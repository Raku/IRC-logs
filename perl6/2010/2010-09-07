[00:00] *** ruoso joined
[00:00] *** ascent_ left
[00:01] *** guidjos left
[00:08] *** rgrau_ left
[00:13] *** ascent_ joined
[00:14] *** Helios joined
[00:22] *** azert0x left
[00:29] *** jhuni joined
[00:33] <Sec> rakudo: ( [], { [$a+1]xx$^a+1 Z~ [1 .. *] } ... * )[6].say

[00:33] <p6eval> rakudo dd6a03: OUTPUT«61 62 63 64 65 66␤»

[00:34] <Sec> rakudo: ( [], { [$a+1]xx$^a+1 Z%% [1 .. *] } ... * )[6].say

[00:34] <p6eval> rakudo dd6a03: OUTPUT«1 0 0 0 0 0␤»

[00:34] <Sec> can someone explain this? I would expect <1 1 1 0 0 1>

[00:35] <colomon> hmmmm

[00:36] <colomon> rakudo: ( [], { [$a+1] xx $^a+1} ... * )[6].say

[00:37] <p6eval> rakudo dd6a03: OUTPUT«6 6 6 6 6 6␤»

[00:37] <colomon> oh

[00:38] <colomon> you're expecting 6 %% 1, 6 %% 2, 6 %% 3, etc?

[00:38] <Sec> jep.

[00:39] <colomon> oh, that's what your first eval there was doing.  gotcha.

[00:39] <colomon> precedence issue, maybe?

[00:39] <colomon> I think that's it.

[00:40] <colomon> ~ and %% have difference precedences.

[00:40] <colomon> rakudo: ( [], { ([$a+1]xx$^a+1) Z%% [1 .. *] } ... * )[6].say

[00:40] <p6eval> rakudo dd6a03: OUTPUT«1 0 0 0 0 0␤»

[00:40] <Sec> nice idea, but that doesn't seem to fix it :)

[00:40] <colomon> or not.  very weird.

[00:40] *** florz joined
[00:41] <colomon> rakudo: ( [], { ([$a+1]xx$^a+1) Z%% [1 .. *] } ... * )[^6].sa

[00:41] <colomon> rakudo: ( [], { ([$a+1]xx$^a+1) Z%% [1 .. *] } ... * )[^6].say

[00:41] <p6eval> rakudo dd6a03: OUTPUT«Method 'sa' not found for invocant of class 'Parcel'␤  in main program body at line 22:/tmp/pupK2R_M5U␤»

[00:41] <p6eval> rakudo dd6a03: OUTPUT«11 01 0 01 0 0 01 0 0 0 0␤»

[00:41] <colomon> rakudo: ( [], { ([$a+1]xx$^a+1) Z%% [1 .. *] } ... * )[^6].perl.say

[00:41] <p6eval> rakudo dd6a03: OUTPUT«([], (Bool::True), (Bool::True, Bool::False), (Bool::True, Bool::False, Bool::False), (Bool::True, Bool::False, Bool::False, Bool::False), (Bool::True, Bool::False, Bool::False, Bool::False, Bool::False))␤»

[00:42] <Sec> rakudo: ([6,6,6,6,6,6] Z%% [1,2,3,4,5,6]).say

[00:42] <p6eval> rakudo dd6a03: OUTPUT«111001␤»

[00:42] *** tylercurtis joined
[00:44] <colomon> rakudo: ( [], { ([$a+1]xx$^a+1) Z%% (1 .. *) } ... * )[^7].perl.say

[00:44] <p6eval> rakudo dd6a03: OUTPUT«([], (Bool::True), (Bool::True, Bool::False), (Bool::True, Bool::False, Bool::False), (Bool::True, Bool::False, Bool::False, Bool::False), (Bool::True, Bool::False, Bool::False, Bool::False, Bool::False), (Bool::True, Bool::False, Bool::False, Bool::False, Bool::False,

[00:44] <p6eval> ..Bool::False)…

[00:44] <Sec> rakudo: ( [], { ([6,6,6,6,6,6]) Z%% ([1 .. *]) } ... * )[6].say

[00:45] <p6eval> rakudo dd6a03: OUTPUT«1 1 1 0 0 1␤»

[00:45] <Sec> rakudo: ( [], { ([6]xx 6) Z%% ([1 .. *]) } ... * )[6].say

[00:45] <p6eval> rakudo dd6a03: OUTPUT«1 0 0 0 0 0␤»

[00:45] <Sec> xx is probably not doing what I expected it to do.

[00:45] <colomon> rakudo: ( [], { (6 xx 6) Z%% ([1 .. *]) } ... * )[6].say

[00:45] <p6eval> rakudo dd6a03: OUTPUT«1 1 1 0 0 1␤»

[00:45] <colomon> rakudo: say ([6] xx 6).perl; say (6 xx 6).perl

[00:45] <p6eval> rakudo dd6a03: OUTPUT«([6], [6], [6], [6], [6], [6])␤(6, 6, 6, 6, 6, 6)␤»

[00:46] <colomon> oh!

[00:46] <colomon> so you were getting [6] %% 2 (etc)

[00:46] <colomon> and [6] in numeric context is 1

[00:46] <Sec> yes!

[00:46] <Sec> rakudo: ( [], { ($a+1)xx$^a+1 Z%% [1 .. * ] } ... * )[6].say

[00:46] <p6eval> rakudo dd6a03: OUTPUT«1 1 1 0 0 1␤»

[00:47] <colomon> there you go.  :)

[00:49] *** plobsing2 is now known as plobsing

[00:52] <snarkyboojum> bonjour hardworking Perl 6 people!

[00:53] <colomon> o/

[00:54] *** Psyche^ joined
[00:54] <snarkyboojum> \o

[00:55] * snarkyboojum has barely looked at a computer screen for more than 2 weeks, so I have some catching up to do :)

[00:58] *** Patterner left
[00:58] *** Psyche^ is now known as Patterner

[01:04] <tylercurtis> TimToady: regarding NFG, are you aware of darbelo's GSoC?

[01:05] <TimToady> no

[01:06] *** Wasp joined
[01:06] <TimToady> colomon: Z should not be working on [] values, since that's a single item in list context

[01:06] *** Wasp left
[01:06] <Sec> how can I elegantly turn ([1,2],[3,4],[5,6]) into ([3],[7],[11]) or (3,7,11) ?

[01:07] <tylercurtis> http://www.parrot.org/darbelo He implemented an NFG encoding for Parrot.

[01:07] *** aloha left
[01:07] <TimToady> tylercurtis: cool

[01:08] <TimToady> Sec: that just looks like a map to me

[01:09] <TimToady> rakudo: say ([1,2],[3,4],[5,6]).map(-> @x { [+] @x }).perl

[01:09] <p6eval> rakudo dd6a03: OUTPUT«(3, 7, 11)␤»

[01:09] *** bacek left
[01:10] <colomon> TimToady: yeah, I was wondering about that.

[01:10] <colomon> I mean, it should work, it should just not work the way it is working.

[01:10] <Sec> TimToady: thanks.

[01:10] <TimToady> that's the difference between hypers and Z/X

[01:11] <TimToady> hypers take a single item, and unpack it for you

[01:11] <TimToady> Z and X expect two lists

[01:11] <TimToady> by the same token, they're eager vs lazy, for similar reasons

[01:11] <TimToady> hypers are for working through existing objects

[01:12] <TimToady> list infixes are for being lazy with lists

[01:12] <TimToady> so Z%% [] should not work over more than one item

[01:13] <TimToady> regardless of how long the list inside [] is

[01:13] <TimToady> in the case of Z%% [1..*], it should be the same as Z%% Inf

[01:14] <TimToady> Z%% 1..* is fine though

[01:14] <TimToady> no parens necessary

[01:14] <TimToady> (or shouldn't be)

[01:19] <pmichaud> rakudo: my $a = [3,5,7];  my @b = 0..10;  say $b[$a];  # checking

[01:19] <p6eval> rakudo dd6a03: OUTPUT«===SORRY!===␤Symbol '$b' not predeclared in <anonymous> (/tmp/zCGcUAog05:22)␤»

[01:19] <pmichaud> rakudo: my $a = [3,5,7];  my @b = 0..10;  say @b[$a];  # checking

[01:19] <p6eval> rakudo dd6a03: OUTPUT«357␤»

[01:19] <pmichaud> yes, bug.

[01:20] <pmichaud> so, what should happen there, ooc? (more)

[01:20] <pmichaud> rakudo:  sub xyz(@a) { say @a.elems; };  my $a = [1,2,3];   xyz($a);

[01:20] <p6eval> rakudo dd6a03: OUTPUT«3␤»

[01:22] <colomon> rakudo: say <a b c> Z~ 1..*

[01:22] <p6eval> rakudo dd6a03: OUTPUT«a1b2c3␤»

[01:30] *** bluescreen joined
[01:30] *** bluescreen is now known as Guest31998

[01:32] <lue> hai o/

[01:33] <lue> .oO(Information on how to get a rakudo commit bit is about as scarce as the commit bits themselves)

[01:39] <Sec> rakudo: (( [1], { ($a+1)xx$^a+1 Z%% 1 .. * } ... * ) ZZ* [1], { [1..($^a+1)] }...*).map(-> @x { (2*@x.elems == [+] @x)??@x.elems!!0 }).grep(*>0)[^2].perl.say

[01:39] <p6eval> rakudo dd6a03: OUTPUT«(timeout)»

[01:40] <Sec> rakudo: (( [1], { ($a+1)xx$^a+1 Z%% 1 .. * } ... * ) ZZ* [1], { [1..($^a+1)] }...*).map(-> @x { (2*@x.elems == [+] @x)??@x.elems!!0 }).grep(*>0)[^1].perl.say

[01:40] <p6eval> rakudo dd6a03: OUTPUT«(6, )␤»

[01:40] <Sec> yay. A really inefficiant way to calculate the first n perfect numbers.

[01:41] <Sec> someone who knows perl6 could probably beautify this a lot. But I'm happy that it works at all %)

[01:43] <Util> rakudo: for [\,] < a b c > -> $n { my @o =      @($n) ; say @o.elems, @o.perl };

[01:43] <p6eval> rakudo dd6a03: OUTPUT«1["a"]␤2["a", "b"]␤2[("a", "b"), "c"]␤»

[01:43] <Util> rakudo: for [\,] < a b c > -> $n { my @o = flat(@($n)); say @o.elems, @o.perl };

[01:44] <p6eval> rakudo dd6a03: OUTPUT«1["a"]␤2["a", "b"]␤2[("a", "b"), "c"]␤»

[01:44] <Util> Trying to get all three elements.

[01:44] <Util> How to recursively flatten? Doesn't S03 say that "The C<flat> contextualizer" will handle it?

[01:45] *** whiteknight left
[01:45] <pmichaud> rakudo:  say ([\,] <a b c>).perl

[01:46] <p6eval> rakudo dd6a03: OUTPUT«("a", ("a", "b"), (("a", "b"), "c"))␤»

[01:46] <pmichaud> rakudo:  say ([\,] <a b c>).flat.perl

[01:46] <p6eval> rakudo dd6a03: OUTPUT«("a", ("a", "b"), (("a", "b"), "c"))␤»

[01:46] <pmichaud> hmmmmm

[01:46] <pmichaud> (once again, I'm not happy with the definition of .perl)

[01:46] <pmichaud> rakudo:  say ([\,] <a b c>).[0].WHAT

[01:46] <p6eval> rakudo dd6a03: OUTPUT«Str()␤»

[01:47] <pmichaud> rakudo:  say ([\,] <a b c>).[1].WHAT

[01:47] <p6eval> rakudo dd6a03: OUTPUT«Seq()␤»

[01:47] *** JimmyZ joined
[01:48] <pmichaud> Util: C<flat>  only really handles one level of flattening

[01:48] <pmichaud> rakudo:  say ([\,] <a b c>)>>flat.perl

[01:48] <p6eval> rakudo dd6a03: OUTPUT«===SORRY!===␤Confused at line 22, near "say ([\\,] "␤»

[01:48] <pmichaud> rakudo:  say ([\,] <a b c>)>>.flat.perl

[01:48] <p6eval> rakudo dd6a03: OUTPUT«(("a"), ("a", "b"), (("a", "b"), "c"))␤»

[01:49] <Util> pmichaud: S03 says "The result will be recursively flattened"

[01:50] <pmichaud> Util: I suspect that's a fossil.

[01:50] <Util> Alternately, if I need recursive flattening, what should I use instead of `flat()`?

[01:51] <Sec> rakudo: sub perf($n) { $n == ([+] grep ($n %% *), ^ $n) };(1..*).grep(perf(*))[^2].perl.say

[01:51] <p6eval> rakudo dd6a03: OUTPUT«Can't take numeric value for object of type Whatever␤  in 'Any::Numeric' at line 1341:CORE.setting␤  in 'prefix:<^>' at line 6794:CORE.setting␤  in 'perf' at line 22:/tmp/g2Tay9MXjl␤  in main program body at line 22:/tmp/g2Tay9MXjl␤»

[01:51] <pmichaud> I don't quite know the answer to that one.  Also, I'm not sure that [\,] should be producing Seq's

[01:52] <Sec> hm. why doesn't  .grep(perf(*)) work as expected?

[01:52] <pmichaud> Sec: perf(*) doesn't create a closure.

[01:52] <pmichaud> you need  { perf($_) }

[01:52] <pmichaud> or you can do   *.&perf

[01:53] <Sec> ah, thanks :)

[01:54] <Util> pmichaud: that was my next issue; S03 shows "triangular comma" as a list of arrays, not Seq.

[01:54] <pmichaud> I suspect that is a rakudobug.

[01:55] <Sec> rakudo: (( [1], { ($a+1)xx$^a+1 Z%% 1 .. * } ... * ) ZZ* [1], { [1..($^a+1)] }...*).map(-> @x { (2*@x.elems == [+] @x)??@x.elems!!0 }).grep(*>0)[^2].perl.say

[01:55] <Sec> ah, no.

[01:55] <p6eval> rakudo dd6a03: OUTPUT«(timeout)»

[01:56] <Sec> rakudo: sub perf($n) { $n == ([+] grep ($n %% *), ^ $n) };(1..*).grep(1==perf($_))[^2].perl.say'

[01:56] <p6eval> rakudo dd6a03: OUTPUT«===SORRY!===␤Confused at line 22, near "(1..*).gre"␤»

[01:57] <Sec> rakudo: sub perf($n) { $n == ([+] grep ($n %% *), ^ $n) };(1..*).grep(1==perf($_))[^2].perl.say

[01:57] <p6eval> rakudo dd6a03: OUTPUT«Use of uninitialized value in numeric context␤Use of uninitialized value in numeric context␤(1, 2)␤»

[01:58] <Sec> this confuses me %)

[01:58] <Sec> I should probably go to bed.

[01:59] <Sec> Or can anyone explain that to me?

[01:59] <pmichaud> Sec: grep expects a closure there

[02:00] <pmichaud> rakudo: sub perf($n) { $n == ([+] grep ($n %% *), ^ $n) }; (1..*).grep({ perf($_) == 1 })[^2].perl.say

[02:00] <p6eval> rakudo dd6a03: OUTPUT«Divide by zero␤  in 'infix:</>' at line 3856:CORE.setting␤  in 'infix:</>' at line 3475:CORE.setting␤  in 'infix:<%>' at line 3480:CORE.setting␤  in 'infix:<%%>' at line 449:CORE.setting␤  in <anon> at line 22:/tmp/unmLsnyM2X␤  in 'Block::ACCEPTS' at line 5803:CORE.setting␤ 

[02:00] <p6eval> ..in <an…

[02:01] *** jhuni left
[02:04] <Sec> pmichaud: thats an improvement :)  ( but yes, thanks, i understand now i was mixing closure an block again)

[02:05] <Sec> still, i can't get it to work properly.

[02:05] <Sec> But I'll try tomorrow. its way to late here now

[02:05] <Util> pmichaud: thanks

[02:06] * Util sleeps

[02:06] *** JimmyZ left
[02:08] *** agentzh joined
[02:13] <gfldex> rakudo: my %a; %a.push("a" => Pair.new(:key("a"), :value(1,2,3))); say [+]%a<a>.value;

[02:13] <p6eval> rakudo dd6a03: OUTPUT«3␤»

[02:13] <gfldex> rakudo: my %a; %a.push("a" => Pair.new(:key("a"), :value(1,2,3))); say [+]@(%a<a>.value);

[02:13] <p6eval> rakudo dd6a03: OUTPUT«6␤»

[02:13] <gfldex> why do i need that typecast?

[02:15] <pmichaud> because the value of a Pair is an item

[02:15] <pmichaud> (which doesn't flatten by default)

[02:18] <gfldex> where would that be useful?

[02:18] <pmichaud> anytime you want to treat an Array or Seq as a unit instead of as individual elements

[02:19] <tylercurtis> for %foo.kv -> $k, $v {...}

[02:19] <tylercurtis> Weirdness ensures if Pair.value flattens.

[02:19] <gfldex> i c

[02:20] <pmichaud> tylercurtis++  # excellent example

[02:20] <tylercurtis> Or %foo.values, too.

[02:20] <gfldex> could [+] be teach to behave nicely?

[02:21] <gfldex> because that confusion will be found a lot

[02:21] <tylercurtis> Although I guess those could be special-cased, but that would be unintuitive, I think.

[02:40] *** kcwu joined
[03:00] *** jhuni joined
[03:07] *** justatheory left
[03:12] *** flatwhatson joined
[03:17] *** mfollett joined
[03:20] *** colomon left
[03:21] *** colomon joined
[03:21] *** Guest31998 left
[03:26] *** Guest31998 joined
[03:37] *** Alias joined
[03:39] *** meppel joined
[03:43] *** meppl left
[04:11] *** patspam left
[04:14] <mfollett> If I make a subroutine with a parameter of type 'Rat' it can't be an 'Int', is that a bug or a feature? :D

[04:14] <sorear> Feature, for now

[04:14] <mfollett> ok

[04:14] <sorear> We haven't completely figured out how type constraints work on numbers yet

[04:15] <sorear> for now, if you want to accept any real number, you need to use Real

[04:15] *** meppel left
[04:15] <mfollett> good to know, thanks! sorear++

[04:15] <sorear> eventually it would be cool if you could say "Num" and have 42, "42", 42.0, and 42.0 + pi - pi all work

[04:16] <sorear> and have them all be coerced to Num

[04:16] <mfollett> that would be cool

[04:16] <sorear> good * #perl6

[04:17] <sorear> araujo: You're the only native speaker of Spanish that I can remember being in here

[04:17] <tylercurtis> sorear: as Num?

[04:17] <sorear> other than darbelo, who has vanished and left the #parrot string rewrite dangling :(

[04:26] <mfollett> Is there a service list gist.github where I can upload Perl6 snippets and they be color formatted?  Gist won't do Perl6. :( 

[04:29] <dalek> rakudo: 8cf7fcd | pmichaud++ | src/Perl6/Actions.pm:

[04:29] <dalek> rakudo: Switch 'for' statement modifier to use 'map' internally.

[04:29] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8cf7fcdd4b3f7481eca80fd0a4a783b7ce20ac35

[04:32] *** mfollett left
[04:38] <sorear> moritz_: What exactly did you want me to do with json-tiny?

[04:44] *** QinGW joined
[05:03] *** Sec left
[05:07] *** Sec joined
[05:08] *** plobsing left
[05:12] <TimToady> a list in list context flattens to list, so .flat is of necessity recursive

[05:42] *** masak joined
[05:43] <masak> oh hai, #perl6!

[05:44] <sorear> Hello masak!

[05:44] <masak> missed the sunset today. ah well, can't catch 'em all. :)

[05:44] <masak> s/sunset/sunrise/

[05:45] * sorear doesn't usually catch sunrises :(

[05:45] <masak> sorear: where're you at?

[05:46] <masak> specifically, what's your latitude? :)

[05:48] <sorear> 32 N

[05:52] <masak> ah. I live at 59 N

[05:52] <masak> that should mean that your sunrises are more easily catchable than mine... :)

[05:53] <sorear> not when your habitual sleep schedule is 3am-11am

[05:53] <sorear> otoh, I never miss a sunset.

[05:54] <masak> :)

[05:55] <araujo> sorear, oh, ok :)

[05:57] *** kaare joined
[05:58] *** kaare is now known as Guest27819

[06:01] <masak> [backlog] +1 on special-casing leading whitespace in rules.

[06:01] <masak> I just browsed through STD.pm6 looking for rules. they fall into a number of different classes wrt this.

[06:02] <masak> (1) those that consist solely of a group with alternatives

[06:02] <masak> (2) one that just calls down to another rule

[06:03] <masak> (3) those that explicitly make sure not to have any leading whitespace

[06:03] <araujo> masak!

[06:03] <masak> araujo! \o/

[06:03] <masak> it would be worth it just to get rid of (3). it's easy enough for people to add back a <.ws> call, should they wish to.

[06:03] <sorear> masak: I skipped backlog 'cause there was so much of it

[06:04] <sorear> I am so +1 for special casing leading whitespace that I did it long ago

[06:04] <masak> :)

[06:04] <sorear> in fact, STD.pm6 depends on it

[06:04] <sorear> [ foo | bar ] # this won't work if there are <ws> calls at the beginning of the alternatives, since <.ws> always breaks LTM

[06:05] <masak> right.

[06:05] <masak> but S05 only makes it seem that this applies to alternatives.

[06:05] <masak> not a whole rule block.

[06:05] <masak> that's why I included (1) above, because I know there's such an exception.

[06:05] <sorear> alternatives were the only case I needed when I was making STD-on-STD work

[06:06] *** uniejo joined
[06:06] <masak> right. what I'm arguing for here is a similar special case for start-of-rule.

[06:14] *** cotto joined
[06:15] *** wtw joined
[06:17] <moritz_> good morning

[06:18] <masak> o/

[06:18] *** redicaps joined
[06:18] <moritz_> sorear: I gave you a commit bit so that you can maintain a niecza-compatible version of JSON::Tiny in a branch

[06:18] <moritz_> sorear: just an offer, not a requirement

[06:20] <masak> rakudo: ( [], { ($a+1)xx$^a+1 Z%% [1 .. * ] } ... * )[6].say

[06:21] <p6eval> rakudo 8cf7fc: OUTPUT«1 1 1 0 0 1␤»

[06:21] <masak> std: ( [], { ($a+1)xx$^a+1 Z%% [1 .. * ] } ... * )[6].say

[06:21] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $a is not predeclared at /tmp/DnStgHxFAw line 1:␤------> [32m( [], { ($a[33m⏏[31m+1)xx$^a+1 Z%% [1 .. * ] } ... * )[6].sa[0m␤Check failed␤FAILED 00:01 119m␤»

[06:21] <masak> that one's already submitted, on one for or other.

[06:21] <masak> s/for/form/

[06:22] <diakopter> well this is weird

[06:23] <diakopter> where did TT's commit from this morning go..

[06:23] <diakopter> oh, it's in specs, nm

[06:28] <sorear> moritz_: ah.

[06:36] *** rbuels joined
[06:42] *** cjk101010 joined
[06:45] *** sftp left
[06:48] *** rhebus joined
[06:49] <rhebus> I'm trying to run Ovid's primes example from http://blogs.perl.org/users/ovid/2010/08/prime-factors-in-perl-6.html

[06:50] <rhebus> but I get "Method 'Bridge' not found for invocant of class 'Failure' /   in 'infix:<**>' at line 3425:CORE.setting /   in 'is-prime' at line 107:P36-ovid.pl ..."

[06:50] * masak tries

[06:50] <rhebus> line 107 is "die "$number is too large" if $number > @PRIMES[*-1]**2;"

[06:50] *** svetlins left
[06:51] <rhebus> you have to copy 2 code blocks mind, the prime-factors block and the my @PRIMES block

[06:51] <masak> nodnod

[06:51] <masak> ok, error reproduced.

[06:51] <masak> debugging.

[06:51] * sorear finds a nasty niecza bug the hard way...

[06:52] <moritz_> rhebus: probably means that @PRIMES is empty

[06:52] <masak> say @PRIMES[*-1].WHAT --> Failure()

[06:53] <masak> say @PRIMES.elems --> 0

[06:53] <masak> moritz_++

[06:53] <rhebus> :/

[06:53] <masak> oh!

[06:53] <masak> the for loop must come after the @PRIMES assignment.

[06:53] <rhebus> i just came to the same conclusion

[06:53] *** lamstyle joined
[06:53] <masak> Ovid's code layout is slightly misleading.

[06:54] <masak> feel free to make a comment to that effect.

[06:54] <rhebus> i would if I could comment, but ovid's blog won't let me

[06:54] <rhebus> i could email him though

[06:54] <masak> I'll try to comment. I think they fixed commenting for me.

[06:54] <masak> it's been very broken in the past.

[06:55] <sorear> It doesn't even let me *view* masak's blog comments

[06:55] <rhebus> "Text entered was wrong."

[06:55] <masak> sorear: that's use.perl.org

[06:55] <sorear> niecza: say "c" ~~ / a | [ b || c ] / # RFC

[06:55] <p6eval> niecza 83c3bc3: OUTPUT«0␤»

[06:55] <rhebus> what is niecza?

[06:56] <masak> sorear: don't see why that shouldn't match.

[06:56] * moritz_ neither

[06:57] <sorear> masak: || hides any tokens on the right from LTM S05:2586

[06:57] <sorear> niecza's | sees that 'a' and 'b' are valid longest tokens, c matches neither

[06:57] <masak> oh, ok.

[06:57] <moritz_> sorear: I'd expect it hide 'b' too

[06:57] <moritz_> but it should still match, just not as LTM

[06:57] <sorear> the only plausible things to do are 1. fallback to || semantics 2. fallback to <!>

[06:58] <masak> sorear: what moritz_ said.

[06:59] <sorear> rhebus: http://github.com/sorear/niecza

[06:59] <sorear> masak: I see

[07:00] <rhebus> sorear: cool beans

[07:00] <rhebus> is it a pun on nietzsche?

[07:01] *** nadim joined
[07:01] <sorear> no

[07:01] <masak> posted.

[07:01] <sorear> it was named by a late night brainstorming session with masak++

[07:02] <masak> rhebus: based on a Czech music video :)

[07:02] <sorear> it doesn't actually mean anything, because masak had his Polish and Czech wires crossed at the time

[07:02] <rhebus> hehe

[07:02] <sorear> but it still sounds cool and it's still unique

[07:02] <masak> they're always crossed.

[07:02] <rhebus> those crazy slavs

[07:02] <rhebus> i had thought rakudo was the only active perl 6 implementation

[07:04] <masak> sorear: and for what it's worth, it *is* the same word in Polish, "czas", as in Czech, "čas". the difference is just orthographic.

[07:09] <tylercurtis> rhebus: You didn't even know about Yapsi? It's the only "official and complete" implementation of Perl 6! (http://use.perl.org/~masak/journal/40519)

[07:09] <masak> "it's a feature for the compiler to look confused when it actually *is* confused. (In Perl 5 this was not always so)" -- A12

[07:10] <sorear> Would it be reasonable to say that | always falls back to || if picking based on declarative prefixes doesn't work?

[07:10] <masak> sorear: I have no gut feeling about that. do you have an example?

[07:11] <sorear> masak: "a" ~~ / [a || b] | c /

[07:11] <masak> sorear: at first blush, it feels like a safe fallback to me.

[07:11] <sorear> hmm wait.

[07:12] <sorear> I think I have another, more subtle bug

[07:12] <masak> because | is essentially || but with perks.

[07:12] <tylercurtis> Good night, #perl6.

[07:12] <moritz_> [a || b] | c    has a declarative prefix of c | ''   

[07:12] <sorear> [a || b] currently generates a declarative prefix automaton of /a/

[07:12] <moritz_> and if the c doesn't match, it tries a || b

[07:12] <masak> good night, tylercurtis. dream of official and complete implementations.

[07:13] <sorear> maybe it should generate /a?/ instead?

[07:13] <sorear> (or /<?>/, if moritz_ is right about || hiding both sides)

[07:13] <moritz_> note that  [a || b] and [|| a || b] are synonymous

[07:14] <moritz_> bbl

[07:18] <tylercurtis> masak: more likely, I shall dream about an unofficial and completely incomplete implementation that I've finally gotten the tuits to work on. However, thank you, nonetheless.

[07:18] <masak> :)

[07:18] <masak> fair enough. dream about tuits.

[07:18] *** tylercurtis left
[07:25] <dalek> niecza: 4926d3c | sorear++ | / (6 files):

[07:25] <dalek> niecza: Implement caching of lexers

[07:25] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4926d3cd39cffabcbf8c49c68b33e66e78c26a9e

[07:25] <dalek> niecza: 4819d25 | sorear++ | / (2 files):

[07:25] <dalek> niecza: Fix || not generating any declarative prefix at all

[07:25] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4819d25342a6c508f55c45a8967ec2972c5d5da5

[07:28] <sorear> 60101 chars in 57.71s user, not too bad

[07:29] *** azert0x joined
[07:32] <masak> perl6: say +(3 => 4)

[07:32] <p6eval> pugs: OUTPUT«2␤»

[07:32] <p6eval> ..rakudo 8cf7fc: OUTPUT«maximum recursion depth exceeded␤  in 'Cool::Numeric' at line 1747:CORE.setting␤  in 'Cool::Numeric' at line 1748:CORE.setting␤  in 'Cool::Num' at line 6794:CORE.setting␤  in 'Cool::Numeric' at line 1747:CORE.setting␤  in 'Cool::Numeric' at line 1748:CORE.setting␤  in

[07:32] <p6eval> ..'Cool::Num' a…

[07:33] <masak> since pairs sort on keys nowadays, I'd argue that maybe they should numify to their key as well.

[07:45] <moritz_> they sort on key first, then on value

[07:50] *** rhebus left
[07:50] <masak> oh, indeed.

[07:51] <masak> but that means that if you're only interested in sorting on key, then it'll DWYM.

[07:51] <moritz_> I'm not sure numification can be made sensible

[07:51] <masak> TimToady++ has been utilizing that recently in Rossetta Code.

[07:51] <masak> (sorting on key)

[07:52] *** rhebus joined
[07:53] *** daxim joined
[07:54] *** rgrau joined
[07:54] <moritz_> do you have a specific use case for pair numification?

[07:55] <moritz_> I imagine that in the context of hashes, a pair often has the form Str => Numeric

[07:55] <moritz_> numifying that to .key.Numeric would be rather confusing (and often 0)

[07:58] <masak> I just stumbled over this old p6l thread, and wanted to check how we eventually solved it: http://markmail.org/message/d5kxskrpsdolxcx3

[07:58] <masak> seems we didn't.

[07:59] <moritz_> pseudo code on p6l for things where perfectly fine real Perl 6 code exists

[08:00] * moritz_ finds that sad, and very telling

[08:01] <masak> not sure we had *.key et al in 2008.

[08:01] <masak> if we did, it wasn't widespread.

[08:01] <moritz_> {.key} isn't too hard to remember either

[08:02] <masak> I actually don't find it sad; p6l is full of interested people from other disciplines (Perl 5, or Haskell, or other ones) who bring in ideas but seemingly don't have time to fully learn the language.

[08:02] *** zag joined
[08:03] <masak> it fills the same function as one-time contributors to Wikipedia.

[08:03] <masak> i.e. the core idea may be worth retaining even if the syntax is off, and core people will come afterwards and clean it up.

[08:04] <moritz_> that's right; but when I ask some question about how to implement a particular feature, that's not what I'm after

[08:05] <masak> then you probably shouldn't ask on p6l :)

[08:05] <moritz_> rakudo: say "aaabaabc" ~~ m:ratchet/a .+*? bc/

[08:05] <p6eval> rakudo 8cf7fc: OUTPUT«===SORRY!===␤Confused at line 22, near "say \"aaaba"␤»

[08:05] <masak> in some ways, p6l is the continuation of the RFC process -- wild, unchecked, pie-in-the-sky, monte carlo.

[08:06] <moritz_> right, and I'd argue that our needs are shifting away from that

[08:06] <masak> agreed.

[08:06] <moritz_> rakudo: say "aaabaabc" ~~ m/:ratchet a .+*? bc/

[08:06] <p6eval> rakudo 8cf7fc: OUTPUT«===SORRY!===␤Confused at line 22, near "say \"aaaba"␤»

[08:07] <moritz_> std: say "aaabaabc" ~~ m/:ratchet a .+*? bc/

[08:07] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Quantifier quantifies nothing at /tmp/24FPao9zMa line 1:␤------> [32msay "aaabaabc" ~~ m/:ratchet a .+*?[33m⏏[31m bc/[0m␤Check failed␤FAILED 00:01 119m␤»

[08:07] <moritz_> rakudo: say "aaabaabc" ~~ m:ratchet/a .+? bc/

[08:07] <p6eval> rakudo 8cf7fc: OUTPUT«===SORRY!===␤Adverb 'ratchet' not allowed on m at line 22, near ""␤»

[08:07] <moritz_> rakudo: say "aaabaabc" ~~ m/:ratchet a .+? bc/

[08:07] <p6eval> rakudo 8cf7fc: OUTPUT«aaabaabc␤»

[08:07] <masak> but I'd rather let p6l evolve that way in its own pace than forcibly shut up people who still live in the RFC era.

[08:07] <moritz_> rakudo: say "aaabaabc" ~~ m/:ratchet a .+? 'b' 'c'/

[08:07] <p6eval> rakudo 8cf7fc: OUTPUT«aaabaabc␤»

[08:08] <masak> only to a limited extent can one redristibute people over the unevenly distributed already-here future. :)

[08:08] <moritz_> rakudo: my $c = 'c'; say "aaabaabc" ~~ m/:ratchet a .+? 'b' $c/

[08:08] <p6eval> rakudo 8cf7fc: OUTPUT«aaabaabc␤»

[08:08] <moritz_> agreed

[08:08] <jnthn> morning, #perl6

[08:08] <masak> jnthn! \o/

[08:09] <mathw> oh hai jnthn

[08:09] <moritz_> \o

[08:09] <masak> and just like with natural torrents, the wild forces on p6l can be harnessed for good if one knows how.

[08:09] <jnthn> ...we're looking at using p6l to generate electricity now? :-)

[08:09] <masak> just don't expect them to run their code through an actual implementation :)

[08:10] <masak> "We have a compiler now? What is this, 2010?"

[08:10] <masak> "Quick, give me a newspaper!"

[08:12] <sorear> hello jnthn 

[08:14] *** timbunce joined
[08:17] <jnthn> hi sorear 

[08:19] *** robins joined
[08:20] <masak> also, the only way to have higher code standards on p6l is to raise the code standards on p6l :)

[08:21] <masak> maybe start to write "This code runs under the August release of Rakudo Star."

[08:21] *** jiyinyiyong joined
[08:21] <masak> and "I couldn't get your code to work. Did you try it with a real compiler?"

[08:22] <moritz_> nqp-rx: /a+/

[08:22] <moritz_> masak: :-)

[08:22] <moritz_> nqp: /a+/

[08:22] <p6eval> nqp:  ( no output )

[08:22] <moritz_> nqp: /a+*/

[08:22] <p6eval> nqp: OUTPUT«Confused at line 1, near "/a+*/"␤current instr.: 'parrot;HLL;Grammar;panic' pc 552 (src/cheats/hll-compiler.pir:205)␤»

[08:22] <dalek> niecza: 09519c3 | sorear++ | / (4 files):

[08:22] <dalek> niecza: Add a very simple regex optimizer.  ~2% win so far

[08:22] <dalek> niecza: review: http://github.com/sorear/niecza/commit/09519c34af1c40fd955b0ff524d845445e4e5ccf

[08:22] <moritz_> std: /a+*/

[08:22] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Quantifier quantifies nothing at /tmp/5J9FdW0jth line 1:␤------> [32m/a+*[33m⏏[31m/[0m␤Check failed␤FAILED 00:01 116m␤»

[08:23] <sorear> a+:, a+?, a+!

[08:26] * moritz_ tries to get good error messages in nqp-rx

[08:26] *** dakkar joined
[08:30] *** bacek joined
[08:33] <dalek> nqp-rx: 237bf91 | moritz++ | src/Regex/P6Regex/Grammar.pm:

[08:33] <dalek> nqp-rx: introduce "Quantifier quantifies nothing" error message

[08:33] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/237bf91d8cd9edfc9ab959b720f9971c8552c49e

[08:33] *** aloha joined
[08:33] <aloha> aloha: rhebus asked me to tell you to shut up

[08:34] *** qwebirc4893 joined
[08:34] *** zag left
[08:34] <sorear> interesting, ~25% of niecza's runtime is spent creating object slot hashes

[08:34] <masak> wow, aloha actually delivers messages to herself.

[08:34] <sorear> I knew that was a bit wasteful, but wow

[08:36] <rhebus> aloha: you numpty

[08:40] *** thebird joined
[08:41] *** jiyinyiyong left
[08:46] *** patrickas joined
[08:46] <patrickas> hello all

[08:46] <moritz_> o/

[08:47] <patrickas> \o boss

[08:47] <patrickas> is http://perlcabal.org/syn/S03.html#line_1989 officially reversed? as per yesterday's discussion ?

[08:48] * moritz_ hasn't followed the discussion closely enough to know

[08:50] <patrickas> I suppose my patch is still valid untill the spec actually changes && the fat lady sings! :-) 

[08:51] <masak> "Perl 6 -- continually released since 1997!" -- http://web.archive.org/web/20000815230706/http://www.primenet.com/~kirbyh/perl6

[08:51] <masak> not a quote from the email, which however contains lots of other memorable quotes.

[08:52] *** Guest27819 is now known as kaare_

[08:54] <moritz_> it does :-)

[08:58] <smash> mornin' everyone

[08:58] <patrickas> 1997! 13 years any you guys haven't realeased anythign yet! Ha!

[08:58] <patrickas> s/any/and/

[08:59] <jnthn> How unlucky. :-)

[09:01] <smash> moritz_: remember beadsort from rosetta code ? check http://gist.github.com/568057

[09:01] <masak> patrickas: nono, the *release* was in 1997. that's why we haven't needed to release anything after that :)

[09:02] <moritz_> smash++ # very nice

[09:02] <masak> ooh, in this old article, MJD describes a few more aspects of the fateful cup-smashing meeting (sans cup, though): http://www.perl.com/pub/2000/07/perl6.html

[09:03] <smash> moritz_: i added the transposed fuction to my List::Util, which made everything else easier

[09:03] <masak> other interesting tidbits: "Larry promised not to abandon Perl 5." -- "CPAN itself can serve as a test suite for Perl 6: When it can run most of the things in CPAN, either directly or post-translation, it's ready."

[09:04] *** Axius joined
[09:05] <smash> phenny: tell TimToady beadsort in Perl 6 (translated from haskell) http://gist.github.com/568057

[09:05] <phenny> smash: I'll pass that on when TimToady is around.

[09:05] <moritz_> smash: now put it on rosetta code :-)

[09:05] <smash> moritz_: first i would like to get the translation sub into List::Util

[09:06] <masak> oh, and the end is hilarious: there was the possibility that Perl 6 would provide strong type checking. :) possibly with a `use strict 'typechecking'` directive :P

[09:06] <moritz_> who wrote the original List::Util?

[09:06] <masak> smash++ # List::Utils

[09:07] <masak> smash: parens on line 7 are redundant. but you probably know that.

[09:07] *** daxim left
[09:07] <jnthn> masak: That last one still isn't outside the realms of possibility. :-)

[09:07] <smash> colomon is the owner of the github repo

[09:07] *** M_o_C joined
[09:07] <masak> jnthn: what I found funny is the idea of a pragma for it. it's much more grown into the language now.

[09:08] <smash> masak: yes, but it feels more like a list with them :-)

[09:08] *** REPLeffect left
[09:08] <masak> smash: I disagree. to me it just looks like a holdover from Perl 5.

[09:08] <masak> but you're free to write it as you want, of course.

[09:09] <smash> well, you got a point there

[09:09] <jnthn> masak: I dunno. A pragma that says "everything here must have statically known types" isn't so ridiculous. We're gradually typed by default, of course, and will use what info there is.

[09:09] <masak> jnthn: oh, indeed. interesting.

[09:10] <smash> masak: removed the parens :-)

[09:10] *** daxim joined
[09:11] <jnthn> masak: Reassuringly, I think the stuff I'll be doing in the coming months will give the infrastructure that will let somebody implement such a thing.

[09:12] <jnthn> Nice when the design fits use cases I didn't consider yet. :-)

[09:12] <moritz_> waitwaitwait

[09:12] <moritz_> everything is strictly type-checked in Perl 6

[09:13] <moritz_> just often the type is Any or Mu

[09:13] <moritz_> but it's still strictly type-checked

[09:14] <moritz_> or are you thinking about compile time type-checking stuff?

[09:14] <jnthn> moritz_: compile time

[09:14] <masak> \o/

[09:14] <masak> that'll be AWESOME.

[09:14] <moritz_> that would require return type declaration on basically all built-ins to work

[09:15] <jnthn> moritz_: Yeah, just 'cus we'll be able to implement it doesn't automatically mean it'd be a particularly fun pragma to work under.

[09:15] <jnthn> In fact, I suspect most Perl folks would find it annoying. 

[09:16] *** bacek left
[09:16] <jnthn> We probably need some middle ground where it tells you helpful stuff.

[09:16] *** aloha left
[09:17] <masak> let's continue this discussion when we have the tech :)

[09:17] <daxim> needs moar inference

[09:17] <jnthn> masak: Aye.

[09:18] <jnthn> masak: I really do want to give us the pieces we'll need to build just static analysis stuff in Rakudo though.

[09:18] <jnthn> s/just/such/

[09:18] <masak> daxim: autopun :)

[09:18] <daxim> go go go grant manager!

[09:19] <sorear> when you figure out, I'd like to know too

[09:19] <moritz_> even detecting things as  my Int $x = "foo"  at compile time would be great

[09:19] <sorear> I have the tech to eliminiate runtime name lookups, given type data

[09:19] <moritz_> and invalidate significant parts of the test suite :-)

[09:20] <jnthn> "Sorry, this test file is too stupid to run."

[09:21] <moritz_> exactly

[09:22] <daxim> "Sorry, this is an infinite loop."   http://perl.plover.com/yak/typing/samples/slide030.html

[09:23] *** REPLeffect joined
[09:24] <moritz_> curios that in the article masak++ linked to, TimToady++ didn't seem to like having a spec, and favoured a reference implementation.

[09:25] *** envi^home joined
[09:27] <masak> aye. Pugs changed that view, I think.

[09:30] *** ssm joined
[09:31] <rhebus> wow, you can use - in identifiers \o/ I'm slightly too excited about this feature.

[09:32] <daxim> apropos pugs, the haskell guy I wanted to meet yesterday is on vacation, so I'll just bug some knowledgable people on IRC about the compiler warnings when I have time, or perhaps hallway trackdown some at the opensuse conference

[09:36] *** Axius left
[09:39] <sorear> hi.  I'm a haskell guy

[09:40] <masak> rhebus: yes, you can use them between two alphabetics.

[09:44] <dalek> niecza: c54087f | sorear++ | / (5 files):

[09:44] <dalek> niecza: Store object fields in an array

[09:44] <dalek> niecza: 

[09:44] <dalek> niecza: We still use a dictionary and name lookup for getting indexes; that will need

[09:44] <dalek> niecza: to be fixed.  50% speedup on the parser benchmark

[09:44] <dalek> niecza: review: http://github.com/sorear/niecza/commit/c54087f32fdab5cd4de1d5e60572829870f98fe0

[09:52] <masak> is 'last LABEL' restricted to loop blocks? what'd happen if LABEL wasn't on a loop block?

[09:55] *** bacek joined
[09:55] * sorear out

[09:56] <masak> I don't believe it would (or should) work, but I can see how it could work. :)

[09:57] <masak> probably should use 'leave LABEL' or something instead, and reserve 'last' for loops.

[09:58] <masak> though now that I think about it, 'last' and 'leave' are very similar.

[10:01] *** redicaps left
[10:02] *** aloha joined
[10:02] *** QinGW left
[10:02] *** agentzh left
[10:05] *** mahen joined
[10:06] *** mahen left
[10:12] *** smash left
[10:20] *** smash joined
[10:31] *** amkrankruleuen left
[10:31] *** Cyrus joined
[10:32] *** aloha left
[10:32] *** aloha joined
[10:36] *** amkrankruleuen joined
[10:38] <colomon> masak, moritz_: should 3 => 4 numify to 3 + 4i?  

[10:40] <jnthn> o.O

[10:44] *** amkrankruleuen left
[10:45] *** kjeldahl joined
[10:49] *** amkrankruleuen joined
[10:55] <colomon> hmmm, actually, then what do you do if you numify 3 => (2 + 2i)?  so probably not a good plan.

[10:56] <jnthn> colomon: I thought that paris generally behave like the value.

[10:56] <jnthn> Maybe that makes sense for numification too.

[10:56] <jnthn> rakudo: say +(a => 42)

[10:56] <p6eval> rakudo 8cf7fc: OUTPUT«maximum recursion depth exceeded␤  in 'Cool::Numeric' at line 1747:CORE.setting␤  in 'Cool::Numeric' at line 1748:CORE.setting␤  in 'Cool::Num' at line 6794:CORE.setting␤  in 'Cool::Numeric' at line 1747:CORE.setting␤  in 'Cool::Numeric' at line 1748:CORE.setting␤  in

[10:56] <p6eval> ..'Cool::Num' a…

[10:56] <jnthn> youch

[10:56] <Quadrescence> a => b numifies to a + bi, so 3 => (2+2i) numifies to 3 + (2+2i)i = 3 + 2i - 2 = 1 + 2i

[10:57] <colomon> jnthn: for sorting, they generally behave like the key

[10:57] <jnthn> Oh.

[10:57] <jnthn> Yeah, that makes sense for sorting I guess.

[10:57] <colomon> for comparison, I guess.

[10:57] <colomon> actually, can't say I understand why we're getting the recursion here.

[10:57] <jnthn> Don't fancy pairs becoming another way to construct complex numbers though

[10:57] <jnthn> That'd just be surprising.

[10:58] <jnthn> s/be/be too/

[10:58] <jnthn> imho

[10:59] *** mikehh joined
[11:01] <colomon> oooo!

[11:01] <colomon> I see the problem.

[11:02] <colomon> Cool::Numeric does pir::set__NP(self)

[11:02] <colomon> which calls .Num on self

[11:02] <colomon> Cool.Num does (+self).Num

[11:02] <colomon> infinite loop

[11:03] <colomon> on any class which does not have its own .Numeric and/or .Num defined

[11:03] <colomon> my bad

[11:06] *** jhuni left
[11:10] *** M_o_C left
[11:17] *** snearch joined
[11:17] <colomon> i don't have any clever notions on how to fix it.  :(

[11:28] *** Axius joined
[11:32] *** amkrankruleuen left
[11:33] <moritz_> add a Pair.Numeric method that fail()s?

[11:35] *** Mowah joined
[11:36] *** rschuster joined
[11:38] <masak> colomon: re pairs numification and complex numbers: oh no please no

[11:38] *** rschuster is now known as rainerschusetr

[11:39] *** rainerschusetr is now known as rainerschuster

[11:39] <sjn> moritz_, pmichaud: updated wall segment (which, if all goes well, is the one sent to the print shop): 1400 – 1700             Parallelle sesjoner:

[11:39] <sjn> gah

[11:40] <sjn> http://dl.dropbox.com/u/3809132/JavaZone/Perl_JZ2010_965x2000_Trykk.pdf

[11:40] <sjn> that's the one

[11:40] * sjn curses the clipboard schism on linuces

[11:41] <moritz_> nice

[11:41] *** amkrankruleuen joined
[11:42] *** meppl joined
[11:44] <sjn> it doesn't say "Perl6" anymore, but is probably much better anyway, since people will ask "what's with the butterfly?" and give us opportunity to answer them :)

[11:45] * sjn has increased his marketing foo the last year. ^^

[11:45] <daxim> http://www.reddit.com/r/programming/comments/d9ov7/hey_reddit_i_created_a_lolcode_compiler_for/  http://twitpic.com/2j1ys2/full

[11:49] *** M_o_C joined
[11:49] *** amkrankruleuen left
[11:49] *** amkrankruleuen joined
[11:51] <daxim> also, comment #c0ylhp7 on that page. "smelltalk"

[11:56] *** bluescreen joined
[11:57] *** bluescreen is now known as Guest59183

[12:00] <M_o_C> sjn: I was always under the impression that Perl 6 is not intended to be a replacement for Perl 5, at least I remember masak saying sth. like that. So don't you think it might be a little bit too provocative to take a Perl 5 logo and "place Camelia over the 5"? Or at least that it will be misinterpreted to mean that? Note that I have nothing against the flyer, I just wanted to point out that this issue could arise.

[12:02] <masak> if it's for a Perl Mongers group that traditionally has done Perl 5, it's a little more OK. :) but yes, people who want to get angry over such things have a splendid opportunity with such a flyer.

[12:02] <sjn> M_o_C: don't worry. the logo say's "Welcome to the Perl Community", but now with an added Camelia :)

[12:03] <sjn> says*

[12:03] <moritz_> M_o_C: I've understood that as "we do 5 and 6"

[12:03] <masak> fwiw, I'll advocate a total replacement of Perl 5 with Perl 6 when Perl 6 is faster, more stable and has a bigger module repository than Perl 5. :)

[12:03] <M_o_C> Hehe^^

[12:04] <moritz_> ... has more active developers, and the p6 modules are a proper superset of the p5 modules

[12:04] <sjn> my purpose is to get people interested in Perl again, and I think doing a trick like this might work for just that :)

[12:04] <M_o_C> Yep, choosing Camelia was a good idea insofar (?) that it's harder to be angry at a butterfly ;)

[12:04] <sjn> heheh

[12:04] <sjn> exactly :)

[12:06] <sjn> (There's even a trademark sign there, so if people ask "why use a child's drawing as a logo?" we can point to that and say "would a child be as professional/serious as to register the drawing as a trademark?" :)

[12:06] <masak> sjn++ # tricking people into being interested in Perl again

[12:06] <sjn> So, all in all, I'm very happy to have asked for feedback here. I only now hope the last changes end up on the actual print

[12:07] <[Coke]> can I get appropriate github commit bits for the new broken-out repos?

[12:07] <moritz_> your github ID is 'Coke'?

[12:08] <moritz_> done

[12:08] * sjn is starting to get TimToady's devious scheme with Camelia :)

[12:12] <[Coke]> moritz_: danke.

[12:12] <moritz_> [Coke]: bitteschoen

[12:13] <takadonet> morning all

[12:15] <masak> morning, takadonet.

[12:17] *** BaggioKwok joined
[12:18] <[Coke]> take a donut? don'tindifidoooooo

[12:18] <takadonet> :)

[12:19] <masak> for @donuts { .take }

[12:19] <masak> hm.

[12:19] <masak> for @donuts { .&take }

[12:19] * [Coke] :headdesks: as he remembers that there were donuts at home for the taking.

[12:20] <masak> man, I love that new trick. every sub is potentially also a method.

[12:20] *** Axius left
[12:20] <masak> and it feels correctly Huffmanized, too.

[12:20] <huf> masak: .&take calls sub with $_ as the first argument?

[12:20] <masak> huf: yep.

[12:21] <huf> whereas .take would be an error, since it's not a method of $_ ?

[12:21] <masak> indeed.

[12:21] <moritz_> EVIL

[12:21] <huf> so this is similar to the perl5-ish undef->$coderef thing

[12:21] <masak> not aware of that one.

[12:21] <huf> either way, neat!

[12:21] * sjn doesn't want to know LALALAALALALAAL

[12:22] <moritz_> rakudo: say ~ gather for { .&take }

[12:22] <p6eval> rakudo 8cf7fc: OUTPUT«===SORRY!===␤Missing block at line 22, near ""␤»

[12:22] <moritz_> rakudo: say ~ gather for 1..5 { .&take }

[12:22] <p6eval> rakudo 8cf7fc: OUTPUT«1 2 3 4 5␤»

[12:22] <moritz_> wow

[12:22] <masak> sjn: waitwait. you make PR for Perl using butterflies, and then you stick your fingers in your ear when we talk about cool Perl 6 tricks? :)

[12:23] <masak> s/ear/ears/

[12:23] <sjn> perl -le'$foo=sub { print qq(oh yeah, baby) }; undef->$foo;' # EVIL

[12:24] <huf> sjn: with great power comes great responsibility... to never use that construct in production code :)

[12:24] <huf> but i wouldnt call it evil

[12:24] <masak> undef -- the universal object.

[12:25] <masak> which is why Perl 6 doesn't have it anymore -- it got too powerful :P

[12:25] <moritz_> nonono, Perl 6 has many of them

[12:25] <sjn> instead, Perl 6 has Mu

[12:25] <huf> once p6 escapes into the wild, i'm sure we'll see lots of creative undef usage

[12:25] <masak> yeah, we scattered the power into many smaller objects.

[12:26] <moritz_> plugs the abilty to create new undefs

[12:26] <moritz_> *plus

[12:26] <sjn> With Perl 6, you can KISS bye-bye to simplicity :-P

[12:26] <huf> pundef - a dialect of perl6 wholly based on undefs

[12:29] <masak> sjn: sometimes I see blog posts about Perl 6, and things are actually really nice and simple. those posts are either made by people who've never been standing close to an implementor, or by those skilled enough to suppress insignificant details. anyway, I find simplicity to be an expository art more than anything else.

[12:29] <sjn> true

[12:30] <sjn> masak: and it's still within the Perl way of doing things ("Perl, the Swiss Army Chainsaw of Programming")

[12:30] <masak> oh, definitely.

[12:31] <masak> Perl 6 just happens to be a nanotech string-theory nuclear swiss army chainsaw...

[12:31] <sjn> the thing is, that all that Cool[TM] stuff in Perl 6 gives me license to complain and shout "MADNESS! IT'S ALL CRAZY LUNATIC MADNESS!" with regular intervals :)

[12:31] <sjn> which, of course, I'm quite happy to use :)

[12:32] <masak> "There's some madness to the method after all..."

[12:32] <sjn> anyhoo

[12:32] * sjn has to get back to prepare tonight's Oslo.pm presentation about YAPC

[12:35] *** jaldhar joined
[12:36] *** BaggioKwok left
[12:38] *** _jaldhar_ left
[12:39] <gfldex> std: my $a = sub(){};

[12:39] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'sub' used at line 1␤Check failed␤FAILED 00:01 118m␤»

[12:40] <moritz_> rakudo: sub sub { {} }; sub(){}

[12:40] <p6eval> rakudo 8cf7fc:  ( no output )

[12:41] <huf> huh?

[12:41] <masak> rakudo: sub sub { say "OH HAI"; {} }; sub(){}

[12:41] <huf> std: my $a = sub () {};

[12:41] <p6eval> rakudo 8cf7fc: OUTPUT«OH HAI␤»

[12:41] <p6eval> std 32123: OUTPUT«ok 00:01 119m␤»

[12:41] <moritz_> it defines a sub called 'sub', which returns an empty hash

[12:41] <moritz_> and it calls .{} on it

[12:41] <moritz_> which is the empty hash slice

[12:47] *** BaggioKwok joined
[12:51] *** Axius joined
[12:52] <masak> Interview question: "Given an array of 100 numbers, work out how to calculate the min, max and average."

[12:52] *** Axius is now known as aigoo

[12:52] <masak> rakudo: my @a = map { rand }, ^100; my $min = [min] @a; my $max = [max] @a; my $avg = ([+] @a) / +@a; say (:$min, :$max, :$avg).perl

[12:52] <p6eval> rakudo 8cf7fc: OUTPUT«("min" => 0.00662271235197309, "max" => 0.968477256921648, "avg" => 0.497900331720313)␤»

[12:52] <masak> \o/

[12:52] <masak> man, these interview questions are *easy* :)

[12:53] <moritz_> who asked those?

[12:54] <masak> this particular one was from http://stackoverflow.com/questions/445425/what-algorithms-should-every-developer-know

[12:54] <masak> third answer.

[12:55] <masak> the second one is not immediate, though. I'd like to see a nice Perl 6 one-liner for that one.

[12:55] <masak> maybe if one can work with slicels as first-class objects, it's possible to make a short, nice one.

[12:57] *** BaggioKwok left
[12:57] <moritz_> I guess you can simply make two two loops, and two explicit comparisons

[12:58] <moritz_> you only have two possible diagonals, so it's probably easier to hard-code those

[13:00] *** rhebus left
[13:03] *** aloha left
[13:04] *** rhebus joined
[13:04] <masak> rakudo: my @b = [-1, 0, 0], [0, -1, 0], [0, 0, -1]; my @lines = [0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]; for @lines { if [==] (my @l = slicel(@b, $_)) { say "Someone won: @l[0]" }}; sub slicel(@a, @s) { map { @a[$_ div 3][$_ % 3] }, @s }

[13:04] <p6eval> rakudo 8cf7fc: OUTPUT«Someone won: -1␤»

[13:04] *** bacek left
[13:04] <masak> so, it's possible. but real slicels would make it nicer, probably.

[13:05] * moritz_ not convinced

[13:05] <moritz_> wouldn't that code detect three 0s in a row as a winner?

[13:05] *** yrgd left
[13:05] <masak> uhhh. yes.

[13:07] <rhebus> a strange game. the only way to win is not to play.

[13:07] <masak> rakudo: my @b = [-1, 0, 0], [0, -1, 0], [0, 0, -1]; my @lines = [0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]; for @lines { if ([==] (my @l = slicel(@b, $_))) && all @l { say "Someone won: @l[0]" }}; sub slicel(@a, @s) { map { @a[$_ div 3][$_ % 3] }, @s }

[13:07] <p6eval> rakudo 8cf7fc: OUTPUT«Someone won: -1␤»

[13:07] <masak> there :)

[13:07] <masak> now, someone please blog a nice solution :)

[13:09] <takadonet> wonder if one day Perl 6 will have a one liner for every interview/exam question out there

[13:09] *** orafu left
[13:09] *** colomon left
[13:09] <takadonet> Interview question: "Given an array of 100 numbers, work out how to calculate the min, max and average without using the 'cheat' Perl 6 language"

[13:09] *** orafu joined
[13:09] <rhebus> hahaha

[13:10] <masak> takadonet: the day it does, we'll update the Perl History to reflect that :)

[13:10] <moritz_> interview(MinMaxAvg).(map &rand, ^100)

[13:10] <masak> "May 2032: Perl 6 now has a one-liner for every single interview question out there"

[13:11] <masak> "August 2032: Perl 6.18 adds the .triggerSingularity method to the Mu class"

[13:11] <masak> or should that be only the Cool class?

[13:12] <jnthn> Triggering a singularity is srsly not cool.

[13:12] <masak> jnthn: you say that *now*, but in 22 years, we'll be triggering a singularity every time we want to make coffee.

[13:13] <PerlJam> singularities sound like a potent form of energy to me.

[13:13] <masak> I hear they make great coffee.

[13:14] <moritz_> s/great/grand/

[13:14] <frettled> I hear they make great virtual realities while using our bodies for batteries.  Environmentally suspect, but perhaps feasible.

[13:14] <PerlJam> "Scientists accidentally explain the universe while constructing a Perl 6 program to model black holes"

[13:14] <frettled> PerlJam: …using a one-liner

[13:15] <moritz_> perl6 -e 'use BlackHole; BlackHole.new.simulate'

[13:15] <PerlJam> frettled: "after days writing a long complicated regex to model black holes, the chief scientist realized that it could be expressed in a single line of Perl 6"

[13:16] <PerlJam> :)

[13:16] <frettled> /o\ (using regex)

[13:17] <masak> PerlJam: and LTM help explain deeper black hole mechanisms.

[13:17] <masak> s/help/helps/

[13:17] <PerlJam> It's all joking ... until someone does it.

[13:17] <moritz_> speaking of which, lately I've been thinking about solving nonograms with regexes

[13:18] <moritz_> but actually the need the inverse - string generators according to a pattern

[13:21] *** rainerschuster is now known as rschuster-off

[13:22] * frettled misread that as "monograms"

[13:24] *** snearch left
[13:24] *** perlygatekeeper joined
[13:25] <masak> frettled: monograms -- a time-honoured problem that still lacks a solution.

[13:25] * PerlJam idly wonders what no-no-grams would be  :)

[13:25] <moritz_> so-grams

[13:25] <PerlJam> moritz++

[13:25] * masak groans

[13:25] <rhebus> moritz_: if you get one, it's problem P98 in 99-problems

[13:25] <moritz_> http://en.wikipedia.org/wiki/Nonogram

[13:25] <frettled> My $entity, it must be Friday.

[13:26] <masak> frettled: some people invoke a deity, but you content yourself with... an entity. :P

[13:27] <frettled> masak: untyped, so it could contain a deity, if the reader is so inclined

[13:28] <frettled> The line between swearing, blasphemy and obsequiousness is thin.

[13:30] <pmichaud> good morning, #perl6

[13:30] <takadonet> pmichaud: morning

[13:30] <frettled> good morning!

[13:30] <jnthn> mornin,g pmichaud 

[13:31] <frettled> jnthn: you're doing what with a mornin, globally, on pmichaud?

[13:31] <jnthn> no, no, ,g means "greet" :P

[13:32] *** javs joined
[13:32] <rhebus> rakudo: my @lines = (0,3,6 X+ 0,1,2),(0,1,2 X+ 0,3,6),0,4,8,2,4,6; my @b = -1,0,0,0,-1,0,0,0,-1; for @lines -> $a,$b,$c { if @b[$a] && [==] @b[$a,$b,$c] { say "@b[$a] won" } }

[13:32] <p6eval> rakudo 8cf7fc: OUTPUT«-1 won␤»

[13:32] <rhebus> masak: howzat?

[13:35] *** M_o_C left
[13:36] <moritz_> nice!

[13:37] <masak> rhebus: a nice improvement!

[13:37] <masak> keep going! :)

[13:37] <moritz_> rhebus: how long have you been programming Perl 6? :-)

[13:37] <rhebus> since sunday

[13:37] <masak> rhebus++!

[13:37] * moritz_ impressed

[13:37] <frettled> rhebus++

[13:37] <moritz_> rhebus++

[13:37] <rhebus> shucks

[13:37] <rhebus> maybe one for perl6-examples, don't know where to file it though

[13:37] <rhebus> games I suppose

[13:37] <moritz_> yes

[13:37] <gfldex> :o

[13:38] <moritz_> 0,1,2 can be made 0..2

[13:38] <rhebus> are we golfing this or what? :)

[13:38] <masak> totally!

[13:38] <masak> ^2

[13:38] <masak> no wait

[13:38] <masak> ^3

[13:38] <moritz_> right

[13:38] <moritz_> and 0,3, 6 is ^3 Z* 3

[13:39] <moritz_> not shorter, but has a nice symmetry :-)

[13:39] <masak> that's not shorter :)

[13:39] <masak> :)

[13:39] <rhebus> I series of steadily golfed tic tac toes would be a good example :)

[13:40] <masak> there's already enough material here for a blog post.

[13:40] <rhebus> I'm happy to aggregate it all

[13:40] <masak> excellent

[13:41] *** Holy_Cow joined
[13:41] <rhebus> keep going with the improvements though

[13:41] <rhebus> (also, I haven't had a chance to show off to anyone about this yet, but I'm the leader on http://codegolf.com/99-bottles-of-beer )

[13:42] <moritz_> rakudo: my @lines = (0,3,6 X+ ^3), (^3 X+ 0,3,6), 0,4,8,2,4,6; my @b = -1,0,0,0,-1,0,0,0,-1; for @lines -> $a, $b, $c { if @b[$a] && [==] @b[$a,$b,$c] { say "@b[$a] won" } }

[13:42] <p6eval> rakudo 8cf7fc: OUTPUT«-1 won␤»

[13:44] <pmichaud> rakudo:  my @x = ( * + 4 for 0..3 );  say @x.perl;  # checking

[13:44] <p6eval> rakudo 8cf7fc: OUTPUT«[4, 5, 6, 7]␤»

[13:44] <pmichaud> \o/

[13:44] <pmichaud> today I think I'll fix up string numification

[13:46] *** Mowah left
[13:46] <gfldex> is there a way to modify the values of a hash in place?

[13:47] <masak> \o/

[13:47] <pmichaud> and maybe .Stringy

[13:47] <moritz_> rakudo: my %h = a => 1; %h<a>++; say %h<a>

[13:47] <p6eval> rakudo 8cf7fc: OUTPUT«2␤»

[13:47] <masak> rakudo: my %h = a => 1; %h<a> = 2; say %h.perl; # gfldex: does this count as in place?

[13:47] <p6eval> rakudo 8cf7fc: OUTPUT«{"a" => 2}␤»

[13:48] <masak> moritz_: interesting how similar those two lines are :)

[13:48] <gfldex> kind of yes but i was thinking about something .map-ish :)

[13:48] <moritz_> rakudo: my %h = a => 1, b => 5; %h.values>>++; say %h.perl

[13:48] <p6eval> rakudo 8cf7fc: OUTPUT«{"a" => 1, "b" => 5}␤»

[13:48] <pmichaud> rakudo: my %h = <a 1 b 2 c 3>;   for %h { .value++ };   

[13:48] <p6eval> rakudo 8cf7fc:  ( no output )

[13:48] <moritz_> hrmpf

[13:48] <pmichaud> rakudo: my %h = <a 1 b 2 c 3>;   for %h { .value++ };   say %h.perl;

[13:48] <p6eval> rakudo 8cf7fc: OUTPUT«{"a" => "1", "b" => "2", "c" => "3"}␤»

[13:49] <pmichaud> hmmmmm

[13:49] <pmichaud> I'm guessing the hash pairs aren't being constructed properly

[13:49] <pmichaud> the values need to be bound instead of assigned

[13:49] <pmichaud> maybe I should re-do Hash today

[13:50] <moritz_> there's also a patch for .hash in RT, iirc

[13:50] <gfldex> if would need: for %h { .value =[+] }

[13:50] <gfldex> or however you say =[+] :)

[13:50] <moritz_> what do you want to do?

[13:51] <gfldex> %h = a => [1,2,3], b => [10,20,30]; %h.magic({[+]*}); # a => 6, b => 60

[13:52] *** kaare_ left
[13:52] <masak> ah, sums.

[13:52] <gfldex> or .uc all values in a hash without creating a new hash

[13:53] <moritz_> %h.values.map({ $_ = [+] @$_}) should work, doesn't

[13:53] <moritz_> %h.values>>.uc

[13:53] <moritz_> %h.values>>.=uc

[13:53] <pmichaud>                 take Pair.new(key => $iter_item.key, value => $iter_item.value);

[13:53] <pmichaud> that's the likely culprit

[13:53] <pmichaud> value needs to be bound to $iter_item.value

[13:53] <masak> rakudo: my %h = a => [1,2,3], b => [10,20,30]; say (map {; .key => ([+] .value.list) }, %h).perl

[13:53] <pmichaud> (as a container)

[13:53] <p6eval> rakudo 8cf7fc: OUTPUT«("a" => 6, "b" => 60)␤»

[13:54] *** spq1 joined
[13:57] * [Coke] wonders if there's a way to ||-ize  $min = [min] @foo; $max = [max] @foo;

[13:58] * moritz_ is more interested in optimizing [+] 1..1000

[13:58] <pmichaud> actually, maybe I should work on something this morning that doesn't require rewriting an entire subsystem :-(

[13:58] <masak> [Coke]: [minmax]

[13:58] <moritz_> could be made by calculating (1000) * (1000+1) / 2  or so

[13:58] <gfldex> why do i need {; ?

[13:59] <[Coke]> masak: I mean in general.

[13:59] <moritz_> gfldex: where?

[13:59] <pmichaud> gfldex: without the semi, the braces end up being a hash constructor

[13:59] <masak> gfldex: because of the rules that distinguish code blocks from hashes.

[13:59] <pmichaud> (curly braces containing a single pair become a hash)

[13:59] <masak> though the implicit use of $_ should be a determinant, IIRC.

[14:00] * masak checks that

[14:00] <pmichaud> I have difficulty (both design and implementation) with that rule.

[14:00] <gfldex> it's ugly for sure

[14:00] *** uniejo left
[14:00] <pmichaud> I'm not sure what qualifies as "implicit use of $_"

[14:00] <pmichaud> or how one can detect it reliably

[14:01] <moritz_> having distinct hash and block quoting would be nice

[14:01] <gfldex> we need bigger keyboards :)

[14:01] <masak> S04 is clear on it, though.

[14:01] * masak submits rakudobug

[14:01] <pmichaud> masak: clear on what?

[14:01] <masak> pmichaud: on implicit use making it a block.

[14:01] <pmichaud> but it's not clear about what makes something "implicit use"

[14:01] <masak> S04:1558

[14:02] <masak> pmichaud: I don't really see how it's unclear.

[14:02] <masak> a dotty without an lhs is an implicit use of $_

[14:02] <pmichaud> { a => { .foo } }     # does the outer block implicitly use $_ ?

[14:02] <masak> what? no.

[14:02] <pmichaud> why not?

[14:02] <masak> because... it doesn't.

[14:03] *** Kodi joined
[14:03] <masak> it has no .foo in it, the inner block does.

[14:03] <masak> and the inner block isn't immediate.

[14:03] <pmichaud> but that inner block uses $_

[14:03] <masak> yes.

[14:03] * masak must be missing something here

[14:03] <pmichaud> and it defaults to the outer $_, yes?

[14:03] <pmichaud> how about now...?

[14:03] <masak> yes, and that doesn't matter here.

[14:03] <pmichaud> { a => { .foo }.() }

[14:03] <masak> er.

[14:03] *** mfollett joined
[14:04] <moritz_> now it gets interesting

[14:04] <pmichaud> what about... ?

[14:04] <pmichaud> { a => * + 2 }

[14:04] <Kodi> masak: Could you either apply that patch or make me a Rakudo committer so I can do it?

[14:04] <pmichaud> Kodi: have you submitted a CLA?

[14:04] <masak> afk &

[14:05] <Kodi> pmichaud: I'm sorry, I don't know what that is.

[14:05] <pmichaud> CLA = Contributor License Agreement

[14:05] <pmichaud> those are required before obtaining rakudo commit bits

[14:05] <Kodi> pmichaud: I see. How do I do that?

[14:05] <pmichaud> Kodi: just a sed

[14:05] <pmichaud> *sec

[14:05] <Kodi> Just an awk.

[14:06] <pmichaud> http://www.perlfoundation.org/contributor_license_agreement

[14:06] *** alester joined
[14:06] <gfldex> Kodi: did they tell you that camelia feeds on souls? :->

[14:06] <pmichaud> Kodi: which patch are you wanting applied?

[14:06] <Kodi> pmichaud: http://rt.perl.org/rt3//Public/Bug/Display.html?id=77560

[14:07] <Kodi> pmichaud: So I can get a commit bit after I've mailed in that form?

[14:07] <moritz_> std: /\x/

[14:07] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex backslash sequence at /tmp/i2X5P21Dqw line 1:␤------> [32m/\[33m⏏[31mx/[0m␤Check failed␤FAILED 00:01 116m␤»

[14:07] <mathw> pmichaud: Ah yes, I still need to send mine. Must do that.

[14:07] <pmichaud> Kodi: yes, if the rest of the team feels you've earned a commitbit :)

[14:08] <pmichaud> the cla is necessary (but not sufficient :)

[14:08] <Kodi> I guess I'll see. :)

[14:08] <pmichaud> I'd likely recommend you for one :)

[14:08] <Kodi> I'm happy to hear that much.

[14:08] *** qwebirc4893 left
[14:09] * moritz_ too

[14:10] <pmichaud> Kodi's patch looks good to me.... any reason I shouldn't apply it?

[14:10] *** sahadev joined
[14:13] <pmichaud> Kodi: testing patch now, will apply if it spectests cleanly

[14:15] <moritz_> pmichaud: is there any way to interpolate captures in <.panic: "foo"> error messages?

[14:17] <moritz_> std: / , /

[14:17] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex metacharacter (must be quoted to match literally) at /tmp/5MDnxOfo4O line 1:␤------> [32m/ ,[33m⏏[31m /[0m␤Can't call method "from" on unblessed reference at /opt/perl-5.12.1/lib/site_perl/5.12.1/STD.pm line 53784.␤FAILED 00:01

[14:17] <p6eval> ..…

[14:17] <pmichaud> I don't understand "interpolate captures"

[14:17] <moritz_> "Unrecognized backslash sequence \\$0"

[14:17] <moritz_> s/captures/capture variables/

[14:18] <pmichaud> in NQP or Rakudo ?

[14:18] <moritz_> NQP

[14:18] <pmichaud> <.panic: "Unrecognized backslash sequence \\{$0}">  # maybe

[14:18] <pmichaud> <.panic: "Unrecognized backslash sequence \\{$/[0]}">  # more likely

[14:19] * moritz_ tries

[14:20] <moritz_> Unrecognized backslash sequence: \{$/[0]} at line 1, near "/\n"

[14:20] <moritz_> nqp: say("foo {2+3}")

[14:20] <p6eval> nqp: OUTPUT«foo 5␤»

[14:21] <pmichaud> that's weird.

[14:21] <pmichaud> nqp:  my $/ := <a b c>;  say("hello $1");

[14:21] <p6eval> nqp: OUTPUT«hello $1␤»

[14:21] <pmichaud> nqp:  my $/ := <a b c>;  say("hello {$1}");

[14:21] <p6eval> nqp: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 1␤current instr.: 'parrot;Regex;Cursor;FAILGOAL' pc 2356 (src/Regex/Cursor.pir:233)␤»

[14:21] *** wtw left
[14:22] <pmichaud> nqp:  my $a := 'hello';  say("hello $a");

[14:22] <p6eval> nqp: OUTPUT«hello hello␤»

[14:22] <pmichaud> nqp:  my $a := 'hello';  say("hello {$a}");

[14:22] <p6eval> nqp: OUTPUT«hello hello␤»

[14:22] <pmichaud> nqp:  my $/ := <a b c>;  say("hello {$/[1]}");

[14:22] <p6eval> nqp: OUTPUT«hello b␤»

[14:23] <pmichaud> nqp:  my $/ := <a b c>;  say("hello \{$/[1]}");

[14:23] <p6eval> nqp: OUTPUT«hello {3[1]}␤»

[14:23] <moritz_> nqp: "abc" ~~ / (.) <.panic: "$0">/

[14:23] <p6eval> nqp: OUTPUT«Method 'panic' not found for invocant of class 'Regex;Cursor'␤current instr.: '_block14' pc 265 (EVAL_1:273)␤»

[14:23] <pmichaud> nqp:  my $/ := <a b c>;  say("hello \\{$/[1]}");

[14:23] <p6eval> nqp: OUTPUT«hello \b␤»

[14:23] *** M_o_C joined
[14:23] <moritz_> +    token backslash:sym<unrec> { {} (\w)

[14:23] <moritz_> +        <.panic: "Unrecognized backslash sequence: \\{$/[0]}"> }

[14:24] <moritz_> that's my patch

[14:24] *** colomon joined
[14:24] <moritz_> seems to be different rules in mainline vs. regex

[14:24] <pmichaud> just a sec

[14:24] <rhebus> is there any difference between >>op<< and Zop ?

[14:24] <pmichaud> rhebus: short answer: yes.

[14:24] <colomon> rhebus: oh, yes.

[14:24] <moritz_> Z is lazy

[14:25] <moritz_> >>op<< is eager (even hyper)

[14:25] <moritz_> Z stops at the shortest list

[14:25] <moritz_> >>op<< dies if they aren't of the same length

[14:25] <rhebus> rakudo: say (1,2,3) Z+ (4,5)

[14:25] <p6eval> rakudo 8cf7fc: OUTPUT«57␤»

[14:25] <rhebus> aha

[14:26] <colomon> >>op<< also recursively descends in structures

[14:26] <colomon> Zop doesn't.

[14:26] <rhebus> do the structures have to match?

[14:26] <moritz_> yes

[14:26] <colomon> rakudo: say ([1, [2, 3]] >>+<< [3, [10, 100]]).perl

[14:26] <p6eval> rakudo 8cf7fc: OUTPUT«[4, [12, 103]]␤»

[14:26] <pmichaud> moritz_: try  <.panic("...")>

[14:27] *** Kodi left
[14:27] <colomon> rakudo: say say ([1, [2, 3]] Z+ [3, [10, 100]]).perl

[14:27] <p6eval> rakudo 8cf7fc: OUTPUT«(4, 4)␤1␤»

[14:27] <pmichaud> moritz_: or try   <.panic("..." ~ $/[0] ~ "...")

[14:27] <pmichaud> >

[14:27] <moritz_> pmichaud: will do

[14:27] <pmichaud> it may just be colon-arguments that aren't interpolating.

[14:27] <colomon> rhebus: the second 4 there is the number of elements in [2, 3] + number of elements in [10, 100]

[14:28] <rhebus> aha

[14:28] <rhebus> thanks colomon++ moritz_++

[14:29] <moritz_> pmichaud: both produce the empty string for $/[0]

[14:30] <pmichaud> I'm guessing $/ isn't being set then.

[14:30] <moritz_> possible

[14:32] <pmichaud> colomon: does any of the str-to-num conversion code you wrote handle things like "0x0a" and the like?

[14:32] <colomon> pmichaud: no

[14:32] <pmichaud> oh.  :-(

[14:32] <colomon> it strictly handles base 10 decimal numbers.

[14:32] <colomon> (ie Rats and Nums)

[14:33] <pmichaud> okay.  that's going to require some refactoring then.

[14:33] *** M_o_C left
[14:33] *** M_o_C joined
[14:33] <dalek> nqp-rx: 24b297f | moritz++ | src/Regex/P6Regex/Grammar.pm:

[14:33] <dalek> nqp-rx: report unrecognized backslash sequences

[14:33] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/24b297f587aa59f6af0e14da196a1e1970ab3a33

[14:34] <PerlJam> The grammar chapter of "Using Perl 6" says that the  TOP rule anchors the match to the start/end of the string.  I can't seem to find the particular section of the Synopses where it says this.

[14:37] <PerlJam> oh, never mind.

[14:38] <PerlJam> I just didn't read enough of the chapter.

[14:41] <rhebus> bah, posterous--, i can't work their syntax out at all

[14:45] <colomon> pmichaud: what are you trying to do?

[14:45] <pmichaud> colomon: eliminate the Perl6Str PMC type

[14:45] <daxim> where's the list of all built-in functions?  $scalar.what-can-be-called-here   @array.what-can-be-called-here

[14:45] <pmichaud> it currently handles the 0x0a conversions

[14:46] <pmichaud> daxim: there's no canonical list at the moment ... but S32 is pretty close

[14:46] <moritz_> rakudo: my @a; say ~@a.^methods

[14:46] <p6eval> rakudo 8cf7fc: OUTPUT«at_pos splice new perl delete Bool rotate pop Num perl Capture of elems Str munch list shift map exists push unshift ACCEPTS hash eager at_pos fmt flat sort new iterator list elems fmt item Num Str Int cosh succ subst sign Numeric chomp index uc chr acotanh samecase substr

[14:46] <p6eval> ..trim-tra…

[14:46] <moritz_> rakudo: say ~Cool.^methods

[14:46] <p6eval> rakudo 8cf7fc: OUTPUT«fmt bytes pred acosec sinh Numeric asinh cosech trim asec trim-leading chr acotanh floor sech asech rand truncate round rindex sqrt asin split match cosh exp acosh succ words sign cotan atan2 lcfirst IO sec cis samecase log capitalize sprintf trans sin Int flip p5chop lc subst

[14:46] <p6eval> ..to-r…

[14:46] <pmichaud> and, of course,  $scalar.what-can-be-called-here depends heavily on the type of $scalar :)

[14:47] <daxim> oh, introspection

[14:47] <daxim> that's nice

[14:47] <colomon> pmichaud: ah, yes, refactor both necessary and useful there, then.

[14:47] <pmichaud> colomon: plus we still need to eliminate the runtime conversion of string constants

[14:48] <pmichaud> sorry

[14:48] <pmichaud> runtime conversion of numeric constants

[14:48] <pmichaud> (to make them compile-time)

[14:48] <colomon> I think we need Rats in nqp to do that...

[14:48] <pmichaud> not at all.

[14:48] <moritz_> nope

[14:48] <moritz_> you can emit Rat.new($nom, $denom) calls

[14:48] <pmichaud> correct.

[14:48] <moritz_> as long as you do the calculations leading up there without rats

[14:49] <colomon> yes, but in order to do that and have it work, you'll have to do dozens of those calls for each number.

[14:49] <pmichaud> huh?

[14:49] <pmichaud> you mean more than we're already doing?  ;-)

[14:49] *** NABD40S joined
[14:51] *** rodi joined
[14:52] <jnthn> .oO( one day we'll be able to just make constant(Rat.new($num, $dom)) in the akshuns :-) )

[14:52] *** lichtkind joined
[14:52] <colomon> I don't have the source up at the moment, but for fractional parts, each digit D is handled by adding D/10^N to the number we're calculating.

[14:52] <pmichaud> colomon: that's not the issue.

[14:52] <pmichaud> currently, code like:   for 1..1000 { say 1.5 }

[14:52] <colomon> Rat.new($num, $dom) would be perfect if we had bigints...

[14:52] <lichtkind> can i do no strict in perl ?

[14:52] <pmichaud> generates

[14:53] <pmichaud>     str2num-rat(0, "1", "5")

[14:53] <pmichaud> which internally calls Rat.new

[14:53] <pmichaud> I'm proposing that we change that to become

[14:53] <pmichaud>     Rat.new(1,5)

[14:53] <pmichaud> er

[14:53] <pmichaud>     Rat.new(3,2)

[14:54] <pmichaud> to avoid the runtime string conversion and pattern match and other overhead (that occurs on each iteration of the loop)

[14:54] <moritz_> lichtkind: you can in perl, but not in Rakudo Perl :-)

[14:54] <lichtkind> moritz_: ah thanks

[14:54] *** _jaldhar joined
[14:55] <moritz_> I guess it will be easy-ish to implement once we have compile time lexpads

[14:55] <colomon> pmichaud: yes, but your example there skips the step where all the hard work is done.

[14:55] <pmichaud> colomon: no, I'm simply saying we calculate the 3 and 2 at compile-time instead of at runtime

[14:55] <pmichaud> I'm not saying we use different steps.

[14:55] <pmichaud> we still call str2num-rat, but we do it once (at compile time) instead of on each execution

[14:56] <colomon> oh.

[14:56] <colomon> so we can still use Rat calculations there?

[14:56] <moritz_> which implies rewriting str2num-rat in nqp, right?

[14:56] <pmichaud> moritz_: no

[14:56] <pmichaud> I'm just going to put it in PIR

[14:56] <pmichaud> it's already PIR

[14:56] <jnthn> Or being smart enough to only call it when we know we have the setting compiled so it's available.

[14:56] <jnthn> Oh, OK

[14:56] <jnthn> If it's in PIR then it's easy :-)

[14:56] <pmichaud> there's no reason that str2num-rat needs to be in the setting--- it's just a Q:PIR { ... } block

[14:57] *** mikehh left
[14:57] <pmichaud> well, that one isn't... but it's easy enough to fix

[14:57] <pmichaud> and yes, what jnthn++ said

[14:57] <pmichaud> we just make sure it's defined first.

[14:57] <pmichaud> (before we encounter any rats)

[14:57] <rhebus> masak: http://rhebus.posterous.com/learning-perl-6-by-playing-silly-games

[14:57] <pmichaud> at any rate, doing   .subst as part of string-to-num conversion is Evil as far as I'm concerned.  We need to eliminate that part.

[14:58] *** jaldhar left
[14:58] <pmichaud> (since it involves an expensive pattern match)

[14:58] <pmichaud> (and calling a variety of closures, and ...)

[15:00] <pmichaud> anyway, it's perfectly valid for Actions.pm to call Perl 6 functions directly.

[15:01] <smash> rhebus++

[15:02] *** cjk101010 left
[15:02] <pmichaud> hmmm.  HLL::Grammar already provides the int conversions (for arbitrary bases)... I should probably use it instead of str2num-int .

[15:03] * colomon is scratching his head, because that looks like his code, but he's not at all remembering writing it that way.

[15:03] *** ash_ joined
[15:03] <colomon> you can't make it a call to the Rat constructor, you'll have to make it a call to infix:</> to get it to work correctly.

[15:04] <pmichaud> that's fine, it's still much cheaper than doing the string conversion on each encounter

[15:04] <colomon> yeah, agreed.

[15:04] <pmichaud> oh, why would I have to do that, ooc?

[15:04] <pmichaud> I don't think I have to call infix:</>

[15:04] <colomon> because the arguments might be Nums instead of Ints

[15:05] <pmichaud> doesn't str2num-rat already handle that for me?

[15:05] <colomon> In which case you're not getting a Rat at all.

[15:05] <pmichaud> right

[15:05] <colomon> oh, sorry, you're saying run str2num-rat and store the result as a Rat constructor.

[15:05] <pmichaud> so I call str2num-rat, then if it gives me a Rat back, I emit a Rat constructor, if it gives me anything else back, I emit the code for whatever else it is.

[15:06] <colomon> gotcha, yes, that should work nicely.

[15:06] <pmichaud> if it gives me back a Num, then I just emit a num constant

[15:06] <colomon> so while optimizing str2num-rat would be a good thing, the main point of this operation is to rewrite the Actions.pm section that calls str2num-rat.

[15:07] <colomon> so that it does it at compile time instead of run time.

[15:07] <pmichaud> actually, likely I'll rewrite the entire string to num conversion

[15:07] <pmichaud> str2num-rat will go away, or at the least Actions.pm won't be calling it directly

[15:07] <pmichaud> it'll get called by Str.Numeric

[15:08] <colomon> pmichaud++  # that's the right refactor

[15:08] <jnthn> +1

[15:08] <jnthn> pmichaud: Sounds like it'll be easily upgradeable to keep the generated constant objects themselves around later on too

[15:09] <jnthn> (Once we get serialization contexts.)

[15:09] <pmichaud> actions will simply say "oh, I have a string that represents a number, call Str.Numeric to compute its value and generate code for that"

[15:09] <jnthn> Right. And in the future it'll be "...compute its value, add it to the serialization context and emit the code to look it up in the constants table" :-)

[15:10] <pmichaud> exactly.

[15:10] * jnthn likes

[15:12] <[Coke]> moritz_: did you fix my cokewants at : http://wiki.github.com/perl6/nqp-rx/requests ?

[15:13] <moritz_> [Coke]: I did the split-in-setting thing

[15:13] <pmichaud> I took it out.

[15:13] <pmichaud> (unless it's been fixed again)

[15:13] <pmichaud> it broke the parrot build.

[15:13] <[Coke]> moritz_: I mean the .panic one. sounded like your earlier discussion.

[15:14] <moritz_> [Coke]: i needed it myself, and couldn't get it to work

[15:14] <[Coke]> ah.

[15:15] <[Coke]> I suppose those requests should be converted to Issues ?

[15:15] <pmichaud> that might work

[15:15] <pmichaud> I'm sure I can get the string interpolation to work.

[15:18] <masak> rhebus: nice! rhebus++

[15:18] * [Coke] rants at having to learn YAML to post a ticket. :P

[15:18] <moritz_> you have to?

[15:18] <moritz_> on github?

[15:18] <[Coke]> argh.  markdown sucks. :P

[15:19] <colomon> pmichaud: I don't see any obvious reason I can't handle the "rewrite Str.Numeric" part of things if you handle the Actions.pm end of the matter.  Free your time up for deeper stuff?

[15:20] <[Coke]> ah, you can just use straight html, that makes it easier. 

[15:20] <moritz_> we should really invent the one true markup language :-)

[15:21] <[Coke]> please no.

[15:21] <pmichaud> colomon: it's likely to be fairly involved

[15:21] * moritz_ found asciidoc for program documentation quite nice

[15:23] <pmichaud> because it also needs to handle the "0x..." and "0b..."  conversions.

[15:23] <colomon> pmichaud: I don't see why the "translate this string to a number" part should be too bad.  the str2num stuff already has most of the needed logic -- it just needs to be updated to handle different bases.

[15:23] <pmichaud> colomon: because I want it to use the HLL versions of those routines instead of duplicating them.

[15:24] <[Coke]> pmichaud: http://github.com/perl6/nqp-rx/issues/labels/feature

[15:24] <colomon> "the HLL versions"?

[15:24] <pmichaud> HLL::Grammar already has the radix conversion subs available.

[15:26] <colomon> ah

[15:26] <pmichaud> well, HLL::Actions, actually

[15:26] *** Guest59183 left
[15:26] <pmichaud> rakudo:  str2num-int("0x0a").say

[15:26] <p6eval> rakudo 8cf7fc: OUTPUT«Could not find sub &str2num-int␤  in main program body at line 22:/tmp/cAPL8Ee2hW␤»

[15:26] <pmichaud> rakudo:  Str::str2num-int("0x0a").say

[15:26] <p6eval> rakudo 8cf7fc: OUTPUT«Method 'panic' not found for invocant of class 'Str'␤  in 'Str::str2num-int' at line 4516:CORE.setting␤  in main program body at line 22:/tmp/kD93ay4IAu␤»

[15:27] <pmichaud> hmmmm

[15:27] *** aigoo left
[15:28] <colomon> rakudo:  Str::str2num-int("0x0a")

[15:28] <p6eval> rakudo 8cf7fc: OUTPUT«Method 'panic' not found for invocant of class 'Str'␤  in 'Str::str2num-int' at line 4516:CORE.setting␤  in main program body at line 22:/tmp/Xem_ZjKu3f␤»

[15:28] <colomon> oh, I see

[15:28] <colomon> src.'panic'('Invalid radix conversion of "', char, '"') is the code in question

[15:29] <pmichaud> str2num-int expects a match object.

[15:29] <pmichaud> actually, it seems to expect a cursor.

[15:30] <colomon> hmm?  not the version in Str.pm.

[15:30] <pmichaud> that's the one I'm looking at.

[15:30] <colomon>             .local pmc src

[15:30] <pmichaud> if you're calling .panic, you're expecting a Cursor.

[15:30] <colomon>             .local string src_s

[15:30] <colomon>             src = find_lex '$src'

[15:30] <colomon>             src_s = src

[15:30] <pmichaud> because .panic is only defined on Cursors.

[15:30] <pmichaud>         src.'panic'('Invalid radix conversion of "', char, '"')

[15:30] <colomon> Presumably the .panic call is just wrong.

[15:31] *** risou joined
[15:31] *** Ross joined
[15:32] *** justatheory joined
[15:32] <colomon> Spectest runs probably don't notice the different between call .panic and failing because you cannot call .panic.

[15:33] <colomon> s:1st/call/calling/

[15:33] *** mberends joined
[15:33] *** rodi left
[15:35] *** jaldhar_ joined
[15:36] <colomon> rakudo: say 1e5.WHAT

[15:36] <p6eval> rakudo 8cf7fc: OUTPUT«Num()␤»

[15:37] <pmichaud> ooooh

[15:37] <pmichaud> we can haz 64-bit ints (on 64-bit machines)

[15:39] *** _jaldhar left
[15:42] <jnthn> pmichaud: ooh, nice :-)

[15:42] *** perlnab joined
[15:43] <dalek> rakudo: d84752d | KodiB++ | / (6 files):

[15:43] <dalek> rakudo: Implemented Instants and Durations.

[15:43] <dalek> rakudo: 

[15:43] <dalek> rakudo: Signed-off-by: pmichaud [email@hidden.address]
[15:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d84752d4f3e12b152cb707392e58ada56d31d20a

[15:44] <TimToady> though actually, 64-bits that can't be guaranteed isn't terribly useful in the overall scheme of things

[15:44] <phenny> TimToady: 09:05Z <smash> tell TimToady beadsort in Perl 6 (translated from haskell) http://gist.github.com/568057

[15:45] <TimToady> if 32-bit machines could emulate int64, then they'd be more useful

[15:47] <colomon> pmichaud: unless you've just changed it, upgrade_to_num_if_needed only knows about 32-bit ints.

[15:47] *** perlnab left
[15:47] <ash_> the repl doesn't support non-ascii input, correct? 

[15:47] <pmichaud> colomon: I've just changed it.

[15:47] <colomon> \o/

[15:47] <ash_> rakudo's repl that is 

[15:47] <pmichaud> I'm testing it now locally to see what happens.

[15:48] <TimToady> ash_: readline doesn't handle utf8

[15:48] <pmichaud> ash_: the repl supports non-asc... what TimToady++ said

[15:48] <ash_> ah, kk

[15:49] <TimToady> the GNU folks have been singularly bass-ackwards when it comes to Unicode

[15:49] *** Ross left
[15:49] *** Ross^ joined
[15:49] <ash_> > «

[15:49] <ash_> Confused at line 1, near "\x{c2}\x{ab}\n"

[15:49] <ash_> alright, well that means, try.rakudo.org won't support utf8 input then 

[15:49] <pmichaud> ash_: you could turn readline off

[15:50] <pmichaud> or I can give an option to do it

[15:50] <pmichaud> is try.rakudo.org really using the standard input?

[15:50] <moritz_> I'm sure there's a parott Configure.pl has an option to disable readline

[15:50] <ash_> well, it uses whatever Perl6::Compiler.interactive(); uses 

[15:50] *** _macdaddy joined
[15:51] <pmichaud> yes, just build Parrot w/o readline support.

[15:51] <ash_> k, i'll do that

[15:52] *** rbuels left
[15:52] <ash_> i see  --without-gettext, is that the same as readline? 

[15:52] <pmichaud> huh

[15:53] <pmichaud> I don't see a "no readline" option.

[15:53] <moritz_> ash_: no

[15:53] <pmichaud> looking.

[15:53] *** mj41_ joined
[15:54] <[particle]> no, gettext is for i18n

[15:54] <ash_> i can just modify the confug/auto/readline.pm runstep... but it should look for --without-readline 

[15:54] <pmichaud> agreed.

[15:54] *** mfollett left
[15:57] *** mj41 left
[15:57] *** mj41_ is now known as mj41

[15:58] <masak> pmichaud: thanks for applying Kodi's patch.

[15:58] *** risou left
[15:59] *** kcwu left
[15:59] *** kcwu joined
[16:00] *** justatheory left
[16:00] *** justatheory joined
[16:00] <moritz_> rhebus: seems your blog post made it to the top 10 on reddit, r/programming/

[16:01] *** meinwald joined
[16:01] <takadonet> !!!

[16:01] *** stepnem left
[16:01] *** meinwald is now known as Guest57678

[16:01] <rhebus> takadonet++

[16:03] <rhebus> i have never used reddit but i assume this is good

[16:03] <takadonet> it is

[16:03] <takadonet> hibou will be out soon....

[16:04] *** stepnem joined
[16:04] <moritz_> rhebus: it means that you're probably getting at least 1k visitors for your blog, more if it stays up longer

[16:05] <rhebus> shame it has an error which I can't fix because the posterous post editor is so godawful D:

[16:05] <rhebus> i need a new blog platform really

[16:06] <moritz_> many people in here like wordpress

[16:06] <moritz_> (I don't really like it, but then I'm a control freak in that respect)

[16:07] <moritz_> I've created my own blogging system on top of my own templating system and blosxom (a perl 5 minimalistic blog system)

[16:07] <moritz_> I don't like it either, but I can use my favorite editor to write blog posts, and have perl 6 syntax hilighting

[16:07] *** timbunce left
[16:07] <ash_> i am lazy, i use wordpress 

[16:10] <pmichaud> rakudo:  say (2147483647+0).WHAT;  say (2147483647+2).WHAT;

[16:10] <p6eval> rakudo 8cf7fc: OUTPUT«Int()␤Num()␤»

[16:10] <pmichaud> >  say (2147483647+0).WHAT;  say (2147483647+2).WHAT;

[16:10] <pmichaud> Int()

[16:10] <pmichaud> Int()

[16:10] *** Guest57678 is now known as meinwald_argh

[16:10] <TimToady> rhebus: you have an <a b c> that is eaten as a tag

[16:10] <rhebus> TimToady: yeah I know, but I can only fix it by deleting and reposting :(

[16:10] <rhebus> posterous--

[16:10] <pmichaud> TimToady: I have a question about 'flat' 

[16:11] <TimToady> flat is what does list context flattening, and () always flattens in list context, so it must be recursive

[16:11] <ash_> how does one set a perl6 variable as readonly via pir? 

[16:11] <pmichaud> okay; I don't think that's what we meant by recursive.

[16:12] <pmichaud> if I have  (1, [1,2], [[1,2],3])   and flatten it, what do I get?

[16:12] <TimToady> I thought the example had nested parens

[16:12] *** Ross^ left
[16:12] <pmichaud> that's a bug with .perl, imo

[16:12] <TimToady> [] doesn't flatten in list context

[16:12] <pmichaud> they were actually itemized Seqs

[16:12] <TimToady> so you get the same thing

[16:12] <pmichaud> right

[16:12] <pmichaud> okay, we're in agreement.

[16:13] <pmichaud> if I have:

[16:13] <pmichaud> (1, (1,2).item, (1,2,3).item).flat

[16:13] <pmichaud> the resulting list has 3 elements, yes?

[16:14] <pmichaud> and same for

[16:14] <pmichaud> (1, (1,2).item, ((1,2).item,3).item).flat

[16:14] *** rbuels joined
[16:17] <TimToady> if so, I don't think [\,] <a b c>) should be itemizing

[16:17] <pmichaud> sure, I can agree with that.

[16:18] <pmichaud> I admit that [\,] is likely broken.

[16:18] <pmichaud> I just wanted to make sure our notion of 'recursive flat' was in sync.  We probably need to clarify the spec.

[16:18] <TimToady> I'm worried that we're going to get a lot of accidental itemizing in user code

[16:19] <TimToady> I'm wondering if we have some default backwards somewhere

[16:19] <pmichaud> so far the opposite complaint is prevalent also (more)

[16:19] <TimToady> "first of all, do no harm"

[16:19] <pmichaud> we also get lots of people worried about accidental flattening

[16:20] <pmichaud> in the case of [\,], I bet something is being put into a scalar

[16:20] <pmichaud> and returned

[16:20] <pmichaud> so there it's a matter of de-itemizing it.

[16:20] <TimToady> ah well, it's likely that if some sig default is wrong, it's only a matter of adding one extra char

[16:20] <TimToady> it's not like every sig is going to fill up with consts

[16:21] <pmichaud> I also had a question about   @x[$y]   where $y ~~ Positional

[16:21] <pmichaud> something feels wrongish there

[16:21] *** meinwald_argh is now known as meinwald

[16:21] <pmichaud> in the general case of:

[16:21] <TimToady> you thinking Match objects?

[16:21] <pmichaud> my xyz(@a) { say @a.elems };  my $b = <1 2 3>;  xyz($b)

[16:22] <pmichaud> correct answer is... 3?

[16:22] <pmichaud> it turns out to not be just Match objects

[16:22] <pmichaud> rakudo:  my @a = 0..9;  my $b = [3,7,4];  say @a[$b]

[16:22] <p6eval> rakudo 8cf7fc: OUTPUT«374␤»

[16:22] <TimToady> I don't think @x[$y] should be looking at whether $y is positional unless you say @$s

[16:22] <TimToady> @$y even

[16:23] <pmichaud> hmmmm

[16:23] <pmichaud> what about something like

[16:23] <pmichaud> @x[foo()]

[16:23] <pmichaud> I guess my question is... how does .[ ]  dispatch here?

[16:23] <TimToady> or @x[m/.../]

[16:24] <jnthn> pmichaud: In the @x[foo()] case if foo() returns multiple things they'd be in a Parcel, if that helps clarify anything.

[16:24] <pmichaud> currently Rakudo has    postcircumfix:<[ ]>(@x) { ... }

[16:24] <jnthn> (So it'd be a single Parcel parameter to the .[ ])

[16:24] <pmichaud> sorry

[16:24] <pmichaud> currently Rakudo has    postcircumfix:<[ ]>(@pos) { ... }

[16:24] <pmichaud> to handle the case of things like @x[1,2,3]

[16:24] <pmichaud> i.e., it looks for a Positional argument

[16:25] <pmichaud> jnthn: (foo() returns Parcel) -- yes, postcircumfix:<[ ]>  relies on that

[16:26] <pmichaud> since Parcel ~~ Positional

[16:26] <jnthn> Right.

[16:26] *** rschuster-off left
[16:26] <jnthn> All of the postcircumfixes today generally take a single parameter.

[16:26] <jnthn> Including postcircumfix:<( )> (which gets a capture)

[16:26] <pmichaud> Right.  My question is about itemizing behavior.

[16:27] <pmichaud> in the case of  @a[$b]   where $b ~~ Positional, how does postcircumfix:<[ ]>  know not to use the elements of $b as indexes?

[16:27] <TimToady> seems $b should be Scalar of Mumble, which is never positional

[16:27] <jnthn> I can't immediately thing of a way it can.

[16:28] <jnthn> TimToady: That won't really fly.

[16:28] <jnthn> TimToady: Scalar is always transparent

[16:28] <pmichaud> TimToady: thus my earlier question of

[16:28] <pmichaud> my xyz(@a) { say @a.elems };  my $b = <1 2 3>;  xyz($b)

[16:28] <TimToady> to methods, but not to fundamental typology

[16:28] <pmichaud> is $b "Scalar of ..."  ?

[16:29] <huf> what does Mumble mean?

[16:29] <huf> is it Foo?

[16:29] <TimToady> they are equivalently meta

[16:30] <pmichaud> huf: "Mumble" is just "<insert appropriate value here>"

[16:30] <TimToady> one gets tired of Foo and Bar

[16:30] <pmichaud> and we can no longer say "of Whatever"  :-)

[16:30] <pmichaud> unless we really mean "Whatever" :)

[16:30] <huf> you're all MumbleFooQuuz

[16:31] <pmichaud> huf: so, "Scalar of MFQ"  :-P

[16:31] <jnthn> ...a meme is born. :-)

[16:31] *** Axius joined
[16:33] <jnthn> TimToady: They're special even at a pretty fundemental level.

[16:33] <jnthn> TimToady: We can't really make $foo in a signature mean Scalar of Any

[16:33] *** stepnem left
[16:33] <jnthn> Otherwise you couldn't pass anything that wasn't ~~ Scalar[Any]

[16:33] <pmichaud> more to the point,  if  $foo = [<a b c>], I'm pretty sure that $foo has to be ~~ Positional

[16:34] <jnthn> Yes

[16:34] <jnthn> Agree.

[16:34] <TimToady> there's some fundamentally missing circularity saw missing with your use of ~~

[16:35] <pmichaud> could be... I just don't know what it is, thus the questions.  :-)

[16:35] <pmichaud> more directly,   Positional.ACCEPTS($foo)   # probably True

[16:35] *** stepnem joined
[16:36] <pmichaud> now then, to resolve the .[ ] issue, I could potentially switch it back to taking slurpy arguments, but that gets tricky when trying to clip ranges and the like.

[16:37] <TimToady> that is stripping the "I am only a simple scalar, leave me alone" info from $foo

[16:37] <jnthn> Maybe "is it positional" is the wrong thing to dispatch on.

[16:37] <pmichaud> if .[ ]  has a slurpy parameter for its arguments, then $b wouldn't flatten.

[16:37] <jnthn> *Positional

[16:37] <jnthn> What if we had some way to dispatch on "does it have the flatten flag set"?

[16:37] <TimToady> ACCEPTS must not loose that

[16:37] <TimToady> *lose

[16:38] <TimToady> if you're going to use ACCEPTS

[16:38] <pmichaud> jnthn: yes, I'm wondering how/where we get flattening behavior into our type system

[16:38] <pmichaud> so far it's really orthogonal to types

[16:38] <jnthn> TimToady: That's hardly the problem here.

[16:38] <jnthn> TimToady: It's that - as pmichaud++ just pointed out - does Positional isn't really implying anything about flattening.

[16:39] *** daxim left
[16:39] <pmichaud> this is also the problem I have with .perl as it's defined now -- it doesn't know anything about flattening either

[16:39] *** cdarroch joined
[16:39] *** cdarroch left
[16:39] *** cdarroch joined
[16:39] <jnthn> TimToady: And we don't yet have a (not implementation specific) way to say "is the flattening flag set"

[16:39] <TimToady> ACCEPTS needs to have a way of acting primitive, and it doesn't have access to the flattening flag, which is *logically* part of the capture, not either the arg or the parameter

[16:39] <pmichaud> if @a and $a are both arrays, then  (1, 2, $a).perl and (1, 2, @a).perl   both result in the same output, even though they're really quite different.

[16:39] *** thebird left
[16:40] <TimToady> I think the fundamental mistake is to try to attach the flattening flag to the arg

[16:40] <pmichaud> it's already attached to the arg.

[16:40] <TimToady> or do you do that anymore?

[16:40] <pmichaud> no

[16:40] <TimToady> that's bogus

[16:40] <pmichaud> it's attached to the container

[16:40] <TimToady> the container is the capture

[16:40] <pmichaud> that doesn't mean anything to me, for some reason.

[16:40] <ash_> ping sorear 

[16:41] <TimToady> it's one level down to where it belongs, I suspect

[16:41] <pmichaud> the capture itself has containers

[16:41] <jnthn> TimToady: No, no...like if you have an array then it's on that container.

[16:41] <TimToady> that's what I think is wrong

[16:41] <jnthn> TimToady: And that is referenced by the Capture

[16:41] <pmichaud> consider:   flat($a, @a)

[16:41] <TimToady> I think the capture has to know the bitmap of what wants flattening, and the internal containers are just objects

[16:41] <pmichaud> the capture is  \($a, @a)

[16:42] <pmichaud> the capture can't syntactically know that

[16:42] <jnthn> TimToady: You seem to be advocating a model where captures are going to be more than just a list/hash of arguments. I think that's a mistake.

[16:42] <TimToady> yes, it can

[16:42] <pmichaud> @a[foo()]   

[16:42] <TimToady> if $a and @a are the same object then *either* the capture must know that $a is non and @a is flattening, or $a *must* be Scalar of Array

[16:43] <pmichaud> right now we do $a is Scalar of Array

[16:43] <jnthn> TimToady: If captures are going to be richer than that, we'll have even more issues being able to optimize them away, for example.

[16:43] <pmichaud> but it's still also Positional

[16:43] <TimToady> then Scalar is being overloaded for two different purposes

[16:44] <TimToady> and I think the bit really belongs to the capture, not the arg

[16:44] <TimToady> it's "how was this expressed in the argument list", and the object itself shouldn't care

[16:44] <pmichaud> if the argument list is a function, how do we know if it's Scalar or not?

[16:45] <pmichaud> sorry

[16:45] <pmichaud> if an argument is a function, how do we know if it's Scalar or not?

[16:45] <pmichaud> (argument is a return value of a function...)

[16:46] *** tylercurtis joined
[16:46] <TimToady> that is always treated as a subparcel, the contents of which depend on how the function returned it

[16:46] <pmichaud> which means we can't know syntactically.

[16:47] *** Axius left
[16:47] *** mberends left
[16:48] <TimToady> which means the capture thinks it's flattenable; probably also implies that it can bind to Positional

[16:48] *** lichtkind left
[16:49] <jnthn> sub foo { 42 }; @x[foo()] # argument to .[ ] is not going to be Positional here

[16:49] <jnthn> e.g. there's only a Parcel created if there's multiple return values

[16:49] <dalek> rakudo: 0d6d574 | moritz++ | docs/ChangeLog:

[16:49] <dalek> rakudo: update ChangeLog

[16:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0d6d57445ab109500d16dc2eac6b19f854b2d2af

[16:50] <TimToady> correct, a single return value is its own Parcel, apart from not doing positional

[16:50] <pmichaud> sub foo { [1,2,3] };  @x[foo()]  # .....

[16:50] <jnthn> But if we can't rely on the flag in the capture to tell us whether the thing will be flattening or not, what is the point?

[16:51] <jnthn> It feels like much of the time it'll be a guess.

[16:52] <jnthn> And if it's going to guess flattening, and we call something that returns a Match object, we're still no further forward on (what I guess anyway was) the original issue.

[16:53] <pmichaud> jnthn: the original issue was that a Match object inside of .{ }   is being treated as a slice, since Match ~~ Positional

[16:53] <pmichaud> I can certainly fix the Match object case simply enough

[16:53] <jnthn> pmichaud: Right.

[16:54] <dalek> nqp-rx: 99fe6e2 | moritz++ | src/stage0/ (3 files):

[16:54] <dalek> nqp-rx: update bootstrap files

[16:54] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/99fe6e22e1b92724fc1e32b1da897927f5e4f1db

[16:54] <TimToady> how?

[16:54] <jnthn> pmichaud: I guess there's related cases though.

[16:54] <jnthn> Well, the obvious fix is to add a candidate to .{ } that takes Match

[16:54] <pmichaud> by defining   postcircumfix:<{ }>(Match $m) { self{~$m} }

[16:54] *** sekimura joined
[16:54] <TimToady> that's a hack

[16:54] <jnthn> It'll be tighter than Positional and thus win.

[16:54] <pmichaud> right

[16:54] <jnthn> I agree it's a hack, yes.

[16:54] <pmichaud> it's a hack, and thus I'm asking about the "real solution"

[16:55] <TimToady> a more general solution might be to always return certain objects inside a Parcel even if there's only one of it

[16:55] <pmichaud> which is why I'm interested in .[$b]  where $b ~~ Positional :-)

[16:56] *** Chillance joined
[16:57] <jnthn> TimToady: sub foo(Int $x) { say "ok" }; sub bar { 42 }; foo(bar()) # if the 42 lived in a Parcel, we hit issues in this example. At the moment, type checks happen before context is applied. We can't reverse that otherwise our multi-dispatches may have multiple solutions.

[16:57] <TimToady> or maybe there's some kind of Don't-Flatten-Parcel

[16:57] <TimToady> that's distinction from both Scalar and Parcel

[16:57] <jnthn> (assuming it's item context application that makes the parcel evaporate)

[16:57] <jnthn> (when it has one item in it, anyways...)

[16:57] *** macroron joined
[16:58] <pmichaud> I don't mind if there's a subset type that means "flattening"

[16:58] <jnthn> It feels like we may well need to introduce flattening somewhere into the type system.

[16:59] <pmichaud> it would be nice to say    postcircumfix:<[ ]>(Item $x) { ... }   and know that non-flattening values go here

[16:59] <TimToady> it's almost feeling like the :U vs :D issue

[16:59] <pmichaud> (or the inverse, if we need that)

[16:59] <jnthn> TimToady: Hey, I was just typing that. :-)

[17:00] <jnthn> TimToady: But was trying to think of nice names :-)

[17:00] <pmichaud> similarly, with :U and :D, why did we avoid subset types of  Defined and Undefined or the like?

[17:00] <TimToady> which is likely a circularity saw flavor

[17:00] <jnthn> TimToady: In a sense though, it is a "check a flag" thing, like :U and :D are "check if the REPR thinks it is defined"

[17:00] <jnthn> pmichaud: :U and :D don't map to .defined

[17:00] <TimToady> becuase it's a circularity saw issue

[17:00] <pmichaud> okay.

[17:00] <jnthn> pmichaud: They map to what the representation considers defined.

[17:00] <jnthn> pmichaud: Which really boils down to "is this a type object or not"

[17:01] <TimToady> we have to break away from normal semantics with ACCEPT in various spots

[17:01] <pmichaud> jnthn: my point was more about subset type versus syntax, not whether it's really "defined" or not.

[17:01] <TimToady> or we get these infinite regressions

[17:01] *** macroron left
[17:01] <pmichaud> i.e., we could conceivably have subset types with meanings similar to :U and :D

[17:01] *** macroron joined
[17:01] <jnthn> pmichaud: Subset types just feel a bit high level for that.

[17:01] <pmichaud> (modulo circularity)

[17:01] <pmichaud> jnthn: sure, I can buy that.

[17:02] <jnthn> pmichaud: I tend to see subset types as a way of adding imperative checks.

[17:02] <moritz_> maybe we need a general mechanism for introducing such subset types like :U and :D

[17:02] <jnthn> pmichaud: And :U / :D are more declarative things.

[17:02] <TimToady> don't see offhand how that helps circularity

[17:02] <moritz_> isn't that what traits were originally meant for?

[17:03] <TimToady> something has to be primitive

[17:03] <jnthn> moritz_: traits are more a thing we'd want to encourage people to use

[17:03] <pmichaud> I wouldn't have trouble with    postcircfumfix:<[ ]>($x is item)   either

[17:03] <jnthn> moritz_: For people people, if they're having to write :U and :D in their code, they're writing something odd.

[17:04] <jnthn> pmichaud: Yeah, we could do that too

[17:04] <pmichaud> similar to the way that $x is rw  distinguishes the dispatch somehow.

[17:04] <jnthn> pmichaud: OTOH, we could do traits for :U and :D too.

[17:04] <jnthn> Maybe we [c|sh]ould eliminate :U and :D in place of traits, like we have for is rw and is ro.

[17:04] <pmichaud> in that sense, rw-ness and item-ness arboth properties of the container

[17:05] <pmichaud> *are both

[17:05] <pmichaud> (or argument)

[17:05] <TimToady> what does "is item" mean?

[17:05] <pmichaud> it would only bind to arguments that aren't flattening

[17:06] <pmichaud> (could use "is scalar" too, I suppose)

[17:06] <pmichaud> (but that has a bad pun with "is Scalar")

[17:06] <TimToady> not sure this solves the Match problem

[17:06] <pmichaud> sure, Match isn't flattening

[17:06] <pmichaud> $/ is an item

[17:07] <pmichaud> so we'd end up with   postcircumfix:<{ }>($x is item) { self.at-key(~x) }   or something like that

[17:07] <TimToady> I guess people will just have to get used to writing ~/.../ and +/.../

[17:08] <pmichaud> er,

[17:08] <pmichaud> self.at_key(~$x)

[17:08] <pmichaud> which forces stringification of the key

[17:08] <jnthn> I think something along the lines of what pmichaud++ is suggested would be workable.

[17:09] <pmichaud> we do this now already (stringification) -- the problem is simply that Match as a Positional causes it to dispatch elsewhere first.

[17:09] <TimToady> thing is, people expect two different things from .[/ (\d+) ** , /]

[17:09] <pmichaud> yes, in that case I think it has to disambiguate

[17:09] <TimToady> but only one thing from .[/ (\w+) ** , /]

[17:10] <TimToady> they expect the Int type constraint of array subscripts to somehow figure out that it couldn't be a slice

[17:10] *** timbunce joined
[17:10] <pmichaud> more generally, what would we expect from    for / (\w+) ** , / { ... }

[17:11] <pmichaud> one iteration per capture?

[17:11] <pmichaud> well, I guess it's still just one iteration

[17:11] <pmichaud> more likely:

[17:11] <TimToady> that's what people would generally expect

[17:11] <TimToady> but for expects a list

[17:11] <pmichaud>     for / (\w+) , (\w+) , (\w+) / { ... }

[17:11] <TimToady> we knew that subscripts were going to be ambiguous

[17:12] <TimToady> one reason we made + and ~ so short :)

[17:12] <pmichaud> for expects a list, and the match object returned there is an item, yes?  i.e., it doesn't flatten?

[17:12] <pmichaud> or I need an m//

[17:12] <pmichaud>     for m/ (\w+) , (\w+) , (\w+) / { ... }

[17:12] <TimToady> match objects must flatten

[17:12] <pmichaud> j,,,

[17:12] <pmichaud> hmmmm

[17:13] <pmichaud> say (1, 2, m/ (\d+) , (\d+) /).elems     # 4 if matched?

[17:13] <TimToady> $/ doesn't because of the $, not because of the Match

[17:13] <pmichaud> okay.

[17:13] <pmichaud> on a similar topic, does   Array.new flatten?

[17:14] <TimToady> yes, 4

[17:14] *** envi^home left
[17:14] <pmichaud> say (1, 2, Array.new).elems   # 2 or 3 ?

[17:15] <TimToady> I suspect we need to make that the choice of the function's return

[17:16] <TimToady> if it said return $array, it shouldn't, and if it said return @array, it should

[17:16] <pmichaud> right, that's what Rakudo does now

[17:16] <pmichaud> so you're saying there's not a general rule for .new ?

[17:17] <pmichaud> (I'm fine with that, just confirming)

[17:17] <TimToady> why should .new be special, except insofar as we have a default one?

[17:17] <pmichaud> wfm

[17:17] <pmichaud> and in the specific case of Array.new, flattens or doesn't flatten?

[17:17] <pmichaud> also Range.new

[17:18] <pmichaud> (1,2, Range.new(4, 7)).elems  # 3 or 6?

[17:18] *** timbunce left
[17:18] <pmichaud> I'm fine with any answer (I think)... I just know these are corner cases I postponed until .... now :)

[17:19] *** masak left
[17:20] <TimToady> not sure this is a flatten flag, seems more like Range.new just returns the range in a parcel, and it depends on how the outer list is eventaully bound whether it's in list or scalar context

[17:20] * pmichaud feels an "I can argue that both ways" coming along.

[17:21] <TimToady> it keeps feeling like returned object's that are Positional or Iterable should never serve as their own Parcel, but should always be Parcelized

[17:22] <pmichaud> hmmm

[17:22] <pmichaud> so, in the case of

[17:23] <TimToady> (1,2,Range.new(4,7) should end the same as (1,2,(4..7))

[17:23] <pmichaud> okay, so .new isn't flattening in that case.

[17:23] <pmichaud> i.e., it doesn't return a flattening value.

[17:23] <pmichaud> I think this is what rakudo does now:

[17:23] <pmichaud> rakudo:  my $x = (1,2, Range.new(4,7));  say $x.perl;

[17:24] <p6eval> rakudo d84752: OUTPUT«(1, 2, 4, 5, 6, 7)␤»

[17:24] <pmichaud> rakudo:  my $x = (1,2, Range.new(4,7).item);  say $x.perl;

[17:24] <p6eval> rakudo d84752: OUTPUT«(1, 2, 4..7)␤»

[17:24] *** plainhao joined
[17:25] <TimToady> rakudo: my sub foo ($a,$b,$c) { say $c.perl }; foo(1,2,Range.new(4,7))

[17:25] <p6eval> rakudo d84752: OUTPUT«4..7␤»

[17:25] <TimToady> rakudo: my sub foo ($a,$b,*@c) { say @c.perl }; foo(1,2,Range.new(4,7))

[17:25] <pmichaud> I'm not sure that saying that Positional/Iterable objects aren't self-Parcels solves the underlying problem.

[17:26] <p6eval> rakudo d84752: OUTPUT«[4, 5, 6, 7]␤»

[17:26] <pmichaud> rakudo: my sub foo ($a,$b,*@c) { say @c.perl }; foo(1,2,Range.new(4,7).item)

[17:26] <p6eval> rakudo d84752: OUTPUT«[4..7]␤»

[17:26] *** ruoso left
[17:27] * jnthn -> dinner, bbiab

[17:27] <TimToady> it separates the positionality of the object itself from the positionality of its outer parcel interpoaltion

[17:27] <pmichaud> except that Parcel ~~ Positoinal

[17:27] <pmichaud> *Positional

[17:27] <TimToady> yes, but if it binds that positional, it leaves the internal positional alone

[17:27] <pmichaud> only if it's marked as non-flattening :-)

[17:28] *** Italian_Plumber joined
[17:28] * TimToady needs more coffee...

[17:28] <pmichaud> I'm sure you do.

[17:28] <pmichaud> :)

[17:28] <pmichaud> I need lunch.

[17:28] <pmichaud> Anyway, I'm happy to let you think on it a bit.

[17:29] <pmichaud> I can put in the Match hack if we want temporarily, or we can just let it stew for a while.

[17:29] <pmichaud> subscripting based on match object results is likely to be common.

[17:29] <pmichaud> the others are markedly less common.

[17:29] <moritz_> we have at least three independent submissions (2 RT, on p6c iirc)

[17:30] *** Mowah joined
[17:30] <pmichaud> in fact, more important (to me at least) is to come up with a much better definition of .perl

[17:30] <pmichaud> the fact that it doesn't understand items versus non-items is very confusing to people.

[17:31] <pmichaud> (flattening versus non-flattening)

[17:31] <pmichaud> rakudo:  say (4..7).perl

[17:31] <p6eval> rakudo d84752: OUTPUT«4..7␤»

[17:31] <pmichaud> rakudo:  say ((4..7).item).perl

[17:31] <p6eval> rakudo d84752: OUTPUT«4..7␤»

[17:34] <pmichaud> my @a = 1,(4..7).item;  say @a.perl;  say @a.elems;  say eval(@a.perl).elems;

[17:35] <pmichaud> rakudo: my @a = 1,(4..7).item;  say @a.perl;  say @a.elems;  say eval(@a.perl).elems;

[17:35] <p6eval> rakudo d84752: OUTPUT«[1, 4..7]␤2␤5␤»

[17:36] <pmichaud> afk, lunch

[17:37] <colomon> pmichaud: I just remembered one of the significant issues to worry about in str -> num conversion.  right now, we use Nums (well, parrot equivalent) accumulate digits, and then convert to Int if possible.

[17:37] <diakopter> phenny: tell sorear wow...! http://github.com/sorear/niecza/commit/c54087f32fdab5cd4de1d5e60572829870f98fe0

[17:37] <phenny> diakopter: I'll pass that on when sorear is around.

[17:38] <colomon> pmichaud: that works great for 32-bit ints, but a 64-bit int is more precision than a Num, which leads to potential issues.

[17:39] <colomon> pmichaud: of course, if you use Int to accumulate digits, then you have issues with Int overflow.  (until the happy day we have arbitrarily large Ints.)

[17:39] <pmichaud> I can always use Int to accumulate until we get to the point at which it'll overflow to num

[17:41] <pmichaud> anyway, I just ran a spectest locally and only run into one problem in an advent test

[17:41] <pmichaud> and we get a couple of passing todo's

[17:41] *** ruoso joined
[17:41] <patrickas> colomon: Got any comments on the series refactor? Or can we land it ? 

[17:42] <colomon> pmichaud: that's for 64-bit int in rakudo?

[17:42] <moritz_> I've cherry-picked the commits into the series-refactor branch

[17:42] <pmichaud> colomon: yes.

[17:42] <colomon> pmichaud: cool

[17:42] *** avar joined
[17:42] <pmichaud> so I'm thinking I might accept the difficulty with constant conversion

[17:43] <colomon> pmichaud: Int switching to Num is great if you can do it reasonably easily.

[17:43] <pmichaud> it just means that some ints will switch to nums earlier than a full 64-bit int might

[17:43] <pmichaud> er, some int *constants*

[17:43] <colomon> pmichaud: oh, my warning was for your grand Str.Numeric refactor.

[17:43] <pmichaud> ah

[17:43] <pmichaud> yes, that's good to remember

[17:44] <pmichaud> (and no, I hadn't thought of it yet.  colomon++)

[17:45] <colomon> pmichaud: if you're switching to 64-bit Ints mostly by changing upgrade_to_num_if_needed, then the issue isn't switching to nums too early -- it's output an int that was calculated internally using nums, so it's not as precise as it should be.

[17:45] <moritz_> phenny: tell Kodi fyi your patches don't have a proper email address (not problem, but if it's a misconfiguration, you'd might want to know)

[17:45] <phenny> moritz_: I'll pass that on when Kodi is around.

[17:45] <colomon> *outputing.

[17:45] <pmichaud> but at that point it's no longer an int :-)

[17:46] <pmichaud> oh, I see.

[17:46] <pmichaud> yes.

[17:46] <pmichaud> it'll incorrectly act like an int when it's really not.

[17:46] *** plobsing_ joined
[17:46] <colomon> patrickas: if the series refactor passes all the spectests and is ready to go, I'm all in favor of using it ASAP.

[17:47] <colomon> pmichaud: specifically, it will generate an Int, but have lost some digits of precision along the way.

[17:47] <colomon> you can actually do that already on 64-bit machines, it's just tricky.

[17:47] <colomon> (I don't think it affects constants, but you can do calculations that cause the effect, I believe.)

[17:47] <patrickas> colomon: great! Yes it passes all the currently unfudged spectests... as soon as it lands we can unfudge about a dozen more!

[17:48] <pmichaud> colomon: sure, calculations that cause it are definitely possible.

[17:48] <pmichaud> I'll think about it a bit more, then.

[17:48] <pmichaud> we could arbitrarily stop at whatever int value won't cause num issues

[17:48] <colomon> pmichaud: I don't know that it's a reason *not* to switch to 64-bit Ints, it's just something to be aware of.

[17:48] <pmichaud> (if there is such a value)

[17:49] <pmichaud> well, claiming something is integer precision when it's really not sounds like a serious problem to me

[17:49] <pmichaud> so I'm inclined to not make that switch.

[17:50] <pmichaud> I may still get integer constants to use 64-bit when available.

[17:50] <pmichaud> (in NQP, at least.)

[17:52] <pmichaud> rakudo:  say +('abc12def45' ~~ / \d+ /)

[17:52] <p6eval> rakudo d84752: OUTPUT«12␤»

[17:53] <pmichaud> rakudo:  say +('abc12def45' ~~ / (\d)\d+ /)

[17:53] <p6eval> rakudo d84752: OUTPUT«12␤»

[17:53] <pmichaud> afk, lunch.

[17:56] *** Holy_Cow left
[17:56] *** Holy_Cow joined
[17:57] *** cotto_work joined
[17:57] <cotto_work> is "Mu" pronounced "moo" or "mew"?

[17:57] * [Coke] sees a conversation about twigils on p5p and is temporarily confused.

[17:58] <TimToady> I do cow, not cat.

[17:58] * [Coke] assumed it was like the greek letter.

[17:58] <TimToady> which is also pronounced both ways :)

[17:58] * patrickas pronounces it as the french vu , du

[17:58] <rhebus> class TimToady does Cow

[17:58] <moritz_> cotto_work: I pronounce it 'moo'

[17:58] <moritz_> like the greek µ

[17:59] <moritz_> no, not quite

[17:59] * Util says 'moo'

[17:59] <rhebus> i presumed it was the zen thing. I pronounce µ cat but zen mu cow

[18:00] <TimToady> yes, it's the zen thing; doesn't really have anything to do with greek

[18:02] <TimToady> actually it should be pronounced 無   :)

[18:02] *** rainerschuster joined
[18:03] <rhebus> got pinyin for that? :)

[18:03] <[Coke]> is  む  ok? ;)

[18:03] <TimToady> in Japanese it is

[18:03] <rhebus> you know i think we're the only ones who have really benefited from unicode :)

[18:03] <[Coke]> 무 is easier to draw. 

[18:03] <TimToady> in Chinese it would come out more /wu2/

[18:04] * moritz_ has too

[18:04] * [Coke] wonders if it's related to the wu in wushu.

[18:05] <smash> TimToady: beadsort in Perl 6 (translated from haskell) http://gist.github.com/568057

[18:06] <TimToady> I saw that

[18:06] <colomon> smash: where is transpose coming from?

[18:06] <TimToady> see the use

[18:06] <smash> colomon: from my List::Utils (which i originally forked from yours)

[18:07] <TimToady> most anything from that module ought to be built-in

[18:07] <smash> but mine has the transpose

[18:07] <colomon> smash: ah

[18:07] <smash> TimToady: from which module ?

[18:07] <TimToady> List::Utils

[18:07] <colomon> smash: url?

[18:08] <TimToady> transpose ought to be built in, anyway

[18:09] <cotto_work> So the proper answer to my question is "learn Chinese". ;)

[18:09] <TimToady> in this case, no, learn Japanese :)

[18:09] <cotto_work> That's much easier.

[18:09] <TimToady> which is why it's anglicized as Mu

[18:10] <TimToady> but that should just be Texas version of 無

[18:10] <sbp> talking of anglicisation, mu and moo aren't homophones in British English... :-)

[18:10] <phenny> sbp: 16:49Z <MattRead> ask sbp I don't see the "not yahoo" phenny module in source. I assume it's like the last version and I need to please you to get it?

[18:10] *** tadzik joined
[18:10] <tadzik> hello

[18:10] <sahadev> rakudo: ("f","oo","bar").>>.chars

[18:11] <TimToady> sbp: we were just discussing that above

[18:11] <p6eval> rakudo d84752: OUTPUT«===SORRY!===␤Confused at line 22, near "(\"f\",\"oo\","␤»

[18:11] <rhebus> sbp: i'd argue "mu" as transliteration from japanese is still "moo" in british english

[18:11] <[Coke]> TimToady: I eagerly anticipate the audio links on perl6.org with pronounciation guides. ;)

[18:11] <sbp> hmm, I'm sure we have a Zen centre around here somewhere

[18:11] <sbp> I should go and ask them

[18:11] <rhebus> wow, i've never had a blog post with nearly this many views before

[18:12] <tadzik> what blog post?

[18:12] <rhebus> up to 7 on reddit /r/programming

[18:12] <rhebus> http://rhebus.posterous.com/learning-perl-6-by-playing-silly-games

[18:12] <moritz_> rhebus: how many did you have so far?

[18:12] <rhebus> 777

[18:12] <TimToady> note that they will not pronounce it "moo" like a cow, but with a very short u

[18:12] <rhebus> TimToady: so, not like a cow.

[18:13] <TimToady> but not palatalized either

[18:13] <rhebus> gah, can't read. never mind

[18:13] <TimToady> in isolation it will tend to come up with a glottal stop on the end

[18:13] <rhebus> yay for glottal stops

[18:13] <rhebus> they remind me of home

[18:13] <cotto_work> like a short cow.  got it

[18:13] <TimToady> like the first o in oh-oh, only with u

[18:14] <TimToady> like the first oo in oo-ooh  :)

[18:15] <rhebus> i'm imagining a cow which gets shot just as it starts mooing

[18:16] <TimToady> otoh, a japanese cow doesn't say moo, it says moh

[18:16] <TimToady> with a long o

[18:16] <TimToady> moooooh

[18:16] <rhebus> is that what the japanese say their cows say, or is it actually what the cows say?

[18:16] <rhebus> (do cows have regional accents?)

[18:17] <TimToady> and there's no native long mū sound, only in borrowings

[18:17] *** mberends joined
[18:17] <TimToady> no, they all speak Standard Cow, it's just the transliteration that differs

[18:18] <TimToady> the Japanese u is a bit tighter than English's u, so o sounds hollower--more like a cow than u does, anyway

[18:18] <sbp> hmm

[18:18] <sbp> OED says:

[18:19] <sbp> Brit. /mu:/, U.S. /mu/

[18:19] <sbp> (mu, n.|3| and int.)

[18:19] <rhebus> sbp: :P

[18:19] <TimToady> that

[18:19] <TimToady> that's what u: think

[18:19] <sbp> hehe

[18:20] <[Coke]> that's a terribull pun.

[18:20] * TimToady thinks that's a silly use of :

[18:21] <sbp> well it should be ː of course...

[18:21] <rhebus> regarding tic tac toe, I've just realised that (0,3,6 X+ ^3) could just be ^9...

[18:22] <rhebus> i wish posterous's editor didn't suck so much

[18:22] *** macroron left
[18:27] *** jhuni joined
[18:30] *** rainerschuster left
[18:30] <sahadev> this example from http://perlcabal.org/syn/S03.html#Hyper_operators doesn't seem to work: ("f","oo","bar").>>.chars # should return (1,2,3)

[18:31] <sahadev> has something changed? or is it a bug?

[18:31] <moritz_> >>.chars works

[18:31] <moritz_> without the leading .

[18:31] <moritz_> we already have a ticket for that

[18:33] <sahadev> moritz_: thanks. which is right? with or w/o leading "."?

[18:33] *** patrickas left
[18:34] *** rainerschuster joined
[18:34] <lue> ohai o/ #phasers today?

[18:37] <pmichaud> back from lunch

[18:38] <colomon> sahadev: ("f","oo","bar")>>.chars is correct code.  not sure if the adding the leading '.' is legal or not.  (there may be more than one way to do it.)

[18:38] <tylercurtis> std:("f", "oo", "bar").>>.chars

[18:38] <p6eval> std 32123: OUTPUT«ok 00:01 118m␤»

[18:39] <colomon> tylercurtis++

[18:39] <sahadev> thanks, colomon and tylercurtis.

[18:39] *** jhuni left
[18:41] <tylercurtis> I think that the .>>.meth form is probably like .++, .(...), .<...>, etc.

[18:46] *** tadzik left
[18:46] *** mfollett joined
[18:47] *** ashleydev left
[18:47] *** ashleydev joined
[18:48] <mberends> \o/ Amsterdam.pm is about to open the beers that were auctioned off for a record €444 in Pisa

[18:49] <jnthn> yay beer!

[18:49] <jnthn> Na zdravje!

[18:49] <TimToady> I hear it's a really good label.  :)

[18:49] *** _jaldhar_ joined
[18:49] * ash_ just images Bender chugging them all real fast like (see Futurama) 

[18:50] * TimToady looks at the T-shirt he got for bargain price of €440

[18:51] *** timbunce joined
[18:51] <mberends> Wendy was just telling the crowd here about the T-shirt :)

[18:51] <TimToady> be sure to tell them that beer won an award :)

[18:52] <[Coke]> jnthn: I know that's not bulgarian, but I have to squint to prove it.

[18:53] *** jaldhar_ left
[18:53] <moritz_> #phasers pre-reports seem to be quite the fashion thoday

[18:54] <moritz_> rakudo: say 'ab' Xxx 1, 3, 1

[18:54] <p6eval> rakudo 0d6d57: OUTPUT«ababababab␤»

[18:54] <moritz_> rakudo: say ('ab' Xxx 1, 3, 1).perl

[18:54] <p6eval> rakudo 0d6d57: OUTPUT«(("ab"), ("ab", "ab", "ab"), ("ab"))␤»

[18:54] <moritz_> rakudo: say ('ab' Xx 1, 3, 1).perl

[18:55] <p6eval> rakudo 0d6d57: OUTPUT«("ab", "ababab", "ab")␤»

[18:55] <jnthn> [Coke]: It was a perhaps mis-spelt attempt at Slovene this time. :-)

[18:55] <jnthn> [Coke]: Was on holiday there last week :-)

[18:56] <lue> .oO(Molybdenum is available for me to buy? Wow!)

[18:57] <sorear> good * #perl6

[18:57] <phenny> sorear: 17:37Z <diakopter> tell sorear wow...! http://github.com/sorear/niecza/commit/c54087f32fdab5cd4de1d5e60572829870f98fe0

[18:59] <sorear> ash_: pong

[19:01] <ash_> sorear: i was going to ask if i could control the encoding in IO::Pty::HalfDuplex on the subprocess, but it turns out that wasn't the problem, it was something else in my code that was broken, sorry about that 

[19:01] *** snearch joined
[19:01] *** Ross joined
[19:09] *** dalek left
[19:10] *** dalek joined
[19:10] *** ChanServ sets mode: +v dalek

[19:14] <TimToady> rhebus: re http://irclog.perlgeek.de/perl6/2010-09-07#i_2793687 you can actually use hyphen or apostrophe between any two legal idents, so the left side could be numeric, but not the right side

[19:14] <TimToady> a42-b33 is legal, but not a42-33b

[19:15] *** tadzik joined
[19:19] <pmichaud> so, $r2-d2 is legal, but $c-3p0 isn't.  :-P

[19:20] <TimToady> everyone knows that R2-D2 is street legal, and C-3PO isn't...

[19:20] *** ashleydev left
[19:21] *** ashleydev joined
[19:22] <TimToady> though what "street legal" means in terms of X-wings, I'm not entirely clear...

[19:23] <pmichaud> .oO( "These aren't the droid identifiers you're looking for..." )

[19:24] <rhebus> TimToady: wow, that's above and beyond the call of duty. thanks :)

[19:26] <ash_> ping lue 

[19:26] <TimToady> well, I really should've addressed it to masak++, but I don't like to leave misapprehensions unchallenged, no matter how minor.  consider it a character flaw.  :)

[19:26] <tadzik> ash_: you want some assistance writing the chapters for try.rakudo.org?

[19:26] <ash_> tadzik: yes. that would be awesome, are you familiar with javascript? 

[19:27] <tadzik> ash_: not really

[19:27] *** Ross left
[19:27] <ash_> tadzik: how about json? 

[19:27] <tadzik> well, that's not a hard one :)

[19:28] <ash_> if not thats fine, but i am keeping the chapter data in json format, i need to do some touch up to get the chapter loaded/example executer working properly, but i can try to get that taken care of asap so you (and hopefully others) can write chapters

[19:28] <ash_> i fixed the utf-8 issues, and the script tag issues on my test server, i am going to push those changes live tonight for try.rakudo.org

[19:30] <lue> pong ash_

[19:30] <sorear> What should I call a Perl 6 object that fills the traditional role of an iterator?

[19:30] *** _macdaddy left
[19:30] <ash_> lue: did you ever have a way of making perl6 identifiers read only? 

[19:30] <ash_> using pir

[19:30] <ash_> i thought you had something that did that for := or ::= 

[19:31] *** Ross joined
[19:32] *** plainhao left
[19:32] <lue> pir::delprop__0Ps($target, 'rw');  # is this what you want?

[19:34] <ash_> maybe? that sounds right

[19:34] <ash_> thanks

[19:34] *** ashleydev left
[19:34] *** ashleydev joined
[19:35] <lue> Note that it deletes the rw attribute, and does not set the readonly attribute (according to pmichaud, they're separate)

[19:36] <pmichaud> there is no readonly attribute.

[19:36] <pmichaud> at least, not yet.

[19:36] <pmichaud> anything not marked rw is readonly.

[19:37] <ash_> alright, cool

[19:37] <pmichaud> (but this doesn't say anything about whether a symbol can be rebound.)

[19:38] <jnthn> fwiw, we used to flag readonly instead of rw and it was a Bad Idea to do it that way around.

[19:40] <pmichaud> I find it's much safer to assume everything is readonly unless explicitly marked otherwise.  :)

[19:41] <jnthn> Aye, it's working _much_ better for us that way.

[19:41] <TimToady> capabilities++

[19:41] <pmichaud> and Perl 6 agrees, thus   has $.xyz    defaults to read-only accessor  :)

[19:42] *** rschuster joined
[19:42] <pmichaud> afk, kid pickup

[19:42] <ash_> well, i was planning on making @*INC readonly for the try.rakudo site, to prevent people from trying mess with things that way

[19:42] *** rainerschuster left
[19:42] <ash_> but since you can always just do my @*INC; later, does that matter? 

[19:43] *** rschuster is now known as rainerschuster

[19:44] <TimToady> well, there are a whole bunch of things that shouldn't work in a sandbox

[19:45] <ash_> any obvious suggestions? for those of us who aren't thinking outside of the sandbox

[19:45] <TimToady> a real capabilities model?

[19:46] <TimToady> "you can't open this door because you haven't been given the key"

[19:46] <TimToady> perhaps that's a bit beyond your current aspirations though.  :)

[19:47] <sorear> rakudo: eval 'pir::spawnw__is("ls")'

[19:47] <p6eval> rakudo 0d6d57: OUTPUT«build␤Configure.pl␤CREDITS␤docs␤dynext␤LICENSE␤Makefile␤parrot␤perl6␤perl6.c␤perl6_group.c␤perl6_group.h␤perl6_group.o␤perl6.o␤perl6.pbc␤README␤src␤t␤Test.pir␤Test.pm␤tools␤VERSION␤»

[19:47] <tadzik> oh funny

[19:47] <Util> I am still looking for a way to recursively flatten (since flat() only does one level), or to make [\,] behave as described in S03.

[19:47] <Util> ( see http://irclog.perlgeek.de/perl6/2010-09-07#i_2792939 )

[19:48] <Util> Any ideas?

[19:48] <TimToady> Util: flat is supposed to be recursive in that case

[19:48] <TimToady> we were discussing this earlier today

[19:48] <ash_> sorear: i disable pir, so hopefully that won't work

[19:49] <tadzik> ash_: it doesn't

[19:49] <TimToady> that is, flat is supposed to be recursive on mere Parcels

[19:49] <lue> afk

[19:50] <TimToady> rakudo: say (1, (2, (3, 4)))

[19:50] <p6eval> rakudo 0d6d57: OUTPUT«1234␤»

[19:50] <TimToady> rakudo: say (1, (2, (3, 4))).flat.perl

[19:50] <p6eval> rakudo 0d6d57: OUTPUT«(1, 2, 3, 4)␤»

[19:50] <ash_> rakudo: my @a = (1, 2, [3, [[4]]); say flat(@a).perl

[19:50] <p6eval> rakudo 0d6d57: OUTPUT«===SORRY!===␤Confused at line 22, near "my @a = (1"␤»

[19:50] <ash_> rakudo: my @a = (1, 2, [3, [[4]]]); say flat(@a).perl

[19:50] <TimToady> flat is not supposed to flatten []

[19:50] <p6eval> rakudo 0d6d57: OUTPUT«(1, 2, [3, [[4]]])␤»

[19:50] <ash_> ah

[19:51] <TimToady> it's like the difference between $array and @array in list context

[19:51] * Util finally sees the scrollback on flat() that he missed. Catching up...

[19:52] <moritz_> rakudo: say ?'0abc'.index('0')

[19:52] <p6eval> rakudo 0d6d57: OUTPUT«0␤»

[19:52] <moritz_> rakudo: say '0abc'.index('0').perl

[19:52] <p6eval> rakudo 0d6d57: OUTPUT«0␤»

[19:52] <moritz_> rakudo: say '0abc'.index('3')

[19:52] <p6eval> rakudo 0d6d57:  ( no output )

[19:52] <moritz_> rakudo: say '0abc'.index('3').defined

[19:52] <p6eval> rakudo 0d6d57: OUTPUT«0␤»

[19:53] <TimToady> rakudo: say '0abc'.index('3').WHAT

[19:53] <p6eval> rakudo 0d6d57: OUTPUT«Failure()␤»

[19:53] <TimToady> that's probably better than Nil

[19:55] <TimToady> should probably be StrPos though

[19:55] <TimToady> and the StrPos of 0 should be true

[19:55] <tylercurtis> jnthn: regarding Parrot profiling: I'd worry about getting it to work with Rakudo before worrying about getting it to be more useful with Rakudo.

[19:56] <jnthn> tylercurtis: My guess was that "doesn't work with" was partly "gives meaningless positions".

[19:56] <tylercurtis> jnthn: Rakudo doesn't run under the profiling runcore.

[19:56] <jnthn> Oh.

[19:57] <jnthn> I...thought it once did. :(

[19:57] <tylercurtis> http://trac.parrot.org/parrot/ticket/1768

[19:57] <pmichaud> it once did, but now is broken.

[19:57] <jnthn> Well, scheise.

[19:57] *** spq1 left
[19:58] <tylercurtis> Not with NQP either, it seems: http://trac.parrot.org/parrot/ticket/1745 , for the same apparent reason.

[19:58] <pmichaud> oh wow, that's.... intersting.

[19:58] *** rlb3_ joined
[19:58] <pmichaud> I would've expected it to work with nqp.

[19:59] <tylercurtis> pmichaud: you submitted that NQP ticket.

[19:59] <sorear> ash_: my $*FORBID_PIR; eval '' ?

[19:59] <pmichaud> tylercurtis: that must've been my other brain.

[19:59] *** Italian_Plumber left
[19:59] <jnthn> Oh, the erorr is in Regex;Cursor

[19:59] <jnthn> So it makes sense if it hits NQP, it'll hit Rakudo too

[19:59] <moritz_> rakudo: use FORBID_PIR; my $*FORMBID_PIR; eval 'pir::printerr__vS("foo")'; say $!

[19:59] <p6eval> rakudo 0d6d57: OUTPUT«pir::op forbidden in safe mode␤␤»

[19:59] <pmichaud> the one I have today hasn't been firing properly

[20:00] <moritz_> rakudo: use FORBID_PIR; my $*FORBID_PIR; eval 'pir::printerr__vS("foo")'; say $!

[20:00] <p6eval> rakudo 0d6d57: OUTPUT«pir::op forbidden in safe mode␤␤»

[20:01] <colomon> ah, that's the error I was getting when I tried to profile, indeed!

[20:01] *** kjeldahl left
[20:01] <pmichaud> Cursor.pir:22 is     load_bytecode 'P6object.pbc'

[20:02] <pmichaud> so that doesn't really tell us much, other than this is likely the first place that load_bytecode is encountered.

[20:02] <pmichaud> so maybe profiling runcore doesn't like load_bytecode

[20:02] * pmichaud checks

[20:09] *** Guest31998 left
[20:10] *** Italian_Plumber joined
[20:11] <pmichaud> http://trac.parrot.org/parrot/ticket/1745#comment:3  # load_bytecode seems a likely culprit

[20:12] *** snearch left
[20:13] <ash_> sorear: my $*FORBID_PIR doesn't work (as far as i can tell) 

[20:13] <tylercurtis> pmichaud: perhaps check if that happens with other bytecodes than p6object.pbc in case the problem is actually somewhere in p6object.pbc(or in the profiling runcore breaking p6object.pbc)?

[20:14] <pmichaud> tylercurtis: dumper.pbc works

[20:14] <pmichaud> but iirc P6object.pbc doesn't do anything terribly .... unusual

[20:14] *** bacek joined
[20:14] *** Italian_Plumber left
[20:16] <pmichaud> istr that profiling runcore didn't like tailcalls, though.

[20:17] <pmichaud> removing the tailcalls in P6object.pir doesn't seem to help.

[20:19] *** ash_ left
[20:19] *** timbunce left
[20:21] *** aloha joined
[20:23] *** tadzik1 joined
[20:25] *** cognominal left
[20:25] *** cognominal joined
[20:26] *** timbunce joined
[20:26] *** tadzik left
[20:26] <sorear> I could use a method on Mu which returns .list.[0] efficiently

[20:26] <sorear> What should I call it?

[20:27] <moritz_> .head ?

[20:27] <phenny> Can't connect to http://?

[20:27] <jnthn> Doesn't (argumentless) .first do that?

[20:27] <moritz_> it's in Any, not Mu

[20:27] <sorear> jnthn: I didn't realize it already existed

[20:28] <colomon> rakudo: my @a = 1..10; say @a.first

[20:28] <p6eval> rakudo 0d6d57: OUTPUT«No candidates found to invoke for method 'first' on object of type 'Array'; available candidates have signatures:␤:(Mu : Mu $test;; *%_)␤␤  in main program body at line 22:/tmp/Q9aFS9q_7L␤»

[20:28] <moritz_> but .first could certainly be made to default to True, if it doesn't already

[20:28] <colomon> it doesn't.

[20:28] <jnthn> Maybe a nice thing to do

[20:28] <colomon> and it's not spec'd to do so, either.

[20:29] <moritz_> that can be changed :-)

[20:29] <colomon> indeed.  :)

[20:29] <moritz_> just make $test = True a default

[20:29] <moritz_> \o/ Perl 6 solved my first nonogram :-)

[20:31] <rhebus> moritz_: submit the code to perl6-examples/99-problems/P98-moritz.p6 :)

[20:32] * PerlJam feels a blog post coming soon.

[20:32] <moritz_> rhebus: currently I develop it in a separate repo

[20:32] <moritz_> http://github.com/moritz/Nonogram/

[20:33] *** timbunce left
[20:33] <PerlJam> turtle++

[20:33] <moritz_> it successfully solves this one here: http://de.wikipedia.org/wiki/Nonogramm#Beispiel

[20:36] <rhebus> what does it do if you give it an ambiguous nonogram?

[20:36] <rhebus> (eg 1,1/1,1)

[20:36] <moritz_> not solve it completely

[20:36] <rhebus> fair enough

[20:37] *** tadzik1 is now known as tadzik

[20:37] <pmichaud> > my %h = a => 1;  'a' ~~ /./;  say %h{$/};

[20:37] <pmichaud> 1

[20:37] <PerlJam> moritz_: how long did it take to solve that one?

[20:37] <moritz_> PerlJam: about 6s

[20:38] <PerlJam> moritz_: maybe you should add it to benchmarks :)

[20:39] <jnthn> pmichaud: yay :-)

[20:39] <dalek> rakudo: 19a8b71 | pmichaud++ | src/core/Any-list.pm:

[20:39] <dalek> rakudo: Add Match workarounds for .[] and .{} to (temporarily) allow match objects to do something sane.  Addresses RT #75868.

[20:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/19a8b71011563e325b65744b3c4f935253fe3c01

[20:41] <moritz_> now curious what will make out of http://de.wikipedia.org/w/index.php?title=Datei:Paint_by_numbers_Animation.gif&filetimestamp=20060913140813

[20:41] <diakopter> .head .

[20:41] <phenny> Can't connect to http://.

[20:41] *** mberends left
[20:41] <diakopter> .head irc.perl6.org

[20:41] <phenny> diakopter: 301, text/html, iso-8859-1, 323 bytes

[20:42] <moritz_> I've read that Nonograms are NP :/

[20:42] *** perlygatekeeper left
[20:43] *** perlygatekeeper joined
[20:43] <PerlJam> Perl 6: making NP-easy things easy and NP-hard things possible.

[20:43] <jnthn> .head localhost

[20:43] <phenny> jnthn: 200, text/html;charset=UTF-8, 2846 bytes

[20:43] <moritz_> .get localhost

[20:44] *** ashleydev left
[20:45] <sbp> .title http://localhost/

[20:45] <phenny> sbp: Index of /

[20:45] <moritz_> .title http://localhost/cgi-bin/

[20:45] <phenny> Can't connect to http://localhost/cgi-bin/

[20:46] *** stepnem left
[20:46] <colomon> nonograms: oh, those! (backlogging)

[20:47] *** stepnem joined
[20:49] *** ashleydev joined
[20:53] *** M_o_C left
[20:55] *** mfollett left
[20:55] <dalek> niecza: b6871bc | sorear++ | / (5 files):

[20:55] <dalek> niecza: Use fastpath code to get first list element

[20:55] <dalek> niecza: 

[20:55] <dalek> niecza: Avoiding lazy list iterators improves parser benchmark ~2x speed.

[20:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b6871bcc1d4e9bc72d8291a77573c0b6e16674f8

[20:59] *** rlb3_ left
[20:59] *** rgrau_ joined
[20:59] *** Italian_Plumber joined
[21:03] *** mfollett joined
[21:04] *** Italian_Plumber left
[21:15] *** whiteknight joined
[21:21] <sjohnson> perl!

[21:22] *** javs left
[21:22] <tadzik> repl!

[21:22] <sjohnson> bheh

[21:23] *** lamstyle left
[21:25] *** lamstyle joined
[21:27] *** tadzik left
[21:28] *** cpr joined
[21:28] *** cpr left
[21:30] *** dakkar left
[21:31] * diakopter read Kernel.cs with interest

[21:31] <diakopter> hey, it's readable! :)

[21:35] <sorear> really?

[21:35] * sorear out.

[21:36] <TimToady> I get server not found.  :)

[21:38] <diakopter> heh

[21:38] <diakopter> .head Kernel.cs

[21:38] <phenny> Can't connect to http://Kernel.cs

[21:40] *** Holy_Cow left
[21:42] *** ash_ joined
[21:45] *** ash_ left
[21:51] <sjohnson> hi TimToady how's life

[21:56] *** yrgd joined
[21:59] * rhebus -> sleepytimes

[22:02] *** masonkramer joined
[22:02] *** yrgd left
[22:05] *** sahadev left
[22:12] *** ash_ joined
[22:13] *** stepnem left
[22:13] *** Mowah left
[22:14] *** rhebus left
[22:16] *** stepnem joined
[22:19] *** Italian_Plumber joined
[22:20] *** _jaldhar_ left
[22:22] <lue> hello o/

[22:22] *** jaldhar joined
[22:22] *** mfollett left
[22:22] *** masonkramer left
[22:23] *** mfollett joined
[22:26] *** Ross left
[22:26] *** mfollett left
[22:28] *** rainerschuster left
[22:29] *** jaldhar left
[22:30] *** tylercurtis left
[22:32] *** mberends joined
[22:32] <flussence> perl6: say sprintf('%1$d', 4).WHAT; # just me, or is %$ NYI?

[22:32] *** jhuni joined
[22:32] <p6eval> rakudo 0d6d57: OUTPUT«Failure()␤»

[22:32] <p6eval> ..pugs: OUTPUT«pugs: Printf.printf: bad formatting char $␤»

[22:33] <flussence> hmm, I didn't expect them both to barf.

[22:34] *** dalek left
[22:37] *** dalek joined
[22:37] *** ChanServ sets mode: +v dalek

[22:42] *** mberends left
[23:00] *** krakan joined
[23:12] *** sekimura_ joined
[23:12] *** fridim left
[23:14] *** sekimura left
[23:15] *** yrgd joined
[23:15] *** patspam joined
[23:22] *** bluescreen joined
[23:22] *** bluescreen is now known as Guest82491

[23:25] *** azert0x left
[23:27] *** crythias joined
[23:42] *** svetlins joined
[23:58] *** risou joined
[23:58] *** Patterner left
