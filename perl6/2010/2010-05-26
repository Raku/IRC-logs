[00:00] <TimToady> the ordering of rules can only be partial

[00:00] <TimToady> and some rules are unorderable wrt each other

[00:01] <TimToady> oh, another thing about the trie extension notion is that we can quit as soon as we're down to one possible fate

[00:02] <TimToady> we don't actualy have to follow the \w+ out to the end if it won't change anything

[00:02] <TimToady> since the actual token rule will still decide whether it matches or not

[00:04] <TimToady> the lexers job is really just to order the real rules, not actually find the ends of the tokens

[00:04] <TimToady> *'s

[00:05] <TimToady> the major thrust of S05 is to find some kind of grand compromise between deterministic and non-deterministic matching, and manage the transition between them on behalf of the user

[00:06] *** f00li5h joined
[00:06] <TimToady> that's going to feel awkward at times, for sure

[00:06] <TimToady> hmm, no pun intended

[00:06] *** whiteknight joined
[00:07] <TimToady> but awk matching is deterministic, and not very powerful, while p5 matching is non-deterministic, and not very fast

[00:07] <TimToady> my research is in getting these two relatively immiscible ideas to mix nicely, so I need a certain amount of "detergent"

[00:10] <TimToady> and as with most of the design of Perl over the years, I try to let the design flow primarily from practical considerations of what I really need at the moment, and less from those clean academic sources that are nevertheless fundamental

[00:11] <sorear> Why is remember_alts separate from walk in the gimme5 regex compiler?

[00:11] <TimToady> p6 turns that around a bit and tries to sneak in as much of the fundamental goodness while hiding it from mere mortals, but it's still a grand compromise underneath, and cheating happens to get it all to mesh

[00:11] <TimToady> there was a reason, lemme think

[00:12] <jnthn> The nice thing is that the cheats seem to be increasingly cleanly expressed in terms of the fundemantal goodness. :-)

[00:12] <lue> Hello!

[00:13] <jnthn> Hellue!

[00:13] <lue> Fedora 13 is out, and PPC is now a "secondary architecture"

[00:13] <lue> One reason I picked Fedora was because they treated PPC so well :(

[00:14] <jnthn> Ooh, I didn't know you were running on PPC. Nice that somebody is running Rakudo there. :-)

[00:16] <clkao> win 28

[00:16] <lue> I'm not developing on it. It crashes every time I try to compile [I ssh]

[00:16] <lue> But fedora does provide Rakudo :)

[00:16] <jnthn> Oh :-(

[00:16] <TimToady> sorear: I don't remember offhand from glancing at it; it may have been a result of some fossil external requirement, perhaps forcing certain cross-linkages that are no longer evident, or that I've forgotten

[00:17] <sorear> ok, I won't copy it

[00:17] <sorear> the propagation of @_ also appears to be a fossil

[00:18] <TimToady> if you try to do it in the same pass, and run into a problem, you may have found the reason :)

[00:18] <sorear> the only real way to understand something is to reinvent it

[00:18] <TimToady> it was probably always just there as a just-in-case

[00:18] <TimToady> I don't think I ever used @_ for anything

[00:19] <sorear> viv culture uses locals in %main:: for that stuff

[00:19] <TimToady> the separate pass might have been required under a different model of LTM generation that did more at compile time

[00:19] <TimToady> maybe it will come to me later

[00:20] <TimToady> yes, but contextuals hadn't even been invented yet when that all started

[00:20] <sorear> ...invented?

[00:20] *** synth joined
[00:21] <TimToady> invented into p6

[00:21] <TimToady> when they were, it was a conscious decision to emulate them with locals and give up multi-threading the parser

[00:22] <TimToady> or more precisely, give up on the notion of modelling a cleanly re-entrant parser as long as gimme5 semantics were involved

[00:23] <sorear> gimme5 is older than I had realized

[00:25] <TimToady> in the early design of p6, we just carried locals over as "temp", but eventually I figgered out that temporizing globals was just going to make the same threading headaches that p5 has, so that's when I started de-emphasizing 'temp'

[00:25] <TimToady> and started emphasizing $*FOO semantics, even though we can't actually have them in gimme5-world

[00:25] <TimToady> well, we could, but it would be expensive

[00:25] <TimToady> Pad::Walker, and such

[00:26] <TimToady> one of the reasons the old 'v6' engine was slow was because it did try to emulate a lot of that stuff in p5

[00:26] <TimToady> and as it is, STD.pm5 is only tolerably slow

[00:27] <TimToady> fsdo tolerable...

[00:30] <tedv> Question about committing updates to the pugs unit tests.  I gave someone my email and they said they gave me authorization, but when I commit, it asks for a user name and password.  Where do I set those up?

[00:30] <phenny> tedv: 24 May 03:07Z <jnthn> tell tedv I just use the command line svn client, e.g. from http://subversion.apache.org/packages.html#windows

[00:31] <diakopter> tedv: you should've gotten an email from the svn auth system

[00:31] <diakopter> if you didn't, someone can rerequest one

[00:31] <tedv> I should check my spam filters

[00:31] <tedv> who should the sender be?

[00:31] <diakopter> hrm

[00:31] <diakopter> [email@hidden.address] maybe?

[00:31] <TimToady> commitbit?

[00:32] <tedv> definitely nothing in my inbox

[00:32] *** yinyin joined
[00:32] <diakopter> msg your email address to TimToady :)

[00:32] <tedv> I kind of figured he was busy with important stuff!

[00:33] <TimToady> there's no tedv in there, was it under a different name?

[00:33] <tedv> but alright, I guess it's like calling shotgun, but in reverse

[00:33] <tedv> tedvessenes at gmail dot com

[00:33] <TimToady> okay

[00:33] <diakopter> my childseat isn't allowed in the front row

[00:33] <tedv> because gmail doesn't let me have 4 letter email addresses. :(

[00:33] <TimToady> what do you want for the svn id?

[00:33] <TimToady> tedv?

[00:33] <tedv> tedv sounds good

[00:34] <tedv> namespace there isn't in quite as much demand as gmail addresses

[00:34] <TimToady> okay, sent

[00:34] <tedv> Oh hey, I just got email from audreyt.  Not sure if I quite believe that, but it looks legit

[00:34] <TimToady> it's customary to add yourself to AUTHORS as a test commit

[00:34] <TimToady> yes, she set it up

[00:34] <TimToady> so that's probably it

[00:35] <tedv> Did she just fall off the face of the earth or something?

[00:35] <TimToady> it might have some pugs-vm specific things in there that are no longer operative, but the svn bits should be right

[00:35] <tedv> I had found an extremely simple thing to fix for a test commit, but AUTHORS sounds even simpler.

[00:35] <diakopter> http://twitter.com/audreyt

[00:38] <diakopter> a nit: the pugscode tests aren't unit tests; they're functional tests

[00:38] <tedv> Is there any difference between the pugs repository that rakudo checks out in rakudo/t/spec and the official pugs repository?

[00:39] <TimToady> t/spec is a sub-branch of the official repo

[00:39] <TimToady> if you check out the whole repo you can also fix other things like the specs

[00:39] <[Coke]> if you're *only* dealing with spec tests, I find it easier to work out of rakudo's t/spec

[00:39] <tedv> I suspect it will be a little while before I'm changing the specs

[00:40] <TimToady> and AUTHORS is outside of t/spec too :)

[00:40] <tedv> start small and all that

[00:40] <TimToady> go for broke!

[00:40] <TimToady> there's always a contradictory saying :)

[00:40] <TimToady> look before you leap!  he who hesitates is lost!

[00:41] <lue> Do not make fun of a penguin.

[00:41] <TimToady> Make fun of a penguin.

[00:41] <TimToady> there's another

[00:42] <lue> Ignorance Is Bliss <-> Knowledge is power

[00:42] <tedv> those don't contradict

[00:42] <tedv> since bliss isn't the same thing as power

[00:42] <TimToady> .oO(Oranges, poranges--there's another one)

[00:42] <tedv> "Be innocent as doves and shrewd as serpents"

[00:43] <tedv> Jesus knew how to do it in the SAME SENTENCE

[00:43] <tedv> that's pretty hardcore

[00:43] <diakopter> Prov 26:4, Prov 26:5

[00:43] <TimToady> welcome aboard!  and remember that we work on forgiveness rather than permission, at least for the first 70*7 mistakes.  :)

[00:43] <lue> [I thought it was 70**7]

[00:43] <TimToady> the other reading is 77

[00:43] <tedv> aramaic is not a good language for mathematical precision

[00:43] <diakopter> or accuracy!

[00:44] <tedv> the options are 490 or 77 though.  I don't think powers were in their understanding of math

[00:44] <TimToady> anyway, I'll go for the more forgiving view, at least until you start abusing it.  :)

[00:45] <lue> "I deleted the t/spec folder and commited it. Is that bad?" <== don't do thta

[00:45] <lue> *that

[00:45] <TimToady> there's also: "If anyone has a sword, he should bring it."  "We have two."  "Er, that's enough."

[00:45] <TimToady> that was two too many, as far as Malchus was concerned :)

[00:46] <TimToady> let's see, if I have to forgive you for each file in t/spec, that adds up pretty rapidly...

[00:46] <TimToady> I think you've just exceeded your 490 in one fell swoop.

[00:47] <sorear> TimToady: Is the setting of $PURE used for anything?

[00:47] * sorear thinks not

[00:47] <lue> Oh, but it was replaced with a huge t.p6 file. Does that make up for it? :)

[00:48] <TimToady> I don't believe it is anymore.  might have been related to the separate pass and a different LTM regime

[00:48] *** snarkyboojum left
[00:49] * lue needs to learn to type 'yum upgrade' more often O.o

[00:49] * TimToady just types "yup"

[00:49] <TimToady> and svn update is just "sup"

[00:52] <lue> gup

[00:53] <lue> Git PUll

[00:53] <TimToady> whoops, gotta go to a meeting to find a new "shepherd"

[00:53] <TimToady> since our old one retired

[00:53] <TimToady> back in three hours ±

[00:54] <TimToady> &

[00:55] <lue> That explains why I saw you three hours ago, you time-traveller

[00:55] <lue> [oh wait, maybe that's not what the ± means....]

[01:02] *** snarkyboojum joined
[01:09] <lue> afk whilst upgrading

[01:18] <pugssvn> r30795 | tedv++ | Added self to authors file; also the standard commit test. 

[01:23] * snarkyboojum looks forward to a working REPL :)

[01:28] <snarkyboojum> lue: how's your dna hacking going? :)

[01:37] *** am0c left
[01:45] *** whiteknight left
[01:56] *** meppl left
[02:04] <pugssvn> r30796 | sorear++ | [viv] New two-pass regex compiler based much more closely on gimme5 logic 

[02:05] *** tylerni7 joined
[02:16] *** colomon_phone joined
[02:25] <sorear> TimToady: Is there a tracker for STD.pm6?  I just found another bizarre misparse

[02:25] <sorear> regex foo { <bar(1)> } # The string 'bar' does not appear anywhere in the AST.  <bar> works fine and is parsed using *the same rule*

[02:26] *** cls_bsd joined
[02:27] *** cls_bsd left
[02:27] <pugssvn> r30797 | sorear++ | [viv] Fix normal name assertion undef error 

[02:31] *** cls_bsd joined
[02:32] *** colomon_phone left
[02:33] *** masonkramer joined
[02:42] *** snarkyboojum left
[02:42] *** cls_bsd left
[02:42] *** cls_bsd joined
[02:43] *** cls_bsd left
[02:45] *** plobsing joined
[02:47] *** cls_bsd joined
[02:48] *** cls_bsd left
[02:52] *** cls_bsd joined
[02:52] *** cls_bsd_ joined
[02:53] <pugssvn> r30798 | sorear++ | [viv] Reintroduce | and || 

[02:55] *** snarkyboojum joined
[02:55] *** cls_bsd left
[02:55] *** cls_bsd_ left
[02:55] *** cls_bsd joined
[02:56] *** cls_bsd left
[03:00] *** cls_bsd joined
[03:21] <pugssvn> r30799 | sorear++ | [viv] Implement literal atoms and simple quotes 

[03:26] *** masonkramer left
[03:33] *** mberends joined
[03:35] *** agentzh joined
[03:44] *** gfx joined
[03:45] <sorear> TimToady: What does <regex_block>:!s mean?

[03:45] *** jaldhar joined
[03:47] *** stephenlb joined
[03:55] *** mimcpher joined
[03:55] *** snarkyboojum left
[03:56] *** revdiablo joined
[04:02] *** snarkyboojum joined
[04:09] *** TiMBuS joined
[04:13] *** stephenlb left
[04:13] *** dju joined
[04:14] *** [mark] joined
[04:23] *** dju left
[04:24] *** dju joined
[04:30] *** dju left
[04:31] *** dju joined
[04:31] *** dju left
[04:34] *** JimmyZ joined
[04:40] <pugssvn> r30800 | sorear++ | [STD] Correctly parse sigspace in rules 

[04:40] <pugssvn> r30800 | [viv] Generate .ws calls

[04:40] *** snarkyboojum left
[04:52] <TimToady> sorear: :s turns on :sigspace, so :!s turns it off

[04:55] <sorear> oh, that simple

[04:55] <sorear> I figured it was an adverb to the assertion

[04:56] <TimToady> no, just left the space out because it would have been significant :)

[04:56] <TimToady> and all those internal :s, :i, etc are lexically scoped, for some definition of 'lexical'

[04:57] <sorear> does %*RX predate slangs?

[04:57] <sorear> it seems weird that the regex engine tweaks entirely differently from quotes

[04:58] <TimToady> well, those aren't exactly slangs, since they don't exactly change the parsing

[04:58] <TimToady> they're more like pragmas

[04:58] <sorear> %*RX<s> changes what <.ws> matches

[04:58] <sorear> there were 2 bugs

[04:58] <sorear> 1. rule did nothing to actually set %*RX<s>

[04:59] <sorear> 2. someone tested 's' using $*RX<s> in a fit of p5think

[04:59] <sorear> both fixed

[04:59] <TimToady> well, kinda, but really it's only supposed to change the meaning of non-null whitespace

[04:59] <TimToady> 2. gee, who could've that been

[04:59] * TimToady looks around for someone to blame

[04:59] *** snarkyboojum joined
[05:01] <TimToady> as for STD trackers, I keep a private todo file

[05:01] <TimToady> so your message is already in it :)

[05:03] <sorear> and yes, now that I've gotten viv to the state where I can just copy code from gimme5, things are going much faster :D

[05:04] <TimToady> \o/

[05:04] <TimToady> looks like we're throwing out the longname with a language change that is not subsumed, maybe

[05:13] *** kaare joined
[05:13] *** kaare is now known as Guest65941

[05:20] *** kel__ joined
[05:27] *** slavik joined
[05:46] *** XaeroOne joined
[05:56] *** uniejo joined
[05:59] *** TSa joined
[06:00] <moritz_> good morning

[06:01] <spinclad> gutn morgn, moritz_ 

[06:01] <TSa> HaloO

[06:01] <dalek> nqp-rx: 814727d | pmichaud++ |  (7 files):

[06:01] <dalek> nqp-rx: Enable outer_ctx handling in NQP programs (e.g., via NQP::Compiler.eval).

[06:01] <dalek> nqp-rx: Establish some infrastructure to make it easier for other compilers

[06:01] <dalek> nqp-rx: to do the same.

[06:01] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/814727d55f980f2d93efac9ef1a630e58a431147

[06:01] <dalek> nqp-rx: d905d5b | pmichaud++ | src/cheats/parrot-callcontext.pir:

[06:01] <dalek> nqp-rx: Skip any null lex_pad entries in the outer_ctx chain.

[06:01] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/d905d5b9f3e3f9f7bdb117d7fa38988311bcda98

[06:01] <dalek> nqp-rx: 9125c3c | pmichaud++ | src/HLL/Actions.pm:

[06:01] <dalek> nqp-rx: Add HLL::Actions.CTXSAVE to make it easy for compilers to save contexts.

[06:01] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/9125c3c4277abf6f1bb2f5ebfaf5863d8b2a3993

[06:01] <dalek> nqp-rx: c5659bb | pmichaud++ | src/HLL/Compiler.pm:

[06:01] <dalek> nqp-rx: Clean up exception printing when catching exceptions in interactive mode.

[06:01] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/c5659bb1223d697620f9dc3d591a493851c9999a

[06:05] <sorear> good morning pmichaud

[06:05] <sorear> was my efforts helpful?

[06:20] *** jhuni joined
[06:21] *** Su-Shee joined
[06:22] *** jakk joined
[06:23] *** jakk left
[06:26] *** Eevee joined
[06:27] <JimmyZ> std: my @foo = <a c d>; for @foo (sub bar() { say $^a; })();

[06:27] <p6eval> std 30800: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block at /tmp/SnAnZP2bFv line 1:␤------> [32mmy @foo = <a c d>; for @foo [33m⏏[31m(sub bar() { say $^a; })();[0m␤    expecting any of:␤     bracketed infix␤  infix or meta-infix␤Parse failed␤FAILED 00:01 114m␤»

[06:27] <JimmyZ> rakudo: my @foo = <a c d>; for @foo (sub bar() { say $^a; })();

[06:27] <p6eval> rakudo 240400: OUTPUT«Missing block at line 11, near "(sub bar()"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[06:32] <TimToady> you have to use map if you want that kind of indirection

[06:41] <JimmyZ> I just got a known bug :)

[06:45] <aesop> whats $^a

[06:45] <sorear> a self-declared positional parameter

[06:45] <sorear> like a named $_

[06:45] <aesop> ahh

[06:45] <sorear> if you have $^a in a block, it's automatically added as a parameter

[06:46] *** BrowserUk joined
[06:46] <sorear> { $^a leg $^b } # this is a 2-ary block usable as a sort callback

[06:55] <moritz_> rakudo: say  {$^a leg $^b}

[06:55] <p6eval> rakudo 240400: OUTPUT«_block46␤»

[06:56] <moritz_> rakudo: say  {$^a leg $^b}.signature.perl

[06:56] <p6eval> rakudo 240400: OUTPUT«:(;; Mu $a, Mu $b)␤»

[07:00] <sorear> std: /a ** 2 - 3/

[07:00] <p6eval> std 30800: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex metacharacter (must be quoted to match literally) at /tmp/jIjYCOpZW3 line 1:␤------> [32m/a ** 2 - [33m⏏[31m3/[0m␤Unable to parse regex; couldn't find final '/' at /tmp/jIjYCOpZW3 line 1:␤------> [32m/a ** 2 -

[07:00] <p6eval> ..[33m⏏[31m3/[0m…

[07:01] <sorear> TimToady: potential for awesomeness

[07:02] <sorear> TimToady: What does <foo>:? mean?

[07:03] <sorear> STD doesn't parse it, but it's implied to be legal in S05

[07:03] <TimToady> S05:2089

[07:04] <sorear> yes...

[07:04] <sorear> that's where it's implied to be legal

[07:04] <sorear> but I can't figure out what the semantics are

[07:06] *** viklund joined
[07:10] <TimToady> well, eager vs greedy is only meaningful when applied to a quantifier, so <foo>:? merely means it can be backtracked into, and :! would likely have the same effect

[07:10] <TimToady> whereas <foo>: may not backtrack into <foo>

[07:10] <sorear> I see.

[07:10] <sorear> What is :+ ?

[07:11] <TimToady> same as :!

[07:11] <TimToady> or is it the same as :

[07:12] <sorear> it doesn't seem to be specced

[07:12] <sorear> except in gimme5

[07:13] <TimToady> I think *+ and ++ are ratcheting forms in some regex languages

[07:13] <sorear> p5 ;)

[07:14] *** masak joined
[07:14] <masak> oh hai, #perl6!

[07:14] <m6locks> o hai guise

[07:15] <TimToady> it was added after p6 had specced :!, so there's some thought of adding it or switching to it

[07:15] <sorear> STD parses <foo>:? as two atoms, the latter of which is quantified

[07:15] <sorear> is this correct?

[07:15] <TimToady> no

[07:20] *** snarkyboojum left
[07:25] <moritz_> rakudo: say samecase('FoO', 'bar')

[07:25] <p6eval> rakudo 240400: OUTPUT«foo␤»

[07:26] <moritz_> rakudo: say samecase('FoO', 'bAr')

[07:26] <p6eval> rakudo 240400: OUTPUT«fOo␤»

[07:26] <moritz_> rakudo: say samecase('FoObar', 'bAr')

[07:26] <p6eval> rakudo 240400: OUTPUT«fOobar␤»

[07:26] <moritz_> rakudo: say samecase('FoObar', 'bAR')

[07:26] <p6eval> rakudo 240400: OUTPUT«fOOBAR␤»

[07:34] *** rgrau[1] joined
[07:38] *** XaeroOne left
[07:39] <TimToady> zzz &

[07:40] *** snarkyboojum joined
[07:41] <mathw> Morning

[07:43] <masak> go' mo'

[07:45] *** snarkyboojum left
[07:47] <pugssvn> r30801 | sorear++ | [viv] Implement quantifiers 

[07:47] <jnthn> oh morning

[07:50] <masak> :)

[07:50] <masak> mmm. auto-print in the REPL.

[07:50] <jnthn> masak: You likes it? :-)

[07:51] <masak> it almost made me forget for a while that variables don't survive to the next line. almost. :)

[07:51] <moritz_> ... until you used a variable from the previous line, and it segfaulted?

[07:51] <masak> actually, yes.

[07:51] <masak> and I see from the backlog that others did the same.

[07:53] <moritz_> my plan for this week's contribution: implement :samecase in .subst

[07:53] <masak> sounds good.

[07:53] <moritz_> should be about 5 lines of patch, if done right

[07:53] <moritz_> + tests

[07:54] <jnthn> +1

[07:54] <mathw> tests++

[07:57] <masak> so... next week, the rakudosketch meeting will take place in... #phasers? :P

[07:57] <moritz_> yes

[07:57] <jnthn> Yes

[07:57] <masak> I leave you guys alone for five minutes... :P

[07:57] *** yinyin left
[07:57] <jnthn> We're all pretty fired up about the idea.

[07:58] <jnthn> I'd bank on this name lasting a while.

[07:58] <masak> oh no, now all the puns get triggered.

[07:58] <jnthn> It's OK.

[07:58] <jnthn> Jag har svenska klass nu. :-)

[07:58] <masak> \o/

[07:58] *** rgrau[1] left
[07:59] <JimmyZ> who owns #rakudosketch?

[07:59] * moritz_ actually understood that :-)

[07:59] <moritz_> JimmyZ: nobody. That's the problem :-)

[07:59] <masak> JimmyZ: it's not registered.

[08:00] <JimmyZ> nobody can unset it?

[08:00] *** yinyin joined
[08:00] <JimmyZ> bad

[08:00] <moritz_> we've beeen more careful with #phasers

[08:02] * masak .oO( especially the 'business end' of the phasers )

[08:02] <JimmyZ> two guys is there. sorear and PerlJam 

[08:02] <JimmyZ> *are

[08:03] <masak> nice fellows. I like them.

[08:04] <masak> they're six days early, though :P

[08:04] <moritz_> no, one day late

[08:04] <mathw> They're camping out

[08:04] <mathw> like you do for tickets for Wimbledon

[08:04] <moritz_> there'll no more meetings in #rs

[08:05] <JimmyZ> hey,there is another irc://irc.perl.org/#rakudosketch :)

[08:08] <moritz_> if in $str.subst($pattern, $replacement, :samecase) the $replacement is a closure, should the samecase() function be applied to its return value?

[08:13] * moritz_ assumes "yes" and moves along

[08:14] <masak> seems to me it would, yes.

[08:15] <masak> is there an alternative?

[08:15] <moritz_> ignore it in the case of a closure

[08:16] *** ejs joined
[08:16] <moritz_> or apply it to the match object, and pass the result string to the closure

[08:18] <moritz_> lolihazblogged: http://perlgeek.de/blog-en/perl-6/contribute-now-samecase-for-subst.writeback

[08:19] <mathw> isn't it week three?

[08:20] <moritz_> no, week 4 :-)

[08:20] *** ejs left
[08:20] <mathw> It says week 2 :)

[08:21] <moritz_> it says week 4... now :-)

[08:21] <mathw> yay

[08:26] <masak> 'ignore it in the case of a closure' breaks Least Surprise.

[08:26] *** ejs joined
[08:27] <masak> moritz_++ # blog post

[08:32] * moritz_ hopes that somebody else comes up (and writes up) with next week's challenge

[08:34] <mathw> yeah I'd say apply it to the closure's return value

[08:35] <masak> moritz_: detaching from a recurring task is nontrivial. not saying it can't be done, though.

[08:36] <masak> people get to expect person X doing task Y, so they don't jump in and take over.

[08:36] <mathw> quite

[08:36] <mathw> I'm not going to volunteer, because I don't have the knowledge to come up with these things

[08:36] *** iblechbot joined
[08:36] <moritz_> masak: that's why I tried to hook people at the very beginning... diakopter++ and colomon++ have put their names into the README, and have come up with some ideas already

[08:37] <masak> ah, good plan.

[08:37] <moritz_> if it matters I can also host challenges by other people on my blog

[08:37] <moritz_> or just post a short notices to look at a different location

[08:37] * masak was just going to suggest that

[08:37] <masak> if not the first solution, then the other.

[08:40] *** dakkar joined
[08:42] <moritz_> masak: any chance Emmentaler is in need of a website next week?

[08:42] <masak> moritz_: I don't feel in a position to promise anything. but I can share my dateless time table.

[08:42] <masak> it looks like this.

[08:43] <masak> (1) fix up GGE with Rakudo master. almost done with that.

[08:43] *** BrowserUk left
[08:43] <masak> (2) set up automatic builds of at least GGE, probably other projects as well. will be proto-based somehow. there's already a proof-of-concept for November, but it's b0rken.

[08:44] <masak> (3) have the builds generate sensible data and save it somewhere on feather.

[08:44] <masak> that's it. with (3), someone can do a weekly challenge.

[08:44] <masak> but I'd drift towards "no" for next week, actually. there's only one of me, and we have a Yapsi release on Tuesday.

[08:44] <moritz_> ok

[08:45] <moritz_> I hope you know if TAP::Formatter::HTML, btw :-)

[08:47] <masak> I've used it for the November reporter thing.

[08:47] <masak> it's functional, but I'm not a fan of the layout.

[08:47] <masak> and it's a bit too detailed for what I have in mind.

[08:47] *** BrowserUk joined
[08:47] <masak> perhaps links from the main report page can link to such output, though.

[08:49] <masak> hm. doing spectests, I got a non-zero exit status from t/spec/S12-methods/submethods.rakudo. unable to reproduce it outside of the harness.

[08:49] *** gfx left
[08:49] <masak> ditto t/spec/integration/99problems-41-to-50.rakudo.

[08:50] <masak> three files contain TODO passed tests: t/spec/S14-roles/composition.rakudo t/spec/S32-hash/delete.rakudo t/spec/S32-str/uc.rakudo

[08:50] <moritz_> first and third are not reliable

[08:52] <pugssvn> r30802 | moritz++ | [t/spec] remove a few #todo markers, masak++ 

[09:02] *** plobsing left
[09:09] *** BrowserUk left
[09:14] *** XaeroOne joined
[09:14] *** iblechbot left
[09:26] *** ejs left
[09:32] *** ejs joined
[09:39] * jnthn back

[09:41] *** clintongormley joined
[09:47] *** finanalyst joined
[10:14] *** yinyin left
[10:17] <mberends> hello jnthn, here's a slightly harder zavolaj question: could you extend NativeCall.pm6 to create wrappers for native functions that return void? The crucial mysql_free_result() does that, and our wrapper presumably still pops something off the native stack, causing Parrot to segfault.

[10:17] *** am0c joined
[10:17] *** am0c left
[10:17] *** am0c joined
[10:21] <jnthn> mberends: If you don't write a "returns" it should already handle that.

[10:22] <jnthn> mberends: Add a debugging say to see what it's making for the Parrot NCI signature string; it should start with a "v"

[10:22] <mberends> jnthn: now why didn't I think of trying that... ;-/

[10:22] <jnthn> :-)

[10:22] <moritz_> HOW IS CODE DEBUGGED? :-)

[10:23] <mberends> google for the answres

[10:23] *** ejs left
[10:23] <moritz_> goggle only tellz me how is babi formed

[10:23] <moritz_> oh wait, that was yahoo answers

[10:23] <jnthn> They should do way instain bugs!

[10:28] *** am0c left
[10:30] *** ejs joined
[10:30] <masak> they need to do way instain developer, who kill their buggies.

[10:33] * jnthn closes his open RT tabs quickly, lest he be done away for looking like he might be about to kill buggies.

[10:38] *** IllvilJa joined
[10:39] *** JimmyZ left
[10:42] *** fridim joined
[10:48] <pragma_> My name is pragma_ and I approve of this channel.

[10:50] *** ejs left
[10:50] *** IllvilJa left
[10:51] <masak> \o/ we approve of you too.

[10:52] *** colomon joined
[10:53] <masak> jnthn: it's ok to kill buggies. it's just a bit sad because these buggy can't frigth back.

[10:54] <jnthn> Aye, but they're lady to rest gently.

[10:55] <masak> oh, good.

[10:55] *** ejs joined
[11:12] *** rgrau[1] joined
[11:16] <mberends> jnthn: unfortunately the NativeCall still segfaults on void functions. It seems that sub make-mapper always gives a return-mapper data type.

[11:17] <jnthn> mberends: What siggy does it make?

[11:18] <jnthn> (the Parrot one)

[11:18] * mberends looks

[11:20] <jnthn> mberends: It should start with v

[11:20] <jnthn> (for void)

[11:20] <jnthn> If not, we certainly have a zavolajbug

[11:21] <jnthn> (if yes, we probably still have one)

[11:21] *** [Coke] joined
[11:28] *** [Coke] left
[11:28] *** envi^home joined
[11:35] * moritz_ back from nom

[11:37] <colomon> rakudo: my $a = "hello world"; say $a ~~ s/o/0/;

[11:37] <p6eval> rakudo 240400: OUTPUT«hell0 world␤»

[11:37] <colomon> rakudo: my $a = "hello world"; say $a ~~ sa/o/0/;

[11:37] <p6eval> rakudo 240400: OUTPUT«Confused at line 11, near "say $a ~~ "␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[11:37] <colomon> rakudo: my $a = "hello world"; say $a ~~ ss/o/0/;

[11:37] <p6eval> rakudo 240400: OUTPUT«Confused at line 11, near "say $a ~~ "␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[11:38] <colomon> rakudo: my $a = "hello world"; $a ~~ s[o] = '0';

[11:38] <p6eval> rakudo 240400:  ( no output )

[11:38] <colomon> rakudo: my $a = "hello world"; $a ~~ s[o] = '0'; say $a

[11:38] <p6eval> rakudo 240400: OUTPUT«hell0 world␤»

[11:39] <jnthn> .oO( $stomach ~~ essess/empty/full/ )

[11:40] <moritz_> std: s:g:g/a/b/

[11:40] <p6eval> std 30802: OUTPUT«ok 00:01 114m␤»

[11:40] <moritz_> std: s:g:foo/a/b/

[11:40] <p6eval> std 30802: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized adverb :foo(1) at /tmp/xiwaLnki7A line 1:␤------> [32ms[33m⏏[31m:g:foo/a/b/[0m␤Check failed␤FAILED 00:01 111m␤»

[11:40] *** ejs left
[11:40] <colomon> moritz_: I'm just looking at subst.t, and noticing there seem to be a decent number of skipped tests that should work in Rakudo now.

[11:41] <colomon> and also, some of the tests are wonky.

[11:41] <moritz_> no surprise here :/

[11:41] <colomon> and many of the skip messages are a bit off.  :(

[11:42] *** masonkramer joined
[11:42] <colomon> "hello".subst(rx:g:i/L/,'p'), 'heppo'

[11:42] <colomon> should that really work the same way as "hello".subst(rx:i/L/,'p', :g), 'heppo'  ?

[11:42] <moritz_> might work, might not

[11:43] <colomon> it seems weirdly non-intuitive to me.

[11:43] <colomon> in fact, it really seems like rx:g shouldn't work at all.

[11:44] <moritz_> aye, :g, :x, :nth could be seen as "external" to the regex

[11:44] <colomon> moritz_: exactly.

[11:45] <colomon> rakudp

[11:45] <colomon> std: rx:g/hello/

[11:45] <p6eval> std 30802: OUTPUT«ok 00:01 112m␤»

[11:45] *** ejs joined
[11:45] <colomon> rakudo: my $a = "hello world"; say $a ~~ rx:g/o/

[11:45] <p6eval> rakudo 240400: OUTPUT«Confused at line 11, near "say $a ~~ "␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[11:45] <colomon> rakudo: my $a = "hello world"; rx:g/o/

[11:45] <p6eval> rakudo 240400: OUTPUT«Confused at line 11, near "rx:g/o/"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[11:46] <moritz_> rakudo: s/a/b/g

[11:46] <p6eval> rakudo 240400: OUTPUT«Unsupported use of /g; in Perl 6 please use :g at line 11, near ""␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[11:46] <colomon> rakudo: 'a'.subst(/(.)/,"$1$0").say

[11:46] <p6eval> rakudo 240400: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class ''␤current instr.: '!postcircumfix:<[ ]>' pc 11646 (src/builtins/Cool.pir:15)␤»

[11:47] <moritz_> rakudo: $1

[11:47] <p6eval> rakudo 240400: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class ''␤current instr.: '!postcircumfix:<[ ]>' pc 11646 (src/builtins/Cool.pir:15)␤»

[11:47] <colomon> that "$1$0" should never work correctly.

[11:47] <colomon> or at least, as a sane programmer probably intended it to work.

[11:48] <mberends> jnthn: the signature is correct (vp) and the native function sometimes returns correctly, so the bug is elsewhere. I'll commit the signature printer, commented out.

[11:49] <colomon> rakudo: 'a b c d'.subst(/\w/, 'x', :x(*))

[11:49] <p6eval> rakudo 240400: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[11:49] *** JimmyZ joined
[11:50] * colomon wonders why we want to support :x(*)...

[11:50] <colomon> rakudo: say 'a b c d'.subst(/\w/, 'x', :nth(2), :g)

[11:50] <p6eval> rakudo 240400: OUTPUT«a x c d␤»

[11:50] <jnthn> mberends: k, hm

[11:51] <moritz_> colomon: :x(*) is the same as :g

[11:51] <moritz_> colomon: and while trying to implement it I found RT #75302

[11:51] <colomon> moritz_: ah.

[11:52] *** ejs left
[11:52] <colomon> woah, that's a crazy bug.

[11:52] <moritz_> aye :-)

[11:53] <moritz_> it took me a while to find out it wasn't my fault

[11:54] <colomon> rakudo: sub f($x is copy) { $x = 'abc'; say $x.WHAT; say $x.perl }; f 'a'

[11:54] <p6eval> rakudo 240400: OUTPUT«Str()␤"abc"␤»

[11:54] <colomon> just checking.  ;)

[11:54] <colomon> rakudo: say 'a b c d'.subst(/\w/, 'x', :nth(2), :g)

[11:54] <p6eval> rakudo 240400: OUTPUT«a x c d␤»

[11:54] *** pmurias joined
[11:54] <colomon> moritz_: the test for that is

[11:55] <colomon> 'a b c d'.subst(/\w/, 'x', :nth(2), :g), 'a x c x'

[11:55] <moritz_> that's wrong

[11:55] <colomon> has the same problem that :nth and :x mixed has.

[11:57] <lisppaste3> pmichaud pasted "REPL in nqp" at http://paste.lisp.org/display/100504

[11:57] <colomon> rakudo: say 'a b c d'.subst(/\w/, 'x', :nth({$_ % 2}))

[11:57] <p6eval> rakudo 240400: OUTPUT«x b x d␤»

[11:57] <colomon> rakudo: say 'a b c d'.subst(/\w/, 'x', :nth({$_ !% 2}))

[11:57] <p6eval> rakudo 240400: OUTPUT«a x c x␤»

[11:57] <pmichaud> good morning, #perl6

[11:57] *** jhuni left
[11:57] <colomon> o/

[11:57] <mberends> \o

[11:58] <pmichaud> NQP now ha a REPL that remembers lexicals.  :-)

[11:58] <moritz_> \o/

[11:58] <masak> yay

[11:58] <moritz_> now port it to rakudo... and ship it!

[11:58] <jnthn> morning, pmichaud++

[11:58] <masak> good morning, pmichaud!

[11:58] <pmichaud> port to rakudo should be straightforward (and should remove some existing code from rakudo)

[11:59] <colomon> moritz_: has TimToady weighed in on the :nth and :x thing, or is that just your (extremely sensible) opinion?

[11:59] <moritz_> colomon: just my opinion

[11:59] <masak> colomon: he has weighed in once.

[11:59] <masak> it's somewhere in the IRC logs.

[11:59] *** pmurias left
[11:59] <moritz_> guided by the principle that one construct should not magically mean different things under certain conditions

[12:00] <colomon> It's easy enough to get the desired behavior using :nth and a closure, too.

[12:00] <colomon> moritz_: maybe we should change the Spec and see if anyone complains?  ;)

[12:01] <takadonet> morning all

[12:01] <moritz_> IMHO the spec is pretty clear

[12:01] <masak> colomon: hah! found the discussion! :) http://irclog.perlgeek.de/perl6/2010-03-26#i_2158320

[12:01] <moritz_> :nth(2) means just one match, in 2nd position

[12:01] <masak> (grepping the IRC logs for RT numbers)++

[12:02] *** agentzh left
[12:02] <colomon> moritz_: that's not how I read TimToady there at all.  looks to me like he's suggesting the test is correct.  :(

[12:03] <moritz_> colomon: he says he can argue for it, not that it must be that way

[12:03] <masak> indeed.

[12:04] *** masonkramer left
[12:05] <moritz_> TimToady++ is sometimes very careful to indicate that he's not convinced "his" option might not be the best. We should take these clues as we see fit :-)

[12:05] <moritz_> s:2nd/not//

[12:05] *** mimcpher left
[12:06] <moritz_> s:nth(2):x(1)/not// # to make my case :-)

[12:06] <colomon> moritz_: did you do those :nth with :x tests?

[12:06] <moritz_> colomon: I did... before I understood that :nth(2) never means "ever second match"

[12:06] <moritz_> colomon: I've since then corrected some tests, but not all :(

[12:06] <moritz_> and I did fix the spec :-)

[12:07] <masak> moritz_: that's a useless use of :x ... :)

[12:07] <moritz_> masak: so you'd think... :-)

[12:10] * masak doesn't know what to think now

[12:10] <moritz_> then think some GSOC

[12:10] <moritz_> like, adding a Stringy role

[12:10] <masak> I did.

[12:10] <masak> that test passes now.

[12:11] <masak> it didn't last time I ran it.

[12:11] <moritz_> oic

[12:11] <masak> something must have miraculously fixed itself in the meantime.

[12:12] <moritz_> but Str ~~ Stringy is NYI, right?

[12:12] <masak> it's I in my buf branch.

[12:12] <masak> oh wait.

[12:12] <masak> no, just Buf ~~ Stringy.

[12:12] <colomon> rakudo: my $a = "hello world"; $a ~~ s[o] = '000'; say $a

[12:12] <p6eval> rakudo 240400: OUTPUT«hell000 world␤»

[12:12] <colomon> oh, bother.

[12:13] *** ejs joined
[12:13] <colomon> rakudo: for <hello world> { s[o] = '000'; say $_;  }

[12:13] <p6eval> rakudo 240400: OUTPUT«hello␤world␤»

[12:13] <moritz_> masak: colomon had some fun changing prefix:<+> to call .Numeric, not .Num; I think in the long run you'll need to change prefix:<~> to .Stringy too

[12:14] <colomon> "fun" in the "not really -Ofun" sense.  :)

[12:14] <masak> -O-fun

[12:14] <masak> moritz_: I'll keep that in mind.

[12:15] <colomon> what's the protocol for false positive tests?  skip them?

[12:15] <masak> rakudo: my $a; say "I do not have ", $a, " shoes on"

[12:15] <p6eval> rakudo 240400: OUTPUT«I do not have Any() shoes on␤»

[12:15] <masak> that's spec'd behaviour nowadays, right?

[12:15] <colomon> rakudo: for <hello world> { say s[o] = '000'; say $_;  }

[12:16] <p6eval> rakudo 240400: OUTPUT«Substitution()<0x3f33340>␤hello␤Substitution()<0x3cc5af0>␤world␤»

[12:16] <colomon> wtf?

[12:16] <colomon> oh.

[12:16] <colomon> rakudo: for <hello world> { say (s[o] = '000').Bool; say $_;  }

[12:16] <p6eval> rakudo 240400: OUTPUT«1␤hello␤1␤world␤»

[12:16] <colomon> rakudo: for <hello world> { say (s[w] = '000').Bool; say $_;  }

[12:16] <p6eval> rakudo 240400: OUTPUT«1␤hello␤1␤world␤»

[12:17] <masak> I thought the 's[] = $rhs' form was purely syntactical and didn't need a type of its own.

[12:17] <moritz_> it should default to $_, and doesn't

[12:18] <moritz_> known bug

[12:18] <colomon> masak: I have no clue, I'm just looking at the "s[...] = ... returns true on success" test in subst.t

[12:18] <jnthn> masak: To do that you'd have to also make the smartmatch recognize it as some kind of special form too

[12:18] <masak> moritz_: I tried augmenting Str to do the Stringy role. it seems to have worked! spectesting.

[12:19] <masak> jnthn: hm, true.

[12:19] <jnthn> masak: Which felt messy.

[12:19] <jnthn> At the time, nobody could give me an answer for how it should be done, so I just Did Something.

[12:19] <colomon> rakudo: for <hello world> -> $a { say ($a ~~ s[w] = '000').Bool; say $a;  }

[12:19] <masak> Something++

[12:19] <p6eval> rakudo 240400: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 18205 (src/builtins/Junction.pir:381)␤»

[12:19] <jnthn> It's almost certainly not right though.

[12:19] <colomon> rakudo: for <hello world> -> $b { my $a = $b; say ($a ~~ s[w] = '000').Bool; say $a;  }

[12:19] <p6eval> rakudo 240400: OUTPUT«1␤hello␤1␤000orld␤»

[12:20] <colomon> aarrrrrgh!

[12:20] <masak> jnthn: fwiw, I would have guessed the smartmatch to be part of the special form.

[12:20] <jnthn> Perhaps so.

[12:20] <jnthn> Just...ugly to do.

[12:20] <masak> aye. might involve backtracking.

[12:20] <jnthn> I think pmichaud++'s context PAST node might help us fix it though.

[12:21] <jnthn> Becuase then we can at least say "oh, we're in sink context, clearly we should do it to $_"

[12:21] * colomon must remember not to be sad about writing tests that fail...

[12:21] <moritz_> I think s[...] should always default to $_

[12:21] <moritz_> and smartmatching sets $_ for the RHS

[12:21] <pmichaud> moritz_: +1

[12:21] <masak> the problem with http://irclog.perlgeek.de/perl6/2010-03-26#i_2158369 is, how do you find out the upper limit? and if that's not a hard enough problem, how do you do it with a closure?

[12:21] <moritz_> and then .sink triggers execution of the substitution

[12:21] <jnthn> moritz_: Feel free to try it.

[12:22] <jnthn> .sink is, iirc, probably actually spelt .eager.

[12:22] <pmichaud> no, I think it's .sink

[12:22] <moritz_> jnthn: types are free to re-interpret .sink as something else

[12:23] * pmichaud thinks he'd better read some backscroll

[12:25] <masak> uhn. are for loops eager because they're in sink context?

[12:25] <moritz_> masak: yes

[12:26] <colomon> for loops are eager IF they're in sink context

[12:26] <masak> what about a for loop at the end of a sub-or-method? will it behave differently? :(

[12:26] <moritz_> yes

[12:26] <pmichaud> depends on how the sub-or-method is called

[12:26] <masak> true.

[12:26] <masak> maybe it's not so bad, then.

[12:26] <pmichaud> a for loop at the end of a sub isn't in sink context, no.

[12:27] <pmichaud> but if the sub invocation is in sink context, the for loop gets executed eagerly then

[12:27] <jnthn> pmichaud: Hmm. I can't find the bit of irclog for the discussion I was thining of.

[12:27] <jnthn> *thinking

[12:28] <pmichaud> it always felt to me as though :x and :n argument handling should be done with smart matching.

[12:28] <moritz_> :nths is

[12:28] <masak> heh -- laziness context is like the value context for Perl 6. :)

[12:28] <moritz_> in rakudo

[12:32] <colomon> code is $i !~~ any |$nth

[12:33] <moritz_> anyway, I'm rather firmly convinced that what we have now for :x + :nth is the sanest semantics, until somebody comes up with a different, consistent interpretation and shows working code for it

[12:33] <takadonet> moritz_: sounds like a challenge to me..

[12:33] <masak> colomon: I'd classify that as one of the confusing uses of negation and junctions...

[12:34] <masak> moritz_++ # pragmatism

[12:34] <colomon> masak: hmmm, I think it could be rewritten in the positive sense without breaking anything...

[12:35] * mathw isn't sure what the prefix | does there

[12:35] <masak> colomon: if I read it correctly, it means '$i ~~ all $nth'.

[12:35] <moritz_> takadonet: not quite a challenge; rather a try to end non-productive bikeshedding

[12:35] <colomon> masak: oh, no no no no

[12:35] <takadonet> moritz_: sounds good

[12:35] <moritz_> mathw: interpolation into argument lists

[12:35] <masak> colomon: see? confusing! :)

[12:35] <masak> colomon: now explain to me why it doesn't mean that.

[12:36] <moritz_> masak: prefix:<|> is interpolation into argument lists

[12:36] <masak> mathw: what moritz_ said but mistabbed.

[12:36] <masak> colomon: sorry, left out the | in |$nth.

[12:37] *** elmex joined
[12:37] <moritz_> takadonet: also if somebody actually cares enough to write code for it, I'm willing to reconsider my position. Until then I just assume that I put the most thought into (hubris :-)

[12:37] <mathw> oh yes of course

[12:37] <mathw> I should have remembered that

[12:38] <masak> colomon: $i !~~ any(|$nth) is the same as any(map { $i !~~ $_ }, |$nth), isn't it?

[12:38] <colomon> masak: darned if I know.  these things are hard to explain.

[12:38] <pmichaud> actually,   $i !~~ any(|$nth)   should be the same as    !($i ~~ any(|$nth))    iiuc

[12:38] <moritz_> masak: yes

[12:39] <masak> ok, pmichaud and moritz_ just contradicted each other.

[12:39] <masak> this should be interesting.

[12:39] <colomon> pmichaud: that's how I read it.

[12:39] <moritz_> wait

[12:39] * moritz_ not so sure anymore

[12:39] <moritz_> pmichaud++ is right

[12:39] <mathw> I read it as "$i is not any of the things in $nth"

[12:39] <masak> dang. :)

[12:39] <moritz_> the negation comes at the end

[12:39] <pmichaud> negations and junctions are problematic

[12:39] <pmichaud> (in general)

[12:39] <masak> apparently so.

[12:39] <masak> I accept what you're saying, but I can't see how it works out that way.

[12:39] <jnthn> To the point that the spec in one place suggests a warning.

[12:39] <masak> how does the ! end up outermost?

[12:40] <pmichaud> it's a metaop

[12:40] <pmichaud> it always ends up "outermost"

[12:40] <jnthn> masak: All ! meta-ops are like that.

[12:40] *** [mark] left
[12:40] <masak> the ! metaop ends up outside of junctions? cool!

[12:40] <jnthn> $a !== $b is !($a == $b) really

[12:40] <masak> jnthn: oh, indeed.

[12:40] <masak> so this doesn't go for the infix:<ne> operator?

[12:40] <moritz_> nope

[12:41] <moritz_> that's not meta-y

[12:41] <masak> that's probably what bit me once, then.

[12:41] <mathw> infix:<ne> would presumably be subtly different to !eq

[12:41] <mathw> since it does all its !-ness inside

[12:41] <masak> after that, I've made large circles around negated comparison ops combined with junctions.

[12:41] <moritz_> so !eq is not quite the same as ne, when junctions are involved

[12:41] <masak> someone should write a blog post about that.

[12:41] <masak> and a u4x entry.

[12:41] <moritz_> masak: that's a good item for our best practise list

[12:42] <jnthn> btw, Rakudo's ne is implemented in terms of !eq

[12:42] <masak> indeed.

[12:42] <jnthn> If you want to avoid the inconsistency, then change infix:<ne> to take two Mus.

[12:42] <masak> jnthn: so maybe that's a potential bug in Rakudo? :)

[12:42] <jnthn> masak: Only if we can decide what the spec is. ;-)

[12:42] <masak> didn't we just do that?

[12:43] <pugssvn> r30803 | colomon++ | [t/spec] Clean up fudging and tests a bit. 

[12:43] <moritz_> masak: where's the bug you're talking about?

[12:43] <jnthn> moritz_: Did you mean !eq is not the same as ne is current Rakudo reality, or an awkward but fixable issue, or?

[12:43] <jnthn> Or intentional?

[12:43] * jnthn would kinda feel more comfortable if they were the same.

[12:44] <moritz_> rakudo: say 1 ne 1|2

[12:44] <p6eval> rakudo 240400: OUTPUT«any(Bool::False, Bool::True)␤»

[12:44] <moritz_> rakudo: say 1 !eq 1|2

[12:44] <p6eval> rakudo 240400: OUTPUT«0␤»

[12:44] <masak> what happens in that first one?

[12:44] <moritz_> that's correct as I understand the current spec

[12:44] <moritz_> masak: autothreading over ne

[12:44] <jnthn> masak: We auto-thread over ne

[12:44] <masak> right, and the junction shouldn't collapse, of course.

[12:44] <jnthn> In the second we auto-thread voer eq, and then the ! collapses it.

[12:45] <jnthn> masak: Yeah, I was asking if we really want that

[12:45] <masak> so it's actually correct? hooray!

[12:45] <jnthn> masak: Or if we should mark ne and != as having Mu parameters.

[12:45] <jnthn> So they work out the same as !eq and !==

[12:45] <masak> jnthn: I don't see why we should.

[12:45] <mathw> I'm wondering how often it's going to bite people

[12:45] <mathw> And if we want to allow the distinction

[12:45] <mathw> Is it potentially useful?

[12:45] <pmichaud> as I read the spec,  infix:<ne>  is supposed to be the same as !eq

[12:46] <pmichaud> i.e., it's just a shortcut.

[12:46] <masak> so it is a bug?

[12:46] <moritz_> masak: only by pmichaud++'s interpretation

[12:46] * masak submits rakudobug

[12:46] <masak> that's enough for me. :)

[12:46] <mathw> I'm not convinced

[12:46] <pmichaud> S03:1189

[12:46] <pmichaud> As in Perl 5, converts to C<Str> before comparison. C<ne> is short for C<!eq>.

[12:47] <moritz_> ok

[12:47] <moritz_> that's enough for me :-)

[12:47] *** plainhao joined
[12:47] <pmichaud> also later at S03:3915

[12:48] <mberends> just re-asking before committing: is it OK to put the directories specified in PERL6LIB before the defaults in @*INC instead of after, to be able to override system modules with local ones? (it works fine locally)

[12:48] <pmichaud> that tells me that &infix:<ne>  is more macro-ish than a normal function, in the long run.

[12:48] <moritz_> mberends: +1 from me

[12:48] <masak> mberends: that sounds like the Right Thing to me, at least.

[12:48] <mathw> I think any way this goes is going to confuse somebody at some point

[12:49] <mathw> if ne is just syntactic sugar for !eq, it's going to surprise someone

[12:49] <mathw> and the current behaviour is going to surprise someone else

[12:49] <colomon> masak: code is now  if !$nth.defined || ($i ~~ any |$nth)

[12:49] <mathw> So my inner paper shredder says why do we need infix:<ne> :)

[12:49] <colomon> hope you find that nicer.  :)

[12:49] <colomon> (spectesting)

[12:50] <moritz_> mathw: because TIMTOWTDI :-)

[12:50] *** M_o_C joined
[12:51] <colomon> moritz_: what, to surprise people?  ;)

[12:51] <jnthn> Because we might get lynched if we don't have == :-)

[12:51] <moritz_> colomon: it would certainly p5 programmers if we had eq but not ne

[12:51] <jnthn> Heh. Back when we had prefix:<=> defined, if we'd dropped ==, then $a == $b woulda parsed as $a = (=$b) :-D

[12:51] *** fridim left
[12:51] <moritz_> colomon: and then we'd have to install infix:<ne> just to generate an error message

[12:52] *** SmokeMachine joined
[12:52] <jnthn> oh wait

[12:52] <jnthn> it would be != we dropped

[12:52] <jnthn> But same

[12:52] <jnthn> Two prefixes :-)

[12:52] <moritz_> colomon: and then people will ask "why don't you just make infix:<ne> the same as infix:<!eq>"

[12:52] <dalek> rakudo: 39c38ca | (Martin Berends)++ | src/Perl6/Compiler.pir:

[12:52] <dalek> rakudo: [Perl6/Compiler.pir] change the order of directories in @*INC so that the 

[12:52] <dalek> rakudo: PERL6LIB ones come first

[12:52] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/39c38caa2548d4d895d9034eedc4d9897b930e01

[12:52] <jnthn> But then two terms in a row. :-)

[12:52] <masak> colomon: I do find it nicer. colomon++

[12:52] <colomon> moritz_: I'm not actually against ne, just amused at invoking TIMTOWTDI in that context  :)

[12:52] *** alanhaggai joined
[12:53] <jnthn> Anyway, we do ne and != often enough that's probably a huffman argument for 'em anyways. :)

[12:53] <pmichaud> mberends: it just occurred to me... what does perl5 do in the case of @INC?

[12:53] <mathw> Maybe

[12:53] <moritz_> colomon: you're right, it was not the best argument :-)

[12:53] * moritz_ knows that 'use lib $path;' prepends to @INC

[12:53] <mathw> It just feels like an inconsistency to me if <ne> behaves with junctions like a meta-opped <eq>

[12:54] <mathw> Because one of them would return a bool, and one of them would return a junction of bools

[12:54] *** perlygatekeeper joined
[12:54] <moritz_> mathw: if you take the radial approach, junctions are the problem, not the ne/!eq multi existence

[12:55] <moritz_> mathw: so just abolish junctions, and everything is suddenly much easier :-)

[12:55] <mberends> pmichaud: good point. PERLLIB also goes before, just checked empirically

[12:55] <mathw> moritz_: just make all comparison operators produce a single bool when used on junctions :)

[12:55] <pmichaud> mberends: if perl 5 does it that way, that's a strong argument for rakudo to do the same :)

[12:55] <mberends> yes, they agree now :)

[12:56] <masak> also, there's an argument by sanity. :)

[12:56] <jnthn> mberends: Nice. :-)

[12:56] <mathw> moritz_: well except the ones that don't return boolean values of course

[12:56] *** SmokeMachine left
[12:56] <masak> if the user actually *specifies* a path in the invocation, that's pretty prioritized.

[12:56] <pmichaud> (junctions and negation)  S03:3121 discusses this in some detail.  ("Use of negative operators...")

[12:57] <pmichaud> I'm not sure if that needs to be updated to take into account !'s meta-ness.

[12:57] <moritz_> pmichaud: you're so boring, citing specs when we could bikeshed for ages... :-)

[12:58] <mathw> pmichaud: yes can't you tell I'm trying to procrastinate here?

[12:58] * mathw reads S03

[12:58] <pmichaud> because the way S03:3121 reads, it makes it sound as though  infix:<!=>  is its own operator, and not the same as   !($a == $b)

[12:59] *** snarkyboojum joined
[12:59] <pmichaud> mathw: (procrastination)  -- trying to resolve ambiguities/contradictions in the synopses is a great way to procrastinate.  Unless you're trying to procrastinate resolving the ambiguities and contradictions in the synopses.  :-)

[12:59] <mathw> pmichaud: the best form of procrastination gets something else useful done

[12:59] <mathw> and yes, S03:3121 does seem to indicate that

[12:59] <pmichaud> mathw: that sounds good... I'll need to think on it more a bit later.

[13:01] <mberends> uh-oh, perl5 puts '.' at the end of @INC, perl6 has it immediately after PERL6LIB, which is also better for overriding system with local. Hmm, don't want to follow perl5 there.

[13:02] <pmichaud> mberends: iiuc, having . anywhere but the end is a potential security risk

[13:02] <moritz_> '.' in INC is potentially harmful

[13:02] <moritz_> we should disable that once wie have 'use lib' and Cwd and such nice modules

[13:03] <mberends> ok, '.' can move to the end

[13:04] <pmichaud> "overriding system with local"  is also another way of saying "silently replace the standard system module with a hacker-compromised version"

[13:05] <mberends> it sounded like a good idea for testing, but indeed it's bad for production

[13:05] <pmichaud> while it makes things easier for developers, it .... right

[13:05] <pmichaud> developers should probably have the burden of extra work here.  :-)

[13:05] <mberends> heh, yes

[13:05] *** moritz_ sets mode: +o mberends

[13:08] *** Guest65941 left
[13:11] <mathw> yes doing that should be possible, but very explicit

[13:14] *** wasmahen joined
[13:14] <wasmahen> hey 

[13:14] <wasmahen> is this perl6

[13:14] <mberends> wasmahen: oh yeah!

[13:14] <masak> it is.

[13:14] <masak> welcome!

[13:14] <wasmahen> i have been looking at this wikipedia article on perl6 http://en.wikipedia.org/wiki/Perl6

[13:14] <wasmahen> are we regressing?

[13:14] <masak> a little, sometimes.

[13:14] <wasmahen> perl 5:  my $i = "25" + 10; # $i is 35

[13:15] <masak> aye.

[13:15] <wasmahen> perl6: my Str $s = "Hello, world";

[13:15] <wasmahen> why

[13:15] <p6eval> elf 30803, pugs, rakudo 240400:  ( no output )

[13:15] <moritz_> rakudo: my $i = "25" + 10; say $i

[13:15] <p6eval> rakudo 240400: OUTPUT«35␤»

[13:15] <masak> wasmahen: you don't have to type your variables if you don't want to.

[13:15] <moritz_> still works.

[13:15] <wasmahen> do i have to declare my variable type

[13:15] <masak> no.

[13:15] <pmichaud> wasmahen: no.

[13:15] <masak> that's what I meant by 'you don't have to'.

[13:16] <pmichaud> wasmahen: if you do, it's a type constrait.

[13:16] <wasmahen> so $str = "hello world" works

[13:16] <masak> yup.

[13:16] <wasmahen> great

[13:16] <pmichaud> well, you still have to declare $str

[13:16] <moritz_> perl6: my $str = "hello world"; say $str

[13:16] <p6eval> elf 30803, pugs, rakudo 240400: OUTPUT«hello world␤»

[13:16] <pmichaud> you just don't have to type it

[13:17] <wasmahen> great, i was afraid for a moment there

[13:17] <wasmahen> am expecting a lot from perl6

[13:17] <masak> wasmahen: does the Wikipedia article give the impression that you have to provide types for all variable declarations?

[13:17] <wasmahen> masak: ya

[13:17] <wasmahen> masak: it says: In Perl 6, the dynamic type system of Perl 5 has been augmented by the addition of static types

[13:18] <snarkyboojum> and then "However, as with Perl 5, programmers can do most things without any explicit typing at all:"

[13:18] *** nodie joined
[13:18] <masak> snarkyboojum! \o/

[13:18] <wasmahen> ya, as if telling me perl5 could do this but in perl6, they made is more complicated

[13:18] <wasmahen> it*

[13:18] <PerlJam> greets

[13:18] <snarkyboojum> masak: o/

[13:19] <pmichaud> PerlJam: /part #rakudosketch

[13:19] <masak> wasmahen: 'Perl 6 offers a hybrid typing system whereby the programmer may choose to use Static Typing, Dynamic Typing or mix the two.'

[13:19] <masak> wasmahen: seems to me to be pretty explicitly telling you that it's optional.

[13:19] <pmichaud> I'd move the option description a bit higher

[13:20] <snarkyboojum> I guess it points out static types first because that's new in Perl 6

[13:20] <wasmahen> masak: all this is too complicated words for me

[13:20] <PerlJam> pmichaud: Is someone going to register the channel, etc.?

[13:20] <wasmahen> english is not my maternal language

[13:20] <masak> wasmahen: ok. thanks for letting me know.

[13:20] <pmichaud> "However, static typing remains optional, so that ..."

[13:20] <pmichaud> instead of "However, as with Perl 5, ..."

[13:20] <moritz_> PerlJam: we moved to #phasers because nobody had registered #rs

[13:20] <moritz_> PerlJam: so we couldn't even set the topic

[13:21] <pmichaud> only sorear++ is left in the channel when PerlJam++ parts

[13:21] <masak> pmichaud: how do you know? :)

[13:21] <masak> wasmahen: the Wikipedia page was clear, but maybe not perfectly organized. thanks for pointing it out.

[13:22] <jnthn> .oO( nobody a/part from ... )

[13:22] <wasmahen> ok goodnite

[13:22] *** wasmahen left
[13:22] <pmichaud> masak: by surreptitiously peeking my head inside the channel from time to time :-)

[13:23] <PerlJam> 13:22 -!- PerlJam [duff@feather.perl6.nl] has left #rakudosketch []

[13:23] <masak> pmichaud: you can't measure an IRC system without also affecting it :P

[13:24] <pmichaud> masak: I'm willing to claim that my statement was/is correct, however.  :)

[13:24] <pmichaud> masak: and I'm not sure anyone can disprove it.  :)

[13:24] <masak> pmichaud: lol

[13:24] <moritz_> :-)

[13:24] <pmichaud> when PerlJam++ parted, only sorear++ was left.  That seems the most likely situation.

[13:24] *** nodie left
[13:27] *** takadonet left
[13:28] <dalek> rakudo: 1728e99 | (Solomon Foster)++ | src/core/Cool-str.pm:

[13:28] <dalek> rakudo: Clarify logic at masak++'s suggestion.

[13:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1728e99ffb00b811fbbc2b781a3ba44e504f90df

[13:28] <dalek> rakudo: 51b61c5 | (Martin Berends)++ | src/Perl6/Compiler.pir:

[13:28] <dalek> rakudo: [Perl6/Compiler.pir] re-order @*INC again, '.' goes to the end, pmichaud++

[13:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/51b61c5969c5455a705eea01e7c1fda2fe026f57

[13:28] *** jhuni joined
[13:28] <dalek> rakudo: 6f0e67d | (Martin Berends)++ | src/core/Cool-str.pm:

[13:28] <dalek> rakudo: Merge branch 'master' of github.com:rakudo/rakudo

[13:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6f0e67d7e72d0e45ebf8e3bf2199f173a7e00dbf

[13:28] <dalek> rakudo: fd769c8 | pmichaud++ |  (2 files):

[13:28] <dalek> rakudo: Update Perl6::Actions to grab dynamic outer compilation via HLL::Actions

[13:28] <dalek> rakudo: instead of maintaining its own.

[13:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/fd769c80e75684d4ffc36a4d330eee453af1b360

[13:28] <dalek> rakudo: 20068fa | pmichaud++ | src/ (2 files):

[13:28] <dalek> rakudo: Merge branch 'master' of github.com:rakudo/rakudo

[13:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/20068fa4ec19c0de7583af3036609385820450fa

[13:28] <pugssvn> r30804 | colomon++ | [t/spec] Add tests for .subst with :p and :c options. 

[13:28] <colomon> woah

[13:30] *** pmurias joined
[13:31] *** zostay left
[13:34] *** isBEKaml joined
[13:39] *** ejs left
[13:40] *** pmurias left
[13:40] *** SmokeMachine joined
[13:40] <isBEKaml> hi all! :)

[13:41] *** JimmyZ left
[13:41] <moritz_> colomon: do those tests pass?

[13:42] *** kaare joined
[13:43] <isBEKaml> oh, I was wondering if my network went into latency or this channel was _really_ silent.. ;)

[13:43] *** kaare is now known as Guest74734

[13:43] <pmichaud> Perhaps the people in the channel went into latency.

[13:43] <moritz_> isBEKaml: you can always check the website with the IRC logs :-)

[13:44] <isBEKaml> :)

[13:44] <PerlJam> isBEKaml: We're all here to varying degrees :)

[13:44] *** ejs joined
[13:45] <isBEKaml> #perl6++ # I wish I could +1 everyone. :)

[13:45] <pmichaud> I bet it could be done with a Perl script.  :)

[13:46] <moritz_> irssi directly supports Perl plugins

[13:46] <isBEKaml> yes, and I'm yet to learn how to do those. But I use XChat since I don't have an unicode ready console, yet.. 

[13:47] <masak> hi, isBEKaml! :)

[13:47] <isBEKaml> yo, masak! :)

[13:47] <moritz_> the documentation of the plugin API is in a rather sad state

[13:48] <moritz_> it basically consists of a short intro (Juerd++), the source code and many example scripts

[13:48] <isBEKaml> moritz_: XChat or irssi? 

[13:48] <moritz_> isBEKaml: irssi

[13:48] <masak> Perl 6 doesn't have a way to combine hexadecimal literals and scientific notation, does it?

[13:48] <isBEKaml> I have used both, but I knida like irssi better since i don't have to go into X for that. :)

[13:49] <moritz_> masak: sure it does :/

[13:49] <moritz_> search S02 for :16< or so

[13:49] *** patspam joined
[13:50] <moritz_> rakudo: say :16<a0*10**2>

[13:50] <p6eval> rakudo 240400: OUTPUT«16000␤»

[13:50] <masak> moritz_: I know about that, but it doesn't elimiate the fact that you can't use E to mean 'scientific notation' in a hexadecimal literal.

[13:50] <colomon> moritz_: yes, the :p and :c tests all pass, no prob.

[13:51] <masak> but I suppose ** works just as well.

[13:51] <moritz_> urk, t/spec/integration/advent2009-day02.t test 8 failed

[13:53] <moritz_> fixing...

[13:53] <pugssvn> r30805 | moritz++ | [t/spec] fix typo 

[13:59] <dalek> rakudo: 4569863 | masak++ | src/Perl6/Module/Loader.pm:

[13:59] <dalek> rakudo: [Module::Loader] removed redundant period

[13:59] <dalek> rakudo: The error message ends with a pair of parentheses. These stand on their own

[13:59] <dalek> rakudo: without a full stop after them.

[13:59] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/45698634de4135cf7b8c645887460ca7f3e5a715

[13:59] *** gbacon joined
[13:59] <moritz_> masak++ # cleaning up my mess :-)

[13:59] <masak> it was a very minor mess. :)

[14:00] <masak> but it's a great feeling to have the power, when bothered by a minor detail, to just commit the change, and it's fixed! \o/

[14:01] <moritz_> .oO( masak admits his power hunger :-)

[14:01] <masak> om nom nom.

[14:02] <isBEKaml> rakudo: say 'The foo and the bar'.subst(/:i the/, 'that', :g, :samecase);

[14:02] <p6eval> rakudo 240400: OUTPUT«that foo and that bar␤»

[14:03] <isBEKaml> moritz_: I'm confused by your blog challenge. What was it about? hooking :samecase to Cool-str ?

[14:03] <moritz_> yes

[14:03] <moritz_> and still is

[14:03] <moritz_> if it worked, the first 't' in the output would have been upper case

[14:04] <isBEKaml> ah

[14:04] <isBEKaml> rakudo: say 'The foo and the bar'.subst(/:i the/, 'that', :g);

[14:04] <p6eval> rakudo 240400: OUTPUT«that foo and that bar␤»

[14:05] <moritz_> it just ignores options it doesn't understand

[14:05] <isBEKaml> so, :samecase is redundant as of now. But challenge is to add weights to it. :)

[14:05] <moritz_> right

[14:06] <masak> isBEKaml++ # I can see you're thinking about it... :)

[14:07] <isBEKaml> masak: lol, I don't know if I can come up with something. I'm only git pulling.... :)

[14:07] <PerlJam> 'THE'.subst(/:i the/, 'that', :samecase);  # what should this do?  :)

[14:07] <moritz_> rakudo: say samecase('that', "THE")

[14:07] <p6eval> rakudo 240400: OUTPUT«THAT␤»

[14:07] <moritz_> exactly THAT :-)

[14:07] *** M_o_C left
[14:08] <PerlJam> excellent.

[14:08] <snarkyboojum> yay, I just did an HTTP request using Rakudo :P

[14:08] <snarkyboojum> lol

[14:08] <masak> PerlJam: S05:225.

[14:08] <PerlJam> masak: yeah, just got there :)

[14:08] <isBEKaml> snarkyboojum++ ## that could turn into something of a tryrakudo.org ? :)

[14:09] <moritz_> we really need a specbot that answers FAQs with links to synopsis :-)

[14:09] <snarkyboojum> isBEKaml: :)

[14:09] <masak> snarkyboojum: you're about two years behind. :P http://november-wiki.org/

[14:09] <PerlJam> moritz_: that would make a good not-necessarily-perl6 challenge :)

[14:09] <snarkyboojum> masak: I have no clever comeback for that :)

[14:10] <moritz_> masak: doing a HTTP request != answering a HTTP request

[14:10] *** BrowserUk joined
[14:11] *** am0c joined
[14:12] <masak> moritz_: oops.

[14:12] <masak> actually, I don't think I've ever *done* an HTTP request from Rakudo. snarkyboojum++

[14:12] <snarkyboojum> :)

[14:13] * jnthn wonders if IRC::Client works on current Rakudo

[14:18] *** M_o_C joined
[14:19] <pmichaud> jnthn: ping

[14:19] *** viklund left
[14:19] * moritz_ received a submission for this week's challenge o/

[14:20] <moritz_> and from a first look it's pretty good

[14:20] <isBEKaml> moritz_: so soon? \o/

[14:20] *** ruoso_ joined
[14:20] <jnthn> pmichaud: pong 

[14:20] <jnthn> pmichaud: Gimme some relief from Java! :-)

[14:20] <pmichaud> I need some guidance with the YOU_ARE_HERE stuff that's been added to Rakudo.

[14:21] <jnthn> Out of the fat and into the fryer... :-) :-)

[14:21] <pmichaud> iiuc, YOU_ARE_HERE is intended to make it appear that code is executed lexically inside of the setting

[14:22] <jnthn> pmichaud: It mostly works just by twiddling the outer of the outermost lexical scope of the program to actually be the setting.

[14:22] <pmichaud> I don't like the $*IN_EVAL contextual -- it's fragile.

[14:23] <jnthn> As in, user-space twiddlable?

[14:23] <jnthn> In that sense yes.

[14:23] <pmichaud> no, in the sense that there may be code that gets evaled (e.g. interactive mode) but doesn't set $*IN_EVAL

[14:23] <jnthn> Ah, and then we don't want the outer scope of the thing to be the setting...

[14:23] <jnthn> Yes.

[14:24] <jnthn> Maybe it's the wrong flag.

[14:24] <jnthn> And we need to look at it the other way

[14:24] <jnthn> $*IN_MAINLINE # this is the mainline code

[14:24] <pmichaud> dynamic vars as flags tend to be code smells to me

[14:25] <jnthn> Many things relating to the current bit of parsing/compilation we're doing are done with dynamic vars.

[14:25] <jnthn> Guess this could be an over-use of them.

[14:25] <jnthn> What would you suggest instead?

[14:25] <pmichaud> yes.... it feels like the use of  $past<something>  as flags as well -- they should be used minimally

[14:26] <jnthn> Aye, I agree on those.

[14:26] <pmichaud> I don't know -- I just needed to make sure I understood what YOU_ARE_HERE is doing

[14:26] <jnthn> The action for YOU_ARE_HERE just shoves a tiny bit of code in the setting that twiddles the outer lexical scope of the bit of the Parrot sub it is passed.

[14:27] <jnthn> Since that code is in the lexical scope of the setting, the chain ends up having the setting in it.

[14:27] <pmichaud> looks to me like it actually generates a sub in the setting

[14:27] <jnthn> Right.

[14:27] <pmichaud> any particular reason it needs to be !YOU_ARE_HERE?

[14:27] <pmichaud> i.e., couldn't it also be &YOU_ARE_HERE just as easily?

[14:27] <jnthn> No, I just needed something to call it. :-)

[14:27] <jnthn> Well

[14:27] <jnthn> I didn't really think it should be user-space exposed.

[14:28] <jnthn> Folks can't call a thing from Perl 6 land with a ! at the start. :-)

[14:28] <moritz_> S06 (iirc) mentions YOU_ARE_HERE, and doesn't say it's hidden

[14:28] <jnthn> That was pretty much the entire reason though.

[14:28] <pmichaud> YOU_ARE_HERE shows up in the spec, so I'm guessing it's userspace exposed 

[14:28] <jnthn> As something you can pass a chunk of code to and have it run in the current setting?

[14:28] <jnthn> If so, then yes, by all means let's rename it.

[14:28] <pmichaud> Haven't read yet -- I just know that it's in the spec

[14:29] <pmichaud> okay, I'll work on any refactors there.  Currently that $*IN_EVAL appears to be destroying my outer context in interactive REPL

[14:29] <jnthn> tbh, the majority of the effort in making this work was fixing other areas we got lexical-ish bits not quite right.

[14:29] *** uniejo left
[14:29] <jnthn> Not the actual YOU_ARE_HERE thing that did set_outer

[14:29] *** isBEKaml left
[14:30] <jnthn> Yes, I can imagine it would cause problems there.

[14:30] <jnthn> Feel free to change it as you see fit.

[14:30] <pmichaud> will do

[14:30] <pmichaud> In some sense I'm thinking of changing  YOU_ARE_HERE.pm  to have a full sub declaration

[14:31] <pmichaud> our sub YOU_ARE_HERE(...) {...}

[14:31] <jnthn> That would also be workable

[14:31] <pmichaud> okay, I'll read up on the spec and see what comes out

[14:31] <jnthn> I was more attempting to match STD and http://svn.pugscode.org/pugs/src/perl6/CORE.setting

[14:31] <pmichaud> yes, I noticed that also :-)

[14:31] <jnthn> (see YOU_ARE_HERE token at end)

[14:32] <pmichaud> I can see that it's following STD.  I'm wondering if this is a place wehre Rakudo should simply so that STD.pm6 can follow what it does instead :)

[14:32] <pmichaud> *simplify

[14:32] <jnthn> :-)

[14:34] <mathw> jnthn: I'm right with you on Java generics

[14:34] <mathw> jnthn: the only thing that's worse is using the collection classes without them

[14:34] <pmichaud> yeah, term:YOU_ARE_HERE appears to be more of a "invoke the mainline code" term rather than a "define the YOU_ARE_HERE sub at this point"

[14:34] <pmichaud> (according to S02)

[14:35] *** XaeroOne left
[14:36] <TimToady> for 

[14:36] <TimToady> for VMs that can't do 'set outer' it's more of a freeze/thaw point

[14:36] <pmichaud> TimToady: makes sense to me

[14:37] <jnthn> mathw: I know just fine what type erasure is, but I'm quite sure Joe Programmer is in for a shock when the compiler starts whining that he can't define these two methods with different signatures because the type-erase to the same thing. :-/

[14:37] <jnthn> *they

[14:37] <jnthn> oh hey, I think I fixed $nasty-work-bug

[14:38] <pmichaud> jnthn: I wonder if we can dynamically detect "mainline" code as being code that doesn't have an outer context set.

[14:38] <pmichaud> (at which point we force its outer to be the setting)

[14:38] <pmichaud> eval'd code would already have an outer context set

[14:39] <jnthn> pmichaud: Maybe.

[14:39] <TimToady> in a sense, so does the mainline code

[14:40] <jnthn> pmichaud: May get an off-by-one if there is some outer scope which is the thingy that actually gives the mainline to YOU_ARE_HERE (or whatever we call the code that does the twiddling)

[14:40] <TimToady> YOU_ARE_HERE should be more or less indistinguishable from a 'my package UNIT { ... }' at that point

[14:41] <pmichaud> TimToady: yes, I was thinking of something like that too :-)

[14:41] <jnthn> pmichaud: Then, I guess that's solvable by .lexical(0) on the mainline PAST::Block.

[14:41] <TimToady> but anything you can do to fake that is fine

[14:41] <pmichaud> jnthn: right.

[14:41] <jnthn> So yeah, sounds feasible.

[14:41] <TimToady> as long as it happens soon enough that the compilation of UNIT knows it

[14:41] <jnthn> "if get_outer returns NULL..."

[14:41] <pmichaud> or the outer scope is the thing that does the checking for "do I have an outer scope?" before calling UNIT_START

[14:42] <pmichaud> as opposed to checking outer of the "inner mainline"

[14:42] *** M_o_C left
[14:42] <pmichaud> (sorry, that was totally confusing)

[14:42] <pmichaud> (rephrasing)

[14:43] <pmichaud> the off-by-one wrapper scope can check itself for "do I have an outer?"  to decide if it's really the mainline execution or no

[14:43] <pmichaud> it can then decide what to do with the "mainline" that it's wrapping.

[14:44] <jnthn> pmichaud: Ah, get it.

[14:44] <jnthn> pmichaud: That also works.

[14:44] <pmichaud> if the wrapper already has an outer scope set, then it can just invoke the mainline and be done.

[14:44] <jnthn> *nod*

[14:45] <pmichaud> and we then reserve UNIT_START for actual mainline execution.

[14:45] <jnthn> That feels righter than making the code that does the set_outer have to do that check.

[14:45] <snarkyboojum> masak, moritz_: ok, I just posted a dent from rakudo :P

[14:45] <masak> cool!

[14:45] <jnthn> oh noes...you dented it?!

[14:45] <jnthn> .oO( It'll buff out )

[14:45] <pmichaud> and in fact!

[14:46] <snarkyboojum> command-line identica'ing from rakudo :)

[14:46] <pmichaud> we can make sure our mainline block is always .lexical(0)

[14:46] <pmichaud> if the off-by-one wrapper has an outer scope set, it passes that scope to mainline before executing it

[14:47] <pmichaud> otherwise it calls UNIT_START or YOU_ARE_HERE or whatever, which sets the mainline's outer to the setting before executing it

[14:47] *** am0c left
[14:47] <masak> found it! http://identi.ca/notice/33651989

[14:47] <pmichaud> either way, the off-by-one wrapper is out of the outer context chain by the time it passes control to mainline

[14:47] <jnthn> *nod*

[14:47] <pmichaud> then mainline's OUTER would indeed be the setting directly

[14:48] <jnthn> Even better.

[14:48] <snarkyboojum> hehe that's it ;) now I just have to make it say "from rakudo" instead of "from api"

[14:48] <pmichaud> okay, I'll work on those refactors.

[14:48] <jnthn> pmichaud++

[14:48] <pmichaud> I'm much more comfortable with this now.

[14:48] <jnthn> Me too. ;-)

[14:49] <pmichaud> it feels much less workaround-y and more "do exactly what is supposed to happen here"

[14:49] <pmichaud> it also stays consistent with other aspects of PCT/NQP compilation

[14:49] <pmichaud> (i.e.,  the evalpmc[0] is the one that determines outer context)

[14:49] <pugssvn> r30806 | moritz++ | [t/spec] tests .subst() with :samecase 

[14:49] <pugssvn> r30806 | 

[14:49] <pugssvn> r30806 | Patch courtesy of Hongwen Qiu

[14:50] <masak> snarkyboojum: make it say 'from perl6awesomedent' :)

[14:50] <snarkyboojum> masak: hehe

[14:50] <pmichaud> okay, need a short break here -- will be back later

[14:51] <masak> on the list of Things We Have Plan 9 to Thank For: UTF-8.

[14:54] <moritz_> I'm curious: what else is on that list?

[14:54] <[particle]> the plan 9 mascot.

[14:54] <masak> I bet one could put something having to do with C compilers on that list.

[14:55] <masak> the Plan 9 people actually share much of the hubris of the Perl 6 crowd. they know they got a lot of things right, and deplore that it's not more widely known.

[14:56] <pmichaud> s/Thank/Blame/   # perhaps?

[14:56] * moritz_ kinda likes UTF-8

[14:56] *** finanalyst left
[14:56] <moritz_> it's not ideal for implementing regex engines, but I don't do that very often :-)

[14:57] <TimToady> UTF-8 is pretty okay as long as you don't have to random access it

[14:57] <arnsholt> I'd argue that it's also a matter of foisting complexity off to the implementors

[14:58] <PerlJam> moritz_: Plan 9 is also relatively unknown as far as OSes go.  Hopefully Perl 6 doesn't share the analogous trait wrt languages.

[14:58] <masak> this presentation especially kinda reeks of "here's what we know we did wrong and want to do better": http://www.cs.unm.edu/~fastos/05meeting/PLAN9NOTDEADYET.pdf

[14:58] <masak> PerlJam: Perl 6 is already famous. unfortunately not yet for all the right reasons :/

[14:59] <masak> &

[14:59] <TimToady> if you squint, Perl 6 looks like a dyslexic Plan 9

[14:59] <moritz_> that's a line for my fortune file :-)

[15:00] <arnsholt> masak: Perhaps infamous is even better than famous. Especially when Perl 6 suddenly turns out to be awesome =)

[15:00] * jnthn -> beer shopping, bbiab

[15:02] *** am0c joined
[15:03] *** justatheory joined
[15:03] <moritz_> masak: I like it. "Don't believe me? Type 'stty' at an xterm

[15:03] <moritz_> and tell me why a window has a baud rate"

[15:03] <PerlJam> heh, I just read that slide too :)

[15:08] <moritz_> they do have a point

[15:09] *** justatheory left
[15:09] <snarkyboojum> masak: there ya go - http://identi.ca/notice/33654228 :P

[15:09] <moritz_> :-)

[15:10] <snarkyboojum> 'from perl6awesomedent'

[15:10] <snarkyboojum> ok.. enough spam from me :)

[15:13] *** orafu joined
[15:13] <TimToady> .oO(Perl 5 : Perl 6 :: Ma Bell : Bell Labs)

[15:19] *** isBEKaml joined
[15:20] <pugssvn> r30807 | pmurias++ | [mildew] renamed Mildew::Parser::* to Mildew::Frontend::* 

[15:22] <ajs> rakudo: use Test; "abc" ~~ /a[ $<x> = (b) ]?c/; ok($/<x> eq "b", "aliased match within optional non-capturing group")

[15:23] <p6eval> rakudo 456986: OUTPUT«No applicable candidates found to dispatch to for 'infix:<eq>'. Available candidates are:␤:()␤:(Any $a, Any $b)␤␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[15:23] <pmichaud> jnthn: ping

[15:23] <ajs> rakudo: use Test; "abc" ~~ /a[ $<x> = (b) ]c/; ok($/<x> eq "b", "aliased match within non-capturing group")

[15:23] <p6eval> rakudo 456986: OUTPUT«ok 1 - aliased match within non-capturing group␤»

[15:23] <ajs> One of these things is not like the other....

[15:23] <moritz_> ajs: the problem with the first test is that $/ isn't a a Perl 6 object at the moment

[15:24] <moritz_> so it's not compatiable with Any :(

[15:24] <ajs> So how do you do aliasing in that case?

[15:25] <moritz_> rakudo: use Test; "abc" ~~ /a[ $<x> = (b) ]?c/; is("$/<x>", "b""aliased match within optional non-capturing group")

[15:25] <p6eval> rakudo 456986: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1971 (ext/nqp-rx/src/stage0/Regex-s0.pir:1050)␤»

[15:25] <moritz_> rakudo: use Test; "abc" ~~ /a[ $<x> = (b) ]?c/; is("$/<x>", "b", "aliased match within optional non-capturing group")

[15:25] <p6eval> rakudo 456986: OUTPUT«not ok 1 - aliased match within optional non-capturing group␤#      got: "1"␤# expected: "b"␤»

[15:25] <pmichaud> stringify it first

[15:25] <pmichaud> try  ~$<x> eq 'b'

[15:25] <moritz_> rakudo: use Test; "abc" ~~ /a[ $<x> = (b) ]?c/; is("$/<x>[0]", "b", "aliased match within optional non-capturing group")

[15:25] <p6eval> rakudo 456986: OUTPUT«ok 1 - aliased match within optional non-capturing group␤»

[15:26] <moritz_> ah, that's the problem

[15:26] <moritz_> the array in $<x> stringifies incorrectly

[15:26] <moritz_> (again it's a parrot thing, not a proper Perl 6 array)

[15:26] <pmichaud> ....because it's a parrot array.  Good catch.

[15:26] <pmichaud> I should be able to look at those today.

[15:26] <moritz_> we have an old ticket for that in RT

[15:27] <ajs> freaky.... so why is it an array when I say [$<x> = (b)]? and a string when I say [$<x> = (b)]

[15:27] <pmichaud> ajs: because of the quantifier

[15:27] <moritz_> [...]?

[15:27] <pmichaud> consier:   [$<x> = (b)]*

[15:27] <pmichaud> *consider

[15:27] <ajs> Ah, I see

[15:27] <ajs> OK, thanks

[15:27] <pmichaud> $<x> would be an array of captures

[15:27] <pmichaud> s/captures/matches/

[15:28] <ajs> That's going to really trip some people up, becuase they have to look outside of the alias to determine what kind of match they're going to get.

[15:28] <ajs> But I can work with that now

[15:28] <pmichaud> I've been wondering if quantified captures should act the same as the :global flag, though

[15:29] <pmichaud> i.e., they return a match object with the individual captures in .[]

[15:29] <pmichaud> instead of returning an array of match objects

[15:29] <moritz_> that could also be pretty confusing

[15:29] <moritz_> because match objects usually represent continuous matches

[15:29] <moritz_> and those wouldn't

[15:29] <pmichaud> ...except in the case of :global :-)

[15:30] <pmichaud> it just seems like a potential semantic mismatch there

[15:31] <ajs> Unrelated: in perl 5, I would return undef to indicate "no result". In P6, is that Mu or should I be returning a more specific type or fail()?

[15:31] <pmichaud> ajs: fail(), usually.

[15:31] <ajs> ok,thanks

[15:31] <moritz_> or maybe Nil

[15:31] <pmichaud> yes, Nil if you really mean "no result"

[15:32] <moritz_> that' like the perl 5 return(); # empty list in list context

[15:32] <pmichaud> moritz_: yes, I agree that using match instead of array could end up being confusing.  someone could then do  $<x>.to   and be totally surprised at the result

[15:33] <pmichaud> whereas if it's an array, $<x>.to  at least gives an error about no method 'to'

[15:33] <pmichaud> so, I guess we leave it as an array

[15:33] <pmichaud> still feels a little weird that :global is different :-)

[15:33] <moritz_> +1 to leaving as-is

[15:34] <moritz_> or even better...

[15:34] <pmichaud> okay, I'm grabbing lunch, then will come back to work on YOU_ARE_HERE refactors

[15:34] <moritz_> don't we have some listy objects that behave just like the stored object if there's only one inside?

[15:34] <pmichaud> sure -- they're called Parcels  :-)

[15:34] <moritz_> then why don't we use a Parcel instead of an Array?

[15:35] <moritz_> that way matches quantified with ? will DWIM as much as possible

[15:35] <pmichaud> well, at the parrot level that would be problematic.

[15:35] <moritz_> Perl 6 will construct its own Match objects

[15:35] <pmichaud> i.e., nqp-rx would never be able to match that.

[15:35] <pmichaud> (not that nqp-rx needs to be driving perl 6 design)

[15:36] <isBEKaml> rakudo: my %hash =<a 1 b 2>; say %hash.keys; say %hash{$_} for %hash.keys; 

[15:36] <p6eval> rakudo 456986: OUTPUT«ba␤2␤1␤»

[15:36] *** pmurias joined
[15:38] <pmichaud> there might also be the problem that single-element captures might cease to act like an array when we need them to

[15:38] <moritz_> that might indeed be a problem

[15:38] <pmichaud> (i.e., the array-ness would get lost somewhere)

[15:38] *** Ross joined
[15:38] <moritz_> anyway, I don't want to stop you from grabbing lunch :-)

[15:38] <pmichaud> I'm more comfortable with things as they re now.

[15:38] <pmichaud> *are

[15:38] <pmichaud> yes, lunch

[15:38] * pmichaud _ISNT_HERE

[15:39] <pugssvn> r30808 | pmurias++ | [mildew] add missing file 

[15:39] <pugssvn> r30809 | pmurias++ | [mildew] add -Fm0ld frontend 

[15:39] <pmurias> moritz_: will there be a gsoc irc meeting?

[15:40] <moritz_> pmurias: we've had masak report as part of the #rakudosketch meeting yesterday

[15:40] <moritz_> pmurias: you'd certainly be welcome there next week (Tue 1900 UTC), or you could arrange something yourself

[15:41] <masak> snarkyboojum++ # perl6awesomedent! \o/

[15:41] <snarkyboojum> masak o/ :)

[15:41] <jnthn> lol...systemet unicode FAIL.

[15:41] <masak> pmurias: but be aware that 'there' is in another place from next week on. #phasers

[15:42] <masak> jnthn: what now?

[15:42] <pmurias> #phasers is the new #rakudosketch?

[15:42] <moritz_> yes :-)

[15:42] <moritz_> for Perl 6 and Rakudo phase transitions, or so

[15:43] <jnthn> masak: Was just glancing my receipt...and turns out whatever font they print in it doesn't have ý in it. :-)

[15:43] <jnthn> Well

[15:43] <masak> jnthn: oh. receipts.

[15:43] <ajs> Gotta go, but I leave you with this one:

[15:43] <jnthn> I'm not sure what the glyph that appears there is. :-)

[15:43] <ajs> rakudo: "abc" ~~ /[$<x> = (b)]?/; say @($/<x>)

[15:43] <p6eval> rakudo 456986: OUTPUT«Method 'list' not found for invocant of class 'ResizablePMCArray'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[15:43] <masak> jnthn: I don't know anyone who gets receipts right.

[15:43] <jnthn> :-)

[15:43] <jnthn> masak: As long as the beer's right, it's fine. :-)

[15:43] <pmurias> moritz_: i think i'll just write a blog post when my milestone is finished and show it to ruoso

[15:44] *** am0c left
[15:46] <masak> the ESR quote at http://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs#Impact is interesting from a Perl 6 perspective as well. Perl 5 may ultimately be a 'dead end', but it's a quite successful one. :)

[15:46] <pmurias> if i convert m0ld -> AST -> m0ld it's called round-tripping?

[15:48] <masak> pmurias: aye.

[15:51] <pugssvn> r30810 | pmurias++ | [mildew] added a -Cm0ld backend to test roundtriping 

[15:51] <diakopter> pmurias: ih

[15:54] *** constant joined
[15:54] *** constant left
[15:54] *** constant joined
[15:54] <diakopter> lol at "ydlsxeci Plan 9"

[15:56] <pmurias> diakopter: hi

[15:57] *** masak left
[15:57] <diakopter> pmurias: wuzzup

[15:58] <pmurias> hacking on rewriting m0ld from haskell to perl5 (part of my GSoC project)

[15:59] *** synth left
[15:59] <diakopter> pmurias: cool

[16:00] *** IllvilJa joined
[16:00] *** synth joined
[16:00] <pmurias> it's more a thing that needs to be done, rather then a particularly cool/fun piece of hacking

[16:01] *** jaldhar left
[16:01] <diakopter> oh

[16:02] <diakopter> what, you're not creating a haskell-esque runtime in Perl? :)

[16:05] <diakopter> that was a joke

[16:07] <pmurias> diakopter: see failing test i committed for perlesque

[16:08] <dalek> csmeta: r297 | pawelmurias++ | trunk/Sprixel/t/parse_bug3.t:

[16:08] <dalek> csmeta: failing test - dunno why

[16:08] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=297

[16:09] <pmurias> please rename it when you find out the true orgin of the bug

[16:11] <pmurias> when are classes better then roles?

[16:12] <TimToady> when you might want to do monkey patching, since roles are immutable

[16:13] <TimToady> when you want your class to have state

[16:13] *** ejs left
[16:14] <TimToady> when you want uneven mixin semantics rather than flat composition

[16:14] <mberends> jnthn: I probably haz $work in Helsingborg June 20-23 (a M$ bootcamp). Will you be in Lund before/after those days?

[16:15] <pmurias> TimToady: mixin semantics?

[16:15] <pmurias> diakopter: the other thing i'm hacking on is a game in erlang

[16:15] <jnthn> mberends: ooh, maybe, let me check travel/conf schedule.

[16:15] <jnthn> mberends: Helsingborg is extremely near here.

[16:16] <jnthn> mberends: I'm away from the 23rd.

[16:16] <jnthn> mberends: I'm around the couple of days before.

[16:17] <mberends> ok, maybe a visit from Friday 18th evening or Saturday morning is possible

[16:17] <isBEKaml> moritz_: sorry I was away for some time, "power" problems. :(

[16:17] <isBEKaml> moritz_: that challenge was unbelievably simple. :O

[16:17] <jnthn> mberends: wfm.

[16:17] <jnthn> You're welcome. :-)

[16:18] <mberends> :-) self.invite();

[16:18] <jnthn> ;-)

[16:18] <jnthn> mberends: Did you get any further on the void thingy?

[16:18] <jnthn> mberends: If not, have you got a small test case I can try?

[16:19] <mberends> nope. the examples file runs, but not the DBI stuff under construction. It's much bigger :-(

[16:20] * mberends gets back into FakeDBI mode

[16:20] <jnthn> Ah

[16:20] <jnthn> mberends: I wonder if the null return value is somehow causing an explosion.

[16:20] <mberends> null != void of course

[16:21] <jnthn> That is, I'd expect that doing $P0 = foo() where foo is an NCI with a signature starting "v" would just shove a null PMC in the register (or complain)

[16:21] <jnthn> Yeah

[16:21] *** pnate joined
[16:21] * jnthn wonders what a good fix may be

[16:21] <jnthn> mberends: There isn't any chance you can get a backtrace?

[16:22] *** colomon left
[16:22] <jnthn> e.g. run it under gdb?

[16:22] * jnthn is really curious where it segfaults

[16:22] <mberends> ok, will try gdb

[16:24] <PerlJam> from #p5p ...

[16:24] <PerlJam> <@xdg> anyone want to opine on how hard it would be to let "when" work inside a map block?

[16:24] <PerlJam> slowly morphing perl 5 into perl 6  :)

[16:24] <mberends> heehee

[16:26] <jnthn> rakudo: (1..10).map({ when 3 { say "tre" }; when 5 { say "fem" }; }).eager

[16:26] <p6eval> rakudo 456986: OUTPUT«tre␤fem␤»

[16:26] <jnthn> Easy. ;-)

[16:26] * jnthn mostly wanted to make sure Rakudo handled it right :-)

[16:27] *** justatheory joined
[16:27] *** hercynium left
[16:27] <snarkyboojum> isBEKaml: my "I did an HTTP request!" *did* turn into something useful - a little cli identi.ca client :)

[16:27] <moritz_> isBEKaml: never said it was hard

[16:28] <isBEKaml> snarkyboojum: nice. link? 

[16:28] <isBEKaml> moritz_: :)

[16:29] <snarkyboojum> isBEKaml: well, it's "as rough as guts" but this is the gist http://gist.github.com/414632

[16:30] <isBEKaml> snarkyboojum++ ## Dented IO::Socket::INET!! :)

[16:31] *** M_o_C joined
[16:31] <snarkyboojum> isBEKaml: :P

[16:33] <pmichaud> back again

[16:34] <pmichaud> jnthn: ping

[16:34] <jnthn> pmichaud: pong

[16:34] <pmichaud> jnthn: want to see a Truly Evil Cheat?  ;-)

[16:34] <pmichaud> (found this last night while working on repl)

[16:34] <jnthn> Uh-oh...

[16:34] <jnthn> :-)

[16:35] <lisppaste3> pmichaud pasted "lexpad evil cheat (for jnthn++)" at http://paste.lisp.org/display/100517

[16:35] *** synth left
[16:35] <jnthn> copy pad, $P1

[16:35] <jnthn> ?!

[16:35] *** XaeroOne joined
[16:35] <pmichaud> I CAN HAZ DYNAMIC LEXPADZ

[16:35] <moritz_> epic

[16:35] <jnthn> omg.

[16:36] <jnthn> There is a proper way to do that. :P

[16:36] <jnthn> pmichaud++

[16:36] <pmichaud> there is?

[16:36] <jnthn> pmichaud: LexPad and LexInfo are, iirc, HLLMappable.

[16:36] <jnthn> pmichaud: But that's effort. ;-)

[16:36] <pmichaud> I only need to do it in one instance, though.

[16:36] <jnthn> Ah

[16:36] <jnthn> Then hack away...and hope. :-)

[16:36] <pmichaud> I don't want all of them to be dynamic... just the one that holds the outer context information for each interactive repl line

[16:36] <jnthn> Where are you doing it, ooi?

[16:37] <jnthn> ah, ok

[16:37] <jnthn> Makes sense.

[16:37] *** meppl joined
[16:38] <pmichaud> essentially, invoke a line of code, capture its context while executing, when it's done executing collect all of the lexicals into the dynamic lexpad

[16:38] <jnthn> Ah

[16:38] <pmichaud> on the next line of code, use the context containing the dynamic lexpad as the outer context for the new line of code

[16:39] <jnthn> Saves building up a long long chain of 'em.

[16:39] <pmichaud> rinse, repeat.

[16:39] <pmichaud> actually, the long-long chains weren't working out.

[16:39] <pmichaud> Parrot doesn't provide sufficient introspective context getting/setting ability to really get the chains to work out

[16:39] <jnthn> Oh.

[16:39] <jnthn> :-|

[16:39] <pmichaud> also, if a sub doesn't believe it's an :outer, it tends to want to throw away its context when it's done

[16:39] *** synth joined
[16:39] <pmichaud> i.e., the return continuation says "okay, we're done, we're not an outer, so we can just throw everything away now!"

[16:40] <pmichaud> and it clears out the registers

[16:40] <jnthn> :|

[16:40] <jnthn> Happy there's a solution.

[16:40] <pmichaud> me too.

[16:40] <jnthn> Even if it does win you disgusting hack on the month award. :-)

[16:40] <jnthn> *of

[16:40] <pmichaud> I thought it was pretty clever

[16:41] <pmichaud> nicer would've been if I could simply setattribute ctx, 'lexpad', pad  instead of using the copy

[16:41] <pmichaud> but allas, that's not allowed either

[16:41] <jnthn> Aye. :-)

[16:41] <pmichaud> *alas

[16:42] *** cdarroch joined
[16:42] *** cdarroch left
[16:42] *** cdarroch joined
[16:42] * jnthn wonders...what else we can use this cheat for. :-) :-)

[16:42] <pmichaud> I knew you'd start thinking of that... :-)

[16:43] <pmichaud> I also added a method that allows us to get an entire lexical environment of a context into a single hash

[16:43] <jnthn> Ah, flattened?

[16:43] <pmichaud> where "entire lexical environment" means context+all outer contexts

[16:43] <pmichaud> yes, flattened

[16:43] <jnthn> Handy.

[16:44] <[particle]> easy to look up OUTER then, i suppose

[16:44] <[particle]> OUTER::$* anyway

[16:44] <pmichaud> somewhat... I think OUTER may be just one level

[16:44] <jnthn> Yeah, same

[16:45] <[particle]> oh, right. OUTER::OUTER::$*. forgot about that

[16:45] <jnthn> CALLER:: OTOH may want a to-the-sub-boundary flat view.

[16:45] <pmichaud> anyway, it's in PIR, so it's a good template for other stuff we might want/need.

[16:45] * jnthn would have to check the spec

[16:45] <jnthn> That is

[16:45] *** __2synth joined
[16:46] *** __2synth left
[16:46] <jnthn> sub foo() { my $a = 42; if 1 { bar() } }; sub bar() { say CALLER::<$a> } # does this work?

[16:46] <jnthn> sub foo() { my $a = 42; if 1 { bar() } }; sub bar() { say CALLER::OUTER::<$a> } # or do you have to write this?

[16:46] <diakopter> my   class LexicalScope : PrototypeChain<string, LexicalScope> { } has a similar (well, PrototypeChain<TKey,TValue> does) all-keys-flattened method

[16:47] <moritz_> jnthn: nope, CALLER only works if the variable in the caller is declared as 'is context'

[16:47] <pmichaud> jnthn: I think CALLER variables are hidden unless 'is dynamic'

[16:47] *** __2synth joined
[16:47] <moritz_> wasn't CONTEXT:: used for caller + caller's lexical environment?

[16:48] <pmichaud> it's now DYNAMIC::

[16:48] <moritz_> ok

[16:48] <pmichaud> and it only looks in callers, not their surrounding outers

[16:48] *** synth left
[16:48] <jnthn> Ah, OK.

[16:50] *** dakkar left
[16:52] *** __2synth left
[16:54] <pmurias> diakopter: any idea what causes that bug?

[16:55] <pmurias> that = one in the failing test

[16:56] <sorear> good morning pmurias 

[16:56] <sorear> pmichaud

[16:56] <pugssvn> r30811 | lwall++ | [S05] attempt to clarify :nth and :x 

[16:57] <pmurias> sorear: hi

[16:59] *** patrickas joined
[16:59] <patrickas> ola!

[16:59] <isBEKaml> hello, patrickas! :)

[17:00] <mberends> perusing docs/test_summary.times, somewhere between May 16th and 20th, the execution time of the first test in every script increased dramatically (factor 2x to 10x). Subsequent tests unchanged. Any idea what caused that (not suggesting a bisect witchhunt)?

[17:00] <patrickas> hey isBEKaml! what's up ? what have you been working on lately ?

[17:01] <moritz_> mberends: so.. startup cost?

[17:01] <mberends> no

[17:01] <mberends> cost of calling the first Test.pm function

[17:01] <jnthn> mberends: Doesn't include calling plan?

[17:02] <jnthn> (that is, could plan have got more costly?)

[17:02] <isBEKaml> patrickas: nothing much. Just hanging around, mostly. :)

[17:02] <mberends> it might be plan(), yes. looking...

[17:03] *** pmurias left
[17:05] <mberends> the increase is between the end of plan() and the first execution of proclaim(), usually via ok().

[17:05] <jnthn> Curious.

[17:06] <diakopter> phenny: tell pmurias no I don't know what's wrong with that bug; I recently slowed down my rate of deluding myself into thinking I have more round tuits than I actually have...

[17:06] <phenny> diakopter: I'll pass that on when pmurias is around.

[17:13] *** alester left
[17:21] <pugssvn> r30812 | lwall++ | [S03] explain how not-raising works on != and ne 

[17:23] <TimToady> pmichaud, mathw: S03 no longer implies that != and ne are distinct operators

[17:23] <jnthn> \o/

[17:23] <diakopter> !!

[17:23] <pmichaud> TimToady: excellent, thanks.

[17:24] <TimToady> so the semantics of != should match !==

[17:24] <jnthn> TimToady: Is negate the right thing to call the HOF that the ! meta-ooperator desugars to?

[17:24] <TimToady> that's why I double-hedged it :)

[17:24] <jnthn> TimToady: If so, will update Rakudo there too (or somebody can beat me to it; currently we call it something else).

[17:24] <TimToady> what do you call it?

[17:24] <jnthn> notresults iirc

[17:24] <jnthn> I prefer negate.

[17:25] <jnthn> rakudo: notresult

[17:25] <p6eval> rakudo 456986: OUTPUT«Could not find sub &notresult␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:25] <jnthn> rakudo: notresults

[17:25] <p6eval> rakudo 456986: OUTPUT«No applicable candidates found to dispatch to for 'notresults'. Available candidates are:␤:(&op, Mu $a, Mu $b)␤:(&op)␤␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:25] <TimToady> I like verbs like cross, reduce, etc

[17:25] <jnthn> That

[17:25] <jnthn> Same

[17:25] <jnthn> 'cus others are like

[17:25] <jnthn> rakudo: crosswith

[17:25] <p6eval> rakudo 456986: OUTPUT«No applicable candidates found to dispatch to for 'crosswith'. Available candidates are:␤:(&op, Iterable $a-iterable, Iterable $b-iterable)␤:(&op, Any $a, Any $b)␤␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:25] <jnthn> etc

[17:33] * snarkyboojum just realised you can exit the REPL with 'last' :)

[17:33] *** colomon joined
[17:33] <moritz_> now that's the last command... :-)

[17:33] <sorear> this is somewhat a bug and may be fixed, depending on how much of my code pmichaud used

[17:34] <snarkyboojum> good that the REPL doesn't segfault any longer

[17:34] <moritz_> std: 1/0e0

[17:34] <p6eval> std 30812: OUTPUT«ok 00:01 114m␤»

[17:34] <moritz_> rakudo: 1/0e0

[17:35] <p6eval> rakudo 456986: OUTPUT«Confused at line 11, near "1/0e0"␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[17:35] <snarkyboojum> sorear: cool - I certainly didn't expect it to exit when I typed 'last' 

[17:35] <moritz_> what's confusing about 1/0e0?

[17:36] <colomon> maybe leftovers from the days when 1/0 was a single number instead of 1 /  0?

[17:36] <moritz_> maybe

[17:36] <moritz_> rakudo: say 2/2**3

[17:36] <p6eval> rakudo 456986: OUTPUT«1␤»

[17:36] <moritz_> yes

[17:36] <moritz_> pugs: say 2/2**3

[17:36] <p6eval> pugs: OUTPUT«0.25␤»

[17:36] <colomon> I thought we'd gotten rid of that complete....  :\

[17:36] <colomon> *completely

[17:37] <moritz_> token number:sym<rational> { <nu=.integer>'/'<de=.integer> }

[17:37] * moritz_ tries to remove

[17:37] <colomon> any idea why TimToady just nixed smartmatching in :nth() ?

[17:38] <moritz_> ETOOMUCHMAGIC?

[17:38] <colomon> it seems the natural way to implement the rest of the specified features...

[17:38] *** perlygatekeeper left
[17:38] <patrickas> how can I add a multi method to Hashes ?

[17:38] <patrickas> naively I would have expected "augment class Hash" or "%h.^add_method" to work but they didn't :-(

[17:38] <TimToady> because smartmatching does the *wrong* thing with :nth(1,3,5)

[17:39] <moritz_> patrickas: currently rakudo implements Hash as a role... so not at all

[17:39] <sorear> TimToady: Is there any difference between COMPILING::<$?FOO> and $*FOO ?

[17:39] <moritz_> rakudo: Hash.^add_method('foo', sub ($a, $b) { say $b } }); say {a => 2}.foo(3)

[17:39] <p6eval> rakudo 456986: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1971 (ext/nqp-rx/src/stage0/Regex-s0.pir:1050)␤»

[17:39] <colomon> TimToady: you mean if you do it $i ~~ 1, 3, 5 rather than $i ~~ any 1, 3, 5   ?

[17:40] <moritz_> rakudo: Hash.^add_method('foo', sub ($a, $b) { say $b }); say {a => 2}.foo(3)

[17:40] <p6eval> rakudo 456986: OUTPUT«Method 'foo' not found for invocant of class ''␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:40] <TimToady> colomon: yes

[17:40] <colomon> ah, okay.

[17:40] <colomon> are closures still allowed?

[17:40] <moritz_> nope

[17:40] <TimToady> and you can still get the smartmatching via grep

[17:40] <patrickas> moritz_ I can add a method foo, but not a multi method

[17:41] <moritz_> patrickas: no idea then :/

[17:41] <TimToady> sorear: yes, COMPILING could conceivably be many dynamic levels outward, and any number of dynamic scopes could have overridden $*FOO inside that

[17:41] <TimToady> so they are not the same

[17:42] <TimToady> and in any case, $?FOO only defaults to $*FOO if there isn't a predefined meaning

[17:42] <patrickas> rakudo: my %h;%h.^add_method('foo', sub ($a, $b) { say $b }); say {a => 2}.foo(3)

[17:42] <p6eval> rakudo 456986: OUTPUT«3␤1␤»

[17:43] <TimToady> also, it's pretty easy to tell when a list is exhausted, and the matching can quit early

[17:43] <colomon> TimToady: If I'm understanding correctly, I'm not sure I like that at all.  Seems like we just went from two different easy ways to specify "match every other time" (either :nth(2) :x(*) or :nth({ %_ !% 2 })) to no easy way.

[17:43] <moritz_> :nth(1, *+2 ... *)

[17:43] <TimToady> :nth(2,4,6...*)

[17:44] <TimToady> :nth(1,3,5...*)

[17:44] <moritz_> colomon: :nth(2) :x(*) never did that

[17:44] <moritz_> that would always only match the 2nd item, never the 4th

[17:44] <TimToady> well, it did in the original formulation lo these many years ago

[17:44] *** ajd joined
[17:44] <TimToady> but a series is much more powerful and expressive

[17:45] <ajd> is there anything out on the state of perl 6?

[17:45] <TimToady> yes

[17:46] <moritz_> ajd: planetsix.perl.org has blogs about many Perl 6 things

[17:46] <ajd> like a paper I could read talking about where is is now, what needs to be done, what has been done, etc

[17:46] <TimToady> however, it's a rather large state vector, so it would help to ask more specific questions

[17:47] <moritz_> there's also http://rakudo.org/status

[17:47] <TimToady> the state of the language as opposed to the various implementations is defined in the synopses

[17:48] <TimToady> (and in the standard parser, STD)

[17:48] *** patrickas left
[17:48] *** perlygatekeeper joined
[17:49] *** envi^home left
[17:51] <colomon> TimToady++ # series

[17:52] <colomon> though that completely blows our current code.

[17:53] *** sundar joined
[17:53] <colomon> does that imply that if you have :nth and :g, hitting the end of the :nth list resets the counter to 1?

[17:54] *** snarkyboojum left
[17:55] * moritz_ doesn't think so

[17:55] <sorear> TimToady: How does using a series as a smartmatch work?

[17:56] <sorear> rakudo: say 2 ~~ 1, 3 ... *

[17:56] <p6eval> rakudo 456986:  ( no output )

[17:56] <moritz_> it's not a smartmatch

[17:56] <moritz_> read the diff again :-)

[17:57] <pugssvn> r30813 | moritz++ | [S03] typo 

[17:58] <lisppaste3> sundar pasted "Why isn't a non-increasing list an error in :nth? (S05-regex.pod)" at http://paste.lisp.org/display/100524

[17:59] <sundar> To clarify, such a non-increasing list will most probably be a mistake, so isn't it better to flag it as such and help the programmer? 

[18:01] <colomon> sundar: are you arguing it should be "such a list must be monotonically increasing" rather than "such a list should be monotically increasing"?

[18:04] *** XaeroOne left
[18:06] <sundar> colomon: I had to refer to the difference, but yes. :) 

[18:06] <colomon> sundar: if so, probably because detecting it is very unreasonable (maybe impossible) if the list extends beyond the number of matches.

[18:08] <TimToady> sorear: you can't smartmatch against an infinite series, except maybe with some kind of prover that shows two expressions will produce the same series

[18:08] <TimToady> list smartmatches do not imply any()

[18:09] <TimToady> unlike in p5 and ancient p6

[18:10] <TimToady> we might possibly define any() on monotonic infinite serieses; there may already be a conjecture in the spec about that

[18:11] <moritz_> a conjectural conjecture :-)

[18:11] <TimToady> but there has to be some way to know when to stop looking

[18:12] <TimToady> in the case of :nth, we have the benefit of knowing we're checking against 1...$n for finite $n

[18:12] <TimToady> well, until we get infinite strings :)

[18:14] <colomon> hmm?

[18:14] <moritz_> like .cat?

[18:16] <colomon> I just figured every time we got a match, we looked at the next thing in the :nth list, and walked up the list as needed, which is why it has to be in monotonically increasing.

[18:17] <colomon> (which is an approach well-suited to being lazy in the case of infinite strings (ie Cat))

[18:17] <moritz_> now we need to JFDI

[18:18] * colomon is still confused by :x

[18:18] *** ajd left
[18:19] <diakopter> Return of the Jfdi

[18:19] <colomon> moritz_: you want to work on .match or on the tests?  ;)

[18:21] <moritz_> colomon: will look at the tests first

[18:21] *** iblechbot joined
[18:21] <colomon> moritz_: okay, I'll see if I can quickly puzzle out the new algorithm

[18:22] <moritz_> so I guess ranges are still allowed?

[18:23] <moritz_> (assuming they somhow interpolate into lists

[18:23] <moritz_> rakudo: say (1, 2..3).perl

[18:23] <p6eval> rakudo 456986: OUTPUT«(1, 2..3)␤»

[18:23] <colomon> I'm assuming it's actually Iterable which is allowed, which includes Ranges

[18:25] <dalek> rakudo: 4e3d29d | (Hongwen Qiu)++ | src/core/Cool-str.pm:

[18:25] <dalek> rakudo: add :samecase to Cool.subst

[18:25] <dalek> rakudo: Signed-off-by: Moritz Lenz [email@hidden.address]
[18:25] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4e3d29df4c64affddf6ff127652f92adce1077f7

[18:25] <dalek> rakudo: bafb6d9 | moritz++ | src/Perl6/ (2 files):

[18:25] <dalek> rakudo: remove rational number literal fossile

[18:25] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/bafb6d95ed74f6272fc91997722de560dd0ce81a

[18:25] *** bluescreen joined
[18:26] *** bluescreen is now known as Guest72640

[18:27] *** charsbar left
[18:27] *** charsbar joined
[18:28] <colomon> say 4.Iterator

[18:28] <colomon> rakudo: say 4.Iterator

[18:28] <p6eval> rakudo 456986: OUTPUT«Method 'Iterator' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[18:28] <colomon> rakudo: say 4.list

[18:28] <p6eval> rakudo 456986: OUTPUT«4␤»

[18:28] <colomon> rakudo: say 4.list.iterator

[18:28] <p6eval> rakudo 456986: OUTPUT«4␤»

[18:28] <pugssvn> r30814 | moritz++ | [t/spec] bring :nth tests up to current spec 

[18:28] <colomon> rakudo: my $a = 4.list.iterator; say $a.get; say $a.get

[18:28] <p6eval> rakudo 456986: OUTPUT«4␤␤»

[18:29] *** BrowserUk left
[18:29] <colomon> rakudo: my $a = 4.list.iterator; say $a.get; say $a.get ~~ EMPTY

[18:29] <p6eval> rakudo 456986: OUTPUT«4␤1␤»

[18:30] *** TiMBuS left
[18:30] <pugssvn> r30815 | moritz++ | [t/spec] remove more outdated usages of :nth 

[18:30] *** iblechbot left
[18:31] *** uvtc joined
[18:32] <sorear> interesting

[18:32] <sorear> TimToady: I think I broke something

[18:32] <TimToady> so did I :)

[18:32] <sorear> ./viv STD.pm6 --> Check failed; undeclared routines: invert, note

[18:32] <uvtc> Hi p6. Does code written in Perl 6 use 2 different filename extensions for scripts and modules (like Perl 5: .pl and .pm)?

[18:33] <moritz_> uvtc: yes (though .pm6 is also OK)

[18:33] <TimToady> sorear: maybe you need a clean remake

[18:33] <TimToady> those should come in from CORE.setting via syml/CORE.syml or some such

[18:34] <sorear> unless viv is using the wrong setting

[18:34] <colomon> moritz_: have a trial implementation.  now compiling.

[18:34] <pugssvn> r30816 | moritz++ | [t/spec] remove old :nth usages from .subst tests 

[18:35] <colomon> nice thing about this version is it radically more efficient when looking for a few early matches out of many.

[18:35] <colomon> if it sees :nth(2) it stops processing the string for matches after the 2nd is found.

[18:35] <moritz_> colomon: I tend to prototype the implemention of such methods in "normal" (non-setting) code, because it's faster to compile

[18:35] <colomon> moritz_: that's probably sensible.  but too late... :)

[18:36] <colomon> my brain is still set to the days when compiling and testing ng was really fast.  

[18:36] <moritz_> for example for .subst I just monkey-typed class Str, that way it was always tighter than the built-in

[18:36] <moritz_> which is in Cool

[18:37] <colomon> moritz_++ # I had no idea you could do that.

[18:37] <colomon> and say probably works then too, eh?

[18:37] <moritz_> it does

[18:38] <moritz_> decadent luxury, I know

[18:38] <sorear> Just how old is STD and gimme5?

[18:39] <colomon> say "hello world".match(/./, :nth(1,2,*+*...*))

[18:39] <colomon> duh

[18:39] <colomon> > say "hello world".match(/./, :nth(1,2,*+*...*))

[18:39] <colomon> heloo

[18:40] *** slavik left
[18:40] <colomon> > say "hello world".match(/./, :nth(1,3...*))

[18:40] <colomon> hlowrd

[18:40] *** slavik joined
[18:40] <colomon> moritz_: are the tests ready to go?

[18:40] <moritz_> colomon: yes

[18:40] <moritz_> not terribly many use :nth

[18:41] <colomon> @match = $data.match(/fo+/, :nth({ $_ !% 2 })); still in counted-match.t 

[18:41] <moritz_> oh

[18:41] <colomon> should be 2, 4 ... *

[18:41] <colomon> ?

[18:41] <moritz_> yes

[18:42] <colomon> I've got it;.

[18:42] <colomon> you added a non-monotonic test, moritz_++

[18:43] <pugssvn> r30817 | moritz++ | [t/spec] remove another :nth fossile, colomon++ 

[18:43] <uvtc> When building rakudo, `make install` just installs things within my rakudo-2010.05 directory -- and not in my /usr/local -- is that correct?

[18:44] <sorear> yes

[18:44] <uvtc> sorear: thanks

[18:44] <sorear> make install installs things within your Parrot installation

[18:45] <sorear> if you're using a system-wide Parrot install, you can install Rakudo system-wide

[18:45] <pugssvn> r30818 | colomon++ | [t/spec] Simple :nth test with infinite series. 

[18:45] <uvtc> I'm doing a `perl Configure.pl --gen-parrot` build.

[18:46] <moritz_> that will install into rakudo-2010.05/parrot_install/

[18:46] <moritz_> so that after 'make install' in Rakudo you'll have a parrot_install/bin/perl6 binary

[18:48] <jnthn> The fibonaci hello world!

[18:48] * jnthn likes :nth

[18:49] <colomon> moritz_: had to patch my fix to make your non-monotonic test work.  compiling version 2 now...

[18:49] <colomon> ooo, infinite loop

[18:49] <uvtc> If I then want to make that perl6 available to all users on the system, can I just copy the whole rakudo-2010.05 directory to /opt, create an /opt/rakudo symlink there, and then tell them to use this shebang in their Perl 6 scripts: `#!/opt/rakudo/parrot_install/bin/perl6`?

[18:50] <sorear> no

[18:50] <sorear> if you want to make perl6 available to all users on the system, you'll need to do a global install of Parrot

[18:50] <uvtc> (Sorry, I meant mv, not cp.)

[18:51] <sorear> parrot_install is not relocatable

[18:51] <sorear> 1. get Parrot

[18:51] <sorear> 2. perl Configure.pl --optimize && make && sudo make install # this will put Parrot in /usr/local

[18:51] <uvtc> sorear: but i mean moving the whole rakudo-2010.05 directory to /opt, not just the parrot_install dir.

[18:51] <sorear> uvtc: parrot bakes paths into its files

[18:51] <moritz_> uvtc: perl Configure --gen-parrot --gen-parrot-prefix=/usr/local/

[18:51] <sorear> 3. switch back to Rakudo

[18:52] <sorear> oh, that works too.

[18:52] <moritz_> uvtc: then run 'make install' in rakudo => profit

[18:53] * colomon just realized he shouldn't have committed that fix, as it will cause failing tests for everyone else

[18:53] <colomon> moritz_: counted-match.t works completely here now.

[18:53] <uvtc> Oh, interesting. Sounds like somewhere it's using absolute paths instead of relative ones.

[18:54] <pugssvn> r30819 | sorear++ | [viv] Allow saving of parsed code 

[18:54] <sorear> uvtc: s/somewhere/everywhere/

[18:54] <moritz_> colomon: \o/

[18:54] <uvtc> moritz: would that be `--gen-parrot-prefix=/opt` or `--gen-parrot-prefix=/opt/rakudo-2010.05`?

[18:54] <sorear> uvtc: why not /usr/local?

[18:55] <colomon> where were the other :nth tests?

[18:55] <moritz_> colomon: subst.t

[18:55] <sorear> whatever you use, Rakudo will be installed as PREFIX/bin/perl6

[18:55] <colomon> where there some in a match.t or no?

[18:55] <moritz_> there too

[18:55] <uvtc> Either would be fine. I guess I just got into the habit of using /opt for "larger" self-contained software (like java).

[18:55] <moritz_> colomon: but those are not runnable by rakudo, iirc

[18:56] <moritz_> no wait, in counted.t

[18:56] <moritz_> $ ack -l :nth S05-*

[18:56] <moritz_> S05-modifier/counted-match.t

[18:56] <moritz_> S05-modifier/counted.t

[18:56] <moritz_> S05-substitution/subst.t

[18:56] <colomon> moritz_: apparently I took stupid pills this morning, latest version handles weird lists but breaks non-nth matches.  :(

[18:57] <moritz_> colomon: nopaste patch?

[18:57] <colomon> already fixed it, I think.

[18:57] <uvtc> sorear: in that case, shouldn't PREFIX be `/usr/local/rakudo-2010.05/parrot_install` ?

[18:57] <colomon> (compiling / testing now)

[18:58] <sorear> uvtc: that's the default PREFIX, but you just said you wanted to move it to /opt

[18:58] <moritz_> uvtc: where do you want the binary to be?

[18:58] <uvtc> sorear: Sorry, I don't think I understand ... do I need the whole rakudo-2010.05 directory and all its contents to be in /usr/local?

[18:59] *** arthur-_ joined
[18:59] *** arthur-_ left
[18:59] <sorear> uvtc: NO

[18:59] <sorear> er

[18:59] <sorear> no.

[18:59] <colomon> moritz_: that's better.

[18:59] <sorear> do not move rakudo-2010.05

[18:59] <sorear> it will not work

[18:59] <sorear> clean everything, change the prefix, and rebuild

[18:59] <sorear> also, where do you want the binary to be?

[19:00] <uvtc> sorear: Ok. Just finished a make that I'd started before we began chatting.

[19:00] <sorear> whee.  ./viv -5 --thaw STD.store in 4.5sec

[19:00] *** M_o_C left
[19:01] <uvtc> sorear: Where is the customary place for the binary? I suppose `/usr/local/parrot/bin`?

[19:01] <uvtc> afk

[19:01] <sorear> uvtc: just /usr/local/bin

[19:01] <colomon> moritz_: prepping for spectest

[19:03] <TimToady> sorear: I think I finally have a fix for your <foo()> dropping the longname

[19:03] <uvtc> sorear: {back} thanks.

[19:04] <uvtc> sorear: Sorry, but I'm still confused. Doesn't the perl6 binary need some accompanying parrot directory to run?

[19:05] <moritz_> uvtc: it needs an installed parrot + tools

[19:05] <uvtc> sorear: if I download rakudo and build in my ~/temp directory, I'd like to be able to delete that temporary build stuff after installing what's necessary somewhere into /usr/local.

[19:06] <moritz_> so you configure it iwth --gen-parrot-prefix=/usr/local

[19:06] <moritz_> but we had that already, no?

[19:06] <uvtc> moritz: right. So, it seems easiest to have the perl6 binary and the parrot + tools all living together, in per-fect har-mon-ey. :)

[19:06] <moritz_> correct.

[19:06] <sorear> uvtc: you should install the parrot stuff in /usr/local/bin/parrot, /usr/local/lib/parrot/2.4.0/runtime, etc

[19:07] <sorear> this can be accomplished by a default install of standalone parrot or a --gen-parrot --gen-parrot-prefix=/usr/local build of rakduo

[19:07] <sorear> TimToady: Excelllent.

[19:08] <uvtc> sorear: I'd rather not let parrot install itself throughout my /usr/local. Seems tidier to have it in its own /usr/local/parrot directory.

[19:08] *** awwaiid joined
[19:08] <moritz_> then use /usr/local/parrot as prefix

[19:09] <moritz_> and rakudo will be in /usr/local/parrot/bin/perl6

[19:09] <uvtc> moritz: beautiful. Will try that, but gotta run at the moment. Thanks very much!

[19:12] *** dju_ joined
[19:12] *** uvtc left
[19:18] *** Guest72640 left
[19:18] *** Guest72640 joined
[19:21] <pugssvn> r30820 | sorear++ | [viv] Store generated class information in compiled files 

[19:21] *** ShaneC joined
[19:21] <TimToady> sorear: did you fix the :sigspace problem in viv?  if not, I think my <foo()> fix might've done so...at least it shows up now

[19:21] *** synth joined
[19:22] <sorear> yes, I fixed :sigspace

[19:22] <sorear> $*RX<s>, remember?

[19:22] <TimToady> 'kay

[19:22] <TimToady> right

[19:22] *** ShaneC left
[19:22] <TimToady> (just testing my patch)

[19:23] *** rhr left
[19:29] * sorear is running viv on live STD.pm6 now :)

[19:30] <pugssvn> r30821 | colomon++ | [spec] Add Real.Int, Real.Rat, Real.Num, and Real.Complex to the spec. 

[19:31] <pugssvn> r30822 | sorear++ | [viv] Implement token foo:bar syntax 

[19:32] <TimToady> sorear++

[19:32] <sorear> now I've gotten far enough down STD.pm6 to hit what appears to be the <foo()> crash

[19:33] <dalek> rakudo: 475d1c7 | (Solomon Foster)++ | src/core/Cool-str.pm:

[19:33] <dalek> rakudo: Change .match to support the new list approach for :nth.

[19:33] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/475d1c77fba6ff29c93c347336c51d203675b926

[19:33] <sorear> hmm, I don't have anything for protoregex traits

[19:37] <TimToady> about to check in fix, but it breaks $<foo> = <bar> for some reason

[19:40] *** rhr joined
[19:41] *** nadim joined
[19:42] <TimToady> well $<foo> = (@x), more specifically

[19:44] *** plainhao left
[19:46] <pugssvn> r30823 | colomon++ | [t/spec] Unfudge tests that now work. 

[19:48] <moritz_> colomon++

[19:49] *** Ross^ joined
[19:49] *** Ross left
[19:53] <sjohnson> rakudo: my $x = 

[19:53] <p6eval> rakudo bafb6d: OUTPUT«Confused at line 11, near "my $x ="␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[19:53] <sjohnson> oops... enter key fail

[19:53] <sjohnson> ... anyone else ever hit the enter key often, when trying to hit the single quote?

[19:53] <moritz_> I hit enter when I want to hit backspace

[19:54] <jnthn> My keyboard has a #~ key in the way. :-)

[19:54] *** justatheory left
[19:54] <jnthn> (between ' and enter)

[19:54] <moritz_> not a good habit when you're typing rm $somthing on the command line, and want to change the wrong last character

[19:58] <pugssvn> r30824 | lwall++ | [STD] don't lose existing bindings when we go to a sublanguage 

[19:58] <pugssvn> r30824 | [STD] refactor $*GOAL to only be informative, never used as <stopper>

[19:58] <pugssvn> r30824 | instead, we create a <stopper> rule for $*GOAL if necessary

[19:58] <pugssvn> r30824 | [gimme5,Cursor] various tweaks in support of the above

[19:59] *** Ross^ left
[19:59] <sorear> TimToady++

[19:59] <TimToady> phone

[20:00] *** Ross^ joined
[20:02] <colomon> rakudo: say 1

[20:02] <p6eval> rakudo bafb6d: OUTPUT«1␤»

[20:02] <moritz_> recompilation in 13min

[20:17] *** justatheory joined
[20:17] <colomon> rakudo: say 1

[20:17] <p6eval> rakudo bafb6d: OUTPUT«1␤»

[20:17] <colomon> recompile starts in 13min, I'm guessing that should have said?

[20:18] * colomon has no idea why he wants to play with p6eval when he has an up-to-date REPL at home.

[20:26] <colomon> rakudo: say 1

[20:26] <p6eval> rakudo bafb6d: OUTPUT«1␤»

[20:29] <pmichaud> hugme: add chromatic to nqpbook

[20:29] * hugme hugs chromatic. Welcome to nqpbook!

[20:31] *** TSa left
[20:32] *** rhr left
[20:39] *** clintongormley left
[20:47] *** pmurias joined
[20:52] *** kel__ left
[21:01] *** patspam1 joined
[21:01] *** patspam left
[21:02] *** patspam1 is now known as patspam

[21:05] * cognominal searched a long time why parse actions where not triggered. I did   parse(....,  :actions<ActionClass>)   instead of ... :actions(ActionClass)

[21:06] *** Guest74734 left
[21:06] <cognominal> I hate sllent fails...

[21:07] <m6locks> fale

[21:08] *** rhr joined
[21:09] *** SmokeMachine left
[21:16] <pmichaud> cognominal: I think we can remove the silent fail.

[21:16] <pmichaud> oh, actually, in this case it might be tricky. Hrm.

[21:16] <pmichaud> I'll think about it.

[21:17] <cognominal> I don't whine much because I suppose someday, once bootstrapped, you (or someone) will rewrite that in Perl 6 and make that more solid.

[21:17] <cognominal> You have so much on your plate...

[21:20] <jnthn> The thing is that methods in general take a *%_

[21:20] <jnthn> Which swallows up the typo'd names.

[21:20] *** whiteknight joined
[21:21] <cognominal> my error was more a braino than a typo, passing a string instead as a class as a pair value

[21:22] <cognominal> s/as/of/

[21:23] <jnthn> Ah

[21:23] <jnthn> That's harder to catch, yes

[21:23] <jnthn> Well, maybe a :U on actions so you gotta pass some type object.

[21:24] <jnthn> Oh, no, 'cus you may pass an instance...

[21:24] <jnthn> Hm

[21:24] <jnthn> Yeah, hard to catch. :)

[21:24] <cognominal> what a :U?

[21:25] <cognominal> why not testing if a string and if so searching the corresponding class and passing that instead, Is that so difficult?

[21:26] <cognominal> anyway I am happy I caught my mistake

[21:26] *** ruoso_ left
[21:27] *** Su-Shee left
[21:28] *** Guest72640 left
[21:31] *** pmurias left
[21:43] *** tedv joined
[21:44] <jnthn> pmichaud: ping

[21:44] <pmichaud> jnthn: pong

[21:44] <pugssvn> r30825 | tedv++ | Fixed incorrect test descriptions. 

[21:44] <jnthn> pmichaud: I'm working on auto-currying.

[21:44] <jnthn> pmichaud: What you rather we construct the PAST for a closure, or instead just call some PIR thingy that manufatures them?

[21:45] <pmichaud> you mean at runtime?

[21:45] <jnthn> For the PIR case, yes.

[21:45] <jnthn> Well

[21:45] <jnthn> We could write it in Perl 6 actually :-)

[21:45] <pmichaud> heh

[21:45] <jnthn> I can go either wa

[21:45] <jnthn> *way

[21:46] <colomon> in p6 would be pretty straightforward, wouldn't it?

[21:46] <pmichaud> you don't have a preference or bias?

[21:46] <jnthn> It occurs to me that we can also for * op * just return the op itself, but maybe that'd be cheating.

[21:46] <jnthn> pmichaud: Well, given it can be done in Perl 6, that eliminates my preference not to write more stuff in PIR. :-)

[21:46] <pmichaud> do you need an answer soon, like, tonight?

[21:46] <jnthn> pmichaud: I can go either way. The Perl 6 way is a little more runtime cost, but a little less PAST.

[21:46] <colomon> still have to handle the * op (* op2 1) case, right?

[21:46] <colomon> (etc)

[21:46] <jnthn> colomon: oh, yes

[21:47] <jnthn> colomon: That...shouldn't be a problem with either approach.

[21:47] <jnthn> pmichaud: Am just hacking on it now and was about to JFDI one way or the other, and wondered if you had a big preference, that's all.

[21:47] <pmichaud> jnthn: my gut reaction is that the PIR case might be _really_ nice.

[21:48] <pmichaud> as in, cleaner overall for dealing with closures in general.

[21:48] <jnthn> pmichaud: It'd be short but...well...then we end up with annoying problems that make it less nice.

[21:48] <colomon> jnthn: I can sort of see how to do it, but was wondering about * op * just being op and how it would interact with that.

[21:48] <pmichaud> jnthn: thus my question about how soon do you need it -- I think I need an evening (but just one) to let it stew in my head a bit

[21:48] <jnthn> Like, we want to return a Perl 6 Block, not a Parrot Sub. And we want it to have a proper signature...

[21:48] <jnthn> pmichaud: It's, like, what I've dug into doing tonight. :-)

[21:48] <colomon> pmichaud: will that depend on fixing closures?

[21:49] <pmichaud> colomon: I think it might simplify fixing closures

[21:49] <colomon> oooooo

[21:49] <pmichaud> jnthn: I'm thinking it might simplify the Perl 6 Block issue a bunch

[21:49] * jnthn ...hadn't seen those as related.

[21:50] <pmichaud> oh, I think I might've misunderstood what you said earlier, then.

[21:50] <jnthn> pmichaud: I'm just working on the

[21:50] <jnthn> * + * => { $^a + $^b }

[21:50] <jnthn> thingy

[21:50] <pmichaud> jnthn: right

[21:51] <pmichaud> I'm wondering if it could be generalized slightly to clean up Perl 6 block construction in general throughout the actions

[21:51] <pmichaud> right now it's a bit... messy

[21:51] <jnthn> Ah, OK

[21:51] <jnthn> Now I see what you're getting at a bit more.

[21:53] <sorear> pmichaud: How is the REPL stuff faring?

[21:53] <sorear> pmichaud: Is any of my research helping?

[21:53] <pmichaud> sorear: yes, it helped quite a bit.

[21:53] <pmichaud> I _really_ appreciated your conversion of HLLCompiler stuff into nqp.  Much nicer to work with.

[21:53] <pmichaud> I have REPL in NQP implemented now.  Adding it to other HLLs will be really easy.

[21:54] <pmichaud> Adding it to Rakudo is a bit tricky because the YOU_ARE_HERE stuff needs a bit of a refactor (and because of the way Perl 6 in general deals with lexical setting)

[21:56] <sorear> Yes.  You're running into a problem which I did.

[21:56] <sorear> My solution was to change YOU_ARE_HERE so that it only called set_outer if the old outer was null

[21:56] <pmichaud> that's the solution we cam up with today

[21:56] <pmichaud> *came

[21:56] <pmichaud> so looks like you were ahead of us a bit

[21:57] <pmichaud> but YOU_ARE_HERE still needs some other cleanups

[21:57] <sorear> your handling of the REPL as outers is a bit different from mine though

[21:57] <pmichaud> actually, outer singular now

[21:57] <sorear> this custom lexpad stuff is pretty crazy ;)

[21:57] <pmichaud> there's one outer

[21:57] <pmichaud> and its lexpad continues to be replaced with an updated lexpad

[21:58] <pmichaud> currently I have it as a package-scoped object, I'm likely to let it be created local to any given interactive loop

[21:58] <sorear> where I went with this was, since eval always sets the outer, it's no longer needed to keep two separate code paths in src/builtins/eval.pm

[21:58] <sorear> then $*IN_EVAL can die, !UNIT_START can be simplified a tiny bit

[21:59] <pmichaud> correct

[21:59] <pmichaud> again, you're doing the same as what I plan

[21:59] <sorear> also, you're about to break spectests

[21:59] <pmichaud> oh?

[22:00] <sorear> the spectests assume that eval "return" will drop a non-null value into $!

[22:00] <sorear> in current Rakudo, this works entirely by accident

[22:00] <sorear> return throws a control exception, which gets caught by the compile-exception-catcher in eval

[22:00] <sorear> once eval is made symmetric, that won't work

[22:01] <pmichaud> oh, that's probably not too big an issue

[22:01] <pmichaud> I think I can work around it, at any rate.

[22:01] <sorear> so you'll need to port a patch from topic/lexical-persistence-2 which adds a CONTROL { die "unexpected control exception" }

[22:01] <jnthn> Hmm. 

[22:01] <jnthn> * + foo(42)

[22:01] <jnthn> Means { $_ + foo(42) }

[22:01] <jnthn> Or

[22:02] <jnthn> $temp = foo(42); { $_ + $temp }

[22:02] <pmichaud> I'd be okay if &eval isn't exactly the same as HLL::Compiler.eval

[22:03] <pmichaud> jnthn: my expectation would be the latter.

[22:03] <jnthn> Ah, S02 suggests the first.

[22:03] <pmichaud> doh!

[22:03] <jnthn> Well

[22:04] <jnthn> It's making a subtler and trickier point though

[22:04] <Eevee> latter seems potentially surprising: foo(*) + foo(42)

[22:04] <jnthn> oh hmm

[22:04] <jnthn> Eevee: That won't get curried, fwiw

[22:04] <Eevee> where, e.g., foo == print

[22:04] <Eevee> oh well then nevermind

[22:04] <jnthn> Needs to be a literal * directly on one side of the operator.

[22:04] <jnthn> pmichaud: The bit of the synopsis is:

[22:04] <jnthn> This rewrite happens after variables are looked up in their lexical scope,

[22:04] <jnthn> and after declarator install any variables into the lexical scope,

[22:04] <jnthn> with the result that

[22:04] <jnthn> * + (state $s = 0)

[22:04] <jnthn> is effectively curried into:

[22:04] <jnthn> -> $x { $x + (state $OUTER::s = 0) }

[22:05] <Eevee> how much does * gobble?  only infix operators?

[22:05] <jnthn> Eww. :-/

[22:05] <lue> Ohai!

[22:05] <jnthn> Oh, wait, it's maybe not nasty

[22:05] <jnthn> Because we have already shoved the decl in the right place.

[22:05] <jnthn> It seems to imply that the assignment happens inside the closure though.

[22:06] <jnthn> Eevee: Postfixes and prefixes too, it appears.

[22:06] <jnthn> For any unary or binary operator (specifically, any prefix, postfix,

[22:06] <jnthn> and infix operator), if the operator has not specifically requested

[22:06] <jnthn> to handle C<*> itself, the compiler is required to translate directly

[22:06] <jnthn> to an appropriately curried closure at compile time.

[22:06] <jnthn> Compiler translates...directly.

[22:06] * jnthn sees the evidence starting to stack up one way :-)

[22:07] <Eevee> hm.  not list?

[22:07] <pmichaud> jnthn: yeah, but I just see weird issues with something like

[22:07] <pmichaud> my $x = * + foo($y);

[22:07] <pmichaud> $y = 7

[22:07] <pmichaud> say $x(3)

[22:07] <jnthn> 10? :-)

[22:07] <pmichaud> because at the time we evaluate the closure, $y is changed

[22:08] <jnthn> pmichaud: Aye - I'm not sure if I see that as weird or not. :-)

[22:08] <pmichaud> I suppose if we think of * as always meaning "construct a closure", then it makes okay sense

[22:09] <jnthn> pmichaud: Yeah, that's how I'd been seeing it.

[22:09] *** IllvilJa left
[22:09] <pmichaud> and I'm guessing that *-currying is now always syntactic?

[22:09] <pmichaud> since it's a compile-time feature?

[22:09] <jnthn> pmichaud: That's very much how the synopsis reads to me.

[22:09] <arnsholt> It sounds like a potential feature, but one that'll take a bit of getting used to

[22:09] <pmichaud> yeah, me too.

[22:09] <jnthn> OK, I'll go that way.

[22:09] <sorear> It's actually a quite critical feature.

[22:10] <pmichaud> how does something like   * + foo(*)   work?

[22:10] <jnthn> Nastily, I suspect.

[22:10] <pmichaud> or even   * + (3 - *)   ?

[22:10] <sorear> It's what makes @foo[*-1] work

[22:10] <jnthn> That second one works OK

[22:10] <sorear> pmichaud: like { $^a + foo($^b) }

[22:10] <sorear> pmichaud: I asked earlier

[22:10] <arnsholt> The first example would be the same as *+foo(3), no?

[22:10] <colomon> I would assume foo(*) is called, or at least that call is compiled in.

[22:10] <jnthn> Ah, or is it..

[22:10] <jnthn> colomon: Yeah

[22:10] <sorear> er, actually it wouild be { $_ + foo(*) }

[22:10] <Eevee> wouldn't the first be { $^a + { foo($^a) } }

[22:10] <colomon> sorear: right

[22:10] <Eevee> and thus sort of useless

[22:11] <jnthn> Eevee: No

[22:11] <jnthn> It'd end up as { $^a + foo(*) }

[22:11] <sorear> Eevee: no.  WhateverCode closures curry like Whatever itself

[22:11] *** sundar left
[22:11] <jnthn> sorear: WhateverCode is what we can rid of by doing it syntactic, btw. :-)

[22:11] <pmichaud> but foo(*) isn't a WhateverCode

[22:11] <jnthn> pmichaud: Correct.

[22:11] <jnthn> It's just a call that passes *.

[22:12] <pmichaud> so what happens with

[22:12] <pmichaud> * + foo(*.xyz)

[22:12] <Eevee> it might be time to read S02

[22:12] <Eevee> this is getting increasingly contrived

[22:12] <sorear> It's never not time to read S..

[22:12] <jnthn> { $^a + foo({ $^a.xyz }) }

[22:12] <jnthn> pmichaud: The two auto-curryings are independent there.

[22:13] <jnthn> afaiu.

[22:13] <pmichaud> jnthn: right

[22:13] <pmichaud> and foo() probably won't know how to handle a WhateverCode argument?

[22:13] <pmichaud> or....

[22:13] <jnthn> pmichaud: There is no WhateverCode

[22:13] <pmichaud> sorry, closure

[22:13] <jnthn> pmichaud: It's just a Block now?

[22:13] * jnthn had been thinking the switch to syntactic was so we could do away with all the various types and multi candidates.

[22:14] <cognominal> the game is to read a S* in one sitting without missing anything.  I have lost eacht time so far

[22:14] <jnthn> And then map will Just Work 'cus it knows what to do with a Callable

[22:14] <pmichaud> jnthn: well, I think that is the thinking, but in my experience it's a waterbed model

[22:14] <pmichaud> i.e., we think we're doing away with it but we've really just pushed the problems somewhere else :-)

[22:14] <pmichaud> kind of like lists and arrays, or the original interpretations of Whatever :)

[22:14] <jnthn> pmichaud: It feels to me like we're trying to take a little bit of sugar that's handy for simple things and trying to make it handle every case we could ever come up with.

[22:15] <pmichaud> jnthn: well, that was the original problem with Whatever, also.  :)

[22:15] <Eevee> well, the language is perl 6...  :P

[22:15] <jnthn> I'd kinda rather it didn't, and people can write out exactly what they want if the simple thing isn't it.

[22:16] <pmichaud> okay, so we only curry on unary and binary operators

[22:16] <jnthn> Otherwise we get * + 3 * * - 42

[22:16] <jnthn> And it's like...huh wtf.

[22:16] <pmichaud> I can live with that.

[22:17] <jnthn> I can live with people being disuaded to write things like that. :-)

[22:17] <pmichaud> I meant I can live with the currying happening at compile time for the binary operators

[22:17] <jnthn> pmichaud: Ah, OK. :-)

[22:17] <pmichaud> (and unaries)

[22:17] <jnthn> OK.

[22:17] <pmichaud> I'm guessing that would have to patch into the expression actions somewhere?

[22:18] <pmichaud> i.e., we need nodes that can say "I'm a currying argument?"

[22:18] <jnthn> pmichaud: I was thinking just a check if $key is INFIX, POSTFIX or PREFIX and if so call whatever_curry or something that goes checking for the whatevers, and also that it's not one of the operators we shouldn't auto-curry.

[22:19] <jnthn> pmichaud: I just added :returns('Whatever') to the PAST node that * generates.

[22:19] <pmichaud> jnthn: sounds like a very reasonable starting point

[22:19] <jnthn> Then it's a very easy check

[22:19] <pmichaud> go with that :)

[22:19] <jnthn> No $pastnode<whatever> flags. ;-)

[22:19] <jnthn> pmichaud: OK, I'll fetch a beer and dig in. :-)

[22:19] <Eevee> (*, *, $x) = (1, 2, 3); <= appears in S02.  wouldn't this require * to eat listops too

[22:20] <jnthn> Eevee: No, that works for Other Reasons. :-)

[22:20] <Eevee> oh dear.  Other Reasons are frightening

[22:20] <jnthn> Eevee: It's just a list assignment.

[22:20] <pmichaud> but it does have infix:<,> in it :-)

[22:20] <jnthn> And it so happens that if you assign to * it throws away the value.

[22:20] <Eevee> in that case I guess that's a good argument for not eating listops

[22:20] <jnthn> pmichaud: oh ouch...

[22:20] <Eevee> oh I thought , was list

[22:20] <jnthn> pmichaud: I think I need a check for binary. ;-)

[22:21] <jnthn> *binaryness

[22:21] <jnthn> binarity?

[22:21] <jnthn> Meh, I should learn English some day.

[22:21] <pmichaud> just check that it's not  :assoc<list>, probably.

[22:21] <jnthn> pmichaud: That works too.

[22:21] <jnthn> rakudo: * = 'lol thrown away';

[22:21] <p6eval> rakudo 475d1c: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 18373 (src/builtins/Junction.pir:373)␤»

[22:21] <jnthn> ...oh.

[22:22] <pmichaud> either that or make sure that infix:<,> doesn't curry.

[22:22] <pmichaud> which, it probably doesn't since it takes Object as arguments.

[22:22] <jnthn> rakudo: my $x; (*, *, $x) = (1, 2, 3);

[22:22] <p6eval> rakudo 475d1c:  ( no output )

[22:22] <jnthn> pmichaud: Aye.

[22:22] <pmichaud> sorry, Mu

[22:22] <jnthn> :-)

[22:23] <pmichaud> so, does an operator have to explicitly declare a Whatever formin order to be not curried?  or is declaring a Mu parameter sufficient?

[22:23] <pmichaud> i.e., if I have   sub infix:<abc>(Mu $a, Mu $b) { ... }

[22:23] <pmichaud> does "* abc 3"  auto-curry?

[22:24] <Eevee> rakudo: (*) = (1);

[22:24] <p6eval> rakudo 475d1c: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 18373 (src/builtins/Junction.pir:373)␤»

[22:25] <jnthn> pmichaud: Well, TimToady mentioned as a first cut we just black-list some we know.

[22:25] <pmichaud> or would it have to be   sub infix<abc>(Mu $a, Mu $b) is like-Whatever-and-stuff { ... }  ?

[22:25] <jnthn> pmichaud: afaik you'd need a signature that somewhere mentioned Whatever

[22:25] <pmichaud> (note that "like-Whatever-and-stuff" is what is written in S02)

[22:25] <jnthn> omg

[22:25] *** Khisanth joined
[22:25] <pmichaud> oh, we'd have to proto it.

[22:26] <jnthn> n operator can declare that it wants to

[22:26] <jnthn> handle C<*> either by declaring one or more of its arguments for at

[22:26] <jnthn> least one of its candidates with an argument of type C<Whatever>, or

[22:26] <jnthn> by marking the proto sub with the trait, C<is like-Whatever-and-stuff>.

[22:26] <pmichaud> Right.

[22:26] <pmichaud> that's the section.  :)

[22:26] <jnthn> :-)

[22:26] <jnthn> Yeah

[22:26] <jnthn> Things get easy on that on the (*sigh*) post-R* multi refactor. :-)

[22:27] <jnthn> Or at least, I'll do the multi compile time introspection enhancements at the same time I work on getting the new meaning of proto in place.

[22:27] <pmichaud> anyway, I'll let you work on it

[22:27] <jnthn> :-)

[22:27] <jnthn> I has selected a beer and am ready to hack. :-)

[22:28] <Eevee> wow, parrot's in ubuntu's universe repo

[22:30] <lue> So nice of them to invite us :)

[22:30] *** gbacon left
[22:34] <Eevee> maybe star will get rakudo in there  :(

[22:35] <diakopter> Ubuntu Silver Star ?

[22:35] <pmichaud> probably.  rakudo isn't quite yet stable enough

[22:35] *** elmex_ joined
[22:35] <diakopter> Ubuntu Spry Star ?

[22:35] <lue> Which one is that?

[22:35] <diakopter> the S one?

[22:35] *** elmex left
[22:35] <Eevee> haha, no, rakudo star

[22:35] *** elmex_ is now known as elmex

[22:36] <Eevee> rakudo★

[22:36] <lue> ahh, no I see what you're saying.

[22:36] <lue> s/no/know

[22:36] <lue> s/know/now/

[22:36] <lue> gah!

[22:37] <diakopter> .u hexa

[22:37] <phenny> U+4DCA HEXAGRAM FOR PEACE (䷊)

[22:37] <diakopter> .u spl

[22:37] <phenny> U+4DD6 HEXAGRAM FOR SPLITTING APART (䷖)

[22:37] <diakopter> my font doesn't have those

[22:38] <Eevee> mine does but they overflow slightly

[22:38] <lue> Mine fit just fine within the parens

[22:38] <arnsholt> On my OS X they overflow a bit on the right

[22:39] <lue> .u 

[22:39] <phenny> U+F8FF (No name found)

[22:39] <lue> Why does my keyboard let me type that? What is it?

[22:39] <Eevee> an apple

[22:39] <Eevee> it's actually the last glyph in the private use block

[22:39] <Eevee> which apple deemed should be a tiny apple logo

[22:39] <lue> Well that figures, it's the Apple fourth level I got that from :)

[22:40] <lue> .u E000

[22:40] <phenny> U+E000 (No name found)

[22:40] <lue> rakudo: say "\xE000"

[22:40] <p6eval> rakudo 475d1c: OUTPUT«␤»

[22:40] <Eevee> and that's the beginning

[22:40] <Eevee> yeah I don't have a glyph

[22:40] <lue> Anyone that has Linux Libertine can see uE000 :)

[22:40] <Eevee> hm, I seem to have a bunch of misc junk all throughout private use

[22:41] <Eevee>   U+E033 BUTTERFLY

[22:41] <lue> That's what it's for :) [0xE000 in Linux Libertine is Tux, the penguin]

[22:41] <Eevee> ha

[22:41] <lue> .u butter

[22:41] <phenny> lue: Sorry, no results for 'butter'.

[22:42] <lue> rakudo: say "\xE033"

[22:42] <p6eval> rakudo 475d1c: OUTPUT«␤»

[22:42] <Eevee> at this size it looks like an airplane with the nose missing

[22:42] <lue> I get an ffj glyph, just like fi (ﬁ) and fl (ﬂ)

[22:42] <lue> [for E033]

[22:43] <lue> rakudo: say "\x[$_]" for 0xE000..0xE010

[22:43] <p6eval> rakudo 475d1c: OUTPUT«Unrecognized backslash sequence: '\x' at line 11, near "[$_]\" for "␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[22:44] <lue> darn :)

[22:44] <Eevee> ha I don't think escapes work like that

[22:45] <Eevee> rakudo: say chr($_) for 0xe000..0xe010

[22:45] <p6eval> rakudo 475d1c: OUTPUT«␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤»

[22:46] <jnthn> rakudo: say "$_: &chr($_)" for  0xe000..0xe010;

[22:46] <p6eval> rakudo 475d1c: OUTPUT«57344: ␤57345: ␤57346: ␤57347: ␤57348: ␤57349: ␤57350: ␤57351: ␤57352: ␤57353: ␤57354: ␤57355: ␤57356: ␤57357: ␤57358: ␤57359: ␤57360: ␤»

[22:46] <lue> Apparently, Linux Libertine and Orbitron have provided some nice characters in the Private Use Area

[22:46] <lue> rakudo: say "{$_.fmt('%x')}: &chr($_)" for  0xe000..0xe010;

[22:46] <p6eval> rakudo 475d1c: OUTPUT«e000: ␤e001: ␤e002: ␤e003: ␤e004: ␤e005: ␤e006: ␤e007: ␤e008: ␤e009: ␤e00a: ␤e00b: ␤e00c: ␤e00d: ␤e00e: ␤e00f: ␤e010: ␤»

[22:46] <Eevee> I just have a bunch of diamonds, an arrow, a checkmark, and circled digits at the end

[22:47] <lue> E009 and E00A are cool W's from Orbitron

[22:47] <lue> sorry, E008 and E009

[22:48] <lue> rakudo: say "«{$_.fmt('%x')}: &chr($_)»" for  0xe000..0xe010;

[22:48] <p6eval> rakudo 475d1c: OUTPUT««e000: »␤«e001: »␤«e002: »␤«e003: »␤«e004: »␤«e005: »␤«e006: »␤«e007: »␤«e008: »␤«e009: »␤«e00a: »␤«e00b: »␤«e00c: »␤«e00d: »␤«e00e: »␤«e00f: »␤«e010: »␤»

[22:50] <lue> Is Pretty Print [colors, font weight, etc.] possible thru perl6? At least to the STDOUT in a console.

[22:51] <Eevee> rakudo: say [~] map 0xe000..0xe010: { "« {$_.fmt('%x')}: &chr($_) »" };

[22:51] <p6eval> rakudo 475d1c: OUTPUT«Confused at line 11, near "say [~] ma"␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[22:51] <Eevee> rakudo hurt itself in its confusion!

[22:52] <Eevee> rakudo: say [~] 0xe000..0xe010.map: { "« {$_.fmt('%x')}: &chr($_) »" };

[22:52] <p6eval> rakudo 475d1c: OUTPUT«␤»

[23:00] *** Psyche^ joined
[23:00] <cognominal> rakudo:  say (class A {} ).defined

[23:00] <p6eval> rakudo 475d1c: OUTPUT«1␤»

[23:01] <cognominal> rakudo:  class A {}   say ::A.defined

[23:01] <p6eval> rakudo 475d1c: OUTPUT«Confused at line 11, near "class A {}"␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[23:01] <cognominal> rakudo:  class A {};   say ::A.defined

[23:01] <p6eval> rakudo 475d1c: OUTPUT«0␤»

[23:01] <cognominal> beats me.

[23:02] <jnthn> rakudo:  class A {}   say A.defined

[23:02] <lue> rakudo: class ::A{}; say ::A.defined

[23:02] <p6eval> rakudo 475d1c: OUTPUT«Confused at line 11, near "class A {}"␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[23:02] <p6eval> rakudo 475d1c: OUTPUT«0␤»

[23:02] <jnthn> std: class A {}   say ::A.defined

[23:02] <p6eval> std 30825: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/2opAbO3d0N line 1:␤------> [32mclass A {}[33m⏏[31m   say ::A.defined[0m␤    expecting any of:␤ bracketed infix␤  infix or meta-infix␤      statement modifier loop␤Parse

[23:02] <p6eval> ..failed␤…

[23:03] <jnthn> Oddness.

[23:03] *** Patterner left
[23:03] *** Psyche^ is now known as Patterner

[23:03] <jnthn> std: class A {}   say A.defined

[23:03] <p6eval> std 30825: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/NpoVdMhlmE line 1:␤------> [32mclass A {}[33m⏏[31m   say A.defined[0m␤    expecting any of:␤   bracketed infix␤  infix or meta-infix␤      statement modifier loop␤Parse

[23:03] <p6eval> ..failed␤FA…

[23:03] <jnthn> std: class A {};   say A.defined

[23:03] <p6eval> std 30825: OUTPUT«ok 00:01 111m␤»

[23:03] <jnthn> std: class A {};   say ::A.defined

[23:03] <p6eval> std 30825: OUTPUT«ok 00:01 111m␤»

[23:03] <jnthn> rakudo: class A {};   say ::A.defined

[23:03] <p6eval> rakudo 475d1c: OUTPUT«0␤»

[23:03] <jnthn> ETOOLIBERAL

[23:04] <jnthn> yay

[23:04] <jnthn> > say (1 + *).WHAT

[23:04] <jnthn> Block()

[23:04] <jnthn> > say (1 + *).(2)

[23:04] <jnthn> 3

[23:04] <jnthn> > say (* + *).(2, 4)

[23:04] <jnthn> 6

[23:04] <jnthn> > say (1..*).WHAT

[23:04] <jnthn> Range()

[23:06] <pmichaud> wow

[23:07] <pmichaud> afk, dinner

[23:07] <lue> rakudo: my $a = 3; say 1+$a; say (1+*).($a)

[23:07] <p6eval> rakudo 475d1c: OUTPUT«4␤4␤»

[23:08] <cognominal> rakduo: say (* * *).(*,*)

[23:08] <cognominal> rakudo: say (* * *).(*,*)

[23:08] <p6eval> rakudo 475d1c: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[23:10] <lue> rakudo: say (* *).(3,++)

[23:10] <p6eval> rakudo 475d1c: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1971 (ext/nqp-rx/src/stage0/Regex-s0.pir:1050)␤»

[23:11] <jnthn> rakudo: say (* * *).(2,4)

[23:11] <p6eval> rakudo 475d1c: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[23:11] <jnthn> That one works now.

[23:11] <jnthn> > say (* * *).(2,4)

[23:11] <jnthn> 8

[23:12] <Eevee> rakudo: say (*.*).(3, postfix:sym<!>)

[23:12] <p6eval> rakudo 475d1c: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1971 (ext/nqp-rx/src/stage0/Regex-s0.pir:1050)␤»

[23:12] *** jhuni left
[23:12] <jnthn> The parser won't accept *all* line noise. ;-)

[23:12] <cognominal> :)

[23:14] *** jhuni joined
[23:17] <lue> rakudo: say (*,*).(3, postfix:sym<!>)

[23:17] <p6eval> rakudo 475d1c: OUTPUT«Could not find sub &postfix:sym<!>␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[23:17] <lue> rakudo: say (*,*).(3, !)

[23:17] <p6eval> rakudo 475d1c: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1971 (ext/nqp-rx/src/stage0/Regex-s0.pir:1050)␤»

[23:17] <lue> rakudo: say (*,*).(3, "&!")

[23:17] <p6eval> rakudo 475d1c: OUTPUT«invoke() not implemented in class 'ResizablePMCArray'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[23:18] <lue> std: say (*,*).(3, "&!")

[23:18] <p6eval> std 30825: OUTPUT«ok 00:01 114m␤»

[23:18] <jnthn> Works on user defined opps too :-)

[23:18] <jnthn> > our multi postfix:<!>(0) { 1 }; our multi postfix:<!>($n) { $n * ($n - 1)! }

[23:18] <jnthn> > my $fact = *!; say $fact.WHAT; say $fact(10);

[23:18] <jnthn> Block()

[23:18] <jnthn> 3628800

[23:22] <lue> rakudo: our multi infix:<+>($a is rw,$b){$a++ for ^$b;}; our multi postfix:<++>($a is rw){$a + 1;}; my $a = 3; say $a++; say $a+3

[23:22] <p6eval> rakudo 475d1c: OUTPUT«Method 'set_candidates' not found for invocant of class 'MultiSub'␤current instr.: '' pc -1 ((unknown file):-1)␤»

[23:22] <lue> ō.o Last time it was infinite recursion

[23:22] *** Ross^ left
[23:23] <jnthn> rakudo: our multi infix:<+>($a is rw,$b){$a++ for ^$b;};

[23:23] <p6eval> rakudo 475d1c:  ( no output )

[23:23] <jnthn> rakudo: our multi postfix:<++>($a is rw){$a + 1;};

[23:23] <p6eval> rakudo 475d1c: OUTPUT«Method 'set_candidates' not found for invocant of class 'MultiSub'␤current instr.: '' pc -1 ((unknown file):-1)␤»

[23:24] <jnthn> Evidentaly postfix:<++> didn't make it into the setting yet.

[23:24] <lue> rakudo: our multi infix:<+>($a is rw,$b){$a++ for ^$b;}; our multi sub postfix:<++>($a is rw){$a + 1;}; my $a = 3; say $a++; say $a+3

[23:25] <p6eval> rakudo 475d1c: OUTPUT«Method 'set_candidates' not found for invocant of class 'MultiSub'␤current instr.: '' pc -1 ((unknown file):-1)␤»

[23:25] *** sorear joined
[23:25] <lue> It worked last time...

[23:25] <pugssvn> r30826 | sorear++ | [viv] Refactor emit_p5 using an augment/inner paradigm.  -2500 characters. 

[23:25] <pugssvn> r30826 | ret and $lvl are no more.

[23:26] <lue> rakudo: say "\xE020"

[23:26] <p6eval> rakudo 475d1c: OUTPUT«␤»

[23:28] <lue> Why do we use ICU? What does it give us that we use? [just curious]

[23:28] <jnthn> lue: A bunch of unicode stuff.

[23:28] <jnthn> lue: Like character properties, etc.

[23:29] <lue> I thought we really only used it for character tables.

[23:30] <lue> I was thinking of whether it would be feasible to "remove" that dependancy [I've heard about doing that before, IIRC]

[23:30] <pugssvn> r30827 | sorear++ | [viv] Finish translation of <foo(bar)> 

[23:30] <sorear> lue: Why?

[23:30] <sorear> Repeat after me.

[23:30] <sorear> Dependencies are Good.

[23:31] <lue> Not like I was going to do it, I was just wondering.

[23:31] *** demond joined
[23:34] <diakopter> sorear: r30826 !!?!??! :D

[23:34] <diakopter> just from reading the commit message, I suspect this will make me willing/able to work on it now!

[23:47] *** snarkyboojum joined
[23:53] <diakopter> phenny: tell pmurias I looked at http://paste.lisp.org/display/100307 and it doesn't work just b/c of the non-working expression parser - my $poss = self.positionals; $poss.Add($pos); # works

[23:53] <phenny> diakopter: I'll pass that on when pmurias is around.

[23:55] *** patspam left
[23:56] *** justatheory left
[23:56] <sorear> std: method foo ($x) ($y) is rw ($z) { }

[23:56] <p6eval> std 30826: OUTPUT«ok 00:01 115m␤»

[23:57] <sorear> TimToady: what does that mean?

[23:58] <jnthn> .oO( 2 sigs, 1 sub )

[23:58] <Eevee> whoa

[23:58] <sorear> 3 sigs, mixed in with a trait

[23:58] <jnthn> Stop spoiling my meme references with accuracy. :P

[23:59] <jnthn> sorear: Somewhere in S12 there's some conjectural syntax relating to being able to give a single multi candidate multiple signatures.

[23:59] <jnthn> sorear: I suspect it's that.

