[00:00] <jnthn> Incomplete

[00:00] <cxreg> ok cool

[00:00] <jnthn> pmichaud++ is hacking on it ATM though. :-)

[00:00] <jnthn> It should be in decent shape by the time R* lands.

[00:00] <cxreg> are Atlanta and * different releases?

[00:00] <jnthn> Yes

[00:01] <jnthn> Atlanta is just the normal boringly regular compiler release.

[00:01] <jnthn> * will be a distribution release.

[00:01] <jnthn> (e.g. compiler + module installation tools + some modules)

[00:01] <cxreg> right on

[00:02] <cxreg> i've been preaching it to a lot of people recently who've lost the thread a few years ago

[00:02] <[Coke]> jnthn: why are you speaking bulgarian now?

[00:02] <dalek> rakudo: 4ae2183 | jonathan++ | src/core/Cool-str.pm:

[00:02] <dalek> rakudo: Fix dodgy split signatures.

[00:02] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4ae21830e04e1383dc8e61706d254d737510ee27

[00:02] <dalek> rakudo: 4578afc | jonathan++ | src/pmc/ (8 files):

[00:02] <dalek> rakudo: Apply patch from cognominal++ to remove now unrequired need_ext from our PMCs.

[00:02] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4578afcd1eba9c55f00cc13b59d7d8920359e163

[00:02] <dalek> rakudo: 5e6fa97 | jonathan++ | src/metamodel/ClassHOW.pir:

[00:02] <dalek> rakudo: Add a (most likely accidentally) missing :load, which gets perl6.pbc loadable 

[00:02] <dalek> rakudo: again without running it. Patch courtesy of dukeleto++.

[00:02] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5e6fa97c03ccc48e1d2f7621551e9920e26c5907

[00:02] <[Coke]> (or is that just something in the same vicinity?)

[00:02] <jnthn> [Coke]: I didn't do it on purpose. :-P

[00:02] <jnthn> [Coke]: It was Slovak - I didn't know it was the same in Bulgarian. :-)

[00:02] <jnthn> [Coke]: Works in most Slavic languages I guess.

[00:03] <[Coke]> da.

[00:03] <jnthn> That sure doesn't work in all of them. :-)

[00:05] <dukeleto> jnthn: should I try to make a test that verifies that perl6.pbc is loadable ?

[00:05] <[Coke]> Opa

[00:06] <jnthn> dukeleto: Could be good - I'm just wondering where we'd put it though.

[00:06] <jnthn> It doesn't belong in spectest.

[00:06] <jnthn> Oh, I guess it could go in as part of "make test"

[00:06] <jnthn> PIR files surely can be run in that too.

[00:06] <dukeleto> jnthn: yes, that is what I was thinking

[00:06] <jnthn> OK, +1

[00:06] <dukeleto> jnthn: i could use Q:PIR or plain PIR

[00:06] <dukeleto> jnthn: cool

[00:07] <jnthn> dukeleto: If you use Q:PIR you're already in Perl 6 though. ;-)

[00:07] <jnthn> So perl6.pbc is already loaded. ;-)

[00:07] <dukeleto> jnthn: duh :)

[00:07] <dukeleto> jnthn: so yes, a PIR test file is needed

[00:07] <jnthn> Aye

[00:08] <dukeleto> jnthn: any specific dir in t/ that I should put it in?

[00:08] <jnthn> Hmm

[00:08] <jnthn> Good question.

[00:08] <dukeleto> jnthn: in 00-parrot or 01-sanity ?

[00:09] *** patspam left
[00:09] <dukeleto> jnthn: or in a new dir?

[00:09] <jnthn> Yeah, I think a new one

[00:09] <jnthn> Since the other two contain Perl 6 sanity tests.

[00:09] <jnthn> Struggling to think of a good name.

[00:10] <jnthn> interop maybe

[00:11] <dukeleto> jnthn: interop is a nice word, or maybe embed

[00:11] <jnthn> Yeah, embed works too

[00:11] <dukeleto> jnthn: i first ran into this issue via embedding Parrot in C and trying to load perl6.pbc

[00:12] <dukeleto> jnthn: ok, i will whip up a test after going for run. thanks for pushing that :load fix so quickly! jnthn++

[00:13] <jnthn> Thanks for debugging it.

[00:13] <jnthn> What are you embedding it in, out of interest?

[00:15] <dukeleto> jnthn: i hack on PL/Parrot, which embeds Parrot in PostgreSQL

[00:15] <jnthn> Ah, cool.

[00:15] <dukeleto> jnthn: so you can write stored procedures in PIR or any language Parrot can grok

[00:15] <jnthn> So it'd enable writing...stored procs in Perl 6?

[00:15] <dukeleto> jnthn: indeed

[00:15] <jnthn> Aha. :-)

[00:15] *** lestrrat is now known as lest_away

[00:16] <dukeleto> jnthn: PL/PIR works, so now I am trying to get Rakudo playing nicely with it

[00:16] <jnthn> It'd be cool to see an example of it, once you get it working. :-)

[00:16] <dukeleto> jnthn: the bytecode actually loads now! 

[00:16] <jnthn> That's a good step forward. :-)

[00:17] <jnthn> Beyond that in theory it's just compreg 'perl6' to get the compiler object.

[00:17] <dukeleto> jnthn: http://github.com/leto/plparrot

[00:17] <jnthn> And .eval on that.

[00:17] <dukeleto> jnthn: i am working in the plperl6 branch

[00:18] <dukeleto> jnthn: yes, now I have some postgres-specific hacking to do, and some stub Rakudo code to wrap around what the source of the stored procedure is

[00:18] <jnthn> Any code base that has a function named make_sausage must be awesome.

[00:19] <jnthn> elog(NOTICE,"CANNOT MAKE SAUSAGE"); # :-D

[00:19] <dukeleto> jnthn: :) I figured out a bit of undocumented knowledge after a long night of hacking, and that is reflected in some of my function names and error messages ;)

[00:20] *** lue joined
[00:20] <jnthn> -Ofun :-)

[00:20] <lue> ohai world

[00:20] <dukeleto> jnthn: "making sausage" =~ data marshalling between Postgres datatypes and parrot datatypes

[00:20] <lue> (where did the ofun come from?)

[00:20] <dukeleto> jnthn: yes, this project is -Ofun

[00:20] <jnthn> lue: My keyboard.

[00:20] <dukeleto> lue: i believe a blog post by AudreyT

[00:21] <jnthn> Yes, originally :-)

[00:21] <jnthn> Certainly it was coined by audreyt

[00:22] * dukeleto goes for a -Ofun run

[00:24] *** masonkramer joined
[00:25] <cognominal> so the official release after rakudo star  will be fun rakudo?

[00:25] <lue> no, I meant WHY :)

[00:25] *** xomas left
[00:25] *** zorgnax left
[00:26] <lue> .oO(-ORakudo)

[00:26] <cognominal> I would also see rakudo imago meaning the puppa has at last became a butterfly.

[00:26] <cognominal> with hopefully a longer life tan a butterfly.

[00:28] <jnthn> cognominal: Heh, after Rakudo * it's time to break everything again. ;-)

[00:28] <jnthn> (No, not really. :-))

[00:28] <Wolfman2000> ...I was about to say jnthn 

[00:29] <jnthn> Well, it will be time to dig in and start on the next big chunk of features.

[00:29] <lue> I thought that was a given :D

[00:29] <Wolfman2000> what is left to implement with Perl 6 anyway?

[00:29] <jnthn> Wolfman2000: S09 is largely unimplemented in Rakudo at the moment.

[00:29] <cognominal> I want :=

[00:30] <cognominal> I don't dig why it is in nqp and not in rakudo...

[00:30] <cognominal> binding arguments to parameters is:= substance...

[00:30] <Wolfman2000> large unimplemented...data structures?

[00:30] <lue> Me too. I need it for my project.

[00:30] <jnthn> cognominal: At least somewhat because in NQP we don't have to make it live alongside assignment.

[00:30] <Wolfman2000> could have thought those worked

[00:31] *** yinyin joined
[00:31] <jnthn> Wolfman2000: Well, more the native types stuff.

[00:31] *** masonkramer left
[00:31] <jnthn> Wolfman2000: It's partly an efficiency thing too.

[00:31] *** masonkramer joined
[00:31] <cognominal> jnthn++  # thx for the explanation.

[00:31] <cognominal> We will have := for rakudo * ?

[00:31] <cognominal> I hope.

[00:32] <lue> rakudo: my @a = [1,2,3,0,0,0]; @a[3..5] := @a[0..2]; @a[4] = 9; say @a

[00:32] <p6eval> rakudo 4df508: OUTPUT«:= binding of variables not yet implemented␤  in 'infix:<:=>' at line 630:CORE.setting␤  in main program body at line 11:/tmp/kMc22qp8kR␤»

[00:32] <jnthn> cognominal: A long story short though, we can't just implement := in Rakudo by compiling it down to the same thing we do in NQP and expect it to work.

[00:32] <Wolfman2000> and range operator setting...alright, point

[00:32] <lue> If only you could set the WHERE of a variable...

[00:32] <jnthn> That said...

[00:32] <lue> rakudo: my $a = 3; say $a.WHERE

[00:32] <p6eval> rakudo 4df508: OUTPUT«57526864␤»

[00:33] <jnthn> rakudo: my $a = 1; my ($b is rw) := $a; $b = 2; say $a;

[00:33] <p6eval> rakudo 4df508: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Code $block, Any $arg?, Any :export($export)!)␤:(Mu $child, Mu $parent)␤␤  in main program body at line 11:/tmp/kSWBifuFoD␤»

[00:33] <jnthn> Aww

[00:33] <Wolfman2000> ...reminder. Does Perl 6 have a native bool type yet?

[00:33] <jnthn> Wolfman2000: Depends what you mean by "native" but there is a Bool type.

[00:33] <jnthn> rakudo: say True.WHAT

[00:33] <p6eval> rakudo 4df508: OUTPUT«Bool()␤»

[00:34] <Wolfman2000> ...why not just typedef it to int1 or something?

[00:34] <jnthn> Wolfman2000: Well, because we don't have int1 yet. :-)

[00:34] <jnthn> Wolfman2000: That's in with the S09 stuff I mentioned.

[00:34] <cognominal> Wolfman2000, all value are boxed so far.

[00:34] <jnthn> cognominal: Yes, good explanation.

[00:34] <jnthn> :-)

[00:35] <jnthn> rakudo: my $a = 1; my ($b) := $a; $b = 2; say $a;

[00:35] <p6eval> rakudo 4df508: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/SzMS2fT17z␤»

[00:35] <jnthn> Hmm

[00:35] <cognominal> anyway unboxed values would not buy as much as expected because we don't have JIT working.

[00:35] <jnthn> cognominal: Yeah, that's unfortunately true.

[00:36] <cognominal> in as sense a shortcoming is a consolation for another :)

[00:36] <pmichaud> good evening

[00:36] <lue> ohai pmichaud o/

[00:37] <Wolfman2000> Hmm...do modifier adverbs work yet?

[00:37] *** k23z__ left
[00:37] <jnthn> evening, pmichaud 

[00:39] <cognominal> I note that jnthn did not say anything about := and rakudo *  :)

[00:40] <cognominal> dodging my question?  :)

[00:40] <jnthn> huh? what question?

[00:40] <jnthn> ;-)

[00:40] <jnthn> cognominal: We may well get it but it's below getting lists and closures fixed up.

[00:40] <pmichaud> := should be available for R*, yes.

[00:40] <jnthn> Ah, cool. pmichaud++ :-)

[00:40] <pmichaud> the reason that := is harder in Rakudo than in NQP is because we have typed containers and read-only things in Rakudo

[00:41] <pmichaud> NQP doesn't have typed containers to deal with

[00:41] <pmichaud> and yes, assignment makes things tricky as well.  NQP doesn't have assignment (largely for this reason)

[00:41] <jnthn> rakudo: my $a = 1; my ($b is rw) := $a;

[00:41] <p6eval> rakudo 4df508: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Code $block, Any $arg?, Any :export($export)!)␤:(Mu $child, Mu $parent)␤␤  in main program body at line 11:/tmp/tM8LgBuSY_␤»

[00:41] <lue> Where in the bowels of Rakudo is variable intialization done? If you just manipulate things there [or make WHERE writable]...

[00:41] <jnthn> :-/

[00:41] <cognominal> I don't mind  rakudo * to be late, but I want it to be reasonnably commplete.

[00:41] <pmichaud> cognominal: we're not aiming for "complete".  "Complete" is still a myth, like "finished".

[00:41] <pmichaud> We're aiming for useful.

[00:42] <jnthn> rakudo: my $a = 1; my ($b is wtf) := $a;

[00:42] <p6eval> rakudo 4df508: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Code $block, Any $arg?, Any :export($export)!)␤:(Mu $child, Mu $parent)␤␤  in main program body at line 11:/tmp/JxbCzgZXbu␤»

[00:42] <jnthn> Oh, hm.

[00:42] <cognominal> I even seen that metadata works better with regexp or matches lately, or am I dreaming already?  It is late here.

[00:42] <pmichaud> yes, we made quite a few regex and match improvements

[00:42] <cognominal> pmichaud++

[00:45] <cognominal> I mean Rakudo * don't need to be complete, just to be good enough to compete...

[00:45] <cognominal> ...productivity-wise. Performance will come late.

[00:45] <pmichaud> right now we're aiming for "good enough to be useful for at least some people."

[00:46] <pmichaud> we're still a long way away from being able to claim that it can compete with any other language in a larger marketplace

[00:46] <pmichaud> (well, maybe not so long.  But not close.)

[00:47] *** Util left
[00:47] <lue> [ It'd be nice to have a few modules ready w/ R* :) ]

[00:48] <pmichaud> lue: I think we'll have some, yes.  Perhaps not a large set... but that's what R*+1 will be for :-)

[00:48] <cognominal> I am of the happy few who likes to play with grammars that start to be reasonably "complete"

[00:49] <lue> (CRAM - Comprehensive Rakudo Archive of Modules)

[00:49] <cognominal> And I don't see anything that comes close to it packaged in a neat package except maybe in haskell.

[00:49] <cognominal> And in fact in haskell I don't think it is in the core.

[00:49] <cognominal> lue++

[00:52] <lue> I'm OK with a Perl6 folder on CPAN, but something about it.... [it's probably just me]

[00:53] <sorear> the Haskell core has a parser engine considerably more powerful than Perl6 rules

[00:53] <sorear> however, it's... broken by design from a performance standpoint

[00:53] <jnthn> rakudo: my $a = 1; my ($b) := $a; say $b; $a = 2; say $b;

[00:53] <p6eval> rakudo 5e6fa9: OUTPUT«1␤2␤»

[00:53] <cognominal> sorear, can you be more specific

[00:53] <sorear> so it rarely gets used

[00:53] <jnthn> hehe

[00:53] <sorear> cognominal: O(way too much)

[00:53] <sorear> not n

[00:54] <cognominal> :_

[00:54] <cognominal> :)

[00:54] <cognominal> O(exponential), O(ballistic)?

[00:55] <sorear> it's actually a lot like the perl 6 framework.  just, without cuts

[00:55] <cognominal> well cuts are yet to be implemented...

[00:56] <sorear> NQP has a lot of cutting in it already

[00:56] <pmichaud> cuts were implemented in PGE, just haven't put them into nqp-rx.  Largely because I haven't needed them yet.

[00:56] <sorear> also, it's coupled to the haskell string format.  which is jaw-dropping fail all by itself

[00:56] <pmichaud> the framework is in place to implement cuts.

[00:56] <cognominal> cool

[00:56] <sorear> pmichaud: token backtracks in nqp-rx!?!?!?

[00:57] <sorear> I'm suprised you can parse a 6000 line file in less than a day

[00:57] <pmichaud> sorear: no, it doesn't.

[00:57] <cognominal> strings are list sin haskell, are'nt they?

[00:57] <pmichaud> I mean the ::, :::, and <commit> sorts of cuts

[00:57] *** azert0x left
[00:57] <lue> nomming time. afk

[00:57] <pmichaud> racheting is definitely implemented in nqp-rx, as is the simple : quantifier

[00:58] <sorear> Haskell's Read doesn't even have : cuts.

[00:58] <sorear> cognominal: yes.  linked lists of fullword integers.

[00:58] <cognominal> shudders

[01:01] <[Coke]> can the pir::opcode syntax use keys?

[01:01] <sorear> no

[01:02] *** lest_away is now known as lestrrat

[01:05] <pmichaud> [Coke]: not yet.

[01:06] <pmichaud> PIR's key syntax is a bit of a pain for code generation

[01:08] <pmichaud> [Coke]: what form of key are you looking for... the   ['ABC';'DEF']  form to identify namespaces/classes, or the   $P0]key]  form for indexing an aggregate?

[01:08] <pmichaud> (or both?)

[01:11] *** whiteknight left
[01:14] *** mikehh left
[01:17] <sorear> or the ['foo';'bar'] form for instantiating a PMC?  because that's easier than you think

[01:20] <pmichaud> *$P0[key]  # wrong bracket

[01:26] *** meppl left
[01:27] *** ggoebel left
[01:28] <jnthn> > my $a = 1; my ($b is rw) := $a; $b = 42; say $a;

[01:28] <jnthn> 42

[01:28] <jnthn> But I gotta sleep now.

[01:28] <jnthn> night o/

[01:28] <colomon> \o

[01:29] *** rgrau_ left
[01:35] <cxreg> how does a function instrospect itself without knowing its name or having a ref to itself?

[01:36] <cxreg> or for that matter, any block

[01:37] <sorear> > say &?BLOCK.arity

[01:37] <sorear> perl6: say &?BLOCK.arity

[01:37] <p6eval> pugs: OUTPUT«1␤»

[01:37] <p6eval> ..rakudo 5e6fa9: OUTPUT«Could not find sub &?BLOCK␤  in main program body at line 11:/tmp/4vzBLlRYn8␤»

[01:37] <p6eval> ..elf 31183: OUTPUT«/home/p6eval/pugs/misc/STD_red/match.rb:141:in `block in to_dump0': undefined method `to_dump0' for true:TrueClass (NoMethodError)␤    from /home/p6eval/pugs/misc/STD_red/match.rb:140:in `each'␤       from /home/p6eval/pugs/misc/STD_red/match.rb:140:in `map'␤        from

[01:37] <p6eval> ../home/p6eval/pugs/misc/STD…

[01:38] <sorear> pugs: say &?BLOCK.arity

[01:38] <p6eval> pugs: OUTPUT«1␤»

[01:38] <sorear> hmm, is elf broken?

[01:38] <sorear> elf: say "hi"

[01:38] <p6eval> elf 31183: OUTPUT«hi␤»

[01:38] <cxreg> &?BLOCK, eh?

[01:41] <lue> jnthn: that's exciting!

[01:58] <[Coke]> (key syntax) no matter, email sent to compiler lsit.

[02:03] *** lue left
[02:03] *** cognomore left
[02:04] *** cognomore joined
[02:05] <cxreg> does that mean jnthn just got aliasing working?

[02:06] *** ggoebel joined
[02:07] <sorear> not necessarily

[02:07] <sorear> rakudo: my $a; my ($b is rw) := $a; $a = 3; say $b;

[02:07] <p6eval> rakudo 5e6fa9: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Code $block, Any $arg?, Any :export($export)!)␤:(Mu $child, Mu $parent)␤␤  in main program body at line 11:/tmp/Phonc7PprM␤»

[02:08] <sorear> it would seem that he got traits in random signatures working correctly

[02:08] *** ggoebel left
[02:16] *** lue joined
[02:16] *** TiMBuS joined
[02:17] *** cls_bsd_ is now known as cls_bsd

[02:20] *** szabgabx_ joined
[02:20] *** ruoso left
[02:24] *** szabgabx left
[02:29] <colomon> alpha: say (^*).WHAT

[02:29] <p6eval> alpha 30e0ed: OUTPUT«!whatever_closure␤»

[02:29] <colomon> alpha: say (0..*).WHAT

[02:29] <p6eval> alpha 30e0ed: OUTPUT«!whatever_closure␤»

[02:30] <colomon> okay, so not the best example there.  :(

[02:31] <lue> what is the difference between a module and a package?

[02:31] <justatheory> I like reading "say what!"

[02:32] <lue> rakudo: say (^*).WHAT; say (0..*).WHAT

[02:32] <p6eval> rakudo 5e6fa9: OUTPUT«Block()␤Range()␤»

[02:33] <lue> The spec only says a module "has extra behaviors", but it won't elaborate :/

[02:33] *** yinyin left
[02:34] <colomon> lue: I know not to trust what master does for ^*, because I know who wrote that code.  ;)

[02:34] <lue> :)

[02:36] *** yinyin joined
[02:37] <lue> I want to write a module that proto will be able to install. I just don't know if I should go w/ package or module...

[02:42] <arnsholt> I'd go with class =)

[02:43] <lue> I just discovered my module idea already exists in proto :O [it was ANSI coloring]

[02:44] *** [mark] joined
[02:46] *** Guest4174 left
[02:47] *** gbacon joined
[02:50] <colomon> rakudo: say 'a' cmp Inf

[02:50] <p6eval> rakudo 5e6fa9: OUTPUT«1␤»

[02:50] <colomon> rakudo: say 'a' cmp -Inf

[02:50] <p6eval> rakudo 5e6fa9: OUTPUT«1␤»

[02:52] *** gbacon left
[02:52] <lue> rakudo: say Inf ~~ NaN

[02:52] <p6eval> rakudo 5e6fa9: OUTPUT«0␤»

[02:54] <lue> Shouldn't that be 1 ?

[03:00] <lue> rakudo: say Inf !~ NaN

[03:00] <p6eval> rakudo 5e6fa9: OUTPUT«===SORRY!===␤Unsupported use of !~ to do negated pattern matching; in Perl 6 please use !~~ at line 11, near "NaN"␤»

[03:00] <lue> rakudo: say Inf !~~ NaN

[03:00] <p6eval> rakudo 5e6fa9: OUTPUT«1␤»

[03:02] *** tylerni7 left
[03:02] *** ShaneC left
[03:04] *** plobsing joined
[03:05] *** Chillance left
[03:18] *** tootroot left
[03:20] *** tootroot joined
[03:20] *** jaldhar joined
[03:21] *** mtnviewmark joined
[03:21] *** skids left
[03:22] *** mberends left
[03:22] *** mtnviewmark left
[03:22] *** mtnviewmark_ joined
[03:24] <lue> Are there any sort of modules you'd like to see? I want to start on my NES emulator, but until := works, that's not feasible.

[03:25] *** mjk joined
[03:25] <lue> [I'd like to test if the code is working; I could of course write it now if I wanted to go w/o testing it]

[03:25] *** mjk left
[03:26] *** tylerni7 joined
[03:26] *** tylerni7 left
[03:26] *** tylerni7 joined
[03:27] *** jaldhar left
[03:28] *** jaldhar joined
[03:32] *** tedv left
[03:32] *** JimmyZ joined
[03:33] <JimmyZ> lue: write  NES emulator by using rakudo?

[03:35] <lue> Using P6. I was using Python, but the lack of references (or := binding in P6) and switch statements (given/when in P6) caused me to switch.

[03:35] *** mikehh joined
[03:35] <lue> I know full well it'd take forever to create the whole thing.

[03:38] <JimmyZ> lue: http://irclog.perlgeek.de/perl6/2010-06-09#i_2416485

[03:38] <JimmyZ> lue: oh, you know it.

[03:39] <lue> :) I started trying to fix it once, my idea being to set the variable's WHERE at its initialization.

[03:39] <lue> Obviously, it didn't even git started. :)

[03:40] *** jaldhar left
[03:41] *** jaldhar joined
[03:41] <lue> [cant wait for Diaspora at the end of summer!]

[03:42] *** stephenlb left
[03:44] *** mberends joined
[03:46] *** jaldhar left
[03:46] *** _jaldhar joined
[03:47] <lue> afk

[03:58] *** ShaneC joined
[04:03] *** JimmyZ left
[04:10] *** ShaneC left
[04:18] *** mtnviewmark_ left
[04:29] *** k23z__ joined
[04:29] *** k23z__ left
[04:32] *** satyavvd joined
[04:35] *** ciphertext left
[04:37] *** Khisanth left
[04:45] *** _jaldhar left
[04:46] *** _jaldhar joined
[04:51] *** dakkar joined
[04:53] *** Khisanth joined
[04:59] *** jaldhar_ joined
[04:59] *** _jaldhar left
[05:00] *** BRAD_ joined
[05:00] *** BRAD_ left
[05:12] *** hirschnase joined
[05:29] *** hirschnase left
[05:30] *** snarkyboojum joined
[05:32] <snarkyboojum> dobar dan #perl6

[05:40] *** orafu left
[05:42] *** orafu joined
[05:47] <moritz_> good morning

[05:51] *** gfx joined
[05:52] <dalek> book: 54a4228 | util++ | src/subs-n-sigs.pod:

[05:52] <dalek> book: [subs] Fixed "order-burger" code example

[05:52] <dalek> book: Concatenation op (~) has tighter precedence than Conditional op (??!!)

[05:52] <dalek> book: review: http://github.com/perl6/book/commit/54a422885549cea991f19935836fd6b8af2e780c

[05:52] <moritz_> ./perl6 -e 'sub MAIN($x, $y) { say $x + $y }' 42 23

[05:52] <moritz_> 65

[05:53] <moritz_> ./perl6 -e 'sub MAIN($x) { say $x  }' 42 23

[05:53] <moritz_> Too many positional parameters passed; got 2 but expected 1 in 'MAIN' at line 1 in 'MAIN_HELPER' at line 5816:CORE.setting in main program body at line 1

[05:53] <eternaleye> \o/

[05:53] *** snarkyboojum left
[05:56] *** snarkyboojum joined
[05:58] *** Wolfman2000 left
[06:00] *** dju left
[06:00] *** dju joined
[06:03] *** uniejo joined
[06:04] *** lestrrat is now known as lest_away

[06:05] *** uniejo left
[06:17] *** szabgabx_ left
[06:19] *** uniejo joined
[06:23] *** Su-Shee joined
[06:27] *** kaare joined
[06:27] *** kaare is now known as Guest99340

[06:33] *** Ross joined
[06:37] *** mberends left
[06:38] *** mberends joined
[06:41] *** lest_away is now known as lestrrat

[06:41] *** lestrrat is now known as lest_away

[06:41] *** lest_away is now known as lestrrat

[06:52] *** jaldhar_ left
[06:52] *** jaldhar_ joined
[06:58] *** hirschnase joined
[06:58] *** hirschnase left
[07:00] *** hirschnase joined
[07:04] <moritz_> problem is, my patch breaks spectest horribly

[07:04] <moritz_> because now eval() doesn't return the value of its last statement anymore

[07:05] <moritz_> but really the return value of MAIN_HELPER

[07:07] <moritz_> so I really need to surpress injection of MAIN_HELPER inside an eval :(

[07:09] *** mberends left
[07:09] <moritz_> rakudo: say 1

[07:09] <p6eval> rakudo 5e6fa9: OUTPUT«1␤»

[07:11] <moritz_> rakudo: sub f { say Q:PIR { $P0 = getinerp␤ %r = $P0['caller';1] }; }; f()

[07:11] <p6eval> rakudo 5e6fa9: OUTPUT«error:imcc:syntax error, unexpected '\n', expecting '('␤   in file 'EVAL_1' line 23976656␤===SORRY!===␤syntax error ... somewhere␤»

[07:16] <eternaleye> moritz_: getinerp vs getinterp

[07:17] <eternaleye> sub f { say Q:PIR { $P0 = getinterp␤ %r = $P0['caller';1] }; }; f()

[07:17] <eternaleye> rakudo: sub f { say Q:PIR { $P0 = getinterp␤ %r = $P0['caller';1] }; }; f()

[07:17] <p6eval> rakudo 5e6fa9: OUTPUT«No such item caller␤  in 'f' at line 11:/tmp/a_f9nSC6nN␤  in main program body at line 12:/tmp/a_f9nSC6nN␤»

[07:17] <moritz_> should probably be 'context'

[07:17] <moritz_> not caller

[07:17] <eternaleye> rakudo: sub f { say Q:PIR { $P0 = getinterp␤ %r = $P0['context';1] }; }; f()

[07:17] <moritz_> anyway, not sure if that solves my problem

[07:17] <p6eval> rakudo 5e6fa9: OUTPUT«␤»

[07:23] *** baest joined
[07:26] *** snarkyboojum left
[07:33] <moritz_> rakudo: rakudo: sub f { say Q:PIR { $P0 = getinterp␤ %r = $P0['sub';1] }; }; f()

[07:33] <p6eval> rakudo 5e6fa9: OUTPUT«===SORRY!===␤Confused at line 11, near "rakudo: su"␤»

[07:34] <moritz_> rakudo: sub f { say Q:PIR { $P0 = getinterp␤ %r = $P0['sub';1] }; }; f()

[07:34] <p6eval> rakudo 5e6fa9: OUTPUT«_block14␤»

[07:34] <moritz_> rakudo: sub f { say Q:PIR { $P0 = getinterp␤ %r = $P0['sub';0] }; }; f()

[07:34] <p6eval> rakudo 5e6fa9: OUTPUT«f␤»

[07:34] <moritz_> rakudo: sub f { say Q:PIR { $P0 = getinterp␤ %r = $P0['sub';2] }; }; f()

[07:34] <p6eval> rakudo 5e6fa9: OUTPUT«!YOU_ARE_HERE␤»

[07:34] <moritz_> rakudo: sub f { say Q:PIR { $P0 = getinterp␤ %r = $P0['sub';3] }; }; f()

[07:34] <p6eval> rakudo 5e6fa9: OUTPUT«!UNIT_START␤»

[07:35] <moritz_> rakudo: sub f { say Q:PIR { $P0 = getinterp␤ %r = $P0['sub';3] }; }; f()

[07:35] <p6eval> rakudo 5e6fa9: OUTPUT«!UNIT_START␤»

[07:35] <moritz_> rakudo: sub f { say Q:PIR { $P0 = getinterp␤ %r = $P0['sub';3] }; }; eval 'f'

[07:35] <p6eval> rakudo 5e6fa9: OUTPUT«eval␤»

[07:36] <moritz_> rakudo: sub f { say Q:PIR { $P0 = getinterp␤$I0 = 3␤ %r = $P0['sub';$I0] }; }; eval 'f'

[07:36] <p6eval> rakudo 5e6fa9: OUTPUT«eval␤»

[07:36] * moritz_ has an eval plan :-)

[07:37] *** Guest9064 left
[07:37] *** cognomore left
[07:40] *** cognominal left
[07:41] *** rgrau[work] joined
[07:43] *** cognominal joined
[07:52] *** aesop left
[07:57] *** mberends joined
[07:58] *** aesop joined
[08:02] *** justatheory left
[08:03] <moritz_> that evil/eval plan seems to work

[08:04] <eternaleye> rakudo: sub f { say Q:PIR { $P0 = getinterp␤$I0 = 3␤ %r = $P0['sub';$I0] }; }; eval '{ { { { f } } } }'

[08:04] <p6eval> rakudo 5e6fa9: OUTPUT«_block93␤»

[08:18] *** hudnix left
[08:20] *** LionMadeOfLions left
[08:27] *** LionMadeOfLions joined
[08:27] *** LionMadeOfLions left
[08:28] *** LionMadeOfLions joined
[08:28] *** LionMadeOfLions left
[08:28] *** LionMadeOfLions joined
[08:28] *** LionMadeOfLions left
[08:29] *** LionMadeOfLions joined
[08:29] *** LionMadeOfLions left
[08:30] *** LionMadeOfLions joined
[08:30] *** LionMadeOfLions left
[08:30] *** LionMadeOfLions joined
[08:30] *** LionMadeOfLions left
[08:31] *** LionMadeOfLions joined
[08:31] *** LionMadeOfLions left
[08:32] *** LionMadeOfLions joined
[08:32] *** LionMadeOfLions left
[08:33] *** LionMadeOfLions joined
[08:33] *** LionMadeOfLions left
[08:33] *** LionMadeOfLions joined
[08:33] *** LionMadeOfLions left
[08:36] <moritz_> jnthn, pmichaud: in the MAIN branch I avoid injecting calls to MAIN by walking the caller chain and comparing to eval. It's evil, but it produces a clean spectest... OK to merge?

[08:37] *** gbacon joined
[08:37] *** clintongormley joined
[08:40] *** ingy left
[08:41] *** ingy joined
[08:41] *** masak joined
[08:46] *** plobsing left
[08:50] *** frettled left
[08:56] <moritz_> and it broke MAIN. OH NOEZ.

[08:57] *** jaldhar_ left
[08:58] *** jaldhar_ joined
[08:59] *** proller joined
[08:59] *** jaldhar_ left
[09:00] *** jaldhar_ joined
[09:00] *** agentzh joined
[09:03] *** frettled joined
[09:17] *** frettled left
[09:18] *** frettled joined
[09:20] * masak .oO( Rakudo Silver Bullet )

[09:21] <hejki> hehe.. sounds like a cheap dildo :)

[09:21] <masak> brain, belay that mental image!

[09:21] <hejki> :P

[09:21] <hejki> sorry for mindfscking

[09:21] <masak> now you're just being mean. :P

[09:22] <hejki> at least you only have to get rid of your conscious mind.. for me it was a byproduct of subconscious

[09:22] <hejki> hehe :)

[09:27] *** lichtkind joined
[09:28] <lichtkind> masak: hai, i seen your new project

[09:28] <masak> lichtkind: I wondered when I'd hear from you :P

[09:28] <lichtkind> masak: can it be i inspired the name?

[09:29] <masak> lichtkind: not consciously, but the mind works in mysterious ways.

[09:29] <lichtkind> masak: im currently in conference preperaing a perl 6 talk

[09:29] <lichtkind> and while making a proto screenshot i saw it just now

[09:30] <masak> :)

[09:30] <masak> it seriously needs a logo, too.

[09:30] <masak> preferably one of those saucer-like things.

[09:31] <lichtkind> i can show you

[09:31] <masak> one of these: http://www.babble.com/CS/blogs/strollerderby/ufo05.jpg

[09:31] <masak> looks like a floating Darth Vader helmet :)

[09:33] <lichtkind> thats stupid

[09:33] <lichtkind> no that onw is good

[09:33] <lichtkind> looks like a pic from billy

[09:33] <lichtkind> he a legend

[09:34] <lichtkind> even mulders wallet was one from him

[09:34] <lichtkind> yeah its real ... goood

[09:34] <masak> Mulder's wallet has been sighted? man.

[09:34] <masak> that series sure is crazy.

[09:35] <lichtkind> masak i ment placard not wallet :)

[09:35] * moritz_ tried to think of a possible logo for JSON::Tiny

[09:35] <jnthn> God morgon, #perl6.

[09:35] <lichtkind> jnthn: moin

[09:35] <masak> Mor'n, jnthn.

[09:36] <moritz_> serializing and deserializing could be a sheet of paper <doublearrow> a tree

[09:36] <moritz_> but getting that into 32px**2 sounds like quite a challenge

[09:36] <lichtkind> good to see you

[09:36] <masak> the original JSON logo is pretty cute.

[09:37] <moritz_> maybe I should just steal that :-)

[09:38] <masak> it's both round and square at the same time. that's pretty flexible.

[09:38] <frettled> jnthn: svenska FTW!

[09:39] *** agentzh left
[09:39] <masak> also, it kinda looks both like a J and an O at the same time.

[09:40] <moritz_> does anybody spot any obvious errors in http://github.com/rakudo/rakudo/commit/c77e2780c294bfac6612a1c5c004ca51b3af3f54 ?

[09:40] <lichtkind> masak: is it ssave to say when http://rakudo.org/status is on all time high rakudo * will be released

[09:40] <moritz_> somehow it never seems to add an MAIN_HELPER call

[09:41] <masak> lichtkind: yes, in absolute numbers, we've now passed alpha.

[09:41] <moritz_> but R* release is not coupled to number of tests

[09:41] <masak> lichtkind: however, alpha has some features that master still lacks.

[09:41] <lichtkind> masak: and when them back * comes?

[09:41] <jnthn> rakudo: say &eval

[09:41] <p6eval> rakudo 5e6fa9: OUTPUT«eval␤»

[09:41] <masak> lichtkind: sorry, that didn't parse.

[09:42] <masak> rephrase, please?

[09:42] <moritz_> rather to some features we want to have, and to a schedule

[09:42] <lichtkind> masak: when these features are back in current branch,  rakudo * may come?

[09:42] * moritz_ is glad he's not the only one who occasionally has troubles parsing lichtkind's sentences :-)

[09:42] <masak> lichtkind: something like that. we want to release Star soon, but we also want a good feature set.

[09:43] <masak> lichtkind: see yesterday's #phasers logs.

[09:43] <jnthn> moritz_: Doens't look immediately wrong

[09:43] <jnthn> moritz_: Try "say $S0" after the $S0 = $P0 line to see what it's actually finding.

[09:43] <moritz_> jnthn: I experimented a bit, and found that print $return_value_from_interp indeed prints 'eval'

[09:43] <moritz_> back to auld debugging :)

[09:43] <lichtkind> masak: there is a phaser channel?

[09:44] <masak> lichtkind: #phasers

[09:44] <masak> channel formerly known as #rakudosketch

[09:44] <jnthn> moritz_: In what way does it fail?

[09:44] <lichtkind> ah

[09:44] <jnthn> IN_EVAL just returns 0?

[09:45] <moritz_> jnthn: I guess so, because the --target=PIR output doesn't show a call to MAIN_HELPER

[09:45] <lichtkind> masak: i wanted say cant find the irclog of that but found now, not that im not see the link the first time

[09:46] <moritz_> the URLs of the IRC log pages are pretty obvious, and extrapolating them to other channels usually works :-)

[09:47] <jnthn> moritz_: Aye, then try dumping the $S0s.

[09:47] <lichtkind> moritz_: normally yes but im sitting in a talk and follow 3 things at once and didnt see a link on the irclog page

[09:47] <moritz_> recompiling now with some printerr statements...

[09:47] <moritz_> jnthn: oh, IN_EVAL always returns 1

[09:48] <moritz_> because the normal call chain also contains an eval :/

[09:48] <moritz_> eval -> compile -> parse -> parse -> TOP -> comp_unit etc

[09:49] <moritz_> so I need to check for at leat two evals... now that's getting hacky

[09:49] <moritz_> hum, no

[09:49] <masak> maybe stop when you hit a 'compile'?

[09:50] <masak> oh wait.

[09:50] <moritz_> masak: but the built-in eval also calls compile

[09:50] <masak> realized that.

[09:50] <jnthn> moritz_: Well, maybe better would be to look up Perl 6's eval function and compare the two subs to see if they're the same sub?

[09:51] *** tylerni7 left
[09:51] <jnthn> $P1 = get_hll_global '&eval'

[09:51] <jnthn> if $P0 == $P1 goto done

[09:51] <jnthn> or maybe

[09:51] <jnthn> eq_addr $P0, $P1, done

[09:51] <moritz_> will try that

[09:51] <lichtkind> masak: http://www.figu.org/ch/ufologie/strahlschiffe/galerie-ohne-flash

[09:52] <masak> lichtkind: nice landscapes.

[09:53] <lichtkind> masak: of cause :)

[09:53] <lichtkind> masak: billy has an eye for proportion too

[09:55] <moritz_> masak: I want my camelia super-awesome logo for Math::RungeKutta

[09:55] <mathw> Form.pm could go in R*... if the backtracking through captures bug is fixed, or a workaround is found, and assuming there aren't any other horrible problems with it. It's incomplete, but what's there works (or worked on alpha anyway!)

[09:55] <masak> moritz_: :)

[09:55] <masak> moritz_: we'll get there, I hope.

[09:55] <moritz_> I have a readme, passing tests, decent test coverage, a logo.. NOW!

[09:56] <masak> mathw: I want to have a look at that bug/unfeature.

[09:56] <moritz_> gerd++ reminded us on parrot-dev that it's 6 days to the parrot release for rakudo *

[09:57] <masak> aye.

[09:57] <moritz_> so everything that should go into R* needs to be in by Tue

[09:57] <masak> no time to linger.

[09:57] <moritz_> from the nqp-rx side

[09:58] <mathw> yeah well if that's fixed, I'll put in the necessary work to get Form ready for R*, but I'm aware that pmichaud said it's untrivial

[09:58] *** jaldhar_ left
[09:58] *** jaldhar_ joined
[09:59] <masak> one needs to add something which isn't there now. and it needs to be done 'properly', with extensibility in mind. it's entirely possible that pmichaud wants to do it himself.

[09:59] <masak> but I thought I might have a look at it and try to think up a solution.

[10:05] *** mjk joined
[10:05] *** nnunley left
[10:05] <moritz_> jnthn: now it's the other way round... the eq_addr never branches :(

[10:08] *** agentzh joined
[10:14] *** agentzh left
[10:18] *** PZt left
[10:18] *** [mark] left
[10:20] *** ggoebel joined
[10:22] <moritz_> but counting the eval's in the call chain does seem to work

[10:23] *** gbacon left
[10:24] *** bkeeler left
[10:26] <moritz_> now running a full spectest over lunch, or so

[10:30] <masak> lunch. good idea.

[10:30] *** masak left
[10:32] *** mjk left
[10:32] *** mjk joined
[10:34] *** lestrrat is now known as lest_away

[10:38] *** bkeeler joined
[10:44] *** rv2733 joined
[10:49] *** lichtkind left
[10:49] *** Pzt3 joined
[10:51] *** Pzt3 is now known as PZt

[11:05] *** hirschnase left
[11:10] *** yinyin left
[11:14] *** jhuni left
[11:16] *** envi^home joined
[11:18] <jnthn> moritz_: (sorry, was suddenly afk) Ah, that's weird.

[11:24] * moritz_ back from nom

[11:25] <moritz_> ./perl6 -e 'sub MAIN(*@a) { say [+] @a }' 2 3 5

[11:25] <moritz_> 10

[11:25] <moritz_> \o/

[11:26] <jnthn> \o/

[11:27] <moritz_> it's with eval-counting

[11:28] <moritz_> jnthn: do you want to review before I merge?

[11:28] <moritz_> or should I just go ahead?

[11:28] <moritz_> (no new spectest failures)

[11:29] <jnthn> moritz_: The eval counting feels a tad odd.

[11:29] <moritz_> jnthn: it does

[11:29] <jnthn> (maybe a litle fragile - what if a user writes a sub called eval

[11:29] <jnthn> )

[11:30] <moritz_> if that appears in the call chain, we're not in mainline code

[11:30] <jnthn> True.

[11:31] <jnthn> The eq_addr probably failed because &eval lookup actually gives you a wrapper object, not the Parrot sub itself.

[11:32] <jnthn> Whereas the Parrot stack introspection hands you the Parrot sub.

[11:32] <moritz_> is there an easy-ish way to access the parrot sub from a wrapper?

[11:32] <jnthn> Maybe .do

[11:32] <jnthn> If not, $P0 = getattribute $P0, '$!do'

[11:32] <jnthn> Method is preferable.

[11:32] *** aesop left
[11:33] <jnthn> rakudo: say &eval.do

[11:33] <p6eval> rakudo 5e6fa9: OUTPUT«eval␤»

[11:33] <jnthn> Aha.

[11:33] <jnthn> Should work.

[11:34] * moritz_ tries

[11:37] *** aesop joined
[11:39] *** rv2733 left
[11:39] *** sorear left
[11:40] *** sorear joined
[11:41] <moritz_> rakudo: my $x = pir::get_hll_global__vS('&main'); say $x.do

[11:41] <p6eval> rakudo 5e6fa9: OUTPUT«===SORRY!===␤The opcode 'get_hll_global_s' (get_hll_global<1>) was not found. Check the type and number of the arguments␤»

[11:41] <moritz_> rakudo: my $x = pir::get_hll_global__pS('&main'); say $x.do

[11:41] <p6eval> rakudo 5e6fa9: OUTPUT«Null PMC access in can()␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/F16T6wEqw2␤»

[11:42] <moritz_> rakudo: Q:PIR { $P0 = get_hll_global '&main'␤ $P0 = $P0.'do'() ␤ say $P0 }

[11:43] <p6eval> rakudo 5e6fa9: OUTPUT«Null PMC access in find_method('do')␤  in main program body at line 1:/tmp/9ipFPHz0i_␤»

[11:43] *** lest_away is now known as lestrrat

[11:43] <moritz_> rakudo: Q:PIR { $P0 = get_hll_global '&eval'␤ $P0 = $P0.'do'() ␤ say $P0 }

[11:43] <p6eval> rakudo 5e6fa9: OUTPUT«eval␤»

[11:44] <moritz_> main and EVAL, MAIN and eval :-)

[11:45] <jnthn> :-)

[11:48] <moritz_> with unwrapping the refaddr comparsion seems to work

[11:48] <jnthn> \o/

[11:48] <moritz_> jnthn++

[11:48] *** satyavvd left
[11:49] <moritz_> ./perl6 -e 'sub MAIN($x) { say eval ~$x } ' 45+6

[11:49] <moritz_> 51

[11:49] <moritz_> when the IN_EVAL doesn't work, either eval() doesn't return its argument, or MAIN is not executed (depending on the failure mode)

[11:50] <moritz_> running another full spectest before merging

[11:50] <jnthn> :-)

[11:50] <jnthn> moritz_: Is this a step along the way to integrating patrickas++'s bits?

[11:50] <moritz_> jnthn: yes; seems that I'm finally done

[11:50] <jnthn> Yay

[11:50] <moritz_> just need to merge

[11:51] *** colomon left
[11:51] <moritz_> the USAGE bit isn't in there, but I'll let patrickas++ do the patch for that bit

[11:52] <jnthn> Yes, I guess it's easier to know where to put that now.

[11:53] *** colomon joined
[11:54] *** gbacon joined
[11:58] *** hirschnase joined
[12:05] *** JimmyZ joined
[12:10] *** IllvilJa joined
[12:17] *** masak joined
[12:17] *** mjk left
[12:20] *** quester_ joined
[12:20] *** gbacon left
[12:27] <takadonet> morning all

[12:27] <masak> \o

[12:28] <jnthn> o/

[12:29] <moritz_> hugme: tweet rakudoperl rakudo now supports MAIN subs, including named arguments #perl6

[12:29] * hugme hugs moritz_; tweet delivered

[12:29] <dalek> rakudo: f7ddcf5 | moritz++ |  (3 files):

[12:29] <dalek> rakudo: try to actually run MAIN subs; most code by patrickas++

[12:29] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f7ddcf57efbf25eb49d2a9b66b47aa80d8dd67df

[12:29] <dalek> rakudo: b0d427b | moritz++ | src/ (2 files):

[12:29] <dalek> rakudo: second attempt at MAIN sub

[12:29] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b0d427b127ea72764d8117f8d49c48f80f01fed1

[12:29] <dalek> rakudo: 3657ad7 | moritz++ | src/Perl6/Actions.pm:

[12:29] <dalek> rakudo: add TODO comment wrt MAIN sub

[12:29] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3657ad7554ef7ef32a502f48afbfa3412302afb2

[12:29] <dalek> rakudo: c77e278 | moritz++ | src/ (2 files):

[12:29] <dalek> rakudo: check for eval()ness by walking the call chain

[12:29] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c77e2780c294bfac6612a1c5c004ca51b3af3f54

[12:29] <dalek> rakudo: d33a958 | moritz++ | src/glue/run.pir:

[12:29] <dalek> rakudo: IN_EVAL needs to count the number of eval()s, since there is always one in the 

[12:30] * moritz_ feels spammy

[12:30] <jnthn> Let's call it "productive" :-)

[12:30] <quester_> .

[12:31] <masak> moritz_++

[12:31] *** masonkramer left
[12:31] *** pnu left
[12:31] *** masonkramer joined
[12:32] <moritz_> patrickas++ did most of the actual logic

[12:33] *** pnu joined
[12:34] <jnthn> moritz_: It was from a weekly challenge too, iirc?

[12:34] <moritz_> jnthn: yes, week 3

[12:34] <moritz_> masak: any submissions for week 6 yet?

[12:34] <jnthn> We seem to be doing very well out of those.

[12:35] <masak> moritz_: no. I did get a comment with a proposed fix for something else. though as far as I could see, that had already been fixed since the April release.

[12:35] <moritz_> right; we need another book release soon

[12:36] <masak> anyone signed up for that?

[12:37] <moritz_> nope

[12:37] <moritz_> I hope I'll get to it tonight

[12:37] <moritz_> feel free to remind me in ~5 hours :-)

[12:37] <masak> I will if I remember :)

[12:38] *** quester_ left
[12:39] <moritz_> phenny: remind me in 5 hours that I want to release the book

[12:41] <masak> anyone else not seeing the whole one-liner at http://blogs.perl.org/users/steven_haryanto/2010/06/custom-dumping-in-datadump.html ?

[12:42] <jnthn> .oO( I accidentally the whole one-liner )

[12:42] <moritz_> truncated

[12:42] * jnthn doesn't see it all either

[12:42] * masak leaves a comment

[12:43] <moritz_> there is no preview button.

[12:43] <moritz_> and moritz_ is his prophet

[12:44] *** JimmyZ_ joined
[12:46] <masak> heh. even use.perl.org has a Preview button! :P

[12:46] <masak> in fact, you have to use it at least once before submitting.

[12:47] *** skids joined
[12:47] <moritz_> unless you configure it not to having to use it

[12:47] <masak> oh. didn't know that.

[12:47] <masak> I usually preview a dozen times anyway.

[12:47] <moritz_> at least I think you can configure it that way, if you're logged in

[12:48] <moritz_> (slashdot allows anonymous comments, and forces preview there)

[12:48] <masak> you usually are logged in when you're writing a journal entry. :)

[12:48] <moritz_> I was talking about comments too

[12:48] <masak> use.perl.org doesn't force preview for comments, at least not when you're logged in.

[12:48] * jnthn didn't move from use.perl.org yet either

[12:49] <jnthn> I think most people who read my stuff, read it aggregated on Planet Perl 6.

[12:49] * mathw does

[12:49] <mathw> Planets are good

[12:49] <mathw> Very convenient

[12:51] *** JimmyZ left
[12:51] <moritz_> if it weren't for planetsix, I'd be subscribing a whole lot more journal RSS

[12:51] *** JimmyZ_ is now known as JimmyZ

[12:54] <moritz_> afk

[12:55] <jnthn> lunch

[12:56] <masak> lately, I've been thinking of writing a series of blog posts about variables and scoping. try to cover all of the Perl 6 variants of these.

[12:57] *** araujo left
[13:00] *** gfx left
[13:04] <masak> lexical variables, dynamic variables, temp/let, my scoping, our scoping, has scoping, placeholder parameters, the OO twigils, compiler hint variables, the 'constant' keyword, the 'anon' keyword, closure semantics...

[13:05] <masak> while Perl 6 contains a lot of "cool" goodness in the form of grammars and solid OO, there's a lot of "mundane" goodness to be had with just variables and scoping.

[13:07] <mathw> yes

[13:07] <mathw> definitely

[13:07] <[particle]> hypotheticals

[13:08] <masak> [particle]: that's 'let'.

[13:08] <[particle]> oh, right, thanks

[13:08] *** hirschnase left
[13:12] <masak> std: package A {}; my $A::b

[13:12] <p6eval> std 31183: OUTPUT«ok 00:01 108m␤»

[13:12] <masak> hm.

[13:14] <masak> rakudo: package A {}; my $A::b = 5

[13:14] <p6eval> rakudo a54677: OUTPUT«Null PMC access in getprop()␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/L_uN0yqfKo␤»

[13:14] * masak submits rakudobug

[13:14] <masak> rakudo: my $A::b = 5

[13:14] <p6eval> rakudo a54677: OUTPUT«Null PMC access in getprop()␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/uVvyvFEwia␤»

[13:14] <masak> even easier.

[13:15] <masak> rakudo: my $A::b

[13:15] <p6eval> rakudo a54677:  ( no output )

[13:16] <jnthn> ah, should just ban long names there...

[13:16] <masak> yes.

[13:17] <jnthn> Maybe we already haz a ticket on that, it feels...familiar

[13:19] <masak> we should appoint a TicketMeister, someone whose main job is to be really familiar with the already submitted tickets in RT.

[13:20] <masak> preferably someone who likes merging, annotating and triaging tickets.

[13:22] <[particle]> i say we nominate the person who's submitted the most tickets...

[13:22] <masak> but then we'd have to... actually find out who that is. sounds hard.

[13:23] <[particle]> write a ticket about it

[13:23] <masak> why does compiling STD give a lot of errors about deep recursion?

[13:23] <masak> s/errors/warnings/

[13:29] *** arthur-_ joined
[13:29] *** arthur-_ left
[13:31] <mathw> masak: your compiler has developed a fear of potholing

[13:31] *** pnu left
[13:32] <masak> mathw: in my dictionary, 'pothole' is a noun only, not a verb. what does the verb mean?

[13:33] <mathw> masak: exploring certain kinds of cave. Usually the kind which go downwards.

[13:33] <masak> ah.

[13:33] *** pnu joined
[13:33] <masak> :)

[13:39] * jnthn has been potholing a couple of times when younger.

[13:39] <jnthn> masak: BTW, did you notice that ByteBuffer has shown up in Parrot?

[13:40] <masak> no, I did not notice. that sounds like good news, though.

[13:40] *** rgrau joined
[13:41] <jnthn> masak: It's likely already more complete than $my-little-hack

[13:41] <masak> I will check it out during the day.

[13:42] *** meppl joined
[13:44] *** araujo joined
[13:49] *** ash__ joined
[13:49] *** colomon_phone joined
[13:50] *** macdaddy joined
[13:50] *** macdaddy is now known as Guest68956

[13:54] <masak> rakudo: { sub say(*@args) {}; say 1 }; say 2

[13:54] <p6eval> rakudo a54677: OUTPUT«2␤»

[13:54] <masak> \o/

[13:54] <masak> Tene: I'll be able to use the above trick to override printing in Ratel.

[13:54] *** hudnix joined
[13:57] <jnthn> Ratel?

[13:59] * jnthn tries http://github.com/masak/ratel/ hopefully...

[13:59] <jnthn> :-)

[13:59] <masak> no, it's in the Web.pm repo.

[14:00] <masak> it's a minimal templating engine.

[14:00] <masak> the Ratel class is 30 lines of code, including blank lines :)

[14:01] <jnthn> Aha. :-)

[14:02] <jnthn> Oh, it's a type of animal.

[14:02] <jnthn> "Honey Badger"

[14:02] * masak hadn't found that out yet :)

[14:02] <masak> jnthn++

[14:02] <masak> Tene++

[14:02] <jnthn> http://www.awf.org/content/wildlife/detail/ratel

[14:05] <jnthn> Wow...they're awesome! See the Diet section!

[14:05] <masak> "Eats, Shoots and Leaves"? :P

[14:06] *** plobsing joined
[14:06] <jnthn> Follows, farts out bees, actually.

[14:06] <masak> cool! a badger-bird symbiosis!

[14:08] <jnthn> Yeah! How sweet.

[14:08] *** gbacon joined
[14:09] *** ash__ left
[14:09] * colomon reads the last few lines, assumes the crew has finally lost their minds.

[14:10] *** ash__ joined
[14:10] *** alester joined
[14:11] <masak> colomon: just business as usual. :)

[14:11] * colomon reads the link on the ratel, assumes the AWF have finally lost their minds.

[14:11] <colomon> (diet section in particular)

[14:12] *** uniejo left
[14:12] *** Guest99340 left
[14:19] <mberends> this immediately reminded me of http://en.wikipedia.org/wiki/Ratel_IFV (having lived in RSA)

[14:22] <jnthn> Disappointing, I was expecting chemical warfare after reading the diet section about the animal. ;-)

[14:23] *** bbkr joined
[14:24] <masak> Tene: idea: to use .<title> syntax in Ratel templates instead of %attrs<title> syntax. this can be done by assigning $_ = %attrs in the serialize method. what do you think?

[14:25] <bbkr> rakudo: grammar X { token TOP { <ws>+ } }; X.parse(" "); # why it goes into infinite loop (despite the fact that + is not necessary) ?

[14:25] <p6eval> rakudo a54677:  ( no output )

[14:25] <bbkr> known bug?

[14:26] <masak> haven't seen it before, no.

[14:26] <jnthn> Me either.

[14:26] * bbkr reports

[14:26] <jnthn> I guess since <ws> can match nothing, it can also match nothing a lot of times. ;-)

[14:27] <masak> that might explain it.

[14:27] <masak> so maybe it's expected behavior.

[14:27] <masak> maybe even something that merits a warning from the compiler.

[14:27] <masak> if someone does <ws>+ with the standard <ws> rule, they get a "you probably don't mean that" warning.

[14:27] <bbkr> rakudo: grammar X { token TOP { ""+ } }; X.parse(" "); # looks like jnthn i right

[14:28] <p6eval> rakudo a54677:  ( no output )

[14:28] *** jaldhar_ left
[14:28] <masak> rakudo: " " ~~ / [ '' ]+ /; say 'alive'

[14:28] <p6eval> rakudo a54677:  ( no output )

[14:28] <jnthn> Ah, *any* zero-width match seems to exhibit it.

[14:29] <jnthn> That probably is a bug.

[14:29] <masak> no, it's not.

[14:29] <masak> think about it. it's expected behavior.

[14:29] <jnthn> rakudo: " " ~~ / [ x? ]+ /; say 'alive'

[14:29] <masak> regexes are *expected* to do this.

[14:29] <p6eval> rakudo a54677:  ( no output )

[14:29] <masak> I have a plan for letting GGE detect these things, though.

[14:29] <masak> it tends to bite people.

[14:30] <masak> I also seem to recall that with a Thompson engine, you can't even think that kind of wrong thought. ;)

[14:30] <jnthn> masak: It's inconsistent with Perl 5.

[14:30] <jnthn> C:\>perl -e "' ' =~ /(x?)+/; print 42;"

[14:30] <jnthn> 42

[14:30] <masak> oh?

[14:30] <masak> then it probably merits pmichaud's and TimToady's attention.

[14:31] <jnthn> I'd be interested to see their responses, yes.

[14:31] *** dakkar left
[14:31] *** colomon_phone left
[14:34] <mathw> It does seem silly to just sit there accepting zero-width matches from the same entity forever

[14:36] *** volss joined
[14:36] <bbkr> reported here: http://rt.perl.org/rt3/Ticket/Display.html?id=75634

[14:36] <jnthn> mathw: I'm trying to work out why it might not be so simple as "check if we advanced by any characters"

[14:37] <mathw> jnthn: it'd be nice if it is that simple

[14:39] <jnthn> rakudo: for 1..5 { my $x = 0; " " ~~ /(<?{ $x++; rand() > 0.5 }> x?)+/; say $x; }

[14:39] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Unsupported use of rand(); in Perl 6 please use rand at line 11, near "() > 0.5 }"␤»

[14:40] <jnthn> rakudo: for 1..5 { my $x = 0; " " ~~ /(<?{ $x++; rand > 0.5 }> x?)+/; say $x; }

[14:40] <p6eval> rakudo a54677: OUTPUT«2␤2␤2␤5␤4␤»

[14:40] <jnthn> Well, we'd break that. ;-)

[14:40] <mathw> oh boo

[14:40] <mathw> I'm conflicted

[14:40] <mathw> on the one hand is the side of me which says "people who rely on that kind of trick can figure out another way"

[14:41] <mathw> it also says "we shouldn't make it trivial to introduce infinite loops into regexps via a common mistake"

[14:41] <mathw> however the other side of me says "Perl gives you enough rope to hang yourself"

[14:41] <mathw> but I can imagine being in here for years answering about why <ws>+ causes infinite loops

[14:42] *** patspam joined
[14:43] *** plobsing left
[14:43] *** Lorn left
[14:44] <bbkr> <ws>+ causing infinite loop is not DWIM-style, i think most people understan it as "\s+". beside: i cannot imagine where this "bug" can be used for purpose

[14:49] <masak> you could say the same about many thinkos.

[14:50] <masak> it's not that someone has maliciously set things up for <ws>+ not to work, it's just a consequence of how <ws> and + work each on its own.

[14:50] *** dju left
[14:50] <masak> alpha: grammar X { token TOP { <ws>+ } }; X.parse(" "); say "alive"

[14:51] <p6eval> alpha 30e0ed:  ( no output )

[14:53] <jnthn> It's not really about <ws> though.

[14:53] <jnthn> It's about zero-width matches and the + and * quantifiers.

[14:53] <jnthn> Well, I presume * too.

[14:57] *** gbacon left
[14:59] *** baest left
[15:01] *** gbacon joined
[15:06] *** kaare joined
[15:07] *** kaare is now known as Guest54878

[15:07] <bbkr> i've seen many regexps in P5 where zero width were in alternative like this: (a|$)+ . and it also loops forever on P6.

[15:07] <bbkr> rakudo: "" ~~ /(a|$)+/

[15:08] <p6eval> rakudo a54677:  ( no output )

[15:08] <bbkr> this will bite often :P

[15:08] <jnthn> C:\>perl -e "'' ~~ /(a|$)+/; print 42"

[15:08] <jnthn> 42

[15:09] <jnthn> rakudo: "xa" ~~ /(a|$)+/; say $/;

[15:09] <jnthn> rakudo: "xa" ~~ /x(a|$)+/; say $/;

[15:10] <p6eval> rakudo a54677:  ( no output )

[15:10] <bbkr> counterintuitive, isn't it?

[15:10] <jnthn> I've surely written more complex things that boil down to that in Perl 5.

[15:11] <jnthn> (As in, that would fail in Rakudo at the moment becuase of this same behavior difference.)

[15:11] <jnthn> masak: (from #parrot)  <@NotFound> ByteBuffer reviews wanted.

[15:11] <masak> gotcha.

[15:11] <jnthn> Sounds like it's ready for your testing, when you ahve time. :-)

[15:12] <jnthn> NotFound++

[15:12] <masak> I'm pretty sure nothing in S05 explicitly mentions an exception that would allow [$]+ to ever terminate.

[15:13] <masak> certainly nothing in PGE does.

[15:13] <colomon> anyone have advice for getting a good printout for the Spec pod?  I just tried pod2latex, and it failed miserably...

[15:14] <masak> what about perldoc?

[15:15] <[Coke]> (printout) - percabal.org ?

[15:15] <[Coke]> er, perlcabal

[15:15] <[Coke]> (just print the HTML versions?)

[15:16] *** synth left
[15:16] *** lestrrat left
[15:17] *** frooh_ is now known as frooh

[15:18] *** synth joined
[15:19] *** lestrrat joined
[15:20] *** M_o_C joined
[15:25] <colomon> [Coke]: that would make the most sense, I guess. 

[15:26] *** JimmyZ left
[15:27] *** justatheory joined
[15:29] *** alester left
[15:29] *** alester joined
[15:30] *** gbacon left
[15:32] <masak> moritz_: yay! a weekly contribution just landed in my inbox!

[15:35] *** Ross left
[15:36] *** estrabd_afk is now known as estrabd

[15:37] <masak> from a stylistic viewpoint, I can never decide whether to use the .= dotty or the .= assignment operator.

[15:38] *** mantovani joined
[15:38] <jnthn> masak: I tend to prefer the latter visually.

[15:39] <jnthn> masak: However, it bites you if you forget that you can't write @a >>.= @b;

[15:39] <masak> heh.

[15:39] <jnthn> (need to use the dotty there)

[15:39] <masak> haven't forgotten that so far. ;)

[15:39] <jnthn> How often have you used >>.= though? ;-)

[15:40] <masak> approximately never.

[15:41] *** hudnix left
[15:41] <jnthn> :P

[15:41] *** hudnix joined
[15:43] *** isBEKaml joined
[15:49] <pmichaud> good morning, #perl6

[15:49] <cognominal> jnthn,  pmichaud : I have filed a bug. Rakudo should detect when a tentative match  goes thru too many zero width assertions.  I did not formulate like this. But this is simpler than to check at compile time. And anyway, some cases are only pathological depending on the input.

[15:50] <pmichaud> cognominal: I agree; at the moment zero-width assertions are a bit of a challenge to detect.

[15:50] *** justatheory left
[15:50] <pmichaud> sorry, zero-width repeated matches.

[15:50] <cognominal> *assertion in a row.

[15:50] <pmichaud> I think there's already a ticket for this (a long-standing ticket)

[15:50] <cognominal> yes.

[15:51] *** pmurias joined
[15:51] <pmichaud> anyway, thanks for the ticket.

[15:51] <cognominal> I don't ever find the correct words "zero-width repeated matches" indeed. pmichaud++

[15:51] <pmichaud> masak: ping

[15:51] <cognominal> I could update it with the suggestion?

[15:52] <masak> pmichaud: pong

[15:52] <pmichaud> masak: you're listed as release manager for june?

[15:52] <masak> oh? cool!

[15:52] <jnthn> morning, pmichaud 

[15:52] <masak> pmichaud: you want to relieve me of that duty?

[15:52] <jnthn> ELATEGREETING

[15:52] <pmichaud> no, but I wanted to see if you already had a name planned for the release.  If not, I have one.

[15:53] <masak> I don't have a name.

[15:53] <pmichaud> okay, Atlanta it is.

[15:53] <cognominal> Wishing I had more idiot-proof barriers for my worshop.

[15:53] <masak> excellent.

[15:53] <pmichaud> thanks

[15:53] <masak> pmichaud: does S05 say that /[$]+/ should terminate?

[15:54] <pmichaud> the engine is supposed to be able to detect and avoid zero-length repetitions, yes.  I'm not sure if S05 explicitly says that.

[15:54] <masak> I'm pretty sure it doesn't.

[15:54] <masak> and I'm very sure PGE doesn't detect any such thing.

[15:54] <cognominal> so am I, But it is common sense.

[15:54] <pmichaud> oh, I'm quite certain PGE didn't -- that was one of the oldest tickets filed for PGE

[15:55] <pmichaud> http://rt.perl.org/rt3/Ticket/Display.html?id=37745

[15:55] <cognominal> Like if you hit a wall hundred time with your head, may be you should stop...

[15:55] <masak> 37745? that's old!

[15:55] <pmichaud> yes, November 2005.

[15:56] <jnthn> Wow. That's like, over 2 years before I first started hacking on Rakudo. :-)

[15:56] <masak> so. given 'regex foo { $ }' and /<foo>+/, what till $/<foo> contain after a successful match?

[15:57] <cognominal> I suppose it is a matter of going trhu all the matcher subroutines to increment a counter when the match is zero width.

[15:57] <masak> cognominal: that's a runtime solution :)

[15:57] <pmichaud> masak: I suspect it will contain a single zero-width match.

[15:57] <masak> pmichaud: in an array?

[15:57] <pmichaud> yes, since $<foo> is quantified.

[15:58] <masak> ok.

[15:58] <isBEKaml> jnthn: You've been at this for two years? Now I'm curious, did you know about parsing and grammars when you started out or picked them up as you hacked away? :)

[15:58] <cognominal> masak: a compile time solution would be very complex and as I said would not detect every possible case.

[15:58] <masak> cognominal: indeed. grammars are likely too dynamic for it to detect every possible case.

[15:59] <masak> and if we're not supposed to warn about them anyway... might as well do it at runtime.

[15:59] <cognominal> jnthn, don't be too intense in your hacking. That did no good to audreyt... but she was also hacking litterally in meat space.

[15:59] <jnthn> isBEKaml: Depends whether you mean in general or about Perl 6 grammars specifically.

[16:00] <jnthn> isBEKaml: I'd done some compiler courses, but I had to learn the Perl 6 grammar stuff, PAST, other bits.

[16:00] <isBEKaml> jnthn: I was asking in a very general sense. I don't know anything about grammars or CS funda. 

[16:00] <jnthn> Perl 6 was the first non-toy compiler I hacked on.

[16:01] <jnthn> (I architected a logo interpreter (that ended up being part prederef-"compiled") at some point too.

[16:01] <jnthn> Was suffering bad RSI at the time, so I was happy to leave the code writing to others.

[16:02] <cognominal> RSI?

[16:02] <jnthn> Plus it was to be written in Java.

[16:02] <cognominal> ho, boy.

[16:02] <jnthn> cognominal: http://en.wikipedia.org/wiki/Repetitive_strain_injury

[16:03] <isBEKaml> jnthn: RSI, that's worse than typing in Java. anyway, it's good you left it to others. 

[16:03] <jnthn> It was one of those university group projects where it's encouraged that different people in the group take different roles.

[16:04] <cognominal> hum, failed to upgrade my ipad to the new seed. Restored it to factory setting Probably because this device is not registered to Apple as a developper device :(

[16:04] <jnthn> So I kinda took the team leader / architect role, where I could just tell people how I thought it should look. :-)

[16:04] <isBEKaml> jnthn: :)

[16:05] *** jiing left
[16:05] <cognominal> lucky you, I went to an enginering school where I leanrt nothing new to me, not that I knew much. That was a waste of time if not for math that helped me recently to plow thru type theory papers.

[16:06] <jnthn> We managed to have the winning project, partly because our logo interpreter was fast enough and done early enough that we could take a crack at implementing basic versions of a couple of other group's projects in logo. :-)

[16:06] <isBEKaml> Learning about compilers and parsers is one of the items in my to-do list. Don't know how long that would take.  I wish I could just go back to university(ah, times when I had lots of free time) 

[16:07] <isBEKaml> "managed to have the winning project"? What, were there bidding sorta things that you could bid projects for? :)

[16:08] <jnthn> net start ImportQueueService

[16:08] <jnthn> er, ww

[16:08] <masak> isBEKaml: hi. I have a compiler. wanna help me hack on it? it's still in its early stages, so now is a good time to join in.

[16:08] <cognominal> jnthn, did you know, that, the Gosling project before Java was based on the postcript language.  Interactive window system programmable in object oriented Postscript. That was way more than display PostScript

[16:08] <cognominal> I was marginally involved in that.

[16:09] <jnthn> isBEKaml: No, they put the whole class into groups, gave each group a project and then after some weeks got us to show/present it, and a bunch of judges gave votes.

[16:09] <isBEKaml> masak: that's great! You must have seen that I know next to nothing about compilers. :) {Initial hand holding needed } 

[16:09] <jnthn> isBEKaml: Then the winning team went off to represent the uni in some national competition agains tother unis. :-)

[16:09] <jnthn> *against # no, it wasn't a spelling competition :-)

[16:09] <cognominal> The project was a failure, so, they decided, ho surprise, to use that PostScript engine for printer

[16:09] <masak> isBEKaml: we're all starting from scratch, so that's ok.

[16:10] <isBEKaml> masak: Well, I'm in!

[16:10] <masak> isBEKaml: cool! this month, we're doing if/while/subs.

[16:10] <isBEKaml> jnthn: that must have felt awesome! 

[16:10] <masak> isBEKaml: have a look at the code if you like: http://github.com/masak/yapsi/blob/master/lib/Yapsi.pm

[16:11] <bbkr> how can I extract match directly into an array in P6. something that will replace @t = "test" =~ m/(.)/g in P5?

[16:11] * [Coke] misread tentative match as "tentacle match"

[16:11] <TimToady> shh, do not invoke them

[16:11] <jnthn> isBEKaml: Yes, it was pretty nice. :-)

[16:12] *** Ross joined
[16:12] *** __2synth joined
[16:12] <pmichaud> bbkr:  @t = "test".comb(/./);  will work

[16:12] <masak> a little background on Yapsi: there are three other projects that Yapsi is meant to provide a foundation to: Tardis (a time-traveling debugger), lid (a code coverage tool) and sigmund (a static code analyzer).

[16:13] <pmichaud> bbkr: you can also do "test" ~~ /(.)*/   and the resulting array will be in $0

[16:13] <pmichaud> rakudo:  "test" ~~ /(.)*/;   for $0 { .say }   # checking

[16:13] *** __2synth left
[16:13] <p6eval> rakudo a54677: OUTPUT«t␤e␤s␤t␤»

[16:13] <isBEKaml> masak: I heard of Tardis as the Time traveller. ;)

[16:13] *** __2synth joined
[16:13] *** lestrrat left
[16:14] <masak> right now, compilation in Yapsi consists of two phases: one "find variables" phase, that makes sure that all variables are declared before use, and one "sicify" stage, which provides a sort of 'assembler' code which can then be executed directly by the runtime.

[16:14] <bbkr> pmichaud: thanks, i always forget about comb :)

[16:14] *** synth left
[16:14] *** mdxi left
[16:14] <pmichaud> bbkr: yes, a lot of people forget about comb.  But it's the generic "find me things that look like this" matcher.

[16:14] *** lestrrat joined
[16:15] *** mdxi joined
[16:16] <bbkr> rakudo: $_="test"; my %h; %h{.comb(/./)}=1,2,3,4; say %h.perl # bug? comb() returns array so it should fill hash slice.

[16:16] <p6eval> rakudo a54677: OUTPUT«{"" => (1, 2, 3, 4)}␤»

[16:16] *** volss left
[16:17] <isBEKaml> masak: sicify? 

[16:18] *** gbacon joined
[16:18] <masak> isBEKaml: so, SIC is this executable format for the Yapsi runtime.

[16:18] <masak> isBEKaml: if you've ever seen PIR, you know what to expect.

[16:18] *** TiMBuS left
[16:18] <jnthn> masak: What does SIC stand for?

[16:18] <[Coke]> comb always reminds me of SpaceBalls(TM) The Movie(R)

[16:18] <jnthn> .oO( SIC Is Cool )

[16:19] <masak> jnthn: it stands for SIC. :)

[16:19] <isBEKaml> masak: Simply In Code ? 

[16:19] <isBEKaml> ;)

[16:19] <masak> SIC Instruction Code, perhaps.

[16:19] *** isBEKaml_ joined
[16:19] <jnthn> masak: That's just inviting people to make stuff up. ;-)

[16:19] <masak> aye.

[16:19] <isBEKaml> Ah, recursive acronyms! :)

[16:19] <masak> ;)

[16:19] *** synth joined
[16:19] *** __2synth left
[16:19] <masak> I didn't say it was recursive :P

[16:20] <masak> all SIC code is prefixed by a line saying "This is SIC". :D

[16:20] <isBEKaml> Atleast, it never runs into StackOverflowException. ;)

[16:21] <masak> isBEKaml: no, because we don't have a call stack yet :P

[16:21] * jnthn wonders why the people around him have suddenly got into having noisy afternoon parties

[16:21] <jnthn> Guess it must be That Time Of Year when people graduate. :-)

[16:21] *** plainhao joined
[16:22] * isBEKaml_ thinks afternoons are meant for dozing off. 

[16:24] <lucs> masak: About the book LaTeX improvement: where is the source to the book?

[16:24] *** __2synth joined
[16:25] <jnthn> hugme: show book

[16:25] <hugme> jnthn: the following people have power over 'book': P⁣erlJam, T⁣imToady, [⁣particle], c⁣olomon, j⁣nthn, m⁣asak, m⁣berends, m⁣oritz_, p⁣michaud. URL: http://github.com/perl6/book/

[16:25] <jnthn> lucs: ^^ there

[16:25] *** synth left
[16:25] <lucs> Thanks.

[16:26] *** mdxi left
[16:26] *** lestrrat left
[16:26] <masak> lucs: kudos! haven't had time to look at the patches yet.

[16:26] <masak> and now I'm unexpectedly being called away.

[16:26] *** justatheory joined
[16:26] *** masak left
[16:26] *** mdxi joined
[16:27] *** lestrrat joined
[16:27] <lucs> masak: Um, I haven't submitted anything (haven't even looked at it yet) :)

[16:28] <isBEKaml_> hugme: show alpha

[16:28] <hugme> isBEKaml_: sorry, I don't know anything about 'alpha'

[16:28] <isBEKaml_> where do I get alpha from? 

[16:29] <jnthn> isBEKaml_: In your Rakudo clone, just do "git checkout origin/alpha"

[16:31] <bbkr> rakudo: 'my @t = 1,2; my %h; %h{@t}="one","two"; say %h.perl # how to write hash slice in P6? S09 says nothing abouut it.

[16:31] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Confused at line 11, near "'my @t = 1"␤»

[16:31] <bbkr> rakudo: my @t = 1,2; my %h; %h{@t}="one","two"; say %h.perl

[16:31] <p6eval> rakudo a54677: OUTPUT«{"1 2" => ("one", "two")}␤»

[16:31] <isBEKaml_> jnthn: last commit in alpha was in feb? I thought it was so long ago. :s

[16:33] <jnthn> rakudo: my %h; %h{1,2}="one","two"; say %h.perl

[16:33] <p6eval> rakudo a54677: OUTPUT«{"1" => "one", "2" => "two"}␤»

[16:33] <jnthn> eww...nasty bug.

[16:34] <jnthn> I guess it is, anyway.

[16:34] <jnthn> rakudo: my @t = 1,2; my %h; %h{|@t}="one","two"; say %h.perl

[16:34] <p6eval> rakudo a54677: OUTPUT«{"Capture()<0x4669fb0>" => ("one", "two")}␤»

[16:34] <jnthn> :-/

[16:34] <bbkr> yay! another one found :)

[16:36] <bbkr> should it work also with GatherIterator? I found it by simplification of case %h{.comb(/./)}=1,2,3, and that doesn't work either

[16:36] <bbkr> report as two separate bugs or one?

[16:36] <isBEKaml_> rakudo: my @t=<1 2>; my %h{@t} = "one", "two"; %h.perl.say; 

[16:36] *** kolibrie left
[16:36] <p6eval> rakudo a54677: OUTPUT«{"one" => "two"}␤»

[16:37] <isBEKaml_> Did I just miss the joke? 

[16:37] *** kolibrie joined
[16:38] <bbkr> isBEKaml: "my %h{@t}=" is not the same as "my %h; %h{@t}="

[16:38] <isBEKaml_> erm, I don't get what this means... < > translates to a list, right? or does that stringify? 

[16:39] *** mberends left
[16:39] <jnthn> isBEKaml_: Note that my %h{@t} is not doing what you think it is.

[16:39] <jnthn> isBEKaml_: It's (unimplemented, but parsed) syntax for declaring key type or something.

[16:40] <jnthn> That is

[16:40] <jnthn> my %h; %h{@a} = ...

[16:40] <isBEKaml_> jnthn: I would have thought it creates an hash out of a list of elems. 

[16:40] <jnthn> Is not just long hand for

[16:40] <bbkr> typization explained here: http://perlcabal.org/syn/S09.html#Hashes

[16:40] <jnthn> my %h{@a} = ...

[16:40] <bbkr> while I was asking for hash slice

[16:41] <isBEKaml_> Well, I get a different output when I do my %h; %h{@arr}=...  

[16:41] <jnthn> std: my @t; my %h{@t} = 1,2; # curious

[16:41] <isBEKaml_> rakudo: my @t=<1 2>; my %h; %h{@t} = "one", "two"; %h.perl.say; ## Does this give the right output?

[16:41] <p6eval> std 31183: OUTPUT«ok 00:01 109m␤»

[16:41] <p6eval> rakudo a54677: OUTPUT«{"1 2" => ("one", "two")}␤»

[16:41] <jnthn> isBEKaml_: No, that is wrong.

[16:42] * bbkr reports

[16:42] <jnthn> Should be 1 => "one", 2 => "two"

[16:44] <TimToady> the problem appears to me that the subscripter is using $subscript semantics and trying to guess from the type rather than * or ** binding

[16:46] *** rgrau[work] left
[16:47] <TimToady> that is, it appears to be trying to fake list/slice context by examining the subscript object

[16:48] <TimToady> and introspection is nearly always the wrong way to do something

[16:49] <bbkr> reported here: http://rt.perl.org/rt3/Ticket/Display.html?id=75636

[16:50] <jnthn> TimToady: multi-dispatch rather than introspection

[16:52] *** cdarroch joined
[16:52] <TimToady> okay, but something still isn't telling the @t it's in list context and letting it do the natural list-contexty thing

[16:52] *** cdarroch left
[16:52] *** cdarroch joined
[16:56] <bbkr> rakudo: say "a" ~~ Str; say Str ~~ "a";

[16:56] <p6eval> rakudo a54677: OUTPUT«1␤0␤»

[16:56] *** hudnix left
[16:57] <TimToady> looks right to me

[16:57] <bbkr> i know. i was curious how it behaves.

[16:58] *** hudnix joined
[17:01] <TimToady> to the first approximation, that's "Socrates is a man" vs "A man is Socrates"  :)

[17:01] *** pmurias left
[17:01] <bbkr> TimToady: good example, thanks :)

[17:08] *** stephenlb joined
[17:09] *** M_o_C left
[17:26] *** estrabd is now known as estrabd_pgh218_4

[17:26] *** estrabd_pgh218_4 is now known as estrabd_pgh218

[17:35] <pmichaud> When attempting to compile the book to pdf, I get:

[17:35] <pmichaud> ! LaTeX Error: File `fancyvrb.sty' not found.

[17:35] <pmichaud> any clues?

[17:35] <pmichaud> (Kubuntu 10.04)

[17:37] <moritz_> pmichaud: install fancyvrb :-)

[17:37] <pmichaud> E: Couldn't find package fancyvrb

[17:37] <moritz_> pmichaud: I'll take a look which debian package it's in

[17:38] <pmichaud> looks like texlive-latex-recommended (from a bug report)

[17:38] <pmichaud> checking.

[17:39] <moritz_> yes

[17:39] <moritz_> texlive-latex-recommended: /usr/share/texmf-texlive/tex/latex/fancyvrb

[17:39] <moritz_> texlive-latex-recommended: /usr/share/texmf-texlive/tex/latex/fancyvrb/fancyvrb.sty

[17:39] <pmichaud> I'll add that to the README

[17:39] <pmichaud> (I have a couple of other changes to the README)

[17:41] <pmichaud> wow, installing that package also installs a lot of other packages

[17:41] <moritz_> well, writing a book needs some software :-)

[17:45] <dalek> book: bbf179b | pmichaud++ | README:

[17:45] <dalek> book: Update README with additional Ubuntu 10.04 package names.

[17:45] <dalek> book: review: http://github.com/perl6/book/commit/bbf179b609890939ad22954cf798a66e31390c01

[17:46] <pmichaud> could we do something to fix the title page  (i.e., break the author list across two lines?)

[17:46] <moritz_> I've intended to work on that tonight, and make a release

[17:46] <pmichaud> +1

[17:46] <pmichaud> My wife wanted to see the latest version, so I just pdf'd her a copy.  I'll forward her comments.

[17:47] <pmichaud> (or just fix them directly)

[17:47] <pmichaud> (or maybe give her a commit bit :)

[17:47] <moritz_> wait

[17:47] <moritz_> the latest PDF doesn'T show the =begin screen ... =end screen sections

[17:47] <moritz_> that needs a patch for Pod::PseudoPod::LaTeX which I have locally here...

[17:47] <moritz_> and which I've submitted to chromatic++

[17:47] <moritz_> but hasn't been released yet

[17:48] <pmichaud> okay.... could you send me an up-to-date pdf, then?  ;-)

[17:48] <pmichaud> or send me the patch to Pod::PseudoPod::LaTex

[17:48] <moritz_> just a sec...

[17:48] <pmichaud> that might be better if I do any other editing/bookbuilding

[17:49] *** patrickas joined
[17:49] <patrickas> hello

[17:49] <moritz_> http://moritz.faui2k3.org/tmp/book.pdf 

[17:49] <patrickas> moritz_ += Inf :-)

[17:49] <moritz_> http://github.com/moritz/Pod-PseudoPod-LaTeX has the latest patch

[17:50] <[Coke]> http://github.com/perl6/book/downloads is sad. :(

[17:50] *** ShaneC1 joined
[17:51] <patrickas> btw I found a typo in the book at http://github.com/perl6/book/blob/master/src/basics.pod "even it does store" should probably be "even if it stores"

[17:51] <TimToady> std: my $A::b; UNIT::A::<$b>

[17:51] <p6eval> std 31183: OUTPUT«ok 00:01 108m␤»

[17:51] <TimToady> std: my $A::b; UNIT::A::<$nonesuch>

[17:51] <p6eval> std 31183: OUTPUT«===SORRY!===␤Variable UNIT::A::<$nonesuch> is not predeclared at /tmp/QTpwitLnO8 line 1:␤------> my $A::b; UNIT::A::<$nonesuch>⏏<EOL>␤Check failed␤FAILED 00:01 105m␤»

[17:51] <TimToady> jnthn, masak: ^^

[17:52] <jnthn> *sigh*

[17:52] <pmichaud> yes, looks like we got knocked off our book release schedule :-|

[17:53] <jnthn> TimToady: And what exactly happens there? Vivify a lexical package A?

[17:53] <moritz_> it's sad here because github says it can't serve the page

[17:53] <TimToady> jnthn: that can be inferred from UNIT::A

[17:54] <Tene> alpha: { sub say(*@args) {}; say 1 }; say 2

[17:54] <p6eval> alpha 30e0ed:  ( no output )

[17:55] <TimToady> std: my $A::b; GLOBAL::A::<$b>

[17:55] <p6eval> std 31183: OUTPUT«===SORRY!===␤Undeclared name:␤ 'GLOBAL::A::' used at line 1␤Check failed␤FAILED 00:01 105m␤»

[17:55] <TimToady> and from that :)

[17:57] <jnthn> OK.

[17:57] <dalek> book: 96911a0 | moritz++ | src/basics.pod:

[17:57] <dalek> book: [basics] typo noticed by patrickas

[17:57] <dalek> book: review: http://github.com/perl6/book/commit/96911a074954d8e7c7849527ada5e7bd8f357396

[17:58] * Tene needs to try to work on $realjob instead of Perl6. :(

[17:58] * diakopter 2

[17:59] <TimToady> on most things symbol-tabley, STD tends to already have well-formed opinions, which are often even correct, or at least arguably so.  :) 

[18:00] <TimToady> .oO(engineers love to hedge their remarks)

[18:00] <jnthn> :P

[18:01] <PerlJam> .oO(implementors love to trim the hedges)

[18:01] <moritz_> TimToady: should multis still be exported by default?

[18:02] <moritz_> jnthn: I wrote RT #75638 and RT #75640 for you, as promised at #phasers

[18:02] <jnthn> PerlJam: So true. ;-)

[18:03] <pmichaud> moritz_: okay, so here's my CPAN cluelessness showing... how do I import your git changes to Pod::PseudoPod::LaTeX ?

[18:03] * pmichaud is a little bummed that he (and therefore others) cannot build the book pdf

[18:03] <moritz_> you can, but not with screen sections :/

[18:04] <pmichaud> well, I presume the screen sections are important-ish :)

[18:04] <moritz_> so do I, but OTOH it took more than 2 months for somebody to complain :-)

[18:04] <pmichaud> I guess we've all been a bit preoccupied this last couple of months :)

[18:04] <TimToady> moritz_: I think perhaps that it is controlled by the proto; if it's exported, so are its minions

[18:04] <moritz_> pmichaud: I've just added a version number to LaTeX.pm and copied it over my install (low-tech version)

[18:05] <pmichaud> okay, I failed to add the version number then.

[18:05] <moritz_> pmichaud: the high-tech version is to use Dist::Zilla

[18:05] <pmichaud> low-tech is fine with me.  want me to poke chromatic into accepting the patch?  ;-)

[18:05] <moritz_> pmichaud: he already said it's OK, just hasn't released yet

[18:05] <pmichaud> want me to poke chromatic into releasing?  ;-)

[18:06] <moritz_> pmichaud: since masak++ received another patch for the latex emitter today, maybe wait a few days

[18:06] <pmichaud> okay

[18:06] <pmichaud> should we just temporarily maintain our own version of Pod::PseudoPod::LaTeX in the book repo until it settles out?

[18:07] <pmichaud> (are there going to be more such patches in our future?)

[18:07] <moritz_> i hope it won't be necessary...

[18:07] <moritz_> I've been weeding out the limitations, and submitted a bunch of patches before, which chromatic++ promptly release

[18:08] <pmichaud> okay.

[18:08] <moritz_> screen sections and sidebars are the only things I'm aware of that need patching

[18:08] <TimToady> moritz_: alternately, in some sense, if the proto is exported, it doesn't even have to export the minions, since it could just carry them along and add them to the candidate list itself, under the new proto-as-wrapper semantics.

[18:08] <pmichaud> I'll let you guys figure it out.  I've also been planning to work a bit on an nqp-tutorial and book, and want the same toolchain available :)

[18:09] *** Wolfman2000 joined
[18:09] <TimToady> moritz_: but that's probably post R*

[18:10] <jnthn> TimToady: Righr, we can't use that as an R* solution.

[18:10] <jnthn> TimToady: OTOH, it really still is about exporting one thingy.

[18:10] <moritz_> TimToady: I kinda expected that answer

[18:10] <jnthn> In that we collect all the candidates to be exported together already.

[18:11] <jnthn> I guess this means that a multi export is all or nothing though if you hang it off the proto.

[18:11] <TimToady> yes, we're just going to associate that behavior more strongly with the &foo proto down the road

[18:11] <TimToady> and hopefull inline all the protos so it comes out the way it is currently, most of the time

[18:12] <jnthn> Yes, the fact that we need to do that to not end up performing even worse hardly makes me want to rush into doing the refactor.

[18:12] <TimToady> :)

[18:12] <TimToady> there is, on the other hand, a basic simplicity to unifying protos as a kind of only sub

[18:12] <jnthn> I hope we can get a significant win by re-working the way we do attributes and adding the compact struct stuff.

[18:13] <TimToady> and then in that sense, foo() always calls only subs

[18:13] <jnthn> TimToady: Yes, I've kinda come around to the "proto first" view of things. I'm still very unhappy with the multi-method changes though.

[18:14] <jnthn> It feels odd that on the one hand we want to clearly have nested dispatches, but then have the multi dispatcher have to know about how method dispatch works too.

[18:15] *** Lorn joined
[18:16] <TimToady> I think of it more as the 'proto method' having to know that, which is different from a 'proto sub'

[18:17] *** mtnviewmark joined
[18:17] <TimToady> it's actually a way of being able to name different dispatchers, kinda

[18:18] <jnthn> Maybe that's making me uneasy is that I expect methods to be blobs of invokable code that the metaclass has associated a name with, and not a whole lot more.

[18:18] <jnthn> That is, the metaclass knows it has these bunch of methods it can invoke.

[18:18] <jnthn> But the methods don't really care about that.

[18:19] <jnthn> It's a bit of a switch to then say "methods are actually aware of the metaclass they're associated with"

[18:20] <jnthn> In a sense because things then get rather interesting when we do role composition.

[18:20] <TimToady> I don't think of it that way.  you call a proto as an "only" method by the short name, and it's figuring out which multi methods to call; the methods themselves are still ignorant

[18:22] <jnthn> Can you ever get a proto composed in to a class from a role, or is that meaningless and protos in the role are just ignored under compositon?

[18:22] <TimToady> I don't see why protos can't be composed; on that level they're ordinary methods

[18:23] <TimToady> and a role that composes a proto would be a good way to emulate the current semantics

[18:23] <jnthn> I don't quite see how the way we want protos to be ordinary in that sense and the way we want them to be special in the dispatchy sense quite hold together.

[18:24] <jnthn> Where do you envision the multi method candidates as living?

[18:24] <TimToady> in the same namespaces, but with longnames that a proto can gather up into a candidate list

[18:25] <TimToady> namespaces is perhaps a bad word to use

[18:25] <jnthn> But methods don't go in the namespace.

[18:25] <jnthn> (by default)

[18:25] <TimToady> I don't mean packages when I say namespaces

[18:25] <TimToady> that's a parrotism

[18:25] <TimToady> lexical scopes are namespaces too

[18:26] <jnthn> Yes, but the methods don't by default go in a lexical scope too. :-)

[18:26] <TimToady> nevertheless they have their own namespace

[18:26] <jnthn> Right, which at the moment I guess you could just see as the metaclass' method table.

[18:26] <TimToady> but we're going to have to figure out a better word than 'namespace' since it will just cause confusion in parrotland

[18:27] <jnthn> Are we essentially saying that the candidates should all be installed individually in the metaclass method table under their long names, and we install a proto under the short name?

[18:27] <TimToady> I suppose I haven't carped before this, so I have no right to complain, but I do shudder every time someone uses 'namespace' to mean 'global package'

[18:28] <jnthn> And a proto somehow has a magical "link" back to the metaclass so it can find them?

[18:28] <jnthn> (namespace) Yes but that's the usage of the word that is fairly entrenched from not just a Parrot POV, but an other-langauges POV too.

[18:29] <TimToady> the proto knows where it is declared, and the type/location of the actual object/lexpad, and can triangulate all the multis in between

[18:29] <TimToady> jnthn: yes, which is why we have to coin a new word to be clear, probably

[18:30] <jnthn> Would it be reasonable to suggest that it considers $?CLASS in order to start looking for the multis that may live in the various metaclasses it's associated with?

[18:30] <TimToady> but 'namespace' didn't used to mean that in the old days

[18:30] <jnthn> Because if a mention of $?CLASS is generic, then we'd get a proto composed from a role doing the right thing.

[18:31] *** Ross is now known as c

[18:31] *** c is now known as d

[18:31] <TimToady> yes, I believe the multis we want are sandwitched by $?CLASS on the top and self.WHAT on the bottom

[18:31] *** d is now known as e

[18:31] *** e is now known as h

[18:31] *** h is now known as i

[18:31] <TimToady> s/witch/wich/

[18:32] <jnthn> Ah, htat's true, we also have the invocant to hand.

[18:32] *** i is now known as Guest85399

[18:32] <TimToady> with proto subs, it's the relationship of the two lexical scopes that is the sandwich

[18:32] *** hercynium joined
[18:32] *** Guest85399 is now known as k

[18:32] *** k is now known as l

[18:32] *** l is now known as n

[18:32] *** n is now known as Ross

[18:33] <jnthn> Hmm. I guess it could be made to work.

[18:34] <moritz_> btw another p6/grammar questioin on perlmonks: http://www.perlmonks.org/?node_id=843877

[18:34] <TimToady> I'm asking myself whether STD pays attention to the $?CLASS end of the sandwich yet...hmm...

[18:34] *** mtnviewmark left
[18:34] <TimToady> probably doesn't

[18:35] <TimToady> it's just assuming that a proto is going to shadow, which is a bad assumption

[18:35] <jnthn> Rakudo probably needs to start making *every* role actually have $?CLASS as an (implicit) first parameter.

[18:35] <TimToady> grr s/is/isn't/

[18:35] <TimToady> durn n't key...

[18:36] <jnthn> (Right now role Foo { ... } is really parameterless. Of course, that in turn means we don't have a way to make $?CLASS work...

[18:36] <jnthn> )

[18:36] <TimToady> or make CALLER::<$?CLASS> figure it out

[18:36] <jnthn> Hmm, could work also.

[18:36] <jnthn> Maybe.

[18:37] <TimToady> or some such dynamic lookup

[18:37] <TimToady> caller.lexpad.class or some such

[18:38] <TimToady> or just lazify $?CLASS to composition time somehow

[18:38] <TimToady> .oO(P6, tormenting the implementor with too many choices)

[18:39] <patrickas> alpha: my $f='foo'; say "$f [--named=value]" ;

[18:39] <p6eval> alpha 30e0ed: OUTPUT«foo [--named=value]␤»

[18:39] <patrickas> rakudo: my $f='foo'; say "$f [--named=value]" ;

[18:39] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Unable to parse infixish, couldn't find final ']' at line 11␤»

[18:39] <patrickas> who's correct here? Rakudo was behaving like alpha till last week or so 

[18:40] <TimToady> biab &

[18:40] *** justatheory left
[18:40] <moritz_> patrickas: alpha is correct

[18:40] <moritz_> (and we have a ticket for that)

[18:40] *** justatheory joined
[18:40] <patrickas> Oh ok! Thanks

[18:42] <jnthn> huh, that's a bit of a wtf bug.

[18:44] <jnthn> std: my $f='foo'; say "$f [--named=value]" ;

[18:44] <p6eval> std 31183: OUTPUT«ok 00:01 106m␤»

[18:44] <jnthn> Heh. Guess it's a game of spot the difference.

[18:44] <patrickas> actually I can produce the same error with 

[18:45] <patrickas> rakudo: say $f [-n];

[18:45] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Unable to parse infixish, couldn't find final ']' at line 11␤»

[18:45] <patrickas> in case it helps

[18:48] <jnthn> Yes, but it's sensible there :-)

[18:48] <jnthn> Its not inside a quoted string. :-)

[18:54] <patrickas> yes sure I just thought maybe it could be interesting since $f [n]; $f [-]; $f[-n]; "$f [n]"; "$f [-]"; "$f[-n]"; all give a different more expected error message

[18:55] <patrickas> rakudo: "$f[-n]";

[18:55] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Symbol '$f' not predeclared in <anonymous>␤»

[18:56] <patrickas> rakudo: $f[-n];

[18:56] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Symbol '$f' not predeclared in <anonymous>␤»

[18:56] <patrickas> rakudo: "$f [-n]";

[18:56] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Unable to parse infixish, couldn't find final ']' at line 11␤»

[18:57] <patrickas> It still trips me that in perl6 spaces seem to matter much more than in perl5

[18:58] <[particle]> they purposely matter more

[19:04] <takadonet> I keep wanting to use junction in my perl 5 code lately...  

[19:06] <TimToady> std: say $f [-n];

[19:06] <p6eval> std 31183: OUTPUT«===SORRY!===␤Variable $f is not predeclared at /tmp/0WyZMNTph5 line 1:␤------> say $f⏏ [-n];␤Unable to parse bracketed infix at /tmp/0WyZMNTph5 line 1:␤------> say $f ⏏[-n];␤Couldn't find final ']'; gave up at /tmp/0WyZMNTph5

[19:06] <p6eval> ..…

[19:06] <TimToady> std: say $_ [-n];

[19:06] <p6eval> std 31183: OUTPUT«===SORRY!===␤Unable to parse bracketed infix at /tmp/8bgX1ymtcA line 1:␤------> say $_ ⏏[-n];␤Couldn't find final ']'; gave up at /tmp/8bgX1ymtcA line 1:␤------> say $_ [-⏏n];␤Parse failed␤FAILED 00:01 106m␤»

[19:07] <TimToady> std: [-n]

[19:07] <p6eval> std 31183: OUTPUT«===SORRY!===␤Undeclared routine:␤      'n' used at line 1␤Check failed␤FAILED 00:01 105m␤»

[19:07] <TimToady> curious

[19:08] <TimToady> I guess that's correct.

[19:08] *** cognomore joined
[19:10] *** cognomore left
[19:10] <[particle]> the second example is parsing as 'term($_) infix_op([-n])'  and the third as 'circumfix_op([]) op(-) term(n)' ?

[19:11] <[particle]> something like that, didn't show the parent-child relationship there

[19:11] <[particle]> *prefix_op(-)

[19:12] <[particle]> so, with '$_ [-n]', circumfix [] would create a term, and two terms in a row is illegal, so it reparses as infix [] ?

[19:13] <[particle]> std: [-n] $_

[19:13] <p6eval> std 31183: OUTPUT«===SORRY!===␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/bW1TDITyEg line 1:␤------> [-n] ⏏$_␤    expecting any of:␤     bracketed infix␤  infix or meta-infix␤      statement modifier loop␤Undeclared routine:␤       

[19:13] <p6eval> ..'n' used at line 1␤P…

[19:15] <[particle]> should the 'Unable to parse bracketed infix' give a 'Two terms in a row' error?

[19:15] *** szabgabx joined
[19:16] <[particle]> i guess i'm trying to figure out why it fails to parse.

[19:16] <pmichaud> [particle]: other-way-around... it starts by trying to parse as infix.

[19:16] <pmichaud> because that is what is expected after a term.

[19:17] <[particle]> ah, right-o

[19:17] <[particle]> it's too far away to be postcircumfix, so it must be infix

[19:17] <[particle]> the error message is LTA

[19:19] <[particle]> "perhaps you are missing a term after the bracketed infix, or you have whitespace between a term and bracketed postcircumfix"

[19:22] *** plainhao left
[19:23] <TimToady> "or perhaps you are just confused"

[19:24] <moritz_> when the error message points to the right location, it's not so hard to find the actual error

[19:25] <TimToady> in this case, it points to two different locations, since there could be at either place

[19:26] <TimToady> s/there/the error/  # sheesh

[19:27] <patrickas> but what about hte fix? is it easy to make it parse correctly ?

[19:27] <TimToady> um, GIGO

[19:27] <TimToady> what is your definition of "correctly"?

[19:28] <patrickas> "it's too far away to be postcircumfix, so it must be infix" makes sense when ot quoted

[19:28] <patrickas> when quoted

[19:28] <patrickas> "it's too far away to be postcircumfix, so it must be just a sting"

[19:28] <patrickas> string

[19:28] <TimToady> STD does parse it correctly in the latter case

[19:29] <TimToady> so rakudo just has to do everything that STD does.  :)

[19:29] <patrickas> oh ok it's that simple then ;-)

[19:31] <Wolfman2000> Afternoon. As a heads up, I now have screen recording software on here. If requested, do you think it may be a good idea to have some sort of Perl 6 video tutorial series?

[19:31] <patrickas> std: sub my-foo () {};  my-foo();

[19:31] <p6eval> std 31183: OUTPUT«ok 00:01 105m␤»

[19:31] <patrickas> rakudo: sub my-foo () {};  my-foo();

[19:31] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Malformed my at line 11, near "-foo();"␤»

[19:31] <moritz_> it's certainly worth a try, Wolfman2000 

[19:32] <patrickas> alpha: sub my-foo () {};  my-foo();

[19:32] <p6eval> alpha 30e0ed: OUTPUT«Malformed declaration at line 10, near "-foo();"␤in Main (file <unknown>, line <unknown>)␤»

[19:32] <moritz_> I personally dislike video tutorials, because they force a certain speed on you. Others love them

[19:32] <Wolfman2000> I did wonder about that...then again, isnt' that what pausing is for?

[19:33] <moritz_> for me it's usually more about fast-forwarding, becuse I love to skim first

[19:33] *** masak joined
[19:33] <masak> ahojte!

[19:33] <moritz_> \o/ it's masak

[19:33] <Wolfman2000> Hmm......alright, good point

[19:33] <Wolfman2000> afternoon masak

[19:34] <Wolfman2000> Well, now I have two choices for a first real screen recording project: something Perl 6 related, or a tutorial for using a javascript app on my website.

[19:34] <Wolfman2000> This will certainly not be a boring few weeks now.

[19:34] <masak> Tene: dang, we made almost the same commit! :)

[19:34] <masak> I should have pushed mine while I had the chance.

[19:34] <Tene> :)

[19:34] <Tene> masak: your bit earlier about overriding say doesn't work in alpha.

[19:35] *** justatheory left
[19:35] <masak> whatever you say. I have a working version here. :)

[19:35] <masak> just need to rebase a bit now... :/

[19:35] <Tene> alpha: { sub say(*@args) {}; say 1 }; say 2

[19:35] <p6eval> alpha 30e0ed:  ( no output )

[19:35] <patrickas> hello masak

[19:35] <masak> o/

[19:35] <moritz_> alpha: { my sub say(*@args) {}; say 1 }; say 2

[19:35] <p6eval> alpha 30e0ed: OUTPUT«2␤»

[19:36] <moritz_> Tene: alpha defaulted to 'our' subs

[19:36] <TimToady> patrickas: offhand, I'd guess the problem is that rakudo doesn't properly limit the precedence of EXPR inside quotes to methodcall precedence

[19:36] <moritz_> but lexical subs did work, mostly

[19:36] <Tene> alpha: { my sub say(*@args) {}; eval 'say 1'; }; say 2;

[19:37] <p6eval> alpha 30e0ed:  ( no output )

[19:37] <patrickas> TimToady: could be ... I don't think I'm qualified to comment on that though :-)

[19:37] <TimToady> that never stops most people from commenting  :)

[19:37] <patrickas> in that case... yes you're probably right, that's probably the problem!

[19:37] <Tene> I may not have any idea what I'm saying, but I'll assert to the death my right to say it?

[19:39] <jnthn> TimToady: I'd love it if that's all it is.

[19:39] * jnthn checks

[19:39] <moritz_> masak: from a quick glance, both patches (book + pseudolatex) look rather fine

[19:39] <masak> Tene: there. my changes made it in. let me know what you think.

[19:39] <masak> moritz_: oh, good.

[19:39] <Tene> Mmm, cherries.

[19:40] <masak> moritz_: I'm feeling terribly distracted today, so if you want, you can apply them.

[19:40] <moritz_> even contains a test

[19:40] <moritz_> masak: I probably won't get around to it today, put probably tomorrow :-)

[19:40] <jnthn> We parse <EXPR('y=')>

[19:41] <jnthn> Perl6::Grammar.O(':prec<y=>, :assoc<unary>', '%methodcall');

[19:41] <jnthn> So, not that. :-(

[19:41] <jnthn> Woulda been an easy fix.

[19:41] <Tene> masak: hrrm... I'd much prefer overriding print and say to call $.emit

[19:42] <Tene> so you can usefully override method emit in subclasses.

[19:42] <masak> I briefly considered such a scheme.

[19:42] <masak> it looks like a sort of dynamic override of print and say, as opposed to a lexical one.

[19:42] <masak> I don't know if it's possible.

[19:43] <patrickas> 4 minutes between commenting on something I am not qualified enough for, and being proven wrong :-) not bad 

[19:43] <patrickas> ok another question how can I know if a list of parameters I have match a certain sub's signature something like : if ( $sub.signature ~~ (|@params) ) , short of trying to call the sub and seing if it works

[19:43] <Tene> masak: well, we could always $*OUT = ...

[19:43] <Tene> ;)

[19:43] <patrickas> does the question even make sense ... if i want to do that am I probably doing somethign wrong ?

[19:43] <masak> Tene: yes, I started doing that. works in alpha, but not in master.

[19:44] <moritz_> rakudo: my @a = 2, 3; sub f ($x) { }; say ?(\(|@a) ~~ &f.signature)

[19:44] <p6eval> rakudo a54677: OUTPUT«1␤»

[19:44] <Tene> Oh, you... um... reverted my commit?  Author tene, committer masak?

[19:44] <moritz_> huh

[19:44] <masak> I accidentally your commit. :/

[19:45] <masak> it was semi-accidental actually, since I cared a bit for my solution, and this was an easy way to show them to you before they got even more difficult to rebase into the branch.

[19:45] <Tene> nodnod

[19:46] <Tene> I'm a little bit unhappy with overriding print for that, as I can imagine legitimate reasons to print while rendering a template.

[19:46] <masak> I'm still open to adopting your solution.

[19:46] <moritz_> patrickas: I fear that it's not easy in rakudo right now, if implemented at all...

[19:46] <Tene> And, yeah, that's fine.  I was just confused by the commit.

[19:46] <moritz_> patrickas: and I know what you need it for :=)

[19:46] <masak> either we use print exclusively in the 'serialize a piece of template' sense, or we use something else.

[19:47] <Tene> I'd define an 'emit' method or lexical sub.

[19:47] <patrickas> heheh moritz_ i bet you do ...

[19:47] <moritz_> rakudo: my @a = 2, 3; sub f ($x) { }; say ?(\@a ~~ &f.signature)

[19:47] <p6eval> rakudo a54677: OUTPUT«1␤»

[19:47] <masak> I kinda like the idea of hijacking print and say for serialization, but seeing how it only partially works in both alpha and master... maybe better to use an emit method, yes.

[19:47] <Tene> I guess I can imagine wanting to re-use some other framework that calls print or say or something, but I'm reluctant to try to find every possible way to print to stdout and override that... rather just override $*OUT

[19:48] <Tene> Lemme see how that works in alpha.

[19:48] <masak> I tried overriding it with an anonymous class. didn't quite get it to work.

[19:48] <masak> I might have gotten it to work before. I know I submitted a bug about it once, and it got fixed.

[19:49] <Tene> replacing it with a different fh works...

[19:49] *** gbacon left
[19:49] <Tene> my $*OUT = open('lol.txt', :w);

[19:49] <masak> alpha: $*OUT := class { method say(*@args) {} }; say 42

[19:49] <p6eval> alpha 30e0ed: OUTPUT«rtype not set␤in Main (file <unknown>, line <unknown>)␤»

[19:50] <masak> or it didn't get fixed. :/

[19:50] *** ggoebel left
[19:50] <Tene> masak: that's binding $*OUT to a class

[19:51] <masak> an anonymous class.

[19:51] <Tene> don't you want an instance of that class instead?

[19:51] <masak> alpha: $*OUT := class { method say(*@args) {} }.new; say 42

[19:52] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near ".new; say "␤in Main (file <unknown>, line <unknown>)␤»

[19:52] <masak> alpha: $*OUT := (class { method say(*@args) {} }).new; say 42

[19:52] <p6eval> alpha 30e0ed: OUTPUT«rtype not set␤in Main (file <unknown>, line <unknown>)␤»

[19:52] <Tene> alpha: class A { method say(*@args) { print "XXX\n"; } } my $*OUT = A.new(); say 'lol';

[19:52] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "my $*OUT ="␤in Main (file <unknown>, line <unknown>)␤»

[19:52] <masak> semicolon.

[19:52] <Tene> oops

[19:52] <Tene> alpha: class A { method say(*@args) { print "XXX\n"; } }; my $*OUT = A.new(); say 'lol';

[19:52] <p6eval> alpha 30e0ed: OUTPUT«too many positional arguments: 2 passed, 1 expected␤in Main (file <unknown>, line <unknown>)␤»

[19:52] <masak> I got that before too.

[19:52] <masak> don't know why.

[19:52] <Tene> that's what I keep seeing.

[19:52] <masak> my guess is it doesn't work.

[19:53] <Tene> rakudo: class A { method say(*@args) { print "XXX\n"; } }; my $*OUT = A.new(); say 'lol';

[19:53] <p6eval> rakudo a54677: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in 'Mu::print' at line 1132:CORE.setting␤  in 'print' at line 4624:CORE.setting␤  in 'A::say' at line 11:/tmp/MXaGFRqvjo␤  in 'say' at line 4631:CORE.setting␤  in main program body at line 11:/tmp/MXaGFRqvjo␤»

[19:53] <Tene> ... ><

[19:53] *** patrickas left
[19:54] <masak> heh, conspiracy nuts keep retweeting my ufo project.

[19:54] <jnthn> masak: It's because .print will print to $*OUT

[19:54] <masak> oh!

[19:54] <jnthn> Which now doesn't has a print method because...

[19:54] <Tene> yeah

[19:54] <jnthn> Well, it inherits the one from Mu

[19:54] <Tene> alpha: my $fh = $*OUT; class A { method say(*@args) { $fh.say("XXX"); } }; my $*OUT = A.new(); say 'lol';

[19:54] <jnthn> Which expects to get no args, and wants to print its invocant. :-)

[19:54] <p6eval> alpha 30e0ed: OUTPUT«XXX␤»

[19:54] <Tene> WFM

[19:56] <masak> Tene: might also be solved with both a .say and a .print method, by what jnthn said.

[19:56] <Tene> masak: that's what I'm doing now.

[19:57] <masak> happy tweet: http://twitter.com/sdanna/status/15789982971 \o/

[19:58] <jnthn> is happy.

[19:59] * jnthn tries to settle down for some slide writing

[19:59] *** estrabd_pgh218 left
[20:00] * colomon would like to write a slide some day

[20:00] <TimToady> phone

[20:00] <jnthn> |\

[20:00] <masak> jnthn: when's the presentation?

[20:00] <TimToady> .u phone

[20:00] <phenny> TimToady: Sorry, no results for 'phone'.

[20:01] <jnthn> masak: Sunday

[20:01] <TimToady> .u telephone

[20:01] <phenny> U+2121 TELEPHONE SIGN (℡)

[20:01] <masak> jnthn: plenty of time :P

[20:01] <jnthn> masak: :P

[20:01] <TimToady> .u ☎

[20:01] <phenny> U+260E BLACK TELEPHONE (☎)

[20:01] <jnthn> masak: Yeah but...I want to be free to drink vok^W^Wsocialize on the Friday night.

[20:01] <jnthn> masak: And Saturday is hackathon.

[20:01] <Tene> masak: are you really attached to "serialize"?  How about "render" instead?

[20:01] <masak> Tene: "render" is better.

[20:02] <masak> Tene: I just didn't like "do" :)

[20:02] <Tene> Yeah.  Agreed.

[20:03] *** Psyche^ joined
[20:03] * colomon but will stick to reels and occasionally jigs and hornpipes until he feels he understands slides better.

[20:04] <Tene> pushed

[20:04] <pmichaud> (phone, on my way)

[20:05] *** justatheory joined
[20:05] <Tene> masak: how about some markup like %= for attrs?  Then we could experiment with defining markup additions in an extensible way...

[20:06] <masak> Tene: did you see my .<key> suggestion?

[20:06] <Tene> masak: won't always work... like inside a for loop.

[20:07] <masak> true, that's a drawback.

[20:07] *** mod_cure joined
[20:08] *** Patterner left
[20:08] *** Psyche^ is now known as Patterner

[20:08] <masak> likely a fatal one.

[20:08] <Tene> maybe an @!transforms that holds arguments to subst(), that we iterate over?

[20:08] <Tene> $source.=subst($_[0], $_[1], :g) for @!transforms;

[20:08] <Tene> @.transforms, really.  Shoudl be modifiable.

[20:09] <cognominal> speaking of booze,  jnthn,  I just bought the Chartreuse. But without BooK, it will test bland.

[20:09] <masak> and .key, .value rather than $_[0], $_[1] :)

[20:09] <masak> pairs look more p6-y :)

[20:09] <Tene> Yeah.

[20:09] <jnthn> cognominal: Aww.

[20:09] <jnthn> cognominal: For the FPW?

[20:09] <cognominal> yup

[20:09] <Tene> %.transforms

[20:10] <jnthn> cognominal: Too bad I'll be missing that.

[20:10] <jnthn> cognominal: You coming to YAPC::EU? ;-)

[20:10] <cognominal> that's his daughter third anniversary

[20:10] <cognominal> jnthn, 

[20:10] <cognominal> I may

[20:10] <jnthn> cognominal: Well, I suspect that's rather more important than weird green liquid. :-)

[20:11] <cognominal> If I finish my slides engine for Friday, I may have something to present in Perl 6

[20:11] <cognominal> jnthn, that's what his wifte told him... :)

[20:12] <cognominal> and it is not green,  it is chartreuse :)   ask TimToady 

[20:12] *** estrabd joined
[20:13] <jnthn> cognominal: After you drink enough of it, it gets hard to distinguish. ;-)

[20:13] <cognominal> and BooK will probably miss YAPC::EU too. His wife is expecting their second child at this time.

[20:15] <masak> %.transforms or @.transforms; doesn't much matter, I think.

[20:15] *** patrickas joined
[20:15] <masak> anyway, Ratel seems to be in good hands. Tene++

[20:15] <masak> I'll spend some time on the tutorial.

[20:15] <Tene> masak: you know the right constructory things to do for alpha?

[20:15] <Tene> I don't remember if that has changed since alpha.

[20:16] <Tene> Oh, I guess i could check the tests.

[20:16] <masak> aye.

[20:16] <masak> a new method mostly looks like this inside:

[20:16] <masak> self.bless(*, :attr1("blah"), :attr2("blah"))

[20:17] <Tene> I just want to initialize some bits if necessary... isn't there a BUILD or something for that?

[20:17] <[Coke]> sorear++ viv

[20:17] <masak> BUILD is an initializer submethod, yes.

[20:18] <masak> don't define a .new method unless you want to deviate from the standard argument passing mechanism. if it works as it is, BUILD is usually fine.

[20:18] <Tene> right

[20:20] *** supernovus joined
[20:22] <masak> 'what you do is you start with a vision of the product and one by one remove the technical obstacles until it's realized' -- Ed Land, Polaroid's founder. that's a nice way to think about software too.

[20:22] <supernovus> A nice new bug to report.

[20:24] <PerlJam> masak++ indeed

[20:24] <supernovus> When trying to use a library with an augment statement in it, the latest rakudo (as of 30 mins ago) tells me:  Confused at line 5, near "augment cl"

[20:25] <supernovus> it works if I do it in an interactive shell though

[20:25] <masak> supernovus: works here.

[20:25] <PerlJam> supernovus: are you sure there isn't an error in the code jsut before the augment declaration?

[20:25] <PerlJam> s/jsut/just/

[20:25] <masak> supernovus: there must be something else afoot. either that, or my Rakudo is too old.

[20:25] <supernovus> if I take out the use MONKEY_TYPING; line it gives me Can't augment class Int without 'use MONKEY_TYPING'

[20:25] <supernovus> which is appropriate

[20:26] <PerlJam> supernovus: pastebin the code.

[20:26] <masak> supernovus: please nopaste.

[20:27] <TimToady> moritz_: re http://www.perlmonks.org/?node_id=843880 I'd point out that <?ww>\s+ can never match anything; the real ws rule is more like just <!ww>\s*

[20:30] *** TimToady sets mode: +vvv buubot dalek hugme

[20:30] *** TimToady sets mode: +vv ilogger2 IRSeekBot

[20:30] *** TimToady sets mode: +vv p6eval phenny

[20:30] *** TimToady sets mode: +v pugssvn

[20:31] <Tene> masak: pushed.

[20:31] * masak looks

[20:32] <Tene> Ratel.new(:source($text)).render(...)

[20:32] <Tene> moved the 'compile' method to be the 'source' accessor.

[20:32] <supernovus> Hmm, I tried a different file with augment and it worked fine, so it's something else in the file in question...

[20:32] <supernovus> http://github.com/supernovus/PSpec/blob/newmaster/lib/Times.pm

[20:34] <Tene> Oh man, I really don't like adding such a method to Int.

[20:34] *** TimToady sets mode: +oooo [Coke] [particle] Tene masak

[20:34] *** TimToady sets mode: +oooo cognominal colomon dukeleto eternaleye

[20:34] *** TimToady sets mode: +oooo hejki japhb justatheory Juerd

[20:34] *** TimToady sets mode: +oooo mathw patrickas PerlJam sorear

[20:34] *** TimToady sets mode: +ooo spinclad Su-Shee xinming

[20:36] <supernovus> Tene: I admit, It's an evil piece of code, it would probably be better to drop the method version and use the infix operator instead, which is indeed more like the RSpec version this was based off of.

[20:36] *** kolibrie left
[20:36] <PerlJam> ah ... I was getting that ruby feeling all over and now I know why  :)

[20:37] *** kolibrie joined
[20:37] <supernovus> PerlJam: It's part of a very evil library I wrote for the January release of Rakudo called PSpec, which is a port of RSpec and Cucumber to Perl 6... done for no other reason than "nobody else had done it yet..."

[20:37] <Tene> Yeah, monkeying with the core classes is rather discouraged... definitely encourage you to use an operator instead.

[20:37] <Tene> I mean, I certainly can't stop you...

[20:38] <PerlJam> supernovus: cool.  rspec I liked.  I never could quite warm up to cucumber though.  It seemed a tad like jumping-the-shark on TDD

[20:38] <PerlJam> er, BDD I guess

[20:38] <pragma_> TimToady: you forgot me

[20:38] <masak> Tene: I like the 'my $*OUT' solution. it's dynamic in scope, which is a big win. but we won't be able to make it work on master.

[20:39] <TimToady> I've never been very pragmatic

[20:39] <jnthn> TimToady: Isn't trusting that many people quite optimistic? :-)

[20:40] * jnthn hides after that pun

[20:40] *** dju joined
[20:40] <supernovus> Tene: I tend to agree. The method was originally added as a suggestion by masak when I was having problems with the infix version. I'll probably drop it for PSpec/Pickle 3.1. I just wondered what was causing rakudo to bork when trying to run it (especially considering other files have no issues...)

[20:40] <TimToady> well, the half life of ops is pretty ferocious...

[20:41] <masak> Tene: not too happy with the .source($text) method :/ but I don't have a better idea right now, since we don't have FETCH/STORE and Proxy objects.

[20:41] <jnthn> supernovus: We had a bug recently where Rakudo could get upset because it didn't parse modules as if they were unicode. But I fixed that recently.

[20:41] <pmichaud> masak: why doesn't my $*OUT work on master?  

[20:41] *** dju left
[20:41] <masak> pmichaud: because $*OUT is readonly.

[20:41] <TimToady> why?

[20:41] <masak> oh wait. maybe 'my $*OUT' works. I'll try it.

[20:41] <pmichaud> it should work just fine

[20:41] <pmichaud> if not, it's an easy fix.

[20:41] *** dju joined
[20:41] <supernovus> jnthn: well, I'm going to remove the augmented method and see if it still fails.

[20:42] <TimToady> the whole point of making those dynvars is so you can override 'em in a scope

[20:42] <pmichaud> what TimToady++ said :-)

[20:42] <masak> rakudo: { my $*OUT = class { method print(*@args) {} }; print "OH HAI" }; print "OH HAI"

[20:42] <p6eval> rakudo a54677: OUTPUT«OH HAI»

[20:42] <masak> nevermind. it works. :)

[20:42] <masak> masak-- # FUD

[20:42] <TimToady> FUD-- # masak

[20:42] *** dju left
[20:43] <[particle]> \o # o/

[20:43] <supernovus> interestingly enough, Table.pm in the same dist has an augmented method and it has no problems. Removing the augment from Times.pm did the trick, it compiles now.

[20:44] <TimToady> [particle]: what's that, Thisbe's Chink?

[20:44] <Tene> masak: Yes, it's a compromise, and I'd prefer FETCH/STORE, but I think it's okay for now.

[20:45] <masak> Tene: also, not sure parameterized delims is something a minimalist templater needs... :)

[20:45] <[particle]> oh, sweet wall

[20:45] <[particle]> wow, i haven't seen midsummer night's dream in a long time!

[20:46] *** dju joined
[20:46] * colomon hopes to see his second outdoor production of it later this summer

[20:46] *** cure_ joined
[20:46] <TimToady> .oO(Let us take a minimalistic approach to minimalism.)

[20:46] <Tene> masak: The larger issue is what if I want to replace [%!foo%] with [% print %attrs<foo> %]

[20:46] * [particle] read "second order production"

[20:47] *** dju left
[20:47] <PerlJam> supernovus: oh ... it's your module declaration.

[20:47] <PerlJam> (it's in the wrong place :)

[20:47] *** dju joined
[20:48] *** mod_cure left
[20:48] <supernovus> Interesting. 

[20:49] <supernovus> I am assuming it's because it was the statement form instead of the block form.

[20:50] <TimToady> nap &

[20:50] <supernovus> The alpha branch allowed you to put stuff before a module/class statement :-)

[20:50] *** dju left
[20:51] *** dju joined
[20:51] <Tene> It was wrong.

[20:51] <masak> not so sure it was.

[20:52] <masak> you should be allowed to put use statements before, for example.

[20:52] *** dju left
[20:52] <masak> so that you can 'use A' before doing 'class B is A;'

[20:52] *** dju joined
[20:52] <Tene> Maybe.

[20:55] <PerlJam> or the calling envinronment must have seen A already.

[20:55] <supernovus> In fact, it appears that use statements are allowed. I have another file with a use statement before a role statement and it works fine.

[20:55] <PerlJam> what does the spec say?

[20:57] *** ggoebel joined
[20:57] <PerlJam> ah ... "only allowed as the first declaration in a compilation unit"

[20:57] <supernovus> "The first form is allowed only as the first declaration in a compilation unit (that is, file or eval string)."

[20:57] <supernovus> ah you beat me to it

[20:58] *** kw47129 joined
[20:58] <supernovus> I think the way the new rakudo works is probably a lot closer to the spirit of the spec. It allows use statements, but nothing else.

[20:59] *** Guest54878 left
[20:59] <supernovus> Basically, my old code was depending on a misfeature of the alpha branch that shouldn't have worked in the first place. So my own fault for not reading the spec more closely :-)

[21:00] <PerlJam> supernovus: are you sure you really mean "nothing else"

[21:02] <supernovus> No, I'm not sure I mean "nothing else". But as I'm not very well versed in the nature of compilers, I think it's a simplification to say "no direct functional code can be placed before a package/module/class/role statement, although certain compilation-stage statements such as 'use' may be used."

[21:03] *** kw47129 left
[21:03] *** LionMadeOfLions joined
[21:09] <masak> rakudo: role Lion[::T] {}; my Lion[Lion] $x

[21:09] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤In "my" declaration, typename Lion must be predeclared (or marked as declarative with :: prefix) at line 11, near "[Lion] $x"␤»

[21:10] <masak> std: role Lion[::T] {}; my Lion[Lion] $x

[21:10] <p6eval> std 31183: OUTPUT«ok 00:01 110m␤»

[21:13] <masak> jnthn: what's happening there?

[21:13] <masak> jnthn: why does Rakudo say that Lion isn't predeclared?

[21:15] <diakopter> cuz Lion`1[] is predeclared, not Lion

[21:15] <diakopter> (/me guesses)

[21:16] <masak> a reasonable guess.

[21:16] <masak> rakudo: role Lion[::T] {}; my Lion[Int] $x

[21:16] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤In "my" declaration, typename Lion must be predeclared (or marked as declarative with :: prefix) at line 11, near "[Int] $x"␤»

[21:16] <masak> which doesn't hold up. :)

[21:17] <diakopter> maybe variables can't be typed as roles

[21:17] <masak> rakudo: role Lion[::T] {}; class LionMadeOfLions does Lion[Lion] {}

[21:17] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Could not find sub &chars␤»

[21:17] <masak> whoa! :)

[21:18] * masak submits rakudobug

[21:18] <diakopter> rakudo: role Lion[::T] {}; my Int[Lion] $x

[21:18] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤In "my" declaration, typename Int must be predeclared (or marked as declarative with :: prefix) at line 11, near "[Lion] $x"␤»

[21:18] <diakopter> heh

[21:18] <masak> seems it doesn't like the [] there, and complains about something else.

[21:19] <diakopter> I'm guessing rakudo distinguishes between Typename and Rolename

[21:20] <diakopter> and variables look only for Typename, which I guess can't contain []

[21:20] <diakopter> variable *declarations

[21:20] <diakopter> (/me another blind guess)

[21:21] <jnthn> rakudo: role Lion[::T] {}; my Lion of Lion $x;

[21:21] <p6eval> rakudo a54677: OUTPUT«No applicable candidates found to dispatch to for '_block62'. Available candidates are:␤:(Mu ::T )␤␤  in <anon> at line 1␤  in <anon> at line 2:/tmp/QZimRFVWDJ␤  in main program body at line 1␤»

[21:21] <jnthn> rakudo: role Lion[::T?] {}; my Lion of Lion $x;

[21:21] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Unable to parse def_module_name, couldn't find final ']' at line 11␤»

[21:21] <jnthn> rakudo: role Lion[::T = Mu] {}; my Lion of Lion $x;

[21:21] <p6eval> rakudo a54677:  ( no output )

[21:22] <jnthn> rakudo: role Lion[::T = Mu] {}; my Lion[Lion] $x;

[21:22] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤In "my" declaration, typename Lion must be predeclared (or marked as declarative with :: prefix) at line 11, near "[Lion] $x;"␤»

[21:22] <masak> '[BUG] Error when reporting an error during parsing caused by doing a role with Lions containing each other in Rakudo' -- funniest bug report description in a while :)

[21:22] <jnthn> Hmm, maybe we don't parse that work.

[21:22] <jnthn> *that form

[21:22] <jnthn> Or know what to do with it.

[21:22] <jnthn> Curious.

[21:22] <diakopter> er and er

[21:22] * masak was just thinking that!

[21:22] <diakopter> stop stealing my thoughts!

[21:23] <jnthn> But it's not a surprse that you get an error

[21:23] <masak> I'm never surprised at getting an error :P

[21:23] *** hercynium left
[21:23] <jnthn> Since there's no variant of Lion that takes no parameters.

[21:23] <masak> right. what diakopter said, IOW.

[21:23] <jnthn> I'm only semi-following. :-)

[21:24] <jnthn> Ah, I see.

[21:24] <jnthn> It's still a bit odd.

[21:24] <jnthn> rakudo: my Positional of Positional of Int $foo;

[21:24] <p6eval> rakudo a54677:  ( no output )

[21:24] <jnthn> rakudo: my Positional[Positional[Int]] $foo;

[21:24] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤In "my" declaration, typename Positional must be predeclared (or marked as declarative with :: prefix) at line 11, near "[Positiona"␤»

[21:24] <jnthn> Yeah, it's just the bracket form.

[21:25] *** Su-Shee left
[21:25] <diakopter> std: my ::Positional[::Positional[Int]] $foo;

[21:25] <p6eval> std 31183: OUTPUT«ok 00:01 105m␤»

[21:25] <diakopter> rakudo: my ::Positional[::Positional[Int]] $foo;

[21:25] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤Malformed my at line 11, near "::Position"␤»

[21:25] <masak> I'd like to see a parody of "Androcles and the Lion" which punchlines with "but the Lion didn't eat him, because there wasn't a role factory that could create Lion[Human]".

[21:25] <arnsholt> =D

[21:26] <masak> thanks, I'll be here all week. try the veal.

[21:26] <jnthn> omnomnom veal

[21:27] <diakopter> rakudo: my ::foo $x; say $x

[21:27] <p6eval> rakudo a54677: OUTPUT«Null PMC access in type()␤  in main program body at line 11:/tmp/BExmqw507I␤»

[21:29] * masak submits rakudobug

[21:29] <diakopter> uh oh.

[21:29] <masak> a phantom-typed variable!

[21:29] <diakopter> masak: you're encouraging my rakudofuzzing

[21:29] <masak> of course!

[21:29] <jnthn> I'm pretty sure ::whatever exploding is already in there.

[21:31] <masak> there are related tickets, for sure: http://rt.perl.org/rt3/Ticket/Display.html?id=64642 is one.

[21:32] <masak> but I find none exactly like this. so I'm submitting it.

[21:32] <jnthn> I've no idea what we're supposed to do in such cases

[21:32] <masak> fail at compile-time? ignore the typing? let demons fly out of the user's nose?

[21:33] <jnthn> I'd prefer a Null PMC Access to my nose demons escaping.

[21:33] <jnthn> Maybe the spec says what to do somewhere. :-)

[21:34] <masak> maybe.

[21:34] <PerlJam> It would be cool if "Null PMC Access" came out as something like "you have a demon infestation"

[21:34] <jnthn> rakudo: say [mod] 100, 99, 88, 77, 66, 55, 44

[21:34] <p6eval> rakudo a54677: OUTPUT«1␤»

[21:35] <masak> \o/

[21:35] <jnthn> colomon: Didn't you write tests for that one?

[21:35] * jnthn just spotted the ticket is still open

[21:36] *** Ross left
[21:38] <supernovus> I hope := makes a return soon. The SCGI library depends on the IO::Socket::INET core module which depends on := and is currently broken. I'm guessing that means other network libraries such as HTTP::Daemon are also broken at the moment.

[21:39] *** Amadiro joined
[21:39] <colomon> jnthn: yesterday or the day before, yes.

[21:40] <diakopter> rakudo: my ::&a &a #masak

[21:40] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[21:40] <masak> :D

[21:40] * masak submits rakudobug

[21:40] <diakopter> that's a parser compiler problem, I'd guess

[21:40] <masak> that error usually is.

[21:41] <masak> std: my ::&a &a

[21:41] <p6eval> std 31183: OUTPUT«ok 00:01 106m␤»

[21:41] <masak> I wouldn't ok that :P

[21:41] <jnthn> wtf.

[21:41] <masak> diakopter++ # insane

[21:41] <diakopter> wtdiakopter

[21:42] <diakopter> std: (my ::&a) &a

[21:42] <p6eval> std 31183: OUTPUT«ok 00:01 106m␤»

[21:42] <diakopter> std: (my :: &a) &a

[21:42] <p6eval> std 31183: OUTPUT«ok 00:01 106m␤»

[21:42] <masak> o.O

[21:42] <diakopter> std: (my :: &a) & a

[21:43] <p6eval> std 31183: OUTPUT«ok 00:01 106m␤»

[21:43] <jnthn> rakudo: my ::foo $x;

[21:43] <p6eval> rakudo a54677: OUTPUT«Null PMC access in type()␤  in main program body at line 11:/tmp/SNMKIm95YU␤»

[21:43] <masak> std: my my my my &a &a &a &a

[21:43] <jnthn> masak: You only got a birdie, not a hole in one. :P

[21:43] <p6eval> std 31183: OUTPUT«===SORRY!===␤Malformed my at /tmp/J4zIcqzdNM line 1:␤------> my ⏏my my my &a &a &a &a␤    expecting any of:␤      scoped declarator␤        typename␤Parse failed␤FAILED 00:01 104m␤»

[21:43] <masak> jnthn: oops. thought diakopter had golfed it already. :/

[21:43] *** nimiezko joined
[21:43] <masak> jnthn: will update the ticket.

[21:44] <diakopter> hee

[21:44] <jnthn> :-)

[21:44] <jnthn> masak: Yeah, I was looking at it thinking "hmm, I know how that code works and I'm surprised we make it past the declaration" :)

[21:45] <masak> :)

[21:45] <jnthn> rakudo: my Positional of Positional[Int] $x; # just curious

[21:45] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤In "my" declaration, typename Positional must be predeclared (or marked as declarative with :: prefix) at line 11, near " of Positi"␤»

[21:46] *** clintongormley left
[21:46] <jnthn> std: my Int<omg>;

[21:46] <p6eval> std 31183: OUTPUT«===SORRY!===␤Malformed my at /tmp/UcfOVys1K_ line 1:␤------> my Int⏏<omg>;␤    expecting any of:␤ multi_declarator␤ scoped declarator␤        typename␤Parse failed␤FAILED 00:01 104m␤»

[21:46] <jnthn> ETOOSMART

[21:48] <diakopter> std: my ::Foo[Foo] &Foo; Foo

[21:48] <p6eval> std 31183: OUTPUT«===SORRY!===␤Illegal redeclaration of routine 'Foo' (see line 1) at /tmp/AXtoZEmNSI line 1:␤------> my ::Foo[Foo] &Foo⏏; Foo␤Check failed␤FAILED 00:01 105m␤»

[21:48] <diakopter> stdbug

[21:49] *** hercynium joined
[21:52] <masak> chromatic++ keeps turning ank's stuff into worthwhile stuff: http://www.modernperlbooks.com/mt/2010/06/an-optometrist-and-a-language-designer-walk-into-a-bar.html

[21:53] <jnthn> .oO( And they said "ouch" )

[21:54] <masak> jnthn: the bytebuffer.pmc looks very good. it will probably give us decoding, too.

[21:54] <masak> at least for UTF-8.

[21:54] <jnthn> masak: Yay

[21:55] *** arthur-_ joined
[21:55] *** arthur-_ left
[21:55] <colomon> \o/

[21:58] *** frettled left
[22:03] *** skids left
[22:06] *** estrabd is now known as estrabd_afk

[22:06] *** nimiezko left
[22:09] *** Util joined
[22:13] <diakopter> std: (:: :(:: :() :) :(::))

[22:13] <p6eval> std 31183: OUTPUT«ok 00:01 107m␤»

[22:13] <masak> ::)

[22:13] <diakopter> rakudo: (:: :(:: :() :) :(::))

[22:13] <p6eval> rakudo a54677: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[22:13] <diakopter> (no need to report that; I'm sure it's a related cause of the other parser compiler issue)

[22:15] <diakopter> std: (:: :(:: :() :) :(::):():():())

[22:15] <p6eval> std 31183: OUTPUT«ok 00:01 107m␤»

[22:16] *** envi^home left
[22:17] <pragma_> What are you trying to do?  Give the language-purists more reasons to hate on Perl?

[22:17] <pragma_> :p

[22:17] <diakopter> who me?

[22:18] <cognominal> forgot the way to call an anonymous sub from itself :(

[22:19] <cognominal> I don't see any $?SUB?

[22:20] <cognominal> &? !

[22:20] <masak> cognominal: &?ROUTINE

[22:21] <cognominal> yea, acking get you only so far when you search the wrong string :)

[22:21] <Util> pugs:   sub foo ($word) { say $word; }; our &bar := &foo.assuming( :word<<baz>> ); bar();

[22:21] <p6eval> pugs: OUTPUT«baz␤»

[22:22] <Util> rakudo: sub foo ($word) { say $word; }; our &bar := &foo.assuming( :word<<baz>> ); bar();

[22:22] <p6eval> rakudo a54677: OUTPUT«:= binding of variables not yet implemented␤  in 'infix:<:=>' at line 630:CORE.setting␤  in main program body at line 11:/tmp/4R4nPQWDtR␤»

[22:22] <Util> Any estimate on when "binding of variables" will be implemented in Rakudo?

[22:22] <Util> (or at least the binding of subs, as in the above code?)

[22:23] <lue> y o hai o/

[22:24] <masak> lue: oh hai, and good night!

[22:24] *** masak left
[22:24] <lue> :)

[22:26] <ash__> Util: does that need the binding? also, bindings partially implemented, but the specific syntax := is not 

[22:26] <ash__> rakudo: sub foo ($word) { say $word; }; our &bar = &foo.assuming( :word<<baz>> ); bar();

[22:26] <p6eval> rakudo a54677: OUTPUT«baz␤»

[22:27] *** tylerni7 joined
[22:27] *** tylerni7 left
[22:27] *** tylerni7 joined
[22:28] <Util> ash__: I was going by the .assuming examples in S06; I had not tried simple assignment. Thanks!

[22:29] <lue> rakudo: my $a = 1; my ($b is rw) := $a; $b = 42; say $a

[22:29] <p6eval> rakudo a54677: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Code $block, Any $arg?, Any :export($export)!)␤:(Mu $child, Mu $parent)␤␤  in main program body at line 11:/tmp/7CF2wqjXWW␤»

[22:29] <ash__> perlcabal got a new stylesheet didnt it? it looks different now

[22:29] <lue> either I did it wrong, or jnthn has yet to upload his fix.

[22:29] <lue> ash__ I noticed it too.

[22:29] <dalek> book: 2df1ea2 | util++ | src/subs-n-sigs.pod:

[22:29] <dalek> book: [subs] Added section on Currying

[22:29] <dalek> book: review: http://github.com/perl6/book/commit/2df1ea2b91a5236397f8ec557f4b8774194c10a5

[22:29] <dalek> book: fc9b935 | util++ |  (2 files):

[22:29] <dalek> book: Merge branch 'master' of github.com:perl6/book

[22:29] <dalek> book: review: http://github.com/perl6/book/commit/fc9b935939ed410c2b9d67ee12d55906c991b545

[22:30] <Util> (I had already `git push`ed the code with the bindings, though )

[22:31] <supernovus> dalek: exterminate!

[22:31] <lue> I tried that before. It won't :(

[22:31] <lue> [yet....]

[22:31] <ash__> rakudo: sub f($a is rw, $b is rw) { my $tmp = $b; $b = $a; $a = $tmp;  }; my $a = 1; my $b = 2; f($a, $b); say $a, $b; # that wouldn't work if some sort of binding wasn't implemented

[22:32] <p6eval> rakudo a54677: OUTPUT«21␤»

[22:32] <supernovus> lue: I think you need to "use SONIC_SCREWDRIVER;" first...

[22:33] <jnthn> lue: I have a patch locally that fixes that my ($x is rw) := 42; thingy.

[22:34] <jnthn> Will push when spectest run is done.

[22:34] <jnthn> oh, it's done

[22:34] <ash__> jnthn: you don't happen to have a patch for "my $a := 3;" ? 

[22:35] <jnthn> ash__: No

[22:35] <jnthn> 'fraid not.

[22:37] <lue> Hey, at least you can get := binding to work :D

[22:37] <lue> [somewhat]

[22:38] <Tene> what would that even mean?  Let you alter the value of 3?

[22:38] <lue> perl6: my $a := 3; say $a

[22:38] <p6eval> rakudo a54677: OUTPUT«:= binding of variables not yet implemented␤  in 'infix:<:=>' at line 630:CORE.setting␤  in main program body at line 11:/tmp/nL5hFiNw1N␤»

[22:38] <p6eval> ..pugs: OUTPUT«3␤»

[22:38] <p6eval> ..elf 31183: OUTPUT«␤»

[22:38] <Tene> perl6: my $a := 3; $a = "lolcats"; say 3;

[22:38] <p6eval> elf 31183: OUTPUT«3␤»

[22:38] <p6eval> ..rakudo a54677: OUTPUT«:= binding of variables not yet implemented␤  in 'infix:<:=>' at line 630:CORE.setting␤  in main program body at line 11:/tmp/w9XIZjH9OU␤»

[22:38] <p6eval> ..pugs: OUTPUT«*** Can't modify constant item: VInt 3␤    at /tmp/RFUHVoH3Zf line 1, column 13-27␤»

[22:39] <Tene> what are you trying to do with that?

[22:39] <cxreg> Tene: you might want very large values of 3

[22:39] <lue> it breaks brains when you assign constants like 3.

[22:39] <lue> [Yours, not rakudo's]

[22:39] <lue> s/assign/bind/ # curse my poor grammar :)

[22:42] <ash__> := is for binding, it thought, so you'd be binding a value to a variable

[22:44] *** skangas left
[22:44] <dalek> rakudo: f50c359 | jonathan++ | src/Perl6/Actions.pm:

[22:44] <dalek> rakudo: When we write my ($x is rw) := 42, make sure that we don't try and re-apply the 

[22:44] <dalek> rakudo: is rw when it's already handled in the signature.

[22:44] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f50c35907a7d185cb4678c32914e9e0b6f631c05

[22:44] <lue> .oO(= assigns a kid at the National Spelling Bee with a number, := binds you to a partner during your stint in the Marine Corps.)

[22:48] <Util> lue: binding is more like Perl5's glob assignment ( *foo = *bar; # now $bar is an alias for $foo, and changing one changes the other )

[22:49] <lue> I remember reading about using things like $a = \$b in P5

[22:54] <Util> lue: that is different. The \ operator produces a "reference" (like a pointer in C, but safer). After `$a = \$b`, you can change the value of $b like this: `${$a} = 3; # now $b is 3`. If you just said `$a = 3`, then $a would be 3, $a no longer "points" to $b, and $b is unchanged.

[22:55] <lue> Ah. Well then, I certainly don't want that. :)

[22:55] <lue> [and If I decided to go with P5, then I would have had headaches there]

[22:55] <jnthn> phenny: tell mberends when I just used proto for first time, I got an error Unable to open filehandle from path 'projects.state' - touch projects.state resolved it though.

[22:55] <phenny> jnthn: I'll pass that on when mberends is around.

[22:57] <cxreg> or Data::Alias

[22:58] <cxreg> i wonder if hare-braned things like that will work when running perl 5 code under parrot

[22:58] <Tene> phenny: tell masak When I tried to use Configure in web the first time, btw, it failed because I didn't compile rakudo in a directory called "rakudo", btw

[22:58] <phenny> Tene: I'll pass that on when masak is around.

[22:59] <[Coke]> btw, btw!

[22:59] <Tene> btw!

[22:59] <Tene> btw?

[23:03] <jnthn> phenny: tell mberends after that, next issue on install fakedbi is (though at least it picks up the dependency) Building zavolaj...project type Str(). That was apparently though just because I didn't have perl6 in my path (it's good that it writes a helpful what went wrong log and pointed me at it)...now in theory it's installed them both. :-)

[23:03] <phenny> jnthn: I'll pass that on when mberends is around.

[23:07] *** rvperl joined
[23:10] *** justatheory left
[23:11] *** lestrrat is now known as lest_away

[23:15] *** patrickas left
[23:16] *** supernovus left
[23:31] *** felipe left
[23:36] *** justatheory joined
[23:38] *** rgrau left
[23:40] <lue> I have color in my Rakudo error output \o/ [for some reason it only takes effect w/ ===SORRY!===, but still]

[23:41] <lue> And if you ask why, it's because it's -Ofun for me :)

[23:45] *** justatheory left
[23:47] <jnthn> phenny: tell sorear I suspect that environment variables may not be making it through to Perl 5 in blizkost; using CGI (:from<perl5>), .param('blah') gave back nothing, but it works if I do my $cgi = CGI.new(%*ENV<QUERY_STRING>);

[23:47] <phenny> jnthn: I'll pass that on when sorear is around.

[23:47] <jnthn> phenny: tell sorear another mapping issue, if you have tuits; calling .param('thing that was not passed') returns a Null PMC.

[23:47] <phenny> jnthn: I'll pass that on when sorear is around.

[23:48] <jnthn> BTW, sorear++ (Blizkost built out the box on my Linux server), mberends++ (FakeDBI worked out the box there too).

[23:51] <ash__> isn't Blizkost the perl5 in parrot thing? 

[23:51] <jnthn> ash__: Yes

[23:51] <jnthn> ash__: And it works. :-)

[23:51] <ash__> cool

[23:51] <ash__> i'll have to try it out

[23:52] <jnthn> http://188.40.91.7/cgi-bin/test.p6?name=ash

[23:52] <jnthn> It uses Perl 6 FakeDBI to fetch a list of countries from a database

[23:53] <jnthn> And Perl 5 CGI, accessed through Blizkost.

[23:53] <ash__> wow nice

[23:53] *** fridim left
[23:53] <jnthn> Yeah, especially that I got it to work on my server in < 1 hour, going from having none of the above installed.

[23:54] <ash__> thats awesome, 

[23:54] <jnthn> Some rough edges.

[23:54] * ash__ has even more motivation to fix my old desktop into a server 

[23:54] <jnthn> But pleasing that it wasn't a terrifying nightmare of hate. :-)

[23:55] <sorear> jnthn: What's .param?

[23:55] <phenny> sorear: 23:47Z <jnthn> tell sorear I suspect that environment variables may not be making it through to Perl 5 in blizkost; using CGI (:from<perl5>), .param('blah') gave back nothing, but it works if I do my $cgi = CGI.new(%*ENV<QUERY_STRING>);

[23:55] <phenny> sorear: 23:47Z <jnthn> tell sorear another mapping issue, if you have tuits; calling .param('thing that was not passed') returns a Null PMC.

[23:55] <jnthn> sorear: Ah, sorry, shoulda been more clear

[23:56] <jnthn> sorear: A method on CGI

[23:56] <ash__> I wonder how much work it would be to make a CGI.pm for rakudo (or is there one already) 

[23:56] <sorear> jnthn: the %ENV stuff isn't surprising me at all

[23:56] <jnthn> sorear: my $cgi = CGI.new; say $cgi.param('name'); # should get name from the query string.

[23:56] <jnthn> sorear: That bit is workaroundable but was the first thing I ran into.

[23:57] <sorear> as for null PMCs, that's probably Parrot's fault

[23:57] <jnthn> sorear: The Null PMC OTOH, is a bit less nice, sicne there's no way really (other than a try block :-/) of checking if a parameter was in the query string.

[23:57] <sorear> blizkost maps all returns as flattened arrays

[23:57] <jnthn> Ah.

[23:57] <jnthn> But what if there's no return value?

[23:57] <sorear> if .param returns a zero-element list to signal failure (not unheard of due to the if (my ($var) = one-or-zero-values) idiom)

[23:58] <jnthn> Ah, yeah, Parrot will :flat that and we get a Null PMC.

[23:58] <sorear> does rakudo use a custom binder?

[23:58] <jnthn> Yes, but not for returns.

[23:58] <sorear> I see

[23:58] *** snarkyboojum joined
[23:58] <jnthn> i mean, we'll be emitting like

[23:58] *** tedv joined
[23:59] <jnthn> $P0 = $P1.'param'('name') # approximately

[23:59] <jnthn> Thing is, that if you :flat an empty array then $P0 will end up as null.

[23:59] <jnthn> You're right, it's a Parrot semantic.

[23:59] <jnthn> I'm not sure what best to do in order to work around it.

