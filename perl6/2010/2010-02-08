[00:00] <lue> I want to set it as my wallpaper, but then I might not read it :( (only 1024*768)

[00:07] <lue> bah. I'll crop it later, then I can read it as my wallpaper :)

[00:16] <lue> ng: my @rray=0..*;say @rray;

[00:17] <p6eval> ng 5635e9:  ( no output )

[00:17] <lue> ng: my @rray=[0,1,2]; say @rray[0..*];

[00:17] <p6eval> ng 5635e9: OUTPUTÂ«No applicable candidates found to dispatch to for 'postcircumfix:<[ ]>'â¤current instr.: '!postcircumfix:<[ ]>' pc 306755 (src/gen/core.pir:39353)â¤Â»

[00:17] <lue> ng: my @rray=0..2; say @rray[0..*];

[00:17] <p6eval> ng 5635e9: OUTPUTÂ«No applicable candidates found to dispatch to for 'postcircumfix:<[ ]>'â¤current instr.: '!postcircumfix:<[ ]>' pc 306755 (src/gen/core.pir:39353)â¤Â»

[00:21] <lue> how does an array store a range? Questions...

[00:23] <lue> ng: say 0..3.minmax

[00:23] <p6eval> ng 5635e9: OUTPUTÂ«Method 'minmax' not found for invocant of class 'Integer'â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[00:23] *** cognominal left
[00:23] <lue> ng: say (0..3).minmax

[00:24] <p6eval> ng 5635e9: OUTPUTÂ«03â¤Â»

[00:24] <lue> ng: my @rray=0..3;say @rray.minmax

[00:24] <p6eval> ng 5635e9: OUTPUTÂ«Method 'minmax' not found for invocant of class 'Array'â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[00:24] <lue> grrr

[00:24] <mberends> lue: ng is probably too incomplete to explore Perl 6 today, You could try rakudo: instead of ng: for many commands.

[00:25] <lue> yeah, trying to fix whatever indices. Trying to find where and how to implement it...

[00:25] <lue> rakudo: my @rray=0..3;say @rray.minmax

[00:25] <p6eval> rakudo 1d4928: OUTPUTÂ«Method 'minmax' not found for invocant of class 'Perl6Array'â¤in Main (file src/gen_setting.pm, line 324)â¤Â»

[00:25] <lue> pugs: my @rray=0..3;say @rray.minmax

[00:25] <p6eval> pugs: OUTPUTÂ«*** No such method in class Array: "&minmax"â¤    at /tmp/Ell1aSMesK line 1, column 19 - line 2, column 1â¤Â»

[00:34] *** ash_ joined
[00:47] *** phenny left
[00:48] <diakopter> anyone around? hi!

[00:49] <lue> yes! just figuring stuff out.

[00:49] <lue> whatever indices, mainly.

[00:50] <lue> pugs: @rray=[0,1,2]; say @rray[0..*];

[00:50] <p6eval> pugs: OUTPUTÂ«*** â¤    Unexpected "=["â¤    expecting "::"â¤    Variable "@rray" requires predeclaration or explicit package nameâ¤    at /tmp/63rzdlL1du line 1, column 6â¤Â»

[00:50] <lue> pugs: @rray=0,1,2; say @rray[0..*];

[00:50] <p6eval> pugs: OUTPUTÂ«*** â¤    Unexpected "="â¤    expecting "::"â¤    Variable "@rray" requires predeclaration or explicit package nameâ¤    at /tmp/mkhmm9hqMV line 1, column 6â¤Â»

[00:50] *** arnsholt left
[00:51] <lue> pugs: my @rray=[0,1,2]; say @rray[0..*];

[00:51] <p6eval> pugs: OUTPUTÂ«0 1 2â¤Â»

[00:51] <lue> pugs: my @rray=[0,1,2]; say @rray[1..*];

[00:51] <p6eval> pugs: OUTPUTÂ«â¤Â»

[00:51] <ash_> why are you using pugs? just cuirous

[00:51] <lue> to try and see how it should come out. I'd use std, but it only say OK and then a time.

[00:53] *** lestrrat is now known as lest_away

[00:54] <lue> so whatever doesn't mean "until the end of the list" (that'd be too easy).

[00:55] <lue> pugs: my @rray=[0,1,2]; say @rray[*..2];

[00:55] <p6eval> pugs: OUTPUTÂ«â¤Â»

[00:55] <ash_> you can use rakudo: or ng: if you want an actively developed version of perl6

[00:55] <lue> rakudo: my @rray=[0,1,2]; say @rray[*..2];

[00:55] <p6eval> rakudo 1d4928: OUTPUTÂ«Use of uninitialized valueâ¤Use of uninitialized valueâ¤â¤Â»

[00:55] <lue> rakudo: my @rray=[0,1,2]; say @rray[*..*]; #heh heh

[00:55] <p6eval> rakudo 1d4928: OUTPUTÂ«Use of uninitialized valueâ¤â¤Â»

[00:56] <lue> pugs: my @rray=[0,1,2]; say @rray[*..*]; #heh heh

[00:56] <p6eval> pugs: OUTPUTÂ«0 1 2â¤Â»

[00:56] <ash_> ng: my @a = 1...5; say ~@a;

[00:56] <p6eval> ng 5635e9: OUTPUTÂ«6 6 6 6 6â¤Â»

[00:56] <ash_> hmm

[00:56] <ash_> that's not right

[00:56] <colomon> ash_: woah.

[00:56] <ash_> rakudo: my @a = 1...5; say ~@a;

[00:56] <p6eval> rakudo 1d4928: OUTPUTÂ«1 2 3 4 5â¤Â»

[00:56] <ash_> thats better

[00:57] <ash_> colomon: yeah, never seen that problem before... 

[00:57] <lue> is that a problem with the array or the range? I'm guessing range.

[00:57] <ash_> ng: my @a = 1,2,3,4,5; say @a;

[00:57] <p6eval> ng 5635e9: OUTPUTÂ«12345â¤Â»

[00:57] <ash_> ng: my @a = 1,2,3,4,5; say ~@a;

[00:57] <p6eval> ng 5635e9: OUTPUTÂ«1 2 3 4 5â¤Â»

[00:57] <ash_> ng: my @a = 1...6; say ~@a[0];

[00:57] <p6eval> ng 5635e9: OUTPUTÂ«7â¤Â»

[00:58] <ash_> lue: doing * in the range is probably not working correctly

[00:58] <lue> for the ... infix, it generates numbers with a "gather loop" (in ng)

[00:59] <ash_> colomon: ... seems to be wrong in most places in ng 

[00:59] <lue> how to know if the * indices are working right? Hmmm...

[00:59] <ash_> ng: say 1...6;

[00:59] <p6eval> ng 5635e9: OUTPUTÂ«777777â¤Â»

[01:00] <ash_> ng: say 1..6; # infix .. seems alright however 

[01:00] <p6eval> ng 5635e9: OUTPUTÂ«123456â¤Â»

[01:00] *** lichtkind left
[01:01] <lue> ng: gather loop(my $calar = 0; $calar <= 6; $calar++){say take $calar;}

[01:01] <p6eval> ng 5635e9: OUTPUTÂ«Whitespace required after 'loop' at line 1, near "(my $calar"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)â¤Â»

[01:01] <lue> ng: gather loop (my $calar = 0; $calar <= 6; $calar++){say take $calar;}

[01:01] <p6eval> ng 5635e9:  ( no output )

[01:02] *** arnsholt joined
[01:02] <lue> ng: @rray=(gather loop (my $calar = 0; $calar <= 6; $calar++){take $calar;}); say @rray;

[01:02] <p6eval> ng 5635e9: OUTPUTÂ«Symbol '@rray' not predeclared in <anonymous>â¤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (src/PCT/HLLCompiler.pir:101)â¤Â»

[01:02] <lue> ng: my @rray=(gather loop (my $calar = 0; $calar <= 6; $calar++){take $calar;}); say @rray;

[01:02] <p6eval> ng 5635e9: OUTPUTÂ«7777777â¤Â»

[01:02] <lue> that gather loop is used in the ... infix.

[01:05] <lue> is ... supposed to be any different from .. ?

[01:06] <ash_> yes, ... is different than .. 

[01:06] *** mssm left
[01:06] <ash_> ... is a series operator, .. is a range

[01:07] <lue> that loop, then, seems to be broken somewhere.

[01:08] <colomon> ash_: I think it's gather / take that's actually broken.  (Sorry for the pause, was backlogging and prepping milk bottles for my boy.)

[01:08] <lue> yeah, that's what it is. Makes most sense.

[01:09] <ash_> no worries colomon 

[01:09] <colomon> actually, it looks like the old rakudo master bug where saying take $i yielded a reference to $i rather than $i's value.

[01:09] <ash_> so gather take isn't functioning properly then? 

[01:09] <colomon> There is some sort of wonkiness with captures, it may be affecting gather / take as well.

[01:10] <colomon> most of our tests have looked more like

[01:10] <lue> ng: my $i=5; say $i.VALUE;

[01:10] <p6eval> ng 5635e9: OUTPUTÂ«Method 'VALUE' not found for invocant of class 'Integer'â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[01:10] <colomon> ng: (1...5).map({$_ * 2}).eager.perl.say

[01:10] <lue> eh, worth a shot.

[01:10] <p6eval> ng 5635e9: OUTPUTÂ«(2, 4, 6, 8, 10)â¤Â»

[01:11] <colomon> See, in that case we process each iteration in the gather / take through the map before going on to the next.

[01:11] <colomon> So you wouldn't notice if it was giving you $i instead of the value of $i.

[01:11] <colomon> If that's the case, though, there's an easy patch.

[01:13] <colomon> (while waiting for compile...)

[01:13] <colomon> btw lue, I think your examples of [0..*] and [1..*] back there are misleading.

[01:13] <colomon> you said  @rray = [1, 2, 3]

[01:13] <colomon> I believe that creates a one-element array whose first element is [1, 2, 3]

[01:14] <colomon> that would certainly explain your results.

[01:14] <lue> ooh!

[01:14] *** mberends left
[01:14] <colomon> try @rray = 1, 2, 3

[01:14] <lue> ng: my @rray = 1, 2, 3; say @rray[0..*];

[01:14] <p6eval> ng 5635e9: OUTPUTÂ«No applicable candidates found to dispatch to for 'postcircumfix:<[ ]>'â¤current instr.: '!postcircumfix:<[ ]>' pc 306755 (src/gen/core.pir:39427)â¤Â»

[01:14] <lue> rakudo: my @rray = 1, 2, 3; say @rray[0..*];

[01:14] <p6eval> rakudo 1d4928: OUTPUTÂ«123Use of uninitialized valueâ¤â¤Â»

[01:14] <lue> pugs: my @rray = 1, 2, 3; say @rray[0..*];

[01:14] <p6eval> pugs: OUTPUTÂ«123â¤Â»

[01:14] <lue> pugs: my @rray = 1, 2, 3; say @rray[1..*];

[01:14] <p6eval> pugs: OUTPUTÂ«23â¤Â»

[01:15] <lue> yes, there we go. (old python habits again)

[01:15] <colomon> > my @a = 1...5; say ~@a;

[01:15] <colomon> 1 2 3 4 5

[01:15] <colomon> That's my local version, ie the patch works.

[01:16] <lue> hooray! now, back to my * indices (grumble)...

[01:17] <lue> rakudo: say (0..3).perl

[01:17] <p6eval> rakudo 1d4928: OUTPUTÂ«0..3â¤Â»

[01:18] <lue> rakudo: say (0..3).Str

[01:18] <p6eval> rakudo 1d4928: OUTPUTÂ«0 1 2 3â¤Â»

[01:18] <lue> rakudo: say (*..3).Str

[01:18] <p6eval> rakudo 1d4928: OUTPUTÂ«WhateverCode()<0x2b768446f740>â¤Â»

[01:18] <lue> rakudo: say (0..*).Str

[01:18] <p6eval> rakudo 1d4928: OUTPUTÂ«WhateverCode()<0x2ac2c1ec1740>â¤Â»

[01:18] <lue> rakudo: say (0..*).perl

[01:18] <p6eval> rakudo 1d4928: OUTPUTÂ«{ ... }â¤Â»

[01:18] <lue> rakudo: say (*..3).perl

[01:18] <p6eval> rakudo 1d4928: OUTPUTÂ«{ ... }â¤Â»

[01:19] <colomon> lue: If (*..3).Str "worked properly", you'd get an infinitely long string of numbers ending with 3.

[01:20] <lue> I know :)

[01:20] <lue> just had to see what happens.

[01:22] <lue> trying to figure out how ranges works, so I can get them to work right with *.

[01:22] <lue> rakudo: my @rray=0..4; say @rray;

[01:22] <p6eval> rakudo 1d4928: OUTPUTÂ«01234â¤Â»

[01:22] *** pnate left
[01:23] *** lest_away is now known as lestrrat

[01:26] *** Exodist joined
[01:26] <lue> rakudo my @rray=0..4; say @rray.WHAT

[01:26] <lue> rakudo: my @rray=0..4; say @rray.WHAT

[01:26] <p6eval> rakudo 1d4928: OUTPUTÂ«Array()â¤Â»

[01:27] <lue> rakudo: say (0..4).WHAT

[01:27] <p6eval> rakudo 1d4928: OUTPUTÂ«Range()â¤Â»

[01:27] *** Exodist left
[01:27] <lue> rakudo: say Array().WHAT

[01:27] <p6eval> rakudo 1d4928: OUTPUTÂ«invoke() not implemented in class 'ResizablePMCArray'â¤in Main (file <unknown>, line <unknown>)â¤Â»

[01:27] <colomon> lue: pretty sure Ranges do work right with *.

[01:27] <colomon> They just don't work in slices.

[01:28] <lue> yeah, I'm trying to figure out indices. I think i'm looking in the wrong place.

[01:28] <colomon> Try looking at Seq.

[01:28] <lue> thank you, colomon!

[01:29] <colomon> probably Seq.pir.

[01:29] <ash_> colomon: does rakudo/ng have this many precedence levels as http://perlcabal.org/syn/S06.html#Subroutine_traits (down a bit starts with category:<prefix>) lists? 

[01:29] *** lisppaste3 left
[01:29] *** lisppaste3 joined
[01:29] *** Exodist joined
[01:30] *** pnate joined
[01:30] <colomon> ng has a lot of those, but as far as I know is tighter/equiv/looser doesn't actually work yet.

[01:30] <colomon> er, I may have just answered completely the wrong thing.

[01:31] *** quietfanatic joined
[01:31] *** Exodist left
[01:31] <colomon> are those actually precedence levels?

[01:31] <dalek> rakudo/ng: 8013237 | (Erik Johansen)++ | src/core/ (2 files):

[01:31] <dalek> rakudo/ng: Add .Bool to Rat and Complex

[01:31] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/80132378e66f81467289dc122cb6865711407d6a

[01:31] <dalek> rakudo/ng: c0d94fd | (Solomon Foster)++ | src/builtins/Role.pir:

[01:31] <dalek> rakudo/ng: Merge branch 'ng' of [email@hidden.address] into ng

[01:31] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/c0d94fd87f2863bddf1f46386a0b91cfb998a8d4

[01:31] <dalek> rakudo/ng: ae60f8c | (Solomon Foster)++ | src/core/Range.pm:

[01:31] <dalek> rakudo/ng: Workaround in ... to deal with the gather / take bug.

[01:31] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/ae60f8c0a34f86e576fde11832c88ef3033ccdfc

[01:31] *** Exodist joined
[01:31] <ash_> yeah, thats what I was wondering colomon

[01:32] <colomon> If you look at line 880 of ng's Grammar.pm, that's where the precedence levels for ng are defined.

[01:33] <ash_> okay, cool

[01:33] <ash_> that helps

[01:33] <lue> rakudo: my @rray{1..7};say @rray;

[01:33] <p6eval> rakudo 1d4928: OUTPUTÂ«Confused at line 10, near "{1..7};say"â¤in Main (file <unknown>, line <unknown>)â¤Â»

[01:34] <lue> rakudo: my @rray{1..7}=2..8;say @rray;

[01:34] <p6eval> rakudo 1d4928: OUTPUTÂ«Confused at line 10, near "{1..7}=2.."â¤in Main (file <unknown>, line <unknown>)â¤Â»

[01:34] <lue> :(

[01:34] <colomon> ng: my @rray = 1..7; say @rray

[01:34] <p6eval> ng 5635e9: OUTPUTÂ«1234567â¤Â»

[01:34] <colomon> rakudo: my @rray; @rray[1..7] = 2..8; say @rray

[01:34] <p6eval> rakudo 1d4928: OUTPUTÂ«Use of uninitialized valueâ¤2345678â¤Â»

[01:35] <lue> looking at S09 for indices, it uses {}.

[01:35] <ash_> ng: my @a; @a[1..3] = 2..4; 

[01:35] <p6eval> ng 5635e9: OUTPUTÂ«No applicable candidates found to dispatch to for 'postcircumfix:<[ ]>'â¤current instr.: '!postcircumfix:<[ ]>' pc 306755 (src/gen/core.pir:39269)â¤Â»

[01:37] <colomon> lue: I'm guessing that's just not yet implemented in rakudo, either master or ng.

[01:37] <lue> rakudo my @rray{ 1..7 };@rray{1}=0;say @rray{1};

[01:38] <lue> yeah, let me see.

[01:38] <lue> rakudo: my @rray{ 1..7 };@rray{1}=0;say @rray{1};

[01:38] <p6eval> rakudo 1d4928: OUTPUTÂ«Confused at line 10, near "{ 1..7 };@"â¤in Main (file <unknown>, line <unknown>)â¤Â»

[01:38] <lue> pugs: my @rray{ 1..7 };@rray{1}=0;say @rray{1};

[01:38] <p6eval> pugs: OUTPUTÂ«*** Cannot cast into Hash: VRef <Array:0x2abc73ada031>â¤    at /tmp/bF3yHkB4xP line 1, column 1-17â¤Â»

[01:38] <lue> :(

[01:38] <ash_> my $a, @b, $c = 1, 2, 3, 4, 5; say 'first: ' ~ $a ~ ' last: ' ~ $c; 

[01:38] <ash_> ng: my $a, @b, $c = 1, 2, 3, 4, 5; say 'first: ' ~ $a ~ ' last: ' ~ $c;

[01:38] <p6eval> ng 5635e9: OUTPUTÂ«Symbol '@b' not predeclared in <anonymous>â¤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (src/PCT/HLLCompiler.pir:101)â¤Â»

[01:39] <lue> nothing seems to agree with the synopsis.

[01:39] <ash_> i'd guess its not yet implemented 

[01:39] <lue> so indices are not yet implemented, let alone whatever indices.

[01:40] <ash_> [] work, but thats not a custom index 

[01:40] <ash_> ng: my @a = 1, 2, 3; @a[2].perl;

[01:40] <p6eval> ng 5635e9:  ( no output )

[01:40] <ash_> ng: my @a = 1, 2, 3; @a[2].perl.say;

[01:40] <p6eval> ng 5635e9: OUTPUTÂ«3â¤Â»

[01:41] <lue> bet that'd be fun to implement. :|

[01:43] <lue> what you'd have to do is create a {} operator that maps the "invented" index to the "actual" index.

[01:43] <lue> rakudo: say Â«1 2 3 4Â».WHAT

[01:43] <p6eval> rakudo 1d4928: OUTPUTÂ«List()â¤Â»

[01:44] <lue> rakudo: say (1..4).WHAT

[01:44] <p6eval> rakudo 1d4928: OUTPUTÂ«Range()â¤Â»

[01:44] <lue> yeah, indices will be fun :/

[01:44] *** cggoebel left
[01:45] <ash_> colomon: is that O thing that is used to specify precedence in the docs? i don't see it in S05

[01:46] <lue> rakudo: my enum Days Â«:Sun(1) Mon Tue Wed Thu Fri SatÂ»; say Days.WHAT;

[01:46] <p6eval> rakudo 1d4928: OUTPUTÂ«Malformed declaration at line 10, near "enum Days "â¤in Main (file <unknown>, line <unknown>)â¤Â»

[01:47] <colomon> ash_: I doubt it.

[01:47] *** ggoebel joined
[01:47] <colomon> Is that my $a, @b, $c = 1, 2, 3, 4, 5; actually in the specs?

[01:47] <colomon> I would have thought it would be my ($a, @b, $c) = 1, 2, 3, 4, 5;

[01:48] <colomon> and that doesn't work at the moment, unless someone fixed it today while I wasn't looking.

[01:48] <lue> rakudo: my @rray=0..4; say @rray.WHAT #I think I have it!

[01:48] <p6eval> rakudo 1d4928: OUTPUTÂ«Array()â¤Â»

[01:49] <lue> rakudo: my @rray=<0 1 2 3 4>; say @rray.WHAT;

[01:49] <p6eval> rakudo 1d4928: OUTPUTÂ«Array()â¤Â»

[01:49] *** IllvilJa left
[01:50] <lue> I've got it! I just need to know where to put it!

[01:51] <pugs_svn> r29659 | colomon++ | [t/spec] Defudge test fixed by the gather / take workaround in infix:<...>. 

[01:51] *** nihiliad left
[01:51] <colomon> lue: my @rray=<0 1 2 3 4>; actually is a one-element array whose one element is an array of strings, AFAIK.

[01:52] *** JimmyZ joined
[01:53] <lue> just figuring out if some defines an indice as <Summer Autumn Spring Winter>.

[01:53] <ash_> colomon: that $a, @b, $c wasn't in the spec that I can find, i was just guessing, it might not be allowed at all

[01:53] <lue> ex. my @rray { <Sum Aut Spr Win> };

[01:54] <colomon> ash_: for sure my ($a, @b) is allowed.

[01:54] <colomon> sorry, I mean, my ($a, @b) = @c.

[01:54] <ash_> can't you do that with params? like sub foo($a, @b, $c) ? 

[01:55] <colomon> ash_: yes, but that's different.

[01:55] <colomon> because then you have to pass three arguments, the middle of which is an array.

[01:55] <colomon> my ($a, @b) = list puts the first element of the list in $a and the rest in @b.

[01:58] *** nihiliad joined
[01:58] <lue> ng: my $calar=<0 1 2>; say $calar;

[01:58] <p6eval> ng ae60f8: OUTPUTÂ«0 1 2â¤Â»

[01:58] <lue> ng: my $calar=<0 1 2>; say $calar.WHAT;

[01:58] <p6eval> ng ae60f8: OUTPUTÂ«Null PMC access in elements()â¤current instr.: 'perl6;SeqIter;get' pc 11981 (src/builtins/Positional.pir:16)â¤Â»

[01:58] <lue> rakudo: my $calar=<0 1 2>; say $calar.WHAT;

[01:58] <p6eval> rakudo 1d4928: OUTPUTÂ«Array()â¤Â»

[01:58] <lue> pugs: my $calar=<0 1 2>; say $calar.WHAT;

[01:58] <p6eval> pugs: OUTPUTÂ«Arrayâ¤Â»

[01:59] <lue> ah. Is that legal? Array in a scalar?

[01:59] <ash_> yea

[02:00] <lue> hm, I think I'm close to the how on indices.

[02:00] *** Exodist left
[02:01] <ash_> you can override how postcircumfix:{ } works, for a special index on an array, i imagine thats how it will be done eventually

[02:01] *** eternaleye left
[02:01] <ash_> [ ] for normal access, { } for special access

[02:01] *** quietfanatic left
[02:03] *** Exodist joined
[02:04] <lue> how can you see if a scalar ends up holding an array (ie variable.WHAT==Array, or something like that)

[02:04] <colomon> lue: $var ~~ Array

[02:05] <lue> ah.

[02:05] * lue thinks about how he REALLY REALLY should learn perl before fixing it.

[02:05] <colomon> Though I think $var ~~ Seq and $var ~~ Positional should both work as well, and be more inclusive.

[02:05] <ash_> the specs are a great place to start, they change a lot though 

[02:06] <colomon> (Seq is an immutable Array, and Positional is the role both Seq and Array do.)

[02:06] <colomon> Not sure if Positional is actually in place in ng at the moment or not.

[02:06] <ash_> ng: say Array ~~ Positional

[02:06] <p6eval> ng ae60f8: OUTPUTÂ«0â¤Â»

[02:06] <ash_> ng: say Positional ~~ Array; # oops had it backwards

[02:06] <p6eval> ng ae60f8: OUTPUTÂ«0â¤Â»

[02:07] <colomon> No, doesn't look like Positional is in Seq yet (just checked the source).

[02:07] <ash_> ng: my $foo = (1, 2, 3); say $foo.WHAT; for @($foo) { say $_.perl; } 

[02:08] <p6eval> ng ae60f8: OUTPUTÂ«Null PMC access in elements()â¤current instr.: 'perl6;SeqIter;get' pc 11981 (src/builtins/Positional.pir:16)â¤Â»

[02:08] *** agentzh joined
[02:08] <colomon> Positional is defined, though...

[02:09] <ash_> ng: my $foo = (1, 2, 3); say $foo.WHAT;

[02:09] <p6eval> ng ae60f8: OUTPUTÂ«Null PMC access in elements()â¤current instr.: 'perl6;SeqIter;get' pc 11981 (src/builtins/Positional.pir:16)â¤Â»

[02:09] <ash_> hmmm thats not right i think

[02:11] <pugs_svn> r29660 | colomon++ | [t/spec] Unfudge tests that now work in ng. 

[02:11] <lue> rakudo: my $foo = (1, 2, 3); say $foo.WHAT;

[02:11] <p6eval> rakudo 1d4928: OUTPUTÂ«Array()â¤Â»

[02:12] *** stephenlb joined
[02:12] <ash_> ng: my $foo = (1, 2, 3); say $foo.perl; 

[02:12] <p6eval> ng ae60f8: OUTPUTÂ«Method 'perl' not found for invocant of class 'Seq'â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[02:12] <ash_> thats why its doing that

[02:13] <lue> I'm looking for a way to take an unnamed array (<1 2 3>) and put it into a variable as its original 1d list.

[02:13] <lue> rakudo: my @rray=\<1 2 3>; say @rray[1];

[02:13] <p6eval> rakudo 1d4928: OUTPUTÂ«Use of uninitialized valueâ¤â¤Â»

[02:14] <lue> rakudo: my $calar=<1 2 3>; my @rray=$calar; say @rray[1];

[02:14] <p6eval> rakudo 1d4928: OUTPUTÂ«Use of uninitialized valueâ¤â¤Â»

[02:14] <lue> hmmm

[02:15] <ash_> my $a = <1 2 3>; my @a = @($a); say ~@a; ? 

[02:15] <ash_> oops

[02:15] <ash_> ng: my $a = <1 2 3>; my @a = @($a); say ~@a; # like that? 

[02:15] <p6eval> ng ae60f8: OUTPUTÂ«1 2 3â¤Â»

[02:15] <ash_> or if you want to check that it did it right you can try: 

[02:16] <ash_> ng: my $a = <1 2 3>; my @a = @($a); for @a { say $_.perl } 

[02:16] <lue> ng: my $a = <1 2 3>; my @a = @($a); say @a[1];

[02:16] <p6eval> ng ae60f8: OUTPUTÂ«"1"â¤"2"â¤"3"â¤Â»

[02:16] <p6eval> ng ae60f8: OUTPUTÂ«2â¤Â»

[02:16] <lue> yes! Thank you!

[02:16] <ash_> hehe, i have bad variable names

[02:16] <lue> ng: my $a = 1..3; my @a = @($a); say @a[1];

[02:16] <p6eval> ng ae60f8: OUTPUTÂ«2â¤Â»

[02:16] <ash_> perl 6 lets you get away with re-using variables with different sigils even though they never point to the same thing

[02:17] <lue> yay, I don't need any ifs!

[02:17] <ash_> $a is not related to @a at all

[02:17] <ash_> so you know 

[02:17] <lue> yes, same way Iterator.pm and iterator.pm are two different files in *nix.

[02:17] <ash_> @() returns something in list context, so does the list op if its implemented (but might want to double check that) 

[02:19] <ash_> list $a  == @($a)   # is what that means 

[02:21] <lue> I now have the how of _storing_ custom indices.

[02:22] <lue> The {} postcircumfix should intercept the given values, and store them in an array.

[02:22] *** JimmyZ left
[02:22] *** Exodist left
[02:22] <ash_> a translation table basically right? 

[02:22] <ash_> how to translate @a{1} into @a[0] for instance 

[02:22] <lue> Yeah. You intercept, interpret, and send.

[02:23] <lue> yes. Exactly. Or @rray{January} into @rray[0].

[02:23] <ash_> yeah

[02:23] <ash_> are you just calling Int or something on the params of { } ? 

[02:24] *** eternaleye joined
[02:24] <lue> I'll post some basic code of storing custom indices when I have it all worked out.

[02:24] <lue> (on paste.lisp.org of course.)

[02:24] <ash_> hmm or does the param of { } need to have 'succ' implemented? 

[02:25] *** Exodist joined
[02:26] <colomon> ng: my ($a, $b) = 1, 2; say $a; say $b

[02:26] <p6eval> ng ae60f8: OUTPUTÂ«Mu()â¤Mu()â¤Â»

[02:27] <ash_> ah, i see i just read over the section on user defined indices and it talks about what you need to do when you encounter an index not specified 

[02:28] <ash_> lue if you get it implemented, why not write some tests for pugscode? :-D 

[02:29] *** JimmyZ joined
[02:29] <lue> I've got just the how of storing it. Nowhere near usable yet :)

[02:31] <ash_> are you augmenting Array? 

[02:31] <lisppaste3> lue pasted "basic howto store indices" at http://paste.lisp.org/display/94551

[02:32] <lue> heh, that's all I coded so far :\

[02:33] <lue> pugs: @rray{1..3}=1,2,3;say @rray;

[02:33] <p6eval> pugs: OUTPUTÂ«*** â¤    Unexpected "{"â¤    expecting "::"â¤    Variable "@rray" requires predeclaration or explicit package nameâ¤    at /tmp/WA30Grp57C line 1, column 6â¤Â»

[02:34] <lue> I'll find a place to put this stuff and start putting it in properly!

[02:34] *** stephenlb left
[02:36] *** stephenlb joined
[02:37] <colomon> ng: say 0i.Bool

[02:37] <p6eval> ng ae60f8: OUTPUTÂ«0â¤Â»

[02:37] <colomon> ng: say 1i.Bool

[02:37] <p6eval> ng ae60f8: OUTPUTÂ«1â¤Â»

[02:37] <ash_> lue: i'd do it something like: http://gist.github.com/297833 but thats not complete right now

[02:41] <lue> yeah, I was thinking of using the index of where the custom value is, but a hash makes more sense.

[02:42] <ash_> i am not sure how you would do my @a{2, 3} = 1, 2 though. I know how to override { } but making the array only accept 2 values and return them at the given keys seems a bit beyond me, like how would i know to map 2 to 1 and 3 to 2, that makes me think the { } needs to be aware of the other side of the = 

[02:43] <ash_> i was thinking of a hash that takes the param of {} and gets a key returned from the hash to input into the array 

[02:44] <ash_> so really that could be as simple as, return self.[%!key_map{*@slice}]; i think eventually 

[02:45] <ash_> is there a way to tell if your doing $a = $foo{'a'} vs $foo{'a'} = 5 ? 

[02:46] <lue> store custom index elements as keys, actual index elements as values,

[02:46] <lue> use value for array I/O.

[02:49] <ash_> ruby had [] and []= for telling if your doing an access vs an assignment, i wonder how you tell the difference in perl 6

[02:50] <lue> maybe ternary operators for assignment?

[02:50] <lue> hm, interesting question

[02:51] * lue thinks this place is deserted because of the Super Bowl, which should be over about now (or soon)

[02:51] <ash_> that and a lot of developers are in europe so its extra late (or early depending on your perspective) plus its the weekened 

[02:51] <colomon> naw, probably most of the European contingent is asleep right now.

[02:53] <lue> tomorrow's a weekday, and I can't be on until *gasp* 15:30 PST.

[02:53] <ash_> colomon do you have any idea if there is a way to tell? 

[02:54] <ash_> i am sure he's busy with his kids, no worries if you don't know

[02:56] <colomon> ash_: you mean if there's a way to tell if you are an lvalue or an rvalue?  

[02:57] <ash_> if those are the right terms for $a = $foo{'a'} vs $foo{'a'} = 5 then yes 

[02:57] <colomon> I asked pmichaud a similar  question the other day, and didn't understand the answer.  :(

[02:58] <lue> Would that tell you the difference between assignment and access? Seems like it would.

[02:58] <ash_> http://perlcabal.org/syn/S06.html#Lvalue_subroutines seems sorta to answer my question but i can't tell if multi dispatch will tell the difference between is rw and not is rw 

[02:59] <ash_> only way to know is to try it out i suppose

[03:00] <colomon> That seems like a sensible approach.

[03:01] <ash_> i think http://perlcabal.org/syn/S06.html#Subroutine_traits 'is rw' has the wrong test associated with it. that test is using a param 'is rw' not a sub 'is rw' 

[03:01] *** vaios joined
[03:02] *** k23z__ left
[03:02] *** ggoebel left
[03:03] *** vaios left
[03:03] <lue> they must have done it for standard indices.

[03:03] <lue> Just use what they used for [] :)

[03:03] *** ggoebel joined
[03:03] <colomon> ng: my @a = 1..5;  sub foo() is rw { @a[0] }; say @a[0]; foo() = 2332; say @a[0];

[03:03] <p6eval> ng ae60f8: OUTPUTÂ«No applicable candidates found to dispatch to for '&trait_mod:<is>'â¤current instr.: '' pc -1 ((unknown file):-1)â¤Â»

[03:04] <ash_> yeah, it seems is rw is not implemented currently 

[03:04] <colomon> You want to look in Array.pir for how postcircumfix:<[ ]> is currently implemented on Array.

[03:05] <ash_> i think ill ask pmichaud about is rw next time i see him, just to see if it does make a difference in the multi dispatcher or if there is a way inside the function to see if its being assigned to 

[03:05] <lue> yeah, {} could, at its simplest, be a sort of middleman, letting [] methods do all the legwork.

[03:06] <ash_> thats what i'd do 

[03:06] <ash_> make [] do the work of finding the real value 

[03:12] <lue> I'm thinking two ways:

[03:13] <lue> 1. Create a middleman and do tricky on the left or on the right stuff.

[03:13] <lue> 2. Add to the pir code the {} operator.

[03:14] <lue> I understand about 80% of Array.pir

[03:14] <ash_> well, you could do have { } return a reference to the array it self and override the assignment = for array's to check if you have defined your set of keys

[03:17] <lue> You could have {} look in a hash, find the appropriate index, then call the [] operator, all through pir code.

[03:17] <lue> Ah, the possibilities...

[03:17] * lue thinks of TIMTOWTDI

[03:18] <colomon> looking at postcircumfix:<[ ]>, it looks to me like the fail path is handling setting up an lvalue using the Proxy class.

[03:19] <ash_> colomon: where are you looking at? just curious? 

[03:20] <colomon> Array.pir and Proxy.pir in src/builtins in ng

[03:20] *** k23z__ joined
[03:20] <colomon> ng: my @a = 1..3; @[-1] = 10; say @a;

[03:20] <p6eval> ng ae60f8: OUTPUTÂ«sh: ./perl6: No such file or directoryâ¤Â»

[03:20] <lue> Maybe the {} pir code could be simply a copy'n'paste of the [] pir code, with appropriate modifications.

[03:21] <lue> eh, middleman still seems easiest to me, especially when implemented as pir code.

[03:21] <ash_> i think it would be better if {} used [] to cut down on repetition

[03:22] <colomon> I don't see why it particularly should be pir code, either.

[03:22] <lue> Just spewing ideas... where would the hash be stored, for middleman stuff?

[03:23] *** ggoebel left
[03:25] *** agentzh left
[03:25] <colomon> lue: I'm not sure.  I've got to say, my instinct would be that you wouldn't do these things in the Array class at all.

[03:25] <colomon> It's not clear to me what the spec intends there.

[03:26] <lue> questions, questions...

[03:26] <colomon> But essentially what you are doing there is adding the Associative role to an Array type.

[03:27] *** agentzh joined
[03:28] <colomon> I don't have a feel whether it makes more sense to add the Associative role to the particular variable you're looking at, or to create a new Array class which also does Associative.

[03:29] <colomon> (if you're wondering, @a means "does Positional", not "is Array".)

[03:31] *** Limbic_Region joined
[03:33] <lue> look in src/core/operators.pm. There is the {} circumfix, and it seems to create a hash...

[03:33] <colomon> all right, I've got to get to bed here.  happy hacking...

[03:33] <lue> ng: %h=<1 2 3>;say %h;

[03:33] <p6eval> ng ae60f8: OUTPUTÂ«Symbol '%h' not predeclared in <anonymous>â¤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (src/PCT/HLLCompiler.pir:101)â¤Â»

[03:33] <ash_> ttyl 

[03:33] <lue> ng: my %h=<1 2 3>;say %h;

[03:33] <p6eval> ng ae60f8: OUTPUTÂ«Odd number of elements found where hash expectedâ¤current instr.: '&die' pc 15000 (src/builtins/Junction.pir:165)â¤Â»

[03:34] <ash_> ng: my %h = :K<4>;

[03:34] <p6eval> ng ae60f8:  ( no output )

[03:34] <ash_> ng: my %h = :K<4>; say %h;

[03:34] <p6eval> ng ae60f8:  ( no output )

[03:34] <lue> I'll mull over how to do it. I have to go get things done.

[03:34] <ash_> ng: my %h = :K(4); say %h;

[03:34] <p6eval> ng ae60f8:  ( no output )

[03:34] <ash_> hmm

[03:35] <ash_> ng: my %h = k => 5; say %h;

[03:35] <p6eval> ng ae60f8:  ( no output )

[03:35] <ash_> ummm i must be doing something wrong

[03:35] <ash_> ng: my %h; %h<k> = 5; say %h<k>; 

[03:35] <p6eval> ng ae60f8: OUTPUTÂ«5â¤Â»

[03:36] <ash_> ng: my %h; %h<k> = 5; say %h<k> ~ ' is the same as' ~ %h{'k'};

[03:37] <p6eval> ng ae60f8: OUTPUTÂ«5 is the same as5â¤Â»

[03:49] *** agentzh left
[03:53] *** drbean left
[03:55] *** eternaleye left
[03:55] *** justatheory left
[04:00] *** eternaleye joined
[04:00] *** Limbic_Region left
[04:11] <lue> I'm back and ready to continue pondering.

[04:12] <lue> rakudo: my @rray=1..5; say @rray[2..*];

[04:12] <p6eval> rakudo 1d4928: OUTPUTÂ«345Use of uninitialized valueâ¤â¤Â»

[04:12] <lue> pugs: my @rray=1..5; say @rray[2..*];

[04:12] <p6eval> pugs: OUTPUTÂ«345â¤Â»

[04:20] <lue> ng: my $a=4; my $b=1; $a=(5 if $b==1); say $a;

[04:20] <p6eval> ng ae60f8: OUTPUTÂ«sh: ./perl6: No such file or directoryâ¤Â»

[04:20] <lue> awww!

[04:20] <lue> ng: my $a=4; my $b=1; $a=(5 if $b==1); say $a;

[04:20] <p6eval> ng ae60f8: OUTPUTÂ«sh: ./perl6: No such file or directoryâ¤Â»

[04:20] <lue> :/

[04:24] <lue> ng: my $a=4; my $b=1; $a=(5 if $b==1); say $a;

[04:24] <p6eval> ng ae60f8: OUTPUTÂ«5â¤Â»

[04:24] <lue> ng: my $a=4; my $b=2; $a=(5 if $b==1); say $a;

[04:24] <p6eval> ng ae60f8: OUTPUTÂ«â¤Â»

[04:25] <lue> ng: my $a=4; my $b=2; $a=($b==1 ?? 5 !! 4); say $a;

[04:25] <p6eval> ng ae60f8: OUTPUTÂ«4â¤Â»

[04:25] <lue> ng: my $a=4; my $b=1; $a=($b==1 ?? 5 !! 4); say $a;

[04:25] <p6eval> ng ae60f8: OUTPUTÂ«5â¤Â»

[04:25] *** mikehh left
[04:25] <lue> hello, anyone there?

[04:25] *** mikehh joined
[04:26] * lue The Hexclock time is D_9E in roughly the PST area

[04:34] * lue is broadcasting a welcome signal. If you see this, please respond.

[04:35] <lue> rakudo: say [1,2,3].WHAT

[04:35] <p6eval> rakudo 1d4928: OUTPUTÂ«Array()â¤Â»

[04:35] <lue> rakudo: say {1 2 3}.WHAT

[04:35] <p6eval> rakudo 1d4928: OUTPUTÂ«Confused at line 10, near "2 3}.WHAT"â¤in Main (file <unknown>, line <unknown>)â¤Â»

[04:35] <lue> rakudo: say {1 2 3 4}.WHAT

[04:36] <p6eval> rakudo 1d4928: OUTPUTÂ«Confused at line 10, near "2 3 4}.WHA"â¤in Main (file <unknown>, line <unknown>)â¤Â»

[04:36] *** jnthn_ joined
[04:37] *** jnthn left
[04:37] <lue> hello.

[04:48] <lue> ng:say 5.FETCH

[04:48] <lue> ng: say 5.FETCH

[04:48] <p6eval> ng ae60f8: OUTPUTÂ«sh: ./perl6: No such file or directoryâ¤Â»

[04:48] <lue> AA

[04:48] <lue> rakudo: say 5.FETCH

[04:48] <p6eval> rakudo 1d4928: OUTPUTÂ«Method 'FETCH' not found for invocant of class 'Int'â¤in Main (file src/gen_setting.pm, line 324)â¤Â»

[04:49] <lue> rakudo: my Parcel $a=5; say a.FETCH

[04:49] <p6eval> rakudo 1d4928: OUTPUTÂ«Malformed declaration at line 10, near "Parcel $a="â¤in Main (file <unknown>, line <unknown>)â¤Â»

[04:49] *** mikehh left
[04:50] *** mikehh joined
[04:53] *** hercynium joined
[05:00] <ash_> hi lue 

[05:08] <lue> there you are!

[05:08] <lue> I'm looking through STD.pm for a potential clue to custom indices.

[05:11] <ash_> i kinda agree with colomon, custom indices seem like hashes basically IMO 

[05:11] <lue> Yeah, just that which side of the equation deal...

[05:13] *** agentzh joined
[05:17] <lue> ng: say 'hi';

[05:17] <p6eval> ng ae60f8: OUTPUTÂ«hiâ¤Â»

[05:17] <lue> yes, done compiling!

[05:18] *** drbean joined
[05:18] <lue> rakudo: $a=5; $b=\$a; $b=3; say $a

[05:18] <p6eval> rakudo 1d4928: OUTPUTÂ«Symbol '$a' not predeclared in <anonymous> (/tmp/DtErD9Iioy:10)â¤in Main (file <unknown>, line <unknown>)â¤Â»

[05:18] <lue> rakudo: my $a=5; my $b=\$a; $b=3; say $a

[05:18] <p6eval> rakudo 1d4928: OUTPUTÂ«5â¤Â»

[05:19] <lue> rakudo: my $a=5; my $b=\$a; $b.WHERE=3; say $a

[05:19] <p6eval> rakudo 1d4928: OUTPUTÂ«5â¤Â»

[05:19] <lue> rakudo: my $a=5; my $b=\$a; say $b.WHAT

[05:19] <p6eval> rakudo 1d4928: OUTPUTÂ«Int()â¤Â»

[05:19] <lue> rakudo: my $a=5; my $b=\$a; say $b.VALUE

[05:19] <p6eval> rakudo 1d4928: OUTPUTÂ«Method 'VALUE' not found for invocant of class 'Int'â¤in Main (file src/gen_setting.pm, line 324)â¤Â»

[05:19] <lue> rakudo: my $a=5; my $b=\$a; say $b.WHERE

[05:19] <p6eval> rakudo 1d4928: OUTPUTÂ«47501651931336â¤Â»

[05:20] <lue> hm... I'm thinking of using references to avoid guessing which side of the equation, but...

[05:20] <ash_> ng: my $a = 5; my $b := $a; say $b; $b = 10; say $a;

[05:20] <p6eval> ng ae60f8: OUTPUTÂ«sh: ./perl6: No such file or directoryâ¤Â»

[05:20] <ash_> ng: my $a = 5; my $b := $a; say $b; $b = 10; say $a;

[05:20] <p6eval> ng ae60f8: OUTPUTÂ«sh: ./perl6: No such file or directoryâ¤Â»

[05:21] <lue> rakudo: my $a = 5; my $b := $a; say $b; $b = 10; say $a;

[05:21] <p6eval> rakudo 1d4928: OUTPUTÂ«5â¤10â¤Â»

[05:21] <lue> hooray! This keeps us from having to worry about which side of the equation!

[05:22] <ash_> hmmm

[05:22] <ash_> how so? 

[05:22] <lue> if we want to access, then the reference will automagically give us the number. If we want to assign, then the reference takes care of that!

[05:25] <ash_> so i assume in my @a{2, 3} = 1, 2; you'd return 2 captures 

[05:25] <ash_> and they'd update indices 0 and 1 to 1, 2

[05:25] <ash_> yeah, i guess that should work fine

[05:26] <lue> ah, now the initialization code and retrieval code just needs to be written and put in the right place.

[05:28] <lue> gah, where to put it, that's the one thing!

[05:31] <ash_> i'd do it in the src/core/Array.pm

[05:32] <ash_> its really late here, so ima head to bed

[05:32] <ash_> cya tomorrow 

[05:33] <lue> It's 9:30 PM here. 'Night.

[05:33] <lue> ...to you, I'm going to work on the indices

[05:33] <ash_> good luck

[05:33] *** ash_ left
[05:35] *** cjk101010 joined
[05:47] <lue> rakudo: my %ash; say %ash;

[05:47] <p6eval> rakudo 1d4928: OUTPUTÂ«â¤Â»

[05:47] <lue> rakudo: my %ash; say %ash~~"";

[05:47] <p6eval> rakudo 1d4928: OUTPUTÂ«1â¤Â»

[05:49] <lue> rakudo: my %ash; say %ash~~undefined;

[05:49] <p6eval> rakudo 1d4928: OUTPUTÂ«Could not find non-existent sub undefinedâ¤in Main (file src/gen_setting.pm, line 324)â¤Â»

[05:53] <lue> rakudo: say @(3);

[05:53] <p6eval> rakudo 1d4928: OUTPUTÂ«3â¤Â»

[05:57] <lue> pugs: @rray{1..3}=0,1,2; say @rray;

[05:57] <p6eval> pugs: OUTPUTÂ«*** â¤    Unexpected "{"â¤    expecting "::"â¤    Variable "@rray" requires predeclaration or explicit package nameâ¤    at /tmp/vr5tR7SWgO line 1, column 6â¤Â»

[05:57] <lue> std: @rray{1..3}=0,1,2; say @rray;

[05:57] <p6eval> std 29660: OUTPUTÂ«Potential difficulties:â¤  Variable @rray is not predeclared at /tmp/WHkDoXH6Mb line 1:â¤------> [32m@rray[33mâ[31m{1..3}=0,1,2; say @rray;[0mâ¤  Variable @rray is not predeclared at /tmp/WHkDoXH6Mb line 1:â¤------> [32m@rray{1..3}=0,1,2; say @rray[33mâ[31m;[0mâ¤ok 00:01 109mâ¤Â»

[05:57] <lue> pugs: my @rray{1..3}=0,1,2; say @rray;

[05:57] <p6eval> pugs: OUTPUTÂ«*** Cannot cast into Hash: VRef <Array:0x2b881a87fe61>â¤    at /tmp/Zkm2VN4AaI line 1, column 1-21â¤Â»

[05:57] <lue> std: my @rray{1..3}=0,1,2; say @rray;

[05:57] <p6eval> std 29660: OUTPUTÂ«ok 00:01 107mâ¤Â»

[06:10] <lue> rakudo: my @rray=1,2,3; say @rray.max;

[06:10] <p6eval> rakudo 1d4928: OUTPUTÂ«3â¤Â»

[06:10] <lue> rakudo: my @rray=1,2,3; say @rray.end;

[06:10] <p6eval> rakudo 1d4928: OUTPUTÂ«2â¤Â»

[06:14] <lue> rakudo: my %ash=("hi"=>3);say %ash; %ash{"oi"}=4; say %ash;

[06:14] <p6eval> rakudo 1d4928:  ( no output )

[06:14] <lue> rakudo: my %ash=("hi"=>3);say %ash;

[06:14] <p6eval> rakudo 1d4928:  ( no output )

[06:14] <lue> ng: my %ash=("hi"=>3);say %ash;

[06:14] <p6eval> ng ae60f8:  ( no output )

[06:14] <lue> pugs: my %ash=("hi"=>3);say %ash;

[06:14] <p6eval> pugs: OUTPUTÂ«hi  3â¤Â»

[06:14] <lue> pugs: my %ash=("hi"=>3);say %ash; %ash{"oi"}=4; say %ash;

[06:15] <p6eval> pugs: OUTPUTÂ«hi  3â¤hi      3oi     4â¤Â»

[06:15] <lue> pugs: my %ash;say %ash; %ash{"oi"}=4; say %ash;

[06:15] <p6eval> pugs: OUTPUTÂ«â¤oi   4â¤Â»

[06:16] *** akl joined
[06:17] <lue> pugs: my %ash;say %ash; %ash{"oi"}=4; say %ash{"oi"};

[06:17] <p6eval> pugs: OUTPUTÂ«â¤4â¤Â»

[06:18] <lue> pugs: say <1 2 3>.end

[06:18] <p6eval> pugs: OUTPUTÂ«2â¤Â»

[06:18] <lue> pugs: say <1>.end

[06:18] <p6eval> pugs: OUTPUTÂ«0â¤Â»

[06:20] <lue> rakudo: my @rray=1 2 3 4; say @rray; @rray[0..2]=5 6 7; say @rray;

[06:20] <p6eval> rakudo 1d4928: OUTPUTÂ«Confused at line 10, near "2 3 4; say"â¤in Main (file <unknown>, line <unknown>)â¤Â»

[06:20] <lue> pugs: my @rray=1 2 3 4; say @rray; @rray[0..2]=5 6 7; say @rray;

[06:20] <p6eval> pugs: OUTPUTÂ«*** â¤    Unexpected "2"â¤    expecting operator or ","â¤    at /tmp/QWUbAVjbtR line 1, column 12â¤Â»

[06:20] <lue> rakudo: my @rray=1,2,3,4; say @rray; @rray[0..2]=5,6,7; say @rray;

[06:20] <p6eval> rakudo 1d4928: OUTPUTÂ«1234â¤5674â¤Â»

[06:21] *** lestrrat is now known as lest_away

[06:28] <lue> pugs: say <1>.end ~~ 1

[06:28] <p6eval> pugs: OUTPUTÂ«â¤Â»

[06:28] <lue> pugs: say <1>.end ~~ 0

[06:28] <p6eval> pugs: OUTPUTÂ«1â¤Â»

[06:50] *** nihiliad left
[07:01] *** kaare joined
[07:01] *** kaare is now known as Guest42460

[07:04] *** lue left
[07:08] *** cjk101010 left
[07:10] *** rgrau left
[07:18] *** stephenlb left
[07:21] *** k23z__ left
[07:22] *** gfx joined
[07:22] *** Chillance left
[07:25] *** drbean left
[07:34] *** agentzh left
[07:34] *** Su-Shee joined
[07:36] *** eternaleye_ joined
[07:36] *** eternaleye left
[07:41] <Su-Shee> good morning

[07:59] *** lest_away is now known as lestrrat

[08:00] *** k23z__ joined
[08:01] *** pnate left
[08:05] *** iblechbot joined
[08:08] *** drbean joined
[08:28] *** mssm joined
[08:41] *** IllvilJa joined
[08:49] *** eternaleye_ left
[08:52] *** agentzh joined
[08:57] *** UjinT34 joined
[08:59] *** fridim_ joined
[09:00] *** cjk101010 joined
[09:01] *** gfx left
[09:10] *** synth left
[09:11] <mathw> Morning

[09:12] *** mssm left
[09:12] *** dakkar joined
[09:15] *** mssm joined
[09:23] *** barney joined
[09:27] *** [particle] left
[09:30] *** [particle] joined
[09:43] *** cdarke joined
[09:44] *** cdarke left
[09:47] <pugs_svn> r29661 | mberends++ | [MiniPerl6] add a perlito launcher script and some docs 

[10:02] *** ruoso joined
[10:02] *** eternaleye joined
[10:05] *** hanekomu left
[10:05] *** hanekomu joined
[10:05] *** drbean left
[10:12] *** k23z__ left
[10:12] *** fridim_ left
[10:14] <jnthn_> ohhai

[10:14] *** jnthn_ is now known as jnthn

[10:20] <JimmyZ>                                                                     hello                                                                                                                                                                                        

[10:22] <colomon> o/

[10:22] *** ruoso left
[10:25] *** iblechbot left
[10:26] *** clausi joined
[10:27] *** phenny joined
[10:33] *** JimmyZ left
[10:45] <colomon> So, by my count ng had 19 commits yesterday, by five different people.

[10:48] <jnthn> Nice :-)

[10:52] *** lestrrat is now known as lest_away

[10:53] <colomon> now if we could do that every day for the next three months.... :)

[10:58] *** eternaleye left
[11:05] <moritz_> good morning

[11:06] *** agentzh left
[11:08] <jnthn> hi moritz_ 

[11:08] <colomon> \o

[11:08] *** moritz_ sets mode: +o jnthn

[11:12] <colomon> jnthn: turns out our lazy gather / take has that old bug where saying take $i actually stashes a reference to $i rather than its value.

[11:12] <dalek> book: 41d351c | moritz++ | src/ (3 files):

[11:12] <dalek> book: There is no undef anymore

[11:12] <dalek> book: review: http://github.com/perl6/book/commit/41d351c8285633658ec3cd5f52773b74ff0f7e2b

[11:13] <jnthn> colomon: Aww.

[11:14] *** eternaleye joined
[11:14] <colomon> ng: my @rray=(gather loop (my $calar = 0; $calar <= 6; $calar++){take $calar;}); say @r

[11:14] <p6eval> ng ae60f8: OUTPUTÂ«Symbol '@r' not predeclared in <anonymous>â¤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (src/PCT/HLLCompiler.pir:101)â¤Â»

[11:14] <colomon> ng: my @rray=(gather loop (my $calar = 0; $calar <= 6; $calar++){take $calar;}); say @rray

[11:14] <p6eval> ng ae60f8: OUTPUTÂ«7777777â¤Â»

[11:15] <colomon> lue++ # for the example

[11:18] *** payload left
[11:33] <colomon> rakudo: say 1, 3, 5 ... 9

[11:33] <p6eval> rakudo 1d4928: OUTPUTÂ«Multiple Dispatch: No suitable candidate found for 'cmp', with signature 'PP->I'â¤in Main (file <unknown>, line <unknown>)â¤Â»

[11:36] *** aindilis left
[11:38] *** mj41 left
[11:44] *** payload1 joined
[11:50] *** bluescreen joined
[11:51] <colomon> jnthn: any notion why moving infix:<...> from Range.pm to operators.pm would break it?

[11:52] <mathw> morning

[11:52] <colomon> o/

[11:52] <moritz_> colomon: perhaps different order of declared classes?

[11:52] <moritz_> colomon: how does it break?

[11:53] <colomon> everything compiles, but you get Could not find non-existent sub &infix:<...>

[11:53] <colomon> when you try to use it.

[11:54] <moritz_> in master there was some magic which would export routines in the setting to the CORE namespace (or whatever it was caused)

[11:55] <colomon> oh hey, good guess, other ops in operators.pm are declared "our"

[11:56] <colomon> I'll try that

[11:57] <colomon> that did it!

[11:57] <colomon> moritz_++

[11:59] <moritz_> "educated guessing" :-)

[12:01] <colomon> it does make me wonder why there was a difference....

[12:01] *** payload1 left
[12:05] *** lest_away is now known as lestrrat

[12:05] *** patspam left
[12:09] *** macae joined
[12:12] *** drbean joined
[12:13] *** drbean_ joined
[12:20] <jnthn> colomon: Sorry, phone-meeting...anyways, subs are lexical by default in Perl 6, so need exporting or marking "our".

[12:20] <colomon> jnthn: so, why did it work in Range.pm without the our?

[12:21] <moritz_> so rakudo doesn't consider the setting yet as an outer scope of the program?

[12:22] <jnthn> moritz_: Not yet.

[12:22] <jnthn> colomon: I'm not sure how it worked without the "our". :-/

[12:23] *** SmokeMachine joined
[12:25] *** ignacio_ joined
[12:30] <dalek> rakudo/ng: 157750d | (Solomon Foster)++ | src/core/ (2 files):

[12:30] <dalek> rakudo/ng: Move infix:<...> to operators.pm.

[12:30] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/157750d82040cbaa9bfea11c5f0e526c33d05214

[12:30] <dalek> rakudo/ng: 2312138 | (Solomon Foster)++ | src/core/operators.pm:

[12:30] <dalek> rakudo/ng: Replace our primitive infix:<...> implementation with a more sophisticated one from master.

[12:30] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/2312138c1964a4ccf90bd9112193fc5d5a4b75b7

[12:36] *** ruoso joined
[12:41] *** bluescreen left
[12:52] *** payload joined
[12:56] *** masak joined
[12:56] <masak> o/

[12:56] *** bluescreen joined
[12:57] *** orafu left
[12:58] <moritz_> \o

[12:59] *** synth joined
[12:59] *** orafu joined
[13:03] <masak> I just blogged a slightly acerbic post: http://use.perl.org/~masak/journal/40167

[13:03] <masak> I hope I managed to walk the fine line of making fun of the present situation and not misrepresenting anyone or anything.

[13:04] * jnthn reads nervously

[13:05] <masak> if not, here's your chance to help me fix it early. :)

[13:06] <takadonet> morning all

[13:06] <masak> takadonet: \o

[13:07] <jnthn> *sigh* Patches welcome, or I'll add it to my queue of 10000000 other things we also need to do.

[13:07] <masak> jnthn++ # my hero

[13:08] <jnthn> masak: I think I worked out why Parrot started getting annotations so wrong, btw.

[13:08] <masak> that's good news.

[13:08] <jnthn> masak: The bad news is that I'm a tad lost on how to fix it.

[13:08] <masak> ok.

[13:09] <jnthn> masak: Essentially, though, we end up not having the program counter to hand any more when there's a non-user-generated exception.

[13:09] <masak> aha.

[13:10] * masak tries hard not to sound like the Q guy in the FAQ

[13:10] *** mikehh left
[13:10] <jnthn> Which is...unhelpful. Of course, keeping track of it does slow things down a bit... :-/

[13:10] *** mikehh joined
[13:10] <jnthn> Anyway, that's as far as I dug into it.

[13:10] <frettled> masak++ - nice blog post, again.

[13:10] *** frettled sets mode: +o masak

[13:11] <masak> frettled: thanks. :)

[13:11] <masak> it was fun to write.

[13:12] <frettled> I can imagine.  It was also quite informative and enjoyable.

[13:12] <masak> \o/

[13:17] *** payload left
[13:17] *** UjinT34 left
[13:18] <moritz_> masak++

[13:19] <masak> clearly, this format is a winner. :)

[13:25] *** uniejo joined
[13:29] <colomon> :)

[13:29] *** mj41 joined
[13:31] *** payload joined
[13:33] <colomon> So, if we say May ... *, should we detect that Dec is the end of the series by checking to see if $x eq $x.succ ?

[13:35] <masak> colomon: why would Dec be its own successor?

[13:35] <colomon> because it's the last one in the (presumed) enum.

[13:37] <masak> sure but the .succ of the last element could be any number of things, on the design level.

[13:37] <masak> it could be Mu.

[13:37] <masak> or it could throw an exception.

[13:37] <masak> I was just wondering if you were reading from the spec and deduced that Dec.succ === Dec

[13:38] <colomon> No, intepolating.

[13:38] <colomon> Though in ng right now, True.succ == True, I believe.

[13:38] <jnthn> I don't think it's throw

[13:38] <colomon> ng: say True.succ

[13:38] <p6eval> ng 231213: OUTPUTÂ«1â¤Â»

[13:38] <jnthn> but it might fail

[13:38] <colomon> I've just been trying to think of how to support:

[13:38] <colomon> May..*      # May through December

[13:38] <jnthn> Well, there is that behavior in Bool, yeah...

[13:39] <jnthn> colomon: Yeah..hmm.

[13:39] <masak> oh yes, whatever the answer is, it has to congrue with Bool.

[13:39] <jnthn> Tssk.

[13:39] <jnthn> That means range needs to be aware of enum elements. :-)

[13:39] <jnthn> Let's see how enums fall out in the implementation, anyways.

[13:39] *** mj41 left
[13:40] <jnthn> The spec improved on those.

[13:40] <colomon> I originally was thinking that we needed another function or two to go with the .succ interface

[13:40] <colomon> but if we simply followed the Bool model, it would be pretty easy to detect end of range.

[13:40] <jnthn> .oO( If it returns identity at the end, doesn't that mean it'll succ less? )

[13:41] <jnthn> colomon: Yes, it does make it easy in that snese.

[13:41] <jnthn> *sense

[13:41] <colomon> The other thing I'm not sure is if we want to allow *..May

[13:41] <jnthn> Hmm

[13:41] *** payload left
[13:41] <masak> I'm actually quite eager to implement those new enums.

[13:41] <jnthn> How to find the start

[13:41] <jnthn> Yeah

[13:42] <jnthn> colomon: otoh

[13:42] <jnthn> both become easy-ish if you can go from an element back to the enum.

[13:42] <colomon> jnthn: ?

[13:42] <jnthn> masak: Feel free. :-)

[13:42] <masak> thanks. :)

[13:42] <jnthn> colomon: If you can get the full set of values...

[13:42] <colomon> oooh.

[13:42] <jnthn> ...then you can make a range from start to end right off

[13:43] <jnthn> Without having to care about how it behaves at the end.

[13:43] <jnthn> 'cus you know where the end is.

[13:43] <jnthn> :-)

[13:43] <colomon> so something like ::T $enum where T ~~ Enum

[13:43] <colomon> and then say T.keys?

[13:43] <jnthn> Not quite sure it wants to be that.

[13:43] <jnthn> I'd have to check the spec

[13:44] <jnthn> Maybe Enum ::T $enum would work...

[13:44] <jnthn> oh, wait

[13:44] <jnthn> No, that won't

[13:44] <jnthn> Well, maybe it should

[13:44] <jnthn> Gah

[13:44] * jnthn looks at what S12 akshually says

[13:46] <masak> not S09?

[13:46] <colomon> (I'm just trying to figure out an approach, not necessarily the actual code.  :)

[13:47] <jnthn> masak: Enums are in S12

[13:48] <jnthn> Alas, I gotta look at some other stuff for a bit now.

[13:50] <jnthn> But I figure that you can (a) know when you have an enum element, not just a plain old value, (b) multi-dispatch on that for the range constructors and (3) get the full set of enum values so you'll be able to know the start and the end.

[13:50] *** mj41 joined
[13:50] <jnthn> masak: btw, a good place to start on enum is to implement the anonymous enum constructor.

[13:50] <masak> thanks for the tip :)

[13:50] <colomon> go masak!

[13:51] <jnthn> It shouldn't be too hard at all. And you should be able to do it in Perl 6. ;-)

[13:51] <masak> colomon: sure, once I finish my day job. :)

[13:51] <masak> jnthn: that sounds wonderful.

[13:52] * jnthn goes to spend a while in the less wonderful world of Java web services

[13:54] *** meppl joined
[14:01] *** drbean left
[14:11] *** forrest joined
[14:14] *** iblechbot joined
[14:22] *** ggoebel joined
[14:37] <pmichaud> good morning, #perl6

[14:37] <phenny> pmichaud: 07 Feb 17:05Z <jnthn> tell pmichaud seems there's some issues with parsing <-> lambdas, I think the xblock's EXPR swallows up < as an infix operator, and then -> { } as a pointy block. Stared at STD a bit, don't immediately notice the solution. LTM? Any thoughts?

[14:37] <pmichaud> did someone do the ng1->master merge?

[14:37] <pmichaud> I can't find ng1 on github

[14:38] <moritz_> or maybe ng1 -> ng?

[14:38] <moritz_> ng is younger

[14:38] <pmichaud> hmmmm

[14:38] <takadonet> morning pmichaud

[14:39] <pmichaud> I only have a few minutes to try to sync up before leaving (to return back home).... but I can't seem to sync anything because the branches aren't where i expected them to be :-)

[14:39] <colomon> pmichaud: we did ng1 to ng.

[14:40] <colomon> I'm still uncomfortable making it master, but making it ng was a no-brainer.

[14:40] <pmichaud> okay.  what about list assignment (that was in the ng branch?)

[14:40] <pmichaud> is it still there, or ... ?

[14:40] <colomon> we did a merge, not a replace.

[14:41] <jnthn> pmichaud: I think still there but not functioning properly.

[14:41] <colomon> as far as I know, though, list assignment is broken.

[14:41] <jnthn> pmichaud: Likely just in need of updates since The World Changed.

[14:41] <colomon> ng: my ($a, $b); ($a, $b) = 1, 2; say $a;

[14:41] <p6eval> ng 231213: OUTPUTÂ«Mu()â¤Â»

[14:41] <pmichaud> I'm sure it's still broken, yes

[14:41] <mathw> pmichaud: and they rewrote Rakudo in Java

[14:41] <pmichaud> because it now goes into Parcel instead of List

[14:42] <jnthn> It runs faster now!

[14:42] <jnthn> ;-)

[14:42] <jnthn> pmichaud: I got much of Hash in place, and colomon++ has done Many Cool Things too.

[14:42] <pmichaud> looks like list assignment got lost.  I'll have to look it up from the history.

[14:43] <colomon> jnthn++ got file I/O working again.

[14:43] <pmichaud> excellent work on all of the other stuff!  jnthn++ colomon++

[14:43] <jnthn> mberends++ provoked me into it!

[14:43] <pmichaud> sorry I didn't get much time to work on things this weekend, but it happens

[14:43] *** drbean_ left
[14:43] <jnthn> pmichaud: Yes, we had quite a commit fest at the weekend. :-)

[14:43] <colomon> we actually had five different patch authors yesterday.  :)

[14:43] <pmichaud> anyway, I just wanted to sync things before getting on the plane today, so I can work on things on the plane

[14:44] <jnthn> \o/

[14:44] <colomon> :D 

[14:44] <colomon> pmichaud: where are you off to?

[14:44] <pmichaud> back home

[14:45] <pmichaud> my wife and I decided we needed an "emergency vacation"  :-)

[14:45] <colomon> :)

[14:45] <mathw> sounds good

[14:47] <pmichaud> anything else important I should work on besides list assignment?

[14:48] <jnthn> pmichaud: http://wiki.github.com/rakudo/rakudo/ng-major-features-needed

[14:48] <jnthn> pmichaud: Slices would be my choice.

[14:48] <pmichaud> slices, whatever, and grammars look like good hits

[14:48] <jnthn> pmichaud: Also array init, so my @array; @array[0] = 42; works

[14:49] <pmichaud> okay, got it

[14:49] <pmichaud> I'll work on those

[14:49] <pmichaud> okay, time to go.  see you all tomorrowish (maybe later tonight from airport)

[14:49] <colomon> safe home!

[14:51] <pmichaud> bbl

[14:57] *** wasy_afk is now known as wasy

[15:00] *** ggoebel left
[15:00] <colomon> afk # storytime

[15:05] *** sbilik joined
[15:05] *** sbilik left
[15:06] *** PacoLinux joined
[15:14] *** Guest42460 left
[15:19] *** kensanata` joined
[15:19] *** kensanata` is now known as kensanata

[15:26] *** Psyche^ joined
[15:28] *** Patterner left
[15:28] *** Psyche^ is now known as Patterner

[15:39] *** uniejo left
[15:52] *** [synth] joined
[16:02] *** nihiliad joined
[16:14] <masak> have people been replying off-list to jonasbn++ about his request for information? I know moritz_++ and jnthn++ have replied on-list, but also listed are TimToady, mberends, and pmichaud, who haven't replied on-list.

[16:20] *** SmokeMachine left
[16:23] *** clausi left
[16:25] *** cjk101010 left
[16:25] *** ignacio_ left
[16:38] *** kensanata left
[16:39] *** [synth] left
[16:39] *** ignacio_ joined
[16:41] *** mikehh left
[16:42] *** mikehh joined
[16:43] *** barney left
[16:43] *** uniejo joined
[16:43] *** SmokeMachine joined
[16:47] *** cjk101010 joined
[16:53] *** justatheory joined
[16:55] *** masak left
[16:55] *** SmokeMachine left
[16:56] *** wolverian left
[16:58] *** wolverian joined
[17:02] <diakopter> g'morn

[17:07] <takadonet> morning

[17:09] *** colomon left
[17:12] *** pmurias joined
[17:21] *** SmokeMachine joined
[17:23] *** mikehh left
[17:23] *** mikehh joined
[17:34] *** nihiliad left
[17:37] *** nihiliad joined
[17:41] *** fridim_ joined
[17:41] *** k23z__ joined
[17:42] *** alester joined
[17:42] *** mikehh left
[17:43] *** mikehh joined
[17:47] *** wanradt_ joined
[17:48] *** cotto_working joined
[17:48] *** colomon joined
[17:48] *** ignacio_ left
[17:51] *** cotto_w0rk left
[17:53] <colomon> ng: my @a = gather for 1..3 { my $a = $_; take $a, $a * 2; }; say @a.perl;

[17:53] <p6eval> ng 231213: OUTPUTÂ«too many positional arguments: 2 passed, 1 expectedâ¤current instr.: '&take' pc 15322 (src/builtins/Junction.pir:347)â¤Â»

[17:54] *** pmurias left
[17:58] *** stephenlb joined
[18:00] *** dakkar left
[18:05] <jnthn> OK...need food and then I'll do some Rakudo bits. :-)

[18:06] <colomon> \o/

[18:06] <jnthn> ah...food turns out to have a dependency on shopping.

[18:06] <takadonet> hehe

[18:06] <takadonet> order pizza?

[18:08] <jnthn> takadonet: Nah, I need some other bits from the store anyway, I may as well go now. :-)

[18:09] * jnthn back soon

[18:11] *** payload joined
[18:13] *** mikehh left
[18:18] *** mikehh joined
[18:19] <spinclad> $cupboard.grep: {when Food}>>.nom

[18:20] <spinclad> ohno, sorry: ($cupboard.grep: {when Food})>>.nom   # not a whole lot more natural, i know

[18:21] <spinclad> if EMPTY { shop }

[18:23] <spinclad> here would be a good place to use the new E operator, if my brane would only engage

[18:24] *** mikehh left
[18:25] *** mikehh joined
[18:29] *** mikehh left
[18:32] *** hercynium left
[18:35] *** jackyf joined
[18:36] <dalek> rakudo/ng: 7e4f20e | (Solomon Foster)++ | src/core/operators.pm:

[18:36] <dalek> rakudo/ng: Add simplest Whatever case to infix:<...>.

[18:36] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/7e4f20ef64bd5c7ef9b929869263953f626796dc

[18:36] <dalek> rakudo/ng: 4eb9894 | (Solomon Foster)++ | src/core/operators.pm:

[18:36] <dalek> rakudo/ng: Implement stupid first stab at lazy series operator with code blocks.

[18:36] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/4eb9894a09c96011813e4d4505be81f4be4b5234

[18:36] <dalek> rakudo/ng: f3e62dc | (Solomon Foster)++ | src/core/Iterator.pm:

[18:36] <dalek> rakudo/ng: Add Iterator.GrabAndSay method -- most definitely NOT in the spec -- in an effort to simplify lazy iterator implementation and debugging.

[18:36] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/f3e62dcb1d86ed7f801e646645ee472c772c2c79

[18:40] *** PZt left
[18:41] <colomon> for anyone looking, .GrabAndSay(5) (for instance) says the first five elements of an iterator.  Basically I got sick of writing "last if $_ > 5" and .eager when testing infinite iterators.  :)

[18:43] *** cdarroch joined
[18:43] *** cdarroch left
[18:43] *** cdarroch joined
[18:43] *** ShaneC joined
[18:43] *** k23z__ left
[18:44] *** k23z__ joined
[18:44] <colomon> Though now that I look at it, I'm wondering if I should have stuck it on Iterable instead of Iterator.

[18:45] *** mikehh joined
[18:50] <k23z__> hey check this out

[18:50] <k23z__> point checked if interior in polygon in c++ http://codepad.org/MmuDEHvO

[18:50] <k23z__> can you do better than that in Perl6 ? :D

[18:50] *** colomon left
[18:54] *** jonasbn joined
[18:57] *** _Jedai_ left
[19:03] *** _Jedai_ joined
[19:11] *** lichtkind joined
[19:13] *** colomon joined
[19:15] *** TSa joined
[19:16] <diakopter> k23z__: what do you mean by 'better'

[19:19] *** mikehh left
[19:24] *** ash_ joined
[19:27] <ash_> does nqp support multi methods? 

[19:30] *** payload left
[19:38] *** rgrau joined
[19:38] *** Khisanth left
[19:38] *** Khisanth joined
[19:45] <jnthn> ash_: no

[19:46] <ash_> does rakudo rely on parrots multi dispatch? or does it implement its own? 

[19:50] *** dual left
[19:50] *** dual joined
[19:51] <ash_> in my nq-nqp i have it parsing some basic variable declarations and function declarations, so now i am wondering how dispatching works

[19:52] *** Khisanth left
[19:52] *** Khisanth joined
[19:56] <diakopter> what's nq-nqp

[19:56] *** mberends joined
[19:56] <diakopter> ash_: I mean, in what are you writing it, is it public, etc

[19:56] <ash_> i am writing it, its not quite nqp 

[19:57] <diakopter> in what language(s)?

[19:57] <diakopter> and is it public?

[19:57] <jnthn> ash_: Implements its own.

[19:57] <ash_> i am taking a class on compilers, so i was going to try to apply what i have been learning and implementing part of nqp seemed like it might be worth taking a whack at 

[19:58] *** fridim_ left
[19:58] <ash_> its on github if you wana see it or help i can give you a commit bit, its in C++ because i am using the llvm for actual code generation 

[19:59] <ash_> C++ was mainly chosen because the llvm is written in C++, it does have other bindings but the C++ seem like the easiest for me to work with for now

[20:00] <ash_> jnthn: where is that in rakudo? i am curious about how you'd go about implementing multi dispatch 

[20:00] <ash_> diakopter: my repo is http://github.com/ashgti/nq-nqp-rx on github

[20:01] <jnthn> ash_: src/pmc/perl6multisub.pmc

[20:02] <ash_> cool, thanks

[20:02] <jnthn> ng: say min(1,2)

[20:02] <p6eval> ng f3e62d: OUTPUTÂ«Could not find non-existent sub &minâ¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[20:03] *** xomas_ left
[20:04] <jnthn> ng: my @x = 1,2,3; say @x.min

[20:04] <p6eval> ng f3e62d: OUTPUTÂ«1â¤Â»

[20:12] <ash_> jnthn: do you have any idea how you could implement the custom array indicies in ng? it seems like an odd feature IMO since it makes the array nearly act like a hash but its in S09 

[20:13] <mberends> ash_: I'm interested in nq-nqp-rx, so you might be interested in http://svn.pugscode.org/pugs/src/perl6/vill in which case we could contribute to each other's projects

[20:13] <jnthn> ash_: Not thought much about them.

[20:14] <ash_> yeah, i have seen vill, i do think it would be cool if we had nqp-rx implemented in llvm and if there was a way to extend it in some way so rakudo could do more work in nqp and less in pir, but that may not be possible/practical 

[20:15] <mberends> llvm looks a lot dumber than pir, unfortunately. no hashes, for example.

[20:16] <mberends> both projects coulod do with a library of similar primitive building blocks

[20:16] <mberends> *could

[20:18] *** TSa left
[20:18] <ash_> std::map<std::string *, p6opaque *> is what i was planning on using but i am having doubts about how i'll construct a C++ based p6opaque object, i am wondering if i need to build some infastructure in the llvm to support what I am doing, but i still haven't finished the dragon book, so i'll probably focus on that, my projects really more for me to learn, but i hope it might be useful to someone eventually 

[20:19] <ash_> well, the map is for a basic hash object 

[20:19] <mberends> the map template seems to be available to the compiler, but not to the generated IR :(

[20:20] *** payload joined
[20:20] <ash_> you can call it from IR if you know how to mangle the name right

[20:20] <ash_> which is the other thing i have been having problems with, C++ name mangling is so annoying. C names don't get mangled, but C++ ones do 

[20:21] <mberends> that's always the way with those two languages

[20:22] <mberends> it's because the underlying linkers and loaders are not namespace aware

[20:22] <ash_> for instance, i have been trying to figure out how to make some sort of std lib to add things to like say, but the C++ name gets mangled into _GLOBAL__I__Z3sayi when i compiled my version of say. so thats why i am trying to figure out what kind of infastructure i'd need to build in the llvm to support what i want to do 

[20:23] *** ignacio_ joined
[20:24] <ash_> i'll probably see how other projects like unladen swallow or rubinius do it before i do much more with my project

[20:30] <pugs_svn> r29662 | jnthn++ | [t/spec] Corrections and an unfudging for a multi test. 

[20:41] <jnthn> Another 30. :-)

[20:42] <mberends> \o/ ** 30

[20:43] <dalek> rakudo/ng: 4d6f164 | jonathan++ | src/builtins/Seq.pir:

[20:43] <dalek> rakudo/ng: Seq (and thus Array) should do Positional.

[20:43] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/4d6f1640bcb27d0379c95dbc59c479708631947e

[20:43] <dalek> rakudo/ng: 6c7f9ec | jonathan++ | t/spectest.data:

[20:43] <dalek> rakudo/ng: S06-multi/syntax.t now passes again.

[20:43] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/6c7f9ecf56a7931e064976f582beb598321f093f

[20:44] *** dugg joined
[20:45] <takadonet> how many test are we passing now in ng branch?

[20:45] <ash_> ng: my @a = 1, 2; say @a.WHAT;

[20:45] <p6eval> ng f3e62d: OUTPUTÂ«Null PMC access in elements()â¤current instr.: 'perl6;SeqIter;get' pc 11981 (src/builtins/Positional.pir:16)â¤Â»

[20:45] <ash_> jnthn do you know whats up with that?

[20:45] <jnthn> ash_: I've got an idea, yeah.

[20:46] <jnthn> takadonet: I think we must be around the 3000 mark or so.

[20:46] <jnthn> takadonet: The rate at which we're winning them back seems to be picking up though.

[20:46] <jnthn> ash_: It's on my "things to try and look at this evening", but quite a few things are. :-)

[20:46] <takadonet> jnthn: Good to hear. Waiting for you the ng branch to land before doing any perl6 coding

[20:46] <ash_> ah, okay, i was just wondering thats all ^_^ 

[20:47] <takadonet> s =~ /you//

[20:48] *** bluescreen left
[20:49] <dalek> rakudo/ng: 7459139 | jonathan++ | src/builtins/ (3 files):

[20:49] <dalek> rakudo/ng: Avoid some NPMCAs and make sure Positional and Associative roles know their names.

[20:49] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/74591399fbe8b79eb465c575a0d9391a791c5099

[20:49] * mberends aborts a spectest run to git pull again...

[20:53] * mberends need not have, pulls were up to date, (slow dalek)--

[20:53] <jnthn> ash_: Aww. It's not quite as easy to fix as I was hoping. Or at lesat, my first attempt failed.

[20:53] <ash_> why is it doing that? 

[20:54] <jnthn> ash_: Well, I had thought it was just hitting the .Str of the class rather than the one that a proto-object has.

[20:54] <jnthn> (Well, I still think it is...I'm just not sure why exactly.)

[20:55] <mberends> jnthn: do variables need to know their own names too, or just classes and roles?

[20:56] <jnthn> mberends: Variables need not know their names, no.

[20:57] <jnthn> mberends: For trait handlers, those know 'em, but they get passed a ContainerDeclarand object, not just the actual container.

[20:57] <jnthn> subs/methods etc should know their names too, btw.

[20:57] <mberends> jnthn: thought so, thanks. It's like filesystem hard links afaics

[20:57] *** cdarroch left
[21:00] *** bluescreen joined
[21:00] *** xomas_ joined
[21:00] *** xomas_ left
[21:00] *** xomas_ joined
[21:00] *** BitJam joined
[21:02] *** macae left
[21:03] <jnthn> Oh eww

[21:03] <jnthn> We hadn't got a proper impl of prefix:<~> for one thing...

[21:04] *** cjk101010 left
[21:06] *** ggoebel joined
[21:06] *** xomas_ is now known as xomas

[21:06] *** bluescreen left
[21:07] *** bluescreen joined
[21:09] *** ruoso left
[21:09] *** takadonet left
[21:10] <jnthn> ng: my $x = 0.5; say $x.WHAT

[21:10] <p6eval> ng 745913: OUTPUTÂ«Rat()â¤Â»

[21:10] <ash_> ng doesn't have infix ~ yet? 

[21:11] <jnthn> I think it does

[21:11] <jnthn> ng: say "a" ~ "advark"

[21:11] <ash_> s/infix/prefix/

[21:11] <p6eval> ng 745913: OUTPUTÂ«aadvarkâ¤Â»

[21:11] <jnthn> ash_: It has it, just not done right.

[21:11] <ash_> gotcha 

[21:11] <jnthn> I figure it's meant to be like prefix:<?>, which just calls .Bool, apart from it calls .Str.

[21:12] <jnthn> ash_: Oh! I think I know what's up. :-/

[21:13] <jnthn> ash_: It sees the proto-object for Array and is like "oh, that's an Array, I should flatten that!"

[21:13] *** SmokeMachine left
[21:16] <mberends> ng passes 3334 spectests on linux/amd64

[21:26] *** bluescreen left
[21:26] *** cdarroch joined
[21:26] *** cdarroch left
[21:26] *** cdarroch joined
[21:26] *** uniejo left
[21:27] <jnthn> 10% to master then... ;-)

[21:27] <PerlJam> anyone familiar with code_swarm?  I was thinking about putting a code_swarm configuration file in the Rakudo repo so that others could hack on the visualization for Rakudo.  Anyone see any problems with that or have any comments?

[21:27] <mberends> correction, ng passes 3037, todos 66 and skips 231 out of 3334

[21:32] <jnthn> ng: say <a b c>

[21:32] <p6eval> ng 745913: OUTPUTÂ«Method 'returns' not found for invocant of class 'String'â¤current instr.: 'perl6;Perl6;Actions;handle_named_parameter' pc 149464 (src/gen/perl6-grammar.pir:30472)â¤Â»

[21:32] <jnthn> ng: <a b c>

[21:32] <p6eval> ng 745913:  ( no output )

[21:32] <jnthn> ng: <a b c>.perl.say

[21:32] <p6eval> ng 745913: OUTPUTÂ«("a", "b", "c")â¤Â»

[21:33] <jnthn> hmm

[21:33] <ash_> thats an interesting bug

[21:33] <jnthn> Yeah, a tad perplexed on that one.

[21:33] <jnthn> ash_: Finding a couple of curiosities when stumbling through S06-multi/type-based.t

[21:33] <Tene> something is make-ing a literal string instead of a PAST::Val node in Actions.pm

[21:33] <PerlJam> (anyone care to see a code_swarm video for rakudo?)

[21:34] <Tene> and something else tries to set or get a type on it.

[21:34] <ash_> i don't know what code_swarm is, or i might? 

[21:34] <Tene> notice where the exception is thrown from.

[21:34] <jnthn> PerlJam: Code swarm? :-)

[21:34] <mberends> it would look pretty http://vis.cs.ucdavis.edu/~ogawa/codeswarm/

[21:34] <jnthn> Tene: Oh, it's doing a get on it, yeah.

[21:34] <PerlJam> code_swarm is a repo visualization tool

[21:34] <jnthn> Tene: Just not sure why it ain't making a decent node. :-)

[21:35] <jnthn> oh, I see it.

[21:35] <Tene> jnthn: that's certainly one argument against allowing literals in PAST.

[21:35] <PerlJam> Here's a run I did for Rakudo earlier today: http://feather.perl6.nl/~duff/rakudo-swarm.avi

[21:35] <dalek> rakudo/ng: 2d24344 | jonathan++ |  (3 files):

[21:35] <dalek> rakudo/ng: The role-in-PIR glue should wrap things in Perl 6 Methods as it adds them to the role. This means composition works out rather better, and we can make EnumMap and thus Hash do Associative, so they'll beind the %foo style parameters.

[21:35] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/2d2434461b0d884d6229ba35519272467ada38f2

[21:35] <jnthn> Tene: Hmm...they are allowed though. :-)

[21:35] <jnthn> I'll fix handle_named_parameters to deal with it. :-)

[21:35] <Tene> jnthn: has that ever stopped people from arguing? ;)

[21:36] <Tene> Glad I could help you find it, though.

[21:40] <jnthn> PerlJam: That's quite surreal. :-)

[21:41] <jnthn> ng: sub foo($a) { }; foo(<a b c>)

[21:41] <p6eval> ng 745913: OUTPUTÂ«Method 'returns' not found for invocant of class 'String'â¤current instr.: 'perl6;Perl6;Actions;handle_named_parameter' pc 149464 (src/gen/perl6-grammar.pir:30472)â¤Â»

[21:42] *** Su-Shee left
[21:42] <jnthn> It actually things it's looking through a list of parameters there. :-/

[21:43] *** iblechbot left
[21:54] *** cognominal joined
[21:56] *** jackyf left
[22:06] *** orafu left
[22:07] *** ggoebel left
[22:08] *** orafu joined
[22:10] <dalek> rakudo/ng: c5340f2 | jonathan++ | src/Perl6/Actions.pm:

[22:10] <dalek> rakudo/ng: Make sure handle_named_parameter doesn't blow up on literals in PAST trees.

[22:10] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/c5340f2fcafc369d48c7c49b316cb215cd472c0f

[22:14] *** lichtkind left
[22:17] *** nihiliad left
[22:18] *** jonasbn left
[22:20] *** pmurias joined
[22:23] *** orafu left
[22:24] *** OuLouFu joined
[22:24] *** OuLouFu is now known as orafu

[22:30] *** REPLeffect left
[22:31] *** ggoebel joined
[22:35] *** wasy is now known as wasy_afk

[22:41] <mberends> trying to use proto on ng, the first blocker is qqx{}; any volunteers to add it?

[22:43] <jnthn> mberends: You? ;-)

[22:43] <jnthn> mberends: In Grammar.pm see

[22:43] <jnthn> token quote:sym<qq>   { 'qq' <![(]> <.ws> <quote_EXPR: ':qq'> }

[22:43] <jnthn> You can probably do something very similar.

[22:44] * mberends was afraid that would be the answer ;)

[22:44] <jnthn> Then add an action for it that builds a PAST::Op( :name('!qx'), :pasttype('call'), $<quote_EXPR>.ast ) node or something like that.

[22:44] <jnthn> Then find the !qx from master.

[22:44] <jnthn> :-)

[22:45] <mberends> ok-ish :-)

[22:45] <jnthn> (.sub '!qx' or so, I think)

[22:52] *** ggoebel left
[22:53] <jnthn> mberends: Just yelp if you get stuck. :-)

[22:54] <mberends> just finishing a proto bisect first... some pattern matching problem now...

[22:56] <mberends> rakudo: my $foo="abcde"; $foo ~~ / b (.) d /; say $0

[22:56] <p6eval> rakudo 1d4928: OUTPUTÂ«câ¤Â»

[22:56] <mberends> ng: my $foo="abcde"; $foo ~~ / b (.) d /; say $0

[22:56] <p6eval> ng c5340f: OUTPUTÂ«Confused at line 1, near "say $0"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)â¤Â»

[22:57] <mberends> $0 $1 etc are broken :(

[22:57] <jnthn> mberends: More likely just nyri

[22:57] <mberends> ok, time to look at qqx{}

[22:59] <ash_> ng: "test" ~~ / t (.*) /; say $/;

[22:59] <p6eval> ng c5340f: OUTPUTÂ«testâ¤Â»

[22:59] <ash_> ng: "test" ~~ / t (.*) /; say $/.0;

[22:59] <p6eval> ng c5340f: OUTPUTÂ«Confused at line 1, near "say $/.0;"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)â¤Â»

[22:59] <ash_> ng: "test" ~~ / t (.*) /; say $/[0];

[22:59] <p6eval> ng c5340f: OUTPUTÂ«Can't postcircumfix:<[ ]> foreign objects yet.â¤current instr.: '!postcircumfix:<[ ]>' pc 309458 (src/gen/core.pir:40328)â¤Â»

[23:01] <ash_> hmmm no good

[23:01] <ash_> it looks like $/ might have the right values, but they might be accessible 

[23:03] *** jferrero joined
[23:03] *** pmurias left
[23:06] *** pmurias joined
[23:07] <dalek> rakudo/ng: 8faeb9e | jonathan++ | src/ (2 files):

[23:07] <dalek> rakudo/ng: Pave the way for lexical classes and even anonymous ones with names (er... :-)) to respond correctly to .WHAT; also make type objects of puns of roles report for .WHAT the name of the role.

[23:07] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/8faeb9e2ba0651add37671e0c507b14fe0d98a9c

[23:09] <jnthn> Well, there's the fix masak++ asked for. :-)

[23:11] *** patspam joined
[23:12] *** pmurias left
[23:20] *** cotto_w0rk joined
[23:23] *** cotto_working left
[23:26] *** REPLeffect joined
[23:30] *** mberends left
[23:33] *** PZt joined
[23:39] *** cotto_working joined
[23:40] *** rgrau left
[23:42] *** cotto_w0rk left
[23:43] *** mberends joined
[23:46] <mberends> heh, testing Reini's B::C on the eeePC eated almost all memory and froze the GUI

[23:47] <jnthn> .oO( you gave me a ram but I eeeted it )

[23:48] <mberends> gimme moar memry!

[23:51] *** ash_ left
[23:52] <mberends> perlcc viv

[23:52] <mberends> /usr/local/bin/perlcc: viv did not compile, which can't happen:

[23:52] <mberends> OH YES IT CAN!

[23:53] <jnthn> lol!

[23:54] <jnthn> Talk about a stress test. :)

[23:55] <mberends> 'twas a good plan, theoretically

[23:55] <jnthn> :-)

[23:56] <mberends> if TPF gives Reini $1000, perlcc will compile viv

[23:56] <diakopter> hee

[23:57] <diakopter> rurban is on magnet

[23:58] <mberends> then please send him my best wishes and appreciation :)

[23:58] *** hercynium joined
[23:59] <mberends> +1 to that grant application, still writing a comment :)

