[00:00] <pugs_svn> r29599 | lwall++ | [S07] start to work out relationship of item/slice context 

[00:00] <pugs_svn> r29599 | (seems they treat parcels similarly, if not identically...)

[00:01] <TimToady> (also doc EMPTY exceptions)

[00:01] *** uniejo joined
[00:02] <pmichaud> TimToady: Iterable flattens in list context... how about Iterator?  

[00:02] <pmichaud> (an iterator in a scalar doesn't flatten, but a "bare" iterator...?)

[00:03] <pmichaud> right now I'm working on the assumption that they do flatten -- makes a few things impler

[00:03] <pmichaud> *simpler

[00:05] *** nihiliad left
[00:06] <colomon> pmichaud: when I try to feed a Range or a RangeIterator to .map, it dings me about missing method list...

[00:06] <pmichaud> yes, known issue

[00:06] *** quietfanatic left
[00:06] <pmichaud> I have to get .list added in a variety of places

[00:06] *** lumi left
[00:06] *** lumi joined
[00:06] *** mikehh left
[00:06] <pmichaud> actually, try this:  in class Iterable, add

[00:07] <pmichaud>     method list() { self.iterator }

[00:07] *** mikehh joined
[00:07] <pmichaud> might work.

[00:07] <colomon> wondered if it might be that simple.

[00:07] <pmichaud> that will probably break at some point -- .iterator may need to return a scalar

[00:07] <pmichaud> but worth trying for the moment

[00:07] <pugs_svn> r29600 | lwall++ | [S03] add new E operator 

[00:08] <pmichaud> (fwiw, I agree that the huffmanization feels wrong on "E")

[00:08] <colomon> er, I'd need to create a Iterable.pm to do that, right?

[00:08] <pmichaud> colomon: yes, probably

[00:08] <colomon> I'm being beat on by a small child, will try that just in Range for the moment for simplicity.

[00:09] <TimToady> it's huffmanized by capitalization :)

[00:09] <TimToady> vertical huffman coding...

[00:09] <pmichaud> even then it feels too short :-)

[00:09] <pmichaud> but IANALD

[00:09] <TimToady> it's also potentially a metaop

[00:10] <TimToady> like Z might be someday, if we do zipwith as Z+

[00:10] * colomon is now picturing TimToady working font size into the mix, so that taller than normal E is the operator.

[00:10] <TimToady> decommuting &

[00:11] <colomon> your suggested .list works seems to work for Range.

[00:11] <colomon> Actually, seem to be getting a moment of respite from the boy, I'll try adding Iterable.pm here.

[00:12] <pmichaud> might be worth waiting on that

[00:12] <colomon> er?

[00:12] <pmichaud> I need to think about .list a bit more

[00:12] <colomon> okay, can do that too.

[00:12] <colomon> or rather, I can easily do nothing.  :)

[00:13] <colomon> So, if you feed an iterator to .perl, should it iterate and output the list of results?

[00:13] *** mikehh left
[00:14] *** mikehh joined
[00:14] <colomon> if nothing else, that would make testing map a lot easier at the moment...

[00:16] *** synth joined
[00:17] <pmichaud> you can do .eager.perl for the moment

[00:18] <colomon> \o/

[00:18] <colomon> (1..5).map({$_*$_}).eager.perl.say

[00:18] <colomon> (1,4,9,16,25)

[00:18] *** cdarroch left
[00:19] <lichtkind> TimToady: how does relate viv to gimme5 ?

[00:21] <pmichaud> laziness at work:

[00:21] <pmichaud> > my $a = (1,4,6).map({ say $_ * $_; }).iterator;  $a.get; say 'wait';  $a.get;

[00:21] <pmichaud> 1

[00:21] <pmichaud> wait

[00:21] <pmichaud> 16

[00:22] *** _ash joined
[00:23] <pmichaud> if we have:    my $a = (1,4,6).map({ say $_ * $_; });

[00:24] <pmichaud> what should $a contain?  A Seq?

[00:24] <pmichaud> (I'm guessing yes.)

[00:25] *** dkulchenko joined
[00:27] <pmichaud> afk, fetching dinner

[00:28] <colomon> pmichaud: wouldn't it be the same type of thing $a contained if you said my $a = (1, 4, 6) ?

[00:29] *** dkulchenko left
[00:29] <colomon> afk, time to   put someone to bed

[00:40] *** uniejo left
[00:40] *** athaba left
[00:42] <_ash> would it try to make the list into item context? which means a capture? 

[00:43] <_ash> .map i would expect to return a list, and since $ is item context i'd expect it to return the list in item context, so a capture

[00:44] *** lichtkind_ joined
[00:46] <_ash> S03 has:   item map { $_, $_*2 }, ^4   # [\(0,0),\(1,2),\(2,4),\(3,6)]  

[00:47] <_ash> i'd personally expect something similar, but i have been wrong many times before

[00:49] <_ash> although, i just noticed your using say in yours... would that be a list containing True, True, True then? 

[00:50] <_ash> rakudo: say (say 'hi').WHAT;

[00:50] <p6eval> rakudo 1d4928: OUTPUT¬´hi‚ê§Bool()‚ê§¬ª

[00:51] *** Chillance left
[00:51] *** dduncan joined
[00:52] <_ash> also, i could not be taking lazyness into account, so... maybe its supposed to be an iterator or Seq if its lazy

[00:52] *** Chillance joined
[00:56] *** lumi left
[00:56] *** lumi joined
[01:01] *** lichtkind left
[01:03] <dduncan> TimToady, about a recent synopsis change about Seq that I commented on, do you consider that any type which is lazy must also be classified mutable?

[01:04] <dduncan> I refer to r29582 and a Jan 23 comment

[01:06] *** quietfanatic joined
[01:06] <dduncan> on p6l

[01:09] *** meppl left
[01:19] *** araujo left
[01:21] <pmichaud> dduncan: immutable types are allowed to do lazy evaluation

[01:21] <dduncan> so why was Seq declared mutable then?  laziness seemed the cited reason, which I disagree with

[01:22] <dduncan> see http://www.nntp.perl.org/group/perl.perl6.language/2010/01/msg33123.html for what I said before ... never got an answer

[01:22] *** jferrero left
[01:22] <lichtkind_> good nicht

[01:23] <lichtkind_> night

[01:23] *** lichtkind_ left
[01:24] <dduncan> pmichaud

[01:27] <pmichaud> ah, I see.  I didn't notice Seq being declared mutable.  That surprises me a little also, but not enough to worry about it at the moment.

[01:27] *** pmurias left
[01:29] <dduncan> that concerned me though

[01:29] <dduncan> I have a stronger interest in the parts of the language about data types

[01:35] <pmichaud> oh.  Seq is listed as immutable also

[01:35] *** drbean joined
[01:35] <dduncan> hmm ...

[01:35] <pmichaud> I suspect it's a typo

[01:37] <dduncan> so it is

[01:37] <dduncan> but r29582 definitely *added* it to Mutable

[01:37] <dduncan> and I thought things were only supposed to be in 1 category

[01:38] <dduncan> if Mutable and Immutable aren't mutually exclusive, that needs explaining

[01:38] <pmichaud> at the time of the change we were still (and still are) trying to work out the details of the iterator interface

[01:39] <pmichaud> so Seq in that context was (I suspect) intended to replace the previous notion we had of List

[01:39] <pmichaud> while also recognizing that lists (as iterators) are in fact mutable

[01:39] <dduncan> I can understand that respect, if some iteration on a Seq would change the results of some other iteration

[01:40] <dduncan> but then it seems better to have 2 separate types, eg a Seq and an Iterator ... and maybe you do

[01:40] <dduncan> but the docs need cleanup

[01:40] <pmichaud> I suspect the mutable version will get a different name

[01:40] <dduncan> perhaps SeqIterator?

[01:41] <pmichaud> at the momnt, the ng1 branch is using List and Iterator

[01:41] <dduncan> speaking of Rakudo, I notice the front page didn't announce last week's release 25

[01:41] *** renormalist|work left
[01:42] <pmichaud> yeah, I got sidetracked and then didn't post the announcement

[01:42] <pmichaud> need to do that now

[01:42] <dduncan> I guess there's no automatic note when downloads is updated then

[01:42] <dduncan> like with CPAN feeds

[01:42] <pmichaud> at the moment, no

[01:45] * pmichaud tries "make spectest" in ng1, just to see the fireworks :)

[01:46] *** renormalist|work joined
[01:46] <_ash> fireworks are cool at times 

[01:46] *** LaVolta joined
[01:49] <dduncan> so is ng trunk now, or just planned to be before 26 comes out?

[01:49] <pmichaud> planned to be before 26

[01:49] <dduncan> okay

[01:54] *** lumi left
[01:55] *** lumi joined
[02:01] *** jaldhar joined
[02:02] <_ash> so, should $a = map { $_ * 2 }, (1, 2); return a Seq? 

[02:06] <dduncan> I would think so

[02:06] <dduncan> is it better for $a to be an Array instead?

[02:06] <dduncan> in the general case I would say no

[02:07] <dduncan> never mind, presumably you'd use [1,2] if you want the Array

[02:08] <dduncan> unless I'm confused

[02:08] <dduncan> I think of [...] building an array and I don't know the literal syntax for building a Seq, so I've been saying Seq.new(...) so far

[02:08] <_ash> well, i'd think the map would return a list, and since its an assignment to an item, it should call item context on the list

[02:09] <dduncan> I thought List was recently eliminated, but maybe it was just changed

[02:10] <_ash> list? as in ( ) lists? 

[02:10] <dduncan> I meant the type called List ... looking ...

[02:11] <pmichaud> it was aliminated, yes

[02:11] <pmichaud> *eliminated

[02:11] <pmichaud> but it may be coming back

[02:11] <_ash> when did that happen? wow, i missed that apparently

[02:12] <dduncan> I see List is a role, but not a class

[02:13] <pmichaud> my point is that it's not set-in-stone as to *what* it is

[02:13] <pmichaud> it's a "best guess" after considering the issues that were brought up late last week

[02:14] <_ash> ah, i see, i guess i am thinking in the wrong terms then of what types of things are being passed around

[02:15] <dduncan> all I know is that, for each of the simple collection types, like sets, bags, sequences/arrays, mappings/hashes, I want some type that is a "value" type ... as far as I know we do, but if Seq was made mutable it seemed then we didn't

[02:17] <dduncan> hmm, I am reminded or it looks like Enum and EnumMap are what used to be called Pair and Mapping, which were immutable

[02:17] *** ShaneC left
[02:18] <TimToady> I'm fine with Seq being considered immutable (but lazy), and adding a SeqIterator or whatever

[02:19] <TimToady> can't do it myself at the moment, have to go out tonight.

[02:19] <TimToady> bbl &

[02:19] <dduncan> thank you

[02:20] <pmichaud> ng1 has SeqIterator :-)

[02:21] *** nihiliad joined
[02:21] <dduncan> I'm going to copy that note to p6l before it is forgotten ...

[02:22] <dduncan> in reply to the commit note that started it

[02:26] *** ndeuwrrr joined
[02:27] <huf> YES. FUN.

[02:27] *** Guest52934 left
[02:29] *** Chazz joined
[02:29] *** Chazz is now known as Guest71329

[02:29] *** Guest71329 left
[02:29] *** Patterner left
[02:32] <dduncan> okay, done

[02:32] *** Chazz_ joined
[02:34] *** quietfanatic left
[02:36] *** orafu left
[02:36] *** orafu joined
[02:37] *** werdan7 joined
[02:37] *** dduncan left
[02:38] <diakopter> ugh

[02:39] *** diakopter sets mode: +R
 
[02:40] *** ndeuwrrr was kicked by diakopter (diakopter))
[02:42] *** lumi left
[02:43] *** lumi joined
[02:46] *** diakopter sets mode: -R
 
[02:47] *** sbilik joined
[02:47] *** hercynium joined
[02:50] *** nothingmuch left
[02:50] *** Exodist left
[02:50] *** wolverian left
[02:50] *** aesop left
[02:50] *** breinbaas left
[02:50] *** nothingmuch_ joined
[02:50] *** aesop joined
[02:50] *** breinbaas joined
[02:50] *** jaldhar left
[02:51] *** wolverian joined
[02:51] *** breinbaas left
[02:51] *** Exodist joined
[02:53] *** mikehh left
[02:53] *** breinbaas joined
[03:00] *** mikehh joined
[03:01] *** diakopter sets mode: -R
 
[03:02] *** Baggiokwok joined
[03:04] *** Baggiokwok left
[03:05] *** pilif12p joined
[03:05] *** pilif12p left
[03:06] *** mikehh left
[03:06] <colomon> > (1..100).map({ $^a % 5 == 1 ?? $^a !! Nil}).eager.perl.say

[03:06] <colomon> ((),(),6,(),(),(),(),16,(),(),(),(),26,(),(),(),(),36,(),(),(),(),46,(),(),(),(),56,(),(),(),(),66,(),(),(),(),76,(),(),(),(),86,(),(),(),(),96,(),())

[03:06] <colomon> That's with Iterable.list { self.iterator; }.

[03:06] *** mikehh joined
[03:06] *** am0c joined
[03:07] <PerlJam> colomon: is .eager doing anything useful there?

[03:07] <colomon> Yes, it's needed to get .map to iterate.

[03:07] <PerlJam> hmm

[03:07] *** RichiH left
[03:08] <colomon> It's not a long term thing, it's a today thing.

[03:10] *** nihiliad left
[03:10] *** RichiH joined
[03:10] <colomon> what I'm trying to figure out is where half of the numbers went.

[03:10] *** tmodiabcpd joined
[03:10] *** tmodiabcpd left
[03:12] <colomon> > (1..100).list.eager.elems.say

[03:12] <colomon> 100

[03:12] <colomon> > (1..100).map({ $^a % 5 == 1 ?? $^a !! Nil}).eager.elems.say

[03:12] <colomon> 10

[03:13] *** mikehh left
[03:13] <pmichaud> Nil is an empty parcel

[03:14] <pmichaud> but yes, some numbers are missing

[03:14] <colomon> right, should be 20.

[03:14] <PerlJam> ng: say 11 % 5

[03:14] <p6eval> ng 22b55c: OUTPUT¬´1‚ê§¬ª

[03:14] <pmichaud> > say { $^a , $^a }.count

[03:14] <pmichaud> 2

[03:14] <colomon> and if you look back at the .perl output, half of the numbers that should be there are missing, and at least of of the Nils.

[03:14] <colomon> ooooo.

[03:14] <pmichaud> it thinks the block has two parameters.

[03:15] <pmichaud> ng likely has the same problem

[03:15] <pmichaud> ng:  say { $^a, $^a }.count

[03:15] <p6eval> ng 22b55c: OUTPUT¬´2‚ê§¬ª

[03:15] *** mikehh joined
[03:15] <colomon> Hey, so it's a minor block problem and not a map issue at all.  \o/

[03:15] * pmichaud adds to ng's todo list

[03:15] *** araujo joined
[03:15] <PerlJam> colomon: at least it's not the iterator  :)

[03:16] <pmichaud> just pushed more changes to ng1

[03:16] <pmichaud> this gets Array and Seq working more properly

[03:17] <colomon> pmichaud: so for very very small values of "I ran some tests", Iterable.list { self.iterator; } works okay.

[03:17] <pmichaud> oh, I just change Iterable.list to return self :-)

[03:17] <pmichaud> *changed

[03:17] <colomon> hmmmm....

[03:18] <colomon> and did it in PIR, I see.  :)

[03:19] * PerlJam just noticed that there doesn't appear to be any tags for the Dec release

[03:19] <colomon> pmichaud: why can Array's !STORE just go away like that?

[03:20] <pmichaud> it inherits from Seq

[03:20] <colomon> ah.

[03:21] <pmichaud> Array used to inherit from List, and a bit difference between Array and List was that Array had copies of values which List had the original sources

[03:21] <pmichaud> *big

[03:21] <pmichaud> but now Array inherits from Seq, and Seq has copies of values also

[03:22] <pmichaud> I'm still trying to work out the exact meanings of List, Iterator, .list, and .iterator

[03:22] <colomon> understood.

[03:22] <pmichaud> my gut feeling is that List is an iterator that supplies flattening list context

[03:22] <colomon> still feels like you are making a lot of progress.

[03:22] *** am0c left
[03:22] <pmichaud> yes, I am

[03:23] <pmichaud> once we get to the point of being able to run tests through ng1, it becomes much easier to say "oh, this can't be right -- have to fix"

[03:23] *** mikehh left
[03:23] *** RichiH left
[03:23] *** RichiH joined
[03:25] *** mikehh joined
[03:26] <colomon> Seems like the spectest is already doing a lot better than it was two days ago.

[03:27] <colomon> (not that I counted, but tests seemed really broken the other day.)

[03:30] *** mikehh left
[03:30] *** lumi left
[03:31] *** lumi joined
[03:32] *** mikehh joined
[03:32] <colomon> I take it gather / take is still broken?

[03:33] *** Chazz_ left
[03:36] <colomon> oh, wow.  I almost feel like I can see how to turn it into an iterator.

[03:37] *** mikehh left
[03:38] *** mikehh joined
[03:38] *** sbilik left
[03:39] <colomon> hmmm... do you have to set the exception handler each time in .get, then?

[03:44] <pmichaud> yes, gather/take still broken

[03:44] <colomon> I feel like I can almost see what it should be, but not quite.

[03:45] *** diakopter sets mode: +R
 
[03:48] <colomon> ah well, should go to bed.

[03:48] *** samlh joined
[03:48] <colomon> I'll be very interested to see how gather / take ends up being implemented.

[03:50] *** samlh left
[03:55] *** LaVolta left
[03:56] *** lumi left
[03:56] *** lumi joined
[04:03] *** Chillance left
[04:07] *** stepnem left
[04:14] *** stepnem joined
[04:23] *** jaldhar joined
[04:27] *** jaldhar left
[04:28] *** jaldhar joined
[04:31] *** justatheory left
[04:35] *** LaVolta joined
[04:39] *** jaldhar left
[04:39] *** jaldhar joined
[04:44] *** lumi left
[04:44] *** lumi joined
[04:50] *** jaldhar left
[04:50] *** jaldhar joined
[05:02] *** quietfanatic joined
[05:04] *** pnate2 left
[05:04] *** pnate joined
[05:08] *** dilip joined
[05:08] *** ycxwgzzvmz joined
[05:08] *** ycxwgzzvmz left
[05:09] *** dilip left
[05:10] <Tene> g/t is broken in ng1?

[05:13] *** stephenlb left
[05:22] *** diakopter sets mode: -R
 
[05:43] *** lisppaste3 left
[05:44] <Tene> Okay, if I understand what the current model is, and I probably don't, this should work perfectly. :)

[05:48] * pmichaud looks for a diff

[05:51] *** lisppaste3 joined
[05:52] <pmichaud> just fixed Array.push|pop|shift|unshift

[05:54] *** lumi left
[05:54] *** lumi joined
[05:54] <Tene> I haven't posted it anywhere yet.  I'm testing before I commit.

[05:55] <Tene> It, um... kinda works. >.>

[05:56] <Tene> i wonder if I could implement a non-lazy version first, instead...

[05:56] <pmichaud> lazy one should be easier, actually.

[05:57] <Tene> The saved continuation ends up returning to the wrong place, is the problem.

[05:58] <pmichaud> nopaste?

[05:59] <Tene> see #parrot

[05:59] *** _jaldhar joined
[06:11] *** logre joined
[06:11] *** logre left
[06:17] *** pnate2 joined
[06:24] *** jaldhar left
[06:24] *** c9s left
[06:25] *** c9s__ is now known as c9s

[06:27] *** _ash left
[06:27] *** fda314925 joined
[06:31] *** pnate left
[06:40] <TimToady> pmichaud: I don't see how a List type can work.  Each iterator has to decide parameter by parameter how it's bound and whether it's flattening; a sig intermixes those demands.

[06:40] <TimToady> hence the new methods in S07, get is flattening, but getitem is not.

[06:41] <TimToady> getitem returns the next parcel, which is what you want either for positional parameters or slice elements

[06:41] <TimToady> (assuming non-parcels to be degenerate parcels)

[06:42] <TimToady> slice parcels are different from positionals primarily by coming in the variadic region.

[06:43] <TimToady> but I think they're more or less the same from the iterator's perspective.

[06:43] <TimToady> (method names are negotiable, of course)

[06:44] <pmichaud> TimToady: I see List as an iterator that flattens a-la list context

[06:45] <pmichaud> while other iterators simply return parcels according to their natural way of doing things

[06:45] <pmichaud> so, for list context, we simply wrap another iterator in a List

[06:45] <pmichaud> and it handles flattening

[06:45] <pmichaud> and .get is always like ".getitem"

[06:46] <pmichaud> i.e., an iterator author always implements .get, which returns parcels

[06:46] <TimToady> argument lists *switch* to list context partway through

[06:46] <TimToady> based on slurpy demands

[06:48] <pmichaud> right.  so when the parcel is being bound to a signature, it can send the slurpy arguments to a List iterator

[06:48] <pmichaud> which then imposes the list context on the remaining arguments

[06:49] <TimToady> okay, maybe. seems like an extra iterator, if the context knows which method to call

[06:50] <TimToady> but I can see how that could be made to work, assuming we never switch back to itemizing parcels

[06:50] <pmichaud> well, I can see how the other can work as well.

[06:50] <pmichaud> would you see .getitem as being the more fundamental, and the Iterator type then provides a default .get ?

[06:50] <pmichaud> (that knows how to flatten based on .getitem?)

[06:50] <TimToady> it also bothers me in the context of nextsame a bit

[06:50] <pmichaud> I haven't read the S07 update yet

[06:51] <TimToady> since the subsig might have a different idea, and the Capture might switch prematurely to list iteration from the standpoint of the subcall

[06:51] <pmichaud> I'd hate to see every iterator type have to implement its own list flattening code

[06:51] <pmichaud> well, in the version I'm doing, the parcel itself remains immutable, so it could be rebound

[06:52] *** pnate2 left
[06:52] *** sjohnson sets mode: +r
 
[06:52] <TimToady> 'kay

[06:52] <sjohnson> diakopter: putting +R isn't going to stop version requests, because they are CTCP'd to the channel, and he is not talking.  +r will prevent them from joining in the first place

[06:52] <pmichaud> ...but I'm real fuzzy on nextsame semantics, and don't have a strong horse in the race, so I'd prefer to go with your guidance

[06:53] <pmichaud> the other advantage of a List iterator is that Seq and Array (very common) can optimize based on knowledge of List's internal structure

[06:53] <TimToady> it just seems to me we probably shouldn't commit to flattening more than one parcel at a time, in case we get fancier with signatures that can intermix listy/slicey things someday

[06:54] <TimToady> though certainly there are some lists we can know will stay lists at compile time

[06:54] <pmichaud> oh, in early versions of ng1, I actually was envisioning that Parcel could have its own iterator

[06:54] <pmichaud> or, we could have an iterator that knows what to do in signature binding contexts

[06:55] <pmichaud> or still further, List could be smart enough to provide  .get  and .getparcel semantics :-)

[06:55] <pmichaud> so, .get flattens, and .getparcel (or .getitem)  gets the next item

[06:56] <TimToady> if all iterators support pushback, then parcel flattening can simply be pulling the parcels contents up into the not-gotten-yet list and then looking at the front again

[06:56] <pmichaud> I'm not sure all iterators should support pushback, though.

[06:56] <pmichaud> I'm fine if they do, though.  In which case I think it should just be standard in the Iterator type

[06:57] <TimToady> I'm not sure they shoudn't...

[06:57] <pmichaud> I'm trying to make sure that individual iterator authors don't end up having to rewrite pushback code :-)

[06:57] <TimToady> anyway, with that approach, you never have to commit to flattening more than one (top-level) parcel at a time

[06:58] <pmichaud> hmmm... as it is now I'm not really committed to flattening more than one parcel

[06:58] <TimToady> and one could conceivably have sigs that alternated flattening bindings with non-flattening, somehow

[06:58] <pmichaud> it just seems a little expensive to have every iterator support a pushback queue

[06:58] <TimToady> well, substituting an iterator for one parcel is isomorphic to hoisting it into the todo

[06:59] <pmichaud> and .get/.getitem have to know to read the pushback

[07:00] <TimToady> well, maybe they don't have to, if pushback is just substituting a different iterator whose tail continues with the original iterator

[07:00] <pmichaud> right, that's where I was heading with List

[07:01] <TimToady> I don't like to call that List, I guess

[07:01] <pmichaud> well, here's what I'd like to see (more)

[07:01] <pmichaud> someone implementing an Iterator really only needs to write a .get method that returns a parcel representing the next item in the iteration

[07:02] <pmichaud> (I'm fine if it's called .getitem)

[07:02] <pmichaud> the other behaviors should probably be built in terms of that particular method

[07:02] <pmichaud> and the person writing .get shouldn't have to worry about pushback, or handling pushback should be extremely straightforward

[07:03] <TimToady> maybe just use .get from parent class/role

[07:03] <TimToady> if it can do the wrapper iterator to schedule todo

[07:03] <TimToady> or to do pushback

[07:04] <pmichaud> I was working from the idea that Iterator itself would be lightweight, and the pushback and other behaviors would come from other special-purpose Iterators

[07:04] <pmichaud> (or one super-iterator that could provide a combination of those methods)

[07:04] <pmichaud> ....more to the point, let me ask a few questions that might clarify things in my head

[07:04] <TimToady> as usual, I'd like to have my cake and eat it too :)

[07:04] <pmichaud> what, exactly does .list return?

[07:05] <pmichaud> for example, if I have   @a.list --- what am I getting back?

[07:05] *** PacoLinux left
[07:05] <pmichaud> I've been thinking it would be the elements of @a in list context

[07:05] <TimToady> that seems like a no-op to me, if @ already implies .list

[07:05] <pmichaud> (which, don't flatten, obviously)

[07:05] <pmichaud> it can be a no-op, yes.

[07:06] <pmichaud> now then ,what about something like   @foo.map({...}).list   ?

[07:06] <TimToady> depends on the signature of the block

[07:07] <pmichaud> okay, so .list doesn't mean "list context" here?

[07:07] <TimToady> map/grep signatures are like the repeating groups in a variadic section of a signature

[07:07] <pmichaud> I would think that .list would imply flattening behavior

[07:07] <TimToady> it would throw away the parcels returned by each map, at least

[07:07] <pmichaud> right

[07:07] <TimToady> flatten, rather

[07:08] <pmichaud> which is actually somewhat different from a plain   @foo.map({...})

[07:08] <TimToady> yes, that doesn't commit its result to flattening

[07:08] *** diakopter sets mode: -rR
 
[07:08] <pmichaud> so, whatever is returned by @foo.map and @foo.map.list  has to be "different" somehow

[07:09] <TimToady> a .list contains no parcels

[07:09] <pmichaud> right

[07:09] <pmichaud> but both are lazy

[07:09] <pmichaud> and both are effectively iterators

[07:09] <pmichaud> which means there's something different between the two

[07:09] <TimToady> depends on whether the person reading it use .get or .getitem

[07:09] <TimToady> *uses

[07:10] <pmichaud> I would think that .get on the thing returned by .list would always be flattening

[07:10] <TimToady> well, no differnce in the list case

[07:10] <pmichaud> and .getitem as well

[07:10] <TimToady> since the parcels are gone

[07:10] <pmichaud> right

[07:10] <TimToady> .get is always flattening, but .list never gives it any parcels to flatten

[07:10] <pmichaud> the parcels are gone in the .list case, which means it's transforming the result, which means it's another iterator of sorts

[07:10] <pmichaud> okay, then I'm thinking more of .getitem

[07:11] <TimToady> which is what binding to a positional or a slice does

[07:11] <pmichaud> right

[07:11] <TimToady> and I'd like the sig of map/grep to be able to indicate which method to call

[07:11] <TimToady> default is .get, since we're assuming flattening

[07:12] <TimToady> but we need a way to indicate a parameter that is a "slice" element

[07:12] <TimToady> it's like map and grep sigs are really subsigs of a larger repeating variadic sig

[07:12] <pmichaud> by "sig of map/grep", do you mean the sig of the block?

[07:12] <Khisanth> sjohnson: actually the +R does stop the CTCPs

[07:13] <TimToady> currently -> $x {...} treats $x as positional, but map really wants that to use .get, not .getitem

[07:13] <Khisanth> it gets you a ":Please register with services ..." reply from the server

[07:13] <TimToady> yes, the sig of the block is really implicitly slurpy in a way

[07:14] <TimToady> and goes with the business of returning a partial match cursor in the iterator

[07:14] <diakopter> Khisanth: yes, another problem is that they're actually registered

[07:14] <diakopter> sometimes

[07:14] <TimToady> if you pass a parcel to a normal positional, it binds as a single item

[07:14] <diakopter> it's just less than a day until they switch ircds

[07:14] <TimToady> that is not your indicate expectation for map's $x

[07:14] <TimToady> *indicated

[07:15] <TimToady> you expected (1,2,3 Z 4,5,6).map to flatten

[07:15] <pmichaud> I wasn't sure what to expect, actually :-)

[07:15] <TimToady> so we need some way of marking such a sig as implicitly variadic

[07:15] <pmichaud> thus the question posed in Pm-19 :-)

[07:16] <TimToady> yes, which I've been mulling very hard.  :)

[07:16] <TimToady> and realizing that map/grep signatures aren't the same beasts as normal sigs

[07:17] <TimToady> but more like a *$x *$x *$x ... in a normal sig

[07:17] <pmichaud> right

[07:17] <TimToady> except called repeatedly

[07:17] <TimToady> so we don't have to worry about the fact that $x means different things

[07:17] <pmichaud> I see how it affects the map/grep signature now

[07:17] <pmichaud> interesting.

[07:17] <TimToady> so it's a bit like subrule matching

[07:18] <pmichaud> indeed.

[07:18] <TimToady> which works differently from matching a complete regex

[07:18] <TimToady> it's anchored to a position, and implicitly quantified externally, and returns its final position for the cursor

[07:18] <pmichaud> okay, so let me ask a few questions

[07:19] *** mberends joined
[07:19] <diakopter> mberends: hi

[07:19] <pmichaud> every iterator would support .get and .getitem ?

[07:19] <mberends> good (evening|morning)

[07:19] *** diakopter sets mode: +o mberends

[07:19] <TimToady> in my current view, yes, though derived support is fine

[07:20] <pmichaud> people writing iterators would tend to write .getitem, and the Iterator could derive .get from that?

[07:20] <TimToady> yes, where getitem returns the actual next object, even if it's a parcel

[07:21] <pmichaud> right

[07:21] <TimToady> what you'd bind a positional to, normally

[07:21] <pmichaud> .list produces something that maps .getitem to .get for the underlying iteration?

[07:21] <TimToady> yes, they become identical, presumably

[07:21] <pmichaud> (so that .getitem on a .list result ends up providing the flattening semantic)

[07:22] <TimToady> yes, the parcel boundaries have disappeared

[07:22] <pmichaud> well, they disappear lazily, yes?

[07:22] <TimToady> sure

[07:22] <pmichaud> as opposed to all-at-once ?

[07:22] <pmichaud> okay

[07:23] <pmichaud> I tend to think of List() as being an Iterator that just maps .getitem to .get, then :-)

[07:23] <pmichaud> (and has an underlying iterator it reads from)

[07:23] <pmichaud> I'm fine if we call it something else, or eliminate "List()" entirely in favor of a flag on an Iterator that says "you always flatten"

[07:23] <TimToady> could naturally, though perhaps not efficiently, be done with gather/take on the underlying

[07:24] <pmichaud> yeah, I tend to think of it in terms of having a pushback structure :-)

[07:24] <TimToady> I am leary of flags that have to be introspected these days  :)

[07:24] <pmichaud> at least from an efficiency perspective

[07:25] <pmichaud> right, so if it's not a flag, it seems like it wants to be its own type

[07:25] * diakopter bleary

[07:25] <pmichaud> I liked "List"  because of the analogy to "list context" and "result from .list"

[07:25] <TimToady> it would seem that pushback should fall out naturally somehow, though if you want to push back a parcel, and the outer is assuming list, you could have a problem

[07:26] *** nnyoyit joined
[07:26] <pmichaud> I suspect pushback does fall out naturally

[07:26] <diakopter> ok, expect severe oddities from irc; freenode is switching ircds now

[07:26] *** nnyoyit left
[07:27] <pmichaud> oh, wait, it doesn't quite fall out naturally.  drat.

[07:28] <pmichaud> can we have a way for iterators to support pushback such that the person writing .getitem doesn't have to worry about it?

[07:28] <TimToady> as long as getitem can tell its caller that its iterator has mutated to one that supports pushback somehow

[07:29] <pmichaud> I feel like I'd like to have (module names)  ".gennext"  which lazily produces the next item in the sequence, while ".get" and ".getitem" check the pushback queue first before calling .gennext

[07:29] <Tene> pmichaud: gather/take pushed

[07:29] <TimToady> which kinda argues that they all should, so you don't have to have that as a requirement

[07:29] <pmichaud> i.e., I'd like to separate the "read from iterator" methods from the "generate the next element" method

[07:29] <TimToady> that might be useful

[07:30] <TimToady> well iterators are mutating anyway, so switch implementations on the fly could be okayish

[07:30] <pmichaud> so, the Iterator base type provides the standard API for reading from an Iterator, and specific iterator implementations focus primarily on the "here's how you produce the next element" method

[07:30] <TimToady> *switching

[07:31] <TimToady> with perhaps a hot-track for unpushed, non flattening iterators

[07:31] <TimToady> but that's an optimizaiton

[07:31] <pmichaud> sure

[07:31] <pmichaud> and checking the pushback queue isn't likely to be all that expensive anyway

[07:32] <TimToady> well, if it's good enough for getc  :)

[07:32] <pmichaud> it can be an internal optimization flag

[07:32] <TimToady> switch vtables, and all that

[07:32] <pmichaud> right

[07:33] <pmichaud> actually, the "read from iterator" method just points to the "generate the next element" method for unpushed, non-flattening :-)

[07:33] <pmichaud> er, read item from iterator

[07:33] <pmichaud> but I think they should have different names

[07:34] <pmichaud> (and if you agree somewhat... what names would you like?  ;-)

[07:35] <pmichaud> Tene++

[07:36] <TimToady> maybe produce and producesome

[07:37] <TimToady> and I'm still officially worried about serial assumptions :)

[07:37] <pmichaud> good point :)

[07:37] * diakopter more worried about cereal consumption

[07:37] <pmichaud> s/next//

[07:39] <TimToady> anyway, "gen" is too close to "get" visually

[07:39] <pmichaud> agreed

[07:39] <TimToady> and as private-ish methods they want dehuffmanization

[07:39] <pmichaud> 'generate'

[07:40] <diakopter> .pull

[07:40] <TimToady> wonder how 'hyper' gets passed in

[07:40] <pmichaud> i've been wondering if hyper is just another form of iterator :-)

[07:41] <pmichaud> but likely no

[07:41] <TimToady> it seems to influence 'generate' more than 'getitem'

[07:41] <pmichaud> yes

[07:41] <TimToady> it's the generate that wants to distribute

[07:41] <pmichaud> exactly

[07:41] <pmichaud> well, there's always .generate(n)

[07:42] <pmichaud> but that feels like maybe it should be .hyper(n), which then calls generate......

[07:42] <TimToady> that's .generatesome(n)

[07:43] <TimToady> well, that's for another day, I expect

[07:43] <TimToady> which isn't for another 17 minutes here

[07:43] <pmichaud> that'd be fine with me.  is .generate okay for now, or do you think you'll want something different?

[07:43] <pmichaud> and did you ever decide on a replacement for IterDone ?  ;-)

[07:43] <pmichaud> (no, I didn't read the diffs today ... pmichaud--)

[07:43] <TimToady> currently specced as EMTPY

[07:43] <pmichaud> okay

[07:43] <TimToady> only spelled right

[07:44] <pmichaud> and .generate ... ?

[07:44] <TimToady> is fine for now

[07:44] <pmichaud> okay

[07:44] <pmichaud> we'll go with that

[07:44] <pmichaud> and every iterator has .get and .getitem methods

[07:44] <pmichaud> and perhaps the ability to pushback built-in

[07:44] <TimToady> I have to think about map sigs more, but that just shows up in to the iterator in which of those two are called

[07:45] <TimToady> my engrish is rotting

[07:46] <TimToady> still planning the demise of @@ in there as well, somehow

[07:46] <pmichaud> okay, thanks for those decisions.  We'll rework the ng1 branch to match.

[07:46] <TimToady> thanks for you patients

[07:47] <TimToady> *your

[07:47] <pmichaud> the other fixes we've done already to iterator code has really shortened some of the methods, too

[07:47] <pmichaud> and made the execution a fair bit more optimal

[07:47] <diakopter> patients are either victims or hypochondriacs

[07:47] <pmichaud> so I'm very happy overall with progress this week, although it's been far slower than I had hoped

[07:47] <TimToady> the two are not mutually exclusive

[07:47] <pmichaud> but I think we'll be back on track real soon

[07:48] <TimToady> well, my sole criterion is whether it's converging, not how fast

[07:48] <pmichaud> yes, but I have a target date :)

[07:48] <TimToady> *I* didn't promise anything in April  :)

[07:48] <pmichaud> no, you didn't.  :)

[07:48] <diakopter> it was in the stars...

[07:48] <pmichaud> well, when Rakudo * releases in April, and people say "but it doesn't match the spec", I can just say "Whatever!"

[07:49] <TimToady> well, ** might indicate slurpy slice

[07:49] *** brrant left
[07:49] * pmichaud snickers.... we're back to the steamroller again, but now it means *don't* flatten!

[07:49] <TimToady> really ought mean hyperflatten

[07:49] <diakopter> ***

[07:49] <TimToady> *oughta

[07:50] <TimToady> gha gotta goto bde sonn

[07:50] <diakopter> std: ***int

[07:50] <p6eval> std 29600: OUTPUT¬´ok 00:01 105m‚ê§¬ª

[07:50] <pmichaud> yeah, same here.  oh wait, I'm already in my bed!  :-)

[07:50] <TimToady> well, |$x is availabe, and maybe ($x)

[07:50] <TimToady> nighty night

[07:50] <pmichaud> ($x) looks good from a parcel perspective

[07:51] <TimToady> yeah, if it doesn't interfer with what we have already there in sigs

[07:51] <TimToady> zzz & # thunk

[07:52] <pmichaud> sleepytime here also -- bbiaw

[07:54] *** lumi left
[07:54] *** lumi joined
[07:54] *** eternaleye left
[07:55] <diakopter> hopefully soon we'll have a new freenode.

[07:56] <diakopter> std: ******

[07:56] <p6eval> std 29600: OUTPUT¬´ok 00:01 105m‚ê§¬ª

[07:58] *** jql left
[07:58] *** jql joined
[08:00] <diakopter> std: ***pi***^^***$!&&***@$()

[08:00] <p6eval> std 29600: OUTPUT¬´ok 00:01 107m‚ê§¬ª

[08:00] *** LaVolta left
[08:00] <quietfanatic> language, diakopter.

[08:00] <diakopter> or something

[08:00] <mberends> it parsed!

[08:01] <diakopter> pugs: ***pi***^^***$!&&***@$()

[08:01] <p6eval> pugs: OUTPUT¬´*** ‚ê§    Unexpected "***"‚ê§    expecting program‚ê§    at /tmp/siVy27Zbz2 line 1, column 1‚ê§¬ª

[08:01] <diakopter> program!  posh.

[08:01] <diakopter> rakudo: ***pi***^^***$!&&***@$()

[08:02] <p6eval> rakudo 1d4928: OUTPUT¬´** (HyperWhatever) is not yet implemented at line 10, near "*pi***^^**"‚ê§in Main (file src/gen_setting.pm, line 2582)‚ê§¬ª

[08:02] <quietfanatic> I think by current grammar rules, any number of stars can go between two terms or two operators, and any number larger than one can go between a term and an operator.

[08:02] <diakopter> rakudo: ordinate

[08:02] <p6eval> rakudo 1d4928: OUTPUT¬´Could not find non-existent sub ordinate‚ê§in Main (file src/gen_setting.pm, line 324)‚ê§¬ª

[08:02] <quietfanatic> Some things don't change :)

[08:03] <diakopter> std: 3***3

[08:03] <p6eval> std 29600: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row at /tmp/we9CJhatgj line 1:‚ê§------> [32m3***[33m‚èè[31m3[0m‚ê§    expecting any of:‚ê§  POST‚ê§   bracketed infix‚ê§    infix or meta-infix‚ê§      postfix‚ê§        postfix_prefix_meta_operator‚ê§       statement modifier loop‚ê§FAILED 00:01

[08:03] <p6eval> ..106m‚ê§¬ª

[08:03] <quietfanatic> Huh

[08:04] <quietfanatic> Oughtn't that be 3 * * * 3?

[08:04] <diakopter> ltm

[08:04] <diakopter> 3 ** * 3

[08:04] <quietfanatic> Oooooh

[08:04] <quietfanatic> right

[08:04] <diakopter> well, 3 ** * fail

[08:05] <quietfanatic> At least until someone writes prefix:<*>

[08:06] <diakopter> nytol&

[08:10] * colomon routinely has dreams where he is back at college but has forgotten to go to class all semester.  This is the first time even he has had a dream where it is the first day back at college for software engineering, and the college has sold its soul to Microsoft, which has representatives crawling all over the campus trying to convince all the new students to sell their souls...

[08:11] <colomon> backlogging.

[08:12] *** cjk101010 joined
[08:12] * mberends wants to buy back his soul, paying in #perl6 tuits...

[08:19] *** drbean left
[08:19] *** yves left
[08:20] <cj> any of you lingrists want to learn something about Lushootseed?

[08:20] <cj> http://wp.colliertech.org/cj/?p=714

[08:23] <colomon> Tene++ # gather / take

[08:24] <colomon> Though, um...

[08:24] <colomon> > my $a = (1..10).grep({$^a % 3 == 1}); my $b = (1..10).grep({$^a % 4 == 2}); say $a.get; say $b.get; say $a.get; say $b.get;

[08:24] <colomon> 2

[08:24] <colomon> 2

[08:24] <colomon> 6

[08:24] <colomon> 6

[08:31] *** wanradt joined
[08:32] <colomon> Current code only allows us to have one gather / take active at a time?  except that isn't quite right, it's like two copies of the same gather / take instead of two different ones.  very odd.

[12:52] *** ilogger2 joined
[12:54] *** mssmfs joined
[12:55] *** tomaw joined
[13:02] *** arnsholt joined
[13:03] *** sunnavy joined
[13:07] <colomon> Tene: ping?

[13:20] <colomon> phenny: ping?

[13:22] *** dakkar joined
[13:27] <colomon> hello world?

[13:28] <Su-Shee> "yes, my son?"

[13:28] <colomon> oh good, I'm not the only living person on #perl6

[13:28] <Su-Shee> no, it's just heavily splitted it seems.

[13:29] <colomon> ah, I thought whatever was happening last night was supposed to fix that.

[13:29] <Su-Shee> maybe a deep sea internet cable again ;)

[13:30] <colomon> well, we're on opposite sides of the Atlantic...  :)

[13:30] <jnthn> I think the ircd migration last night might have caused everyone to fall off the channel.

[13:30] <Su-Shee> jnthn: and they plainly didn't rejoin?

[13:30] <Su-Shee> hm, good opportunity to clean up :)

[13:30] <jnthn> Su-Shee: My client normally manages to re-join automatically

[13:30] <jnthn> Su-Shee: But failed to for some reason.

[13:30] <colomon> jnthn: same here.

[13:31] <jnthn> Suspect it was just a side-effect of the migration then.

[13:31] <colomon> jnthn: do we have a spot for rakudo-specific test files?

[13:31] <jnthn> colomon: Rakudo-specific?

[13:31] <jnthn> colomon: t/ in the Rakudo repo is perhaps the place though.

[13:33] <colomon> for instance, we've got MapIterator now, which is a pretty key component, but it's not in the spec, as far as I know.

[13:33] <saschi> hi

[13:34] <colomon> hello

[13:38] *** buu joined
[13:43] *** LylePerl joined
[13:44] <LylePerl> hi all

[13:45] <LylePerl> Following the success of our groups Perl talk at University of Western England, Bristol

[13:45] *** buubot joined
[13:45] *** lisppaste3 joined
[13:45] <LylePerl> I've convinced them to host what we are calling "Perl 6 Discovery Workshop"

[13:46] <LylePerl> Details at http://www.perl6.org.uk

[13:46] <colomon> ah, the source of the mysterious web page.  :)

[13:46] <LylePerl> :)

[13:47] <LylePerl> Yeah, got bogged down with uni work, etc, so this has got a little delayed

[13:47] <LylePerl> was planned for next month, but probably wont be until march april now

[13:48] <jnthn> LylePerl: Where abouts in the UK will it be, out of curiosity?

[13:48] <jnthn> Oh, wait, Bristol.

[13:48] * jnthn should read

[13:49] <Su-Shee> shiny onion :)

[13:50] <LylePerl> I prob should have discussed it with you guys first, but I wanted to be sure the uni would go ahead before taking up your time

[13:50] <LylePerl> I've seen that other Perl groups have done things like fly some of you in to talk

[13:51] <LylePerl> Unfortunately our group is still new and doesn't have any rich/well off sponsors :(

[13:51] <LylePerl> Although if any of you happen to be in the UK at that time, it would be great if you popped along

[13:53] <LylePerl> My knowledge of Perl 6 is still very limited

[13:54] <LylePerl> I need to form a list of areas for the worksgroups to look into (details of workshop format on the site)

[14:09] *** go|dfish joined
[14:22] *** hercynium joined
[14:22] *** nihiliad joined
[14:30] *** PZt joined
[14:34] <LylePerl> I think at the end of the workshop, after the talks, it's also be good to talk to people about easy ways they can contribute to Perl 6

[14:35] <sjohnson> das perl

[14:35] *** Baggiokwok joined
[14:37] *** rhr joined
[14:54] *** Patterner joined
[15:00] *** dugg joined
[15:01] *** lichtkind joined
[15:02] <lichtkind> cheers

[15:02] *** colomon2 joined
[15:03] <lichtkind> is here anybody that can me tell something about elf?

[15:11] <pmurias> LylePerl: how do you imagine to workshop to look like? groups of people reading the synopsis and typing stuff into rakudo trying to figure how things work like?

[15:17] *** Baggiokwok left
[15:17] *** PacoLinux joined
[15:25] *** pmichaud joined
[15:25] *** Su-Shee joined
[15:28] <pmichaud> good morning, #perl6

[15:28] *** nbrown joined
[15:34] <colomon2> morning!

[15:36] *** cognominal joined
[15:36] *** Psyche^ joined
[15:36] *** Psyche^ left
[15:36] *** Patterner left
[15:44] *** mikehh joined
[15:47] <colomon2> pmichaud: I'm very excited to see lazy gather / take up and running.

[15:47] <pmichaud> yes, but as you noted, there's a bug in grep.

[15:47] <pmichaud> I'm looking at that now.

[15:48] *** cotto joined
[15:49] <colomon2> If you mean the strange bug with the second iterator overriding the first, I think that's got to be a gather / take bug.  At least, grep's source code is very simple, and (barring the wierdness with $_) worked fine with the old gather / take.

[15:50] <pmichaud> actually, I think the problem may be with grep

[15:50] <pmichaud> the grep is using 'for', which is eager.

[15:50] <pmichaud> (not in spec, but in the current ng1 implementation for is eager)

[15:50] <colomon2> oh.

[15:51] <pmichaud> yes, switching to map seems to have.... issues

[15:51] <pmichaud> hmmmm

[15:54] *** mikehh left
[15:54] <pmichaud> hmmmmm

[15:54] <pmichaud> ohhhhhh

[15:55] <pmichaud> no, that's not it.

[15:55] <pmichaud> hrm.

[15:55] <pmichaud> even when I switch .grep to not use map at all, I end up with the problem

[15:55] <pmichaud> sorry

[15:55] <pmichaud> let em rewrite

[15:55] <pmichaud> even when I switch .grep to not use gather/take at all, I end up with the problem

[15:55] <colomon2> really?

[15:55] <pmichaud> yes

[15:56] *** mikehh joined
[15:56] <colomon2> hmmm.... rangeiterator bug?

[15:56] <pmichaud> wouldn't think so, but possible

[15:56] <pmichaud> let me reset locally and try again

[15:56] <pmichaud> and I'll commit a patch so you can play along too :-)

[15:56] <colomon2> Thank you.

[15:57] <colomon2> In theory I'm cleaning my office, but I've sneaked a log-in from my office machine onto the MacBook in the other room so I can hack on ng1 a bit, too.  :)

[16:01] <colomon2> doesn't seem to be any difficulty running two RangeIterators in "parallel".

[16:02] *** Patterner joined
[16:03] <pmichaud> http://nopaste.snit.ch/19419  # problem with multiple greps

[16:03] <pmichaud> notice there's no gather/take involved there.

[16:04] *** diakopter joined
[16:04] *** ChanServ sets mode: +o diakopter

[16:05] <colomon2> yup.

[16:05] *** diakopter sets mode: +oooo TimToady pmichaud moritz_ obra

[16:05] *** diakopter sets mode: +oooo sunnavy Tene colomon cotto

[16:05] <pmichaud> I'm thinking it has to be an issue with the closure block

[16:05] *** diakopter sets mode: +o jnthn

[16:06] <diakopter> g'morn

[16:07] <pmichaud> yes, that's it

[16:07] <pmichaud> there's no clone taking place

[16:08] <pmichaud> I wonder which will be faster, though -- writing grep using .map and gather/take  or using .map and next

[16:09] *** mikehh left
[16:09] *** mikehh joined
[16:11] <colomon2> or even writing grep as an iterator of its own...

[16:11] <pmichaud> I'd probably vote against that

[16:11] * colomon2 is worried that colomon just quit.

[16:12] <diakopter> heh

[16:13] *** diakopter sets mode: +vvvv buubot _ilbot2 ilogger2 IRSeekBot

[16:13] *** diakopter sets mode: +vvv lambdabot lisppaste3 pugs_svn

[16:13] <diakopter> oh, no dalek

[16:13] <diakopter> <frown>

[16:13] <diakopter> feather is happily very responsive

[16:13] *** ChanServ left
[16:13] *** wolverian joined
[16:14] <pmichaud> looks like a problem with whatever code is blessing closures into Block

[16:15] *** mikehh left
[16:15] * pmichaud has a serious "wtf?!" moment upon seeing the Block code

[16:15] *** dalek joined
[16:16] *** diakopter sets mode: +v dalek

[16:17] *** mikehh joined
[16:19] *** tylerni7 joined
[16:23] *** pnate joined
[16:24] <colomon2> My wife shut down the MacBook Pro, which is where colomon was logged in.  Also, unfortunately, where my ng1 build is.

[16:24] <pmichaud> np -- the problem is in the closure handling code

[16:24] <colomon2> so, might that also explain why grep was getting the wrong $_?

[16:25] <colomon2> That is, it was getting from from grep's calling point, rather than inside the grep code.

[16:25] <colomon2> like

[16:25] <pmichaud> grep isn't getting the wrong $_

[16:25] <pmichaud> it's getting the wrong block

[16:25] <colomon2> ng: (1...10).grep({ say $_; })

[16:25] <colomon2> oh, bother, no dalek.

[16:25] <diakopter> it's here

[16:26] <diakopter> oh, p6eval

[16:26] <diakopter> sec

[16:27] *** p6eval joined
[16:27] *** diakopter sets mode: +v p6eval

[16:27] <diakopter> ng: (1...10).grep({ say $_; })

[16:27] <p6eval> ng 22b55c: OUTPUT¬´Mu()‚ê§Mu()‚ê§Mu()‚ê§Mu()‚ê§Mu()‚ê§Mu()‚ê§Mu()‚ê§Mu()‚ê§Mu()‚ê§Mu()‚ê§¬ª

[16:27] <colomon2> yeah, that problem there.

[16:27] <colomon2> diakopter++

[16:28] <pmichaud> ng:  (1...10).say

[16:28] <p6eval> ng 22b55c: OUTPUT¬´12345678910‚ê§¬ª

[16:28] <pmichaud> yes, it may indeed be the same problem

[16:28] <pmichaud> at any rate, closure creation seems messed up at the moment

[16:29] <colomon2> I'm pretty sure that if we can fix that, grep.t will pass.  :)

[16:29] <pmichaud> and quite a few other things using map or anywhere that we pass a block as aparam

[16:30] *** mikehh left
[16:35] *** mikehh joined
[16:36] <LylePerl> pmurias: I guess so... It's a bit of an experiment, i think it'll be interesting to see what people come up with... I really want to encourage them to look into it for themselves, rather than being told. So they get the bug, go home and keep going into it

[16:37] <colomon2> afk: dim sum

[16:39] <pmichaud> afk, breakfast

[16:50] *** _ash joined
[16:52] *** Vyg3R joined
[16:54] *** ejs joined
[16:55] *** omps` joined
[16:56] *** mikehh left
[16:56] *** dakkar left
[16:58] *** omps` left
[16:58] *** mikehh joined
[16:58] *** omps joined
[16:59] *** justatheory joined
[17:02] *** Vyg3R left
[17:11] *** _ash left
[17:12] *** _ash joined
[17:14] *** _ash left
[17:15] *** ejs left
[17:15] *** arthur-_ joined
[17:18] *** justatheory left
[17:19] *** mikehh left
[17:19] *** spinclad joined
[17:21] *** Chillance joined
[17:21] *** mikehh joined
[17:30] *** omps left
[17:35] *** xinming joined
[17:37] *** gabiruh joined
[17:43] *** mikehh left
[18:02] <pugs_svn> r29601 | lwall++ | [pm.txt] some not-entirely-nailed-down ideas for direction on Pm<18 19> 

[18:02] <pugs_svn> r29601 | @@ is going away, @ is decoupled from flattening, coercions/contextualizers always

[18:02] <pugs_svn> r29601 | take a parcel, not a list.  Some speculations on how map/grep should rewrite sigs

[18:02] <pugs_svn> r29601 | to be more like subpattern matches.

[18:05] *** jql joined
[18:07] <diakopter> using depth = UInt32; public class Block : PrototypeChain<depth, Block> {

[18:08] <diakopter> jnthn: check out that class declaration :D

[18:09] * diakopter starting to reap the fruits of implementing PrototypeChain<TKey, TValue> in C#

[18:12] <diakopter> what's even more interesting is that Block's derived classes themselves (and the derived classes thereof) are actually compiled-to-classes representations of a string->slot closures system itself (which can less efficiently be represented as a PrototypeChain<string, VarSlot>)

[18:13] <diakopter> codegen is fun.

[18:27] *** jan_ joined
[18:29] *** nihiliad left
[18:30] *** k23z__ joined
[18:34] *** breinbaas joined
[18:55] *** s1n joined
[19:00] *** justatheory joined
[19:01] *** k23z__ left
[19:06] *** k23z__ joined
[19:13] *** ejs joined
[19:22] *** justatheory left
[19:34] <pmichaud> anyone have any suggestions for a warm sunny place to vacation next weekend?  Hopefully not too difficult to reach from DFW?  ;-)

[19:38] *** akl joined
[19:40] <pmichaud> TimToady: From the latest pm.txt:

[19:40] <pmichaud> Therefore list($a) and $a.list should do the same thing, if indeed

[19:40] <pmichaud> it's a coercion.  But again, that thing it's doing is something

[19:40] <pmichaud> ...

[19:41] <TimToady> Um

[19:41] <pugs_svn> r29602 | lwall++ | [S02,S03] start detangling sigils from other contexts 

[19:41] <pugs_svn> r29602 | No longer use .list to mean force-flat semantics

[19:41] <pugs_svn> r29602 | "List" now always means lazily contextual.

[19:41] <pugs_svn> r29602 | Use .flat or .slice to be specific about that

[19:41] <pugs_svn> r29602 | @@ is starting to go away (don't have sig relief for slices yet)

[19:41] <pugs_svn> r29602 | @ no longer means .flat

[19:41] <pugs_svn> r29602 | @($x) and @$x defined to be identical

[19:41] <pugs_svn> r29602 | Foo($x) and $x.Foo defined to be identical for any known Foo type

[19:41] <pmichaud> okay, reading update.

[19:41] <pugs_svn> r29602 | Args to coercions always passed as parcels, not flat lists

[19:42] * diakopter watches hope meter change direction to clockwise

[19:42] <pmichaud> I think I should've found a way to ask some of these questions long ago :)

[19:42] <TimToady> diakopter: don't index your hope meter to the 3rd derivative  :P

[19:43] <lichtkind> diakopter: thanks for your time yesterday

[19:44] * TimToady now has to think about signature relief for flat/slice binding, and contemplate (shudder) an S09 rewrite...

[19:45] <pmichaud> TimToady: you prefer RangeIter to RangeIterator ?

[19:45] <diakopter> Ranger

[19:45] <TimToady> I'd like -Iter to be a productive suffix

[19:45] <pmichaud> that's fine, just verifying

[19:46] <TimToady> hmm, we could even do Range-Iter, Seq-Iter and avoid Camel-Case

[19:46] <pmichaud> well, that's still CamelCase of a form, just hyphenated :-)

[19:46] <pmichaud> I prefer non-hyphen, myself.

[19:46] <pmichaud> Don't know why.

[19:46] <TimToady> is fine

[19:46] <TimToady> just didn't like that MyTypeIterator kept causing column overflow

[19:46] <pmichaud> agreed

[19:47] <pmichaud> RangeIter is fine

[19:47] <pmichaud> but the base type is still "Iterator"

[19:47] <pmichaud> (which is fine, just confirming)

[19:47] <TimToady> yes, though it was kinda woggly there for a bit :)

[19:47] <pmichaud> oh dear, I have to go re-think and readjust all of my terms again

[19:47] <TimToady> had it as Iter for a while, then changed back

[19:47] <pmichaud> Scalar(...)  is back in the picture?!?

[19:47] <pmichaud> *sigh*

[19:48] <TimToady> maybe not, but I wanted to name a role

[19:48] <pmichaud> we still have C<list> ?

[19:48] <TimToady> something that hides an intrinsically flattenable object

[19:48] <TimToady> it's pretty much a no-op

[19:49] <TimToady> might go away

[19:49] <pmichaud> Seq doesn't autoflatten?

[19:49] <pmichaud> that's.... icky.

[19:49] <TimToady> Parcel does

[19:49] <pmichaud> right, but Seq does Iterable

[19:50] <pmichaud> and (at least as of yesterday)  Iterable flattens

[19:50] <TimToady> well, that one might go back the other way

[19:51] <pmichaud> what I have currently in ng1, which seems to work _really_ well (more)

[19:51] <pmichaud> anything that is Iterable flattens, but things in scalar containers don't flatten

[19:51] <TimToady> was thinking of it more like Scalar[Seq], so maybe the Scalar container is in need of a handier name

[19:51] <TimToady> what are you calling it currently

[19:51] <pmichaud> so,  [1,2,3]  is a scalar reference to an Array

[19:52] <pmichaud> currently it's  Perl6Scalar  (an internal name)

[19:52] <TimToady> well, Ref is available :)

[19:52] <pmichaud> one thing I'm not quite so sure about though (more)

[19:53] <TimToady> but maybe it means AntiIterable

[19:53] <pmichaud> sub foo() { return $x; }      #  the result of foo() doesn't flatten by default

[19:53] <pmichaud> however

[19:53] <TimToady> comes back as ($x)

[19:53] <pmichaud> sub foo() { return $x.list; }   #  the result of foo() does flatten, because it's not a scalar

[19:54] <TimToady> well, that's why we're splitting .list from .flat

[19:54] <TimToady> $x.list wouldn't flatten now

[19:54] <pmichaud> well, .flat is different here

[19:54] <pmichaud> I see three cases

[19:55] <pmichaud> $x  -  return something that doesn't flatten at all (unless explicitly commanded to do so)

[19:55] <pmichaud> $x.list -  return something that flattens if placed in a flattening context

[19:55] <pmichaud> $x.flat -  force whatever is returned to be flattened, regardless of context

[19:55] <TimToady> that seems right

[19:55] <pmichaud> that's why .list is slightly different from .flat

[19:56] <pmichaud> .list is "can flatten", while .flat is "must flatten"

[19:56] <TimToady> well, that's why .list is slightly different from a no-op, when there's only one thing

[19:56] <pmichaud> right

[19:56] <TimToady> list($x) likewise

[19:56] <pmichaud> so, that was my question I started before the above

[19:57] <pmichaud> for $x, $y { ... }    #  two iterations, yes?

[19:57] <pmichaud> for list($x) { ... }   #  one iteration?  or depends on $x ?

[19:57] <TimToady> depends on $x

[19:57] <pmichaud> okay, that's a newish behavior then

[19:58] <pmichaud> [$x]   -  array with one element

[19:58] <TimToady> but should be same as $x.list by new def

[19:58] <pmichaud> [list $x]   -  array with number of elements determined by $x

[19:58] <TimToady> yes

[19:58] <pmichaud> [list $x,$y]   - array with two elements

[19:58] <TimToady> yes, list is no-op on a list :)

[19:58] <TimToady> well, strictly, on a Parcel

[19:58] <pmichaud> for $x { ... }   # one iteration, regardless of $x ?

[19:59] <TimToady> correct

[19:59] <pmichaud> what's the equivalent .map?

[19:59] <TimToady> map {...}, $x

[19:59] <pmichaud> there's not a method-based equivalent?

[20:00] <TimToady> item($x).map

[20:00] <pmichaud> and  for $x,$y { ... }   is equivalent to   item($x,$y).map  ?

[20:01] <pmichaud> (until now my mental model for "for ... {block}"   had been   list(...).map({block}) )

[20:01] <pmichaud> (but that no longer works.)

[20:02] <TimToady> why wouldn't it?

[20:02] <pmichaud> because   for $x {block}  is not the same as   list($x).map({block})  in the new scheme

[20:03] <pmichaud> I had been distinguishing   "in list context" from  "value as a flattenable list"

[20:03] <pmichaud> (the former was  list(), the latter was .list)

[20:04] <pmichaud> so,  list($x)  was $x in list context  (doesn't flatten),  while  $x.list was "$x as a flattenable entity"

[20:04] <TimToady> I see what you're saing

[20:04] <TimToady> y

[20:05] *** Chillance left
[20:07] <TimToady> the latter wants to be something more like $x.iterable seems like

[20:08] <TimToady> or $x.unwrap, or some such

[20:08] <pmichaud> well, it can be  @$x, if the @ implies Iterable

[20:09] <TimToady> but I'd like to keep the notion of lists as orthogonal to the flattening decision as possible now

[20:09] <TimToady> so .list is probably bad for that

[20:09] <pmichaud> but I'm still not sure how to translate   for ... {block}   to an equivalent map

[20:10] <pmichaud> (a method based form, at any rate)

[20:10] <pmichaud> oh, perhaps it's

[20:10] <pmichaud>     [...].map({block})

[20:10] <TimToady> don't see why we need an array

[20:11] <pmichaud> well, we want something that imposes list context but doesn't flatten scalars

[20:11] <pmichaud> could be   list($x,Nil).map({block})  instead

[20:11] <TimToady> well, maybe list should do that, even for list($x), which would be a no-op

[20:11] <TimToady> and we unwrap a $x elsewise

[20:12] <pmichaud> well, if list() does that, it seems like it's no longer orthogonal to the flattening decision :)

[20:12] <TimToady> list would always be lazy context, flattening agnostic

[20:13] <TimToady> the choice depends on the map's block's sig

[20:13] <TimToady> likewise for for

[20:13] <TimToady> list($x) wouldn't be a nop-op, it would be a trivial list

[20:14] <pmichaud> basically, ng1 has it that list($x)  forces a parcel iteration of $x instead of itemizing $x out of the parcel

[20:14] <TimToady> a Parcel, perhaps

[20:14] <pmichaud> or, more precisely

[20:15] <pmichaud> list(...) forces parcel iteration of the ..., even if it has only one item in it

[20:15] <pmichaud> put a different way,    list($x).flat   doesn't flatten $x, while  ($x).flat would

[20:17] <pmichaud> or perhaps the way to think of it is...

[20:17] <pmichaud> (we can change names)

[20:17] <pmichaud> list($x).foo   # forces .foo to be invoked on the parcel containing $x

[20:17] <pmichaud> ($x).foo  #  invokes .foo on $x directly

[20:18] <pmichaud> so perhaps list()  is really Parcel($x)

[20:18] <pmichaud> but that gets ickyish in other respects

[20:19] <TimToady> kinda like (\($x)).foo

[20:19] <pmichaud> it might be worth noting that in ng and ng1,  the parcel constructor is  infix:<,>

[20:19] <pmichaud> and so ($x)  really isn't a Parcel anyway

[20:19] <pmichaud> (except conceptually)

[20:20] <TimToady> well, any item that isn't a Parcel is degenerate parcel

[20:20] <pmichaud> right

[20:20] *** allbery_b joined
[20:21] <pmichaud> and what list(...)  currently does is create a Parcel containing (...), and then a List (iterator) that iterates the Parcel

[20:21] <pmichaud> so list($x)  really creates a flattening iterator for a non-degenerate Parcel containing $x

[20:22] <TimToady> sounds good to a brane that is short on nutriments...

[20:22] *** nihiliad joined
[20:23] <pmichaud> well, let me re-read the updated specs and see if I can tease out the semantics of the new definitions

[20:23] <TimToady> a non-degenerate Parcel sounds like a Ref

[20:23] <pmichaud> maybe, but I want iteration to be different

[20:23] <pmichaud> iterating a Parcel with one item should not iterate the one item (if the one item is non-flattening)

[20:24] <pmichaud> that seems different to me than a Ref

[20:25] <TimToady> a Parcel that pretends it has multiple elements when it only has one

[20:25] <pmichaud> right

[20:25] <pmichaud> thus my   ($x,Nil)  version above

[20:25] <TimToady> a way to defeat the auto-deref that usually happens

[20:26] <pmichaud> but that's what list() currently does in ng1 -- it creates an iterator for a Parcel that doesn't degenerate if there's one item

[20:26] <pmichaud> (conceptually, because it's not possible in ng1 to create a Parcel with one item atm)

[20:27] <TimToady> munchings and crunchings &

[20:27] *** ejs left
[20:29] <pmichaud> I need to think on it just a bit more, but perhaps a very useful distinction is to think that infix:<,> creates a Parcel, and postcircumfix:<( )> creates a Parcel, (and maybe other postcircumfixes as well), but circumfix:<()>  _doesn't_ create a Parcel

[20:29] <pmichaud> then we might be able to eliminate the notion of "degenerate Parcel"

[20:30] <pmichaud> (exception,  empty parens create an empty parcel)

[20:30] <pmichaud> so,  ($x) doesn't have a Parcel in it at all, even conceptually

[20:30] <pmichaud> and a Parcel of one element doesn't degenerate

[20:32] <pmichaud> afk for a bit

[20:34] <pmichaud> back for a sec:   and we have some other operator or mechanism for creating a parcel of one element

[20:34] <TimToady> and \$x creates a Parcel

[20:35] <pmichaud> I somewhat prefer that \$x creates a Capture, but okay

[20:35] <pmichaud> I might need to re-think that into my model as well

[20:35] <pmichaud> there's always  Parcel($x)  for creating a Parcel of one element

[20:35] <TimToady> captures are very minor in my mental picture, a last-minute optimization of parcels where we know we might want named params

[20:36] <pmichaud> well, that's a good question as well

[20:36] <pmichaud> what's the effect of   |$x   if $x is a hash?

[20:37] <TimToady> inserts the pairs into the parcel, which might or might not promote to capture

[20:37] <pmichaud> well, in   foo(|$x), for example

[20:37] <pmichaud> if $x is a Hash, does it act like named arguments there?

[20:38] <TimToady> I think it's supposed to, currently

[20:39] <TimToady> making lunch, so distracted

[20:39] <pmichaud> that's fine

[20:39] <pmichaud> how would I pass pairs as positional arguments?

[20:40] <pmichaud> I guess convert $x to an array and | that?

[20:40] <pmichaud> foo(|@$x)   # always positional

[20:40] <pmichaud> foo(|%$x)  # always named

[20:40] <pmichaud> foo(|$x)   # depends on $x

[20:40] <TimToady> $x could be a capture and do both

[20:40] <pmichaud> right

[20:41] <TimToady> or a match

[20:41] *** ejs joined
[20:41] <pmichaud> okay, I can live with that

[20:41] <TimToady> I think I like non-degenerate parcels

[20:41] <pmichaud> yes, it's worked out very well in rakudo (master, even)

[20:41] <TimToady> the fact that we're having to invent them to get around the degeneracy..

[20:41] <TimToady> lunch &

[20:42] <pmichaud> okay, I'll continue probing with the "no degenerate Parcels" concept also

[20:42] <pmichaud> but now a short break to go pound on a drumkit

[20:42] *** nihiliad left
[20:48] *** k23z__ left
[20:49] *** k23z__ joined
[20:57] *** colomon joined
[21:08] *** ejs left
[21:12] <obra> win 2

[21:15] *** nihiliad joined
[21:27] *** tmosx joined
[21:28] <tmosx> Hello everybody, is it possible to print the variable name instead of its value ? for example : $x would print x and not ( 5, which is its value)?

[21:34] *** PerlJam joined
[21:40] *** nihiliad left
[21:43] *** tmosx left
[21:52] <TimToady> pmichaud: \$x can't be just parcel, or it won't protect from flattening, so that's gotta be a different indirection

[21:54] *** eternaleye joined
[21:56] <Tene> pmichaud: did you get my note I left in #parrot last night?

[22:00] <colomon> Tene++ # gather / take

[22:01] <Tene> colomon: the problem only shows up when you make other iterators before using them

[22:01] <colomon> eh?

[22:02] <Tene> didn't you report a problem with gather to me last night?

[22:02] *** nihiliad joined
[22:02] <colomon> I think pmichaud determined the problem I found wasn't gather / take at all.

[22:02] <Tene> Ah.  I haven't read scrollback.

[22:03] <colomon> He reimplemented grep using map instead of gather / take, and it still has the issue.  Something to do with cloning closures.

[22:03] <colomon> (he thinks, but it sounds right to me.)

[22:03] <Tene> yes

[22:04] <colomon> so you're totally off the hook for that, and we're left with your cool lazy gather / take.  :)

[22:07] *** diakopter sets mode: -q $~a

[22:07] <diakopter> in case it was set

[22:11] <pmichaud> Tene: no, didn't get the message yet (picking up messages now)

[22:12] <Tene> pmichaud: colomon says that you already found the problem, something about cloning closures.

[22:12] <pmichaud> right

[22:12] <pmichaud> something isn't getting lexicals and closures correct

[22:12] <pmichaud> I suspect a closure might not be cloned properly.  Although that doesn't quite match the symptoms either

[22:13] <pmichaud> anyway, it's pretty clearly not a gather/take problem, since I get the same issues when using a straight map

[22:14] <Tene> I nopasted a restricted example that might help

[22:14] <pmichaud> and it's also obvious from looking at the generated code that closures aren't being cloned

[22:14] <Tene> http://nopaste.snit.ch/19418

[22:14] <pmichaud> the restricted example works the way you expect, or doesn't?

[22:15] <Tene> there's a line commented out.  it works when uncommented, and misbehaves when commented.

[22:15] <pmichaud> okay

[22:15] <pmichaud> did you pull in my coroutine cloning changes, ooc?

[22:15] <Tene> No.

[22:15] *** nihiliad left
[22:15] <pmichaud> that might be why it's not behaving, then.

[22:17] <pmichaud> but I'm also certain there are issues with the various thunk routines in actions.pm

[22:17] <colomon> actually, it fails with the latest code checked in, too.

[22:17] <colomon> (just checked)

[22:17] <pmichaud> okay, looking.

[22:18] <pmichaud> that still sounds like a closure cloning issue, though.

[22:19] <pmichaud> maybe the closure being passed to gather isn't being cloned

[22:19] <pmichaud> that would make a lot of sense

[22:20] <pmichaud> it's not

[22:20] <pmichaud> so, what is happening is that when the closure finally gets invoked by .get, it has the wrong outer context

[22:20] <colomon> it's not being cloned, or that's not the problem?

[22:20] <pmichaud> it's not being cloned, that *is* a problem

[22:22] <pmichaud> at one time I think I had PAST::Compiler automatically cloning closures... but I think "automatic" is probably the wrong approach.  Maybe a flag on the PAST::Block is needed

[22:22] <pmichaud> anyway, I know that the thunking code in ng and ng1 has issues and looks in need of a significant cleanup

[22:22] <pmichaud> (looked at it in some detail this morning)

[22:24] <pmichaud> afk for a bit

[22:25] *** k23z__ left
[22:29] *** PacoLinux left
[22:32] *** synth joined
[22:34] *** [synth] joined
[22:36] *** [synth] left
[22:36] *** nihiliad joined
[22:49] *** PacoLinux joined
[22:55] *** nihiliad left
[22:55] *** p6eval left
[22:55] *** cognominal left
[22:55] *** lisppaste3 left
[22:55] *** xinming left
[22:55] *** arthur-_ left
[22:55] *** dalek left
[22:55] *** pmichaud left
[22:55] *** akl left
[22:55] *** colomon left
[22:55] *** pnate left
[22:55] *** PZt left
[22:55] *** hercynium left
[22:55] *** tylerni7 left
[22:55] *** synth left
[22:55] *** allbery_b left
[22:55] *** spinclad left
[22:55] *** diakopter left
[22:55] *** eternaleye left
[22:55] *** Su-Shee left
[22:55] *** go|dfish left
[22:55] *** LylePerl left
[22:55] *** PerlJam left
[22:55] *** jan_ left
[22:55] *** buubot left
[22:55] *** buu left
[22:55] *** breinbaas left
[22:55] *** nbrown left
[22:55] *** sunnavy left
[22:55] *** arnsholt left
[22:55] *** jql left
[22:55] *** colomon2 left
[22:55] *** cotto left
[22:55] *** Patterner left
[22:55] *** lichtkind left
[22:55] *** PacoLinux left
[22:55] *** dugg left
[22:55] *** rhr left
[22:55] *** s1n left
[22:55] *** gabiruh left
[22:55] *** wolverian left
[22:55] *** mssmfs left
[22:55] *** diakopter joined
[22:55] *** jferrero joined
[22:57] *** colomon2 joined
[22:57] *** Khisanth joined
[22:57] *** Helios joined
[22:57] *** lichtkind joined
[22:57] *** cotto joined
[22:57] *** Patterner joined
[22:57] *** Grrrr joined
[22:57] *** yves joined
[22:57] *** hicx174 joined
[22:57] *** IRSeekBot joined
[22:57] *** dugg joined
[22:57] *** PacoLinux joined
[22:57] *** huf joined
[22:57] *** hercynium joined
[22:57] *** xinming joined
[22:57] *** saschi joined
[22:57] *** jjore joined
[22:57] *** pugs_svn joined
[22:57] *** hatseflats joined
[22:57] *** nsh joined
[22:57] *** Lorn joined
[22:57] *** frettled joined
[22:57] *** mssmfs joined
[22:57] *** rhr joined
[22:57] *** wolverian joined
[22:57] *** gabiruh joined
[22:57] *** s1n joined
[22:57] *** pmichaud joined
[22:57] *** ssm joined
[22:57] *** lisppaste3 joined
[22:57] *** kornbluth.freenode.net sets mode: +ovvv cotto IRSeekBot pugs_svn lisppaste3

[22:57] *** cognominal joined
[22:57] *** p6eval joined
[22:57] *** nihiliad joined
[22:57] *** LylePerl joined
[22:57] *** pnate joined
[22:57] *** kornbluth.freenode.net sets mode: +v p6eval

[22:57] *** sjohnson joined
[22:57] *** phenny joined
[22:57] *** PerlJam joined
[22:57] *** jan_ joined
[22:57] *** buubot joined
[22:57] *** mj41 joined
[22:57] *** BinGOs joined
[22:57] *** krunen joined
[22:57] *** constant joined
[22:57] *** kornbluth.freenode.net sets mode: +v buubot

[22:57] *** eternaleye joined
[22:57] *** lestrrat joined
[22:57] *** yahooooo joined
[22:59] *** breinbaas joined
[22:59] *** jql joined
[22:59] *** nbrown joined
[22:59] *** buu joined
[22:59] *** sunnavy joined
[22:59] *** arnsholt joined
[22:59] *** moritz_ joined
[22:59] *** elmex joined
[22:59] *** Tene joined
[22:59] *** stepnem joined
[22:59] *** _ilbot2 joined
[22:59] *** kornbluth.freenode.net sets mode: +ooov sunnavy moritz_ Tene _ilbot2

[22:59] *** charsbar joined
[22:59] *** cosimo joined
[23:00] *** jrockway joined
[23:00] *** Su-Shee joined
[23:00] *** literal joined
[23:00] *** kraih_sri joined
[23:00] *** akl joined
[23:00] *** tylerni7 joined
[23:04] *** justatheory joined
[23:04] *** allbery_b joined
[23:04] *** obra joined
[23:04] *** tomaw left
[23:07] *** tomaw joined
[23:08] *** Su-Shee left
[23:12] *** tkr joined
[23:14] *** duryodhan joined
[23:15] *** nihiliad left
[23:23] *** ejs joined
[23:24] *** patspam joined
[23:26] *** lichtkind left
[23:27] *** PZt joined
[23:35] *** duryodhan left
[23:36] *** Khisanth left
[23:36] *** Khisanth joined
[23:38] *** go|dfish joined
[23:41] *** eternaleye left
[23:46] *** ejs left
[23:47] *** eternaleye joined
[23:47] *** eternaleye left
[23:47] *** eternaleye joined
[23:50] *** DarkWolf84 joined
[23:51] <DarkWolf84> hi there :)

[23:54] *** DarkWolf84 left
