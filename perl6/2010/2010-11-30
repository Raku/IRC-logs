[00:00] <ash_> question for anyone online, do you use .pl6 or .pl? i have been sticking with .pl just curious 

[00:00] <masak> since grammars are one of the Big, Obvious strengths of Perl 6, and since they're largely implmeneted and well-tested in Rakudo, I think blog posts are very good news for Perl 6. they show the language from one of the best sides possible.

[00:00] <Tene> ash_: .pl

[00:00] <masak> ash_: I usually don't put a suffix on my executables. and my Perl 6 scripts are executables.

[00:00] <flussence> I've been using .p6

[00:01] <masak> three people, three different answers :)

[00:02] <masak> only one of which intersected with the original two options :P

[00:02] <flussence> I'm too lazy to put a ft=perl6 modeline in when that works just as well :)

[00:03] <ash_> when its an executable, i do not put a suffix on it, but if its just a script that i am not using as an executable i do .pl or .pm 

[00:03] <masak> ash_: if you're not executing the script, is it truly a write-only script? :)

[00:04] <ash_> i am executing it, just not by doing ./filename 

[00:04] <ash_> so, i probably could just add #!/usr/bin/perl6 and chmod +x but still 

[00:06] <masak> flussence: re "all your base"... try not to feed the trolls.

[00:07] <masak> I'm no real authority on troll management, but I do suspect that they're better hugged or left alone than attacked or mocked.

[00:09] <masak> time to sleep.

[00:09] <masak> 'night, #perl6.

[00:09] *** masak left
[00:10] *** ggoebel joined
[00:14] <dukeleto> For those interested in Troll Management, check out trolluniversity.com

[00:14] <Tene> flussence: I read norkakn's post as sarcasm, fwiw

[00:14] <Tene> "That's pretty cool.  Shame that there's all that inaccurate fud about Perl 6."

[00:14] <Tene> approximately.

[00:15] <flussence> meh, I get snarky easily on reddit. been there too long :(

[00:16] <ash_> my friend does the same thing, reddit must bring out the troll/anti-troll in people

[00:23] *** Gothmog_ left
[00:29] *** orafu left
[00:29] *** orafu joined
[00:36] *** icwiener left
[00:39] *** Gothmog_ joined
[00:44] *** lilstevey joined
[00:59] *** risou left
[01:00] *** QinGW joined
[01:04] <ash_> pugs: 'ab' ~~ /c|ab/

[01:04] <p6eval> pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.16/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped by operat…

[01:04] <ash_> weird

[01:04] <ash_> locally

[01:04] <ash_> that works fine

[01:04] <ash_> pugs> 'ab' ~~ /c|ab/

[01:04] <ash_> Match.new(

[01:04] <ash_>   ok => Bool::True, 

[01:04] <ash_>   from => 0, 

[01:04] <ash_>   to => 2, 

[01:04] <ash_>   str => "ab", 

[01:04] <ash_>   sub_pos => (), 

[01:04] <ash_>   sub_named => {}

[01:04] <ash_> )

[01:05] <ash_> sorry, i'll stop spamming 

[01:05] *** lilstevey left
[01:09] *** satyavvd joined
[01:10] *** ash_ left
[01:18] *** redicaps joined
[01:21] <diakopter> whee

[01:25] *** shabble joined
[01:25] *** shabble left
[01:25] *** shabble joined
[01:27] * diakopter hopes I'm below the 8 max commits for dalek

[01:27] <dalek> 6model: 47a15f6 | diakopter++ | dotnet/runtime/Runtime/Ops/Primitive.cs:

[01:27] <dalek> 6model: [dotnet] add a format_str Op, but don't use it yet.

[01:27] <dalek> 6model: review: https://github.com/jnthn/6model/commit/47a15f64e0

[01:27] <dalek> 6model: 4e98d42 | diakopter++ | / (4 files):

[01:27] <dalek> 6model: [dotnet] flesh out and debug pasttypes 'scan' and 'pass',

[01:27] <dalek> 6model: such that non-capturing groups work, rule concatenation works, and

[01:27] <dalek> 6model: non-left-anchored scanning works.

[01:27] <dalek> 6model: fix bugs in DNST::JumpTable exposed by the above

[01:27] <dalek> 6model: fix bugs in Cursor exposed by the above

[01:27] <dalek> 6model: review: https://github.com/jnthn/6model/commit/4e98d42bdf

[01:27] <dalek> 6model: 1f4a978 | diakopter++ | common/NQP/NQPSetting.pm:

[01:27] <dalek> 6model: [common NQPSetting] Add a Bool method to Any

[01:27] <dalek> 6model: Add a simple join() sub

[01:27] <dalek> 6model: review: https://github.com/jnthn/6model/commit/1f4a978d4f

[01:27] <dalek> 6model: c16594c | diakopter++ | t/nqp/45-smartmatch.t:

[01:27] <dalek> 6model: [tests] write 3 more passing tests in 45-smartmatch.t

[01:27] <dalek> 6model: review: https://github.com/jnthn/6model/commit/c16594c667

[01:27] <diakopter> oh good

[01:32] <diakopter> nqpnet: ok(("hihi" ~~ /i [h i]/) eq 'ihi', "non-capturing groups work");

[01:32] <p6eval> nqpnet: OUTPUT«ok 1␤»

[01:32] <diakopter> nqpnet: ok(("hihi" ~~ /i hi/) eq 'ihi', "rule concatenation works");

[01:32] <p6eval> nqpnet: OUTPUT«ok 1␤»

[01:33] <diakopter> nqpnet: ok(("hi" ~~ /i/) eq 'i', "basic non-anchored scanning works");

[01:33] <p6eval> nqpnet: OUTPUT«ok 1␤»

[01:33] <diakopter> (yay)

[01:37] *** lichtkind left
[01:38] *** am0c left
[01:58] *** shabble left
[01:58] *** shabble joined
[01:58] *** shabble left
[01:58] *** shabble joined
[01:58] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_variable_tablet

[01:58] *** Guest27466 left
[02:00] *** satyavvd left
[02:01] *** kst joined
[02:07] *** knewt2 joined
[02:15] *** bluescreen joined
[02:16] *** bluescreen is now known as Guest81143

[02:26] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[02:27] *** ggoebel left
[02:29] *** ShaneC joined
[02:32] *** ggoebel joined
[02:32] *** ShaneC left
[02:36] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_variable_tablet

[02:42] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[02:57] *** Guest81143 left
[03:03] *** Sarten-X joined
[03:15] *** am0c joined
[03:17] *** envi joined
[03:27] *** envi left
[03:31] *** am0c left
[03:53] *** whiteknight left
[04:15] *** am0c joined
[04:17] <sorear> good * #perl6

[04:21] *** Faizan` joined
[04:21] *** Faizan` left
[04:37] *** takadonet1 joined
[04:37] <takadonet1> sorear++

[04:37] <takadonet1> gratz on the release!

[04:41] *** ch3ck3r left
[04:47] <sorear> takadonet1: thanks

[04:53] <takadonet1> good night all

[04:53] <takadonet1> only came here to say that :)

[04:53] *** takadonet1 left
[05:09] <dukeleto> sorear: did you do a release of niecza?

[05:12] <sorear> dukeleto: no, only an announcement

[05:13] *** Trashlord left
[05:17] *** hercynium_ left
[05:30] *** alc joined
[05:31] *** nymacro joined
[05:51] *** envi joined
[06:06] *** nymacro left
[06:27] *** gimix joined
[06:28] *** jaldhar joined
[06:43] *** kanishka left
[06:47] *** gimix left
[06:47] *** kaare joined
[06:48] *** kaare is now known as Guest84862

[07:10] *** wtw joined
[07:29] *** DarthGandalf left
[07:37] *** DarthGandalf joined
[07:40] *** justatheory left
[07:53] *** gimix joined
[08:04] *** Guest84862 is now known as kaare_

[08:05] *** uniejo joined
[08:11] <sjohnson> ma

[08:18] *** Bwiz joined
[08:18] *** Bwiz left
[08:19] <sorear> mi?

[08:19] <mathw> I saw that and thought I'd switched to #lojban by mistake

[08:21] <mathw> sorear: grats on getting Niecza (sp?) to an announceable state

[08:23] <sorear> ma, mi is lojban?

[08:23] * sorear was thinking ... ho, ma, mi, mu, me, mo, ya ...

[08:24] * sorear waits for the p6a moderator to see this

[08:24] <mathw> "ma" is

[08:25] <mathw> it's a question word

[08:28] <mathw> "mi" also is, it's the pro-sumti for "I" or "myself"

[08:28] <mathw> but someone saying just "ma" just struck me as Lojban :)

[08:31] <sorear> rakudo: say ~(<n>, (<_ k s t n h m y r w> X~ <a i u e o>).grep: none(<yi ye wi wu we>))

[08:31] <p6eval> rakudo : OUTPUT«n _a _i _u _e _o ka ki ku ke ko sa si su se so ta ti tu te to na ni nu ne no ha hi hu he ho ma mi mu me mo ya yu yo ra ri ru re ro wa wo␤»

[08:31] * sorear ponders golf

[08:32] <sjohnson> sorear: :)

[08:33] <sjohnson> actually wrote that as a complete accident because screen -d -r took about 30 seconds to load

[08:33] *** Hor|zon left
[08:33] <sjohnson> best part about this channel, is no one complains or get angry, when things get lightly off topic in a carefree way

[08:34] *** jfried joined
[08:41] <mathw> It's not like there really *is* a topic at the moment :)

[08:41] *** nymacro joined
[08:48] <moritz_> mathw: sure there is. Perl 6 :-)

[08:56] <mathw> pffffft :P

[08:56] <mathw> Who wants to talk about that :)

[08:56] <tadzik> hello

[08:56] <sorear> I do

[08:56] <tadzik> phenny: tell masak I think it's just the failed joke

[08:56] <phenny> tadzik: I'll pass that on when masak is around.

[08:56] <sorear> hi tadzik

[08:57] <mathw> hey tadzik

[08:59] *** nymacro left
[09:00] <tadzik> hey hey

[09:06] <tadzik> sorear++ # announcing niecza

[09:17] *** mikehh left
[09:36] *** dakkar joined
[09:36] <dalek> niecza: e5c3ac0 | sorear++ | / (2 files):

[09:36] <dalek> niecza: Add a call graph analyzer

[09:36] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e5c3ac0b38

[09:36] <dalek> niecza: 871b07d | sorear++ | docs/announce.initial:

[09:36] <dalek> niecza: Commit a copy of announce message

[09:36] <dalek> niecza: review: https://github.com/sorear/niecza/commit/871b07d52b

[09:36] <dalek> niecza: 2b8ae9c | sorear++ | src/ (2 files):

[09:37] <dalek> niecza: use ANON consistently, not anon

[09:37] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2b8ae9cbf8

[09:37] *** masak joined
[09:37] <masak> oh hai, #perl6!

[09:37] <phenny> masak: 08:56Z <tadzik> tell masak I think it's just the failed joke

[09:38] <masak> ok, that needs some context, I'm afraid :)

[09:38] <masak> which failed joke in particular?

[09:40] <masak> sjohnson: the only thing that's slightly off-topic is Perl 5. :) but only because there are better places to discuss that already.

[09:41] <sorear> hi masak

[09:41] * masak tips hat

[09:43] <sorear> Eh?!

[09:45] *** redicaps left
[09:48] <masak> sorear: I thought a common non-verbal greeting in the anglosphere was to grab the brim of one's hat and tip it. feel free to put me right if this was a misunderstanding.

[09:51] <masak> rakudo.org still down...

[09:53] *** kensanata joined
[09:53] *** daxim joined
[09:55] <moritz_> oh hai

[09:56] <masak> moritz_! \o/

[09:57] <masak> moritz_: in the backlog, we were discussing standardizing the Test module in a synopsis.

[09:57] <masak> the already-agreed-on nomenclature suggests that this would be S24.

[09:58] <moritz_> agreed

[09:58] <moritz_> I'll support any such effort.

[09:59] <masak> as sorear++ points out, there are four Test.pm files already, and nothing really to make them conform to anything in particular.

[10:01] <moritz_> they implicitly conform to the ones from Test::{More,Exception} in p5

[10:05] <masak> moritz_: have you ever reacted to the insanity that is todo($reason, $count); skip($count, $reason)? (note reversal of arguments) is that from Test::More too?

[10:06] <moritz_> masak: I don't write todo() and skip() lines manually (fudge does that for me), so I didn't really encounter it

[10:06] <sorear> masak: AIUI the hat-tip greeting is generally reserved for cases where there is a significant gap in social class

[10:06] <masak> I realized that yesterday, and thought "hm, if I ever write a book on API design, that'd deserve a whole anti-pattern section of whose need I wasn't previously aware"

[10:07] <masak> sorear: oh! that's the first time I hear such a thing.

[10:08] <moritz_> sorear: I'm quite sure that that's not generally the case

[10:08] <sorear> ok.

[10:08] <masak> sorear: then consider my greeting as one from a lowly warrior to a mage. :)

[10:08] * sorear is not an authority on social cues

[10:09] *** QinGW left
[10:15] * sorear -> sleep

[10:19] <moritz_> sorear: it's on p6a now

[10:42] *** jhuni left
[10:46] *** jhuni joined
[10:53] *** jhuni left
[11:19] <tadzik> masak: the r/perl one

[11:20] *** alc left
[11:21] *** alc joined
[11:24] *** alc left
[11:41] <tadzik> anyone writing Colemak? :)

[11:41] <tadzik> (this took me a while to type)

[11:47] *** uniejo left
[11:49] *** cognominal joined
[12:06] <tadzik> masak: LOLDispatch may work nicely with grammar dispatching, no?

[12:13] *** rams joined
[12:13] *** lichtkind joined
[12:14] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_variable_tablet

[12:14] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_io_tablet

[12:17] *** rams left
[12:20] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[12:46] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_io_tablet

[12:46] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[12:56] <masak> tadzik: seems to me LOLDispatch works fine without grammar dispatching, and vice versa. don't really see what it'd mean for them to work together.

[12:57] <masak> this Japanese twitterer seems to think something is cumbersome: http://twitter.com/kgt_bot/status/9582436358815744

[12:57] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[12:59] *** masak left
[13:20] *** kjeldahl joined
[13:22] <bbkr> std: $.foo # curious...

[13:22] <p6eval> std a194beb: OUTPUT«ok 00:01 118m␤»

[13:23] *** MayDaniel joined
[13:26] <bbkr> hmm, i'm not sure if class variable syntax should be allowed in main. it should give the same warning as for example trying to write "method foo {}" in main scope - about useless declaration/usage. right?

[13:27] <bbkr> check following example...

[13:27] <bbkr> rakudo: my $.foo; say "alive"; $.foo

[13:27] <p6eval> rakudo : OUTPUT«alive␤Null PMC access in find_method('foo')␤  in main program body at line 22:/tmp/B60vOmq2fl␤»

[13:27] <bbkr> not so consistent, isn't it? declaration passes but usage gives null PMC access

[13:28] *** plainhao joined
[13:35] *** MayDaniel left
[13:38] *** Patterner left
[13:38] <bbkr> reported in http://rt.perl.org/rt3/Ticket/Display.html?id=80008

[13:52] *** Psyche^ joined
[13:52] *** Psyche^ is now known as Patterner

[13:53] <bbkr> phenny: tell mberends that HTTP::Daemon should have possibility to get request body on unknown Content-Type (or even better - to allow to connect custom handler method for given content type). This will allow for example to write JSON::RPC::Server based on this nice module.

[13:53] <phenny> bbkr: I'll pass that on when mberends is around.

[14:12] *** uniejo joined
[14:16] <tadzik> phenny: tell masak actually, a PM fellow pointed out that grammar dispatching would be nice if you were writing only Action class, and Grammar would be generated automagically. I instantly thought of traits, and then about LOLDispatch

[14:16] <phenny> tadzik: I'll pass that on when masak is around.

[14:20] *** uniejo left
[14:22] *** masak joined
[14:22] <masak> bbkr++ # RT #80008

[14:22] <phenny> masak: 14:15Z <tadzik> tell masak actually, a PM fellow pointed out that grammar dispatching would be nice if you were writing only Action class, and Grammar would be generated automagically. I instantly thought of traits, and then about LOLDispatch

[14:22] <masak> tadzik: I'm having trouble visualizing that.

[14:26] <tadzik> masak: I suppose a framework will be either generating a grammar class and evaling it, or adding tokens with add_method or something

[14:26] <masak> right.

[14:26] <masak> "working code or it didn't happen" :)

[14:27] <tadzik> (I may write slowly, Colemak is hard)

[14:28] <tadzik> masak: bah, that will result in more ridiculous blag toasts :)

[14:29] <flussence> ooh, generated code. I just spent a week re-learning graph theory to write a p5 script that makes a shell script to run 2 dozen SQL files in the right (foreign key) order. Does that make me officially insane?

[14:33] *** Trashlord joined
[14:37] <colomon> flussence: it makes you officially sane!

[14:38] <colomon> (says the man whose has a bunch of $work perl 5 scripts for generating C++ code....)

[14:47] <masak> flussence: DFS to make a topological sort?

[14:47] <masak> (that's what ufo does)

[14:49] <flussence> I was using Graph.pm... it has a ->toposort method, but I didn't like the output so I ended up doing it semi-manually :)

[14:49] <masak> seems I guessed right, then.

[14:49] *** nymacro joined
[14:49] <masak> but... a week? :)

[14:50] <masak> I went to the nearest textbook and looked up 'topological sorting'.

[14:50] <masak> it took less than a week.

[14:50] <flussence> well, rounded up from 3 days, in between the actual sql writing...

[14:50] <masak> ah :)

[14:51] <flussence> and a fair bit of that was offloading as much work as I could to p5 once I got it working :)

[14:51] <masak> sounds sane.

[14:51] <PerlJam> I've seen topological sorting in a few P6 programs/modules now ... seems like it would make a good module on its own if someone hasn't already done it.

[14:52] <PerlJam> (also might make a good advent calendar post :)

[14:52] <diakopter> masak: tipping-of-the-hat (as an implied pre-genuflection) is much more English than American these past many decades

[14:52] <masak> diakopter: now that I can believe.

[14:52] <colomon> it's not unknown, but hats suitable for tipping are not in fashion.  :)

[14:52] <masak> "pre-genuflection" :P

[14:53] <diakopter> er, an implied pre-bowing

[14:53] <diakopter> what colomon said

[14:53] <diakopter> ++

[14:53] <colomon> Also, there's something about saying it "hat tip" which causes a moment pause.  Even though it is clearly correct, at a moment's glance it makes me think "hat trick" (a hockey term) rather than "tip of the hat".

[14:54] <colomon> :)

[14:54] <diakopter> or catnip

[14:57] *** Trashlord left
[14:59] *** am0c left
[15:00] <diakopter> about the only hats suitable for tipping are cowboy hats and (aptly-called) "floppy hats", and those are only regionally culturally fashionable, and rare elsewhere.

[15:02] <masak> don't think I've seen a floppy hat.

[15:02] *** sftp joined
[15:02] <masak> do they come in different sizes, measured in inches? :)

[15:05] <colomon> The 3.5 inch hat isn't very floppy.  ;)

[15:10] <diakopter> .. where a floppy hat is essentially a cowboy hat that's floppy and not Texas-tall

[15:11] *** lichtkind_ joined
[15:13] *** lichtkind left
[15:13] <diakopter> TimToady wears one, iirc

[15:13] *** lichtkind_ is now known as lichtkind

[15:14] *** uniejo joined
[15:14] <colomon> ooo, actually, guess I wear a floppy hat too, by that standard.  :)

[15:17] <masak> in that case, I have seen one.

[15:18] *** wtw left
[15:18] <diakopter> there's this http://www.amazon.com/Sun-Protection-Hat-Keep-Floppy/dp/B000JWNQ2I and http://www.amazon.com/Fishing-Hat-01-Khaki-W11S35E/dp/B0007OF2QG styles too

[15:18] *** fhelmberger joined
[15:19] <colomon> Mine is a fancier version of the Sun Protection Hat.  (Unsurprisingly, as that is exactly the job it is doing, though it's handy in rain as well.)

[15:19] <masak> by rights, it should be the Oracle Protection Hat nowadays.

[15:20] <PerlJam> Why does Oracle need protection?

[15:20] *** MayDaniel joined
[15:20] <masak> PerlJam: you're not extrapolating this correctly. :)

[15:21] <PerlJam> That would be the fault of the punner, not the punee  :)

[15:22] <masak> a Sun Protection Hat protects against Sun.

[15:22] <masak> it doesn't protect Sun.

[15:23] <masak> I guess Sun has dangerous cancerogenic rays of electromagnetic radiation that need protecting against.

[15:23] <masak> similarly, an Oracle Protection Hat... oh forget it. :)

[15:23] <PerlJam> "Protection Hat" sounds like a euphemism for a condom in any case  ;)

[15:24] <masak> indeed.

[15:29] *** risou joined
[15:31] <diakopter> http://www.starling-software.com/employment/programmer-competency-matrix.html   kinda neat. enterprisey-oriented (like 80% of the job market). where do YOU rate yourself

[15:32] *** nymacro left
[15:33] *** nymacro joined
[15:33] <masak> the subjectivity of it all makes me read it more as an interesting subdivision of the universe than as a way to rate myself.

[15:35] <diakopter> I don't find it subjective

[15:37] <PerlJam> Where's the section on using the competency matrix to rate yourself? :-)    Level 0:  doesn't know about the competency matrix  Level 1: knows about it, but doesn't believe it's useful  Level 2: believes it's useful   Level 3: believes it's useful and uses it daily

[15:38] <colomon> PerlJam++

[15:38] <masak> diakopter: here's an example of what I found highly subjective: Erlang and Prolog at the top of the scale of "languages exposed to".

[15:39] <masak> similarly, git at the top of "source code version control". and CVS/SVN on the way there.

[15:39] <masak> maybe that does makes sense from an enterprisey perspective, I dunno.

[15:41] <colomon> masak: remember, if you're not doing things their way, you're just not that sophisticated.  ;)

[15:41] <diakopter> PerlJam: heh

[15:41] <PerlJam> masak: for the languages I could make a case that it's arranged from most common to least common languages, but that same scale doesn't work on many of the others

[15:42] <PerlJam> (version control is a perfect example where it doesn't work at all)

[15:42] <masak> I'm not saying it's a bad matrix; I did find it an interesting read.

[15:46] <flussence> I'd rate myself... NaN

[15:46] *** kaare_ left
[15:46] *** soroush joined
[15:49] <PerlJam> diakopter: are you applying for a job at Starling?

[15:50] <diakopter> no..

[15:53] *** dakkar left
[15:55] *** rgrau_ joined
[15:59] *** rgrau_ left
[16:00] *** rgrau_ joined
[16:02] *** masak left
[16:04] *** justatheory joined
[16:04] *** rgrau_ left
[16:04] *** rgrau_ joined
[16:04] *** uniejo left
[16:05] *** dakkar joined
[16:09] *** hercynium joined
[16:09] *** Trashlord joined
[16:14] *** rgrau_ left
[16:20] *** spq1 joined
[16:25] *** nymacro left
[16:28] *** MayDaniel left
[16:30] *** jdv79 joined
[16:48] *** jdv79 left
[16:48] *** jdv79 joined
[16:51] *** hillu joined
[16:52] *** am0c joined
[17:02] <colomon> #phasers in two hours?

[17:03] <moritz_> aye

[17:09] <jnthn> o/

[17:10] <colomon> \o

[17:11] <moritz_> /o\

[17:16] <TimToady> as it happens, http://rosettacode.org/wiki/Topological_sort has entries for both Perl 5 and Perl 6

[17:17] <TimToady> PerlJam, flussence: ^^

[17:27] *** kensanata left
[17:29] *** am0c left
[17:33] *** am0c joined
[17:35] *** am0c left
[17:36] *** ash_ joined
[17:39] <ash_> rakudo: 'ab' ~~ /ab'; say $/

[17:39] <p6eval> rakudo : OUTPUT«===SORRY!===␤Confused at line 22, near "'ab' ~~ /a"␤»

[17:39] <ash_> rakudo: 'ab' ~~ /ab/; say $/

[17:39] <p6eval> rakudo : OUTPUT«ab␤»

[17:39] <ash_> pugs: 'ab' ~~ /ab/; say $/

[17:39] <p6eval> pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.16/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped by operat…

[17:43] <TimToady> pugs was never strong on regexen

[17:45] *** proller_ joined
[17:50] <ash_> that works locally 

[17:51] <ash_> pugs>  'ab' ~~ /ab/; say $/

[17:51] <ash_> ab

[17:51] *** ShaneC joined
[17:51] *** ShaneC left
[17:53] *** sji joined
[17:55] <TimToady> one of the reasons pugs was never strong on regexen is because it depends on external libraries for regex, hence the difference you see

[17:55] *** MayDaniel joined
[17:56] <TimToady> and I doubt you'll find any of those external libraries doing LTM

[18:01] <dalek> rakudo: 1eae0c4 | KodiB++ | src/core/Bool.pm:

[18:01] <dalek> rakudo: [core/Bool] Made +False and +True return Ints.

[18:01] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/1eae0c4e71

[18:01] <ash_> pugs> 'bc' ~~ /a|bc/; say $/

[18:01] <ash_> bc

[18:02] <dalek> roast: f013a92 | (Kodi Arfer)++ | S02-builtin_data_types/bool.t:

[18:02] <dalek> roast: [bool.t] Ensure that Bools numify to Ints.

[18:02] <dalek> roast: review: https://github.com/perl6/roast/commit/f013a92e3c

[18:03] <ash_> that seems right to me, but i don't know about external dependencies 

[18:03] <colomon> at one point, at least, there was a thought that Bool was a Numeric type.  (though personally I think I'm against that.)

[18:05] *** cognominal left
[18:05] <ash_> i think of Bool's as a single bit, more than an integer with values 0 and 1, but i can understand why you would assume a true + true = 2, although that seems more like an error to me personally 

[18:05] *** cognominal joined
[18:05] <ash_> rakudo: say True + True

[18:05] <p6eval> rakudo : OUTPUT«2␤»

[18:06] <ash_> rakudo: say True & True 

[18:06] <p6eval> rakudo : OUTPUT«all(Bool::True)␤»

[18:07] <ash_> have you seen the new 'refine' semantics they are adding to ruby? in a scope, you can 'refine an object' only in that scope, so you don't have to monkey patch the whole object, your just monkey patching for a given scope

[18:08] <TimToady> lexical scope or dynamic?

[18:08] <ash_> lexically 

[18:08] <moritz_> afaict we've explicitly decided against such a mechanism, no?

[18:08] <ash_> would be something like: class Foo { refine Int { method bar { } }; method stuff { return bar } };  Foo.stuff; #works; Int.bar #fails 

[18:08] <TimToady> well, dynamic is just temp, if we ever implement it

[18:09] <ash_> err

[18:09] <ash_> s/return bar/return Int.bar/

[18:09] <moritz_> aren't that what subs are for?

[18:09] <ash_> http://timeless.judofyr.net/refinements-in-ruby 

[18:10] <ash_> explains it better than i can

[18:10] <TimToady> btw, your /a|bc/ is not attempting LTM

[18:10] <TimToady> /b|bc/ would be

[18:10] <ash_> doh

[18:11] <ash_> ya, it doesn't do LTM 

[18:11] <ash_> pugs> 'ab' ~~ /a|ab/; say $/

[18:11] <ash_> a

[18:11] *** MayDaniel left
[18:12] <ash_> all its really doing is lexically scoping your monkey patching

[18:13] <TimToady> in which case it's really a mechanism to let you write .bar instead of bar()

[18:13] <moritz_> we can do that with $obj.&bar

[18:14] <ash_> when i read about it, i thought "so they are just adding more lexical scoping?" it seems odd

[18:15] <TimToady> the question is whether they're actually hooking into the dispatcher's type lookup to implement it, or whether it's just sugar

[18:17] <TimToady> it could be done on the incoming binding, and then it'd pass dynamically to submethods outside the scope but called from within the scope

[18:17] <TimToady> if that's the case, it'd be a form of delegation, methinks

[18:17] <TimToady> the interior object is really just wrapping the passed object

[18:18] <TimToady> or it's sugar for some sort of mixin at binding time

[18:19] <TimToady> maybe I should read it instead of speculating :)

[18:22] *** Kovensky joined
[18:24] <ash_> its lexical, but it can be inherited and things like that

[18:26] <TimToady> it looks like it's basically doing scope-based mapping of the object's type to the ISA chain to use for that object in that context

[18:28] <TimToady> so instead of having lexically scoped searching for subs as Perl does, it kinda meshes the lexically scoped refinements into the existing dispatcher to redirect some of the ISA components elsewhere

[18:29] *** daxim left
[18:29] <TimToady> "every time you dispatch in this scope, pretend that you did these mixins to these ISA components"

[18:30] <TimToady> (when I say ISA, I mean the parent chain, not MI)

[18:32] *** proller_ left
[18:34] <ash_> it seems like an alternative to lexical scoping (the way perl does it) 

[18:36] <ash_> but you can do something like (psuedo code): module Foo { refine Int { method bar { 1 } } }; class A { using Foo; }; augment class A { method x { 1.bar } }; which i think (i could be wrong) doesn't work in perl's lexical scoping, does it? 

[18:37] <ash_> class A { sub bar { 1 } }; augment class A { method x { bar } }; does that work? 

[18:38] <TimToady> that's just normal monkey typing in P6

[18:39] <sorear> good * #perl6

[18:39] <ash_> but does method x have visibility to bar?

[18:39] <TimToady> the "using" is doing something like lexical import in that case

[18:40] <ash_> i guess does class { }; have a different lexical scope than an augment class { }; ? 

[18:40] <TimToady> augment doesn't have a scope in that sense; it takes its scope from whatever it's augmenting

[18:40] <ash_> okay 

[18:40] <TimToady> which is why it's currently in the scope_declarator slot

[18:42] <ash_> rakudo: use MONKEY_TYPING; class A { sub bar { 1 } }; augment class A { method x { bar } }; A.new.x.say # is that wrong behaviour then? 

[18:42] <p6eval> rakudo : OUTPUT«Could not find sub &bar␤  in 'A::x' at line 22:/tmp/58rclymu6H␤  in main program body at line 22:/tmp/58rclymu6H␤»

[18:42] <ash_> rakudo: class A { sub bar { 1 }; method x { bar } }; A.new.x.say # compare to this

[18:42] <p6eval> rakudo : OUTPUT«1␤»

[18:43] *** kjeldahl left
[18:45] <ash_> in my mind, i could be wrong on this, refine is lexical monkey patching, so only in a specific scope the monkey patch exists

[18:46] <sorear> moritz_: huh, I haven't seen it

[18:47] <moritz_> sorear: second entry from the top

[18:47] <sorear> moritz_: does perl6.org avoid duplicate sends

[18:47] <sorear> aye, I see it in the archive

[18:48] <TimToady> in any case, if we decided we wanted it, it would be just a matter of compiling a different method dispatcher into a given scope that knew to look up the local view of the type system

[18:49] <TimToady> but I prefer to keep lexical scoping orthogonal to single dispatch for now

[18:49] *** uniejo joined
[18:49] <TimToady> so to get your bar to work about, it requires an export/import

[18:49] <TimToady> *above

[18:49] <TimToady> .oO(strange typo)

[18:52] <TimToady> basically, Perl 6 puts a strong emphasis on language mutability within lexical scopes, and prefers to keep normal OO outside of the realm of language mutability

[18:52] <Tene> ash_: your example isn't doing the same thing at all.

[18:52] <TimToady> the meaning of a message dispatch is controlled by the class, not by the lexical scope

[18:53] <ash_> Tene: as ruby refinement?

[18:53] <Tene> ash_: yes

[18:53] <ash_> hmm

[18:53] <Tene> It's more like:

[18:54] <Tene> module A { refine class Int { method frob { ... } } }; module B { import A; method foo { 2.frob; } };

[18:55] <TimToady> assuming that refinements are automatically exported

[18:55] <Tene> Yes.

[18:55] <Tene> (which they are in ruby)

[18:55] <ash_> ruby autmoattically export anything not label private 

[18:55] <TimToady> which is all perfectly find P6ish, assuming that what you're changing is the dispatcher in the scope of the refinement

[18:56] <TimToady> that's just mutating the semantics of the language in a lexical scope

[18:56] <Tene> I've long felt that we need something like this to lexically-scope class modifications, to give the rubyists more-sane options.

[18:56] <ash_> Tene: my example was more perl6'ish without patching an object, just using a lexically scoped sub as an atlernative to a lexically added method 

[18:56] <Tene> However, my question is this:

[18:57] <Tene> module A { refine class Int { method frob { ... } } }; module B { import A; method foo(Int $n) { $n.frob; } }; B.new.foo(2); # does this work?

[18:57] <ash_> i think my example was similiar in thoery, just without the extra object 

[18:57] <Tene> If I pass in an Int instantiated from a different scope, does it still use the refined Int class?

[18:57] <Tene> Also:

[18:58] <Tene> module A { refine class Int { method frob { ... } } }; module B { import A; method foo { 2; } }; B.new.foo.frob; # does this work?

[18:58] <Tene> If I return an Int from a scope containing Int refinements, does that object use the refined class hierarchy when accessed in a different lexical scope?

[18:58] <ash_> i would image an Int from a different scope would get the refinement but only if you didn't supersede Int, since supersede IMO is a replacement, and the refinement should be lost with the supersede  

[18:59] <ash_> returning the int would, in ruby, loose the refinement, so B.new.foo.frob would fail 

[18:59] <ash_> since you'd be out of the bound of the refinement 

[18:59] <Tene> That's what I'd hope, in both of those.

[19:00] <Tene> This is why just importing a modified class under the same name isn't enough to work as a relief valve for rubyist monkey patching fetishism.

[19:00] <ash_> rubyists both love and hate monkey patching it seems

[19:01] <ash_> its good when you need it, to add to an existing class instead of making a new one, but it is bad when you do: "require ActiveRecord" and Object has 28 new methods on it, not to mention all the other changes to Fixnum, Class, Module, etc.. 

[19:02] <Tene> importing MySpecialInt as 'Int', and getting integer literal constants to use it lexically, would not pass the first test, and would not fail the second.

[19:03] *** simcop2387 joined
[19:03] *** wamba joined
[19:03] *** dalek joined
[19:03] *** ChanServ sets mode: +v dalek

[19:06] <Tene> I'm fine with it not being a 6.0 feature, but I've been saying for a long time, we need a sane way to lexically-scope class hierarchy modifications.  I'm a bit grumpy about augment being offered as a serious tool to new users.

[19:06] *** kjeldahl joined
[19:07] *** kjeldahl left
[19:07] *** kjeldahl joined
[19:11] *** risou left
[19:11] <TimToady> well, as I say, this looks to me like simply replacing the standard single dispatcher with a different single dispatcher that uses one level of indirection to tell the object what its parents are in this scope

[19:12] <TimToady> and the standard dispatcher need only be replaced in the refined scope

[19:12] <TimToady> and P6 already has a custom of making dispatchers first class

[19:13] <TimToady> so I suspect this will fall into the "almost a piece of cake" category

[19:13] *** ch3ck joined
[19:13] <Tene> TimToady: Having this dispatcher as a core module might be nice.  It's something we definitely eventually need.

[19:13] <moritz_> tadzik: ping

[19:13] <TimToady> maybe

[19:14] <TimToady> every abstraction layer we add makes the language harder to learn, so I'm not sure whether this achieves sufficient utility to justify that cost

[19:15] <TimToady> it might, but I'm not yet convinced

[19:16] <Tene> TimToady: We already have this semantic complexity in the form of augment, and people are already using augment.  I've seen several beginners come in here talking about wanting to add weird methods to core classes, etc.

[19:16] *** dakkar left
[19:16] <Tene> I would be really disappointed if Perl 6 ended up with a significant "monkey patch all over the place conflicts" culture like Ruby has had in some cases.

[19:17] <TimToady> AOP falls into a similar hole

[19:19] *** envi left
[19:24] *** uniejo left
[19:25] *** masak joined
[19:25] <masak> rakudo: anon class C {}; say C.WHAT

[19:25] <p6eval> rakudo : OUTPUT«Failure()␤»

[19:25] <masak> std: anon class C {}; say C.WHAT

[19:25] <p6eval> std a194beb: OUTPUT«===SORRY!===␤Undeclared name:␤    'C' used at line 1␤Check failed␤FAILED 00:01 119m␤»

[19:26] * masak submits rakudobug

[19:26] <masak> uasi++ http://twitter.com/uasi/status/9640599502192640

[19:28] <TimToady> masak: btw, the earlier tweet was probably saying that it's *not* difficult to put -> into the language (compared to P5, I imagine)

[19:28] <TimToady> there was a negative on the end

[19:28] <masak> ah.

[19:29] <masak> Google Translate completely missed that fact, I think.

[19:29] <TimToady> I could be missing something too

[19:30] <TimToady> not entire sure how a native speaker would interpret the "inai" on the end

[19:33] <TimToady> *ly

[19:33] <masak> who can bring rakudo.org back up again? :/

[19:34] <moritz_> I hope alester can

[19:35] <sorear> rakudo: anon class C {}; say D.WHAT

[19:35] <p6eval> rakudo : OUTPUT«Could not find sub &D␤  in main program body at line 22:/tmp/BVyrdBgaef␤»

[19:36] <TimToady> that is a spot where STD just guesses and gives a different error message for uppercase than for lowercase

[19:36] <TimToady> std: D

[19:37] <p6eval> std a194beb: OUTPUT«===SORRY!===␤Undeclared name:␤    'D' used at line 1␤Check failed␤FAILED 00:01 117m␤»

[19:37] <TimToady> std: d

[19:37] <p6eval> std a194beb: OUTPUT«===SORRY!===␤Undeclared routine:␤ 'd' used at line 1␤Check failed␤FAILED 00:01 117m␤»

[19:37] <masak> the nomenclature of things that don't exist :)

[19:37] <TimToady> and subtle pressure to follow the convention

[19:40] <Tene> That should be easy to fix for rakudo.

[19:42] <moritz_> it's not

[19:42] <TimToady> sorear: your README.pod says "see note", but I don't see a note, and I don't seem to know where to find an "xbuild"

[19:42] <moritz_> because the lexpad isn't easily available at compile time

[19:42] <moritz_> (not yet)

[19:43] <PerlJam> TimToady: if on ubuntu, "sudo apt-get install mono-xbuild"

[19:43] <Tene> moritz_: I mean, ignoring the name of an anonymous class should be easy, something like this: https://gist.github.com/722248

[19:44] *** MayDaniel joined
[19:44] <Tene> masak: Feel free to try that patch.

[19:44] <moritz_> Tene: ah, right

[19:45] * masak tries it

[19:45] <Tene> I don't think that's going to be entirely right, as it looks like it will still set up ::C, but it will become a compile-time error, so maybe it won't get far enough to matter.

[19:45] <TimToady> PerlJam: thanks

[19:46] <Tene> Maybe the package name should be changed to a include a unique identifier, or something, maybe stick it in some other private namespace or something.

[19:46] *** stkowski joined
[19:46] <Tene> You don't want multiple anon class C {} to stomp on each other.

[19:48] <PerlJam> TimToady: you'll also want to install mono-gmcs as well and have viv in your path somewhere

[19:51] <ash_> http://yehudakatz.com/2010/11/30/ruby-2-0-refinements-in-practice/ another, more in-depth article about ruby 2.0 refinements 

[19:52] <dalek> niecza: 0cbefbb | sorear++ | README.pod:

[19:52] <dalek> niecza: Remove stale note reference & talk about Debian packages

[19:52] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0cbefbb95f

[19:52] <masak> ash_: because "Perl 6" exists, and it's called "Ruby 2.0"? :P

[19:53] * masak has been listening too much to twitterfolks lately

[19:54] <masak> oh, 'refinements' is a language feature.

[19:54] <ash_> masak: humbug, i was just bringing it up because its an interesting alternative to MONKEY_PATCHING that ruby is trying to push 

[19:54] <masak> ash_: yeah, reading now.

[19:55] <PerlJam> at least the ruby folks realize that rampant monkey patching is a problem and are working to fix it.

[19:55] <masak> it looks like a more hygienic form of monkey patching.

[19:55] <wolverian> ash_: nice. after using scala for a while it's obvious that ruby is desperately missing lexical mixins/money patching

[19:55] <wolverian> (corresponding to scala's implicit conversions)

[19:55] <wolverian> s/money/monkey/ 

[19:56] <ash_> and its different, its like lexical scoping but different

[19:56] <ash_> ya

[19:56] <ash_> anyway

[19:56] <ash_> i linked an article earlier and that one is  bit more in depth than the first one i talked about 

[19:57] <dalek> niecza: e9e96d5 | sorear++ | / (3 files):

[19:57] <dalek> niecza: Add optimized code for nested autovivification

[19:57] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e9e96d52d7

[19:57] <wolverian> I've been kind of assuming that "my class String { .... }" or so would be similar in Perl 6.

[19:59] <ash_> key point: in ruby people monkey patch a lot, its a tool to allow some of the functionality of monkey patching with restrictions to prevent people from polluting global namespaces, eg 'requre "ActiveRecord"' in ruby adds something like 28 new methods to Object

[20:00] <masak> wolverian: wouldn't that lexically shadow the old String class completely, rather than augment it?

[20:00] <ash_> or, you'll see code in ruby modules saying things like: if Object.responds_to :to_json ... end 

[20:00] <PerlJam> refinements seem nice but a little backward.

[20:00] <Tene> wolverian: That doesn't work for two reasons: strings passed in from outside the lexical scope would not have the modification, and strings returned from subs in the lexical scope would retain the modification when used elsewhere.

[20:01] <Tene> masak: "something like" probably includes setting the core String class as an ancestor.

[20:03] <wolverian> masak: yeah, that's why I said "or so".

[20:03] <wolverian> I didn't remember the augmentation syntax. "is also"?

[20:03] <ash_> augment class String { }

[20:03] <Tene> wolverian: augment is global

[20:03] <wolverian> okay. then "my augment class String { }"? :)

[20:04] <ash_> rakudo: use MONKEY_TYPING; augment class Str { method foo { 1 } }; "".foo.say

[20:04] <p6eval> rakudo : OUTPUT«1␤»

[20:05] <ash_> thats monkeypatching as it stands in p6 

[20:06] *** fhelmberger left
[20:06] <sorear> Tene: sounds like what you want is extension methods

[20:06] <masak> std: my augment class Str { "does this work?" }

[20:06] <p6eval> std a194beb: OUTPUT«===SORRY!===␤Malformed my at /tmp/Qd0cCzGgwN line 1:␤------> my ⏏augment class Str { "does this work?" }␤    expecting any of:␤        scoped declarator␤      typename␤Parse failed␤FAILED 00:01 118m␤»

[20:07] <TimToady> you can't put two scope_declarators in a row

[20:07] <wolverian> masak: maybe it _should_ work.

[20:07] <masak> no, I suspected that.

[20:07] <masak> wolverian: I can't say I think it reads very well.

[20:07] <wolverian> me neither.

[20:08] <masak> keep thinking :)

[20:08] * TimToady is thinking about 'my method' and 'my regex'...

[20:09] <wolverian> well, we could steal implicit conversions from scala, which would add one new keyword ("implicit"), or C#'s extension methods, whose syntax I don't remember

[20:09] <ash_> class Foo { }; { my method Foo::bar { 1};  say Foo.new.bar; } Foo.new.bar #fails

[20:09] <ash_> would be neat

[20:09] <Tene> masak: Really, it would be a similar scope declarator to 'augment', like: refine class Foo { ... };

[20:10] <TimToady> syntax is boring

[20:10] <wolverian> seriously though, if I can write "my class", it feels proper that I should be able to write "my augment class" too. even if augment is a verb.

[20:10] <Tene> masak: That ties into TimToady's description of a specialized dispatcher for that lexical scope.

[20:10] <PerlJam> wolverian: "augment my class"

[20:10] <PerlJam> :-)

[20:11] <Tene> wolverian: 'my' and 'augment' are the same lexical category.

[20:11] <ash_> augment your class { } ... 

[20:11] *** _kaare joined
[20:11] <Tene> wolverian: does it look like it should make sense to write: my my class?  my our class?

[20:11] <wolverian> Tene: in a sense, yes. what's wrong with lexical globals? ;)

[20:11] <dalek> niecza: a4c17f0 | sorear++ | lib/ (2 files):

[20:11] <dalek> niecza: Run autovivification off the trampoline

[20:11] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a4c17f0b65

[20:11] <masak> ash_++ :)

[20:11] <Tene> wolverian: ... ><

[20:11] <TimToady> it's trivial to add another declarator if we decide to

[20:11] <PerlJam> wolverian: What's the goal here?  You want to lexically shadow an existing class and possibly augment that shadow?

[20:11] <masak> pimp your class { }; ...

[20:12] <wolverian> PerlJam: lexically add behaviour to a class, yes.

[20:12] <ash_> wolverian: dynamic variables are better than globals, IMO 

[20:12] <wolverian> how it exactly works isn't really that important.

[20:12] <masak> 'refine' could even be provided by a module.

[20:12] <wolverian> again, scala, C# and ruby 2 all do it differently.

[20:12] <wolverian> the point is that it's an important feature (IMHO)

[20:13] <TimToady> wolverian: how it exactly works is the *most* important, which is why I said syntax is boring :)

[20:13] <PerlJam> wolverian: why?

[20:13] <sorear> crossed 45s

[20:14] <wolverian> TimToady: right, I meant how it works syntactically is not important. :)

[20:14] <wolverian> PerlJam: so that you can combine modules that change the behaviour of common classes without conflicts.

[20:14] <wolverian> (where "modules" is meant generally and not in any specific sense)

[20:15] <moritz_> you assume that it's important to change the behaviour of classes

[20:15] <moritz_> I think it's bad OO design

[20:15] <TimToady> of course, this is just sweeping the problem one step away--what if you import conflicting view into a 3rd module?

[20:15] <PerlJam> wolverian: so ... it's important in a world of monkey patching or when modules are excessively promiscuous?

[20:16] <TimToady> *views

[20:16] <wolverian> moritz_: what, you never want to add a role to a third party class? 

[20:16] <wolverian> it might be bad design, but I find that in scala it works well when used in moderation.

[20:17] <TimToady> so do globals :P

[20:17] <TimToady> where moderation is defined as "countable on the fingers of one hand"

[20:18] <wolverian> I suppose the two aren't exactly comparable, since scala uses implicits mainly to add syntax 

[20:18] * PerlJam looks at yacc and decides it doesn't know the meaning of "moderation"

[20:18] <masak> is it because Perl has no theoretical axes to grind that it's littered with blunt instruments and loaded uzis? :)

[20:18] <wolverian> e.g. pairs are constructed with "foo -> bar", which means "foo.->(bar)", which works by adding an implicit conversion from Object to an anonymous class that has the -> method

[20:18] <wolverian> I suspect Perl 6 doesn't need that so much.

[20:20] <TimToady> you get these distortions in a language where one object or the other must make the decision in a symmetrical situation; in p6 the lexical scope is the object that makes the decision, or delegates the decision to a dispatcher that can be symmetric

[20:21] <dalek> niecza: 762b837 | sorear++ | docs/tracing.pod:

[20:21] <dalek> niecza: Document NIECZA_TRACE_CALLS

[20:21] <dalek> niecza: review: https://github.com/sorear/niecza/commit/762b837c35

[20:21] <ash_> moritz_: it might be bad OO to modify built in objects, but it is common practice in some places, its better to have a way of doing it for people that need to (for whatever reason) than let people tack it on later in a module that may or may not work with the rest of p6 ecosystem 

[20:21] *** saaki joined
[20:22] <PerlJam> ash_: it's better to encourage people to think about the consequences of their actions.

[20:22] <sorear> completely eliminating the #2 most called function helped a bit

[20:23] <ash_> p6 already lets you augment class {...}; refinement (in the ruby sense, i don't know scala or c#) is almost a lexically scoped augment 

[20:23] <sorear> ash_: niecza disallows 'augment' in modules.  problem solved.

[20:23] <wolverian> TimToady: right. single dispatch is a big wart in scala!

[20:25] <flussence> I can imagine this object thing being useful if for example, you want some high-overhead debugging stuff in a method that gets called everywhere, but you only want to know about one specific call. Or you want to poke around that object's insides when that call happens. maybe.

[20:25] <ash_> i think something is wrong if you ever see code like: "unless Foo.^method ~~ 'bar' { ...add bar... }" start showing up in a module, which is a common thing in ruby because of their open classes, and p6 already has open classes, it could probably become a problem for p6 as well 

[20:26] <sorear> using if $ch ~~ "\n" on a string which is known to have at most one character is ... wasteful

[20:26] <ash_> or you could disable augment 

[20:26] <masak> by the way, only 10 days -- ten days -- now remain to the BIG ANNOUNCEMENT.

[20:26] <masak> which means it's time for another clue.

[20:26] <sorear> oh, it's obvious.

[20:26] <sorear> I'll be 20 1/12

[20:27] * sorear feels important

[20:27] <colomon> \o/

[20:27] <moritz_> rakudo: say Date.today + 10

[20:27] <p6eval> rakudo : OUTPUT«2010-12-10␤»

[20:27] <colomon> sorear: apparently I missed telling you happy birthday approximately 20 days ago.  So happy unbirthday!

[20:28] <masak> sorear: happy unbirthday!

[20:28] <colomon> masak: your clue please, sir?

[20:29] <dalek> mu: 5287a83 | duff++ | misc/perl6advent-2010/schedule:

[20:29] <dalek> mu: Claim a couple of days for the advent calendar

[20:29] <dalek> mu: review: https://github.com/perl6/mu/commit/5287a83101

[20:29] <masak> colomon: thought you'd never ask :)

[20:29] *** Axius joined
[20:30] <masak> colomon: here it is: http://www.thefreedictionary.com/task

[20:30] <jnthn> "A difficult or tedious undertaking"

[20:30] *** plainhao left
[20:30] <colomon> "To overburden with labor"

[20:30] <jnthn> ...sounds like guessing masak's announcement. :P

[20:30] <PerlJam> masak: clearly you've created a perfect make replacement for Perl 

[20:30] * moritz_ has an idea

[20:30] <masak> :)

[20:31] <moritz_> or you have created your own personal-time-scheduling-and-tracking app

[20:31] <moritz_> to become 200% productive not only in November, but for the whole year

[20:31] <PerlJam> moritz_: this is just masak's way of soliciting ideas for future projects.

[20:31] <masak> I like your overconfidence in me, even if it's feigned.

[20:31] <moritz_> PerlJam: :-)

[20:32] <masak> PerlJam: sssh! ... I mean, no!

[20:32] * masak quietly takes notes

[20:33] <moritz_> masak: or you have a deal with Patrick Rothfuss; he'll write your next Yapsi release announcement

[20:34] *** jaldhar left
[20:34] *** MayDaniel left
[20:34] *** tylercurtis joined
[20:35] <masak> moritz_: that would be tomorrow, not in 10 days.

[20:35] <ash_> rakudo: my method Foo::bar { }

[20:35] <p6eval> rakudo :  ( no output )

[20:35] <moritz_> masak: well, not for tomorrow's release

[20:35] <ash_> rakudo: class Foo { }; my method Foo::bar { 1 }; say Foo.new.bar;

[20:35] <p6eval> rakudo : OUTPUT«Method 'bar' not found for invocant of class 'Foo'␤  in main program body at line 22:/tmp/wPFuy49BOa␤»

[20:36] <ash_> std: class Foo { }; my method Foo::bar { 1 }; say Foo.new.bar;

[20:36] <p6eval> std a194beb: OUTPUT«ok 00:01 120m␤»

[20:36] <ash_> does that mean anything useful? 

[20:36] <ash_> (my method ...) 

[20:36] <masak> moritz_: you've guessed right insofar as him not writing tomorrow's release announcement :P

[20:37] <masak> ash_: you wouldn't be able to call the method in that way, at any rate.

[20:37] <ash_> why not? 

[20:37] <masak> ash_: but I doubt it'd even work if you used 'our'. feels wrong.

[20:38] <moritz_> ash_: Foo::bar looks like an entry in the symbol table to me

[20:38] <moritz_> but method lookup doesn't look into symbol tables

[20:38] <jnthn> That method dispatch will fail.

[20:38] <jnthn> ah, Rakudo got it right. phew :)

[20:39] <sorear> niecza: class Foo { }; my method Foo::bar { 1 }

[20:39] <p6eval> niecza 762b837: OUTPUT«===SORRY!===␤Qualified method definitions not understood at /tmp/4Rnk3EZVBr line 1:␤------> class Foo { }; my method Foo::bar⏏ { 1 }␤Use of uninitialized value $name in concatenation (.) or string at

[20:39] <p6eval> ../home/p6eval/niecza/src/Niecza/Actions.pm lin…

[20:39] *** masak left
[20:39] <sorear> hrm.

[20:39] *** masak joined
[20:39] <sorear> niecza: my class A::B { }

[20:39] <p6eval> niecza 762b837: OUTPUT«===SORRY!===␤Qualified package definitions NYI at /tmp/A0_sk9pM9c line 1:␤------> my class A::B⏏ { }␤Attribute (var) does not pass the type constraint because: Validation failed for 'Str' with value undef at

[20:39] <p6eval> ../home/p6eval/niecza/src/Niecza/Action…

[20:40] <sorear> my.*:: doesn't make any sense

[20:40] <sorear> I thought I had an awesome error message for it, but I guess not

[20:40] <ash_> std: my class A::B { }

[20:40] <p6eval> std a194beb: OUTPUT«ok 00:01 118m␤»

[20:40] <sorear> :: means "put the right side in the symbol table named on the left"

[20:40] <ash_> class A::B { }

[20:41] <ash_> err

[20:41] <sorear> my means "don't put this in any symbol table"

[20:41] <sorear> :: is only compatible with our

[20:41] <sorear> (and augment)

[20:41] <ash_> well, you can do: 

[20:42] <ash_> rakudo: class Foo { }; { my &a = method { 1 }; Foo.new.&a.say; }

[20:42] <p6eval> rakudo : OUTPUT«1␤»

[20:42] <ash_> just wondering if there was a way to make that work without & and have it still be lexically scoped

[20:43] <masak> ash_: probably not; why is it important to lose the & ?

[20:43] <sorear> you can lose one of the &s

[20:43] <ash_> masak: good point

[20:43] <sorear> rakudo: my method foo { 1 }; "foo".&foo.say

[20:43] <p6eval> rakudo : OUTPUT«1␤»

[20:44] <TimToady> one of the lesser design principles of Perl 6 is: Strange things should look strange.

[20:45] <ash_> that functionality could approximate refinement, no? 

[20:45] <PerlJam> rakudo: my method foo { 1 }; .&foo.say

[20:45] <p6eval> rakudo : OUTPUT«1␤»

[20:45] <masak> sorear posted on p6l about methodicals (which is what ash_ is proposing) about half a year ago. since then, we've discovered the power of $obj.&foo here on the channel, and the need to specially introduce methodicals has *completely* gone away, if you ask me.

[20:46] <masak> I think I replied something to that effect to that p6l thread.

[20:46] <TimToady> std: my multi method foo(Int:) {...}; my multi method foo(Str:) {...}; 42.&foo

[20:46] <p6eval> std a194beb: OUTPUT«ok 00:01 126m␤»

[20:46] <TimToady> that even lets you dispatch on the type

[20:47] <masak> nice.

[20:47] <TimToady> so it's an even closer approximation to refinement

[20:47] <jnthn> TimToady: ...ouch!

[20:47] <jnthn> Does...that even work...

[20:47] <sorear> why wouldn't it?

[20:47] <jnthn> rakudo: my multi method foo(Int:) {...}; my multi method foo(Str:) {...}; 42.&foo

[20:47] <p6eval> rakudo : OUTPUT«===SORRY!===␤Multiple declarations of lexical '&foo'␤␤»

[20:47] <sorear> my methods are just subs

[20:47] <jnthn> sorear: Because I wrote the implementatin of that in Rakudo

[20:47] <masak> jnthn: I think so. it's only anon methods that can't multi.

[20:48] <ash_> rakudo: class A { has $!a }; method foo { $!a + 1}; A.new(:a(3)).foo.say 

[20:48] <p6eval> rakudo : OUTPUT«Useless declaration of has-scoped Method in a module; add our or my to install it in the lexpad or namespace␤Method 'foo' not found for invocant of class 'A'␤  in main program body at line 22:/tmp/qs4a4ir_St␤»

[20:48] <jnthn> sorear: So I generally knwo what I expect to work or not :)

[20:48] <ash_> rakudo: class A { has $!a }; my method foo { $!a + 1}; A.new(:a(3)).&foo.say

[20:48] <p6eval> rakudo : OUTPUT«4␤»

[20:48] <jnthn> Anyway, I suepct it can be made to work.

[20:48] <ash_> i thought that was deemed bad/wrong/breaks encapsulation 

[20:48] <sorear> rakudo: my multi sub foo(Int) {...}; my multi sub foo(Str) {...}; 42.&foo

[20:48] <p6eval> rakudo :  ( no output )

[20:48] <sorear> ash_: yes

[20:48] <masak> ash_: it was. it is. it's a bug.

[20:48] <jnthn> ash_: That will likely become an error.

[20:48] <masak> ash_: it's been reported :)

[20:49] <sorear> It's clearly very low priority though.

[20:49] <ash_> then do 'my method' provide a real equivalent to refinement? since in refinement you can access private variables if your in the right scope

[20:50] <ash_> i guess the jump to private requires an augment and MONKEY_PATCHING 

[20:50] <sorear> jnthn isn't even trying to get away from "attributes are named elements of an object" in 6model

[20:50] <ash_> monkey_typing 

[20:53] <tylercurtis> sorear: ooc, what is the alternative to "attributes are named elements of an object"?

[20:54] <TimToady> class Me { use MONKEY_TYPING; augment A { trusts Me }; ... }

[20:54] <sorear> tylercurtis: that was worded badly

[20:54] <sorear> tylercurtis: what I mean is that every current Perl 6 implementation has objects that act sort of like hashes

[20:54] <sorear> $obj!A has a single meaning, $obj!B has another

[20:55] <sorear> however Perl 6 attribute privacy requires that a superclass and a subclass be able to use $!x without interference

[20:56] <sorear> so the objects really need to be keyed by class * name

[20:56] <sorear> not name alone

[20:56] * tylercurtis thought 6model did that.

[20:56] <jnthn> sorear: huh?

[20:56] <sorear> (it's fairly straightforward to turn this into class * index, in a system vaguely reminiscent of virtual bases)

[20:56] <jnthn> sorear: "so the objects really need to be keyed by class * name" - that's exactly what 6model does

[20:57] <jnthn> I wish you'd actually check stuff about 6model. Msot of what you say aobut it is consistently wrong.

[20:57] <jnthn> There's even stuff in the REPR API already to allow indexed access.

[20:57] <masak> jnthn++

[20:57] <sorear> that's a failure of reading comprehension, not effort

[20:57] <sorear> sorry

[20:58] <sorear> I saw the indexes, but not the class disambiguation stuff

[20:59] <masak> Tene: your patch worked, by the way. making spectest and then committing. Tene++

[20:59] <jnthn> sorear: 'sok

[21:02] <lichtkind> is .... still the yadda ?

[21:02] <TimToady> next niecza build problem: Target SAFE.cs:

[21:02] <tylercurtis> lichtkind: ...

[21:02] <TimToady> Can't locate STD.pm in @INC

[21:03] <lichtkind> tylercurtis: the ... operator

[21:03] <lichtkind> since he does list creation

[21:04] <tylercurtis> lichtkind: Sorry, I was unclear. The series operator and the yadda term are both "...", not "....".

[21:04] *** Axius left
[21:04] <lichtkind> yes i had a typo

[21:04] <jnthn> lichtkind: Perl 6 always knows whether it expects an infix operator or a term. So there's no an ambiguity between them.

[21:05] <jnthn> lichtkind: Vsetko je dobre. :)

[21:05] <lichtkind> :)

[21:06] <ash_>  what language is that? 

[21:06] <jnthn> ash_: Lazy Slovak.

[21:06] * ash_ wishes i knew more than bad english 

[21:06] <jnthn> (Lazy 'cus I neglected to type any of the marks... :-))

[21:07] <sorear> TimToady: niecza expects to find a CPAN STD installed

[21:08] <TimToady> ah

[21:08] <ash_> sorear: how does one build/playwith niecza

[21:09] <sorear> ash_: 1. git clone git://github.com/sorear/niecza.git

[21:09] <ash_> check

[21:09] <sorear> 2. install stuff listed in README

[21:10] <ash_> perl 5.12 i assume is fine, right? 

[21:10] <sorear> yes

[21:10] <ash_> never built a C# program (or mono) so, thats the part that has me stumped 

[21:10] <ash_> no ./configure either 

[21:11] <sorear> xbuild

[21:11] <sorear> unless you're talking about mono itself

[21:12] <ash_> i am on OS X 10.6, mono 2.6.7 x86 

[21:12] <ash_> so... i dont know

[21:13] <sorear> mono 2.6.7 is fine, that's what I started on

[21:13] <sorear> run xbuild in the niecza root

[21:13] <ash_> kk, still getting perl5 deps

[21:13] *** Ikarus left
[21:14] *** Ikarus joined
[21:15] *** masak left
[21:16] *** masak joined
[21:17] *** ch3ck left
[21:18] <ash_> sorear++ its building now

[21:18] <diakopter> .. and it's done.

[21:19] * ash_ off to class

[21:19] *** ash_ left
[21:19] *** Axius joined
[21:23] *** Hor|zon joined
[21:26] *** __david__ joined
[21:30] *** masak left
[21:33] *** wamba left
[21:37] *** Axius_ joined
[21:44] *** y3llow joined
[21:45] *** pothos_ joined
[21:47] *** pothos_ left
[21:48] *** pothos joined
[21:54] *** Axius left
[21:54] *** Axius_ left
[22:00] *** __david__ left
[22:02] <shortcircuit> TimToady: Sure, RC has P6 and P5 versions of Topological Sort...but it looks like the P6 version has the "translation of Perl" annotation.

[22:02] <shortcircuit> Is that P6 implementation really the most idiomatic for the task?

[22:08] *** bluescreen joined
[22:09] *** bluescreen is now known as Guest2621

[22:09] *** Luiji99 joined
[22:09] <Luiji99> How do I create PBCs with Rakudo?

[22:11] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[22:15] <flussence> shortcircuit: the p6 one looks like a literal translation too, the [<>]s should be <>s. I haven't found any way to make the algorithm itself look nicer though.

[22:15] <Luiji99> The Rakudo --output command-line option doesn't seem to do anything.

[22:17] <sorear> you need to pass the option to Parrot

[22:17] <flussence> Luiji99: --target=pir will get you halfway there, =pbc doesn't seem to work directly

[22:17] <sorear> parrot --parrot-options /path/to/perl6.pbc --rakudo-options

[22:18] <Luiji99> There is no such file perl6.pbc.

[22:18] <Luiji99> flussence:thanks,trying

[22:19] <Luiji99> it worked! thx

[22:19] *** Luiji99 left
[22:19] <flussence> I don't like giving half-solutions, but if it works for him... *shrug*

[22:25] *** ch3ck joined
[22:26] *** ch3ck3r joined
[22:30] *** ch3ck left
[22:37] <lichtkind> TimToady: regex_mod_internal means only tobe used inside a regex not in front as a adverb?

[22:43] <dalek> rakudo: bba62f3 | masak++ | src/Perl6/Actions.pm:

[22:43] <dalek> rakudo: [Perl6::Actions] don't registed names of anon types

[22:43] <dalek> rakudo: 

[22:43] <dalek> rakudo: Patch submitted by Tene++.

[22:43] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/bba62f3bae

[22:45] <jnthn> Tene++, masak++

[22:54] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_lookup_tablet

[22:56] *** risou joined
[23:03] *** _kaare left
[23:03] *** ch3ck3r left
[23:04] *** ch3ck3r joined
[23:09] *** hercynium left
[23:09] *** Helios- joined
[23:16] *** tylercurtis left
[23:24] *** risou_ joined
[23:25] *** risou left
[23:32] *** masak joined
[23:32] <masak> ahoy!

[23:34] <masak> sorear: I now have a working niecza checkout.

[23:35] <colomon> \o/

[23:36] <masak> sorear: and, conveniently, November just ran out, so I can focus on other things, such as trying out a new implementation. :)

[23:37] <masak> blog post! http://strangelyconsistent.org/blog/november-30-2010-going-out-with-style

[23:38] <colomon> having a working system perl 5.10 is slowing me down at the moment...

[23:38] <colomon> (installing niecza, I mean.)

[23:39] <masak> colomon: every heard of perlbrew?

[23:39] <masak> s/every/ever/

[23:39] <colomon> I recognize the name...

[23:40] <colomon> oooooo

[23:40] <masak> I

[23:40] <masak> I've only used it very little so far.

[23:40] <masak> but it's a *very* pleasant experience, what little I've used it.

[23:41] <jnthn> masak: (blog post) :/

[23:41] * masak exhales after the November blogging month

[23:42] <masak> jnthn: I'm only reporting things as they are. :/

[23:42] <jnthn> masak: Things as they are, are, apparently, shit.

[23:42] <masak> yup.

[23:43] <colomon> masak: any way to distill that down to a benchmark?

[23:43] <masak> colomon: I don't know.

[23:43] <masak> colomon: maybe just put all the code into one file and use that as a benchmark?

[23:44] <masak> but it's quite a bit of code.

[23:45] <colomon> I'm thinking something that can fit into the bench-scripts framework.  (One large file would be okay, so far as I know.)

[23:45] <colomon> We need to seriously tackle profiling issues.

[23:46] *** tylercurtis joined
[23:46] <colomon> ... or maybe make niecza implement a lot more of the spec.  :)

[23:47] <masak> that's not an exclusive or. :)

[23:48] <colomon> afk # pub

[23:50] *** whiteknight joined
[23:54] *** plobsing joined
