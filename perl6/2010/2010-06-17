[00:00] <TimToady> yes :)

[00:00] <sorear> I appear to be spending a considerable amount of time not tracing the DFA engine

[00:01] <TimToady> it's a good idea, just needs someone young, active, with lots of tuits, who is not allergic to yak shaving

[00:01] <diakopter> do tuits get rounder or anglier with age

[00:02] <pmichaud> rarer.

[00:02] <pmichaud> and pricklier.

[00:03] <TimToady> there's a slightly smaller number of tuits, but many more places to put 'em

[00:04] <sorear> I have a semi-automatic yak shaver, it's labelled :%s///cg

[00:04] <TimToady> I've spent a goodly portion of today talking to my brother-in-law, who is making large holes in my house.

[00:04] <jnthn> Hmm. So Parrot currently allocates for every object an Object PMC and in turn a ResizablePMCArray ==> two GCables + some memory overhead for the attribute storage. I'd figured that switching that to a C array would save us a lot of GCables (well, I guess that has happened) but also memory usage *increased*. Maybe I've sprung a leak... :-S

[00:05] <pmichaud> hmm.  jnthn has leaks in his objects, and TimToady has holes in his house.

[00:06] <sorear> jnthn: I've been telling people that Object = 5 memory blocks for a while now...

[00:06] <jnthn> sorear: I wasn't not believing you. :-)

[00:06] <jnthn> sorear: I've known it's heavy for a while, I figured it was time for a diet. :-)

[00:06] <jnthn> Alas, the diet made me fatter.

[00:06] <pmichaud> today during the design meeting I proposed holding a Lorito/Parrot BOF at YAPC::NA, the explicit purpose of which is to come up with some core design principles that might drive the development of Lorito. (more)

[00:07] <pmichaud> (1) suggestions would be welcomed

[00:07] <pmichaud> (2) my #1 suggestion is going to be "make a fast and efficient object metamodel/implementation"

[00:08] <pmichaud> (end for now)

[00:08] <diakopter> :)

[00:08] <jnthn> pmichaud: I've been sketching out how to do better for Rakudo on that front of late.

[00:09] <pmichaud> jnthn: well, we can only do so much before we basically take over (or thoroughly subvert) the VM :)

[00:09] <pmichaud> jnthn: important ping

[00:09] <jnthn> pmichaud: important pong

[00:10] <pmichaud> okay, I have a problem (at least I think it's a biggish one)

[00:10] <jnthn> Ugh.

[00:10] <pmichaud> I've moved Positional into the setting

[00:10] <pmichaud> now I want to declare Match  as being   "does Positional does Associative"

[00:10] <pmichaud> and I get

[00:10] <pmichaud> Method 'of' collides and a resolution must be provided by the class

[00:11] <jnthn> conflict relating to 'of'?

[00:11] <pmichaud> yes.

[00:11] <jnthn> gah, you beat me.

[00:11] <jnthn> :-)

[00:11] <jnthn> method of { Mu }

[00:11] <pmichaud> perfect.

[00:11] <pmichaud> okay, not big then.

[00:11] <sorear> what does "of" mean in both roles?

[00:11] <jnthn> pmichaud: .of tells you what the ::T was

[00:11] <pmichaud> right

[00:11] <TimToady> maybe they both do the "Of" role

[00:11] <jnthn> sorear: role Positional[::T] { method of { T } }

[00:11] <pmichaud> I was trying to figure out how to get to the T.

[00:12] <pmichaud> but I don't need to do that.

[00:12] <pmichaud> so, we're good.

[00:12] <jnthn> pmichaud: Well, for match objects they're always using untyped.

[00:12] <pmichaud> jnthn: right.

[00:12] <pmichaud> as I said, "perfect."  :-)

[00:12] <jnthn> So Mu is the correct answer.

[00:13] <jnthn> (take over the VM) yeah, I wonder each time we do that a step more how long until we almost *have* a VM. :-)

[00:13] <pmichaud> well, that's why I volunteered to set something up for yapc::na

[00:13] <pmichaud> we'll have a lot of parrot core people there, and maybe I can set a few guidelines for them

[00:14] <pmichaud> or at least say "if you really want a good VM for rakudo, this is what we think needs emphasizing"

[00:14] <jnthn> I think we both have ideas of what we'd like the metamodel to look like, but how far the Parrot folks will buy them, or if they'll get rejected as "too Perlish", I've no idea.

[00:14] <pmichaud> right

[00:15] <pmichaud> I was going to suggest the Perl 6/Moose metamodel as well, especially since that model can be used to support both class-based and prototype-based OO

[00:15] <pmichaud> but more important (to me) is to have a speedy object system.  Right now what we have is anything but that.

[00:15] <jnthn> I'm certainly willing to try working with the Parrot folks to get us what we want first though. It's far preferable.

[00:15] <pmichaud> I mean, attribute access is slow, method invocation is slow, etc.

[00:15] <jnthn> *nod*

[00:16] <jnthn> Attribute access in Perl 6 can be done by offset.

[00:16] <pmichaud> I'd much rather have a fast object system at the core, with operators and stuff layered on top, than to have fast operators at the core, with an object model layered on type.

[00:16] <jnthn> *nod*

[00:16] <pmichaud> s/type/top/

[00:16] <jnthn> (for a lot of cases)

[00:16] <jnthn> But we can't take advantage of that at the moment.

[00:17] <diakopter> "fast object system" - incl primitive types, classes? single-inheritance?  GC?

[00:17] <pmichaud> diakopter: GC, yes

[00:17] <jnthn> diakopter: primitive types as attributes has to happen.

[00:17] *** skids joined
[00:17] <diakopter> k

[00:17] <pmichaud> "classes" in the way that the Perl 6 metamodel has them

[00:18] <pmichaud> i.e., they're meta-level objects that manage dispatch

[00:18] <ash__> parrot's PIR meta model is a bit bare.... 

[00:18] <diakopter> it's not the dispatch at the lowest levels that makes it slow?

[00:18] <diakopter> (currently in parrot?)

[00:18] <pmichaud> diakopter: it's partially that, yes.

[00:19] <pmichaud> currently method dispatch requires hash lookups and a pretty lengthy search through inheritance and role chains, iiuc.

[00:19] <jnthn> Not role chains.

[00:19] <pmichaud> sorry, inheritance chains

[00:19] <jnthn> Composition is (really) flattening.

[00:19] <pmichaud> you're correct, not role chains

[00:19] <jnthn> Just inheritance.

[00:19] <diakopter> none of it is resolved at compile-time?

[00:19] *** Visitor99 joined
[00:19] <pmichaud> a HLL can potentially do that, yes.

[00:20] <pmichaud> but we're not really set up to do that at the moment.

[00:20] <diakopter> I mean, at the lowest levels

[00:20] <diakopter> the dispatching on the lowest level objects

[00:20] <pmichaud> and parrot doesn't really help much there, as its facilities for managing and referencing subs is a bit limited

[00:21] <pmichaud> anyway, I don't know that what we produce will greatly influence Parrot, and that would be okay, I just thought it'd be useful for them and us to brainstorm the key design principles we'd like to see in an vm

[00:21] <jnthn> *nod*

[00:21] <jnthn> We can ask. :-)

[00:22] <pmichaud> to me, it's not really us asking them (more)

[00:22] <pmichaud> oops, I have to run to dinner

[00:22] <pmichaud> we'll pick this up again tomorrowish

[00:22] <jnthn> ENOMORE

[00:22] <jnthn> OK :-)

[00:22] <pmichaud> on the plus side, the branch is up to S05-mass/properties-derived.rakudo................. 178    0    0   78  256

[00:22] <pmichaud> with apparently no errors

[00:22] <jnthn> \o/

[00:23] <pmichaud> (I'm running full spectest now)

[00:23] <pmichaud> so I think we're closing in on a merge quickly.

[00:23] <jnthn> :-)

[00:23] <pmichaud> bbl

[00:23] <jnthn> o/

[00:25] <pugssvn> r31303 | sorear++ | [dfa/Cursor] Don't use Class::MOP to locate protoregex methods; do it manually.  Reduces time to parse 2 + 2 cold from 5.15s to 3.35s (avg 10 runs) 

[00:25] <Visitor99> rakudo: sub s1{.say for(1..5)}; &s1;

[00:25] <p6eval> rakudo c9ee2e:  ( no output )

[00:26] <jnthn> Visitor99: &s1 doesn't call the sub

[00:27] <jnthn> Also, some extra whitespace needed. :-)

[00:27] <jnthn> rakudo: sub s1{.say for 1..5}; s1;

[00:27] <p6eval> rakudo c9ee2e: OUTPUT«1␤2␤3␤4␤5␤»

[00:27] <sorear> the hot time for trunk Cursor is 2.35s

[00:27] <sorear> so we've mostly bridged the gap

[00:27] <Visitor99> i want to have a junction with 2 funtions

[00:27] <Visitor99> and the run the junction

[00:27] <Visitor99> it is possible?

[00:27] <jnthn> Yup

[00:27] <jnthn> Should be

[00:27] <Visitor99> the=then

[00:28] <jnthn> rakudo: sub a { say 1 }; sub b { say 2 }; my $j = &a & &b; $j();

[00:28] <p6eval> rakudo c9ee2e: OUTPUT«1␤2␤»

[00:28] <Visitor99> sub s1{.say for(1..5)}; sub s2{.say for('a'..'b')}; $subs = &s1|&s2; $subs.say.perl;

[00:28] *** xabbu42_ joined
[00:28] *** xabbu42 left
[00:28] *** xabbu42_ is now known as xabbu42

[00:29] <Visitor99> rakudo: sub s1{.say for(1..5)}; sub s2{.say for('a'..'b')}; $subs = &s1|&s2; $subs.say.perl;

[00:29] <p6eval> rakudo c9ee2e: OUTPUT«===SORRY!===␤Symbol '$subs' not predeclared in <anonymous> (/tmp/xn73YuQyE_:11)␤»

[00:29] <Visitor99> rakudo: sub s1{.say for(1..5)}; sub s2{.say for('a'..'b')}; my $subs = &s1|&s2; $subs.say.perl;

[00:29] <p6eval> rakudo c9ee2e: OUTPUT«any({ ... }, { ... })␤»

[00:29] <jnthn> Visitor99: You're not actually calling them there.

[00:29] <jnthn> You're calling .say on the junction object.

[00:29] <Visitor99> well... that's the part i don't know yet :)

[00:30] <jnthn> rakudo: sub s1{.say for(1..5)}; sub s2{.say for('a'..'b')}; my $subs = &s1|&s2; $subs().say.perl;

[00:30] <p6eval> rakudo c9ee2e: OUTPUT«1␤2␤3␤4␤5␤a␤b␤Method 'HOW' not found for invocant of class 'ArrayIterator'␤  in '&infix:<===>' at line 5938:CORE.setting␤  in 'Junction::postcircumfix:<( )>' at line 1␤  in main program body at line 11:/tmp/zwEbsCxljj␤»

[00:30] <Visitor99> rakudo: sub s1{.say for(1..5)}; sub s2{.say for('a'..'b')}; my $subs = &s1|&s2; $subs.say.perl; $subs();

[00:30] <p6eval> rakudo c9ee2e: OUTPUT«any({ ... }, { ... })␤1␤2␤3␤4␤5␤a␤b␤Method 'HOW' not found for invocant of class 'ArrayIterator'␤  in '&infix:<===>' at line 5938:CORE.setting␤  in 'Junction::postcircumfix:<( )>' at line 1␤  in main program body at line 11:/tmp/B1Hbg74UTw␤»

[00:30] <jnthn> wtf

[00:30] <diakopter> bbq

[00:30] <jnthn> It ran it anyway...

[00:30] <jnthn> mmm...bbq

[00:30] <Visitor99> rakudo: sub s1{.say for(1..5)}; sub s2{.say for('a'..'b')}; my $subs = &s1|&s2; $subs();

[00:30] <p6eval> rakudo c9ee2e: OUTPUT«1␤2␤3␤4␤5␤a␤b␤Method 'HOW' not found for invocant of class 'ArrayIterator'␤  in '&infix:<===>' at line 5938:CORE.setting␤  in 'Junction::postcircumfix:<( )>' at line 1␤  in main program body at line 11:/tmp/W34xAjikHY␤»

[00:31] <Visitor99> it is possible to run them in parallel?

[00:31] <Visitor99> rakudo: sub s1{.say for(1..5)}; sub s2{.say for('a'..'e')}; my $subs = &s1^&s2; $subs();

[00:31] <p6eval> rakudo c9ee2e: OUTPUT«1␤2␤3␤4␤5␤a␤b␤c␤d␤e␤»

[00:31] <jnthn> Visitor99: Not yet in Rakudo.

[00:33] <Visitor99> rakudo: sub s1{.say for(1..5)}; sub s2{.say for('a'..'e')}; my $subs = one(&s1,&s2); $subs();

[00:33] <p6eval> rakudo c9ee2e: OUTPUT«1␤2␤3␤4␤5␤a␤b␤c␤d␤e␤»

[00:33] <Visitor99> rakudo: sub s1{.say for(1..5)}; sub s2{.say for('a'..'e')}; my $subs = all(&s1,&s2); $subs();

[00:33] <p6eval> rakudo c9ee2e: OUTPUT«1␤2␤3␤4␤5␤a␤b␤c␤d␤e␤Method 'HOW' not found for invocant of class 'ArrayIterator'␤  in '&infix:<===>' at line 5938:CORE.setting␤  in 'Junction::postcircumfix:<( )>' at line 1␤  in main program body at line 11:/tmp/ZnWRewdWFz␤»

[00:33] <Visitor99> rakudo: sub s1{.say for(1..5)}; sub s2{.say for('a'..'e')}; my $subs = none(&s1,&s2); $subs();

[00:33] <p6eval> rakudo c9ee2e: OUTPUT«1␤2␤3␤4␤5␤a␤b␤c␤d␤e␤Method 'HOW' not found for invocant of class 'ArrayIterator'␤  in '&infix:<===>' at line 5938:CORE.setting␤  in 'Junction::postcircumfix:<( )>' at line 1␤  in main program body at line 11:/tmp/bzXpKGcuLV␤»

[00:34] <Visitor99> rakudo: sub s1{.say for(1..5)}; sub s2{.say for('a'..'e')}; my $subs = one(s1(),s2()); $subs();

[00:34] <p6eval> rakudo c9ee2e: OUTPUT«1␤2␤3␤4␤5␤a␤b␤c␤d␤e␤invoke() not implemented in class 'ArrayIterator'␤  in <anon> at line 5139:CORE.setting␤  in 'Junction::postcircumfix:<( )>' at line 5938:CORE.setting␤  in main program body at line 11:/tmp/A7_D6O6vm_␤»

[00:36] <pugssvn> r31304 | sorear++ | [dfa/Cursor] Gut the monolithic lexer cache, as it is now actually a pessimization. 

[00:38] *** lest_away is now known as lestrrat

[00:40] *** masonkramer_ joined
[00:40] *** masonkramer left
[00:40] *** masonkramer_ is now known as masonkramer

[00:41] * jnthn -> sleep

[00:43] <sorear> stefan@stefans:/usr/local/src/pugs/src/perl6$ perl -e 'use strict; BEGIN { constant->import(DEBUG => 1) }; BEGIN { DEBUG }'

[00:43] <sorear> Bareword "DEBUG" not allowed while "strict subs" in use at -e line 1.

[00:43] <sorear> I have a feeling I'm misunderstanding something extremely important

[00:43] <sorear> are BEGIN blocks not run before the remainder of the file is parsed?

[00:45] <pmichaud> down to 6 failing test files.

[00:45] <sorear> ah, found it

[00:46] <sorear> apparently "constant" wasn't loaded

[00:50] *** kidd left
[00:52] <pugssvn> r31305 | sorear++ | [dfa/Cursor] Change $DEBUG to a use constant. 

[00:53] *** snarkyboojum joined
[00:56] <sorear> only took 30 seconds of STD.pm6 parse time

[01:04] *** cdarroch left
[01:08] *** knewt2 left
[01:13] <pugssvn> r31306 | sorear++ | [dfa/Cursor] Small evil microoptimization to the decision tree engine 

[01:16] <sorear> Is there a good way to get precise costs from Perl 5?

[01:17] <sorear> I'd like some magic button I can push for "Report # of executed ops at end"

[01:17] <sorear> there's too much statistical noise in STD.pm6 timings to effectively microoptimize with just timings

[01:21] *** knewt2 joined
[01:25] *** plobsing joined
[01:26] <snarkyboojum> sorear++ # re dfa/Cursor bootstrapping STD.pm6!!

[01:33] *** Chillance joined
[01:36] *** broquaint joined
[01:37] *** whiteknight left
[01:45] *** snarkyboojum left
[01:45] *** xabbu42 left
[01:46] *** xabbu42 joined
[01:47] *** masonkramer_ joined
[01:52] *** xabbu42_ joined
[01:52] *** xabbu42 left
[01:52] *** xabbu42_ is now known as xabbu42

[02:01] *** Visitor99 left
[02:09] * diakopter giggles at the mention of "the evil mangler" in http://www.cse.unsw.edu.au/~chak/papers/ghc-llvm.pdf

[02:13] <sorear> yes, the evil mangler

[02:13] <sorear> postprocessing gcc -S output with regexes, what could possibly go wrong?

[02:13] *** snarkyboojum joined
[02:13] <diakopter> this paper is interesting

[02:14] *** Chillance left
[02:21] *** TiMBuS joined
[02:22] <diakopter> hah; "the Righteous Mangler"

[02:25] <snarkyboojum> hey - that's my uni! :)

[02:27] <snarkyboojum> and that's my lecturer for next session :)

[02:28] <diakopter> heh

[02:28] *** meppl left
[02:28] <diakopter> tell him typo in first paragraph of section 6.2 - missing space in line 5

[02:29] <snarkyboojum> heh

[02:30] <diakopter> also missing a space in the sixth-from-last line of section 6.2

[02:31] <pugssvn> r31307 | colomon++ | [t/spec] Fudge out test that depended on Array isa Seq. 

[02:31] <diakopter> its -> it's  in the 3rd-to-last line of first paragraph of section 6.3

[02:32] <diakopter> same in the last sentence of section 6.3

[02:34] <snarkyboojum> diakopter: perhaps you could provide your peer review services :)

[02:35] <diakopter> certainly not technical review.. maybe english punctuation

[02:35] *** pnate left
[02:42] *** xabbu42 left
[02:42] *** xabbu42_ joined
[02:43] <colomon> pmichaud: uniq.t error is kind of weird.  I mean, for sure our .uniq implementation sucks.  But I really don't understand why the test works in master and fails in list.

[02:52] *** ggoebel left
[02:54] *** snarkyboojum left
[02:56] *** pronik` joined
[02:57] *** pronik left
[03:07] *** pnate joined
[03:08] *** Visitor99 joined
[03:09] *** masonkramer_ left
[03:13] *** tedv left
[03:13] *** snarkyboojum joined
[03:24] *** xabbu42_ left
[03:24] *** xabbu42 joined
[03:29] *** xabbu42_ joined
[03:29] *** xabbu42 left
[03:29] *** xabbu42_ is now known as xabbu42

[03:44] *** xabbu42_ joined
[03:44] *** xabbu42 left
[03:44] *** xabbu42_ is now known as xabbu42

[03:44] <Visitor99> hi again....

[03:45] <Visitor99> is there such thing as a "Duration"  datatype? (related to time)

[03:45] <sorear> yes

[03:45] <sorear> it's even called that

[03:47] <Visitor99> is there a synopse about that? i was looking at s32 and Instant is mentioned there

[03:47] <Visitor99> but no 'Duration'

[03:48] <pmichaud> Visitor99: Synopsis 2

[03:48] <Visitor99> thanks pmichaud!

[03:48] *** hercynium joined
[03:48] <pugssvn> r31308 | sorear++ | [dfa/Cursor] Cache results of decision trees for a 1.43% instruction count reduction 

[03:49] *** snarkyboojum left
[03:55] *** skids left
[03:56] *** macdaddy left
[04:07] *** snarkyboojum joined
[04:07] *** kda left
[04:07] *** kda joined
[04:10] *** Visitor99 left
[04:14] <dukeleto> How does one turn a Rakudo data structure into a Parrot data structure ?

[04:15] * dukeleto has Perl 6 running on PL/Parrot, and is now trying to data marshall

[04:15] <dukeleto> Rakudo Perl 6 on PL/Parrot, that is.

[04:24] *** mikehh left
[04:25] <pmichaud> dukeleto++

[04:25] <dukeleto> pmichaud: thanks. it is still rough, but is looking promising

[04:26] <dukeleto> Parrot_PMC_get_integer seems to just return 0 on any Rakudo integer

[04:26] * dukeleto is mostly sure about that, but will verify

[04:26] <pmichaud> it's possible, although I'd find it odd.

[04:27] <pmichaud> actually, I'm pretty sure that can't be the case, or a lot of other code would break.

[04:27] <dukeleto> pmichaud: if you think it should work, then I probably have a bug somewhere in my code, which gives me hope :)

[04:28] <pmichaud> I'm pretty sure it works at least part of the time.

[04:28] <pmichaud> otherwise arrays wouldn't index properly.

[04:28] <pmichaud> (which definitely use Rakudo Ints for the indexes)

[04:29] *** mikehh joined
[04:30] <dukeleto> pmichaud: i am using the Parrot embed interface from C, could that be part of it? Rakudo goes thru NQP->PIR, right?

[04:31] <pmichaud> it could.  Yes, when Rakudo is running it's all PIR, dynops, and dynpmcs.

[04:31] <pmichaud> there aren't any special C libraries or anything we use.

[04:31] <pmichaud> oops, I'm wrong -- we do have a special binder library... but that shouldn't affect this at all.

[04:33] *** pronik`` joined
[04:36] *** pronik``` joined
[04:36] *** pronik` left
[04:37] <dukeleto> pmichaud: i will dig deeper and try to figure out exactly what is not working. And write more tests....

[04:38] *** pronik`` left
[04:48] *** Superjane joined
[04:48] <Superjane> hi

[04:51] *** agentzh joined
[04:58] *** xomas_ left
[05:00] *** ewilhelm left
[05:00] *** ewilhelm joined
[05:00] *** sunnavy left
[05:01] *** sunnavy joined
[05:07] *** yinyin left
[05:08] <pmichaud> down to 9 failing tests.

[05:08] <PerlJam> pmichaud: good morrow  :)

[05:08] <pmichaud> at least I think it's 9, the "make test" output is awfully noisy.

[05:10] *** yinyin joined
[05:12] *** kaare joined
[05:12] *** kaare is now known as Guest94288

[05:12] <dukeleto> Superjane: good $localtime

[05:13] *** \shade\ left
[05:13] *** pronik``` left
[05:15] * sorear has figued out how to implement *general* cursor reuse

[05:15] <sorear> for all tweaks, not just add_categorical ones

[05:15] <sorear> *lexer reuse

[05:17] <PerlJam> sorear++

[05:18] <PerlJam> (I have no idea what that really /means/, but sorear++ nonetheless :-)

[05:18] <pmichaud> it's pretty important

[05:18] * snarkyboojum agrees with PerlJam

[05:18] <pmichaud> I'm eager to hear how it's done (when my brain will be able to take it)

[05:18] <pmichaud> (which isn't now)

[05:19] <PerlJam> sorear: could you explain it to me?  (maybe even tell how it's done and pmichaud can backlog when he's able)

[05:20] <pmichaud> 7 tests.

[05:21] * dukeleto would be interested to hear as well

[05:23] *** xabbu42_ joined
[05:23] *** xabbu42 left
[05:23] *** xabbu42_ is now known as xabbu42

[05:25] <snarkyboojum> pmichaud++ # pretty heroic effort :)

[05:26] <dukeleto> rakudo: sub r { 42 }; r()

[05:26] <p6eval> rakudo c9ee2e:  ( no output )

[05:26] <dukeleto> what is wrong with that?

[05:26] <snarkyboojum> prints 42 in the REPL

[05:27] *** ab5tract left
[05:27] <dukeleto> snarkyboojum: yep

[05:27] <dukeleto> snarkyboojum: that is what is tripping me up

[05:27] *** ab5tract joined
[05:27] <sorear> the crucial point is that the lexer cache needs to be keyed off Regex.WHICH, not name

[05:27] <snarkyboojum> which is right no?

[05:27] <sorear> once that's done it fell into place quickly

[05:27] <dukeleto> perl6: sub r { 42 }; r()

[05:27] <p6eval> elf 31308, pugs, rakudo c9ee2e:  ( no output )

[05:27] <sorear> I'll make this clearer with code in a little bit

[05:28] <PerlJam> At a guess I'd say that "lexer reuse" sounds like an optimization whereby each time we switch languages (perl, regex, quoted strings, whatever) rather than creating a new lexer each time, we use one we've already built.

[05:28] <snarkyboojum> rakudo: sub r { 42 }; say r()

[05:28] <p6eval> rakudo c9ee2e: OUTPUT«42␤»

[05:28] <dukeleto> std: sub r { 42 }; r()

[05:28] <p6eval> std 31308: OUTPUT«ok 00:01 107m␤»

[05:29] <snarkyboojum> dukeleto: REPL autoprinting vs commandline not printing anything?

[05:29] <dukeleto> snarkyboojum: could be. how would I "return" r() instead of printing it ?

[05:30] <dukeleto> snarkyboojum: i am running that Perl 6 code from the Parrot embed API, and it is not returning a value

[05:30] <sorear> PerlJam: sort of.  That's actually the easiest case, and one STD has supported for ages

[05:31] <snarkyboojum> dukeleto: oic - I'm not familiar with the parrot embed api

[05:31] *** shade__ joined
[05:31] <PerlJam> sorear: like I said ... I don't know what it really means :)

[05:31] <sorear> PerlJam: STD generates new languages at runtime - Q:foo, :foo is actually a mixin applied to the quote language

[05:31] <sorear> lexer reuse allows us to keep much of the lexer work even when small changes are made to the language

[05:32] <ash__> dukeleto: &r will let you access the sub r as a variable

[05:32] <ash__> rakudo: sub foo { 'foo called' }; my $a = &foo; say $a();

[05:32] <p6eval> rakudo c9ee2e: OUTPUT«foo called␤»

[05:32] <pmichaud> ooooh

[05:32] <PerlJam> sorear: sort of like inheritance in oop-land

[05:32] <pmichaud> yes, that sounds somewhat similar to what nqp is doing for its token caches

[05:33] <pmichaud> it's essentially tied to the grammar.  although you said Regex.WHICH above... I'd have to think about that one a bit.

[05:33] <pmichaud> oh, wait, I get it.  Nice.

[05:33] <pmichaud> sorear++ sorear++

[05:33] <sorear> nqp doesn't really support creating new grammars at run time, though

[05:34] <pmichaud> well, not yet.  :-)

[05:34] <dukeleto> snarkyboojum: well, it would basically the same as wanting to eval that code and wanting the return value

[05:34] <pmichaud> it *does* support creating new grammars at runtime -- it's called "inheritance".  As far as the engine is concerned, there's not much difference.  :)

[05:35] <pmichaud> but yes, for the types of changes that would be needed for a true P6 STD model, it's a little primitive at the moment.

[05:35] <pmichaud> (like some of the early versions of STD before the optimizations)

[05:35] <pmichaud> 3 tests.

[05:36] *** Mowah joined
[05:36] <PerlJam> pmichaud: at this hour that sounds like a countdown to sleep :)

[05:36] <pmichaud> maybe, but not likely.

[05:37] <ash__> rakudo: my $a = eval "-> { return 1 + 2 }"; say $a(); # am i wrong assuming this should return a closure? The eval that is 

[05:37] *** orafu left
[05:37] <p6eval> rakudo c9ee2e:  ( no output )

[05:37] *** orafu joined
[05:37] <pmichaud> Within the last six hours I've finally figured out how to clean up most of rakudo's variable handling, so that we get autovivification to work, eliminate the Proxy class, throw out a bunch of obsolete/convoluted code, etc.

[05:37] <pmichaud> oh, and binding.  :-)

[05:37] <PerlJam> rakudo: my $a = eval "-> { return 1 + 2 }"; say $a.WHAT;

[05:37] <p6eval> rakudo c9ee2e:  ( no output )

[05:37] <dukeleto> ash__: that sounds similar to my issue

[05:38] *** shade__ left
[05:38] <pmichaud> shouldn't be a 'return' in a pointy block.

[05:38] <pmichaud> so it's generating an exception, which the eval is catching.

[05:38] <PerlJam> rakudo: my $a = eval "-> { leave 1 + 2 }"; say $a.WHAT;

[05:38] <pmichaud> rakudo:  my $a = eval "-> { 1 + 2 }"; say $a();

[05:38] <p6eval> rakudo c9ee2e: OUTPUT«Could not find sub &leave␤  in main program body at line 11:/tmp/nmapR6o9wi␤»

[05:38] <p6eval> rakudo c9ee2e: OUTPUT«invoke() not implemented in class 'Seq'␤  in main program body at line 11:/tmp/SQ3FPBT1KZ␤»

[05:39] <pmichaud> rakudo:  my $a = eval "-> { 1 + 2 }"; say $a.WHAT;

[05:39] <p6eval> rakudo c9ee2e: OUTPUT«Seq()␤»

[05:39] <pmichaud> huh

[05:39] <pmichaud> that's... weird.

[05:39] <pmichaud> rakudo:  say (eval "-> { 1+2 }").WHAT

[05:39] <p6eval> rakudo c9ee2e: OUTPUT«Parcel()␤»

[05:39] <pmichaud> looks like a parcel fail

[05:40] <pmichaud> don't know why eval wants to return a Parcel there.

[05:40] *** ewilhelm left
[05:40] *** ewilhelm joined
[05:40] <PerlJam> looks like there's an unwritten test or two there :)

[05:40] <pmichaud> 1 test.

[05:40] *** ewilhelm left
[05:40] <pmichaud> ...that I think I'm simply going to mark as "skip" or "todo"  :-)

[05:41] <ash__> rakudo: sub foo { 1 + 3 }; my $a = eval "&foo"; say $a(); # it evals fine in this form, is it something specific to pointy blocks? 

[05:41] <pmichaud> okay, let's see what happens if I merge to master.

[05:41] <p6eval> rakudo c9ee2e: OUTPUT«4␤»

[05:42] <pmichaud> rakudo:  my $a = "eval sub { 1 + 3 }";  say $a.WHAT;

[05:42] <p6eval> rakudo c9ee2e: OUTPUT«Str()␤»

[05:42] <pmichaud> er

[05:42] <pmichaud> rakudo:  my $a = eval "sub { 1 + 3 }";  say $a.WHAT;

[05:42] <p6eval> rakudo c9ee2e: OUTPUT«Seq()␤»

[05:42] <ash__> (i tried that)

[05:42] <pmichaud> ohhhh!

[05:42] <pmichaud> I know what the problem is.

[05:42] <pmichaud> Evil.

[05:42] <PerlJam> need a ; in front?

[05:42] <pmichaud> no.

[05:42] *** rhr left
[05:43] * PerlJam was guessing at some weird misparse

[05:43] <pmichaud> In Parrot, whenever you dynamically compile some code using the PIR compiler, you get back something called an Eval PMC

[05:43] <pmichaud> it's basically an array of the subs that were in the PIR source

[05:43] <pugssvn> r31309 | sorear++ | [dfa/Cursor] Lexer caches need to be keyed on lexer identity, not lexer name.  +0.25% ops 

[05:44] <pmichaud> oh, hmm, that doesn't quite follow, I guess

[05:44] <pmichaud> I was going to say that the eval() ends up returning the Eval PMC, which then gets treated as a Parcel containing the compiled sub.

[05:44] <sorear> http://search.cpan.org/~sorear/Devel-CountOps-0.01/

[05:44] <pmichaud> but that's not it.

[05:44] <sorear> so much for "this doesn't seem to exist"

[05:44] <ash__> dukeleto: with embedded parrot does it execute each statement in an Eval PMC?

[05:45] <pmichaud> okay, time to try a merge with master and see what happens....

[05:45] <pmichaud> no merge conflicts.

[05:45] <pmichaud> compiling...

[05:46] *** xabbu42_ joined
[05:46] *** xabbu42 left
[05:46] *** xabbu42_ is now known as xabbu42

[05:49] <pmichaud> spectesting...

[05:49] <dukeleto> ash__: 'compile' returns an Eval PMC

[05:49] <pmichaud> dukeleto: yes, but Rakudo's eval is supposed to then invoke the Eval PMC and return that result

[05:50] <pmichaud> so something else is happening there.

[05:50] <pmichaud> rakudo:  my $a = eval "sub { 1 + 3 }";  say $a.perl;

[05:50] <p6eval> rakudo c9ee2e: OUTPUT«()␤»

[05:50] <pmichaud> yeah, it's just ending up with Nil.

[05:51] <pmichaud> rakudo:  my $a = eval "(-> { 1 + 3 })";  say $a.perl;

[05:51] <p6eval> rakudo c9ee2e: OUTPUT«()␤»

[05:51] <pmichaud> rakudo:  my $a = eval "(-> { 1 + 3 })()";  say $a.perl;

[05:51] <p6eval> rakudo c9ee2e: OUTPUT«()␤»

[05:51] <pmichaud> ohhhh!

[05:51] <pmichaud> duh!

[05:51] <pmichaud> I know what the problem is!  I know what the problem is!

[05:51] <sorear> Excellent!

[05:52] <pmichaud> rakudo:  my $a = eval '-> { 1 + 3 }';  say $a();

[05:52] <p6eval> rakudo c9ee2e: OUTPUT«4␤»

[05:52] <pmichaud> WIN

[05:52] <PerlJam> ha

[05:52] <PerlJam> interpolation

[05:52] *** yinyin left
[05:52] <ash__> doh 

[05:52] <PerlJam> pmichaud++

[05:52] <ash__> well never mind then 

[05:52] *** yinyin joined
[05:53] <pmichaud> we do need to get it so that eval returns any exception into the result value

[05:53] *** xabbu42_ joined
[05:53] *** xabbu42 left
[05:53] *** xabbu42_ is now known as xabbu42

[05:53] <pmichaud> that shouldn't be hard... just call the &fail equivalent.

[05:55] *** shade__ joined
[05:56] <dalek> book: 61514b0 | duff++ | src/r (2 files):

[05:56] <dalek> book: [regex] lexicalize free-standing regex

[05:56] <dalek> book: review: http://github.com/perl6/book/commit/61514b0c808bea18b243ab2f4341c9aa40460058

[05:56] *** dalek left
[05:57] *** dalek joined
[05:57] *** Mowah left
[06:11] *** yinyin left
[06:12] *** yinyin joined
[06:14] <dukeleto> what does "No exception handler and no message" actually mean?

[06:15] <pmichaud> it means an exception was generated and thrown and there was no handler available to catch it.

[06:16] <ciphertext> rakudo: (1,2,3 Z 4,5,6).perl.say

[06:16] <p6eval> rakudo c9ee2e: OUTPUT«(1, 4, 2, 5, 3, 6)␤»

[06:17] <ciphertext> rakudo: (1,2,3 Z[,] 4,5,6).perl.say

[06:17] <p6eval> rakudo c9ee2e: OUTPUT«(1, 4, 2, 5, 3, 6)␤»

[06:17] <pmichaud> > (1,2,3 Z[,] 4,5,6).perl.say

[06:17] <pmichaud> ((1, 4), (2, 5), (3, 6))

[06:17] <pmichaud> (in the new branch)

[06:17] <dukeleto> pmichaud: how do I install an exception handler (or where do I read about that?) in Rakudo

[06:18] <pmichaud> ...in Rakudo?  That would be CATCH { ... }   or   try { ... }

[06:18] <dukeleto> pmichaud++

[06:18] <pmichaud> okay, all tests pass (I think)

[06:18] <pmichaud> so.... prepare for commit flood.

[06:19] <pmichaud> list branch merged to master.

[06:19] *** [Coke] left
[06:19] <ciphertext> pmichaud: that's what i'm getting, but the spec says that Z should be an alias for Z[,]

[06:19] <ciphertext> "The Z, operator is perhaps more clearly written as Z[,]. However, this list form is common enough to have a shortcut, the ordinary infix Z operator described earlier."

[06:20] <pmichaud> sounds like a rakudo bug to me then.

[06:20] <ciphertext> k.

[06:20] <ciphertext> that's what i thought.

[06:20] <ciphertext> (i was just checking whether it was something i had done locally)

[06:21] <dalek> rakudo: ddb39d0 | (Solomon Foster)++ | t/spectest.data:

[06:21] <dalek> rakudo: Regress range-iterator.t, because it conforms to the now-obsolete former 

[06:21] <dalek> rakudo: iterator model.

[06:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ddb39d064c6e334f4d08addd30e4c02b00c20296

[06:21] <dalek> rakudo: 6b2af44 | moritz++ | src/core/MAIN.pm:

[06:21] *** dalek left
[06:22] <moritz_> is this the list merge?

[06:22] * moritz_ just got up

[06:22] *** dalek joined
[06:22] <pmichaud> it is.

[06:22] <moritz_> \o/

[06:24] <snarkyboojum> wowsers, that's a serious merge :)

[06:24] <pmichaud> 154 commits.

[06:24] <pugssvn> r31310 | pmichaud++ | [t/spec] Fudge some tests for later review as part of Rakudo's list branch merge. 

[06:24] <pmichaud> only one (very minor) merge conflict.  :)

[06:25] *** Su-Shee joined
[06:25] <moritz_> nqp: sub f($x) { 3 }; say(&f)

[06:25] <p6eval> nqp: OUTPUT«Symbol '&f' not predeclared in <anonymous>␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:109)␤»

[06:26] <pmichaud> nqp doesn't automatically prepend subs with &'s

[06:26] <pmichaud> but you can put them there.

[06:26] <moritz_> which is not Perl 6

[06:26] <pmichaud> nqp:  sub &f($x) { 3 };  say(&f);

[06:26] <p6eval> nqp: OUTPUT«&f␤»

[06:26] <moritz_> can you refer to subs by name withou using &f in the name?

[06:26] <pmichaud> nqp doesn't do any automatic adding or removal of &'s

[06:27] <moritz_> I told tcurtis that the 'sub &f' thing was an nqp oddity and not Perl 6, best to be avoided

[06:27] <pmichaud> wfm

[06:28] <pmichaud> it's one of those known deviations because otherwise nqp doesn't provide a clean way to get at parrot subs that don't have the &'s

[06:28] <pmichaud> or to produce parrot subs that don't have &'s

[06:28] *** synth left
[06:28] <pmichaud> and other HLLs might really want to do that.

[06:30] <pmichaud> well, if others can run spectests and double-check my results, that'd be great.

[06:30] <pmichaud> I'll start updating spectest-progress now.

[06:31] <moritz_> I'm spectesting now on list pre-merge

[06:31] <Tene> I'm spectesting right now.  I spectested master earlier today.

[06:31] <pmichaud> okay, I fixed rotate.t post-merge.

[06:31] <moritz_> Your branch is behind 'origin/master' by 155 commits, and can be fast-forwarded.

[06:31] <moritz_> epic.

[06:31] <pmichaud> it was a huge amount of work, yes.

[06:32] <pmichaud> I'm sooooo glad we had git and not svn.

[06:32] <pmichaud> and I have a bunch more improvements I can add shortly now to fix a whole slew of long-standing bugs (some of which are on the ROADMAP), but I'll wait until after release to try to bring those in.

[06:33] <pmichaud> after I get a little sleep, my plan is bug stomping, ticket wrangling, and blog posting.

[06:33] <moritz_> pmichaud: you accidentally merged the commenting out of some spectests

[06:33] <pmichaud> oh

[06:33] <moritz_> pmichaud: S03-metaops/{reduce,zip}.t

[06:33] <pmichaud> I didn't realize they had been commented out.

[06:33] <Tene> I'm up into S11

[06:33] <moritz_> S03-operators/series*.t

[06:33] <Tene> Yeah, we definitely need to include *some* bugs in the release.

[06:33] <moritz_> that were the tests that used .batch

[06:34] <pmichaud> I suspect many of them will "just pass"

[06:34] <pmichaud> I'll try them quickly.

[06:36] <sorear> don't we have an automatic defuzzer script?

[06:36] <szabgab> some spec-test are failing for me

[06:36] <szabgab> anything I can do ?

[06:36] <szabgab> t/spec/S03-operators/assign.rakudo ............................. Failed 1/240 subtests

[06:36] <szabgab> t/spec/S03-operators/range-basic.rakudo ........................ Dubious, test returned 1 (wstat 256, 0x100)

[06:36] <pmichaud> szabgab: you might need to svn up t/spec

[06:37] <szabgab> I just did it

[06:37] <szabgab> about 1 min ago

[06:37] <pmichaud> okay, looking

[06:37] <szabgab> to 31310

[06:39] <pmichaud> oh, I need to put error reporting back in.

[06:40] <pmichaud> pushed.

[06:42] <Tene> pmichaud: http://gist.github.com/441765

[06:43] <pmichaud> Tene++  # thanks

[06:43] <Tene> updated with pre-merge spectest output

[06:43] * pmichaud likes seeing all of those passing TODOs

[06:43] <pmichaud> there are also a bunch of passing skips that we can start looking for as well :)

[06:44] *** Zapelius joined
[06:44] <Tene> are you working on removing the TODO markers, or should I do that?

[06:44] <pmichaud> I'm not doing that now, no.

[06:44] <dalek> rakudo: cca4a84 | pmichaud++ | src/Perl6/Compiler.pir:

[06:44] <dalek> rakudo: Restore backtrace handling.

[06:44] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cca4a8411258baacbac7a540bc6e7e0c1bf88246

[06:44] <pmichaud> (so yes, please feel free)

[06:46] <pmichaud> right now I'm mainly taking deep breaths and saying "wow, that was a lot."

[06:50] <pmichaud>     @x = 2, 3, 4;

[06:50] <pmichaud>     is @x.pop, 4, 'can pop from typed array';

[06:50] <pmichaud>     is @x.unshift(2), [2, 2, 3], 'can unshift from typed array';

[06:50] <pmichaud> ...doesn't that last test look wrong?

[06:50] <pmichaud> oh, I guess not

[06:51] <pmichaud> missed the .pop

[06:56] <pmichaud> anyway, I'm getting a bit sleepy here so I'll take a short break.  Feel free to clean up spectests as appropriate.

[06:56] <pugssvn> r31311 | tene++ | Remove a few rakudo skip and todo markers 

[06:58] <pmichaud> bbiaw

[06:58] *** yinyin left
[06:58] * sorear has gotten general reuse to work, but something is slowing it down an unexpected amount and it's not being a net win

[06:59] <pugssvn> r31312 | tene++ | remove a rakudo todo marker 

[06:59] *** yinyin joined
[07:01] <moritz_> pmichaud: t/spec/S03-metaops/reduce.t fails one test

[07:01] <moritz_> I'll just put it in anyway; it's a regression

[07:01] <moritz_> maybe I'll investigate later

[07:02] <pmichaud> yes... given the number of other things this branch fixes, I'm not too worried about a small number of regressions :)

[07:03] <sorear> are we passed alpha yety?

[07:04] <moritz_> in what terms?

[07:06] <sorear> #tests passing

[07:07] <moritz_> yes, for a few weeks

[07:09] <moritz_> t/spec/S09-typed-arrays/arrays.rakudo fails here

[07:09] <dalek> rakudo: a5f844b | moritz++ | t/spectest.data:

[07:09] <dalek> rakudo: enable quite a few passing test files (some of them were regressions of the list 

[07:09] <dalek> rakudo: branch, but most not)

[07:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a5f844b1b634d66b27069ed6fe34777067fcbb91

[07:09] *** cono left
[07:09] <moritz_> get_pmc_keyed() not implemented in class ''

[07:09] <moritz_> after test 7

[07:09] <moritz_> afk

[07:13] *** xabbu42 left
[07:13] *** xabbu42_ joined
[07:14] <pugssvn> r31313 | tene++ | Remove more rakudo skip and todo markers 

[07:14] *** cono joined
[07:17] <Tene> Yeah, I know, I don't need to commit this often. :P

[07:17] <pugssvn> r31314 | tene++ | Remove another rakudo todo marker 

[07:17] *** yinyin left
[07:26] <mathw> Morning

[07:26] *** plobsing left
[07:28] <pugssvn> r31315 | tene++ | Remove more rakudo todo markers 

[07:29] *** kensanata joined
[07:31] <snarkyboojum> rakudo: <a>.rotate

[07:31] <p6eval> rakudo e3eb60: OUTPUT«Method 'rotate' not found for invocant of class 'Str'␤current instr.: '_block14' pc 148 (EVAL_1:66) (/tmp/lJbMXDQajh:11)␤»

[07:31] <snarkyboojum> rakudo: <a b>.rotate

[07:31] <p6eval> rakudo e3eb60: OUTPUT«Method 'rotate' not found for invocant of class 'Parcel'␤current instr.: '_block14' pc 154 (EVAL_1:65) (/tmp/1CUBFnQhg9:11)␤»

[07:31] <pmichaud> needs to be added to Cool, probably.

[07:32] <pmichaud> see the pattern used for .join and .sort

[07:32] <snarkyboojum> Cool :)

[07:35] <pugssvn> r31316 | tene++ | Remove two more rakudo todo markers 

[07:40] <pmichaud> or Any-list.pm, come ot think of it.

[07:41] <snarkyboojum> adding it to Parcel.pm like this works too http://gist.github.com/441809

[07:42] <pugssvn> r31317 | tene++ | Remove more rakudo todo markers 

[07:43] <pmichaud> putting it in Parcel is too far down the chain.

[07:43] *** xabbu42_ left
[07:43] *** xabbu42 joined
[07:43] <pmichaud> since Parcel is ~~ Any, it would go better there.

[07:43] <snarkyboojum> it's in List.pm too isn't it

[07:43] <pmichaud> List.pm is where it's actually implemented

[07:43] <pmichaud> Any should forward to list

[07:43] <snarkyboojum> ah ok :)

[07:44] *** pronik``` joined
[07:48] *** dual left
[07:50] *** xabbu42_ joined
[07:50] *** xabbu42 left
[07:50] *** xabbu42_ is now known as xabbu42

[07:50] *** shade__ left
[07:53] *** shade__ joined
[07:53] *** dual joined
[07:55] <pugssvn> r31318 | tene++ | Remove more rakudo todo markers 

[07:56] <pugssvn> r31319 | tene++ | Remove todo markers for "fails intermittently" added two months ago.  I could not reproduce, but if it still fails intermittently, we can re-fudge. 

[07:57] <pugssvn> r31320 | sorear++ | [dfa/Cursor] Implement lexer reuse.  Something is not quite right; it's definitely reusing lexers but the performance increase is underwhelming 

[07:58] <pugssvn> r31321 | tene++ | Remove another rakudo todo marker 

[07:59] <szabgab> how can I run a specific spectest in verbose mode so I'll see the details of the failure?

[07:59] <pmichaud> make t/spec/S02-whatever/test.t

[08:00] <pmichaud> (with apologies to TimToady++)

[08:01] <szabgab> so not the .rakudo ?

[08:01] <pmichaud> .t

[08:01] <phenny> Thu, 17 Jun 2010 08:01:30 GMT

[08:03] <moritz_> pmichaud: do you also get a failure in t/spec/S09-typed-arrays/arrays.rakudo?

[08:03] <pmichaud> Yes.

[08:03] <szabgab> I got weird test failurse after I added a call to die() in the need method of src/Perl6/Module/Loader.pm  , well just playing to see if I make an impact at all with my changes, now let's try with a real change...

[08:04] *** [Coke] joined
[08:06] *** pnate left
[08:06] *** pnate joined
[08:08] <pmichaud> moritz_: I think I have an idea on the typed-arrays error, but will have to wait until morning to fix it.

[08:08] * Tene spectesting again, will post shortly.

[08:08] <pmichaud> it has to do with how arrays are initialized

[08:08] <moritz_> pmichaud: should we wait with the rakudo release so long?

[08:08] <moritz_> erm, s/we/masak/

[08:09] <pmichaud> masak said he was going to release around 2000 utc

[08:09] <moritz_> ok

[08:09] <pmichaud> so I think I'll have it in place before the release w/o any difficulty

[08:09] <moritz_> great

[08:09] <pmichaud> are typed arrays going to generally be a blocker?

[08:09] <pmichaud> I mean, although I think they've not caused problems, we haven't had actual type checking since alpha

[08:10] <pmichaud> (but I know how to fix that now, will do that shortly after release... :-)

[08:10] <pmichaud> anyway, I need sleep.  bbiaw

[08:11] <moritz_> sleep well

[08:11] <snarkyboojum> is that a more appropriate way to fix rotate for parcels then http://gist.github.com/441829?

[08:11] <pmichaud> I'd add "multi"

[08:11] <pmichaud> other than that, looks great.

[08:12] <pmichaud> I'd probably also use "is export" instead of the separate proto

[08:12] <pmichaud> unless there's a big reason for the proto

[08:12] <pmichaud> (really gone now)

[08:12] <moritz_> named arguments

[08:12] <snarkyboojum> I just did it to follow suit with other methods, but would have used the is export.. will give that a whirl ;)

[08:13] <moritz_> rotate :array[1, 2, 3]  only works with a proto

[08:13] *** ajs left
[08:14] <snarkyboojum> moritz_: ok that works with that current change

[08:15] <pugssvn> r31322 | sorear++ | [dfa/Cursor] Combine two separate (and separately cached) protoregex scanner loops.  -0.8% ops 

[08:15] <snarkyboojum> moritz_: potential patch then? http://gist.github.com/441834 (if keeping proto is appropriate)

[08:15] <Tene> http://gist.github.com/441765 -- updated spectest results

[08:16] <Tene> if anyone else wants to pick up un-fudging

[08:16] *** xabbu42_ joined
[08:16] *** xabbu42 left
[08:16] *** xabbu42_ is now known as xabbu42

[08:16] <Tene> afk, sleep.

[08:16] *** masak joined
[08:18] <moritz_> snarkyboojum: thanks, pushed

[08:18] <masak> o/, #perl6

[08:18] <phenny> masak: 16 Jun 21:17Z <pmichaud> tell masak  it's official, tomorrow's release is "Kiev"

[08:18] <dalek> rakudo: 012ea2b | snarkyboojum++ | src/core/Any-list.pm:

[08:18] <dalek> rakudo: Get rotate working for Parcel again

[08:18] <dalek> rakudo: Signed-off-by: Moritz Lenz [email@hidden.address]
[08:18] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/012ea2baaa27ecf0c074bde369e40a9915e867cc

[08:18] <masak> \Kiev/

[08:19] *** pronik``` left
[08:19] <mathw> o/ masak

[08:20] <snarkyboojum> moritz_: thanks!

[08:22] <moritz_> snarkyboojum: thank you for yoru patch

[08:26] <sorear> tryfile STD.pm6 in 2:26

[08:26] <sorear> 1-1.5 minutes faster than trunk

[08:26] *** thebird joined
[08:27] <moritz_> \o/

[08:27] <pugssvn> r31323 | sorear++ | [dfa/Cursor] Gut the old RE-based LTM entirely 

[08:28] <pugssvn> r31324 | moritz++ | [t/spec] unfudges for rakudo 

[08:31] <masak> most likely not R* priority, but eventually I would like Rakudo (and the spec) to address all the points in this post: http://blog.ksplice.com/2010/05/top-10-perl-one-liner-tricks/

[08:32] <pugssvn> r31325 | moritz++ | [t/spec] another small rakudo unfudge 

[08:33] *** cono left
[08:33] *** cono joined
[08:35] *** xabbu42_ joined
[08:35] *** xabbu42 left
[08:35] *** xabbu42_ is now known as xabbu42

[08:37] *** JimmyZ joined
[08:37] <JimmyZ> Test Summary Report on Windows XP. http://gist.github.com/441854

[08:38] <sorear> masak: 4,7,8,9 are core Perl 6 features and have better syntax

[08:38] <sorear> 10 is a SMOP

[08:38] <sorear> the rest are vaguely thought of under the concept of "settings

[08:38] <sorear> "

[08:38] <masak> thing is, they need to be relatively easy.

[08:38] <moritz_> #1 too

[08:38] <moritz_> autochomping is default

[08:38] <masak> that's the beauty of -n and -p. they're right there.

[08:39] <sorear> 4,7,8,9 are relatively easy

[08:39] <sorear> no harder than perl5

[08:39] <sorear> #10 will be much easier with named regex syntax

[08:39] <masak> I still don't really know how one'd write `perl -ne 'print if /start/../stop/'` in Perl 6.

[08:39] <jnthn> good morning, #perl6

[08:39] <masak> jnthn: morning!

[08:39] <sorear> perl6 -ne '.say if /start/ ff /stop/'

[08:40] <moritz_> sorear: close. perl6 -n -e

[08:40] <masak> moritz_: what, why?

[08:40] <moritz_> only boolean single-letter args may be clustered

[08:40] <moritz_> according to current spec

[08:40] <sorear> you're upending thirty years of tradition...why?

[08:40] <masak> exactly.

[08:40] *** dakkar joined
[08:41] <moritz_> not me

[08:41] <masak> I think that rule should be loosened up.

[08:41] <moritz_> [particle]'s decision, iirc

[08:41] <masak> boolean single-letter flags can have other single letter flags following them, or something like that.

[08:41] <masak> that would allow -ne and -lne and similar.

[08:41] <moritz_> would work for me

[08:42] <jnthn> list branch merged!! :-D

[08:42] <jnthn> pmichaud++

[08:42] <moritz_> aye

[08:42] <moritz_> there's some fallout though

[08:42] <jnthn> And (all others who worked on it)++

[08:42] <jnthn> moritz_: How much?

[08:42] <masak> pmichaud++

[08:42] <moritz_> jnthn: http://gist.github.com/441854

[08:43] <colomon> yow

[08:43] <jnthn> moritz_: Is that from Win32?

[08:43] <moritz_> jnthn: yes ( JimmyZ nopasted it earlier)

[08:44] <pmichaud> yeah, I'm not quite sure what happened there.  all of the spectests were passing on my box.

[08:44] <jnthn> They failed in master on Win32 before anyway :-(

[08:45] <sorear> parrot version stuff?

[08:45] <moritz_> callframe.t also failes here

[08:45] <pmichaud> oh

[08:45] <jnthn> Something is not quite right with the cases where we shell out

[08:45] <jnthn> And run another Rakudo proccess

[08:45] <jnthn> I thnk

[08:45] <jnthn> *think

[08:45] <pmichaud> then that would be why... I was just trying to match whatever tests master was running.

[08:45] <jnthn> pmichaud: Yeah

[08:45] <jnthn> pmichaud: I keep meaning to look at that.

[08:45] <pmichaud> I suspect a linux person re-enabled some tests that otherwise fail on win32

[08:45] <jnthn> We also segfault on Win32 on t\spec\S05-capture\subrule.rakudo   

[08:46] <jnthn> pmichaud: It's fine, though a bit noisy for me, but it'll eventually irk me enough to track it down. :-)

[08:46] <jnthn> On caught the segfault in the debugger but it was actually a (C-level) stack overflow in the GC.

[08:46] <pmichaud> well, I'm fine with the group adjusting the spectests however it's decided best

[08:47] <jnthn> I'd suggest not adjusting them for Win32-specific issues.

[08:47] <jnthn> It's just some platform lag. 

[08:47] <jnthn> I caught a little of it a while back when I fixed chomp, but there's a tad more to go.

[08:48] <jnthn> (I think one underlying issue is to blame for most of them.)

[08:48] <pmichaud> okay.  I just think we may get a lot of faq from win32 people who say "the tests don't pass"

[08:48] <pmichaud> in that sense I'd rather todo them than leave them failing, I think.

[08:49] <pugssvn> r31326 | sorear++ | [STD-ecosystem] Merge back dfa branch of Cursor, rebootstrap, and remove all references to lex from the makefile. 

[08:49] <jnthn> pmichaud: Heh, then we'll get a lot of "there's TODO passes" ;-)

[08:49] <pmichaud> sure, but we can put a note that says  "fails on Win32"

[08:49] <jnthn> pmichaud: srsly though, I'll try and give it some tuits at the weekend.

[08:49] *** Superjane left
[08:49] <pmichaud> wfm

[08:49] * jnthn is mini-hackathoning with mberends++ this weekend.

[08:50] <sorear> speaking of tuits, STD is now 25% faster

[08:50] <jnthn> Today though, I really need to give $dayjob some attention.

[08:50] <jnthn> sorear: Nice!

[08:50] <sorear> from the LTM rewrite

[08:50] <sorear> and I've killed the on-disk lexer cache with fire; lexer generation is now sufficiently lazy that short files aren't killed by a cold start

[08:51] <pmichaud> btw, in my local repo:

[08:51] <pmichaud> > my Int @a = 1, 2, 3, 'x', 7

[08:51] <pmichaud> Unable to store value of type Str in list of Int

[08:51] <moritz_> \o/

[08:51] <sorear> the only thing that STD writes to disk now is precompiled modules

[08:52] <pmichaud> jnthn: while working on the list branch tonight I totally figured out how to fix assignment, scalars, proxys, vivification, and binding

[08:54] <pmichaud> (but it's too big a refactor to try to fit in before the release, so I'm doing it afterwards)

[08:54] * moritz_ hopes it's not gone after sleep :-)

[08:54] <pmichaud> moritz_: I wrote it down :)

[08:54] <pmichaud> (actually I was writing to address a different problem, and then said "oh! Cool!")

[08:54] <jnthn> pmichaud: Nice!

[08:54] <masak> pmichaud: why 'list of Int' when it's an Array?

[08:55] <masak> pmichaud: what would it say if it were a Hash?

[08:55] <pmichaud> masak: I don't yet know how to get the invocant's type name

[08:55] <masak> ok.

[08:55] <moritz_> self.WHAT.perl ?

[08:55] <masak> :)

[08:55] <jnthn> Aye, that.

[08:55] <moritz_> (might be naiive though)

[08:55] <pmichaud> well, I was hoping for the names without the parens

[08:55] <jnthn> Possibly, yes.

[08:55] <pmichaud> so I was trying .WHO

[08:55] <jnthn> .perl strips 'em.

[08:55] <pmichaud> oh, .perl

[08:55] <pmichaud> yes

[08:55] <pmichaud> okay

[08:56] <jnthn> rakudo: say 42.WHAT; say 42.WHAT.perl;

[08:56] <p6eval> rakudo 012ea2: OUTPUT«Int()␤Int␤»

[08:56] <pmichaud> jnthn: In the process, the fix I have also means that with    my Int @a;   all of the elements of @a will start out as the Int type object :)

[08:57] <jnthn> pmichaud: That's nice.

[08:57] <moritz_> sounds like a ponie :-)

[08:57] <pmichaud> so:   my @a;  say @a[5].WHAT;  # Int()

[08:57] <dalek> csmeta: r334 | anteus4++ | trunk/doc/PerlesqueDocumentation.html:

[08:57] <dalek> csmeta: added more class related syntax and callable type

[08:57] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=334

[08:57] <jnthn> \o/

[09:00] <sorear> Who is anteus4?

[09:01] <pmichaud> maybe us3?  </obscure>

[09:01] <moritz_> jaffa4?

[09:02] <dalek> csmeta: r335 | anteus4++ | trunk/doc/PerlesqueDocumentation.html:

[09:02] <dalek> csmeta: changed subroutine syntax

[09:02] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=335

[09:02] <pmichaud> > my Int @a = 1, 2, 'x', 4;

[09:02] <pmichaud> Unable to store value of type Str in  of Int

[09:02] <pmichaud> (sigh)

[09:03] <pmichaud> yeah, can't get the type name of self

[09:03] <jnthn> Oh

[09:03] <moritz_> is that in a role?

[09:03] <moritz_> oh wait

[09:03] <jnthn> Yeah, because of the way we currently set up typed arrays. :/

[09:04] <pmichaud> anyway, easy to fix up a bit later :)

[09:04] <jnthn> *nod*

[09:04] <pmichaud> okay, let's see if _now_ I can get to sleep

[09:04] <pmichaud> bbiaw

[09:04] <szabgab> pmichaud, you were supposed to go to sleep:)

[09:04] <szabgab> a long time ago

[09:04] <pmichaud> szabgab: yes, but I keep thinking of cool things to try in the new implementation :)

[09:05] <szabgab> go now

[09:05] <jnthn> Sleep is overrated. :)

[09:05] <szabgab> and underrsupplied :)

[09:08] <masak> and strangely distributed :/

[09:10] <szabgab> rakudo: say <sleep hack eat code debug commit patch>.pick

[09:10] <p6eval> rakudo 012ea2: OUTPUT«sleep␤»

[09:10] <masak> \o/

[09:10] <hejki> rakudo: say <work work work work work work>.pick

[09:10] <p6eval> rakudo 012ea2: OUTPUT«work␤»

[09:10] <hejki> aww.. :<

[09:10] <masak> hejki: what did you expect? :P

[09:11] <hejki> masak: some savory side-effect to save me from working? :P

[09:11] <sorear> std: 2

[09:11] <p6eval> std 31325: OUTPUT«ok 00:01 107m␤»

[09:12] <moritz_> rakudo: say <hack work work work work>.pick

[09:12] <p6eval> rakudo 012ea2: OUTPUT«hack␤»

[09:12] <moritz_> \o/

[09:12] * moritz_ goes to fix callframe.t

[09:13] * masak suspects Rakudo is rigged out of self-preservation :P

[09:14] <hejki> moritz_: :))

[09:15] <masak> jnthn: can you put several parameters in the siggy in the [] of a role declaration?

[09:15] <moritz_> sure

[09:15] <moritz_> you can even do multi dispatch on them

[09:16] <szabgab> so in src/Perl6/Module/Loader.pm I am trying to make some small fix

[09:16] <masak> what does .of return in such a case?

[09:16] <jnthn> masak: It's a full Perl 6 signature in that case

[09:16] <szabgab> I am trying to use open()   but rakudo cannot find it

[09:16] <jnthn> masak: .of is just a method in Positional and Associative.

[09:16] <szabgab> I guess it is not exported yet or sg similar

[09:16] <jnthn> masak: It's not "automatic" in any sense.

[09:16] <masak> jnthn: oh, ok.

[09:16] <masak> that's fine, then.

[09:16] <szabgab> how can I use it then?

[09:16] <moritz_> rakudo: role A[$x, $y] { method x { say $x + $y } }; A[4, 5].new.x

[09:16] <p6eval> rakudo 012ea2: OUTPUT«No applicable candidates found to dispatch to for '_block52'. Available candidates are:␤:(Mu $x, Mu $y)␤␤  in main program body at line 1␤»

[09:17] <szabgab> IO.open() ?

[09:17] <jnthn> ...wtf?

[09:17] <moritz_> szabgab: the module loader is written in nqp, not Perl 6

[09:17] * masak submits rakudobug

[09:17] <moritz_> szabgab: so you need to resort to parrot tools

[09:17] <szabgab> moritz_, so does it mean I cannot use code from core yet ?

[09:17] <moritz_> right

[09:18] <szabgab> so I cannot do my planned refactoring then :(

[09:18] *** yinyin joined
[09:18] *** kensanata left
[09:18] <jnthn> szabgab: Ah, you wanted to change the use of pir::open in the module loader?

[09:19] <szabgab> yes

[09:19] <jnthn> I'd maybe rather that wasn't done, even were it possible.

[09:19] *** mberends joined
[09:19] <jnthn> Otherwise we can't "use" when compiling the setting.

[09:19] <jnthn> Which we may at some point want to do.

[09:19] <szabgab> ok, so something else then

[09:20] <szabgab> how can I find the implementation of things that are written pir::name__XYZ ?

[09:20] <szabgab> for example the pir::open__PSS

[09:22] <masak> rakudo: role A[$x, $y] { method x { say $x + $y } }; A[4, 5].new

[09:22] <p6eval> rakudo 012ea2: OUTPUT«No applicable candidates found to dispatch to for '_block52'. Available candidates are:␤:(Mu $x, Mu $y)␤␤  in main program body at line 1␤»

[09:22] <dalek> rakudo: d1a7442 | moritz++ | src/core/CallFrame.pm:

[09:22] <dalek> rakudo: fix callframe().line and .file by creating a Perl 6 hash from the annotations

[09:22] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d1a7442b130036112bd7352cd7eec603e3bb520b

[09:22] <dalek> rakudo: cb0e95e | moritz++ | src/core/CallFrame.pm:

[09:22] <dalek> rakudo: simplify CallFrame.pm, and make a parameter optional

[09:22] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cb0e95ecf01d7d088993cd141f025b268c5bbc7e

[09:26] <jnthn> masak: I wonder if it's passing the role args as just one Parcel.

[09:26] <jnthn> Rather than properly sending them in as multiple args.

[09:26] <masak> that might be it.

[09:30] <moritz_> szabgab: you have to go through the parrot docs

[09:31] <szabgab> where is my yak ?  :)

[09:31] <moritz_> szabgab: pir::open__PSS means it's an opcode that returns a P(MC) and receives two S(trings)

[09:32] <mberends> yay! today I'm going to Sweden to visit a world famous pivo connoisseur!

[09:33] <szabgab> so theoretically I could just write  pir:opendir__PS   ?

[09:33] <moritz_> right

[09:35] <jnthn> mberends: going, but arriving tomorrow, no? :-)

[09:35] <mberends> yes, overnight coach trip :)

[09:35] <jnthn> Phew, the pivo connoisseur wasn't drunk when you told him the dates after all. :-)

[09:35] <masak> jnthn, mberends: what will you two be hacking on this weekend?

[09:36] <jnthn> pivo!

[09:36] <jnthn> oh, hacking, not drinking...

[09:36] <masak> :)

[09:36] <dlm> hi martin

[09:36] <jnthn> That...other thing I do... :-)

[09:36] *** dlm is now known as dolmen

[09:36] <mberends> the hacking will have to be sekrit, in case is fails ;-)

[09:36] <mberends> hi dolmen!

[09:37] *** dolmen is now known as Guest58318

[09:37] <jnthn> masak: I'm not sure. Last time mberends showed up at my place, we spontaneously wrote Zavolaj. But then we had to leave the country.

[09:37] * Guest58318 was in Calais

[09:37] *** Guest58318 is now known as dolmen_

[09:37] *** dolmen_ is now known as dolmen__

[09:37] <mberends> bounce, bounce

[09:38] <masak> jnthn: any causation between spontaneously writing Zavolaj and having to leave the country? :P

[09:38] *** dolmen__ left
[09:38] <mberends> masak: the 'is native' trait may have caused a problem, since we were both foreigners

[09:39] <masak> *lol*

[09:39] <jnthn> :D

[09:40] *** dlm joined
[09:40] *** xabbu42 left
[09:40] *** xabbu42 joined
[09:40] <szabgab> I guess if I attempt to implement opendir it should be in some module called IO::Dir and not in IO.pm , right ?

[09:40] * dlm doesn't remembers its freenode account :(

[09:43] <moritz_> szabgab: does the spec say anything about it?

[09:44] <szabgab> I don't think so

[09:44] <masak> each time I read the file IO parts of the spec, I do so with some amounts of disbelief and suspicion.

[09:44] <szabgab> S29 mentiones opendir once

[09:44] <moritz_> it would be very cool to have a function that lazily returns all directory entries in a lazy list

[09:45] <moritz_> there's basically no need for opendir/readdir/closedir if you have that

[09:45] <szabgab> for now I'd be happy with any first implementation of it

[09:45] <masak> I wouldn't be sad if we just scrapped that (overdesigned and overly complex) part of the spec and did exactly what Perl 5 is doing.

[09:45] <jnthn> Maybe we can gather some hackers to take that on.

[09:45] <szabgab> moritz_, I'd guess that would be a utility function

[09:45] <moritz_> do we have an API to generate a list from an iterator?

[09:47] <szabgab> I found IO::Directory in S32/IO

[09:47] <szabgab> but does not have much of a spec as I can see

[09:50] <mathw> As far as I see it, IO's still in a horrendous state in spec terms

[09:50] <mathw> Nobody ever seems to agree on how to do it

[09:51] <ciphertext> rakudo: my @a = gather { take [1,2],3}; @a.perl.say;

[09:51] <p6eval> rakudo 012ea2: OUTPUT«[[1, 2], 3]␤»

[09:51] <masak> it has only been touched by people who like abstractions so far, not people who know file IO.

[09:51] *** xabbu42_ joined
[09:51] *** xabbu42 left
[09:51] *** xabbu42_ is now known as xabbu42

[09:51] <moritz_> rakudo: say WHAT gather { take 1 }

[09:51] <p6eval> rakudo 012ea2: OUTPUT«List()␤»

[09:51] <masak> (with due apologies to people who have edited that piece of the spec, and actually know file IO -- it's just that that's not what it looks like)

[09:52] <ciphertext> rakudo: say gather {my $x = 0; take $x++; take $x};

[09:52] <p6eval> rakudo 012ea2: OUTPUT«01␤»

[09:54] *** dlm left
[09:58] <ciphertext> rakudo: my f($x is copy) { say gather { take $x++; take $x }}; f(5);

[09:58] <p6eval> rakudo 012ea2: OUTPUT«===SORRY!===␤Malformed my at line 11, near "f($x is co"␤»

[09:58] <ciphertext> rakudo: my sub f($x is copy) { say gather { take $x++; take $x }}; f(5);

[09:58] <p6eval> rakudo 012ea2: OUTPUT«56␤»

[10:01] *** aesop_ joined
[10:02] *** aesop left
[10:03] *** xabbu42_ joined
[10:03] *** xabbu42 left
[10:03] *** xabbu42_ is now known as xabbu42

[10:05] <ciphertext> rakudo: say gather { my $x = 10; take $x while --$x >= 0; };

[10:05] <p6eval> rakudo 012ea2: OUTPUT«-1-1-1-1-1-1-1-1-1-1␤»

[10:05] <ciphertext> aha! i knew it was still broken.

[10:05] <moritz_> to reproduce, you have to always take() the same variable

[10:06] <moritz_> if you take $x++, the $x++ returns a value that's not the same variable as $x

[10:08] *** yinyin left
[10:08] <ciphertext> right. i submitted a patch yesterday (http://rt.perl.org/rt3/Ticket/Display.html?id=75810), but now that the list branch isn't riddled with errors, i can see that my patch broke something...  

[10:09] <moritz_> there's an easy enough fix...

[10:09] <moritz_> clone the arguments to take()

[10:09] <moritz_> I'm just not sure if it's the right fix

[10:09] <ciphertext> that's what i did in the patch...

[10:11] <moritz_> why does it change so much unrelated code?

[10:12] <ciphertext> what do you mean?

[10:12] *** xabbu42_ joined
[10:12] *** xabbu42 left
[10:12] *** xabbu42_ is now known as xabbu42

[10:12] <moritz_> I'd expect the patch only to change .sub 'take'

[10:13] <moritz_> if it makes other things simpler, putting those changes into a second patch makes review much easier

[10:14] <ciphertext> i'll keep that in mind

[10:15] <ciphertext> oh yeah, i think i submitted the multiple fixes as one patch because my patch to &infix:<...> didn't work without the patch to take

[10:15] <ciphertext> > my @a = gather { take [1,2],3}; @a.perl.say;

[10:15] <ciphertext> [1, 2, 3]

[10:16] <moritz_> ouch

[10:16] <hejki> i still so hate gather not being lazy :<

[10:16] <moritz_> hejki: but, it is

[10:16] <hejki> oh

[10:16] *** xabbu42 left
[10:16] <hejki> for isn't then

[10:16] <hejki> :>

[10:16] <moritz_> right

[10:16] *** xabbu42 joined
[10:16] <moritz_> .map is

[10:16] <hejki> rakudo: my @ar = gather { for ^Inf -> $i { take $i if $i % 2 == 0 } }; @ar[4].say

[10:16] *** lestrrat is now known as lest_away

[10:16] <hejki> i want this :>

[10:17] <p6eval> rakudo 012ea2:  ( no output )

[10:18] <moritz_> rakudo: my @ar = gather { while 1 { take $i++ if $i % 2} }; say @ar[4]

[10:18] <p6eval> rakudo 012ea2: OUTPUT«===SORRY!===␤Symbol '$i' not predeclared in <anonymous> (/tmp/IbZIN6GFFs:11)␤»

[10:18] <moritz_> rakudo: my @ar = gather { while 1 { my $i = -1; take $i++ if $i % 2} }; say @ar[4]

[10:18] <p6eval> rakudo 012ea2:  ( no output )

[10:18] <hejki> rakudo: my @ar = gather { while ++$i { take $i if $i % 2 == 0 } }; @ar[4].say

[10:18] <p6eval> rakudo 012ea2: OUTPUT«===SORRY!===␤Symbol '$i' not predeclared in <anonymous> (/tmp/z4MiQEMiNM:11)␤»

[10:18] <hejki> rakudo: my @ar = gather { my $i = 0; while ++$i { take $i if $i % 2 == 0 } }; @ar[4].say

[10:19] <p6eval> rakudo 012ea2:  ( no output )

[10:19] <moritz_> rakudo: say (gather { my $i = 0; while ++$i { take $i if $i % 2 == 0 } }.[4]

[10:19] <p6eval> rakudo 012ea2: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤»

[10:19] <moritz_> rakudo: say (gather { my $i = 0; while ++$i { take $i if $i % 2 == 0 } ).[4]

[10:19] <p6eval> rakudo 012ea2: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 11␤»

[10:20] <moritz_> rakudo: say (gather { my $i = 0; while ++$i { take $i if $i % 2 == 0 } }).[4]

[10:20] <sorear> std: 2

[10:20] <p6eval> rakudo 012ea2: OUTPUT«10␤»

[10:20] <p6eval> std 31325: OUTPUT«ok 00:01 104m␤»

[10:20] <moritz_> hejki: it seems that array assignment isn't lazy yet :(

[10:20] <hejki> ye

[10:21] <sorear> moritz_: array assignment isn't lazy as specced.  Note that it returns the list, which is then put into void context...

[10:21] <ciphertext> rakudo: say ((^Inf).map: {$_ if $_ % 2 == 0})[4]

[10:21] <p6eval> rakudo 012ea2: OUTPUT«4␤»

[10:21] <moritz_> sorear: rakudo doesn't detect void/sink context yet

[10:21] <sorear> oh.

[10:22] <ciphertext> wait... that's not right...

[10:22] <ciphertext> nvm

[10:22] <moritz_> ciphertext: I guess it always puts one (possibly empty) Capture into the list

[10:22] <moritz_> rakudo: say ((^Inf).map: {$_ if $_ % 2 == 0}).flat.[4]

[10:23] <p6eval> rakudo 012ea2: OUTPUT«8␤»

[10:23] <moritz_> better? :-)

[10:23] <hejki> much better :>

[10:23] <hejki> now i just need to make one giving me lazy primes :>

[10:23] <hejki> and then i can start rejoiceing projecteuler with perl6 :>

[10:30] *** JimmyZ left
[10:38] <masak> rakudo: say (gather loop (my $i = 2;;++$i) { take $i + 0 if $i % all 2..$i/2 }).[^10].perl

[10:38] <p6eval> rakudo 012ea2: OUTPUT«(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)␤»

[10:38] <masak> man, that's cool.

[10:39] <jnthn> perl6++

[10:39] <masak> pmichaud++

[10:40] <jnthn> rakudo: say (gather for 1..* -> $i { take $i + 0 if $i % all 2..$i/2 }).[^10].perl

[10:40] <p6eval> rakudo 012ea2:  ( no output )

[10:40] <jnthn> Aw.

[10:40] <ciphertext> jnthn: for isn't lazy yet

[10:41] <jnthn> I thought gather/take being continuation-y would win over that, though.

[10:41] *** dakkar left
[10:41] <masak> jnthn: no, because the loop never starts.

[10:41] <masak> rakudo: say (gather loop (my$i=2;;++$i){take +$i if$i%all 2..$i/2}).[^10].perl # curious manifestation of the 'take' bug

[10:41] <p6eval> rakudo 012ea2: OUTPUT«(29, 3, 5, 7, 11, 13, 17, 19, 23, 29)␤»

[10:44] <ciphertext> > say (gather loop (my$i=2;;++$i){take +$i if$i%all 2..$i/2}).[^10].perl

[10:44] <ciphertext> (2, 3, 5, 7, 11, 13, 17, 19, 23, 29)

[10:44] *** dakkar joined
[10:44] <ciphertext> unfortunately, the fix breaks "take [0,1]" type statements for some reason...

[10:45] <masak> ciphertext: you just happened to have a fix to that? cool!

[10:46] *** xabbu42_ joined
[10:46] *** xabbu42 left
[10:46] *** xabbu42_ is now known as xabbu42

[10:46] <ciphertext> see http://rt.perl.org/rt3/Ticket/Display.html?id=75810  (note that it is also a patch for &infix:<...> )

[10:47] *** Mowah joined
[10:48] <masak> sounds like something we'd want to apply.

[10:48] *** sjohnson joined
[10:49] <masak> any particular reason it's one patch instead of one-per-fix?

[10:49] *** xabbu42_ joined
[10:49] *** xabbu42 left
[10:49] *** xabbu42_ is now known as xabbu42

[10:49] <masak> the one applying them might want to review them separately.

[10:52] *** dakkar left
[10:52] *** dakkar joined
[10:53] <ciphertext> the patch for &infix:<...> doesn't work without the patch for take :/

[10:54] *** LylePerl joined
[10:54] *** xabbu42_ joined
[10:54] <masak> oh, ok.

[10:54] *** xabbu42 left
[10:54] *** xabbu42_ is now known as xabbu42

[10:55] <masak> I just did a spectest, so I might as well apply those patches and make another one. :)

[10:56] *** ggoebel joined
[10:56] <ciphertext> well, keep in mind, the take patch broke something else (i'm currently trying to figure out how)

[10:56] <sorear> hmm down to 88.84%

[10:56] <sorear> significant regression :/

[10:56] *** xabbu42 left
[10:56] *** xabbu42 joined
[10:56] <masak> ciphertext: in that case, I'll leave it to pmichaud to decide what to do.

[10:57] <LylePerl> Hello

[10:57] <sorear> Hello

[10:57] *** am0c joined
[10:58] <LylePerl> It's been a long time

[10:58] *** xabbu42_ joined
[10:58] *** xabbu42 left
[10:58] *** xabbu42_ is now known as xabbu42

[11:01] *** sdvsdvsdv left
[11:01] *** arthur-_ joined
[11:01] <LylePerl> We (Bristol & Bath Perl Mongers) had a trial run of our Perl 6 discovery workshop last tues

[11:03] <mberends> LylePerl: how did it go?

[11:03] <masak> LylePerl: nice. what were the conclusions from the trial run?

[11:04] *** quester_ joined
[11:04] <quester_> .

[11:04] <LylePerl> Not quite as smoothly as I'd hoped :/ I'm glad we delayed the big one which we plan to promote nationally to all the UK groups

[11:05] <masak> I have three failing test files: t/spec/S06-advanced_subroutine_features/callframe.rakudo t/spec/S09-typed-arrays/arrays.rakudo t/spec/S12-methods/submethods.rakudo -- and still lots of TODO passes in other files.

[11:05] <masak> LylePerl: we'll be happy to help smooth out rough spots if we can.

[11:06] <LylePerl> Thanks Masak, I've got some questions and thoughts based on our experiments

[11:06] <masak> excellent.

[11:07] *** xabbu42_ joined
[11:07] *** xabbu42 left
[11:07] *** xabbu42_ is now known as xabbu42

[11:07] *** tadzik joined
[11:07] <LylePerl> The format of the workshop is that people are divided into groups, then given an area of Perl 6 to investigate, 2hrs later all group present their findings to each other (with code examples)

[11:08] <masak> interesting idea. must try that sometime.

[11:09] <LylePerl> From the experience, Picking things at random from the synopsis didn't work as some chunks are mostly un-implemented

[11:09] <mberends> LylePerl: could you write up a summary of the areas chosen and the findings?

[11:09] <LylePerl> Such as Data Structures, I looked at these and found much un-implemented

[11:10] <LylePerl> mberends: Good idea, I'll start a discussion on the groups list and do a blog post

[11:10] *** xabbu42_ joined
[11:10] *** xabbu42 left
[11:10] *** xabbu42_ is now known as xabbu42

[11:10] <mberends> LylePerl++

[11:11] <LylePerl> So I think for the big one we need more specific areas for the groups to work on, the interesting bits where much is implemented

[11:12] <LylePerl> The overall aim is to inspire people to play with Rakudo more, we really don't want them to be put off in any way

[11:13] <mberends> yes, so a priority is to identify and work around blockers

[11:13] *** xabbu42_ joined
[11:13] *** xabbu42 left
[11:13] *** xabbu42_ is now known as xabbu42

[11:14] <LylePerl> Is there a kind of list kept of what's implemented and what's not?

[11:14] <sorear> t/spec/spectest.data

[11:14] <sorear> within the spectests themselves, individual tests are also annotated by who passes them

[11:15] <snarkyboojum> seems that Rakudo Star might be a good opportunity to update "Things that work in Rakudo" on http://rakudo.org/status

[11:15] <LylePerl> excellent, now I know where to start, prob should have thought of that

[11:15] <jnthn> Note, t/spectest.data

[11:16] *** kensanata joined
[11:17] <LylePerl> Another idea came forward for which order things are being implemented

[11:17] <snarkyboojum> or will there be another list of "things that work in Rakudo Star"?

[11:18] <LylePerl> That possibly the interesting and often complicated things are being implemented first because they are more challenging and fun to do

[11:19] <LylePerl> which is potentially leaving some comparatively easy to implement features

[11:19] *** xabbu42_ joined
[11:19] *** xabbu42 left
[11:19] *** xabbu42_ is now known as xabbu42

[11:20] *** mjk joined
[11:20] <LylePerl> which would be ideal for people new to rakudo and wanting to help with implementation

[11:22] <LylePerl> So an idea of what isn't implemented, ranked by complexity would be useful for people like myself

[11:24] <ciphertext> rakudo: my $x = gather { take 0,[1,2]; }; say $x.perl; say $x.flat.perl;

[11:24] <p6eval> rakudo cb0e95: OUTPUT«((0, [1, 2]))␤(0, [1, 2])␤»

[11:24] <moritz_> LylePerl: if you want to fix (relatively straight-forward) things in the existing implementation, I have an idea for you

[11:24] *** synth joined
[11:25] <ciphertext> rakudo: my $x = gather { take 0,[1,2]; }; say $x.WHAT; say $x.flat.WHAT;

[11:25] <p6eval> rakudo cb0e95: OUTPUT«List()␤List()␤»

[11:25] <moritz_> get t/spec/S03-operators/series-arity0.t to pass again on rakudo

[11:26] <moritz_> it's in src/core/operators.pm starting at line  311

[11:26] <moritz_> it's only Perl 6 code, no PIR or other magic involved

[11:27] <LylePerl> (just for a little background, I disappeared last year because of a new job and starting a part time MSc. I've now passed the first year of the MSc with Distinction, got my results yesterday so I'm pretty chuffed :) It's proved to myself at least that I am capable of learning at a pretty high level. Uni doesn't start again until september, so I want to devote some time again to Perl 6 at least until then)

[11:27] <ciphertext> rakudo: my $x = gather { take 0,[1,2]; }; say $x[0].WHAT;

[11:27] <p6eval> rakudo cb0e95: OUTPUT«Parcel()␤»

[11:27] <moritz_> LylePerl: congratulations

[11:30] <LylePerl> moritz_: thanks. At this point I probably know more PIR than Perl 6 from my experiences last year. Which is pretty embarrasing. Sounds like a good reason to learn more Perl 6 :)

[11:33] <masak> LylePerl: yay! there's been a modest module explosion in the past year. you might get inspired by reading through some source code: http://proto.perl6.org/

[11:34] *** _buno_ joined
[11:34] *** _buno_ left
[11:35] *** _buno_ joined
[11:38] *** jjore left
[11:38] <ciphertext> moritz_: i have a patch for &infix:<...>. (Unfortunately, it's dependent on a patch to fix the 'take while' bug, which is causing other problems)

[11:38] <moritz_> which other problems is it causing?

[11:38] <pugssvn> r31327 | sorear++ | [viv] Pregenerate protoregex data & declaration class fields.  -0.6% ops, prerequisite for killing \d\d\d 

[11:39] *** jjore_ joined
[11:39] <sorear> std: 2

[11:39] <p6eval> std 31325: OUTPUT«ok 00:01 104m␤»

[11:39] <LylePerl> masak: I saw this pop up on the mailing list, good stuff :)

[11:39] <moritz_> ciphertext: also it's pretty easy to work around the take-bug

[11:39] <moritz_> ciphertext: take my $tmp = $value;

[11:39] <ciphertext> moritz_: masak and i were talking about this earlier.

[11:40] <moritz_> then I should backlog

[11:40] <masak> aye.

[11:40] <masak> LylePerl: I think this is a good time to jump on the Perl 6 train. R* will probably generate a lot of activity, and much focus will go to explain things to beginners.

[11:42] <moritz_> ciphertext: is infix:<scmp> spec?

[11:42] <moritz_> if not, it should not be user-visible

[11:45] <ciphertext> no, not spec. Is there a way to make it not user-visible, but still visible to all the multi's of &infix:<...>?

[11:45] *** xabbu42 left
[11:45] *** xabbu42 joined
[11:46] <moritz_> you could try to put them into a common block

[11:46] <moritz_> { my multi sub scmp($a, $b) { ... }; all infix:<...> subs here, as 'our multi'  }

[11:47] *** JimmyZ joined
[11:47] <ciphertext> ok.  i'll do that, then.

[11:47] *** pnu left
[11:47] <moritz_> (doesn't need to be an operator, sub form works too

[11:48] <snarkyboojum> I think its a good idea

[11:48] <masak> neat trick.

[11:48] *** _buno_ left
[11:49] *** pnu joined
[11:50] <moritz_> lexical scoping ftw!

[11:50] <masak> aye... will have to remember that for my upcoming scoping tutorial.

[11:51] *** xabbu42 left
[11:51] *** xabbu42_ joined
[11:51] *** xabbu42_ is now known as xabbu42

[11:55] *** envi^home joined
[11:57] *** xabbu42_ joined
[11:57] *** xabbu42 left
[11:57] *** xabbu42_ is now known as xabbu42

[11:57] *** arthur-_ left
[12:00] <moritz_> autounfudge seems to find quite a few passing tests

[12:01] <moritz_> sorear: FYI, there were about 5 newly passing test files after the 'list' merge

[12:02] <masak> moritz_: both Tene and I have found lots of TODO passes in the backlog. what's the rule for knowing when such tests can be unfudged?

[12:02] <moritz_> masak: normally all of them can... except for those notrious intermittent passing TODOs in uc.rakudo and some of the role composition tests

[12:03] <moritz_> I removed a few todo markers after Tene++'s nopaste

[12:03] <moritz_> need to do a fresh spectest to look what's left

[12:03] <masak> moritz_++

[12:03] *** xabbu42 left
[12:03] *** xabbu42 joined
[12:05] <moritz_> but first I need to finish the autounfudge run

[12:09] <takadonet> morning all

[12:09] <masak> \o

[12:09] *** xabbu42 left
[12:09] *** xabbu42 joined
[12:10] <masak> any volunteers for ChangeLog updates? the release guide has good tips on how to go about it. I'll do it later today if no-one else has done it, but I'll also happily accept contributions. :)

[12:10] <moritz_> I've tried to keep it up-to-date while adding features, but I appear to be the only one

[12:11] <masak> in the kingdom of the blind, the one-eyed is overburdened with responsibility :P

[12:11] <moritz_> aye :-)

[12:12] <masak> someone writing something about Rakudo * in Japanese. http://twitter.com/ryochin/status/16383155941 -- something about being put off, about June, and about already existing.

[12:13] <moritz_> can somebody please run callframe.t on an up-to-date rakudo and tell me if it passes?

[12:14] *** skids joined
[12:16] <moritz_> rakudo: say (5 but 'foo').Str

[12:16] <p6eval> rakudo cb0e95: OUTPUT«foo␤»

[12:16] <masak> rakudo: say ~(5 but 'foo')

[12:16] <p6eval> rakudo cb0e95: OUTPUT«5␤»

[12:16] <moritz_> that's correct, but probably for the wrong reasons

[12:16] *** arthur-_ joined
[12:17] <masak> aye.

[12:17] <jnthn> No, it's correct for the right reason.

[12:17] <jnthn> See infix:<does> in operators.pm

[12:17] <masak> cool!

[12:18] <snarkyboojum> moritz_: I get a fail for callframe.t

[12:18] <moritz_> snarkyboojum: does it fail after the first test?

[12:18] <jnthn> It's quite cool, it looks at the type of the RHS argument and constructs a role with the right method name using the metamodel, then composes it. :-)

[12:18] <snarkyboojum> tests 2, 6 and 7 fail here

[12:18] <snarkyboojum> oh

[12:19] <snarkyboojum> no, just the 2nd

[12:19] <masak> in all honesty, a better name for $do-it-to-me is probably $receiver, or something similarly boring. :)

[12:19] <masak> I say this as someone who created a project called Hit-on-me :P

[12:19] <snarkyboojum> moritz_: 'got: Proxy.new(), expected 15'

[12:20] <moritz_> jnthn: I'd expect ~(5 but 'foo') to return '5' because prefix:<~> calls .Stringy, not .Str

[12:20] <jnthn> moritz_: Me too.

[12:20] <moritz_> does it do that?

[12:20] <jnthn> It did above, no?

[12:20] <moritz_> I thought it still called .Str

[12:20] <jnthn> Oh. :S

[12:21] <masak> moritz_: callframe.t aborts after the third test. Method 'inline' not found for invocant of class 'CallFrame'.

[12:21] <jnthn> masak: Can I call it $doee? :-)

[12:21] <moritz_> rakudo: class A { method Str { 'Str' }; method Stringy { 'Stringy' } }; say ~A.new()

[12:21] <p6eval> rakudo cb0e95: OUTPUT«Str␤»

[12:21] <moritz_> masak: needs to run with fudge

[12:21] <masak> jnthn: yes! that's a good compromise :)

[12:21] <masak> moritz_: ah, you asked about .t

[12:21] <jnthn> masak: I think it also sounds like Dutch for "bye" ;-)

[12:21] *** xabbu42 left
[12:21] *** xabbu42 joined
[12:21] <moritz_> masak: and I meant .rakudo, sorry

[12:22] <snarkyboojum> well, I ran it with make so I was talking about .rakudo as well

[12:22] <masak> moritz_: the .rakudo file runs to completion. test 6 fails.

[12:22] <masak> oh, and test 2.

[12:24] <moritz_>     method line() {

[12:24] <moritz_>         self!annotations()<fline>;

[12:24] <moritz_>     }

[12:24] <moritz_> that explains a lot

[12:24] <moritz_> moritz--

[12:24] <jnthn> flail

[12:24] *** xabbu42 left
[12:24] *** xabbu42 joined
[12:25] *** arthur-_ left
[12:26] *** JimmyZ left
[12:26] <colomon> moritz_: don't forget those tests you turned off on Tuesday can be turned back on (assuming they weren't in the merge because the test count seems low)

[12:27] <moritz_> colomon: I've turned on some of them again

[12:27] <moritz_> colomon: some still fail, but I guess I should re-enable them anyway

[12:28] <colomon> moritz_: which ones fail?  that indeed would be good to know...

[12:28] *** am0c left
[12:29] <moritz_> series-simple.t for example

[12:29] <moritz_> only series test left

[12:29] <moritz_> I've re-enabled all the others

[12:30] <moritz_> -#?rakudo skip "Why should Complex.sign fail gracefully enough to work with this test?" ok sign(3+4i).notdef, 'sign(Complex) fails';

[12:30] <moritz_> colomon: should that skip marker go? the test passes

[12:30] <colomon> yes

[12:31] <colomon> I wasn't sure what to do with it, then I made things consistent by making the other Real-only methods have nice fails for non-Real Numeric too.

[12:32] <dalek> rakudo: 19e7264 | moritz++ | src/core/CallFrame.pm:

[12:32] <dalek> rakudo: fix typo in CallFrame.pm, moritz--

[12:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/19e72646422f568e1f017eaca1032beb20e8d01f

[12:32] <dalek> rakudo: f17fe96 | moritz++ | docs/ChangeLog:

[12:32] <dalek> rakudo: extend ChangeLog a bit

[12:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f17fe961c7906b9b870ab09322cd53918fac4998

[12:32] <dalek> rakudo: 17e43e8 | moritz++ | t/spectest.data:

[12:32] <dalek> rakudo: turn on the series tests; those that fail are regressions from the "list" merge, 

[12:32] <dalek> rakudo: and should be fixed before the release

[12:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/17e43e86eedaa241a9f282372aa6db476216df5f

[12:33] <cono> rakudo: ("62.76.96.200", "62.76.96.201", "62.76.96.202", ... "62.76.96.223").perl.say

[12:33] <p6eval> rakudo cb0e95:  ( no output )

[12:33] <cono> repl just hang up on this example

[12:34] <cono> is it an error?

[12:34] <pugssvn> r31328 | moritz++ | [t/spec] lots of rakudo unfudges 

[12:34] <tadzik> cono: no output here, no hanging

[12:34] <tadzik> ah, but it's #29

[12:34] <cono> I think it must print an error message

[12:35] <ciphertext> i get:

[12:35] <ciphertext> > ("62.76.96.200", "62.76.96.201", "62.76.96.202", ... "62.76.96.223").perl.say

[12:35] <ciphertext> ===SORRY!===

[12:35] <ciphertext> Stub code executed

[12:35] <snarkyboojum> cono: you can get the same behaviour by just putting ... into the repl

[12:35] <cono> ciphertext: yup

[12:35] <cono> is it a bug?

[12:35] <jnthn> ciphertext: I think you didn't want that , before the ...

[12:35] <ciphertext> no, a typo

[12:35] <moritz_> ciphertext: you probably didn't want the comma before teh ,

[12:35] <ciphertext> jnthn++

[12:35] <jnthn> And no, not a bug

[12:36] <jnthn> ... as a term is stub code that will whine a bit

[12:36] <cono> But I think rakudo must print an error

[12:36] <jnthn> cono: Ah, it didn't for you? :-S

[12:36] <cono> syntax error ...

[12:36] <moritz_> not a syntax error

[12:36] <jnthn> cono: It's not a syntax error.

[12:36] <cono> jnthn: perl6 -e '("62.76.96.200", "62.76.96.201", "62.76.96.202", ... "62.76.96.223").perl.say'

[12:36] <moritz_> '...' is both a term and an operator

[12:36] <moritz_> std: ...

[12:36] <p6eval> std 31325: OUTPUT«ok 00:01 104m␤»

[12:36] <moritz_> std: 1 ... 2

[12:36] <p6eval> std 31325: OUTPUT«ok 00:02 105m␤»

[12:36] <cono> std: ... 2

[12:37] <p6eval> std 31325: OUTPUT«ok 00:01 104m␤»

[12:37] <jnthn> rakudo: ("62.76.96.200", "62.76.96.201", "62.76.96.202" ... "62.76.96.223").perl.say

[12:37] <p6eval> rakudo cb0e95: OUTPUT«("62.76.96.200", "62.76.96.201", "62.76.96.202")␤»

[12:37] <jnthn> rakudo: ("62.76.96.200", "62.76.96.201", "62.76.96.202", ... "62.76.96.223").perl.say

[12:37] <p6eval> rakudo cb0e95:  ( no output )

[12:37] <jnthn> Hm

[12:37] <moritz_> bug

[12:37] <jnthn> Yeah

[12:37] <snarkyboojum> :)

[12:37] <moritz_> somwhere the fail() is lost

[12:37] <jnthn> It should whine about stub code being executed.

[12:38] <jnthn> We fail to fail.

[12:38] <jnthn> And thus we fail.

[12:38] <cono> :D

[12:38] <moritz_> meta-fail

[12:38] *** JimmyZ joined
[12:39] * cono submit a bug

[12:39] <ciphertext> > ("62.76.96.200", "62.76.96.201", "62.76.96.202" ... "62.76.96.223")

[12:39] <ciphertext> Null PMC access in find_method('params')

[12:39] <moritz_> another bug

[12:39] <ciphertext> (this includes local changes, though)

[12:39] <moritz_> oh

[12:39] <moritz_> then don't submit :-)

[12:40] <pmichaud> good morning, #perl6

[12:40] *** masonkramer left
[12:40] <snarkyboojum> I don't get that behaviour :)

[12:40] <moritz_> good morning pmichaud 

[12:40] *** masonkramer joined
[12:40] <cono> pmichaud: morning

[12:41] *** arthur-_ joined
[12:41] <jnthn> re-morning, pmichaud 

[12:41] <moritz_> :-)

[12:41] *** quester_ left
[12:41] <pmichaud> so, how do things look a few hours later?  ;-)

[12:41] <JimmyZ> wow...

[12:42] <moritz_> pmichaud: a few more commits, less passing TODOs

[12:42] <moritz_> pmichaud: I've re-enabled the series tests; some of them are still failing

[12:43] <moritz_> I've also managed to fix CallFrame.pm, break it, and fix it again :-)

[12:43] <pmichaud> excellent, not so great, and really excellent!  :-)

[12:46] <ciphertext> in my @a = 1, 2;   how is the rhs converted from a parcel to array? i.e. what methods/subs are called?

[12:47] <moritz_> pmichaud: you might also be pleased that some test files just started passing, like for hash slices (iirc)

[12:47] <pmichaud> moritz_: yes, I was thinking that would happen :)

[12:47] <pmichaud> I know that a *lot* of stuff was backed up on the list/iterator stuff.

[12:48] <pmichaud> (even if it didn't seem to have an obvious connection)

[12:48] <jnthn> ciphertext: infix:<=> is called, and passed the Array from the LHS and the parcel from the RHS

[12:48] <jnthn> ciphertext: And then shuffles the Parcel's contents into the array

[12:49] *** rgrau joined
[12:49] *** xabbu42_ joined
[12:49] *** xabbu42 left
[12:49] *** xabbu42_ is now known as xabbu42

[12:54] <colomon> looking at series errors...

[12:56] <ciphertext> colomon: see backlog

[12:57] <colomon> oh, changing from batch(N) to [^N] broke the tests -- batch stopped when the iterator ran out, but [^N] pads.

[12:57] <colomon> ciphertext: where?

[12:59] <pmichaud> .munch is a somewhat acceptable alternative to .batch, I would think.

[12:59] <ciphertext> masak, moritz_ and i were talking about my patch for &infix:<...>

[12:59] *** Guest94288 left
[13:00] <colomon> pmichaud: hmmm.... there's no actual reason to use [^10] in these tests that I can see.  We shouldn't need munch either.

[13:00] <moritz_> http://nopaste.snit.ch/paste

[13:04] <masak> lol i haz blogged: http://use.perl.org/~masak/journal/40403

[13:05] <masak> (it's about this weekend's mini-hackathon, and its three-phase nature. I find I really like working like that.)

[13:05] <pugssvn> r31329 | colomon++ | Changing from .batch(N) to.[^N] broke tests that expected to get fewer than N elements from the series.  But if there are fewer than N elements, we don't need batch or []! 

[13:06] <moritz_> rakudo: say (^5).[^10].elems

[13:06] <p6eval> rakudo 17e43e: OUTPUT«10␤»

[13:06] <moritz_> I'm pretty sure that's wrong

[13:06] <masak> aye.

[13:07] <masak> rakudo: say (5).[^10].perl

[13:07] <p6eval> rakudo 17e43e: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class 'Int'␤  in main program body at line 1␤»

[13:07] <moritz_> slices extending over the upper bound of the list should just be Nil

[13:07] <masak> they should? I thought they should be as large as possible.

[13:07] <moritz_> I mean the return value should be Nil

[13:08] <moritz_> of the excessive elements

[13:08] <masak> I'd expect the above to print "5\n".

[13:08] <pmichaud> there are several competing things happening here.

[13:08] *** agentzh left
[13:09] <moritz_> I've tried to put postcircumfix:<[ ]> into Any

[13:09] <moritz_> and got stuck with what to do with %h[0]

[13:09] <colomon> moritz_: oh, right!

[13:09] <masak> disallow it.

[13:10] <moritz_> die "with fire" ?

[13:10] <masak> do Hashes do Positional?

[13:10] <pmichaud> no.

[13:11] <pmichaud> but %h.list[0]  would work.

[13:11] <pmichaud> as would  (@%h)[0]

[13:11] <masak> of course.

[13:11] <[particle]> moritz_, masak: re: S19... Single-character options may be clustered with the same syntax and semantics

[13:11] <moritz_> and both would be the same as %h.pairs.[0]

[13:11] <masak> that's because then it's no longer a hash.

[13:11] <moritz_> [particle]: then I misremembered something, sorry

[13:11] <masak> [particle]++

[13:11] *** xabbu42 left
[13:11] *** xabbu42 joined
[13:12] <moritz_> [particle]: with the same syntax and semantics... as perl 5?

[13:12] <pmichaud> my @a = ^5; say @a.perl;

[13:13] <pmichaud> rakudo: my @a = ^5; say @a.perl;

[13:13] <p6eval> rakudo 17e43e: OUTPUT«[0, 1, 2, 3, 4]␤»

[13:13] <pmichaud> rakudo: my @a = ^5; say @a[^10].elems

[13:13] <p6eval> rakudo 17e43e: OUTPUT«10␤»

[13:14] <colomon> pmichaud: can I use .munch in a spectest?

[13:14] <[particle]> moritz_: aye, as perl 5.  that is from the "Unchanged Syntactic Features" section

[13:14] <pmichaud> colomon: works for me, I expect it to become spec.

[13:14] *** plainhao joined
[13:14] <[particle]> only the last single-character option can take a value

[13:15] <masak> just like I hoped it would be :)

[13:15] <pugssvn> r31330 | colomon++ | Replace .[N] with .munch(N) so that results are not padded with Any(). 

[13:17] <pugssvn> r31331 | colomon++ | [t/spec] Don't use .[^20] on tests which should have finite results. 

[13:18] *** SmokeMachine joined
[13:18] <colomon> okay, that's got all the series tests passing (when fudged) again.

[13:18] <pmichaud> \o/

[13:18] <moritz_> colomon++ # cleaning up the mess I accidentally left behind

[13:19] <moritz_> http://nopaste.snit.ch/21326 spectest summary (before colomon's fixes)

[13:20] <jnthn> Wow, mostly TODO passes.

[13:20] <colomon> so reduce.t

[13:20] <colomon> t/spec/S09-typed-arrays/arrays.t

[13:20] <colomon> are the only two problem files remaining?

[13:21] <pmichaud> I suspect the problem with arrays.t has to do with object initialization.

[13:21] <pmichaud> I'll work on that one.

[13:22] <colomon> it's the [>>+<<] that's failing in reduce.

[13:22] <PerlJam> gutenTag

[13:22] *** kensanata left
[13:22] <colomon> suspect it might have something to do with the .flat?

[13:22] *** broquaint left
[13:23] <colomon> rakudo: say [>>+<<] ([1..3],[1..3],[1..3])

[13:23] <p6eval> rakudo 17e43e: OUTPUT«Sorry, sides are of uneven length and not dwimmy.␤  in 'hyper' at line 114:CORE.setting␤  in 'hyper' at line 137:CORE.setting␤  in 'reducewith' at line 1␤  in main program body at line 1␤»

[13:23] *** gbacon joined
[13:24] <ciphertext> in pir, when cloning a pmc  (e.g. $P0 = clone $P1), is type information lost or something?

[13:25] <jnthn> ciphertext: If you have a Perl 6 object, almost certainly better to call .clone()

[13:25] <jnthn> Cloning may lose some properties.

[13:25] <PerlJam> make

[13:25] <PerlJam> oops

[13:25] <pmichaud> if the idea is to get &take to clone its arguments.... I'm not so sure that's a good idea.

[13:26] <ciphertext> oh?

[13:26] <jnthn> pmichaud: I tried that bath once in the past.

[13:26] <jnthn> pmichaud: It fixed the usual test cases...and broke other things.

[13:26] <jnthn> er, path

[13:26] <jnthn> :-)

[13:26] <jnthn> So anyway, I didn't apply it.

[13:26] <pmichaud> better would be to strip the arguments of their containers somehow.

[13:27] <pmichaud> i.e., so that you're only taking the values, and not the containers of the values.

[13:27] <jnthn> Would a simple deref do?

[13:27] <jnthn> er, deobjectref

[13:27] <pmichaud> yes and no.

[13:27] <pmichaud> consider

[13:27] <masak> under which circumstances should a class author overload the Mu.clone method?

[13:27] <pmichaud>    take 3, (4,5), 6

[13:27] <pmichaud> I'm not sure how to peek inside of parcels and deobjectref those things.

[13:29] <moritz_> is there a good reason why take() is not a Perl 6 sub which a signature of (\$returns) ?

[13:29] <moritz_> s/which/with/

[13:29] <pmichaud> ummmm, it is.

[13:29] <pmichaud> that's the reason it's a problem.

[13:29] <jnthn> moritz_: \$foo is part of why we end up with the same container referenced throughout.

[13:30] <pmichaud> captures capture the container, not just the value.

[13:30] <pmichaud> so we see changes to the container

[13:30] <jnthn> pmichaud: ah, I guess a more apt example is take 3, ($a, $b), 4; or so.

[13:30] <pmichaud> jnthn: right

[13:30] <moritz_> last time I looked, take was a PIP sub with a slurpy parameter list

[13:30] <pmichaud> moritz_: pir slurpy parameter is basically the same as (\$returns)

[13:30] <pmichaud> it's not like a Perl 6 slurpy that flattens

[13:31] <jnthn> moritz_: Even if that is so, the things inside the PIR slurpy will act as if they were all implicitly \$foo

[13:31] *** xabbu42 left
[13:31] <pmichaud> internally, a Parcel is just an RPA

[13:31] <pmichaud> and   .param pmc args :slurpy    produces an RPA

[13:31] *** Guest23195 joined
[13:31] <jnthn> pmichaud: Hmm. What if take did have a Perl 6 slurpy sig, I wonder...

[13:31] <jnthn> Not sure it's right though.

[13:31] <pmichaud> it's wrong

[13:31] <jnthn> oh, yeah

[13:31] <pmichaud> we don't want to flatten

[13:31] <moritz_> ah, the PIR having implicit \ was what I was missing

[13:32] <jnthn> It's veyr wrong when we try to do slices.

[13:32] <colomon> rakudo: say [<<+>>] ([1..3],[1..3],[1..3])

[13:32] <p6eval> rakudo 17e43e: OUTPUT«3 5 7 4 6 8 5 7 9␤»

[13:32] <pmichaud> and even if we do slurpy slices, it's still wrongish.

[13:32] <jnthn> *nod*

[13:32] <pmichaud> here's the issue with take....

[13:32] <jnthn> Yeah, we want it kinda unscathed structurally

[13:32] <jnthn> Just with its variable links severed

[13:33] <pmichaud> rakudo:  my $a = 5;  sub foo() { $a++; };    sub bar($x) { say $x; foo();  say $x; };   bar($a);

[13:33] <p6eval> rakudo 17e43e: OUTPUT«5␤6␤»

[13:33] <pmichaud> this example is turning "take" inside out so we can see what is happening.

[13:34] <pmichaud> essentially, the problem is that when we have a function call, the parameters are bound to the actual containers

[13:34] <pmichaud> so, with   take $a

[13:34] <pmichaud> we're not capturing the value of $a, we're capturing the container itself

[13:34] <moritz_> the common workaround for that is

[13:34] <moritz_> take my $x = $a

[13:35] <pmichaud> correct

[13:35] <moritz_> could we do that in take() too?

[13:35] <moritz_> hm

[13:35] *** bluescreen joined
[13:35] <jnthn> Thing is we have a parcel that we probably don't want to enforce context on.

[13:35] <pmichaud> I'm not sure what we would do with      take 1, ($a,$b), 2

[13:35] <jnthn> And assignment one why or another enforces a context.

[13:35] <jnthn> *way

[13:35] *** bluescreen is now known as Guest99875

[13:36] <moritz_> that would involve unpacking the parcel, identifying the containers, clone them, re-compose into a new parcel

[13:36] <moritz_> sound hacky

[13:36] <pmichaud> right

[13:36] <jnthn> Well, identify the containers, take the values out and re-compose into a new parcel

[13:36] <jnthn> but yes

[13:36] <jnthn> (as in, store the de-containered things)

[13:38] <jnthn> OTOH, do we have a case where that approach wouldn't work?

[13:38] <pmichaud> I can't really think of one at the moment.

[13:39] <pmichaud> and I could certainly prototype something to handle it fairly quickly

[13:39] <jnthn> In a sense, it's a little bit like binding to a signature the same shape as the Parcel with everything "is copy"

[13:39] <pmichaud> oh!

[13:39] <pmichaud> actually, yes, I could do this pretty easily in PIR, come to think of it.

[13:40] <pmichaud> oh, yes, there is a problem.

[13:40] <pmichaud> with something like:

[13:40] <pmichaud> my $x = [1,2,3];   take $x

[13:40] <pmichaud> we can't just strip off the container, because it's the container that gives the value its "item-ness"

[13:41] <pmichaud> taking off the container in this case would convert the non-flattening array into a flattening one

[13:41] <jnthn> pmichaud: In that case, isn't $x a Perl6Scalar (or ObjectRef) in turn referencing another ObjectRef?

[13:41] <pmichaud> jnthn: it's a Perl6Scalar referencing an Array

[13:41] <jnthn> Ah, yes.

[13:42] <pmichaud> it's not a chain of objectrefs, no.

[13:42] <jnthn> And take [ 1,2,3 ] is probably going to thwart any "1-deep"

[13:42] <colomon> rakudo: say [<<~>>] ([1..3],[1..3],[1..3])

[13:42] <pmichaud> I wonder if there are properties other than flattening that would need to be preserved

[13:42] <p6eval> rakudo 17e43e: OUTPUT«111 221 331 112 222 332 113 223 333␤»

[13:42] <jnthn> Even if that were the case.

[13:42] <moritz_> ro-ness?

[13:43] <pmichaud> ah, yes --    take [ 1, 2, 3 ]   would also lose its item nature

[13:43] <pmichaud> rw is a propery of the container also, so stripping the container would make allof the values ro

[13:43] <jnthn> pmichaud: Yeah. It won't fly.

[13:43] <pmichaud> I think that's pretty safe.

[13:44] <pmichaud> well, it wouldn't be too difficult for me to grab all of the values, decontainerize them, and then put on a new container with the same flattening characteristics as the original

[13:44] <pmichaud> that's only about 3 extra lines of PIR.

[13:44] <jnthn> fresh container with the same props?

[13:44] <jnthn> Yeah

[13:44] <jnthn> especially given setprop

[13:44] <jnthn> er, setprophash

[13:44] <pmichaud> oh, I hadn't thought of same props.

[13:44] <jnthn> or whatever it's called

[13:44] <pmichaud> that would make it even easier.

[13:44] <pmichaud> Maybe I'll try that.

[13:45] <jnthn> I'm not quite up on property use in the latest model.

[13:45] <jnthn> We have a scalar property, or a flatten property these days?

[13:45] <jnthn> Or neither?

[13:45] <pmichaud> it's a 'scalar' property.  'flatten' is gone.

[13:45] <jnthn> OK

[13:45] <pmichaud> also '!FETCH' is gone.  :-)

[13:46] <pmichaud> and I'm thinking that 'scalar' may change to 'item' at some point.

[13:46] <jnthn> Hmmm...

[13:46] <jnthn> !FETCH being gone may have to be considered when we get to doing Proxy or other tied scalar containers, but that's not an immediate worry.

[13:46] *** mjk left
[13:46] <pmichaud> ...one thing that we have to recognize is that by doing any of this de-containerization we're fundamentally going outside of p6's existing signature binding model to do it

[13:47] <jnthn> pmichaud: Yeah, that is bothering me a little.

[13:47] <jnthn> We're "cheating".

[13:47] <pmichaud> big time.

[13:47] <pmichaud> which is why I've been hoping for someone to figure out what "take" really means within the boundaries of the specification.

[13:47] <pmichaud> and then alter the specification to accommodate what we want.

[13:48] <pmichaud> I'm also hoping that I won't find that someone in the mirror.  :)

[13:48] <jnthn> What we want to happen with take doesn't seem to have a matching mechanism in the current signature semantics.

[13:48] *** kda left
[13:48] *** kda joined
[13:48] *** kda left
[13:48] <pmichaud> well, I suspect take itself needs a bit of a rethink.

[13:48] *** kda joined
[13:49] <pmichaud> i.e., it's not so much that we need to expand the signature semantics, but we need to rethink how take itself is achieved

[13:50] <pmichaud> it's trivially simple to say, for example, that &take works by manipulating the parcel to remove containers and the like 

[13:50] <pmichaud> as opposed to saying that the binder has to do it.

[13:50] <jnthn> True

[13:50] <jnthn> And if we have a Perl 6 way to write that, then we're OK I guess.

[13:50] <pmichaud> so it *is* possible to do it within the current binding semantics, we just need to officially declare that this is in fact what take does.

[13:50] <jnthn> I'm not a big fan of extending binding semantics just for take.

[13:50] <pmichaud> right

[13:51] <pmichaud> I'm pretty sure the existing binding semantics are (1) what we want and (2) adequate

[13:51] <pmichaud> I'm pretty sure the problem lies in the take API and/or model itself.

[13:51] <mathw> It seems to me that if nothing else wants to do that kind of thing, and take can do it itself, it should...

[13:51] <jnthn> I'm not too keen on making people know that they shouldn't give variables that exist between takes some extra thought, though.

[13:51] <pmichaud> mathw++

[13:51] <moritz_> maybe the problem is at another level

[13:51] <jnthn> But not entirely against it.

[13:51] <moritz_> afaict gatther() uses .push internally

[13:52] <pmichaud> it does not

[13:52] <moritz_> what does it do?

[13:52] <pmichaud> at least, not a p6 push

[13:52] <moritz_> it sounds like it's binding the new values into the array

[13:52] <moritz_> instead of assigning it 

[13:52] <pmichaud> ...array?

[13:52] <pmichaud> there's no array

[13:52] <moritz_> list

[13:52] <moritz_> sorry

[13:52] <pmichaud> one cannot assign into a list

[13:52] <pmichaud> a list doesn't have any containers of its own

[13:52] <jnthn> Anyway, +1 one what mathw said - if there's to be some magic, it belongs inside take.

[13:52] <pmichaud> it cannot have them

[13:53] <pmichaud> lists have to reference the original containers, otherwise  things like   .map cannot affect the values of the original list

[13:53] <colomon> oh, the reduce bug is actually a hyper bug.

[13:53] <pmichaud> s/affect the values/affect the containers/

[13:54] * moritz_ kinda thinks that .map affecting the original list is broken, but that's not the topic of the discussion

[13:54] <masak> I keep seeing people being surprised over and over again by values being changed *after* being put into the invisible gather list by &take. is there a sensible use case of when one would actually want those semantics?

[13:54] <pmichaud> moritz_: that's what enables       @foo.map( { $_ = ... } )    to work

[13:54] <moritz_> pmichaud: I know

[13:54] <masak> and I'm not talking about the bug here, just the normal behaviour of &take.

[13:58] <jnthn> masak: My feeling is most people don't expect take to work the way it currently does.

[13:58] <mathw> I certainly don't

[13:58] <moritz_> pmichaud: from a functional programming point of view it's ... very unusual, to say the best

[13:58] <mathw> I've been caught by that a lot

[13:58] <pmichaud> masak: we would want those semantics if we ever expect the results of a gather to act as lvalues

[13:58] <moritz_> and also from the view of separation of concerns

[13:58] <mathw> moritz_: my inner functional programmer says map operates on an immutable list, but this is Perl 6...

[13:58] <moritz_> mathw: right

[13:58] <masak> rakudo: my $i = 0; say (gather while $i++ < 10 { take $i }).perl

[13:58] <p6eval> rakudo 17e43e: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)␤»

[13:58] <masak> huh :)

[13:58] *** plobsing joined
[13:58] <moritz_> .map constructs a new list. it's job is not to alter the old one

[13:58] <moritz_> rakudo: my $i = 0; say (gather while ++$i < 10 { take $i }).perl

[13:58] <p6eval> rakudo 17e43e: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8, 9)␤»

[13:58] <masak> pmichaud: I wouldn't mind sacrificing the opportunity to treat the results as lvalues, if it led to more understandable semantics.

[13:58] <colomon> remember, you're talking about "for", too....

[13:58] <jnthn> I'd say that if we want to allow the lvalue case, it wants to be the exceptional, dehuffmanized case.

[13:58] <masak> isn't the above result *wrong* according to current spec?

[13:58] <jnthn> Not the default.

[13:58] <masak> jnthn: nod.

[13:58] <moritz_> colomon: I know. I've kinda become an extremist about that lately :-)

[13:58] <PerlJam> moritz_: so, you're saying map and for shouldn't be synonyms?

[13:58] *** ruoso left
[13:58] <moritz_> PerlJam: no. I'd be fine with 'for' not modifying the list either

[13:58] <jnthn> masak: I can certainly argue why the current behavior is "not surprising" but I can also completely understand that such arguments will mean nothing to the everyday user.

[13:58] <moritz_> there's still @a.=map for in-place modifications

[13:58] <pmichaud> that's actually different.

[13:58] <jnthn> masak: And that's who we should really be looking out for.

[13:58] <masak> jnthn: aye.

[13:58] <moritz_> pmichaud: I know

[13:58] <masak> jnthn: it's probably a symptom if lots of people fall into the same trap.

[13:58] <jnthn> masak: Right.

[13:58] <moritz_> but I don't think @larry is likely to make for/map immutable, so my point is moot

[13:59] <mathw> I think in the sense of the Perl world, it makes sense for map to see mutable values

[13:59] <jnthn> masak: If I hadn't seen that happen so much, I may have been tempted to argue for the current semantics. As it stands, so many people get bit by it I don't think that any argument in that direction will really hold any water.

[13:59] <pmichaud> okay, here's what I think (more)

[14:00] <pmichaud> I think that we should modify take so that it de-containerizes its parcel

[14:00] <pmichaud> in the p6 sense, this would be done as an operation on parcels

[14:00] <pmichaud> if someone wants to use take in an lvalue sense, that's what captures are for.

[14:00] <pmichaud> (end)

[14:01] <jnthn> lvalue is just a \ away

[14:01] <jnthn> pmichaud: +1 from me

[14:01] *** Zapelius left
[14:01] <pmichaud> well, not only that, but we could have a take_lvalue

[14:01] <pmichaud> which *doesn't* decontainerize the parcel

[14:01] <pmichaud> I mean, all that &take really does is throw the parcel as part of a "take exception"

[14:01] <jnthn> pmichaud: So long as we declare the "magic" is in take, not in the binding.

[14:01] <jnthn> (in the spec)

[14:01] <pmichaud> so I'm proposing that the new &take  decontainerize the parcel before it throws it.

[14:02] <jnthn> Right.

[14:02] <jnthn> That sounds workable.

[14:02] <jnthn> And explainable.

[14:02] <pmichaud> there are also several other places where it would be very handy to decontainerize a parcel

[14:02] <pmichaud> for example, it would make it possible to have array assignment have more lazy characteristics without having to worry about action-at-a-distance effects

[14:02] <pmichaud> (we might even be able to use it to make array assignment completely lazy)

[14:03] <pmichaud> right now there's a problem with something like

[14:03] <pmichaud> my @a = 1..foo(), $b

[14:03] <pmichaud> if 1..foo() ends up acting like something that halts mostly eager evaluation, we end up lazily evaluating $b

[14:03] <pmichaud> which could happen sometime after $b changes

[14:04] <masak> tricky.

[14:04] <pmichaud> but if we have a way of de-containerizing the Parcel

[14:04] <pmichaud> then the connection to $b goes away, leaving only its value at the time of the assignment

[14:04] <pmichaud> which means laziness is no longer an issue

[14:04] <pmichaud> WIN.

[14:04] <mathw> Ooh

[14:05] <mathw> Which could remove a lot of potential confusion around lazy semantics

[14:05] <Juerd> pmichaud: Does that use CoW somehow?

[14:05] <pmichaud> (it doesn't quite work with arrays still, though, because decontainerizing an array still leaves a mutable array.  Put another way, arrays *are* containers that can't be decontainerized.)

[14:05] <pmichaud> Juerd: it very well could be a CoW feature.

[14:05] *** patspam joined
[14:06] <mathw> Although I have only the vaguest notion of what 'de-containerising' is, it seems like a sensible idea in this context

[14:06] <pmichaud> that might make even more sense

[14:07] <pmichaud> if cow is something we can do to a Parcel, then take is really going to be taking advantage of that feature.

[14:07] <pmichaud> instead of "de-containerizing"

[14:07] <pmichaud> it's simply marking its values as cow

[14:08] <mathw> That's... very sensible

[14:08] <pmichaud> anyway

[14:09] <pmichaud> I see two choices

[14:10] <pmichaud> (1)  we can try to make &take act the way we think it should act, even though we don't yet know the correct underlying semantics

[14:10] <pmichaud> (2) we can leave &take the way it is now, so that people have to write code to explicitly make their intentions clear until the underlying semantics are known

[14:11] <pmichaud> the advantage of #1 is that take will seem more natural to people, but an underlying semantic change in the future may cause existing code to break

[14:11] <pmichaud> the advantage of #2 is that code that people write now will continue to work

[14:11] <pmichaud> (but people have to be burdened to realize that there's something spooky going on)

[14:11] <pmichaud> er, potentially spooky

[14:12] <mathw> It's probably not a good idea to change it without knowing what the right thing to change it to is.

[14:12] <jnthn> pmichaud: I think that with (1) we'll end up with Rakudo having semantics closer to how I expect things to end up than (2) would.

[14:12] <Juerd> "In the future", does that mean after Perl 6 is "done", or during the development process?

[14:13] <jnthn> pmichaud: That is, I don't think the final answer will be "people have to be burdened with the action-at-a-distance thing we have now"

[14:13] <jnthn> So even if we don't get the semantics spot on, they'd still be closer to the right ones than where we are now.

[14:14] <sjn> Juerd: "In the future" means whenever there's a change that has/needs to be made

[14:14] <moritz_> Juerd: I think it's hard for any of us to imagine what Perl 6 looks like when it's "done" :-)

[14:14] <Juerd> sjn: That's vague enough to always apply

[14:14] <PerlJam> pmichaud: who are the "people" in #2?  Are they mostly on #perl6?

[14:15] <sjn> Juerd: exactly (remember, perl6 is a _language_ - it will probably _never_ be "done")

[14:15] <Juerd> I just mean: currently, people *expect* Perl 6 to change, even fundamentally, but after a while it will just get on peoples nerves.

[14:15] <Juerd> sjn: Yeah yeah. That's why I used the "".

[14:15] <arnsholt> PerlJam: I think the assumption should be that users are not in #perl6

[14:16] <sjn> Juerd: yep, expect it to change, but also, expect the features that are much used/sensible/useful to become more stable

[14:16] <masak> there are quite a few Perl 6 users who have never been to #perl6.

[14:17] <moritz_> I was about to mention TheDamian, but in fact I've seen him here once :-)

[14:17] <sjn> Juerd: The more people use Perl6, the easier it's to figure out what what needs to be stable

[14:17] <PerlJam> sjn: everything :)

[14:17] <masak> PerlJam: eventually, yes.

[14:18] <masak> stabilizing things that aren't ready would cause more damage than letting them evolve first.

[14:18] <sjn> PerlJam: imo, "everything" is that nice ideal one can imagine right beyond the horizon. in the meantime, it's probably best to get there one step at a time

[14:19] <sjn> ...while figuring out what steps to make

[14:21] <Juerd> sjn: I think you're missing my point. Would the hypothetical incompatible change that pmichaud referred to in his option #1 be within the near future (before Perl 6 is widely deployed) or the remote future (when Perl 6 has a large user base)

[14:21] <sjn> aah

[14:21] <moritz_> I think we all hope "near future", but time predicitions have a tendency to be wrong

[14:21] <masak> Juerd: and would the change in semantics be associated with a version change, such as 6.0.0 -> 6.1.0?

[14:22] <sjn> nvm me then :)

[14:22] <moritz_> I dearly hope it would

[14:23] <masak> I wouldn't mind if 6.1 came fairly soon after 6.0, and contained changes of just that type. improvements, clarifications, new discoveries. nothing fancy, just progress.

[14:23] * moritz_ too

[14:23] <moritz_> erm

[14:23] * moritz_ neither

[14:24] <masak> it would look good on a history timeline, too :)

[14:24] <PerlJam> If jnthn is correct that the guessed semantics are close to the final semantics, then that future change might not be that big of a deal.  So ... how good are jnthn and pmichaud at guessing?

[14:24] *** xabbu42 joined
[14:24] <moritz_> and I hope that there will be a clear versioning scheme for incompatible changes vs. bug fixes

[14:24] <mathw> PerlJam: ask me in 100 years :)

[14:25] <PerlJam> wait ... when is Perl 6.0.0 going to be released?  Or are we calling that Rakudo*?

[14:25] <PerlJam> (they're still separate things to me)

[14:26] <jnthn> They're certainly separate things.

[14:26] <mathw> That's because they are separate things

[14:26] <PerlJam> oh good.  Then "we've got plenty of time"  :)

[14:26] <jnthn> My point was that when we have semantics that users constantly trip over, they tend to get changed.

[14:26] <jnthn> Currently we have semantics that users trip over and have the option to move to ones that should trip people up less.

[14:27] <jnthn> Or stay where we are.

[14:27] <jnthn> I'm just saying I think adopting ones that trip people up less feels more Perl 6-ish to me. :-)

[14:27] <mathw> TRipping users up before we even have any declaration of spec-stability is not good really is it :)

[14:28] <PerlJam> mathw: users should expect to be tripped up in the grey areas of the spec :)

[14:28] <mathw> I'd just say that you have to be fairly sure the change is going in the right direction, lest it ends up changing back again...

[14:30] <PerlJam> jnthn: Well, if you implement it, who's to say otherwise?  :)

[14:31] <pmichaud> let's look at it slightly differently

[14:31] <pmichaud> earlier this year, we had a list and iterator specification that got put into Rakudo ng

[14:31] <pmichaud> a lot of code was built on top of that specification...

[14:32] <pmichaud> which turned out to be completely unworkable.

[14:32] <pmichaud> it had some fundamental issues in dealing with "disappearing arrays" and the like.

[14:33] <pmichaud> so, we had to do some fairly deep analysis to determine the flaws in the model and come up with a new one, which makes a fairly different set of assumptions

[14:33] <pmichaud> and changes the list/iterator API substantially

[14:34] <pmichaud> so, if we move to make &take more dwimmy than it is now, my question is:  are we then storing up future problems when we discover that &take needs to do something fundamentally different?  Or do we think we can make a good enough guess?

[14:35] <pmichaud> it's a borderline decision for me.

[14:36] <pmichaud> I could go either way.

[14:36] * pmichaud thanks the crickets who remained through this presentation.  :)

[14:37] <colomon> I don't feel like I have a good enough understanding of the issues to take an informed vote. 

[14:38] <pmichaud> colomon: I think we're all in that boat.  :)

[14:38] <PerlJam> Do you think the "end semantics" for &take will have it such that the user must be really specific or that &take will be more dwimmy?

[14:38] <colomon> But I will say that I don't think we should be too afraid of making mistakes now.

[14:38] <pmichaud> colomon++

[14:38] <jnthn> I think that we probably wouldn't have got to the current, much better list semantics we have now without doing the last, wrong ones first.

[14:38] <pmichaud> PerlJam: I'm sure &take will be more dwimmy.  I just don't know what the dwimminess will look like.

[14:39] <PerlJam> Then I'm for option #1.  Make a best guess and go with it.

[14:39] <pmichaud> so, we could make a dwimmier &take, but somehow warn people that "hey, this isn't a solid specification yet, and if you really want to be safe you should do ..."

[14:39] <moritz_> There's also option #3, ask our Perl 6 oracle

[14:40] <pmichaud> moritz_: I'm speculating, but this issue has come up quite a bit before, and I'm guessing the oracle doesn't have a clear answer yet either.  :)

[14:40] <pmichaud> (like with lists/iterators)

[14:40] <pmichaud> jnthn++  # I agree, we probably wouldn't have arrived at the present model without first going through the wrong ones first.

[14:40] <PerlJam> But an implementation that "comes close" may help the oracle too  :)

[14:40] <pmichaud> yeah, I'm coming to that conclusion as well.

[14:40] <moritz_> like it did with iterators

[14:40] <pmichaud> okay.

[14:41] <pmichaud> I think we'll try fixing up &take  (hubris)  and see what happens.

[14:41] <pmichaud> probably post-release today :)

[14:41] <jnthn> hubris ftw

[14:41] <moritz_> indeed

[14:41] <PerlJam> pmichaud: what?  you mean you can't whip something up in 6 hours or so?

[14:41] <PerlJam> ;-)

[14:41] <pmichaud> PerlJam: I *can*, yes.

[14:41] <moritz_> without hubris I wouldn't have attempted callframe()

[14:41] <pmichaud> In fact, I think I could do this one in two.

[14:42] <masak> realizing that we don't have enough information to get everything right the first time, and daring to make mistakes now and correct them later, are two of the main reasons I like the Perl 6 developer community. the only way forward is successive iteration.

[14:42] <PerlJam> masak++ indeed!

[14:42] <pmichaud> but I reserved today for todo and ticket wrangling :)

[14:42] <pmichaud> and blog posting

[14:42] * mathw posts pmichaud two more hours

[14:43] <colomon> another release question: I'm convinced the current implementation of hyper is wrong.  

[14:44] <colomon> rakudo: say ([1, 2, 3] >>+<< [4, 5, 6]).perl

[14:44] <p6eval> rakudo 17e43e: OUTPUT«[[5, 7, 9]]␤»

[14:44] <colomon> I think I know how to fix, but I don't know if I can get it done in reasonable time this afternoon.

[14:44] <moritz_> rakudo: say ([1, 2, 3] >>+<< [4, 5, 6]).WHAT

[14:44] <p6eval> rakudo 17e43e: OUTPUT«Array()␤»

[14:44] <pmichaud> what's wrong about it?

[14:44] <colomon> Should we fudge the one failing test (the reduce.t one) and deal with it post-release?

[14:44] <cognominal> rakudo: (*)(1)

[14:44] <p6eval> rakudo 17e43e:  ( no output )

[14:45] <cognominal> rakudo: (*+*)(1,2)

[14:45] <p6eval> rakudo 17e43e:  ( no output )

[14:45] <colomon> pmichaud: if you feed it two arrays, it returns a nested array.

[14:45] <cognominal> rakudo: say (*+*)(1,2)

[14:45] <colomon> basically, it needs the map solution you suggested yesterday.

[14:45] <p6eval> rakudo 17e43e: OUTPUT«3␤»

[14:46] <moritz_> rakudo: say (1 >>+<< 2).perl

[14:46] <p6eval> rakudo 17e43e: OUTPUT«[3]␤»

[14:46] <moritz_> ah

[14:46] <moritz_> it always returns an array

[14:46] <colomon> moritz_: exactly.

[14:46] <moritz_> and if the arguments happen to be arrays, it recurses into them

[14:46] <pmichaud> oh, that seems fixable

[14:46] <pmichaud> just a sec

[14:46] <moritz_> woulden't a  return |@result; in the end fix that?

[14:47] <pmichaud> they shouldn't be arrays at all.

[14:47] <moritz_> (might be a naiive idea)

[14:47] <pmichaud> they should be lists

[14:47] <moritz_> parcels?

[14:47] <pmichaud> or parcels, yes.

[14:47] <moritz_> note that hyper is not lazy

[14:47] <moritz_> it's the opposite :-)

[14:47] <colomon> actually, hyper should return the same type it got in, by spec.

[14:47] <pmichaud> that's fine, there's still the issue that putting lists into arrays collapses structure.

[14:48] <colomon> so pass it two lists, you should get a list back

[14:48] <colomon> pass it two arrays, you should get an array back

[14:48] <pmichaud> rakudo:  say ((1,2,3) >>+<< (4,5,6)).perl

[14:48] <p6eval> rakudo 17e43e: OUTPUT«[5, 7, 9]␤»

[14:48] <pmichaud> oh

[14:48] <moritz_> that seemsm kinda scary, from an implementation point of view

[14:48] <pmichaud> then yes, I'd try  return |@result

[14:48] <moritz_> (preserving list type)

[14:49] <colomon> moritz_: it goes much, much deeper than that.

[14:49] <colomon> if you pass it any Iterable, it's supposed to be able to do its thang and then return an object of that type.

[14:49] <colomon> Sets, Bags, whatever.

[14:49] <masak> colomon: what about when the types don't match?

[14:50] <ash__> rakudo: my $a = eval '{  sub foo { 1 + 3 }  }; return &foo'; say ~$a() # do i have something wrong in that? 

[14:50] <p6eval> rakudo 17e43e: OUTPUT«invoke() not implemented in class 'Seq'␤  in main program body at line 11:/tmp/dz8TCW5Ost␤»

[14:50] <pmichaud> ash__: subs are lexically scoped by default.

[14:50] <pmichaud> also, you have a return outside of any sub.

[14:51] <colomon> masak: I don't think it's supposed to work in that case.

[14:51] <ash__> well, i was trying to figure out how to get the eval to return the sub after its been defined 

[14:51] <moritz_> rakudo: my $a = eval '{  sub foo { 1 + 3 }  }; &foo'; say $a()

[14:51] <p6eval> rakudo 17e43e: OUTPUT«invoke() not implemented in class 'Seq'␤  in main program body at line 11:/tmp/09dRar5bVV␤»

[14:51] <colomon> whoops, belay that

[14:51] <colomon> Seq(3,8,[2,Seq(9,3)],8) >>->> (1,1,2,1); # Seq(2,7,[0,Seq(7,1)],7

[14:51] <moritz_> rakudo: my $a = eval 'sub foo { 1 + 3 }; &foo'; say $a()

[14:51] <pmichaud> there's still no &foo in scope.

[14:51] <p6eval> rakudo 17e43e: OUTPUT«4␤»

[14:51] <moritz_> right

[14:51] <moritz_> better

[14:52] <colomon> anyway, I've no idea how to make that work for arbitrary types yet, but it probably should work for lists and arrays.

[14:52] <ash__> ah, okay, i see what  i did wrong, thanks moritz_++ pmichaud++

[14:52] <colomon> I don't think implementing it is a multi-day project, but I don't know if it's a release-time project.  :)

[14:52] <pmichaud> colomon: I'm fine with fudging the one test for the release and working on it a bit later.

[14:52] <moritz_> colomon: the obvious (and probably wrong) approach  is to coerce the return type

[14:52] <pmichaud> (if I wasn't fine with it, I wouldn't have merged the branch to trunk :)

[14:52] <moritz_> @result."$input.WHAT.perl()"() # URKS

[14:53] *** broquaint joined
[14:53] <pmichaud> $input.WHAT(@result)  # better?

[14:53] <moritz_> what does that do?

[14:54] <pmichaud> same as  Dog(...)

[14:54] <moritz_> really?

[14:54] <pmichaud> (assuming $input is a Dog)

[14:54] <pmichaud> might need parens

[14:54] <pmichaud> ($input.WHAT)(@result)

[14:54] <moritz_> runtime error in rakudo in both cases? :-)

[14:54] <pmichaud> it doesn't work *yet*

[14:54] <pugssvn> r31332 | colomon++ | [t/spec] Fudge test which fails because of hyper issues. 

[14:54] <colomon> afk # exercise!

[14:54] <moritz_> ah, with parens it makes more sense

[14:55] <pmichaud> we haven't fixed up postcircumfix:<( )> on our type objects yet, I don't think.

[14:55] <moritz_> it's also a parsing issue

[14:55] <moritz_> rakudo: Int()

[14:55] <p6eval> rakudo 17e43e: OUTPUT«Could not find sub &Int␤  in main program body at line 11:/tmp/dVRMfwD9mU␤»

[14:55] <pmichaud> yes, that too, although  ($input.WHAT)(...)   wouldn't be a parsing issue :)

[14:56] <moritz_> that kind of type coercion has the advantage of also working with anonymous classess too

[14:56] <pmichaud> right.

[14:56] <pmichaud> We aim to allow anonymity these days.  :)

[14:56] <moritz_> wheres $output."$input.WHAT.perl()" is simply FAIL in those cases

[14:58] *** plobsing left
[14:59] <colomon> pmichaud: is "for" still eager, or did it become lazy in the Great List Revamp?

[14:59] *** ash__ left
[14:59] <pmichaud> it's still eager.

[14:59] <pmichaud> I haven't changed it to use .map yet.

[14:59] <pmichaud> (need sink context for that first)

[14:59] *** rhr joined
[14:59] <jnthn> er, I had TypeObject($foo) as being essentially sugar for $foo."{TypeObject}"()

[15:00] <pmichaud> I think it was discussed before and declared that it's not syntactic

[15:00] <jnthn> I didn't say it was syntactic.

[15:00] <pmichaud> it's invocationon the TypeObject

[15:00] <jnthn> Right

[15:00] <jnthn> Which (at least by default, unless overridden) does the mapping I just mentioned.

[15:01] <pmichaud> that's weird.

[15:01] <pmichaud> I would just expect it to be handled in the dispatcher.

[15:01] <jnthn> huh?

[15:01] *** macdaddy joined
[15:01] <pmichaud> (maybe not in the dispatcher, but via normal dispatch)

[15:01] <jnthn> Oh, I wasn't advocating otherwise.

[15:01] <pmichaud> oh, you're saying that postcircumfix:<( )> does the method call?

[15:02] <pmichaud> maybe.

[15:02] <jnthn> I was saying that's what...yes, right.

[15:02] <moritz_> jnthn: it's a reasonable default implementation for named types that are available in all scopes

[15:02] <pmichaud> yeah, I'm not sure it's going to stand, but it's okay for now :)

[15:02] <jnthn> Me either, it's just the answer I got last time I asked, iirc.

[15:04] <pmichaud> afk, lunch

[15:05] *** am0c joined
[15:05] *** tadzik left
[15:06] * jnthn -> walk, shopping

[15:07] <PerlJam> y

[15:12] *** ash__ joined
[15:13] *** xinming_ joined
[15:15] <snarkyboojum> rakudo: my$a=42; say $a

[15:15] <p6eval> rakudo 17e43e: OUTPUT«42␤»

[15:16] *** xinming left
[15:16] <snarkyboojum> rakudo: my$a=42;$a.say

[15:16] <p6eval> rakudo 17e43e: OUTPUT«42␤»

[15:17] <snarkyboojum> didn't realise spaces weren't needed between my and variables

[15:17] <masak> std: my$a=42

[15:17] <p6eval> std 31325: OUTPUT«ok 00:01 105m␤»

[15:17] <masak> std: my($a,$b)

[15:17] <p6eval> std 31325: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $a is not predeclared at /tmp/cnruvy4SFH line 1:␤------> [32mmy($a[33m⏏[31m,$b)[0m␤Variable $b is not predeclared at /tmp/cnruvy4SFH line 1:␤------> [32mmy($a,$b[33m⏏[31m)[0m␤Undeclared routine:␤  'my' used at line 1␤Check

[15:17] <p6eval> ..failed␤FAILE…

[15:18] <snarkyboojum> or I did and forgot

[15:18] *** xabbu42_ joined
[15:18] *** xabbu42 left
[15:18] *** xabbu42_ is now known as xabbu42

[15:18] <masak> snarkyboojum: Yapsi supports it too :)

[15:19] *** kensanata joined
[15:19] *** TiMBuS left
[15:20] <snarkyboojum> masak: yapsi++ :)

[15:20] <masak> buubot: karma yapsi

[15:20] <buubot> masak: yapsi has karma of 1      

[15:20] *** am0c left
[15:20] <masak> \o/

[15:20] <snarkyboojum> heh

[15:22] <cono> yapsi++

[15:23] <snarkyboojum> well, it's goodnight from me

[15:23] <snarkyboojum> masak: good luck with the release :)

[15:23] <masak> snarkyboojum: thanks! good night.

[15:24] *** snarkyboojum left
[15:28] <JimmyZ> what does "5 but 'string'" mean?

[15:29] <JimmyZ> it's in the changelog

[15:29] <cono> JimmyZ: adding to Int class methods of 'string'

[15:29] <masak> er, no.

[15:30] <ash__> but is like does 

[15:30] <ash__> but not exactly 

[15:30] <masak> adding to *that object* the capabilities of a Str.

[15:31] <arnsholt> So the object behaves like 'string' for Str stuff, but 5 for Numeric stuff?

[15:31] <cono> JimmyZ: good examples in S12-objects /Enumeration

[15:31] <masak> 'but' attaches run-time properties to individual objects.

[15:32] <masak> I think it does so by returning a new object, not by changing an existing one.

[15:32] <JimmyZ> oh, 'but' keyword

[15:34] <ash__> i don't think it works yet though 

[15:34] <masak> rakudo: say (5 but "OH HAI").Str

[15:34] <p6eval> rakudo 17e43e: OUTPUT«OH HAI␤»

[15:34] <masak> \o/

[15:34] <cono> rakudo: enum Day <Sun Mon Tue Wed Thu Fri Sat>; my Str $day = 'Today' but Tue; $day.Day.say

[15:34] <p6eval> rakudo 17e43e: OUTPUT«Method 'Day' not found for invocant of class ''␤  in main program body at line 11:/tmp/ck0SNsGudk␤»

[15:34] <ash__> ah, i was using it wrong 

[15:34] <cono> :(

[15:35] <masak> ash__: no, you're using it right.

[15:35] <masak> ash__: but it doesn't work yet for enums.

[15:35] <moritz_> rakudo: say ('foo' but 5) + 5

[15:35] <p6eval> rakudo 17e43e: OUTPUT«5␤»

[15:36] <ash__> rakudo: say 42 but 'the answer' # shouldn't that print "the answer" ?

[15:36] <p6eval> rakudo 17e43e: OUTPUT«42␤»

[15:36] <cono> like in p5 we can store int and str value in scalar :)

[15:37] <cono> but in p5 throw the guts

[15:38] <ash__> 5 but 'string' is the same as 5 but (role { method Str() { 'string'} }), 5 but True is 5 but (role { method Bool() { True } })

[15:38] <colomon> rakudo: say ('foo' but 5) ~~ Real

[15:38] <p6eval> rakudo 17e43e: OUTPUT«0␤»

[15:39] <colomon> rakudo: say ('foo' but Real) ~~ Real

[15:39] <p6eval> rakudo 17e43e: OUTPUT«1␤»

[15:39] <colomon> rakudo: say ('foo' but 5) ~~ Real

[15:39] <p6eval> rakudo 17e43e: OUTPUT«0␤»

[15:39] <masak> rakudo: say 5 ~~ Real

[15:39] <p6eval> rakudo 17e43e: OUTPUT«1␤»

[15:39] *** xabbu42 left
[15:39] <colomon> rakudo: say ('foo' but 5.0) ~~ Real

[15:39] <p6eval> rakudo 17e43e: OUTPUT«0␤»

[15:39] *** xabbu42 joined
[15:39] * masak submits rakudobug

[15:39] <ash__> i think but is close but not exactly right... 

[15:39] <ash__> rakudo: say ('foo' but 5.0).Num ~~ Real

[15:39] <p6eval> rakudo 17e43e: OUTPUT«1␤»

[15:40] <masak> rakudo: say 'foo'.Num ~~ Real

[15:40] <p6eval> rakudo 17e43e: OUTPUT«1␤»

[15:40] <masak> :)

[15:40] <cono> :)

[15:40] <cono> Str have Num method?

[15:40] <masak> cono: yes, it's Cool.

[15:41] *** JimmyZ left
[15:41] <cono> Any is Cool? :)

[15:41] <masak> no.

[15:41] <ash__> rakudo: say ('foo' but 5.0).Num

[15:41] <p6eval> rakudo 17e43e: OUTPUT«0␤»

[15:41] <TimToady> Cool is Any

[15:41] <ash__> :-\

[15:42] <cono> Any base all over the p6 world? :D

[15:42] <ash__> rakudo: say ('foo' but 5).Num, ('foo' but 5).Int

[15:42] <p6eval> rakudo 17e43e: OUTPUT«05␤»

[15:42] <TimToady> Mu

[15:42] <cono> ah

[15:42] <cono> Mu -> Any -> Cool ? :D

[15:42] <masak> rakudo: say Int ~~ Real

[15:42] <p6eval> rakudo 17e43e: OUTPUT«1␤»

[15:43] <ash__> cono: thats commonly the case, yes but there are some things that don't follow that, but Mu is always the base 

[15:43] <moritz_> right

[15:43] <moritz_> with the exception of objects from other HLLs

[15:44] <TimToady> we will probably make them derive from Mu too :)

[15:44] <cono> in Any.pm, no inheritance..

[15:44] <ash__> rakudo: say Str.^parents

[15:44] <p6eval> rakudo 17e43e: OUTPUT«Cool()Any()Mu()␤»

[15:44] <cono> ash__: wow

[15:45] <moritz_> cono: src/builtins/Any.pir

[15:45] <moritz_> Your branch is behind 'origin/master' by 155 commits, and can be fast-forwarded.

[15:45] <moritz_> sorry, wrong paste

[15:45] <moritz_>     anyproto = p6meta.'new_class'('Any', 'parent'=>'Mu')

[15:45] <cono> moritz_: augment meanse that it extends from pir clas ?

[15:45] <moritz_> yes

[15:45] <cono> ty

[15:45] <moritz_> existing class in general

[15:46] <cono> ah

[15:46] <cono> everywhere ?

[15:46] <moritz_> yes

[15:46] <cono> ok, thanks :)

[15:46] <ash__> rakudo: use MONKEY_TYPING; augment class Int { method foo { 'foo' } }; say 5.foo

[15:46] <p6eval> rakudo 17e43e: OUTPUT«foo␤»

[15:46] <cono> wow, awesome feature :)

[15:48] <TimToady> well, in Ruby it's a Way of Life

[15:48] *** [mark] left
[15:48] <ash__> same in python, all classes just let you tack stuff on 

[15:49] <cono> new OO feature :)

[15:49] <ash__> you can extend classes in Obj-C and Smalltalk too 

[15:49] <PerlJam> Is Perl 6 the only language that discourages it somewhat?

[15:49] <cono> I like p5 OO feature: @ISA[0,1] = @ISA[1,0]; $self->SUPER::print(); :D

[15:50] <moritz_> "feature"

[15:51] <ash__> PerlJam: no, in Obj-C its not that easy either, you have to extend the category of the object you want to change, (its more akin to adding a role at runtime) 

[15:51] <cono> e.g.: I can sort DB objects by load in @ISA and call $self->SUPER::select

[15:52] <PerlJam> cono: you're a strange one  :)

[15:52] <cono> i'm :D

[15:52] <ash__> PerlJam: also in python if you declare your class to have __slots__ it can only have those specific slots filled so you cant append anything you want, but the default behavior is that objects are open  

[15:59] <ciphertext> http://nopaste.snit.ch/21332 <-- patch to fix &infix:<...>    passes all tests in t/spec/S03-operators/series* +1 TODO

[15:59] *** REPLeffect joined
[16:00] <cono> ciphertext: rakudobug with [PATCH] I guess

[16:01] <ciphertext> well, we were talking about it earlier, so i wanted to post it here, where it'll be seen faster

[16:01] *** Ross joined
[16:02] <ciphertext> *we = masak, moritz_ and i

[16:02] <cono> :)

[16:02] <cono> say we[0] :D

[16:03] <ciphertext> o.O except for the improper sigil on we, it's actually valid perl6 (assuming masak, moritz_ and i are functions)

[16:04] *** cdarroch joined
[16:04] *** cdarroch left
[16:04] *** cdarroch joined
[16:04] <sorear> TimToady: ping

[16:04] <sorear> TimToady: What was your reason for thinking viv would ditch YAML?

[16:05] <cono> ciphertext: perl is speaking language :D

[16:05] * TimToady resolves into a Schrödinger's person

[16:05] <cono> cat? :D

[16:07] <TimToady> sorear: I was just thinking that we would generally emit data structures natively in whatever was the target language, especially if they could be precompiled

[16:08] <cono> rakudo: ([/] 1, 2, 3).perl.say

[16:08] <p6eval> rakudo 17e43e: OUTPUT«1/6␤»

[16:08] <TimToady> sorear: but YAML is fine as a generic solution

[16:09] *** REPLeffect left
[16:09] <TimToady> also, not all targets will necessarily support YAML well

[16:09] <TimToady> that's all

[16:10] <masak> swim &

[16:10] <TimToady> I don't hate YAML

[16:10] <TimToady> except when I do...

[16:10] *** masak left
[16:10] *** REPLeffect joined
[16:16] <sorear> TimToady: the YAML version also loads faster, by 0.1 second

[16:17] *** Trashlord joined
[16:18] *** REPLeffect left
[16:18] *** REPLeffect joined
[16:20] <pmichaud> back from lunch

[16:21] *** envi^home left
[16:22] <[Coke]> pmichaud: ~~

[16:26] *** xabbu42_ joined
[16:26] *** xabbu42 left
[16:26] *** xabbu42_ is now known as xabbu42

[16:29] *** meppl joined
[16:30] <colomon> ciphertext: is all that scmp stuff solely meant to support handling series with single character endpoints?

[16:31] <ciphertext> colomon: yeah

[16:33] <colomon> seems like it would be cleaner to detect those as a special case, convert the series to a numeric series based on the .ord values, and then map the resulting numeric series back through .chr?

[16:34] <ciphertext> hmm

[16:35] <ciphertext> actually, it's not 'single character' endpoints that are the problem.

[16:35] <ciphertext> rakudo: say 'z' cmp 'aa'

[16:35] <p6eval> rakudo 17e43e: OUTPUT«1␤»

[16:36] <ciphertext> the problem is that cmp compares in lexicographic order, but series go in a more number-like order (i.e. shorter strings come first, then compare alphabetically)

[16:37] <colomon> ciphertext: where does it say that?

[16:39] <pmichaud> it seems to me that the spec is fairly straightforward, and we should simply follow the spec.

[16:39] <pmichaud> (I grant I might be missing something here.)

[16:40] <colomon> pmichaud: right, I'm trying to figure out if I'm missing something.

[16:42] <ciphertext> huh... i guess it doesn't say that.  I'm not sure where i got it.

[16:42] <pmichaud> ciphertext: it *used* to be a problem, but the new series specification seems to clear that up a bunch.  TimToady++

[16:43] *** charsbar joined
[16:43] <colomon> I think we clearly need more series tests here.

[16:44] *** charsbar_ left
[16:45] *** rv2733 joined
[16:45] <colomon> pmichaud: can you think of any objection to my ".ord the inputs, run series on the numbers, and map .chr the outputs" solution to the single character string issue in series?

[16:45] <pmichaud> you mean like....

[16:45] <colomon> that seems to me to be the cleanest way to implement TimToady's { $^prev.ord.succ.chr } 

[16:45] <pmichaud> isn't that exactly what that says?  ;-)

[16:46] <colomon> afk # diaper change

[16:46] <pmichaud> if you're thinking of .ording the inputs in advance, it's wrong.

[16:47] <sorear> perl6: foo; my &foo := sub () { say "HI" }

[16:47] <p6eval> rakudo 17e43e: OUTPUT«invoke() not implemented in class 'Any'␤  in main program body at line 11:/tmp/ggq4IwbTH4␤»

[16:47] <p6eval> ..pugs: OUTPUT«*** Cannot use Undef as a Code object␤    at /tmp/ESC2EjTNI0 line 1, column 1-4␤»

[16:47] <p6eval> ..elf 31332: OUTPUT«/home/p6eval/pugs/misc/STD_red/match.rb:141:in `block in to_dump0': undefined method `to_dump0' for true:TrueClass (NoMethodError)␤    from /home/p6eval/pugs/misc/STD_red/match.rb:140:in `each'␤       from /home/p6eval/pugs/misc/STD_red/match.rb:140:in `map'␤        from

[16:47] <p6eval> ../home/p6eval/pugs/misc/STD…

[16:47] *** Guest99875 left
[16:48] *** kensanata left
[16:50] *** REPLeffect left
[16:50] <sorear> S06 doesn't say anything about that example

[16:50] *** ruoso joined
[16:52] <sorear> TimToady: Are sub statements run at an advanced phase in Perl 6, like they are in 5?

[16:52] <sorear> Which S covers this, if any?

[16:52] <jnthn> I suspect Pugs and Rakudo are correct on this one.

[16:52] <pmichaud> named sub declarations are, yes.  

[16:52] <pmichaud> but the binding is runtime, iiuc

[16:52] *** bbkr left
[16:52] <jnthn> Right, that's the distinction.

[16:53] *** bbkr joined
[16:53] <jnthn> That's an anonymous sub being explicitly bound.

[16:53] <jnthn> At runtime rather than "compile time".

[16:53] *** xabbu42_ joined
[16:53] *** xabbu42 left
[16:53] *** xabbu42_ is now known as xabbu42

[16:53] <PerlJam> does ::= still do compile time binding?

[16:53] <pmichaud> no

[16:53] <sorear> so if I said my &foo; BEGIN { &foo := ... }, it would be correct, and more or less equivalent to a sub statement, yes?

[16:54] <pmichaud> PerlJam: ::= is binding and make it read-only

[16:54] <ciphertext> colomon: the ordering comes from the specification of autoincrement operators on chars, rather than the series specification.  my $a = 'z'; $a++;   $a == 'aa'; 

[16:55] <pmichaud> ciphertext: but it's different for single character endpoints

[16:56] <ciphertext> what do you mean?

[16:57] <pmichaud> 'A' ... 'z'   will follow the codepoint sequence, not the string iteration one

[16:57] <PerlJam> pmichaud: er, what exactly is the "it" in that sentence?  my $a ::= 5;  # $a can't be re-bound? or just that $a's value can't change?

[16:57] <cono> eval: my $a = "z"; ++$a

[16:57] <jnthn> sorear: I believe yes.

[16:57] * colomon is back

[16:57] <jnthn> rakudo: my $a = "z"; say ++$a

[16:57] <p6eval> rakudo 17e43e: OUTPUT«aa␤»

[16:58] <colomon> okay, the single character endpoints case should be easy.

[16:58] <cono> I wanted p5 :D

[16:58] <cono> but buubot keep silence :(

[16:58] <pmichaud> i.e., in the series  'A' ... 'z', the thing that comes after 'Z' will be '[' and not 'AA'

[16:58] <colomon> oh, except for the extra broken series sub.  Hmmm.

[16:59] <ciphertext> pmichaud: the spec says "but since 'Z' increments to 'AA', none of these ever terminate: 'A' ... 'zz' "

[16:59] <pmichaud> ciphertext: sure, but that's not a single-character endpoint

[17:00] <colomon> ciphertext: single-characters (on both endpoints!) is a special case

[17:00] <jnthn> rakudo: sub foo() { try { my $r = eval ' 42 '; return $r }; }; say foo()

[17:00] <p6eval> rakudo 17e43e: OUTPUT«Null PMC access in type()␤  in main program body at line 11:/tmp/UVXgTJRGsR␤»

[17:00] <ciphertext> oh. skipped over a paragraph.  i see it now

[17:03] <ciphertext> yeah, we need more tests. :p   the scmp operator in my patch is used to correctly determine endpoints in string iteration order.  It doesn't even consider the single-character exception.

[17:03] <ciphertext> oddly, 'A' ... 'z' == 'A' ... 'Z'

[17:03] <dalek> rakudo: 96af91d | pmichaud++ | src/Perl6/Actions.pm:

[17:03] <dalek> rakudo: Remove fossil:  'for' should use &flat on its source, not &eager.

[17:03] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/96af91db7fc9c3cdbbd43fa7a392d1054503d96a

[17:03] <pmichaud> uh, no.

[17:04] <pmichaud> not any more.

[17:04] <ciphertext> i meant, that's how my version currently (and incorrectly) works

[17:04] *** dakkar left
[17:04] <pmichaud> okay.

[17:04] <ash__> rakudo: sub foo { try { return 13213 }; return 1 }; say foo; # is that right? 

[17:04] <p6eval> rakudo 17e43e: OUTPUT«1␤»

[17:04] <pmichaud> yes, the old way has always bugged the heck out of me about ranges.

[17:05] <colomon> pmichaud: it's officially wrong in ranges, too.

[17:05] <colomon> just haven't changed the code yet.

[17:05] <pmichaud> right

[17:05] <pmichaud> I suspect that Ranges should just delegate to the series operator.

[17:05] <colomon> well, actually, we did change the code, in the list branch.

[17:05] <pmichaud> (since that's what the specification says)

[17:05] <colomon> pmichaud: yeah, I was wondering about that yesterday.

[17:05] <colomon> the specification still says there's a RangeIter.

[17:06] <colomon> it just is supposed to behave exactly like the series operator.

[17:06] <pmichaud> ...and, as followup to that, I suspect that the series operator should be smart enough to generate RangeIter

[17:06] <pmichaud> when it's appropriate to do so

[17:06] <colomon> okay, that hurts my head.

[17:06] <pmichaud> and I also suspect that RangeIter in the synopsis could be considered a fossil if we determine we really don't need one

[17:06] <pmichaud> i.e., the existence of "RangeIter" could be considered to be a leftover from the old incorrect way of looking at iterators.

[17:07] <pmichaud> colomon: really?  I would just think that certain special cases of the series operator shortcut to do something different.

[17:07] <pmichaud> could even potentially be done with multisubs on &infix:<...>

[17:07] <ash__> try doesn't catch CONTROL exceptions does it? 

[17:07] <pmichaud> (although probably not)

[17:08] <pmichaud> ash__: Rakudo has known issues with 'return' in closures.

[17:08] <colomon> pmichaud: when I mentioned getting rid of it yesterday to TimToady, he suggested there may be efficiency reasons to keep RangeIter.

[17:08] <pmichaud> colomon: I agree

[17:08] <ash__> okay, just checking that is a bug

[17:08] <colomon> I wonder if we might really want a SeriesIter, and then have Range delegate to it.

[17:08] <pmichaud> I'm just saying that it's &infix:<...> that creates a RangeIter

[17:08] *** Wolfman2000 left
[17:09] <colomon> pmichaud: obviously that can work, but it really seems needlessly confusing to me.

[17:09] <pmichaud> I can envision that we would have different types of *Iter depending on the series that needs to be generated

[17:09] <pmichaud> I think there's the same amount of complexity no matter what is done (more)

[17:09] *** clintongormley joined
[17:09] <pmichaud> either you have one type of iterator that tries to do everything

[17:09] <pmichaud> or you have several iterators that each do one thing well, and you select among them

[17:10] <colomon> well, I vote we worry about getting it correct using gather / take, and then worry about efficiency afterward.

[17:10] <pmichaud> wfm

[17:10] <pmichaud> I'm just saying that the gather/take approach may itself be fairly complex

[17:10] <pmichaud> if (...) { gather/take 1 }

[17:10] <pmichaud> elsif (...) { gather/take 2 }

[17:10] <pmichaud> elsif (...) { gather/take 3 }

[17:10] <pmichaud> ...

[17:10] <pmichaud> also looks complex to me

[17:11] <colomon> I don't think it is.

[17:11] <pmichaud> if it can be cleanly done with a single gather/take,, then that'd be fine with me.

[17:11] <pmichaud> I'll be glad to review the code when it's ready.  :)

[17:11] <colomon> :)

[17:12] <colomon> At the moment, I'm still trying to get rid of the fossil infix:<...> we had sitting around confusing matters.

[17:12] *** thebird left
[17:12] <pmichaud> yes.

[17:14] <colomon> ack.

[17:14] <colomon> the fix for 4 ... ^5 was only ever added to the fossil one.  so...

[17:15] <colomon> rakudo: say ~(4 ... ^5)

[17:15] <p6eval> rakudo 17e43e: OUTPUT«4 3 2 1 0 1 2 3 4␤»

[17:15] <colomon> rakudo: say ~(4, 3 ... ^5)

[17:15] <p6eval> rakudo 17e43e: OUTPUT«4 3 2 1␤»

[17:15] <dalek> rakudo: 7df145b | jimmy++ | src/core/metaops.pm:

[17:15] <dalek> rakudo: removed unused code

[17:15] <dalek> rakudo: Signed-off-by: Moritz Lenz [email@hidden.address]
[17:15] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7df145bb759732790b15400f17afc6c148b0ad1c

[17:15] <dalek> rakudo: 1cfec1c | moritz++ | src/Perl6/Actions.pm:

[17:15] <dalek> rakudo: Merge branch 'master' of github.com:rakudo/rakudo

[17:15] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1cfec1cbdc4e7e0af8baa7c8a529466096a12fab

[17:16] <pmichaud> 7df145b might not be safe.

[17:17] <colomon> pmichaud: nah, it should be good.

[17:17] *** SmokeMachine left
[17:17] <colomon> unless &op somehow returns $b directly?

[17:17] <pmichaud> right.

[17:17] <pmichaud> some ops could do that.

[17:17] <colomon> in which case the code was wrong anyway.

[17:17] <colomon> ah.

[17:20] <colomon> pmichaud: can you fix that one?  I'm knee-deep in series...

[17:20] <pmichaud> it can stand for now... we just might get bitten by it at some point.

[17:21] <ciphertext> colomon, pmichaud: new patch: http://nopaste.snit.ch/21333

[17:21] <pmichaud> also, I prefer the new version, and assuming we fix &take, it'd be okay.

[17:21] *** xabbu42_ joined
[17:21] *** xabbu42 left
[17:21] *** xabbu42_ is now known as xabbu42

[17:21] <ciphertext> i haven't tested it much yet

[17:22] <colomon> ciphertext: I'm very confused how this patch is supposed to work?

[17:22] <colomon> and I'm fairly certain scmp is the wrong approach.

[17:23] *** REPLeffect joined
[17:23] <colomon> ah, I see the single char version now.  That's sensible.

[17:26] <ciphertext> re: scmp... i'm not particularly fond of it either, but i don't know of another way to make sure that 'Z' comes before 'AA', for example.

[17:27] <colomon> if you look at the Spec, there are very specific rules for handling those cases, none of which involve comparing string lengths.

[17:28] <pmichaud> the spec has eliminated string length from the equation altogether.

[17:28] <pmichaud> (other than the 1-character endpoint case)

[17:28] <pmichaud> so if you're relying on length for something... it's probably wrong.

[17:29] <pmichaud> also, is &infix:<scmp> a part of the spec?

[17:29] <pmichaud> if no, then it may need removal.

[17:32] <ciphertext> no.  scmp isn't spec.   I tried to hide it using moritz_  {my sub &infix:scmp() ... our sub &infix<...> ... }, but it wouldn't compile...  right now, however, I think i get how to do without scmp

[17:32] <pmichaud> right

[17:32] <pmichaud> it looks to me like the spec simply uses before, after, and eq

[17:32] <ciphertext> related to the single character case:

[17:33] <ciphertext> rakudo: say 'ü'.chars

[17:33] <p6eval> rakudo 17e43e: OUTPUT«1␤»

[17:33] <ciphertext> ... well i got '2' on my system

[17:33] <moritz_> on the REPL?

[17:33] <pmichaud> some repls don't read utf-8 properly.

[17:33] <moritz_> don't trust it in Unicode questions

[17:33] <pmichaud> to test it you really have to put it in a file and test it.

[17:33] <ciphertext> ok. i'll try that.

[17:33] <moritz_> mine for example

[17:34] <Tene> ciphertext: why don't you just use a function instead of defining an operator?

[17:34] <moritz_> is there an easy for that?

[17:34] <pmichaud> or even a my sub within &infix:<...>

[17:34] *** xabbu42_ joined
[17:34] *** xabbu42 left
[17:34] *** xabbu42_ is now known as xabbu42

[17:34] <Tene> right.

[17:34] <pmichaud> anyway, I'm speculating that "scmp" isn't needed at all.

[17:35] <ciphertext> k, in a file, 'ü' works correctly.

[17:37] <colomon> rakudo: my $a = *; say $a ~~ Whatever; say $a.list ~~ Whatever

[17:37] <p6eval> rakudo 17e43e: OUTPUT«0␤0␤»

[17:37] <colomon> rakudo: my $a = *; say $a.WHAT

[17:37] <p6eval> rakudo 17e43e: OUTPUT«Any()␤»

[17:37] <colomon> er?

[17:37] <colomon> rakudo

[17:38] <pmichaud> rakudo:  say (my $a = *).WHAT

[17:38] <p6eval> rakudo 17e43e: OUTPUT«Block()␤»

[17:38] <pmichaud> uh oh.

[17:38] <moritz_> that's a weird and reported bug

[17:38] <pmichaud> or is that supposed to be turned into a whatever block?  ;-)

[17:38] <colomon> rakudo: sub tellme($a) { say $a.WHAT; }; tellme(*);

[17:38] <p6eval> rakudo 17e43e: OUTPUT«Whatever()␤»

[17:38] <pmichaud> it's not wierd, it's just currying &infix:<=>

[17:38] <pmichaud> *weird

[17:38] <colomon> rakudo: sub tellme($a) { say $a.WHAT; say $a ~~ Whatever; say $a.list ~~ Whatever }; tellme(*);

[17:38] <p6eval> rakudo 17e43e: OUTPUT«Whatever()␤1␤0␤»

[17:38] <pmichaud> the question is whether it should be doing that.

[17:39] <colomon> surely not?

[17:39] <colomon> rakudo: sub tellme($a) { say $a.WHAT; say $a ~~ Whatever; say $a.list.perl }; tellme(*);

[17:39] <p6eval> rakudo 17e43e: OUTPUT«Whatever()␤1␤{ ... }␤»

[17:39] <colomon> rakudo: sub tellme($a) { say $a.WHAT; say $a ~~ Whatever; say $a.list.WHAT }; tellme(*);

[17:39] <p6eval> rakudo 17e43e: OUTPUT«Whatever()␤1␤Block()␤»

[17:39] <pmichaud> colomon: note that binding isn't the same as assignment.

[17:39] <colomon> $a.list shouldn't turn into a block either, should it?

[17:40] <pmichaud> $a.list would seem to be the same as   *.list  in that case.

[17:40] <moritz_> why not?

[17:40] <pmichaud> and *.list is definitely a block.

[17:40] <pmichaud> unless whatever-currying is purely syntactic.

[17:41] <colomon> I definitely thought whatever-currying was purely syntactic.

[17:42] <pmichaud> discussed at http://irclog.perlgeek.de/perl6/2010-05-26#i_2371899

[17:44] <alester> hey, moritz_, did you see try.rakudo.org has propagated?

[17:44] <moritz_> alester: yes

[17:44] <alester> I also set up ponie.rakudo.org, too, per your request.

[17:45] <moritz_> alester: I haven't got much further than architectural planning though

[17:45] *** SmokeMachine joined
[17:45] <jnthn> colomon, pmichaud: I know * + 42 is syntacticly transformed. I was under the impression *.foo could happen at runtime though. It certainly currently does in Rakudo. We can change it if needed.

[17:46] <jnthn> It'd be a win in some senses to do so.

[17:46] <sorear> std: 1

[17:46] <p6eval> std 31325: OUTPUT«ok 00:01 104m␤»

[17:47] <alester> so, if anyone wants a ponie, rakudo.org will give it to them.

[17:47] *** patspam1 joined
[17:47] *** patspam left
[17:47] *** patspam1 is now known as patspam

[17:48] *** patspam1 joined
[17:48] * colomon feels like he's stepped through the looking glass, where his simple attempt to eliminate what should be dead code has lead to nightmares...

[17:50] *** ShaneC joined
[17:50] * pmichaud finds a nice big fat juicy bug to fix.

[17:50] *** ShaneC left
[17:50] <pmichaud> (with a 1-line fix)

[17:51] <sorear> pmichaud: see CursorBase.pmc lines 2140-2198 in the current svn; that's the general cross-grammar lexer sharer

[17:51] *** xabbu42 left
[17:51] *** xabbu42 joined
[17:52] <cognominal> jnthn,  the stuff on Whatever is indeed strange  (*)(1)   (*+*)(1,2)   (*+*+*)(1,2,3)    # only the second works   :)

[17:53] <cognominal> ...last time I tried

[17:54] *** patspam1 left
[17:56] <pmichaud> in the first one, (*) is a term, not a block.

[17:56] <cognominal> indeed :)

[17:58] *** Trashlord left
[17:58] <cognominal> rakudo  *(1).signature.perl

[17:58] <cognominal> rakudo:  *(1).signature.perl

[17:58] <p6eval> rakudo 17e43e:  ( no output )

[17:58] *** REPLeffect left
[17:59] <cognominal> rakudo:  say *(1).signature.perl

[17:59] <p6eval> rakudo 17e43e: OUTPUT«:(;; Mu $x)␤»

[17:59] *** Trashlord joined
[18:06] <pmichaud> does anyone have a command-line tool they like to use for nopastes?

[18:07] <dalek> rakudo: 7a230d9 | pmichaud++ | docs/spectest-progress.csv:

[18:07] <dalek> rakudo: spectest-progress update through 06-14; still waiting on later dates to be 

[18:07] <dalek> rakudo: generated.

[18:07] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7a230d9c027706354b38a0b8d096e9ac6803354d

[18:10] <PerlJam> pmichaud: App::Nopaste?  (not a favorite, just one I know of via Padre::Plugin::Nopaste)

[18:11] <PerlJam> I typically use it from Padre if I use it.

[18:11] <pmichaud> I installed App::Nopaste, and it's totally deficient in documentation.

[18:11] <pmichaud> So I have no idea how to actually use it.

[18:11] *** REPLeffect joined
[18:11] <lue> why o hai o/

[18:13] <PerlJam> If you used padre, it would be a Ctrl+Shift+V away  ;)

[18:13] <pmichaud> if I can find out how App::Nopaste works, I can also make it Ctrl+Shift+V away.  Globally.

[18:14] <pmichaud> hmmm, my bug fix appears to break .trans

[18:15] <pmichaud> I'll wait until after the release to apply the fix.

[18:15] <pmichaud> (and let someone else figure out how to fix .trans :)

[18:17] <Tene> pmichaud: I use the script in the parrot repo

[18:18] <Tene> tools/dev/nopaste.pl iirc

[18:18] *** stephenlb joined
[18:18] * lue thinks maybe RT will provide something to work on.

[18:20] <PerlJam> pmichaud: nopaste filename  # it outputs the URL where filename was pasted

[18:20] <pmichaud> aha

[18:22] <colomon> okay, think I've got a somewhat cleaned up series with the single-character endpoints case working.  spectesting...

[18:22] <PerlJam> pmichaud: nopaste -s Gist filename  # paste to gist.github.com

[18:22] *** xabbu42_ joined
[18:22] *** xabbu42 left
[18:22] *** xabbu42_ is now known as xabbu42

[18:22] <pmichaud> PerlJam: awesome

[18:22] <pmichaud> thanks

[18:22] <pmichaud> now I can set up hotkeys for my nopasting

[18:23] <lue> I'm still wondering about custom circumfix operators. I'm afraid, however, that it's out of my depth w/o reading a lot :/

[18:24] <pmichaud> firefox $(xclip -o | nopaste -s Gist)  # niiiiiice

[18:33] *** Mowah left
[18:40] <arnsholt> Hmm. Working with arrays and Rakudo is a bit fiddly =/

[18:44] <pmichaud> it should be less fiddly now, though.

[18:44] <pmichaud> if it still has some fiddly areas, we can fix them.  :)

[18:44] *** xabbu42 left
[18:44] *** xabbu42 joined
[18:45] <lue> I'm considering working on Rakudo's binding.

[18:45] <pmichaud> binding should be relatively easy now.

[18:45] <lue> [:= of course]

[18:46] <pmichaud> first, type-check that the value you're binding to matches the type requirements of the container

[18:46] <pmichaud> if yes, then change the container (the one you're binding) to be an ObjectRef pointing to the thing you're binding.

[18:46] <lue> i.e my Int $a := $b can't work if $b is 3.5 [?]

[18:47] <pmichaud> correct

[18:47] <pmichaud> anyway, that handles binding to a first approximation

[18:48] <pmichaud> for a complete binding implementation, we also have to rebind the symbol in the lexpad, but that's Hard at the moment.

[18:49] <pmichaud> (or we have to go with yet another level of indirection.... but I'm not really in favor of doing that.)

[18:49] * lue attempts, by first finding the place where assignment works.

[18:50] <pmichaud> assignment is good background, but note that it's in fact very different

[18:50] *** REPLeffect left
[18:51] <lue> I know, it might give me insight to how variables are created though.

[18:51] <arnsholt> pmichaud: The main fiddlyness comes from lack of auto-vivification

[18:51] <pmichaud> well, I'd start with scalars only to begin with.

[18:51] <pmichaud> arnsholt: I expect to fix that tomorrow.

[18:51] <pmichaud> (I'd do it today, but I don't want to mess with a release.)

[18:51] *** REPLeffect joined
[18:51] <arnsholt> Oooh. That would be awesome

[18:51] <pmichaud> I figured out how to implement it cleanly last night.

[18:52] <pmichaud> (given the other refactors that I was able to do in the list branch)

[18:52] <pmichaud> lue: I'd start with scalars

[18:52] *** xabbu42 left
[18:52] *** xabbu42 joined
[18:52] <pmichaud> lue: leave array and hash binding for later (although it's basically the same thing)

[18:53] <pmichaud> lue:  the way that scalar variables work is that they are a Perl6Scalar PMC that holds a reference to a value

[18:53] <pmichaud> whenever we do an assignment, we change the reference to instead point to the new value

[18:54] <pmichaud> the main difference between assignment and binding whether or not the value itself is a reference

[18:54] <pmichaud> for assignment, we strip off any references, such that the scalar points directly to the value

[18:54] <pmichaud> for binding, we keep the references, so that the scalar points to a reference to the value

[18:55] <lue> In essence, make two variables point to the same PMC, if I'm getting this right.

[18:55] <pmichaud> well, let's consider an example

[18:55] <pmichaud> my $x = 3;

[18:56] <pmichaud> creates a Perl6Scalar, binds the symbol $x to it, and after assignment we have the Perl6Scalar pointing to a PMC containing the value 3

[18:56] <pmichaud> if we then do $y = $x

[18:56] <pmichaud> that translates into  &infix:<=>($y, $x)

[18:57] <pmichaud> this actually receives references to the containers $y and $x

[18:57] <pmichaud> so, in the simplest case (this one),   we make sure that whatever is in $x matches any type constraint attached to the container $y

[18:57] <pmichaud> we also check to see if $y is readonly

[18:58] <pmichaud> throw an exception if needed

[18:58] <pmichaud> once we decide the assignment can proceed, we dereference $x to get to is underlying value (the PMC holding 3)

[18:58] <pmichaud> and we set $y to also reference that underlying value

[18:59] <pmichaud> okay so far?

[18:59] <lue> in the process this creates another Perl6Scalar for $y, correct?

[18:59] <lue> which also contains 3

[18:59] <pmichaud> well, the Perl6Scalar for $y gets created at the "my" step.

[18:59] <pmichaud> it's more like

[19:00] <pmichaud> (my $x) = 3;  (my $y) = $x;

[19:00] <pmichaud> i.e., the "my" creates the Perl6Scalar, the &infix:<=> sets its value

[19:00] <lue> ah, ok.

[19:00] <pmichaud> assignment doesn't create any new objects, it just manages references to existing ones

[19:01] <pmichaud> well, I should say that item assignment doesn't create any new objects

[19:01] <pmichaud> (although itemizing the rhs may result in a new object being created... but this is not important for this at the moment.)

[19:01] <pmichaud> so, binding is exactly the same

[19:02] <pmichaud> (my $x) = 3;  (my $y) := $x;

[19:02] <pmichaud> *except*

[19:02] <lue> So, for binding, you change $y into an object that can hold a reference, or rather, point to one.

[19:02] <pmichaud> $y is already an object that holds a reference

[19:02] <pmichaud> what changes is that we now reference another reference, instead of the value directly.

[19:03] <pmichaud> in other words, instead of dereferencing $x to get to its underlying value, we simply set $y to point directly at $x

[19:03] <pmichaud> now then, in the case where we're assigning to a container that is referencing another reference, we delegate the assignment to the thing it's referencing

[19:04] <pmichaud> (but we still perform read-only and type checks for all of the references in the chain before doing this)

[19:04] <pmichaud> so, if we imagine that we have   $y := $x    and $z := $y

[19:05] <pmichaud> we end up with a chain that looks like     $z -> $y -> $x -> value

[19:05] <pmichaud> if we assign a value to $z, then it delegates the assignment to $y which delegates to $x, and it's $x's value that ultimately changes

[19:05] <lue> would infix:<=> have to change then, to accomodate that, or is it already taken care of?

[19:05] <pmichaud> it's already somewhat taken care of

[19:06] <dalek> rakudo: fdb5ca4 | (Solomon Foster)++ | src/core/operators.pm:

[19:06] <dalek> rakudo: Unify the infix:<...>($lhs, $rhs) case with the main infix:<...> code.  Add 

[19:06] <dalek> rakudo: support for the single-character endpoints special case.

[19:06] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/fdb5ca4f6c1d8259a90a0cee12efafbe10f9618c

[19:06] <pmichaud> i.e., infix:<=> already knows that it has to follow the chain of references and change the last one.

[19:06] <pmichaud> It has to know to do this, because this is exactly how parameter-binding works.

[19:07] <lue> Ah. So that would explain my ($a is rw) = $b working somewhat like := :)

[19:07] <pmichaud> now then, the thing this model doesn't yet handle is the case where   we rebind a variable that has itself been bound to

[19:08] <pmichaud> e.g.   $b := $a;   $a := $x;

[19:08] <pmichaud> with this model in place, $b would end up pointing through $a to $x, which is wrong

[19:08] <lue> would it then be where $b := $x , or...

[19:09] <pmichaud> so, what I'm hoping to be able to do is to find a way to leave the existing $a Perl6Scalar alone, and rebind the symbol "$a" to a new Perl6Scalar that then is bound to $x

[19:10] <lue> in effect creating two $a variables [?]

[19:10] <pmichaud> well, the old one would no longer be associated with the symbol '$a'

[19:10] <pmichaud> it would just be anonymous

[19:11] <lue> It seems to be a very interesting programming scenario when you do $a := $b and then $b := $c .

[19:11] <pmichaud> right

[19:11] <pmichaud> anyway, I'm not worrying about that case just yet.  It's not common enough to worry about for me.

[19:11] <pmichaud> so, the simple binding is good enough for now, and ought to handle most of what we want done.

[19:12] <lue> so, := eq = in terms of type checking and rw, but then the actual operation gets very different.

[19:13] <pmichaud> the main difference being how the source and target containers get dereferenced

[19:13] <pmichaud> for assignment, we dereference the source all the way down to its last reference, and dereference the target all the way down to its value

[19:13] <pmichaud> for binding, we don't do any dereferencing of either source or target

[19:14] <lue> pmichaud++ for explaining. Any further questions that come up I'll be sure to ask.

[19:14] <pmichaud> sure thing

[19:14] <pmichaud> also, I plan to do some more major refactoring of variables in the next two days

[19:14] <lue> .oO(Perl6: Where you learn how everything from classes to = works)

[19:14] <pmichaud> so, you'll be chasing a bit of a moving target

[19:14] <pmichaud> (the refactor will clean up the terms a bit, as well as resolve autovivification of hashes/arrays)

[19:15] <lue> Good, we need to cut our dependence on foreign code! [the Foreign Code of course being…

[19:15] <lue> …PMC]

[19:15] *** xabbu42 left
[19:15] <lue> That is one eventual goal, right?

[19:16] <pmichaud> well, we hope to be able to abstract to multiple backends

[19:16] <pmichaud> but I think the basic model I described above is going to be pretty common

[19:16] <pmichaud> it somewhat has to be that way in order to preserve type constraint and rw characteristics.  (there are some places where you can collapse chains of references for efficiency, but the conceptual model remains the same)

[19:17] <TimToady> jnthn: *.foo(bar()) must be syntactic, or bar gets called too early

[19:18] <lue> pmichaud: I'd be lucky to finish in time to get messed up by your refactoring :D

[19:18] <pmichaud> TimToady: I'm planning to propose a Hague Grant to rewrite S07, S08, and update the rest of the synopses for the list/iterator stuff.  Any comments/objections?

[19:18] <pmichaud> (as well as document Rakudo's internals and flesh out a few other things dealing with lists, iterators, and parcels)

[19:19] <lue> .oO(\o/ for API)

[19:19] <jnthn> TimToady: Ah.

[19:19] <jnthn> TimToady: Thanks for clarification.

[19:19] <jnthn> Will get to it at some point hopefully soonish. :-)

[19:19] <TimToady> pmichaud: that seems fine to me, but then typeglobs seemed fine to me at the time...

[19:20] <pmichaud> lol

[19:20] <jnthn> TimToady: Can I also assume that my $x = *; $x.foo # does not need to auto-curry?

[19:20] <TimToady> I don't think people will expect = to autocurry

[19:20] <jnthn> TimToady: no no

[19:20] <jnthn> I meant if I have a variable with a Whatever in it

[19:20] <jnthn> And I do a method invocation on that variable.

[19:20] <pmichaud> fwiw,  $x = *   is currently autocurrying in Rakudo.  :)

[19:20] <jnthn> lol

[19:21] <jnthn> I accidentally the curry.

[19:21] <pmichaud> rakudo:  say (my $x = *).WHAT

[19:21] <p6eval> rakudo 7a230d: OUTPUT«Block()␤»

[19:21] <jnthn> heh

[19:21] <pmichaud> I agree it's unexpected.

[19:21] <lue> .oO(The apathy variable)

[19:21] <jnthn> Yeah, we should probably not do it for that, or binding. :-)

[19:21] <TimToady> I can argue late currying either way

[19:22] <jnthn> TimToady: Thing is, it's a huge pain to do late currying for the * + 1 case

[19:22] <jnthn> That's why we made it syntactic, iirc.

[19:22] <jnthn> I'd prefer consistency between the two.

[19:22] <pmichaud> I think we agree that it needs to be syntactic

[19:22] <pmichaud> (at least, I do.)

[19:22] <jnthn> pmichaud: Sure, my question is if you have a Whatever in $x and do a method call on $x, what happens.

[19:23] <pmichaud> oh, I could go either way on that also.  :)

[19:23] <jnthn> pmichaud: Because it lets me rip a bunch of code out of the dispatcher if we go purely syntactic.

[19:23] <lue> So, := does not dereference AT ALL (.|?)

[19:23] <pmichaud> lue: only for optimization purposes, but conceptually, no.

[19:23] <pmichaud> lue: if we have

[19:24] <pmichaud>     my Int $a;   my $b := $a;    then $b needs to retain $a's constraint.

[19:24] <TimToady> why would there be code in the dispatcher anyway?  seems like late Whatever would work more like junctions and just fall out of normal dispatch rules

[19:24] <pmichaud> and if $b binds to something that is readonly, then $b also needs to act read-only

[19:25] <lue> ah, well of course. In that case, would $b inheret this from $a's Perl6Scalar, or does it need to be explicitly read and set?

[19:25] <TimToady> I'm not sure binding always adds an indirection

[19:25] <pmichaud> TimToady: so far it's the only consistent model I've found.  I could be argued out of it.

[19:25] <jnthn> TimToady: For a bunch of reasons, it doesn't.

[19:26] <jnthn> TimToady: Anyway, I'd prefer if we could make it purely syntactic.

[19:26] <TimToady> well, you could have a flat model if proxying were separate from references

[19:26] <pmichaud> lue: I don't like to say it "inherits" these behaviors -- rather that it just accumulates the behaviors of the thing it references

[19:26] <pmichaud> ...proxying?

[19:26] <jnthn> TimToady: If anything because $x + 1 where $x is a Whatever won't auto-curry.

[19:27] <lue> it collects, then :)

[19:27] <pmichaud> lue: or delegates

[19:28] <lue> So, in $a := $b, $a always says, "just look at $b, and that's me too." [?]

[19:28] *** chitragupt joined
[19:28] <pmichaud> lue: mostly

[19:29] <TimToady> lue: and that's what I'm carping about

[19:29] <pmichaud> $a says "here are my constraints, and obtw you need to match $b's constraints too"

[19:29] <TimToady> that's proxying, not referencing

[19:29] <pmichaud> okay, then that's what I'm thinking of doing :-)

[19:29] <lue> .oO(maybe waiting for variable refactor can save valuable key-hours (those keyboard keys do wear out))

[19:29] <pmichaud> or that's effectively what we're doing.

[19:31] <pmichaud> yes, I agree we can do without chains of indirections

[19:31] <TimToady> it feels like a Big Mistake to me

[19:31] <lue> methinks it'd be very brilliant if someone managed to write assignment in P6 as opposed PIR…

[19:31] <alester> Hey, people using perl6.vim, are you seeing what's described here? http://github.com/petdance/vim-perl/issues#issue/26

[19:31] <lue> [w/o inline PIR of course, that's just cheating]

[19:31] <pmichaud> TimToady: or, are you thinking that constraints are temporary?

[19:32] <pmichaud> i.e., when I do

[19:32] <pmichaud>     my Int $b := $a;

[19:32] <pmichaud> that adds a constraint to $a preventing it from becoming anything but an Int, for as long as $b is bound to the proxy?

[19:32] <pmichaud> (and actually not to $a itself, but to the proxy that $a references...)

[19:33] <TimToady> I think it only checks the constraint when bound, and if you modify the type of $a out-of-band, it's probably just erroneous

[19:33] <pmichaud> so...

[19:34] <TimToady> but readonly still needs proxying, I suspect

[19:34] <pmichaud> sub foo(Int $b) { $a = 'hello'; };    my $a = 3;  foo($a);   # what happens?

[19:34] <pmichaud> sorry, put my $a before foo

[19:34] <pmichaud> my $a = 3;   sub foo(Int $b) { $a = 'hello'; };   foo($a);

[19:35] <pmichaud> does $a inside of foo() "see" $b's constraint?

[19:35] *** plainhao left
[19:35] <jnthn> TimToady: Ah, the reason it doesn't fall out of failover just like junctions is because Whatever is Any, and we may want to *.some-method-in-any and have it curried.

[19:35] <pmichaud> .oO(does Whatever have to be Any?)

[19:36] <TimToady> if *.foo is syntactic, then we could move Whatever out of Any

[19:36] <pmichaud> I had been provisionally working from a model where constraints are based primarily on the variable used to access a value.

[19:37] <pmichaud> so in the above, $a = 'hello'   ends up being allowed, because we got to the proxy via $a.

[19:37] <TimToady> there's something here going on very much like "which thread owns this object"

[19:37] <pmichaud> and $b might later carp about "hey, where's my Int?"

[19:38] <pmichaud> and, in particular, even though $b is readonly, $a is not.

[19:39] *** slavik left
[19:40] <lue> And to think, when I thought about fixing := the first time, I wanted to change the .WHERE of variables...

[19:40] <pmichaud> anyway, the model I described above is really "provisional" until there are some clearer test cases.

[19:40] <pmichaud> and I think it's workable to a first approximation for now.

[19:40] <pmichaud> I agree that chains-of-indirections feels like Big Mistake; but I know that it's very optimizable

[19:41] <TimToady> I think of constraints as gatekeepers, and we can't keep people from climbing the walls without a great number of guards, who have finanical and/or cultural overhead

[19:41] *** macdaddy left
[19:41] <pmichaud> TimToady: that sounds to me like  $a = 'hello' above would be allowed

[19:42] <TimToady> I don't see us dynamically altering the type of the $a container

[19:42] <pmichaud> okay, good.

[19:42] <TimToady> that way lies madness

[19:42] *** slavik joined
[19:42] <pmichaud> I agree.

[19:42] <pmichaud> anyway, I'm fine with variable -> proxy -> value

[19:43] <TimToady> and "Int" doesn't even say it has to be an int, only that $b has to support Int, and the actual type of $a may well also support Str

[19:43] <arnsholt> alester: You don't get that behaviour? Weeird

[19:43] <alester> ooh wait

[19:43] <arnsholt> I'm on OS X 10.6, vim 7.2.108, if it matters

[19:43] <pmichaud> I think of type constraint as  "if you bind or assign to this variable/container, you must first meet these constraints"

[19:43] *** am0c joined
[19:44] <pmichaud> not "I guarantee to enforce this constraint at all times"

[19:44] <lue> pmichaud: hopefully the variable refactor will end up being Better Than Before :)

[19:44] <alester> ok, I do get it.  I now understand.

[19:44] <pmichaud> lue: of course, otherwise, why refactor?  ;-)

[19:44] <lue> Clearer Than Before is another one :)

[19:44] <lue> .oO(An Actual API would be wunderbar!)

[19:45] <TimToady> hmm, for assignment, it's almost more like, try assigning this, and then see if the resulting object is still consistent with the constraint, and if so, commit the transaction, otherwise rollback

[19:45] <pmichaud> TimToady: that works also.

[19:45] <pmichaud> I agree that's a better phrasing and model than what I described.

[19:45] <TimToady> but higher overhead in the general case

[19:45] <arnsholt> alester: Ah, good. Also, I feel that there should be a better way to solve the issue, but I'm not sure how

[19:45] <alester> arnsholt: can you please paste your line 760 here in the channel?

[19:46] <alester> the whole line

[19:46] <arnsholt> syn match p6RegexName display "\%(\<\%(regex\|rule\|token\)\@<!\%([$%@&].\)\s\+\)\@<=\K\%(\k\|[-']\K\@=\)*" nextgroup=p6RegexBlockCrap skipwhite skipempty

[19:46] <alester> and as to submitting patches on Github, the typical way is to fork the project, commit your change, and then send a pull request

[19:46] *** pronik``` joined
[19:47] <arnsholt> Ah, of course. Another one for the "this is how you do it in git" book

[19:47] <pmichaud> I still find github's "fork queue" for pull requests totally unusable.

[19:47] *** bbkr left
[19:47] <alester> pmichaud: it works for me, but then again, I don't have nearly the number of pull requests I'm sure you do.

[19:47] *** bbkr joined
[19:47] * lue thinks of gitorious. KDE uses it!

[19:48] <pmichaud> I end up with screenfuls of red-lined commits that all say "will not apply cleanly".

[19:48] <jnthn> pmichaud: I did use it for one person's patches at the weekend hackathon.

[19:48] <TimToady> pmichaud: otoh, the whole notion of inheritance is based on multiple levels of delegation, so maybe there's some unity lurking in the multilevel idea

[19:48] <jnthn> pmichaud: Mostly because they were sat next to me and I'd watched them run the spectests. ;-)

[19:49] <pmichaud> jnthn: you used the fork queue interface on the web?

[19:49] <TimToady> pmichaud: maybe we can think about it and find some time to talk next week

[19:49] <lue> frankly, I'm still sort of wondering about the difference btwn fork and branch [on git, not in Real Life :)]

[19:49] <jnthn> pmichaud: Yes

[19:49] <pmichaud> jnthn: in the rakudo account?

[19:49] <jnthn> pmichaud: Yes

[19:49] <pmichaud> oh, can all committers see that?

[19:49] *** ggoebel left
[19:49] <pmichaud> that's an improvement.

[19:49] <jnthn> pmichaud: fwiw, I see some green, some red.

[19:50] <jnthn> pmichaud: I think it's a "get 'em while they're hot" situation though.

[19:50] <pmichaud> jnthn: yeah

[19:50] <lue> Are forks a normal part of git?

[19:50] <alester> arnsholt: Porbably the better fix is to not recognize rule, regex or token if they are preceded by a sigil or twigil.

[19:50] <pmichaud> forks are normal in git, yes.

[19:50] <alester> "fork" doesn't mean what you probably think it imeans.

[19:50] <alester> Think of it like "branching the entire repo"

[19:50] <jnthn> pmichaud: Anyway, it's not convenient for me in general for patches because I like to know they past spectest for myself before I commit.

[19:50] <lue> well, that leaves me wondering what the diff. between branch and fork is.

[19:50] <pmichaud> jnthn: same here.

[19:50] <jnthn> pmichaud: But it was kinda nice in a hackathon situation.

[19:51] <alester> branch means branch

[19:51] <jnthn> That's about the first time I've used it in months though.

[19:51] <pmichaud> lue: branch creates a copy within your repository

[19:51] <TimToady> pmichaud: and just because something feels like a Big Mistake doesn't mean it is one...that's how disruptive technologies arise, by making what seems like a big mistake...

[19:51] <alester> fork means "I'm making my own copy of the entire repo"

[19:51] *** ggoebel joined
[19:51] <pmichaud> lue:  fork means create a copy *of* a repository, all branches

[19:51] <pmichaud> lue:  it's essentially "git clone"

[19:51] <pmichaud> but I think github uses "fork" because they get to use a new word and a bunch of double entendres

[19:51] <alester> Remember that "fork" is only meaningful on github.

[19:52] <lue> Then, unless I somehow need to, I see no point in forking when I already have a clone of the repo.

[19:52] <pmichaud> TimToady: (disruptive technologies)  agreed

[19:53] <alester> oops, meeting, brb

[19:53] <pmichaud> lue: github's model is that you clone the repo on github, then clone a local working copy from there

[19:53] <pmichaud> lue:  you then work with your local copy as much as you want, pushing things up to your github repo as appropriate

[19:53] <pmichaud> when you have something ready for the master repo, you issue a "pull request" from your github repo

[19:54] <pmichaud> and the master repo on github can then pull your commits from github directly

[19:54] <pmichaud> (while you continue to work locally)

[19:54] <lue> Hm, not sure I like the sound of that model. [Ah well, I'm not a master of version control systems. I'm pretty sure there is a really good reason somewhere]

[19:54] <pmichaud> lue: well, I'm not a fan of it either, which is why rakudo doesn't make much use of pull requests :)

[19:55] * lue is tempted to go to gitorious to see the difference.

[19:55] <pmichaud> I still find applying a patch file and testing to be easier than trying to cherry-pick and pull things from repos.

[19:55] <pmichaud> although pulling branches from remote repos (on github or elsewhere) also seems to work pretty nicely.

[19:56] <pmichaud> okay, time for me to bug fix and write

[19:56] *** pmurias joined
[19:56] <pmurias> ruoso: hi

[19:56] <pmichaud> (still here, but in other windows)

[19:56] <pugssvn> r31333 | pmurias++ | [smop] mildew is used by tools/ri instead of the haskell m0ld 

[19:57] <dalek> rakudo: 2be1d04 | (Solomon Foster)++ | src/core/operators.pm:

[19:57] <dalek> rakudo: Handle the infix:<@lhs, @rhs> case we forgot about last time.

[19:57] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2be1d04165735fb754817e08cc363000b085ebf7

[19:57] <pugssvn> r31334 | colomon++ | [t/spec] Unfudge series / Range tests Rakudo now passes, and add a few more tests in those areas. 

[19:58] <colomon> TimToady: is 'ZZ' ... 'A' expected to be a finite list?

[19:58] * lue is examining the feature lists of github & gitorious out of curiousity

[19:59] <arnsholt> colomon: For consistency it should be the same as 3 ... 1, no?

[19:59] <colomon> arnsholt: nope.

[20:00] <colomon> or at least, at a low level, they are quite different operations.

[20:00] <pmichaud> colomon: what comes next after   'AC', 'AB', 'AA', ...

[20:00] <pmichaud> ?

[20:00] <colomon> rakudo: 'AA'.prec

[20:00] <p6eval> rakudo 7a230d: OUTPUT«Method 'prec' not found for invocant of class 'Str'␤  in main program body at line 11:/tmp/OTApycdzxD␤»

[20:00] <colomon> rakudo: 'AA'.pred

[20:00] <pmichaud> I think that the predecessor to 'AA' ends up being an exception.

[20:00] <p6eval> rakudo 7a230d:  ( no output )

[20:00] <pmichaud> or a Failure object of some kind

[20:01] *** ggoebel left
[20:01] <jnthn> rakudo: say 'AA'.pred

[20:01] <p6eval> rakudo 7a230d:  ( no output )

[20:01] <pmichaud> > say 'AA'.pred

[20:01] <pmichaud> ===SORRY!===

[20:01] <pmichaud> Decrement out of range

[20:01] <pmichaud> can probably make that a soft-fail.

[20:01] <colomon> that's the very message.

[20:01] <arnsholt> Oh. But 'Z'.succ is 'AA', isn't it?

[20:01] <pmichaud> yes

[20:01] <pmichaud> .succ can add characters, but .pred doesn't (yet?) take them away

[20:02] *** REPLeffect left
[20:02] <pmichaud> it would be hard to know what comes before 'A0', for example.

[20:02] *** ggoebel joined
[20:02] <pmichaud> colomon: at first glance, I'd be fine with the series terminating at AA

[20:02] <arnsholt> Good point

[20:03] *** REPLeffect joined
[20:03] <pmichaud> i.e., the next value in sequence is at least undefined, and so terminates the sequence (or something like that)

[20:04] <lue> afk

[20:04] <pmichaud> and a good compiler could/should warn when something odd like that is taking place

[20:04] <pmichaud> i.e., if it's a decrementing range of strings, make sure the ending string has the same form and length as the starting one.

[20:04] <colomon> so (generalizing) if the code block which generates the next item in the series generates a fail, the series ends?

[20:04] *** Psyche^ joined
[20:05] <pmichaud> I dunno... does the spec say anything about udnefs?

[20:05] <TimToady> I believe current spec says there's nothing before AA

[20:06] *** patrickas joined
[20:06] *** silug joined
[20:06] <colomon> ooo, I think terminating is the right thing to do.

[20:06] <colomon> (I mean, terminating the series)>

[20:06] <pmichaud> for a terminating closure, the series terminates on a false value

[20:07] <pmichaud> (from the closure, that is)

[20:07] <colomon> Right, but this is the generating closure.

[20:07] <pmichaud> it doesn't seem to say anything about values from the generating closure

[20:07] <colomon> I think if it fails, the series should terminate.

[20:07] <colomon> it will make Wed ... * terminate, right?

[20:08] *** Patterner left
[20:08] *** Psyche^ is now known as Patterner

[20:08] <pmichaud> well, I'm not sure "terminate on the first failure" is exactly right.

[20:08] <colomon> (or is Sun.succ Sun again?)

[20:08] <cognominal> Depending on the Oracle?

[20:08] <pmichaud> rakudo:  say Mu before 'AA'  

[20:08] <p6eval> rakudo 7a230d: OUTPUT«No applicable candidates found to dispatch to for 'infix:<before>'. Available candidates are:␤:()␤:(Any $a, Any $b)␤␤  in main program body at line 11:/tmp/nqRVMd7lbl␤»

[20:09] *** ash__ left
[20:09] <pmichaud> rakudo:  say Any before 'AA'  

[20:09] <p6eval> rakudo 7a230d: OUTPUT«0␤»

[20:09] <pmichaud> rakudo:  say Any after 'AA'  

[20:09] <p6eval> rakudo 7a230d: OUTPUT«1␤»

[20:09] <pmichaud> huh.

[20:09] <pmichaud> I guess it stringified to "Any()" or somesuch.  :-)

[20:09] <colomon> pmichaud: yes, Any()

[20:09] <pmichaud> rakudo: say Any before 'BB'

[20:09] <p6eval> rakudo 7a230d: OUTPUT«1␤»

[20:10] <pmichaud> anyway, if failure ended up being treated as '', then it would clearly be before 'AA'  (or any other string other than the empty string)  and the series would naturally terminate :-)

[20:11] <pmichaud> (and it might throw a useful warning, too)

[20:11] <pmichaud> I'm thinking that   'AA'.pred   should &fail instead of &die.

[20:11] <colomon> I really think terminate series on Failure is the Right Thing.

[20:11] <colomon> rakudo: say 'AA'.pred.WHAT

[20:11] <p6eval> rakudo 7a230d: OUTPUT«Failure()␤»

[20:11] <pmichaud> oh, it's already doing that. :-)

[20:12] <pmichaud> colomon: I can imagine series where failures are reasonable within the series.

[20:12] <pmichaud> otoh, perhaps the closure should make that explicit in that case

[20:13] <pmichaud> so, we could default to "failure terminates, use an explicit closure somehow if you want failure to be part of the series"

[20:13] <pmichaud> or

[20:13] <pmichaud> "failure doesn't terminate, use a closure if you want it to do so"

[20:13] <pmichaud> the latter seems far far easier on the programmer.

[20:14] <colomon> If the user doesn't provide an explicit generating closure, no Failure is every going to lead to anything other than an infinite series of Failures.

[20:14] <colomon> (unless we terminate on the first Failure, I mean)

[20:15] <pmichaud> not true -- the case I gave above  ('ZZ' .. 'A')   would naturally terminate.  :-)

[20:15] <TimToady> S03:518 specs that 'aaa' and '000' don't decrement

[20:15] <colomon> pmichaud: no it wouldn't

[20:15] <pmichaud> colomon: ummm, why not?

[20:15] <colomon> unless Failure.pred doesn't generate a Failure?

[20:16] <pmichaud> Failure  ends up being before 'A'

[20:16] <pmichaud> so its beyond the endpoint

[20:16] <TimToady> before AA by S03:518

[20:16] <pmichaud> and the series stop.

[20:16] <pmichaud> (since this is a decrementing series, we reverse the test on the endpoint)

[20:16] <TimToady> it doesn't do AA -> Z

[20:17] <TimToady> so never gets to A

[20:17] *** pronik``` is now known as pronik

[20:17] <pmichaud> with 'AA' ... 'Z'    we'd fail immediately after 'AA', yes?

[20:17] <TimToady> by current spec, yes

[20:17] <colomon> no, because that's an increasing series

[20:17] <pmichaud> colomon: it is?  hrm.

[20:17] <TimToady> er, yeah

[20:17] <colomon> absolutely is.

[20:18] *** masak joined
[20:18] <masak> ahojte!

[20:18] <colomon> 'AA' is before 'Z', so we do .succ as the generator.

[20:18] <pmichaud> then it's infinite, and we never see a failure.

[20:18] <masak> let's go into Release Mode for real here. :)

[20:18] <pmichaud> so failure doesn't come into the picture.

[20:18] <colomon> it's not infinite, either.

[20:18] <TimToady> eh?

[20:18] *** Chillance joined
[20:18] <pmichaud> oh, I guess it stops at ZA

[20:18] <pmichaud> since 'ZA' after 'Z'

[20:19] <pmichaud> either way, failure isnt a problem there.

[20:19] <colomon> stops at YZ, actually.

[20:19] <jnthn> masak! :-)

[20:19] <masak> :)

[20:19] <pmichaud> right, last element produced is YZ

[20:19] <TimToady> I think series on alphas should probably only stop on exact match

[20:19] <colomon> right.

[20:19] <colomon> TimToady: aiigh, no!

[20:20] <[particle]> nfg exact?

[20:20] <pmichaud> at any rate, we still don't have the case of "failure leading to anything other than infinite series of failures"

[20:20] <jnthn> masak: I read your blog post and couldn't help but thing of some of Visual Studio's "Generate From Usage" features.

[20:20] <jnthn> *think

[20:20] <pmichaud> i.e., we still don't have an instance where we need to do something special to terminate on generating a failure.

[20:20] <jnthn> masak: Where you can write code that instantiates classes and calls methods on them, and then take the code and have the stub classes/methods generated for you.

[20:21] <colomon> pmichaud: you keep saying that, but I don't think you're right.

[20:21] <pmichaud> colomon: feel free to provide a counter example.  :)

[20:21] <colomon> at least, we're not terminating on Failure now, and every other case seems to work fine.

[20:21] <pmichaud> colomon: my point is that having a failure show up in an automatically-generated sequence is pretty rare

[20:21] <masak> jnthn: that sounds like a blessing-and-a-curse feature. :)

[20:21] <masak> jnthn: I actually quite enjoy doing it by hand, and by-need.

[20:21] <pmichaud> and the only one we can come up with (decrementing strings), does a reasonable thing by default.

[20:22] <masak> jnthn: the error messages guide me on, in a way.

[20:22] <pmichaud> so, that goes back to my point, which is that if we terminate a series on Failure by default, then it becomes hard for a generator to create a series with a Failure in it

[20:22] <pmichaud> but if we allow a series to continue by default, it's pretty easy to provide a closure that can terminate the series when a Failure occurs.

[20:22] <jnthn> masak: Aye...of course, you can run code in a dynamic language without having a bunch of stuff implemented, whereas same wouldn't even compile in a static one. :-)

[20:23] <TimToady> so why are we returning Failure rather than Nil?

[20:23] <pmichaud> TimToady: currently   rakudo has  'AA'.pred   returning a Failure

[20:23] <pmichaud> we can change that to Nil if the spec so indicates (haven't checked recent spec on this)

[20:23] <TimToady> return $x.pred // Nil;

[20:23] <pmichaud> sure, that works

[20:24] <colomon> huh.

[20:24] <pmichaud> but I think that's a part of the generator, not part of the series logic.

[20:24] <pmichaud> i.e., the generator sees a failure and returns Nil to stop the series.

[20:24] <pmichaud> not that the series sees a failure being generated and thus stops.

[20:24] <colomon> well, it appears I have been chasing after the wrong problem here.

[20:24] <colomon> TimToady: think of the case of enums, please.

[20:24] *** tadzik joined
[20:25] <colomon> if we get this right, I think we will handle them automatically...

[20:25] <colomon> what I actually get: if I do say 'ZZ' ... 'A', everything works and it stops on 'AA'

[20:25] <colomon> If I do say ('ZZ' ... 'A').elems, I get "Decrement out of range"

[20:25] <ruoso> pmurias, hi

[20:26] <pmichaud> colomon: TimToady is suggesting to use  $x.pred // Nil   as your generator there

[20:26] <pmichaud> that will prevent the Decrement out of range

[20:26] <pmichaud> (by converting it to a Nil)

[20:26] *** masak left
[20:26] <colomon> really?

[20:27] <pmichaud> since Failures are undefined, yes.

[20:27] <colomon> can you explain why I get the Decrement out of range?

[20:27] <colomon> is Failure actually the last element of the series?

[20:27] <pmichaud> 'AA'.pred returns a Failure object

[20:27] <pmichaud> if you attempt to do anything with that Failure object other than test it for definedness or truth, it throws its exception

[20:28] <pmichaud> rakudo:  say 'AA'.pred

[20:28] <p6eval> rakudo 7a230d:  ( no output )

[20:28] <pmichaud> rakudo:   say 'AA'.pred // 'hello'

[20:28] <p6eval> rakudo 7a230d: OUTPUT«hello␤»

[20:28] <pmichaud> this is the basics of how Failures work in Perl 6 :-)

[20:28] <colomon> will switching it to Nil do the right thing, though?

[20:29] <pmichaud> I think that returning Nil from a generator terminates the sequence

[20:29] <pmichaud> (can't seem to find that point in the spec atm)

[20:29] <colomon> you mean, terminates the series?

[20:29] <TimToady> what is this "generator" of which you speak?

[20:29] <TimToady> do you mean List or iterator?

[20:30] <pmichaud> in a series like     'ZZ' .. 'AA',   we can have a closure that does  { $^x.pred }   as a generating sequence

[20:30] <pmichaud> i.e., something like

[20:30] <pmichaud>     'ZZ', { $^x.pred } .. 'AA'

[20:30] <pmichaud> (sorry, three dots)

[20:30] *** silug left
[20:30] <pmichaud>     'ZZ', { $^x.pred } ... 'AA'

[20:30] <pmichaud> colomon is concerned that with

[20:31] <pmichaud>     'ZZ', { $^x.pred } ... 'A'

[20:31] <TimToady> then whatever is calling that needs to check for definedness

[20:31] <pmichaud> we end up with an exception after generating 'AA's predecessor

[20:31] <pmichaud> I'm saying that if he instead generated the sequence as

[20:31] <pmichaud>    'ZZ', { $^x.pred // Nil } ... 'A'

[20:32] <TimToady> $generator() // last

[20:32] <pmichaud> then &infix:<...> doesn't need the definedness check.

[20:32] <colomon> but will it need a Nil check?

[20:32] <pmichaud> I'm fine if &infix:<...> does check for defined elements, but that means it can't really be used to create sequences containing failures

[20:32] <TimToady> Nil is probably a bad sentinal

[20:32] <pmichaud> (which is okay by me, but I could imagine some classes of generating closures where that might be desirable)

[20:33] <colomon> rakudo: say 'aa' cmp Nil

[20:33] <p6eval> rakudo 7a230d: OUTPUT«1␤»

[20:33] <pmichaud> we could resurrect EMPTY :-)

[20:33] <TimToady> and in fact we already have specced something that returns an infinite series of Nils

[20:33] <TimToady> I think we should just require definedness

[20:33] <pmichaud> okay, then colomon++ is right :-)

[20:33] <TimToady> $generator() // last

[20:34] *** ive joined
[20:34] <colomon> we're locked down for release, right?

[20:34] <TimToady> gather loop { take $generator(|@someargs) // last }

[20:35] <TimToady> or some such

[20:35] <pmichaud> I don't know about "locked down", but I'd avoid any major semantic changing commits

[20:35] <colomon> TimToady: it's a lot more complicated than that.  :)

[20:35] <TimToady> yes, it's pseudocode :)

[20:35] <colomon> but the // last is easy to add.  TimToady++

[20:35] *** silug joined
[20:36] <TimToady> it's a conservative approximation that will work until the time that we want serieses with undefined values :)

[20:36] <colomon> well, the good news here is series works for single-char arguments now, and seems to mostly do the right thing with other strings.

[20:37] <colomon> excepting the case where we need // last added.  :)

[20:37] <moritz_> maybe the // needs to become an exception-aware operator one day (orelse?)

[20:38] <pmichaud> TimToady: I buy that form of conservatism as well.

[20:38] <pmichaud> masak:  I just updated spectest-progress.csv in master

[20:38] <colomon> TimToady++ # it's not as if any previous definition of series has lasted longer than a week!  ;)

[20:38] <TimToady> and at that point we can switch to pure iterators

[20:38] *** ive left
[20:38] <dalek> rakudo: af53808 | pmichaud++ | docs/spectest-progress.csv:

[20:38] <dalek> rakudo: spectest-progress.csv update: 489 files, 33280 (83.4% of 39887) pass, 37 fail

[20:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/af53808f18d0a8cc5fbbc81e06371f7fa7063871

[20:38] <pmichaud> note however that the number of tests reported there is *before* the branch merge

[20:39] <TimToady> and for pure iterators, Nil really does mean "no more iterators"

[20:39] <pmichaud> (because it is the state of the repo as of 0000 CDT, or 0500 UTC, and the merge occurred around 0700 UTC)

[20:39] *** mberends left
[20:39] <pmichaud> afk for a bit

[20:40] <alester> arnsholt: I have pushed my changes

[20:40] <arnsholt> Cheers

[20:41] <colomon> / last appears to fix this case.

[20:41] <colomon> / last, sorry.

[20:41] <moritz_> colomon: / //

[20:41] *** masak joined
[20:42] <moritz_> most IRC clients accept '/ ' to escape a leading /

[20:42] <masak> we now return to your regularly scheduled Release Mode.

[20:42] <colomon> ah, so I didn't make the same stupid typo twice in a row.  Nice to know.

[20:43] <alester> I just type a leading space

[20:44] <lue> ohai

[20:44] *** clintongormley left
[20:47] <masak> lue: \o

[20:48] <masak> lue: time to make a Rakudo release :)

[20:48] <colomon> \o/

[20:48] * masak runs spectests

[20:48] * jnthn feeds masak with a Chicken Kiev

[20:49] <masak> jnthn: quite full on post-swim pasta already, thank you :)

[20:50] *** Mowah joined
[20:54] *** Schwern left
[20:56] <lue> :=)

[20:56] <diakopter> /

[20:56] <diakopter> ///

[20:57] <pmurias> diakopter: hi

[20:59] <Juerd> 22:42 <@moritz_> most IRC clients accept '/ ' to escape a leading /

[20:59] <Juerd> Which is sometimes implemented as an alias for /say

[20:59] <Juerd> Which also works, in many clients

[21:00] *** macdaddy joined
[21:00] <moritz_> testing

[21:00] <moritz_> //

[21:00] <moritz_> /say // also works

[21:00] <moritz_> in irssi

[21:01] *** eternaleye_ joined
[21:02] *** eternaleye left
[21:04] <lue> enclosing stuff in double brackets causes links to wikipedia.

[21:06] <pmurias> masak: any progress on tote? (i just read the blog post)

[21:06] <masak> pmurias: a commenter also asked that, as you'll note.

[21:07] <masak> pmurias: I've been a bit egotistical, and not packaged what I already have (and use quite efficiently) as a Perl 6 project.

[21:07] <masak> I will make amends soonish.

[21:08] <pugssvn> r31335 | pmurias++ | [smop] store the build files in build/ instead of builddir/ 

[21:12] *** azert0x joined
[21:12] <masak> it would seem PARROT_REVISION is set to Parrot 2.5.0. check.

[21:12] *** macdaddy left
[21:13] *** Mowah left
[21:13] <arnsholt> When I've created a new branch locally, how do I push that to the remote origin?

[21:14] <masak> arnsholt: make sure you're "in the branch", as in 'git checkout $branch'

[21:14] <masak> arnsholt: then, just 'git push origin $branch'

[21:15] <arnsholt> Ah, there we go. Thanks

[21:15] <masak> the two instances of $branch don't have to be identical, but it's generally good for sanity if they are. :)

[21:15] <arnsholt> Hehe

[21:16] <masak> things in docs/ChangeLog appear in decreasing order of importance, yes?

[21:18] <jnthn> masak: I don't know there's been a deliberate attempt to do that in the past.

[21:18] <jnthn> masak: More that the things that make it into the announcement are the biggies.

[21:19] *** whiteknight joined
[21:19] <masak> aye, but ISTR that it's semi-common practice to put big changes at the top, lest reader falls asleep halfway through list.

[21:20] <patrickas> masak: It seems chronological to me (except first line)

[21:21] <masak> going through the git commit log now to see if we've missed something.

[21:21] <masak> '.' goes on the end in @*INC now. I'll mention this, because it might impact some module authors.

[21:23] *** xinming joined
[21:23] <arnsholt> There. I do like git, but sometimes it makes me want to strangle someone =)

[21:23] *** tadzik left
[21:24] <masak> arnsholt: I don't think I've ever felt that. what's up?

[21:24] <arnsholt> masak: Just struggled to get onto the new branch on my other computer

[21:24] <diakopter> pmurias: hi

[21:24] <masak> hm, Rakudo's developers still don't use --rebase enough when pulling :P

[21:24] <arnsholt> Finally foung branch -b foo origin/foo

[21:25] *** xinming_ left
[21:25] <masak> arnsholt: 'git checkout -b foo origin foo' probably also works.

[21:25] <arnsholt> Cool.

[21:25] <masak> hm. maybe not.

[21:26] <arnsholt> I think my main problem with git is that I've not fully assimilated the way git works into my mental model of how source control works

[21:26] <masak> that's usually the big stumbling block.

[21:26] <masak> arnsholt: read "Git From the Bottom Up". that's the biggest favour you can do yourself in terms of understanding. :)

[21:28] *** Guest23195 left
[21:28] <arnsholt> I really like the add/commit mechanism of git though

[21:28] *** rv2733 left
[21:29] <arnsholt> Working with an SVN repo at work, I went "but those changes are -local- don't wanna commit those!" today =)

[21:30] *** skids left
[21:32] <masak> I saw it in the commit when it arrived earlier this month, but then promptly forgot about it: http://github.com/rakudo/rakudo/blob/master/src/core/Date.pm#L94

[21:32] *** Su-Shee left
[21:32] <masak> can that work?

[21:32] <masak> if it can, I still don't understand the :: sigil.

[21:32] <masak> rakudo: say ::A.foo; class A { method foo { "OH HAI" } }

[21:32] <p6eval> rakudo 2be1d0: OUTPUT«OH HAI␤»

[21:33] <masak> huh.

[21:33] <arnsholt> ::Foo means that you want the Foo from the root namespace, no?

[21:33] <jnthn> Not in Perl 6.

[21:33] <arnsholt> Oh. Ignore me, then =)

[21:33] <jnthn> std: say ::A.foo; class A { method foo { "OH HAI" } } # curious

[21:33] <p6eval> std 31325: OUTPUT«ok 00:01 105m␤»

[21:33] <masak> I honestly did not expect that to work.

[21:33] <masak> the rakudo evaluation, that is.

[21:34] <patrickas> arnsholt: that would be GLOBAL::Foo (I think)

[21:38] <lue> .rnd(as far as I can tell, gitorious has no forks)

[21:41] *** perlygatekeeper left
[21:43] *** SmokeMachine left
[21:47] <pmurias> diakopter: have you thought about rewriting perlesque in itself once it has working grammars?

[21:48] <dalek> rakudo: 736bef8 | masak++ | docs/ChangeLog:

[21:48] <dalek> rakudo: [docs/ChangeLog] some further updates

[21:48] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/736bef8098e574f4b8067759a9d711ee6da85427

[21:48] <masak> ok. spectest done. t/spec/S09-typed-arrays/arrays.rakudo still fails here.

[21:48] <jnthn> Comment out in the spectest.data for release?

[21:48] <masak> so does t/spec/S12-methods/submethods.rakudo.

[21:48] <masak> haven't seen that one before.

[21:48] <jnthn> That one is more...surprising. :-S

[21:48] <diakopter> pmurias: maybe, but it'd be better to make a perlesque emitter for viv

[21:48] <masak> jnthn: it runs fine out of the harness. :/

[21:49] <jnthn> oh wtf

[21:49] <jnthn> I hate it when that happesn.

[21:49] <masak> it runs fine with 'make', too.

[21:49] <masak> might have been a cosmic ray or something.

[21:49] <pmurias> diakopter: which will emit code with perlesque like semantics?

[21:49] <masak> still lots of passing TODO tests, as well.

[21:49] <masak> I won't do anything about them.

[21:49] <jnthn> *nod*

[21:50] <jnthn> "This release is SO win it come with passing TODOs!"

[21:50] <masak> do more people agree that I should comment out t/spec/S09-typed-arrays/arrays.rakudo from spectest.data for release?

[21:50] <masak> I'm not really a fan of that practice.

[21:50] <jnthn> masak: You're a fan of a month of people pointing out it fails?

[21:50] <masak> no, I'm a fan of fixing it before release :)

[21:50] *** rgrau left
[21:51] <jnthn> masak: Is it a total fail?

[21:51] *** eternaleye_ left
[21:51] <masak> checking.

[21:51] <masak> yes.

[21:51] <masak> get_pmc_keyed() not implemented in class ''

[21:51] <masak> after test 7.

[21:52] <jnthn> Oh, so it actually compiles. Hm

[21:52] <masak> after fixing that, it dies later in the script.

[21:52] <masak> applying rolling fixes until it passes.

[21:52] <pmichaud> I suggest skipping the tests in S09-typed-arrays for now.

[21:53] <pmichaud> it's not a trivial fix.

[21:53] <masak> I'm adding #?skip comments.

[21:53] <jnthn> pmichaud: What's the akshaul issue?

[21:53] <pmichaud> (or it may be a trivial fix, but it's not a trivial find.)

[21:53] <jnthn> heh

[21:53] <masak> ah, only two were required. :)

[21:53] <pmichaud> #?skip +1

[21:53] <pmichaud> right

[21:53] <jnthn> What's the actual symptom?

[21:53] <jnthn> :-)

[21:53] <pmichaud> it crashes.  :)

[21:53] <pmichaud> srsly.  :)

[21:53] <jnthn> :P :P

[21:53] <masak> pmichaud: what about t/spec/S12-methods/submethods.rakudo ?

[21:54] <pmichaud> that one was passing for me last time I checked.

[21:54] <pmichaud> looking.

[21:54] <pmichaud> (or, at least, it wasn't failing.)

[21:54] <pmichaud> yeah, that one shows everything passing for me.

[21:54] <masak> I also couldn't get it to fail on demand.

[21:54] <pmichaud> So, I dunno.

[21:54] <pugssvn> r31336 | masak++ | [S09-typed-arrays/arrays.t] skip-fudged two tests 

[21:54] <masak> I'll just leave it in.

[21:55] <masak> maybe it'll come back and bite us, and we'll treat it then.

[21:55] <pmichaud> that's fine.

[21:55] <pmichaud> I'm also fine with skipping it, or commenting it out of spectest.data for the release

[21:55] <pmichaud> so we don't get a lot of people saying "you shipped something with failing tests?!?"

[21:56] <masak> I would if I (or anyone) could reproduce it.

[21:57] <jnthn> Yeah, doing another spectest run just to try and spot it again would be annoying I guess.

[21:57] <jnthn> masak: What if you put it and a few other things into localtest?

[21:57] <masak> jnthn: trying.

[21:57] <pmichaud> this is one of those areas that I feel has no definite right answer, so it's really the release manager's call

[21:58] <masak> jnthn: care to write up a sentence or two about the rationale for the name "Kiev" for this release?

[21:58] *** eternaleye joined
[21:59] <jnthn> masak: Can you hold on 5 mins while I finsih tracking a $dayjob test fail?

[21:59] <masak> oh, definitely.

[21:59] <jnthn> kk :-)

[21:59] <masak> still at least half an hour left of the preparations :)

[22:00] <masak> submethods.rakudo runs fine in localtest.data as well. :/

[22:00] <masak> oh wait.

[22:00] <masak> it runs all the way through, but exits with exit status 1.

[22:01] <masak> seems *that* is reproducible, even out-of-harness.

[22:02] <masak> um. it ends with 'exit(1)'. so... :)

[22:02] <masak> do all fudged test files end with 'exit(1)'?

[22:02] <masak> seems not.

[22:03] <masak> why this one? must be something the fudger added.

[22:03] *** Mowah joined
[22:03] <jnthn> woo, passes

[22:03] *** Ross left
[22:03] * jnthn switches to extolling the virtues of Kiev

[22:05] <sorear> pmichaud: nopaste -x /path/to/file or command | nopaste -x

[22:05] <sorear> pmichaud: -x tells nopaste to place the URL directly into the clipboard for pasting into IRC

[22:05] <masak> hm, seems the 'fudge' tool adds an 'exit(1)' if --keep-exit-code hasn't been supplied to it.

[22:05] <masak> but why?

[22:06] <sorear> nopaste --help

[22:06] <pmichaud> masak: yeah, that seems new or different somehow.

[22:06] <pmichaud> I noticed that I get exit(1) on all of the files with fudged tests now, and I don't think I used to get that.

[22:07] <pmichaud> (or at least the test harness is a lot more verbose about it)

[22:07] <jnthn> pmichaud: Me too and it's...horrible.

[22:07] <jnthn> I get so much test output about that. :S

[22:07] <jnthn> pmichaud: But I thought it was a Parrot destruction bug.

[22:07] <jnthn> I never suspected the test harness.

[22:07] <jnthn> Or the fudger.

[22:07] <jnthn> :S

[22:07] <pmichaud> for exit code 1, it's usually not Parrot.

[22:08] <pmichaud> it's the fudger, returning exit 1 because "you really didn't pass all of the test file"  :-)

[22:08] <jnthn> pmichaud: Yeah, it did seem...odd.

[22:08] <jnthn> pmichaud: Yeah but...it upsets the test harness.

[22:08] <pmichaud> but we used to have an option in place that caused the harness to not report that condition

[22:08] <jnthn> I'd really rather it didn't.

[22:08] <pmichaud> so I'm not sure what happened to it

[22:08] *** patrickas left
[22:08] <jnthn> Does having them give exit code 1 win us anything?

[22:09] <pmurias> if the harness ignores that it shouldn't give anything

[22:09] <pmichaud> can we pass --keep-exit-code to fudge?

[22:09] <pmichaud> (were we at one point, and it changed?)

[22:10] * pmichaud looks... github to the rescue.

[22:10] <sorear> pmichaud: The big problem with := hacking lexpads is that, well, it only works on lexicals

[22:10] <masak> at this point, I would like to be able to use 'ack' in the time dimension, as well :)

[22:12] <pmichaud> hmmm, Makefile has

[22:12] <pmichaud> HARNESS_WITH_FUDGE = $(PERL) t/harness --fudge --keep-exit-code --icu=$(HAS_ICU)

[22:12] <pmichaud> does --keep-exit-code not get passed along to fudge?

[22:13] <pmichaud> looks like it does, or should.

[22:16] <masak> good. we've found two ends of the inconsistency. :)

[22:17] <masak> only bisection left, then.

[22:17] <pmichaud> anyway, I'm not at all fond of the way it works now (where I get lots of false errors reported from T::H because something somewhere is choosing to generate a strange exit code), so whatever can be done to fix that I'm in favor of.

[22:18] <pmichaud> I don't think it's Rakudo generating the exit code, so that just leaves fudge or something in Test::Harness (or equiv)

[22:18] *** macdaddy joined
[22:20] <pmichaud> I don't know why it started appearing when it previously did not.

[22:20] <pmichaud> (at least on my systems)

[22:22] *** eternaleye left
[22:25] *** pmurias left
[22:27] *** gbacon left
[22:28] <masak> tools/contributors.pl is not Unicode-aware, but it sure simplifies things.

[22:29] *** lest_away is now known as lestrrat

[22:35] <masak> http://github.com/rakudo/rakudo/blob/master/docs/announce/2010.06 -- please help review, find errors, possible improvements, etc. this is your last chance to help with the release, so take it! :)

[22:35] <dalek> rakudo: 22b71e0 | masak++ | docs/announce/2010.06:

[22:35] <dalek> rakudo: [docs/announce/2010.06] added

[22:35] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/22b71e0f33c9c0135fb7fbff849ba3ddad877709

[22:36] * jnthn reads

[22:36] <pmichaud> other features off the top of my head

[22:36] <pmichaud> match objects now act like real hashes and arrays

[22:37] <pmichaud> hash and array slicing is greatly improved

[22:37] <pmichaud> (you can adopt or ignore these as you wish)

[22:37] <pmichaud> variable interpolation in regexes now works  (that's kind of a biggie to me)

[22:37] <masak> the first of those is in docs/ChangeLog, but maybe it's important enough to mention even in the release announcement. yes, probably.

[22:37] <masak> pmichaud: I wrote that last one! :)

[22:38] <pmichaud> oh, I see it now.

[22:38] <pmichaud> <-- blind.

[22:38] <masak> the hash/array slices one should probably go both in the docs/ChangeLog and in the release announcement.

[22:38] <masak> fixing.

[22:38] <jnthn> masak: "The list semantics received a complete overhaul" -> semantics and implementation?

[22:38] <masak> jnthn: this is for the implementation.

[22:38] <pmichaud> the next release is scheduled for July 22, I think.

[22:39] *** Mowah left
[22:39] <pmichaud> Certainly not the 17th.

[22:39] <pmichaud> (which is a Saturday)

[22:39] <masak> oh yes.

[22:39] <masak> apparently I can't read a calendar properly.

[22:39] <jnthn> "many things that should be truly lazily evaluated, now are." -> that comma looks odd to me

[22:39] <masak> removing.

[22:40] *** xabbu42 joined
[22:40] <pmichaud> maybe: "Rakudo now uses immutable iterators internally, and generally hides their existence from programmers.  Many more things are now evaluated lazily."

[22:40] <pmichaud> might be too long.

[22:41] <masak> no, it's fine.

[22:41] * masak uses that

[22:41] <jnthn> Wow...the list of contributors to this months release feels quite sizable. :-)

[22:41] <pmichaud> it's quite impressive, I agree.

[22:41] <masak> any duplicates?

[22:41] <masak> I found a few, maybe not all.

[22:41] <jnthn> 25 people

[22:41] <jnthn> :-D

[22:41] <jnthn> masak: no

[22:42] <jnthn> Or at least, not unless somebody has an alias and a real name pair that I'm not aware of.

[22:43] *** xabbu42_ joined
[22:43] *** xabbu42 left
[22:43] *** xabbu42_ is now known as xabbu42

[22:43] <masak> new version: http://github.com/rakudo/rakudo/blob/master/docs/announce/2010.06

[22:44] <masak> hm, the bullet point about the spectests is improperly indented.

[22:45] <jnthn> + Backtraces with Perl 6 subroutine names and line numbers

[22:45] <pmichaud> +2

[22:45] <jnthn> masak: Is that noteworth enough to be in the announce as well as the changelog?

[22:45] <pmichaud> Yes.

[22:45] <jnthn> masak: It feels like quite a big thing for users.

[22:45] <masak> definitely.

[22:46] <masak> it must have slipped my mind.

[22:46] <masak> jnthn++ # backtraces!

[22:46] <jnthn> Maybe something that hints that the backtraces are more accurate than alphas ever were too.

[22:46] <pmichaud> jnthn: any suggestions for a grant manager for my proposal?  ;-)

[22:46] *** mikehh left
[22:46] <pmichaud> jnthn: I'll punt the issue for now, I think.

[22:46] <jnthn> pmichaud: Grant manager?

[22:46] <dalek> rakudo: 8a1a1a5 | masak++ | docs/ (2 files):

[22:46] <dalek> rakudo: [ChangeLog, announce] improvements

[22:46] <dalek> rakudo: pmichaud++, jnthn++ for the suggestions.

[22:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8a1a1a57aa50d0a44fa28bbf9b19bdf2ed9465b9

[22:47] <pmichaud> for the proposal I'm putting togehter.  I'll send you a copy shortly.

[22:47] <pmichaud> I think I'll just say "I'm not sure who should be manager" and see what we come up with.  :)

[22:47] <masak> that's the old commit. new commit coming up :)

[22:47] <jnthn> pmichaud: It'd feel slighlty weird to grant-manage the pumpking. :-) OTOH, I'm probably better positioned to actually understand/assess it than most due to my level of Rakudo involvement...

[22:48] <jnthn> pmichaud: I'm happy to, so long as it won't be seen as "too cosy" (e.g. given it leaves us essentially managing each others grants :-)).

[22:48] <pmichaud> jnthn: yes; I'm just worried that it starts to look a bit strange if we're all serving as manager's for each other's grants.

[22:48] <pmichaud> right, what you just said :)

[22:48] <masak> vim's spellchecker found a double 'the the' that neither of us had found. :P

[22:49] <pmichaud> I totally can't believe we we missed that!

[22:49] <masak> :P :P

[22:49] <masak> final version so far: http://github.com/rakudo/rakudo/blob/master/docs/announce/2010.06

[22:50] <masak> (this might be the one!)

[22:50] <pmichaud> ooc, where does the 33,280 number come from?

[22:50] <masak> docs/spectest-progress.csv

[22:50] * jnthn double checks the Ukrainian words

[22:50] <masak> last line, third column.

[22:51] <pmichaud> that number was actually as of 0000 UTC

[22:51] <pmichaud> the release probably passes quite a few more than that :-P

[22:51] *** xabbu42 left
[22:51] *** xabbu42_ joined
[22:51] <masak> care to give a newer number?

[22:51] <pmichaud> anyway, it's fine to cite that number.

[22:51] <pmichaud> I don't think we want to wait an hour for me to calculate the new one.

[22:51] <pmichaud> Oh, I might have a calc... just a sec

[22:51] <masak> :)

[22:52] <pmichaud> as of 1320 this morning, we were passing 33378

[22:52] *** Schwern joined
[22:52] <pmichaud> out of 39887 counted.

[22:52] <masak> ok.

[22:52] <masak> I can change it to that.

[22:52] <dalek> rakudo: 6b12f89 | masak++ | docs/announce/2010.06:

[22:52] <dalek> rakudo: [announce] more fixes

[22:52] <dalek> rakudo: jnthn++ for suggestions.

[22:52] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6b12f89d7b6defc9434fff160e994d6a70faeb59

[22:53] *** patspam left
[22:54] <pmichaud> I think it looks really good.

[22:54] <pmichaud> Amazing progress this past month.

[22:54] <pmichaud> actually, amazing progress this past three months.

[22:54] <masak> indeed.

[22:54] <masak> for a bunch of raving lunatics, we're doing pretty good. :P

[22:55] <jnthn> I'm a true believer in all of us!

[22:55] <[particle]> pmichaud: re: grant manager... jhorwitz?

[22:55] *** eternaleye joined
[22:55] <[particle]> he is a tpf grant manager

[22:56] * masak runs 'make release 2010.06'

[22:56] *** tedv joined
[22:56] <pmichaud> [particle]: excellent suggestion also

[22:56] <masak> "Try 'make release VERSION=yyyymm'"

[22:56] <pmichaud> the manager for this grant is going to have very little to have to do

[22:56] <masak> should I update the release guide? :)

[22:56] <pmichaud> it should be VERSION=yyyy.mm"

[22:56] <pmichaud> (note dot)

[22:57] <pmichaud> at least, I think it's supposed to have the dot.

[22:57] * [particle] wishes he was able to contribute something this past month

[22:57] <masak> aye.

[22:57] <pmichaud> oh, wait.

[22:57] <masak> missed the VERSION=

[22:57] <pmichaud> yes.

[22:57] <[particle]> pmichaud: i'll offer myself, but that might still be to incestuous

[22:57] <masak> but the error message is missing the dot.

[22:57] <pmichaud> the error message needs a fix then ( can happen post release )

[22:58] <masak> aye

[22:58] <masak> I'll try to remember, and fix it post-release.

[22:58] <dalek> rakudo: 5eb3875 | masak++ | docs/announce/2010.06:

[22:58] <dalek> rakudo: [announce] more recent passing-tests figure

[22:58] <dalek> rakudo: pmichaud++ contributed it.

[22:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5eb38753c19ca0bc284955019ee4a701b61904cf

[22:59] *** skids joined
[22:59] *** xabbu42_ left
[22:59] *** xabbu42 joined
[23:00] * masak untars and runs spectests in a different directory

[23:03] <masak> the release guide speaks about an 'initial tarball'. is the implication that after applying the git tags, one should produce a new tarball?

[23:03] *** xabbu42 left
[23:03] *** xabbu42 joined
[23:03] <pmichaud> no

[23:03] *** lestrrat is now known as lest_away

[23:03] <pmichaud> the intent is that the tarball might not work, and so you'd have to fix something and possibly make another

[23:03] <masak> right.

[23:03] <pmichaud> however, I don't think that's ever really happened in practice

[23:04] <masak> :)

[23:04] <pmichaud> so if you want to remove "initial" or otherwise rephrase the document, +1 from me :)

[23:04] <masak> will do.

[23:04] <masak> running spectests just in case, one last time.

[23:04] <pmichaud> yes, I do that as well.

[23:04] <pmichaud> masak++

[23:04] <masak> I have a number of smallish changes to the release guide, but I'll push them after the release.

[23:04] <pmichaud> wfm.

[23:06] * masak finally gets an account at rakudo.org

[23:07] <pmichaud> masak: do you need posting privs?

[23:07] <masak> I'll shout if I do. still creating the account.

[23:08] <masak> yes, seems I do.

[23:08] <masak> account name 'masak'.

[23:08] <pmichaud> done, I think.

[23:09] <masak> I don't see any difference...

[23:09] <pmichaud> oh, oops.

[23:09] *** shade__ is now known as \shade\

[23:09] <pmichaud> try now.

[23:09] <pmichaud> (reload)

[23:09] <masak> that's better. :)

[23:09] <masak> thanks.

[23:11] *** eternaleye_ joined
[23:12] *** xabbu42_ joined
[23:12] *** xabbu42 left
[23:12] *** xabbu42_ is now known as xabbu42

[23:12] *** eternaleye left
[23:13] * masak likes Aaron Sherman's suggestion about underscores after the radix in numbers

[23:14] <masak> std: 0x_dead_beef

[23:14] <p6eval> std 31325: OUTPUT«[31m===[0mSORRY![31m===[0m␤Whitespace is required between alphanumeric tokens at /tmp/RJjIcwt5A6 line 1:␤------> [32m0[33m⏏[31mx_dead_beef[0m␤Whitespace is required between alphanumeric tokens at /tmp/RJjIcwt5A6 line 1:␤------> [32m0x[33m⏏[31m_dead_beef[0m␤Undeclared

[23:14] <p6eval> ..na…

[23:15] <diakopter> std: 0xd_ead_beef

[23:15] <p6eval> std 31325: OUTPUT«ok 00:01 104m␤»

[23:18] *** pronik` joined
[23:18] *** pronik left
[23:21] <jnthn> masak: Unfortunately, though, he's patched a generated file.

[23:21] <masak> we're getting comment spam on rakudo.org. I removed those I just discovered.

[23:21] <jnthn> masak: Maybe we need a note in ext/nqp-rx in Parrot saying not to edit the files

[23:21] <masak> jnthn: I suspected as much. someone should tell him.

[23:21] <jnthn> Or maybe there is one.

[23:21] <masak> generally, generated files should contain a note, yes. :)

[23:21] <masak> "OH HAI IM GENERATED"

[23:22] *** xabbu42_ joined
[23:22] *** xabbu42 left
[23:22] *** xabbu42_ is now known as xabbu42

[23:23] *** snarkyboojum joined
[23:26] <pmichaud> the file does say it's generated.

[23:27] <pmichaud> errrr..... it *used* to say it.

[23:27] <pmichaud> hmmm

[23:27] * pmichaud makes a note to go add notes to the generate files.

[23:28] <pmichaud> ...and wonders what happened to the code he added last month-ish to add notes to the files...

[23:29] * cxreg adds .rand to a subset condition

[23:29] *** cdarroch left
[23:29] *** xabbu42 left
[23:29] <cxreg> subset Lol of Int where { 2.rand.Int }

[23:29] *** xabbu42 joined
[23:31] *** arthur-_ left
[23:32] *** REPLeffect left
[23:33] <masak> rakudo: subset Lol of Int where { (0..1).pick }; say 5 ~~ Lol for ^10

[23:34] <p6eval> rakudo 736bef: OUTPUT«0␤1␤1␤0␤0␤0␤1␤0␤1␤0␤»

[23:34] <masak> interesting idea. subsets which change over time.

[23:34] *** arthur-_ joined
[23:35] <arnsholt> I can't decide if I hate you or love you =D

[23:35] *** REPLeffect joined
[23:35] <TimToady> the two are not mutually exclusive

[23:35] <arnsholt> Heh, true

[23:36] <masak> rakudo: subset IntOnAThursday of Int where { Date.today.day-of-week == 4 }; say 5 ~~ IntOnAThursday

[23:36] <p6eval> rakudo 736bef: OUTPUT«1␤»

[23:36] <masak> \o/

[23:36] *** macdaddy left
[23:36] <arnsholt> But it's friday! ^^

[23:36] <masak> arnsholt: not in UTC :)

[23:36] <arnsholt> Spoilsport ;p

[23:36] <jnthn> masak: At some talk a while back I caused some amusement by writing a sub signature that'd randomly fail to bind. :-)

[23:37] <masak> there's much untapped fun here, for sure.

[23:38] *** xabbu42_ joined
[23:38] *** xabbu42 left
[23:38] *** xabbu42_ is now known as xabbu42

[23:38] <pmichaud> rakudo:  say "I can't decide if I {any(<hate love>)} you."

[23:38] <p6eval> rakudo 736bef: OUTPUT«I can't decide if I any("hate", "love") you.␤»

[23:39] <pmichaud> :-D

[23:42] *** REPLeffect left
[23:43] <masak> rakudo: say "I've decided: I {<hate love>.pick} you." # risky!

[23:43] <p6eval> rakudo 736bef: OUTPUT«I've decided: I hate you.␤»

[23:44] <masak> :(

[23:44] <jnthn> hugme: hug masak

[23:44] * hugme hugs masak

[23:44] <masak> :)

[23:44] *** xabbu42_ joined
[23:44] *** xabbu42 left
[23:44] *** xabbu42_ is now known as xabbu42

[23:44] <jnthn> rakudo: say "She loves me { ('', 'not').pick }"

[23:44] <p6eval> rakudo 736bef: OUTPUT«She loves me not␤»

[23:45] <jnthn> Typical.

[23:45] <masak> hugme: hug jnthn 

[23:45] * hugme hugs jnthn

[23:45] <jnthn> :)

[23:45] *** REPLeffect joined
[23:48] <masak> release announcement posted to rakudo.org, p6l, p6c, p6announce, p6u, and use.perl.org. I updated the Wikipedia article.

[23:48] <jnthn> masak: Got the mail. \o/

[23:48] * jnthn wonders if use.perl.org copes with the unicode chars

[23:48] <masak> the independant spectest has finished, after 35 minutes. it looks good.

[23:48] <masak> jnthn: in posts, yes. in comments, no.

[23:48] <masak> http://use.perl.org/~masak/journal/40405

[23:49] <jnthn> ah, phew

[23:49] <pugssvn> r31337 | lwall++ | [S02] allow _ between radix and digits as suggested by ajs++ 

[23:49] <jnthn> I was sure there was some issue somewhere.

[23:50] <pugssvn> r31338 | lwall++ | [STD] allow _ between radix and digits as suggested by ajs++ 

[23:50] <sorear> hugme is for wusses.

[23:50] * sorear hugs masak

[23:51] <dalek> rakudo: cbff7d0 | masak++ | docs/release_guide.pod:

[23:51] <dalek> rakudo: [docs/release_guide.pod] updates and improvements

[23:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cbff7d0ccad461d51679b39ab7f04b5691e47716

[23:52] <masak> sorear: if that's what it takes to get hugs, I'm a wuss. :P

[23:52] *** xabbu42 left
[23:52] *** xabbu42 joined
[23:52] * masak goes to look up 'wuss'

[23:52] <jnthn> If I get wussier, do I get hugged more?

[23:52] * jnthn gets curious about the etymology

[23:53] *** REPLeffect left
[23:53] <jnthn> oh

[23:53] <jnthn> It's recentish maybe

[23:53] <masak> jnthn: depends if there's a correlation between degree of wussiness and amount of hugs. :)

[23:54] <masak> dictionary.com suggest it's from the 1980s.

[23:54] <masak> perhaps a mixture of 'wimp' and 'puss'.

[23:54] *** REPLeffect joined
[23:54] <masak> there's also 'wussy', which corroborates that.

[23:54] <jnthn> masak: I think I mixture of wimp and pussy

[23:55] <masak> oh, but that's the adhective form.

[23:55] <jnthn> To get wussy

[23:55] <jnthn> Which was then shortened.

[23:55] <jnthn> *a mixture

[23:55] *** xabbu42_ joined
[23:55] *** xabbu42 left
[23:55] *** xabbu42_ is now known as xabbu42

[23:55] <masak> right. 'wuss' might be a fairly obvious back-formation from 'wussy'.

[23:55] <jnthn> You can call somebody a pussy if they're being a a wimp.

[23:55] <masak> but 'puss' also is a noun, meaning 'cat'.

[23:56] <jnthn> Yes, but more slangy, at least in my dialect

[23:56] <jnthn> Puss is also nasty fluid

[23:56] <masak> no, that's with one 's'.

[23:57] <dalek> rakudo: 30db218 | masak++ | build/Makefile.in:

[23:57] <dalek> rakudo: [Makefile.in] added missing '.' in error message

[23:57] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/30db218e6eeeb6cc56c25e6b916dbc34a524e4ee

[23:57] <jnthn> masak: Really?

[23:58] <jnthn> oh, yes

[23:58] <snarkyboojum> puss can also mean 'girl or young woman' apparently - never heard it used that way though

[23:58] <snarkyboojum> according to thefreedictionary.com anyway

[23:58] <masak> jnthn: don't debate English spelling with a Swede. :P

[23:59] <jnthn> snarkyboojum: I'd...not try it. :)

[23:59] <arnsholt> snarkyboojum: My guess would be that the "girl" meaning has been replaced by a more, er, narrow sense =)

[23:59] <snarkyboojum> jnthn: I can imagine even a romantic mood wouldn't help :)

[23:59] <jnthn> masak: It sucks to be a native speaker, never quite knowing how to spell things. :-)

[23:59] *** supernovus joined
[23:59] <jnthn> snarkyboojum: OTOH, I've heard all kinds of terms of endearment from different dialects in the UK, so I guess it varies a lot.

[23:59] <arnsholt> (For some reason words for woman and girl are prone to extreme semantic drift)

[23:59] <masak> jnthn: I have no idea what you're talking about :P

