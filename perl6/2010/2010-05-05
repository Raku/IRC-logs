[00:12] <lichtkind> Juerd: hej

[00:13] *** literal left
[00:25] *** slavik1 joined
[00:26] *** slavik left
[00:27] *** nihiliad joined
[00:34] *** ash_ joined
[00:44] *** johnjohn101 joined
[00:48] *** plobsing joined
[00:55] <Juerd> lichtkind: Hi

[00:55] <lichtkind> ah :)

[00:57] <lichtkind> Juerd: cant find excape sequence in synopses , can you help?

[00:57] <Juerd> I'm about to go to bed

[00:58] <Juerd> What do you want to know, exactly?

[01:00] <lichtkind> Juerd:  cant find where i once copied that from synopses http://www.perlfoundation.org/perl6/index.cgi?perl_6_lookup_tablet#escape_sequences

[01:08] <Juerd> Can't find it

[01:08] <Juerd> Must have been S05 though.

[01:09] <lue> ohi

[01:09] <phenny> lue: 04 May 09:28Z <masak> tell lue that I don't know if it corresponds exactly to what you're working on, but this might interest you: http://use.perl.org/~masak/journal/39238

[01:09] *** ruoso joined
[01:10] <Juerd> lichtkind: http://diveintoperl6.blogspot.com/2007/06/perl-6-round-4.html and http://trac.parrot.org/parrot/browser/branches/pmc_pct/docs/book/ch05_pge.pod?rev=39377

[01:11] <Juerd> lichtkind: I googled for one of the lines.

[01:11] <Juerd> Good night

[01:12] <lichtkind> good night

[01:12] <lichtkind> sleep well

[01:12] <lue> phenny: tell masak ooh! That could come in handy ( esp. considering one of my theories involves codons :) )

[01:12] <phenny> lue: I'll pass that on when masak is around.

[01:16] <sorear> ok, I have successfully relayed closure problem information to pmichaud, my work here is done

[01:16] <phenny> sorear: 04 May 14:54Z <masak> tell sorear that `macro postfix:<san> { q[~ "san"] }; say "sorear"san` just prints "san\n"

[01:16] <lue> Although I was shooting for binary (A&T as one digit, C&G as the other), I considered quaternary before, *and* it maintains special ties with binary & hex :)

[01:16] <snarkyboojum> sorear++

[01:17] <snarkyboojum> hellue

[01:18] <snarkyboojum> how about the REPL thing sorear? :)

[01:19] <lue> rakudo: subset DNA of Str where { all(.uc.comb) eq any <A C G T> }; my DNA $dna = "gattaca"; say $dna;

[01:19] <p6eval> rakudo 1eef08: OUTPUT«gattaca␤»

[01:21] <lue> weird, failure on my end /me updates

[01:23] <snarkyboojum> rakudo: subset DNA of Str where { all(.uc.comb) eq any <A C G T> }; my DNA $dna = "zxbbbyy"; say $dna;

[01:23] <p6eval> rakudo 1eef08: OUTPUT«Type check failed for assignment␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[01:23] <snarkyboojum> w00t

[01:28] <lue> rakudo: say :4<10>.fmt('%x') #predict 4

[01:28] <p6eval> rakudo 1eef08: OUTPUT«4␤»

[01:28] *** mantovan1 joined
[01:28] *** mantovan1 left
[01:28] *** mantovan1 joined
[01:36] *** johnjohn101 left
[01:37] <lue> there's no way to use .fmt() to convert ->to-> arbitrary bases is there?

[01:40] <ash_> you mean like take 15 in decimal and print it's binary representation in a string? 

[01:43] <lue> print its quaternary representation, for example

[01:43] <lue> I know binary, octal, and hex are supported, but not arbitrary

[01:45] <ash_> how arbitrary do you need? 

[01:46] <lue> right now, only to base 4

[01:46] <ash_> you could write a module to do it, thats an odd number base...

[01:48] *** k23z__ left
[01:52] *** mantovan1 left
[01:52] *** log joined
[01:54] <colomon> rakudo: say e.log

[01:54] <p6eval> rakudo 1eef08: OUTPUT«1␤»

[01:59] *** Psyche^ joined
[02:01] *** elmex left
[02:01] *** agentzh joined
[02:03] *** Patterner left
[02:03] *** Psyche^ is now known as Patterner

[02:04] *** wknight8111 left
[02:04] <lue> rakudo: my $hi='oii'; say $hi[1]

[02:04] <p6eval> rakudo 1eef08: OUTPUT«i␤»

[02:04] <lue> why does it die for me? :(

[02:05] <snarkyboojum> what error? :)

[02:07] <colomon> that shouldn't be legal, should it?

[02:07] <snarkyboojum> alpha: my $hi='oii'; say $hi[1]

[02:07] <p6eval> alpha 30e0ed: OUTPUT«Method 'postcircumfix:[ ]' not found for invocant of class 'Str'␤in Main (file src/gen_setting.pm, line 324)␤»

[02:07] <lue> Malformed my at line 1, near "='oii'; sa"

[02:08] <lue> I typed: ./perl6 -e "my $hi='oii'; say $hi[1]"

[02:08] <ash_> pugs: my $a = 'hello'; say $a[2];

[02:08] <p6eval> pugs: OUTPUT«␤»

[02:08] <ash_> lue: in my terminal, i have to escape the $'s 

[02:09] <ash_> works locally... 

[02:09] <snarkyboojum> same here :)

[02:09] <ash_> colomon: should that be illegal? 

[02:09] <colomon> as far as I know, yes.

[02:10] <lue> I've never had to escape them before. That's weird.

[02:10] *** elmex joined
[02:13] <snarkyboojum> rakudo: my $hi='oii'; say $hi<xyz>

[02:14] <p6eval> rakudo 1eef08: OUTPUT«o␤»

[02:14] <snarkyboojum> how does that one work?

[02:16] <lue> what would the legal way be then?

[02:16] <snarkyboojum> rakudo: my $hi='oii'; say $hi<abc>

[02:16] <p6eval> rakudo 1eef08: OUTPUT«o␤»

[02:16] <colomon> xyz == 0

[02:16] <colomon> but ick.

[02:16] <snarkyboojum> oic

[02:17] <snarkyboojum> rakudo: say +<abc>

[02:17] <colomon> rakudo: my $hi = "hello"; say $hi.substr(4, 1);

[02:17] <p6eval> rakudo 1eef08: OUTPUT«0␤»

[02:17] <p6eval> rakudo 1eef08: OUTPUT«o␤»

[02:17] <colomon> rakudo: my $hi = "hello"; say $hi.substr(2, 1);

[02:17] <p6eval> rakudo 1eef08: OUTPUT«l␤»

[02:18] <lue> so there isn't MTOWTDI is there? (I like the [] slicing. It should be kept)

[02:19] <snarkyboojum> rakudo: say 'hello'.split('')[4]

[02:19] <p6eval> rakudo 1eef08: OUTPUT«o␤»

[02:20] <lue> :)

[02:21] <lue> AFAIK, It's like snowman/comet. the [] is not supposed to work, but it has no forseeable danger.

[02:23] *** yinyin joined
[02:24] * lue wonders if you can take a regex as input and put it inside / /

[02:26] <snarkyboojum> rakudo: my $a = "hello"; say $a[].WHAT

[02:26] <p6eval> rakudo 1eef08: OUTPUT«Parcel()␤»

[02:29] *** synth left
[02:29] <lue> would something like my $a="[a-z]?"; my Regex $b = /$a/; be legal?

[02:35] *** snarkyboojum left
[02:35] *** abbe left
[02:38] *** cotto left
[02:40] *** lichtkind left
[02:43] *** log left
[02:43] <ash_> lue sure thats legal, but that might not mean what you think it means

[02:44] <ash_> do you want the string to eval to its regex literal? 

[02:46] *** snarkyboojum joined
[02:47] *** cotto joined
[02:48] <lue> Yes, I want what's in the string to be put in // and be treated as if I hard-coded the contents of the string into the regex.

[02:49] <ash_> you could eval it

[02:49] <lue> basically, my ultimate goal is to create an 'alias' circumfix for regexes.

[02:50] <lue> such as, say, ø[a-zA-z]?ø being another way of writing regexes.

[02:51] <colomon> rakudo: my $a ="f.*"; my $b = eval "rx/$a/"; say "hello friend" ~~ $b;

[02:52] <p6eval> rakudo 1eef08: OUTPUT«friend␤»

[02:52] <colomon> rakudo: my $a ="f.*"; my $b = eval "rx/$a/"; say "hello friend" ~~ /$b/;

[02:52] <p6eval> rakudo 1eef08: OUTPUT«␤»

[02:52] <colomon> rakudo: my $a ="f.*"; my $b = rx/f.*/; say "hello friend" ~~ /$b/;

[02:52] <p6eval> rakudo 1eef08: OUTPUT«␤»

[02:52] <ash_> you could extend the grammar

[02:52] <ash_> the regex grammar 

[02:53] *** cotto left
[02:53] <colomon> I think the eval method is probably the easiest way to go.  though looks like variable interpolation still doesn't work in regexes?

[02:53] <lue> I'm only trying to reimplement snowm— *cough**cough**haak* sorry.

[02:54] * colomon has completely destroyed his local implementation of log. :(

[02:55] <lue> :(

[02:56] <lue> I think extending the grammar (as long as it doesn't give me a heart attack trying) is the best way to go.

[03:02] <sorear> lue: you can do that right now with macros

[03:03] <sorear> and now I'm backlogged.  only took 9h

[03:03] <ash_> sorear: how far along are macros? i haven't checked recently

[03:04] <sorear> I have syntactic category macros

[03:04] <sorear> you can extend any protoregex

[03:05] <sorear> for instance, proto token term { ... }

[03:05] <lue> i.e. proto circumflex:<ø ø> { yada }

[03:05] <lue> ?

[03:07] *** mtve left
[03:07] <sorear> close

[03:08] *** cotto joined
[03:08] <lue> oh! darn :)

[03:09] *** mtve joined
[03:09] <sorear> macro quote:<ø ø> is parsed(/'ø'<p6regex=.LANG('Regex', 'nibbler')>'ø'/) { self.quote:sym</ />($/) } ought to do it

[03:10] <ash_> rakudo: macro quote:<ø ø> is parsed(/'ø'<p6regex=.LANG('Regex', 'nibbler')>'ø'/) { self.quote:sym</ />($/) }; say 'foo' ~~ øfooø;

[03:10] <p6eval> rakudo 1eef08: OUTPUT«Confused at line 11, near "macro quot"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[03:13] <lue> hmm..

[03:14] *** BrowserUk left
[03:14] *** envi^home joined
[03:15] <sorear> ash_: the patch review board hasn't gotten back to me yet. also I've got a bugrep from masak to deal with.

[03:15] <ash_> ah, got ya 

[03:16] * lue has never heard of the PRB

[03:22] *** cognominal left
[03:26] *** cognominal joined
[03:28] <diakopter> also I think p6eval rakudo is frozen on an older build still

[03:30] <lue> I get that same confusion, so I don't think it's an old build issue.

[03:35] *** meppl joined
[03:36] *** [Coke] joined
[03:36] <[Coke]> hio. Anyone here with privs on feather that could install kcachegrind?

[03:37] *** stephenlb left
[03:43] <diakopter> [Coke]: sure

[03:44] <[Coke]> diakopter: I am trying the macport on OS X, but I have low hopes. =-)

[03:45] <diakopter> hrm

[03:45] <diakopter> it seems debian experimental insanity has once again overtaken feather

[03:46] <sorear> feather is running experimental?

[03:46] * sorear quickly checks if kcachegrind is installable today (libc upgrades fff)

[03:47] <diakopter> er, maybe not

[03:47] <diakopter> it was at some point a couple years ago

[03:47] <lue> feather runs debian-based linux? Wow!

[03:47] <diakopter> running experimental, I mean.

[03:47] *** nihiliad left
[03:48] <diakopter> sid and experimental

[03:48] <diakopter> sid has priority

[03:49] <sorear> lue: how wow?

[03:49] <diakopter> [Coke]: done

[03:49] *** snarkyboojum left
[03:51] <[Coke]> diakopter: fast!

[03:53] <lue> I just don't care for debian's binary blobs :)

[03:53] <[Coke]> also: holy crap it works.

[03:53] <lue> That's why I choose Fedora!

[03:54] <lue> .oO(The Distro Holy Wars hath begun)

[03:56] *** justatheory left
[03:57] <sorear> drat, I seem to have pinged out since the last time someone opped me

[03:57] *** kfo_ joined
[03:58] <lue> *gulp*

[03:58] *** JimmyZ joined
[04:00] *** kfo left
[04:00] *** kfo_ is now known as kfo

[04:01] *** snarkyboojum joined
[04:03] <lue> IIUC, I just created a P6 blog: http://rdstar.wordpress.com/

[04:03] <lue> The first post is just to have a first post. Any questions as to why I posted that, look at the tagline in the top-right first :)

[04:06] <JimmyZ> lue++

[04:06] <JimmyZ> nice blog

[04:07] <sorear> maybe I should resurrect the Perl 6 rewrite of Angband I started two Aprils ago

[04:07] <lue> I get the feeling that's a text game :)

[04:08] <sorear> mostly.

[04:08] <sorear> ot

[04:08] <sorear> it's from the roguelike heritage - ASCII art video game

[04:08] <lue> ASCII art win \o/

[04:08] <lue> afk

[04:08] <sorear> not to be confused with aadoom

[04:09] <sorear> which is an entirely different sort of win

[04:16] *** jonrafkind joined
[04:20] *** molaf joined
[04:20] <snarkyboojum> lue: cool! another blog to subscribe to :)

[04:24] <snarkyboojum> lue: the about page is still a default I think http://rdstar.wordpress.com/about/

[04:28] <ash_> neat, one of the GSoC project for GCC is to make a python frontend for AOT compiles python

[04:29] *** plobsing left
[04:36] *** jonasbn joined
[04:42] *** kst left
[04:45] *** kst joined
[04:53] *** gfx joined
[04:57] *** molaf left
[05:04] * sorear has achieved POST-enlightenment

[05:05] *** rv2733 left
[05:07] *** chitragupt left
[05:07] *** chitragupt joined
[05:07] *** rv2733 joined
[05:08] *** simcop2387 left
[05:12] *** simcop2387 joined
[05:12] *** tri1 joined
[05:13] *** tri1 left
[05:22] *** justatheory joined
[05:28] *** [mark] joined
[05:29] *** jonrafkind left
[05:32] *** steinberg joined
[05:37] *** lue left
[05:38] *** kaare joined
[05:38] *** kaare is now known as Guest66879

[05:41] *** kst left
[05:43] *** kst joined
[05:48] *** REPLeffect left
[06:02] *** REPLeffect joined
[06:03] *** justatheory left
[06:04] *** uniejo joined
[06:12] <sorear> Does Perl 6 have a mechanism for implicit coercions?

[06:13] <sorear> i.e. if a sub foo(Int $x) {}; foo(MyClass.new) # Can I define anythin in MyClass to make this work?

[06:13] <sorear> "is Int" doesn't count :p

[06:27] <moritz_> sorear: nothing; it would make multi dispatch too complex

[06:27] <moritz_> sorear: you can define sub foo($x as Int) { ... } though

[06:27] <moritz_> sorear: and then class MyClass { method Int { ... } }

[06:30] <sorear> 'as' Int?

[06:31] * sorear points at t/spec/S06-macros/postfix.t and asks how to implement it

[06:31] <sorear> it's using macro postfix:<!> (Int $n) {... and expecting to coerce the AST

[06:32] <sorear> 1. Coercions for only dispatch?

[06:32] <sorear> 2. Macro calling introspects signatures?

[06:32] <sorear> 3. The spectest is wrong?

[06:33] <moritz_> 3.

[06:33] <sorear> ok then.

[06:33] <moritz_> it was back from pugs days, and pugs didn't do type checks

[06:33] <sorear> Should there be an easy way for macros to expect an argument to be a compile time constant and get the value?

[06:34] *** Guest66879 is now known as kaare_

[06:34] <sorear> pugs didn't do macros either.

[06:34] <moritz_> so many tests from that area are sloppy/wrong with type annotations

[06:34] <moritz_> pugs: macro foo { say "hi" }; foo

[06:34] <p6eval> pugs: OUTPUT«hi␤*** ␤    Unexpected end of input␤    expecting bare or pointy block construct, ":" or identifier␤    Macro did not return an AST, a Str or a Code!␤    at /tmp/JuQc5YOMQl line 2, column 1␤»

[06:34] <moritz_> you're right :-)

[06:36] <sorear> oh, looks like pugs *did* do macros :(

[06:36] <JimmyZ> rakudo: sub foo( $x as Int is copy) { say ++$x }; class bar { method Int() { '10' }}; foo(bar.new());

[06:36] <p6eval> rakudo 1eef08: OUTPUT«11␤»

[06:36] <sorear> I feel so not-pioneering

[06:37] <moritz_> if it had macro support, it was very basic

[06:40] <JimmyZ> rakudo: multi sub foo(bar $x as Int is rw) { say ++$x }; class bar { method Int() { '10' }}; foo(bar.new());

[06:40] <p6eval> rakudo 1eef08: OUTPUT«Invalid typename in parameter declaration at line 11, near " $x as Int"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[06:40] <moritz_> the 'bar $x' is actually the problem

[06:41] <JimmyZ> why?

[06:41] <moritz_> because there's no type name bar

[06:41] <moritz_> it's declare later on

[06:41] <JimmyZ> rakudo: class bar { ... } multi sub foo(bar $x as Int is rw) { say ++$x }; class bar { method Int() { '10' }}; foo(bar.new());

[06:41] <p6eval> rakudo 1eef08: OUTPUT«Confused at line 11, near "class bar "␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[06:41] <JimmyZ> rakudo: class bar { ... }; multi sub foo(bar $x as Int is rw) { say ++$x }; class bar { method Int() { '10' }}; foo(bar.new());

[06:41] <p6eval> rakudo 1eef08: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[06:41] <JimmyZ> rakudo: class bar { ... }; multi sub foo(bar $x as Int is copy) { say ++$x }; class bar { method Int() { '10' }}; foo(bar.new());

[06:42] <p6eval> rakudo 1eef08: OUTPUT«11␤»

[06:42] <JimmyZ> oh, it likes C, must pre-declare it

[06:44] *** thowe left
[06:45] <JimmyZ> rakudo: class bar { }; multi sub foo(bar $x as Int is copy) { say ++$x }; class bar { method Int() { '10' }}; foo(bar.new());

[06:45] <p6eval> rakudo 1eef08: OUTPUT«Illegal redeclaration of symbol 'bar'␤current instr.: 'perl6;Perl6;Grammar;_block257' pc 42659 (src/gen/perl6-grammar.pir:274)␤»

[06:46] *** steinberg left
[06:51] *** iblechbot joined
[06:52] *** kst left
[06:53] *** steinberg joined
[06:54] *** kst joined
[06:55] *** thowe joined
[06:59] <JimmyZ> how to define non-global classes?

[07:01] <moritz_> my class ...

[07:02] <JimmyZ> rakudo: my class bar { method Str() { '11'; }; };  multi sub foo(bar $x as Int is copy) { say ++$x }; augment class bar { method Int() { '10' }};    foo(bar.new());

[07:02] <p6eval> rakudo 1eef08: OUTPUT«Can't augment class bar without 'use MONKEY_TYPING'␤current instr.: 'perl6;Perl6;Grammar;add_name' pc 42888 (src/gen/perl6-grammar.pir:353)␤»

[07:05] <JimmyZ> non-global classes shouldn't use MONKEY_TYPING for augment class

[07:07] <JimmyZ> rakudo: my class bar { method Str() { '11'; }; };  multi sub foo(bar $x as Int is copy) { say ++$x }; my augment class bar { method Int() { '10' }};    foo(bar.new());

[07:07] <p6eval> rakudo 1eef08: OUTPUT«Malformed my at line 11, near "augment cl"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[07:07] <moritz_> does the spec say that?

[07:07] <JimmyZ> In order to discourage casual misuse of these declarators, they are not allowed on global classes unless you put a special declaration at the top:

[07:08] * sorear just figured out that reusing declarations in the REPL === separate compilation of the setting

[07:08] <sorear> so, topic/lexical-persistence will do both.

[07:09] <JimmyZ> So, they are allowed on non-global classes.

[07:09] <JimmyZ> S12:2032

[07:11] <moritz_> sorear: is that good or bad news

[07:12] <JimmyZ> Am I right?

[07:13] <moritz_> I think so, yes

[07:13] <moritz_> feel free to ticket it

[07:14] <JimmyZ> OK, thanks, will do

[07:14] *** rv2733 left
[07:18] <JimmyZ> rakudo: my class bar { method Str() { '11'; }; };  multi sub foo(bar $x as Int is copy) { say ++$x }; augment my class bar { method Int() { '10' }};    foo(bar.new());

[07:18] <p6eval> rakudo 1eef08: OUTPUT«Malformed augment at line 11, near "my class b"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[07:20] *** Intensity left
[07:29] *** gfx left
[07:33] <sorear> moritz_: good, since PCT's memory usage is O(size of translation unit)

[07:33] <sorear> compile each setting module, then cat pir will use much less memory

[07:34] <sorear> although looking at !UNIT_START it may not work quite so well

[07:34] <sorear> !UNIT_START does lots of stuff that should really only be done once; I wonder why e.g. setting up %*ENV is not done in a setting INIT block

[07:54] <moritz_> you may well patch it to do so

[07:56] <sorear> I've already determined that it's impossible

[07:56] <sorear> I'll just patch it to add an explanatory comment, instead

[08:19] <moritz_> rakudo: sub foo($) { say "hi" }; foo(3)

[08:19] <p6eval> rakudo 1eef08: OUTPUT«hi␤»

[08:20] <moritz_> rakudo: sub foo(@) { say "hi" }; foo(3) #should barf

[08:20] <p6eval> rakudo 1eef08: OUTPUT«Nominal type check failed for parameter ''; expected Positional but got Int instead␤current instr.: 'foo' pc 179 (EVAL_1:22219452)␤»

[08:20] <moritz_> rakudo: sub foo(@) { say "hi" }; foo([]) #should barf

[08:20] <p6eval> rakudo 1eef08: OUTPUT«hi␤»

[08:20] <moritz_> that should not barf :-)

[08:23] *** dakkar joined
[08:23] <sorear> > my $x = 4;

[08:23] <sorear> > say $x;

[08:23] <sorear> 4

[08:24] <moritz_> \o/

[08:24] <moritz_> does it involve evil sorcery?

[08:24] <moritz_> black magic?

[08:24] <sorear> far less than Devel::REPL does

[08:25] <sorear> and what's more, it's *existing* evil sorcery

[08:25] <sorear> I effectively put a YOU_ARE_HERE; at the end of every repl line

[08:25] <sorear> (there are a few complications and nicities involved)

[08:26] <moritz_> so you push all lexical symbols onto the setting, effectively?

[08:27] <sorear> yes

[08:28] <sorear> but I keep the old setting around so modules aren't affected

[08:31] * sorear goes off to implement P

[08:35] *** TiMBuS joined
[08:43] *** kst left
[08:45] *** kst joined
[08:46] *** uniejo left
[08:46] *** meppl left
[08:46] *** Tene left
[08:46] *** opx^away left
[08:46] *** tomaw left
[08:46] *** pugssvn left
[08:46] *** Gothmog_ left
[08:46] *** felipe left
[08:46] *** kolibrie left
[08:47] *** uniejo joined
[08:47] *** meppl joined
[08:47] *** Tene joined
[08:47] *** opx^away joined
[08:47] *** tomaw joined
[08:47] *** pugssvn joined
[08:47] *** Gothmog_ joined
[08:47] *** PZt joined
[08:47] *** Maddingue joined
[08:47] *** f00li5h joined
[08:47] *** estrabd joined
[08:47] *** mathw joined
[08:47] *** kolibrie joined
[08:47] *** card.freenode.net sets mode: +v pugssvn

[08:48] <sorear> What's the difference between <foo> and <.foo> ?

[08:50] <moritz_> <.foo> doesn't capture

[08:51] *** xabbu42 joined
[08:53] *** zag joined
[08:53] <sorear> ah

[08:54] <moritz_> I can recommend S05 -- it's a good read :-)

[08:55] <sorear> the synopses can be read ten times and they're still good reads.

[08:55] <sorear> I think I'm at #7 or so for S05

[08:56] <moritz_> :-)

[08:56] <moritz_> sounds like my number of passes, too

[08:57] <moritz_> the first few times I didn't know what to make of that weird "longest token matching"

[09:00] <sorear> I've hung around lex(1) long enough to know exactly what that means, but I still haven't quite figured out how Perl implements it

[09:01] <sorear> (which did not help when I had to hack protoregexes in NQP-rx for syntactic category macros)

[09:01] <moritz_> nqp-rx doesn't really implement it

[09:01] <moritz_> which is the culprit

[09:01] <moritz_> it only implements longest constant prefix

[09:02] <moritz_> I've tried to explain my understanding of LTM here: http://perlgeek.de/en/article/longest-token-matching

[09:02] <moritz_> (I guess I've given you that link before, sorry for spamming...)

[09:02] *** clintongormley joined
[09:03] <JimmyZ> rakudo: sub postfix:<++++>($a is copy) { ++++$a}; my $a = 2; $a++++.say;

[09:03] <p6eval> rakudo 1eef08: OUTPUT«4␤»

[09:03] <JimmyZ> rakudo: my $a = 2; $a++++.say;

[09:03] <p6eval> rakudo 1eef08: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[09:04] <moritz_> it should die like this in the first place

[09:04] <moritz_> because ++$a returns should return an immutable integer

[09:04] <moritz_> s/returns//

[09:05] <JimmyZ> that may be a bug

[09:06] <JimmyZ> rakudo: my $a = 2; $a++.++.say;

[09:06] <p6eval> rakudo 1eef08: OUTPUT«Could not find sub &postfix:<.>␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:06] <moritz_> rakudo: my $x =3; say ++++$x

[09:06] <p6eval> rakudo 1eef08: OUTPUT«5␤»

[09:06] <moritz_> that is the bug, yes

[09:07] <JimmyZ> I will submmit it.

[09:10] <moritz_> JimmyZ++ # putting on masak's hat

[09:12] <JimmyZ> :)

[09:12] <JimmyZ> ++++ is LTM, I think

[09:13] <moritz_> i't parsed as to prefix:<++>

[09:13] <moritz_> otherwise you wouldn't get 5 in the example above

[09:14] <JimmyZ> rakudo: sub postfix:<++++>($a is copy) { $a+=2 }; my $a = 2; $a++++.say; # I meant this one.

[09:14] <p6eval> rakudo 1eef08: OUTPUT«4␤»

[09:14] <JimmyZ> rakudo: sub prefix:<++++>($a is copy) { $a+=2 }; my $a = 2; ++++$a.say;

[09:14] <p6eval> rakudo 1eef08: OUTPUT«2␤»

[09:14] <kaare_> The new http://proto.perl6.org/ ++

[09:14] <JimmyZ> rakudo: sub prefix:<++++>($a is copy) { $a+=2 }; my $a = 2; (++++$a).say;

[09:14] <p6eval> rakudo 1eef08: OUTPUT«4␤»

[09:14] <moritz_> patrickas++

[09:15] <JimmyZ> rakudo: sub prefix:<++++>($a is copy) { $a+=2 }; my $a = 2; ++++$a.say; # Is it output rightly?

[09:15] <p6eval> rakudo 1eef08: OUTPUT«2␤»

[09:15] *** quester_ joined
[09:16] <JimmyZ> rakudo:  my $a = 2;++$a.say;

[09:16] <moritz_> yes

[09:16] <p6eval> rakudo 1eef08: OUTPUT«2␤Cannot assign to readonly value␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[09:16] <moritz_> that's correct too

[09:16] <JimmyZ> rakudo:  my $a = 2; (++$a).say;

[09:16] <p6eval> rakudo 1eef08: OUTPUT«3␤»

[09:16] <moritz_> and that too :-)

[09:17] <JimmyZ> rakudo:  my $a = 2; ++($a.say);

[09:17] <p6eval> rakudo 1eef08: OUTPUT«2␤Cannot assign to readonly value␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[09:17] <JimmyZ> rakudo: sub prefix:<++++>($a is copy) { $a+=2 }; my $a = 2; (++++($a.say)).say;

[09:17] <p6eval> rakudo 1eef08: OUTPUT«2␤3␤»

[09:17] <JimmyZ> rakudo: sub prefix:<++++>($a is copy) { $a+=2 }; my $a = 2; (($a.say)).say;

[09:17] <p6eval> rakudo 1eef08: OUTPUT«2␤1␤»

[09:18] <JimmyZ> I know , it should be 'is rw'

[09:21] *** felipe joined
[09:23] <JimmyZ> rakudo: sub prefix:<++++>($a is rw) { $a+=2 }; my $a = 2; (++++$a).say;

[09:23] <p6eval> rakudo 1eef08: OUTPUT«4␤»

[09:23] *** Intensity joined
[09:24] *** kst left
[09:27] *** kst joined
[09:44] *** zag left
[09:48] *** proller_ left
[09:51] *** quester_ left
[09:58] <sorear> > my $x = 12;

[09:58] <sorear> 12

[09:58] <sorear> > $x += 5

[09:58] <sorear> 17

[10:00] <moritz_> what does it print? .perl?

[10:00] <moritz_> or .Str?

[10:00] <sorear> &say()

[10:01] <moritz_> ok, that converts to Str

[10:01] *** agentzh left
[10:01] <moritz_> rakudo: class A {}; say A.new

[10:01] <p6eval> rakudo 1eef08: OUTPUT«A()<0x4183bd8>␤»

[10:01] <moritz_> you'd get a similar output for that, right?

[10:01] <sorear> lexical persistence and the P in REPL are on topic/lexical-persistence

[10:01] *** agentzh joined
[10:01] <sorear> > class A {}

[10:01] <sorear> !class_init_10

[10:01] <sorear> > A.new

[10:01] <sorear> A()<0xbbae568>

[10:02] <sorear> I wonder what !class_init_10 is

[10:04] *** agentzh left
[10:04] <JimmyZ> rakudo: class A { method Str() { 'Hi'}; }; say A.new

[10:04] <p6eval> rakudo 1eef08: OUTPUT«Hi␤»

[10:04] * sorear upgrades Parrot, rebases branches, then moves on to the next unclaimed **** item on ROADMAP

[10:06] <moritz_> sorear: should I add your name to "Perl 5 interop"?

[10:06] <sorear> oh, and I'm also going to implement masak's macro feature and look at his bug

[10:06] <sorear> moritz_: yes

[10:08] <moritz_> sorear: while you are at it... 

[10:08] <moritz_> 2 **    custom operators for circumfix:, postcircumfix: (B, pmichaud)

[10:08] <moritz_> seems pretty close to me to what you do, no?

[10:09] <sorear> moritz_: I can take a request

[10:09] * moritz_ issues a request

[10:10] <sorear> right now I'm just going for "hard fun ROADMAP items"

[10:10] <sorear> taken.

[10:10] <moritz_> sorear++

[10:11] <sorear> are we checking stuff off the roadmap?

[10:12] <moritz_> yes

[10:12] <sorear> hmm, I can comment on a few of these

[10:12] <moritz_> it's usually moved down to 'Completed ROADMAP items'

[10:12] <moritz_> sorear: did you already submit a perl foundation CLA?

[10:13] <sorear> not yet.

[10:13] <moritz_> sorear: please do, if you want a commit bit at some point

[10:15] <dalek> rakudo: 124895a | moritz++ | src/pmc/ (2 files):

[10:15] <dalek> rakudo: switch two PMCs to auto_attrs. Patch courtesy of Vasily Chekalkin

[10:15] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/124895afdc3056c72ef5cf309b0281063a8e4025

[10:15] <dalek> rakudo: 60c23d9 | moritz++ | docs/ROADMAP:

[10:15] <dalek> rakudo: [docs] update ROADMAP

[10:15] <dalek> rakudo: put sorear++ into two slots (p5 interop, macros)

[10:15] <dalek> rakudo: comment on progress of some items

[10:15] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/60c23d95b91177a85fc4775951654a124f807e21

[10:15] <moritz_> oh, I thought I had pushed bacek's patch yesterday

[10:20] * sorear also makes a note to work on operator overloading / scoping / precomp

[10:20] <sorear> making *that* work will involve adding slangs to our parser

[10:21] <sorear> which seems like the next big step towards STD

[10:23] * sorear spectests topic/lexical-persistence

[10:23] * sorear &

[10:24] *** iblechbot left
[10:24] *** viklund joined
[10:37] *** kst left
[10:39] *** kst joined
[10:40] *** mikehh left
[10:46] *** JimmyZ left
[10:55] *** muixirt joined
[10:56] <muixirt> proto did complain about missing 'projects.state' file in the first run

[10:57] <muixirt> ping moritz_ 

[10:59] <muixirt> proto did report that the json module build failed but installed it anyways.

[11:00] <muixirt> error message in log was: Illegal redeclaration of symbol 'JSON::Tiny'

[11:11] <moritz_> muixirt: pong

[11:11] <moritz_> muixirt: JSON::Tiny is known not to work with current rakudo

[11:11] <moritz_> muixirt: because it regeressed on much that's related to match objects

[11:12] <moritz_> so the data extraction from the parse tree fails horribly

[11:12] <muixirt> moritz_: ok, i thought this was fixed

[11:12] <moritz_> I'm working on it, but it's not easy

[11:16] *** yinyin left
[11:17] <moritz_> (and I'm doing way too many projects in parallel)

[11:18] *** _jaldhar joined
[11:19] <muixirt> why is 'zavolaj' not mentioned on the shiny new proto page?

[11:20] <moritz_> because nobody put it in projects.list

[11:20] <moritz_> adn that's where the proto page is generated from

[11:21] *** literal joined
[11:21] <muixirt> afk

[11:27] *** masak joined
[11:27] <masak> oh hai, #perl6

[11:27] <phenny> masak: 01:12Z <lue> tell masak ooh! That could come in handy ( esp. considering one of my theories involves codons :) )

[11:27] <masak> whose doesn't? :P

[11:28] *** ruoso left
[11:30] *** TiMBuS left
[11:31] <snarkyboojum> hai masak

[11:32] <masak> snarkyboojum: \o

[11:32] <snarkyboojum> o/

[11:40] <masak> snarkyboojum: this month for Yapsi, there are quite a few possible roads to take. they all involve blocks of different kinds. if statements, while loops, subroutines, BEGIN blocks, other phasers...

[11:41] *** kst left
[11:41] <snarkyboojum> masak: are you thinking control flow next?

[11:41] * moritz_ sings "the first phaser's the hardest" (with apologies to Cat Stevens

[11:41] <masak> :)

[11:42] <masak> snarkyboojum: yeah. control flow is probably the least involved of those.

[11:42] <masak> we need a few more opcodes, and a plan for how to do jumps.

[11:42] <snarkyboojum> masak: in that case let's go for the hardest :P

[11:42] <masak> nothing prevents us from investigating things in many branches :)

[11:42] <moritz_> I guess BEGIN is the hardest

[11:43] <masak> actually, BEGIN could be pretty easy. now that we have detachable environments.

[11:43] <masak> but I can't claim to understand the surrounding model quite yet.

[11:43] *** iblechbot joined
[11:44] <masak> for example, I found this in S04 on the train today:

[11:44] <masak> 'Some closures produce C<Block> objects at compile time that cannot be cloned, because they're not attached to any runtime code that can actually clone them.  C<BEGIN>, C<CHECK>, C<INIT>, and C<END> blocks fall into this category.  Therefore you can't reliably refer to run-time variables from these closures even if they appear to be in the scope.'

[11:44] *** kst joined
[11:44] <masak> I have no idea what it means, but it sounds bad. :(

[11:44] <moritz_> and it kinda sounds wrong-ish

[11:45] <masak> I'm glad you say that.

[11:45] <moritz_> I agree with the first part: you can't clone them in runtime code

[11:45] <moritz_> because they have been evaluated at that time already, and you don't have a reference to them

[11:45] <masak> *nod*

[11:46] <moritz_> but why does that mean you can't reliably refer to variables from them?

[11:46] <moritz_> I mean they don't present themselves as closures to the runtime code

[11:46] <masak> things like `my &b := BEGIN { say "LOL" }` are pretty meaningless.

[11:46] <moritz_> ok, I agree with that

[11:47] <moritz_> maybe even with  `my $c = BEGIN { my $x =3; -> $y { $x * $y } }`

[11:48] <moritz_> since BEGIN isn't visisble as a closure, that will likely fail

[11:48] <moritz_> but

[11:48] <moritz_> my $x; BEGIN { $x = 3 }  should work IMHO

[11:48] <masak> aye.

[11:48] <moritz_> maybe that's what the paragraph actually means to say

[11:48] <masak> let's hope so.

[11:49] <masak> rakudo: say Nil.defined

[11:49] <p6eval> rakudo 1eef08: OUTPUT«0␤»

[11:49] * masak submits rakudobug

[11:49] <masak> rakudo: say ().defined

[11:49] <p6eval> rakudo 1eef08: OUTPUT«0␤»

[11:49] <moritz_> "You can't transfer BEGIN closures to runtime"

[11:50] <takadonet> morning all

[11:50] <moritz_> muixirt: what's wrong with that?

[11:50] <moritz_> erm, I meant masak 

[11:51] <masak> moritz_: S02 states that Nil.defined is true.

[11:51] <moritz_> now that's weird

[11:51] <moritz_> my $x = { }.()

[11:51] <moritz_> then $x is defined? wtf?

[11:52] <masak> S02:2142

[11:52] <masak> moritz_: well, when you assign Nil to a scalar, you get that scalar's undefined type object, no?

[11:52] <masak> S02 says so too.

[11:52] <moritz_> ouch

[11:53] <masak> S02:2144 :)

[11:53] <moritz_> so assignment special-cases Nil

[11:53] <masak> aye.

[11:53] <masak> has been doing so for quite a while.

[11:53] <moritz_> rakudo: my $x = (); say $x.defined

[11:53] <p6eval> rakudo 1eef08: OUTPUT«1␤»

[11:53] <moritz_> rakudo: my $x = (); say $x.perl

[11:53] <p6eval> rakudo 1eef08: OUTPUT«()␤»

[11:54] <moritz_> rakudo: my $x = (); say $x.WHAT

[11:54] <p6eval> rakudo 1eef08: OUTPUT«Seq()␤»

[11:54] <masak> all those are wrong, I think.

[11:54] <moritz_> so how would you place an empty parcel into a scalar?

[11:54] *** Su-Shee joined
[11:54] <Su-Shee> heyho. 

[11:55] <moritz_> holla Su-Shee, que tal?

[11:55] <Su-Shee> in principle (besides nyi) - how difficult is it going to be to make DSLs in rakudo?

[11:56] <moritz_> easy

[11:56] *** felipe left
[11:56] <Su-Shee> nice. 

[11:56] <moritz_> for example quotes are basically a DSL

[11:57] <moritz_> defined in STD.pm in terms of delimiters, and which parts of the "normal" Perl 6 take part

[11:57] <moritz_> likewise regexes

[11:58] <Su-Shee> I was just reading through my blogs and all and realized that DSLs seriously take off (or I'm as usal the last one getting it ;) and that that's a serious limit of p5. (afaik at least..)

[11:58] <moritz_> well, p5 is a fairly mallable if you are clever

[11:59] <moritz_> but I'm not, I fear

[11:59] <Su-Shee> oh that level of clever? missed that already before birth. ;)

[11:59] <moritz_> I mean you can do things like

[11:59] <moritz_> sub foo { ... };   foo sub bar { ... }

[12:00] <moritz_> and then foo can do things with &bar

[12:00] <masak> that's not a DSL. that's just a sub. :)

[12:00] <moritz_> masak: well, providing an appropriate sub is already a DSL in some way

[12:00] <moritz_> it's a fairly crude one, but it's a start

[12:00] <masak> I belong to a staunch set of people who disagree with that it is a DSL.

[12:01] <masak> call a shovel a shovel, and a sub a sub.

[12:01] <moritz_> and perl 5.12 supports custom hooks for new keywords

[12:01] <masak> no need to bring out the fancy vocab for mundane things.

[12:01] <moritz_> masak: I remember that when quitefantastic++ used that trick, you were quiet amazed

[12:01] <masak> I was.

[12:01] <masak> I remember it too.

[12:01] <masak> that doesn't mean I think it was a DSL. :)

[12:01] *** bluescreen joined
[12:01] <Su-Shee> well it _seems_ like creating DSLs is much easier in Ruby and I'm trying to get to the bottom of it.

[12:02] <masak> many Ruby proponents seem to think that subs are DSLs.

[12:02] <moritz_> Su-Shee: please report what you find, when you do

[12:02] *** bluescreen is now known as Guest3356

[12:03] <Su-Shee> well I probably see it somewhat loosely - I would consider a DSL if you take PerlPythoNRubyJavaScriptRakudoFoobar and create a tiny language with its own syntax. which not necessarily looks like the language it is written in.

[12:06] <pmichaud> good morning #perl6

[12:07] <masak> pmichaud: \o

[12:08] <masak> Su-Shee: define 'take PerlPythoNRubyJavaScriptRakudoFoobar'. somehow I'm not satisfied when people are so exceedingly proud of the naming of their subroutines, and the fact that they are using very few parentheses, that they choose to call what they created 'a DSL' instead of (say) 'an API'.

[12:09] <masak> I remember Aristotle and chromatic writing about this in 2007: http://use.perl.org/~Aristotle/journal/34004 http://use.perl.org/~chromatic/journal/33898

[12:09] <takadonet> pmichaud: morning

[12:09] <masak> posts well worth reading.

[12:11] <moritz_> indeed :-)

[12:13] *** proller joined
[12:13] <masak> in short, I think the term 'DSL' should be reserved for things that actually are other languages, and just a restricted way of using your host language. this may be an uphill battle, but if it were lost, 'DSL' would be the proudest buzzword in town. and that would be too bad, because it can be a very useful concept.

[12:13] <moritz_> +1

[12:14] <moritz_> sorry for using the rubyish terminology in the first place

[12:14] <masak> sorry for ranting :)

[12:14] <moritz_> the rants on the blogs were actually quite amusing :-)

[12:14] <masak> yes :)

[12:15] *** lrnperl6 joined
[12:15] <lrnperl6> morning all

[12:15] * moritz_ reads http://trac.parrot.org/parrot/wiki/ParrotQuotes again and chuckles

[12:15] <masak> I have always loved the phrase "If I had to maintain his code I’d refactor that part out of existence I<with a quickness>!"

[12:15] <moritz_> lrnperl6: good morning

[12:15] <masak> lrnperl6: morning!

[12:16] <moritz_> lrnperl6: I hope you're not too disappointed to learn that somebody else was quicker with the script for proto

[12:16] <lrnperl6> I am :)

[12:16] <pmichaud> rants? blogs?  what did I miss?

[12:17] <moritz_> lrnperl6: then be comforted by 1) the fact that we now have http://proto.perl6.org/ and 2) that there will be another challenge next week

[12:17] <moritz_> pmichaud: that last 10 minutes, it seems

[12:18] <lrnperl6> that looks good

[12:18] <moritz_> aye; I'm quite amazed by the good collaboration that emerged

[12:19] <moritz_> patrickas contributed the script, I set up the sub domain, masak urged us to use dl/dd/dt, isBEKaml and patricks did the rest

[12:20] <moritz_> or somthing like that :-)

[12:20] <masak> it was astounding!

[12:20] <lrnperl6> you guys are too fast

[12:20] <_sri> masak: make sure to check out ruby cucumber, i don't like it but it shows how far ruby DSLs can go

[12:20] <masak> there'll be a new task next week :)

[12:20] <masak> _sri: I know about it.

[12:21] <masak> _sri: chromatic had this to say about it the other day: http://twitter.com/chromatic_x/status/13320560727

[12:22] <masak> _sri: don't know how accurate that criticism actually is; haven't actually tried cucumber.

[12:23] <lrnperl6> I have a question

[12:23] <masak> fire away.

[12:24] *** rv2733 joined
[12:26] <lrnperl6> for all (novel) features which perl6 will support, do we have applications/examples of those 

[12:26] <lrnperl6> or http://perlcabal.org/syn/ is all we have got

[12:26] <masak> it's funny you ask.

[12:26] <masak> because yesterday we made a page... :)

[12:26] <masak> http://proto.perl6.org/

[12:27] <moritz_> the projects actually use most of the implemented features

[12:27] <masak> there you'll find plenty of applications and examples.

[12:27] <masak> some of which even work!

[12:27] <masak> :)

[12:27] <moritz_> but there's no structured list of example for all features, sorted by synopsis or so

[12:28] <masak> there's the Advent Calendar.

[12:28] <masak> it probably best approximates such a list of features.

[12:28] <masak> u4x contains ample examples for all features, but has the drawback that it doesn't exist yet.

[12:29] *** proller left
[12:29] <lrnperl6> just an idea: can we have a attributes to each project(listed on proto) where it tells novice like me how it is benefited by perl6

[12:29] <masak> challenge for some intrepid Perl 6 module developer: an XML module that makes editing XML fun. :)

[12:30] <lrnperl6> maybe a separate page for each project

[12:31] <masak> lrnperl6: could you be more specific? an example, perhaps?

[12:31] <_sri> masak: call it declarative api instead of DSL if you like, but ruby can make complicated things look amazingly clean thanks to implicit invocants, optional braces and the magical block argument all methods accept

[12:31] <moritz_> lrnperl6: the page can certainly be extended; for example indicators whether a particular project has tests, a README, date of last activity...

[12:32] <moritz_> lrnperl6: I'd certainly consider such an extension as another successful submission :-)

[12:32] <lrnperl6> say a csv parser. page saying how easy it was to use perl6 for this. I am not saying that perl6 is best for all the application

[12:34] <_sri> masak: and here's a perfect example http://teachingkids.railsbridge.org/2009/08/15/teaching-ruby-to-high-school-girls.html

[12:35] <masak> _sri: yes. 'declarative API' is a good name.

[12:35] <_sri> (or moritz)

[12:35] <masak> and Shoes is very nice.

[12:35] * _sri nods

[12:36] *** SmokeMachine joined
[12:36] <lrnperl6> moritz_: but we have link to github where we have information regarding README, last activity etc

[12:37] <moritz_> lrnperl6: true

[12:39] *** kst left
[12:41] *** kst joined
[12:49] *** jonasbn left
[12:50] <masak> lrnperl6: I can tell you a bit about the CSV parser. I wrote most of that.

[12:50] <masak> lrnperl6: it was developed using TDD, first without a priori knowledge about other CSV parsers or standards, and later with some of that.

[12:50] <masak> I remember it as being a fun weekend of coding.

[12:51] <masak> Perl 6 is a good fit because it has grammars.

[12:51] <masak> it would have been a pain to do multiline parsing without that.

[12:54] * moritz_ has to attend a boring safety instruction

[12:55] <pmichaud> the thrilling safety instructions are sometimes less desirable.  :-)

[12:58] *** ruoso joined
[12:58] * masak is reminded of http://picturesforsadchildren.com/index.php?comicID=72

[13:01] <pmichaud> I'm told the Internet is beneficial to society... sometimes I'm not so sure about that.  :)

[13:04] <obra> pmichaud: sure it is. it keeps us crazy people away from society

[13:05] <PerlJam> obra: society is us.

[13:06] <obra> :)

[13:11] *** pmurias joined
[13:13] <lrnperl6> masak: exact description i was talking about :)

[13:15] <masak> lrnperl6: usually I put that in blog posts :)

[13:15] <masak> for this particular project, that wasn't meant to be, though.

[13:15] <lrnperl6> masak: then we can have link to blog posts on project page :)

[13:17] <masak> lrnperl6: that's an interesting idea.

[13:17] <masak> lrnperl6: I'd like to see a solution based on the repo, though. so the build script would pull some given file from the repo, expecting links to blog posts.

[13:20] <masak> I'll put together such a list for November, as an example.

[13:31] *** mikehh joined
[13:36] *** tylerni7 left
[13:36] *** BrowserUk joined
[13:37] *** kst left
[13:39] *** kst joined
[13:39] *** kaare_ left
[13:40] *** tylerni7 joined
[13:40] *** tylerni7 left
[13:40] *** tylerni7 joined
[13:40] *** plobsing joined
[13:44] <lrnperl6> wild(&bad) idea: a script to parse perl6 code to deduce what features it uses :)

[13:45] <masak> definitely possible.

[13:45] <masak> should probably base itself on viv.

[13:45] <lrnperl6> masak: now the trouble: what is viv. already searching for it :)

[13:45] <masak> I'll be doing some similar things in the next few weeks: code analysis, etc.

[13:45] <masak> lrnperl6: I'll get the URL for you.

[13:46] <masak> lrnperl6: http://svn.pugscode.org/pugs/src/perl6/

[13:46] <masak> in this directory, you will find STD.pm6, the standard Perl 6 grammar.

[13:46] <masak> using it, we can check whether our Perl 6 syntax is ok.

[13:46] <masak> std: "this is OK, OK?"

[13:46] <p6eval> std 30549: OUTPUT«ok 00:01 109m␤»

[13:47] <masak> std: NotOk.WHAT

[13:47] <p6eval> std 30549: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤ 'NotOk' used at line 1␤Check failed␤FAILED 00:01 107m␤»

[13:47] <masak> now, whereas the std target in p6eval only says 'ok' or 'not ok', the viv script in that directory will give you a whole parse tree.

[13:48] <masak> containing loads of lex and structure information.

[13:48] <lrnperl6> masak: so it's matter of querying viv for required information, right?

[13:48] <masak> yes.

[13:49] <masak> it's output in YAML, so you'll need something to read the YAML.

[13:49] <masak> that's still sorely lacking in Perl 6, so Perl 5 is probably the best option for now.

[13:49] <masak> then you can traverse the data structure, looking for features somehow.

[13:50] <lrnperl6> masak: so viv has information before eval?

[13:50] <PerlJam> one of my coworkers just asked how I feel about installing Rakudo on one of our servers   :)

[13:51] <masak> lrnperl6: please restat your question :)

[13:51] <masak> s/restat/restate/

[13:51] <masak> PerlJam: cool!

[13:51] <lrnperl6> masak: just found this "Unfortunately, 'viv' is not equipped to execute the code" at http://www.perlfoundation.org/perl6/index.cgi?viv

[13:52] <masak> lrnperl6: neither STD.pm6 nor viv executes code.

[13:52] *** proller joined
[13:54] *** PacoLinux joined
[13:55] <PerlJam> (whoever is packaging Rakudo in Fedora releases)++

[13:55] <lrnperl6> PerlJam: what is with "++"?

[13:56] <PerlJam> lrnperl6: karma

[13:56] <moritz_> incrementing karma

[13:56] <moritz_> buu: karma moritz_

[13:56] <moritz_> buubot: karma moritz_

[13:56] <buubot> moritz_: moritz_ has karma of 377     

[13:56] <moritz_> buu: sorry :-)

[13:56] <moritz_> buubot: karma moritz

[13:56] <buubot> moritz_: moritz has karma of 1208     

[13:56] <moritz_> buubot: karma lrnperl6 

[13:56] <buubot> moritz_: lrnperl6 has karma of      

[13:56] <moritz_> lrnperl6++

[13:56] <PerlJam> The reason my coworker asked about rakudo was because he noticed there's a Fedora package for it.

[13:56] <moritz_> buubot: karma lrnperl6 

[13:56] <buubot> moritz_: lrnperl6 has karma of      

[13:56] <lrnperl6> buubot: karma lrnperl6 

[13:56] <buubot> lrnperl6: lrnperl6 has karma of      

[13:56] <PerlJam> (and I've been talking about using it "for real" for a while now :)

[13:57] <lrnperl6> does that meanI Infinity :)

[13:57] <lrnperl6> s/meanI/mean/

[13:57] <moritz_> lrnperl6: 2x infinity, actually :-)

[13:58] <masak> buubot: karma TimToady 

[13:58] <buubot> masak: TimToady has karma of      

[13:58] <moritz_> lrnperl6: I think not all karma is currently tracked, due to some bug... but I have log files, and will a script that extracts the karma at some point

[13:58] <lrnperl6> infinity of infinity

[13:58] <PerlJam> aleph infinity

[13:59] <moritz_> "what's a cardinal higher than the pope? 2 to the pope"

[13:59] *** tedv joined
[14:00] <lrnperl6> wow. TimToady is L Wall

[14:00] <tedv> Welcome to 1997!

[14:00] <lrnperl6> (again) wow, tedv is tedv :)

[14:01] <tedv> indeed!

[14:01] <masak> how would you turn a file upside down with a Perl 6 one-liner?

[14:02] <arnsholt> masak: Turn it upside down?

[14:02] <moritz_> say for open('filename').lines.reverse

[14:02] <tedv> .say for open($file, :r).lines.reverse

[14:02] <tedv> omg I'm beaten

[14:02] * masak arrived at this: .say for reverse lines("the.file")

[14:02] <tedv> was SO close

[14:02] <moritz_> tedv++ # using .say correctly

[14:02] <moritz_> tedv: well, your answer was correct, mine wasn't :-)

[14:02] <masak> arnsholt: print the last line first and vice versa.

[14:02] <lrnperl6> tedv++

[14:03] <tedv> Anyway, so I've been thinking (again) about getting into perl6 stuff more

[14:03] <masak> good for you!

[14:03] <tedv> as I understand it, the general procedure for helping out looks like...

[14:03] <PerlJam> lines("file").reverse.say  doesn't work?

[14:03] <arnsholt> masak: Yeah, that's what I guessed, but I wasn't quite sure

[14:03] <tedv> write simple perl 6 stuff -> find bugs -> add unit tests -> fix source code

[14:03] <masak> PerlJam: you wouldn't get newlines.

[14:03] <moritz_> tedv: that's one way, yes

[14:04] <PerlJam> masak: they're automatically removed in the call to lines() ?

[14:04] <tedv> well I'm still learning syntax

[14:04] <masak> PerlJam: yes.

[14:04] <tedv> the more I use perl 6, the more it feels very much like perl, just not like perl 5

[14:04] * PerlJam clearly didn't remember that

[14:04] <masak> PerlJam: most input autochomps.

[14:04] <tedv> I think that's a good thing though

[14:04] *** leedo joined
[14:04] <moritz_> tedv: that's very much how I feel about Perl 6 too

[14:05] <pmurias> diakopter: hi

[14:05] <phenny> pmurias: 04 May 23:09Z <diakopter> tell pmurias hi

[14:05] *** leedo left
[14:05] <pmurias> :)

[14:05] <tedv> So would a reasonable short term goal be to add more unit tests to the pugs svn repository?

[14:05] <moritz_> yes

[14:06] <moritz_> tedv: do you have a commit bit already?

[14:06] <tedv> No, I don't

[14:06] <tedv> nor have I been briefed on general etiquit

[14:06] <tedv> etiquite?

[14:06] <moritz_> tedv: then tell (or /msg) me your email address, and I'll give you one

[14:06] <masak> 'be polite.'

[14:06] <tedv> anyway, how not to burn down the house

[14:07] <moritz_> tedv: it's a version control system; if you screw anything up, the worth thing that can happen is that we have to revert it

[14:07] <tedv> yeah but that costs people time

[14:07] <PerlJam> lines("filename" :!chomp).reverse.say  # just because I was forced to look at the docs  ;)

[14:07] <tedv> and if I'm costing other people time, I'm not really helping

[14:07] <tedv> TMTOWTDI!

[14:07] <moritz_> tedv: that's ok. Just don't make it on purpose

[14:07] <masak> PerlJam: :)

[14:07] <moritz_> tedv: in general we say forgiveness is better than permisson

[14:07] <tedv> Truth

[14:08] <moritz_> PerlJam: but then use .print, otherwise you get one extra newline

[14:08] <masak> PerlJam: I didn't know we had a flag there that defaults to true. that's usually a design smell.

[14:08] <PerlJam> moritz_: ah, you're right!

[14:08] <tedv> Does Rakudo's make spectest run the full suite (minus rakudo skip flagged tests)?

[14:08] <masak> no.

[14:08] <moritz_> tedv: not all, but quite many

[14:08] <PerlJam> moritz_: say is just so seductive :)

[14:08] <tedv> So what is the best way to make sure I'm adding legitimate test cases?

[14:08] <masak> lrnperl6: I made a list of the blog posts related to November: http://github.com/viklund/november/blob/master/docs/blog-posts.md

[14:09] <moritz_> tedv: and if you add new tests to files that rakudo passes, it's polite to check them with rakudo

[14:09] <masak> lrnperl6: perhaps other projects can also use that format, and we could link to the list from proto.perl6.org

[14:09] <moritz_> tedv: if rakudo doesn't pass them, but you think the test case is right, fudge them out

[14:09] <moritz_> tedv: in case of doubt, just ask

[14:09] <PerlJam> tedv: #perl6 does a good job of shepherding when needed.

[14:09] <tedv> alright.  I've seen past examples in the test files

[14:09] *** mberends joined
[14:09] <tedv> Is there a list of "unit tests that need to be written"?

[14:10] <moritz_> tedv: we're also very forgiving to newcomers; if you do something wrong, we'll tell you without yelling :-)

[14:10] <tedv> That Is The Perl Way

[14:10] <moritz_> tedv: t/spec/ contains a TODO file, let me check how up-to-date it is

[14:11] <lrnperl6> moritz_: we have information for each project listed on proto; like the one masak has for november

[14:11] <dalek> november: 6d57c89 | masak++ | docs/blog-posts.md:

[14:11] <dalek> november: [docs/blog-posts.md] links to all known posts

[14:11] <dalek> november: ...about November. Tried to find them all in my feed; might have missed seme.

[14:11] <dalek> november: Definitely missed some from other people. Feel free to supplement.

[14:11] <dalek> november: review: http://github.com/viklund/november/commit/6d57c895b86859b5c2c7305d21d3b6ad0dd6bde2

[14:11] <dalek> november: 4e56a14 | masak++ | docs/blog-posts.md:

[14:11] <dalek> november: [docs/blog-posts.md] fixed copy-paste-o

[14:11] <dalek> november: review: http://github.com/viklund/november/commit/4e56a149a03c010a31d279d4bba93bf3b9ca74fe

[14:11] <masak> huh. :)

[14:11] <mberends> \o from a vacation street-wifi! (may disconnect at any time)

[14:11] <masak> mberends! \o/

[14:12] <tedv> The last thing I noticed when playing around with rakudo was that some scripts seemed really slow.  Slower than could be pinned on the VM alone.

[14:12] <mberends> masak: I'm working offline on tools/test-summary.pl per-test benchmarking :)

[14:12] <moritz_> tedv: I'll need to go through the TODO file soon; but for example the one listed for S06 seems up-to-date, as well as S11

[14:12] <masak> mberends: sounds nice.

[14:12] <tedv> My best guess is that Rakudo has some serious inefficiencies in how it throws around lists

[14:13] <PerlJam> tedv: almost nothing is optimized.

[14:13] <tedv> I've seen a lot of comments saying Rakudo doesn't support lazy list evaluation

[14:13] <moritz_> it does now, to some extend

[14:13] <tedv> I wrote a block of code that was like...

[14:13] <moritz_> rakudo: (1..10).map({say "here"})

[14:13] <p6eval> rakudo 1eef08:  ( no output )

[14:13] <masak> mberends: lately, I've been toying with the idea of making a script to count the spectests.

[14:13] <moritz_> rakudo: (1..10).map({say "here"}).eager

[14:13] <tedv> for $input_file.lines { ... }

[14:13] <p6eval> rakudo 1eef08: OUTPUT«here␤here␤here␤here␤here␤here␤here␤here␤here␤here␤»

[14:13] <masak> mberends: on a per-file basis.

[14:13] <tedv> where the file was several megabytes long

[14:13] <tedv> and it never even got inside the block

[14:14] <moritz_> tedv: yes, 'for' isn't lazy yet

[14:14] <moritz_> tedv: it needs to be, but there's a problem with it...

[14:14] <tedv> what's the problem?

[14:14] <pugssvn> r30550 | pmurias++ | [mildew] added some deps to dist.ini and the mildew executable is 

[14:14] <pugssvn> r30550 | noticed by Dist::Zilla

[14:14] <moritz_> we don't recognize "void" context (called "sink" context in Perl 6)

[14:14] <mberends> masak: do you mean a sort of anti-A-cunning-no_plan?

[14:14] <moritz_> so for 1..3 { .say }   wouldn't print anything

[14:14] <moritz_> if for was mady lazy right now

[14:14] <moritz_> which would break just about all existing programs :-)

[14:15] <tedv> sink is something you put on the tail of a loop that evalutes code but still returns false, right?

[14:15] <tedv> When exactly does the sink execute?  If the last statement in the loop block is false?

[14:15] <masak> mberends: depends on the value of 'anti', I guess. but yeah, something to counteract the 'no plan' things.

[14:15] <moritz_> tedv: all expressions that aren't assigned or bound to something else are considered to be in "sink" context

[14:15] <masak> mberends: mostly because I'm interested in the actual exact number :)

[14:15] <moritz_> sub foo { a; b; c}

[14:15] <tedv> ah so it's not just a loop thing

[14:16] <masak> mberends: but also because I'd like to graph the spectests, and show implementations coverage.

[14:16] <moritz_> a and b are in sink context

[14:16] <moritz_> c isn't

[14:16] <mberends> masak: have you read the existing work on that problem in tools/test_summary.pl?

[14:16] <masak> no.

[14:16] * masak does that now

[14:16] <mberends> it outputs what the totals *should* be

[14:16] <tedv> so for loops are always in sink context.  What does this have to do with "sink { ... }"

[14:17] <moritz_> std: my @x = for 1..2 { }

[14:17] <p6eval> std 30549: OUTPUT«[31m===[0mSORRY![31m===[0m␤Word 'for' interpreted as a listop; please use 'do for' to introduce the statement control word at /tmp/ZpaeE4Dire line 1:␤------> [32mmy @x = [33m⏏[31mfor 1..2 { }[0m␤Unexpected block in infix position (two terms in a row) at /tmp/ZpaeE4Dire

[14:17] <p6eval> ..line…

[14:17] <masak> mberends: what does that mean?

[14:17] <moritz_> std: my @x = do for 1..2 { }

[14:17] <p6eval> std 30549: OUTPUT«ok 00:01 108m␤»

[14:17] <moritz_> tedv: not always sink context

[14:17] <moritz_> tedv: sink { ... } just puts the block in sink context

[14:17] <tedv> ahhh I got it

[14:18] <masak> mberends: it says 'Implementing 'no_plan' or 'plan *' in test scripts makes this total (sic) # inaccurate.'

[14:18] <tedv> std: @x = do for 1..2 { 5; 3; }; @x.say;

[14:18] <p6eval> std 30549: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable @x is not predeclared at /tmp/xj6BZ71QYb line 1:␤------> [32m@x[33m⏏[31m = do for 1..2 { 5; 3; }; @x.say;[0m␤Variable @x is not predeclared at /tmp/xj6BZ71QYb line 1:␤------> [32m@x = do for 1..2 { 5; 3; }; @x[33m⏏[31m.say;[0m␤Check

[14:18] <p6eval> ..f…

[14:18] <tedv> std: my @x = do for 1..2 { 5; 3; }; @x.say;

[14:18] <p6eval> std 30549: OUTPUT«ok 00:01 108m␤»

[14:18] <moritz_> tedv: std only checks syntax, doesn't execute code

[14:18] <tedv> curse you std! :[

[14:19] <moritz_> but it's smart about the syntax, to be sure :-)

[14:19] <tedv> but I assume @x should be bound to (3,3)?

[14:19] <masak> mberends: I'm thinking semi-ambitiously; something which went looking for 'is' and 'ok' things, and perhaps even knew a bit about for loops.

[14:19] <moritz_> tedv: yes

[14:19] <mberends> masak: tools/test_summary.pl counts the actual tests run, and if a test script begins with 'plan *;' it outputs a report saying what the actual number should be, in case someone feels like editing the test script.

[14:19] <lrnperl6> got to go

[14:19] <tedv> if I write: @x = for @foo { ... } sink { }

[14:20] <tedv> Then when does the sink execute?

[14:20] <masak> mberends: aha. but that requires the test file to be runnable by Rakudo, no?

[14:20] <moritz_> assuming you put a : after the first } ...

[14:20] <moritz_> after the loop

[14:20] <mberends> masak: yes, true

[14:20] <moritz_> but it doesn't do anything

[14:20] <moritz_> because the block is empty

[14:20] <tedv> I forgot the second ...

[14:20] <tedv> @x = for @foo { ... }: sink { ... }

[14:20] <moritz_> std: sink <foo bar>.map: { say "hi" }

[14:20] <masak> mberends: I was hoping to be Rakudo-independent. I could imagine leaning on viv.

[14:20] <p6eval> std 30549: OUTPUT«ok 00:01 108m␤»

[14:20] <tedv> so the sink would execute after the loop but before the @x assignment?

[14:20] *** kst left
[14:21] <mberends> masak: things like fudging and loops play havoc with static test counting

[14:21] <moritz_> tedv: no, it would be totally unrelated to the loop

[14:21] <moritz_> tedv: you have to say 'sink' *before* the thing you want to put in sink context

[14:21] <masak> mberends: fudging won't affect the number of actual tests.

[14:21] *** kst joined
[14:21] <masak> mberends: loops are a problem. I'd like to see how far I get :)

[14:22] <tedv> oh so the problem with for loops not understand sink context is if you want to write sink { for @x { ... } }

[14:22] <moritz_> no

[14:22] <mberends> masak: I agree with your sentiment though. 'plan *;' does not help our reporting...

[14:22] <tedv> heh okay I'm trying here

[14:22] <moritz_> the problem is that sink context mostly should be *automatic*

[14:22] <tedv> can you give me a block of code that shows how rakudo loops have trouble with sink context?

[14:22] <moritz_> rakudo: for <a b> { .say } 

[14:22] <p6eval> rakudo 1eef08: OUTPUT«a␤b␤»

[14:23] <masak> mberends: I never said that. :) but I guess you're right.

[14:23] <moritz_> tedv: imagine that 'for' was being executed lazily

[14:23] <moritz_> tedv: then what would happen?>

[14:23] <masak> nothing.

[14:23] <moritz_> right

[14:23] <moritz_> so

[14:24] <tedv> Still thinking through this

[14:24] <moritz_> we need a mechanism to make sure that 'for' is in sink context *unless put into another context*

[14:24] *** plobsing left
[14:24] <moritz_> so that a bare 'for ...' is in sink context

[14:24] <moritz_> but a '@x = do for ...' is not

[14:24] <PerlJam> moritz_: you didn't get a lot of feedback on your proposal on p6c did you?  :)

[14:24] <tedv> by "nothing" you mean nothing would get printed?

[14:25] <moritz_> tedv: right

[14:25] <masak> lue++ # http://rdstar.wordpress.com/

[14:25] *** viklund left
[14:25] <tedv> I think I don't understand lazy evaluation then

[14:25] <tedv> lazy means "don't get the value until you need them"

[14:25] <moritz_> PerlJam: I got feedback from most of the "important" people on IRC

[14:25] <tedv> oh I get it

[14:25] <tedv> because the sink context doesn't need any values out of the for loop

[14:25] <moritz_> right - you never need them

[14:25] <tedv> it doesn't evaluate the block

[14:25] <moritz_> well, sink context enforces eager evaluation

[14:26] <moritz_> but we don't have sink context yet

[14:26] <tedv> So for loops are supposed to default to sink context so that they work the way people think they should intuitively

[14:26] <tedv> ?

[14:26] <mberends> masak: I do intend to edit 'plan *;' back to 'plan \d+;' where appropriate, meaning where the number is tests in the script shows little likelihood of changing.

[14:27] <moritz_> tedv: *all* statements are supposed to default to sink context, unless the value is captured somehow

[14:27] <moritz_> by an assignment, or by being the return value of a block

[14:27] <moritz_> and 'for' is one of them

[14:27] <tedv> and lazy evaluation will only trigger when the value is captured

[14:27] <masak> mberends: it's not always \d+, though.

[14:27] <tedv> which, I suppose is the whole point of lazy eval

[14:27] <masak> mberends: sometimes it's +@tests

[14:27] <masak> or +@tests * 3

[14:28] <mberends> masak: I'd better leave those alone then ;-)

[14:28] <moritz_> *sigh* not quite

[14:28] <tedv> maybe I should hold off on writing unit tests for a while and get more familiar with the language

[14:28] <masak> mberends: I mean, sometimes it makes more sense to change from * to such an expression that to \d+

[14:28] <moritz_> tedv: it's a complicated piece of the language

[14:28] <moritz_> my $x = <foo bar>.map({ ... })

[14:28] <tedv> thats fine, I'm not giving up

[14:29] <moritz_> does not execute the block of the map

[14:29] <moritz_> but it stored the lazy list in $x

[14:29] <moritz_> so

[14:29] <moritz_> if you iterate over $x, the block gets executed

[14:29] <mberends> masak: would such a change help you in your endeavours too?

[14:29] <moritz_> that's the "normal" laziness you might know from haskell

[14:29] <moritz_> but if you write

[14:29] <moritz_> <foo bar>.map({ ... })

[14:30] <moritz_> there's no reason for that statement at all

[14:30] <moritz_> because nothing happens

[14:30] <tedv> even if the ... has side effects?

[14:30] <moritz_> if the return value is lazy

[14:30] <moritz_> so we assume that the ... has side effects, and the author really wand the ... to be executed

[14:30] <moritz_> *wanted

[14:31] <moritz_> and that's what sink context is for

[14:31] <moritz_> it causes throw-away values to behave like eager lists

[14:31] <tedv> lets say you write: my $x = <a b c d e>.map({ ... }); my $y = $x[4]

[14:32] <tedv> Will that evaluate the whole list or just the map at the last value?

[14:32] <masak> mberends: assuming the plans are correct, sure. it's easier to count elements of an array than to parse a whole file for an open set of sub calls. :)

[14:32] <tedv> ack, I have a meeting; back later

[14:32] <moritz_> tedv: it will evaluate the block until there are 5 items in the return list

[14:32] <moritz_> tedv: a block can return more than one item, or none at all

[14:33] <[particle]> or one.

[14:33] <PerlJam> moritz_: a minor thing, but it will evaluate until there are *at least* 5 items in the list

[14:33] <moritz_> yes; but that's boring :-)

[14:33] <masak> mberends: here's the zoology of the non-digit plans in t/spec: http://gist.github.com/390842

[14:33] <[particle]> :)

[14:34] <mberends> masak: oh wow! It will be interesting to see what develops. I hope to complete the test_summary.pl in the next 2-3 days. Give the current one a try in the meantime.

[14:35] <masak> mberends: so, for the formulaic variants, all the cases seem to be covered by A + @array * B + @otherarray * C :)

[14:35] <PerlJam> moritz_: I mean, the first evaluation may generate 20 things and I don't think perl is going to "look deeper" into the execution path to make sure it only gets 5.

[14:35] <masak> mberends: I will. thanks.

[14:35] <moritz_> PerlJam: yes, you're right

[14:35] <moritz_> I just try to hide some details in the first explanation :-)

[14:37] <Su-Shee> (I was talking - before I was sucked into the meeting vortex - exactly about the cleansiness _sri mentioned..)

[14:37] * mberends disconnects with browser tabs full of lovely irclogs :)

[14:37] *** mberends left
[14:38] <moritz_> mberends: want an sql dump? :-) oh too late...

[14:38] *** rgrau_ joined
[14:39] <moritz_> masak: I find it funny that you use 'grep -v' once, and perl 'ne 'print unless /$regex/' in the same one-liner :-)

[14:40] <masak> moritz_: trial and error. :) I couldn't make grep -v do what I wanted the second time.

[14:40] <moritz_> masak: you probably need -E for \d+

[14:40] *** lrnperl6 left
[14:41] <moritz_> for "extended" regexes

[14:41] <masak> ah.

[14:41] <masak> makes sense.

[14:41] <moritz_> more or less :-)

[14:41] <moritz_> and I like the output if you add a -c to the final uniq call

[14:41] *** clintongormley left
[14:41] *** elmex left
[14:41] *** jotr left
[14:41] *** japhb left
[14:42] *** SmokeMachine left
[14:42] <[Coke]> (grep -E) : see also "ack"

[14:42] *** elmex joined
[14:42] <[Coke]> ... especially if you're using avoiding .svn dirs.

[14:43] <moritz_> aye, ack++

[14:43] <alester> masak: ack will change your life.

[14:45] *** molaf joined
[14:45] *** uniejo left
[14:46] <masak> alester: ack figured in my trial-and-error :)

[14:46] <moritz_> alester: any chance getting some perlbuzz coverage for http://perlgeek.de/blog-en/perl-6/contribute-now-announce.html when the second challenge comes out next week?

[14:46] <masak> it could probably have done what I wanted, but I reached for the more familiar tool when I got a lot of color-coded lines I didn't want.

[14:48] <alester> moritz_: What's the angle?

[14:48] <moritz_> angle?

[14:48] <[Coke]> ack -h '^plan\s' t/spec | ack -v '^plan \d+;' | sort -u

[14:49] <moritz_> something like "start contributiong with low startup costs" or so

[14:49] <PerlJam> moritz_: I  think alester is asking where's the "buzz" that makes it perlbuzz-worthy

[14:49] <alester> Why is it interesting to readers?  What would I say about it?

[14:49] <[Coke]> ... and you could probably combine those 2 regular expressions since it's just perl.

[14:49] <tedv> what's the quickest perl6 way to convert an array of values into a hash table mapping those values to true?

[14:49] *** clintongormley joined
[14:49] *** jotr joined
[14:49] *** japhb joined
[14:50] <moritz_> alester: it allows people to contribute without learning "scary" things

[14:50] <alester> http://perlbuzz.com/how-to-contribute.html 

[14:50] <tedv> %x = @a.map({ ($_ => 1) }); # Best I could come up with?

[14:50] <alester> I don't understand what it is that the article is saying.

[14:50] <moritz_> %x{@a} = True xx @a

[14:50] <PerlJam> tedv: my %hash = @array Z>> 1;  # not sure about that

[14:51] <moritz_> that's bad :(

[14:51] <tedv> why wouldn't it be "@a xx True"?

[14:51] <moritz_> I want people to help who think that Perl 6 development is scary, because you have to write complex compilers

[14:51] <moritz_> I want them to help us, that is

[14:52] <PerlJam> tedv: because it's "True 5 times"  not "5 True times"  (for instance)

[14:52] <moritz_> and I want to show them that you don't need to know the dragon book to get involved

[14:52] <moritz_> and I want to offer guidance, and incentive

[14:52] <tedv> well I'd like to help, including writing complex compiler stuff, but I have to start at the beginning

[14:52] <alester> moritz_: I'd be glad to help you get that point across.

[14:52] <alester> But it's not clear at all from the article.

[14:52] <masak> [Coke]: ah, -h was what I was missing. when I found it in grep, I had already switched away from ack. :/

[14:53] <alester> It sounds like you're having a contest, but then it sounds like you're asking for something to put in Rakudo.

[14:53] <masak> [Coke]: also, I'll try to remember 'sort -u' till next time :)

[14:53] <moritz_> I want to make it like a contest, too

[14:53] <diakopter> pmurias: hi

[14:53] <moritz_> well, I might need to work on the announcement a bit

[14:53] <moritz_> alester: thanks for your input so far

[14:53] <PerlJam> tedv: oh, I was suffering perl5think a second ago ...   my %hash = @array Z 1..*;

[14:54] <tedv> There is a bit of a catch 22 problem.  People need to learn new syntax to help out, but they need to help out to implement things that parse new syntax.

[14:54] <PerlJam> (I suffer perl5 think alot because I'm often writing perl 5 code :)

[14:54] <moritz_> PerlJam: Z True xx *  maybe

[14:54] <tedv> So 1..* is an infinitely long list of 1s

[14:54] <Juerd> I don't write much code at all anymore, but whenever I try, I mix up Perl 5, Perl 6 and Javascript.

[14:54] <moritz_> no

[14:54] <moritz_> it's one to infinity

[14:54] <alester> moritz_: I did put it in the @perlbuzz Twitter feed yesterday.

[14:55] <PerlJam> tedv: it's an ever-increasing sequence.  1,2,3...

[14:55] <tedv> then won't that code map @array[0] to 1, @array[1] to 2, and so on?

[14:55] <alester> but if this is a big ongoing thing, I'd be glad to put up an article, if there was a clear call to action for people.

[14:55] <Juerd> Fortunately Javascript's okay with $ as the first character of a variable name. But eventually I type @ and things break.

[14:55] <tedv> the Z operator does a 1-to-1 match between those two arrays, right?

[14:55] <PerlJam> tedv: those are all "true values"  :-)

[14:55] <moritz_> alester: I plan to keep a weekly schedule, for at least 6 weeks or so, likely a bit longer

[14:55] <tedv> meh okay point taken

[14:56] <moritz_> alester: so I'd like a bigger announcement to coincide with the second week

[14:56] <tedv> how would you write an array that's an infinitely long list of trues?

[14:56] <masak> PerlJam: no, it's the *interval* 1 to whatever.

[14:56] <masak> PerlJam: you're thinking of 1...*

[14:56] <moritz_> tedv: True xx *

[14:56] <Juerd> tedv: True xx Inf

[14:56] <Juerd> *? Oh.

[14:56] <moritz_> xx Inf works too

[14:56] <alester> moritz_: Let me know how I can help.

[14:56] <tedv> so: my %hash = @array Z (True xx *)

[14:56] <tedv> is the most explicitly correct way of writing it

[14:57] <PerlJam> tedv: assuming that works

[14:57] <tedv> well it's defined as correct in the language specs, is what I'm asserting.  Whether it's currently implemented is a different question

[14:57] <PerlJam> aye

[14:58] <Juerd> @array »=> True

[14:58] <moritz_> std: <a b c> >>=><< True

[14:58] <p6eval> std 30550: OUTPUT«ok 00:01 110m␤»

[14:59] <PerlJam> rakudo: my @array = "a".."z";  my %hash = @array >>=><< True; %hash.say

[14:59] <tedv> So the result of ($item xx $int) is an array consisting of $int copies of $item.

[14:59] <p6eval> rakudo 1eef08: OUTPUT«Sorry, right side is too short and not dwimmy.␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[14:59] <tedv> (Still learning syntax)

[14:59] <PerlJam> Hmm

[14:59] <moritz_> oh, needs <<=>>>

[14:59] <masak> >>=>>>

[15:00] <PerlJam> right ... watch the direction of the pointy ends

[15:00] <Juerd> OMG :)

[15:00] <tedv> I have some vague memory that >>operator<< does weird operations on arrays on either side

[15:00] <Juerd> >>=>>> is ugly and beautiful at the same time.

[15:00] <tedv> yeah

[15:00] <PerlJam> It looks kind of like a fish

[15:00] <tedv> are you allowed to space it out a bit: >> => >>

[15:01] <tedv> for readability?

[15:01] <moritz_> tedv: @a >>+<< @b just adds the elements piece-wise, and they have to have same length

[15:01] <PerlJam> tedv: that would make it mean something different

[15:01] <moritz_> tedv: no, but you're allowed to use unicode form of >>

[15:01] <moritz_> »=>»

[15:01] <tedv> yeah

[15:01] <moritz_> whitespace in operators are generally forbidden

[15:02] <PerlJam> It's too bad you can't stick and unspace in the middle of your operators.   that would allow for some nice obfuscation  ;)

[15:02] <PerlJam> s/and/an/

[15:02] * moritz_ has to leave now, bbl

[15:02] <tedv> so >>oper<< operates on two arrays and applies the operation to both sides.  That sounds related to the Z operator.  Like Z is >>,<<

[15:02] <tedv> what about >>oper>>

[15:03] <snarkyboojum> is the code responsible for generating http://proto.perl6.org/ updated periodically from the github repo?

[15:04] *** kst left
[15:04] *** kst joined
[15:04] <[Coke]> tedv; FYI, SYN03 has all the operators.

[15:05] <PerlJam> rakudo: my @a = 5 xx 10; my @b = @a >>,>> 3;   @b.say

[15:05] <p6eval> rakudo 1eef08: OUTPUT«53535353535353535353␤»

[15:06] <tedv> Ah so >>oper>> iterates through the left side and applies the operator with the single value on the right side

[15:06] *** isBEKaml joined
[15:06] <tedv> rakudo: say 5 <<+>>3

[15:06] <p6eval> rakudo 1eef08: OUTPUT«8␤»

[15:07] <tedv> rakudo: say( (1,2) <<+>> (3,4)  )

[15:07] <p6eval> rakudo 1eef08: OUTPUT«46␤»

[15:07] *** nihiliad joined
[15:07] <tedv> rakudo: say( (1,2) >>+<< (3,4)  )

[15:07] <p6eval> rakudo 1eef08: OUTPUT«46␤»

[15:07] <tedv> mmm but those are different

[15:07] *** felipe joined
[15:07] <tedv> I think that >>+<< is iterating through the values, then creating a new list

[15:07] <tedv> while <<+>> is just doing + on the two lists?

[15:08] <tedv> say( (1,2) + (3,4) )

[15:08] <tedv> rakudo: say( (1,2) + (3,4) )

[15:08] <p6eval> rakudo 1eef08: OUTPUT«4␤»

[15:08] <tedv> hmmm I'll figure it out

[15:09] <PerlJam> tedv: the pointy end allows for a scalar that is replicated as many times as the fat end needs.

[15:09] <tedv> so what makes >>+<< different from +?

[15:09] <tedv> since both seem to say "we only need one copy of ourselves"?

[15:10] <PerlJam> tedv: the former is vector-y, the latter is scalar-y 

[15:11] <tedv> ah I see

[15:11] <tedv> so it just casts the lists into scalar context and does 2+2

[15:11] <masak> could this be the first ever Perl 6 job ad? http://www.carriere-info.fr/offre-emploi-perl-88929.html?_c51

[15:11] <masak> is it serious? it looks serious.

[15:11] *** SmokeMachine joined
[15:12] <PerlJam> tedv: see S03:3964  (Hyper operators)

[15:12] <isBEKaml> yo masak!

[15:12] <masak> isBEKaml: y0

[15:12] <PerlJam> masak: I'm going to go with "serious but they really don't know what they're asking for"

[15:13] <[Coke]> what are the odds it's a manager who doesn't understand the diff between 5 & 6?

[15:13] <[Coke]> .. what PJ said.

[15:13] <diakopter> http://www.editions-eni.fr/Livres/Perl-5-/.4_3a6222cf-b921-41f5-886c-c989f77ba994_2fa97b12-0f92-4eee-ad85-6aa4e2d6e9c3_1_0_d9bd8b5e-f324-473f-b1fc-b41b421c950f.html

[15:13] <isBEKaml> masak: uhh, I know no french, but they want perl6 guys to update some reference book?

[15:13] <isBEKaml> going by what google translate threw at me... 

[15:13] <masak> same here.

[15:13] <diakopter> since that's the only editions-eni publication having to do with Perl, I'm guessing that's what they want updated.

[15:14] <PerlJam> Perhaps they really do want a section on "what's new in Perl 6" or something

[15:14] * PerlJam doubts though

[15:14] <[Coke]> someone who's an author on the p6book should give 'em a ring.

[15:15] * masak sends them an email

[15:15] <diakopter> I don't know.  their book is 311 pages

[15:15] <snarkyboojum> that's a yes to my question above it seems :)

[15:16] <masak> snarkyboojum: yesterday it wasn't.

[15:16] <snarkyboojum> masak: oh ok - seems automated now

[15:16] <masak> snarkyboojum: moritz_ might have written that cron job in the meantime.

[15:17] <snarkyboojum> sweet

[15:17] <arnsholt> The ad is a bit short on info

[15:18] <arnsholt> All it says is that they want an IT professional, who is a Perl 6 expert to update a reference book

[15:18] <diakopter> arnsholt: see the link I pasted above

[15:18] <arnsholt> Yeah, it looks relevant

[15:19] <[Coke]> .wub 9

[15:20] <arnsholt> If you download the TOC, there's an appendix entitled "The future: Perl 6"

[15:20] <masak> oh, so maybe they do need help.

[15:20] <masak> I'm halfway through writing my email to them.

[15:20] <arnsholt> May very well be

[15:20] <isBEKaml> wow, they want guys to *write* the future! bbbut, the future is here! :)

[15:20] <arnsholt> Do we have any French or Francophone people?

[15:21] <arnsholt> (Apart from me =)

[15:21] <masak> cognominal.

[15:22] <arnsholt> Ah yes. Going by his name he's even proper French =)

[15:23] <pmurias> diakopter: you you check out what it takes to build mildew on your box? 

[15:23] <pmurias> dzil build in p6/v6/Mildew should create the tar ball

[15:24] <masak> this is the email I ended up with. http://gist.github.com/390917

[15:24] <masak> if I hear no suggestions for changes within the next minute or so, I'll send it off. :)

[15:25] <diakopter> moritz_: I noticed in parrotsketch yesterday nobody addressed your mention of rakudo's issues with current parrot: http://irclog.perlgeek.de/parrotsketch/2010-05-04#i_2292538

[15:25] <diakopter> pmurias: no I haven't tried.

[15:25] <diakopter> pmurias: I have no idea whether dzil is supposed to work on windows.

[15:26] * masak pushes 'send'

[15:26] <pmurias> dzil is installed by Dist::Zilla

[15:27] <pmurias> cpanm Dist::Zilla should install it

[15:28] <arnsholt> masak: The email looks good to me

[15:28] <masak> phew.

[15:29] <masak> errands &

[15:29] <isBEKaml> masak: The email looks fine to me too, even as I am unsure whether they were really looking for perl6.. :)

[15:29] * pmurias has never seen some mention "PERL 6" before

[15:30] <isBEKaml> pmurias: that's what got me.. :)

[15:31] *** SmokeMachine left
[15:31] <diakopter> pmurias:  the last one that seems to work on windows is  Dist-Zilla 1.100711

[15:32] <pmurias> diakopter: did you get a failure installing the current one?

[15:32] <diakopter> I haven't tried.  I don't even have a perl installed on this machine.

[15:32] <pmurias> oh

[15:32] <diakopter> "this machine" being the one I'm sitting at

[15:33] <pmurias> it's a $work one?

[15:33] <diakopter> I could try it on the p6eval box.

[15:33] <pmurias> we could have a mildew-perlesque evalbot target

[15:33] <diakopter> oh; I didn't know it was ready for that

[15:33] <diakopter> :)

[15:34] <pmurias> runs hello world seems to be enough for evalbot readiness

[15:35] *** justatheory joined
[15:37] <pmurias> food&

[15:37] <diakopter> pmurias: I really want to get perlesque running persistently

[15:38] <pmurias> mildew should also run persistently

[15:38] *** ruoso left
[15:40] <pmurias> diakopter: i could try to make perlesque run persistently but i need to eat something first

[15:40] <diakopter> I'm certain perlesque is no less than 98% threadsafe, by lines of code

[15:40] <moritz_> that's an interesting way to count :-)

[15:41] <alester> hey moritz_ !  Success!

[15:41] <diakopter> the only things that use static fields for anything meaningful are the compiler classes, and those would be easy to change.  Also, there are some caching objects that should be converted from fields to static

[15:41] <moritz_> alester: with what?

[15:41] <isBEKaml> moritz_: hi! 

[15:42] <alester> see mail to perl6-compiler.  You got a contribution.

[15:42] <moritz_> alester: aye; it arrived via IRC yesterday night (in my timezone)

[15:42] <moritz_> isBEKaml: hi

[15:43] <diakopter> really though, being threadsafe isn't an issue since p6eval queues the requests anyway (I think)

[15:44] <moritz_> should MyGrammar.parse($str) set $/?

[15:44] <moritz_> diakopter: that's correct

[15:44] *** jonrafkind joined
[15:44] <moritz_> it is in fact partially using blocking IO

[15:46] <diakopter> jonrafkind: hi

[15:46] <jonrafkind> sup

[15:48] <isBEKaml> looking at this month's posts on p6c mailing list, masak's got the greatest number of bugs submitted. Prolific bug hunter! 

[15:49] *** ruoso joined
[15:49] <moritz_> profilic coder too :-)

[15:49] <isBEKaml> masak++

[15:49] <isBEKaml> :)

[15:51] *** kst left
[15:53] <arnsholt> Not to mention prolific blogger =)

[15:53] *** SmokeMachine joined
[15:56] *** kst joined
[15:56] *** thowe left
[15:58] *** SmokeMachine left
[16:05] *** pmurias left
[16:09] *** clintongormley left
[16:12] *** ruoso left
[16:14] *** cdarroch joined
[16:14] *** cdarroch left
[16:14] *** cdarroch joined
[16:19] *** ruoso joined
[16:20] *** molaf left
[16:20] *** ntaylor joined
[16:29] *** dual_ left
[16:33] *** [mark] left
[16:34] <m6locks> hmm whats going on, I've been able to use LWP before: Can't locate object method "show_progress" via package "LWP::UserAgent" at ./proto line 115.     

[16:35] <moritz_> m6locks: with master or with alpha?

[16:35] <m6locks> thats master yes

[16:35] *** dual joined
[16:35] <moritz_> might be a protobug - not sure

[16:36] <m6locks> i was actually aiming for proto to build me a new copy of rakudo

[16:38] *** patspam joined
[16:38] <m6locks> thought i'd give it a shot, it seems to have taken quantum leaps in development

[16:39] <masak> isBEKaml, moritz_, arnsholt: thanks :)

[16:41] <masak> something about the beginning of the Google Translate translation of the job ad pleases me :)

[16:41] <masak> "Hello\n\nYou are the Professional computer expert on Perl 6."

[16:41] *** kst left
[16:41] <masak> it reads like something from spamusement.com :)

[16:42] *** kst joined
[16:43] *** iblechbot left
[16:45] *** meppl left
[16:46] <isBEKaml> masak: I haven't seen too many ppl writing PERL even for p5, but this amuses me to see PERL 6 and computer expert terms thrown in.. 

[16:46] <isBEKaml> not even in job ads.. 

[16:48] <masak> well, PERL 6 ought to be the subset of Perl 6 involving only the identifiers with all-caps letters.

[16:48] <masak> takes some real ingenuity to do stuff in PERL 6.

[16:49] <masak> BEGIN { .WHAT }

[16:49] <Su-Shee> so, essentially COBOL?

[16:49] <isBEKaml> END { .WHERE } 

[16:49] <isBEKaml> ??

[16:49] <isBEKaml> =)

[16:49] <pugssvn> r30551 | lwall++ | [S05] give overview of Perl patterns in terms of PEGs, and spec tiebreaking explicitly 

[16:49] <pugssvn> r30551 | [Basics.pod] remove fossil 'proto object'

[16:49] *** patspam left
[16:50] <masak> TimToady: typo? 'packing order'

[16:51] <pugssvn> r30552 | lwall++ | [S05] typo from masak++ 

[16:52] <masak> TimToady: also, I don't grok 5)

[16:52] <TimToady> * STD does not yet implement either 3 or 5

[16:52] <TimToady> you can have two rules from different files that land in the same grammar/class

[16:52] <TimToady> but only with monkey patching

[16:53] <masak> what's a 'use'?

[16:53] <TimToady> they might tie under all the earlier rules

[16:53] <TimToady> use/need declaration

[16:53] <masak> ah.

[16:53] <TimToady> use Other::Grammar;

[16:54] <masak> so a mere count of number of 'use' declarations in the compilation unit?

[16:54] <TimToady> how many uses it took to get there, usually 1

[16:54] <masak> oh!

[16:54] <masak> something like 'degrees apart'

[16:54] <TimToady> so if Other::Grammar uses Other::Other::Grammar, that's 2 away

[16:55] <masak> I understand now, but I maintain that this was not evident from the current wording.

[16:55] <TimToady> we'll take OG's foo in preference to OOG's foo

[16:55] <TimToady> well, the fact that there's a message is most of the message

[16:55] <TimToady> :)

[16:56] <TimToady> I'll have to figure out in STD how to calculate 3 and 5

[16:57] <TimToady> easy enough to track derivation levels in grammars numerically, I suppose

[16:57] <masak> TimToady: did you see my question about S02:4013?

[16:57] <TimToady> but #5 requires a link from each rule back to its file descriptor, I guess

[16:58] <TimToady> well, probably already has that somewhere

[16:58] *** snarkyboojum left
[16:58] <TimToady> haven't finished backlogging, actually

[16:58] <masak> ok.

[16:58] <masak> no hurry/worry/scurry :)

[16:59] <masak> just seems to be a stray 1 on that line.

[17:00] *** envi^home left
[17:00] <pugssvn> r30553 | lwall++ | [S02] add missing 1 found (er) by masak++ 

[17:00] <masak> :)

[17:01] <masak> TimToady++

[17:03] <TimToady> so basically, STD currently does #1, #2 and #4, but rakudo really only does #2

[17:05] <TimToady> and maybe #4, dunno

[17:07] *** stephenlb joined
[17:08] <tedv> So just broad strokes here...  What major features are missing from rakudo that prevents it from passing the whole test suite?

[17:08] *** patspam joined
[17:09] <moritz_> tedv: hundreds of corner cases, proper lazy lists, macros, some built-ins, regex features, parsing limitations (for example adverbs on quotes and modifiers), proper longest-token matching

[17:10] <moritz_> proper named enums

[17:10] <moritz_> binary data support

[17:10] <masak> tedv: I just ran tools/test_summary.pl -- if you're interested in specifics, you can run it too and see which tests are fudged and for what reasons.

[17:10] <moritz_> array and hash autovivification

[17:10] <moritz_> bigints

[17:10] <moritz_> native types

[17:11] <masak> S09.

[17:11] <moritz_> compact structures, ... right, S09

[17:11] <masak> Perl 5.

[17:11] <pugssvn> r30554 | lwall++ | [S06] fossil, my/our anonymous subs were superseded by 'anon' some time ago 

[17:11] <moritz_> Perl 6 :-)

[17:11] <moritz_> *SCNR*

[17:11] <masak> rakudo: say "Perl 5"++

[17:11] <p6eval> rakudo 1eef08: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[17:11] <tedv> Hmmm

[17:12] <moritz_> proper stack traces

[17:12] <tedv> Yeah that does explain perl 5!

[17:12] <masak> rakudo: my $perl = 'Perl 5'; $perl++; say $perl

[17:12] <p6eval> rakudo 1eef08: OUTPUT«Perl 6␤»

[17:12] <masak> \o/

[17:12] <moritz_> rakudo: say 'Perl 5'.succ # even clearer :-)

[17:12] <p6eval> rakudo 1eef08: OUTPUT«Perl 6␤»

[17:12] <isBEKaml> moritz_: SCNR? 

[17:12] <tedv> I should read up on autovivification

[17:13] <tedv> since I keep hearing the term, learning it, and then forgetting it again

[17:13] <moritz_> isBEKaml: "sorry, could not resist"

[17:13] <tedv> my mental note says "this is a technical term for something you already understand"

[17:13] <moritz_> my mental note says "this is a technical term for something you already understand, but can't spell"

[17:13] <moritz_> :-)

[17:14] <[Coke]> moritz_: are you saying that Perl 5 succs?

[17:14] <tedv> I think I spelt it right

[17:14] <ash_> which phasers are implemented? 

[17:14] <moritz_> ash_: BEGIN and END I think

[17:14] <moritz_> [Coke]: now that's your interpretation :-)

[17:14] <masak> rakudo: CHECK {}

[17:14] <p6eval> rakudo 1eef08:  ( no output )

[17:14] <isBEKaml> moritz_++

[17:14] <masak> rakudo: INIT {}

[17:14] <p6eval> rakudo 1eef08:  ( no output )

[17:14] <isBEKaml> =)

[17:15] <moritz_> rakudo: CHECK { say "oh hai" }

[17:15] <p6eval> rakudo 1eef08: OUTPUT«Could not find sub &say␤current instr.: '_block45' pc 166 (EVAL_1:80)␤»

[17:15] <moritz_> rakudo: CHECK { "oh hai".say }

[17:15] <p6eval> rakudo 1eef08: OUTPUT«oh hai␤»

[17:15] <isBEKaml> moritz_: what does CHECK do? fail loudly if they don't pass? 

[17:16] <isBEKaml> we have fail(), right? uhh? 

[17:16] <masak> isBEKaml: CHECK runs ALAP at compile time.

[17:16] <moritz_> isBEKaml: CHECK is just a phaser like BEGIN

[17:16] <masak> no other semantics, AFAIK.

[17:16] <moritz_> it just runs later than BEGIN

[17:16] <masak> now, PRE and POST... :)

[17:16] <[particle]> and before MAIN()

[17:17] <ash_> hmm 

[17:17] <moritz_> [particle]: everything that runs at compile time runs before run time :-)

[17:17] <isBEKaml> let me get this straight, PRE, BEGIN, CHECK, <BODY HERE>, END, POST ? 

[17:17] <ash_> so, which ones run at runtime? 

[17:17] * PerlJam wonders if CHECK is still a good name

[17:17] <ash_> is there an ENTER?  

[17:17] <masak> isBEKaml: you should really look up S04.

[17:17] <isBEKaml> moritz_: awk's back for jamming..! :)

[17:17] <masak> isBEKaml: it has the whole list.

[17:17] <moritz_> INIT, PRE, POST, START, ENTER, LEAVE all run at compile time

[17:17] <masak> ash_: yes.

[17:17] <moritz_> and a few more, probably :-)

[17:17] <moritz_> like FIRST

[17:17] <PerlJam> BEGIN?  :)

[17:18] <masak> moritz_: ENTER and LEAVE run at compile time? o.O

[17:18] * ash_ reading S04

[17:18] <moritz_> erm

[17:18] <moritz_> all at run time

[17:18] <moritz_> sorry

[17:18] * isBEKaml looking up S04

[17:18] <PerlJam> maximal confusion!

[17:18] <[particle]> BEGIN { sub MAIN { 'main'.say; CHECK { 'check'.say } }; }

[17:18] <masak> moritz_: you should read S04 too! :P

[17:18] <[particle]> forgot 'begin'.say there...

[17:18] * moritz_ should really be going to his table tennis training, and stop writing nonsense here

[17:19] * masak should really acquire nom

[17:19] <moritz_> [particle]: iirc master doesn't do MAIN yet

[17:19] <ash_> but moritz_ then who would write nonsense? :P 

[17:19] <[particle]> nope, that's why i didn't run in through the bot

[17:19] <isBEKaml> ash_: who would write nonsense to correct the nonsense? 

[17:19] <isBEKaml> :P

[17:20] <ash_> lol, i don't know the spec well enough to correct moritz_ 

[17:20] <moritz_> ash_: I'm sure you'll find somebody to do that

[17:20] <moritz_> (writing nonsense, that is)

[17:20] <moritz_> gone&

[17:20] *** dakkar left
[17:21] <diakopter> std: say $#array

[17:21] <p6eval> std 30552: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of $#array variable; in Perl 6 please use @array.end at /tmp/aF6RfF6Ziy line 1:␤------> [32msay $#array[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 107m␤»

[17:21] <diakopter> nice

[17:22] <isBEKaml> diakopter: this was autovivified earlier. oO

[17:22] <isBEKaml> ?? 

[17:23] <masak> which runs first, the PRE block of a method or the PRE block of a class? does the answer change with the declaration order of the two?

[17:23] *** meppl joined
[17:25] <ash_> masak: you suggested seeing if I could make a module to try to achieve the phasers I am looking for (for roles), but I don't think the current phasers activate at the right times, i could still look into oter ways of doing it though

[17:26] <PerlJam> ash_: what are you trying to do?

[17:26] <masak> ash_: seems to me one could maybe convince the metaclass to fire off user-defined phasers.

[17:27] <masak> ash_: maybe even with parts already in Rakudo.

[17:27] <ash_> PerlJam: looking at phasers for COMPOSED and INHERITED actions in OO 

[17:28] <PerlJam> ash_: ah, excellent!  I've wondered about those myself.

[17:28] <ash_> i didn't think of looking at the meta class

[17:28] <ash_> hmmm

[17:29] <ash_> with the metaclass wouldn't they need to be submethods? 

[17:29] <ash_> no, nevermind, thats silly, i think you can do it without making them submethods

[17:30] <PerlJam> particularly COMPOSED.  Seems like you'd want to do some automatic conflict resolution through method creation at composition time (yes, it may be a smell, but Perl has never stopped that before :)

[17:31] <masak> the default is pretty sweet already.

[17:31] <masak> but I can see the nice thing about being able to override it, I guess.

[17:32] <masak> nom &

[17:32] <PerlJam> in a way it's all hypothetical because no one has enough experience with roles to really say

[17:32] *** masak left
[17:33] <ash_> PerlJam: thats not strictly true, some other languages have what are effectively roles

[17:34] <PerlJam> ash_: the devil is always in the details.  :)

[17:34] * Su-Shee started desperately reading smalltalk-traits papers to understand roles

[17:34] <ash_> ruby's modules are nearly identical 

[17:35] <PerlJam> ash_: I think you and I have different definitions for the word "identical"  :)

[17:35] <ash_> probably

[17:35] <ash_> :P 

[17:35] *** MILKMILK joined
[17:35] *** lucs joined
[17:35] <PerlJam> there are lots of techniques the occupy similiar design space as roles.  Each have their own caveats.

[17:35] <MILKMILK> how do i compial perl6 with a perl5 interpreter?

[17:36] *** akl left
[17:36] *** MILKMILK left
[17:37] <PerlJam> MILKMILK: you mean blizkost?

[17:37] <[particle]> TROLLTROLL has left the room

[17:37] <PerlJam> ah.  that's what I get for only paying spurious attention

[17:39] <ash_> so... anyone here made a custom metaclass? 

[17:40] *** rv2733 left
[17:40] <ash_> that means writing a slang right? 

[17:42] <ash_> http://github.com/rakudo/rakudo/blob/master/docs/metamodel.pod is probably the only reference I know of for making a custom metaclass

[17:45] <ash_> you should be able to augment the Perl6 grammar right? 

[17:45] <ash_> rakudo: use MONKEY_TYPING; augment  grammar Perl6::Grammar { }

[17:45] <p6eval> rakudo 1eef08: OUTPUT«Method 'compose' not found for invocant of class ''␤current instr.: 'perl6;Perl6;Grammar;!class_init_11' pc 352 (EVAL_1:159)␤»

[17:45] * ash_ checks bugs tracker

[17:48] <ash_> nope, i don't see it

[17:48] <ash_> is there any reason you wouldn't be able to augment the grammar? 

[17:50] *** meteorjay left
[17:50] *** meteorjay joined
[17:52] <pugssvn> r30555 | lwall++ | [S06] long-threatened revamp of proto to keep routine and method semantics similar 

[17:53] *** Guest3356 left
[17:54] *** Guest3356 joined
[18:10] <pugssvn> r30556 | lwall++ | [S06] More rationale for the proto simplification 

[18:13] <TimToady> whew!

[18:13] *** ash_ left
[18:14] <PerlJam> If anyone ever wants to see Perl 6 "from the outside", go hang out in #p5p on irc.perl.org for a little while.

[18:15] *** SmokeMachine joined
[18:16] <TimToady> as opposed to #perl :)

[18:17] <TimToady> the dysfunctionality of the old p5p list is one of the reasons p6 happened, so we should be celebrating it :)

[18:28] *** rhr left
[18:28] <TimToady> Anyway, as the tiger said, "I don't mind you viewing me from the outside as long as you also don't mind viewing me from the inside."

[18:31] <PerlJam> TimToady: is that to imply that Perl 6 is actually a tiger rather than a butterfly and that it will eat you?  ;)

[18:32] <ntaylor> Newbie question: anyone else observing a segfault while running perl6 outside the pwd of the perl6 executable?

[18:33] <ntaylor> (latest checkout)

[18:33] <Su-Shee> PerlJam: no, it's a hobbes-tiger. ;)

[18:35] <ntaylor> gdb says it's dying within Parrot internals; I'll bug #parrot :)

[18:35] <PerlJam> ntaylor: perhaps it's grabbing the wrong libparrot?

[18:37] <ntaylor> PerlJam: ah, interesting, let me dig into that...

[18:37] <colomon> rakudo: my @a = 'a' ... 'g'; my %h = @a »=>» True; say %h.perl

[18:37] <p6eval> rakudo 1eef08: OUTPUT«{"a" => Bool::True, "b" => Bool::True, "c" => Bool::True, "d" => Bool::True, "e" => Bool::True, "f" => Bool::True, "g" => Bool::True}␤»

[18:39] <colomon> rakudo: my @a = 'a' ... 'g'; my %h = @a Z=> True, True ... *; say %h.perl

[18:39] <p6eval> rakudo 1eef08: OUTPUT«{"a" => Bool::True, "b" => Bool::True, "c" => 1, "d" => 1, "e" => 1, "f" => 1, "g" => 1}␤»

[18:40] <colomon> rakudo: my @a = 'a' ... 'g'; my %h = @a Z=> (True, True ... *); say %h.perl

[18:40] <p6eval> rakudo 1eef08: OUTPUT«{"e" => 1, "f" => 1, "g" => 1, "a" => Bool::True, "b" => Bool::True, "c" => 1, "d" => 1}␤»

[18:40] <PerlJam> I don't see how you're going to get True, True ... * to work since the series op is about numbers :)

[18:40] <ntaylor> PerlJam: There's only one libparrot in /blib/lib/ and otool is able to devine its path, so it might not be a library issue.  The error given back is "Null PMC access in find_method('get_parrotclass')\n current instr.: 'perl6;ClassHOW;onload' pc -1 ((unknown file):-1)"

[18:40] <PerlJam> you could use the version that has a closure though

[18:41] <ntaylor> and then the segfault occurs in Parrot_Context_get_info 

[18:41] <ntaylor> any thoughts?

[18:42] <colomon> PerlJam: series op is NOT about numbers.

[18:42] *** ash_ joined
[18:42] <colomon> and anyway, True is technically speaking a number.  :)

[18:42] <colomon> series op still has bugs in it, however.

[18:43] <colomon> rakudo: say (True ... *).perl

[18:43] <p6eval> rakudo 1eef08: OUTPUT«(Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True,

[18:43] <p6eval> ..Bool:…

[18:43] <colomon> not what I expected, but would have worked for me above.

[18:43] <colomon> rakudo: my @a = 'a' ... 'g'; my %h = @a Z=> (True ... *); say %h.perl

[18:43] <p6eval> rakudo 1eef08: OUTPUT«{"e" => Bool::True, "f" => Bool::True, "g" => Bool::True, "a" => Bool::True, "b" => Bool::True, "c" => Bool::True, "d" => Bool::True}␤»

[18:43] * colomon has started wondering about lazy hashes....

[18:45] <PerlJam> ntaylor: Hmm.   I have recompiled the latest rakudo a few times just now and I occassionally get a segfault compiling src/gen/core.pm

[18:45] <TimToady> PerlJam: Camelia is just the spokesbug; she doesn't claim to be the same species as Perl 6.  :)

[18:45] <ash_> TimToady: is there any reason you shouldn't be able to augment grammar Perl6::Grammar ? 

[18:46] <TimToady> other than that there is no such grammar in STD?  :)

[18:46] <TimToady> and that you forgot the 'use MONKEY_TYPING;'? :)

[18:46] <ntaylor> PerlJam: interesting, I had no issues compiling, and, indeed, it's happy running the test suite or executing perl6 so long as the pwd is the root rakudo directory

[18:46] <ash_> rakudo: use MONKEY_TYPING; augment  grammar Perl6::Grammar { } # Just wanted to make sure this is a bug 

[18:46] <p6eval> rakudo 1eef08: OUTPUT«Method 'compose' not found for invocant of class ''␤current instr.: 'perl6;Perl6;Grammar;!class_init_11' pc 352 (EVAL_1:163)␤»

[18:46] <colomon> ntaylor: did you "make install"

[18:46] <colomon> ?

[18:47] <TimToady> well, if rakudo has a Perl6::Grammar class, then it oughta work

[18:47] <PerlJam> colomon: I'll grant the series op is not *just* about numbers, but the spec sure is written as if it were.

[18:47] <ntaylor> colomon: no, I've not installed it, merely appended my envvars to point into the appropriate rakudo paths

[18:47] <ash_> i think the Perl6::Grammar is made in NQP-rx so that might be why its not working 

[18:48] <colomon> PerlJam: actually, the spec does cover non-numbers as well.  but many of the cool features of series do require numbers, which is why the spec focuses on them.

[18:48] <TimToady> there should probably be something in there that says that enums mean their numbers to a series, and that * means the max enum

[18:48] <colomon> ntaylor: you have to do make install to be able to run the executable outside the rakudo directory.

[18:48] <ntaylor> aha.

[18:48] <ntaylor> Well, serves me right for trying to outsmart the build script.

[18:48] <colomon> TimToady: I've been wondering how series or range is supposed to make * mean the max enum.

[18:49] <ntaylor> oh, well, I'll be damned

[18:49] <colomon> ntaylor: it doesn't install it anywhere outside of there, mind you, just sets things up so it can be run outside of there.

[18:49] <ntaylor> indeed, I just noticed :)

[18:49] <colomon> TimToady: I mean, how it is supposed to know what the max is?

[18:49] <ntaylor> hey, there we go. :-)  Thanks.

[18:50] <PerlJam> colomon++ good thinking

[18:50] <TimToady> an enum is a hash, so it ought to respond to .values.max

[18:50] <TimToady> I realize that rakudo still thinks of enums primarily as packages though

[18:50] <colomon> so we can say something like "if $lhs ~~ Enum && $rhs ~~ Whatever { $rhs = $lhs.WHAT.values.max }"?

[18:51] <TimToady> the new view is that an enum is simply a constant hash that happens to also introduce some second-class constants if they don't collide

[18:53] <sorear> considering the performance implications of real slangs in rakudo, I just figured out what the lex/ directory in STD is for

[18:54] <TimToady> yeah...fortunately there's still lots of room for optimization even there

[18:54] <colomon> TimToady: how does the constant hash imply an ordering?  .values won't actually work for that, will it?

[18:55] <TimToady> we'd have to assume that the values are well-behaved

[18:55] <TimToady> otherwise it's probably just erroneous

[18:56] <TimToady> the series itself is probably just doing 0,1,2,3...42

[18:56] <colomon> TimToady: one other series question from the other day: "it depends on whether the two values look like numbers whether we use *+0 or *.succ/*.pred."  Is there a technical definition for 

[18:56] <colomon> "look like numbers"?

[18:57] <TimToady> I mean it in the pattern matching sense

[18:57] <PerlJam> $value.are-you-or-are-you-not-a-number

[18:57] <ash_> PerlJam: +$value? 

[18:57] <TimToady> history: looks_like_number() is a routine inside of P5 that sees if a string seems to be a representation of a number

[18:58] <PerlJam> ash_: that's more like $value.turn-into-your-best-idea-of-a-number

[18:59] <ash_> well, then shouldn't the person writing it be more explicit if thats not what they want? 

[19:03] <colomon> rakudo: say +"hell"

[19:03] <p6eval> rakudo 1eef08: OUTPUT«0␤»

[19:03] <sorear> TimToady: Do I stand much chance of understanding gimme5?

[19:03] <TimToady> it's not terrible, but it's not wonderful either. :)

[19:03] <ash_> rakudo: role Foo { our sub bar { say 'Foo::bar called' } }; Foo::bar; # thats should work right? 

[19:03] <p6eval> rakudo 1eef08: OUTPUT«Can not find sub Foo::bar␤current instr.: 'perl6;Perl6Exception;throw' pc 15354 (src/builtins/Associative.pir:46)␤»

[19:03] <colomon> TimToady: so, at the most naive level, just something like $a ~~ /^\d/

[19:03] <colomon> ?

[19:04] <colomon> (obviously need to support +/- first as well.)

[19:04] <TimToady> sorear: gimme5 is pretty understandable in the regex translation bits, which are hierarchical

[19:04] <sorear> phenny: tell masak - postfix: macros not working is not a bug, it turns out that operator-like macros need a completely different implementation and I haven't implemented it yet.  The ][ thing is troubling, though.

[19:04] <phenny> sorear: I'll pass that on when masak is around.

[19:04] <sorear> Su-Shee: Can you give examples of stuff you want to work in rakudo?

[19:04] <TimToady> most of the rest of the translation is done bit-by-bit in un6

[19:05] <TimToady> viv -5 is partway there to replacing gimme5; but it only really translates some of the un6() stuff so far

[19:05] <TimToady> I've only just started the regex translation

[19:06] <TimToady> the only other hairy stuff in gimme5 is parsing the sigs and emitting the corresponding p5 code

[19:06] <TimToady> that's mostly just done with strange lookahead patterns in the main loop

[19:07] <TimToady> the main limitation of gimme5 is that it is not able to do any tree transformations on non-regex code.

[19:08] <TimToady> so in normal p6 expressions STD has to be written in a subset that can translate close to word-for-word to p5

[19:09] <TimToady> when we switch to viv -5 that restriction will presumably go away, but we'd probably better freeze a bootstrap stage of STD.pm6 there in case we need to rebootstrap

[19:11] *** Ross joined
[19:11] *** justatheory left
[19:14] <sorear> or maybe someday rakudo/mildew/etc could become good enough to run STD and viv6 directly?

[19:16] <TimToady> yes, kudos to the first implementation that actually runs STD :)

[19:16] <Su-Shee> sorear: what I personally want to or what I think what's important to have? or more in the meaning "how to place/position rakudo as a language"?

[19:16] <TimToady> the code emitted by gimme5/viv is also special, insofar as it's trading off semantic correctness

[19:16] <TimToady> for instance, using locals for dynamic variables

[19:17] <TimToady> and basically assuming a single-threaded parser

[19:17] *** meppl left
[19:19] <TimToady> I do think the new proto semantics will map more nicely to p5 though

[19:19] <sorear> is STD completely Perl6 or does it rely on gimme5 extensions?

[19:20] *** ShaneC1 joined
[19:20] * sorear notes that STD_syntax_hilight crashes when fed STD.pm6

[19:20] *** ash_ left
[19:20] <TimToady> its base class Cursor is in P5

[19:20] <TimToady> (so far)

[19:20] <sorear> Su-Shee: What you, personally, want.

[19:20] *** ShaneC1 left
[19:20] <TimToady> was waiting on viv to translate Cursor

[19:20] *** ash_ joined
[19:20] <TimToady> since one of the reasons for having Cursor in P5 was to express things that gimme5 can't translate...

[19:20] <sorear> topic/lexical-persistence has passed spectest

[19:21] <Su-Shee> sorear: future web, gui bindings for everything, mashups, mobile devices of all kinds, poor man's data mining, DSLs

[19:22] <Su-Shee> sorear: all in a tidy, tiny, pretty zen-like fashion. no workhorses. 

[19:23] *** ntaylor left
[19:25] <tedv> Is the rakudo repository actually in git, or is it really subversion and the documentation told me to use git because git is awesome?

[19:25] <colomon> tedv: it's in git on github

[19:26] <tedv> I know the pugs unit tests are still subversion

[19:27] *** rhr joined
[19:27] <tedv> sweet, tedv wasn't taken on github.  4 letter user name FTW!

[19:28] <TimToady> tedv: svn for several reasons: 1) pugs history, 2) very low barrier to entry, and 3) not much branching needed for the test suite

[19:28] <tedv> and 4) if it's not broken don't fix it

[19:28] <tedv> yeah

[19:28] <TimToady> :)

[19:28] <sorear> Su-Shee: I meant in regards to DSLs.

[19:29] <TimToady> doubtless we'll move it all over to git someday, but I'm in denial :)

[19:29] <Su-Shee> sorear: I'm wracking my brain about making graphics, shapes and widgets easier. 

[19:30] <Su-Shee> wrecking? 

[19:30] <Su-Shee> well I'm thinking hard. :)

[19:30] <tedv> Hmmm, if I'm just starting out by adding unit tests though, I shouldn't need to change anything in rakudo, so I shouldn't need any access to the github repository

[19:31] <Su-Shee> sorear: I'd like to be able to say "draw this here, make it green and oh yeah, a shadow please and oh, yes, if you click, action x will happen". in short and straightforward and easy.

[19:32] *** ruoso left
[19:40] *** ruoso joined
[19:47] *** rv2733 joined
[19:51] <pugssvn> r30557 | colomon++ | [t/spec] Add a test for Num.log(Complex), which needs to be skipped now, alas. 

[19:56] *** cotto_work left
[19:57] *** cotto_work joined
[19:57] *** _jaldhar left
[19:57] *** _jaldhar joined
[20:00] <TimToady> phone

[20:02] <sorear> Su-Shee: your task, if you choose to accept it, is to design this language.

[20:03] *** kst left
[20:03] <tedv> can methods and submethods have parameter lists?

[20:03] *** kst joined
[20:03] <sorear> yes

[20:04] <tedv> I mean other than their invocant

[20:04] <Su-Shee> sorear: and when I'm done desiging it, I get flowers? :)

[20:04] <tedv> but I assume the answer is still yes

[20:04] <sorear> indeed, they are mandatory in rakudo

[20:04] <sorear> we don't implement method foo { } yet

[20:04] <sorear> Su-Shee: No, you get Phase II.

[20:05] <Su-Shee> "aha" ;) I have no idea what you're getting at :)

[20:06] <pugssvn> r30558 | colomon++ | [t/spec] Add some log tests, most of which need to be skipped for now. 

[20:09] *** iblechbot joined
[20:15] *** justatheory joined
[20:22] *** Su-Shee left
[20:23] *** pmurias joined
[20:24] *** molaf joined
[20:27] <diakopter> pmurias: hi

[20:28] <pmurias> diakopter: hi

[20:29] <diakopter> typo  in TimToady   The first versoin of Rakudo 

[20:31] <colomon> rakudo: say ('z' ... 'a').perl

[20:31] <p6eval> rakudo 1eef08: OUTPUT«("z", "y", "x", "w", "v", "u", "t", "s", "r", "q", "p", "o", "n", "m", "l", "k", "j", "i", "h", "g", "f", "e", "d", "c", "b", "a")␤»

[20:32] <tedv> rakudo say('z' .. 'a').perl

[20:32] <colomon> rakudo: say ('z', 'y' ... 'a').perl

[20:32] <p6eval> rakudo 1eef08: OUTPUT«("z", "y")␤»

[20:32] <tedv> rakudo: say('z' .. 'a').perl

[20:32] <p6eval> rakudo 1eef08: OUTPUT«␤»

[20:32] <colomon> tedv: Range's (..) cannot go backwards

[20:32] <tedv> rakudo: say('a' ... 'f').perl

[20:32] <p6eval> rakudo 1eef08: OUTPUT«abcdef␤»

[20:32] *** pmurias left
[20:32] <colomon> but series (...) can

[20:32] <tedv> yeah I thought that's how it would work

[20:33] <tedv> examining output seemed like the best way to find out though

[20:37] <colomon> I think according to the current spec 'z' ... 'a' is supposed to work, but 'z', 'y' ... 'a' is not.

[20:37] <colomon> unless someone gives me a good reason, I'm probably going to fix that in code and in spec today.  :)

[20:39] <tedv> rakudo: say('a', 'b' ... 'e').perl

[20:39] <p6eval> rakudo 1eef08:  ( no output )

[20:39] <tedv> rakudo: say('a', 'b' .. 'e').perl

[20:39] <p6eval> rakudo 1eef08: OUTPUT«abcde␤»

[20:39] <moritz_> this takes .perl of the return value of say(), and ignores it

[20:41] <colomon> rakudo: say ('a', 'b' ... *).perl

[20:41] <p6eval> rakudo 1eef08: OUTPUT«("a", "b", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {???} ... ???)␤»

[20:41] *** molaf left
[20:42] <colomon> rakudo: say 'z'.prev

[20:42] <p6eval> rakudo 1eef08: OUTPUT«Method 'prev' not found for invocant of class 'Perl6Str'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:42] <colomon> rakudo: say 'z'.prec

[20:42] <p6eval> rakudo 1eef08: OUTPUT«Method 'prec' not found for invocant of class 'Perl6Str'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:43] <colomon> rakudo: my $a = 'z'; say --$a

[20:43] <p6eval> rakudo 1eef08: OUTPUT«y␤»

[20:43] <colomon> rakudo: my $a = 'z'; say $a.prec

[20:43] <moritz_> rakudo: say 'z'.pred

[20:43] <p6eval> rakudo 1eef08: OUTPUT«Method 'prec' not found for invocant of class 'Perl6Str'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:43] <p6eval> rakudo 1eef08: OUTPUT«y␤»

[20:44] <colomon> doh!

[20:44] <colomon> I think I just found a block of code in the series operator which has never actually been run, then.

[20:44] * colomon wishes for am embarrassed smiley yet again....

[20:44] <tedv> which section of the spec explains  twigils in detail?

[20:45] <moritz_> S02, S06 and S12 probablz

[20:45] <tedv> (-_-);

[20:45] <moritz_> s/z/y/

[20:45] <moritz_> depending on the twigil

[20:45] <ash_> does parrot have a trace yet? like gcov? 

[20:46] <ash_> that would be useful for finding places that aren't correct, if you could run a gcov like program with the parrot code generated and be able to see which parts of your script executed and which parts didnt 

[20:46] <ash_> S02 has a list, it has the biggest overview of the twigils 

[20:47] <tedv> yeah I have it open now

[20:48] *** pmurias joined
[20:48] <pmurias> diakopter: by internet connection failed and i had to reset the router a few times

[20:54] <tedv> hmm, where can one download the perl 6 color markup instructions for vim?  white text is fail text. :[

[20:55] *** kst left
[20:56] <moritz_> tedv: http://github.com/petdance/vim-perl has a perl6.vim file

[20:57] <tedv> thanks

[21:00] *** kst joined
[21:00] <ash_> oh man he updated, i need to re-checkout my vim-perl stuff

[21:00] *** orafu left
[21:00] <tedv> ahhh that looks much better

[21:00] *** orafu joined
[21:01] <alester> tedv: at some point I'll have an installer for it.

[21:01] <tedv> cp is fine for me

[21:01] <tedv> it gets the files in the right places; ergo it works

[21:03] <tedv> Hmmm I notice that some unit tests have parallel .t and .rakudo files.  I assume that rakudo uses a .rakudo file over a .t if it exists, and it contains special logic that handles some kind of current rakudo inadequacy?

[21:03] *** alester left
[21:03] <tedv> it sounds like the rule of thumb is "don't write a test that breaks; instead write a test that passes and document when it should pass the inverse logic"

[21:05] <ash_> there is a makefile, git clone the repo and do make install 

[21:06] *** BrowserUk left
[21:06] <ash_> tedv: you mean the fudging? rakudo fudges tests it knows it doesn't pass, but the .rakudo files are auto-generated 

[21:06] <tedv> ah okay

[21:06] <tedv> so just putting a #?rakudo todo should handle that?

[21:07] <ash_> do you want to fudge the whole file? or part of a file? 

[21:08] <tedv> I don't have any particular wants except understanding

[21:09] <tedv> I'm more trying to understand the context

[21:09] <ash_> you can do #?rakudo # skip 'comment why' to skip multiples, or #?rakudo skip 'comment' to skip 1, or call it a todo, if you want to fudge an entire file change the spectest.data in the rakudo/t/ folder 

[21:09] <ash_> that first one would be more like #?rakudo 3 skip 'Bug ticket #b123' for instance to skip 3 

[21:10] <tedv> alright

[21:10] <tedv> and the skip will skip the next N tests executed?

[21:10] <tedv> for example, if I have something like...

[21:10] <tedv> sub foo { is $a, $b, "my test"; }

[21:10] <tedv> #?rakudo 2 skip

[21:10] *** ruoso left
[21:11] <tedv> then two calls to foo() after that

[21:11] <tedv> those would get skipped.  but if foo() had two "is" checks, then the skip effectively only skips the first function call?

[21:11] <tedv> ugh sorry, kind of a pedantic question

[21:13] *** pmurias left
[21:16] <ash_> um

[21:16] <ash_> i am not sure, i'd have to check the fudge script

[21:18] <ash_> http://svn.pugscode.org/pugs/t/spec/fudge is the fudge script that does the fudging 

[21:19] *** lichtkind joined
[21:19] <lichtkind> nqp: say 4

[21:19] <p6eval> nqp: OUTPUT«Confused at line 1, near "say 4"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[21:20] <ash_> nqp: say(4); # nqp is strict about ( )

[21:20] <p6eval> nqp: OUTPUT«4␤»

[21:20] <lichtkind> thanks ash

[21:22] <lichtkind> jnthn: can i egt an +o ?

[21:23] <lichtkind> mas

[21:23] <lichtkind> err

[21:24] <s1n> holy moly, my perl[56] feed backlog was a mile long

[21:25] <s1n> 6 months backs of not doing anything perl6 backed up

[21:25] <lichtkind> :)

[21:26] <lichtkind> err op is gone?

[21:26] *** Ross left
[21:27] <colomon> lichtkind: seems like it has been for a long time?

[21:27] <colomon> but I don't remember the details.

[21:27] <colomon> rakudo: say 3 err 45

[21:27] <p6eval> rakudo 1eef08: OUTPUT«3␤»

[21:27] <colomon> or not.  :)

[21:27] <colomon> rakudo: say Mu err 45

[21:27] <p6eval> rakudo 1eef08: OUTPUT«Mu()␤»

[21:28] <lichtkind> rakudo: say 0 // 4

[21:28] <p6eval> rakudo 1eef08: OUTPUT«0␤»

[21:28] <s1n> colomon: how's your work on perl6 numerical methods (that is what you were working, right)?

[21:28] <lichtkind> rakudo: say '' // 4

[21:28] <colomon> s1n: right.

[21:28] <p6eval> rakudo 1eef08: OUTPUT«␤»

[21:28] <colomon> s1n: sort of slow but sure.  :)

[21:28] <lichtkind> rakudo: say undef // 4

[21:28] <p6eval> rakudo 1eef08: OUTPUT«Unsupported use of undef as a value; in Perl 6 please use something more specific:␤        Mu (the "most undefined" type object),␤   an undefined type object such as Int,␤    Nil as an empty list,␤    *.notdef as a matcher or method,␤ Any:U as a type constraint␤       or

[21:28] <p6eval> ..fail() as a failure return␤       …

[21:30] <s1n> colomon: keep it up, it's god's work indeed :)

[21:30] <colomon> s1n: I do a few bits, and all is going well, and then I run into a role bug and have to wait a bit on jnthn++

[21:33] *** wknight8111 joined
[21:34] <colomon> hmmm....

[21:34] <s1n> colomon: i'd like to help, but i really shouldn't until i finish my thesis :/

[21:35] <colomon> rakudo: my StrNum does Real { has Str $.num; method Bridge() { +$.num; }; }; my $a = Real.new(:num("34")); 

[21:35] <p6eval> rakudo 1eef08: OUTPUT«In "my" declaration, typename StrNum must be predeclared (or marked as declarative with :: prefix) at line 11, near " does Real"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[21:36] <colomon> s1n: no worries.

[21:36] <colomon> rakudo: class StrNum does Real { has Str $.num; method Bridge() { +$.num; }; }; my $a = Real.new(:num("34")); 

[21:36] <p6eval> rakudo 1eef08:  ( no output )

[21:36] <colomon> rakudo: class StrNum does Real { has Str $.num; method Bridge() { +$.num; }; }; my $a = Real.new(:num("34")); say $a.WHAT; say $a + 3; say $a.exp

[21:36] <p6eval> rakudo 1eef08: OUTPUT«Real()␤Method 'Bridge' not found for invocant of class 'Failure'␤current instr.: 'infix:<+>' pc 297223 (src/gen/core.pir:1004)␤»

[21:36] *** BrowserUk joined
[21:37] <colomon> rakudo: class StrNum does Real { has Str $.num; method Bridge() { +$.num; }; }; my $a = StrNum.new(:num("34")); say $a.WHAT; say $a + 3; say $a.exp

[21:37] <p6eval> rakudo 1eef08: OUTPUT«StrNum()␤37␤583461742527454␤»

[21:37] <colomon> hmmm.... exp seems very wrong there.  :\

[21:38] <colomon> anyway, that's one of my goals -- making it very easy to add a new Numeric class that plays nicely with the existing ones.

[21:38] <colomon> afk # toddler just woke up cranky

[21:42] *** Guest3356 left
[21:49] *** arthur-_ joined
[21:51] <colomon>  rakudo: say e ** 34

[21:51] <p6eval> rakudo 1eef08: OUTPUT«583461742527454␤»

[21:51] *** christine left
[21:51] <colomon> or, my intuition for what exp should return is very bad.

[21:52] <colomon> rakudo: class StrNum does Real { has Str $.num; method Bridge() { +$.num; }; }; my $a = StrNum.new(:num("3.4")); say $a.WHAT; say $a + 3; say $a.exp

[21:52] <p6eval> rakudo 1eef08: OUTPUT«StrNum()␤6.4␤29.964100047397␤»

[21:52] <colomon> rakudo: class StrNum does Real { has Str $.num; method Bridge() { +$.num; }; }; my $a = StrNum.new(:num("3.4")); say $a.WHAT; say $a + 3; say $a.exp.log

[21:52] <p6eval> rakudo 1eef08: OUTPUT«StrNum()␤6.4␤3.4␤»

[22:00] *** iblechbot left
[22:04] *** christine joined
[22:07] *** ethel joined
[22:10] *** ash_ left
[22:12] <TimToady> rakudo: say e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e*e

[22:12] <p6eval> rakudo 1eef08: OUTPUT«583461742527454␤»

[22:13] <TimToady> rakudo: say pi**34

[22:13] <p6eval> rakudo 1eef08: OUTPUT«8.00010471504562e+16␤»

[22:16] <TimToady> rakudo: say e**pi - pi

[22:16] <p6eval> rakudo 1eef08: OUTPUT«19.9990999791895␤»

[22:16] <TimToady> darn it :)

[22:20] <colomon> guess I don't have it accurate enough yet.  ;)

[22:21] <TimToady> rakudo: say e.WHAT

[22:21] <p6eval> rakudo 1eef08: OUTPUT«Num()␤»

[22:21] <TimToady> rakudo: say pi.WHAT

[22:21] <p6eval> rakudo 1eef08: OUTPUT«Num()␤»

[22:22] <TimToady> there's your problem :)

[22:24] <TimToady> rakudo: say pi**33

[22:24] <p6eval> rakudo 1eef08: OUTPUT«2.54651242130458e+16␤»

[22:24] <TimToady> rakudo: say pi**32

[22:24] <p6eval> rakudo 1eef08: OUTPUT«8.1058007899107e+15␤»

[22:24] <TimToady> rakudo: say pi**31

[22:24] <p6eval> rakudo 1eef08: OUTPUT«2.58015652686496e+15␤»

[22:24] <TimToady> rakudo: say pi**30

[22:24] <p6eval> rakudo 1eef08: OUTPUT«821289330402749␤»

[22:24] <TimToady> there yo ugo

[22:24] <TimToady> Yo, Ugo!!

[22:26] *** lue joined
[22:27] <lue> hello!

[22:28] <TimToady> pugs: say pi ** 30

[22:28] <p6eval> pugs: OUTPUT«821289330402747.711387089095441878807212836874715389772␤»

[22:28] <TimToady> ooh, shiney

[22:28] <lue> ooooooooh Oo

[22:28] <TimToady> rakudo: say pi ** 30

[22:28] <p6eval> rakudo 1eef08: OUTPUT«821289330402749␤»

[22:29] <TimToady> wow, doesn't even get the right integer :)

[22:29] <lue> I'd understand ...748. But ...749?

[22:29] <lue> EOFFBYTWO

[22:30] <TimToady> lack of floating precision

[22:30] <TimToady> hmm

[22:30] <TimToady> rakudo: say e**34

[22:30] <p6eval> rakudo 1eef08: OUTPUT«583461742527454␤»

[22:30] <TimToady> pugs: say e**34

[22:30] <p6eval> pugs: OUTPUT«*** No such subroutine: "&e"␤    at /tmp/OzXmvVOwue line 1, column 5 - line 2, column 1␤»

[22:30] <TimToady> O.o

[22:31] <lue> .oO( that's what I call an inactive project! :) )

[22:31] <TimToady> eeee!

[22:33] * lue | backlog --channel="#perl6" --when="today"

[22:34] * TimToady is tempted to return a junction

[22:36] *** ethel_ joined
[22:36] * lue back

[22:37] *** ethel_ left
[22:37] *** ethel left
[22:37] <lue> is there any way to convert to arbitrary bases?

[22:38] *** ethel joined
[22:38] *** ethel left
[22:39] *** ethel joined
[22:39] <sorear> lichtkind: jnthn is *gone*

[22:39] <lue> .oO(*gone* ? D:)

[22:39] <lichtkind> sorear: ah

[22:40] <sorear> lue: No internet access for 3 days!

[22:41] <lue> Stupid volcano .oO(I Hate Iceland!)

[22:41] <colomon> TimToady: can 'z', 'y', ... 'a'  be the same as 'z' ... 'a' ?

[22:43] <TimToady> seems likely

[22:43] *** nihiliad left
[22:44] <colomon> it's actually not spec'd to work that way at the moment, but I figured that was what you'd say.  :)

[22:44] <colomon> (I've got it working locally at the moment.)

[22:44] <TimToady> might be harder to make 'zz', 'zy' ... 'aa' to work

[22:45] <TimToady> rakudo: 'z', 'y', ... 'a'  # wonder what rakudo does with the extra comma

[22:45] <colomon> the rule I've got in there is that if it is non-numeric, you treat it as 'z', ('y' ... 'a')

[22:45] <p6eval> rakudo 1eef08: OUTPUT«No exception handler and no message␤current instr.: '&fail' pc 18025 (src/builtins/Junction.pir:481)␤»

[22:45] * sorear reads S05 some more

[22:45] <colomon> actually, I've just been wondering if 'z', 'y' ... * should use pred instead of succ

[22:45] <colomon> (that's not implemented yet.)

[22:46] <lue> that's very quantum.

[22:46] <lue> rakudo: 'z','y', ... 'a'

[22:46] <p6eval> rakudo 1eef08: OUTPUT«No exception handler and no message␤current instr.: '&fail' pc 18025 (src/builtins/Junction.pir:481)␤»

[22:46] <lue> rakudo: 'z','y' ... 'a'

[22:46] <p6eval> rakudo 1eef08:  ( no output )

[22:46] <lue> rakudo: say 'z','y' ... 'a'

[22:46] <p6eval> rakudo 1eef08: OUTPUT«zy␤»

[22:47] <colomon> > ('z', 'y' ... 'a').perl.say

[22:47] <colomon> ("z", "y", "x", "w", "v", "u", "t", "s", "r", "q", "p", "o", "n", "m", "l", "k", "j", "i", "h", "g", "f", "e", "d", "c", "b", "a")

[22:48] * TimToady wonders if single characters should always just be treated as codepoint numbers

[22:48] <sorear> you mean like C?

[22:48] <sorear> 'a'.say => 97

[22:48] <TimToady> no, in terms of succ/pred

[22:49] <TimToady> so that "\0" ... "\x7f" would get all ASCII, for instance

[22:50] <TimToady> currently it would turn 'Z' into 'AA' and never get there

[22:50] <lue> rakudo: say ("\0" ... "\x7f") # curious

[22:51] <p6eval> rakudo 1eef08:  ( no output )

[22:51] <TimToady> so 'A' ... 'z' would terminate, but 'A' ... 'zz' wouldn't

[22:51] <TimToady> ...as long as we're special casing it for all kinds of dwimmery :)

[22:52] *** kst left
[22:53] *** kst joined
[22:53] <sorear> TimToady: What does PEG Rule 5 mean?

[22:53] <TimToady> that is, if the characters involved were all single codepoints, you'd do ('A'.ord ... 'z'.ord).map: *.chr

[22:54] <sorear> "5) Declaration with least number of 'uses' wins"

[22:54] <lue> .oO(stop this tom-dwimmery!)

[22:54] <lue> PEG?

[22:54] <TimToady> as in the 'use' statement

[22:54] <TimToady> I explained this earlier to today

[22:55] *** jjore left
[22:55] *** ruoso joined
[22:56] <sorear> Ah, I see

[22:56] *** ruoso left
[22:56] <sorear> moritz++

[22:57] <TimToady> was masak++ that asked

[22:57] <sorear> moritz provided the log though

[22:57] <TimToady> which is why I didn't take away his ++   :)

[22:58] <sorear> what's the difference between 3 and 5?

[22:58] <TimToady> 3 is derivation independent of file

[22:58] <TimToady> could be in the same file

[22:58] <TimToady> more derived still wins

[22:58] <TimToady> regardless of #4

[22:59] *** snarkyboojum joined
[22:59] <sorear> How does s[pattern] = doit() parse?

[22:59] <lue> What's is PEG? Perl Ettiquette Guidelines...?

[22:59] <TimToady> see S05

[22:59] <TimToady> or the patch in question

[22:59] *** ruoso joined
[23:00] <TimToady> wikipedia also has an article on Parsing Expression Grammars (oops)

[23:00] *** eternaleye left
[23:00] <TimToady> sorear: the sibble rule does it

[23:00] *** jjore joined
[23:01] <lue> rakudo: say "1ffffff".fmt('%b')

[23:01] <p6eval> rakudo 1eef08: OUTPUT«1␤»

[23:01] <lue> ō.o

[23:01] *** stephenlb left
[23:03] <TimToady> rakudo: say "1fffff" + "1fffff"

[23:03] <p6eval> rakudo 1eef08: OUTPUT«2␤»

[23:03] <TimToady> looks right to me :)

[23:04] <TimToady> apart from the missing "Weird junk after number" warnings  :)

[23:04] <sorear> I thought that was a fatal error in perl 6

[23:04] <lue> *sigh*

[23:04] <lue> rakudo: say :16<1ffffff>.fmt('%b')

[23:04] <p6eval> rakudo 1eef08: OUTPUT«1111111111111111111111111␤»

[23:05] <TimToady> well, errors that are too fatal are just as likely to crash a spacecraft as errors that are not fatal enough

[23:06] <TimToady> and I'm not nearly as exception-happy now that we're trying to do hyperops and such

[23:06] <lue> that looks better, but the script shouldn't have said all 1's (grr)

[23:06] <TimToady> why not?

[23:07] <TimToady> each f is 1111

[23:07] <lue> my script output the wrong number, that's what I meant.

[23:08] <TimToady> ah, don't try to confuse me--that would be redundant

[23:08] <lue> would this line do what I want it to do? :

[23:09] <lue> if $filein.split('')[$i].uc == "A" or "T"

[23:09] <lue> (the equality part)

[23:09] <TimToady> I was gonna say, don't you need some kind of mumblease to split DNA?

[23:10] <TimToady> no, you need a junction for that

[23:10] <TimToady> 'A' | 'T'

[23:10] <lue> thought so. No wonder I got all ones. "T" is true.

[23:10] <TimToady> or any('A','T')

[23:11] <lue> rakudo: say "hi" if "T" is True;

[23:11] <p6eval> rakudo 1eef08: OUTPUT«Confused at line 11, near "say \"hi\" i"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[23:11] <TimToady> you'll not it doesn't say *who* is confused there :P

[23:11] <TimToady> *note

[23:11] <lue> (methinks I got caught up in natural language)

[23:11] <lue> rakudo: say "hi" if "T";

[23:11] <p6eval> rakudo 1eef08: OUTPUT«hi␤»

[23:13] <sjohnson> rakudo: say "hi" if 'F';

[23:13] <sbp> rakudo: say "1a" + "1a"

[23:13] <sjohnson> rakudo, hailing from africa

[23:13] <p6eval> rakudo 1eef08: OUTPUT«hi␤»

[23:13] <p6eval> rakudo 1eef08: OUTPUT«2␤»

[23:13] <sbp> rakudo: say "1a" + "a1a"

[23:13] <p6eval> rakudo 1eef08: OUTPUT«1␤»

[23:14] <sbp> rakudo: say "1a" + " 1a"

[23:14] <p6eval> rakudo 1eef08: OUTPUT«2␤»

[23:14] <sbp> rakudo: say "1a" + ".1a"

[23:14] <p6eval> rakudo 1eef08: OUTPUT«1.1␤»

[23:14] <sbp> rakudo: say "1a" + ":1a"

[23:14] <p6eval> rakudo 1eef08: OUTPUT«1␤»

[23:14] <sbp> rakudo: say "1a" + "..1a"

[23:14] <p6eval> rakudo 1eef08: OUTPUT«1␤»

[23:14] <sbp> rakudo: say "1a" + " .1a"

[23:14] <p6eval> rakudo 1eef08: OUTPUT«1.1␤»

[23:14] <sbp> thus endeth the test suite

[23:14] <TimToady> basically doing p5 semantics there...

[23:15] <sjohnson> perl 6 april fools joke should have rakudo behave oddly next year

[23:15] <lue> while we're at Odd Math...

[23:15] <lue> rakudo: my $a=3; my $b=2; say $a$b # implicit multiplication

[23:15] <p6eval> rakudo 1eef08: OUTPUT«Confused at line 11, near "say $a$b #"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[23:15] *** xabbu42 left
[23:16] <lue> sjohnson: how would anyone notice the joke then? ;)

[23:17] <TimToady> more precisely...

[23:17] <sjohnson> heh

[23:17] <TimToady> std: my $a=3; my $b=2; say $a$b # implicit multiplication

[23:17] <p6eval> std 30558: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/eIX2NYpmCc line 1:␤------> [32mmy $a=3; my $b=2; say $a[33m⏏[31m$b # implicit multiplication[0m␤    expecting any of:␤   POST␤   bracketed infix␤    infix or meta-infix␤      postfix␤       

[23:17] <p6eval> ..postfix_prefix_meta_operator␤       statement modifier…

[23:18] *** justatheory left
[23:19] <slavik1> does the parrot library for postgres work?

[23:20] <lue> so it recognizes the $ as a start of a new term, interesting.

[23:20] <lue> (or rather, makes the distinction)

[23:21] <TimToady> fundamentally, Perl is extremely opposed to juxtaposition operators, and has been since version 1, or maybe 0

[23:21] <TimToady> the foibles of mathematicians notwithstanding

[23:21] <slavik1> what kind of threading model does Perl6 use? Whatever parrot provides?

[23:22] <TimToady> Perl 6 is not defined in terms of parrot

[23:22] *** eternaleye joined
[23:22] <sorear> TimToady: Do you consider Rakudo's use of an "actions class" a fossil?

[23:22] <TimToady> no

[23:22] <TimToady> {*} is the fossil

[23:22] <lichtkind> is err gone?

[23:23] <TimToady> has been gone for ages

[23:23] <lichtkind> but it was in rakudo :)

[23:23] <lue> that (does & does not) put a damper on my proposed Math with Perl6 book :)

[23:23] * TimToady should put all his oracular sayings into hexameter

[23:23] <lichtkind> TimToady: has it been replaced except of // ?

[23:23] <sorear> TimToady: Asking because STD.pm6 seems to use exclusively inline actions

[23:24] <TimToady> it was replaced with "orelse"

[23:24] <lue> .oO(talking in DNA bases is interesting)

[23:24] *** felipe left
[23:24] <TimToady> sorear: no, it's just you don't see the actions argument in viv

[23:24] <TimToady> and pure STD doesn't care about actions yet

[23:25] <lichtkind> TimToady: so i just use orels instead of where I former used err?

[23:25] <TimToady> the point of making the actions plugglable is to put the same grammar to different uses

[23:25] <TimToady> s/ggl/gg/

[23:25] * slavik1 should've studied linguistics ...

[23:25] <TimToady> lichtkind: kinda, it is no longer exactly the same semantics as //

[23:26] <lichtkind> TimToady: because you cannt connect blocks with // as orelse does i suggest

[23:26] <TimToady> the point of orelse is to do logic programming, not provide defaults like // does

[23:27] <TimToady> so they are merely similar

[23:27] <TimToady> but andthen and orelse try to set up $_ or $! for testing sub-hypotheses

[23:28] <TimToady> no one implements them yet, btw

[23:28] <sorear> TimToady: OH!

[23:28] <sorear> That makes things *much* easier

[23:28] <TimToady> slavik1: as for shared vs unshared data, p6's model is that everything outside the lexical scope of the async {} is shared, and everything inside isn't

[23:28] <TimToady> which is why we try to make everything as lexical as possible, including dynamic vars

[23:29] <sorear> TimToady++ uncanny ability to anticipate all my problems and pre-solve them

[23:29] <sorear> TimToady: Is that basically the same as "everything is shared, but the async {} is re-cloned in the new task"?

[23:29] <lichtkind> TimToady: yadday orelse yadde comes much more fluent from my lips then yadda err yadda

[23:30] <TimToady> yes, well, 35 years head start will do that... :)

[23:30] *** kst left
[23:30] <TimToady> it was err back when we thought it was just a low precedence //

[23:30] <TimToady> then p5p got all hot and bothered that err should be dor

[23:30] <TimToady> "defined or"

[23:31] <TimToady> then I got all hot and bothered and said "Phooey, defined-or isn't what we wanted anyway"

[23:31] *** kst joined
[23:32] <sorear> I wonder if I could make a case for 'make' cloberring $/'s submatches

[23:32] <sorear> so, you either have an AST or a parse tree, but not both

[23:33] <TimToady> except that the parser often wants to peek into submatches to decide things

[23:33] <sorear> it does that before make, no?

[23:34] <TimToady> in any case, with viv, unless you use the -m switch, it doesn't keep match pointers in the AST, and you can just throw away the whole match tree at the end, and keep the AST

[23:34] <sorear> I'm more thinking about rakudo at this instant

[23:35] *** lestrrat is now known as lest_away

[23:35] <sorear> during the parse phase, rakudo generates a Match tree and a PAST tree

[23:35] <sorear> which are deeply intertwined

[23:35] <TimToady> yes, well, rakudo's memory problems are not caused by keeping matches around, in my estimation

[23:35] <sorear> what do you estimate they are caused by?

[23:35] <TimToady> parrot silliness

[23:36] <lue> can you blame them?

[23:36] <sorear> well, yes

[23:36] <lue> they're named after Monty Python, after all. :)

[23:36] <sorear> it's a joint effort

[23:36] <TimToady> I was named after Abraham Lincoln

[23:36] <sorear> our match trees wouldn't hurt so much if Parrot didn't have such a ludicrous object representation

[23:37] <TimToady> yes, well, I think in the long run it will turn out that PMCs were a bad idea

[23:38] <TimToady> I muttered about this at the beginning, but they told me to stay out of parrot internals...

[23:39] <TimToady> "we already know how you implement Perl, and we can do better"

[23:39] <lue> why not just define the types people want, and use classes for your own?

[23:39] <lue> I see your point, TimToady.

[23:39] <sorear> PMCs disgust me

[23:39] <sorear> I can't put a finger on the totality of why, though

[23:40] <sorear> but many little cuts

[23:40] <TimToady> confusion of containers with values, for one

[23:40] <sorear> yes

[23:40] <lichtkind> TimToady: thank you

[23:40] <sorear> absolutely

[23:40] <diakopter> you can never have too many object system layers; the taller the cake...

[23:40] <sorear> that has caused me no end of headaches

[23:40] <TimToady> the vtables stuff kinda turned out to be a premature optimization, I think

[23:40] <TimToady> like a CPU with heavy microcode

[23:40] <sorear> Parrot-land likes to think of Parrot as like a computer architecture

[23:41] <sorear> it has far too little policy

[23:41] <sorear> every HLL is expected to define its own ABI

[23:41] <sorear> cross-language calling is... tricky

[23:41] <TimToady> yes, that too, the inability to capture abstractions at a useful level

[23:42] <lue> further reason why Rakudo moving away from Parrot is a good long-term goal.

[23:42] <lue> 1. PMC's suck

[23:42] <lue> 2. Virtual Machines are slow

[23:43] <TimToady> well, 2 is arguable, depending

[23:43] <lue> On my computer, it's a bit faster than Java :/

[23:43] <TimToady> however, parrot isn't a very good counterargument to 2 yet :)

[23:43] <diakopter> depending whether it's bytecode JITted to machine code that calls into a runtime, or bytecode interpreted, and lots of other factors.

[23:44] <sorear> every machine you can usefully program is virtual, lue

[23:44] <sorear> even FPGAs are emulators

[23:44] <diakopter> lue: Java is near the top of most of the computer language shootout game benchmarks.. languages have their sweet spots, performance-wise.

[23:46] <TimToady> but VMs are usually optimized heavily for a particular environment, and tend to be lousy at off-brand performance

[23:46] <lue> On my old laptop though, virtual machine based languages have a huuge difference over ones that don't. (python, C, etc.)

[23:47] <TimToady> a fabulous JIT that targets *86 is pretty useless on a Power PC

[23:47] <diakopter> which python? and which C?

[23:47] <lue> so rakudo being off parrot would, for me, be very cool.

[23:47] <lue> Python 3. gcc

[23:48] <TimToady> gcc is pretty slow by modern standards

[23:48] <lue> TimToady: I ought to replace my G3 chip with a G4. I got this computer for free, so I'm keeping it.

[23:48] * diakopter is desperately trying to solve many problems I don't know exist, and some that I wrongly think exist, and some that I correctly know exist.

[23:49] <diakopter> (incl some of the above)

[23:49] <lue> I actually have a G4 chip, but that'd require desoldering on a two-sided circuit board :(

[23:49] <diakopter> lue: it's a pismo?

[23:50] <lue> Powerbook G3 Pismo, currently in use

[23:50] <TimToady> at least, according to http://clang.llvm.org/features.html#performance

[23:50] <TimToady> which is probably not an unbiased site :)

[23:50] <lue> I can buy a G4 chip for the pismo, all it requires is a simple out-and-in of the cpu "module".

[23:51] <Tene> lue: why do you say "abandon parrot" instead of "help fix parrot"?

[23:52] <lue> it's a virtual machine. I prefer to emulate as little as possible on my poor computer.

[23:52] <lue> I have to ssh to work on rakudo (when I do)

[23:52] *** SmokeMachine left
[23:53] <diakopter> lue: the fact that rakudo/parrot are slow is not due to parrot being a virtual machine

[23:53] <lue> .oO(once they get Mactel linux working, I really ought to invest in a shiny new mac laptop with Intel)

[23:53] <sorear> when you use a modern microprocessor, you're already sitting on a layer cake a mile high

[23:53] <lue> but I'm not, so there :P

[23:53] <diakopter> lue: ^^

[23:53] <sorear> "virtual machines are slow" is hopelessly naive

[23:53] <lue> they are! (on my computer)

[23:53] <sorear> there are some very interesting tradeoffs

[23:54] <sorear> your computer IS a virtual machine

[23:54] <sorear> why?  because PPC instructions take up less space than horizontal microcode

[23:54] <sorear> the cache win outweighs the emulation loss

[23:56] <lue> I don't care! A virtual machine at the user level is slow for me!

[23:58] <Tene> lue: *everything* is slow on your computer. ;)

[23:59] <lue> yes, but rakudo is slower than perl5, python, or anything else not virtually run :)

[23:59] <TimToady> now you're changing your argument

[23:59] <Tene> It's also slower than anything I haven't contributed code to.

[23:59] <pugssvn> r30559 | diakopter++ | [S06] fix Freudian slap toyp 

