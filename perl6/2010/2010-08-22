[00:00] <jnthn> lue: I should probably write a post explaining that a bit more some day. :-)

[00:00] <jnthn> lue: It's not a stupid question either, fwiw. It's a kinda esoteric area.

[00:00] <jnthn> lue: It kinda boils down to, consider "class Foo { method bar() { } }" and "role Foo { method bar() { } }".

[00:01] <jnthn> Those apart from the keywords look kinda similar.

[00:01] *** Psyche^ joined
[00:01] <jnthn> Then think along the lines of, "so what makes a class behave like I'd expect a class to, and a role to behave like I'd expect a role to?"

[00:02] <jnthn> Those semantics have to be implemented somewhere.

[00:02] <jnthn> In Perl 6, we have "meta-objects" which are objects that describe the behavior of other objects.

[00:02] <jnthn> So we have a "meta-class" (called ClassHOW) that describes how classes work.

[00:02] <jnthn> Those things are pretty much the meta-model.

[00:03] <jnthn> Plus dealing with issues like the API for adding new types of packages.

[00:03] <jnthn> And introspection.

[00:03] <jnthn> And meta-circularity (which is a fancy word for, we can re-use parts of the meta-model as it exists so far to define new things).

[00:04] <jnthn> Plus sometimes, making sure that it's introspectable "all the way down".

[00:04] * jnthn wonders if that explanation made any sense :-)

[00:04] <jnthn> lue: You may also find these slides interesting: http://www.jnthn.net/papers/2010-nlpw-metamodels.pdf

[00:05] *** Patterner left
[00:05] *** Psyche^ is now known as Patterner

[00:05] * TimToady is testing a patch to relax where's EXPR precedence limiter from %chaining to %item_assignment (can't be looser than that or we misparse defaults in sigs)

[00:06] <TimToady> I dunno why it was limited to tighter than %chaining

[00:06] <jnthn> TimToady: Nice, let me know how it works out.

[00:06] <jnthn> TimToady: I think it'd be an improvement, if it doesn't cause other issues.

[00:07] <TimToady> well, it's only an issue if it interferes with other signature components, but == shouldn't bother = defaults

[00:07] <jnthn> Shouldn't, no.

[00:07] <lue> "A Little Reflection on Metamodels" (next slide) "OH HAI!"  :)

[00:07] <jnthn> lue: Oh, those slides get worse.

[00:08] <jnthn> I can only conclude I'd found some REALLY great beer the week I wrote those. :-)

[00:09] *** sftp joined
[00:10] <lue> .oO(At least there are no business-style graphs)

[00:10] <jnthn> There actually are some graphs later :-)

[00:10] <jnthn> There's also a bad pun and a picture of a bear about to eat golfers, iirc.

[00:10] <lue> I would hate to eat a large Stroopwafel in Perl 6 :)

[00:12] <jnthn> ;-)

[00:12] <lue> .oO(apparently you think highly of stroopwafels. .oO(There needs to be someplace I can add annontations that don't cause an IRC flood))

[00:18] <lue> ah! I got to the politics pun!

[00:27] *** meppl left
[00:30] <pugssvn> r32080 | lwall++ | [STD] relax where expressions to only require tighter than item assignment 

[00:31] <jnthn> TimToady: Will do that in Rakudo tomorrow unless I'm beaten to it.

[00:31] <jnthn> TimToady++

[00:31] <jnthn> Now I can delete some parens from my slides too, for next time I give 'em. :-)

[00:32] <tylercurtis> TimToady++

[00:35] <jnthn> tylercurtis: I twiddled the STable a little today (additive changes). Know you borrowed it, dunno how close you're tracking it.

[00:38] <tylercurtis> jnthn: I haven't started on that bit in Bennu yet. I'm waiting until I better understand a few things. Also, I have to write a YAML parser before I can start on the rewrite anyway.

[00:38] <jnthn> tylercurtis: Aha, OK. :-)

[00:39] <jnthn> tylercurtis: Today I did a high-level project planny blog post, but I plan to make some more that explain the design somewhat.

[00:39] <jnthn> tylercurtis: Let me know if there's any area that's particularly unclear and I can try and do a post on it.

[00:43] <tylercurtis> jnthn: will do. I haven't read all of the prototype yet. Reading those slides you linked earlier was helpful(especially the bit about building meta-objects at compile time).

[00:43] <jnthn> tylercurtis: Yeah, that's going to be quite a big change for Rakudo.

[00:44] <jnthn> It's also something I can't do in the prototype really.

[00:44] <jnthn> Well, maybe it's doable with enough effort

[00:44] <jnthn> But it gets way easier if you can bootstrap.

[00:45] <jnthn> (On Parrot I already have the luxury of a bootstrapped nqp-rx...)

[00:45] <sorear> jnthn: when I started... there was much less overlap

[00:45] <jnthn> Oh, I guess I could look at a portable serialization format...

[00:46] <jnthn> But then I have to write a serializer from scratch and it'll just hurt.

[00:48] <lue> jnthn: good post

[00:49] <jnthn> lue: Thanks. :-)

[00:49] <lue> sometimes I feel I came in too late, and the only things left to do are big and complicated features, the kind of stuff that requires you to have experience in coding new features :D

[00:50] <sorear> lue: It would help if you tried to implement stuff that actually is specified..

[00:51] <sorear> me?  I thought optimization research, static metaobject analysis, vtables, representation polymorphism, gradual typing, and CLR embedding would be fun things that I could do and not immediately be rendered irrelevant by established folk like jnthn++

[00:53] <lue> Well, I suppose part of the problem is that I can't find some specific area to work on, so I end up finding random bits that, after looking into it, I can see why they haven't been implemented yet.

[00:55] <lue> .oO(although macros is something that keeps popping into my mind)

[00:59] <jnthn> sorear: I don't want to spoil your -Ofun. :-( All I've ever wanted to do since I joined in with Perl 6 compiler dev is make a great compiler for a really awesome language. I've been pondering refactorings to the object model to supprot some of those things for quite a while, and almost dug in before, before realizing that Rakudo wasn't quite ready for them, or that there were higher priorities from user's perspective.

[01:04] <jnthn> I'd figured that you were focusing on the CLR and optimization in a more general sense than object model stuff, e.g. on the regex engine side of things.

[01:05] <lue> .oO(I just found something unicode-related in the ROADMAP!)

[01:08] <sorear> no, it's not your fault... I think this place is just too popular

[01:24] *** test34 joined
[01:24] * jnthn takes some sleep, night all

[01:33] *** justatheory joined
[01:49] *** test34 left
[01:53] *** justatheory left
[02:10] *** mmmpork_ joined
[02:12] *** mmmpork left
[02:37] *** colomon joined
[02:40] *** Alias joined
[02:46] *** takadonet1 joined
[02:47] <takadonet1> hey everyone

[02:47] <sorear> hello

[02:48] <takadonet1> sorear: how are u?

[02:49] *** takadonet1 left
[03:03] *** fod left
[03:17] *** Italian_Plumber left
[03:24] *** sftp left
[04:32] *** azert0x left
[04:52] *** mmmpork_ left
[04:52] *** mmmpork joined
[04:54] *** shade_ left
[04:56] *** Lorn left
[04:57] *** Lorn joined
[05:12] <tylercurtis> phenny: ask jnthn Shouldn't Rakudo.Runtime.Ops.logical_not_int box the result into TC.DefaultBoolBoxType?

[05:12] <phenny> tylercurtis: I'll pass that on when jnthn is around.

[05:13] *** drbean joined
[05:28] *** achromic left
[05:30] *** envi^home joined
[05:50] *** shade_ joined
[05:53] *** barika left
[05:56] *** shade_ left
[06:00] *** shade_ joined
[06:06] *** shade_ left
[06:09] <risou_> どう考えてもあつい

[06:09] *** risou_ left
[06:12] *** [particle] left
[06:13] *** [particle] joined
[06:14] *** yahooooo left
[06:16] *** yahooooo joined
[06:16] *** xiaolongxia left
[06:17] *** xiaolongxia joined
[06:18] *** mmmpork left
[06:19] *** mmmpork joined
[06:21] *** shade_ joined
[06:36] *** lasse_ joined
[06:37] *** achromic joined
[06:54] *** shade_ left
[07:13] *** rang joined
[07:13] <rang> hi - is anyone updating: http://www.perlfoundation.org/perl6/index.cgi?articles_and_presentations  ?

[07:19] <sorear> doesn't look like it

[07:37] *** tylercurtis left
[07:46] *** Mowah joined
[07:46] *** Guest23195 joined
[07:50] *** mberends joined
[08:03] <rang> sorear: cheers - I've removed the link from http://dev.perl.org/perl6/

[08:03] <rang> just pointing to the wiki directly now

[08:05] <rang> ttfn

[08:05] *** rang left
[08:08] *** Eevee left
[08:11] *** Eevee joined
[08:16] *** zulon joined
[08:21] *** meppl joined
[08:26] *** ruoso left
[08:33] *** wamba joined
[08:43] *** ruoso joined
[08:45] *** Su-Shee joined
[08:48] <Tene> lue: Don't be too intimidated by macros.  They're definitely doable in Rakudo.

[09:03] *** zulon left
[09:08] *** shade_ joined
[09:09] *** szabgab left
[09:10] *** dju left
[09:14] *** szabgab joined
[09:15] *** drbean left
[09:20] <moritz_> in fact sorear had a proof of concept macro implementation for rakuo

[09:24] *** masak joined
[09:24] *** achromic left
[09:24] <masak> oh hai, #perl6

[09:24] <moritz_> oh hai

[09:24] *** shade_ left
[09:25] <moritz_> http://6guts.wordpress.com/2010/08/22/rakudos-meta-model-the-road-ahead/ interesting read, jnthn++

[09:26] *** zulon joined
[09:26] *** achromic joined
[09:26] <masak> ooh

[09:26] <moritz_> oom

[09:27] <masak> I liked http://blogs.perl.org/users/tyler_curtis/2010/08/age-discrimination-in-perl-6-using-subsets-and-multiple-dispatch.html as well.

[09:27] <masak> I'm starting to think Perl 6's whatever-currying syntax is a sort of gateway drug for people to start thinking naturally about closures.

[09:28] <masak> jnthn: you blog looks so much nicer than that last one you had, with the gray 90s background and the blocky 90s widgets! :/

[09:29] *** shade_ joined
[09:30] <masak> "Today in Rakudo, writing type annotations may make your program slower rather than faster, even though you give more information. I want to fix that." -- jnthn++

[09:30] <masak> both for the intent, and for the quote itself.

[09:32] <mberends> masak: good day! I've finally got a round tuit for our planned discussion, after you finish reading jnthn++'s article three times, as I have :)

[09:32] <masak> :)

[09:32] <masak> mberends: actually, I'm trying to make a very short visit here today. big exam on Tuesday. need to dive into big book with hidden clues in it.

[09:33] <mberends> oh. ok.

[09:33] <masak> mberends: what I can do, though, is send along the patch for you to look at.

[09:33] <mberends> ok2.

[09:33] <masak> and then we can talk on Wednesday :)

[09:33] <mberends> ok3.

[09:34] <masak> which do you prefer, email or gist?

[09:34] <mberends> masak: gist please

[09:34] <masak> http://gist.github.com/543580

[09:34] <mberends> masak: thanks, and good luck with the exam.

[09:35] *** Mowah left
[09:35] <masak> let me just say a thing about the intent of this patch: it is to make IO::Socket IO inherently Buffy. :)

[09:35] <masak> (instead of inherently Stringly, as it is now)

[09:35] <masak> (or should I say Strly)

[09:35] <mberends> good idea, I want to try getting WebSockets into a web server.

[09:36] <mberends> Buf will probably help

[09:36] <masak> mberends: the patch applies cleanly, apart from some tests which it *exposes* as being wrong in the first place.

[09:36] <masak> oha++

[09:36] <masak> mberends: I mainly wanted a second opinion from a downstream consumer before I applied this.

[09:37] <mberends> masak: I'll apply the patch and try the various webserver implementations. thanks.

[09:38] <masak> \o/

[09:38] <sorear> I need a new project

[09:38] <masak> sorear: I'd like for someone to write a real LTM gramamr engine.

[09:39] <masak> preferably in Perl 6.

[09:39] <sorear> conveniently, I already have one of those.

[09:39] <masak> :)

[09:39] <sorear> niecza: "fooo" ~~ / foo { say "A" } | fo* { say "B" } /

[09:39] <p6eval> niecza 1801379: OUTPUT«B␤»

[09:40] <masak> wow!

[09:40] <masak> sorear++

[09:42] <masak> seriously, someone write an FAQ page or blog post or wiki entry somewhere about how to input » on various systems: http://twitter.com/juanpabloaj/status/21805082345

[09:42] <masak> it's not that hard...

[09:43] *** mberends left
[09:43] * masak replies with the ways he knows

[09:43] <moritz_> compose > >  on linux

[09:43] <masak> what about Windows?

[09:43] <moritz_> or AltrGr x # on my machine

[09:43] *** shade\ joined
[09:43] <masak> right, something similar on Windows ISTR.

[09:43] <moritz_> (but it's some default, nothiing that i configured myself)

[09:45] *** shade\ left
[09:46] *** shade\ joined
[09:46] *** shade\ left
[09:46] *** shade\ joined
[09:50] <masak> tylercurtis++ made HN: http://news.ycombinator.com/item?id=1624027

[09:55] *** zulon left
[09:56] *** mberends joined
[09:58] <masak> and the HN discussion is lucid, open-minded and mostly friendly, much thanks to tylercurtis++ participating in it. impressive.

[10:03] *** shade_ left
[10:21] *** risou joined
[10:23] *** azawawi joined
[10:23] <azawawi> hi

[10:23] <azawawi> sorear: ping

[10:32] <sorear> I thought I handed you off to pmurias

[10:32] <sorear> pong

[10:33] <azawawi> sorear: ok i'll follow up with him then... cya :)

[10:34] <sorear> well, maybe it is my fault.

[10:35] <azawawi> anyway, STD is not working when trying a simple STD->parse()...

[10:35] <masak> sorear: what do you consider the performance of STD to be, compared to the fastest port of STD you can imagine?

[10:35] <masak> azawawi: I got it working in the backlog. hold on, I'll find it for you.

[10:35] <masak> azawawi: there's a trick to it.

[10:35] <azawawi> masak: ok

[10:36] <sorear> azawawi: you need to install a setting

[10:36] <masak> right.

[10:36] *** Italian_Plumber joined
[10:36] <sorear> try STD->parse("2", setting => "NULL")

[10:37] <masak> irclog.perlgeek.de is slow today... :/

[10:37] <sorear> there's a LTA error message for "setting not found"

[10:37] <azawawi> sorear: i know ... i was wondering why it is not part of the STD package...

[10:37] <sorear> (ironically, it was added to be user friendly)

[10:37] <masak> sorear: that's not very uncommon for ironically LTA error messages...

[10:38] <masak> s/ironically //

[10:38] <sorear> azawawi: the 'CORE.setting' in src/perl6 is the viv setting, and it doesn't make a whole lot of sense for general use

[10:38] <sorear> Syntax::Highlight::Perl6 could probably get away with it, but niecza and mildew can't

[10:40] <masak> why not?

[10:40] <azawawi> sorear: ok but what's the use of an STD package when STD->parse() doesnt work?

[10:43] <masak> there should be a big sign somewhere saying "you need a setting for this to work. batteries not included"

[10:45] <azawawi> that and im seeing a lot of uninitialized errors in CursorBase.pmc when parsing a wrong Perl 6 code.

[10:45] <azawawi> after installing the setting that is

[10:50] <sorear> that should never happen

[10:50] <sorear> what exactly are you doing and ow did you "install" the setting

[10:50] * moritz_ wonders why people always confuse warnings and error messages

[10:51] <masak> mberends: you're probably already on the Dancer mailing list, but today they're discussing building a Plack::Middleware::Websocket. seems very connected to what you want to do, except it's in Perl 5.

[10:51] <moritz_> maybe they aren't sufficiently distinct

[10:52] <masak> moritz_: maybe people haven't felt sufficient need to distinguish them in their heads. both signify something wrong with their programs.

[10:53] *** whiteknight joined
[10:53] <azawawi> sorear: I added a syml_search_path => ['parent-folder-of-syml/CORE.syml'] to STD->parse and installed syml/CORE.syml

[10:56] <sorear> What CORE.syml?

[10:56] <sorear> Like I said, there is no usable standard one

[10:57] <sorear> Any that you install is wrong

[10:58] <x3nU> is there changelog for latest rakudo?

[10:58] <sorear> git log is good enough for me

[10:58] <masak> rakudo: say (16 < * < 66)(5) # tylercurtis++ discovered this one, but didn't submit it as far as I can see

[10:58] <p6eval> rakudo 928836: OUTPUT«1␤»

[10:59] <moritz_> x3nU: docs/ChangeLog

[10:59] * araujo cannot understand women

[10:59] <masak> rakudo: say 16 < 5 < 66

[10:59] <p6eval> rakudo 928836: OUTPUT«0␤»

[10:59] * masak submits rakudobug

[10:59] <araujo> whoever asked here that wanted to have a gf .... I envy you

[10:59] * araujo wants to get back to his previous single-lonely life

[11:00] <masak> araujo: that can be arranged.

[11:00] <huf> or why not try a boyfriend?

[11:01] <araujo> masak, yeah, I will arrange that

[11:01] *** azawawi left
[11:02] <araujo> huf, will wait for AI to come

[11:02] <araujo> design your own android

[11:02] <araujo> that is the future

[11:02] <araujo> so hurry up with perl6 guys, it might be the answer

[11:03] <moritz_> hurrying is a good way to delay things

[11:03] <moritz_> araujo: but of course you can help make it happen faster

[11:04] <araujo> finally that bible thing about adam out of paradise and struggling for living is starting to make sense for me

[11:04] <araujo> moritz_, :)

[11:09] <masak> rakudo: sub foo($a) { True; }; subset Foo of Mu where -> $foo { foo($foo) }; say 5 ~~ Foo # also found and unreported by tylercurtis++

[11:09] <p6eval> rakudo 928836: OUTPUT«Could not find sub &foo␤  in <anon> at line 22:/tmp/NatSYeFo2Q␤  in 'Block::ACCEPTS' at line 5775:CORE.setting␤  in 'infix:<~~>' at line 402:CORE.setting␤  in <anon> at line 1:/tmp/NatSYeFo2Q␤  in 'Block::ACCEPTS' at line 5775:CORE.setting␤  in 'ACCEPTS' at line

[11:09] <p6eval> ..984:CORE.setting␤  …

[11:09] * masak submits rakudobug

[11:09] <masak> <pmichaud> probably the same one that caused (causes) roles to not see lexical subs.

[11:09] <moritz_> another fun not-in-the-right-lexical-context bug

[11:09] <masak> right.

[11:10] <moritz_> they seem to be quite a problem in rakudo

[11:10] <masak> I haven't figured out a model that works in my head either.

[11:11] <masak> how *do* the inner workings of a metaoperator see a lexical user-defined operator, for example?

[11:13] <moritz_> masak: [+]  desugars to reduce_helper(&infix<+>, @args) or so

[11:13] <moritz_> masak: so it just gets a reference to a routine (or multi), which it calls

[11:14] *** redicaps joined
[11:14] *** redicaps left
[11:22] <masak> moritz_: right, but the desugaring takes place in a lexical scope unrelated to that of the user's script. so how can the desugaring code "see" the user's 'my'-declared operator sub?

[11:22] *** rokoteko joined
[11:23] <moritz_> masak: the "desugaring" is the process of compiling [+]. That inserts the helper code in lexical scope of the user script

[11:23] <moritz_> in rakudo, that's roughly

[11:24] <moritz_> PAST::Op.new(:pirop('call'), '&reduce_helper', Past::Var.new(:name('&infix:<+>), :scope('&lexical')), @args)

[11:24] <masak> ah, with the desugaring taking place at parse time, I get it. thanks.

[11:25] <moritz_> if it were not parse time, I'd need lift()

[11:27] <moritz_> s/I/It

[11:28] <moritz_> rakudo: my $x = 5; subset A of Int where { $_ < $x }; say 2 ~~ A

[11:28] <p6eval> rakudo 928836: OUTPUT«Null PMC access in can()␤  in <anon> at line 1:/tmp/DDVdqI7ocJ␤  in <anon> at line 22:/tmp/DDVdqI7ocJ␤  in 'Block::ACCEPTS' at line 5775:CORE.setting␤  in 'infix:<~~>' at line 402:CORE.setting␤  in <anon> at line 1:/tmp/DDVdqI7ocJ␤  in 'Block::ACCEPTS' at line

[11:28] <p6eval> ..5775:CORE.setting␤  i…

[11:29] <moritz_> I'm so sure that worked once

[11:29] * masak submits rakudobug

[11:29] <masak> I also think it worked once.

[11:30] <masak> rakudo: my $x; subset A where { $x }; 2 ~~ A; say "alive"

[11:31] <p6eval> rakudo 928836: OUTPUT«alive␤»

[11:31] <masak> rakudo: my $x; subset A where { $_ < $x }; 2 ~~ A; say "alive"

[11:31] <p6eval> rakudo 928836: OUTPUT«Null PMC access in can()␤  in <anon> at line 1:/tmp/lqVft7Zeo5␤  in <anon> at line 22:/tmp/lqVft7Zeo5␤  in 'Block::ACCEPTS' at line 5775:CORE.setting␤  in 'infix:<~~>' at line 402:CORE.setting␤  in <anon> at line 1:/tmp/lqVft7Zeo5␤  in 'Block::ACCEPTS' at line

[11:31] <p6eval> ..5775:CORE.setting␤  i…

[11:31] <masak> rakudo: my $x; subset A where { $_ }; 2 ~~ A; say "alive"

[11:31] <p6eval> rakudo 928836: OUTPUT«alive␤»

[11:31] <masak> rakudo: my $x; subset A where { say $x }; 2 ~~ A; say "alive"

[11:31] <p6eval> rakudo 928836: OUTPUT«Could not find sub &say␤  in <anon> at line 22:/tmp/9mQi5DLi64␤  in 'Block::ACCEPTS' at line 5775:CORE.setting␤  in 'infix:<~~>' at line 402:CORE.setting␤  in <anon> at line 1:/tmp/9mQi5DLi64␤  in 'Block::ACCEPTS' at line 5775:CORE.setting␤  in 'ACCEPTS' at line

[11:31] <p6eval> ..984:CORE.setting␤  …

[11:31] <masak> ah :)

[11:33] <colomon> rakudo: my sub infix:<++++>($a, $b) { -$a + $b }; say [++++] 1, 2, 3, 4

[11:33] <p6eval> rakudo 928836: OUTPUT«===SORRY!===␤Could not find sub &infix:<++++>␤»

[11:34] <colomon> rakudo: our sub infix:<++++>($a, $b) { -$a + $b }; say [++++] 1, 2, 3, 4

[11:34] <p6eval> rakudo 928836: OUTPUT«2␤»

[11:36] *** zulon joined
[11:36] <moritz_> that's unfortunate :/

[11:37] <masak> now that moritz_ has explained the simple desugaring process, I don't understand why the error occurs... :)

[11:37] <masak> it's just a simple lexical lookup in the same scope, no?

[11:37] <colomon> I don't think moritz_'s explanation is actually correct

[11:37] <moritz_>                 PAST::Op.new( :pirop('find_sub_not_null__Ps'), $base_op ),

[11:38] <moritz_> does that look into lexical scopes too?

[11:39] <colomon> but I may be wrong on that, too.  :\

[11:40] <moritz_> colomon: do you think it's not what happens now, or not what's supposed to happen?

[11:40] <colomon> okay, the first problem (which may not actually affect this one) is that it's generating the code for the metaop that way.

[11:41] <colomon> so basically, the first time you call [+], it generates a new [+] sub which does the reducewith call.

[11:41] <colomon> so if you later define a new infix:<+> and then call [+] wanting to use it, you definitely do NOT get the lexical scope at that point.

[11:41] <colomon> may very well be that you never get the correct lexical scope.

[11:41] <moritz_> then that design is flawed

[11:42] <colomon> my guess (based on watching these things happen) is that you never get the correct lexical scope.  But that's strictly a guess.

[11:43] <colomon> I certainly agree that it's not supposed to work that way.

[11:43] <masak> jnthn: http://www.jnthn.net/papers/2010-nlpw-metamodels.pdf is AWESOME! massive kudos!

[11:43] * masak can't believe he missed that one till now

[11:46] <masak> num &

[11:46] <masak> er, *nom

[12:12] *** molaf joined
[12:17] *** molaf left
[12:23] *** cogno joined
[12:30] *** azert0x joined
[12:37] *** Italian_Plumber left
[12:37] <jnthn> morning, 6folk

[12:37] <phenny> jnthn: 05:12Z <tylercurtis> ask jnthn Shouldn't Rakudo.Runtime.Ops.logical_not_int box the result into TC.DefaultBoolBoxType?

[12:39] <jnthn> masak: I only gave it once and had a lot of fun doing so...maybe I should do it again some day. :-)

[12:41] <moritz_> jnthn: is there a good reason for caching things like prefix [+] ?

[12:42] <moritz_> it seems to mess up things when there are lexical ops

[12:43] <jnthn> moritz_: Mostly it means that we can just generate the op calls as normal calls to &prefix:<[+]> 

[12:43] *** drbean joined
[12:44] <jnthn> I think the lexical issue is a more general one fwiw.

[12:44] <jnthn> Though yes, we could do the meta-ops differently to avoid the issue.

[12:44] <moritz_> do we gain anything from it? the logic for calling reducewith with the right arguments is already in there

[12:44] <jnthn> Feel free to try out a non-caching version.

[12:44] *** cogno left
[12:44] * moritz_ does

[12:44] <jnthn> I'm not especially attached to it.

[12:44] <jnthn> It just made code-gen a bit easier.

[12:44] <moritz_> $ ./perl6 -e 'multi sub infix:<+++>($a, $b) { $a + $b }; say [+++] 1, 2'

[12:44] <moritz_> 3

[12:44] <moritz_> works when I remove the cache

[12:45] <moritz_> let's see what spectest has to say

[12:45] <jnthn> And when instead of emitting the op you emit the call?

[12:45] <jnthn> Rather than currying it?

[12:45] *** wamba left
[12:45] <jnthn> I guess it'd work.

[12:47] <moritz_> that's what I'm trying now

[12:47] <moritz_> it's nearly only deleting code

[12:47] <moritz_> ... and breaks some tests .(

[12:48] <moritz_> ah, we need the cache for combining it with other meta ops

[12:48] <moritz_> unless we tweak their codegen too... not sure if that works

[12:49] <jnthn> Yes, you may need to refactor the bunch.

[12:51] <moritz_> huh

[12:51] <moritz_> my @result = [~]«( <a b> X, <1 2> );

[12:53] <moritz_> which colomon++ commented with #?rakudo todo "Not at all clear if this test is correct or not"

[12:54] <jnthn> OK, that just makes me want more coffee. :-)

[12:55] <moritz_> if that's the only test that breaks, I'll consider s/todo/skip/

[12:56] *** cogno joined
[12:57] <colomon> have you considered nested metaops?

[12:57] <jnthn> I'd hope we have tests for those... :-)

[12:57] <colomon> I'm not sure if it's a problem with [op], but it's an issue in general with this approach

[12:58] <cogno> Limechat++ # irc on the go

[12:58] <jnthn> But yes, there was a sense in that what we have now gets the nesting right by just passing in higher order function references.

[13:00] <moritz_> colomon: yes, those are a problem

[13:00] <colomon> the specific case to worry about (I think) is what happens to [R-] if R- no longer generates a R- sub.

[13:00] <moritz_> hm

[13:00] <colomon> though can you use [op] in a hyper-op?  then you'd run into the same issue here.

[13:00] <colomon> afk

[13:01] <moritz_> maybe we can make all the helper subs always return closures

[13:01] <moritz_> and emit a call to it in the end

[13:02] <jnthn> moritz_: Yes, it'd need to be something like that.

[13:02] <colomon> won't a closure have the same lexical issues?

[13:02] <colomon> afk for real

[13:02] <jnthn> moritz_: Or just .assuming everything apart from the "top" one in the chain, which you just call.

[13:02] *** dju joined
[13:03] <moritz_> hm

[13:04] <moritz_> remains the question of how to find out which one is the top one, at compile time

[13:04] <jnthn> Yes. :-)

[13:05] <moritz_> currently we have only one test for a reduce meta op being used by another meta op

[13:05] <moritz_> and that is borked :-)

[13:06] <dalek> 6model: 03bf0be | jnthn++ | dotnet/runtime/Runtime/Ops.cs:

[13:06] <dalek> 6model: Fix a nit noticed by tylercurtis++.

[13:06] <dalek> 6model: review: http://github.com/jnthn/6model/commit/03bf0be6ec408730d623426efc60c2100be75c0d

[13:06] <dalek> 6model: b4f8465 | jnthn++ | dotnet/runtime/Metamodel/SharedTable.cs:

[13:06] <dalek> 6model: Fix a jnthn-- fail.

[13:06] <dalek> 6model: review: http://github.com/jnthn/6model/commit/b4f8465a438cb1de86e110d7968d46aa050a2732

[13:07] *** dju left
[13:08] *** dju joined
[13:09] *** orafu left
[13:09] *** orafu joined
[13:12] *** sftp joined
[13:15] *** sftp left
[13:21] *** cogno left
[13:31] *** lala joined
[13:33] <lala> Other Syntax for Calling by Name

[13:33] <lala> http://cloud.github.com/downloads/perl6/book/book-2010-04.pdf

[13:33] <moritz_> don't look at the PDF from April - take a newer one

[13:33] <lala> announce-time(dinner => '9pm'); the '>' appearing as an upside down question mark

[13:35] <moritz_> we do fix bugs sometimes. Which is why it's worth to look at a newer version.

[13:36] <lala> i was going to play with it abit, but I couldn't find any examples of using event loops or tcp sockets 

[13:36] *** Colb-Seton joined
[13:37] <lala> was an eventloop like libevent etc decided on?

[13:37] <moritz_> I think the plan is to implement eventloops with feeds

[13:42] <lala> i'd love to see code cleaner using events, right now my code imports a C library, and its just a big mess of functions calling functions never going back to main

[13:46] *** cogno joined
[13:49] *** dual left
[13:54] <lala> in perl5 the socket connects were not truely non blocking i had to set socket to non blocking then manually use connect($sock, $saddr) to get it to work

[13:56] *** cogno left
[14:02] *** Colb-Seton left
[14:04] *** guidj0s joined
[14:04] <guidj0s> Hi guys.

[14:05] <guidj0s> Im excited about perl6, but why the change in the ternary operator?

[14:11] *** Mahmoud joined
[14:11] <Mahmoud> I don't get why do we need Perl6

[14:12] <lala> I asked myself that question alot as well, but it seems we can compile our source code, that will be main reason i think

[14:13] <lala> be nice not to have to install 50 modules to put program on another box

[14:14] <Mahmoud> aren't there existing languages that already do so

[14:14] <Juerd> guidj0s: Because ? and : could be used so much better

[14:14] <guidj0s> Juerd: oh... ok

[14:14] <Juerd> guidj0s: And it gave the nice opportunity to change it to something more consistent throughout the language: ? is the opposite of !, which negates. Now we get ?? and !! for if-true and if-false of the ternary.

[14:14] <jnthn> guidj0s: Several reasons, of those I remember: ! had a clear association with negation, signle characters were felt a bit too flimsy for control flow operators, and I think partly that because : is used to mean quite a few other things in Perl 6, it might have caused some parsing-y trickiness.

[14:15] <Juerd> And it looks a bit more consistent with && and ||

[14:15] <guidj0s> Juerd: yeah, i was reading some Perl6 documentation, and I saw the change, that's what made me ask here

[14:16] <moritz_> guidj0s: another reason is that having single characters for control is a bit a hard to read, they can easily be overloooked

[14:16] <Juerd> jnthn: Maybe the documentation should be grouped per codepoint ;)

[14:16] <jnthn> Mahmoud: I think you just made an argument against ever making anything that does something better than a tool that already exists today... :-)

[14:16] <moritz_> Mahmoud: Perl 6 unifies a lot of concept that aren't present in this combination in other language

[14:16] <Juerd> jnthn: ":", U+003A, COLON: Used in the following operators: (...)

[14:16] <moritz_> Juerd: actually I have long planned such a project

[14:17] <jnthn> Juerd: http://www.perlfoundation.org/perl6/index.cgi?witch

[14:17] <moritz_> Juerd: and I started to write some documentation for it too

[14:17] <Juerd> Oh my :)

[14:17] *** Sarten-X2 is now known as Sarten-X

[14:17] <Juerd> I thought I was being silly but that actually looks useful.

[14:17] <guidj0s> is there any idea when Perl6 is coming out?

[14:17] <Juerd> http://www.perlfoundation.org/perl6/index.cgi?witch_colon

[14:18] <guidj0s> i was just starting to delve into more advanced Perl 5 usage...

[14:18] <jnthn> Mahmoud: Seriously though, Perl 6 does have various new things to offer. See for example grammars and junctions.

[14:18] <guidj0s> and the stuff I was learning seems to be about to disappear

[14:19] <moritz_> "coming out" is a process

[14:19] <jnthn> guidj0s: Perl 5 is most certainly not going to disappear. :-)

[14:19] <moritz_> which is in progress

[14:19] <guidj0s> jnthn: what do you mean?

[14:19] <Juerd> guidj0s: Knowing multiple languages will give you a more solid understanding of programming in general.

[14:20] <lala> if your talking about production i'd stick to perl5 till perl6 has enough cpan modules to make life easier, and I'm guessing that will take 2 years

[14:20] <Juerd> Sometimes learning differences is more effective than learning specific aspects of a single language.

[14:20] <jnthn> guidj0s: Perl 6 "coming out" will not mean Perl 5 development ceases, or that people who are using Perl 5 will all suddenly stop doing so and use Perl 6 instead. :-)

[14:20] <guidj0s> mmmkay...

[14:20] <Juerd> Where will it come out from?

[14:20] <Juerd> s/from/of/

[14:21] <guidj0s> I just feel a tad bit insecure because something I like in Perl (5) is the fact that it's not completely abstract....

[14:21] <guidj0s> i.e., you build complex data structures out of very fundamental ones

[14:21] *** sftp joined
[14:22] *** risou_ joined
[14:22] <guidj0s> I just like how you build big things out of just scalars, lists and references to them.

[14:24] <guidj0s> which just seems likely to disappear in Perl 6

[14:24] <Juerd> You'll still be able to do all the same things

[14:24] <jnthn> rakudo: my @people = { name => 'jnthn', likes => 'beer' }, { name => 'masak', likes => 'strange loops' }; say "@people[0]<name> likes @people[0]<likes>"; # you still can in Perl 6.

[14:24] <Juerd> And often even in the same way, even if the underlying techniques change.

[14:24] <p6eval> rakudo 928836: OUTPUT«jnthn likes beer␤»

[14:24] <moritz_> jnthn++ # nice example

[14:25] *** risou left
[14:25] <moritz_> perl 5 only needed references for nested data structures because arras and hashes can only hold scalars

[14:25] <guidj0s> are there lots of changes in the way references are treated?

[14:25] <jnthn> rakudo: my @people = { name => 'jnthn', likes => 'beer' }, { name => 'masak', likes => 'strange loops' }; for ^people -> { say "@people[$i]<name> likes @people[$i]<likes>"; } # :-)

[14:25] <moritz_> that limitation is gone

[14:25] <p6eval> rakudo 928836: OUTPUT«===SORRY!===␤Missing block at line 22, near ""␤»

[14:25] <jnthn> grr!

[14:25] <Juerd> guidj0s: Yes. References are gone.

[14:25] <guidj0s> %somehash{name} actually calls name() now, doesnt it?

[14:25] <jnthn> rakudo: my @people = { name => 'jnthn', likes => 'beer' }, { name => 'masak', likes => 'strange loops' }; for ^@people -> $i { say "@people[$i]<name> likes @people[$i]<likes>"; } # :-)

[14:25] <guidj0s> Juerd: oh man

[14:25] <p6eval> rakudo 928836: OUTPUT«jnthn likes beer␤masak likes strange loops␤»

[14:25] <Juerd> guidj0s: Don't let it scare you :)

[14:25] <moritz_> actually not quite true

[14:26] <moritz_> everything is a reference, more or lesss

[14:26] <moritz_> it's just that explicit usage of references is gone

[14:26] <guidj0s> i just dont want my sweet lovely perl to turn into java :(

[14:26] <jnthn> guidj0s: See the exmple I just ran. Note that you can have an array of hashes just like in Perl 5. The only difference is that when you go to access the data, you don't have to write -> any more.

[14:26] <guidj0s> jnthn: i noticed.

[14:27] <guidj0s> how about closures though?

[14:27] <Juerd> guidj0s: my $closure = { say "Hello, $world!" };

[14:27] <jnthn> rakudo: my $x = { say "oh hai I'm a closure" }; $x();

[14:27] <p6eval> rakudo 928836: OUTPUT«oh hai I'm a closure␤»

[14:27] <guidj0s> $closure calls it?

[14:27] <guidj0s> or $closure()?

[14:27] <jnthn> $closure()

[14:27] <moritz_> or .() if you prefer

[14:27] <guidj0s> ah, nice.

[14:27] <Juerd> $closure.() or $closure();

[14:27] <Juerd> s/;//

[14:28] *** tadzik joined
[14:28] <tadzik> oh hello

[14:28] <Juerd> O hai

[14:28] <jnthn> ahoj, tadzik 

[14:29] <guidj0s> thanks guys, i needed the comforting

[14:29] <guidj0s> guess i shouldn't be scared of change :P

[14:29] <lala> you like new pussy don't you?

[14:29] <guidj0s> lala: im quite happy with my girl man ;)

[14:30] <guidj0s> think ill like new perl though :P

[14:30] <jnthn> "Perl 6. It's a new pussy."

[14:30] <Juerd> p6ssy

[14:31] <guidj0s> how deeply is L.W. involved in the making of Perl 6?

[14:31] <moritz_> hey, we're supposed to be a family frindly channel

[14:31] <moritz_> guidj0s: as deep as possible

[14:31] <jnthn> moritz_: wtf, I was thinking of lolcats!

[14:31] <Juerd> guidj0s: Deeper does not exist.

[14:31] <guidj0s> nice.

[14:31] <gfldex> rakudo: say "purr";

[14:31] <p6eval> rakudo 928836: OUTPUT«purr␤»

[14:31] <guidj0s> btw, anybody here got pumpking status? :)

[14:31] <Juerd> guidj0s: He's known as TimToady here, though :)

[14:32] <tadzik> oh, new faces

[14:32] <guidj0s> awesome :|

[14:32] <Mahmoud> any plans to make perl 6 faster than perl 5

[14:32] <moritz_> guidj0s: pmichaud is the Rakudo pumpking

[14:33] <moritz_> Mahmoud: we'll make it as fast as we can

[14:33] <guidj0s> nice.

[14:33] <tadzik> Mahmoud: it's alredy happening, rakudo 2010.08 is like 2-20 times faster than the last release

[14:33] *** drbean left
[14:34] <guidj0s> i would've thought the heavt object orientation would have made it at least a little bit slower...

[14:34] <guidj0s> heavy*

[14:34] <guidj0s> awesome though.

[14:34] <Juerd> guidj0s: Slower than what?

[14:34] <Mahmoud> i read that perl 6 can't get faster than perl 5

[14:34] <gfldex> guidj0s: as slow as c++?

[14:34] <lala> more syscalls that necessary you mean

[14:34] <Juerd> lala: OO does not involve system calls.

[14:34] <tadzik> Mahmoud: where?

[14:34] <guidj0s> Juerd: than Perl 5

[14:35] <Juerd> guidj0s: For now, it still is.

[14:35] <guidj0s> at least its initial versions

[14:35] <Mahmoud> tadzik, youtube comment http://www.youtube.com/watch?v=ZKmUZVKIdKg

[14:35] *** s1n joined
[14:35] <tadzik> Mahmoud: oh come on, please

[14:35] <Mahmoud> heh

[14:35] <Juerd> guidj0s: Everyone hopes to see it get faster, though!

[14:35] <guidj0s> yeah.

[14:35] <Mahmoud> 2-20 times faster is really good

[14:35] <guidj0s> i just love Perl man. I want it to kick ass and you freaks usually manage to make it do it.

[14:35] <Juerd> 20?

[14:35] <tadzik> Mahmoud: don't say you took this troll seriously :)

[14:36] <gfldex> yes, it was that slow :)

[14:36] <lala> Well if we can compile our programs on a unix box, then just ftp it over to another one and use it i;m all for it, however wouldn;t there be issues if something was compile on linux vs freebsd vs solaris?

[14:36] <tadzik> Juerd: one of my tests ran 20 times faster, yes

[14:36] <tadzik> it consisted mainly of iterating and adding Nums :)

[14:37] *** blogometer joined
[14:37] <jnthn> guidj0s: For what it's worth, the new OO syntax being more declarative actually provides more information to the compiler. Once we have a compiler that knows how to make good use of that information, we've a good chance of being able to do OO stuff pretty fast in the common cases.

[14:37] *** blogometer left
[14:38] <tadzik> jnthn: sounds interesting to me. How can a compiler benefit, and from what?

[14:39] <guidj0s> jnthn: I just figured the compiler would have to change so much

[14:40] <guidj0s> jnthn: and I'm thinking that Perl 5's constant improvement since 1987 is one friggen good reason why it's fast :)

[14:40] <jnthn> tadzik: For example, consider class Beer { has $!name; has $!type; method describe() { say "$!name is a $!type" } }

[14:41] <jnthn> tadzik: We're not committing to any particular storage strategy for the attributes here.

[14:41] <jnthn> tadzik: They're also private to the class.

[14:41] <lala> well if we go overboard on having to declare every variable as a float int or whatever, then we're no better than c/c++

[14:41] <gfldex> lala, you imply that you have to provide types

[14:42] <gfldex> you further imply that you cant have dynamic types in c/c++

[14:42] <jnthn> tadzik: So we could choose to just have a chunk of memory where we store them in our object.

[14:42] <gfldex> you can but nobody is using it, because the syntax is so ugly

[14:42] <jnthn> tadzik: And then look them up using offsets.

[14:42] <tadzik> jnthn: like a structin C?

[14:42] <jnthn> tadzik: Yes

[14:42] <tadzik> s/tin/t in/

[14:43] <tadzik> jnthn: how is it different from other languages?

[14:43] <jnthn> tadzik: It's not different from a lot of languages. It is a change from Perl 5, for example, where a lot of storage is based on hashes, so an attribute lookup = a hash lookup.

[14:44] <tadzik> oh, so it's just different from Perl 5's approach?

[14:44] <gfldex> tadzik: it _can_ be different but don't has to

[14:44] <jnthn> tadzik: Well, and probably some other dynamic languages.

[14:44] <guidj0s> is there any change on hashes' implementation?

[14:45] <lala> One thing I do hate about google is they are favoring python, I read this compiler will work with both languages, meaning we may even be able to write programs for android etc that has python support down the road if this is the case

[14:45] <tadzik> gfldex: yep, I know that

[14:45] <jnthn> tadzik: The important thing is that we're not locked into just one way of representing objects.

[14:45] <tadzik> lala: is liking a language a reason to hate?

[14:45] <moritz_> guidj0s: Perl 6 is a specification. The internals can be wildly different from Perl 5

[14:46] <guidj0s> moritz_: then i guess i uderstand, even if feebly, how much work you guys are doing

[14:47] <lala> tadzik: your always going to favor the language your know the most in

[14:47] <tadzik> lala: maybe. Then why do you hate google? :)

[14:47] <lala> should be interesting moving forward to mod_perl etc

[14:48] <Mahmoud> if mod_perl6 is limited like mod_php, we would see more of it in shared webhosts env

[14:48] <Juerd> Mahmoud: Embedding into Apache isn't necessary for serving web pages.

[14:48] <Juerd> Mahmoud: FastCGI is a much better approach, and easier to implement

[14:49] <lala> tadzik: i hate them mostly because i envisioned their company something out of the terminator movies, only thing they have left for world dominance is creating their own windows OS

[14:49] <lala> i had a dream where its going to be hackers vs google one day

[14:50] <tadzik> lala: that's one of the reason I avoid using their products. But that doesn't matter, I was just curious about your python point

[14:51] <guidj0s> I've heard google sticks with python for hystorical reasons

[14:51] <Juerd> hysterical

[14:51] <guidj0s> because they started using it on a time when it was a good choice, and now they've just too much in it to port to other languages (PERL!)

[14:52] <guidj0s> kinda like COBOL

[14:52] <Juerd> guidj0s: You make it sound like Google uses *only* Python. They use a whole lot of languages.

[14:52] <guidj0s> Juerd: sorry, I didnt mean that. I meant they use "a lot of" 

[14:52] <lala> they favor python look at all their new programming API's from last few months, java, python 

[14:53] <Juerd> A company can have its prefenences

[14:53] <gfldex> google serves the masses

[14:53] <gfldex> i can't see what would be wrong about that :->

[14:53] <lala> i looked at that language, i didn't like its code at all

[14:55] *** mikehh_ joined
[14:56] <guidj0s> gfldex: if you wanna make money, you have to.

[14:56] *** mikehh left
[14:58] *** sftp left
[14:58] <gfldex> guidj0s: like rolls-royce?

[14:59] *** _twitch joined
[14:59] <guidj0s> gfldex: I didnt know Google was in the auto industry

[14:59] <_twitch> hi guidj0s 

[14:59] <guidj0s> heya

[14:59] <_twitch> hi god of perl

[14:59] *** sftp joined
[14:59] * _twitch wonders which one the god of perl is..

[14:59] *** tohen joined
[15:00] <lala> fucked up articles in last few days, of how a guy hacked into a guys car on the freeway through his tire pressure guage and took over his brakes, engine etc

[15:00] <_twitch> hey tohen 

[15:00] <tadzik> you know why python has so much whitespace in it?

[15:00] <tohen> sup ;]

[15:01] <_twitch> not much

[15:02] <guidj0s> Juerd: I expect there are big changes to globs and the way we manipulate them?

[15:02] <lala> lets face it biggest reason we all use these type of languages is because it would take us 10 times as long to do it in low level language, and we prefer not working on same shit all the time

[15:04] *** dual joined
[15:04] <guidj0s> lala: you forgot to mention worrying about endianness and the other gazillion aspects that differ from architecture to architecture.

[15:04] *** masak left
[15:04] <pmichaud> good morning, #perl6

[15:05] <guidj0s> heya

[15:05] <tadzik> 'afternoon pmichaud 

[15:05] *** macroron joined
[15:06] <_twitch> hello pmichaud 

[15:06] *** justatheory joined
[15:06] <jnthn> hi, pmichaud 

[15:08] *** risou_ left
[15:11] <lala> guidj0s: I guess it depends what your purpose is, I guess if you want to be on top end of programming you have no choice but to use c++ or some language you can make nice GUI programs/games for windows, but alot more focus on web based stuff than that, I would love to see game programming one day in a higher language with self-installers etc

[15:12] <tohen> lala, does GameMaker count? :[

[15:13] <lala> yeah well i doubt gamemaker could make something liek WOW, or final fantasy

[15:13] <tohen> you have a fair point there

[15:13] <mberends> hi pmichaud, I've just run test_summary.pl and have the "'plan *;' could become 'plan 101;'" output before me. I'm thinking of putting the actual test counts into the spectests in Synopsis-sized batches. Is that ok with you?

[15:17] <pmichaud> mberends: I'm okay with it... but based on discussion yesterday I'm not sure it'll be needed, unless we're aiming to get "really accurate" spectest sizes

[15:18] <mberends> I just hope to improve what we've got a little. 97% accuracy would be nice.

[15:19] <lala> hey on an interesting note: game developpers now have the highest divorce rate, sleeping/eating/breathing a game until completion

[15:19] <pmichaud> mberends: sounds great, then :-)

[15:21] <guidj0s> does Benchmark work for Perl 6?

[15:21] <Juerd> guidj0s: Typeglobs? I'm not sure if Perl 6 even has those.

[15:22] <guidj0s> Juerd: hmmm, ok

[15:22] <Juerd> I can't remember having heard of globs in Perl 6 context.

[15:22] <guidj0s> me neither, that's why I asked here tbh :)

[15:24] <tadzik> guidj0s: no one knows, it has no tests

[15:25] <tadzik> guidj0s: here http://tjs.azalayah.net/ser.html are some (a bit old) tests results for everything from modules.perl6.org

[15:48] *** cogno joined
[15:50] <jnthn> TimToady: proto lol($x) { * }; multi lol(Int $x) { 1 }; { multi lol(Str $x) { 2 } }; say lol("cat") # error, or 2? Under the current model, it's an error. Under my first cut implementation at the moment, we go looking for a proto to associate the multi with and just give it to the candidate list that proto will manage, so it'd print 2.

[15:50] <jnthn> TimToady: er, where "the current model" = what Rakudo implements

[15:51] <jnthn> TimToady: And "my first cut implementation" is my first crack at trying to do the new style multi-dispatch in 6model.

[15:51] *** fod joined
[15:52] <dalek> 6model: bfac235 | jnthn++ | dotnet/ (2 files):

[15:52] <dalek> 6model: Build signature objects a bit later. This will allow us to add type information to them.

[15:52] <dalek> 6model: review: http://github.com/jnthn/6model/commit/bfac235756a313fd14101488cc17e59463e2b3ec

[15:54] <jnthn> pmichaud: nqp-rx parses proto-regexen specially rather than falling through multi_declarator rule to get to them. Deliberate or just hysterical raisons?

[15:56] <pmichaud> jnthn: deliberate

[15:56] <jnthn> pmichaud: OK

[15:56] <pmichaud> jnthn: at least, at the time it was deliberate.  it might be possible to work with them falling through.

[15:57] *** justatheory left
[15:57] <jnthn> pmichaud: I've no immediate need to seek unification, just noticed it and got curious.

[15:57] *** Guest23195 left
[15:57] <pmichaud> it's very likely fossil, now that I think of it.  Until bacek++ did multis for nqp, we didn't even have a multi_declarator rule, I don't think.

[15:57] <jnthn> pmichaud: Yes, that's my guess too.

[15:58] *** masak joined
[15:58] <jnthn> pmichaud: How do proto-regexes find all of their variants today, btw?

[15:58] <pmichaud> when a protoregex is invoked, it introspects the class to find all of the methods in the protoregex

[15:58] <jnthn> OK

[15:58] <pmichaud> (and caches that information)

[15:58] <jnthn> I'm looking at a push model rather than a pull model at the moment.

[15:59] <pmichaud> ...push model?

[15:59] <jnthn> That is, add_multi_method goes looking for a proto that the candidate can be associated with.

[15:59] <jnthn> And associates it.

[15:59] <jnthn> Rather than the proto going looking down the tree for candidates.

[15:59] <pmichaud> I'm not sure that quite works for regexes.  

[15:59] <jnthn> Oh

[15:59] <jnthn> It may not for methods either

[15:59] <jnthn> Hmm.

[15:59] <jnthn> No, it probably doesn't. :-(

[16:00] <pmichaud> (will have to depart shortly)

[16:00] <jnthn> I do think the multi variants maybe want to live in a separate place in the meta-object than everyday methods.

[16:01] <jnthn> I'll see how things work out.

[16:02] *** cogno left
[16:02] *** justatheory joined
[16:03] *** Su-Shee left
[16:09] *** tylercurtis joined
[16:09] *** tohen left
[16:10] <tylercurtis> masak: thanks for reporting those.

[16:10] * tylercurtis forgot.

[16:10] <masak> no prob.

[16:15] *** Mahmoud left
[16:23] *** tylercurtis left
[16:25] *** tylercurtis joined
[16:25] *** zulon left
[16:28] <masak> lala, guidj0s: hi, new kids on the block!

[16:29] <guidj0s> masak: heya ;)

[16:29] <masak> just wanted to say that I enjoyed reading your questions, and their answers.

[16:29] <masak> hope you'll like it here. :)

[16:29] <guidj0s> <3

[16:33] <masak> I see lala++ has a potty mouth. that's not unheard of here, but a bit unusual. I hope e'll stick around, so I can observe whether the channel changes lala, or vice versa.

[16:38] <TimToady> protos of any type have to consider both downward context and upward, so the multi defined in the sub-block is not part of the candidate list for the outer call.  i.e. the proto may need to manage different candidate lists in different scopes (or different child classes, for proto methods)

[16:38] <masak> ok, folks. after a bit of downtime http://november-wiki.org/ is back up!

[16:40] <masak> TimToady: I got all of that except the part where protos have to consider upward context. to me it looks like only the things in the same scope as or lower than a proto are affected.

[16:40] <TimToady> jnthn, so your example should be an error, as it is now; it's just that this is decided by the proto looking at the appropriate candidate list

[16:41] <jnthn> TimToady: OK. :S

[16:41] <TimToady> and in the case of a bare proto like {*} there, it devolves to your current system, except that &lol is allowed to refer to the proto

[16:41] <tadzik> masak: http://november-wiki.org/Perl_6 works for you?

[16:41] <dalek> 6model: f324cbc | jnthn++ | dotnet/runtime/Metamodel/Representations/RakudoCodeRef.cs:

[16:41] <dalek> 6model: Add a slot that we'll be able to stick dispatchees in (where dispatchee = something that a sub that's going to serve as a dispatcher will have in its candidate list).

[16:41] <dalek> 6model: review: http://github.com/jnthn/6model/commit/f324cbcb5b0736e4d685fbbc7d2a8b486aa30111

[16:41] <dalek> 6model: e21ef65 | jnthn++ | dotnet/compiler/ (2 files):

[16:41] <dalek> 6model: Stash types in signature objects.

[16:41] <dalek> 6model: review: http://github.com/jnthn/6model/commit/e21ef65d5f2005e3bdab5d80f5bbeadd4879be02

[16:41] * masak tries

[16:41] <dalek> 6model: c5ba12f | jnthn++ | dotnet/runtime/Init.cs:

[16:41] <dalek> 6model: Give low level code objects a HOW and a !add_dispatchee method that will add to its dispatchee list.

[16:41] <dalek> 6model: review: http://github.com/jnthn/6model/commit/c5ba12f75ae7066266c5f8ed412576b14d111f5b

[16:42] <jnthn> TimToady: *sigh* Took me ages to work out how to get thees things right in the last design. :/

[16:42] <masak> tadzik: no, getting an internal error for that one.

[16:42] <TimToady> S06:126 discusses how the candidate lists are defined

[16:42] <masak> tadzik: November is in need of quite some de-bitrotting these days. I'm glad it runs, but it does so on quite an old Rakudo and with quite a few fixes needed.

[16:43] <masak> tadzik: fwiw, it seems to give an error on all not-found pages.

[16:43] <masak> so it's mostly a question of LTA there, I think.

[16:43] <TimToady> jnthn: maybe think of it this way; instead of an anonymous multi dispatcher, the proto is the name of the multi dispatcher you're going to use

[16:44] <TimToady> and most of them will be the same dispatcher

[16:44] <jnthn> TimToady: Well, the model I'm pondering at the moment is that every routine has a candidate list that it presides over.

[16:45] <jnthn> TimToady: For many routines that slot will be null.

[16:45] <rokoteko> howdi.

[16:45] <TimToady> that doesn't seem quite right to me

[16:45] <jnthn> TimToady: Why?

[16:45] <TimToady> lambdas shouldn't care about candidates

[16:45] <jnthn> TimToady: Any routine could be wrapped.

[16:45] <TimToady> only protos have to care anymore

[16:45] <jnthn> TimToady: Huh?

[16:45] <jnthn> I said *Routine*.

[16:45] <jnthn> Not Code.

[16:45] <TimToady> ah

[16:45] <jnthn> That was deliberate. :-)

[16:46] <jnthn> I guess though that this falls apart if somebody tries to wrap a proto...

[16:46] <masak> rokoteko: hi!

[16:46] <TimToady> sorry, distracted...

[16:46] <jnthn> Since they'd both fight over that slot.

[16:46] <TimToady> surely the wrapper is an only around the proto

[16:46] <jnthn> Oh, good point

[16:46] <jnthn> So the wrapper owns the candidate list.

[16:46] <masak> oh wow. wrapping a proto.

[16:46] <jnthn> Yeah, this could work.

[16:47] <TimToady> that's one of the reasons I wanted &lol to refer to the proto

[16:47] <jnthn> The thing is that it can't really refer to just *a* candidate list.

[16:47] <jnthn> erm

[16:47] <jnthn> Not the &lol

[16:47] <TimToady> that's correct

[16:47] <jnthn> I mean, I can't have a slot that just holds *a* candidate list.

[16:47] *** cogno joined
[16:47] <TimToady> the candidate list it uses still belongs in the scope of the caller somehow

[16:47] <jnthn> It needs to have some mapping of handle => candidate list.

[16:47] <jnthn> Oh, hmm.

[16:47] <guidj0s> TimToady: are you considering anything similar to symbolic references for Perl 6?

[16:48] *** am0c joined
[16:48] <TimToady> $::($name)

[16:48] <masak> guidj0s: they're in the spec already.

[16:48] <TimToady> it has a separate syntax

[16:48] <jnthn> TimToady: That doesn't feel quite right.

[16:49] <jnthn> TimToady: I want the same mechanism that we use for multi-method candidate lists at different levels to also work for inner/outer scopes ideally.

[16:49] *** envi^home left
[16:49] <jnthn> TimToady: I guess maybe they shouldn't live in the proto though, otherwise we may memory leak.

[16:50] <TimToady> you still want to cache them (or at least a reference) with the call

[16:50] <jnthn> (e.g. in anonymous subclasses)

[16:50] <jnthn> Yeah, quite.

[16:50] <jnthn> As well as the dispatch cache.

[16:51] <TimToady> I'm trying to drive the semantics of nested lexical scopes and inheritance as close together as I can, wrt proto

[16:51] <TimToady> so you can think of inner scopes as derived classes

[16:51] <jnthn> Right, which fits with me wanting the same underlying mechanism for both.

[16:52] *** cogno left
[16:52] <jnthn> TimToady: In a sense, we don't only want to invoke the proto with the arguments, we also want to invoke it with the current caller's view of the candidate list or something.

[16:53] <jnthn> Though for objects it's not really caller as such

[16:53] <jnthn> It's more invocant type

[16:53] *** Trashlord joined
[16:54] <TimToady> for sure the candidate list builder needs to know the identity of the target scope/class somehow or other

[16:54] <TimToady> if only to keep a hash of candidate lists per target scope/class

[16:55] <jnthn> I don't think that's a good idea.

[16:55] <jnthn> It'll leak memory on anonymous subclasses that we then GC.

[16:55] <masak> the chief difference between nested scopes and inherited classes is multi inheritance.

[16:55] <TimToady> yes, it should be put into the target object to avoid leaking

[16:56] *** hudnix left
[16:56] <jnthn> masak: That's not really relevant here.

[16:56] <TimToady> you still have an ordering even under MI

[16:56] <jnthn> masak: With multi-inheritance you have an MRO and can use that linerarization.

[16:57] <masak> jnthn: I suppose so. I'm still thinking about it.

[16:57] <TimToady> which is why nextsame can work for either

[16:57] * masak 's brane hurts

[16:58] <masak> I think the two of you are right. it's not a problem with MI.

[16:58] <jnthn> TimToady: Define "the target object" though

[16:58] <TimToady> you're beating your head against a Wall :P

[16:58] <TimToady> scope or class

[16:58] <jnthn> What's a class?

[16:58] <jnthn> :-)

[16:58] <jnthn> Oh

[16:58] * masak makes the sound of one that stops doing that :)

[16:58] * masak goes away to study

[16:59] <jnthn> I wonder if I can shove it in the STable.

[16:59] <jnthn> Yes, I can.

[16:59] <jnthn> Maybe.

[16:59] <TimToady> what is an STable

[16:59] <jnthn> TimToady: It's a table of stuff that exists per (HOW, REPR) pair

[16:59] <jnthn> Or at least, per one that we ever instantiate.

[16:59] <jnthn> TimToady: Internal implementation detail

[17:00] <jnthn> Rather than Perl 6 space thing

[17:00] <TimToady> assuming each class has a unique .HOW instance, it can go there

[17:00] <jnthn> I'm still not sure that's right though

[17:00] <TimToady> if it's not unique, then some place per-meta-class instance needs to exist

[17:00] <jnthn> Yeah but that's going to play really badly if people want to write prototype-y stuff

[17:00] <TimToady> well, it's probably not in the type object

[17:01] <jnthn> No, it's certainly not in the type object.

[17:02] <TimToady> well, a prototype-y knowhow will probably have to stuff it in the actual object

[17:02] <jnthn> So are we saying that this lookup needs to be part of the HOW API?

[17:02] <jnthn> e.g. a meta-object needs to know how to manage these things?

[17:03] <jnthn> (We're making life a bit harder for the meta-programmer here. OTOH we can always provide this in a role that they can compose.)

[17:04] <TimToady> probably, but I'm fuzzy on the exact handshake looks like

[17:04] <TimToady> *waht

[17:04] <TimToady> *ha

[17:04] <jnthn> WHAT

[17:04] <jnthn> Yeah. Hmm.

[17:05] <jnthn> I guess what is clear from this is that the proto doesn't actually own the candidate list(s). It either just knows how to obtain them, or should be curried with them.

[17:06] <jnthn> Figuring out how to make this work at all is hard enough without even starting on how to make it really fast...

[17:07] <jnthn> The other difference between scopes and objects is that in a scope, the candidate list is fixed at compile time, whereas in an object, we could get new candidates monkey-patched in.

[17:07] <TimToady> curry, yum

[17:07] <jnthn> So we'll need to make sure invalidation is done right to.

[17:07] <jnthn> *too

[17:07] *** molaf joined
[17:07] <TimToady> yes, though even there, we can start to guarantee lack of monkeying at CHECK time and finalize classes

[17:08] <TimToady> or at least close them

[17:08] <jnthn> We can close them perhaps. Can't seal 'em though

[17:08] <jnthn> Well

[17:08] <jnthn> What happens if I compile some class in a module, close the class, and then somebody uses it from a script?

[17:09] <jnthn> And monkey patches it from there?

[17:09] <TimToady> aggressive inlining in the absence of declarative pessimization will (I hope) save our bacon someday

[17:09] <TimToady> this determination is made on an application level

[17:09] <TimToady> a predefined module may not assume it, or must at least provide both closed and open options

[17:10] <TimToady> or some way to pry it open again

[17:10] <TimToady> when I say CHECK time, I mean the CHECK of the main application, not the CHECK of the module

[17:10] <jnthn> Yes but if you pre-compiled the module...

[17:10] <jnthn> Well, I guess you still have the meta-objects in memory and can twiddle them.

[17:11] <TimToady> then you have to take it into account that you might have to recompile it to be open if someone monkey patches it

[17:11] <TimToady> we don't have to make monkey patching efficient

[17:11] <jnthn> True

[17:12] <TimToady> it's the lack of monkey typing that needs to be detectable at CHECK time and aggressive optimization enabled

[17:12] <jnthn> Like, "Pre-compiled modules can close classes. If you use a module and are monkey typing, the pre-compiled version will be ignored and we will always re-compile with source."

[17:12] <TimToady> nobody can close classes, according to spec

[17:13] <TimToady> only the application as a whole may do so

[17:13] <TimToady> mere mortal code may only request that a particular class remain open

[17:13] <jnthn> Yes, but the spec says precious little afair about how that plays with pre-compilation.

[17:14] <TimToady> one may certainly precompile both ways on spec, if we want to factor out some optimization to before CHECK time

[17:14] <jnthn> By the time you freeze bytecode, didn't you already have that module's CHECK time, though?

[17:14] <TimToady> turning $.foo into $!foo will be a large optmization

[17:15] <TimToady> when I say CHECK time, I mean the CHECK of the main application, not the CHECK of the module

[17:15] *** felliott__ left
[17:15] <jnthn> Anyway, I think I've got a few more hints on what this multi stuff needs to look like.

[17:15] <jnthn> Though more questions than answers yet.

[17:16] <jnthn> (On how to implement it.)

[17:16] <TimToady> hopefully they're bad questions, meaning the kind I can answer :)

[17:16] <jnthn> It's mostly "how do I factor this", "how do I make this fast" and so on.

[17:16] * TimToady is still thinking about $/ and $!

[17:17] <jnthn> We had to do some trickery in current Rakudo to get closure semantics + multis right, which is yet another thing to try and factor into this.

[17:18] <TimToady> to best enable optimization, we have to hang every piece of data at the right spot (kinda like database normalization) and make sure we don't throw away any useful information as to when to optimize/pessimize

[17:19] <jnthn> I suspect I should probably try and get the new model in place while doing the meta-model stuff and NQP refactors...otherwise it's just asking for another round of painful refactors later.

[17:19] <TimToady> well, in a real sense there are no multis anymore, except as a tag for collection; everything is a lambda down under

[17:19] *** guidj0s left
[17:19] <jnthn> Well, yeah, my current model for multis is "go find a place to install this"

[17:20] <jnthn> Rather than "install something in the symbol table right away"

[17:20] <jnthn> Oh, I wonder

[17:20] <jnthn> Maybe I can just stick the candidate lists in the lexpad for the lexicals case

[17:20] <jnthn> So in

[17:21] <TimToady> that's where I thought it would go

[17:21] <jnthn> Yeah

[17:21] <jnthn> I guess I can just pick a weird sigil-y name :-)

[17:21] <TimToady> I was using .<!FOO> for hidden names

[17:22] <Juerd> I can see your hidden name :)

[17:22] <jnthn> proto foo($x) { {*} }; multi foo(Int $x) { 1 }

[17:22] <jnthn> That would actually install two things

[17:22] <jnthn> The &foo

[17:22] <TimToady> otoh maybe there's a scope object separate from the symbol table

[17:22] <jnthn> And a &!foo-candidates

[17:22] <jnthn> Or something like that.

[17:23] <TimToady> STD currently has two objects, mostly because p5 doesn't like to mix normal hash with object hash

[17:23] <jnthn> Yeah, I heard mixing different types of hash can really mess you up.

[17:23] <jnthn> Oh, wait...different topics.

[17:23] <ingy> o/

[17:23] * ingy waves from the Boston->NYC bus

[17:23] <TimToady> well, you can't install the foo-candidates until you have to inner scope

[17:24] <TimToady> \o

[17:24] <TimToady> how's my favorite iterant acmeist?

[17:24] <TimToady> *itinerant

[17:24] <jnthn> TimToady: I was thinking more that a multi in the inner scope would just go and add things in each scope down to the one with the proto in.

[17:25] <jnthn> er, wait

[17:25] <jnthn> The other way round

[17:25] <jnthn> Oh, damm

[17:25] <jnthn> I see your point.

[17:25] <jnthn> :|

[17:26] <tylercurtis> rakudo: sub postfix:<?>($thing) { $thing.Bool }; say (::ingy does Iterator)?

[17:26] <p6eval> rakudo 928836: OUTPUT«0␤»

[17:27] <jnthn> TimToady: The language about downward candidates for lexically scoped multis is pretty clear, but what's the upwards bit?

[17:28] <jnthn> TimToady: Is that saying that if I declare a proto foo($x) { * } and a bunch of multis in inner (downward) scopes, then that proto controls them, but also incorporates things from its outer scopes too?

[17:28] <jnthn> proto foo($x) { * }; multi foo(Int $x) { 1 }; { proto foo($x) { * }; multi foo($x) { 2 }; foo(); } # 1 or 2?

[17:29] <jnthn> And

[17:29] <jnthn> oops, above I meant foo(42)

[17:29] <jnthn> And

[17:29] <jnthn> proto foo($x) { * }; multi foo(Int $x) { 1 }; { proto foo($x) { * }; multi foo(Str $x) { 2 }; foo(42); } # 1 or error?

[17:30] <jnthn> That is, is the proto marking the end of an "extent" of scopes, and hiding the ones beneath it?

[17:30] <jnthn> From S06 I'm guessing 1 and 1.

[17:31] <masak> I thought a proto was like saying "I'll handle this scope and those inside it".

[17:31] <masak> can dispatch reach above a declared proto?

[17:31] <jnthn> masak: And thus hides the things above it?

[17:31] * tylercurtis would expect error, from a intuitive perspective.

[17:31] <jnthn> masak: I could argue for that.

[17:32] <jnthn> I'd actually *like* that.

[17:32] <masak> jnthn: that's how I grokked it so far.

[17:32] <masak> jnthn: thus, a proto is very much like an only. except that it has multies. :)

[17:32] <jnthn> masak: I'm not sure it's what S06 says though.

[17:32] <masak> neither am I.

[17:32] <jnthn> We used the term "managed" loosely above to indicate the set of C<multi>s in

[17:32] <jnthn> question; the "managed set" is more accurately defined as the intersection

[17:32] <jnthn> of all the C<multi>s in the C<proto>'s downward scope with all the C<multi>s that

[17:32] <jnthn> are visible to the caller's upward-looking scope.

[17:32] <jnthn>  -- love, S06

[17:33] <masak> I think we're in agreement. you, me, and S06.

[17:33] <jnthn> Erm, huh?

[17:33] <masak> so here's how I read it.

[17:33] <masak> you have two cones going on.

[17:33] <masak> one cone is the things downwards from the proto.

[17:33] <masak> the other cone is the things upwards from where you're calling.

[17:33] <masak> the set of multis in the dispatch is simply the intersection of those two cones.

[17:34] <jnthn> You're saying that

[17:34] <masak> in a scopes setting, the latter cone is boring. think of it as a line. in a MI setting, the latter cone is interesting.

[17:34] <masak> sorry for somewhat mixed metaphors. :)

[17:34] <masak> I love the fact that I think I grok this.

[17:35] <jnthn> Grr...it's hard to come up with an example...wait a moment...

[17:36] <tylercurtis> On the topic of multis, what does "Named arguments that bind to positionals in the proto sig will become positionals for all subsequent calls to its managed multis." mean. How does a named argument bind to a positional?

[17:37] <masak> rakudo: sub foo($x) { say $x }; foo( x => "OH HAI" )

[17:37] <p6eval> rakudo 928836: OUTPUT«OH HAI␤»

[17:37] <masak> tylercurtis: does that answer your question?

[17:38] <tylercurtis> masak: yes, it does. I knew that that sort of thing applied to BUILD, but I had no idea it worked in general.

[17:38] <masak> tylercurtis: BUILD contains absolutely no magic, save for being automatically called by .bless via BUILDALL.

[17:39] <jnthn> OK, I guess what I'm curious about is if there's a case where the caller's upward looking scope is ever also not the multi we're calling's upward looking scope.

[17:40] <masak> can't think of any.

[17:40] <masak> because in order for us to see the multi we're calling, we have to be below it.

[17:40] <TimToady> the managed list is the intersection of downward and upward views, not the union

[17:41] <jnthn> TimToady: I think I need a few examples. First, what are the outputs of the two things I pasted above?

[17:42] *** xinming left
[17:42] <TimToady> 2 and error

[17:43] <jnthn> TimToady: OK, good. :-)

[17:43] <jnthn> TimToady: But I'm still struggling a little on what the "downward and upward" bits mean.

[17:43] <masak> yes; good.

[17:44] <masak> jnthn: the proto defines things downward. multis are visible upward.

[17:44] <jnthn> TimToady: Because as I'm seeing it, the multi candidates that you might end up calling are those situated between your current scope and the outer scope containing the proto, inclusive.

[17:44] <jnthn> Which is kind of one "cone".

[17:44] <TimToady> multis don't look, they're passive

[17:44] <TimToady> the call looks upward, and the proto looks downward

[17:44] <TimToady> and multies they both see are valid candidates

[17:45] <jnthn> Aha, OK

[17:45] <jnthn> That makes it much less foncusing.

[17:45] <jnthn> oh ffs

[17:45] <jnthn> *confusing

[17:45] <jnthn> .oO( I guess one coffee this morning wasn't enough... )

[17:45] <masak> "funcusing" is when you try to focus, and almost succeed :)

[17:46] <masak> er, *foncusing

[17:46] <jnthn> :P

[17:46] <masak> -Ofuncusing

[17:46] <jnthn> -Ofuncusing

[17:46] <jnthn> ...

[17:46] <masak> \o/ :)

[17:47] <masak> jnthn: the upwards cone is a line, because the scope inclusion relation is one-to-many. that's why I thought MI would be more problematic, because it's many-to-many and creates funnier upwards cones.

[17:48] <jnthn> TimToady: OK, I think I see what you mean by intersecting views now

[17:48] <masak> but it's admittedly not more problematic, because of the MRO.

[17:48] <jnthn> TimToady: Though I guess it's manageable in a sense by the call "collecting" all of the multis it can see on its way to the proto, and then saying "oh hey, I found these candidates, how about you pick one for me?"

[17:50] <masak> it's a really pretty interaction between the calling scope and the proto. hopefully one that can be cached at scope level, too.

[17:50] <ingy> TimToady: doing well thanks! I think it's my net connection that is itinerant :]

[17:50] *** Mowah joined
[17:51] <masak> I wonder if anyone is ever going to make use of the fact that multis define and undefine themselves at scope limits. in serious code, I mean.

[17:51] * masak stops babbling and goes back to studying again

[17:52] <TimToady> for overloadings of operators, perhaps

[17:52] <TimToady> drums &

[17:52] <ingy> I had a few acmeist days of hacking with path++ nd sartak++ in which they knocked my pegex back a few pegs, but with a little backtracking it should all be fine...

[17:53] <ingy> *patch++

[17:54] *** ggoebel joined
[17:55] *** jhuni joined
[17:55] <ggoebel> I've got 2 1/2 hours of "me" time... where does one get niezca? instructions? website? wiki?

[17:56] <[Coke]> is rakudo having any trouble with compiler infrastructure bleeding into user-visible areas?

[17:56] <tylercurtis> Is the invocant at all privileged over the other parameters in multimethod dispatch? For example, "class A { multi method foo(::B $b) { #`(do I need a proto, btw?) 1 } }; class B is A { multi method foo(A $a) { 2 } }; say B.new.foo(B.new);" Is that an error or 2?

[17:56] <tylercurtis> rakudo: .say for ClassHOW.^methods

[17:56] <p6eval> rakudo 928836: OUTPUT«Method 'methods' not found for invocant of class ''␤  in main program body at line 22:/tmp/iBifVtQvVm␤»

[17:56] <tylercurtis> [Coke]: ^^

[17:57] <jnthn> ClassHOW isn't leakage - it should be there.

[17:57] <mberends> ggoebel: http://github.com/sorear/niecza

[17:57] *** colomon left
[17:57] <tylercurtis> jnthn: Right. But shouldn't it be introspectable, ideally?

[17:57] <jnthn> tylercurtis: Yes

[17:57] <jnthn> tylercurtis: (6model will get that right.)

[17:58] <[Coke]> For example, in partcl, I can see the Grammar in the top level Tcl namespace, which I shouldn't.

[17:58] <tylercurtis> rakudo: say Perl6::Compiler; say PAST::Compiler; say PAST::Block.new

[17:58] <p6eval> rakudo 928836: OUTPUT«Perl6::Compiler()␤PAST::Compiler()␤Capture[0x5a77490]␤»

[17:58] <jnthn> [Coke]: Yeah, we have that too.

[17:58] <jnthn> As tylercurtis just showed

[17:59] <ggoebel> mberends: thanks

[17:59] <pmichaud> in rakudo's case, Perl6::Compiler is as much feature as bug, though.

[17:59] <jnthn> True :-)

[17:59] <jnthn> But PAST is harder to argue. ;-)

[18:00] <[Coke]> is there a way to force "module" in nqp to be absolute instead of relative to the hll?

[18:00] <pmichaud> it should be very possible to get PAST and the like to live in their own private hll namespace -- just nobody's done it yet.

[18:01] <jnthn> tylercurtis: (multi) At the moment we always look class by class up the hierarchy.

[18:01] <jnthn> tylercurtis: In the future, we will look at all candidates between the invocant type and the nearest proto.

[18:01] <jnthn> And yes, you will have to write a proto.

[18:01] <ggoebel> niezca readme states that mono v2.6.4 is recommended. Should I assume that the current v2.6.7 is discouraged?

[18:01] <dalek> 6model: ab1b7bc | ++ | java/runtime/ (8 files):

[18:01] <dalek> 6model: globally rename IRakudoObject to RakudoObject etc, catch up with some dotnet/ changes

[18:01] <dalek> 6model: review: http://github.com/jnthn/6model/commit/ab1b7bc3ded6e4d3b90e904e6f3e4c7cc34a0cbd

[18:01] <pmichaud> [Coke]: (absolute instead of hll-relative)  no, but one could put a .HLL directive before the line of the compiler that includes the NQP-generated .pir files

[18:02] <pmichaud> that would cause all of the methods to appear in that alternate HLL space

[18:02] <pmichaud> I've also considered having a   'use hll' pragma but not gotten there yet.

[18:02] <jnthn> mberends++ # karma fel? 

[18:02] * mberends seems to have gone anonymous

[18:04] <masak> or, as we say in automata theory, ε

[18:05] * [Coke] blearghs.

[18:05] <[Coke]> it's not a blocker, it's just annoying. I'll see what I can do to route around.

[18:09] <masak> [Coke]: you just summarized my past 2 years with Rakudo. :P

[18:14] <pmichaud> and my past 4-5 years with Parrot.  :P

[18:15] *** justatheory left
[18:17] *** am0c left
[18:17] *** colomon joined
[18:19] <jnthn> o/ colomon 

[18:19] <[Coke]> I am doubly annoyed as I had already worked around most of this stuff BEFORE pct/nqp. =-)

[18:19] <colomon> \o

[18:23] <ggoebel> scruffy:~/src/niecza ggoebel$ xbuild

[18:23] <ggoebel> dyld: Library not loaded: /usr/lib/libiconv.2.dylib

[18:23] <ggoebel>   Referenced from: /Library/Frameworks/Mono.framework/Versions/2.6.7/bin/mono

[18:23] <ggoebel>   Reason: Incompatible library version: mono requires version 7.0.0 or later, but libiconv.2.dylib provides version 5.0.0

[18:23] <ggoebel> scruffy:~/src/niecza ggoebel$ xbuild

[18:23] <ggoebel> dyld: Library not loaded: /usr/lib/libiconv.2.dylib

[18:23] <ggoebel>   Referenced from: /Library/Frameworks/Mono.framework/Versions/2.6.7/bin/mono

[18:23] <ggoebel>   Reason: Incompatible library version: mono requires version 7.0.0 or later, but libiconv.2.dylib provides version 5.0.0

[18:23] <ggoebel> getting an xbuild libiconv error trying to build niecza... http://pastebin.com/eKjE3Bva

[18:23] <ggoebel> on osx 10.4

[18:23] <ggoebel> sorry about the double paste...

[18:26] <mberends> ggoebel: so your libiconv is too old

[18:29] <ggoebel> mberends: figured... installing current (1.13.1) from http://www.gnu.org/software/libiconv/#TOCdownloading

[18:30] *** justatheory joined
[18:33] <ggoebel> still trying to compile niecza. With updated libiconv I now get:

[18:33] <ggoebel> $xbuild

[18:33] <ggoebel> Bus Error

[18:33] <ggoebel> thoughts?

[18:34] <diakopter> hm

[18:36] *** maja joined
[18:37] *** justatheory left
[18:37] *** cogno joined
[18:38] *** maja left
[18:38] <ggoebel> downgrading mono to 2.6.4...

[18:44] <masak> ggoebel: generally, using a nopaste service is appreciated. just so you know till next time. :)

[18:45] <masak> today's word: dehierarchicalization. that's what roles do. :)

[18:46] * gfldex stares in awe at the new word

[18:47] <masak> I wasn't aware that you could summarize what roles do in one word. but apparently you can.

[18:48] <jnthn> So ar people that promote multiple inheritance instead antidehierachicalizationists?

[18:48] <tylercurtis> I think it's more accurate to suggest that MI's proponents are anticommutativists.

[18:48] <tylercurtis> Or linearizationalists, if you prefer.

[18:49] <masak> jnthn: only if they're aware of the dehierarchicalization that roles provide and reject it.

[18:50] <mberends> that word looks a little bit shorter each time you read it ;)

[18:51] <jnthn> .oO( must use this in a talk )

[18:51] *** cogno left
[18:52] <tylercurtis> masak: I'm not sure I agree that roles dehierarchicalize. You can have hierarchies of roles. The difference is that hierarchies of roles have sane semantics.

[18:53] <masak> tylercurtis: well, some kinds of hierarchies disappear, and other kinds remain when using roles.

[18:53] <jnthn> tylercurtis: Yes, but the hierarchy has to be collapsed before you cna ever use any of the things in the roles.

[18:53] <jnthn> That's what happens in role compositon.

[18:53] <jnthn> And you can't call a method in a role without it being composed into a class first.

[18:53] <masak> it's the role composition that does the actual dehierarchicalization.

[18:53] <jnthn> Right.

[18:54] <masak> I've stopped typing out the word now, and just paste it in. :)

[18:54] <jnthn> So yes, you can have a hierarchy of roles, but the thing that makes roles interesting is the composition algorithm.

[18:54] <masak> is it the ClassHOW that does the composition, or the RoleHOW? or neither?

[18:54] <jnthn> Neither.

[18:55] <ggoebel> phenny: tell sorear two suggestions for niecza's readme: 1) state the minimum libiconv requirement (I installed 1.13.1 from http://www.gnu.org/software/libiconv/) and 2) Mention that mono v2.6.4 isn't just a recommendation (v2.6.7 is known to have problems on OSX 10.4)

[18:55] <phenny> ggoebel: I'll pass that on when sorear is around.

[18:55] <jnthn> The composer is factored out.

[18:55] <jnthn> .oO( Like in a lot of pop music. )

[18:55] <tylercurtis> Right. I think the thing to focus on is the behavior of composition and sum, though, not so much the lack of hierarchies, since there is still the option of conceptual hierarchies.

[18:56] <jnthn> tylercurtis: But the result of composition is to flatten the hierarchy out. Thus the name "flattening composition".

[18:56] <gfldex> can we adapt this for perl 6 propaganda? http://gfldex.files.wordpress.com/2010/08/0025e5041762b0f1822f2d230b58c821.jpg?w=436

[18:56] <jnthn> And I think that is in many senses what makes roles interesting.

[18:57] <jnthn> By the time you get to the point of dispatch, there's no hierarchy to consider and the fact that the methods came from roles is a mere historical artefact, mostly interesting to the introspectionist.

[18:57] <ggoebel> getting further compiling niecza on OSX 10.4. Now I'm getting 'mono --aot obj/Kernel.dll' exited  with code:1 (http://pastebin.com/nrG4Kji1)

[18:58] <mberends> dehierarchicalizationintrospectionist # copy, paste, copy, paste

[18:59] <jnthn> gfldex: we scantily woman dressed use not should!

[18:59] <ggoebel> phenny: tell sorear I get a "Bus error" executing xbuild on osx 10.4 with mono 2.6.7... which goes away with a downgrade to 2.6.4 

[18:59] <phenny> ggoebel: I'll pass that on when sorear is around.

[19:00] <jnthn> .oO( it's actually quite hard to write English in reverse polish notation... )

[19:01] <jnthn> .oO( "ovip mam aj" is my favorite reverse polish saying... )

[19:01] <tylercurtis> I think the commutativity and associativity of trait sum is more important. If roles flattened but role sum linearized instead of being commutative, roles would be significantly less useful, IMO.

[19:02] <jnthn> Yes, that is also important too.

[19:03] <masak> jnthn++ # real reverse Polish!

[19:04] *** offby1 joined
[19:04] *** _twitch left
[19:05] <tylercurtis> I think that I'd prefer roles that didn't flatten to roles that linearized. Of course, roles that flatten and don't linearize are even better. :)

[19:05] <offby1> I'm playing with rakudo "Pisa" at the command line, and notice that (10 * 10).WHAT => Int(), as I'd expect, but (109999 * 109999).WHAT => Num, which is not what I'd expected.  How can I force the multiplication to return an exact integer?

[19:05] *** cono left
[19:05] <colomon> offby1: you cannot

[19:05] <offby1> oh.

[19:06] <jnthn> offby1: We don't have big-int support yet

[19:06] <colomon> right now in Rakudo, Ints are limited to 32-bits of precision.  

[19:06] <offby1> jnthn: oh.

[19:06] <offby1> bummer.

[19:06] <colomon> (though occasionally 64-bits sneaks through on 64-bit machines.)

[19:06] <jnthn> offby1: So if they overflow we promote 'em to Nums. That should change at some point.

[19:06] <offby1> ah well.

[19:06] <offby1> thanks

[19:06] <tylercurtis> colomon: as long as you don't perform any actual operations on them.

[19:06] *** offby1 left
[19:06] <pmichaud> s/should/will

[19:06] *** cono joined
[19:06] <ggoebel> Found a niecza reference to mono AOT failures in irc logs at (http://irclog.perlgeek.de/perl6/2010-08-06#i_2670473)

[19:07] <ggoebel> penny tell sorear One more osx addition for readme... I got neicza to build without error using: xbuild /property:UseAOT=N

[19:07] <masak> "that should change at some point" is in some ways a dangerous stance. we might risk ending up with a spec that says one thing, and a number of implementations that do another, simpler thing.

[19:08] <masak> may it'd be better in that sense for Rakudo to die on int overflow.

[19:08] <jnthn> masak: That fails the "being useful" test. :-)

[19:08] <gfldex> ggoebel: you misspelled phenny

[19:09] <masak> in some cases demoting to nums can be a lot less useful than giving fair warning.

[19:09] <ggoebel> phenny tell sorear One more osx addition for readme... I got neicza to build without error using: xbuild /property:UseAOT=N

[19:09] <ggoebel> gfldex: thanks

[19:09] <ggoebel> success!

[19:09] <masak> jnthn: it's not like you won't be able to represent large Nums under such a regime. just multiply by 1.0

[19:10] <colomon> masak: nope, 1.0 is a Rat

[19:10] <masak> oh, indeed.

[19:10] <masak> well, .Num, then.

[19:11] <masak> rakudo: say 5.Num.WHAT; say 5.Num

[19:11] <p6eval> rakudo 928836: OUTPUT«Num()␤5␤»

[19:11] <masak> rakudo: say 5.Num.perl

[19:11] <p6eval> rakudo 928836: OUTPUT«5␤»

[19:11] <masak> hm. wonder if that should be something else.

[19:11] <colomon> .perl doesn't work well on numbers.

[19:12] <colomon> I believe that's already in RT

[19:14] <masak> std: FIRST {}

[19:14] <p6eval> std 32080: OUTPUT«ok 00:01 115m␤»

[19:15] <masak> std: if 5 { FIRST {} }

[19:15] <p6eval> std 32080: OUTPUT«ok 00:03 116m␤»

[19:15] <masak> TimToady: shouldn't the first be illegal in a non-loopy setting, and the second always?

[19:15] <masak> decommute &

[19:15] *** masak left
[19:19] *** wamba joined
[19:22] *** Mowah left
[19:26] *** tadzik left
[19:27] *** M_o_C joined
[19:31] *** jhuni left
[19:31] <gfldex> $gfldex.blog.post('http://gfldex.wordpress.com/2010/08/22/callbacks-and-perl-6/');

[19:34] <dalek> 6model: 98196e3 | jnthn++ | dotnet/ (2 files):

[19:34] <dalek> 6model: Stash capture in current context. Also fix a viviself code-gen bug.

[19:34] <dalek> 6model: review: http://github.com/jnthn/6model/commit/98196e3270d77fd6ba3e19f910ec59df8bff769f

[19:34] <dalek> 6model: 7d9fec6 | jnthn++ | dotnet/runtime/Metamodel/SharedTable.cs:

[19:34] <dalek> 6model: Fix bug noticed by mberends++.

[19:34] <dalek> 6model: review: http://github.com/jnthn/6model/commit/7d9fec658608f12448d680fd600e62192e235307

[19:34] <dalek> 6model: a389552 | jnthn++ | dotnet/ (7 files):

[19:34] <dalek> 6model: A fresh start at prototyping the new multi-dispatch, after discussions with TimToady++. Nothing working yet, but this starts us storing the candidates per scope and stubs in some logic for us to go looking for them. Needs a first crack at lists before we can make this work at all, though.

[19:34] <dalek> 6model: review: http://github.com/jnthn/6model/commit/a389552f075bc1e4693fa6ab58ee4090ae082452

[19:36] *** tadzik joined
[19:44] *** patrickas joined
[19:45] <patrickas> Ola!

[19:46] <tadzik> hello!

[19:47] <patrickas> tadzik: what's up?

[19:47] <patrickas> do you have a page with the speed tests you were doing ? I was curious about the tests and the pseed improv for each one

[19:48] <tadzik> patrickas: fine, just updated/updating my system :)

[19:48] <patrickas> s/pseed/speed/

[19:49] <ggoebel> Are announcements for development releases of Rakudo gone by the wayside now that R* releases are coming out? I.e. there is no release announcement for rakudo development release #32 at http://www.rakudo.org 

[19:49] <tadzik> ggoebel: only Star will be announced now

[19:50] <tadzik> it's the main Marketing Hit now :)

[19:51] <jnthn> ggoebel: The compiler releases are just announced on the perl6-compiler mailing list now; the Star releases will be announced more widely, as tadzik mentioned.

[19:51] <jnthn> ggoebel: Trying to avoid confusing people with too many release announcements. :-)

[19:52] <patrickas> jnthn++ (blog post), can't wait for all the goodies you'll be working on to land :-)

[19:52] <tadzik> a blog post?

[19:57] <tadzik> jnthn: mind sharing a link?

[19:58] <moritz_> planetsix.perl.org

[19:58] <tadzik> thanks moritz_++

[19:58] <jnthn> tadzik: http://6guts.wordpress.com/2010/08/22/rakudos-meta-model-the-road-ahead/

[19:58] <jnthn> oh, also where moritz_++ said :-)

[20:01] <moritz_> planetsix is a must-read for 6ers :-)

[20:02] <jnthn> Aye

[20:04] <dalek> 6model: eae223f | jnthn++ | / (4 files):

[20:04] <dalek> 6model: Add a first cut of a P6list representation and a list sub that makes one (hardcoded rather than in the setting for now). Stub in NQPList in the setting; expect we'll base NQPArray on this representation too.

[20:04] <dalek> 6model: review: http://github.com/jnthn/6model/commit/eae223f3921747ec858ffa3c9235199f6088de77

[20:04] <dalek> 6model: e1bf4d3 | jnthn++ | dotnet/compiler/Actions.pm:

[20:04] <dalek> 6model: Name fix. Seems that we now manage to build per-scope candidate lists.

[20:04] <dalek> 6model: review: http://github.com/jnthn/6model/commit/e1bf4d3ad89bb489a5b065541209b37c3cf9ef68

[20:07] *** jaldhar left
[20:07] *** jaldhar joined
[20:11] *** masak joined
[20:13] <tadzik> jnthn: nice post :) Though, I'm curious about one thing. You mention putting some things into compile time when possible. I remember Allison Randall's Parrot talk, when she said that the way to optimize dynamic languages is to make them more dynamic, rather than more static. How does it go with your approach, can I see your opinion here?

[20:15] <masak> was that allison's point? I'm not sure it was...

[20:15] <tadzik> she mentioned that, she was also talking about late evaluation and stuff. I remember it for I was quite suprised with it

[20:20] <masak> I think one of the things in Perl 6 that might be slightly revolutionary is a kind of dynamic-when-necessary/static-when-possible thinking.

[20:21] <masak> a bit like the grammar engine switches between declarative and procedural behind the scenes, static and dynamic bits might be interchanged behind the scenes as well.

[20:23] <patrickas> tadzik: sorry I got ditracted ... yes I read the post on planetsix too ....

[20:23] <jnthn> tadzik: I think the "work done at compile time is work that doesn't need to be done at runtime" mantra still holds up, and a lot of what I'm advocating is generating better code when compiling our dynamic language rather than pushing the language itself in a more static direction. It's true that making information available to the runtime to let it do dynamic optimization is a good think, and I'm not proposing we take that information away (as if we could anyway, si

[20:24] <jnthn> *good thing

[20:24] <masak> 'anyway, si'

[20:24] <masak> truncated.

[20:24] <jnthn> ", since everything is runtime introspectable in Perl 6).

[20:24] <jnthn> Everything is a slight exaggeration, but a heck of a lot is. :-)

[20:24] <masak> you tl;dr people should either adapt to IRC or, you know, write emails. :P

[20:26] <jnthn> masak: I joined the Twitter School of Brevity this year, I'm trying. :P

[20:28] <masak> omit needless, you know, words. :)

[20:28] <jnthn> tadzik: Yes. No.

[20:28] <jnthn> ;-)

[20:29] <masak> heh. :)

[20:29] * patrickas often needed words.

[20:29] <masak> patrickas: accidentally? :)

[20:29] <jnthn> The *whole* words?

[20:29] <patrickas> maska: just not this time :-p

[20:30] <masak> you accidentally my nick, too :P

[20:30] <tadzik> :)

[20:30] <patrickas> there must be a bug in my tab completion :-P

[20:31] *** cheeps joined
[20:32] <masak> for some reason that made me think about routine protos again. strange association.

[20:34] *** ggoebel left
[20:35] * jnthn looks forward to runtime pls

[20:35] <tadzik> I see proto, pls, but I guess it's not about module installation :)

[20:36] <masak> I think that was the attempted pun. :P

[20:37] <tadzik> with #perl6 came #pun6

[20:37] <masak> well, we do have a tradition of optimizing for pun in here.

[20:38] <tadzik> -Opun

[20:38] <jnthn> Yeah, we're very -Opun to them.

[20:38] <masak> haven't had any punic wars yet, though.

[20:39] <tadzik> but we have puntastic conversations

[20:39] <masak> yeah, they're punderful.

[20:44] <sorear> good * #perl6

[20:44] <phenny> sorear: 18:55Z <ggoebel> tell sorear two suggestions for niecza's readme: 1) state the minimum libiconv requirement (I installed 1.13.1 from http://www.gnu.org/software/libiconv/) and 2) Mention that mono v2.6.4 isn't just a recommendation (v2.6.7 is known to have problems on OSX 10.4)

[20:44] <phenny> sorear: 18:59Z <ggoebel> tell sorear I get a "Bus error" executing xbuild on osx 10.4 with mono 2.6.7... which goes away with a downgrade to 2.6.4 

[20:45] <jnthn> *, sorear 

[20:46] <masak> **, sorear

[20:48] <masak> I have a question. is there a need for a special "package lexpad" containing 'our'-declared variables, or can the package lexpad simply be equated to the topmost lexpad in the package?

[20:48] <masak> my suspicion is the latter, but I might be missing something.

[20:51] <pmichaud> "omit needless^W words"

[20:52] <masak> "needless" isn't needless.

[20:52] <pmichaud> the package lexpad can't be the same as the top most lexical

[20:52] <pmichaud> module XYZ { my sub abc() { ... } };   # abc should not appear in the package

[20:53] <masak> oh!

[20:53] <masak> right.

[20:53] <masak> so, separate one, then.

[20:53] <jnthn> Additionally, lexpads are meant to be static by the time we hit runtime, and you're allowed to shove stuff into the package dynamically. Not quite sure how those two hold together.

[20:53] <pmichaud> well,  module XYZ { ... }   creates a lexical XYZ entry that holds the package entries

[20:54] <jnthn> Aha!

[20:54] <pmichaud> and it's just a hash, really.

[20:54] <jnthn> And the XYZ entry is a stash or somehting

[20:54] <jnthn> OK

[20:54] <pmichaud> and rakudo's use of Parrot NameSpace PMCs hopefully goes away at some point.

[20:55] <pmichaud> either that or the namespace PMCs just get anonymous internal names

[20:55] <jnthn> *nod*

[20:55] <jnthn> heh

[20:56] <jnthn> Rakudo's development plan: "use of Parrot <INSERT FEATURE HERE> goes away" ;-)

[20:56] <jnthn> But not the GC. :P

[20:57] <masak> does inserting the package lexpad below the outside lexpad (and above the topmost lexpad) make sense? that way, Yapsi wouldn't need any special opcodes for doing 'our'-variable lookups.

[20:57] <masak> hm, not sure that question has a boolean answer.

[20:58] <jnthn> 0.5 :-)

[20:58] <pmichaud> the package lexpad is an entry in the outside lexpad, yes.

[20:58] <pmichaud> I'm not sure it encapsulates the nested lexpad, though.

[20:58] <masak> hm.

[20:59] <masak> if it doesn't, I don't really see how it's visible from inside the package.

[20:59] <masak> I've more or less convinced myself that sandwiching it between outer and topmost is what I want to do for Yapsi.

[21:00] <pmichaud> our &xyz  can make an entry in both the package and in the lexical.  

[21:00] <pmichaud> this is what rakudo does now.

[21:00] <pmichaud> we have to do similar things for methods already, too.

[21:00] <masak> sure. it makes entries in both.

[21:00] <masak> and methods make entries in two places, too.

[21:00] <masak> (as you said)

[21:00] <pmichaud> by having entries in both, that's how it's visible inside the package

[21:01] <masak> hm, indeed.

[21:01] <masak> no need to have the package lexpad visible from inside.

[21:01] <pmichaud> anyway, sandwiching might work too.  haven't quite gotten to that point in Rakudo thinking yet.  And it can get a bit tricky with multis.

[21:01] <masak> no need to sandwich it in, either. it can sit in limbo outside the tree of scopes.

[21:02] <pmichaud> oh, I know why it perhaps shouldn't (or should) be visible:

[21:02] <pmichaud> my $x = 'lexical';   module XYZ { say $x;  { our $x = 'package'; } }

[21:03] <masak> ...yes?

[21:03] <pmichaud> I'm pretty sure "say $x" needs to grab the 'lexical' $x, not the one that might be "sandwiched" in a package.

[21:03] <masak> of course.

[21:03] <masak> that falls out from ordinary scope nesting and shadowing.

[21:03] <masak> innermost block binds its lexical to the container in the package lexpad.

[21:04] <masak> so, that speaks out against sandwiching.

[21:04] <masak> pmichaud++

[21:17] *** ggoebel joined
[21:18] <sorear> hello ggoebel 

[21:29] *** patrickas left
[21:35] <sorear> ggoebel: x86 or ppc?

[21:36] <pugssvn> r32081 | mberends++ | replace plan *; with number of tests 

[21:37] <masak> the eradication of whatever for the betterment of statistics.

[21:37] <masak> I'm thinking maybe there's a lesson to be learned here. though perhaps not.

[21:40] <jnthn> There's cake, dammed cake and statistics. :-)

[21:40] <colomon> mmmmm, statistics.

[21:40] <masak> lol

[21:41] <masak> I blogged our discussion of 'our' scoping. http://use.perl.org/~masak/journal/40511

[21:41] <masak> jnthn: by the way, I made pizza today. trying to recreate the one I had in Bologna.

[21:41] <jnthn> masak: How did it work out?

[21:42] <masak> better than I had feared. I know which knobs to tweak next time.

[21:42] <masak> (it was good)

[21:42] <masak> (but not the same)

[21:42] *** lasse_ left
[21:43] <masak> Mozzarella di Buffala is a scary thing. all I know is that now the one I bought is gone, and I need, somehow, to get another one.

[21:45] <colomon> it says something about what I've been cooking lately that I don't even know if I can get fresh mozz in town.  :(

[21:46] <masak> having arrived back home from Italy, that's one of the first things I found out.

[21:46] <masak> turns out one place in town haz it.

[21:46] *** lichtkind joined
[21:47] <colomon> there's one place in town that probably does.

[21:47] <colomon> but I have to make it by their crazy single malt collection to find out.

[21:47] <colomon> ;)

[21:47] <masak> jnthn: btw, I think in the slide with the first code sample in http://www.jnthn.net/papers/2010-nlpw-metamodels.pdf , $area is missing a bang ('!').

[21:47] <colomon> (they have three different bottlings of Talisker!  I can't afford any of them!)

[21:48] <masak> jnthn: or can that be left out nowadays?

[21:48] <jnthn> masak: oh noes, you're right

[21:48] <masak> jnthn: if it can, I hereby declare that sloppy coding :P

[21:48] <jnthn> masak: I was distracted by the flava. :-)

[21:48] <masak> :0

[21:48] <masak> :)

[21:49] <jnthn> That talk is 10 minutes of joking around and 5 minutes of actually talking about meta-models. :-)

[21:49] <masak> that's a decent proportion.

[21:49] <jnthn> :P

[21:49] *** payload joined
[21:49] <jnthn> Maybe I should submit it for OSDC.fr

[21:50] * masak thinks so

[21:53] <masak> I'm thinking I might submit one 20min talk about Druid, and one 40min talk about Yapsi.

[21:53] <masak> but not decided yet.

[21:53] <masak> it's for a relatively non-Perl audience, so the Yapsi one might not be advisable.

[21:55] * masak sleeps

[21:55] *** payload left
[21:55] *** masak left
[21:55] <dalek> 6model: 2d77d23 | jnthn++ | dotnet/runtime/Runtime/ (4 files):

[21:55] <dalek> 6model: A little baby multi-dispatcher is born. It hasn't learned to do topological sorting yet, but it has the organs that will allow it to do so some day soon. :-)

[21:55] <dalek> 6model: review: http://github.com/jnthn/6model/commit/2d77d23c8e8a0dc7fe3d3899b91179c7b8b542de

[22:03] *** wamba left
[22:03] * sorear watches jnthn race ahead

[22:06] <jnthn> sorear: Heh. Though given I'm caching *nothing* at the moment, the runtime is hardly going to race anywhere yet. :-)

[22:08] <pugssvn> r32082 | mberends++ | replace plan *; with number of tests S03 

[22:09] <colomon> mberends++

[22:10] <mberends> S32 or bust!

[22:14] <sorear> jnthn: You just beat me to multi-dispatch.

[22:14] *** Gothmog_ left
[22:19] *** shade\ left
[22:20] *** shade\ joined
[22:20] <pugssvn> r32083 | mberends++ | replace plan *; with number of tests S03-S06 

[22:24] *** macroron left
[22:26] <pugssvn> r32084 | mberends++ | replace plan *; with number of tests S09-S16 

[22:31] <pugssvn> r32085 | mberends++ | replace plan *; with number of tests S32 

[22:34] <pugssvn> r32086 | mberends++ | replace plan *; with number of tests integration/ 

[22:36] <pugssvn> r32087 | mberends++ | replace plan *; with number of tests split.t 

[22:40] *** drbean joined
[22:43] *** M_o_C left
[22:45] <dalek> rakudo: b958a10 | ++ | tools/test_summary.pl:

[22:45] <dalek> rakudo: [tools/test_summary.pl] add S19  to the list of synopses being tested

[22:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b958a10fc6d3efdd6e797310e19f6653db8e3593

[22:46] <mberends> hmm, ack still finds many 'plan *' lines in t/spec, so they must be files that are not being called from spectest.data. I'll look at them later, jnthn++ has put me on a series of turtles to translate into Java first.

[22:49] <mberends> all: if cases of (tested > spec) arise, please let me know, I'm keen to get test_summary.pl as accurate and useful as possible.

[22:51] *** hudnix joined
[22:51] *** cggoebel joined
[22:52] *** ggoebel left
[22:59] *** jedai_ left
[22:59] *** gfldex left
[22:59] *** gfldex joined
[22:59] *** jedai joined
[23:09] <jnthn> Sheesh, even a crappy cache-less multi dispatcher beats the hell out of doing coercions.

[23:10] <cggoebel> phenny tell sorear: x86... One more osx addition for readme... I got neicza to build without error using: xbuild /property:UseAOT=N

[23:10] <cggoebel> phenny tell sorear  x86... One more osx addition for readme... I got neicza to build without error using: xbuild /property:UseAOT=N

[23:11] *** lestrrat is now known as lest_away

[23:11] <jnthn> cggoebel: You need a colon after the phenny

[23:16] <dalek> 6model: 8876bee | jnthn++ | dotnet/ (2 files):

[23:16] <dalek> 6model: Refactors to get signatures built in the right lexical scope (e.g. so they find the types in the right lexical scope).

[23:16] <dalek> 6model: review: http://github.com/jnthn/6model/commit/8876bee8696e5f851dc8d563f6481dd0981c2061

[23:16] <dalek> 6model: 10019ac | jnthn++ | common/NQP/NQPSetting.pm:

[23:16] <dalek> 6model: Start to add multi variants to the NQPSetting. Seems that even though we've no inlining or caching, we still manage to win over the coercions from before.

[23:16] <dalek> 6model: review: http://github.com/jnthn/6model/commit/10019acd6c3713b3b742cc2063e36c160aabfefb

[23:16] <tylercurtis> jnthn: I started working on a Go runtime for your prototype. Unfortunately, I can't figure out how to sanely write a Makefile for complicated Go projects. Also, Go doesn't support dynamic loading so I'm not really sure how I could load a setting anyway.

[23:16] <jnthn> tylercurtis: Oh. :-(

[23:16] <tylercurtis> Oh, well. It's been informative. :)

[23:16] *** tadzik left
[23:16] <jnthn> Well, I guess that approach...doesn't Go. :-/

[23:17] <jnthn> Yes, having to work out early on how to handle having a setting is kind of a man or boy test for targets.

[23:17] *** orafu left
[23:17] <jnthn> I wonder how much mberends++ will have at that point. :-)

[23:17] *** orafu joined
[23:23] <sorear> there's something kind of funny about an IRC discussion mediated entirely by tellbots.

[23:24] <jnthn> Email is just not cool though. ;-)

[23:27] <sorear> I thought the cool kids were using Twitter and SMS these days

[23:27] *** Trashlord left
[23:28] <jnthn> Oh, heck knows. I'm just not cool enough any more. :-)

[23:28] <tylercurtis> ingy: Are you around?

[23:34] *** moritz__ joined
[23:34] *** moritz_ left
[23:53] <dalek> 6model: 3446bc2 | jnthn++ | dotnet/runtime/ (3 files):

[23:53] <dalek> 6model: Optimize a couple of hot-paths, also reducing in less code. :-)

[23:53] <dalek> 6model: review: http://github.com/jnthn/6model/commit/3446bc23d4a2210381e268a7d34a76ad53bfc022

[23:58] <sorear> Maybe I should go back into the modules business.

[23:58] <dalek> niecza: 16c4aaa | sorear++ | / (2 files):

[23:58] <dalek> niecza: A few tweaks for ggoebel

[23:58] <dalek> niecza: 

[23:58] <dalek> niecza: (Who may not rest until he actually reports these bugs)

[23:58] <dalek> niecza: review: http://github.com/sorear/niecza/commit/16c4aaa1be1d45ae85a0772f0b2e3611086113d1

