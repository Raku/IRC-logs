[00:01] <PerlJam> what is DO ?

[00:06] *** mtk left
[00:07] <jnthn> sorear: I'm quite sure it's just a block in the normal flow of code execution.

[00:07] <jnthn> say 1; { say 2 }; say 3;

[00:07] <jnthn> is like (aside from the class decl

[00:07] <jnthn> say 1; class Foo { say 2 }; say 3;

[00:07] <jnthn> I think Rakudo has it that way too.

[00:08] <jnthn> And afaik it's spec. Or at least meant to be in there somewhere. :-)

[00:08] <TimToady> package blocks are at DO time

[00:08] <tylercurtis> rakudo: say 1; class Foo { say 2; } say 3;

[00:08] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "class Foo "‚ê§¬ª

[00:08] <tylercurtis> rakudo: say 1; class Foo { say 2; }; say 3;

[00:08] <p6eval> rakudo 7579f7: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[00:09] <TimToady> sorear: this is specced at S10:88

[00:14] <TimToady> anything that wants run at some other time than DO time should be in a phaser

[00:14] <TimToady> but pretty much everything important about a class should be expressed by declarations within the class, not the normal code

[00:22] <cognominal> thx jnthn for your 22:27 answer

[00:23] <PerlJam> so DO time is "normal execution time"?

[00:23] *** skids left
[00:25] *** skids joined
[00:27] <PerlJam> (ack -wa DO of the synopses doesn't return any results)

[00:27] <TimToady> well, it's "do" not "DO"...

[00:28] *** aubreyja_ joined
[00:33] <sorear> I see.

[00:33] <sorear> perl6: my class Foo { ... }; Foo.new.say; my class Foo { };

[00:33] <p6eval> rakudo 7579f7: OUTPUT¬´too few positional arguments: 1 passed, 2 (or more) expected‚ê§  in main program body at line 1‚ê§¬ª

[00:33] <p6eval> ..pugs:  ( no output )

[00:33] <sorear> Is that legal?

[00:34] * sorear is quite hoping "no"

[00:34] <TimToady> std: my class Foo { ... }; Foo.new.say; my class Foo { };

[00:34] <p6eval> std 31614: OUTPUT¬´ok 00:01 111m‚ê§¬ª

[00:34] *** ashleydev left
[00:35] <tylercurtis> std: my $foo; $foo.say; my $foo;

[00:35] <p6eval> std 31614: OUTPUT¬´Potential difficulties:‚ê§  Useless redeclaration of variable $foo (see line 1) at /tmp/FWZ7DOwJ5s line 1:‚ê§------> [32mmy $foo; $foo.say; my $foo[33m‚èè[31m;[0m‚ê§ok 00:01 108m‚ê§¬ª

[00:35] <arnsholt> Hmm. This given/when stuff was easier than I'd thought

[00:35] <TimToady> tylercurtis: the ... makes it a stub decl

[00:35] <tylercurtis> TimToady: Ah, right. Didn't notice the ...

[00:36] *** ashleydev joined
[00:36] <arnsholt> rakudo: given 5 -> $x, $y { say "alive!" } # Hmm...

[00:36] <p6eval> rakudo 7579f7: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in main program body at line 2:/tmp/pMCr7Cye66‚ê§¬ª

[00:36] <sorear> TimToady: std accepts it because the stub makes it in scope.  I'm just imagining that, until the real decl, ::Foo is a Failure

[00:39] <pugssvn> r31615 | lwall++ | [STDeco] start transitioning to {*} proto stubs 

[00:39] <pugssvn> r31615 | (when bootstrapped and stable, we'll switch from the current {{*}} to {*})

[00:39] <pugssvn> r31615 | implement 'also' declarator, and attach 'also of' trait to proper $*DECLARAND

[00:39] <pugssvn> r31615 | $*OFTYPE is now only used to preserve the 'of' type of a scope declarator until there is a declarand

[00:40] *** aubreyja_ left
[00:40] <TimToady> sure, but it's expected that the real Foo must be defined later at compile time, and most code runs at run time

[00:40] <TimToady> it's always going to fail to access something at compile time that isn't defined yet...

[00:47] <pugssvn> r31616 | lwall++ | [STD] now that reboot is stable, change {{*}} proto stubs to {*} 

[00:52] <sorear> TimToady: Am I correct that $STD::ALL is mostly a memory usage hack?

[00:53] <TimToady> no, it's primarily to break the OUTER:: cycles

[00:54] <sorear> that's what I meant

[00:54] <TimToady> :)

[00:55] <TimToady> but you have to minimally remember all the lexical scopes around YOU_ARE_HERE in the .syml

[00:56] <TimToady> and having them all is useful for debugging

[00:59] <lue> afk

[01:00] <pugssvn> r31617 | lwall++ | [STDeco] transit CORE and lib/Test to {*} stubs 

[01:01] <sorear> what I want to do is to separate STD.pm6 from the current module system

[01:01] <sorear> because the syml stuff appears to be pretty dependant on p5 semantics

[01:10] <sorear> literal: Where in grok is the code which does line wrapping?

[01:13] *** masonkramer left
[01:14] *** masonkramer joined
[01:14] *** masonkramer left
[01:14] *** ashleydev left
[01:15] *** skids left
[01:15] <literal> sorear: either Pod::Text (Perl 5 Pod) or Perl6::Perldoc (Perl 6 Pod)

[01:18] *** TiMBuS joined
[01:22] <sorear> literal: Where in Perl6::Perldoc?

[01:23] <literal> sorear: actually, I think Perl6::Perldoc doesn't do line-wrapping yet

[01:23] <sorear> so the fact that 'grok' output fits on my screen accurately even after format codes are excised is entirely accidental?

[01:24] <literal> most likely

[01:25] <sorear> Hmm.

[01:25] * sorear wants to add optional dark grey line number annotations to grok output

[01:27] <ingy> greetings

[01:27] <diakopter> .

[01:27] <sorear> ..

[01:28] <diakopter> welcome to our proudly humble abode

[01:29] *** skids joined
[01:29] *** justatheory joined
[01:29] <diakopter> .. in theory

[01:31] *** justatheory left
[01:35] *** whiteknight left
[01:38] *** ashleydev joined
[01:40] *** PenThrive joined
[01:47] *** aubreyja joined
[01:50] *** aubreyja is now known as aubreyja_

[01:51] *** aubreyja_ is now known as aubreyja

[01:56] <sorear> TimToady: would it be reasonable to rename Stash, NAME, etc to STD:: and CursorBase, RE_ast, etc to Cursor::?

[02:05] * sorear contemplates what STD would look like if it were purged of backtracking (every subrule either returns exactly one cursor or .panics)

[02:19] *** khb joined
[02:21] *** isBEKaml joined
[02:22] *** aubreyja left
[02:23] *** PZt joined
[02:24] <TimToady> Perl 6 requires backtracking

[02:25] <TimToady> yes, the internal type could be renamed

[02:25] <TimToady> *typs

[02:25] <TimToady> *e

[02:39] <ingy> does rakudo have a perl -I... equiv?

[02:42] <ingy> looks like PERL6LIB works at least

[02:45] *** masonkramer joined
[02:57] <TimToady> I don't think there's a -I

[03:04] *** aubreyja joined
[03:06] <lue> rakudo: class B { has $.a is 0..0xFF }; B.new.a = 300;

[03:06] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 20‚ê§¬ª

[03:07] *** aubreyja left
[03:07] <lue> can you place limits on attributes?

[03:15] <lue> .oO(I suppose one could modify the attribute's accessor...)

[03:21] *** sftp left
[03:22] <sorear> lue: you can spell that 'has uint8 $.a'

[03:22] <sorear> generally speaking you (currently) do that using subset types

[03:23] <sorear> power-of-power-of-two-minus-one subsets are predefined

[03:23] <tylercurtis> rakudo: class B { has $.a where 0 <= * <= 255 }; B.new.a = 300;

[03:23] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 20‚ê§¬ª

[03:24] <sorear> (at some point I'm going to drag stevan in here and get a real attribute system forward-ported, but that's not likely to be soon)

[03:24] <tylercurtis> rakudo: class B { has $.a where 0 <= * <= 255; }; B.new.a = 300;

[03:24] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 20‚ê§¬ª

[03:24] <tylercurtis> rakudo: class B { has $.a where {0 <= $_ <= 255}; }; B.new.a = 300;

[03:24] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 20‚ê§¬ª

[03:25] <lue> rakudo: class B { has uint8 $.a }; B.new.a = 300;

[03:25] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Malformed has at line 20, near "uint8 $.a "‚ê§¬ª

[03:25] <lue> too bad all the sized ints are NYI and their existence is dependant on Parrot (IIRC)

[03:26] <lue> rakudo: class B { has $.a where 0..0xFF }; B.new.a = 300;

[03:26] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 20‚ê§¬ª

[03:26] <TimToady> rakudo: class B { has $.a of Any where 0..0xFF is rw }; B.new.a = 300

[03:27] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 20‚ê§¬ª

[03:27] <TimToady> std: class B { has $.a of Any where 0..0xFF is rw }; B.new.a = 300

[03:27] <p6eval> std 31617: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row at /tmp/IDUK2e7eBS line 1:‚ê§------> [32mclass B { has $.a of Any where 0..0xFF [33m‚èè[31mis rw }; B.new.a = 300[0m‚ê§    expecting any of:‚ê§  bracketed infix‚ê§  constraint‚ê§       infix or meta-infix‚ê§      statement modifier

[03:27] <p6eval> ..loop‚ê§Parse failed‚ê§FAILE‚Ä¶

[03:27] <TimToady> std: class B { has $.a where 0..0xFF is rw }; B.new.a = 300

[03:27] <p6eval> std 31617: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row at /tmp/QxVDAXfpfl line 1:‚ê§------> [32mclass B { has $.a where 0..0xFF [33m‚èè[31mis rw }; B.new.a = 300[0m‚ê§    expecting any of:‚ê§ bracketed infix‚ê§  constraint‚ê§       infix or meta-infix‚ê§      statement modifier loop‚ê§Parse

[03:27] <p6eval> ..failed‚ê§FAILED 00:01‚Ä¶

[03:27] <lue> it's not specced, but methinks it should be legal (it's already doable in parameters)

[03:28] <TimToady> std: class B { has $.a where 0..0xFF }; B.new.a = 300

[03:28] <p6eval> std 31617: OUTPUT¬´ok 00:01 111m‚ê§¬ª

[03:28] <tylercurtis> std: class B { has $.a is rw where 0..0xFF }; B.new.a = 300

[03:28] <p6eval> std 31617: OUTPUT¬´ok 00:01 111m‚ê§¬ª

[03:29] <sorear> lue: approximately seven years ago, TimToady decided what was wrong with the Perl 5 object system and created a new one.

[03:29] <sorear> Two things have happened with this.

[03:29] <sorear> Perl 6 has the old version, which has seen nearly no improvement over that time

[03:30] <TimToady> rakudo: subset u8 where 0..255; class B { has u8 $.a is rw }; B.new.a = 300;

[03:30] <sorear> The Moose people have backported it to Perl 5 and have been improving it for all this time

[03:30] <p6eval> rakudo 7579f7:  ( no output )

[03:30] <TimToady> some of that is merely to tailor it to the idiosyncracies of p5, and not applicable

[03:30] <TimToady> I'd like to see a list of what you think isn't in that category

[03:31] <sorear> If the current Perl 6 object system looks like a dusty prototype which has been unprioritized for seven years, that's because it has been

[03:31] <sorear> anonymous types

[03:31] <sorear> triggers

[03:31] <sorear> method modifiers

[03:31] <sorear> runtime class creation by API

[03:32] <sorear> representation traits

[03:32] <isBEKaml> for instance, one thing I find confusing in the current object system in rakudo is we can instantiate from objects (I might be wrong in phrasing this though)

[03:32] <TimToady> I think you're reading some of rakudo's limitations as Perl 6's limitations

[03:32] <TimToady> anon types are no problem

[03:32] <TimToady> triggers and method modifiers can be done

[03:33] <isBEKaml> rakudo: class A { has $.x is Int}; my $foo = A.new; my $bar = $foo.new; # is this right? 

[03:33] <sorear> how do you define an attribute with an anonymous type?

[03:33] <p6eval> rakudo 7579f7:  ( no output )

[03:33] <TimToady> bind it to ::T

[03:33] <tylercurtis> rakudo: class Foo { }; my $f = Foo.new;  say $f.new.WHAT =:= $f.WHAT

[03:33] <p6eval> rakudo 7579f7: OUTPUT¬´1‚ê§¬ª

[03:33] <lue> .oO(I saw masak do that!)

[03:33] <TimToady> roles are full of anonymous types

[03:34] <sorear> Our object system has no batteries

[03:34] <sorear> It's all extensibility and no features

[03:35] <TimToady> you do like to overstate things, dontchya?  :)

[03:35] <isBEKaml> I think saying $foo.new is pretty confusing imho. Objects are created from prototypes(classes) unless you're cloning another object. So .new is misleading here. 

[03:35] *** kev joined
[03:35] <lue> TimToady: should I be able to use where on attributes in roles/classes ?

[03:35] <TimToady> yes

[03:35] *** kev left
[03:35] <TimToady> that's a rakudo nyi

[03:37] <sorear> Actually, my root problem is that I want an 'after' keyword built in

[03:37] <TimToady> also, some of the design philosophy is to let the implementations discover what they need behind .HOW and negotiate something cross-platform.

[03:37] <sorear> not necessarily with the same spelling

[03:37] <TimToady> you can .wrap any routine

[03:37] <TimToady> including a method

[03:37] <sorear> TimToady: of course.  I'm not saying drop everything right now

[03:37] <TimToady> and your carping is part of the negotiation process :)

[03:38] <sorear> but I don't want lue to think that the object system we have now is final

[03:38] <TimToady> but repr hooks have been envisioned from the start

[03:38] <sorear> the perl 6 object system is going to be much more awesome than it is now

[03:38] <sorear> despite the fact that some people seem to think it

[03:38] <sorear> 's perfect as is.  imagination, use it

[03:39] <TimToady> gee, now you tell me, after ten years...  :P

[03:40] <sorear> anyways.

[03:40] <TimToady> the main point of the .HOW barrier is to let the language stabilize on top while we're still experimenting underneath

[03:40] <TimToady> we encapsulate repr even from the casual user

[03:40] <TimToady> that's very important, i think

[03:41] <isBEKaml> tylercurtis: I wasn't aware of =:=. But I was thinking when doing $foo.new, we were cloning the object. :)

[03:41] <isBEKaml> tylercurtis: my point still stands, it's misleading! 

[03:41] <TimToady> feel free to play with anything on the other side of .HOW; we want that

[03:41] <sorear> I think that the single biggest difference between the Moose and P6 metamodels is that the Moose repr and how are the same object

[03:41] <sorear> I'm not sure if this is a good thing

[03:42] <TimToady> P6 is completely agnostic on that subject

[03:42] <TimToady> so we can try it both ways

[03:42] <TimToady> ruoso++ was playing with separate RIs for smop

[03:43] <tylercurtis> isBEKaml: I agree. On the other hand, sometimes I really like that all the methods of the proto-object are available on any object of the class.

[03:43] <sorear> S12:0791 specs the ability of a single class to interact with multiple, ergo independant, reprs

[03:43] <isBEKaml> rakudo: class B { }; my $foo = B.new; say $foo.new =:= $foo; 

[03:43] <p6eval> rakudo 7579f7: OUTPUT¬´0‚ê§¬ª

[03:44] <sorear> I've also come to the conclusion that the reasonable way to think about protoobjects is as an instance of a nonstandard repr, so every class gets to use at least two of them

[03:44] <TimToady> jnthn++ and I were discussing that earlier today, and I was telling him we could restrict that for efficiency

[03:45] <TimToady> that's kinda how words work in natural language too

[03:46] *** xinming joined
[03:46] <TimToady> in tagmemics any given syntax structure can have multiple interpretations simultaneously depending on context

[03:46] *** xinming left
[03:46] <lue> rakudo: my $a where 0..0xFF; $a = 999;

[03:46] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "my $a wher"‚ê§¬ª

[03:47] *** xinming joined
[03:47] <isBEKaml> tylercurtis: if we want all methods of proto-object available, I think we should be doing clone() , not .new - if I'm not wrong.. 

[03:47] <lue> rakudo: sub xyzzy($a where 0..0xFF) { say $a }; xyzzy(390)

[03:47] <p6eval> rakudo 7579f7:  ( no output )

[03:48] <isBEKaml> tylercurtis: of course, that would limit the new object to be just using the attribute values that were available in the cloned object. 

[03:49] <tylercurtis> isBEKaml: Sometimes, being able to get at "class" methods conveniently from the instance is quite nice.

[03:50] <isBEKaml> tylercurtis: $object.^methods ? 

[03:50] <lue> (I'm assuming 'where' is a trait.)

[03:50] <TimToady> it's officialy a post_constraint

[03:50] <tylercurtis> Of course, you can always do $obj.WHAT.foo(I think this is the correct way).

[03:53] <isBEKaml> tylercurtis: huh, why wouldn't $obj.foo() work? Unless I'm mistaken, class methods and object methods are the same... :|

[03:53] <tylercurtis> Right.

[03:53] <tylercurtis> isBEKaml: but, I'm saying, that sometimes I like being able to do that.

[03:54] <isBEKaml> tylercurtis: following class hierarchy, the compiler would be able to resolve methods present in several parent classes.. 

[03:54] <lue> .oO(not exactly easy to find an exisiting implementation of where in Rakudo)

[03:56] <tylercurtis> Another benefit of not having a class/instance method distinction is that for classes where the users of that class will often not care about specific instances(e.g., a Compiler implemented as a class internally to store various of information in attributes), you can more easily allow them to be called either as Foo::Compiler.compile($source) or Foo::Compiler.new.compile($source), just by sticking "self.new.compile($source) unless self.defined" at the 

[03:56] <tylercurtis> beginning of the compile method.

[03:56] <isBEKaml> lue Grammar.pm I think (not sure)

[03:56] *** juster joined
[04:00] *** PZt left
[04:00] <isBEKaml> tylercurtis: that took me sometime to understand. :)

[04:04] <isBEKaml> tylercurtis: you're saying that we just abstract away the instantiations within method implementations? Sure, we can do that. But not doing that would lead to GC problems, I think. I'd rather avoid having to take care of such things. A clear demarcation between objects and classes would be preferable when it comes to instantiating new objects. 

[04:05] <tylercurtis> isBEKaml: I agree that being able to do SomeClass.new.new.new.new.new.new.WHAT.new.new.WHAT.WHAT.WHAT.new.new is confusing, but on the other hand, the class/instance method non-distinction can clarify code sometimes.

[04:06] *** justatheory joined
[04:07] <lue> my $a = 3; say $a.WHAT.WHAT

[04:07] <lue> rakudo: my $a = 3; say $a.WHAT.WHAT

[04:07] <p6eval> rakudo 7579f7: OUTPUT¬´Int()‚ê§¬ª

[04:07] <isBEKaml> tylercurtis: I think it was always there. instance objects take to class object methods easily as they don't have their own independent method definitions, unless augmented with MONKEY_TYPING. 

[04:08] <tylercurtis> isBEKaml: For example, in my say-call-without-parentheses-on-arguments-that-are-positive-integers-with-singly-assigned-lexicals(although "lexical" don't really mean much when you don't have any way to create a new scope :) to LLVM compiler; the SIC::Compiler class keeps some internal variables for things like the numeric suffix for temporary variable names in the generated code. So, you need to create a new SIC::Compiler object to compile any code with

[04:08] <tylercurtis> However, most uses of the SIC::Compiler class are going to consist of "SIC::Compiler.new.compile($the-source-code)". So, at the beginning of the compile method, I use self.defined to check if self is undefined(and thus, in my class's case, at least, is the proto-object), and return the result of calling the method with the same arguments on a newly-created SIC::Compiler object just as if you had done "SIC::Compiler.new.compile($the-source-code)", even 

[04:08] <tylercurtis> though you just did "SIC::Compiler.compile($the-source-code)".

[04:10] <tylercurtis> I could still do that if Perl 6 had separate class and instance methods, but it would be less convenient. I'd have to write a separate class method instead of just sticking the one "return self.new.compile($source) unless self.defined;" line at the beginning.

[04:15] <isBEKaml> tylercurtis: I agree with you there. self.method-name()  is not too different from doing this.method-name() in other languages - apart from the fact that the method call happens only within the object's own blueprint of the class' method. 

[04:22] <isBEKaml> tylercurtis++ # I now see what he was driving at.. 

[04:25] <tylercurtis> I'm not really decided on whether I agree with not having the distinction yet, but I'm definitely finding myself doing stuff like that far more often in Perl 6(and even in NQP) where the method works on either the proto-object or the instance than in other languages.

[04:26] <tylercurtis> And that sentence of mine was badly ordered. put in Perl(and even in NQP) just before "than in other languages" in your mind if it sounds incoherent.

[04:27] <isBEKaml> tylercurtis: self.new has no (AFAIK) equivalent in other languages and offers an advantage here in P6. However, we do object.getClass().newInstance() in Java. 

[04:28] <isBEKaml> tylercurtis: so we always get the class method first. 

[04:28] <tylercurtis> isBEKaml: right. Other languages can do it. Although, it's not always obvious how or if a language can do some of the things that the unity of "class" and "instance" methods in Perl 6 allows.

[04:29] <tylercurtis> In Smalltalk, I hadn't even realized that class methods inherited until just now when I checked, but with Perl 6, it's obvious that "class" methods are inheritable.

[04:30] <isBEKaml> tylercurtis: Java has the concept of Reflection that is not quite obvious/intuitive. Some programmers use it (mostly library developers), most would just avoid it. You have to jump through to get at what you want here. 

[04:32] <isBEKaml> tylercurtis: the non-distinguishable nature of class/object methods are somewhat problematic when done incorrectly. (I had referred to GC issues before). I think Perl should just the Right Thing when it sees one. 

[04:33] <isBEKaml> tylercurtis: duh.. sorry if I'm being somewhat incoherent. Please let me know.. 

[04:33] <tylercurtis> In one of my projects in NQP(it's my GSoC project, in fact), I use a helper class to implement the Tree::Pattern.transform method, which descends through a tree and transforms, using a supplied sub, any parts of the tree that match the pattern. However, I want to be able to create subclasses of both the pattern class and the helper class with additional functionality(for example, to traverse tree subtypes).

[04:34] <tylercurtis> So, I did the obvious thing and created a method on the parent class that returns the appropriate helper class.

[04:36] <tylercurtis> Conveniently, I can also call the method on the class to find out what its helper class is.

[04:38] <tylercurtis> It logically feels like a property(not in the "attribute"/"class/instance variable" meaning of the word, but in the "something that describes something") of the class, but it's more convenient to call on the instance in most cases. Best of both worlds. :)

[04:40] *** justatheory left
[04:43] <isBEKaml> Right. :) I think we should restrict the use of class methods to `self` alone and using it on objects are somewhat misleading. 

[04:43] <isBEKaml> doing self.new.method looks cleaner than $obj.new.method. 

[04:44] <isBEKaml> But I guess that would lead to problems in implementation. How do we do $obj.WHAT? Related, we are doing this reflectively... I have no answer.. :)

[04:47] <isBEKaml> tylercurtis: where can I find out about your GSoC project? URL? 

[04:50] <isBEKaml> tylercurtis: I'm looking at this. http://trac.parrot.org/parrot/browser/branches/gsoc_past_optimization/docs/user/library

[04:58] *** rv2733 joined
[05:03] <tylercurtis> isBEKaml: that's it. I moved it to http://github.com/ekiru/tree-optimization this weekend so that it's easier for people to try.

[05:04] <tylercurtis> It's also available via plumage("./plumage install tree-optimization").

[05:04] *** ashleydev_ joined
[05:06] *** ashleydev left
[05:06] *** ashleydev_ is now known as ashleydev

[05:10] <tylercurtis> isBEKaml: certain parts of it aren't fully documented(in part because I've got some significant refactors planned for some of those parts and didn't want to have to write and then soon after rewrite it :).

[05:12] <isBEKaml> tylercurtis: ty. But that's alright. I just wanted to look at what you were doing, not necessarily understand it. ;)

[05:17] <tylercurtis> More things about it to look at are available at http://www.parrot.org/blog/839 , where I've been posting blog posts weekly-ish that have varied from tutorials to descriptions of APIs I was planning to implement to simple descriptions of what I've done for the week.

[05:21] <isBEKaml> tylercurtis: great! that's nice. :)

[05:22] *** PZt joined
[05:22] <tylercurtis> I'll probably be posting another sometime tomorrow, too. :) It's always nice when people sound like they're interested in one's project. :)

[05:23] <isBEKaml> I don't know how that feels. I'm yet to get my own project up. :)

[05:25] <isBEKaml> I'm currently trying to understand parrot and rakudo. So my project won't be up anytime soon. ;)

[05:31] <isBEKaml> tylercurtis: can you tell me what other optimisations are you targeting apart from tailcall recursions? 

[05:31] *** masonkramer left
[05:32] <isBEKaml> tylercurtis: I believe there might be more since your first post about PAST Optimizations. :)

[05:34] <sorear> apparently, now that ibus + anthy are working, my compose key /isn't/

[05:35] *** ashleydev left
[05:37] *** redicaps joined
[05:37] <tylercurtis> isBEKaml: Well, I've mostly been working on the infrastructure, so far, but I've got a working optimization for some tail-calls with an explicit return in NQP-rx(extending it further is blocking on better understanding of PAST::Op(:pasttype<call>) and :pirop<tailcall> nodes), and a prototype of very basic constant-folding of Integer addition for NQP-rx. I've also done quite a bit of constant-folding for PIRATE(which is a PIR compiler written in NQP wit

[05:37] <tylercurtis> PCT).

[05:39] *** hercynium left
[05:39] <tylercurtis> Most of the rest of my GSoC is scheduled for implementing specific optimizations, and I have a list somewhere of some possible ones to work on, so expect to see more coming soon. Another thing I might attempt to do is some sort of transformation from PAST to some kind of SSA form to make optimizations simpler.

[05:43] *** rv2733 left
[05:44] *** Mowah joined
[05:49] * tylercurtis sleep 28800 &

[05:49] *** tylercurtis left
[06:45] *** cono left
[06:48] *** redicaps left
[06:55] *** cono joined
[06:59] *** Mowah left
[07:05] <sorear> perl6: say class Foo { ... }

[07:05] <p6eval> pugs: OUTPUT¬´*** No such subroutine: "&class"‚ê§    at /tmp/KFCnPQxcsT line 1, column 5 - line 2, column 0‚ê§¬ª

[07:05] <p6eval> ..rakudo 7579f7: OUTPUT¬´‚ê§¬ª

[07:06] <sorear> rakudo: say (class Foo { ... }).WHAT

[07:06] <p6eval> rakudo 7579f7: OUTPUT¬´error:imcc:syntax error, unexpected '\n'‚ê§  in file 'EVAL_1' line 76‚ê§===SORRY!===‚ê§syntax error ... somewhere‚ê§¬ª

[07:06] <sorear> what.

[07:06] *** xinming left
[07:07] <isBEKaml> rakudo: say { class Foo {} }.WHAT; 

[07:07] <p6eval> rakudo 7579f7: OUTPUT¬´Block()‚ê§¬ª

[07:08] <isBEKaml> rakudo: say { (class Foo {}).WHAT }

[07:08] <p6eval> rakudo 7579f7: OUTPUT¬´_block64‚ê§¬ª

[07:08] <isBEKaml> class Foo {} doesn't seem to be treated as an expression in a saycall. 

[07:09] <isBEKaml> rakudo: say ({ class Foo {} }).WHAT; 

[07:10] <p6eval> rakudo 7579f7: OUTPUT¬´Block()‚ê§¬ª

[07:18] <isBEKaml> rakudo: say (class Foo{}.new.WHAT)

[07:18] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Illegal redeclaration of symbol 'Foo'‚ê§¬ª

[07:25] <isBEKaml> rakudo: say ((class Quux{}).WHAT)

[07:25] <p6eval> rakudo 7579f7: OUTPUT¬´Code()‚ê§¬ª

[07:27] *** mulander left
[07:39] *** tedv left
[08:03] <moritz_> good morning

[08:05] <isBEKaml> moritz_: good morning! at Hackathon? :)

[08:05] <moritz_> nope

[08:06] <sorear> good morning moritz_

[08:06] <sorear> (is the _ part of your name?  You seem to use it unusually often here)

[08:07] <moritz_> sorear: the 'moritz' nick is registered on freenode, so I settled with moritz_ here permanently

[08:07] <moritz_> and registered it

[08:16] *** meppl joined
[08:19] <moritz_> speaking of freenode... the FAQ says that if somebody hasn't logged in for three month, it's possible to request that their nick is being freed

[08:19] <moritz_> can I find out what was the last login date of a given nick?

[08:19] <dalek> niecza: b125222 | sorear++ |  (3 files):

[08:19] <dalek> niecza: Implement a system of auxilliary stacks

[08:19] <dalek> niecza: Replaces the old ad-hoc handling of protopads.

[08:19] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b1252221ee3d6580916efd958af48dfd72aeb21d

[08:19] <dalek> niecza: 7943914 | sorear++ |  (4 files):

[08:19] <dalek> niecza: More steps towards class decls.  Allow lexget et al to directly access 

[08:19] <dalek> niecza: protopads.

[08:19] <dalek> niecza: review: http://github.com/sorear/niecza/commit/794391454e4f93a1d153e5b4f2cfd0b53aae06b3

[08:19] <dalek> niecza: 13b25f8 | sorear++ |  (7 files):

[08:19] <dalek> niecza: Add class statements

[08:19] <dalek> niecza: review: http://github.com/sorear/niecza/commit/13b25f8c15ac047e5043559cbd2f6ef3eff60983

[08:20] *** xinming joined
[08:22] <TiMBuS> moritz_, /ns info moritz

[08:22] <TiMBuS> Last seen  : Mar 23 20:57:22 2010 (15 weeks, 4 days, 11:24:19 ago)

[08:22] <moritz_> TiMBuS: thanks

[08:22] <TiMBuS> its an 8 year old nick tho, so

[08:23] <TiMBuS> yeah you might be stuck with the _

[08:25] <sorear> 03:24 [freenode] -!- moritz [~moritz@p579F9664.dip.t-dialin.net]

[08:25] <sorear> 03:24 [freenode] -!-  ircname  : Moritz Lenz

[08:25] <sorear> 03:24 [freenode] -!- moritz_ [moritz@faui2k3.org]

[08:25] <sorear> 03:24 [freenode] -!-  ircname  : Moritz Lenz

[08:25] <sorear> there are 2 active freenode connections here

[08:25] <moritz_> sorear: yes, just tired it...

[08:25] <moritz_> *tried

[08:25] <moritz_> sorear: the nick without the _ is registered by somebody else

[08:25] <sorear> according to the freenode FAQ, a nick is considered expired after 60 days without use

[08:26] <sorear> moritz qualifies almost twice over

[08:37] <sorear> what does also :foo<bar> mean

[08:38] * moritz_ doesn't quite understand 'also'

[08:39] <sorear> also is new, less confusing syntax for something old

[08:40] <sorear> class Foo { also is Bar; } # new

[08:40] <sorear> class Foo { is Bar; } # old

[08:40] <sorear> class Foo is Bar { } # old and new, equivalent

[08:40] <moritz_> I understood that much, but I don't see how it works, in terms of parsing or underlying semantics

[08:41] <sorear> it just lets you put traits inside the class body

[08:42] <sorear> if you don't want to put them in the header

[08:42] <sorear> no semantic or parsing changes required

[08:43] <moritz_> sounds like something you could achieve with a module too

[08:43] <sorear> with a module too?

[08:44] <moritz_> I mean, it sounds like it doesn't need to go into core Perl 6, IMHO

[08:45] <sorear> nope

[08:46] <sorear> 98% of the stuff in core Perl 6 doesn't need to be there, and this is no exception

[08:48] *** eternaleye left
[08:57] *** Ross joined
[08:58] *** Ross left
[08:59] *** Ross joined
[08:59] *** Ross left
[08:59] *** Ross joined
[08:59] *** Ross left
[09:07] *** Ross joined
[09:08] *** Ross left
[09:10] *** tadzik joined
[09:16] *** pmurias joined
[09:16] <pmurias> moritz_: ping

[09:16] <moritz_> pmurias: pong

[09:17] <pmurias> moritz_: still blocking on CHI?

[09:17] <moritz_> pmurias: yes

[09:17] <pmurias> comment the dependency out ;)

[09:17] <dalek> niecza: 53b6cdf | sorear++ |  (2 files):

[09:17] <dalek> niecza: Implement 'also'

[09:17] <dalek> niecza: review: http://github.com/sorear/niecza/commit/53b6cdf5586aadc50969522cf0e40fd921fa95b9

[09:17] <dalek> niecza: 6e9becd | sorear++ |  (4 files):

[09:17] <dalek> niecza: Implement superclasses for also

[09:17] <dalek> niecza: review: http://github.com/sorear/niecza/commit/6e9becd6c1e193901c7f0ad91fec6614d96c2306

[09:17] <dalek> niecza: 676bde0 | sorear++ |  (2 files):

[09:17] <dalek> niecza: Implement in-header trait syntax

[09:17] <dalek> niecza: review: http://github.com/sorear/niecza/commit/676bde067535c22a8030e08599eb797b259925a4

[09:17] <dalek> niecza: 8da9e3d | sorear++ |  (2 files):

[09:17] <dalek> niecza: With no explicit superclasses, automatically add an Any superclass

[09:17] <dalek> niecza: review: http://github.com/sorear/niecza/commit/8da9e3d4adabb5d7351630bf98b92bda30b033bc

[09:17] <dalek> niecza: 32d2ad5 | sorear++ | setting:

[09:17] <sorear> niecza just jumped from 5 classes to ~50

[09:17] <dalek> niecza: A bunch of stub classes

[09:17] <dalek> niecza: review: http://github.com/sorear/niecza/commit/32d2ad5968c60501a2a6b1b61853ed3b5e900dbc

[09:18] <sorear> since I've got class syntax working... took long enough.

[09:18] <moritz_> sorear: should I investigate setting niecza up on p6eval?

[09:19] <sorear> next up: methods.  then, control structures

[09:19] <sorear> moritz_: niecza is going to become much easier to set up very soon

[09:19] * pmurias notices perlito has a python backend

[09:20] <sorear> once I can use pmurias++'s STD dist instead of hardcoding a path to my pugs checkout

[09:20] <moritz_> sorear: then I'll wait... just tell me when you think it's time to add it

[09:20] <sorear> (yes, I have hardcoded paths in a public git repo.  I feel just a bit dirty for it.)

[09:20] <moritz_> pmurias: perlito seems to have quite a few backends :-)

[09:21] * sorear out.

[09:21] <pmurias> sorear: what do you need to use my STD dist?

[09:21] <pmurias> it use it for mildew currently

[09:22] <pmurias> s/it/i/

[09:23] <sorear> pmurias: it being announced and on CPAN, ideally

[09:24] *** Ross joined
[09:24] * sorear out for real.

[09:28] *** agentzh joined
[09:28] <pmurias> moritz_: what's the best way to have an optional dependency?

[09:29] <moritz_> pmurias: the META.yaml file has a "recommends" field, iirc

[09:29] *** azert0x joined
[09:29] *** azert0x left
[09:30] *** azert0x joined
[09:30] *** azert0x left
[09:30] <moritz_> oh, that's deprecated :/

[09:30] *** azert0x joined
[09:30] <pmurias> an optional dependency will show up as a prompt to the user? "do you want to install 1 optional dependency?"

[09:30] <pmurias> those are annoying

[09:30] <moritz_> http://search.cpan.org/~dagolden/CPAN-Meta-2.101670/lib/CPAN/Meta/Spec.pm#prereqs

[09:31] <moritz_> runtime => { recommends => { CHI => '0.35' } }

[09:31] <moritz_> no idea how installer handle it

[09:33] <pugssvn> r31618 | pmurias++ | [mildew] temporary disable the CHI dependency for moritz++ 

[09:33] <pmurias> moritz_: try installing now

[09:34] <pmurias> moritz_: i think i'll just move Mildew::Frontend::STD::Cached into a seperate package

[09:34] * moritz_ tries

[09:34] *** tadzik left
[09:35] <moritz_> Successfully installed Mildew-0.01

[09:35] <moritz_> what's next? SMOP?

[09:36] <pmurias> yes

[09:36] <moritz_> then.. Mildew-Setting-SMOP?

[09:36] <pmurias> yes

[09:37] <pmurias> moritz_: smop installed? :)

[09:37] <moritz_> yes

[09:37] <pmurias> good

[09:37] <moritz_> Mildew-Setting-SMOP too

[09:37] <moritz_> so, how do I run it? :-)

[09:37] <pmurias> mildew -e 'say 1' 

[09:37] <pmurias> it's installed into a non-default local::lib?

[09:37] <moritz_> ... and now I have to fix up @INC.

[09:38] *** tadzik joined
[09:39] <tadzik> http://wklej.org/id/363056/ can someone show me the way? (line #37)

[09:40] <moritz_> tadzik: try: method clear { $!z = 0; nextsame; }

[09:41] <pmurias> moritz_: eval $(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib)?

[09:41] <moritz_> pmurias: p6eval@debian:~$ ./mildew-install/bin/mildew

[09:41] <moritz_> Can't locate MildewCORE.lex in @INC (@INC contains: lib mildew-install/lib/perl5//x86_64-linux-gnu-thread-multi mildew-install/lib/perl5/ /etc/perl /usr/local/lib/perl/5.10.0 /usr/local/share/perl/5.10.0 /usr/lib/perl5 /usr/share/perl5 /usr/lib/perl/5.10 /usr/share/perl/5.10 /usr/local/lib/site_perl .) at mildew-install/lib/perl5//CursorBase.pm line 320.

[09:41] <moritz_> find mildew-install/ -name MildewCORE.lex # no result

[09:41] <pmurias> you installed Mildew-Setting-SMOP?

[09:41] <moritz_> yes

[09:41] <pmurias> that's bad

[09:42] * pmurias tried removing his local lib and installing everything on his box

[09:42] <moritz_> I can try again

[09:42] <pmurias> * tries

[09:42] <pmurias> moritz_: wait with that

[09:42] <moritz_> Successfully installed Mildew-Setting-SMOP-0.01

[09:43] <pmurias> nopaste the ~/.cpanm/build.log?

[09:44] <pmurias> (hint App::Nopaste is really usefull)

[09:45] <moritz_> pmurias: http://nopaste.snit.ch/21931

[09:47] <moritz_> tadzik: http://nopaste.snit.ch/21932

[09:48] *** Trashlord left
[09:48] <pmurias> hmm

[09:49] <pmurias> moritz_: i found a different bug in Mildew-Setting-SMOP

[09:49] *** Trashlord joined
[09:49] <pmurias> moritz_: can you find Mildew and SMOP filed in mildew-install?

[09:50] <moritz_> mildew-install/lib/perl5/Mildew/Setting/SMOP.pm

[09:50] <moritz_> mildew-install/lib/perl5/SMOP.pm

[09:51] <moritz_> when looking for SMOP.pm

[09:51] <pmurias> moritz_: STD.pmc?

[09:51] <moritz_> mildew-install/lib/perl5/Mildew.pm

[09:51] <moritz_> mildew-install/lib/perl5/STD.pmc

[09:55] <pmurias> moritz_: what i suspect is the Build process die'ing because of badly set @INC

[09:56] <pmurias> dzil build;cd Mildew-Setting-SMOP;perl Build.pl;perl Build

[09:56] <pmurias> should return more info

[09:56] <pmurias> cd Mildew-Setting-SMOP-0.1

[09:56] <pmurias> * 0.01

[09:57] * pmurias fixes an other bug in the build process...

[09:59] <moritz_> rakudo: die 2

[09:59] <p6eval> rakudo 7579f7: OUTPUT¬´2‚ê§  in main program body at line 20:/tmp/iWSoE1QX01‚ê§¬ª

[09:59] <tadzik> moritz_: so before would be { nextsame; $.z = 0 } ?

[10:01] <moritz_> tadzik: actually it's the other way round

[10:01] <tadzik> or no, that'd be after

[10:01] <tadzik> yep

[10:01] <tadzik> then around is just a method with nextsame() in the middle. Makes sense, even better than in Moose

[10:02] <moritz_> nextsame just calls the next available method with the same name, and the same parameters as the current method

[10:02] <tadzik> so it looks up the parent class, the roles etc?

[10:03] <moritz_> and multi methods from the same class, if applicable

[10:03] <tadzik> mhm

[10:03] <moritz_> roles are flattened into classes at composition time, so they don't need to be considered specifically

[10:04] <tadzik> I see. Thanks, moritz_++

[10:04] <moritz_> you're welcome

[10:04] <moritz_> you can also specifically call a method from another class

[10:04] <moritz_> so self.Point::clear()

[10:14] <arnsholt> Right, my given/when for NQP is pretty much done

[10:14] <arnsholt> I got commit access to the repo at some point, so does pushing the branch to Github sound like a resonable way to submit it for review?

[10:24] *** isBEKaml left
[10:26] <moritz_> yes

[10:27] <arnsholt> Excellent

[10:30] <arnsholt> And done

[10:30] <moritz_> arnsholt++

[10:44] *** timbunce joined
[10:48] <TiMBuS> if i add two roles and they have a conflicting method, is there a way to disambiguate? or does the flattening make this not possible

[10:52] <TiMBuS> Method 'dothing' collides and a resolution must be provided by the class

[10:52] <TiMBuS> oh ok

[10:52] <TiMBuS> that warning isnt thrown when using 'but'

[10:53] <TiMBuS> or, i guess, any kind of runtime composition

[10:58] *** whiteknight joined
[11:07] <pugssvn> r31619 | colomon++ | [t/spec] Update fudging. 

[11:07] *** colomon joined
[11:09] *** tadzik left
[11:09] *** agentzh left
[11:25] <pugssvn> r31620 | pmurias++ | [mildew] fix a bug in the build process 

[11:25] <pmurias> moritz_: maybe that will help with the installation of mildew (install mildew and mildew-setting-smop again)

[11:37] <pugssvn> r31621 | pmurias++ | [mildew] add basic tests that check if Mildew-Setting::SMOP builds correctly 

[11:40] *** colomon left
[11:52] <moritz_> pmurias: #   Failed test at t/01-tmp-is-created.t line 2

[11:52] <moritz_> all 6 subtests fail

[11:53] *** Guest38594 joined
[11:53] *** Guest38594 is now known as pragma_

[11:53] <pmurias> moritz_: dzil build

[11:53] <pmurias> moritz_: in Mildew-Setting-SMOP

[11:53] <pmurias> then perl Build.pl

[11:53] <pmurias> then perl Build

[11:54] <pmurias> and perl Build test

[11:54] <pmurias> that will allow us to see when do the errors happen

[11:55] <moritz_> doesn't reveal more details

[11:55] <moritz_> building works

[11:55] <moritz_> the test doesn't

[11:56] <moritz_> no error messages except for "Failed test..."

[11:56] <szabgab> I understand proto is now out and one should use pls ?

[11:56] <szabgab> where is pls ?

[11:56] <pmurias> moritz_: is tmp created

[11:56] <pmurias> ?

[11:57] <moritz_> szabgab: pls is only a proof-of-concept so far

[11:57] <pmurias> moritz_: run the test manually

[11:57] <moritz_> szabgab: so continue running proto for now

[11:57] <moritz_> no tmp/ created

[11:57] <moritz_> that's why the test fails :-)

[11:58] <moritz_> szabgab: and FYI, 'pls' is a branch in the proto repo

[11:58] <pmurias> moritz_: perl -MSTD works?

[11:58] <szabgab> ty

[11:59] <pmurias> moritz_: make sure you don't have the STD from src/perl6 in your @INC

[11:59] <moritz_> ugh, I had a relative path in PERL5LIB

[11:59] <moritz_> which didn't work out for installing Mildew

[12:00] <moritz_> pmurias: now perl -MSTD -e 1 works, but no tmp created

[12:00] <pmurias> you ran perl Build again

[12:00] <moritz_> yes

[12:03] <pugssvn> r31622 | pmurias++ | [mildew] remove a file which crept up into the repo 

[12:03] <pmurias> Mildew-Setting-SMOP-0.01.tar.gz was creted by dzil build?

[12:03] <pmurias> * created

[12:03] <moritz_> pmurias: yes, that's where I run perl Build.PL

[12:04] <pmurias> an old one crept into the repo so that's why i ask

[12:04] <moritz_> btw is the 'diff' file there on purpose?

[12:04] * moritz_ tries again

[12:05] <moritz_> still no tmp

[12:06] <pugssvn> r31623 | pmurias++ | [mildew] remove trash found by mortiz++ 

[12:06] <pmurias> moritz_: check if ACTION_code is called by inc/MyBuilder.pm

[12:06] <pmurias> inserting a warn should do

[12:07] * pmurias updates Module::Build

[12:08] <moritz_> pmurias: it is not

[12:09] * moritz_ has Module::Build version 0.3603

[12:11] * pmurias has 0.3607

[12:12] <pmurias> moritz_: try perl Build code?

[12:13] <moritz_> seems like a noop

[12:13] <szabgab> moritz_: looking at the book I see some of the chapeters in src/ that are not included in the Makefile , is that on purpose?

[12:14] <pmurias> moritz_: that's worring

[12:14] <pmurias> moritz_: could you nopaste your Build.PL

[12:14] <pmurias> ?

[12:14] <moritz_> szabgab: afaict only builtins.pod shouuld not be included

[12:15] <moritz_> pmurias: http://nopaste.snit.ch/21934

[12:15] <moritz_> szabgab: are others missing too?

[12:15] <szabgab> and why not include it with a big todo?

[12:15] <pmurias> moritz_: that's bad

[12:15] <szabgab> checking

[12:15] <pmurias> moritz_: that's seems to be the problem

[12:16] <moritz_> szabgab: we had some ongoing discussions whether it should be a proper chapter or an appendix, and then I forgot

[12:16] <moritz_> szabgab: feel free to change though

[12:16] *** clintongormley joined
[12:16] <pmurias> moritz_: could you dzil build in smop and nopaste the Build.PL from there?

[12:16] <szabgab> roles and subtypes are also missing from Makefile

[12:16] <moritz_> szabgab: that's bad... fixing...

[12:17] <szabgab> I can fix it

[12:17] <szabgab> I was just asking

[12:17] <moritz_> szabgab: even better :-)

[12:17] <szabgab> as trying to get involved

[12:17] <szabgab> but I though I should first read what is there already :)

[12:17] <szabgab> what about creating a perl script insted of the make file ?

[12:18] <moritz_> what would be the benefit?

[12:18] <szabgab> checking for files not included in makefile

[12:18] <pmurias> moritz_: maybe your dist::zilla version is different

[12:19] <szabgab> or the files could be renamed to 01_prefix.pod  etc

[12:19] <szabgab> and build the list of files on the fly

[12:19] <moritz_> http://nopaste.snit.ch/21935

[12:19] <moritz_> szabgab: if you want to do that, please check with lucs on #perl6book first, he might have some planned changes

[12:20] <moritz_> szabgab: and I don't like the number prefix, because we might still add chapters

[12:20] *** masak joined
[12:20] <masak> oh hai, #perl6!

[12:21] <moritz_> pmurias: Dist::Zilla version  4.101900

[12:21] <moritz_> masak: oh hai. I've added some crude line wrapping code into XML::Writer

[12:22] <masak> ok.

[12:22] <pmurias> moritz_: nopaste your dist.ini

[12:22] <masak> last night after logging off, instead of sleeping, I wrote that new Yapsi runtime. :)

[12:22] <masak> it was exactly the fun I had pictured it to be.

[12:22] <pmurias> moritz_: from Mildew-Setting-SMOP

[12:22] <moritz_> pmurias: isn't that under version control?

[12:23] <pmurias> yes

[12:23] <moritz_> well, I didn't change it :-)

[12:23] <moritz_> Last Changed Rev: 31607

[12:23] <pmurias> moritz_: you have an incorrect Build.PL

[12:25] <pmurias> moritz_: you have App::nopaste installed?

[12:25] <pmurias> * App::Nopaste

[12:25] <moritz_> no

[12:25] <moritz_> but that's easyenough to change :-)

[12:27] <pmurias> then you could nopaste stuff with "nopaste file"

[12:29] <pmurias> moritz_: check the version  NAME ^

[12:29] <pmurias> of Dist::Zilla::Plugin::ModuleBuild

[12:29] <pmurias> moritz_: it seems our Dist:Zilla's behave differently 

[12:30] *** timbunce left
[12:31] <moritz_> 2.101241

[12:31] <pmurias> what? so your Dist::Zilla is made of different versions?

[12:33] <pmurias> perl -MDist::Zilla::Plugin::ModuleBuild -e 'print $Dist::Zilla::Plugin::ModuleBuild::VERSION'

[12:33] <moritz_> huh

[12:33] <moritz_> that's 4.101900

[12:33] <moritz_> I got my version from looking into the module

[12:34] <moritz_> package Dist::Zilla::Plugin::ModuleBuild;

[12:34] <moritz_> BEGIN { $Dist::Zilla::Plugin::ModuleBuild::VERSION = '2.101241';

[12:34] <moritz_> }

[12:34] <moritz_> seems to get overridden later on

[12:34] * moritz_ shudders

[12:34] <masak> jnthn: ping

[12:35] *** f00li5h joined
[12:36] *** f00li5h left
[12:36] *** f00li5h joined
[12:36] *** f00li5h left
[12:36] *** f00li5h joined
[12:37] *** f00li5h left
[12:37] *** f00li5h joined
[12:37] <masak> f00li5h: stop that. :)

[12:38] <pmurias> moritz_: that's a leftover file from an old Dist::Zilla

[12:40] <pmurias> moritz_: http://www.yourcargo.org/Mildew-Setting-SMOP-0.01.tar.gz

[12:40] *** lichtkind joined
[12:41] <lichtkind> cheers

[12:41] <masak> \o

[12:41] <pmurias> moritz_: you could try using that tarball if you Dist::Zilla is a strange hybrid

[12:42] *** s1n joined
[12:45] <moritz_> which depends on yet another new module. *sigh*

[12:45] <moritz_> Can't locate Config/AutoConf.pm in @INC

[12:46] *** PenThrive left
[12:46] <f00li5h> masak: turns out that i forgot about /connect -! ... 

[12:47] <masak> f00li5h: no worries. :)

[12:47] <masak> http://gist.github.com/471521 # yay! new runtime!

[12:47] *** takadonet joined
[12:48] <takadonet> morning all

[12:48] <masak> takadonet: \o

[12:48] <takadonet> masak: how are u?

[12:48] <masak> takadonet: it's way too warm here in my part of the world, but I'm inside, and coding Perl 6, so I guess I'm fine. :)

[12:49] <masak> takadonet: and u?

[12:49] <takadonet> masak: at ISMB right now waiting for the keynote speaker to start

[12:49] <masak> nice.

[12:49] <takadonet> masak: you do bioinformatics correct?

[12:50] <masak> I try to. :)

[12:50] <takadonet> :)

[12:51] *** Ross left
[12:52] <takadonet> masak: http://www.slideshare.net/bosc2010/fields-bosc2010-bioperl 

[12:52] <moritz_> pmurias: with your tarball I get "Can't stat tmp: No such file or directory at /opt/perl-5.12.1/lib/5.12.1/Module/Build/Base.pm line 4858

[12:52] * masak looks

[12:52] <moritz_> "

[12:52] <moritz_> which is non-fatal

[12:52] <takadonet> people were happy to see some bioperl6 code :)

[12:52] <moritz_> but later it dies with  Can't locate object method "compile" via package "Mildew::Backend::C::So" at /home/p6eval/mildew-install/lib/perl5//Mildew/Compiler.pm line 21

[12:52] <moritz_> (while running ./Build)

[12:53] <masak> takadonet: yoy, Perl 6 is mentioned, at least :)

[12:53] <takadonet> masak: with some of my code! hehe

[12:54] *** sftp joined
[12:54] <takadonet> masak: with help from you and moritz_

[12:54] * moritz_ bows

[12:54] <takadonet> bbl presentation is starting

[12:55] *** takadonet left
[12:56] <pmurias> moritz_: is Mildew::Backend::C::So installed?

[12:56] *** agentzh joined
[12:56] <masak> takkadonet: very nice. takadonet++

[12:57] <pmurias> moritz_: the non fatal warning is expected

[12:57] <pmurias> moritz_: who own's the evalbot box?

[12:59] <pmurias> * owns

[13:00] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; say $h_ref<a>;

[13:00] <p6eval> rakudo 7579f7: OUTPUT¬´Null PMC access in type()‚ê§  in main program body at line 20:/tmp/y9fWXYyJS1‚ê§¬ª

[13:00] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; say $h_ref.perl;

[13:00] <p6eval> rakudo 7579f7: OUTPUT¬´\("b" => 2, "a" => 1)‚ê§¬ª

[13:04] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; say ${h_ref}<a>;

[13:04] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "say ${h_re"‚ê§¬ª

[13:04] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; say $$h_ref<a>;

[13:04] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "say $$h_re"‚ê§¬ª

[13:04] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; say %h_ref<a>;

[13:04] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Symbol '%h_ref' not predeclared in <anonymous> (/tmp/HBwUba7bcT:20)‚ê§¬ª

[13:04] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; say %{$h_ref}<a>;

[13:04] <p6eval> rakudo 7579f7: OUTPUT¬´‚ê§¬ª

[13:05] <moritz_> pmurias: diakopter owns it

[13:06] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; say %$h_ref<a>;

[13:06] <p6eval> rakudo 7579f7: OUTPUT¬´‚ê§Null PMC access in find_method('HOW')‚ê§  in main program body at line 1:/tmp/MEHuxodZza‚ê§¬ª

[13:09] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; my %g = Hash($h_ref); say %g<a>;

[13:09] <p6eval> rakudo 7579f7: OUTPUT¬´Could not find sub &Hash‚ê§  in main program body at line 20:/tmp/uq2GdO8qo_‚ê§¬ª

[13:09] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; my %g = %$h_ref; say %g<a>;

[13:09] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "my %g = %$"‚ê§¬ª

[13:09] <cosimo> mm

[13:12] <pmurias> diakopter: ping

[13:14] <pmurias> moritz_: try perl -MMildew::Backend::C::So -e 1

[13:14] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; my %g = $h_ref; say %g<a>;

[13:14] <p6eval> rakudo 7579f7: OUTPUT¬´1‚ê§¬ª

[13:14] <cosimo> shiny

[13:15] <cosimo> but isn't there a direct way?

[13:15] <cosimo> i'd have expected $h_ref.<a> to work

[13:15] <cosimo> rakudo: my %h=('a'=>1,'b'=>2); my $h_ref=\%h; say $h_ref.{'a'}

[13:15] <p6eval> rakudo 7579f7: OUTPUT¬´Null PMC access in type()‚ê§  in main program body at line 20:/tmp/NRIhf8BtHO‚ê§¬ª

[13:15] <cosimo> mmh

[13:18] *** tadzik joined
[13:23] * masak submits rakudobug

[13:24] <masak> by the way, why isn't .invert in Cool? I wanted to use it on a List last night, and it turns out it's only defined for Hash.

[13:25] <moritz_> pmurias: fails, with 80 lines of "Couldn't load class" error messages. And App::Nopaste refuses to install

[13:25] <moritz_> afk

[13:28] <masak> rakudo: say (\my %h)<a>

[13:28] <p6eval> rakudo 7579f7: OUTPUT¬´Null PMC access in type()‚ê§  in main program body at line 20:/tmp/7teqOLAaKD‚ê§¬ª

[13:28] <cosimo> rakudo: my $x = "someThing"; say $x ~~ m:i/something/;

[13:28] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "say $x ~~ "‚ê§¬ª

[13:28] <cosimo> rakudo: my $x = "someThing"; say $x ~~ m/something/;

[13:28] <p6eval> rakudo 7579f7: OUTPUT¬´‚ê§¬ª

[13:28] <cosimo> rakudo: my $x = "someThing"; say $x ~~ m/someThing/;

[13:28] <p6eval> rakudo 7579f7: OUTPUT¬´someThing‚ê§¬ª

[13:29] <cosimo> are regex modifiers broken?

[13:29] <masak> rakudo: my $x = "someThing"; say $x ~~ m/:i something/;

[13:29] <p6eval> rakudo 7579f7: OUTPUT¬´someThing‚ê§¬ª

[13:29] <masak> cosimo: NYI on the outside, that's all.

[13:29] <cosimo> masak: NIY you mean?

[13:29] <masak> I hear both abbreviations.

[13:30] <masak> NYI is the more common, though.

[13:30] <cosimo> ok :)

[13:30] <masak> they mean the same.

[13:30] <cosimo> but the "Correct(tm)" form is m:i// then?

[13:31] <masak> yes, I'd say so.

[13:31] <masak> IIRC, the tricky part with implementing it was to change the regex after it had been compiled.

[13:32] <masak> since ':i' on the inside is how it "actually works", at least in PGE and nqp-rx.

[13:32] *** whiteknight left
[13:38] <moritz_> there is no "change the regex after it had been compiled"

[13:39] <moritz_> the :i must be passed on the regex compiler

[13:39] <moritz_> currently the tricky thing with implementing adverbs in rakudo is not to make anything unrelated parsefail

[13:42] <masak> ah.

[13:42] <moritz_> I tried adding a simple ':g'? after the 's' parsing for s///

[13:43] <moritz_> and it would then parsefail identifies starting with s.

[13:43] <moritz_> "huh".

[13:43] <jnthn> masak: pong

[13:44] <cosimo> rakudo: my @x = ('5c', 'Blah', '10', 'Blah'); say @x.shift.Int;

[13:45] <p6eval> rakudo 7579f7: OUTPUT¬´5‚ê§¬ª

[13:45] <cosimo> cool

[13:45] <cosimo> how do I convert, say '5c' to decimal?

[13:45] <cosimo> rakudo: say '5c'.hex;

[13:46] <p6eval> rakudo 7579f7: OUTPUT¬´Method 'hex' not found for invocant of class 'Str'‚ê§  in main program body at line 20:/tmp/hruYr0rHDd‚ê§¬ª

[13:46] <moritz_> rakudo: say :16('5C')

[13:46] <p6eval> rakudo 7579f7: OUTPUT¬´92‚ê§¬ª

[13:46] <masak> jnthn: remember we talked about SIC and explicitly putting in an 'outer' pointer from an inner block to its outer block?

[13:47] <jnthn> Yes

[13:48] <masak> jnthn: I've forgotten your reson for why that was necessary; and now I have things working without it... :)

[13:48] <jnthn> Well, pointer sounds runtime-y

[13:48] <masak> so there's probably something I'm missing.

[13:48] <masak> yes, the pointer became entirely runtime-y.

[13:48] <jnthn> OK, and how do you know from the IL which block is nested inside which?

[13:48] <cosimo> rakudo: my $hex = '5c'; say :16($hex);

[13:48] <masak> but PIR has a static :outer() thingy.

[13:48] <p6eval> rakudo 7579f7: OUTPUT¬´92‚ê§¬ª

[13:49] <cosimo> rakudo: my $hex = '5c2f'; say :16($hex);

[13:49] <masak> jnthn: "IL"?

[13:49] <p6eval> rakudo 7579f7: OUTPUT¬´23599‚ê§¬ª

[13:49] <jnthn> SIC?

[13:49] <cosimo> moritz_: masak: thanks

[13:49] <masak> SIC currently doesn't know, doesn't care.

[13:49] <jnthn> Um

[13:49] <masak> the compiler cares, and the runtime cares.

[13:49] <masak> but not SIC.

[13:49] <jnthn> So how do you know how to set up the links between blocks?

[13:49] <jnthn> That information must be *somewhere*?

[13:50] <masak> well, the outer block takes a closure to the inner block at runtime.

[13:50] <masak> at that point, an 'outer' pointer is made.

[13:51] <masak> this will work for subs as well as simpler things like immediate blocks.

[13:52] <masak> jnthn: here's an example of it working: http://gist.github.com/471521

[13:52] <jnthn> Right, so that's where you have said info in the bytecode. It builds the links like that.

[13:52] <pmurias> shouldn't we have a nopaste mentioned in the topic?

[13:53] <masak> jnthn: yes. so now I'm left wondering what PIR uses its :outer() attribute for :)

[13:54] <masak> jnthn: since the blocks in SIC are about as static as static lexpads, and don't have much relation to the lexpads at runtime.

[13:54] <jnthn> masak: e

[13:55] <jnthn> You aren't assuming that caller = outer here are you?

[13:55] <masak> gosh, I hope not. :)

[13:55] *** rv2733 joined
[13:55] <masak> for a while yesterday, I think I was.

[13:55] <masak> but now I think I'm not, since it's all about when the closure is taken. it's taken at block entrance.

[13:56] <masak> after that, it might be called at any time, and will still have the right 'outer'.

[13:56] <jnthn> rakudo: my $x = 42; sub foo { our sub bar { say $x } }; { my $x = 69; bar() }

[13:56] <p6eval> rakudo 7579f7: OUTPUT¬´42‚ê§¬ª

[13:56] <jnthn> masak: Will you get that right under your model?

[13:56] <jnthn> Here the foo block was never entered.

[13:56] <masak> hm.

[13:57] <masak> that'll take the closure at CHECK time or something like that, I assume.

[13:58] <masak> rakudo: my $x = 42; sub foo { $x = 5; our sub bar { say $x } }; bar; foo; bar;

[13:58] <p6eval> rakudo 7579f7: OUTPUT¬´42‚ê§5‚ê§¬ª

[13:58] <masak> and it'll re-rake the closure if foo is ever entered.

[13:58] <jnthn> I guess it just feels odd to me to set up the static chain dynamically, that's all.

[13:58] <masak> yes, I think I have the model right in my head. :)

[13:58] <masak> willing to be proven wrong, of course.

[13:59] <masak> jnthn: well, it just feels wrong to put in something that I never end up using...

[13:59] <masak> rakudo: sub foo { my $y; our sub bar { say $y } }; bar

[13:59] <p6eval> rakudo 7579f7:  ( no output )

[13:59] <masak> this is problematic in my model. :/

[14:00] <masak> and seemingly in Rakudo's, too :)

[14:00] <masak> locally, Null PMC access.

[14:00] * masak submits rakudobug

[14:00] <jnthn> Ugh

[14:00] <jnthn> Yeah, that's why we need the proto-lexpads.

[14:01] <masak> yep.

[14:01] <masak> let's call them 'static lexpads', like pmichaud has started doing.

[14:01] <masak> I'm going to have to think about that case some more.

[14:02] <masak> but probably when the closure is taken at CHECK time, it'll use the static lexpad as its .outer

[14:02] <masak> and then it works.

[14:02] *** slavik joined
[14:02] <jnthn> Anyway, my answer in summary is, with the model you've adopted you don't need to say in the code 'my outer is X'. However, I know which model I prefer. :-)

[14:03] <masak> noted. :)

[14:04] <masak> well, it just seemed to me there was a category in there somehow, at least in the way PIR does it. the :outer() thingies refer to other subs, i.e. static things in the code. whereas I needed to refer to outer lexpads, live things in the runtime.

[14:04] <moritz_> as soon as you start to optimize, you will be glad for every piece of information

[14:05] <masak> the same block of code may have zero, one or several lexpads "associated" with it.

[14:05] <slavik> so, how much openmp type stuff will there be in Perl6? ;)

[14:05] <masak> so pointing back to the parent *block* doesn't really tell me much anyway, it seems.

[14:05] <masak> s/parent/outer/

[14:05] <moritz_> slavik: as much as people implement

[14:06] <slavik> :(

[14:06] <masak> slavik: sorry, expecting a free lunch? :P

[14:06] <masak> slavik: is there funding money involved?

[14:06] <slavik> masak: I wish ;)

[14:06] <moritz_> slavik: well, it's true for any other feature too

[14:06] <slavik> honestly though, I wish there was a finalized spec

[14:07] <slavik> hint hint wink wink

[14:07] <slavik> *cough* TimToady *cough*

[14:07] <moritz_> considering how many quirks we found in the exisiting spec so far, finalizing it before it was implemented seems like a direct way to failure

[14:07] <slavik> the moment there is, I think I will start to use Perl6 more seriously.

[14:07] <masak> slavik: I used to wish for that, too. now I wish the spec freezes gracefully.

[14:08] <slavik> moritz_: I am not accounting or implementation in that statement.

[14:08] <masak> slavik: the fact that you aren't... :)

[14:08] <slavik> masak: I think you put it in better terms :)

[14:08] <masak> that's why the spec *is* changing nowadays is mainly because of the implementations!

[14:08] <moritz_> slavik: you can't separate spec from implementation to the extend you like

[14:09] <slavik> moritz_: not talking about separating them.

[14:09] <masak> we know what we want from Perl 6, but some ideas need tweaking when the rubber meets the road.

[14:09] <moritz_> so what do we want from Perl 6? :-)

[14:09] <slavik> moritz_: it's in the sense of learning something and not having it change the next day ;)

[14:09] <slavik> moritz_: cake

[14:09] <slavik> and flying pigs

[14:10] * moritz_ had cake today

[14:10] <slavik> >.>

[14:10] <moritz_> strawberry and cream

[14:10] <slavik> yea? well, one of my friends is a baker! take that!

[14:10] <moritz_> there's still some in the kitchen :-)

[14:10] * moritz_ read "bake that" :-)

[14:10] <slavik> haha

[14:11] <pmurias> moritz_: diakopter is the one who could give me a acoount on the evalbot box?

[14:11] <moritz_> pmurias: yes. Normally I could too, but I forgot my password :/

[14:12] <masak> moritz_: I want a simple, reliable model that I can't get into my head, and that my mind doesn't reject because it's inelegant. lately, with things coming together in Rakudo with nesting/OO/different kinds of variables, I've been getting a tast of that. it's wonderful.

[14:12] <masak> s/can't/can/

[14:13] *** kid51 joined
[14:13] <pmurias> moritz_: why does App::Nopaste refuse to install?

[14:13] * moritz_ wonders if Perl 6 fits into a model that fits into your head :-)

[14:13] <moritz_> or mine

[14:13] <moritz_> pmurias: a dependency fails, HTTP::Server::Simple or so

[14:13] <moritz_> even though I don't want to run a server, just a client

[14:14] <cosimo> rakudo: my @x = 1, 2, 3; @x[2]:delete; say @x;

[14:14] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "@x[2]:dele"‚ê§¬ª

[14:14] <cosimo> rakudo: my @x = 1, 2, 3; @x[2].delete; say @x;

[14:14] <p6eval> rakudo 7579f7: OUTPUT¬´Method 'delete' not found for invocant of class 'Int'‚ê§  in main program body at line 20:/tmp/GSSwm0mafY‚ê§¬ª

[14:14] <moritz_> operator adverbs NYI

[14:14] <moritz_> rakudo: my @x = 1, 2, 3; @x.delete(2); say @x.perl

[14:14] <p6eval> rakudo 7579f7: OUTPUT¬´[1, 2]‚ê§¬ª

[14:14] <moritz_> rakudo: my @x = 1, 2, 3; @x.delete(1); say @x.perl

[14:14] <masak> simple example: in http://github.com/masak/proto/blob/pls/t/subcommands/install-with-test.t , the @actions variable is threaded into the scopes of methods in mocking subclasses of the classes I want to test. as a consequence, I can run the code I want to test, and then inspect @actions. such a simple thing, but having all the components for it to work... is great.

[14:14] <p6eval> rakudo 7579f7: OUTPUT¬´[1, Any, 3]‚ê§¬ª

[14:15] <cosimo> moritz_: thanks

[14:15] <masak> moritz_: by the way, do you agree that .invert could well be on List, instead of on EnumMap?

[14:15] <cosimo> rakudo: my @x = 1, 2, 3; splice(@x, 1); say @x;

[14:15] <p6eval> rakudo 7579f7: OUTPUT¬´1‚ê§¬ª

[14:15] *** nathan06 joined
[14:15] <cosimo> rakudo: my @x = 1, 2, 3; splice(@x, 1, 1); say @x;

[14:15] <p6eval> rakudo 7579f7: OUTPUT¬´13‚ê§¬ª

[14:15] <moritz_> masak: on both, actually :-)

[14:15] <cosimo> rakudo: my @x = 1, 2, 3; splice(@x, 1, 1); say @x.perl;

[14:15] <slavik> not exactly perl6 related, but is there a gui/browser type app for cpan? (like synaptic but for cpan)

[14:15] <p6eval> rakudo 7579f7: OUTPUT¬´[1, 3]‚ê§¬ª

[14:16] <pmurias> moritz_: could you nopaste the 80 line error?

[14:16] * masak puts it on List

[14:16] <pmurias> if it's so long surely it must be very usefull ;)

[14:16] *** takadonet joined
[14:17] <masak> moritz_: what'd be the failure mode for trying to .invert an odd-elemented List?

[14:17] <moritz_> masak: none. .invert just returns a list of Pairs

[14:17] * masak doesn't follow

[14:17] <masak> moritz_: but what if the input List isn't a list of Pairs?

[14:17] <moritz_> oh wait

[14:18] <moritz_> rakudo: say {a => 1, b => 2}.perl

[14:18] <p6eval> rakudo 7579f7: OUTPUT¬´{"a" => 1, "b" => 2}‚ê§¬ª

[14:18] <moritz_> rakudo: say {a => 1, b => 2}.invert.perl

[14:18] <p6eval> rakudo 7579f7: OUTPUT¬´(1 => "a", 2 => "b")‚ê§¬ª

[14:18] <moritz_> see, list of pairs

[14:18] <masak> oh, I guess it'd just do $list.hash.invert, and the error'll come from .hash

[14:18] <masak> moritz_: we're talking past each other.

[14:18] <moritz_> I'd think List.invert would turn <a b c> into a => 0, b => 1, c => 2

[14:19] <masak> yes, exactly.

[14:19] <masak> so $list.kv.hash.invert, then.

[14:19] <masak> and it needs to be spec'd :)

[14:19] *** christine joined
[14:19] <moritz_> except that .hash would stringify the keys/indexes

[14:20] <masak> hm.

[14:20] <moritz_> it's more like $list.pairs.map({ .value => .key})

[14:20] <masak> ah, better.

[14:20] * masak likes

[14:21] <jnthn> Comments welcome from @all on http://news.perlfoundation.org/2010/07/hague-grant-application-meta-m.html

[14:21] <pmurias> moritz_: i'll try to install Mildew on a fresh 5.12.1 so that all the undeclared dependencies will be exposed

[14:21] * masak read "hugme grant" :)

[14:21] <moritz_> jnthn: I have that open in my browser tab all day, in order not to forget commenting

[14:22] <jnthn> masak: :)

[14:22] <jnthn> moritz_: I only just noticed it was posted :-)

[14:22] * moritz_ wrote hugme completly without a grant

[14:23] <moritz_> pmurias: http://nopaste.snit.ch/21938

[14:23] <moritz_> I kinda think that different installation procedures took different perl versions

[14:23] <moritz_> but then I don't understand why noen of the unit tests failed

[14:23] <moritz_> *none

[14:23] <masak> oooh, S09!

[14:24] *** tylercurtis joined
[14:24] <pmurias> moritz_: that's a missing Devel::Declare

[14:24] <masak> jnthn: I'm reading the "Benefits..." section, and thinking "wow, yes! send the guy money!"

[14:26] <masak> "Accessing object attributes by index offset" \o/ -- today's theme, clearly.

[14:26] <pmurias> moritz_: and MooseX::Declare is mentioned as Moose prereq

[14:26] <pmurias> p6eval: did you ran Build in the tarball with the same @INC settings as when installing Mildew?

[14:26] *** xlat joined
[14:27] <pmurias> s/p6eval/moritz_/

[14:27] <moritz_> yes

[14:27] <moritz_> though I'm not entirely sure

[14:27] <pmurias> you installed the things before with cpanm -L mildew-install?

[14:28] <moritz_> yes

[14:28] <masak> jnthn: all in all, looks very good.

[14:28] <masak> jnthn++

[14:28] <moritz_> masak: then also comment on the blog post

[14:28] * masak does so

[14:31] *** Ross joined
[14:31] <pmurias> moritz_: try running cpanm -L mildew-install . in the unpacked tar ball

[14:33] <moritz_> pmurias: I'll try tomorrow, now I'm frustrated and don't want to touch any CPAN-like things for a while :/

[14:34] <pmurias> just run the command if it failes i'll ask diakopter for a commit bit and finish the Mildew installation myself ;)

[14:35] <moritz_> yes, fails

[14:35] <masak> time to wash some clothes. will be back later tonight.

[14:35] *** masak left
[14:35] <tylercurtis> jnthn: if the new P6object doesn't support multiple inheritance, Parrot will need to either keep the old P6object around or have a standard work-around that does. Or at least, if it doesn't, I'll complain loudly. :)

[14:37] * moritz_ hopes that NQP-rx will be that workaround

[14:40] <jnthn> tylercurtis: The comment is a bit speculative. But more importantly, I doubt that most things will use the very core directly. They'll use a meta-object for classes that does support multiple inheritance.

[14:41] <jnthn> Oops, about to fail at being on time for church

[14:41] * jnthn back later

[14:42] <moritz_> I just wonder about the usefulness of natively typed attributes when we don't have variables to store them

[14:43] <moritz_> but I guess we have to start with one of them :-)

[14:55] <moritz_> szabgab: any success with adding those chapters to the Makefile?

[14:57] *** masonkramer joined
[15:04] <cosimo> rakudo: my $x = "Âä†"; say $x.chars;

[15:04] <p6eval> rakudo 7579f7: OUTPUT¬´1‚ê§¬ª

[15:04] <cosimo> rakudo: my $x = "Âä†"; say $x.bytes;

[15:04] <p6eval> rakudo 7579f7: OUTPUT¬´3‚ê§¬ª

[15:04] <cosimo> cool

[15:06] *** takadonet left
[15:08] <moritz_> rakudo: 3 does True;

[15:09] <p6eval> rakudo 7579f7:  ( no output )

[15:09] <moritz_> rakudo: say 3 does True;

[15:09] <moritz_> shouldn't that fail, because 3 is immutable?

[15:09] <p6eval> rakudo 7579f7:  ( no output )

[15:09] <moritz_> says 3 here locally

[15:23] <dalek> book: 92dcca7 | moritz++ | src/roles.pod:

[15:23] <dalek> book: apply some editorial advise; short explanation for infix:<but>

[15:23] <dalek> book: review: http://github.com/perl6/book/commit/92dcca7b36f7d22a0760b7bd377d1f18bbeff3f4

[15:25] *** nathan06 left
[15:34] *** Mowah joined
[15:35] <cosimo> I just finished chunked transfers support for LWP::Simple -> http://bit.ly/bZW1xa

[15:35] <cosimo> \o/

[15:37] <moritz_> \o/

[15:37] <moritz_> cosimo++

[15:38] *** skids left
[15:38] <cosimo> I find myself *wanting* to write Perl 6 code more and more

[15:39] <moritz_> the patch doesn't look too painful

[15:42] <cosimo> actually, it looks clean doesn't it? i'm sure it can be improved, but...

[15:42] <moritz_> these days when I write Perl 6 code I spend far more time on the application logic, testing and debugging than on working around rakudobug or NYI features

[15:42] <tadzik> cosimo: still no binary file support, no?

[15:42] <tadzik> getstore will work only for plaintexts

[15:43] <moritz_> cosimo: yes, looks clean... I meant it wasn't full of workarounds or so

[15:45] * moritz_ is looking for ideas for his weekly Perl 6 challenges

[15:45] *** skids joined
[15:46] *** Lawn joined
[15:47] *** Mowah left
[15:49] *** skids left
[15:51] *** kid51 left
[15:55] *** takadonet joined
[15:55] *** skids joined
[15:58] <takadonet> can a grammar with action method be lazy? In sense that once we have one 'full' record we stop parsing the file and allowed to resume later?

[15:58] <cosimo> tadzik: why not?

[15:59] <cosimo> tadzik: or, why it doesn't work for non-plaintext?

[16:00] *** xlat left
[16:01] <moritz_> takadonet: in ideal Perl 6, yes

[16:01] <takadonet> moritz_: but not currently?

[16:01] <moritz_> at least I think so

[16:01] <moritz_> not currently

[16:02] <tadzik> cosimo: I remember writing similar getstore for your LWP some time ago. Downloaded binary files were just recognised as text files by the OS

[16:02] <moritz_> currently you need to emulate the laziness by matching one item, lazily record that (via gather/take), and then anchor the next match

[16:03] <moritz_> with $str.match($regex, :p($previous_position)

[16:03] <takadonet> currently i'm using gather and take but perhaps I'm not anchor the next match

[16:05] <cosimo> tadzik: a couple of weeks ago I didn't have HTTP headers parsing either

[16:05] <cosimo> so it should be different now, but I haven't tried binary files yet

[16:06] *** avar joined
[16:07] <avar> Hi, who has access to the perl6 github account? Please remove my commit access to perl6/book. I keep getting github issue spam about it.

[16:07] <avar> Someone added me to that account without me knowing about it

[16:08] <moritz_> sorry, forgot to remove you :(

[16:08] <moritz_> will do

[16:08] <avar> WHEE

[16:08] <avar> oh yeah, forgot about having asked about it earlier. /me goldfish memory

[16:09] <avar> Just noticed it because someone filed 5 issues or something :)

[16:10] <tadzik> Hmm. Is there a way to get the subroutine parameters like in Perl 5? How to get unknown number of params?

[16:10] *** takadonet left
[16:10] <slavik> data dumper?

[16:10] <moritz_> sub f(*@a) { ...}

[16:10] <tylercurtis> rakudo: sub foo { say @_; } foo 1, 2, 3, 4;

[16:10] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "sub foo { "‚ê§¬ª

[16:11] <tylercurtis> rakudo: sub foo { say @_; }; foo 1, 2, 3, 4;

[16:11] <p6eval> rakudo 7579f7: OUTPUT¬´1234‚ê§¬ª

[16:12] <tylercurtis> rakudo: sub foo (*@positional, *%named) { say @positional; say %named }; foo 1, 2, 3, 4, :hey<there>;

[16:12] <moritz_> avar: you should be gone now (I only have API access, so I'm not quite sure if it worked)

[16:12] <p6eval> rakudo 7579f7: OUTPUT¬´1234‚ê§hey     there‚ê§¬ª

[16:13] <avar> moritz_: whee

[16:15] <avar> thanks!

[16:15] *** avar left
[16:16] <tylercurtis> rakudo: sub foo ($one, $two, *@many) { say $one; say $two; .say for @many; }; foo("One...", "Two...", "I don't know how to count higher than two..., but at least these examples answer your question, eh, tadzik?");

[16:16] <p6eval> rakudo 7579f7: OUTPUT¬´One...‚ê§Two...‚ê§I don't know how to count higher than two..., but at least these examples answer your question, eh, tadzik?‚ê§¬ª

[16:16] <tadzik> yep, got it :)

[16:17] *** agentzh left
[16:17] <ingy> greetings

[16:18] *** isBEKaml joined
[16:19] *** tylercurtis left
[16:23] *** justatheory joined
[16:30] *** justatheory left
[16:31] * ingy is writing a simple YAML dumper for p6, because he's sick of .perl not dumping objects :\

[16:33] <cosimo> rakudo: my $status = 'HTTP/1.0 302 Found'; say $status ~~ m/30[12]/;

[16:33] <p6eval> rakudo 7579f7: OUTPUT¬´‚ê§¬ª

[16:33] <cosimo> rakudo: my $status = 'HTTP/1.0 302 Found'; say $status ~~ m/302/;

[16:33] <p6eval> rakudo 7579f7: OUTPUT¬´302‚ê§¬ª

[16:33] <cosimo> rakudo: my $status = 'HTTP/1.0 302 Found'; say $status ~~ m/30[2]/;

[16:33] <p6eval> rakudo 7579f7: OUTPUT¬´302‚ê§¬ª

[16:33] <cosimo> rakudo: my $status = 'HTTP/1.0 302 Found'; say $status ~~ m/30[12]/;

[16:33] <p6eval> rakudo 7579f7: OUTPUT¬´‚ê§¬ª

[16:33] <cosimo> mmh

[16:34] <cosimo> rakudo: my $status = 'HTTP/1.0 302 Found'; say ($status ~~ '301' || $status ~~ '302');

[16:34] <lue> ohai o/

[16:34] <p6eval> rakudo 7579f7: OUTPUT¬´0‚ê§¬ª

[16:34] <cosimo> rakudo: my $status = 'HTTP/1.0 302 Found'; say ($status ~~ m/301/ || $status ~~ m/302/);

[16:34] <p6eval> rakudo 7579f7: OUTPUT¬´302‚ê§¬ª

[16:34] <cosimo> rakudo: my $status = 'HTTP/1.0 301 Found'; say ($status ~~ m/301/ || $status ~~ m/302/);

[16:34] <p6eval> rakudo 7579f7: OUTPUT¬´301‚ê§¬ª

[16:35] <lue> rakudo: my $status = 'HTTP/1.0 301 Found'; say $status ~~ m/30[1|2]/

[16:35] <p6eval> rakudo 7579f7: OUTPUT¬´301‚ê§¬ª

[16:35] <cosimo> rakudo: my $status = 'HTTP/1.0 301 Found'; say $status ~~ m/30 <[12]>/;

[16:36] <p6eval> rakudo 7579f7: OUTPUT¬´301‚ê§¬ª

[16:36] <cosimo> rakudo: my $status = 'HTTP/1.0 30A Found'; say $status ~~ m/30 <[12A]>/;

[16:36] <p6eval> rakudo 7579f7: OUTPUT¬´30A‚ê§¬ª

[16:44] <ingy> rakudo: { die 'foo'; CATCH { say $! } }

[16:44] <p6eval> rakudo 7579f7: OUTPUT¬´foo‚ê§¬ª

[16:44] <ingy> rakudo: { die 'foo'; CATCH { die $! } }

[16:44] <p6eval> rakudo 7579f7:  ( no output )

[16:44] <lue> rakudo: warn ('bad things'); say $!

[16:44] <p6eval> rakudo 7579f7: OUTPUT¬´bad things at line 20:/tmp/K1aVbYwf4c‚ê§Any()‚ê§¬ª

[16:44] <ingy> TimToady: is this on purpose? ^^

[16:45] <cosimo> TimToady: maybe this can be useful for newbies like me? http://nopaste.snit.ch/21945

[16:46] <diakopter> is what on purpose?

[16:47] <TimToady> rakudo: die "message"

[16:47] <p6eval> rakudo 7579f7: OUTPUT¬´message‚ê§  in main program body at line 20:/tmp/oP5txIC0nC‚ê§¬ª

[16:47] <TimToady> looks like a bug

[16:48] <TimToady> rakudo: die 'foo'; CATCH { when /bar/ {} }

[16:48] <p6eval> rakudo 7579f7:  ( no output )

[16:48] <TimToady> looks like it's not rethrowing correctly

[16:49] <TimToady> we don't tend to use exceptions heavily in p6 because it's counterproductive under parallelism

[16:49] <TimToady> so it's not exercised much

[16:49] <TimToady> we fail much more often than we die :)

[16:50] <diakopter> ours is but to do and fail

[16:52] <ingy> TimToady: thanks

[16:53] <lue> is fail() less bad than die() ? [it is in English, just wondering here]

[16:53] <pugssvn> r31624 | lwall++ | [S05] redirect to new char class syntax with patch from cosimo++ 

[16:53] <TimToady> depends on whether you've done a 'use fatal', in which case fail does a die

[16:54] <TimToady> but usually fail just returns an unthrown exception as a form of undef

[16:54] *** TiMBuS left
[16:54] <TimToady> if you try to use it as a value, then it dies

[16:55] <ingy> TimToady: where did you lift that concept from?

[16:56] <ingy> it's quite interesting...

[16:56] <lue> rakudo: my $a where 0..0xFF; $a = 300; # is this use of 'where' legal?

[16:56] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "my $a wher"‚ê§¬ª

[16:56] <TimToady> every so now and again, I invent something from scratch

[16:56] <TimToady> std: my $a where 0..0xFF; $a = 300; # is this use of 'where' legal?

[16:56] <p6eval> std 31623: OUTPUT¬´ok 00:01 111m‚ê§¬ª

[16:56] <ingy> if true {TimToady++}

[16:56] <TimToady> yes :P

[16:58] <TimToady> ingy: though it was a synthesis in the sense that there have always been languages that have the semi-predicate problem on either side of succeed/fail; I just decided to have it on neither side

[16:58] *** dual joined
[16:58] <TimToady> so you can return interesting values of both success and failure

[16:58] <lue> [well, that changes where I should look to put it (excuse the pun) . Now to find where post_constraints for variables lie.]

[16:59] <lue> another example of a quantum language :)

[17:00] <ingy> TimToady: heads or tails?

[17:00] *** aubreyja joined
[17:03] *** jaffa4 joined
[17:03] <pugssvn> r31625 | lwall++ | [S12] Nail down class representations sooner to make jnthn++ happier 

[17:03] <jaffa4> hi

[17:04] <ingy> greetings jaffa4 

[17:05] <jnthn> TimToady: \o/

[17:05] <jnthn> .oO( maybe I should read the commit pre-\o/ :-) )

[17:05] <jaffa4> hi ingy

[17:05] <jaffa4> How is Rakudo star?

[17:09] <jnthn> jaffa4: Coming along. The REPL now remembers variables and stuff between lines, closures are fixed, various other bits too. Still some stuff to go.

[17:09] <lue> would this work too:    my $a; $a where 0..0xFF;    ? [applying 'where' after declaration]

[17:09] <jnthn> But the must-have things on the ROADMAP are more default with than not

[17:09] <jnthn> lue: no

[17:09] <pugssvn> r31626 | lwall++ | [S12] discuss pessimizing optimizations with augment 

[17:10] <lue> I figured /me off to find where variables are first created in the grammar

[17:10] <TimToady> jnthn: did you see the CATCH problem earlier?

[17:12] <jnthn> TimToady: no

[17:12] <jnthn> Didn't backlog quite yet :-)

[17:13] <TimToady> rakudo: die 'foo'; CATCH { when /bar/ {} }

[17:13] <p6eval> rakudo 7579f7:  ( no output )

[17:13] <TimToady> that should rethrow

[17:13] <TimToady> rakudo: die 'foo'; CATCH { die "bar" }

[17:13] <TimToady> so should that

[17:13] <p6eval> rakudo 7579f7:  ( no output )

[17:13] <lue> std: my $a where 0..0xFF is copy

[17:13] <p6eval> std 31625: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row at /tmp/ZeGXZHrlza line 1:‚ê§------> [32mmy $a where 0..0xFF [33m‚èè[31mis copy[0m‚ê§    expecting any of:‚ê§    bracketed infix‚ê§  constraint‚ê§       infix or meta-infix‚ê§      statement modifier loop‚ê§Parse failed‚ê§FAILED 00:01 114m‚ê§¬ª

[17:14] <lue> std: my $a is copy where 0..0xFF

[17:14] <p6eval> std 31625: OUTPUT¬´ok 00:01 111m‚ê§¬ª

[17:14] <jnthn> TimToady: Seems it swallows stuff too eagerly, yes.

[17:14] <moritz_> phenny: tell takadonet to look at <http://nopaste.snit.ch/21946>, which is a working example of lazy matching with Rakudo

[17:14] <phenny> moritz_: I'll pass that on when takadonet is around.

[17:14] *** Ross left
[17:14] <jnthn> I'll have to glance S04 to check when we auto-rethrow.

[17:15] *** Ross joined
[17:15] <TimToady> any time you fall of the end, basically; it's only succeed that bypasses

[17:16] <jnthn> TimToady: r31625 says just what I wanted

[17:16] <jnthn> -    layout        P6opaque, P6hash, P5hash, P5array, PyDict, Cstruct, etc.

[17:16] <jnthn> +    repr          P6opaque, P6hash, P5hash, P5array, PyDict, Cstruct, etc.

[17:16] *** tedv joined
[17:16] <jnthn> I guess this is the repr that was set with the "is repr" trait?

[17:16] <jnthn> So if you :repr(*) then .repr on the HOW returns *?

[17:17] <TimToady> I presume

[17:17] <TimToady> at least, for the class it would

[17:17] <TimToady> an instance might return something more specific, I suppose

[17:17] <jnthn> Yeah, that was going to be my next question.

[17:17] <jnthn> Do we have a per-instance version too. :-)

[17:17] <jnthn> .REPR macro or some such.

[17:18] <jnthn> Anyway, +1 on the changes. Thanks.

[17:18] <slavik> where can I read about diff between .MACRO and .method?

[17:19] <jnthn> TimToady: btw, I liked the "also" change yesterday.

[17:19] <slavik> was Java's "everything implicitly extends Object" considered? Looks like a decent way of getting base functionality into an object

[17:19] <sorear> good * #perl6

[17:20] <moritz_> good now, sorear :-)

[17:20] <moritz_> std: now

[17:20] <slavik> o/

[17:20] <p6eval> std 31625: OUTPUT¬´ok 00:01 107m‚ê§¬ª

[17:20] <slavik> std: now + 1

[17:20] <p6eval> std 31625: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[17:20] <slavik> std: now + 1

[17:20] <p6eval> std 31625: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[17:20] <sorear> I interpret the 'repr' trait on classes as being a specialization pragma

[17:20] <slavik> :(

[17:20] <sorear> The class body is allowed to assume that a specific repr will be used

[17:20] <moritz_> slavik: std does syntax check.

[17:20] <lue> rakudo: say now

[17:20] <slavik> oh

[17:20] <p6eval> rakudo 7579f7: OUTPUT¬´Could not find sub &now‚ê§  in main program body at line 20:/tmp/i5MV7S6h5i‚ê§¬ª

[17:20] <slavik> rakudo: now

[17:20] <p6eval> rakudo 7579f7: OUTPUT¬´Could not find sub &now‚ê§  in main program body at line 20:/tmp/ChBxXBjQxq‚ê§¬ª

[17:21] <jnthn> slavik: The default type of everything is Any

[17:21] <slavik> aww :(

[17:21] <jnthn> slavik: Which in turn inherits from Mu

[17:21] <moritz_> facts: 1) gather/take is lazy

[17:21] <jnthn> sorear: Yeah, I figure you can't take advantage of that knowledge until you parsed the whole class body.

[17:21] <moritz_> 2) my @a = 1..*; # also lazy

[17:21] <jnthn> sorear: In case also repr(*); shows up along the way

[17:22] <moritz_> 3) assigning the result from gather/take to an array evaulates it eagerly

[17:22] <jnthn> But that's fine I guess.

[17:22] <slavik> moritz_: unless it's ==> ?

[17:22] <moritz_> slavik: I'm talking about the 'is' situation in Rakudo, not the 'should be' situation

[17:22] <slavik> oh

[17:22] <moritz_> sorry if that wasn't clear

[17:22] <sorear> pmurias: Is your dist a fork of std or are you intending to merge it back at some point?

[17:22] <slavik> moritz_: I have no idea what the is situation is ;)

[17:22] <isBEKaml> rakudo: class Foo{}; Foo.^parents.perl.say; 

[17:23] <moritz_> slavik: facts 1) to 3) describe it :-)

[17:23] <p6eval> rakudo 7579f7: OUTPUT¬´(Any, Mu)‚ê§¬ª

[17:23] <isBEKaml> slavik: ^^ 

[17:23] <lue> [why is the basis for everything named Mu?]

[17:23] <slavik> moritz_: I mean wouldn't op(<==) make it lazy?

[17:23] *** tadzik left
[17:24] <slavik> it's a quark, and smaller than an atom, which is Any

[17:24] <slavik> or so I think

[17:24] <jnthn> lue: S02

[17:25] <moritz_> slavik: it would. But I'm kinda surprised that assignment doesn't work lazily with gather/take, even though my @a = 1..*; *is* lazy

[17:25] <moritz_> so, the real question is: BUG?

[17:26] <sorear> TimToady, jnthn: die in CATCH is a longstanding Parrot bug

[17:27] <sorear> http://trac.parrot.org/parrot/ticket/1631

[17:27] <jnthn> sorear: I was kinda hoping it was mostly a code-gen bug but maybe it's not so simple

[17:27] <jnthn> e.g. we needed to emit a pop_eh where we're not

[17:27] * jnthn checks the ticket

[17:27] <sorear> it's mostly likely a PAST bug.

[17:28] <jnthn> sorear: ah, yes

[17:28] <jnthn> OK

[17:28] <jnthn> Taht's probably easier to fix

[17:28] <jnthn> In PAST::Compiler somewhere

[17:29] <jnthn> (easier than if it was deep in Parrot)

[17:30] <jnthn> ops.'push_pirop'('pop_eh')

[17:30] <jnthn> hmm

[17:30] <jnthn> Looks like it is

[17:31] <ingy> "Error: Too many positional parameters passed; got 2 but expected 1" ... what subroutine???!!!

[17:31] <moritz_> ingy: less than awesome, and reported. Happens for method dispatch

[17:31] <isBEKaml> moritz_: about my @a= 1..*; maybe you missed the parens around rvalue? I recently hit on this and pmichaud++ pointed out that '=' binds tighter than '..'. (What's the situation here? I sorely lack context here.. :()

[17:32] <jnthn> moritz_: huh, when?

[17:32] <ingy> error reporting is teh big suck right now :\

[17:32] <pmurias> sorear: i could merge back the few changes i made, and make Dist::Zilla make a dist from the pile of files in src/perl6

[17:32] <jnthn> Doesn't the backtrace have the current method in?

[17:32] <ingy> at least it keeps me around :\

[17:32] <moritz_> isBEKaml: that's only the case in $scalar = 1..*;

[17:32] *** Lawn left
[17:32] <moritz_> rakudo: class Foo { method x() { } }; Foo.x(5)

[17:32] <jnthn> rakudo: class C { method m { } }; C.m(42)

[17:33] <moritz_> seems that p6eval is borked again

[17:33] <moritz_> Too many positional parameters passed; got 2 but expected 1

[17:33] <moritz_> that's what I get locally

[17:33] <p6eval> rakudo 7579f7:  ( no output )

[17:33] <jnthn> I get

[17:33] <jnthn> Too many positional parameters passed; got 2 but expected 1 in 'C::m' at line 1 in main program body at line 1

[17:33] <jnthn> Oh, do you mean in the REPL?

[17:33] <isBEKaml> moritz_: Ah, I see.. 

[17:33] <moritz_> jnthn: yes

[17:34] <jnthn> Oh

[17:34] <moritz_> jnthn: but I've also seen that creeping up in normal code

[17:34] <jnthn> moritz_: Got a ticket for a non-REPL case?

[17:34] <ingy> rakudo: say Boolean::true

[17:34] <p6eval> rakudo 7579f7: OUTPUT¬´Can not find sub Boolean::true‚ê§  in main program body at line 1‚ê§¬ª

[17:35] <ingy> rakudo: say Boolean::True

[17:35] <p6eval> rakudo 7579f7: OUTPUT¬´Can not find sub Boolean::True‚ê§  in main program body at line 1‚ê§¬ª

[17:35] <moritz_> jnthn: Regex::Match.from(1, 2, 3);

[17:35] <lue> ingy: that's Bool::True

[17:35] <isBEKaml> rakudo: say (1 < 0).perl

[17:35] <ingy> thx

[17:35] <p6eval> rakudo 7579f7: OUTPUT¬´Bool::False‚ê§¬ª

[17:35] <moritz_> jnthn: gives a backtrace with line number, but without the method name

[17:36] <jnthn> sorear: oh, may have found it

[17:36] <jnthn> moritz_: oh

[17:36] <ingy> rakudo: use Bool; say True

[17:36] <jnthn> moritz_: That's an NQP class?

[17:36] <p6eval> rakudo 7579f7: OUTPUT¬´===SORRY!===‚ê§Unable to find module 'Bool' in the @*INC directories.‚ê§(@*INC contains:‚ê§  lib‚ê§  /home/p6eval/.perl6/lib‚ê§  /home/p6eval//p1/lib/parrot/2.5.0-devel/languages/perl6/lib‚ê§  .)‚ê§¬ª

[17:36] <moritz_> jnthn: or even PIR

[17:36] <jnthn> moritz_: ah, I can totally believe we may be crappy on those

[17:36] <isBEKaml> jnthn: http://irclog.perlgeek.de/perl6/2010-07-11#i_2538819

[17:36] <isBEKaml> this is another. 

[17:37] <ingy> is Bool::True the shortest form of Bool::True?

[17:37] <jnthn> ingy: Normally just True works

[17:37] <moritz_> rakudo: say True

[17:37] <p6eval> rakudo 7579f7: OUTPUT¬´1‚ê§¬ª

[17:37] <moritz_> rakudo: say ?1 # even shorter

[17:37] <p6eval> rakudo 7579f7: OUTPUT¬´1‚ê§¬ª

[17:38] <ingy> why does it Str to '1'?

[17:38] <ingy> seems arcane

[17:38] <moritz_> masak recently said about the same

[17:38] <ingy> </bitchin>

[17:39] *** Kodi joined
[17:40] <ingy> phenny: tell masak /me hugs masak

[17:40] <phenny> ingy: I'll pass that on when masak is around.

[17:43] *** whiteknight joined
[17:44] *** masonkramer left
[17:45] <jnthn> > { die 'foo'; CATCH { die $! } }

[17:45] <jnthn> foo

[17:45] <ingy> rakudo: use Test; is "foo\nfoo\n", "bar\nbar\n", 'Baz!';

[17:45] <p6eval> rakudo 7579f7: OUTPUT¬´not ok 1 - Baz!‚ê§#      got: "foo\nfoo\n"‚ê§# expected: "bar\nbar\n"‚ê§¬ª

[17:45] * jnthn spectests and goes to make some noms

[17:45] <ingy> is there a way to tell test not to serialize newlines as \n?

[17:46] <jnthn> ingy: Suspect it's just doing .perl on them

[17:46] <ingy> nod :\

[17:47] <ingy> I need to get my waiver in to pmichaud so I can get meh bit!

[17:47] <moritz_> ingy: what would you have it serialize to instead?

[17:48] <ingy> moritz_: I would do it same as p5

[17:48] <sorear> moritz_: I have root on feather1, can I help you with your password problems?

[17:48] <ingy> got: "foo

[17:48] <moritz_> sorear: no, wrong matchine

[17:48] <ingy> # foo

[17:48] <ingy> "

[17:48] <ingy> like that

[17:48] <moritz_> ingy: that's a bit bad if there are spaces after the newline

[17:49] <moritz_> but now that .subst properly works for zero-width assertions, it should be SMOP to patch Test.pm if you really want it

[17:49] <ingy> moritz_: testing yaml dumps is almost impossible with \n

[17:50] <ingy> and TestML supports diff output of got/expected

[17:50] <moritz_> ingy: just get it right :-)

[17:50] <pragma_> I disagree.

[17:50] <moritz_> pragma_: with what?

[17:51] <ingy> anyway, I just want it to be the same as p5 by default, and have options to do whatever pragma_ wants ;)

[17:51] * pragma_ concedes.

[17:51] * ingy hugs pragma_ 

[17:52] <ingy> \@_o/

[17:54] <moritz_> ingy: should it chomp trailing newlines?

[17:54] <ingy> whatever p5 does. ( I think that is no)

[17:54] <jnthn> moritz_: S02-literals/quoting.t has two fails on Windows - iirc this is the one you asked me to check?

[17:55] <moritz_> jnthn: yes... qx and qqx at the very end

[17:55] <jnthn> not ok 145 - qx

[17:55] <jnthn> #      got: "world\r\n"

[17:55] <jnthn> # expected: "world\n"

[17:55] <jnthn> not ok 146 - qqx

[17:55] <jnthn> #      got: "world\r\n"

[17:55] <jnthn> # expected: "world\n"

[17:55] <ingy> rakudo: say [].WHAT.WHAT

[17:55] <p6eval> rakudo 7579f7: OUTPUT¬´Array()‚ê§¬ª

[17:55] <moritz_> jnthn: does it work if you .chomp the result from qx, and remove the \n from the RHS?

[17:55] <lue> .oO(darn those crazy windows)

[17:56] <ingy> rakudo say Array(1,2)

[17:56] <ingy> rakudo: say Array(1,2)

[17:56] <p6eval> rakudo 7579f7: OUTPUT¬´Could not find sub &Array‚ê§  in main program body at line 20:/tmp/Xa7gAanl93‚ê§¬ª

[17:56] <pugssvn> r31627 | Kodi++ | [S32/Temporal] Changed to use a different way of specifying time zones, which is hopefully saner than my last proposal. 

[17:56] <ingy> rakudo: say Array()

[17:56] <p6eval> rakudo 7579f7: OUTPUT¬´Could not find sub &Array‚ê§  in main program body at line 20:/tmp/GixAlIescH‚ê§¬ª

[17:56] *** masak joined
[17:57] <lue> ohai masak o/

[17:57] <ingy> masak: \ (o) (x) /

[17:57] <jnthn> moritz_: Probably will since I fixed .chomp for windows a while back

[17:57] <masak> Oddly, Perl 6 doesn't seem to be mentioned at http://en.wikipedia.org/wiki/Semipredicate_problem

[17:57] <masak> someone should add it there. :)

[17:57] <phenny> masak: 17:40Z <ingy> tell masak /me hugs masak

[17:57] <jnthn> moritz_: nom time here

[17:57] * masak submerges again

[17:57] *** masak left
[17:57] <ingy> jnthn: nom nom

[17:58] <ingy> what kind of thing does .WHAT return?

[17:58] *** aubreyja left
[17:59] <moritz_> a type object

[17:59] <lue> masak: Perl 6 would get its own section on that page :)

[18:00] <ingy> rakudo: say Array()

[18:00] <p6eval> rakudo 7579f7: OUTPUT¬´Could not find sub &Array‚ê§  in main program body at line 20:/tmp/zJ9HUJWQrQ‚ê§¬ª

[18:00] <moritz_> rakudo: say Array

[18:00] <p6eval> rakudo 7579f7: OUTPUT¬´Array()‚ê§¬ª

[18:00] <ingy> rakudo: say Array.WHAT

[18:00] <p6eval> rakudo 7579f7: OUTPUT¬´Array()‚ê§¬ª

[18:01] <ingy> whay not Type() ?

[18:01] <moritz_> coercion syntax NYI

[18:01] <moritz_> rakudo: say Array.perl # if you want runnable code...

[18:01] <p6eval> rakudo 7579f7: OUTPUT¬´Array‚ê§¬ª

[18:02] *** aubreyja joined
[18:02] <ingy> rakudo: say Array.perl

[18:02] <p6eval> rakudo 7579f7: OUTPUT¬´Array‚ê§¬ª

[18:02] *** aubreyja_ joined
[18:02] <ingy> rakudo: say Array.perl.WHAT

[18:02] <p6eval> rakudo 7579f7: OUTPUT¬´Str()‚ê§¬ª

[18:02] <moritz_> rakkudo: say "ab\ncd".subst(rx/^^/, '# ', :g)

[18:03] <ingy> rakudo: say [].WHAT eq 'Array()'

[18:03] <p6eval> rakudo 7579f7: OUTPUT¬´1‚ê§¬ª

[18:03] *** aubreyja_ left
[18:03] <moritz_> rakudo: say "ab\ncd".subst(rx/^^/, '# ', :g)

[18:03] <p6eval> rakudo 7579f7: OUTPUT¬´# ab‚ê§# cd‚ê§¬ª

[18:03] <sorear> mm rakkudo

[18:03] *** isBEKaml left
[18:04] <moritz_> rakudo: use Test; isa_ok Mu, Mu, 'foo'

[18:04] <p6eval> rakudo 7579f7: OUTPUT¬´No applicable candidates found to dispatch to for 'isa_ok'. Available candidates are:‚ê§:(Mu $var, Any $type)‚ê§:(Mu $var, Any $type, Any $msg)‚ê§‚ê§  in main program body at line 20:/tmp/pGmGDYICap‚ê§¬ª

[18:10] <dalek> rakudo: b48fb92 | moritz++ | Test.pm:

[18:10] <dalek> rakudo: allow Mu type checks in isa_ok

[18:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b48fb926feba10bb109d67b7c2690d84c9a9b19a

[18:10] <dalek> rakudo: 582dc43 | moritz++ | Test.pm:

[18:10] <dalek> rakudo: [Test] make diagnostics in is() like in Perl 5, ingy++

[18:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/582dc435b67c1e647eaddca93452e762e757031b

[18:17] <ingy> moritz_++

[18:17] <ingy> \o/

[18:18] <ingy> moritz_: thanks

[18:18] * ingy updates rakudo. prays that other shit don't break.

[18:21] *** eternaleye joined
[18:23] <ingy> rakudo: say 'ingy'.times(3)

[18:23] <p6eval> rakudo 7579f7: OUTPUT¬´Method 'times' not found for invocant of class 'Str'‚ê§  in main program body at line 20:/tmp/rpkvq3boRA‚ê§¬ª

[18:23] <ingy> rakudo: say 'ingy' x 3

[18:24] <p6eval> rakudo 7579f7: OUTPUT¬´ingyingyingy‚ê§¬ª

[18:24] <ingy> rakudo: say 'ingy' x 'foo'

[18:24] <p6eval> rakudo 7579f7: OUTPUT¬´‚ê§¬ª

[18:24] <moritz_> rakudo: say ('ingy' xx 3).perl

[18:24] * ingy guessed TimToady would be more creative ;)

[18:24] <p6eval> rakudo 7579f7: OUTPUT¬´("ingy", "ingy", "ingy")‚ê§¬ª

[18:25] <ingy> nice

[18:25] <ingy> rakudo: say (1,2).WHAT

[18:25] <p6eval> rakudo 7579f7: OUTPUT¬´Parcel()‚ê§¬ª

[18:25] <ingy> :D

[18:25] <ingy> Parcel!

[18:26] <moritz_> rakudo: say ('ingy', ('ingy', 'foo') xx *).[^5].join(', ')

[18:26] <p6eval> rakudo 7579f7: OUTPUT¬´ingy, ingy, foo, ingy, foo‚ê§¬ª

[18:26] <ingy> is that a term from the gay community?

[18:26] * ingy dicks

[18:26] <ingy> I mean *ducks*

[18:26] <moritz_> ingy: Parcel = Parenthesis Cell

[18:26] <ingy> ha!

[18:26] <ingy> TimToady++

[18:27] <ingy> only TimToady could come up with that

[18:27] <ingy> I <3 the Perl community

[18:27] <ingy> screw Python... (even if they have a more usable language)

[18:27] * ingy is BACK!

[18:28] <ingy> at least for now...

[18:28] <ingy> only Perl is -Ofun

[18:30] <lue> afk

[18:30] *** [Coke] joined
[18:33] <diakopter> interesting: http://cacm.acm.org/magazines/2010/7/95061-youre-doing-it-wrong/fulltext

[18:34] <diakopter> (but over my head)

[18:38] <ingy> is there an example of a perl module dist with `make install` capability?

[18:39] <moritz_> ingy: all of my Perl 6 modules are installable, provided you generate a makefile with ufo (see <http://github.com/masak/ufo/>)

[18:40] <ingy> moritz_: example url?

[18:40] <arnsholt> Just see ufo's docs

[18:40] * ingy wants to grab moritz_' modules

[18:42] *** Chillance joined
[18:43] * ingy cues up Side A of Heart's Dreamboat Annie, FTW!

[18:45] <moritz_> ingy: http://github.com/moritz/Math-RungeKutta

[18:46] <moritz_> ufo && make install

[18:46] <ingy> :-*

[18:46] *** takadonet joined
[18:47] *** nadim joined
[18:47] *** nathan06 joined
[18:50] <ingy> moritz_: I already have my own Makefile which handles 'make test' and 'make t/specific.t' 

[18:50] <ingy> does ufo, do make test?

[18:50] <moritz_> make test, yes

[18:50] <ingy> guess I can find out and patch if necessary

[18:50] <moritz_> make t/specific.t not

[18:51] <moritz_> hugme: add ingy to ufo

[18:51] <hugme> moritz_: sorry, I don't know anything about project 'ufo'

[18:51] <moritz_> uhm.

[18:51] <moritz_> just submit a patch :-)

[18:51] <ingy> to the mothership?

[18:51] <moritz_> that masakship, yes :-)

[18:52] <ingy> XD

[18:58] <ingy> moritz_: this would be a nice patch: ufo - | make -f - install

[18:58] <pugssvn> r31628 | Kodi++ | [t/spec] Overhauled DateTime.t. Rakudo can pass all of these with my latest version of DateTime.pm. 

[19:01] <moritz_> ingy: and a SMOP...

[19:01] <diakopter> wow, 1000 commits to pugscode svn in the last 2 months

[19:02] *** envi^home left
[19:02] <ingy> moritz_: SMOP forthcoming :)

[19:02] <moritz_> ingy: I'm faster :-)

[19:02] <moritz_> SMOP already written and tested

[19:02] <moritz_> ... and pushed

[19:03] <ingy> :P

[19:03] <ingy> moritz_++ # I guess :\

[19:03] <ingy> ;)

[19:04] *** cono left
[19:04] <moritz_> that MAIN sub makes it really easy to have command line arguments with default values

[19:04] <ingy> moritz_: you realized that '-' means stdin, yeah?

[19:04] <ingy> or stdout

[19:04] <ingy> depending

[19:04] <ingy> make -f - (reads stdin)

[19:05] <moritz_> is open('-') specced?

[19:05] <ingy> I just meant that `ufo -` prints to stdout

[19:05] *** cono joined
[19:06] <moritz_> yes, that's what my patch did

[19:06] <ingy> ok, the log msg didn't say that

[19:06] <ingy> sorry, should have looked at the code

[19:07] <moritz_> it's alien technology. Of course it's magic :-)

[19:07] <ingy> neat, MAIN binds to @*ARGS?

[19:08] <moritz_> yes, with some additional magic

[19:08] <ingy> <3

[19:08] <moritz_> like possible multi subs

[19:08] <ingy> nod

[19:08] <moritz_> and named arguments bein --foo options

[19:08] <ingy> ossum

[19:09] * ingy puts on the fIREHOSE

[19:10] <ingy> moritz++ # now I can install TestML to write YAML tests

[19:11] <ingy> xoxo

[19:12] <moritz_> \o/

[19:15] <ingy> > ufo - | sudo make -f - install clean

[19:15] <ingy> works!

[19:15] <moritz_> \o/

[19:16] <moritz_> but why sudo? are you installing into a non-standard location?

[19:17] <moritz_> default is ~/.perl6/lib/

[19:17] *** takadonet left
[19:19] *** takadonet joined
[19:21] <ingy> moritz_: O

[19:21] <ingy> moritz_: I thought stuff went where Test.pm goes...

[19:22] <ingy> moritz_: take a look at: > perl -e 'use Test::More tests => 1; is "foo\nfoo\n", "foo\nfoo", "A test";'

[19:22] <ingy> your new output++ is a little off

[19:23] <moritz_> you mean no leading/trailing ''?

[19:23] *** payload joined
[19:25] *** Kodi left
[19:27] <ingy> moritz_: right

[19:28] <ingy> moritz_: also the period after Failed test 1 of 1. :)

[19:31] <dalek> rakudo: d60d064 | moritz++ | Test.pm:

[19:31] <dalek> rakudo: [Test] quote strings in diagnostic output

[19:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d60d0645d33bcb56bebb9767a018243236da1b75

[19:33] *** masak joined
[19:33] <masak> ahoy!

[19:33] <moritz_> aloha

[19:34] <masak> so now there's two of us believing that enum values maybe should stringify to their names. ingy++ \o/

[19:35] <ingy> masak: say Bool::True;

[19:36] <masak> ingy: True

[19:36] <ingy> :D

[19:36] * masak , the living evalbot

[19:36] <ingy> oui

[19:36] <ingy> masak lives

[19:37] <ingy> masak: I think I meant more that Bool should be first class in Perl 6

[19:37] <moritz_> it's an enum as currently specced

[19:37] <ingy> but I like where you are going.

[19:38] <masak> ingy: I like that it's an enum. pmichaud seems grudgy over it being an enum.

[19:38] <ingy> masak: I like it too.

[19:38] <ingy> masak: I'm writing a YAML dumper right now

[19:39] <ingy> after I get it working ok, we should hack in .yaml support

[19:39] <ingy> then .perl will be sad 

[19:39] <ingy> :)

[19:39] <masak> :)

[19:43] *** takadonet left
[19:44] <ingy> masak: did you like our ufo tweak?

[19:45] <masak> haven't studied it in detail.

[19:45] <ingy> ufo - | make -f - install clean

[19:45] <ingy> no Makefile!

[19:45] <masak> huh :)

[19:45] <masak> why?

[19:45] <ingy>  case I already have a Makefile

[19:46] <ingy> and you say to throw it away

[19:46] <ingy> so why ever make one?

[19:46] <ingy> except as a speed op :P

[19:46] <masak> feel free to prepare a patch, and I'll review it :)

[19:47] <ingy> masak: too late

[19:47] <ingy> moritz++ !!!

[19:47] * moritz_ already pushed one

[19:47] <masak> o.O :)

[19:47] <masak> I'll review it pushed, then. :)

[19:47] * ingy already pulled it

[19:48] <ingy> it works great over here ;)

[19:48] <masak> moritz_++ # cute change

[19:49] <masak> is assigning $*OUT equivalent in all ways to binding $*OUT?

[19:49] <sorear> assigning $*OUT is a fatal error

[19:49] <moritz_> sorear: where is that specced?

[19:49] <masak> sorear: not assigning *to* $*OUT.

[19:50] <moritz_> masak: except when one modifies the variable it is assigned to

[19:50] <masak> ah, right.

[19:50] <sorear> it's not specced in so many words, but S03:1569 strongly implies that all bindings to $*OUT are readonly

[19:51] <ingy> moritz_: your latest Test patch is great. thanks

[19:51] <moritz_> sorear: no.

[19:51] <moritz_> sorear: it just describes ::=

[19:52] <moritz_> sorear: and only because it was RO-bound it's not modifiable in this example

[19:52] <sorear> it establishes the standard way to bind $*OUT as ::=, not :=

[19:53] <moritz_> no. It's just an exmaple for ::=.

[19:53] <sorear> along with S02:2705

[19:53] <sorear> Wait, how are you doing that

[19:54] *** IllvilJa joined
[19:54] <sorear> I tried to take the synopses at face value once, there wasn't nearly enough to go on

[19:54] <moritz_> $*OUT is not a user-defined dynamic variable

[19:55] <ingy> rakudo: if 0 {} elsif 1 {say "OK"}

[19:55] <p6eval> rakudo 582dc4: OUTPUT¬´OK‚ê§¬ª

[19:55] <ingy> elsif lives!

[19:55] <ingy> worst name evar

[19:56] <ingy> 'elsif' is teh worst name evar -- gwall

[19:56] <ingy> gloria actually told me that. (paraphrased)

[19:56] * moritz_ things that X_CREAT is worse (don't remember what X is)

[19:56] <moritz_> *thinks

[19:59] * masak kinda likes 'elsif'

[20:00] <masak> it's pronounced the way it's spoken! :P

[20:00] <ingy> el `Sif

[20:01] <masak> std: if 0 {} else if 1 { say "OK" }

[20:01] <p6eval> std 31628: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Please use 'elsif' at /tmp/7j3yGrZiSI line 1:‚ê§------> [32mif 0 {} else if [33m‚èè[31m1 { say "OK" }[0m‚ê§Confused at /tmp/7j3yGrZiSI line 1:‚ê§------> [32mif 0 {} else if [33m‚èè[31m1 { say "OK" }[0m‚ê§    expecting statement_control‚ê§Parse

[20:01] <p6eval> ..failed‚ê§FAILED‚Ä¶

[20:01] *** rv2733 left
[20:02] <masak> though in the above case, I'm sorely tempted to advocate a "just understand what I want already" kind of approach :)

[20:03] <masak> if people want to write it out in long form, why not just let them?

[20:05] <moritz_> if we allow too much stuff, we end up with crappy error messages, long documentation and lettle consistency

[20:05] <ingy> wow: I almost asked how to do a simple thing (because I couldn't find doc on it) but then I just tried: for %node.keys.sort -> $key {

[20:05] <ingy> \o/

[20:05] <ingy> perl6 is sometimes intuitive

[20:05] <moritz_> ingy: you can also say %node.sort, and it sorts by key too, and returns a list of paris

[20:06] <moritz_> *pairs

[20:06] * moritz_ can't type anymore

[20:06] <ingy> moritz_: I tried pairs but messed it up

[20:06] <masak> is there a way to do nested signatures on pairs?

[20:06] <moritz_> rakudo: .value.say for { a => 1, b => 4, d => 8, c => 0 }

[20:06] <p6eval> rakudo 582dc4: OUTPUT¬´Method 'value' not found for invocant of class ''‚ê§  in main program body at line 20:/tmp/R7ByJh2yA_‚ê§¬ª

[20:06] <masak> because there totally should be.

[20:06] <moritz_> masak: sure, with .key and .value

[20:06] <moritz_> rakudo: .value.say for { a => 1, b => 4, d => 8, c => 0 }.sort

[20:07] <p6eval> rakudo 582dc4: OUTPUT¬´1‚ê§4‚ê§0‚ê§8‚ê§¬ª

[20:07] <masak> moritz_: no, I mean binding the key and value in each pair to a parameter.

[20:08] <moritz_> masak: sure, $pair ($key, $value)

[20:08] <masak> \o/

[20:08] <masak> TimToady++ jnthn++

[20:08] <moritz_> which works through the general mechanism of methods calls

[20:09] <masak> the section "When is a closure not a closure" is strange and exhilarating. today I understand a little bit more of it than earlier.

[20:22] <jnthn> rakudo: { die 'foo'; CATCH { die $! } }

[20:22] <p6eval> rakudo 582dc4:  ( no output )

[20:22] <jnthn> rakudo: { die 'foo'; CATCH { die $! } }; say "ok"

[20:22] <p6eval> rakudo 582dc4:  ( no output )

[20:23] <moritz_> the first segfaults

[20:23] <jnthn> ah, ok

[20:23] <jnthn> Does anyone know the ticket #?

[20:23] <jnthn> I don't spot it.

[20:23] <jnthn> (Got a fix locally, gets through the Parrot tests and Rakudo spectest is looking good - almost there.)

[20:25] <masak> jnthn: I think there is one.

[20:25] <masak> looking.

[20:26] <masak> jnthn: http://rt.perl.org/rt3/Ticket/Display.html?id=64262

[20:27] *** timbunce joined
[20:33] *** wilx joined
[20:34] *** jaffa4 left
[20:44] <ingy> how do I change a grammar token at runtime?

[20:44] <ingy> (for my own grammar)

[20:46] <lue> ohaio o/

[20:47] <masak> ingy: I imagine the answer is the same as "how do I change a method at runtime?"

[20:50] <moritz_> rakudo: class A { method foo { say "old" } }; my $x = A.new() but role { method foo { say "new" } }; $x.foo

[20:50] <p6eval> rakudo d60d06:  ( no output )

[20:50] <masak> std: until 42 -> $a { ... }

[20:50] <p6eval> std 31628: OUTPUT¬´ok 00:01 114m‚ê§¬ª

[20:50] <moritz_> says "new" here

[20:51] <masak> std: unless 42 -> $a { ... }

[20:51] <p6eval> std 31628: OUTPUT¬´ok 00:01 111m‚ê§¬ª

[20:51] <moritz_> so "but" seems to work for replacing methods

[20:51] <ingy> rakudo: grammar G1 { our $t = 'xxx'; token t { $t } rule TOP { <t> } } G1.parse("aaa xxx bbb")

[20:51] <p6eval> rakudo d60d06: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 20‚ê§¬ª

[20:51] <jnthn> does to do it in place

[20:51] <moritz_> right

[20:51] <masak> ingy: semicolon.

[20:51] <moritz_> two of them :-)

[20:51] <masak> right.

[20:51] <masak> ingy: the rule is simple.

[20:51] <ingy> rakudo: grammar G1 { our $t = 'xxx'; token t { $t }; rule TOP { <t> } }; G1.parse("aaa xxx bbb");

[20:51] <p6eval> rakudo d60d06:  ( no output )

[20:52] <ingy> rakudo: grammar G1 { our $t = 'xxx'; token t { $t }; rule TOP { <t> } }; say G1.parse("aaa xxx bbb");

[20:52] <p6eval> rakudo d60d06: OUTPUT¬´‚ê§¬ª

[20:52] <ingy> rakudo: grammar G1 { our $t = 'xxx'; token t { $t }; rule TOP { <t> } }; say G1.parse("aaa xx bbb");

[20:52] <p6eval> rakudo d60d06: OUTPUT¬´‚ê§¬ª

[20:52] <ingy> rakudo: grammar G1 { our $t = 'xxx'; token t { $t }; rule TOP { <t> } }; say G1.parse("xxx bbb");

[20:52] <p6eval> rakudo d60d06: OUTPUT¬´xxx ‚ê§¬ª

[20:53] <ingy> rakudo: grammar G1 { our $t = 'xxx'; token t { $t }; rule TOP { <t> } }; say G1.parse("xx bbb");

[20:53] <p6eval> rakudo d60d06: OUTPUT¬´‚ê§¬ª

[20:53] <ingy> rakudo: grammar G1 { our $t = 'xx'; token t { $t }; rule TOP { <t> } }; say G1.parse("xx bbb");

[20:53] <p6eval> rakudo d60d06: OUTPUT¬´xx ‚ê§¬ª

[20:53] <ingy> that seems like an ok way to do it for my needs

[20:55] <moritz_> you know that rules also can take parameters?

[20:55] *** aubreyja left
[20:55] <moritz_> rakudo: grammar A { token TOP { <b("foo")> }; token b($x) { $x } }; say A.parse('foo')

[20:55] <p6eval> rakudo d60d06: OUTPUT¬´foo‚ê§¬ª

[20:56] <moritz_> rakudo: grammar A { token TOP { <b("foo")> }; token b($x) { $x } }; say A.parse('bar')

[20:56] <p6eval> rakudo d60d06: OUTPUT¬´‚ê§¬ª

[20:56] <ingy> rakudo: grammar G1 { our $t = '+++'; token t { $t }; rule TOP { <t> } }; say G1.parse("+++ bbb");

[20:56] <p6eval> rakudo d60d06: OUTPUT¬´+++ ‚ê§¬ª

[20:57] <ingy> rakudo: grammar G1 { our $t = '+++'; token t { $t }; rule TOP {<t>} }; say G1.parse("+++ bbb");

[20:57] <p6eval> rakudo d60d06: OUTPUT¬´+++‚ê§¬ª

[20:58] *** nathan06 left
[20:59] <lue> rakudo: my $a where 0..10; $a = 20;

[20:59] <p6eval> rakudo d60d06: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "my $a wher"‚ê§¬ª

[20:59] <lue> > my $a where 0..10; $a = 20;

[20:59] <lue> Contextual $*PARAMETER not found

[20:59] <moritz_> std: my $a where 0..10; $a = 20;

[21:00] <p6eval> std 31628: OUTPUT¬´ok 00:01 111m‚ê§¬ª

[21:00] *** timbunce left
[21:00] <lue> ever closer! I can paste what I changed so far,

[21:00] <moritz_> rakudo: my Int $a where 0..10; $a = 20; say $a

[21:00] <p6eval> rakudo d60d06: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "my Int $a "‚ê§¬ª

[21:00] <lue> [and yes, I remembered a separate branch this time :)]

[21:04] <masak> rakudo: repeat while 42 -> $x! { say "OH HAI" }

[21:04] <p6eval> rakudo d60d06: OUTPUT¬´OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH HAI‚ê§OH

[21:04] <p6eval> ..HAI‚ê§OH‚Ä¶

[21:04] <masak> rakudo: repeat while 42 -> $x! { say $x }

[21:04] <p6eval> rakudo d60d06:

[21:04] <p6eval> ..OUTPUT¬´‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§

[21:05] <masak> hm. I guess that is according to spec.

[21:05] <jnthn> masak: It's only saying exactly the same as -> $x would.

[21:05] <masak> aye.

[21:05] *** timbunce joined
[21:05] <masak> I kinda thought it'd fail to bind.

[21:06] <jnthn> Why?

[21:06] <masak> because the first iteration doesn't pass in a value.

[21:06] <masak> or so I thought.

[21:06] <jnthn> ?

[21:07] <masak> in a 'repeat while' loop, one iteration is run, then the condition is tested.

[21:07] <jnthn> Ah, yes

[21:07] <masak> so in the first iteration the condition hasn't been tested.

[21:07] <masak> thus (I thought) no parameter would be passed in.

[21:08] <masak> rakudo: repeat while my $a = 42 { say $a }

[21:08] <p6eval> rakudo d60d06:

[21:08] <p6eval> ..OUTPUT¬´Any()‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§42‚ê§

[21:09] *** Trashlord left
[21:09] <lue> [ IIUC, here's what I did:    http://gist.github.com/471833 ]

[21:10] <moritz_> masak: re last section of S04, I agree it's a tough read

[21:11] <masak> moritz_: I'm not sure I understand what 'cloning' means exactly here. and to the extent that I (think I) understand, I'm not sure it's a good word for it. :)

[21:12] <moritz_> "cloning" means "take a snapshot of the lexical environment"

[21:12] <masak> do you have a concrete example?

[21:14] <moritz_> my $x = 3; my $y = { ... }; # $x and $y are the lexical environment of the block

[21:14] <moritz_> + the setting, of course. But that's immutable anyway

[21:15] <masak> I don't really see where "snapshot" comes in. one keeps around a pointer to that lexpad.

[21:15] <masak> "snapshot" sounds like things are photographed and then the photo never changes.

[21:15] <masak> that's not what closures do at all.

[21:16] <masak> you can emulate mutable objects with closures, precisely because it's not just a snapshot, but a living link back to the surrounding lexpad.

[21:16] <jnthn> It's a snapshot of that link. :-)

[21:16] <moritz_> masak: then think of it as a "branch" in the version control sense

[21:17] <masak> I'm at the point where I think I got the theory right, but the terminology is confusing me.

[21:17] <moritz_> masak: have you seen the "illguts", the illustrated guts of perl 5?

[21:17] <masak> no.

[21:18] <masak> ah, found it: http://www.cpan.org/authors/id/GAAS/illguts-0.09.pdf

[21:18] <moritz_> hm, it's not in there anyway... sorry

[21:18] <moritz_> I'm looking for an illustration I've once seen

[21:18] <masak> I saw that PDF the other day.

[21:19] <masak> moritz_: maybe you're thinking of HOP. it has a nice picture of lexpads, IIRC.

[21:19] <ingy> masak: does ufo make install just install .pir, and is that enough?

[21:19] <masak> ingy: per default, yes.

[21:19] <masak> ingy: moritz_ disagrees-ish with me on that.

[21:20] <ingy> install lib/TestML/Runner/TAP.pir ~/.perl6/lib/TestML/Runner/TAP.pir

[21:20] <masak> ingy: there's another install target that installs the .pm files, too.

[21:20] <moritz_> install-src

[21:20] <masak> right.

[21:20] <ingy> Unable to find module 'TestML::Runner::TAP' in the @*INC directories.

[21:20] <masak> huh.

[21:20] *** Ross left
[21:20] <moritz_> masak: if you have HOP available, page 76 describes how Perl 5 does it

[21:21] <ingy> (@*INC contains: t lib /Users/ingy/.perl6/lib

[21:21] <masak> moritz_: I don't right now, but I'll look it up when I get the chance.

[21:21] <jnthn> masak: Installing just the PIR is not enough

[21:21] <masak> jnthn: why not?

[21:22] <jnthn> Because we look for the .pm files first

[21:22] <jnthn> Because the .pir versions don't have a way for us to pull the version info out

[21:22] <masak> huh.

[21:22] <jnthn> And because .pir files are just cached compiled versions

[21:22] <masak> well, then clearly ufo must install both .pir and .pm files.

[21:22] <jnthn> The original source is authoritative.

[21:22] * masak changes ufo

[21:23] <ingy> \o/

[21:23] <jnthn> masak++

[21:23] <ingy> masak++

[21:23] <masak> ingy++ # field-testing

[21:23] <jnthn> There was a HUGE storm here earlier. I hope it's nice and cold out now.

[21:23] <moritz_> it's as simple as adding a install-src dependency to install: 

[21:23] * jnthn goes to take a quick walk and see

[21:23] * ingy feels like the first man in space

[21:23] <moritz_> btw I got the same error too, but attributed it to my own stupidity

[21:24] <ingy> moritz_: for what?

[21:24] <masak> moritz_: good idea.

[21:24] <moritz_> ingy: pir-installed-only module

[21:25] <masak> pushed.

[21:25] <masak> ingy: try now.

[21:26] <lue> rakudo: say $*PARAMETER

[21:27] <p6eval> rakudo d60d06:  ( no output )

[21:29] *** plobsing joined
[21:29] <ingy> can I get 'use Module' to not import the exports?

[21:30] <lue> .oO(I wonder why it couldn't find contextual $*PARAMETER...)

[21:31] <ingy> masak: seems to work

[21:31] <masak> yay

[21:31] <moritz_> ingy: 'need Module;' iirc

[21:33] <masak> std: my @a; my @b; zip(@a;@b)

[21:33] <p6eval> std 31628: OUTPUT¬´ok 00:01 113m‚ê§¬ª

[21:33] *** slavik left
[21:35] <masak> std: loop (;;) -> $a { ... }

[21:35] <p6eval> std 31628: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block at /tmp/SPmRet1WfV line 1:‚ê§------> [32mloop (;;) [33m‚èè[31m-> $a { ... }[0m‚ê§Parse failed‚ê§FAILED 00:01 107m‚ê§¬ª

[21:35] *** ashleydev joined
[21:36] <lue> Grammar.pm is the one place where a document of some sort would be helpful in understanding all the weird little <tokens> and whatnot

[21:36] <ingy> moritz_, masak, everyone: CHECK IT!! -> http://github.com/ingydotnet/yaml-pm6/blob/master/t/dump.tml

[21:36] <ingy> YAML.pm passes 4 tests writtn in TestML

[21:36] <masak> nice.

[21:37] <moritz_> \o~

[21:37] <ingy> it's STOOPID PHRESH \o/

[21:38] <lue> oooh! aaah!

[21:39] <ingy> masak++ # thanks for ufo++

[21:39] <ingy> moritz_++ # thanks for fixing Test etc

[21:39] * ingy writes more tests and refactors

[21:40] <ingy> YAML::dump will be soon!

[21:40] *** ashleydev left
[21:41] <lue> Can somebody point me in the right direction? I'm stuck on that error concerning $*PARAMETER

[21:43] *** ashleydev joined
[21:43] *** ashleydev left
[21:46] <jnthn> lue: For now probably just put parens around the decl.

[21:47] <lue> > my ($a where 0..10); $a = 20;

[21:47] <lue> 20

[21:51] <jnthn> Ah, guess constraint types on variables are not yet re-implemented. :-(

[21:52] <lue> so it's no longer a grammar issue? [see http://gist.github.com/471833 for what I did]

[21:55] <masak> loliblogged! http://use.perl.org/~masak/journal/40442

[21:57] <masak> &

[22:02] * masak sleeps

[22:02] *** masak left
[22:09] <lue> jnthn: what's weird is that 'where' works in parameters

[22:10] <lue> rakudo: sub xyzzy($a where 0..10) { say $a }; xyzzy(5); xyzzy(15);

[22:10] <p6eval> rakudo d60d06: OUTPUT¬´5‚ê§¬ª

[22:10] <arnsholt> Does p6eval no longer print STDERR?

[22:12] <jnthn> lue: No, it'll be more than a grammar issue.

[22:12] <jnthn> lue: Not weird.

[22:12] <jnthn> The way signatures are built is a bit different.

[22:15] <lue> The tricky bit [for me, considering my inexperience with Rakudo] is finding where the heck a reimplementation of 'where' for !signatures goes

[22:15] <jnthn> lue: I'm not quite sure how to do it off hand.

[22:16] <arnsholt> It'd be in several places I guess?

[22:16] <lue> arnsholt: that's exactly what I don't like :D

[22:17] <jnthn> lue: It'll finally need to be attached in declare_variable

[22:17] <arnsholt> Off the top of my head, both binding and assignment should heed constraints I think

[22:17] <lue> jnthn: I wouldn't expect you to know. After all, it's NYI

[22:17] <jnthn> arnsholt: It's not that they aren't heeding them.

[22:17] <jnthn> arnsholt: It's that the where constraint ain't being attached to the container.

[22:17] <arnsholt> Oh, right =)

[22:17] <jnthn> So that's "all" that needs doing :-)

[22:17] <arnsholt> For some value of all, yeah

[22:18] <jnthn> It shouldn't be too bad - I suspect we may want a fake $*PARAMETER to collect the where clauses.

[22:18] <jnthn> But that also feels a tiny bit messy

[22:18] <jnthn> May work though

[22:18] <jnthn> Thing is, at the time I think STD didn't parse a where clause outside of a signature.

[22:18] <lue> rakudo: our Fake $*PARAMETER;

[22:19] <p6eval> rakudo d60d06: OUTPUT¬´===SORRY!===‚ê§In "our" declaration, typename Fake must be predeclared (or marked as declarative with :: prefix) at line 20, near " $*PARAMET"‚ê§¬ª

[22:19] <jnthn> lue: will have to be in the grammar IIRC

[22:19] <jnthn> :my $*PARAMETER; or some such

[22:19] <jnthn> See where similar shows up inside Signature

[22:19] <jnthn> er, signature

[22:20] *** pjcj joined
[22:21] <lue> signature as in signature.(pm|pir) ?

[22:21] <jnthn> no

[22:21] <jnthn> the rule in grammar.pm

[22:22] <lue> ah

[22:24] <dalek> rakudo: 62ee6d9 | jonathan++ | build/PARROT_REVISION:

[22:24] <dalek> rakudo: Bump PARROT_REVISION to get PAST::Compiler fix for exception handler code 

[22:24] <dalek> rakudo: generation, so a CATCH doesn't re-catch exceptions thrown from within it.

[22:24] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/62ee6d92de9b7730f2f74f8b2ec71449f44be8e8

[22:25] <lue> there's only a signature *token*, and :my $*PARAMETER doesn't show up there. [it does show up in the token below it, which is    token parameter]

[22:25] <lue> .oO(let's add it and see what happens!)

[22:25] <jnthn> lue: aha yes

[22:25] <jnthn> Taht's the one I meant

[22:26] <pugssvn> r31629 | jnthn++ | [t/spec] Add test by KyleHa++ that didn't seem to have made it from the RT ticket to the tests for the CATCH not catching its own exception bug. 

[22:30] *** azert0x left
[22:33] *** kid51 joined
[22:37] <lue> > my $b where 0..10; $b = 39;

[22:37] <lue> 39

[22:37] <lue> at least I don't need parentheses for that result anymore :)

[22:48] *** payload left
[22:51] *** timbunce left
[22:59] <araujo> lue, was it needed before?

[22:59] <lue> to get it to fail silently like that, yes. Or else an actual error message popped up.

[23:00] <lue> But now, it just fails silently :)

[23:04] *** elmex joined
[23:09] *** elmex left
[23:13] *** pmurias left
[23:14] <sorear> jnthn: kyleha writes tests too?

[23:18] * kid51 is preparing an introductory talk on Rakudo*

[23:18] <kid51> first audience may be a local Linux user group

[23:18] <kid51> the talk is intended to be more of an announcement than an explanation

[23:19] * kid51 would welcome feedback on slides:  http://thenceforward.net/perl/talks/rakudostar/index.html

[23:19] <kid51> (obviously adapted from pmichaud's YAPC talk, with his permission)

[23:19] <Tene> kid51: the "Star" part also came from the usage of * in Perl 6 as "Whatever"

[23:20] <kid51> Tene:  yes I think pmichaud mentioned that in that talk

[23:21] <kid51> but that's a bit too fine a point for this talk

[23:21] <Tene> 'k

[23:21] <kid51> ... so fine that I don't recall it from pmichaud's talk

[23:24] *** snarkyboojum joined
[23:25] <snarkyboojum> kid51: on slide6 you mention Parrot and Pugs under the "Multiple implementations" bullet point. I have find that a bit misleading, perhaps Rakudo (on Parrot) and Pugs listed there?

[23:26] <kid51> Well, Rakudo is the Perl 6 implementation on the Parrot virtual machine ... correct?

[23:27] <kid51> You can have multiple implementations of Perl 6.  Those are the two most prominent.

[23:27] <snarkyboojum> yeah, just pointing out that on my reading you were implying that Parrot is an implementation of Perl 6 (which I realise isn't your intention)

[23:27] *** justatheory joined
[23:28] <kid51> okay, I see what you're driving at; will fix

[23:28] <snarkyboojum> s/you were/you seemed to be/

[23:28] <jnthn> sorear: Yes :-)

[23:29] <sorear> I knew he ran an automatic test crossposter

[23:29] *** shade_ joined
[23:31] *** justatheory left
[23:31] <jnthn> No, he's written quite a lot of tests too :-)

[23:33] <kid51> snarkyboojum:  fixed in the source code (though not on the web site)

[23:34] *** colomon joined
[23:34] <kid51> afk &

[23:38] <jnthn> o/ colomon :-)

[23:39] <ingy> rakudo: my $h = {}; $h{'foo'} ||= 0; say $h.perl;

[23:39] <p6eval> rakudo 62ee6d: OUTPUT¬´{"foo" => 0}‚ê§¬ª

[23:41] <ingy> rakudo: my $h = {}; $h{'foo'}++ ||= 0; say $h.perl;

[23:42] <p6eval> rakudo 62ee6d:  ( no output )

[23:42] *** masonkramer joined
[23:42] <ingy> rakudo: my $h = {}; $h{'foo'}++ ||= 1; say $h.perl;

[23:42] <p6eval> rakudo 62ee6d:  ( no output )

[23:42] <ingy> rakudo: my $h = {}; $h{'foo'}++; say $h.perl;

[23:42] <p6eval> rakudo 62ee6d: OUTPUT¬´{"foo" => 1}‚ê§¬ª

[23:43] *** meppl left
[23:43] <ingy> rakudo: my $h = {}; my $n = $h{'foo'}++; say $n;

[23:43] <p6eval> rakudo 62ee6d: OUTPUT¬´Any()‚ê§¬ª

[23:43] <ingy> rakudo: my $h = {}; my $n = ++$h{'foo'}; say $n;

[23:44] <p6eval> rakudo 62ee6d: OUTPUT¬´1‚ê§¬ª

[23:52] <ingy> rakudo: given 3 { when 4 { say "four" } }

[23:52] <p6eval> rakudo 62ee6d:  ( no output )

[23:52] <ingy> rakudo: given 3 { when 3 { say "four" } }

[23:52] <p6eval> rakudo 62ee6d: OUTPUT¬´four‚ê§¬ª

[23:55] *** Psyche^ joined
[23:59] *** Patterner left
[23:59] *** Psyche^ is now known as Patterner

