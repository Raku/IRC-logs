[00:07] *** rgrau_ left
[00:08] *** alester left
[00:12] *** Psyche^ joined
[00:12] *** Psyche^ is now known as Patterner

[00:15] *** ash_ left
[00:17] <TimToady> was it something I said?

[00:18] *** Patterner left
[00:22] <sjohnson> p6 was too ahead of our current times

[00:23] *** thundergnat joined
[00:23] <TimToady> they all went off to the future without me?

[00:24] <TimToady> am I dead?

[00:24] <sjohnson> yep.  they're working on p7

[00:25] <TimToady> well, that's okay, then

[00:26] <sjohnson> fwiw, i used some p5 today, and it was very refreshing

[00:27] <sjohnson> that qw() syntax probably advanced mankind by at least 15 years of technological-time

[00:27] <sjohnson> especially when you just CTRL-V paste in about 4800 isbn's or other non-space strings that are in your clipboard for quick and dirty parsing.

[00:28] <sjohnson> one could have been burned at the stake for suggesting qw() to a language spec. 20 years ago

[00:30] <gfldex> that could still happen

[00:30] <sjohnson> yep.  we're lucky to believe

[00:32] *** risou left
[00:35] <sjohnson> err, be alive i mean

[00:35] <sjohnson> has anyone ever figured out how to simply get p5 to work like PHP

[00:35] <sjohnson> with the <? ?> inline html syntax?

[00:35] <sjohnson> hmm, maybe not the best place to ask that question.

[00:35] <sjohnson> kind of OT

[00:41] *** Helios left
[00:42] *** ascent_ left
[00:44] <diakopter> sjohnson: actually I ran across something on CPAN that does that .. quite a few years ago.  so I don't remember the name.

[00:47] *** Helios joined
[00:47] <perigrin_> Mason can be inlined, you can re-define the TT2 delimiters to <? ?> if you want 

[00:48] <perigrin_> there is also Embperl, and Apache::ASP (??) that are much older and I don't know if they're still maintained

[00:48] *** ascent_ joined
[00:50] <sjohnson> i remember installing mod_perl being frustrating and tiresome

[00:50] <sjohnson> maybe that has gotten easier, too

[00:51] *** thundergnat left
[00:52] *** broquaint left
[00:54] <perigrin_> sjohnson: no, not really

[00:54] *** perigrin_ is now known as perigrin

[00:54] <diakopter> sjohnson: that would depend (like the building/installation of nearly everything) extremely heavily on who's doing the building/installing, and in what environment.

[00:56] * sjohnson ponders these thoughts

[00:56] *** Psyche^ joined
[00:56] *** Psyche^ is now known as Patterner

[01:00] *** broquaint joined
[01:04] *** Chillance left
[01:09] *** Patterner left
[01:16] *** xinming_ left
[01:17] *** Psyche^ joined
[01:17] *** Psyche^ is now known as Patterner

[01:18] *** xinming joined
[01:18] *** [particle] left
[01:23] *** cdarroch left
[01:23] *** [particle] joined
[01:30] *** Patterner left
[01:31] *** Psyche^ joined
[01:31] *** Psyche^ is now known as Patterner

[01:38] *** [particle] left
[01:43] *** sekimura_ left
[01:47] *** whiteknight left
[01:47] *** flatwhatson left
[01:50] *** PacoLinux left
[01:56] *** Patterner left
[01:56] *** christine joined
[02:05] *** PacoLinux joined
[02:13] *** patspam left
[02:13] *** Italian_Plumber left
[02:21] *** Psyche^ joined
[02:21] *** Psyche^ is now known as Patterner

[02:29] *** ash_ joined
[02:32] *** Patterner left
[02:34] *** Psyche^ joined
[02:34] *** Psyche^ is now known as Patterner

[02:37] *** ash_ left
[02:45] *** Patterner left
[02:46] <diakopter> so um

[02:47] *** Psyche^ joined
[02:47] *** Psyche^ is now known as Patterner

[02:48] *** Holy_Cow joined
[02:48] *** Holy_Cow left
[02:50] *** bluescreen joined
[02:50] *** bluescreen is now known as Guest83031

[02:51] *** Guest83031 is now known as bluescreen10

[02:54] <crythias> um?

[02:56] <diakopter> the rwun swu zam anf romnan tucket

[03:00] *** mdxi joined
[03:03] *** ash_ joined
[03:04] *** Patterner left
[03:05] <ash_> ping moritz_ 

[03:10] *** flatwhatson joined
[03:13] *** Psyche^ joined
[03:13] *** Psyche^ is now known as Patterner

[03:27] *** redicaps joined
[03:27] *** agentzh joined
[03:35] *** karb joined
[03:38] *** meppel joined
[03:42] *** meppl left
[03:42] *** ash_ left
[03:42] *** ash_ joined
[03:42] <ash_> http://try.rakudo.org/?input=say%20%221%202%20%C2%AB%22; 

[03:43] <ash_> any comments/suggestions?

[03:43] <ash_> that is just an example of unicode working with the try.rakudo.org site 

[03:46] <karb> ash_: looks good. I personally like smaller fonts

[03:47] <ash_> smaller where? 

[03:47] <karb> on the result screen

[03:47] <ash_> a lot of the styles work highly influenced by http://perl6.org/ but are not the exact same, so thats the kind of style i was shooting for 

[03:48] <ash_> (granted i am not a designer by any stretch of the imagination)

[03:50] <karb> ash_: multiple line/statement input works well

[03:51] <ash_> its sorta a cheat

[03:53] <ash_> there are circumstances where it will not work, its a real perl6 repl running in the backend, so anything that doesn't work in the real repl won't work on the site, so if you do (for instance): if $a { <newline> it considers that a syntax error 

[03:53] *** mfollett joined
[03:53] <karb> ash_: when i give the command clear it does not clear any variables i created in the session. Suppose I want to start a fresh program is there any command for clearing the session?

[03:54] <ash_> exit

[03:54] <ash_> that will kill the current repl, and the backend will restart it on the next request

[03:55] <karb> ok

[03:57] <ash_> dang, this server is a LOT faster than the test server i have been working with, there used to be a 1~2 second delay on each command

[03:57] *** meppel is now known as meppl

[03:58] *** Patterner left
[04:02] <ash_> if anyone has any difficulties, compatability issues, or any bugs either leave me a message, or if your on github, http://github.com/moritz/try.rakudo.org/issues would be great 

[04:02] <ash_> err, filling out an issue in the issue tracker is what i mean

[04:06] <pmichaud> ash_++  # very nice work

[04:07] *** bluescreen10 left
[04:07] <ash_> i feel like its better than it was (say rand twice doesn't make the output look wrong for instance), but still room for improvements, the next feature will be (hopefully) the tutorial system

[04:08] *** Psyche^ joined
[04:08] *** Psyche^ is now known as Patterner

[04:09] *** plobsing_ left
[04:12] *** Guest82491 left
[04:15] *** tcliou joined
[04:15] *** tcliou left
[04:16] *** tcliou joined
[04:16] *** mfollett left
[04:18] <ash_> man, i kinda envy macruby, in their current trunk they just added another new feature, they can pass a ruby block to a C program like a C block (the ones that apple added to the gcc and clang compilers), how cool is that 

[04:18] *** Patterner left
[04:19] <ash_> is feather3 alright for anyone else? i am getting timeouts from ssh 

[04:21] *** Schwern joined
[04:21] <Schwern> Hi folks.  Where are Parcels documented?

[04:21] <ash_> oh, i put a really long running thing into the repl and it caused the whole server to lag... thats not good

[04:22] <ash_> S08 i believe 

[04:22] <ash_> http://perlcabal.org/syn/S08.html 

[04:22] <Schwern> Oh.  Huh.  The title went right past my eyes

[04:24] <Schwern> I'm most interested in a Parcel's behavior to act like a single-element list or a scalar.

[04:24] <Schwern> And see if I can backport it to Perl5 with some clever overloading

[04:24] *** tcliou left
[04:26] <ash_> parcels are kinda internal, they aren't something you normally directly manipulate, in my experience anyway 

[04:27] *** Psyche^ joined
[04:27] *** Psyche^ is now known as Patterner

[04:27] <Schwern> I encountered them when investigating porting pick() to perl5i

[04:28] <Schwern> And also wanting things like @array->pop and @array->pop(3) to act sensibly.

[04:29] <ash_> rakudo: sub foo(|$a) { $a.WHAT }; say foo 1; # lets you directly grab the capture

[04:29] <p6eval> rakudo 19a8b7: OUTPUT«Capture()␤»

[04:31] <ash_> rakudo: my @a = (0, :a<b>); say (|@a).WHAT;  # can get to it too 

[04:31] <p6eval> rakudo 19a8b7: OUTPUT«Capture()␤»

[04:31] <ash_> i am not sure how to grab the parcel 

[04:31] *** gfx joined
[04:32] <diakopter> rakudo: 4>>[.say]

[04:32] <p6eval> rakudo 19a8b7: OUTPUT«Any()␤»

[04:33] <diakopter> o

[04:33] *** Patterner left
[04:36] <Schwern> What does pick return?

[04:36] <Schwern> rakudo: [1,2,3].pick

[04:36] <p6eval> rakudo 19a8b7:  ( no output )

[04:37] <ash_> rakudo: say (1..6).pick

[04:37] <p6eval> rakudo 19a8b7: OUTPUT«6␤»

[04:37] <ash_> rakudo: say (1..6).pick.WHAT

[04:37] <p6eval> rakudo 19a8b7: OUTPUT«Int()␤»

[04:38] *** Psyche^ joined
[04:38] *** Psyche^ is now known as Patterner

[04:38] <ash_> it returns an element from the list it was picking from, i don't think its a reference though (its not assignable) 

[04:38] <ash_> rakudo: my @a = 1, 2, 3; @a[2] = 6; @a.pick = 3; 

[04:38] <p6eval> rakudo 19a8b7:  ( no output )

[04:39] <ash_> rakudo: my @a = 1, 2, 3; @a[2] = 6; @a.pick = 3; say 'done', ~@a;

[04:39] <p6eval> rakudo 19a8b7: OUTPUT«done1 2 6␤»

[04:39] *** crythias left
[04:39] <ash_> weird, i kinda expected a warning 

[04:45] *** tylercurtis joined
[04:45] <Schwern> rakudo: [1,2,3].pick.[0].say

[04:45] <p6eval> rakudo 19a8b7: OUTPUT«3␤»

[04:46] <Schwern> That.

[04:46] <Schwern> rakudo: [1,2,3].pick.say

[04:46] <p6eval> rakudo 19a8b7: OUTPUT«2␤»

[04:46] <Schwern> That's what I'm talking about.

[04:48] *** jaldhar joined
[04:49] *** agentzh left
[04:50] <ash_> rakudo: my @a = 1, 2, 3; my $b := @a[2]; $b = 5; say ~@a

[04:50] <p6eval> rakudo 19a8b7: OUTPUT«1 2 5␤»

[04:50] <ash_> rakudo: my @a = 1, 2, 3; my $b := @a[2]; say $b.WHAT;

[04:50] <p6eval> rakudo 19a8b7: OUTPUT«Int()␤»

[04:50] *** M_o_C joined
[04:53] *** reedx032 joined
[04:53] <ash_> is $b a parcel in that case? or a capture

[04:53] <ash_> i think a capture

[04:53] <Schwern> Ta da!  http://github.com/schwern/List-Parcel/blob/master/lib/List/Parcel.pm

[04:54] *** Patterner left
[04:56] <ash_> well, captures override .[0] to let you access the value its referencing, but you can't do .[1] or any other larger index 

[04:57] *** Psyche^ joined
[04:57] *** Psyche^ is now known as Patterner

[04:58] *** reedx032 left
[04:59] <dukeleto> when does #phasers happen?

[05:00] <ash_> Tue 19:00 UTC 

[05:01] <dukeleto> that doesn't seem to be in an easily-findable place, just noting. ash_++

[05:02] <ash_> i got it from the title of the #phasers channel :P 

[05:02] <dukeleto> ash_: :)

[05:04] *** [particle] joined
[05:05] *** Patterner left
[05:05] *** ash_ left
[05:20] *** Axius joined
[05:24] <dukeleto> I've added #phasers to the Parrot Calendar on parrot.org, so people (like me) can set reminders

[05:30] *** Psyche^ joined
[05:31] *** Psyche^ is now known as Patterner

[05:31] *** mantovani joined
[05:31] <karb> which is the correct way to bless: self.bless(*) OR self.bless(self.CREATE)  ?

[05:34] *** [particle] left
[05:35] *** Axius left
[05:36] *** Patterner left
[05:41] <sorear> self.bless(*) and self.CREATE do the same thing

[05:41] <sorear> self.bless(self.CREATE) blesses twice

[05:42] <sorear> Schwern: the return from pick isn't a parcel; .[0] is defined to be the identity operation on non-lists in Perl6

[05:43] * sorear is an Implementor and doesn't quite grok parcels yet

[05:47] *** masak joined
[05:47] <masak> oh hai, #perl6!

[05:47] <karb> I checked S12, it says * calls self.CREATE()

[05:48] <masak> this looks like a nice task to implement for Rosetta Code: http://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform

[05:49] <masak> karb: in the sense that .bless calls self.CREATE() when it sees a *, yes.

[05:50] <karb> S12 specifies self.CREATE is the "normal" way. Is there an advantage over * ?

[05:53] <masak> it's shorter.

[05:54] <masak> oh, advantage *over* *. hm.

[05:54] <masak> self.CREATE is more explicit, and doesn't rely on any hidden magic.

[05:57] *** karb left
[05:58] *** Psyche^ joined
[05:58] *** Psyche^ is now known as Patterner

[06:02] *** agentzh joined
[06:07] <dalek> niecza: 981e8db | sorear++ | / (5 files):

[06:07] <dalek> niecza: Optimize subrules further for the non-backtrack case

[06:07] <dalek> niecza: 

[06:07] <dalek> niecza: ~+30%

[06:07] <dalek> niecza: review: http://github.com/sorear/niecza/commit/981e8dbc985c423e7ef7d9c295ff6b66ea096aeb

[06:09] *** uniejo joined
[06:14] <sorear> my new regex engine is so fast, I can't even find it in the profiler

[06:14] <sorear> so I'm chasing *general Perl6 stuff*

[06:14] <sorear> :/

[06:15] <masak> "chasing"?

[06:15] <sorear> I'm trying to get niecza competitively fast

[06:15] <sorear> so I knock down the biggest stuff on the profile

[06:16] <sorear> but the big stuff on the profile is mostly object system and data model stuff that the regex engine doesn't use

[06:16] *** Axius joined
[06:16] <masak> ok.

[06:19] <masak> why did the specification end up in a repository named 'specs' with a final 's'? sounds like it's not a specification but a pair of glasses... :)

[06:20] *** Patterner left
[06:20] <moritz_> because it's not one spec document, but many

[06:20] <moritz_> good morning

[06:21] <masak> good morning.

[06:21] <masak> I always thought of it as "the specification", singular, but "the synopses", plural.

[06:22] <masak> it's several documents, but they form one specification.

[06:22] <moritz_> http://www.perlmonks.org/?node_id=859263 :(

[06:23] <masak> :(

[06:23] *** Psyche^ joined
[06:23] *** Psyche^ is now known as Patterner

[06:24] <masak> seems easy to fix, though.

[06:25] <sorear> LTA, sure, but ":("?

[06:25] <moritz_> if people go to perlmonks to ask question about the book, it means that we didn't explain it good enough, didn't make it robust enough etc.

[06:26] <masak> it indicates a certain lack-of-robustness that someone'd... what moritz_ said.

[06:26] <masak> on the other hand, it's good to get that feedback now.

[06:27] *** wtw joined
[06:27] <moritz_> I've added a note about the first example not being robust to whitespace fluctuations

[06:27] <moritz_> some weeks ago

[06:28] <moritz_> but it's not yet in the PDF

[06:29] *** Patterner left
[06:31] *** svetlins left
[06:32] <tylercurtis> token term:identifier in STD is mildly confusing.

[06:32] *** hlatapie joined
[06:33] <sorear> I disagree

[06:34] *** Psyche^ joined
[06:34] <dalek> book: 6d48a37 | moritz++ | src/basics.pod:

[06:34] <dalek> book: [basics] re-word warning about robustness

[06:34] <dalek> book: review: http://github.com/perl6/book/commit/6d48a378ca5c9430eaf57f3ff3acfe4eb63e9abf

[06:34] *** Psyche^ is now known as Patterner

[06:34] <tylercurtis> s/is mildly confusing/mildly confuses me/

[06:34] *** justatheory left
[06:34] <masak> moritz_: maybe it'd make sense to do a 'next unless $line' at the start of the loop?

[06:35] <sorear> it more than mildly confuses ME.

[06:36] <tylercurtis> Am I a bad person for feeling a little better because of that?

[06:37] <moritz_> masak: works for me, but would need to be explained properly

[06:39] <moritz_> masak: pmichaud is right, we need a chapter about statements

[06:39] <masak> aye.

[06:39] <masak> ok.

[06:40] <TimToady> the series refactor has landed

[06:40] <TimToady> I guess it still doesn't show up here...

[06:41] *** Axius left
[06:41] *** Patterner left
[06:43] <TimToady> hmm, I guess the watcher is running a bit slow, but it showed up in perl6/specs anyway

[06:44] *** cjk101010 joined
[06:44] <TimToady> or does the watcher not show your own pushes?

[06:46] *** hlatapie left
[06:46] <tylercurtis> sorear: looking at your action for it in Niecza, it looks as though $/.is_name($<args>.ast) is true for identifiers that are in scope without a sigil?

[06:47] <tylercurtis> $<identifier>.Str, rather.

[06:47] <TimToady> anyway, series refactor is at http://github.com/perl6/specs/commit/692474967ab8535f370d859488da592555e17d8d

[06:47] <sorear> tylercurtis: iiuc, it's true for typenames

[06:47] <sorear> like Num

[06:47] <sorear> also True

[06:59] <snarkyboojum> moritz_: the camelia icon in fame-and-profit.html for modules.perl6.org needs updating (probably to http://github.com/perl6/mu/raw/master/misc/camelia32.ico I guess) and I'm guessing that lives in your forked proto/modules.perl6.org repo?

[07:04] *** synth joined
[07:04] *** M_o_C left
[07:05] <masak> TimToady: it's customary to leave the second line in a git commit message empty. this makes the message render better in various clients.

[07:05] <TimToady> I wondered why it highlit red...

[07:06] <TimToady> it also changes color partway through the top line--what does that mean?

[07:08] <snarkyboojum> if it exceeds 72 chars or so?

[07:08] <sorear> yes

[07:09] <sorear> conventional formatting is shortmessage, blank, longmessage

[07:09] *** redicaps left
[07:09] <masak> snarkyboojum: 50 chars, methinks

[07:09] <masak> TimToady: I also learned that convention by observind vim's highlighting :)

[07:10] <masak> s/vind/ving/

[07:10] <TimToady> ah well, came out fine on the web page, at least...

[07:10] <masak> aye.

[07:10] <masak> but it really helps (especially the '50 chars' part) in git log and other similar tools.

[07:10] <TimToady> so it's really a title for what follows

[07:11] <snarkyboojum> masak: ah - it does appear to be 50 :)

[07:11] *** amkrankruleuen left
[07:11] <TimToady> just something to jog the memory

[07:11] <snarkyboojum> this explained it well - http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html

[07:12] *** amkrankruleuen joined
[07:12] <snarkyboojum> I think I got that link off masak somehow :)

[07:13] <masak> aye.

[07:14] <masak> I like to view the shortmessage as a challenge. what did the commit do, in 50 chars or less? :)

[07:14] <masak> it's like nanoblogging.

[07:14] <snarkyboojum> heh

[07:17] <TimToady> can I use Japanese?

[07:18] <masak> commit messages are utf-8 per default, so technically yes.

[07:19] <TimToady> I suppose they count the Kanji as double-wide, unlike twitter...

[07:22] <tylercurtis> Yay! I have a Bennu rewrite that can parse "say 1;". And that's about it. Oh, well, it's progress. 

[07:23] *** Guest23195 joined
[07:24] *** amkrankruleuen left
[07:24] <moritz_> is it fast? :-)

[07:24] <sorear> tylercurtis: can it do anything post-parse?

[07:24] <TimToady> progress is never fast.

[07:25] *** Guest23195 left
[07:25] *** Guest23195 joined
[07:29] <masak> many many spectest failures: http://gist.github.com/569768

[07:29] <tylercurtis> moritz_: it parses "say 1;" slightly faster than rakudo on my machine.

[07:29] <masak> some are known recurring baddies. others are new.

[07:29] <tylercurtis> sorear: not a thing, yet.

[07:31] *** Axius joined
[07:32] *** azert0x joined
[07:34] *** amkrankruleuen joined
[07:37] *** cmadsen joined
[07:37] *** tadzik joined
[07:37] <tadzik> good morning

[07:38] *** foodoo joined
[07:40] <sorear> niecza is now within 10% of viv on the JSON::Tiny benchmark

[07:40] <masak> tadzik: morning!

[07:41] *** amkrankruleuen left
[07:41] <dalek> niecza: b939063 | sorear++ | / (6 files):

[07:41] <dalek> niecza: Store non-dynamic lexicals in an array

[07:41] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b939063ad1df30b7975019f7b8075cb00aa06448

[07:44] *** Psyche^ joined
[07:45] *** Psyche^ is now known as Patterner

[07:47] *** tadzik left
[07:55] *** Trashlord left
[07:56] <jnthn> Morning, #perl6

[07:57] *** amkrankruleuen joined
[07:58] <jnthn> sorear: "self.bless(self.CREATE)" - does not bless twice. .bless(*) calls .CREATE for you, rather than using what was passed in, that's all.

[07:58] <masak> morning, jnthn

[07:59] <jnthn> yayitsmasak!

[07:59] * jnthn is in Helsingborg for the day

[08:00] <masak> yay

[08:05] <masak> someone asks for a Perl 6 version of a Python script in the first comment at http://www.reddit.com/r/programming/comments/damyp/learning_perl_6_by_playing_silly_games/

[08:05] * masak tries to produce one

[08:06] *** frooh joined
[08:06] *** ashleydev left
[08:07] *** ashleydev joined
[08:10] <sorear> \o/ niecza has passed viv

[08:10] <masak> this is what I got: http://gist.github.com/569803

[08:10] <masak> sorear: wow! cool!

[08:11] <masak> seems to work.

[08:11] <sorear> for 100 repetitions of sample.json, total 60kb, viv: 8.6s user, niecza: 5.1s user

[08:11] *** tadzik joined
[08:11] <tadzik> seen alexm

[08:11] <aloha> Sorry, I haven't seen alexm.

[08:11] <sorear> 't/JsonTinyG.pl' is the grammar I'm using

[08:12] <sorear> pity that what I had to do to benchmark viv makes it impossible to benchmark nqp/rakudo

[08:13] <dalek> niecza: ffb2ed0 | sorear++ | src/ (2 files):

[08:13] <dalek> niecza: Fix sigspace not respecting :r optimization

[08:13] <dalek> niecza: review: http://github.com/sorear/niecza/commit/ffb2ed0c4790d7dee0e9a8838045fa1c9626163c

[08:17] <sorear> Is there a meaningful distinction between proto regex and proto token?

[08:17] <moritz_> I don't think so

[08:17] <moritz_> in rakudo you can add token foo:sym<foo> and regex foo:sym<bar> to the same proto

[08:17] <moritz_> I like that

[08:18] <moritz_> and since you have to be explicit about what you want in each candidate anyway, there's no need for the proto to carry such information around

[08:19] *** tadzik left
[08:21] *** Axius left
[08:22] *** timbunce joined
[08:23] *** timbunce left
[08:23] *** timbunce_ joined
[08:30] *** dakkar joined
[08:36] <masak> ok, so I made a patch to add 'each' junctions to Rakudo.

[08:36] <masak> it seems to work, in the sense that it doesn't fail any more spectests than before.

[08:36] <masak> unfortunately, the prototypical use case, @a.each.say, doesn't work.

[08:36] *** gfx left
[08:36] <masak> it just prints .perl of the junction.

[08:37] <masak> so somewhere, I need the each junction to do more dispatch than it does currently. any ideas?

[08:37] <tylercurtis> rakudo: (1 | 2).Str.say;

[08:37] <p6eval> rakudo 19a8b7: OUTPUT«any(1, 2)␤»

[08:37] <tylercurtis> rakudo: say ~(1|2);

[08:37] <p6eval> rakudo 19a8b7: OUTPUT«any(1, 2)␤»

[08:37] <tylercurtis> rakudo: say 1|2;

[08:37] <p6eval> rakudo 19a8b7: OUTPUT«any(1, 2)␤»

[08:37] <masak> right. seems autothreading doesn't happen with .say currently

[08:38] <masak> instead, it stringifies immediately.

[08:38] <masak> not sure where that happens.

[08:39] <moritz_> rakudo: say ~Mu.^methods

[08:39] <p6eval> rakudo 19a8b7: OUTPUT«so BUILDALL new Bool print say item WALK defined BUILD clone perl WHICH Capture CREATE PARROT bless WHENCE WHERE notdef ␤»

[08:40] <moritz_> there's a Mu.say

[08:40] <masak> ...which only delegates to the sub &say

[08:40] <tylercurtis> Which delegates to IO.say;

[08:40] <jnthn> which doesn't auto-thread

[08:41] <jnthn> (because it takes a slurpy array)

[08:41] <masak> oh

[08:41] <jnthn> (that's correct, afaik)

[08:41] <masak> even with the desired behaviour of the each junction factored in?

[08:41] *** amkrankruleuen left
[08:41] <masak> where will the autothreading of .each.say happen?

[08:42] *** amkrankruleuen joined
[08:43] <tylercurtis> IO.say calls IO.print which appears to pass the items directly to Parrot's IO-related PMCs, so I'm guessing the eventual stringification happens somewhere in parrot's guts.

[08:43] <moritz_> probably through the get_string vtable

[08:44] <jnthn> masak: Maybe each auto-threads more eagerly than a typical junction

[08:44] <jnthn> (on method calls)

[08:44] <masak> jnthn: yes, I suspect so too.

[08:44] <jnthn> e.g. maybe it doesn't look up the hierarchy for the method calls

[08:44] <jnthn> but that's ugly to implement

[08:44] <masak> jnthn: it's also interesting to think about how each interacts with all/none and any/one.

[08:44] <jnthn> We can do it when we get custom meta-classes.

[08:44] <masak> jnthn: my guess is that it's "outside" them all.

[08:45] <jnthn> And can override dispatch.

[08:45] <masak> jnthn: it's also interesting to thing about how each interacts with control structures. does it re-run if statements and while loops once for each element?

[08:45] <masak> my guess is yes.

[08:47] <jnthn> Well, same as other junctions I guess?

[08:47] <jnthn> (rusty on the spec)

[08:50] <masak> no, other junctions boolify in if statements and while loops.

[08:50] <masak> but each doesn't feel like it boolifies.

[08:51] <masak> i.e. `my @a = 1, 2, 3; my @b = 2, 3, 5; if each(@a) == any(@b) { say "yes" } else { say "no" }` would print "no\nyes\nyes"

[08:51] <masak> "...\n"

[08:52] * sorear ponders how each would fit into niecza's static junctions modle

[08:52] <masak> anyway, stowing my patch for now. it's not many lines that need changing to add it, which is positive.

[08:53] <moritz_> which patch?

[08:53] <masak> the one I prepared to add &each and .each and the 'each' type of Junction.

[08:54] <masak> (it should really be its own type, Each, but I wanted to try this first)

[08:54] *** kjeldahl joined
[08:56] <tylercurtis> Good night, #perl6!

[08:56] <masak> night, tylercurtis!

[08:57] <masak> dream of correctly autothreading exotic junctions :)

[08:57] *** thebird joined
[08:57] *** tylercurtis left
[08:57] <sorear> phenny: msg TimToady I need a parameter type which takes 0-infinity arguments, does NOT flatten, and puts them all into scalar context in a Seq or List

[08:58] <sorear> phenny: tell TimToady I need a parameter type which takes 0-infinity arguments, does NOT flatten, and puts them all into scalar context in a Seq or List

[08:58] <phenny> sorear: I'll pass that on when TimToady is around.

[08:58] <moritz_> how do each junctions collapse (or decompose into their eigenstates)?

[08:59] <sorear> .Bool

[08:59] <sorear> (canonically)

[08:59] <moritz_> that doesn't make any sense.

[09:01] *** jhuni left
[09:03] <masak> .Bool feels high-level to me, which would imply that it's not expemt from autothreading.

[09:03] <masak> I'd have guessed .so or prefix:<?>

[09:03] <jnthn> prefix:<?> calls .Bool, no?

[09:03] * sorear thought all three were synonyms

[09:03] <moritz_> .Bool makes sense for any, all, one, none

[09:03] <moritz_> but not for each

[09:04] <jnthn> I guess maybe each is not really a junction then.

[09:04] <sorear> each should trip on .sink

[09:04] <moritz_> the goal of an each junction is not produce a single boolean

[09:04] <moritz_> maybe assignment to an array?

[09:10] <masak> I don't know what you mean by that.

[09:11] <sorear> I guess .list might work too

[09:11] <moritz_> masak: what I mean by what?

[09:11] <sorear> but, @( each($(@arr1), $(@arr2)) )

[09:11] <masak> moritz_: <moritz_> maybe assignment to an array?

[09:12] <moritz_> masak: my @a = each(<a b c>).uc

[09:12] <moritz_> masak: the @a =  part is assignment to an array :-)

[09:12] <masak> I read that as making three single-item assignments to @a

[09:13] <masak> the function of 'each' is to hoist a for loop, encountered in the middle of an expression, up to the statement level.

[09:13] <moritz_> and I proposed that assignment to an array extracts the eigenstates

[09:13] <masak> ...making it a serial version of >>, no?

[09:14] <masak> a bit like &map is.

[09:14] <moritz_> well, more magical than either

[09:14] <masak> I'm not sure I see the utility. I'd prefer 'each' to be consistent across all uses.

[09:14] <smash> mornin' everyone

[09:14] <moritz_> each(<a b c>).lc.ucfirst

[09:14] <masak> smash: \o

[09:15] <masak> moritz_: that's just a refusal to use map or >> in my view.

[09:15] <moritz_> masak: well, that's the problem, it can't be consistent across all usages

[09:15] <masak> I'm not sure I see why you think so.

[09:16] <moritz_> because you need to have some kind of mechanism to stops its autodistribution

[09:17] <moritz_> so whatever that mechanism is, the behavior is *not* consistent across that mechanism and everything else

[09:17] <moritz_> just like junctions can't be made to autothread over boolean context, because that's how they collapse

[09:17] <masak> I'm lost. I don't drink coffee, but maybe I need to, now.

[09:17] <moritz_> let's start simple

[09:17] <masak> sure.

[09:18] <moritz_> each() should be a mechanism to do some operations on each item of the each() construct

[09:18] <moritz_> right?

[09:18] <masak> absolutely.

[09:18] *** jhuni joined
[09:18] <masak> .each.say being the prototypical example.

[09:18] <moritz_> and in general, you'll want to extract the return values in some form or another, right?

[09:18] <masak> no, I don't think so.

[09:19] <moritz_> ah, you only want it for its side effect

[09:19] <masak> I think the occurrence of each translates to several different statements.

[09:19] <masak> @a[0].say, @a[1].say, etc.

[09:19] <masak> each one having the ordinary return value of .say

[09:19] <moritz_> which you don't want to make available to the user

[09:20] <masak> sure, just as it's usually available.

[09:20] <masak> so if you do my $b = @a.each.say; you get a lot of redundant assignments.

[09:20] <masak> and the last one sticks.

[09:21] <moritz_> so you want to limit the effect of .each to the statement level?

[09:21] <masak> but I see what you mean. and no, in my model, the purpose of each is not to make an array of return values available to the user.

[09:21] <masak> yes, 'each' propagates to the statement level.

[09:21] <masak> that's its purpose.

[09:21] <masak> not return values.

[09:21] <masak> there are other good constructs for that already.

[09:22] <moritz_> which makes it not "uniform across all usages", because a possible usage is to ahve multiple statements

[09:22] <masak> well, uniform across all *intended* usages.

[09:22] <moritz_> somebody else will have different intentions than you do.

[09:23] <masak> clearly.

[09:23] <masak> that's why we're having this discussion now.

[09:23] *** daxim joined
[09:23] <masak> all I'm saying is that it's *very* consistent to always hoist 'each' up to the statement level.

[09:23] * moritz_ would like to see some use cases

[09:23] <masak> and then explain to people who use it wrongly why they're doing it wrong.

[09:24] *** patrickas joined
[09:25] <patrickas> Ola!

[09:25] <moritz_> \o

[09:26] <moritz_> patrickas: have you seen the series changes in the spec?

[09:28] <sorear> +1 to limiting each to statement level

[09:30] <patrickas> moritz_ yes I did .... does that mean the current patch is toast ... or can we apply it while waiting for someone to work on the new implementation ?

[09:31] <moritz_> patrickas: I'm fine with applying it for now

[09:32] <moritz_> running a spectest now

[09:33] <masak> TimToady: the 1, *+1 ... { $_ == 9 }, 10, *+10 ... { $_ == 90 }, 100, *+100 ... { $_ == 900 } example in the latest commit, can it also be written 1, *+1 ... 9, 10, *+10, ... 90, 100, *+100 ... 900? can it be written 1, *+1 ...^ 10, *+10 ...^ 100, *+100 ...^ 1000?

[09:33] <masak> oh; first question already answered by the spec. :)

[09:35] *** jhuni left
[09:49] *** robins is now known as robinsmidsrod

[09:51] <patrickas> moritz_: sorry I was on the phone. that's great then. Besides most of the things added in the patch will be useful to implement the new spec, (mostly allowing the first element of the rhs to be a closure)

[10:00] *** Italian_Plumber joined
[10:01] <patrickas> masak: Yesterday, I created a reddit account after years of lurking just to answer the python to perl6 question you mentioned this morning :-) My reply was surprizingly well received. And HIB0U has still not showed up. So all is well ...

[10:02] <frettled> patrickas: URL?

[10:02] <masak> patrickas: oh, it was you :) I only saw your very fine and detailed reply after I had posted mine...

[10:02] *** Schwern left
[10:02] <masak> frettled: http://www.reddit.com/r/programming/comments/damyp/learning_perl_6_by_playing_silly_games/

[10:03] <frettled> masak: thanks!

[10:03] <moritz_> patrickas: that was a very good answer

[10:07] <patrickas> Thanks... I always thought I was going to be eaten by trolls the second I post anything on reddit! :-)

[10:07] <frettled> patrickas++ — that workedout well.

[10:07] *** Italian_Plumber left
[10:09] <moritz_> t/spec/S05-transliteration/trans.rakudo and t/spec/integration/real-strings.rakudo both abort before running any test

[10:10] <patrickas> moritz_: Is that related to the seies patch spectest? or in general ?

[10:10] <moritz_> patrickas: not related - failed that way in my previous spectest run too

[10:10] <patrickas> oh ok

[10:11] *** araujo left
[10:17] <dalek> rakudo: b736c88 | patrickas++ | src/ (2 files):

[10:17] <dalek> rakudo: add ...^ operator

[10:17] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b736c8855472c8a4f02ed3745cd016d9854f9011

[10:17] <dalek> rakudo: 0a93184 | patrickas++ | src/core/operators.pm:

[10:17] <dalek> rakudo: Cleanup as per pmichaud++'s comment

[10:17] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0a93184111c55b78a234c0018f04c99ad17510ad

[10:17] <dalek> rakudo: 4615073 | moritz++ | src/core/operators.pm:

[10:17] <dalek> rakudo: Refactored series operator

[10:17] <dalek> rakudo: 

[10:17] <dalek> rakudo: Conflicts:

[10:17] <dalek> rakudo: 

[10:17] *** dalek left
[10:17] *** dalek joined
[10:17] *** ChanServ sets mode: +v dalek

[10:18] <moritz_> it seems I'v got the karma for that commit because I resolved a conflict

[10:18] <moritz_> patrickas++ deserves it

[10:19] <patrickas> Dalek knows who's the boss ;-)

[10:20] <patrickas> ok so I guess now I can git reset --hard rakudo/master and start working on the new spec in a new branch as I should have been doing all along :-)

[10:24] <colomon> dear heavens, that looks like a lot of changes to the series spec!

[10:26] <moritz_> indeed

[10:26] *** Patterner left
[10:27] <masak> good thing we haven't released Perl 6 yet.

[10:28] <patrickas> on the plus side that means I won't be bugging anyone with what I should be working on next :-)

[10:28] <frettled> masak: for some reason, that statement was ominously close to "release the hounds!"

[10:29] <masak> frettled: I guess that's why we're saving it for some very special circumstances.

[10:29] <masak> patrickas: congratulations, your first unit of torment! :)

[10:30] * masak liked http://twitter.com/Ne0lite/status/23902228880

[10:30] <frettled> masak: Ugh, I must be slipping, the meme these days is to show a clip of Liam Neeson as a Greek deity, commanding "Release Perl 6"

[10:31] <frettled> masak: pretty nice

[10:31] <frettled> But why does Rakudo say "PROFIT!!!" when it's told to say "Hello, world!"?  ;)

[10:31] <masak> Easter Egg :)

[10:31] *** Psyche^ joined
[10:32] *** Psyche^ is now known as Patterner

[10:32] <masak> frettled: for some reason, picturing Liam Neeson as a Greek deity isn't very difficult.

[10:34] <frettled> masak: http://www.youtube.com/watch?v=IFQvTRBeVp8 (endless repeat, apparently)

[10:36] <masak> frettled: that one is new to me. but it does feel right.

[10:37] <moritz_> .oO( geek deity )

[10:37] <frettled> I haven't seen the movie (Clash of the Titans), but I guess he needed the money.

[10:37] <frettled> moritz_++

[10:37] <frettled> Now, can we nettle TimToady into a spoof of that?  :D

[10:39] <moritz_> (totally Off-Topic: my thunderbird can't count; It says that Inbox has 1130 new e-mails. The inbox consists of three mail accounts, with unread counts (0, 52, 1))

[10:39] <frettled> moritz_: nothing in other folders?

[10:39] * masak .oO( "release the butterfly!" )

[10:40] *** Patterner left
[10:40] <frettled> Relese Camelia!

[10:40] <frettled> +a

[10:43] <daxim> let slip the butter of war!

[10:45] *** Psyche^ joined
[10:46] *** Psyche^ is now known as Patterner

[10:47] * colomon has to admit to feeling vaguely cheated by the series changes.

[10:48] * colomon wonders if that is a form of Stockholm syndrome.

[10:49] <masak> jnthn: I'm reading http://perl.plover.com/classes/typing/notes.html right now. it seems to be pleasant reading for someone who's thinking about type systems.

[10:49] <masak> colomon: is it just a general feeling of being cheated, or do you miss any of the old features?

[10:50] <colomon> It's mostly caused because I (and later patrickas) spent days banging my head against the old system trying to make it work.

[10:52] <frettled> And then someone just went and … fixed it?

[10:53] <colomon> frettled: you have to understand, we had the insanely complex version 95% working.

[10:53] <colomon> and the new change throws out all that work to replace it with something trivial.

[10:54] <frettled> I can see how that creates mixed feelings.

[10:54] <colomon> mind you, the new spec is vastly better.

[10:54] *** Mowah joined
[10:56] <jnthn> colomon: Welcome to Perl 6 dev.

[10:57] <colomon> the only thing I might miss is needing to write 1, 2, 4 ... * >= 900 instead of 1, 2, 4 ... 900

[10:57] <jnthn> After a couple of years of work to understand multi dispatch, I currently am throwing out most of what I knew of it.

[10:57] *** ruoso left
[10:57] <colomon> jnthn++

[10:57] <jnthn> Which is annoying, even if I have to admit the new spec is sane in ways the old one wasn't.

[10:58] <jnthn> (It's insane in new ways too of course :-))

[10:58] <colomon> you know, I think I have a little bit of single malt still hidden away in my desk drawer....

[10:58] <jnthn> ;-)

[10:58] <frettled> colomon: og glug glug?

[10:58] * jnthn gets back to $dayjobhacking for a bit, and looks forward to having 6model time a little later on today :-)

[10:58] <frettled> (alternative to the om nom nom meme)

[10:58] <colomon> sip sip sip

[10:59] <colomon> I sooooooo cannot afford to glug single malt at this junction in my life.

[10:59] *** Patterner left
[10:59] *** macroron joined
[11:00] <smash> something wrong in Test::is i can't debug :\

[11:01] <smash> or maybe further down the 'stack'

[11:07] *** Psyche^ joined
[11:07] *** Psyche^ is now known as Patterner

[11:08] <frettled> colomon: If not at this junction, when? :D

[11:09] <colomon> frettled: well, first the home repairs need to be finished and paid off...

[11:10] *** rhebus joined
[11:11] *** Patterner left
[11:11] <rhebus> good $time-of-day all

[11:12] <colomon> o/

[11:12] *** Psyche^ joined
[11:12] *** Psyche^ is now known as Patterner

[11:13] <rhebus> i have heard about using ordinary functions as methods -- how does this work?

[11:14] <rhebus> say I have a function sub remove-at (@arr is rw, Int $pos) { @arr.splice($pos, 1); return @arr }

[11:14] <rhebus> is it possible to call it as @arr.remove-at(3)?

[11:14] <jnthn> No

[11:14] <jnthn> But you can do

[11:14] <jnthn> @arr.&remove-at(3)

[11:14] <rhebus> aaaaah

[11:15] <rhebus> useful

[11:15] <rhebus> so any function can be invoked as a method on its first arg as $arg1.&func(@otherargs) ?

[11:16] <rhebus> (excluding nullary functions...)

[11:17] *** Patterner left
[11:17] *** Psyche^ joined
[11:17] *** Psyche^ is now known as Patterner

[11:18] <smash> rakudo: ([1,2]).map({shift $_}); # why is the list being flattened here ?

[11:18] <p6eval> rakudo ea77cc:  ( no output )

[11:19] <jnthn> yes, though "as a method" means no more than "in a way that looks like a method"

[11:19] <jnthn> It's syntactic sugar really for a sub call.

[11:19] <smash> rakudo: ([1,2],[3,4]).map({shift $_});

[11:19] <p6eval> rakudo ea77cc:  ( no output )

[11:21] <smash> hmm

[11:22] <rhebus> jnthn++

[11:23] <jnthn> Note that if you have any kind of code ref in a scalar then $lol.$wtf() also works.

[11:23] <jnthn> However, $lol.@cands() is different

[11:23] <frettled> How so?

[11:23] <jnthn> (S12 has details)

[11:23] <jnthn> frettled: The latter specifies the candidate list

[11:24] <jnthn> And nextsame etc will defer through that

[11:24] <jnthn> And .* will walk through it.

[11:24] <frettled> ooh

[11:24] <jnthn> $foo.*@stuff(); # call all the things in @stuff

[11:24] <jnthn> $foo.+@stuff(); # call all the things in @stuff and die if we don't call at least one thing

[11:25] *** azert0x left
[11:26] *** Italian_Plumber joined
[11:30] <rhebus> jnthn++ # language teaching

[11:30] <rhebus> the karma syntax is more specific than I previously thought

[11:32] *** azert0x joined
[11:34] *** [synth] joined
[11:35] <smash> colomon: just sent you a pull request to add the transpose function to List::Utils, please take a look at it when you have time, thank you

[11:36] *** synth left
[11:41] <colomon> smash++

[11:42] <masak> sri_++ # http://blog.kraih.com/actual-perl-marketing

[11:42] <_sri> \o/

[11:53] <colomon> smash: do you know if there is now a way to pull directly from your fork, or do I still need to do that stuff with adding your branch to my local checkout?

[11:56] *** Patterner left
[11:57] <colomon> (reads github help) Looks like I still need to do that stuff.

[11:57] *** Psyche^ joined
[11:57] *** Psyche^ is now known as Patterner

[11:57] *** tadzik joined
[11:58] *** envi^home joined
[11:58] *** sftp joined
[11:58] <pmichaud> good morning, #perl6

[11:58] <moritz_> _sri: do you have a vector graphic version of that book cover? we currently use the .jpg, and in print the letters of the author names are pixeled

[11:59] <tadzik> hello

[12:00] <colomon> o/

[12:01] <moritz_> rhebus: do you have an updated visitor count for your blog post?

[12:01] <moritz_> I'm curious if the 1k visitors I predicted actually came

[12:02] <takadonet> morning all

[12:02] <jnthn> morning, pmichaud 

[12:02] *** Patterner left
[12:04] <masak> morning, pm

[12:05] <masak> rakudo: sub infix:<$> (@list, $step) { gather for ^$step -> $a { for ^(@list.Int div $step) -> $b { take @list[$_] if $_ < @list given $b * $step + $a } } }; say (^9 $ 3).perl # mingle operator :)

[12:05] <p6eval> rakudo ea77cc: OUTPUT«(0, 3, 6, 1, 4, 7, 2, 5, 8)␤»

[12:05] <masak> this one gives the columns in tic-tac-toe.

[12:05] <rhebus> moritz_: 2110. or you can see it yourself http://rhebus.posterous.com/learning-perl-6-by-playing-silly-games

[12:06] <moritz_> ah right, missed the "viewed" number

[12:06] <moritz_> rhebus++

[12:06] <rhebus> if i blog on perl 6 again, i think i might move to wordpress

[12:06] <rhebus> posterous is godawful

[12:07] <rhebus> posterous-- # stupid broken post editor

[12:07] <[Coke]> .

[12:08] <[Coke]> dukeleto added phasers to the google comp.lang.parrot calendar. anyone wants any other vaguely related events added (like the attemtped cpan6 sketch), let him (or me) know.

[12:09] <masak> what does it mean to add phasers to the calendar?

[12:10] <rhebus> masak: add it to perl6/perl6-examples/games/tictactoe.p6 :)

[12:11] <masak> tempting... let's see if someone manages to come up with a shorter way to write the sub first :)

[12:11] <masak> it seems too long to me.

[12:11] <[Coke]> do you know what it means to add an event to a calendar? (esp. a google calendar?)

[12:11] <masak> [Coke]: no, I understand that part.

[12:12] <masak> [Coke]: but in which sense are phasers an event?

[12:12] <[Coke]> ok. that's all that is.

[12:12] <[Coke]> masak: #phasers

[12:12] <masak> oh!

[12:12] <masak> sorry, I get it now.

[12:12] <rhebus> masak: actually, i have written tictactoe.p6 as a series of refinements - and therefore a teaching tool - rather than just the final product

[12:12] <[Coke]> \o/

[12:12] <[Coke]> it's just the calendar that's visible off here:

[12:12] <[Coke]> http://www.parrot.org/

[12:13] * masak also realizes there must have been a #phasers event yesterday, and that he missed it :/

[12:13] *** Psyche^ joined
[12:14] <moritz_> there are logs :-)

[12:15] <masak> perusing them currently.

[12:17] <moritz_> (off-topic again: in the last few weeks there were two scientific paper in the media, which were produced at my workplace: http://www.nature.com/nphoton/journal/vaop/ncurrent/fig_tab/nphoton.2010.214_F5.html (covered on slashdot) and http://www.nature.com/nphoton/journal/vaop/ncurrent/fig_tab/nphoton.2010.214_F5.html (covered on heise.de) )

[12:17] <masak> seems #phasers was mostly about why #cpan6sketch hasn't taken off. I think that's a good discussion to have.

[12:17] <moritz_> seems I have more geek neighbours than I knew :-)

[12:18] *** Psyche^ left
[12:18] *** Psyche^ joined
[12:18] *** Psyche^ is now known as Patterner

[12:21] <masak> TimToady: thanks for correcting my LTA hyphen/apostrophe explanation. I will memorize the rule "R2-D2 is street legal, C-3PO isn't" :)

[12:21] <frettled> Oh, lovely.

[12:23] <moritz_> std: R2-D2

[12:23] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤ 'R2-D2' used at line 1␤Check failed␤FAILED 00:01 114m␤»

[12:24] *** pkkm joined
[12:24] <pkkm> Will perl6 be slower than perl5 because of virtual machine?

[12:25] <moritz_> Perl 5 also uses a virtual machine

[12:25] <frettled> Mu.

[12:25] <moritz_> it's just more tightly coupled with the compiler

[12:26] *** JimmyZ joined
[12:26] <moritz_> so the answer is "no". We don't know yet if p6 is going to be faster or slower than p5, but if it's slower, certainly not because it uses a VM

[12:26] <frettled> …and the tightness of the coupling depends on the Perl 6 implementation.

[12:29] <masak> pkkm: Perl 6 is currently much slower than Perl 5. but in many cases, we know why and how to speed it up. it's just that the focus has been on getting it to run rather than getting it fast so far.

[12:30] <pkkm> So will it be faster than Java?

[12:30] <frettled> Mu.

[12:30] <masak> pkkm: you should realize that such questions are almost, but not quite, meaningless.

[12:30] <masak> faster with what benchmark?

[12:31] <masak> on what computer?

[12:31] <masak> and so on.

[12:31] <frettled> Will Java ever be faster than Java?

[12:31] <moritz_> will Perl be faster than Forth?

[12:31] <masak> also, rest assured that if we are ever given the choice to make Perl 6 faster than Java, we will not hesitate to make it so :)

[12:31] <moritz_> :-)

[12:32] * JimmyZ wonders whether he is faster than perl :)

[12:32] * moritz_ wonders if a JIT compiler would speed up JimmyZ :-)

[12:32] * JimmyZ or not

[12:32] <frettled> For more references, see old (but awful) discussions on whether Java is faster than C, or whether Common Lisp is slower than C, or …

[12:33] <masak> pkkm: if all we cared about was runtime speed, we'd all be using assembly or C. but that's not all we care about.

[12:33] *** Patterner left
[12:33] <frettled> masak: or Common Lisp ;)

[12:33] * JimmyZ doen't want JIT, he maybe want airplane

[12:33] <frettled> JimmyZ: and a pony!

[12:33] <masak> right. assembly, C, or Common Lisp :)

[12:33] <frettled> and surprise.

[12:33] <masak> JimmyZ: a JIT airplane, how could would that be? :)

[12:34] <frettled> Few things are quicker than surprise.

[12:34] <JimmyZ> masak: that's a good idea.

[12:34] <TiMBuS> jump off a building, and build your aircraft before you hit the bottom

[12:35] *** Psyche^ joined
[12:35] *** stepnem left
[12:36] <smash> colomon: (pull directly) sorry, don't know

[12:37] *** Psyche^ is now known as Patterner

[12:38] <frettled> pkkm: Perhaps a more relevant comparison is the hubbub surrounding the introduction of Perl 5.  Perl 5 was appreciated as being more feature-rich, but also a slow mastodont as compared to Perl 4, when looking at the things that Perl 4 was good at.  Perl 6 isn't quite there yet, and Perl 6 also has a few more years to go to reach the kind of maturity that Perl 4 had in the early nineties, or Perl 5 has now.

[12:38] *** stepnem joined
[12:39] <tadzik>  Perl cannot be faster, Perl implementation can be

[12:39] *** ruoso joined
[12:39] <masak> same thing with early Ruby implementations. hailed as nice, but slow. they've slowly been able to speed some of them up over the years.

[12:40] * flussence points to the current browser wars, and how slow JS used to be

[12:40] <PerlJam> good morning #perl6

[12:40] <frettled> flussence: and still is — Mozilla has decided to avoid the problem by throwing hardware at it.  ;)

[12:41] *** yrgd left
[12:41] <masak> morning, PJ

[12:41] <pkkm> Often, pretty simple Java programs eat up enormous amount of resources (for example, JDownloader can slow down my Core2Duo @2,66 4GB RAM computer). Perl 5 GUI programs don't behave like that, even if they are much more complex than JDownloader.

[12:42] <frettled> Perhaps someone should look into hardware-accelerated Perl 6 operations, throw some of them to e.g. that Apple open source library.

[12:43] <colomon> smash: appears the answer is no.  anyway, pulled and pushed.

[12:43] <colomon> smash++

[12:44] <smash> colomon: great, thank you

[12:44] <smash> colomon++

[12:44] <PerlJam> Given that the focus has been on correctness rather than speed, we should probably focus on doing cool things where no one cares if they are a little slow.

[12:44] <PerlJam> Then, when the speed improvements happen, everyone will be in even *more* awe  :)

[12:45] *** Patterner left
[12:46] *** [synth] is now known as synth

[12:47] <masak> PerlJam: that's a good summary of how I currently choose new venues to explore.

[12:47] *** synth is now known as synths

[12:47] <masak> PerlJam: I want my next blog to be in Perl 6, but Rakudo is too slow to serve webpages in any greater quantities. so I'll make a static webpage generator instead.

[12:47] *** synths is now known as synth

[12:47] *** synth left
[12:48] <mathw> masak: cool

[12:48] <frettled> masak: It's nicer on the webserver anyway.

[12:48] <PerlJam> mathw: exactly!  :)

[12:48] <masak> I'll package it so that others can use it too.

[12:48] <PerlJam> masak++

[12:48] <mathw> I was considering using Rakudo to write a CMS, which would chew data files and generate a site

[12:48] <patrickas> frettled: That's not try about mozilla ... But I guess you were joking.

[12:48] <masak> still a bit unsure how to do with comments.

[12:48] <frettled> masak: And if you push a bit of work to the client with AJAX, you can get some pretty nice things out of it anyway.

[12:48] <mathw> and then just provide the person who the site is for with a really light Perl 5 interface to edit the data files with

[12:49] <mathw> until such time as it's fast enough to do that in Perl 6

[12:49] <frettled> patrickas: http://www.webmonkey.com/2010/08/fourth-firefox-4-beta-adds-panorama-hardware-acceleration/

[12:49] <mathw> masak: meh, comments

[12:49] <mathw> nobody needs those :)

[12:49] <masak> :)

[12:49] *** Italian_Plumber left
[12:49] <mathw> invite people to @ you on twitter if they feel it's important

[12:49] <patrickas> frettled: Their hardware acceleration is orthogonal to their javascript speed improvements.

[12:49] <mathw> why would you want it recorded attached to the article?

[12:49] <mathw> someone might say something disapproving... :)

[12:50] <frettled> patrickas: yes, that was the joke part, because they seem unable to catch up to the competition performance-wise.

[12:50] <moritz_> then you can delete it :-)

[12:50] <frettled> patrickas: both Chrome and MSIE will be applying graphics acceleration.

[12:51] *** Italian_Plumber joined
[12:51] <patrickas> frettled: on the v8 benchmarks they are now as fast as apple nitro's implementation

[12:52] <frettled> patrickas: that's wonderful, but they're continuously one generation behind in speed.  That is, current Firefox seems to be on par with previous-generation Safari, Chrome et al.

[12:52] <mathw> Chrome are doing hardware graphics too? cool

[12:53] <frettled> While V8 may bridge the gap to the current Chrome/Safari speed, that is not so promising, becaus neither Apple nor Google are sleeping in class.

[12:53] <mathw> oddly

[12:53] <frettled> It would be really cool if we could have the same kind of competition for implementations of Perl 6.

[12:53] <mathw> I've found firefox 4b4 as fast as Chrome on my PC

[12:53] <mathw> in qualitative use

[12:53] <moritz_> frettled: indeed :-)

[12:53] <frettled> mathw: Firefox 3.6.9 is the current version.

[12:53] <mathw> yes I know that

[12:53] <frettled> mathw: you need to compare with Chrome 7.

[12:53] <mathw> and yes, it is horribly slow

[12:54] <patrickas> frettled: but I don't think they *are* comparing to nightly builds of other browsers

[12:55] <mathw> patrickas: the IE team certainly don't publish comparisons against nightlies

[12:55] <frettled> All I'm saying is that it's a bit weird to compare the performance of an upcoming release of one product, with the current stable release of other products.

[12:55] <mathw> standard practice

[12:55] <patrickas> mathw: I am talking about mozilla

[12:55] <patrickas> frettled: definetely!

[12:55] <mathw> it's handy to be able to compare against something fixed

[12:56] <frettled> but ultimately useless

[12:56] <mathw> epsecially if it's a version your potential users have in their hands right now

[12:56] <mathw> a marketing trick really

[12:56] <patrickas> did chrome have a new release on aug 23?

[12:56] <[Coke]> hard to tell when chrome has new releases.

[12:57] <patrickas> because in the mozilla comparision chart, chrome had a 10% improvement on that day ... so I assumed they were comparing themselves again moving targets and not assuming the competition is sleeping in class

[12:57] <frettled> patrickas: that may be the day when Chrome 6 was released.

[12:58] * moritz_ continues trolling perlmonks with Perl 6 answers

[12:58] <frettled> no, wait, that was September 2.

[12:58] *** Psyche^ joined
[12:58] <frettled> moritz_: URL! :D

[12:58] *** Psyche^ is now known as Patterner

[12:58] *** Kodi joined
[12:58] <frettled> patrickas: so either the comparison was against Chrome 5, or against a Chrome 6 beta.

[12:59] <Kodi> How can I get the ability to close RT tickets, so I can mark some outdated issues as resolved?

[12:59] <phenny> Kodi: 07 Sep 17:45Z <moritz_> tell Kodi fyi your patches don't have a proper email address (not problem, but if it's a misconfiguration, you'd might want to know)

[13:00] <patrickas> frettled: that's possible. In that case you would be right.

[13:00] <Kodi> moritz_: I figure spambots would get a real email address, because of, e.g., GitHub's web interface.

[13:00] <moritz_> [Coke], pmichaud: can one of you please give Kodi permission to the perl6 RT queue?

[13:00] <[Coke]> Kodi: get one of the regulars to vouch for you, and I can enable that.

[13:00] <[Coke]> wow, that was quick.

[13:01] <moritz_> :-)

[13:01] * pmichaud vouches

[13:01] <pmichaud> I need to bookmark the rt admin url somewhere.

[13:02] <Kodi> \me feels vouchsafe.

[13:02] <Kodi> Doggone it.

[13:02] <frettled> patrickas: http://www.pcworld.com/printable/article/id,204925/printable.html

[13:02] <[Coke]> Kodi: rt id?

[13:02] <smash> added a possible perl 6 solution for the bead sort task on rosetta code

[13:02] <Kodi> [Coke]: Kodi

[13:03] <frettled> Opera is still quicker, that's nice.

[13:03] <[Coke]> Kodi: done

[13:03] *** Patterner left
[13:04] <[Coke]> pmichaud: I find the URL by going to trac.parrot.org, browse source, find metacommitter guide, go back in time.

[13:04] <masak> moritz_: trolling perlmonks -- url?

[13:04] <[Coke]> and I have yet to bookmark the damn thing. doing so at least on this browser...

[13:04] <pmichaud> [Coke]: I just did the same

[13:04] <Kodi> Works; great.

[13:04] <pmichaud> colomon: what url did you obtain?  I'm finding the wrong one.

[13:05] <pmichaud> s/colomon/coke  # tab fail

[13:05] <[Coke]> https://rt.perl.org/rt3/Admin/Groups/Members.html?id=20479

[13:05] <moritz_> masak: http://www.perlmonks.org/?node_id=859306

[13:05] <[Coke]> it says parrot, but we shared admin privs.

[13:05] <masak> `thanks.

[13:05] <pmichaud> that's the one.  thanks.

[13:05] <pmichaud> (also bookmarked)

[13:06] <[Coke]> moritz_: is perlmonks insanely slow, or is it just my cxn?

[13:06] <masak> slow here too.

[13:06] <moritz_> [Coke]: perlmonks is slow

[13:07] <masak> moritz_: I liked that one. it shows one place where you don't have to load a module to do what the requestor wanted, as opposed to Perl 5.

[13:07] *** [particle] joined
[13:07] <patrickas> frettled: That's .... dissapointing

[13:08] *** Italian_Plumber left
[13:09] *** javs joined
[13:09] *** javs left
[13:09] *** javs joined
[13:09] *** Italian_Plumber joined
[13:10] <frettled> patrickas: it might be the benchmark, but it seems strange that a cherry-picked benchmark touting Chrome as faster would still show Opera as fastest.

[13:10] *** orafu left
[13:10] *** orafu joined
[13:11] <patrickas> It's not really strange if opera is actually fastest

[13:12] *** synth joined
[13:12] <[Coke]> moritz_: this is unusably slow. 

[13:12] <[Coke]> ah well.

[13:13] <frettled> It's annoying that rt.perl.org, pause etc. use invalid certificates.  :(

[13:14] <moritz_> http://yosefk.com/c++fqa/

[13:14] *** Psyche^ joined
[13:14] <frettled> Heh, nice, "frequently questioned answers".

[13:14] *** Psyche^ is now known as Patterner

[13:14] <[Coke]> frettled: FSOV invalid, yah.

[13:15] <patrickas> frettled: It seems the tests were run by computerworld so they were not necessarly cherry picked to claim Chrome is fatest

[13:15] <[Coke]> but certs ain't free, and rt and pause web interface are not really external interfaces.

[13:15] <[Coke]> s/certs/certs signed by the big guys/

[13:15] <frettled> [Coke]: StartCom.

[13:16] <masak> about some C++ templates: "don't read this, it's impossible. just count the lines" -- http://yosefk.com/c++fqa/defective.html

[13:16] <masak> lovely.

[13:16] <frettled> patrickas: With Confuserworld, you'd imagine the deck to be stacked for MSIE ;)

[13:18] <moritz_> masak: wow, that example is harmless, compared to error messages I got with C++

[13:18] <[Coke]> frettled: those are still $$.

[13:18] <[Coke]> I'm not saying it's expensive, but for a non-user-facing site, what's the poitn?

[13:18] <masak> moritz_: I think that's not an error message -- that's code. :/

[13:18] <[Coke]> (also, I am not a perl.org admin.)

[13:19] <moritz_> masak: right

[13:20] <frettled> [Coke]: PAUSE is user-facing.

[13:21] <frettled> And even non-users may not be allowed to install third-party CA certificates.

[13:24] <[Coke]> PAUSE is CPAN AUTHORs, neh?

[13:25] <[Coke]> in any case, I have no influence on Robert and Ask in this area.

[13:25] <[Coke]> (and pause is not them, anyway, they're RT etc.)

[13:26] *** Italian_Plumber left
[13:26] <frettled> This may be a strange notion, but CPAN authors are users.

[13:26] *** Holy_Cow joined
[13:26] <frettled> I'll stop harping now :)

[13:32] *** sftp left
[13:33] *** sftp joined
[13:34] *** icwiener joined
[13:35] *** JimmyZ left
[13:40] *** Kodi left
[13:43] *** javs left
[13:43] *** Italian_Plumber joined
[13:49] *** Axius joined
[13:55] *** hudnix joined
[13:56] *** javs joined
[13:58] *** agentzh left
[14:02] <masak> buubot: eval END { print "OH HAI\n" }; die "oh noes"

[14:02] <buubot> masak: ERROR: oh noes at (eval 40) line 1. OH HAI       

[14:02] <masak> rakudo: END { say "OH HAI" }; die "oh noes"

[14:02] *** uniejo left
[14:02] <p6eval> rakudo ea77cc: OUTPUT«oh noes␤  in main program body at line 22:/tmp/FgUuXM3aoF␤»

[14:02] * masak consults S04

[14:03] <masak> no mention.

[14:03] * masak submits rakudobug

[14:04] *** Italian_Plumber left
[14:04] *** sftp_ joined
[14:04] *** sftp left
[14:12] *** mfollett joined
[14:12] *** patspam joined
[14:12] *** [particle] left
[14:17] *** risou joined
[14:19] <masak> "Adding type-checking to Perl would be like making a hot fudge sundae with mashed potatoes instead of ice cream and with gravy instead of fudge. It might be perfectly edible, but it wouldn't be a hot fudge sundae." -- mjd, http://perl.plover.com/classes/typing/notes.html

[14:20] *** amkrankruleuen left
[14:20] * moritz_ soemtimes wants to eat something that's not hot fudge sundae :-)

[14:20] *** alester joined
[14:20] *** amkrankruleuen joined
[14:21] * jnthn decommutes

[14:22] <rhebus> gah, that slide is wrong is so many ways

[14:23] <rhebus> oh wait, he's talking about *compile-time* type checking

[14:23] <masak> aye.

[14:23] <rhebus> which i guess makes it a reasonable point

[14:24] <masak> he's basically saying that Perl will never be ML.

[14:24] <moritz_> that's something I can easily agree with

[14:24] <rhebus> but if they breed correctly, they might have a common descendent :)

[14:24] *** foodoo left
[14:25] <moritz_> haskell and ML are kinda extremists

[14:27] <moritz_> which is fine for some, and not for others; perl traditionally fills a different niche

[14:27] <mathw> quite

[14:27] <mathw> I happen to rather like strong typing myself

[14:27] <mathw> but I appreciate Perl's flexibility in that

[14:28] <rhebus> i took an evening to try to learn some erlang a week back

[14:28] <rhebus> it seems similarly extreme

[14:28] <PerlJam> Perl 6 is leaking into Haskell's niche quite well I think  :)

[14:28] <mathw> even a strongly-typed system can be more fun if you can do type-related decisions at runtime

[14:28] <PerlJam> s/Haskell/FP/ really

[14:29] <mathw> Well kind of

[14:29] <rhebus> hmm, i can't think of many languages I'd describe as dynamically-typed functional languages

[14:29] <mathw> Perl 6 lets you do a lot more FP-type stuff

[14:29] <moritz_> PerlJam: it enables many FP features, but I haven't seen any empirical signs that Haskell programmers migrate to P6 :-)

[14:29] <mathw> but Haskell is relentlessly, totally functional

[14:29] <mathw> also relentlessly, totally lazy

[14:29] <mathw> which Perl 6 most definitely isn't

[14:30] <PerlJam> P5 had FP tendencies, and P6 more so.

[14:30] <mathw> Perl 6 is a happy place where paradigms meet

[14:30] <mathw> unlike C++, which is a dusty place full of razor-sharp rocks where paradigms meet when they're feeling depressed

[14:30] <PerlJam> s/had/has/ # don't want to accidentally write the obit just yet  ;-)

[14:31] <PerlJam> Perl 6 is the paradigm bar?  They drink beer and sing karaoke?

[14:32] <rhebus> non-pure-functional languages are basically going through the pockets of functional languages for useful features

[14:32] <moritz_> PerlJam: that's a nice metaphor

[14:32] *** alester left
[14:32] <rhebus> even C++0x is getting lambdas

[14:32] <PerlJam> rhebus: Perl has a long history of stealing good ideas, it's just that other languages have stolen *that* idea  ;)

[14:32] <rhebus> :)

[14:33] <rhebus> I think English got there first on the whole stealing foreign features thing :)

[14:33] <PerlJam> rhebus: true.

[14:33] <moritz_> PerlJam: we should have got a business pattern patent on stealing features from other programming languages

[14:33] <moritz_> :-)

[14:33] <masak> It's hard to make a good language without stealing lambdas. *cough* Java *cough*

[14:34] <rhebus> i really like the fact that the word "trousers" comes from scots gaelic... from a people known for *not* wearing trousers

[14:34] <rhebus> java doesn't have lambdas? »ö«

[14:34] <masak> rhebus: it's a reverse Sapir-Worf effect

[14:34] <mathw> rhebus: C++ with lambdas is going to save my sanity when I finally get to use it at work

[14:35] <mathw> and no, Java doesn't have lambdas

[14:35] <mathw> they use instances of anonymous subclasses instead

[14:35] <mathw> not fun

[14:35] <masak> :(

[14:35] <mathw> I believe it's about the most commonly requested feature addition for Java 7

[14:35] <mathw> whenever that might or might not happen

[14:35] <rhebus> even C++ has boost::lambda, which is an ugly bugger but does the job

[14:35] <mathw> yeah... kind of :)

[14:35] <mathw> real lambdas will be much nicer though

[14:36] <mathw> first time I saw boost::lambda my jaw hit the floor

[14:36] <rhebus> wasn't there a big lambda hoo-ha in python as well?

[14:36] <mathw> I had no conception you could do anything like that

[14:36] <moritz_> Mathematica has #^2& for * ** 2 or -> $x { $x ** 2}

[14:36] <rhebus> mathw: mine too

[14:36] <mathw> but operator overloading gets you a lot :)

[14:36] <mathw> as does abuse of the template system

[14:36] <mathw> c.f. boost::mpl

[14:36] <rhebus> yes

[14:36] <rhebus> and boost::spirit

[14:36] <moritz_> just the resulting error messages are... !fun

[14:36] <mathw> oh yeah spirit's impressive

[14:37] <mathw> the error messages are... entertaining

[14:37] <mathw> sometimes Sun C++ comes up with some real crackers

[14:37] <rhebus> yeah, spirit's impressive alright

[14:37] <mathw> which could almost be better written as "main.cpp:45 DO NOT WANT"

[14:37] <rhebus> but when i had to implement a parser for a job, i still just went recdescent

[14:38] <mathw> I have no idea what the runtime performance of a Spirit parser is

[14:38] <rhebus> mathw: that's just a symptom of templates in general D:

[14:38] <mathw> Perl 6 still wins in parser land

[14:38] * moritz_ points people to http://maddingue.free.fr/conferences/bpw-2010/enterprise-perl/

[14:38] <mathw> don't care about the performance yet

[14:38] <mathw> but the syntax is sublime

[14:39] <rhebus> mmm, delicious stack traces

[14:39] <Maddingue> ^^

[14:39] <masak> as long as END is executed after them... :)

[14:39] <rhebus> wow these slides are entertaining

[14:40] *** pkkm left
[14:41] <Maddingue> thanks

[14:41] *** alester joined
[14:41] <rhebus> i especially like U+1F4A9

[14:41] * moritz_ enjoyed the lightning talk at YAPC::EU; it was one of the few that had no problem keeping their time limit :-)

[14:42] <Maddingue> the most funny thing, which I didn't say and isn't noted here is that the Møøse traces are just.. warnings

[14:42] <Maddingue> more than 200 lines of warnings

[14:42] <Maddingue> but the code still works

[14:43] *** snearch joined
[14:43] <rhebus> why do the warnings produce traces? that's retarded

[14:44] <Maddingue> I could say "that's Møøse", but that would be very mean. it's probably a setting somewhere that does this, but the end result is the same

[14:44] *** Guest23195 left
[14:45] *** [particle] joined
[14:46] *** Axius left
[14:46] <arnsholt> Is there a simple way to call a parent class's method in NQP/PIR?

[14:46] *** Axius joined
[14:46] <arnsholt> (Where I've overridden the method in my class)

[14:47] <moritz_> arnsholt: I think you need pir::find_method

[14:47] <moritz_> with the explicit parent class

[14:47] <arnsholt> Right. Thanks

[14:49] *** Axius left
[14:49] *** wtw left
[14:49] *** Axius joined
[14:51] *** masak left
[14:52] *** ash_ joined
[14:52] *** pkkm joined
[14:52] <ash_> ping moritz_ 

[14:54] *** silug left
[14:57] <moritz_> ash_: pong

[14:57] <ash_> just wanted to let you know, i updated the backend to try.rakudo.org 

[14:58] *** Axius left
[14:58] <moritz_> \o/

[14:58] <moritz_> ash_++

[14:58] <moritz_> ash_++

[14:58] <moritz_> ash_++

[14:58] <moritz_> ash_++

[14:58] *** Axius joined
[15:00] <mfollett> ash_++

[15:00] <mfollett> I didn't know that existed, but I'm happy that it does!

[15:01] <mfollett> Where is that linked from though on the rakudo or perl6 site?

[15:01] <moritz_> nowhere yet

[15:01] <moritz_> it wasn't working properly before

[15:01] <moritz_> fsvo "properly" :-)

[15:02] <ash_> http://try.rakudo.org/?input=say%20~(1,%203%20...%207)

[15:02] <ash_> if you wana see it

[15:03] <moritz_> and it's surprisingly fast, once you have started the session

[15:03] <mfollett> yeah, that is awesome

[15:03] <ash_> ya, i noticed that server is a LOT faster than my test server

[15:04] <ash_> it used to take 1~2 seconds to start a session, now you almost don't notice it starting

[15:05] <moritz_> ash_: will you blog about it?

[15:05] <ash_> rakudo: say [\,] 1...3 # what do \, mean here? 

[15:05] <p6eval> rakudo ea77cc: OUTPUT«11 21 2 3␤»

[15:05] <moritz_> rakudo: say ~[\~] 1..5

[15:05] <p6eval> rakudo ea77cc: OUTPUT«1 12 123 1234 12345␤»

[15:05] <ash_> umm good point moritz_ ya, i'll prepare a little something about it 

[15:05] <moritz_> the [

[15:06] <ash_> that one looks more sane, not sure i understand \, 

[15:06] <moritz_> the [\ ] is the "triangle reduce"

[15:06] <ash_> h

[15:06] <ash_> ah

[15:06] <moritz_> rakudo: say ([\,] 1..5).perl

[15:07] <p6eval> rakudo ea77cc: OUTPUT«(1, (1, 2), ((1, 2), 3), (((1, 2), 3), 4), ((((1, 2), 3), 4), 5))␤»

[15:07] <moritz_> maybe it should flatten... not sure :-)

[15:08] <TimToady> I think list associative ops should probably remove the extra parcel

[15:08] <phenny> TimToady: 08:58Z <sorear> tell TimToady I need a parameter type which takes 0-infinity arguments, does NOT flatten, and puts them all into scalar context in a Seq or List

[15:08] <tadzik> ash_: well, I'm afraid something's fscked :(

[15:08] <moritz_> arnsholt: re http://github.com/perl6/nqp-rx/issues#issue/7, a reasonable workaround is to add a :returns('Typename') 

[15:08] <tadzik> ash_: say 5 / 2, then say 2 + 19

[15:09] <tadzik> it prints 2.5 twice, like in good^Wold times

[15:10] <ash_> tadzik: try rand twice in a row

[15:10] <TimToady> sorear: that's what a **@slice is supposed to do, I think

[15:11] <ash_> tadzik: are you getting multiple lines each time you enter rand?

[15:12] <ash_> it might be a caching issue, if your browser has the old javascript file then something could be wrong, but i am not sure i am getting the same result as you are 

[15:13] * moritz_ doesn't see any signs of re-evaluation

[15:13] <Sec> ash_: works fine for me.

[15:17] *** justatheory joined
[15:24] <Sec> rakudo: say &say.signature

[15:24] <p6eval> rakudo ea77cc: OUTPUT«get_attr_str() not implemented in class 'Perl6MultiSub'␤  in main program body at line 1␤»

[15:24] <ash_> lol, i just realized i didn't take out the chapter commands in the try site, if you type "chapter 1" it tries to load it, but fails, so it just clears the screen and puts up the help 

[15:25] <ash_> rakudo: say &infix:<+>.signature

[15:25] <p6eval> rakudo ea77cc: OUTPUT«get_attr_str() not implemented in class 'Perl6MultiSub'␤  in main program body at line 1␤»

[15:25] <ash_> that might be a bug on all mutli's 

[15:25] <ash_> maybe? 

[15:25] <ash_> rakudo: say &infix:<+>.^methods(:local)

[15:25] <p6eval> rakudo ea77cc: OUTPUT«namemulticandidates␤»

[15:40] *** silug joined
[15:40] *** Axius left
[15:41] <tadzik> ash_: works fine after hard refresh, I thought I did it before, pardon

[15:43] *** Guest23195 joined
[15:43] <arnsholt> moritz_: I've tried adding :returns('Float') but it doesn't seem to make a difference

[15:44] <arnsholt> Not sure why, but from what pmichaud said, I think this is more of a PCT issue than an NQP issue

[15:44] <pmichaud> it's a PCT bug.

[15:48] <TimToady> smash: I moved your beadsort to the right place in alphabetical order

[15:57] *** Ross joined
[15:59] <jnthn> TimToady: What would be the output of:

[15:59] <jnthn> proto x($) { {*} }

[15:59] <jnthn> multi x($x) { 1 }

[15:59] <jnthn> my $c; { multi x(Int $x) { 2 }; $c = &x }

[15:59] <jnthn> say $c(42);

[16:00] <TimToady> I would expect 2

[16:00] <jnthn> OK

[16:00] * moritz_ 2

[16:00] <jnthn> So what *is* &x?

[16:00] <jnthn> (I expected it too. It just nicel

[16:00] <TimToady> the candidate list for that scope

[16:01] <jnthn> y lets me get at what I want to ask. :-))

[16:01] <jnthn> OK, so it's not the proto?

[16:01] <jnthn> It's "something else"?

[16:01] <TimToady> maybe the proto curried with the current scope

[16:01] <jnthn> If so, what should that something else look like?

[16:01] <jnthn> OK

[16:01] <jnthn> So in that case protos all have an implicit "curry me with a candy list" parameter?

[16:02] <TimToady> or the dispatcher that proto calls curried with the scope

[16:02] * TimToady waves his hands vaguely

[16:02] <jnthn> :P

[16:03] <jnthn> Put another way, is there ever a circumstance where &x really means "give me the proto"? Or is it always "give me a curried proto"?

[16:03] <jnthn> That is, we never see the proto in its naked uncurried form.

[16:03] <jnthn> Currying the proto did occur to me as a solution, fwiw.

[16:04] <TimToady> I'm a bit uncomfy with that

[16:04] <jnthn> So was I

[16:04] <jnthn> But I've been uncomfy with every other solution so far too... :-S

[16:04] <jnthn> Still hunting for something that feels right.

[16:04] * moritz_ can't resist.... "it's lexical all the way down!"

[16:04] <jnthn> :P

[16:04] <TimToady> I guess it could get the info from CALLER instead of by currying

[16:05] <jnthn> Looking at the CALLER is what I've done in 6model before I went off on vacation but I realized it's really fragile.

[16:05] <TimToady> hmm, that doesn't work for &x though

[16:05] <jnthn> Well, that for one.

[16:05] <jnthn> It's also off-by-one when you inline

[16:05] <jnthn> And if you wrap the proto then heck knows what the caller is.

[16:06] *** ash_ left
[16:06] <TimToady> perhaps it's kind of a generic function that clones itself when put into a lower scope

[16:06] <TimToady> you can get the original by making sure you look for &x in the right scope

[16:06] <jnthn> What is "the original" though? In the example above, I have candidates at the same level as the proto, for example.

[16:07] <jnthn> I can go with something clone-y though in general.

[16:07] <jnthn> Does it sound wrongish that we'd install something different for &x in each scope that declares some new multi candidates?

[16:07] <TimToady> it might be deep magic; not sure how it would look at the surface

[16:08] <jnthn> (each inner scope, that is, given a proto somewhere to the outer)

[16:08] <TimToady> it doesn't sound wrongish to me

[16:08] <jnthn> What about in the inheritance situation?

[16:08] <jnthn> Same answer?

[16:08] <TimToady> don't see any difference there, offhand

[16:08] <jnthn> That is, the methods table has something in it if the class declares some multis at all?

[16:08] <TimToady> you have to make sure there isn't an explicit one there already

[16:08] <TimToady> in either case

[16:08] <jnthn> It's just that it incorporates all the candidates up the tree?

[16:09] <jnthn> Sure, I'm just thinking that it looks different from an introspection POV perhaps.

[16:09] <TimToady> yes

[16:09] <jnthn> But if you're comfortable with the &x in the lexpad and the m in the method table having something specialized for the "most derived" case, then I can probably come up with something workable in that space.

[16:10] <jnthn> I've been having a really hard time coming up with a design where we stash some state and then go look for the proto, or have it work out the two scopes between which it's looking for candidates.

[16:10] <TimToady> I see it as closely related to the shadow alias I install to detect  my $x; { $x; my $x }

[16:10] <TimToady> std: my $x; { $x; my $x }

[16:10] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Lexical symbol '$x' is already bound to an outer symbol (see line 1);␤  the implicit outer binding at line 1 must be rewritten as OUTER::<$x>␤  before you can unambiguously declare a new '$x' in this scope at /tmp/vaunigtF3T line 1:␤------> [32mmy

[16:10] <p6eval> ..$x…

[16:10] <jnthn> Aye, though this is an effect that would live on until runtime too

[16:11] <TimToady> well, I really do install the alias in the lexpad there

[16:11] <jnthn> Oh, OK :-)

[16:11] <TimToady> it's just marked as not real

[16:11] <jnthn> *nod*

[16:11] <TimToady> the lexinfo, not necessary the lexpad

[16:11] <TimToady> I still get those terms tangled

[16:12] <jnthn> I've been trying to talk about them as "static" vs "dynamic" lexpad.

[16:12] <smash> TimToady: ups, thank you

[16:12] <jnthn> In 6model I have the dynamic lexpad being a kind of "instantiation" of the static one. It has all the stuff the static one has, and all the slots allocated.

[16:13] <[Coke]> my $x = 3; say $ x;

[16:13] <[Coke]> rakudo: my $x = 3; say $ x;

[16:13] <p6eval> rakudo ea77cc: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at line 22, near "$ x;"␤»

[16:13] <[Coke]> moritz_++

[16:13] <TimToady> p5 does it in sync that way too

[16:13] <moritz_> that's not always a sign of sanity :-)

[16:13] *** patspam left
[16:14] <TimToady> otoh the static lexpad could just store int offsets in the dynamic pad

[16:14] <jnthn> Oh, the name -> indexes mapping I always share

[16:14] <jnthn> All that we really allocate for the a dynamic lexpad is an array of slots

[16:14] *** patspam joined
[16:15] *** stepnem left
[16:15] <TimToady> if the static lexpad is really a hash, then you can have extra things there that don't allocate a slot

[16:15] <jnthn> In 6model I've even got parameter binding being done into the slots by array index rather than the name lookup we do in Rakudo at the moment. :-)

[16:15] <jnthn> Well, true

[16:15] <jnthn> At the moment I just have a "oh btw extend this lexpad with more slots" method.

[16:16] <TimToady> slot binding sounds efficient

[16:16] <jnthn> Since the hash is expandable

[16:16] <jnthn> Yes, the slot binding gave me a big win.

[16:16] <jnthn> I need to see if Parrot can learn all of these tricks.

[16:16] <TimToady> Unfortunately, most parrots aren't as smart as Alex (RIP)

[16:16] <jnthn> :-(

[16:17] <TimToady> if the Lorito core turns out well, perhaps the VM should be called Alex :)

[16:17] <jnthn> :-)

[16:18] <jnthn> Think on the train today I figured out a decent-ish design for a multi-dispatch cache too, that can handle :D and :U efficiently.

[16:19] <Sec> rakudo: my @a=<a a a a a>;my @b=<b b b b b>;for (@a Z @b Z @a) -> $a, $b, $c {say "$a $b $c"}

[16:19] <p6eval> rakudo ea77cc: OUTPUT«No applicable candidates found to dispatch to for 'infix:<Z>'. Available candidates are:␤:()␤:(Any $lhs, Any $rhs)␤␤  in main program body at line 22:/tmp/AwPfCoUswW␤»

[16:19] *** stepnem joined
[16:19] <Sec> shouldn't that 'just work'?

[16:20] <TimToady> rakudo doesn't do list associative listops yet

[16:21] <TimToady> rakudo: my @a=<a a a a a>;my @b=<b b b b b>;for (@a Z @b) Z @a -> $a, $b, $c {say "$a $b $c"}

[16:21] <p6eval> rakudo ea77cc: OUTPUT«a a b␤a a a␤b a a␤Not enough positional parameters passed; got 1 but expected 3␤  in <anon> at line 2:/tmp/VBA9t093Zk␤  in main program body at line 1␤»

[16:21] *** justatheory left
[16:22] <TimToady> rakudo: my @a=<a a a a a>;my @b=<b b b b b>;for ((@a Z @b) Z @a).flat -> $a, $b, $c {say "$a $b $c"}

[16:22] <p6eval> rakudo ea77cc: OUTPUT«a a b␤a a a␤b a a␤Not enough positional parameters passed; got 1 but expected 3␤  in <anon> at line 2:/tmp/IsFYr1Uoxd␤  in main program body at line 1␤»

[16:23] <Sec> rakudo: my @a=<a a a>;my @b=<b b b>;for ((@a Z @b) Z @a) -> $a, $b, $c {say "$a $b $c"}

[16:23] <p6eval> rakudo ea77cc: OUTPUT«a a b␤a a a␤»

[16:24] <TimToady> that ain't right

[16:24] <Sec> thats what I expect when using ()s, but I wanted to have (a,b,a,a,b,a)

[16:24] <TimToady> the parens should disappear in for's list context, in any case

[16:25] <TimToady> quite apart from whether Z does list assoc correctly

[16:25] <Sec> well, a Z b is  (a,b,a,b...) and Z that with (a,a,a) you get (a,a,b,a,a,a,b,a ...)

[16:25] <TimToady> your outer parens are useless though

[16:25] <jnthn> TimToady: Anyways, thanks for the answers. I'll have a crack at getting something working. :-)

[16:26] <TimToady> oh, wait, Z is list context on the left, so flattens

[16:27] <TimToady> that's what's going on

[16:28] *** risou left
[16:28] <TimToady> rakudo: my @a=<a a a>;my @b=<b b b>;for (@a »,« @b) »,« @a -> $a, $b, $c {say "$a $b $c"}

[16:28] <p6eval> rakudo ea77cc: OUTPUT«Sorry, sides are of uneven length and not dwimmy.␤  in 'hyper' at line 179:CORE.setting␤  in main program body at line 1␤»

[16:28] <TimToady> that looks like a bug

[16:29] <TimToady> rakudo: my @a=<a a a>;my @b=<b b b>;for @a »,« @b »,« @a -> $a, $b, $c {say "$a $b $c"}

[16:29] <p6eval> rakudo ea77cc: OUTPUT«No applicable candidates found to dispatch to for 'hyper'. Available candidates are:␤:(&op, @lhs, @rhs, Any :dwim-left($dwim-left), Any :dwim-right($dwim-right))␤:(&op, %lhs, %rhs, Any :dwim-left($dwim-left), Any :dwim-right($dwim-right))␤:(&op, %arg)␤:(&op, @arg)␤:(&op, %lhs,

[16:29] <p6eval> ..Any …

[16:29] <TimToady> list assoc doesn't work there yet either

[16:30] <TimToady> rakudo: my @a=<a a a>;my @b=<b b b>;for zip(@a;@b;@a) -> $a, $b, $c {say "$a $b $c"}

[16:30] <p6eval> rakudo ea77cc: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 22␤»

[16:31] <TimToady> pugs: my @a=<a a a>;my @b=<b b b>;for zip(@a;@b;@a) -> $a, $b, $c {say "$a $b $c"}

[16:31] <moritz_> doesn't like ; in lists yet

[16:31] <p6eval> pugs: OUTPUT«a b a a b a a b a␤»

[16:31] <TimToady> pugs is still better at some things :)

[16:31] <moritz_> you do notice that pugs' output has only one \n?

[16:32] <moritz_> pugs: my @a=<a a a>;my @b=<b b b>; say zip(@a;@b;@a).perl

[16:32] <p6eval> pugs: OUTPUT«(("a", "b", "a"), ("a", "b", "a"), ("a", "b", "a"))␤»

[16:32] <TimToady> innerestin'

[16:32] <moritz_> it gets the slices/lists right, but doesn't flatten on sig binding

[16:32] <TimToady> for's sig is what should flatten

[16:32] <TimToady> not the ->'s

[16:33] <moritz_> right

[16:33] <TimToady> nobody has done slicing according to spec yet  :/

[16:34] <moritz_> nobody has specced slicing and laziness according to sanity yet :-)

[16:35] <Sec> and here I was, expecting this to be a simple example to try %)

[16:35] <TimToady> patrickas: as far as I can see, *all* the parens in your tic-tac-toe examples are not really necessary, not to say superstitious.  :)

[16:36] <TimToady> would be, if Z worked right

[16:36] <TimToady> or for's list flattening

[16:37] *** lichtkind joined
[16:39] <TimToady> patrickas: nice tutorial though

[16:40] <TimToady> masak++ for not using parens though :)

[16:40] *** cjk101010 left
[16:42] <lichtkind> which tutorial?

[16:44] *** macroron left
[16:46] <moritz_> lichtkind: http://www.reddit.com/r/programming/comments/damyp/learning_perl_6_by_playing_silly_games/ look for a comment from patrickas++

[16:47] <lichtkind> thanks

[16:48] <rhebus> patrickas++ # very nice

[16:50] <lichtkind> rakudo error messages++

[16:52] <TimToady> I think each() is a variant of all() that promises to do things in order, and perhaps more importanly, responds as a Positional/Iterable

[16:53] <TimToady> and therefore autothreads the values when in a list context

[16:54] <TimToady> oh, and returns the values in question, not the boolean results

[16:54] <lichtkind> OMGNOEZ perl tablets are lacking each

[16:54] <TimToady> nobody implements it yet

[16:55] <TimToady> say each(@array) ~~ $match

[16:55] <TimToady> would be equivalent to

[16:55] <TimToady> grep $match, @array

[16:55] *** dakkar left
[16:55] *** cdarroch joined
[16:55] *** cdarroch left
[16:55] *** cdarroch joined
[16:56] <arnsholt> :q

[16:56] * hugme hugs arnsholt, good vi(m) user!

[16:56] <arnsholt> Er, whoops

[16:56] <TimToady> say 1 < each(@array) < 10  # only report elements in that range

[16:57] <patrickas> TimToady: EBRAINCURRUPTEDBYPERL5

[16:57] * TimToady apologizes profusely

[16:58] <TimToady> and sometimes confusely

[16:58] *** Chillance joined
[16:59] <TimToady> it's just a little hot button that, when comparing with python, we need to show that Perl 6 looks clean too

[17:00] *** envi^home left
[17:00] *** tylercurtis joined
[17:04] <patrickas> Removed parens form the post :-)

[17:04] <TimToady> oh, you can do that?  cool

[17:05] <TimToady> hmm, they still show up here, must be cached somehow

[17:06] <TimToady> oh, down at the end, I see it

[17:07] <patrickas> I Could remove them from second step and below if you feel it is better that way

[17:08] <TimToady> you could use $^player and @^lines if you reversed the X

[17:09] <patrickas> yes but I thought that I would either need to explain it, or risk misleading people 

[17:09] <TimToady> but your last point seems to imply that you must lose the names, and that ain't so

[17:09] <TimToady> it's just you have to worry about alphabetical order

[17:11] <TimToady> alternately pick different names

[17:11] *** Italian_Plumber joined
[17:12] *** sftp_ left
[17:12] <patrickas> I prefer explicitly naming the variable *instead of being constrained to find names that would match alphabetical order*

[17:12] *** sftp_ joined
[17:12] *** javs left
[17:12] <patrickas> Actually I am fully aware that my preference is only coming from probably unjustified fear

[17:12] <TimToady> but those names are explicit too, but I'm just haggling over words

[17:13] <TimToady> I'd probably stick with -> my own self too

[17:14] *** rgrau_ joined
[17:14] *** thebird left
[17:16] <TimToady> anyway, thatnks

[17:16] * TimToady is starting to talk like Owl

[17:18] <patrickas> rakudo: say 1..* ... 5

[17:18] <p6eval> rakudo ea77cc: OUTPUT«(timeout)»

[17:19] *** snearch left
[17:19] <colomon> patrickas: we need to make that one work.  :)

[17:19] <colomon> unless your patch already did it?

[17:19] <patrickas> yea I am working on it right now ... but totally messed up series locally though i am testing with p6eval while waiting for a recompile

[17:19] <TimToady> gee, where did you get that one?  :)

[17:20] <TimToady> that's...sick

[17:20] <colomon> TimToady: nah, it's lovely.

[17:20] <colomon> :)

[17:20] <colomon> I mean, like that it's terrible.

[17:20] <TimToady> the two are not mutually exclusive to a goth

[17:21] <colomon> Is that Visi- or Ostro-?

[17:21] <TimToady> that's -ic Horror

[17:21] <colomon> anyway, it actually makes sense in some contexts.  came up on my blog in a comment the other day.

[17:21] *** sekimura joined
[17:21] *** ruoso left
[17:22] <TimToady> hmm, didn't see that

[17:22] <TimToady> +1 for independent discovery and all that

[17:22] <colomon> basically it's a simple form of take-until which is actually supported by the spec (if not rakudo yet)

[17:22] <TimToady> I presume you guys saw the series refactor in S03 last night?

[17:23] <patrickas> TimToady: Wish we hadn't :-)

[17:23] <colomon> so if you said my @fib := 1, 1, *+* ... *; you can later say @fib ... * > 900 to get the beginning of the list, with a limit.

[17:24] <patrickas> colomon: That's the example right below it in the spec

[17:24] <colomon> TimToady: I've already groused about it.  but honestly, the new version is so clearly superior that it's just the pain of trying to get the old version to work that makes me miss it.

[17:25] <pmichaud> ...series refactor?

[17:25] * pmichaud didn't see it.

[17:25] <colomon> series is a lot simpler now.

[17:25] <pmichaud> I keep wanting perl6/specs to be perl6/spec  :-|

[17:26] <colomon> except for some weird stuff that snuck in there about generating series of numbers in string form in arbitrary bases.  (evil glare at TimToady)

[17:26] <pmichaud> TimToady: I don't understand rvalue vs. lvalue on subscripts in S09 (more)

[17:26] *** javs joined
[17:26] <pmichaud> ...how is postcircumfix:<[ ]> to know it's being used in an lvalue context?  doesn't that get back to the "want" issue?

[17:29] *** ashleydev left
[17:29] *** ashleydev joined
[17:30] <TimToady> I suspect behaves as an lvalue only when it knows it's on the left side of =, or knows it's being passed to a function with a rw argument, and assumes rvalue otherwise

[17:30] <TimToady> s/passed to a function/bound to a parameter/

[17:30] <TimToady> so method args would always assume rvalue, since those can't be known statically

[17:30] <jnthn> So

[17:31] <jnthn> sub foo($x is rw) { $x = 42 }; my @a = 1,2,3; foo(@a[1]) # fails?

[17:31] <TimToady> no, why would it?

[17:32] <jnthn> Well, if the args assumed rvalue...

[17:32] <jnthn> I suspect I'm missing the point here though. :-)

[17:32] <pmichaud> jnthn: method args

[17:32] <TimToady> that foo is known lexically

[17:32] <jnthn> pmichaud: ah, ok

[17:32] <pmichaud> in that case, we know 'foo' at compile time, so we can see that it has an rw argument and tell postcircumfix:<[ ]> to generate something different

[17:33] <jnthn> OK, but are we saying that it would work but not

[17:33] <jnthn> my $x = sub ($x is rw) { $x = 42 }; my @a = 1,2,3; $x(@a[1])

[17:33] <TimToady> I can take or leave that one, but @foo[1..10] = 0 xx *; oughta work

[17:33] *** jedai left
[17:33] <pmichaud> TimToady: sure, I have no problem with that -- lvalues are the easy case

[17:33] <colomon> patrickas: geez, you're right, TimToady++ used that exact example in the spec.  I should have read it more carefully this morning!  :)

[17:33] <pmichaud> it's trimming in the case of rvalues that is tougher

[17:34] <TimToady> maybe something can be done lazily

[17:34] <pmichaud> in particular, if I have

[17:34] *** mberends joined
[17:34] <colomon> patrickas: 1..* ... * >= $lim is so horrible I never imagined it could have been used, other than as a test...  ;)

[17:34] <patrickas> colomon: I guess great /twisted minds do think alike!

[17:34] *** jedai joined
[17:34] *** yrgd joined
[17:35] <pmichaud>     my @b = <a b c>;   say @b[3..5].elems

[17:35] <pmichaud> how many elems?

[17:35] <pmichaud> sorry

[17:35] <pmichaud> wait

[17:35] <pmichaud>     my @b = <a b c>;   say @b[2..5].elems

[17:35] <TimToady> well, if one says that the limit applies to all the values on the left, it's not a big stretch to say that "all" could be infinite

[17:36] <TimToady> one, I'd think

[17:36] <pmichaud> because @b[2..5] is in rvalue context?

[17:36] <pmichaud> or, more precisely, because it's not in lvalue context?

[17:36] <TimToady> because it's not lvalue context ;)

[17:36] <TimToady> yup

[17:36] <pmichaud> and same for 

[17:37] <pmichaud>     my @b = <a b c>;   say @b[2,3,4,5].elems

[17:37] <pmichaud> ?

[17:37] <TimToady> that would be different according to current spec, which assume the subscript can ask "am I in a range now?"

[17:37] <pmichaud> okay

[17:37] <pmichaud> and how about

[17:38] <pmichaud>     my @b = <a b c>;   say @b[2.,.5].elems

[17:38] <pmichaud> ?

[17:38] <pmichaud> oops

[17:38] <pmichaud> typo

[17:38] *** sekimura_ joined
[17:38] <pmichaud>     my @b = <a b c>;   say @b[2...5].elems

[17:38] <TimToady> spec sez "range or series"

[17:38] <pmichaud> is series a standard type, now?

[17:38] <pmichaud> (I haven't read the updated series spec)

[17:39] <TimToady> perhaps "in an iterator, and it's the last one in the list" is more like

[17:40] <pmichaud> 2...5 isn't an iterator, it's a list.

[17:40] <TimToady> so presumably @foo[@bar] could also truncate

[17:40] <pmichaud> (in current implementation)

[17:40] *** sekimura left
[17:40] <pmichaud> so,   @foo[2,3,4,5]  doesn't truncate, but  @bar = 2..5;  @foo[@bar]  does?

[17:40] <TimToady> there's likely something they all have in common; someone should write a program to find it.  :)

[17:40] *** sekimura_ left
[17:41] *** justatheory joined
[17:41] *** sekimura joined
[17:41] <TimToady> there's perhaps some introspective call on a list that asks if it's going handwavey at the end

[17:42] <patrickas> can the lhs contain any closure at all except in the last element ?

[17:42] <pmichaud> okay, so then  @b[2..5]  doesn't truncate?  because ranges don't strike me as handwavey :)

[17:43] <pmichaud> and knowing handwavey-ness from map/gather/etc.  seems to be a challenge too.

[17:44] <TimToady> I think it wants to, because I wanted it in http://rosettacode.org/wiki/Top_rank_per_group#Perl_6

[17:44] <TimToady> I'd like .[^$n] to give me the first $n, or however many there are, if fewer

[17:45] <pmichaud> but we'd also like   .[^$n] = 0..*     to work also?

[17:45] <TimToady> well, that's why I was proposing the final ,* the other day, for when it's not clearly handwavey

[17:45] <pmichaud> (i.e., filling $n elements regardless of the original size of the array?)

[17:45] <TimToady> yes, hence the lvalue criterion

[17:45] <pmichaud> I'd be very happy to say that  .[^$n,*]  truncates and [^$n] doesn't

[17:46] <pmichaud> (regardless of lvalue/rvalue ness)

[17:47] *** plainhao joined
[17:47] <pmichaud> i.e.,    @a[^$n,*] = 0 xx *;   would clear up to the first $n elements of @a without extending it

[17:47] <TimToady> that might be okay, need to think about other use cases though

[17:48] <sorear> good * #perl6

[17:48] <pmichaud> and   @a[^$n]  would always return $n elements, while  @a[^$n,*]  would return up-to $n elements

[17:49] <patrickas> TimToady: Do you think we should allow the lhs to contain any closure at all except in the last element ?

[17:49] <TimToady> not sure, which is why I put "next" in the spec :)

[17:50] <TimToady> it's not clear how one escapes from one closure to continue the list

[17:50] <TimToady> return Nil maybe

[17:50] <TimToady> but that might make it harder to optimize

[17:50] <TimToady> if we're always testing for that in the loop

[17:51] <TimToady> next doesn't seem quite right, it'd just call the closure again, seems

[17:52] <TimToady> it's almost like we want to rebind the caller's &generator

[17:52] <TimToady> or undef it

[17:53] <TimToady> there's probably a way to make it work, once we have the sticky generator implementation down

[17:53] <patrickas> ok

[17:53] <TimToady> but it's not an easy question to answer, which is why I fudged the spec

[17:53] <patrickas> :-)

[17:54] <patrickas> when in doubt torment the implementator

[17:54] <TimToady> and what if the generator returns a generator?  :)

[17:54] *** proller left
[17:55] <colomon> what if you're generating a series of closures?  :)

[17:55] <TimToady> maybe there's some highfalutin' tailcallish solution

[17:55] <TimToady> colomon: there is that

[17:56] <patrickas> colomon: In that case is the last closure just another element or a way telling us how to generate more closures?

[17:56] <TimToady> that's more or less how LazyMap is implemented in STD's Cursors

[17:56] <colomon> last closure is a way telling us how to generate more closures.

[17:56] <colomon> after all, you can't really use .succ on a closure, can you?

[17:57] <TimToady> we don't call an intuited function when there's an explicit one

[17:57] <TimToady> and an explicit one can certainly have some way of generating one closure from another

[17:58] *** Axius joined
[17:58] <TimToady> mind you, this is probably a gigantic space leak somehow

[17:59] <TimToady> which can only be solved by proper application of the the proper set of monads with the proper lift semantics  :)

[17:59] <TimToady> .dedup

[17:59] <colomon> rakudo: my @a := -> $a { 0 }, -> $a { $a + 1 }, -> &closure { -> $a { &closure($a + 1) } } ... *; say @a[^5].perl

[17:59] <p6eval> rakudo ea77cc: OUTPUT«({ ... }, undef, undef, undef, undef)␤»

[17:59] <moritz_> undef?

[18:00] <TimToady> parrot type?

[18:00] <TimToady> s/type/value/?

[18:00] <tylercurtis> rakudo: say Failure.new.perl

[18:00] <pmichaud> I have no idea where those undefs are coming from.

[18:00] <p6eval> rakudo ea77cc: OUTPUT«too few positional arguments: 1 passed, 2 (or more) expected␤  in main program body at line 1␤»

[18:00] <pmichaud> must be fossil code.

[18:00] <tylercurtis> rakudo: say (fail "foo").perl

[18:01] <p6eval> rakudo ea77cc:  ( no output )

[18:01] <moritz_> src/builtins/Exception.pir line 93

[18:01] <colomon> rakudo: my @a := -> { 0 }, -> { 1 }, -> &closure { -> { &closure() + 1 } } ... *; say @a[^5].perl

[18:01] <p6eval> rakudo ea77cc: OUTPUT«({ ... }, undef, undef, undef, undef)␤»

[18:02] <TimToady> patrickas: now see what you've started!

[18:03] <patrickas> TimToady: Sorry :-(

[18:05] <colomon> rakudo: my @a := -> { 0 }, -> { 1 }, -> &closure { -> { &closure() + 1 } } ... *; say @a[^5]>>.()

[18:05] <p6eval> rakudo ea77cc: OUTPUT«Tried to find null name␤  in main program body at line 22:/tmp/4QHOR9P7DC␤»

[18:05] <colomon> ... precedence issue?

[18:06] <pmichaud> yes

[18:06] <colomon> rakudo: my @a := (-> { 0 }), (-> { 1 }), -> &closure { -> { &closure() + 1 } } ... *; say @a[^5].perl

[18:06] <pmichaud> := still is doing item assignment

[18:06] <p6eval> rakudo ea77cc: OUTPUT«({ ... }, undef, undef, undef, undef)␤»

[18:06] <colomon> oh!

[18:06] <colomon> rakudo: my @a := (-> { 0 }, -> { 1 }, -> &closure { -> { &closure() + 1 } } ... *); say @a[^5]>>.()

[18:06] <p6eval> rakudo ea77cc: OUTPUT«Tried to find null name␤  in main program body at line 22:/tmp/VPhIFkDtuo␤»

[18:06] <colomon> rakudo: my @a := (-> { 0 }, -> { 1 }, -> &closure { -> { &closure() + 1 } } ... *); say @a[^5].perl

[18:06] <p6eval> rakudo ea77cc: OUTPUT«({ ... }, { ... }, { ... }, { ... }, { ... })␤»

[18:06] <colomon> there we go.

[18:07] <pmichaud> I have a fix for that now in nqp, but I can't move it into Rakudo until we find the Parrot bug that is causing build failures under 64-bit systems

[18:07] <colomon> rakudo: my @a := (-> { 0 }, -> { 1 }, -> &closure { -> { &closure() + 1 } } ... *); for @a[^5] -> &a { say &a(); }

[18:07] <p6eval> rakudo ea77cc: OUTPUT«0␤1␤2␤3␤4␤»

[18:07] <pmichaud> *ding*

[18:08] <pmichaud> TimToady: in the series operator, do all of the values on the lhs honor the limit value on the rhs?

[18:08] <pmichaud> for example, if I write     1, 2, 3, 4, 5 ... 3

[18:08] <pmichaud> do I get 1, 2, 3  as the result?

[18:08] <TimToady> yes

[18:08] <pmichaud> and 1, 2, 3, 5, 7 ... 2    stops at the 2?

[18:09] <TimToady> yes

[18:09] <pmichaud> +1

[18:09] <pmichaud> excellent

[18:09] <TimToady> however, I still think 1,2,3,4,5 ... 1..* ... 3  ==>  1,2,3,4,5,1,2,3

[18:09] <patrickas> pmichaud: That part did not change and is already implemented

[18:10] <TimToady> that is, each limit applies only to the term between ...s

[18:10] <TimToady> hmm, waitaminnit

[18:10] *** xinming left
[18:10] <patrickas> TimToady: But .. but ...

[18:11] <pmichaud> as I read it, that would be 1,2,3

[18:11] <TimToady> the middle limit should apply left too

[18:11] <TimToady> yes

[18:11] <TimToady> however, I still think 1,2,3,4,5 ... 6..* ... 3  ==>  1,2,3,4,5,6..*

[18:12] <pmichaud> I would expect   1,2,3,4,5,6

[18:12] <TimToady> the 3 applies only to the 6..* and the 6 applies only to the 1..5

[18:12] <pmichaud> right

[18:12] <pmichaud> so no ..* at the end

[18:12] <pmichaud> because 7 > 3

[18:12] <TimToady> no implicit inequality tests anymore

[18:12] <TimToady> we talked about that the other day

[18:13] <TimToady> and you liked it then

[18:13] <TimToady> only exact match stops it

[18:13] <PerlJam> ... is right assoc?

[18:13] <pmichaud> PerlJam: list assoc

[18:13] <TimToady> it's in a funny order

[18:13] <pmichaud> TimToady: I don't think I was thinking strictly equality test for the part I liked

[18:13] <PerlJam> well, I just don't understand that last example.

[18:13] <TimToady> it has to go right to left on first value of each list

[18:13] <TimToady> to find the limit

[18:14] <TimToady> but then the rest are produced left to right

[18:14] <pmichaud> so,   1, 1.3, 1.6 ... 3    never terminates?

[18:14] <colomon> pmichaud: right.

[18:14] <TimToady> correct

[18:14] <rhebus> there was someone in here the other day who found that { 2,3,*+2 ... sqrt $n } failed to terminate for $n < 4...

[18:14] <pmichaud> and the way to get it to terminate is   1, 1.3, 1.6 ... * > 3

[18:14] <pmichaud> okay, I remember now, and I can live with that.

[18:14] <colomon> rhebus: that's already fixed.  though the new spec makes it not work.

[18:15] <rhebus> yes, we discovered it failed as designed

[18:15] * TimToady hangs head

[18:15] <rhebus> and indeed it's not obvious how to make it work without breaking other cases

[18:15] <pmichaud> rhebus: it's now   2, 3, *+2 ... * > sqrt $n

[18:15] <TimToady> yes, we wanted contradictory dwimmery

[18:16] <rhebus> example from http://rosettacode.org/wiki/Primality_by_trial_division#Perl_6

[18:16] <PerlJam> looks like I'm going to have to read the spec again

[18:16] <rhebus> (seeing the eidt history, i see TimToady is well aware of all this)

[18:16] <PerlJam> when there's a closure, it terminates when it evaluates true?

[18:16] <pmichaud> PerlJam: yes.

[18:16] <patrickas> colomon: 2,3,*+2 ... sqrt $n was not (and I think cannot be fixed)

[18:16] <pmichaud> "up to this condition"

[18:16] *** rainerschuster joined
[18:17] * tylercurtis is beginning to regret using MooseX::Declare for the Perl 5 bits of Bennu.

[18:17] <colomon> patrickas: are you sure?  I thought your patch fixed that one.

[18:17] <TimToady> under the old semantics

[18:17] <patrickas> no my patch fixes : 2,3,5,7 ... sqrt $n

[18:17] <TimToady> sqrt $n is unlikely to be an exact match anymore

[18:18] <patrickas> when the last element is a closure I could not  work any magic to figure out if it will hit the limit or not

[18:18] <TimToady> sqrt($n).ceiling +| 1 might work though

[18:18] *** timbunce_ left
[18:18] <colomon> TimToady: right.  but I thought there was a brief window here were it would work -- until we fixed the code to match the spec.

[18:18] <PerlJam> the terminating condition is always straight equality (modulo closures)

[18:18] <TimToady> s/equality/smartmatch/

[18:18] <TimToady> no need to modulo closures anymore

[18:18] <PerlJam> ah

[18:18] <PerlJam> of course

[18:19] <PerlJam> okay.  makes sense now  :-)

[18:19] <TimToady> that was one of those DOH! moments

[18:19] <patrickas> rakudo: say 2,3,5,7 ... 2.5

[18:19] *** zby_ joined
[18:19] <p6eval> rakudo ea77cc: OUTPUT«2␤»

[18:19] *** Axius left
[18:19] *** zby__ joined
[18:19] <patrickas> rakudo: say 2,3,*+2 ... 2.5

[18:19] <shortcircuit> What's the difference between http://rosettacode.org/wiki/Rakudo_Star and http://rosettacode.org/wiki/Rakudo ?

[18:19] <p6eval> rakudo ea77cc: OUTPUT«2␤»

[18:20] <patrickas> rakudo: say 2,3,*+2 ... 1

[18:20] <dalek> nqp-rx: c83336f | pmichaud++ | src/cheats/hll-grammar.pir:

[18:20] <dalek> nqp-rx: Add :sub<...> precedence for operator precedence parser (<EXPR>).

[18:20] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/c83336fc2bad4d10fde0952a2482e9672e03b3fd

[18:20] <TimToady> different "works with" entries?

[18:20] <p6eval> rakudo ea77cc:

[18:20] <p6eval> ..OUTPUT«(timeout)151719212325272931333537394143454749515355575961636567697173757779818385878991939597991011031051071091111131151171191211231251271291311331351371391411431451471491511531551571591611631651671691711731751771791811831851871891911931951971992012032052072092112132152172192212232…

[18:20] <colomon> well bother.

[18:20] <colomon> patrickas: have you made any progress at switching over the spectests to the new spec?

[18:21] <PerlJam> shortcircuit: Rakudo is a compiler implementation of Perl 6.  Rakudo Star is a Perl 6 distribution based on Rakudo that will have the Rakudo compiler and other stuff

[18:21] <patrickas> colomon: I reached 1..* ... * >= $lim

[18:21] <shortcircuit> TimToady: Yeah. The Rakudo Star one, I just created when I noticed the reference to Primality by trial division. Rakudo looks like it's linked to by 50-100 pages.

[18:21] <patrickas> and drowned in a huge refactor

[18:21] <shortcircuit> Hm.

[18:21] <colomon> patrickas: and then we distracted you.

[18:22] <shortcircuit> Anyone feel like maintaining those two pages? :)

[18:22] <colomon> patrickas: I was figuring we'd get the spectests up to date first, and then dive into the coding.

[18:22] <TimToady> some of the entries say "Rakudo Star" but have really only be tested against rakudo HEAD

[18:22] <TimToady> * been

[18:23] <shortcircuit> Well, these two pages might be of use, if anyone wants to verify them: http://rosettacode.org/wiki/Special:WhatLinksHere/Rakudo_Star and http://rosettacode.org/mw/index.php?title=Special:WhatLinksHere/Rakudo&limit=100

[18:23] * shortcircuit goes back to work.

[18:23] <patrickas> colomon: maybe that's a better idea ... it's just that I thought I'd at least try to wrap my head around the issues of making this work

[18:24] <patrickas> insanity ensued.

[18:25] <colomon> I figure it's always good to have a base of correct tests to work from.

[18:25] <patrickas> I think I killed a coroutine

[18:26] <patrickas> "Cannot resume dead coroutine"

[18:26] <colomon> oh, man, hide the body quickly!

[18:27] *** daxim left
[18:28] <patrickas> colomon: I am adding one test at a time from the new spec and trying to make it pass, unfortunately that was the second test in the spec, So I got stuck, side tracked the channel and killed a coroutine :-) 

[18:29] *** sekimura_ joined
[18:30] *** sekimura left
[18:32] *** stepnem left
[18:32] <colomon> okay, I'm claiming arity2ormore to fix

[18:34] *** ruoso joined
[18:34] *** stepnem joined
[18:37] <colomon> pushed.  now for some extraordinarily boring $work

[18:41] <colomon> patrickas: hmm, the $work code I'm looking at has a body_count.  Just like you do... ;)

[18:43] <patrickas> I am innocent! It was dead when I walked in!

[18:44] *** hercynium joined
[18:46] *** icwiener left
[18:47] *** zby_ left
[18:47] *** zby joined
[18:51] *** timbunce joined
[18:52] *** justatheory left
[18:53] *** MarderIII joined
[18:54] *** rgrau_ left
[19:00] *** rgrau_ joined
[19:00] *** javs left
[19:01] *** timbunce left
[19:01] <patrickas> rakudo: say (1,1,{ $^a + 1, $^b * 2 }...*).munch(5).perl; #Is that correct ?

[19:01] <p6eval> rakudo ea77cc: OUTPUT«(1, 1, (2, 2), (2, 4), (3, 4))␤»

[19:02] <TimToady> not according to spec

[19:03] <TimToady> should be 1,1,2,2,3

[19:03] <TimToady> it's a list context, so () should disappear

[19:05] *** justatheory joined
[19:05] <patrickas> ok so the third item should be 2 instead of (2,2)

[19:05] <patrickas> even if $next is returning 2,2

[19:16] *** javs joined
[19:22] <dalek> rakudo: 780732f | moritz++ | src/core/IO.pm:

[19:22] <dalek> rakudo: make dir() default to the current directory

[19:22] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/780732f21f92760c67bf4d78a9ff00f68a1567d1

[19:23] <jnthn> .oO( We ever stole from MS DOS! )

[19:24] *** Schwern joined
[19:27] *** Italian_Plumber left
[19:28] *** sekimura_ left
[19:31] *** stepnem left
[19:33] *** plainhao left
[19:33] *** stepnem joined
[19:37] <rhebus> From S32/Containers: "Set: A set of unique values. When used as a hash always treats the set's values as the keys of the hash, returning True for set elements. See KeySet for a container that can represent different sets as keys are added or deleted." <-- does this imply that a Set is immutable?

[19:37] *** timbunce joined
[19:38] <rhebus> and if it doesn't, what's the difference between a Set and a KeySet?

[19:39] <TimToady> that would be why Set is listed in the Immutable section of S02

[19:40] * frettled has a mutable TV.

[19:40] <rhebus> >_< of course

[19:40] *** rschuster joined
[19:41] *** rainerschuster left
[19:41] <rhebus> rakudo: my @g = [Set.new(1,2),Set.new([1,2])]; @g.perl.say

[19:41] <p6eval> rakudo ea77cc: OUTPUT«[[Set.new(1, 2), Set.new(1, 2)]]␤»

[19:41] <rhebus> rakudo: my @g = [Set.new(1,2),Set.new([1,2],[2,1])]; @g.perl.say

[19:41] <p6eval> rakudo ea77cc: OUTPUT«[[Set.new(1, 2), Set.new()]]␤»

[19:42] <frettled> huh

[19:42] *** rschuster is now known as rainerschuster

[19:43] <moritz_> that's curious

[19:43] <rhebus> is it not supposed to do that?

[19:43] *** pkkm left
[19:44] <rhebus> I'm trying to implement a graph as a pair (V,E)

[19:44] <moritz_> ah, the double [] come from assigning [] to an array

[19:44] <moritz_> rakudo: say Set.new([1,2]).perl

[19:44] <p6eval> rakudo ea77cc: OUTPUT«Set.new(1, 2)␤»

[19:44] <rhebus> rakudo: say Set.new([1,2],[2,1]).perl

[19:44] <sorear> TimToady: what does ; in argument lists do?

[19:44] <p6eval> rakudo ea77cc: OUTPUT«Set.new()␤»

[19:46] <frettled> So, essentially, attepting to do that means that you end up with an empty set instead.  Is that a healthy failure mode?

[19:46] <rhebus> rakudo: say Set.new([1,2],3).perl

[19:46] <p6eval> rakudo ea77cc: OUTPUT«Set.new(3)␤»

[19:46] <rhebus> frettled: it just ignores arrays

[19:47] <rhebus> rakudo: say Set.new([1,2],3, 4 => 5, Set.new(6)).perl

[19:47] <p6eval> rakudo ea77cc: OUTPUT«Set.new(3, 4 => 5, Set.new(6))␤»

[19:47] <rhebus> huh, now I'm *really* confused

[19:47] *** sekimura joined
[19:48] <rhebus> but I guess I can use pairs for my graphs. that's a better conceptual fit for edges anyway

[19:48] *** timbunce left
[19:50] <sorear> TimToady: you say that **@foo accepts any number of positionals and puts them into item context; how does that interact with foo(1,2; 3,4)?

[19:51] *** wolv joined
[19:52] *** kjeldahl left
[19:52] *** wolv is now known as wolverian

[19:52] <pmichaud> sorear: I suspect that ; in argument lists forms Slicels

[19:52] <pmichaud> (but haven't worked out the details yet)

[19:52] *** kjeldahl joined
[19:53] <rhebus> I'm looking at http://github.com/perl6/perl6-examples/blob/master/99-problems/99-problems.pod and wondering how to translate the graph problems from the original prolog to Perl 6

[19:54] <rhebus> might it be a good way to introduce writing OO code? we could ask the reader to write a Graph class

[19:56] *** timbunce joined
[19:57] <rhebus> and then P80 is not "write conversions between different prolog predicate representations of graphs" but instead "write methods .neighbour .add-edge etc so that you can solve the following problems"

[19:57] <rhebus> hmm i may sleep on it

[19:57] *** MarderIII left
[19:59] * rhebus -> pub

[19:59] <TimToady> phone

[20:02] <pmichaud> be there shortly.

[20:05] *** snearch joined
[20:05] *** javs left
[20:06] *** sekimura_ joined
[20:07] *** sekimura left
[20:07] *** sekimura_ left
[20:07] *** timbunce left
[20:07] *** sekimura joined
[20:11] *** justatheory left
[20:11] <dalek> nqp-rx: ce60da8 | pmichaud++ | src/cheats/hll-compiler.pir:

[20:11] <dalek> nqp-rx: Temporarily backport PCT::HLLCompiler's 'lineof' method

[20:11] <dalek> nqp-rx: from Parrot r48866 into HLL::Compiler, so that nqp-rx can

[20:11] <dalek> nqp-rx: continue to build from an older Parrot until parrot's trunk

[20:11] <dalek> nqp-rx: is working again.  When we're able to bump PARROT_REVISION,

[20:11] <dalek> nqp-rx: this code can go away to fall back to Parrot's version of

[20:11] <dalek> nqp-rx: 'lineof' (DRY).

[20:11] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/ce60da8d258a8243f3bbf2c266a1970e99a30211

[20:11] <dalek> nqp-rx: bb5d370 | pmichaud++ | src/ (3 files):

[20:11] <dalek> nqp-rx: Switch 'lineof' method calls to use the version of HLL::Compiler instead of CodeString.

[20:11] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/bb5d370de5b43105a774623351eb58e54b465a53

[20:11] <dalek> nqp-rx: d2d100f | pmichaud++ | src/Regex/Cursor.pir:

[20:11] <dalek> nqp-rx: Eliminate CodeString coercion.

[20:11] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/d2d100fa8480eb8a8e5854dae82ce82b8fe00b57

[20:11] <dalek> nqp-rx: 5c1686c | pmichaud++ | src/stage0/ (4 files):

[20:11] <dalek> nqp-rx: Update bootstrap to include lineof changes.

[20:11] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/5c1686c0b12eec062bfbda9c85e07d37f9cd78c9

[20:11] *** patspam left
[20:12] *** patspam joined
[20:13] *** timbunce joined
[20:14] <patrickas> TimToady: in the spec my $end = 7; then later 0,2,4 ...^ { $_ > $end }; #Why the exclusive limit ?

[20:14] <TimToady> to include 7 if it matches

[20:15] <TimToady> but not 7.1

[20:16] <patrickas> include 7 in the returned items ?

[20:17] <patrickas> so ...^ is not "exclusive" since it includes the limit?

[20:17] *** rhebus left
[20:18] <TimToady> ... includes the limit, ...^ doesn't

[20:18] <TimToady> but ... * >= $end would include the first number after the limit if it didn't match exactly

[20:18] <patrickas> and when the limit is a closure

[20:19] <TimToady> doesn't matter

[20:19] <TimToady> it's just a smartmatch

[20:19] <TimToady> and if it smartmatches, ... includes it, and ...^ doesn't

[20:19] <patrickas> ok

[20:20] <TimToady> I don't know if rakudo implements last($value) yet though

[20:20] <patrickas> I htink it does (even though it is not used yet in series)

[20:20] *** jferrero joined
[20:20] <pmichaud> rakudo:  say (for 1..5 { last 'xyz' if 3 })

[20:20] <p6eval> rakudo ea77cc: OUTPUT«xyz␤»

[20:20] <pmichaud> ummm

[20:20] <pmichaud> rakudo:  say (for 1..5 { last 'xyz' if $_ == 3 })

[20:20] <p6eval> rakudo ea77cc: OUTPUT«xyz␤»

[20:21] <pmichaud> that's supposed to work :(

[20:21] *** timbunce left
[20:21] <pmichaud> rakudo:  say (for 1..5 { if $_ == 3 { last 'xyz' } })

[20:21] <p6eval> rakudo ea77cc: OUTPUT«00xyz␤»

[20:21] <pmichaud> oh, they were nils.

[20:22] <pmichaud> rakudo:  say (for 1..5 { last 'xyz' if $_ == 3; $_ })

[20:22] <p6eval> rakudo ea77cc: OUTPUT«12xyz␤»

[20:22] <jnthn> oh wow, I didn't know you could do that!

[20:22] <pmichaud> last($value) works.  'if' apparently doesn't.

[20:22] <pmichaud> jnthn:   next($value) also works :-)

[20:22] <jnthn> Cute!

[20:22] <jnthn> (whoever implemented that)++ :-)

[20:23] *** patspam left
[20:23] * jnthn wipes the dust of the 6model repo

[20:24] *** tadzik left
[20:24] <moritz_> dust, after less than two weeks of inactivity?

[20:24] <pmichaud> construction dust, I think.

[20:24] <TimToady> 'if' is supposed to return Nil on non-match

[20:24] <pmichaud> TimToady: right.  I'm not sure what happened there.

[20:24] <pmichaud> oh, wait, yes I do.

[20:24] <pmichaud> 'if' statement works,  'if' statement_modifier doesn't.

[20:24] <TimToady> Nil is supposed to disappear in list context

[20:25] <TimToady> say provides a list context

[20:25] <pmichaud> right

[20:25] <pmichaud> rakudo:  say (for 1..5 { if $_ == 3 { last 'xyz' } })

[20:25] <TimToady> say (for 1..5 { last 'xyz' if 3 }).perl

[20:25] <p6eval> rakudo ea77cc: OUTPUT«00xyz␤»

[20:25] <TimToady> rakudo: say (for 1..5 { last 'xyz' if 3 }).perl

[20:25] <p6eval> rakudo ea77cc: OUTPUT«("xyz")␤»

[20:25] <[Coke]> we have implicit contexts again?

[20:25] <TimToady> now that should've had some Nils in it

[20:26] <pmichaud> right

[20:26] <pmichaud> I'm not sure where my Nils went.

[20:26] <allbery_b> they got Bohred?

[20:26] <TimToady> willy nilly

[20:26] <pmichaud> rakudo:  say ('xyz' if 0).perl

[20:26] <p6eval> rakudo ea77cc: OUTPUT«Nil␤»

[20:26] *** hercynium left
[20:27] <pmichaud> rakudo:  say ('xyz' if 0, 'xyz' if 0).perl

[20:27] <p6eval> rakudo ea77cc: OUTPUT«===SORRY!===␤Missing block at line 22, near ").perl"␤»

[20:27] <TimToady> loop collector flattened maybe?

[20:27] <patrickas> rakudo: say 1,2,3 ... * > 0 

[20:27] <pmichaud> oh, yes.

[20:27] <pmichaud> our 'for' currently has an 'eager' on it.

[20:27] <p6eval> rakudo ea77cc:

[20:27] <p6eval> ..OUTPUT«(timeout)101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130…

[20:27] <pmichaud> (awaiting sink context)

[20:27] <patrickas> TimToady: that should become be 1 ? ^^

[20:27] <pmichaud> and eager likely removed the nils.

[20:27] <TimToady> but eager should be orthogonal to flattening

[20:28] <TimToady> patrickas: yes

[20:28] <pmichaud> it would still remove the Nils, yes?  Or does it itemize them?

[20:29] <TimToady> I think it should be agnostic to whether it is handling a flat or slice

[20:29] <pmichaud> so does it itemize the Nils?

[20:30] <TimToady> no, that would imply slice semantis

[20:30] <pmichaud> it just reifies the Nils as Nil?

[20:30] * TimToady tries to picture a praying semantis

[20:30] <TimToady> it just processes the list as a list, neither .flat nor .slice

[20:31] <TimToady> so () and Nil come through unscathed

[20:31] *** mfollett left
[20:31] <pmichaud> what about @a?

[20:31] <pmichaud> (@a, Nil, @b).eager

[20:31] <pmichaud> I mean, if it doesn't imply flattening... what does it actually do for ranges and other iterators?

[20:32] <pmichaud> what does it "eagerly evaluate" then?  ;-)

[20:33] <TimToady> flattening is the removal of () structure.  I don't see how it relates to reification, except insofar as you might have to go into a () to reify what's inside it

[20:33] <TimToady> if the only way to reify something is to strip the (), that seems wrong to me

[20:34] <pmichaud> so,  (@a, Nil, @b).eager is the same as (@a.eager, Nil.eager, @b.eager)   ?

[20:34] <TimToady> yes

[20:34] <pmichaud> what about  (1..*).eager ?

[20:34] <TimToady> it's like a unary hyper that way

[20:34] <TimToady> it keeps the current structure

[20:34] <pmichaud> so (1..*).eager remains a Range

[20:34] <TimToady> well, we know that's infinite, so it can remain

[20:35] <pmichaud> how about  (1..5).eager ?

[20:35] <TimToady> that reifies

[20:35] <TimToady> I think

[20:35] <pmichaud> why?

[20:35] <TimToady> maybe not

[20:36] <TimToady> well, hmm, I guess our reified lists are pushed into a flat array...

[20:36] <pmichaud> if .eager is just saying to an object "reify yourself and all of your components", then Ranges (as immutable objects) don't need anything for eager

[20:37] <TimToady> that might be reasonable

[20:37] <TimToady> so all ranges would stay in the imaginary list even under eager

[20:37] <patrickas> rakudo: say 10,9,8, { $_ - 1 || last } ... *

[20:37] <pmichaud> well, all items, really

[20:37] <p6eval> rakudo ea77cc: OUTPUT«10987654321␤»

[20:37] <TimToady> anything immutable can be lazy

[20:38] <TimToady> eager is really trying to force side effects

[20:38] <pmichaud> if I have  (@a, 5, @b).eager     then @a and @b still need to remain in the imaginary list, I think

[20:39] <TimToady> but they aren't immutable

[20:39] <pmichaud> agreed

[20:39] <TimToady> people will expect those to snapshot themselves at least

[20:40] <TimToady> under eager

[20:40] <pmichaud> snapshot into what, though?

[20:40] <pmichaud> that's why eager was flattning

[20:40] <TimToady> right, that's the question

[20:40] <pmichaud> because the outer parcel becomes a Seq

[20:40] *** tadzik joined
[20:40] <TimToady> but maybe this is related to decontainerizing

[20:40] <pmichaud> which then gets the (flattened) values of it components

[20:40] <TimToady> and the decontainerizer can shove back into the imaginary part a snapshot of values

[20:41] <pmichaud> in that case, .eager returns a new Parcel

[20:41] <TimToady> only flattened into its snapshot spot, the outer () remains

[20:41] <pmichaud> right

[20:41] <pmichaud> .eager on an Array would reify the array

[20:41] <TimToady> so eager is really more like snapshot

[20:42] <pmichaud> yeah

[20:42] <pmichaud> so,  (@a, 1, @b).eager  has the effect of reifying both @a and @b, but also returning a new Parcel that has (@a.Seq.eager, 1, @b.Seq.eager)

[20:43] <pmichaud> (where Seq's decontainerize their values)

[20:43] <TimToady> sounds about right, and very similar to decontainerization

[20:43] <pmichaud> right -- currently I have Seq as a list of decontainerized values

[20:43] <TimToady> and maybe snapshot is just a snazzier word for decontainerization

[20:43] <TimToady> more or less what eqv does too

[20:44] <pmichaud> I'll try that out and see what happens.

[20:44] <pmichaud> although in some sense I'd also like decontainerization to be orthogonal to eagerness

[20:44] <TimToady> also related to the mystery of serialization

[20:44] <pmichaud> i.e., I can decontainerize an array without having to reify all of its elements.

[20:45] *** ash_ joined
[20:45] <pmichaud> (for some arrays, at any rate)

[20:45] *** timbunce joined
[20:45] <TimToady> and you can snapshot it that way too, if the rest is immutable

[20:45] <pmichaud> right

[20:45] <pmichaud> so I'd like a decontainerize method that is orthogonal to eager

[20:45] <TimToady> mainly I see the difference is decontainerization is what you do to a container, and snapshot is recursively that over a data structure

[20:46] <TimToady> well, iteratively, if not recursively

[20:46] <pmichaud> so, we'd have decontainerization, snapshot, and eager ?

[20:46] *** timbunce left
[20:46] <TimToady> snapshot and eager would be basically the same thing

[20:46] *** whiteknight joined
[20:46] <pmichaud> that doesn't sound right

[20:47] <TimToady> each of them does decontainerizations as appropriate

[20:47] <pmichaud> "snapshot"  - return me something that contains only values

[20:47] <pmichaud> "eager" - tell everything to reify as much as it can

[20:47] <TimToady> values can be lazy

[20:47] <TimToady> constant @primes := ...

[20:48] <pmichaud> well, if @primes is created with a generator, I'd assume that snapshot would have some eagerness there.

[20:48] <TimToady> I wouldn't

[20:49] <TimToady> I think snapshot === eager

[20:49] <TimToady> and both are merely promises about lack of side effects, other than laziness

[20:49] <pmichaud> so, @a.eager does.... what?

[20:50] <pmichaud> or is it now @a.snapshot ?

[20:50] <TimToady> gives you a snapshot of the array such that any modification of @a has not effect, that's all

[20:50] <TimToady> eager is shorter :)

[20:50] <pmichaud> so, @a.eager doesn't force any reification at all?

[20:50] <TimToady> *no effect on the snapshot

[20:51] *** hercynium joined
[20:52] <TimToady> no, that depends on whether the imaginary part has something with side effects

[20:52] <TimToady> which, yes, is hard to know

[20:52] <pmichaud> for typical generators, we don't know if t..... right

[20:52] <pmichaud> so, we either evaluate the generator for its side effects, or we don't force reification

[20:53] <TimToady> I think we evaluate any generator that isn't marked with '*'

[20:53] <pmichaud> where marked with '*' means '*' is the last element?

[20:53] <TimToady> or is '0' xx *, or 1..*

[20:53] *** tadzik left
[20:54] <TimToady> basically * is a promise of some kind of purity, in addition to unendingness, in that view

[20:54] <TimToady> which for xx and .. makes sense

[20:54] <pmichaud> how about for parcels in general (more)

[20:54] <TimToady> makes a little less sense for a user-code generator that might refer to something external

[20:54] <pmichaud>     gather { ... }, *

[20:55] <pmichaud> (in parens, I guess)

[20:55] <pmichaud>     (gather { ... }, *)

[20:55] <TimToady> but basically, it's a mark that says, exempt this from snapshotting

[20:55] <pmichaud> okay

[20:55] <TimToady> for whatever reason

[20:55] <TimToady> maybe I actually *want* the lazy side effects, but snapshot the earlier part of the list, though it seems pretty fragile

[20:56] *** Guest23195 left
[20:56] <TimToady> of course, lazy gather {...} should have the same effect, I guess

[20:57] <TimToady> eager @a, lazy gather {...}

[20:57] <TimToady> eager @a, gather {...}, *   # same thing maybe

[20:59] <pmichaud> so a gather loop would get snapshotted, but if it's in a parcel that ends with *  it won't?

[21:00] <TimToady> something like that.  I think * implies lazy, but lazy doesn't necessarily imply *

[21:00] *** avuserow left
[21:00] <TimToady> a generator could be lazy by choice, a * has to be lazy by necessity

[21:01] <TimToady> so I don't think * is redundant with lazy

[21:01] <TimToady> so .[lazy range()] still uses the whole range, while .[range(), *] doesn't

[21:02] <TimToady> (if the available elements are fewer)

[21:02] <TimToady> putting ,* as a postfix is a bit quirky thought

[21:03] <TimToady> *though

[21:03] <TimToady> one could argue for a statement_prefix:inf instead to go with lazy

[21:03] <TimToady> and eager

[21:03] *** nperez left
[21:03] *** Getty left
[21:03] *** Gothmog_ joined
[21:03] *** jnthn left
[21:03] *** cls_bsd_ joined
[21:03] <pmichaud> I don't have a problem with that.

[21:03] *** au|irc left
[21:04] <pmichaud> so, 'lazy' really means "don't eager me"  :-)

[21:04] *** Getty joined
[21:04] <pmichaud> does that make eager/lazy into named unaries?

[21:04] <pmichaud> i.e., "eager" forces snapshotting, "lazy" suppresses it?

[21:04] <pmichaud> (and there's some in-between that is the default?)

[21:04] *** avuserow_ joined
[21:04] *** nperez_ joined
[21:04] <pmichaud> right

[21:04] <pmichaud> my @a = 1..*;   # lazy

[21:04] <pmichaud> my @a = 1..100;   # eager

[21:04] <pmichaud> my @a = eager 1..100;  # also eager

[21:04] <pmichaud> my @a = lazy 1..100;   # lazy

[21:04] <pmichaud> my @a = 0, 1, *+* ... * ;   # lazy, because of the terminating *

[21:04] *** au|irc joined
[21:04] <pmichaud> my @a = 0, 1, *+* ... * > 500;   # eager

[21:04] *** azert0x left
[21:04] <pmichaud> my @a = lazy(0, 1, *+* ... * > 500);  # lazy

[21:04] *** azert0x joined
[21:04] <pmichaud> hmmm, netlag

[21:04] *** exodist_ joined
[21:04] *** jnthn_ joined
[21:04] <TimToady> weird

[21:06] <TimToady> the ,* kinda works because of all the other places * pops up

[21:06] *** mfollett joined
[21:06] <TimToady> but it really kinda wants to be a modifier on the previous term somehow

[21:07] *** mfollett left
[21:07] <pmichaud> yes, I was trying to work some adverbs in for gather and .[ ]

[21:07] <pmichaud> i.e.:  gather :lazy { ... }

[21:07] <pmichaud> or

[21:07] <pmichaud>    gather :inf { ... }

[21:07] <pmichaud> and

[21:07] <pmichaud>     @a[1..10]:clip

[21:07] <TimToady> rather have those out front

[21:07] <TimToady> lazy gather or inf gather

[21:08] <pmichaud> wfm

[21:08] <PerlJam> lazy gather +1

[21:09] <pmichaud> gather is already "lazy"

[21:09] <pmichaud> it's really "inf gather" that I want.

[21:09] <TimToady> but it could hide a gather from an eager

[21:09] <pmichaud> i.e., to signal to eager operations that "you really don't want to try to iterate this to the end"

[21:09] <TimToady> maybe inf isn't quite right

[21:10] *** snearch left
[21:10] <pmichaud> same goes with some cases of .map and .grep and the like

[21:10] <TimToady> wish there was a short word for "unending"

[21:11] <pmichaud> eternal

[21:11] <TimToady> ever

[21:11] <ash_> eventually ? 

[21:11] <TimToady> for ever foo() {...}

[21:11] <ash_> loop

[21:11] <pmichaud> dne

[21:11] <pmichaud> :-P

[21:11] <TimToady> dnf, you mean :)

[21:12] <pmichaud> ohm => mho,   end => dne  :)

[21:12] <pmichaud> but yes, dnf works too 

[21:12] <pmichaud> but then people really will say that Perl 6 and DNF are DNF

[21:12] <PerlJam> dnf is very punnable too  :)

[21:13] <TimToady> "does not finish"

[21:13] <pmichaud> "Perl 6 isn't finished yet... and we even have an operator for it"

[21:13] <TimToady> for never foo() {...}

[21:13] <PerlJam> too many words

[21:13] <PerlJam> eternal foo() { ... }

[21:14] <pmichaud> well, for is already lazy outside of sink context

[21:14] <pmichaud> so it would be more like  "never for foo() { ... }

[21:14] <pmichaud> which isn't really right.

[21:15] *** jaldhar left
[21:16] <TimToady> for the-long-haul foo()

[21:16] <ash_> loop foo() { } 

[21:16] <TimToady> it's just a modifier on a term, why would it want a block?

[21:16] <pmichaud> wait for it() { ... }

[21:17] <ash_> for EVER { } 

[21:17] <ash_> #define EVER ;; 

[21:18] <PerlJam> ash: I liked where you were going with loop much better

[21:18] <pmichaud> TimToady: you're imagining that the modifier on a term would override sink context?

[21:18] <TimToady> sink is just a kind of eager

[21:18] <pmichaud> okay.

[21:18] <pmichaud> so with

[21:19] <TimToady> "Useless use of lazy list in sink context at line 42"

[21:19] <pmichaud> sink  (lazy foo()).map( { ... } )

[21:19] <pmichaud> the lazy wins?

[21:19] <TimToady> yes, but could produce that error

[21:19] *** jnthn_ is now known as jnthn

[21:19] <pmichaud> so, sink is kind of a super-eager.... more like "strictly eager"?

[21:19] <pmichaud> and it carps if it's given something marked 'lazy'?

[21:20] *** wolverian left
[21:20] <TimToady> well, I suppose the map could have side effects, so no warning there

[21:20] <pmichaud> right

[21:20] <pmichaud> and since for --> map.....

[21:20] <TimToady> yes, that's fine

[21:20] <TimToady> the map will read the lazy foo

[21:20] <pmichaud> that's why I was not following the significance of    for lazy foo() { ... }

[21:20] <TimToady> we need to make it so that "the cow jumped over the lazy dog" is legal Perl 6

[21:21] <TimToady> s/cow/fox/

[21:21] <pmichaud> well, I guess the map result signals it's lazy also (transitively)

[21:21] *** lue left
[21:21] <pmichaud> i.e., the thing it's iterating is explicitly lazy, so the map result is explicitly lazy also.

[21:21] <TimToady> it does, but then the inside of the map may carp about useless things in sink context

[21:22] <pmichaud> well, or the sink can still do it.

[21:22] <pmichaud> since it'll get the lazy result from map.

[21:23] <pmichaud> this does indicate that the laziness of  "lazy foo()"  is somehow different from the laziness of 1..*  though

[21:23] <pmichaud> (which I think you alluded to earlier)

[21:23] <TimToady> yes, one by choice, one by necessity

[21:23] <TimToady> * implies lazy, lazy doesn't imply *

[21:23] <pmichaud> sink of lazy by choice -> carp

[21:24] <pmichaud> sink of lazy by necessity -> no carp?

[21:24] <pmichaud> or do we carp there as well, and require some other explicit construct if you *really* want to work through the laziness

[21:24] <TimToady> has more to do with whether there were side effects

[21:24] <TimToady> pure code carps if sunk

[21:24] <pmichaud> right... but at the other levels we don't know if there are side effects

[21:24] <pmichaud> *outer

[21:24] <pmichaud> such as with .map

[21:25] <TimToady> sink propagates inward to final statements

[21:25] <pmichaud> I haven't figured out how to do that.  It sounds too much like want()

[21:25] <TimToady> and earlier statements are already sunk

[21:25] <TimToady> just the opposite, it's don't-want()  :)

[21:25] <sorear> I thought we got rid of context propagating inward

[21:25] <pmichaud> :)

[21:25] <TimToady> not that

[21:26] <pmichaud> sorear: yes, that's the problem I have with "propagates inward"

[21:26] <pmichaud> foo() { for @list { .say } };   foo();  1;

[21:26] <pmichaud> how does foo() know it's in sink context?

[21:27] <TimToady> a bit in the call frame

[21:27] <pmichaud> grrr

[21:27] <sorear> the same way { say "hi" }; knows to call the block immediately

[21:27] <sorear> it's syntactic

[21:27] <pmichaud> no, I did that wrong.

[21:27] <pmichaud> sub foo() { for @list { .say } };  foo();  1

[21:27] <pmichaud> I know that foo() knows it's in sink context.

[21:27] <pmichaud> But how does the map inside of "&foo"  know it?

[21:28] <TimToady> by looking at the sink bit in the callframe

[21:28] <pmichaud> (TimToady answers;  bit in the call frame)

[21:28] <sorear> because the map is at statement level

[21:28] <pmichaud> sorear: the map is a return value.  It's not in sink context.

[21:28] <sorear> for loops are exactly like bare blocks in my mind

[21:28] <pmichaud> (syntactically it's not in sink context)

[21:28] <TimToady> as the last statement in the sub it knows it has to look at the bit in the call frame

[21:28] <sorear> they run immediately at statement level regardless of whether they are the return value

[21:28] <pmichaud> sorear: I think your interpretation is wrong there.

[21:29] <pmichaud> (TimToady can clarify if yes/no)

[21:29] <sorear> I know my interpretation is 'wrong'; I'm trying to convert you

[21:29] <TimToady> sorear++ isn't guessing, he just wants it different

[21:29] <pmichaud> sorear: I'm not the one who needs converting.

[21:29] <TimToady> and I think his use case is contrived

[21:30] <pmichaud> I'm trying to understand how TimToady wants it to work, not to change the spec.

[21:30] <TimToady> and I'm saying the user generally knows which routines are called for values and which for side effects

[21:31] <sorear> it seems to me like having both callframe bits and context methods is the worst of both world

[21:31] <TimToady> and that a simple --> Nil in the sig can easily force sink context on the last statement statically

[21:31] <sorear> s

[21:31] <pmichaud> well, a simple "sink" can force sink context, too :-)

[21:31] <TimToady> there can be multiple last statments, like in a switch

[21:32] <TimToady> so better to mark the return as Nil

[21:32] *** Mowah left
[21:32] <pmichaud> sure, that works for me

[21:32] <TimToady> and the rest of the time, the bit works right nearly all the time

[21:34] <sorear> TimToady: sorry, that wasn't a use case

[21:34] <sorear> TimToady: the contrived example I gave was intended to be spectest material

[21:34] <sorear> TimToady: the real use case for my interpretation is simplifying the RTS

[21:34] <pmichaud> it feels funny that 'sink context' gets a bit when none of our other contexts do

[21:34] <pmichaud> I'm wondering how long it'll be before we have an 'lvalue bit' also.

[21:35] <sorear> how about a list bit?

[21:39] *** [Coke] joined
[21:40] *** tylercurtis left
[21:40] <dalek> 6model: 920e357 | jnthn++ | dotnet/runtime/R (2 files):

[21:40] <dalek> 6model: A first crack at implementing a maybe decent multi-dispatch type/definedness cache. Not yet in use, not even tested, but sketches out the idea at least.

[21:40] <dalek> 6model: review: http://github.com/jnthn/6model/commit/920e357fbe232effb9afc78b6527f560e1061b1c

[21:40] *** wolverian joined
[21:40] *** justatheory joined
[21:41] *** Holy_Cow left
[21:44] *** Holy_Cow joined
[21:50] *** wolverian left
[21:51] *** wolverian joined
[21:51] *** ruoso left
[21:53] <sorear> What would be a good name for the low-level opposite of &item?

[21:54] <sorear> It doesn't do any coercion, but fiddles allomorphic reference properies to allow a list to interpolate in list contexts

[21:54] <sorear> in rakudo it would more or less be pir::deobjectref

[21:56] <patrickas> phenny: tell colomon I think I implemented the main changes in the new series spec http://github.com/patrickas/rakudo/tree/series-new-spec (minus a few things that were not working and did not get affected by the change) but we won't really know till we have new correct spectests! In the mean while I tested with the following tests http://gist.github.com/570893 and your updated series-arity2ormore.t

[21:56] <phenny> patrickas: I'll pass that on when colomon is around.

[21:57] <colomon> actually right here at the moment.

[21:57] <phenny> colomon: 21:56Z <patrickas> tell colomon I think I implemented the main changes in the new series spec http://github.com/patrickas/rakudo/tree/series-new-spec (minus a few things that were not working and did not get affected by the change) but we won't really know till we have new correct spectests! In the mean while I tested with the following tests http://gist.github.com/570893 and your updated series-arity2ormore.t

[21:57] <colomon> :)

[21:57] <pmichaud> sorear: I don't know a good name for it, but .list often just creates a new ObjectRef that doesn't have the item property set.

[21:57] <patrickas> one commit was removing about 35 lines of unneded convoluted code :-)

[21:57] <colomon> was snapping beans for nomming and surfing the web.

[21:57] <pmichaud> afk

[21:57] <colomon> patrickas++

[21:57] <sorear> pmichaud: but I can't use .list to de-item-property, say, Parcels

[21:58] <patrickas> i ended up skipping the 1..* ... 5 issue since it had nothign to do with the new change

[21:58] *** ash_ left
[21:59] <patrickas> If you have time to take a look / test it would be great!

[21:59] <pmichaud> That case doesn't come up in Rakudo, because a Parcel is already de-itemed

[21:59] * patrickas gotta go prepare dinner and get some rest... 'night all

[21:59] *** patrickas left
[22:00] <pmichaud> afk, errands

[22:06] *** rgrau__ joined
[22:07] *** rgrau_ left
[22:08] *** Holy_Cow left
[22:11] *** Limbic_Region joined
[22:11] <dukeleto> Did masak's work on binary data in Rakudo get merged ?

[22:12] * dukeleto is writing up a blog post about gsoc

[22:12] *** sekimura left
[22:12] *** Ross left
[22:13] <moritz_> dukeleto: I don't know if everything got merged, but parts were certainly merged

[22:14] <dukeleto> moritz_: does he have a branch that he is working on?

[22:15] <dukeleto> moritz_: just wanting to mention it in a blog post, which means I should at least topically understand what was actually done :)

[22:15] *** jhuni joined
[22:15] <moritz_> dukeleto: yes, it's called 'buf'

[22:15] <moritz_> dukeleto: and he also blogged a few times about his progress

[22:17] *** ash_ joined
[22:18] <dukeleto> moritz_: yes, i read them. just hadn't seen anything recently

[22:18] <dukeleto> moritz_: thanks for the info!

[22:19] *** flatwhatson left
[22:25] *** ash_ left
[22:27] <jnthn> dukeleto: I believe it all got merged.

[22:28] <moritz_> jnthn: I don't believe so

[22:28] <moritz_> oh well

[22:28] <moritz_> at least I can't find the commit messages from origin/buf in master

[22:29] *** Schwern left
[22:29] <moritz_> but it might have been merged some other way, like with squashed commits or custom messages

[22:30] <jnthn> moritz_: iirc, they were squashed.

[22:30] <jnthn> rakudo: pack

[22:30] <p6eval> rakudo 780732: OUTPUT«No applicable candidates found to dispatch to for 'pack'. Available candidates are:␤:(Str $template, *@items)␤␤  in main program body at line 22:/tmp/em4nV2EvBm␤»

[22:30] <jnthn> pack was the last part of the grant and it's there.

[22:31] <moritz_> ok

[22:31] <jnthn> Maybe they were squashed.

[22:32] <moritz_> phenny: ask masak if there's a good reason to keep the 'buf' branch on github around

[22:32] <phenny> moritz_: I'll pass that on when masak is around.

[22:32] *** rgrau__ left
[22:32] <moritz_> jnthn: 83b2cdfa64becdef052417962cc114e38f5920d8 seems to be the monster commit that brought the buf goodness to master

[22:33] *** rainerschuster left
[22:36] *** mfollett joined
[22:42] * jnthn -> sleep

[22:43] *** mfollett_ joined
[22:43] *** mfollett left
[22:44] <moritz_> that's acutally quite a good idea

[22:44] *** mfollett_ is now known as mfollett

[22:47] *** mfollett left
[22:54] <dukeleto> moritz_: i don't even see the buf branch on github

[22:59] *** drbean_ joined
[23:00] *** meppl left
[23:02] *** drbean left
[23:03] *** kjeldahl left
[23:04] *** alester left
[23:04] <dalek> niecza: 9740be1 | sorear++ | / (7 files):

[23:04] <dalek> niecza: Simplify representation and construction of lists

[23:04] <dalek> niecza: review: http://github.com/sorear/niecza/commit/9740be13dd7008b4acbd8dcf7682ef8aedecdaa7

[23:04] *** felipe joined
[23:05] *** flatwhatson joined
[23:05] <TimToady> I guess we can do sink lazily too; it's really temp that is fundamentally broken, at least insofar as it's implemented the way Perl 5 does local.  Emulation with dynamic vars would close over lazy lists properly, so temp $lexical should do that.

[23:06] *** cdarroch left
[23:06] <TimToady> Only temp $global would remain borken if used to feed a lazy list.

[23:31] *** nimiezko joined
[23:32] *** ash_ joined
[23:35] *** Helios left
[23:37] *** ascent_ left
[23:39] *** Limbic_Region left
[23:43] *** ascent_ joined
[23:43] *** Helios joined
[23:46] *** azert0x left
[23:47] <diakopter> grr indeed :)

[23:48] *** Alias left
[23:49] *** justatheory left
[23:50] <nimiezko> hello #perl6

[23:56] <dukeleto> nimiezko: howdy

[23:59] *** Patterner left
