[00:00] *** Patterner left
[00:00] *** Psyche^ is now known as Patterner

[00:02] <ingy> [Coke]: it's true. i'm unruly.

[00:02] *** kanishka joined
[00:03] <ingy> rakudo: say '$foo $bar'

[00:03] <p6eval> rakudo c513fb: OUTPUT«$foo $bar␤»

[00:03] <ingy> rakudo: say '$foo $bar'.subst(/'$foo'/, 'FOO')

[00:03] <p6eval> rakudo c513fb: OUTPUT«FOO $bar␤»

[00:04] <ingy> rakudo: say '$foo $bar'.subst(/'$foo'/, 'FOO').subst(/'$bar'/, 'PASS')

[00:04] <p6eval> rakudo c513fb: OUTPUT«FOO PASS␤»

[00:05] <kanishka> i got error while installing perl6 module

[00:05] <sorear> which one?

[00:05] <kanishka> Math-Mode

[00:06] <kanishka> i got proto and configured the conf file 

[00:07] <ingy> how do you type in ␤

[00:07] <ingy> ?

[00:07] <ingy> rakudo: say '$foo $bar'␤.subst(/'$foo'/, 'FOO').subst(/'$bar'/, 'PASS')

[00:07] <p6eval> rakudo c513fb: OUTPUT«===SORRY!===␤Confused at line 20, near "say '$foo "␤»

[00:07] <kanishka> http://pastebin.com/fpNqSWFU

[00:07] <ingy> why did that fail?

[00:08] <ingy> rakudo: say '$foo $bar'.␤subst(/'$foo'/, 'FOO').subst(/'$bar'/, 'PASS')

[00:08] <p6eval> rakudo c513fb: OUTPUT«===SORRY!===␤Confused at line 20, near "say '$foo "␤»

[00:08] <ingy> rakudo: say '$foo $bar'.subst(/'$foo'/, 'FOO')␤.subst(/'$bar'/, 'PASS')

[00:08] <p6eval> rakudo c513fb: OUTPUT«===SORRY!===␤Confused at line 20, near "say '$foo "␤»

[00:08] <ingy> TimToady: is that a bug?

[00:08] <TimToady> ingy: whenever rakudo is confused, feed it to STD instead

[00:08] <ingy> thx

[00:08] <ingy> std: say '$foo $bar'.subst(/'$foo'/, 'FOO')␤.subst(/'$bar'/, 'PASS')

[00:08] <p6eval> std 31738: OUTPUT«[31m===[0mSORRY![31m===[0m␤Method call found where infix expected (omit whitespace?) at /tmp/tPUvFGhabS line 2:␤------> [32m<BOL>[33m⏏[31m.subst(/'$bar'/, 'PASS')[0m␤    expecting any of:␤   POST␤   infix or meta-infix␤        postfix␤       

[00:08] <p6eval> ..postfix_prefix_meta_operator␤Parse failed␤FAILED …

[00:09] <ingy> std: say '$foo $bar'.subst(/'$foo'/, 'FOO').␤subst(/'$bar'/, 'PASS')

[00:09] <p6eval> std 31738: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of . to concatenate strings; in Perl 6 please use ~ at /tmp/YLQeQpCfAP line 2:␤------> [32m<BOL>[33m⏏[31msubst(/'$bar'/, 'PASS')[0m␤Parse failed␤FAILED 00:01 116m␤»

[00:09] <ingy> std: say '$foo $bar'.subst(/'$foo'/, 'FOO').subst(/'$bar'/, 'PASS')

[00:09] <p6eval> std 31738: OUTPUT«ok 00:01 116m␤»

[00:09] <ingy> grr

[00:09] <TimToady> use unspace

[00:09] <ingy> did I type in the newline correctly?

[00:09] <TimToady> yes

[00:10] <ingy> unspace?

[00:10] <TimToady> you can put \ before whitespace to make it not there

[00:10] <TimToady> std: say '$foo $bar'\    .subst(/'$foo'/, 'FOO')\␤.subst(/'$bar'/, 'PASS')

[00:10] <p6eval> std 31738: OUTPUT«ok 00:01 116m␤»

[00:11] <ingy> rakudo: say "\␤hello"

[00:11] *** destiney left
[00:11] <p6eval> rakudo c513fb: OUTPUT«␤hello␤»

[00:11] <TimToady> not there

[00:11] <ingy> haha

[00:11] <ingy> that would be nice

[00:11] <ingy> python++

[00:12] <TimToady> that would imply multiple pass parsing, which is evil

[00:12] *** mike joined
[00:12] <ingy> huh

[00:12] <mike> rakudo: say "hi"

[00:12] <p6eval> rakudo c513fb: OUTPUT«hi␤»

[00:13] *** mike is now known as Guest94307

[00:13] <Guest94307> rakudo: say 5 ~ 1 .. 10

[00:13] <p6eval> rakudo c513fb: OUTPUT«␤»

[00:13] <ingy> I think not allowing "foo()␤.bar()" is a turnoff

[00:13] <Guest94307> rakudo: say 0 ~ 1 .. 10

[00:13] <p6eval> rakudo c513fb: OUTPUT«01020304050607080910␤»

[00:13] <Guest94307> rakudo: say 0 ~ (1 .. 10)

[00:13] <p6eval> rakudo c513fb: OUTPUT«01 2 3 4 5 6 7 8 9 10␤»

[00:13] <ingy> that's like, just my opinion, man

[00:14] <TimToady> it's perfectly fine for you to have opinions, even bad ones like that

[00:14] <ingy> but that's pretty expected, I'd think

[00:14] <Guest94307> rakudo: say 0 ~~ (1 .. 10)

[00:14] <p6eval> rakudo c513fb: OUTPUT«0␤»

[00:14] <Guest94307> rakudo: say 5 ~~ (1 .. 10)

[00:15] <p6eval> rakudo c513fb: OUTPUT«1␤»

[00:15] <Guest94307> rakudo: say 50 ~~ (1 .. 10)

[00:15] <p6eval> rakudo c513fb: OUTPUT«0␤»

[00:15] <ingy> TimToady: what's more culturally imperialistic than inventing a new programming language? :P

[00:15] <Guest94307> Sorry, guys. Had to check something.

[00:15] <TimToady> telling a culturual imperialist he's not culturally imperialistic enough, maybe

[00:16] <ingy> :)

[00:16] <sorear> TimToady: What's the difference between FIRST and START?

[00:16] <TimToady> there are good reasons for the whitespace rules in Perl 6 involving extensibility

[00:16] <TimToady> so not allowing extensibility would be more culturally imperialistic

[00:17] <TimToady> sorear: not much, assuming a loop clones its block every time it starts the loop

[00:17] <TimToady> but it's probably good documentation

[00:18] <Guest94307> rakudo: 'goat' ~~ 'cow' .. 'zebra'

[00:18] <TimToady> it's also possible that FIRST and LAST could bubble up to the dynamically enclosing loop somehow

[00:18] <p6eval> rakudo c513fb:  ( no output )

[00:18] <Guest94307> rakudo: 'm' ~~ 'a' .. 'z'

[00:18] <p6eval> rakudo c513fb:  ( no output )

[00:18] <TimToady> whereas START is only responsive to its own block's recloning

[00:19] <TimToady> Guest94307: you need a say

[00:19] <Guest94307> Thanks

[00:19] <Guest94307> rakudo: say 'm' ~~ 'a' .. 'z'

[00:19] <p6eval> rakudo c513fb: OUTPUT«1␤»

[00:19] <Guest94307> rakudo: say 'goat' ~~ 'cow' .. 'zebra'

[00:19] <p6eval> rakudo c513fb: OUTPUT«1␤»

[00:19] <Guest94307> rakudo: say 'a' ~~ 'cow' .. 'zebra'

[00:19] <p6eval> rakudo c513fb: OUTPUT«0␤»

[00:21] <TimToady> rakudo: say '19' ~~ '1' .. '100'

[00:21] <p6eval> rakudo c513fb: OUTPUT«0␤»

[00:21] <Guest94307> Yes!

[00:21] <Guest94307> I'm just preparing a mail on the darn Range operator.

[00:22] <Guest94307> Excuse my language.

[00:23] <TimToady> Ranges now are pretty strictly just intervals, unless you happen to use them in list context

[00:23] <TimToady> all the fancy stuff should be done with ...

[00:24] *** felliott left
[00:24] <TimToady> it does occur to me that it would be awfully nice if the function of ... could have access to the final value it's aiming for

[00:24] <Guest94307> Yes. But using something as 'cow' .. 'zebra' in list context shouldn't be possible unless you explicitly specify a domain.

[00:25] <TimToady> so we could have "000", &dwim-for-ajs ... "fff" let the function see 'fff' somehow

[00:25] <sorear> What do you call an ordered set with the property that \forall a b. a > b -> \exist c. a > c > b ?

[00:25] <TimToady> perhaps as $*ENDPOINT or some such

[00:26] <Guest94307> Over countable. You are talking about strings and real numbers.

[00:26] <sorear> Guest94307: rats too

[00:26] <TimToady> um, irrational :)

[00:27] <Guest94307> Those are making the Range operator counterintuitive.

[00:27] <Guest94307> ...in list context.

[00:27] <Guest94307> sorear: sorry, yes.

[00:27] <TimToady> .oO(irrational strings...)

[00:29] <sorear> sorry, but you've already proposed surreal Char

[00:29] *** rgrau_ left
[00:29] <Guest94307> Eh?

[00:30] <TimToady> well, "surreal" precedence, but that's kinda wrongish anyway

[00:30] <TimToady> but certainly you can always put new things in the cracks

[00:31] <TimToady> but we just do it with ordinary strings and use leg semantics

[00:32] <TimToady> the trick is leaving room under a particular value as well as over

[00:32] <Guest94307> I think its better to change the Range operator so it will refuse to try to evaluate 'a' .. 'ant' without the developer explicitly telling it which domain is intended.

[00:32] <Guest94307> Maybe leaving single char ranges as an exception.

[00:32] *** cdarroch left
[00:35] <TimToady> well, kinda depends on what the default for 'a' ... 'ant' is

[00:35] <Guest94307> Currently in Rakudo, its the lexicographical range of chars from 'a' to 'ant' limited to 3 chars in length.

[00:36] <sorear> Guest94307: 'a' .. 'ant' is very well defined in scalar context

[00:36] <TimToady> yes, that is a p5ism

[00:36] <TimToady> he was just talking about list context

[00:36] <Guest94307> sorear: didn't consider that. What is the result then?

[00:37] <TimToady> makes a Range object

[00:37] <tylercurtis> rakudo: ('a'..'ant').perl.say

[00:37] <p6eval> rakudo c513fb: OUTPUT«"a".."ant"␤»

[00:37] <TimToady> rakudo: my $r = 'a' .. 'ant';  say 'ab' ~~ $r

[00:37] <Guest94307> :)

[00:37] <sorear> a range object is just an interval

[00:37] <p6eval> rakudo c513fb: OUTPUT«1␤»

[00:38] <sorear> it makes sense in any totally ordered domain

[00:38] <tylercurtis> rakudo: .say for 'a' .. 'ant'

[00:38] <p6eval> rakudo c513fb: OUTPUT«a␤»

[00:38] <sorear> coercing a range to a list only makes sense in countable discrete domains

[00:38] <sorear> like Int

[00:38] <sorear> and Char

[00:38] <tylercurtis> Ah. Did not know that.

[00:38] <Guest94307> Yes. I totally agree. This is what I'd like Range to do.

[00:39] <sorear> rakudo: say 'aardvark' ~~ 'a' .. 'ant'

[00:39] <Guest94307> Unless you provide your own countable domain.

[00:39] <p6eval> rakudo c513fb: OUTPUT«1␤»

[00:39] <Guest94307> Duh^^

[00:39] <Guest94307> Because

[00:39] <sorear> perl6: { say "a"; START { say "b" }; say "c" }  # S04 is unclear on whether this makes bac or abc

[00:39] <p6eval> rakudo c513fb: OUTPUT«a␤Could not find sub &START␤  in main program body at line 20:/tmp/xqU9QIJ584␤»

[00:39] <p6eval> ..pugs: OUTPUT«a␤b␤c␤»

[00:40] <TimToady> which Str++ kinda does, it's just that it's not the same order as leg

[00:40] <TimToady> sorear: abc is the intent

[00:40] <sorear> ok

[00:40] <TimToady> so it is unlike FIRST in that regard

[00:41] <TimToady> it's really more like say "b" unless $didit++

[00:41] <TimToady> and, in fact, you can provide it based entirely on state vars

[00:42] <TimToady> rakudo: say "b" unless (state $)++

[00:42] <p6eval> rakudo c513fb: OUTPUT«===SORRY!===␤Contextual $*GOAL not found␤»

[00:42] <TimToady> except rakudo can't parse anonyvars yet

[00:42] <TimToady> rakudo: say "b" unless (state $x)++

[00:42] <p6eval> rakudo c513fb: OUTPUT«===SORRY!===␤Symbol '$x' not predeclared in <anonymous> (/tmp/QzCIityU4N:20)␤»

[00:42] <TimToady> or state, apparently...

[00:43] <Guest94307> rakudo: say 5.1 ~~ 1.1 .. 9.101

[00:43] <p6eval> rakudo c513fb: OUTPUT«1␤»

[00:43] <Guest94307> rakudo: say 9.2 ~~ 1.1 .. 9.101

[00:43] <p6eval> rakudo c513fb: OUTPUT«0␤»

[00:43] <Guest94307> rakudo: say 9 ~~ 1.1 .. 9.101

[00:43] <TimToady> rakudo: state $x

[00:43] <tylercurtis> rakudo: sub foo () { state $x; $x++; } say foo; say foo;

[00:43] <p6eval> rakudo c513fb: OUTPUT«1␤»

[00:43] <p6eval> rakudo c513fb: OUTPUT«===SORRY!===␤Symbol '$x' not predeclared in <anonymous> (/tmp/qoMeqEBDnh:20)␤»

[00:43] <p6eval> rakudo c513fb: OUTPUT«===SORRY!===␤Confused at line 20, near "sub foo ()"␤»

[00:44] <tylercurtis> rakudo: sub foo () { state $x; $x++; }; say foo; say foo;

[00:44] <p6eval> rakudo c513fb: OUTPUT«===SORRY!===␤Symbol '$x' not predeclared in foo (/tmp/_Vqeh_j9R_:20)␤»

[00:44] <TimToady> that's really kind of a bad bug

[00:44] <TimToady> std: sub foo () { state $x; $x++; }; say foo; say foo;

[00:44] <p6eval> std 31738: OUTPUT«ok 00:01 115m␤»

[00:45] <TimToady> alpha: sub foo () { state $x; $x++; }; say foo; say foo;

[00:45] <Guest94307> rakudo: .say for(<1 2 3>)

[00:45] <p6eval> alpha 30e0ed: OUTPUT«Use of uninitialized value␤␤1␤»

[00:45] <p6eval> rakudo c513fb: OUTPUT«1␤2␤3␤»

[00:45] <Guest94307> rakudo: .say for(1 .. 3)

[00:45] <p6eval> rakudo c513fb: OUTPUT«1␤2␤3␤»

[00:45] <Guest94307> rakudo: .say for(1.1 .. 9.1)

[00:45] <p6eval> rakudo c513fb: OUTPUT«1.1␤2.1␤3.1␤4.1␤5.1␤6.1␤7.1␤8.1␤9.1␤»

[00:45] <TimToady> um

[00:46] <TimToady> std: .say for(1.1 .. 9.1)

[00:46] <p6eval> std 31738: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row (method call requires colon or parens to take arguments) at /tmp/IeQniXpOc7 line 1:␤------> [32m.say [33m⏏[31mfor(1.1 .. 9.1)[0m␤    expecting any of:␤  bracketed infix␤  infix or meta-infix␤      statement modifier loop␤ 

[00:46] <p6eval> ..statement_mod…

[00:46] <TimToady> error message is LTA, but for requires ws in STD

[00:46] *** gbacon left
[00:46] <TimToady> std: .say for (1.1 .. 9.1)

[00:46] <p6eval> std 31738: OUTPUT«ok 00:01 114m␤»

[00:46] <tylercurtis> rakudo: if(1) { say "This shouldn't happen, either." }

[00:46] <TimToady> std: .say for 1.1 .. 9.1

[00:46] <p6eval> rakudo c513fb: OUTPUT«This shouldn't happen, either.␤»

[00:46] <p6eval> std 31738: OUTPUT«ok 00:01 113m␤»

[00:47] <TimToady> std: if(1) { say "This shouldn't happen, either." }

[00:47] <p6eval> std 31738: OUTPUT«[31m===[0mSORRY![31m===[0m␤Word 'if' interpreted as 'if()' function call; please use whitespace instead of parens at /tmp/bSCj_jFlKQ line 1:␤------> [32mif[33m⏏[31m(1) { say "This shouldn't happen, either[0m␤Unexpected block in infix position (two terms in a row) at

[00:47] <p6eval> ../tmp/bS…

[00:47] <lue> why not?

[00:47] <TimToady> ^^^

[00:47] <tylercurtis> rakudo: if 0 { say "Doesn't happen."; } elsif(1) { say "This is correctly incorrect, iirc." }

[00:47] <p6eval> rakudo c513fb: OUTPUT«===SORRY!===␤Confused at line 20, near "if 0 { say"␤»

[00:48] <TimToady> std: sub if {...}; if(1)

[00:48] <p6eval> std 31738: OUTPUT«ok 00:01 113m␤»

[00:48] <lue> ah.

[00:48] <TimToady> except terrible location

[00:48] <TimToady> std: if 0 { say "Doesn't happen."; } elsif(1) { say "This is correctly incorrect, iirc." }

[00:48] <p6eval> std 31738: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/4RRbPNV31O line 1:␤------> [32mif 0 { say "Doesn't happen."; }[33m⏏[31m elsif(1) { say "This is correctly incor[0m␤    expecting statement_control␤Parse failed␤FAILED

[00:48] <p6eval> ..00:…

[00:48] <TimToady> at least that's closer

[00:49] <lue> should there be a semicolon between } and elsif ?

[00:50] <TimToady> no, it's just guessing, hence the ?

[00:50] <dalek> book: 1f44d57 | chromatic++ | src/subs-n-sigs.pod:

[00:50] <dalek> book: Edited subs-n-sigs chapter for flow.

[00:50] <dalek> book: Added a couple of editorial comments.

[00:50] <dalek> book: review: http://github.com/perl6/book/commit/1f44d577ee9734d25c19e734899a3e4992931958

[00:50] <tylercurtis> lue: iiuc, foo(...) is always postcircumfix:<( )>. Whereas foo (...) is circumfix:<( )>. 

[00:51] <TimToady> it's the same rule ingy was carping about

[00:51] <TimToady> postfixes never take ws

[00:51] <TimToady> if there is ws, it can't be a postfix

[00:51] <TimToady> beyond that, we force identifier() to always be a function call

[00:52] <TimToady> even in spots where it doesn't quite make sense, like 42 for(1)

[00:52] <TimToady> we just don't want people to get used to writing non-functions that look like functions

[00:52] <tylercurtis> std: say -5\␤.abs

[00:52] <p6eval> std 31738: OUTPUT«ok 00:01 113m␤»

[00:52] <tylercurtis> rakudo: say -5\␤.abs

[00:53] <p6eval> rakudo dd8d5d: OUTPUT«-5␤»

[00:53] <TimToady> .abs binds tighter

[00:53] <TimToady> even across unspace

[00:54] <tylercurtis> I was just verifying that Rakudo understands unspace.

[00:54] <TimToady> though I've actually considered making unspace put an implicit () around the left arg

[00:54] <TimToady> but it's never quite seemed worth it to get a precedence relaxer like that, when () is only one more char

[00:56] <TimToady> so we still have to say (^5).foo

[00:57] <sorear> does state $x = ... create a scope?

[00:58] <Juerd> IIRC the scope is lexical

[00:59] <ingy> carp carp

[00:59] <ingy> Just finished a heavy refactor of ufo. http://github.com/masak/ufo/blob/master/ufo

[00:59] <Guest94307> rakudo: .say for( 1 .. 10 :by 2)

[00:59] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Confused at line 20, near ".say for( "␤»

[00:59] <ingy> much more * now!

[00:59] <Guest94307> std: .say for( 1 .. 10 :by 2)

[00:59] <p6eval> std 31738: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/umS82gRaoT line 1:␤------> [32m.say [33m⏏[31mfor( 1 .. 10 :by 2)[0m␤    expecting any of:␤ bracketed infix␤  infix or meta-infix␤      statement modifier loop␤  statement_mod_loop␤Parse failed␤FAILED 00:01 114m␤»

[00:59] <Guest94307> std: .say for( 1 .. 10)

[00:59] <p6eval> std 31738: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row (method call requires colon or parens to take arguments) at /tmp/D7QoZRtF2w line 1:␤------> [32m.say [33m⏏[31mfor( 1 .. 10)[0m␤    expecting any of:␤    bracketed infix␤  infix or meta-infix␤      statement modifier loop␤ 

[00:59] <p6eval> ..statement_mod_l…

[01:00] <Guest94307> rakudo: .say for 1 .. 10

[01:00] <p6eval> rakudo dd8d5d: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[01:00] <Guest94307> rakudo: .say for 1 .. 10 :by 2

[01:00] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Confused at line 20, near ".say for 1"␤»

[01:00] <Guest94307> std: .say for 1 .. 10 :by 2

[01:00] <p6eval> std 31738: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/wT74Uxs2vo line 1:␤------> [32m.say for 1 .. 10 :by [33m⏏[31m2[0m␤    expecting any of:␤ bracketed infix␤  infix or meta-infix␤Parse failed␤FAILED 00:01 114m␤»

[01:00] <Guest94307> std: .say for 1 .. 10

[01:00] <p6eval> std 31738: OUTPUT«ok 00:01 113m␤»

[01:01] <Guest94307> pugs: .say for 1 .. 10

[01:01] <p6eval> pugs: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[01:01] <Guest94307> pugs: .say for 1 .. 10 :by 2

[01:01] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ":by"␤    expecting operator␤    at /tmp/th7yTSUNIj line 1, column 18␤»

[01:01] <TimToady> sorear: it doesn't create a scope any more than 'my' does, it just persists for the clone

[01:02] <TimToady> Guest94307: :by is long gone, and it would be :by(2) in any case

[01:02] <sorear> TimToady: I'm mostly thinking abould blasty stuff and the START desugar

[01:02] <TimToady> :by is a standalone term meaning :by(True)

[01:02] <Guest94307> I can see that in the spec. Thanks.

[01:03] <TimToady> all :by semantics were taken over by the ... operator

[01:03] <tylercurtis> pugs: my %h; %h<foo> = 5; say %h<foo>; %h<foo> :delete; say %h<foo>;

[01:03] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ":delete"␤    expecting operator␤    at /tmp/xHbKwOMbMQ line 1, column 42␤»

[01:04] <Guest94307> TimToady: yes. I have been away from Perl6 for a while. I can see that now.

[01:04] <TimToady> START should desugar to (state $)//=1 or some such, and the $ is an anonymous state var in the current lexical scope

[01:04] <TimToady> if there were another $ it would be a different var in the same scope

[01:04] <TimToady> std: my $

[01:04] <p6eval> std 31738: OUTPUT«ok 00:01 112m␤»

[01:04] <TimToady> rakudo: my $

[01:04] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Malformed my at line 20, near "$"␤»

[01:05] <TimToady> rakudo: state 42

[01:05] <p6eval> rakudo dd8d5d: OUTPUT«Could not find sub &state␤  in main program body at line 20:/tmp/O9BI2_qNOh␤»

[01:05] <TimToady> two strikes on rakudo

[01:06] <TimToady> alpha: say ++(state $)

[01:06] <p6eval> alpha 30e0ed: OUTPUT«Malformed declaration at line 10, near "$)"␤in Main (file <unknown>, line <unknown>)␤»

[01:06] <TimToady> alpha: say ++(state $x)

[01:06] <p6eval> alpha 30e0ed: OUTPUT«1␤»

[01:06] <TimToady> at least alpha knew 'state'

[01:06] <TimToady> pugs: say ++(state $)

[01:06] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "$)"␤    expecting "=", formal parameter, context, ":" or "("␤    at /tmp/1zpwm2Muoa line 1, column 14␤»

[01:06] <TimToady> pugs: say ++(state $x)

[01:06] <p6eval> pugs: OUTPUT«1␤»

[01:07] <TimToady> so a state $x = func() really entails two states, one for $x, and one for the implicit STATE block

[01:08] <TimToady> START even

[01:09] <TimToady> rakudo: say "foo"; START { say "bar" }; say "baz"

[01:09] <p6eval> rakudo dd8d5d: OUTPUT«foo␤Could not find sub &START␤  in main program body at line 20:/tmp/8oaU4o_y3V␤»

[01:09] *** kanishka left
[01:10] <TimToady> alpha: say "foo"; START { say "bar" }; say "baz"

[01:10] <p6eval> alpha 30e0ed: OUTPUT«foo␤bar␤baz␤»

[01:10] <TimToady> that's correct

[01:10] <TimToady> sorear: the reason for those semantics is state $x = $a + $b could depend on calculations earlier in the block

[01:11] <sorear> does $::CURLEX == $::UNIT make sense?>

[01:11] <TimToady> yes, that's asking if the currently compiling scope is the outermost of the compilation unit

[01:12] <TimToady> well, assuming == is the right way to compare refs :)

[01:12] <TimToady> but the :: sez yer in p5

[01:15] <tylercurtis> Should one refrain from submitting "bug reports" for things that are known to be NYI? e.g. state?

[01:20] <TimToady> it was YI in alpha, so don't refrain

[01:26] <jnthn> Feel free to make a ticket for state.

[01:26] <jnthn> alpha had a great impl of state variables. :-/

[01:27] * jnthn wonders how much he can just copy over

[01:31] <jnthn> Will try during the weekend. :-)

[01:32] <jnthn> It'd be nice to have that in for R*.

[01:32] <TimToady> maybe it could be moritz_'s next challenge though

[01:33] <TimToady> though he's mostly tried to avoid PIR-based challenges

[01:35] <jnthn> Trouble is, it not only needs to PIR (or at least Parrot-y) skills, but also PAST and NQP

[01:35] <jnthn> Which is quite a big ask.

[01:36] <jnthn> Thankfully, less and less of Rakudo is being written in PIR these days, though.

[01:37] <lue> > my $a = 3; my $b = $a; say $a =:= $b

[01:37] <lue> 1

[01:37] <lue> (.WHERE is a cruddy way to check if things were bound)

[01:37] <tylercurtis> My first rakudobug. :)

[01:38] <jnthn> I wonder if it ends up operating on the thingy in the container rather than the container. Probably.

[01:38] <jnthn> lue: eq_addr may be better

[01:38] <tylercurtis> rakudo: my $a = "foo"; my $b = $a; say $a =:= $b

[01:38] <p6eval> rakudo dd8d5d: OUTPUT«0␤»

[01:38] <jnthn> I fear that the way binding happens in Rakudo means it's not quite trivial...

[01:39] *** WH0RE joined
[01:40] <lue> rakudo: my $a = 3; my $b = $a; say "{$a.WHERE} — {$b.WHERE}"

[01:40] <p6eval> rakudo dd8d5d: OUTPUT«35233952 — 35233952␤»

[01:40] <lue> that's why its a problem :/

[01:41] <lue> Well, the parameters are (Mu \$a, Mu \$b)  # is that a boo-boo? :)

[01:43] <jnthn> no, that's what they should be

[01:45] <TimToady> the problem is that =:= should really be more like VAR($x) === VAR($y)

[01:45] <TimToady> where VAR fails on a value

[01:45] <jnthn> I don't recall VAR being spec'd as failing on a value.

[01:45] <lue> but macros don't exist yet :(

[01:45] <jnthn> But rather being identity on it.

[01:46] * jnthn checks S...12?

[01:46] <jnthn> C<VAR> is a no-op on a non-scalar variables and values:

[01:46] <jnthn> VAR(1);     # 1 VAR(@x);    # @x

[01:46] <TimToady> hmm, I don't think I wrote that part, or if I did, I was confused

[01:46] <jnthn> :-)

[01:48] <TimToady> anyway, =:= shouldn't work on non-bindable things, methinks, just if we can see if two containers are the same container

[01:48] <jnthn> *nod*

[01:49] * TimToady is tempted to remove =:= entirely if people are going to misuse it

[01:49] <TimToady> dinner &

[01:50] <sorear> jnthn: 1.VAR is probably never going to return 1 in niecza

[01:51] <sorear> at least, not legitimately

[01:53] <sorear> in niecza, 1.VAR returns something which is ~~ Variable, returns 1 from .container.FETCH, returns True from .readonly

[01:54] <sorear> or something like that

[01:54] <sorear> I need to work out the semantics of VAR with TimToady later

[01:54] <sorear> (but I'm absolutely convinced that the underlying data model I'm using is the right one)

[01:56] <tylercurtis> What's the Perl 6 equivalent of Common Lisp's "eq"? In other words, reference equality. You have two objects and you want to know if they have the same address.

[01:58] <sorear> $x.WHERE === $y.WHERE

[01:59] <jnthn> sorear: Is Variable spec?

[01:59] <tylercurtis> rakudo: say 5.WHERE === 5.WHERE

[01:59] <p6eval> rakudo dd8d5d: OUTPUT«0␤»

[01:59] <sorear> jnthn: no, but its interface is (partially)

[01:59] <jnthn> sorear: I see .VAR as a macro that gives you something that makes a scalar container not delegate its methods.

[02:00] <jnthn> (to the things it's holding)

[02:00] <jnthn> Er, methods called on it I mean

[02:00] <sorear> tylercurtis: === is defined to be value equality on immutable types like Int and reference equality on everything else

[02:00] <tylercurtis> rakudo: my $a = 5; my $b = $a; say $a.WHERE === $b.WHERE; #lue: does this do what you want?

[02:00] <p6eval> rakudo dd8d5d: OUTPUT«1␤»

[02:00] <sorear> tylercurtis: it's what you probably want

[02:00] <sorear> jnthn: S** talkes about VAR($x).readonly.  In niecza, a container doesn't know if it's readonly

[02:01] <sorear> my $a = 1; my $b ::= $a;  # $a and $b share the same Scalar object

[02:01] *** Guest94307 left
[02:02] <tylercurtis> interesting, "5.WHERE !=== 5.WHERE" but "my $a  = 5; my $b = $a; $a.WHERE === $b.WHERE", in Rakudo at least.

[02:03] <sorear> tylercurtis: each mention of 5 gives you a new Num object

[02:03] <sorear> tylercurtis: fixing that is your job, o high optimization hacker

[02:05] <lue> problem is, === is also a cheat, like =:= currently is.

[02:09] *** azert0x left
[02:10] <TimToady> === is supposed to be $a.WHICH eqv $a.WHICH

[02:10] *** plobsing joined
[02:10] <lue> I just don't trust things in the cheats/ folder. They're cheats! :)

[02:11] <lue> rakudo: my $a = 3; my $b = $a; say "{$a.WHICH}, {$b.WHICH}"

[02:11] <TimToady> they should be optimized away by the cheater, er, the optimizer

[02:11] <p6eval> rakudo dd8d5d: OUTPUT«3, 3␤»

[02:11] <TimToady> .WHICH is identity for value types

[02:12] <TimToady> and .WHERE for object types

[02:14] <tylercurtis> sorear: "fixing" that sounds fragile in Parrot. If you only have one Num object for 5 and you use any of the vtables that modify it; then everyone who thinks they have a Num 5 of their own suddenly has a Num 6.

[02:15] <jnthn> tylercurtis: I'm not sure Rakudo uses Parrot that way.

[02:15] <TimToady> which is why value types should generally be considered immutable

[02:15] <jnthn> tylercurtis: That said, I'm unsure whether Rakudo will use any of Rakudo's Integer/Float etc PMCs after I do my meta-model work.

[02:16] <jnthn> .oO( at this rate I'll have most parts of a VM out of the bits I replaced )

[02:16] <TimToady> maybe the most generic repr role should be named Turtle

[02:17] <jnthn> :D

[02:18] <jnthn> TimToady: Still beating my branes up over how do handle the lowest level bits of the meta-model.

[02:18] <jnthn> *to

[02:18] <jnthn> Including the REPR stuff

[02:18] <TimToady> well, do it just like Moose except where it's wrong :)

[02:19] <jnthn> Aye, but Moose relies on Perl 5 for at least some bits.

[02:19] <TimToady> that's where it's wrong :P

[02:19] <TimToady> badump bumb

[02:19] <TimToady> *bump

[02:21] *** cognominal left
[02:22] <TimToady> aha, that part of S12 was written by audreyt++

[02:23] <TimToady> pugs: say Var(1)

[02:23] <p6eval> pugs: OUTPUT«*** No such subroutine: "&Var"␤    at /tmp/hmbv2uXf3d line 1, column 5 - line 2, column 1␤»

[02:23] <TimToady> pugs: say VAR(1)

[02:23] <p6eval> pugs: OUTPUT«1␤»

[02:23] <TimToady> just a don't-deref hint

[02:24] <TimToady> have to tell if something is bindable some other way, if VAR works like that

[02:24] <jnthn> Or change how VAR works :-)

[02:24] <jnthn> I can't imagine many folks are depending on its meaning.

[02:25] <TimToady> esp since rakudo doesn't implement it

[02:25] <jnthn> alpha had a hacky attempt

[02:26] <jnthn> Current Rakudo won't get one back until I'm happy I can do it "properly"

[02:26] <TimToady> but if VAR($x) === VAR($y) can be made to do the same as =:=, I might just throw out =:= as an attractive nuisance

[02:26] <TimToady> cute though it is

[02:27] <jnthn> *nod*

[02:27] * TimToady now thinks about replacing VAR with prefix:<:=>

[02:27] <jnthn> But that implies it probably means to do something on @x, %y etc

[02:28] <jnthn> ...prefix:<:=>?!

[02:28] <TimToady> thought you'd like that... :)

[02:28] * jnthn chokes a little on his pivo

[02:37] <lue> :=$a

[02:38] <lue> looks nice, and forces good whitespacing \o/

[02:45] <lue> .oO(postcircumfix:<:= =:>)

[02:46] <jnthn> rakudo: sub circumfix:<:= =:>($foo) { say "lol $foo"; }; :=42=:

[02:47] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Confused at line 20, near ":=42=:"␤»

[02:47] <jnthn> :/

[02:47] <lue> circumfix doesn't work yet :(

[02:47] <jnthn> lue: It kinda does.

[02:47] <lue> [afaik]

[02:47] <jnthn> rakudo: sub circumfix:<` `>($foo) { say "lol $foo"; }; `42`

[02:47] <p6eval> rakudo dd8d5d: OUTPUT«lol 42␤»

[02:48] <jnthn> It's just *very* picky about what bracketing chars you can choose.

[02:48] <lue> rakudo: sub prefix:<:=>($a) { VAR($a) }; my $b = 3; say :=$b

[02:48] <jnthn> Probably because I did something rong, or LTM-ish reasons.

[02:48] <p6eval> rakudo dd8d5d: OUTPUT«Could not find sub &VAR␤  in 'prefix:<:=>' at line 20:/tmp/kRwOaP5bzj␤  in main program body at line 20:/tmp/kRwOaP5bzj␤»

[02:48] <tylercurtis> sub circumfix:<:= =:>($foo) { note 'NEVER EVER DO THIS!'; exit 1; }

[02:53] *** WH0RE left
[02:54] <TimToady> actually, I think that's still a bug in STD...

[02:54] <lue> afk

[02:55] <TimToady> std: sub circumfix:<` `>($foo) { say "lol $foo"; }; `42`

[02:55] <p6eval> std 31738: OUTPUT«unhandled meta : at RE_ast.pm line 402.␤FAILED 00:01 114m␤»

[02:55] <TimToady> std: sub circumfix:<:= =:>($foo) { say "lol $foo"; }; :=42=:

[02:55] <p6eval> std 31738: OUTPUT«unhandled meta : at RE_ast.pm line 402.␤FAILED 00:01 114m␤»

[02:57] <jnthn> TimToady: Rakudo mostly runs into issues when there's a prefix operator with the same char as the opener for the circumfix.

[02:58] <jnthn> TimToady: e.g. in the RT ticket somewhat wanted to do a sub circumfix:<| |>($n) { abs($n) }; say |-1|

[02:58] <TimToady> well, that one's just not gonna fly, if you want to keep prefix:<|>

[02:58] <jnthn> Right

[02:59] <jnthn> I guessed it wouldn't in STD either.

[02:59] <jnthn> What I thought *should* work is like

[02:59] <TimToady> not without there's some way to combine the two so they know about each other, and where to expect the final |

[02:59] <jnthn> rakudo: sub circumfix:<|| ||>($n) { abs($n) }; say ||-1||

[02:59] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Confused at line 20, near "say ||-1||"␤»

[02:59] <jnthn> And it'd beat prefix:<|> on LTM

[02:59] <TimToady> we have prefix:<||> too

[02:59] <jnthn> (because || is a longer token)

[02:59] <jnthn> ...we do?

[03:00] <TimToady> interpolate slice

[03:00] <jnthn> I don't think Rakudo knows that one though and it still barfs.

[03:00] <jnthn> But OK, bad example.

[03:00] <jnthn> Anyway, my point was that choosing good circumfixes is potentially quiet hard.

[03:00] <TimToady> indeed

[03:02] <jnthn> OK, well, I'll be interested when STD does it, how well it and Rakudo match up on what flies and what doesn't.

[03:04] <TimToady> STD did used to work on non-identical chars

[03:05] <TimToady> std: sub circumfix:<〘 〙>($foo) { say "lol $foo"; }; 〘42〙

[03:05] <p6eval> std 31738: OUTPUT«unhandled meta : at RE_ast.pm line 402.␤FAILED 00:01 114m␤»

[03:06] <TimToady> that's a minor regression for which I gladly trade all of sorear++'s upgrades :)

[03:06] <jnthn> *nod*

[03:15] *** sftp_ left
[03:17] <jnthn> meh, it's 5:20am and I'm not even that tired. :S

[03:17] <sorear> I recommend VAR not be standardized until I have a chance to warp it into my personal views.

[03:18] <jnthn> +1, apart from I want an opportunity to do the same :-)

[03:18] <jnthn> It may be one of those macros where the implementation has a choice of what to do though.

[03:19] <jnthn> (e.g. like the representation API)

[03:23] <dalek> niecza: 11f549b | sorear++ |  (2 files):

[03:23] <dalek> niecza: Move slot logic into Decl

[03:23] <dalek> niecza: review: http://github.com/sorear/niecza/commit/11f549b325197656b31b5aaba50f3be1ea806e33

[03:23] <dalek> niecza: 649b221 | sorear++ |  (3 files):

[03:23] <dalek> niecza: Implement START phaser

[03:23] <dalek> niecza: review: http://github.com/sorear/niecza/commit/649b2215f5e0940b2038707037dec1fe070d93ef

[03:23] * jnthn -> rest, or an elongated keyboard break, anyways

[03:28] *** ab5tract left
[03:35] <dalek> book: 5a8c3de | chromatic++ | src/grammars.pod:

[03:35] <dalek> book: Edited grammars chapter for clarity.

[03:35] <dalek> book: A few author notes are very important here.

[03:35] <dalek> book: review: http://github.com/perl6/book/commit/5a8c3def0ffc914102dc3ed2b93835fd46239fdf

[03:36] *** justatheory left
[03:41] <tylercurtis> Am I correct in understanding that "{*} #= something" is no longer the proper way to do what it does in Perl 6 regexes?

[03:54] <Tene> That's right.

[03:54] *** DemoFreak left
[03:55] *** DemoFreak joined
[03:56] <tylercurtis> And a token with <?> as its body is the proper way?

[04:10] <TimToady> generally if you think you need to do that, you should decompose your rules better

[04:13] <TimToady> also, we just stole the {*} syntax for proto calls into their multis

[04:14] <sorear> generally speaking you should try to keep rules under 15 lines or so

[04:14] <sorear> longer rules are very annoying to write actions for

[04:15] <TimToady> well, I don't do arbitrary limits, but organically speaking, if something doesn't have a name that you need to have a name, that's pretty indicative

[04:16] <TimToady> there's some kind of a general principle here, related to looking for stack frames that have certain characteristics rather than counting them

[04:16] <TimToady> so it would be good if FIRST and LAST knew how to find their innermost enclosing loop in the same way that next and last can

[04:17] <TimToady> rather than assuming that it must be the same as OUTER

[04:17] *** envi^home joined
[04:17] <TimToady> or $?BLOCK, or whatever the accurate way to say that is when I'm awaker

[04:23] *** gfx joined
[04:29] <tylercurtis> TimToady, sorear: I'm trying to keep the basic structure of the Squaak tutorial analogous as I update it. So, currently, the TOP rule calls its action twice. The first time, it supplies the key 'open', and initializes $?BLOCK and @?BLOCK package variables that will be used in actions lower in the parse tree(to add lexicals to the current block's symbol table and such). Later it makes the topmost block.

[04:29] <tylercurtis> I'm going to, for now at least, just replace that with a token begin_TOP { <?> } whose action does that initialization.

[04:32] <TimToady> that's fine too, or you can write begin_TOP as a real method in real Perl 6

[04:32] <TimToady> or just inline the init code in a {...} block

[04:33] <TimToady> whatever works

[04:46] *** envi^home left
[04:51] *** Chillance left
[05:00] *** pmurias joined
[05:04] *** tylercurtis left
[05:05] *** tylercurtis joined
[05:18] <ingy> greetings

[05:42] *** cognominal joined
[05:42] *** cognominal left
[05:53] *** Mowah joined
[06:00] *** ashleydev joined
[06:11] <pugssvn> r31739 | lwall++ | [STDeco] implement circumfix categoricals correctly (I hope) 

[06:11] <pugssvn> r31739 |     1) by deriving the unbalanced lang for the <stopper> inside (duh)

[06:11] <pugssvn> r31739 |     2) by checking <!stopper> at the start of a statement (also duh)

[06:12] <TimToady> and just for the record, it was *not* a regression caused by sorear++'s work in any way; I'd just never finished it right

[06:18] <pmurias> TimToady: what tests should STD-0.02 run on installation?

[06:20] <ingy> rakudo: say "xxx".subst(/x/g, 'i')

[06:20] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Unsupported use of /g; in Perl 6 please use :g at line 20, near ", 'i')"␤»

[06:20] <ingy> rakudo: say "xxx".subst(m:g/x/, 'i')

[06:20] <dalek> niecza: 8f73f31 | sorear++ |  (2 files):

[06:20] <dalek> niecza: Implement calls to subroutine references

[06:20] <dalek> niecza: review: http://github.com/sorear/niecza/commit/8f73f316f8cd7487ad37de9b2878f76c1057dc5a

[06:20] <dalek> niecza: bd10167 | sorear++ |  (3 files):

[06:20] <dalek> niecza: Implement the 'state' declarator

[06:20] <dalek> niecza: review: http://github.com/sorear/niecza/commit/bd1016748f4b842eb3bbe7ed764304f30fc91972

[06:20] <dalek> niecza: 2879d62 | sorear++ |  (3 files):

[06:20] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 20␤»

[06:20] <dalek> niecza: Implement implicit START semantics for state initializers

[06:20] <dalek> niecza: review: http://github.com/sorear/niecza/commit/2879d6284648dd8f87c935dc51a25228f7c42652

[06:20] <TimToady> pmurias: well, compiling itself is the most important test

[06:20] <pmurias> how should it do that?

[06:21] <ingy> rakudo: say "xxx".subst(m/x/, 'i')

[06:21] <p6eval> rakudo dd8d5d: OUTPUT«ixx␤»

[06:21] <ingy> rakudo: say "xxx".subst(m:g/x/, 'i')

[06:21] <TimToady> have a copy of STD.pm6 and see if it parses, I suppose

[06:21] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 20␤»

[06:21] <snarkyboojum> rakudo: say "xxx".subst(m/x/, 'i', :g)

[06:21] <p6eval> rakudo dd8d5d: OUTPUT«iii␤»

[06:21] <ingy> thx

[06:23] *** cjk101010 joined
[06:23] <moritz_> good morning

[06:23] <pmurias> TimToady: would checking if that copy parses something simple be a good idea?

[06:24] *** ashleydev left
[06:24] <TimToady> maybe, dunno how much of the infrastructure used by, say 'make snaptest' is included in your dist

[06:28] <ingy> rakudo: say "O'Reilly".subst(/"'"/, "''")

[06:28] <p6eval> rakudo dd8d5d: OUTPUT«O''Reilly␤»

[06:30] <sorear> I think I'll pass on first/last for now

[06:30] <sorear> have to let yapsi stay better at /something/

[06:31] <TimToady> first/last is not necessary for niecza *   :)

[06:31] <moritz_> rakudo: sub f() is foo { }

[06:31] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Routine $r, Any :default($default)!)␤:(Code $block, Any $arg?, Any :export($export)!)␤:(Mu $child, Mu $parent)␤:(Mu $type where ({ ... }), Any

[06:31] <p6eval> ..:rw($rw)…

[06:31] *** tylercurtis left
[06:33] <moritz_> std: class A { has method x() { } }

[06:33] <p6eval> std 31738: OUTPUT«ok 00:01 113m␤»

[06:33] <ingy> moritz_: did you catch my note from earlier?

[06:33] <moritz_> rakudo: class A { has method x() { } }

[06:33] <moritz_> ingy: yes

[06:33] <p6eval> rakudo dd8d5d:  ( no output )

[06:38] <sorear> TimToady: nie ;)

[06:40] <TimToady> is 'ie' in czech pronounced like it is in deutsch?

[06:42] <ingy> moritz_: just found/fixed a buglet in ufo

[06:43] * moritz_ git pulls

[06:43] <ingy> moritz_: have you seen my work? sexy! http://github.com/masak/ufo/blob/master/ufo

[06:43] <sorear> it has been determined that masak screwed up and mentally amalgamated czech and slovak while naming niecza

[06:43] <sorear> which means that there isn't actually a correct pronounciation

[06:43] <sorear> I'm ok with that

[06:44] <moritz_> ingy: it would be sexy if ufo emitted proper dependencies for the modules, so that 'make -j' works

[06:44] <TimToady> std: sub circumfix:<⦃ ⦄> ($x) { say $x }; ⦃ 42 ⦄

[06:44] <p6eval> std 31739: OUTPUT«ok 00:01 124m␤»

[06:44] <TimToady> std: sub circumfix:<` `> ($x) { say $x }; `42`

[06:45] <p6eval> std 31739: OUTPUT«ok 00:01 124m␤»

[06:45] <TimToady> hmm

[06:46] <TimToady> std: sub postcircumfix:<⦃ ⦄> ($x) { say $x }; $_⦃ 42 ⦄

[06:46] <p6eval> std 31739: OUTPUT«ok 00:01 124m␤»

[06:46] <TimToady> \o/ never tested postcircumfix

[06:48] <ingy> moritz_: the only code left in ufo is to order the SOURCES. I think that ufo should just be a util that reads module path names on stdin, and sorts them in its order onto stdout. The Makefile then, as it stands, could be totally static.

[06:49] *** pmurias left
[06:51] <moritz_> having it read from STDIN doesn't sound very easy for the user

[06:53] <ingy> moritz_: disconnect... nevermind...

[06:54] <ingy> I'm bascially just saying that ufo is not really needed at all, at this point. A static Makefile would do fine. It's already a hair from that.

[06:54] <TimToady> std: sub circumfix:<｢ ｣> ($x) { say $x }; ｢42｣

[06:54] <p6eval> std 31739: OUTPUT«ok 00:01 124m␤»

[06:55] <TimToady> std: sub circumfix:<| |> ($x) { say $x }; |42|

[06:55] <p6eval> std 31739: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus term at /tmp/c36uf7dOGE line 1 (EOF):␤------> [32mub circumfix:<| |> ($x) { say $x }; |42|[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 120m␤»

[06:55] <ingy> but I like the ufo usage meme just fine for now anyway

[06:55] <TimToady> std: sub circumfix:<| |> ($x) { say $x }; |42|;

[06:55] <p6eval> std 31739: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus term at /tmp/irsNgQz94d line 1:␤------> [32mub circumfix:<| |> ($x) { say $x }; |42|[33m⏏[31m;[0m␤Parse failed␤FAILED 00:01 120m␤»

[06:57] <TimToady> that should really take precedence over prefix:<|> by the 'most derived' rule, S05:46

[06:57] <TimToady> but I don't think we have that PEG disambiguator yet

[07:00] *** cognominal joined
[07:04] <ingy> rakudo: say [ 'foo', 'bar' ].map { flip }

[07:04] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Confused at line 20, near "say [ 'foo"␤»

[07:05] <ingy> rakudo: say [ 'foo', 'bar' ].map({ flip }).perl

[07:05] <p6eval> rakudo dd8d5d: OUTPUT«No applicable candidates found to dispatch to for 'flip'. Available candidates are:␤:(Mu ;; *%_)␤␤  in <anon> at line 20:/tmp/7xa9RwiVPK␤  in 'Any::join' at line 1␤  in 'List::perl' at line 2517:CORE.setting␤  in main program body at line 20:/tmp/7xa9RwiVPK␤»

[07:05] <ingy> rakudo: say [ 'foo', 'bar' ].map({ upper }).perl

[07:05] <p6eval> rakudo dd8d5d: OUTPUT«Could not find sub &upper␤  in <anon> at line 20:/tmp/IRO7KuSb4V␤  in 'Any::join' at line 1␤  in 'List::perl' at line 2517:CORE.setting␤  in main program body at line 20:/tmp/IRO7KuSb4V␤»

[07:05] <TimToady> nothing defaults to $_, use .flip or .uc

[07:06] <ingy> rakudo: say [ 'foo', 'bar' ].map({ .uc }).perl

[07:06] <p6eval> rakudo dd8d5d: OUTPUT«("FOO", "BAR")␤»

[07:06] <TimToady> rakudo: say <foo bar>.map: *.flip

[07:06] <p6eval> rakudo dd8d5d: OUTPUT«oofrab␤»

[07:07] <ingy> rakudo: say ( 'foo', 'bar' ).map({ .uc }).perl

[07:07] <p6eval> rakudo dd8d5d: OUTPUT«("FOO", "BAR")␤»

[07:07] <ingy> rakudo: say [ 'foo', 'bar' ].map({ .flip }).perl

[07:07] <p6eval> rakudo dd8d5d: OUTPUT«("oof", "rab")␤»

[07:07] <TimToady> rakudo: say <foo bar>».map({.uc}).perl

[07:07] <p6eval> rakudo dd8d5d: OUTPUT«(("FOO"), ("BAR"))␤»

[07:08] <TimToady> rakudo: say <foo bar>».uc.perl

[07:08] <p6eval> rakudo dd8d5d: OUTPUT«("FOO", "BAR")␤»

[07:08] <ingy> I'm just trying to learn map, TimToady 

[07:08] <ingy> thanks though

[07:09] <ingy> rakudo: say [ 'foo', 'bar' ].map({ .flip }).array.perl

[07:09] <p6eval> rakudo dd8d5d: OUTPUT«Method 'array' not found for invocant of class 'List'␤  in main program body at line 20:/tmp/fQ9LCIWXVp␤»

[07:09] <ingy> rakudo: say [ 'foo', 'bar' ].map({ .flip }).Array.perl

[07:10] <p6eval> rakudo dd8d5d: OUTPUT«Method 'Array' not found for invocant of class 'List'␤  in main program body at line 20:/tmp/tqgZNF4P6J␤»

[07:10] <ingy> meh

[07:10] *** tadzik joined
[07:10] <moritz_> [...] constructs an array

[07:10] <TimToady> .Array should probably have worked

[07:10] <ingy> rakudo: say [[ 'foo', 'bar' ].map({ .flip })].perl

[07:10] <p6eval> rakudo dd8d5d: OUTPUT«["oof", "rab"]␤»

[07:10] <ingy> that would be nice I think

[07:10] <moritz_> rakudo leaks memory like a leaky couldron

[07:11] <ingy> moritz_: someday rakudo will leak memory like an airtight couldron

[07:14] <ingy> rakudo: say substr("ingy", 1, 2)

[07:14] <p6eval> rakudo dd8d5d: OUTPUT«ng␤»

[07:14] <ingy> rakudo: say substr(("ingy", 1, 2))

[07:14] <p6eval> rakudo dd8d5d: OUTPUT«No applicable candidates found to dispatch to for 'substr'. Available candidates are:␤:(Mu : Any $start, Any $length?;; *%_)␤␤  in main program body at line 20:/tmp/sVtxiJzBTH␤»

[07:14] <ingy> rakudo: say substr(|("ingy", 1, 2))

[07:14] <p6eval> rakudo dd8d5d: OUTPUT«ng␤»

[07:15] <ingy> \o/

[07:16] <ingy> rakudo: say [[ 'foo', 'bar' ].map({ flip($_) })].perl

[07:16] <p6eval> rakudo dd8d5d: OUTPUT«["oof", "rab"]␤»

[07:19] <sorear> TimToady: I'm thinking of providing more extensive system interfacing in niecza, but also being able to switch it off hard for moritz_.  To me this seems to call for implementing conditional compilation.  Thoughts?

[07:20] <TimToady> conditional compilation is usually the wrong solution, if it can be done more modularly by just swapping in different files

[07:21] <dalek> niecza: bdea4d8 | sorear++ |  (2 files):

[07:21] <dalek> niecza: Implement a system of body types

[07:21] <dalek> niecza: review: http://github.com/sorear/niecza/commit/bdea4d844be29bc72ac790c6ad9cb497b753bef3

[07:21] <dalek> niecza: 9fac9e9 | sorear++ |  (3 files):

[07:21] <dalek> niecza: Don't clone mainline pads

[07:21] <dalek> niecza: Inspired by some discussion with TimToady++ , this is an attempt to make END

[07:21] <dalek> niecza: more useful, but it also seems to help with optimization prospects a great

[07:21] <dalek> niecza: deal as well.  A pad which belongs to a mainline (defined recursively below)

[07:21] <dalek> niecza: will not be deeply cloned; any variable in it at runtime aliases the same

[07:21] <dalek> niecza: variable at compile time.

[07:21] <dalek> niecza: UNIT is a mainline.

[07:21] <dalek> niecza: Any statement-level bare block contained in a mainline is itself a mainline.

[07:21] <dalek> niecza: Any package definition in a mainline is itself a mainline.

[07:21] <dalek> niecza: review: http://github.com/sorear/niecza/commit/9fac9e9f0975d121139d77bbeecae3ecc6cb2a3d

[07:22] <TimToady> if you just want to turn off some well-formed code, if CONSTANT should eventually optimizeit away if the constant is known false

[07:22] <ingy> how do I test if a value is a Str

[07:23] <TimToady> ~~ Str

[07:23] <ingy> what about a Foo::Bar?

[07:23] <ingy> instance

[07:23] <ingy> same deal?

[07:23] <TimToady> any type

[07:24] <ingy> rakudo: class Foo {}; Foo.new ~~ Foo

[07:24] <p6eval> rakudo dd8d5d:  ( no output )

[07:24] <ingy> rakudo: class Foo {}; say Foo.new ~~ Foo

[07:24] <p6eval> rakudo dd8d5d: OUTPUT«1␤»

[07:24] <TimToady> rakudo: say [] ~~ Array

[07:24] <p6eval> rakudo dd8d5d: OUTPUT«1␤»

[07:24] <ingy> :P

[07:24] <TimToady> rakudo: say [] ~~ Positional

[07:24] <p6eval> rakudo dd8d5d: OUTPUT«1␤»

[07:24] <TimToady> rakudo: say [] ~~ Any

[07:24] <p6eval> rakudo dd8d5d: OUTPUT«1␤»

[07:25] <sorear> TimToady: it's more a case of, I want to remove access to all but a small whitelisted set of external calls at the code generator level, but a few setting functions will be broken by that

[07:25] <sorear> and the setting is always a single file?

[07:25] <TimToady> not necessarily

[07:26] *** pmurias joined
[07:26] <TimToady> but if you're running essentially a different language, you want it declared differently somehow

[07:27] <TimToady> rakudo: subset Something of Any where +*; say [] ~~ Something

[07:27] <p6eval> rakudo dd8d5d: OUTPUT«0␤»

[07:27] <TimToady> rakudo: subset Something of Any where +*; say [0] ~~ Something

[07:27] <p6eval> rakudo dd8d5d: OUTPUT«1␤»

[07:29] <TimToady> gotta crash

[07:29] <TimToady> zzz &

[07:30] <pmurias> sorear: if adding a secure mode you could also try adding security by using a sandbox mode of the .NET vm

[07:30] <pmurias> sorear: mono appears to have something like that: http://www.mono-project.com/MonoSandbox

[07:31] <sorear> mono --help says (unsupported) in large friendly letters

[07:32] <pmurias> why is it unsupported?

[07:33] <pmurias> they use it for moonlight so it should work correctly

[07:33] <sorear> from the .NET exception best practices: * Use grammatically correct error messages

[07:33] <moritz_> :-)

[07:39] <sorear> MonoSandbox doesn't say anything on how to enable the sandbox

[07:53] <sorear> --security=core-clr looks like it mgiht be what I want

[08:03] *** hudnix left
[08:03] *** hudnix joined
[08:04] *** envi^home joined
[08:04] <ingy> rakudo: say "x" !~ /y/

[08:04] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Unsupported use of !~ to do negated pattern matching; in Perl 6 please use !~~ at line 20, near "/y/"␤»

[08:05] <ingy> rakudo: say "x" !~~ /y/

[08:05] <p6eval> rakudo dd8d5d: OUTPUT«1␤»

[08:05] <moritz_> rakudo++ # awesome error message

[08:05] <ingy> oui

[08:05] <ingy> rakudo++

[08:07] <ingy> I'm zzzzz all'y'all. o/

[08:08] *** timbunce joined
[08:17] <sorear> moritz_: I just discovered that I can cut 1.5-2s of niecza run time by running sudo mono --aot -O=all,-shared against gmcs.exe and dependencies thereof (strace -efile gmcs /r:Setting.dll Program.cs 2>&1 | grep 'so"')

[08:18] * sorear wonders if he's going to pay for this eventually

[08:19] <pragma_> fgetsA

[08:20] <pmurias> sorear: if you keep an unmodified mono to tests for compability the price shouldn't be too high

[08:21] <pmurias> * compability checking

[08:23] *** eternaleye left
[08:39] * sorear lazily -> stefan@stefans:/usr/local/lib/mono$ find . -name '*.exe' -o -name '*.dll' | perl -ne 'chomp; system("sudo","mono","--aot","-O=all,-shared",$_)' 2>&1 | tee /tmp/aot.log

[08:40] <sorear> aftward, I have <1s turnaround in the REPL

[08:41] <sorear> even though I'm still shelling out to the C# compiler for my code generation

[08:46] <dalek> niecza: abf4863 | sorear++ |  (3 files):

[08:46] <dalek> niecza: Make NIECZA_TRACE a runtime, not compile time, check.  Small performance loss.

[08:46] <dalek> niecza: review: http://github.com/sorear/niecza/commit/abf486387621823276e21b1f9677933902c128e5

[08:48] *** jferrero joined
[08:52] <sorear> pmichaud: ping

[09:01] <sorear> or anyone.

[09:02] <sorear> I think I get Parcel - it's a lazy list of values which are 1. not contextualized 2. bound rw

[09:02] <sorear> Seq is a Parcel which binds stuff 'is copy' (and also ro)

[09:03] <sorear> Array contextualizes, containing only stuff with the scalar-nature, is copy and rw

[09:03] <sorear> ... I don't get where List fits in.

[09:06] *** rgrau_ joined
[09:09] <moritz_> like an Array, but not modifyable

[09:09] <TiMBuS> rakudo: my $a = sub{'hello'}; $a.wrap: {callsame ~ 'world'}; $a().say

[09:09] <p6eval> rakudo dd8d5d: OUTPUT«hello␤»

[09:10] <sorear> moritz_: is that the same as "like Seq, but forcing item context on elements"?

[09:10] <TiMBuS> rakudo: my $a = sub{'world'} $a.wrap: {'hello' ~ callsame}; $a().say

[09:10] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Confused at line 20, near "my $a = su"␤»

[09:11] <TiMBuS> rakudo: my $a = sub{'world'}; $a.wrap: {'hello' ~ callsame}; $a().say

[09:11] <p6eval> rakudo dd8d5d: OUTPUT«helloworld␤»

[09:12] <TiMBuS> :/

[09:12] <moritz_> what's :/ about it?

[09:15] <TiMBuS> is that expected behaviour?

[09:15] *** M_o_C joined
[09:15] <moritz_> what?

[09:16] <moritz_> the parse error? yes

[09:16] <TiMBuS> (callsame ~ 'world') returns 'hello' but ('hello' ~ callsame) returns 'helloworld'

[09:17] <moritz_> callsame ~ 'world' is the same as callsame(~'world'), which is the same as callsame('word')

[09:17] <moritz_> s/rd/rld/

[09:17] <moritz_> you probably want callsame() ~ 'world'

[09:18] <sorear> moritz_: is List = Seq but with item context on elements?

[09:18] *** meppl joined
[09:19] <moritz_> sorear: I'm not sure... ask pmichaud, he should know :-)

[09:19] <sorear> Well, it sounds good. :)  I can always change it later

[09:19] <TiMBuS> ah i see. well if thats the case, can callsame take arguments?

[09:19] <sorear> In:  for $*IN.lines { .say }

[09:20] <sorear> What allows the memory to be freed?

[09:20] <moritz_> TiMBuS: I think it shouldn't

[09:20] <sorear> I'm guessing some shifty business with Lists?

[09:20] <moritz_> sorear: pmichaud mumbled something about immutable iterators/cursors

[09:24] <moritz_> sorear: there were lots of discussions when pmichaud worked on the 'list' branch... have fun backlogging :-)

[09:27] *** clintongormley joined
[09:30] *** IllvilJa left
[09:30] <sorear> hah.

[09:31] <sorear> niecza: sub VAR($x) { Q:CgOp { (newscalar (getfield container (getfield lv (l $x)))) } }; say VAR(1)

[09:31] <p6eval> niecza: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized quote modifier: CgOp at (eval) line 1:␤------> [32msub VAR($x) { Q[33m⏏[31m:CgOp { (newscalar (getfield container ([0m␤Check failed␤»

[09:33] <sorear> doesn't even work locally. :/

[09:45] * sorear out.

[09:46] *** rgrau_ left
[09:47] *** rgrau___ joined
[09:48] *** ive joined
[09:49] *** ive left
[09:57] *** Alias joined
[10:02] <pugssvn> r31740 | pmurias++ | [mildew] rename Types to Mildew::Types 

[10:02] *** pmurias left
[10:03] *** whiteknight joined
[10:07] *** timbunce left
[10:12] *** timbunce joined
[10:12] *** ive joined
[10:39] *** M_o_C left
[10:40] *** gfx left
[10:40] *** M_o_C joined
[10:56] * sorear finds a very simple way to drastically simplify niecza's object model

[10:56] <sorear> I hereby declare that it is illegal to augment any class defined inside a loop or subroutine.

[10:57] <sorear> If your loops or subroutines are so big that they contain classes that need to be defined in multiple pieces, you're doing something wrong anyway.

[10:59] *** snarkyboojum left
[11:16] *** ive left
[11:20] *** snarkyboojum joined
[11:29] *** timbunce left
[11:34] <sorear> also, such a class cannot be declared 'our' for much the same reasons

[11:38] <moritz_> I think it's a sane-ish restriction :-)

[11:40] <moritz_> \o/ my resonance curves (with Math::Model) look fine

[11:40] <sorear> grr.  this {YOU_ARE_HERE} change is suprisingly inconvenient for niecza

[11:41] <sorear> because for @foo {YOU_ARE_HERE}, class Cow {YOU_ARE_HERE}, etc are suddenly valid syntax

[11:42] <sorear> and my data structures are completely unprepared to handle a compilation unit being a loop block or class body

[11:42] <moritz_> std: for 1, 2 {YOU_ARE_HERE}

[11:42] <p6eval> std 31740: OUTPUT«Use of uninitialized value $file in substitution (s///) at CursorBase.pm line 362.␤ok 00:01 117m␤»

[11:42] <sorear> maybe I'll just cheat and treat {YOU_ARE_HERE} as {{YOU_ARE_HERE}}

[11:43] <sorear> so you won't be able to use FIRST/LAST/has in UNIT

[11:53] *** hanekomu_9 joined
[11:56] <sorear> Also, because of the need to emulate MI at compose time in some environments, I suspect it may be erroneous to augment a class with subclasses.

[11:56] <sorear> This restriction, however, will NOT be implemented in niecza.  Yet.

[11:59] <dalek> niecza: 0d75b53 | sorear++ |  (3 files):

[11:59] <dalek> niecza: Update to latest STD

[11:59] <dalek> niecza: We get unused warnings in the setting, since STD can't see into low-level

[11:59] <dalek> niecza: code blocks.  Not sure how best to fix this.

[11:59] <dalek> niecza: review: http://github.com/sorear/niecza/commit/0d75b53b40bb2831386bddc9c7a208124f97237e

[12:09] *** hanekom__ joined
[12:09] *** hanekomu_9 left
[12:11] *** sftp joined
[12:18] *** xabbu42 left
[12:34] *** snarkyboojum left
[12:54] *** snarkyboojum joined
[12:56] *** hanekom__ left
[13:15] *** azert0x joined
[13:16] *** xinming left
[13:20] *** am0c joined
[13:20] *** am0c left
[13:28] *** tadzik left
[13:29] *** whiteknight left
[13:42] *** tadzik joined
[13:45] *** snarkyboojum left
[13:46] *** kid51 joined
[13:48] *** payload joined
[13:49] <jnthn> sorear: actually it's Polish spelling of a masing together of Czech words, so far as I can tell. :-) Let's just call it "Generic West Slavic". :-)

[13:50] *** colomon left
[14:03] *** tylercurtis joined
[14:03] *** ruoso joined
[14:04] *** xinming_ joined
[14:41] <TimToady> jnthn: I just want to know how to pronounce it

[14:46] *** M_o_C left
[14:46] *** ashleydev joined
[14:53] <TimToady> sorear: why should it matter whether augment occurs in a loop?  everything important in an augment is supposed to be done by declarations, not run-time code

[14:53] <TimToady> most augments will execute a null statement list at DO time

[14:54] *** kid51 left
[14:55] <TimToady> if you have to simplify by restricting augment in loop, I submit that you should be simplifying some other way instead, mebbe

[14:56] <jnthn> TimToady: The "ie" in nie is a diphthong. The cz is a digraph for č, like the "ch" in "chocolate""

[14:56] *** ashleydev left
[14:56] <TimToady> I figgered the ch, but wondered if the ie was diphthong or not.  thanks

[14:58] <jnthn> TimToady: Also the n is palatalized.

[14:58] <TimToady> sorear: List does not enforce any context; only binding enforces context

[14:59] <TimToady> I also figgered that as an alternate way of thinking of the ie, this being slavic  :)

[15:04] <TimToady> sorear: and maybe you can compile UNIT as a you would a thunk, so that it borrows the lexical scope from the YOU_ARE_HERE, which is must know before it compiles, or there's no setting

[15:04] <jnthn> TimToady: Ah, no, the "i" is not just a "palatalize this" indicator. In Slovak, "ne" (a prefix for negating verbs, e.g. mam => nemam) and "nie" ("no" but also used to negate the verb "to be", and stands as a separate word e.g. "je" => "nie je") have distinct sounds. The "n" is palatalized in both cases.

[15:05] <TimToady> ss/is must/it must/

[15:06] <TimToady> k

[15:07] <TimToady> sorear: and for the same reason, 'our class' in a loop should be No Problem

[15:08] <TimToady> all declarational aspects of classes should be done at compile time, not run time, including composition

[15:08] *** Mowah left
[15:09] <TimToady> at DO phase, 'our class' just looks like 'our package', with whatever statements weren't declarations as the only executing code, often nothing at all

[15:13] <TimToady> and 'our' things really live in the global space, with only a name in the lexical scope, so that only thing that could be cloned is the name lookup itself

[15:14] <jnthn> Rakudo ends up building two blocks essentially, one containing the compilation of the declarations and the other containing the none-declarative bits.

[15:14] <jnthn> *non

[15:15] <TimToady> the first of those blocks is the one I was referring to when I muttered about BEGIN time, and was taken to mean that the second block runs at BEGIN time, which is not so

[15:15] <jnthn> *nod*

[15:16] <TimToady> and I assume part of rakudo's problem is trying to defer various BEGIN-time bits to INIT time.  :)

[15:16] <TimToady> and then things happen out of order

[15:17] <TimToady> so basically you have to run the BEGIN at BEGIN time and emulate its state with yet a third "block" that runs at INIT time, it seems from here

[15:18] <TimToady> rather than the freeze/restore of proto-state we've discussed from time to time

[15:18] <TimToady> maybe someday parrot will support that...

[15:22] <jnthn> TimToady: Even if we take Parrot out of the equation for a moment and imagine we can have a runtime that can do such things. We still have the problem that in, say, class Foo { method bar { self.foo }; method foo { } }, if we want to optimize that call on self then we need to really have composed the class, but that means the compilation of the method bodies can't have taken place at that point.

[15:23] <jnthn> It's almost as if we want to construct the "shape" of the class as we parse it, and then fill in the methods later on.

[15:24] <TimToady> I don't follow that at all

[15:25] <TimToady> the methods are at least compiled down to AST immediately; optimization and code generation can always be lazy

[15:26] <jnthn> TimToady: Oh, I agree about them going to AST immediately.

[15:26] <jnthn> TimToady: It's just that the optimizer at some level wants to have the meta-class to hand.

[15:27] <TimToady> which should be to hand during compilation

[15:28] <jnthn> TimToady: Do you envision that when we parse a declaration like method foo() { } in a class body, we immediately call add_method on a meta-object?

[15:28] <TimToady> 'has' should be telling the meta-class something at its BEGIN time

[15:30] <TimToady> a {...} stub, if necessary, to be filled in later with real code

[15:30] <jnthn> Right, so I'm not crazy to be thinking such things as "stub and fill in later". :-)

[15:30] <TimToady> that's the way all declarations work in Perl 6, pretty much

[15:30] <jnthn> That's largely what I was trying to ask.

[15:31] <TimToady> names are always entered into their namespace immediately

[15:31] <TimToady> so declarations can be self-referential

[15:31] <jnthn> TimToady: Essentially, we need to generally not be maintaining compile-time and runtime versions of things separately?

[15:32] <TimToady> std: class NewName { has NewName $.x }  # would be an error unless NewName entered immediately

[15:32] <p6eval> std 31740: OUTPUT«ok 00:01 113m␤»

[15:32] <jnthn> Sure, but the Rakudo answer to that is to look in the namespace *and* in some state that the compiler is keeping.

[15:32] <TimToady> 'need to' is a bit to strong

[15:32] <TimToady> *too

[15:33] <TimToady> it's just very error prone to maintain parallel engines

[15:33] <jnthn> OK.

[15:33] <jnthn> So more of a trade-off.

[15:33] <TimToady> when I say "namespace" I never mean "package", unless I do

[15:34] <jnthn> :-)

[15:34] <TimToady> when I say namespace I mean, hopefully, the proto namespace the compiler is using that will turn into a real namespace

[15:34] <TimToady> where namespace could be the metaobject, or the lexical scope, or a pad

[15:35] <TimToady> s/pad/package

[15:35] <jnthn> *nod*

[15:35] *** timbunce joined
[15:35] <jnthn> I probably really need to fathom serializability into the meta-model stuff I work on.

[15:36] <TimToady> I really hope I'm not going to have to invent a new word for "namespace" because parrot made it only mean "package"...

[15:37] <frettled> Metaspace :=)

[15:37] <jnthn> TimToady: Maybe I need a type Package that we use in Rakudo for everything rather than Parrot's NameSpace type. ;-)

[15:37] <TimToady> anything with a Hash-like api is a kind of namespace

[15:38] <TimToady> so maybe Association :)

[15:38] <frettled> jnthn: PackageSpace

[15:38] <jnthn> ;-)

[15:38] <TimToady> I mean Association for Namespace, not for rakudo packages

[15:39] <jnthn> TimToady: fwiw, Parrot also calls its captures call signatures.

[15:39] <jnthn> TimToady: Which is probably a source of great fun for anyone trying to understand the Rakudo binder.

[15:40] <jnthn> TimToady: Thankfully, that confusion hasn't leaked into #perl6-land :-)

[15:40] <tylercurtis> AssociaNamePackative

[15:40] <TimToady> \o/

[15:40] <jnthn> Then we'd just never talk about them because it's too much effort to type. :-)

[15:41] * jnthn afk for a little bit

[15:41] <tylercurtis> jnthn: Good point. 

[15:45] <tylercurtis> phenny: tell masak I have an idea(thanks to jnthn++) for fixing your complaints about people's discussions about DateTime/Temporal on p6l. Rename DateTime to DaTimporYeaMonthSecDayHourMinal. No one will ever talk about it again because it's too much effort to type. 

[15:45] <phenny> tylercurtis: I'll pass that on when masak is around.

[15:46] <frettled> :)

[15:51] *** PZt left
[15:57] *** cjk101010 left
[16:07] *** IllvilJa joined
[16:11] *** justatheory joined
[16:13] *** rv2733 joined
[16:14] *** gbacon joined
[16:19] *** xinming_ is now known as xinming

[16:22] *** masak joined
[16:22] <masak> oh hai, #perl6!

[16:22] <phenny> masak: 15:45Z <tylercurtis> tell masak I have an idea(thanks to jnthn++) for fixing your complaints about people's discussions about DateTime/Temporal on p6l. Rename DateTime to DaTimporYeaMonthSecDayHourMinal. No one will ever talk about it again because it's too much effort to type. 

[16:22] <masak> tylercurtis: I like the way you're thinking.

[16:24] *** xabbu42 joined
[16:25] *** rgrau___ left
[16:26] <TiMBuS> jnthn, i saw you fixed up wrap. an even more fixed fix is to change !wrap_clholder_helper so it handles .CONTROL_RETURN instead of return type '58', so nextsame and nextwith also work..

[16:27] <masak> actually, I'm not really too grumpy about people talking about DateTime et al. it's when they propose new levels of abstraction without regard for simple use cases, and without writing Actual Code to back up their theories that I get a bit testy.

[16:34] <jnthn> TiMBuS: I only half fixed up wrap. :-)

[16:34] <jnthn> TiMBuS: Yes, that may well be sane. Thanks. :-)

[16:34] <jnthn> o/ masak

[16:37] <masak> jnthn: \o

[16:38] <masak> today I will fix one half of the Buf/IO trouble, and draft up my 10th anniversary blog post for y'all to read.

[16:38] <TiMBuS> yay i helped! \:3/

[16:43] <TiMBuS> while im in routine.pir, would make more sense to make .assuming clone the current sub, then change $!do to the assuming_helper, so as to hide the ugly 'assuming_helper' name when it gets printed in the repl?

[16:45] <jnthn> TiMBuS: That could well work. Feel free to try. ;-)

[16:45] * jnthn -> nomshop

[16:46] <masak> ingy: nice refactor. MAIN looks really neat now.

[16:54] *** Mowah joined
[16:59] <masak> nom &

[16:59] *** masak left
[17:10] <TimToady> rakudo: say ^10 X~ (^10 X~ ^10)

[17:10] <p6eval> rakudo dd8d5d:  ( no output )

[17:10] <TimToady> "cannot resume dead coroutine"

[17:11] *** jferrero left
[17:11] *** PZt joined
[17:13] *** cjk101010 joined
[17:17] *** timbunce left
[17:19] <TimToady> rakudo: say [X~] ['a'..'z'] xx 2

[17:19] <p6eval> rakudo dd8d5d: OUTPUT«aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz ca cb cc cd ce cf cg ch ci cj ck cl cm cn co cp cq cr cs ct cu cv cw cx cy cz da db dc dd de df dg dh di dj dk dl dm dn

[17:19] <p6eval> ..do dp …

[17:19] <TimToady> doesn't work for 3 though

[17:21] *** PZt left
[17:23] <TimToady> rakudo: say [X~] [0..9, 'a'..'f'] xx 2

[17:23] <p6eval> rakudo dd8d5d: OUTPUT«00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a 5b

[17:23] <p6eval> ..5c 5d …

[17:26] *** jferrero joined
[17:41] <sorear> TimToady: If List doesn't enforce any context, how does it differ from Parcel?

[17:41] <sorear> 09:53 <@TimToady> most augments will execute a null statement list at DO time

[17:41] <sorear> TimToady: exactly.

[17:41] <sorear> TimToady: what I've done is to ban augments which require non-null DO-time code

[17:48] *** envi^home left
[18:00] *** am0c joined
[18:03] *** PZt joined
[18:06] *** hercynium left
[18:13] *** Mowah left
[18:14] *** molaf joined
[18:20] *** ashleydev joined
[18:21] *** payload left
[18:24] *** timbunce joined
[18:24] *** timbunce left
[18:26] <diakopter> sorear: there is a bug that prevents the full --aot of all dlls that come with mono, but I see you worked around it nicely; good job

[18:28] <TimToady> sorear: Lists are mutable, Parcels are not

[18:28] <TimToady> if you don't allow DO code in what is essentially a package block, it's not really Perl 6

[18:29] <TimToady> Lists are mutable containers for a sequence of immutable iterator cursors

[18:34] <sorear> you mean, like, .shift?

[18:36] <sorear> loop { class A { method b { 0 }; }; if rand < 1/3 { my $x = rand; augment class A { method b { 1 + $x }; }; }; if rand < 1/3 { my $x = rand; augment class A { method b { 2 + $x }; }; }; say A.new.b }  # What is the distribution of this?

[18:39] *** Trashlord left
[18:41] *** Alias left
[18:41] *** Trashlord joined
[18:41] *** Alias joined
[18:41] *** justatheory left
[18:42] <ingy> greetings

[18:42] <sorear> hello.

[18:42] <ingy> hi sorear 

[18:42] * sorear pings TimToady

[18:44] <TimToady> the augments always happen regardless of their run-time context, so you only end up with the final method b (or augment carps about the collision because you didn't supersede the method)

[18:45] <TimToady> the augments happen at compile time

[18:46] <TimToady> only that final $x cares about its run-time context

[18:46] *** masak joined
[18:48] *** cjk101010 left
[19:01] <TimToady> and since the method declaration is really taking the closure at compile time and poking it into the meta-object, I'd say even $x is bound only to the protopad, and is always undefined in this example

[19:02] <TimToady> to do anything else at run time requires playing directly with the meta object

[19:02] *** jedai_ left
[19:03] *** rv2733 left
[19:06] <TimToady> declarative syntax is supposed to act declarative, and I don't see cloning of method bodies as important enough to shove a bunch of semantics into the run-time, with possible adverse effects on optimizability

[19:07] <TimToady> lunch &

[19:11] *** Trashlord left
[19:16] *** Trashlord joined
[19:23] *** pmurias joined
[19:26] *** dju_ left
[19:26] *** dju_ joined
[19:29] *** cjk101010 joined
[19:34] *** ashleydev left
[19:34] *** synth joined
[19:37] *** masonkramer joined
[19:52] *** Mowah joined
[19:54] *** cjk101010 left
[20:11] *** pmurias left
[20:22] *** molaf left
[20:43] <masak> I have an anniversary blog post draft for tomorrow about 3/4-ready. anyone want to read it and comment?

[20:47] <tylercurtis> masak: if you'll read and comment a draft of a request for people to get involved with Parrot by helping with updating the Squaak tutorial, I will. :)

[20:47] <masak> tylercurtis: I will.

[20:47] <masak> URL?

[20:47] <tylercurtis> masak: http://perlmonks.org/?viewmode=public;node_id=846756

[20:47] * masak reads

[20:48] <tylercurtis> masak: URL to yours?

[20:48] <masak> hey; I can't both proof-read yours and make a gist of mine. :)

[20:48] <masak> hold on. :)

[20:49] <masak> tylercurtis: http://gist.github.com/479846

[20:49] <ingy> hi masak 

[20:50] <masak> ingy: hi!

[20:50] <masak> tylercurtis: ss/The Squaak tutorial is a tutorial for creating/The Squaak tutorial aims to create/

[20:50] <ingy> masak: i saw u saw etc. good stuff.

[20:51] <masak> oh wait. that doesn't work with the later stuff in the sentence.

[20:51] <masak> tylercurtis: what I wanted to do was avoid the repetition of 'tutorial'.

[20:52] <ingy> is there a 'seen' bot here?

[20:52] <masak> tylercurtis: s/PGE(/PGE (/

[20:52] <masak> ingy: buubot. but it doesn't work so well.

[20:52] <masak> buubot: seen ingy

[20:52] <buubot> masak: I don't think I've seen ingy.      

[20:52] <masak> see? :)

[20:52] <ingy> heh

[20:53] <ingy> buubot: seen yourself lately?

[20:53] <buubot> ingy: I don't think I've seen yourself.      

[20:53] <masak> tylercurtis: hm, generally, add a space before '('

[20:53] <ingy> buubot: seen myself lately?

[20:53] <buubot> ingy: I don't think I've seen myself.      

[20:54] <masak> ingy: you were here during the Pugs days. I'd be happy to hear your comments on my characterization of them, gist'd above.

[20:55] <masak> I've also pinged @audreyt and @orwant on Twitter. both are kinda Twitter tortoises, so it's not clear they will have time to react before I go live tomorrow.

[20:56] <masak> tylercurtis: "it would be much better if someone can" -> "...could"

[20:56] <masak> tylercurtis: otherwise; looks good!

[21:00] *** aubreyja joined
[21:02] <jnthn> masak: explanation</a>,

[21:02] <jnthn> comma not needed

[21:02] <jnthn> (in first paragraph)

[21:02] * masak fixes

[21:02] <masak> ah. it was a fossil. thanks.

[21:03] <tylercurtis> masak: I don't really know anything about the historical information of it, only recently becoming at all involved with Parrot or Perl 6, but it seems to have your usual wonderful mixture of entertainment and information. Also, s/Exigeses/Exegeses/, I think, and chromatic msged you via purl in #parrot with the same correction, so I'm probably right. :)

[21:03] <masak> right, "Exegeses". thanks.

[21:04] <masak> does chromatic have a spy bot in this channel? :)

[21:07] <jnthn> masak: "dynamickest" :-D

[21:07] <masak> jnthn: might lose that one in a subsequent review :P

[21:08] <jnthn> masak: It's cute. "most dynamic" is correct. "dynamicest" looks righter and wronger at the same time... :-)

[21:08] <masak> somehow true to the Perl 6 lingo/terminology. :)

[21:08] <masak> it's also a bit of an autopun.

[21:09] <jnthn> frightingly => frighteningly

[21:10] <masak> fixed, thanks.

[21:11] <ingy> rakudo: sub xxx() { say $_ }; xxx 'O HAI'

[21:11] <p6eval> rakudo dd8d5d: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in 'xxx' at line 20:/tmp/Lt8E0GV653␤  in main program body at line 20:/tmp/Lt8E0GV653␤»

[21:11] <ingy> rakudo: sub xxx($s) { say $s }; xxx 'O HAI'

[21:11] <p6eval> rakudo dd8d5d: OUTPUT«O HAI␤»

[21:11] <ingy> sweet

[21:11] <ingy> XXX.pm forthcoming

[21:11] <tadzik> see your data in nude?

[21:12] <ingy> bareword_functions++

[21:12] <ingy> tadzik: :D

[21:12] <tadzik> yeah, that's your thing :)

[21:12] *** M_o_C joined
[21:13] <masak> "warning: must be above $some-age to see the data!"

[21:13] <jnthn> masak: Looks good

[21:13] <jnthn> masak: I guess more to come?

[21:13] <masak> jnthn: yes. writing Rakudo section now.

[21:13] <ingy> tadzik: http://github.com/ingydotnet/xxx-pm6 -- See Your Perl 6 Data in the Nude

[21:14] <tadzik> coming! :)

[21:14] <masak> jnthn: Rakudo history is harder to get a grip on, because I'm not outside of it as with Pugs...

[21:14] <ingy> putting yaml-pm6 t good use.

[21:14] <ingy> *to

[21:15] * ingy <3 pugs

[21:27] *** literal left
[21:28] <tylercurtis> masak: I'm replacing "The Squaak tutorial" with "Squaak" in the sentence you mentioned and correcting the other things you mentioned. I'm probably not going to wait and get more feedback (unless anything wants to read it over right now and provide feedback) given the time-sensitivity of it, so thanks a lot for looking at it. :)

[21:28] <masak> tylercurtis: you're welcome. thanks for looking at my draft.

[21:29] *** gbacon left
[21:32] <ingy> is there a p6 equiv of Carp::confess?

[21:32] <masak> dying with stacktrace is the default.

[21:33] <ingy> masak: oh right. is there a terse die?

[21:33] <masak> not that I know :/

[21:34] <masak> all that seems clear is that the `die "error message\n"` pattern is below the standards of Perl 6.

[21:34] <masak> so something else is needed.

[21:34] <ingy> masak: warn "error"; exit 1;

[21:34] <ingy> warn gives a line #

[21:34] <masak> note "error";

[21:34] <masak> exit 1;

[21:35] <ingy> what is note?

[21:35] <masak> &warn throws an exception which can be caught.

[21:35] <masak> &note doesn't.

[21:35] <ingy> k

[21:35] <ingy> so note is a print to stderr?

[21:35] <masak> in other words, $*OUT:$*ERR::say:note

[21:36] <masak> ingy: what masak said.

[21:36] <ingy> masak: I never understand masak. Please explain what he said.

[21:37] <masak> ingy: a:b::c:d is a nifty syntax meaning "a is to b as c is to d".

[21:37] <masak> masak can't help it; he likes to speak in terse riddle-like utterances. :)

[21:38] <masak> if it's any consolation, sometimes I don't understand him either...

[21:38] <ingy> :)

[21:38] <ingy> so one difference

[21:38] <ingy> warn prints a line number

[21:38] <ingy> note don't

[21:39] <masak> and warn gets caught in CATCH nets. note doesn't.

[21:39] <masak> trust me, that's the important difference :)

[21:39] <tylercurtis> rakudo: note 'foo $?LINE';

[21:39] <p6eval> rakudo dd8d5d: OUTPUT«foo $?LINE␤»

[21:39] <tylercurtis> rakudo: note "foo $?LINE";

[21:40] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Symbol '$?LINE' not predeclared in <anonymous> (/tmp/69HeMARcsQ:20)␤»

[21:40] <ingy> :P

[21:41] <masak> tylercurtis: NYI

[21:41] <ingy> rakudo: sub foo {␤say $?LINE;␤}␤foo;

[21:41] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Symbol '$?LINE' not predeclared in foo (/tmp/nupulGIw0c:21)␤»

[21:42] <ingy> rakudo: sub foo {␤say $*LINE;␤}␤foo;

[21:42] <p6eval> rakudo dd8d5d:  ( no output )

[21:42] <tylercurtis> Anyone want to provide some last-minute feedback on http://perlmonks.org/?viewmode=public;node_id=846756 before I post it?

[21:43] <ingy> rakudo: warn 1; say 2;

[21:43] <p6eval> rakudo dd8d5d: OUTPUT«1 at line 20:/tmp/O2TOCh0zHA␤2␤»

[21:43] *** literal joined
[21:43] <tylercurtis> rakudo: warn 1; say 2; CATCH { note 'Nope, you don't get to say.'; }

[21:43] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 20␤»

[21:44] <tylercurtis> rakudo: warn 1; say 2; CATCH { note 'Nope, you don\'t get to say.'; }

[21:44] <p6eval> rakudo dd8d5d: OUTPUT«Nope, you don't get to say.␤»

[21:44] <sbp> .gc +blockoid

[21:44] <phenny> +blockoid: 211

[21:46] <sbp> does everybody in #perl6 have a keybinding for U+2424? :-)

[21:46] <tylercurtis> .u 2424

[21:46] <phenny> U+2424 SYMBOL FOR NEWLINE (␤)

[21:47] * tylercurtis doesn't.

[21:48] <ingy> I thought Test.pm has a use_ok

[21:49] <ingy> rakudo: use Test; BEGIN { plan 1 }; ok 'foo';

[21:49] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Could not find sub &plan␤»

[21:49] <ingy> what's up with that?

[21:49] <ingy> rakudo: use Test; plan 1; ok 'foo';

[21:50] <p6eval> rakudo dd8d5d: OUTPUT«1..1␤ok 1 - ␤»

[21:50] <ingy> I guess BEGIN scope does not share with its outer scope?

[21:50] <ingy> actually

[21:50] <tylercurtis> rakudo might not do need/import at BEGIN time properly.

[21:50] <ingy> rakudo: use Test; BEGIN { Test::plan(1) }; ok 'foo';

[21:50] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Can not find sub Test::plan␤»

[21:51] <ingy> :'(

[21:52] <ingy> If I'm testing whether a module loads, I want to run my plan first

[21:52] <ingy> I guess I'll have to string eval the use

[21:52] <ingy> how do I know if a string eval failed?

[21:52] *** xinming left
[21:52] <tylercurtis> rakudo: BEGIN { use Test;  plan(1); }; ok 'foo';

[21:53] <p6eval> rakudo dd8d5d: OUTPUT«1..1␤Could not find sub &ok␤  in main program body at line 20:/tmp/rNNnHuNq7W␤»

[21:53] <tylercurtis> rakudo: use Test; BEGIN { use Test;  plan(1); }; ok 'foo';

[21:53] <p6eval> rakudo dd8d5d: OUTPUT«1..1␤ok 1 - ␤»

[21:53] <ingy> rakudo: use Test; plan 1; use Bad; ok 'Bad is ok'

[21:53] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Unable to find module 'Bad' in the @*INC directories.␤(@*INC contains:␤  lib␤  /home/p6eval/.perl6/lib␤  /home/p6eval//p1/lib/parrot/2.5.0-devel/languages/perl6/lib␤  .)␤»

[21:53] <ingy> tylercurtis: nice

[21:54] <tylercurtis> rakudo: use Test; plan 1; lives_ok { use Bad; }, 'Bad is ok.';

[21:54] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Unable to find module 'Bad' in the @*INC directories.␤(@*INC contains:␤  lib␤  /home/p6eval/.perl6/lib␤  /home/p6eval//p1/lib/parrot/2.5.0-devel/languages/perl6/lib␤  .)␤»

[21:54] <ingy> rakudo: use Test; BEGIN { use Test; plan 1 }; use Bad; ok 'Bad is ok'

[21:54] <p6eval> rakudo dd8d5d: OUTPUT«1..1␤===SORRY!===␤Unable to find module 'Bad' in the @*INC directories.␤(@*INC contains:␤  lib␤  /home/p6eval/.perl6/lib␤  /home/p6eval//p1/lib/parrot/2.5.0-devel/languages/perl6/lib␤  .)␤»

[21:54] <ingy> tylercurtis: that executes 'use' too early

[21:55] <tylercurtis> rakudo: use Test; plan 1; lives_ok "use Bad; ", 'Bad is ok.';

[21:55] <p6eval> rakudo dd8d5d: OUTPUT«1..1␤not ok 1 - Bad is ok.␤# Looks like you failed 1 tests of 1␤»

[21:55] <ingy> that's nice

[21:55] <ingy> what is lives_ok?

[21:55] <tylercurtis> rakudo: use Test; plan 1; eval_lives_ok "use Bad; ", 'Bad is ok.';

[21:56] <p6eval> rakudo dd8d5d: OUTPUT«1..1␤not ok 1 - Bad is ok.␤# Looks like you failed 1 tests of 1␤»

[21:58] <tylercurtis> ingy: you want eval_lives_ok. lives_ok is for closures.

[21:58] <ingy> rakudo: use Test; plan 1; eval_lives_ok "use Test; ", 'Test is ok.';

[21:58] <p6eval> rakudo dd8d5d: OUTPUT«1..1␤ok 1 - Test is ok.␤»

[21:58] <ingy> rakudo: use Test; plan 1; lives_ok "use Test; ", 'Test is ok.';

[21:58] <p6eval> rakudo dd8d5d: OUTPUT«1..1␤not ok 1 - Test is ok.␤# Looks like you failed 1 tests of 1␤»

[21:59] <tylercurtis> If you do lives_ok "some str", it does 'try { "some str"(); }', which will never live unless someone adds a postcircumfix:<( )> to Str (please don't, someone).

[22:01] <masak> jnthn: Rakudo part written. http://gist.github.com/479846

[22:05] <ingy> XXX.pm is alive, and waiting to die for you! http://github.com/ingydotnet/xxx-pm6/blob/master/lib/XXX.pm

[22:05] <tylercurtis> http://perlmonks.org/?node_id=850115 posted it on perlmonks.

[22:06] <masak> ingy: nice.

[22:07] <masak> ingy: feedback: I didn't knwo about XXX on CPAN before now. maybe provide a bit more information in the README? :)

[22:10] <sorear> ingy: Rakudo has a bit of batch-compiler nature currently and runs all BEGIN blocks before submitting the rest of the program to the interpreter

[22:10] <sorear> ingy: so BEGIN can't see anything outside it

[22:12] <ingy> masak: done and attributed :)

[22:12] *** tadzik left
[22:12] <ingy> sorear: is that a Rakudo bug?

[22:13] <ingy> Perl 5 is the same, but use statements count as BEGIN blocks

[22:13] <masak> ingy: nice.

[22:14] <masak> ingy: if you like the listop form better, why do you use the parens in the README?

[22:14] *** ive joined
[22:14] <ingy> masak: listop wasn't working for me :)

[22:15] <ingy> maybe I goofed it up

[22:15] <sorear> perl6: sub foo () { say "Hi" }; BEGIN { foo }

[22:15] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Could not find sub &foo␤»

[22:15] <p6eval> ..pugs: OUTPUT«Hi␤»

[22:15] <sorear> (yes)

[22:15] <jnthn> masak: reading :-)

[22:16] <sorear> BEGIN blocks in Rakudo can't even see each other, because the scope they are mutually embedded in is created at CHECK time

[22:16] *** ive left
[22:16] <sorear> real Perl 6 is supposed to build scopes at BEGIN time

[22:16] <sorear> pugs is much closer to the spec on this part

[22:17] <jnthn> It's kinda easier to get right if you're interpreting rather than compiling with the expectation of running the compiled output later.

[22:17] <ingy> masak: I think I know... maybe

[22:18] <ingy> rakudo: sub XXX($s) { say $s.perl }; my @x = (1,2); XXX @x;

[22:18] <p6eval> rakudo dd8d5d: OUTPUT«[1, 2]␤»

[22:18] <ingy> hmm

[22:19] <ingy> maybe export messes with listop?

[22:19] *** clintongormley left
[22:19] <ingy> masak: can you try installing XXX and listopping?

[22:19] <masak> ingy: sure thing.

[22:21] <jnthn> masak: looks nice

[22:21] <jnthn> masak: They story about how I got sucked in is not quite accurate though. :-)

[22:22] <masak> jnthn: please give a correct version :)

[22:22] <jnthn> masak: It was actually junctions I promised to implement. It wasn't until I set about trying to do that task that I realized that junctions needed multi-dispatch to do properly, multi dispatch needed the type system, and that involves doing a bunch of the work on OO first. 

[22:22] <jnthn> masak: It was a kind of dependency explosion. :-)

[22:22] <masak> hah :)

[22:23] <masak> I'll try to express that somehow.

[22:23] <masak> I also want to add more examples of Perl 6 culture during the silver age.

[22:23] <masak> if anyone has a memorable snippet from the IRC logs from the past two-three years, I'd be happy to hear about it.

[22:24] * masak greps the logs for "lol" :)

[22:24] <jnthn> .oO( grep irclog 'masak submits rakudo bug' | wc -l )

[22:24] *** justatheory joined
[22:25] <masak> jnthn: I'm up to about 900, I think.

[22:26] <tylercurtis> masak: is that for this month or this week?

[22:26] <masak> tylercurtis: :P

[22:29] *** gbacon joined
[22:31] *** M_o_C left
[22:33] <ingy> how do I count the number of newlines in a string?

[22:35] <jnthn> +$str.comb("\n")

[22:36] <ingy> thx

[22:39] *** rv2733 joined
[22:39] <masak> ooh, that's cute.

[22:41] *** gbacon left
[22:43] <ingy> hey, I just found a problem in my parser that only happens when a keyword begins with a 't'

[22:43] <ingy> actually all leading 't's are ignored

[22:43] <ingy> sound familiar?

[22:43] <masak> no.

[22:43] <sorear> yes.

[22:43] <masak> ingy: golf and evalbot, please?

[22:43] <ingy> my rakudo's a few days old

[22:44] <masak> well, we had that with Q.

[22:44] <masak> but not t.

[22:44] *** whiteknight joined
[22:45] <ingy> rakudo: say "testml".match(/[a-z][a-zA-Z]*/).perl

[22:45] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 20␤»

[22:45] <ingy> ?

[22:45] <masak> std: say "testml".match(/[a-z][a-zA-Z]*/).perl

[22:45] <p6eval> std 31740: OUTPUT«[31m===[0mSORRY![31m===[0m␤Invalid regex metacharacter (must be quoted to match literally) at /tmp/4doHEfMysP line 1:␤------> [32msay "testml".match(/[a-[33m⏏[31mz][a-zA-Z]*/).perl[0m␤Invalid regex metacharacter (must be quoted to match literally) at /tmp/4doHEfMysP line

[22:45] <p6eval> ..1:…

[22:45] <ingy> oh

[22:46] <ingy> rakudo: say "testml".match(/<[a-z]><[a-zA-Z]>*/).perl

[22:46] <p6eval> rakudo dd8d5d: OUTPUT«===SORRY!===␤Obsolete use of hyphen in enumerated character class;in Perl 6 please use .. instead at line 20, near "z]><[a-zA-"␤»

[22:46] <masak> ingy: when Rakudo gets confused, try feeding through STD. :)

[22:46] <ingy> rakudo: say "testml".match(/<[a..z]><[a..zA..Z]>*/).perl

[22:47] <p6eval> rakudo dd8d5d: OUTPUT«Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ from => 0,␤ orig => "testml",␤ to   => 6,␤)␤»

[22:47] <masak> there you go.

[22:47] <masak> expected result.

[22:47] * ingy upgrades...

[22:47] <ingy> bbl

[22:52] *** zorgnax joined
[22:53] *** eternaleye joined
[22:53] <lue> ohai o/

[22:56] <sorear> TimToady: After my $c = class { our $x = 42 };  is $x accessible in any way?

[22:59] *** whiteknight left
[23:10] <jnthn> sorear: It'd guess C.WHO<$x> or some such

[23:10] <jnthn> er

[23:10] <jnthn> $c.WHO<$x>

[23:20] *** whiteknight joined
[23:25] <masak> yay, audreyt proof-reads my draft \o/

[23:35] *** am0c left
[23:36] *** synth] joined
[23:38] *** synth left
[23:47] *** au|irc joined
[23:48] <au|irc> masak: tiny grammar nit: s/Pugs still existed/Pugs still exists/

[23:48] <au|irc> but otherwise very accurate and personal and authentic and nice :)

[23:48] <masak> au|irc: got it. fixing.

[23:48] <masak> oh, and while I have you on the line... :)

[23:48] <masak> hugme: hug au|irc

[23:48] * hugme hugs au|irc

[23:48] <au|irc> :)

[23:49] <au|irc> hugme: hug hugme

[23:49] * hugme hugs hugme

[23:49] <masak> au|irc: thank you for Pugs. it was a blast.

[23:49] * sorear hugs au|irc

[23:50] <au|irc> masak: np at all. and thank y'all for being there :)

[23:50] <masak> hm, I cannot just change it to "Pugs still exists" since I'm writing in past tense. would "Pugs was (and is) still around" work?

[23:50] <au|irc> sure

[23:51] * masak fixes

[23:51] <masak> ideally, I'd like to run this through pmichaud++ as well. but I'm not sure it's worth disturbing him on his vacation.

[23:51] <au|irc> masak: and I'd like to translate that announcement to chinese, as I did for pmichaud's reply-to-an-anonymouse-monk

[23:51] <au|irc> if you're ok with it, that is

[23:52] <masak> au|irc: that'd be awesome.

[23:52] <masak> I will try to read it, and it'll take days. :)

[23:52] <au|irc> maybe I'll make it extra difficult for you by translating fragments from "Larry is a Mariner" too

[23:52] <au|irc> and interleaving the prose with the poetry :-)

[23:52] * sorear cannot fathom how pugs could be blamed for Perl 6 being late

[23:53] <au|irc> it's more of a community dynamics thing... the haskell community didn't get cabal going until 2 years later

[23:53] <sorear> doesn't not having a wroking implementation make things take /longer/?

[23:53] <masak> au|irc: 现在我说一点儿中文 :)

[23:53] <au|irc> and a hs without cabal is like perl4 without cpan

[23:53] *** whiteknight left
[23:53] <au|irc> it didn't quite make modular collaboration easy

[23:53] <sorear> mm

[23:54] <sorear> I was there-ish when cabal was coming up

[23:54] <masak> without Pugs, Perl 6 might have been an abandoned effort by now.

[23:54] <sorear> I was one of the old guard, very annoyed that Haskell was trying to turn into the next Java :D

[23:54] <au|irc> you were! I remember hacking hacked with SyntaxNinja on the very first version of cabal-install

[23:55] <sorear> mm. memories.

[23:55] <masak> wait, you two know each other? that explains a lot. :P

[23:55] <sorear> funny how long 3 years can seem

[23:55] <au|irc> it's internet time :)

[23:55] <sorear> masak: 2007-2008 #1 active human on #haskell

[23:55] <masak> yipes.

[23:56] <sorear> I didn't really care much about Perl back then.

[23:56] <sorear> 4, 5, or 6

[23:56] *** Psyche^ joined
[23:57] <au|irc> so haskell didn't turn into another java, and lambdacamels became λӝ... it all works out!

[23:57] <masak> \ӝ/

[23:57] *** meppl left
