[00:00] <TimToady> sorear: almost according to spec, except they don't limit the upward search to the purview of the proto

[00:00] <TimToady> that is, it assumes no nested protos currently

[00:01] <sorear> er

[00:01] <sorear> by now I mean, how should they work, now that non-regex protos contain a dispatcher

[00:01] <sorear> { <...> } is almost certainly wrong

[00:01] <TimToady> turns out {*} is available :)

[00:02] <TimToady> and even if it weren't, {{*}} is

[00:02] <TimToady> which was another reason for wanting *

[00:03] <TimToady> though I suppose, strictly speaking {{*}} would cause the proto not to participate in an outer alternative

[00:03] <TimToady> since {} terminates LTM

[00:04] <stef__> What is the current  state of := in rakudo?  

[00:05] *** stef__ left
[00:05] *** lest_away is now known as lestrrat

[00:07] <TimToady> I suppose [*] could be special too

[00:09] <cognominal> sorry, stef__,  that was me on my iPhone, Getting back home t charge it.

[00:10] <ingy> rakudo: module TestML::Standard { our sub Point { say 42 } }; my $pkg = "TestML::Standard"; my $name = "Point"; my $fun = eval "&$pkg" ~ "::$name"; $fun.()

[00:10] <p6eval> rakudo c80319: OUTPUTÂ«42â¤Â»

[00:10] *** fozo left
[00:11] <ingy> what does 'our sub ...' mean?

[00:12] <cognominal> ingy, by default, the scope of subs and methods is lexical

[00:12] <cognominal> ...if my memory serves me well

[00:12] <jnthn> Right

[00:12] <diakopter> what's this about Rust

[00:12] <jnthn> ingy: the default would be my sub ...

[00:13] <jnthn> ingy: our means it goes in the package too

[00:13] <pugssvn> r31584 | lwall++ | [S05] also define how * does multi dispatch inside regexes 

[00:13] <pugssvn> r31584 | delete <...> et al. since they're redundant with {...}

[00:15] *** solarion left
[00:15] *** solarion joined
[00:15] <TimToady> bbl &/e

[00:18] <lue> rakudo: say Num.^methods(:local)

[00:18] <p6eval> rakudo c80319: OUTPUTÂ«to-radiansabsacotanacosechlnceilingcotanhunpolarRealatanacosRattanhatanhcosecNumWHICHperlrootslog10from-radianstancospredacosecsinhasinhNumericcosechrealsStrasecacotanhfloorACCEPTSsechasechtruncateroundsqrtasinBoolexpcoshsuccacoshsigncotanatan2ComplexseccislogsinIntBridgeâ¤Â»

[00:18] <lue> rakudo: say Num.^methods(:local).perl

[00:18] <p6eval> rakudo c80319: OUTPUTÂ«[{ ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ...

[00:18] <p6eval> ..}, { â€¦

[00:18] <lue> rakudo: say @(Num.^methods(:local))

[00:18] <p6eval> rakudo c80319: OUTPUTÂ«realsStrasecacotanhfloorACCEPTSsechasechtruncateroundsqrtasinBoolexpcoshacoshsuccsigncotanatan2ComplexseccislogsinIntBridgeto-radiansabsacosechacotanlnceilingcotanhunpolaratanRealacosRattanhatanhcosecNumperlWHICHrootstanfrom-radianslog10cospredacosecsinhNumericasinhcosechâ¤Â»

[00:19] <ingy> jnthn, cognominal: thx

[00:20] <ingy> wouldn't this expect 2 args: our sub Point ($this, $name) {

[00:20] <ingy> ?

[00:21] <ingy> I get: too many positional arguments: 2 passed, 1 expected

[00:21] <ingy> hmm

[00:22] <lue> rakudo: say floor(3.5);

[00:22] <p6eval> rakudo c80319: OUTPUTÂ«3â¤Â»

[00:22] <jnthn> rakudo: our sub Point ($this, $name) { }; Point(1,2)

[00:22] <p6eval> rakudo c80319:  ( no output )

[00:22] <jnthn> rakudo: our sub Point ($this, $name) { }; Point(1)

[00:22] <p6eval> rakudo c80319: OUTPUTÂ«Not enough positional parameters passed; got 1 but expected 2â¤  in 'Point' at line 11:/tmp/lNaC11bvoqâ¤  in main program body at line 11:/tmp/lNaC11bvoqâ¤Â»

[00:22] <jnthn> ingy: Suspect there's more to the story :-)

[00:23] <ingy> nm, my bad

[00:23] <ingy> sorry

[00:23] <jnthn> np 

[00:23] <ingy> it was another call within that call.

[00:23] <ingy> I better take a break

[00:23] * ingy heads to the beach

[00:23] * ingy is your beach

[00:24] <jnthn> enjoy the beach, you beach!

[00:24] <jnthn> EMYBEACHNOTWALKINGDISTANCE

[00:24] <lue> EBEACHHOURSAWAYBYCAR

[00:25] * lue is somewhat shocked there's no integer division. I guess that's what floor() is for :)

[00:31] <lue> rakudo: say (0x3FFE - 8*(floor(0x3FFE/8)-0x400)).fmt('%x')

[00:31] <p6eval> rakudo c80319: OUTPUTÂ«2006â¤Â»

[00:33] <lue> I kinda wish implicit multiplication existed....

[00:35] <lue> rakudo: multi sub postcircumfix:<( )>($a, $b) { $a * $b }; say 3(5);

[00:35] <p6eval> rakudo c80319: OUTPUTÂ«invoke() not implemented in class 'Integer'â¤  in main program body at line 11:/tmp/co3SNwFyKNâ¤Â»

[00:36] <lue> rakudo: multi sub postcircumfix:<~ ~>($a, $b) { $a * $b }; say 3~5~;

[00:36] <p6eval> rakudo c80319: OUTPUTÂ«error:imcc:syntax error, unexpected '\n'â¤  in file 'EVAL_1' line 58â¤===SORRY!===â¤syntax error ... somewhereâ¤Â»

[00:38] *** meppl left
[00:40] <lue> How would you remove a binding? in $b := $a, how would you turn $b into its own variable again?

[00:51] <lue> *chirp chrip*

[00:52] <sorear> At what point does /kick become acceptable in responce to that?

[00:53] *** quietfanatic left
[00:54] * lue stops

[00:54] *** am0c left
[00:59] <[Coke]> sorear: you appear awfully grumpy.

[01:00] <sorear> tired.

[01:02] * jnthn knows the tiredness/grumpiness correlation

[01:02] <lue> afk

[01:12] *** s1n joined
[01:19] *** kid51 left
[01:20] <sorear> TimToady: what is the <>-canonical form of circumfix:[' ', ' ']?

[01:22] <jnthn> lol...<   > :-)

[01:22] <jnthn> (logically...)

[01:22] <sorear> jnthn: but it's ambiguous

[01:23] <jnthn> Yeah

[01:23] <jnthn> sorear: I'm curious - what would declaring such a circumfix do to the parse?

[01:23] <sorear> jnthn: nothing

[01:23] <jnthn> Would it actually somehow actually fall out and work?

[01:23] <jnthn> gah

[01:23] <jnthn> s:2nd/actually//

[01:24] <sorear> it would never match, because <ws> prevents the cursor from ever pointing at a space when term comes up

[01:24] <jnthn> Right, I imagined so.

[01:24] <jnthn> Somebody will try it of course. :-)

[01:25] <sorear> one problem with using unmodified STD is that I'm limited to a postorder traversal

[01:26] <sorear> in class Foo { is; method; has } I have to consider the insides before ever seeing that I'm in a class

[01:27] <sorear> I'm not quite sure how I'll make this work with BEGIN

[01:27] <jnthn> eww

[01:27] <jnthn> In Rakudo we're able to run some action before the {

[01:27] <jnthn> Well, same action method but with a "tag"

[01:27] <jnthn> "open" or some such

[01:27] <jnthn> That's how it's dealt with there.

[01:27] <jnthn> If STD wants to borrow from Rakudo. ;-)

[01:28] <jnthn> I think the answer is "you need to find a way to do something earlier than the end of the class decl" though

[01:30] *** [Coke] left
[01:30] <pugssvn> r31585 | pmichaud++ | Adjust some tests for binding operator. 

[01:30] <pmichaud> we no longer use "#= open"

[01:31] <pmichaud> and eventually it won't even be possible

[01:31] <jnthn> What do we use?

[01:31] <pmichaud> (we may still use "#= open", but it'll be phased out)

[01:31] <pmichaud> for example, to detect the start of a compilation unit we now have <.unitstart>

[01:31] <jnthn> We *will* need an alternative.

[01:31] <jnthn> Ah

[01:31] <jnthn> That will do. :-)

[01:31] <pmichaud> to detect the start of a new lexpad we have <.newlex>

[01:31] <pmichaud> (these are all from STD.pm)

[01:31] <jnthn> *nod*

[01:31] <jnthn> OK

[01:31] <dalek> rakudo: b30f2a6 | (Matthew (lue))++ | src/ (2 files):

[01:31] <dalek> rakudo: Begin implementation of ::= binding.

[01:31] <dalek> rakudo: Signed-off-by: pmichaud [email@hidden.address]
[01:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b30f2a6808b99d6408b28e5b01fa8c8f60d0260e

[01:31] <dalek> rakudo: c59e59a | (Matthew (lue))++ | src/core/operators.pm:

[01:31] <dalek> rakudo: Removal of Q:PIR block in := implementation.

[01:31] <dalek> rakudo: Signed-off-by: pmichaud [email@hidden.address]
[01:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c59e59a5e6b3079d2c8caf85b2a909cf30f73d14

[01:31] <dalek> rakudo: 669c9cc | (Matthew (lue))++ | src/core/operators.pm:

[01:31] <dalek> rakudo: Implementation of := binding.

[01:31] <dalek> rakudo: Signed-off-by: pmichaud [email@hidden.address]
[01:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/669c9cc132a034d4eb57c83ea7fa9c2009e03edd

[01:31] <dalek> rakudo: a3d4b9e | pmichaud++ | src/core/operators.pm:

[01:31] <jnthn> That works...it's messier, but it works.

[01:31] <dalek> rakudo: Add WHENCE code (originally from lue++, but patch didn't apply for some reason).

[01:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a3d4b9e87a3ced6171c0fa2aad6065ca3189da99

[01:31] <dalek> rakudo: c70469a | pmichaud++ | src/core/operators.pm:

[01:31] <dalek> rakudo: A bound variable needs to adopt the 'rw' state of the thing it's bound to.

[01:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c70469aa5e9c4cbd6a4d3eab7f7195fef2ee5fbc

[01:31] <pmichaud> actually, it's far cleaner

[01:32] <pmichaud> it's *much much* cleaner

[01:32] <pmichaud> because we no longer need  $key

[01:32] <jnthn> Well...in that sense yes

[01:32] <jnthn> Depends how you look at it.

[01:32] <jnthn> lue++

[01:32] <pmichaud> I know that I found <.unitstart> to be much easier to understand and process than trying to deal with the {*} #= key

[01:32] <jnthn> *nod*

[01:32] <jnthn> OK, good to know

[01:32] <jnthn> I can maybe refactor the package_def in that direction.

[01:33] <jnthn> Well, I *can*

[01:33] <jnthn> But I maybe can do it soonish. :-)

[01:34] <pmichaud> look to see what STD does

[01:35] <pmichaud> (and we can always modify STD to do what we need it to do)

[01:35] <jnthn> I don't think it cares

[01:36] <jnthn> Since you can get awya with the syntactic case just by knowing you have a new type name.

[01:36] <pmichaud> well, it cared enough for TimToady to have created <.newlex> and <.unitstart> and the like :-)

[01:36] *** skids joined
[01:36] <jnthn> Yeah, true

[01:36] <pmichaud> STD has to manage a symbol table as well, which means it has to know about the symbols *before* the action methods are applied.

[01:36] <jnthn> If STD gives a name there, I'll happily use the one it suggests.

[01:37] <pmichaud> right. :-)

[01:37] <jnthn> If not, I'll propose one and TimToady++ will dislike it and choose a better one. :-)

[01:37] <pmichaud> another possibility to keep in mind is that at some point we really want to divorce ourselves from Parrot NameSpace PMCs altgoether.

[01:37] <pmichaud> *altogether.

[01:38] <pmichaud> so that our package symbols are just another pad

[01:38] <jnthn> heh

[01:38] <jnthn> That's a cert for objects.

[01:38] <sorear> pmichaud: the trick is though that method newlex is defined in STD...

[01:38] <jnthn> Guess we could go the whole hog.

[01:42] *** plobsing joined
[01:46] *** colomon joined
[01:46] <colomon> o/ from the great white north!

[01:48] <jnthn> o/

[01:48] <colomon> how goes it?

[01:48] <jnthn> colomon: Having fun?

[01:49] <jnthn> colomon: Goes well here.

[01:49] <colomon> amazing amounts of fun here

[01:49] <jnthn> I passed some cert at $dayjob today then went out for nice Thai nom. :-)

[01:49] <colomon> eight hours fishing a day, beautiful lake

[01:49] <colomon> \o/

[01:49] <jnthn> Nice

[01:49] <jnthn> Sounds wonderfully relaxing

[01:50] <jnthn> OTOH, most things that involve being outdoors rather than in front of a computer somehow sound relaxing to me. :-)

[01:50] <colomon> it is amazingly relaxing.

[01:50] <colomon> my most relaxing vacation in years.

[01:50] <jnthn> \o/

[01:50] <jnthn> rakudo: my $a = 10; my $b = '$a'; $b.eval

[01:50] <p6eval> rakudo c80319:  ( no output )

[01:50] <jnthn> rakudo: my $a = 10; my $b = '$a'; say $b.eval

[01:51] <p6eval> rakudo c80319:  ( no output )

[01:51] *** tylercurtis joined
[01:51] <jnthn> tssk, locally 

[01:51] <jnthn> > my $a = 10; my $b = '$a'; say $b.eval

[01:51] <jnthn> Symbol '$a' not predeclared in <anonymous>

[01:51] <colomon> can't spend much time on the internet up here, which is why I had premade messages ready to send.  ;)

[01:51] <jnthn> but

[01:51] <jnthn> > my $a = 10; my $b = '$a'; say eval($b)

[01:51] <jnthn> 10

[01:52] <jnthn> That way works (e.g. sub rathe than method call)

[01:52] <jnthn> It's rakudobug

[01:52] <jnthn> colomon: Well, I can answer that with a quick workaround at least. ;-)

[01:52] <colomon> oh, hey, that's great!

[01:52] <jnthn> And yes, closure bug is fixed.

[01:53] <colomon> is the closur.... \o/

[01:53] <jnthn> pmichaud++

[01:53] <colomon> been driving me nuts up here.

[01:53] <colomon> pmichaud++

[01:53] <colomon> trig test overhaul is almost done.

[01:53] <jnthn> \o.

[01:53] <jnthn> er, \o/

[01:54] <colomon> just working on atan2

[01:54] <colomon> actually have found two bugs in it!

[01:55] <colomon> (that is, atan2 is the last thing to work on)

[01:55] <jnthn> :-)

[01:55] <jnthn> Bugs known are bugs that can be fixed.

[01:55] <colomon> well, the one is kind of extra tricky.

[01:55] <colomon> hope to have the other one soon.

[01:56] <colomon> rakudo: say 10.atan2

[01:56] <p6eval> rakudo c80319: OUTPUTÂ«1.47112767430373â¤Â»

[01:56] <colomon> rakudo: say 10.atan2(Radians) # should be the same answer, as Radians are the default base

[01:56] <p6eval> rakudo c80319: OUTPUTÂ«1.5707963267949â¤Â»

[01:56] <colomon> problem is that our hack for TrigBase turns the bases into integers.

[01:56] <colomon> so that actually looks like

[01:56] <colomon> rakudo: say 10.atan2(0)

[01:57] <p6eval> rakudo c80319: OUTPUTÂ«1.5707963267949â¤Â»

[01:57] <jnthn> Oh!

[01:58] <jnthn> Er, yes, ouch.

[01:59] <colomon> Okay, I've downloaded the latest in Rakudo, and sent my e-mails.  My wife isn't online to chat, so it is time to go.

[01:59] <colomon> I should be back for real on Monday.

[01:59] <colomon> have a great weekend!

[01:59] <jnthn> You too!

[01:59] *** colomon left
[02:02] <pmichaud> mmmmm, Thai nom == yummy

[02:02] <jnthn> It was.

[02:02] <jnthn> Lund isn't a great restaurant town overall.

[02:02] <jnthn> But there is at least a good Thai restaurant here.

[02:04] <pmichaud> yes, I've been spoiled by some great restaurant towns

[02:04] *** ashleydev left
[02:04] *** tedv left
[02:05] <jnthn> I miss Bratislava somewhat. The pub nom was awesome.

[02:05] <jnthn> And it had a decent Indian.

[02:06] <jnthn> Cambridge had some *really* nice places.

[02:08] *** kid51 joined
[02:11] *** jimk joined
[02:13] *** jimk left
[02:14] *** kid51 left
[02:19] *** pragma_ left
[02:24] <jnthn> Sleep, night o/

[02:25] *** takadonet left
[02:29] *** pragma_ joined
[02:29] *** pragma_ is now known as Guest62179

[02:31] *** pnate left
[02:33] <lue> hello!

[02:35] <sorear> Hello

[02:37] *** sftp left
[02:38] *** pnate joined
[02:41] *** [Coke] joined
[02:51] *** TiMBuS joined
[03:03] <pmichaud> rakudo:  my $x = 5;  my $y := $x;  $y = 4;  say $x;   # lue++

[03:03] <p6eval> rakudo c70469: OUTPUTÂ«4â¤Â»

[03:05] <lue> the one thing about := still on my mind is list binding, but that's for a busier time, when more Important Peopleâ„¢ are around :)

[03:05] <pmichaud> at some point it's just easier to use signature binding

[03:06] <pmichaud> ..but I guess you're wanting to bind elements of arrays or something like that

[03:07] <lue> yes. Although using $_ and a for loop works quite well.

[03:07] <lue> rakudo: my @a = 1,2,3; @a[$_+3] := @a[$_] for ^3; say @a.perl

[03:07] <p6eval> rakudo c70469: OUTPUTÂ«[1, 2, 3, 1, 2, 3]â¤Â»

[03:08] <lue> rakudo: my @a; @a[0..2] = 3; say @a.perl

[03:08] <p6eval> rakudo c70469: OUTPUTÂ«[3, Any, Any]â¤Â»

[03:09] <lue> the main problem (in terms of unclear spec), is what to do in that situation, because you obviously can't start writing Any()'s like that in binding.

[03:09] <lue> s/the main/a/

[03:17] *** Guest865 left
[03:17] <sorear> sure you caqn

[03:17] *** masonkramer left
[03:22] <lue> in @a[0..2] := 3, what do you do with elements [1] and [2] ? (hrm, I oughta post my thoughts on p6l)

[03:27] <sorear> nothing

[03:27] <sorear> @a[0..2] is not a bvalue

[03:27] <sorear> the := operator should die

[03:27] <pmichaud> not only that, but unless @a already has some elements, @a[0..2] is a null list.

[03:28] <pmichaud> (rakudo doesn't implement this yet, but that's what the spec says)

[03:30] * pmichaud goes ahead and implements this.

[03:30] <ash_> http://greaterthaninfinity.dyndns.info/ 

[03:30] <ash_> i think the basics are working now

[03:31] <ash_> thats the interactive shell for rakudo

[03:33] <lue> ash_++ good job. Looks great!

[03:34] *** PZt left
[03:35] <ash_> i am still messing with styles

[03:36] <ash_> but its starting to work a little, it doesn't remember anything, its completely stateless for now 

[03:36] <ash_> cygx is working on the other parts that will make it remember things between lines 

[03:38] <lue> afk ~1.5 hrs

[03:38] <pmichaud> TimToady: ping

[03:38] <TimToady> pon

[03:38] <TimToady> g

[03:39] <pmichaud> (the "ng" key is having trouble too, I see :-)

[03:39] <pmichaud> I think we need a method on lists that can answer the question "do you have at least this many elements?"

[03:39] <pmichaud> same for strings

[03:39] <pmichaud> (do you have this many chars/codepoints/whatever?)

[03:39] <pmichaud> something that we can use without having to calculate .elems

[03:40] <TimToady> is .reify taken?

[03:40] <pmichaud> might be a collison with iterator.reify

[03:40] *** PZt joined
[03:40] <pmichaud> (Iterator.reify can certainly change names, if needed)

[03:41] <TimToady> .atleast

[03:41] <pmichaud> wfm

[03:41] <TimToady> .is-there

[03:41] <TimToady> umm

[03:41] <pmichaud> in particular, I'm looking at the case of   .[$range]

[03:42] <pmichaud> and we need to see if $range.min is beyond the end of the list/array/whatever

[03:42] <TimToady> .guarantee except I envisioned that it would just give you back the real answer if it ran into the end

[03:43] <TimToady> .tryfor

[03:43] <pmichaud> internally I've used !fill

[03:43] <pmichaud> i.e.   !fill(5)    # make sure 5 elements are filled, if possible.

[03:43] <TimToady> .budget

[03:43] <TimToady> .want

[03:43] <pmichaud> but !fill's return value wouldn't work

[03:43] <pmichaud> .want isn't too bad

[03:44] <TimToady> implies that it could give you something less than that

[03:44] <TimToady> (1..4).want(10) would return 4, presumably

[03:44] <pmichaud> right

[03:44] <pmichaud> .gimme

[03:45] <TimToady> that would be fine by me :)

[03:45] <pmichaud> I can do .want for now, and it's easily changed at some point if we need.

[03:45] <pmichaud> and of course,   .want(Inf)  returns the same as .elems :-)

[03:46] <TimToady> that could even be the generic definition of .elems

[03:46] <pmichaud> oh!  yes!

[03:46] <pmichaud> .elems(4)

[03:46] <pmichaud> where the default is .elems(Inf)

[03:46] <TimToady> hmm

[03:46] <pmichaud> well, which do you prefer  (or .want? :-)

[03:47] <TimToady> well...elems saves a name, but doesn't read as well

[03:48] <pmichaud> .want has the advantage of potentially working for (lazy) string thingies, too.

[03:48] <TimToady> it's not clear that the arg to elemsn is a max

[03:48] <pmichaud> although there  we could have   .chars(5),  .glyphs(10), etc.

[03:48] <pmichaud> could make it a named argument to make it clear

[03:48] <pmichaud> .elems(:max(5))

[03:49] <pmichaud> .elems(:upto(5))

[03:49] <TimToady> I suppose want() is making the "length" mistake

[03:49] <TimToady> .elems(^5)

[03:50] <pmichaud> .elems(:to(5))

[03:51] <TimToady> I kinda like .elems(Range) vs .elems(Int)

[03:51] <pmichaud> that feels weirder, though.

[03:52] <pmichaud> would we use Range.max, or Range.elems?  ;-)

[03:52] <pmichaud> and if Range.max, then why not just an Int?

[03:52] <TimToady> because there's also a min

[03:52] <TimToady> whereas Int fails if it can't get that many

[03:52] <pmichaud> ohhhh

[03:52] <TimToady> .elems($lastpos+1)

[03:53] <pmichaud> so,  .elems($min..$max)   would return failure if it couldn't get at least $min?

[03:53] <TimToady> .elems(++$pos)

[03:53] <TimToady> right

[03:53] <pmichaud> it feels less weird now, but still a little weird.

[03:54] <pmichaud> still, in the case of  .[$range],  that ends up translating into .elems($range)  which is kind of nice

[03:56] <pmichaud> although it kinda fails in that .[1..5]  would want .elems to return 6

[03:56] *** ashleydev joined
[03:56] <pmichaud> I guess that's okay.

[03:56] <pmichaud> but it does mean that   .elems(0..5)  would return 6 if it got them all, and not 5.

[03:56] <pmichaud> which is different from  .elems(6)

[03:57] <pmichaud> also with ranges we'd have to think about exclusive ranges (ugh)

[03:57] <pmichaud> I guess that's just a smartmatch, though.

[03:58] <TimToady> maybe .elems isn't quite right

[03:58] <TimToady> .wantelem maybe, and it's 0 based instead of 1

[04:00] <pmichaud> I guess my thinking about ranges is that if we wanted to do something like  .elems(^5), one could write   .elems(5) ~~ ^5

[04:00] <pmichaud> or in general,  .elems($max) ~~ $range

[04:00] <pmichaud> which perhaps argues that  .elems($range)  is really talking about a range of element sizes and not a range of indices

[04:00] <pmichaud> and .[$range]  has to be aware of the off-by-one-ism (which is likely okay)

[04:01] <pmichaud> okay, well, I think I'll let this sit for the night, then.

[04:01] <pmichaud> maybe I'll try .elems($range) and see how it works.  We can always remove it if it doesn't work out.

[04:01] <TimToady> if feels like there's probably something better we're not seeing yet

[04:01] <TimToady> *it

[04:01] <pmichaud> yeah.

[04:02] <pmichaud> I'll go with .elems($range) for now, under the expectation that it'll be removed.  :)

[04:02] <pmichaud> (won't be hard to change to something else later.)

[04:03] <TimToady> .elems($base,$howmanymore) maybe

[04:03] <pmichaud> or maybe I'll just do .elems(Int) for now, under the same expecation :-)

[04:03] <pmichaud> *expectation

[04:03] * TimToady expectorates

[04:05] <pmichaud> anyway, I'll wait on this for morning at least, and perhaps for tomorrow's plane rides

[04:05] <pmichaud> if you come up with anything, leave me a note in the backlog or with phenny.  thanks

[04:07] <TimToady> 'course, there's still a conjecture in there that (1..2) + 1 produces 2..3

[04:08] * pmichaud grabs the conjecture by its scrawny little neck, shakes it around, slams it against the wall, and bounces it off the ceiling until there's nothing left in its lifeless body.

[04:08] <pmichaud> Hey, that's not a bad idea.

[04:08] <pmichaud> :-)

[04:08] * TimToady grins

[04:17] <diakopter> is := dead yet

[04:19] <TimToady> seems to be still twitching a bit

[04:19] <TimToady> but we're hoping it stabilizes soon

[04:23] *** mantovani left
[04:24] *** mantovani joined
[04:29] *** nimiezko left
[04:31] *** simcop2387 joined
[04:49] <diakopter> rakudo: say (1..2) * (2..4)

[04:49] <p6eval> rakudo c70469: OUTPUTÂ«6â¤Â»

[04:49] * sorear is struggling to add class declarations to the IR

[04:55] *** skids left
[04:58] *** ashleydev left
[05:00] *** hercynium joined
[05:10] <lue> ohai again

[05:13] *** tylercurtis left
[05:14] <lue> [backlogging] I like the sound of .want, if only for the reason that its name is different from what you'd expect.

[05:15] <lue> (somewhere along with slurpy, stringy, etc.)

[05:17] *** vapace joined
[05:19] <PerlJam> .hal(5)  # has at least   :-)

[05:22] <lue> I don't know how I feel about a hal function... ;)

[05:38] *** Su-Shee joined
[05:45] <szabgab> rakudo: max(2,3);

[05:45] <p6eval> rakudo c70469: OUTPUTÂ«Unable to handle non-closure Ordering yetâ¤  in 'Any::max' at line 1404:CORE.settingâ¤  in 'max' at line 1665:CORE.settingâ¤  in main program body at line 11:/tmp/eh3XKQ5XE9â¤Â»

[05:45] <szabgab> rakudo: vuvuzela(2,3);

[05:45] <p6eval> rakudo c70469: OUTPUTÂ«Could not find sub &vuvuzelaâ¤  in main program body at line 11:/tmp/za2d4ksK4fâ¤Â»

[05:46] <szabgab> rakudo: Any::max(2,3);

[05:46] <p6eval> rakudo c70469: OUTPUTÂ«Can not find sub Any::maxâ¤  in main program body at line 1â¤Â»

[05:56] *** ashleydev joined
[06:10] *** gtyhm joined
[06:11] *** uniejo joined
[06:14] *** gtyhm left
[06:16] *** iota__ joined
[06:17] <iota__> rakudo:

[06:17] *** iota__ left
[06:17] *** cjk101010 joined
[06:19] *** uniejo left
[06:21] *** uniejo joined
[06:27] *** justatheory left
[06:34] *** eternaleye joined
[06:51] <moritz_> rakudo: say 2 max 3

[06:51] <p6eval> rakudo c70469: OUTPUTÂ«3â¤Â»

[06:51] <moritz_> szabgab: the sub form of max() needs an ordering closure as first argument

[06:51] <moritz_> rakudo: my $x := 3; say $x; $x = 5; say $x

[06:51] <p6eval> rakudo c70469: OUTPUTÂ«3â¤Cannot modify readonly valueâ¤  in '&infix:<=>' at line 1â¤  in main program body at line 11:/tmp/6vFidOJhM0â¤Â»

[06:52] <szabgab> rakudo: say 2.max 3;

[06:52] <p6eval> rakudo c70469: OUTPUTÂ«===SORRY!===â¤Confused at line 11, near "say 2.max "â¤Â»

[06:52] <moritz_> two terms in a row

[06:52] <szabgab> rakudo: say max 2,3;

[06:52] <p6eval> rakudo c70469: OUTPUTÂ«Unable to handle non-closure Ordering yetâ¤  in 'Any::max' at line 1404:CORE.settingâ¤  in 'max' at line 1665:CORE.settingâ¤  in main program body at line 11:/tmp/xFL3ZYD6Eqâ¤Â»

[06:52] <moritz_> rakuo: say [max] 5, 2, 3

[06:53] <moritz_> rakudo: say [max] 5, 2, 3

[06:53] <szabgab> specifically I was hoping to show $x = $x.max(42);      and then $x .= max(42)

[06:53] <p6eval> rakudo c70469: OUTPUTÂ«5â¤Â»

[06:53] <moritz_> $x max= 42

[06:54] <sorear> rakudo: say 2.max: 3

[06:54] <p6eval> rakudo c70469: OUTPUTÂ«Unable to handle non-closure Ordering yetâ¤  in 'Any::max' at line 1404:CORE.settingâ¤  in main program body at line 11:/tmp/5beGyYTRuiâ¤Â»

[06:54] <szabgab> rakudo: my $x = 2; $x max=3; say $x

[06:54] <p6eval> rakudo c70469: OUTPUTÂ«3â¤Â»

[06:54] <szabgab> rakudo: my $x = 2; $x max=1; say $x

[06:54] <p6eval> rakudo c70469: OUTPUTÂ«2â¤Â»

[06:55] <sorear> max= is one of p6's most awesome features imo

[06:55] <moritz_> sorear: (backlog, circumfix:[' ', ' '])  - whitespace in operators are officially forbidden

[06:58] <sorear> how about Foo:from['foo bar', 'baz'] then

[07:00] <moritz_> noidea

[07:07] *** Ross joined
[07:07] *** Ross left
[07:08] *** Ross joined
[07:12] <dalek> niecza: 9d143f0 | sorear++ |  (5 files):

[07:12] <dalek> niecza: Refactor preinit / enter to be controlled by a common object set

[07:12] <dalek> niecza: review: http://github.com/sorear/niecza/commit/9d143f069eb946f48dc996c2af597ae241c7f5dc

[07:17] *** vapace left
[07:18] *** ashleydev left
[07:24] <pugssvn> r31586 | moritz++ | [t/spec] some rakudo unfudges 

[07:33] <pmichaud> I like unfudges :-)

[07:34] <pmichaud> I like fudge too, which is an interesting paradox of sorts.

[07:34] <moritz_> humans are paradox by nature

[07:35] <moritz_> we like stress (within limits) and relaxing

[07:35] <moritz_> sleeping and doing sports

[07:35] <moritz_> etc.

[07:35] <moritz_> did any of the binding commits add a test file?

[07:36] <pmichaud> not that I saw

[07:36] * moritz_ neither

[07:36] <pmichaud> but there are lots of binds in the tests already

[07:36] <pmichaud> try ack ':='  :-)

[07:36] <moritz_> I guess I need to run autounfudge again

[07:36] <moritz_> [SPA] (  4/8  ) t/spec/S03-operators/binding-closure.t

[07:36] <moritz_> [SPA] ( 33/37 ) t/spec/S03-operators/binding-hashes.t

[07:36] <moritz_> [SP ] ( 17/28 ) t/spec/S03-operators/binding-scalars.t

[07:36] <moritz_> from tools/update_passing_test_data.pl

[07:36] *** lue left
[07:37] <moritz_> that looks promising

[07:37] <moritz_> S09-subscript_slice/slice.t

[07:37] <moritz_> passes too

[07:43] *** snarkyboojum joined
[07:44] <pugssvn> r31587 | moritz++ | [t/spec] rakudo re-fudges (mostly unfudges) and a corrected plan() 

[07:48] <snarkyboojum> some modules have dropped off the proto website since things have moved to the pls fork?

[07:48] <dalek> rakudo: 1086ff8 | moritz++ | t/spectest.data:

[07:48] <dalek> rakudo: we pass 6 more test files

[07:48] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1086ff8a04a3e9a1a0c7ba5a78e9107eb32d61a5

[07:49] <moritz_> snarkyboojum: I think one or two projects were removed where the project location was a 404

[07:49] <moritz_> snarkyboojum: but apart from that, I'm not aware of any

[07:49] <moritz_> snarkyboojum: though I don't know how well masak++ keeps the project lists of proto and pls in sync

[07:49] <snarkyboojum> moritz_: my little MIME::Base64 port isn't there anymore, but there could be a good reason :D

[07:50] <moritz_> I doubt there's a good reason for it.

[07:50] <moritz_> snarkyboojum: github URL?

[07:50] <snarkyboojum> moritz_: http://github.com/snarkyboojum/Perl6-MIME-Base64

[07:51] *** xinming left
[07:51] *** exodist_ joined
[07:52] <mathw> Morning

[07:53] <moritz_> snarkyboojum: I guess the fault is mine for using an experimental, WIP fork as the base for the module list

[07:53] <moritz_> snarkyboojum: anyway, I've added it to pls' project list, so the next regular update should get it

[07:53] <snarkyboojum> moritz_: lovely - thanks

[07:54] <moritz_> ash_: I can give you access to the try.rakudo.org server, just ping me when you're online

[07:57] *** xinming joined
[07:59] <moritz_> pmichaud: you're right, autounfudge finds quite some occurences of fudged binding tests all over the test suite

[08:01] *** tadzik joined
[08:04] <snarkyboojum> moritz_: FWIW, I think these are missing also, http://github.com/supernovus/SCGI and http://github.com/uasi/file-spec

[08:05] <moritz_> snarkyboojum: I think I should bother masak++ with finding a good way to keep them up-to-date automatically :-)

[08:05] <sorear> I'm pretty sure I told you that would happen

[08:05] <sorear> rakudo needing major unfudgage after :=

[08:05] <snarkyboojum> moritz_: sure :) just pointing the missing ones out ;)

[08:06] <moritz_> sorear: yes. It's not a bad thing :-)

[08:12] *** clintongormley joined
[08:29] *** plobsing left
[08:34] *** exodist_ left
[08:34] *** dakkar joined
[08:38] *** exodist joined
[08:40] *** thebird joined
[08:52] <moritz_> wc -l autounfudge.patch

[08:52] <moritz_> 200 autounfudge.patch

[08:52] * moritz_ impressed

[08:52] <moritz_> there are two false-positives in there

[08:52] <moritz_> but all in all it should be OK

[08:54] <moritz_> running a spectest now before I commit them...

[08:55] <moritz_> rakudo: class A { has $.x; method foo { $!x := 42 } }; my $a = A.new; $a.foo; say A.x

[08:55] <p6eval> rakudo 1086ff: OUTPUTÂ«Type objects are abstract and have no attributes, but you tried to access $!xâ¤  in main program body at line 67â¤Â»

[08:55] <moritz_> rakudo: class A { has $.x; method foo { $!x := 42 } }; my $a = A.new; $a.foo; say $a.x

[08:55] <p6eval> rakudo 1086ff: OUTPUTÂ«42â¤Â»

[08:59] *** envi^home joined
[08:59] *** arthur-_ joined
[08:59] *** arthur-_ left
[09:04] *** ldd joined
[09:05] *** Su-Shee left
[09:08] <dolmen__> rakudo: say (1..5).max

[09:08] <p6eval> rakudo 1086ff: OUTPUTÂ«5â¤Â»

[09:08] <dolmen__> rakudo: say [max] 1..5

[09:08] <p6eval> rakudo 1086ff: OUTPUTÂ«5â¤Â»

[09:08] <dolmen__> rakudo: say 1..5.elems

[09:09] <p6eval> rakudo 1086ff: OUTPUTÂ«1â¤Â»

[09:09] <dolmen__> rakudo: say (1..5).elems

[09:09] <p6eval> rakudo 1086ff: OUTPUTÂ«5â¤Â»

[09:09] <dolmen__> rakudo: say (1..5).elems(3)

[09:09] <p6eval> rakudo 1086ff: OUTPUTÂ«No candidates found to invokeâ¤  in main program body at line 11:/tmp/ogQKFUud4Eâ¤Â»

[09:13] *** cinch left
[09:15] <sorear> rakudo: state class Foo { }

[09:16] <p6eval> rakudo 1086ff: OUTPUTÂ«Could not find sub &stateâ¤  in main program body at line 11:/tmp/xhJrD3SHaeâ¤Â»

[09:16] <moritz_> std: state class A { }

[09:16] <p6eval> std 31587: OUTPUTÂ«ok 00:01 110mâ¤Â»

[09:17] <pmichaud> sleep time here -- bbiaw

[09:17] *** cono joined
[09:28] <dolmen__> rakudo: say ((1..5) | (6..8) ).elems(3)

[09:28] <p6eval> rakudo 1086ff: OUTPUTÂ«No applicable candidates found to dispatch to for 'elems'. Available candidates are:â¤:(Mu ;; *%_)â¤â¤  in main program body at line 1â¤Â»

[09:28] <dolmen__> rakudo: say ((1..5) | (6..8) ).elems

[09:28] <p6eval> rakudo 1086ff: OUTPUTÂ«any(1)â¤Â»

[09:29] <moritz_> the junction flattens

[09:29] <moritz_> into any(1..8)

[09:29] <moritz_> and each of them has 1 elem

[09:30] <dolmen__> rakudo: say any(1..8).elems

[09:30] <p6eval> rakudo 1086ff: OUTPUTÂ«any(1)â¤Â»

[09:31] <dolmen__> the output of .elems should'nt be an Int

[09:31] <dolmen__> ?

[09:31] <pugssvn> r31588 | moritz++ | [t/spec] binding unfudges for rakudo 

[09:31] <moritz_> rakudo: say 3.elems

[09:31] <p6eval> rakudo 1086ff: OUTPUTÂ«1â¤Â»

[09:32] <moritz_> dolmen__: .elems autothreads, returning an each for item. The result is a junction of 1s

[09:32] <moritz_> which collapses to a single 1

[09:32] <moritz_> not actually collapses, but there's no use to store duplicates in an any()-junction

[09:32] <dolmen__> but any(1) is not 1

[09:32] <moritz_> right

[09:33] <moritz_> but 1 and any(1) behave the same in almost all ways

[09:33] <moritz_> the general rule is that out of junctions you only get Bool or other junctions

[09:34] <dolmen__> rakudo: say (1 | 2 | 3).elems

[09:34] <p6eval> rakudo 1086ff: OUTPUTÂ«any(1)â¤Â»

[09:34] <moritz_> if that's not what you want, you should use a Set instead of a Junction

[09:34] <dolmen__> which are the operators to build a Set ?

[09:35] <dolmen__> rakudo: say (1 & 2 & 3).elems

[09:35] <p6eval> rakudo 1086ff: OUTPUTÂ«all(1)â¤Â»

[09:35] <dolmen__> rakudo: say (1..6 & 2 & 3).elems

[09:35] <p6eval> rakudo 1086ff: OUTPUTÂ«all(1)â¤Â»

[09:35] <moritz_> dolmen__: I don't know... Rakudo has a basic implementation in src/core/Set.pm, maybe that's helpful

[09:36] <dolmen__> rakudo: my Set $s; $s.add(1..5);

[09:36] <p6eval> rakudo 1086ff: OUTPUTÂ«Method 'add' not found for invocant of class ''â¤  in main program body at line 11:/tmp/sN607pu9fCâ¤Â»

[09:36] <dolmen__> rakudo: my Set $s; $s += (1..5);

[09:36] <p6eval> rakudo 1086ff: OUTPUTÂ«Type check failed for assignmentâ¤  in '&infix:<=>' at line 1â¤  in main program body at line 11:/tmp/n9JW9m9R3Bâ¤Â»

[09:37] <moritz_> rakudo: say Set.new(1..5)

[09:37] <p6eval> rakudo 1086ff: OUTPUTÂ«Set()<0x7684990>â¤Â»

[09:37] <moritz_> uhm

[09:37] <moritz_> less than awesome stringification

[09:38] <cono> rakudo: my Set $s .= new(1,2,3,5); $s.perl.say

[09:38] <p6eval> rakudo 1086ff: OUTPUTÂ«Set.new(1, 2, 3, 5)â¤Â»

[09:38] *** masak joined
[09:39] <masak> oh hai, #perl6

[09:39] <frettled> yayitsmasak

[09:39] <moritz_> he lo ma sak

[09:39] <dolmen__> rakudo: my Set $s .= new(1..5); say $s.elems

[09:39] <p6eval> rakudo 1086ff: OUTPUTÂ«5â¤Â»

[09:39] <dolmen__> rakudo: my Set $s .= new(1..5, 72..82); say $s.elems

[09:40] <p6eval> rakudo 1086ff: OUTPUTÂ«16â¤Â»

[09:40] <frettled> rakudo: Set.new(1..5).say

[09:40] <moritz_> rakudo: say Set.new(1..5).intersect(4..8).elems

[09:40] <p6eval> rakudo 1086ff: OUTPUTÂ«Set()<0x75fc7b0>â¤Â»

[09:40] <p6eval> rakudo 1086ff: OUTPUTÂ«Method 'intersect' not found for invocant of class 'Set'â¤  in main program body at line 11:/tmp/iVIrlAIkjyâ¤Â»

[09:40] <moritz_> rakudo: say Set.new(1..5).intersection(4..8).elems

[09:40] <p6eval> rakudo 1086ff: OUTPUTÂ«2â¤Â»

[09:41] <moritz_> rakudo: say ~Set.new.^methods(:local)

[09:41] <p6eval> rakudo 1086ff: OUTPUTÂ«of elems subset intersection equal superset keys at_key exists union new difference Bool subsetorequal values Num perl supersetorequalâ¤Â»

[09:41] <dolmen__> rakudo: my Set $s .= new(1..5, 3..9); say $s.elems

[09:41] <p6eval> rakudo 1086ff: OUTPUTÂ«9â¤Â»

[09:41] <dolmen__> ???

[09:41] <masak> dolmen__: Â¿Â¿Â¿

[09:41] <dolmen__> oh, mixed answers

[09:42] <frettled> rakudo: Set.new(1..4, 2..6).perl.say

[09:42] <p6eval> rakudo 1086ff: OUTPUTÂ«Set.new(1, 2, 3, 4, 5, 6)â¤Â»

[09:45] <masak> pretty neat, eh?

[09:46] <masak> I almost got the unicode operators in there, too.

[09:46] <dolmen__> rakudo: ~Set.WHAT.say

[09:46] <p6eval> rakudo 1086ff: OUTPUTÂ«Set()â¤Â»

[09:47] <dolmen__> rakudo: Set.WHAT.say

[09:47] <p6eval> rakudo 1086ff: OUTPUTÂ«Set()â¤Â»

[09:47] <frettled> Hmm!

[09:47] <frettled> rakudo: Set.new(1..4, 2..6).keys.say

[09:47] <dolmen__> say (1..5)

[09:47] <p6eval> rakudo 1086ff: OUTPUTÂ«123456â¤Â»

[09:47] <dolmen__> rakudo: say (1..5)

[09:48] <p6eval> rakudo 1086ff: OUTPUTÂ«12345â¤Â»

[09:48] <dolmen__> rakudo: say ~(1..5)

[09:48] <p6eval> rakudo 1086ff: OUTPUTÂ«1 2 3 4 5â¤Â»

[09:49] <dolmen__> rakudo: say 'x' ~(1..5)

[09:49] <p6eval> rakudo 1086ff: OUTPUTÂ«x1 2 3 4 5â¤Â»

[09:50] <dolmen__> Is ~ an infix or prefix op?

[09:50] <moritz_> both

[09:50] <moritz_> when a term is epxected, a prefix

[09:50] <moritz_> when an infix is expected, an infix

[09:51] <moritz_> just like +

[09:52] <dolmen__> rakudo: say [~] (1..5)

[09:52] <p6eval> rakudo 1086ff: OUTPUTÂ«12345â¤Â»

[09:52] <dolmen__> rakudo: say ([~] (1..5)).elems

[09:52] <p6eval> rakudo 1086ff: OUTPUTÂ«1â¤Â»

[09:52] <dolmen__> rakudo: say (~ (1..5)).elems

[09:52] <p6eval> rakudo 1086ff: OUTPUTÂ«1â¤Â»

[09:52] <moritz_> dolmen__: do you have an obsession for .elems? :-)

[09:53] <moritz_> rakudo: say ([~] 1..5).perl

[09:53] <p6eval> rakudo 1086ff: OUTPUTÂ«"12345"â¤Â»

[09:54] <dolmen__> I had a look at the discussion between pmichaud and TimToady about .elems in the backlog

[09:55] <moritz_> ah, didn't read it yet

[09:55] <dolmen__> 5 hours ago

[09:56] <dolmen__> or 6

[09:58] <masak> [backlog] I think I like 'firstsame' better than '*' :)

[09:58] <masak> 'firstsame' has that Perl oddness about it.

[09:59] * moritz_ thinks * is already overused

[09:59] <masak> aye.

[09:59] <moritz_> adding another meaning to it isn't going to help

[10:00] <masak> let's start a Facebook group "we want 'firstsame' instead of '*'" :)

[10:01] <masak> hm. 'firstsame' sounds like it's parallel to 'nextsame' though -- which implies it's a tailcall.

[10:01] <masak> and there's no obvious parallel to 'callsame'.

[10:05] *** meppl joined
[10:14] <jnthn> oh hai

[10:15] <jnthn> Typing protos is going to get tiring enough

[10:15] <jnthn> Typing you-think-that's-cute-now firstsame will get even more so. :-)

[10:21] <masak> heh.

[10:27] <bbkr> rakudo: Set.new(1, 1).perl.say

[10:27] <p6eval> rakudo 1086ff: OUTPUTÂ«Set.new(1)â¤Â»

[10:28] <bbkr> rakudo: Set.new(1 .. 2).perl.say

[10:28] <p6eval> rakudo 1086ff: OUTPUTÂ«Set.new(1, 2)â¤Â»

[10:28] <bbkr> rakudo: Set.new(1 .. *).perl.say

[10:29] <p6eval> rakudo 1086ff:  ( no output )

[10:32] <bbkr> rakudo: Set.new(1, **-1 ... *).perl.say # expecting miracle :)

[10:32] <p6eval> rakudo 1086ff:  ( no output )

[10:33] *** lestrrat is now known as lest_away

[10:43] <bbkr> std: 555 ~~!~~ 666

[10:43] <p6eval> std 31588: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Expecting a term, but found either infix ~~ or redundant prefix ~â¤  (to suppress this message, please use space between ~ ~) at /tmp/EZ59HXaH3Q line 1:â¤------> [32m555 ~~!~~[33mâ[31m 666[0mâ¤Parse failedâ¤FAILED 00:01 112mâ¤Â»

[10:43] <bbkr> rakudo: 555 ~~!~~ 666

[10:43] <p6eval> rakudo 1086ff:  ( no output )

[10:43] <bbkr> bug :)

[10:44] <jnthn> heh

[10:44] <jnthn> bet it parsed as

[10:44] <jnthn> 555 ~~ !(~(~(666)))

[10:45] <jnthn> std: 555 ~~!~ 666

[10:45] <p6eval> std 31588: OUTPUTÂ«ok 00:01 109mâ¤Â»

[10:45] <jnthn> std: 555 ~~!! 666

[10:45] <p6eval> std 31588: OUTPUTÂ«ok 00:01 109mâ¤Â»

[10:46] <jnthn> Curios.

[10:46] <bbkr> i'll work on my mutation tests during weekend journey so there will be more interesting cases :)

[10:46] *** Mowah joined
[10:54] <masak> bbkr: is that a new bug?

[10:55] *** rv2733 joined
[10:59] <bbkr> i think so, i found some similiar forced-context operator parsing bug 72828, but this one looks like different case

[11:00] <masak> feel free to submit.

[11:00] <masak> bbkr++

[11:05] *** TiMBuS|Away joined
[11:06] *** thebird left
[11:06] *** thebird joined
[11:07] <masak> a POST phaser block gets the return value as the current topic upon normal block exit. what does it get as the current topic when the surrounding block exits un-normally? more importantly, how will code within the POST phaser know whether the surrounding block exited normally?

[11:07] *** TiMBuS left
[11:08] <frettled> masak: is the phaser set to stun or kill?  :)

[11:10] <masak> wow, a *phaser* joke! how original. :P

[11:10] <frettled> Yes, I bet you've never heard one before!

[11:11] <masak> hold on, let me just stop laughing.

[11:11] <masak> there. :)

[11:12] <masak> now, about my question...

[11:13] <jnthn> Maybe Nil

[11:13] <jnthn> But of course it's possible Nil coulda been returned.

[11:13] <masak> returning Nil counts as an 'unsuccessful block exit' though, right?

[11:13] <masak> so it kinda makes sense.

[11:14] <jnthn> Yes

[11:14] <jnthn> Troo

[11:14] <frettled> masak: If I read the spec correctly, POST phasers handle what happens after LEAVE, and if the block doesn't exit normally through LEAVE, then â€¦?

[11:14] <jnthn> I think os anyway

[11:14] <jnthn> If current spec says that

[11:14] <jnthn> *so

[11:15] * frettled re-reads that part of the spec.  I remember I was confused the last time, too.

[11:15] <masak> frettled: any of the LEAVE blocks in the LEAVE queue can throw an exception, or change the topic to Nil, I guess.

[11:19] <frettled> masak: and it appears that you need to check $! in POST

[11:19] <masak> yes, probably.

[11:19] <frettled> well, OUTER::<$!>

[11:19] <masak> should be the same, no?

[11:19] <masak> is $! set by &fail?

[11:20] <jnthn> not afaik

[11:20] <frettled> Perhaps this is relevant: Â«If there is no stack-unwinding exception when these phasers are run, $! will be Nil. The last exception caught in the outer block is available as OUTER::<$!>, as usual.Â»

[11:20] <jnthn> fail is just return Failure.new($thingy) iirc

[11:20] <frettled> Context: exception in exit phasers

[11:20] <jnthn> so it's a normal return in that sense.

[11:21] <jnthn> (though not sure if it's "successful")

[11:22] <masak> ok.

[11:25] <masak> S04:1580: "In the absence of error exception propagation, a successful exit is one that returns a defined value in item context, or any number of values in list context as long as the length is defined. [...] A list is of undefined length only if it contains an undefined generator, which, happily, is what is returned by the C<fail> function when used in list context."

[11:25] <masak> so &fail counts as an unsuccessful exit.

[11:25] <jnthn> aha

[11:27] <jnthn> So it's not successful to die or fail, but I'd not expect fail to set $!.

[11:27] <masak> me either.

[11:29] <frettled> sensible.

[11:39] *** sftp joined
[11:42] *** ruoso left
[11:54] <moritz_> masak: a POST block won't get executed if the surrunding block fails

[11:54] <moritz_> POST is basically an assertion "if this thing returned a value, make sure it's a good one"

[11:55] <masak> moritz_: "If a C<POST> fails while an exception is in flight the C<POST> failure doesn't replace C<$!> but goes straight into C<$!.pending>."

[11:56] <masak> in which light am I supposed to read the above phrase if they don't run after an exception has been thrown?

[11:56] <moritz_> hm

[11:56] <moritz_> that goes contrary to my understandings of DBC

[11:56] <masak> not to mine.

[11:56] <masak> it's still important to make sure the object is in a consistent state.

[11:57] <moritz_> object being in a consistent state should be checked by invariants, not by POST conditions

[11:57] <masak> ok.

[11:57] <masak> how does one encode invariants in Perl 6?

[11:57] <moritz_> though I don't know if we have support for invariants

[11:57] <masak> I thought POST blocks were the closest we had.

[11:58] <moritz_> an invariant is a check that runs after the end of each method

[11:58] <masak> that's a class-level POST block.

[11:58] <moritz_> so that if child classes add methods that endanger the internal state of an object, the parent invariant fires

[11:59] <masak> class A { POST { "check invariant here" }; ... }

[11:59] <moritz_> that doesn't do what we want by current spec

[11:59] <moritz_> unless it's special-cased, and I forgot about it

[11:59] <jnthn> That'll only run once ever

[11:59] <moritz_> right

[11:59] <masak> moritz_: it's special-cased.

[11:59] <masak> and I think I like it.

[11:59] <jnthn> masak: Spec reference?

[12:00] <masak> hold on.

[12:00] * moritz_ should read S04 and S06 again

[12:00] <moritz_> it's just very expensive

[12:00] <masak> S04:1345

[12:01] <moritz_> in Eiffel, the mother of all OO DBC languages, you can enable and disable pre- and postconditions, invariants and loop invariants at compile time

[12:01] <jnthn> Hmm, ok

[12:01] <masak> moritz_: like, put comments before them? :P

[12:01] <moritz_> masak: no, in a control file

[12:01] <moritz_> but PRE/POST in a class block are evaluated around every method in the class

[12:01] <moritz_> right, that's the interesting part

[12:02] <moritz_> so you can build debug and optimized libraries

[12:02] *** silug left
[12:03] <masak> right, because assertions never fail in production systems anyway :P

[12:03] <moritz_> gotcha

[12:04] * frettled understood the spec as saying that POST would be run anyway.  That is, LEAVE etc. aren't guaranteed to run, but POST seems to be.  Mind you, it's already three quarters of an hour since I read S04's section on phasers, and memory is such a flighty little slut.

[12:04] <masak> moritz_: in Perl 6, I guess someone could write a 'turn off all PRE/POST things for greater speed' pragma.

[12:04] <moritz_> masak: I guess so too

[12:04] <jnthn> I'm a little unconvinced about PRE and POST in the class body btw

[12:05] <jnthn> They won't be very useful

[12:05] <jnthn> If we can't make them see self

[12:05] <masak> jnthn: good point.

[12:05] <jnthn> And they won't do so unless we declare more magic.

[12:05] <jnthn> And I'm not sure how that magic would look at this point.

[12:05] * moritz_ hopes they can see self

[12:05] <masak> jnthn: magic it is, then. :)

[12:05] <jnthn> OK, but "magic" doesn't cut it.

[12:05] <jnthn> You need something implementable.

[12:06] <jnthn> For PRE and POST inside a method it's easy - self is in the lexical scope.

[12:06] <moritz_> I understand them as wrappers around the method

[12:06] <moritz_> around each method, that is

[12:06] <masak> frettled: I read your eponym for memory and though "oh my, slipperly slope... :/"

[12:06] <frettled> masak: heh

[12:07] * moritz_ has other gripes with class invariants though

[12:07] <masak> I won't be the one to point out that this is supposed to be a family channel :)

[12:07] <jnthn> The magic could be "the compiler clones them and sticks them as if they were PRE or POST into each method"

[12:07] <moritz_> suppose you have a constructor that ensures a sensible state of the object it returns

[12:07] <jnthn> But don't expect that way to work for dynamically added methods. ;-)

[12:07] <moritz_> and then you add a second multi

[12:08] <frettled> masak: good ;)

[12:08] <moritz_> and you find that you want to share some of the code for setting things up

[12:08] <moritz_> and you put it into a method

[12:08] <moritz_> and you call that from both constructors

[12:09] <moritz_> and then it goes boom, becaues the helper method might only partially set up the object

[12:09] <moritz_> but since it's the end of a method, the invariant is checked

[12:09] <masak> moritz_: maybe make it a private method?

[12:09] <moritz_> masak: and private methods don't get invariant checks?

[12:10] <masak> moritz_: right.

[12:12] *** exodist is now known as Exodist

[12:19] <dalek> rakudo: 92a210d | pmichaud++ | docs/spectest-progress.csv:

[12:19] <dalek> rakudo: spectest-progress.csv update: 513 files, 34010 (84.7% of 40163) pass, 12 fail

[12:19] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/92a210d6d2eb06699e715447d8625ddc17facaf6

[12:20] <pmichaud> good morning, #perl6

[12:20] <frettled> good morning, pmichaud!

[12:20] <moritz_> good morning pmichaud, you seem to have rather tight sleep cycles these days :-)

[12:22] <masak> good morning pmichaud!

[12:24] <jnthn> morning, pmichaud 

[12:24] <jnthn> Wow, we cleared 34,000! :D

[12:24] <pugssvn> r31589 | moritz++ | [t/spec] qx, qqx 

[12:25] <moritz_> jnthn: I'm curious if my last spectest commit works on windows... could you please try it? (no hurry though)

[12:27] <pmichaud> yes, my sleep cycles are all off at the moment.

[12:29] <jnthn> moritz_: Will do so later on today :-)

[12:29] <moritz_> thanks

[12:31] *** pmurias joined
[12:37] <moritz_> rakudo: 'abc' ~~ /(.)/; .say for $/

[12:37] <p6eval> rakudo 1086ff: OUTPUTÂ«aâ¤Â»

[12:37] <moritz_> rakudo: 'abc' ~~ /(.)/; say $/

[12:37] <p6eval> rakudo 1086ff: OUTPUTÂ«aâ¤Â»

[12:38] <moritz_> rakudo: 'abc' ~~ /(.)(.)(.)/; say $/

[12:38] <p6eval> rakudo 1086ff: OUTPUTÂ«abcâ¤Â»

[12:38] <moritz_> rakudo: 'abc' ~~ /(.)(.)(.)/; .say for $/

[12:38] <p6eval> rakudo 1086ff: OUTPUTÂ«abcâ¤Â»

[12:38] <masak> what I expect so far.

[12:38] <moritz_> right

[12:39] <moritz_> rakudo: 'abc' ~~ /(.)(.)(.)/; .say for $/.flat

[12:39] <p6eval> rakudo 1086ff: OUTPUTÂ«aâ¤bâ¤câ¤Â»

[12:39] <moritz_> \o/

[12:39] *** timbunce joined
[12:39] <moritz_> seems like RT #63606 can be resolved

[12:43] <masak> aye.

[12:53] *** rv2733 left
[12:55] *** ruoso joined
[12:58] <masak> is there a projected date for when Rakudo will run out of tests?

[12:58] <moritz_> Inf

[12:59] <masak> run out of spectests to pass, I mean.

[12:59] <moritz_> Inf

[12:59] <masak> good. then I'll keep calling Yapsi "official".

[13:00] <moritz_> when the number of not-yet-passing tests gets very small, it gets asymptotically harder to pass them all

[13:00] <moritz_> which gives us enough time to write more failing tests :-)

[13:00] <frettled> heh

[13:00] <masak> is that effect perceptible yet?

[13:00] <moritz_> well

[13:01] <moritz_> there's a core of todo'ed/skip'ped tests that have been that way for ages

[13:01] <mathw> Probably not, while there are large chunks of the spec still unimplemented

[13:01] <mathw> I bet I could write you some macro tests that fail...

[13:01] <moritz_> mathw: there are macro tests already :-)

[13:01] <moritz_> more are welcome, of course

[13:01] <masak> I have a feeling we need more phaser tests :)

[13:02] <moritz_> or for example quasi-quoting isn't limited to macros

[13:02] <moritz_> masak: that too

[13:04] <jnthn> There's LOTS of areas we need more tests.

[13:04] <jnthn> I bet we'll want more integration tests too

[13:04] <jnthn> As we discover more interesting feature interactions.

[13:04] <moritz_> things like phasers need a quadratic number for interactions between them

[13:05] <moritz_> jnthn: most of the tests I wrote are integration tests of some kind... lexicals + recursing, typing + attributes, multi dispatch + subset types, ....

[13:06] <masak> I think I might actually enjoy writing phaser tests. did I just say that out loud?

[13:06] <masak> don't know where I'd get the tuits, though.

[13:06] <masak> and it'd be more fun with an implementation that implemented things in parallel.

[13:06] <mathw> well then, you should implement parallelism in Yapsi

[13:09] <masak> some phasers are already feasible to implement in Yapsi, but perhaps not so interesting yet without subroutines.

[13:10] <dolmen__> rakudo: (1, 'Z', 3).flat.perl.say

[13:10] <p6eval> rakudo 92a210: OUTPUTÂ«(1, "Z", 3)â¤Â»

[13:12] <frettled> masak: details, schmetails, who needs subroutines, anyway?  :D

[13:13] <moritz_> masak: FIRST and LAST should be possible right now, I think

[13:13] <masak> frettled: I do. :) working my way up to fibonacci in Yapsi :)

[13:13] <masak> moritz_: hm, but those aren't the easiest ones, I think.

[13:14] <masak> ENTER is easy, though.

[13:14] <moritz_> masak: if you want something easy, go shopping :-)

[13:15] <masak> moritz_: what I really meant was "I don't see the mechanism with which FIRST and LAST might currently be made to work".

[13:15] <frettled> moritz_: that's not yet a set of keywords in Perl 6, though?  (Â«go shoppingÂ»)

[13:15] <moritz_> frettled: no, just a meme :-)

[13:15] <frettled> moritz_: thank goodness :D

[13:15] <dolmen__> rakudo: (1, (1, 9), 3).flat.perl.say

[13:15] <p6eval> rakudo 92a210: OUTPUTÂ«(1, 1, 9, 3)â¤Â»

[13:15] <moritz_> masak: don't you have loops yet?

[13:15] <masak> moritz_: specifically, I thought I might start by cheating and make the phasers static. FIRST and LAST don't seem very static.

[13:16] <masak> moritz_: Yapsi does while loops now.

[13:16] <moritz_> well, then :-)

[13:17] <moritz_> alpha: for 1..4 { FIRST { say "OH HAI" }; .say }

[13:18] <p6eval> alpha 30e0ed: OUTPUTÂ«Could not find non-existent sub FIRSTâ¤in Main (file src/gen_setting.pm, line 324)â¤Â»

[13:18] <masak> moritz_: I'm successively adding things to my (and Yapsi's) model. I'm not sure how FIRST and LAST would work with what's currently there.

[13:18] <masak> FIRST has to check for... something. probably a hidden variable.

[13:19] <masak> that's not a problem in itself, but where to put it?

[13:19] <moritz_> in first approximation, ENTER could be made to work by just adding another block to the statementlist in the block, no?

[13:19] <masak> can't put it in the lexpad of the block that's executing, because a new such is born with each iteration.

[13:19] <masak> will probably have to put it in the lexpad outside that.

[13:20] <moritz_> in the same location where you put state variables :-)

[13:20] <masak> :)

[13:20] <moritz_> oh wait, that doesn't work

[13:20] <masak> moritz_: re, ENTER; yes. that's my plan.

[13:20] <moritz_> with nested loops, that is

[13:20] <masak> it doesn't?

[13:20] <moritz_> for 1..3 { for 1..2 { FIRST {.say }; ... } }

[13:20] <masak> seems to work great.

[13:20] <moritz_> I'd expect that to say 1 three timees

[13:20] <masak> aye.

[13:20] <masak> and it would, too.

[13:21] <moritz_> I meant with a state variable

[13:21] <masak> ah; no.

[13:21] <moritz_> sorry for being confusing

[13:21] <masak> but the hidden-in-outer-block idea works.

[13:21] <moritz_> speaking of confusion...

[13:21] <masak> (it doesn't work for 'state' vars, as I and sorear discussed the other day)

[13:21] <moritz_> you were right about nextsame() never leading to ambiguous dispatch in the current model

[13:22] <moritz_> (which we've discussed a few months ago)

[13:22] <masak> moritz_: I remember that discussion, yes.

[13:22] <masak> we're all trying to fit Perl 6 into our brains here. :)

[13:23] *** bphillips joined
[13:23] <moritz_> and when we let it out again, it's squeezed in some places

[13:23] <masak> :)

[13:23] <masak> "handle with care"

[13:24] *** skids joined
[13:24] *** patspam joined
[13:25] <moritz_> Perl 6 - a product of initite mental rumination :-)

[13:27] *** tadzik left
[13:27] <masak> man, now I felt like implementing ENTER. :)

[13:27] <moritz_> and did you do it? :-)

[13:27] <masak> must... not... lose... focus...

[13:27] <masak> no, I'm being a good GSoC student right now :)

[13:27] <moritz_> masak++

[13:28] <moritz_> well, you have to make something up for missing the last status meeting :-)

[13:28] <masak> will probably do ENTER right after the http://gist.github.com/464349 SIC refactor.

[13:28] <masak> moritz_: yeah. :/ I'll likely not make the next one, either.

[13:29] <jnthn> masak: Can always pre-paste a rapport in the channel. :-)

[13:30] <masak> jnthn: that's provided I remember the #phasers meeting. :/

[13:31] *** uniejo left
[13:32] <[particle]> if only there were technology that existed to help you with that.

[13:33] *** tylercurtis joined
[13:33] <jnthn> That'd be stunning.

[13:35] <masak> [particle]: :P

[13:38] <masak> what do Bufs stringify to?

[13:38] <mathw> strings :P

[13:38] <masak> thank you.

[13:38] <masak> what strings?

[13:38] <masak> rakudo: say ~Buf.new

[13:38] <p6eval> rakudo 92a210: OUTPUTÂ«Buf()<0x79b30c0>â¤Â»

[13:39] <masak> is that right?

[13:39] <mathw> I assume the spec doesn't say, or you wouldn't be asking

[13:39] <[particle]> Bugs stringify with what encoding/charset?

[13:39] <arnsholt> If the binary contents are valid as a string in the current encoding, as a literal string might make sense

[13:40] <masak> arnsholt: that sounds slightly dangerous for some reason.

[13:40] <arnsholt> I s'pose

[13:40] <[Coke]> http://blogs.perl.org/users/brian_d_foy/2010/07/is-230-5-4-sometimes-it-is.html - would this trip up perl6?

[13:40] <masak> arnsholt: what if it's a .jpg blob which just happens to have only kosher characters?

[13:40] <masak> [Coke]: heard of Rat?

[13:40] <arnsholt> Then it'll be stringified as gibberish =)

[13:40] *** tadzik joined
[13:41] <moritz_> IMHO there are two ways Bufs can stringify:

[13:41] <moritz_> 1) like they do now

[13:41] <moritz_> 2) with a huge explosion

[13:41] <arnsholt> Something like "Buffer, 128 bytes" might make sense as well

[13:41] <masak> rakudo: say (200 * 1.15) % 5

[13:41] <p6eval> rakudo 92a210: OUTPUTÂ«0â¤Â»

[13:41] <masak> \o/

[13:41] <moritz_> any implicit decoding operation would do us no good

[13:41] <mathw> Arguably they should only convert to string representations of their internal data under explicit guidance

[13:41] <mathw> I think we're all agreeing on that :)

[13:41] <moritz_> ... which is what .decode does

[13:42] <masak> I'll go with "big explosion", then.

[13:42] <mathw> sounds good

[13:43] <moritz_> it will be less surprising in the case of   if $buf eq 'Foo' { ... }

[13:43] <masak> aye.

[13:43] <masak> moritz_++ # you'd make a good language designer! :)

[13:44] *** tadzik left
[13:45] <[Coke]> masak: that was more of a softball question intended to get someone motivated to post a response on bdf's blog. =-)

[13:45] <moritz_> URL?

[13:45] <[Coke]> http://blogs.perl.org/users/brian_d_foy/2010/07/is-230-5-4-sometimes-it-is.html - would this trip up perl6?

[13:45] <[Coke]> (resend)

[13:46] <pmichaud> looking

[13:46] <mathw> pah, floating point

[13:47] <moritz_> rakudo: say (200 * 1.15).perl

[13:47] * moritz_ replies

[13:47] <p6eval> rakudo 92a210: OUTPUTÂ«230/1â¤Â»

[13:47] <pmichaud> moritz++

[13:47] <pmichaud> I'd simply say that Perl 6 knows how to represent 1.15 exactly.   :-)

[13:48] <mathw> (Perl 6)++

[13:49] <mathw> (floating point)--

[13:49] <pmichaud> rakudo:   say (1.15).WHAT

[13:49] <p6eval> rakudo 92a210: OUTPUTÂ«Rat()â¤Â»

[13:54] <pmichaud> masak: (buf stringification)   I worked on implementing Stringy the other day, and it's not a trivial change

[13:54] <pmichaud> (it's not a hard change, it's just not trivial :)

[13:54] <frettled> Hmm, converting the cheatsheet to HTML + CSS is a nice challenge, progress is slow inbetween $ork_stuff, but it's slooowly improving.

[13:55] <pmichaud> masak: I don't know if that impacts at all the work you're doing on Buf

[13:55] <masak> pmichaud: might do, might not.

[13:55] <masak> pmichaud: right now I'm in file I/O, trying to round-trip.

[13:55] <masak> that basically involves making Parrot do the right thing through PIR.

[13:56] <pmichaud> really, in pir?  I would've thought that'd be abstracted away by now.

[13:57] <masak> possibly.

[13:57] <masak> I've not decided exactly how to do it yet.

[13:57] * pmichaud does his final "git pulls" before heading off for travels

[13:57] <masak> pmichaud: have a pleasant, relaxing  vacation!

[13:58] <pmichaud> I will

[13:58] <[particle]> pmichaud: aloha

[13:58] <moritz_> have -Ofun vacations :-)

[14:03] <pmichaud> I shall

[14:03] <pmichaud> see you all online :)

[14:04] * moritz_ wants to see you call offline in Pisa :-)

[14:05] <frettled> heh

[14:05] <frettled> pmichaud: enjoy!

[14:06] *** bphillips left
[14:07] *** patspam left
[14:18] *** timbunce left
[14:19] *** patspam joined
[14:22] *** gbacon joined
[14:23] *** timbunce joined
[14:26] <frettled> Now it's just a small matter of arranging the elements properly, some minor formatting, and a choice of colors: http://jani.at.ifi.uio.no/prog/P6/cheatsheet.shtml

[14:27] <frettled> (tested only in the latest official versions of Chrome, Firefox, Opera and Safari)

[14:27] <masak> frettled: nice start!

[14:28] <jnthn> Aye!

[14:28] <jnthn> frettled++

[14:28] * jnthn looks forward to seeing the final thing

[14:29] <frettled> â™¥ CSS3

[14:30] <IllvilJa> frettled: unicode ftw!

[14:30] <frettled> That, too!

[14:32] *** Ross left
[14:34] <masak> "It's 2010, and some things are nice, at least."

[14:36] <IllvilJa> masak: progress creeps upon us from everywhere... new versions of software is installed, and suddenly stuff like mobile broadband etc becomes RELIABLE!

[14:36] <masak> :)

[14:41] *** jaldhar left
[14:43] <ash_> frettled++ looks nice

[14:43] <dolmen__> frettled: could you add the Unicode symbols too?

[14:44] <pugssvn> r31590 | moritz++ | [t/spec] fudge advent 10 for rakudo 

[14:44] <pugssvn> r31591 | moritz++ | [t/spec] fudge autoviv tests for rakudo 

[14:45] *** xinming left
[14:46] <dolmen__> frettled: also, use italics for 'op'

[14:48] <dalek> rakudo: 1ef278d | moritz++ | t/spectest.data:

[14:48] <dalek> rakudo: run two more test files

[14:48] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1ef278dd0c4bd64076448c55e87b40ff207d46bd

[14:48] <dolmen__> frettled: put it on github ; I would like to contribute

[14:50] <moritz_> or in the pugs repo, where the .txt version is

[14:51] <moritz_> in docs/Perl6/

[14:51] * moritz_ decommutes

[14:54] <masak> wee, segfault!

[14:54] <masak> I'll take that as meaning "no, that's not the way this should be coded".

[15:05] <diakopter> "this" ambiguous ;)

[15:05] <diakopter> (or intentionally broad)

[15:08] *** diakopter sets mode: +v masak

[15:10] <tylercurtis> frettled: looks nice, but I'm getting lots of wasted whitespace(on Chrome 5.0.375.99 on OS X, if that's relevant).

[15:11] *** chitragupt joined
[15:12] *** eternaleye left
[15:13] *** TiMBuS|Away left
[15:13] *** TiMBuS joined
[15:17] <ash_> ping moritz_? 

[15:20] <frettled> dolmen__: I'll put it in the pugs repo when I find where I put my commit bit (I know it's around here somewhere!)

[15:21] <frettled> tylercurtis: I'm also getting lots of wasted whitespace, it's a bit of work to fix that, but we'll get there.

[15:21] <frettled> dolmen__, tylercurtis: thanks for the feedback!

[15:23] <frettled> Hrm, long time no checkout.  :)

[15:27] <frettled> Would it be sensible to create a Cheatsheet subdirectory, move cheatsheet.txt there, and place HTML+CSS there?

[15:28] * frettled considers the forgiveness option.  :)

[15:28] *** pmurias left
[15:28] *** wallberg joined
[15:33] *** masak left
[15:36] *** dolmen__ left
[15:37] <pugssvn> r31592 | jani++ | Moved text cheatsheet, added HTML+CSS version 

[15:39] * frettled needs to commit a few svn commands to memory ;)

[15:44] <moritz_> ash_: pong... just a sec

[15:55] *** macdaddy joined
[15:56] *** macdaddy is now known as Guest48289

[15:58] *** sail0r joined
[15:58] <frettled> Yay, perl6.org is updated with the new link, too, so that people can still use the text-based cheatsheet until the HTML+CSS one is, ehrm, okay.

[15:58] <sail0r> perl6: say 3;

[15:58] <p6eval> elf 31592, pugs, rakudo 92a210: OUTPUTÂ«3â¤Â»

[15:58] <ash_> rakudo: say 3; 

[15:58] <p6eval> rakudo 92a210: OUTPUTÂ«3â¤Â»

[15:58] <moritz_> wow, they agree :-)

[15:59] *** snarkyboojum left
[15:59] <frettled> heh

[16:00] <ash_> nqp: say(4); 

[16:00] <frettled> perl6: 3.say;

[16:00] <p6eval> nqp: OUTPUTÂ«4â¤Â»

[16:00] <p6eval> elf 31592, pugs, rakudo 92a210: OUTPUTÂ«3â¤Â»

[16:00] <ash_> o.0 i wrote 4

[16:00] <ash_> nqp: say(3); # facepalm

[16:00] <p6eval> nqp: OUTPUTÂ«3â¤Â»

[16:00] <ash_> even nqp agree's (almost) 

[16:00] <frettled> nqp: 3.say;

[16:00] <p6eval> nqp: OUTPUTÂ«Method 'say' not found for invocant of class 'Integer'â¤current instr.: '_block11' pc 33 (EVAL_1:12)â¤Â»

[16:04] *** ashleydev joined
[16:09] *** baest_ joined
[16:11] *** baest left
[16:16] *** zachy left
[16:19] *** dual left
[16:22] *** lue joined
[16:22] *** chitragupt left
[16:22] <lue> good $celestialposition, #perl6 !

[16:23] <tylercurtis> moritz_: Even Yapsi and Bennu agree on that one. :)

[16:23] *** zachy joined
[16:23] *** chitragupt joined
[16:24] *** cdarroch joined
[16:24] *** cdarroch left
[16:24] *** cdarroch joined
[16:25] *** ashleydev left
[16:27] <lue> gr. I can't git pull because of the newly added changes to operators.pm (specifically, merge conflict)

[16:28] <moritz_> tylercurtis: it seems to be the smallest common denominator

[16:28] <moritz_> :-)

[16:29] <tylercurtis> perl6: my $a = 3; say 3;

[16:29] <p6eval> elf 31592, pugs, rakudo 92a210: OUTPUTÂ«3â¤Â»

[16:29] <tylercurtis> moritz_: and that's the greatest common denominator. :)

[16:34] <lue> .oO(the greatest common denominator is 42)

[16:35] *** wallberg left
[16:35] <moritz_> perl6: say 43 # SCNR

[16:35] <p6eval> elf 31592, pugs, rakudo 92a210: OUTPUTÂ«43â¤Â»

[16:38] *** thebird left
[16:38] *** Ross joined
[16:41] <pugssvn> r31593 | lwall++ | [S05,S06] more refinements to {*} 

[16:46] <moritz_> phenny: ask masak any objections against migrating ufo to use MAIN sub?

[16:46] <phenny> moritz_: I'll pass that on when masak is around.

[16:47] *** ashleydev_ joined
[16:51] *** p6eval left
[16:51] <pugssvn> r31594 | moritz++ | [evalbot] less horrible safe mode for Rakudo 

[16:51] <moritz_> rakudo: say "alive"

[16:51] *** p6eval joined
[16:51] <moritz_> rakudo: say "alive"

[16:52] <p6eval> rakudo 1ef278: OUTPUTÂ«aliveâ¤Â»

[16:52] <moritz_> rakudo: say @*INC.perl

[16:52] <p6eval> rakudo 1ef278: OUTPUTÂ«["lib", "/home/p6eval/.perl6/lib", "/home/p6eval//p1/lib/parrot/2.5.0-devel/languages/perl6/lib", ".", "lib"]â¤Â»

[16:52] <moritz_> rakudo: run('echo pwnd')

[16:52] *** ashleydev_ left
[16:52] <p6eval> rakudo 1ef278:  ( no output )

[16:53] <moritz_> rakudo: run('echo pwnd')

[16:53] <p6eval> rakudo 1ef278:  ( no output )

[16:54] <lue> rakudo: $a = run('echo pwnd'); say $a;

[16:54] <p6eval> rakudo 1ef278: OUTPUTÂ«===SORRY!===â¤Symbol '$a' not predeclared in <anonymous> (/tmp/wJwdhPQbfu:13)â¤Â»

[16:55] <moritz_> now it's just so slow that each possibly unsafe operation times out :-)

[16:55] *** ashleydev joined
[16:56] <tylercurtis> rakudo: my $a = run('echo pwnd'); say $a;

[16:56] <p6eval> rakudo 1ef278:  ( no output )

[16:56] <moritz_> I guess I need to precompile Safe.pm

[16:56] *** TiMBuS left
[17:00] *** dakkar left
[17:03] <diakopter> hm

[17:03] *** kensanata joined
[17:03] <moritz_> rakudo: * *

[17:03] <frettled> moritz_: yes, I don't think you can rely on computers to be too slow to execute Rakudo runtimes forever.

[17:03] <p6eval> rakudo 1ef278: OUTPUTÂ«===SORRY!===â¤Confused at line 13, near "* *"â¤Â»

[17:05] <lue> rakudo: *; say "hi"

[17:05] <p6eval> rakudo 1ef278: OUTPUTÂ«hiâ¤Â»

[17:05] <lue> my $a = 2; my $b = $a * *; say $b;

[17:06] <lue> rakudo: my $a = 2; my $b = $a * *; say $b;

[17:06] <p6eval> rakudo 1ef278: OUTPUTÂ«_block114â¤Â»

[17:06] <lue> .oO(apathetic math is weird)

[17:08] <pugssvn> r31595 | lwall++ | [S06] = should be := 

[17:08] <ash_> rakudo: my $a = 2 * *; say $a(3);

[17:08] <p6eval> rakudo 1ef278: OUTPUTÂ«6â¤Â»

[17:08] *** proller left
[17:09] <TimToady> jnthn or pmichaud: how does the callsame "macro" get the capture of the current routine?  this is something we should probably standardize

[17:09] <lue> (I'm surprised it dwimmed, actually.)

[17:11] *** p6eval left
[17:11] *** p6eval joined
[17:11] <pugssvn> r31596 | moritz++ | [evalbot] experimental yapsi target 

[17:11] *** p6eval left
[17:11] *** p6eval joined
[17:12] <moritz_> yapsi: say 3

[17:12] <p6eval> yapsi: OUTPUTÂ«Can't find ./Yapsi in @*INCâ¤in Main (file <unknown>, line <unknown>)â¤Â»

[17:12] <dalek> rakudo: 8978801 | moritz++ | build/Makefile.in:

[17:12] <dalek> rakudo: compile Safe.pm, and install the .pir version too

[17:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/897880192ed655b2f6933d180bcb972ed1a3bdc4

[17:13] *** p6eval left
[17:13] <pugssvn> r31597 | moritz++ | [evalbot] yapsi needs PERL6LIB 

[17:13] *** p6eval joined
[17:13] <moritz_> yapsi: say 3

[17:13] <p6eval> yapsi: OUTPUTÂ«3â¤Â»

[17:14] <diakopter> ooo

[17:14] <moritz_> this is the moment we've all been waiting for!

[17:14] <moritz_> erm, at least masak did :-)

[17:14] <diakopter> it slow-ish

[17:14] <frettled> moritz_: is yapsi included in the perl6-thingy?

[17:14] <moritz_> frettled: no

[17:15] <moritz_> diakopter: it is. it's another layer on top of rakudo :-)

[17:15] <frettled> jolly joy :)

[17:15] * lue ponders an English <â€“> Perl 6 translator

[17:15] <diakopter> moritz_: ohhh.  oh yeah.  I knew that, someday ago

[17:16] <frettled> lue: that's _almost_ â†â†’

[17:16] <moritz_> but it means that any rakudo optimizations directly speed up yapsi too (once it runs on current Rakudo and not alpha)

[17:23] *** pmurias joined
[17:23] <pmurias> TimToady: ping

[17:26] <pmurias> TimToady: could we change the keys in ALL to some sort of unique identifiers as the files names are causing heaps of problems?

[17:27] <pmurias> * $ALL

[17:27] * [Coke] wonders what's stopping yapsi from running on rakudo-mater.

[17:27] <[Coke]> *master

[17:30] *** dual joined
[17:36] *** xinming_ joined
[17:38] *** xinming_ is now known as xinming

[17:40] *** dju_ joined
[17:40] *** dju left
[17:41] *** Kodi joined
[17:43] <pugssvn> r31598 | Kodi++ | [S32/Temporal] Clarified the distinction between &time and &now, specified what formatters and time zones should actually do, and dropped some formatting methods. 

[17:43] <Kodi> Comments welcome.

[17:48] *** cls_bsd left
[17:50] *** rv2733 joined
[17:59] <ingy> rakudo: my $n = "Ongy"; $n ~~ s/O/I/; say $n

[17:59] <p6eval> rakudo 897880: OUTPUTÂ«Ingyâ¤Â»

[18:04] *** eiro left
[18:07] *** kensanata left
[18:07] <ingy> rakudo: my $v = "a\nb\nc\n\n"; $v ~~ s/\n+$/\n/; say $v;

[18:07] <p6eval> rakudo 897880: OUTPUTÂ«aâ¤bâ¤câ¤â¤Â»

[18:07] <[particle]> Kodi: "...except that it *also* includes a fractional part."  -- limits ambiguity

[18:08] <ingy> rakudo: my $v = "a\nb\nc\n\n\n\n"; $v ~~ s/\n+$/\n/; say $v;

[18:08] <p6eval> rakudo 897880: OUTPUTÂ«aâ¤bâ¤câ¤â¤Â»

[18:09] <Kodi> [particle]: Agreed.

[18:09] <ingy> anyone seen: Null PMC access in find_method('new')

[18:09] <ingy> on a subst like $v ~~ s/\n+$/\n/

[18:17] *** eiro joined
[18:17] <ingy> rakudo: say Nil

[18:17] <p6eval> rakudo 897880: OUTPUTÂ«â¤Â»

[18:17] <diakopter> my poor p6eval vps.

[18:17] <ingy> rakudo: say Nil.perl

[18:18] <p6eval> rakudo 897880: OUTPUTÂ«()â¤Â»

[18:18] <diakopter> rakudo: say 'hi' ~~ s/\n+$/\n/

[18:18] <p6eval> rakudo 897880:  ( no output )

[18:18] <diakopter> (timeout)

[18:20] <ingy> rakudo: my $v = 'hi'; $v ~~ s/\n+$/\n/; say $v

[18:20] <p6eval> rakudo 897880: OUTPUTÂ«hiâ¤Â»

[18:20] <ingy> rakudo: my $v = {}; $v ~~ s/\n+$/\n/; say $v

[18:21] <p6eval> rakudo 897880: OUTPUTÂ«â¤Â»

[18:21] <ingy> rakudo: my $v = Str.new; $v ~~ s/\n+$/\n/; say $v

[18:21] <p6eval> rakudo 897880: OUTPUTÂ«â¤Â»

[18:22] <ingy> rakudo: Str.new('huh')

[18:22] <p6eval> rakudo 897880: OUTPUTÂ«flattened parameters must be a hash or arrayâ¤  in main program body at line 13:/tmp/U6kZapiCy9â¤Â»

[18:35] *** snarkyboojum joined
[18:36] <tylercurtis> Macros are supposed to return either strings or ASTs, right?

[18:38] <Tene> tylercurtis: that's right.

[18:39] <lue> rakudo: my $1number = 3; say $1number # testing vars beginning w/ digit

[18:39] <p6eval> rakudo 897880: OUTPUTÂ«===SORRY!===â¤Redeclaration of symbol $ at line 13, near "number = 3"â¤Â»

[18:39] *** justatheory joined
[18:39] <lue> O.o

[18:41] <tylercurtis> Is there any way to get an AST in the spec other than quasiquoting?

[18:42] <Tene> The AST isn't actually specced.

[18:42] <Tene> Quasiquoting will give you an implementation-dependant AST.

[18:42] <Tene> You could also just instantiate AST object directly.

[18:43] <tylercurtis> But, since the AST isn't described in a spec, that doesn't seem like a very portable option.

[18:43] <tylercurtis> s/a spec/the spec/

[18:44] <pmurias> the intent of the spec is that quasiquoting should be used

[18:44] <Tene> tylercurtis: that's right.

[18:45] <Tene> tylercurtis: You could always try something like quasiquoting something else, examining the result, and building something that looked like the result, but quasiquoting is likely a lot simpler than that.

[18:47] <tylercurtis> This is really just idle curiosity. I was wondering how implementing the "use COBOL;" that S02 jokes about would work.

[18:48] * lue wonders if macros work yet in rakudo.

[18:48] <tylercurtis> I don't think so.

[18:48] <[particle]> rakudo: macro works { } # doesn't

[18:48] <p6eval> rakudo 897880: OUTPUTÂ«Could not find sub &worksâ¤  in main program body at line 13:/tmp/njapY_Bcttâ¤Â»

[18:49] <Kodi> lue: If most Perl 6 features will be implemented by Christmas, macros will be implemented by Boxing Day.

[18:50] <lue> :)

[18:51] * pmurias hates when STD hangs up

[18:54] * moritz_ hates it when any software hangs

[18:55] <diakopter> what's Boxing Day

[18:55] <moritz_> Dec 26th

[18:55] <lue> Day after christmas, if I remember right.

[18:56] <diakopter> oh

[18:56] <moritz_> that very much depends on your definition of "christmas" :-)

[18:57] <moritz_> for me, christmas is usually the 24th

[18:58] <ingy> rakudo: class Foo { my $.x is rw }; my $o = Foo.new; $v = "O HAI"; $o.x = $v; say ">>" ~ $o.x;

[18:58] <p6eval> rakudo 897880: OUTPUTÂ«===SORRY!===â¤Symbol '$v' not predeclared in <anonymous> (/tmp/ZjUDGoQ7AN:13)â¤Â»

[18:58] <ingy> rakudo: class Foo { my $.x is rw }; my $o = Foo.new; my $v = "O HAI"; $o.x = $v; say ">>" ~ $o.x;

[18:59] <p6eval> rakudo 897880:  ( no output )

[18:59] <ingy> rakudo: class Foo { my $.x is rw }; my $o = Foo.new; my $v = "O HAI"; $o.x = $v; say ">>" ~ $o.x;

[18:59] <p6eval> rakudo 897880:  ( no output )

[18:59] <ingy> :'(

[19:00] <moritz_> seems p6eval is a bit broken

[19:00] <diakopter> did you remove the Safe.pm inlining?

[19:00] <ingy> everything feels broken

[19:00] <moritz_> rakudo: class Foo { }; say 3

[19:01] <moritz_> diakopter: I now have inlining and Safe.pm loading

[19:01] <p6eval> rakudo 897880:  ( no output )

[19:01] <diakopter> ?

[19:01] <diakopter> in evalbot.pl it's still inlined as I left it

[19:01] <diakopter> the contents of Safe.pm, I mean

[19:01] <moritz_> diakopter: r31594

[19:02] <moritz_> the old approach stopped working since most built-ins are lexicals now

[19:03] <diakopter> ok

[19:03] <moritz_> but it seems the new approach has to be fully inlined too

[19:03] <moritz_> :(

[19:04] <moritz_> using Safe + another module leads to infinite loops

[19:04] <diakopter> hrm

[19:04] <diakopter> istr that was why I inlined it previously

[19:04] *** cono left
[19:05] <moritz_> right, which I forgot :(

[19:05] <diakopter> :) me too

[19:05] <diakopter> I guess I shoulda noted it in a comment or two

[19:06] *** cono joined
[19:06] <moritz_> I'll do that now

[19:09] <Kodi> rakudo: class C { my $n = 5; has $.x = $n; }; my $i = C.new; say $i.x;

[19:09] <diakopter> (timeout)

[19:09] <p6eval> rakudo 897880:  ( no output )

[19:09] <Kodi> Ah.

[19:09] <diakopter> (b/c of what we were saying above)

[19:09] <pugssvn> r31599 | moritz++ | [evalbot] "use Safe" makes rakudo loop when declaring a class. So inline it instead. diakopter++ 

[19:09] *** p6eval left
[19:09] <Kodi> Yeah.

[19:09] *** p6eval joined
[19:09] *** diakopter sets mode: +v p6eval

[19:10] <diakopter> rakudo: class C { my $n = 5; has $.x = $n; }; my $i = C.new; say $i.x;

[19:10] *** colomon joined
[19:10] <p6eval> rakudo 897880:  ( no output )

[19:10] <moritz_> rakudo: say 'alive'

[19:10] <p6eval> rakudo 897880: OUTPUTÂ«aliveâ¤Â»

[19:10] <moritz_> 10541 CPU time limit exceeded | PERL6LIB=lib ../p/bin/perl6 /tmp/Ng0yDI8zMr >> /tmp/Y3hdJXQ_M4 2>&1

[19:10] <moritz_> rakudo: class A { }; say "alive"

[19:10] <p6eval> rakudo 897880: OUTPUTÂ«aliveâ¤Â»

[19:11] <lue> rakudo: my @a = 1,2,3; @a[$_+3] := @a[$_] for ^3; say @a.perl

[19:11] <p6eval> rakudo 897880: OUTPUTÂ«[1, 2, 3, 1, 2, 3]â¤Â»

[19:11] <Kodi> rakudo: class A { }; my $x = A.new; say "alive"

[19:11] <p6eval> rakudo 897880: OUTPUTÂ«aliveâ¤Â»

[19:12] <Kodi> rakudo: class C { has $.x = 5; }; my $i = C.new; say $i.x;

[19:12] <p6eval> rakudo 897880: OUTPUTÂ«5â¤Â»

[19:12] <Kodi> rakudo: class C { my $n = 5; has $.x = $n; }; my $i = C.new; say $i.x;

[19:13] <p6eval> rakudo 897880:  ( no output )

[19:14] <dalek> rakudo: e58b166 | (Solomon Foster)++ | src/core/ (2 files):

[19:14] <dalek> rakudo: Tweak Real.atan2 and Num.atan2 so they can handle $x's which are not of the 

[19:14] <dalek> rakudo: ideal type.

[19:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e58b166d508acea739c863e944f05a2d3030bfc8

[19:22] *** eiro left
[19:23] *** timbunce left
[19:28] *** eiro joined
[19:29] *** colomon left
[19:29] <Kodi> rakudo: say 0.fmt('%02d'); say abs(0).fmt('%02d');

[19:29] <p6eval> rakudo 897880: OUTPUTÂ«00â¤0â¤Â»

[19:29] <Kodi> Am I doing something wrong there?

[19:33] <[particle]> rakudo: say (abs(0)).fmt('%02d'); # ooc

[19:33] <p6eval> rakudo 897880: OUTPUTÂ«00â¤Â»

[19:34] <[particle]> rakudo: say fmt('%02d'), abs(0)

[19:34] <p6eval> rakudo 897880: OUTPUTÂ«Could not find sub &fmtâ¤  in main program body at line 20:/tmp/fTFailGxTVâ¤Â»

[19:34] <[particle]> ok, so it's not a sub, just a method, but abs(0).fmt is taking the abs of (0).fmt(...) it seems

[19:35] <Kodi> [particle]: Looks like it. Pretty counterintuitive.

[19:35] <[particle]> well, i would have written 0.abs.fmt to start

[19:35] <[particle]> method chaining looks correcterrer there

[19:36] <Kodi> Indeed, I forgot abs was a method.

[19:36] <[particle]> but, i'll agree, i didn't expect that result

[19:39] *** baest_ left
[19:41] * cognominal tries to grok the llsig_element. sig hell? sieg heil?

[19:42] <cognominal> it's hot, my pun engine got in overdrive.

[19:42] <jnthn> cognominal: It describes one parameter in the sig.

[19:42] <cognominal> I got that right :)

[19:43] <jnthn> Other than that it's just a bunch of stuff. :-)

[19:43] <jnthn> It's what bind.c does with it that's interesting. :-)

[19:43] <cognominal> indeed, that's what I trie to undeerstand.

[19:44] <cognominal> *try

[19:45] *** daemon joined
[19:45] <cognominal> jnthn,  when a parameter is a signature, does it affact the candidate selection or only the binding?

[19:46] <cognominal> *affect

[19:46] *** masak joined
[19:46] <masak> ahojte!

[19:46] <phenny> masak: 16:46Z <moritz_> ask masak any objections against migrating ufo to use MAIN sub?

[19:46] <jnthn> "is a signature"

[19:46] <jnthn> ?

[19:46] <jnthn> cognominal: As in when it has a sub-signature?

[19:46] <masak> moritz_: no objections. patch welcome.

[19:46] <jnthn> cognominal: In that case both

[19:46] <tylercurtis> yapsi: say 'Look what moritz_ did, masak!';

[19:46] <p6eval> yapsi: OUTPUTÂ«Could not parseâ¤Â»

[19:46] <jnthn> cognominal: look in perl6multisub.pmc

[19:46] <masak> \o/

[19:46] <cognominal> yes

[19:46] <masak> moritz_++

[19:46] * tylercurtis didn't think that would work.

[19:47] <jnthn> cognominal: look for bindability check or something like that.

[19:47] <jnthn> yapsi: !d9_++!!!

[19:47] <masak> yapsi: my $a = 3; while --$a { my $b; say $b; $b = 42 }

[19:47] *** justatheory left
[19:47] <p6eval> yapsi: OUTPUTÂ«Could not parseâ¤Â»

[19:47] <p6eval> yapsi: OUTPUTÂ«Any()â¤42â¤Â»

[19:47] <jnthn> fuzzing fel

[19:47] <pugssvn> r31600 | Kodi++ | [S32/Temporal] Prose edit; "C<Seq>" -> "list" 

[19:47] <cognominal> jnthn, but the answer is yes or no?

[19:48] <jnthn> cognominal: yes but :-)

[19:48] <masak> I think I've figured out how to do FIRST and LAST blocks.

[19:48] <jnthn> cognominal: It affects the candidate selection

[19:48] <lue> hai masak o/

[19:48] <jnthn> cognominal: But the candidate selection uses "can this bind" as its criteria, iirc.

[19:48] <masak> my favorite lue! hi! \o

[19:48] <jnthn> .oO( this is where I don't ask masak how many lues he knows ;-) )

[19:48] <masak> jnthn: 1.

[19:49] <jnthn> <grin>

[19:49] <lue> masak: you've got yourself someone who can test Buf! [might actually be cool to use Buf for a memory map, instead of ye olde Array]

[19:49] <masak> lue: I'm working on Buf and file I/O as we speak.

[19:50] <lue> (and other Binary (including I/O) type things) :)

[19:50] <cognominal> that's what I fear, I feel that perl6 is strayed to far away for haskell pattern matching. I know we are in a dynamic object environment so this is way more complex. But if we don't get haskell pattern matching as a subset of feature, I would not find MMD very compelling.  But I may not be representative of the average user.

[19:50] <masak> I have a question for #parrot about a segfault that's blocking me. preparing for that now.

[19:50] <cognominal> *has strayed

[19:50] *** cdarroch left
[19:51] <cognominal> *has strayed too far away from

[19:51] *** Kodi left
[19:52] * lue imagines #parrot as being a very unforgiving board of members sitting behind a desk kilometers above the ground, with you behind a dinky lectern

[19:56] *** baest joined
[19:56] *** eternaleye joined
[19:57] <jnthn> cognominal: I'm not convinced it can't be used for that, your examples just had too much ambiguity for the dispatcher to resolve without you giving it a few more hints.

[19:57] *** envi^home left
[19:57] *** shade\ left
[19:58] *** tadzik joined
[19:59] <cognominal> I certainly don't know enough already to emit anything but gut feelings.  

[20:00] <ash_> are return types included in signatures? (eg. :(Int $a --> Bool)

[20:00] <cognominal> probably some blog entry from jonathan giving exemple how to walk  some structures (arrays,  hashes)  will help. hint! hint!.

[20:00] <ash_> ) 

[20:00] *** timbunce joined
[20:00] <ash_> std: :(Int $a)

[20:00] <p6eval> std 31599: OUTPUTÂ«ok 00:01 113mâ¤Â»

[20:00] <jnthn> cognominal: :-)

[20:00] <ash_> std: :(Int $a --> Bool)

[20:00] <p6eval> std 31599: OUTPUTÂ«ok 00:01 110mâ¤Â»

[20:01] <jnthn> cognominal: I'll try and come up with something on that.

[20:01] *** cdarroch joined
[20:01] *** cdarroch left
[20:01] *** cdarroch joined
[20:01] <cognominal> ash_, I think the spec has some speculation about that (and marked as such)

[20:01] <cognominal> jnthn, I believe it will interest many people besieds me.

[20:01] <jnthn> lol spec-ulation

[20:01] <cognominal> MMD is a difficult subject.

[20:03] <ash_> rakudo: my $a = :(Int $a --> Bool); 

[20:03] <p6eval> rakudo 897880:  ( no output )

[20:03] <ash_> rakudo: my $a = :(Int $a --> Bool); say $a.WHAT;

[20:03] <p6eval> rakudo 897880: OUTPUTÂ«Signature()â¤Â»

[20:08] <cognominal> ORIGIN late 16th cent.: from Latin speculat- â€˜observed from a vantage point,â€™ from the verb speculari, from specula â€˜watchtower,â€™ from specere â€˜to look.â€™

[20:12] *** buubot left
[20:12] *** buubot joined
[20:13] <[Coke]> lue; ah, so it's like #perl6 for parrot folks!

[20:14] <masak> [Coke]: I've found neither #parrot nor #perl6 people to be 'unforgiving' :)

[20:14] <[Coke]> masak: merely trying to counter parrot fud. :P

[20:15] <masak> by all means.

[20:15] <lue> the way masak worded his message made me think of that.

[20:15] <masak> I did not mean to imply any such thing.

[20:16] <masak> preparing questions is a nice habit, is all.

[20:16] <masak> though whether it helped in this case remains to be seen :)

[20:16] <lue> it's a far-fetched conclusion. [So of course it's my first thought :)]

[20:18] <lue> maybe it's looking through piles of info on the NES. [Maybe next time I should a project that doesn't require so much planning and foresight :)]

[20:18] <arnsholt> masak: I try to be prepared as well

[20:18] <lue> s/should a/should pick a/

[20:18] <arnsholt> Always nice to be reasonably sure you're right about what's wrong

[20:19] <frettled> lue: I'm still stuck in the world where NES means Nintendo Entertainment System.  Help!

[20:19] <masak> frettled: er. that's what he means.

[20:19] <arnsholt> I think it still means Nintendo Entertainment System, in this case =)

[20:20] *** shade_ joined
[20:20] <frettled> masak: phew

[20:22] <lue> (I'm stuck on how to implement the clock cycles right now) And what _*fun*_ those mappers will be.

[20:22] <lue> It's quite a complex little world, it deserves an essay or two :)

[20:25] <moritz_> masak: I have a patch for ufo to use MAIN sub, but I'm not sure you'll like it :-)

[20:25] <masak> moritz_: thanks for being so honest about it :)

[20:25] <moritz_> it puts everything into MAIN

[20:26] <moritz_> even subroutines

[20:26] <masak> that's OK.

[20:26] <moritz_> because many of them are closures

[20:26] <masak> aye.

[20:26] <moritz_> apart from that, it's all trivial

[20:26] <masak> I've recently come around to that kind of development.

[20:27] <moritz_> so, should I push?

[20:27] <masak> go ahead.

[20:27] <moritz_> pushed

[20:27] <moritz_> all tests pass :-)

[20:27] <masak> jnthn: ping

[20:27] <masak> moritz_++

[20:27] <moritz_> rakudo: say ?all()

[20:27] <p6eval> rakudo 897880: OUTPUTÂ«1â¤Â»

[20:27] <masak> love the commit message :)

[20:28] <masak> rakudo: say ?all

[20:28] <jnthn> masak: gnip

[20:28] <p6eval> rakudo 897880: OUTPUTÂ«1â¤Â»

[20:28] <masak> jnthn: lol segfault: http://gist.github.com/469980

[20:28] <jnthn> OMG PARTY!

[20:28] <masak> jnthn: line 25.

[20:28] <masak> jnthn: on #parrot, we determined that even pio.'print'('OMG HAI') segfaults.

[20:29] <moritz_> it's that damn lolspeak

[20:29] <masak> jnthn: so there's something I'm not supposed to do with pio, $pio or $!PIO that I'm doing.

[20:29] <masak> jnthn: any idea what?

[20:29] <moritz_> that insults the intelligence of our nifty parrot

[20:29] <jnthn> masak: Yes, I knwo why

[20:29] <masak> oh phew

[20:29] <jnthn> masak: This is why every other method call in IO.pm on $!PIO is written in Perl 6.

[20:29] <[Coke]> wozzit?

[20:30] <jnthn> masak: Anyway, the answer is...let me check because it got changed very recently by pmichaud++

[20:30] <masak> :)

[20:31] <jnthn> [Coke]: We put PMCs in transparent containers.

[20:31] <jnthn> [Coke]: If we don't de-containerize invocants, then PCCMETHODs get very very upset.

[20:31] *** gbacon left
[20:32] <jnthn> masak: deref_unless_object

[20:32] <jnthn> pio = find_lex '$pio'

[20:32] <jnthn> pio = deref_unless_object pio

[20:32] <jnthn>  pio.'print'(s)   # hopefully we don't segfault

[20:32] <[Coke]> jnthn: ok. segfaulting is probably a little harsh, though.

[20:32] <masak> jnthn: thank you thank you! you're a good mentor! \o/

[20:32] <jnthn> [Coke]: Unfortunately, there's not a lot we can easily do to resolve it.

[20:33] <[Coke]> but that makes it a much lower priority. =-)

[20:33] <masak> jnthn: ah, does pir::descalarref__PP($!PIO) do about the same thing?

[20:33] <jnthn> [Coke]: It segfaults because it goes for the data pointer of the PMC wrapper

[20:33] <jnthn> masak: Yes and would work just the same here

[20:33] <[Coke]> I hate that pointer. =-)

[20:33] <jnthn> masak: You can use that too

[20:33] *** ash_ left
[20:34] <[Coke]> jnthn++

[20:34] <jnthn> masak: The variant I gave you only does it if needed

[20:34] <jnthn> descalarrer does it always, unconditionally

[20:34] <jnthn> In your case, you know you need to so you can do that

[20:34] <lue> afk

[20:34] <jnthn> masak: Whenever you do a method call, we do this deref anyways.

[20:35] <masak> hokay.

[20:35] <jnthn> As in, from Perl 6

[20:35] *** clintongormley left
[20:35] <jnthn> We emit the deref_unless_object op

[20:36] <masak> I had fun figuring out today while swimming how FIRST and LAST might work in Yapsi.

[20:37] <masak> they're slightly more complex than I thought, especially LAST.

[20:37] * jnthn gets a sinking feeling

[20:37] <masak> but at least I know *a* way to do either now.

[20:37] <moritz_> I guess LAST has to do funny things to preserve the value of lexicals

[20:37] <masak> moritz_: closure.

[20:37] <moritz_> heh

[20:37] <masak> moritz_: I don't want to do anything more 'funny' at this point.

[20:37] <masak> this is what closures are made for.

[20:39] <masak> so `while $cond { LAST { say "OH HAI" } }` translates to `while $cond { $sekrit-var = { say "OH HAI" } }; if $loop-ran-at-all { $sekrit-var() }`

[20:42] <frettled> I think you just stunned the world.

[20:42] <moritz_> you notice that $loop-ran-at-all can be the same as $sekrit-var ?

[20:43] <masak> and probably should :)

[20:43] <masak> it cannot, however, be the same as $first-block-has-run, since there might be a 'last' in a FIRST block.

[20:43] <masak> oh! and that reminds me.

[20:44] <masak> PRE { ...; POST { ... } } has a special meaning.

[20:44] <jnthn> omg

[20:44] <jnthn> ...

[20:44] <jnthn> It means "the person who wrote this is nuts"? :-)

[20:44] <masak> do any of the other FIRST/LAST, ENTER/LEAVE blocks have special meaning in a corresponding way?

[20:45] <masak> jnthn: this is what I do when I have fun! :)

[20:45] <frettled> jnthn: masak is scaring me!

[20:45] <jnthn> masak: huh, I just drink beer and design meta-models.

[20:46] <jnthn> Completely typical fun activities.

[20:46] <jnthn> ;-)

[20:46] <masak> jnthn: I wrote the above completely sober. I don't need the beer. :P

[20:46] <frettled> Evidently not.

[20:46] <jnthn> I need the beer after reading it. :P

[20:46] <masak> I'm my own Ballmer peak.

[20:46] <jnthn> masak: What's the special meaning, ooc?

[20:46] <frettled> No other substances that are illegal in most civilized nations?

[20:47] <masak> jnthn: it's that the POST block still acts like it wasn't nested in the PRE block, except for the lexical nesting.

[20:47] <masak> jnthn: pretty neat.

[20:47] <frettled> oh!

[20:47] <masak> TimToady++

[20:47] <jnthn> masak: I didn't find that in S04.

[20:47] <jnthn> masak: But...OK. :-)

[20:47] <frettled> masak: that even makes a twisted kind of sense

[20:47] <masak> jnthn: it's in there somewhere.

[20:47] <cognominal> jnthn, beware of meta stasis, it soon proliferate beyon control.

[20:47] *** eternaleye left
[20:48] <masak> cognominal: well, you might argue that being a strange loop, all meta-models are already 'out of control' :)

[20:49] * masak writes his first binary file locally

[20:49] <masak> \o/

[20:49] <masak> now for reading it.

[20:49] <jnthn> Yay!

[20:50] *** ash_ joined
[20:50] *** crazycaw joined
[20:50] <moritz_> masak: I've moved about half of the functions in ufo out of MAIN, and feel much better now :-)

[20:50] <masak> :)

[20:51] *** crazycaw left
[20:51] <masak> moritz_: looks good.

[20:51] <moritz_> masak: thanks, good to hear

[20:52] <masak> moritz_: mind if I change the 'note ... if' on line 61 to an 'if ... { note }'? I like to reserve statement_mod_cond for control flow.

[20:53] <moritz_> masak: go right ahead

[20:53] <masak> also, is the double blank line on 108, 109 intentional?

[20:53] <jnthn> afk for a little

[20:53] <moritz_> probably not

[20:53] <masak> ok, fixing.

[20:56] <masak> ah, 'topo-sort' is a new name, too. I like it.

[20:57] <moritz_> and with s/modules/things/ in it it's quite generic

[20:57] <masak> indeed. not that ufo stands to gain from that, but still :)

[20:57] <masak> by the way, would anyone like to design a ufo logo?

[20:58] <frettled> masak: the theme would be very obvious, I think

[20:58] <masak> I'm thinking this, only clearer: http://www.babble.com/CS/blogs/strollerderby/ufo05.jpg

[20:58] *** sail0r left
[20:58] <masak> actually, the more stylistic, the better, I suspect.

[20:59] <frettled> masak: mm

[21:03] <frettled> Too bad I don't know how to use e.g. Adobe Illustrator, because I think I know what it might look like.

[21:04] <moritz_> frettled: then use inkscape :-)

[21:04] <masak> +1

[21:06] *** justatheory joined
[21:09] <moritz_> or draw it with a pencil, and scan it

[21:10] <pugssvn> r31601 | lwall++ | [S04] simplify definition of successful return to be context agnostic 

[21:10] <pugssvn> r31601 | define class-level PRE/POST to be submethods that are called like BUILD/DESTROY

[21:11] <masak> has anyone else noticed a correlation between things we bitch about here on the channel, and some spec changes? :P

[21:12] <TimToady> you're imagining things

[21:12] <frettled> moritz_: There's another problem, and that is that I'm not a graphical designer.  :)

[21:12] <Tene> I haven't noticed a correlation with spec changes and the things that *I* bitch about in here.

[21:12] <frettled> I have noticed a correlation with spec changes and the things that TimToady commits.

[21:12] <masak> Tene: then clearly, you're bitching up the wrong tree. :P

[21:13] * TimToady has settled in at our new offices in Santa Clara, in my spiffy new cubicle

[21:14] <frettled> TimToady: I hope there's nothing fishy about it.

[21:15] <TimToady> we just outgrew our old tank because someone fed us too much

[21:15] <moritz_> so the feds were involved? :-)

[21:15] <cognominal> outgrown our think tank?

[21:15] * [Coke] wonders where timtoady works these days.

[21:16] <Tene> TimToady: have you figured out where the "default parsing rule" for each grammatical category, as described in the macros section of S06, comes from yet, or considered my proposal that it come from the proto regex body?

[21:16] <[Coke]> . o O (obviously santa clara. thank you, pedants. =-)

[21:16] <Tene> Santa Clara is very close to where I live.

[21:17] * moritz_ would be surprised if tehre were just one Santa Clara in the US

[21:17] <TimToady> Tene: all this {*} work in the proto is, in part, to make that possible

[21:17] <Tene> :)

[21:18] *** skids left
[21:18] *** cdarroch left
[21:19] <masak> TimToady: I like the new definition of success better.

[21:19] <TimToady> especially since the old one was nonsensical

[21:19] <masak> yeah :)

[21:19] <TimToady> insofar as we don't know context at that point

[21:21] *** timbunce left
[21:21] <Tene> TimToady: I keep forgetting that you live in the area.  Let me know if you ever want to food and/or hacking sometime.

[21:22] <Tene> Well, I guess that I live in the area now.  You were here before I was.

[21:24] <TimToady> since '91

[21:25] *** dolmen joined
[21:26] *** timbunce joined
[21:27] <TimToady> [Coke]: http://www.netlogicmicro.com

[21:29] <masak> TimToady: do you write any Perl at work? :)

[21:31] <TimToady> well, I don't write all Perl at work.  :P

[21:32] <masak> C? Visual Basic? LOLCODE?

[21:32] <moritz_> English?

[21:36] *** ruoso left
[21:40] *** lue left
[21:43] <TimToady> jnthn: I expect fail to set $!, or you can't say:  do-something() // warn "Couldn't do something: $!";

[21:45] <jnthn> TimToady: That's $! in the caller though?

[21:45] <pugssvn> r31602 | pmurias++ | [mildew] load SMOP only when it's needed to avoid cicular dependency 

[21:45] <jnthn> TimToady: I was talking about in the callee.

[21:46] <pugssvn> r31603 | pmurias++ | [mildew] new Cso backend, new YOU_ARE_HERE using setting 

[21:46] <pugssvn> r31604 | pmurias++ | [mildew] add AST::Branch::simplified 

[21:46] <pugssvn> r31605 | pmurias++ | [mildew] fix dist.ini 

[21:46] <pugssvn> r31606 | pmurias++ | [smop] fix the building 

[21:46] <pugssvn> r31607 | pmurias++ | say 1 works in mildew with all components installed 

[21:47] *** masak left
[21:47] *** masak joined
[21:47] <pmurias> diakopter, moriz_: who is responsible for the evalbot?

[21:47] <pmurias> * mortiz_

[21:47] <masak> yapsi: say 42

[21:47] <p6eval> yapsi: OUTPUTÂ«42â¤Â»

[21:47] <masak> \o/

[21:48] <masak> moritz_++

[21:48] <pmurias> mildew: say 42

[21:48] <p6eval> mildew: OUTPUTÂ«Can't open perl script "mildew": No such file or directoryâ¤Â»

[21:48] * pmurias should fix that soon

[21:48] <masak> yapsi: while 42 { say 42 }

[21:48] <p6eval> yapsi: OUTPUTÂ«42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â¤42â

[21:49] <pmurias> TimToady: i'll be now turning ~/p6/src/STD-dist into an acceptable STD, how do you want the files to be organized

[21:49] <pmurias> ?

[21:50] *** lue joined
[21:50] <masak> seems p6eval cut Yapsi off mid-byte.

[21:50] <lue> ohai!

[21:52] <lue> masak: good job on Buf & Co. so far.

[21:52] <masak> lue: still working on it. hoping to be able to push and blog something before turning in for the night.

[21:54] <lue> (I seem to have an interest spike in strings, esp. StrPos and StrLen)

[21:55] *** patspam left
[21:55] <pmurias> masak: the midterm evaluation evaluates the progress till the evaluation or till some other date?

[21:56] <masak> pmurias: I'd guess the former, but I'm not sure.

[21:56] <masak> I've only done that evaluation as a mentor, last year.

[21:57] <jnthn> masak: I suggest just write something early next week about where you're at, and I'll do similar, and we'll submit 'em.

[21:57] *** patspam joined
[21:57] <masak> jnthn: aye. as I remember it, it's a bit more formulaic than that. they have a system called "Melange" in which you fill in some text fields.

[21:58] <jnthn> masak: ah, your bit is too?

[21:58] <pmurias> last year the student didn't have to fill in anything?

[21:59] <pmurias> s/?//

[21:59] <jnthn> I noticed I have some questions to fill in.

[22:00] <jnthn> masak: Anyways, next week is The Big Week. :-)

[22:00] <masak> aye. :)

[22:00] <masak> right now, progress feels good.

[22:00] <masak> I'm learning a bit more about PIR, too :)

[22:00] <masak> for example, one cannot do find_lex '$!pio'

[22:00] <lue> The Big Week?    *jarring chord*

[22:00] <masak> probably because it's not a lex :P

[22:00] <jnthn> masak: :P

[22:01] <jnthn> lue: Yeah it's like 8 days instead of 7.

[22:01] <masak> a leap week.

[22:02] <jnthn> We've probably had support for those spec'd in Temporal at some point in its history

[22:02] *** cjk101010 left
[22:02] <masak> well, it's important to be general enough.

[22:03] <lue> but then other parts of the spec'd Temporal erased those from history :)

[22:03] <Tene> masak: getattribute self, 'pio'

[22:03] <Tene> probably

[22:03] <masak> ooh.

[22:03] <dolmen> what is "yapsi"?

[22:03] <Tene> or maybe '$pio'

[22:03] <Tene> I don't quite recall.

[22:03] <masak> so far I assigned the attr to a lex, and then found_lex. but Tene's way looks promising.

[22:03] <Tene> but you can check with --target=pir

[22:04] <masak> dolmen: it's Perl 6 written in Perl 6.

[22:04] <Tene> Let me know if you want help with it.

[22:04] <dolmen> oh

[22:04] <masak> Tene: I'll experiment a bit. thanks.

[22:05] <masak> dolmen: you should see your expression right now! :)

[22:05] <dolmen> masak: what is the state of this implementation? Early? Very Early?

[22:05] <tylercurtis> masak: It might be '$!pio'. I know that's what NQP does if you do has $!foo.

[22:05] <jnthn> $P0 = find_lex 'self'

[22:05] <masak> dolmen: Very Early. but also fairly hackable.

[22:05] <jnthn> $P1 = getatribute $P0, '$!lol'

[22:05] <masak> dolmen: see http://github.com/masak/yapsi

[22:05] <masak> jnthn: ah, yes.

[22:06] <jnthn> masak: But nicest is to not write these in PIR :-)

[22:06] <tylercurtis> yapsi: my $i = 6; while --$i { say $i; }

[22:06] <jnthn> If you can avoid it.

[22:06] <lue> [:)]

[22:06] <p6eval> yapsi: OUTPUTÂ«5â¤4â¤3â¤2â¤1â¤Â»

[22:06] <masak> jnthn: it hinges on ByteBuffer, which is a Parrot PMC.

[22:07] <jnthn> masak: aye, but there's often ways to do PMCs without dropping to Q:PIR, e.g. the pir::foo forms.

[22:07] <jnthn> masak: But make it work first.

[22:07] <masak> nod.

[22:08] * dolmen watches http://github.com/masak/yapsi

[22:09] *** shade_ is now known as shade\

[22:10] <jnthn> masak: (twitter) :P :P

[22:10] <dolmen> what are "phasers"?

[22:10] <masak> dolmen: things like BEGIN {}

[22:10] <masak> I should clarify that in the README, perhaps.

[22:10] <jnthn> They're blocks that get fired at special times. They're one of the most stunning features of Perl 6.

[22:10] <dolmen> oh, a new word for an old thing?

[22:11] <masak> dolmen: yes, a Perl 6 term.

[22:11] <dolmen> which synopsis? S04?

[22:11] <jnthn> All puns aside though, it's quite a sensible name - BEGIN/CHECK/INIT etc are all phases in a program's lifetime.

[22:13] *** lest_away is now known as lestrrat

[22:15] *** sahadev left
[22:17] *** patspam left
[22:17] <masak> ok. apart from a small encoding issue somewhere in the read, I've got it roundtripping now.

[22:21] <lue> \o/

[22:22] <sorear> good * #perl6

[22:23] <masak> sorear! \o/

[22:23] *** patspam joined
[22:24] *** patspam left
[22:24] <pmurias> sorear: hi

[22:24] <masak> ok, I'm thinking I should just push this. there's some improper extra encoding somewhere, but I don't see exactly where.

[22:24] <sorear> hah.  given how much time he spends here I always figured TimToady was being payed by TPF to lurk in #perl6

[22:24] <masak> maybe Parrot's IO.read and IO.print aren't symmetrical.

[22:25] <masak> sorear: yeah, me too.

[22:25] <masak> sorear: I guess he just has a great fascination with Perl 6, like the rest of us. :)

[22:25] <pmurias> sorear: doesn't he use screen through ssh?

[22:26] *** tedv joined
[22:26] <pmurias> g'night

[22:26] *** pmurias left
[22:26] <sorear> I hate it when people do that

[22:26] <sorear> ask question, immediately quit

[22:27] <masak> cowards!

[22:27] <masak> sorear: why do you hate that?

[22:27] *** masak left
[22:27] *** masak joined
[22:28] <masak> sorear: I couldn't get your 'hidden var in outer block' idea to work for 'state' variables, but it works great for FIRST and LAST phasers :)

[22:29] <lue> masak: I'd like to look at the code, maybe new eyes will help [then again, it also couldn't :)]

[22:29] <masak> lue: right. preparing a merge now.

[22:30] <lue> [it fully depends on how well versed I am in whatever PIR you use :)]

[22:31] <masak> it's not that complex, actually.

[22:33] *** tadzik left
[22:33] <masak> I think I know what's wrong. I tell it to encode the string as ISO-8859-1, but I don't think it can yet.

[22:34] <masak> so the string gets written as UTF-8, and then things start going wrong from there.

[22:34] <lue> (Last time I remember ISO-8859-1 isn't the complete Unicode spec. Could be wrong though)

[22:35] <sorear> ISO-8859-1 is only incidentally related to Unicode

[22:36] <ingy> anyone seen: Null PMC access in find_method('new')

[22:36] <ingy> on a subst like $v ~~ s/\n+$/\n/

[22:36] <ingy> I'm pretty sure $v is a string...

[22:37] <sorear> std: s/\n+$/\n/

[22:37] <p6eval> std 31607: OUTPUTÂ«ok 00:01 112mâ¤Â»

[22:37] <sorear> huh.  I thought that syntax was no longer supported.

[22:37] <masak> it is.

[22:37] <sorear> rakudo: my $v = ''; $v ~~ s/\n+$/\n/

[22:37] <p6eval> rakudo e58b16:  ( no output )

[22:37] <sorear> rakudo: my $v; $v ~~ s/\n+$/\n/

[22:38] <p6eval> rakudo e58b16:  ( no output )

[22:38] <masak> ok. commits in the chute.

[22:39] <Tene> rakudo: my $v = "foo\n\n\n"; $v ~~ s/\n+$/\n/; say $v;

[22:39] <p6eval> rakudo e58b16: OUTPUTÂ«fooâ¤â¤Â»

[22:39] <Tene> rakudo: my $v = "foo\n\n\n"; $v ~~ s/\n+$/\n/; print $v;

[22:39] <p6eval> rakudo e58b16: OUTPUTÂ«fooâ¤Â»

[22:39] <pugssvn> r31608 | masak++ | [t/spec] re-fudged S16-filehandles/io.t for Rakudo 

[22:39] <Tene> Looks like it works fine for me.

[22:39] <lue> masak: sure that's t/spec? :)

[22:40] <masak> lue: what do you mean?

[22:41] <lue> oops

[22:41] <ingy> does ~~ coerce $v to be a string?

[22:42] <masak> not in itself, no.

[22:42] <masak> `4 ~~ Int` is totally fine.

[22:42] <lue> .oO(sure I'm not insane?) somewhere the connection between [t/spec] and .t failed in my brain. :)

[22:42] <lue> (I interpreted [t/spec] as spec, completely ignoring the t/)

[22:43] <dalek> rakudo: 692aa15 | masak++ | src/core/IO.pm:

[22:43] <dalek> rakudo: [IO] implemented IO.read and IO.write

[22:43] <dalek> rakudo: There's still some mis-encoding somewhere, because a few tests still fail in

[22:43] <dalek> rakudo: t/spec/S16-filehandles/io.t.

[22:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/692aa15f2538858028934b8e26910199cc5fdc53

[22:43] <dalek> rakudo: 2d0a573 | masak++ | src/core/IO.pm:

[22:43] <dalek> rakudo: [IO] added :$bin parameter to &open and .open

[22:43] <dalek> rakudo: When called, the file is opened without expecting utf-8. The argument

[22:43] <dalek> rakudo: 'binary' to the .encoding method on the filehandle could actually have

[22:43] <dalek> rakudo: been any non-'utf-8' string, since Parrot only has two modes right now.

[22:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2d0a57359c94fdd97476ae69cf831b77ea2af62d

[22:44] <ingy> what is !whatever_dispatch_helper

[22:44] <ingy> ?

[22:45] <jnthn> ingy: Leaking guts but usually a result of a method call on a Whatever

[22:45] <jnthn> But it may want to be ripped out now that we do *.foo syntactically

[22:46] <jnthn> I didn't get a straight answer on whether it could be ripped out yet though.

[22:46] <jnthn> Or if I did, I forgot it. :-)

[22:46] <jnthn> masak: yay patches!

[22:46] <lue> CONFLICT (content): Merge conflict in src/core/operators.pm

[22:46] <lue> Automatic merge failed; fix conflicts and then commit the result.

[22:46] <masak> ingy: see http://github.com/rakudo/rakudo/blob/master/src/glue/dispatch.pir#L19

[22:46] <lue> I suppose I could just checkout operators.pm, but I want to know if there's a better way.

[22:47] <masak> lue: see http://www.kernel.org/pub/software/scm/git/docs/git-merge.html

[22:47] <masak> lue: or perhaps http://www.kernel.org/pub/software/scm/git/docs/git-mergetool.html

[22:49] <lue> funny thing is, it's my := code that's causing the conflict :)

[22:51] <masak> lue: the real answer to 'a better way' is 'do development in a branch, don't pull in the branch you do development in'.

[22:52] <sorear> rebase!

[22:52] *** timbunce left
[22:52] <masak> I found the buf branch no longer even built with newer Parrots. a rebase solved it.

[22:53] *** breinbaas left
[22:54] <lue> I think I'll just git checkout right now. The mergetool is just confusing me.

[22:55] <masak> lue: I think after being appropriately confused, you'll really like 'git rebase' :) right up your time-traveling alley.

[22:55] <pugssvn> r31609 | lwall++ | [S04,6] more refinement of how scoping works under DBC 

[22:55] <pugssvn> r31609 | note that all phasers in methods to have access to self via closure

[22:56] <lue> I'd need a lot more gitfu before I can think about a separate branch :) [hello, gitready website]

[22:58] <arnsholt> Branches are actually pretty straightforward

[22:58] <lue> actually, I might as well try rebase now.

[22:59] <lue> ...nvm

[22:59] <pugssvn> r31610 | lwall++ | [S04] emphasize that LEAVE blocks *always* run even under stack unwinding 

[23:00] <lue> I can't win right now :)

[23:00] *** dolmen left
[23:00] <lue> lue@twigil:~/rakudo$ git checkout src/core/operators.pm

[23:00] <lue> error: path 'src/core/operators.pm' is unmerged

[23:00] *** Ross left
[23:01] <masak> lue: see previous links. also see git tutorials in general. :)

[23:01] <masak> lue: also, #git.

[23:02] <masak> lue: I do feel your pain, though. it's a bit tricky at the start.

[23:02] <lue> oh! I didn't bother commiting the last couple of edits I made, instead changing the already generated patches.

[23:02] <lue> the Warning! on the help page for merge describes my problem :)

[23:03] <arnsholt> lue: Yeah, that's generally a bad approach =)

[23:03] <arnsholt> (Editing patches, that is)

[23:03] <sorear> You can't edit git patches unless you have mad sha1 skillz

[23:04] *** skids joined
[23:04] <arnsholt> Oh, right. That probably explains why pmichaud had trouble applying one of the patches

[23:04] <lue> now that also explains why pmichaud couldn't apply the one patch :)

[23:04] <sorear> ...

[23:04] <lue> I only changed one 'v' to an '0', but I know what that can do to a checksum

[23:06] <lue> (note to self: pay attention to large streams of hex digits in headers)

[23:06] <sorear> the worst is when software decides to apply newline conversion to git patches

[23:09] <TimToady> re stringifying buffers, perhaps in the absence of encoding type information (such as the utf8 type provides), it should just print out as a list of numbers

[23:10] <jnthn> sorear: Yes, that is decidedly annoying.

[23:11] <lue> is the \x escape sequence dependant on what encoding system you use?

[23:12] <sorear> no

[23:12] <lue> [git commit -a seemed to commit the merge or something â€” next time, branches are good :)]

[23:12] <TimToady> \x should always indicate the integer of a Unicode codepoint

[23:12] <sorear> \x can take up to 6 digits

[23:12] <sorear> rakudo: say "\x10FFFE".chars

[23:13] <p6eval> rakudo e58b16: OUTPUTÂ«===SORRY!===â¤Malformed stringâ¤Â»

[23:13] <sorear> rakudo: say "\x[10FFFE]".chars

[23:13] <p6eval> rakudo e58b16: OUTPUTÂ«===SORRY!===â¤Malformed stringâ¤Â»

[23:13] *** rv2733 left
[23:13] <masak> TimToady: I can do that.

[23:13] <sorear> std: say "\x10FFFE".chars

[23:13] <p6eval> std 31610: OUTPUTÂ«ok 00:01 111mâ¤Â»

[23:14] <TimToady> rakudo: say "\x10fffe".chars

[23:14] <p6eval> rakudo e58b16: OUTPUTÂ«===SORRY!===â¤Malformed stringâ¤Â»

[23:14] <TimToady> rakudo: say "\xfffe".chars

[23:14] <p6eval> rakudo e58b16: OUTPUTÂ«===SORRY!===â¤Malformed stringâ¤Â»

[23:14] <TimToady> rakudo: say "\x[fffe]".chars

[23:14] <p6eval> rakudo e58b16: OUTPUTÂ«===SORRY!===â¤Malformed stringâ¤Â»

[23:14] <TimToady> huh

[23:15] <lue> rakudo: say "\x[cb]"

[23:15] <p6eval> rakudo e58b16: OUTPUTÂ«Ã‹â¤Â»

[23:15] <TimToady> rakudo: say "\x[4e00]".chars

[23:15] <p6eval> rakudo e58b16: OUTPUTÂ«1â¤Â»

[23:15] <TimToady> I guess it doesn't like undefined chars

[23:15] <lue> .u 4E00

[23:15] <phenny> U+4E00 CJK UNIFIED IDEOGRAPH-4E00 (ä¸€)

[23:16] <lue> .u 004E

[23:16] <phenny> U+004E LATIN CAPITAL LETTER N (N)

[23:16] <lue> oh, didn't notice the .chars

[23:16] <TimToady> rakudo: say "ğ¯¨œ".chars

[23:16] <p6eval> rakudo e58b16: OUTPUTÂ«1â¤Â»

[23:17] <TimToady> .u 2fa1c

[23:17] <phenny> TimToady: Sorry, no results for '2fa1c'.

[23:17] <TimToady> .u 2FA1C

[23:17] <phenny> TimToady: Sorry, no results for '2FA1C'.

[23:17] <lue> .u 10FFEE

[23:17] <phenny> lue: Sorry, no results for '10FFEE'.

[23:17] <sorear> .u fffe

[23:17] <phenny> U+FFFE (No name found)

[23:18] <sorear> .u fffd

[23:18] <phenny> U+FFFD REPLACEMENT CHARACTER (ï¿½)

[23:18] <sorear> .u 10fffd

[23:18] <phenny> sorear: Sorry, no results for '10fffd'.

[23:18] <sorear> it's clearly not even parsing stuff that high as a number

[23:18] <sorear> .u linear b

[23:18] <phenny> sorear: Sorry, no results for 'linear b'.

[23:18] <sorear> .u phoenician

[23:18] <phenny> sorear: Sorry, no results for 'phoenician'.

[23:18] <phenny> sorear: Sorry, no results for 'phoenician'.

[23:18] *** ashleydev left
[23:18] <TimToady> .u ğ¯¨œ

[23:18] <phenny> U+2FA1C CJK COMPATIBILITY IDEOGRAPH-2FA1C (ğ¯¨œ)

[23:18] <sorear> .u phoenician

[23:18] <phenny> sorear: Sorry, no results for 'phoenician'.

[23:19] <sorear> what just happened

[23:19] <sorear> from my POV, I run ".u phoenician" twice and got three replies

[23:19] <TimToady> .u acrophonic

[23:19] <phenny> TimToady: Sorry, no results for 'acrophonic'.

[23:20] <TimToady> .u ACROPHONIC

[23:20] <phenny> TimToady: Sorry, no results for 'ACROPHONIC'.

[23:20] <sorear> ilogger2 concursw

[23:20] <TimToady> phenny running with older Unicode spec, mebbe

[23:20] <lue> phenny doesn't like any code points beyond the zeroth astral plane given to it, it seems.

[23:20] <sorear> lue: it has a name

[23:20] <ingy> jnthn: could you look at http://gist.github.com/470234 and tell me what you think?

[23:21] <TimToady> though it looked up my U+2FA1C in one direction

[23:21] <ingy> greetings TimToady, sorear 

[23:21] <TimToady> Life's a beach, and then you dry.

[23:22] <ingy> Life's a bleach, then you whiiiii...

[23:22] <TimToady> whiiiii not?

[23:24] <lue> Life's an analogy, and then you metaphor.

[23:24] <ingy> I never actually met a phor...

[23:24] <TimToady> .oO(I never metaphor I didn't life...)

[23:24] * ingy bows down

[23:25] <ingy> seen jnthn 

[23:25] <ingy> TimToady: http://gist.github.com/470234 ring any bells?

[23:25] <masak> loliblogged: http://use.perl.org/~masak/journal/40440

[23:25] <lue> .oO(I knight thee Sir Real)

[23:27] <masak> ingy: if that's all there is to it, you've got yourself a bug report. but it can't be.

[23:27] <jnthn> ingy: I think "wtf"

[23:27] <TimToady> missing some context

[23:27] <jnthn> ingy: What's $context.value?

[23:27] * lue adds a new word to his dictionary. smop.

[23:28] <jnthn> TimToady: gah, I was just thinking that :P

[23:28] <masak> rakudo: class Context { has $.value is rw }; my $context = Context.new; $value = "x y z"; $context.value = $value; say ">>> " ~ $context.value;

[23:28] <p6eval> rakudo e58b16: OUTPUTÂ«===SORRY!===â¤Symbol '$value' not predeclared in <anonymous> (/tmp/RSOkgsikNo:20)â¤Â»

[23:28] <masak> argh.

[23:28] <masak> rakudo: class Context { has $.value is rw }; my $context = Context.new; my $value = "x y z"; $context.value = $value; say ">>> " ~ $context.value;

[23:28] <p6eval> rakudo e58b16: OUTPUTÂ«>>> x y zâ¤Â»

[23:28] <masak> ingy: worksforme.

[23:31] * masak heads bedwards

[23:32] <masak> 'night, #perl6

[23:32] <ingy> masak: brb (after the bubble shack)

[23:32] *** masak left
[23:33] *** Guest62179 left
[23:33] *** jibal joined
[23:36] *** jibal left
[23:37] <ingy> masak's case works here too.

[23:37] <ingy> will try to get a replication

[23:39] <ingy> rakudo: class Context { has $.value is rw }; my $context = Context.new(value => *); my $value = "x y z"; $context.value = $value; say ">>> " ~ $context.value;

[23:39] <p6eval> rakudo e58b16: OUTPUTÂ«>>> !whatever_dispatch_helperâ¤Â»

[23:39] <ingy> jnthn: ^^

[23:40] <jnthn> bug

[23:40] <jnthn> TimToady: Can we toss the non-syntactic whatever currying?

[23:40] <TimToady> rakudo: class Context { has $.value is rw }; my $context = Context.new(:value(*)); my $value = "x y z"; $context.value = $value; say ">>> " ~ $context.value;

[23:40] <p6eval> rakudo e58b16: OUTPUTÂ«>>> !whatever_dispatch_helperâ¤Â»

[23:40] <jnthn> TimToady: I bet some internals-y method is getting curried.

[23:41] <jnthn> We already have to have an exceptions list.

[23:41] <TimToady> we can toss it for now, sure

[23:41] <jnthn> OK, I'll try it tomorrow and see what it does to the test suite.

[23:41] <TimToady> how does callsame get the current capture?

[23:43] <TimToady> jnthn ^^

[23:43] *** pragma_ joined
[23:43] *** pragma_ is now known as Guest38858

[23:45] <ingy> rakudo: class Context { has $.value is rw }; my $context = Context.new(value => 'fail'); my $value = "x y z"; $context.value = $value; say ">>> " ~ $context.value;

[23:45] <p6eval> rakudo e58b16: OUTPUTÂ«>>> x y zâ¤Â»

[23:45] <jnthn> TimToady: It stashes it away in a sekrit lexical.

[23:45] <jnthn> TimToady: Which tends to do sane things with closures too.

[23:45] <TimToady> I wish it was not so secret as to not be specced :)

[23:46] <jnthn> Well, you can spec it if you want

[23:46] <jnthn> All I'll do is give it the name you've spec'd. :-)

[23:46] <TimToady> maybe a "same" keyword like "self"

[23:46] <TimToady> callwith(|same) == callsame

[23:46] <jnthn> hm

[23:46] <jnthn> Could work.

[23:46] <jnthn> Don't immediately see why not

[23:46] <jnthn> Oh

[23:46] <TimToady> perhaps a bit to conflicty with uservars

[23:46] <TimToady> *too

[23:47] <TimToady> selfsame :)

[23:47] <jnthn> One reason is that we currently keep it as a low-level capture.

[23:47] <jnthn> Which is cheaper.

[23:47] <ingy> Cannot resume dead coroutine.

[23:47] <jnthn> (Actually, as a Parrot CallContext object)

[23:47] * ingy cries

[23:47] <jnthn> ingy: gather/take?

[23:48] <ingy> ?

[23:49] <TimToady> how were you making a co-routine?

[23:49] <ingy> not sure yet

[23:49] <ingy> :\

[23:49] <TimToady> what did you do?!?!?

[23:50] <sorear> TimToady: Rakudo implements lazy lists using Parrot coroutines

[23:50] <sorear> so a perl6 program will tend to make lots of coroutines

[23:51] <jnthn> Really?!

[23:51] <jnthn> pm...didn't tell me that bit.

[23:51] <lue> (O.o)

[23:51] <sorear> jnthn: Maybe I'm just uncreative, but I haven't thought of any other way to make garther/take work

[23:51] <sorear> using Parrot primitives

[23:52] <TimToady> I guess it's Friday, except where prohibited by law...

[23:52] <sorear> I haven't actually looked at the code

[23:52] <jnthn> sorear: Oh

[23:52] <jnthn> You're half right.

[23:52] <jnthn> It's used for implementing GatherIter

[23:52] <jnthn> But not anywhere else in the lazy lists impl.

[23:52] <jnthn> OK, that worries me less. It used to be done as continuations.

[23:53] <TimToady> it should really say, "cannot resume dead parrot coroutine"  :)

[23:53] <jnthn> "cannot resurrect dead norweigan blue parrot coroutine"

[23:53] <lue> Norweigan blue, lovely plumage

[23:54] <jnthn> TimToady: I'd context that it really shoudln't crash. ;-)

[23:54] <jnthn> rakudo: (1 ... 10).grep({ $_ %% 2 }).grep({ $_ %% 3 })

[23:54] <lue> .oO(Gah! what was the replacement pet again?)

[23:54] <p6eval> rakudo e58b16:  ( no output )

[23:54] <jnthn> rakudo: say (1 ... 10).grep({ $_ %% 2 }).grep({ $_ %% 3 })

[23:54] <p6eval> rakudo e58b16:  ( no output )

[23:54] <TimToady> hmm

[23:54] <TimToady> rakudo: say 6 %% 2

[23:55] <p6eval> rakudo e58b16: OUTPUTÂ«1â¤Â»

[23:55] <TimToady> rakudo: say 6 %% 3

[23:55] <p6eval> rakudo e58b16: OUTPUTÂ«1â¤Â»

[23:55] *** Psyche^ joined
[23:55] <TimToady> rakudo: say (1 ... 10).grep({ $_ %% 2 | 3})

[23:55] <p6eval> rakudo e58b16: OUTPUTÂ«12345678910â¤Â»

[23:56] <TimToady> er

[23:56] <jnthn> TimToady: I think it's something that goes horribly wrong when two gather iterators get chained back to back

[23:56] <TimToady> rakudo: say 7 %% 2

[23:56] <p6eval> rakudo e58b16: OUTPUTÂ«0â¤Â»

[23:56] <TimToady> still?

[23:56] <jnthn> rakudo: say 7 %% 3

[23:56] <p6eval> rakudo e58b16: OUTPUTÂ«0â¤Â»

[23:56] <jnthn> rakudo: say 7 %% 2 | 3

[23:56] <p6eval> rakudo e58b16: OUTPUTÂ«any(Bool::False, 3)â¤Â»

[23:56] <jnthn> precedence what have you done to us

[23:56] <jnthn> :-)

[23:56] <TimToady> oh, oops

[23:56] <jnthn> TimToady: It's my best guess so far.

[23:57] <TimToady> rakudo: say (1 ... 10).grep({ $_ %% (2 | 3)})

[23:57] <p6eval> rakudo e58b16: OUTPUTÂ«23468910â¤Â»

[23:57] <TimToady> that's more like

[23:57] <TimToady> doesn't explane your double grep though

[23:57] <sorear> Speaking of which

[23:57] <jnthn> No

[23:57] <jnthn> It needs some digging.

[23:57] <sorear> I need a very efficient implementation of lazy lists

[23:57] <sorear> Especially for the 0-or-1-item case

[23:58] <TimToady> perhaps you should use Erlang

[23:58] *** lestrrat is now known as lest_away

[23:59] *** Patterner left
[23:59] *** Psyche^ is now known as Patterner

[23:59] <TimToady> so I guess the grep method isn't cloning something right

