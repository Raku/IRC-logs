[00:01] <sorear> aha, found it

[00:09] <pugssvn> r31008 | sorear++ | [viv] Allow .*? to backtrack in rules again.  Oops. 

[00:16] *** whiteknight joined
[00:21] *** Spreadsheet_ left
[00:23] *** [Coke] joined
[00:30] *** azert0x left
[00:35] *** rgrau left
[00:36] *** yinyin joined
[00:38] * [Coke] skips review.

[00:38] *** kda left
[01:00] *** meppl left
[01:03] *** yinyin left
[01:07] *** meppl joined
[01:09] *** pausenclown left
[01:13] *** pausenclown joined
[01:16] *** tylerni7 left
[01:31] *** snarkyboojum left
[01:31] *** am0c joined
[01:32] *** Guest86832 left
[01:32] *** nothingmuch joined
[01:34] *** tylerni7 joined
[01:45] *** nothingmuch left
[01:46] *** meppl left
[02:08] *** synth left
[02:09] *** synth joined
[02:19] <jnthn> mornin'

[02:23] *** whiteknight left
[02:27] <sorear> yo.

[02:28] *** [mark] joined
[02:30] *** agentzh joined
[02:31] *** atomicstack joined
[02:36] <sorear> Hmm.

[02:37] <sorear> Fixing quantifier ratcheting doesn't seem to have helped performance much...

[02:39] *** JimmyZ joined
[02:43] *** bluescreen joined
[02:43] *** bluescreen is now known as Guest3497

[02:46] *** JimmyZ left
[02:47] *** Guest3497 left
[02:47] *** JimmyZ joined
[02:48] *** pencilk joined
[02:51] *** molaf joined
[03:03] <TimToady> <masak> module A { module UNIT::A {} } # clash?

[03:04] <TimToady> yes, clash

[03:04] <colomon> jnthn: I'm spectesting Prakash Kailasa's hyper patch, but I'm going to go to bed before it finishes, I think.  

[03:04] <TimToady> std: module A { module UNIT::A {} }

[03:04] <p6eval> std 31008: OUTPUT«===SORRY!===␤Illegal redeclaration of symbol 'MY:file</tmp/NdCFDuauHW>::<A>' (from line 1) at /tmp/NdCFDuauHW line 1:␤------> module A { module UNIT::A ⏏{} }␤Check failed␤FAILED 00:01 114m␤»

[03:05] <jnthn> colomon: OK. :-)

[03:05] <jnthn> colomon: I've gotta take care of $dayjob for the next little while anyways.

[03:05] <TimToady> in fact, nearly all your questions about module nesting are already answered by STD, though you might have to parse a .pm and examine the resulting .syml file to find the answer

[03:05] <colomon> It gets at least another 40 tests passing!  \o/

[03:05] <jnthn> colomon: \o/

[03:06] <jnthn> colomon: We hit 33k yet? ;-)

[03:06] <colomon> I dunno, but we're within 40 for sure, I think.

[03:06] <jnthn> \o/

[03:06] <colomon> currently having git issues.  :(

[03:06] <jnthn> Good chance of us making that in the next 24 hours then :-)

[03:07] <colomon> yes

[03:07] <colomon> bother, I just erased the working patch.  :()

[03:07] <colomon> :(

[03:08] <jnthn> :(

[03:09] <colomon> easy enough to rebuild, now trying compile and hyper.t again.

[03:10] *** krakan joined
[03:10] <colomon> ack, things are completely confused here.

[03:11] <colomon> think I will go to bed and tackle it again in the morning.

[03:12] *** colomon left
[03:15] <TimToady> the _reduced for <foo=.bar> is 'bar' in sTD

[03:15] <TimToady> STD even

[03:19] *** Eevee left
[03:21] <sorear> TimToady: What are the most important optimizations in gimme5?

[03:22] <TimToady> well, LTM itself prevents a great many false leads

[03:22] <TimToady> the other biggie is avoiding lazymap

[03:22] <TimToady> via ratcheting

[03:23] <sorear> Huh.  I had never thought of LTM as an /opt/imization

[03:24] <TimToady> if you do the LTM at the termish level, you don't have to redo it at lower levels because the fate is already determined

[03:25] <sorear> hmm.  I wonder if that's working

[03:25] <sorear> (in viv)

[03:26] <TimToady> should be able to tell from the logs what probes are made and what fates are piced

[03:26] <TimToady> *picked

[03:28] <sorear> on the plus side, LTM lexer caching does not appear to be magically broken

[03:28] * sorear has a hunch that <.ws> is the most expensive rule

[03:29] <sorear> how does HIGHEXPECT and MEMOS work?

[03:29] <TimToady> which is why it is heavily optimized

[03:29] <TimToady> you could run NYTProf on viv

[03:30] <TimToady> I run it now and then on std

[03:30] <TimToady> generally cursor_fate is the most expensive routine

[03:30] <TimToady> since it's faking LTM

[03:30] <TimToady> well, it's doing LTM but not always efficiently

[03:31] <TimToady> @*MEMOS is indexed by pos in the original source

[03:31] <TimToady> each entry is a hash that, beside mapping back to line number, allows any other keys, such as <ws> for the whitespace memoization

[03:32] <TimToady> if <ws> is set, it's pointing back to the beginning of the whitespace here, and means "we already match ws here, don't do it again"

[03:32] <TimToady> also we set some hints for possible future error messages

[03:32] <TimToady> <nodecl> and such

[03:32] * sorear ponders experimenting with packratism

[03:32] <TimToady> probably won't get much

[03:33] <TimToady> because we don't backtrack much

[03:34] <TimToady> HIGHEXPECT records the rules we attempted at the highwater mark

[03:34] <sorear> gimme5: sub ws__PEEK { '' }

[03:34] <sorear> viv: sub ws__PEEK { '' }

[03:34] <sorear> er

[03:34] <TimToady> it's the list of expectations in 'expecting any of' messages

[03:34] <sorear> sub ws__PEEK { $_[0]->_AUTOLEXpeek('ws', $retree) }

[03:35] <sorear> aha, I was wondering how  that worked

[03:35] * sorear thinks this __PEEK difference is important

[03:35] *** cowyn left
[03:35] <TimToady> I think ws is hardwired elsewhere to terminate LTM

[03:35] <TimToady> so this PEEK shouldn't be important

[03:36] <TimToady> RE_ast:214

[03:36] <TimToady> 218 rather

[03:36] <sorear> in general, though

[03:36] <sorear> viv is currently hardwired to generate a single form of __PEEK

[03:37] * sorear doesn't follow the <<DECL>> etc stuff in gimme5 and just cloned behaviorally

[03:39] <sorear> ah, viv generates empty __PEEK for ws fail commit before after panic and anything declared using 'method'

[03:39] <sorear> s/viv/gimme5/

[03:39] <sorear> viv doesn't generate __PEEK *at all* in those cases

[03:40] <sorear> I'm also not generating EXPR__PEEK

[03:52] <sorear> hmm

[03:53] <sorear> die processing is pretty slow iirc

[03:53] <sorear> maybe adding __PEEK stubs for things would be a big improvement

[03:53] <sorear> except, no, that would only help autolexer generation

[03:53] <sorear> which is Not The Bottleneck

[03:55] *** cli_ joined
[03:56] <sorear> TimToady: Might changing the names of alternatives have broken anything?  (ws_03 and ws_05 are now ws_0 and ws_1)

[03:57] * sorear quickly flips back and forth between two versions of "sub ws" looking for breakage

[04:00] <lue> ohai

[04:04] <sorear> TimToady: Can you tell me anything about the hacks involved in autolexing EXPR?

[04:09] <dmpk2k> Does Perl6 have any method or function help at the REPL, like Python or Common Lisp?

[04:11] <sorear> rakudo: Any.^methods.Str.say

[04:11] <p6eval> rakudo dd0e5d: OUTPUT«can Numeric elems end reduce Str keys reverse isa uniq classify map pairs kv ACCEPTS min max pick first minmax does grep values join WHICH perl CREATE Capture PARROT bless WHENCE WHERE list  notdef BUILDALL new Bool print say defined WALK item BUILD REJECTS clone␤»

[04:11] <sorear> something like that?

[04:13] <dmpk2k> Alas, nope. Fire up a python interpreter and type "help(dir)".

[04:13] <dmpk2k> It shows you a description of what the dir() function does.

[04:14] <lue> there's perldoc, but i'm not sure if that's part of the REPL itself.

[04:15] *** cli_ left
[04:15] *** cli_ joined
[04:16] <dmpk2k> Perldoc is good stuff, but it'd very oh-so-nice if there were allowanced for it at the REPL.

[04:16] <dmpk2k> I don't use Python, but I use it all the time with Factor.

[04:16] <lue> rakudo: perldoc

[04:16] <p6eval> rakudo dd0e5d: OUTPUT«Could not find sub &perldoc␤  in main program body at line 1:/tmp/TrJadigSqD␤»

[04:19] <sorear> Perl6 is specced to have online help

[04:19] <dmpk2k> Awesome. :)

[04:19] <sorear> it's stored in the .WHY interrogative of variables

[04:20] <lue> but last I heard, REPL still has an feeble "memory", in that it can't remember variables from the last line. It still has a waaays to go.

[04:21] <sorear> there's a fork of the REPL from about two weeks ago with the ability to remember variables

[04:21] <sorear> pmichaud is working on a "real" version

[04:22] *** molaf left
[04:24] <dmpk2k> rakudo: say.WHY.say

[04:24] <p6eval> rakudo dd0e5d: OUTPUT«␤Method 'WHY' not found for invocant of class 'Bool'␤  in main program body at line 11:/tmp/yFmMBZvYyP␤»

[04:25] <dmpk2k> So much for that guess.

[04:26] <sorear> there are no complete implementations of Perl 6 yet

[04:28] <pugssvn> r31009 | sorear++ | [viv] Optimize .*? and .*! to SCANs with special meta nodes 

[04:28] <pugssvn> r31009 | Blocks don't need additional cutting

[04:30] <lue> rakudo: 3.WHO.say; 3.WHAT.say

[04:30] <p6eval> rakudo dd0e5d: OUTPUT«Method 'say' not found for invocant of class 'Int'␤  in main program body at line 11:/tmp/eKMULuByqJ␤»

[04:30] <lue> :O

[04:31] <lue> that should work, right?

[04:31] <lue> rakudo: say 3.WHO; say 3.WHAT

[04:31] <p6eval> rakudo dd0e5d: OUTPUT«Int␤Int()␤»

[04:40] *** am0c left
[04:49] <sorear> oh, /nice/

[04:49] *** TiMBuS joined
[04:50] <sorear> TimToady: apparently the .*? -> _SCANf optimization is Really Important

[04:50] <sorear> implementing it in viv made STD.pmc 36 times faster

[04:56] *** lue left
[05:04] *** PZt left
[05:20] *** am0c joined
[05:22] * sorear looks through a 196MB viv.log

[05:29] *** pencilk left
[05:39] <sorear> STD-on-viv-on-STD can't seem to handle character classes

[05:39] <sorear> hmm

[05:39] *** kaare joined
[05:39] <sorear> /<[]>/ fails, tr/// succeeds

[05:40] *** kaare is now known as Guest26513

[05:42] *** dju joined
[05:49] <moritz_> good morning

[05:52] <PerlJam> morning moritz_ 

[05:53] <sorear> good morning moritz_ 

[05:53] <sorear> ok, I'm missing _PARAMS generation

[05:54] * moritz_ is very pleased with rakudo's progress in last 7 days or so

[05:56] <sorear> hah, viv-compiled-STD doesn't grok balanced punctuation

[05:56] <pugssvn> r31010 | sorear++ | [viv] Fix parameterized role autolexer generation (_PARAMS missing) 

[05:56] <sorear> it's willing to parse a character class if I spell it <[ a e i o u [>

[05:56] <dalek> rakudo: 5c09771 | moritz++ | t/spectest.data:

[05:56] <dalek> rakudo: run whatever.t again

[05:56] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5c097714cb7ab95b7f2ad7b5c005263ac80014c5

[05:56] <moritz_> sorear: :-)

[05:59] <pugssvn> r31011 | moritz++ | [t/spec] test that method not found error contains method name and line number 

[05:59] *** mempko joined
[06:00] <sorear> wanted: a web changeset service for pugssvn

[06:00] *** am0c left
[06:01] *** mempko left
[06:05] <sorear> found it

[06:06] <moritz_> sorear: if you look at the IRC logs in /topic, all the r\d+ occurences are turned into links

[06:07] <moritz_> as are many other things :-)

[06:08] <sorear> excellent.  moritz++ for telling me moritz++ for the logs

[06:09] <moritz_> #perl6++

[06:09] <moritz_> most feature ideas and layout patches came here

[06:10] <moritz_> it was the first ugly-but-useful page I produced, and #perl6 people beautified it

[06:10] <moritz_> same with perl6.org (perl6-proejects.org back then)

[06:10] <moritz_> and same with proto.perl6.org

[06:11] * sorear wonders if #perl6 made mowyw

[06:12] *** uniejo joined
[06:12] <moritz_> nope that was my own, pre-#perl6 invention

[06:13] <moritz_> probably not really pre-#perl6, but shortly after I joined

[06:13] <pugssvn> r31012 | sorear++ | [viv] Bracketize \xABCD in perl5-output 

[06:13] <sorear> yay, STD-viv can now parse bracketing delimiters

[06:13] <moritz_> \o/

[06:14] <sorear> one little bugfix at a time

[06:14] <moritz_> rakudo: sub foo ($a where 5) { say "hi" }; foo(42);

[06:14] <p6eval> rakudo dd0e5d: OUTPUT«Constraint type check failed for parameter '$a'␤  in 'foo' at line 11:/tmp/ld2jH1UvGy␤  in main program body at line 11:/tmp/ld2jH1UvGy␤»

[06:14] <sorear> though I was rather in a quagmire not long ago; I had my ETA calculated as June 23, 2042

[06:15] <moritz_> ETA for viv compiling STD.pm6 without errors?

[06:15] <sorear> no

[06:15] *** atomicstack left
[06:15] <sorear> that's already here

[06:16] <sorear> however, it's miscompiling STD

[06:16] <sorear> miscompilations are very problematic to debug

[06:16] <moritz_> with "without errors" I actually meant "correctly"

[06:17] <sorear> ahhh

[06:17] <sorear> yeah.  slow going.

[06:18] <moritz_> rakudo: my $x = "test"; given $x { say $_; m/(e.)/; say $/ }

[06:18] <p6eval> rakudo dd0e5d: OUTPUT«test␤Any()␤»

[06:18] <sorear> erm...

[06:18] <sorear> what does %<a> mean

[06:19] <moritz_> std: %<a>

[06:19] <p6eval> std 31010: OUTPUT«ok 00:01 114m␤»

[06:19] <moritz_> std: % <a>

[06:19] <p6eval> std 31010: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at /tmp/NT9FIN0XhR line 1:␤------> <BOL>⏏% <a>␤Bogus statement at /tmp/NT9FIN0XhR line 1:␤------> %⏏ <a>␤    expecting twigil␤Parse failed␤FAILED 00:01 111m␤»

[06:19] * moritz_ has no idea

[06:20] <moritz_> rakudo: class Foo { }; my $x = "Foo"; my $y = $x.new; $y.WHAT.say;

[06:20] <p6eval> rakudo dd0e5d: OUTPUT«Foo()␤»

[06:20] *** masonkramer joined
[06:20] <sorear> STD.pm6 lines 3263-3265 contain 3 references to %<O><prec> syntax

[06:20] <sorear> gimme5 compiles this identically to $<O><prec>

[06:21] <moritz_> std: 1 R~= 2

[06:21] <p6eval> std 31010: OUTPUT«ok 00:01 111m␤»

[06:21] <moritz_> rakudo: my $x = 3; 1 R~= $x; say $x

[06:22] <p6eval> rakudo dd0e5d: OUTPUT«1␤»

[06:22] <moritz_> rakudo: sub foo { my $a = 5; say $^a }; foo(7)

[06:22] <p6eval> rakudo dd0e5d: OUTPUT«===SORRY!===␤Multiple declarations of lexical '$a'␤␤»

[06:24] <sorear> \o/ I'm 100 lines down

[06:24] <pugssvn> r31013 | sorear++ | [viv] Translate the %<O> syntax found in STD 

[06:24] <sorear> that cuts about a year off my ETA at previous rate estimates :p

[06:25] <moritz_> somebody flagged http://rt.perl.org/rt3/Ticket/Display.html?id=62622 as [LHF] (pmichaud perhaps?) but I have no idea where to dig for it :(

[06:26] <sorear> LHF?

[06:27] <moritz_> low-hanging fruit

[06:31] *** masonkramer left
[06:32] *** meteorjay joined
[06:33] *** cognominal joined
[06:33] *** tedv| left
[06:35] *** Su-Shee joined
[06:41] <pugssvn> r31014 | sorear++ | [viv] Â« Â» needs to generate an Array 

[06:42] <sorear> svn--

[06:43] <moritz_> it's pugssvn that has problems with UTF-8

[06:48] *** kda joined
[06:51] <sorear> strange.  now it's parsing :=, **, ++ fine, but not =>

[06:55] <sorear> aha

[06:55] <sorear> it's parsing :sym« => » as having literal spaces in the name

[06:55] <sorear> screws up LTM

[06:58] *** ejs joined
[06:58] <pugssvn> r31015 | sorear++ | [viv] We need to trim leading and trailing spaces in word quotes used as adverbs 

[06:59] <sorear> jumped ahead *500* lines

[06:59] <sorear> 3 years!!!

[07:02] *** ejs left
[07:03] *** ejs joined
[07:09] *** atomicstack joined
[07:13] <Su-Shee> good morning.

[07:13] <cognominal> \o

[07:14] *** cli_ left
[07:18] * sorear wishes he understood the contents of viv.log

[07:25] <mathw> Morning

[07:31] *** tomka joined
[07:32] <sorear> TimToady: Why is $CTX only updated at certain places, instead of continuously in deb?

[07:48] *** buubot left
[07:48] *** buubot joined
[07:56] *** cosimo left
[07:57] <pugssvn> r31016 | sorear++ | [viv-ecosystem] Add a tiny script to make comparing lexers easier 

[08:01] *** plobsing left
[08:04] <pugssvn> r31017 | sorear++ | [cleanlex] Also deal with FATE index skew. 

[08:08] *** proller joined
[08:20] <pugssvn> r31018 | sorear++ | [viv] One hack and two bug-compatibilities to improve LTM 

[08:21] <sorear> it can now parse $<a>

[08:22] <sorear> there's something delightfully ironic about parsefailing in the parse error code.

[08:22] <sorear> (line 1307)

[08:23] <mberends> heh

[08:24] * sorear revises his ETA from June 26, 2042 to next Thursday

[08:25] <mberends> that's better than "to *the* next Thursday" ;)

[08:25] <sorear> std: no Foo

[08:25] <p6eval> std 31016: OUTPUT«Can't locate object method "explain_myster" via package "STD::P6" at STD.pm line 12432.␤FAILED 00:01 113m␤»

[08:26] <pugssvn> r31019 | sorear++ | [STD] Fix a misspelled method name 

[08:26] <mberends> tried to access SQLite via zavolaj yesterday. It required some signatures that Parrot doesn't yet support. In other experiments, it *did* create an empty database file before segfaulting. Committed the WIP anyway.

[08:27] <sorear> mberends: go talk to plobsing

[08:27] <mberends> yes, will do that :)

[08:27] <sorear> plobsing's parrot can handle any signature

[08:27] <mberends> oh cool!

[08:27] <moritz_> sorear: local branch?

[08:33] <sorear> er, wait

[08:34] <sorear> I forgot... it was an extension

[08:34] *** kel_ joined
[08:34] <sorear> http://github.com/plobsing/parrot-libjit-fb

[08:35] *** Ross joined
[08:37] *** cosimo joined
[08:40] *** Ross left
[08:40] <pugssvn> r31020 | sorear++ | [viv] Global protoregex trait tables simulate inheritance 

[08:40] *** Ross joined
[08:46] <pugssvn> r31021 | sorear++ | [viv] Ignore specific token signature if a proto token provided one, to prevent double shifting and lossage.  (Is this the right approach?) 

[08:47] <sorear> line 2438!

[09:14] *** tomka left
[09:29] *** PZt joined
[09:30] *** Ross left
[09:33] <pugssvn> r31022 | sorear++ | [viv] Add SUBSUME coalescing (acts like an optimization, but it turns out to be semantically critical) 

[09:35] <sorear> can now handle 1 !~~ 1

[09:35] * moritz_ hopes it returns False :-)

[09:36] <sorear> no, it returns (3 pages of AST)

[09:36] <moritz_> ah well

[09:37] <sorear> you seem to have STD confused with a perl 6 implementation

[09:39] <sorear> STD.pm, having been compiled with STD.pm, just successfully parsed STD.pm

[09:39] <sorear> \

[09:39] <sorear> o

[09:39] <sorear> /

[09:40] <sorear> that actually wasn't intentional entering...

[09:41] <moritz_> looks like a cool move :-)

[09:41] <moritz_> now it would be interesting if also rejects wrong Perl 6 programs :-)

[09:41] <moritz_> sorear: how long did it take (the parsing, that is)?

[09:42] <sorear> out of scrollback, but 4-5 minutes

[09:42] <sorear> the same as gimme5 STD

[09:43] *** Ross joined
[09:45] <sorear> STD stage 3 contains several <<ERROR>> markers, indicating that unprocessable (i.e. different and wrong) AST is still being generated in some cases

[09:45] <sorear> however, diff -u (stage 3) (stage 2) is 10,000 lines

[09:45] <sorear> compared to a total of 60k lines

[09:46] *** azert0x joined
[09:46] <moritz_> too much if I understand you

[09:46] <sorear> I mean to say that STD-stage-2 has correctly compiled 80% of STD

[09:47] <sorear> and successfully compiled 100%

[09:47] <moritz_> ok

[09:48] * sorear -> sleep

[09:48] <moritz_> 'night

[09:49] <Su-Shee> I have a sudden hunger for bacon. 

[09:50] <moritz_> chunky bacon?

[09:50] <Su-Shee> slices or chunks, but fried please. :)

[09:57] *** agentzh left
[09:57] <Su-Shee> *HAHA*

[09:58] <Su-Shee> my co-worker is from poland. _he_ got the name of zavolaj immediately. ;)

[09:59] *** masak joined
[09:59] <masak> oh hai, #perl6

[09:59] <phenny> masak: 30 May 19:03Z <sorear> tell masak : there is no 'package' statement in Perl 6.  "package Foo;" is interpreted as meaning "use v5; package Foo;" to allow pure-Perl-5 modules to be used unaltered.  STD implements this (partially)

[09:59] <phenny> masak: 30 May 21:58Z <mathw> tell masak I pushed some changes to Form which make it build on my system, but the tests fail. The first failure is in the parsing tests with some fields not parsing, so maybe Form::Grammar is now out of date.

[10:01] <masak> clearly activity kept being high after I left yesterday :)

[10:02] <masak> mathw: given that there's a new underlying grammar engine now, that sounds probable :)

[10:03] <moritz_> mathw: biggest pitfal with the current grammar engine: backslash escape sequences in char classes are NYI

[10:04] <masak> sorear: if by 'package statement' you mean 'braceless package declaration', then I agree. I can see how it would be right for STD.pm6 to actually allow such a form, if it did enough p5. Rakudo, in its present form, should probably disallow it.

[10:04] <masak> moritz_: I could probably implement those. but not before the Yapsi release. :)

[10:05] <moritz_> masak: in nqp-rx? that would be awesome

[10:05] <masak> I've done it before in Perl 6, so... :)

[10:05] <moritz_> it's currently the biggest source of workarounds in JSON::Tiny

[10:07] <moritz_> it also rates high in the often-discussed bugs on p6c

[10:10] <jnthn> masak: We can make package an error, or a "is this Perl 5" kinda message, quite easily if that's the Right Thing to do.

[10:12] <mberends> std: package Foo;

[10:12] <p6eval> std 31022: OUTPUT«ok 00:01 114m␤»

[10:14] <masak> alpha: say ?(chr(9) ~~ /<[\t]>/) # is this meant to work?

[10:14] <p6eval> alpha 30e0ed: OUTPUT«1␤»

[10:14] <masak> oh, it does :)

[10:14] <masak> rakudo: say ?(chr(9) ~~ /<[\t]>/)

[10:14] <p6eval> rakudo 5c0977: OUTPUT«0␤»

[10:14] <moritz_> rakudo: say ord("\t")

[10:14] <p6eval> rakudo 5c0977: OUTPUT«9␤»

[10:15] <moritz_> rakudo: say ?('\\' ~ /<[\t]>/)

[10:15] <p6eval> rakudo 5c0977: OUTPUT«1␤»

[10:15] <moritz_> rakudo: say ?('t' ~ /<[\t]>/)

[10:15] <p6eval> rakudo 5c0977: OUTPUT«1␤»

[10:15] * masak notices with embarrassment that GGE doesn't implement this at all

[10:16] <mathw> moritz_: no char classes in Form's grammar

[10:16] <mathw> masak: Yes. What I need is a grammar engine that tells me what it's doing :)

[10:17] <masak> gnnnn. I really really need to write that GGE debugger.

[10:17] <mathw> heh

[10:17] <masak> maybe I should convince someone to help me do it? it's really LHF at this point.

[10:17] <mathw> I'll probably take another look at it later

[10:17] <mathw> see if I can figure it out

[10:17] <mathw> right now I need to have some breakfast

[10:18] <moritz_> rakudo: '12 abc ' ~~ /<?DEBUG(1)> <alpha>+/

[10:18] <p6eval> rakudo 5c0977: OUTPUT«3/1: PASS   at pos=6␤»

[10:19] <moritz_> not perfect, but better than nothing

[10:19] <mathw> could be just the key

[10:19] <mathw> okay I'll look at it now

[10:19] <mathw> and then I'll have breakfast

[10:22] <mathw> okay now I'm confused

[10:22] <mathw> the same field that's failing... passes if I run just that

[10:23] <mathw> but doesn't run inside the test file itself

[10:23] <mathw> so maybe it's not the grammar

[10:24] *** whiteknight joined
[10:25] *** colomon joined
[10:26] <mathw> oh

[10:26] <mathw> no my mistake

[10:26] <mathw> it is the parsing

[10:28] <bbkr> rakudo: my Rat $a; $a += 0.1 for ^10 # chcking if 74626 is fixed

[10:28] <p6eval> rakudo 5c0977:  ( no output )

[10:28] *** ejs left
[10:28] <masak> well, it's resolved...

[10:29] <mathw> rakudo: grammar A { regex B { a } }; "a" ~~ A::B;

[10:29] <p6eval> rakudo 5c0977: OUTPUT«Can not find sub A::B␤  in main program body at line 1␤»

[10:29] <mathw> pah

[10:29] <masak> mathw: that's a bug. it was submitted yesterday.

[10:30] <mathw> it's enormously unhelpful

[10:30] <masak> mathw: workaround: rename the regex A::B

[10:30] <jnthn> er

[10:30] <jnthn> huh

[10:30] <jnthn> How is that a bug?

[10:31] <jnthn> regexes are has scoped by default

[10:31] <masak> oh.

[10:31] <masak> of course.

[10:31] <jnthn> They're methods.

[10:31] <masak> need to learn to think this new way.

[10:31] <mathw> rakudo: grammar A { regex B { a } }; "a" ~~ A.B;

[10:31] <p6eval> rakudo 5c0977: OUTPUT«Type objects are abstract and have no attributes, but you tried to access $!pos␤  in 'A::B' at line 11:/tmp/CT2pH7kqHL␤  in main program body at line 11:/tmp/CT2pH7kqHL␤»

[10:31] <masak> mathw: that's calling the regex.

[10:31] <masak> not referring to it.

[10:31] <jnthn> /<A::B>/

[10:32] <jnthn> Or our regex and than &A::B

[10:32] <masak> rakudo: grammar A { regex B { a } }; A.B

[10:32] *** tylerni7 left
[10:32] <p6eval> rakudo 5c0977: OUTPUT«Type objects are abstract and have no attributes, but you tried to access $!pos␤  in 'A::B' at line 11:/tmp/ydvRI0xwHf␤  in main program body at line 11:/tmp/ydvRI0xwHf␤»

[10:32] <masak> slightly unhelpful error message there.

[10:32] <mathw> rakudo: grammar A { regex B { a } }; "a" ~~ /<A::B>/;

[10:32] <p6eval> rakudo 5c0977: OUTPUT«===SORRY!===␤regex assertion not terminated by angle bracket at line 11, near "::B>/;"␤»

[10:32] <masak> would it be possible to get something like "oh, you tried to call me as a method, don't do that"

[10:32] <masak> ?

[10:33] *** ejs joined
[10:33] <masak> mathw: I don't think /<A::B>/ is implemented yet... :(

[10:33] <colomon> jnthn: seem to have a solid patch this morning....

[10:33] <jnthn> masak: gah, now *that* is annoying (<A::B> NYI)

[10:33] <mathw> any chance it's LHF?

[10:33] <masak> jnthn: glad we agree :)

[10:34] <jnthn> mathw: Well, probably if you're pmichaud 

[10:34] <jnthn> mathw: Maybe even if you're not. :-)

[10:34] <jnthn> colomon: yay!

[10:34] <mathw> because figuring out this Form thing without being able to call individual regexes in the grammar for testing is going to be a pain in the arse

[10:34] <mathw> it's going to be a pain anyway, but...

[10:34] *** BrowserUk joined
[10:35] <jnthn> masak: On the error, not quite sure what the best way to be more helpful would be.

[10:35] <jnthn> masak: Perhaps though if it emits a signature with the invocant as :D when the binder supports that...

[10:35] <jnthn> ...then at least the dispatch fails if you try and call the regex on the type object.

[10:35] <masak> hm, yes.

[10:36] <masak> but until then, maybe we could have a check inside the regex method?

[10:36] <jnthn> moze byt.

[10:37] * masak likes how 'may be' and 'moze byt' are built from the same components

[10:37] *** atomicstack left
[10:37] *** zamolxes left
[10:37] <jnthn> masak: Well, it's more literally "can be"

[10:38] <masak> and 'may' means...? :)

[10:40] <masak> it comes from a proto-Germanic root *mag-, which indicates ability.

[10:40] <jnthn> heh

[10:40] <jnthn> Nice

[10:41] <jnthn> Perhaps that's proto-indo european; Russian "I can" is могу for example. :-)

[10:41] <masak> from proto-Indo-European *mogh/*megh meaning 'power', from Sanskrit mahan, 'great'. it's related to 'might'.

[10:41] <masak> yes, they're probably related.

[10:42] <masak> I never thought of that.

[10:42] <jnthn> Cute.

[10:43] <Su-Shee> "to understand the meaning of perl 6 modules, please refer to Linguistics 0.1 for beginners and consult a Sanskrit grammar of your choice. Knowledge in attic greek and japanese is helpful."

[10:43] *** Lorn joined
[10:43] <masak> even the etymology for the month May flows out of that same river.

[10:43] <jnthn> Grr. If validating XML, helps to actually load the document you're planning to validate into the reader before calling .Validate().

[10:43] <jnthn> On the upside, the first XML schema I ever wrote in my life...works straight off.

[10:44] <Su-Shee> masak: I thought may comes from mars actually?

[10:44] *** JimmyZ left
[10:44] <jnthn> It's "Mars" the word for May in...some romance language?

[10:45] <Su-Shee> yes. 

[10:45] * jnthn is very rusty on romance

[10:45] <jnthn> *romance languages

[10:45] <jnthn> :)

[10:46] <masak> Su-Shee: no, it seems to come from the greek goddess Maja/Maia, whose name has to do with might and power.

[10:46] <Su-Shee> no, I'm wrong and confusing it with march ;) 

[10:46] <Su-Shee> just looked it up. :)

[10:46] <jnthn> Oh!

[10:46] <jnthn> :-)

[10:46] <Su-Shee> jnthn: *HAHAHAHA* :)

[10:46] <masak> Swedish for Match is 'mars' :)

[10:47] <jnthn> masak: Match or March? :-)

[10:47] <masak> er.

[10:47] <masak> my typo disaster seems to not be limited to yesterday. :(

[10:47] <jnthn> Jag har en Marsbjekt!

[10:47] <masak> March. of course.

[10:47] <masak> jnthn: 'ett objekt' :)

[10:48] <jnthn> :-)

[10:48] <jnthn> masak: Gradually adding words to my "these take ett" list. :-)

[10:48] <masak> should probably have a list of 'these take en' instead... :)

[10:49] <masak> it will be shorter.

[10:49] <jnthn> masak: Huh? Aren't there a lot more common gender ones?

[10:49] <masak> let me check.

[10:49] <jnthn> I thought there were way more of those. :)

[10:50] <masak> yep. you're right. common gender is around 75%.

[10:51] <jnthn> Wow, even higher than I'd thought.

[10:51] <jnthn> (I had thought maybe 2/3-ish)

[10:51] <masak> according to Wikipedia.

[10:51] <masak> and there's a handy rule for detecting the 'ett'-form nouns.

[10:51] <jnthn> (IIUC, masculine and feminine genders merged to common a while back.)

[10:51] <jnthn> A rule? :-D

[10:51] <masak> if the plural indefinite form is the same as the singular indefinite form, it's a t-word.

[10:52] <masak> 'ett bord' -- 'flera bord'. t-word.

[10:52] <masak> the converse of the rule doesn't hold.

[10:52] <jnthn> Yeah. :-(

[10:52] <jnthn> So unless you go learning the plural indefinite forms of everything first...that only helps so much.

[10:53] <masak> sorry :/

[10:53] <jnthn> Nice to know though.

[10:53] <jnthn> Though...it sounds familiar.

[10:53] <masak> I've probably said it before.

[10:53] <jnthn> I think I may have run into it and then discarded it as "not much use" :-)

[10:54] <jnthn> I'm very much liking the "verbs in the present tense have just one form" thing though.

[10:54] <jnthn> Rather than, like, six. :-)

[10:54] <Su-Shee> you are clearly not talking about german. ;)

[10:54] <masak> jnthn: there are two if you read slightly older texts.

[10:54] <masak> but even that is pretty ok.

[10:55] <jnthn> masak: Ah, OK. I haven't run accross that.

[10:56] <jnthn> masak: I have run accross remenants of masc/fem though.

[10:56] <jnthn> lillebror vs lillasyster

[10:56] <mberends> Dutch is also a bit gender-confused. But I think French takes the cake for "un livre" and "une livre" meaning completely different things

[10:57] <masak> jnthn: aye. and 'gamle'/'gamla', and 'käre'/'kära'.

[10:58] <masak> mberends: that's not confusion, that's efficiency :P

[10:59] <jnthn> masak: I love the whole grandparents thing though.

[10:59] <Su-Shee> dutch is nice with their like three or four irregular verbs ;)

[10:59] <jnthn> masak: mormor/morfar/farmor/farfar is so nice and logical.

[10:59] <masak> aye. wouldn't have it any other way.

[10:59] <jnthn> In English its ambiguous.

[10:59] <jnthn> barnbarn is cute too :-)

[11:00] <masak> jnthn: there's farbror and mo(sy)ster, too.

[11:00] <masak> er, mo(rsy)ster.

[11:00] <jnthn> Oh, wow.

[11:00] <masak> lunch &

[11:00] <jnthn> swedish++

[11:02] *** ejs left
[11:03] <colomon> jnthn: 32,983 passing tests, one fail.

[11:04] <colomon> rakudo: <a b> X, <1 2>

[11:04] <p6eval> rakudo 5c0977:  ( no output )

[11:04] <colomon> rakudo: (<a b> X, <1 2>).perl.say

[11:04] <jnthn> colomon: oh noes a fel!

[11:04] <p6eval> rakudo 5c0977: OUTPUT«("a", "1", "a", "2", "b", "1", "b", "2")␤»

[11:04] <jnthn> colomon: What fails?

[11:05] <colomon> [~]«( <a b> X, <1 2> )

[11:05] <colomon> I kind of think the test may be wrong.

[11:05] <jnthn> Ah. :-)

[11:05] <colomon> It expects the result to be a1 a2 b1 b2

[11:07] *** ejs joined
[11:07] <colomon> that's assuming <a b> X, <1 2> produces something like (a, 1), (a, 2), (b, 1), (b 2)

[11:07] <colomon> and you can then run [~] on each of those pairs.

[11:08] <jnthn> Ah

[11:08] <jnthn> Well, it probably should produce something like that, but then the [~] implies flattening list context.

[11:09] <jnthn> I guess you'd need to explicitly stick the parcel into slice context (which is NYI in Rakudo) for that to work.

[11:09] <colomon> but "dwimmy hyper operator works recursively for any object matching the Iterable role"

[11:09] <colomon> and (a, 1) is Iterable, isn't it?

[11:09] <jnthn> I hope so. :-)

[11:11] <colomon> I'm just going to fudge that one.  and maybe TimToady can wander by and tell us if it correct or not.

[11:11] <jnthn> Good plan. :-)

[11:11] * jnthn is still a tad hazy on all that area

[11:12] <colomon> well, and you can get the same effect by doing X~ and skipping the hyper bit altogether.

[11:12] *** ejs left
[11:14] <dalek> rakudo: aebd0c5 | (Solomon Foster)++ | src/core/metaops.pm:

[11:14] <dalek> rakudo: Extend hyper to handle nested lists / arrays.  Patch courtesy of Prakash 

[11:14] <dalek> rakudo: Kailasa.

[11:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/aebd0c5f32ef311bb9d1af11c5f35ac91117ffe3

[11:15] <pugssvn> r31023 | colomon++ | [t/spec] Refudging and tweaks for nested hyper. 

[11:17] *** ejs joined
[11:19] <colomon> now to have a bit of noms and then try to knock off 20 more tests...

[11:19] *** Ross left
[11:19] *** Ross joined
[11:20] <jnthn> colonom++

[11:20] <jnthn> .oO( noms sound like a good idea... )

[11:22] *** zamolxes joined
[11:42] *** azert0x left
[11:43] *** alanhaggai joined
[11:45] <masak> phenny: tell lue that you asked why trigonometry entered into the complex version of &exp. there's an exciting field called 'complex analysis' which holds the exact answers, but the short story is that 'it all fits'. :) the closeness between exp and sin/cos can be seen through their Taylor series.

[11:45] <phenny> masak: I'll pass that on when lue is around.

[11:46] <moritz_> or the short explanation: exp(i phi) = cos(phi) + i sin(phi)

[11:47] <masak> yes, but how to explain *that* without pulling out of your hat?

[11:48] <masak> the explanation for that is that the (only possible) analytic extension of the real part of exp becomes just that.

[11:48] <masak> which is slightly unstatisfactory until you learn the math to prove it.

[11:48] <moritz_> right :-)

[11:48] <moritz_> I think I forgot that part of my math already :-)

[11:48] *** DJ-DONGDOT joined
[11:49] <moritz_> I dimly remember the results, though

[11:50] *** DJ-DONGDOT left
[11:50] <moritz_> but yeah, taylor expansion is a good way to show it

[11:50] <masak> complex analysis ranks among the most beatiful subfields of math I've studied. it's fantastic, especially given that complex numbers are relatively non-obvious, yet almost as well-behvaed as reals.

[11:51] <masak> it's like a cave of riches set up to reward curious mathematicians. :)

[11:51] * colomon has to admit he preferred real analysis.

[11:51] *** envi^home joined
[11:52] <masak> rakudo: say 3 «*» (1,2,3,4)

[11:52] <p6eval> rakudo 5c0977: OUTPUT«36912␤»

[11:52] <masak> why does that not give an error?

[11:52] <colomon> why would it?

[11:52] * moritz_ never really got to chose, given that he usually picked subjects by physical interest, not mathematical

[11:52] <masak> colomon: because the 'lists' are of different shape.

[11:53] <masak> oh wait, the arrows are pointing outwards... :)

[11:53] <moritz_> rakudo: say 3 >>*<< (1, 2, 3, 4)

[11:53] <p6eval> rakudo 5c0977: OUTPUT«Sorry, left side is too short and not dwimmy.␤  in 'hyper' at line 137:CORE.setting␤  in 'hyper' at line 150:CORE.setting␤  in main program body at line 1␤»

[11:53] <masak> nice, error. it refers to two different things by 'left side' though :P

[11:53] *** colomon_phone joined
[11:54] <masak> s/,//

[11:54] <colomon_phone> lost the last couple of lines there...

[11:55] <moritz_> colomon_phone: masak confused >>*<< with <<*>>

[11:55] <masak> aye. :/

[11:56] <colomon_phone> gotcha.  :)

[11:57] *** colomon left
[11:57] <jnthn> Aye, that error could be slightly clearer, methinks.

[11:57] <colomon_phone> I was just working on hyper on hashes, but ran out of battery with a couple of wee issues left.

[11:58] *** azert0x joined
[12:01] * moritz_ wonders if working on Str.trans would make a good Weekly Challenge

[12:01] <colomon_phone> I forgot to check  aNd see if hyperhaSh wAs in alphA....

[12:01] *** proller left
[12:02] <moritz_> rakudo: say {1 => 2, 3 => 4} >>*<< 3

[12:02] <masak> moritz_: it would sure be a nice (re-)addition to Rakudo.

[12:02] <p6eval> rakudo 5c0977: OUTPUT«Sorry, right side is too short and not dwimmy.␤  in 'hyper' at line 127:CORE.setting␤  in 'hyper' at line 150:CORE.setting␤  in main program body at line 1␤»

[12:02] <moritz_> alpha: say {1 => 2, 3 => 4} >>*<< 3

[12:02] <p6eval> alpha 30e0ed:  ( no output )

[12:03] <moritz_> masak: that much is for sure; other questions I have to ask myself is whether it's doable for a novice, or which parts of it, and how much to request

[12:04] <takadonet> morning all

[12:05] <colomon_phone> o/

[12:05] *** clintongormley joined
[12:07] *** colomon_phone left
[12:08] *** ejs left
[12:14] <masak> moritz_: has any task proven too difficult yet, in the sense that no-one has attempted it?

[12:14] <moritz_> masak: nope

[12:16] <masak> I must say I'm pleasantly surprised seeing *new* people contribute things each week.

[12:16] <moritz_> huh. Our federal president just stepped down. That's surprising. (off-topic, sorry)

[12:16] <masak> that indicates that we should probably spread out as much as possible, task-wise, so as to tickle as many people as possible at least once.

[12:24] <Su-Shee> moritz_: uhm what? *click* ;)

[12:25] <moritz_> Su-Shee: like http://www.tagesschau.de/inland/koehlerruecktritt100.html

[12:26] <moritz_> npq: $_ := 3; say(.uc) # I know this blows up, just want to know at which point

[12:27] <moritz_> nqp: $_ := 3; say(.uc) # I know this blows up, just want to know at which point

[12:27] <p6eval> nqp: OUTPUT«Confused at line 1, near "say(.uc) #"␤current instr.: 'parrot;HLL;Grammar;panic' pc 528 (src/cheats/hll-grammar.pir:196)␤»

[12:27] <Su-Shee> moritz_: already like 5 tabs open with news ;)

[12:28] *** kda left
[12:29] *** colomon joined
[12:31] * Su-Shee tststs.

[12:31] *** JimmyZ joined
[12:42] *** proller joined
[12:59] <masak> what would be a fitting logotype for Yapsi?

[13:00] <jnthn> Some kind of 6 looping back on itself somehow?

[13:00] <moritz_> a disc world standing on top of elephants on top of a giant turtle

[13:00] <masak> all 6-es loop back on themselves :P

[13:00] <jnthn> (since it's Perl 6 implemented in Perl 6)

[13:00] <moritz_> "it's turtle all the way down"

[13:00] <colomon> shouldn't be a giant parrot?

[13:00] <jnthn> masak: Well, you could think of a loopier one :-)

[13:00] <masak> a turtle is kinda nice.

[13:01] <moritz_> jnthn: a mobius strip might symbol that very well

[13:01] <colomon> camels on a parrot...

[13:01] <jnthn> Ooh, yes.

[13:01] <colomon> spectesting hyper hash patch now.

[13:01] <jnthn> I think for a logotype, the camel would kinda dwarf the Parrot, if you did relative sizes. ;-)

[13:01] * masak likes the Möbius strip idea

[13:01] <masak> jnthn: and the butterfly would be bigger than both :P

[13:03] <Juerd> Möbius-6?

[13:03] <masak> I can see how one could perhaps make a Klein bottle look like a 6...

[13:04] <masak> a Möbius strip kinda looks like a 0 or an 8 no matter how you bend it.

[13:04] <jnthn> Well, it'd need to be small for a logotype I guess...

[13:04] <jnthn> ;-)

[13:04] <Su-Shee> please no animal.. I beg you. 

[13:04] <masak> :)

[13:05] <Su-Shee> I'm so tired of all the cute cutesy open source cuddly thingies.. 

[13:05] <masak> Su-Shee: we could have a non-cuddly animal.

[13:05] <jnthn> Dugong

[13:05] <Su-Shee> no. rejected by commitee. :) moebius stripe is good!

[13:05] <jnthn> Grizzly bear

[13:05] <Su-Shee> naked molerat.

[13:06] <masak> Velociraptor.

[13:07] *** atomicstack joined
[13:07] <masak> though that's more a Perl 5 symbol ;)

[13:07] <Su-Shee> that's dino park and will trouble a) mozilla, b) disney and c) Warner Bros. ;)

[13:08] <masak> dang. :P

[13:08] <Su-Shee> design something escher like, afaik there's a couble of mathematically highly complex islamic ornaments.

[13:08] <masak> yeah, because we want to trouble Islam rather than Disney. :P

[13:09] <Su-Shee> the use of an ornament is perfectly fine.

[13:09] <Su-Shee> was just an example islamic art has plenty of pretty ornaments.

[13:10] <moritz_> it's funny, when you read parrot-dev you'll see that allison and I proposed very similar syntaxes for matching PAST nodes, only did she express it pythony and I perly :-)

[13:10] *** ejs joined
[13:10] <moritz_> and basically at the same time

[13:10] <moritz_> (I saw here mail come when I finished writing mine, but didn't read it before sending)

[13:10] <masak> multiculturalism++ # both re Islamic art and re Perl/Python

[13:11] *** Guest26513 left
[13:12] <jnthn> moritz_: It occured to me that Perl 6 signature syntax is perhaps powerful enough for that.

[13:12] <moritz_> woooh.

[13:12] *** Kejohm joined
[13:13] <jnthn> PAST::Op $node (:$returns where 'Pair', *%)

[13:13] *** Kejohm left
[13:14] <moritz_> it gets clumsy when it comes to repetition though

[13:15] <jnthn> Repetition?

[13:15] <moritz_> "5 child noeds that all return 'Int'"

[13:16] * masak .oO( junctions )

[13:16] <moritz_> *nodes

[13:16] <moritz_> masak: so how do you express the 5 as a junction?

[13:16] <masak> moritz_: I don't. I measure the length of the list of children.

[13:17] <moritz_> no problem with where { ... } blocks. But that's not declarative anymore

[13:18] *** [mark] left
[13:28] <colomon> 33,019 passing tests!

[13:28] <moritz_> rakudo: say 2**15

[13:28] <p6eval> rakudo aebd0c: OUTPUT«32768␤»

[13:28] <masak> \o/

[13:28] <pugssvn> r31024 | colomon++ | [t/spec] Unfudge the hyper hash tests. 

[13:28] <moritz_> hugme: tweet rakudoperl Rakudo now passes more than 2**15 tests! #perl6

[13:28] * hugme hugs moritz_; tweet delivered

[13:29] <masak> it would be interesting to research when Rakudo passed the other 2 ** $n thresholds...

[13:29] <masak> and then blog about it.

[13:29] <colomon> moritz_: we've actually been above 2**15 for a few days now.  :)

[13:29] <moritz_> masak: should be a SMOP, given docs/spectest-progress.csv

[13:29] <masak> oh! indeed.

[13:30] <moritz_> colomon: I know, but nobody twittered it so far :-)

[13:30] <colomon> moritz_++

[13:30] <colomon> best part is, there are obvious further hyper hash tests needed.

[13:30] <colomon> and a couple of obvious extensions to the current functionality which will be both super-cool and need even more tests.  :)

[13:32] <dalek> rakudo: 7a2ede9 | (Solomon Foster)++ | src/core/metaops.pm:

[13:32] <dalek> rakudo: Simple implementation of hyper on hashes.

[13:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7a2ede99d88bdd30d544e44c7d003efc43769e77

[13:32] <Wolfman2000> Over 65K tests...man, that's a lot.

[13:32] <Wolfman2000> ...wait, I added an extra exponent

[13:33] <masak> we passed 2**8 on 2008-05-25, 2**9 on 2008-06-01, 2**10 on 2008-06-27, 2**11 on 2008-08-05, 2**12 on 2008-09-28, 2**13 on 2009-04-04, 2**14 on 2009-10-03.

[13:33] <masak> that last one was the trig tests, I think :)

[13:34] <masak> we almost reached 2**15 with alpha. so close.

[13:36] * jnthn suspects 2**16 is going to tkae us a little while. :-)

[13:36] <moritz_> well, the exponentials are hard to get by

[13:38] <masak> not at all, there's an infinite supply of them. aleph zero.

[13:38] <masak> they're hard to get *past*, though. :P

[13:38] <masak> increasingly harder, even.

[13:38] <colomon> masak: I have one word for you.

[13:38] <colomon> automatically-generated-tests

[13:39] <colomon> (okay, it's only one word in German.  :)

[13:39] <jnthn> Most things are. :-)

[13:39] <moritz_> not even there :-)

[13:39] <jnthn> Aww. 

[13:40] <moritz_> disappointing, I know

[13:40] <moritz_> just when you need it

[13:40] *** kaare joined
[13:40] *** kaare is now known as Guest10356

[13:43] *** kda joined
[13:46] <colomon> Is there a non-modifying postfix numeric operator in p6?

[13:46] <moritz_> .succ (can't call that an operator though)

[13:47] <colomon> should have a test for it too, though.

[13:48] *** Ross left
[13:48] <jnthn> ! is the obvious one to define and test.

[13:48] <cognominal> mberends:  reading baklog "But I think French takes the cake for "un livre" and "une livre" meaning completely different things"; yes, but I don't think they are so many homographs with meaning changed according to gender in French.

[13:49] <arnsholt> There's only a handful

[13:49] *** BrowserUk left
[13:49] <mberends> oui, c'est vrai

[13:49] *** ruoso joined
[13:49] <arnsholt> There's un tour/une tour as well, but that's the only one that comes to mind right know

[13:50] <moritz_> very rare in German

[13:50] <colomon> jnthn: but if I have to define it, that's an unrelated area of code being tested.

[13:50] <arnsholt> Very rare in any language I think. It's just asking for confusion

[13:50] *** uniejo left
[13:50] <jnthn> colomon: Troo.

[13:51] * moritz_ can only come up with one example on the spot, and it's pretty weird

[13:51] <colomon> jnthn: doing it anyway, cause can't think of anything better.

[13:51] <moritz_> (der Moment = the moment; das Moment = angular force)

[13:51] <jnthn> (different meanings by gender) I think never happens in Slovak, especially given gender is very reliably predictable by the way the noun ends.

[13:52] <jnthn> (Which was *such* a nice thing. :-))

[13:53] <cognominal> I had a thread here about some french adjectives changing meaning with place (before or after name, like "grand") or gender ("public", well  when specifically used with "femme" or "homme). But these are mere curiosities too.

[13:55] <cognominal> That will be fun when we will design Perl 6 grammars with appropriate among context to translate languages.

[13:56] <cognominal> That will change from automated  statistical methods in fashion today.

[13:57] <cognominal> s/among/amount of/

[14:03] *** plobsing joined
[14:09] *** PacoLinux joined
[14:10] *** tylerni7 joined
[14:12] <arnsholt> cognominal: I'm not sure Perl 6 grammars are the right tool for NLP

[14:12] *** masonkramer joined
[14:13] <arnsholt> AFAIK most people work with formalisms that are more unification-based rather than CFG-based

[14:13] <arnsholt> But LFG does use CFGs in c-structure

[14:13] <arnsholt> (But that's only a part of the formalism)

[14:22] *** Ross joined
[14:26] *** ejs left
[14:26] *** Ross left
[14:27] *** Ross joined
[14:34] *** Ross left
[14:35] *** JimmyZ left
[14:39] *** Ross joined
[14:40] <moritz_> pmichaud++ # it would be hilarious to have Rakudo as a dependency for the PAST optimizer

[14:43] *** Ross left
[14:45] <Juerd> c

[14:45] <Juerd> s/c//

[14:47] * cognominal googles for the TLAs arnsholt throws at me :)

[14:47] <masak> pmichaud: I'm surprised at the lack of curlies around the where expression. can that work? even if it can, is it good style?

[14:48] <masak> std: sub foo($a where $a and $a) {}

[14:48] <p6eval> std 31024: OUTPUT«===SORRY!===␤Unable to parse signature at /tmp/8ESmlgwaku line 1:␤------> sub foo(⏏$a where $a and $a) {}␤Couldn't find final ')'; gave up at /tmp/8ESmlgwaku line 1:␤------> sub foo($a where $a ⏏and $a) {}␤    expecting any

[14:48] <p6eval> ..of…

[14:48] *** Ross joined
[14:48] <masak> thought so :)

[14:48] <moritz_> masak: can't work with 'and', would have to be '&' for a smart-matchable junction

[14:48] <masak> yes. that'd work.

[14:48] <masak> still, questionable to omit the closure there, IMO.

[14:48] <jnthn> It's a precedence issue there.

[14:48] <jnthn> std: sub foo($a where $a && $a) {}

[14:48] <p6eval> std 31024: OUTPUT«===SORRY!===␤Unable to parse signature at /tmp/kwzajBi5pl line 1:␤------> sub foo(⏏$a where $a && $a) {}␤Couldn't find final ')'; gave up at /tmp/kwzajBi5pl line 1:␤------> sub foo($a where $a ⏏&& $a) {}␤    expecting any

[14:48] <p6eval> ..of:␤…

[14:49] <jnthn> heh

[14:49] <moritz_> but then you'll probably need parens around the sub-smartmatch

[14:49] <jnthn> std: sub foo($a where ($a && $a)) {}

[14:49] <p6eval> std 31024: OUTPUT«ok 00:01 113m␤»

[14:49] <jnthn> Aye, probably wise.

[14:49] <moritz_> std: sub f($x where $a & $a) { }

[14:49] <p6eval> std 31024: OUTPUT«===SORRY!===␤Variable $a is not predeclared at /tmp/AxcNzZ2l6n line 1:␤------> sub f($x where $a⏏ & $a) { }␤Variable $a is not predeclared at /tmp/AxcNzZ2l6n line 1:␤------> sub f($x where $a & $a⏏) { }␤Check failed␤FAILED

[14:49] <p6eval> ..00:…

[14:49] <moritz_> std: sub f($x where $x & $x) { }

[14:49] <p6eval> std 31024: OUTPUT«ok 00:01 113m␤»

[14:50] <masak> I've used an &-junction of roles in a where clause. that feels OK, for some reason.

[14:51] <masak> subtypes, too.

[14:51] <masak> probably because it feels so declarative.

[14:53] <jnthn> It's OK so long as you don't expect it to play into candidate ordering.

[14:54] *** Ross left
[14:54] * jnthn uses Rakudo to generate test data sets for $dayjob

[14:54] <moritz_> \o/

[14:54] <moritz_> another productive use of Perl 6 :-)

[14:56] <jnthn> heh, good enough data set to crash the thing it was testing :-)

[15:03] *** patspam joined
[15:04] *** takadonet left
[15:07] *** plobsing left
[15:07] *** __2synth joined
[15:09] <dalek> rakudo: 4f9ca44 | (Solomon Foster)++ | src/core/metaops.pm:

[15:09] <dalek> rakudo: Handle single-arg hash hypers as well.

[15:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4f9ca44ecafa417c21f057ccc92f8706939da5de

[15:10] <pugssvn> r31025 | colomon++ | [t/spec] Single-op hyper hash tests. 

[15:11] *** synth left
[15:12] *** __2synth left
[15:13] *** tedv| joined
[15:16] <bbkr> rakudo.org is down :(

[15:18] <cosimo> while (! ordered(@list)) { @list = shuffle(@list) }

[15:18] <cosimo> how do i do that in perl6?

[15:19] <cosimo> and hi everyone :)

[15:19] <moritz_> @list.=pick(*) while ! [<=] @list

[15:20] <cosimo> moritz_: wow, cool

[15:20] <moritz_> I see you want to implement RandomSort, with average exponential run time :-)

[15:20] <cosimo> moritz_: i want to add a code example here

[15:20] <cosimo> http://en.wikipedia.org/wiki/Bogosort

[15:21] <moritz_> rakudo: my @l = 3, 1, 2; @l.=pick(*) while ![<=] @l; say @l.perl

[15:21] <p6eval> rakudo 7a2ede: OUTPUT«[1, 2, 3]␤»

[15:21] <moritz_> wow, there's even a name for it... didn't know that :-)

[15:22] <moritz_> rakudo: my @l = 3, 1, 2; @l.=pick(*) until [<=] @l; say @l.perl

[15:22] <p6eval> rakudo 7a2ede: OUTPUT«[1, 2, 3]␤»

[15:22] <moritz_> even nicer

[15:22] <cosimo> amazing

[15:27] * moritz_ wonders if .classify would make radix sort in Perl 6 really awesome

[15:28] <moritz_> I'm sure we can beat the python implementation by a factor of two in code length :-)

[15:29] *** Trashlord left
[15:30] <masak> rakudo: my @a = "!", a => "1", b => "2", c => "3"; my ($name, %opts) = @a; say %opts.perl # RT #74302

[15:30] <p6eval> rakudo 7a2ede: OUTPUT«{"a" => "1"}␤»

[15:30] <masak> please fix this. :/

[15:30] *** Trashlord joined
[15:30] <moritz_> masak: you can hope for pmichaud's magical list refactoring

[15:30] *** BrowserUk joined
[15:31] <cosimo> http://en.wikipedia.org/wiki/Bogosort#Perl_6

[15:31] <cosimo> \o/

[15:32] <moritz_> rakudo: my @l = 3, 1, 2; @l .= pick(*) until [<=] @l; say @l.perl

[15:32] <p6eval> rakudo 7a2ede: OUTPUT«[1, 2, 3]␤»

[15:32] <moritz_> rakudo: my @l = 3, 1, 2, 4, 5; @l .= pick(*) until [<=] @l; say @l.perl

[15:32] <p6eval> rakudo 7a2ede: OUTPUT«[1, 2, 3, 4, 5]␤»

[15:32] * cognominal tries to wrap his head around NativeCall.pm6 in zavolaj

[15:32] <moritz_> wow, still within the time limit

[15:32] <cosimo> moritz_: wikipedia doesn't have perl6 syntax highlighting, guys :-)

[15:32] <cosimo> we need to tell them

[15:33] <moritz_> and then they'll ask how to parse Perl 6

[15:33] <moritz_> and we point them to STD.pm6

[15:33] <moritz_> and they say "ugh" and move along

[15:33] <moritz_> hugme: tweet rakudoperl Bogosort #perl6 example at http://en.wikipedia.org/wiki/Bogosort#Perl_6

[15:33] * hugme hugs moritz_; tweet delivered

[15:34] <cosimo> :)

[15:35] <pmichaud> (parens or curlies in where clause)    yeah, I knew I was potentially mangling the syntax.  otoh, I wanted to make it look less complex and line-noisy

[15:35] <moritz_> cheating! :-)

[15:35] *** rgrau joined
[15:35] <pmichaud> besides, sometimes the spec itself changes in response to use cases like this :-P

[15:36] *** meppl joined
[15:36] <pmichaud> masak: the list refactoring fixes RT #74302

[15:37] <pmichaud> right now I consider list refactoring to be highest priority -- higher than closures or anything else, if only because Rakudo's current broken implementation is leading people down far too many false paths.

[15:37] <masak> agreed.

[15:37] <moritz_> +0.9

[15:37] <moritz_> (the other 0.1 parts scream "but @other_stuff is important too!!11!" :-)

[15:37] <masak> closures are easily workaroundable and not something people stumble on until after a while.

[15:38] *** takadonet joined
[15:38] <moritz_> pmichaud: if you have a plan for void-context-detection in PAST, could you write a few lines about it, and hope that somebody else takes it up?

[15:40] <pmichaud> moritz_: it's faster for me to write it than to explain it.

[15:41] <pmichaud> I mainly need to decide what to name the node type.

[15:41] <moritz_> ok

[15:41] <pmichaud> so, suggestions there would be helpful.  :)

[15:41] <pmichaud> I've already somewhat rejected PAST::Context

[15:41] <pmichaud> because "context" is often too overloaded a word.

[15:42] <moritz_> it really depends on the use case

[15:42] <moritz_> do you want it to return a boolean value?

[15:42] <pmichaud> no

[15:42] <moritz_> or more a IfVoidContext?

[15:43] <pmichaud> it's a node that says "if the caller expects xyz type, return the result of compiling self[0], otherwise return self[1]"

[15:43] <pmichaud> but it's a compile time return, not a run-time one.

[15:44] <pmichaud> (thus it's not really the same as PAST::Op(:pasttype<if>, ...), which is a runtime test.

[15:44] <masak> lol i blogged: http://use.perl.org/~masak/journal/40371

[15:46] <moritz_> masak: undef is gone. You probably meant Nil or Mu  or something. # wouldn't that be s/Mu/Any/?

[15:46] <moritz_> it's really rare that Mu is actually needed

[15:48] <masak> moritz_: I've only ever needed Nil, but since Nil misbehaves in some cases, I used Mu instead. but I can change it to Any.

[15:48] <cognominal> Masak, I am not sure you say anywhere in your blogs what CGE is

[15:48] <cognominal> GGE!

[15:48] <masak> cognominal: I could provide a link.

[15:48] <masak> the README explains what it is.

[15:49] <cognominal> I guess that this suppose cloning or looking to a git repository?

[15:51] <masak> sorry, what? no, you can read the README online.

[15:52] <moritz_> GGE is not in proto's projects.list :(

[15:53] *** zostay joined
[15:53] <masak> o.O

[15:53] <masak> please, someone feel free to add it.

[15:54] <mberends> hokay, in a few minutes

[15:55] * masak is a bit too scattered at the mo'

[15:55] * moritz_ could resist the urge to point out that masak++ has commit access to proto :-)

[15:57] <masak> :)

[15:57] <moritz_> time to go home...

[15:58] <masak> I usually add my own projects. GGE was a secret project at first, so that's how it avoided being added, I guess.

[16:04] *** ruoso left
[16:05] * pmichaud wonders when masak++ will register sekritprojects.org.  Or did he do that already and not tell anyone?!?  ;-)

[16:09] <pmichaud> afk for a while

[16:09] <masak> pmichaud: I'm not sure you've grokked the essence of a sekrit project :P

[16:10] <masak> (1) it doesn't need a website :)

[16:19] *** ruoso joined
[16:22] <cosimo> tried to summarize my interpretation of the bogosort snippet, it was a fun ride. hope it's not too much bullshit

[16:22] <cosimo> http://my.opera.com/cstrep/blog/2010/05/31/a-working-bogosort-in-perl6

[16:24] * mberends has a sekrit website at http://192.168.1.2

[16:24] <moritz_> cosimo: FYI, @list.pick(3) would pick three random elements from @list

[16:24] <moritz_> cosimo: so .pick(*) could be read as "pick all"

[16:25] <cosimo> oh, ok, now it makes sense

[16:31] <masak> swimming &

[16:31] *** masak left
[16:34] *** avar joined
[16:35] <avar> duuudes

[16:36] *** synth joined
[16:37] *** lest_away joined
[16:37] <avar> does rakudo really need to run spectests with --jobs? It churned up to load ~40 before I managed to kill it, hovering at load ~3 with just one test process

[16:37] *** lest_away is now known as lestrrat

[16:37] *** athomason joined
[16:38] <moritz_> do you have, like, very little memory available?

[16:38] <moritz_> anyway, you can disable it with an env variable (see README)

[16:38] *** mdxi joined
[16:39] <avar> I have ~500MB of RAM free, since some tests seem to take 200-300MB of memory and I have 4 cores spectest seesm to require at least 1.2GB to be comfortable with --jobs

[16:40] <avar> Anyway. Yes I can tweak it. It's just a bit unfriendly to have that as the default when rakudo is eating this amount of resources, that's all.

[16:40] <avar> Maybe it could adjust the --jobs count based on free memory

[16:40] *** mdxi left
[16:41] <moritz_> I wouldn't oppose it, but I don't know how to do it in a way that doesn't break everythiing except linux

[16:41] <moritz_> so the proverbial "patches welcome" holds, in lack of a friendlier way to phrase it (I don't mean to be rude)

[16:45] <Su-Shee> dinner, code. 

[16:47] *** pmurias joined
[16:50] *** mdxi joined
[16:58] <sorear> I just expect everything to run -j1 unless instructed otherwise

[17:01] *** finanalyst joined
[17:02] <colomon> btw, 33,043 passing tests, and I'm just getting started on the hyper hash stuff, there are a lot of neat cases to add code and tests for.  ;)

[17:03] <colomon> partying with family now, however.

[17:04] *** envi^home left
[17:06] *** takadonet left
[17:06] *** skids joined
[17:11] *** Ross joined
[17:12] <bbkr> rakudo: say (none() ~~ all()); say (none() ~~ any()); # what is the logic behind junction comparision in this case? if none() is the whole universe then it should be "1" in both cases, am i right?

[17:12] <p6eval> rakudo 4f9ca4: OUTPUT«1␤0␤»

[17:13] <moritz_> rakudo: say all() ~~ none()

[17:13] <p6eval> rakudo 4f9ca4: OUTPUT«1␤»

[17:13] <moritz_> that's easy to understand at least

[17:15] *** orafu joined
[17:15] <moritz_> ./parrot_install/bin/parrot --hash-seed 1 perl6.pbc t/spec/S05-capture/caps.rakudo

[17:15] <moritz_> fails

[17:17] <bbkr> i understand it this way: in "set theory" none() can be represented as a whole universe with excluded empty element. while all() is empty element. so all() ~~ none() should be 0.

[17:17] <moritz_> do you means s:g/element/sset/ ?

[17:18] <moritz_> for all x element A $predicate    is true for empty A in mathematics

[17:18] <moritz_> because it's defined as

[17:18] <moritz_> not exists x element A !$predicate

[17:18] <moritz_> (uhm, set, not sset)

[17:19] <bbkr> indeed, thanks, it's clear now. moritz_++ 

[17:20] *** fda314925 left
[17:21] *** fda314925 joined
[17:27] <moritz_> rakudo: 'abc' ~~ /<alpha>/; $<alpha> = 5; say $<alpha>

[17:27] <p6eval> rakudo 4f9ca4: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/xJObQUaCPT␤»

[17:29] <jnthn> That "at line 1" is bull.

[17:29] *** patrickas joined
[17:29] <patrickas> sabaho perlsixers

[17:30] <jnthn> o/ patrickas 

[17:30] <moritz_> oh hai

[17:30] * patrickas really enjoyed the perl6 bogosort thingy :)

[17:30] <patrickas> hello moritz_, jnthn

[17:31] <jnthn> There's a name for even the silliest algorithms. :-)

[17:31] <moritz_> actually it's a non-algorithm

[17:31] <moritz_> at least I've learned in my CS classes that an algorithm has to terminate

[17:32] <jnthn> It'll terminate when a Rakudo memory leak causes the process to be killed.

[17:32] <jnthn> ;-)

[17:35] <moritz_> wow, I get random parrot + rakudo behaviour even if I set hash seed by command line option

[17:37] <jnthn> On chunks.t?

[17:38] <moritz_> caps.t

[17:38] <moritz_> but it doesn't need .caps or .chunks to reproduce

[17:42] <Su-Shee> mberends: Unable to find module 'FakeDBD::CSV' in the @*INC directories. Did I miss something?

[17:42] <Su-Shee> (while make-ing)

[17:44] *** pmurias left
[17:45] <patrickas> I'm going over the perl6 advent calendar making sure all the example work on rakudo....

[17:46] <patrickas> in day 2 the one liner at the bottom does not work on windows (quotes need to be inverted) which is not rakudo's fault, but could be mentioned in the post

[17:46] <mberends> Su-Shee: oops, that's a bit of the future that hasn't been backported to the present yet ;)

[17:46] <mberends> please comment out any mention of FakeDBD::CSV

[17:47] <mberends> also, this points out a need to 'soft fail' on unmet dependencies. hmm.

[17:48] <Su-Shee> ah, there it is. 

[17:54] *** cdarroch joined
[17:54] *** cdarroch left
[17:54] *** cdarroch joined
[17:54] *** Jedai joined
[17:55] <avar> moritz_: The current behavior is obviously how the devs prefer it. I don't see how to patch it without mucking up the current behavior.

[17:56] <avar> moritz_: I just try to check out perl biannualy. Tested it on a linode and had to hard-kill it from a console because it locked up the box in ~30 load because I ran spectest and went away for tea ;/

[17:56] <avar> running it on one core was pretty cpu/memory heavy too, but it got through it

[17:56] <Su-Shee> ha. I knew it. Positional of Str. 

[17:58] <mberends> yes, all you probably needed was to call the same lib func once per column.

[17:58] <Su-Shee> yes. darn. ;)

[17:59] *** pmurias joined
[18:01] <sorear> well, you see, the devs are running on real computers

[18:01] <sorear> with 3+ GB of memory and 4+ cores

[18:04] <patrickas> rakudo: my $b = Nil; $b //= 7; say $b;

[18:04] <p6eval> rakudo 4f9ca4: OUTPUT«␤»

[18:04] <patrickas> rakudo: my $b = Any; $b //= 7; say $b;

[18:04] <p6eval> rakudo 4f9ca4: OUTPUT«7␤»

[18:06] *** atomicstack left
[18:06] <Su-Shee> mberends: that kind of sub with returns Positional of Str - what is that exactly? why doesn't it have ; and why is { ... } ok?

[18:08] <mberends> Su-Shee: it's how zavolaj registers native functions as subs

[18:09] <Su-Shee> mberends: it looks nice.

[18:09] <mberends> the data types determine how values are sent to / returned from the lib

[18:09] <mberends> jnthn++ for zavolaj

[18:10] <jnthn> Su-Shee: Esssentially, it uses Perl 6 signature introspection to map args to C types and, but the Parrot NCI does most of the hard work really. :-)

[18:10] <jnthn> s/ and//

[18:10] <Su-Shee> what it does I understand basically - I was wondering about the style. 

[18:10] <jnthn> Su-Shee: { ... } is just a stub - essentially the body is replaced by something that magically forwards the call to the C library

[18:11] <jnthn> It'd actually work fine with just an empty block too.

[18:11] *** gbacon joined
[18:11] *** TiMBuS left
[18:11] <jnthn> But I like it with the ... as "something to come here" :-)

[18:11] <Su-Shee> jnthn: that's zavolaj specific or a basic p6 feature?

[18:11] <jnthn> Su-Shee: Which bit? The ... ?

[18:11] <jnthn> Su-Shee: That's general syntax for declaring stub code.

[18:11] <Su-Shee> jnthn: looks like "..." as in "well you know what to do" ;)

[18:11] <jnthn> rakudo: sub foo() { ... }; say foo()

[18:11] <p6eval> rakudo 4f9ca4:  ( no output )

[18:11] <jnthn> ...huh

[18:12] <jnthn> oh, locally it says "Stub code executed"

[18:12] <jnthn> Don't know what's up with p6eval.

[18:12] <mberends> rakudo: ...

[18:12] <p6eval> rakudo 4f9ca4:  ( no output )

[18:12] <Su-Shee> I'm always envious when ruby folks have that pretty shortened code. 

[18:14] *** molaf joined
[18:14] *** kda left
[18:17] <Su-Shee> submethods? when did that happen?

[18:21] <pmurias> http://pages.cs.wisc.edu/~liblit/pldi-2009-b/ # a really cool way of automatically generating bindings to c libraries

[18:21] <mberends> Su-Shee: the ... spec: http://perlcabal.org/syn/S03.html#line_2223

[18:22] <Su-Shee> ah, nice.

[18:23] <Su-Shee> "stubby exception generators" - noone will believe me if I say this. :) 

[18:25] <jnthn> Just wait until you have to tell them about phasers. :-)

[18:26] <Su-Shee> aaah I just forgot a ++ on saturday.. I'm such an idiot. :))

[18:26] <Su-Shee> jnthn: I already tried. ;)

[18:27] <moritz_> jnthn: in a parameter trait, will I be able to get a reference to multi candidate it's in?

[18:27] *** tedv| left
[18:27] <moritz_> ie for   multi foo($x is autothreaded, ... ) I want to grab the current candidate to add a few more of them

[18:28] <moritz_> in the 'autothreaded' trait handler

[18:33] <jnthn> moritz_: Hmm...not quite sure how that'd work.

[18:33] <jnthn> moritz_: Maybe it could be made available as some contextual.

[18:33] <moritz_> that might work, yes

[18:34] <jnthn> Dunno, I can see the use case. Probably needs more thought. Nobody implemented parameter traits yet.

[18:34] <jnthn> (as in, custom ones)

[18:34] <jnthn> They're not so hard to do, mind.

[18:35] <patrickas> rakudo: my $b = Nil; $b //= 7; say $b; #Is that supposed to print 7 ?

[18:35] <p6eval> rakudo 4f9ca4: OUTPUT«␤»

[18:36] <moritz_> I think so, yes

[18:36] <moritz_> rakudo: say (my $b = Nil).defined

[18:36] <p6eval> rakudo 4f9ca4: OUTPUT«1␤»

[18:36] <moritz_> rakudo: say (my $b = Nil).perl

[18:36] <p6eval> rakudo 4f9ca4: OUTPUT«()␤»

[18:37] <patrickas> rakudo: say Nil.defined;

[18:37] <p6eval> rakudo 4f9ca4: OUTPUT«0␤»

[18:37] <moritz_> it should be the other way round :-)

[18:37] <moritz_> Nil.defined should be True, and assignment to a variable should turn it into Any

[18:38] <jnthn> nomtime!

[18:38] * moritz_ already had some tasty nom

[18:38] * Su-Shee had egg salad with green asparagus.

[18:39] * moritz_ had white asparagus yesterday - 0.5kg per person :-)

[18:40] <pugssvn> r31026 | moritz++ | [t/spec] fudge randomly failing tests for Rakudo 

[18:40] <Su-Shee> minimum :)

[18:46] *** alanhaggai left
[18:46] *** masonkramer left
[18:46] *** alanhaggai joined
[18:47] <moritz_> rakudo: pir::sleep(Inf); say "alive"

[18:47] <p6eval> rakudo 4f9ca4: OUTPUT«===SORRY!===␤The opcode 'sleep_p' (sleep<1>) was not found. Check the type and number of the arguments␤»

[18:47] <moritz_> rakudo: pir::sleep_vN(Inf); say "alive"

[18:47] <p6eval> rakudo 4f9ca4: OUTPUT«error:imcc:syntax error, unexpected PREG, expecting '(' ('$P45')␤  in file 'EVAL_1' line 65␤===SORRY!===␤syntax error ... somewhere␤»

[18:47] <moritz_> rakudo: pir::sleep__vN(Inf); say "alive"

[18:48] <p6eval> rakudo 4f9ca4:  ( no output )

[18:49] *** clintongormley left
[18:51] *** clintongormley joined
[18:51] <Su-Shee> \o/ someid somedata something somethingelse ;)

[18:52] <moritz_> not the classical 'fooid foo bar baz'? :-)

[18:52] *** masak joined
[18:53] <Su-Shee> it's from fetchrow_hashref :)

[18:54] <patrickas> rakudo: sub lsay(@a) { @a.perl.say }; lsay (1, 2, 3, 4)>>++;

[18:54] <p6eval> rakudo 4f9ca4: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in 'hyper' at line 5466:CORE.setting␤  in main program body at line 1␤»

[18:55] <patrickas> Is that the right behaviour ? 

[18:55] <moritz_> yes

[18:55] <moritz_> just like 1++ is forbidden

[18:56] <patrickas> yea that makes sense ... it it strage that it is used as an example in the advent calendar ... maybe alpha was buggy ....

[18:56] <moritz_> it was

[18:59] <avar> moritz_: Just t/spec/integration/advent2009-day17.t takes ~600MB to run. It seems it (and maybe tests like it) are actually the main problem

[18:59] <avar> I can't run it to completion without locking up my box

[19:00] <moritz_> avar: we'll probably move some of those tests to an extra test target

[19:00] <avar> should I file a bug for it?

[19:00] <moritz_> if you feel like, yes

[19:00] <avar> (is there a bug reporting tool?)

[19:00] <moritz_> nope

[19:01] <avar> email?

[19:01] <moritz_> [email@hidden.address]
[19:01] *** tri1 joined
[19:02] <masak> heh. the Wikipedia user who made the bogosort addition has made one edit in total. :)

[19:03] <pugssvn> r31027 | moritz++ | [t/spec] test for RT #61772, *@a is copy messed up in Rakudo 

[19:03] <moritz_> 100% Perl 6 contributions!

[19:04] <patrickas> rakudo: my @a = (1, 2, 3, 4) ; @a >>/=>> 2; #I know this is the same case but it feel like it should dwim

[19:04] <p6eval> rakudo 4f9ca4: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in 'hyper' at line 143:CORE.setting␤  in 'hyper' at line 150:CORE.setting␤  in main program body at line 1␤»

[19:04] <dalek> rakudo: cde6abe | moritz++ | src/core/system.pm:

[19:04] <dalek> rakudo: enable argumentless sleep(); closes RT #57294

[19:04] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cde6abe86278dd11e335d8b7bd24036dcbc51c14

[19:04] <moritz_> patrickas: that one should work

[19:04] <masak> ah, it's cosimo++. :)

[19:05] <patrickas> oh ok in that case I'll add a test for it

[19:05] <moritz_> when it's assigned to an array first, it has a mutable container

[19:05] <moritz_> that's why this case is supposed to work, but not the one before

[19:06] *** masonkramer joined
[19:06] <avar> moritz_: ok, sent

[19:06] <moritz_> avar++

[19:08] *** finanalyst left
[19:10] <moritz_> rakudo: sub f($x) as Int { "12" }; say f(3).perl

[19:10] <p6eval> rakudo 4f9ca4: OUTPUT«===SORRY!===␤Could not find sub &trait_mod:<as>␤»

[19:14] <moritz_> rakudo: sub f($x as Int) { say $x.perl }; f("42")

[19:14] *** bluescreen joined
[19:14] <p6eval> rakudo 4f9ca4: OUTPUT«42␤»

[19:14] *** bluescreen is now known as Guest56962

[19:14] <moritz_> where's that implemented? in the binder somewhere?

[19:14] <jnthn> moritz_: Yeah

[19:15] <jnthn> moritz_: The compiler knows about that one.

[19:16] <moritz_> when I have a type object, how do I coerce to that type in current Rakudo?

[19:16] <moritz_> ooh, I know

[19:16] <moritz_> my $typename = $type.WHAT.perl()

[19:16] <moritz_> $obj."$typename"()

[19:17] <Su-Shee> I have a stupid question.. "self" without $ .. where does that come from?

[19:17] <moritz_> rakudo: sub f($x) { $x }; &f.wrap({ say "foo" }); f(3)

[19:17] <p6eval> rakudo 4f9ca4: OUTPUT«No such attribute 'proxy' in class 'Sub'␤  in main program body at line 1␤»

[19:17] <moritz_> Su-Shee: from the compiler

[19:17] <moritz_> Su-Shee: a bit like 'this' in C++

[19:18] <Su-Shee> wait, am I just confused now..

[19:18] <moritz_> bah. If &sub.wrap was working, implementing 'as' coercion would be a piece of cake

[19:19] <Su-Shee> I'm just confused. 

[19:19] <Su-Shee> perl 5 and 6 and javascript is too much.

[19:20] <masak> Su-Shee: consider 'self' as a special term that is defined within the confines of a method body.

[19:20] <pugssvn> r31028 | patrickas++ | Added test for in-place operators 

[19:22] *** masak left
[19:30] <jnthn> moritz_: Yeah, wrap needs re-doing for master.

[19:34] <pugssvn> r31029 | patrickas++ | Added test for map form and hyperoperator form. 

[19:38] <pugssvn> r31030 | moritz++ | [t/spec] test for RT #64310, $^a after my $a 

[19:39] *** patrickas left
[19:43] *** molaf left
[19:45] <moritz_> rakudo: my @a=1,2,3; say ( ^@a ).perl

[19:45] <p6eval> rakudo 4f9ca4: OUTPUT«0..^3␤»

[19:47] <moritz_> rakudo: say :(3).params[0]

[19:47] <p6eval> rakudo 4f9ca4: OUTPUT«Parameter()<0x1d90c70>␤»

[19:48] <moritz_> rakudo: say :(3).params[0].constraints

[19:48] <p6eval> rakudo 4f9ca4: OUTPUT«3␤»

[19:48] <jnthn> rakudo: say :(3).params[0].type

[19:48] <p6eval> rakudo 4f9ca4: OUTPUT«Int()␤»

[19:48] <jnthn> nice :-)

[19:51] <pugssvn> r31031 | moritz++ | [t/spec] Test for RT #70720, :(3) has the 3 available to introspection 

[19:54] *** lue joined
[19:55] <lue> hello!

[19:55] <phenny> lue: 11:45Z <masak> tell lue that you asked why trigonometry entered into the complex version of &exp. there's an exciting field called 'complex analysis' which holds the exact answers, but the short story is that 'it all fits'. :) the closeness between exp and sin/cos can be seen through their Taylor series.

[19:55] <moritz_> rakudo: say '4' ~~ /<-alpha>/

[19:55] <p6eval> rakudo 4f9ca4: OUTPUT«4␤»

[19:55] <moritz_> rakudo: say '4' ~~ /<!alpha>/

[19:55] <p6eval> rakudo 4f9ca4: OUTPUT«␤»

[20:01] *** tri1 left
[20:02] *** Psyche^ joined
[20:03] <pugssvn> r31032 | moritz++ | [S05] correct think in .trans example 

[20:03] <pugssvn> r31032 | 

[20:03] <pugssvn> r31032 | A zero-width assertion doesn't do us any good here.

[20:04] <moritz_> I'm currently thinking about how to implement Str.trans

[20:05] <moritz_> and I find that I have a hard time coming up with an efficient scheme

[20:05] <moritz_> that handles both regexes and literals as patterns well

[20:06] <moritz_> any ideas?

[20:06] *** Patterner left
[20:06] *** Psyche^ is now known as Patterner

[20:10] <moritz_> rakudo: my @x = <a b d>; say 'a' ~~ /@x/; say 'c' ~~ /@x/;

[20:10] <p6eval> rakudo 4f9ca4: OUTPUT«␤␤»

[20:10] <moritz_> huh? I thought that was working...

[20:10] * lue heads for S32::String [Or whatever it is]

[20:12] <jnthn> moritz_: me too...

[20:12] <lue> wow. The spec is a big help on str.trans [at least in S32]

[20:12] <lue> </sarcasm>

[20:12] <moritz_> lue: http://perlcabal.org/syn/S05.html#Transliteration

[20:12] <jnthn> rakudo: my $x = <a b d>; say 'a' ~~ /$x/; say 'c' ~~ /$x/;

[20:12] <p6eval> rakudo 4f9ca4: OUTPUT«␤␤»

[20:12] <jnthn> rakudo: my $x = 'a'; say 'a' ~~ /$x/; say 'c' ~~ /$x/;

[20:12] <p6eval> rakudo 4f9ca4: OUTPUT«a␤␤»

[20:13] <jnthn> :-S

[20:16] <lue> lets see... if I were to type "hi".trans("i" => "o") I would get "ho" ?

[20:16] <moritz_> rakudo: tr/a/b/

[20:16] <p6eval> rakudo 4f9ca4: OUTPUT«===SORRY!===␤Confused at line 11, near "tr/a/b/"␤»

[20:16] <moritz_> alpha: say "hi".trans("i" => "o")

[20:16] <p6eval> alpha 30e0ed: OUTPUT«ho␤»

[20:18] <lue> I would imagine some sort of translation. The easiest I see is literal -> regex, then all you deal with is a regex.

[20:19] <moritz_> and then you have to determine which regex matched

[20:19] <lue> alpha: say "Help keep our e's on earth!".trans("e" => " ")

[20:19] <p6eval> alpha 30e0ed: OUTPUT«H lp k  p our  's on  arth!␤»

[20:19] <moritz_> so either you need some cleverness involved there, or match each regex separately (expensive)

[20:20] <lue> or, if you want to be crafty, the other way around

[20:20] <lue> regex -> literal

[20:21] <lue> alpha: say "   something    or other  about whitespace".trans( / \s+ / => ' ' )

[20:21] <p6eval> alpha 30e0ed: OUTPUT« something or other about whitespace␤»

[20:21] <sorear> moritz_: { make $replacement_str }

[20:21] <moritz_> sorear: so... compile each alternative to a separate proto regex?

[20:22] *** Su-Shee left
[20:23] *** Su-Shee joined
[20:24] <sorear> moritz_: or just put them in a single alternation

[20:24] <moritz_> with eval? or how do I get the { make $replacement} into each branch?

[20:29] <moritz_> http://perlgeek.de/blog-en/perl-6/contribute-now-Str-trans.html lolihazblogth

[20:31] <jnthn> moritz_++

[20:31] *** justatheory joined
[20:32] <moritz_> having a simple variant would already help me for JSON::Tiny :-)

[20:32] <moritz_> (probably could come up with such a thing in 10 minutes... but others should have fun too)

[20:34] * Su-Shee had her fun for today and pushed it out already. ;)

[20:34] *** eternaleye left
[20:34] <lue> what is the difference between s/// and tr/// ?

[20:35] <moritz_> s/ab/cd/ will replace 'ab' by 'cd', but leave 'a' alone

[20:35] <moritz_> tr/ab/cd/ will replace each a by c, and each b by d

[20:35] <moritz_> also tr does global transliteration, s/// defaults to one substitution only (needs :g for all)

[20:36] <lue> alpha: say "abra".trans("ab"=>"cd")

[20:36] <p6eval> alpha 30e0ed: OUTPUT«cdrc␤»

[20:36] <lue> ah. Well, there goes using s/// :P

[20:39] *** kda joined
[20:44] <sorear> tr/// also does left-to-right longest token matching

[20:45] <sorear> there is no reasonable way to change \" into " in a string while allowing backslashes to be escaped using s///

[20:45] <sorear> with tr, it's trivial

[20:46] *** jaldhar left
[20:46] <moritz_> example?

[20:46] <sorear> "\\\\" -> "\\\\", "\\\"" -> "\""

[20:46] *** jaldhar joined
[20:46] <moritz_> I mean, tr example?

[20:46] <sorear> that was the tr example

[20:47] <moritz_> I don't see a tr/ in there

[20:47] <sorear> I don't know the tr syntax offhand

[20:47] <lue> rakudo: say '"'

[20:47] <p6eval> rakudo cde6ab: OUTPUT«"␤»

[20:48] <moritz_> as I understand S05, you can't do that with tr directly, only with the method form

[20:48] <moritz_> (ok, it's nit-picking, I admit)

[20:49] *** eternaleye joined
[21:02] <Su-Shee> <-- bed. tomorrow cleanup. good night everyone. :)

[21:02] <jnthn> o/

[21:07] *** Su-Shee left
[21:07] *** kel_ left
[21:08] *** Guest56962 left
[21:09] <lue> rakudo: $/<a><b>; say "Alive!"

[21:09] <p6eval> rakudo cde6ab: OUTPUT«Method 'postcircumfix:<{ }>' not found for invocant of class ''␤  in main program body at line 1␤»

[21:10] <sorear> viv can handle that :>

[21:10] <lue> My question is: where'd the { } come from?

[21:10] <moritz_> from the < >

[21:10] <moritz_> see S02 and S05

[21:12] <lue> afk

[21:12] *** Ross left
[21:12] *** Guest10356 left
[21:26] *** kda left
[21:26] <sorear> TimToady: How does ./std precompile modules?  Looking at it it seems to just be a thin wrapper over STD->parsefile

[21:32] <pugssvn> r31033 | sorear++ | [viv] In $<foo> = (bar), for gimme5 compatibility, disable binding to $0. 

[21:38] *** pnate joined
[21:42] <pmurias> sorear: would it be difficult to expose viv as a library so i could conviently get access to VAST for mildew (without resorting to evil tricks to subvert the executable)?

[21:43] <sorear> The VAST-generating part of viv already is a library

[21:44] <sorear> use STD; use Actions; STD->parsefile(..., actions => 'Actions')->{_ast}

[21:45] *** rgrau left
[21:45] <sorear> 'Actions' dynamically generates VAST::foo classes; the VAST:: classes "defined" in viv are most correctly viewed as supercede class VAST::foo { ... }

[21:48] <pmurias> ok thanks will attempt to remove the hackery tommorrow

[21:52] *** kda joined
[21:52] *** kda left
[21:57] <sjohnson> std: my $a;

[21:57] <p6eval> std 31032: OUTPUT«ok 00:01 114m␤»

[21:58] *** ruoso left
[22:02] *** pmurias left
[22:11] *** pnu joined
[22:20] *** pyrimidine joined
[22:21] <pyrimidine> regarding Str.trans, I had an implementation working on my github fork

[22:24] *** pnu left
[22:26] *** pnu joined
[22:26] <[Coke]> phenny: tell patrickas to check the advent tests in t/spec/integration

[22:26] <phenny> [Coke]: I'll pass that on when patrickas is around.

[22:27] <pyrimidine> moritz_: here is the latest version for Str.trans that was passing tests (including closures) http://gist.github.com/420337

[22:28] <pyrimidine> moritz_: the alternation capture is really slowing things down, though

[22:28] <pyrimidine> could be optimized

[22:33] <pyrimidine> moritz_: In the gist, it's called trans2 (I implemented a version of .trans in Cool-str.pm that broke at some point).  

[22:40] *** pyrimidine left
[22:46] *** pyrimidine joined
[22:51] <pyrimidine> phenny: tell moritz_ that there is a partially working .trans implementation (including closures and :d, :s) at http://gist.github.com/420337, but there are issues with regex name mapping.  Also, odd bug with array version mapping (tests with "&nbsp;&lt;&gt;&amp;" string are not parsing).

[22:51] <phenny> pyrimidine: I'll pass that on when moritz_ is around.

[23:01] *** orafu left
[23:01] *** orafu joined
[23:29] *** azert0x left
[23:31] *** pyrimidine left
[23:38] *** masonkramer left
[23:54] *** clintongormley left
