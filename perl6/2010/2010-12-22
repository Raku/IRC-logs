[00:04] *** wamba left
[00:18] *** hudnix joined
[00:20] *** lopaway is now known as lopnor

[00:23] *** lopnor is now known as lopaway

[00:24] *** risou joined
[00:30] *** nymacro joined
[00:35] *** shi left
[01:02] *** QinGW joined
[01:13] *** rgrau left
[01:14] <dalek> niecza/cilbackend: 86933d1 | sorear++ | lib/CLRBackend.cs:

[01:14] <dalek> niecza/cilbackend: Add primitives for autovivification

[01:14] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/86933d1933

[01:14] <dalek> niecza/cilbackend: e79c528 | sorear++ | lib/CLRBackend.cs:

[01:14] <dalek> niecza/cilbackend: More misc bindings

[01:14] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/e79c528f80

[01:14] <dalek> niecza/cilbackend: 5223934 | sorear++ | lib/CLRBackend.cs:

[01:14] <dalek> niecza/cilbackend: Add returnable handling, rudiments of exception handler tracking

[01:14] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/5223934c87

[01:20] *** kdaiba joined
[01:23] *** redicaps joined
[01:34] *** risou_ joined
[01:35] *** jhuni joined
[01:35] *** risou left
[01:36] *** Alias_ left
[01:41] *** kiithroen joined
[01:49] *** glow left
[01:52] *** nymacro left
[01:53] *** risou_ left
[01:56] *** nymacro joined
[02:38] *** ShaneC left
[02:38] *** nymacro left
[02:42] <flussence> usually I'd consider messing around with code at 02:30 a bad idea, but I managed to fix a segfault *and* file a semi-coherent bug report about it this time...

[02:43] * flussence steps away from the keyboard before I jinx it :)

[02:43] *** copyleft left
[02:49] *** agentzh joined
[03:05] <dalek> niecza/cilbackend: 347dcb7 | sorear++ | lib/CLRBackend.cs:

[03:05] <dalek> niecza/cilbackend: Add gather_hack, fix my @foo

[03:05] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/347dcb79f8

[03:05] <dalek> niecza/cilbackend: e060adb | sorear++ | lib/CLRBackend.cs:

[03:05] <dalek> niecza/cilbackend: Add cast, many more misc bindings

[03:05] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/e060adb554

[03:05] <dalek> niecza/cilbackend: 5f19070 | sorear++ | lib/CLRBackend.cs:

[03:05] <dalek> niecza/cilbackend: &die, other misc bindings

[03:05] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/5f190703d8

[03:05] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[03:10] <colomon> rakudo: say 2.rand

[03:10] <p6eval> rakudo cae7f9: OUTPUT«1.22047050967279␤»

[03:10] <colomon> rakudo: say (1, 2).rand

[03:10] <p6eval> rakudo cae7f9: OUTPUT«0.721460723033431␤»

[03:10] <colomon> rakudo: say (1, 2).pick

[03:10] <p6eval> rakudo cae7f9: OUTPUT«1␤»

[03:10] <colomon> rakudo: say (1, 2).pick

[03:10] <p6eval> rakudo cae7f9: OUTPUT«1␤»

[03:12] <sorear> perl6: my $wc = rand * *; say $wc(1); say $wc(2)

[03:12] <p6eval> rakudo cae7f9: OUTPUT«0.706005393152253␤0.435747933650667␤»

[03:12] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "$wc"␤    expecting "=", context, ":" or "("␤    at /tmp/nofD6WhPUX line 1, column 4␤»

[03:13] <sorear> rakudo: my $wc = rand * *; say $wc(1) == $wc(1)

[03:13] <p6eval> rakudo cae7f9: OUTPUT«Bool::False␤»

[03:13] <sorear> alpha: my $wc = rand * *; say $wc(1) == $wc(1)

[03:13] <p6eval> alpha : OUTPUT«1␤»

[03:14] <sorear> alpha: my $wc = rand * *; say $wc(1); say $wc(2);

[03:14] <p6eval> alpha : OUTPUT«0.254515018154965␤0.50903003630993␤»

[03:21] <colomon> sorear: what are you looking for here?

[03:22] *** sjn joined
[03:23] <sjn> moritz_: should "RoleHOW.new" be "Role.HOW.new" in your advent calendar post for today?

[03:24] <sorear> colomon: TimToady to declare that alpha was right, ideally

[03:25] <colomon> by what logic?

[03:26] <colomon> oooo.... rand is evaluated before the closure is made?

[03:27] <sorear> yes

[03:28] <colomon> alpha: my $wc = { rand * $_ }; say $wc1(1) == $wc(2)

[03:28] <p6eval> alpha : OUTPUT«Symbol '$wc1' not predeclared in <anonymous> (/tmp/qSqEn6Y0aI:10)␤in Main (file <unknown>, line <unknown>)␤»

[03:28] <colomon> alpha: my $wc = { rand * $_ }; say $wc(1) == $wc(1) 

[03:28] <p6eval> alpha : OUTPUT«0␤»

[03:29] <colomon> hmmm

[03:32] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[03:32] <colomon> alpha: sub frand() { rand }; my $wc = frand * *; say $wc(1) == $wc(1)

[03:32] <p6eval> alpha : OUTPUT«Confused at line 10, near "*; say $wc"␤in Main (file <unknown>, line <unknown>)␤»

[03:32] <colomon> alpha: sub frand() { rand }; my $wc = frand() * *; say $wc(1) == $wc(1)

[03:32] <p6eval> alpha : OUTPUT«1␤»

[03:33] *** nymacro joined
[03:38] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[03:39] *** lichtkind left
[03:53] *** nymacro left
[03:58] *** Khisanth left
[04:02] *** Khisanth joined
[04:03] *** adu joined
[04:03] *** TimToady_ is now known as TimToady

[04:06] *** sftp left
[04:08] *** satyavvd joined
[04:26] *** starcoder left
[04:32] *** adu left
[04:33] *** starcoder joined
[04:48] *** orafu left
[04:48] *** orafu joined
[04:49] *** araujo left
[05:00] *** cdarroch left
[05:04] *** s1n left
[05:05] *** s1n joined
[05:37] *** cschimm1 left
[05:39] *** f00li5h left
[05:39] *** justatheory left
[05:39] *** justatheory joined
[05:45] *** justatheory left
[05:48] *** industry__ joined
[05:55] *** justatheory joined
[05:57] *** f00li5h joined
[06:03] *** justatheory_ joined
[06:03] *** justatheory left
[06:03] *** justatheory_ is now known as justatheory

[06:24] *** xinming_ is now known as xinming

[06:33] *** am0c^2 joined
[06:35] *** am0c^ left
[06:53] *** ch3ck3r left
[06:58] *** industry__ left
[06:59] *** _kaare joined
[07:05] *** am0c^2 left
[07:13] *** justatheory left
[07:14] *** am0c^ joined
[07:18] <dalek> niecza/cilbackend: b56f60d | sorear++ | lib/CLRBackend.cs:

[07:18] <dalek> niecza/cilbackend: indexes, array construction

[07:18] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/b56f60d406

[07:18] <dalek> niecza/cilbackend: 4076928 | sorear++ | / (4 files):

[07:18] <dalek> niecza/cilbackend: Bindings for basic regex function

[07:18] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/407692831d

[07:18] <dalek> niecza/cilbackend: aa2b8f9 | sorear++ | lib/CLRBackend.cs:

[07:18] <dalek> niecza/cilbackend: set_status and a module Foo; hack

[07:18] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/aa2b8f97f9

[07:20] *** fhelmberger joined
[07:27] *** am0c joined
[07:28] *** fhelmberger left
[07:32] *** cschimm1 joined
[07:41] *** cognominal left
[08:05] *** lopaway is now known as lopnor

[08:10] *** zby_home_ joined
[08:18] *** masak joined
[08:18] <masak> morning, zebras.

[08:18] <masak> moritz_++ # slot #22

[08:18] <cotto> I liked that one.

[08:19] *** Axius joined
[08:20] <masak> also, contestants 11 and 12 have now signed up for http://strangelyconsistent.org/blog/masaks-perl-6-coding-contest

[08:20] <masak> remember that you can only sign up until the 24th!

[08:25] *** am0c^ left
[08:29] <masak> I like this tweet: http://twitter.com/robreed/status/17354662386601984

[08:33] *** jhuni left
[08:37] <sorear> hello masak

[08:37] <masak> hi sorear. how proceeds the refactor?

[08:37] <sorear> ahead of schedule.

[08:38] *** kdaiba left
[08:38] <masak> :)

[08:38] <sorear> it could be ready by v1

[08:39] <masak> that's great.

[08:40] <masak> 2010-12-29?

[08:40] <sorear> 27

[08:40] *** envi joined
[08:41] <masak> ok.

[08:41] <sorear> think 29 would be better?  I haven't published my schedule yet :)

[08:41] <masak> I think a simple rule is good.

[08:41] <masak> I saw v0 was 2010-11-29, so I took a guess :)

[08:41] *** glow joined
[08:42] <sorear> Rakudo's rule is the somethingth thursday, so I took the last Monday

[08:42] <masak> will the Perl 5 dependency go away with v1?

[08:42] <masak> oh, last Monday is a good rule.

[08:42] <sorear> *-*-29 will cause problems with v3

[08:42] <masak> right.

[08:42] <sorear> v1 will definitely still have Perl 5

[08:43] <sorear> v2 has a good chance of being bootstrapped

[08:43] <masak> cool!

[08:43] <sorear> after I sort out this mess of data storage formats

[08:44] <sorear> (redundandly storing module metadata using Storable and JSON::XS won't work very well in the Perl 6 world...)

[08:46] *** fhelmberger joined
[08:47] <masak> no.

[08:48] *** envi left
[09:16] *** kensanata joined
[09:21] *** Axius left
[09:23] *** ch3ck joined
[09:23] *** taoz joined
[09:24] *** taoz left
[09:25] <dalek> niecza/cilbackend: 77f59fd | sorear++ | lib/CLRBackend.cs:

[09:25] <dalek> niecza/cilbackend: Start on SubInfo thawer generator

[09:25] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/77f59fdc73

[09:25] *** noganex joined
[09:25] <ch3ck> morrn masak 

[09:26] <masak> hey

[09:26] <masak> rakudo: say { foo => Bool } ~~ :!foo

[09:27] <p6eval> rakudo cae7f9: OUTPUT«Bool::False␤»

[09:27] <masak> I never got any second opinion from anyone about this.

[09:27] <masak> shall I just (*gasp*) apply my own good judgement and declare this Wrong?

[09:27] <masak> basically, I consider Bool a less fortunate version of False.

[09:29] <masak> also, I'd like a third opinion on TimToady's statement that chaning Bool.Bool to just { self } might be bad for circularity-saw reasons. I don't see that it would.

[09:30] *** kiithroen left
[09:31] <sorear> masak: under S13 doctrine, any method named .Bool ought to return a Bool

[09:31] <masak> well, I agree with that.

[09:32] <sorear> there may be stronger things than Liskov at work here

[09:32] <masak> but a method Bool { self } declared in class Bool will, AFAICS, return a Bool.

[09:32] <masak> even if Bool is subclassed.

[09:32] <sorear> OTOH, defining method Bool { self ?? True !! False } in niecza will cause infinite recursion

[09:33] <masak> right, so that's the converse of what TimToady said. all depends on where you apply the saw, of course.

[09:33] <masak> sorear: what I discovered yesterday was that (a more complicated version of) the above was the only thing that failed when I chose the simpler definition of Bool.Bool.

[09:33] <masak> and now I'm arguing that the above is wrong anyway.

[09:34] <sorear> I think the above is wrong

[09:34] *** baest joined
[09:34] * masak goes ahead and fixes it

[09:34] <sorear> { foo => Bool } ~~ :foo(False) should mean the same as Bool ~~ False

[09:35] <sorear> which should be the same as !Bool

[09:35] <masak> aye.

[09:35] <masak> rakudo: say Bool ~~ False

[09:35] <p6eval> rakudo cae7f9: OUTPUT«===SORRY!===␤Smartmatch against False always fails; if you mean to test the topic for truthiness, use :!so or *.not or !* instead at line 22, near " False"␤»

[09:35] <sorear> and type objects are always false unless the object has a Bool:U override, which no standard Perl 6 object does

[09:35] <masak> oh, right.

[09:35] <sorear> erp.

[09:35] <sorear> I'm confused

[09:35] <masak> we put in an exception there :)

[09:35] <masak> people were using smartmatch like 'if'.

[09:36] <masak> rakudo: Bool ~~ :!so

[09:36] <p6eval> rakudo cae7f9:  ( no output )

[09:36] <masak> rakudo: say Bool ~~ :!so

[09:36] <p6eval> rakudo cae7f9: OUTPUT«Bool::True␤»

[09:36] <masak> maybe we should tear up that exception, now that ~~ treats $_ differently.

[09:38] <sorear> skimming S0[23], %hash ~~ :!key is always false

[09:38] <sorear> it's only $object ~~ :!key that makes sense

[09:38] <masak> how come?

[09:39] <sorear>     Hash      Pair      test hash mapping       $_{X.key} ~~ X.value

[09:39] <sorear> $_{X.key} ~~ False

[09:39] <masak> assuming you could ~~ False

[09:40] <sorear> you can

[09:40] <sorear> 'tis only a warning

[09:40] <masak> ah, right.

[09:40] <sorear> oh, it's a sorry in Rakudo

[09:40] <sorear> std: 1 ~~ False

[09:40] <p6eval> std 625303c: OUTPUT«Potential difficulties:␤  Smartmatch against False always fails; if you mean to test the topic for␤    truthiness, please use :!so or *.not or !* instead at /tmp/yjhtvkUc59 line 1:␤------> 1 ~~⏏ False␤ok 00:01 120m␤»

[09:40] <masak> we mix up warnings and sorries a bit in Rakudo.

[09:40] <sorear> not that I suspect many people will care

[09:41] <masak> rakudo: { foo => 1 } ~~ :foo

[09:41] <p6eval> rakudo cae7f9:  ( no output )

[09:41] <masak> rakudo: say { foo => 1 } ~~ :foo

[09:41] <p6eval> rakudo cae7f9: OUTPUT«Bool::True␤»

[09:41] <masak> rakudo: say { foo => 42 } ~~ :foo

[09:41] <p6eval> rakudo cae7f9: OUTPUT«Bool::True␤»

[09:41] <sorear> rakudo: say { foo => 1 } ~~ :bar

[09:41] <p6eval> rakudo cae7f9: OUTPUT«Bool::True␤»

[09:41] <masak> huh.

[09:41] <sorear> it reduces to Any ~~ True

[09:41] <masak> oh, I see what's you're saying.

[09:42] <masak> hm, that means that my original line above is Right.

[09:42] <masak> and that I need a new example :)

[09:43] <masak> rakudo: say "non-existent-file-tests".IO ~~ :!f

[09:43] <p6eval> rakudo cae7f9: OUTPUT«Bool::True␤»

[09:43] <masak> this is correct.

[09:43] <masak> but it flips as soon as I define Bool.Bool as { self }

[09:43] <sorear> The Bool.ACCEPTS stuff is yucky imo

[09:44] <masak> yeah

[09:45] *** redicaps left
[09:52] <masak> rakudo: class A { has Bool $.foo }; say A.new ~~ :!foo; say A.new(:foo) ~~ :!foo; say A.new(:foo(Bool)) ~~ :!foo

[09:52] <p6eval> rakudo cae7f9: OUTPUT«Bool::True␤Bool::False␤Bool::True␤»

[09:52] <masak> there you go. that's the bug.

[09:52] <masak> oh wait, that's right :)

[09:53] *** tomaw left
[09:53] <masak> *locally*, it's wrong, because locally Bool.Bool is { self }

[09:54] <masak> (locally, I get "Bool::True \n Bool::False \n Bool::False")

[09:54] *** tomaw joined
[09:54] <masak> which must mean that ~~ :!f calls .Bool somewhere. fair enough.

[09:55] <masak> rakudo: say Bool ~~ :!so

[09:55] <p6eval> rakudo cae7f9: OUTPUT«Bool::True␤»

[09:55] <masak> huh! I'm at a loss for how to expose the bug on an unmodified Rakudo :P

[09:55] <moritz_> sjn: nope, RoleHOW is the name of the meta class for roles

[10:01] <moritz_> good morning zebras

[10:01] *** agentzh left
[10:03] *** cognominal joined
[10:03] *** QinGW left
[10:04] <masak> moritz_: morning, koala.

[10:05] * moritz_ waves with his big, fluffy ears

[10:05] <masak> moritz_: maybe you can help me find my way around the Rakudo source a bit. what part of the source is visited when I do $obj ~~ :!foo ?

[10:06] <moritz_> Pair.ACCEPTS

[10:06] <masak> right. and in which file is it defined?

[10:06] <moritz_> $ ack -g Pair

[10:06] <moritz_> src/core/Pair.pm

[10:06] <moritz_> src/builtins/Pair.pir

[10:06] <moritz_> I guess you checked both?

[10:07] <masak> actually, I did 'ack ACCEPTS' and didn't get anything useful from that.

[10:07] <masak> I'll check those; thanks.

[10:07] <moritz_>     pairproto = p6meta.'new_class'('Pair', 'parent'=>'Enum')

[10:08] <masak> src/core/Enum.pm -- bingo!

[10:08] <masak> moritz_++

[10:08] <moritz_> src/core/Enum.pm has two ACCEPT multis

[10:08] *** am0c left
[10:08] *** wamba joined
[10:09] <masak> right. it's the second one I wanted.

[10:09] *** hanekomu joined
[10:10] *** Trashlord left
[10:10] <masak> it does prefix:<?> on both $topic and $.value

[10:11] <masak> rakudo: class Foo; say Foo.new ~~ :methoddoesnotexist

[10:11] <p6eval> rakudo cae7f9: OUTPUT«Method 'methoddoesnotexist' not found for invocant of class 'Foo'␤  in 'Enum::ACCEPTS' at line 5351:CORE.setting␤  in main program body at line 22:/tmp/XdLhdNG9dH␤»

[10:11] <masak> rakudo: my $f = False; say Bool ~~ $f

[10:12] <p6eval> rakudo cae7f9: OUTPUT«Bool::False␤»

[10:12] <masak> there we go.

[10:12] <masak> discuss. :)

[10:13] <masak> my proof consists of two parts: (1) when a false value smartmatches against False, the result should be True; (2) Bool is a false value.

[10:13] * masak submits rakudobug

[10:14] <dalek> niecza/cilbackend: ab0a22e | sorear++ | lib/CLRBackend.cs:

[10:14] <dalek> niecza/cilbackend: Implement generation of line number tables

[10:14] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/ab0a22e636

[10:14] <dalek> niecza/cilbackend: 5484ab8 | sorear++ | lib/CLRBackend.cs:

[10:14] <dalek> niecza/cilbackend: Implement exception handler table generation

[10:14] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/5484ab86c2

[10:31] <dalek> niecza/cilbackend: f5409ed | sorear++ | lib/CLRBackend.cs:

[10:31] <dalek> niecza/cilbackend: Implement constant pooling

[10:31] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/f5409edd0f

[10:31] <dalek> niecza/cilbackend: 3a914b7 | sorear++ | lib/CLRBackend.cs:

[10:31] <dalek> niecza/cilbackend: Tweak box implementation a bit to break circularity

[10:31] <dalek> niecza/cilbackend: review: https://github.com/sorear/niecza/commit/3a914b7972

[10:31] * sorear calls it a night.

[10:31] * sorear poof

[10:33] <masak> 'night, sorear. dream of pools of constants. :)

[10:40] *** roen joined
[10:47] *** roen left
[10:51] *** roen joined
[10:52] *** wamba left
[10:53] *** kanishka joined
[10:53] *** am0c joined
[11:05] *** daxim joined
[11:06] *** Trashlord joined
[11:14] *** soroush_ joined
[11:14] *** soroush left
[11:15] *** scp1 left
[11:39] *** _kaare left
[11:44] <masak> is this TODO comment out-of-date? https://github.com/rakudo/rakudo/blob/master/src/core/Enum.pm#L10

[11:46] *** lopnor is now known as lopaway

[11:48] *** hanekomu left
[11:48] *** hanekomu joined
[11:56] *** dju left
[12:01] *** roen left
[12:11] *** Guest33910 joined
[12:23] *** shi joined
[12:32] *** roen joined
[12:32] *** masak left
[12:33] *** satyavvd left
[12:43] *** MayDaniel joined
[12:44] *** molaf joined
[12:44] <colomon> Has anyone tried building Rakudo with the released Parrot?  We need to know if that works ASAP.  (And I'm still a bit fuzzy on how to do it since the Parrot switch to git.)

[12:45] *** kanishka left
[12:48] *** dual left
[12:54] *** WonTu joined
[12:54] *** shi left
[12:54] *** WonTu left
[12:54] *** takadonet joined
[12:54] <takadonet> hey all

[12:55] *** Trashlord left
[12:55] *** mtk joined
[13:00] <gfldex> colomon: you need to edit build/PARROT_REVISION

[13:01] <colomon> yes, but what do you put there now?

[13:01] <colomon> It was easier when I just needed to figure out the right SVN revision.

[13:05] <colomon> afk # finally light enough to walk

[13:05] *** Kovensky left
[13:08] *** envi joined
[13:11] *** roen left
[13:14] *** glow left
[13:16] *** Kovensky joined
[13:17] <gfldex> colomon: setting build/PARROT_REVISION to RELEASE_2_11_0 seams to work

[13:17] <gfldex> building now

[13:17] *** araujo joined
[13:17] *** araujo left
[13:17] *** araujo joined
[13:17] <colomon> gfldex++

[13:17] <colomon> (walk delayed because of small child waking.  :)

[13:21] *** Guest33910 is now known as _twitch

[13:31] *** roen joined
[13:31] <moritz_> rakudo: say 1 ~~ False;

[13:31] <p6eval> rakudo cae7f9: OUTPUT«===SORRY!===␤Smartmatch against False always fails; if you mean to test the topic for truthiness, use :!so or *.not or !* instead at line 22, near " False;"␤»

[13:32] *** jimmy1980 joined
[13:34] *** Trashlord joined
[13:36] *** ch3ck left
[13:39] *** jimmy1980 left
[13:39] *** wamba joined
[13:40] *** ch3ck joined
[13:40] *** ch3ck left
[13:41] *** mberends left
[13:43] *** jimmy1980 joined
[13:47] *** ch3ck joined
[13:50] *** roen left
[13:51] *** MayDaniel left
[13:51] *** jimmy1980 left
[13:52] *** MayDaniel joined
[13:54] <moritz_> off topic question: does ruby have a proper meta object model?

[13:55] <moritz_> I've found some google hits for "ruby metaclass", but it seems the rubyist associate a certain kind of singleton with it, not the way think of a metaclass

[13:57] *** jimmy1980 joined
[14:04] *** glow joined
[14:10] <frettled> moritz_: According to mst: no.

[14:10] *** roen joined
[14:11] <frettled> moritz_: he had a rant/talk in Oslo earlier this year, provoking Ruby people to come in and listen and object to what he said.

[14:11] <frettled> They objected to a few things, but just as before, nobody could really claim that Ruby's introspection was on level with Perl 5's.

[14:11] <frettled> That surprised me.

[14:13] *** jimmy1980 left
[14:22] *** jimmy1980 joined
[14:22] <smash> hello everyone

[14:23] <takadonet> smash: hey

[14:27] <moritz_> hi smash

[14:27] <tadzik> o/

[14:35] *** am0c left
[14:38] <alester> Happy Wednesday with a non-broken rakudo.org

[14:42] <smash> alester++

[14:42] <alester> Added a quarter gig of RAM 

[14:42] <alester> no more swapping

[14:42] <alester> all goodness

[14:43] <smash> great

[14:44] *** roen left
[14:47] <colomon> o/

[14:49] <tadzik> about the advent calendar, shouldn't 24 be merry christmas?

[14:55] <alester> smash: See http://petdance.com/random/diskio.png

[14:55] <alester> (force reload if you saw the old chart yesterday)

[14:57] *** jaldhar left
[15:01] <smash> alester: ouch, nasty

[15:03] <alester> that drop was when I upgraded my linode from 512 to 768 MB

[15:04] <takadonet> alester: how many hits are we getting for rakudo.org?

[15:05] <alester> What kind of answer do you want to hear?

[15:08] <takadonet> alester: # of visitors per month?

[15:08] <takadonet> are we increasing?

[15:09] <alester> What would that tell you?

[15:09] <alester> You can have the log files if you want.

[15:09] <alester> actually

[15:09] <alester> I could get you some Google Analytics

[15:09] <takadonet> alester: just curious really. 

[15:09] <alester> If you want ready-made answers, I don't have them.

[15:09] <takadonet> alester: don't put any effort into this

[15:09] <alester> That was my plan. :-)

[15:10] <alester> We get about 100-200 visits per day

[15:11] <alester> except on 11/25 when we got 1,177

[15:11] <takadonet> cool

[15:13] <alester> There is no trend

[15:13] <alester> it's all flat

[15:18] *** jimmy1980 left
[15:25] <gfldex> colomon: new parrot build and runs rakudo, I did little tests tho

[15:25] *** hanekomu left
[15:25] <colomon> gfldex++: I'm happy to duplicate your efforts and run spectest here.

[15:26] <smash> just run fulltest with latest parrot: All tests successful.

[15:27] *** mtk0 joined
[15:28] *** mtk0 left
[15:28] *** mtk left
[15:29] *** mtk joined
[15:30] <takadonet> sweet

[15:30] *** Gahrian joined
[15:37] <tadzik> how faster is that?

[15:37] <takadonet> tadzik: the newest parrot build?

[15:38] *** soroush_ left
[15:41] <tadzik> takadonet: yeah

[15:41] *** glow left
[15:42] <tadzik> nothing fancy on http://isparrotfastyet.com/

[15:47] <takadonet> one day I just want to see that graph have a huge decrease on runtime

[15:49] <tadzik> hmm

[15:51] <tadzik> „this entire project should be finished sometime in late

[15:51] <tadzik> December.”

[15:52] <tadzik> (the Meta-Model grant)

[15:52] *** risou joined
[15:52] *** sftp joined
[15:53] <takadonet> tadzik: jnthn grant?

[15:54] <tadzik> takadonet: yeah

[15:54] <tadzik> that'd be a hell of a speedup

[15:54] <colomon> I'd think we'd know by now if jnthn was ready to finish the grant next week.

[15:54] <colomon> Though I did miss #phasers yesterday...

[15:55] <tadzik> also we could start making some fun after the tree-optimizer is merged

[15:55] <smash> no news on #pahsers yesterday on the topic

[15:55] <smash> *phasers

[15:56] <colomon> yes, just read the backlog.

[15:56] <colomon> no jnthn, either

[15:57] <tadzik> > 01234

[15:57] <tadzik> Leading 0 does not indicate octal in Perl 6; please use leading 0o if you mean that at line 1, near "\n"

[15:58] <tadzik> could've been prettier (ideas?), but I have the promised "at least one patch" for ya :)

[16:02] * tadzik has a mixed feelings about #81146. Shouldn't smartmatching againt False be always false? It even is alredy

[16:03] *** am0c joined
[16:04] *** gbacon left
[16:05] <tadzik> I feel as doing something for rakudo, it'd be good to have something to show off in a changelog

[16:06] *** _kaare joined
[16:09] *** glow joined
[16:12] *** glow left
[16:13] <tadzik> could anybody give me a hand with a patch? It's like this atm[1], but it does not show near what it warns. [1] http://paste.perldancer.org/P7y68YAxgHfO

[16:26] <tadzik> anyone into nqp-rx here? I think I implemented .worry

[16:34] *** risou_ joined
[16:35] *** risou left
[16:47] <PerlJam> greetings

[16:48] <PerlJam> tadzik: you're not sure if you implemented worry?  :)

[16:50] <huf> .worry is specced? what's it do?

[16:50] <tadzik> PerlJam: no, it just doesn't work fully :)

[16:51] <tadzik> huf: it's like .panic, but does not die

[16:52] <tadzik> weird

[16:53] <tadzik> http://paste.perldancer.org/2zS3oA69v1A61

[16:54] <tadzik> the worry method is basically panic with a few changes, I was planning to refactor them a bit after I'm sure worry works

[16:54] *** justatheory joined
[17:06] *** plainhao joined
[17:22] *** alester left
[17:23] *** glow joined
[17:31] *** cdarroch joined
[17:31] *** cdarroch left
[17:31] *** cdarroch joined
[17:35] *** risou joined
[17:36] *** ch3ck3r joined
[17:37] *** risou_ left
[17:37] <moritz_> \o/ 1.1k views on the advent blog today

[17:37] <moritz_> with still a few hours to go

[17:39] *** ch3ck left
[17:39] <colomon> sweet!

[17:40] <moritz_> so, anybody up for the 24th?

[17:40] <moritz_> thundergnat++ claimed the 23rd

[17:40] <takadonet> moritz_: nice

[17:40] <takadonet> moritz_: reddit is down

[17:41] <moritz_> takadonet: I know. We've slashdotted it! :-)

[17:42] <takadonet> moritz_: we seems to got the attention of a troll which posted on every perl 6 advent posted saying it was spam....

[17:42] <takadonet> he was downvoted pretty good 

[17:44] *** glow left
[17:48] *** MayDaniel left
[17:51] <Util> Status of &?ROUTINE in Rakudo?

[17:52] *** impious joined
[17:53] *** impious left
[17:57] *** wamba left
[18:17] *** lestrrat left
[18:25] *** ShaneC joined
[18:28] *** lestrrat joined
[18:28] *** uasi joined
[18:33] *** uniejo joined
[18:35] *** risou left
[18:35] *** risou_ joined
[18:37] *** uniejo left
[18:45] *** MayDaniel joined
[18:45] *** am0c^ joined
[18:46] *** am0c left
[18:50] *** envi left
[18:50] *** uniejo joined
[19:05] *** hercynium joined
[19:06] <moritz_> Util: NYI

[19:06] *** fhelmberger left
[19:09] *** abra joined
[19:10] *** uniejo left
[19:20] *** _twitch left
[19:21] <colomon> build/PARROT_REVISION = RELEASE_2_11_0 passes all spec tests on OS X

[19:21] <colomon> what's the procedure for generating a proper PARROT_REVISION value now?

[19:21] <PerlJam> colomon: git describe --tags

[19:22] *** Patterner left
[19:23] <PerlJam> colomon: it's in docs/release_guide.pod

[19:23] <colomon> PerlJam: that just gets me the RELEASE_2_11_0 string, without the hash and all

[19:24] * PerlJam tries it

[19:24] <colomon> of course, the release_guide.pod doesn't seem to indicate that the hash is necessary.  Hmmm.

[19:27] <colomon> pushed

[19:30] <dalek> rakudo: b5c0165 | colomon++ | build/PARROT_REVISION:

[19:30] <dalek> rakudo: Bump to Parrot 2.11.  PerlJam++ for pointing out instructions to do this are in docs/release_guide.pod.

[19:30] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/b5c0165346

[19:33] <PerlJam> That hardly warrants a ++  :)

[19:36] <colomon> I'll be the judge of that in my commits.  ;)

[19:36] *** glow joined
[19:37] *** Psyche^ joined
[19:37] *** Psyche^ is now known as Patterner

[19:38] *** risou_ left
[19:39] *** MayDaniel left
[19:44] <sorear> good * #perl6

[19:45] <colomon> \o

[19:48] <rokoteko> colomon: mm.. as I remember you are the perl6 + math dude all in a single package.. how would you transform cartesian coordinates to polar coordinates using perl6?

[19:49] <colomon> hmmmm... unpolar goes the other way.

[19:49] <colomon> polar

[19:50] <colomon> rakudo: say (2 + 3i).polar.perl

[19:50] <p6eval> rakudo cae7f9: OUTPUT«(3.60555127546399, 0.982793723247329)␤»

[19:50] *** icwiener joined
[19:50] <colomon> that's (magnitude, angle)

[19:50] <colomon> and then...

[19:50] <rokoteko> colomon: ok. assuming I want X decimals?

[19:50] <colomon> "X decimals"?

[19:50] <rokoteko> that's pretty cool already. :)

[19:51] <colomon> oh, you mean, N digits behind the .?

[19:51] <rokoteko> nods

[19:51] <rokoteko> ie. lazily evaluated transformation.

[19:51] <colomon> if you just... what?

[19:51] <rokoteko> "N digits behing the .?" Yes, exactly.

[19:52] <rokoteko> I decide what the N is, how to do it with perl6? mainly curious.

[19:52] <colomon> yes, but I'm not sure I see what lazily evaluated transformation has to do with that?

[19:52] <colomon> if you're just worried about printing it that way, I think fmt has the normal printf formats.

[19:53] <colomon> rakudo: say (2 + 3i).polar>>.fmt("%.5g")

[19:53] <p6eval> rakudo cae7f9: OUTPUT«3.60560.98279␤»

[19:53] <colomon> rakudo: say ~(2 + 3i).polar>>.fmt("%.5g")

[19:53] <p6eval> rakudo cae7f9: OUTPUT«3.6056 0.98279␤»

[19:53] *** jpr5 joined
[19:53] <rokoteko> colomon: ok. so the answer is that it's in the core? so you should avoid using perl6 code to implement a better way?

[19:54] <colomon> if you actually want the corresponding numbers, it's 

[19:54] <colomon> rakudo: say ~(2 + 3i).polar>>.round(1/10000)

[19:54] <p6eval> rakudo cae7f9: OUTPUT«3.6056 0.9828␤»

[19:54] <colomon> rakudo: say ~(2 + 3i).polar>>.round(1/100000)

[19:54] <rokoteko> ok, thanks. Im always bit puzzled about these things. :)

[19:54] <p6eval> rakudo cae7f9: OUTPUT«3.60555 0.98279␤»

[19:55] *** mtk left
[19:55] *** molaf left
[19:55] <rokoteko> colomon: I thought that you could "abuse" lazy evaluation to provide the N digits. not talking about how long it will take here.

[19:56] <rokoteko> Anyhow if it is built-in, then I (obviously) see the limits. :)

[19:56] <colomon> Unless you're talking about crazy levels of precision that Rakudo can't even dream of yet, calling .polar is about as fast as any single operation you can do.

[19:57] *** uasi left
[19:58] <rokoteko> I wasnt talking about being "fast".

[19:58] <rokoteko> just about "how would you do it in perl6"?

[19:59] *** mtk joined
[19:59] <colomon> rakudo: say 3.60555.unpolar(0.98279)

[19:59] <p6eval> rakudo cae7f9: OUTPUT«2.00001046222405 + 2.99999149223699i␤»

[20:02] <rokoteko> imagine  e^(i*pi) - 1 = 0   ==   pi^(X)  # where YOU define the X. currently it's not doable. but just curious what approach is perl6 taking to this. so it's implemented in core and it goes as far as what? 1/(64 bit integer) is the farthest the precision currently does? is this using Rats?

[20:04] <rokoteko> colomon: I was just curious about how would *you* approach the problem. I remember your power series blog entry which was an answer to one question I asked on irc. :)

[20:10] *** pkkm joined
[20:13] *** daxim left
[20:13] <colomon> Hmmm...

[20:13] <colomon> Are you suggesting using conversion from cartesian to polar to compute pi to an arbitrary number of decimal places?

[20:14] <colomon> rakudo: say (-1i).polar

[20:14] <p6eval> rakudo cae7f9: OUTPUT«1-1.5707963267949␤»

[20:14] <colomon> or something like that?

[20:16] *** abra left
[20:16] *** abra joined
[20:16] <colomon> Actually, 1/(32 bit integer) is the best reliable Rat precision at the moment.

[20:17] <colomon> The spec calls for FatRats which can go as far down as you'd like, but we don't have them yet.

[20:18] <colomon> If you wanted to use a series approach for pi, you'd start with something like Pi/4 = 1 - 1/3 + 1/5 - 1/7 + ...

[20:18] <sorear> fatrats != computable reals

[20:18] <sorear> colomon: ick not that

[20:19] <PerlJam> fatrats are what you find in grain storage areas

[20:19] <colomon> fatrats are not the computable reals, but they can represent a computable real to an arbitrary precision.

[20:22] <colomon> sorear: You're right on PI/4 = atan(1) = 1 - 1/3 + 1/5 - 1/7 ... not being ideal, but as an example, it certainly simplifies the discussion.

[20:23] <rokoteko> colomon: I was mainly curious how would you do it. :) I have no idea of the implementation.

[20:23] <PerlJam> rokoteko: so ... you're cheating?  :)

[20:24] <rokoteko> ermm well. if you ask on the perl6 knowledge on the subject, then yes Im cheating by asking here how to do it.

[20:25] <rokoteko> (also related to the fact that I happen to know that colomon is good with this shit) :)

[20:26] <rokoteko> didnt I mention this yet?

[20:27] <rokoteko> Im just a curious fellow.

[20:27] <colomon> rakudo: say (1...10).map({-1 ** $^n * - (1 / ($n * 2 + 1) ) }).perl

[20:27] <p6eval> rakudo cae7f9: OUTPUT«(1/3, 1/5, 1/7, 1/9, 1/11, 1/13, 1/15, 1/17, 1/19, 1/21)␤»

[20:28] <colomon> rakudo: say (1...10).map({(-1 ** $^n) * - (1 / ($n * 2 - 1) ) }).perl

[20:28] <p6eval> rakudo cae7f9: OUTPUT«(1/1, 1/3, 1/5, 1/7, 1/9, 1/11, 1/13, 1/15, 1/17, 1/19)␤»

[20:28] <colomon> dang it, one of these days I will learn

[20:28] <colomon> rakudo: say (1...10).map({((-1) ** $^n) * - (1 / ($n * 2 - 1) ) }).perl

[20:28] <p6eval> rakudo cae7f9: OUTPUT«(1/1, -1/3, 1/5, -1/7, 1/9, -1/11, 1/13, -1/15, 1/17, -1/19)␤»

[20:29] <colomon> rakudo: say [+] (1...10).map({((-1) ** $^n) * - (1 / ($n * 2 - 1) ) })

[20:29] <p6eval> rakudo cae7f9: OUTPUT«0.760459904732351␤»

[20:29] <PerlJam> rokoteko: i don't know .. he seems to have problems with precedence  :)

[20:29] *** shi joined
[20:30] *** pothos left
[20:30] *** y3llow left
[20:30] <colomon> rakudo: say pi / 4

[20:30] <p6eval> rakudo cae7f9: OUTPUT«0.785398163397448␤»

[20:30] <colomon> rakudo: say [+] (1...20).map({((-1) ** $^n) * - (1 / ($n * 2 - 1) ) })

[20:30] <p6eval> rakudo cae7f9: OUTPUT«0.77290595166696␤»

[20:30] <colomon> woah, that does indeed converge very, very slowly.

[20:32] <rokoteko> rakudo: say (1...10).map({(-1 ** $^n) * - (1 / ($n * 2 - 1) and not $n / $n == int($n/$n) ) }).perl

[20:32] <p6eval> rakudo cae7f9: OUTPUT«Could not find sub &int␤  in <anon> at line 22:/tmp/pcVWGU5F_E␤  in 'Any::join' at line 1␤  in 'List::perl' at line 2772:CORE.setting␤  in main program body at line 22:/tmp/pcVWGU5F_E␤»

[20:33] <rokoteko> rakudo: say (1...10).map({(-1 ** $^n) * - (1 / ($n * 2 - 1) and not $n / $n == ($n/$n).Int ) }).perl

[20:33] <p6eval> rakudo cae7f9: OUTPUT«(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)␤»

[20:33] *** plainhao left
[20:34] <rokoteko> afk. need to eat. :)

[20:40] <colomon> rakudo: sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; say atan(1)[^10].perl 

[20:40] <p6eval> rakudo cae7f9: OUTPUT«(1/1, -1/3, 1/5, -1/7, 1/9, -1/11, 1/13, -1/15, 1/17, -1/19)␤»

[20:41] <colomon> rakudo: sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; say ((4, 4 ... *) Z* atan(1/5) Z- atan(1/239))[^10].perl

[20:41] <p6eval> rakudo cae7f9: OUTPUT«No applicable candidates found to dispatch to for 'zipwith'. Available candidates are:␤:(&op, Any $lhs, Any $rhs)␤␤  in main program body at line 1␤»

[20:42] <colomon> rakudo: sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; say (4, 4 ... *)[^10].perl

[20:42] <p6eval> rakudo cae7f9: OUTPUT«(4, 4, 4, 4, 4, 4, 4, 4, 4, 4)␤»

[20:42] <colomon> rakudo: sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; say ((4, 4 ... *) Z* atan(1/5))[^10].perl

[20:42] <p6eval> rakudo cae7f9: OUTPUT«(4/5, -4/375, 4/15625, -4/546875, 4/17578125, -4/537109375, 2.52061538461538e-10, -8.73813333333333e-12, 3.08404705882353e-13, -1.10376421052632e-14)␤»

[20:43] <colomon> rakudo: sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; say ((4, 4 ... *) Z* atan(1/5))[^10].perl; say atan(1/239)[^10].perl

[20:43] <p6eval> rakudo cae7f9: OUTPUT«(4/5, -4/375, 4/15625, -4/546875, 4/17578125, -4/537109375, 2.52061538461538e-10, -8.73813333333333e-12, 3.08404705882353e-13, -1.10376421052632e-14)␤(1/239, -1/40955757, 2.56472314424647e-13, -3.20713065778469e-18, 4.36693152440392e-23, -6.25504450992156e-28,

[20:43] <p6eval> ..9.26582162415509e-33,…

[20:43] <colomon> rakudo: sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; say ((4, 4 ... *) Z* atan(1/5))[^5].perl; say atan(1/239)[^2].perl

[20:44] <p6eval> rakudo cae7f9: OUTPUT«(4/5, -4/375, 4/15625, -4/546875, 4/17578125)␤(1/239, -1/40955757)␤»

[20:44] <colomon> rakudo: sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; say [+]((4, 4 ... *) Z* atan(1/5))[^5] + [+] atan(1/239)[^2]

[20:44] <p6eval> rakudo cae7f9: OUTPUT«5.00418407600182␤»

[20:44] <colomon> that seems a little high

[20:44] <colomon> rakudo: sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; say [+]((4, 4 ... *) Z* atan(1/5))[^5] - [+] atan(1/239)[^2]

[20:44] <p6eval> rakudo cae7f9: OUTPUT«4.99581592399818␤»

[20:45] <colomon> rakudo: sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; say ([+] atan(1/5))[^5]) * 4 - [+] atan(1/239)[^2]

[20:45] <p6eval> rakudo cae7f9: OUTPUT«===SORRY!===␤Confused at line 22, near ") * 4 - [+"␤»

[20:46] <colomon> rakudo: sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; say ([+] atan(1/5)[^5]) * 4 - [+] atan(1/239)[^2]

[20:46] <p6eval> rakudo cae7f9: OUTPUT«0.785398170601356␤»

[20:46] <colomon> rakudo: say pi /4

[20:46] <p6eval> rakudo cae7f9: OUTPUT«0.785398163397448␤»

[20:46] <colomon> not bad

[20:50] *** abra left
[20:50] <sjohnson> WeeChat uptime: 113 days 11:22:42, started on Tue Aug 31 02:26:54 2010

[20:50] <sjohnson> always nice to see someone using the same client

[20:52] *** Klause joined
[20:55] <sorear> colomon: google is failing me atm but I saw a basic program to calculate partial sums of sum(i, 0, infty, (-1)^i * 1/(1+2*i)) once using a fiendish indirect algorithm

[20:56] *** colomon_ joined
[20:56] <sorear> colomon: he had the 10^15'th partial sum in a comment, it was accurate to not a whole lot of places :)

[20:56] *** [Coke] joined
[20:56] <rokoteko> colomon: "< colomon> The spec calls for FatRats which can go as far down as you'd like" ... uhhh. is everyone serious about implementing this spec?

[20:57] *** Klause_ joined
[20:57] *** colomon left
[20:57] *** colomon_ is now known as colomon

[20:58] <colomon> rokoteko: I was just thinking about doing it as a module for now.  Or rather, doing a BigInt type as a module, and then implement a FatRat module on top of it.

[20:59] *** Klause__ joined
[20:59] * colomon is still kind of geeked about sub atan($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) };

[20:59] <colomon> errr, guess it should be called atan-series, or something like that.

[20:59] <rokoteko> colomon: ok. might be a cool subject make a series of blog entries about, your proceedings with this. :)

[21:00] <PerlJam> colomon: indeed.  I was going to comment as much

[21:00] *** Klause left
[21:00] <rokoteko> colomon: so the rest of us could also understand it. :)

[21:00] <PerlJam> colomon: well, I was going to suggest atans or atang  or something   :)

[21:01] <PerlJam> (atang == atan generator)

[21:02] <PerlJam> if constructions such at those could be made fast, we'd already have a good chunk of PDL-ness in Perl 6.

[21:02] <rokoteko> PerlJam: atans obviously stands then for: a tan, which is A TAN Simulator? kinda like solarium?

[21:03] <colomon> rakudo: sub atang($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; sub atan(Rat $x) { [+] atang($x) ...^ Num }; say atan(1/5).perl

[21:03] <p6eval> rakudo cae7f9: OUTPUT«0.197395559788975␤»

[21:03] <colomon> ah, the fly in the ointment.

[21:04] <colomon> rakudo: sub atang($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; sub atan(Rat $x) { (([\+] atang($x)) ...^ Num)[*-1] }; say atan(1/5).perl

[21:04] <p6eval> rakudo cae7f9: OUTPUT«24288907/123046875␤»

[21:04] <colomon> rakudo: sub atang($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; sub atan(Rat $x) { (([\+] atang($x)) ...^ Num)[*-1] }; say atan(1/5).perl; say atan(1/5)

[21:04] <p6eval> rakudo cae7f9: OUTPUT«24288907/123046875␤0.197395561650794␤»

[21:05] <colomon> rakudo: sub atang($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; sub atan(Rat $x) { (([\+] atang($x)) ...^ Num)[*-1] }; say atan(1/5).perl; say atan(1/5); say atan(1/5.Num)

[21:05] <p6eval> rakudo cae7f9: OUTPUT«24288907/123046875␤0.197395561650794␤Nominal type check failed for parameter '$x'; expected Rat but got Num instead␤  in 'atan' at line 22:/tmp/XLrjiVevxD␤  in main program body at line 22:/tmp/XLrjiVevxD␤»

[21:05] <colomon> rakudo: sub atang($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; sub atan(Rat $x) { (([\+] atang($x)) ...^ Num)[*-1] }; say atan(1/5).perl; say atan(1/5); say atan2(1/5)

[21:05] <p6eval> rakudo cae7f9: OUTPUT«24288907/123046875␤0.197395561650794␤0.197395559849881␤»

[21:06] *** Klause__ left
[21:06] *** Klause_ left
[21:07] *** alester joined
[21:07] *** alester left
[21:11] *** Caffeine left
[21:11] <colomon> rakudo: sub atang($x) { (1..*).map(1 / (* * 2 - 1)) Z* ($x, * * $x * -$x ... *) }; sub atan(Rat $x) { (([\+] atang($x)) ...^ Num)[*-1] }; say atan(1/4).perl; say atan(1/4); say atan2(1/4)

[21:11] <p6eval> rakudo cae7f9: OUTPUT«20229203/82575360␤0.244978683713883␤0.244978663126864␤»

[21:13] <rokoteko> why not to just limit the maximum number perl6 can handle? Then it would atleast be a known limit.

[21:14] <rokoteko> no floating point errors, or anything. just a very well known fact. how large numbers does one need anyhow?

[21:14] <[Coke]> "pick a size" "someone will need bigger"

[21:14] <[Coke]> if you want a limited size number, you already have that type.

[21:14] <[Coke]> (yes?)

[21:15] <rokoteko> Ahh.. .oO( class Approximate extends FatRat )

[21:15] <PerlJam> rokoteko: mathematicians reason in a land where their numbers are free of implementation constraints.

[21:18] <rokoteko> and most of perl6 programmers are not mathematicians, and the ones that happen to be would appreciate the point of knowing when they are moving to approximations..?

[21:19] <rokoteko> (approximiations by the implementation, of course)

[21:20] *** mtk left
[21:22] <rokoteko> would't they?

[21:22] <rokoteko> +n

[21:25] * colomon suspects he'd be able to hear his recording more clearly if he actually had speakers attached to the computer playing it.

[21:27] <moritz_> mathematicians model their number types as subsets and supersets

[21:27] <moritz_> not as classes in the CS sense

[21:28] *** pkkm left
[21:29] <moritz_> but subset types or superset types don't map well to machine registers

[21:29] <sorear> I have a mathematical background, and I would rather my numbers be 1. fast 2. free of obvious pitfalls than "fancy"

[21:30] <moritz_> fully agreed

[21:30] <sorear> we call it the waterbed theory - using a complex system internally but forcing it under a seemingly-simple facade just forces the complexity to well up elsewhere

[21:31] * moritz_ thinks that defaulting to Rat with decimal literals is a nice balance on that bed

[21:33] <[Coke]> and Rat is not arbitrary precision, yes? It's limited to whatever can fit in the Num/Denom ?

[21:34] *** kensanata left
[21:35] <moritz_> [Coke]: yes, it degrades to Num (aka floating point numbers) if either gets too big

[21:36] <moritz_> which prevents excessively slow computations

[21:37] <TimToady> it's limited to Int/Int64

[21:37] <TimToady> or probablu uint64, and keep the sign on the numeriator

[21:38] <TimToady> but there's no limit on the Int part

[21:38] <TimToady> (according to spec, not according to rakudo)

[21:39] <TimToady> so the Rat type already has an arbitrary precision limit on the low end

[21:40] <TimToady> the assumption here is that most future CPUs will support efficient 64-bit integer ops

[21:40] * sorear wonders about efficient gcs

[21:41] <sorear> gcd

[21:41] <TimToady> which is why the spec allows it to be done lazily

[21:42] <rokoteko> TimToady: heh. yes. as far as they extend the precision by ALUs.

[21:42] <rokoteko> but why not to make the programmer know when she's switching to approximations?

[21:43] <TimToady> it's not often that she will run into it, when the threshold is 1/2**64

[21:43] <rokoteko> yes, but by the current spec, if or when that happens, how is ones supposed to know?

[21:44] <TimToady> if you want to be sure, do your calculations in FatRats instead

[21:44] <rokoteko> earlier I was thinking about class Approximate extends FatRats. when FatRats fall out of scope, the programmer would know.

[21:45] <TimToady> that sounds non-liskovian

[21:45] <sorear> TimToady: what happens when a trancedental function is called on (Fat)Rat?

[21:46] <TimToady> then the type model is transcended :)

[21:46] <rokoteko> wtf is liskonian?

[21:47] <TimToady> it doesn't sound like Approximate is actually extending FatRat

[21:48] <PerlJam> rokoteko: google Barbara Liskov

[21:48] <colomon> rokoteko: If Rat math results in an approximation, the result is a Num.  That works now, and it's easy to check and see if you have a Num instead of a Rat.

[21:53] <rokoteko> Int, Rat, Float etc are all Nums, right?

[21:53] <TimToady> no

[21:53] <TimToady> they're all Numeric

[21:53] <rokoteko> ah. what exactly is a Num then?

[21:53] <TimToady> floater

[21:54] <TimToady> likely double

[21:54] <rokoteko> "floater" as in "more than a float" ?

[21:54] <TimToady> when I say "flaoter" I mean generic floating-point as opposed to single precision

[21:54] <TimToady> s/ao/oa/

[21:55] <rokoteko> ok, but you'd never know if it actually is an exact result or honestly just an approximation?

[21:56] <TimToady> see S02:683

[21:56] <rokoteko> I will, thanks.

[21:56] <TimToady> and this is different from the entire world of fp calculations today how?

[21:57] <rokoteko> no there's no difference compared to the current implementations.

[21:57] <PerlJam> TimToady: there are no exact results in floating point calculations today  ;)

[21:57] <moritz_> there are, actually

[21:57] <moritz_> if you use them as integers in the range where the mantissa is enough

[21:58] <TimToady> there's no easy way of telling if you've gotten into approximations, is the point

[21:58] <PerlJam> moritz_: sure, but in the general case, you have to pretend that isn't true to maintain the proper skeptical view of the numbers you get

[21:58] <TimToady> you can't even look at an integer floater and know that it was exact

[21:59] <TimToady> it might have really been 42.00000000000000000000000000000000000000000000000001

[21:59] <rokoteko> TimToady: if you got 1/(2**64-1) as your smallest number you got. then wouldnt be falling out of that precision being an approximate?

[21:59] <TimToady> yes, what of it?

[22:00] <rokoteko> TimToady: what? I was referring to: 

[22:00] <rokoteko> 23:58 < TimToady> there's no easy way of telling if you've gotten into approximations, is the point

[22:00] <TimToady> life is hard

[22:01] *** [particle] left
[22:01] <rokoteko> isnt that an easy way, limit your maximum and what is falling outside that is an approximation?

[22:01] <TimToady> I don't think this is a killer feature that would be a disruptive technology

[22:01] <TimToady> there is no maximum precision; Int is arbitrarily big

[22:02] <rokoteko> Ok. Im just throwing out ideas here, I thought that's all perl6 was all about. not nailing the spec to a wall and every one kneeling at front of it.

[22:02] <TimToady> I haven't seen that happening lately :P

[22:03] <sorear> the spec isn't important, users are

[22:03] <TimToady> but it's absolutely not true that perl6 is just about throwing ideas around

[22:03] <sorear> show me a legitimate use case for a super-rich numeric hierarchy and I'll consider implementing it

[22:03] <TimToady> we'll never get anywhere that way

[22:04] <TimToady> and the point of the current design is that looks close to practical for users

[22:04] <PerlJam> rokoteko: read the last paragraph of http://perl6advent.wordpress.com/2010/12/20/day-20-the-perl-6-synopses/   :-)

[22:05] <rokoteko> I was trying to participate in the discussion.

[22:06] <TimToady> well, that also involves dealing with any pushback :)

[22:08] <TimToady> you wanted an easy way to tell if you have an approximation, and ~~ Num is currently that way, and we're not sure what more you want

[22:08] <TimToady> so you'll need to clarify

[22:09] <PerlJam> actually,  I thought he wanted an "automated" method to let the programmer know when they've strayed into the dangerous land of approximation.

[22:09] <rokoteko> my maint point is that I think floats are pretty much bad design.

[22:09] <moritz_> they aren't. They are just bad design for certain applications

[22:09] <rokoteko> if building a new language why not to get rid of them, as far as you can go.

[22:10] <rokoteko> 1/64 should be small enough for the regular users.

[22:10] *** jhuni joined
[22:10] <rokoteko> if you need to go smaller fall to Approximate.

[22:10] <rokoteko> erm. 1/64**2

[22:10] <TimToady> but if you want smaller, you're going for Exact

[22:10] <TimToady> == FatRat

[22:11] <rokoteko> 1/65**2 is a FatRat?

[22:11] <TimToady> and very likely slow, if there's any multiplication

[22:11] <TimToady> FatRat can hold 2 ** -65

[22:12] <moritz_> can't it hold arbitrary fractions?

[22:12] <TimToady> it can hold any Int / Int

[22:12] <TimToady> or maybe Int / Uint

[22:12] <sjohnson> cute datatypes

[22:12] <flussence> .oO( I sense "is native('libgmp')" appearing somewhere in the future )

[22:13] <rokoteko> TimToady: and, as you wasnt here follow, I wasnt curious about the performance. about getting the actual result or knowing that it actually is an approximation.

[22:13] <PerlJam> flussence: actually, I'd like that to be as invisible as possible for the most part.

[22:13] <rokoteko> .. weren't here earlier to follow the discussion.. # pardon my hectic typing

[22:14] <TimToady> I backlogged

[22:14] <TimToady> and we already answered the knowing question

[22:14] <TimToady> that's Num vs (FatRat)

[22:14] <TimToady> (Fat)Rat

[22:14] *** am0c^ left
[22:15] <flussence> rakudo: use FatRat; # will this explode?

[22:15] <p6eval> rakudo cae7f9: OUTPUT«===SORRY!===␤Unable to find module 'FatRat' in the @*INC directories.␤(@*INC contains:␤  lib␤  /home/p6eval/.perl6/lib␤  /home/p6eval/p1/lib/parrot/2.10.1-devel/languages/perl6/lib␤  .)␤»

[22:15] <TimToady> nyi

[22:15] <rokoteko> ok. I hear you.

[22:15] <rokoteko> what is actually Num then?

[22:15] <sorear> ah, the innocence of youth.

[22:15] <moritz_> rokoteko: Num is a floating point

[22:15] <moritz_> double precision, iirc

[22:16] <flussence> rakudo: use Int; # just curious

[22:16] <p6eval> rakudo cae7f9: OUTPUT«===SORRY!===␤Unable to find module 'Int' in the @*INC directories.␤(@*INC contains:␤  lib␤  /home/p6eval/.perl6/lib␤  /home/p6eval/p1/lib/parrot/2.10.1-devel/languages/perl6/lib␤  .)␤»

[22:17] <rokoteko> Num is a class and Numeric is a role?

[22:17] <PerlJam> Now that the pugs repo is split up, it seems it takes me about 2-3 tries to locate the appropriate repo for whatever it is I wanted to lookup.

[22:17] <sbp> rakudo: sub postfix:<!> { [*] 1..$^n }; say 27**(86!) > (27**86)!

[22:18] <p6eval> rakudo cae7f9: OUTPUT«(timeout)»

[22:18] <sbp> what's the fastest factorial implementation in perl6?

[22:18] <PerlJam> sbp: fastest by what measure?

[22:18] <moritz_> sbp: probably calling a C library through NCI

[22:19] <TimToady> probably an array lookup :)

[22:19] <PerlJam> sbp: the quickest to type is probably sub fact($n) { [+] 1..$n }

[22:19] <sbp> PerlJam: least likely to timeout in the above calculation

[22:19] <sbp> [+]?

[22:19] <PerlJam> oops

[22:19] <PerlJam> looks like I can't type what I'm thinking

[22:19] <TimToady> well, it's faster than [*]  :)

[22:20] <PerlJam> heh

[22:20] <sbp> hehe

[22:20] <sbp> cf. http://mrob.com/pub/perl/hypercalc.txt

[22:20] <sbp> #  But no other calculator can tell you that

[22:20] <sbp> #    (27 ^ 86) !  =  10 ^ (1.534607.. x 10 ^ 125)

[22:20] <sbp> #  or that

[22:20] <sbp> #    27 ^ (86!)   =  10 ^ (3.467778.. x 10 ^ 130)

[22:21] <sbp> it uses Logarithmic Number Systems to store large numbers

[22:21] <TimToady> pugs: sub postfix:<!> { [*] 1..$^n }; say 27**(86!) > (27**86)!

[22:21] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "!)"␤    expecting "_", fraction, exponent, term postfix, operator or ")"␤    at /tmp/YEzSH8g6dJ line 1, column 44␤»

[22:22] <TimToady> pugs: sub postfix:<!> ($n) { [*] 1..$n }; say 27**(86!) > (27**86)!

[22:22] <flussence> am I right in assuming the "use Int;" I did above should've been a no-op?

[22:22] <p6eval> pugs: OUTPUT«(timeout)»

[22:22] <moritz_> is 'use Int' specced?

[22:23] <flussence> or "use $anybuiltintype", really

[22:23] <moritz_> hrm

[22:23] * moritz_ wonders how that's going to be implemented, if at all

[22:23] * moritz_ starts a spectest run and goes off to sleep

[22:25] <sbp> if you called Block "Perl" instead, you... you can see where I'm going

[22:39] <sbp> why doesn't this exist? http://perlcabal.org/syn/S26.html

[22:39] <rokoteko> isnt 'use Int' implied? when would you need to re-use it?

[22:39] <sbp> all the other synopses have HTML counterparts

[22:40] *** [particle] joined
[22:40] <Tene> sbp: S26 is written in the language it describes, instead of Perl 5 POD, iirc.

[22:40] <rokoteko> Anyhow. need to work tomorrow. Thanks to all of you for a very interesting chat and see you around. :)

[22:40] <rokoteko> Sleep tight, don't let the bed bugs bite!

[22:41] <Tene> Since there aren't tools to work with the language described in S26, there's nothing to use to produce an html version, etc.

[22:41] <Tene> https://github.com/perl6/specs/blob/master/S26-documentation.pod for example

[22:41] <Tene> tries to render as p5 pod, but fails badly

[22:41] <sbp> so the Rosetta Stone turns out to be a manual for reading hieroglyphics?

[22:41] <sbp> Champollion would be amused

[22:43] <sbp> "'=begin' only takes one parameter, not several" — oh, how wrong thou art my noble githubby friend, welcome to the future. so I'm sure somebody's written some p6 pod gear somewhere?

[22:44] <sbp> —

[22:44] <sbp> > 3. Can I just rename S26.pod to perl6pod.pod and be done with it? :)

[22:44] <sbp> S26.pod is intended as a reference (but quite readable, if I remember

[22:44] <sbp> correctly). It's certainly a good start, maybe at some later point we

[22:44] <sbp> might want to have something more tutorial-style.

[22:44] <sbp> —

[22:44] <sbp> Moritz in http://www.nntp.perl.org/group/perl.perl6.language/2010/08/msg34065.html

[22:46] <sbp> well I didn't find any p6 pod stuff

[22:46] <sbp> but I did find this, which is rather nifty:

[22:46] <sbp> http://search.cpan.org/~lichtkind/Perl6-Doc/lib/Perl6/Doc.pm

[22:49] *** hercynium left
[23:03] *** wamba joined
[23:03] *** zby_home_ left
[23:14] *** icwiener left
[23:21] <lue> ohai world o/

[23:22] <sbp> hi lue

[23:22] <Tene> sbp: there's been a huge amount of bikeshedding over it on the list

[23:23] * sbp imagines a gaggle of lizards with bicycles for tails

[23:24] <sbp> any results?

[23:25] <sorear> Tene: all of the synopses are written in pod6; S26 just uses more advanced features (semantic tables, iirc)

[23:27] <Tene> sorear: 'k

[23:27] <sbp> sorear: all the other synopses use a subset of pod6 syntax which is backwards compatible with pod5 I assume?

[23:29] <sorear> looks like it

[23:29] *** masak joined
[23:29] <sorear> I know 'grok' works fine on the other synopses; I might just be getting fooled by a failover

[23:29] <sorear> hi masak!

[23:29] <masak> ahoy, #perl6.

[23:30] <masak> TimToady: do you want to write something for Advent slot #24?

[23:30] <masak> something on the topic of community hacking, for example.

[23:33] <masak> rakudo: say "nonexistent".IO.f

[23:33] <p6eval> rakudo cae7f9: OUTPUT«Bool()␤»

[23:33] <masak> moritz_++ was right to reject my last bug report.

[23:33] <masak> but I think this is a bug.

[23:34] <masak> should be Bool::False.

[23:34] <masak> ...that would fix the spectest that fails with the simpler Bool.Bool method which would allow me to put that simplifying patch in.

[23:35] <sbp> rakudo: say "nonexistent".IO ~~ :e

[23:35] <p6eval> rakudo cae7f9: OUTPUT«Bool::False␤»

[23:35] <flussence> so... is anyone currently working on a pod6tohtml?

[23:35] <masak> flussence: there's one on CPAN. TheDamian wrote it.

[23:35] <masak> it's pretty good.

[23:36] <masak> not altogether up-to-date, but good enough.

[23:36] <sbp> does it work on S26?

[23:36] <masak> probably not without some tweaks, no.

[23:36] <masak> but try it and see.

[23:37] *** envi joined
[23:37] <masak> I still plan to submit a grant application for some S26/Rakudo work. I have the grant application draft gist somewhere if anyone's interested.

[23:37] <sorear> std: my $f = { last LOOP; }; LOOP: loop { $f() }

[23:37] <p6eval> std 625303c: OUTPUT«===SORRY!===␤Illegally post-declared type:␤       'LOOP' used at line 1␤Check failed␤FAILED 00:01 121m␤»

[23:38] <sorear> std: my $f = { last lOOP; }; lOOP: loop { $f() }

[23:38] <p6eval> std 625303c: OUTPUT«===SORRY!===␤Illegally post-declared type:␤       'lOOP' used at line 1␤Check failed␤FAILED 00:01 121m␤»

[23:38] <masak> sorear: read the error message. :)

[23:38] <sorear> I thought that error message was influeced by case for some reason

[23:39] <masak> no, it's influenced by the programmer illegaly post-declaring a type. :P

[23:40] * masak stops being a smart-aleck

[23:41] *** justatheory left
[23:41] <flussence> does Pod6 specify a default charset? The S26 on github has some �s appearing in the source, and my browser thinks it's utf8.

[23:41] *** justatheory joined
[23:42] <masak> hm, Pod6 ought to abide by the same encoding rules as the rest of Perl 6.

[23:42] <flussence> oh, shows up as «» with iso8859-1 encoding...

[23:42] <flussence> “By default, Pod assumes that documents are Unicode“

[23:42] <masak> yeah, just found that too.

[23:43] <flussence> guess the file itself needs fixing :)

[23:43] * masak not surprised

[23:43] <masak> I probably touched it last, so might have been me mucking it up.

[23:46] *** MayDaniel joined
[23:46] *** smash left
[23:46] <masak> sleep &

[23:47] <sbp> =encoding punycode

[23:47] <flussence> that's just evil :)

[23:47] <sbp> heh, heh

[23:53] *** shi left
[23:54] * lue happens to be starting to create a Unicode font. Let's see how long that dream lasts :)

[23:57] *** S_Blade joined
[23:59] *** cdarroch left
