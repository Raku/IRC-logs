[00:12] *** dju joined
[00:12] *** chitragupt left
[00:14] *** chitragupt joined
[00:25] *** stepnem left
[00:26] *** justatheory left
[00:28] *** stepnem joined
[00:35] *** opx^away joined
[00:40] *** chitragupt left
[00:43] <diakopter> sorear: did you get STD running?

[00:49] *** chitragupt joined
[00:49] *** kst left
[00:50] *** chitragupt left
[00:51] *** chitragupt joined
[00:51] *** kst joined
[00:55] *** chitragupt left
[00:57] *** chitragupt joined
[01:02] *** chitragupt left
[01:02] *** chitragupt joined
[01:03] *** drbean left
[01:06] *** drbean joined
[01:09] *** chitragupt left
[01:09] *** ruoso left
[01:12] *** chitragupt joined
[01:16] *** snarkyboojum left
[01:22] *** hicx174 joined
[01:22] *** JimmyZ joined
[01:23] <JimmyZ> \o

[01:24] <JimmyZ> morning

[01:24] *** fda314925 left
[01:25] *** [mark] joined
[01:25] *** fda314925 joined
[01:25] <diakopter> hi

[01:27] <lue> afk

[01:27] *** ruoso joined
[01:27] *** snarkyboojum joined
[01:28] *** wknight8111 left
[01:30] <sorear> diakopter: I've had STD running for a while

[01:30] *** molaf joined
[01:30] <diakopter> ok

[01:31] *** kst left
[01:33] *** kst joined
[01:36] *** k23z__ left
[01:38] *** molaf_ joined
[01:42] <diakopter> std: my $a = (Array[int]).new # mruhahaha

[01:42] <p6eval> std 30541: OUTPUT«ok 00:01 108m␤»

[01:43] *** molaf left
[01:43] <diakopter> though to be more accurate... hrmph. I guess I should use List[int], since that's what's underneath it anyway.

[01:43] <diakopter> boo.

[01:45] *** Intensity joined
[01:45] <diakopter> oh yeah.

[01:45] <diakopter> I forgot I already created an alias for that.

[01:47] <sorear> grr.  STD.pm6 relies on slangs to parse quasiquotes

[01:48] * diakopter was aware of that, once upon a time.

[01:56] <sorear> diakopter: I have macros working

[01:56] *** snarkyboojum left
[01:56] <diakopter> I saw :) your work rocks

[01:56] <sorear> I just need hygenic quasiquotes now for maximum impressiveness

[01:56] <sorear> which is not as ridiculously hard as I first beleived

[01:57] <diakopter> someone needs to give you a commitbit

[01:58] <diakopter> (not I, since I can't)

[01:58] *** rv2733 left
[01:59] *** Psyche^ joined
[02:00] <colomon> rakudo: say &prefix:<!> ~~ Code

[02:00] <p6eval> rakudo c4857a: OUTPUT«1␤»

[02:01] <colomon> rakudo: my &c = &prefix:<!>; say &c.signature.params

[02:01] <p6eval> rakudo c4857a: OUTPUT«get_attr_str() not implemented in class 'Perl6MultiSub'␤current instr.: 'perl6;Code;signature' pc 13378 (src/builtins/Str.pir:68)␤»

[02:01] *** chitragupt left
[02:02] <colomon> dang it, should have gotten that one in before jnthn went off-line for days.  :(

[02:02] <diakopter> where'd jnthn go

[02:03] * diakopter feels nosy

[02:03] <colomon> He's camping in Iceland.

[02:03] *** KyleHa joined
[02:04] *** Patterner left
[02:04] *** Psyche^ is now known as Patterner

[02:04] *** chitragupt joined
[02:04] *** snarkyboojum joined
[02:05] <sorear> colomon: don't you have commits too?

[02:06] <colomon> yes.

[02:06] <colomon> but I don't have the first clue about dealing with signatures.  that's jnthn's area.

[02:06] <diakopter> boo.  googlecode rejecting my svn ci.

[02:13] <sorear> rakudo: pir::compreg__PS("perl6").dumper(Perl6::Grammar.parse('$Foo::x', :rule('term'), :actions(Perl6::Actions)).ast, "PAST")

[02:13] <p6eval> rakudo c4857a: OUTPUT«Contextual $*LEFTSIGIL not found␤current instr.: 'perl6;Perl6;Grammar;_block1827' pc 105568 (src/gen/perl6-grammar.pir:17473)␤»

[02:14] <sorear> rakudo: my $*LEFTSIGIL; pir::compreg__PS("perl6").dumper(Perl6::Grammar.parse('$Foo::x', :rule('term'), :actions(Perl6::Actions)).ast, "PAST")

[02:14] <p6eval> rakudo c4857a: OUTPUT«"PAST" => PMC 'PAST;Var'  {␤    <name> => "$x"␤    <namespace> => ResizablePMCArray (size:1) [␤        "Foo"␤    ]␤    <scope> => "package"␤}␤»

[02:14] <sorear> heh, it does work in p6eval

[02:15] <diakopter> o__O

[02:20] *** nihiliad left
[02:20] *** nihiliad joined
[02:21] *** _jaldhar joined
[02:23] <sorear> diakopter: Yes, the compiler API is exposed to Perl 6 code.

[02:23] <sorear> Isn't it wonderful?

[02:30] <colomon> rakudo: say (1, 1, 1, 2, 3 ... 10).batch(10).join(', ')

[02:30] <p6eval> rakudo c4857a: OUTPUT«Method 'batch' not found for invocant of class 'Failure'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[02:35] *** camenix left
[02:35] *** xinemac left
[02:38] *** camenix joined
[02:38] *** xinemac joined
[02:43] *** camenix left
[02:43] *** xinemac left
[02:47] *** KyleHa left
[02:50] *** nihiliad left
[02:51] *** [[mark]] joined
[02:52] *** KyleHa joined
[02:52] *** KyleHa left
[02:53] *** [mark] left
[02:53] *** chitragupt left
[02:55] *** chitragupt joined
[02:58] * sorear has some misgivings about the specced design of hygenic quasiquotes

[03:05] *** justatheory joined
[03:07] <sorear> most importantly, unquotes being a kind of term

[03:07] <sorear> so you can't do stuff like declare functions with variable names

[03:08] <sorear> I'd like to wait until someone has a use case before doing much hygiene hacking

[03:12] *** chitragupt left
[03:14] *** chitragupt joined
[03:18] <sorear> another problem revolves around lexical binding

[03:18] <sorear> lexicals are bound to a specific environment at parse time

[03:18] <sorear> so quasi { my $COMPILING::x = 2; {{{ $ast }}} }  doesn't really make sense

[03:18] <sorear> because $ast already has lexicals bound

[03:30] *** chitragupt left
[03:32] *** chitragupt joined
[03:39] <sorear> I think what we need is to divide macros into two groups

[03:40] <sorear> 1. Category macros (like Lisp's reader macros) are associated directly with a grammatical category.  The 'is parsed' is combined with <sym> to make a new protoregex rule, which is injected into the grammar; user code is run when the grammatical rule is recognized.

[03:42] <sorear> 1. Functional macros (like Lisp's syntax macros) involve no special syntax; they do not modify the grammar.  However, when a function call (including operator syntax calls like x ~ y === &[~](x, y)) is going to be generated, the AST construction is redirected and calls the macro instead.

[03:43] <sorear> s:2nd/1./2./

[03:43] * sorear returns to his real code and tries to pretty it with macros

[03:45] *** molaf_ left
[04:01] *** chitragupt left
[04:02] *** chitragupt joined
[04:18] <cognominal> I can't find where nibbler is defined :(

[04:19] *** arnsholt_ joined
[04:20] *** arnsholt left
[04:20] *** skangas left
[04:23] *** japhb joined
[04:24] * lue wonders if there's a neat little linux program to search the human genome.

[04:24] * lue (firefox doesn't count) :)

[04:28] <sorear> grep

[04:31] *** chitragupt left
[04:33] <lue> I searched the fedora package repos for 'genome', and came up with a couple things (including a few P5 modules. figures :) )

[04:34] *** chitragupt joined
[04:46] * sorear contemplates adding roles to NQP-rx

[04:48] <cognominal> I don't understand. I find nibbler in P6Regex::Grammar.  So how rakudo can work if it is not pulled as the parrot in rakudo?

[04:49] <sorear> Failed to parse sentence

[04:49] <sorear> if we had roles in NQP, we could do proper slangs, and lexically scoped macros, and other such stuff

[04:49] <cognominal> I mean. rakudo does pull parrot to compile. how come I don't see nibbler

[04:50] <sorear> Where are you looking and what do you want to find?

[04:50] <sorear> rakudo: 2 ¢ 3

[04:50] <p6eval> rakudo c4857a: OUTPUT«Confused at line 11, near "2 \x{a2} 3"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[04:50] <sorear> rakudo: { my sub infix:<¢> ($x, $y) { !!! }; };2 ¢ 3

[04:50] <p6eval> rakudo c4857a: OUTPUT«Could not find sub &infix:<¢>␤current instr.: '_block21' pc 29 (EVAL_2:0)␤»

[04:50] <cognominal> as I said nibbler is in P6Regex::Grammar of nqp-rx

[04:51] <sorear> operator injections are not lexically scoped

[04:51] <sorear> I wonder if there's a spectest for that

[04:51] <cognominal> how come I don't see it when I do a ack on rakudo (which includes a parrot/ folder)

[04:51] <sorear> parrot/ is not a parrot source tree

[04:52] <sorear> parrot/ is bits specific to the Rakudo Parrot backend

[04:52] <sorear> (currently the only one)

[04:52] <sorear> note that Perl6::Regex is a subclass of Regex::P6Regex::Grammar and inherits the nibbler method

[04:52] <cognominal> ok, I thought it was a copy of some parrot branch.

[04:53] <sorear> no, it only has four files

[04:53] <cognominal> ??

[04:53] <sorear> unless you're talking about the automatic checkout

[04:53] <cognominal> yes

[04:53] <sorear> but P6Regex isn't part of Parrot anyway

[04:54] <cognominal> I see P6Regex-S0 that must be generated from Regex::P6Regex::Grammar

[04:55] <cognominal> so I am surprised to see that file and not the file that is used to generate it

[04:55] <sorear> yes

[04:55] <sorear> the parrot repository contains files without matching source code

[04:55] <cognominal> that's what puzzles me.

[04:56] <cognominal> ok. I suppoed the contrary :)

[04:56] <sorear> http://github.com/perl6/nqp-rx/blob/40bb2a8d84864d10935db50cd060e10fc13f5a52/src/Regex/P6Regex/Grammar.pm

[04:56] <sorear> P6Regex is implemented using P6Regex

[04:56] <sorear> so you need to start with a precompiled version

[04:57] <sorear> Parrot ships the compiled version, but the canonical source is in a different project

[04:57] <sorear> there are 4 major subsystems here

[04:57] <cognominal> ...in the nqp-rx branch

[04:58] <sorear> not a branch, it's an entire project

[04:58] <cognominal> indeed.

[04:58] <sorear> 1. Parrot, a VM.  Parrot is shipped as C source

[04:58] <sorear> 2. PCT, a library for compiling to Parrot bytecodes.  Is written in Parrot assembly and shipped along with Parrot

[05:00] <sorear> 3. NQP-rx, a very simple Perl6-like language for Parrot + an implementation of Perl6 parsing rules.  It is written using NQP-rx (for the frontend) and PCT (for the backend).  It is shipped *as binaries* with Parrot; the source lives elsewhere

[05:00] <sorear> 4. Rakudo, an implementation of full-ish Perl6 on top of NQP-rx and PCT

[05:01] <cognominal> " nqp-rx :  It is shipped *as binaries* with Parrot; the source lives elsewhere"  : now everything makes sense to me. thx

[05:01] *** chitragupt left
[05:02] <sorear> The first big item on our post-R* agenda is to loosen Rakudo's ties to PCT

[05:03] <sorear> NQP is very simple, it can be easily implemented on other platforms (nq-nqp and purlesque are active projects in this direction)

[05:03] <sorear> PCT is pretty deeply tied to Parrot

[05:06] <cognominal> well, only the pir generation part. The rest is written in pir but could be rewritten in  nqp/perl 6 rakudo  once the bootstrapping done.

[05:08] *** meppl joined
[05:09] *** chitragupt joined
[05:10] <lue> afk and goodnight!

[05:10] <sorear> I don't think parrotfolk would like that very much

[05:10] <sorear> having a core library (PCT) depending on a non-core component (NQP-rx)

[05:12] *** eternaleye left
[05:13] *** jlindsay left
[05:14] <JimmyZ> I think it's more easy to get more contributors.

[05:18] *** eternaleye joined
[05:20] *** kaare joined
[05:21] *** kaare is now known as Guest19628

[05:30] *** chitragupt left
[05:31] *** chitragupt joined
[05:38] *** eternaleye left
[05:54] *** eternaleye joined
[06:02] *** uniejo joined
[06:18] *** plobsing left
[06:21] *** oldy joined
[06:22] <oldy> hi, 

[06:24] <oldy> Looking at http://fedoraproject.org/wiki/Features/Rakudo_Perl_6. Can Perl6 be installed on Fedora machine, without disprupting existing Perl5.already installed? 

[06:28] <araujo> of course oldy 

[06:28] <araujo> the most popular implementation right now is rakudo ... you install that even in your home dir, set a path for the binaries, and ready to go

[06:31] <sorear> Perl6 is installed as perl6

[06:31] <sorear> we aren't even attempting to take over perl5 yet

[06:33] <araujo> sorear, we will right?, 

[06:38] <oldy> araujo: & sorear thanks, will give it a go  :)

[06:41] *** JimmyZ left
[06:41] <snarkyboojum> FWIW, I think quite a few respected perl5 and perl6 guys have been expending effort to dissolve the 'take over perl5' meme

[06:42] <mj41> rakudo: say "and I said: %quotes{"me"}.";

[06:42] <p6eval> rakudo c4857a: OUTPUT«Symbol '%quotes' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[06:42] *** JimmyZ joined
[06:42] <mj41> rakudo: my %quotes = {}; say "and I said: %quotes{"me"}.";

[06:42] <p6eval> rakudo c4857a: OUTPUT«and I said: .␤»

[06:43] <moritz_> rakudo: my %quotes = me => "dunno"; say "and I said: %quotes<me>."

[06:43] <p6eval> rakudo c4857a: OUTPUT«and I said: dunno.␤»

[06:51] <JimmyZ> rakudo: my %quotes = {}; say pir::defined_PP(%quotes); say pir::defined_PP(%quotes<f>); say pir::defined_PP(%quotes<f>);

[06:51] <p6eval> rakudo c4857a: OUTPUT«error:imcc:syntax error, unexpected PREG, expecting '(' ('$P48')␤  in file 'EVAL_1' line 73␤error:imcc:syntax error, unexpected PREG, expecting '(' ('$P51')␤  in file 'EVAL_1' line 79␤error:imcc:syntax error, unexpected PREG, expecting '(' ('$P54')␤  in file 'EVAL_1' line

[06:51] <p6eval> ..85␤Could not…

[07:08] *** meppl left
[07:11] *** rgrau joined
[07:13] *** agentzh joined
[07:18] *** riffraff joined
[07:18] *** jonasbn joined
[07:20] *** iblechbot joined
[07:25] <sorear> TimToady: Would you characterize :actions as a fossil?

[07:27] *** chitragupt left
[07:29] *** chitragupt joined
[07:37] *** justatheory left
[07:38] *** oldy left
[07:39] <sorear> huh.  perl6.vim parses "is parsed" but not "macro"

[07:39] <moritz_> patch it

[07:48] *** meppl joined
[07:51] *** jql left
[07:51] *** athomason left
[07:52] *** synth left
[07:54] *** lestrrat left
[07:54] *** Koven joined
[07:55] *** athomason joined
[07:55] *** Kovensky left
[07:55] *** lestrrat joined
[07:55] *** agentzh left
[07:56] *** chitragupt left
[07:58] *** kst left
[07:58] *** kst joined
[08:00] *** chitragupt joined
[08:04] *** chitragupt left
[08:06] *** chitragupt joined
[08:10] *** lestrrat is now known as lest_away

[08:10] *** lest_away is now known as lestrrat

[08:23] *** riffraff left
[08:34] <sorear> How is ./perl6 --target=past spelled these days?

[08:35] <moritz_> NYI, I fear

[08:36] *** riffraff joined
[08:37] <sorear> so I'm just hallucinating that it worked in the past?

[08:37] <moritz_> I'm sure it worked in alpha

[08:37] * sorear writes a script to emulate the behavior

[08:37] <sorear> I've never used alpha

[08:37] <sorear> I might be thinking of nqp though

[08:40] <sorear> (would anyone like a copy?)

[08:41] <moritz_> of what?

[08:41] <sorear> a script that emulates perl6 --target=past

[08:41] * moritz_ would prefer a patch

[08:42] <sorear> that would involve me understanding what's wrong

[08:42] <sorear> the bug doesn't make any sense since AFAICT --target=past is a PCT feature and other PCT compilers work

[08:42] <moritz_> I'll try here once my rakudo build is finished

[08:44] <moritz_> works here

[08:44] <moritz_> sorear: there's a known bug... you can't mix --target= with -e

[08:45] <sorear> --target=pir -e works fine

[08:45] <sorear> --target=past -e generates no output

[08:45] <moritz_> now that's weird

[08:46] <sorear> moritz++ perl6 --target=past <( echo 'foo' ) #works fine

[08:46] *** fridim joined
[08:49] <cognominal> --target=parse -e does not generate any output either

[08:54] <sorear> What's idiomatic Perl6 to disambiguate " $varalphanumsafter " ?

[08:55] <moritz_> "{$var}alphanumsafter"

[08:56] <moritz_> though we're all new to Perl 6, more or less, so I'm not that sure with idioms

[08:58] *** JimmyZ left
[09:01] <sorear> std: module Soric4::Event;

[09:01] <p6eval> std 30541: OUTPUT«ok 00:01 109m␤»

[09:01] <sorear> rakudo: module Soric4::Event;

[09:01] <p6eval> rakudo c4857a:  ( no output )

[09:03] <sorear> oh, it's just an error attribution bug

[09:04] <cognominal> rakudo:   my $a; say "{$a}a"

[09:04] <p6eval> rakudo c4857a: OUTPUT«Any()a␤»

[09:04] <cognominal> not sure that what is expected

[09:05] <cognominal> rakudo:   my $a; say "$a"

[09:05] <p6eval> rakudo c4857a: OUTPUT«Any()␤»

[09:05] <moritz_> "a" is expected, probably

[09:05] <moritz_> alpha: my $a; say "$a"

[09:05] <p6eval> alpha 30e0ed: OUTPUT«Use of uninitialized value␤␤»

[09:05] <moritz_> but we don't have the Str/Stringy distinction implemented yet

[09:06] <sorear> rakudo: module Soric4::Event; mxacro term:<event> is parsed( / <?> / ) { }

[09:06] <p6eval> rakudo c4857a: OUTPUT«Confused at line 11, near "module Sor"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[09:06] <sorear> I think this error message counts as outright buggy

[09:06] <moritz_> aye

[09:07] <sorear> rakudo: module Soric4::Event; mxacro foo is parsed( 0 ) { }

[09:07] <p6eval> rakudo c4857a: OUTPUT«Confused at line 11, near "module Sor"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[09:07] <sorear> rakudo: module S; mxacro foo is parsed( 0 ) { }

[09:07] <p6eval> rakudo c4857a: OUTPUT«Confused at line 11, near "module S; "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[09:07] <moritz_> maybe it backtracks over the ;

[09:07] <sorear> most importantly, why are only the first three letters of the error message getting used?

[09:07] <moritz_> huh?

[09:09] <sorear> er

[09:09] <sorear> first three letters of the module name

[09:10] *** lestrrat is now known as lest_away

[09:10] *** lest_away is now known as lestrrat

[09:11] <moritz_> I think the length of code quoted in the error message is limited

[09:11] <sorear> the actual error was quite simple - I forgot to 'make install' my macro-aware rakudo before trying to write code using it

[09:11] <moritz_> which is quite sensible, but maybe the limit itself is a bit too tight

[09:13] <sorear> so would a "grammar backtracks too far generating error" bug be valid?

[09:14] <sorear> is it possible to search the perl6 rt queue?

[09:14] <moritz_> it is possible, the I don't like the search interface at all

[09:14] <sorear> I only see an option for searching the perl.org rt instance, which is less than helpful for things that affect both 5 and 6

[09:14] <moritz_> (and you might need to log in to get to the advanced search)

[09:19] <sorear> sent

[09:19] *** Koven is now known as Kovensky

[09:20] <moritz_> sorear: just read in the backlog about your idea of a streaming PAST model

[09:20] <moritz_> I like it

[09:20] <moritz_> but I don't know how much of it can be used in rakudo

[09:21] <moritz_> because rakudo will have to do additional passes over some intermediate format (don't know if that will be PAST or not)

[09:21] <sorear> "will"?

[09:21] <sorear> what NYI feature requires reprocessing PAST?

[09:21] <moritz_> to determine sink context, and check routine names at CHECK time

[09:21] <moritz_> (sink = void)

[09:40] <dalek> rakudo: c9d9a99 | moritz++ | build/PARROT_REVISION:

[09:40] <dalek> rakudo: bump PARROT_REVISION to get some testing after merge of pbc_frozen_strings1 branch

[09:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c9d9a997fbf06c21a4241723cdc24a49bfb39760

[09:42] *** JimmyZ joined
[09:42] <sorear> rakudo: role A { method foo() { ... }; }; role B { method foo() { say 2; }; }; class C does B does A { };

[09:42] <p6eval> rakudo c4857a: OUTPUT«Method 'foo' collides and a resolution must be provided by the class␤current instr.: 'perl6;Perl6;Metamodel;RoleToClassApplier;_block132' pc 9253 (src/gen/RoleToClassApplier.pir:306)␤»

[09:43] <moritz_> this error message could be awesomized in several ways:

[09:43] <moritz_> 1) tell which class is being composed

[09:44] <moritz_> 2) tell where the methods are coming from (might be many roles in the composition list)

[09:44] <sorear> if it was going to be completely awesome, it should also be spelled "Role-required methods are NYI in Rakudo"

[09:46] <moritz_> I don't know what "Role-required" means

[09:46] <sorear> S14:0076

[09:46] <sorear> method foo() { ... } means "the composed class must have a foo method, it could come from the class itself or another role"

[09:47] <moritz_> ah

[09:50] *** masak joined
[09:50] <masak> oh hai, #perl6

[09:50] <sorear> rakudo: role A { method x() { say 2 }; }; class B does A { }; B.new.x;

[09:50] <p6eval> rakudo c4857a: OUTPUT«Could not find sub &say␤current instr.: 'perl6;A[];x' pc 577 (EVAL_1:223)␤»

[09:51] <moritz_> oh hai masak

[09:51] <sorear> hello masak

[09:52] *** bob___ joined
[09:57] *** kst left
[09:58] *** kst joined
[09:58] *** jql joined
[09:59] <sorear> I just ran into #74858 / #74078 (dups)

[09:59] <sorear> not going to submit another

[10:06] *** chitragupt left
[10:07] * masak merges those

[10:08] *** chitragupt joined
[10:11] *** clintongormley joined
[10:12] *** alexn_org joined
[10:19] <masak> rakudo: for 0, 1 { my $a = { say "LOL" }; say $a.WHICH }

[10:19] <p6eval> rakudo c4857a: OUTPUT«108070592␤108070592␤»

[10:20] <masak> rakudo: my @a; for 0, 1 { my @a[$_] = { say "LOL" }; say @a[$_].WHICH }

[10:20] <p6eval> rakudo c4857a: OUTPUT«43846216␤48606192␤»

[10:20] <masak> this intrigues me. why are the blocks different in the latter case, but not in the former?

[10:25] *** ruoso left
[10:25] *** opx^away left
[10:28] *** opx^away joined
[10:35] <JimmyZ> nqp: my %quotes; say %quotes<f>.WHAT;say %quotes<f>.WHAT ;

[10:35] <p6eval> nqp: OUTPUT«Confused at line 1, near "say %quote"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[10:36] <JimmyZ> nqp: my %quotes; say %quotes{'d'}.WHAT;say %quotes{'f'}.WHAT ;

[10:36] <p6eval> nqp: OUTPUT«Confused at line 1, near "say %quote"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[10:36] <JimmyZ> nqp: my %quotes; say (%quotes{'d'}).WHAT;say (%quotes{'f'}).WHAT ;

[10:36] <p6eval> nqp: OUTPUT«Confused at line 1, near "say (%quot"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[10:39] *** chitragupt left
[10:39] <snarkyboojum> hi masak o/

[10:39] <masak> snarkyboojum: hi!

[10:39] *** chitragupt joined
[10:39] <snarkyboojum> masak++ for awesome yapsi commits :)

[10:40] <masak> snarkyboojum: you mentioned you had something going with tardis...?

[10:40] <snarkyboojum> masak: yeah, that was before I had read the message you'd left me with phenny

[10:40] <masak> oh, I see.

[10:41] <snarkyboojum> masak: however, I have another couple of questions - first one is re the get-ticks gist

[10:41] <masak> fire away.

[10:41] <masak> http://gist.github.com/386512

[10:41] <snarkyboojum> masak: it seems to break if you define a variable in an immediate block - is that a bug?

[10:41] <snarkyboojum> I haven't traced through it

[10:42] <snarkyboojum> e.g. my $program = '{my $a = 5}';

[10:42] <masak> sounds like a bug, yes.

[10:42] <snarkyboojum> can't find the var during get-value-of()

[10:42] <masak> seems I only tried it without immediate blocks :/

[10:42] <snarkyboojum> aye ;) that was my first test case, so I was stuck thinking I'd introduced a bug somewhere for a while

[10:43] <masak> :)

[10:43] <JimmyZ> rakudo:  our $a = 'Hi'; {my $a; say our $a;}

[10:43] <p6eval> rakudo c4857a: OUTPUT«Redeclaration of symbol $a at line 11, near ";}"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[10:43] <JimmyZ> rakudo:  our $a = 'Hi'; {my $a; say our $a;} # masak, is it a bug? 

[10:43] <p6eval> rakudo c4857a: OUTPUT«Redeclaration of symbol $a at line 11, near ";} # masak"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[10:44] <masak> JimmyZ: it should give an error, but not that one.

[10:44] <JimmyZ> rakudo:  our $a = 'Hi'; {say our $a;} # masak, is it a bug? 

[10:44] <p6eval> rakudo c4857a: OUTPUT«Hi␤»

[10:44] <masak> and that's fine.

[10:44] <JimmyZ> rakudo:  our $a = 'Hi'; {say our $a;} # not a bug

[10:44] <p6eval> rakudo c4857a: OUTPUT«Hi␤»

[10:44] <masak> JimmyZ: you shouldn't be able to use an outer-scope variable and then declare one with the same name in the current scope.

[10:44] <masak> std: our $a; { say $a; our $a }

[10:44] <snarkyboojum> masak: I do have something going with tardis, but it's not pretty printing, because I have another newbie perl6 question

[10:44] <p6eval> std 30541: OUTPUT«ok 00:01 110m␤»

[10:44] <masak> hm.

[10:45] <masak> std: our $a; { say $a; my $a }

[10:45] <p6eval> std 30541: OUTPUT«ok 00:01 108m␤»

[10:45] <masak> TimToady: ^

[10:45] <JimmyZ> std: our $a; { my $a; our $a }

[10:45] <p6eval> std 30541: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $a (see line 1) at /tmp/un87KvmUfl line 1:␤------> our $a; { my $a; our $a⏏ }␤ok 00:01 108m␤»

[10:45] <JimmyZ> rakudo: our $a; { my $a; our $a }

[10:45] <masak> snarkyboojum: I love newbie questions. :)

[10:45] <p6eval> rakudo c4857a: OUTPUT«Redeclaration of symbol $a at line 11, near " }"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[10:45] <JimmyZ> rakudo: our $a; { our $a; my $a}

[10:46] <p6eval> rakudo c4857a: OUTPUT«Redeclaration of symbol $a at line 11, near "}"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[10:46] <JimmyZ> rakudo: our $a; { our $a; my $a} # masak, does it work on perl 5?

[10:46] <p6eval> rakudo c4857a: OUTPUT«Redeclaration of symbol $a at line 11, near "} # masak,"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[10:47] <masak> JimmyZ: have you started communicating with me through p6eval now? :)

[10:47] <JimmyZ> ;)

[10:47] <masak> JimmyZ: I don't know if it works in Perl 5. does it matter?

[10:47] <masak> Perl 6 has its own way of handling these things, clearly explained in S02 and S04.

[10:49] * JimmyZ wonders why it works in Perl 5 and why it doesn't work in Perl 6, and what wrong with Perl 5 is about it

[10:51] <masak> in Perl 5 'our $a = 1; { say $a; our $a = 2; say $a; my $a = 3; say $a }; say $a' prints 1\n2\n3\n2\n

[10:51] <masak> and it also gives one warning about a redeclaration and one about variable masking.

[10:52] <masak> I can think of two sane things that might happen in Perl 6.

[10:52] <masak> either it dies, because the user is obviously confusing herself.

[10:52] <masak> or it lives, and the variable in that block behaves like an 'our' variable.

[10:53] <JimmyZ> rakudo: our $a = 3; { say $a; }

[10:53] <p6eval> rakudo c4857a: OUTPUT«3␤»

[10:53] <JimmyZ> rakudo: our $a = 3; sub foo() { say our $a; }; &foo

[10:53] <p6eval> rakudo c4857a:  ( no output )

[10:54] <JimmyZ> rakudo: our $a = 3; sub foo() { say our $a = 3; }; &foo

[10:54] <p6eval> rakudo c4857a:  ( no output )

[10:54] <JimmyZ> rakudo: our $a = 3; sub foo() { say our $a = 3; }; foo()

[10:54] <p6eval> rakudo c4857a: OUTPUT«3␤»

[10:54] <JimmyZ> rakudo: our $a = 3; sub foo() { say our $a }; foo()

[10:54] <p6eval> rakudo c4857a: OUTPUT«3␤»

[10:54] <JimmyZ> rakudo: my $a = 3; sub foo() { say our $a }; foo()

[10:54] <p6eval> rakudo c4857a: OUTPUT«Any()␤»

[10:55] <JimmyZ> rakudo: our $a = 3; sub foo() { say my $a = 3}; foo()

[10:55] <p6eval> rakudo c4857a: OUTPUT«3␤»

[10:55] *** chitragupt left
[10:55] <JimmyZ> rakudo: our $a = 3; sub foo() { say my $a = 4}; foo()

[10:55] <p6eval> rakudo c4857a: OUTPUT«4␤»

[10:58] *** chitragupt joined
[10:58] <snarkyboojum> masak: ah - looks like I sorted out my issue

[10:58] <masak> \o/

[10:58] <snarkyboojum> an issue of my own making even :)

[10:58] <JimmyZ> rakudo: our $a = 3; sub foo() { say my $a = 4; say our $a;}; foo()  # It's sadly for me.

[10:58] <p6eval> rakudo c4857a: OUTPUT«Redeclaration of symbol $a at line 11, near ";}; foo() "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[10:59] <snarkyboojum> masak: now for pretty printing I guess - http://gist.github.com/387966

[10:59] <masak> :)

[10:59] <snarkyboojum> forgive the debugging output :|

[10:59] <masak> no prob. nice to see things falling into place.

[11:00] <masak> I still think pretty-printing could look something like this: http://gist.github.com/372419

[11:00] <snarkyboojum> I wish I had read your gist before trying to integrate :) as I ended up reinventing something like Yapsi::Runtime::get-value-of

[11:00] <snarkyboojum> so threw that out and uses your (more correct) method

[11:01] <snarkyboojum> s/uses/used/

[11:01] <masak> yeah, I put that one in Yapsi::Runtime because it seemed it would be duplicated.

[11:02] <masak> I also think we should invent the commands 'follow $a' and 'unfollow $a', to make some values print automatically ever time the user changes ticks.

[11:02] <snarkyboojum> masak: cool, something like watch

[11:02] <masak> yeah.

[11:02] <masak> maybe that's a better name.

[11:02] <masak> 'watch' and 'unwatch'.

[11:05] <masak> lunch &

[11:05] *** pmurias joined
[11:12] *** meppl left
[11:18] *** takadonet1 left
[11:18] <moritz_> rakudo: sub swap($a, $b) { ($a, $b) = ($b, $a) }; swap my $z = 2, my $y = 5;

[11:18] <p6eval> rakudo c4857a:  ( no output )

[11:19] *** JimmyZ left
[11:20] <moritz_> rakudo: sub swap($a, $b) { ($a, $b) = ($b, $a) }; swap my $z = 2, my $y = 5; say $z;

[11:20] <p6eval> rakudo c4857a: OUTPUT«2␤»

[11:21] <masak> right. list assignment doesn't die when it can't assign readonly values.

[11:21] <colomon> rakudo: sub swap($a is rw, $b is rw) { ($a, $b) = ($b, $a) }; swap my $z = 2, my $y = 5; say $z;

[11:22] <moritz_> Just replied to Mark's email

[11:22] <p6eval> rakudo c4857a: OUTPUT«5␤»

[11:23] <masak> I already replied to him on RT.

[11:23] <masak> oh, and I don't think I cc:ed p6c. d'oh.

[11:24] *** bob___ left
[11:28] <masak> well, no, I didn't pick the wrong lines from p6eval. but the first example wasn't golfed enough.

[11:28] <masak> the ticket ends with this:

[11:28] <masak> rakudo: (1, 2) = 3, 4

[11:28] <p6eval> rakudo c4857a:  ( no output )

[11:28] <masak> which is the root of the problem.

[11:28] <moritz_> agreed

[11:31] *** riffraff left
[11:31] <moritz_> after having fought with my own HTML + JS templates for my slides, somebody pointed me to http://meyerweb.com/eric/tools/s5/

[11:31] <moritz_> which looks nicer than what I have now, although my solution now works

[11:32] <moritz_> http://moritz.faui2k3.org/tmp/talk/0000.html

[11:33] <masak> S5 is indeed nice.

[11:33] <moritz_> I kinda like their FAQ, too

[11:33] <moritz_> Shouldn't it really be the "stupendously simple small sized standards-based structural slide show system", or S9? That would be nearly twice as good as S5, right?

[11:33] <moritz_> Let's not get carried away.

[11:33] <masak> :)

[11:34] <snarkyboojum> alpha: my @list; my %h; %h<a> = <1 2 3>; @list.push: %h; say @list[0].WHAT

[11:34] <p6eval> alpha 30e0ed: OUTPUT«Pair()␤»

[11:34] <snarkyboojum> rakudo: my @list; my %h; %h<a> = <1 2 3>; @list.push: %h; say @list[0].WHAT

[11:35] * colomon cancels his plans to develop S27...

[11:35] <p6eval> rakudo c4857a: OUTPUT«Hash()␤»

[11:35] <masak> I saw a similar answer on a Perl mailing list once. 'how do I write "else if"' in Perl?' -- 'you write it "elsif", it's abbreviated' -- 'shouldn't it be abbreviated to "elif"?' -- 'now don't be absurd.'

[11:35] <snarkyboojum> masak: I'm running into something like this now

[11:36] <snarkyboojum> moritz_: I thought this was pretty funky too http://apirocks.com/html5/html5.html#slide1

[11:37] <masak> snarkyboojum: not sure I understand what the issue is.

[11:37] <moritz_> snarkyboojum: I've seen that too

[11:38] <snarkyboojum> masak: why does alpha say it's a pair, and rakudo say it's a hash? a pair is only giving me one element in the hash presumably?

[11:39] <masak> aye.

[11:39] <snarkyboojum> I want alpha to treat that as a hash

[11:39] <moritz_> a hash in list context behaves like a list of pairs

[11:39] <snarkyboojum> :)

[11:39] *** riffraff joined
[11:40] <masak> alpha: my @list; my %h; %h<a> = <1 2 3>; @list.push: %h.hash; say @list[0].WHAT

[11:40] <p6eval> alpha 30e0ed: OUTPUT«Pair()␤»

[11:40] <masak> hm.

[11:40] *** fridim left
[11:41] <snarkyboojum> alpha: my @list; my %h = { a => 1, b => 2};  @list.push: %h; say @list[0]

[11:41] <p6eval> alpha 30e0ed:  ( no output )

[11:42] <snarkyboojum> ke?

[11:42] <snarkyboojum> rakudo: my @list; my %h = { a => 1, b => 2};  @list.push: %h; say @list[0]

[11:42] <p6eval> rakudo c4857a: OUTPUT«a  1␤b      2␤␤»

[11:42] <snarkyboojum> well anyway, alpha (locally) is returning a 1

[11:45] <snarkyboojum> so that's my problem with alpha

[11:45] *** synth joined
[11:46] <snarkyboojum> funnily enough this works

[11:46] <snarkyboojum> alpha: my @list; my %h = { a => 1, b => 2}; @list.push: \%h; say @list[0]

[11:46] <snarkyboojum> but that's a Capture now

[11:46] <snarkyboojum> or something :S

[11:46] <p6eval> alpha 30e0ed:  ( no output )

[11:46] *** chitragupt left
[11:49] *** chitragupt joined
[11:50] <pugssvn> r30542 | colomon++ | [t/spec] Add some tests for some trickier cases for the series operator. 

[11:52] <dalek> rakudo: 1eef087 | (Solomon Foster)++ | src/core/operators.pm:

[11:52] <dalek> rakudo: Change infix:<...> code to use the last three elements passed on the left-hand side to determine the series, rather than the first three.

[11:52] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1eef08710bbac2b8d68bed0939642ce52b4bfcaa

[11:56] <masak> that... does sound like an improvement... :)

[11:57] <moritz_> masak: seems you don't use master and/or series operator enough :-)

[11:58] <masak> I think I've seen some symptoms that might be due to the above.

[11:58] <masak> don't think I've realized that that was what was wrong until now, though.

[11:59] * moritz_ took a while to parse "that that was what was"

[12:00] *** envi^home joined
[12:00] <masak> moritz_: seems you don't use French enough :)

[12:00] <moritz_> so it seems indeed

[12:00] <colomon> the difference is pretty subtle unless you're doing something weird

[12:01] * masak is doing something weird :)

[12:01] * moritz_ wrote on his applications in the "languages" section: French: learned in school, needs revitalization

[12:02] <masak> same as mine, then.

[12:03] *** riffraff left
[12:03] *** bluescreen joined
[12:04] *** bluescreen is now known as Guest20535

[12:06] <colomon> rakudo: say (4, 2, 1, 2, 4 ... 16).perl

[12:06] <p6eval> rakudo c4857a: OUTPUT«undef␤»

[12:06] *** nazgjunk joined
[12:06] *** takadonet joined
[12:06] <takadonet> morning all

[12:07] <colomon> >  say (4, 2, 1, 2, 4 ... 16).perl

[12:07] <colomon> (4, 2, 1, 2, 4, 8/1, 16/1)

[12:07] <moritz_> what is this "undef", and where does it come from?

[12:07] <masak> takadonet: \o

[12:08] <colomon> moritz_: not sure.

[12:08] <colomon> it should have been an infinite series before.

[12:08] <masak> rakudo: sub foo($i) { return { $i } }; say foo(5)(); say foo(42)(); my $c1 = foo(5); my $c2 = foo(42); say $c1(); say $c2()

[12:08] <p6eval> rakudo c4857a: OUTPUT«5␤42␤42␤42␤»

[12:08] <masak> :(

[12:08] *** meppl joined
[12:09] <masak> it's not as bad as lexicals not working with recursion, but it's not good either. :/

[12:13] <colomon> " If $ab is zero, and the three values look like numbers, then the function is *+0."

[12:14] *** ruoso joined
[12:14] <colomon> what do you think the technical meaning of "look like numbers" is?

[12:14] <moritz_> it's probably: either ~~ Numeric, or can be parsed as a number

[12:15] * moritz_ tries to build a newer rakudo on the p6eval server

[12:16] <colomon> moritz_: well yes.  I hadn't imagined there was a third possibility.... :)

[12:16] <masak> I read it as 'can be parsed as a number'.

[12:18] <colomon> masak: is there a way to test that?

[12:18] <masak> colomon: I was going to say $ab eq ~+$ab, but that probably doesn't DWWM.

[12:19] <moritz_> use Scalar::Util qw(looks_like_number)

[12:19] <masak> :)

[12:19] <moritz_> (that does exist in Perl 5 core)

[12:20] <colomon> ~$ab ~~ /^\d/   

[12:20] <colomon> ?

[12:20] <moritz_> .4

[12:20] <masak> 4e3

[12:20] <moritz_> rakudo: say .4

[12:20] <p6eval> rakudo c4857a: OUTPUT«0.4␤»

[12:20] <masak> 5i

[12:20] <moritz_> but /^\.?\d/ might be good enough

[12:20] <moritz_> as a start

[12:20] <masak> 0x30

[12:21] <moritz_> starts with 0, with matches \d

[12:21] <masak> :)

[12:21] <colomon> say "3.4".succ

[12:21] <moritz_> rakudo: say 1 + ' 3'

[12:21] <p6eval> rakudo c4857a: OUTPUT«4␤»

[12:21] <moritz_> rakudo: say "3.4".succ

[12:21] <p6eval> rakudo c4857a: OUTPUT«4.4␤»

[12:22] <moritz_> rakudo: say 'cimg0001.jpg'.succ

[12:22] <p6eval> rakudo c4857a: OUTPUT«cimg0002.jpg␤»

[12:22] <moritz_> \o/

[12:22] <masak> that's just sick :P

[12:22] <colomon> rakudo: say ('cimg0001.jpg' ... *).perl

[12:22] <p6eval> rakudo c4857a: OUTPUT«("cimg0001.jpg", "cimg0002.jpg", "cimg0003.jpg", "cimg0004.jpg", "cimg0005.jpg", "cimg0006.jpg", "cimg0007.jpg", "cimg0008.jpg", "cimg0009.jpg", "cimg0010.jpg", "cimg0011.jpg", "cimg0012.jpg", "cimg0013.jpg", "cimg0014.jpg", "cimg0015.jpg", "cimg0016.jpg", "cimg0017.jpg",

[12:22] <p6eval> .."cimg0018…

[12:23] <masak> whoa. an infinite sequence of .jpg file names. o.O

[12:23] <masak> how come .perl finishes?

[12:23] <moritz_> rakudo: say (1 ... *).perl

[12:23] <p6eval> rakudo c4857a: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, {???} ... ???)␤»

[12:24] <moritz_> it cheats :-)

[12:24] <masak> oh, good.

[12:24] <colomon> masak: it's got a limiter now.

[12:24] <colomon> I don't know how great an idea that is in general, but it is very handy for testing.

[12:24] <masak> I was worried for a while that it did something impossible.

[12:24] *** nazgjunk left
[12:24] <colomon> (with the REPL, I mean)

[12:24] <masak> what REPL? :)

[12:28] *** colomon left
[12:29] <masak> sorear: re http://irclog.perlgeek.de/perl6/2010-04-29#i_2276344 , I don't see how that could work. I see your intention with C.new.*handler, but the error occurs already at class composition time (as it should).

[12:29] <moritz_> rakudo: say "version"

[12:30] <p6eval> rakudo c4857a: OUTPUT«version␤»

[12:30] <masak> sorear: the thing about roles is that they flatten and mostly cease to exist at class composition time. so what you're left with is a collision between multi candidates.

[12:33] <moritz_> unless the multis are marked externally as stubs, and special-cased at composition time

[12:41] <pmurias> ruoso: ping

[12:41] *** k23z__ joined
[12:43] *** SmokeMachine joined
[12:49] <dalek> rakudo: b440a11 | moritz++ | t/spectest.data:

[12:49] <dalek> rakudo: two more passing test files

[12:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b440a117618c820a22964e34d7b8179060619b98

[12:50] *** chitragupt left
[12:51] <ruoso> hi pmurias 

[12:53] *** chitragupt joined
[12:59] *** p6eval left
[13:01] *** p6eval joined
[13:05] *** lestrrat is now known as lest_away

[13:05] *** lest_away is now known as lestrrat

[13:06] *** rv2733 joined
[13:06] <pmurias> ruoso: i want to seperate the mildew core from the C/smop backend so the perlesque backend can be easily installable

[13:06] *** p6eval left
[13:07] <ruoso> that'd be nice...

[13:08] <pmurias> one thing i'm not sure how to solve is that we load all the VAST classes by getting a list of them with a glob

[13:08] *** p6eval joined
[13:08] <ruoso> pmurias, using Module::Pluggable would solve that

[13:08] * ruoso .oO( is that the name of the module? )

[13:09] *** chitragupt left
[13:11] *** M_o_C joined
[13:12] <pmurias> ruoso: yes that one looks like it will be helpfull

[13:13] *** jql left
[13:16] *** chitragupt joined
[13:18] *** Guest19628 left
[13:19] <pmurias> ruoso: what would be the could name for the backend independent part? Mildew::Common?

[13:20] <pmurias> or just Mildew

[13:20] <pmurias> ?

[13:23] *** colomon joined
[13:23] *** iblechbot left
[13:24] *** rgrau` joined
[13:28] *** rgrau_ joined
[13:29] *** rgrau` left
[13:30] *** tlb joined
[13:31] <masak> Perl 6 equals communism: http://zag.ru//page/item_view/kommunizm-v-ehpokhu-perl6.html

[13:32] *** uniejo left
[13:32] <masak> if I understand the reasoning correctly it's that Parrot will enable many languages to run at the same time, and that 28 times 5 is 140.

[13:32] <pmurias> i get a 502 error which is propably better as the post doesn't sound sensible

[13:34] *** chitragupt left
[13:34] *** chitragupt joined
[13:35] <masak> it was mostly silly, actually.

[13:35] <masak> got caught in my Twitter live search.

[13:44] <ruoso> pmurias, just mildew

[13:45] <pugssvn> r30543 | pmurias++ | [mildew] started seperating mildew into modules 

[13:45] <moritz_> http://robertfortner.posterous.com/the-unrecognized-death-of-speech-recognition

[13:46] <moritz_> (probably old news to people like arnsholt_, but I found it quite interesting)

[13:47] <colomon> moritz_: funny thing was, I saw that headline immediate after seeing ESR mention how nice the speech recognition feature on his Android phone was....

[13:48] <arnsholt_> moritz_: You know how it is. It's hard to wreck a nice beach/It's hard to recognise speech =)

[13:48] <moritz_> colomon: and it does work quite well, for limited applications like controlling a phone

[13:49] <colomon> moritz_: actually the context was how (almost?) any text field could be filled using speech recognition.

[13:49] <moritz_> cool if it works :-)

[13:49] <colomon> "Much more impressive in practice is the fact that voice-to-text now works on any text input box, rather than being a browser-only feature. It’s not perfect – you’ll get the occasional funny homonym – but it’s good enough to reduce the amount of typing I have to do really significantly, and the background-noise cancellation works remarkably well. I’ve grown used to having it work even in the hubbub of a crowded convention 

[13:50] <colomon> http://esr.ibiblio.org/?p=1961 but that's all he says about that.

[13:51] <colomon> I don't know how true it is, but it was very funny in conjunction with the other article's headline.  :)

[13:52] <moritz_> somehow that reminds me of "Perl is dead" - "Perl is alive and kicking" :-)

[13:52] <arnsholt_> The section about statistics is interesting (and to my taste)

[13:52] *** arnsholt_ is now known as arnsholt

[13:53] <arnsholt> You can get some quite interesting results with statistical models, but you only get so far

[13:54] <arnsholt> Especially, what is the most probable sequence at one level (word segmentation of running speech for example) may very well turn out to be impossible further up in the hierarchy (syntax, semantics)

[13:54] *** chitragupt left
[13:56] *** alester joined
[13:57] <moritz_> so you need backtracking

[13:57] *** chitragupt joined
[14:00] <arnsholt> Yeah, I think so. Some kind of interation between the different layers

[14:00] *** meppl left
[14:01] <arnsholt> Also, as he points out in the conclusion, the problem looks increasingly like flat-out AI

[14:05] *** mikehh left
[14:08] *** chitragupt left
[14:12] *** jql joined
[14:23] <masak> time to crack flat-out AI, then :P

[14:24] <moritz_> let's do that in Perl 6

[14:24] <masak> "Perl 6 is all good and well, but what can you USE it for?" -- "Here, hold this AI."

[14:25] <moritz_> rakudo: say 1

[14:25] <p6eval> rakudo 1eef08: OUTPUT«1␤»

[14:25] <moritz_> note the new-and-improved revision string

[14:26] <colomon> ?

[14:26] <masak> looks like earlier today.

[14:26] <colomon> or do you just mean that it is compiling again?

[14:26] *** PacoLinux joined
[14:27] *** _kaare joined
[14:27] <colomon> rakudo: say (4, 2, 1, 2, 4 ... 256).perl

[14:27] <p6eval> rakudo 1eef08: OUTPUT«(4, 2, 1, 2, 4, 8/1, 16/1, 32/1, 64/1, 128/1, 256/1)␤»

[14:27] <moritz_> colomon: I've compiled a new version again

[14:27] <moritz_> took 40min

[14:27] <colomon> ye gads.

[14:28] <colomon> moritz_++

[14:28] <moritz_> so I'm reluctant to cron-job it again right now

[14:29] <masak> :/

[14:29] <Juerd> Just put it in an infinite loop then

[14:29] <Juerd> ;)

[14:29] <moritz_> thus spoketh the experienced sysadmin, and was never seen again

[14:29] *** kst left
[14:30] <Juerd> I have several things running in infinite loops

[14:30] <Juerd> I'm considering it for backups too

[14:30] *** kst joined
[14:34] <pugssvn> r30544 | moritz++ | [t/spec] unfudges for rakudo 

[14:35] <pugssvn> r30545 | moritz++ | [t/spec] typo in file name 

[14:38] <lisppaste3> colomon pasted "C++ versus Perl 6 " at http://paste.lisp.org/display/98714

[14:39] * moritz_ kinda likes the perl 6 version better :-)

[14:40] <colomon> so far I'm finding the conversion from Perl 6 to C++ to be relatively quick, and it was a lot nicer prototyping in Perl 6.  :)

[14:44] <masak> sorear: you mixed up me and moritz_ in a bug report :) http://rt.perl.org/rt3/Ticket/Display.html?id=74866

[14:45] *** molaf joined
[14:45] <moritz_> .oO( are we isomorphic in IRC? :-)

[14:46] * masak .oO( isomorizm )

[14:47] <moritz_> :-)

[14:48] *** nihiliad joined
[14:49] *** christine left
[14:52] *** christine joined
[14:53] *** meppl joined
[14:53] *** _kaare left
[14:59] *** pmurias left
[15:00] *** k23z__ left
[15:01] <masak> rakudo: say e ** pi - pi

[15:01] <p6eval> rakudo 1eef08: OUTPUT«19.9990999791895␤»

[15:01] <masak> I hear if there are no rounding errors, that should be 20 :)

[15:02] <moritz_> exactly 20?

[15:02] <masak> yes!

[15:02] <colomon> :\

[15:02] * masak tries to conceal a smile

[15:02] <masak> http://www.xkcd.com/217/

[15:03] <moritz_> lol

[15:03] *** riffraff joined
[15:04] <colomon> I should have remembered the cartoon.  

[15:04] <colomon> I see we are indeed as accurate as it.  :)

[15:06] <masak> Raccurato++

[15:22] *** M_o_C left
[15:22] <colomon> I have to admit that working on const-correctness kind of makes me wish we had that for Perl 6 methods.

[15:23] *** M_o_C joined
[15:26] <masak> 'const-correctness'?

[15:27] <colomon> masak: you can (sort of) guarantee a C++ method has no side-effects on the class object it is run on by declaring it "const".  

[15:28] <masak> that feels oddly sideways.

[15:28] <masak> it's not the method that is 'const', it's the things it doesn't do to the invocant :)

[15:29] <masak> colomon: anyway, I could imagine that being done with a trait of some sort.

[15:29] <colomon> it's definitely not perfect

[15:29] <colomon> but having the compiler enforce it can be a handy way of clarifying your thinking that Perl 6 lacks.

[15:30] <colomon> (but then, if you can define a trait for that, that would be full of awesome....)

[15:30] <colomon> it is one more bookkeeping thing to keep track of while you are programming, but it's mostly second nature to me now.  :)

[15:30] <masak> it would probably have to involve some analysis of the method body, in order to enforce the constraint...

[15:31] * colomon nods

[15:31] <masak> something like 'the method body may not assign to attributes, or call other methods which don't have the same trait"

[15:33] <colomon> the nice thing about that is you could also have the stricter version:

[15:33] <colomon> this method has no side effects.

[15:34] <masak> is 'next' a side effect?

[15:34] <masak> what about looping forever?

[15:35] <colomon> heh, there was discussion of looping forever (and the optimization thereof) on Hacker News yesterday.

[15:35] <masak> URL?

[15:37] <colomon> http://news.ycombinator.com/item?id=1310105

[15:38] *** M_o_C left
[15:39] <masak> ah, I had put that one in my queue. :)

[15:39] <colomon> :)

[15:39] <colomon> it's an interesting question.

[15:41] <masak> seems the discussion is divided between those who stick to the spec and those who appeal to reality :)

[15:42] <colomon> though I'm inclined to agree with the group who thinks that complicated loops that provably have no side effects in any iteration of the loop ought to be optimized away.

[15:42] <masak> hm, maybe.

[15:42] <colomon> sounded to me like a hole in the spec, not really specified either way.

[15:43] <colomon> (which would be unsurprising in C/C++, of course.)

[15:44] *** M_o_C joined
[15:54] *** _kaare joined
[16:00] *** eternaleye left
[16:03] *** envi^home left
[16:05] *** constant left
[16:07] *** constant joined
[16:07] *** constant left
[16:07] *** constant joined
[16:10] *** justatheory joined
[16:11] *** chitragupt joined
[16:11] <dalek> yapsi: 8c6edd7 | masak++ | lib/Yapsi.pm:

[16:11] <dalek> yapsi: [Yapsi] bumped SIC version

[16:11] <dalek> yapsi: Between releases, the SIC version is always the version number of the

[16:11] <dalek> yapsi: upcoming release.

[16:11] <dalek> yapsi: review: http://github.com/masak/yapsi/commit/8c6edd73d1b68553502e75121cf802e6f1301dda

[16:14] *** REPLeffect joined
[16:16] <masak> swimming &

[16:16] *** masak left
[16:17] *** kst left
[16:17] *** kst joined
[16:27] *** iblechbot joined
[16:30] *** ash_ joined
[16:39] *** nihiliad left
[16:39] *** nihiliad joined
[16:40] *** chitragupt left
[16:40] *** chitragupt joined
[16:44] *** tlb left
[16:49] *** sundar_afk joined
[16:49] *** fda314925 left
[16:49] *** hicx174 left
[17:12] *** cdarroch joined
[17:12] *** cdarroch left
[17:12] *** cdarroch joined
[17:21] *** [[mark]] left
[17:25] <sorear> phenny: tell masak - (on .*) - .* has other problems anyway (too low level), which is why I'm going via http://pastie.org/943825 ;)

[17:25] <phenny> sorear: I'll pass that on when masak is around.

[17:27] <sorear> phenny: tell masak - closures not working is a PCT problem I think; declaration blocks should get newclosure'd before being capture_lex'd

[17:27] <phenny> sorear: I'll pass that on when masak is around.

[17:33] *** _kaare left
[17:38] *** BrowserUk joined
[17:38] <colomon> Ack, one line of Perl 6 just translated to 9 of C++. 

[17:39] *** szabgab left
[17:39] <ash_> ?

[17:39] <ash_> colomon: how did you translate into c++?

[17:39] <colomon> by hand

[17:41] <ash_> what line of perl6 was it?

[17:42] <colomon> my @limited-points = (@.points, $possible-inner.points).grep({ $_[0] ~~ $inner-u-range });

[17:43] <ash_> yeah, i can see why that would be so many lines :P 

[17:44] <ash_> o.0 apparently, (i forgot this...) but in my nq-nqp, i can generate functions already, hmmm but they aren't being added to the lexical scope properly, but thats not to hard

[17:51] <diakopter> rakudo: sub foo($i) { return { $i } }; say foo(5)(); say foo(42)(); my $c1 = foo(5); my $c2 = foo(42); say $c1(); say $c2()

[17:52] <p6eval> rakudo 1eef08: OUTPUT«5␤42␤42␤42␤»

[17:52] <diakopter> !!!

[17:52] <diakopter> alpha: sub foo($i) { return { $i } }; say foo(5)(); say foo(42)(); my $c1 = foo(5); my $c2 = foo(42); say $c1(); say $c2()

[17:52] <p6eval> alpha 30e0ed: OUTPUT«5␤42␤5␤42␤»

[17:52] <diakopter> oh

[17:52] <diakopter> that's kindof a major regression

[17:53] <ash_> yeah

[17:53] *** ShaneC joined
[17:53] *** ShaneC left
[17:53] <ash_> somewhere its not capturing lexicals properly 

[17:54] *** mikehh joined
[17:56] <PerlJam> ash_: or maybe it's not creating the closure properly

[17:56] <ash_> rakudo: sub foo($i) { return { $i } }; my $c1 = foo(42); my $c2 = foo(5); say $c1(); say $c2(); # a shorter version of it

[17:56] <p6eval> rakudo 1eef08: OUTPUT«5␤5␤»

[17:59] <diakopter> I would have to insist that that's an R* blocker

[17:59] <TimToady> I would tend to agree

[17:59] <PerlJam> I don't think anyone would argue with that :)

[18:01] *** nadim_ joined
[18:08] *** kst left
[18:08] *** kst joined
[18:12] *** M_o_C left
[18:13] <colomon> ah, yes, that's been a huge bug for a while.

[18:13] <colomon> (I mean, it's a regression switching from alpha to master, not a regression in master itself)

[18:14] <sjohnson> hi

[18:16] <diakopter> not cloning lexpads might explain speed improvement

[18:21] <ash_> nqp: sub foo($i) { return { $i }; }; my $a := foo(1); my $b := foo(3); say($a(), $b());

[18:21] <p6eval> nqp: OUTPUT«33␤»

[18:21] <ash_> its a problem in nqp also 

[18:26] *** SmokeMachine left
[18:33] *** M_o_C joined
[18:35] *** pyrimidine joined
[18:35] *** ash_ left
[18:36] <colomon> diakopter: speed improvement where?  (I'm assuming you're still talking about the closure issue.)

[18:37] *** [particle] left
[18:39] <diakopter> from alpha to master

[18:42] <colomon> was there one?

[18:42] <colomon> I know the spectests ran faster back in the day, but that was when we weren't running most of them on master/ng.

[18:45] *** SmokeMachine joined
[18:46] *** [particle] joined
[18:53] *** M_o_C left
[18:55] *** cotto_work left
[18:57] <colomon> at any rate, IMO the closure thing is one of the top two biggest issues we need solved by R*.

[18:59] *** masak joined
[18:59] <pyrimidine> colomon: what was the other issue?

[19:00] <masak> I agree about the closures thing being a Rakudo Star blocker.

[19:00] <phenny> masak: 17:25Z <sorear> tell masak - (on .*) - .* has other problems anyway (too low level), which is why I'm going via http://pastie.org/943825 ;)

[19:00] <phenny> masak: 17:27Z <sorear> tell masak - closures not working is a PCT problem I think; declaration blocks should get newclosure'd before being capture_lex'd

[19:00] * pyrimidine came in late to the conversation

[19:00] <colomon> pyrimidine:  getting the current issues with Array, Seq, iterators, and lazy lists sorted out.

[19:00] <masak> it's also a blocker for my understanding of how blocks and closures work in Perl 6. :)

[19:00] <pyrimidine> ok

[19:01] <colomon> rakudo: sub bad(@a) { say @a.perl; say @a.perl; }; bad(1 ... 10)

[19:01] <p6eval> rakudo 1eef08: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)␤()␤»

[19:02] <masak> rakudo: our $a = 1; say $a; { our $a = 2; say $a; my $a = 3; say $a }; say $a

[19:02] <p6eval> rakudo 1eef08: OUTPUT«Redeclaration of symbol $a at line 11, near " = 3; say "␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[19:02] <masak> std: our $a = 1; say $a; { our $a = 2; say $a; my $a = 3; say $a }; say $a

[19:02] <p6eval> std 30545: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $a (see line 1) at /tmp/b4BXQvFtb1 line 1:␤------> = 1; say $a; { our $a = 2; say $a; my $a⏏ = 3; say $a }; say $a␤ok 00:01 110m␤»

[19:02] <colomon> pyrimidine: that's a symptom, but the real problem is deeper and conceptual.

[19:02] <pyrimidine> sounds like it reaches back into PCT as well

[19:04] *** skangas joined
[19:05] <colomon> hmmm.... next Rakudo release is May 20th?

[19:06] * masak thinks so

[19:06] <moritz_> colomon: aye. And you're the release manager

[19:06] <colomon> moritz_: ah, right!  :)

[19:07] <colomon> I'll try not to let the power go to my head.

[19:07] <moritz_> :-)

[19:07] <colomon> But before moritz_++ reminded me of that, I was going to suggest that we really ought to have both those bugs taken care of before this month's release.

[19:08] <colomon> seems like it would be very scary for R* if we were trying to deal with those things in June....

[19:09] *** kst left
[19:10] *** kst joined
[19:11] * colomon needs to finish this C++ $work project so he can get to proper Rakudo hacking...

[19:11] <colomon> afk

[19:13] *** ash_ joined
[19:17] <masak> good topic for tomorrows #rs, then.

[19:19] <masak> sorear: I find your macro code intriguing and I want to subscribe to your newsletter.

[19:22] *** SmokeMachine left
[19:30] <ash_> masak: whats the link for sorear's blog? 

[19:30] <colomon> masak: I'm suddenly wondering why I've been thinking of the lazy list issue as a big block.  It seems to me there are probably 3-4 approachable pieces in there...

[19:31] *** nihiliad left
[19:31] <masak> ash_: don't know if he has one. my expression was more an instance of a Slashdot meme than anything else. (but sincere. he's doing cool stuff with macros!)

[19:31] *** nihiliad joined
[19:32] <masak> colomon: that's great news.

[19:32] <colomon> masak: mind you, I may be insane.

[19:32] <colomon> but I am definitely feeling inspired at the minute.

[19:32] <masak> \o/

[19:32] <colomon> which of course means it's time for $work.  :(

[19:34] *** meppl left
[19:35] *** molaf left
[19:37] *** tri1 joined
[19:40] *** k23z__ joined
[19:50] <masak> nom &

[19:50] *** masak left
[20:00] <pugssvn> r30546 | moritz++ | [helpnow] draft for first challenge/task 

[20:00] <moritz_> I'd appreciate it if somebody could gloss over that announcement and give me some feedback

[20:01] <ash_> moritz_: do you have any idea on the capturing of lexical vars bugs? it appears to be a problem in nqp-rx as well as rakudo 

[20:02] *** bkeeler left
[20:02] *** bkeeler joined
[20:02] <moritz_> ash_: nope

[20:02] <moritz_> ash_: I think you know the nqp-rx code base better than I do

[20:04] <ash_> maybe i can compare the pir generated by master and alpha and look for glaring differences (which there will probably be a bunch) 

[20:07] <moritz_> rakudo: enum A <b c d>; say A::c

[20:07] <p6eval> rakudo 1eef08: OUTPUT«Can not find sub A::c␤current instr.: 'perl6;Perl6Exception;throw' pc 15354 (src/builtins/Associative.pir:46)␤»

[20:07] <moritz_> rakudo: enum A <b c d>; say c

[20:07] <p6eval> rakudo 1eef08: OUTPUT«1␤»

[20:07] *** thowe joined
[20:07] <moritz_> rakudo: enum A <b c d>; say d

[20:07] <p6eval> rakudo 1eef08: OUTPUT«2␤»

[20:07] *** muixirt joined
[20:07] <moritz_> rakudo: enum A <b c d>; say c ~~ A

[20:07] <p6eval> rakudo 1eef08: OUTPUT«0␤»

[20:07] <moritz_> rakudo: enum A <b c d>; say 2 ~~ c

[20:07] <p6eval> rakudo 1eef08: OUTPUT«0␤»

[20:08] <moritz_> rakudo: enum A <b c d>; say 2 ~~ d

[20:08] <p6eval> rakudo 1eef08: OUTPUT«1␤»

[20:08] <ash_> rakudo: sub a { 'a' }; enum A <a b c d>; say a; 

[20:08] <p6eval> rakudo 1eef08: OUTPUT«0␤»

[20:08] <ash_> is that an issue? 

[20:08] <moritz_> yes

[20:09] <ash_> rakudo: sub a { 'a' }; enum A <a b c d>; say a, &a;

[20:09] <p6eval> rakudo 1eef08: OUTPUT«0a␤»

[20:09] <moritz_> jnthn wrote "First hacky cut of named enums" not without reason

[20:10] *** clintongormley left
[20:10] <ash_> you can (thankfully) still get to sub a 

[20:10] <ash_> guess i should use & more to make sure you can tell what your doing 

[20:10] <moritz_> not really

[20:10] <moritz_> a() should be sufficient

[20:11] <moritz_> rakudo: sub a { 'a' }; enum A <a b c d>; say a()

[20:11] <ash_> rakudo: sub a { 'a' }; enum A <a b c d>; say a, a();

[20:11] <p6eval> rakudo 1eef08: OUTPUT«a␤»

[20:11] <p6eval> rakudo 1eef08: OUTPUT«0a␤»

[20:11] <ash_> ah, cool 

[20:11] * colomon apparently just slept 20 minutes sitting up in his office chair .

[20:11] <colomon> hey, I just realized jnthn is missing #rs this week.

[20:11] <ash_> power nap eh? 

[20:11] <colomon> perfect time to go crazy.  ;)

[20:11] <colomon> power nap indeed.

[20:11] <colomon> no wonder my mouth was dry.

[20:12] *** krakan left
[20:12] <colomon> I thought I was just blinking in and out a bit, but Jen says I snored for 20 minutes.

[20:26] *** lue left
[20:32] *** tri1 left
[20:37] *** eternaleye joined
[20:50] *** skangas left
[20:51] *** skangas joined
[20:51] *** patrickas joined
[20:54] *** rv2733 left
[21:01] *** Lorn left
[21:02] *** Lorn joined
[21:03] *** orafu left
[21:05] *** orafu joined
[21:11] *** jonasbn left
[21:14] *** riffraff left
[21:20] *** sundar_afk left
[21:21] *** Tene left
[21:21] *** pmurias joined
[21:21] <pmurias> diakopter: hi

[21:23] *** lichtkind joined
[21:24] <diakopter> hio

[21:24] <lichtkind> hai

[21:25] *** cotto_work joined
[21:29] <diakopter> pmurias: I'm working on revealing clr generic types to perlesque as parametric types

[21:29] *** Guest20535 left
[21:30] <diakopter> pmurias: also, I got the asmbly_1.exe files to not have a dependency on Sprixel.exe

[21:30] <diakopter> (necessarily)

[21:31] <diakopter> (in mildew's case, we'll want to have mildew_stage0.dll available as a link to both Sprixel.exe's compiler and the resulting assemblies)

[21:31] *** mikehh left
[21:31] *** mikehh joined
[21:31] <diakopter> (so that mildew's resulting assemblies don't need a reference/dependency to Sprixel.exe)

[21:32] <diakopter> (unless of course the code they represent contains an "eval('code')"

[21:36] *** patrickas left
[21:39] *** chitragupt left
[21:42] <pmurias> what should mildew_stahe0.dll contain?

[21:42] <pmurias> * mildew_stage0.dll

[21:42] <pmurias> the P6{Str,capture...}?

[21:45] <diakopter> yes

[21:54] *** kensanata joined
[21:56] *** Tene joined
[21:56] *** Tene left
[21:56] *** Tene joined
[21:59] *** kensanata left
[22:00] *** iblechbot left
[22:04] *** kst left
[22:04] *** kst joined
[22:04] <lichtkind> what is ORed ?

[22:10] <TimToady> the opposite of ANDed

[22:12] <lichtkind> TimToady: thanks

[22:12] <lichtkind> TimToady: you got my reaction to your message?

[22:13] <lichtkind> i see now it means or-ed, i read o-red

[22:13] *** pmurias left
[22:14] <TimToady> lichtkind: yes, though I sent my message a couple days before you got it :)

[22:14] <TimToady> possibly before Damian sent his...

[22:14] <lichtkind> TimToady: yes so damian was only virtually faster, but he found some other error too

[22:15] <lichtkind> TimToady: however its fixed now in both version, working on metops and escape sequences now

[22:18] * lichtkind currently sees he missed the S meta op

[22:18] <ash_> /msg p6eval rakudo: my $a = 3; sub f { say $a + 2 }; $a = 1; f();

[22:20] *** kensanata joined
[22:21] *** ruoso left
[22:22] *** kensanata left
[22:26] <ash_> i found whats wrong with closures in nqp-rx

[22:27] <ash_> nqp: sub foo($i) { return { $i } }; my $a := foo(4); my $b := foo(2); say($a(), $b());

[22:27] <p6eval> nqp: OUTPUT«22␤»

[22:27] <ash_> nqp: sub foo($i) { return pir::newclosure__PP({ $i }); }; my $a := foo(4); my $b := foo(2); say($a(), $b());

[22:27] <p6eval> nqp: OUTPUT«42␤»

[22:27] <ash_> it's missing a newclosure to capture the variables properly 

[22:28] <ash_> rakudo: sub foo($i) { return pir::newclosure__PP(%7B $i }); }; my $a = foo(4); my $b = foo(2); say($a(), $b());

[22:28] <p6eval> rakudo 1eef08: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[22:28] <ash_> rakudo: sub foo($i) { return pir::newclosure__PP(%7B({ $i }); }; my $a = foo(4); my $b = foo(2); say($a(), $b())

[22:28] <p6eval> rakudo 1eef08: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[22:29] <ash_> rakudo: sub foo($i) { return pir::newclosure__PP({ $i }); }; my $a = foo(4); my $b = foo(2); say($a(), $b())

[22:29] <p6eval> rakudo 1eef08: OUTPUT«Attempting to do sub operation on non-Sub.␤current instr.: 'foo' pc 272 (EVAL_1:96)␤»

[22:29] *** pyrimidine left
[22:30] *** rgrau__ joined
[22:32] *** rgrau_ left
[22:41] *** ash_ left
[22:43] *** kensanata joined
[22:52] <snarkyboojum> no

[22:52] <snarkyboojum> oops wrong window :)

[22:54] <TimToady> yes

[23:04] *** nihiliad left
[23:05] *** Sanitoeter left
[23:06] *** Sanitoeter joined
[23:14] *** cdarroch left
[23:14] <sorear> moritz_: I know *exactly* what's causing the lexical var capture bug.

[23:15] <sorear> do I need to put this in the topic or something?  ash_ just spent however much time rediscovering it...

[23:15] <sorear> unfortunately

[23:15] <sorear> phenny: seen pmichaud

[23:16] <sorear> this is a potentially controvertial change; I need to track down the PCT maintainer before I can push a patch

[23:16] <sorear> which is probably going to have to be a #parrotsketch thing

[23:17] <TimToady> well, better to ask around on #parrot than here, I suspect

[23:20] *** rgrau__ left
[23:21] <snarkyboojum> rakudo: say e ** pi - pi # backlogging fun

[23:21] <p6eval> rakudo 1eef08: OUTPUT«19.9990999791895␤»

[23:25] *** lestrrat is now known as lest_away

[23:25] <sorear> phenny: tell ash_ - please contact me before raising more heckles over broken closures in PCT.  You're duplicating a ridiculous amount of work I did a week ago.

[23:25] <phenny> sorear: I'll pass that on when ash_ is around.

[23:27] *** masak joined
[23:27] <masak> ahoy.

[23:27] <diakopter> sorear: disregarding the controversial-ness of your proposed change, I'm curious about the technical explanation

[23:27] *** lue joined
[23:28] <masak> I just realized that jnthn++ has put in a first shot at named enums.

[23:28] <masak> I'm not sure I had registered that before. even though it's not complete, it's great news.

[23:29] *** chitragupt joined
[23:29] <masak> and now jnthn has gone underground, which I take to mean that he wants me to round up all the aspects of named enums that still don't work, and package them as RT tickets until he comes back. :P

[23:30] <sorear> You could always help me break macros

[23:30] <masak> oh, gladly.

[23:32] *** chitragupt left
[23:32] *** chitragupt joined
[23:33] *** wknight8111 joined
[23:37] <sorear> masak: Sadly, I don't have a newsletter.

[23:38] <snarkyboojum> dobro jutro p6hackers

[23:38] <masak> no jutro here for a couple hours yet... :)

[23:39] <snarkyboojum> I thought it was almost 2am there - oh well :)

[23:39] <masak> sorear: then how am I supposed to know about the current state of macro implementation? :)

[23:39] *** chitragupt left
[23:39] <masak> snarkyboojum: it is. could be seen as a very premature jutro, I guess... :)

[23:40] <masak> but I assure you it doesn't get darker than this outside.

[23:40] <sorear> shrug, I guess you could try github's rss generator

[23:40] *** kensanata left
[23:40] <colomon> masak: I'm sure he'd be happy if you found the bugs and fixed them instead.  ;)

[23:40] *** chitragupt joined
[23:40] <masak> sorear: on what repo?

[23:40] <masak> Rakudo?

[23:40] <sorear> sorear/rakudo

[23:40] <masak> ah, excellent.

[23:40] <masak> I will most certainly download it and give it a whirl.

[23:41] <masak> I mean, macros! wow!

[23:41] <sorear> and I found a rakudobug while implementing it!

[23:41] <masak> yeah, I noticed :)

[23:41] <masak> sorear++

[23:42] <masak> so, the most recent work is in topic/macros?

[23:43] <sorear> yes

[23:43] <sorear> heh, I found a wrong spectest

[23:44] <sorear> S06-operator-overloading/sub.t 155  'my' needs to be 'our'

[23:45] *** muixirt left
[23:45] <masak> why?

[23:46] <sorear> because my subs don't live in namespaces

[23:46] <sorear> so &::(...) is wrong

[23:46] <masak> ah, indeed.

[23:47] <TimToady> well, but symbolic indirection is supposed to look in lexpads as well

[23:47] <masak> so 'my' is not wrong?

[23:49] <TimToady> looks pretty okay to me, assuming the & migrates in to the actual lookup

[23:50] <TimToady> but it has to do that anyway for any compound sigiled name like $foo::bar, which is really foo::<$bar>

[23:51] <masak> *nod*

[23:51] <TimToady> since 'foo' is allowed to be a named lexical scope, seems like it oughta work

[23:52] <TimToady> std: my $foo; UNIT::<$foo>; UNIT::<$bar>

[23:52] <p6eval> std 30546: OUTPUT«===SORRY!===␤Variable UNIT::<$bar> is not predeclared at /tmp/2dWtcRlrKN line 1:␤------> my $foo; UNIT::<$foo>; UNIT::<$bar>⏏<EOL>␤Check failed␤FAILED 00:01 110m␤»

[23:52] <masak> TimToady: did you see my confusion earlier about the lack of warnings from STD about redeclarations involving 'our'?

[23:53] <TimToady> yes, and it's in my todo file

[23:53] <TimToady> which keeps growing... :(

[23:54] <masak> sorry about that.

[23:54] <sorear> STD has bugs?

[23:54] <sorear> I thought STD only has LTAness

[23:54] <masak> *gasp*

[23:54] <TimToady> shh!

[23:55] * sorear wonders how many more bugs STD would have if it bundled a compiler

[23:55] <masak> well, people are working on finding out :)

[23:55] <TimToady> well, I know for a fact that [op] args doesn't actually store the args anywhere :)

[23:56] *** eternaleye left
[23:56] <sorear> incidentally, I wonder how hard it would be to get roles working in NQP-rx

[23:56] <TimToady> and I know that the tie-breaking rules for ambiguous LTM matches probably doesn't take inheritance into account correctly yet

[23:56] <sorear> (you're allowed to use src/metamodel/)

[23:57] <TimToady> and I'm sure if I actually look back at my todo file I could find quite a few more bugs :)

[23:57] <sorear> if we had /that/, it would be fairly simple to have slangs in rakudo

[23:57] <sorear> just think about it!  q:s! lexical macros!  use COBOL!  actually skip the last one

[23:58] <sorear> rakudo: { my sub infix:<¢>($x,$y) { !!! }; }; 2 ¢ 3

[23:58] <p6eval> rakudo 1eef08: OUTPUT«Could not find sub &infix:<¢>␤current instr.: '_block21' pc 29 (EVAL_2:0)␤»

[23:58] <sorear> rakudo: 2 ¢ 3

[23:58] <p6eval> rakudo 1eef08: OUTPUT«Confused at line 11, near "2 \x{a2} 3"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[23:59] <masak> why, when I call `sub foo($p) { return { $p } }` twice, do I get two different closures? when is the cloning done?

[23:59] <sorear> rakudo: sub foo($p) { return { $p }; }; say foo(2).do.WHICH; say foo(3).do.WHICH;

[23:59] <p6eval> rakudo 1eef08: OUTPUT«67766560␤67766560␤»

[23:59] <sorear> What two different closures

