[00:05] <diakopter> sorear: what kind of textual pattern does that grammar express

[00:07] <sorear> diakopter: the first, same as /bc/, the second, same as /<?>/

[00:08] <sorear> but the important part is that $/.<X> == 1 after both

[00:08] <sorear> or, if it happens from a subrule, maybe $/.<a><X> == 1

[00:28] *** wamba joined
[00:29] *** Schwern joined
[00:39] *** tylercurtis joined
[00:43] *** nimiezko left
[01:04] *** Eevee left
[01:06] *** Eevee joined
[01:09] *** wamba left
[01:17] <TimToady> whoever put up http://rosettacode.org/wiki/Numerical_integration#Perl_6 the math is wrong at least three different ways, some of which apparently was already wrong in whichever source you copied, which is unattributed

[01:17] <TimToady> midpoint is wrong one way, the trapezoidal method is wrong at least two ways

[01:18] <TimToady> the perpetrator would appear to be someone from Brazil

[01:25] *** lichtkind left
[01:28] *** azert0x left
[01:33] *** mfollett joined
[01:34] *** hercynium left
[01:37] <TimToady> I suspect it was transcribed from the Java example, which would explain both its verbosity and 2/3 of its wrongness

[01:39] *** ash_ left
[01:57] <allbery_b> heh

[02:00] *** flatwhatson_ joined
[02:01] <flatwhatson_> hi, is there an implementation of perl6 grammars that i can use in perl5?

[02:04] <perigrin> Perl6::Rules, Regexp::Grammar, Parse::RecDescent all come to mind

[02:04] *** rgrau_ left
[02:05] <allbery_b> oh damn.  now I'm gonna be tempted to use them :)

[02:10] *** leprevost joined
[02:20] *** whiteknight left
[02:25] <florz> how would I go about accessing a capture from code within a regex following said capture? as in / (fo*) { here } /

[02:25] <flatwhatson_> Regexp::Grammar and Parse::RecDescent both look quite good! it seems the major difference is that P::RD lets you trigger actions during the parsing process, whereas R::G is more geared towards the perl5-style parse-then-process pattern

[02:25] <flatwhatson_> would that be an accurate assessment?

[02:27] *** patspam joined
[02:27] *** patspam left
[02:32] *** jaldhar joined
[02:33] <perigrin> flatwhatson_: well Regexp::Grammar is based on 5.10+ Regex extensions while Parse::RecDescent implement an entire Recursive Descent parser

[02:33] <perigrin> so at a high level "yes" but that's partly because the implementations are wildly different

[02:35] *** meppl joined
[02:36] *** ash_ joined
[02:37] <flatwhatson_> sure, so it is the 5.10 engine's lack of parse actions that limits Regex::Grammars in that sense

[02:37] <flatwhatson_> but it seems that it would be more performant due to re-using the built-in engine?

[02:38] <flatwhatson_> also i think the syntax would be less likely to give my co-workers aneurysms :)

[02:39] *** b0m1ro left
[02:41] *** mfollett left
[02:41] *** mfollett joined
[02:41] *** ash_ left
[02:42] *** Holy_Cow joined
[02:43] *** Holy_Cow left
[02:47] <sorear> florz: just use $0

[02:51] *** mfollett left
[02:58] <florz> sorear: oh, IC, captures are 0-based now, eh? thx :-)

[03:13] <sorear> yeah

[03:13] <sorear> $0 is short for $/[0], it's zero-based like every other array

[03:18] <florz> sounds sensible - thx :-)

[03:28] *** ioio_1 joined
[03:34] *** meppel joined
[03:37] *** meppl left
[03:38] *** sjn joined
[03:41] *** meppel is now known as meppl

[03:41] *** ioio_1 left
[03:47] *** tom_tsuruhara joined
[03:59] *** Schwern left
[04:06] *** envi^home joined
[04:08] *** envi^home left
[04:10] *** qw3rty joined
[04:12] <qw3rty> hi... i was just introduced to =pod annotations in perl5 today... I found it very interesting, i like its simplicity. The thing is...

[04:12] <qw3rty> does pod annotations evolved too with perl6?

[04:15] <tylercurtis> qw3rty: yes, although I think it's not really nailed down yet due to not being fully implemented.

[04:15] <qw3rty> is there any specs available???

[04:17] <tylercurtis> http://github.com/perl6/specs/raw/master/S26-documentation.pod It's written in Perl 6 Pod.

[04:17] <qw3rty> cool... thanks tylercurtis!

[04:24] *** mfollett joined
[04:29] <mfollett> Is it a bug that you can't call d, f, and such on an object of type Str and instead of to do $str.IO or was it a bug that you could at some point in the past?

[04:33] *** gfx joined
[04:33] <tylercurtis> mfollett: There is another possibility: both were correct. Which is actually the case, I don't know.

[04:35] <mfollett> tylercurtis: that's true.  I'm just seeing a lot of code around that does $str ~~ :f which, at least in * 2010-08, does not seem to be a thing you can do.

[04:35] <mfollett> It would make sense that you could do either way and that way just isn't working at the moment though.

[04:46] *** Chillance left
[05:01] *** REPLeffect left
[05:01] *** qw3rty left
[05:02] <mfollett> Is there an English version of the Perl 6 tutorial that is listed on the perl6 wiki?

[05:09] <sorear> mfollett: AIUI, both were correct *at the respective times*.  We haven't frozen the spec yet.

[05:10] <mfollett> sorear: oh, ok, thanks for the explanation.

[05:13] *** jaldhar left
[05:15] *** jaldhar joined
[05:17] *** REPLeffect joined
[05:18] *** meppl left
[05:27] <TimToady> strings are generally not assumed to be filenames anymore

[05:28] <TimToady> we broken that on purpose

[05:30] <TimToady> broke, even

[05:32] *** Guest23195 joined
[05:32] <mfollett> TimToady:  good to know, thanks

[05:38] <mfollett> I'm kind of playing around with Web.pm, trying to bring it up to speed and it looks like Tags.pm is getting a "Null PMC access in invoke()" with terms like ::Tags{$tag} and ::Tags::EXPORT::DEFAULT{$tag} (for context here is a pastie http://pastie.org/1151608 lines 29 and 32).  What was this originally doing and what is the now way to do it?

[05:42] <shortcircuit> TimToady: http://rosettacode.org/wiki/Template:Incorrect is useful for flagging such errors, if one doesn't want (or can't) fix the code oneself.

[05:43] *** Schwern joined
[05:46] <sorear> looks like an exploitation of alpha'

[05:46] <sorear> s chronic parrot leakage

[05:47] <tylercurtis> What does this mean?

[05:47] <tylercurtis> std: $::

[05:47] <p6eval> std 32123: OUTPUT«ok 00:01 114m␤»

[05:47] <sorear> niecza: $::

[05:47] <p6eval> niecza 10151ff: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-simple variables NYI at /tmp/X7a8zGQzYJ line 1:␤------> [32m$::[33m⏏[31m<EOL>[0m␤Use of uninitialized value in concatenation (.) or string at /home/p6eval/niecza/src/Niecza/Actions.pm line 1388.␤Use of uninitialized value in

[05:47] <p6eval> ..concatenation (.) …

[05:47] <sorear> huh

[05:47] <sorear> I thought I had an 'XXX STD bug workaround' sorry for that

[05:48] <sorear> I don't think it means anything at all

[05:51] <TimToady> shortcircuit: I've found a fourth error in the Perl 6 code; it also comes from the Java I suspect

[05:59] <TimToady> a fifth error, this one in the Perl transcription

[06:04] *** Schwern left
[06:05] *** jaldhar left
[06:06] *** envi^home joined
[06:06] *** Schwern joined
[06:07] *** jaldhar joined
[06:18] <mfollett> How do I dynamically add a sub to a module?

[06:26] <ingy> hi shortcircuit :)

[06:46] <tylercurtis> Good night, #perl6.

[06:46] *** mfollett left
[06:54] *** icwiener joined
[07:09] *** brxue joined
[07:15] *** rhebus joined
[07:16] *** Ross joined
[07:19] *** stepnem left
[07:30] <moritz_> good morning

[07:35] <sorear> hello

[07:38] *** icwiener left
[07:38] *** tylercurtis left
[07:38] *** icwiener joined
[07:39] *** icwiener left
[07:39] *** icwiener joined
[07:50] <rhebus> morning

[07:57] *** leprevost left
[07:57] <TimToady> shortcircuit: okay, added the incorrections, thanks for the pointer

[07:57] *** ashleydev left
[07:58] *** ashleydev joined
[07:58] *** sunnavy joined
[07:59] <TimToady> I believe http://rosettacode.org/wiki/Numerical_integration#Perl_6 is now correct, but I didn't fix the other languages :)

[07:59] *** tadzik joined
[07:59] <Quadrescence> TimToady: you look like weird al, just sayin' as I know it's relevant to the topic

[07:59] <TimToady> I knew that

[07:59] <TimToady> actually, he looks like me

[08:00] <Quadrescence> very true; i dare you to write a perl program which calculates the similarity between two images by making your own novel metric.

[08:00] <TimToady> http://mirrors.develooper.com/perl/history.perl.org/misc/al_wall/

[08:01] <Quadrescence> dammit

[08:03] * moritz_ thought that TimToady stayed away from the more mathematical problems :-)

[08:03] <Quadrescence> moritz_: This is a linguistic problem

[08:04] *** cosimo left
[08:06] <moritz_> Quadrescence: I was talking about the numerical integration rosetta code

[08:06] <Quadrescence> oh >_>

[08:06] <Quadrescence> well numerical integration is linguistic too

[08:07] <Quadrescence> i mean, what /is/ the etymology of 'quadrature' and 'cubature'

[08:07] <TimToady> http://rosettacode.org/wiki/Talk:Numerical_integration has my carpage

[08:08] *** leprevost joined
[08:09] <rhebus> TimToady: won't you get lossage from numerical error in the endpoints?

[08:09] <TimToady> what numerical error?  this is all done in Rats

[08:09] *** araujo joined
[08:10] <TimToady> I don't think the function was complicated enough to get into Nums

[08:10] <rhebus> huh

[08:10] <rhebus> rakudo: say 1, *+0.1 ... 2.0

[08:10] <p6eval> rakudo ce565f: OUTPUT«11.11.21.31.41.51.61.71.81.92␤»

[08:10] <rhebus> rakudo: say ~(1, *+0.1 ... 2.0)

[08:10] <p6eval> rakudo ce565f: OUTPUT«1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2␤»

[08:10] <TimToady> we like our Rats

[08:10] <rhebus> rakudo: say ~1, *+0.1 ... 2.0

[08:10] <tadzik> rakudo: say ~(1, 1.1, 1.2 ... 2.0)

[08:11] <p6eval> rakudo ce565f: OUTPUT«11.11.21.31.41.51.61.71.81.9␤»

[08:11] <p6eval> rakudo ce565f: OUTPUT«1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2␤»

[08:11] <tadzik> no need to closure

[08:11] <rhebus> hmm, so i'm losing the endpoint because i'm stringifying the first term, not the whole sequence?

[08:11] <tadzik> hmm

[08:12] <rhebus> rakudo: say ~1, 1.1, 1.2 ... 2

[08:12] <tadzik> rakudo: say (~1, *+0.1 ... 2.0).perl

[08:12] <p6eval> rakudo ce565f: OUTPUT«Unable to figure out pattern of series␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in main program body at line 22:/tmp/cC1eMHAtxS␤»

[08:12] <p6eval> rakudo ce565f: OUTPUT«("1", 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9)␤»

[08:12] <tadzik> funny

[08:12] <rhebus> tadzik: yeah, it's doing Nums not Rats

[08:13] <TimToady> rakudo: say 1.0e0, 1.1, 1.2 .. 2.0

[08:13] <p6eval> rakudo ce565f: OUTPUT«11.11.2␤»

[08:13] <TimToady> rakudo: say 1.0e0, 1.1, 1.2 ... 2.0

[08:13] <p6eval> rakudo ce565f: OUTPUT«Unable to figure out pattern of series␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in main program body at line 22:/tmp/bBI7jTvNeb␤»

[08:13] <Quadrescence> arithmetic sequences with floats seems like a pretty bad idea

[08:13] <TimToady> rakudo: say 1.0e0, 1.1e0, 1.2e0 ... 2.0

[08:13] <p6eval> rakudo ce565f: OUTPUT«Unable to figure out pattern of series␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in main program body at line 22:/tmp/tt9fvILPsp␤»

[08:14] <TimToady> it can't figure it out because the ratios aren't exactly the same

[08:14] <Quadrescence> ratios or differences?

[08:14] <TimToady> rakudo: say 1.0e0, 1.1e0 ... 2.0 # should work

[08:14] <p6eval> rakudo ce565f: OUTPUT«11.11.21.31.41.51.61.71.81.9␤»

[08:14] <TimToady> work better, I mean

[08:14] <rhebus> heh

[08:15] <TimToady> with three terms, the differences or ratios have to match

[08:15] <rhebus> right

[08:15] <Quadrescence> rakudo: say 1.1e0 - 1.0e0, 1.2e0 - 1.1e0

[08:15] <p6eval> rakudo ce565f: OUTPUT«0.10.0999999999999999␤»

[08:15] <TimToady> it's...probably good that they don't

[08:15] <rhebus> rakudo: say ~1.0e0, 1.1e0, 1.2e0 ... 2.0

[08:15] <p6eval> rakudo ce565f: OUTPUT«Unable to figure out pattern of series␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in main program body at line 22:/tmp/CtYku1hYEZ␤»

[08:16] *** gfx left
[08:16] <TimToady> rakudo: say 1.1 - 1.0,' ', 1.2 - 1.1

[08:16] <p6eval> rakudo ce565f: OUTPUT«0.1 0.1␤»

[08:16] <Quadrescence> rakudo: say 1.1e0 - 1.0e0, ' ', 1.2e0 - 1.1e0

[08:16] <p6eval> rakudo ce565f: OUTPUT«0.1 0.0999999999999999␤»

[08:16] <Quadrescence> rakudo: say (1.1e0 - 1.0e0)-(1.2e0 - 1.1e0)

[08:16] <p6eval> rakudo ce565f: OUTPUT«2.22044604925031e-16␤»

[08:16] <TimToady> rakudo: say (1.1 - 1.0) - (1.2 - 1.1)

[08:17] <p6eval> rakudo ce565f: OUTPUT«0␤»

[08:17] <TimToady> Rats++

[08:17] <rhebus> TimToady: but what if the user passes in a Num for $a or $b? :)

[08:17] <Quadrescence> are those rationals internally? or fixed point?

[08:17] <TimToady> rakudo: say 1.1.perl

[08:17] <p6eval> rakudo ce565f: OUTPUT«11/10␤»

[08:17] <rhebus> rakudo: say (1,1.1 ... 2).perl

[08:17] <p6eval> rakudo ce565f: OUTPUT«(1, 11/10, 6/5, 13/10, 7/5, 3/2, 8/5, 17/10, 9/5, 19/10, 2/1)␤»

[08:18] <Quadrescence> TimToady: have you considered using fixed point arithmetic instead

[08:18] <TimToady> rhebus: we call that DIHWIDT

[08:18] <Quadrescence> rationals just get unwieldy quickly; i just wrote a chapter on this in a book i'm writing not too long ago actually

[08:19] <rhebus> TimToady: it's reasonable to make these things explicit in example code. sub leftrect (&f, Rat $a, Rat $b, Int $n)

[08:20] <TimToady> Quadrescence: see S02:704 on that subject

[08:20] <TimToady> rhebus: yes, wouldn't hurt

[08:21] <rhebus> shall i add it in?

[08:21] <Quadrescence> TimToady: "i just wrote a chapter on this in a book i'm writing not too long ago actually" <-- Is this redundant because I said "just" and "not too long ago"?

[08:22] <Quadrescence> (I don't know how much of a grammarian you are. :)

[08:22] <sorear> TimToady: e0 forces Num now?!

[08:22] <TimToady> also, S02:733 discusses an optimization that makes rats behave a bit like fixed point by being lazy about reducing

[08:22] *** cjk101010 joined
[08:22] <TimToady> sorear: it's been that way for months :)

[08:23] <TimToady> actually, S02:751 discusses the lazy idea

[08:24] <TimToady> Quadrescence: redundancy is good for communication; I'm a linguist, not a grammarian

[08:25] <Quadrescence> TimToady: Did you ever write anything about redundancy in programming (in the linguistic sense, not any datum sense)?

[08:25] <Quadrescence> I very vaguely recall you saying something about this somewhere from years ago.

[08:25] <TimToady> not specifically

[08:25] <TimToady> I've probably mentioned the principle from time to time

[08:27] <TimToady> I should probably go to bed; have to get up in 4.5 hours or so...

[08:29] * TimToady --> SleepState

[08:32] *** masak joined
[08:32] <masak> привет, #perl6!

[08:32] *** rhebus_ joined
[08:33] *** rhebus left
[08:34] *** rhebus_ is now known as rhebus

[08:38] *** tadzik left
[08:39] <rhebus> rakudo: say do $_ for 1..10

[08:39] <p6eval> rakudo ce565f: OUTPUT«12345678910␤»

[08:40] <masak> rakudo: say 1..10

[08:40] <rhebus> hmm, that doesn't work on my local rakudo*

[08:40] <p6eval> rakudo ce565f: OUTPUT«12345678910␤»

[08:40] <masak> star: say do $_ for 1..10

[08:40] <p6eval> star 2010.07: OUTPUT«␤»

[08:40] <masak> confirmed.

[08:44] *** rhebus_ joined
[08:44] *** rhebus left
[08:45] *** rhebus_ is now known as rhebus

[08:45] <rhebus> goddamn wireless goblins

[08:45] *** barney joined
[08:45] <masak> one would have thought that the big Goblin De-wire-ification of 1996 would have led to something good. but no.

[08:46] <rhebus> :)

[08:46] <moritz_> \o

[08:46] <masak> o/

[08:46] <rhebus> moritz_++ # irclog

[08:47] <masak> moritz_: I have another exception for our single wtop so far in http://github.com/moritz/perl6-wtop/blob/master/practices.pod

[08:47] <masak> moritz_: I tend to write $a..$b in some circumstances.

[08:47] <masak> (and $a .. $b in others, but still)

[08:48] <moritz_> masak: agreed. It's not a very hard rule

[08:49] * moritz_ would like to move all S03-operators/series*.t to S03-series/*.t

[08:49] <rhebus> masak, moritz_: could you have a list of pending wtops? it'd be nice to see what you guys are thinking about as well as what you've agreed

[08:49] <masak> moritz_: go right ahead.

[08:50] <rhebus> RFC-style

[08:50] <moritz_> rhebus: no objections

[08:50] <masak> rhebus: heh :) I probably have some, but I can't think of any right now.

[08:50] <masak> at least I don't think I can.

[08:50] * moritz_ too

[08:50] <rhebus> there was one mentioned the other day... don't overuse junctions

[08:50] * moritz_ should be more consequent in writing them down...

[08:50] <rhebus> or something like that

[08:51] <sorear> wtop?

[08:51] <moritz_> right, what rhebus++ said

[08:51] <masak> sorear: well-thought-out practice

[08:51] <masak> sorear: it's a tongue-in-cheek riff off "best practices"

[08:52] <rhebus> i think the best way to arrive at best practices is to write a load of ideas down and criticise the $expletive out of them and see which ones stay standing at the end

[08:53] <masak> hm, maybe.

[08:53] *** Ross left
[08:53] <moritz_> rhebus: I disagree. At the start of a best practise there's code, lots of code

[08:53] <masak> in some cases it's hard to speak about best practices, because much Real Code out there is still shock-full of workarounds.

[08:54] <rhebus> moritz_: i don't understand. at the start of the best practice document, at the start of the best practice design?

[08:54] <masak> making the best practices hard to identify.

[08:54] <masak> rhebus: what moritz_ is getting at is that people talking is worth less than people with lots of experience.

[08:54] <rhebus> masak: quite. The criticism must be based on experience

[08:55] <moritz_> rhebus: at the start of a best practise there should be lots of real-world code that accomplishes real-world tasks

[08:55] *** Ross joined
[08:55] <masak> experience with Perl 6 as well as with programming in general.

[08:55] <rhebus> at the start of the design of a best practice? at the start of the best practice document?

[08:56] <masak> rhebus: I don't understand that question.

[08:56] <moritz_> rhebus: the best practise comes before its document

[08:56] <masak> I think 'at the start' was meant figuratively.

[08:56] <rhebus> what I'm saying is that once a best practice is identified, it must be tested before being accepted generally

[08:57] <rhebus> that testing must involve real code and real experience

[08:58] <rhebus> but, for example, many of damian's pbps were found to be wanting. eg inside-out objects

[08:58] *** flatwhatson_ left
[08:58] <rhebus> (though pbp is an excellent book)

[08:58] <masak> inside-out objects were run over by the Moose train.

[08:58] <sorear> best practices should always come from an examination of already-working code

[08:58] <masak> and they in turn superseded much of Damian's OO book.

[08:59] <moritz_> well, even the people using inside-out objects don't typically don't use the modules recommended in PBP

[08:59] <rhebus> i'm not sure best practices come from examining code, but rather from examining habits

[08:59] *** cosimo joined
[08:59] <moritz_> rhebus: and they come from making mistakes

[08:59] <rhebus> i see best practices as a behavioural thing rather than a purely code-based thing

[09:00] <moritz_> and spotting mistakes in other people's code

[09:00] <rhebus> i agree

[09:01] <masak> nod

[09:01] <masak> it's really about discipline, and disciplines.

[09:01] *** flatwhatson_ joined
[09:01] <rhebus> but you can't know if a proposed best practice is really good until you've tried coding consciously under that best practice

[09:02] <moritz_> that's why I wrote that code comes first

[09:02] <moritz_> or phrased differently, that's another reason

[09:02] <rhebus> well I see it like this: code -> identify problems -> identify best practices -> test bp with more code

[09:03] <masak> it's not a best practice until it has been practiced a lot by people who consider it best.

[09:03] <moritz_> code -> identify problems -> find a solution -> write code with the solution -> discuss -> write up

[09:03] <rhebus> masak: that's what i mean. but those people won't consider it best unless they've been asked to consider it as a possible best practice

[09:03] <rhebus> moritz_: i think more code is needed in the discuss stage

[09:03] <masak> rhebus: right.

[09:04] <moritz_> probably, yes

[09:04] <rhebus> and this process can be iterative -- find problems with the bp -> refine bp to accomodate those problems -> test new bp

[09:04] <rhebus> anyway

[09:05] <masak> a practice that I consider to be very good, but that is non-specific to Perl 6, is "use vertical alignment to favourably expose meaningful patterns in your code"

[09:05] <masak> or, put more simply, "put similar things under each other"

[09:06] <rhebus> that's why i want to see proposed and hypothetical wtops, to try them out and see how they affect my coding

[09:06] <masak> and that underlies my total avoidance of tab characters, because I value vertical alignment.

[09:06] <rhebus> i imagine a number of damian's pbp can be lifted wholesale into perl 6

[09:06] <masak> rhebus: yes. and I code under a number of them daily.

[09:08] <moritz_> can anybody please check if S03-operators/nesting.t or S03-metaops/reverse.t loop under current rakudo?

[09:08] <rhebus> ah here's something i've been wondering: is it ok to use ~~ instead of ==?

[09:08] <moritz_> it loops here, but I have some local patches

[09:10] <masak> rhebus: I consider it sloppy to use ~~ when == is what's intended.

[09:10] <masak> rhebus: but it works, yes.

[09:10] <moritz_> rhebus: IMHO == has the advantage of telling exactly what kind of comparison is wanted

[09:10] <moritz_> so it's better

[09:10] <moritz_> *if* you know that you want numeric comparison

[09:10] <rhebus> yes, supposing that you do

[09:11] <moritz_> if you don't, ~~ is correct

[09:12] *** mikehh left
[09:12] <masak> ~~ casts to the rhs. == casts to numeric. so it depends on what you want.

[09:12] <masak> in the case where the rhs is numeric, they're the same. but == shows intent better.

[09:13] <rhebus> so 1 ~~ "1x" is not the same as 1 == "1x"?

[09:13] <masak> right.

[09:13] <sorear> no current compiler is smart enough to handle ~~ quite well

[09:13] <masak> the former is string comparison.

[09:13] *** wamba joined
[09:13] <moritz_> rakudo handles ~~ pretty well, just not fast

[09:13] <masak> I don't know if I consider it a "best practice" to prefer == whenever that's what's intended, or just common sense :)

[09:14] * moritz_ pushed to perl6-wtop

[09:14] *** wamba left
[09:14] *** wamba joined
[09:15] <masak> for what it's worth, I don't see the value of differentiating practices.pod and rfc.pod.

[09:17] <masak> one sounds more official than the other, but who determines when something is worthy of moving up to practices.pod?

[09:17] <moritz_> good point

[09:17] <moritz_> you're welcome to join them, and remove the comment from README

[09:17] * masak does so

[09:17] <moritz_> masak++

[09:17] <rhebus> well i guess you could sort practices.pod by number of champions, such that more-championed practices rise to the top

[09:18] *** Steppenwolf joined
[09:18] <rhebus> but that will lead to horrible diffs

[09:18] <moritz_> aye

[09:18] <moritz_> I'd rather prefer the presenting software (if any) to do the sorting

[09:18] <rhebus> yeah

[09:22] *** sunnavy left
[09:22] *** ashleydev left
[09:23] *** frew left
[09:24] *** rgrau_ joined
[09:28] *** sunnavy joined
[09:29] *** ashleydev joined
[09:30] *** frew joined
[09:36] <moritz_> rakudo: say ~(1, 3 ... 9)

[09:37] <p6eval> rakudo ce565f: OUTPUT«1 3 5 7 9␤»

[09:42] *** kjeldahl joined
[09:46] *** azert0x joined
[09:47] *** flatwhatson_ left
[09:47] *** flatwhatson_ joined
[09:48] <sorear> S05 specs that regexes return lists of Cursor, but I (and viv) think returning lists of Match makes some more sense

[09:51] <moritz_> http://github.com/rakudo/rakudo/pull/4

[09:58] *** whiteknight joined
[10:03] * masak writes his first given/when in Perl 5

[10:03] *** barney left
[10:08] *** mikehh joined
[10:11] *** baest left
[10:17] <rhebus> moritz_: it seems the spec has changed to remove inexact endpoint dwimmery

[10:17] <rhebus> which would make 'AA' ... 'Z' infinite

[10:18] <masak> works for me. :)

[10:19] <masak> I don't think I'd ever want that to dwim to anything anyway...

[10:19] <rhebus> http://github.com/perl6/specs/commit/692474967ab8535f370d859488da592555e17d8d

[10:20] <rhebus> well, 2,3,*+2 ... sqrt $n would be nice

[10:20] <rhebus> or 1,1,{$^a + $^b} ... 1000

[10:20] <masak> in general, I think incrementing strings is pretty futile. beyond perhaps the very basics, which can be useful.

[10:22] *** tadzik joined
[10:24] *** Schwern left
[10:32] <rhebus> it's not just strings which may want inexact limits

[10:33] <masak> true.

[10:33] <rhebus> but, as the spec shows, you can always use a closure

[10:33] <masak> we've seen arrays in series lately.

[10:33] <rhebus> 2,3,*+2 ... * >= sqrt $n

[10:33] <rhebus> rakudo: [1,2,3].succ.say

[10:33] <p6eval> rakudo ce565f: OUTPUT«Method 'succ' not found for invocant of class 'Array'␤  in main program body at line 22:/tmp/ZOOCh7wH05␤»

[10:34] <rhebus> so it's be something like [1,2,3], [*[1]+1,*[2]+2,*[3]+3] ... *?

[10:36] <rhebus> although it would seem more intutive to me to say 2,3,*+2 ... * < sqrt $n

[10:36] <rhebus> iow, i think the limit should be a while condition, not an until condition

[10:41] <masak> I had the same thought when I read the latest spec changes.

[10:41] <masak> but then I remembered that the rhs of a series operator actually reads like an until condition.

[10:45] <rhebus> right i'm off to the local park fun day

[10:46] <rhebus> bouncy castle and face painting :D

[10:46] <masak> have the appropriate amount of fun :)

[10:47] <rhebus> heh

[10:47] *** rhebus left
[10:59] *** mberends joined
[11:05] <tadzik> masak: what do you think about ripping the make-substitute part out of pls and rolling out something like Module::Builder?

[11:05] <masak> tadzik: that might be a good idea.

[11:05] <masak> pls would still carry of copy of such a module, of course.

[11:06] <tadzik> sure thing

[11:06] <masak> to avoid having dependencies.

[11:06] <tadzik> so is neutro

[11:06] <tadzik> also, I think of using the actual File::Find instead of writing own sub find-files

[11:06] <masak> :)

[11:07] <tadzik> crap, I can't build parrot due to something that looks like an ld bug

[11:07] <tadzik> http://wklej.org/id/387595/

[11:08] *** mberends left
[11:10] <masak> tadzik: I get a 500 error on that paste.

[11:10] <masak> "Unhandled Exception -- An unhandled exception was thrown by the application."

[11:10] <tadzik> oh, I do too

[11:10] <tadzik> whatever, seems like --as-needed in LDFLAGS was breaking it

[11:20] *** nimiezko joined
[11:23] <jnthn> afternoon, 6folk

[11:25] <masak> o/

[11:25] <jnthn> yayitsmasak!

[11:25] * jnthn makes a bacon sarnie

[11:26] <masak> lunch, now there's an idea...

[11:27] *** flatwhatson_ left
[11:27] <jnthn> breakfast for me :P

[11:27] <jnthn> Well...brunch :-)

[11:29] <jnthn> Plan for today: write my talk for Oslo, write a short-term roadmap for my grant, hack some more stuff into 6model. :-)

[11:29] <masak> when's Oslo?

[11:29] <jnthn> Tuesday evening

[11:29] <jnthn> Thus the talk is at the "can't procrastinate it much longer" stage. :-)

[11:30] * masak likes that stage

[11:30] <masak> but beware, the next stage is not as fun :)

[11:30] <masak> not to mention the one after that... :/

[11:31] <masak> or the one after that... :(

[11:33] <masak> Plan for today: continue rescuing my use.perl.org content (it's going surprisingly well, much thanks to Perl 5), maybe design the new blog a bit, pick up Web.pm, have a look at Druid.

[11:35] *** flatwhatson_ joined
[11:36] <tadzik> hmm, I think something like Module::Tools would be nicer. There could be Module::Build, Module::Install, maybe Module::Starter

[11:50] <masak> tadzik++ # doing module infrastructure

[11:51] <tadzik> moritz_++ started some Module::Starter I think

[11:53] *** isBEKaml joined
[11:54] *** sftp left
[11:58] *** am0c joined
[11:59] <masak> aye, and mberends++ had a script in the proto repository before that.

[11:59] <masak> create-new-project

[11:59] <isBEKaml> OHHAI, #perl6! :)

[11:59] <isBEKaml> masak: I was surprised when I received mails about bug reports from proto on github. :)

[12:00] <isBEKaml> masak: not that I mind, though. But I thought proto was so long ago. 

[12:01] <masak> isBEKaml: aye, github's default emailing policy is "email contributors". it's possible to turn those emails off, though. I believe I did for my account.

[12:01] <masak> isBEKaml: some people still seem to use proto. also, the pls branch is still in that repository.

[12:01] <tadzik> I alredy msged mfollet about these

[12:01] <masak> tadzik++

[12:01] <isBEKaml> tadzik++

[12:02] <tadzik> although I had no balls to close the issues with a message 'project abandoned' ;)

[12:02] <isBEKaml> I think it'll be less confusing between proto and pls if we swap branches. 

[12:03] <masak> or put pls into a separate repository.

[12:03] <tadzik> masak++

[12:03] <isBEKaml> I think that would be even more confusing. Consider a new guy, what would he think if he saw two repos by the same author that "purportedly" does the same thing?

[12:04] <isBEKaml> We have to have some way of pointing people towards pls than proto.

[12:04] *** nimiezko left
[12:04] <masak> isBEKaml: would that be more confusing than pls being in the main branch of a repo called 'proto', or less? :)

[12:04] <masak> isBEKaml: I don't like to make decisions for people.

[12:05] <isBEKaml> masak: ah, proto/pls/decision-making dilemma. ;)

[12:05] <tadzik> well, there are now 3 projects doing purportedly the same thing

[12:05] <masak> not when both alternatives still have different benefits over each other, at least.

[12:05] <tadzik> . o O ( troth alternatives )

[12:06] <isBEKaml> tadzik: not all by the same author. :)

[12:06] <tadzik> well, I'm a neutro author and a pls contributor :)

[12:06] <isBEKaml> that's one less confusion. ;)

[12:06] <tadzik> and it's not very confusing to me :)

[12:06] <isBEKaml> maybe because it's you? :)

[12:07] <tadzik> :)

[12:07] <tadzik> maybe

[12:09] <tadzik> hm, Module::Build is actually an ufo-then-pls code stolen and put into a module

[12:12] *** isBEKaml left
[12:14] *** isBEKaml joined
[12:16] <isBEKaml> Module::Build? 

[12:16] <isBEKaml> that makes it quad-alternative. =)

[12:16] <masak> lunch &

[12:16] *** masak left
[12:20] *** zulon joined
[12:22] *** Mowah left
[12:22] <isBEKaml> oh, Module::Builder seems to be only on p5. :|

[12:23] *** jasonmay joined
[12:25] <tadzik> Module::Build can now Module::Build itself

[12:26] <isBEKaml> I think you (intentionally) left out something. 6 on 6, 5 on 5, 5 on 6, 6 on 5? ;)

[12:27] <tadzik> wait, what? :)

[12:27] <tadzik> 6 on 6 if I understand correctly

[12:27] <isBEKaml> perl6 Module::Build can build itself on perl6? ;)

[12:27] <tadzik> yes :)

[12:28] <isBEKaml> tadzik++ 

[12:28] <tadzik> nothing fancy, it's just pls code stolen :)

[12:31] <isBEKaml> tadzik++ # init worked! 

[12:31] <tadzik> :)

[12:33] <tadzik> method install($project --> Result) -- now what is this?

[12:37] <tadzik> I like this: run $command and die() ;)

[12:37] *** stepnem joined
[12:44] *** sftp joined
[12:45] *** am0c left
[12:45] <tadzik> phenny: tell masak http://github.com/masak/proto/blob/pls/proof-of-concept#L284 -- shouldn't it be /\.pm6?$/ ?

[12:45] <phenny> tadzik: I'll pass that on when masak is around.

[12:47] *** aloha left
[12:47] *** bacek left
[12:49] *** zulon left
[12:50] <tadzik> rakudo: my $a = List.new(1, 2, 3); for $a -> $b { say $b.perl } # is this a feature?

[12:50] <p6eval> rakudo ce565f: OUTPUT«(1, 2, 3)␤»

[12:51] <isBEKaml> rakudo: my $a = List.new(1,2,3); say $a; # does this seem different?

[12:51] <p6eval> rakudo ce565f: OUTPUT«1 2 3␤»

[12:51] <tadzik> well, I thought it'd be iterating over a list

[12:51] <isBEKaml> rakudo: my $a = List.new(1,2,3); say $a.perl;

[12:51] <p6eval> rakudo ce565f: OUTPUT«(1, 2, 3)␤»

[12:51] <gfldex> rakudo: my $a = List.new(1,2,3); for $a.list -> $b { say $b.perl };

[12:51] <p6eval> rakudo ce565f: OUTPUT«1␤2␤3␤»

[12:51] <tadzik> hmm

[12:51] <isBEKaml> yes.

[12:51] <tadzik> thanks gfldex 

[12:52] <gfldex> i can even show you why this is a good feature

[12:52] <gfldex> imagin you have a list of lists and you want to iterate over that list

[12:52] <gfldex> then you need to keep the item context in $a -> $b

[12:54] *** sftp left
[12:55] <tadzik> I don't really get it

[12:58] <tadzik> phenny: tell masak http://github.com/masak/proto/blob/pls/proof-of-concept#L172 -- couldn't it just be try-CATCH?

[12:58] <phenny> tadzik: I'll pass that on when masak is around.

[12:59] *** sftp joined
[13:10] *** orafu left
[13:10] *** orafu joined
[13:13] *** Mowah joined
[13:13] *** zulon joined
[13:13] *** redicaps joined
[13:15] *** Patterner left
[13:15] *** redicaps left
[13:17] *** envi^home left
[13:17] <tadzik> Nominal type check failed for parameter '$from'; expected Str but got File::Find::Result instead

[13:17] *** icwiener left
[13:17] <tadzik> shouldn't it be ok if File::Find::Result is Cool and has a .Str method?

[13:18] *** Psyche^ joined
[13:18] *** Psyche^ is now known as Patterner

[13:19] *** Mowah left
[13:19] *** icwiener joined
[13:20] *** envi^home joined
[13:23] *** Mowah joined
[13:24] <moritz_> no, Cool !~~ Str

[13:24] <moritz_> it's the the other way round

[13:25] <jnthn> tadzik: If you want to take anything and coerce it to a string, use "$from as Str" instead.

[13:26] <tadzik> sounds safer than Str $from

[13:26] <tadzik> more versatile

[13:26] <jnthn> Depends what kinda safetly you want. ;-)

[13:26] <tadzik> and less strict

[13:26] <jnthn> Right. :-)

[13:27] <tadzik> true :)

[13:27] <moritz_> subset Stringable of Any where .can('Str');

[13:29] <tadzik> huh, I just did rm -r ./\~

[13:29] <tadzik> I'm still scared stiff :)

[13:30] <moritz_> accidentally create a file with non-globbed filename?

[13:31] *** jhuni left
[13:32] <tadzik> yeah

[13:32] <tadzik> well, I created ~ in a directory

[13:34] *** zulon left
[13:37] *** rainerschuster joined
[13:37] *** brxue left
[13:51] *** tadzik left
[13:57] *** masak joined
[13:58] <masak> tadzik: ooh, reading pls? nice!

[13:58] <phenny> masak: 12:45Z <tadzik> tell masak http://github.com/masak/proto/blob/pls/proof-of-concept#L284 -- shouldn't it be /\.pm6?$/ ?

[13:58] <phenny> masak: 12:58Z <tadzik> tell masak http://github.com/masak/proto/blob/pls/proof-of-concept#L172 -- couldn't it just be try-CATCH?

[13:58] <masak> first question: seems it should indeed. good catch. fixing.

[13:59] <masak> second question: obviously you don't have the deep mistrust of try/CATCH in Rakudo that I've built up. :) that's good, I guess.

[13:59] <masak> either it still doesn't work, or my mistrust is out-of-date.

[14:03] *** mberends joined
[14:04] *** Chillance joined
[14:04] <masak> mberends: ping

[14:05] <mberends> masak: pong

[14:05] <phenny> mberends: 10 Sep 12:11Z <masak> tell mberends that if he plans to submit OSDC.fr talks: deadline falls today.

[14:05] <masak> mberends: what phenny said.

[14:05] <mberends> oops

[14:06] <masak> maybe not too late still.

[14:08] <mberends> I saw jnthn's talks, and planned to discuss other talk ideas before making a submission, and then got sidetracked by $work :(

[14:08] <mberends> yes, quite possibly

[14:08] <masak> hurry hurry

[14:09] <mberends> think think, what would complement the existing schedule?

[14:10] <jnthn> Something at 90 degrees to it?

[14:10] <jnthn> ;-)

[14:10] <masak> |o_

[14:11] <dalek> rakudo: 62e168d | patrickas++ | src/core/operators.pm:

[14:11] <dalek> rakudo:  Starting to implement new series spec

[14:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/62e168d68b94711f97786536efce8efe5fa54c3f

[14:11] <dalek> rakudo: 953705a | patrickas++ | src/core/operators.pm:

[14:11] <dalek> rakudo: There is no more need to check of the wrong side

[14:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/953705acda85f522cd95b9edfcdce0708c1fe7d9

[14:11] <dalek> rakudo: 6483439 | patrickas++ | src/core/operators.pm:

[14:11] <dalek> rakudo: Simplify the limit-reached code since geometric series don't require use of abs() anymore

[14:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/64834397cc2ea627f0008b63b581585ce7eccff1

[14:11] *** dalek left
[14:11] <masak> rakudo: my class Str {}; say 42.Str ~~ Str

[14:11] <p6eval> rakudo ce565f: OUTPUT«0␤»

[14:11] <masak> :)

[14:12] <jnthn> :-)

[14:12] *** mberends_ joined
[14:12] *** dalek joined
[14:12] *** ChanServ sets mode: +v dalek

[14:12] <masak> mberends_: are you mberends' evil twin?

[14:12] <jnthn> Or just the complement to mberends| ;)

[14:12] <masak> :D

[14:13] <jnthn> I'm sure mberends++ can submit a talk that gets the right angle on Perl 6.

[14:13] * masak groans appreciatively

[14:13] *** mberends left
[14:13] <moritz_> patrikas++ # the big series hacker!

[14:13] <masak> jnthn: sometimes you manage to angle your puns just right!

[14:14] <jnthn> masak: Thanks for the complement.

[14:14] <masak> LOL

[14:14] *** mberends_ is now known as mberends

[14:16] <flussence> (scrollback from ~17h ago): It'd be nice to have some sort of .POD method on functions for that.

[14:17] <masak> flussence: that's spec'd. not implemented, though. I plan to.

[14:17] <jnthn> It's .WHY speculated to be for that?

[14:17] <dalek> rakudo: fb4feba | moritz++ | t/spectest.data:

[14:17] <dalek> rakudo: track test file rename

[14:17] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/fb4feba08f8994651b44b2d5d896df7d9417c502

[14:17] <jnthn> *Isn't

[14:17] <moritz_> it is

[14:20] <flussence> ooh, .WHY looks a lot more useful than I imagined.

[14:21] <masak> \o/

[14:25] * flussence now appreciates the value of docs bundled with the language, after trying to write javascript without a net connection

[14:26] <masak> programming without a net connection? curious.

[14:26] <masak> and javascript of all languages, to boot :)

[14:27] *** wamba left
[14:28] <flussence> stuck on a boat for 3 hours, and perl6 isn't much fun on a slow netbook :(

[14:28] *** xinming left
[14:28] <flussence> (yet)

[14:29] <masak> Rakudo has the slow feature built in right now. no need for a netbook to add that feature :)

[14:29] *** xinming joined
[14:31] <flussence> OTOH, the slow hardware gives me a reason to write faster code :)

[14:31] *** meppl joined
[14:31] <masak> my thinking too

[14:32] *** tom_tsuruhara left
[14:33] <masak> phenny: tell tadzik fixed, thanks! http://github.com/masak/proto/commit/8599dfe66200e79c2eea1b67ef9eae5f72a2a7aa

[14:33] <phenny> masak: I'll pass that on when tadzik is around.

[14:35] *** takadonet joined
[14:35] *** amkrankruleuen joined
[14:35] <amkrankruleuen> Hello.

[14:35] <masak> amkrankruleuen! \o/

[14:35] <moritz_> oh hai

[14:40] *** cognominal left
[14:41] *** rainerschuster left
[14:41] <dalek> rakudo: a93dcb6 | moritz++ | / (2 files):

[14:41] <dalek> rakudo: [docs] update ChangeLog

[14:41] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a93dcb688d612f4a972ad676183f9ac07f1d266f

[14:42] *** cognominal joined
[14:45] <moritz_> rakudo: / \# /

[14:45] <p6eval> rakudo ce565f:  ( no output )

[14:45] <moritz_> std: / \# /

[14:45] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Regex not terminated at /tmp/FMr5XK2dYm line 1 (EOF):␤------> [32m/ \# /[33m⏏[31m<EOL>[0m␤    expecting quantifier␤Parse failed␤FAILED 00:01 116m␤»

[14:46] <masak> huh.

[14:46] <moritz_> TimToady: LTA parse error message above

[14:46] <masak> LTA parse, I'd say.

[14:46] <moritz_> TimToady: should trigger the "No unspace allowed" from line 4725

[14:46] <moritz_> std: / /

[14:46] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null regex not allowed at /tmp/Axk3n03C7Z line 1:␤------> [32m/ /[33m⏏[31m<EOL>[0m␤Check failed␤FAILED 00:01 114m␤»

[14:46] <moritz_> rakudo: / /

[14:47] <p6eval> rakudo ce565f: OUTPUT«===SORRY!===␤Null regex not allowed at line 22, near ""␤»

[14:47] <moritz_> rakudo: / & /

[14:47] <p6eval> rakudo ce565f:  ( no output )

[14:47] <moritz_> bug

[14:47] <moritz_> rakudo: / | /

[14:47] <p6eval> rakudo ce565f:  ( no output )

[14:47] <moritz_> same bug

[14:48] <shortcircuit> TimToady: I was up later than usual last night. :)

[14:48] <moritz_> rakudo: / : /

[14:48] <p6eval> rakudo ce565f: OUTPUT«===SORRY!===␤Method 'backtrack' not found for invocant of class 'Integer'␤»

[14:49] <moritz_> LTA error

[14:49] *** ash_ joined
[14:49] <jnthn> std: / : /

[14:49] <p6eval> std 32123: OUTPUT«ok 00:01 116m␤»

[14:49] <moritz_> that's broken too

[14:50] <jnthn> LTE error

[14:50] <moritz_> should say "Backtrack control ':' does not seem to have a preceding atom to control"

[14:51] *** Getty left
[14:53] <isBEKaml> rakudo: / #`{ / # just curious

[14:53] <p6eval> rakudo ce565f: OUTPUT«(timeout)»

[14:53] <isBEKaml> std: / #`{ /

[14:54] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Couldn't find terminator } at /tmp/n1sjPtydK7 line 1 (EOF):␤------> [32m/ #`{ /[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 114m␤»

[14:59] <shortcircuit> TimToady: Wow; didn't expect that you'd do that much analysis on each example. Thanks. :)

[15:00] * shortcircuit also went in added a test output spec consisting of a couple functions, so something like that doesn't happen again on that page.

[15:00] *** takadonet left
[15:00] <x3nU> well

[15:00] <x3nU> i have created rakudo star installer for windows

[15:01] <shortcircuit> whups. The 'later than usual' was intended for a different channel/person target.

[15:03] *** macroron joined
[15:03] *** amkrankruleuen left
[15:03] *** patspam joined
[15:08] *** whiteknight left
[15:09] <moritz_> std: /a{1,3}/

[15:09] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of {1,3} as general quantifier; in Perl 6 please use X**1..3 at /tmp/VUiqpioGUF line 1:␤------> [32m/a{1,3}[33m⏏[31m/[0m␤Check failed␤FAILED 00:01 116m␤»

[15:09] <x3nU> http://xenu.pl/rakudo-star.2010.08.exe

[15:09] <moritz_> rakudo: /a{1,3}/

[15:09] <p6eval> rakudo fb4feb:  ( no output )

[15:09] <moritz_> x3nU++

[15:11] <masak> moritz_: known, RT'd?

[15:12] *** The_Ghost joined
[15:12] <moritz_> masak: I'm fixing the a{1,3} thing now (as good as currently possiblein nqq-rx), I don't think the others are RT'ed

[15:13] * masak backlogs and submits what he can sift out

[15:13] *** The_Ghost left
[15:13] <moritz_> I think a general "LTA regex parsing errors" ticket wouldn't hurt

[15:15] <masak> std: / & /

[15:15] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null pattern not allowed at /tmp/jD4FwUztCd line 1:␤------> [32m/ & [33m⏏[31m/[0m␤    expecting quantifier␤Parse failed␤FAILED 00:02 115m␤»

[15:18] *** b0m1ro joined
[15:19] *** tylercurtis joined
[15:21] *** isBEKaml left
[15:21] <dalek> nqp-rx: 184e828 | moritz++ | src/Regex/P6Regex/Grammar.pm:

[15:21] <dalek> nqp-rx: catch p5 gneral quantifiers

[15:21] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/184e828e137ae5813a895f39a63c547204fd9a5e

[15:28] <shortcircuit> TimToady: Question regarding your P6 code: http://rosettacode.org/mw/index.php?title=Talk:Y_combinator&diff=90857&oldid=prev

[15:30] *** takadonet joined
[15:33] *** Chillance left
[15:37] *** b0m1ro left
[15:38] *** ruoso joined
[15:40] *** Ross left
[15:40] *** Ross joined
[15:43] *** patspam left
[15:48] *** mikehh left
[15:51] *** cjk101010 left
[16:05] *** jettero left
[16:05] *** thundergnat joined
[16:06] *** jettero joined
[16:06] *** jettero left
[16:06] *** jettero joined
[16:08] <thundergnat> rakudo: my $x; $x = $x ?& 1; say $x;

[16:08] <p6eval> rakudo fb4feb: OUTPUT«0␤»

[16:08] <thundergnat> rakudo: my $x; $x ?&= 1; say $x;

[16:09] <p6eval> rakudo fb4feb: OUTPUT«No applicable candidates found to dispatch to for 'infix:<?&>'. Available candidates are:␤:(Any $a, Any $b)␤␤  in main program body at line 1␤»

[16:09] <thundergnat> hmmm.

[16:09] <thundergnat> known bug?

[16:09] <thundergnat> or does that fall under "don't do that"?

[16:09] <tylercurtis> rakudo: my $x; $x [?&]= 1;  say $x;

[16:09] <p6eval> rakudo fb4feb: OUTPUT«===SORRY!===␤Confused at line 22, near "$x [?&]= 1"␤»

[16:09] *** Steppenwolf left
[16:10] <tylercurtis> std: my $x; $x [?&]= 1;  say $x;

[16:10] <p6eval> std 32123: OUTPUT«ok 00:01 118m␤»

[16:10] <tylercurtis> The former is probably a bug. The latter almost certainly is.

[16:10] <thundergnat> Its kind of a degenerate case

[16:11] <pmichaud> good morning, #perl6

[16:12] <jnthn> morning, pmichaud 

[16:14] <masak> morning, pm!

[16:14] <masak> I'm getting a build fail on latest Parrot and latest Rakudo: "FATAL ERROR: Duplicated VTABLE function: get_pmc_keyed_int at /usr/local/lib/parrot/2.7.0-devel/tools/build/../lib/Parrot/Pmc2c/PMC.pm line 74."

[16:14] <masak> should I downgrade my Parrot?

[16:15] <masak> PARROT_REVISION says 48909, I has 48934.

[16:15] <masak> (just to be clear, latest Parrot builds fine; latest Rakudo on top of it doesn't.)

[16:17] <pmichaud> we might have a PMC that has multiple get_pmc_keyed_int declarations.

[16:17] <pmichaud> one of the recent Parrot changes declares that an error.

[16:17] <x3nU> also i wonder can someone put my installer on rakudo.org? ;f

[16:18] <pmichaud> in fact, I'm wondering if that should've required a deprecation cycle

[16:19] <tylercurtis> Compilers detecting bugs in supplied code is a good thing, no?

[16:20] *** mfollett joined
[16:20] <tylercurtis> By the way, http://github.com/rakudo/rakudo/blob/master/src/pmc/perl6multisub.pmc#L926 and http://github.com/rakudo/rakudo/blob/master/src/pmc/perl6multisub.pmc#L1112

[16:20] <pmichaud> tylercurtis: sure, but making code that previously worked turn into non-working code isn't.

[16:23] *** rhebus joined
[16:25] *** takadonet left
[16:25] <tylercurtis> pmichaud: A warning might be better than a fatal error (at least for a deprecation cycle). But I'd consider pmc2c silently ignoring parts of the PMC code a bug.

[16:26] <pmichaud> sure, I consider that a bug also.

[16:26] <pmichaud> but part of the purpose of Parrot declaring "supported releases" and a deprecation cycle is so that HLL and library authors supposedly won't have to deal with these sorts of failures.

[16:26] <pmichaud> at least, that's what I understand the purpose to be.

[16:27] *** takadonet joined
[16:27] *** tadzik joined
[16:27] <tylercurtis> True.

[16:27] <tadzik> oh hai

[16:27] <phenny> tadzik: 14:33Z <masak> tell tadzik fixed, thanks! http://github.com/masak/proto/commit/8599dfe66200e79c2eea1b67ef9eae5f72a2a7aa

[16:27] <masak> o/

[16:27] <pmichaud> a warning would be great.  failing altogether isn't.

[16:27] <tadzik> masak: also, Module::Tools are mostly working

[16:28] <masak> \o/

[16:28] <tadzik> except when they don't

[16:30] *** jferrero joined
[16:31] <rhebus> rakudo: say %(1,2).WHAT

[16:32] <p6eval> rakudo fb4feb: OUTPUT«Hash()␤»

[16:32] <rhebus> star: say %(1,2).WHAT

[16:32] <p6eval> star 2010.07:  ( no output )

[16:32] *** mfollett left
[16:33] <tadzik> http://github.com/tadzik/perl6-File-Tools/blob/master/lib/File/Copy.pm can you see anything painfully slow in here?

[16:33] <tadzik> it takes ages to copy anything

[16:34] *** sjn left
[16:34] <pmichaud> tadzik: there are some pathological cases in I/O in general (both in Parrot and in Rakudo)

[16:34] <pmichaud> I agree that should not be slow.  It's probably worth tracking down a bit to see why it's slow.

[16:35] *** mfollett joined
[16:37] <tadzik> sometimes it's immediate, sometimes takes around 25 seconds to copy a single file

[16:37] <tadzik> decreasing over time

[16:37] <pmichaud> I'm thinking it may be GC again.

[16:37] <pmichaud> but I can run a test to find out.

[16:38] *** Axius joined
[16:38] <tadzik> oh, maybe it's old .pir lying around confusing Parrot and Rakudo, let's see

[16:38] <ash_> tadzik: you could cheat with your cp function and call cp (if its a unixy system) 

[16:38] <tadzik> well, no

[16:38] <tadzik> ash_: that's what I want to avoid

[16:39] <tadzik> moreover, I'm worried about my child being so painfully slow

[16:39] <tadzik> while being, well, quite straightforward

[16:39] <ash_> ah, well, i'd do some profiling then 

[16:40] <tadzik> http://gist.github.com/575338 that's the code

[16:40] *** kjeldahl_ joined
[16:40] <tadzik> http://gist.github.com/575340

[16:40] <tadzik> here's the result ↑ the copying time is approaching to 0 seconds, yet it's horrible at the beginning

[16:41] <tadzik> ash_: how do I do profiling on Rakudo?

[16:43] *** kjeldahl left
[16:44] <tadzik> alright, it's not the matter of "the first file", it's about the size I think

[16:44] <tadzik> ...but _that_ slow?

[16:45] <tadzik> these are just 13 iterations

[16:45] *** mfollett left
[16:49] <ash_> in theory, you could do parrot -R profiling but that currently doesn't work in rakudo, so.... i am not sure what the best way of detecting the slow part is 

[16:49] <tadzik> rakudo: my $t = 5555555; say "{time - $t} seconds passed" # what?

[16:49] <p6eval> rakudo fb4feb: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in 'time' at line 5933:CORE.setting␤  in main program body at line 22:/tmp/pbmFAlpOzT␤»

[16:53] <ash_> rakudo: say time;

[16:53] <p6eval> rakudo fb4feb: OUTPUT«1284222665␤»

[16:53] <ash_> rakudo: my $t = time; say $t - 1;

[16:53] <p6eval> rakudo fb4feb: OUTPUT«1284222679␤»

[16:53] <ash_> rakudo: say "{time}"

[16:53] <p6eval> rakudo fb4feb: OUTPUT«1284222687␤»

[16:53] <ash_> rakudo: say "{time - 1}"

[16:53] <p6eval> rakudo fb4feb: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in 'time' at line 5933:CORE.setting␤  in main program body at line 22:/tmp/7ZHhrTveTq␤»

[16:53] <ash_> thats weird

[16:54] <ash_> must be a bug with interpolating functions 

[16:55] <tadzik> I sense so

[16:56] <ash_> rakudo: sub f { 'foo' }; sub g($a) { 'g' ~ $a }; say "{f}"; say "{g 1}"

[16:56] <p6eval> rakudo a93dcb: OUTPUT«foo␤g1␤»

[16:56] <ash_> rakudo: sub f { 'foo' }; sub g($a) { 'g' ~ $a }; say "{f ~ 1}"; say "{g 1}"

[16:57] <p6eval> rakudo a93dcb: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in 'f' at line 22:/tmp/jxxAhP2YWx␤  in main program body at line 22:/tmp/jxxAhP2YWx␤»

[16:57] <ash_> weird

[16:57] <ash_> i don't get it but /shrug

[16:57] * ash_ submits rakudo bug

[16:59] <rhebus> ash_: is it interpreting "f ~ 1" as "f (~1)"?

[16:59] *** timbunce joined
[16:59] <rhebus> and is that correct with no parameter list?

[16:59] <ash_> std: sub f { ... }; say "{f + 1}"

[16:59] <p6eval> std 32123: OUTPUT«ok 00:01 116m␤»

[16:59] <tadzik> oh, std

[16:59] <rhebus> kk

[17:00] <ash_> rhebus: that seems possible

[17:00] <tadzik> std: my $t = 5555555; say "{time - $t} seconds passed"

[17:00] <p6eval> std 32123: OUTPUT«ok 00:01 118m␤»

[17:00] <tadzik> lol bug

[17:00] <ash_> that could be how its interpreting it 

[17:00] <tadzik> rakudo: my $t = 5555555; say "{time() - $t} seconds passed"

[17:00] <p6eval> rakudo a93dcb: OUTPUT«1278667546 seconds passed␤»

[17:00] <ash_> yup thats it

[17:01] <rhebus> rakudo: sub f () { 'foo' }; sub g($a) { 'g' ~ $a }; say "{f ~ 1}"; say "{g 1}"

[17:01] <p6eval> rakudo a93dcb: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in 'f' at line 22:/tmp/FSQLthDu_t␤  in main program body at line 22:/tmp/FSQLthDu_t␤»

[17:01] *** Axius left
[17:01] <rhebus> rakudo: sub f () { 'foo' }; sub g($a) { 'g' ~ $a }; say "{f() ~ 1}"; say "{g 1}"

[17:01] <p6eval> rakudo a93dcb: OUTPUT«foo1␤g1␤»

[17:02] <tadzik> http://wklej.org/id/387712/ -- yep, it's about the size

[17:02] *** Chillance joined
[17:04] *** Axius joined
[17:04] <ash_> that probably has something to do with parrot's GC system

[17:05] <tadzik> weird

[17:06] <ash_> parrots GC is a bit weird at times

[17:06] <sorear> good * #perl6

[17:07] <tadzik> hello

[17:07] *** thundergnat left
[17:10] *** patch left
[17:24] *** dju left
[17:25] * jnthn afk for noms

[17:28] <pmichaud> tadzik: it looks to me like it's taking about 1 sec per 4k block

[17:28] <pmichaud> let's see if I can get something similar here

[17:28] <tadzik> I just thought about trying to increase the amount per iteration

[17:28] <pmichaud> if it's gc-related, I think that will make it worse, no better.  Ironically.

[17:28] <pmichaud> *not

[17:29] <tadzik> I'm trying 2048 now...

[17:30] <tadzik> no significant difference

[17:32] <tadzik> alike with 8192. Bah

[17:32] <pmichaud> rebuilding latest parrot here

[17:32] <pmichaud> try 512, ooc

[17:32] <tadzik> building with 128, just ooc

[17:32] <pmichaud> wfm

[17:32] <tadzik> I like edge cases for comparing

[17:32] <pmichaud> try 1.  :-P

[17:32] <pmichaud> try 0. :-)

[17:32] <tadzik> :D

[17:33] <pmichaud> at 128 I think we might get swamped by the method call overhead, though :-|

[17:33] <tadzik> the lack of any difference is making me wonder whether it actually makes the changes in pirs

[17:34] <pmichaud> well, I'm writing a baseline PIR version now so we can do a base measurement.

[17:34] <tadzik> great

[17:35] <pmichaud> oh, ouch ouch ouch

[17:36] <pmichaud> http://github.com/rakudo/rakudo/blob/master/src/core/IO.pm#L72    # here's why it's slow

[17:36] <pmichaud> that's.... not going to work in the long run.

[17:36] <tadzik> where exactly?

[17:36] <pmichaud> or even in the medium run.

[17:36] <pmichaud> lines 72-97

[17:37] <tadzik> well, that I can see :)

[17:37] <dalek> rakudo: 085920f | pmichaud++ | src/pmc/perl6multisub.pmc:

[17:37] <dalek> rakudo: Remove extra (unused) VTABLE get_pmc_keyed_int from perl6multisub.  Discovered by NotFound++ (Parrot r48932) and masak++.

[17:37] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/085920ffaabb521b63a7b0c02767fe84720c0e71

[17:37] <pmichaud> after reading a 4k chunk, it pushes them one-byte-at-a-time into a ByteBuffer

[17:37] <pmichaud> that's going to be... slow.

[17:37] <tadzik> ouch

[17:38] <tadzik> (maybe inserting 1 instead of 128 wouldn't be a bad idea after all :P)

[17:38] <pmichaud> oh, it's worse!

[17:38] *** Axius left
[17:38] <pmichaud> it pushes them one-byte-at-a-time into an RPA!

[17:38] *** hudnix left
[17:38] <lue> ohai o/

[17:38] <masak> pmichaud: o.O

[17:39] *** hudnix joined
[17:39] <tadzik> RPA?

[17:39] <pmichaud> ResizablePMCArray

[17:39] <pmichaud> which means it creates a new PMC for each element pushed

[17:39] <tadzik> aw snap

[17:39] <lue> O.o

[17:40] <pmichaud> i.e., one PMC per byte read.

[17:41] <tadzik> btw, what's that tool extracting POD from C source?

[17:41] * masak sobs softly

[17:41] *** macroron left
[17:42] <pmichaud> masak: this code was/is working around Parrot's difficulty in reading binary strings, or ... ?

[17:42] <masak> oh! we're talking about *my* code!? :/

[17:42] <pmichaud> oh, is it not yours?

[17:43] <pmichaud> I didn't look to see the authorship.

[17:43] <masak> it's Buf-related?

[17:43] <pmichaud> I just assume buf-related item..... yes

[17:43] <masak> probably mine, then.

[17:43] <pmichaud> at least, I'm guessing it is, since read() is returning a buf

[17:43] * masak checks

[17:43] <pmichaud> let me be more precise.

[17:43] <pmichaud> http://github.com/rakudo/rakudo/commit/692aa15f2538858028934b8e26910199cc5fdc53   # looks like it

[17:44] <masak> aye.

[17:44] <pmichaud> maybe that was that other "masak++"  :)

[17:44] <masak> ok, so *all* conversion to and from Buf is done byte-by-byte right now.

[17:45] <masak> it's not ideal by far.

[17:45] *** leprevost left
[17:45] * rhebus grabs a pitchfork

[17:45] <pmichaud> agreed, and no blame for it afaic

[17:45] *** leprevost joined
[17:45] <pmichaud> buf in parrot is... tricky

[17:45] <masak> it's -Oworks rather than -Ospeed :)

[17:45] <pmichaud> it's following in the footsteps of GGE :)

[17:45] <rhebus> optimising is easy if it doesn't have to work :)

[17:45] <masak> *lol*

[17:46] <pmichaud> it's the GIO subsystem :)

[17:46] <lue> .oO(* in parrot is tricky)

[17:46] <pmichaud> actually, * wasn't too bad :)

[17:46] <masak> not sure there are tests for read(). checking.

[17:47] <pmichaud> I think I'd like to see Buf implemented using a ResizableIntegerArray

[17:47] <lue> .oO[ * wasn't meant literally :) ]

[17:50] <masak> pmichaud: I can look into that.

[17:50] <rhebus> i'm implementing a graph class, which has a method add-edges(), which I want to accept a list of Pair. A Pair 'a' => 'b' represents a line from vertex 'a' to vertex 'b'

[17:50] <masak> rhebus: go on. :)

[17:51] <rhebus> however, a Pair with a certain key gets interpreted as a named parameter. eg: sub add-edges (*@_ of Pair) { ... } foo(1 => 2) is ok, but foo (a => 'b') breaks with "Unexpected named parameter 'a' passed

[17:51] <masak> rhebus: yes.

[17:51] <rhebus> i don't want to interpret lines as named parameters, because that's not what they are

[17:52] <masak> rhebus: to pass a pair, you need either 'a' => 'b' or (a => 'b')

[17:52] <rhebus> er, any suggestions on which part of my design needs to give?

[17:52] <rhebus> masak: i see

[17:52] <masak> rhebus: I've also experienced friction with that part of Perl 6 parameter passing.

[17:52] <rhebus> :/

[17:52] <masak> rhebus: what you can do (which I don't necessarily recommend) is add a slurpy hash to the signature.

[17:53] <masak> rhebus: that would slurp up all the occasional named params, and you can add them post facto to the array.

[17:53] <rhebus> masak: that fails for foo (a => 'b', a => 'c')

[17:53] <masak> not per the spec.

[17:53] <masak> maybe per Rakudo.

[17:53] <rhebus> really?

[17:53] * masak checks

[17:54] <rhebus> what does it mean then? what does %^a<a> give me in that case?

[17:54] <masak> S06:745

[17:58] <rhebus> S06:753 confirms lossage

[17:59] <rhebus> rakudo: sub foo(*%p) { say %p.perl }; foo (a => 'b', a => 'c')

[17:59] <p6eval> rakudo a93dcb: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in 'foo' at line 22:/tmp/crSDJW6xjj␤  in main program body at line 22:/tmp/crSDJW6xjj␤»

[17:59] <masak> hm.

[17:59] <rhebus> i'll go with the literal Pair syntax

[18:00] <masak> nod

[18:00] <masak> rakudo: sub foo(*%p) { say %p.perl }; foo(a => 'b', a => 'c')

[18:00] <p6eval> rakudo a93dcb: OUTPUT«duplicate named argument in call␤  in main program body at line 2:/tmp/ebJMPKp82_␤»

[18:00] * masak submits rakudobug

[18:01] <masak> rakudo: sub foo(*%p) { say %p.perl }; my %h = a => 'b'; foo(|%h, a => 'c')

[18:01] <p6eval> rakudo a93dcb: OUTPUT«duplicate named argument in call␤  in main program body at line 22:/tmp/N6sXSOf5hR␤»

[18:01] <rhebus> i literally can't see the difference between mine and yours there

[18:01] <pmichaud> the potential problem with slurping things into a hash is that ordering gets lost

[18:01] <masak> rhebus: so here's the thing about function calls and whitespace.

[18:02] <rhebus> in my case, ordering doesn't really matter

[18:02] <masak> rhebus: 'foo(' and 'foo (' mean different things

[18:02] <rhebus> masak: :O

[18:02] <rhebus> Ö

[18:02] <pmichaud> the other way to avoid named parameters is to use an extra level of parens around the entire list

[18:02] <masak> rhebus: general theme through all of Perl 6.

[18:02] <pmichaud> foo(a=>1, b=>2)   # named arguments

[18:02] <masak> rhebus: they snuck a little whitespace significance in there... :)

[18:02] <pmichaud> foo((a=>1, b=>2))   # list of pairs

[18:03] <masak> right and 'foo (' means the latter.

[18:03] *** envi^home left
[18:04] <rhebus> hmm, my list of things i don't quite like about perl 6 is growing :(

[18:04] <rhebus> it's got past the honeymoon period

[18:04] <masak> :)

[18:05] <masak> rhebus: I might be able to argue that that particular significant whitespace thing is part of the whole two-terms-in-a-row reasoning.

[18:05] <pmichaud> I've not been happy about the   a=>1   named/pair dichotomy either, but so far the cures aren't much better than the disease.

[18:05] <masak> and two-terms-in-a-row is the whole *key* to understanding Perl 6 parsing.

[18:05] <rhebus> two-terms-in-a-row?

[18:05] <masak> pmichaud: agreed.

[18:05] <masak> rhebus: ok, so here's the thing about terms and operators.

[18:05] <masak> rhebus: to a first approximation, code looks like this: term op term op term

[18:06] <rhebus> with you so far

[18:06] <masak> that's with infix operators; prefixes and postfixes work a little different. but not much.

[18:06] <sorear> TTIAR has been in Perl since 1.0

[18:06] <masak> if you find, term term or op op, it means something special is happening.

[18:06] <sorear> I'm not sure what significant whitespace has to do with it

[18:06] <masak> for example that something is wrong.

[18:07] <masak> sorear: I'm building up to it.

[18:07] <masak> at some point in the evolution of Perl 6, it was decided that postfix operators really can't have any whitespace before them.

[18:08] <masak> because then they're suddenly ambiguous with infix operators.

[18:08] <masak> so nowadays, the '+' in 'foo+' is a postifx operator if such an operator is defined in the current scope.

[18:08] <masak> only otherwise it's an infix operator.

[18:08] *** patspam joined
[18:09] <pmichaud> or prefix operator

[18:09] <pmichaud> since prefix also occurs in "op" position.

[18:09] <pmichaud> oh, wait

[18:09] <masak> no.

[18:09] <pmichaud> in term position

[18:09] <pmichaud> never mind.

[18:09] <masak> please ignore pmichaud :)

[18:09] <pmichaud> no, don't ignore me entirely

[18:09] <pmichaud> because    foo + bar      is not an infix

[18:09] <masak> it's not?

[18:10] <pmichaud> it's   foo( + bar() )

[18:10] <masak> oh, sorry. I didn't mean 'foo' as a listop.

[18:10] <masak> I shoulda said $foo

[18:10] <pmichaud> right

[18:10] <masak> thanks.

[18:10] <rhebus> this is really helping

[18:10] <masak> anyway...

[18:10] <pmichaud> listops are also a place where we run into ambiguity

[18:10] <masak> postcircumfixes ( () [] <> etc ) are a kind of postfix.

[18:11] <masak> well, not really, but it helps if they follow similar rules.

[18:11] <pmichaud> i.e.,  listops  tends ot be "term term"

[18:11] <pmichaud> *tend to

[18:11] <masak> listops basically reset the term/op clocking function.

[18:11] <masak> anyway...

[18:11] <pmichaud> and what turns something into a listop is a space.

[18:11] <masak> now you see 'foo(' is really just a postcircumfix function call.

[18:11] <sorear> what matters isn't "term term", it's that the parser almost always knows whether the next token is going to be an infex or a term

[18:12] <sorear> in Perl 1-5, this was a literal boolean flag in the lexer

[18:12] <masak> and 'foo (' is a listop followed by a term which happens to be a parenthetical group.

[18:12] <pmichaud> and it's the *space* that causes the listop

[18:12] <masak> well 'foo;' is a listop too

[18:13] <pmichaud> okay, space or terminator :)

[18:13] <rhebus> oh! so, for example, say (1) + 2 is actually say 1 + 2 == say(1 + 2)

[18:13] <masak> aye.

[18:13] <masak> rhebus++ # gets it

[18:13] <masak> rhebus: thus we avoid the awkward misparsings of Perl 5.

[18:13] <pmichaud> we just get new awkward misparsings :)

[18:13] <masak> where say (1) + 2 puts '+ 2' in void context.

[18:14] <masak> pmichaud: but honestly, I find Perl 6's way of parsing function calls so much nicer.

[18:14] <pmichaud> I do too.

[18:14] <pmichaud> very much so.

[18:14] <rhebus> masak: what? surely say(1) + 2?

[18:14] <pmichaud> I'm just saying it's not completely resolved in Perl 6 :-)

[18:15] <masak> rhebus: no, not in Perl 5.

[18:15] <pmichaud> because  "foo + 3"  is a listop (assuming foo is a sub),  but   "pi + 3"  is an equation.

[18:15] <masak> rhebus: in Perl 5, the space doesn't matter.

[18:15] <rhebus> masak: ah, hadn't got perl 5 context

[18:15] <masak> sorry, might not have been clear on that.

[18:15] <rhebus> you need an operator for that

[18:16] <rhebus> masak++ # slow and patient explanation

[18:16] <pmichaud> rakudo:  say pi + 3;  say abs + 3;

[18:16] <masak> pmichaud: a lint tool might help there, too.

[18:16] <p6eval> rakudo a93dcb: OUTPUT«6.14159265358979␤3␤»

[18:16] <masak> rhebus: I was curious whether I would be able to connect the dots :)

[18:16] <flussence> I have to admit, whitespace after a sub is easier to remember than "put unary plus here, depending on whether the author wrote sub($) or not"

[18:16] <rhebus> does one define a nullary function in the same way as in perl 5? ie sub foo () { }

[18:17] <pmichaud> rhebus:   sub term:<foo>() { ... }     # iirc

[18:17] <rhebus> pmichaud: thankie

[18:17] <pmichaud> for simple constants, it's just      constant xyz =  ... 

[18:17] <masak> right. because subs are always listops, even if they take no parameters.

[18:19] <pmichaud> for example, 'self' is defined as a term.

[18:19] <rhebus> right

[18:21] <tadzik> masak: http://github.com/tadzik/perl6-Module-Tools

[18:21] <tadzik> seems to be working for me

[18:21] <masak> tadzik: great! kudos.

[18:22] <rhebus> right

[18:22] <rhebus> off to last night of the proms <333

[18:23] *** leprevost left
[18:23] <masak> have the appropriate amount of fun!

[18:24] <tadzik> neutro seems to handle this

[18:24] <tadzik> I'd say have even more :)

[18:24] * masak .oO( inappropriate amounts of fun? )

[18:24] <tadzik> more than appropriate

[18:26] <tadzik> oh, btw masak

[18:26] <pmichaud> afk, lunch

[18:26] <tadzik> method test($project --> Result) -- what's that?

[18:26] <masak> a return type...?

[18:27] <tadzik> I don't know, that's why I'm asking :)

[18:27] <pmichaud> iir, it's a return constraint

[18:27] <masak> right.

[18:27] <masak> basically, the method promises to return something that is or does Result, if it returns normally.

[18:28] <masak> I actually don't know how that interacts with &fail

[18:28] <tadzik> hmm. my $command = "env PERL6LIB=`pwd`/lib prove -e 'perl6' -r t/";

[18:28] <tadzik> can't it be just "env PERL6LIB=lib prove ..." ?

[18:28] *** synth left
[18:29] <pmichaud> undefined types always match, likely.

[18:29] <pmichaud> (and Failure is undefined)

[18:29] <pmichaud> really afk this time.

[18:30] <masak> tadzik: it probably can. never thought of that.

[18:30] <tadzik> well, `pwd` is just .

[18:30] <tadzik> and `pwd`/bah is just ./bah, which is just bah

[18:30] <tadzik> at least I think so

[18:31] <tadzik> well, let's see if it works in Module::Test

[18:31] *** rhebus left
[18:32] <tadzik> btw, why 'env' at the beginning

[18:32] <tadzik> ?

[18:35] *** leprevost joined
[18:37] <masak> becuase people have told me to write it like that :)

[18:37] <tadzik> :)

[18:37] * tadzik provoking people

[18:38] <tadzik> aaand, we have Module::Test

[18:39] <masak> \o/

[18:39] <sorear> I think it has more to do with tcsh

[18:41] <masak> 'has' scoping is koan-level curious.

[18:41] <tadzik> star: eval 'use File::Find'; say $!.perl; eval 'use Not::Found'; say $!.perl

[18:41] <p6eval> star 2010.07: OUTPUT«Any␤undef␤»

[18:41] <tadzik> hmm

[18:41] <masak> it basically says 'put the variable/method/whatever on *instances*, only not really'

[18:42] *** Schwern joined
[18:42] *** rgrau_ left
[18:42] <masak> for different levels of 'not really' :)

[18:43] <masak> i.e. each instance has its own private attribute to a greater extent that it has its own method.

[18:43] <masak> serious dwimmery at work.

[18:50] *** Axius joined
[18:51] *** wamba joined
[18:52] *** M_o_C joined
[18:55] *** Mowah_ joined
[18:55] *** Mowah_ left
[18:59] *** Axius left
[18:59] *** Axius joined
[19:02] *** Mowah left
[19:03] *** Axius left
[19:08] <tadzik> how do I recursively flatten a list?

[19:08] <tadzik> if I can

[19:08] <masak> rakudo: my @a = 1, 2, (3, 4, (5, 6, (7, 8))); say @a.perl

[19:08] <p6eval> rakudo 085920: OUTPUT«[1, 2, 3, 4, 5, 6, 7, 8]␤»

[19:09] <tadzik> well, an array then

[19:09] <masak> should have said array, then :)

[19:09] <masak> I don't know. I would write a sub, I think.

[19:12] *** wamba left
[19:17] *** takadonet left
[19:17] *** Axius joined
[19:17] *** molaf joined
[19:18] *** takadonet joined
[19:20] <tadzik> how do I modify permissions from Perl 6 (do I?)

[19:20] <tadzik> like chmod

[19:21] <masak> S32/IO specs chmod.

[19:21] <masak> rakudo: chmod

[19:21] <p6eval> rakudo 085920: OUTPUT«Could not find sub &chmod␤  in main program body at line 22:/tmp/29WkCvWp00␤»

[19:21] *** mberends left
[19:22] *** timbunce left
[19:22] <\xF0> last I checked, lots of system functions don't exist yet

[19:22] <masak> that is so.

[19:23] *** takadonet left
[19:23] <tadzik> http://github.com/tadzik/perl6-Module-Tools/commit/7a5debc589365a2fd18327174560cc98263ba4cc

[19:24] <tadzik> any ideas why doesn't it always work as expected? Seems to sometimes compile some files anyway

[19:24] *** takadonet joined
[19:25] <tadzik> . o O ( maybe I'll get myself some civilized gravatar )

[19:27] *** M_o_C left
[19:28] *** timbunce joined
[19:30] <moritz_> jnthn++ # blog post

[19:30] <tadzik> oh, moritz_, was just thinking about you :)

[19:30] <tadzik> so I'm supposed to write some simple grammar example for the book>?

[19:31] <tadzik> based on the Q&A from advent calendar?

[19:31] <moritz_> that would be very welcome

[19:31] <tadzik> will do

[19:31] <tadzik> I'll need to get myself an inkscape then :)

[19:32] <moritz_> re that commit, you don't even need the { } for interpolation

[19:32] <moritz_> (but that's the line you deleted)

[19:33] <tadzik> it used to by copypasted from somebody else's code I think

[19:34] <moritz_> anyway, in what way doesn't it work as expected, sometimes?

[19:34] <tadzik> well, sometimes the difference in stat is obvious, but it still build stuff anyway

[19:34] <tadzik> (will paste some exapmle)

[19:35] <ash_> rakudo: sub f { 5 }; say "{f - 5}" # i found a bug, i haven't seen any tickets in the bug tracker like it, i don't think 

[19:35] <p6eval> rakudo 085920: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in 'f' at line 22:/tmp/GnQ4gv4xbg␤  in main program body at line 22:/tmp/GnQ4gv4xbg␤»

[19:35] <ash_> actually tadzik++ found it

[19:35] <tadzik> http://wklej.org/id/387765/

[19:35] <moritz_> not a bug

[19:36] <moritz_> it's parsed as f(-5)

[19:36] <ash_> rakudo: sub f { 5 }; say "{f() - 5}"

[19:36] <ash_> ah

[19:36] <tadzik> oh

[19:36] <p6eval> rakudo 085920: OUTPUT«0␤»

[19:36] <moritz_> but f doesn't expect a parameter

[19:36] <ash_> well, if thats how its supposed to work, then thats fine

[19:36] <tadzik> If we had static dispatch... :P

[19:37] *** rainerschuster joined
[19:38] <moritz_> Perl 6 - still not able to read the programmer's mind

[19:39] <ash_> Perl 6 - alpha version of skynet

[19:40] <tadzik> Perl 6 – prototype of Perl 7

[19:41] <masak> Perl 6 - reasonable if you are

[19:41] *** meppel joined
[19:41] * masak ==> $bed

[19:41] <tadzik> Perl 6 – fun as Haskell, but better

[19:41] *** masak left
[19:43] *** Axius left
[19:44] *** meppl left
[19:45] *** Axius joined
[19:45] *** icwiener_ joined
[19:46] *** meppel is now known as meppl

[19:47] *** icwiener left
[19:47] *** icwiener_ left
[19:47] *** icwiener_ joined
[19:49] <moritz_> phenny: ask masak if he already applied some version of his enum patch, and if not, if I can do anything to speed it up or to help

[19:49] <phenny> moritz_: I'll pass that on when masak is around.

[19:50] *** Axius left
[19:51] *** Axius joined
[19:53] *** pjcj left
[19:55] <ash_> rakudo: say "{1 + 3 + 4}" 

[19:55] <p6eval> rakudo 085920: OUTPUT«8␤»

[19:55] *** Axius left
[19:56] *** Axius joined
[19:56] <tylercurtis> rakudo: 1..5 ==> map * * 2 ==> my $foo; say $foo.perl; # curious

[19:56] <p6eval> rakudo 085920: OUTPUT«Method 'push' not found for invocant of class ''␤  in main program body at line 22:/tmp/0HiSxB59nl␤»

[19:57] <moritz_> rakudo: 1..5 ==> map * * 2 ==> my @foo; say @foo.perl

[19:57] <p6eval> rakudo 085920: OUTPUT«[2, 4, 6, 8, 10]␤»

[19:57] <moritz_> tylercurtis: push doesn't autoviv yet

[19:57] <moritz_> though it should

[19:57] <tylercurtis> moritz_: good to know.

[19:58] <moritz_> rakudo: my %h; %h<a>.push: 3

[19:58] <moritz_> same problem

[19:58] <p6eval> rakudo 085920: OUTPUT«Method 'push' not found for invocant of class ''␤  in main program body at line 22:/tmp/Svptg5GHeg␤»

[19:58] <dalek> rakudo: 8669d77 | Util++ | build/PARROT_REVISION:

[19:58] <dalek> rakudo: Bump PARROT_REVISION to include nwellnhof++ fix for non-ICU Parrots. Fixes RT#77778 part 2.

[19:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8669d77a310a4675db8734e33969ac31db5977cd

[20:00] *** qw3rty joined
[20:02] <jnthn> "S06 explicitly allows passing the same named parameter several times." # Is that a hangover from the insanity over :@foo collecting up all the foo arguments?

[20:03] * jnthn votes to toss

[20:03] <jnthn> Either that or explicit "last one of the name wins"

[20:06] *** Schwern left
[20:09] *** snearch joined
[20:11] <tylercurtis> lazy ping: sorear;

[20:16] <flussence> S06 seems to say that already

[20:17] <flussence> at least for not-@

[20:19] <sorear> lazy?

[20:21] *** molaf left
[20:21] *** araujo left
[20:24] <moritz_> rakudo: sub f { say callframe(1).line }; f

[20:24] <p6eval> rakudo 085920: OUTPUT«22␤»

[20:24] <sorear> p6eval lies

[20:25] <moritz_> it just counts differently than you do

[20:25] *** qw3rty left
[20:26] *** timbunce left
[20:26] *** rainerschuster left
[20:27] *** tadzik left
[20:27] *** tadzik1 joined
[20:27] *** tadzik1 is now known as tadzik

[20:27] *** ash_ left
[20:30] <sorear> tylercurtis: ???

[20:30] *** Axius left
[20:31] *** Ross left
[20:31] *** Ross joined
[20:32] *** timbunce joined
[20:34] *** icwiener_ left
[20:35] *** takadonet left
[20:36] *** tadzik left
[20:36] *** qw3rty joined
[20:36] *** takadonet joined
[20:36] <qw3rty> hi...

[20:36] <qw3rty> "roles" support, is part of perl6 or parrotvm?

[20:37] <sorear> yes

[20:38] <moritz_> parrot has roles, but they are not enough for what Perl 6 needs

[20:38] <qw3rty> so, one can make a COBOL that runs on parrot and add "roles" to that COBOL?

[20:38] <moritz_> so rakudo doesn't use parrot roles to implement the Perl 6 roles

[20:38] <moritz_> yes

[20:38] <moritz_> but it wouldn't be COBOL anymore

[20:38] <qw3rty> more like pabol or something like that

[20:38] <qw3rty> but still sounds like a good experiment to do

[20:39] * moritz_ doesn't know how 'COBOL' and 'good' go together in the same sentence

[20:39] <qw3rty> hehe,, is good on the paycheck ;)

[20:39] <qw3rty> some of my coleagues work in cobol

[20:39] <qw3rty> they salaries are good, compared to, say, java developers

[20:40] <sorear> supply and demand ;)

[20:40] <moritz_> compensation for suffering, I guess

[20:41] *** synth joined
[20:41] <qw3rty> i think a saw a test suite for cobol somewhere on the net... i have a proyect for these holidays now :)

[20:42] <qw3rty> anyway, thanks for your answers guys

[20:42] <qw3rty> great job u are doing with perl6

[20:42] <qw3rty> even if not still out (i mean, production) i already had many interesting discussions online and in "real" life about some features

[20:43] <qw3rty> well.. bye all!

[20:43] *** qw3rty left
[20:44] *** araujo joined
[20:52] *** patspam left
[20:56] *** araujo left
[20:56] <tylercurtis> sorear: sorry about the ping and disappear. I cargo-culted the CursorBase::_REDUCE and REDUCE methods from Niecza::Actions for Bennu, and I've noticed that only a certain number(around a dozen) of the "Action method ... not yet implemented" sorrys actually display. Should that be happening? Can I make it display all of the sorrys?

[20:57] <sorear> tylercurtis: take a look at STD.pm6 line 6028

[20:58] <sorear> also the corresponding line in STD.pmc

[21:00] *** rainerschuster joined
[21:01] *** araujo joined
[21:01] *** tom_tsuruhara joined
[21:01] *** araujo left
[21:02] <tylercurtis> sorear: thanks.

[21:02] *** jaldhar left
[21:09] <moritz_> rakudo: say { 1 Z=> True xx * }.perl

[21:09] <p6eval> rakudo 8669d7: OUTPUT«{ ... }␤»

[21:13] <moritz_> rakudo: class A::B { has $.x = 3 }; say A::B.new(x => 1).perl

[21:13] <p6eval> rakudo 8669d7: OUTPUT«A;B.new(x => 1)␤»

[21:13] * moritz_ submits rakudobug

[21:18] <colomon> A;B is the bug?

[21:18] <moritz_> yes

[21:18] *** jaldhar joined
[21:18] *** patrickas joined
[21:19] <colomon> moritz_++

[21:19] <patrickas> rakudo: say 1..* ... 5;

[21:19] <p6eval> rakudo 8669d7: OUTPUT«12345␤»

[21:19] <patrickas> moritz_++ indeed!

[21:19] <colomon> patrickas++

[21:19] <colomon> that's what I should be doing while I watch the football game -- adding series tests.

[21:20] *** jaldhar left
[21:20] <patrickas> moritz_ I am reading the comments on github, indeex that tests should have been removed, I had forgotten to push it!

[21:21] <patrickas> indeex! That's a new one!

[21:22] * moritz_ kinda loves the Xxx operator

[21:22] <patrickas> colomon: I am sure you'll find some new edge case I hadn't thought about and manage to send me back to the drawing board :-)

[21:22] <moritz_> rakudo: say 1..3 Xxx 3

[21:22] <p6eval> rakudo 8669d7: OUTPUT«111222333␤»

[21:22] <patrickas> Oh yea, that's the nsfw operator!

[21:23] <colomon> rakudo: say 1..3 Xxx 1..3

[21:23] <p6eval> rakudo 8669d7: OUTPUT«111111222222333333␤»

[21:24] <colomon> rakudo: say (1..3 Xxx 1..3).perl

[21:24] <p6eval> rakudo 8669d7: OUTPUT«((1), (1, 1), (1, 1, 1), (2), (2, 2), (2, 2, 2), (3), (3, 3), (3, 3, 3))␤»

[21:24] *** pjcj joined
[21:25] <moritz_> that usage is interesting too, bu I haven't felt the need in real world code yet

[21:25] <colomon> patrickas: given the scope of series, it's pretty inevitable.  :)

[21:26] <moritz_> http://nopaste.snit.ch/23302 :-)

[21:28] *** araujo joined
[21:29] *** jaldhar joined
[21:30] *** jaldhar left
[21:30] *** jaldhar joined
[21:30] *** snearch left
[21:30] *** guidjos joined
[21:32] *** guidjos left
[21:32] *** guidjos joined
[21:34] *** guidjos left
[21:35] *** Guest23195 left
[21:35] <colomon> patrickas: have you checked in all your changes to the series tests?  (/me moving very slowly)

[21:38] <Util_> To handle spectests like S19-command-line/dash-e.t, which contains a mix of Unicode and non-Unicode tests,

[21:38] <Util_> I plan to split the Unicode tests out into a separate .t (dash-e-unicode.t), then condition it with '# icu' in spectest.data.

[21:38] <Util_> Compared to just marking the original file as '# icu', this will allow more testing to run on non-ICU systems.

[21:38] <Util_> Objections? Have I missed anything?

[21:41] *** Mowah joined
[21:41] <moritz_> Util_: it might be better to have one command-line-unicode.t file somewhere

[21:41] <moritz_> Util_: instead of having two files for each option

[21:43] <Util_> moritz_: I see. I would add comments to each block of tests in command-line-unicode.t, pointing to the .t that would normally be their home.

[21:43] <moritz_> Util_: +^

[21:43] <moritz_> +1

[21:43] * moritz_ should really sleep

[21:45] <sorear> why can't we just depend on ICU?

[21:45] <sorear> We already depend on Parrot, which is much bigger and doubtless harder to compile

[21:46] <pmichaud> our use of ICU depends on Parrot's use of ICU.

[21:46] <pmichaud> and at one time (although this may no longer be true), getting ICU to work with Parrot was a Real Pain on windows environments.

[21:46] <jnthn> ICU used to be bundled in with Parrot and built with it.

[21:46] <jnthn> It was a lot of effort to get that to fly on Windows.

[21:46] <pmichaud> ICU is still built with Parrot.

[21:46] <jnthn> I got it to work.

[21:46] <jnthn> pmichaud: Used to be in the repo.

[21:47] <pmichaud> (although it's not bundled with it)

[21:47] <Util_> sorear: I expect that on Christmas, we might start requiring ICU. Until then, no-ICU required means more testers come to our parties!

[21:47] <jnthn> Anyway, yes, last time I tried to build a Parrot on Windows with ICU support, I didn't manage to get it to work.

[21:47] <patrickas> colomon: sorry I was afk, yes I think moritz_++ pulled everythin I had

[21:48] <pmichaud> anyway, requiring ICU significantly increases the steps needed from Windows users, and that goes against our larger goal of increasing Perl 6 usage.

[21:48] <patrickas> rakudo: say 1 ... *>5

[21:48] <p6eval> rakudo 8669d7: OUTPUT«123456␤»

[21:48] <pmichaud> \o/

[21:49] <patrickas> yes that's the alst case I worked on

[21:49] <jnthn> Nice

[21:49] *** Ross left
[21:49] <jnthn> rakudo: say 1 ... *>*

[21:49] <p6eval> rakudo 8669d7:  ( no output )

[21:49] <jnthn> :-)

[21:50] <sorear> Util_: we can't just hide a copy of ICU in src/dynops?

[21:50] <sorear> *src/ops

[21:51] <patrickas> jnthn what was that supposed to do ?

[21:51] <jnthn> patrickas: Be infinite.

[21:51] <jnthn> patrickas: Wanted to check it didn't blow up with arity 2 closures

[21:51] <jnthn> (on the RHS)

[21:52] <patrickas> jnthn: the RHS closure taking two items was working yesterday but after talking to TimToady and colomon I specifically made it only work for arity 1

[21:52] <pmichaud> I don't understand why dash-e.t requires unicode, btw.

[21:52] <pmichaud> oh, nm.

[21:52] <pmichaud> I'm thinking of something *totally* different.

[21:52] <pmichaud> yes, it needs it because of the \c[...]

[21:52] <jnthn> patrickas: Oh...so what did it do above?

[21:52] <Util_> pmichaud: RT#77778

[21:53] <patrickas> no idea! kinda confused me!

[21:53] <jnthn> rakudo: say 1 ... *>*; say "alive"

[21:53] <p6eval> rakudo 8669d7: OUTPUT«alive␤»

[21:53] <Util_> sorear: Do you mean a pre-compiled library, or the ICU source? 

[21:53] <patrickas> rakudo: 1,2 .... {$^a+$^b > 5}

[21:53] <jnthn> oh, it makes an empty list and fails silently.

[21:53] <p6eval> rakudo 8669d7: OUTPUT«===SORRY!===␤Confused at line 22, near "1,2 .... {"␤»

[21:54] <patrickas> rakudo: say 1,2 .... {; $^a+$^b > 5}

[21:54] <p6eval> rakudo 8669d7: OUTPUT«===SORRY!===␤Confused at line 22, near "say 1,2 .."␤»

[21:54] <pmichaud> why four dots?

[21:54] <jnthn> four dots?

[21:54] <patrickas> rakudo: say 1,2 ... {; $^a+$^b > 5}

[21:54] <p6eval> rakudo 8669d7:  ( no output )

[21:54] <pmichaud> Util_: right, those are due to the lack of ICU -- I agree.

[21:54] <jnthn> Hmm, if it's not meant to work, maybe silent failure is LTA.

[21:55] <pmichaud> rakudo:   say 2 ~~ { $^a + $^b > 5 }

[21:55] <p6eval> rakudo 8669d7: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in <anon> at line 2:/tmp/N8P9Onzuge␤  in 'Block::ACCEPTS' at line 5799:CORE.setting␤  in main program body at line 22:/tmp/N8P9Onzuge␤»

[21:56] <pmichaud> rakudo:   say ({ $^a + $^b > 5 }).ACCEPTS(2)

[21:56] <p6eval> rakudo 8669d7: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in <anon> at line 2:/tmp/xhFVrhlvK1␤  in 'Block::ACCEPTS' at line 5799:CORE.setting␤  in main program body at line 22:/tmp/xhFVrhlvK1␤»

[21:56] <pmichaud> that's what I'd expect.

[21:56] <jnthn> aye

[21:56] *** Kodi joined
[21:57] <patrickas> brb

[21:58] <Kodi> So I'm taking a shot at implementing implementation types, at least for hashes. And by that I mean I'm trying to get 'my %h is MyClass' to work. We should allow 'my %h is Set', although Sets are immutable and have boring values, right?

[21:59] <patrickas> rakudo: my $limit={;*>*}; say $limit.count

[21:59] <p6eval> rakudo 8669d7: OUTPUT«1␤»

[22:00] <sorear> Util_: The source.

[22:00] <patrickas> rakudo: my $limit= ->$a,$b {$a+$b}; say $limit.count

[22:00] <p6eval> rakudo 8669d7: OUTPUT«2␤»

[22:00] <patrickas> rakudo: say 1,2 ... ->$a,$b {; $a+$b > 5}

[22:00] <p6eval> rakudo 8669d7:  ( no output )

[22:01] <patrickas> Does this mean anythig? or was i just typing random stuff under influence ?

[22:01] <patrickas> http://github.com/rakudo/rakudo/commit/927c28c2bf0aa8f14cb37257a881e2e4425cd013#L0R410

[22:02] <Util_> sorear: Parrot used to do that, keeping the whole ICU source in the repo. I think it is a bad practice for any project that we another project wants to include, but it *can* be done.

[22:03] <Util_> I certainly support Rakudo Star packagers providing ICU in their binary packages, though.

[22:04] <patrickas> rakudo: fail('foo')

[22:04] <p6eval> rakudo 8669d7:  ( no output )

[22:04] <patrickas> oh it's just not priting the failure message!

[22:04] <patrickas> locally

[22:05] <patrickas> > say 1,2 ... ->$a,$b {$a+$b > 5}

[22:05] <patrickas> ===SORRY!===\nLimit arity cannot be larger than 1

[22:07] *** ash_ joined
[22:07] <dalek> rakudo: 9734b29 | chromatic++ | src/pmc/objectref_pmc.template:

[22:07] <dalek> rakudo: [PMC] Made ObjectRef's mark() more accurate.

[22:07] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9734b29faf0778d3593469b888ad79f1b38afdf9

[22:09] *** dalek left
[22:09] <sorear> Util_: I'm not convinced it's bad myself... a little amusing, but submodules take most of the pain out

[22:09] *** dalek joined
[22:09] *** ChanServ sets mode: +v dalek

[22:12] *** rainerschuster left
[22:14] <Util_> me is afk for 3 hours; will commit the unicode split on my return.

[22:15] <Util_> s/me/\/me/

[22:17] *** araujo left
[22:19] <patrickas> is fail the right way to handle such a case ?

[22:20] <colomon> yes seems like a reasonable answer to me...

[22:25] <patrickas> how do i get p6eval to display the fail emssage ?

[22:25] <patrickas> rakudo: try  { fail 'foo'; CATCH { say "$!" } }

[22:25] <p6eval> rakudo 8669d7:  ( no output )

[22:28] *** M_o_C joined
[22:30] <lue> rakudo: grammar A { token B { <alpha>+ } }; say "hello" ~~ A.B

[22:31] <p6eval> rakudo 8669d7: OUTPUT«Type objects are abstract and have no attributes, but you tried to access &!regex␤  in 'A::B' at line 22:/tmp/hIhidxIVgI␤  in main program body at line 22:/tmp/hIhidxIVgI␤»

[22:31] <lue> rakudo: grammar A { token B { <alpha>+ } }; say "hello" ~~ A::B

[22:31] <p6eval> rakudo 8669d7: OUTPUT«Can not find sub A::B␤  in main program body at line 1␤»

[22:32] <lue> .oO(so close)

[22:34] <patrickas> jnthn: btw TimToady prefered to remove the arity > 1 on the limit (even thought it was working) because it is rarely used and there is another way to achieve it if you really want to

[22:34] <patrickas> rakudo: say 1,1,-> $a,$b { last if $a+$b>100 ;$a+$b;} ... *

[22:35] <p6eval> rakudo 8669d7: OUTPUT«1123581321345589␤»

[22:35] <patrickas> I don't really like it but at least it's there

[22:36] <pmichaud> 22:03 <Util_> I certainly support Rakudo Star packagers providing ICU in their binary packages, though.

[22:36] <pmichaud> +1, I would agree to that.

[22:36] <pmichaud> (especially on the windows side, if it can be done relatively painlessly)

[22:36] <lue> Is there another way to get token B of grammar A besides /<A::B>/ ?

[22:37] <pmichaud> I wonder if   <&A::B> works

[22:37] <pmichaud> well, no, not exactly.

[22:37] <pmichaud> because it also has to change the type of the underlying cursor.

[22:38] *** hudnix left
[22:39] <lue> I think using A.B [like I did above] should work, by `translating' A.B to the regex (in this case /<alpha>+/).

[22:40] <lue> rakudo: grammar A { token B { <alpha>+ } }; say "hello" ~~ /{A.B}/

[22:40] <pmichaud> lue: it doesn't quite work that way.

[22:40] <p6eval> rakudo 8669d7: OUTPUT«Type objects are abstract and have no attributes, but you tried to access &!regex␤  in 'A::B' at line 22:/tmp/4rC3qkMnZ3␤  in <anon> at line 22:/tmp/4rC3qkMnZ3␤  in 'Cool::match' at line 2416:CORE.setting␤  in 'Regex::ACCEPTS' at line 5840:CORE.setting␤  in main program body

[22:40] <p6eval> ..at lin…

[22:40] <pmichaud> what if token B uses another subrule defined in A?

[22:40] <lue> aah.

[22:42] <tylercurtis> Or even if it recurses.

[22:45] <pmichaud> afk for a while

[22:46] *** hatseflats left
[22:46] *** hatseflats joined
[22:46] *** mjk joined
[22:47] *** mberends joined
[22:52] <lue> rakudo: say "hello" ~~ a.B

[22:52] <p6eval> rakudo 8669d7: OUTPUT«Could not find sub &a␤  in main program body at line 22:/tmp/PjeUhGmNUx␤»

[22:55] *** xinming_ joined
[22:55] *** timbunce left
[22:56] *** araujo joined
[22:57] *** kjeldahl_ left
[22:59] *** xinming left
[23:01] <lue> rakudo: regex A { '(' ~ ')' 'ab' }; say 'x(ab' !~~ /<A>/;

[23:01] <p6eval> rakudo 9734b2: OUTPUT«Useless declaration of has-scoped regex in a module; add our or my to install it in the lexpad or namespace␤Method 'A' not found for invocant of class 'Cursor'␤  in <anon> at line 22:/tmp/INaopm8zX9␤  in 'Cool::match' at line 2416:CORE.setting␤  in 'Regex::ACCEPTS' at line

[23:01] <p6eval> ..5840:COR…

[23:02] <lue> Has the spec changed since #62086 concerning 'has-scoped regexes'?

[23:10] *** Kodi left
[23:13] *** exodist_ is now known as Exodist

[23:23] *** patrickas left
[23:24] *** shelling_lab joined
[23:26] *** M_o_C left
[23:27] *** gottreu joined
[23:31] *** saaki joined
[23:33] *** shelling_lab left
[23:33] *** shelling_lab joined
[23:35] *** saaki left
[23:36] *** saaki joined
[23:37] *** araujo left
[23:37] *** patspam joined
[23:42] *** Mowah left
[23:46] *** leprevost left
[23:47] *** shelling_lab left
[23:48] *** mjk left
[23:48] *** hudnix joined
[23:50] *** mfollett joined
[23:51] *** mfollett left
[23:53] *** shelling_lab joined
