[00:03] *** ruoso left
[00:20] *** ruoso joined
[00:33] *** gbacon joined
[00:40] <lue> ohai everyone!

[00:45] *** rgrau left
[00:48] *** yinyin joined
[00:50] *** sakib left
[00:51] *** isBEKaml left
[01:00] <dalek> nqp-rx: 3fcffdb | pmichaud++ | src/ (5 files):

[01:00] <dalek> nqp-rx: Revert regex-interpolation branch changes back to 3ad311, fresh

[01:00] <dalek> nqp-rx: starting point for new approach to regex interpolation.

[01:00] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/3fcffdb77a9eaea129682a7877265a926dbd7da4

[01:00] <dalek> nqp-rx: 183d47b | pmichaud++ | src/Regex/Cursor.pir:

[01:00] *** dalek left
[01:00] *** dalek joined
[01:01] <lue> afk

[01:09] *** masonkramer_ joined
[01:16] *** whiteknight left
[01:22] *** ash__ joined
[01:40] *** ash__ left
[01:44] *** justatheory left
[01:57] *** hercynium joined
[01:57] *** bpalmer joined
[02:01] *** [mark] joined
[02:19] *** meppl left
[02:25] *** mantovani left
[02:25] *** mantovani joined
[02:29] <dalek> nqp-rx: 890caca | pmichaud++ |  (2 files):

[02:29] <dalek> nqp-rx: Don't interpolate special variables in regexes.

[02:29] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/890caca1c5bea8267bbdcff65dc802faae77e10e

[02:29] <dalek> nqp-rx: b81ec42 | pmichaud++ | src/stage0/ (3 files):

[02:29] <dalek> nqp-rx: Update bootstrap.

[02:29] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/b81ec42b9a5dafc6a4beed973b83ee2660ace5b2

[02:38] *** BrowserUk left
[02:52] *** ash__ joined
[02:58] *** JimmyZ joined
[03:03] *** gbacon left
[03:07] *** masonkramer_ left
[03:14] *** alester joined
[03:31] <diakopter> chirp

[03:31] <lue> rechirp

[03:43] <lue> I'm so annoyed with the USPTO, I wish to patent "A system for safeguarding the concepts and ideas created by persons"

[03:43] <lue> Or something of the sort.

[03:50] *** masonkramer_ joined
[03:50] *** masonkramer left
[03:50] *** masonkramer_ is now known as masonkramer

[03:55] *** TiMBuS joined
[04:03] *** sorear joined
[04:25] *** patspam left
[04:34] *** baest left
[04:36] <sorear> hello.

[04:36] *** ash__ left
[05:05] *** XaeroOne joined
[05:08] <lue> TimToady: ping [quick question about romaji]

[05:13] <TimToady> ポン

[05:14] <lue> Could I write rakudadou as rakudadō ?

[05:14] <TimToady> sure, that's one way

[05:14] *** bpalmer left
[05:14] <TimToady> there's more than one system of romaji

[05:14] *** xomas_ left
[05:15] <TimToady> the more disturbing thing to English speakers is to write /ti/ for "chi" and /tu/ for "tsu"

[05:16] <TimToady> though of course they'll also tend to mis-interpret o vs ō as tenseness rather than length

[05:16] <lue> I've always viewed a macron (¯) as meaning say the letter, not its sound

[05:17] <lue> ā = eh-ee, ī = ah-ee, etc.

[05:17] <TimToady> we call them "long" vowels in English, because they *used* to be that way

[05:17] <TimToady> but o and ō are exactly the same vowel sound in Japanese, only the second is two mora long instead of one

[05:18] <lue> I've read about the slight sound differences, so got to watch out for that [or sound like a foreigner]

[05:18] <TimToady> as an English speaker, just thing of saying o twice in a row

[05:18] <TimToady> without a dipthong

[05:18] <TimToady> *ph

[05:18] <TimToady> so don't say owow

[05:19] <lue> The "u" and "r" sounds would seem to be troublesome...

[05:19] <TimToady> also, since they have only a five-vowel system, none of the vowels land in your mouth exactly where you find natural

[05:20] <lue> Don't we have a five-vowel system as well? [discounting y]

[05:20] <TimToady> the u is maid more with the back of your throat rather than with lip rounding as in English

[05:20] *** tootroot joined
[05:20] <TimToady> *made

[05:21] <TimToady> no, we have a (lemme count)

[05:21] <lue> I think I've watched enough japanese game shows to have the sound at least somewhere in my head :D

[05:21] <tootroot> argh that topic messed up my irssi D:

[05:21] <TimToady> 10 or 11 at least

[05:21] *** kaare joined
[05:21] <lue> Well, with the semivowels and such :)

[05:22] *** kaare is now known as Guest99099

[05:23] <sorear> As someone learning to speak Japanese, I've discovered that I can't actually hear the difference between o and oo.

[05:23] <lue> I blame my interest in (natural&programming) languages on being born German & English :)

[05:23] <sorear> The other long vowels are fine

[05:24] <lue> [If i can find spots in conversation where I could say "way of the camel", I could say "駱駝道"]

[05:24] *** sorear left
[05:24] *** sorear joined
[05:24] <TimToady> seek, sick, sake, sock, sack, suck, suk, (for)sook, soak, LASIK (schwa) for  starters, and that's not counting dipthongs

[05:25] <sorear> As someone learning to speak Japanese, I've discovered that I can't actually hear the difference between o and oo.

[05:25] <sorear> The other long vowels are fine

[05:25] <TimToady> that's because you're listening for the wrong difference

[05:25] <TimToady> maybe

[05:26] <TimToady> what is your native dialect?

[05:26] <sorear> Well, it's not like I can dictate English without knowing the words

[05:26] <sorear> None; Japanese is entirely foreign

[05:26] <TimToady> are you a native English speaker?

[05:26] <sorear> Yes

[05:26] <sorear> (US southwest)

[05:26] <TimToady> okay, so basically western, same as me

[05:27] <lue> [I, having been born in Germany, find it amazing people cannot say 'ch', as in 'Ich bin ein Berliner']

[05:27] <TimToady> well, not that Germans can agree on that either :)

[05:28] <TimToady> a Berliner doesn't say it like a Münchner

[05:28] <lue> Lustiges Taschenbuch!

[05:28] <lue> Southern germans wear the lederhosen. They're weird :)

[05:31] <TimToady> but the difference between o and oo will (to a western English speaker) be something like the difference between the o sounds in 'dough' and 'dough-owner'

[05:31] <TimToady> it really is just length in time

[05:32] <lue> [Glottal stop is just like lisp; just by saying it tells us if you have it.]

[05:32] <TimToady> but since Japanese is syllable timed rather than stress times, you have to learn to hear the syllables as equal in time, not equal between stresses, as we do in English

[05:32] <pmichaud> My glottal stopped a long time ago.

[05:33] <TimToady> lue: well, only if you're cockney and say glo'l stop :)

[05:33] <lue> I do love literal transalation of ja->en . They always sound like proverbs :)

[05:33] <lue> or Estuary! Estuary accent has glottal stop as well!

[05:33] <TimToady> the rest of us tend not to use glotals except at the beginnings of words with vowels

[05:33] <lue> or in uh-oh

[05:34] <TimToady> it's the *absence* of a glottal stop that we hear as an 'h', more or less

[05:34] <lue> [I've read up on Estuary because the 10th Doctor spake it :D]

[05:34] <TimToady> yes uh-oh is an exception

[05:36] <lue> Language is fun. Ever since I picked up a Visual Basic book at age 11.... :)

[05:36] <TimToady> well, you got be started on phonetics/phonemics, which is my linguistic speciality, but a bit OT here...

[05:36] <lue> This is #perl6. We were OT when I asked about romaji :)

[05:37] <TimToady> I think part of the reason I'm good at phonetics is because I'm somewhere on the autistic spectrum, and can hear things on the detailed/unanalyzed level if I choose to

[05:38] <TimToady> neurotypicals usually have a harder time not filtering everything through the phonemic system of their native language

[05:38] <lue> rakudo: autistic ~~ smart

[05:38] <p6eval> rakudo 10a321: OUTPUT«Could not find sub &smart␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[05:38] <lue> but what about autistic? That was the first one!

[05:38] <TimToady> Every now and then, I am the smartest person you will ever meet.  Pity about the rest of the time...

[05:38] <lue> rakudo: say licks[TootsiePop]

[05:39] <p6eval> rakudo 10a321: OUTPUT«Could not find sub &licks␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[05:39] <lue> rakudo: say @licks[TootsiePop]

[05:39] <TimToady> Maybe I should have called it the Autistic License...

[05:39] <p6eval> rakudo 10a321: OUTPUT«Symbol '@licks' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[05:39] <lue> I once saw a Death and Restitution license

[05:40] <lue> basically, you can't use the software if you are alive, or a ghost or an angel :)

[05:40] *** simcop2387 left
[05:40] <TimToady> angels aren't alive?!?

[05:41] <lue> I know; there was a part about being punished if you used it if you were a ghost/angel or something

[05:41] <lue> Where I found it [thru slashdot], you could either pick the BSD or D&R license

[05:43] <lue> I want to patent patents; if it ever gets through the USPTO and gets approved, then, well, enough said about the USPTO :)

[05:43] <TimToady> Copyright (2054) Larry Wall, you may use this if I'm still alive, or if you're dead...

[05:44] <sorear> lue: you know the wheel is currently patented in australia, right?

[05:44] <lue> Or something else absurd, like goverment, or CO2

[05:44] <lue> No.

[05:45] <lue> After patenting patents, I can sue the USPTO, who approved the patent, for infringing upon my patent. It's PERFECT! \o/ >:)

[05:45] <sorear> No.

[05:45] <sorear> It doesn't work that way.

[05:45] <lue> That's what I *hope*.

[05:45] <sorear> Patent lawsuits tend to result in the patent getting thrown out

[05:45] <TimToady> Interestingly, the contract for my timeshare in Hawaii is valid only until the last living descendent of Ronald Reagan or Queen Elizabeth dies.

[05:46] <lue> If it actually worked, I'd be very frightened

[05:46] <sorear> The power of a patent is in scaring people who don't want to enter a lawsuit /at all/

[05:46] <pmichaud> mmmmm, Hawaii

[05:46] <TimToady> Hawaii doesn't allow contracts in perpetuity, it seems...

[05:46] <pmichaud> already got my plane tickets for hawaii :)

[05:46] <TimToady> which island?

[05:46] <pmichaud> Maui

[05:47] <sorear> TimToady: Does it specify which Queen Elizabeth? :D

[05:47] <TimToady> lotsa nice things on Maui

[05:47] <TimToady> II

[05:47] <lue> TimToady: for that contract, is that or as in xor ?

[05:47] <TimToady> no

[05:47] <lue> Darn; then the contract would only be temporarily invalid :)

[05:49] <lue> "Copyright (c) Doomco 32 B.C. All rights (and then some) reserved. Any violation will be prosecuted to the fullest extent ABOVE the law"

[05:51] *** uniejo joined
[05:52] <TimToady> you would not have liked it back then, since you are a loose cannon.

[05:52] <TimToady> loose catapult just doesn't have the same panash

[05:53] <lue> But what would those darn Golganfrinchans know? :)

[05:53] <TimToady> or panache even

[05:53] <lue> Adams' Theory of Evolution

[05:53] <TimToady> I prefer the Addams

[05:54] <lue> Douglas Nöel Adams, RIP [Towel Day, in honor of his death, is tomorrow! (May 25)]

[05:55] <TimToady> um, that's today there...

[05:56] <lue> Well, here in the good ol' US of A, it's still 1 hour 4 minutes until the 25th

[05:56] <lue> s/US of A/PD of T/

[05:57] <TimToady> only the good new US of A :)

[05:57] <TimToady> the old bits are on the other end

[05:58] <TimToady> well, except for the really old bits, which are in New Mexico

[05:58] <TimToady> but it wasn't very U yet back then...

[05:59] <lue> NQU? :)

[05:59] <TimToady> well, it wasn't Less Than America, I suppose...

[06:00] <pmichaud> there's some really old bits here in the Republic of Texas, too.  :-)

[06:00] <TimToady> yes, but you were anti-united back then

[06:00] <pmichaud> I think just dis-united :-)

[06:00] <lue> More like the PMC of the USA back then :)

[06:01] <lue> [or was that something else?]

[06:01] <eternaleye> TimToady: (re autistic spectrum making it easier to differentiate sounds) That explains it for me. I thought it was that I grew up hearing Hebrew from my mom, Arabic from my dad, and Japanese from anime, so I heard a large subset of available phonemes early enough that they made sense

[06:01] <pmichaud> mostly people kept forgetting ice cream with their pie, I think.

[06:01] <pmichaud> The motto became "Remember the a-la-mode!"

[06:01] <lue> .oO(A Perl6-ish representation of the US)

[06:01] <TimToady> well, being multilingual certainly doesn't hurt

[06:02] <TimToady> such as in Texas, where they speak both English and Texan

[06:02] <eternaleye> lue: (death and restitution) ITYM Death and Repudiation, it's used as a dual-license with BSD in the sole project that uses it; it was referenced in a semirecent slashdot story

[06:03] <lue> It's an awesome license, and it smells faintly of dead parrots and silly frenchmen :)

[06:03] *** simcop2387 joined
[06:03] <lue> [That one reason I started learning french this year; to get a good frenchman-speaking-english accent]

[06:04] <lue> afk and good night (off to 楽土, aka bed) :)

[06:05] <eternaleye> All in all, Japanese is the natural language I like the most (having also taken French in Junior High). It's relatively sane in terms of having rules and sticking to them, and it sounds beautiful.

[06:05] <TimToady> お休みなさい。

[06:06] <sorear> I like 'em all

[06:11] <eternaleye> Besides, 私のホバークらーフトはうなぎでいっぱいです！

[06:11] <eternaleye> (hiragana overusage due to not knowing relevant kanji)--

[06:13] <eternaleye> Although if I took the time to open it Kiten would help with that (VERY nice japanese dictionary and radical lookup tool for KDE)

[06:13] <sorear> well it's not like I'd *understand* the relevant kanji

[06:13] <eternaleye> "My hovercraft is full of eels" -> watashi no hobaakurafuto wa unagi de ippai desu

[06:14] <eternaleye> I had an extra ー too

[06:14] <TimToady> are you sure they were うなぎ and not あなご?

[06:15] <eternaleye> Every time I've seen it romanized, it's with 'u', so...

[06:15] <TimToady> well, they distinguish two different kinds of eels

[06:15] <TimToady> unagi are freshwater eels, and anago are sea eels

[06:16] <eternaleye> Ah. The one on the 'multiple translations of hungarian sketch' page used unagi

[06:16] <TimToady> I keep track of this, being allergic to seafood, but not freshwater

[06:16] <sorear> do they distinguish a common superclass?

[06:16] <sorear> or just "round fish"

[06:17] <TimToady> I am not aware of a superclass

[06:19] <eternaleye> rakudo: class うなぎ　{ }; class ホバークラフト does Positional[うなぎ] { };

[06:19] <p6eval> rakudo 10a321:  ( no output )

[06:20] <TimToady> I think a hovercraft is more like a Bag[うなぎ]

[06:21] <eternaleye> I ♥ Unicode

[06:21] <sorear> pmichaud++ dealing with my problems without me

[06:22] <eternaleye> TimToady: Maybe - it depends on if you have the eels sit in the seats :D

[06:23] <TimToady> ⟅うなぎ⟆

[06:24] <dalek> nqp-rx: becdc98 | pmichaud++ |  (2 files):

[06:24] <dalek> nqp-rx: Change tests for isa ['Sub'] to does 'invokable'.

[06:24] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/becdc989e972eb4876097c208c6881f86f23498b

[06:24] <dalek> nqp-rx: 0b3416f | pmichaud++ | src/stage0/ (4 files):

[06:24] <dalek> nqp-rx: Update bootstrap.

[06:24] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/0b3416ffa824fc39ecd58788c82afdd89f7bac44

[06:24] <TimToady> looks like they're on the bottom to me

[06:24] <eternaleye> rakudo: sub infix:<♥>( $lhs as Str, $rhs as Str ) { say $lhs ~ " love " ~ $rhs }; "I" ♥ "Perl 6";

[06:24] <p6eval> rakudo 10a321: OUTPUT«I love Perl 6␤»

[06:25] <eternaleye> rakudo: sub infix:<♥>( $lhs as Str, $rhs as Str ) { say $lhs ~ " love " ~ $rhs }; "I" ♥ $*VM;

[06:25] <p6eval> rakudo 10a321: OUTPUT«Contextual $*VM not found␤current instr.: 'perl6;Perl6Exception;throw' pc 15629 (src/builtins/Associative.pir:32)␤»

[06:25] <eternaleye> rakudo: sub infix:<♥>( $lhs as Str, $rhs as Str ) { say $lhs ~ " love " ~ $rhs }; "I" ♥ $?VM;

[06:25] <p6eval> rakudo 10a321: OUTPUT«Symbol '$?VM' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[06:25] <eternaleye> Awww

[06:27] <sorear> wow, I'm now caught up on everything

[06:28] <sorear> I was expecting 4 days of backlog to take more than 3 hours

[06:28] <sorear> you guys are such SLACKERS

[06:28] *** kel__ joined
[06:28] <pmichaud> <-- SLACKER

[06:29] * sorear reads pmichaud's REPL implementation

[06:29] <pmichaud> I haven't done the REPL part yet

[06:29] <TimToady> sorear: we're only doing this for you, and when you wander off, we lose all motivation...

[06:30] *** Su-Shee joined
[06:30] <pmichaud> but I've figured out how I think it should be factored

[06:30] <pmichaud> I was going to finish it up this morning, but got sidetracked on the regex interpolation fixes

[06:30] *** alester left
[06:31] * TimToady never gets sidetracked, but only because everything is a sidetrack to begin with...

[06:31] *** masak joined
[06:31] <sorear> pmichaud: do you still have the baton for this or do you want me to try and rejoin?

[06:31] <masak> good morning, #perl6!

[06:31] <phenny> masak: 24 May 18:16Z <Tene> tell masak ping

[06:31] <sorear> good morning masak

[06:31] <pmichaud> sorear: let me keep the baton until tomorrow noonish, if you don't mind

[06:31] <masak> Tene: pong

[06:31] <sorear> sure.

[06:32] <pmichaud> I think it'll just take me a couple of hours to get nqp to have a repl that saves lexicals

[06:32] <pmichaud> then updating rakudo (or any other hll) will be a fairly simple matter

[06:33] *** redicaps joined
[06:37] *** JimmyZ_ joined
[06:38] *** JimmyZ left
[06:38] *** JimmyZ_ is now known as JimmyZ

[06:44] *** redicaps left
[06:55] <sorear> Is $*CURPAD.<!IN_DECL> another gimme5ism?

[06:58] <moritz_> masak: iwbn if you brought dalek to report your commits to the buf branch (or bribe Infinoid or diakopter or so to do it for you)

[06:58] <masak> *nod*

[06:59] <masak> that would indeed be a boon.

[07:09] *** rgrau joined
[07:09] *** rgrau_ joined
[07:11] *** rgrau_ left
[07:12] *** rgrau left
[07:13] *** rgrau[work] joined
[07:13] *** iblechbot joined
[07:20] *** k23z__ joined
[07:23] *** ethel left
[07:29] <sorear> k23z__: Hi.

[07:29] <sorear> You wanted me?

[07:30] <k23z__> sorear, yes but it depends on what you mean by "wanted" , for example some women might want you, and I would like to clarify that I don't want you the same way :)

[07:31] *** ejs joined
[07:32] <masak> now that we've cleared that up...

[07:38] *** ejs left
[07:39] *** gfx joined
[07:43] *** ejs joined
[07:44] <cognominal> is there any way to trace function calls in Perl 6?

[07:45] <masak> cognominal: are you asking for more backtraces than those that already plague us? :P

[07:45] <cognominal> :)

[07:46] <cognominal> I am not asking backtrace here (which become  rarer) but plain trace

[07:46] <masak> guess you could emulate tracing by pushing and popping a contextual array variable.

[07:47] <masak> it's a bit of manual work in each function, but it'd do the trick.

[07:47] <sorear> I think what you're looking for is pir::trace(4)

[07:48] <cognominal> thx, I shoud learn more about parrot

[07:48] <masak> clearly, so should I :)

[07:49] <cognominal> For my presenetion I am just documenting the Q::Pir and  pir::   and other interfaces between rakudo and parrot.

[07:49] <sorear> oooooh presentation?

[07:49] <cognominal> sorear++  # for blizkost

[07:49] <cognominal> jnthn++ # for initiating it

[07:49] <sorear> it needs to be better

[07:50] <cognominal> sorear, I want to use blizkost, so be sure I will whine loudly. 

[07:51] <sorear> what are you using it for?

[07:51] * sorear is using it for POSIX & DBD::SQLite, but the project is design-stalled, so not much testing is being done

[07:51] <cognominal> in Calais, we are lacking tacks (hint, hint) so we will have a big Perl 6 track. Work for me :(

[07:51] *** snarkyboojum joined
[07:52] <moritz_> FPW?

[07:52] <sorear> Calais?

[07:52] <cognominal> I intend to use it for code serving web pages hopefully to call Perl 6 code (for demo)

[07:52] <cognominal> yes,  french  Perl workshop at Calais

[07:53] <cognominal> anglophone speakers welcome.

[07:53] <cognominal> mberends will probably talk.

[07:54] <pmichaud> .oO( "We have ways of making him talk...muwahahahahah" )

[07:55] <cognominal> and we dirnk Chartreuse the evening. jnthn++ will attest it nice (also to make people talk).

[07:55] <cognominal> besides being a nice liquor, chartreuse is TimToady's favorite color.

[07:57] <masak> not many things are both a liquor and someone's favorite color.

[07:58] <cognominal> I  strap people in  a chair and can dress like  Lawrence Olivier ("is this safe?") to make people talk

[07:58] <cognominal> *I can strap people to a chair

[08:01] <pmichaud> masak: .... um, burgundy?  ;-)

[08:01] <pmichaud> or champagne?

[08:01] <masak> champagne is a color?!

[08:01] <moritz_> .oO( only for women :-)

[08:01] <pmichaud> http://en.wikipedia.org/wiki/Champagne_(color)

[08:02] <moritz_> like, my girlfriend als thinks that "lavender" is a color

[08:02] <moritz_> *also

[08:02] <moritz_> for me it's a herb

[08:02] *** viklund joined
[08:02] <masak> wow.

[08:02] <masak> moritz_: you're probably alluding to http://blog.xkcd.com/2010/05/03/color-survey-results/

[08:02] <masak> or you should be :)

[08:06] *** snarkyboojum left
[08:06] <pmichaud> well, time for sleep here

[08:07] <pmichaud> I have the refactor of regex interpolation almost done in the 'ri2' branch of the rakudo repo.

[08:07] <pmichaud> Just have three failing test files, if anyone wants to play with it and perhaps fix some of them.  :-)

[08:07] <cognominal> moritz_, if you went to Provence to admire a lavender field, you would know for sure that lavender is a color (and an odor too).

[08:08] <pmichaud> see you all a bit later

[08:11] <moritz_> cognominal: odor I well believe :-)

[08:14] <moritz_> http://perlgeek.de/blog-en/perl-6/rakudo-star-wish-list.html lolihazblogged

[08:19] <masak> \o/

[08:19] <mathw> That's a good list

[08:19] <mathw> I'd really like those backtraces

[08:19] *** mathw sets mode: +o masak

[08:19] <masak> I should make a corresponding list of bugs I'd like to see fixed :)

[08:20] <mathw> Yes

[08:20] <masak> the 'April list' is slowly running out of open bugs :P

[08:20] <mathw> \o/

[08:20] <mathw> Better add some more then

[08:20] <cognominal> we should clone pmichaud and jnthn (that's for the rakudo side).

[08:21] <masak> probably won't add to the original blog post -- more likely to create a new one.

[08:21] <moritz_> cognominal: ... and properly clone their lexpads too :-)

[08:21] <masak> actually, moritz_++'s list is already quite a good list of bugfixes rather than features.

[08:22] <cognominal> moritz_++  # context always helps

[08:22] <moritz_> and I find it's really the bugs that bug me, not the missing features

[08:22] <mathw> but then we'd also have to clone masak, because otherwise they'd be at risk of emptying the bug queue

[08:22] <moritz_> at least 90% of the time

[08:22] <mathw> For Rakudo * we can accept missing features - after all, we've got a lot of features already

[08:23] <mathw> But the ones that are there should work...

[08:23] <masak> I definitely agree on closures, match objects, and iterators. I'd like to add "more mature List/Iterator implementation" and "Short (Rakudo-only) backtraces"

[08:24] <masak> moritz_: missing closing paren on the line starting 'General Whatever-currying'.

[08:25] <moritz_> masak: thanks, fixing...

[08:27] *** k23z__ left
[08:27] *** dakkar joined
[08:46] <pugssvn> r30779 | sorear++ | [viv] Implement declarative or in regex compiler 

[08:47] <masak> sorear++ # cool!

[08:48] <sorear> rakudo: say "π" ~~ /\w/

[08:48] <p6eval> rakudo 10a321: OUTPUT«π␤»

[08:48] <masak> π is an alphanumeric.

[08:48] <sorear> rakudo: say "π" ~~ /<[\0x3c0]>/

[08:48] <p6eval> rakudo 10a321: OUTPUT«␤»

[08:49] *** jhuni left
[08:49] <mathw> Mmmm pie

[08:49] <sorear> rakudo: say "π" ~~ /<[\u03c0]>/

[08:49] <masak> pie pie pie pie pie pie pie.

[08:49] <p6eval> rakudo 10a321: OUTPUT«␤»

[08:49] <sorear> rakudo: say "π" ~~ /<[\U03c0]>/

[08:49] <p6eval> rakudo 10a321: OUTPUT«␤»

[08:50] <sorear> rakudo: say "π" ~~ /<[\x03c0]>/

[08:50] <p6eval> rakudo 10a321: OUTPUT«␤»

[08:51] <moritz_> rakudo: say "π" ~~ / <[\x[03c0]]> /

[08:51] <p6eval> rakudo 10a321: OUTPUT«regex assertion not terminated by angle bracket at line 11, near "]> /"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[08:51] <moritz_> std: say "π" ~~ / <[\x[03c0]]> /

[08:51] <p6eval> std 30778: OUTPUT«ok 00:01 116m␤»

[08:53] <moritz_> rakudo: say 'c' ~~ /<[\x03c0]>/

[08:53] <p6eval> rakudo 10a321: OUTPUT«c␤»

[08:55] <moritz_> rakudo: say '0' ~~ /<[\x03c0]>/

[08:55] <p6eval> rakudo 10a321: OUTPUT«0␤»

[09:10] *** ive joined
[09:10] *** Trashlord left
[09:11] *** proller left
[09:14] <pugssvn> r30780 | sorear++ | [viv] Implement || 

[09:15] *** proller joined
[09:15] <eternaleye> moritz_: (re blog) As to $/ in s///, might a workable hack be to make s/$lhs/$rhs/ delegate to s/$lhs/{ "$rhs" }/ using sorear's textual macros and thus manage it using the .subst closure semantics?

[09:16] <sorear> I doubt it

[09:16] <eternaleye> Eh, just a random idea

[09:16] <moritz_> eternaleye: that's basically how it works at the moment, but it still has the problem that $str.subst() doesn't set $/ for the RHS

[09:16] <sorear> the infrastructure for sanely handling lexicals through macros doesn't really exist

[09:16] <sorear> the parser has to knoe the lexical referencing environment at parse time

[09:17] *** k23z__ joined
[09:17] <eternaleye> Huh, I thought .subst( /foo/, { code($0) } ) worked

[09:17] <moritz_> rakudo: my $x = 'foo'; $x ~~ s/(o)/$_[0]$_[0]/; say $x

[09:17] <p6eval> rakudo 10a321: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class ''␤current instr.: '!postcircumfix:<[ ]>' pc 11584 (src/builtins/Cool.pir:15)␤»

[09:17] <moritz_> :(

[09:18] <moritz_> alpha: say 'foo'.subst(/(.)/, { uc $0 }, :g)

[09:18] <p6eval> alpha 30e0ed: OUTPUT«FOO␤»

[09:18] <moritz_> it worked in alpha

[09:18] <moritz_> HOW?

[09:18] <eternaleye> rakudo: say 'foo'.subst(/(.)/, { uc $0 }, :g)

[09:18] <p6eval> rakudo 10a321: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class ''␤current instr.: '!postcircumfix:<[ ]>' pc 11584 (src/builtins/Cool.pir:15)␤»

[09:18] <eternaleye> Huh

[09:19] <moritz_> that's what you get for accessing $0 if $/ isn't defined

[09:19] <moritz_> rakudo: $0

[09:19] <p6eval> rakudo 10a321: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class ''␤current instr.: '!postcircumfix:<[ ]>' pc 11584 (src/builtins/Cool.pir:15)␤»

[09:19] <eternaleye> moritz_: Yeah, but in your first example you used $_ not $/

[09:21] *** lestrrat is now known as lest_away

[09:21] <pugssvn> r30781 | sorear++ | [viv] Implement [ ] 

[09:21] <moritz_> eternaleye: that's because $/ is passed as the first positional parameter to the closure that .subst receives

[09:21] *** ruoso left
[09:22] <sorear> moritz_: I did a clever trick in the macros implementation by adding $/ as a placeholder parameter

[09:24] *** jaldhar left
[09:24] <eternaleye> moritz_: http://github.com/rakudo/rakudo/blob/alpha/src/builtins/any-str.pir#L842

[09:24] *** jaldhar joined
[09:24] <eternaleye> lexpad['$/'] = match

[09:25] <moritz_> huh

[09:25] <moritz_> will have to try that

[09:30] <sorear> TimToady: How does Cursor know when protoregexes have changed (composition, &c) and need to be recalculated?

[09:32] *** XaeroOne left
[09:32] *** gfx left
[09:35] *** ruoso joined
[09:49] *** Trashlord joined
[09:51] *** yinyin left
[09:56] <eternaleye> Also re blog, could whatever-currying use some of the code from junctions? As far as I can see, both do something special when no multi that accepts them is defined

[09:56] <moritz_> yes, I think the idea is to do it in the dispatcher

[09:57] <moritz_> rakudo: say Whatever ~~ Any

[09:57] <p6eval> rakudo 10a321: OUTPUT«1␤»

[09:57] <moritz_> that's a problem though

[09:57] <moritz_> most built-ins have a very general candidate that accepts two Any's

[09:57] <moritz_> rakudo: say *~*

[09:57] <p6eval> rakudo 10a321: OUTPUT«!whatever_dispatch_helper!whatever_dispatch_helper␤»

[09:58] <moritz_> rakudo: say (*~*).arity

[09:58] <p6eval> rakudo 10a321: OUTPUT«Method 'arity' not found for invocant of class 'Str'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:58] <moritz_> so it doesn't fail

[09:58] <moritz_> which is where junction dispatch kicks in

[09:58] <eternaleye> Hm, maybe respec Whatever as ~~ Mu && !~~ Any?

[09:58] <eternaleye> Makes it easy then

[09:58] <moritz_> and makes other things harder

[09:59] <eternaleye> drat

[09:59] <moritz_> but that's something that TimToady++ has to decide

[09:59] <moritz_> I don't see all the implications involved

[09:59] <moritz_> oh wait...

[09:59] <eternaleye> And again the question becomes 'how did alpha do it?'. I'll dig in alpha again.

[10:00] <moritz_> maybe the solution is not to have an infix:<~>(Any, Any) but rather (Cool, Cool)

[10:01] <jnthn> morning

[10:01] <moritz_> \o/

[10:01] <jnthn> No, I don't think we want whatever stuff to fall out of junction dispatch.

[10:02] <jnthn> (if that's the suggestion)

[10:02] <moritz_> it was, yes

[10:03] <jnthn> afaik, we're mostly meant to set up the auto-currying at compile time.

[10:05] <eternaleye> jnthn: That seems... Difficult. Like, 'must know whether all multi candidates explicitly accept Whatever at compile time' halting problem difficult.

[10:06] <eternaleye> s/all/any/

[10:06] *** k23z__ left
[10:07] <eternaleye> So range's 1..* vs 2+* would be... interesting.

[10:07] <eternaleye> If whatever always curried it'd be trivial

[10:08] <moritz_> fsvo "trivial"

[10:08] <eternaleye> Well, insert a 'relatively'

[10:09] <eternaleye> Perl 6 seems to enjoy thoroughly nuking 'trivial' on the part of implementations from orbit so as to preserve it for users.

[10:10] <moritz_> yes

[10:10] <masak> sushi &

[10:10] <moritz_> "tormenting the implementor on behalf of the user", TimToady++ called it once

[10:10] <eternaleye> mmmsushi

[10:11] <jnthn> eternaleye: But we *do* know all the multi candidates in a given lexical scope at compile time, by spec.

[10:11] <jnthn> eternaleye: Granted it's the halting problem in general, yes.

[10:11] <eternaleye> jnthn: Mmm

[10:12] <jnthn> eternaleye: I think that right now, though, I'd rather have auto-currying and say that it's tough luck for anyone who writes a multi that takes Whatever for an operator, rather than not have the auto-currying.

[10:12] <jnthn> (Since not having it is helping nobody right now.)

[10:13] <eternaleye> jnthn: I think lots of people would miss 1..* though, and it would be a test regression

[10:13] <eternaleye> As well as 1...*

[10:16] <jnthn> eternaleye: We can easily eliminate operators known to have special handling too.

[10:16] <moritz_> or maybe a cheating trait

[10:17] <moritz_> multi sub foo(...) is not_whatever_curried { ... }

[10:17] <jnthn> moritz_: That's no easier to get in place than looking at the signature really, though.

[10:18] <moritz_> hm, ok

[10:20] *** slavik left
[10:33] *** ruoso left
[10:34] *** XaeroOne joined
[10:50] *** JimmyZ left
[10:50] *** slavik joined
[10:58] *** masonkramer left
[11:12] *** iblechbot left
[11:13] *** masonkramer joined
[11:14] *** synth joined
[11:24] *** MOAR-f00li5h joined
[11:24] *** f00li5h left
[11:27] *** MOAR-f00li5h is now known as f00li5h

[11:31] <masak> moritz_++ gets karma from uasi on Twitter for JSON::Tiny -- http://twitter.com/uasi/status/14684657673

[11:32] *** redicaps joined
[11:32] <moritz_> so, what does he write? :/

[11:32] <moritz_> google translate says "The JSON:: Tiny is now helpless Rakudo like bugs around and take a regular expression, but I was still rewriting the work Nde."

[11:33] <moritz_> to which I can mostly say "huh?"

[11:34] <masak> I read that as having to do with the alpha->master transition, and JSON::Tiny being 'helpless' due to bugs in master.

[11:34] <masak> but I might read too much into it -- I'm a bit biased :)

[11:34] <moritz_> there's a lot of truth in there

[11:34] * jnthn thought JSON::Tiny worked in master now

[11:35] <moritz_> jnthn: nope - uses too many Match features

[11:35] <jnthn> Ah.

[11:35] <moritz_> the parsing works, except for character classes containing \t

[11:35] <_sri> how is the socket support in rakude these days?

[11:36] <_sri> *rakudo

[11:36] <moritz_> not changed in the last few weeks

[11:36] <jnthn> Socket support v Rakude je fajn. ;-)

[11:37] <jnthn> .oO( maybe I wasn't meant to parse that typo as a case declension, but it was spot on correct :-) )

[11:37] <_sri> :D

[11:38] <jnthn> _sri: The socket code in master is pretty much what we had in alpha. It was capable of various things, though I guess it probably had some issues. But people managed to write servers and clients for various things using it, so I guess it's at some level usable.

[11:40] *** envi^home joined
[11:43] <_sri> does that include non blocking sockets?

[11:43] <moritz_> don't think so

[11:43] * _sri was thinking about starting to port his http 1.1 client and server libraries

[11:43] <moritz_> but I think parrot recently got support for those

[11:44] <moritz_> or somebody's working on them

[11:45] <jnthn> Once Parrot supports them, it should be easyish to expose it in Rakudo.

[11:47] <_sri> perl5 network programming is so awful (compared to ruby and python), i guess with a little effort rakudo could already beat it

[11:47] *** redicaps left
[11:48] *** redicaps joined
[11:50] <_sri> well, keeping an eye on it *crosses fingers*

[11:53] <masak> so many wishes, so few tuits :-/

[11:55] <jnthn> Aye. :-/

[11:56] * jnthn has had a tuit drought for the last week or so.

[11:56] <moritz_> I failed to backport the code that sets $/ in the code block of .subst()

[11:56] <moritz_> it does work, but gives a NPMCA in the $str.=subst form

[11:56] <jnthn> moritz_: Feel free to gist the patch.

[11:56] <jnthn> moritz_: Who knows, maybe I get a round tuit.

[11:57] <jnthn> moritz_: I bet it's because caller in the case of .= isn't doing quite what you want though.

[11:57] <jnthn> (because the caller is the implementation of .=)

[11:58] <moritz_> jnthn: http://gist.github.com/413051

[11:58] <moritz_> aye, that's what I suspected

[11:58] <moritz_> but I don't know how to fix it

[11:59] <masak> good interview with Damian Conway: http://www.oreillygmt.co.uk/2010/05/damian-conway-on-perl-and-its-future.html

[11:59] <masak> lots of Perl 6 questions and answers.

[11:59] <moritz_> and for s/// there will be yet another caller

[11:59] <colomon> moritz_++ # for getting that far

[12:00] <jnthn> moritz_: Does it make things work more than they did before, btw?

[12:00] <masak> "I've switched most of my development to Perl 6, and it's like stepping out of a prison I didn't even know I was in" -- Damian++

[12:00] <jnthn> Wow!

[12:00] <colomon> I was noticing in the YAPC:NA listings that he seemed to be doing a lot of p6 work -- where is it?

[12:01] <moritz_> jnthn: with this patch 'str'.subst(/(.)/, { uc "$0" })  DWIM

[12:03] <jnthn> moritz_: 

[12:03] <jnthn> I just have to wonder if we can get away with:

[12:04] <jnthn> pir::find_dynamic_lex__ps('$/') = $m;

[12:04] <moritz_> now that's an awesome idea

[12:04] <jnthn> Rather than all the caller lookup which depends on an explicit number of lexpads being there.

[12:05] <jnthn> Well, only if it works. :-)

[12:05] <moritz_> I'll try

[12:06] <moritz_> I think I've tried something similar before, but it involved stored_dynamic_lex

[12:06] <moritz_> which didn't work out too well

[12:09] *** lest_away is now known as lestrrat

[12:09] <moritz_> jnthn: the error goes away, but the improvement too :(

[12:10] <moritz_> do find_dynamic_lex search the current lexpad too?

[12:10] <moritz_> s/do/does/

[12:10] <masak> colomon: Damian's MO seems to be lone hacking followed by a presentation and a first release.

[12:11] <colomon> masak: still seems like this would be a good time to be providing the feedback you get from developing actual code in p6...

[12:11] <jnthn> moritz_: Oh, it probably does

[12:11] <colomon> but I hope that means there are presentations coming next month...

[12:11] <jnthn> moritz_: We maybe need an op like find_lex_skip_current

[12:11] <jnthn> But a dynamic variant of it.

[12:11] <masak> colomon: I've been known to withhold code in the interests of making a splash, so I'm not one to throw stones. :)

[12:12] <masak> colomon: if you ask me, we have a large proportion of people sharing already. what we need isn't a larger proportion, but simple more people coding Perl 6.

[12:12] * colomon was getting all excited to run git bisect for $work, but then discovered there were only about 3 commits in the relevant time period...

[12:13] <colomon> masak: more people coding in Perl 6 would be Very Good

[12:13] *** [mark] left
[12:13] <masak> colomon: and Rakudo Star is the chance many people are waiting for to start.

[12:14] <moritz_> jnthn: I can't find find_lex_skip_current in current... are you sure that's the name?

[12:14] <masak> including those who see it as "the Perl 6 release".

[12:14] <colomon> masak: sure enough.  but R* would be better if more people started now.

[12:14] *** jaldhar left
[12:14] <colomon> hmmm.... probably too late at this point, I suppose.

[12:14] <moritz_> I remember seeing such an opcode, but I can't find it :(

[12:14] <pmichaud> good morning, #perl6

[12:14] <moritz_> good morning pmichaud 

[12:15] <masak> R* might be better, but I really do understand people who want to wait until the worst bugs are squashed.

[12:15] <colomon> o/

[12:15] <masak> mo', pm.

[12:15] *** BrowserUk joined
[12:15] <jnthn> pmichaud: morning! o/

[12:16] <jnthn> moritz_: No, I'm not sure that's the name...let me check.

[12:16] <jnthn> moritz_: oh, no, I was right

[12:16] <jnthn> =item find_lex_skip_current(out PMC, in STR)

[12:16] <jnthn> moritz_: btw, Rakudo dynop

[12:16] <jnthn> Not Parrot op.

[12:16] <moritz_> ah

[12:17] <moritz_> that's why I didn't find it in the parrot repo :/

[12:17] <jnthn> :-)

[12:17] <moritz_> I'm curious, doesn't NQP need those?

[12:18] <jnthn> Wow, prototyping garbage collection in Perl 6!

[12:19] <jnthn> http://trac.parrot.org/parrot/wiki/GCMassacre

[12:19] <jnthn> moritz_: Not atm.

[12:20] <pmichaud> ...nobody took me up on the challenge of cleaning up regexes in the ri2 branch :-)

[12:20] <pmichaud> okay, I'll work on 'em

[12:20] <mathw> jnthn: I like that the rough outline is written in NQP :)

[12:20] <moritz_> pmichaud: at leat I looked at the failures :-)

[12:21] <pmichaud> moritz_++

[12:21] <pmichaud> it's probably something trivial-ish

[12:21] <pmichaud> I do like the new formulation much better.  Also, it knows how to properly do LTM on array interpolations.

[12:22] <moritz_> we have proper LTM?

[12:22] <moritz_> that's news :-)

[12:22] <pmichaud> i.e.,   my @xyz = <b bc bcd>;   'abcde' ~~ / @xyz /;   # properly finds bcd

[12:22] <pmichaud> right now, only in interpolations, and only if backtracking isn't involved

[12:23] <jnthn> protoregexen with constant prefixes also do LTM-ish stuff too, iirc?

[12:23] <pmichaud> jnthn: yes

[12:23] <pmichaud> we definitely don't have "proper LTM" yet, though.  that's still a significant challenge

[12:23] <jnthn> Aye.

[12:24] <jnthn> Turns out we don't have proper multi handling again yet either after latest spec changes. :-/

[12:25] * jnthn doesn't look forward to that refactor all that much

[12:25] <masak> jnthn: why not -- apart from the obvious, that you wrote one working thing already, and now it changed?

[12:26] <jnthn> masak: It took more than one attempt to get the current one working as per the old spec too.

[12:27] <jnthn> masak: But also because multi dispatch is pretty central to all kinds of things.

[12:27] <jnthn> So when you go tweak it, there's a lot to break.

[12:27] <jnthn> Including building the setting.

[12:28] <masak> so, definitely post-R*.

[12:28] <jnthn> Oh, yes.

[12:28] <jnthn> And probably not immediately after that.

[12:28] <masak> jnthn: do you think we'll have time to hackathon once more before R*? I'd be happy to pop down to Lund this time.

[12:28] <jnthn> masak: Perhaps.

[12:28] <jnthn> masak: We need to squeeze it in amongst the workshops.

[12:28] <jnthn> ;-)

[12:29] <masak> oh right :)

[12:29] <jnthn> I'm going nowhere from here before the Ukrainian Perl Workshop.

[12:29] <jnthn> Well

[12:29] <jnthn> Perl Mova + YAPC::Russia to give it its full name.

[12:29] <mathw> masak: the Form.pm push commences this weekend. I can't do it sooner as I have to make up some aikido classes this week.

[12:29] <jnthn> It's historically cute that YAPC::Russia is in Kiev. :-)

[12:30] <masak> mathw: oh well, then I'll simply have to find something else to do until then. :P

[12:30] <moritz_> masak: tough call :-)

[12:30] *** iblechbot joined
[12:30] <masak> I'll live it down. :)

[12:30] *** masonkramer left
[12:30] <jnthn> masak: You thinking of popping down for a weekend/long weekend kinda thing?

[12:31] <masak> jnthn: yes, think so.

[12:31] <jnthn> 5th/6th June would work, if it ain't too soon.

[12:31] <jnthn> The weekend after that I'm in Kiev \o/

[12:31] <masak> no can do :(

[12:31] <jnthn> Aww

[12:31] <jnthn> Next weekend is free but, well, soon.

[12:31] <masak> I have a shareholders meeting on Lyr.

[12:31] <pmichaud> rakudo:  say '3' ~~ /<[\x03c0]>/

[12:32] <p6eval> rakudo 10a321: OUTPUT«3␤»

[12:32] <mathw> masak: you can always do some yourself, I'm sure I can still find more to do. I was planning to do it this week but then I realised that I don't want to flunk testing this month

[12:32] <masak> mathw: *nod*

[12:32] <masak> mathw: I might have a brief look, but I probably wont do leaps and bounds without your supervision.

[12:32] <masak> might focus, say, on my GSoC work instead.

[12:32] <masak> or the last mile of Web.pm.

[12:33] <masak> or porting GGE to master.

[12:33] <masak> or Emmentaler.

[12:33] <masak> or, you know. something else. :)

[12:33] <mathw> Yeah it's not like you're stuck for things to do :)

[12:33] <jnthn> masak: I'd love to have the basic bits of Web.pm working on master.

[12:33] <jnthn> (Request/Response)

[12:33] <mathw> But I am looking forward to figuring out what's going on with Form.pm because it's weird

[12:33] <masak> jnthn: porting Web.pm to master is definitely post-grant. but it might still be pre-R*.

[12:34] *** ejs left
[12:34] <jnthn> .oO( or porting master to Web.pm )

[12:34] <masak> dang, forgot Yapsi on that list! release is a week away.

[12:34] <BrowserUk> HI all

[12:34] <masak> HI

[12:34] <jnthn> o/ BrowserUk 

[12:37] <jnthn> masak: If I wanted to get Request/Response to work, should I branch Web?

[12:37] *** masonkramer joined
[12:37] <jnthn> masak: So I don't break things on alpha?

[12:39] <masak> jnthn: for dual-Rakudobranch projects, I tend to prefer if there's either master/ng-compat, or alpha-compat/master. that ties in well with what Emmentaler will do.

[12:39] <Su-Shee> .oO(how many rakudo stars are you planning?!)

[12:40] *** redicaps1 joined
[12:40] *** ruoso joined
[12:41] *** iblechbot left
[12:41] *** redicaps left
[12:41] <moritz_> as many as needed

[12:41] *** iblechbot joined
[12:41] <masak> and no more than necessary. :)

[12:42] <Su-Shee> yeah but which one is which? :)

[12:42] <masak> likely the first one is number one. etc. :)

[12:43] <masak> man, today's questions are easy. :P

[12:44] <jnthn> masak: OK, ng-compat it will be, if I get to it.

[12:44] <jnthn> phenny: show web

[12:45] <jnthn> grr

[12:45] <jnthn> hugme: show web

[12:45] <hugme> jnthn: the following people have power over 'web': PerlJam, TimToady, [particle], colomon, jnthn, masak, moritz_, pmichaud. URL: http://github.com/masak/web/

[12:45] <jnthn> yay

[12:45] *** masonkramer left
[12:45] <moritz_> it means you're a meta committer, not automatically a committer

[12:46] *** jaldhar joined
[12:46] <colomon> but if you're a meta committer, you can make yourself a committer?

[12:46] <moritz_> sure

[12:46] *** M_o_C joined
[12:47] <moritz_> however hugme can't do that automatically, because irc nicks != github nicks

[12:47] * [Coke] reviewingly sees TimToady go off on a cotangent.

[12:48] <masak> jnthn: you're now a committer to Web.pm

[12:48] <jnthn> masak: w00t

[12:48] * masak hugs jnthn - welcome aboard!

[12:48] <jnthn> \o/

[12:51] <masak> #rs tonight, no?

[12:51] * mathw hugs everyone, just 'cause

[12:51] <jnthn> Yes.

[12:52] <jnthn> Clockan nio.

[12:52] <masak> Klockan nio, ja. :)

[12:52] <jnthn> meh, speling.

[12:53] <masak> om typ sex timmar.

[12:57] <arnsholt> Swedish spelling is weird =p

[12:58] <masak> compared to what, Norwegian spelling? :P

[12:58] <PerlJam> good morning #perl6

[12:58] <masak> PerlJam: \o

[12:59] <moritz_> o/

[13:00] <jnthn> o/

[13:00] *** perlygatekeeper joined
[13:00] <mathw> No, English spelling is weird

[13:01] <moritz_> encoding sounds in visual symbols is weird all in itself

[13:01] <pmichaud> what time is #rs?

[13:01] <arnsholt> masak: Norwegian spelling is about the same I suppose. We also have the most delightfully messed up phonology =D

[13:01] <jnthn> pmichaud: Now + 6 hours

[13:02] <jnthn> pmichaud: Well, give or take some minutes.

[13:02] <moritz_> which is UTC 19, if my math hasn't left me

[13:02] <pmichaud> okay, 19:00 utc then

[13:02] <[Coke]> I can put that on the comp.lang.parrot calendar if people want. (or give someone here write access to it.)

[13:02] <[Coke]> (having jumped through the hoops to make the stuff on there already UTC-based)

[13:02] * jnthn was like, "pm musta missed it when masak said so", then noticed masak wrote it in Swedish :-)

[13:03] <masak> :)

[13:04] <pmichaud> I thought that was just some rot13 encoded text or something....  :-P

[13:04] *** nehal joined
[13:05] *** nehal is now known as Guest73293

[13:06] *** Guest73293 left
[13:07] *** rgrau joined
[13:07] <mathw> I've developed a bad habit of expecting my friends to be able to understand amusing German song lyrics, but most of them never studied German...

[13:08] * moritz_ never studied German, and still understands it :-)

[13:09] <[Coke]> conversely, I studied for 3 semesters, and don't!

[13:10] <[Coke]> ich kannst nicht Deutsche sprechen?

[13:10] *** JimmyZ joined
[13:10] <moritz_> [Coke]: nicht ganz richtig, aber verstaendlich :-)

[13:10] <moritz_> like, my English usualy (not quite correct, but understandable)

[13:10] <[Coke]> ... it's wrong but you understand me? close enough. =-)

[13:11] <jnthn> *usually ;-)

[13:11] <[Coke]> heh

[13:11] <moritz_> jnthn: exactly my point :-)

[13:11] *** ejs joined
[13:11] <[Coke]> I keep hoping I'll have a business need to learn a new language. whenever I do it for fun it stops being fun after a bit and I have no one to chat with.

[13:12] * jnthn values communication over correctness

[13:12] <PerlJam> [Coke]: you should find some like-minded people and form a "language learning club"  :)

[13:13] <mathw> My company actually pay for online language training

[13:13] <mathw> I can take any of the courses I like

[13:13] <mathw> But I've never quite got around to it

[13:14] <Juerd> I can understand most German. It's pretty similar to Dutch :)

[13:14] <mathw> I can understand some Dutch for the same reason

[13:14] <mathw> Correspondingly less though, as I'm not a fluent German speaker :)

[13:14] <Juerd> Most Germans can't understand Dutch though :)

[13:14] <mathw> Odd

[13:14] <mathw> I always thought they looked very similar

[13:15] <Juerd> They do, but Dutch people are exposed to German more than the other way around.

[13:15] <mathw> Point

[13:15] <mathw> Which is another reason why English people are awful at other languages

[13:15] <Juerd> The Dutch tend to switch to English all the time

[13:15] <Juerd> Germans however will try German first, even abroad.

[13:16] <jnthn> Juerd: That's another problem English speakers can have learning another language.

[13:16] <mathw> English people will just try English again, more loudly

[13:16] <jnthn> Juerd: People switch to English quite naturally in a lot of places.

[13:16] <Juerd> jnthn: I know. I've heard several people complain about this habit.

[13:16] <mathw> Yeah

[13:16] <mathw> On my German exchange we asked someone for directions

[13:16] <mathw> And stood there discussing the implications

[13:17] <mathw> and he came back and repeated them in English

[13:17] <mathw> We had actually understood them...

[13:17] <mathw> we were just arguing about where to go first :)

[13:17] <moritz_> Juerd: I think it's impolite to try German first anywhere except 'de'|'ch'|'at'

[13:17] <Juerd> I've forced myself to speak Dutch at the Perl Monger meetings

[13:18] <Juerd> Even when others were speaking English.

[13:18] <mathw> Trying German first in England is unlikely to be successful

[13:18] <Juerd> Finally we're back to Dutch as the primary language for our meetings :)

[13:18] <mathw> yay!

[13:18] <mathw> English is a terrible language really

[13:18] <Juerd> Unfortunately, some non-Dutch mongers no longer attend the meetings

[13:19] <Juerd> They weren't here to learn our language...

[13:19] <mathw> I think we've got a goal for Perl 7

[13:19] <mathw> Make it so expressive you can also use it as a natural, spoken language

[13:19] <Juerd> Incorporate Esperanto

[13:19] *** SmokeMachine joined
[13:19] <mathw> Then all Perl mongers meetings can be conducted in Perl 7

[13:20] <mathw> Problem solved!

[13:20] <masak> I've been learning English for almost twenty years. there are still big gaps in my knowledge.

[13:20] <Juerd> Mi pensas ke uzi Esperanton estus pli facile ol verki lingvon kiu estas kaj komputila kaj homa.

[13:20] <mathw> Not an uncommon problem, even among native speakers

[13:20] <PerlJam> masak: Americans have been learning English all their lives.  There are still big gaps in their knowledge too  :)

[13:21] <Juerd> Tiu lingvo *jam ekzistas*

[13:21] <mathw> PerlJam: That's because they speak it *wrong*

[13:21] <masak> UR DOIN IT RONG

[13:22] <Juerd> Preskaux neniu volas lerni lingvon sole por renkontigxoj

[13:22] <PerlJam> mathw: wrong relative to what?  Usage defines language; there are no absolutes.  :)

[13:23] <moritz_> isn't "there are no absolutes" and absolute by itself, and therefor self-contradictory?

[13:23] <moritz_> s/and/an/

[13:23] <jnthn> Absolutely.

[13:23] <mathw> PerlJam: 'colour' has a 'u' in it :P

[13:23] <PerlJam> heh!

[13:24] <moritz_> that's why Perl 6 has aliases for named parameters

[13:24] <moritz_> so that you can write :color(:$colour)

[13:24] <jnthn> We even have *that* example in book. :-)

[13:24] <moritz_> aye

[13:24] <pmichaud> shouldn't that be  :$colou?r    :-P

[13:24] <Juerd> mathw: Strangely, 'color' does not :)

[13:25] <masak> moritz_: sure, but the proposition 'there are no absolutes' might still be 'true' from a vantage point outside of the formal system we're in, even though it's paradoxical from the inside.

[13:25] <jnthn> pmichaud: There will be modules... :-P

[13:25] <masak> pmichaud: loul!

[13:25] <moritz_> masak: I'm well aware that that's the case here

[13:26] <masak> moritz_: thought so :)

[13:26] <PerlJam> this is certainly the right channel for joy and humor^W er, humour  ;)

[13:27] *** ejs left
[13:28] * jnthn takes a fag break ;)

[13:31] <jnthn> moritz_: btw, did you have any luck with find_lex_skip_current?

[13:32] <moritz_> jnthn: I looked at find_dynamic_lex in the C code, and it does appear to start at the caller's lexpad

[13:32] <jnthn> moritz_: Ah

[13:32] <moritz_> jnthn: unless I'm mislead by the pcc function names used

[13:32] <jnthn> moritz_: No, sounds likely.

[13:32] <pmichaud> correct, find_dynamic_lex does not look in the current lexpad

[13:32] <jnthn> moritz_: We could make it a friend that dkips current.

[13:32] <jnthn> pmichaud: oh, it doesn't?

[13:33] <pmichaud> it's analogous to find_outer_lex, which also does not look in the current lexpad

[13:33] <jnthn> rakudo: my $*x = 42; say $*x; # wouldn't that be a nuisance for this?

[13:33] <p6eval> rakudo 10a321: OUTPUT«42␤»

[13:33] <jnthn> Well, it ain't because we do !find_contextual I guess.

[13:33] <pmichaud> partially

[13:34] <jnthn> I thought NQP just used that op directly, though.

[13:34] <pmichaud> but it's also not-a-nuisiance because presumably the compiler knows about the lexicals in the current lexpad already

[13:34] <jnthn> True.

[13:34] <pmichaud> ...and  :scope<contextual>  is smart enough to check the block's symbol table to determine which opcode to emit

[13:34] <moritz_> anyway, it didn't help me in setting $/ for the closure of .subst

[13:34] <pmichaud> (either that or NQP is doing it.)

[13:34] <jnthn> moritz_: Aww. OK.

[13:35] <moritz_> alpha: my $x = 'foo'; $x.=subst(/(o)/, { uc "$0" }); say $x

[13:35] <p6eval> alpha 30e0ed: OUTPUT«Use of uninitialized value␤fo␤»

[13:35] <pmichaud> and yes, it's generally trivial to have find_dynamic_lex look in the current lexpad by simply calling a sub that does the find_dynamic_lex for you :-P

[13:36] <moritz_> alpha: my $x = 'foo'; say $x.subst(/(o)/, { uc "$0" });

[13:36] <p6eval> alpha 30e0ed: OUTPUT«fOo␤»

[13:36] <pmichaud> (whereas the reverse is emphatically not true :-)

[13:36] <moritz_> so it never worked in alpha either, it just didn't barf as loudly as my attempt

[13:36] <pmichaud> ...didn't work?

[13:37] <pmichaud> it looks like it worked in alpha to me

[13:37] <pmichaud> or am I looking at somethign different?

[13:37] <moritz_> pmichaud: the in-place variant didn't work

[13:37] <pmichaud> oh

[13:38] <moritz_> pmichaud: and with my patch, the in-place variant dies loudly, but the normal one works as in alpha

[13:38] * jnthn guesses he could hack up !dispatch_.=

[13:38] <moritz_> http://gist.github.com/413051 this one

[13:38] *** gbacon joined
[13:38] <jnthn> But that won't help us with s///

[13:38] <moritz_> correct too

[13:38] <pmichaud> oh, .subst can almost certainly be made to work

[13:38] <jnthn> pmichaud: The thing is, it goes looking in the immediate callers lexpad. Always.

[13:38] <pmichaud> jnthn: right, that's fixable.

[13:39] <jnthn> pmichaud: right, I was just expecting find_dynamic_lex to perhaps do it.

[13:39] <moritz_> but there's still a problem

[13:39] <jnthn> pmichaud: That is, find the first $/

[13:39] <jnthn> Becuase !dispatch_.= sure don't declare one.

[13:39] <moritz_> right now we assume that the closure passed to .subst comes from the same lexical scope

[13:40] <moritz_> that doesn't have to be the case

[13:40] <moritz_> (though maybe it's safe to ignore that problem)

[13:40] *** M_o_C left
[13:40] <pmichaud> it's safe to ignore that problem, I think.

[13:41] *** viklund left
[13:42] <jnthn> pmichaud: Did using find_dynamic_lex completely break it, or just not fix the problem?

[13:42] <jnthn> er

[13:42] <jnthn> moritz_: 

[13:42] <jnthn> ^

[13:42] <jnthn> :-)

[13:43] <moritz_> jnthn: it made it not barf, but didn't set $/ as it should

[13:43] <pmichaud> I have just one more fix to make for interpolated regexes, then I can help out with .subst

[13:43] <moritz_> and I think I know why (speculation ahead)

[13:43] <moritz_> becaue I did it inside the loop

[13:44] <moritz_> and the loop body is compiled as a subroutine to PIR

[13:44] <jnthn> Ah

[13:44] <moritz_> so the caller of that sub is method subst

[13:44] <jnthn> *nod*

[13:44] <jnthn> yeah. :-(

[13:44] <moritz_> but that might be fixable

[13:45] *** baest joined
[13:46] <moritz_> just need to do the lookup in the outer scope, and do some binding cheating magic at PIR level

[13:47] <pmichaud> oh, wait.  my failure in in .subst

[13:47] <pmichaud> so I guess I get to look at it now.

[13:47] <pmichaud> where is .subst defined?

[13:47] <moritz_> Cool-str.pm

[13:47] <moritz_> in src/core/

[13:47] <moritz_> around line 30

[13:50] *** SmokeMachine left
[13:50] *** redicaps1 left
[13:50] <pmichaud>             $result ~= ~($replacement ~~ Callable

[13:50] <pmichaud>                             ?? $replacement($m)

[13:50] <pmichaud>                             !! $replacement);

[13:50] <pmichaud> ....really?  $replacement($m)  ?

[13:50] <pmichaud> that looks.... wrongish

[13:50] <moritz_> why?

[13:50] <pmichaud> do we expect the match to also be in $_ ?

[13:50] <moritz_> yes

[13:51] <pmichaud> hmmmmm

[13:53] <moritz_> however I realize that doing the call as '$m ~~ $replacement' would be more robust

[13:53] <moritz_> because that code handles zero-arg closures too

[13:53] <pmichaud> well, no matter what it's going to end up having to be   helperfunction($replacement, $m)

[13:54] <pmichaud> where helperfunction does the switching around of $/

[13:54] <pmichaud> (or otherwise mucking with $replacement's outer context)

[13:56] *** mikehh joined
[13:58] <moritz_> mucking with $m's outer seems better than with self's caller

[13:58] <pmichaud> that's what alpha did.

[13:58] <pmichaud> it modified $/ in the replacement's outer context

[13:58] *** BrowserUk left
[13:58] <jnthn> That'd in theory avoid the .= problem.

[13:59] *** pyrimidine joined
[13:59] <moritz_> pmichaud: not if I understand that old code correctly

[13:59] <pmichaud> ...assuming that the replacement's outer context was the same as the one calling .subst

[13:59] <moritz_> http://github.com/rakudo/rakudo/blob/alpha/src/builtins/any-str.pir#L834

[13:59] <moritz_> $P0 = getinterp lexpad = $P0['lexpad';1]

[14:00] <pmichaud> right

[14:00] <moritz_> ...

[14:00] <pmichaud> that gets the caller's lexpad

[14:00] <pmichaud> and then later

[14:00] *** alester joined
[14:00] <pmichaud>     lexpad['$/'] = match

[14:00] <pmichaud> changes the meaning of $/ in the caller's lexpad

[14:00] <moritz_> right

[14:01] <pmichaud> the problem in this case is that the caller isn't replacement's outer

[14:01] <pmichaud> (the caller to .subst is !dispatch.=

[14:02] <pmichaud> and in the more general case, it's probably unwise to assume that the caller is the replacements outer

[14:02] <moritz_> right; so I thought we could call $replacement.get-outer.lexpad['$/'] = $M

[14:02] <moritz_> or so

[14:02] <moritz_> fiddled into parrot semantics

[14:02] <pmichaud> that's a fair bit of fiddling

[14:03] <pmichaud> unfortunately parrot doesn't expose the outer context.

[14:03] <moritz_> :(

[14:03] <moritz_> it's available at the C level

[14:03] <pmichaud> it exposes the outer sub, though, which if cloned properly can do what we want/need.

[14:04] <jnthn> That sounds potentially fragile.

[14:04] <pmichaud> it is.

[14:04] <jnthn> I'd prefer a dynop that goes off and does the right thing.

[14:04] <jnthn> Then at least if Parrot changes its structures around we'll blow up when compiling

[14:04] <jnthn> And know to go and fix it

[14:04] <jnthn> Than have an obscure bug.

[14:04] <pmichaud> let me think on this just a sec

[14:04] <jnthn> Aye

[14:05] <moritz_> no hurry

[14:05] * jnthn needs a little break too, bbs

[14:06] <pmichaud> actually, the part that bugs me at the moment is the fact that $/ always defaults to OUTER::<$/>

[14:06] <pmichaud> I almost wish there was a way to make it do something more useful/different.

[14:06] <moritz_> like, have a way to initialize it on function call?

[14:07] <moritz_> or make it default to the caller's $/?

[14:07] *** pyrimidine left
[14:07] <pmichaud> or make it always default to the dynamic $/

[14:07] *** ruoso_ joined
[14:07] <masak> std: my $a; {{{{{{{ $a; my $a }}}}}}}

[14:07] <p6eval> std 30781: OUTPUT«[31m===[0mSORRY![31m===[0m␤Lexical symbol '$a' is already bound to an outer symbol (see line 1);␤  the implicit outer binding at line 1 must be rewritten as OUTER::OUTER::OUTER::OUTER::OUTER::OUTER::OUTER::<$a>␤  before you can unambiguously declare a new '$a' in this scope at

[14:07] <p6eval> ..…

[14:07] <moritz_> that sounds potentially harmful

[14:07] <pmichaud> but that probably causes issues if we start cloning closures with things like $0 and the like in it.

[14:08] *** isBEKaml joined
[14:09] <isBEKaml> hallo hexers! :)

[14:09] <pmichaud> okay, here's a bizarrish approach

[14:09] <masak> isBEKaml: \o

[14:09] *** SmokeMachine joined
[14:10] <isBEKaml> I was bit surprised to find a new branch, ri2 when I git pulled.. What's up? 

[14:10] <pmichaud> what if we wrap $replacement with a dynamically-created sub that has its own $/ (that we can set) but that otherwise takes $replacement's outer context as its own?

[14:10] *** ruoso left
[14:10] <moritz_> isBEKaml: simplification of regex interpolation

[14:11] <pmichaud> in some sense it really bugs me to be rebinding $/ in $replacement's outer context

[14:11] <isBEKaml> moritz_: ah, cool. one of the items on your Ponie. :)

[14:11] <pmichaud> action-at-a-distance, and all that.

[14:12] <moritz_> aye, it's not a nice solution

[14:13] <pmichaud> I wonder if it could be done as a named argument somehow.

[14:13] <pmichaud> (which defaults to OUTER::<$/> when not supplied)

[14:13] *** ive left
[14:14] <pmichaud> much like what currently happens for $_

[14:17] <pmichaud> then we could have   $replacement($m, :MATCH($m))

[14:17] <pmichaud> and $/ would bind to $m instead of OUTER::<$/>

[14:17] <moritz_> or even call that thing :$/

[14:18] <pmichaud> how would we invoke it?  (I'm forgetting my syntax at the moment)

[14:18] <moritz_> which we then can fill with |%( '/' => $m)

[14:18] <pmichaud> a little icky, but do-able.

[14:19] <moritz_> less icky than colliding with \w+ names, IMHO

[14:19] <pmichaud> it would mean that all of our blocks end up with named parameters, though.

[14:19] <pmichaud> not so sure I like that.

[14:19] <moritz_> maybe we can filter out immediate blocks at compile time?

[14:20] <pmichaud> oh, that's somewhat true

[14:20] <pmichaud> this would likely be only for blocks w/o an explicit signature

[14:24] <pmichaud> well, at the moment I think I'm leaning toward the dynop.  :-|

[14:25] <pmichaud> although that's a bit messy also, as $replacement is likely to be a wrapped sub

[14:26] <pmichaud> although I suppose we can de-wrap it before handing it off to the dynop (sounds cleaner that way)

[14:27] <pmichaud> or, perhaps the better dynop is something that lets us get the current context from a sub

[14:27] <pmichaud> which we can then muck around with directly.

[14:28] <pmichaud> then it's just  $replacement.real_sub.get_outer.get_ctx.get_lexpad['$/'] := $m   :-P

[14:28] <pmichaud> although that's not really right either :-(

[14:29] <pmichaud> really what we want is the outer_ctx attribute of $replacement

[14:32] <pmichaud> hey, waitaminnit!

[14:36] *** snarkyboojum joined
[14:36] <pmichaud> let me ask around on #parrot a bit

[14:37] <snarkyboojum> bonjour perl6 hackers

[14:37] <moritz_> bonjour snarkyboojum 

[14:37] <isBEKaml> snarkyboojum: yo! 

[14:37] <snarkyboojum> :)

[14:39] <isBEKaml> rakudo: enum Stuff <A B C D E>; say E.WHAT; say E.key;

[14:39] <p6eval> rakudo 10a321: OUTPUT«Int()␤Method 'key' not found for invocant of class 'Integer'␤current instr.: '_block18' pc 29 (EVAL_2:0)␤»

[14:40] *** jaldhar left
[14:40] <snarkyboojum> moritz_: I noticed day8 and day20 aren't in the spectest list yet - do they need reviewing/changing?

[14:41] <isBEKaml> std: enum Stuff <A B C D E>; say E.WHAT; say E.key;

[14:41] <p6eval> std 30781: OUTPUT«ok 00:01 115m␤»

[14:41] <pmichaud> moritz_ / jnthn:  I'm going to see if we can get better introspection on Parrot subs; we can then use that to handle the $/ binding from .subst

[14:42] <pmichaud> I've come across other places (REPL) where I really feel I need to have this, also.

[14:42] <moritz_> setting the sub name by a different API than $P0 = $S0 also wouldn't hurt

[14:42] <jnthn> pmichaud: +1

[14:42] <masak> snarkyboojum! \o/

[14:42] <snarkyboojum> masak-san! o/

[14:43] <snarkyboojum> :)

[14:43] * moritz_ wonders what robots get attached to their name, must be different from -san

[14:43] <isBEKaml> rakudo: enum Stuff <A B C D E>; say E.WHAT; say Stuff::.keys; 

[14:43] <p6eval> rakudo 10a321: OUTPUT«Int()␤Could not find sub &Stuff␤current instr.: '_block18' pc 29 (EVAL_2:0)␤»

[14:44] <moritz_> rakduo: enum Stuff <A B C D E>; say Stuff.keys

[14:44] <moritz_> rakudo: enum Stuff <A B C D E>; say Stuff.keys

[14:44] <p6eval> rakudo 10a321: OUTPUT«ABCDE␤»

[14:44] <moritz_> after about two years I still can't spell 'rakudo' reliably :-)

[14:44] <isBEKaml> :)

[14:45] <isBEKaml> habity of the ginfers... :)

[14:45] <isBEKaml> oh, well. ;)

[14:46] <isBEKaml> moritz_: the Enum's .key is NYI or a known bug? 

[14:46] <moritz_> isBEKaml: known NYI

[14:47] *** rokoteko left
[14:48] <isBEKaml> moritz_: club the two unknowns, you get a known! ;)

[14:49] <isBEKaml> I'm trying to search through RT, but the search is a little, er, primitive? Can't do a detailed search? 

[14:50] <isBEKaml> Results are out from perl5, parrot and perl6, when I only want perl6. :|

[14:50] <moritz_> isBEKaml: are you logged in?

[14:51] <moritz_> it makes a huge difference

[14:51] <isBEKaml> moritz_: I don't have an account yet. Should I create one? 

[14:51] <moritz_> yes

[14:56] *** ash__ joined
[14:57] *** ash__ left
[15:00] <XaeroOne> in perl6 do you use . instead of -> in perl5?

[15:01] <moritz_> aye

[15:01] <moritz_> at least in the case of calling stuff

[15:01] <moritz_> when dereferencing array or hash refs, you don't need anything explicit at all

[15:01] *** k23z__ joined
[15:02] <moritz_> rakudo: my $h = { a => 42, b => 23 }; say $h{'a'}

[15:02] <p6eval> rakudo 10a321: OUTPUT«42␤»

[15:02] *** hercynium left
[15:03] <XaeroOne> are there perl6 modules somewhere like cpan?

[15:05] <moritz_> XaeroOne: http://proto.perl6.org/

[15:05] <jnthn> http://proto.perl6.org/

[15:05] <jnthn> ah, moritz_ beat me :-)

[15:05] <XaeroOne> :P

[15:05] <XaeroOne> lot has changes in perl6, i wonder if python to perl6 will be easier than perl5 to perl6 :-?

[15:05] <masak> note though that proto is *not* like CPAN :)

[15:05] <moritz_> XaeroOne: it depends on which level you want to rewire your brain

[15:05] *** IllvilJa joined
[15:06] <XaeroOne> xD true

[15:06] <XaeroOne> it would invole some level of unlearning of perl5 right?

[15:07] *** orafu left
[15:07] <moritz_> yes

[15:07] *** orafu joined
[15:07] <moritz_> or maybe co-learning Perl 6 :-)

[15:07] <isBEKaml> well, not only perl5 unlearning. You'd have to unlearn some to learn some more. :)

[15:07] <moritz_> it's not like you need to forget how Perl 5 works - I use both 5 and 6 almost every day

[15:08] <IllvilJa> what about dropping knowledge regarding 'Lost'  in favor of Perl6 ;-)

[15:08] <IllvilJa> That way, you can keep Perl5 AND Perl6 in your head, at the same time!

[15:08] <moritz_> and "lost" isn't such a big loss

[15:09] <snarkyboojum> moritz_: me too - it's more like keeping the knowledge of p5 and p6 separate

[15:09] <XaeroOne> dammit I stopped watching Lost after season1

[15:10] <[Coke]> XaeroOne: I'm netflixing season 2 now. =-)

[15:10] <IllvilJa> snarkyboojum: isn't Perl6 a bit too viral to stay away from Perl5 in your head?

[15:10] <isBEKaml> p5 and p6 can really co-exist. They share a... symbiosis ;)

[15:10] <IllvilJa> Watch what the Moose/Catalyst crowd is doing... they are slowly being assimilated into Perl6 (sort  of) by letting Perl6 infect Perl5 more and more...

[15:11] <isBEKaml> I wouldn't use the word infect... ;)

[15:11] <IllvilJa> BTW, is duke leto around in this channel?

[15:12] *** plobsing left
[15:12] <moritz_> IllvilJa: nope, but usually on #parrot (irc.perl.org) network as dukeleto

[15:12] <[Coke]> moritz++

[15:12] <IllvilJa> moritz_: thanks!

[15:13] * [Coke] ponders where the advent stuff sits. +1 to everyone who's hacked on that this week.

[15:14] <moritz_> only 5 files left without tests

[15:14] <moritz_> might be that not all of them need tests in the end

[15:14] <isBEKaml> I find them too vague to come up with tests... ## Maybe, next advent should focus more on code than concepts ? 

[15:15] <TimToady> ⟅うなぎ⟆

[15:15] <moritz_> I think we had a good mixture of code and concepts

[15:16] <isBEKaml> moritz_++

[15:16] <[Coke]> I basically just cut and pasted the calendar page in, and made sure that all the code that was presented compiled and did what it said.

[15:16] <[Coke]> except where it didn't. :P

[15:16] <[Coke]> I think MONKEY_TYPING was the only spec change I found in the pages I did.

[15:16] <masak> TimToady: I might have missed your answer to my question about the spec's definition of (Unicode) 'character', and about .chars -- or perhaps you're still mulling over it?

[15:17] *** XaeroOne left
[15:17] *** XaeroOne joined
[15:17] <isBEKaml> yes, I think that way too. I was more inclined towards each day's coverage should give a balanced treatment to code and concepts. 

[15:17] <isBEKaml> than, the whole advent series. :)

[15:18] <snarkyboojum> [Coke]: some of the posts without tests are a little fuzzier, and require supporting code etc

[15:19] <snarkyboojum> or maybe not :)

[15:19] <isBEKaml> [Coke]: case in point, day 10. 

[15:20] <[Coke]> (require supporting code) yah. still doable, though.

[15:20] <TimToady> masak: at one point, character was supposed to mean the largest available abstraction under use graphs/codes/bytes

[15:21] <TimToady> but that is not terribly practical with method dispatch, so .chars basically means graphemes these days

[15:21] <snarkyboojum> definitely doable, but not as clean as some of the others

[15:21] <TimToady> (except that it really means codepoints in rakudo still)

[15:21] <moritz_> but bytes have a separate data type these days

[15:21] <snarkyboojum> ah [Coke] beat me to it

[15:21] <moritz_> so having .bytes in class Str is just confusing

[15:21] <m6locks> whoa, building rakudo was like a lightning strike compaared to what it was in the beginning of this year, i see some significant improvement in performance     

[15:21] <moritz_> ... and startup time has gone down too

[15:22] <m6locks> kudos goes out to y'all

[15:22] <moritz_> it's currently at about 0.38s

[15:22] <TimToady> also, if we get to some kind of NFG, then even Str is represented by a list of integers (but some of them are out-of-line indexes)

[15:22] <moritz_> used to be more like 0.7s-ish

[15:22] <[Coke]> chromatic++ # et al.

[15:22] <TimToady> so Str and Buf are more like each other than they used to be

[15:22] <TimToady> so it becomes not quite so evil to use numbers as character positions

[15:23] <isBEKaml> [Coke], snarkyboojum: how about tacking regexes and stuff like that without tests with a common set of test data? Rather than using random test data in the specific test files... 

[15:23] <snarkyboojum> isBEKaml: common set of test data?

[15:23] <moritz_> TimToady: so... have .graphs on Str and .bytes on Buf, and in each case .chars re-dispatch as appropriate?

[15:24] <masak> TimToady: thanks. that makes it easier to think about. I'll see if I think some of the spec needs rewording to be clearer.

[15:24] <TimToady> maybe we need a Cod string type :)

[15:24] <pmichaud> looks like I have regex interpolation working again... just need to catch all of the repos up with the changes.

[15:25] <TimToady> rakudo: say '𠱠'.chars

[15:25] <p6eval> rakudo 10a321: OUTPUT«1␤»

[15:25] * moritz_ doesn't like Cod, or fish in general

[15:25] <[Coke]> isBEKaml: the advent tests aren't for features, they're just to make sure the sample code we have put out there still works.

[15:25] <pmichaud> (and run lots of tests)

[15:25] * TimToady doesn't like UTF-16, or codepoints in general

[15:25] <[Coke]> anything more complicated than that should be tested outside of t/spec/integration.

[15:25] <masak> TimToady: then we could refer to slices of Cod, and Codpieces.

[15:25] <[Coke]> pmichaud++

[15:26] <[Coke]> (that other guy)++

[15:26] <pmichaud> .oO( t/spec/complicated ?)

[15:26] *** BrowserUk joined
[15:26] <dalek> nqp-rx: c69f6f6 | pmichaud++ | src/Regex/Cursor.pir:

[15:26] <dalek> nqp-rx: Avoid "Cannot take substr outside of string" exceptions on interpolated literal 

[15:26] <dalek> nqp-rx: matches.

[15:26] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/c69f6f6c9c4f65302fabaf6a33b3409ab17eb418

[15:26] <dalek> nqp-rx: 64ff6a1 | pmichaud++ | src/stage0/ (4 files):

[15:26] <dalek> nqp-rx: Update bootstrap.

[15:26] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/64ff6a14dcd6d1ed773ace42d92abf7a2034e5be

[15:27] <moritz_> next parrot, then rakudo, then the world!

[15:27] * moritz_ -> decommute

[15:27] <pmichaud> yes, testing parrot now

[15:27] <isBEKaml> [Coke]: ah, not for features. I was thinking more of broader tests like regexes. 

[15:28] <isBEKaml> Maybe, we could just make some tests common across them. like variations of strings, rather than repeating them through test files.. 

[15:30] *** rob___ joined
[15:30] <[Coke]> isBEKaml: I think the regexp tests are already setup like that. (at least the parrot ones are.)

[15:31] <masak> aye. the PGE tests are essentially big tables of situations.

[15:31] <masak> a script parses them and runs them as TAP tests.

[15:31] <isBEKaml> Err, feel free to ignore them if not suitable. :)

[15:32] <pmichaud> okay, merged locally to master, spectesting

[15:32] <isBEKaml> (i'm not that conversant in perl6 yet to come up with concrete examples)

[15:33] <isBEKaml> My perl6fu is still in monosyllables. ## or even primitive. ;)

[15:34] <pmichaud> well, in perl 6 those monosyllables can take you a lot farther :-)

[15:35] <isBEKaml> pmichaud++ ## Too true. :)

[15:36] <isBEKaml> S05-nonstrings/basic.t is happpy ## Clue: Zaphod. :)

[15:37] *** rob___ left
[15:39] *** JimmyZ left
[15:43] *** Ross joined
[15:44] <lisppaste3> cognominal pasted "I expected that this subclassing would worl" at http://paste.lisp.org/display/100464

[15:45] <cognominal> probably pmichaud or jnthn are the most qualified to help

[15:45] <cognominal> Apparently I cargo culted something...

[15:45] <jnthn> Where are you trying to run this? Rakudo?

[15:45] <cognominal> yup

[15:46] <jnthn> Maybe it's HLL issues

[15:46] <cognominal> probably I  aped npq code.

[15:46] <jnthn> (PCT::Dumper lives in parrot I guess)

[15:46] <jnthn> try like

[15:47] <jnthn> $P0 = get_root_global ['parrot';'PCT'], 'Dumper'

[15:47] <jnthn> And 'parent'=>$P0

[15:47] <jnthn> may work

[15:48] <jnthn> You may want a class HTMLDumper { ... } above too, just to keep the parser happy when it sees the augment.

[15:48] <jnthn> oh, otoh the BEGIN block will put the thingy in the namespace

[15:48] <jnthn> So it'll work anyway I guess.

[15:49] <cognominal> jnthn++ #  Can't augment class HTMLDumper without 'use MONKEY_TYPING'

[15:49] <cognominal> I am getting there :)

[15:49] <jnthn> oh, you need that too, yeah :-)

[15:50] <cognominal> some errors are less frightning to me )

[15:50] <jnthn> When they're less frightening, that means they're good ones. :-)

[15:51] <cognominal> I hope to make perl6 code navigage using the web eventually

[15:51] <cognominal> *navigable

[15:51] <cognominal> ideally,  "eventually" means for fpw

[15:52] <cognominal> jnthn, you have a talk cut for you "crossing boundaries between rakudo and parrot"

[15:54] <snarkyboojum> typo in S02-bits.pod line 1087 "in the sense that it always calls any closure it finds *it its list" should be "in" :)

[15:55] <cognominal> now,  Class HTMLDumper already registered!

[15:59] <cognominal> ho, nope :(

[16:00] *** SmokeMachine left
[16:00] <snarkyboojum> oh wait, I might have commit access

[16:01] <cognominal> i mistyped parent, back to  Parent isn't a Class

[16:01] <pugssvn> r30782 | snarkyboojum++ | [S02] typo fix 

[16:04] *** SmokeMachine joined
[16:06] <cognominal> f* me, read the error message!!

[16:06] <pmichaud> yay!  all tests pass!

[16:07] <moritz_> \o/

[16:07] <isBEKaml> pmichaud++ \o/

[16:07] <pugssvn> r30783 | pmichaud++ | [t/spec]:  Fudge out some sequential-alternation tests. 

[16:07] <pmichaud> (big) push coming :)

[16:08] <snarkyboojum> :)

[16:09] <cognominal> pmichaud++

[16:09] *** hercynium joined
[16:09] <colomon> \o/

[16:10] <jnthn> pmichaud++

[16:10] * jnthn builds latest

[16:12] <dalek> rakudo: d034418 | pmichaud++ |  (8 files):

[16:12] <dalek> rakudo: Revert "Regex Interpolation"

[16:12] <dalek> rakudo: This reverts commit b9f260d67840c2013c4abbc90491bea52533142b.

[16:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d0344186acd78d3dea9aed52acf879b073398e2d

[16:12] <dalek> rakudo: 3362b1a | pmichaud++ | src/Perl6/ (2 files):

[16:12] <dalek> rakudo: Refactor <codeblock>-related assertions.

[16:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3362b1aa47a5afced72dc3f03422c02d2e6a4854

[16:12] <dalek> rakudo: f9a12d2 | pmichaud++ | src/Perl6/ (2 files):

[16:12] <dalek> rakudo: Add variable assertions.

[16:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f9a12d2e7c714d0a8a2be2f709bea7140127a4b0

[16:12] <dalek> rakudo: a48d4df | pmichaud++ | build/PARROT_REVISION:

[16:12] <dalek> rakudo: Bump PARROT_REVISION to get nqp's "does invokable" fixes.

[16:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a48d4df516dff83112790ca3cb04676a3f4bdf4f

[16:12] <dalek> rakudo: 263a905 | pmichaud++ |  (4 files):

[16:12] <masak> pmichaud++ \o/

[16:12] * masak builds too

[16:12] * moritz_ recommends to merge with --no-ff

[16:13] <cognominal> --no-ff?

[16:13] <moritz_> no-fast-forward

[16:13] <sorear> why?

[16:13] <moritz_> because that way it's much easier to see what belonged to the branch

[16:14] <moritz_> and for example bisecting along the master branch shows the branch as one commit, not as many

[16:14] <cognominal> too late...

[16:14] <XaeroOne> does perl6 have something like XS?

[16:14] <moritz_> it's no big deal, just something which I'd like to propose as best practise

[16:14] <moritz_> XaeroOne: http://github.com/jnthn/zavolaj

[16:15] <XaeroOne> thanks

[16:16] <sorear> XaeroOne: Not really.  zavolaj handles foreign binding pretty well, but we don't have anything for the other use cases

[16:18] <jnthn> sorear: That said, there's a bunch more introspectable stuff from Perl 6 land too.

[16:19] <jnthn> sorear: And other ways to extend things.

[16:19] <jnthn> So hopefully many of those bits of XS won't need dropping to C.

[16:19] <jnthn> Or...whatever Perl 6 happens to be running on...

[16:19] *** simcop2387 left
[16:20] <sorear> I'm a member of the "profile, then rewrite 10% in a lower level language" school of optimization

[16:20] * moritz_ would kinda love a C::function__sig(args) interface like we have with pir::

[16:20] <sorear> ooooooh

[16:20] <sorear> Yes.

[16:21] <moritz_> "powered by macros", maybe

[16:21] <sorear> compiler_psuedo_package is absolutely doable as a macro in my new (unimplemented) framework

[16:21] *** mberends joined
[16:22] <pmichaud> when NCI gets cleaned up a bit better in Parrot, then c::function(...)  seems very doable.

[16:22] * jnthn spotted the new NCI proposal today

[16:22] <moritz_> sorear: implement it! :-)

[16:22] <sorear> how does it differ from the old proposal?

[16:23] <pmichaud> lunchtime here, then repl

[16:23] <jnthn> sorear: Well, differs from current reality more than an old proposal.

[16:23] <sorear> \o/

[16:23] <jnthn> sorear: Seems there's syntax for structs that can be declared right in there.

[16:23] <jnthn> Plus adds missing types

[16:23] <jnthn> It's on Parrot mailing list.

[16:24] <jnthn> I didn't give it a good look yet, just glanced through it earlier and was happy to see someone working on it. :-)

[16:24] <sorear> same here.

[16:25] *** TiMBuS left
[16:25] <cognominal> whate the difference between NCI and zavolaj? is this between a spec and animplementation?

[16:25] *** clintongormley joined
[16:25] <jnthn> cognominal: NCI (as I was talking about it here) is the Parrot layer.

[16:26] <jnthn> cognominal: Zavolaj is a Perl 6 module written atop of that so that you may write Perl 6 subs with Perl 6 signatures, mark them as native and coming from a library, and then Zavolaj introspects the signature and builds a Parrot NCI signature and makes the sub a call forwarder.

[16:26] *** patspam joined
[16:27] <jnthn> cognominal: See the mysql example to get an idea of some of what it can do.

[16:28] *** justatheory joined
[16:28] <pmichaud> jnthn: I'm thinking of a new dynop:     find_outer_lexpad <pmc>, <str>

[16:28] <jnthn> <str> ?

[16:28] <pmichaud> given a Sub pmc, it follows the outer contexts until it finds the lexpad that contains <str>

[16:28] <jnthn> oh

[16:28] <pmichaud> in our case, we would have

[16:29] <jnthn> OK, makes sense.

[16:29] <pmichaud>     lexpad = find_outer_lexpad $replacement, '$/'

[16:29] <jnthn> The name find_outer_lexpad_containing ...

[16:29] <jnthn> ...is too long

[16:29] <jnthn> :-)

[16:29] <jnthn> Though clearer. :-)

[16:29] <pmichaud> well, all of the other find*lex always include a symbol :-)

[16:29] *** rgrau left
[16:29] <jnthn> It didn't say any of those were well named. :-P

[16:29] <pmichaud> there is that :-)

[16:30] <jnthn> Anyway, +1. It's a nice general mechanism.

[16:30] <pmichaud> right

[16:30] <jnthn> Plus, if you can get hold of the lexpad, you can look the thing up *and* bind into it.

[16:30] <jnthn> So no need for a matching store op.

[16:30] <pmichaud> right

[16:30] <pmichaud> right

[16:30] <jnthn> Plus get the $_ in the same scope, if that was ever gonna be interesting. Or the $!. Or something. :-)

[16:31] <TimToady> sorear: re recalc, it's done in _AUTOLEXgen about line 1937; uses moose to find all visible methods and calls each one's PEEK to get its sublexer.

[16:31] <jnthn> pmichaud: Actually it may be that this makes callsame and friends neater... 

[16:31] <sorear> TimToady: How does it know to rerun in subclasses?

[16:31] <jnthn> pmichaud: Or maybe covers some or all of what the dynop involved in that business does.

[16:31] <pmichaud> I've also considered  find_dynamic_lexpad  and find_lexpad variants as well

[16:31] <TimToady> it's called JIT

[16:31] <TimToady> on the actual call into the subclass's method

[16:31] <pmichaud> anyway, I'll do find_outer_lexpad a bit later, if nobody beats me to it.  :)

[16:32] <TimToady> of course, the recalc is expensive, so we try to avoid it if possible

[16:32] *** gbacon left
[16:32] <TimToady> two main ways

[16:32] <pmichaud> time for lunch here -- bbiah

[16:32] <TimToady> first, caching, both in-memrory and on-disk

[16:32] *** pyrimidine joined
[16:33] *** simcop2387 joined
[16:33] <TimToady> second, when we know it's an anonymous language such as from a macro, we actually look at its parent's lexer, and if none of the fates mention the current category, we know that we can just copy it down, since nothing will be recalculated

[16:33] <TimToady> that'd done at line 1818

[16:34] <TimToady> it's kinda convenient that the fates also track the dependencies

[16:35] *** SmokeMachine left
[16:36] <sorear> oh I see, $::LEXERS is keyed on the *class*

[16:36] <TimToady> we could probably do more with that, though it's possible it could make things worse, if the 'peek' on the superclass forces lexer generation where we happened to have never needed the lexer

[16:36] <TimToady> and, in fact, that could be one of the things that slows down a list of operator overloads that aren't actually used

[16:38] <TimToady> yes, ref $self, and the //= is the typical "I'm a cache" idiom

[16:38] <TimToady> obviously, requires 5.10 :)

[16:39] <TimToady> and then after we gen the lexer, we cache linked lists for fates, since they can share tails

[16:39] <TimToady> and then we load up the trie for constant prefixes

[16:40] <TimToady> if we had a better nodal representation of the regexes, we could extend that trie into a parallel nfa

[16:41] <TimToady> currently, all the non-constant regexen are just evaluated at the position where they make that transition

[16:43] *** ilogger2 joined
[16:43] <TimToady> well, we could, instead of node pointers, just keep offsets into the regex strings, but that's icky

[16:43] <moritz_> std: / <[ \xdefg ]> /

[16:44] <p6eval> std 30783: OUTPUT«ok 00:01 115m␤»

[16:44] *** stephenlb joined
[16:44] <TimToady> oh, I have a fix for the \u thing there

[16:44] <moritz_> is that the same as <[ \xdef g ]> ?

[16:44] <moritz_> or are hex chars always supposed to come in pairs?

[16:44] <TimToady> yes, \x, \o, \b etc always eat as much as they can

[16:45] *** SmokeMachine joined
[16:45] <TimToady> which is not much of a burden when you can always put whitespace

[16:45] <TimToady> or use []

[16:45] <moritz_> ok

[16:45] <moritz_> just wanted to know how to implment it

[16:46] <pugssvn> r30784 | lwall++ | [STD] fix up backslashes in character classes to allow \s etc, and reject \u etc. 

[16:46] <pugssvn> r30785 | sorear++ | [viv] Implement 'proto' regexes 

[16:47] <TimToady> er, not \b

[16:47] <sorear> TimToady: what is the arrow munging around gimme5 line 430 for?

[16:49] <TimToady> it's just installing a 'sym' parameter before the -->

[16:49] *** am0c joined
[16:49] <TimToady> derived from the :sym<op>

[16:49] <sorear> what's the -->?

[16:49] <TimToady> the return type comes after it

[16:49] <sorear> ...what? in perl5?

[16:51] <TimToady> the sig isn't really processed into p5 until down about line 509

[16:52] <sorear> oh

[16:52] <TimToady> and the return type is the first thing stripped off there

[16:53] <TimToady> so the line you were asking about eventually produces a p5 line such as:     local $::sym = $args{sym} // 'twigil';

[16:55] *** snarkyboojum joined
[16:55] *** cdarroch joined
[16:55] *** cdarroch left
[16:55] *** cdarroch joined
[16:55] <TimToady> this poking into the sig somewhat predates the ability to declare contextuals within a regex, which is why it ended up being "declared" as a fake parameter

[16:55] <TimToady> it's a bit of a fossil these days

[16:56] <TimToady> nobody is really expected to pass :sym as an argument

[16:57] <TimToady> it's just abusing the named parameter mechanism to fake a declaration of $*sym

[16:58] <TimToady> which used to be used by the <sym> rule as a default

[16:58] <TimToady> when we actually had a <sym> rule

[16:59] <TimToady> nowadays gimme5 just inlines the check for the literal symbol

[16:59] <TimToady> and also inlines any 'endsym' check such as for a word boundary

[17:00] <sorear> what's the standard way to pull a value out of a colonpair in compile time code?

[17:02] *** SmokeMachine left
[17:06] *** ruoso_ joined
[17:08] *** ash___ joined
[17:12] <TimToady> there is no standard yet, it's all ad hoc, and some of it is ad hoccer than others

[17:12] <TimToady> the most complete one is probably in the slightly misnamed add_macro

[17:12] <TimToady> it will be very much simpler when we can just eval some AST

[17:15] *** Trashlord joined
[17:15] <TimToady> I think maybe I'll rename add_macro to add_categorical

[17:16] *** ash___ left
[17:16] <pugssvn> r30786 | moritz++ | [t/spec] unfudge complex number comparison tests for rakudo, colomon++ 

[17:18] *** Trashlord left
[17:19] *** Trashlord joined
[17:20] <moritz_> rakudo: say 'a' ~~ /(o) | (.)/; say $1

[17:20] <p6eval> rakudo 52a137: OUTPUT«a␤Any()␤»

[17:20] <moritz_> rakudo: say 'a' ~~ /(o) | (.)/; say $0

[17:20] <p6eval> rakudo 52a137: OUTPUT«a␤a␤»

[17:20] <moritz_> uhm

[17:20] <moritz_> is that correct?

[17:20] <moritz_> I thought (o) would be the $0 capture, and (.) the $1 

[17:21] * moritz_ re-reads S05

[17:21] <TimToady> no, alternatives restart the count

[17:21] <TimToady> it's in there somewhere

[17:21] <pugssvn> r30787 | lwall++ | [STD,Cursor] rename add_macro (which it doesn't) to add_categorical (which it does) 

[17:22] <TimToady> S05:3017

[17:22] <TimToady> first hit on /restarts

[17:23] <moritz_> just found it

[17:23] <moritz_> it's easy if you know what you need to look for :-)

[17:24] <TimToady> and p6 is easy to implement if you know what code to write :P

[17:27] <TimToady> moritz_: on putting Whatever outside of Any, I proposed that once upon a time, but these days * op 42 is supposed to be recognized by the compiler, by spec, so the exact dispatch semantics are a bit less crucial

[17:28] <TimToady> but we could still probably put it outside of Any, alongside Junction and the conjectural Each

[17:29] *** snarkyboojum left
[17:29] <TimToady> maybe someday those will all be derived from Concept, which is derived from Mu

[17:29] *** SmokeMachine joined
[17:31] <TimToady> maybe there's a better word than Concept

[17:31] <pugssvn> r30788 | sorear++ | [viv] implement 'multi' regexes 

[17:33] <TimToady> I guess they're all meta-programming notions

[17:34] <sorear> how is the ENDSYM translation supposed to work?

[17:35] <TimToady> it inlines the call right after it inlines the sym

[17:35] <sorear> examples of use?

[17:35] <sorear> oh, I see

[17:36] <sorear> is it a STD.pm6 specific thing?  I don't see anything on it in S05

[17:38] <TimToady> it's probably more generally useful than just for STD, I suppose

[17:38] <TimToady> but it's probably going to fall out of how we've redefined protos

[17:39] <TimToady> and be specified inside the proto's block instead of a a trait

[17:39] <sorear> is STD's usage fossily?

[17:40] *** SmokeMachine left
[17:40] <TimToady> so the proto does something like { :my $*endsym = 'nofun'; <callsame> }

[17:40] <TimToady> yes, somewhat fossily

[17:41] <TimToady> so instead of just throwing away the current <...> and replacing it with the proto's subdispatcher

[17:41] <TimToady> that's just substituted in for the <callsame>/<nextsame>

[17:41] *** jbwiv joined
[17:41] <TimToady> that's the direction I'm headed, one of these days

[17:41] <TimToady> so the proto gets full "wrapper" privileges

[17:42] <TimToady> and can even usurp the category entirely

[17:43] <TimToady> so you can override an entire category and make it not inherited in a subgrammar using proto token mycategory { <?> }

[17:44] <TimToady> or put an error message in there saying "You can't do that in this DSL!?!?!"

[17:45] <pmichaud> back

[17:45] <TimToady> anyway, as usual, traits are a smell

[17:45] <TimToady> so endsym will be going away in favor of a contextual, or some such

[17:46] <TimToady> hmm, 'dynamic variable' is just too hard to say

[17:46] <TimToady> how soon till we shorten it to dynavar?

[17:47] <pmichaud> I think it just happened.

[17:47] <TimToady> starvar

[17:47] <pmichaud> although I've sometimes done "dynvar"

[17:47] <TimToady> 'course, some starvars don't var

[17:48] <pmichaud> "constants aren't, variables won't"?

[17:48] <TimToady> dynathingy...

[17:48] <TimToady> if it's small, it could be a dynamite

[17:49] <sorear> dyvar

[17:49] <sorear> TimToady: so <sym> has to depend on a contextual at run time?

[17:49] <sorear> unneccessary dynamic dependencies are also a smell to me...

[17:49] <TimToady> troo

[17:51] <TimToady> so maybe it stays a trait, but we're still making proto bodies useful (if normally inlined)

[17:51] <TimToady> so the dynamic mechanism will be there if we want it someday

[17:52] * sorear punts on endsym handling for now

[17:53] <sorear> what is _SYM in Cursor for?

[17:57] <TimToady> it's the rule that matches <sym> if we can't inline it

[17:57] <TimToady> gimme5:1964

[17:58] <TimToady> (which is unreachable code)

[17:59] <sorear> is there any full perl6 situation where <sym> can't be inlined?

[17:59] <lisppaste3> cognominal pasted "contents of Q:PIR in a BEGIN is executed twice" at http://paste.lisp.org/display/100472

[18:00] <sorear> yes, BEGIN blocks are executed twice

[18:00] <cognominal> why?

[18:00] <TimToady> it would appear that the only place that calls it anymore is Cursor.pmc:2393

[18:01] <cognominal> th

[18:01] <sorear> if we don't run them immediately during parsing, we're going to parse the rest of the file with wrong assumptions

[18:01] <cognominal> I mean normal stuff in a BEGIN is not executed twice. It is proper to stuff in Q:PIR apparently

[18:01] <jnthn> sorear: Aye, though we're meant to only run them once in any given execution of Rakudo.

[18:01] <sorear> oh

[18:02] <TimToady> sorear: if we were to force the setting of $*sym before the proto call, then a proto could match <sym> <endsym> generically

[18:02] <sorear> ineresting.

[18:02] <jnthn> rakudo: BEGIN { Q:PIR { say "hi" } }

[18:02] <p6eval> rakudo 52a137: OUTPUT«hi␤hi␤»

[18:02] <jnthn> wtf

[18:02] <jnthn> I thought I'd fixed that.

[18:02] <jnthn> rakudo: BEGIN { say 42 }

[18:02] <p6eval> rakudo 52a137: OUTPUT«42␤»

[18:02] <jnthn> ...

[18:02] <jnthn> huh.

[18:02] <sorear> perl -p -e 'next if /^---/../\A\w+\Z/;' -e 's/\A[ \t]+//;' STD.pm5 >STD.pmc

[18:02] <sorear> what?

[18:02] <jnthn> So what's special about Q:PIR ...

[18:03] <TimToady> rakudo: BEGIN { say 42 }; 42 42

[18:03] <p6eval> rakudo 52a137: OUTPUT«42␤Confused at line 11, near "42 42"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[18:03] <TimToady> rakudo: BEGIN { Q:PIR { say "hi" } }; 42 42

[18:03] <p6eval> rakudo 52a137: OUTPUT«hi␤Confused at line 11, near "42 42"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[18:03] <cognominal> hum  it is exectued twice when there is Q:PIR including stuff outside the Q:PIR

[18:04] <TimToady> only one 'hi' before the parsefail

[18:04] <cognominal> I am sure jonathan will fix that in a jiffy :)

[18:04] <pmichaud>     get_hll_global $P35, ["Perl6";"Actions"], "%BEGINDONE"

[18:04] <pmichaud>     set $P36, $P35["BEGINDONE_12"]

[18:04] <pmichaud> what is that for?!?

[18:05] <TimToady> sorear: that's just removing leading whitespace so p5 can parse it faster, but not removing the whitespace from the embedded yaml

[18:05] *** SmokeMachine joined
[18:06] <jnthn> pmichaud: What I just said - making sure we don't run it during the parse *and* at runtime.

[18:06] <pmichaud> jnthn: fire_phasers is supposed to take care of that already

[18:06] <pmichaud> you should just be able to fire the BEGIN phaser and it'll be prevented from firing again later

[18:06] <TimToady> BEGIN ought to simply remove any reference to itself once it is run, I'd think

[18:06] <cognominal> your phasers are firing before aiming :)

[18:08] <TimToady> the whole point of BEGIN is to fire before aiming, and not after :)

[18:08] <cognominal> but twice?

[18:08] <TimToady> since BEGIN is the fire that is creating the cannon :)

[18:09] <TimToady> I said *not* after

[18:09] <pmichaud> with %BEGINDONE there's also a huge potential for conflict among loaded modules that also have BEGIN blogs (that might also be called "BEGINDONE_12")

[18:09] <TimToady> you don't want to melt your cannon again after you've made it

[18:09] <pmichaud> anyway, I suggest using the built-in fire_phasers mechanism rather than inventing another wheel.  if fire_phasers isn't doing the right thing, we can fix that.

[18:09] <TimToady> that tends to have deleterious results

[18:09] * pmichaud wonders about the KABOOM phaser.

[18:10] <TimToady> does fire_phasers have a :delete-on-completion option?

[18:10] <pmichaud> TimToady: We could add that, yes.  More precisely, fire_phasers keeps track of everything it's fired and refuses to fire it again.

[18:10] <TimToady> seems like it'd be useful for any kind of only-do-once semantics

[18:11] <TimToady> if you delete it, you *know* you can't fire it again, unless someone keeps a reference to it sekritly

[18:11] <pmichaud> that's the problem -- Parrot tends to have lots of sekrit references

[18:11] <pmichaud> so, we delete it *and* we keep track of it (but not by reference) so that it's not fired again.

[18:11] <pmichaud> (it's kept track of by uuid)

[18:12] <TimToady> I suppose if you deleted parrot you'd also delete some references you want to keep  :)

[18:12] <pmichaud>     "!begin_unless_begun"("BEGINDONE_12", $P38)

[18:12] <pmichaud> ugh

[18:13] <TimToady> maybe you need a fire_and_forget command :)

[18:14] <TimToady> well, I suppose that metaphor doesn't really work, since have to wait for it to hit its target

[18:14] <TimToady> *since you

[18:14] <cognominal> fire and forget,  like in Doctor StrangeLove

[18:15] <cognominal> no problem with supporting users anymore

[18:17] <jnthn> pmichaud: I guess I musta taken the "this is wrong" comment above the begin phaser impl to mean it was wrong to be using the fire phasers mechanism.

[18:17] <jnthn> I guess we could tweak that to do the righ tkinda thing.

[18:17] * pmichaud looks

[18:17] <jnthn> TimToady: The problem kinda is that if somebody writes BEGIN { @*INC.push('blah') }

[18:18] <jnthn> TimToady: Then pre-compiles to a bytecode file...

[18:18] <jnthn> ...they'll probably be surprised when @*INC doesn't contain blah when they run the compiled bytecode.

[18:18] <pmichaud> jnthn: "this is wrong" comment?

[18:20] <pmichaud> jnthn: I would think that BEGIN could work with

[18:21] <jnthn> pmichaud: The one that used to be above the begin phaser.

[18:21] <jnthn> Which I was attempting to deal with.

[18:21] <pmichaud> method statement_prefix:sym<BEGIN>($/) { add_phaser($/, 'BEGIN'); Q:PIR { '!fire_phasers'('BEGIN') }; }

[18:21] <pmichaud> or something like that

[18:21] <pmichaud> I'll go look at previous code to see if I can remember the genesis of the comment

[18:21] <jnthn> pmichaud: What does that do with the return value?

[18:22] <jnthn> Also, does it immediately compile the code?

[18:22] <pmichaud> it can do so, if we want it to

[18:22] <jnthn> OK

[18:22] *** gbacon joined
[18:22] <jnthn> It just felt like quite a lot of changes for the fire phasers stuff.

[18:23] <pmichaud> at one point, I had !add_phaser so that a phase of 'BEGIN' automatically invoked the item

[18:23] <jnthn> Could it return some "handle" to then emit into the code and access the value at runtime?

[18:23] <cognominal> afk&

[18:24] <pmichaud> jnthn: yes, that would seem to make sense

[18:24] <jnthn> Anyway, if your intention is that fire_phasers handles that, I can re-work things to do so.

[18:24] <pmichaud> we probably need that for CHECK / INIT also, anyway

[18:24] <jnthn> It just wasn't clear to me at the time that was the way to go.

[18:25] <pmichaud> yes, my intention is that fire_phasers is used to handle the various phases of execution

[18:25] <jnthn> OK

[18:25] <jnthn> Then sorry for mis-guessing. :-)

[18:25] <pmichaud> including BEGIN, if possible

[18:25] <pmichaud> oh

[18:25] <pmichaud> (looked at the comment)

[18:25] <pmichaud> # XXX BEGIN isn't correct here, but I'm adding it along with this

[18:25] <pmichaud> that one?

[18:26] <jnthn> Yes

[18:26] <pmichaud> I merely meant that the implementation of BEGIN there was incomplete, not that it shouldn't be using fire_phasers

[18:26] <pmichaud> bad comment on my part.

[18:26] <jnthn> "along with this" I guess I took as "along with the add_phaser-y htings"

[18:26] *** meppl joined
[18:26] <jnthn> Whereas I guess you meant, along with this patch, as a starting point. :-)

[18:26] <pmichaud> right

[18:27] <jnthn> Ah well

[18:27] <jnthn> 'tis fixable.

[18:27] <pmichaud> anyway, I'd like it all to go through the add_phaser/fire_phaser mechanism, if possible

[18:27] <pmichaud> and yes, we probably need a way to retrieve the return value from any fired phaser

[18:28] <pmichaud> it'd be fine with me if fire_phasers stored that also

[18:28] <pmichaud> then have some other function to look up return values by phaser

[18:28] <jnthn> OK.

[18:28] <jnthn> Feel free to leave that with me.

[18:28] <jnthn> I'll re-work it.

[18:29] <pmichaud> currently %!PHASERS_FIRED just has a hash which keeps a reference to the phaser.  Would make perfect sense to have it keep the return value of the fired phaser.

[18:29] <jnthn> Aha.

[18:29] <jnthn> Yes.

[18:29] <pmichaud> phasers.pir:67

[18:30] *** patrickas joined
[18:31] <patrickas> sabaho perl6!

[18:31] <TimToady> jnthn: re @*INC, that's why you need to have a freeze/thaw model of the proto-data constructed by the compiler, and not try to figure out which bits of the construction code need to be redone later

[18:31] <moritz_> ni hao patrickas 

[18:32] <patrickas> moritz_ I think I got another patch for a LHF :-)

[18:32] <moritz_> patrickas: \o/

[18:32] <patrickas> I'll mail you the diff ... 

[18:32] <moritz_> si tu veux

[18:33] <patrickas> running spectest now ... should be two extra passing tests

[18:33] <jnthn> TimToady: That's quite a requirement on a runtime.

[18:33] *** Trashlord left
[18:33] <TimToady> it's vastly simpler

[18:33] <patrickas> hehehe je veux je veux.

[18:34] <jnthn> I guess it's muchly what is wanted for the setting, though.

[18:34] <patrickas> Actually I am not sure what is the best practice ... sending diff by email seems really low tech... and I still am not very confortable with git

[18:34] <jnthn> Goes without saying I don't see Rakudo on Parrot being able to get this right all that soon.

[18:34] *** Trashlord joined
[18:34] <jnthn> Though somebody did mention on working on the freeze/thaw bits.

[18:35] <jnthn> plobsing++ iirc.

[18:35] <moritz_> patrickas: the high tech solution is to fork rakudo on github, and push your changes there

[18:35] <TimToady> it's not just BEGIN, it's all code that needs to run at compile time, like constant and enum initializers

[18:35] <moritz_> so you get version control, but if you screw something up you still don't harm the "canonical" rakudo repo

[18:35] <TimToady> lexical variables with proto-values

[18:36] * jnthn -> dinner, back in 20 for #rs.

[18:37] <TimToady> but a data structure that is decided in only one spot is inherently more stable than one that has to be redecided and reconstructed later

[18:37] <patrickas> moritz_: I was trying to merge back your process-cmd-args fork to practice that but I failed miserably ... so I decided to stick to old tech for now :-)

[18:37] <TimToady> this is something I discovered (to my dismay) in Perl 4, which is why Perl 5 does constant folding with the same run-time engine that the normal expressions use

[18:38] <TimToady> Perl 4 had its own constant folder, and it was always out-of-sync with the actual expresion evaluator

[18:39] <TimToady> but making the run-time engine available to the compiler in Perl 5 implies a promise to keep around all the data-structurey side effects of running any code at BEGIN time

[18:40] *** hercynium joined
[18:41] <TimToady> which doesn't matter so much when you just run the program after CHECK time in the same process, like p5 does

[18:41] <TimToady> but it does put the freeze/thaw requirement for separate compilation

[18:43] <TimToady> sorry if it sounds like I'm repeating myself every year or so.  :)

[18:43] <pmichaud> if you are, it's worthwhile repetition.

[18:43] <pmichaud> Parrot's freeze/thaw capabilities just don't quite measure up to the task at present, I fear.

[18:43] <TimToady> I just figure there are some things worth saying too many times rather than too few...

[18:45] <TimToady> with parrot, you might be able to fake it by setting up the namespace/lexical scope skeleton, and then poking the data in after the fact, but that data should probably be harvested by a tree walker, not by trying to dup the original init code

[18:46] <TimToady> since it cannot be proven idempotent

[18:46] <pmichaud> yes, the challenge is to know when to stop walking the tree

[18:46] *** tlb joined
[18:47] <TimToady> basically, the freeze/thaw provides a *transaction*

[18:47] <TimToady> or some kind a sequence point where you know what has happened before, and what has not, and the state is known to be consistent

[18:48] *** kfo_ joined
[18:49] <TimToady> STD's .syml files are a primitive version of that, since STD doesn't have an evaluator, so can't produce "real" data, but it does in fact dump all the lexical scopes and packages

[18:49] <TimToady> adding data to those would be fairly trivial, if I had any data.  :)

[18:50] *** Trashlord left
[18:51] *** kfo left
[18:51] *** Trashlord joined
[18:51] *** kfo_ is now known as kfo

[18:52] * TimToady wanders off to see if there's a suction cup that will fit his hot button so he can pull it back up...

[18:53] *** clintongormley joined
[18:53] *** masak joined
[18:54] <moritz_> #rs in 5?

[18:54] <masak> aye.

[18:54] <moritz_> with our first gsoc report from masak?

[18:55] *** plainhao joined
[18:55] <masak> er, um, sure.

[18:55] <colomon>  \o/

[18:56] <moritz_> speaking of planning stuff... any good ideas for this week's challenge?

[18:56] <colomon> "your challenge is to figure out a good challenge for this week, and then do it."

[18:56] <masak> recursion!

[18:58] <jnthn> omnomnomköttbullar

[18:59] * jnthn is back

[19:00] <masak> 'perl 6 cookbook?' http://use.perl.org/~iaw4/journal/40366

[19:00] <jnthn> ;-)

[19:00] <jnthn> masak: About things Perl 6 devs cook? :-)

[19:00] <moritz_> I know of none

[19:01] * moritz_ made a tasty Lasagne on Sunday

[19:01] * jnthn didn't hear about one

[19:01] <Su-Shee> whut? I just tweeted my bread recipe!

[19:01] <masak> compiling a cookbook is probably too big a week challenge. :P

[19:01] <moritz_> and that barbecue yesterday was quite nice, too

[19:01] <jnthn> I'm glad I just ate, rather than came here hungry. :-)

[19:01] <masak> jnthn: you had meatballs? I had a yummy pasta salad.

[19:02] <jnthn> masak: I make them about once a week now.

[19:02] <jnthn> med lingonsylt och smörgåsgurka ;-)

[19:03] <masak> I hardly ever eat them. my parents refused to cook typically Swedish food, so I never got into the habit of eating it at home. :)

[19:03] *** quietfanatic joined
[19:06] *** ShaneC1 joined
[19:06] * patrickas just encuntered %h1<b>:delete and is kind of confused (so is rakudo) ... I guess means %h1.delete('b') ... where can I read about it ?

[19:06] *** Trashlord left
[19:06] <moritz_> it's the official adverb syntax

[19:06] <moritz_> S03 probably, or so

[19:06] *** ShaneC1 left
[19:07] <masak> NYI.

[19:07] *** smash_ joined
[19:07] <smash_> hello everyone

[19:07] <masak> smash_! \o/

[19:09] <patrickas> cause the t/spec/S32-hash/delete.t test file uses this syntax so none of the tests are being run even though delete itself is implemented

[19:09] *** Trashlord joined
[19:10] *** clintongormley left
[19:10] *** Trashlord is now known as Guest35543

[19:15] *** quietfanatic left
[19:25] *** SmokeMachine left
[19:25] <masak> I see you've been discussing freeze/thaw between the compile phase and the run phase in the backlog. fwiw, that's the model Yapsi is drifting towards. I only wish I knew a blazingly fast way to thaw things with Rakudo.

[19:25] <masak> (preferably not involving &eval)

[19:26] <masak> I don't understand TimToady's comment about the constant folder in Perl 4 being 'out-of-sync with the actual expression evaluator', though. that sounds interesting.

[19:28] *** plainhao left
[19:30] <pugssvn> r30789 | patrickas++ | Modified the delete.t file to use the normal form of delete, this way it can be added to the spec tests. 

[19:30] <pugssvn> r30789 | Created delete_adverb.t which uses the adverbial form that was used in the original file the file should not be added to the spec tests since adverbs seem to be NYI

[19:36] *** tlb left
[19:38] *** Guest35543 left
[19:38] <patrickas> I think S32-array/delete.t can now be safely added to rakudo's t/spectest.data

[19:38] *** Siddy joined
[19:38] *** Siddy is now known as Trashlord

[19:39] * moritz_ tries it

[19:40] *** tlb joined
[19:42] <moritz_> patrickas: btw I have a nicer patch for RT #68482:  return |@deleted

[19:42] *** masak left
[19:42] <moritz_> that way we don't need any special-casing of one-item deletes

[19:42] <patrickas> :-)

[19:43] <patrickas> moritz_++, I love one character patches ... 

[19:43] <moritz_> there's nothing wrong with special-casing, it just feels wrong :-)

[19:44] *** masak joined
[19:44] <patrickas> yea it does :-( but on the bright side it worked :-)

[19:47] *** SmokeMachine joined
[19:48] *** masak left
[19:49] *** masak joined
[19:49] <patrickas> moritz_: |@deleted is a capture ? 

[19:49] <moritz_> patrickas: it's "interpolation into arg list"

[19:50] <moritz_> rakudo: sub f($a, $b) { say "a: $a; b: $b" }; my @a = 1, 2; f(@a)

[19:50] <p6eval> rakudo 52a137: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤current instr.: 'f' pc 241 (EVAL_1:44379420)␤»

[19:50] <moritz_> rakudo: sub f($a, $b) { say "a: $a; b: $b" }; my @a = 1, 2; f(|@a)

[19:50] <p6eval> rakudo 52a137: OUTPUT«a: 1; b: 2␤»

[19:50] <moritz_> in the first example we have just one positional argument, which is an array

[19:50] <moritz_> in the second, the array is interpolated/dissolved into the argument list

[19:51] <patrickas> ok I see ... thx.

[19:52] <dalek> rakudo: baebe1f | moritz++ |  (2 files):

[19:52] <dalek> rakudo: make Hash.delete($one_item) return that item (and not a list of items)

[19:52] <dalek> rakudo: Fixes RT #68482. Inspired by patrickas++

[19:52] <dalek> rakudo: Also adds three more test files (of which two are unrelated)

[19:52] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/baebe1fa18aa821503c38916331c514e52e413e6

[19:52] <TimToady> think of the | as the place where you slice the argument list open with a knife and insert the extra arguments

[19:52] <patrickas> hahaha so I get to be a muse for patches now :-P

[19:53] *** masak left
[19:55] <[particle]> i'm so confused.  i'm at a conference, and "the guy in the second row" is sitting in the last row.

[19:55] <patrickas> TimToady: thx for the image, for some reason it reminds me of Why's (Poignant) Guide to Ruby...

[19:58] <TimToady> [particle]: someone just shuffled the rows before you got there--it's still the second row

[19:58] <TimToady> the last row is actually #4 right now

[19:59] <[particle]> $seat.pick

[20:00] <lisppaste3> pmichaud pasted "<&var> now works" at http://paste.lisp.org/display/100475

[20:01] <jnthn> pmichaud: \o/

[20:02] <lisppaste3> pmichaud pasted "<xyz=&var> now works" at http://paste.lisp.org/display/100476

[20:02] <pmichaud> spectesting, then committing.

[20:03] <pugssvn> r30790 | moritz++ | [t/spec] tests for <&foo> interpolation 

[20:03] <pugssvn> r30791 | moritz++ | [t/spec] some random fudges 

[20:06] <pugssvn> r30792 | pmichaud++ | [t/spec]:  more lexical regex tests 

[20:09] <pugssvn> r30793 | moritz++ | [t/spec] test renaming of lexical regexes with other name 

[20:13] *** _ilbot2 left
[20:14] *** _ilbot2 joined
[20:17] <moritz_> pmichaud: do you need more tests?

[20:23] *** patrickas left
[20:23] * moritz_ -> bed

[20:24] <TimToady> n8

[20:27] <pmichaud> moritz_: no, this is plenty of tests

[20:28] *** pragma_ joined
[20:42] <dalek> rakudo: 2404007 | pmichaud++ |  (2 files):

[20:42] <dalek> rakudo: Add /&var/ and /<&var>/ regex interpolation syntax, and enable tests.

[20:42] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/240400772a8c5f4491760fc05be95db5c37ba281

[20:45] <sorear> !!! pmichaud++

[20:56] <pyrimidine> pmichaud++ # very nice!

[21:06] <PerlJam> $ perl6

[21:06] <PerlJam> > 34+8

[21:06] <PerlJam> 42

[21:06] <PerlJam> *that's* nice

[21:07] <PerlJam> pmichaud++

[21:07] <jnthn> sorear++ too :-)

[21:08] <sorear> jnthn: what did I do???

[21:08] <jnthn> sorear: Worked on auto-print support as well?

[21:09] <sorear> oh, I blinked

[21:09] <sorear> I thought you were still on about <&var>

[21:09] <jnthn> :-)

[21:09] <PerlJam> although ... this isn't nice at all ...

[21:09] <PerlJam> > my $a = 5;

[21:09] <PerlJam> 5

[21:09] <PerlJam> > say $a;

[21:09] <PerlJam> Segmentation fault

[21:09] <jnthn> core blimey!

[21:09] <sorear> PerlJam: known issue (exception handling doesn't work)

[21:10] <sorear> $a needs to be $GLOBAL::a anyway

[21:10] <sorear> no lexical persistence (yet)

[21:10] <sorear> pmichaud has given himself until 20 hours from now to fix that

[21:11] <[Coke]> I've sort of been volunteered to coordinate any parrot issues rakudo needs for the june release. Feel free to assign any trac tickets to me or ask me to follow up on statuses for the next month or so.

[21:12] <[Coke]> though the latest I heard is "just don't break anything"

[21:12] <jnthn> Please don't. ;-)

[21:12] <[Coke]> would probably be good to setup a continuous build to insure that.

[21:12] <jnthn> [Coke]: I guess the GC changes that are being started now will land after it, anyways.

[21:13] <[Coke]> is anyone watching the rakudo smolder reports?

[21:13] <[Coke]> jnthn: I think some of those might land sooner.

[21:13] <jnthn> [Coke]: Ah, OK

[21:13] <jnthn> [Coke]: Cleanup or functional?

[21:14] <[Coke]> bacek is usually pretty good about doing anything invasive on a branch, so we'll have time to test.

[21:14] <[Coke]> and... I don't know. =-)

[21:14] <jnthn> Ok. :)

[21:15] <[Coke]> bacek says "It will be faster."

[21:15] <[Coke]> . o O (whee!)

[21:15] * bacek arrive in flames and smokes

[21:15] <jnthn> \o/

[21:15] <bacek> I will try to make new GC ready for R*

[21:15] <bacek> It's my main goal/driving reason.

[21:16] <PerlJam> "make a new GC" sounds like "break things" to me ;-)

[21:17] <bacek> It is not. Ok. Actually - it will not :)

[21:18] <[Coke]> if it breaks anything, it won't go in. no worries.

[21:19] *** pmurias joined
[21:20] <diakopter> ______________

[21:20] <[Coke]> oh no, he's flatlined.

[21:20] <pmurias> diakopter: hi

[21:21] <[Coke]> diakopter: please assure me that C# is really cool once everything is installed and working. :P

[21:21] <[Coke]> (that's not perl6 related)

[21:21] *** iblechbot joined
[21:21] <diakopter>  /^\ /^\

[21:21] <diakopter> [Coke]: er, hee?

[21:21] <diakopter> by "everything" do you mean mono 2.6.latest? :)

[21:24] * diakopter confused still

[21:24] <diakopter> [Coke]: funny you mention "cool" since "Cool" was the internal codename for C# at microsoft in the late nineties

[21:25] <wolverian> http://projectfortress.sun.com/Projects/Community/blog/OverloadingPartOne I like fortress more and more 

[21:26] <diakopter> C-style Object Oriented Language

[21:27] * diakopter [Coke] I think I missed your joke, if intended :)

[21:28] <diakopter>  /me , /msg , same thing

[21:28] <[Coke]> diakopter: no joke. I'm trying to do some C# work for $DAYJOB, and when it works, it's awesome. when there's an error, I'm completely stumped. =-)

[21:29] <diakopter> o

[21:31] *** gbacon left
[21:31] <dmpk2k> Do conditionals like if or unless return a value?

[21:31] <sorear> TimToady: STD.pm6 parses <sym> as an identifier capture.  Is this correct?

[21:32] *** dj_goku joined
[21:33] <jnthn> dmpk2k: The value of the executed block.

[21:33] <diakopter> but on falseness of the conditional, I think TimToady said Nil

[21:33] <diakopter> [it returns] Nil

[21:33] <jnthn> Ah, yes, if there's no else clause.

[21:35] <diakopter> rakudo: say 4 if (if 4 { say 5 })

[21:35] <p6eval> rakudo baebe1: OUTPUT«5␤4␤»

[21:35] <diakopter> rakudo: say 4 if (if 0 { say 5 })

[21:35] <p6eval> rakudo baebe1:  ( no output )

[21:35] <diakopter> rakudo: say(if 0 { say 5 })

[21:35] <p6eval> rakudo baebe1: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1971 (ext/nqp-rx/src/stage0/Regex-s0.pir:1050)␤»

[21:35] <dmpk2k> jnthn: thanks. That makes me happy to hear. Why are they called "if statements" then, and not "if expressions"?

[21:35] <diakopter> rakudo: say (if 0 { say 5 })

[21:35] <p6eval> rakudo baebe1: OUTPUT«0␤»

[21:35] <sorear> Because they're not expressions.

[21:35] <dmpk2k> But they return a value.

[21:35] <sorear> rakudo: say if 0 { say 5 }

[21:35] <p6eval> rakudo baebe1: OUTPUT«Confused at line 11, near "say if 0 {"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[21:36] <jnthn> std:  say if 0 { say 5 }

[21:36] <p6eval> std 30793: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/23vt08zCts line 1:␤------> [32msay if 0 [33m⏏[31m{ say 5 }[0m␤    expecting any of:␤      bracketed infix␤  infix or meta-infix␤Other

[21:36] <p6eval> ..potential dif…

[21:36] <sorear> expression ::= '(' statement ')'

[21:36] <sorear> statements return values

[21:36] <sorear> but aren't legal in expressions unless parenthetized

[21:36] <diakopter> rakudo: say [if 0 { say 5 }]

[21:36] <p6eval> rakudo baebe1: OUTPUT«0␤»

[21:36] <diakopter> or otherwise bracketed

[21:37] <jnthn> Essentially, it's a difference in where one can be parsed.

[21:37] <jnthn> And circumfixes tend to parse a statementlist within them.

[21:37] *** iblechbot left
[21:38] <dmpk2k> Okay. Thanks for the clarification.

[21:39] <dmpk2k> Are there things in Perl6 that cannot return a value?

[21:41] <diakopter> what else would they return? :P

[21:41] <sorear> Gather blocks?

[21:41] <sorear> Infinite loops?

[21:41] <sorear> Die statements?

[21:42] <jnthn> sorear: Gather blocks return an iterator. That's a value. :-)

[21:42] <pmichaud> s/iterator/list/  :-)

[21:42] <pmichaud> (it's a lazy list, but still a list.)

[21:42] <jnthn> list *containing* an iterator ;-)

[21:42] <jnthn> But yes

[21:42] * jnthn is too used to That Rakudo Leakage.

[21:42] <pmichaud> return an Iterable :-)

[21:43] *** SmokeMachine left
[21:44] <diakopter> dmpk2k: I was punning; does anything never *return*? nothing that doesn't also exist in nearly every other language. (as sorear implied, I suspect)

[21:44] <bkeeler> Heya folks, sorry I missed the #rs.  I'll read over the logs...

[21:45] <jnthn> o/ bkeeler 

[21:45] <dmpk2k> diakopter: I'm sorry, I'm having trouble parsing the second sentence. ^^;

[21:46] <diakopter> oops, too many negnegnegatives

[21:47] <diakopter> infinite loops & things that cause the entire language environment to exit.

[21:47] <diakopter> (as sorear said)

[21:49] <dmpk2k> Thanks. I just wanted to know if things like conditional statements can return a value since I'm quiet a fan of the idioms that makes possible.

[21:50] <sorear> Also, comments.

[21:50] <[particle]> hee

[21:50] <[particle]> return unless # foo

[21:50] <sorear> dmpk2k: perl6 has a ternary operator

[21:51] <[particle]> comments returning values would be very silly

[21:51] <[particle]> sounds like a great module

[21:52] <sorear> [particle]: http://search.cpan.org/~chorny/Smart-Comments-1.0.4/lib/Smart/Comments.pm

[21:55] <dmpk2k> sorear: ternary operators alone returning a value is a bit limiting. I think the more functional approach where (almost) everything is an expression is more interesting.

[21:55] *** ruoso_ left
[21:56] <dmpk2k> Or, in Perl6's case, wrap parens around it.

[21:58] <pugssvn> r30794 | sorear++ | [viv] Implement <sym> rule 

[22:05] *** whiteknight joined
[22:05] *** stephenlb left
[22:05] *** stephenlb joined
[22:17] <sorear> TimToady: What is _SYM for?

[22:18] <sorear> TimToady: What are tweaks?

[22:19] <TimToady> _SYM is for matching <sym> when we don't know its literal value, iirc

[22:19] <TimToady> tweaks are grammar mixins

[22:19] <sorear> what is %impute used for?

[22:19] <TimToady> don't recall, lemme look

[22:19] <sorear> %impure

[22:20] * sorear is about to make the viv regex compiler much more similar to gimme5's

[22:20] <TimToady> it used to be that way, but that's less extensible, I think

[22:24] <TimToady> %impure says that this method has no PEEK, and will therefore terminate LTM

[22:25] <sorear> The current viv regex compiler is entirely my creation

[22:25] <sorear> and it sucks

[22:25] <sorear> I have a VAST->RE_ast walker and a VAST->perl5 walker

[22:25] <sorear> this makes for DRY problems

[22:26] <sorear> I'm going to change it into a VAST->RE_ast walker and a RE_ast->perl5 walker

[22:26] *** spinclad joined
[22:26] <sorear> the latter component of which will be able to take code directly from gimme5

[22:27] <TimToady> okay, that seems sensible

[22:27] *** pmurias left
[22:28] * TimToady always sees "parser" when people say "compiler", and it's a hard habit to break  :)

[22:30] <sorear> current viv is powerful enough to translate "sigil" from STD.pm6

[22:32] *** smash_ left
[22:33] <TimToady> as in proto token sigil and all the multis?

[22:35] <sorear> yes

[22:36] <sorear> TimToady: what is 'min' in RE_ast used for?

[22:36] <TimToady> ultimately, left-recursion detection in LTM calculation

[22:36] <TimToady> the only important values are really 0, 1, and 'many'

[22:37] <sorear> this is something I do not understand at the moment

[22:37] *** whiteknight left
[22:39] * sorear attempts to understand the LTM calculator

[22:39] <TimToady> the important line from RE_ast.pm is $Cursor::fakepos++ if $self->{'min'};

[22:39] <sorear> what does that do?

[22:40] <TimToady> if the fake position doesn't advance on revisiting a token rule, we've got infinite recursion

[22:40] <sorear> Is infinite recursion always an internal error?

[22:41] <sorear> What is the magic of :: at Cursor.pmc +1806?

[22:41] <TimToady> used to be an error, but I think it just cuts off LTM at that spot these days, and the token in question just has a shorter LTM

[22:41] <TimToady> so it can only match if longer things don't

[22:42] <sorear> Under what circumstances is it legal for a left recursive grammar to be generated?

[22:42] <sorear> Is left recursion in perl 6 rules legal?

[22:43] <TimToady> technically, yes, it's allowed to write an infinite loop :)

[22:43] <TimToady> but the situation doesn't arise often in practice in Perl 6, at least

[22:43] <TimToady> because nearly all such loops are mediated by EXPR, which requires a term

[22:44] <sorear> Why doesn't cursor just die if you write a loop?

[22:44] <sorear> Perl automatically breaking while 1 { } would be suprising

[22:44] <TimToady> there might be valid reasons for writing a left recursion that is stopped by a constraint further on in the pattern

[22:45] <sorear> If the constraint is further on in the pattern, how can it break a loop at the beginning?

[22:46] <TimToady> well, the state could have changed somehow in the recursion, I should have said

[22:46] <TimToady> accidental recursions are typically fairly deep before they get back to the original rule

[22:47] <sorear> Cursor uses pos().  Heh.

[22:47] <TimToady> so it's not so much that the deeper rule looks farther, but with (potentially) more information

[22:48] <TimToady> yes, Cursor goes back and forth between matching on the $::ORIG string and the @::ORIG array of ords

[22:49] <TimToady> when checking @::ORIG we can just stick with the .pos from the Cursor, but any time we dip down in p5 regex of unknown length, we have to do the pos() dance

[22:50] <TimToady> hopefully the new pos is not far from the old one, so p5's pos cache doesn't have to scan utf-8 very far

[22:54] <diakopter> was someone referring to the p-o-s acronym?

[22:55] <sorear> Cursor uses tries to optimize the literal prefix case of the LTM hierarchy?

[22:55] <TimToady> it uses a trie match for literals, yes

[22:55] <TimToady> I talked about that earlier today, maybe you missed it

[22:55] <sorear> And at the ends of the tries are big lists of regexes that are used for LTM matching

[22:56] <sorear> Maybe, or maybe I just didn't understand it

[22:56] <TimToady> there's only regexes at the end if there was a common prefix of the same length

[22:57] <TimToady> usually there's 0 or 1 regexes at the end of each chain

[22:58] <TimToady> my point earlier is that we could evolve the current trie into a DFA-ish graph if we could manage pointers into the middles of those regexes that currently hang off of various points in the trie

[22:58] *** cdarroch left
[22:58] <sorear> which is to say, if we had our own regex compiler instead of relying on p5

[22:58] * diakopter giggles childishly

[22:59] <TimToady> yes, but just having *a* regex compiler isn't good enough, since there are lot of unsuitable ones out there already :)

[22:59] *** Psyche^ joined
[23:00] <sorear> if I look in a lexer, say lex/STD/P6/term, why do I see 231 regexes?

[23:00] <TimToady> we need an approach more like egrep uses, where it's managing a set of active states based on the current input

[23:00] <sorear> is the "usually 0 or 1" thing done after storage?

[23:00] <sorear> TimToady: Direct NFA execution?

[23:00] * sorear is not familiar with the egrep guts

[23:01] <TimToady> I don't know what "direct" means

[23:01] <sorear> not translating to DFA first

[23:02] <TimToady> yes, more of a parallel NFA is wanted here, I think, but with good caching characteristics based on the tokenization problem space

[23:02] <TimToady> since as you traverse your parallel NFA, you're continuing to build up the trie as a set of cached NFA decisions so you don't have to do set theory again

[23:03] <sorear> Cursor.pmc +1806

[23:03] * justatheory does set TimToady 

[23:03] <sorear> what's so magical about :: ?

[23:03] <TimToady> you mean (?#::) ?

[23:03] *** tlb left
[23:03] <sorear> yes

[23:04] <sorear> the comment makes me think :: matters

[23:04] *** Psyche^ is now known as Patterner

[23:04] <sorear> or do I need to read perlre again

[23:04] <TimToady> that's a p5 comment that I'm using to mark a transition from declarative to procedural

[23:04] <TimToady> the :: is mnemonic for the backtracking control

[23:05] <TimToady> but any side-effect-ish pattern will add the marker

[23:05] <TimToady> and then any rule that uses this as a subrule knows that it should not add any more "tokenstuff" to it

[23:05] <TimToady> on the end, that is

[23:05] <TimToady> it's fine to add prefix

[23:06] <TimToady> in lex/STD/P6/term, it's a very "square" or relational layout

[23:06] <TimToady> with no attempt to gather common prefixs or literal prefixes

[23:06] <TimToady> that's calculated after it's slurped in and turned into trie

[23:06] *** snarkyboojum joined
[23:06] <TimToady> but the file needs to be human readable for debugging purposes

[23:07] <TimToady> the Storable form of cache has this precalculated, however

[23:07] <TimToady> to the extent we do the trie

[23:09] <TimToady> once we actually start caching partial parallel NFA results in the trie, it might be good to run the parser over an amount of typical program to extend the tries with common names, such as come from CORE

[23:09] <TimToady> and cache those in Storable as well

[23:10] <TimToady> currently only the literal prefixes are cached in the Storable trie

[23:11] * sorear perl -MRE_ast -MStorable -MYAML -e 'print Dump retrieve("lex/STD/P6/term.store")'

[23:11] <eternaleye> ly

[23:11] <eternaleye> gah, wrong window

[23:12] <sorear> Wow.

[23:12] <sorear> This is completely clear now.

[23:13] <TimToady> the real performance killers are the ~~ regexes at the beginning of the pattern; those need to be distributed into the trie as we learn how each of those patterns responds to each individual character

[23:14] <TimToady> but currently it just reruns them on each <term> match

[23:14] <TimToady> and sorts them by LTM ruls

[23:14] <TimToady> sorts their results by LTM rules, rather

[23:15] <TimToady> in this case, the yaml elucidates the structure rather nicely, for a change :)

[23:16] <TimToady> but you can see why I haven't touched the LTM in a while, because it's in a metastable state of sorts

[23:16] <TimToady> and it does the semantics more or less correctly, if slowly

[23:16] <TimToady> but there's room for improvement, certainly

[23:17] <TimToady> and, actually, in terms of the PEG tiebreaker rules described at the beginning of S05, it really only does 1, 2, and 4.

[23:19] <TimToady> I'm hoping to push some of these tiebreaking determinations back into the lex/STD/P6/term files as additional columns

[23:19] <TimToady> the length of the literal prefix can be known in advance, and some of the orderings can reflected in the order of the file in question

[23:20] <TimToady> if not in a specific collation datum

[23:22] <sorear> um, should . generate 0x10FFFE trie nodes?

[23:23] <TimToady> example?

[23:24] <sorear> it's a regex

[23:24] <sorear> you feed it every possible character

[23:24] <sorear> then....?

[23:24] <sorear> or is this what you were talking about when you said lazy dfa generation

[23:25] <TimToady> okay, on something like .*? in a nibbler, we'll have to be careful to cut off caching

[23:26] <TimToady> but yes, we only build that subset of DFA reflecting the states for characters that have actually been seen

[23:26] *** alester joined
[23:26] <TimToady> in egrep, this cached set of states is limited to, oh, 10,000 or so, and older unused states are dropped off the end, and reconstructed if needed

[23:27] <sorear> I think the solution for .* is to limit the size of the ... yeah

[23:27] <TimToady> I think of the trie as a fixed set of states for anchored patterns

[23:27] <TimToady> and then longer ones cut loose and do something more like egrep after N characters

[23:28] <TimToady> or at that point we revert to the current ~~ algorithm, as a stopgap

[23:29] <TimToady> it's also a matter for research how much of the trie/dfa info can be shared across different languages, especially if everything is linked listed and there are common tails

[23:30] <TimToady> at the moment, the sharing is all or nothing with a parent grammar's lexer for a particular category

[23:30] *** whiteknight joined
[23:31] <TimToady> again, that's determined within the first 20 or so lines of _AUTOLEXgen, looking at the superlexer for this category  (but only for anonymous languages, since they don't get Storabled)

[23:32] <TimToady> otherwise we'd need a way to name all anonymous languages universally to avoid collisions, and that's...hard

[23:32] <TimToady> I suppose practically we'd just name them all with a large random hash of some sort

[23:32] <TimToady> but you still have the garbage collection problem

[23:33] <TimToady> or lex/ would fill up your disk

[23:33] <TimToady> eventually we'll also have to solve the global lex/ vs per-user lex/ issue

[23:34] <sorear> how much of a win is sending lex/ to disk?

[23:34] <TimToady> but I've specifically been shying away from anything resembling productizing

[23:34] <TimToady> it certainly helps for the 'make snaptest' on the t/ files, which have a lot of commonality

[23:35] <TimToady> even STD.pm6 compiles faster the second time through

[23:35] <TimToady> s/compiles/parses/  #  grr

[23:36] <sorear>         $text =~ s/([[:alpha:]])/'[' . $1 . chr(ord($1)^32) . ']'/eg if $self->{i};

[23:36] <sorear> erm...

[23:36] <TimToady> but it's not clear how much it helps once STD is compiled with most of the common patterns

[23:37] <TimToady> yes, there are ASCII assumptions in various spots still

[23:37] *** ive joined
[23:39] <eternaleye> (re dyvar) my @*sparse = ( 1, 2, Nil, 4) # I can has Holey Dyvar?

[23:41] <TimToady> um, not that way

[23:41] <TimToady> Nil mean ()

[23:42] <TimToady> and () in list context disappears

[23:43] *** stephenlb left
[23:43] *** whiteknight left
[23:45] <TimToady> sorear: I think that code is a bit of a fossil from when I was trying to feed these patterns to other regex engines that didn't support either utf8 or case insensitivity

[23:46] <TimToady> but certainly if I know I'm targeting p5 patterns I can just use uc/lc, and maybe ucfirst for titlecase

[23:47] <TimToady> or, actually, it can just use p5's embedded (?i) ability

[23:48] <TimToady> but I was targeting TRE or some such a the time, and it got very upset about those sorts of thigns

[23:49] <TimToady> I gave up on TRE when I realized it was allocating many megabytes on the stack for *every* token lookup

[23:49] *** ive left
[23:49] <TimToady> it doesn't scale well in # of parallel patterns, turns out

[23:51] <sorear> TRE?

[23:51] <sorear> let me explain an incomplete thought of mine

[23:51] <TimToady> Tagged Regular Expressions

[23:52] <TimToady> libtre, etc

[23:52] <sorear> when you compile a NFA to a DFA, you're forcing the regex to express its entire state in some complex encoding of one word

[23:52] <TimToady> yes, but that's an abstract idea

[23:52] <sorear> a NFA expresses the state as a bit array, but needs to loop over it for every character

[23:52] <TimToady> the word can be spread out in various spots, physically

[23:53] <sorear> I'd like to see some middle ground

[23:53] <sorear> where the regex's state space is multi-dimensional, so less storage is required, but there's less of a looping problem

[23:53] <TimToady> the trie cache can get the subset of the state space for the current match

[23:54] <TimToady> so in essence your dimensional lookup is keyed on what we've seen so far

[23:54] <sorear> I don't like the cache.

[23:54] <sorear> It feels like an awkward crutch.

[23:55] <TimToady> it precomputes some probabilistically likely state sets

[23:56] <TimToady> and it could conceivably be quite fast, for something that feels "lame"  :)

[23:57] <TimToady> especially as the redundancy in your program goes up

[23:57] <TimToady> it starts working more like a compression algorithm

[23:58] <TimToady> but hopefully the compression is on the state space more than the output :)

[23:58] <sorear> My goal is to output something that looks vaguely like a hand-written recursive descent parser

[23:58] <TimToady> but anyway, if you have something that feels less lame, by all means it's worth a shot

[23:58] <sorear> Not really.

[23:58] <sorear> Just expressing my concerns in case you had insights.

[23:59] <TimToady> well, recursive descent doesn't guarantee LTM easily

