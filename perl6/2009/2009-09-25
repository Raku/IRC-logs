[00:00] *** Whiteknight joined
[00:00] <diakopter> rakudo: use @*INC

[00:00] <p6eval> rakudo 0eaf62: OUTPUT«Can't find .//home/p6eval/.perl6/lib /home/p6eval/p1/lib/parrot/1.6.0-devel/languages/perl6/lib lib . in @*INC␤in Main (/tmp/OvoKrXtEnH:2)␤»

[00:01] <diakopter> <blink />

[00:02] <diakopter> rakudo: use use

[00:02] <p6eval> rakudo 0eaf62: OUTPUT«Can't find ./use in @*INC␤in Main (src/gen_setting.pm:445)␤»

[00:03] <diakopter> std: use use

[00:03] <p6eval> std 28379: OUTPUT«Potential difficulties:␤  Can't locate module use at /tmp/Hu92GrWr75 line 1 (EOF):␤------> [32muse use[33m⏏[31m<EOL>[0m␤ok 00:01 94m␤»

[00:03] *** ihrd joined
[00:03] *** ihrd left
[00:16] <diakopter> colomon: successor/predecessor

[00:18] <colomon> diakopter: yes, moritz_ explained.  :)

[00:33] <dalek> rakudo: 729722a | (Solomon Foster)++ | src/setting/Complex.pm:

[00:33] <dalek> rakudo: Add Complex trig functions not currently shadowed by Parrot complex functions.

[00:33] <dalek> rakudo: In particular, add Complex.cosec, Complex.cosech, Complex.acosec, Complex.cotan, Complex.cotanh, Complex.acotan, Complex.acosec, and Complex.acotanh.  Comment out implementations of Complex.sin and Complex.cos, as these are currently shadowed by Parrot functions.

[00:33] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/729722a9c0b260032ecc914f4cd6495dc22b422c

[00:33] <dalek> rakudo: 3afb78d | (Solomon Foster)++ | src/setting/ (2 files):

[00:34] <dalek> rakudo: Change from-radians to work on self rather than a passed parameter.

[00:34] <dalek> rakudo: For some reason Any.from-radians ignored self completely and did its work on a passed parameter.  This patch changes from-radians to work on self instead (like Any.to-radians does).  Note as well that no conversion to Num is done, it just does the math, so it works fine for Complex too.

[00:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3afb78dc47737a08fd061b9a7f81087da6d0f004

[00:34] <dalek> rakudo: 7a33068 | (Solomon Foster)++ | src/setting/Any-num.pm:

[00:34] <dalek> rakudo: Add Any.atan2.

[00:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7a3306864270c38561c303d2afceaf4d09d84184

[00:47] <sjohnson> is dalek a bot?

[00:47] *** Matt-W joined
[00:53] *** gbacon left
[00:54] *** TiMBuS joined
[00:59] <colomon> sjohnson: yes

[00:59] <sjohnson> /mode +v dalek

[00:59] <sjohnson> i guess that explains why he never answered my letters

[01:01] *** s1n joined
[01:12] *** TimToady sets mode: +v dalek

[01:14] *** wknight8111 joined
[01:14] *** Whiteknight left
[01:28] *** Matt-W_ joined
[01:31] *** Matt-W left
[01:55] *** rhr_ joined
[01:55] *** molaf_x joined
[01:55] *** molaf left
[02:00] <pugs_svn> r28398 | colomon++ | [t/spec] Bring the complex trig tests into the new (still not active) system. 

[02:08] *** explorer left
[02:08] *** rhr left
[02:08] *** jhuni left
[02:13] *** wknight8111 left
[02:22] *** PZt joined
[02:24] *** japhb joined
[02:25] *** stephenlb left
[02:33] *** xinming_ joined
[02:35] *** [particle] left
[02:37] *** [particle] joined
[02:38] *** rindolf left
[02:45] *** sparc joined
[02:48] *** xinming left
[02:53] *** alester joined
[02:57] *** nbrown left
[02:58] *** rhr_ left
[03:00] *** rhr joined
[03:09] *** Entonian joined
[03:15] *** s1n_mini joined
[03:32] *** jaldhar joined
[03:50] *** Student left
[03:53] <pugs_svn> r28399 | jimmy++ | [zh-cn/syn/S02-bits.pod]fixed grammar. 

[03:58] *** jhuni joined
[04:08] *** nihiliad joined
[04:08] *** tak11 left
[04:11] *** alester left
[04:11] *** alester joined
[04:34] *** s1n_mini left
[04:54] *** alester left
[05:18] <pugs_svn> r28400 | jimmy++ | [Spec/S02-bits.pod]used standard dialect 'Pod' 

[05:31] *** zerhash left
[05:32] *** Entonian left
[05:50] *** nihiliad left
[05:53] *** am0c left
[05:55] <mikehh> rakudo (729722a) builds on parrot r41465 - make test / make spectest (up to 28400) PASS - Ubuntu 9.04 amd64

[05:56] *** [particle]1 joined
[06:02] *** justatheory left
[06:03] *** [particle]1 left
[06:04] *** PZt left
[06:05] *** [particle] left
[06:10] <mikehh> make spectest_smolder ok now - #28049

[06:13] *** NorwayGeek|Away left
[06:29] *** iblechbot joined
[06:43] *** PZt joined
[06:53] *** meppl joined
[07:08] *** Laughing_God joined
[07:08] *** Laughing_God left
[07:11] *** iblechbot left
[07:12] *** mariuz joined
[07:16] *** rfordinal joined
[07:20] *** donaldh left
[07:23] *** donaldh joined
[07:31] *** crythias left
[07:32] <pugs_svn> r28401 | jimmy++ | [zh-cn/syn/S02-bits.pod]added random Chinese translation. 

[07:32] *** Matt-W_ is now known as Matt-W

[07:38] <pugs_svn> r28402 | jimmy++ | [zh-cn/syn/S02-bits.pod]a bit more Localization. 

[07:44] *** charsbar left
[07:44] *** charsbar joined
[07:45] *** cosimo left
[07:52] *** ejs joined
[07:56] *** dakkar joined
[07:59] *** ellipsis joined
[08:02] *** ejs1 joined
[08:02] *** JimmyZ joined
[08:08] *** jferrero joined
[08:10] *** ejs left
[08:11] *** am0c joined
[08:14] *** icwiener joined
[08:15] *** ssm left
[08:17] *** NorwayGeek joined
[08:17] *** NorwayGeek left
[08:18] *** NorwayGeek joined
[08:18] *** ellipsis left
[08:30] *** payload1 joined
[08:31] *** payload left
[08:32] <jnthn> phenny tell __ash__ yes, it's fine if you do that. :-)

[08:33] <jnthn> phenny?

[08:33] <jnthn> phenny: tell __ash__ yes, it's fine if you do that. :-)

[08:33] <phenny> jnthn: I'll pass that on when __ash__ is around.

[08:33] <jnthn> ah

[08:33] <jnthn> insufficient colonage.

[08:35] <Matt-W> morning

[08:40] <jnthn> oh hai

[08:48] <moritz_> \o/

[08:48] <moritz_> yesterday night was very productive in finding new rakudobugs and stumbling over old ones

[08:48] *** flip645 joined
[08:49] <flip645> rakudo: (1,2,3).».&infix:<+>(3).say

[08:49] <p6eval> rakudo 0eaf62: OUTPUT«Parameter type check failed; expected Complex, but got Int for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:881)␤called from Main (/tmp/exOs2Lja2n:2)␤»

[08:49] <flip645> rakudo: (1.2,2.1,3.1).».&infix:<+>(3.2).say

[08:49] <p6eval> rakudo 0eaf62: OUTPUT«Parameter type check failed; expected Complex, but got Num for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:881)␤called from Main (/tmp/xdUNntbBcO:2)␤»

[08:49] <flip645> Is there some way to specify which <+> operator I want?

[08:49] <moritz_> sadly that somewhat diminished my productivity in actually producing working code

[08:50] <moritz_> flip645: &infix:<+> is a subroutine, but you try to call it as an operator

[08:50] <flip645> well, shouldn't it work that way?

[08:51] <moritz_> no

[08:51] <flip645> it just tells me about wrong types ...

[08:51] <moritz_> the error message is less than awesome, yes

[08:52] <flip645> I don't understand the difference ...

[08:52] <flip645> I thought that I could pass a curried function, which just needs one more argument, as an operator?

[08:53] <flip645> rakudo: (1.2,2.1,3.1).map(*+3.2).».say

[08:53] <p6eval> rakudo 0eaf62: OUTPUT«4.4␤5.3␤6.3␤»

[08:53] <flip645> Maybe I'm just "confused at p6" ;-=

[08:54] <flip645> rakudo: (1,2,3).».&infix:<+>.say

[08:54] <p6eval> rakudo 0eaf62: OUTPUT«too few arguments passed (1) - 2 params expected␤in sub infix:+ (src/gen_setting.pm:872)␤called from Main (/tmp/zDbZEuoHDA:2)␤»

[08:54] <flip645> So it needs just one more parameter ... and that's what I'd like to provide:

[08:54] <flip645> rakudo: (1,2,3).».&infix:<+>(3).say

[08:54] <p6eval> rakudo 0eaf62: OUTPUT«Parameter type check failed; expected Complex, but got Int for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:881)␤called from Main (/tmp/ewAXrvYbHl:2)␤»

[08:55] <flip645> How can I take the "Int" infix:<+>?

[08:55] <moritz_> flip645: unlike in haskell you still have to curry explicitly

[08:55] <moritz_> it's NYI, not sure what the spec says

[08:56] <moritz_> something like &infix:<+>(Int,Int)(2, 3) or so

[08:56] <flip645> just looking at the pods

[08:56] <flip645> rakudo: (1,2,3).».&infix:<+>(Int,Int)(3).say

[08:56] <p6eval> rakudo 0eaf62: OUTPUT«too many arguments passed (4) - 2 params expected␤in sub infix:+ (src/gen_setting.pm:872)␤called from Main (/tmp/KUueI0MrPR:2)␤»

[08:56] <moritz_> but you still try to call it as a method. Won't work.

[08:56] <flip645> Hmm, doesn't select

[08:56] <moritz_> (unless by a bug)

[08:56] <flip645> rakudo: my $a=&infix:<+>(Int,Int); (1,2,3).».$a(3).say

[08:56] <p6eval> rakudo 0eaf62: OUTPUT«Use of type object as value␤Use of type object as value␤elements() not implemented in class 'Integer'␤in Main (/tmp/V2TEGY8bE2:2)␤»

[08:57] <flip645> well, it looks nice to me ...

[08:57] <flip645> I think that should DWIM (but maybe that's just me)

[08:57] *** ssm joined
[08:58] <moritz_> subs and methods have totally different lookup rules

[08:58] <moritz_> mixing them is a receipt for trouble

[09:09] <flip645> rakudo: (1,2,3).».&infix:<+>:(Int,Int)(2).say

[09:09] <p6eval> rakudo 0eaf62: OUTPUT«Parameter type check failed; expected Complex, but got Int for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:881)␤called from Main (/tmp/F2SMjUvSKI:2)␤»

[09:09] <flip645> doesn't seem to hel

[09:09] <flip645> *help

[09:10] <moritz_> still a method call.

[09:10] <flip645> Could you elaborate?

[09:10] <flip645> Now we're cooking with charcoal:

[09:10] <flip645> rakudo: my &a=&infix:<+>:(Int,Int).assuming(2); say &a(3);

[09:11] <p6eval> rakudo 0eaf62: OUTPUT«5␤»

[09:12] <flip645> rakudo: my &a=&infix:<+>:(Int,Int).assuming(2); (2,3,1).».&a.say;

[09:12] <p6eval> rakudo 0eaf62: OUTPUT«elements() not implemented in class 'Sub'␤in Main (/tmp/fDYVKxNP0c:2)␤»

[09:12] <moritz_> what kind of elaboration do you want? $something>>.$otherthing is a method call.

[09:12] <flip645> I'd thought that it would call $otherthing on each element of $something?

[09:12] <flip645> Ain't that a method call?

[09:13] <moritz_> yes. But &infix:<+> is not a method.

[09:14] <flip645> Isn't $x.$f() the same as $f($x)?

[09:16] <flip645> Or  $x: $f()?

[09:18] <flip645> Just reading S13 ...

[09:20] *** iblechbot joined
[09:21] <moritz_> $x.$f() is not the same as $f($x).

[09:23] <flip645> What's the difference?

[09:23] <flip645> Shouldn't both do dispatch based on the type?

[09:24] <flip645> Ok, $f($x) may be a bit lax, in that $x.$f() has to have a method in the class of $x defined

[09:24] <flip645> But in any case there's a function $f taking a single argument of $x, isn't it?

[09:24] *** masak joined
[09:24] <flip645> I don't really understand why that doesn't DWIM

[09:25] * masak slides into the channel and does a backflip

[09:25] <masak> flip645: it could DWIM, but it doesn't.

[09:26] <masak> think of it as an arbitrary syntactic limitation.

[09:26] <flip645> that doesn't sound like Perl ;-)

[09:26] <moritz_> flip645: foo($x) looks into the current scope for a sub 'foo', then in an outer scope, then in the next outer scope, and at the very end in the namespace

[09:27] <masak> flip645: well, it's worth it when it encourages Correct Thoughts. Perl 5 had less of that, but it was there.

[09:27] <moritz_> flip645: $x.foo() looks for a 'foo' method in the class of $x, then in the parent class of $x, then in the next parent class etc.

[09:27] <moritz_> flip645: see also http://perlgeek.de/blog-en/perl-6/subs-vs-methods.html

[09:28] <flip645> now reading ...

[09:31] <flip645> So that brings us something like this:

[09:31] <flip645> rakudo: (1,2,3).map( &infix:<+>:(Int,Int)(2,*) ).».say

[09:31] <p6eval> rakudo 0eaf62: OUTPUT«3␤4␤5␤»

[09:31] <flip645> rakudo: (1,2,3).map( * + 2 ).».say

[09:31] <p6eval> rakudo 0eaf62: OUTPUT«3␤4␤5␤»

[09:32] <flip645> Who's the rakudo operator? In case I'm doing something stupid.

[09:32] * moritz_ 

[09:32] <flip645> Is it a problem if I try (1 .. *).map().».say?

[09:33] *** NorwayGeek left
[09:33] <moritz_> no, there are resource limits, so if you produce an infinite loop it will get killed after a few seconds

[09:33] <flip645> Fine!

[09:33] <flip645> rakudo: (1 .. *).map( * + sleep(1) ).».say

[09:33] <p6eval> rakudo 0eaf62: OUTPUT«!whatever_closure␤»

[09:33] <flip645> rakudo: say sleep(1)

[09:33] <p6eval> rakudo 0eaf62: OUTPUT«0.994981050491333␤»

[09:34] <flip645> rakudo: (1 .. 3).map( * + sleep(1) ).».say

[09:34] <p6eval> rakudo 0eaf62: OUTPUT«1.99465298652649␤2.99465298652649␤3.99465298652649␤»

[09:35] *** NorwayGeek joined
[09:35] <flip645> rakudo: eager (1 .. *).map( * + sleep(1) ).».say

[09:35] <p6eval> rakudo 0eaf62: OUTPUT«!whatever_closure␤Could not find non-existent sub eager␤»

[09:36] <flip645> not yet implemented, it seems

[09:36] <flip645> Thanks for your time

[09:36] <spinclad> 'Ha! mere carbon-based lifeform, you cannot put me to sleep so easil.......'

[09:38] <masak> JimmyZ: I see you did the s:i/POD/Pod/ substitution. good.

[09:39] <masak> JimmyZ: another thing that I noticed is the '=begin podstuff'/'=end podstuff'. that's not right according to S26.

[09:39] <masak> (because all-lowercase names are reserved)

[09:39] <flip645> Is "augment class" already implemented?

[09:39] <flip645> like in

[09:39] <flip645> rakudo: augment class Int { method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}};

[09:39] <masak> flip645: yes, but as the old 'is also'.

[09:39] <p6eval> rakudo 0eaf62: OUTPUT«Re-declaration of type Int at line 2, near ";"␤in Main (src/gen_setting.pm:1648)␤»

[09:40] <jnthn> flip645: Rakudo curently spells it ....what masak said

[09:40] <flip645> rakudo: class Int is also { method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}};

[09:40] <p6eval> rakudo 0eaf62:  ( no output )

[09:40] <flip645> rakudo: class Int is also { method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}}; say 4.&infix:<+>(2);

[09:40] <p6eval> rakudo 0eaf62: OUTPUT«Parameter type check failed; expected Complex, but got Int for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:881)␤called from Main (/tmp/6yakWXoh7Y:2)␤»

[09:40] <flip645> rakudo: class Int is also { method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}}; say 4.&infix:<+>:(Int,Int)(2);

[09:40] <p6eval> rakudo 0eaf62: OUTPUT«Parameter type check failed; expected Complex, but got Int for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:881)␤called from Main (/tmp/LDwDeHJC2Q:2)␤»

[09:41] <jnthn> oddness

[09:41] <flip645> rakudo: class Int is also { method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}}; say 4.Int.&infix:<+>:(Int,Int)(2);

[09:41] <p6eval> rakudo 0eaf62: OUTPUT«Parameter type check failed; expected Complex, but got Int for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:881)␤called from Main (/tmp/3p1ktBLjVF:2)␤»

[09:41] <flip645> rakudo: class Int is also { method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}}; say 4.int.&infix:<+>:(Int,Int)(2);

[09:41] <p6eval> rakudo 0eaf62: OUTPUT«the int() sub and .int method have been replaced by the .Int method␤in Main (/tmp/FnbJjsvAq9:2)␤»

[09:41] <flip645> Help?

[09:43] <masak> flip645: the error message is telling in itself, I'd say.

[09:43] <masak> flip645: .int is deprecated.

[09:44] <flip645> ok, but with .Int? and without?

[09:44] <masak> I don't think you need to convert 4 at all.

[09:44] <masak> it's already an Int.

[09:44] <flip645> As soon as that works, we could use introspection to put all defined functions as methods in the classes of their first argument ;-)

[09:45] <flip645> Why does it try to call Complex:+

[09:45] <masak> no idea.

[09:45] <flip645> Doesn't selection via the signature (Int,Int) work?

[09:45] <flip645> rakudo: say &infix:<+>:(Int,Int).WHICH;

[09:45] <p6eval> rakudo 0eaf62: OUTPUT«47256741210240␤»

[09:45] <flip645> rakudo: say &infix:<+>:(Int,Int).WHICH; say &infix:<+>:(Num,Num).WHICH;

[09:46] <p6eval> rakudo 0eaf62: OUTPUT«47266217863296␤47266217863296␤»

[09:46] <flip645> no, returns the same

[09:46] <flip645> rakudo: say &infix:<+>:(Int,Int).WHICH; say &infix:<+>:(Complex,Complex).WHICH;

[09:46] <p6eval> rakudo 0eaf62: OUTPUT«47291921664128␤47291921664128␤»

[09:46] <JimmyZ> masak: will do.

[09:46] <jnthn> Looks like some bug, but I cna't even beging to guess what, and I gotta head out now.

[09:48] *** NorwayGeek left
[09:53] *** NorwayGeek joined
[10:06] <Matt-W> argh

[10:06] <Matt-W> must stop writing Perl 6 constructs in my Perl 5

[10:07] <Matt-W> perl doesn't like it when I leave out the () on my ifs

[10:07] * Matt-W wants to live in the future

[10:07] <JimmyZ> masak: how to fix '=begin podstuff'/'=end podstuff'?

[10:09] <JimmyZ> masak: Podstuff?

[10:11] <flip645> Matt-W: yeah, I'm longing for some perl6 syntax as well ...

[10:15] <flip645> Can someone explain this?

[10:15] <flip645> rakudo: class Int is also { multi method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}; multi method infix:<+>(Int $self: Complex $arg) { return 0; } }; say 3.f(2)

[10:15] <p6eval> rakudo 0eaf62: OUTPUT«Method 'f' not found for invocant of class 'Int'␤»

[10:16] <flip645> sorry, wrong paste

[10:16] <flip645> rakudo: class Int is also { multi method f(Int $self: Int $arg) { return $self+$arg+1;}; multi method f(Int $self: Complex $arg) { return 0; } }; say 3.f(2)

[10:16] <p6eval> rakudo 0eaf62: OUTPUT«6␤»

[10:16] <flip645> declaring multi methods in a class - works.

[10:16] <flip645> But if I substitute "f" with "infix:<+>" it doesn't:

[10:16] <flip645> class Int is also { multi method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}; multi method infix:<+>(Int $self: Complex $arg) { return 0; } }; say 3.&infix:<+>(2)

[10:17] <Matt-W> Operators don't always behave the same way as methods

[10:17] <Matt-W> This may or may not be a bug, I'm unsure

[10:17] <flip645> rakudo: class Int is also { multi method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}; multi method infix:<+>(Int $self: Complex $arg) { return 0; } }; say 3.&infix:<+>(2)

[10:17] <p6eval> rakudo 0eaf62: OUTPUT«Parameter type check failed; expected Complex, but got Int for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:881)␤called from Main (/tmp/6XsJJ2yxwW:2)␤»

[10:17] <flip645> Why does it always expand to the most universal type here? In the "f" example it doesn't!

[10:18] <flip645> rakudo: class Int is also { multi method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}; multi method infix:<+>(Int $self: Complex $arg) { return 0; } }; say 3+2;

[10:18] <p6eval> rakudo 0eaf62: OUTPUT«5␤»

[10:18] <Matt-W> I'd say file a bug

[10:18] <flip645> rakudo: class Int is also { multi method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}; multi method infix:<+>(Int $self: Complex $arg) { return 0; } }; say &+(3,2);

[10:18] <Matt-W> Can't see that should be specced, so it's probably Rakudo doing it wrong

[10:18] <p6eval> rakudo 0eaf62: OUTPUT«say requires an argument at line 2, near " &+(3,2);"␤in Main (src/gen_setting.pm:2565)␤»

[10:19] <flip645> rakudo: class Int is also { multi method infix:<+>(Int $self: Int $arg) { return $self+$arg+1;}; multi method infix:<+>(Int $self: Complex $arg) { return 0; } }; say &infix:<+>(3,2);

[10:19] <p6eval> rakudo 0eaf62: OUTPUT«5␤»

[10:19] <flip645> doesn't call me method, ok. because it looks for the function first.

[10:20] *** payload1 left
[10:21] *** jauaor left
[10:22] <colomon> errr... rakudo doesn't have any notion that Complex is "the most universal type", does it?

[10:22] *** am0c left
[10:25] <Matt-W> possibly not

[10:27] *** flip645 left
[10:33] <pugs_svn> r28403 | jimmy++ | [Spec]use standard dialect 'Pod'  

[10:37] *** iblechbot left
[10:41] *** JimmyZ left
[10:51] *** jhuni left
[10:59] <masak> phenny: tell JimmyZ that yes, '=begin Podstuff' would work.

[10:59] <phenny> masak: I'll pass that on when JimmyZ is around.

[11:04] <masak> rakudo: sub foo(@a) { say !@a }; foo(undef); say undef

[11:04] <p6eval> rakudo 0eaf62: OUTPUT«0␤Use of uninitialized value␤␤»

[11:05] <masak> can someone explain what happens in the sub call?

[11:05] <masak> first off, why does undef match against a Positional?

[11:05] <masak> second, how is it that negating it gives 0?

[11:06] <masak> rakudo: sub foo(@a) { say @a.WHAT }; foo(undef)

[11:06] <p6eval> rakudo 0eaf62: OUTPUT«Array()␤»

[11:07] <Juerd> I wonder what would happen in 2000 years if only a programmer's chat log was preserved, and no other part of our culture. What would the future people think when reading it... Would they realise that bots are actually bots?

[11:07] <arnsholt> They might

[11:07] <masak> hard to say.

[11:08] <masak> 2000 years is a long time.

[11:08] <Juerd> It's an arbitrary number :)

[11:08] <arnsholt> We know a fair bit about the Romans, and the record from back then is kinda sketchy

[11:08] <masak> Juerd: it's a very long number, if you adhere to the idea of a technological singularity.

[11:08] <arnsholt> Heck, we actually know a little bit about the Proto-Indo-Europeans

[11:08] <masak> s/long/large/

[11:09] <arnsholt> Based purely on comparative linguistic data

[11:10] <masak> I realized the other week that the next generation will likely grow up surrounded by bots and bot-like entities.

[11:10] <Juerd> Hm

[11:10] <arnsholt> Probably

[11:10] <Juerd> Could be

[11:11] *** ihrd joined
[11:11] <masak> I just extrapolate from what we ahve here in #perl6 to what the rest of the (western) world will have in 30 years.

[11:11] *** ihrd left
[11:15] *** pmurias joined
[11:17] *** cosimo joined
[11:27] *** NorwayGeek left
[11:30] *** mariuz left
[11:37] <moritz_> Juerd: if the read the HTML version of the logs, they'd surely notice, because they are all marked in the same color

[11:41] <pmurias> diakopter: hi

[11:41] <masak> moritz_: how come an undef argument binds to an @a parameter?

[11:42] *** ruoso left
[11:42] <masak> rakudo: class A { has $.bar = "OH HAI"; method Str() { $.bar } }; say A.new.Str

[11:42] <p6eval> rakudo 0eaf62: OUTPUT«OH HAI␤»

[11:42] <masak> rakudo: class A is Str { has $.bar = "OH HAI"; method Str() { $.bar } }; say A.new.Str

[11:42] <p6eval> rakudo 0eaf62: OUTPUT«Use of uninitialized value␤␤»

[11:43] * masak reports rakudobug

[11:46] <colomon> moritz_: I promised bugs last night and was too tired to report them.  So here's the first:

[11:46] <colomon> enum TrigBase <Radians Degrees Gradians Circles>;  # Should be "is export" according to spec, but that

[11:46] <colomon> constant $?TRIGBASE = Radians;                     # doesn't compile yet.

[11:46] <moritz_> masak: why is that a bug?

[11:46] <masak> moritz_: because it calls the Str method, but the attribute is undef.

[11:47] <colomon> Adding that (from the spec) to Any-Num.pm produced a Rakudo that compiled but was completely broken.

[11:47] <moritz_> masak: A.new ~~ Str, so I don't see why it should call method Str at all

[11:47] <masak> moritz_: well, it does.

[11:47] <moritz_> colomon: yes, $? variables aren't supported yet

[11:47] <masak> so either way, it's a bug.

[11:47] <moritz_> colomon: a workaround would be to use $TRIGBASE for now

[11:48] <colomon> I thought $? was added a few weeks ago?

[11:48] <masak> moritz_: actually, I'd argue that if you define your own .Str method, and then call it, it should be called.

[11:48] <masak> but it is, so that's no problem.

[11:48] <masak> the problem is that $.bar yields undef for some reason.

[11:49] <moritz_> oh wait, you call it explicitly... yeah, sorry

[11:50] <masak> np. it's a confusing bug.

[11:51] <colomon> moritz_: Switching $?TRIGBASE to $TRIGBASE still gets the bug.  (ie every single test in make test fails...)

[11:51] <colomon> trying it now without the variable declaration....

[11:53] *** payload joined
[11:55] *** mariuz joined
[11:55] <colomon> Same thing.

[11:56] <masak> moritz_: perhaps you'd like to add your updated projects.list graph to the Perl Myths p6l thread?

[11:56] <lisppaste3> colomon pasted "Error message when TrigBase enum in Any-Num.pm" at http://paste.lisp.org/display/87706

[11:57] <moritz_> masak: ETOOLATE, afaict Tim already held his talk

[11:57] <masak> moritz_: IIUC, he holds it regularly. besides, it might still be interesting to others.

[11:57] <moritz_> colomon: and that's only with add one 'enum...;' line, no other changes?

[11:57] <colomon> yes

[11:57] <moritz_> colomon: please submit a bug report then

[11:57] <moritz_> masak: ok, I might reply later on

[11:58] <colomon> moritz_: will get on that asap

[12:02] <colomon> moritz_: RT #69382

[12:03] <moritz_> colomon++

[12:04] *** KyleHa joined
[12:10] <colomon> moritz_: Next issue I had is that Complex.sin dispatches to a Parrot complex.sin function rather than a Perl 6 Complex.sin.

[12:11] <colomon> rakudo: class Complex is also { multi method sin() { say "Hello!"; return self + 1i; }; }; say (1+1i).sin;

[12:11] <p6eval> rakudo 0eaf62: OUTPUT«1.29846+0.634964i␤»

[12:13] *** payload left
[12:13] <moritz_> colomon: pmichaud suggested we write our own Complex class

[12:13] *** payload joined
[12:13] <moritz_> colomon: which just keeps the real and imaginary part, and then we don't have dispatch issues with that

[12:14] <moritz_> and we can delegate to the parrot Complex class in a controlled and meaningful way

[12:14] <colomon> I don't have the mojo to untangle the current Complex from Parrot's, but if one of you could do it I believe I can take a fair stab at implementing Complex purely in Perl 6.

[12:15] <moritz_> class Complex { has $.re; has $.im;  ... }; # lots of operator definitions here

[12:15] <moritz_> maybe I can get to it in a branch over the weekend

[12:16] <colomon> But Complex is defined someplace deep inside Rakudo, isn't it?  The setting is "class Complex is also"...

[12:17] <colomon> (Having said that, implementing complex ln and exp scares me a little.... but it would be an interesting project, for sure.)

[12:18] <masak> I just upped the priority on http://rt.perl.org/rt3/Ticket/Display.html?id=66552 and added it as a dependency of the 'High priority tickets' RT ticket.

[12:19] <moritz_> masak: I think we "just" need to move the operators to the setting to fix that

[12:20] <masak> er.

[12:20] <masak> is that the easiest way to solve it?

[12:21] <moritz_> rakudo: multi sub infix:<+> ($l,$r) { $l ~ $r }; say( 1 + 2 )

[12:21] <p6eval> rakudo 0eaf62: OUTPUT«3␤»

[12:23] *** KyleHa left
[12:26] *** JimmyZ joined
[12:27] *** NorwayGeek joined
[12:30] <JimmyZ> bad plenny

[12:30] <phenny> JimmyZ: 10:59Z <masak> tell JimmyZ that yes, '=begin Podstuff' would work.

[12:30] <masak> JimmyZ: she only reports when you say something.

[12:30] <JimmyZ> ...

[12:33] <pugs_svn> r28404 | jimmy++ | [Spec/S02-bits.pod]use standard dialect 'Pod' 

[12:33] <colomon> moritz_: Third bug(?): If I define multi sub sin(Complex $x) in setting/Complex.pm, trig.t doesn't see it.  But if I define it in trig.t, it works just fine.

[12:33] <colomon> Is there something "special" that needs to be done to export subs from the setting?

[12:34] <moritz_> no, nothing

[12:34] <moritz_> I guess it's just general Complex weirdness

[12:34] *** payload1 joined
[12:35] <colomon> I guess if the thought is seriously to split Complex away from the Parrot version, it's probably worth tabling this last one until after that is done.

[12:37] <colomon> BTW, one thing I don't understand with the trig functions is how any of the sub versions work.  All I see is definitions for the method versions.  (Not counting the above Complex definitions I've made.)

[12:37] <colomon> I know there is "is export" on the method definitions, but as I understand it, that means a sub Num::sin should be defined, rather than just plain sin.

[12:41] *** payload left
[12:42] <moritz_> it means that a sub is created automatically from the method

[12:43] *** SmokeMachine joined
[12:43] <colomon> moritz_: But as I understand it, that sub is not in the general namespace.  Num.sin is export would generate Num::sin rather than just sin.

[12:44] <moritz_> colomon: right. But the session is magically exporting everything

[12:44] <colomon> moritz_: "session"?

[12:45] <moritz_> setting

[12:45] <moritz_> sorry

[12:45] <colomon> ah.

[12:45] <colomon> that would certainly explain everything, I think.  I suspect I was trying "is export" with Complex, which seems to have other issues causing trouble.

[12:53] *** pmurias left
[12:53] *** crythias joined
[12:54] *** payload1 left
[12:59] *** dakkar left
[13:09] *** crythias left
[13:11] *** JimmyZ_ joined
[13:12] *** nihiliad joined
[13:16] *** jferrero left
[13:17] *** JimmyZ left
[13:17] *** JimmyZ_ is now known as JimmyZ

[13:20] *** NorwayGeek is now known as NorwayGeek|Away

[13:23] *** payload joined
[13:24] <TiMBuS> how do you turn a list into a hash in perl 6? i ended up making an array of pairs :|

[13:24] <TiMBuS> i guess you dont use map $_ => 1

[13:24] <moritz_> you can, yes

[13:25] *** awwaiid left
[13:25] <TiMBuS> i should just implement KeyHash and co.

[13:25] <moritz_> but you also have to assign it to a hash

[13:25] <moritz_> or coerce it, like %( ... )

[13:25] <TiMBuS> its a HoH

[13:25] <TiMBuS> oh

[13:25] <moritz_> rakudo: say %( <a b c> Z 1..3 ).perl

[13:25] <p6eval> rakudo 0eaf62: OUTPUT«{"c" => 3, "a" => 1, "b" => 2}␤»

[13:25] <TiMBuS> so, do i still need to convert it to pairs

[13:26] <moritz_> you don't have to

[13:26] <moritz_> if you have an even-sized list of non-pair values, you can just coerce it to hash

[13:26] <moritz_> in the example above, the zip operator doesn't emit pairs

[13:27] <moritz_> rakudo: my @a = 'a' .. 'd'; say %( @a Z (1 xx @a)).perl

[13:27] <p6eval> rakudo 0eaf62: OUTPUT«{"a" => 1, "b" => 1, "c" => 1, "d" => 1}␤»

[13:28] <TiMBuS> it doesnt? i thought it.. oh it emits something like (a, 1), (b, 2).. which flattens out or something

[13:28] <moritz_> right.

[13:28] <masak> ideally, yes.

[13:28] <masak> right now, it only emits flat things, methinks.

[13:28] <frettled> It's better to emit than omit.  ;)

[13:29] <moritz_> rakudo: my $x = (1, 2) Z (3, 4); say $x.perl

[13:29] <p6eval> rakudo 0eaf62: OUTPUT«[1, 3, 2, 4]␤»

[13:29] <moritz_> rakudo: .perl.say for  (1, 2) Z (3, 4)

[13:29] <p6eval> rakudo 0eaf62: OUTPUT«1␤3␤2␤4␤»

[13:29] <TiMBuS> i really should just implement KeyHash instead

[13:29] <moritz_> looks as flat as can be :-)

[13:32] <TiMBuS> speaking of which, in what sense are Bag and Set immutable?

[13:33] <TiMBuS> im guessing its just, once they're set, they cant change their contents?

[13:33] <moritz_> right.

[13:34] <TiMBuS> but can you set the container itself to something else?

[13:34] <moritz_> yes

[13:34] <moritz_> just like with numbers

[13:34] *** zerhash joined
[13:34] <moritz_> Integers are also immutable

[13:34] <moritz_> you can't modify 42

[13:34] <TiMBuS> heh

[13:34] <moritz_> but you can modify a variable holding 42

[13:36] <TiMBuS> is there a reason for that? immutable strings and stuff make sense, but ints.. hmm

[13:36] <TiMBuS> make a copy every time you inc

[13:38] <moritz_> how would you modify 42 then?

[13:40] <TiMBuS> in place, id guess. hm maybe im confusing myself with low level implementation vs conceptual

[13:40] <moritz_> immutability in this case just means that if you do 'my $x = 42; my $y = $x' and then do *anything* with $x, $y is still 42

[13:41] <moritz_> wheras if you have a mutable object, let's say an array

[13:41] *** Matt-W left
[13:41] <moritz_> rakudo: my $x = [4, 2]; my $y = $x; $x.push: ' 23'; say $y

[13:41] <p6eval> rakudo 0eaf62: OUTPUT«4 2  23␤»

[13:42] <TiMBuS> woah. didnt know arrays worked like that in p6. surprised that hasnt bit me yet

[13:43] <TiMBuS> oddly i knew that they were passed by reference so

[13:43] <TiMBuS> that should have been obvious..

[13:44] <moritz_> note that if you use @-sigiled variables the assignment does shallow copying

[13:44] <moritz_> so @a = @b does no aliasing

[13:44] <TiMBuS> oh..

[13:45] *** iblechbot joined
[13:49] <TiMBuS> i guess that makes sense. so applying that to the way it looks how the sigils act, $a = @b would not copy @b?

[13:50] <moritz_> rakudo: my @b = 1, 2,3; my $a = @b; @b.push: 5; say $a

[13:50] <p6eval> rakudo 0eaf62: OUTPUT«1 2 3 5␤»

[13:50] <moritz_> TiMBuS: rakudo thinks the same :-)

[13:51] <masak> perl6: my @b = 1, 2,3; my $a = @b; @b.push: 5; say $a

[13:51] <p6eval> elf 28404: OUTPUT«123␤»

[13:51] <p6eval> ..pugs, rakudo 0eaf62: OUTPUT«1 2 3 5␤»

[13:52] * masak wonders whither to submit an elfbug

[13:56] *** Matt-W joined
[14:01] * Matt-W mutters about unreliable hosting companies

[14:01] * jnthn hates those

[14:01] <moritz_> masak: where would you submit it to?

[14:01] <Matt-W> They took down the network for 'emergency maintenance' with 0 notice

[14:02] <jnthn> fail

[14:02] <Matt-W> I'm hard-pressed to think of a situation so bad that such a thing can be necessary unless everybody's already offline

[14:02] <pmichaud> good morning, #perl6

[14:02] <masak> moritz_: don't know, really. a TODO list in the pugs repo somewhere, p'haps.

[14:03] <masak> pmichaud: o/

[14:03] <masak> pmichaud: PGE day today?

[14:03] <pmichaud> definitely.

[14:03] <jnthn> pmichaud++

[14:03] <masak> \o/

[14:03] <Matt-W> \o/

[14:05] <moritz_> "write a grammar engine in a day"

[14:05] <Matt-W> he already wrote a grammar engine

[14:05] <Matt-W> I thought the point was to make it even better

[14:05] <moritz_> time for one more, it seems :-)

[14:05] <Matt-W> like, protoregexes and LTM

[14:06] <moritz_> Matt-W: from what pmichaud said yesterday it looked like a complete rewrite (or complete new write) rather than a big refactor

[14:07] <masak> moritz_: no, it's a big refactor.

[14:07] <moritz_> ok

[14:07] <masak> the point is to keep things working during the whole process, IIUC.

[14:07] <TimToady> sometimes those can look kinda like complete rewrites :)

[14:08] <TimToady> that was how the P4 -> P5 transition went

[14:08] <pmichaud> it's more of a complete rewrite than a refactor, now.

[14:09] <Matt-W> Sometimes you start off with a refactor

[14:09] <Matt-W> and end up with a rewrite

[14:09] * Matt-W wasn't around for the P4->P5 transition

[14:09] *** ispy_ joined
[14:09] <pmichaud> I think it's going to be too difficult to try to preserve PGE's existing interfaces, so easier to just write a new subsystem with new interfaces

[14:10] <pmichaud> then other systems can migrate from PGE to the new system on their own schedule

[14:10] <pmichaud> (similar to how things moved from TGE to PCT when it was created)

[14:11] <masak> sounds like a rather big change.

[14:11] <masak> will it go on in a Parrot branch?

[14:11] <pmichaud> it is.  but we'll end up with something much more modular, maintainable, etc.

[14:11] <pmichaud> and possibly even more portable.  :-)

[14:11] <Matt-W> Portable how?

[14:12] <Matt-W> to other VMs?

[14:12] <pmichaud> portable to other backends

[14:12] <pmichaud> yeah

[14:12] <Matt-W> ooooh

[14:12] <Matt-W> PCT for .NET :D

[14:12] <masak> PCT for the JVM.

[14:12] <pmichaud> that is on my radar, yes.

[14:12] <pmichaud> (it's not yet an explicit target, but it's something I tend to keep in mind)

[14:13] <pmichaud> one very interesting question, though, is whether we want the grammar engine stuff to be "owned" by the Parrot Foundation or by TPF or ....

[14:13] <Matt-W> Hmm

[14:13] <Matt-W> I shall stay out of that one I think

[14:13] <pmichaud> masak:  (branch)  I'm thinking I may just develop it in Parrot trunk

[14:14] <masak> pmichaud: oki

[14:14] <masak> well, it's SVN, not git. otherwise I'd have protested. :)

[14:14] <pmichaud> heh

[14:14] <pmichaud> you would've protested it going into an svn branch? 

[14:15] <TimToady> pmichaud: you can always just copyright it under your name until you decide

[14:15] <pmichaud> TimToady: if I copyright it under my name, it really shouldn't go into the parrot repo

[14:15] <masak> pmichaud: no, I'd have protested it not going into a git branch. :)

[14:15] *** alester joined
[14:16] <pmichaud> I'll have to go re-read the CLA terms about copyright ownership

[14:16] <TimToady> I'm sure it doesn't say they own everything you write :)

[14:17] *** rfordinal left
[14:17] <jnthn> As I understood it, it's more of a "collective copyright" that is held.

[14:17] <jnthn> That is, you don't lose your rights to the code as a result of signing the CLA.

[14:18] <pmichaud> looks like that's correct

[14:18] <pmichaud> why then does all of the code in the repo hold a PaFo copyright notice?

[14:18] *** rfordinal joined
[14:19] <pmichaud> PaFo can't claim copyright in code it doesn't own.

[14:20] <TimToady> well, they can if it was given to them

[14:20] <pmichaud> sure

[14:21] <TimToady> but then they "own" it, I suppose

[14:24] <pmichaud> anyway, I'll go ahead and stick a few copyright notices into these new pieces just in case

[14:26] <masak> what's the interaction between the PaFo license and ported code?

[14:27] *** NorwayGeek|Away left
[14:27] <pmichaud> code coming from parrot repo is AL2

[14:27] *** elmex_ joined
[14:27] *** elmex left
[14:28] *** elmex_ is now known as elmex

[14:28] *** NorwayGeek joined
[14:28] <masak> ah. nice.

[14:30] <NorwayGeek> O.o

[14:31] *** mberends joined
[14:31] <masak> mberends: \o/

[14:31] <Matt-W> masak: the other thing that gets me writing Perl 5 is what .= means

[14:32] <mberends> (ahoy: masak).reverse

[14:32] <masak> Matt-W: I don't think I'm bothered by that either.

[14:32] <masak> rakudo: say <ahoy : masak>.reverse.perl

[14:32] <p6eval> rakudo 0eaf62: OUTPUT«["masak", ":", "ahoy"]␤»

[14:32] <mberends> heh

[14:33] *** Psyche^ joined
[14:33] *** justatheory joined
[14:33] <jnthn> ahoj, mberends :-)

[14:34] * jnthn is liking Korea lots.

[14:34] <Matt-W> \o/

[14:34] <Matt-W> good food?

[14:34] <masak> mmm, Korean food.

[14:35] <jnthn> yes, awesome food

[14:35] <jnthn> Spicy!

[14:36] *** Patterner left
[14:36] *** Psyche^ is now known as Patterner

[14:36] <mberends> o/ jnthn, glad you're having a great roamabout

[14:37] <mberends> it's high time proto gets the benefit of TDD, the beginnings of that are forming in some new TODOs

[14:37] <mberends> developing without tests sux

[14:37] <masak> :/

[14:38] <masak> I'm getting ready to take tote by the reins. right now I'm having a lot of fun with Squerl, though.

[14:38] <masak> but I could easily make a blog post already containing just positive responses from people re tote.

[14:39] *** rfordinal left
[14:39] <cognominal> squerl?

[14:39] <masak> cognominal: oh, I'm porting this for Web.pm: http://sequel.rubyforge.org/

[14:40] <cognominal> nice

[14:40] <masak> yes, it's very possibly the nicest Ruby project I've ever seen.

[14:41] <masak> it already works, and I'm using all the free time I have to implement more tests.

[14:41] <masak> s/implement/pass/

[14:42] *** JimmyZ_ joined
[14:46] *** JimmyZ left
[14:46] *** JimmyZ_ is now known as JimmyZ

[14:48] *** mberends left
[14:49] <TimToady> rakudo: say sleep(.1)

[14:49] *** payload left
[14:49] <p6eval> rakudo 0eaf62: OUTPUT«0.10144305229187␤»

[14:49] <TimToady> heh

[14:49] <TimToady> rakudo: say sleep(.1)

[14:49] <p6eval> rakudo 0eaf62: OUTPUT«0.101404905319214␤»

[14:53] *** TiMBuS left
[14:53] <masak> rakudo: say schlep(.1)

[14:53] <p6eval> rakudo 0eaf62: OUTPUT«Could not find non-existent sub schlep␤»

[14:54] * masak .oO( use Yiddish; )

[14:55] <huf> that would own sooo much tho

[14:55] <arnsholt> I'd prefer use Latin, to be honest. Or perhaps use Cuneiform =D

[14:55] <mdxi> $sth->schlepall_arrayref

[14:55] <huf> arrOY! :)

[14:56] <masak> mdxi: that's $sth.schlepall_arroyref with a dot, even in Yiddish. :)

[14:59] <mdxi> my bad. i hang out here to soak up the perl6, but i still think in perl5 :)

[15:00] <masak> no shame in that. :) just means you're well versed in Perl 5.

[15:00] <Matt-W> As I was talking about earlier, I'm a little too versed in Perl 6 in some ways...

[15:01] <masak> Matt-W: in my experience, it gets easier the more you switch.

[15:02] <Matt-W> masak: Yes I think it probably does, rather like C and F fingering recorders. Learn one, learn the other, then play them both regularly and you can easily swap.

[15:03] * Matt-W -> home -> aikido &

[15:08] <jnthn> Aye, I rite 5 and 6 regularly.

[15:08] <jnthn> erm, write

[15:09] <jnthn> I find it's more 6-isms in my 5 code than 5-isms in my 6.

[15:10] *** tak11 joined
[15:11] *** payload joined
[15:12] <mdxi> i should probably be a good citizen and get involved with test writing and such

[15:12] <colomon> Matt-W: do they have transposing music for F recorders (ala alto and tenor sax), or do you actually think of different note names for the same fingering?

[15:13] <TimToady> sure, just play sax music on your recorder :P

[15:19] <lucs_> colomon: The latter, you think of different fingerings for the same note.

[15:21] <lucs_> (er, when reading a score that is.)

[15:22] <colomon> ouch, that must hurt the brain.

[15:23] <lucs_> I play the flute only (and a bit of C recorders), and I've never had the courage to learn the others :-(

[15:24] <lucs_> (drove me nuts)

[15:24] *** tak11 left
[15:24] *** tak11 joined
[15:25] *** jan_ left
[15:28] <colomon> I've done a fair bit of transposing in my day, and of course have whistles in about nine keys, but I always think of it in terms of my "base" fingering and figure out a way to con whatever I'm reading into that.  (Like reading clarinet music by pretending it is in tenor clef.)

[15:29] * jnthn -> sleep

[15:29] <lucs_> colomon: That'll do it :)

[15:31] *** ejs1 left
[15:33] <masak> mdxi: I find 'should' is not the best of motivators. I tend to just play around with Perl 6, until something motivates me to improve it somehow. -Ofun.

[15:35] *** sparc left
[15:40] *** ejs joined
[15:43] *** masak left
[15:44] *** Student joined
[15:48] *** FCO joined
[15:54] <pugs_svn> r28405 | jimmy++ | [zh-cn/syn/S02-bits.pod]add a bit more Chinese transcript for Lexical Conventions 

[15:58] <moritz_> I found one more case where an exception (?) makes a say() fail silently

[15:58] <moritz_> does anybody remeber the ticket number, or a keyword I could search for?

[16:00] *** M_o_C joined
[16:01] *** M_o_C left
[16:01] <pugs_svn> r28406 | jimmy++ | [zh-cn/syn/S02-bits.pod]fixed Chinese term. 

[16:02] *** JimmyZ left
[16:05] *** ruoso joined
[16:06] *** SmokeMachine left
[16:08] *** abra joined
[16:09] *** mariuz left
[16:10] * moritz_ just wanted to prepare a blog post about introspection, and immediately found a bug

[16:10] <moritz_> sigh

[16:10] <moritz_> this feels like 2008 all over again ;-)

[16:11] *** mariuz joined
[16:11] <colomon> moritz_: Was it RT #68960?

[16:12] <moritz_> colomon: yes, probably. I just created a new one ;-)

[16:20] *** NorwayGeek left
[16:21] <moritz_> rakudo: class A { method b() { say "in A.b" } }; A.new.^methods(:local).[0].()

[16:21] <p6eval> rakudo 0eaf62: OUTPUT«too few arguments passed (0) - 2 params expected␤in method A::b (/tmp/hn2RrqXw9M:2)␤called from Main (/tmp/hn2RrqXw9M:2)␤»

[16:21] <moritz_> rakudo: class A { method b() { say "in A.b" } }; A.new.^methods(:local).[0].(A.new)

[16:21] <p6eval> rakudo 0eaf62: OUTPUT«in A.b␤»

[16:21] <moritz_> should the first one work?

[16:27] *** zerhash left
[16:31] *** abra left
[16:32] *** jan_ joined
[16:32] <TimToady> no, how is it supposed to know what self is?

[16:32] <moritz_> it's passed to .methods

[16:32] * ruoso just replied to moritz_'s mail

[16:32] <moritz_> why shouldn't it know it?

[16:33] <TimToady> it's a different method call

[16:33] <moritz_> how so?

[16:33] <TimToady> method calls don't magically know the self from the 2nd call back

[16:33] <TimToady> $foo.bar.baz doesn't tell baz what $foo is

[16:33] <moritz_> I mean $obj.^methods() is short for $obj.HOW.methods($obj), no?

[16:34] <TimToady> yes, but that doesn't distribute to either .[] or .()

[16:34] *** mariuz left
[16:34] <moritz_> well, .^methods could return list of methods that know their invocant

[16:34] <moritz_> the question is not if it's possible, but if we want it

[16:34] <TimToady> also, I'm not sure either of them should work if methods returns method descriptors

[16:35] <ruoso> moritz_, you are assuming the meta method always work in the context of a given object

[16:35] <ruoso> but a meta method can be inespecific to any given object

[16:35] <TimToady> note also that you're calling the method using a function invocation, not a method invocation

[16:35] *** donaldh left
[16:35] <moritz_> ok, that pretty much answers my question

[16:36] <moritz_> mostly ;-)

[16:36] <ruoso> if the meta is XMLRPCHow, it might have methods such as $foo.^remote_port

[16:36] <TimToady> in fact, dispatchers dispatch by calling candidates as functions

[16:36] *** abra joined
[16:37] <moritz_> my mental model was that there's a class Method (or so) that has methods like .signature, .name, .multi etc

[16:37] <moritz_> and that a class holds such Method objects

[16:37] <moritz_> and introspection simply returns those

[16:38] <ruoso> that is true, if the meta is specific to each class

[16:38] <moritz_> does that roughly match your mental models?

[16:38] <ruoso> but a meta might be more prototype-oriented

[16:38] *** stephenlb joined
[16:38] <moritz_> I don't understand why it has to be specific to each class to do that

[16:39] <ruoso> it would if the second argument to the metamethods weren't the object in question

[16:40] <moritz_> this is me again, asking wierd questions instead of going back to blogging ;-)

[16:40] <ruoso> Foo.^methods map to Foo.HOW.methods(Foo) because Foo.HOW might be used by several other classes

[16:40] <TimToady> we want you to blog with the correct weird answers :)

[16:40] <moritz_> TimToady: :-)

[16:41] <TimToady> basically, all methods are called as &method.($self...) by the dispatcher

[16:42] *** KyleHa joined
[16:42] <TimToady> except, of course, that &method is probably not in a symbol table or lexical scope

[16:43] <TimToady> (unless you explicitly say "my method" or "our method")

[16:43] <moritz_> right

[16:43] <moritz_> so the only real difference is how they are looked up

[16:43] <TimToady> yes, everything is really a sub underneath

[16:43] <TimToady> and ruoso curses the day I decided that :)

[16:44] <TimToady> well, he was unhappy at the time, anyway  :)

[16:44] * ruoso already got over it ;)

[16:45] * ruoso is now trying to swallow the Parcel

[16:45] <moritz_> ah, one of the major offenses you talked about ;-)

[16:45] *** saran joined
[16:45] <TimToady> indeed

[16:47] <pmichaud> TimToady: S05/spec question...

[16:47] <pmichaud> if I invoke a regex directly, what do I get back?

[16:47] <TimToady> define "invoke"

[16:47] <pmichaud> example:    my $foo = regex { foo };    $foo(...)

[16:48] <pmichaud> does that give me back a Match object?

[16:48] <pmichaud> ...or a cursor?

[16:48] <pmichaud> ...or a list of cursors?

[16:48] <TimToady> probably gives you a Cursor that can pretend to be a Match

[16:48] <pmichaud> ...or is it impl-dependent?

[16:49] <TimToady> note that this is like:

[16:49] *** payload left
[16:49] <TimToady> my $foo = method { ...}; $foo(...)

[16:49] <TimToady> meaning that $foo($cursor: ...) is really what is wanted

[16:49] <pmichaud> okay.

[16:50] <ruoso> (Cursor that pretends to be a Match)++

[16:50] <TimToady> if $cursor is the result of a previous match, and we haven't denatured the Cursor to pure Match, it should work

[16:51] <TimToady> or Match can respawn a Cursor at need

[16:51] <pmichaud> I like that latter one

[16:51] <pmichaud> here's what I'd find a bit odd (more)

[16:52] <pmichaud> grammar A { regex TOP { foo } };   my $match = A.parse('foo');   say $match ~~ A;   # true

[16:53] <TimToady> yes, a match knows what language it is

[16:53] <pmichaud> okay

[16:53] <TimToady> well, a cursor does

[16:53] <pmichaud> right, I know that a cursor does; just wanted to make sure that we're comfortable with Match objects acting like "does grammar"

[16:53] <pmichaud> (PGE currently has this feature as well... checking to see if it's legit)

[16:54] *** am0c joined
[16:54] <pmichaud> and with

[16:54] <pmichaud> grammar A { regex TOP { foo };   regex bar { bar }; }  my $match = A.parse('foo');   my $b = $match.bar();   #  $b is a valid match object?

[16:55] <pmichaud> sorry, parse 'foobar' instead of just 'foo'

[16:55] <pmichaud> grammar A { regex TOP { foo };   regex bar { bar }; };  my $match = A.parse('foobar');   my $b = $match.bar();   #  $b is a valid match object?

[16:57] <TimToady> I think so; it's up to TOP to enforce $ constraint, and this one doesn't

[16:57] <pmichaud> okay

[16:57] *** [particle] joined
[16:57] <pmichaud> this last one is kind of edge-case-y, I don't need a definitive ruling on it yet

[16:57] <TimToady> likewise grammar A might call down into a callback that deals in A's cursors

[16:58] <pmichaud> s/is/was/

[16:58] <pmichaud> your answers give me enough to be "close enough" for now

[16:58] <TimToady> "this" is always a bit dodgy in English :)

[16:59] <pmichaud> anyway, regexes are methods that want cursors as invocants and return a "cursor pretends Match" as a result

[16:59] <pmichaud> here's one that PGE currently has difficult with, though

[17:00] <[particle]> $_ is less dodgy?

[17:00] <pmichaud> grammar A { regex TOP { foo };   regex orig { bar }; };  my $match = A.parse('foobar');   my $b = $match.orig();   #  $b is a valid match object?

[17:00] <pmichaud> or

[17:00] <pmichaud> grammar A { regex TOP { foo };   regex from { bar }; };  my $match = A.parse('foobar');   my $b = $match.from();   #  $b is a valid match object?

[17:00] <saran> can anyone give me a link for the implementation of hash in perl6 ?

[17:01] <moritz_> erm, isn't .orig a Str and .from a StrPos?

[17:01] <pmichaud> moritz_: yes, that's why this example is difficult.  :)

[17:01] <pmichaud> we end up with a conflict between cursor methods and match methods

[17:01] <pmichaud> that's why PGE doesn't currently work well for grammars that attempt to define 'from', 'to', 'orig', etc.  regexes

[17:03] <pmichaud> the question becomes... when a Cursor pretends to be a Match, do the Match methods override the Cursor ones?

[17:03] <pmichaud> (I'm okay if the answer is "yes"... just would like it to be explicitly "yes"  :-)

[17:05] <pmichaud> but we also run into an issue with

[17:06] <pmichaud> grammar A { regex TOP { <b> };  regex b { foo };  regex from { bar }; };   my $match = A.parse('foobar');

[17:06] <pmichaud> or, more hurtful:

[17:07] <pmichaud> grammar A { regex TOP { <b> };  regex b { foo <from> };  regex from { bar }; };   my $match = A.parse('foobar');

[17:07] <pmichaud> grammar A { regex TOP { <b> <from> };  regex b { foo };  regex from { bar }; };   my $match = A.parse('foobar');

[17:08] <pmichaud> if the subrule call to <b> gives us back "a Cursor pretending to be a match", we might run into difficulties when we try to call the <from> subrule using that cursor.

[17:09] <TimToady> make the bad man go away...

[17:09] <pmichaud> I had been somewhat leaning towards "regex always returns a Cursor, and one can get a Match object out of the cursor"

[17:09] <pmichaud> i.e., we could do   $cursor.match

[17:10] *** NorwayGeek joined
[17:10] <pmichaud> since most invocations of regexes are indirect (via smartmatch, .parse, etc.), that might not be too onerous

[17:11] <TimToady> that makes more sense than always requiring a .cursor

[17:12] <TimToady> well, now you can't have a rule <match> :)

[17:12] <pmichaud> okay,  .MATCH

[17:12] <TimToady> .MATCH 

[17:12] <TimToady> currently Cursor stores from and to as .<_from> and .<_to> actually

[17:12] <pmichaud> I figured that was implementation more than spec

[17:13] *** rfordinal joined
[17:13] <TimToady> yeah, though it leaks here and there

[17:13] <pmichaud> right

[17:13] <pmichaud> PGE and PCT do similar "we treat hash elements like attributes" tricks as well, which also leak

[17:15] <pmichaud> I've also been working with the idea that instead of each Cursor having its own copy of the "match object", that it simply carries a pointer to the current Match object

[17:15] <pmichaud> Match objects are immutable during the match

[17:15] <pmichaud> well, as far as the engine is concerned, they're immutable

[17:15] <pmichaud> whenever we add something to the match object, we simply create a new Match object that holds the addition and set the cursor to use that new Match object

[17:16] <pmichaud> if we backtrack out of the cursor, we end up with the previous match

[17:19] <pmichaud> also, I've been looking at doing cursors as linked lists instead of arrays of cursors

[17:19] <pmichaud> i.e., each cursor has a reference to the cursor that spawned it

[17:20] <TimToady> whoops, kid to school &

[17:20] <pmichaud> okay, lunch here

[17:20] <pmichaud> I'll keep going with some of these ideas and see where things end up.  I'm hoping to blog about design notes each day.

[17:20] <pmichaud> or every couple of days.

[17:21] <pmichaud> since there's a lot of interest in the topic, it'll be easier for me to develop a design/implementation guide that way

[17:21] <pmichaud> afk, lunch

[17:23] *** dukeleto joined
[17:25] *** dukeleto left
[17:25] *** Zloyrusskiy joined
[17:32] *** tak11 left
[17:33] *** jaldhar left
[17:36] *** molaf_x left
[17:41] *** ejs left
[17:41] *** zerhash joined
[17:43] *** saran left
[17:47] *** gbacon joined
[17:48] *** tak11 joined
[17:48] *** NorwayGeek left
[17:48] *** NorwayGeek joined
[18:03] *** ejs joined
[18:06] *** MrRandom joined
[18:06] *** mberends joined
[18:07] *** tak11 left
[18:07] <MrRandom> how to update my rakudo to the newest from git (and also Parrot from svn)?

[18:10] *** MrRandom left
[18:13] *** Zloyrusskiy left
[18:14] *** ejs left
[18:18] *** ejs joined
[18:23] *** ispy__ joined
[18:26] *** ejs left
[18:33] *** ejs joined
[18:35] *** ispy_ left
[18:39] *** Student left
[18:42] <mberends> rakudo: "$_-{$_.uc}".say for <foo bar baz>

[18:42] <p6eval> rakudo 0eaf62: OUTPUT«foo-FOO␤bar-BAR␤baz-BAZ␤»

[18:42] <mberends> rakudo: "$p-{$p.uc}".say for <foo bar baz> -> $p

[18:42] <p6eval> rakudo 0eaf62: OUTPUT«Confused at line 2, near "-> $p"␤in Main (src/gen_setting.pm:3469)␤»

[18:43] <pmichaud> the -> $p always goes with the block

[18:43] <mberends> rakudo: { "$p-{$p.uc}".say } for <foo bar baz> -> $p

[18:43] <p6eval> rakudo 0eaf62: OUTPUT«Confused at line 2, near "-> $p"␤in Main (src/gen_setting.pm:3469)␤»

[18:43] <pmichaud> -> $p { "$p-{$p.uc}".say } for <foo bar baz>;

[18:43] <mberends> sorry

[18:43] <pmichaud> rakudo: -> $p { "$p-{$p.uc}".say } for <foo bar baz>;

[18:43] <mberends> thanks

[18:43] <p6eval> rakudo 0eaf62:  ( no output )

[18:43] <pmichaud> eh, it's busted.  :)

[18:43] <pmichaud> anyway, with   for @list -> $x { ... }

[18:44] <pmichaud> the "-> $x" is part of the block, not the for

[18:44] <mberends> it was different in a script: said Confused, but worked anyway

[18:44] <pmichaud> heh

[18:44] <pmichaud> rakudo: (-> $p { "$p-{$p.uc}".say }).($_) for <foo bar baz>;

[18:44] <p6eval> rakudo 0eaf62: OUTPUT«foo-FOO␤bar-BAR␤baz-BAZ␤»

[18:44] <pmichaud> there.

[18:45] <mberends> :-) not the elegant golf I was aiming for

[18:45] <pmichaud> okay

[18:46] <pmichaud> rakudo:  "$^p->{$^p.uc}".say for <foo bar baz>;

[18:46] <p6eval> rakudo 0eaf62: OUTPUT«too few arguments passed (0) - 1 param expected␤in Main (/tmp/FtPDB8Gde9:0)␤»

[18:46] <pmichaud> hmmmmmm

[18:46] <mberends> tried $^p a few ways

[18:46] <pmichaud> rakudo:  "$^p-{$^p.uc}".say for <foo bar baz>;

[18:46] <p6eval> rakudo 0eaf62: OUTPUT«too few arguments passed (0) - 1 param expected␤in Main (/tmp/e33Vgp82au:0)␤»

[18:46] <pmichaud> rakudo:  ($^p~"-{$^p.uc}")say for <foo bar baz>;

[18:47] <p6eval> rakudo 0eaf62: OUTPUT«Confused at line 2, near "say for <f"␤in Main (src/gen_setting.pm:3469)␤»

[18:47] <pmichaud> oh, yes

[18:47] <pmichaud> that's right, $^p wouldn't work there either

[18:47] <TimToady> I hope you're not thinking that the inside $^p is the same as the outside one

[18:47] <pmichaud> right

[18:47] <pmichaud> I was, I'm not.

[18:47] <mberends> rakudo:  {$^p~"-{$^p.uc}".say } for <foo bar baz>;

[18:47] <p6eval> rakudo 0eaf62: OUTPUT«too few arguments passed (0) - 1 param expected␤in Main (/tmp/uxZTWfyTkS:2)␤»

[18:47] <mberends> nah

[18:47] <pmichaud> inside of  the curlies, the $^p isn't the same as the one in the string

[18:48] <pmichaud> and the one in the string isn't the argument from for, it's $^p in the outer block

[18:48] <TimToady> why do you want a double closure?

[18:48] <pmichaud> (i.e., the block containing the for)

[18:48] <mberends> no, no want double closure

[18:48] * pmichaud goes back to doing grammar engine work, which is much less confusing.  :)

[18:50] <mberends> rakudo: for <foo bar baz> -> $p { "$p-{$p.uc}".say } # was trying to turn this around

[18:50] <p6eval> rakudo 0eaf62: OUTPUT«foo-FOO␤bar-BAR␤baz-BAZ␤»

[18:50] <pmichaud> map.

[18:50] <mberends> yes.

[18:51] *** szabgab left
[18:51] <pmichaud> rakudo: .say for <foo bar baz>.map({"$^p-{$^p.uc}"});

[18:51] <p6eval> rakudo 0eaf62: OUTPUT«too few arguments passed (0) - 1 param expected␤in method Any::map (/tmp/EiB41e5L7Y:2)␤called from Main (/tmp/EiB41e5L7Y:2)␤»

[18:52] <pmichaud> bah.

[18:52] <diakopter> humbug.

[18:52] <TimToady> rakudo: .say for <foo bar baz>.map({"$^p-$($^p.uc)");

[18:52] <p6eval> rakudo 0eaf62: OUTPUT«Can't use $ as non-variable in interpolated string at line 2, near "$($^p.uc)\""␤in Main (src/gen_setting.pm:3469)␤»

[18:53] *** ejs left
[18:53] <TimToady> std: .say for <foo bar baz>.map({"$^p-$($^p.uc)");

[18:53] <p6eval> std 28379: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse block; couldn't find final '}' at /tmp/X9BLPA2nBe line 1:␤------> [32my for <foo bar baz>.map({"$^p-$($^p.uc)"[33m⏏[31m);[0m␤    expecting any of:␤ standard stopper␤ statement modifier loop␤  terminator␤     whitespace␤FAILED

[18:53] <p6eval> ..00:02 97m␤»

[18:53] <TimToady> std: .say for <foo bar baz>.map({"$^p-$($^p.uc)"});

[18:53] <p6eval> std 28379: OUTPUT«ok 00:02 97m␤»

[18:53] <mberends> rakudo: <foo bar baz>.map({"$_-{$_.uc}"})>>.say

[18:53] <TimToady> rakudo: .say for <foo bar baz>.map({"$^p-$($^p.uc)"});

[18:53] <p6eval> rakudo 0eaf62: OUTPUT«foo-FOO␤bar-BAR␤baz-BAZ␤»

[18:53] <p6eval> rakudo 0eaf62: OUTPUT«Can't use $ as non-variable in interpolated string at line 2, near "$($^p.uc)\""␤in Main (src/gen_setting.pm:3469)␤»

[18:53] <diakopter> rakudo: .say for <foo bar baz>.map({"$^p-" ~ $($^p.uc)});

[18:53] <p6eval> rakudo 0eaf62: OUTPUT«foo-FOO␤bar-BAR␤baz-BAZ␤»

[18:54] <TimToady> I lose

[18:54] <mberends> .map++

[18:56] <mberends> the actual line was: for @projects -> $p { say "$p: {$.ecosystem.get-state($p)}"; }

[18:56] <TimToady> rakudo: .say for <foo bar baz>.map({"$^p-&Str($^p.uc)"});

[18:56] <p6eval> rakudo 0eaf62: OUTPUT«foo-&Str(foo.uc)␤bar-&Str(bar.uc)␤baz-&Str(baz.uc)␤»

[18:57] <pmichaud> heh

[18:57] <TimToady> heh

[18:57] <TimToady> so much for the & approach

[18:57] <pmichaud> so far rakudo only knows $ interpolation

[18:57] <diakopter> rakudo: say 1+<&map

[18:57] <p6eval> rakudo 0eaf62: OUTPUT«2␤»

[18:58] <diakopter> rakudo: urban

[18:58] <p6eval> rakudo 0eaf62: OUTPUT«Could not find non-existent sub urban␤»

[18:59] <mberends> the old jokes never die

[19:00] <TimToady> they just smell that way

[19:00] <mberends> :-)

[19:01] <diakopter> rakudo: trahend

[19:01] <p6eval> rakudo 0eaf62: OUTPUT«Could not find non-existent sub trahend␤»

[19:01] *** diakopter was kicked by TimToady (TimToady))
[19:01] <pmichaud> rakudo: stantial

[19:01] <p6eval> rakudo 0eaf62: OUTPUT«Could not find non-existent sub stantial␤»

[19:01] *** pmichaud was kicked by TimToady (TimToady))
[19:02] *** pmichaud joined
[19:02] <mberends> now who's laughing?

[19:02] <TimToady> sorry, my finger slipped

[19:02] <pmichaud> :)

[19:03] *** ChanServ sets mode: -o TimToady

[19:03] <pmichaud> rakudo:  trans stantiate

[19:03] <p6eval> rakudo 0eaf62: OUTPUT«Could not find non-existent sub stantiate␤»

[19:03] *** diakopter joined
[19:04] *** ChanServ sets mode: -o jnthn

[19:04] *** ChanServ sets mode: -o Juerd

[19:04] *** ChanServ sets mode: -o moritz_

[19:04] *** ChanServ sets mode: -o PerlJam

[19:05] *** pmurias joined
[19:06] <mberends> rakudo: verted-channel-perl6

[19:06] <p6eval> rakudo 0eaf62: OUTPUT«Could not find non-existent sub verted-channel-perl6␤»

[19:06] *** ChanServ sets mode: +o PerlJam

[19:06] *** ChanServ sets mode: +o moritz_

[19:06] <mberends> WHOZ OP

[19:06] *** ChanServ sets mode: +o Juerd

[19:06] *** ChanServ sets mode: +o jnthn

[19:06] *** ChanServ sets mode: +o pmichaud

[19:06] *** ChanServ sets mode: +o TimToady

[19:08] <diakopter> rakudo: sub sub {1}; say sub;

[19:08] <p6eval> rakudo 0eaf62: OUTPUT«Malformed routine definition at line 2, near ";"␤in Main (src/gen_setting.pm:3469)␤»

[19:09] <TimToady> std: sub sub {1}; say sub;

[19:09] <p6eval> std 28379: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block at /tmp/wTKGVZect5 line 1:␤------> [32msub sub {1}; say sub[33m⏏[31m;[0m␤    expecting any of:␤       block␤  name␤     nofun␤    routine_def␤      terminator␤       trait␤    whitespace␤FAILED 00:01 98m␤»

[19:09] <TimToady> std: sub sub {1}; say sub();

[19:09] <p6eval> std 28379: OUTPUT«ok 00:01 95m␤»

[19:10] <TimToady> rakudo: sub sub {1}; say sub();

[19:10] <p6eval> rakudo 0eaf62: OUTPUT«1␤»

[19:10] <TimToady> sub is one of the rare keywords that doesn't require \s

[19:14] <diakopter> rakudo: package package { say ::package }

[19:14] <p6eval> rakudo 0eaf62: OUTPUT«No applicable candidates found to dispatch to for 'iterator'␤in sub say (src/gen_setting.pm:1362)␤called from Main (/tmp/SCXWSNdfcI:2)␤»

[19:17] <mberends> TimToady: for @a { ... } else { ... } # is fiction, right?

[19:17] <TimToady> yes

[19:17] <mberends> ok, thanx

[19:19] <TimToady> for @a or void ... { ... }

[19:19] <TimToady> or

[19:20] <TimToady> for @a { ... } or void ...

[19:20] <TimToady> nyi, likly

[19:20] <TimToady> *likely

[19:20] <TimToady> rakudo: void say "yes"

[19:20] <p6eval> rakudo 0eaf62: OUTPUT«yes␤Could not find non-existent sub void␤»

[19:21] <pmichaud>  /kick TimToady  # oh wait, he wasn't trying another sub pun

[19:21] <diakopter> rakudo: say loop (;;){ break }

[19:21] <TimToady> my next trick will be to report that error message as a bug

[19:21] <p6eval> rakudo 0eaf62: OUTPUT«␤Null PMC access in can()␤in Main (/tmp/DaBR69hwOG:2)␤»

[19:22] <diakopter> but can he do the can can

[19:23] <diakopter> rakudo: loop (;;break){}

[19:24] <p6eval> rakudo 0eaf62:

[19:24] <p6eval> ..OUTPUT«␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤􏿽xE2

[19:24] <diakopter> my eyes, my eyes!

[19:24] <mberends> diakopter:  give us a break!

[19:24] <diakopter> heh

[19:24] <diakopter> that's what I was trying to do

[19:24] <Tene> rakudo: break;

[19:25] <p6eval> rakudo 0eaf62: OUTPUT«␤»

[19:25] <Tene> rakudo: loop (;;last){}

[19:25] <p6eval> rakudo 0eaf62:  ( no output )

[19:25] <diakopter> :)

[19:25] <TimToady> std: loop (;;){}

[19:25] <p6eval> std 28379: OUTPUT«ok 00:01 98m␤»

[19:25] <TimToady> hmm

[19:25] <TimToady> that shouldn't be allowed

[19:26] <diakopter> rakudo: loop (;;){}

[19:26] <diakopter> oh, weird.

[19:26] <p6eval> rakudo 0eaf62:  ( no output )

[19:26] <diakopter> :) p6eval replied with something (not timeout)

[19:26] <diakopter> o wait

[19:26] <diakopter> rakudo: say loop (;;){}

[19:26] <p6eval> rakudo 0eaf62: OUTPUT«too few arguments passed (0) - 3 params expected␤in Main (/tmp/vlOITeceK0:2)␤»

[19:27] <TimToady> std: say loop (;;){}

[19:27] <p6eval> std 28379: OUTPUT«Undeclared routine:␤   loop used at line 1␤ok 00:01 95m␤»

[19:27] <diakopter> o

[19:28] <TimToady> std: say loop{}

[19:28] <p6eval> std 28379: OUTPUT«Undeclared routine:␤   loop used at line 1␤ok 00:01 95m␤»

[19:29] <TimToady> std: say loop {}

[19:29] <p6eval> std 28379: OUTPUT«Undeclared routine:␤   loop used at line 1␤ok 00:01 95m␤»

[19:29] <TimToady> std: say do loop {}

[19:29] <p6eval> std 28379: OUTPUT«ok 00:02 95m␤»

[19:29] <diakopter> rakudo: loop (;last if last;){ say 3 }

[19:29] <p6eval> rakudo 0eaf62: OUTPUT«␤Null PMC access in get_bool()␤in Main (/tmp/F07UQSwhAc:2)␤»

[19:30] <pmichaud> afk # kid pickup

[19:30] <diakopter> whenever I read "Null PMC access" all I can hear in my mind is "null pointer exception"

[19:30] <TimToady> to be consistent with other loops it should really not allow you to leave out the space before the {}

[19:33] <diakopter> rakudo: loop (;;say 3,last){ say 3 }

[19:33] <p6eval> rakudo 0eaf62: OUTPUT«3␤»

[19:33] <diakopter> just looking for clarification - does last immediately leave or post-statement leave

[19:34] <diakopter> probably a S has the answer

[19:34] <pmichaud> I'd somewhat expect "last" there to leave whatever construct the loop is in

[19:35] <pmichaud> i.e.,:   for @foo {   loop (;;say 3,last) { say 4 } }   # I think the "last" affects the outer "for"

[19:37] <diakopter> rakudo: my $a = 2; loop (;;){ say ++$a,last,++$a }; say $a;

[19:37] <p6eval> rakudo 0eaf62: OUTPUT«3␤»

[19:39] <diakopter> rakudo: my $a = 0; loop (;;){ say $a, (last if $a++) }; say $a;

[19:39] <p6eval> rakudo 0eaf62: OUTPUT«1␤2␤»

[19:39] <diakopter> the first say is missing?

[19:41] <diakopter> rakudo: my $a = 0; loop (;;){ say $a; say $a, (last if $a++) }; say $a;

[19:41] <p6eval> rakudo 0eaf62: OUTPUT«0␤1␤1␤2␤»

[19:42] <diakopter> \./

[19:42] <diakopter> er, um  |.|

[19:46] <diakopter> I mean, what's the symbol for arms-raised-palms-up-in-ignorance

[19:47] <diakopter> as in, "someone please tell me where I'm wrong here, or explain what's going on"

[19:48] <TimToady> rakudo: my $a = 0; say $a, $a++

[19:48] <p6eval> rakudo 0eaf62: OUTPUT«10␤»

[19:49] <diakopter> RTL?

[19:49] <TimToady> no, think what's happening with references

[19:49] *** crythias joined
[19:49] <diakopter> oh, a capture?

[19:49] <diakopter> I mean, parcel.

[19:49] <TimToady> $a can't know whether it's going to be bound rw

[19:50] <TimToady> so it doesn't actually look up its value till the slurpy does it

[19:50] <TimToady> by then $a++ has already run

[19:53] <diakopter> rakudo: my $a = 0; say ++$a, $a++, $a

[19:53] <p6eval> rakudo 0eaf62: OUTPUT«212␤»

[19:54] *** nihiliad1 joined
[19:56] *** Matt-W left
[19:59] <diakopter> my question with 0112 was that the second "0" is missing from the output. as in:

[19:59] <diakopter> rakudo: my $a = 0; loop (;;){ say $a; say $a, (last if $a++) };

[19:59] <p6eval> rakudo 0eaf62: OUTPUT«0␤1␤1␤»

[19:59] <diakopter> shouldn't $a get to the 2nd say() when $a is 0?

[20:03] <crythias> say, say say what you want but don't play games with my affection.

[20:03] <TimToady> it does, but it's 1

[20:03] <TimToady> that was my point

[20:04] <TimToady> you increment $a++ before the second say can read 0 from $a

[20:04] <diakopter> ooohh. ok. I was misremembering... *now* my question *was* (:)) then the final "2" is missing from that output

[20:04] <diakopter> if last doesn't leave immediately

[20:05] <TimToady> the last also runs before the say

[20:05] *** Student joined
[20:05] <diakopter> does 'last' mean 'jump to the end of this loop after the innermost statement surrounding the expression last is in is finished' or 'jump now'

[20:06] <Tene> It currently means the latter in rakudo, and I've seen no indication tha tit should mean otherwise.

[20:07] <diakopter> oky doky

[20:07] <Tene> My initial inclination is that the former would be confusing and awkward.

[20:09] <crythias> perl6: It's a hammer in search of a screw.

[20:09] <p6eval> elf 28406: OUTPUT«Parse error in: /tmp/UhuRBUZWlj␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: It's a hammer in search of a s␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[20:09] <p6eval> ..STD_red…

[20:09] <p6eval> ..rakudo 0eaf62: OUTPUT«Confused at line 2, near "."␤in Main (src/gen_setting.pm:3469)␤»

[20:09] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "'"␤    expecting "::", dot, ":", "(", term postfix or operator␤    at /tmp/ro6CWkxL5O line 1, column 3␤»

[20:09] * diakopter cackles

[20:09] *** hudnix left
[20:11] *** tak11 joined
[20:11] *** nihiliad left
[20:11] <TimToady> 'z' xx *; &

[20:27] *** dukeleto joined
[20:27] *** __ash__ joined
[20:28] *** crythias left
[20:37] *** Matt-W joined
[20:44] <Matt-W> colomon: re C and F recorders, you learn different notes, the music is written at concert pitch. Recorders in G and D are rarer, and sometimes they're written transposing for the sake of the players

[20:44] *** xomas_ joined
[20:45] <Matt-W> colomon: some people do play an F recorder by transposing in their heads at sight to C though...

[21:02] <lucs_> Matt-W: Do you mean that they manage to "see" the printed note a fourth below (or maybe a fifth above)?

[21:03] <Matt-W> lucs_: pretty much, yes. They see a written G and they manage to convert that to a D and finger what would be a D on a C recorder and they get a G

[21:04] <lucs_> Hmm...

[21:04] <Matt-W> I don't know how they do it

[21:04] <Matt-W> but the ones who are really good can use the same technique to play instruments in D and G without much effort, which is handy

[21:04] <Matt-W> I'd have to have transposed music or relearn the fingerings again

[21:05] <Matt-W> I play C and F as different instruments, essentially

[21:05] <Matt-W> and I can play F instruments from treble or bass clef, need to learn to read that for C instruments so I can play great bass more easily

[21:06] *** am0c left
[21:06] <lucs_> ftw :)

[21:07] <Matt-W> more concerned right now in learning to read lute from score

[21:08] <lucs_> How are those tuned compared to a guitar?

[21:08] <lucs_> (And they have more strings maybe?)

[21:09] <Matt-W> my lute has eight courses, seven of which are double strung

[21:09] <Matt-W> the first six are tuned the same as a tenor viol - GDAFCG (descending), then two more at F and D

[21:09] <lucs_> (I should wikipedia, but thanks!)

[21:10] <Matt-W> the basic renaissance lute is six courses, but a lot of Dowland's music requires seven and sometimes eight or nine

[21:11] <Matt-W> my teacher keeps saying it should be easy for me to read score because it's the same as a tenor viol

[21:11] <Matt-W> but he forgets that I play bass viol, and that's got a different set of strings

[21:11] <lucs_> Do you have to tweak the tuning when playing in different keys or is it tuned equal tempered?

[21:12] <Matt-W> I've been using vilotti temprement - it's what I use on my viol and it seems to work

[21:12] <Matt-W> I don't know what my teacher would use though, I've not spoken to him about it much

[21:12] <lucs_> Oookay :)

[21:12] <Matt-W> I know equal temprement sounds hideous though

[21:12] <Matt-W> (and I can't spell, I know)

[21:13] <lucs_> Well, equal temperament turned out to be a useful compromise, but it's hard to beat clean intervals.

[21:14] <lucs_> Good luck with all those instrument variations!

[21:15] * lucs_ & # Dishes...

[21:16] <Matt-W> we don't use equal much in early music

[21:17] <Matt-W> we don't play in a huge variety of keys, so we can keep it under control using other options, and it means that our different keys do actually sound subtly different, which is nice

[21:22] *** zamolxes joined
[21:22] *** arthur-_ left
[21:25] <colomon> Matt-W: One of my high school friends has gotten professionally into early music, and I treasure my memory of him stopping to retune their keyboard instrument between numbers so it could handle a key change.  :)

[21:28] *** ruoso left
[21:30] <Matt-W> colomon: I've never seen that done

[21:31] <Matt-W> colomon: probably using a different temperament again to what I use

[21:31] <Matt-W> my teacher's always going on about how we should be using quarter comma meantone, but I gather that's an enormous hassle

[21:31] <colomon> Matt-W: He only had to retune a couple of notes to make it work... and being by far my superior at these things, he could do it by ear.

[21:32] <Matt-W> well when you get to the level when you really really care, you should be!

[21:32] <Matt-W> bet it sounded good though

[21:34] *** scottp joined
[21:35] <colomon> Matt-W: It did, though I must confess my tastes in music are more for stuff from 1800 on.  :)

[21:36] *** KyleHa left
[21:37] <lucs_> Yet, for example, Dowland++

[21:38] *** scottp left
[21:38] *** scottp joined
[21:38] *** scottp left
[21:38] *** scottp joined
[21:38] *** scottp left
[21:39] *** scottp joined
[21:41] *** ispy__ left
[21:41] *** Matt-W_ joined
[21:42] <colomon> lucs_: Don't think I am at all familiar with Dowland.

[21:49] <lucs_> Oh, great stuff.

[21:50] *** rindolf joined
[21:50] <rindolf> Hi all.

[21:53] <lucs_> Well, maybe not great, but pretty good, and quite enjoyable :)

[21:53] *** jauaor joined
[21:53] *** Matt-W left
[21:54] <Tene> pmichaud: github is migrating from Engine Yard to Rackspace at 17:00 Sunday

[21:56] <rindolf> Hi Tene 

[21:56] <Tene> hi rindolf

[21:57] *** arthur-_ joined
[22:02] *** __ash__ left
[22:06] <pmichaud> Tene: interesting.  I hope it goes well.

[22:06] *** NorwayGeek|Away joined
[22:06] <pmichaud> 17:00 edt?  pdt?  gmt?

[22:06] <Tene> PDT

[22:07] <pmichaud> http://github.com/blog/497-rackspace-move-scheduled-for-sunday-september-27th-at-5pm-pacific-time

[22:07] *** NorwayGeek left
[22:08] <pmichaud> looks like they plan for an hour of push unavailability.  I can live with that.

[22:09] <pmichaud> from a rakudo perspective, this sunday is probably a good time

[22:09] <pmichaud> I'd much prefer that to 3 weeks from now when we're about to do a release :)

[22:09] <pmichaud> and there's plenty of time to deal with migration issues

[22:10] <Tene> hehe

[22:22] *** NorwayGeek|Away is now known as NorwayGeek

[22:22] *** NorwayGeek is now known as NorwayGeke

[22:32] *** FCO left
[22:42] *** ab5tract joined
[22:47] *** FCO joined
[22:49] *** icwiener left
[22:56] *** Whiteknight joined
[23:05] *** s1n_mini joined
[23:26] *** ab5tract left
[23:31] <pugs_svn> r28407 | lwall++ | [viv] handle ast-less nodes like the bits of rad_number 

[23:31] <pugs_svn> r28407 | [STD] move pi, e, and i out of term:-space; they are now just CORE constants

[23:34] *** ewilhelm left
[23:34] *** ewilhelm joined
[23:35] <scottp> Hey guys. I was just searching the net, but with no luck, has anyone found a solution to getting Rakudu working on Snow Leopard - I am getting the bug as per http://www.mail-archive.com/perl6-all@perl.org/msg86462.html

[23:39] *** s1n_mini left
[23:42] <TimToady> maybe the CORE::i should really be 𝚒 (MATHEMATICAL MONOSPACE SMALL I)

[23:43] *** iblechbot left
[23:44] <colomon> scottp: Wow, that sounds really close to a (regular) Leopard bug from a few months back.  Not that I remember anything useful about it....

[23:46] <scottp> colomon: I have tried a "make clean" and "make distclean" in both parrot and rakudo. My next step is to try a different build of Parrot.

[23:47] <colomon> What version of GCC do you have on Snow Leopard?

[23:48] <colomon> Oooo, first clue?  That file is in config/gen/platform/generic/hires_timer.c but should probably be in config/gen/platform/darwin/hires_timer.c instead.

[23:54] <colomon> I mean, it's compiling the generic version when it should probably be compiling the darwin version.

[23:56] <diakopter> ++TimToady

[23:58] <TimToady> since it's in the generic AUTOLOAD, it should probably help elsewhere as well

[23:58] <diakopter> yay; intpart has TEXT

[23:58] <colomon> scottp: I would look at parrot/config/auto/arch.pm for clues.

[23:58] <colomon> scottp: Though glancing at it I don't see any obvious reason it wouldn't work.

[23:59] <colomon> (Though you're using the 64-bit Snow Leopard, I take it?  That may have something to do with it.)

[23:59] <diakopter> \\\

[23:59] <diakopter> \ is not backspace

