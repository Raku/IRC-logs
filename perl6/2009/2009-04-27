[00:00] *** eternaleye left
[00:04] *** goksie left
[00:11] *** eternaleye joined
[00:13] *** jferrero left
[00:13] *** Whiteknight joined
[00:18] *** Whiteknight is now known as wknight8111

[00:24] *** justatheory joined
[00:44] *** cls_bsd joined
[00:44] *** payload1 left
[00:47] *** justatheory left
[00:52] *** lumi left
[00:52] <LylePerl> rakudo: "hello".say

[00:52] <p6eval> rakudo c4f676: OUTPUT«hello␤»

[00:52] <LylePerl> rakudo: "hello".print

[00:52] <p6eval> rakudo c4f676: OUTPUT«hello»

[01:05] *** lumi joined
[01:08] *** Grrrr joined
[01:12] *** eternaleye left
[01:12] *** eternaleye joined
[01:14] *** wknight8111 left
[01:23] *** samlh joined
[01:36] *** Limbic_Region left
[01:37] *** bacek__ joined
[01:40] *** bacek_ left
[01:42] *** dukeleto joined
[01:43] *** eternaleye left
[01:57] *** nihiliad left
[02:04] *** redicaps joined
[02:20] *** justatheory joined
[02:20] *** bacek joined
[02:40] *** amoc joined
[02:44] *** nihiliad joined
[02:52] *** FurnaceBoy left
[03:15] *** cspencer joined
[03:19] *** jamtech joined
[03:22] *** nbrown left
[03:25] *** jamtech left
[03:28] *** skids_ left
[03:29] *** jamtech joined
[03:31] *** jamtech left
[03:31] *** jamtech joined
[03:41] *** jamtech left
[03:44] *** orafu joined
[04:00] *** redicaps left
[04:03] *** eternaleye joined
[04:04] *** SamB left
[04:26] *** mikehh joined
[04:27] *** FurnaceBoy joined
[04:27] *** cspencer left
[04:33] *** FurnaceBoy left
[04:35] *** twigil joined
[04:35] <mikehh> I built rakudo (c4f6736) on parrot r38376 about 4/5 hours ago and left make spectest running - it failed on t/spec/S06-signature/named-parameters.rakudo

[04:35] <mikehh> Parse errors: Bad plan.  You planned 75 tests but ran 45

[04:36] <mikehh> i then ran ./perl6 t/spec/S06-signature/named-parameters.rakudo and it PASSed

[04:37] *** twigil left
[04:38] *** orafu left
[04:38] *** orafu joined
[04:40] <s1n1> rakudo: run("env PATH=\$PATH:junktest echo \$PATH")

[04:40] <p6eval> rakudo c4f676: OUTPUT«/usr/local/bin:/usr/bin:/bin:/usr/games␤»

[04:41] <s1n1> hmm, can i not set environment variables inline like that in rakudo or did i do something wrong there?

[04:42] <s1n1> rakudo: $*ENV{TEST} = 'junk'; say $*ENV{TEST}

[04:42] <p6eval> rakudo c4f676: OUTPUT«Could not find non-existent sub TEST␤current instr.: '_block14' pc 65 (EVAL_17:44)␤»

[04:46] *** alester_ joined
[04:49] *** masak joined
[04:50] <masak> morning, gather-camels.

[04:50] <lambdabot> masak: You have 1 new message. '/msg lambdabot @messages' to read it.

[04:50] <masak> @messages

[04:50] <lambdabot> frettled said 6h 5m 37s ago: (expt masak 2) for that blog post

[04:50] <masak> :P

[05:03] *** tarbo2 left
[05:06] <s1n1> rakudo: %*ENV{TEST} = 4; say %*ENV{TEST

[05:06] <s1n1> akk

[05:06] <p6eval> rakudo c4f676: OUTPUT«Statement not terminated properly at line 1, near "{TEST"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:85)␤»

[05:06] <s1n1> rakudo: %*ENV{TEST} = 4; say %*ENV{TEST}

[05:06] <p6eval> rakudo c4f676: OUTPUT«Could not find non-existent sub TEST␤current instr.: '_block14' pc 65 (EVAL_17:44)␤»

[05:06] <masak> s1n1: no autoquoting in .{} in Perl 6

[05:07] <s1n1> oh heh, i'm a tard

[05:07] <s1n1> %*ENV{'TEST'} = 4; say %*ENV{'TEST'}

[05:07] <s1n1> rakudo: %*ENV{'TEST'} = 4; say %*ENV{'TEST'}

[05:07] <p6eval> rakudo c4f676: OUTPUT«␤»

[05:08] <s1n1> hmm

[05:08] <s1n1> just newline?

[05:08] <s1n1> am i just too sleep deprived??

[05:08] <masak> the newline is due to 'say'.

[05:08] <masak> s1n1: no, it's %*ENV that's broken.

[05:08] <masak> been thus since last summer.

[05:08] <masak> there's an extensive RT ticket about it.

[05:09] *** s1n1 is now known as s1n

[05:09] <masak> [perl #57400]

[05:10] <s1n> masak: thanks

[05:10] <masak> http://rt.perl.org/rt3/Ticket/Display.html?id=57400

[05:11] <szabgab> good morning ppl

[05:11] <szabgab> rakudo: say 1 ^^ 1

[05:11] <p6eval> rakudo c4f676: OUTPUT«␤»

[05:12] <szabgab> rakudo: say 1 ^^ 1 ^^ 1

[05:12] <p6eval> rakudo c4f676: OUTPUT«1␤»

[05:12] <szabgab> rakudo: say [^^] 1, 1

[05:12] <masak> szabgab: mornin'

[05:12] <p6eval> rakudo c4f676: OUTPUT«say requires an argument at line 1, near " [^^] 1, 1"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:85)␤»

[05:12] <szabgab> is masak filing a bug ?

[05:12] <masak> szabgab: he could be, if you like.

[05:13] *** tarbo2 joined
[05:13] <szabgab> ^^ is bitwise xor right ?

[05:13] <masak> szabgab: I thought it was Bool xor.

[05:13] <masak> szabgab: ?^ ought to be bitwise.

[05:13] <szabgab> let me look at my slides :-)

[05:13] <szabgab> actually I meant bool xor, yes

[05:14] <szabgab>  I am just still asleep a bit

[05:14] <masak> hm, or maybe +^ is bitwise...

[05:14] <masak> anyway,

[05:14] * masak files

[05:14] <szabgab> in any case the hyper should work

[05:14] <masak> aye.

[05:15] <eternaleye> s1n: Also, when you did run("env PATH=\$PATH:junktest echo \$PATH"), it didn't do what you intended: the shell interpreted the second $PATH, not echo - thus, what the shell ran was 'env PATH=whatever:path:was:junktest echo whatever:path:was'.

[05:16] <eternaleye> What you want is more like run("env PATH=\$PATH:junktest sh -c 'echo \$PATH'")

[05:16] <eternaleye> rakudo: run("env PATH=\$PATH:junktest sh -c 'echo \$PATH'")

[05:16] <p6eval> rakudo c4f676: OUTPUT«/usr/local/bin:/usr/bin:/bin:/usr/games:junktest␤»

[05:19] <eternaleye> masak: +^ is integer xor, ~^ will be Buf xor

[05:19] <masak> eternaleye: right.

[05:30] *** sri_kraih joined
[05:45] *** meppl joined
[05:46] *** ejs joined
[05:46] *** DemoFreak joined
[05:51] <pugs_svn> r26475 | szabgab++ | fix internal link

[06:01] *** orafu left
[06:01] *** orafu joined
[06:04] *** justatheory left
[06:10] <pugs_svn> r26476 | szabgab++ | fix some smartlinks

[06:20] *** ejs left
[06:27] *** tarbo2 left
[06:30] *** tarbo2 joined
[06:31] <pugs_svn> r26477 | moritz++ | [t/spec] a few more smartlink fixes

[06:38] *** iblechbot joined
[06:40] *** payload joined
[06:46] *** ejs joined
[06:51] *** mistermoo joined
[06:51] *** orafu left
[06:51] *** orafu joined
[06:52] *** nihiliad left
[06:55] *** mistermoo left
[06:56] <pugs_svn> r26478 | szabgab++ | fix some more smartlinks

[06:58] *** ejs left
[07:03] *** alester_ left
[07:03] * masak takes a stroll through the RT tickets

[07:05] *** ejs joined
[07:05] <szabgab> docs/Perl6/Spec/S14-roles-and-parametric-types.pod has mixed newlines

[07:05] <szabgab> shall I dos2unix it ?

[07:05] <masak> feel free.

[07:07] <pugs_svn> r26479 | szabgab++ | dos2unix

[07:07] <szabgab> any idea where did the 'Filehandles, files, and directories' section moved from S16 ?

[07:08] <masak> buubot: spack Filehandles

[07:08] <buubot> masak: S16-io.pod:1

[07:08] <masak> hm.

[07:14] <pugs_svn> r26480 | szabgab++ | t/spec fix more smartlinks

[07:14] *** ejs left
[07:24] <masak> rakudo: enum Weekday<Monday Tuesday>; say Tuesday.WHAT

[07:24] <p6eval> rakudo c4f676: OUTPUT«␤»

[07:24] <moritz_> rakudo: enum Weekday<Monday Tuesday>; say Tuesday.perl

[07:24] <p6eval> rakudo c4f676: OUTPUT«.new()␤»

[07:24] <moritz_> ouch.

[07:24] <moritz_> but I think we have a ticket for that one

[07:25] <masak> aye.

[07:25] <moritz_> rakudo: enum Weekday<Monday Tuesday>; say Weekday::Tuesday.perl

[07:25] <p6eval> rakudo c4f676: OUTPUT«.new()␤»

[07:25] <masak> rakudo: enum Weekday<Monday Tuesday>; say Weekday.WHAT

[07:25] <p6eval> rakudo c4f676: OUTPUT«␤»

[07:38] *** payload left
[07:39] <masak> std: sub foo($.bar) { ... }

[07:39] <p6eval> std 26480: OUTPUT«ok 00:02 36m␤»

[07:39] * masak gasps

[07:40] <masak> hm. maybe it's that "STD only knows how to parse, not how to interpret" detail playing out again.

[07:40] <moritz_> that's a bit useless.

[07:41] <moritz_> $.bar is $(self.bar)

[07:41] <moritz_> so having a method call as a parameter is brain dead

[07:42] <masak> moritz_: I beg to differ.

[07:42] <masak> ISTR S12 special-cases this as parameters binding to automatic attribute assignments.

[07:42] * masak looks

[07:44] <masak> hm, no, I'm wrong here. it's $!foo that does that.

[07:44] *** goksie joined
[07:45] *** ejs joined
[07:45] <masak> TimToady: is the $!foo sugar specific to BUILD submethods?

[07:49] <Tene> http://pleasedieinafire.net:2080/357964

[07:50] <Tene> Playing with a POE clone... just got that running.

[07:50] <moritz_> are custom traits implemented in Rakudo?

[07:50] <Tene> moritz_: not officially, afaik

[07:51] <moritz_> Tene: but they work, kind of?

[07:51] <Tene> moritz_: yes

[07:51] <moritz_> cool

[07:51] <Tene> moritz_: rakudo calls '!trait_handler_foo' when it encounters 'sub ... is foo'

[07:51] <pugs_svn> r26481 | wollmers++ | typo

[07:52] <moritz_> Tene: ah, that's not the specced way

[07:52] <Tene> right.

[07:52] <Tene> Is there a specced way?

[07:52] <masak> moritz_: Tene  is doing cool/scary things in the shadowland between Rakudo and Parrot. :)

[07:53] <masak> Tene++

[07:53] <Tene> moritz_: if there's a specced way, I'd be interested in implementing it.

[07:54] * moritz_ looks

[07:54] <Tene> moritz_: this is the implementation: http://pleasedieinafire.net:2080/769460

[07:55] <moritz_> Tene: see S14/Traits/

[07:56] <Tene> ah

[07:56] *** ejs1 joined
[07:57] *** goksie left
[07:57] <Tene> std: sub foo:bar { ... }

[07:57] <p6eval> std 26481: OUTPUT«ok 00:02 35m␤»

[07:57] <Tene> so rakudo needs to allow ':' in sub names...

[07:59] <Tene> unless the :xxx is special syntax?

[08:01] <Tene> do we have tests for this?

[08:01] <moritz_> Tene: it's also needed for parsing of proto regexes

[08:01] <Tene> ah, right.

[08:01] <masak> conclusion from my RT tests excursion: out of the 14 or so tests that I reviewed as candidates for closing, 1 could be closed. I'm re-evaluating my previous claim that there are a host of unclosed rakudobug tickets in RT.

[08:02] <moritz_> Tene: which are of the form token statement_modifier:sym<while>

[08:03] <moritz_> masak: I skimmed over the first 70 or so tickets in RT last week, so in that part of RT I don't expect a host of unclosed-but-now-working tickets

[08:03] <moritz_> masak: who claimed that?

[08:03] *** ejs left
[08:03] <masak> I've been known to claim that.

[08:03] <moritz_> Tene: t/spec/S12-traits/*

[08:04] <Tene> ah

[08:05] <moritz_> I'll move that to S14-traits/

[08:06] <moritz_> gna

[08:15] *** ejs2 joined
[08:19] *** payload joined
[08:22] *** orafu left
[08:22] *** orafu joined
[08:24] <pugs_svn> r26482 | szabgab++ | t/spec more smartlink fixes

[08:25] *** ejs2 left
[08:25] *** ejs1 left
[08:28] *** ejs joined
[08:30] *** azawawi joined
[08:30] <azawawi> hi

[08:31] <masak> azawawi: o/

[08:31] *** cognominal left
[08:36] <szabgab> I was about to upload Smart::Links to CPAN but I have second thougths about its name

[08:36] <szabgab> maybe it should be called Pod::SmartLinks ?

[08:36] <masak> preferably, yes.

[08:36] *** orafu left
[08:36] *** orafu joined
[08:36] <moritz_> that depends on your future plans

[08:36] <szabgab> other names?

[08:37] <moritz_> if you plan to port it to other file formats, having Pod:: in the name would be bad

[08:37] <masak> Pod::Links::Smart :)

[08:37] <moritz_> Doc::SmartLinks

[08:37] <masak> Text::SmartLinks

[08:37] <moritz_> masak: I also thought about that

[08:40] *** kimtaro joined
[08:40] <szabgab> there is a Text::Smart module

[08:41] <szabgab> I have no idea how other formats could be supported but I guess I'll go with Text::Smartlinks

[08:42] <szabgab> now if I knew how to rename it in one svn commit command that would be nice

[08:43] * masak doesn't think that's possible

[08:43] <masak> not if you want to use 'svn mv', that is.

[08:45] <pugs_svn> r26483 | szabgab++ | Smart::Links add README and Changes files

[08:45] <szabgab> I have 15 minutes till the next wave of cronjobs

[08:47] <moritz_> don't worry - when you're done I can start the update manually

[08:59] *** goksie joined
[08:59] <jnthn> oh morning

[08:59] <masak> jnthn: o/

[09:00] <pugs_svn> r26484 | szabgab++ | rename Smart::Links to Text::SmartLinks

[09:01] *** payload left
[09:07] *** kidd_` joined
[09:10] *** hanekomu left
[09:14] *** cognominal joined
[09:21] *** eternaleye left
[09:21] *** m-i-l-a-n joined
[09:22] *** eternaleye joined
[09:26] *** payload joined
[09:27] *** eternaleye left
[09:28] *** eternaleye joined
[09:35] <frettled> yay?

[09:36] *** bacek left
[09:39] <masak> frettled: I'm getting increasingly interested in your using-an-existing-packaging-system idea.

[09:43] * masak researches apt a bit

[09:45] *** goksie left
[09:45] <pugs_svn> r26485 | szabgab++ | remove empty directory

[09:47] *** orafu left
[09:48] *** orafu joined
[09:48] <pugs_svn> r26486 | szabgab++ | still renaming Smart::Links ...

[09:52] <pugs_svn> r26487 | szabgab++ | hopefully finished renaming Smart::Links to Text::SmartLinks

[10:00] <frettled> masak: I truly hope it's feasible.

[10:00] <masak> wow, now I'm totally sold on APT.

[10:01] <frettled> :)

[10:01] <jeremiah_> APT rocks.

[10:01] <masak> frettled: I think we should ask ourselves: what is the simplest way to get a working prototype of this?

[10:01] <pugs_svn> r26488 | szabgab++ | Text::SmartLinks some Makefile.PL improvements and some default error checking

[10:01] <masak> frettled: do you know if there's a .deb-packaged Rakudo release?

[10:02] <jeremiah_> masak: I have thought about doing one, but there is not one  yet.

[10:02] <jeremiah_> masak: Do you think that would be useful?

[10:02] <jeremiah_> Or are the sources still in a state of flux?

[10:03] <masak> jeremiah_: the latter, very much.

[10:03] <masak> jeremiah_: but I don't mean an official Debian package.

[10:03] <jeremiah_> You just mean packaged at all?

[10:03] <masak> it'd be nice to have a repository somewhere with Parrot, Rakudo (latest releases), and all the Perl 6 projects.

[10:03] <masak> jeremiah_: aye.

[10:03] <masak> how do I go about making one?

[10:03] <jeremiah_> masak: my talk in Oslo ;)

[10:04] <jeremiah_> Its not hard.

[10:04] <masak> URL?

[10:04] <jeremiah_> Use dh-make-perl to download the sources, then use dpkg-buildpackage to create a deb

[10:04] <masak> \o/

[10:04] <jeremiah_> You may have to install devscripts on your debian machine

[10:04] <jeremiah_> That has some useful goodies too.

[10:05] <masak> hold on a minute... :)

[10:05] <masak> I'm on Darwin here. no Debian.

[10:05] <jeremiah_> uh oh.

[10:05] <masak> I do have MacPorts, if that helps.

[10:05] <jeremiah_> Virtualbox, install debian

[10:05] <masak> about time anyway, I guess.

[10:05] <jeremiah_> No, that won't help.

[10:06] * masak goes hunting for Virtualbox

[10:06] <jeremiah_> Virtualbox works on well on Darwin.

[10:07] <masak> oh, and I have Parallels on here too. would that be a better solution?

[10:07] <jeremiah_> Dunno - I have never used parallels.

[10:07] *** zostay joined
[10:07] <jeremiah_> But I know VB works like a charm and is really easy.

[10:08] <jeremiah_> And is free

[10:08] <masak> http://freeversing.com/?p=36 seems to indicate Parallels is a good choice...

[10:09] <jeremiah_> I would use debian 5.0 though.

[10:10] <pugs_svn> r26489 | szabgab++ | SmartLinks dist_dir needs package name

[10:11] <masak> jeremiah_: aye.

[10:11] <jeremiah_> w00t

[10:12] <masak> hm, an "Intel 2 Core Duo" is of which architecture? i386?

[10:13] <pugs_svn> r26490 | szabgab++ | SmartLinks add MANIFEST.SKIP

[10:13] <jeremiah_> masak: Actually, I thinkit is i686

[10:13] <jeremiah_> I have one too. :)

[10:14] <jeremiah_> And I installed debian on it.

[10:14] <masak> jeremiah_: here are the options: http://www.debian.org/CD/netinst/

[10:14] <masak> no i686 there, only i386 and ia64.

[10:14] <jeremiah_> masak: use i386 network install

[10:14] <masak> hokay.

[10:14] <jeremiah_> that is the fastest

[10:14] <szabgab> masak, he tried to pull that trick on me too but we could not install on a VirtualBox

[10:14] <jeremiah_> szabgab: well you couldn't :P

[10:15] <masak> szabgab: :)

[10:15] <jeremiah_> :)

[10:15] <szabgab> you were sitting next to me :-)

[10:15] <masak> szabgab: I'll be trying Parallels first.

[10:15] <szabgab> Text::SmartLinks was uploaded to CPAN

[10:16] <szabgab> it will still need a lot of work to remove all the synopsis, Pugs and Perl 6 references from the output html but it can already be used

[10:16] <jeremiah_> masak: Just for your info, there is a move afoot to create a cross-distro packaging system. i.e. a package that would install on rpm systems and .deb systems

[10:17] <masak> jeremiah_: nice.

[10:17] <masak> lunch &

[10:17] <jeremiah_> But it has not come very far, still it might be nice for proto

[10:17] <masak> forget proto :) what we need is a real packaging system.

[10:18] <masak> & # really

[10:18] <pugs_svn> r26491 | szabgab++ | svn:ignore

[10:19] *** mberends joined
[10:19] <jnthn> ...but...but...proto preventend the Austrian uprising!

[10:20] <mberends> good $UTC-morning, #perl6

[10:21] <mberends> I want to register my interest in developing an apt clone to run outside of debian.

[10:26] <mberends> masak: give that Debian 5.0 MicroSD a try, it just needs an x86 PC.

[10:26] *** orafu left
[10:26] *** orafu joined
[10:27] *** hcchien_ is now known as hcchien

[10:29] <jeremiah_> mberends: I think you'll face a certain amount of skepticism re-creating APT. Why not just port it?

[10:32] *** icwiener joined
[10:32] *** SamB joined
[10:32] <mberends> jeremiah_: sure, whatever works best. I just like the yak shaving that comes from trying to implement existing tools on Rakudo. Also, there may some overkill that can be omitted, for example ipkg is a lightweight dpkg clone in my Freecom NAS boxes.

[10:38] <jeremiah_> ah, okay. :)

[10:43] *** payload left
[10:47] *** broquaint left
[10:50] *** icwiener left
[10:50] *** pmurias joined
[10:57] *** pmurias left
[10:59] *** azawawi left
[11:02] *** kimtaro_ joined
[11:03] *** kimtaro_ left
[11:04] *** kimtaro left
[11:10] *** payload joined
[11:21] <masak> mberends: call it a clone or a port, I agree it'd be nice.

[11:22] <masak> lately I've started to like the best form of flattery as a way to develop "new" Perl 6 applications.

[11:22] <frettled> masak: sorry, was afk there for a bit.  Using Parallels should work nicely with almost any Linux.

[11:22] <masak> seems to work fine so far.

[11:22] <frettled> \o/

[11:23] <masak> I'm 15% through the installation.

[11:25] *** kane_ left
[11:25] *** kane_ joined
[11:26] *** eternaleye left
[11:26] <masak> jnthn: actually, it turns out it was the last line of the bridge in the Beatles song "She loves you" that prevented the Austrian uprising. :)

[11:27] *** eternaleye joined
[11:27] <frettled> so it wasn't ABBA?

[11:28] <masak> frettled: well, ABBA has done a lot of other good things. but not Austria, no.

[11:35] <pugs_svn> r26492 | wollmers++ | length is not language dependent

[11:37] <mberends> masak: I'm just working up to my first blog, and flattery is part of it :)

[11:37] <frettled> Regarding a port/fork of dpkg (and possibly apt) to something non-Debian-specific, I'd first check to see if someone else did it (well) before.

[11:38] <mberends> good point, yes, the ipkg in optware is a functional subset.

[11:38] <frettled> (deb file format also, I guess)

[11:38] <masak> mberends: re flattery: is that a threat or a promise? :)

[11:38] *** kimtaro joined
[11:39] <frettled> mberends: ipkg could be that example, yes, but I don't know anything about it.  :)

[11:39] <mberends> Sun got Ian Murdoch to do it again in OpenSolaris

[11:39] <masak> frettled, mberends: I think a first working prototype might simply piggyback on the existing apt framework.

[11:39] <frettled> masak: I may already have been flattering in my blog.

[11:39] <frettled> masak: sensible

[11:39] <masak> frettled: URL?

[11:40] <mberends> yes, borrowing existing apt toolchain for a bootstrap effort (like Perl 6)

[11:40] <frettled> masak: http://howcaniexplainthis.blogspot.com/

[11:41] <masak> oh, right.

[11:41] * mberends would love to keep chatting, but has a ferry to England to catch.

[11:41] <frettled> mberends: have a nice trip

[11:41] * mberends will resume tomorrow. thanks. o/

[11:42] *** broquaint joined
[11:42] *** mberends left
[11:42] <masak> mberends: \o

[11:44] *** amoc left
[11:48] <masak> frettled: nice. :)

[11:48] <masak> frettled: slight correction though: proto is a Perl 6 project installer, not (primarily) an autoinstaller script for parrot and rakudo.

[11:49] *** payload left
[11:49] *** chid joined
[11:49] <frettled> masak: ok, thx

[11:51] <frettled> masak: better now?

[11:52] <masak> frettled: perfect.

[11:53] * masak should fix those nice progress dots some day...

[11:53] <masak> I've been talking about them for a month now.

[11:53] *** kidd_` left
[11:57] <frettled> )

[11:57] <frettled> :)

[11:58] <moritz_> -:)

[11:59] <sjn> frettled: s/you don't need 5.10.0/5.10.0 even better/

[11:59] <sjn> (let's get people to upgrade to 5.10, mkay?)

[11:59] <masak> I was of half a mind to mention that one, too. :)

[12:00] <masak> everybody needs 5.10.0 in some sense.

[12:00] <moritz_> I'm sure my mother can live without out :-)

[12:00] <sjn> yes, 5.10.0 is the new 5.8.*

[12:01] <sjn> moritz_: I'm sure your mom would be EXTATIC to use 5.10.0 :)

[12:01] <masak> moritz_: are you actually trying to create a "your mom" situation here? :P

[12:02] <sjn> just say "it's like a new 1600 RPM tumbler"

[12:02] <masak> well, it is.

[12:02] <frettled> sjn: 5.10.0 isn't stable enough that I'm willing to recommend it.

[12:02] *** iblechbot left
[12:02] <masak> Perl 5.10.0 is like a new 1600 RPM tumbler.

[12:02] <frettled> I'll post something about it when 5.10.1 is available.  :)

[12:03] <sjn> frettled: 5.10.0 is stable enough :-P

[12:03] <sjn> (seriously, any more stable, and it should be considered dead...)

[12:03] <frettled> I'll change it to "5.8.8 or 5.10.0", then.  No loaded words.

[12:03] <moritz_> speaking of which, anybody know if davem is making some progress towards the 5.10.1 release?

[12:04] <sjn> seen davem

[12:04] <frettled> Considering this amount of feedback, I now of course expect front page coverage in major newspapers.

[12:04] <sjn> bah, ENOUSEFULBOTS

[12:04] <frettled> @seen davem

[12:04] <lambdabot> I haven't seen davem.

[12:04] <frettled> Idle for 13:30.08, though

[12:05] <sjn> bah, EUSEFULBOTSUSECRYPTICACCESSCODESINFRONTOFKEYWORDS

[12:05] *** broquaint left
[12:05] <frettled> ENOPERCEPTION

[12:07] <masak> lambdabot: don't mind them. you're great.

[12:08] <moritz_> I just peeked into the maint-5.10 branch - lots of activity there

[12:09] *** chid left
[12:09] <frettled> jeez, think if all that energy could be channeled into parrot and rakudo!

[12:09] * masak CAN HAZ DEBIAN

[12:10] <moritz_> frettled: then... what? Perl 5 would die, just as the critics say it would

[12:11] <frettled> moritz_: and we'd still have no Perl 6?  ;)

[12:12] <moritz_> frettled: exactly.

[12:12] <moritz_> though we'd have a bit more Perl 6, which I for one would welcome

[12:13] <frettled> :)

[12:13] *** masak left
[12:14] <frettled> in other words, Perl 5 hackers aren't what we need for Perl 6! \o/

[12:14] <moritz_> well, not primarily

[12:14] *** masak joined
[12:15] <masak> lesson learned: if I try to change the screen resolution in Debian in Parallels, the whole computer goes down.

[12:15] <masak> otherwise, I like it.

[12:15] <frettled> yow

[12:20] <szabgab> masak, what is Parallels ?

[12:20] <moritz_> sounds like virtualization to me

[12:20] <szabgab> ah, found it

[12:21] <masak> szabgab: aye, what moritz_ said.

[12:22] <pugs_svn> r26493 | wollmers++ | avoid editor problems with characters > 0xFFFF; grapheme tests added

[12:25] * jnthn raises his eyebrows at the ^^ ticket

[12:25] <jnthn> ...what operator is that?

[12:27] <masak> jnthn: xor?

[12:28] <masak> analogous to && and ||.

[12:28] <jnthn> ah

[12:28] <masak> and the one() analogue to all() and any().

[12:28] *** orafu left
[12:28] <masak> uh, when written as '^', that is.

[12:29] *** orafu joined
[12:32] *** wayland76 joined
[12:33] <wayland76> moritz_++ # Blog summaries :)

[12:33] *** abra joined
[12:34] <wayland76> moritz_: Do you want to know the typos and mistakes?

[12:34] <moritz_> wayland76: yes

[12:38] *** wayland_ joined
[12:38] *** msmatsko left
[12:39] <wayland_> "Having only two ways to do the same things is still now violation of the timtowtdi principle"

[12:39] <wayland_> s/now/no/

[12:39] <wayland_> "As each month Rakudo had another release in April, featuring..."

[12:39] <wayland_> This is difficult to parse for me (and probably other English monolinguals)

[12:39] <wayland_> I'd recommend instead "As happens each month, Rakudo had another release in April, featuring..."

[12:39] <pugs_svn> r26494 | ron++ | add test for accessing match keys through scalary copy RT 62530

[12:39] <wayland_> (added the word "happens", and a comma after "month")

[12:40] <wayland_> hth

[12:40] *** eric256 joined
[12:40] *** wayland76 left
[12:40] *** wayland_ is now known as wayland76

[12:40] <drbean_>  Yeh, it sounds like it is released in April each month.

[12:41] <moritz_> fixing now, thanks

[12:41] <eric256> hey, i have a ton of pull requests on perl6-examples (i'm a bad person) and all 50 failed to commit

[12:41] <wayland76> drbean_: Yes, I think that's what was confusing me

[12:41] <wayland76> Well, that's not very committed of you :)

[12:41] <eric256> how can i go about fixing this?

[12:41] <eric256> wayland76: lol yea

[12:42] <moritz_> lol

[12:42] <moritz_> eric256: I'd do that on the command line... add the remotes, pull the, cherry-pick, resolve conflicts if necessary

[12:43] *** pmurias joined
[12:43] <wayland76> Btw, that Unicode stuff isn't very scary.  While I wouldn't say I have a comprehensive grip on it, I have a basic grip

[12:44] <masak> wayland76: understood.

[12:44] <moritz_> yes, me too - but I didn't undertand that particular part, due to lack of effort

[12:45] <wayland76> To get a basic group, go to http://www.fileformat.info/info/unicode/category/index.htm and scroll down 'til you find the items that begin with the word "Punctuation".  Then read the bullet points associated with Ps, Pe, Pi, and Pf.  

[12:45] <wayland76> s/group/grip/

[12:45] <eric256> is there some document that might walk me through this? i have a local copy that i did a git pull on and its up to date

[12:46] <wayland76> (Or maybe table entries instead of bullet points.  Whatever you call them...)

[12:46] <wayland76> Anyway, I'll stop now, so that people can answer eric256's question :)

[12:48] <masak> eric256: you mean actual pull requests, not patch RT tickets?

[12:48] <eric256> i mean the fork que on github... mistyped before

[12:48] <eric256> not RT patches

[12:48] <masak> I think someone said once that no-one actually takes care of github pull requests to rakudo.

[12:49] <masak> surely that can't be right, but that's how I remember it.

[12:49] <moritz_> masak: perl6-examples, not rakudo

[12:49] <eric256> i'm talking bout perl6-examples though... and yea i hope thats not right. 

[12:49] <masak> moritz_: oh.

[12:49] <eric256> which i run poorly and you both have stuff in the fork que

[12:49] <eric256> lol

[12:50] <moritz_> and actually eric256++ (is that eric257? :/) incorporated my patches already which I submitted by pull requests

[12:50] <masak> eric256: in that case, it can be argued that it's the task of the requestors to update their patches.

[12:50] <literal> just give them commit bits and let them sort it out themselves :)

[12:50] <eric256> i think you all have commit bits, so now i'm realy confused

[12:50] <eric256> lol

[12:50] <wayland76> @karma eric256

[12:50] <lambdabot> eric256 has a karma of 5

[12:51] *** orafu left
[12:51] <masak> eric256++ # nice guy

[12:51] *** orafu joined
[12:51] <eric256> should i just ignore everything in the fork queue then? that doesn't seem neighborly

[12:51] <wayland76> @karma eric256

[12:51] <lambdabot> eric256 has a karma of 6

[12:52] <moritz_> eric256: I don't have commit access

[12:52] <masak> eric256: you are basically free (from a social standpoint) to take whatever action on things in your fork queue.

[12:52] <wayland76> Anyway, gotta go o/

[12:52] *** ejs left
[12:52] *** wayland76 left
[12:52] *** aindilis left
[12:53] *** aindilis joined
[12:53] <eric256> masak: is on there already and i'm trying to add you now as well

[12:53] *** eternaleye left
[12:54] <eric256> hmmm it just does its little swirly cirlcle constantly

[12:54] *** eternaleye joined
[12:58] * eric256 notices that his facebook was updated around the same time as his last commit, last month flew by

[12:59] *** PhatEddy joined
[13:00] <PhatEddy> rakudo: class Match is also { method keys () {return %(self).keys }; };rule a {H}; "Hello" ~~ /<a>/; my $x = $/; say $x.keys.perl

[13:01] <p6eval> rakudo c4f676: OUTPUT«["a"]␤»

[13:02] <PhatEddy> eric256: that example is your Rt 62530

[13:03] *** jhorwitz joined
[13:04] <moritz_> PhatEddy: if you write that RT #62530 the IRC logs automatically turn it into a link to RT :-)

[13:05] <eric256> the new rakudo.org++ very nice looking

[13:07] <eric256> PhatEddy++ cool,  now i have to figure out how to catch up, last time i was here rakudo wasn't on git yet, or it had just gotten on it...not sure.

[13:08] *** maja joined
[13:08] <eric256> i think i have like 5 versions of rakudo and parrot on this pc...time to clean up

[13:08] <pugs_svn> r26495 | pmurias++ | [re-smop] the capture.MESSAGE is defined in the RI DSL

[13:08] *** skids_ joined
[13:09] *** eternaleye left
[13:10] *** eternaleye joined
[13:10] *** ispy_ joined
[13:11] * sjn is looking for blogposts from NPW and the hackathon

[13:11] <sjn> anyone have some links for me? :)

[13:13] * eric256 notices rakudo got socket support and gets very excited

[13:13] <masak> that reminds me... I should check why the socket support has stopped working in Rakudo...

[13:14] <moritz_> masak: ... and then immediately write a test

[13:14] <moritz_> masak: I wanted to write some tests, but I was too late

[13:14] <masak> moritz_: oh.

[13:14] <eric256> what? it worked, then it stopped, and i missed it ? lol

[13:14] <masak> moritz_: I might be able to do it with your guiding hand.

[13:15] <moritz_> masak: I'll do my very best

[13:16] <moritz_> I thought of something as simple as opening a server port on localhost, connecting to it from the same script, transfer a few bytes of data and compare them

[13:16] <masak> moritz_: problem is, as mberends++ pointed out, that recv is blocking.

[13:16] <masak> so you need two threads or equiv.

[13:17] <moritz_> dammit

[13:19] <eric256> can i go ahead and mark that ticket as resolved?

[13:20] <moritz_> if we have tests for that, yes

[13:20] *** maja_ left
[13:21] *** PacoLinux joined
[13:26] <literal> does rakudo not do signals yet?

[13:27] <moritz_> no

[13:27] <eric256> hmm all the commits in the fork que have j1n3l0  in the link....

[13:27] <pmichaud> std:  module Foo { sub _foo { say 'foo' } };  Foo::_foo();

[13:27] <lambdabot> pmichaud: You have 1 new message. '/msg lambdabot @messages' to read it.

[13:28] <p6eval> std 26495: OUTPUT«ok 00:02 35m␤»

[13:30] *** abra left
[13:31] *** abra joined
[13:32] <pmichaud> masak: I've started putting the tarballs on github.  I can put them on my personal site as well if we still need them.

[13:32] *** mib_g8edcm joined
[13:35] *** mib_g8edcm left
[13:38] *** zamolxes joined
[13:40] *** orafu left
[13:40] *** orafu joined
[13:40] <PhatEddy> I am looking at committing tests for five tickets in four test files.  Should I be doing four commits or one?

[13:40] *** iblechbot joined
[13:41] <moritz_> PhatEddy: whatever you prefer

[13:42] <eric256> still no line numbers on errors? i'm guessing that turned out more difficult that was originaly hoped?

[13:43] *** jhorwitz left
[13:43] <eric256> rakudo: <a b c d>[-1].say

[13:44] <p6eval> rakudo c4f676: OUTPUT«Use of uninitialized value␤␤»

[13:45] <eric256> rakudo: <a b c d>[*-1].say

[13:45] <p6eval> rakudo c4f676: OUTPUT«d␤»

[13:48] <pmichaud> eric256: the line numbers are embedded in the compiled code -- we're just looking for the right way to get them out to the programmer.

[13:49] <jnthn> I guess more specifically, it's blocking on the "it changes the Parrot error messages" issue...

[13:51] <pugs_svn> r26496 | ron++ | add tests for slice with two whatever stars RT #61844

[13:52] <pmichaud> well, we can always decide to put the error handling into pct or rakudo instead of / in addition to parrot.

[13:52] <pmichaud> Last time I looked into it, I couldn't introspect the annotations sufficiently to get it to work.  But Tene++ has made progress since then.

[13:53] <jnthn> pmichaud: Probably you missed .backtrace() on exception, which gets you an array of hashes of into including the annotations.

[13:53] <jnthn> *info

[13:53] <pmichaud> That's what I was using, but it wasn't giving me back the right results.

[13:53] <pmichaud> I kept getting segfaults, null PMCs, or other non-useful items.

[13:54] <jnthn> ...filed a Trac ticket?

[13:54] <pmichaud> no, I left it for Tene++ to work on :-)

[13:54] <pugs_svn> r26497 | ron++ | document existence of test for RT #61960

[13:54] <jnthn> Ah. :-)

[13:54] <jnthn> That works too. ;-)

[13:56] <baest> jnthn++ # for updating parrot version in rakudo

[13:59] <eric256> isn't there a flatten or splat operator?

[13:59] <pmichaud> depends on what you want to flatten or splat.  :-)

[13:59] <pmichaud> if you're wanting to flatten arguments in a call, it's   |@array

[13:59] <pmichaud> as in    foo(|@array)

[14:00] <baest> pmichaud: I have a question for you regarding /< funny stuff >/. I've the normal cases working, but in case of < ab >, I would create a literal node with 'ab', but that doesn't consume the whole pattern and fails badly

[14:00] <pmichaud> just make sure that it's 'to' attribute points to the end of the >

[14:00] <pmichaud> it's okay if the Literal node itself marks a different location

[14:01] <pmichaud> (be sure it's .ast value remains 'ab', though)

[14:01] *** zamolxes left
[14:01] <eric256> P7 from 99 problems: Flatten a nested list structure

[14:01] <pugs_svn> r26498 | ron++ | improve testing for mmd builtin override RT #58948

[14:02] <baest> pmichaud: ok, will check it out. Do you know if <  > (1 or 2 spaces) is legal and if what it means?

[14:02] <pmichaud> I don't know if it's legal.

[14:02] <pmichaud> std:   / <  > /

[14:02] <p6eval> std 26497: OUTPUT«ok 00:03 36m␤»

[14:02] <baest> it is :)

[14:02] <pmichaud> std seems to like it.

[14:02] <pmichaud> I would think that it ends up being a no-op of some sort.

[14:03] <pmichaud> in that sense, it probably shouldn't be legal :-)

[14:03] <eric256> rakudo: sub splat (|@a) { return @a }; splat( [1,2,3, [4,5]] ).perl.say;

[14:03] <moritz_> std: / <> /

[14:03] <baest> make sense

[14:03] <p6eval> rakudo c4f676: OUTPUT«Malformed routine definition at line 1, near "splat (|@a"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:85)␤»

[14:03] <p6eval> std 26497: OUTPUT«##### PARSE FAILED #####␤Unrecognized regex assertion at /tmp/iJjryIUuSt line 1:␤------> [32m/ <[31m> /[0m␤    expecting any of:␤ assertion␤        name␤FAILED 00:03 35m␤»

[14:03] <baest> I can just warn in that case

[14:03] <pmichaud> eric256: that's a different type of flattening

[14:03] <pmichaud> eric256: also, note that flattening lists != flattening arrays

[14:03] *** PerlPilot left
[14:03] <masak> pmichaud: re tarballs: no need. just wondering what's the official place.

[14:04] <baest> otherwise it could be pretty magical. Already <something> and < something> is very different

[14:04] <masak> pmichaud: I only noticed because proto used the old place.

[14:04] <pmichaud> masak: for the forseeable future, github will be the official place.

[14:04] <masak> goodenuf.

[14:04] <eric256> yea this lists arrays thing is going to bite me like 500 more times

[14:04] <eric256> lol

[14:04] <pmichaud> I would've have started it there in the first place if I had realized that it existed.  :-)

[14:04] <masak> :)

[14:05] <pmichaud> eric256: btw, I'm thinking of forking perl6-examples into the perl6 account on github -- would you have any objections/concerns with that?  (Yes, I'd give you whatever commit/admin privileges I can for it.)

[14:05] <pmichaud> if you'd prefer that we not do that, I won't.

[14:06] *** dukeleto|work left
[14:06] *** dukeleto|work joined
[14:08] <baest> pmichaud: doh, it work perfectly when I use to correctly. That has already bitten me a few times :) I will probably learn in the end

[14:09] <pugs_svn> r26499 | ron++ | add tests for isa override and method creation with eval RT #60946 and RT #61354

[14:09] <pmichaud> baest: It's bitten me a few times as well.

[14:10] <baest> :0

[14:10] *** dukeleto|work left
[14:11] <baest> std: /< ab     cd>/

[14:11] <p6eval> std 26499: OUTPUT«ok 00:02 35m␤»

[14:11] <baest> std: /<     ab     cd>/

[14:11] <p6eval> std 26499: OUTPUT«ok 00:02 35m␤»

[14:15] *** frew|work joined
[14:24] *** eternaleye left
[14:25] *** orafu left
[14:25] *** orafu joined
[14:25] *** eternaleye joined
[14:27] <masak> @tell mberends check out the new dotty progress bars when proto installs Rakudo :)

[14:27] <lambdabot> Consider it noted.

[14:28] <baest> world peace one dot at the time :)

[14:28] <moritz_> pmichaud: how much Perl 6 code do you actually write? (just idle interest... and no, NQP doesn't count :-)

[14:29] <masak> baest: a nice title for a blog post :)

[14:30] <baest> masak: quite inspired by your last one

[14:32] <masak> baest: nice to hear that.

[14:35] <eric256> pmichaud: no thats perfect

[14:36] <eric256> i'd actualy wanted that in the first place, but started it seperate to see if it would work ;) plus rakudo wasn't in git yet

[14:39] *** exodist joined
[14:40] *** payload joined
[14:41] <masak> hm, need to allow proto better granularity in perl6-examples... basically treating all the smaller projects as separate units...

[14:52] <pmichaud> moritz_: I haven't written a lot of Perl 6 code yet :-)

[14:52] <pmichaud> outside of the compiler and tools, that is :-)

[14:52] *** ispy_ left
[14:53] <arnsholt> In a way, writing the stuff that lets us write Perl 6 is actually more important than the Perl 6 code itself =)

[14:55] <jnthn> Both are important. :-)

[14:55] <jnthn> Happily, there are people doing both.

[14:59] * moritz_ tries

[15:02] *** M_o_C joined
[15:05] <PhatEddy> I haven't asked yet where my efforts on rakudo might be most useful and thought this might be a good time.

[15:05] <PhatEddy> I am currently keeping busy coming up with tests for active tickets ...

[15:06] *** Psyche^ joined
[15:07] <moritz_> that's a good use, IMHO

[15:07] *** nihiliad joined
[15:08] <masak> PhatEddy: sounds very good.

[15:08] <jnthn> I am always happy, when I come to fix an RT ticket and find it already is annotated with tests that I can unfudge after fixing it.

[15:10] *** Jedai left
[15:11] <pmichaud> (tests for active tickets)++

[15:11] <pmichaud> same here.

[15:12] *** broquaint joined
[15:12] <PhatEddy> So I'll keep going with that then :)

[15:13] <sjn> pmichaud: got your mail, we'll look into refunding your trip+hotel the next few days (need to get some funds out of PayPal too)

[15:13] <sjn> pmichaud: it should go pretty smoothly though

[15:14] <pmichaud> sjn: that's fine -- I just wanted to get it off of my "todo list"  :-)

[15:14] <sjn> :)

[15:15] <sjn> pmichaud: btw, could you update your info with your IBAN account number? (if you have one)

[15:15] *** Jedai joined
[15:15] <pmichaud> U.S. banks don't have IBAN

[15:15] <sjn> ah, ok

[15:15] <jnthn> I is International and... ;-)

[15:15] <pmichaud> that's why I gave the SWIFT code :-)

[15:15] <kane_> all your money are belong to sjn then

[15:15] <sjn> strange people, those USAnians...

[15:16] *** eternaleye left
[15:16] <pmichaud> I did once have a UBS account, though :-)

[15:16] <pmichaud> but alas, no longer.

[15:16] <frettled> It might be better if you created a paypal account.

[15:16] *** fridim_ joined
[15:16] <pmichaud> I have a paypal account... but there's a fee for transfers there :-|

[15:16] <sjn> mm

[15:16] <sjn> 4%

[15:16] <frettled> hmm

[15:16] <sjn> too much

[15:17] <frettled> more than for a SWIFT transfer?

[15:17] *** eternaleye joined
[15:17] <frettled> "SWIFT" is fairly ironic, though.

[15:17] <pmichaud> I don't know what the cost is on SWIFT at the sending end.  On the receiving end I don't have a fee, I don't think.  I'm sure it's less than 4%, though.

[15:17] <frettled> yup

[15:18] * sjn leaves for the NPW wrap-up meeting soon

[15:18] <sjn> frettled: feel free to come, if you want to give feedback :)

[15:18] <frettled> I know it isn't really my business, but my general thought was something along this line: if the fee for withdrawing from paypal is less than for a SWIFT transfer, then all NPW would have to do is to transfer the additional amount via paypal also.

[15:18] <frettled> sjn: where is that? :)

[15:19] <sjn> same as most oslo.pm meetings :)

[15:19] <[particle]> international wire transfers cost parrot foundation ~USD35

[15:20] <frettled> sjn: ... which is?  :D

[15:20] <frettled> [particle]: yep, they're leeches, that's for sure.

[15:20] <baest> international transfer is free in my bank as long as it is doing using the internet bank

[15:20] <sjn> frettled: http://oslo.pm.org/ :)

[15:21] <frettled> sjn: Marhaba Caf􏿽xE9?

[15:21] <sjn> jepp

[15:21] *** Patterner left
[15:21] *** Psyche^ is now known as Patterner

[15:22] <eric256> rakudo: my $x = [1,2,3, [4,5]]; for $x -> $t { $t.perl.say };

[15:22] <p6eval> rakudo 6f1649: OUTPUT«[1, 2, 3, [4, 5]]␤»

[15:22] <eric256> now i know i'm just being dumb, but how do i loop over an array ref? or better yet, how do i look up how to loop over an array ref?

[15:22] <masak> eric256: $x.list

[15:23] <frettled> sjn: so that would be at 18:00, then? Hmm. Well, it's within walking distance, I suppose.

[15:23] <masak> rakudo: my $x = [1,2,3, [4,5]]; for $x.list -> $t { $t.perl.say };

[15:23] <p6eval> rakudo 6f1649: OUTPUT«1␤2␤3␤[4, 5]␤»

[15:24] <sjn> frettled: 18:30

[15:24] <frettled> whoa, loooots of time.

[15:24] <masak> eric256: over time, I've found that terms like 'array ref' fade into the background for me when coding Perl 6. they're just not needed to explain the underlying model. 'array' covers it fine.

[15:24] * sjn toddles off to get some food first

[15:24] *** gottreu joined
[15:25] <masak> eric256: as for looking it up, I expect that u4x's section on for loops would eventually cover a thing such as this.

[15:25] <masak> that's one of the main differences between u4x and the spec.

[15:26] <frettled> sjn: that answered my next question :P

[15:26] <eric256> yea, thats a very different behaviour

[15:26] <pmichaud> I'm find with receiving the money via paypal as long as I don't take a big fee hit in the process :-)

[15:27] <pmichaud> *fine

[15:27] *** fridim_ left
[15:29] *** orafu left
[15:29] *** orafu joined
[15:30] <eric256> rakudo: sub test (@t) { say @t.perl }; test((1,2,3)); test([1,2,3]);

[15:30] <p6eval> rakudo 6f1649: OUTPUT«[1, 2, 3]␤[1, 2, 3]␤»

[15:30] <eric256> i fell like i'm relearning a foreign language....all the peices are there, i just can't seem to put them in the right order ;)

[15:30] <masak> eric256: first one is a list, the second one is an array.

[15:31] <eric256> i think i need to re-re-read the documentation

[15:31] <pmichaud> I suspect that .perl on lists will change soon.

[15:31] <masak> eric256: parentheses do grouping, so you're sending the 1,2,3 in the first call as a single argument.

[15:31] <masak> eric256: ...which is fine, since the sub accepts one parameter.

[15:31] *** cognominal left
[15:32] <arnsholt> Which synopsis defines the meta-object protocol?

[15:32] *** km2 joined
[15:32] <pmichaud> S12

[15:32] <pmichaud> some pieces aren't well-defined yet, though.

[15:32] <pmichaud> also look at the details from sm0p on the perl6 wiki (getting url)

[15:33] <pmichaud> http://www.perlfoundation.org/perl6/index.cgi?smop_oo_api

[15:33] <arnsholt> Thanks

[15:34] <pmurias> s/sm0p/smop

[15:34] *** cognominal joined
[15:36] *** abra left
[15:38] *** abra joined
[15:38] <arnsholt> Ah, dang. $/.perl doesn't work yet

[15:39] *** maja left
[15:39] <jnthn> arnsholt: The HOW API part of smop_oo_api or something very similar to it is likely to become spec.

[15:39] <pmichaud> pmurias++ # "smop" it is.

[15:41] <arnsholt> jnthn: Good to know. Thanks

[15:41] <pmichaud> afk, errands

[15:42] *** orafu left
[15:42] *** orafu joined
[15:43] *** descamps joined
[15:43] *** justatheory joined
[15:46] *** descamps left
[15:53] <TimToady> japhb: re constants, you can put "is export" on any declaration

[15:53] <lambdabot> TimToady: You have 1 new message. '/msg lambdabot @messages' to read it.

[15:53] <TimToady> @messages

[15:54] <lambdabot> perlmonkey said 1d 22h 36m 17s ago: got a chemistry question for you larry

[15:54] <TimToady> @clear

[15:54] <lambdabot> Messages cleared.

[15:54] <masak> perlmonkey seems to have since evaporated.

[15:55] <TimToady> well, asking to ask is a no-op in any case

[15:55] <TimToady> or telling to ask, in this case... :)

[15:56] <jnthn> "Can I ask you a question?" "Apparently, yes."

[15:56] <masak> TimToady: is the $!foo parameter sugar (for auto-assignment) specific to BUILD submethods?

[15:57] <TimToady> I can argue it both ways; as a designer, I'd like it to work anywhere, but as an implementor, I can see wanting to restrict the code mangling required

[15:58] <TimToady> since it implies adding code to the end of the function

[15:58] <TimToady> to do the unless-already-set semantics

[15:58] <TimToady> but if defined in terms of a wrapper, maybe it can generalize

[15:59] <TimToady> wrapping seems a bit heavy for that though

[15:59] <TimToady> building objects wants to be fastish

[15:59] <pugs_svn> r26500 | ron++ | my Num List sub should allow return of empty list RT #65128

[16:00] <masak> well, I have no opinion in the matter, I just noticed that the spec doesn't seem to say.

[16:00] <japhb> TimToady: (re: export any decl) Really?  That's great!

[16:00] <TimToady> so I'm okay with restricting it for 6.0, with the proviso that we might generalize it later

[16:00] <masak> TimToady: sounds good.

[16:00] <masak> and sane.

[16:00] <TimToady> japhb: except it occurs to me that enums don't have traits yet...

[16:00] <TimToady> so I need to glare at the grammar for some of the more esoteric declarators

[16:01] <japhb> heh

[16:01] <TimToady> std: enum Foo of Int is export <a b c>

[16:01] <[particle]> toke.std

[16:01] <p6eval> std 26499: OUTPUT«##### PARSE FAILED #####␤Syntax error (two terms in a row?) at /tmp/LKmzDN0H91 line 1:␤------> [32menum Foo of Int [31mis export <a b c>[0m␤    expecting any of:␤        infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤FAILED

[16:01] <p6eval> ..00:02 35m␤»

[16:02] <japhb> jnthn: you said that constant $foo = 'foo' works now ... does it work with 'is export' yet?  Or is that tbd?

[16:02] <TimToady> std: subset Foo of Int is export where {...}

[16:02] <p6eval> std 26499: OUTPUT«##### PARSE FAILED #####␤Syntax error (two terms in a row?) at /tmp/d4RWz3hMH9 line 1:␤------> [32msubset Foo of Int [31mis export where {...}[0m␤    expecting any of:␤  infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤FAILED

[16:02] <p6eval> ..00:02 35m␤»

[16:03] <jnthn> japhb: to be done

[16:06] <japhb> jnthn: OK, thanks.  Is that possible as part of the Tuesday work, or is it too much work?

[16:07] *** masak left
[16:07] <TimToady> hmm, bit of ambiguity in enum, since <trait> recognizes :export as equiv to "is export", but the enums arglist also allows pairs...

[16:08] <TimToady> *enum's

[16:09] <TimToady> maybe we should go back to requiring = before enum's arglist

[16:09] <TimToady> or at least allowing = there, for now

[16:11] <jnthn> japhb: Well, we're not doing lexical importing at the moment, so they'd go into the NS, and inlining would be trickier too...but maybe do-able.

[16:11] <pmichaud> TimToady: if you're looking for an easier problem to solve... I'm interested to know how/why STD parses   "Foo::_bar"  as a name, since it (apparently) only accepts <alpha> after the '::'

[16:12] <japhb> Apparently I'm on a "deceptively tricky" streak ....

[16:12] <japhb> jnthn: Thank you.

[16:12] * japhb anxiously awaits Wednesday.  :-)

[16:14] <TimToady> pmichaud: _ is considered an alpha

[16:14] *** jhorwitz joined
[16:15] <japhb> TimToady: What is the builtin for just alphabetics then?

[16:16] <pmichaud> TimToady: <alpha> matches _ in general, or just STD is doing it that way?

[16:18] <TimToady> perl has always considered _ to be alpha; _ gets into \w by virtue of being "alpha", not digit

[16:18] <TimToady> and $_ is considered an alphabetic var

[16:18] <pmichaud> hmm.  I always thought of \w as being alpha+digit+underscore

[16:18] <arnsholt> pmichaud: Is there a particular reason PGE seems to want closures to start with {{?

[16:18] <TimToady> std: class _foo_ {...}

[16:18] <[particle]> _ is definitely <alpha>

[16:18] <p6eval> std 26500: OUTPUT«ok 00:02 35m␤»

[16:18] <pmichaud> arnsholt: to emphasize the fact that we only do PIR closures.

[16:19] <pmichaud> when we do closures in Perl 6 or other languages, we'll accept { 

[16:19] <[particle]> and specify the lang how?

[16:19] *** payload left
[16:19] <pmichaud> :lang modifier

[16:19] <arnsholt> D'oh, I should've seen that.

[16:19] <[particle]> on the end?

[16:19] <pmichaud> in particular, PGE needs to be able to find the end of the closure block, so it has to search for "}}"

[16:19] <[particle]> { ... } :lang<lua>

[16:20] <[particle]> ^ end weight problem

[16:20] <pmichaud> particle:   / :lang('Perl 6') { ... } /    # I think -- see S05

[16:20] <TimToady> Perl 6 doesn't use PGE, in that sense, so the :lang is implicit :)

[16:20] <[particle]> ok, before works great.

[16:20] <TimToady> in Perl 6 the language of the closure is carried down from the outer context

[16:21] <pmichaud> yes, PGE will accept the language from the outer context as well, when it's implemented.

[16:21] <pmichaud> it involves getting PGE to be smart enough to call other parsers in the middle (and having all of those parsers honor a common API)

[16:22] <TimToady> since P6 considers all declarations as language mutating, that's how the closures see the the outer declarations

[16:23] <japhb> TimToady: So if _ is alpha, then what rule excludes it?  Is the expectation that we explicitly exclude when we want to e.g. parse English, or will there be a builtin for it?

[16:23] <TimToady> \pL to get the Unicode idea of it

[16:23] <japhb> (Because, of course, in Perl 6 parsing English should now be trivial ....)

[16:23] <pmichaud> I suppose one could do:   <+upper+lower>   or <isL>

[16:23] <TimToady> in P5

[16:23] <TimToady> so yes, <isL> or some such

[16:24] <TimToady> pmichaud: <+upper+lower> ignores +title

[16:25] <pmichaud> I haven't see a <title>

[16:25] <TimToady> japhb: of course ;) since English has only some 300 grammatical rules, and those are all perfectly well behaved...

[16:25] *** payload joined
[16:25] <pmichaud> *seen

[16:25] <TimToady> well, titlecase is outside upper/lower in any case (NPI)

[16:25] <pmichaud> right.

[16:25] <pmichaud> so <isL> to match all alphabetics.

[16:26] <pmichaud> <alpha>  matches alphabetics + underscore

[16:26] <pmichaud> (i.e., Perl 6's idea of "alpha")

[16:26] <[particle]> <alpha-->

[16:26] <[particle]> :)

[16:26] <[particle]> <alpha-'-'>

[16:26] <TimToady> seems like that will be least surprise for P5ers

[16:26] <[particle]> er, gah.

[16:26] <[particle]> <alpha-'_'>

[16:27] <TimToady> probably a syntax error

[16:27] <pmichaud> <+alpha-[\ ]>

[16:27] <pmichaud> arggh

[16:27] <[particle]> heh, glad it's not just me

[16:27] <pmichaud> <+alpha-[_]>  # there.

[16:27] <TimToady> std: /<+alpha-[_]>/

[16:28] <p6eval> std 26500: OUTPUT«ok 00:03 36m␤»

[16:28] * pmichaud decides to stick with <isL>

[16:28] <pmichaud> rakudo:  say ?('a' ~~ /<isLetter>/)

[16:28] <p6eval> rakudo 6f1649: OUTPUT«1␤»

[16:28] <pmichaud> rakudo:  say ?('_' ~~ /<isLetter>/)

[16:28] <[particle]> do we need icu for isL?

[16:28] <p6eval> rakudo 6f1649: OUTPUT«0␤»

[16:28] <pmichaud> [particle]1: currently, yes.

[16:29] <TimToady> [particle]: you could reimplement icu for us today...

[16:29] <pmichaud> afk again

[16:29] <[particle]> timtoady: i'll add it to my list.

[16:29] <TimToady> thanks! :)

[16:30] <TimToady> you could implement it in Perl 6

[16:30] <TimToady> I'll give you that much slack...

[16:31] <[particle]> maybe on my flights to/from palo alto on wednesday

[16:31] <[particle]> that's almost close enough to slap you :P

[16:35] <Tene> pmichaud: I have line number reporting working, yes.  I can add it wherever you say is appropriate.  Parrot, PCT, Rakudo, etc.

[16:35] <pmichaud> Tene:  PCT

[16:35] <pmichaud> or Parrot

[16:35] <Tene> OK, I'll do that today or tonight.

[16:36] *** azawawi joined
[16:36] <azawawi> hi

[16:37] <Tene> pmichaud: does http://perlcabal.org/syn/S14.html#Traits just involve allowing : in sub declarations, or does :xxx mean something special there, like in proto regexes?

[16:38] <pmichaud> it's slightly more than just allowing ':' in sub declarations.

[16:38] <pmichaud> because we also need to allow   infix:<+> and the like.

[16:39] <Tene> so it's : followed by text or a quote?

[16:39] <pmichaud> postcircumfix, I think.  See STD.pm .

[16:40] <TimToady> any identifier may be extended with any adverb

[16:40] <pmichaud> token deflongname, I think.

[16:40] <pmichaud> or even longname

[16:40] <TimToady> std: What::ever:foo<bar>

[16:40] <p6eval> std 26500: OUTPUT«Undeclared name:␤      What::ever:foo<bar> used at 1 ␤ok 00:02 35m␤»

[16:42] <TimToady> std: 1..$x:by(3) # but note this

[16:42] <p6eval> std 26500: OUTPUT«Potential difficulties:␤  Variable $x:by(3) is not predeclared at /tmp/J1wLRkHJgS line 1:␤------> [32m1..$x:by(3)[31m # but note this[0m␤ok 00:02 36m␤»

[16:45] <TimToady> std: $_-_-_-_-_-_ = 42

[16:45] <p6eval> std 26500: OUTPUT«Potential difficulties:␤  Variable $_-_-_-_-_-_ is not predeclared at /tmp/DbWIABYpUo line 1:␤------> [32m$_-_-_-_-_-_[31m = 42[0m␤ok 00:02 36m␤»

[16:45] <TimToady> std: my $_-_-_-_-_-_ = 42

[16:45] <p6eval> std 26500: OUTPUT«ok 00:02 36m␤»

[16:45] <TimToady> std: constant _-_-_-_-_-_ = 42

[16:45] <p6eval> std 26500: OUTPUT«ok 00:02 35m␤»

[16:51] <PhatEddy> std: class A { my $.b; method x { $.b = "b" } }; 

[16:51] <p6eval> std 26500: OUTPUT«ok 00:04 36m␤»

[16:51] <PhatEddy> What is the difference between my/our and has for declaring attributes?

[16:52] <PerlJam> my and our don't declare attributes of a class :)

[16:53] <PhatEddy> should a declaration like the one I just made be an error?

[16:55] <PerlJam> er, no.  (I misspoke, my and our declare class attributes rather than object attributes)

[16:56] *** azawawi left
[16:56] <PerlJam> so, all of your class A objects will have access to the $.b variable.

[16:57] *** azawawi joined
[16:57] <PerlJam> And it'll be the same $.b 

[16:57] <PhatEddy> thx

[16:57] <TimToady> in any case, std doesn't check semantics much

[16:58] <PerlJam> "much"?  what semantics does it check? 

[16:58] <azawawi> TimToady: speaking of attributes, http://feather.perl6.nl/~azawawi/Padre-Plugin-Perl6-with-attributes.png :)

[16:58] <TimToady> it has to know what has been declared as a type name

[16:59] <TimToady> or a parameterless value

[16:59] <PerlJam> ah.  

[17:01] *** ruoso joined
[17:04] <ruoso> Hello!

[17:09] *** barney joined
[17:09] *** pmurias_ joined
[17:11] *** M_o_C left
[17:12] <szabgab> can some explain to me how this test works: t/spec/S04-statements/lazy.t ?

[17:13] <szabgab> I don't see any rakudo skip in it but it does not run in rakudo as lazy is not implemented

[17:14] <PhatEddy> rakudo: class A { my $.bar is rw = 5 }; A.bar = 3; say A.bar

[17:14] <p6eval> rakudo 6f1649: OUTPUT«3␤»

[17:15] <PhatEddy> is the "my" there doing anything?

[17:15] <moritz_> szabgab: rakudo runs only those tests that are in t/spectest.data iin rakudo

[17:16] <szabgab> ah, I have forgotten about that 

[17:16] <szabgab> so then another question, where should "lazy" be in the spec?

[17:17] <moritz_> buubot: spack lazy

[17:17] <buubot> moritz_: S02-bits.pod:6 S03-operators.pod:14 S04-control.pod:2 S05-regex.pod:2 S06-routines.pod:7 S07-iterators.pod:16 S09-data.pod:7 S12-objects.pod:2 S16-io.pod:1 S29-functions.pod:7

[17:17] <PerlJam> PhatEddy: that looks like a bug.

[17:17] <szabgab> yes the word lazy appears in many places but none is the declaration of the lazy keyword used in that test file

[17:18] <PerlJam> PhatEddy: my  $.count;        # generates a public read-only .count accessor

[17:18] <PerlJam> PhatEddy: from the section that talks about using my/our for class attributes.

[17:19] *** FurnaceBoy joined
[17:19] <eric256> pushed a 99 problems directory to perl6-examples and i'm starting to populate it if anyone is interested ;)

[17:19] <skids_> There was talk of "adding" lazy as a word in addition to "eager" WRT S07's attempts to define laziness.

[17:20] <moritz_> eric256: we already have such a thing in the test suite

[17:20] <PhatEddy> PerlJam: ok thx - probable rakudobug if can't find a duplicate

[17:20] <skids_> There was also some discussion of laziness at Oslo, so maybe someone who was privvy to that could chime in.

[17:21] *** rindolf joined
[17:21] <eric256> oh shoot

[17:21] <eric256> well the test suite is a silly place for it ;)

[17:21] <moritz_> szabgab: STD.pm has the token statement_prefix:lazy

[17:21] <moritz_> eric256: why?

[17:21] <eric256> which S does that go under?

[17:21] <PhatEddy> rakudo: say $.a

[17:22] <p6eval> rakudo 6f1649: OUTPUT«Lexical 'self' not found␤current instr.: '_block14' pc 51 (EVAL_17:34)␤»

[17:22] <moritz_> eric256: it's in integration/

[17:22] <moritz_> eric256: we need some tests that actualy code works, not only contrived examples that usual tests are

[17:23] <PhatEddy> There's a ticket open for that last one (RT #57336) and I am wondering if current handling isn't good enough ...

[17:23] *** pmurias left
[17:23] <eric256> well you just blew my plans for the next week ;) lol, i was going to use those 99 to get me going, though i might still do it, i formatted ine differently

[17:23] <moritz_> eric256: sure, feel free

[17:23] <moritz_> eric256: also note that the ones in the test suite are fairly incomplete

[17:23] <eric256> :q

[17:24] <eric256> err. wrong window

[17:24] <eric256> oh? in what way?

[17:25] <eric256> tests are kinda a heard way for people to look and learn, so maybe having them in both spots with different solutions/formating is okay ;)

[17:25] *** ispy_1 joined
[17:25] <moritz_> not all of the 99 problems have a solution there

[17:26] <eric256> besides i was hoping to have an answer file and run all the solutions agianst those answers...could score solutions based on time to answer or something. ;)  same with some of the other folders that have multiple solutions

[17:26] <eric256> could probably then make a test file that tests all those different problems, euler, 99, wsg, etc

[17:26] <moritz_> some have non-trivial data structures as the answer

[17:30] <szabgab> it would be nice if the t/spec/integration/ directory would have lots of smartlinks

[17:31] <szabgab> to the appropriate pages in the synopsis

[17:33] * eric256 has done that duty some in the past ;) the syns can be a pretty fast moving target some days, maybe thats slowed down more recently

[17:35] <[particle]> eric256: some have slowed down quite a bit, while others are accelerating.

[17:36] <szabgab> you can look here to see what is broken/missing: http://perlcabal.org/syn/stats.html

[17:36] <szabgab> for example I think "uniq" is not speced anywhere

[17:37] <pugs_svn> r26501 | szabgab++ | some more smartlinks

[17:38] <[particle]> neither is .sign

[17:39] <[particle]> i need that to implement 'augment class Int { method perl {...} }'

[17:41] <ruoso> pmurias_, hi

[17:43] <jnthn> [particle]: Is that just not return ~self;

[17:44] *** Schnueff joined
[17:45] <pugs_svn> r26502 | azawawi++ | Removed useless assignment

[17:47] <[particle]> jnthn: i suppose it's actually self <=> 0;

[17:47] <PhatEddy> Sorry - looking at the '$.a' outside of a class - complaining there is no lexical self around looks to me like rakudo pretty much DTRT no?

[17:47] <[particle]> yep

[17:48] *** Schnueff_ joined
[17:49] *** japhb left
[17:55] <jnthn> [particle]: I meant for .perl, not for .sign

[17:56] <[particle]> um, i'm writing .perl in perl 6.

[17:56] <jnthn> aye

[17:56] <jnthn> .perl of an Int is just its stringification, no?

[17:56] <[particle]> i'm writing prefix:<~> in perl 6

[17:56] <[particle]> maybe that's a better way to put it

[17:57] <[particle]> the itoa equivalent

[17:57] <jnthn> prefix:<~> probably calls .Str, and .Str on an Int can probably be defined in terms of Parrot's get_string vtable, I think.

[17:58] <jnthn> Unless you're going for something non-Parrot-specific, but I'm not srue this is the place for it.

[17:58] <[particle]> yes, i'm not writing this specifically for parrot.  it's to have a fully-functional perl 6 in perl 6

[17:58] <jnthn> Ah, OK.

[17:58] <jnthn> But IMO the Parrot one should just call the vtable method.

[17:58] <[particle]> of course!

[17:58] <jnthn> OK, I understand what you're doing now. :-)

[17:59] * jnthn -> dinner, back later

[17:59] <Tene> So, when I define submethod BUILD in a class, and instantiate a subclass, BUILD is called twice

[17:59] <Tene> once for the parent class and once for the subclass

[17:59] <pmurias_> ruoso: hi

[17:59] *** pmurias_ is now known as pmurias

[17:59] <Tene> is there any way for me to define something in the parent class that will be called once on instantiation of any subclasses?

[18:01] <pmurias> ruoso: &return is the current thing &say is blocking on

[18:02] <pugs_svn> r26503 | pmurias++ | [re-smop] added FETCH,STORE to idconst and bool

[18:03] <pmurias> ruoso: do you think we could have ControlException in Perl 6?

[18:04] <Tene> pmurias: what do you want to know about exceptions in rakudo?

[18:04] <pugs_svn> r26504 | szabgab++ | some more smartlinks

[18:05] <Tene> pmurias: I did most of the existing exception-handling in rakudo.  I ended up blocked on feedback on how it should behave.

[18:06] *** Schnueff left
[18:07] <pmurias> Tene: you mean from the user viewpoint or internally on the vm

[18:08] <Tene> pmurias: I didn't have specs for what it should look like from the user viewpoint.

[18:10] *** PhatEddy left
[18:12] <pmurias> Tene: what are the things you didn't know?

[18:13] <Tene> pmurias: I got a basic implementation working and posted to the list with "Is this right?  How should this behave?  What else needs to be done?" and got no response.

[18:14] <Tene> I don't remember the details.

[18:14] <ruoso> pmurias, I think so, but I think having it in m0ld is not harmful

[18:17] <ruoso> Tene, I think we can sync some things up between rakudo and smop

[18:17] <ruoso> I'm not sure there is any difference...

[18:18] <pmurias> ruoso: what is the RI test in control exception used?

[18:18] <pmurias> * for

[18:19] <ruoso> pmurias, I'm not sure it is already used, but it should be used to check for native types in signatures...

[18:27] *** rblasch joined
[18:27] <pmurias> handle_return_mold  in ControlExceptionReturn use RI test

[18:30] <ruoso> pmurias, right... 

[18:30] <ruoso> pmurias, anyway... I think it's best if we keep the already implemented exceptions as they are now...

[18:30] <ruoso> so we can close this refactoring

[18:30] *** japhb joined
[18:31] <pmurias> what is handle_return used for?

[18:33] <ruoso> it is the actual traversal of the exception throwing

[18:33] <ruoso> oh... wait... that's throw

[18:33] <ruoso> ah

[18:34] <ruoso> pmurias, it implements the:

[18:34] <ruoso> if $e.routine === &?ROUTINE { handle... } else { rethrow... }

[18:36] *** jbt joined
[18:41] *** rindolf left
[18:44] *** jrockway left
[18:44] <pugs_svn> r26505 | ruoso++ | [re-smop] idconst_message.ri implements Str returning self, as idconst supposedly does Str...

[18:45] <ruoso> rakudo: say ControlExceptionReturn.HOW;

[18:45] <p6eval> rakudo 6f1649: OUTPUT«Could not find non-existent sub ControlExceptionReturn␤current instr.: '_block14' pc 53 (EVAL_16:37)␤»

[18:45] <ruoso> Tene, you were talking about exceptions... this is an important mismatch... 

[18:46] *** eternaleye left
[18:46] <Tene> ruoso: Rakudo doesn't have any exception classes but Exception.

[18:46] <Tene> rakudo: say Exception.HOW

[18:46] <p6eval> rakudo 6f1649: OUTPUT«␤»

[18:46] <Tene> ruoso: I couldn't find any list of what exception classes Perl 6 should have.

[18:47] <ruoso> Tene, that isn't very clear yet... but Control exceptions have the name defined with the "ControlException" prefix

[18:47] <ruoso> and ControlExceptionReturn is one that should be there for sure

[18:48] <ruoso> so as ControlExceptionWarn

[18:48] <ruoso> ControlExceptionNext

[18:48] <ruoso> ControlExceptionLast

[18:48] <ruoso> and so on

[18:48] <Tene> Huh, okay.

[18:48] <Tene> I'll look at it.

[18:50] *** jrockway joined
[18:50] <ruoso> pmurias, are you porting over ControlExceptionReturn?

[18:51] <jnthn> It'd probably be helpful if the exception hierarchy got filled out a little.

[18:51] <Tene> ruoso: are there any tests for these?

[18:52] <ruoso> hmm... you mean one using the actual name?

[18:52] <ruoso> I'm not sure there are...

[18:52] <pmichaud> even just seeing a real blessing of "ControlException" would be nice.

[18:53] <pmichaud> or I guess we can decide that it's correct by implementation consensus.

[18:53] <ruoso> pmichaud, there's something in the irc log some time ago...

[18:53] <pmichaud> there are lots of things in the irc log :-(

[18:53] <ruoso> TimToady had blessed it

[18:53] <pmichaud> looks like 08-12-24

[18:54] <ruoso> pmichaud, link?

[18:54] <jnthn> Somebody should probably JFHackItIntoTheSpec.

[18:54] <ruoso> (for the sake of documenting)

[18:54] <pmichaud> something to be said for ControlException in front instead

[18:54] <pmichaud>         

[18:54] <pmichaud> 19:44

[18:54] <pmichaud> 	

[18:54] <pmichaud> oops

[18:54] <pmichaud> http://irclog.perlgeek.de/perl6/2008-12-24#i_785232

[18:55] <pmichaud> Not exactly a blessing of "ControlException" into the spec, but a reasonable start.

[18:58] <ruoso> but basically... there is no function to generically raise control exceptions (as fail does with failures)

[18:58] <ruoso> all control exceptions need to be raised from its own object

[18:59] *** barney left
[18:59] <ruoso> and functions like "return", "goto", "next", "last" are the things that raise the specific control exceptions

[19:00] <pmichaud> I was referring only to the name.  The rest of it we pretty much have in Rakudo already.

[19:00] <ruoso> is the return already fixed?

[19:01] <pmichaud> if you mean that it returns from its lexical scope -- not yet.

[19:01] <pmichaud> but the basic control structures being functions that raise the appropriate exceptions -- aye, we have that.

[19:02] <pmichaud> we could probably get 'return' fixed now with the increased levels of introspection we have available.

[19:02] <Tene> what is the 'return' issue?

[19:02] <pmichaud> But I also want to get Parrot to handle .leave semantics more directly than we do now.

[19:02] <ruoso> Tene, return inside closure sent as argument to another routine

[19:03] * ruoso can't remember the ticket id

[19:03] <pmichaud> I'm getting the ticket #... just a sec

[19:03] <pmichaud> RT #61126

[19:04] <pmichaud> Ideally what I'd like return to do is to find its lexical outer Routine, and then invoke .leave on that.

[19:04] *** nihiliad left
[19:04] <ruoso> pmichaud, I'm not sure you can

[19:04] <pmichaud> alternatively it needs to throw a return exception that is tagged to its lexical outer

[19:05] <Tene> I could do that.

[19:05] <ruoso> because you could interfere that by providing a manual CONTROL block to the routine

[19:05] <Tene> I already have a sketch of it.

[19:05] <ruoso> sub bar($code) { $code(); CONTROL { say "hello" }};sub foo { bar { return 1 }; return 2; }; say foo

[19:06] <ruoso> it should say "hello" and return 1 

[19:06] <pmichaud> ruoso: I'm not sure that's what the spec indicates.

[19:06] <pmichaud> at least, that doesn't match my understanding of it.

[19:07] <ruoso> hmm... that's pretty much what I understand of it ;)

[19:07] *** orafu left
[19:07] *** orafu joined
[19:08] <ruoso> pmichaud, do you agree that return is implemented in terms of control exceptions?

[19:08] <pmichaud> sure.

[19:08] <pmichaud> and Rakudo currently implements it that way.

[19:08] *** [particle]2 joined
[19:08] <ruoso> do you agree CONTROL should be able to handle any control exception?

[19:09] <pmichaud> ruoso:  S04 says:   "If you pass a closure

[19:09] <pmichaud> object outside of its official "sub" scope, it is illegal to

[19:09] <pmichaud> return from it.  You may only leave the displaced closure block itself

[19:09] <pmichaud> by falling off the end of it or by explicitly calling C<leave>.

[19:09] *** nihiliad joined
[19:09] <ruoso> hmm....

[19:09] <ruoso> is that new?

[19:09] <pmichaud> I don't know how new that is.

[19:09] <pmichaud> I just know what the spec says.  :-)

[19:10] *** gottreu left
[19:10] <Tene> svn blame ftw

[19:11] <ruoso> pmichaud, that indeed enable some simplifications in return

[19:11] <pmichaud> even presuming that we can pass a closure containing 'return' to bar() above, I'm not sure that bar's CONTROL block is allowed to intercept the return exception.

[19:12] <ruoso> but it seems to be specific to return, not to CONTROL in general

[19:12] <ruoso> if return is a control exception it goes through the dynamic scope

[19:13] <ruoso> so bar can intercept it

[19:13] <pmichaud> that also doesn't match my understanding of the spec.

[19:13] *** nihiliad left
[19:14] <pmichaud> we only search the outer dynamic scopes if there's not a lexical scope matching the type of control exception being thrown.

[19:14] <ruoso> huh?

[19:14] <ruoso> that's for finding a symbol...

[19:14] <ruoso> you don't go running CONTROL and CATCH of outer scopes...

[19:14] <ruoso> but of caller scopes

[19:15] <pmichaud> S04 again:  "Much like

[19:15] <pmichaud> C<return> may only return from an "official" subroutine or method,

[19:15] <pmichaud> a loop exit like C<next> should be caught by the construct the user

[19:15] <pmichaud> expects it to be caught by.  In particular, if the user labels a loop

[19:15] <pmichaud> with a specific label, and calls a loop control from within the lexical

[19:15] <pmichaud> scope of that loop, and if that call mentions the outer loop's label,

[19:15] *** AzureStone_ joined
[19:15] <pmichaud> then that outer loop is the one that must be controlled."

[19:15] <ruoso> that only specifies the expected behavior of next....

[19:15] *** AzureStone left
[19:16] <ruoso> which means that the default CONTROL block of a loop should look for the label when handling the control exception

[19:16] <ruoso> but it is a plain control exceptions

[19:16] <ruoso> therefore subject to CONTROL blocks

[19:16] *** nihiliad joined
[19:16] <pmichaud> in the dynamic scope as well, assuming the lexical scope is available?

[19:17] <ruoso> the lexical scope is not queried at all

[19:17] <ruoso> it goes straight to the dynamic scope

[19:18] <pmichaud> S04 again:  "If there is no such lexically scoped outer loop in the current subroutine,

[19:18] <pmichaud> then a fallback search is made outward through the dynamic scopes in

[19:18] <pmichaud> the same way Perl 5 does."

[19:18] <pmichaud> Note the if clause.

[19:18] <pmichaud> although it is qualified by "in the current subroutine".

[19:18] <ruoso> that's specific to the implementation of the default CONTROL of the loop statements

[19:19] *** justatheory left
[19:19] <pmichaud> I have trouble seeing which control exceptions you're referring to then, if not return or next/last/redo.

[19:19] <ruoso> it is all of them

[19:19] <ruoso> in a more generic way

[19:19] <ruoso> CONTROL blocks see *all* control exceptions

[19:20] <pmichaud> but not all control exceptions go through the dynamic stack.

[19:20] *** acajou joined
[19:20] <ruoso> that's the point

[19:20] <ruoso> all control exceptions go through the dynamic stack

[19:20] <ruoso> "all exception handlers run in the dynamic context"

[19:21] *** orafu left
[19:21] <pmichaud> I think that the fact that next/last/redo and return don't honor the dynamic stack seems to contradict your statement.

[19:21] *** orafu joined
[19:21] <ruoso> it does honor the dynamic stack

[19:21] <pmichaud> i.e., they first react lexically, _then_ they look through the dynamic stack.

[19:21] *** xinming_ joined
[19:22] <ruoso> what happens is that the implementation of the implied CONTROL block for routine declarators and loop statements, not which CONTROL block is executed

[19:23] <ruoso> pmichaud, my point is that all CONTROL blocks are going to be executed in the way

[19:23] <ruoso> what happens is that there are some implied CONTROL blocks 

[19:23] <ruoso> in routine boundaries

[19:24] <ruoso> and in loop statements

[19:25] <ruoso> and the implementation of that implied blocks are the ones that take care of only returning from the correct routine... or going next on the correct loop

[19:26] <pmichaud> ruoso: I'm sorry, but I don't see it that way in the spec.

[19:27] <ruoso> pmichaud, I honestly don't see how you can think of them as control exceptions and not going through the dynamic stack directly...

[19:28] <pmichaud> I'm saying they go through the dynamic stack if they aren't handled lexically.

[19:28] <ruoso> but how do you handle an exception lexically?

[19:28] <ruoso> what does it mean?

[19:29] <pmichaud> the same way that 'return' is tied to the lexical sub in which it's written.

[19:29] <pmichaud> next/last/redo can be tied to the looping construct in which they are written

[19:30] <pmichaud> in particular, saying  "next LABEL"  will always trigger a lexically-available LABEL in preference to a dynamically-available one.

[19:30] <ruoso> that's simply the implementation of the implied CONTROL blocks

[19:30] <ruoso> not the behavior of "goto" itself

[19:31] <ruoso> nor "return", "next", "last" etc

[19:31] <ruoso> I mean...

[19:31] <ruoso> the "goto" function

[19:31] <pmichaud> again, that doesn't appear to be written as you describe it in the spec.

[19:31] <ruoso> the functions are simply meant to instantiate and throw the specific control exception

[19:32] <TimToady> I think ruoso's view is the more accurate here; in the abstract, we always throw the control exception up the dynamic stack, but we may already have labelled it with the lexical scope it's aimed at

[19:32] <TimToady> the optimizer can get rid of the dynamic throw if it can prove no CONTROL blocks interfere

[19:32] <pmichaud> TimToady: and inner dynamic routines'  CONTROL blocks can catch the exception?

[19:32] <TimToady> and well-behaved CONTROL blocks won't usurp the lexical semantics

[19:33] <pmichaud> fair enough.

[19:33] <ruoso> but bad-behaved CONTROL blocks can indeed happen...

[19:33] <TimToady> and one-person's bad-bahaved is someone else's killer feature--see AOP :)

[19:34] <ruoso> TimToady, is the "If you pass a closure object outside of its official "sub" scope, it is illegal to return from it" new?

[19:34] <pmichaud> is it possible for dynamic inner CONTROL blocks to see a return exception, or is that outside of what ruoso just cited?

[19:34] <TimToady> no, it's pretty old

[19:34] <ruoso> I think I over-read it

[19:34] <TimToady> and falls out from the fact that the lexical label just won't be found in the dynamic stack

[19:34] <ruoso> a return inside a map is made impossible by that line

[19:35] <ruoso> ahhh...

[19:35] <ruoso> you got it wrong...

[19:35] <ruoso> pmichaud, 

[19:35] <ruoso> it's not about the example in the RT ticket

[19:35] <TimToady> a return inside a map returns from the map only if the first arg was a sub {}

[19:35] <TimToady> well, returns from the sub in the map

[19:36] <TimToady> otherwise return returns from the sub surrounding the map

[19:36] <ruoso> that quote is about

[19:36] <TimToady> yes, inner CONTROl blocks can examine the return exception as it goes by

[19:36] <TimToady> the optmizer should not be trying to eliminate that throw

[19:37] <ruoso> sub closure_generator { return { return 1 }; }; my $code = closure_generator(); sub bar($code){ $code.() }; foo($code)

[19:37] *** rindolf joined
[19:37] <ruoso> the above example is illegal

[19:37] <TimToady> yes, it is

[19:37] <ruoso> that's what that quote is about

[19:37] *** abra left
[19:38] <pmichaud> and

[19:38] <pmichaud> 19:05 <ruoso> sub bar($code) { $code(); CONTROL { say "hello" }};sub foo { bar { return 1 }; return 2; }; say foo

[19:38] <ruoso> that is legal

[19:38] <TimToady> has to be written &CALLER.leave(1) or some such

[19:38] <pmichaud> is valid, and produces 'hello 1' as ruoso said.

[19:38] *** xinming left
[19:39] <ruoso> I think that quote could be re-written as "it is illegal to use the return function in a closure whose outer scope was already destroyed"

[19:40] <ruoso> ok... not destroyed... but maybe "lost" instead

[19:40] *** justatheory joined
[19:40] <pmichaud> in ruoso's bar() example,  does the CONTROL block make it considered to have handled the return exception?  Or is it treated as not handled by default?

[19:40] <pmichaud> i.e., because we didn't specifically test the exception itself

[19:40] <ruoso> I've been assuming that for a while now

[19:40] <TimToady> I think everything a CONTROL block does must be explicit, perhaps

[19:41] <pmichaud> ruoso: assuming that the exception isn't handled?

[19:41] <ruoso> TimToady, I like that

[19:41] <TimToady> so nothing gets handled merely by testing

[19:41] <pmichaud> that's true for CATCH also?

[19:41] <pmichaud> or just CONTROL ?

[19:41] <ruoso> just CONTROL, or else you get much more verbose code for CATCH

[19:41] <TimToady> so there's some primitive access to $!.handle_it available to CONTROL blocks to stop propagation

[19:42] <TimToady> just CONTROL, I think

[19:42] <ruoso> TimToady, what about CONTROL having to re-trhow the exception when appropriate?

[19:42] <TimToady> proper Huffman, since people aren't supposed to write CONTROL often

[19:42] <pmichaud> okay, so all CONTROL block exceptions are not handled unless the block explicitly does something to handle it.

[19:42] <pmichaud> er, to mark it as "handled"

[19:42] <TimToady> well, explicit rethrow is the other way to default it

[19:43] <TimToady> can argue it either way

[19:43] <TimToady> when * { rethrow } is pretty short

[19:43] <TimToady> on the other hand, we want whatever is fastest

[19:44] <TimToady> it's really another dispatcher problem with a list of candidates

[19:44] <TimToady> so the argument is over whether we're defaulting to . or .* semantics :)

[19:45] <TimToady> and whether we require poeple to say "next" vs "lastcall"

[19:45] <TimToady> s/oe/eo/

[19:46] <TimToady> only those are called rethrow vs handled

[19:46] <TimToady> so it's possible there's another unification waiting here somehow

[19:46] <ruoso> for SMOP, rethrow is pretty straight forward

[19:46] <ruoso> because we are very continuation-oriented...

[19:46] <TimToady> it might not be for some VMs though

[19:47] <ruoso> but I guess that whatever is decided can be adapted from the code to the expected behavior

[19:47] <TimToady> unfortunately, we can't implement CONTROL calls in terms of callnext/lastcall if those are implemented in terms of CONTROL...

[19:49] <pmichaud> TimToady, ruoso:  thanks for the clarification on CONTROL -- that will be very helpful.

[19:49] <TimToady> I'm still inclined to think that CONTROL { } is a no-op, and rethrow is just "keep going"

[19:49] <TimToady> and stopping that is explicit somehow

[19:49] <ruoso> TimToady, in fact... CONTROL { } and CONTROL { $_.rethrow } are really the same thing...

[19:50] <ruoso> in terms of what can be done, I mean...

[19:50] <TimToady> in SMOP, you mean

[19:51] <pmichaud> I tend to prefer the notion that CONTROL { }  is a no-op.

[19:51] <TimToady> they might be very different in other VMs, unless we define rethrow to be to just leave the CONTROL block

[19:51] <pmichaud> The idea that CONTROL { } means "intercept all control exceptions and do nothing with them"  kinda bugs me.

[19:51] *** ispy_1 left
[19:51] <TimToady> I don't want to make life all that easy for the writers of CONTROL blocks; they should suffer a little :)

[19:51] <ruoso> TimToady, I mean that in terms of the compiler, it will be compiled to one thing or the other... it really is purely a syntax decision...

[19:51] <TimToady> but they have to be FAST

[19:52] <ruoso> (in SMOP, explicit rethrow is faster)

[19:52] <ruoso> as implicit would require an additional test...

[19:53] <pmurias> ruoso: porting over, not today

[19:53] <ruoso> pmurias, ok... I'll see if I do it...

[19:56] <ruoso> pmichaud, syntatically... we could imply that every CONTROL block has an implicit "when * { .rethrow }"

[19:57] <pmichaud> ruoso: that works for me.

[19:57] <TimToady> what if when FooException doesn't handle it and breaks out?

[19:58] <TimToady> that won't hit the 'when *' default case

[19:58] <TimToady> but the Really Default semantics

[19:58] <TimToady> and that could be either assuming . or .* semantics

[19:58] <TimToady> so I think implicit 'when *' doesn't cut it

[19:58] <ruoso> but thinking about it... it kinda makes sense...

[19:59] <ruoso> that means that if you use "when" inside a CONTROL, you better rethrow if that's what you mean

[19:59] <ruoso> so, it's kinda making it handled by matching in the when...

[20:00] <TimToady> so your arguing for CATCH semantics, basically

[20:01] <ruoso> kinda...

[20:01] <ruoso> CATCH still does an "if"

[20:01] <ruoso> it only rethrows if it's not handled

[20:05] <ruoso> I could argue that CATCH could behave like this as well

[20:05] <TimToady> maybe CONTROL blocks should be required to be explicit about everything, and die horribly if the response is "I dunno".  then the optimizer could decide what can be a no-op.

[20:06] <ruoso> you mean CONTROL { } to be a no-op or not?

[20:06] <TimToady> that would then die horribly

[20:06] <ruoso> I'd be fine with that...

[20:07] <TimToady> so you must have a when *, and each when Foo must be explicit in rethrow or handle

[20:07] <ruoso> but it looks strongly continuation-oriented

[20:07] <pmichaud> I think die horribly seems good.

[20:07] <TimToady> as I say, I'm not trying to simplify the lives of CONTROL block writers, who should be discouraged whenever possible. :)

[20:08] <ruoso> ok... so CONTROL {} is plain wrong...

[20:08] <TimToady> so I think the right default is NO default

[20:08] <TimToady> yes, that'd be wrong under this view

[20:08] <pmichaud> CONTROL {}  indicates a lack of control on the part of the author.  :-)

[20:08] <[particle]2> if being specific means it'll be fast and unambiguous, let the module authors come up with syntax sugar

[20:08] *** [particle]2 is now known as [particle]-

[20:08] <ruoso> ok... so if it leaves a CONTROL block with an unhandled exception, it should break

[20:08] <TimToady> CONTROL {} means "just shoot me"

[20:09] <pmichaud> actually, I think that any leaving of a CONTROL block breaks.

[20:09] <pmichaud> i.e., one has to explicitly get out of the CONTROL block.

[20:09] <TimToady> I think getting control flow fast is a good reason to inflict pain

[20:09] <ruoso> that should be fine...

[20:09] <pmichaud> there's a presumed      <  die "horribly" >   at the end of the CONTROL block.

[20:10] *** azawawi left
[20:10] <TimToady> yes, and after it too, to handle ambiguous break exits

[20:11] <[particle]-> so, you can't attach a control block to a control block.

[20:11] <pmichaud> argh... something in parrot has broken rakudo.

[20:11] <ruoso> [particle]-, well... that idea looks so weird I can't even think about it...

[20:12] * pmichaud decides to find a particle gun.

[20:12] <TimToady> [particle]-: if that restriction falls out of what we're saying, I'm quite happy with it

[20:12] <ruoso> but I guess when running the control block, it is plain code...

[20:12] * [particle]- likes to think of edge cases

[20:12] <ruoso> so you can have a control block inside it

[20:15] <TimToady> yes, it's plain code, but the question is whether it has to be considered a 'critical' section that locks out similar code somehow

[20:16] <ruoso> well... for SMOP, at least, it makes no difference... 

[20:16] <TimToady> might need a conservative approach in 6.0 till we understand that

[20:16] <ruoso> more one of those erroneous things?

[20:17] <ruoso> s/more one/one more/

[20:17] <TimToady> no, one step beyond erroneous

[20:17] <TimToady> erroneous still allows divergence

[20:17] <ruoso> I'm fine either way...

[20:18] <TimToady> being conservative means preventing divergence until we understand it

[20:18] <ruoso> (the problem with that is making the change incredibly hard... as with conservative people in politics ;)

[20:19] <ruoso> (but I'm still ok with being conservative in that point) ;)

[20:19] <TimToady> ENOBRAINSUGAR

[20:19] <TimToady> lunch &

[20:19] * ruoso decommute &

[20:26] <acajou> rakudo: my @tt = (1, 2, 3, 4); sub zap(@input is readonly) { @input[0] = 666; }; zap(@tt); say @tt[0];

[20:26] <p6eval> rakudo 6f1649: OUTPUT«666␤»

[20:26] <acajou> bug or feature?

[20:26] <acajou> And

[20:26] <acajou> rakudo: my @tt[4] = (1, 2, 3, 4); sub zap(@input is readonly) { @input[4] = 666; }; zap(@tt); say @tt[4];

[20:26] <p6eval> rakudo 6f1649: OUTPUT«Statement not terminated properly at line 1, near "[4] = (1, "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:85)␤»

[20:26] <acajou> Oops, wrong version...

[20:26] <acajou> rakudo: my @tt = (1, 2, 3, 4); sub zap(@input is readonly) { @input[4] = 666; }; zap(@tt); say @tt[4];

[20:26] <p6eval> rakudo 6f1649: OUTPUT«666␤»

[20:27] <acajou> Also: bug or feature?

[20:28] <PerlJam> looks like a bug to me 

[20:28] <moritz_> I don't think that 'is readonly' is implemented

[20:28] <jnthn> readonly doesn't extend any deeper than the container.

[20:28] <jnthn> So AFAIK not a bug.

[20:28] <acajou> OK, so the former is a feature.  But the second one, I shouldn't be able to grow the array it seems...

[20:28] <jnthn> Don't see the difference.

[20:29] <jnthn> Both call postcircumfix:<[ ]>

[20:29] <acajou> rakudo: my @tt = (1, 2, 3, 4); sub zap(@input is readonly) { @input[4] = 666; }; zap(@tt); say @tt[4];

[20:29] <p6eval> rakudo 6f1649: OUTPUT«666␤»

[20:29] *** lisppaste3 joined
[20:29] <jnthn> moritz_: is readonly is the default.

[20:29] <moritz_> rakudo: sub f($x is blah) { say "alive" }; f(2)

[20:29] <p6eval> rakudo 6f1649: OUTPUT«alive␤»

[20:29] <acajou> The array passed in doesn't have a [4]th element.

[20:29] <pmichaud> I would guess that postcircumfix:<[ ]> needs to honor the readonly attribute on @input

[20:30] <jnthn> pmichaud: I didn't think readonlyness extended down a level?

[20:30] <pmichaud> jnthn: surely @input is readonly should mean that one cannot add new elements to @input, yes?

[20:30] <pmichaud> or what is it about @input that is "readonly"?

[20:31] <jnthn> rakudo: sub foo(@foo) { @foo = 1,2,3,4; } my @x = <a b c d>; foo(@x); say @x;

[20:31] <p6eval> rakudo 6f1649: OUTPUT«Statement not terminated properly at line 1, near "my @x = <a"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:85)␤»

[20:31] <jnthn> rakudo: sub foo(@foo) { @foo = 1,2,3,4; }; my @x = <a b c d>; foo(@x); say @x;

[20:31] <p6eval> rakudo 6f1649: OUTPUT«Cannot assign to readonly variable.␤current instr.: 'die' pc 17536 (src/builtins/control.pir:225)␤»

[20:31] <jnthn> That'.

[20:31] <pmichaud> but you're saying that @foo[99] = 5;   would be valid there?

[20:32] <jnthn> I think so...though I may be wrong.

[20:32] <pmichaud> I can understand that @foo[0] = 5;  might be valid, because we're modifying @foo[0]  (as opposed to @foo)

[20:32] <acajou> Seems odd to allow a read-only object to grow its length....

[20:32] <jnthn> As far as I understood it though, readonly protection only affects the variable itself.

[20:32] <pmichaud> but @foo[99] is definitely modifying @foo.

[20:32] <jnthn> Yeah, interesting case.

[20:33] <jnthn> But that means postcircumfix:<[ ]> would need to know about read-onlyness. :-S

[20:33] <acajou> is readonly should default to a fixed length for an array

[20:33] <acajou> (though fixed length arrays don't appear to exist yet.)

[20:33] <acajou> imho...

[20:33] <eric256> wouldn't the = be what needs to know about readonly not the [ ]?

[20:33] <pmichaud> jnthn: it's okay if postcircumfix:<[ ]> knows array readonly ness.

[20:34] <jnthn> pmichaud: Yeah, perhaps.

[20:34] <pmichaud> argggh, I'm getting runtime failures in rakudo spectests.

[20:34] <pmichaud> I wonder if it's a 64-bit issue.

[20:34] <jnthn> I'd just understood it as, if you call a method on some data structure that was passed as a read-only parameter, it could do what it likes.

[20:34] <jnthn> And postcircumfix:<[ ]> is just a method call...

[20:35] <jnthn> We could treat this case specially though, for sure.

[20:35] <moritz_> jnthn: for scalars that's definitively true

[20:35] <pmichaud> sounds like it needs clarification from p6l.

[20:35] <moritz_> jnthn: I don't know if that's intended like that for containers as well

[20:35] <acajou> Well, allowing @foo[99]=1; doesn't seem very DWIMish to me...

[20:35] <jnthn> Thing is, push would also need to know about this...

[20:35] <jnthn> etc

[20:35] <pmichaud> and unshift.

[20:35] <moritz_> all modifying methods would need to know it

[20:36] <acajou> But once fixed length arrays exist, will that not be necessary anyway?

[20:36] <moritz_> only where they are used

[20:37] <acajou> and is readonly should tranform an array into fixed length within its context...(no?)

[20:37] <acajou> (AFK)

[20:37] <pmichaud> is readonly should generally not be doing any sort of transformation.

[20:37] <pmichaud> that's kinda the point of "readonly"

[20:38] <meppl> good night

[20:43] *** meppl left
[20:45] <pugs_svn> r26506 | pmichaud++ | [t/spec]:  underscore matches <alpha> -- RT #65138.

[20:59] *** iblechbot left
[21:01] *** eric256 left
[21:04] *** dolmen joined
[21:04] <pugs_svn> r26507 | ruoso++ | [re-smop] ported over ritest, capturize and ControlExceptionReturn... now mildew tests are failing because its not finding $_ in the lexical scope... that looks like its missing the default block signature...

[21:04] <Tene> Can anyone help me with some class construction issues?

[21:05] *** ruoso left
[21:05] <Tene> if I define BUILD in a parent class, it's called multiple times for each level of the class hierarchy

[21:05] <Tene> http://gist.github.com/102721

[21:06] <Tene> I tried adding an attribute to the class (has $.built) and checking that, but that gets weird errors...

[21:06] *** payload left
[21:07] *** rindolf left
[21:08] *** orafu left
[21:09] *** orafu joined
[21:10] *** nihiliad left
[21:11] <Tene> rakudo: class A { has $.foo is rw; submethod BUILD($item) { $item.foo = 1 } }; my $a = A.new();

[21:11] <p6eval> rakudo f93154: OUTPUT«Null PMC access in getprop()␤current instr.: 'infix:=' pc 15704 (src/builtins/assign.pir:20)␤»

[21:13] *** dukeleto left
[21:14] <Tene> Oh, the issue with submethods is that they shouldn't be inherited by ancestors?

[21:14] <Tene> erm... descendants?

[21:14] <moritz_> that's one of the issues

[21:15] <Tene> The other issue was me trying to work around that. :)

[21:15] <jnthn> submethods work - what is wrong is (at least) that when you replace the default BUILD with your own one, you lose the code that puts the initial scalar or other container PMC into the attribute.

[21:16] <jnthn> Since the default BUILD does that.

[21:16] <jnthn> We probably need to thus move the code doing that elsewhere.

[21:16] <Tene> jnthn: any ideas on how to run something just once on class instantiation?

[21:16] <jnthn> So you can write a BUILD and have it work.

[21:16] <jnthn> BUILD should do it. I wonder if we're not calling the submethod through the correct dispatcher though...

[21:17] <Tene> jnthn: if I define a submethod BUILD in a parent class, it's called once for each descendent class

[21:17] <Tene> http://gist.github.com/102721

[21:20] <moritz_> Tene: there's also a ticket for that one

[21:22] <jnthn> Aye.

[21:22] <jnthn> I'll try and look at and clean this stuff up soon.

[21:22] <Tene> :)

[21:22] <Tene> jnthn: do I have any patches left I've promised you I'd work on?

[21:22] <jnthn> Already promised to work on constants tomorrow.

[21:23] <jnthn> Tene: How's the annotations/backtrace one going? Still blocking on the "it changes Parrot error messages" issue?

[21:23] <Tene> pm suggests I just put it in PCT instead of Parrot

[21:24] <Tene> The issues I had when trying to get it to change nothing if there were no annotations was that I was somehow getting a 0 instead of NULL

[21:25] <pmichaud> Tene: if it fits well in Parrot, go there.  If it doesn't fit well in Parrot, it's okay to put in PCT.

[21:25] *** PhatEddy joined
[21:25] <pmichaud> I vote to go with your best judgement on this one :-)

[21:25] <Tene> OK

[21:27] <pugs_svn> r26508 | moritz++ | [t/spec] test for RT #65138, Foo::_foo() parsefails (and change fudging a bit)

[21:33] *** wknight8111 joined
[21:34] *** skids_ left
[21:44] *** Schnueff_ left
[21:46] *** payload joined
[21:46] *** justatheory left
[22:04] *** dduncan joined
[22:05] <acajou> Gotta run, but I still think allowing this is kinda odd:

[22:05] <acajou> rakudo: my @tt = (1, 2, 3, 4); sub zap(@input is readonly) { @input[99] = 666; }; zap(@tt); say @tt[99];

[22:05] <p6eval> rakudo f93154: OUTPUT«666␤»

[22:06] *** iblechbot joined
[22:06] <acajou> Though maybe it's ok given that I didn't say my @tt[4] = (1, 2, 3, 4);

[22:06] <acajou> (which doesn't parse right now...)

[22:07] * acajou waves

[22:07] *** acajou left
[22:08] <dduncan> question ... what are some good examples, if any are better than STD.pm, of Perl 6 grammars, particularly demonstrating a difference between tokens and rules

[22:09] <moritz_> if STD.pm is too complex, rakudo's grammar might be easier for you

[22:09] <dduncan> I'm wanting to enhance my grammar for my new programming language to specify places where it adds or changes information that ends up in the parse tree, such as node names

[22:10] <moritz_> (but the difference is really simple - whitespaces in rules are substituted internally by <.ws>)

[22:10] <dduncan> eg, if it finds a run like 'foo' then I want it to turn it into something like [Text, 'foo'], and how to say that

[22:10] <moritz_> ah for that you need action methods

[22:11] <dduncan> I thought a diff between a rule and a token is that a rule adds action specifiers while a token is strictly "match what looks like this"

[22:12] <moritz_> rakudo: grammar A { token TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { make ['Text', ~$0 } } }; A.parse("'foo'", :actions(B.new)); say $/.ast.perl;

[22:12] <p6eval> rakudo f93154: OUTPUT«Statement not terminated properly at line 1, near "['Text', ~"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[22:12] <moritz_> dduncan: no, actions are marked with {*}, and are indpendent of the token/rule distinction

[22:12] <moritz_> rakudo: grammar A { token TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { make ['Text', ~$0] } }; A.parse("'foo'", :actions(B.new)); say $/.ast.perl;

[22:12] <p6eval> rakudo f93154: OUTPUT«""␤»

[22:12] *** orafu left
[22:13] <moritz_> rakudo: grammar A { token TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { make ['Text', ~$0] } }; A.parse("'foo'", :action(B.new)); say $/.ast.perl;

[22:13] *** orafu joined
[22:13] <p6eval> rakudo f93154: OUTPUT«""␤»

[22:13] <pmichaud> dduncan: the only real difference between token and rule is the handling of whitespace in the pattern

[22:13] <dduncan> oh?

[22:13] <pmichaud> a rule is simply a token with :sigspace set.

[22:13] <arnsholt> I just looked up the difference between token and rule, and according to S05, the difference is that tokens never backtrack by default, as opposed to rules, which do

[22:13] <dduncan> I'll have to remind myself what sigspace is

[22:13] <dduncan> ...

[22:14] <pmichaud> regexes do not backtrack by default.

[22:14] <dduncan> I see

[22:14] <pmichaud> regex:  backtracking

[22:14] <moritz_> pmichaud: huh?

[22:14] <pmichaud> backwards

[22:14] <moritz_> regexes backtrack

[22:14] <pmichaud> regexes backtrack by default

[22:14] <pmichaud> rules do not backtrack by default

[22:14] <moritz_> tokens and rules don't

[22:14] <pmichaud> a token is simply a regex with :ratchet set

[22:14] <pmichaud> a rule is simply a token with :sigspace set

[22:15] <moritz_> rakudo: grammar A { token TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { make ['Text', ~$0] } }; A.parse("'foo'", :action(B.new)) or die 'no match'; say $/.ast.perl;

[22:15] <p6eval> rakudo f93154: OUTPUT«no match␤current instr.: 'die' pc 17536 (src/builtins/control.pir:225)␤»

[22:15] <arnsholt> Indeed. If I'd read the whole section I might even have figured that out by myself...

[22:15] <moritz_> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { make ['Text', ~$0] } }; A.parse("'foo'", :action(B.new)) or die 'no match'; say $/.ast.perl;

[22:15] <p6eval> rakudo f93154: OUTPUT«["Text", "foo"]␤»

[22:16] <moritz_> that was a classical example of backtracking FAIL ;-)

[22:16] <dduncan> another grammar question, I may return to my first question ... regarding the syntax for "<mylistitem> ** <mylistsep>", does that only match a list of at least one item, or will it match a zero-item list too?

[22:16] <moritz_> .*? can't work without backtracking

[22:16] <pmichaud> currently PGE treats it as "at least one item"

[22:16] <moritz_> dduncan: the example above should give you an idea of how to do transformations from grammars

[22:16] <dduncan> okay

[22:17] <pmichaud> all of the descriptions in S05 seem to imply that <item> ** <sep>  match at least one <item>, so that's what we've gone with.

[22:17] <pmichaud> To include the possibility of zero, it's:   [ <item> ** <sep> ]?

[22:17] <dduncan> that's what I've been doing so far

[22:18] <dduncan> but I thought I'd see if my ** assumption was false

[22:18] <dduncan> seems not atm

[22:19] <dduncan> fyi, right at the moment I'm mainly looking to write an illustrative grammar for my language spec, which doesn't necessarily have to run, though I will want to make a version that runs soon after

[22:19] <pmichaud> dduncan: excellent

[22:19] <dduncan> but where the illustrative version can be correct without being too complicated, I prefer to be correct

[22:19] <moritz_> dduncan: IMHO grammars work pretty well in rakudo... the action methods don't, they tend to segfault when it gets too complicated

[22:20] <dduncan> I thought I'd prefer to use the Perl 6 grammar syntax rather than BNF or whatever

[22:20] <pmichaud> action methods segfault?  hmmm.

[22:20] <moritz_> pmichaud: yes, I've written a ticket for that...

[22:21] <pmichaud> if you can find the ticket, I'd like to look closer at it.

[22:21] <moritz_> pmichaud: and then later on tried to rewrite the actions for a XML grammar by masak, and it also segfaulted pretty soon

[22:21] <pmichaud> (will have to do it later tonight, though -- fixing dinner here)

[22:21] <dduncan> fyi, http://search.cpan.org/dist/Muldis-D/lib/Muldis/D/Dialect/PTMD_Tiny.pod is the most recently published version of what I'm talking about ... right now I'm pushing to partially rewrite and otherwise complete the grammar, which currently just does literals, so it does everything else (routine, type defs, etc)

[22:22] <moritz_> I've never been able to reduce it; when the example is too simple it just works... http://rt.perl.org/rt3/Ticket/Display.html?id=64208

[22:22] <moritz_> (hilight pmichaud so he'll see the link)

[22:22] <dduncan> my tokens/rules question related to adding capturing groups in such a way that the result can be similar to another dialect of the language which is specified as Perl data structures

[22:22] <pmichaud> moritz_: part of the difficulty with that example is that $_ isn't set.

[22:23] <pmichaud> so there's not really anything for   when * { ... }  to smartmatch.

[22:23] <dduncan> if I can say what I want easily in the grammar I will, otherwise I'll just describe it in human text comments about "this is interpreted as ..."

[22:23] <dduncan> that is all for the moment

[22:23] <dduncan> thank you

[22:23] <moritz_> pmichaud: quoting the ticket "(adding a given $what { ... } around it makes no difference)."

[22:24] <moritz_> dduncan: the best way to get familiar with the match tree is to write some really simple grammars (like, 3 or 4 rules) and then 'say $/.perl

[22:24] <pmichaud> the other difficulty might be that (I think)   the block for the when gets its own $/

[22:24] <moritz_> '

[22:24] <dduncan> okay

[22:24] <pmichaud> I wonder if the $/ isn't being bound properly.

[22:24] <pmichaud> at any rate, segfault is definitely the wrong answer.  I'll give it a try a bit later.

[22:25] <moritz_> rakudo: grammar A { token TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no match'; say $/.ast.perl;

[22:25] <pmichaud> (claiming ticket)

[22:25] <p6eval> rakudo f93154: OUTPUT«no match␤current instr.: 'die' pc 17536 (src/builtins/control.pir:225)␤»

[22:25] <moritz_> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no match'; say $/.ast.perl;

[22:25] <p6eval> rakudo f93154: OUTPUT«["Text", "foo"]␤»

[22:25] <dduncan> I'll get to such experimentation before too long, though right now I'm going for the low hanging fruit of what I can approximate without actually executing anything

[22:25] <moritz_> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { if 1 { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no match'; say $/.ast.perl;

[22:25] <p6eval> rakudo f93154: OUTPUT«["Text", "foo"]␤»

[22:25] <dduncan> I will study the Rakudo source as suggested though

[22:26] <moritz_> feel free to come back with questions

[22:27] <pmichaud> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { when * { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no  match'; say $/.ast.perl;

[22:27] <p6eval> rakudo f93154:  ( no output )

[22:27] <pmichaud> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no  match'; say $/.ast.perl;

[22:27] <p6eval> rakudo f93154: OUTPUT«["Text", "foo"]␤»

[22:27] <pmichaud> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { when True { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no  match'; say $/.ast.perl;

[22:27] <p6eval> rakudo f93154: OUTPUT«Method 'ACCEPTS' not found for invocant of class ''␤current instr.: 'infix:~~' pc 21988 (src/builtins/match.pir:18)␤»

[22:28] <pmichaud> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { when ?(1) { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no  match'; say $/.ast.perl;

[22:28] <p6eval> rakudo f93154:  ( no output )

[22:28] <moritz_> heh, another bug ;-)

[22:28] <pmichaud> it must have something to do with the way that 'when' is setting things up.

[22:28] <moritz_> pmichaud: "no output" seems to mean "segmentation fault"

[22:28] <pmichaud> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { if 1 { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no  match'; say $/.ast.perl;

[22:28] <p6eval> rakudo f93154: OUTPUT«["Text", "foo"]␤»

[22:29] <pmichaud> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { if 0 { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no  match'; say $/.ast.perl;

[22:29] <p6eval> rakudo f93154: OUTPUT«"'foo'"␤»

[22:29] <moritz_> pmichaud: I only see that on p6eval's console, I haven't found a way to print it back to IRC

[22:29] *** iblechbot left
[22:30] <dduncan> it does appear though that tokens are indeed what I want to use right now rather than rules ... less magical ... and a quick scan through STD.pm shows it uses mostly tokens also

[22:31] <pmichaud> in general, 'token' is for things that don't have spaces

[22:31] *** km2 left
[22:31] *** km2 joined
[22:32] <dduncan> well in that case, maybe rules are what I want often times ... looking ...

[22:32] <pmichaud> token is also for things where you need very tight control of spaces

[22:32] *** km2 left
[22:32] <dduncan> in most places, I have been specifying whitespace as \s*

[22:33] <pmichaud> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { if $_ ~~ ?(1) { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no  match'; say $/.ast.perl;

[22:34] <p6eval> rakudo f93154: OUTPUT«["Text", "foo"]␤»

[22:34] <pmichaud> definitely tied to when.

[22:34] <pmichaud> rakudo: grammar A { regex TOP { \' (.*?) \' {*} } }; class B { method TOP($/) { if $_ ~~ * { make ['Text', ~$0] } } }; A.parse("'foo'", :action(B.new)) or die 'no  match'; say $/.ast.perl;

[22:34] *** orafu left
[22:34] <p6eval> rakudo f93154: OUTPUT«["Text", "foo"]␤»

[22:34] *** orafu joined
[22:37] <dduncan> another question ... is there an easy way to say that certain things in an inner context are only allowed to match when that is within an arbitrarily far away outer context? ...

[22:38] <dduncan> for example, I have a number of syntaxes for selecting anonymous collection values, which if composed into an expression tree that is part of a routine or type def, may include a function invocation, ...

[22:39] <dduncan> but if that syntax is used standalone, outside eg a func def, then a function call isn't allowed, and only literals etc are

[22:40] <dduncan> unless there's an easy way to say this, I was going to make 2 versions of the syntax, one for value expressions inside routines, and the other for ones outside them, which are then just constant declarations

[22:40] <dduncan> my question was whether I could save some redundancy or whether it doesn't matter to have such redundancy

[22:41] <dduncan> if code examples are needed to understand my question, I can provide them

[22:41] *** dolmen left
[22:42] <dduncan> basically the distinction is like the difference between compile time and runtime evaluation, where routines may not be invoked at compile time

[22:42] <dduncan> but stuff like anonymous Perl hash or array etc constructions are allowed both times

[22:43] <dduncan> that's not strictly what is going on here, but it should be illustrative

[22:44] *** rblasch left
[22:51] *** Kisu left
[22:51] *** Kisu joined
[22:53] *** jbt left
[22:56] *** simcop2387 left
[22:58] *** justatheory joined
[23:00] *** skids_ joined
[23:27] *** justatheory left
[23:38] *** orafu left
[23:38] *** orafu joined
[23:39] *** pmurias left
[23:39] *** justatheory joined
[23:51] *** Limbic_Region joined
[23:52] *** bacek joined
[23:57] *** alester left
