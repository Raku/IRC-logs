[00:04] <ruoso> wayland76, hi

[00:04] <wayland76> Question: Should IO::Listening be merged into IO::Socket?

[00:05] <wayland76> (I'm in the middle of revision the S32/IO stuff)

[00:05] <ruoso> well... it certainly is Socket specificc

[00:06] <wayland76> Can't be used by pipes as well?

[00:06] <wayland76> Or are pipes handled by the Socket interface?

[00:06] <ruoso> not at all...

[00:06] <wayland76> ok

[00:06] <wayland76> I'll merge it into IO::Socket then

[00:06] <ruoso> pipes are most fundamental than socket

[00:07] *** Kisu left
[00:08] *** Kisu joined
[00:12] *** hercynium joined
[00:15] *** M_o_C left
[00:18] *** wknight8111 left
[00:22] *** DemoFreak left
[00:26] *** FurnaceBoy left
[00:30] <pugs_svn> r26030 | wayland++ | S32/IO:

[00:30] <pugs_svn> r26030 | wayland++ | -  Merged IO::Listening into IO::Socket

[00:30] <pugs_svn> r26030 | wayland++ | -  Made IO::Socket implement IO::Closeable

[00:30] <pugs_svn> r26030 | wayland++ | -  Added a $.Listening attribute to IO::Socket.  

[00:34] <wayland76> I'll also make all sockets do Streamable, right?

[00:36] *** lumi_ joined
[00:47] *** lumi left
[00:47] *** lumi_ is now known as lumi

[00:48] <pugs_svn> r26031 | wayland++ | S32/IO: Expanded IO::Socket, mostly at the expense of IO::Socket::INET.  

[00:53] *** Sepheebear joined
[01:10] *** cognominal left
[01:41] *** c9s_ joined
[01:42] *** r00t_byte joined
[01:45] *** c9s left
[01:52] *** c9s joined
[01:53] *** agentzh left
[01:54] *** agentzh joined
[01:54] <s1n> frioux ping

[01:54] <frioux> s1n: pong

[01:56] *** Student joined
[02:00] *** kimtaro left
[02:01] *** cognominal joined
[02:01] *** c9s_ left
[02:03] *** Student left
[02:08] <dalek> rakudo: c015556 | pmichaud++ |  (6 files):

[02:08] <dalek> rakudo: Bring Rakudo up-to-date with recent PGE and compiler tools

[02:08] <dalek> rakudo: in trunk (which themselves were changed in order to more

[02:08] <dalek> rakudo: accurately reflect recent changes in S05).

[02:08] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c0155565811df4350ab1ff17a1ad47e6c7b13730

[02:08] <Tene> pmichaud: talked with jnthn yet about leave?

[02:09] *** kimtaro joined
[02:13] *** mncharity joined
[02:15] <mncharity> did a "Perl 6 - it's a new Common Lisp" sub-lightning talk at this evenings boston-lisp.  went over pretty well.  :)

[02:18] <wayland76> Great :)

[02:18] *** r00t_byte left
[02:18] <s1n> mncharity: common lisp, seems like an insult

[02:19] <mncharity> basically starts as a "Common Lisp is unique" talk.    "has a set of language features no other language has".  shows the names of lots of languages scattered across the slide.   for feature X, fade out languages which don't have it (usually most).  finally, "combining these all, CL is unique"... fades to CL in

[02:19] <mncharity> one corner, Perl 6 in another.  "err, well, how to rescue this hypothesis..."  next slide, "Perl 6 - it's a new Common Lisp".

[02:20] <mncharity> s1n: to CL or p6?

[02:20] <s1n> comparing anything to CL

[02:21] <s1n> sounds like a death kiss

[02:21] <wayland76> Not at a boston-lisp talk, presumably :)

[02:22] <wayland76> I kind of wonder, though, how we appeal to the PHP/python crowd :)

[02:22] <mncharity> that's easy...  { use Python; ... }

[02:22] <s1n> i suspect not at all

[02:23] <s1n> perl6 is significantly heavier on the twigils/operators/etc than perl5, and that was the source of lots complaints about perl5

[02:24] <s1n> (from non-perl developers anyways)

[02:24] <mncharity> on the infinite todo (short one) for elf, is getting some other languages working as language-X-to-p6 translators, to vastly increase the body of p6 tests.  javascript before python though (at least if I do it).  probably ruby too.

[02:24] <mncharity> js is actually not hard.  there's a one-day hack at it somewhere in the pugs tree.

[02:24] *** SamB left
[02:26] <wayland76> s1n: is it possible to avoid a fair amount of the twigils/operators if you don't like them?

[02:26] <mncharity> s1n:  there's no reason  $ perl6 foo.py  shouldn't work just fine.  don't have to care about twigils one never sees. 

[02:26] <wayland76> (ie. when writing your own code)

[02:26] <mncharity> pypy has done all the hard work.

[02:27] <mncharity> s/all/almost all/

[02:27] <mncharity> still need a p6 implementation though.  that's the real hard part.

[02:27] *** SamB joined
[02:28] <mncharity> $ perl6 -MLanguage::Friendly foo.py  perhaps

[02:28] *** PZt left
[02:29] <mncharity> $ perl6 -MLanguage::Friendly foo.py bar.rb hee.php

[02:29] <mncharity> though someone other than me would have to do hee.

[02:31] <mncharity> but anyway, p6 and CL are actually very close in concept and design philosophy.  aside from a slight disagreement on what's sane syntax.  "P6 - it's a metastasized reader macro".

[02:33] <mncharity> "P6 - the only way python will ever get non-toy multiple-dispatch"

[02:35] <literal> s1n: the only possibly bad thing I can think about Perl 5 sigils have been fixed in Perl 6, in my opinion

[02:35] <mncharity> wayland76: s1n: thanks for the comments anyway.  :)  I feared #perl6 dead air.

[02:36] <literal> that would be the variant sigil thing (@array -> $array[1]), which confuses some, and the sometimes hairy dereferencing syntax

[02:36] <mncharity> literal: how about, sigils exist?   /me expects a  { use Sigiless;  ...}   module as soon as the grammar and its surround support that.  Probably quite popular in some circles.

[02:37] <literal> no sigils? but I want interpolation :)

[02:37] <mncharity> :)

[02:37] <literal> and a separate namespace from subs

[02:38] <mncharity> ah.  I'm thinking   foo   parses as  $foo  .  but feel free to use "a$foo".   though "a{foo}b" is close.  re subs, perhaps trailing parens distinguish.

[02:39] <mncharity> atleast from folks coming from a language which uses them.  making ml'ers/haskellers  happy is more of a challenge perhaps.

[02:39] <mncharity> maybe typing.

[02:39] <literal> it's not just subs though, some other keywords as well

[02:40] <mncharity> ?

[02:40] <mncharity> don't use a variable named  next  ?

[02:40] <literal> or for, or last, or if...

[02:41] <mncharity> most langauges live with that.  one gets use to it.

[02:41] <frioux> rakudo: say 'foo'

[02:41] <p6eval> rakudo c01555: OUTPUT«foo␤»

[02:41] <mncharity> though I note you are making a CL-like argument... "lisp-2 is better than lisp-1" :)

[02:42] <mncharity> P6: "but if lisp-2 is better than lisp-1, think how great lisp-7 will be!"

[02:42] <mncharity> for some value of 7.  it's been a while since I've counted the p6 namespaces, don't remember how it turned out (12?), and has probably changed.

[02:45] <mncharity> to save folks the google:  CL is a lisp-2, functions and variables are in different namespaces.  in (x x) , x and x refer to different things.  the symbol x is like a glob, with separate "function" and "value" slots.   in scheme, a lisp-1,  x and x are the same.  in p5, a lisp-5+ (?), you can have f($f,@f,%f,...).

[02:50] *** dKingston left
[02:50] *** PZt joined
[02:52] * mncharity notes the irclog.perlgeek.de is creating broken links for S32, namely http://perlcabal.org/syn/S32.html .

[02:53] <wayland76> @tell moritz_ mncharity notes the irclog.perlgeek.de is creating broken links for S32, namely http://perlcabal.org/syn/S32.html .

[02:53] <lambdabot> Consider it noted.

[02:54] <mncharity> :)

[02:54] <wayland76> It's not what you know, it's who you know :)

[02:54] <wayland76> (well, maybe :) )

[02:54] <mncharity> lol

[02:55] <mncharity> at boston-lisp, someone clueful actually made the argument that CL's lack of standardized posixy things like chmod() wasn't a problem.  sigh.  standardized chmod++.

[02:56] <wayland76> Well, I don't like them, but I agree we have to have them :)

[02:57] <mncharity> :)  not like?

[02:57] *** mikehh joined
[02:58] <wayland76> Well, I don't like chmod because it ties us to a particular permissions model

[02:59] <wayland76> If we had a more ACL-based model, people would be happier about adding new filesystem attributes

[02:59] <mncharity> yeah

[02:59] <wayland76> But OTOH, I think people need to be able to call chmod at least as a legacy interface

[03:00] <mncharity> hmm, instead of chmod LIST ,  why isn't that  chmod PERM, FILES

[03:00] <mncharity> then chmod can multi dispatch on PERM.

[03:01] <mncharity> oh, LIST context?  err.  hmm.  /me puzzled.

[03:01] *** hudnix left
[03:01] <mncharity> but anyway, should be able to multi-dispatch on the permissions argument.

[03:01] <wayland76> Well, according to the spec at the moment, .chmod is only applicable to IO::FSNode::Unix

[03:02] <wayland76> And then ACLs are the "standard" interface, to be used with the knowledge that some OSs/filesystems will support more stuff than others

[03:03] <wayland76> To be fair, though, it's a draft spec :)

[03:03] <diakopter> well, a new group can be created for any ACL you want

[03:03] <diakopter> under-the-covers

[03:04] <diakopter> (I'm [perhaps wrongly] assuming groups can be members of groups)

[03:04] <diakopter> presuming

[03:05] <mncharity> chmod 'user_r:user_t:s0' foo;   multi chmod (Str $acl, *@files) { ... }   ?

[03:05] <wayland76> diakopter: I don't understand your first statement

[03:06] <mncharity> though obviously probably want to objectify that user_r:user_t:s0 .

[03:07] <mncharity> (example from SELinux)

[03:08] <wayland76> mncharity: Did you see ruoso's example on #november-wiki yesterday?

[03:08] <wayland76> multi uri($uri where /^http:/)

[03:08] *** hudnix joined
[03:08] <mncharity> hadn't.  neat.  instance-types++

[03:08] <wayland76> O

[03:08] <mncharity> another similarity with common lisp. ;)

[03:09] <meppl> good night

[03:09] <mncharity> err, "predicate types" (not "instance types")

[03:09] *** orafu left
[03:09] <wayland76> I'd been arguing in favour of a global variable, but when I saw that, I said "Can we do that?  Lets do that then!"

[03:09] <mncharity> g'night meppl :)

[03:09] <meppl> ;)

[03:09] *** c9s_ joined
[03:09] <wayland76> 'night

[03:09] *** OuLouFu joined
[03:09] <meppl> ;)

[03:10] *** meppl left
[03:11] <mncharity> traditional problem is that predicate dispatch is kind of expensive.  but... that's "fast language"'s concept of expensive, not "scripting language"-expensive.

[03:11] <diakopter> wayland76: nm; I was making faulty presumptions about the *n*x group membership system

[03:12] <mncharity> one joy of p6 vs CL is arguments of the form "nice language feature idea, but we don't know how to compile it efficiently" ends with "but we don't care!  let's have it anyway! :)".

[03:12] <mncharity> vis haslkel too.

[03:13] <mncharity> "that'd be nice to have... but we can't type it"..."don't care!  let's have it anyway!"

[03:15] <wayland76> diakopter: Yeah, I knew that, but I wondered if you might still have a point anyway :)

[03:15] * mncharity wonders what the current state of the art in p5 multi-dispatch is...

[03:16] <mncharity> i thought there was a #moose channel... ;-/

[03:16] * wayland76 think multi-dispatch is where you say "Duh, if youse don't talk, I'll knock both yers heads off"

[03:17] <wayland76> There is now, but I'm the only one there, and I don't know anything :)

[03:17] <mncharity> #moose on irc.perl.org

[03:18] <wayland76> bacek: are you the one doing the sockets?

[03:18] <diakopter> Class::C3...?

[03:18] <diakopter> oh wait, :(

[03:18] * diakopter shuts up

[03:19] *** ChanServ sets mode: +o diakopter

[03:19] *** diakopter was kicked by diakopter (diakopter))
[03:24] <mncharity> C3++

[03:25] <mncharity> nice to see #moose active... :/

[03:27] <mncharity> p5 has a triple down red arrow rating in this month's TIOBE.  which is subtitled "All time high for JavaScript, all time low for Perl".

[03:27] <mncharity> http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html

[03:27] *** c9s left
[03:27] <wayland76> TIOBE = The Importance of Being Ernest?

[03:28] <literal> haha

[03:28] <mncharity> :)

[03:30] <wayland76> I note we also had the biggest drop of anything except VB

[03:30] <wayland76> I wonder if the 3rd great depression (aka the Global Financial Crisis which is just starting) is having any effect on that

[03:33] *** c9s_ is now known as c9s

[03:33] <wayland76> It also appears that the only big gains were C, C plus plus, and javascript

[03:33] <mncharity> if one has there operational flexibility to choose what language to use, few would currently choose p5 over py in general, or niche rb, clojure/groovy/jruby/etc on java.

[03:34] <wayland76> I'd choose PHP over python :)

[03:34] *** hercynium left
[03:35] <mncharity> from the graph, the C++ gain looks like noise

[03:39] <bacek_> wayland76: (sockets) I just resurrected them

[03:40] <mncharity> wayland76: re PHP over python, shudder.

[03:41] <mncharity> ;)

[03:42] <mncharity> no commits to src/perl6/ since the 24th?  hmm

[03:43] <wayland76> bacek: ok.

[03:43] <wayland76> mncharity: Admittedly, I've not had to do much python

[03:44] <frioux> rakudo: 1 < 1|3 < 3

[03:44] <p6eval> rakudo c01555: RESULT«any(Bool::True, Bool::False)»

[03:44] <mncharity> huh?

[03:44] *** Alias_ left
[03:44] <bacek_> wayland76: btw, I personally dislike your last changes in S32...

[03:44] <mncharity> oh, i get it.

[03:44] <wayland76> bacek: In what way?

[03:45] <bacek_> using internal "$.isListening" for changing behavior

[03:45] <wayland76> Well, it should only change the behaviour of the .new() and .open() calls

[03:45] <wayland76> Did you have another better way to achieve the same thing?

[03:46] <wayland76> (and I'd happily agree that $.isListening is a bad name for it)

[03:46] *** agentzh left
[03:46] <wayland76> Ooh, maybe $.isListener (unless we can think of a better way to do it)

[03:47] <bacek_> wayland76: something like http://search.cpan.org/~chrmue/Socket-Class-2.02/Class.pm

[03:49] <wayland76> Which specific part do you like?  The way 'listen' gets passed as a parameter to .new() ?

[03:50] *** nacho joined
[03:55] * mncharity reads http://www.perlfoundation.org/perl6/index.cgi?oslo_perl_6_hackaton_2009

[03:55] <bacek_> wayland76: clear distinguish "local_addr" and "remote_addr"

[03:55] <bacek_> wayland76: because sockets has both

[03:56] <bacek_> wayland76: (for established connections)

[03:57] <wayland76> I agree

[03:58] <wayland76> It just means we probably need to move more stuff from IO::Socket::INET to IO::Socket

[03:59] <wayland76> No, I'm wrong

[04:00] <wayland76> It means that the roles/classes that implement IO::Socket need to format up the address properly

[04:00] <mncharity> maybe do an elf Q1 report this week.  see if there's any interest until Oslo ends.  then mothball elf if not.

[04:02] <mncharity> g'night all &

[04:02] *** mncharity left
[04:03] <wayland76> 'night

[04:03] <wayland76> bacek: Does that make sense?

[04:04] *** dukeleto left
[04:04] <wayland76> Another question; is IPv6 backwards compatible?

[04:05] <wayland76> ie. if I listen on port 80 with an IPv6 connection, will it hear IPv4 connections?

[04:05] <skids> There's an address prefix for IPV4 addresses within the IPV6 space, if that's what you are asking.

[04:06] <skids> No, you won't because it is a different proto id.

[04:07] <wayland76> Oh, that makes sense.  Thanks

[04:07] <skids> (on the level of GRE, etc.)

[04:07] <wayland76>  /etc/protocols :)

[04:07] <skids> Erm, I mean on the layer 2 level.  It'll be a different frame type.

[04:09] <skids> (as well, usually)

[04:12] *** agentzh joined
[04:17] *** c9s_ joined
[04:22] *** c9s__ joined
[04:22] <pugs_svn> r26032 | wayland++ | S32/IO: Made calls to .new() a bit more consistent with each other.  

[04:23] *** alester joined
[04:25] *** c9s_ left
[04:29] <pugs_svn> r26033 | wayland++ | S32/IO: Added a .new() method to IO::Socket::Unix

[04:29] <wayland76> bacek: Is that better?

[04:31] <wayland76> ( or bacek_ even :) )

[04:34] *** c9s left
[04:37] <bacek_> wayland76: no... "method open" is redundant and harmful.

[04:38] <wayland76> In what way?

[04:38] <bacek_> wayland76: technically each Socket holds pair of Sockaddr - local and remote. So, when you create Socket you specify one of them.

[04:39] <wayland76> Yes

[04:39] <bacek_> and the call to proper "listen" or "connect"

[04:39] <wayland76> I'd like to see a more consistent interface across the IO objects

[04:40] <bacek_> wayland76: imagine you writing simple httpd server. 

[04:40] <wayland76> Ok, imagining... :)

[04:40] <bacek_> And want to log remote IPs.

[04:40] <wayland76> Yes

[04:40] <bacek_> you have to have ability to fetch both "remote" and "local" prt from socket.

[04:40] <bacek_> parts

[04:40] <wayland76> yes

[04:41] <wayland76> As specified in IO::Socket::INET (btw, are you working from r26033?)

[04:42] <wayland76> Ie. assume we've created the listening socket, in $lsock

[04:42] <bacek_> so, I prefer to have "class Socket { has Sockaddr $.local; has Sockaddr $.remote }; 

[04:42] <skids> for that matter, udp, you don't even have a connection, and you can have a socket that accepts all src addresses (or one that doesn't)

[04:42] *** c9s joined
[04:42] *** araujo left
[04:42] <wayland76> $newsock = $lsock.accept(); log($newsock.RemoteAddr);

[04:42] <bacek_> and "new" will just accept one of this attributes

[04:43] <bacek_> my $newsock = Socket.new(local => Sockaddr("localhost", 80)); my $conn = $newsock.accept()

[04:44] <bacek_> Sockaddr.new rather

[04:45] <wayland76> You don't appear to have specified in any way that you want it to listen

[04:46] <wayland76> Or are you assuming that Local = listening and Remote = connecting?

[04:48] <bacek_> yes

[04:48] <wayland76> The equivalent in the syntax I suggested would be something like my $newsock = IO::Socket::INET.new(LocalHost => 'localhost', LocalPort => 80, Listener => MAXSOCKWHATEVER);

[04:48] <wayland76> What about the occasions where you want to specify both local and remote contact details?

[04:48] <bacek_> is bluetooth Socket::INET?

[04:49] <skids> How do you differentiate listen from connect when you specify both src and dst?

[04:49] <wayland76> Exactly my question :)

[04:49] <bacek_> local => sockaddr(...), remote => sockaddr(...)

[04:49] <bacek_> or LocalAddr => ..., RemoteAddr => ...

[04:50] *** nacho left
[04:50] <wayland76> But how do we know then whether it's listening or connecting?

[04:50] <bacek_> we dont.

[04:50] <bacek_> id depends on "connect" or "listen" call.

[04:50] <bacek_> it depends.

[04:51] <bacek_> so, "open" is redundant and harmful :)

[04:51] <wayland76> Well, but that's what I'm trying to get rid of :)

[04:51] <wayland76> Or connect and listen are :)

[04:52] <wayland76> I agree the default should be changed, though, so that not specifying remote contact details defaults to a listen as well

[04:53] <wayland76> Then the only conditions under which you'd have to specify $Listener is if you're specifying both local and remote addresses

[04:53] <bacek_> why defaults to listen???

[04:54] <skids> you can't connect without saying what to.

[04:54] <wayland76> Well, your point above was that, if people specify local contact details but not remote ones, then they probably want a listening socket

[04:54] <bacek_> it's explicitly specified

[04:55] <wayland76> Now I'm confused about what bacek_ is saying

[04:56] <wayland76> What is explicitly specified?

[04:56] <skids> I think bacek is too :-)

[04:56] <skids> Allow me to summarize:

[04:56] <bacek_> whet you pass "LocalAddr" you explicitly specifying that you want "Listen" on this port.

[04:56] <skids> bacek suggested ditching open for new; accept;

[04:57] <skids> then wayland asked how do we know when to listen

[04:57] <bacek_> new/listen :)

[04:57] <skids> Ah but you said new accept

[04:57] <wayland76> bacek_: No, I think when you don't specify RemoteAddr, *that* when you want to listen

[04:57] *** c9s__ left
[04:57] <skids> and thereby, the confusion ;-)

[04:58] <bacek_> wayland76: 50/50. So, only one way to distinguish - call "listen" or "connect"

[04:59] <wayland76> bacek_: I think we should call the appropriate one by default, and only require people to specify something when we can't figure it out

[05:02] <wayland76> Anyway, I'll modify the spec again, and then you can argue with the improved version

[05:02] <skids> I  think a one-shot call might have merit, but still people will want explicit control -- maybe keep open as a one-shot call, but specify it is only for simple use.

[05:02] <wayland76> And thanks to both of you for helping with this :)

[05:05] <skids> I don't think automatically calling listen or connect will be appreciated by some users, so it should not happen on new()

[05:05] <wayland76> skids: a one-shot call of what?

[05:05] <wayland76> Well, then they can pass the NoOpen parameter in :)

[05:05] <skids> one-shot as in create a socket and listen/connect

[05:06] <skids> So I have no real problem with open = create and listen or connect, new = setup but wait for user to listen/connect.  But I'm not necessarily saying that would be the best way.

[05:07] <pugs_svn> r26034 | wayland++ | S32/IO: Based on some suggestions of bacek++ and skids++, I refined the initialisation of 

[05:07] <pugs_svn> r26034 | wayland++ | the $.Listening attribute.  This may need more discussion though.  

[05:08] <wayland76> Anyway, I'm being called for food, but please feel free to continue this; I should be back in 20 minutes or so, and will backlog

[05:09] <wayland76> (I hope r26034 is a little more to your taste)

[05:17] *** dukeleto joined
[05:23] <wayland76> Actually, I've just realised that, while I'm back now, I'm going to have to leave in about 5 minutes

[05:26] <wayland76> Feel free to e-mail problems with IO.pod to p6l :)

[05:38] <wayland76> Ok, looks like I don't need to go away

[05:38] *** alester left
[05:39] *** zostay_ joined
[05:43] *** zostay left
[05:58] *** mjk joined
[06:14] <moritz_> good morning

[06:14] <lambdabot> moritz_: You have 1 new message. '/msg lambdabot @messages' to read it.

[06:14] <moritz_> I'll fix the links to the S32-* synopsis as soons as there's a HTML version of them

[06:15] *** c9s_ joined
[06:26] *** c9s left
[06:27] *** c9s_ is now known as c9s

[06:47] *** zostay joined
[06:47] *** zostay_ left
[06:49] *** justatheory left
[06:52] *** REPLeffect left
[06:57] <wayland76> moritz_: Ok, I'll try to remember to get to that

[06:59] *** REPLeffect joined
[07:02] *** ejs joined
[07:10] <moritz_> wayland76: good

[07:11] *** c9s left
[07:13] *** ejs left
[07:16] *** c9s joined
[07:22] <Matt-W> Morning

[07:23] *** goksie joined
[07:38] <mikehh> moritz_: hi - everything ok on Kubuntu Intrepid i386 - everything PASSes, unlike Ubuntu Intrepid Amd64

[07:42] *** |mjk| joined
[07:51] *** DemoFreak joined
[07:59] *** mjk left
[08:08] *** ejs joined
[08:09] *** bacek_ left
[08:11] *** |mjk| left
[08:13] *** ejs left
[08:14] *** ejs joined
[08:15] *** masak joined
[08:16] <masak> good early afternoon, Camelians.

[08:18] <moritz_> afternoon? :-)

[08:18] <moritz_> you're not in europe, are you?

[08:20] <masak> hm.

[08:20] <masak> meant late morning, actually.

[08:20] * masak hopes that puts him back in Europe

[08:22] <masak> ruoso: ping

[08:22] <Matt-W> it's 0922 in the UK

[08:22] <Matt-W> so the rest of europe can't really be much further ahead

[08:22] <masak> @ask ruoso what did you mean yesterday that roles should not be used for stateful things, like Closeable?

[08:22] <lambdabot> Consider it noted.

[08:26] <wayland76> masak: I can answer that :)

[08:26] <masak> ok.

[08:26] <wayland76> He meant that it's entirely possible for a readonly object to compose IO::Writeable

[08:27] <wayland76> That's why IO::Writeable has an isWriteable attribute

[08:27] <wayland76> Does that make sense?

[08:27] <masak> not really, I'm afraid.

[08:27] <wayland76> (sorry, a readonly IO file)

[08:28] <masak> it doesn't feel very elegant.

[08:28] <wayland76> Well, say you have a file that you have readonly permission to

[08:28] <eternaleye> Are you saying the object is readonly, but the backend it's attached to is writable?

[08:28] <wayland76> And you access it through an IO::File

[08:28] *** alexn_org joined
[08:28] <wayland76> IO::File *always* composes IO::Writeable, even though you may not be able to write to the file

[08:28] <eternaleye> nvm, I type slowly

[08:29] <wayland76> So if you ask whether an IO::File object does IO::Writeable, the answer is yes

[08:29] <wayland76> But if you write to a readonly file, it will throw an error

[08:30] <wayland76> That's why you do something like if($fileio.isWriteable) {...}

[08:30] <Matt-W> Doesn't that kind of defeat the object of having IO::Writeable as a role?

[08:30] <wayland76> No

[08:30] <wayland76> Now we're getting beyond questions that I can answer well, though.  Ask ruoso that one

[08:31] <wayland76> (although maybe it should be IO::ReadWriteable or something)

[08:34] <eternaleye> It souds like IO::Writable is anything that is /capable/ of being written to in at least one circumstance, but does not necessarily mean that writing is permitted in the current circumstance. Necessary, but not sufficient for writing.

[08:35] <masak> in other words, IO::Writable means that things are _possibly_ writeable.

[08:35] *** M_o_C joined
[08:35] <masak> it all makes more sense now.

[08:35] <wayland76> eternaleye: You got it (Travelling WIlburys)

[08:36] <wayland76> And ruoso no doubt reminded me because I keep forgetting :)

[08:40] <eternaleye> Perhaps a simplified way to explain it in the future is that IO::Writable defines "Can I write?" while isWritable defines "May I write?" - This should make it really easy for grammarians

[08:41] <wayland76> Ooh.  Perl already had magic, now it has grammarye

[08:41] <Matt-W> hahaha

[08:41] <Matt-W> wayland++

[08:41] <eternaleye> All we need is a chicken and two goats.

[08:42] <masak> @tell ruoso nvm, wayland76++ clarified satisfactorily.

[08:42] <lambdabot> Consider it noted.

[08:44] *** c9s_ joined
[08:46] *** c9s left
[08:47] *** kimtaro_ joined
[08:48] *** alexn_org left
[09:00] *** cognominal left
[09:00] *** M_o_C left
[09:02] *** c9s_ left
[09:04] *** c9s joined
[09:04] *** kimtaro left
[09:24] *** cognominal joined
[09:26] *** renormalist joined
[09:29] *** araujo joined
[09:31] *** PZt left
[09:34] *** amoc joined
[09:38] *** kimtaro joined
[09:44] *** payload left
[09:46] *** renormalist left
[09:56] *** kimtaro_ left
[10:01] *** c9s_ joined
[10:05] *** c9s left
[10:07] *** amoc left
[10:26] *** finanalyst joined
[10:26] <finanalyst> ruoso: ping

[10:27] <finanalyst> pmurias: ping

[10:27] *** grwi joined
[10:27] *** grwi left
[10:27] *** kimtaro left
[10:37] *** xinming_ is now known as xinming

[10:55] *** kimtaro joined
[10:57] *** pmurias joined
[11:11] <ruoso> finanalyst, pong

[11:11] <lambdabot> ruoso: You have 2 new messages. '/msg lambdabot @messages' to read them.

[11:12] <pmurias> ruoso: hi

[11:13] <pugs_svn> r26035 | pmurias++ | [mildew] added a snapshot of STD in perl6-snapshot

[11:18] <ruoso> hi pmurias 

[11:20] <pmurias> ruoso: i'm wondering if a have native and s1p in Perl 6 scheme would work if we had a simplified version of p6opaque and a way to use C functions with a Inline-style interfacee

[11:20] *** goksie left
[11:20] *** goksie joined
[11:21] <ruoso> pmurias, well... a simplified version of p6opaque is a C structure (since you're generating code...)

[11:21] <pmurias> that what i was thinking about

[11:21] <ruoso> but the inline-style C interface is doubtless interesting...

[11:21] <ruoso> I'm not sure how to make STD support it tho

[11:22] <pmurias> STD parses =begin DATA

[11:24] <ruoso> hmmm... I was expecting something more on the line of a quote modifier... but if that works

[11:25] <pmurias> wouldn't a quote modifer suggest quasi-quoting C?

[11:25] <ruoso> but you don't need to actually parse the C code

[11:26] <pmurias> we could even use use Inline C => '...'

[11:26] <ruoso> you can simply look for the closing brace

[11:26] <pmurias> ruoso: i can parse the C code with some haskell thing

[11:26] <ruoso> but the point is that you don't need to

[11:26] <pmurias> so that it gets signatures generated for it

[11:27] <ruoso> Ah... you mean having a different grammar for the entire file

[11:28] <ruoso> hmm....

[11:28] <pmurias> i'm more thing of it like mildew recognising use Inline C => 'code' and exposing all the function there to Perl 6 code

[11:29] <ruoso> you mean...

[11:29] <ruoso> method foo($a,$b,$c) { use Inline C =>  '...' } ?

[11:29] <pmurias> yes

[11:30] <ruoso> the pod directive seems a better idea

[11:31] <pmurias> we could alternativly keep the C code in a different file

[11:35] <ruoso> you know... there isn't really many files written in C+mold

[11:36] <ruoso> maybe just adding signature support to the RI DSL already saves a great deal of work

[11:36] *** wayland76 left
[11:36] *** wayland76 joined
[11:41] <pmurias> ruoso: maybe you're right, we should consider it seperatly from the refactoring anyway

[11:42] <ruoso> probably a sane idea

[11:42] <ruoso> let's just finish this refactoring, then we think on the next refactoring

[11:47] <pugs_svn> r26036 | pmurias++ | [re-smop] moved over lowdoc/02_interpreter.pod

[11:48] <pmurias> ruoso: do we need native uint in re-smop?

[11:49] <ruoso> well... the spec defines it...

[11:50] <pmurias> as well as 14 other int types

[11:53] <pmurias> perl6: say 1.new;

[11:53] <p6eval> elf 26036: OUTPUT«Can't locate object method "Str" via package "1" at ./elf_h line 752.␤ at ./elf_h line 5881␤»

[11:53] <p6eval> ..pugs: OUTPUT«<obj:Int>␤»

[11:53] <p6eval> ..rakudo c01555: OUTPUT«0␤»

[11:53] <pmurias> perl6: say 1.new("7");

[11:53] <p6eval> elf 26036: OUTPUT«Odd number of elements in anonymous hash at ./elf_h line 19.␤Can't locate object method "Str" via package "1" at ./elf_h line 752.␤ at ./elf_h line 5881␤»

[11:53] <p6eval> ..pugs: OUTPUT«*** Must only use named arguments to new() constructor␤    Be sure to use bareword keys.␤    at /tmp/JY4oV2Mazv line 1, column 5-15␤»

[11:53] <p6eval> ..rakudo c01555: OUTPUT«0␤»

[11:53] <pmurias> perl6: say 1.new(7);

[11:53] <p6eval> elf 26036: OUTPUT«Odd number of elements in anonymous hash at ./elf_h line 19.␤Can't locate object method "Str" via package "1" at ./elf_h line 752.␤ at ./elf_h line 5881␤»

[11:53] <p6eval> ..rakudo c01555: OUTPUT«0␤»

[11:53] <p6eval> ..pugs: OUTPUT«*** Must only use named arguments to new() constructor␤    Be sure to use bareword keys.␤    at /tmp/qMMQKPTTti line 1, column 5-13␤»

[11:57] *** jogla joined
[11:58] <ruoso> pmurias, beware that by using 1.new, yuo're kinda autoboxing to the Int type, and calling new on it instead...

[12:00] *** c9s_ is now known as c9s

[12:09] *** msmatsko_ left
[12:09] <pmurias> ruoso: i'm removing .new from int

[12:09] <ruoso> right... it seems a bit pointless

[12:10] <ruoso> eventually we make it delegate the method calls to Int

[12:12] <pmurias> do we still seperate *_mold_init and *_mold_destr from *_init and *_destr?

[12:12] <ruoso> hmmm

[12:13] <ruoso> I hope we have solved the dependency issues

[12:13] <ruoso> so, in theory, there should be no need to make them separated

[12:16] *** OuLouFu left
[12:16] <pmurias> walk&

[12:17] *** Guest50274 left
[12:18] *** dKingston joined
[12:27] <pugs_svn> r26037 | ruoso++ | [re-smop] update lowdoc/02_interpreter.pod according to the refactoring, basically fixing nomenclature.

[12:28] *** skids left
[12:33] *** smtms left
[12:37] *** mberends joined
[12:40] *** orafu joined
[12:46] *** alester joined
[12:46] *** alester left
[12:48] * masak misuses $^param variables in subs

[12:49] * Matt-W gasps in horror

[12:50] <moritz_> rakudo sub f { say $^x }, f(3)

[12:50] <moritz_> rakudo: sub f { say $^x }, f(3)

[12:50] <p6eval> rakudo c01555: OUTPUT«3␤»

[12:50] <masak> rakudo: sub foo { my $a = 5; say $^a }; foo(7)

[12:50] <moritz_> that shouldn't work

[12:50] <p6eval> rakudo c01555: OUTPUT«5␤»

[12:50] <masak> that shouldn't either, I think.

[12:50] <moritz_> only blocks should have implict parameters, no?

[12:50] <masak> so what do I do now? submit two rakudobugs?

[12:51] <masak> moritz_: a sub has a block.

[12:51] <moritz_> masak: but it has a signature on its own

[12:51] <moritz_> anyway, not sure

[12:51] <masak> p6l?

[12:51] <moritz_> maybe look it up in the synopsis first :-)

[12:51] * masak looks

[12:51] <ruoso> moritz_, I'm not sure that's entirely true

[12:51] <ruoso> moritz_, sub foo { } has an implied signature

[12:52] <ruoso> but having $^a there might imply a different

[12:52] <masak> man, coding Perl 6 is so much better than working.

[12:52] <moritz_> masak: indeed

[12:53] <masak> I've learned to like the uncertainness surrounding many constructs in Perl 6.

[12:53] <masak> trying out new things means that the synopses shift a little.

[12:54] <masak> in a sense, I wish all languages worked like that. :P

[12:54] * masak discovers that placeholder variables can be written with a colon

[12:54] <masak> wtf! when did this happen? :)

[12:55] <masak> ah, they are named placeholders.

[12:56] <masak> "Placeholders may also be used in method bodies that have no formal signature."

[12:56] <masak> (from S06)

[12:56] <moritz_> ah, ok

[12:56] <masak> one might argue that excepting subs would then be a strange exception.

[12:57] <moritz_> rakudo: sub f() { $^a.say }; f(2)

[12:57] <p6eval> rakudo c01555: OUTPUT«Cannot use placeholder var in block with signature. at line 1, near ".say }; f("␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[12:57] <moritz_> rakudo++

[12:57] <moritz_> and masak++ for investigating

[12:57] <masak> still, what about my last one-liner?

[12:57] <masak> the one where I used $a first and then $^a?

[12:57] <moritz_> that looks... wrong

[12:57] <masak> aye.

[12:58] <masak> bug reporting time.

[12:58] <moritz_> it seems that initialization happens at the wrong time (which we also found in another block involving eval)

[12:58] <moritz_> rakudo: eval 'say $f'; my $x = 3;

[12:58] <p6eval> rakudo c01555: RESULT«3»

[12:59] <moritz_> that's wrong, it should first run the eval, then do the assignment

[12:59] <moritz_> so it should print an undef really

[12:59] <moritz_> (but we have a ticket for that already)

[13:00] <masak> aye.

[13:01] <masak> moritz_: I'm very mystified by that behavior.

[13:01] <masak> ah.

[13:01] <masak> the 3 comes from the last assignment.

[13:01] <masak> that explains it.

[13:01] <masak> nvm.

[13:01] * moritz_ never minds

[13:02] <masak> rakudo: eval 'say $x'; my $x = 3; say "OH HAI"

[13:02] <p6eval> rakudo c01555: OUTPUT«OH HAI␤»

[13:02] <masak> moritz_: I think that ticket is bogus.

[13:02] <masak> do you have its number?

[13:02] <moritz_> no idea

[13:02] * masak goes looking

[13:02] <moritz_> why do you think it's bogus?

[13:03] <moritz_> it was TimToady who said it's  wrong :-)

[13:03] <Matt-W> that eval shouldn't compile!

[13:03] <moritz_> it should

[13:03] <masak> moritz_: because I try to reproduce it above, and I don't succeed.

[13:03] <Matt-W> there's no $x for it to use

[13:03] *** Khisanth joined
[13:03] <masak> let me just find the bug ticket...

[13:03] <moritz_> Matt-W: yes, but the declaration of $x happens at compile time...

[13:03] <Matt-W> so it can see the $x that's declared *after* it when it comes to runtime?

[13:03] <moritz_> Matt-W: and at run time the eval only asks if there is an $x declared in the current block

[13:04] <Matt-W> ouch

[13:04] <masak> #64010.

[13:04] <moritz_> it's actually a very sane behaviour

[13:04] <masak> yup, it's bogus.

[13:04] <Matt-W> how is that sane?

[13:04] <moritz_> otherwise eval would have to track its caller's position in the source file

[13:04] <masak> you're all being misled by p6eval's behavior when you don't print something to STDOUT.

[13:05] <moritz_> omg

[13:05] <masak> marking ticket as bogus.

[13:05] <moritz_> masak++

[13:05] <masak> moritz_: IMO, turn off that behavior on p6eval.

[13:05] <Matt-W> I'm not interested in implementation requirements

[13:05] <masak> it's only confusing.

[13:05] <Matt-W> I'm interested in why it's a good thing in the language

[13:05] <moritz_> masak: I should, yes

[13:06] * moritz_ notes it on his todo

[13:06] <moritz_> for tonight, that is

[13:06] <masak> great.

[13:07] <masak> I liked the old behaviour better, when it said "you oughta print something, DUH"

[13:07] <masak> or equiv.

[13:07] <Matt-W> <<No output.>>

[13:07] <masak> that works too.

[13:09] <Matt-W> It's slightly less insulting :)

[13:10] <masak> aye.

[13:11] *** meppl joined
[13:13] <masak> moritz_: so, you have Perl 6 time planned for tonight? me too. I plan to hack on November.

[13:13] <moritz_> perl 6 spoiled me. Now I want to write obj.method_without_args.other_method in C++ as well :-)

[13:13] <Matt-W> Me too

[13:13] <moritz_> masak: actually I have some time planned to implement an april's fool joke for the 80+ machines I'm administrating

[13:14] <literal> you can still do it in Ruby :P

[13:14] * Matt-W is hoping to do a bit of Form, but has a recorder lesson

[13:15] *** smtms joined
[13:21] *** jan_ joined
[13:22] * moritz_ just sped up a program from 7 min 35s to 35s

[13:23] <masak> optimized away the '7 min' part? :P

[13:23] <moritz_> right

[13:24] <moritz_> git commit -m 'it can be faster, you suckers' :-)

[13:25] <Matt-W> did you find the line that said "sleep" and take it out?

[13:25] <moritz_> I found out how to solve an equation system only for non-zero rows :-)

[13:25] <Matt-W> :)

[13:26] <masak> ah, those non-zero rows.

[13:26] <masak> I should have thought of that.

[13:27] <Matt-W> Maths-based optimisation ftw

[13:27] <moritz_> you should indeed, and you have told me so in the first place :-)

[13:29] *** Khisanth left
[13:31] *** skids joined
[13:36] *** Schmidt left
[13:39] <pugs_svn> r26038 | pmurias++ | [re-smop] ported over native int

[13:39] *** ivantis joined
[13:39] <krunen> ls

[13:40] <krunen> argh!

[13:40] <ivantis> zomg perl6 doesnt have $ ?

[13:41] <pmurias> perl6 has sigils

[13:41] <ivantis> in #perl someone just asked if we would lose $ @ and %

[13:41] <ivantis> they mean different things?

[13:41] <ivantis> perl6 is a scary language

[13:44] <moritz_> they are slightly different

[13:44] *** rgs left
[13:44] <pmurias> ivantis: $foo->{'foo'} turned into $foo{'foo'} and $foo{'bar'} turned into %foo{'bar'}

[13:44] <moritz_> if you have an array @a, you access a single item with @a[0], not with $a[0] as in Perl 5

[13:45] <masak> ivantis: I agree that Perl 6 is a scary language. that doesn't stop me from liking it a lot, though.

[13:45] <pmurias> ivantis: btw $foo<foo> is an other way to write $foo{'foo'} in Perl 6

[13:45] <ivantis> this sounds more like perl to php, not perl next version

[13:45] <masak> ivantis: why?

[13:46] <moritz_> php doesn't have % and @ as sigils at all

[13:46] <moritz_> rakudo: my @a = <foo bar baz>; say @a[1];

[13:46] <ivantis> yeah, but so different

[13:46] <p6eval> rakudo c01555: OUTPUT«bar␤»

[13:46] <masak> right. PHP kept the $ sigil, but forgot about its meaning.

[13:46] <moritz_> that more perlish than PHPish to me :-)

[13:46] <ivantis> oh arent you guys cool, got your own evalbot

[13:46] <masak> ivantis: I think that if Perl 6 turned to PHP, many of us would have noticed. :)

[13:47] <masak> ivantis: yah, neat, innit? :)

[13:47] <ivantis> so instead of using $ for arrays and hashes, @ and % are used, even for individual references?

[13:47] <ivantis> kind of makes sense

[13:48] <moritz_> the sigils are now tied to the variable, not to the return value

[13:48] <masak> ivantis: aye. same as in Perl 5, except even more consistent.

[13:48] <moritz_> it confused a great many perl 5 beginners, for sure :-)

[13:48] <masak> it's a nice idea gramatically...

[13:48] <moritz_> including me, that is :-)

[13:49] <masak> ...but maybe it doesn't carry its own weight.

[13:49] <Matt-W> It confused us all to start with

[13:49] <Matt-W> But it's minor next to the really awesome stuff in Perl 6 :)

[13:49] <masak> I don't think I've ever been confused by it. just annoyed at times.

[13:49] <Matt-W> Well let's just say it took me a while to get my head around it

[13:49] <Matt-W> But then I read Programming Perl

[13:50] *** goksie left
[13:50] <ivantis> is there a new system binary for perl6 on linux and stuff?

[13:50] <Matt-W> All the current implementations are new programs, so yes

[13:51] <Matt-W> There may at some point be one that can handle Perl 5 and Perl 6, but we don't have one at the moment

[13:52] <ivantis> why not just an option, like -v 6 on the shebang line?

[13:52] <skids> Cause we gots us some plans for that there commandline :-)

[13:52] <Matt-W> Because the Perl 6 runtime is completely different

[13:53] <masak> ivantis: Perl 6 is in parts the next version, in parts a whole new language.

[13:53] *** goksie joined
[13:53] <moritz_> ivantis: the idea is that a binary called 'perl' (without version number) defaults to perl 5, and switches to Perl 6 as soon as it sees 'use v6' or 'class' or 'module'

[13:54] <PerlJam> masak: I like what is I think Larry's analogy:  If I have my face reconstructed (say I was in a bad wreck), am I not the same person?  

[13:54] <masak> ivantis: if you'd like to give Perl 6 a try on your computer, I'd recommend downloading Rakudo. http://rakudo.org/

[13:54] <literal> moritz_: what about "grammar" did they add that one as well?

[13:54] <masak> PerlJam: indeed.

[13:54] <Matt-W> Perl 6 has a thing called grammars

[13:54] <moritz_> literal: don't remember

[13:55] <jnthn> OH HAI I haz return from trip.

[13:55] <masak> Matt-W: that wasn't the question. :)

[13:55] <Matt-W> OH HAI jnthn

[13:55] <masak> jnthn: OH HAI

[13:55] <moritz_> OH HAY jnthn welcome back :-)

[13:55] <Matt-W> masak: yes I just realised I misread

[13:55] <Matt-W> masak: give me some slack, I'm trying to have this conversation at the same time as reviewing some C++

[13:56] <masak> Matt-W: no slack for you! get in the back of the line. :)

[13:56] *** exodist joined
[13:56] <Matt-W> literal: I think 'grammar' does trigger perl 6 since it's really just a kind of class...

[13:56] * PerlJam misreads and gives Matt-W some flak instead  

[13:56] <PerlJam> ;-)

[13:56] <literal> Matt-W: yeah, it should

[13:57] <Matt-W> jnthn: Was it a good trip?

[13:57] <Matt-W> literal: if it doesn't, we should demand a good reason :)

[13:57] <jnthn> Matt-W: Yes, seeing some family and also some friends from uni who live in a similar area of the UK.

[13:57] <jnthn> Managed to eat substantial amounts of curry.

[13:58] <Matt-W> Hurrah

[13:58] <Matt-W> You weren't in Birmingham, by any chance?

[13:58] <Matt-W> Has a reputation for curry it seems

[13:59] <jnthn> Matt-W: Not in Birmingham, but not far off.

[13:59] <jnthn> Nottingham first, and then Dudley area.

[13:59] <Matt-W> Although come to think of it, the one time I went there I ate no curry at all

[13:59] <Matt-W> Aaah right

[13:59] * Matt-W lives in Nottingham

[13:59] <jnthn> I have had great curry in Birmingham too, however.

[13:59] <jnthn> OH RLY?

[13:59] <Matt-W> yes rly :)

[14:00] <Matt-W> Came to uni and neglected to leave

[14:01] *** ron_ joined
[14:01] *** kimtaro left
[14:02] <ron_> rakudo: say 102030405.split(0).perl;

[14:02] <p6eval> rakudo c01555: OUTPUT«["1", "2", "3", "4", "5"]␤»

[14:03] <masak> rakudo: say reverse ~ [*] 1..4

[14:03] <p6eval> rakudo c01555: OUTPUT«42␤»

[14:03] <masak> rakudo: say reverse [*] 1..4

[14:03] <jnthn> Matt-W: Next time I'm visiting similar folks, we should try and catch a beer or whatever $beverage you prefer. :-)

[14:03] <p6eval> rakudo c01555: OUTPUT«Parameter type check failed for $delimiter in call to split␤current instr.: 'die' pc 15621 (src/builtins/control.pir:204)␤»

[14:03] * masak doesn't know whether that last one is a bug

[14:03] <jnthn> It's...not too dwimmy.

[14:03] <Matt-W> jnthn: Absolutely

[14:03] <ron_> Looking at rt (59184 http://rt.perl.org/rt3/Public/Bug/Display.html?id=59184) and the current tests in t/spec/S32-str/split-simple.t and wondering why the ticket is still open.

[14:03] <masak> jnthn: my thought exactly.

[14:04] <masak> ron_: I'll close it. thanks.

[14:05] * jnthn spots that Padre now has the ability to write plug-ins in Perl 6. That's cool.

[14:07] <masak> ron_: there are likely many other open tickets in RT right now which could be closed or merged. thanks for spotting this one.

[14:07] <masak> ron_++

[14:09] <ron_> Is there anything different to be done at this point if someone comes across one?

[14:09] <masak> ron_: in my opinion, only those tickets that are still valid should be open. does that answer your question?

[14:10] <ron_> gooe enough :)

[14:10] <ron_> s/gooe/good/

[14:11] <finanalyst> ruoso: ping

[14:11] <ruoso> finanalyst, pong

[14:11] <finanalyst> ruoso: still trying to get smop to work

[14:11] <ruoso> right...

[14:12] <ruoso> have an svn update

[14:12] <ruoso> pmurias had put a working snapshot of STD inside mildew source

[14:14] <finanalyst> will get new copy

[14:14] <ruoso> by new copy you mean make a svn update

[14:14] <ruoso> right?

[14:18] *** ron_ left
[14:21] <finanalyst> ruoso: right

[14:21] <finanalyst> just updated, but problems again

[14:22] <finanalyst> after make in smop, a failed test is reported

[14:23] <finanalyst> going to ../mildrew and perl ./mildew example/sdl.pl indicates I dont have STD

[14:25] *** brunoV joined
[14:25] <ruoso> rm -rf lex CORE.pad.store

[14:26] <ruoso> hmm... 

[14:26] <ruoso> pmurias, example/sdl.pl doesn't seem to be working...

[14:29] *** dKingston left
[14:31] *** justatheory joined
[14:34] *** dKingston joined
[14:35] *** ron_ joined
[14:40] <pugs_svn> r26039 | pmurias++ | [mildew] updated example/sdl.pl

[14:42] <pasteling> "finanalyst" at 193.110.4.137 pasted "getting SMOP running" (45 lines, 2.5K) at http://sial.org/pbot/35779

[14:42] <finanalyst> ruoso: could you look at the nopaste

[14:45] <masak> I tell you, with tests I discover bugs that I couldn't even dream was in my codebase. and I'm not even doing TDD -- most of the code is already written.

[14:45] <dalek> rakudo: 5374f73 | pmichaud++ | docs/spectest-progress.csv:

[14:45] <dalek> rakudo: spectest-progress.csv update: 339 files, 8039 passing, 0 failing

[14:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5374f7354fcb5a3c40d35e1b33fc7aa2d87fbc06

[14:49] <pmurias> finanalyst: run make in perl6-snapshot

[14:49] *** Tene_ joined
[14:51] *** mberends left
[14:54] <jnthn> Over 8,000?!

[14:55] <[particle]> yep, day 2 at 8000+

[14:56] <finanalyst> pmurias: is perl6-snapshot going to be permanent?

[14:56] <jnthn> More Perl 5 regex support?

[14:57] <pmichaud> moritz++  found quite a bit of passing tests in the spectest suite, I think.

[14:57] <jnthn> Nice

[14:57] <jnthn> moritz++ :-)

[14:58] <masak> jnthn: is there a Rakudo day this week?

[14:58] <jnthn> pmichaud: Any preferences when I do Rakudo day or anything particularly you want me to look at this week?

[14:58] <pmichaud> jnthn: no preferences -- all days are about equal here

[14:58] <jnthn> OK

[14:58] <jnthn> Maybe will make it Thursday.

[14:58] <pmichaud> Tene++ wants us to think more about .leave

[14:59] <jnthn> Thursday is normally not so good, but this week it turns out it is because the thing that normally makes it less good is happening on a Wednesday... :-)

[14:59] <pmichaud> Thursday should be okay here.

[14:59] <jnthn> Ah, OK.

[14:59] <pmichaud> Currently Tene has an implementation of .leave using exceptions.... but I'm not convinced that's the correct model.  I think we should perhaps be invoking continuations.

[14:59] <pmichaud> But we can discuss on Rakudo day.

[14:59] <jnthn> Sure

[15:00] <jnthn> I have been down the continuation route with it as an experiment too.

[15:00] <jnthn> And found it wasn't all as nice and clean as I'd hoped. :-(

[15:01] <jnthn> (Because of differences in the way the calling conventions error check return values vs parameters being passed.)

[15:01] *** hercynium joined
[15:01] <jnthn> (We get the second semantics when we actually want the first.)

[15:01] <pmichaud> one can't just invoke the (return) continuation with the values to be returned as params?

[15:02] *** lambdabot left
[15:02] <jnthn> Well, it becomes a full continuation as soon as you get hold of it from interpinfo/ParrotInterpreter PMC

[15:02] <jnthn> And then when you invoke it with the return values, it treats it a bit like a call.

[15:03] <pmichaud> so do we need a way to get at it without promoting it to a full continuation?

[15:03] <jnthn> Having looked at the invoke vtable method of RetContinuation too, I'm not sure that helps either.

[15:03] <jnthn> It basically boils down to

[15:03] <jnthn> $P0 = 'foo'()

[15:03] <jnthn> 'foo'()

[15:03] <jnthn> In both of those, it's completley OK for foo to have a .return (42)

[15:03] *** nihiliad left
[15:04] <jnthn> In the second case, the fact that there's an unused return value is ignored by the calling conventions.

[15:04] *** nihiliad joined
[15:04] <jnthn> On the other hand, failing to pass a parameter (that isn't marked :optional) is an error.

[15:04] *** lambdabot joined
[15:04] <pmichaud> got it.

[15:04] <[particle]> it's a flag setting in imcc to ignore unused return values

[15:04] <jnthn> And the problem comes up because when you invoke the continuation it is doing the error check.

[15:04] <[particle]> s/unused/mismatched/

[15:05] <jnthn> [particle]: Maybe indirectly.

[15:05] <jnthn> [particle]: But the real difference is in the way you call parrot_pass_args

[15:05] <jnthn> (specifying call or return semantics)

[15:05] <[particle]> the idea has been to enable mismatched return value detection, but at the time (2+ years ago) it required so many code/test/hll changes, it wasn't done

[15:06] <jnthn> I did hack Continuation PMC just to make sure this is what the issue was, and it is this.

[15:06] <jnthn> However (and I confirmed with allison, but suspected anyway) that's not really the right way to fix it.

[15:06] <[particle]> since parrot is cps, we could get rid of all the return calls and just use invoke

[15:06] *** Tene left
[15:06] <pmichaud> return calls are invoke.

[15:07] <jnthn> Aye.

[15:07] <pmichaud> .return is just syntactic sugar around an invoke.

[15:07] <[particle]> i mean, the silly second path through the pcc

[15:07] <jnthn> It's the ivoke vtable meth that gets called.

[15:07] <jnthn> I'd imagine all it changes is what error checks are done.

[15:07] <jnthn> So it's not an extra path as such.

[15:08] *** Patterner left
[15:08] <jnthn> Also, if you make mismatched return values an error, we're going to have to go fix all kinds.

[15:08] *** Psyche^ joined
[15:08] <[particle]> right, which is why it was never done

[15:08] <jnthn> since sub foo { 42 }; foo(); # is valid

[15:08] *** Psyche^ is now known as Patterner

[15:08] <pmichaud> the major difference between   .return   and a normal invoke is that a normal invoke uses  set_args   while .return uses set_return

[15:09] <[particle]> right.

[15:09] <[particle]> and the pir compiler could recognize invoke in void context and create slurpy unused registers

[15:09] <pmichaud> so what we'd really want is a way to invoke a continuation using set_return instead of set_args

[15:10] <pmichaud> ooh!  ooh!

[15:10] <pmichaud> this sounds very much like the patch that chromatic was working on for me that would do lazy :slurpy

[15:10] *** kane_ joined
[15:10] <pmichaud> i.e., that could avoid creating the slurpy PMC if it wasn't needed/used.

[15:14] *** ivantis left
[15:14] <jnthn> That sounds like a useful patch. :-)

[15:15] <pmichaud> In all of the other stuff happening at the time (moving rakudo out of parrot repo) I never got a good chance to play with it much.

[15:15] <jnthn> pmichaud: It did also occur to me, that we can write our own dynpmc that gives us completely lazy binding semantics...

[15:16] <pmichaud> this is still for .leave?

[15:16] <pmichaud> that seems reasonable/workable also. (more)

[15:16] <pmichaud> but in some sense we keep coming up on Parrot calling convention roadblocks.

[15:16] <jnthn> No, this is for avoiding using much of Parrot's calling convention implementation.

[15:16] <pmichaud> and I fear that if we do workarounds it just means that Parrot will never get fixed.

[15:17] <jnthn> That or it'll be like "oh, their workaround is how we shoulda done it in the first place" ;-)

[15:17] <pmurias> finanalyst: perl6-snapshot will be updated

[15:17] <finanalyst> pmurias: smop still not working for me

[15:18] <pmichaud> well, if we do a workaround with the expectation that it eventually gets adopted by Parrot, that doesn't bug me quite so much.

[15:18] <finanalyst> pmuria: I have scons: *** Cannot duplicate `test/03_const_identifier.c' in `build-tests': None.  Stop.

[15:18] <[particle]> it has always been a goal for parrot calling conventions to support p6 calling semantics natively

[15:19] <pmichaud> [particle]: I agree it's a goal.  What I don't know is when that goal might be reached.

[15:19] <jnthn> pmichaud: I think that it might at the very least help Parrot get where we'd like it to be.

[15:19] <[particle]> yep

[15:19] <pmichaud> jnthn: I agree with that.

[15:19] <[particle]> i agree with jonathan there

[15:20] <pmichaud> so, basically we'd have our own mmd, our own calling conventions, etc.?

[15:20] <pmichaud> independent of what Parrot implements?

[15:20] <masak> rakudo: class A { has $.f; method new($.f) {} }; my A $a .= new(5); say $a.f # I've asked this before, but what do I need to write inside the 'new' method body to make this work?

[15:20] <p6eval> rakudo 5374f7: OUTPUT«Type mismatch in assignment.␤current instr.: 'die' pc 15621 (src/builtins/control.pir:204)␤»

[15:20] *** ejs left
[15:21] <pmurias> finanalyst: try removing build-tests,that's a strange error

[15:21] <pmichaud> rakudo:  class A { has $.f; method new($x) { $!f = $x } };  my A $a .= new(5);  say $a.f;   # perhaps this?

[15:21] <p6eval> rakudo 5374f7: OUTPUT«Null PMC access in getprop()␤current instr.: 'infix:=' pc 13861 (src/builtins/assign.pir:21)␤»

[15:21] *** dKingston left
[15:21] <masak> pmichaud: I've a feeling I must return a newly-created A object.

[15:22] <jnthn> pmichaud: I didn't think it through in huge detail yet. If anything, I planned to keep the caller side the same everywhere. Because actually it's the callee that does get_params and that is what invokes the calling conventions. And basically rather than just going through those to get the arguments we'd hand back some lazy data structure that pulls them "on demand". However, I didn't get to thinking a load beyond that just yet...and really it may just tur

[15:22] <masak> jnthn: clipped message.

[15:22] *** dKingston joined
[15:22] <masak> jnthn: '...may just tur'

[15:22] <jnthn>  may just turn out to be too ugly to do.

[15:23] <jnthn> And the tuits would be better spend in Parrot guts instead.

[15:23] <pmichaud> I'm fine with the callee revising get_params.  Ideally from a Rakudo perspect, it would be great if the callee could bind the arguments to lexicals directly (and immediately)

[15:23] <pmichaud> instead of relying on the PIR to do it.

[15:24] <jnthn> pmichaud: Well, part of me got thinking, "hey, signature bind maybe should become a dynop one day for speed"

[15:24] <pmichaud> agreed, that's been my expectation.

[15:24] <jnthn> And then it wasn't a huge step to "and thus we needn't bother with the callee side of PCC"

[15:26] <pmichaud> so, coming back to .leave ... what should we do there?

[15:27] <jnthn> Well, it depends if the spec is going to say that leave is a control exception that you'd expect to be able to catch

[15:27] *** amoc joined
[15:27] <pmichaud> I think the spec says it's _not_ an exception.

[15:27] <jnthn> OK.

[15:28] <jnthn> The other thing about implementing it was an exception is that we do need to unwind the stack.

[15:28] <jnthn> And call any block exit handlers etc.

[15:28] *** Khisanth joined
[15:29] <jnthn> While in some senses the "just invoke the return continuation" model appeals to me, I don't see such a neat way to make sure we call all of those.

[15:29] <pmichaud> well, we really need block exit handlers.

[15:29] <pmichaud> I know we had them at one time.

[15:29] <pmichaud> but we need block exit handlers for a lot of things -- so we can unwind various actions that may have occurred (e.g., 'temp' variables)

[15:30] <pmichaud> iirc, Bob Rogers was using Parrot's block exit handlers to do such unwinding... but then allison said those features were going away.

[15:31] <jnthn> Have they gone away, or are they just going away?

[15:31] *** plash joined
[15:32] <pmichaud> "going away" is my guess.

[15:32] *** frioux_away left
[15:32] <jnthn> OK. Maybe we should ask what replaces them.

[15:32] <pmichaud> I'd have to go look at the historical logs a bit to see if I can find them out.  But the issue came up as part of the exceptions refactor.

[15:32] <pmichaud> I think Bob asked what replaced them but didn't get an answer.  Or maybe I just didn't see the answer.

[15:33] <jnthn> I don't remember an answer either.

[15:34] <jnthn> Anyway, if we are expecting a Parrot-level solution for the unwinding, then the argument taht it'd be easier to handle this with exceptions maybe holds less.

[15:37] <pmichaud> using exception handlers to do unwinding just feels wrong to me.

[15:37] <pmichaud> in particular because exceptions typically _don't_ unwind the stack :-|

[15:39] <jnthn> Aye

[15:39] <jnthn> In that case, perhaps trying to fix up the continuations stuff to do what we want instead is the way to go.

[15:39] <jnthn> And hopign whatever Parrot's block exit handler solution is works.

[15:39] <pmichaud> especially since I think we could get a big number of other optimizations out by doing so.

[15:39] <jnthn> Yes, good point.

[15:40] <pmichaud> if we had a real .leave that unwinds things, then the standard 'return' semantics (esp for other languages) could be less exceptional.

[15:40] <jnthn> *nod*

[15:41] <pmichaud> another question I've late lately is trying to figure out the meaning of 'want' in Perl 6

[15:41] <pmichaud> s/late/had/

[15:41] <jnthn> Ah, I was hoping you did understand that, because I don't. :-)

[15:43] <finanalyst> ruoso: ping

[15:44] <finanalyst> pmurias: ping

[15:45] <jnthn> pmichaud: I think part of it may well be about the bigger question of how we handle multiple return values too.

[15:45] <jnthn> And probably needs to be considered and answered in part of working that out.

[15:45] *** finanalyst left
[15:45] <jnthn> IIRC, there was some lingering questions there too.

[15:45] <pmichaud> well, multiple return values doesn't cause me as much grief, actually.  I somewhat understand how the notion of Capture works there.

[15:45] <jnthn> OK.

[15:46] <pmichaud> but with the exception of assignment, I'm not sure I can deduce context in many situations.

[15:46] <jnthn> Same.

[15:47] <jnthn> I guess I should re-read the spec on it.

[15:47] <jnthn> And review the tests that exist etc.

[15:47] *** finanalyst joined
[15:47] <jnthn> But yes, I've not had any eureka moments at all on want.

[15:50] *** frioux_ joined
[15:52] *** ron_ left
[15:52] <pmichaud> okay, we'll need clarification, examples, or to look at tests then.

[15:55] <jnthn> Aye, agree.

[15:56] *** frioux_ left
[15:56] <jnthn> And we can always bug Larry it in realspace about it in a couple of weeks too. Mwaha... ;-)

[15:56] *** frew|work joined
[15:56] <jnthn> Anyway, I need to do @other_thing for a bit...

[15:59] <pmichaud> yes, I'm thinking that realspace discussion might be easiest.

[16:01] <masak> food &

[16:01] *** Khisanth left
[16:05] *** payload joined
[16:19] * skids reminds pmichaud,jnthn to include "take" in the discussion when sussing out "leave", especially nested gathers.

[16:19] <moritz_> why? take already works

[16:20] <pmichaud> fsvo "works"

[16:21] <moritz_> rakudo: sub t ($x) { take $x }; (gather { for 1 .. 3 { t($_) } } ).perl.say

[16:21] <p6eval> rakudo 5374f7: OUTPUT«[1, 2, 3]␤»

[16:22] <moritz_> it's dynamically scoped

[16:22] <pmichaud> rakudo:  sub foo(@a) { my $x;  gather { for @a { $x++; take $x } } };   foo(1..5).say

[16:22] <PerlJam> what doesn't work about take?

[16:22] <p6eval> rakudo 5374f7: OUTPUT«Non-Positional argument for @a in call to foo␤current instr.: 'die' pc 15621 (src/builtins/control.pir:204)␤»

[16:22] <pmichaud> rakudo:  sub foo(@a) { my $x;  gather { for @a { $x++; take $x } } };   foo((1,2,3,4,5)).say

[16:22] <p6eval> rakudo 5374f7: OUTPUT«55555␤»

[16:22] <moritz_> ah, there was that.

[16:23] <moritz_> but is it related to the .leave implementation?

[16:23] <pmichaud> I don't know.  It could end up being related, since it has to do with contexts and calling conventions (and capture binding of return values)

[16:24] <pmichaud> at any rate, I don't have a good answer to the 'take' problem yet.

[16:24] *** eternaleye left
[16:24] *** eternaleye joined
[16:25] <skids> Also it isn't specced yet whether you can CALLER.take, contex, etc.

[16:25] <skids> erm context(..).take

[16:25] <skids> Or label gathers.

[16:27] <skids> I figured it might have some implications in the implementation, given what has to happen stack-wise, so I mention it, is all.

[16:28] <pmichaud> agreed.

[16:34] <pmurias> finanalyst: pong

[16:41] <finanalyst> pmurias:

[16:41] <finanalyst> hiu

[16:41] <finanalyst> ih

[16:42] <finanalyst> pmurias: end of day tiredness

[16:42] <finanalyst> still cant get smop to work

[16:44] <finanalyst> pmurias: have to go but put error message in nopaste

[16:45] <pasteling> "finanalyst" at 193.110.4.137 pasted "mildew error" (5 lines, 204B) at http://sial.org/pbot/35796

[16:46] *** finanalyst left
[16:48] *** args joined
[16:49] *** dKingston left
[16:51] *** args is now known as rgs

[16:51] *** dalek left
[16:52] *** dalek joined
[16:53] *** dKingston joined
[16:55] *** rgs left
[16:58] *** plash left
[17:03] *** cognominal left
[17:14] <ruoso> @tell finanalyst run "make CORE" (I suspect make all is missing a dependency on CORE) 

[17:14] <lambdabot> Consider it noted.

[17:15] *** eternaleye left
[17:16] *** eternaleye joined
[17:27] *** awarefish joined
[17:31] *** barney joined
[17:38] <pugs_svn> r26040 | moritz++ | [evalbot] only reproduce output, never try to print the return value.

[17:38] <pugs_svn> r26040 | moritz++ | Suggested by masak++ to reduce bogus tickets

[17:38] <masak> moritz_++

[17:39] *** p6eval left
[17:39] *** p6eval joined
[17:39] <moritz_> rakudo: say "oh hai"

[17:39] <p6eval> rakudo 5374f7: OUTPUT«oh hai␤»

[17:39] <moritz_> rakudo: "foo"

[17:39] <p6eval> rakudo 5374f7:  ( no output )

[17:39] <moritz_> that was easy

[17:40] <jnthn> rakudo: say " ( no output ) "

[17:40] <p6eval> rakudo 5374f7: OUTPUT« ( no output ) ␤»

[17:40] <masak> jnthn++

[17:40] <jnthn> ;-)

[17:41] *** nihiliad left
[17:42] <masak> did we ever reach a conclusion on the question "what do I have to fill a 'new' method with for it to work?"?

[17:43] *** M_o_C joined
[17:45] <jnthn> masak: I fear not, no.

[17:45] <jnthn> masak: Just didn't get the tuits to chase it up yet.

[17:45] <moritz_> masak: in the spec, or in the implementation?

[17:45] <masak> moritz_: I'm interested in both answers to that junction.

[17:45] <jnthn> masak: Will try and remember to spend time on that in Rakudo day - poke me about it then if I don't.

[17:45] <masak> jnthn: sure thing.

[17:45] <jnthn> erm, if I seem to ahve forgotten

[17:46] <masak> aye.

[17:46] * masak tries to get November to build manually

[17:46] <moritz_> the spec says it's as easy as self.bless(attrib1 => $value, attrib2 => $value, ...)

[17:47] <masak> ok.

[17:47] <masak> sounds promising.

[17:48] <moritz_> (once you know which parts of S12 you can ignore to get to that conclusion ;-)

[17:48] <masak> rakudo: class A { has $.a; method new($a) { self.bless(:a($a)) } }; A.new(5).a.say

[17:48] <p6eval> rakudo 5374f7: OUTPUT«5␤»

[17:48] <masak> holy smokes, did that work!?

[17:48] <moritz_> rakudo: class A { has $.a; method new($a) { self.bless(:a($a))  }}; A.new.WHAT(4).say

[17:49] <p6eval> rakudo 5374f7: OUTPUT«too few arguments passed (1) - 2 params expected␤current instr.: 'parrot;A;new' pc 183 (EVAL_20:77)␤»

[17:49] <moritz_> rakudo: class A { has $.a; method new($a) { self.bless(:a($a))  }}; A.new(4).WHAT.say

[17:49] <p6eval> rakudo 5374f7: OUTPUT«A␤»

[17:49] <masak> \o/

[17:49] <masak> can't believe it.

[17:49] *** smtms left
[17:49] <moritz_> t/spec/S12-construction/construction.t has two tests for that

[17:50] <moritz_> but it's not in spectest.data

[17:50] <masak> why not?

[17:50] <moritz_> because it relies on the existance of a class Class that all classes are members of...

[17:51] <masak> ah.

[17:51] <masak> which is against the Spec.

[17:51] <moritz_> but iirc that thing is gone

[17:51] <masak> aye.

[17:51] <moritz_> and it fails in other funny ways

[17:51] <masak> wohoo, November builds!

[17:51] <moritz_> like wrong class names

[17:52] <masak> huh.

[17:52] <moritz_> it defines class OwnConstructor and uses OwnConsstr all over

[17:53] <moritz_> dammit, it relies on outer lexials in classes

[17:53] <masak> don't we have that?

[17:53] <moritz_> no, only in eval

[17:54] <moritz_> maybe I can change that into a class atrib

[17:54] *** rgs joined
[17:55] <masak> rakudo: class A { my $a = 5; method foo { say $a } }; A.foo # are we talking about this?

[17:55] *** smtms joined
[17:55] <p6eval> rakudo 5374f7: OUTPUT«5␤»

[17:55] <moritz_> that's not an outer lexical

[17:55] <moritz_> my $x; class A { # user $x here }

[17:55] <masak> aha.

[17:56] <masak> rakudo: my $a = 5; class A { method foo { say $a } }; A.foo # are we talking about this?

[17:56] <p6eval> rakudo 5374f7: OUTPUT«Lexical '$a' not found␤current instr.: 'parrot;A;foo' pc 168 (EVAL_20:77)␤»

[17:56] <masak> hm.

[17:56] <moritz_> we're talking now ;-)

[17:56] <masak> does that have to do with different times, like BEGIN and stuff?

[17:57] <moritz_> dunno

[17:57] <jnthn> No, it is an underlying ParrotBug.

[17:57] <jnthn> It's about irksome enough that I really want to go hunt it down soon though...

[17:58] <masak> jnthn: so there isn't a problem about A being constructed before the assignment to $a?

[17:58] *** eternaleye_ joined
[17:59] <PerlJam> when does that assignment happen exactly?

[17:59] <PerlJam> at INIT time?

[17:59] <masak> PerlJam: if the assignment is outside the class, as in my last example, I imagine it happens at normal runtime.

[18:01] *** ZuLuuuuuu joined
[18:04] *** phat_ed joined
[18:05] <PerlJam> so ...  my $a = 5; class A { say $a; } would barf because the body of the class is run at compile time and $a is undefined?  and your last example is very neat conceptually the same thing as my $a; class A { method foo { say $a; } }; $a = 5; A.foo;  ?

[18:05] <PerlJam> and your last example dies now because of some bug with the lexical linkage in parrot?

[18:05] <moritz_> PerlJam: it wouldn't barf, because $a is *visible* at compile time, not just initialized yet...

[18:05] *** phat_ed left
[18:06] <moritz_> PerlJam: but when you run the method, chances are that it has been initialized by then

[18:06] *** phat_ed joined
[18:06] *** phat_ed left
[18:06] <masak> moritz_: so $a still contains an undefined  prototype?

[18:06] <PerlJam> right, right, it would just warn.

[18:06] <masak> PerlJam: no, why would it?

[18:06] *** cognominal joined
[18:06] <moritz_> it wouldn't even warn, because the assignment is run before the execution of the method

[18:07] <PerlJam> masak: because $a is uninitialized.

[18:07] <masak> PerlJam: ah. right.

[18:07] <PerlJam> my $a = 5; class A { say $a; }  # $a is uninitialized at the time the class body is executed.

[18:07] <masak> rakudo: my $a; say $a

[18:07] <jnthn> The problem now is that the presence of the class (or rather, something we use when constructing the class) makes the lexical invisible to Parrot.

[18:07] <p6eval> rakudo 5374f7: OUTPUT«Use of uninitialized value␤␤»

[18:07] <jnthn> Or at least, one of the problems.

[18:08] <moritz_> PerlJam: correct

[18:08] <jnthn> rakudo: my $a = 5; class A { method x { say $a } }; A.x # should say 5

[18:08] <p6eval> rakudo 5374f7: OUTPUT«Lexical '$a' not found␤current instr.: 'parrot;A;x' pc 168 (EVAL_20:77)␤»

[18:08] <jnthn> But instead we get that error from Parrot.

[18:09] <PerlJam> jnthn: how does the lexical become invisible?

[18:09] <masak> :/

[18:10] <jnthn> PerlJam: Because we have an init-time block in the static chain, and some Parrot bug gets in the way of that.

[18:10] <jnthn> As in, makes init-time blocks hide lexicals outside of them.

[18:10] <jnthn> Or somehting along those lines. I always forget exactly what it is...there's a Parrot ticket on it.

[18:11] <PerlJam> :init can't also have :outer?  or something like that?

[18:11] *** eternaleye left
[18:11] <jnthn> Right, something like that.

[18:11] <jnthn> Anyway, dinner time...back in a bit. :-)

[18:15] <masak> jnthn: don't miss the parrotsketch meeting in 15 minutes. :)

[18:16] *** jhorwitz joined
[18:16] *** PhatEddy joined
[18:17] * moritz_ eats a tasty steak

[18:19] *** Tene_ left
[18:19] *** Tene joined
[18:19] * PerlJam eats nips of cheese

[18:19] <PerlJam> (and wishes for a tasty steak)

[18:21] *** nihiliad joined
[18:23] <pugs_svn> r26041 | moritz++ | [t/spec] some improvements to construction.t, and fudged for rakudo

[18:26] *** Tene_ joined
[18:41] *** eternaleye joined
[18:42] *** Tene left
[18:42] *** alester joined
[18:42] *** eternaleye_ left
[18:44] *** eternaleye_ joined
[18:48] <dalek> rakudo: 78cb4c3 | (Moritz Lenz)++ | t/spectest.data:

[18:48] <dalek> rakudo: add passing test to t/spectest.data

[18:48] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/78cb4c3f0e14dd68ced8f583f51a420b6189de62

[18:59] *** eternaleye left
[19:04] *** dKingston left
[19:04] *** dKingston joined
[19:11] <masak> haha, Perl 5 requires parentheses around the boolean expression after 'if'. how quaint. :P

[19:11] <sbp> yeah. Perl 6 only requires your sanity and your firstborn

[19:12] <masak> deal.

[19:14] *** FurnaceBoy joined
[19:15] <masak> sbp: with 'firstborn', you meant November, right? :P

[19:17] <jnthn> masak: Oh, as if...I can't believe it's Tuesday. :-(

[19:17] <jnthn> Given that I didn't work yesterday I somehow thought today was Monday or something... :-|

[19:17] <masak> jnthn: I'm sorry, can't talk right now. I'm in a meeting. :P

[19:18] <jnthn> masak: :-P

[19:19] <sbp> hey now, no taking the mickey out of November

[19:20] <sbp> it's a true achievement

[19:20] <sbp> because, you know, it's not like you can make a wiki in two lines of perl5 OH WAIT YOU CAN

[19:21] <masak> sbp: I'm amused by your skewed compliemnt. thanks, I guess.

[19:21] <sbp> heh, actually, I misremembered

[19:21] <sbp> it's four lines: http://c2.com/cgi/wiki?ShortestWikiContest

[19:21] <masak> right.

[19:22] <sbp> having said that, the 3 line PHP was smaller

[19:22] <masak> we should have written it in PHP 6. :)

[19:22] <sbp> oh, there's a PHP 6 now? always copying perl, those guys...

[19:23] <moritz_> isn't version 6 the one where they want to use the backslash as namespace separator?

[19:23] <sbp> oh man, I remember that now

[19:23] <masak> sbp: I definitely agree that there is nothing innovative in the ideas underlying November. and it could definitely have been shorter, if brevity were what we were striving for.

[19:23] <masak> sbp: also, coming up with what to write wasn't the hard part.

[19:23] <masak> sbp: making it run on top of Rakudo was.

[19:24] <sbp> masak: I sympathise entirely

[19:24] <moritz_> it seems just as stupid as having ' for that function in Perl 5 ;-)

[19:24] <sbp> it took me a day to get a grep-a-like working in rakudo

[19:24] <masak> sbp: how long ago?

[19:24] <sbp> a few days ago

[19:24] <masak> sbp: nowadays it should not be so hard. :)

[19:24] <masak> I'm talking about this summer.

[19:24] <sbp> well it would have been easier if we could decide the best way to do the actual grepping

[19:25] <masak> 'we'?

[19:25] <sbp> because I tried loads of things which looked according to the synopses and code samples like they should have worked

[19:25] <sbp> yeah, I roped a few friends into helping

[19:25] <masak> sbp: I must say this sounds interesting. please provide details if you can.

[19:25] <literal> why does Perl 6 allow ' in package names, though?

[19:25] <sbp> masak: oh the script is miniscule, hang on

[19:26] <masak> sbp: I mean your discussion around it.

[19:26] <moritz_> literal: probably because it's part of english (pseudo) words

[19:26] <masak> sbp: and the failures you allude to.

[19:26] <[particle]> literal, apostrophes are allowed in all identifiers

[19:26] <moritz_> literal: I never used it, but I used - a lot

[19:26] <literal> [particle]: yeah, I meant to ask why they are allowed in identifiers

[19:26] <[particle]> literal: isn't(1, 0, "one isn't zero");

[19:27] <sbp> masak: sure, well, http://paste.lisp.org/display/77828 is the script. embarrasing really. let me dig out all of the alternatives that we tried for that little bit in the middle, iterating over the file handle...

[19:27] <literal> I'm not complaining, though, it's neat to have it

[19:27] <[particle]> it allows programmers to express ideas better in grammatically correct identifiers

[19:27] <masak> sbp: looks nice.

[19:27] <PerlJam> literal: neater than apostrophes are dashes.   $I-like-dashes = 1;   #  :-)

[19:27] * [particle] has been writing perl5 code with dashes lately, only to get compile errors

[19:27] <[particle]> sigh.

[19:28] <literal> PerlJam: I like underscores better than dashes

[19:28] <masak> sbp: you should try lines($file). that's about the only improvement I can spot in your script. the rest is idiomatic Perl 6.

[19:28] <moritz_> [particle]: there's a whole list of features that I try to use in perl 5 regularly, and fail regularly ;-)

[19:28] <[particle]> :)

[19:28] <masak> oh, but lines() might now work on $*IN. trying... :)

[19:28] <PerlJam> literal: I like fewer keystrokes in my expression of identifiers.

[19:28] <[particle]> those backporters better get to work!

[19:29] <literal> moritz_: Perl::Critic is your friend :P

[19:29] <literal> PerlJam: that is a point

[19:29] <moritz_> literal: perl -c catches most of them anyway ;-)

[19:29] * [particle] eschewes the shift key

[19:29] <masak> no, it works fine on $*IN.

[19:29] <sbp> masak: well, what we tried was to compress that iterator into a single line. because, like, it's perl innit? so we ended up doing all of the following daft things, and more: http://paste.lisp.org/display/77829

[19:29] <sbp> where exactly would lines($file) go?

[19:30] <masak> sbp: .say if $_ ~~ eval("/{@*ARGS[0]/") for lines( @*ARGS[1] // $*IN )

[19:30] <masak> :)

[19:30] <sbp> ...ooh

[19:30] <masak> sbp: lines($file) returns an array of strings.

[19:30] *** parduncia left
[19:30] <moritz_> masak: you're being evil, that recompiles the regex for each lines

[19:31] <masak> moritz_: I'm evil. what else is new?

[19:31] <sbp> sure, I'd use $regex there

[19:31] <sbp> but the // is the classiest thing there

[19:31] <sbp> does that operator actually do what it looks like it does?

[19:31] <masak> aye.

[19:31] <masak> "undef-or"

[19:31] <sbp> blimey. awesome

[19:31] <PerlJam> sbp: what does it look like it does to you? :)

[19:31] *** eternaleye joined
[19:32] <moritz_> lines($*IN) has the disadvantage that it'll only do its work after all lines have beeen read from STDIN

[19:32] <sbp> it looks like it transmutes base variables into gold

[19:32] <moritz_> ;-)

[19:32] <PerlJam> for some reason I dislike all of the parenthetical forms for grep in that paste earlier.

[19:32] <masak> moritz_: is that inherent, or just in current Rakudo?

[19:32] <moritz_> sbp: actually it's available in perl 5.10 as well

[19:32] <sbp> oh, it reads the whole file into memory?

[19:32] <moritz_> masak: current rakudo

[19:32] <masak> thought so.

[19:32] <moritz_> sbp: yes. Until somebody implements lazy lists.

[19:32] <masak> moritz_: also, I'm waiting for your revised version that doesn't recompile the regex each time. where is it? :)

[19:33] <sbp> moritz_: I see. so technically it could be read lazily, but that depends on the implementation and nothing in the language or the code?

[19:33] <moritz_> sbp: right

[19:33] <sbp> masak: just my $regex = eval(...); and then using $regex there wouldn't work?

[19:33] <moritz_> masak: .say if $_ ~~ state $x //= eval(...) for ...

[19:33] <masak> moritz_: there you go. :)

[19:33] <moritz_> sbp: sure it would

[19:33] <masak> sbp: what moritz_ did.

[19:34] <sbp> okay... so my version would work...

[19:34] <moritz_> sbp: but masak and I have some kind of competition going on

[19:34] <sbp> *but* it requires two, stupid, lines?

[19:34] <masak> sbp: I was looking for a one-liner.

[19:34] <sbp> right

[19:34] <sbp> okay, makes sense to me... :-)

[19:36] * moritz_ found a bug ;-)

[19:36] <masak> \o/

[19:36] <moritz_> bar

[19:36] <moritz_> foobarbaz

[19:36] <moritz_> blubb

[19:36] <moritz_> Null PMC access in get_pmc_keyed()

[19:36] <moritz_> current instr.: '!state_var_inited' pc 19160 (src/builtins/guts.pir:1206)

[19:36] <masak> wtf?

[19:36] <moritz_> argl

[19:36] <masak> was it the 'blubb' that did it?

[19:36] <moritz_> ./perl6 -e '.say if $_ ~~ state $r = eval("rx/{@*ARGS[0]}/") for lines(@*ARGS[1] // $*IN)' foo

[19:36] <moritz_> that should have been the first line

[19:36] <moritz_> the rest was input

[19:37] <moritz_> and output

[19:37] <masak> makes more sense. :)

[19:37] * masak tries

[19:37] <PerlJam> why the eval exactly?

[19:37] <moritz_> PerlJam: because variables don't interpolate into regexes (yet)

[19:37] <sbp> why the rx?

[19:38] <PerlJam> okay, you're just working around the current implementation.

[19:38] <masak> moritz_: I can reproduce.

[19:38] <moritz_> they are specced to work as regexes with <$regex>

[19:38] <sbp> eval("/{...}/") works too, right?

[19:38] <masak> sbp: aye.

[19:38] <moritz_> sbp: it works, but I'm never sure when bare /.../ should match immediately, and when it should construct a regex

[19:39] <masak> moritz_: I don't think they ever match immediately.

[19:39] <sbp> I see. so rx/ basically enforces a construct and keeps your mind neat?

[19:39] <moritz_> sbp: aye

[19:39] <masak> moritz_: it's just where expressions etc that take them and match.

[19:39] <moritz_> masak: if /.../ { ... } # should that test the truthness of the regex object?

[19:39] <masak> moritz_: I'd say do.

[19:39] <masak> s/do/so/

[19:40] <masak> rakudo: $_ = "foo"; if /bar/ { say "OH HAI" }

[19:40] <p6eval> rakudo 78cb4c: OUTPUT«OH HAI␤»

[19:40] <masak> case in point.

[19:41] <PerlJam> that be a bug

[19:41] <PhatEddy> Came across another rt that looks closable if anyone is interested. 54800 (http://rt.perl.org/rt3/Public/Bug/Display.html?id=54800)

[19:41] <PhatEddy> rakudo: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3));

[19:41] <p6eval> rakudo 78cb4c: OUTPUT«Use of uninitialized value␤|3␤»

[19:41] <masak> PerlJam: how so?

[19:41] <PerlJam> http://perlcabal.org/syn/S05.html#Return_values_from_matches

[19:42] <masak> PhatEddy: looks good.

[19:42] <masak> PhatEddy: closing.

[19:42] <masak> PerlJam: indeed.

[19:42] * masak submits rakudobug

[19:42] <masak> close one, submit one. life's good.

[19:47] *** eternaleye_ left
[19:47] <jnthn> For the closed ticket, did we have a regression test?

[19:49] <masak> um. good question.

[19:50] *** diakopter joined
[19:50] <diakopter> rakudo: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3));

[19:50] <p6eval> rakudo 78cb4c: OUTPUT«Use of uninitialized value␤|3␤»

[19:52] <sbp> by the way, I didn't realise you could use state variables outside of closures

[19:52] <diakopter> rakudo: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3), :x(5));

[19:52] *** ejs joined
[19:52] <p6eval> rakudo 78cb4c: OUTPUT«too many named arguments - 'x' not expected␤current instr.: 'foo' pc 86 (EVAL_17:50)␤»

[19:52] <sbp> what's it doing, treating the whole program as the closure scope basically?

[19:52] <diakopter> rakudo: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3), 5);

[19:52] <p6eval> rakudo 78cb4c: OUTPUT«5|3␤»

[19:53] <sbp> kinda hurts my head. I think I get the point about using it in that loop...

[19:54] <pmichaud> 19:40 <masak> rakudo: $_ = "foo"; if /bar/ { say "OH HAI" }

[19:54] <pmichaud> not a bug.

[19:54] <masak> pmichaud: oh, so spec is wrong?

[19:54] <pmichaud> spec isn't wrong.

[19:55] <pmichaud> S05:  Specifically, a C</.../> matches immediately in a value context (void,

[19:55] <pmichaud> Boolean, string, or numeric), or when it is an explicit argument of

[19:55] <pmichaud> a C<~~>.  Otherwise it's a C<Regex> constructor identical to the explicit

[19:55] <pmichaud> C<regex> form.  So this:

[19:55] <pmichaud> (...)

[19:55] <pmichaud> the 'if' statement puts the regex in a boolean value context, so it matches immediately.

[19:56] <masak> pmichaud: why then is OH HAI printed?

[19:56] <pmichaud> oh.

[19:56] <masak> "foo" does not match /bar/.

[19:56] <pmichaud> sorry, yes, *that* is a bug.

[19:56] *** Alias joined
[19:56] <masak> pmichaud: thank you.

[19:56] <pmichaud> I was misreading.

[19:56] *** M_o_C left
[19:57] *** M_o_C joined
[19:57] <pmichaud> is there a value context other than if/while/unless/until ?

[19:57] <moritz_> ?(/.../) perhaps?

[19:57] <lambdabot> Unknown command, try @list

[19:58] * sbp finds the state def in S03, reads

[19:58] <masak> lambdabot: sssh, grownups talking.

[19:58] <pmichaud> ?(/.../)  looks like  a call to prefix:<?>(...) to me, though.

[19:58] <lambdabot> Unknown command, try @list

[19:59] <moritz_> pmichaud: notionally it puts ... in boolean context, doesn't it?

[19:59] <sbp> ooh, each of the scoping keywords corresponds to a trait...

[19:59] <pmichaud> I think it evaluates ... for its boolean value

[19:59] <moritz_> maybe a regex object in boolean context just matches against $_?

[19:59] <moritz_> including in ?(...)

[20:00] <pmichaud> no, not any arbitrary regex object.

[20:00] <jnthn> sbp: state applies to a block

[20:00] <pmichaud> at least, I haven't been thinking of regex objects in that way.

[20:00] <jnthn> sbp: The main body of the program counts as a block too.

[20:01] <sbp> jnthn: thanks

[20:01] <moritz_> it would kinda be weird in the case where regex objects are stored in data structures, and sombody says 'if @re[0] { ... }' and meant something else

[20:01] <moritz_> so maybe my idea isn't all that great

[20:01] <sbp> why (reading on in S03) would one want to construct a Signature outside of its normal contexts?

[20:02] <pmichaud> in particular,    regex { ... }    should never automatically match against $_, afaict.

[20:02] <sbp> I don't really get the point

[20:02] <moritz_> sbp: functions return captures...

[20:03] <moritz_> sbp: ... and if you want to select a value from a capture, binding the capture to a signature is an easy way

[20:03] * masak hasn't fully grokked signatures

[20:03] <PerlJam> sbp: deep magic  :)

[20:04] <jnthn> sbp: You can also use them for unpacking nested data structures.

[20:06] <sbp> ah! wait, I get it

[20:06] * jnthn looks forward to getting Rakudo doing that stuff, but hasn't worked out quite how yet

[20:07] <PerlJam> re: /.../ matching in a value context, does that apply to the rx// form as well?  

[20:07] <PerlJam> (i.e., is there no difference between rx// and // ?)

[20:07] <sbp> right, I found this:

[20:07] <PerlJam> nevermind, I'll look it up.

[20:07] <sbp>     Signature   Function parameters (left-hand side of a binding)

[20:07] <sbp>     Capture     Function call arguments (right-hand side of a binding)

[20:07] <sbp> - S02

[20:07] <masak> jnthn: would it be possible to use them for unpacking nested data structures on the pointy side of -> in for loops as well?

[20:07] <jnthn> masak: yes

[20:07] <sbp> moritz_: but I still don't get your technique

[20:08] <PerlJam> ah, it's only the m// form that matches immediately.  I was conflating m// and rx// there for a minute.

[20:08] <sbp> so I understand that Signature is like the query constructed when you make a sub, and that the Capture is the result of the execution of the query against the parameters when the sub is called...

[20:09] <pmichaud> PerlJam: I _think_ the primary reason for rx is to allow modifiers to be easily attached.

[20:09] <PerlJam> so, $var = /.../ doesn't match immediately, but $var = ?/.../ does because the ? provides a value context.

[20:09] <moritz_> sbp: look at http://svn.pugscode.org/pugs/docs/Perl6/Spec/S32-setting-library/Containers.pod and the example for sub classify 

[20:09] <sbp> thanks, looking...

[20:09] <pmichaud> normally immediate match is handled with m/.../

[20:10] <PerlJam> right, I'm just trying to understand the non-normal stuff :)

[20:10] <pmichaud> I'm not sure how we can know the context of ?, unless it's somehow "special"

[20:10] <pmichaud> which it could be.

[20:11] <PerlJam> I would think that ?/.../,  +/.../, and ~/.../ all match immediately because the prefix op provide value context to the //

[20:11] <pmichaud> this gets back to my conversation with jnthn++ earlier -- how exactly is context detected there?

[20:11] <PerlJam> (I don't understand "value context" really, but this is what I would think based on what the spec says)

[20:11] <pmichaud> assuming that   ?/.../  is really    prefix:<?>( /..../ )

[20:12] <pmichaud> how does that argument learn that it's in a value context?

[20:12] <pmichaud> either  prefix:<?> isn't multi, or there's something else going on

[20:12] <moritz_> pmichaud: it must be "more" than that, otherwise want() could never work

[20:12] <pmichaud> moritz_: yes, that was my question earlier -- how exactly does want() work there?

[20:13] <pmichaud> perhaps  it's     sub prefix:<?>($x as Bool) { $x }     ?

[20:13] <moritz_> maybe

[20:13] <diakopter> rakudo: .:P

[20:13] <pmichaud> and the "as Bool" imposes the context?  But that doesn't feel quite right either.

[20:13] <p6eval> rakudo 78cb4c: OUTPUT«Multiple Dispatch: No suitable candidate found for 'concatenate_str', with signature 'PSP->P'␤current instr.: 'parrot;Perl6;Grammar;Actions;_block2731' pc 163431 (src/gen_actions.pir:8071)␤»

[20:13] <moritz_> I guess only TimToady can answer that ;-)

[20:13] *** goksie left
[20:14] <diakopter> PSP->P

[20:14] <diakopter> std: .:P

[20:14] <PerlJam> sub prefix:<?>(Regex $x) { $x.does_it_match }   # is there such a method?

[20:14] <p6eval> std 26041: OUTPUT«ok 00:02 35m␤»

[20:14] <jnthn> I'm not sure I even want to know what Rakudo is trying to do there...

[20:15] <sbp> moritz_: oh, I think I see. so like another way that could be done is simply making a hash and having 'odd' and 'even' be keys of the hash, but instead you're using the capture as a kind of default hash to make the syntax nicer?

[20:15] <diakopter> std: .:()

[20:15] <pmichaud> PerlJam: sure, but once you start changing prefix:<?> into a multi sub (which it would have to be), then context information seems to be lost

[20:15] <p6eval> std 26041: OUTPUT«ok 00:02 35m␤»

[20:15] <moritz_> jnthn: it's trying to call method :P on $_

[20:15] <PerlJam> oh, bool or something?  bit?

[20:15] * PerlJam doesn't remember

[20:15] <moritz_> sbp: yes

[20:15] <PerlJam> pm: what do you mean "seems to be lost"?

[20:16] <moritz_> sbp: also note that signatures have more power, with 'is copy', 'is rw' etc

[20:16] <pmichaud> PerlJam: how does $x know that it's in "boolean value context"?

[20:16] <sbp> moritz_: ah, I see

[20:16] <diakopter> std: :P.:P

[20:16] <p6eval> std 26041: OUTPUT«ok 00:02 35m␤»

[20:17] <moritz_> jnthn: that's how $file ~~ :e works right now, it calls the method :e on Str ;/

[20:17] <PerlJam> pm: I'm going to go with prefix:<?> is special  :)

[20:18] <jnthn> Man, is there any smiley that isn't valid Perl 6 syntax in some context yet?

[20:18] <PerlJam> pm: somethings are context providers, others are context consumers.  prefix:<?> is a provider 

[20:18] <moritz_> std: /<[^:^]>/

[20:18] <p6eval> std 26041: OUTPUT«ok 00:03 35m␤»

[20:19] <pmichaud> PerlJam: but in order to do that, we have to have something that makes it special.  Either it has to thunk its arguments (so it can provide context), or there has to be something declarationally or syntactically to make that happen.

[20:19] <diakopter> rakudo: :() ~ 1

[20:19] <sbp> moritz_: only thing I don't get, why shouldn't (:@even, :@odd) be :(:@even, :@odd)?

[20:19] <p6eval> rakudo 78cb4c: OUTPUT«No applicable methods.␤␤current instr.: '_block14' pc 66 (EVAL_17:40)␤»

[20:20] <PerlJam> pm: I don't think you're going to get any syntactic help, so it's got to be the former.

[20:20] *** barney left
[20:20] <moritz_> sbp: they could be. But positional arguments can always also be called by name

[20:20] <pmichaud> so, what in the definition indicates that prefix:<?> thunks it argument?

[20:21] <moritz_> sbp: sub f($x) { ... } can be called with f(:x<3>)

[20:22] <pmichaud> but more generally,   consider    $y + foo()

[20:22] <pmichaud> what's the want context for foo() ?

[20:23] <PerlJam> numeric scalar (or whatever the right terminology is)

[20:23] <sbp> moritz_: also, why the comma between the classify args?

[20:23] <sbp> moritz_: someone pointed out to me that http://svn.openfoundry.org/pugs/docs/Perl6/Spec/Functions.pod doesn't have the comma there

[20:23] <sbp> (in the same example)

[20:24] <literal> that's an outdated version

[20:24] <moritz_> sbp: that repository is very old

[20:24] <literal> http://perlcabal.org/syn/S29.html

[20:24] <PerlJam> unless someone redefines infix:<+> I guess.

[20:24] <pmichaud> PerlJam:  but infix:<+> is already a Multi

[20:24] <moritz_> sbp: you should forget about that repoistory immediately ;-)

[20:25] <pmichaud> and we can't decide which multi to call until we know what foo() returns.

[20:25] <sbp> will do. I'll bludgeon my friend with clue too

[20:25] <PerlJam> right.

[20:26] <pmichaud> so foo can't know what its caller wants because we don't know the identity of its caller.

[20:27] <[particle]> is there a single word for "ask a yes/no question"?

[20:27] <diakopter> rakudo: .say(1)

[20:27] <p6eval> rakudo 78cb4c: OUTPUT«too many arguments passed (3) - 1 params expected␤current instr.: 'parrot;Perl6Object;say' pc 980 (src/classes/Object.pir:174)␤»

[20:28] <masak> [particle]: boolify?

[20:29] <[particle]> i should say, a verb.  like interrogate/query/ask

[20:29] <PerlJam> pm: so ... thunks everywhere?  Seems like that would kill performance.  (Suddenly simple addition feels like I'm dealing with junctions  :)

[20:29] <[particle]> i guess not.  boole only has nouns named after him.

[20:29] <lucs> [particle]: If the word was 'florb' for example, can you give an example of its usage?

[20:29] <PerlJam> verbing nouns is a great tradition.

[20:30] <diakopter> rakudo: {say $^zzz}.(e)

[20:30] <p6eval> rakudo 78cb4c: OUTPUT«2.71828182845905␤»

[20:30] <[particle]> i'm tagging ~300 api functions by objects involved, attributes, and verbs

[20:30] <[particle]> IsContactIDUnsubscribed - Checks if a contact is subscribed by a contact ID number.

[20:31] <[particle]> i need a verb to signify boolean context

[20:31] <diakopter> [particle]: how about 'whether'

[20:31] <[particle]> maybe i should be specifying context separately from my verbs

[20:31] <jnthn> masak can probably offer you an appropriate Chinese particle. ;-)

[20:31] <[particle]> whether isn't a verb, but it does express the idea

[20:31] <masak> there's always an appropriate Chinese particle.

[20:32] <jnthn> There might even be some inappropriate ones too. ;-)

[20:32] <masak> 了 (LE5), of course, being the all-time favourite.

[20:33] <masak> http://en.wikipedia.org/wiki/Chinese_particles

[20:34] <jnthn> [particle]: Well, "is" is a verb too...

[20:34] <masak> albeit a strange one.

[20:35] * masak likes E-prime on some days.

[20:35] <jnthn> Aye, some languages mostly do without it, some may entirely...

[20:35] <masak> jnthn: Russian doesn't count. they just have a zero-length word for it. or a long dash.

[20:36] <masak> jnthn: Chinese also doesn't count. all their adjectives are verbs.

[20:36] <masak> every language cheats. :)

[20:36] <diakopter> rakudo: say *

[20:36] <p6eval> rakudo 78cb4c: OUTPUT«Whatever<0xb6060098>␤»

[20:36] <masak> rakudO: say *.WHAT

[20:37] <masak> rakudo: say *.WHAT

[20:37] <p6eval> rakudo 78cb4c: OUTPUT«Statement not terminated properly at line 1, near ".WHAT"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[20:37] <masak> rakudo: say (*).WHAT

[20:37] <p6eval> rakudo 78cb4c: OUTPUT«Whatever␤»

[20:37] <masak> :)

[20:37] <[particle]> rakudo: say *.WHAT()

[20:38] <p6eval> rakudo 78cb4c: OUTPUT«Statement not terminated properly at line 1, near ".WHAT()"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[20:38] * [particle] thought WHAT needed parens

[20:38] *** kidd joined
[20:39] <pmichaud> PerlJam: (thunks everywhere)  -- you can see why I'm a bit confounded by 'what'  :-)

[20:39] <pmichaud> sorry, by 'want'

[20:39] <moritz_> maybe it would be sane to get rid of what() entirely ;-)

[20:39] <moritz_> though it won't be popular among perl 5 hackers at all

[20:39] <masak> getting rid of want() is an intriguing idea.

[20:41] <jnthn> Would replacing it with some built in type that you initialize with how it coerces in various contexts do?

[20:41] <jnthn> fwiw, I have _very_ rarely used want in Perl 5.

[20:41] <jnthn> But I'd look at what people are using it for to get an idea...

[20:41] <moritz_> literal: I just got a mail that we should try to convince students to hand in their GSOC applications *now*, so please feel informed and motivated ;-)

[20:41] <PerlJam> I editted some code just this morning and added a call to wantarray.

[20:41] <literal> moritz_: will do

[20:41] <moritz_> jnthn: people mostly do that to generate DWIMmy return values

[20:42] <moritz_> jnthn: which IMHO is much easier in Perl 6 anyway

[20:42] <PerlJam> moritz_: funny, I was thinking it easier in perl 5 since you only have 3 "types" to work with  :)

[20:43] <moritz_> PerlJam: I'm rather impressed by the Match object, which IMHO is unbeatable in DWIMmyness ;-)

[20:44] <masak> moritz_: right. we use objects in Perl 6 to DWIM values.

[20:44] <masak> no need for want(). :)

[20:44] *** Alias left
[20:44] <jnthn> do not want()

[20:44] <moritz_> ;-)

[20:44] <masak> 哈哈

[20:45] <pmichaud> it might be nice to have a canonical way to create an instance that says "in boolean context do X, in numeric context do Y, in list context do Z, etc."

[20:45] <moritz_> should I write a mail to p6l suggesting its killing?

[20:45] <pmichaud> where X, Y, and Z may be closures that are lazily evaluated.

[20:45] <moritz_> pmichaud: good idea

[20:45] <masak> moritz_: please.

[20:45] <pmichaud> I don't know if 'but' fills that niche already

[20:46] <moritz_> pmichaud: I don't think that 'but' is lazy in any way

[20:46] <masak> pmichaud: class A { method Str { ... }; method Num { ... }; method Bool { ... } }

[20:46] <pmichaud> masak: sure, I can do that for a class, I'm thinking more of an instance.

[20:46] <pmichaud> return $x but List({ ... })

[20:46] <masak> pmichaud: just instantiate an anonymous class.

[20:47] <masak> it doesn't get much more convenient than that.

[20:47] <masak> _and_ it's OO! :)

[20:47] <pmichaud> having to create an anonymous class for want semantics seems odd....

[20:47] <pmichaud> yet strangely consistent.

[20:47] <masak> want() seems odd. :)

[20:48] <pmichaud> oh, maybe it's:    return value but role { method Str { ... }; }

[20:49] <amoc> rakudo: my %hash = (1 => 2); say "%role<>"

[20:49] <p6eval> rakudo 78cb4c: OUTPUT«%role<>␤»

[20:49] <amoc> rakudo: my %hash = (1 => 2); say "%hash<>"

[20:49] <p6eval> rakudo 78cb4c: OUTPUT«%hash<>␤»

[20:49] <pmichaud> amoc:  Rakudo doesn't recognize anything but $-vars in interpolated strings yet.

[20:49] <masak> pmichaud: I like that.

[20:49] <pmichaud> rakudo:  my %hash = (1 => 2);  say "{%hash<>}";

[20:49] <p6eval> rakudo 78cb4c: OUTPUT«␤»

[20:49] <pmichaud> hmmm.

[20:50] <pmichaud> my @list = (1,2,3,4);   say "{@list[]}";

[20:50] <masak> bug?

[20:50] <amoc> err..

[20:50] <pmichaud> rakudo: my @list = (1,2,3,4);   say "{@list[]}";

[20:50] <PerlJam> looks like one to me.

[20:50] <p6eval> rakudo 78cb4c: OUTPUT«1 2 3 4␤»

[20:50] * masak submits rakudobug

[20:50] <pmichaud> yes, I suspect it's a bug in postcircumfix:< >

[20:50] <literal> rakudo: my @list = (1,2,3,4);   say "{@list}";

[20:50] <p6eval> rakudo 78cb4c: OUTPUT«1 2 3 4␤»

[20:50] <pmichaud> rakudo:  my %hash = (1 => 2);  say "{%hash}";

[20:50] <p6eval> rakudo 78cb4c: OUTPUT«1  2␤␤»

[20:50] <literal> only need the [] when interpolating without { } :P

[20:50] <PerlJam> rakudo:  my %hash = (1 => 2);  say "{%hash{}}";  # does this work?

[20:50] <p6eval> rakudo 78cb4c: OUTPUT«1  2␤»

[20:51] <pmichaud> rakudo:  my %hash = (1 => 2);  say "{%hash{()}}";

[20:51] <p6eval> rakudo 78cb4c: OUTPUT«␤»

[20:51] <pmichaud> heh.

[20:52] <pmichaud> %hash<> is the same as %hash{()}

[20:52] <pmichaud> which is an empty slice.

[20:52] <masak> rakudo: my %hash = (1 => 2);  say %hash<>;

[20:52] <p6eval> rakudo 78cb4c: OUTPUT«␤»

[20:52] <PerlJam> er, isn't <> the empty string?

[20:52] <pmichaud> no, it's the empty list.

[20:52] <pmichaud> like ()

[20:52] <pmichaud> (unless the spec changed again on me)

[20:53] <literal> more like Perl 5's qw() (or qw<>, etc)

[20:53] <PerlJam> yeah, you're right.  I keep thinking of <> as quotes rather than quote words since it's almost always used with one word as a hash subscript.

[20:53] <amoc> ...'~' empty slice produces list of elements when interpolation i think

[20:54] <PerlJam> so ... why doesn't the interpolation work yet?  Is it just blocking on tuits or something more substatial?

[20:54] <PerlJam> er, substantial even

[20:54] <pmichaud> amoc: not quite -- empty brackets or braces produce the entire list.  But if there's an argument there, then we use whatever the argument returns.

[20:55] *** masak left
[20:55] <pmichaud> so:   my @a = 1,2,3;   my @b = ();   say @a[];   # "123"

[20:55] <amoc> ah i see

[20:55] <pmichaud> so:   my @a = 1,2,3;   my @b = ();   say @a[@b];   # ""

[20:55] <pmichaud> PerlJam: it's a parser issue.

[20:55] <amoc> o_O?

[20:55] <pmichaud> for   [email@hidden.address]   we have to be able to lookahead and make sure there's a postcircumfix at the end somewhere

[20:56] <amoc> @a[@b] = () is by design? or not yet implemented?

[20:56] <lambdabot> Unknown command, try @list

[20:57] <pmichaud> by design.

[20:58] <amoc> i see that it means, then, only empty brackets not empty list. 

[20:58] <pmichaud> in particular, people would be surprised if  a 2-element @b produces a 2-element slice, a 1-element @b produces a 1-element slice, and a 0-element @b produces the entire list.

[20:58] <PerlJam> I know I would be surprised.

[20:59] <amoc> yes, yet it looks really great.

[21:00] <skids> BTW, the name for the [] or {} feature is "Zen slice"

[21:00] <pmichaud> yes, couldn't find it in S02.

[21:01] *** sri_kraih_ joined
[21:04] *** ZuLuuuuuu left
[21:05] <moritz_> mail to p6l sent

[21:05] <moritz_> maybe not the brightest description :/

[21:07] <pmichaud> looks okay.  Note that my "value but role ..."  is conjectural -- I have no idea if it's actually correct.  :-P

[21:07] *** sri_kraih left
[21:07] <moritz_> pmichaud: I see how it's allowed by current language rules

[21:08] *** jhorwitz left
[21:09] <amoc> good morning (here)

[21:09] <jnthn> I think you'd get away with it.

[21:10] <jnthn> std: my $x = 42 but role { method x { say "oink" } }; say $x. say $x.x;

[21:10] <p6eval> std 26041: OUTPUT«##### PARSE FAILED #####␤Obsolete use of . to concatenate strings; in Perl 6 please use ~ instead at /tmp/0t8Pro0Wj7 line 1:␤------> [32mle { method x { say "oink" } }; say $x. [31msay $x.x;[0m␤FAILED 00:04 36m␤»

[21:10] <jnthn> std: my $x = 42 but role { method x { say "oink" } }; say $x; say $x.x;

[21:10] *** __felix__ joined
[21:10] <p6eval> std 26041: OUTPUT«ok 00:04 36m␤»

[21:11] <jnthn> rakudo: my $x = 42 but role { method x { say "oink" } }; say $x; say $x.x;

[21:11] <p6eval> rakudo 78cb4c:  ( no output )

[21:11] <jnthn> fail

[21:11] *** ejs left
[21:11] <jnthn> rakudo: my $r = role { method x { say "oink" } }; say $x.WHAT

[21:11] *** __felix__ left
[21:11] <p6eval> rakudo 78cb4c: OUTPUT«Scope not found for PAST::Var '$x' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[21:12] <jnthn> rakudo: my $r = role { method x { say "oink" } }; say $r.WHAT

[21:12] <p6eval> rakudo 78cb4c: OUTPUT«Code␤»

[21:12] <jnthn> Ah.

[21:12] <jnthn> That is the Wrong Answer.

[21:12] <PerlJam> rakudo: my $x = 42 but role { method x { say "oink" } }; say $x.WHAT;

[21:12] <jnthn> rakudo: say (role { }).WHAT

[21:13] <p6eval> rakudo 78cb4c:  ( no output )

[21:13] <p6eval> rakudo 78cb4c: OUTPUT«Code␤»

[21:13] <pmichaud> rakudo:   my $x = class { };  say $x.WHAT;

[21:13] <p6eval> rakudo 78cb4c: OUTPUT«!ANON10␤»

[21:13] <moritz_> std: 2 but role { ... }

[21:13] <p6eval> std 26041: OUTPUT«ok 00:02 35m␤»

[21:13] <pmichaud> rakudo:   my $x = role { };  say $x.WHAT;

[21:13] <p6eval> rakudo 78cb4c: OUTPUT«Code␤»

[21:13] <jnthn> rakudo: my $r = role { method x { say "oink" } }; say $r!select.WHAT

[21:13] <pmichaud> shouldn't 'role' return a protoobject or something here?

[21:13] <p6eval> rakudo 78cb4c: OUTPUT«Method '!select' not found for invocant of class 'Sub'␤current instr.: 'parrot;P6metaclass;dispatch' pc 637 (src/classes/ClassHOW.pir:161)␤»

[21:13] <moritz_> std: return 2 but role { method foo { ... } }

[21:13] <p6eval> std 26041: OUTPUT«ok 00:02 35m␤»

[21:14] <jnthn> pmichaud: tbh I'd not really thought a whole load on anonymous roles...

[21:14] <jnthn> So I'm not hugely surprised that it doesn't work.

[21:14] <pmichaud> that's fine... I hadn't thought of them until today either :-)

[21:14] <jnthn> ah

[21:14] <jnthn> rakudo: my $x = role { }; say $x().WHAT

[21:14] <pmichaud> I do wonder if  it's really     $value but Str({...})   instead, though.

[21:14] <p6eval> rakudo 78cb4c: OUTPUT«␤»

[21:15] <jnthn> oh ah hmm nasty.

[21:15] <jnthn> Roles as multi subs is great for named ones...

[21:15] <pmichaud> I think it's returning the Code block instead of the proto.  Seems to work okay for 'class' though.

[21:16] <jnthn> I suspect it's trying to construct something multi-ish but then getting horribly confused over the anonymity.

[21:16] <PerlJam> rakudo: my $x = 42; say $x.WHAT;

[21:16] <p6eval> rakudo 78cb4c: OUTPUT«Int␤»

[21:16] <PerlJam> rakudo: my $x = 42 but role { }; say $x.WHAT;

[21:16] <PerlJam> (dramatic pause...)

[21:17] <p6eval> rakudo 78cb4c:  ( no output )

[21:17] <jnthn> I'm surprised infix:<but> isn't exploding here too.

[21:17] <jnthn> Ho hum. Rakudo bug it. :-)

[21:18] <diakopter> arkduo: say 3

[21:18] <diakopter> erm

[21:18] <PerlJam> arkduo is rakudo's evil twin?

[21:18] <[particle]> three is the magic number

[21:19] <PerlJam> one of an evil triplet?  :)

[21:19] <[particle]> that's the whole idea of ark duo's

[21:21] *** skids left
[21:23] *** dKingston_ joined
[21:23] *** dKingston left
[21:46] *** hercynium left
[21:46] <Tene_> anyone know how many spectests pugs passes these days?

[21:50] <moritz_> maybe there are some reports on smoke.pugscode.org?

[21:50] <Tene_> ELAMEBROWSER

[21:51] * Tene_ on ircphone

[21:51] <moritz_> ELAMESERVER

[21:51] <moritz_> I'm trying to get to that server, and it takes ages

[21:52] <Tene_> laaaaaaame

[21:53] <Tene_> moritz++ # provides http proxy over irc :)

[21:54] *** kane_ left
[21:54] *** kane_ joined
[21:56] *** Alias_ joined
[21:57] <diakopter> uadork: say "rakudo"

[21:57] <diakopter> erm

[22:03] *** Limbic_Region joined
[22:05] *** vinay joined
[22:05] *** M_o_C left
[22:07] *** FurnaceBoy left
[22:08] *** orafu left
[22:11] *** orafu joined
[22:13] *** pmurias left
[22:13] *** skids joined
[22:14] *** awarefish left
[22:37] <PerlJam> moritz_: Did you see Damian's reply re: want?  Damian++ :-)

[22:39] <moritz_> PerlJam: no. Has it hit the list already?

[22:39] *** moritz_ sets mode: +oooo Tene_ diakopter PerlJam [particle]

[22:39] <PerlJam> dunno, I just saw it in my inbox

[22:40] *** [particle] left
[22:44] *** dduncan joined
[22:44] *** dduncan left
[22:46] *** nihiliad left
[22:46] <jnthn> Just hit mine too.

[22:48] <moritz_> same here

[22:48] <moritz_> (slow lists)--

[23:06] *** PZt joined
[23:11] *** exodist left
[23:22] *** wayland76 left
[23:35] *** nihiliad joined
[23:36] *** wknight8111 joined
[23:42] *** Maghnus joined
[23:50] *** LimbicRegion joined
[23:50] *** Limbic_Region left
[23:50] *** LimbicRegion is now known as Limbic_Region

[23:51] *** PhatEddy left
[23:51] *** meppl left
[23:59] *** PhatEddy joined
