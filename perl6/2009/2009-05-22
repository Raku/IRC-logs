[00:02] <pmichaud> $tree.planted = True

[00:02] *** vxnick left
[00:03] <jnthn> :-)

[00:03] <jnthn> pmichaud: Which way up is it facing? The computer science tree way, or the natural tree way? ;-)

[00:04] <pmichaud> The root of the tree is at the bottom.

[00:04] <jnthn> Judging from the diagrams, I wouldn't have trusted a lot of the folks who lectured me in computer science to know it should be that way.

[00:05] <pmichaud> well, "bottom" and "top" are totally relative.

[00:05] <jnthn> :-)

[00:05] <pmichaud> To someone living in Australia, I suspect they think the tree I just planted is in the computer-science orientation.

[00:06] <pmichaud> And the tree is a Chinese Pistache, so who knows what the "correct" orientation is.  :-)

[00:07] <pmichaud> Anyway, the parts that were surrounded with dirt when we bought the tree are now surrounded by even more dirt, which I think is the important part.

[00:07] * jnthn has to google to get an idea of what kinda tree that is

[00:08] <jnthn> Hmm, looks like they can get quite pretty. :-)

[00:08] <pmichaud> Yes.

[00:08] <pmichaud> We have one already in our side courtyard, and it's beautiful (even though we've been totally mistreating it for about 3 years)

[00:09] <jnthn> Nice. :-)

[00:09] <pmichaud> we originally thought it was a Grey Ash with a heavy mistletoe infestation.  Turns out it's a Chinese Pistache and the "mistletoe" we've been vigorously cutting out is in fact its fruit.

[00:09] <jnthn> Oh!

[00:09] <pmichaud> Oops.

[00:09] <jnthn> Eddible fruit?

[00:10] <jnthn> I'm suspecting not.

[00:10] <pmichaud> Anyway, it survived our mistreatment (and a couple of heavy droughts), so when it was time for a new tree in our front yard to replace the (largely dead) oak it was an easy pick.

[00:10] <pmichaud> I don't think its berries are all that edible, no.

[00:10] <pmichaud> However, the plum that sits next to the Chinese Pistache is *very* edible and makes wonderful plum jam.  :-)

[00:10] <jnthn> Oooh, nice.

[00:11] <pmichaud> And our apple tree is covered with almost-ripe apples this year.

[00:11] <jnthn> My family grew various fruits in the garden. The blackberries and rubarb were the best. :-)

[00:11] <pmichaud> I've never been able to get our blackberries to really grow.

[00:11] <jnthn> These days I live city center though. Which is nice in many ways, but leaves me without a garden.

[00:12] <pmichaud> We have a (I suspect somewhat wild) blackberry vine in the courtyard as well, but I think it's not getting enough sun to really produce lots of berries.

[00:12] <pmichaud> If I try to train it to a trellis, it's probably too much shade.

[00:12] <pmichaud> Oh well.

[00:12] <pmichaud> It always manages to produce about a dozen blackberries, which the birds and rabbits get to long before I get to try one.  :-|

[00:12] <jnthn> Yeah, ours got a decent bit of sun.

[00:13] <pmichaud> We lucked out with this house -- most of the plants/trees were here when we bought it -- we had no idea we had so many fruit-producing trees.

[00:14] <jnthn> My mum tended to make various puddings out of the fruits. Which was nice. :-)

[00:14] <pmichaud> Indeed.

[00:14] <pmichaud> okay, well, time for a shower, then dinner.  Catch you tomorrow, likely.

[00:15] <jnthn> Yes, I'm going to take some sleep.

[00:15] <jnthn> Spending about half tomorrow on Rakudo, half on $other_job.

[00:15] *** bacek left
[00:15] <pmichaud> okay.  I'll be travelling much of tomorrow.

[00:15] <pmichaud> I should be able to catch up with things in the evenings and over the weekends.

[00:15] <jnthn> I'll try not to break too much. ;-)

[00:15] <pmichaud> I'm not too worried about that.  :-)

[00:16] <pmichaud> anyway, see ya soon.

[00:16] <Trey> so... how *is* .prime defined in that example then?  does it assume Int being reopened and a prime method added?

[00:16] <jnthn> Have a safe journey.

[00:16] <pmichaud> Trey: I don't know.  I think it may be from a much earlier draft.

[00:16] <pmichaud> There was a time when methods did fall back to subs.

[00:16] <jnthn> Trey: I suspect you'd have to augment to get that now.

[00:16] <pmichaud> More likely one should just write   prime($_)

[00:17] <jnthn> Yes.

[00:17] *** Tene left
[00:17] <Trey> yeah, i remember that... but one could make C<@primes = (do (do $_ if .prime) for 1..100);> work if you defined an Int::prime... what about if you created a multi?  would that work?

[00:18] <Trey> can single-arg multis be called with dot notation?

[00:18] <jnthn> No.

[00:18] <jnthn> Only methods.

[00:18] <Trey> didn't think so

[00:18] <jnthn> There's no fallback now.

[00:18] <Trey> didn't think so.

[00:18] <Trey> thanks

[00:18] <jnthn> You can augment the class, but, well, just write a sub. ;-)

[00:20] <jnthn> OK, sleeps...night all

[00:22] *** dextius joined
[00:22] *** szabgab left
[00:23] <dextius> can anyone give an idea why I am getting this error compiling rakudo? (first comment on the site) http://www.rakudo.org/node/43#comment-6

[00:23] *** DemoFreak left
[00:28] *** c9s joined
[00:29] *** frew|work joined
[00:31] *** Tene joined
[00:34] <skids> dextius: looks like a string is getting created without a specified encoding.

[00:35] <dextius> I've tried to rakudo for the last 3 builds, keep getting the same error.. 

[00:35] <skids> If you do a backtrace, there may be a value in the string to give more clues.

[00:35] <skids> (that is, run under gdb)

[00:36] <dextius> skids: ok, I'll try and give that a try.. 

[00:40] <dextius> skids: I ran "gdb /code/rakudo/parrot/parrot", at the prompt, I typed "run -o perl6_s1.pbc perl6.pir" at the prompt.  It dumped the same thing I posted to the web page.  Do I need to give it some sort of "really verbose" option to get what you are looking for?

[00:41] <skids> yes you can walk up the stack and look at the code.

[00:43] <skids> First thing is, it should have also shown you a line of code after the stack

[00:43] <skids> and "list" should get you more surrounding code.

[00:43] <dextius> skids: src/string/api.c:762: failed assertion 'encoding'

[00:44] <skids> Right but it should show you source code.

[00:44] <dextius> skids: Yeah, I typed list, I got an "int main" looking routine..

[00:44] *** nsh joined
[00:44] <dextius> (sorry, my GDB skills are non-existent, just a very happy perl programmer)

[00:44] <skids> so look at the line 762 in the listing.

[00:46] <skids> and there is probably a string object being tested by an assert

[00:46] *** Casan left
[00:47] <dextius> skids: yeah, Parrot_str_new_init

[00:47] <skids> what's the argument to that function?

[00:48] <dextius> ARROT_INTERP, ARGIN_NULLOK(const char *buffer), UINTVAL len,         ARGIN(const ENCODING *encoding), ARGIN(const CHARSET *charset), UINTVAL flags

[00:48] <skids> so use "print" to see what are in those values

[00:49] <dextius> cool, ok, one sec

[00:49] *** clkao_ is now known as clkao

[00:50] * skids bets encoding is null

[00:50] <dextius> am I an idiot? "(gdb) print encoding No symbol "encoding" in current context."

[00:51] * skids digs up that part of the source/

[00:53] <skids> might be some kind of macro magic in the way

[00:54] <dextius> skids: screwing around, I ran "bt" and it gave me this.. #5  0x00901b4b in Parrot_str_new_init (interp=0x801790, buffer=0x734acc "MutableVAR", len=10, encoding=0x0, charset=0x0, flags=12288) at src/string/api.c:762

[00:55] <dextius> I'm going to guess that 0x0 is "null"

[00:55] <dextius> I'll dump this onto the rakudo page..

[00:56] <skids> OK then do "up" and another list to look at where that was called

[00:56] <dextius> skids: I dumped the entire list to http://www.rakudo.org/node/43#comment-6

[00:59] <skids> Ah, what does "print PARROT_DEFAULT_ENCODING" give?

[01:01] <dextius> No symbol "PARROT_DEFAULT_ENCODING" in current context.

[01:01] <dextius> <sigh>

[01:01] <skids> agh, it's a macro.

[01:01] <skids> How about Parrot_fixed_8_encoding_ptr

[01:02] <dextius> $1 = (ENCODING *) 0x801d60 

[01:02] <dextius> Where did you find this (been greping a storm over here)

[01:02] <skids> this is in the parrot source code, so under parrot/src/ and parrot/include/parrot/

[01:03] <dextius> Ok.  I simply did the instructions on the rakudo page to compile (git, then perl Configure.pl --gen-parrot)

[01:04] <dextius> Is it possible parrot built incorrectly on my system?

[01:04] <skids> Oh, you mean you were trying to run against and installed parrot?

[01:04] <skids> s/and/an/

[01:05] <dextius> No, I don't have parrot installed.  I think Configure.pl svn's out parrot and compiled it for me.

[01:05] <skids> damn, that would have been an easy explanation :-)

[01:06] <skids> So it's weird then, PARROT_DEFAULT_ENCODING should have been  Parrot_fixed_8_encoding_ptr, not 0x0.

[01:06] <dextius> heh, sorry, thanks for your help.. i bought both O'Reilly books on Parrot a long time ago, I keep trying to build this thing every few weeks, was trying to avoid coming here and begging for help :-(

[01:07] <skids> I don't do anything else useful around here so I don't mind helping :-)

[01:07] <dextius> Is it possible that Rakudo isn't seeing Parrot's encoding?

[01:09] *** araujo joined
[01:10] <skids> I don't think so, it's happening inside an API function where the value passed to "encoding" is not dependent on inputs

[01:12] <skids> s = Parrot_str_new_init(interp, buffer, strlen(buffer),

[01:12] <skids>     678                        PARROT_DEFAULT_ENCODING, PARROT_DEFAULT_CHARSET,

[01:12] <skids>     679                        PObj_external_FLAG|PObj_constant_FLAG);

[01:12] *** eternaleye joined
[01:13] <skids> so unless something is screwed with the headers, PARROT_DEFAULT_ENCODING should be defined in parrot/include/parrot/encoding.h

[01:14] <dextius> Is there any way to interrogate the "default" that is being passed as a null?

[01:14] <dextius> (for encoding)?

[01:14] <pmichaud> I have a couple of questions -- what platform?

[01:14] <dextius> Mac OS X

[01:14] <pmichaud> 64 bit, 32 bit?

[01:15] <pmichaud> Intel?

[01:15] <dextius> Darwin victory 9.6.0 Darwin Kernel Version 9.6.0: Mon Nov 24 17:37:00 PST 2008; root:xnu-1228.9.59~1/RELEASE_I386 i386

[01:15] <pmichaud> okay.

[01:15] <pmichaud> That's not one of our common platforms but it seems like it should still work.

[01:16] <pmichaud> out of curiosity, try running the parrot command with the -G flag

[01:16] * dextius smiles.. I'll be your tester then :-)

[01:16] <dextius> sure.. one sec

[01:16] <pmichaud> parrot/parrot -G perl6_s1.pbc perl6.pir   # I think

[01:16] <pmichaud> oh, missing a -o there

[01:16] <pmichaud> parrot/parrot -G -o perl6_s1.pbc perl6.pir   # I think

[01:16] <dextius> inside of GDB ?

[01:17] <pmichaud> yes, or from the command line

[01:17] <pmichaud> either one

[01:17] <wayland76> Nopaste URL: http://sial.org/pbot/perl6

[01:17] <lambdabot> wayland76: You have 3 new messages. '/msg lambdabot @messages' to read them.

[01:17] <dextius> pmichaud: done, same error

[01:17] <pmichaud> hmmm.

[01:17] <pmichaud> what are the contents of build/PARROT_REVISION ?

[01:18] <wayland76> Why do my lambdabot messages keep returning from the dead?

[01:18] <skids> waylang76: try @clear

[01:18] <skids> skids: trying typing slower

[01:18] <wayland76> I've done @clear on at least 3 separate days

[01:18] <dextius> 39019

[01:18] <pmichaud> hmmm.

[01:19] <pmichaud> At NPW we also someone with problems building Rakudo under Darwin.

[01:19] <pmichaud> *also had someone

[01:20] <dextius> I watched a bunch of the videos from NPW on iTunes, looks like you guys had a nice time..

[01:20] <pmichaud> It was very cool, yes.

[01:21] <pmichaud> dextius: I don't have any quick answers, I'm afraid.  You may have stumbled upon a Parrot bug that is going to take a bit of time to locate and resolve.

[01:21] <dextius> hey, no problem, I dumped everything I've found to http://www.rakudo.org/node/43#comment-6 ... Thank you VERY much for your time/help.  I really want to learn and hopefully contribute some day.. Thanks again.

[01:21] <pmichaud> But I'll pass your bug report along to the Parrot developers -- there are several people there who are pretty quick about finding and fixing such things.

[01:21] * skids intuits some kind of compiler argument list construction foobar

[01:22] * dextius has to go take care of the dog.  buh-bye!

[01:22] <pmichaud> skids:  perhaps, but it looks as though it's having trouble loading the .so 

[01:22] *** dextius left
[01:22] <pmichaud> The "MutableVar" stuff is a dynpmc

[01:22] *** bacek joined
[01:23] <pmichaud> so it's failing during "Parrot_lib_perl6_group_load", which is the part that results from the .loadlib directive in perl6.pir

[01:23] <skids> Ah. probably it then. (but I've never been able to get something to even attempt to run without a dllib found)

[01:24] <skids> Though that's probably due to always doing proper error handling on dl import :-)

[01:24] <pmichaud> well, it's finding the .so okay -- it's just having trouble when initializing

[01:25] <skids> is there a way to build static?

[01:26] <pmichaud> not really

[01:26] <pmichaud> since they're dynpmcs, they're not part of parrot.

[01:28] * skids notes PARROT_NO_EXTERN_ENCODING_PTRS (and the violation of Parrot "no double negatives" coding guide)

[01:29] <pmichaud> I wonder what that is for....

[01:30] <pmichaud> oh, I see.

[01:31] <pmichaud> we should've found out from dextius what compiler he's using

[01:33] *** viirya joined
[01:33] *** wknight8111 left
[01:33] <pmichaud> my guess is that somehow Parrot_default_encoding_ptr isn't being initialized.

[01:34] <pmichaud> There's also a Parrot_default_encoding() function, but apparently it's never used.

[01:35] <skids> Parrot_fixed_8_encoding_ptr had a value, and that's what the macro is set to.

[01:38] <pmichaud> Hmmm.

[01:38] <pmichaud> I wonder what PARROT_DATA ended up being defined as.

[01:41] <pmichaud> maybe getting a copy of his include/parrot/config.h would yield some clues.

[01:41] <pmichaud> anyway.

[01:41] <pmichaud> gotta pack for a trip tomorrow.

[01:42] <skids> bon voyage!

[01:43] <Infinoid> gah, dextius triggered the encoding/charset race condition

[01:44] *** IRSeekBot left
[01:44] <skids> .oO(reliably, it seems)

[01:45] <Infinoid> wait, no he didn't, that isn't the init race.  That might be an export/linker issue

[01:45] <pmichaud> Yes, I think it's more likely an export/linker issue.

[01:45] <pmichaud> Because at the time this occurs, Parrot is already running and has started processing perl6.pir

[01:45] <pmichaud> (and is at the stage of performing the .loadlib)

[01:45] <Infinoid> and has a valid Parrot_fixed_8_encoding_ptr (within the core, at least)

[01:46] <pmichaud> although since the encoding isn't coming from the library being loaded.... well, that's just weird.

[01:47] <Infinoid> yeah.  something's off there

[01:57] *** kst` is now known as kst

[02:04] *** dukeleto left
[02:04] *** dukeleto joined
[02:36] *** lichtkind left
[02:40] *** sri_kraih joined
[02:40] *** ElectricHeavyLan left
[02:56] *** sri_kraih_ left
[02:57] *** Chillance left
[03:03] <meppl> good night

[03:07] *** meppl left
[03:08] *** frew|wor2 joined
[03:20] *** donaldh left
[03:20] *** donaldh joined
[03:25] *** alester_ joined
[03:30] <s1n> any idea what "Null PMC access in can()" might imply?

[03:30] <skids> That there's a bug in can()?

[03:31] *** nsh left
[03:31] <dukeleto> howdy

[03:32] <skids> OH HAI

[03:34] <s1n> i think i found it, lemme see if i can reproduce

[03:35] <s1n> here we go

[03:36] <s1n> rakudo: $test.say; my $test = 5;

[03:36] <p6eval> rakudo 5ed6da: OUTPUT«Null PMC access in can()␤in Main (/tmp/4ovG5cGhvE:1)␤»

[03:36] <s1n> that's not quite the error i was expecting

[03:36] <s1n> rakudobug?

[03:41] *** orafu left
[03:47] *** orafu joined
[03:56] *** frew|wor2 left
[03:57] *** frew|wor2 joined
[03:59] *** frew|wor1 left
[04:02] *** frew|wor1 joined
[04:03] *** kst left
[04:03] *** kst joined
[04:27] *** alester__ joined
[04:27] *** alester_ left
[04:47] *** cspencer joined
[04:52] <eternaleye> rakudo: multi infix:<union>( List *@sets ) { my %result; @sets.map: ->$list { @($list).map: -> $item { %result{$item} = 1; }; }; return %result.keys; }; say (1, 2, 3, 4) union (1, 7, 3, 8);

[04:52] <p6eval> rakudo 5ed6da: OUTPUT«123478␤»

[04:53] <eternaleye> mmm, tasty set theory

[04:55] <eternaleye> rakudo: multi infix:<intersection>( List *@sets ) { my %result; @sets.map: ->$list { @($list).map: -> $item { %result{$item}++; }; }; my @answer; for %result.kv -> $key, $value { @answer.push( $key ) if $value == @sets.elems; }; return @answer; }; say (1, 2, 3, 4) intersection (1, 7, 3, 8);

[04:55] <p6eval> rakudo 5ed6da: OUTPUT«␤»

[04:55] <eternaleye> hm

[04:55] <eternaleye> rakudo: multi infix:<intersection>( List *@sets ) { my %result; @sets.map: ->$list { @($list).map: -> $item { %result{$item}++; }; }; my @answer; for %result.kv -> $key, $value { @answer.push( $key ) if $value == @sets.elems + 1; }; return @answer; }; say (1, 2, 3, 4) intersection (1, 7, 3, 8);

[04:55] <p6eval> rakudo 5ed6da: OUTPUT«␤»

[04:55] <eternaleye> rakudo: multi infix:<intersection>( List *@sets ) { my %result; @sets.map: ->$list { @($list).map: -> $item { %result{$item}++; }; }; my @answer; for %result.kv -> $key, $value { @answer.push( $key ) if $value == @sets.elems - 1; }; return @answer; }; say (1, 2, 3, 4) intersection (1, 7, 3, 8);

[04:56] <p6eval> rakudo 5ed6da: OUTPUT«␤»

[04:57] <eternaleye> rakudo: multi infix:<intersection>( List *@sets ) { my %result; @sets.map: ->$list { @($list).map: -> $item { %result{$item}++; }; }; my @answer; for %result.kv -> $key, $value { say "$key: $value -- {@sets.elems}" }; return @answer; }; say (1, 2, 3, 4) intersection (1, 7, 3, 8);

[04:57] <p6eval> rakudo 5ed6da: OUTPUT«1: 2 -- 8␤2: 1 -- 8␤3: 2 -- 8␤4: 1 -- 8␤7: 1 -- 8␤8: 1 -- 8␤␤»

[04:58] <eternaleye> Ah, it's flattening

[04:58] <eternaleye> rakudo: multi infix:<intersection>( List *@sets ) { my %result; @sets.map: ->$list { @($list).map: -> $item { %result{$item}++; }; }; my @answer; for %result.kv -> $key, $value { @answer.push( $key ) if $value == @sets.elems; }; return @answer; }; say [1, 2, 3, 4] intersection [1, 7, 3, 8];

[04:58] <p6eval> rakudo 5ed6da: OUTPUT«13␤»

[04:58] *** frew|wor2 left
[04:58] <eternaleye> rakudo: multi infix:<intersection>( Array *@sets ) { my %result; @sets.map: ->$list { @($list).map: -> $item { %result{$item}++; }; }; my @answer; for %result.kv -> $key, $value { @answer.push( $key ) if $value == @sets.elems; }; return @answer; }; say (1, 2, 3, 4) intersection (1, 7, 3, 8);

[04:59] <p6eval> rakudo 5ed6da: OUTPUT«Parameter type check failed; expected something matching Array() but got something of type List() for @sets in call to infix:intersection␤in sub infix:intersection (/tmp/2lSB7QALap:1)␤called from Main (/tmp/2lSB7QALap:1)␤»

[04:59] *** wayland_ joined
[04:59] <eternaleye> By the way, in my example above using List *@sets and passing in ()'d args, were those lists really supposed to flatten?

[05:00] <eternaleye> (the reason I used a slurpy was because in my head is was assoc<chain>)

[05:00] <eternaleye> *it

[05:01] *** wayland76 left
[05:03] *** frew|work left
[05:06] *** wayland_ is now known as wayland76

[05:07] <wayland76> rakudo: multi infix:<∪>( List *@sets ) { my %result; @sets.map: ->$list { @($list).map: -> $item { %result{$item} = 1; }; }; return %result.keys; }; say (1, 2, 3, 4) ∪ (1, 7, 3, 8);

[05:07] <p6eval> rakudo 5ed6da: OUTPUT«123478␤»

[05:08] <wayland76> I think I like that :)

[05:11] <wayland76> So, are you volunteering to write Sets.pm ?

[05:11] *** cspencer left
[05:15] <eternaleye> Sure, just give me a bit to learn set theory first ;D

[05:16] <eternaleye> Although, subset and superset are easy. all() ~~ any() and vice versa.

[05:17] <eternaleye> With the benefit of autothreading, unlike a nested loops subset check.

[05:17] *** skids left
[05:18] *** masak joined
[05:21] <eternaleye> Ooh, interesting thought: my Set integers = Set.new( seed => 0, up-generator => sub { $^a + 1 }, down-generator => sub { $^a - 1 } );

[05:21] <eternaleye> Double-ended lazy list :D

[05:22] <eternaleye> Implementing subset of _that_ would probably be difficult, but rewarding

[05:23] <eternaleye> Of course, some mathematical wise guy'll probably try 'ok( $integers subset $real-numbers )'

[05:24] <eternaleye> "My thesis: Proving cardinality through Perl 6 one-liners"

[05:24] *** szabgab joined
[05:32] <masak> Peano would have been proud.

[05:36] <eternaleye> rakudo: multi infix:<exclusion>( List *@sets ) { my %result; @sets.map: ->$list { @($list).map: -> $item { %result{$item}++; }; }; my @answer; for %result.kv -> $key, $value { @answer.push( $key ) if $value == 1; }; return @answer; }; say [1, 2, 3, 4] exclusion [1, 7, 3, 8];

[05:37] <p6eval> rakudo 5ed6da: OUTPUT«2478␤»

[05:37] <eternaleye> I love how most of these only require changing the name and a single term (or maybe one expression)

[05:43] <eternaleye> rakudo: multi infix:<subset> ( @sub, @super ) { all(@sub) ~~ any(@super) ?? return( Bool::True ) !! return( Bool::False ); }; multi infix:<superset>( @super, @sub ) { @sub Rsubset @super }; say [1, 2, 3] subset [0, 1, 2, 3, 4]; say [1, 2, 3] superset [0, 1, 2, 3, 4]

[05:43] <p6eval> rakudo 5ed6da: OUTPUT«1␤1␤»

[05:43] <eternaleye> Hm.

[05:44] <eternaleye> Oh wait...

[05:44] <eternaleye> rakudo: multi infix:<subset> ( @sub, @super ) { all(@sub) ~~ any(@super) ?? return( Bool::True ) !! return( Bool::False ); }; multi infix:<superset>( @super, @sub ) { @super Rsubset @sub }; say [1, 2, 3] subset [0, 1, 2, 3, 4]; say [1, 2, 3] superset [0, 1, 2, 3, 4]

[05:44] <p6eval> rakudo 5ed6da: OUTPUT«1␤0␤»

[05:45] <wayland76> Maybe you could write some perl code that generates Set.pm :)

[05:45] <eternaleye> Metaops on custom ops, enabling sugar everywhere ;D

[05:45] <eternaleye> wayland76: That's way cooler than I could possibly accomplish!

[05:46] <wayland76> Did you read Dluglosz article on APL?

[05:46] <eternaleye> Not yet, where?

[05:47] <wayland76> http://www.dlugosz.com/Perl6/web/  and click the "APL" one

[05:47] <wayland76> s/Dluglosz/Dlugosz/

[05:47] *** JDlugosz joined
[05:48] <wayland76> JDlugosz: We were just talking about you :)

[05:48] <JDlugosz> Hey, everyone...

[05:48] <lambdabot> JDlugosz: You have 2 new messages. '/msg lambdabot @messages' to read them.

[05:48] <JDlugosz> lambdabot:  really?

[05:48] <wayland76> Did you know that, or did you just turn up now by coincidence?

[05:48] <JDlugosz> I was wondering... why was failover of method calls to subs removed (in August)?

[05:49] <JDlugosz> No, just coincedence.  I needed to ask a question.  Noticed client wasn't running.

[05:49] <wayland76> Ok :)

[05:49] <masak> JDlugosz: oh hai. reading your latest article right now.

[05:49] <masak> I like it. thanks for writing it.

[05:49] <JDlugosz> masak:  updating it from remarks as we speak.

[05:50] <JDlugosz> Found a few problems with the Syn along the way.  Like failover change not updating ANY other docs.

[05:50] <masak> JDlugosz: I have a slight nit, then: we tend to write S04<77> as S04:77. if you go to the logs, you'll even find that this latter syntax turns into links into the respective spec.

[05:50] <wayland76> Yeah, JDlugosz, I can write stuff, but you've done a really good job there.  I'd be keen to see stuff like yours as part of any official tutorials we have :)

[05:51] <JDlugosz> I'd be glad for it.  You know, I used to write a lot for magazines, back when they were pleantiful.

[05:51] <JDlugosz> Have you looked at any of the others around that directory?

[05:51] <wayland76> I wondered; masak, am I correct in thinking that you're thinking 77 refers to a line number -- and is JDlugosz referring to that, or to a version number?

[05:52] <wayland76> I read over the APL one, but I haven't read the others.  

[05:52] <masak> wayland76: oh, I assumed line number.

[05:52] <JDlugosz> That is the synax for version, mimicing the module version for use.

[05:52] <masak> aha. I see.

[05:52] <masak> no need to change, then.

[05:52] <JDlugosz> I put the pop-up there for those who don't know that convention.  Love that hypertext.

[05:52] <wayland76> S04<77>:31 :)

[05:53] <eternaleye> Oh, that's an interesting thought.

[05:53] <JDlugosz> BTW, what's the lambdabot message thing?

[05:53] <wayland76> lambdabot is a bot that will store messages for later

[05:53] <masak> JDlugosz: missed the pop-up, thought it was a link to the line. :P

[05:53] <JDlugosz> It's telling me I have messaages, but it's not giving them up.

[05:53] <wayland76> if you type the thing it says to type, then it will give you messages

[05:53] <eternaleye> rakudo: my @array = ( [1,2,3], [4,5,6] ); say [[+]] @array

[05:53] <p6eval> rakudo 5ed6da: OUTPUT«say requires an argument at line 1, near " [[+]] @ar"␤in Main (src/gen_setting.pm:2400)␤»

[05:53] <eternaleye> Drat.

[05:53] <wayland76> lambdabot: @messages

[05:53] <lambdabot> You don't have any new messages.

[05:54] <JDlugosz> I copy/paste'd, and it didn't work.  Just showed @messages as a message.

[05:54] <masak> p6eval: that's not ever going to work. :)

[05:54] <masak> eternaleye: ^

[05:54] <eternaleye> Ah.

[05:54] <eternaleye> So the syntax for that is @array.map: { [+] $_ } ?

[05:54] <wayland76> JDlugosz: try just typing "lambdabot @messages", which will put them in the public channel (hopefully they're not private), and we can hopefully tell you what's going wrong

[05:55] <eternaleye> rakudo: my @array = ( [1,2,3], [4,5,6] ); say @array.map: { [+] $_ }

[05:55] *** dduncan joined
[05:55] <p6eval> rakudo 5ed6da: OUTPUT«1 2 34 5 6␤»

[05:55] <JDlugosz> The APL stuff was half joking, but serious in showing how you can warp things to your desire.

[05:55] <JDlugosz> OK...

[05:55] <JDlugosz> lambdabot @messages

[05:55] <eternaleye> rakudo: my @array = ( [1,2,3], [4,5,6] ); say @array.map: { [+] @( $_ ) }

[05:55] <p6eval> rakudo 5ed6da: OUTPUT«615␤»

[05:55] <wayland76> Put a colon after "lambdabot"

[05:55] <wayland76> (sorry)

[05:56] <JDlugosz> lambdabot: @messages

[05:56] <lambdabot> You don't have any new messages.

[05:56] <wayland76> I guess they must've gotten cleared.  I don't know what happened there

[05:56] <JDlugosz> OK, then why tell me I had 2?  Or did you think you told me already so they are not new?

[05:56] <eternaleye> rakudo: my @array = ( [1,2,3], [4,5,6] ); say [+] @array.map: { [+] @( $_ ) }

[05:56] <masak> I should add that lambdabot has been acting unreliably lately.

[05:56] <p6eval> rakudo 5ed6da: OUTPUT«21␤»

[05:56] <JDlugosz> Well, hopefully whoever it was will get back.

[05:56] <wayland76> Yes, my messages keep coming back after I @clear them

[05:57] <masak> wayland76: yes, that's one of the symptoms.

[05:57] <masak> wayland76: my guess is that someone will write a better bot in Perl 6 fairly soon.

[05:57] <eternaleye> Well, there's phenny++ IIRC

[05:57] <masak> aye.

[05:57] <masak> phenny: I keep forgetting about you. :)

[05:57] <JDlugosz> So, what do you think of all the wrapping that ()'s are doing, now that they are active object-creating elements?

[05:58] <wayland76> I can tell you the magic answer JDlugosz

[05:58] <JDlugosz> And does anybody know why the failover was removed?

[05:58] <wayland76> lambdabot was supposed to give you a message from TimToady saying "the lines() function already defaults to $*ARGFILES; that's its only advantage over the method form"

[05:59] <masak> JDlugosz: "Because of that, having whatever if .prime for 1..100 would be a suffix for a statement that already has a suffix, and that is not allowed." are you sure this isn't also old news?

[05:59] <masak> rakudo: .say if $_ % 2 for 1..10

[05:59] <JDlugosz> OK, thanks.

[05:59] <p6eval> rakudo 5ed6da: OUTPUT«1␤3␤5␤7␤9␤»

[05:59] <wayland76> And another one from TimToady that was supposed to say "yes, S11:573 specs the separate compilation principle that implies each modules starts in its own SETTING"

[06:00] <JDlugosz> masak:  I already changed it.  Lots of old clutter in the Synopses.

[06:00] <wayland76> Well, I hope we get to keep our karma with the new bot :)

[06:00] <JDlugosz> Thanks again, Wayland.

[06:00] <masak> JDlugosz: please make sure to keep a list of the cruft in the synopses too. :)

[06:01] <masak> JDlugosz: or just change them directly yourself.

[06:01] <JDlugosz> Now that I have commit bit, I don't need to keep a dusty list that nobody ever applies anyway.  Very frustrating, it was.

[06:01] <JDlugosz> I'll change the things I've found here this (long) weekend.

[06:01] <masak> JDlugosz++

[06:02] <JDlugosz> Along with a few I recall spotting before.  Have to diff my old edits from "offerings" that have grown mold.

[06:02] <wayland76> anyway, afk &

[06:02] * masak reads "the seat of spirit and courage"

[06:02] <masak> wonderful.

[06:03] <JDlugosz> Larry ^^^^ Why was "failover to subs" removed, in August?  Problem getting rules to work in general (I recall working on that), or an overwhelimg issues that killed it?

[06:03] <JDlugosz> Thanks, masak.  Turns out someone can live without a spleen after all.

[06:03] <masak> aye. :)

[06:04] <JDlugosz> Notice all the other biology refs?  I changed others, like "under the hood" to conform, "under the skin".

[06:04] <masak> oh, nice.

[06:05] *** viirya left
[06:07] <masak> JDlugosz: I, for one, am happy that failover is gone. I'm not sure exactly why it did go away, but it feels very much like a p5ism, and not consistent with the fairly strict OO-ish bits of p6.

[06:07] *** dduncan left
[06:08] <JDlugosz> failover is more consistent with generic functions a'la MMD, like in CLOS etc.  invocant syntax doesn't work if the invokant is in the middle or multiple.

[06:08] <masak> JDlugosz: TimToady sort of gave a reason in an email from Feb 20: "Anyway, we're trying to maximize flexibility while also giving the compiler as much information as possible to feed the optimizer. So fallbacks are not in vogue these days."

[06:08] <JDlugosz> And you can say .prime instead of prime($_).

[06:09] <masak> JDlugosz: to me, that looks tantamount to monkey patching.

[06:10] <JDlugosz> That makes sense.  Tracking a known static type of a class is one thing, but you lost the ability to give compile-time errors if it must look for more functions at run-time anyway.

[06:10] <masak> JDlugosz: you might also want to check out the speculations by TimToady in an email from Mar 5.

[06:12] <JDlugosz> which year?

[06:12] <masak> this one. 2009.

[06:12] <JDlugosz> The change was made in August.

[06:12] <masak> they were.

[06:12] <masak> the speculation came afterwards.

[06:13] <JDlugosz> OK, I'll look back.

[06:13] <masak> and I'm not sure they're directly related. just pointing you to the latest thoughts about subs and methods.

[06:23] <masak> JDlugosz: as to which bracket-like signs show up on my system, I can see all but the second-last pair just fine. I'm on Mac OS X 10.5.7.

[06:23] <JDlugosz> The 567 doesn't show?

[06:24] <masak> it doesn't.

[06:24] <masak> oh, "Sorry, you asked?" shouldn't have the comma.

[06:25] <JDlugosz> Sorry, thanks.  <g>.

[06:30] <JDlugosz> OK, I updated that essay.  Might need polishing where I changed things, but should have fixed everything that was noted.

[06:30] <JDlugosz> If anyone wants to take a fresh look.

[06:31] *** JDlugosz left
[06:31] <masak> my tuits ran out for now, but I will come back to it in a few days.

[06:33] *** finanalyst joined
[06:34] *** alester__ left
[06:42] *** kst left
[06:43] <eternaleye> Drat, he left

[06:43] *** kst joined
[06:43] <eternaleye> @tell JDlugosz Your article says: ...just like 2+(3+4) has parentheses that group it the same way it was going to do anyway.

[06:43] <lambdabot> Consider it noted.

[06:43] <masak> eternaleye: use phenny! :)

[06:44] <eternaleye> I don't know her syntax, and when I PM'd every help invocation I could think of she didn't respond

[06:45] <masak> phenny: msg eternaleye is this the right syntax?

[06:45] <masak> hm. seems not.

[06:45] <eternaleye> I'll look it up in the logs

[06:46] <masak> ah -- http://inamidst.com/phenny/

[06:46] <masak> tell eternaleye so this is the syntax?

[06:46] <masak> phenny: tell eternaleye so this is the syntax?

[06:46] <phenny> masak: I'll pass that on when eternaleye is around.

[06:46] <masak> ah.

[06:46] <eternaleye> Aha!

[06:46] <masak> phenny++

[06:46] <phenny> eternaleye: 06:46Z <masak> tell eternaleye so this is the syntax?

[06:47] <eternaleye> Does that Z mean Zulu time?

[06:48] <masak> Zebra time.

[06:49] <eternaleye> Heh, April 28: 13:50

[06:49] <eternaleye> 	masak

[06:49] <eternaleye> 	phenny: pleased to meet you. I will use you for @telling next time.

[06:50] <eternaleye> You liedz!

[06:50] <masak> :)

[06:50] <masak> eternaleye: you mean I've been using lambdabot after that?

[06:50] <masak> that wouldn't surprise me...

[06:50] <masak> I should make a bot to remind me when I'm using the wrong bot.

[06:51] <wayland76> phenny: help me!!!

[06:51] <eternaleye> Well, I seem to have accidentally the whole search function, so...

[06:51] <wayland76> The thing I like about Lambdabot is that it has useful help

[06:52] <wayland76> That's why I like it better than other bots :)

[06:53] <masak> yes, useful help is a really worthwhile feature in a bot.

[06:53] <masak> discoverability.

[06:54] <wayland76> Even lambdabot could be improved, but it's better than nothing :)

[06:55] *** justatheory joined
[06:55] <eternaleye> masak: Actually, you seem to have simply been in-channel when you wanted to tell someone something, and they backlogged

[06:55] <wayland76> s/ lambdabot / lambdabot's help/

[06:55] <eternaleye> You haven't used any bots in this channel since you said that to phenny

[06:55] <masak> eternaleye: :)

[06:55] <eternaleye> Well, except p6eval++

[06:56] *** DemoFreak joined
[06:56] <masak> p6eval: you're my favourite bot of them all!

[06:56] <eternaleye> @karma p6eval

[06:56] <lambdabot> p6eval has a karma of 1

[06:56] <eternaleye> lambdabot: p6eval += 3

[06:56] <eternaleye> @karma p6eval

[06:56] <lambdabot> p6eval has a karma of 1

[06:56] <eternaleye> :(

[06:57] <masak> rakudo: say $*IN.words.grep({$_ eq .ucfirst}).join(' ')

[06:57] <p6eval> rakudo 5ed6da: OUTPUT«IO()<0xb62232f8>␤»

[06:57] <masak> hm.

[06:57] <masak> rakudo: say $*IN.slurp.words.grep({$_ eq .ucfirst}).join(' ')

[06:57] <p6eval> rakudo 5ed6da: OUTPUT«Land Berge, Land Strome, Land Äcker, Land Dome, Land Hämmer, Heimat Söhne, Volk, Schöne, Österreich, Österreich! Heiß Erdteil Herzen Hast Ahnentagen Sendung Last Österreich, Österreich! Mutig Zeiten, Einig Brüderchören, Vaterland, Treue Österreich, Österreich!␤»

[06:58] <masak> Austrian national anthem, all nouns pulled out. :)

[07:00] <eternaleye> rakudo: say $*IN.words.grep( *.comb.pick(*) ).join('')

[07:00] <p6eval> rakudo 5ed6da: OUTPUT«␤»

[07:00] <eternaleye> rakudo: say $*IN.words.grep( { .comb.pick(*) } ).join('')

[07:00] <p6eval> rakudo 5ed6da: OUTPUT«IO()<0xb62942f8>␤»

[07:00] <eternaleye> rakudo: say $*IN.slurp.words.grep( *.comb.pick(*) ).join('')

[07:00] <p6eval> rakudo 5ed6da: OUTPUT«␤»

[07:01] <eternaleye> rakudo: say $*IN.slurp.words.grep( { .comb.pick(*) } ).join('')

[07:01] <p6eval> rakudo 5ed6da:  ( no output )

[07:01] <eternaleye> oh wait

[07:01] <eternaleye> rakudo: say $*IN.slurp.words.map( { .comb.pick(*) } ).join('')

[07:01] <p6eval> rakudo 5ed6da:  ( no output )

[07:02] <masak> rakudo: say $*IN.slurp.words.sort.[^50].join

[07:02] <p6eval> rakudo 5ed6da:

[07:02] <p6eval> ..OUTPUT«AhnentagenBerge,Brüderchören,Dome,EinigErdteilHastHeimatHeißHerzenHämmer,LandLandLandLandLandLastMutigSchöne,SendungStrome,Söhne,TreueVaterland,Volk,Zeiten,amarbeitsfrohbegnadetbistdasdemderderderderdiedirdudueinemfreifrühenfürgetragen,gleich.gläubiggroßerhoffnungsreich.hoher␤»

[07:02] <masak> oops.

[07:02] <eternaleye> Song soup!

[07:03] <masak> rakudo: say $*IN.slurp.words.sort({.lc}).[^50].join(' ')

[07:03] <p6eval> rakudo 5ed6da: OUTPUT«Ahnentagen am arbeitsfroh begnadet Berge, bist Brüderchören, das dem der der der der die dir Dome, du du einem Einig Erdteil frei frühen für getragen, gleich. gläubig großer Hast Heimat Heiß Herzen hoffnungsreich. hoher Hämmer, in in inmitten, Land Land Land Land Land Last laß

[07:03] <p6eval> ..lieg…

[07:03] <eternaleye> rakudo: say $*IN.slurp.map( { .comb.pick(*) } ).join('')

[07:03] <p6eval> rakudo 5ed6da:  ( no output )

[07:03] * masak likes the 'das dem der der der der die dir' part

[07:03] <eternaleye> rakudo: say $*IN.slurp.map( { .comb.pick(3) } ).join('')

[07:04] <p6eval> rakudo 5ed6da: OUTPUT«ear␤»

[07:04] <eternaleye> rakudo: say $*IN.slurp.words.map( { .comb.pick(99) } ).join('')

[07:04] <p6eval> rakudo 5ed6da:  ( no output )

[07:04] <eternaleye> rakudo: say $*IN.slurp.words.map( { .comb.pick(3) } ).join('')

[07:04] <masak> 'ear'?

[07:04] <p6eval> rakudo 5ed6da:  ( no output )

[07:04] <eternaleye> rakudo: say $*IN.slurp.map( { .comb.pick(3) } ).join('')

[07:04] <wayland76> Where does the input come from?

[07:04] <p6eval> rakudo 5ed6da: OUTPUT«emm␤»

[07:04] <eternaleye> rakudo: say $*IN.slurp.words.map( { .comb.pick(3) } ).join('')

[07:04] <masak> wayland76: Austria. :)

[07:04] <p6eval> rakudo 5ed6da:  ( no output )

[07:05] <eternaleye> Huh?

[07:05] <eternaleye> rakudo: say $*IN.slurp.map( { .comb.pick(3) } ).join('')

[07:05] <wayland76> Where abouts in Australia (ie. you know what I mean :) )

[07:05] <p6eval> rakudo 5ed6da: OUTPUT«Z f␤»

[07:05] <eternaleye> rakudo: say $*IN.slurp.words.map( { .comb.pick(*) } ).join('')

[07:05] <wayland76> (s/Australia/Austria/ -- stupid fingers)

[07:05] <p6eval> rakudo 5ed6da:  ( no output )

[07:05] <eternaleye> rakudo: say $*IN.slurp.words.map( { .comb.pick(20) } ).join('')

[07:05] <p6eval> rakudo 5ed6da:  ( no output )

[07:05] <masak> wayland76: http://svn.pugscode.org/pugs/misc/evalbot/evalbot.pl

[07:06] <eternaleye> Grr, y inputline is not cooperating

[07:06] <eternaleye> rakudo: say $*IN.slurp.map( { .comb.pick(*) } ).join('')

[07:06] <p6eval> rakudo 5ed6da:  ( no output )

[07:06] <eternaleye> rakudo: say $*IN.slurp.map( { .comb.pick(20) } ).join('')

[07:06] <p6eval> rakudo 5ed6da:  ( no output )

[07:06] <masak> eternaleye: I don't know what you're trying to do... but it's not working.

[07:07] <eternaleye> I realize, but have no clue why

[07:07] <eternaleye> I'm trying to get a jumbled mess of letters, but it's not working :(

[07:07] <masak> eternaleye: slurp is one item, so no use running map on that.

[07:07] <eternaleye> Well, they why is the words one giving nothing?

[07:07] <eternaleye> *then

[07:08] <eternaleye> rakudo: say $*IN.slurp.comb.pick(*).join('')

[07:08] <p6eval> rakudo 5ed6da:  ( no output )

[07:08] <masak> rakudo: print .comb.pick(*), " " for $*IN.slurp.words

[07:09] <p6eval> rakudo 5ed6da: OUTPUT«Lnda erd eBr,ge dnLa am omtr,Se naLd dre kÄrec, adnL erd mDe,o aLdn dre mm,eräH kszife!thucnru ateHim bsti du oßrger Sn,höe ,oVkl teaenbdg rüf dsa n,hSöce telhisveregüm cri,rhÖseet meeüehtlrgivs !eshrctiÖre ißeH de,fmtehu iwld ntrsetumit sielgt edm tlreidE du nntitie,m einme

[07:09] <p6eval> ..arntse…

[07:09] <masak> there you go.

[07:09] <eternaleye> Weird. Is there a limit on chaining method calls?

[07:09] <masak> no.

[07:09] <masak> you just have to do it right. :P

[07:20] *** donaldh left
[07:21] *** donaldh joined
[07:21] *** justatheory left
[07:29] <eternaleye> phenny: tell JDlugosz that the 567 quotes show as unicode-numbered quads on my system in Firefox, but that's a font issue with Serif rather than anything in the OS

[07:29] <phenny> eternaleye: I'll pass that on when JDlugosz is around.

[07:30] <eternaleye> phenny: tell JDlugosz (that's amd64 Gentoo, firefox 3.1beta)

[07:30] <phenny> eternaleye: I'll pass that on when JDlugosz is around.

[07:36] *** justatheory joined
[07:37] *** justatheory left
[07:55] <Matt-W> Morning

[07:56] * masak tips hat

[08:02] * Matt-W looks in the hat for tips

[08:02] <masak> :P

[08:02] <masak> I'm going away for the weekend; will be back on Sunday evening.

[08:03] *** DemoFreak left
[08:03] <Matt-W> I'm going away for the weekend as well

[08:04] <Matt-W> Train tonight, then a day of music tomorrow followed by a barbecue, then some awkward family time

[08:04] *** bacek left
[08:04] <masak> I'll be celebrating the arrival of spring with some fellow Esperanto youngsters.

[08:05] <Matt-W> And probably a lot of pointless questioning from my parents over what's happening with my car, as if I've found out any more information during five minutes when I haven't had any phone calls

[08:07] <Matt-W> Hmm so no speaking Swedish or English allowed then

[08:08] <masak> Matt-W: we're not very draconian. we like languages, that's all. most people do prefer Esperanto, though.

[08:08] <masak> especially because it's an international context, where not everyone may feel included if Swedish or English is spoken.

[08:09] <Matt-W> Well Esperanto is the common language, really

[08:09] <Matt-W> And the reason you're all there

[08:09] <masak> aye.

[08:09] <Matt-W> And a good chance to practise your spoken Esperanto with lots of people

[08:09] <masak> exactly.

[08:09] <masak> well, gotta go.

[08:10] * masak waves

[08:10] *** masak left
[08:14] *** zpmorgan_ left
[08:16] *** jferrero joined
[08:22] *** payload joined
[08:39] *** dakkar joined
[08:54] *** tulcod joined
[09:04] *** spx2 left
[09:06] *** jiing_ joined
[09:20] *** payload left
[09:23] *** bacek joined
[09:24] *** payload joined
[09:26] *** M_o_C joined
[09:55] *** jan___ left
[10:14] *** riffraff joined
[10:23] *** icwiener joined
[10:26] *** jrockway left
[10:26] *** jrockway joined
[10:26] *** ZuLuuuuuu joined
[10:34] *** bacek left
[10:36] *** bacek joined
[10:40] *** payload left
[10:41] *** payload joined
[10:59] *** payload left
[11:17] *** clintongormley joined
[11:20] *** donaldh left
[11:20] *** donaldh joined
[11:20] *** bacek left
[11:20] *** bacek joined
[11:26] *** bacek_ joined
[11:26] *** bacek_ left
[11:29] *** ssm joined
[11:37] *** payload joined
[11:43] *** pmurias joined
[11:49] <dalek> rakudo: 5eac9bd | pmichaud++ | build/PARROT_REVISION:

[11:49] <dalek> rakudo: Bump PARROT_REVISION so we get the smarter "variable not predeclared" messages.

[11:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5eac9bda84c6e33b2b583519f161d54d900d57df

[11:49] *** bacek left
[11:50] *** skids joined
[11:59] *** fridim_ joined
[12:02] *** kst left
[12:02] *** kst joined
[12:12] * skids gets Nigerian spam saying it wants to compensate me for funds lost due to falling for Nigerian spam scams.

[12:12] <skids> Does that mean spam has jumped the shark?

[12:14] <jnthn> No, it just means we should send sharks to eat Nigerian scammers.

[12:20] <wayland76> I think we'd be better of setting the sharks on the Somali pirates, and finding a way to send something else to the Nigerian scammers.  Maybe grizzly bears or elephants.  No, I have it!  Klingons!

[12:23] <skids> Or Somali pirates...

[12:24] *** jlaire joined
[12:27] <wayland76> Now that would be a feat :)

[12:30] *** mizioumt joined
[12:32] <Matt-W> Well all these scammers are in possession of vast sums of money as inheritances

[12:33] <Matt-W> So you just need to get them to put it all on a boat

[12:33] <Matt-W> And sail it past Somalia at a tempting speed

[12:34] <skids> They are all officials or royalty, so just their own presence as valuable hostages should do :-)

[12:35] <Matt-W> But they're even more valuable if they come with gold and jewels included, rather than having to buy them afterwards

[12:35] <wayland76> Hmm.  So when we receive Nigerian Spam, we should say we've just gotten free cruise tickets, and we'll meet them on the boat... :)

[12:36] <skids> Matt-W: or just safe deposit box keys that they swear contain the wealth of ages

[12:37] <wayland76> I love Pobox.com.  I get so little Spam these days that it's not a real problem :)

[12:38] <wayland76> Admittedly, I have to do something about the false positives from time to time :)

[12:39] <skids> I just greylist + dnsbl, it lets enough through so I have a random sampling to amuse myself. but not enough to be burdensome.

[12:39] <wayland76> Yeah, greylist would be nice :)

[12:40] <pugs_svn> r26903 | moritz++ | [t] move closure_traits/* to spec/

[12:40] <pugs_svn> r26904 | moritz++ | [t] merge regex/context.t into spec/S05-modifier/pos.t

[12:40] <pugs_svn> r26905 | moritz++ | [t] remove regex test which is outdated and flawed in multiple ways

[12:40] <skids> (spammers peform a valuable service after all, they are the keepalive packets of the mail system :-)

[12:40] <pugs_svn> r26906 | moritz++ | [t] move spaceship.t to spec/, minor corrections and fudging for rakudo

[12:40] <pugs_svn> r26907 | moritz++ | [t] move subscript.t to spec

[12:40] <pugs_svn> r26908 | moritz++ | [t] move lt.t to spec/

[12:40] <pugs_svn> r26909 | moritz++ | [t] improve parens.t a bit

[12:40] <wayland76> I receive spam, therefore I am?

[12:40] <clintongormley> i used to host my own mail, and just bounced all mails with spam assassin score > $x

[12:40] <pugs_svn> r26910 | moritz++ | [t] explain why syntax/signature.t is flawed

[12:40] <clintongormley> now moved to google, and after a month, checked my junk folder: 12,000 emails!

[12:41] <wayland76> On the ISP I do some admin for, we reject anything that scores above 40

[12:41] <wayland76> And filter anything that scores above 5 into a separate folder

[12:41] <wayland76> (or we did; the rejecting above 40 part might be broken at the moment)

[12:49] *** payload left
[12:49] *** payload1 joined
[12:52] *** abra joined
[12:55] *** cspencer joined
[12:55] *** payload1 left
[12:59] <Matt-W> rakudo: say [1, 2] X [1, 2]

[13:00] <p6eval> rakudo 5eac9b: OUTPUT«1 21 2␤»

[13:00] *** payload joined
[13:01] <skids> rakudo: say (1,2)X(1,2); my @a = (1,2); say @a X @a;

[13:01] <p6eval> rakudo 5eac9b: OUTPUT«11122122␤11122122␤»

[13:02] *** riffraff left
[13:03] <skids> rakudo: say [1, 2] Z [1, 2]

[13:03] <p6eval> rakudo 5eac9b: OUTPUT«1122␤»

[13:07] <PerlJam> good morning #perl6

[13:07] <Matt-W> good afternoon PerlJam 

[13:15] *** presh joined
[13:18] *** Chillance joined
[13:20] *** jferrero left
[13:35] *** justatheory joined
[13:36] *** [particle] joined
[13:46] *** cspencer left
[13:47] <TimToady> rakudo: say 1,2 Z 1,2

[13:47] <p6eval> rakudo 5eac9b: OUTPUT«1122␤»

[13:47] <TimToady> rakudo: say 1,2 X 1,2

[13:47] <p6eval> rakudo 5eac9b: OUTPUT«11122122␤»

[13:48] <TimToady> rakudo is correct on []X[] but not []Z[]

[13:48] <Matt-W> that's not correct??

[13:49] <TimToady> Z should treat [] as a single value

[13:49] <TimToady> just as X does

[13:49] <Matt-W> oh

[13:50] <TimToady> list infixes expect to infix lists :)

[13:50] *** M_o_C left
[13:53] *** justatheory left
[13:54] <Matt-W> there's a certain sense to that

[13:54] <Matt-W> :)

[13:55] *** M_o_C joined
[13:55] <Trey> What's the current idiom for P5 "while (<>) { say }" ?

[13:57] <PerlJam> Trey: do you mean a literal <> there, or was that <> meant to stand for reading a line from any filehandle?

[13:58] <Trey> PerlJam: Either.  Both.

[14:00] <PerlJam> .say for $filehandle.lines  # maybe

[14:00] <TimToady> for lines() {.say} is supposed to work

[14:00] <PerlJam> (also depends on if you really meant say there too and the status of autochomping, etc.)

[14:01] <Trey> i remember when it was for =<> { .say } and realized with = no longer iterating that that couldn't work

[14:01] <PerlJam> TimToady: The lines sub does the equivalent of reading from STDIN or files given on the command line?

[14:02] <TimToady> it defaults to $*ARGFILES, which does that

[14:02] <PerlJam> gotcha

[14:02] <PerlJam> same for get() I take it?

[14:03] <Trey> = as iterator went away why?  i think that happened when my head was in the sand somewhere....

[14:03] <TimToady> I suppose, though we're trying to encourage list processing

[14:04] <TimToady> we lost it somewhere in Norway

[14:04] <Trey> makes sense.  it's got a big groove there that can get caught in the ice.

[14:04] <TimToady> after we discovered that it was really ugly to teach as the first thing new Perl programmers see :/

[14:04] *** payload left
[14:05] <Trey> so now any iterator in scalar context iterates.

[14:05] <Trey> and if you want the iterator itself...

[14:05] <TimToady> no

[14:05] <TimToady> $iterator.net

[14:05] <TimToady> .get

[14:06] <TimToady> that what $*IN.get is really

[14:06] <PerlJam> get and lines bother me as the universal iterator interface for some reason but I don't have anything specific to propose  :)

[14:06] <TimToady> it's an on-purpose symmetry breaking

[14:06] <Trey> ahh.  i see.

[14:06] * Matt-W finds the idea of lines() working without an object slightly disquieting

[14:07] <TimToady> get is a verb because it's essentially procedural

[14:07] <TimToady> but lines is a noun because it's essentially FP

[14:07] <skids> rakudo: sub infix:<X> (List *@slurp) { @slurp.join("#") }; ((1,2) X (3,4) X (5,6)).say # <-- why we can't just move Z and X to setting yet.

[14:07] <p6eval> rakudo 5eac9b: OUTPUT«1#2#3#4#5#6␤»

[14:07] <PerlJam> TimToady: I think I'd still like to see something like  $handle.gimme  (grab them all), and $handle.gimme(1)  or something

[14:08] <PerlJam> (luckily I have the option to create that myself  :)

[14:08] <TimToady> biab

[14:08] <Matt-W> I like $handle.lines()

[14:09] <Matt-W> Conceptually it's like $handle has everything inside it already

[14:09] <Matt-W> it doesn't matter if it's not been read from disc

[14:11] <skids> PerlJam: just ==> @a and use the array interface. (not that that works yet)

[14:12] *** finanalyst left
[14:13] *** payload joined
[14:14] <PerlJam> skids: I think I'm more opposed to having get/lines than having some alternate way to access them.  It just "feels" wrong.   I haven't done enough introspection on why, but it may just be because of my C background.

[14:15] *** ssm left
[14:15] <skids> (gdb) print _temp_multi_func_list.func_ptr

[14:15] <skids> $14 = @0x40868042: 0x407aca30 <Parrot_Undef_multi_is_equal_Undef>

[14:15] <skids> (gdb) print Parrot_Undef_multi_is_equal_Undef

[14:15] <skids> $15 = {INTVAL (Parrot_Interp, PMC *,  PMC *)} 0x407aca30 <Parrot_Undef_multi_is_equal_Undef>

[14:16] <skids> Can anyone explain why there's two pointers?

[14:18] <PerlJam> one for the undef multi and one for the "true" undef ?  

[14:18] <PerlJam> :)

[14:18] *** justatheory joined
[14:18] <skids> now how would gdb know that?

[14:20] * skids can't find reference to this @ notation in gdb docs.

[14:21] <skids> (but the @ value is the actual content of the member, just wondering by what mechanism 0x407aca30 is being derived.

[14:22] *** jferrero joined
[14:23] *** elmex left
[14:23] *** elmex joined
[14:30] *** alester left
[14:33] * skids tries to figure out WTF __JCR_LIST__ is.

[14:35] *** aindilis left
[14:47] <pugs_svn> r26911 | lwall++ | [pos.t] fix parsefail

[14:48] *** payload left
[14:50] *** exodist joined
[14:53] *** payload joined
[15:02] *** nihiliad joined
[15:07] *** [particle]1 joined
[15:18] *** pmurias left
[15:18] *** Chillance left
[15:18] *** pmurias joined
[15:20] *** donaldh left
[15:20] *** donaldh joined
[15:34] *** Psyche^ joined
[15:34] *** Patterner left
[15:34] *** Psyche^ is now known as Patterner

[15:39] *** ElectricHeavyLan joined
[15:50] *** pmurias left
[15:51] *** claytoris joined
[15:52] <claytoris> Hey does anyone know if k3151y comes in here often?

[15:56] *** claytoris left
[16:15] *** dakkar left
[16:16] *** alester joined
[16:18] *** iblechbot joined
[16:20] *** zostay joined
[16:25] *** zostay left
[16:26] *** zostay joined
[16:28] *** cdarroch joined
[16:37] *** zostay left
[16:37] *** zostay joined
[16:43] *** jferrero left
[16:44] *** justatheory left
[16:51] *** zostay left
[16:53] *** donaldh left
[16:58] *** zostay joined
[17:20] *** kst left
[17:21] *** kst joined
[17:21] *** ssm joined
[17:38] *** justatheory joined
[17:50] *** eternaleye left
[17:55] *** payload left
[18:03] *** mizioumt1 joined
[18:05] *** aindilis joined
[18:09] *** payload joined
[18:17] *** mizioumt left
[18:23] *** meppl joined
[18:27] *** pmurias joined
[18:51] *** justatheory left
[18:52] *** justatheory joined
[18:53] *** justatheory left
[18:54] *** mizioumt joined
[18:55] *** justatheory joined
[19:00] *** mizioumt2 joined
[19:10] <pmurias> how do i create a capture in perl6 which is a copy of $capture_orig except without the first positional

[19:10] *** mizioumt1 left
[19:15] *** mizioumt left
[19:16] *** icwiener_ joined
[19:18] *** icwiener left
[19:23] *** claytoris joined
[19:23] *** claytoris left
[19:24] <jnthn> pmurias: Perhaps something like \(|$capture_orig[1..*], |$capture_orig{}).

[19:25] *** DemoFreak joined
[19:26] <pmurias> perl6: (\foo => 1){}

[19:26] <rhr_> how about something like :($, |$new) := |$orig

[19:26] <p6eval> elf 26911: OUTPUT«Undefined subroutine &GLOBAL::prefix__92 called at (eval 123) line 3.␤ at ./elf_h line 5881␤»

[19:26] <p6eval> ..pugs:  ( no output )

[19:26] <p6eval> ..rakudo 5eac9b: OUTPUT«Method 'postcircumfix:{ }' not found for invocant of class 'Perl6Pair'␤»

[19:28] <pmurias> rhr_: i think |$new would capture the whole list then

[19:28] <rhr_> hmm

[19:28] *** sri_kraih left
[19:29] <jnthn> pmurias: Yeah, I'd got the impression too that if you write |$foo in a signature you get the lot too.

[19:31] <PerlJam> rhr_: you're binding, not copying too :)

[19:31] <PerlJam> but, I think something like :($, $copy) = |$orig;  ?

[19:32] <PerlJam> maybe

[19:32] <rhr_> dunno, I thought the sig/cap magic only happened for binding

[19:32] <icwiener_> I tried to build rakudo today but it just filled my ram and swap and then aborted. http://rafb.net/p/6TJ30W31.html

[19:32] <PerlJam> you can break down an array  [$first, *$rest] ... how do you do the same for captures?

[19:32] <icwiener_> Any idea how to solve that?

[19:34] <jnthn> icwiener_: What C compiler / platform?

[19:35] <icwiener_> GCC 4.3.3 on Debian GNU/Linux AMD64

[19:36] <jnthn> Hmm, nothing so unusual then.

[19:36] <pmurias> PerlJam: method addto (|$args ($self: @x)) {...} # quoting the synopsis

[19:36] <jnthn> I'm not really sure. I know that it can take quite a lot of ram to compile perl6.c since it contains a massive bytecode array.

[19:38] <icwiener_> I have a 3rd G RAM here but I usually do not use it since it runs on lower frequency. Do you think 2GB vs. 3GB makes the difference?

[19:38] <icwiener_> Unfortunately my swap is only 500 MB since I do not need it else.

[19:38] <jnthn> icwiener_: I've heard of it taking hundreds, but gigs is kinda...ouch.

[19:38] <icwiener_> Yupp.

[19:38] <icwiener_> It's like compiling Eclipse. ;)

[19:38] <jnthn> ;-)

[19:39] <icwiener_> Any ide how I can get more helpful output?

[19:39] <icwiener_> *idea

[19:39] <jnthn> You can try giving it more RAM, but I'm surprised it's using quite that much...

[19:39] <jnthn> There are efforts underway to generate the .c file differently.

[19:39] <jnthn> So that it won't require so much RAM>

[19:40] <jnthn> But different compilers get upset over different things, so it's proved non-trivial...

[19:40] <icwiener_> I understand.

[19:40] <jnthn> Did you build with the --gen-parrot option?

[19:41] <icwiener_> Yes.

[19:41] <jnthn> If you just want to turn Perl 6 and play with it a bit, you can still invoke Parrot with the bytecode file.

[19:41] <jnthn> Which in that case would look I think like

[19:41] <jnthn> ./parrot/parrot perl6.pbc

[19:41] <jnthn> Basically the .exe we build is a loader with the bytecode embedded.

[19:42] <jnthn> erm, s/trun/run/

[19:43] <icwiener_> Let's see if I can do that. :) Thanks for your help.

[19:45] *** icwiener_ left
[19:45] <[particle]1> i wonder if the trouble is only on x64 bits

[19:46] <[particle]1> due to larger int size doubling the memory requirements

[19:49] <jnthn> [particle]1: Even so, consuming 2 gigs + swap is nuts!

[19:49] <jnthn> (OK, sure, it didn't have the whole 2 gigs, but still...)

[19:56] <pmichaud> good afternoon, #perl6

[19:58] <Tene> hi pm

[19:58] <jnthn> hi pm

[20:00] *** [particle]1 is now known as [particle]-

[20:08] <pmichaud> rakudo:  sub prime($x) { $x == 3 };   say (3 when prime);

[20:08] <p6eval> rakudo 5eac9b: OUTPUT«too few arguments passed (0) - 1 params expected␤in sub prime (/tmp/A5vIHVzFMI:1)␤called from Main (/tmp/A5vIHVzFMI:1)␤»

[20:10] <TimToady> rakudo: sub prime() { $CALLER::_ == 3 }; say (3 when prime);

[20:10] <p6eval> rakudo 5eac9b: OUTPUT«Use of uninitialized value␤␤»

[20:11] <TimToady> say (3 if 1)

[20:11] <TimToady> rakudo: say (3 if 1)

[20:11] <p6eval> rakudo 5eac9b: OUTPUT«3␤»

[20:13] <pmichaud> afaik, CALLER:: not implemented in rakudo yet.

[20:15] <jnthn> OK, S12 question (oh hai TimToady...)

[20:15] <jnthn> In Construction and Initialization

[20:15] <jnthn> It says:

[20:15] <jnthn> If the candidate is omitted, a candidate object is implicitly created in

[20:15] <jnthn> the current class by calling C<CREATE>:

[20:15] <jnthn> $object = $class.bless(k1 => $v1, k2 => $v2, ...)

[20:15] <pmichaud> afk for me -- bbl

[20:16] <jnthn> And you can also call bless with the candidate you want blessing, having previously called CREATE.

[20:16] <jnthn> However, afaict you can also pass to bless positional arguments, like Animal{ :blood<warm> }

[20:16] <jnthn> I'd a little fearful about potential for confusion of the first positional.

[20:17] <jnthn> That is, is it the candidate, or is it just one of the auto-vivifying protos?

[20:21] *** sjohnson joined
[20:22] <sjohnson> hello, anyone awake and wants to chat about perl?

[20:23] *** M_o_C left
[20:29] <jnthn> sjohnson: For some definition of awake. :-)

[20:33] <sjohnson> is it possible to submit something to the developers of perl for consideration into the new Perl 6 spec?

[20:34] <jnthn> A lot of Perl 6 developers hang out here (well, mabye not loads at this exactly point in time... ;-))

[20:34] <jnthn> There's also the perl6-language mailing list.

[20:34] <jnthn> What were you thinking of?

[20:34] <TimToady> jnthn: yes, it's probably ambiguous, and the candidate needs to be required, perhaps with * as a you-pick value

[20:35] <jnthn> TimToady: Sounds sane, thanks.

[20:35] <TimToady> sjohnson: for most such suggestions, there's a good chance it has already been considered at some point :)

[20:36] <jnthn> TimToady: One of us should whack that into the spec.

[20:36] *** gbacon joined
[20:36] <TimToady> I can't right now, but if you don't I'll try to remember

[20:37] <jnthn> TimToady: I'll have a crack at it.

[20:37] <jnthn> Just trying to tidy that lot up in Rakudo.

[20:38] <sjohnson> ok i will tell my ideas

[20:38] <sjohnson> do you think Mr. Wall would consider a whitespace trim function like in every single other language, instead of 1) having to depend on CPAN or 2) having to write your own regex function or 3) doing the raw regex each time yourself

[20:39] <TimToady> it's already there

[20:39] <sjohnson> in perl 6 or perl 5?

[20:40] <TimToady> perl 6

[20:40] <TimToady> S32-setting-library/Str.pod:	=item trim

[20:40] <jnthn> rakudo: my $x = "  abc  "; say $x.trim;

[20:40] <p6eval> rakudo 5eac9b: OUTPUT«abc␤»

[20:40] <jnthn> sjohnson: Implemented in Rakudo even. :-)

[20:41] <sjohnson> YESSSSSSSSSSSSSSSSSSs

[20:41] <sjohnson> !!!!

[20:41] <TimToady> told you we might have considered it already :)

[20:41] <sjohnson> i am very happy to ehar that

[20:41] <[particle]-> (Mr. Wall)++

[20:43] <TimToady> biab, will backlog

[20:44] *** alester left
[20:45] <sjohnson> will Perl 6 let you do:  if (1) return 1; .... or give you a syntax error

[20:46] <jnthn> You must have the curly braces.

[20:46] <jnthn> return 1 if cond; # is fine though

[20:48] <sjohnson> ahh so perl 6 will still make the curly braces necessary for that one statement eh.. :(

[20:48] *** tulcod left
[20:49] <jnthn> sjohnson: Dangling syntax considered nasty.

[20:49] <jnthn> sjohnson: On the up side, the parens around the conditional are optional.

[20:50] <jnthn> if $x == 42 { say "the answer" }

[20:50] *** tulcod joined
[20:51] <sjohnson> thats kind of nice

[20:51] <sjohnson> as i hated those too

[20:51] <sjohnson> but i can live with just writing it backwards

[20:51] <sjohnson> do something if 1;

[20:52] <sjohnson> tho in perl 5 you dont need parens when it's written like that either which is nice

[20:52] <jnthn> Yes, true.

[20:53] <sjohnson> but that is still good news to me

[20:57] <sjohnson> can you edit strings by doing things like $string[3] = 'a';

[20:57] <sjohnson> in perl 6?

[20:59] <jnthn> sjohnson: No, not for a string, but there's a type called Buf (short for buffer) that lets you do that kind of thing.

[20:59] <jnthn> So far as I know anyway.

[21:00] <jnthn> One thing to note is that Perl 6 is very careful in the whole area of units.

[21:00] <jnthn> "length" is kinda a dirty word. :-)

[21:00] <sjohnson> length($string) will behave a bit differently?

[21:00] <jnthn> length is gone.

[21:00] <jnthn> You gotta say what you want.

[21:00] <jnthn> chars($string) # characters

[21:00] <japhb> rakudo: say %*VM.perl

[21:00] <jnthn> bytes($string) # how many bytes

[21:01] <p6eval> rakudo 5eac9b: OUTPUT«{"config" => {"-falign-functions=16" => "1", "-funit-at-a-time" => "1", "-fvisibility=hidden" => "1", "-maccumulate-outgoing-args" => "1", "-W" => "1", "-Waggregate-return" => "1", "-Wall" => "1", "-Wbad-function-cast" => "1", "-Wc++-compat" => "1", "-Wcast-align" => "1",

[21:01] <p6eval> .."-Wcast-q…

[21:01] <jnthn> Note you can call 'em as methods too.

[21:01] <jnthn> $string.chars

[21:01] <japhb> ouch, way too long.

[21:01] <jnthn> wow.

[21:02] <japhb> Can .perl be told to pretty-print?

[21:03] <sjohnson> thats not too bad

[21:03] <jnthn> japhb: No, but try .fmt

[21:05] *** pmurias left
[21:05] <japhb> jnthn: ooh, hash fmt works quite well, thanks.

[21:07] <japhb> jnthn: is there any way to get Rakudo's version and commit string, as you can for Parrot's using %*VM?

[21:07] <sjohnson> will Perl 6 contain a switch / case structure?

[21:08] <jnthn> japhb: Not that I'm aware of.

[21:08] <japhb> sjohnson: given/when.

[21:08] <japhb> sjohnson: and it's quite powerful.

[21:08] <sjohnson> wow i am excited

[21:08] <japhb> sjohnson: also exists in a weaker version in 5.10, btw.

[21:08] <japhb> jnthn: awww.  :-)

[21:08] *** PhatEddy joined
[21:09] <sjohnson> japhb: Perl has a sort() for arrays without the need for cpan.  Will a shuffle() be available for Perl 6?

[21:10] <skids> sjohnson: it's called given/where

[21:10] <skids> And the given is in a lot of cases optional.

[21:10] <japhb> sjohnson: yup.  It's called pick

[21:10] <skids> (where works on the topic, i.e. $_)

[21:10] <japhb> rakudo: say <1 2 3 4 5>.pick(*)

[21:10] <p6eval> rakudo 5eac9b: OUTPUT«53241␤»

[21:10] <japhb> rakudo: say <1 2 3 4 5>.pick(2)

[21:10] <p6eval> rakudo 5eac9b: OUTPUT«35␤»

[21:11] <jnthn> rakudo: say "Perl 6 is {<awesome cool beautiful twisted>.pick}"

[21:11] <p6eval> rakudo 5eac9b: OUTPUT«Perl 6 is twisted␤»

[21:11] <PhatEddy> jnthn: I can vouch for the other fellow's experience with requiring a few gig of memory to build a perl6 executable with 64 bit linux.

[21:11] <skids> oops. right. when.  I must be too "constrained" today.

[21:11] <jnthn> payload: Really?

[21:11] <PhatEddy> I had the same problem with 64 bit ubuntu.

[21:11] <jnthn> oops

[21:11] <japhb> sjohnson: skids is referring to the fact that 'given' merely sets the topic ($_).  If you're getting the topic set another way, you don't actually need the given.  Just do when clauses.

[21:11] <jnthn> PhatEddy: Wow.

[21:12] <japhb> skids: 'where' is for subtypes.

[21:13] <sjohnson> there's a shufflefunction called pick() to shuffle arrays?  that's an odd name

[21:13] <japhb> sjohnson: pick is the more general function.

[21:13] <Tene> jnthn: yes, I cna also verify.  Is this not already-known?

[21:13] <japhb> shuffle is just the special case of pick on the entire array.

[21:13] *** abra left
[21:13] <Tene> I thought it was well-known, or something.

[21:13] <jnthn> sjohnson: .pick without an argument gets one item.

[21:14] <skids> rakudo: for <a b c> { when <c> { say "OH HAI" }; default { say "OH" } }

[21:14] <p6eval> rakudo 5eac9b: OUTPUT«OH␤OH␤OH HAI␤»

[21:14] <jnthn> Tene: That it took gigs? Maybe known to others, that sounded an awful lot to me.

[21:14] <Tene> ah

[21:14] <jnthn> Tene: I thought in the hundreds.

[21:14] <Tene> ah, OK

[21:14] <PhatEddy> I had two gig of ram and swap disabled.  It wouldn't build until I re-enabled the 4 gig swap. I think the system used 800 meg and the build required 1.5Gig to 2 gig I think.  Is this an RT kind of thing?

[21:14] <Tene> I sometimes forget that I have more ram than I usually know what to do with.

[21:14] <jnthn> But if that's normal, fair enough...I just wasn't aware it was *that* bad. :-|

[21:15] <Tene> (although lately firefox has been finding creative uses...)

[21:15] <Tene> (a web browser should never need 1.5G :( )

[21:15] <sjohnson> jnthn:  does it remove it out of the array?  im worried about "picking" twice

[21:15] <jnthn> sjohnson: No, it doesn't.

[21:15] <skids> Tene: close those windows with flash in them, they waste electricity :-)

[21:16] <Tene> skids: this is with no flash at all.

[21:16] <jnthn> sjohnson: You can pass a number to .pick to say how many you want.

[21:16] <Tene> flash uses another 600M or so

[21:16] <jnthn> sjohnson: If you to .pick(*) it means "all of them"

[21:16] <jnthn> When you ask for more than one, though, the order can vary.

[21:17] <jnthn> (as in, is random)

[21:18] <japhb> sjohnson: both pick-without-replace and pick-with-replace are available.  It's just an adverb on the pick method.

[21:18] <jnthn> Ooh, I'd forgot about pick with replace. :-)

[21:18] <skids> Tene: yeah well, mostly it would just be nice if people used AJAX loops that knew how to sleep.  but too OT.

[21:18] <sjohnson> Q:  is there a uniq(@array); function too?

[21:19] <japhb> rakudo: say <1 2 3 2 5 6 4 3>.uniq.perl

[21:19] <p6eval> rakudo 5eac9b: OUTPUT«["1", "2", "3", "5", "6", "4"]␤»

[21:19] <japhb> yup

[21:19] <japhb> :-)

[21:20] <japhb> And before you even ask, note the '.perl' method there.  It's Data::Dumper on steroids, and built in.

[21:21] <japhb> Man, being able to say "already done" over and over is really nice.

[21:21] <sjohnson> wow on irc parser eh

[21:21] <sjohnson> rakudo: print "hello sjohnson";

[21:21] <p6eval> rakudo 5eac9b: OUTPUT«hello sjohnson»

[21:22] <skids> jnthn: WRT memory usage I think there was a misunderestimation on just how many really small hash/array/strings would be created.  The out is to make all those guys store small values directly in the PMC.

[21:22] <sjohnson> japhb: is what you wrote a real perl6 syntax?

[21:23] <sjohnson> i dont think you can do that in perl 5... using dots after things like that. am i wrong / right?

[21:23] <japhb> sjohnson: Because Perl 6 is a spec/testsuite with a number of implementations, the evalbot can actually show you the current response from each known implementation of Perl 6.

[21:23] <jnthn> sjohnson: When you prefix something with rakudo: here, it takes it and compiles/runs it.

[21:23] <jnthn> Yes, rakudo is just one implementation of Perl 6.

[21:23] <japhb> sjohnson: Yep.  $object.foo is roughly $object->foo in Perl 5.

[21:23] <jnthn> sjohnson: The . is the Perl 6 method call operator.

[21:23] <jnthn> ETOOMANYEXPLAINERS :-)

[21:24] <japhb> There can never be too many.

[21:24] <sjohnson> fuck i cant wait for perl 6

[21:24] <japhb> There Must Not Be Only One

[21:24] <jnthn> japhb: Oh yes, I agree. :-)

[21:24] <japhb> sjohnson: It's here.  Just not 100% implemented yet.

[21:24] <sjohnson> print "happy "house".trim;

[21:24] <sjohnson> rakudo:  print "    happy house    \n".trim;

[21:25] <p6eval> rakudo 5eac9b: OUTPUT«happy house»

[21:25] <skids> jnthn: That E'1atonce

[21:25] <sjohnson> fuck i am in love

[21:25] <sjohnson> sorry for the course language

[21:25] <sjohnson> but all of this is WAY better than perl 5

[21:25] <japhb> It's a strong emotion, we understand.  ;-)

[21:25] <jnthn> sjohnson: There's even more cool stuff. :-)

[21:25] <japhb> Like this:

[21:25] <japhb> rakudo: print "1 and 2 is {1 + 2}"

[21:25] <skids> sjohnson: rumor has it perl6 might swear occasionally too :-)

[21:25] <p6eval> rakudo 5eac9b: OUTPUT«1 and 2 is 3»

[21:26] *** Whiteknight joined
[21:29] <sjohnson> soi am impressed

[21:30] <sjohnson> say <1 2 3>.class

[21:30] <sjohnson> rakudo: say <1 2 3>.class

[21:30] <p6eval> rakudo 5eac9b: OUTPUT«Method 'class' not found for invocant of class 'List'␤»

[21:30] <sjohnson> rakudo: " moose".class

[21:30] <p6eval> rakudo 5eac9b: OUTPUT«Method 'class' not found for invocant of class 'Str'␤»

[21:30] <japhb> rakduo: say <1 2 3>.WHAT

[21:30] <japhb> rakudo: say <1 2 3>.WHAT

[21:30] <p6eval> rakudo 5eac9b: OUTPUT«List()␤»

[21:30] <skids> rakudo: say <1 2 3>.WHAT

[21:30] <p6eval> rakudo 5eac9b: OUTPUT«List()␤»

[21:31] <skids> Most of the "introspection" stuff is allcaps methods like WHAT HOW etc.

[21:31] <japhb> rakudo: say <1 2 3>.^methods

[21:31] <p6eval> rakudo 5eac9b: OUTPUT«invoke() not implemented in class 'ResizablePMCArray'␤in Main (src/gen_setting.pm:3166)␤»

[21:31] <sjohnson> rakudo:  say 3.WHAT

[21:31] <p6eval> rakudo 5eac9b: OUTPUT«Int()␤»

[21:31] <sjohnson> wow it's like ruby

[21:31] <jnthn> japhb: .^methods is kinda screwed up/work in progress atm. :-|

[21:32] <japhb> jnthn: I figured I had a 50-50 shot.  ;-)

[21:32] <jnthn> japhb: Your luck varies by type. ;-)

[21:32] <japhb> heh

[21:32] <jnthn> japhb: It's on my todo list.

[21:32] <[particle]-> 'j' ~ <a-z>.pick(4)

[21:32] <jnthn> japhb: As is introspection generally.

[21:33] <sjohnson> rakudo:  say <1 2 3>.shuffle

[21:33] <p6eval> rakudo 5eac9b: OUTPUT«Method 'shuffle' not found for invocant of class 'List'␤»

[21:33] <sjohnson> damn

[21:33] <japhb> rakudo: class Foo { method foo {...}; method bar {...} } my Foo $a .= new; say Foo.^methods

[21:33] <p6eval> rakudo 5eac9b: OUTPUT«Statement not terminated properly at line 1, near "my Foo $a "␤in Main (src/gen_setting.pm:0)␤»

[21:33] <jnthn> japhb: missing semi

[21:33] <[particle]-> rakudo: print [~] 'j', <a..z>.pick(4)

[21:33] <p6eval> rakudo 5eac9b: OUTPUT«ja..z»

[21:33] <japhb> sjohnson: you want '.pick(*)' instead of '.shuffle'

[21:33] <japhb> rakudo: class Foo { method foo {...}; method bar {...} }; my Foo $a .= new; say Foo.^methods;

[21:34] <[particle]-> rakudo: print [~] 'j', ['a'..'z'].pick(4)

[21:34] <p6eval> rakudo 5eac9b: OUTPUT«foobar␤»

[21:34] <p6eval> rakudo 5eac9b: OUTPUT«jwytg»

[21:34] <[particle]-> finally got it.

[21:34] <japhb> rakudo: class Foo { method foo {...}; method bar {...} }; my Foo $a .= new; say Foo.^methods.perl;

[21:34] <p6eval> rakudo 5eac9b: OUTPUT«[{ ... }, { ... }]␤»

[21:34] <japhb> oooh

[21:34] <sjohnson> rakudo:  print <a..z>.pick(*)

[21:34] <jnthn> japhb: methods doesn't return the names, but the actual methods.

[21:34] <p6eval> rakudo 5eac9b: OUTPUT«a..z»

[21:34] <skids> [particle]-: it's like simon says ;-)

[21:34] <japhb> jnthn: yep, I forgot that.

[21:35] <jnthn> rakudo: class Foo { method foo {...}; method bar {...} }; Foo.^methods>>.name>>.say

[21:35] <p6eval> rakudo 5eac9b: OUTPUT«foo␤bar␤»

[21:35] <sjohnson> how come my pick(*) didnt work?

[21:36] <jnthn> sjohnson: Because <...> is like qw in Perl 5

[21:36] <jnthn> a..z is just one string

[21:36] <sjohnson> rakudo:  say <1 2 3 4 5 6 7 8 9 10>.pick(*)

[21:36] <sjohnson> oh i thought it was a range

[21:36] <p6eval> rakudo 5eac9b: OUTPUT«67513910284␤»

[21:36] <jnthn> rakudo: ('a'..'z').pick(*)

[21:36] <p6eval> rakudo 5eac9b:  ( no output )

[21:37] <jnthn> rakudo: say ('a'..'z').pick(*)

[21:37] <japhb> sjohnson: Of course, you can do what jnthn just said ...

[21:37] <p6eval> rakudo 5eac9b: OUTPUT«gwzltucsriekjdymaxpbnfohvq␤»

[21:37] <jnthn> .oO( if you do that enough times, some of the resulting strings will contains swears! )

[21:37] <japhb> clbuttic.

[21:38] <sjohnson> will i be made fun of if i say i'm 10x as excited about Perl 6 now than I was 10 minutes ago?

[21:38] <japhb> Nope.  We'll merely suggest you get a paper bag to breathe into.  :-)

[21:38] <skids> rakudo: (1, -2, 3, 4)>>.abs.say # dare we reveal hypers this soon?

[21:38] <p6eval> rakudo 5eac9b: OUTPUT«1234␤»

[21:39] <sjohnson> all this stuff larry wall decided should go into Perl 6?

[21:39] <japhb> sjohnson: and more.  How about this one:

[21:39] <japhb> rakudo: (<a b> X <1 2>).say

[21:39] <p6eval> rakudo 5eac9b: OUTPUT«a1a2b1b2␤»

[21:40] <[particle]-> sjohnson: it's a community rewrite of perl, not (just) larry's rewrite

[21:40] <sjohnson> [particle]-: am i too late to suggest other things?

[21:41] <[particle]-> no

[21:41] <skids> Go for it, we want to see how far the "already there" score can get today :-)

[21:41] <[particle]-> the perl6-language mailing list is one place, and here is another.

[21:43] <jnthn> Gah. I'm waaay to butterfingered tonight to be refactoring object init code...

[21:43] <skids> jnthn: then work on destruction :-)

[21:44] <sjohnson> well let me think of another one

[21:44] <japhb> Having just seen HTTP::Daemon leaking all over the floor, I'm all for better destruction.  ;-)

[21:44] <japhb> Of course, it may be a Parrot issue.

[21:44] <jnthn> japhb: It has a memory leak?

[21:45] <jnthn> japhb: Quite believable, I'm curious if it's notably more leaky than any other long-running Perl 6 program though.

[21:47] <[particle]-> most perl 6 programs are long-running these days

[21:47] <skids> ;-)

[21:47] <jnthn> [particle]-: :-P

[21:48] <sjohnson> $string = "moose";  $string[2] = "O";  # "moose" => "moOse";

[21:48] <sjohnson> how would that be done in perl 6 properly?

[21:49] <skids> my Buf $b := $string; $b[2]="0";

[21:49] <skids> I think.

[21:49] <skids> Buf isn't quite fleshed out yet though.

[21:51] <sjohnson> in Perl 6, can there be a qx/ / without $string interpolation?

[21:51] *** justatheory left
[21:52] <japhb> jnthn: Yes, I ran a thousand hits of the sample httpd root page, and it ate ~ half a gig.

[21:52] <japhb> jnthn: I'll be looking at it in more detail in a bit

[21:53] <japhb> sjohnson: yes, there are both interpolating and non-interpolating versions of qx.

[21:53] <skids> sjohnson: there's just about any quoting form you could desire, Q: takes many adverbs that can be mixed together.

[21:53] <jnthn> japhb: That is srsly ouch.

[21:55] <sjohnson> my brother asks:  can you declare variables without dollar signs in Perl 6?

[21:56] <skids> hahah!

[21:56] <[particle]-> rakudo: constant pi = 3; print pi;

[21:56] <p6eval> rakudo 5eac9b: OUTPUT«invoke() not implemented in class 'Integer'␤in Main (/tmp/EhsQtdYtpZ:1)␤»

[21:56] <[particle]-> feh.

[21:56] <[particle]-> rakudo: constant pi := 3; print pi;

[21:56] <p6eval> rakudo 5eac9b: OUTPUT«No applicable methods.␤in Main (/tmp/4gGeTI4F6n:1)␤»

[21:57] <sjohnson> skids: i take it no, i dont mind tho

[21:57] <sjohnson> i dont mind the @ and $'s

[21:57] <skids> In perl6, though, you don't change @ to $ when using [], though.

[21:58] <sjohnson> what do you mean

[21:58] <sjohnson> i dont remember doing that in perl 5 even

[21:58] <sjohnson> oh

[21:58] <sjohnson> you mean like $list[5];

[21:58] <sjohnson> what do you do instead?

[21:58] <skids> in perl5 @a = (1,2,3); $a[1];

[21:59] <skids> rakudo: my @a = (1,2,3); @a[1].say

[21:59] <p6eval> rakudo 5eac9b: OUTPUT«2␤»

[22:00] <sjohnson> skids: will say @a[1]; work too?

[22:00] <pugs_svn> r26912 | jnthn++ | [spec] We now always require the candidate to be passed to bless, otherwise there's potential for confusion with the first auto-vivifying type object.

[22:00] <jnthn> sjohnson: ye

[22:00] <jnthn> s

[22:01] <sjohnson> what about hashes and stuff?

[22:01] <sjohnson> my brother hates having to do all the ${@{%hash{list}}} shit

[22:01] <sjohnson> i dont like it either much

[22:01] <ZuLuuuuuu> sigil doesn't change anymore taking an element from array or hash

[22:01] <sjohnson> any improvements on that?

[22:01] <skids> Same general deal -- the parens determine how you expect it to behave, the $@% are part of the variable name.

[22:01] <ZuLuuuuuu> *when taking element from ...

[22:02] <sjohnson> but @a[1]; didnt really change its behaviour

[22:02] <sjohnson> even tho i said list context with the @ snail sign

[22:03] <jnthn> sjohnson: The sigils are here to stay, they're just invariant now. That is, part of the name.

[22:03] <jnthn> sjohnson: Additionally, the enforce an "interface contract".

[22:03] <jnthn> *they...

[22:06] <sjohnson> can i see some examples?

[22:06] <sjohnson> that make it easier in perl 6 jnthn?

[22:07] <jnthn> Perl 5: my @a = (1,2,3); print $a[1];

[22:07] <jnthn> Perl 6: my @a = 1,2,3; print @a[1];

[22:07] <sjohnson> what about... hash things?

[22:07] <jnthn> $a and @a are always separate variables.

[22:07] <jnthn> Same rule.

[22:07] <sjohnson> it just knows what you want to do?

[22:08] <jnthn> my %h = a => 1, b => 2; say %h<a>

[22:08] <skids> Hrm, I haven't had to use many multi-level data structures due to better control flow, come to think of it.

[22:08] <jnthn> You can do [1] and <a> and {'a'} on any variable you want.

[22:09] <jnthn> But @a promises you that [...] will always work, for example.

[22:09] <jnthn> You can put something into a variable with an @ sigil that can't be indexed into positionally.

[22:11] <skids> perl5: $a = +{ a => [1,2,3], b => [4,5,6] }; print $a->{b}->[0]

[22:11] <skids> $a = +{ a => [1,2,3], b => [4,5,6] }; print $a{b}[0]

[22:11] <skids> rakudo: $a = +{ a => [1,2,3], b => [4,5,6] }; print $a{b}[0]

[22:12] <p6eval> rakudo 5eac9b: OUTPUT«Symbol '$a' not predeclared in <anonymous> (/tmp/uLlQqlWcox:1)␤in Main (src/gen_setting.pm:3166)␤»

[22:12] <skids> rakudo: my $a = +{ a => [1,2,3], b => [4,5,6] }; print $a{b}[0]

[22:12] <p6eval> rakudo 5eac9b: OUTPUT«Could not find non-existent sub b␤»

[22:12] <skids> rakudo: my $a = { a => [1,2,3], b => [4,5,6] }; print $a{b}[0]

[22:12] <p6eval> rakudo 5eac9b: OUTPUT«Could not find non-existent sub b␤»

[22:12] <jnthn> skids: <b>

[22:12] <jnthn> {...} never auto-qoutes in Perl 6.

[22:12] <skids> Yeah I just realized Iwas pasting the perl5 line back in.

[22:12] <skids> :-)

[22:12] <jnthn> :-=)

[22:13] <skids> rakudo: my $a = { a => [1,2,3], b => [4,5,6]}; $a<b>[0].say

[22:13] <p6eval> rakudo 5eac9b: OUTPUT«4␤»

[22:13] <skids> helps if you cut the right text :-)

[22:14] <sjohnson> rakudo: say { 1, 2, 3}.WHAT

[22:14] <p6eval> rakudo 5eac9b: OUTPUT«Block()␤»

[22:15] <sjohnson> perl6:  say <1>.WHAT

[22:15] <skids> rakudo: say { 1 => 2, 3 => 4 }.WHAT

[22:15] <p6eval> pugs: OUTPUT«Str␤»

[22:15] <p6eval> ..elf 26912: OUTPUT«Array␤»

[22:15] <p6eval> ..rakudo 5eac9b: OUTPUT«Str()␤»

[22:15] <p6eval> rakudo 5eac9b: OUTPUT«Hash()␤»

[22:15] <skids> (mines the last one)

[22:16] <pugs_svn> r26913 | jnthn++ | [t/spec] Spec change means bless always needs a candidate now; update construction.t.

[22:16] *** smtms left
[22:16] <jnthn> y'know, I think my patch is - after tweaking that spectest - actually going to pass make spectest.

[22:17] <jnthn> Too bad it's only doing the first easy bit of what I eventually want to do.

[22:17] *** smtms joined
[22:18] <skids> rakudo: my %h = :a(1), :b(2); %h.perl.say

[22:18] <p6eval> rakudo 5eac9b: OUTPUT«{"a" => 1, "b" => 2}␤»

[22:18] <sjohnson> how will one learn about all the tricks in Perl 6 that are new, if one has already purchased Programming Perl (v5)

[22:18] *** justatheory joined
[22:19] <skids> sjohnson: for the meantime, watch changelogs on pugs cvs.

[22:19] <jnthn> s/cvs/svn/ # thankfully!

[22:19] <jnthn> sjohnson: There are various places to follow Perl 6 news, and at least one documentation project.

[22:20] * skids embarrassed at showing his age, nervously sweeps hair over bald spot.

[22:20] <jnthn> Plus this place is pretty good for questions. :-)

[22:21] *** nihiliad left
[22:21] <japhb> sjohnson: Just in case it wasn't clear earlier, [particle] was trying to demonstrate that according to spec, you can declare *constants* without a sigil, but it isn't working yet everywhere.

[22:22] <sjohnson> without using "use constant ANIMAL => 'goose';" ?

[22:23] <japhb> jnthn: Yeah, that leak is pretty bad.  I am going over the HTTP::Daemon source looking for any obvious places the Perl 6 code does the wrong thing, and then I'll probably have to look deeper.  :-/

[22:23] <skids> sjohnson: there are enums also.

[22:23] *** tulcod left
[22:24] <japhb> sjohnson: 'constant' and 'enum' are now declarators, there's no module to use.

[22:24] <dalek> rakudo: 23718a8 | jnthn++ | src/classes/Object.pir:

[22:24] <dalek> rakudo: First steps in refactoring object building/initialization. We now are a bit more consistent with the spec about new/bless/CREATE and their relationship, plus follow a recent spec change. Plus adds placeholders for the next step of refactoring creation and BUILD.

[22:24] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/23718a8bec08f01b8081b359fde4bbaaca9ff2de

[22:24] <japhb> (They're in the core syntax, I mean)

[22:25] <jnthn> rakudo: constant foo = 42; say foo

[22:25] <p6eval> rakudo 5eac9b: OUTPUT«42␤»

[22:25] <japhb> Go jnthn!

[22:25] <jnthn> rakudo: constant π = 3.14; say π

[22:25] <p6eval> rakudo 5eac9b: OUTPUT«3.14␤»

[22:25] <japhb> sjohnson: note the unicode ...

[22:25] <jnthn> What did particle try earlier that didn't work... :-S

[22:26] <japhb> "rakudo: constant pi = 3; print pi;"

[22:26] <jnthn> rakudo: say pi

[22:26] <p6eval> rakudo 5eac9b: OUTPUT«3.14159265358979␤»

[22:26] <jnthn> Oh!

[22:27] <jnthn> We already have a pi

[22:27] <japhb> Builtin!

[22:27] <jnthn> And it's not detecting the collision.

[22:27] <jnthn> Bad Rakudo. No cookie.

[22:27] *** justatheory left
[22:27] <japhb> ("It's easy to detect collision with pi -- just check if your face is covered in whipped cream ...")

[22:28] <jnthn> Aww. You just made me want pi(e)...

[22:28] <skids> (disclaimer: does not work in case of french meat pie)

[22:30] <japhb> heh

[22:33] <jnthn> Ah well, if I can't have pie I'll have pivo. :-)

[22:34] <sjohnson> what are enums

[22:34] * japhb watches as Rakudo valiantly tries to overtake Firefox as biggest process on my laptop ...

[22:34] <sjohnson> "true", "false" type datatypes?

[22:34] <pugs_svn> r26914 | jnthn++ | [spec] Oops, forgot to save before commit.

[22:34] <japhb> sjohnson: that is one example, yes.

[22:35] * skids uses firefox to horde cache to check rakudo misses.

[22:35] <japhb> sjohnson: days of the week, months of the year, that sort of thing

[22:35] <skids> rakudo: say (2.296,0.5671,"pork") >>~>> " the other " >>~<< (pi,e,"white meat") >>~>> "\n"

[22:35] <p6eval> rakudo 23718a: OUTPUT«2.296 the other 3.14159265358979␤0.5671 the other 2.71828182845905␤pork the other white meat␤␤»

[22:36] <jnthn> rakudo: enum Day <Mon Tue Wed Thu Fri Sat Sun>; given Day.pick { when Mon { say "yawn" }; when Tue|Wed|Thu { say "work work work" }; when Fri { say "oh phew it's nearly over" }; when Sat { say "off t'pub" }; when Sun { say "good morning, vicar" } }

[22:36] <p6eval> rakudo 23718a:  ( no output )

[22:36] <japhb> A classic example, that ....

[22:37] <jnthn> erm...

[22:37] <jnthn> why no output though. :-|

[22:37] <japhb> Rakudo wins by a nose!

[22:37] <jnthn> oh well, I blogged the working one somewhere...

[22:39] <japhb> rakudo: ((436 * 1024 - 69308)/1000).say

[22:39] <p6eval> rakudo 23718a: OUTPUT«377.156␤»

[22:39] <japhb> ouch.  Leaking a bit under 400 kB per hit.

[22:39] <jnthn> ouch.

[22:40] <sjohnson> the squiggle operator is new to me

[22:40] <sjohnson> >> ~ << etc

[22:40] <jnthn> sjohnson: stirng concat

[22:40] <japhb> sjohnson: since Perl 6 uses . for method calls, we needed something else for concatenation

[22:40] <jnthn> rakudo: say "oh" ~ "ai";

[22:40] <p6eval> rakudo 23718a: OUTPUT«ohai␤»

[22:41] <japhb> sjohnson: in general, there was a massive reshuffle of operators, as A became B and B became C and so on.

[22:41] <skids> and =~ is now ~~

[22:42] <japhb> skids: ~~ is how you say 'smart match' in Perl 5.10, too.  Perl 5 =~ was regex match only.

[22:42] <skids> Oh I never learned much of .10 new stuff.

[22:42] *** dalek left
[22:43] *** dalek joined
[22:43] <japhb> skids: 5.10 gives me heartache.  Because it's SO much better than 5.8, but it's so not 6.0.

[22:43] <skids> sjohnson: and the >> stuff are hyperoperators, which are very interesting.

[22:44] <japhb> Oh!  We forgot reduction!

[22:44] *** jferrero joined
[22:44] <japhb> rakudo: say [+] 1..10;

[22:44] <p6eval> rakudo 23718a: OUTPUT«55␤»

[22:44] <skids> Yes reduction before hypers :-)

[22:44] <japhb> rakudo: say [\+] 1..10

[22:44] <p6eval> rakudo 23718a: OUTPUT«say requires an argument at line 1, near " [\\+] 1..1"␤in Main (src/gen_setting.pm:2400)␤»

[22:44] <jnthn> japhb: didn't do tirangles yet

[22:44] <japhb> rakudo: ([\+] 1..10).say

[22:44] <p6eval> rakudo 23718a: OUTPUT«Syntax error at line 1, near "([\\+] 1..1"␤in Main (src/gen_setting.pm:0)␤»

[22:44] <japhb> jnthn: dang

[22:45] <jnthn> japhb: Hey, we handle most of the rest. :-P

[22:45] <jnthn> :-)

[22:45] <japhb> true

[22:45] <skids> .oO(tirangle: n. the half of the town square closed off during dictatorship)

[22:45] <jnthn> .oO( why on earth is this krušovice so insanely fizzy?! )

[22:48] * japhb sees comment '# inefficient workaround - remove when Rakudo gets a qx operator', complies ...

[22:49] <sjohnson> do you guys in general, prefer Perl over Python?

[22:50] <sjohnson> reason i ask is because the Perl fans seem to live in caves / don't post their thoughts on the debate

[22:50] <sjohnson> it would be refreshing to hear some opinions that they like Perl better for once

[22:51] <japhb> sjohnson: It just doesn't seem a debate worth fighting.  Especially since Parrot allows both to run in the same process and commingle nicely.

[22:52] <jnthn> I can't speak for everyone, but on my part getting into "my language is better" debates always feels a tad pointless. For one because part of language preference is just what people personally like too.

[22:52] <jnthn> I'm happy to point out factual inaccuracies if I spot them and it looks like a genuine mis-understanding rather than a troll.

[22:52] <wayland76> sjohnson: Yes, I prefer Perl over Python.  But I mostly agree with jnthn about these debates being somewhat pointless.  

[22:52] <sjohnson> not so much a debate i would like to see, but someone sincerely admit that they prefer Perl over Python ... with that person having worked with both

[22:52] <wayland76> Let me give an example of pointfulness, though

[22:53] *** JDlugosz joined
[22:53] <wayland76> There's a book by Raphael Finkel called "Advanced Programming Language Design", and it talks about the criteria that people may or may not use for judging a language

[22:54] <wayland76> Perl 5 happily violates almost all the principles mentioned in order to maximise one principle -- expressiveness

[22:54] <JDlugosz> I've read books like that from a more classic era.  Things were more interesting then, I think.  Now they just study Java and C.

[22:54] <lambdabot> JDlugosz: You have 1 new message. '/msg lambdabot @messages' to read it.

[22:54] <phenny> JDlugosz: 07:29Z <eternaleye> tell JDlugosz that the 567 quotes show as unicode-numbered quads on my system in Firefox, but that's a font issue with Serif rather than anything in the OS

[22:54] <phenny> JDlugosz: 07:30Z <eternaleye> tell JDlugosz (that's amd64 Gentoo, firefox 3.1beta)

[22:54] <sjohnson> wayland76:  i c

[22:55] <wayland76> That aligns with my preferences, so I like Perl better than Python

[22:55] <wayland76> JDlugosz: Well, the Finkel one actually means "Advanced".  This is "What to do next after you've done a basic Compilers course"

[22:56] <wayland76> (Oh, the opinion that Perl maximises expressiveness is mine, naturally, and didn't come from the book)

[22:56] <wayland76> Btw, the Finkel book is free online as a PDF, but I liked it so much that I bought it anyway

[22:58] <JDlugosz> Algol, PL/1, LISP, SnoBol, REXX, ...

[22:58] <JDlugosz> Got a link for the PDF?  Like catnip...

[22:59] <japhb> jnthn: Is the time API implemented in Rakudo yet?

[22:59] <jnthn> japhb: time() function will work

[22:59] <japhb> jnthn: but none of the methods?

[23:00] <jnthn> japhb: The Temporal module work my mberends++ isn't integrated yet.

[23:00] <japhb> OK

[23:00] <jnthn> japhb: When he tried, the stage 1 compiler exploded. Then I spent two fruitless hours trying to work out why. :-(

[23:00] <JDlugosz> ➸ I'm thinking of a function signature.

[23:00] <japhb> nice

[23:01] <jnthn> japhb: So that's on my crap-I-have-to-be-bothered-to-debug-but-gah-it's-hard list. :-)

[23:01] <JDlugosz> DId I miss the boat somewhere maybe five years ago?  Consider:  sub foo ($x, @y, @z) { ... }

[23:01] <japhb> jnthn: not exactly a fun list to work through, I bet ....

[23:01] <sjohnson> rakudo:  $x = { if (0 == 1) { 5; } else { 6; } }; say $x = { if (0 == 1) { 5; } else { 6; } }; say $x;

[23:01] <jnthn> japhb: No, there's the fun times in implemetning Perl 6, and the painful ones.

[23:02] <JDlugosz> The books of that era always covered stuff like that.  I learned much more than any "modern" guy.

[23:02] <p6eval> rakudo 23718a: OUTPUT«Symbol '$x' not predeclared in <anonymous> (/tmp/1nw1yawVgA:1)␤in Main (src/gen_setting.pm:3166)␤»

[23:02] <jnthn> sjohnson: You need to declare your variables. :-)

[23:02] <jnthn> JDlugosz: I'm looking over your article at the moment.

[23:02] <sjohnson> rakudo:  $x = { if (0 == 1) { 5; } else { 6; } }; say $x;

[23:02] <p6eval> rakudo 23718a: OUTPUT«Symbol '$x' not predeclared in <anonymous> (/tmp/ZIlE0YH9jY:1)␤in Main (src/gen_setting.pm:3166)␤»

[23:02] <jnthn> JDlugosz: The one you just sent mail to p6l about.

[23:02] <sjohnson> rakudo:  my $x = { if (0 == 1) { 5; } else { 6; } }; say $x;

[23:02] <japhb> sjohnson: 'my $x = ...'

[23:02] <p6eval> rakudo 23718a: OUTPUT«_block21␤»

[23:02] <JDlugosz> jnthn:  The thing I just posted, or the one we've been discssing all week?

[23:02] <jnthn> rakudo:  my $x = { if (0 == 1) { 5; } else { 6; } }; say $x();

[23:03] <p6eval> rakudo 23718a: OUTPUT«6␤»

[23:03] <jnthn> JDlugosz: The one you just posted

[23:03] <JDlugosz> jnthn, thanks.

[23:03] <jnthn> http://www.dlugosz.com/Perl6/web/passing_examples.html

[23:03] <jnthn> JDlugosz: I need to find time to look at more of your work...

[23:03] <sjohnson> jnthn: do you have to do $x();?

[23:03] <JDlugosz> I need to update most of those short pieces anyway.  

[23:03] <jnthn> sjohnson: If you want to run the block, yes.

[23:04] <jnthn> JDlugosz: Your surname looks Polish - is it?

[23:04] <JDlugosz> I think you are missing a "do" there.  The immediate block gets executed, not saved as a &.  It is a statement.  Needs 'do' to get the value back into an expression.

[23:05] <jnthn> JDlugosz: It's not an immediate block there, it's a closure.

[23:05] <JDlugosz> Yes, Name is Polish.  Actually spelled with an Ł

[23:05] <sjohnson> rakudo:  $x = { if (0 == 1) { 5; } else { 6; } }() ; say $x;

[23:05] <jnthn> Ah, OK. :-)

[23:05] <p6eval> rakudo 23718a: OUTPUT«Symbol '$x' not predeclared in <anonymous> (/tmp/iI3mbBC2L1:1)␤in Main (src/gen_setting.pm:3166)␤»

[23:05] <sjohnson> rakudo: my  $x = { if (0 == 1) { 5; } else { 6; } }() ; say $x;

[23:05] <p6eval> rakudo 23718a: OUTPUT«6␤»

[23:05] <JDlugosz> What makes it a closure instead?

[23:05] <jnthn> JDlugosz: I'm living in Slovakia at the moment, so I run into the odd bit of Polish now and then. :-)

[23:06] <jnthn> In general { ... } gives a closure, I guess it's the context that makes it "immediate" in some sense.

[23:07] <skids> JDlugosz: it's not where a statement was expected.

[23:07] <skids> my $x = -> $a, $b { if ($a == $b) { 5; } else { 6; } }; say $x(3,3); say $x(3,4)

[23:07] <skids> rakudo: my $x = -> $a, $b { if ($a == $b) { 5; } else { 6; } }; say $x(3,3); say $x(3,4)

[23:07] <jnthn> skids: Ah, that sounds about correct.

[23:07] <p6eval> rakudo 23718a: OUTPUT«5␤6␤»

[23:07] <jnthn> So I guess it's a syntactic decision.

[23:07] <JDlugosz> Yes, the context.  I'm reviewing S06 now... guess it's not as simple as I recall it saying.

[23:09] <JDlugosz> Probably right, really executes if it becomes a statement itself.  So the grammar will give complex behavior in general, but the common cases are designed to DWIM.

[23:09] <jnthn> JDlugosz: You write "Coerce the Positional role out of α,"

[23:09] <jnthn> It's really "check that α does Positional"

[23:09] <jnthn> The sigil on the parameter implies that a certain role is done.

[23:10] <wayland76> JDlugosz: http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/

[23:10] <wayland76> But it would've been impossible to find if I hadn't looked up the filename on my local computer, and googled that :)

[23:11] <JDlugosz> It's my upcoming formal language that I'll use later, trying out now... that's what I mean here.  I'm preparing a full treatment of coersions.

[23:11] <JDlugosz> Deals with iheriting from roles and the problems with "Isa" and derived types not being proper subtypes.  That kind of thing.

[23:11] <jnthn> OK, but to me coercion has always meant something very different from a type check.

[23:12] <JDlugosz> That's my pet from last year:  my sabbatical research was on F-bounds polymorphism.  On my web page.

[23:12] <JDlugosz> term coersion:  I'm running with what I saw used already.  Maybe needs a different word for the general case?

[23:12] <JDlugosz> I've come up with "identity coersion" is one that returns the same object or a conforming proxy to the one it was called on.

[23:13] <JDlugosz> where conforming means something a page or two long, too.

[23:13] <JDlugosz> I'll hit the thesarus.  But the Synopses mention Conversion and Coersion.

[23:14] <JDlugosz> and doesn't distinguish checking for an interface on an object (static type conversion, dynamic type same).

[23:14] <JDlugosz> Suggestions welcome.

[23:14] <jnthn> Sure.

[23:14] <JDlugosz> Thanks for the PDF.

[23:14] <jnthn> I've implemented much of the Perl 6 type stuff in Rakudo.

[23:15] <jnthn> So I'm kinda coming from the angle of, how that implementation looks.

[23:15] <JDlugosz> At the very least, I should hyperlink the term.  But this page wasn't meant to be shown yet.  Just want to get past my issue before going on.

[23:16] <jnthn> http://www.dlugosz.com/Perl6/web/typesystem-summary.html is probably an interesting read for me too...

[23:16] <JDlugosz> Yea, I need to hear from you on "what really happens" since the spec is too vague, but then come up with something that's not implementation-specific to re-describe it.

[23:16] <jnthn> The spec on roles has got a tad less vague of late. :-)

[23:17] <JDlugosz> typesystem-summary:  more lamenting on what's not in the spec.

[23:17] <JDlugosz> good to here.

[23:17] <jnthn> Yeah, on the type stuff the spec is a bit hand-wavey for sure.

[23:17] <JDlugosz> Also last year I figured out a complete algorithm for role composition.

[23:17] <jnthn> A lot of what I've been doing is working out how to reconcile the requirements and get an implementation.

[23:17] <JDlugosz> Anyway, is there anything wrong with defining @-varaibles as formal parameters?

[23:18] <jnthn> I gather you're trying to do the same but get a formal spec out of the process rather than an implementation. :-)

[23:18] <skids> is the mmd decision process "specced"

[23:18] <sjohnson> rakudo:  say 1..10.WHAT

[23:18] <jnthn> skids: Yes.

[23:18] <p6eval> rakudo 23718a: OUTPUT«Use of type object as value␤␤»

[23:18] <skids> where at?

[23:18] <sjohnson> rakudo:  say (1..10).WHAT

[23:18] <jnthn> skids: S12.

[23:18] <p6eval> rakudo 23718a: OUTPUT«Range()␤»

[23:19] <sjohnson> fuck Perl 6 is almost exaclty like Ruby... am i right?  i am happy about it

[23:19] <JDlugosz> jnthn:  I would appreciate it if you read "specdoc".  There are a few things in there that are well worked out.  Even if out of date, some important things that still apply.

[23:19] <sjohnson> oops gotta watch my mouth

[23:19] <sjohnson> just so excited!!!

[23:19] <jnthn> JDlugosz: I don't see any issue with calling them that off hand.

[23:20] *** dalek left
[23:20] <wayland76> sjohnson: Almost!  But More Better :)

[23:20] *** dalek joined
[23:20] <jnthn> sjohnson: Well, Ruby was a source of inspiration too.

[23:20] <wayland76> (Actually I haven't used enough Ruby to make a judgement call :) )

[23:20] <jnthn> Perl has always been a langauge that borrows from others though.

[23:20] <japhb> rakudo: say defined %*ENV<some_env_var_that_does_not_exist>

[23:20] <p6eval> rakudo 23718a: OUTPUT«1␤»

[23:20] <JDlugosz> That's what I'm hoping.  But I got suspicious when no such thing is exampled in the synopses.  I distinctly remember being shown that in the very early days.

[23:22] <wayland76> rakudo: say exists %*ENV<some_env_var_that_does_not_exist>

[23:22] <p6eval> rakudo 23718a: OUTPUT«No applicable candidates found to dispatch to for 'exists'␤in Main (/tmp/Nh3DbYC4m2:1)␤»

[23:22] <wayland76> rakudo: say %*ENV.exists('some_env_var_that_does_not_exist');

[23:22] <p6eval> rakudo 23718a: OUTPUT«0␤»

[23:23] <wayland76> rakudo: say %*ENV.defined('some_env_var_that_does_not_exist');

[23:23] *** M_o_C joined
[23:23] <p6eval> rakudo 23718a: OUTPUT«too many arguments passed (3) - 1 params expected␤in Main (src/gen_setting.pm:3166)␤»

[23:23] <wayland76> rakudo: say %*ENV('some_env_var_that_does_not_exist').defined;

[23:23] <p6eval> rakudo 23718a: OUTPUT«invoke() not implemented in class 'Env'␤in Main (/tmp/DbIV7iYqTx:1)␤»

[23:23] <jnthn> JDlugosz: The biggest thing that I see missing in your description of "Multi Dispatch" is the separation between what we do per invocation and what we compute ahead of time.

[23:24] <jnthn> JDlugosz: We sort the candidate list completely independently of any invocation.

[23:24] *** ZuLuuuuuu left
[23:24] <JDlugosz> jnthn:  where is that?  specdoc?

[23:24] <jnthn> And all we do per invocation is walk that ordering and pick the first thing that matches, being aware of amgiguities.

[23:24] <jnthn> JDlugosz: I was looking at http://www.dlugosz.com/Perl6/web/typesystem-summary.html

[23:24] <JDlugosz> Oh, thanks.  

[23:24] <jnthn> If you've defined it more clearly elsewhere, that's fine - it just stood out to me as missing there.

[23:25] <jnthn> Or at least, groking that it was one of the things that helped me most when implementing it.

[23:25] <sjohnson> i am so excited i can hardly stand it

[23:25] <JDlugosz> I recall trying to get to the bottom of things in the mailing list in June or so.  That doc should be updated.

[23:25] <sjohnson> im not even joking

[23:26] <sjohnson> any time frame for an official Larry Wall release? hopefully not super long

[23:26] <wayland76> sjohnson: Perl 6 has that effect on me too sometimes :)

[23:26] <wayland76> sjohnson: Perl 6 is a specification, there are multiple implementations of that specification

[23:26] <wayland76> No one implementation is the "Official" one

[23:27] <sjohnson> is there one written in C tho / will Larry Wall pick one of them to be official?

[23:27] <sjohnson> or will he write one himself with his buddies?

[23:27] <jnthn> JDlugosz: On the "Relationships Between Types" section of the same doc.

[23:27] <japhb> Sorry, was AFK.  Shouldn't %*ENV<nonexistant> be undefined?

[23:27] <wayland76> There's one called "Rakudo" that's built on the virtual machine called "Parrot"

[23:27] <wayland76> And there's one called SMOP that is, IIRC, written in C

[23:27] <jnthn> JDlugosz: I found that things work out quite well if you just use smart-matching to define acceptance.

[23:28] <jnthn> JDlugosz: That's the model I've gone down in Rakudo, and it's worked out well.

[23:28] <wayland76> The big advantages of Rakudo are a) it seems the most complete at the moment, and b) it will be very interoperable with other Parrot-based languages

[23:28] <JDlugosz> Yea, the smart match of sig/capture is intended to tell you whether it can be called.  So they'd better agree!

[23:28] <jnthn> So far anyways...

[23:28] <wayland76> The big advantage of SMOP is that it will integrate well with Perl 5

[23:28] <japhb> sjohnson: Larry is specializing in spec and canonical parser (STD).  (Most) implementation is left to others.

[23:28] <japhb> s/parser/grammar/

[23:28] <jnthn> JDlugosz: Yes but I mean at the "does this value do this type" level.

[23:29] <wayland76> Yes, i forgot to mention STD is an official Larry Wall grammar

[23:29] *** PhatEddy left
[23:29] <jnthn> JDlugosz: I see that as just boiling down to TypeThing.ACCEPTS(value)

[23:29] <wayland76> I'm expecting it will be used by both Rakudo and SMOP at some point

[23:29] <wayland76> (I'm not involved in either project, except on the periphery of Rakudo)

[23:29] <JDlugosz> Oh, tells you if it can (claims to), but that doesn't return the interface or casted object.

[23:29] <jnthn> JDlugosz: And it also works for comparing two types.

[23:29] <skids> std: my $a # STD doesn't run code it just says whether the syntax is valid

[23:30] <p6eval> std 26914: OUTPUT«ok 00:02 36m␤»

[23:30] <wayland76> (So my impressions of completeness, etc, are based on eg. what I see people saying)

[23:30] *** ruoso joined
[23:30] <JDlugosz> I thought ACCEPTS was a fallback if it can't tell which rule to use at compile time.  Normally will use a more specific method.

[23:30] <jnthn> I see that more as an optimization.

[23:30] <skids> std: "I am the last word."; "Don't like it?, talk to the Wall.".say

[23:31] <p6eval> std 26914: OUTPUT«ok 00:04 36m␤»

[23:31] <jnthn> But yes, if we know we can save a level of indirection.

[23:31] <jnthn> It turns out knowing isn't always quite so easy though.

[23:31] <wayland76> rakudo: "I am in progress".say

[23:31] <p6eval> rakudo 23718a: OUTPUT«I am in progress␤»

[23:31] <JDlugosz> That means that ACCEPTS must be inline-able and optimizable.  

[23:32] <JDlugosz> That's hard to do in the general spec, to make sure crazy things have well-defined meanings and implementations agree.

[23:33] <jnthn> JDlugosz: Yes and no. Rakudo optimizes the bulk of multi-dispatches in such a way that we never actually have to call ACCEPTS on a lot of invocations.

[23:33] *** mizioumt2 left
[23:33] *** revdiablo joined
[23:33] <skids> pugs: "I'm cold, and I forgot where I put my teeth.".say

[23:33] <p6eval> pugs: OUTPUT«I'm cold, and I forgot where I put my teeth.␤»

[23:34] <wayland76> (pugs is an old implementation that doesn't seem to have anyone working on it any more)

[23:34] <JDlugosz> I like a simple spec, rather than having the compiler know all the rules directly.  Anything more is just the optimizer, or a harrier compiler implementation.

[23:35] <jnthn> JDlugosz: In which way is "call .ACCEPTS, and to know what that does go see the smart-matching section of the spec" not simple?

[23:35] <JDlugosz> So, your original point... I think I see what you mean.  You don't need different casting functions, you just let ACCEPTS do it all.

[23:35] <JDlugosz> Rather than having the type-cast form for ACCEPTS turn around and call the special function for that.

[23:35] <JDlugosz> Right?

[23:36] <JDlugosz> I was agreeing.  I like a simple spec.

[23:36] <jnthn> I'm curious about the notion of "casting" you mention.

[23:36] <JDlugosz> The "notion" in general?

[23:37] <jnthn> OK, I know what casting is. Well, I know what my definition of casting is. :-)

[23:37] <jnthn> I'm just not quite sure how it applies in the Perl 6 world.

[23:37] <JDlugosz> Given something of one type, produce something of a (possibly different) type that is conceptually the "same thing".

[23:37] *** sjohnson_ joined
[23:37] <sjohnson_> hello!

[23:38] <sjohnson_> perl6... the FUTURE of scripting languages

[23:38] <jnthn> JDlugosz: I fear that definition confuses casting and coercion.

[23:38] <JDlugosz> How it applys:  implicit conversions, "isa" relationships via static type information providing differing types for the same object, proxies.

[23:38] <JDlugosz> What's the difference between casking and coercion?

[23:39] <jnthn> I've always defined coercion as a change of representation.

[23:39] <jnthn> Whereas casting is just "we see the type as being A, because A is one of the types we can see the thing as being"

[23:39] <JDlugosz> Ah.  I see it as no change in representation, just coaxing a different facet out of the same object.

[23:39] <JDlugosz> casting:  cast int to double, ...

[23:40] <jnthn> Yes, but that's not a cast. That'a a coercion because a double has a different representation to an int.

[23:40] <JDlugosz> So our uses are directly opposite to each other.

[23:40] <jnthn> At least, for the definitions of these things that I'm used to.

[23:40] <JDlugosz> In C++, everything is a cast.

[23:40] <sjohnson_> wayland76:  are there Perl 6 things out right now that are fully functional that i dont have to install 3 separate things to get it to inpret, so i can start scripting in it?

[23:41] <sjohnson_> and that aren't much slower than perl 5

[23:41] <wayland76> sjohnson: Not sure what you mean

[23:41] <wayland76> No.  Perl 6 is not complete, and Rakudo at least are not worried about speed very much until it's complete

[23:41] <jnthn> JDlugosz: I tend to see it more as, in C++ I see there's one syntax and it may do a cast and it may do a coercion.

[23:41] <revdiablo> sjohnson_: Do you mean is there a perl 6 implementation ready for production use? No. Not yet.

[23:42] *** sjohnson1 joined
[23:42] <JDlugosz> But grabbing different interfaces from one full object is handled at a different level in C++, and so Perl would need to have a notion of "give me a static type from this... and BE SURE it's the same object".

[23:42] <skids> "First make it work"

[23:42] *** exodist left
[23:42] <wayland76> IRC log: http://irclog.perlgeek.de/perl6/today

[23:42] <JDlugosz> So what would you call those things?

[23:42] <jnthn> JDlugosz: I think what I'm missing is the "give me an X" type of thing.

[23:43] <JDlugosz> missing?

[23:43] <jnthn> sub foo(Num $x) { } # Num here means "make sure whatever is passed to go in $x has $x ~~ Num giving a true value"

[23:43] *** sjohnson left
[23:43] <wayland76> sjohnson1: Basically, there's nothing out there that's simple to install; i expect that to change within the next month or two, but feature complete and production ready are definitely further away

[23:43] *** nsh joined
[23:43] <jnthn> It's a check, there's no "getting" as such.

[23:43] *** sjohnson1 left
[23:44] <JDlugosz> Yes, it's a check.  But if you already know the static type of $x now, you can optimize calls via a jump table.

[23:45] <JDlugosz> There are some things where knowing the static type matters.  But I agree, that doesn't mean you "get" something.

[23:45] <JDlugosz> But, if you have a proxy, then getting is important.

[23:45] *** sjohnson_ is now known as sjohnson

[23:45] <sjohnson> there we go

[23:45] <JDlugosz> You might generate the guts to "do" that on the fly, when asked.

[23:45] <sjohnson> i used to think ruby would solve all the scripting problems in the universe, but now i think perl 6 will

[23:46] <sjohnson> is the Perl 6 spec done, finished, over?  or is larry still cooking up some ideas of his

[23:46] <JDlugosz> Thanks for the insight though.  That is definitly something to chew on.  And certainly something to explain better if I describe it that way.

[23:46] <jnthn> Oh, foc sure the compiler can use the knowledge that "if the check fails we never run this code".

[23:46] <wayland76> The Perl 6 spec is still changing

[23:47] <jnthn> And the opposite - if we're running the code $x does Num.

[23:47] <wayland76> For example, Larry just recently added some more specific stuff about how to override sublanguages (eg. regex) in the grammar

[23:47] <wayland76> But some sections of the spec are moderately stable

[23:48] *** cdarroch left
[23:48] <JDlugosz> If you call $x.foo, the compiler can emit a simple jump table jump to foo, based on a table created for Num.  It has that table prepared for the object in $x right now.  That's what it "gets".  But I agree, that's a much lower level detail that Perl 6 sees.

[23:48] <jnthn> JDlugosz: The thing that worries me about using "coercion" is that the Perl 6 spec does use it.

[23:48] <wayland76> What tends to happen is the implementors get arguing about what *should* happen, and then Larry resolves everything with a brilliant new idea (That doesn't happen with all arguments, but it's what drives some of the spec changes)

[23:49] <JDlugosz> Oh, that description also was from when I was thinking that contextualizers can be unified with coersions too.  All aspects of the same coin, as it were.

[23:49] <JDlugosz> That's exactly why I did use it.

[23:50] <JDlugosz> I was just seeing things differently, as you so reciently enlightned me.

[23:50] <sjohnson> does anyone know of the -devel mailing list for Perl 6, and if Larry himself ever reads it?

[23:50] <jnthn> That kinda fits with how things work in Rakudo too.

[23:50] <jnthn> But it still is a different matter to a "type check".

[23:50] <wayland76> sjohnson: There's a "Language" list and a "Compilers" list

[23:51] <skids> He reads perl6-language and also comes here.

[23:51] <wayland76> Language is for arguing about the Spec.  I'm on it, and so is Larry.  

[23:51] <wayland76> (perl6-language is the "Language" list I mentioned)

[23:51] <wayland76> I'm not on Compilers, so I can't speak for it

[23:52] <sjohnson> skids, how often does he come here?  what's his nickname when he does?

[23:53] <wayland76> lambdabot: @seen TimToady

[23:53] <lambdabot> TimToady is in #perl6. I last heard TimToady speak 3h 9m 56s ago.

[23:53] <skids> sjohnson: you already talked to him, in fact, when you first logged in.

[23:54] <jnthn> JDlugosz: If I can show anythign convincing, then maybe: sub foo($x of Str) { } vs sub foo($x as Str) { }

[23:54] *** iblechbot left
[23:54] <jnthn> The first checks the value passed and bound to the parameter $x does Str. The second takes that value - whatever type it is - and (tries to) coerce to to Str.

[23:55] <jnthn> They're two quite different operations, and I fear trying to unify them both under the heading "coercions" is the wrong direction, unless you want to parameterize your coercer to say "check or coerce", in which case you probably might as well have defiend two things anyway.

[23:57] <sjohnson> wow

[23:57] <sjohnson> i had no idea that was him!!!

[23:57] <skids> :-)

[23:58] <revdiablo> jnthn: I wouldn't call the first coercion at all... rather, a form of type checking

[23:58] <jnthn> revdiablo: Right, that's my point. :-)

[23:58] <revdiablo> jnthn: Oh, I thought you were calling them two types of coercion. But scrolling up now I see the unification was JDlugosz's suggestion...

[23:59] <revdiablo> I guess I should have read the scrollback before, rather than after ;)

[23:59] <jnthn> ;-)

[23:59] <skids> well, i suppose if downgrading to a more general type... but that's just exposing stuff the object already had.

