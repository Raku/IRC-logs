[00:00] <jnthn> rakudo: my @a = a => 1, b => 2, c => 3; for @a.reverse.hash.kv -> $k, $v { say "$k = $v" }

[00:00] <p6eval> rakudo 595d36: OUTPUT«c = 3␤b = 2␤a = 1␤»

[00:00] <jnthn> Dunno if that's nicer.

[00:00] <jnthn> oh wait

[00:00] <jnthn> that could lose the ordering 

[00:00] <jnthn> duh 

[00:00] <japhb> jnthn: won't that lose ordering?

[00:00] <japhb> jinx

[00:01] * jnthn should just sleep ;-)

[00:01] <japhb> heh

[00:01] <japhb> We need you fully awake for tomorrow.  ;-)

[00:01] <jnthn> I can't think of much neater way than you have already tbh.

[00:01] <japhb> FAir enough

[00:01] *** payload1 left
[00:01] <jnthn> rakudo: my @a = a => 1, b => 2, c => 3; for @a.reverse.map: *.kv -> $k, $v { say "$k = $v" }

[00:02] <p6eval> rakudo 595d36: OUTPUT«c = 3␤b = 2␤a = 1␤»

[00:02] <jnthn> There's always that.

[00:02] <japhb> I'm still not used to unbracketed *.method syntax ...

[00:04] <japhb> Are { .method } and *.method exactly equivalent, aside from possible limitations on where *.method can appear?

[00:04] <jnthn> japhb: Pretty much yes

[00:04] <japhb> OK, cool

[00:04] <jnthn> *.meth generates a closure

[00:06] <jnthn> japhb: BTW, now that Tene++ has got importing from different HLLs working in Rakudo, I suspect importing stuff from Parrot libraries isn't so far off.

[00:06] *** jferrero left
[00:06] <japhb> :-) :-)

[00:06] <skids> rakudo:  my @a = a => 1, b => 2, c => 3; for @a.reverse  { .kv -> $k, $v {say "$k = $v"} }

[00:06] <Tene> jnthn: pm and I were talking about that earlier... We planned to work out the details after the Parrot release.

[00:07] <p6eval> rakudo 595d36: OUTPUT«Statement not terminated properly at line 1, near "-> $k, $v "␤in Main (src/gen_setting.pm:0)␤»

[00:07] *** cls_bsd joined
[00:07] <jnthn> Tene: Awesome. :-)

[00:08] <jnthn> skids: missing }

[00:08] <jnthn> and maybe missing : too

[00:08] <jnthn> And then .reverse doesn't want a block :-)

[00:08] <japhb> That leads to the question of how to specify at the PIR level that I want my NCI wrappers to be exportable ... right now OpenGL.pir has a magic function that you call to export the contents of the namespace.

[00:09] <japhb> I'd love to drop that function, and the manual call from Perl, and have it Just Work.

[00:09] <jnthn> japhb: The Perl 6 approach is along the lines of having a sub-namespace which contains aliases of the things to export, and I think the Parrot way has been following that somewhat.

[00:10] <jnthn> erm, sorry

[00:10] <jnthn> The HllCompiler way

[00:10] <jnthn> It may end up looking that way for the Parrot modules, or may not...

[00:11] *** fridim_ left
[00:12] <japhb> OK, so currently the OpenGL stuff is in a namespace ['parrot'; 'OpenGL'], and the magic function knows which subs to export from there.  You're saying I need to make a ['parrot'; 'OpenGL'; 'export_me_plenty'] or somesuch, export my stuff there at library load time, and then Rakudo will know to look there when I do 'use OpenGL;' ?

[00:13] <jnthn> japhb: It's To Be Discussed, but it's quite feasible it will go along those lines, yes.

[00:13] <skids> ramy @a = a => 1, b => 2, c => 3; for @a.reverse { for .kv -> $k, $v {say "$k = $v"} }kudo: 

[00:13] <jnthn> In Perl 6, you generally have two "tags"

[00:14] <skids> rakudo: @a = a => 1, b => 2, c => 3; for @a.reverse { for .kv -> $k, $v {say "$k = $v"} }

[00:14] <jnthn> ALL and DEFAULT

[00:14] <p6eval> rakudo 595d36: OUTPUT«Scope not found for PAST::Var '@a' in ␤in Main (src/gen_setting.pm:3122)␤»

[00:14] <jnthn> Actually it'd be more like ['parrot'; 'OpenGL'; 'EXPORT'; 'ALL' ] that they go into if it's following the same model.

[00:14] <skids> rakudo: my @a = a => 1, b => 2, c => 3; for @a.reverse { for .kv -> $k, $v {say "$k = $v"} }

[00:15] <p6eval> rakudo 595d36: OUTPUT«c = 3␤b = 2␤a = 1␤»

[00:15] <japhb> OK, I was going to ask about how that interacts with tagging, but you beat me to it.

[00:15] <japhb> :-)

[00:15] <jnthn> There may be some kind of sugar to save you writing all of the namespace aliases out by hand though.

[00:15] <skids> (was missing a 'for' actually)

[00:15] <jnthn> skids: There's More Than One Way To Make It Syntactically Valid ;-)

[00:16] <skids> ...but it still helps if you can type :-)

[00:16] <japhb> Is the assumption that Parrot languages that don't have the concept of import tags will just assume DEFAULT under the covers?

[00:17] <jnthn> japhb: Yeah, I guess DEFAULT and ALL will just be the same thing and they'll both just have the export list.

[00:18] <jnthn> Well, export hash I guess. 

[00:18] *** bacek left
[00:19] <japhb> So tagless_lang importing from Rakudo imports DEFAULT, and tagless_lang exporting to Rakudo exports ALL = DEFAULT.  Sensible.

[00:19] *** donaldh joined
[00:20] <jnthn> japhb: Yeah, I think it'll work out.

[00:22] *** M_o_C left
[00:24] <s1n> pmichaud: ping

[00:24] *** payload joined
[00:29] * jnthn -> sleep, see y'all tomorrow

[00:29] *** hercynium joined
[00:32] *** bacek joined
[00:32] <japhb> I need some help understanding why the following two are different:

[00:32] <japhb> rakudo: my @foo = a => (<x y z>), b => (<r g b>); say @foo.perl; for @foo.map: *.kv -> $k, $v { say $v.perl }

[00:32] <japhb> rakudo: my @foo = a => [<x y z>], b => [<r g b>]; say @foo.perl; for @foo.map: *.kv -> $k, $v { say $v.perl }

[00:33] <p6eval> rakudo 595d36: OUTPUT«["a" => ["x", "y", "z"], "b" => ["r", "g", "b"]]␤"x"␤"z"␤"r"␤"b"␤»

[00:33] <p6eval> rakudo 595d36: OUTPUT«["a" => ["x", "y", "z"], "b" => ["r", "g", "b"]]␤["x", "y", "z"]␤["r", "g", "b"]␤»

[00:33] <japhb> The frustrating part is that the @foo.perl is the same in both cases.

[00:36] <pmichaud>  japhb: that will change soon.

[00:36] <pmichaud> (<x y z>) will itemize to a Capture, while [<x y z>] will be an Array.

[00:36] <TimToady> bare <x y z> should probably also itemize to Capture

[00:37] <pmichaud> Yes

[00:37] <TimToady> since <> is defined in terms of ()

[00:37] <pmichaud> Lists will itemize to Capture.

[00:37] <pmichaud> I've been waiting to do that as part of the other array/list refactors that need doing.

[00:38] <pmichaud> dinnertime here.

[00:40] *** lichtkind joined
[00:40] <japhb> OK, so just to be clear:  The second case with [<x y z>] will be unchanged after your fixes.  But will the first case with (<x y z>) change only in the @foo.perl part, with the for loop having the same behavior, or will both the .perl and the loop output change?

[00:42] <TimToady> radudo:  my @a = a => 1, b => 2, c => 3; for @a.reverse>>.kv { say $_.join(' = ') }

[00:42] <japhb> (typo)

[00:42] <TimToady> rakudo:  my @a = a => 1, b => 2, c => 3; for @a.reverse>>.kv { say $_.join(' = ') }

[00:42] <p6eval> rakudo 595d36: OUTPUT«c = 3␤b = 2␤a = 1␤»

[00:43] <skids> TimToady: I thought hypers do not order?

[00:44] <TimToady> they order return value, not order of execution

[00:44] <TimToady> hypers would be useless if they scrambled the result

[00:44] <japhb> Funky.  So .kv is giving back a capture, but because you're using a block rather than a pointy, the capture is not flattening, but is available directly in $_?

[00:44] <TimToady> it's returning an array of kv arrays

[00:44] <japhb> s/flattening/binding

[00:45] <TimToady> [['c','3'],['b','2'],['a','1']]

[00:46] <TimToady> just another way to map the .kv over the values

[00:46] <japhb> TimToady: gotcha.  I was confused, and was assuming [('c', '3'), ('b', '2'), ('a', '1')]

[00:47] <TimToady> well, it might do that eventually

[00:47] <japhb> OK, so my assumption had some minor basis in sanity.  Good.

[00:48] <TimToady> I was just trying to replace the map, not illustrate captures

[00:48] <japhb> sure.

[00:48] <meppl> good night

[00:48] *** cognominal left
[00:52] <TimToady> perl6: my @a = (1..10); my @b = (11..20); sub infix:<XXX> ($a,$b) { say "$a $b" }; @a >>XXX<< @b

[00:52] <p6eval> rakudo 595d36: OUTPUT«Statement not terminated properly at line 1, near ">>XXX<< @b"␤in Main (src/gen_setting.pm:0)␤»

[00:52] <p6eval> ..pugs: OUTPUT«2 12␤3 135 156 167 178 189 1910 201 11␤␤␤␤␤␤␤␤4 14␤»

[00:52] <p6eval> ..elf 26890: OUTPUT«Undefined subroutine &GLOBAL::XXX called at (eval 134) line 9.␤ at ./elf_h line 5881␤»

[00:54] <TimToady> you'll note pugs doesn't actually call XXX in order

[00:55] *** meppl left
[00:55] <TimToady> pugs: my @a = (1..10); my @b = (11..20); sub infix:<XXX> ($a,$b) { "$a $b" }; say @a >>XXX<< @b

[00:55] <p6eval> pugs: OUTPUT«1 112 123 134 145 156 167 178 189 1910 20␤»

[00:55] *** eternaleye joined
[00:55] <TimToady> but it still returns the results in order

[00:55] <TimToady> skids: ^^^

[00:55] <skids> thanks.

[00:56] <TimToady> one of those spots where pugs still wins :)

[00:56] <skids> :-)

[01:02] <TimToady> decommutationalization &

[01:16] *** Whiteknight left
[01:21] *** cognominal joined
[01:28] *** lambdabot left
[01:33] *** lambdabot joined
[01:49] *** justatheory joined
[01:52] *** frew joined
[01:54] *** justatheory left
[01:58] *** cj joined
[01:59] <cj> TimToady: have you ever mucked with wordnet databases?  Is there a linguistics channel I should be asking this on? :)

[02:08] *** unobe joined
[02:08] *** rhr_ joined
[02:12] *** unobe left
[02:13] *** unobe joined
[02:14] *** unobe left
[02:20] *** unobe joined
[02:22] *** rhr left
[02:31] *** meppl joined
[02:37] *** [particle] joined
[02:37] *** [particle]1 left
[02:42] *** sri_kraih_ joined
[02:44] <s1n> cj: i've used wordnet before, but dunno if there's a channel (would be nice to know)

[02:45] *** unobe left
[02:46] *** lichtkind_ joined
[02:47] *** lichtkind_ left
[02:49] *** cdarroch left
[02:51] *** sri_kraih left
[02:53] <TimToady> cj: you mistake me for a real lingrist  :)

[02:53] <cj> TimToady: oh, you just work with those computer languages, eh?

[02:59] *** lichtkind left
[03:04] *** spx2_ is now known as spx2

[03:05] *** hercynium left
[03:17] *** alester joined
[03:20] *** donaldh left
[03:20] *** donaldh joined
[03:31] *** LylePerl left
[03:31] *** LylePerl joined
[03:32] *** japhb_ joined
[03:41] *** orafu left
[03:42] *** orafu joined
[03:43] *** cotto left
[03:43] *** Maghnus joined
[03:43] *** meppuru joined
[03:48] *** cotto joined
[03:49] *** japhb left
[03:59] *** meppl left
[04:18] *** H1N1[A] joined
[04:20] *** xinming_ joined
[04:26] *** justatheory joined
[04:33] *** H1N1[A][Again] left
[04:39] *** xinming left
[04:40] <[particle]> context flea glammal

[04:45] *** [particle] left
[04:48] *** mikehh joined
[04:50] *** skids left
[05:00] *** alester left
[05:02] *** mkehh left
[05:05] *** araujo joined
[05:07] *** nihiliad left
[05:16] *** frew left
[05:25] <dalek> rakudo: 5e2e2c1 | pmichaud++ | src/ (3 files):

[05:25] <dalek> rakudo: Add qx{}, qqx{}, q:x{}, qq:x{}.

[05:25] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5e2e2c1f4200797cc7c86857bcd460388bf2e944

[05:28] *** ejs joined
[05:32] *** Andronic joined
[05:34] *** DemoFreak joined
[05:49] <pmichaud> rakudo:  say qx{ls}

[05:49] <p6eval> rakudo 5e2e2c: OUTPUT«build␤Configure.pl␤CREDITS␤docs␤LICENSE␤Makefile␤parrot␤perl6␤perl6.c␤perl6.o␤perl6.pbc␤perl6.pir␤perl6_s1.pbc␤rakudo_revision␤README␤src␤t␤Test.pir␤Test.pm␤tools␤␤»

[05:51] *** eternaleye left
[05:55] *** eternaleye joined
[05:59] <TimToady> rakudo: say qx{./perl6 -e 'say "hi"'}

[05:59] <p6eval> rakudo 5e2e2c: OUTPUT«hi␤␤»

[05:59] *** mberends joined
[05:59] <eternaleye> Wow.

[06:00] <dalek> rakudo: 33dd7ac | pmichaud++ | docs/ (2 files):

[06:00] <dalek> rakudo: Some news and announcement updates in preparation for release.

[06:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/33dd7ac3519b2efa884a8790eab27a0d3296af8b

[06:00] <mberends> hey! that is seriously ++! pmichaud++!

[06:01] <eternaleye> ++pmichaud++ # this too

[06:03] <TimToady> rakudo: say qx{./perl6 -e 'say qx[./perl6 -e "say q<hello #perl6>"]'}

[06:03] <p6eval> rakudo 33dd7a: OUTPUT«hello #perl6␤␤␤»

[06:03] <eternaleye> rakudo: say qq:x{ ./perl6 $*PROGRAM_NAME }, 'This should be interesting'

[06:04] <eternaleye> Uh oh

[06:04] <japhb_> I wondered how long people could resist the DoS

[06:05] <eternaleye> I was just testing interpolation! My subconscious just had an idea...

[06:05] <eternaleye> I shouldn't have listened to it

[06:06] *** japhb__ joined
[06:07] <pmichaud> I'll be curious to know if qx{} works on Windows.

[06:09] <s1n> pmichaud: ping

[06:09] <pmichaud> @tell masak you might check the draft release announcement (docs/announce/2009-05) and tell me if there are any chagnes you'd like made

[06:09] <lambdabot> Consider it noted.

[06:09] <pmichaud> s1n: pong

[06:09] <s1n> still giving out commitbit to perl6 on github?

[06:09] <pmichaud> sure.  What do you want the repo to be called for your project?

[06:10] <s1n> epoxy-resin

[06:10] *** brunov left
[06:11] <pmichaud> what's your github id ?

[06:11] <s1n> s1n

[06:11] <dalek> rakudo: 0ce0f62 | pmichaud++ | docs/ChangeLog:

[06:11] <dalek> rakudo: Update ChangeLog a bit.

[06:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0ce0f62f29bc0e21c74a86ab616443daeb137d8d

[06:11] <pmichaud> do you have an existing git repo for it, or should it start new?

[06:12] <s1n> none yet

[06:12] <pmichaud> okay, starting new.

[06:12] <s1n> thanks :)

[06:12] <s1n> pmichaud: btw, have you seen gitorious? it looks like it has a better patch review process

[06:13] <pmichaud> now created: http://github.com/perl6/epoxy-resin/

[06:14] <pmichaud> I haven't looked at gitorious yet, no.

[06:14] *** [particle] joined
[06:18] *** p6eval left
[06:18] *** p6eval joined
[06:19] <moritz_> rakudo: say Regex ~~ Routine

[06:19] *** DemoFreak left
[06:19] <p6eval> rakudo 0ce0f6: OUTPUT«1␤»

[06:21] <s1n> pmichaud++ thanks

[06:22] <s1n> bed&

[06:23] *** japhb_ left
[06:23] *** japhb__ is now known as japhb

[06:25] *** amoc joined
[06:31] *** iblechbot joined
[06:34] <pmichaud> back later  # bedtime

[06:35] <moritz_> good night

[06:35] *** justatheory left
[06:36] *** ejs left
[06:41] <japhb> @tell masak pull request for proto waiting for you at github.  :-)

[06:41] <lambdabot> Consider it noted.

[06:51] *** donaldh left
[07:00] *** ElectricHeavyLan left
[07:03] *** ejs joined
[07:13] *** ejs left
[07:19] *** smtms left
[07:35] *** donaldh joined
[07:46] *** ejs joined
[07:55] *** donaldh left
[07:57] *** ejs left
[07:57] *** ejs joined
[07:59] *** donaldh joined
[08:05] *** M_o_C joined
[08:15] <Matt-W> Morning

[08:16] <moritz_> good morning

[08:19] <Matt-W> No

[08:19] <Matt-W> Not a good morning

[08:19] <Matt-W> Just a morning

[08:21] <araujo> Just Morning

[08:27] *** keepguessing left
[08:28] *** tulcod joined
[08:33] <mberends> Matt-W: hopefully the fact that pmichaud++ just gave us qx{} and qq:x{} makes the morning a bit better for, and it's Rakudoday as well!

[08:33] <mberends> s/for/for you/

[08:34] <moritz_> rakudo: my $a = "foo"; say uc qq:x{echo $a}

[08:34] <p6eval> rakudo 0ce0f6: OUTPUT«FOO␤␤»

[08:34] <moritz_> woooot

[08:35] <mberends> woooooooot

[08:35] <Matt-W> mberends: That improves things a little bit

[08:36] <mberends> :)

[08:36] <Matt-W>  say qx{find my car}

[08:37] *** Su-Shee joined
[08:37] <Su-Shee> hi.

[08:39] <mberends> hi, are you going to play with SQLite today?

[08:40] * mberends must install Windows on a laptop for $work tomorrow

[08:40] <Su-Shee> no, I have to get some work-for-rent done and afterwards I think I'll do some code for the blog in p6.

[08:41] <Su-Shee> and put the 69845604 other ideas for parrot/rakudo on hold. ;)

[08:41] *** DemoFreak joined
[08:43] <mberends> rakudo: say qx{ find . -name '*car*' | wc -l };

[08:43] <p6eval> rakudo 0ce0f6: OUTPUT«25␤␤»

[08:44] <mberends> Matt-W: is one of those your car?

[08:47] <mberends> moritz_: does evalbot run in a chroot jail?

[08:49] *** M_o_C left
[08:49] <moritz_> mberends: yes

[08:49] <moritz_> mberends: but please don't screw it anyway :-)

[08:49] *** M_o_C joined
[08:51] <mberends> moritz_: i would not deliberately, promise

[08:51] *** bacek left
[08:52] *** bacek joined
[08:52] <moritz_> at some point we need a safe mode

[08:54] <Matt-W> mberends: unfortunately not

[08:56] *** amoc left
[08:57] *** dakkar joined
[09:02] *** sparc joined
[09:03] *** riffraff joined
[09:03] <mberends> rakudo: print qx{env}

[09:03] <p6eval> rakudo 0ce0f6:

[09:03] <p6eval> ..OUTPUT«SHELL=/bin/bash␤TERM=screen␤USER=evalenv␤LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.svgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;3…

[09:05] <mberends> rakudo: %*ENV{"FOO"}="BAR"; print qx{echo $SHELL $FOO $SHELL}

[09:05] <p6eval> rakudo 0ce0f6: OUTPUT«/bin/bash /bin/bash␤»

[09:06] <mberends> fraid proper CGI apps must still wait

[09:10] *** amoc joined
[09:11] *** payload left
[09:11] *** payload1 joined
[09:12] *** fridim_ joined
[09:18] *** M_o_C left
[09:20] <jnthn>  H H  , 'tis Rakudo day.

[09:20] <tulcod> holy cow, hubble pix http://gigapica.geenstijl.nl/2009/05/bye_bye_hubble.html

[09:21] <Matt-W> OH HAI jnthn

[09:21] <Matt-W> What marvels do you have planned today?

[09:21] <jnthn> Matt-W: First, coffee...

[09:22] <Matt-W> That sounds like a good start

[09:39] *** amoc left
[09:43] *** alc joined
[09:46] <dalek> rakudo: 34823c9 | masak++ | docs/announce/2009-05:

[09:46] <dalek> rakudo: [docs/announce/2009-05] nitpicked about my home

[09:46] <dalek> rakudo: Technically, I live in Uppsala and Stockholm is simply the closest PM group

[09:46] <dalek> rakudo: around. I tried to express this as succinctly-but-still-correct as possible

[09:46] <dalek> rakudo: in the announcement. Further edits are appreciated.

[09:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/34823c9b321b7c5b4dbcb7715606231851dd4a25

[09:47] *** payload joined
[09:47] *** payload left
[09:47] *** payload joined
[09:48] *** payload1 left
[09:49] <jnthn> Uppsala. Stockholm. They're both in the north anyways. :-P

[09:49] * jnthn has coffee and finished backlogging

[09:56] *** flw joined
[09:57] *** DemoFreak left
[09:59] *** flw is now known as su2admin

[09:59] *** fridim_ left
[10:01] *** su2admin is now known as flw

[10:02] *** clintongormley joined
[10:04] *** amoc^ joined
[10:09] <dalek> rakudo: dcc0fdd | jnthn++ | build/PARROT_REVISION:

[10:09] <dalek> rakudo: Bump PARROT_REVISION up to the revision of the Parrot release, so we're testing against the Parrot Thursday's release should run on.

[10:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/dcc0fdd45f13e1c6e7ee77bdef4cee52d2fc883e

[10:09] <dalek> rakudo: 6685755 | jnthn++ | docs/ChangeLog:

[10:09] <dalek> rakudo: Few extras for the ChangeLog.

[10:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6685755d0ebc3e33e3a50589daace5136210ade2

[10:12] <jnthn> pmichaud: (for when you're backlogging ;-)) We might be able to close this one now: http://rt.perl.org/rt3/Ticket/Display.html?id=49812 ? Or did we only do part of it?

[10:21] *** flw left
[10:30] *** [particle] left
[10:30] *** lambdabot left
[10:33] *** lambdabot joined
[10:34] *** payload left
[10:34] *** payload joined
[10:35] *** [particle] joined
[10:36] *** baest left
[10:39] *** M_o_C joined
[10:40] *** tulcod left
[10:50] *** [particle] left
[10:51] *** payload left
[10:59] *** [particle] joined
[11:01] *** [particle] left
[11:05] *** [particle] joined
[11:06] *** [particle] left
[11:10] *** [particle] joined
[11:11] *** M_o_C left
[11:11] *** dakkar left
[11:11] *** p6eval left
[11:11] *** Andronic left
[11:11] *** sri_kraih_ left
[11:11] *** Patterner left
[11:11] *** charsbar left
[11:11] *** Eevee left
[11:11] *** yahooooo left
[11:11] *** jnthn left
[11:11] *** buu left
[11:11] *** Maddingue left
[11:11] *** [particle] left
[11:12] *** jnthn joined
[11:12] *** M_o_C joined
[11:12] *** dakkar joined
[11:12] *** p6eval joined
[11:12] *** Andronic joined
[11:12] *** sri_kraih_ joined
[11:12] *** Patterner joined
[11:12] *** charsbar joined
[11:12] *** Eevee joined
[11:12] *** yahooooo joined
[11:12] *** buu joined
[11:12] *** Maddingue joined
[11:12] *** irc.freenode.net sets mode: +o jnthn

[11:15] *** [particle] joined
[11:16] *** jnthn left
[11:16] *** yahooooo left
[11:16] *** Eevee left
[11:16] *** Patterner left
[11:16] *** Andronic left
[11:16] *** buu left
[11:16] *** Maddingue left
[11:16] *** sri_kraih_ left
[11:16] *** p6eval left
[11:16] *** M_o_C left
[11:16] *** dakkar left
[11:16] *** charsbar left
[11:16] *** [particle] left
[11:17] *** estrabd_ left
[11:18] <literal> do all public object attributes become valid named arguments to .new() ?

[11:18] *** jnthn joined
[11:18] *** M_o_C joined
[11:18] *** dakkar joined
[11:18] *** p6eval joined
[11:18] *** Andronic joined
[11:18] *** sri_kraih_ joined
[11:18] *** Patterner joined
[11:18] *** charsbar joined
[11:18] *** Eevee joined
[11:18] *** yahooooo joined
[11:18] *** buu joined
[11:18] *** Maddingue joined
[11:18] *** irc.freenode.net sets mode: +o jnthn

[11:18] <literal> if so, how would one exclude an attribute from that?

[11:19] <moritz_> literal: by writing a custom constructor

[11:19] *** [particle] joined
[11:20] *** donaldh left
[11:20] <literal> that seems tedious for such a simple thing :P

[11:20] <literal> a trait on the "has $.attr" declaration would be convenient

[11:20] <moritz_> submethod new { $?CLASS.bless }

[11:20] <moritz_> how very tedious

[11:20] *** donaldh joined
[11:20] <moritz_> or 'method new'

[11:20] <jnthn> moritz_: bless probably needs an arg...

[11:20] *** kst left
[11:21] <literal> how does this say that some arbitrary attribute is to be exluded from .new ?

[11:21] <moritz_> literal: that writes a .new that doesn't set any attribute

[11:21] *** kst joined
[11:21] <literal> so you'd have to manually list all the ones you want to include

[11:21] <literal> more tedious :)

[11:21] *** [particle] left
[11:22] <moritz_> or manually delete those from %_ that you want to exclude

[11:22] <moritz_> and pass |%_ to bless

[11:22] <moritz_> or so

[11:22] <literal> yeah but that doesn't complain if the user passes it to .new

[11:22] <moritz_> neither does the current one

[11:22] <jnthn> method new(*%named where { !%^x.contains('exclude') }) { ... } # or some such

[11:22] <moritz_> superfluous arguments are ignored

[11:22] <literal> oh, ok

[11:22] <moritz_> literal: anyway, feel free to write a mail to p6l and propose it

[11:23] <jnthn> We can't provide sugar for everything people could possibly want... :-S

[11:23] <literal> I haven't really looked at Perl 6 objects much, it was just a thoughtt

[11:23] <moritz_> well, maybe it's not a bad idea

[11:25] *** [particle] joined
[11:25] <literal> I was just looking at http://programming-scala.labs.oreilly.com/ and thought "neat, they have class Foo (SIGNATURE) { }" and thought "oh wait I don't even need that in Perl 6 because it is determined by the public attributes", then wondered about excluding some from the constructor

[11:25] <jnthn> tbh I'd probably prefer to leave this in the module world.

[11:26] <jnthn> class Foo does CoolAutoConstructor[exclude => 'foo'] { }

[11:26] <moritz_> or it could be a custom trait

[11:26] <jnthn> That'd be a cool easy module to write.

[11:26] <jnthn> Yeah, or do it with a custom trait perhaps.

[11:26] <jnthn> But then you need to somehow pull in a new method.

[11:27] <moritz_> (don't know how easy or hard that is)

[11:27] <moritz_> since traits are mixins... seems possible

[11:27] <moritz_> well, the trait is applied on an attribute, and you need to obtain the class to which the attribute belongs

[11:27] <moritz_> so some kind of introspection will be necessary

[11:27] <jnthn> Right, but you're mixing into the variable rather than the class...though if there's a way to get at the class...

[11:28] <Matt-W> you'd need a path that says 'hey, variable, are you a class attribute? Can I talk to your class please?'

[11:28] <jnthn> Yeah, I'm just not entirely sure how that would look.

[11:28] <moritz_> maybe CALLER::$?CLASS in the trait_auxiliary:<is> multi

[11:28] <jnthn> Maybe that, yes.

[11:28] <jnthn> If $?CLASS is context.

[11:29] * jnthn spectesting fix for 64594 - that wins us +19 tests.

[11:29] *** [particle] left
[11:29] <Matt-W> woohoo

[11:30] <jnthn> moritz++ for the tests :-)

[11:30] * Matt-W looks up the bug

[11:30] <Matt-W> ooch

[11:33] *** payload joined
[11:34] *** icwiener joined
[11:35] *** [particle] joined
[11:37] *** [particle] left
[11:40] *** [particle] joined
[11:42] *** [particle] left
[11:42] *** iblechbot left
[11:45] *** [particle] joined
[11:47] *** [particle] left
[11:47] *** alc left
[11:50] *** [particle] joined
[11:52] *** [particle] left
[11:55] *** [particle] joined
[11:57] *** [particle] left
[12:00] *** ruoso joined
[12:00] *** [particle] joined
[12:00] <ruoso> Hello!

[12:01] *** [particle] left
[12:03] <pugs_svn> r26891 | jnthn++ | [t/spec] Some unfuding for Rakudo.

[12:04] <dalek> rakudo: 6229131 | jnthn++ | src/classes/Object.pir:

[12:04] <dalek> rakudo: Fix typed array and hash attributes so that the type checking is enforced. Resolves RT#64594.

[12:04] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6229131d8422b8bcbedecd3821b2d0add043ee1a

[12:05] *** [particle] joined
[12:06] <jnthn> rakudo: class Foo { has $.x = rand }; say Foo.new.x; say Foo.new.x; say Foo.new.x;

[12:06] <p6eval> rakudo 668575: OUTPUT«0.652888946076022␤0.652888946076022␤0.652888946076022␤»

[12:06] <moritz_> ouch

[12:06] <jnthn> lolz

[12:06] <moritz_> rakudo: say rand, rand, rand

[12:06] <p6eval> rakudo 668575: OUTPUT«0.6477605147092650.620590299225540.79427869505356␤»

[12:06] <jnthn> I made you a random number but I eated it.

[12:06] <jnthn> moritz_: I've fixed it locally.

[12:07] <moritz_> well, .652888946076022 looks like a good random number to me :-)

[12:07] <jnthn> moritz_: Just wanted to make sure existing Rakudo really did it wrong.

[12:07] *** [particle] left
[12:07] <jnthn> moritz_: Yeah, but it's kinda the debian ssh definition of random. ;-)

[12:07] <moritz_> right.

[12:07] <jnthn> .oO( that was inflamatory )

[12:08] <moritz_> rakudo: class Foo { has $.x = rand }; my @a = map { Foo.new.x } 1..10; say ?(all(@a) == all(@a))

[12:08] <p6eval> rakudo 668575: OUTPUT«Statement not terminated properly at line 1, near "1..10; say"␤in Main (src/gen_setting.pm:0)␤»

[12:08] <jnthn> Also my change makes this one work...

[12:08] <moritz_> rakudo: class Foo { has $.x = rand }; my @a = map { Foo.new.x }, 1..10; say ?(all(@a) == all(@a))

[12:08] <jnthn> class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b; }

[12:08] <jnthn> say Foo.new.c

[12:08] <p6eval> rakudo 668575: OUTPUT«1␤»

[12:08] <jnthn> 3

[12:08] <moritz_> cool

[12:08] <jnthn> Which fails under current Rakudo.

[12:09] <jnthn> masak should be happy about that one :-)

[12:09] <moritz_> rakudo: say ?(all(1, 2, 3) == all(1, 2,4))

[12:09] <p6eval> rakudo 668575: OUTPUT«0␤»

[12:10] <moritz_> uhm, that check should be [==] @a, of course

[12:10] *** [particle] joined
[12:10] <moritz_> don't mess with junctions when you can mess with hyper ops instead :-)

[12:10] <jnthn> >>==<< is hyper op btw

[12:10] <jnthn> [==] is reduction

[12:10] <moritz_> erm, yes

[12:10] <moritz_> I meant meta ops

[12:10] <jnthn> :-)

[12:11] *** ejs1 joined
[12:11] <jnthn> async { qx{make spectest}; } qx{ make lunch}

[12:12] *** [particle] left
[12:14] <pmichaud> rakudo:  say qx { echo 'good morning #perl6' }

[12:14] <p6eval> rakudo 668575: OUTPUT«good morning #perl6␤␤»

[12:14] *** riffraff left
[12:14] <Matt-W> pmichaud: showoff :)

[12:14] <moritz_> quite understandable once you've got that feature working :-)

[12:15] <moritz_> did anybody test that on windows?

[12:15] <moritz_> (me looks at jnthn)

[12:15] *** [particle] joined
[12:15] <jnthn> ooh, no, but can do

[12:16] <jnthn> > say qx { echo 'good morning #perl6' }

[12:16] <jnthn> Unable to open filehandle from path ' echo 'good morning #perl6' '

[12:16] <lambdabot>   <no location info>:

[12:16] <lambdabot>      lexical error in string/character literal at chara...

[12:16] <jnthn> lambdabot: stfu

[12:16] <moritz_> is there an echo builtin on windows?

[12:16] <jnthn> aye

[12:16] <Matt-W> but it's nto a program

[12:16] <jnthn> C:\Consulting\parrot\trunk\languages\rakudo>echo 'good morning #perl6'

[12:16] <jnthn> 'good morning #perl6'

[12:16] <Matt-W> it's a builtin I think

[12:17] <Matt-W> on unix it's /usr/bin/echo

[12:17] <jnthn> Matt-W: ah, good point

[12:17] <Matt-W> but there's no echo.exe on windows

[12:17] <moritz_> jnthn: just try say qx{dir}

[12:17] *** [particle] left
[12:17] <Matt-W> I think that's also a builtin

[12:17] <jnthn> moritz_: That doesn't work either, but I think that is also builtin.

[12:17] <jnthn> But I tried say

[12:17] <moritz_> oh my

[12:17] <jnthn> qx{ notepad } which is a program

[12:18] <jnthn> And same error.

[12:18] <Matt-W> damn

[12:18] <jnthn> aye :-(

[12:18] <Matt-W> windows' process model is quite different

[12:19] <Matt-W> it's one of the less pleasant bits of crossplatform programming IMO

[12:19] <moritz_> windows and VMS seem to cause the most trouble for Perl 5

[12:20] *** [particle] joined
[12:22] *** ejs left
[12:22] *** [particle] left
[12:25] *** [particle] joined
[12:27] *** payload left
[12:29] *** iblechbot joined
[12:40] *** skids joined
[12:40] <Matt-W> moritz_: that's because windows and vms are the most weird things around

[12:42] <jnthn> I fear that it's something that'd need fixing at a Parrot level rather than a Rakudo one. :-(

[12:43] *** mizioumt joined
[12:44] <pmichaud> Yes, I'm pretty sure it's a Parrot level fix, since all that Rakudo is doing is 'open' with an 'rp' mode.

[12:44] *** justatheory joined
[12:44] *** zamolxes joined
[12:45] <jnthn> Aye. In which case, it ain't going to be something we can fix in the Rakudo release (since the Parrot release is already cut).

[12:49] <moritz_> then you should note in the ChangeLog that it's Unix only

[12:56] *** smtms joined
[12:57] *** iblechbot left
[13:07] *** [particle] left
[13:09] <Matt-W> aye, and then see about getting it fixed for parrot 1.3

[13:10] *** [particle] joined
[13:10] *** [sbp] joined
[13:12] *** [particle] left
[13:15] *** [particle] joined
[13:17] *** [particle] left
[13:18] *** kst left
[13:18] *** kst joined
[13:19] * jnthn thinks he's finally down the various spectest failures his fixes to attr init caused.

[13:19] *** DemoFreak joined
[13:19] <Matt-W> excellent

[13:20] <jnthn> (There was a rather subtle issue when you had a parametric role and were using one of its parameters to initialize the attribute.)

[13:20] *** [particle] joined
[13:21] <Infinoid> Does rakudo build with the parrot 1.2.0 installed on feather?  Sounds like partcl is having problems (with pbc_to_exe for example), and I want to know if there are any blockers.

[13:22] <jnthn> Infinoid: afaik Rakudo won't build on an installed Parrot yet

[13:22] <Infinoid> So "it's broken but not a blocker"?

[13:22] <jnthn> (So if it won't under 1.2.0 I don't think it's a regression.)

[13:22] <jnthn> See what pm just said on #parrot

[13:22] *** [particle] left
[13:22] <Infinoid> ok, thanks

[13:23] * jnthn wonders if we have any tests for class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b; } style stuff.

[13:25] *** [particle] joined
[13:26] <rjh> i was looking at SQL::Interpolate::Filter which is pretty cool

[13:26] <rjh> it does sql/SELECT * FROM foo WHERE x = $x/

[13:26] <rjh> and interpolates the variables automatically

[13:26] <rjh> it uses rather dodgy source filtering though

[13:26] <rjh> i assume perl 6 can do this natively?

[13:27] <jnthn> Aye, there should be a clean way to do that in Perl 6.

[13:27] *** [particle] left
[13:27] <jnthn> Guess it's a custom quoting construct of some kind.

[13:28] <rjh> So you define your own quoting construct and that's an arbitrary block of code that runs over the text inside?

[13:30] *** sbp is now known as sbp-not-spb

[13:30] <jnthn> I think the cleanest way is just to derrive a sub-language.

[13:30] *** [particle] joined
[13:31] <jnthn> And parse it using normal Perl 6 grammar syntax.

[13:31] <jnthn> And have some kind of action handler to do the Right Thing when a variable is seen.

[13:31] <pmichaud> okay, I think I know how to resolve/workaround the "rakudo is slow in its own HLL" problem

[13:32] <jnthn> pmichaud: With or without a Parrot change?

[13:32] <pmichaud> without

[13:32] <jnthn> If we can do it without one, then it'll benefit this release.

[13:32] <pmichaud> there's a bug we likely ought to have fixed in Parrot as well

[13:32] <jnthn> OK, great.

[13:32] <jnthn> *nod*

[13:32] *** [particle] left
[13:32] <jnthn> Well, next release...

[13:33] <jnthn> I spotted the "performance improvements" in ChangeLog and was like, "hmm"

[13:33] <jnthn> I MADE YOU A PERFORMANCE IMPROVEMENT BUT HLL EATED IT.

[13:34] <pmichaud> http://gist.github.com/114815  # basic reason why rakudo is slower in its own HLL

[13:35] <jnthn> rjh: See for example grammar Q is STD {

[13:35] <jnthn> Well, below there

[13:35] <jnthn> And token escape:sym<$> {

[13:35] <jnthn> And what's in there.

[13:36] <jnthn> pmichaud: ah, sucky

[13:36] <pmichaud> anyway, we just should always use the get_root_namespace form when building objects from (parrot) PMC types

[13:37] <jnthn> *nod*

[13:37] <pmichaud> ohhhhhhh crap

[13:37] <pmichaud> PGE needs to do the same, then.

[13:37] <pmichaud> I can't fix that part without a parrot change.

[13:38] <jnthn> :-(

[13:38] <jnthn> But wait - PGE runs in Parrot HLL, no?

[13:38] <jnthn> Or does it have its own HLL?

[13:38] <pmichaud> the code it produces doesn't.

[13:38] <jnthn> oh

[13:38] <pmichaud> PGE is just a compiler.

[13:39] <jnthn> *nod*

[13:39] <jnthn> OK, but that's not the bit that is primarily responsible for say while 1..5000 { $i++ } being so slow.

[13:39] <pmichaud> right

[13:39] <pmichaud> I suspect that bit is in dispatch somewhere.

[13:39] <pmichaud> anyway, I'll make adjustments and we'll see what we get.

[13:39] <jnthn> *nod*

[13:44] <pmichaud> uh oh

[13:44] <pmichaud> it gets worse

[13:44] <pmichaud> (not unsolvable, but worse)

[13:45] <jnthn> pmichaud: If the issue is that it's looking for the PMCProxy that was created in the wrong namespace...

[13:46] <jnthn> ...is not a possible solution just to create and alias them ourself at startup?

[13:46] <jnthn> Then we have one bit of workaround code that we can rip out later.

[13:46] <jnthn> Rather than loads of little workarounds.

[13:46] <pmichaud> no, that's not exactly it

[13:46] <pmichaud> currently, every call to e.g.    $P0 = new ['ResizablePMCArray']

[13:46] <pmichaud> creates a new ProxyPMC

[13:46] <pmichaud> er, PMCProxy

[13:47] <jnthn> Ouch.

[13:47] *** sbp-not-spb is now known as sbp

[13:47] <pmichaud> although that could be because 'new' is looking it up in the wrong namespace and then creating it

[13:47] *** justatheory left
[13:47] <pmichaud> anyway, I suspect the correct answer (and the one I'm working on) is that we should never be doing  $P0 = new ['ResizablePMCArray']

[13:47] *** ejs2 joined
[13:47] <pmichaud> instead, it has to be

[13:48] <pmichaud> $P0 = get_root_global ['parrot';'ResizablePMCArray'];   $P0 = new $P0

[13:48] <jnthn> *nod*

[13:48] <pmichaud> but I'm not sure what we have to do for, say  Perl6Scalar or ObjectRef

[13:48] <jnthn> All PMCs live in the Parrot HLL.

[13:48] <pmichaud> are those in the parrot hll or in the perl6 hll?

[13:49] <pmichaud> I think the "all PMCs live in the Parrot HLL" is likely to bite Parrot at some point.

[13:49] <jnthn> I was saying it more as a "the way it is" rather than "the way it should be". :-)

[13:49] *** ejs1 left
[13:51] *** mizioumt1 joined
[13:51] <moritz_> ok, I'm gone for vacations... I might drop in a few times in the next few days, but all in all: "see you in 3 weeks" ;-)

[13:52] <pmichaud> it is going to be a pain to convert all of the   $P1 = new ['Perl6Scalar']  to   $P0 = get_root_namespace ['parrot';'Perl6Scalar'];  $P1 = new $P0

[13:52] <pmichaud> especially the ones in actions.pm

[13:52] <jnthn> moritz_: Have an awesome vacation. :-)

[13:52] <moritz_> jnthn: thanks ;-)

[13:52] <pmichaud> moritz_: happy travels!

[13:53] <moritz_> thank you

[13:53] <jnthn> pmichaud: It is. Have you considered a PIR macro so it can still be one line?

[13:54] <pmichaud> I _really_ prefer to avoid PIR macros.

[13:54] <jnthn> Any particular reason?

[13:54] <jnthn> I've never been bitten by basic use of them.

[13:54] <jnthn> (Never tried to be excessively clever...)

[13:55] <pmichaud> to me, they tend to reflect improper design

[13:55] <pmichaud> but more than that

[13:56] <pmichaud> in this case, most instances of    $P1 = new ['Perl6Scalar'] are being generated directly from PCT/PAST and not from code we write ourselves in actions.pm

[13:56] <pmichaud> and I'd prefer to not make PAST call the macros.

[13:56] <pmichaud> (e.g., as part of 'viviself' options)

[13:56] <Matt-W> moritz_: three weeks! Lucky you!

[13:56] <jnthn> pmichaud: OK, fair enough.

[13:57] <Matt-W> so what's wrong with saying new ['Perl6Scalar'] now?

[13:57] <pmichaud> it creates an extra PMCProxy object on each invocation.

[13:57] <Matt-W> ouch

[13:58] <Matt-W> so every time rakudo makes an object it gets hit with an extra new pmc?

[13:58] <pmichaud> not every time, but a lot of them.

[13:58] <Matt-W> enough, clearly

[13:58] <pmichaud> we get extra new pmcs every time we create a new instance of $_, $/, and $!, at minimum :-)

[13:58] <Matt-W> that happens quite a lot, doesn't it

[13:59] <jnthn> Indeed.

[13:59] <Matt-W> Oh dear

[13:59] <pmichaud> I might go ahead and use a macro for our hand-rolled PIR code, though.

[13:59] <pmichaud> I don't want actions.pm to be using macros

[13:59] *** skids left
[14:00] *** skids joined
[14:00] <pmichaud> heh

[14:00] <pmichaud> instead of a macro, it's _almost_ worth creating a dynop.

[14:01] <pmichaud> that might make actions.pm easier to handle as well

[14:01] <Matt-W> it'd be nice to have something that keeps it a one-liner

[14:02] <Matt-W> else someone's bound to stick the bad way in by mistake

[14:05] <jnthn> pmichaud: dynop works for me.

[14:06] *** DemoFreak left
[14:07] <pugs_svn> r26892 | jnthn++ | [t/spec] Some unfudging, test review/tweak and additional tests for attribute initialization.

[14:08] <pmichaud> I really wish there was a clear-cut description of class name resolution in Parrot.

[14:08] <pmichaud> e.g.   what difference is there (if any)    between    $P0 = new 'Integer'   and    $P0 = new ['Integer']

[14:09] *** payload joined
[14:09] <dalek> rakudo: f62aa0f | jnthn++ | src/ (2 files):

[14:09] <dalek> rakudo: Refactor our handling of attribute initializers. The RHS should become an anonymous method. This should get us in line with the spec, and resolves at least RT#65346.

[14:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f62aa0f231c7497b4b719f1812dec74a85365c55

[14:09] <jnthn> pmichaud: Aye, same.

[14:10] <jnthn> pmichaud: I've never been too clear on what the difference is.

[14:10] <jnthn> Or what ['Foo'] actually means.

[14:10] <pmichaud> well, it's changed over time.

[14:10] <jnthn> Ah.

[14:14] *** mizioumt left
[14:16] * jnthn dives into the multi-dispatcher to try and sort out 64882

[14:16] *** [sbp] left
[14:17] *** [sbp] joined
[14:18] *** iblechbot joined
[14:24] <pmichaud> any ideas what to call the dynop?  We'd only use it when creating PMC instances.

[14:24] <jnthn> new_pmc

[14:26] *** masak joined
[14:26] <Matt-W> surprisingly_unslow_new

[14:26] <masak> Rakudo Day! \o/

[14:26] <lambdabot> masak: You have 1 new message. '/msg lambdabot @messages' to read it.

[14:26] <jnthn> masak: Indeed. :-)

[14:27] <pmichaud> I thought of 'new_pmc' also, but I fear it's too easily confused with 'new'

[14:27] <masak> jnthn: excuse me, but Uppsala is _not_ in the north of Sweden. :P

[14:27] <jnthn> rakudo: class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b;}; say Foo.new.c

[14:27] <p6eval> rakudo f62aa0: OUTPUT«3␤»

[14:27] <jnthn> masak: Tell that to the average Swede. :-P

[14:27] <pmichaud> masak: thanks for the update to the announcement; fwiw, you can pretty much change that section to say whatever you want about Stockholm.pm

[14:28] <Matt-W> Friend of mine went to university in Uppsala

[14:28] <pmichaud> masak:  new toy

[14:28] <pmichaud> rakudo:  say qx{ls};

[14:28] <p6eval> rakudo f62aa0: OUTPUT«build␤Configure.pl␤CREDITS␤docs␤LICENSE␤Makefile␤parrot␤perl6␤perl6.c␤perl6.o␤perl6.pbc␤perl6.pir␤perl6_s1.pbc␤rakudo_revision␤README␤src␤t␤Test.pir␤Test.pm␤tools␤␤»

[14:28] <masak> pmichaud: I have surprisingly little contact with Stockholm.pm -- I usually meet them at Sweden-arranged NPWs.

[14:28] <masak> pmichaud++ # qx!

[14:28] <jnthn> "Stockholm.pm is the best pm group in the world. We travel together in our volvos to Ikea, and eat meatballs together while talking about Perl."

[14:29] <masak> jnthn: yes; so what? don't all pm groups do that? :)

[14:29] <masak> @messages

[14:29] <Matt-W> No

[14:29] <lambdabot> TimToady said 15h 14m 4s ago: STD isn't trying to be a full POD parse yet, and I don't think writing the specs for it via the bug reporting system is going to be terribly efficient :)

[14:29] <Matt-W> Nottingham.pm appears to have folded

[14:30] <masak> TimToady: you do have a point.

[14:30] * pmichaud stares at that word "yet"

[14:30] <masak> lambdabot: did you lose my other messages?

[14:30] *** [sbp] left
[14:31] <pmichaud> masak: anyway, feel free to adjust the announcement to your liking :-)

[14:31] <masak> TimToady: let me know if there's some way, besides helping with the Pod::Parser effort, to efficiently spur Pod parsing development.

[14:31] <pmichaud> (and yes, what you have now is fine)

[14:31] <masak> pmichaud: thank you. :)

[14:31] *** [sbp] joined
[14:31] *** justatheory joined
[14:31] <jnthn> oh noes my stereotypes missed mentioning abba... ;-)

[14:32] <masak> pmichaud: I did consider finding out the last number of rakudobug tickets I've submitted, and adding that.

[14:32] <masak> but for some reason, it felt a bit like boasting... :P

[14:32] <pmichaud> masak:  self-promotion is okay in my book :-)

[14:32] *** payload1 joined
[14:33] *** payload left
[14:33] <pmichaud> and in this case, it's effectively Rakudo citing your accomplishments, as opposed to you boasting about them :-)

[14:35] <masak> how convenient. :)

[14:36] <masak> (people emailing, offering summer jobs)++

[14:37] <Matt-W> nice

[14:43] *** sbp is now known as sbp`

[14:43] *** [sbp] left
[14:44] *** nihiliad joined
[14:45] *** sbp joined
[14:46] *** mizioumt joined
[14:47] *** sbp` left
[14:48] *** sbp` joined
[14:54] <masak> ooh, and $.c = $.a + $.b works too now. jnthn++

[14:55] *** zamolxes left
[14:56] <jnthn> masak: Thought you'd like that one.

[14:57] <masak> jnthn: I do indeed!

[14:57] <jnthn> Woo. 2 MMD bugs fixed in 1 patch. ...if I make it through the spectets.

[14:58] <jnthn> aww..no.

[15:03] *** jferrero joined
[15:03] <pmichaud> "new_parrot"   # dynop to create a new PMC for a parrot class

[15:03] <pmichaud> as in

[15:03] <pmichaud> $P0 = new_parrot 'Integer'

[15:03] <pmichaud> or

[15:03] <masak> japhb: thank you very much for the pull request. I've now reviewed the code. haven't decided whether to pull it in or not yet.

[15:03] <pmichaud> $P0 = new_parrot 'Perl6Scalar'

[15:04] *** mizioumt1 left
[15:04] <jnthn> pmichaud: Well, it reads kinda OK.

[15:04] <pmichaud> I'm open for other suggestions, still.

[15:04] <jnthn> Still prefer new_pmc, but not a big deal.

[15:05] <pmichaud> new_pmc strikes me as being too close to the various C functions of similar names.

[15:05] <jnthn> ah, true

[15:05] <masak> japhb: (there's certainly nothing wrong with the code quality, by the way. it's just that (1) I've been thinking of exactly this type of change in the past few days, and I arrived at a slightly different design, and (2) I'm not sure whether the addition of the 'graphdeps' subcommand is necessary for proto. maybe that should be a module using proto instead.)

[15:06] <pmichaud> kind of like how get_pointer, get_addr, etc. are currently all convoluted

[15:06] * jnthn looks at S06-multi/positional-vs-named.t and wonders (a) is it right and (b) how on earth did we ever pass it before.

[15:06] <pmichaud> checking.

[15:06] <jnthn> oh duh

[15:06] <jnthn> ignore me

[15:06] <jnthn> we don't run it.

[15:06] <jnthn> I think it's wrong anyways.

[15:06] <jnthn> multi earth (:$me)               {"me $me"};

[15:06] <jnthn> multi earth (:$him)              {"him $him"};

[15:07] <jnthn> Expecting those two to not be ambiguous (certainly in Perl 6.0.0) is most likely wrong.

[15:07] <pmichaud> originally mmd-based-on-named-args was part of the spec.

[15:07] <jnthn> Aye.

[15:07] <jnthn> OK, in this case my patch might be OK.

[15:09] *** tulcod joined
[15:10] <masak> wherein lies the difficulty in named-args-based mmd? (not questioning that it's difficult, just ignorant/curious.)

[15:11] <pmichaud> it's very easy to end up with ambiguous dispatch.

[15:11] <masak> in a qualitatively different way from other dispatch?

[15:12] <pmichaud> I'm not sure about that.

[15:13] <jnthn> masak: The narrowness analysis gets a bit more complex since you need to match up nameds. The dispatcher gets harder 'cus it has to do the same. Trying to build an efficeint MMD cache for nameds is harder too.

[15:13] <pmichaud> It does seem that it complicates the narrowness criteria a fair bit.

[15:13] <jnthn> I haven't spent time working through all of the issues that would arise from it.

[15:14] <jnthn> I can say that getting the positional case correct and efficient has been non-trivial.

[15:14] <masak> ok.

[15:14] <jnthn> (And continues to be...)

[15:14] <masak> jnthn++ # Perl 6 MMD

[15:15] <jnthn> I don't know it'd be impossible to do, but I do know perl6multisub.pmc is not the simplest bit of code in Rakudo already. ;-)

[15:15] <jnthn> And MMD is kind of a "hot path" too.

[15:15] <masak> maybe another target for a review blog post...

[15:15] <masak> I already have the spectest suite and PGE queued up, though...

[15:17] <jnthn> masak: In 65700 subset types are now enforced, but here we seem to hit issues because a lexical subset type doesn't work out too well.

[15:17] <jnthn> masak: If you have a moment, feel free to confirm that and transform the ticket into one about that.

[15:18] <jnthn> erm, for the respective "that"s.

[15:19] <masak> I submitted my first rakudobug on 2008-05-07. Since then, I've submitted 393 rakudobugs. that's a smidgeon over 1 bug per day.

[15:20] *** donaldh left
[15:20] *** alester joined
[15:20] <jnthn> masak++

[15:20] <jnthn> High Score!

[15:20] *** donaldh joined
[15:20] <masak> :)

[15:20] *** [particle] joined
[15:20] <masak> jnthn: what's the ticket number?

[15:21] <jnthn> masak: I wrote it...

[15:21] <jnthn> http://rt.perl.org/rt3/Ticket/Display.html?id=65700 # clicky

[15:21] <pmichaud> afk for a bit

[15:21] <masak> jnthn: ah, I thought that was a Parrot revision number. :)

[15:21] <jnthn> oh :-)

[15:24] * masak changes ticket

[15:25] *** hercynium joined
[15:27] <masak> jnthn: I can confirm that the evaluation still gives exactly the same result on my box.

[15:30] <masak> jnthn: so if you want, I can change the ticket subject to "lexical subset types don't work out to well"

[15:34] <jnthn> masak: Well, if you do:

[15:35] <jnthn> rakudo: subset B of Int where { $^n < 10 }; class A { has B $.c }; A.new( c => 20 ); say "alive"

[15:35] <p6eval> rakudo f62aa0: OUTPUT«Type mismatch in assignment; expected something matching type  but got something of type Int()␤in Main (/tmp/I9bgeo9Pp5:1)␤»

[15:35] <jnthn> rakudo: subset B of Int where { $^n < 10 }; class A { has B $.c }; A.new( c => 2 ); say "alive"

[15:35] <p6eval> rakudo f62aa0: OUTPUT«alive␤»

[15:35] <jnthn> So it's clearly checking the subset type when it's non-lexical.

[15:35] <jnthn> rakudo: my subset B of Int where { $^n < 10 }; class A { has B $.c }; A.new( c => 20 ); say "alive"

[15:35] <p6eval> rakudo f62aa0: OUTPUT«alive␤»

[15:36] <jnthn> It's when we stick a "my" there that we run into issues.

[15:37] *** Psyche^ joined
[15:40] <masak> ah.

[15:40] * masak updates ticket

[15:40] <jnthn> Ooh, I get a test fail but the test is bogus. rakudo_fixes++

[15:40] <jnthn> oh, hang on...

[15:40] <jnthn> :-S

[15:51] *** eternaleye left
[15:52] *** Patterner left
[15:52] *** Psyche^ is now known as Patterner

[15:54] <TimToady> rakudo: class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b;}; say Foo.new(:a(40)).c

[15:54] <p6eval> rakudo f62aa0: OUTPUT«42␤»

[15:54] <PerlJam> rakudo++

[15:54] <TimToady> rakudo: class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b;}; say Foo.new(:b(41)).c

[15:54] <p6eval> rakudo f62aa0: OUTPUT«42␤»

[15:55] <TimToady> rakudo++ indeed

[15:55] <TimToady> jnthn++ too

[15:55] <masak> rakudo: class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b;}; say Foo.new(:c(42)).c

[15:55] <PerlJam> yeah, can't forget jnthn++ 

[15:55] <p6eval> rakudo f62aa0: OUTPUT«42␤»

[15:55] <masak> ...just to complete the set.

[15:56] <PerlJam> (of course, these results could all just be special cases that we're being fooled into believing are general  ;-)

[15:56] <[particle]> rakudo: class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b;}; say Foo.new(:a(44), :b(-2)).c

[15:56] <p6eval> rakudo f62aa0: OUTPUT«42␤»

[15:56] <[particle]> rakudo: class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b;}; say Foo.new(:a(99), :b(-99), :c(42)).c

[15:56] <p6eval> rakudo f62aa0: OUTPUT«42␤»

[15:57] <[particle]> jnthn++ rakudo++

[15:57] <TimToady> rakudo: class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b;}; say Foo.new(:b(Object)).c

[15:57] <p6eval> rakudo f62aa0: OUTPUT«Use of type object as value␤1␤»

[15:57] <TimToady> rakudo: class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b;}; say Foo.new(:b(undef)).c

[15:57] <p6eval> rakudo f62aa0: OUTPUT«Use of uninitialized value␤1␤»

[15:57] <TimToady> rakudo: say Object === undef

[15:58] <p6eval> rakudo f62aa0: OUTPUT«0␤»

[15:58] <TimToady> erm

[15:58] <PerlJam> rakudo: class Foo { has $.a = 1; has $.b = 2; has $.c = $.a + $.b;}; say Foo.new(:b(Object but 4)).c

[15:58] <p6eval> rakudo f62aa0: OUTPUT«The but operator can only be used with a role or enum value on the right hand side␤in Main (/tmp/IK2K4SAsLn:1)␤»

[15:58] <TimToady> rakudo: say undef.WHAT

[15:58] <p6eval> rakudo f62aa0: OUTPUT«Failure()␤»

[15:58] <dalek> rakudo: 14bba5f | masak++ | docs/announce/2009-05:

[15:58] <dalek> rakudo: [docs/announce/2009-05] added details about rakudobugs

[15:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/14bba5f213b5d1a0fb2a2cb2f4d7d476f2106d89

[15:58] <jnthn> TimToady: What is the "erm" at? I didn't see anything that looked wrong.

[15:58] <TimToady> is okay

[15:59] <TimToady> I was still thinking undef is Object, but Failure is okay

[15:59] <TimToady> rakudo: my $x; say $x.WHAT

[15:59] <p6eval> rakudo f62aa0: OUTPUT«Failure()␤»

[15:59] <TimToady> that doesn't seem right

[16:00] <jnthn> No, it doesn't.

[16:00] <TimToady> uninitialized isn't failure

[16:00] <jnthn> That shoulda been Object, right?

[16:00] <TimToady> I wouldn't *mind* if undef === Object

[16:00] <PerlJam> that poor, poor variable.  I bet it has a complex about being a failure 

[16:00] <TimToady> one should use fail() to return failure

[16:01] <TimToady> or maybe undef should be Nil

[16:01] <skids> PerlJam: wait, Failure is an imaginary number? :-)

[16:02] *** dakkar left
[16:02] <masak> while we're all here: what's the accepted way to answer the question "was the value of this parameter passed or was it assigned its default value?"?

[16:02] <jnthn> TimToady: Maybe Nil so it behaves more nicely in lists, yeah...

[16:02] <[particle]> (undef as Nil)++

[16:02] *** kst left
[16:02] <PerlJam> TimToady: undef == Nil feels right to me.

[16:02] <[particle]> that's how i have thought of it

[16:02] <TimToady> well, currently specced to be Failure

[16:02] *** kst joined
[16:02] <jnthn> TimToady: How are your branes doing on re-speccing traits, btw?

[16:03] <[particle]> good thing i don't read the spec much ;)

[16:03] <PerlJam> masak: how do you tell the difference between the default and being assigned the same value as the default?

[16:03] <TimToady> well, the question is whether 1,$undef,3 should complain, I suppose

[16:03] <skids> masak: I thought the whole idea of defaults was to make the code not have to bother with that scenario?

[16:03] <PerlJam> masak: I don't think you can.  (or, it seems a strange thing to want to me anyway)

[16:04] <skids> If you want that, don't use an default, use a //= in the body.

[16:04] <masak> skids, PerlJam: hold on, I'll drag up the RT ticket where I last formulated this question.

[16:04] <masak> (or something a bit like it)

[16:04] <TimToady> jnthn: on traits, there's a dependency on exactly how syntax changes propagate to another scope, which I'm still trying to work out

[16:04] <jnthn> TimToady: Do you see traits as a language tweak?

[16:05] <jnthn> (I hadn't been.)

[16:05] <masak> ah, here: http://rt.perl.org/rt3/Ticket/Display.html?id=64928

[16:05] <jnthn> Or do you mean just the same underlying thing that they both need?

[16:05] <TimToady> new trait_auxiliarys and verbs are tweaks

[16:06] <masak> oh right, so it's "how do I know whether an optional typed param was passed?"

[16:06] <TimToady> and I think every tweak wants to desugar to an augment slang, but I really want to get that working in STD

[16:06] <masak> I think the way things are now is a bit problematic.

[16:06] <TimToady> unfortunately this is all on the border of what STD can't do

[16:06] <TimToady> because it doesn't actually run Perl 6

[16:07] <pmichaud> ...so, we need STD running in rakudo, yes?  ;-)

[16:07] <jnthn> TimToady: In the case where you you define a multi trait_auxiliary:<is>(...) {...} too?

[16:07] <jnthn> TimToady: That is, even if you aren't introducing new syntax, just an overload?

[16:07] <PerlJam> Clinton was  right to ask about the definition of "is"  :)

[16:07] <jnthn> (I'm trying to get a sense of what counts as a language tweak.)

[16:07] <PerlJam> masak: why do you need to know?

[16:08] <TimToady> well, it's certainly something that has to get imported at least, like any other multi

[16:08] <jnthn> Sure.

[16:08] <masak> PerlJam: if I have a parameter %h? I might somethimes want to know whether it was passed or not.

[16:08] <masak> PerlJam: I don't remember exactly why I needed it in this particular instance.

[16:08] <TimToady> so probably that can just be considered a strange name

[16:08] <masak> PerlJam: I just think it's a reasonable question.

[16:08] <TimToady> I think importing strange names has to trigger the addition of syntax

[16:08] <TimToady> if the syntax isn't already there

[16:09] <jnthn> Sure. So overloading an existing operator with another multi counts as a language tweak?

[16:09] *** baest joined
[16:09] <TimToady> kinda

[16:09] <masak> PerlJam: the alternative is to make two multisubs, one with and one without the param. that's certainly an option, but sometimes the code in the two multis would be very similar, only differing in one place, say.

[16:09] <jnthn> :-)

[16:11] <PerlJam> masak: okay, I finally read through that IRC log.  Yes, defined() seems like a good way to tell if an optional parameter was given a value or not.   (but if you really want to differentiate between a default value and a passed value, I don't see the utilityz)

[16:11] <PerlJam> s/z//

[16:11] <TimToady> rakudo: my $x; $x .= new; say $x.WHAT

[16:12] <p6eval> rakudo 14bba5: OUTPUT«Failure()␤»

[16:12] <masak> PerlJam: no, but I definitely would like to know whether an optional param was passed or not.

[16:12] <masak> rakudo: my (%h?)

[16:12] <p6eval> rakudo 14bba5: OUTPUT«get_pmc_keyed_str() not implemented in class 'String'␤in Main (/tmp/6vPzQGbrFH:1)␤»

[16:12] <masak> jnthn: bug? :)

[16:12] *** jan_ joined
[16:12] <masak> std: my (%h?)

[16:12] <p6eval> std 26892: OUTPUT«ok 00:02 37m␤»

[16:13] <PerlJam> but what does it mean? :)

[16:13] <TimToady> it means that *if* you were to bind to it, it would be optional

[16:14] *** payload1 left
[16:14] <jnthn> masak: I'm not even sure where ti's blowing up...

[16:14] <jnthn> *it's

[16:14] <masak> jnthn: that wasn't my question. :)

[16:14] <jnthn> oh, runtime.

[16:14] <jnthn> Hmm

[16:15] <TimToady> my Any $x; $x .= new; say $x.WHAT

[16:15] <TimToady> rakudo: my Any $x; $x .= new; say $x.WHAT

[16:15] <p6eval> rakudo 14bba5: OUTPUT«Any()␤»

[16:15] *** ejs2 left
[16:15] <jnthn> masak: It shouldn't crash like that.

[16:15] <TimToady> rakudo: my Object $x; $x .= new; say $x.WHAT

[16:15] * masak submits rakudobug

[16:15] <p6eval> rakudo 14bba5: OUTPUT«Object()␤»

[16:15] <jnthn> But I'm not really sure what it means... :-)

[16:15] <masak> :)

[16:16] <masak> jnthn: "what use is a new-born baby?" :)

[16:16] <TimToady> rakudo: my (%h?) := ()

[16:16] <p6eval> rakudo 14bba5:  ( no output )

[16:16] <TimToady> rakudo: my (%h) := ()

[16:17] <p6eval> rakudo 14bba5:  ( no output )

[16:17] <jnthn> TimToady: I *very* much doubt binding is doing the right thing in Rakudo like that yet.

[16:17] <jnthn> TimToady: Would my (%h?) actually declare a %h?

[16:17] <TimToady> no, it declares %h

[16:18] <masak> :)

[16:18] <TimToady> the thing in parens parses exactly like a signature

[16:18] <jnthn> TimToady: I think you interpreted my question as "...declare a %h??" ;-)

[16:19] * masak feels like Alice in Wonderland

[16:19] <skids> masak: there's that conjecture about stacking longnames, not to say that's necessarily the best resolution.

[16:19] <TimToady> what is the name of the hash called?

[16:19] <jnthn> %h

[16:19] <masak> skids: not sure what that would entail.

[16:19] <skids> Just a multi with multiple signatures sharing the same body.

[16:19] <masak> TimToady: no, that's the name of the hash. not what the hash is called.

[16:19] <skids> It's supposedly somewhere in S12

[16:20] <masak> (in Mandarin Chinese, people say "my name is called...")

[16:20] <rjh> and in French?

[16:20] <PerlJam> TimToady: so, would that mean that my ($a,$b,$c) := mumble   would (should) complain if one of $a, $b, or $c isn't provided by the RHS?

[16:21] <TimToady> yes

[16:21] <masak> rjh: in French, "I call myself...", AFAIU.

[16:21] <jnthn> masak: AFAIU too.

[16:22] <jnthn> heh, Rakudo is generating some pretty hashed up PIR for my (%h?)

[16:22] <masak> this signature binding stuff is just begging for something like Prolog-style unification.

[16:22] <TimToady> shh

[16:22] <masak> :)

[16:22] <TimToady> that's for 6.0.1

[16:23] <skids> me llamo lama

[16:23] <jnthn> skids: Ain't that Spanish?

[16:24] <skids> yes, with a poorly spelled english llama

[16:24] <PerlJam> Just don't defer too much stuff to the future.  You don't want to end up like Knuth and only have 4ish volumes of a 7 volume set.

[16:25] <masak> Knuth++

[16:25] <masak> what he's finished is impeccable.

[16:25] <masak> if anything, we should be more like him. :)

[16:26] <masak> PerlJam: you're not implying that Perl 6 isn't revolutionary enough already, are you? :)

[16:27] <jnthn> Oh, I think my (%h?) the .viviself might be tripping things up.

[16:28] *** azawawi joined
[16:29] <azawawi> hi all

[16:31] <skids>  OT: http://www.aggregate.org/MAGIC/ <-- I knew most of these but some I had never seen.  Like the dual linked list XOR trick.

[16:31] *** cdarroch joined
[16:40] *** jferrero left
[16:41] *** nihiliad left
[16:42] *** azawawi left
[16:43] <masak> rakudo: sub foo(%h?) { say %h.defined }; foo

[16:43] <p6eval> rakudo 14bba5: OUTPUT«1␤»

[16:43] <jnthn> oh phew finally...I think my MMD fix passes all existing tests plus the new ones.

[16:44] <jnthn> That was a lotta effort for a little patch...

[16:44] *** Fuad joined
[16:44] <Fuad> hi all

[16:44] <jnthn> hi Fuad 

[16:44] <Fuad> How are you jnthn ?

[16:44] <masak> Fuad: hello, buddy!

[16:44] <Fuad> Hello ,masak:)

[16:44] <jnthn> Fuad: I'm good, thanks. :-)

[16:44] <Fuad> Hows you bros?:)

[16:45] * masak is just fine

[16:45] <jnthn> Fuad: Happily hacking on Rakudo, trying to get some bugs cleaned up before the release.

[16:46] <masak> jnthn++

[16:48] <pugs_svn> r26893 | jnthn++ | [t/spec] Several tests to cover a couple of now-resolved RT tickets.

[16:50] *** masak left
[16:51] <dalek> rakudo: 01ec2a7 | jnthn++ | src/pmc/perl6multisub.pmc:

[16:51] <dalek> rakudo: Fix up Perl6MultiSub to not let named paramters get in the way in various cases. Resolves two RT tickets. Also name a magic value and a little visual tweak.

[16:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/01ec2a7bfcf2487e89e196ae72ef254de32d5200

[16:51] <jnthn> OK, that's that done.

[16:51] <jnthn> What now...

[16:52] <jnthn> rakudo: class A { has &!m = method {}; method f { &!m() } }; A.new.f

[16:52] <p6eval> rakudo 14bba5: OUTPUT«No such attribute '!m'␤in method A::f (/tmp/JSBdZRgt1W:1)␤called from Main (/tmp/JSBdZRgt1W:1)␤»

[16:52] <jnthn> Maybe this one. :-)

[16:54] <Fuad> :)

[16:54] *** mberends left
[16:56] *** payload joined
[16:57] *** gbacon left
[17:01] <Tene> pmichaud: I have ideas for hllcompiler support for PIR libraries... will detail later.

[17:01] <Tene> Must go to work now.

[17:04] *** ejs joined
[17:04] <pmichaud> Tene: excellent.

[17:14] *** ejs left
[17:14] *** justatheory left
[17:15] *** Fuad left
[17:29] *** amoc^ left
[17:29] *** sri_kraih_ left
[17:33] *** ejs joined
[17:35] *** sparc left
[17:35] *** nihiliad joined
[17:38] *** ElectricHeavyLan joined
[17:39] *** nihiliad left
[17:41] *** japhb left
[17:45] *** nihiliad joined
[17:48] *** ascent__ is now known as ascent_

[17:53] *** abra joined
[17:54] <jnthn> std: class x { has &!foo; method y($x) { $x.&!foo } }

[17:54] <p6eval> std 26893:  ( no output )

[17:54] <jnthn> huh

[17:54] <jnthn> std: class x { has &!foo; method y($x) { $x.&!foo } }

[17:54] <p6eval> std 26893:  ( no output )

[17:54] <jnthn> :-(

[17:57] *** ejs left
[18:00] *** ejs joined
[18:02] <pugs_svn> r26894 | lwall++ | [STD] allow .& as noted by jnthn++

[18:02] *** [particle]1 joined
[18:07] <jnthn> rakudo: .ffs

[18:07] <p6eval> rakudo 01ec2a: OUTPUT«Method 'ffs' not found for invocant of class 'Failure'␤»

[18:07] <jnthn> Hmm.

[18:08] <TimToady> also not a failure

[18:08] <TimToady> variables should not be (un)initialized to Failure

[18:09] <jnthn> nod

[18:10] *** lichtkind joined
[18:11] <jnthn> Hmmm. Cook or go for pizza+pivo...

[18:11] * jnthn nearly has attributes with & sigils working now...

[18:12] <TimToady> std: std: class x { has &!foo; method y($x) { $x.&!foo } }

[18:12] <p6eval> std 26894: OUTPUT«##### PARSE FAILED #####␤Syntax error at /tmp/qbkVwnXP2E line 1:␤------> [32m class x { has &!foo; method y($x) { $x.[31m&!foo } }[0m␤    expecting postfix_prefix_meta_operator␤FAILED 00:03 53m␤»

[18:12] <TimToady> hasn't reprocessed yet

[18:12] <TimToady> std: std: std: std: std: std: class x { has &!foo; method y($x) { $x.&!foo } }

[18:12] <p6eval> std 26894: OUTPUT«##### PARSE FAILED #####␤Illegal redeclaration of 'std' at /tmp/fcAfqfBBDF line 1:␤------> [32mstd: std: [31mstd: std: std: class x { has &!foo; meth[0m␤FAILED 00:02 35m␤»

[18:13] <TimToady> heh, caught me

[18:15] * jnthn chases TimToady++'s STD change.

[18:16] *** fridim_ joined
[18:17] <jnthn> woo, works

[18:19] <jnthn> (will commit spectest for it later too)

[18:22] <TimToady> std: class x { has &!foo; method y($x) { $x.&!foo } }

[18:22] <p6eval> std 26894: OUTPUT«ok 00:03 53m␤»

[18:22] <jnthn> \o/

[18:23] <TimToady> btw, trait_verb and trait_auxiliary are going to combine into trait_mod, but the actual action routines will not use those names, but some variant of TRAIT_IS(), TRAIT_DOES(), etc

[18:23] *** justatheory joined
[18:24] <TimToady> trait mods are the syntax, and the multis to which we dispatch are just uppercase to indicate automatically called routines

[18:26] <TimToady> so when you add syntax for a trait_mod, the compilation of it needs to say what routine to call with what arguments

[18:26] <TimToady> (I presume that currently there is a call to trait_auxiliary:<is> hardwired in there somewhere

[18:26] *** nsh joined
[18:26] <TimToady> it would just hardwire to TRAIT_IS (or whatever) instead

[18:26] <jnthn> Well, there isn't, because we've been cheating on the built-in traits.

[18:27] <jnthn> I was going to modify things to be calling trait_auxiliary:<is>, but anyways :-)

[18:27] <jnthn> How does this deal with namespacing of, e.g. rw?

[18:27] <TimToady> ah, well, we could cheat to the extent of extracting the <sym> and munging it into the name, but it won't help the problem that different trait_mods actually process different arguments

[18:28] *** Chillance joined
[18:28] <TimToady> doesn't say anything about namespaces yet

[18:28] <jnthn> We cheat just out of making it work. I'm fine with whatever it's meant to become.

[18:28] *** gbacon joined
[18:29] *** nsh left
[18:29] *** japhb joined
[18:30] <jnthn> OK, I'm feeling lazy...pizza it is. bbiab

[18:32] *** M_o_C left
[18:32] *** nsh joined
[18:33] *** nsh left
[18:37] *** nsh joined
[18:38] *** nsh left
[18:38] *** nsh joined
[18:38] *** nsh left
[18:49] *** nihiliad1 joined
[18:49] *** nihiliad left
[18:51] *** justatheory_ joined
[18:54] *** justatheory left
[18:55] *** nihiliad joined
[18:55] *** nihiliad1 left
[18:58] *** finanalyst joined
[19:01] <finanalyst> is there anything in the specifications that associates directory structure with module naming? Eg. if i "use mym::subm" must i have .../mym/subm.pm?

[19:01] *** abra left
[19:01] *** donaldh left
[19:05] <TimToady> see S11:236

[19:09] *** pmurias joined
[19:12] *** masak joined
[19:13] <masak> flakyneighbourwifi. hello.

[19:14] <finanalyst> TimToady: sorry to be a half-wit: is there a neat way to see the line numbers using the html versions of the synopses? or will i need to get the pod version?

[19:14] <masak> finanalyst: you can 'view source' and see the line numbers.

[19:15] <masak> but getting the pod version isn't such a bad idea either.

[19:16] *** icwiener_ joined
[19:16] *** icwiener left
[19:17] <finanalyst> thanx for view source idea. i did download, but they change faster than i can keep up. so i prefer now to view from web

[19:17] <masak> finanalyst: well, by downloading via svn or git-svn, keeping up is as easy as updating the local copy.

[19:18] <masak> ...with the added bonus that if you want to know what changed, you can query the commit logs.

[19:18] *** FabioCavallaro joined
[19:19] <finanalyst> view source doesnt work cos all the extra html padding bias the line numbers

[19:19] <masak> I'm sorry?

[19:20] *** donaldh joined
[19:21] <finanalyst> duh (:

[19:21] <finanalyst> i was looking at the html version of the Synopsis

[19:21] <finanalyst> changed to pod version

[19:21] <finanalyst> now it works.

[19:22] <masak> I have no idea what didn't work for you, but I'm glad it works now. :)

[19:24] * jnthn back from dinner

[19:24] *** FabioCavallaro left
[19:24] *** meppuru left
[19:25] <finanalyst> just to explain: i look at the Synopses at http://perlcabal.org/syn/ 

[19:25] <finanalyst> these have a version that is marked up with html

[19:25] <finanalyst> the extra html lines increase the number of lines

[19:27] <dalek> rakudo: 60f709d | jnthn++ | src/parser/grammar.pg:

[19:27] <dalek> rakudo: Follow a STD.pm addition.

[19:27] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/60f709daa6b46b2f27714446ed8b121c37c75f45

[19:29] *** clintongormley left
[19:30] *** lambdabot left
[19:30] *** kst left
[19:31] *** Scorp|away joined
[19:31] *** kst joined
[19:31] <Scorp|away> Hi. I appearently am address banned from #perl. I have no idea why, but I was hoping someone could unban me?

[19:32] <pugs_svn> r26895 | jnthn++ | [t/spec] Tests for attributes with the & sigil.

[19:33] <dalek> rakudo: ba0b2be | jnthn++ | src/ (2 files):

[19:33] <dalek> rakudo: Some tweaks to handle has &!foo and has &.foo. Resolves RT#64650 and RT#64270.

[19:33] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ba0b2be42e1fb5c307007cc8fdb3fb57101822c1

[19:33] *** lambdabot joined
[19:35] *** Scorp|away is now known as Scorp1us

[19:35] <xinming_> Scorp1us: I'm asking you for this.

[19:35] <xinming_> in #perl

[19:36] *** justatheory joined
[19:37] *** xinming_ is now known as xinming

[19:37] *** DemoFreak joined
[19:37] <Scorp1us> I got this: #perl unable to join channel (address is banned)

[19:38] <xinming> Scorp1us: It's ok, You are now in #perl, let's not pollute this channel. :-)

[19:40] *** masak left
[19:41] *** justatheory left
[19:44] *** masak joined
[19:45] *** DemoFreak left
[19:48] *** DemoFreak joined
[19:48] *** masak left
[19:49] *** justatheory joined
[19:59] *** tulcod left
[20:00] *** justatheory_ left
[20:04] *** finanalyst left
[20:16] *** szabgab left
[20:24] *** tulcod joined
[20:29] * ruoso decommute &

[20:29] *** ruoso left
[20:30] *** justatheory left
[20:37] <dalek> rakudo: b4f301d | jnthn++ | docs/ChangeLog:

[20:37] <dalek> rakudo: ChangeLog tweaks.

[20:37] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b4f301d0ce3df06edd9ad170954fa316c2b860d3

[20:39] *** ejs left
[20:40] *** kidd joined
[20:44] *** donaldh_ joined
[20:48] *** skids left
[20:48] *** DemoFreak left
[20:51] *** DemoFreak joined
[20:55] *** pmurias left
[20:55] *** skids joined
[21:02] *** Su-Shee left
[21:03] *** H1N1[A] left
[21:10] *** bacek left
[21:13] *** mizioumt left
[21:16] *** meppl joined
[21:22] *** H1N1[A] joined
[21:22] *** Whiteknight joined
[21:31] *** szabgab joined
[21:35] *** donaldh_ left
[21:46] *** [particle]1 left
[21:57] * jnthn is getting there with meta-ops for user defined ops

[21:57] <jnthn> sub infix:<wtf>($a, $b) { $a ~ "WTF" ~ $b }

[21:57] <jnthn> my $a = "OMG"; $a wtf= "BBQ"; say $a;

[21:57] <jnthn> OMGWTFBBQ

[21:59] *** jferrero joined
[22:02] *** Whiteknight left
[22:12] *** bacek joined
[22:12] *** ruoso joined
[22:17] *** nihiliad left
[22:19] <pugs_svn> r26896 | jnthn++ | [t/spec] Basic tests for meta-operators generated from user defined operators.

[22:23] *** justatheory joined
[22:26] *** icwiener_ left
[22:27] *** justatheory left
[22:32] *** [particle]1 joined
[22:33] *** alester left
[22:42] *** M_o_C joined
[22:48] <pmichaud> jnthn: is every infix: op that gets added also defining its metaop versions?

[22:49] *** ElectricHeavyLan left
[22:50] *** szabgab left
[22:51] <jnthn> pmichaud: I've left the original gen_metaop approach for all built-ins.

[22:51] <pmichaud> sure, but that doesn't answer my question :-)

[22:51] <jnthn> pmichaud: We only follow this new code-path for user-defined ops.

[22:51] <pmichaud> okay, *that* answers it :-)

[22:51] *** tulcod left
[22:51] <jnthn> And then only for infixes.

[22:51] <pmichaud> I might want to review the patch before it goes in.

[22:52] <pmichaud> or, if you can just nopaste it real quick, I can see if the approach agrees with me :-)

[22:52] *** szabgab joined
[22:52] <jnthn> oh, gah, I already did commit

[22:52] <jnthn> oh, wait, but I didn't push

[22:52] <pmichaud> spectested it yet?

[22:52] <jnthn> ...erm, how does I get a diff of something I comitted but didn't push?

[22:52] <jnthn> yes, spectested.

[22:52] <jnthn> all pass.

[22:52] <pmichaud> git diff ORIG_HEAD or git diff FETCH_HEAD or something like that

[22:52] <jnthn> Plus the new test file I wrote.

[22:52] <pmichaud> Go ahead and push, then if spectest passes.

[22:53] <pmichaud> I might ask you to refactor it :-)

[22:53] <jnthn> OK

[22:53] <TimToady> the spectest doesn't test if Xwtf is list infix prec

[22:53] <TimToady> if list infix, should need the extra parens aroung its args

[22:53] <jnthn> pmichaud: That's fine, though it'll be tomorrow for the refactor in that case, I'm tired.

[22:53] <TimToady> *shouldn't

[22:53] <pmichaud> jnthn:  no problem, it'll be tomorrow before I can tell you if I want a refactor.  :-)

[22:54] <jnthn> pmichaud: But you'll probably be happy to know that it adds very little to actions.pm

[22:54] <dalek> rakudo: 6381427 | jnthn++ | src/ (2 files):

[22:54] <dalek> rakudo: Implement generation of meta-ops for user-defined operators. Resolves RT#65660.

[22:54] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/638142748b7a17a68150647ac3a18b64ff1a661e

[22:54] <pmichaud> hopefully your changes don't stomp on the huge set I've just made.

[22:54] <jnthn> pmichaud: And mostly works in terms of lexicals.

[22:54] <jnthn> pmichaud: Unlikely. It's a few lines added in actions.pm.

[22:54] <jnthn> And then one contiguous bunch of PIR in op.pir

[22:55] <jnthn> So basically only 2 hunks. :-)

[22:55] <pmichaud> okay, it looks generally okay.

[22:55] <pugs_svn> r26897 | lwall++ | [metaoperators] test that Xwtf is list infixy

[22:55] <pmichaud> no refactor needed as yet :-)

[22:55] <jnthn> We could probably generalize it a bit more by swapping around the order of the arguments to !HYPEROP

[22:56] <jnthn> TimToady: Happily, it still passes just fine like that :-)

[22:58] * jnthn adds the test file to spectest.data

[22:58] <jnthn> TimToady++ # reviewing the new tests

[22:58] <pmichaud> I generally prefer to be using .const 'Sub'  instead of find_name these days, fwiw.

[22:58] <pmichaud> *much* safer.

[22:59] <pmichaud> (e.g., in generate_meta_op_sub)

[22:59] <pmichaud> seems like generate_meta_op_sub could also be doing the set_hll_globals

[22:59] <jnthn> pmichaud: I did originally, then wanted to choose different ones...but yes, I could still have passed in the sub rather than the name...

[22:59] <dalek> rakudo: 3c425eb | jnthn++ | t/spectest.data:

[22:59] <dalek> rakudo: Add S13-overloading/metaoperators.t to spectest.data.

[22:59] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3c425eb3e8c886e8d1a103049603ebea570d7a78

[23:01] <pmichaud> anyway, cool work :-)  jnthn++

[23:01] <jnthn> pmichaud: Aye. You're probably right on both of those...

[23:01] <jnthn> pmichaud: Anyway, another day. :-)

[23:01] <pmichaud> sure.

[23:01] <jnthn> How's the op going?

[23:02] <pmichaud> I may refactor it a bit (after release) to have that function also handle the token for the operator itself, as well as its meta ops.

[23:02] *** iblechbot left
[23:02] <jnthn> http://use.perl.org/~JonathanWorthington/journal/39011 # rakudo day report

[23:02] <pmichaud> the op itself was very easy to implement -- converting all of the existing uses of new 'XYZ'  is a bit tedious.

[23:02] <jnthn> *nod*

[23:03] <jnthn> Have you see a performance increase from the ones you did so far?

[23:03] <pmichaud> a bit.

[23:03] <pmichaud> I did a short test using the new op versus the old way of doing it and saw a significant increase

[23:03] <pmichaud> nopasting...

[23:03] <pmichaud> (waiting for perl6 to build, actually)

[23:05] <jnthn> Down to 326 tickets now.

[23:06] <jnthn> We have more RT tickets than Parrot. ;-)

[23:06] <jnthn> But Parrot has TTs too. :-)

[23:07] <pmichaud> http://gist.github.com/115147 # cost of using $P0 = new ['Integer']   versus   $P0 = root_new ['parrot';'Integer']

[23:08] <jnthn> OK, pretty significant.

[23:09] <jnthn> pmichaud: How often are we creating Perl6Scalar PMCs BTW? Are they the most common type we create?

[23:09] <pmichaud> especially since it impacted pretty much every ResizablePMCArray, Perl6Scalar, ObjectRef, P6invocation, Perl6MultiSub, etc.

[23:09] <pmichaud> anytime we enter a block we get at least three Perl6Scalar PMCs (for $_, $/, $!)

[23:10] <pmichaud> anytime we call a sub we end up with an ObjectRef

[23:10] <jnthn> Resolving the name by string/key every time is a real drag.

[23:10] <jnthn> Especially when in a given run we can (once) map the name to an ID.

[23:10] <pmichaud> we'd still have to do the lookup of that id.

[23:11] <jnthn> I'm wondering if we can do that once though, and have a dynop that creates it by ID.

[23:11] <jnthn> Yes, it's evil evil evil.

[23:11] <pmichaud> you mean a constant int of some sort?

[23:12] <pmichaud> probably epic fails with .pbcs

[23:12] <jnthn> No, you'd do it per run and cache it.

[23:12] <pmichaud> cache it where?

[23:13] <pmichaud> right now it's going to be fairly efficient -- at least as efficient as going from a key to a namespace

[23:13] <jnthn> static INTVAL id = 0;

[23:13] <jnthn> inline op create_p6s(out PMC, in PMC) { if (id == 0) lookup; $1 = pmc_new_init(interp, id, $2); goto NEXT();

[23:13] <jnthn> }

[23:13] <jnthn> gah, pasting fial

[23:13] <jnthn> *fail

[23:13] <pmichaud> oh, you mean just for Perl6Scalar

[23:14] <pmichaud> not in genera

[23:14] <pmichaud> l

[23:14] <jnthn> yeah, thus why I was asking if it's a hot path.

[23:14] <pmichaud> I'm not sure it's that hot.

[23:14] <jnthn> But really I'd hope a JIT could do the general case...

[23:14] <jnthn> "We know new + this constant string = this type ID"

[23:15] <pmichaud> they aren't strings, though.

[23:15] <pmichaud> they're keys

[23:15] <jnthn> They're still PMC constants, ze?

[23:15] <pmichaud> sure, they're PMC constants, no problem.

[23:15] <pmichaud> anyway, it's something I'd want to profile before pursuing too far.

[23:15] <jnthn> Sure, I'm not suggesting we do it Right Now.

[23:16] <jnthn> I'm just pondering how we can do better in the future.

[23:16] <pmichaud> btw, something to keep in mind when looking at using :immediate for hll sub mapping is to make sure it will still work with precompiled .pbc's

[23:16] <pmichaud> iirc, :immediate subs get lost when converting to .pbcs

[23:17] <jnthn> Yes, good point, already considered it. :-)

[23:17] <pmichaud> okay, good.

[23:17] <jnthn> I do it in the :load :init too.

[23:17] <pmichaud> but isn't that too late?

[23:17] <jnthn> I do both.

[23:18] <pmichaud> when the bytecode gets saved to .pbc, do the subs of the .pbc already have their newly blessed type in place?

[23:18] <jnthn> As I understand it, if we're creating them as Perl6MultiSub thanks to the hll_map then we'll be freezing them as Perl6MultiSub too.

[23:18] <pmichaud> okay, I still haven't figured out how that works.

[23:18] <jnthn> So there won't be anything to re-bless at startup.

[23:18] <pmichaud> I.e., how does the frozen Perl6MultiSub know how to map to the (dynpmc) type when loaded?

[23:18] <jnthn> Just the same as it does for MultiSub today.

[23:19] <jnthn> Ugh. I didn't check that bit worked. :-|

[23:19] <jnthn> I was under the impression it did.

[23:19] <pmichaud> and presuming that we do     ./parrot hello.pbc

[23:19] <jnthn> (That there's a fix-up table for this stuff.)

[23:19] <pmichaud> how would the Perl6MultiSubs in hello.pbc deal with the fact that the Perl 6 compiler hasn't even loaded yet?

[23:20] *** donaldh left
[23:20] <jnthn> In terms of their contents, they shouldn't care, just as Parrot MultiSub doesn't today.

[23:20] *** donaldh joined
[23:20] <pmichaud> except that Parrot MultiSub is already known to be loaded when we start up Parrot

[23:20] <pmichaud> because it's a "core PMC"

[23:20] <jnthn> There's a references segment in a PBC that is supposed to contain the things that we need to load.

[23:21] <pmichaud> okay, I'll presume it works until I see otherwise, then :-)

[23:21] <jnthn> Yeah, I'm maybe assuming too much works, when actually it doesn't yet.

[23:21] <jnthn> It'll need fixing up at some point, though.

[23:21] <pmichaud> I'd just say to make sure the "compile to pbc and run pbc" option works before being too hasty on commit.

[23:21] <jnthn> Going on re-blessing is kinda gonna suck...

[23:21] <pmichaud> if it doesn't work, we need to decide which is more important

[23:21] <pmichaud> or an appropriate workaround.

[23:21] <jnthn> Sure.

[23:22] <jnthn> Making everything a Perl6MultiSub will solve various lingering issues.

[23:22] <jnthn> I'm wanting this for more than just a little start-up performance win.

[23:22] <pmichaud> will Rakudo still be able to work with non-Perl6MultiSubs?

[23:22] <jnthn> You mean, from outside of the Parrot HLL?

[23:23] <pmichaud> yes, libraries not written in Rakudo.

[23:23] <jnthn> (Ones created outside of and passed in or imported...)

[23:23] <jnthn> Yes, I see no reason why not.

[23:23] <pmichaud> okay.  

[23:23] <jnthn> The end goal here is that we'll emit all sub calls and method calls just as Parrot ones, so it shouldn't matter what you're calling etc.

[23:23] <pmichaud> that's an end goal I'd really like.  :-)

[23:23] <jnthn> The abstraction is going to get leaky if you start trying to introspect them.

[23:24] <pmichaud> I don't mind if non-Rakudo subs leak.

[23:24] <jnthn> But if you just wanna call them, sure, shoudln't be an issue.

[23:24] <pmichaud> if someone is importing stuff from some other hll, then leaks are a little bit to be expected.

[23:24] <jnthn> Trying to .signature or .candidates a non-Rakudo multi is probably not going to end well.

[23:25] <jnthn> I think - and aim for - nothing worse than a "method not found" error though.

[23:25] <pmichaud> I'm fine with .signature and .candidates pessimization

[23:25] <pmichaud> okay, time for dinner here.  bbl.  Nice work today, as always.

[23:25] <jnthn> :-)

[23:25] <jnthn> Enjoy dinner

[23:26] <jnthn> I'm probably sleeping soon, so catch you tomorrow.

[23:27] *** cotto left
[23:32] *** cdarroch left
[23:35] *** cotto joined
[23:35] *** cotto left
[23:39] *** araujo left
[23:40] *** araujo joined
[23:40] *** bacek left
[23:42] *** araujo left
[23:42] *** cotto joined
[23:44] *** araujo joined
[23:48] *** araujo left
[23:49] *** sri_kraih joined
[23:52] *** DemoFreak left
[23:55] *** jferrero left
