[00:01] <cspencer> what does the $?NF variable contain?

[00:02] <moritz_> the compile-time default Unicode normal form, I think

[00:02] <moritz_> though I don't see much sense in having such a variable

[00:03] <cspencer> how come?

[00:04] *** kst left
[00:04] *** kst joined
[00:05] <moritz_> why do we need a *compile time* variable for a thing which only affects *run time*?

[00:05] <cspencer> ah, ok :)

[00:07] *** msmatsko left
[00:08] *** Guest34131 joined
[00:09] <Guest34131> hello?

[00:09] <Diederich> howdy

[00:09] <Guest34131> hi, is this the place to ask questions about perl 6?

[00:10] <Diederich> aye, but I'm just a lurker here

[00:10] <Guest34131> i c

[00:10] <Diederich> I've seen a lot of Qs ansked and answered

[00:10] <Diederich> s/ansked/asked/ :-)

[00:10] <Diederich> brb

[00:11] <Guest34131> ok

[00:11] <cspencer> guest34131: what kind of questions do you have? 

[00:11] <cspencer> i might be able to help, or point you in the right direction, at least :)

[00:12] <Guest34131> thanks, here it is..I've installed Perl 6 on ubuntu 8.10...

[00:12] <[particle]> which perl 6? rakudo?

[00:12] <Guest34131> .. and I got $home/rakudo/perl6 -e 'my Int $x; $x.say' to work

[00:12] <[particle]> type perl6 -v

[00:13] <[particle]> ok

[00:13] <Guest34131> ... and now I'm trying to install the package "Image::Magick" so I can make it work with perl6

[00:13] <moritz_> that's a Perl 5 module

[00:13] <Guest34131> but I don't know how to go about installing packages into perl6... 

[00:14] <moritz_> you can't with Perl 5 packages.

[00:14] <Guest34131> ahhhhh..........

[00:14] <Guest34131> I spent 2 days on it :)

[00:14] *** kulp joined
[00:14] <moritz_> it'll probably work some day, but we honestly have no idea when that could be

[00:14] *** kulp left
[00:14] <[particle]> ouch!

[00:14] <moritz_> (at least I don't)

[00:14] <[particle]> i wonder what kind of errors you got

[00:15] <[particle]> so, maybe, we could improve the messages

[00:15] <Guest34131> I had fun though, installing, and reinstalling perl 6 though...

[00:15] *** kate21de1 left
[00:16] <Guest34131> then if you don't mind me asking another question... this is the reason why I want to install perl 6 in the first place...

[00:16] <[particle]> please, not to run perl 4 code!

[00:16] <moritz_> ;-)

[00:17] <Guest34131> ... I'm trying to use Image::Magick to automatically draw a simple shape, using the Draw command...

[00:17] <cspencer> you should probably use perl5 then :)

[00:17] <Guest34131> ... then entering in numbers (200,100 50,50) as coordinates...

[00:18] <Guest34131> ... I got Image::Magick to accept coordinates when I use numbers (200,100 etc) but when I substitute $x after declaring $x = 200; then ($x,100) doesn't work as a coordinate

[00:19] <Guest34131> I tried "use Integer;" but it didn't work either...

[00:19] <[particle]> yeah, i'm sure that was a move of desperation

[00:20] <Guest34131> then I read about how in perl6 you can actually declare an Int as an Int, which is why I installed it... but now I can't import the Image::Magick package into Perl6...

[00:21] <[particle]> unfortunately, there's no module to use Image::Magick in perl 6 yet

[00:21] <[particle]> so, you'll have to use perl 5

[00:22] <Guest34131> is there any way to declare a real integer in Perl 5? I heard it was possible but very hard to do...

[00:22] <[particle]> you don't need to, to get that working

[00:22] <Guest34131> what do you sugges then?

[00:23] <cspencer> guest34131: what was your error message?

[00:23] <cspencer> if any?

[00:23] <[particle]> i suspect you're using single quotes instead of double quotes

[00:23] <[particle]> my $x = 3; print '$x'; print "$x";

[00:23] <[particle]> prints: $x3

[00:24] <Guest34131> the code was Draw... '200,100 50,50' but instead I put '$x,100 50,50'

[00:24] <[particle]> use double quotes instead

[00:24] <[particle]> then $x will be interpolated

[00:24] <Guest34131> ah...

[00:25] <Guest34131> I'll try that, thank you very much

[00:25] <[particle]> for more help, try #perl, since you'll be happily using perl 5 now :)

[00:25] <Guest34131> haha

[00:26] *** __felix__ left
[00:27] <Guest34131> btw, do you know when approximately Perl 6 will have the ability to import packages like Image::Magick? or do you think not until Perl 6 actually gets released in the mainstream...

[00:27] <[particle]> i'm surprised every day by the progress of our volunteers

[00:28] <[particle]> there is a module installer called 'proto'

[00:28] <Guest34131> oh?

[00:28] <[particle]> but there are very few modules, still.  that's changing, and i suspect this summer, after the us/european conferences, there will be more folks writing perl 6 modules

[00:29] <Guest34131> i c... btw, is "GD" in perl 6 yet? or is that a another module that has yet to be written?

[00:30] <cspencer> there's no GD yet :)

[00:31] <Guest34131> i c... well, I guess I'll wait to see what happens in the summer :-)

[00:32] <jnthn> Eventually we should be able to use and call functions from Perl 5 in Perl 6. But we're a bit off that yet.

[00:32] <Guest34131> ah...

[00:32] <jnthn> (It's non-trivial to do.)

[00:32] <[particle]> thanks for your patience. it will be rewarded :)

[00:33] <Guest34131> I appreciate the hard work, where are most of you located? North America or Europe?

[00:34] *** Alias left
[00:34] <[particle]> we're well spread out, actually

[00:35] *** |jedai| is now known as jedai

[00:35] <Guest34131> i c

[00:35] <[particle]> and jnthn alone covers half of europe and asia in his travels

[00:35] <jnthn> ;-)

[00:35] <jnthn> Hey, travel is *fun*. :-)

[00:35] <Guest34131> hey jnthn, sometimes Japan by any chance?

[00:36] <jnthn> Guest34131: Actually, I'd really like to make the next YAPC::Asia.

[00:36] <jnthn> I'm just waiting to hear dates, etc. :-)

[00:36] <Guest34131> next week in Tokyo?

[00:36] <Guest34131> or in May?

[00:36] <jnthn> Huh? Last I heard of it was in September.

[00:36] <jnthn> (Erm, that it'd be in September.)

[00:37] <Guest34131> I c, it hasn't been scheduled yet..

[00:37] <jnthn> Aye. Best info I've seen yet is http://use.perl.org/~lestrrat/journal/38354

[00:38] <jnthn> Anyway, I never did visit Japan yet, and I'd really love to, and combining travel and Perl events has worked out wonderfully in the past. :-)

[00:39] *** frioux is now known as frioux_away

[00:40] <Guest34131> jnthn, do you get paid for your efforts? or is 100% volunteer work..

[00:40] <Tene> jnthn: purl in #parrot has messages for you

[00:41] <Tene> jnthn: I implemented leave() with exceptions, but pmichaud thinks that maube exceptions are wrong there, and wants to discuss with you

[00:43] <jnthn> Guest34131: I am funded, but do some volunteer effort too.

[00:43] <Guest34131> i c...

[00:43] <jnthn> Guest34131: I couldn't give the time I give to Perl 6 without funding, so I've very grateful with it.

[00:43] <jnthn> *for it

[00:43] <jnthn> Tene: OK, let me look...

[00:44] <Tene> jnthn: leave_exceptions branch in rakudo

[00:44] <Tene> leave.t fails because of &?BLOCK and &?ROUTINE as well as indirect method call syntax

[00:44] <jnthn> Tene: Yeah, pmichaud and I originally discussed it in terms of invoking a continuation, but the discussion with you/me/TimToady IIRC in it I think convinced me that exception-based approach maybe was the way...

[00:44] <jnthn> indirect method call syntax?

[00:44] <jnthn> Such as? I think we have passing tests on that :-|

[00:45] <Tene> oh, maybe I was wrong

[00:45] <jnthn> Tene: Nah, you could easily have found a bug too

[00:48] *** kst left
[00:48] *** kst joined
[00:50] <jnthn> Tene: Need sleep now; will try and look more tomorrow. Thanks for working on it.

[00:50] <Tene> jnthn: np

[00:51] *** nihiliad joined
[00:52] *** Guest34131 left
[00:56] *** Kisu left
[00:57] *** Kisu joined
[01:09] *** NordQ left
[01:11] *** frooh_away is now known as frooh

[01:13] *** msmatsko joined
[01:18] *** alc joined
[01:21] *** Diederich left
[01:24] *** Diederich joined
[01:26] <cspencer> i take it it's not possible to use a "return" in try's CATCH { ... } block?

[01:27] <pmichaud> not yet.

[01:27] <pmichaud> actually, that should work, though.

[01:27] <pmichaud> std:  q :hello:

[01:27] <cspencer> rakudo: try { die "exeption"; CATCH { say "Caught: $!"; return fail("Failed") } }

[01:27] <pmichaud> one doesn't "return fail"

[01:27] <cspencer> oh :)

[01:27] <pmichaud> fail() already does a return.

[01:27] <cspencer> you just...fail? :)

[01:27] <cspencer> ah ok

[01:28] <pmichaud> but I suspect that CATCH might catch the fail in this case.

[01:28] <pmichaud> (it probably shouldn't -- but we have to get lexical returns working for that first.)

[01:28] <cspencer> alright, i'll work around that for the time being :)

[01:28] <pmichaud> std:  say q :  hello world :

[01:29] <pmichaud> std:  say q 'hello'

[01:29] <pmichaud> std seems lost.

[01:30] <cspencer> rakudo: say "foo"

[01:30] <cspencer> rakudo seems lost too

[01:30] <pmichaud> perl6: die?

[01:31] <pmichaud> p6eval: hello?

[01:35] *** kulp joined
[01:36] *** kulp left
[01:37] *** FurnaceBoy left
[01:46] <s1n> frooh: ping

[01:46] <frooh> s1n: pong

[01:53] *** Diederich left
[01:54] *** Diederich joined
[01:54] <pugs_svn> r26003 | pmichaud++ | [t/spec]:  Fudge some rx:P5 tests for rakudo.

[01:59] <pugs_svn> r26004 | pmichaud++ | [t/spec] more rakudo fudging for rx:P5.

[02:04] *** Caelum left
[02:05] *** bacek left
[02:06] *** cotto joined
[02:09] *** Caelum joined
[02:09] *** justatheory joined
[02:09] <pugs_svn> r26005 | pmichaud++ | [t/spec]:  more rakudo :P5 fudging

[02:10] <dalek> rakudo: 353aca7 | pmichaud++ | src/parser/ (3 files):

[02:10] <dalek> rakudo: Enable :P5 on m/.../ and rx/.../ patterns.

[02:10] <dalek> rakudo: Throw exception if attempting to use colon as quoting delimiter.

[02:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/353aca7867b2f4c3e1ecb415f88a84bf727a1604

[02:14] *** dKingston left
[02:17] *** wknight8111 left
[02:17] *** justatheory left
[02:32] <p6eval> std 26002: OUTPUT«##### PARSE FAILED #####␤Unrecognized quote modifier: 1 at /tmp/S4TctYMh3N line 1:␤------> [32mq :hello[31m:[0m␤FAILED 00:02 34m␤»

[02:32] *** p6eval left
[02:32] *** p6eval joined
[02:32] <p6eval> .....

[02:32] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected end of input␤    at /tmp/xLaLWXX0qr line 2, column 1␤»

[02:42] <diakopter> std: say q :  hello world :

[02:42] <p6eval> std 26005: OUTPUT«ok 00:03 35m␤»

[02:42] *** rachelBROWN left
[02:43] <diakopter> std:  q :hello:

[02:43] <p6eval> std 26005: OUTPUT«##### PARSE FAILED #####␤Unrecognized quote modifier: 1 at /tmp/t1i1e1d0fu line 1:␤------> [32mq :hello[31m:[0m␤FAILED 00:02 34m␤»

[03:01] *** justatheory joined
[03:11] <pugs_svn> r26006 | pmichaud++ | [t/spec]:  Some updates to rakudo skips for rx syntax.

[03:11] <pugs_svn> r26007 | pmichaud++ | [t/spec] Some #?rakudo fudging for unspace.t .

[03:12] <pugs_svn> r26008 | pmichaud++ | [t/spec]:  More fudging for unspace.t .

[03:12] *** Alias joined
[03:13] *** Alias_ joined
[03:13] <dalek> rakudo: 7c69c7b | pmichaud++ |  (2 files):

[03:13] <dalek> rakudo: Add some more t/spec/S05-modifier files to spectest.data .

[03:13] <dalek> rakudo: Bump PARROT_REVISION to enable :P5 regexes.

[03:13] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7c69c7ba68cb9781ea05854d533216b5b41980eb

[03:24] *** grwi joined
[03:29] <pugs_svn> r26009 | putter++ | [elf] elfish/on_sbcl renamed on_lisp to reflect added ccl support.  Also renamed the old elfish/elfX to elfX_smop for greater clarity.

[03:30] *** Alias left
[03:31] *** grwi left
[03:46] <pugs_svn> r26010 | pmichaud++ | [t/spec]:  Final bit of rakudo fudging in unspace.t

[03:48] <dalek> rakudo: 4929856 | pmichaud++ | t/spectest.data:

[03:48] <dalek> rakudo: Add unspace.t to spectest.data .

[03:48] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/49298567bdcf0f68b4c90971316fb094250421fc

[04:03] *** cspencer left
[04:19] <pmichaud> rakudo:  say ('a', 1, 'b', 2, 'c', 3, 'd', 4).sort.perl;

[04:19] <p6eval> rakudo 492985: OUTPUT«["a", "b", "c", 1, 2, 3, 4, "d"]␤»

[04:19] <pmichaud> say 'a' cmp 1;

[04:19] <pmichaud> rakudo: say 'a' cmp 1;

[04:19] <p6eval> rakudo 492985: OUTPUT«1␤»

[04:20] <pmichaud> rakudo: say 'd' cmp 4;

[04:20] <p6eval> rakudo 492985: OUTPUT«1␤»

[04:20] <pmichaud> rakudo: say 1 cmp 2;

[04:20] <p6eval> rakudo 492985: OUTPUT«-1␤»

[04:20] <pmichaud> rakudo:  say <a 1 b 2 c 3 d 4>.sort.perl;

[04:20] <p6eval> rakudo 492985: OUTPUT«["1", "2", "3", "4", "a", "b", "c", "d"]␤»

[04:22] <frooh> rakudo: <a 1 b 3 c 3 d 4>.sort

[04:22] <p6eval> rakudo 492985: RESULT«["1", "3", "3", "4", "a", "b", "c", "d"]»

[04:22] <frooh> rakudo: <a 1 b 3 c 4 d 5>.sort

[04:22] <p6eval> rakudo 492985: RESULT«["1", "3", "4", "5", "a", "b", "c", "d"]»

[04:23] <pmichaud> rakudo:  say 4 cmp 'c';

[04:23] <p6eval> rakudo 492985: OUTPUT«1␤»

[04:24] <pmichaud> rakudo:  say 'c' cmp 4;

[04:24] <p6eval> rakudo 492985: OUTPUT«1␤»

[04:31] *** Util joined
[04:35] *** Util left
[04:38] *** alc left
[04:43] *** kimtaro left
[04:47] *** Util joined
[04:47] <Util> rakudo:     my %h = ( foo => "bar" ); for %h.pairs -> $one { say $one.perl }

[04:47] <p6eval> rakudo 492985: OUTPUT«"foo" => "bar"␤»

[04:48] <Util> rakudo:     my %h = ( foo => "bar" ); for %h.pairs -> $one { print $one.perl }

[04:49] <p6eval> rakudo 492985: OUTPUT«"foo" => "bar"»

[05:00] *** kst left
[05:00] *** Util left
[05:00] *** kst joined
[05:05] *** estrabd_ joined
[05:06] *** estrabd left
[05:06] *** Khisanth left
[05:07] *** Khisanth joined
[05:14] *** Woody4286 left
[05:14] *** kimtaro joined
[05:15] *** Woody4286 joined
[05:16] *** nihiliad left
[05:37] *** nww joined
[05:39] *** nww left
[05:46] *** Kisu left
[05:49] *** Kisu joined
[05:59] *** masak joined
[05:59] <masak> good morning, fellow butterflies.

[06:00] <Tene> goot morning

[06:02] <Tene> good

[06:03] *** mberends joined
[06:03] <mberends> good morning, happy hackers

[06:05] *** alc joined
[06:06] <mberends> masak: top o' the mornin' to you, sir!

[06:06] <masak> mberends: and a very fine morning to you, fellow citizen!

[06:07] * masak tips hat

[06:07] * mberends bows

[06:09] <mberends> masak: may I insert copies of Configure.p6 and Configure.pm into proto?

[06:10] <masak> mberends: for proto itself, or for budding project creators?

[06:10] <mberends> initially for the latter

[06:11] <masak> yes. you may. :)

[06:11] *** DemoFreak joined
[06:12] <mberends> will do in next few hours. currently planning a tree-based Pod parser as alternative to current stream-based.

[06:14] <masak> nice.

[06:16] <mberends> it may be nice to apply your SVG class to the task of XHTML emitter :)

[06:19] <masak> aye, been thinking the same.

[06:19] <masak> both the SVG class and an XHTML emitter would be greatly benefitted by some kind of real-time validation by DTD.

[06:19] *** finanalyst joined
[06:20] <masak> but my DTD-fu is still lacking. I'm looking at the stuff, and only almost seeing what it means.

[06:21] *** charsbar_ left
[06:23] <mberends> validation separate from generation is very expensive, so better to it by means of constraints at generate time. DTD is cumbersome, XML Schema is friendlier. I use them in .NET work. But performance is usually a problem when parsing (and also validating) XML.

[06:24] <masak> I'm not saying we necessarily use the DTD qua DTD.

[06:24] <masak> just that it contains the information I'm interested in validating against. :)

[06:25] <masak> oh, and there should probably be a way to turn validation off in production environments, yes.

[06:25] <mberends> perhaps validate mainly in the test suite

[06:26] <masak> hm.

[06:26] *** parduncia_ joined
[06:26] <masak> the group I hope to reach is the one writing one-off scripts of the CGI kind.

[06:26] <mberends> generally systems validate what arrives from the outside, not what is made inside.

[06:27] <masak> indeed.

[06:27] <mberends> design your generator classes to make only valid productions

[06:27] <masak> that would be ideal, yes.

[06:28] <masak> but... let's take an example to make it concrete.

[06:28] <masak> a <li> element in HTML can only occur in some other elements.

[06:29] <masak> I'm not sure if it's invalid XHTML 1.0 Strict if it occurs outside, but it's at least doubtful use.

[06:29] <masak> a warning from the XHTML generator would seem appropriate.

[06:30] *** Alias joined
[06:30] *** Alias_ left
[06:30] <mberends> a hierarchy of classes would prevent you from creating <li> except where it is valid

[06:32] <masak> mberends: sir, you just set warning bells off in my head with the phrase "a hierarchy of classes" :)

[06:32] <masak> but that's all right.

[06:32] <masak> I'm just a little allergic to excessive OO.

[06:32] <mberends> too Java-ish?

[06:32] <masak> might be.

[06:33] <masak> mind you, I've seen wonderful class hierarchies in my day, but they're few and far between.

[06:33] <masak> most often they're just a waste of ink, or bytes as it were.

[06:34] <masak> my ears perk up when it turns out that the classes use polymorphism in some constructuve way.

[06:34] <masak> s/uve/ive/

[06:35] <mberends> agreed. that reinforces my dislike of frameworks that bloat that way

[06:35] *** miloux left
[06:35] <mberends> Java causes some of that by being too formally strict and correct

[06:35] <masak> Java enforces bloat.

[06:36] * mberends laughs

[06:37] <mberends> the potential number of classes for XHTML is not so bad

[06:38] <masak> I'm just not convinced yet that element types should map to classes.

[06:38] <mberends> SVG is worse, which is probably why your code was so generic. too generic, methinks.

[06:38] <masak> maybe they should, if MMD is used in some clever way for each type of valid containment relation.

[06:39] <masak> mberends: aye, too generic.

[06:39] <mberends> you were starting top-down and SVG::Tiny was going bottom-up.

[06:40] <masak> mberends: I wish to introduce a convenience into SVG: for some attributes, like style, an array of pairs should be flattened and formatted into a string of semicolon-separated key/value pairs.

[06:40] <masak> after that, I'll be happy with the syntax. but I'll still want validation.

[06:42] <mberends> actually, that's very nice. just make the validation fast, per-item.

[06:43] <mberends> per-item is probably the trick, avoid unwieldy trees

[06:43] <masak> aye.

[06:44] <masak> I just wish that someone gave me the magical ability to understand what the DTD document means.

[06:44] <masak> http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-flat-20030114.dtd

[06:46] *** charsbar joined
[06:46] <mberends> what a format. it's a wonder Tim Berners-Lee got something friendly out of it.

[06:46] <masak> I hereby publicly advertise for a person who can speak DTD.

[06:47] <masak> I'm sure I can manage if I get the first three or four WTFs explained to me.

[06:47] *** bacek_ left
[06:48] <mberends> the Microsoft toolchain replaced all DTDs with XML Schemata.

[06:49] <mberends> http://www.w3.org/XML/Schema

[06:49] <masak> that was probably for the better.

[06:49] <mberends> a very good move, indeed.

[06:49] *** kate21de joined
[06:50] <lucs> masak: This looks like a decent tutorial: http://library.stanford.edu/tools/tutorials/html2.0/gentle.html

[06:50] <masak> lucs: thank you.

[06:50] <lucs> np

[06:53] <mberends> lucs: were you replying to masak's advert?

[06:53] <masak> seems so.

[06:53] <lucs> I was kinda following along, yeah.

[06:53] <masak> 2.4 is actually not the bad, thus far.

[06:55] <lucs> The example in 2.4.1 is badly formatted as far as I can see in my browser, but the rest looks ok.

[06:55] <masak> aye.

[06:56] <masak> I'm hallucinating line breaks; after that, it looks fine.

[06:56] <lucs> Right :)

[06:58] <mberends> view source does not correct the line breaks - a missed opportunity :(

[06:58] *** meppl joined
[07:00] *** justatheory left
[07:00] *** mtve joined
[07:01] <masak> oh, the content model has similarities with a regular expression, in fact.

[07:01] <lucs> Maybe more like shell globs, but yeah.

[07:01] <masak> and the <ENTITY % foo ... > declarations look a bit like macros to me.

[07:01] <lucs> Right.

[07:02] <masak> ah, the rush of revelation!

[07:02] <masak> lucs++

[07:02] * mberends leaves DTD to lucs and masak, shaking his head

[07:03] <masak> mberends: I'll get back to you when I've written a Perl 6 grammar that takes the SVG DTD and emits an understandable Perl 6 data structure :)

[07:03] <lucs> I hadn't thought about DTDs for many years (used to work with them before XML became popular), but that intro is quite decent.

[07:05] <mberends> yes, the explanation is good. but DTD is obsolete now, superseded.

[07:05] <lucs> Exactly.

[07:06] <masak> it seems to me I'm most interested in the ENTITY declarations declaring things ending with '.content'. they contain all the meaty stuff about hierarchy.

[07:06] <masak> also, I get the feeling that this DTD was written with extensibility in mind.

[07:06] <masak> there's a lot of '.extra.content' defined, but they're all empty.

[07:08] <lucs> Good luck with it.

[07:08] * lucs & # ZZ

[07:08] <mberends> masak: the content you will generate is finite in structure, so the entity restrictions can be hard coded. avoid interpreting them from any schema file format at all.

[07:09] <masak> of course. :)

[07:09] <masak> that's why I want to pre-parse it and turn it into a Perl 6 structure.

[07:09] <mberends> ah, so you were not joking...

[07:10] <masak> :)

[07:10] <masak> meeting &

[07:10] *** masak left
[07:14] <mberends> shower &

[07:14] *** mberends left
[07:15] *** kimtaro_ joined
[07:17] *** eternaleye left
[07:32] *** kimtaro left
[07:35] *** eternaleye joined
[07:46] *** riffraff joined
[07:53] *** eternaleye left
[08:03] *** bacek joined
[08:06] <pugs_svn> r26011 | moritz++ | [t/spec] unfudge unspace.t a bit

[08:06] <bacek> good evening

[08:07] <moritz_> good localtime() ;;-)

[08:08] <pugs_svn> r26012 | moritz++ | [t/spec] unfudge while.t for rakudo

[08:08] *** mberends joined
[08:08] <bacek> moritz_: :)

[08:09] <bacek> rakudo: sub localtime {...}; sub good { say "O RLY?" }; good localtime

[08:09] <p6eval> rakudo 492985: OUTPUT«O RLY?␤»

[08:09] <bacek> it works :)

[08:10] *** Woody4286 left
[08:10] *** Woody4286 joined
[08:10] <moritz_> why doesn't it throw an exception when calliing localtime()?

[08:11] <mberends> only time() is currently implemented.

[08:12] <bacek> moritz_: it's warning, not exception.

[08:12] <bacek> rakudo: sub foo { ... }; foo

[08:12] <p6eval> rakudo 492985: RESULT«undef»

[08:12] <bacek> hmmm...

[08:12] <moritz_> uhm.

[08:12] <bacek> masak's time?

[08:13] <mberends> masak went to a meeting about an hour ago

[08:15] <mberends> yesterday masak++ ran a pattern match on a million character document, and Rakudo outperformed Perl 5 in some sense :)

[08:15] <bacek> rakudo: sub foo { ... }; foo; say $!

[08:15] <p6eval> rakudo 492985: OUTPUT«Use of uninitialized value␤␤»

[08:16] <pugs_svn> r26013 | moritz++ | [t/spec] unfudge match.t for rakudo

[08:16] <pugs_svn> r26013 | moritz++ | 

[08:16] <pugs_svn> r26013 | moritz++ | we now support both rx/.../ and lexicals in eval(). YaY!

[08:17] *** amoc joined
[08:17] <bacek> moritz_: rakudo crashed later than perl5? :)

[08:18] <moritz_> bacek: that was masak, not me :-)

[08:19] <bacek> I'm expected it. masak is pretty good in breaking things :

[08:19] <bacek> :)

[08:20] <mberends> bacek: http://irclog.perlgeek.de/perl6/2009-03-26#i_1018129

[08:20] <moritz_> I usually break things when I want to write articles about them ;-)

[08:21] <bacek> mberends: heh :)))

[08:23] <mberends> perl5 segfaulted, but Rakudo++ survived

[08:25] <pugs_svn> r26014 | moritz++ | [t/spec] unfudge comb.t for rakudo

[08:33] *** Helios left
[08:34] *** Helios joined
[08:43] *** sunnavy left
[08:45] *** sunnavy joined
[08:51] *** pmurias joined
[08:54] *** bacek left
[08:58] *** jedai left
[08:59] *** |jedai| joined
[09:01] *** alc left
[09:05] *** kate21de left
[09:09] *** kimtaro joined
[09:11] *** rblasch joined
[09:18] *** kimtaro_ left
[09:33] *** dduncan joined
[09:38] *** literal left
[09:48] *** jrockway left
[09:52] *** bacek joined
[09:54] *** rblasch left
[09:55] *** Alias left
[09:56] *** Alias joined
[10:12] *** mikehh joined
[10:18] *** dduncan left
[10:20] <jnthn> hi all

[10:20] <moritz_> hi jnthn 

[10:24] <jnthn> I see pmichaud++ has got us passing more tests! :-)

[10:25] *** bacek left
[10:25] <moritz_> indeed

[10:25] <jnthn> And moritz++ has been unfudging some too :-)

[10:26] <moritz_> mostly just those found by autounfudge

[10:39] *** pmurias left
[10:39] *** pmurias joined
[10:46] *** zamolxes joined
[10:46] *** kst left
[10:47] *** kst joined
[11:04] *** Tene left
[11:04] *** diakopter left
[11:04] *** buubot left
[11:05] *** Tene joined
[11:05] *** diakopter joined
[11:05] *** buubot joined
[11:15] *** kimtaro_ joined
[11:16] *** kimtaro_ left
[11:17] *** jrockway joined
[11:19] *** literal_ joined
[11:24] *** kimtaro_ joined
[11:25] *** kimtaro left
[11:42] *** rob___ joined
[11:57] *** ruoso joined
[11:57] *** mikehh left
[12:00] <ruoso> finanalyst, I've just replied to your mail about junctions

[12:11] *** kst left
[12:11] *** kst joined
[12:11] *** pmurias left
[12:12] *** orafu joined
[12:15] *** Trey joined
[12:17] *** ejs joined
[12:25] *** mikehh joined
[12:27] *** bsb left
[12:31] *** dKingston joined
[12:32] *** dKingston left
[12:33] *** dKingston joined
[12:33] <Matt-W> mberends: ping

[12:33] *** dKingston left
[12:33] *** dKingston joined
[12:33] <mberends> Matt-W: pong

[12:34] <Matt-W> mberends: what did you want last night?

[12:34] <mberends> I was curious if you were working on Form. I'm studying it closely.

[12:35] <Matt-W> I was, yes

[12:35] <Matt-W> and suffering some frustration

[12:35] <mberends> sorry to hear that

[12:36] <Matt-W> it *looks* like something's trying to call an action method with an insufficient number of parameters

[12:36] <Matt-W> but since Parrot won't tell me which routine it is that's got the parameter count mismatch, I'm not entirely sure

[12:38] <mberends> Matt-W: for diagnostics, replace your 'say' trace statements with 'warn', then they still appear during 'make test'

[12:38] <mberends> in Actions.pm

[12:39] <Matt-W> ah

[12:39] <Matt-W> hadn't thought of that

[12:39] *** skids left
[12:40] <Matt-W> they work nicely when I run the test file directly though :)

[12:40] <jnthn> Matt-W: Akshually the routine that is normally at the top of the backtrace is the one that didn't get enough parameters passed.

[12:40] *** rodi joined
[12:40] <Matt-W> jnthn: it's still an action method then, it's just a different one

[12:40] <Matt-W> hmm

[12:40] <Matt-W> except it manages to run say statements from within that on

[12:40] <jnthn> Matt-W: The way you normally get these, is having an "#= foo"

[12:40] <jnthn> But not $key parameter to receive it.

[12:41] <Matt-W> that would be the other way round wouldn't it? too many parameters

[12:41] <jnthn> Though maybe not in this case. But it's the first thing I check when i'm dealing with actions/grammars.

[12:41] <jnthn> Ah, yes, so you try to take a $key when none is passed.

[12:42] <mberends> therefore "#= foo" missing in Grammar.pm

[12:43] <Matt-W> It really looks a lot like that

[12:43] <Matt-W> but I can't see that there is any way they could be missing

[12:43] <mberends> Matt-W: the version last pushed passes all tests, care to push the current files?

[12:43] <Matt-W> sure

[12:44] <Matt-W> done

[12:44] <mberends> pulled. making test...

[12:45] <Matt-W> it *looks* like it's the action method for aligned_field, but it's got all the #= it could possibly want...

[12:45] <jnthn> URL?

[12:45] <Matt-W> maybe I just need somebody else's eyes to look at it without expecting to know what's there

[12:46] <Matt-W> github.com/mattw/form

[12:46] <Matt-W> lib/Form/Actions.pm and lib/Form/Grammar.pm being of particular interest

[12:46] <Matt-W> no doubt it will be something simple and embarrassing

[12:47] <mberends> yep, left_justified_field

[12:48] <Matt-W> oooh

[12:48] <Matt-W> I've seen it

[12:48] <Matt-W> I was right wasn't I

[12:49] <Matt-W> very simple and embarrassing

[12:49] <Matt-W> mberends++

[12:49] <Matt-W> now I just need to make the grammar work

[12:49] <Matt-W> but that's a different problem

[12:50] <mberends> me doesn't see it yet

[12:50] <Matt-W> extra {*} in the grammar

[12:50] <Matt-W> with no #=

[12:50] <mberends> Grammar.pm:54

[12:51] <Matt-W> yup

[12:51] <Matt-W> pushed the fix

[12:51] <Matt-W> now back to making the new bits of grammar work

[12:52] <mberends> pulled, now fails test 11

[12:52] <Matt-W> yes I know about that

[12:52] <Matt-W> that's th ehalf-finished work that got derailed by finding the other bug

[12:53] <Matt-W> I just fixed that, actually, and am proceeding to the next five

[12:53] *** gfldex left
[12:54] *** bacek joined
[12:54] <Matt-W> and that's done too

[12:54] <Matt-W> I was closer than I thought

[12:54] *** finanalyst left
[12:55] <Matt-W> it can now handle a string like "{[[[} some text {>>>>} some other text"

[12:56] <mberends> jnthn, is the "#= foo" a short term kludge or a permanent language feature?

[12:57] <jnthn> mberends: Better to ask pmichaud, but I'm not aware of it being endangered.

[12:58] * mberends has little faith in comments-as-syntax

[12:58] <jnthn> mberends: In general, the need for it in Rakudo's grammar will mostly disappear as we get proto-regexen.

[12:58] <mberends> good. riddance.

[12:58] <jnthn> Though whether that's mostly disappear or completely go away, I'm less sure.

[12:59] <Matt-W> proto-regexen?

[12:59] <Matt-W> because I'm really relying on its functionality in Form right now

[12:59] <Matt-W> and while proper embedded closures would fix it, it wouldn't for the case of having multiple sets of actions for the same grammar

[13:00] <jnthn> *nod*

[13:00] <jnthn> I think best is to ask pmichaud 

[13:00] <Matt-W> I think we can manage that

[13:01] <mberends> Matt-W: while I like your structure, obviously I'll make a big effort to use alternatives to "#= foo".

[13:02] <Matt-W> I was wanting to just use { make whatever } but that doesn't work yet

[13:02] <Matt-W> since I don't need multiple sets of actions

[13:03] <Matt-W> I just want to build a nice pile of meaningful objects

[13:03] <Matt-W> but I agree with you on the syntactically meaningful comments thing

[13:03] <Matt-W> I know regex is a different language, but still...

[13:04] *** Alias left
[13:05] <mikehh> rakudo (4929856) builds on parrot r37753 - make test/make spectest PASS - Ubuntu Intrepid Amd64

[13:08] *** kimtaro joined
[13:08] *** kimtaro left
[13:09] *** szabgab left
[13:21] *** mj41 left
[13:22] *** Alias_ joined
[13:22] *** donaldh joined
[13:24] *** mj41 joined
[13:24] *** kimtaro_ left
[13:32] <PerlJam> greetings 

[13:35] *** skids joined
[13:36] <diakopter> hi

[13:37] <moritz_> hi

[13:37] <PerlJam> anything interesting happen in the last 20 hours ?  :)

[13:38] <moritz_> yes

[13:38] <Alias_> Although the next 20 hours should be more interesting

[13:38] <Alias_> Since they're going to be completed in only 19 hours

[13:38] <moritz_> rakudo: "abc" ~~ m:Perl5/(?:..)/ && say 'alive'

[13:38] <p6eval> rakudo 492985: OUTPUT«alive␤»

[13:39] <moritz_> rakudo: "abc" ~~ m:Perl5/(?:..)/ && say $1

[13:39] <p6eval> rakudo 492985: OUTPUT«Use of uninitialized value␤␤»

[13:39] <moritz_> rakudo: "abc" ~~ m:Perl5/(..)/ && say $0

[13:39] <p6eval> rakudo 492985: OUTPUT«ab␤»

[13:39] <moritz_> perl 5 regexes are new in rakudo :-)

[13:39] <diakopter> Alias_: how's that

[13:39] <PerlJam> cool

[13:39] <Alias_> diakopter: Daylight savings switchover

[13:39] <PerlJam> I suppose they don't support  \1, \2, etc.  though  :)

[13:39] <diakopter> Alias_: oh; not in usa; that happened a couple of weeks ago

[13:39] <PerlJam> Alias_: maybe for you, but we already did that

[13:40] <Alias_> uk

[13:40] <moritz_> doesn't it happen on sunday morning?

[13:40] <Alias_> Not according to the news...

[13:40] <Alias_> Saturday morning, early

[13:40] <Alias_> Maybe I wasn't listening well enough

[13:41] <PerlJam> moritz_: given that DST is of political determination, there's no telling when it could happen  ;)

[13:41] <moritz_> :-)

[13:41] <moritz_> here (Germany) it's Sunday 2am

[13:41] <PerlJam> same in the USA

[13:42] <Alias_> Not a bad last 20 hours for releases though

[13:42] <Alias_> New Module::Install, new Padre, new Catalyst, and new DBD::SQLite

[13:42] <PerlJam> There is a female cardinal determined to peck a hole through my window.  Every day for the last week she comes at random times during the day and pecks at my window for a few minutes.

[13:42] <moritz_> .oO( new TAP::Parser? )

[13:43] <PerlJam> meanwhile, her mate just hangs out and eats the birdseed that I put out and drinks from the water in the bird bath that I set up.

[13:43] <PerlJam> new Catalyst?

[13:44] *** bsb joined
[13:44] * PerlJam needs to pay more attention perhaps

[13:44] <Alias_> http://search.cpan.org/~mramberg/Catalyst-Runtime-5.71001/

[13:44] <Alias_> only minor release though :/

[13:45] <PerlJam> 5.8 will get here eventually :)

[13:50] *** kimtaro joined
[13:51] <dalek> rakudo: 9fa0fca | pmichaud++ | docs/spectest-progress.csv:

[13:51] <dalek> rakudo: spectest-progress.csv update: 339 files, 7795 passing, 0 failing

[13:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9fa0fca79315160469202c495d78ff970c77c4bc

[13:51] * moritz_ updates the chart

[13:52] <jnthn> wow, that chart has a nice ending

[13:53] <moritz_> that's the p5 regex spike ;-)

[13:54] *** exodist joined
[13:55] <pmichaud> if I can get (?m) and (?i) working in p5 regexes we might get another spike.

[13:58] *** [particle] left
[13:58] <pmichaud> http://svn.pugscode.org/pugs/t/spec/S05-mass/properties.t  # test file that would get us a huge spike in passing tests

[14:03] *** kanru joined
[14:06] <moritz_> pmichaud: what's so hard about (?i) and (?m)? weird scoping?

[14:09] <pmichaud> moritz_: weird scoping is part of it -- mostly it's just tuits to implement it

[14:09] <pmichaud> I'm a little surprised that PGE::P5Regex handled as many as it did :-)

[14:14] *** ejs left
[14:19] *** justatheory joined
[14:21] *** alester joined
[14:26] *** Alias_ left
[14:34] *** justatheory left
[14:34] *** kst left
[14:35] *** kst joined
[14:35] <pmichaud> std:  sub infxi:<abc>($x, $y) { ... }

[14:35] <p6eval> std 26014: OUTPUT«ok 00:02 36m␤»

[14:36] <PerlJam> "infxi:"?

[14:36] <pmichaud> that's what I was checking.

[14:37] <PerlJam> I figured, but why?  Was there a typo that continued to work surprisingly? :)

[14:37] <amoc> std:  sub anyany:<abc>($x, $y) { ... }

[14:37] <p6eval> std 26014: OUTPUT«ok 00:02 36m␤»

[14:37] <pmichaud> I'm curious how STD parses names of the form category:<...>   so I can see about doing the same in rakudo.

[14:37] <Matt-W> pmichaud: A question was raised earlier about whether the {*} #= stuff in rules is permanent

[14:37] <pmichaud> Matt-W: it's permanent for at least as long as STD.pm has them.

[14:38] *** orafu left
[14:38] <PerlJam> I think it would be crazy for them to NOT be permanent (at least as an option)

[14:38] *** OuLouFu joined
[14:38] <diakopter> (I thought I read in STD.pm they were deprecated, eventually)

[14:38] *** OuLouFu is now known as orafu

[14:38] <Matt-W> PerlJam: we were wondering if there was something coming along that didn't use comments as meaningful syntax

[14:39] <pmichaud> Matt-W: that's only because you insist on thinking of #= as being a comment :-)

[14:39] <PerlJam> That they're comments is a feature!

[14:39] *** [particle] joined
[14:39] <pmichaud> I haven't seen or heard anything to suggest that #= is going away.

[14:39] <Matt-W> Well it does start with a #

[14:40] <PerlJam> you could write your parser in perl 6 and your "actions" in some other language if that were desirable.

[14:40] <Matt-W> just feels icky to me

[14:40] <Matt-W> but

[14:40] <Matt-W> the functionality is definitely needed

[14:40] <Matt-W> so I'm going to not complain too much, especially as I don't have a better option at the moment :)

[14:41] *** rob___ left
[14:41] <PerlJam> Matt-W: just keep using it until it doesn't feel icky any more  :)

[14:42] <Matt-W> Or alternatively I could grow a couple of extra brains and use them to implement embedded closures

[14:42] <mberends> so, is S02:128 wrong about comment, because the {*} exception is not specified?

[14:44] <pmichaud> that's a slightly different question :-)

[14:44] <pmichaud> if you're asking    "is #= part of the spec", the answer is "no", or at least "not yet".

[14:44] <diakopter> jnthn: ping

[14:44] <diakopter> (sigh)

[14:44] <jnthn> diakopter: pong

[14:44] <[particle]> #? isn't part of the spec yet, either

[14:44] <mberends> relatedly, where is the action form of 'make' specified?

[14:44] <pmichaud> if you're asking  "is #= going away anytime soon", the answer thus far is "not likely" or "not until TimToady comes up with an alternative"

[14:45] <pmichaud> 'make' is specified in S05

[14:45] <mberends> ok, thanks

[14:45] <pmichaud> even {*} isn't specified in the synopses yet.

[14:45] <pmichaud> (where "yet" includes "possibly never will be")

[14:45] <[particle]> sure, but it's valid perl 6 anyway

[14:46] <pmichaud> well, #= is valid perl6 also :-)

[14:46] <[particle]> it's semantics aren't specced

[14:46] <pmichaud> actually, it semantics would currently be the same as   { * }

[14:46] <[particle]> i can imagine #= and even #? becoming some single-line pod directive

[14:47] <pmichaud> the "special" semantics that PGE currently gives to {*} in regexes isn't specced.

[14:47] <[particle]> right

[14:47] <[particle]> and it's not only pge, larry is using that for viv

[14:48] <moritz_> maybe we should just spec it :-)

[14:48] * ruoso wonders if ⎨1,2,3⎬ could be used as a synonim for set(1,2,3)

[14:48] * [particle] wonders what those utf8 chars were, and why they didn't display here

[14:48] <pmichaud> or maybe  «{ 1, 2, 3 }»

[14:48] <ruoso> U+23AC RIGHT CURLY BRACKET MIDDLE PIECE

[14:48] <ruoso> U+23A8 LEFT CURLY BRACKET MIDDLE PIECE

[14:49] <pmichaud> with <<{ 1, 2, 3 }>>  as the Texas set :-)

[14:49] <Matt-W> well, if you implement custom operators... why not?

[14:49] <Matt-W> or maybe a macro is more suitable

[14:49] <Matt-W> hurrah for playing with the grammar

[14:49] * ruoso considering sets will end up in core

[14:50] * ruoso points at a very recent thread on p6-l about this issue

[14:50] <mberends> Matt-W: see what trouble you've got us into!

[14:50] <moritz_> :-)

[14:51] <pmichaud> as I see it, the problem most people have with junctions isn't their collapsing behavior, but that they then want to know "what particular set of collapsing behavior led to this outcome"?

[14:51] <ruoso> pmichaud, that's the easy problem... 

[14:51] <pmichaud> i.e., they want to look inside the collapsing wave function to figure out how we arrived in the universe we're in.

[14:51] <ruoso> the harder problem is "how do I get a subset of a junction?"

[14:51] *** frooh left
[14:52] <pmichaud> iiuc, junctions aren't sets any longer in Perl 6.

[14:52] <Matt-W> pmichaud: as long as they don't want a career programming quantum computers...

[14:52] <ruoso> it actually never was

[14:52] <ruoso> but people kept using it as if it were

[14:52] <ruoso> so TimToady removed the hability for it to work as a set

[14:52] <pmichaud> Synopsis 2 once indicated that Junctions were sets

[14:53] <ruoso> ah... 

[14:53] <ruoso> I should have missed that

[14:53] <[particle]> my Set|Junction $x;

[14:54] <pmichaud> S02 used to give the following for Junction:

[14:54] <pmichaud>     Junction    Set with additional behaviors

[14:55] <ruoso> right... but it's a wrong definition even then...

[14:55] <pmichaud> agreed, which is why it was changed :-)

[14:55] <ruoso> unless you believe in anti-sets

[14:55] <ruoso> i.e. none(1,2,3)

[14:56] <ruoso> what I was really wondering... is at which point Sets can DWIM

[14:56] <ruoso> I mean... I think "set(1,2,3) + 3 eqv set(4,5,6)"

[14:57] <ruoso> but to which extent that can be applied to other operators/

[14:57] <ruoso> ?

[14:57] <ruoso> specially... "set(1,2,3) > 3"

[14:58] <ruoso> probably it should be used in conjunction with junctions at that case...

[14:58] <ruoso> "any(set(1,2,3)) >= 3"

[14:58] <pmichaud> aren't these just lists, though?

[14:58] <ruoso> pmichaud, not really

[14:58] <moritz_> autothreading lists?

[14:58] <ruoso> if we want to DWIM, we need an actual type

[14:58] <pmichaud> (with the exception of the uniqueness)

[14:59] <ruoso> moritz_, I don't think autothreading applies to sets

[14:59] <pmichaud> set(1,2,3) + 3  is really just   (1,2,3) >>+>> 3

[14:59] <ruoso> pmichaud, exactly... that's how  "multi infix:<+>(Set, Num) {...}" implements it

[15:00] <pmichaud> so, you're just wanting to have a Set type that hyperizes its operators without using the >> <<

[15:00] <ruoso> so it DWIM on regular operators

[15:00] <ruoso> just as jucntion does

[15:00] <ruoso> (which is why people keep wanting to use Junction as Set)

[15:01] <pmichaud> but I don't think this gets at the true issue

[15:01] <pmichaud> i.e., someone wants to be able to ask "are any of the elements greater than X" -- which means it's a junction again.

[15:01] <pmichaud> or if someone wants to ask "which of the elements are greater than X", it's a map

[15:01] <pmichaud> or if someone wants to say "give me all of the elements greater than X", it's a grep

[15:02] <diakopter> perhaps more contextualizers are needed, then, for Junction context and such

[15:02] *** parduncia_ left
[15:03] <moritz_> if we still had .eigenstates it wouldn't be all that hard :)

[15:03] <pmichaud> istr that TimToady has recently declared that junctions are meaningful only in boolean context.

[15:03] <pmichaud> moritz_: even .eigenstates doesn't help out much for "give me all of the elements greater than X"

[15:04] <PerlJam> junction -> list -> grep   seems fine to me :)

[15:04] <pmichaud> PerlJam: sure, but if you do something like    any(...) > 3    then the resulting junction is a junction of booleans

[15:04] <moritz_> what PerlJam said :-)

[15:04] <pmichaud> i.e., we've lost the original values

[15:04] <moritz_> right

[15:04] <ruoso> the problem is that using junctions as sets will lead to unexpected behavior at some point

[15:05] <moritz_> but for that question you use (...).grep({$_>0})

[15:05] <PerlJam> pm: so, don't do that?  It seems like we have enough operators to convert lists into whatever we nee

[15:05] <pmichaud> PerlJam: yes, that's kinda my point.

[15:05] <ruoso> I see your point...

[15:05] <moritz_> currently Junctions are kind of like a singularity

[15:05] <ruoso> but it's all about DWIMmery

[15:06] <moritz_> you can throw items in, but you'll only ever get a boolean out

[15:06] <moritz_> heh, but I know I can cheat to get eigenstates back

[15:07] <moritz_> rakudo: my @x; sub e($x) {@x.push: $e }; e(1|2|3); @x.perl.say

[15:07] <ruoso> I currently think of Set having all the dwimmery junction has, but no collapsing and no autothreading...

[15:07] <p6eval> rakudo 9fa0fc: OUTPUT«Scope not found for PAST::Var '$e' in e␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[15:07] <moritz_> rakudo: my @x; sub e($x) {@x.push: $x }; e(1|2|3); @x.perl.say

[15:07] <p6eval> rakudo 9fa0fc: OUTPUT«[1, 2, 3]␤»

[15:07] <moritz_> ruoso: but the junction dwimmery comes exactly from autothreading

[15:07] <PerlJam> ruoso: it's different dwimmery isn't it?

[15:08] <moritz_> ruoso: if you don't autothread, you won't get any dwimmery with user defined subs

[15:08] <ruoso> moritz_, well... it does in terms of implementation... not in terms of expected behavior...

[15:08] <ruoso> moritz_, autothreading is not necessary to call the same sub several times

[15:08] *** literal_ is now known as literal

[15:09] <ruoso> that's just an hyper invocation...

[15:09] <moritz_> ruoso: ... and we call it autothreading.

[15:10] <moritz_> not that "normal" hyper invocation doesn't work with user defined subs with two parameters

[15:10] <moritz_> that's where you need autothreading to dwim

[15:10] <ruoso> indeed... that's the point I'm talking about

[15:10] <ruoso> Set is Any

[15:10] *** nihiliad joined
[15:10] <ruoso> it's not autothread.. it's simply overrided operators

[15:11] <moritz_> so you want a type that doesn't DWIM on user defined functions, but autothreads on built-in functions/operators?

[15:11] <ruoso> not autothread... simply follows regular multi dispatch

[15:11] <ruoso> there's nothing "automatic" there

[15:12] <moritz_> but from a user's point of view it looks like autothreading?

[15:12] <pmichaud> you want a type that has overloaded operators that dwim the hyperization for builtins

[15:12] <ruoso> pmichaud, exactly

[15:12] <pmichaud> but wouldn't dwim the hyperization for non-builtins

[15:12] <pmichaud> i.e., if I define my own custom operator, I'd have to define its Set version also.

[15:12] <moritz_> ... which would introduce a distinction between builtins and non-builtins that's undesirable IMHO

[15:12] <ruoso> exactly... 

[15:13] <ruoso> it's not really a distinction...

[15:13] <pmichaud> I think it is.

[15:13] <ruoso> it's like Whatever

[15:13] <moritz_> but it makes it more work to define new operators that DWIM

[15:13] <moritz_> that's the big advantage of junctions

[15:13] <ruoso> just like with Whatever

[15:13] <moritz_> 90% of all code just works with them

[15:13] <ruoso> moritz_, and the danger in being used as if it were a simple Set

[15:13] <PerlJam> 90%?

[15:14] <ruoso> my point is... Set is as special as Whatever

[15:14] <ruoso> not as special as junctions

[15:14] <moritz_> ruoso: yes, but if you add more such concepts the complexity for defining user defined operators increases quadratically

[15:14] <pmichaud> I can understanding having Whatever as a special case.   I can't understand using it to justify other special cases :-)

[15:14] <moritz_> no, actually exponentially

[15:15] <moritz_> right, one special case is bad enough already

[15:15] <ruoso> ok... what would happen in the case of new operators?

[15:15] <ruoso> it would fall into the Any,Any signature

[15:15] <ruoso> which should deal with unknown types

[15:15] <moritz_> but doesn't add any meaningful behaviour

[15:16] <ruoso> so, Set has a very well defined behavior...

[15:16] <diakopter> pmichaud: why would you need a Set version of the custom operator as well?  isn't that just like saying you can write an optionally parallel implementation of an operator if you want to?  Why wouldn't we want to allow folks to write parallelized and nonparallelized implementations of operators that work in the proper contexts

[15:16] <ruoso> that's my point

[15:16] <pmichaud> diakopter:  suppose I have   set(1,2,3) + 3    .... according to ruoso, that gives me set(4,5,6)

[15:16] <pmichaud> (more

[15:17] <pmichaud> diakopter: now then, if I define   postfix:<!> to do factorial

[15:17] <pmichaud> and write

[15:17] <pmichaud>    (set(1,2,3) + 3)!

[15:17] <pmichaud> my generic expectation is that I end up with  (4!, 5!, 6!)

[15:17] <pmichaud> but unless I write a special Set-form of postfix:<!>   what I will really end up with is 3!

[15:17] <moritz_> ruoso: it's well defined, but much less useful than autothreading

[15:18] <[particle]> (because 3 is the number of elements in the set, for those wondering)

[15:20] <moritz_> have a nice weekend all

[15:20] *** donaldh left
[15:20] <moritz_> ciao

[15:20] <ruoso> hmm... 

[15:20] <pmichaud> it gets a little worse if I can't even tell that something is a Set

[15:20] <ruoso> pmichaud, that you could...

[15:20] <pmichaud> because $a + 3   and $a customOp 3   would end up doing different things.

[15:20] <ruoso> ~~ Set

[15:20] <ruoso> pmichaud, but that's just MMD

[15:20] *** donaldh joined
[15:21] <ruoso> but point taken... I don't think I have a strong argument...

[15:21] <ruoso> I think it shouldn't be a problem to have Set in the same level as junctions

[15:21] <ruoso> but without the collapsing

[15:22] <pmichaud> ruoso: I'd suggest completing the example you gave in the thread, though.

[15:22] <pmichaud> ruoso: i.e., you proposed the idea of Set, but then didn't illustrate how it could be used to determine that @p beats @d

[15:22] <diakopter> correct me if I'm wrong... there's already a metaop syntax for hyper.. but ruoso thinks it can be inferred, sometimes (but pmichaud disagrees).

[15:23] <pmichaud> diakopter: ruoso proposes that Set DWIMs hyper for builtins

[15:23] <ruoso> pmichaud proposes it DWIMs for everything ;)

[15:23] <[particle]> it auto-hyperizes, that's the dwim here

[15:23] <[particle]> does that apply to bag, too?

[15:24] <[particle]> but not array and list?

[15:24] <Matt-W> what happens if you do something that expects a set to a set of sets?

[15:24] <pmichaud> I'm not proposing it DWIMs for everything -- I'm illustrating why DWIM for somethings and non-DWIM for others may be problematic

[15:24] <[particle]> is Set.keys defined?

[15:24] <pmichaud> if anything, I'm saying that we already have a hyperizing notation, we should use it.

[15:24] <ruoso> Matt-W, it doesn't collapse... 

[15:24] <ruoso> [particle], I'm not sure it should be named "keys"

[15:25] <Matt-W> pmichaud: that seems sensible to me

[15:25] <[particle]> i'm basically asking how array-like a Set is.

[15:25] <[particle]> does it Enumerable?

[15:25] <ruoso> hmm,... Enumerable?

[15:25] <ruoso> you mean... Positional?

[15:25] <PerlJam> It seems like ruoso's idea could work if there were some way to specify that operations "pass through" the Set to its members.  (i.e., if there were a generic mechanism to specify the pass-through)  But I'm not sure there's much utility beyond the specific example of Set

[15:26] <ruoso> PerlJam, the way for doing that would be the same of the one for junctions...

[15:26] <PerlJam> ruoso: right.

[15:26] <ruoso> for those who missed it, I agreed it should be in the same level of Junctions...

[15:26] <PerlJam> ruoso: right now, that's part of the "special case" for junctions.  They have this behaviour, but other objects can't get at it easily.

[15:26] <[particle]> hrmm, yeah, i guess i mean Positional.  perhaps there's room for an Enumerable role, that doesn't implement .keys

[15:27] <ruoso> I'd suppose Set doesn't support .]

[15:27] <ruoso>  .[] nor .{}

[15:27] <ruoso> because a set is not ordered...

[15:27] <ruoso> I guess

[15:27] <[particle]> right, nor Bag

[15:27] <Matt-W> .[] would be pretty meaningless

[15:27] <Matt-W> and .{} has no keys to work with

[15:28] <diakopter> well, it has an ordering on *some* time dimension

[15:28] <ruoso> I guess it implements .exists

[15:28] <ruoso> and .values

[15:28] <Matt-W> I can imagine doing a for loop ove ra set though - just in no particular order

[15:28] <PerlJam> diakopter: yeah, but you don't want to imply anythign about the order at the interface.

[15:28] <diakopter> heh :)

[15:28] <[particle]> Set.values is Set.pick(*)

[15:29] <ruoso> fair analogy

[15:29] <[particle]> so set(1,2,3).values!

[15:30] <[particle]> no, that probably still gives 3!

[15:30] <ruoso> just set(1,2,3)!

[15:30] <ruoso> and it will autothread, returning the same as set(1!, 2!, 3!)

[15:30] *** kst left
[15:30] <ruoso> just like junctions...

[15:30] <ruoso> but without any type of collapsing

[15:31] *** kst joined
[15:31] <[particle]> yes, that's your proposal.

[15:31] <ruoso> yes

[15:31] <[particle]> a set is a junction with list context

[15:31] <[particle]> a junction is a set with boolean context

[15:31] <[particle]> something like that

[15:31] <ruoso> not really

[15:32] <ruoso> because none(1,2,3) doesn't map to any set concept

[15:32] <[particle]> set(Nil)

[15:32] <ruoso> the collapsing of junctions is what makes it "Not A Set"

[15:32] <[particle]> i wonder about set(Nil).elements

[15:33] <ruoso> if I remember first-grade school, it is 1

[15:33] <skids> I always viewed a set as keys without values, not values without keys.

[15:33] *** Cybera joined
[15:34] <ruoso> [particle], if I see what you mean... Nil.elements will be 0

[15:34] <[particle]> yep

[15:34] <PerlJam>  If we had AutoThread as a role and Junctions does AutoThread  and Set does AutoThread   ...  :)

[15:34] <ruoso> PerlJam, that isn't necessary...

[15:34] <[particle]> so you have the whole container/values method problem, like junction

[15:35] <ruoso> Any vs Object already does that distinction

[15:35] <diakopter> so, a junction is a membership predicate of a [perhaps lazily enumerated] set?

[15:35] <diakopter> (sorry for continually translating the Perl terminology...)

[15:35] * PerlJam doesn't remember the hierarchy

[15:36] <ruoso> diakopter, I don't really see a reason to stablish a hierarchy between Junction and Set... they are both Object and both not Any

[15:36] <diakopter> I'm not tryign to do that

[15:36] <ruoso> [particle], ah... I guess that's the main difference...

[15:36] <diakopter> they can have logical relationships in both directions

[15:36] <ruoso> (1,2,3).foo doesn't autothread...

[15:36] <ruoso> it simply calls the method foo on the set

[15:37] <diakopter> set(1,2,3).foo ?

[15:37] <[particle]> set(1,2,3).foo, you mean

[15:37] <ruoso> yeah... sorry

[15:37] <[particle]> so, set(1,2,3)! is 3!

[15:37] <ruoso> why?

[15:37] <[particle]> set(1,2,3).postfix<!>

[15:38] <ruoso> [particle], ops are not method calls

[15:38] <ruoso> they are multi sub calls

[15:38] <[particle]> ah, right, different dispatcher

[15:38] <skids> Do folks really want sets, or Bags?  Bag is a hash of integer counts where count=0 keys cannot exist.

[15:38] <ruoso> exactly

[15:38] <[particle]> there are three dispatchers, right?

[15:38] <[particle]> skids: perl 6 specifies both Set and Bag

[15:39] <skids> Yes, but speaking of what the demand is for.

[15:39] <ruoso> [particle], multi sub dispatch, object dispatch and private dispatch.... yes... I think that's all...

[15:39] <[particle]> a Set is a Bag with uniqueness constraints

[15:39] <skids> What are these junction abusers really after? :-)

[15:39] <ruoso> skids, implement blackjack programs

[15:39] <[particle]> :)

[15:40] * [particle] wonders if blackjack will be a one-liner in perl6

[15:40] <diakopter> .21

[15:41] <[particle]> well, the problem and the proposal seem well-defined to me.

[15:41] * diakopter re-reads http://osdir.com/ml/lang.perl.perl6.language/2005-02/msg00196.html

[15:42] <pmichaud> I'd still like to see the complete blackjack solution done with sets

[15:42] <pmichaud> I'm not convinced it solves the problem.

[15:42] <[particle]> i'm not sure it solves it, either, but it's clear to me.

[15:42] <ruoso> pmichaud, basically... replace 1|11 by set(1,11)

[15:43] <pmichaud> I understand that part.  I don't see how to do the rest of the problem.

[15:43] <[particle]> right, the trick is in the op and method calls involving sets

[15:43] <ruoso> my @hand = set(1,11), 3, set(1,11);

[15:43] <ruoso> my $sum = [+] @hand;

[15:44] <pmichaud> what does $sum become after that step?

[15:44] <ruoso> say $sum.perl; # set(5,15,25)

[15:44] <pmichaud> okay, so keep going

[15:45] <pmichaud> in reality (from the original) we would have

[15:45] <ruoso> if any($sum) < 21 { #there's a game here

[15:45] <pmichaud> my $p = [+] @p;

[15:45] <pmichaud> my $d = [+] @d;

[15:46] <pmichaud> where $p is set(4, 14, 24) and $d is set(5, 15, 25)

[15:46] <ruoso> ok...

[15:46] <pmichaud> how do we determine that $d beats $p ?

[15:46] * diakopter mangles  any( $sum, (x) => x < 21 )  in my head

[15:47] <ruoso> pmichaud, that's where the set part really enters... since we need the subset of valid games...

[15:47] <pmichaud> and we do that with ... ?

[15:47] <ruoso> my $valid_p = $p.subset: { * < 21 };

[15:48] <literal> Hm, ok, I'm definitely gonna apply for GSoC this year and I have Perl 6 in mind. However, I not sure which aspect I should work on. What would be of most benefit to Perl 6? Spec tests? Docs (u4x)? Something else?

[15:48] <diakopter> <=

[15:48] <ruoso> right...

[15:48] <ruoso> my $valid_p = $p.subset: { * <= 21 };

[15:49] <[particle]> literal: both are good.  i suggest you take that to the list (tpf-gsoc-students@googlegroups.com)

[15:49] <PerlJam> literal: pick the one you want to work on.

[15:49] <[particle]> the mentors not here can reply there

[15:49] <literal> PerlJam: a lot of them look good to me, so I'd like to pick one that's more likely to be accepted :)

[15:50] <pmichaud> what's the difference between  $p.subset and $p.grep ?

[15:50] <ruoso> $p.subset returns another set...

[15:50] <pmichaud> $p.grep couldn't do the same?

[15:50] <ruoso> maybe... 

[15:50] <ruoso> but even then...

[15:51] <ruoso> my $valid_p = $p.grep: { * <= 21 };

[15:51] <[particle]> does grep change the context of its elements?

[15:51] <ruoso> which is what people is trying to do with junctions

[15:51] <[particle]> er, the elements of the object over which it's operating.

[15:52] <ruoso> [particle], what do you mean by "change the context"?

[15:52] <[particle]> i guess i mean, does grep return List?

[15:52] <[particle]> or are you suggesting a multi for grep that returns Set?

[15:52] <ruoso> [particle], well... that was why I didn't suggest $p.grep at the first example

[15:52] <ruoso> but I think there isn't really a problem in that case...

[15:53] <pmichaud> so far it looks as though the only advantage of Set over List is in the [+] step.

[15:53] *** Tene_ joined
[15:53] <ruoso> in the blackjack case... maybe

[15:54] <ruoso> but...

[15:54] <ruoso> if you really think as sets...

[15:54] <ruoso> you could extend the dwimmery to...

[15:54] <ruoso> my $valid_p = $p <= 21;

[15:54] <pmichaud> wouldn't that be a set of booleans, then?

[15:55] <ruoso> no... a set of the values that passed the test

[15:55] <ruoso> where an empty set is, obviously, false

[15:56] <pmichaud> I would think an empty set would remain empty

[15:56] <ruoso> I mean... an empty set in boolean context is false

[15:56] <[particle]> i'd like to see set operators that create sets, like union, intersection, etc

[15:56] <pmichaud> (but you can see why this gets weird, because we're taking what was a boolean operator and turning it into a filter)

[15:57] <pmichaud> there's no boolean context in   my $valid_p = $p <= 21;

[15:57] <ruoso> yes... I only said that as an additional comment

[15:57] *** |jedai| left
[15:58] <pmichaud> does prefix:<+> DWIM on sets?

[15:58] <ruoso> does it DWIM on junctions?

[15:58] <pmichaud> yes.

[15:58] <ruoso> so yse

[15:58] <ruoso> since Set is not Any

[15:59] <[particle]> maybe it should be spelled 'set', not 'Set'

[15:59] *** |jedai| joined
[15:59] <[particle]> as now we have junction

[15:59] <pmichaud> how would I get a list of the elements out of a set?

[15:59] <ruoso> that usually differentiates native vs non-native types

[15:59] <ruoso> pmichaud, $set.values?

[15:59] <ruoso> or just @$set

[15:59] <pmichaud> so methods don't autothread

[15:59] <ruoso> no... they don't...

[16:00] <[particle]> right, ops autothread, and not methods, on sets.

[16:00] <[particle]> that's ruoso's idea.

[16:00] <pmichaud> how would I truncate all of the elements in a set?

[16:00] <ruoso> what do you mean by truncate?

[16:00] <[particle]> make it the empty set.

[16:00] <pmichaud> rakudo:  3.4.truncate

[16:00] <p6eval> rakudo 9fa0fc: RESULT«3»

[16:00] <[particle]> ah, like floor.

[16:00] <pmichaud> yes, or floor.

[16:01] <diakopter> truncate in-place or make a new set

[16:01] <pmichaud> make a new one

[16:01] <[particle]> set(1,2,3).<<truncate

[16:01] <pmichaud> particle:  a set in list context becomes a list of its elements?

[16:01] <ruoso> that's my plan

[16:02] <diakopter> (flattens)

[16:02] <pmichaud> can I have lists of sets?

[16:02] <pmichaud> or sets of lists?

[16:02] <[particle]> (set(1,2,3).<<truncate).WHAT() # set, or List?

[16:02] <ruoso> hmmm

[16:02] <ruoso> why are you using the hyper operator there>

[16:02] <ruoso> ?

[16:03] <[particle]> i want to call that method on the elements of the set

[16:03] <pmichaud> he's treating the set as a list.

[16:03] <pmichaud> (the hyper is pointing the wrong way, I think)

[16:03] <ruoso> I guess you need an explicit cast, in that case

[16:03] <pmichaud> so it would be   set(1,2,3).values.truncate ?

[16:03] <[particle]> yes, it is, and i copy/pasted the bad code again :(

[16:04] <ruoso> or does the hyperop implies list context?

[16:04] <pmichaud> er, >>.truncate

[16:04] <[particle]> hyperop implies list

[16:04] <ruoso> well... if it implies list, you'll get it called in the elements of the set

[16:05] *** Tene left
[16:05] <ruoso> pmichaud, but why can't set implement truncate as well?

[16:05] <ruoso> (although I don't really see what truncate would do in a set)

[16:05] <[particle]> it would operate on its elements

[16:05] <pmichaud> ruoso: this gets back to the question of "how do I know which methods are defined for Sets and which aren't?"  (more)

[16:05] <[particle]> basically, most anything Any does, set should do.

[16:05] <pmichaud> In the case of Junctions, methods autothread over the Junction, so we don't have to think about whether or not it's implemented for Junction

[16:06] <diakopter> so, a set has its own dispatcher that iterates, optionally parallel.

[16:06] <ruoso> pmichaud, that problem doesn't arise in Set, because it never delegates a method call to its elements

[16:06] <pmichaud> it's just inconsistent then (more)

[16:06] <pmichaud> for Junctions, we have autothreading of methods and operators

[16:07] <[particle]> so sets only produce sets with operators. with methods, they produce lists.

[16:07] <pmichaud> for Lists, we have hyperizing of methods and operators

[16:07] <pmichaud> for Sets, we hyperize operators but not methods

[16:07] <pmichaud> (or DWIM operators but not methods)

[16:07] <ruoso> right... I see the point...

[16:09] <ruoso> but even if we have to face the problem of "which method does Set implement"

[16:09] <ruoso> there's still a major difference from Junctions...

[16:09] <ruoso> there's no collapsing

[16:09] <pmichaud> I'm asking if there's a major difference from List

[16:10] *** cognominal left
[16:10] <ruoso> it DWIMs in operators and methods...

[16:10] <pmichaud> no, you just said it DWIMs operators only

[16:11] <ruoso> pmichaud, I accepted your point five lines ago ;)

[16:11] <pmichaud> oh.

[16:11] <pmichaud> I didn't know that "see the point" meant "accepts it"

[16:11] <ruoso> sorry... 

[16:11] <pmichaud> so, the purpose of a set is to get rid of the hyper angles on lists.

[16:11] <skids> Well either way I think we would want to specify that sets/bags only act like hashes when treated that way, and when naked they explode to the keys, not the values.

[16:12] <ruoso> pmichaud, the purpose of set is provide all the DWIMmery people love in Junctions, but without collapsing, which makes "getting the values" a reasonable idea...

[16:12] <pmichaud> but the effect is simply to have a type that doesn't require hyper angles

[16:12] <ruoso> not really...

[16:12] <pmichaud> because I could do the same thing with List

[16:13] <ruoso> the effect is having a type that can be used as a singular value, even if it's a plural value

[16:13] <ruoso> which means that you can intermix singular and plural

[16:13] <ruoso> i.e.:

[16:13] <ruoso> my @hand = set(1,11), 3, set(1,11)

[16:13] <ruoso> my $sum = [+] @hand;

[16:14] <ruoso> the code works the same if you have no sets there

[16:15] *** |jedai| left
[16:15] <pmichaud> what if we have ...

[16:15] *** |jedai| joined
[16:15] <pmichaud> my $x = set(1,11);   say ($x < 3).perl;

[16:16] *** mberends left
[16:16] <pmichaud> do I get   set(3)   or set(True, False)  ?

[16:16] <pmichaud> sorry, set(1)   or set(True, False)

[16:17] <pmichaud> and that leads to

[16:17] <pmichaud> my $ordered = [<=] @hand;

[16:18] <ruoso> the question is "what does comparing a set to a number means"?

[16:19] <ruoso> hmm... actually... that's not the question...

[16:19] <pmichaud> in junctions,  $x < 3  would produce a junction of true/false values

[16:19] <pmichaud> (assuming $x is a junction)

[16:21] <ruoso> rakudo: my @hand = 1|11, 3, 1|11; my $ordered = [<=] @hand; say $ordered.perl;

[16:21] <p6eval> rakudo 9fa0fc: OUTPUT«get_integer() not implemented in class 'Junction'␤current instr.: '!MAKE_JUNCTION' pc 9241 (src/classes/Junction.pir:222)␤»

[16:21] *** kst left
[16:22] <pmichaud> we still have some autothreading issues in rakudo.

[16:22] <ruoso> but what would it return?

[16:22] *** kst joined
[16:22] <pmichaud> well, it ought to be the same as    1|11 <= 3 <= 1|11   

[16:23] <pmichaud> which is going to be a junction of true/false values of some sort

[16:23] <ruoso> rakudo: my $ordered = 1|11, 3, 1|11 ; say $ordered.perl;

[16:23] <p6eval> rakudo 9fa0fc: OUTPUT«[any(1, 11), 3, any(1, 11)]␤»

[16:23] <ruoso> rakudo: my $ordered = 1|11 <= 3 <= 1|11 ; say $ordered.perl;

[16:23] <p6eval> rakudo 9fa0fc: OUTPUT«any(Bool::False, Bool::True)␤»

[16:24] * ruoso thinking

[16:24] <skids> That's logical.  It could be true, or could be false, depending on what value collapsed out of each junction.

[16:24] <pmichaud> anyway, I need to get to work on some other tasks.  Sets are a good idea, but I don't think we have quite the right magic yet.

[16:25] <ruoso> I think "set(1,11) > 3" should somehow return "set(1)"

[16:25] <ruoso> but I still don't know how it could get there

[16:26] <skids> I think that's more like the functionality a user that goes looking for "sets" would want.

[16:27] <skids> But as far as "the purpose of sets" it was my reading that the original intent was just that set(1,2){1} == 1, but set(1,2).>>say said "1 2" or "2 1"

[16:27] <skids> And nothing fancier.

[16:28] <skids> Not that fancier might not be good.

[16:28] <ruoso> skids, the problem is, if you want to be able to use a set where you use a plain value... it needs to be much fancier

[16:29] <ruoso> and if that's not possible, there's no difference from a regular list

[16:29] <skids> Not if all you expect is a hash that you don't have to call .keys on all the time.

[16:29] <ruoso> what's the purpose of that?

[16:29] <ruoso> I mean

[16:29] <ruoso> set(1,2){1} 

[16:29] <ruoso> what's the meaning of that?

[16:29] <ruoso> you're trying to extract a value that you already have

[16:30] <skids> A lot of uses of hashes is in the keys, not the values, either counting(bag) or presence(set).  So I read it as just a way to ensure you could have very efficiently stored keys that were easier to work with syntactically.

[16:31] <ruoso> skids, right... but .{} is not the api to that

[16:31] <ruoso> probably .exists

[16:31] <skids> $a = something that generates a set; if ($a{"foo"}) do something.

[16:31] *** DietCoke joined
[16:31] *** DietCoke is now known as Coke

[16:31] <skids> ruoso: think bags for .{}, then ask why not sets too.

[16:31] <Coke> is there a way to collapse nested anys?

[16:32] <Coke> e.g. any(any(1,2),any(2,3)) == any(1,2,3) ?

[16:32] <skids> bag is the more important of the two.

[16:32] <Coke> .

[16:33] *** awarefish joined
[16:33] <ruoso> Coke, you collapse it when you use it

[16:33] <ruoso> rakudo: say any(any(1,2),any(2,3)) > 2;

[16:33] <p6eval> rakudo 9fa0fc: OUTPUT«Junction<0xb5b45928>␤»

[16:34] <ruoso> rakudo: say (any(any(1,2),any(2,3)) > 2).true;

[16:34] <p6eval> rakudo 9fa0fc: OUTPUT«1␤»

[16:34] <ruoso> rakudo: say (any(any(1,2),any(2,3)) > 2).perl;

[16:35] <p6eval> rakudo 9fa0fc: OUTPUT«any(any(Bool::False), any(Bool::False, Bool::True))␤»

[16:37] <skids> ruoso: and also pay attention that anything a Set/Bag can do a KeySet/KeyBag should also do, but they are mutable.

[16:37] <ruoso> skids, I'd prefer a syntax like: if "foo" ∈ $a {...} instead

[16:39] <skids> I think .{} falls out from the overarching "if you want it to behave like a hash, treat it as a hash" edict.

[16:39] <ruoso> skids, not really... KeySet implements the behavior you want... not Set

[16:39] <ruoso> it's not just immutable/mutable conterparts

[16:40] <ruoso> Set doesn't behave like a Hash

[16:40] <ruoso> nor does Bagh

[16:40] <ruoso> just KeySet and KeyBag

[16:40] <skids> Is there something in the standard that says or implies so?

[16:41] <ruoso> yes... S02

[16:41] <ruoso> KeySet      KeyHash of Bool (does Set in list/array context)

[16:41] <ruoso> KeyHash     Perl hash that autodeletes values matching default

[16:41] <ruoso> Set         Unordered collection of values that allows no duplicates

[16:41] *** Cybera left
[16:42] <skids> That doesn't say anything about {}

[16:42] *** awarefish left
[16:43] *** orafu left
[16:43] <ruoso> skids, Associative implements .{}

[16:43] <ruoso> Set is not Associative

[16:43] *** FurnaceBoy joined
[16:43] *** OuLouFu joined
[16:43] *** OuLouFu is now known as orafu

[16:43] <jnthn> Heading off for the weekend; probably offline most of it; back Tuesday. Have fun. :-)

[16:44] <pmichaud> have fun, jnthn!

[16:45] <ruoso> pmichaud, do you see any way to make "set(1,2,3) > 2" to return "set(3)" ?

[16:45] <pmichaud> not without introducing some other confusion, no.

[16:46] <ruoso> unless there are specific signatures for that operators

[16:46] <ruoso> since we want them to return a different thing

[16:46] *** Psyche^ joined
[16:47] <pmichaud> rakudo:  say  'c' cmp 3;

[16:47] <p6eval> rakudo 9fa0fc: OUTPUT«1␤»

[16:47] <pmichaud> rakudo:  say  3 cmp 'c';

[16:47] <p6eval> rakudo 9fa0fc: OUTPUT«1␤»

[16:47] <pmichaud> (...sigh...)

[16:47] <ruoso> rakudo: say +'c'

[16:47] <p6eval> rakudo 9fa0fc: OUTPUT«0␤»

[16:49] * ruoso lunch &

[16:49] <pmichaud> yes, I should lunch here also.

[16:50] <skids> same here

[16:55] <[particle]> you people are crazy, it's too early for lunch!

[16:56] <literal> initial draft: http://nix.is/u4x-gsoc.pod  ... comments?

[16:59] *** hercynium joined
[16:59] <diakopter> ruoso: what about another meta operator... meaning apply (really *permute*) the operator's argument(s) (if/where they are sets), and return a set of the [union of] the results.  set(1,2,3) S> 2 gives set(3), and set(1,2,3) S> set(1,2) gives set(2,3)

[17:00] <ruoso> diakopter, the point is about being able to use a set as if it were a singular value...

[17:01] <diakopter> I know; I'm suggesting a way to do it, assuming there's no reliable way to infer it.

[17:02] <ruoso> the point is if that can't be done, sets are not more usefull than plain lists

[17:03] *** Patterner left
[17:03] *** Psyche^ is now known as Patterner

[17:03] <diakopter> but they are, if they have a meta-op that enforces uniqueness when hyperizing.

[17:05] *** zamolxes left
[17:07] <diakopter> ? bags are eagerized lists that disregard ordering; sets are bags that enforce uniquenes ?

[17:11] <diakopter> I see your point, they're not more useful as language intrinsics if operations on them don't have possibly special behavior... but of course they're still useful as logical constructs

[17:12] <diakopter> (I think)

[17:12] *** kst left
[17:12] *** kst joined
[17:12] <ruoso> I think I'll get back to the idea of Set being Any

[17:13] <ruoso> the consequences of putting it in the same level as junction are enormous

[17:13] <ruoso> and in the end, you always need to use it as a Set

[17:14] <ruoso> so "set(1,2,3) + 3" works by the existance of "infix:<+>(Set, Num)"

[17:15] <ruoso> it provides limited DWIMmery... but it's still better than no DWIMmery....

[17:15] <diakopter> .... idea of Set being the result of an Any [applied to a predicate producing a bool that's used for membership]?

[17:15] <ruoso> no...

[17:15] <ruoso> the idea of Set ~~ Any

[17:15] <diakopter> oh.

[17:15] <ruoso> meaning it wouldn't autothread at all

[17:16] <ruoso> and all DWIMmery would depend on signatures in each operators that we want to DWIM

[17:16] <ruoso> just like Whatever

[17:17] * ruoso really lunch &

[17:18] <diakopter> speaking of operators... can an operation (like infix:<+>(Set, Num)) be declared as commutative, so that infix:<+>(Num, Set) is also applicable?

[17:20] <[particle]> no

[17:20] <[particle]> there's no commutative adverb

[17:20] <diakopter> no, as in "not yet", or no, as in "I don't like that idea"? :)

[17:20] <[particle]> right now that's R[]

[17:20] *** frioux_away left
[17:20] *** frioux joined
[17:20] <[particle]> not yet.

[17:22] <[particle]> we have 'is assoc' but not 'is commutative'

[17:22] <[particle]> s/adverb/trait/

[17:23] <diakopter> I suppose 'is commut' ('is commu'?) could also apply to n-ary operations (not just binary)

[17:23] *** cognominal joined
[17:24] <diakopter> er, not n-ary operations :)  I mean, operations of all arities.

[17:25] *** pmurias joined
[17:25] <diakopter> pmurias:  hi

[17:25] <pmurias> diakopter: hi

[17:26] <diakopter> pmurias: lots to backlog...

[17:26] <diakopter> :D

[17:31] <pmurias> diakopter: yes, someone has to start this week/day in #perl6

[17:31] <pmurias> ;)

[17:34] *** Coke left
[17:37] *** donaldh left
[17:37] <ruoso> hi pmurias 

[17:37] <pmurias> ruoso: hi

[17:41] <ruoso> pmurias, I was thinking the LOwlevel STate machine can still be helpfull, specially when we support signatures in the RI DSL

[17:42] <ruoso> because if the capture is native and the values are not wrapped into a scalar, it will be able to have all the values avaialble before returning the first time... it could even use some trick to avoid getting back to the runloop...

[17:43] <ruoso> while it would still do all the necessary SMOP_DISPATCH (one at a time) if that's not the case...

[17:43] <ruoso> pmurias, what do you think?

[17:44] <pmurias> isn't that a bit of premature optimalisation

[17:44] <pmurias> ?

[17:44] <pmurias> btw we should add a wrapper around SMOP_DISPATCH which calls SMOP_RELEASE on the it's return value

[17:45] <ruoso> pmurias, you know you can simply use SMOP_RELEASE around it, don't you?

[17:45] <pmurias> yes

[17:46] <ruoso> btw... I'm not sure it's premature optimization... because generating the mold code for the signature is not going to be much fun... specially if the code that will use the values is not a mold block

[17:47] <ruoso> generating a specialized code might be easier

[17:49] <pmurias> what i'm wondering is if it would be possible to write s1p in Perl 6

[17:49] <ruoso> I'm not sure it's worth the trouble...

[17:49] <pmurias> as most of the things s1p classes do atm is calling mold blocks and keeping data in a struct

[17:50] <ruoso> some of them, yes

[17:50] <ruoso> S1P__Scalar, for instance...

[17:50] <ruoso> is not one of them

[17:50] <ruoso> nor is S1P__Array

[17:50] <ruoso> or Hash

[17:54] <ruoso> pmurias, what certainly would help would be a way to write a method with a signature in mold

[17:54] <ruoso> like...

[17:54] <ruoso> %moldmethod foo($bar, $baz)

[17:55] <ruoso>   $mold."code"("here");

[17:56] <pmurias> that would eliminate a fair bit of the boiler plate

[17:56] <ruoso> but not many methods are implemented just in mold

[17:56] <ruoso> they usually access some internal attribute of the object...

[17:57] <ruoso> which is set in the given mold frame

[17:57] <ruoso> which gets execute

[17:57] <ruoso> d

[17:59] <ruoso> pmurias, maybe %moldmethod provides an additional signature, for getting things from this object's structure...

[17:59] <ruoso> like...

[18:00] <ruoso> %moldmethod foo ($bar, $baz) ($bla = invocant->member, $ble = invocant->othermember)

[18:01] *** schmalbe joined
[18:02] <ruoso> where $bar, $baz, $bla and $ble are made available as registers in the mold

[18:03] <pmurias> that would be helpfull

[18:04] <pugs_svn> r26015 | putter++ | [elfparse] IRx1_FromAST2_create.pl: Kludge around /:my $x; a | b/ parsing as /[:my $x; a] | b/.

[18:05] <pmurias> ruoso: i'll have to think over and compare it to have a set of primitives and write s1p in Perl 6 (without lexical scopes) approach

[18:05] <skids> how about a parameter trait "will explode" or something, lets MMD know if it gets a Set to feed to a scalar, to thread.

[18:06] <skids> (as long as the Set is "of" the appropriate type, of course)

[18:07] <pmurias> ruoso: what license to we use for smop?

[18:08] <skids> Though I guess for foo(set(1,2),$bar) that doesn't get around the set list context explosion before the MMD.

[18:08] <ruoso> same as perl

[18:19] <pmurias> shouldn't we use Artistic 2?

[18:20] <amoc> .oO( it is just a checking for myself that failed in my local test )

[18:20] <amoc> rakudo: is (<a ab>, <bc ad ba>).comb(m:Perl5/\S*a\S*/), <a ab ad ba>, 'comb a list';

[18:20] <p6eval> rakudo 9fa0fc: OUTPUT«Could not find non-existent sub is␤current instr.: '_block14' pc 190 (EVAL_17:67)␤»

[18:21] *** M_o_C joined
[18:21] <amoc> rakudo: (<a ab>, <bc ad ba>).comb(m:Perl5/\S*a\S*/), <a ab ad ba>;

[18:22] <p6eval> rakudo 9fa0fc: RESULT«["a", "ab", "ad", "ba", "a", "ab", "ad", "ba"]»

[18:22] <amoc> oh?

[18:22] <pmurias> ruoso: native types should support arbitary captures too?

[18:26] *** kst left
[18:26] *** kst joined
[18:38] <ruoso> pmurias, Perl uses Artistic 2 + GPL

[18:38] <ruoso> pmurias, yes, they need...

[18:40] <ruoso> pmurias, I think the only type we can accept requiring only native capture is the interpreter 

[18:46] *** Tene_ is now known as Tene

[18:49] *** eternaleye joined
[18:50] *** japhb left
[18:59] *** nihiliad left
[18:59] *** nihiliad joined
[19:01] *** riffraff left
[19:06] *** |jedai| is now known as jedai

[19:24] *** rodi left
[19:26] *** cognominal left
[19:26] *** icwiener joined
[19:29] <pmurias> ruoso: Artistics 2 is gpl comaptible so there is no need to make a disjunction

[19:29] <ruoso> it's not a disjunction

[19:29] *** cognominal joined
[19:29] <ruoso> it's a dual licensing...

[19:29] <ruoso> you can choose whichever you want

[19:31] <pmurias> Artistic 2 can be changed to GPL

[19:31] <pmurias> and i think perl5 is Artistic 1

[19:32] <pmurias> s/changed/sublicensed

[19:33] *** dKingston left
[19:44] *** REPLeffect joined
[19:45] <pugs_svn> r26016 | pmichaud++ | [S05]:  Correct typo  "by use if" ==> "by use of"

[19:52] <ruoso> pmurias, maybe let it just Artistic 2

[19:54] <diakopter> yeah, al2 software may be relicensed as any certified by opensource.org

[19:55] *** icwiener left
[20:03] *** Cybera joined
[20:03] *** Cybera left
[20:03] *** Cybera joined
[20:07] *** nww joined
[20:27] *** eternaleye left
[20:32] <Matt-W> whee

[20:32] <Matt-W> new passing tests for Form.pm

[20:34] *** frioux left
[20:35] *** skids left
[20:47] *** orafu left
[20:47] *** OuLouFu joined
[20:47] *** OuLouFu is now known as orafu

[20:49] *** eternaleye joined
[20:50] *** mikehh left
[20:51] *** ZuLuuuuuu joined
[20:51] *** rblasch joined
[20:51] *** Grrrr left
[20:52] *** Grrrr joined
[20:54] *** sri_kraih_ joined
[20:56] *** ruoso left
[20:58] *** justatheory joined
[20:59] *** M_o_C left
[21:08] *** sri_kraih left
[21:08] *** orafu left
[21:08] *** OuLouFu joined
[21:08] *** OuLouFu is now known as orafu

[21:20] *** donaldh joined
[21:24] *** mberends joined
[21:34] *** kate21de joined
[21:36] *** skids joined
[21:39] *** ron_ joined
[21:40] *** ron_ left
[21:43] *** Whiteknight joined
[21:44] *** NoirSoldats left
[21:45] *** ron_ joined
[21:49] *** NoirSoldats joined
[21:52] *** ZuLuuuuuu left
[21:52] *** Cybera1 joined
[21:52] *** Cybera left
[21:53] *** Cybera1 is now known as Cybera

[21:54] *** dKingston joined
[21:55] *** nihiliad left
[21:55] *** FurnaceBoy left
[21:59] *** justatheory left
[22:01] *** ron_ left
[22:02] *** pmurias left
[22:07] *** mberends left
[22:12] *** donaldh left
[22:17] *** hercynium left
[22:19] *** Whiteknight left
[22:25] *** nww left
[22:28] *** exodist left
[22:31] *** alester left
[22:33] *** dKingston left
[22:44] *** Whiteknight joined
[22:46] *** rblasch left
[22:48] *** orafu left
[22:52] *** orafu joined
[22:54] *** nacho joined
[22:54] *** dKingston joined
[23:00] *** nacho left
[23:01] *** schmalbe left
[23:02] *** nacho joined
[23:10] <skids> how do you bind in PIR.  e.g. $P0 = find_lex('$a')  $S0 = $P0 but I want $S0 to BE the string in $P0 not a copy of it,

[23:24] <Tene> skids: look in docs/ops/set.pod

[23:25] <skids> not finding it.

[23:27] *** jan_ left
[23:28] *** kate21de1 joined
[23:29] *** jan_ joined
[23:44] *** kate21de left
[23:47] *** orafu left
[23:47] *** OuLouFu joined
[23:48] *** OuLouFu is now known as orafu

[23:54] *** eternaleye left
