[00:09] *** maerzhase left
[00:20] <slavik> junction is when it takes an element from setA and combines it with every element from setB?

[00:21] *** pmurias left
[00:21] <slavik> ad, ae, af, bd, be ... etc?

[00:26] <slavik> pmichaud: rakudo can has libgtk bindings? ^^

[01:00] *** meppl left
[01:00] <rakudo_svn> r34841 | pmichaud++ | [rakudo]:  Autothread junctions over concatenation (infix:<~>).

[01:02] <pmichaud> rakudo: say (any(<a b c>) ~ any(<d e f>)).perl;

[01:02] <p6eval> rakudo 34840: OUTPUT«"Junction<0xb5f6c828>Junction<0xb5f6024c>"␤»

[01:02] <pmichaud> (hasn't updated yet.)

[01:03] <Limbic_Region> rakudo: my @foo = <a b c> X~X <d e f>; @foo.perl

[01:03] <p6eval> rakudo 34840: RESULT«"[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]"»

[01:03] <Limbic_Region> slavik - no, what you described is a cross product operator

[01:03] <Limbic_Region> slavik - a junction is a bit harder to describe

[01:06] <Limbic_Region> pmichaud: I am not sure I understand what any<a b c> ~ any<d e f> should produce?

[01:06] <pmichaud> rakudo: say (any(<a b c>) ~ any(<d e f>)).perl;

[01:06] <p6eval> rakudo 34840: OUTPUT«"Junction<0xb5f29860>Junction<0xb5f1d380>"␤»

[01:06] <pmichaud> arggh. just a sec.

[01:06] <pmichaud> > say (any(<a b c>) ~ any(<d e f>)).perl;

[01:06] <pmichaud> any(any("ad", "ae", "af"), any("bd", "be", "bf"), any("cd", "ce", "cf"))

[01:06] <lambdabot>   <no location info>: parse error on input `)'

[01:09] <Whiteknight> rakudo: say "w00t"

[01:09] <p6eval> rakudo 34840: OUTPUT«w00t␤»

[01:09] <Whiteknight> rakudo: say "w00t";

[01:09] <Limbic_Region> pmichaud: my question is more fundemental

[01:09] <p6eval> rakudo 34840: OUTPUT«w00t␤»

[01:09] <Limbic_Region> when you have a junction and you ask it to stringify

[01:09] <Limbic_Region> should it stringify to its eigenstates in a list

[01:09] <pmichaud> yes.

[01:09] <pmichaud> I think that's where we ended up.

[01:10] <pmichaud> just haven't implemented that yet.

[01:10] <Limbic_Region> so some questions I asked back on the list a long time ago which I was told 'no' then, are now 'yes'

[01:10] <Limbic_Region> time has a funny way of doing that

[01:10] <pmichaud> I honestly don't recall the answer -- there's probably an rt ticket for it somewhere, or else I'll have to re-check the logs.

[01:10] <pmichaud> or maybe the tests cover it.

[01:11] <Limbic_Region> well, it had to do with being able to get the actual matches out of something like all(1..5) == any(0,2,3,7)

[01:11] <Limbic_Region> to get the intersection

[01:12] <pmichaud> oh, I don't know that we do that.

[01:12] <pmichaud> (from a language perspective)

[01:12] <pmichaud> rakudo:  say (all(1..5) == any(0,2,3,7)).perl;

[01:12] <p6eval> rakudo 34840: OUTPUT«all(any(Bool::False), any(Bool::False, Bool::True), any(Bool::False, Bool::True), any(Bool::False), any(Bool::False))␤»

[01:12] <Limbic_Region> well, that should return a junction

[01:12] <Limbic_Region> as it does

[01:13] <Limbic_Region> the problem is it doesn't return the values

[01:13] <pmichaud> correct.

[01:13] <pmichaud> (as it shouldn't, I suspect)

[01:13] <Limbic_Region> but using stringification and other tricks, the same thing can be accomplished

[01:15] <Limbic_Region> though, it would be pretty silly to do since perl 6 has sets

[01:15] <Limbic_Region> and set operations

[01:16] <Limbic_Region> so getting the intersection of a list should be more straight forward

[01:17] <pmichaud> @a.grep( { $_ == any(@b) } )

[01:17] <lambdabot> Unknown command, try @list

[01:17] <pmichaud> maybe

[01:18] * Limbic_Region tries to find the correct thread

[01:19] <slavik> rakudo: say any(<a b c>);

[01:19] <p6eval> rakudo 34841: OUTPUT«Junction<0xb5f59278>␤»

[01:19] <slavik> rakudo: say ~any(<a b c>);

[01:19] <p6eval> rakudo 34841: OUTPUT«Junction<0xb5f78ba8>␤»

[01:19] <slavik> err ... ?

[01:20] <pmichaud> 01:10 <pmichaud> just haven't implemented that yet.

[01:20] <Limbic_Region> pmichaud: http://groups.google.com/group/perl.perl6.language/browse_thread/thread/fe506aa2bad65cf5/a1c92a305af2ab31?lnk=gst&q=Do+junctions+support+determining+interesections+of+lists#a1c92a305af2ab31

[01:20] <slavik> what should it return?

[01:20] <slavik> rakudo: for all(1..6) -> $a { say $a }

[01:20] <p6eval> rakudo 34841: OUTPUT«Junction<0xb68aa990>␤»

[01:21] <pmichaud> slavik: note that all(1..6) is a single scalar value

[01:21] <pmichaud> so it only iterates ones.

[01:21] <pmichaud> *once.

[01:21] <slavik> err, shouldn't that be parallel?

[01:21] <pmichaud> oh, maybe.  I don't know if that's still in the spec.

[01:23] <Limbic_Region> pmichaud - or do you need to explicitly call .values

[01:23] <pmichaud> it's not in S03, at any rate.

[01:23] <Limbic_Region> that's one of the questions I asked back in that thread I pointed to 

[01:23] <pmichaud> L_R:  so far we're against .values.  Rakudo implements .eigenstates

[01:23] <Limbic_Region> back then - the spec seemed to be contradictory about how you could use junctions

[01:23] <pmichaud> any(@a, @b).values   #  does this return (@a, @b), or does it autothread .values over (@a|@b)  ?

[01:23] <Limbic_Region> pmichaud - the method name makes no difference (to me) for the question

[01:24] <slavik> pmichaud: IMO, it should retturn one of the two arrays

[01:24] <Limbic_Region> S3 used to state that you could iterate over an all(1..5) junction just as slavik described

[01:24] <pmichaud> l_r:  yes, and I think it was decided that wouldn't really work

[01:24] <Limbic_Region> but elsewhere indicated if you wanted to get at its eigenstates, you needed to call .values 

[01:24] <Limbic_Region> ah

[01:24] <Limbic_Region> good

[01:24] <Limbic_Region> consistency++

[01:25] <pmichaud> which is why I think it's no longer in S03

[01:25] <slavik> pmichaud: since args aren't passed in @_ unless they are slurped, and all() shouldn't slurp IMO

[01:25] <Limbic_Region> I was just pulling up the latest

[01:25] <pmichaud> in order to hyperize the loop, I think we explicitly require a 'hyper' keyword now.

[01:25] <Limbic_Region> slavik - you really need to understand what a junction is

[01:25] <pmichaud> slavik: a junction is not a list.

[01:25] <slavik> Limbic_Region: then explain it :)

[01:26] <Limbic_Region> a junction is a more usuable name then quantum superposition

[01:26] <Limbic_Region> but that's what it used to be called

[01:26] <Limbic_Region> basically, it is the state of an operation where many different possible states can exist at once

[01:26] <Limbic_Region> as a single entity

[01:26] <slavik> quantum ... you lost me :(

[01:26] <Limbic_Region> until you ask for a value

[01:26] <Limbic_Region> where is a link to Damian's talk on Quantum::Superpositions anyway

[01:27] * Limbic_Region goes to ask google

[01:27] <slavik> Limbic_Region: all(<a b c>); what is the result of that?

[01:27] *** DemoPhreak left
[01:27] <Limbic_Region> slavik - it returns a junction

[01:27] <pmichaud> slavik: it's a Junction

[01:27] <Limbic_Region> a single scalar

[01:27] <Limbic_Region> you can do lots of neat things with it though

[01:27] <pmichaud> it's a Junction of type 'all' that has three states:  'a', 'b', and 'c'

[01:28] <Limbic_Region> you can ask it to pick a value at random from its possible eigenstates

[01:28] <slavik> eigenstates?

[01:28] <Limbic_Region> quantum superpositions again

[01:28] <Limbic_Region> all possible states

[01:28] <Limbic_Region> let me find the link

[01:28] <pmichaud> (pick a value at random) -- I think that's no .eigenstates.pick

[01:28] <pmichaud> s/no/now/

[01:28] <slavik> so, if I ask it for a value, what will it return?

[01:28] <pmichaud> slavik: depends on what kind of value you ask it for

[01:28] *** sri_kraih left
[01:28] <slavik> err

[01:29] * slavik is lost and confused

[01:29] <pmichaud> we tend to not say "ask for a value", we say "ask for a string" or "ask for a number" or ...

[01:29] <pmichaud> if I have:   any(<a b c>) ~ 'd'

[01:29] <TimToady> junctions are mostly for doing comparisons in boolean context

[01:29] <pmichaud> then the result is    any('ad', 'bd', 'cd')

[01:30] <slavik> pmichaud: if I want a single result, what will it give me then? like if I do: say any(<a b c>) ~ d;

[01:30] <TimToady> so any(<a b c>) ~ 'd' eq 'db' is True

[01:30] <Limbic_Region> TimToady - I have to agree that there should be a succinct but clear explanation of junctions in one of the synopses

[01:30] <pmichaud> slavik: a junction "is" a single result.  :-)

[01:30] <slavik> I see

[01:30] <Limbic_Region> I can't seem to find the link I was looking for

[01:31] <slavik> pmichaud: is this something like MMX type of thing?

[01:31] <pmichaud> I don't know "MMX"

[01:31] <slavik> pmichaud: pentium mmx?

[01:31] <pmichaud> okay, now I recall the acronym, but I'm a software guy.  :-

[01:31] <Limbic_Region> pmichaud - I thought any was defined to randomly find any true value, not all possible true values?

[01:31] <slavik> single instruction multiple data ... that type of thing?

[01:31] <Limbic_Region> and for all true values, you used all()

[01:31] <Limbic_Region> ?

[01:31] <pmichaud> l_r:  any in a boolean context returns true if any of its eigenstates is true

[01:32] <slavik> pmichaud: does the above make sense?

[01:32] <pmichaud> l_r:  all() in a boolean context returns true if all of its eigenstates are true

[01:32] <pmichaud> ?(any(<1 2 3>) == 2)      # true

[01:32] <lambdabot> Unknown command, try @list

[01:32] <slavik> also, all(<a b c>, <d e f>) will that be ad, ae, af, bd ... etc?

[01:32] <Limbic_Region> pmichaud - nevermind

[01:33] <pmichaud> ?(all(<1 2 3>) == 2)      # false

[01:33] <lambdabot> Unknown command, try @list

[01:33] <TimToady> slavik: we do use such ideas all the time in English: "If the value is 1 or 2 or 3"

[01:33] <pmichaud> slavik: all(<a b c>, <d e f>)  is   all('a', 'b', 'c', 'd', 'e', 'f')

[01:33] <pmichaud> (<a b c>, <d e f>)  is just a list.

[01:33] <slavik> ok

[01:33] <slavik> so all slurps all arguments

[01:34] <pmichaud> "slurps" is an odd word there.

[01:34] <slavik> I take it there won't be automatic parallelization?

[01:34] <pmichaud> it evaluates its arguments in list context.

[01:34] <pmichaud> (I guess that's "slurps")

[01:34] <pmichaud> slavik: there can be automatic parallelization, yes, in contexts where it's appropriate.

[01:35] <TimToady> there is no guarantee of serial processing. the computer can try to decide the fastest way to falsify it

[01:35] <slavik> pmichaud: the apocalypse stated that for all(@list) would automatically evaluate every element in the list in parallel

[01:35] <pmichaud> slavik: perhaps, but that's no longer the case.

[01:36] <slavik> pmichaud: hence my confusion :P

[01:36] <TimToady> but it's specifically for logical parallelism where you plan to throw away most of the results

[01:36] <pmichaud> slavik: junctions aren't meant to be parallelism operators -- that's not their purpose.

[01:36] <pmichaud> as TimToady says, they're for parallelism in logical contexts.

[01:36] <pmichaud> but not generic parallelism.

[01:36] <slavik> such as?

[01:37] <pmichaud> if all(<a b c d e f>) lt 'd' { ... }

[01:37] <TimToady> if you say all(@list) == 42 it's allowed to stop processing @list as soon as it sees something that is not 42

[01:37] <slavik> I see

[01:37] <pmichaud> TimToady: wouldn't one also have to be in boolean context?

[01:37] <TimToady> yes, I'm assuming that

[01:37] <pmichaud> okay.

[01:38] <TimToady> I personally thing that junctions are only for that

[01:38] <TimToady> *think

[01:38] <pmichaud> that works for me.

[01:38] <TimToady> if you want other forms of parallelism, we try to provide those too

[01:39] <TimToady> so attempts to make junctions do that are a bit misguided

[01:39] <TimToady> which is why we don't provide a lot of user-visible methods on juncitons

[01:39] <pmichaud> it'd probably be helpful to move the "parallelism" description of junctions out of S03 and move it to wherever we discuss parallelism in more detail.

[01:40] <TimToady> we don't want people trying to do set theory with them, for instance, except in boolean contexts

[01:40] <pmichaud> since S03 is really the first place "parallel" gets mentioned, I think lots of people latch onto that as being "oh, here's where I get automatic threading and concurrency"

[01:41] <Limbic_Region> does the hyper keyword give the ok to parallelize anything it wants to?

[01:41] <TimToady> the hyper keyword says you don't care what order the following list is calculated in

[01:42] <Limbic_Region> so hyper only applies to a list, not to a block acting on a list?

[01:42] <TimToady> it also asserts that you likely interested in all the values

[01:42] <TimToady> in the sense of eager()

[01:42] *** mgs joined
[01:42] <TimToady> hyper is a form of list context

[01:42] <TimToady> as is eager

[01:43] <TimToady> slice context is another modification of list context, but orthogonal to hyper/eager/lazy

[01:44] <Limbic_Region> let me ask a question a different way

[01:44] <Limbic_Region> future proofing the language - cause parallelism is all the rage

[01:44] <mgs> could someone point me to where i can find a good example of how to use libraries in perl? i have never used perl but i have a lot of experience in other languages .. just not sure where to begin :)

[01:44] <Limbic_Region> is there a way to say

[01:44] <Limbic_Region> for (@foo) { ... } and let that block be parallelized

[01:44] <Limbic_Region> ?

[01:45] <mgs> but i found an awesome graphviz extension that is a perl library and would love to use it

[01:45] <Limbic_Region> mgs - try #perl 

[01:45] <TimToady> hyper for does that

[01:45] <Limbic_Region> this channel is specifically for perl 6

[01:45] <TimToady> but that's becuase for knows it's in list context

[01:45] <Limbic_Region> TimToady - and hyper map and hyper grep play along too?

[01:45] <TimToady> hyper for is identical to hyper map, except for argument order

[01:45] <TimToady> yes

[01:46] <pmichaud> need a break... afk for a while.

[01:46] <TimToady> note, hyper says you don't care what order evaluation happens, but the list is still serialized

[01:46] <Limbic_Region> ok, so now we can call ourselves Erlang improved

[01:46] * Limbic_Region ducks

[01:46] <TimToady> well, Erlangy things will tend rather to be done with ==> and <==

[01:47] <mgs> Limbic_Region: i'm sorry, i found out about #perl6 by the #perl topic ;)

[01:47] <TimToady> an object pipe with signature matching on the end is very Erlangy

[01:48] *** mgs is now known as mgs`

[01:48] <Limbic_Region> TimToady - true.  I just wanted to ensure perl 6 was being future proofed for the parallelistic future

[01:49] <Limbic_Region> punting S17 to "it's an implementation detail" kinda scares me

[01:50] <TimToady> my job is just to make sure it's clear which constructs promise which parallel semantics, but there is no real guarantee of parallelism anywhere within any traditional von neumann computer, so that's about all we can do

[01:51] *** hercynium joined
[01:52] <TimToady> as long as the implementors know which constructs promise them how much leeway, then I think we'll be okay in the world of ∥

[01:53] <TimToady> for instance, ==> basically promises a clean thread fork

[01:53] * Limbic_Region listens

[01:53] <TimToady> where the definition of "clean" is still under negotiation

[01:53] <TimToady> it's very analogous to | in a shell

[01:54] * Limbic_Region only got one of the books on the list for Xmas which he read in a day and will now have to go buy the rest himself :-(

[01:54] <Limbic_Region> *shrug* - ok, ok, trying to pin you down on anything is like <any number of things - I would say something but then it would be wrong because there is no one way to pin you down>

[01:56] <Limbic_Region> did you have the shoulder surgery yet?

[01:56] <TimToady> not yet

[01:57] <TimToady> had to wait for holidays to pass, and still have to be cleared by my gp

[01:57] <TimToady> and that may depend on what my GI guy tells me about my capsule endo

[01:58] <TimToady> very strange to swallow a pill with a xenon flash bulb going off twice a second...

[01:58] <Limbic_Region> speaking of GI, I found a home remedy for an unpleasant GI problem that wasn't solved after 4 days using Immodium nor Pepto Bismol

[01:58] <Limbic_Region> 2 tbsp of apple cider vinegar diluted in about 6 oz of water

[01:59] <Limbic_Region> TimToady - very strange indeed, but given the alternatives ;-)

[02:00] *** Whiteknight left
[02:00] <slavik> you're going to shit a light bulb?

[02:00] <slavik> sorry, had to be said

[02:01] <Limbic_Region> if he's lucky

[02:01] <slavik> heh

[02:20] *** ilogger2 joined
[02:21] <slavik> yes

[02:25] *** hercynium joined
[02:39] <s1n> wow, 7612 passing tests

[02:54] *** brunoV joined
[02:59] *** [bjoern] joined
[03:00] <drbean_> sln: Read Jonathan Worthington's blogs on use.perl. I found this one explained MMD to me. http://use.perl.org/~JonathanWorthington/journal/36298

[03:02] <[bjoern]> Is there anything ontopic that would today help me determine how two structurally simple but very long perl5 regular expressions with lots of unicode code points are different, if at all?

[03:03] <[bjoern]> (in what they match)

[03:14] *** [bjoern] left
[03:24] <avar> lambdabot: tell [bjoern] perl -Mre=debug and compare the output

[03:29] *** alc joined
[03:51] *** kisu joined
[04:00] <pugs_svn> r24742 | azawawi++ | [S:H:P6] hilitep6 was doing --clean-html all the time. Release 0.02963 to CPAN

[04:02] *** elmex_ joined
[04:17] *** xinming_ joined
[04:17] *** elmex_ is now known as elmex

[04:21] <s1n> drbean_: that's a one, not an "el"

[05:52] *** hercynium left
[05:56] *** justatheory joined
[06:30] *** kisu_ joined
[06:31] *** justatheory left
[06:34] *** kisu left
[06:49] *** ejs joined
[06:51] *** kisu_ is now known as kisu

[07:15] *** DemoFreak joined
[07:18] *** DemoFreak left
[07:20] *** DemoFreak joined
[07:23] *** mberends joined
[07:31] *** ejs left
[07:37] *** DemoFreak left
[07:54] *** Amsuna[Busy] joined
[07:59] *** Amsuna[Busy] left
[08:51] *** iblechbot joined
[08:57] *** brunoV left
[08:58] *** DemoFreak joined
[09:53] *** pmurias joined
[10:12] *** kisu_ joined
[10:16] *** kisu left
[10:31] *** maerzhase joined
[10:46] *** maerzhase left
[10:53] *** ayrnieu joined
[11:01] *** vixey joined
[11:10] *** [particle]1 joined
[11:10] *** barney joined
[11:12] *** kisu joined
[11:14] *** kst joined
[11:14] *** Aisling joined
[11:14] *** alester joined
[11:14] *** smtms joined
[11:14] *** [particle] joined
[11:14] *** Jedai joined
[11:18] *** kisu_ left
[11:29] *** [particle] left
[11:36] *** masak joined
[11:47] <masak> wow, I'm really happy with the diversity of rakudobug reporters lately.

[11:51] <masak> perl6: say undef === undef

[11:51] <p6eval> pugs: OUTPUT«1␤»

[11:51] <p6eval> ..rakudo 34869: OUTPUT«0␤»

[11:51] <p6eval> ..elf 24742: OUTPUT«Undefined subroutine &GLOBAL::prefix__61 called at (eval 149) line 3.␤ at ./elf_f line 3861␤»

[11:51] <masak> "yes", "no", "don't ask me" :)

[11:52] <masak> any reason undef _shouldn't_ triple-equal itself?

[11:53] <masak> is it like NaN, perhaps? NaN always returns false in equality comparisons, even with itself.

[12:01] <Gothmog_> Nah.

[12:01] <masak> I agree.

[12:01] <masak> just trying on different hats here. :)

[12:02] <Gothmog_> There is a good reason for the NaN behaviour, but that doesn't apply for undef.

[12:03] <masak> right.

[12:04] *** DemoFreak left
[12:06] *** maerzhase joined
[12:09] <Gothmog_> Plus, it would be very counter-intuitive. NaN is not meant to be compared explicitly with a float, but undef is.

[12:09] <Gothmog_> That would be a real trap.

[12:10] <masak> aye

[12:24] *** pdcawley joined
[12:38] *** laye joined
[12:41] *** xinming joined
[12:42] *** pdcawley left
[12:47] *** xinming_ left
[12:50] *** xinming_ joined
[13:02] *** araujo joined
[13:09] *** fridim_ joined
[13:09] *** xinming left
[13:12] *** masak left
[13:13] *** laye left
[13:13] *** laye joined
[13:14] *** laye left
[13:14] *** laye joined
[13:14] *** laye left
[13:14] *** laye joined
[13:14] *** kisu_ joined
[13:19] *** kisu left
[13:31] *** xinming joined
[13:32] *** xinming left
[13:36] *** xinming joined
[13:37] *** xinming_ left
[13:42] *** laye left
[14:00] *** meppl joined
[14:11] *** nomas joined
[14:14] *** nomas left
[14:20] <rakudo_svn> r34876 | pmichaud++ | [rakudo]: spectest-progress.csv update: 264 files, 5911 passing, 0 failing

[14:31] *** xinming_ joined
[14:50] *** xinming left
[15:01] *** vixey left
[15:06] *** vixey joined
[15:07] <pmurias> perl6: say NaN === NaN

[15:07] <p6eval> elf 24742: OUTPUT«Can't call method "Str" on an undefined value at ./elf_f line 649.␤ at ./elf_f line 3861␤»

[15:07] <p6eval> ..rakudo 34878: OUTPUT«0␤»

[15:07] <p6eval> ..pugs: OUTPUT«␤»

[15:08] <pmurias> how can one check for NaN?

[15:35] <szabgab> pugs: unpack("A2", "hello").say

[15:35] <p6eval> pugs: OUTPUT«*** No such subroutine: "&unpack"␤    at /tmp/yd6ul5G3Bb line 1, column 1 - line 2, column 1␤»

[15:35] <szabgab> rakudo: unpack("A2", "hello").say

[15:35] <p6eval> rakudo 34883: OUTPUT«Could not find non-existent sub unpack␤current instr.: '_block14' pc 62 (EVAL_13:40)␤»

[15:36] <szabgab> but AFAIK unpack is in perl 6, so what shall I do now?

[15:45] *** masak joined
[15:47] *** fridim_ left
[15:58] *** xinming joined
[16:03] <masak> buubot: spack unpack

[16:03] <buubot> masak: S03-operators.pod:1 S06-routines.pod:1 S09-data.pod:3 S29-functions.pod:1

[16:04] <szabgab> masak: so what does this mean ? that unpack is mentione in those places?

[16:04] <masak> szabgab: aye.

[16:04] <masak> szabgab: 'spack' is 'speck-ack', i.e. ack/grep through the Specs.

[16:05] <szabgab> cute :-)

[16:05] <masak> it is. it was added by buu++ yesterday.

[16:05] <masak> only the S29 change seems relevant.

[16:06] <masak> ...and it's empty. :/

[16:06] <masak> hence "insufficently specced"

[16:06] <masak> szabgab: but if you want 'pack'/'unpack', I'm wiling to work with you on that.

[16:07] <szabgab> I have started to go through the Perl 5 Cookbook and reimplement it

[16:07] <masak> szabgab: cool!

[16:07] <szabgab> the first example used unpack()

[16:08] <masak> do you commit your work somewhere public?

[16:08] <szabgab> yes and it is on CPAN Per6::Cookbook

[16:08] <masak> szabgab: URL to the first example?

[16:08] <szabgab> Perl6::Cookbook

[16:08] <szabgab> http://szabgab.com/blog/2009/01/1230804190.html

[16:08] <masak> thanks

[16:09] <szabgab> oh, it does not have the one with unpack yet

[16:09] <szabgab> here is the cpan version: http://search.cpan.org/dist/Perl6-Cookbook/

[16:09] <masak> aye, already tracked that one down.

[16:10] <szabgab> and this is the svn: http://svn1.hostlocal.com/szabgab/trunk/Perl6-Cookbook/eg/01_Strings/

[16:10] <szabgab> where you have the unpack example already

[16:10] <masak> szabgab: you could help by filling in S29, or by reviewing the tests in the Pugs repo for unpack

[16:10] <szabgab> but it is a very basic version of unpack, onlu using A and x

[16:11] <masak> szabgab: I think I can get that working today.

[16:11] <szabgab> s/reviewing/writing/

[16:11] *** xinming_ left
[16:11] <szabgab> as there is no test yet

[16:11] <masak> szabgab: possibly.

[16:11] <szabgab> where shall I pu the tests

[16:12] <masak> somewhere in t/ in the Pugs repo.

[16:12] <masak> preferably t/spec/S29-*

[16:12] <szabgab> pugs/t/spec/S29-str/

[16:12] <masak> sounds reasonable.

[16:12] <masak> szabgab++

[16:13] * szabgab grabs a sandwitch and goes to write perl 6 tests again 

[16:13] <masak> tests++

[16:14] <masak> I should add that I'm not really here right now, but I will be in increasing degrees as the day progresses.

[16:15] <masak> it's been a while since I made a significant contribution to Rakudo, but this one I'll be happy to help with.

[16:17] *** meppl left
[16:20] <szabgab> masak++

[16:21] <masak> as in, it's about at the level of PIR that I'm comfortable with :)

[16:21] *** azawawi_ joined
[16:27] <pugs_svn> r24743 | szabgab++ | basic unpack() test

[16:28] <masak> szabgab: looks good. I'll look at it in a couple of hours.

[16:29] <masak> @ask TimToady is there any reason to assume that C<pack>/C<unpack> will not be identical in Perl 6 as in Perl 5?

[16:29] <lambdabot> Consider it noted.

[16:30] <masak> s/as /to those /

[16:36] <pmichaud> @ask TimToady  class Dog { is Mammal; does Pet; ... } (from S12) parses 'is' as a listop -- is this correct?

[16:36] <lambdabot> Consider it noted.

[16:38] *** eric256 joined
[16:39] <masak> eric256: greetings.

[16:40] <eric256> morning

[16:40] <moritz_> perl6: say NaN ~~ NaN

[16:40] <p6eval> elf 24743: OUTPUT«Can't call method "Str" on an undefined value at ./elf_f line 649.␤ at ./elf_f line 3861␤»

[16:40] <p6eval> ..pugs: OUTPUT«1␤»

[16:40] <p6eval> ..rakudo 34888: OUTPUT«0␤»

[16:40] <moritz_> hi there

[16:40] <masak> moritz_: hi!

[16:40] <moritz_> masak: want to report as a bug?

[16:40] <masak> moritz_: no.

[16:40] <masak> moritz_: I think Rakudo is right.

[16:41] <moritz_> masak: care to elaborate?

[16:41] <masak> moritz_: well,

[16:41] <moritz_> perl6: say NaN == NaN

[16:41] <p6eval> rakudo 34888: OUTPUT«0␤»

[16:41] <p6eval> ..elf 24743, pugs: OUTPUT«␤»

[16:41] <masak> two NaN's can very well be different. there is not but one NaN.

[16:41] <masak> that's part of the theory behind them.

[16:41] <moritz_> masak: ~~ doesn't test equality

[16:42] <eric256> then how do you do $num ~~ NaN?

[16:42] <eric256> say (NaN === NaN)

[16:42] <masak> moritz_: seems to me it does test equality in increasing amounts lately.

[16:42] <eric256> rakudo: NaN === NaN

[16:42] *** rindolf joined
[16:42] <p6eval> rakudo 34888: RESULT«Bool::False»

[16:42] <masak> moritz_: but you have a point.

[16:42] <moritz_> I think that $thing ~~ NaN should answer the questions "is $thing a NaN`?"...

[16:42] * masak reports rakudobug

[16:42] <moritz_> just like $thing ~~ undef really desugars to !$thing.defined

[16:43] <eric256> rakudo: my $nan = NaN; say $nan ~~ NaN;

[16:43] <p6eval> rakudo 34888: OUTPUT«0␤»

[16:43] <azawawi_> moritz_: hi there

[16:43] <moritz_> masak: I also put .perl in my local S29 copy, will commit on Thursday 8th, when I have good internet access again

[16:43] <moritz_> azawawi_: hi

[16:43] <moritz_> have to go now again (but will backlog, if you have more comments or questions)

[16:43] <moritz_> cheers

[16:44] <masak> moritz_: goodie. in the meantime, I will map what needs be done with S29. see my latest blog post.

[16:44] *** GitHub96 joined
[16:44] <GitHub96> perl6-examples: 3Eric Hodges 07master0 SHA1-367ec9d

[16:44] <GitHub96> Adding WSG Advanced category

[16:44] <GitHub96> http://is.gd/eu3a

[16:44] *** GitHub96 left
[16:44] <eric256> i'm gitting used to this git thing. starting to wish rakudo used it. would be easy to fork and patch etc...thought thats probably easy in SVN ifyou know what you are doing too hehe

[16:44] <vixey> I really hate that github bot

[16:44] <masak> moritz_: http://use.perl.org/~masak/journal/38212

[16:45] <masak> vixey: /ignore it then.

[16:45] <eric256> vixey: its not my favorite either. i would prefer a single line, but till i can make a bot in perl6 it will have to do

[16:45] <vixey> yeah I would have to hack my client to allow me to ignore join/parts of one class of user

[16:45] <eric256> masak: you think i should store the problems from WSG? in case M$ decides to take them down?

[16:46] <masak> eric256: find out what licence they are under.

[16:46] <masak> in general, one is not allowed to copy text indiscriminately.

[16:47] *** alc left
[16:47] <eric256> rakudo: say (1..3) X (1..3) X (1..3)

[16:47] <p6eval> rakudo 34889: OUTPUT«111112113121122123131132133211212213221222223231232233311312313321322323331332333␤»

[16:48] <masak> pretty.

[16:48] <eric256> lol

[16:48] <eric256> as my licensing csar could you check? i'll do the copying if you could make sure i'm not going to jail lmao http://www.microsoft.com/technet/scriptcenter/funzone/games/games08/aevent1.mspx

[16:48] <eric256> i don't see any licenses

[16:49] <masak> in the case of no license, I think you'd better write and ask.

[16:50] <masak> eric256: http://www.microsoft.com/info/cpyright.mspx#E1E

[16:50] <eric256> perl6++ rakudo++ :)

[16:50] <eric256> rakudo: (<a b c> X~X <d e f>).perl

[16:50] <p6eval> rakudo 34889: RESULT«"[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]"»

[16:52] <eric256> rakudo: (<> X~X <d e f>).perl

[16:52] <p6eval> rakudo 34889: RESULT«"[]"»

[16:52] <eric256> i was afraid of that ;)

[16:52] <eric256> rakudo: ((' ') X~X <d e f>).perl

[16:52] <p6eval> rakudo 34889: RESULT«"[\" d\", \" e\", \" f\"]"»

[16:53] <masak> eric256: write to them and ask nicely. they might surprise you with a lenient policy.

[16:53] <eric256> okay

[16:53] <eric256> can't hurt

[16:53] <masak> exactly.

[16:57] <eric256> rakudo: my %test = (1 => <a b c>); my @word = <e f g>; (%test{1} X~X @word).perl.say

[16:57] <p6eval> rakudo 34889: OUTPUT«["a b ce", "a b cf", "a b cg"]␤»

[16:57] <eric256> it appears to be stringifying <a b c> before crossing it..any idea what i did wrong?

[16:58] <eric256> rakudo: my %test = (1 => <a b c>); my @word = <e f g>; %test{1}.perl.say

[16:58] <p6eval> rakudo 34889: OUTPUT«["a", "b", "c"]␤»

[17:03] <masak> rakudo: my %test = (1 => <a b c>); %test{1}.WHAT.say

[17:03] <p6eval> rakudo 34889: OUTPUT«Array␤»

[17:03] <masak> rakudo: my %test = (1 => <a b c>); (%test{1} X~X <e f g>).perl.say

[17:03] <p6eval> rakudo 34889: OUTPUT«./parrot: error while loading shared libraries: libparrot.so.0.8.2: cannot open shared object file: No such file or directory␤»

[17:04] <masak> lots of kudos to the first person who makes Rakudo build _in the background_.

[17:04] <masak> can't be that hard to save the executable from destruction...

[17:04] <eric256> couldn't you just copy the executable to a new location, run from there. then rebuild in the original location andocpy when done?

[17:05] <masak> eric256: I think so, yes.

[17:05] <masak> but I haven't tried to solve the problem myself, so I don't know.

[17:05] <masak> I'm just miffed when it occurs.

[17:07] <masak> rakudo: my %test = (1 => <a b c>); (%test{1} X~X <e f g>).perl.say

[17:07] <p6eval> rakudo 34889: OUTPUT«["a b ce", "a b cf", "a b cg"]␤»

[17:07] <masak> eric256: I'd say that's a bug. care to submit to rakudobug?

[17:08] * masak has begun to try to delegate of late

[17:08] <masak> rakudo: use Test; ok(1)

[17:08] <p6eval> rakudo 34889: OUTPUT«Can't find ./Test in @INC␤current instr.: 'die' pc 14812 (src/builtins/control.pir:204)␤»

[17:09] <masak> seems Rakudo is not run from its built location anyway... so I don't see a problem with copying it.

[17:09] <eric256> does the bot live in the pugs repo?

[17:09] <eric256> is it self updating?

[17:10] <masak> I think moritz_ is the right person to ask such questions.

[17:10] <masak> eric256: it is "self updating", yes.

[17:10] <masak> at least Rakudo is.

[17:11] <eric256> i meant if i update the bots source in the repo will the bot update its files and restart ;)

[17:11] <masak> eric256: oh. no, I don't think so.

[17:11] <eric256> hehe i just sent several thousands items into an any statement....hmmm possibly not a good idea at current ;(

[17:14] <masak> what Rakudo needs are people who push its limits.

[17:18] <eric256> switched to a double for loop....still comparing to many options i think ;) one list of 3^7 comparing agianst another that is over 30k 

[17:18] <eric256> rakudo: say 3^7;

[17:18] <p6eval> rakudo 34893: OUTPUT«Junction<0xb6046250>␤»

[17:18] <eric256> rakudo: say 3^^7;

[17:18] <p6eval> rakudo 34893: OUTPUT«␤»

[17:18] <eric256> rakudo: say 3**7;

[17:18] <masak> rakudo: say 3 ** 7

[17:18] <p6eval> rakudo 34893: OUTPUT«2187␤»

[17:18] <p6eval> rakudo 34893: OUTPUT«2187␤»

[17:18] <eric256> i was getting there ;)

[17:19] <masak> seemingly :)

[17:19] <szabgab> masak: ping me if you hear a response from TimToady regarding the unpack() so I can add more tests if its the same as in p5

[17:19] <masak> szabgab: a'ight.

[17:19] * masak has a vague recollection he's seen pack/unpack documentation for Perl 6 somewhere

[17:19] <masak> but perhaps that was just a dream.

[17:20] <szabgab> what was dream?

[17:20] <masak> the vision of pack/unpack documentation for Perl 6.

[17:20] <masak> (maybe)

[17:22] <eric256> yea paired the comparisons down to 2187 XeqX 3805

[17:22] <eric256> still probably too many

[17:22] <masak> eric256: are you sure XeqX is what you want?

[17:22] *** jferrero joined
[17:23] <szabgab> well we don't need documentation now if it is the same as in perl 5

[17:23] <eric256> nah thats just pseudo code, its realy nested loops with eq in ther cause i need the value not just the true/false

[17:23] *** kidd joined
[17:23] <masak> szabgab: no, just tests.

[17:26] <eric256> maybe i'll try loading the dictionary into a hash... my %dictionary = ( @words X 1 ); ?? i wonder if that would work

[17:26] <eric256> rakudo: my @words = <a b c>; my %dictionary = (@words X 1); %dictionary.perl.say;

[17:26] <p6eval> rakudo 34893: OUTPUT«{"a" => 1, "b" => 1, "c" => 1}␤»

[17:26] <eric256> perl6++ ;)

[17:28] <masak> eric256: sorry, did you submit the rakudobug about the %hash{1} X~X @array thing?

[17:30] <eric256> masak: nope. i leave professional bug submission to you

[17:30] <masak> eric256: ok, then I'm glad I checked. :)

[17:30] * masak submits rakudobug

[17:36] *** GitHub191 joined
[17:36] <GitHub191> perl6-examples: 3Eric Hodges 07master0 SHA1-e1d07db

[17:36] <GitHub191> Adding answer to WSG Advanced 2008

[17:36] <GitHub191> http://is.gd/euhi

[17:36] *** GitHub191 left
[17:41] * eric256 's daughter just inhaled all of his breakfast ;)

[17:49] *** aindilis` joined
[18:08] *** ruoso joined
[18:09] <eric256> masak: is there a way to sort a hash? i want to get the key with the highest score? array of hashes maybe or array of pairs?

[18:10] <masak> rakudo: my %h = 1 => 'a', 2 => 'c'; say %h.keys.sort({ $^b <=> $^a }).first

[18:10] <p6eval> rakudo 34894: OUTPUT«No applicable methods.␤␤current instr.: '_block14' pc 159 (EVAL_13:58)␤»

[18:10] <masak> hrm.

[18:10] <masak> rakudo: my %h = 1 => 'a', 2 => 'c'; say %h.keys;

[18:10] <p6eval> rakudo 34894: OUTPUT«12␤»

[18:10] <masak> rakudo: my %h = 1 => 'a', 2 => 'c'; say %h.keys.sort;

[18:10] <p6eval> rakudo 34894: OUTPUT«12␤»

[18:10] <szabgab> masak: I have another project for you: 4 parameter substr()

[18:10] <masak> rakudo: my %h = 1 => 'a', 2 => 'c'; say %h.keys.sort.reverse;

[18:10] <p6eval> rakudo 34894: OUTPUT«21␤»

[18:10] <szabgab> it has spec tests but not implemented in rakudo yet

[18:11] <masak> rakudo: my %h = 1 => 'a', 2 => 'c'; say %h.keys.sort.reverse[0];

[18:11] <p6eval> rakudo 34894: OUTPUT«2␤»

[18:11] <masak> eric256: there you go.

[18:11] <masak> szabgab: oh? sounds a bit un-Perl6-like.

[18:11] <eric256> masak: ??????

[18:11] <eric256> lol

[18:11] <masak> szabgab: we usually do .= nowadays.

[18:12] <masak> eric256: ¿¿¿¿¿¿

[18:12] <szabgab> whatever, I'll keep an eye on it 

[18:12] <masak> szabgab: is there proof that 4-args substr() is still in Perl 6? spec or tests?

[18:13] <eric256> rakudo: my %test = ( 'eric' => 5, 'masak' => 2); %test.values.sort.reverse[0].say;

[18:13] <p6eval> rakudo 34894: OUTPUT«5␤»

[18:13] <masak> szabgab: meantime, why don't you implement your own multi in your code which does just that? it should be possible.

[18:13] <eric256> got the high score...but i need the key with the highest score

[18:13] <masak> eric256: ah.

[18:14] <szabgab> masak: I don't have code :-) I am just typing in these stupid examples

[18:14] <masak> rakudo: my %test = 'eric' => 5, 'masak' => 2; say %test.pairs.sort( { $^b.value <=> $^a.value } )[0]

[18:14] <p6eval> rakudo 34894: OUTPUT«eric        5␤»

[18:15] <eric256> magic pairs++

[18:15] <eric256> thanks

[18:15] <masak> szabgab: but you know you don't _need_ four-args substr. it's just a convenience, even in Perl 5.

[18:15] <masak> eric256: glad to be of assistance. :)

[18:15] <eric256> whats 4-args substr do?

[18:15] <szabgab> eric256: replace the selected part by the 4th arg

[18:15] <masak> eric256: see `perldoc -f substr`

[18:16] <pmurias> ruoso: what would be a good demo of the p5 integration?

[18:16] <eric256> use CGI;

[18:16] <masak> pmurias: DBI, CGI.

[18:20] *** Psyche^ joined
[18:21] *** dwhipp joined
[18:23] *** aindilis` left
[18:23] *** GitHub199 joined
[18:23] <GitHub199> perl6-examples: 3Eric Hodges 07master0 SHA1-3c65243

[18:23] <GitHub199> [WSG] Adding challenge 2

[18:23] <GitHub199> http://is.gd/eupi

[18:23] *** GitHub199 left
[18:25] <eric256> perl6 rocks! lol. figuring out skaters scores, sorting and printing all takes very very little space

[18:25] <eric256> amazing

[18:25] <masak> aye.

[18:28] *** Psyche^ is now known as Patterner

[18:30] *** DemoFreak joined
[18:31] *** jferrero left
[18:32] <eric256> crap i added a .swp file to the repo by accident. lmao

[18:32] <masak> eric256: locally?

[18:32] <masak> or did you push it to github?

[18:33] <ruoso> pmurias, hi... btw the SDL thing is just awesome

[18:33] <ruoso> have you seen how std parses

[18:33] <ruoso> std: use p5:DBI;

[18:33] <p6eval> std 24743: OUTPUT«00:05 71m␤»

[18:35] <ruoso> if it parses it somewhat in an easy way...

[18:35] <ruoso> you could alias the used package to the lexical scope as a type

[18:35] <ruoso> and just make

[18:35] *** ejs joined
[18:36] <ruoso> use p5:DBI; my $dbh = DBI.connect($dsn);

[18:36] <eric256> pushed it to github

[18:37] <masak> eric256: ok. just 'git rm' it I guess.

[18:37] <ruoso> eric256, if you remove the file and re-push it fix it... no big deal

[18:38] <masak> 'xactly.

[18:38] <eric256> oddly i don't see it localy, just on github and a git pull doesn't git it...

[18:39] <masak> eric256: it was probably generated by your editor, and removed when you exited it.

[18:39] <masak> eric256: also, you probably shouldn't 'git add' files the way you did when you added the .swp file. :)

[18:40] <eric256> masak:  yea i was adding the folder

[18:40] <eric256> and i guess it added all the files in it

[18:40] <pugs_svn> r24744 | pmurias++ | [smop] SMOP__Objects are represented as tied scalars in p5 land so they FETCH and STORE when necessary

[18:41] <eric256> http://github.com/eric256/perl6-examples/tree/master/wsg/advanced-2008/event002-eric256.pl thats pretty sweet. and actualy i think i could shorten it by a couple lines ;)

[18:42] <dwhipp> promised Patrick a writeup: http://dave.whipp.name/sw/perl6 (lots of code for the scripting games; plus Connect4 game)

[18:42] <masak> eric256: yes, it adds all files, recursively.

[18:42] <masak> dwhipp++

[18:42] <pmurias> ruoso: hi

[18:43] <masak> dwhipp: I looked at the Connect4 game earlier today; looks great.

[18:44] <masak> eric256: indentation looks strange on lines 7 and 8-10.

[18:44] <pmurias> ruoso: shouldn't it be use DBI:from<perl5>?

[18:44] <masak> eric256: other than that, cool code.

[18:45] <TimToady> yes, just because STD parses something doesn't mean it would interpret the bits like you would, if it did interpret the bits, which it mostl doesn't :)

[18:45] <masak> eric256: may I suggest you use .fmt for the last three lines?

[18:45] <eric256> wow dwhipp thats a heck of a write up!

[18:45] <eric256> masak: yea or you could submit your own ;) lol

[18:46] <masak> eric256: sure.

[18:46] <masak> but it would be a very similar variant of yours.

[18:46] <eric256> ohh the editor ate some indents...odd

[18:47] <TimToady> masak: we could probably use a p5-identical pack/unpack, but long term we'll probably be de-emphasizing the template language as something that a user would deal with directly

[18:47] <eric256> off to play some rockband2 with the wife ;)

[18:48] <eric256> dwhipp

[18:48] <eric256> dwhipp++

[18:48] <TimToady> rather, we'd use compact classes to represent layout, and ask the class for the template that will unpack it

[18:48] <TimToady> or something like that

[18:48] <masak> TimToady: ok.

[18:48] <masak> szabgab: ping

[18:48] <TimToady> but an identical pack/unpack will at least be useful for p5 migration

[18:49] <TimToady> and precompiled templates can dispatch via a different type than Str

[18:49] <masak> I'll try to implement at least some of it tonight.

[18:50] <masak> @tell szabgab see http://irclog.perlgeek.de/perl6/2009-01-03#i_803031 for TimToady's answer.

[18:50] <lambdabot> Consider it noted.

[18:50] <TimToady> or we'll just have a direct serialization interface (.pack/.unpack?) for the class

[18:50] *** rindolf left
[18:51] <masak> I'll start by providing the functions.

[18:51] <masak> I'm in a JFDI mood today.

[18:51] <TimToady> I don't see any problem with that

[18:51] <TimToady> and it's not something we have to "get right first"

[18:52] <szabgab> masak: pong

[18:52] <lambdabot> szabgab: You have 1 new message. '/msg lambdabot @messages' to read it.

[18:52] <masak> szabgab: well, see above discussion.

[18:54] <szabgab> masak: I'll try to write some tests for you

[18:54] <masak> szabgab: and I'll try to implement them for you. :)

[18:56] <TimToady> on 4-arg substr, I haven't made up my mind yet

[18:57] <TimToady> it's not clear to what extent P6 strings are mutable outside of a variable containing a string

[18:57] <TimToady> so it may be some OO notation is better for mutating a string variable in place

[18:57] <pugs_svn> r24745 | pmurias++ | [smop]

[18:57] <pugs_svn> r24745 | pmurias++ | SMOP::Object::DESTROY calls SMOP_RELEASE

[18:57] <masak> TimToady: postcircumfix:<[ ]> ?

[18:58] * masak hides

[18:58] <szabgab> TimToady: it also freaks out C programmers :-)

[18:58] <TimToady> we do already allow .[] on Buf types

[18:59] <masak> we do? does that include Str?

[18:59] <TimToady> Str is not a Buf type

[18:59] <masak> ok.

[18:59] <masak> can I cast it to a Buf easily?

[18:59] <TimToady> otoh, NFG is not variable-width in terms of graphemes, so maybe we could allow .[] there too

[19:00] <masak> NFG?

[19:00] <TimToady> masak: you can cast as long as it's perfectly clear what hte mapping is supposed to be

[19:00] <TimToady> Normalization Form Grapheme

[19:00] <masak> I guess I'd specify the mapping through pragmas or something?

[19:00] <TimToady> not something you'll find in the Unicode docs

[19:01] <TimToady> well, a pragma could set up defaults, but in general you'd want to have an interface much like Encode provides

[19:01] <masak> oh, I think I know what an NFG is, then.

[19:02] <TimToady> NFG is basically a local mapping of multiple codepoints into a single grapheme number so it can be stored in a single array element

[19:03] <TimToady> we assign them temporary negative numbers so as not to confuse them with Unicode codepoints

[19:03] <masak> this all sounds familiar.

[19:03] <masak> I think the specs mention it somewhere.

[19:04] <azawawi_> TimToady: Padre::Plugin::Perl6 now uses STD in a separate process for faster typing while highlighting/syntax checking...

[19:04] * masak moves from one location to another

[19:04] *** masak left
[19:06] *** azawawi_ is now known as azawawi

[19:06] <TimToady> speaking of syntax highlighting, I noticed perl6.vim seems to be making my vim slower and slower... :/

[19:07] <szabgab> regarding tests, can I just copy the test file for pack() from perl 5 and the change it to fit the perl6 syntax or is there some copyright/legal issue there?

[19:08] <eric256> "Hello"[1] = 'a'; 

[19:08] <TimToady> considering I own the overall copyright on Perl 5, unless the individual file says otherwise, I'd say there's not problem

[19:09] <szabgab> TimToady: the file does not have any special copyright statement

[19:10] <TimToady> then feel free

[19:10] <azawawi> TimToady: im looking at .panic and .obs; could we add something to identify a warning/error from STD output?

[19:10] <TimToady> you have officially "made other arrangements with the copyright holder" :)

[19:10] <dwhipp> eric256: indexing into a string feels dangerous -- nice to have, but...

[19:11] <dwhipp> <aa bb>[0]  --> "aa"

[19:11] <dwhipp> <aa>[0] --> "a" 

[19:12] <szabgab> now the only 2 problems are 

[19:12] <dwhipp> endcases like taht are petri-dishes for bugs

[19:12] <szabgab> 1) .t files are still considered perl5 files by Padre

[19:12] <eric256> umm wouldn't <aa>[0] still be 'aa'? its a list/array isn't it?

[19:12] <eric256> rakudo: (<aa>).perl.say

[19:12] <p6eval> rakudo 34895: OUTPUT«"aa"␤»

[19:12] <eric256> rakudo: <aa>.perl.say

[19:12] <p6eval> rakudo 34895: OUTPUT«"aa"␤»

[19:13] <szabgab> 2) even if I manage to convince it otherwise our syntax highligher will take ages to parse this 2000 lines long file

[19:13] <eric256> rakudo: <aa>.WHAT.say

[19:13] <dwhipp> I had that discussion the other day (even filed a bug)

[19:13] <p6eval> rakudo 34895: OUTPUT«Str␤»

[19:13] <eric256> rakudo: <aa aa>.WHAT.say

[19:13] <p6eval> rakudo 34895: OUTPUT«List␤»

[19:13] <eric256> okay thats surprising

[19:13] <dwhipp> I am told that <aa> returns a scalar

[19:14] <TimToady> it pretty much has to, since it's short for ('aa') or {'aa'} when used as a subscript

[19:14] <eric256> that means that not having a space in there is significant.  thats a bit scary actualy

[19:15] <eric256> rakudo: ('aa').WHAT.perl

[19:15] <p6eval> rakudo 34895: RESULT«"Str"»

[19:15] <eric256> rakudo: (<aa>).WHAT.perl

[19:15] <p6eval> rakudo 34895: RESULT«"Str"»

[19:16] <eric256> rakudo: (<aa b>).WHAT.say; ("aa","a").WHAT.say;

[19:16] <p6eval> rakudo 34895: OUTPUT«List␤List␤»

[19:16] <eric256> rakudo: (<aa>).WHAT.say; ("aa").WHAT.say;

[19:16] <p6eval> rakudo 34895: OUTPUT«Str␤Str␤»

[19:17] <eric256> guess that makes it consistent ;)

[19:17] <TimToady> I think it's relatively harmless unless you get into the habit of using <> where you should use ''

[19:18] *** rindolf joined
[19:18] <TimToady> for bare terms, pragmatically you only ever use < a b c > for multiple items

[19:18] <TimToady> and with .<> subscripts, it mostly doesn't matter

[19:18] <eric256> yea. mostly i think i'm just still working on being able to think in p5 and p6 at the same time ;)

[19:19] <eric256> i used < > for a single item list earlier...which obviously wasn't working as expected

[19:19] <TimToady> some of us do go back and forth, and there will always be some recurring brainos because of that  :)

[19:20] <eric256> [+] has already proven very usefull and so has X~X

[19:24] *** rindolf left
[19:24] *** rindolf joined
[19:27] <azawawi> http://padre.perlide.org/wiki/Screenshots

[19:30] <ruoso> pmurias, anyway... is the parsing of "use DBI:from<perl5> complicated?

[19:31] <pmurias> looking...

[19:31] *** ejs left
[19:31] * ruoso don't know exactly where that p5:DBI came from

[19:32] *** masak joined
[19:32] <ruoso> TimToady, is there any change routine_declarator:coro to get into STD?

[19:33] <pmurias> ruoso: not very

[19:33] <ruoso> pmurias, is used parsed as a function call? or as a keyword?  

[19:34] * ruoso .oO( by keyword I mean whatever "self" is)

[19:34] <pmurias> it's a statement_control

[19:34] <ruoso> hmm... even more explicit

[19:34] <ruoso> cool

[19:34] <pmurias> i use perl mildew --debug to see the VAST

[19:39] <pmurias> ruoso: you meant use by "used"?

[19:44] <ruoso> yes

[19:48] <ruoso> pmurias, I think you can implement use DBI:from<perl5> without any problems... the parsing looks like something that is meant for the compiler to understand directly

[19:48] <ruoso> unlike "is export"

[19:56] *** ejs joined
[19:57] *** maerzhase left
[19:59] <ruoso> I think it'd be nice to have a package declarator for DelegatedPrototypeHOW

[20:01] * ruoso goes implement attributes in knowhows

[20:02] * ruoso realizes s1p_pureprototypehow is not a .ri yet... *sigh*

[20:04] *** ejs left
[20:07] * ruoso finishes converting pureprototypehow to an RI

[20:07] *** c9s joined
[20:08] * ruoso strangely notices that make test in smop doesn't raise any memory leak

[20:10] <pmurias> i fixed them all some time ago, but we have lots of leaks in mildew/t to compensate

[20:10] <ruoso> heh...

[20:11] <ruoso> but I've just understood why pureprototypehow wasn't a .ri yet

[20:11] <ruoso> I think I'll add a %singleton tag to .ri

[20:12] <pmurias> what would it do?

[20:12] <ruoso> create an empty SMOP__Object* that have the RI as its responder interface

[20:12] <ruoso> without the need to call new

[20:13] <ruoso> as in %prototype

[20:13] <pmurias> we could create a single object with .new and put it in the lexical prelude

[20:14] <ruoso> seems too complicated...

[20:14] <ruoso> specially because in this case it is indeed a singleton

[20:15] <ruoso> there's no point in creating a new instance of PurePrototypeHOW

[20:15] <pmurias> ok

[20:16] *** brunoV joined
[20:22] <pmurias> &

[20:25] <pugs_svn> r24746 | masak++ | [t/spec/S29-str/unpack.t] removed mismatched right paren

[20:30] *** azawawi_ joined
[20:34] <pugs_svn> r24747 | szabgab++ | add pack/unpack tests from perl 5 source code

[20:35] <pugs_svn> r24748 | ruoso++ | [smop] .ri files now can declare a %singleton

[20:35] <pugs_svn> r24748 | ruoso++ | [smop] pureprototypehow is now a .ri

[20:37] *** bsdperl joined
[20:37] <masak> szbalint: I'm about halfway towards implementing the first three tests you made. will refrain from svn-upping until after I'm done passing them, for morale reasons. :)

[20:37] *** rindolf left
[20:37] <masak> szbalint: oops, should be szabgab. sorry.

[20:38] <szabgab> masak: yes

[20:38] <szabgab> the hungarian notation is confusing :-)

[20:39] <masak> :)

[20:45] *** xinming_ joined
[20:48] *** azawawi left
[20:55] <szabgab> rakudo: split(/b/, "abc").join(';').say;

[20:55] <p6eval> rakudo 34895: OUTPUT«a;c␤»

[20:55] <szabgab> rakudo: split(//, "abc").join(';').say;

[20:55] <p6eval> rakudo 34895: OUTPUT«Statement not terminated properly at line 1, near "(//, \"abc\""␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[20:56] <masak> szabgab: // is disallowed in Perl 6

[20:57] <szabgab> masak: ah, so how do I split character by character?

[20:57] <masak> rakudo say split('', 'abc)

[20:57] <masak> rakudo say split('', 'abc').perl

[20:57] <masak> rakudo: say split('', 'abc').perl

[20:57] <p6eval> rakudo 34895: OUTPUT«["a", "b", "c"]␤»

[20:57] <masak> er.

[20:57] <szabgab> rakudo: split('', "abc").join(';').say;

[20:57] <p6eval> rakudo 34895: OUTPUT«a;b;c␤»

[20:58] <szabgab> thanks

[20:58] *** xinming left
[21:00] *** kisu_ left
[21:09] <masak> szabgab: your original tests two and three contain a logical error. in Perl 6 (as in Perl 5), a list within a list is "flattened" out into the outer list.

[21:09] <masak> hence, the arglists to is_deeply actually contain four arguments each, not three.

[21:12] <masak> (as was intended)

[21:16] *** Khisanth joined
[21:18] *** kisu joined
[21:18] <masak> anyway, I have PIR code here that passes what you meant.

[21:24] * ruoso wishes "has $.a" could be treated as a macro by STD

[21:28] <szabgab> masak++

[21:30] <rakudo_svn> r34898 | masak++ | [rakudo] added C<unpack> implementation that passes szabgab's three original

[21:30] <rakudo_svn> r34898 | masak++ | tests, and very nearly nothing more

[21:30] <rakudo_svn> r34899 | masak++ | [rakudo] removed obsoleted comment in any-str.pir

[21:32] <masak> szabgab: do you think you could fix unpack.t?

[21:32] <masak> szabgab: re the new pack.t -- wow!

[21:32] <szabgab> I thought you already fixed it, 

[21:33] <masak> szabgab: no, I just pointed it out.

[21:33] <masak> szabgab: on the plus side, if you fix it and then build Rakudo, the tests will pass. :)

[21:33] <szabgab> then I try to do it

[21:33] <masak> it's just a matter of replacing the () with []

[21:33] <masak> I could have done it, but I wanted you to learn from your own mistakes :P

[21:33] <szabgab> oh is that the same in p6 ?

[21:34] <masak> szabgab: sure!

[21:34] <szabgab> oh thanks :-)

[21:34] <masak> as I said above.

[21:34] <masak> "parentheses are only for grouping".

[21:36] *** barney left
[21:36] <masak> szabgab: re pack.t -- it'll take some changes to that file for Rakudo to accept it. it's a large file, and it's in Perl 5, so "some changes" may be an understatement.

[21:38] <szabgab> sure but if I understant the =begin pod should take car of that for now

[21:38] <szabgab> or am I mistaken ?

[21:38] <masak> szabgab: ah, didn't see that one.

[21:38] <masak> no, that should work.

[21:38] <masak> szabgab++

[21:38] <szabgab> then once I learn more about it I can slowly move things out 

[21:38] <szabgab> or someone else will do it

[21:39] <masak> I might help.

[21:39] <masak> still, Rakudo chokes on it already.

[21:40] <masak> ah.

[21:40] <masak> the \001 escape string on line 8 has been deprecated.

[21:40] <masak> should be \o001 instead, it seems.

[21:41] <masak> I'll try and change that and see if it helps.

[21:41] <szabgab> once I compiled rakudo, how can I run a test script ?

[21:41] <szabgab> simple running it cannot fine Test in @INC

[21:41] <masak> szabgab: you have to have Test.pm in the current directory.

[21:42] <szabgab> and where is Test.pm ?

[21:42] <masak> it's in languages/perl6

[21:42] <masak> ok, now it compiles -- committing.

[21:43] <pugs_svn> r24749 | masak++ | [t/spec/S29-str/pack.t] changed \001 to \o001 some places

[21:43] <pugs_svn> r24750 | szabgab++ | fixing parentheses, masak++

[21:43] *** mberends left
[21:44] *** slavik joined
[21:44] <slavik> what's the bitshift operator?

[21:44] <slavik> perl6: say 2<<2;

[21:44] <p6eval> elf 24748: OUTPUT«8␤»

[21:44] <p6eval> ..rakudo 34897: OUTPUT«Statement not terminated properly at line 1, near "<<2;"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[21:44] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "<<2"␤    expecting "_", fraction, exponent, term postfix, operator, ":" or ","␤    at /tmp/bd42WIeTww line 1, column 6␤»

[21:44] <slavik> perl6: say 2+<<2;

[21:44] <szabgab> masak: Could not find non-existent sub pack

[21:44] <p6eval> rakudo 34897: OUTPUT«Statement not terminated properly at line 1, near "+<<2;"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[21:44] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected end of input␤    expecting block, "\\", variable name, ">>" or "<<"␤    at /tmp/ANCrpExWz6 line 2, column 1␤»

[21:45] <p6eval> ..elf 24748: OUTPUT«Parse error in: /tmp/qmLEcGdG4t␤panic at line 1 column 8 (pos 8): Error in quotesnabber␤WHERE: say 2+<<2;␤WHERE:        /\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:1307:in `quotesnabber'␤  (eval):1:in `__quote_3820646'␤  STD_red/prelude.rb:406:in `block in

[21:45] <p6eval> ..long...

[21:45] <masak> szabgab: that's because it doesn't exist.

[21:45] <szabgab> surprise :-)

[21:45] <slavik> masak: ?

[21:45] <masak> slavik: ¿

[21:45] <slavik> bitshift operator?

[21:45] <masak> slavik: read the spec. S03.

[21:46] <masak> slavik: I cannot do it for you.

[21:46] <slavik> :P

[21:46] <masak> szabgab: the unpack.t tests pass now.

[21:48] <szabgab> that's enough for today, &

[21:48] <masak> szabgab: I'm a bit surprised that the [] were needed around the unpack() calls as well. but it seems the tests do not pass without them.

[21:48] <pmurias> ruoso: what do you mean in treated as a macro?

[21:49] <slavik> perl6: say 2~<2;

[21:49] <p6eval> elf 24750: OUTPUT«Undefined subroutine &GLOBAL::infix__126_60 called at (eval 119) line 3.␤ at ./elf_f line 3861␤»

[21:49] <p6eval> ..rakudo 34901: OUTPUT«Could not find non-existent sub infix:~<␤current instr.: '_block14' pc 62 (EVAL_12:40)␤»

[21:49] <p6eval> ..pugs: OUTPUT«È␤»

[21:49] <slavik> perl6: say 2 ~< 2;

[21:49] <p6eval> elf 24750: OUTPUT«Undefined subroutine &GLOBAL::infix__126_60 called at (eval 119) line 3.␤ at ./elf_f line 3861␤»

[21:49] <p6eval> ..rakudo 34901: OUTPUT«Could not find non-existent sub infix:~<␤current instr.: '_block14' pc 62 (EVAL_12:40)␤»

[21:49] <p6eval> ..pugs: OUTPUT«È␤»

[21:49] <slavik> :(

[21:49] <slavik> perl6: say (2 ~< 2);

[21:49] <p6eval> elf 24750: OUTPUT«Undefined subroutine &GLOBAL::infix__126_60 called at (eval 119) line 3.␤ at ./elf_f line 3861␤»

[21:49] <p6eval> ..rakudo 34901: OUTPUT«Could not find non-existent sub infix:~<␤current instr.: '_block14' pc 62 (EVAL_12:40)␤»

[21:49] <p6eval> ..pugs: OUTPUT«È␤»

[21:49] <slavik> bitshift fail

[21:49] <masak> Pugs++

[21:50] <slavik> how so?

[21:50] <slavik> perl6: say +(2 ~< 2);

[21:50] <masak> slavik: if you want a number as a result, I don't think ~< is what you want.

[21:50] <p6eval> rakudo 34901: OUTPUT«Could not find non-existent sub infix:~<␤current instr.: '_block14' pc 62 (EVAL_12:40)␤»

[21:50] <p6eval> ..elf 24750: OUTPUT«Undefined subroutine &GLOBAL::infix__126_60 called at (eval 123) line 3.␤ at ./elf_f line 3861␤»

[21:50] <p6eval> ..pugs: OUTPUT«0␤»

[21:50] <slavik> oh

[21:50] <slavik> perl6: say (2 +< 2);

[21:50] <p6eval> pugs, rakudo 34901: OUTPUT«8␤»

[21:50] <p6eval> ..elf 24750: OUTPUT«Undefined subroutine &GLOBAL::infix__43_60 called at (eval 119) line 3.␤ at ./elf_f line 3861␤»

[21:50] <slavik> ahh, awesome

[21:50] <masak> slavik: see? all you need to do is to read carefully. :)

[21:51] <slavik> I see

[21:51] <slavik> ~ == string version/context

[21:51] <masak> aye

[21:51] <masak> there's some logic to the madness.

[21:53] <slavik> my @guesses; for 0..16 -> $p { for 0..2 -> $g { push @guesses, ($g +< (2*$p)); };}; 

[21:53] <slavik> does that make sense?

[21:53] <masak> I think so.

[21:53] <slavik> I want to generate a sequence of all 00, 01, and 10 that will fit in 32bits

[21:53] <masak> but I'd do it with maps instead.

[21:54] <slavik> map == for?

[21:54] <masak> slavik: do you know Perl 5?

[21:54] <slavik> yes

[21:54] <slavik> map is different than for in perl5

[21:54] <masak> map in Perl 6 works the same as in Perl 5.

[21:55] <slavik> but maps are synonomous with for loops, no?

[21:55] <masak> slavik: I have difficulty answering that question.

[21:55] <slavik> don't for loops return a list as well?

[21:55] <slavik> rakudo: my @list = for 1..5 { 1; }; say @list;

[21:55] <p6eval> rakudo 34901: OUTPUT«Statement not terminated properly at line 1, near "{ 1; }; sa"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[21:56] <slavik> rakudo: my @list = for 1..5 { 1; } say @list;

[21:56] <p6eval> rakudo 34901: OUTPUT«Statement not terminated properly at line 1, near "{ 1; } say"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[21:56] <slavik> rakudo: my @list = map { 1 } 1..5; say @list;

[21:56] <p6eval> rakudo 34901: OUTPUT«Statement not terminated properly at line 1, near "1..5; say "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[21:56] <slavik> rakudo: my @list = map { 1 }, 1..5; say @list;

[21:56] <p6eval> rakudo 34901: OUTPUT«11111␤»

[21:56] <slavik> rakudo: my @list = for 1..5 { 1 }; say @list;

[21:56] <p6eval> rakudo 34901: OUTPUT«Statement not terminated properly at line 1, near "{ 1 }; say"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[21:56] <slavik> hmm

[21:57] <slavik> rakudo: my @list = for 1..5 { say 1 }; say @list;

[21:57] <masak> slavik: it doesn't work like that.

[21:57] <p6eval> rakudo 34901: OUTPUT«Statement not terminated properly at line 1, near "{ say 1 };"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[21:57] <slavik> :-\

[21:57] <masak> for loops aren't expressions.

[21:57] <masak> they're statements.

[21:58] <masak> S04 explains the difference.

[22:01] <slavik> masak: looking at s04, which part in particular?

[22:02] <masak> http://perlcabal.org/syn/S04.html#The_do-once_loop

[22:02] *** bloreg joined
[22:02] *** bloreg left
[22:02] <slavik> can map have a pointy block?

[22:03] <slavik> there do not seem to be map examples :(

[22:03] *** kisu_ joined
[22:03] <masak> map can take pointy blocks.

[22:03] *** pmurias left
[22:04] <slavik> rakudo: map {say $a}, 1..5 -> $a;

[22:04] <p6eval> rakudo 34901: OUTPUT«Statement not terminated properly at line 1, near "-> $a;"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[22:04] <masak> rakudo: say map(-> $a { $a + 2 }, 1..5);

[22:04] <p6eval> rakudo 34901: OUTPUT«34567␤»

[22:04] <slavik> I see

[22:04] <masak> slavik: the -> $param goes before the block.

[22:05] <slavik> gotcha

[22:05] <masak> slavik: if you feel a dearth of good code examples, check out the spectests.

[22:05] <masak> slavik: or, for that matter, check out the November wiki codebase.

[22:07] <masak> or the newly created "Perl 6 Examples" repository.

[22:07] <masak> or any number of games that people have been posting on blogs in the last few days. :)

[22:08] *** aindilis joined
[22:11] *** kisu left
[22:13] <dwhipp> subs Vs blocks question: if I want to write "sub foo { $xxx.scan: { return } };", how do I write the "scan" method such that the "return" exception will propagate to "sub foo"?

[22:14] <masak> dwhipp: in my limited understanding, you don't need to do anything special. however, Rakudo doesn't yet behave correctly for such a case.

[22:14] *** azawawi_ is now known as azawawi

[22:15] <dwhipp> thx. that explains why it didn't work for me ;-)

[22:15] <masak> dwhipp: the rule is (ideally), if the 'return' is located inside 'sub foo', it will return from there.

[22:15] <masak> there's an RT ticket about it that I could dig out for you if you want.

[22:16] <dwhipp> no need thx: I'm sure it will get fixed -- I can google if I need it

[22:16] <masak> http://rt.perl.org/rt3/Ticket/Display.html?id=61126

[22:16] <masak> got it anyway :P

[22:17] <dwhipp> :-)

[22:18] <masak> dwhipp: note that this also means that you could conceivably trigger a return from a sub that has already been run!

[22:18] <masak> (that will likely cause an exception, I guess)

[22:18] <masak> s/run/exited/

[22:19] *** gravity joined
[22:46] *** dwhipp left
[22:49] *** buu joined
[23:08] *** eric256 left
[23:11] *** eric256 joined
[23:13] *** ayrnieu left
[23:23] *** gravity left
[23:27] <pugs_svn> r24751 | masak++ | [t/spec/S29-str/unpack.t] two fixes:

[23:27] <pugs_svn> r24751 | masak++ | * fixed one erroneous test description

[23:27] <pugs_svn> r24751 | masak++ | * removed two sets of [] that aren't needed after r34904 in Rakudo's Test.pm

[23:30] <rakudo_svn> r34904 | masak++ | [rakudo] in Tests.pm, made the smartmatch check for List, not Array

[23:35] *** masak left
[23:35] <eric256> rakudo: say ( any<a b c> ~ any<d e f>)

[23:35] <p6eval> rakudo 34903: OUTPUT«Method 'postcircumfix:{ }' not found for invocant of class 'Junction'␤current instr.: 'postcircumfix:{ }' pc 1864 (src/classes/Associative.pir:77)␤»

[23:35] <eric256> rakudo: say ( any(<a b c>) ~ any(<d e f>) )

[23:35] <p6eval> rakudo 34903: OUTPUT«Junction<0xb687f04c>␤»

[23:35] <eric256> rakudo: say ( any(<a b c>) ~ any(<d e f>) ).perl

[23:35] <p6eval> rakudo 34903: OUTPUT«any(any("ad", "ae", "af"), any("bd", "be", "bf"), any("cd", "ce", "cf"))␤»

[23:36] <eric256> rakudo: say ( any(<a b c>) ~ any(<d e f>) ) ~~ 'ae'

[23:36] <p6eval> rakudo 34903: OUTPUT«Junction<0xb68547a4>␤»

[23:36] <eric256> rakudo:  any(<a b c>) ~ any(<d e f>)  ~~ 'ae'

[23:36] <p6eval> rakudo 34903: RESULT«any(any(Bool::False, Bool::True), any(Bool::False), any(Bool::False))»

[23:37] <eric256> ohh now my WSG answer could be changed to use junctions ;)  performance is probably still better using hashes though 

[23:49] *** eric256 left
[23:51] *** slavik left
[23:56] *** vixey left
