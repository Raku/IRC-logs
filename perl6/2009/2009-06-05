[00:04] *** DanielC left
[00:07] *** snarkyboojum joined
[00:09] *** _Chillance_ joined
[00:10] *** _Chillance_ left
[00:12] *** kst left
[00:13] *** kst joined
[00:15] *** Chillance left
[00:24] *** bacek joined
[00:53] *** FurnaceBoy_ is now known as FurnaceBoy

[01:02] *** snarkyboojum left
[01:05] *** jferrero left
[01:05] *** snarkyboojum joined
[01:06] <sjohnson> will Perl 6 (or even perl 5), have, or does have, an easy way to read a single key in without the ENTER key, and do something?

[01:07] <sjohnson> i found Term::ReadKey as it sounds like something that would do it, but upon reading its CPAN page, it doesn't sound like it

[01:07] <sjohnson> or it's heavily obfuscated

[01:08] <TimToady> is CTRL a key?

[01:09] <sjohnson> not one that i really care to trap, but maybe in the future

[01:09] <sjohnson> just looking to trap keys like 1 to 0

[01:09] <sjohnson> and a few letters

[01:09] <sjohnson> i've written a flashcard program in perl for kanji review

[01:10] <sjohnson> and it would definitely speed it up if i didnt have to hit ENTER all the time

[01:10] *** Whiteknight left
[01:10] <TimToady> yes, well, it's a complicated problem, even on one OS, let alone cross-OS

[01:10] <TimToady> what OS are you one?

[01:10] <TimToady> *on?

[01:11] <sjohnson> ubuntu linux

[01:11] *** exodist left
[01:11] <TimToady> I'd suggest (for p5) running stty to set your terminal to cbreak mode or raw, and then use sysread

[01:11] <sjohnson> unfortunately it looks like what i am asking is like pulling a tooth out of a sleeping tiger's mouth without waking it up

[01:12] <TimToady> if you use raw, make sure your exit code works first :)

[01:12] <sjohnson> TimToady: sysread() being a function i should use in p5?

[01:12] <TimToady> yes, bypasses STDIO, another wrinkle

[01:13] <sjohnson> perhaps i could run an alias that does all the comamnds for me

[01:13] <sjohnson> alias flashprogram='stty cbreak && flashprogram.pl && stty normal'

[01:13] <sjohnson> or something

[01:13] <TimToady> mebbe

[01:14] <pmichaud> "stty sane", often.

[01:14] <TimToady> in my program I just use system "stty raw -echo opost";

[01:14] <pmichaud> that sounds familiar :-)

[01:15] <TimToady> then while (sysread(STDIN, $buf, 1)) {

[01:15] <sjohnson> Term::TermKey; from CPAN might do the trick as well

[01:15] <sjohnson> without me busting out the dusty unix manuals

[01:16] <sjohnson> though i should try the "l33t" timtoady way, as i wuold probably learn something in the process too

[01:16] <TimToady> then when it exits, system "stty echo cooked -istrip";

[01:17] <sjohnson> FYI:  http://search.cpan.org/~pevans/Term-TermKey-0.03/lib/Term/TermKey.pm

[01:19] *** ispy_ joined
[01:19] <sjohnson> ahhh i knew it was too good to be true.  cpan won't install it for me, some error

[01:19] <sjohnson> i will do it the Official Larry Wall way

[01:20] <sjohnson> thanks Tim's toady

[01:30] <sjohnson> oops, 

[01:30] <sjohnson> i should have taken your CTRL-C advice seriously

[01:30] <sjohnson> heh

[01:30] <sjohnson> well i did, but at least i should have remembered it

[01:31] <sjohnson> thankfully i wrote a "kill" wrapper in perl too

[01:31] <sjohnson> to handle these "unforseeable" incidents

[01:33] <sjohnson> but the technology worked!

[01:34] <sjohnson> many thanks.  that would have probably taken me a month to figure out on my own

[01:54] <sjohnson> pmichaud: your sane thing saved the day too

[01:59] *** unitxt left
[02:02] *** xinming_ joined
[02:03] *** agentzh left
[02:04] *** eternaleye_ is now known as eternaleye

[02:04] *** agentzh joined
[02:05] *** agentzh left
[02:05] *** luqui joined
[02:06] *** xinming left
[02:06] *** agentzh joined
[02:25] <sjohnson> Q:  is there a universal $dummy variable in Perl 6 or 5?

[02:26] <sjohnson> maybe ()?

[02:26] <sjohnson> the Camel book said to set () = &something;

[02:26] <sjohnson> but i have found cases where that fails

[02:26] <sjohnson> also, undef = &something; fails too sometimes

[02:26] <sjohnson> (or maybe all the time)

[02:27] <sjohnson> i'd like to always be able to set $dummy stuff, without having to do "my $dummy;" all the time

[02:27] <literal> *, I think

[02:27] <sjohnson> am i dummy for asking this question?

[02:27] <literal> ($foo, *, $bar) = something();

[02:27] <sjohnson> will try it out

[02:27] * sjohnson hopes the universe doesn't implode

[02:28] <literal> $ if it's in a declaration: my $foo, $, $bar = something();

[02:28] <sjohnson> i have found that doing undef in that case works

[02:28] <literal> in Perl 6?

[02:28] <sjohnson> my ($foo, undef, $goose) = getFarmAnimals();

[02:28] <sjohnson> haven't tried p6

[02:28] <sjohnson> i should tho

[02:28] <literal> oh, I was talking about Perl 6

[02:28] <literal> in Perl 5 you'd use undef

[02:29] <sjohnson> rakudo:  my ($foo, undef, $bar) = <1 2 3>;  say $foo, $bar;

[02:29] <p6eval> rakudo 10a9b2: OUTPUT«Unable to parse declarator; couldn't find final ')' at line 2, near ", undef, $"␤in Main (src/gen_setting.pm:0)␤»

[02:29] <sjohnson> rakudo:  my ($foo, undef, $bar) = <1 2 3>;  say $foo.$bar;

[02:29] <p6eval> rakudo 10a9b2: OUTPUT«Unable to parse declarator; couldn't find final ')' at line 2, near ", undef, $"␤in Main (src/gen_setting.pm:0)␤»

[02:29] <sjohnson> hmm, now i've done it

[02:29] <sjohnson> rakudo:  my $foo, undef, $bar = <1 2 3>;  say $foo.$bar;

[02:29] <p6eval> rakudo 10a9b2: OUTPUT«Symbol '$bar' not predeclared in <anonymous> (/tmp/N8Ew8cisvi:2)␤in Main (src/gen_setting.pm:3207)␤»

[02:29] * sjohnson throws his hands in the air

[02:29] <literal> my $foo, $, $bar = <1 2 3>;  say $foo, $bar;

[02:30] <literal> rakudo: my $foo, $, $bar = <1 2 3>;  say $foo, $bar;

[02:30] <p6eval> rakudo 10a9b2: OUTPUT«Statement not terminated properly at line 2, near "$, $bar = "␤in Main (src/gen_setting.pm:0)␤»

[02:30] <luqui> rakudo: my $foo, $, $bar = <1 2 3>;  say $foo~$bar;

[02:30] <p6eval> rakudo 10a9b2: OUTPUT«Statement not terminated properly at line 2, near "$, $bar = "␤in Main (src/gen_setting.pm:0)␤»

[02:30] <literal> hm

[02:30] <sjohnson> we broketed the compiler

[02:30] <literal> rakudo: my $foo, $bar; $foo, *, $bar = <1 2 3>;  say $foo, $bar;

[02:30] <p6eval> rakudo 10a9b2: OUTPUT«Symbol '$bar' not predeclared in <anonymous> (/tmp/ETNvJ8wmyF:2)␤in Main (src/gen_setting.pm:3207)␤»

[02:31] <literal> rakudo: my ($foo, $bar); ($foo, *, $bar) = <1 2 3>;  say $foo, $bar;

[02:31] <p6eval> rakudo 10a9b2: OUTPUT«13␤»

[02:31] *** luqui left
[02:31] <literal> rakudo: my ($foo, $, $bar) = <1 2 3>;  say $foo, $bar;

[02:31] <p6eval> rakudo 10a9b2: OUTPUT«13␤»

[02:31] <literal> needs the parens, I guess

[02:32] <sjohnson> oh right

[02:33] <sjohnson> i was doing the undef thing that wouldnt work in p6

[02:33] <sjohnson> literal: do you know how to do it in p5?

[02:33] <literal> yeah, by using undef: my ($foo, undef, $bar) = qw<1 2 3>;

[02:34] <literal> $ perl -E'my ($foo, undef, $bar) = qw<1 2 3>; say $foo, $bar'

[02:34] <literal> 13

[02:37] <sjohnson> oh

[02:37] <sjohnson> what about the... other scenario

[02:37] <sjohnson> like undef = 5+5;

[02:42] <sjohnson> () = 5+5; works, but i tried it in other cases and it fails i think

[02:42] *** alanhaggai joined
[02:43] *** Limbic_Region left
[02:44] *** beggars joined
[02:59] <s1n> what's the difference between method and submethod?

[02:59] <pmichaud> submethods aren't inherited

[02:59] <s1n> pmichaud: thanks

[03:02] *** amoc left
[03:12] *** ispy_ left
[03:15] *** aindilis joined
[03:15] <TimToady> they're not inherited, but they must be accessible directly as $obj.ExactMatch::meth()

[03:15] <TimToady> even if $obj isn't an exact match; the submethod is really only concerned with the infrastructure of the object relating to ExactMatch, but others can invoke that

[03:16] <sjohnson> TimToady: do you know an answer to the $dummy variable question?

[03:17] <sjohnson> i will ask again

[03:17] <TimToady> so, for instance, BUILDALL can invoke the BUILD submethod on the object multiple times, once for each thing that the object is

[03:17] <sjohnson> is there a better way to write, sysread(STDIN, my $dummy, 1);

[03:17] <sjohnson> for a "press any key" action

[03:18] <TimToady> in p5?

[03:19] <TimToady> not really

[03:19] <sjohnson> yeah, and p6 if you know the future

[03:19] <sjohnson> in the camel book , it says to use () for non-important returned values, but this fails from time to time

[03:19] <TimToady> I only know the future to the extent people let me create the future

[03:19] <sjohnson> () = 5+5; works

[03:19] <sjohnson> but not in that sysread thing

[03:19] <TimToady> that's only for assigment, not for in/out parameters

[03:19] <sjohnson> i thought you were the king of the future, though

[03:20] <TimToady> I am the servant of the future

[03:20] <sjohnson> and other people follow suit

[03:20] <TimToady> If anyone is to be great among you, he must become least of all.  --Jesus

[03:21] <sjohnson> hence being one of Tim's toadies :)

[03:22] <TimToady> but I can be strong on behalf of people who do not (yet) have a voice

[03:22] * cj is happy to note this he finally got UTF-8 working with irssi.  in case anyone was still worried about that.

[03:23] <TimToady> 楽

[03:23] <sjohnson> music

[03:23] <sjohnson> testing my kanji knowledge?

[03:23] <sjohnson> :)

[03:23] <TimToady> no, testing cj's utf-8

[03:23] <sjohnson> oh

[03:24] <sjohnson> i wrote my kanji thing thanks to your tip, in TimToady(TM)-approved coding techniques

[03:24] <TimToady> well, just because I suggested it doesn't mean I approve :)

[03:25] <sjohnson> i suppose I should have said... inspired

[03:25] <TimToady> inspiration is another tricky concept...

[03:26] *** snarkyboojum left
[03:27] <sjohnson> may i ask, what inspired you to learn some japanese?

[03:28] <sjohnson> is it because of your background in linguistics?

[03:28] <sjohnson> and/or do you think it's a cool language to tackle (as I do)

[03:30] <TimToady> both those, plus we love anime

[03:30] <sjohnson> me too

[03:30] *** frew|work joined
[03:30] <sjohnson> that is why I am learning it

[03:30] <TimToady> also, started on my 2nd trip to Japan

[03:31] <sjohnson> have you met Matsumoto?

[03:31] <TimToady> a friend took me around Kyoto

[03:31] <TimToady> and started teachin me :)

[03:31] <TimToady> sure, we get along fine

[03:31] <TimToady> imitation is the sincerest form of flattery, after all :)

[03:32] <sjohnson> it is kind of neat when the "big names" of the computer world meet other big names

[03:32] <sjohnson> well, at least i think it is

[03:32] <sjohnson> and i mostly mean the heros of the computer stuff... not so much millionaire CEOs

[03:33] <TimToady> I enjoy the Hacker's Conference because we can all get together and be "normal" with each other

[03:33] <sjohnson> what do you guys usually talk about?

[03:34] <TimToady> cool gadgets, works in progress, social hacks, and anything else we like, which is pretty much everything

[03:36] <sjohnson> have you heard of the anime Rurouni Kenshin (TV, not OVA)?

[03:37] <TimToady> sure, we've watched all of Kenshin

[03:38] <sjohnson> wow that is suprising.  it's an older one so many haven't seen it.  it is my favourite

[03:38] <sjohnson> do you have any favourites?

[03:38] <TimToady> oh, lots

[03:38] <TimToady> Last Exile is cool

[03:39] <TimToady> Utena

[03:39] <TimToady> fushigi yuugi

[03:40] <sjohnson> ya i like that Otome Ranman song they played in fushigi yuugi

[03:40] <TimToady> his and her circumstances

[03:40] <sjohnson> http://www.youtube.com/watch?v=cUpDECjbbSE

[03:40] <sjohnson> what about Hunter x Hunter

[03:41] <TimToady> samarai champloo was pretty good, gad gaurd, escaflowne, (anything with music by Yoko Kano)

[03:42] <TimToady> cowboy beebop, trigun, irrisponsible captain tylor

[03:42] <TimToady> most of the old classics

[03:42] *** FurnaceBoy left
[03:42] <TimToady> stellvia is good

[03:42] <sjohnson> Legend of Basara

[03:42] <sjohnson> ?

[03:42] <sjohnson> that's around that time too

[03:42] <TimToady> yes, pretty okay

[03:43] <sjohnson> i liked that one

[03:43] <sjohnson> bought the dvds so a fansubbing group could re-release, which is ongonig right now

[03:43] <TimToady> oh, my favorite favorite is still probably Azumanga Daioh

[03:44] <sjohnson> im noting these, as i am in the mood for another "good show"

[03:44] <sjohnson> and its hard to find something that REALLY touches you

[03:44] <TimToady> crest of the stars, banner of the stars was pretty good

[03:45] <sjohnson> other than champloo, escaflowne, and fushigi yuugi, i havent heard of any of these

[03:45] * sjohnson is frothing at the mouth

[03:45] <sjohnson> you must have seen... Love Hina, right?

[03:47] <TimToady> sorry, have to go

[03:47] <sjohnson> i copide all you suggested

[03:47] <sjohnson> thanks for the tips!!!

[03:54] *** amoc joined
[03:54] *** Util joined
[04:00] <Util> rakudo: my $i = 4; my @a = ($i);              $i += 2; print @a[0];

[04:00] <p6eval> rakudo 10a9b2: OUTPUT«4»

[04:00] <Util> rakudo: my $i = 4; my @a;        push @a, $i; $i += 2; print @a[0];

[04:00] <p6eval> rakudo 10a9b2: OUTPUT«6»

[04:00] <Util> Why does the second version print "6" instead of "4"? Is it a known bug?

[04:07] *** unitxt joined
[04:12] *** davidad joined
[04:13] <s1n> Util: looks like it's pushing the reference/pointer, src/classes/Array.pir:196 might be a good place to start

[04:17] <Util> s1n: thanks, that looks promising.

[04:18] <s1n> Util: np, i can't say whether it's the correct behavior, but that's probably what's happening (args might be a ref pmc, if such a thing exists)

[04:21] <Util> I cannot believe that "6" is the correct behavior, but I see no explicit example in the S32 tests.

[04:30] *** eternaleye left
[04:48] *** Util left
[04:55] *** unitxt left
[04:57] *** unitxt joined
[05:08] *** snarkyboojum joined
[05:17] *** frew|work left
[05:19] *** alanhaggai left
[05:56] <japhb> Tene: ping

[05:58] *** sparc joined
[06:03] *** snarkyboojum left
[06:06] *** eternaleye joined
[06:16] *** viklund_ joined
[06:17] *** viklund_ left
[06:17] <Tene> japhb: pong

[06:17] <Tene> japhb: what's up?

[06:41] *** [particle] joined
[06:49] *** justatheory left
[06:52] *** alanhaggai joined
[06:59] *** [particle]1 left
[07:00] *** beggars left
[07:01] *** finanalyst joined
[07:02] *** drbean_ joined
[07:04] *** DemoFreak joined
[07:07] *** drbean__ joined
[07:11] *** barney joined
[07:19] *** dakkar joined
[07:20] *** drbean left
[07:22] *** drbean_ left
[07:25] *** unitxt left
[07:46] *** masak joined
[07:47] <Matt-W> Good morning

[07:48] <masak> good morning!

[07:53] <masak> today is Rakudo day! \o/

[07:53] <masak> and Form hackathon day! \o/

[07:54] *** cognominal left
[07:54] *** agentzh left
[07:55] *** agentzh joined
[07:57] *** lichtkind_ joined
[07:57] <masak> lichtkind: run.pugscode.org hasn't been working in a long time.

[07:57] <masak> lichtkind_: it would be really cool to re-create something like that, but for Rakudo.

[08:04] <Matt-W> yes indeed it's form hackathon day

[08:04] <Matt-W> I fixed the failing test last night

[08:04] <Matt-W> So we're on a clean slate and ready to go

[08:05] <masak> Matt-W++

[08:05] <Matt-W> So hopefully it will be an exciting day

[08:06] <Matt-W> I shall have to blog about it when it's done

[08:07] <Matt-W> And get my perl 6 category feed on planet perl six, maybe

[08:08] *** kst left
[08:09] *** kst joined
[08:10] *** davidad left
[08:11] *** lichtkind left
[08:23] *** ssm joined
[08:23] *** donaldh joined
[08:24] *** ejs joined
[08:28] *** DanielC joined
[08:29] *** ejs left
[08:29] *** ejs joined
[08:30] <DanielC> rakudo: for (0..9):by(2) -> $i {say $i}

[08:30] <p6eval> rakudo 10a9b2: OUTPUT«Statement not terminated properly at line 2, near ":by(2) -> "␤in Main (src/gen_setting.pm:0)␤»

[08:30] <DanielC> buubot: :by

[08:30] *** riffraff joined
[08:30] <buubot> DanielC:  hi 

[08:31] <DanielC> Damn it, my firefox just froze.

[08:31] <masak> DanielC: :by not implemented yet in Rakudo. you want 'buubot: spack'

[08:32] <DanielC> thanks

[08:32] <DanielC> buubot: spack :by

[08:32] <buubot> DanielC: S01-overview.pod:3 S02-bits.pod:119 S03-operators.pod:109 S04-control.pod:58 S05-regex.pod:95 S06-routines.pod:85 S07-iterators.pod:3 S09-data.pod:46 S10-packages.pod:5 S11-modules.pod:15 S12-objects.pod:62 S13-overloading.pod:9 S16-io.pod:17 S17-concurrency.pod:10 S19-commandline.pod:5 S22-package-format.pod:8 S26-documentation.pod:67 S29-function

[08:32] <DanielC> buubot says that :by is in S02 but he's lying.

[08:32] <buubot> DanielC: Stored says that :by

[08:33] <DanielC> Either that, or Firefox text search is lying.

[08:33] <masak> DanielC: I find one instance using ack locally.

[08:34] * DanielC tries searching for just "by"

[08:34] <masak> S02:2647.

[08:35] <DanielC> I'm looking a the web page, so I don't know where line 2647 is.

[08:36] <masak> it's in the HTML source, if you insist on using the web page. :)

[08:36] <DanielC> 1 .. 100 :by(3)

[08:37] <DanielC> I assume that the spaces are optional, right? In Perl 6 spaces are almost always optional.

[08:37] <DanielC> 1..100:by(3)  <-- ok

[08:37] <masak> std: 1..100:by(3); 1 .. 100 :by(3)

[08:38] <p6eval> std 27000: OUTPUT«ok 00:02 36m␤»

[08:38] <masak> DanielC: STD.pm says yes.

[08:38] <DanielC> What does "00:02 36m" mean?

[08:39] <masak> two seconds, 36 megabytes.

[08:39] <DanielC> STD took 36MB just to do 1..100:by(3) ?

[08:40] <masak> DanielC: yes, well... feel free to write your own more memory-efficient Perl 6 parser... :P

[08:42] * masak adds STD.pm and its underlysing technology to queue of things to review, after PGE and the Perl 6 test suite

[08:42] <masak> std: 

[08:42] <masak> std: *

[08:43] <p6eval> std 27000: OUTPUT«ok 00:02 35m␤»

[08:44] *** krunen joined
[08:45] *** bacek left
[08:45] <Matt-W> NO NO NO NO NO!

[08:45] <Matt-W> Excuse me

[08:46] <Matt-W> Colleague committing code that DOESN'T COMPILE

[08:46] * Matt-W fumes quietly in the corner

[08:46] <DanielC> Matt-W: One of your co-workers?

[08:46] <Matt-W> yes

[08:46] * Matt-W twitches

[08:47] <DanielC> You'd think he'd at least make the code compile before he commits to the main branch.

[08:47] <Matt-W> must... not... shatter... skull...

[08:47] <Matt-W> yes, you'd think

[08:47] *** snarkyboojum joined
[08:48] <DanielC> Matt-W: What programming language do you work in?

[08:48] <Matt-W> C++

[08:48] <DanielC> I thought it would be. That or C.

[08:48] <Matt-W> occasionally I do some Java or Perl

[08:48] <Matt-W> but it's mostly C++ for me

[08:49] <DanielC> I know C but I've never tried to learn C++. It looks complicated.

[08:49] <Matt-W> IT is

[08:49] <Matt-W> extremely

[08:49] <masak> C-- C-- C-- C-- C--

[08:49] <Matt-W> but no more so than Perl 6

[08:50] <Matt-W> What's different is that the complexity hits you in different places

[08:50] <DanielC> But I don't find Perl 5 (and so far Perl 6) complicated.

[08:50] <Matt-W> Perl 6 is better at hiding it

[08:50] <Matt-W> and provides a lot of simple things which are easy

[08:50] <Matt-W> C++ doesn't have any of those

[08:50] <DanielC> I tend to like simple languages. That includes C, Ruby, Perl, and others.

[08:51] <DanielC> re Perl:  You don't need to learn much to start writing useful Perl programs. Most of the language is just alternative ways of saying things.

[08:51] *** kst left
[08:52] <DanielC> e.g. If you only know one way to do a for loop, you'll get your work done just fine, even if there is a other way that would look nicer.

[08:52] *** kst joined
[08:54] <Matt-W> yeah

[08:54] <Matt-W> C++ is not too bad

[08:54] <Matt-W> until you start playing with templates

[08:54] <DanielC> I've heard bad things about templates. Honestly, I don't know what they are.

[08:54] <Matt-W> unfortunately, creative abuse of templates is where all the fun bits are :)

[08:55] <Matt-W> they're C++'s means of doing generic programming

[08:55] <Matt-W> classes with type parameters

[08:55] <Matt-W> etc.

[08:55] <DanielC> Like a + function that works for both matrices, vectors and complex numbers?

[08:55] *** riffraff left
[08:55] *** jferrero joined
[08:58] <DanielC> Wikipedia: "Generic programming [allows] some code to effectively circumvent the static typing"

[08:59] *** payload left
[08:59] * DanielC wonders, why don't they use a dynamicly typed language if they are just going to circumvent the static types.

[09:00] *** payload joined
[09:04] <DanielC> Ok, I've read a bit about C++ templates and generic programming, so I have an idea of what you are talking about.

[09:04] *** cognominal joined
[09:08] *** xomas left
[09:08] *** synth left
[09:09] *** davidad joined
[09:10] *** synth joined
[09:10] *** alanhaggai left
[09:11] *** xomas joined
[09:11] *** xomas left
[09:12] *** xomas joined
[09:17] *** kst left
[09:18] *** viklund_ joined
[09:18] *** snarkyboojum left
[09:18] *** viklund left
[09:18] *** viklund_ is now known as viklund

[09:19] *** viklund_ joined
[09:20] *** kst joined
[09:24] *** pjcj joined
[09:25] <Matt-W> DanielC: C++ templates do not allow you to circumvent static typing in any way

[09:26] <Matt-W> they're like another preprocessor language

[09:26] <Matt-W> a templated class is regenerated for each type your code uses it with

[09:26] <Matt-W> it remains very definitely statically typed

[09:26] <DanielC> Ok... a pre-processor...

[09:27] <DanielC> I saw the Swap() example.

[09:27] <DanielC> template<typename T>

[09:27] <DanielC> void Swap(T & a, T & b) { ... }

[09:27] <Matt-W> yeah

[09:27] <Matt-W> you'd get a new definition of Swap for each type T you use it with in the code

[09:27] <DanielC> Ok.

[09:27] <Matt-W> templates cause a few problems with the c++ compilation model

[09:27] <Matt-W> because you have to be able to see function bodies when the templates are instantiated

[09:28] <Matt-W> so you tend to end up with all the code in the header files

[09:28] <DanielC> ah

[09:28] <Matt-W> not particularly pleasant

[09:28] <Matt-W> One day I'd quite like a job where I don't have to worry about that anymore

[09:28] <Matt-W> i.e. a Perl 6 job :)

[09:29] <DanielC> A Perl 6 job would be nice.

[09:29] <Matt-W> not very likely for a while though

[09:29] <DanielC> I currently work with PHP, and while I don't hate PHP, it certainly doesn't excite me.

[09:29] <Matt-W> urgh

[09:29] <Matt-W> poor you

[09:29] <DanielC> Strange that the most popular languages seem to be the crappy ones.

[09:29] <Matt-W> I think what most interests me about C++ is finding clever ways to circumvent its restrictions and do very cool things

[09:30] <Matt-W> and also how you can write code that's actually quite nice, but still manages to run really fast

[09:30] <DanielC> I find nothing interesting about PHP. I think that embedding code in HTML is a great idea for making templates (Mason does that too), but that's it really.

[09:30] <Matt-W> as a language, it's entirely unremarkable

[09:30] * DanielC nods

[09:31] <DanielC> That's a good summary:  unremarkable.

[09:32] <DanielC> ugh!  My boss just asked me if we could make the website give an audio warning before it logs you out automatically.

[09:32] <DanielC> You know, because the website is not annoying enough as it is.

[09:34] <Matt-W> you can, if the user's using firefox 3.5 :)

[09:34] <DanielC> ??

[09:34] <Matt-W> <audio> element :)

[09:34] <DanielC> ah

[09:34] <DanielC> I'd rather tell him it's impossible :)

[09:35] <DanielC> I can just imagine a classroom fool of beeping computers.

[09:35] <DanielC> (our software is used in classrooms)

[09:35] <Matt-W> ouch

[09:35] <Matt-W> Just say it's impractical

[09:36] <Matt-W> And also highly unwise

[09:36] <Matt-W> Ill-considered

[09:36] <Matt-W> And it would increase the global production of Evil by nearly 0.02% year on year

[09:36] <DanielC> He rarely listens to me when it comes to design. He figures I'm a technie so I can't know anything about design.

[09:37] *** ejs1 joined
[09:37] <DanielC> I told him I have studied design as long as I have studied programming (which is true), but you know that design is one of those soft topics where everyone thinks they are an expert.

[09:38] <jnthn> ahojte...to je Rakudo den :-)

[09:38] <Matt-W> Yes, it's a bikeshedding topic

[09:38] <DanielC> yeah

[09:39] <Matt-W> but I've always felt, from my limited experience, that there are certain things which are objectively true

[09:39] <Matt-W> And one of those is that making noises is a bad idea in almost every circumstance

[09:39] <DanielC> and you would be right.

[09:39] <DanielC> There is actually a lot of research on usability design.

[09:39] <Matt-W> yes

[09:39] <Matt-W> I've read some of it

[09:39] <Matt-W> I thought it was very interesting

[09:40] <DanielC> I just follow Jakob Nielsen's blog, and read a few books.

[09:40] <DanielC> s/blog/web page/

[09:41] <DanielC> Much of design is subjective, but much of it isn't. But my employer thinks it's all subjective.

[09:42] *** ejs left
[09:44] *** ilogger2 joined
[09:44] *** hudnix joined
[09:45] *** p6eval joined
[09:45] <DanielC> Hmm... maybe we'll start selling auto-logout ring tones... Just to make the classroom experience /really/ annoying.

[09:45] <Matt-W> no don't do it!

[09:45] <Matt-W> think of the children!

[09:45] <DanielC> heh

[09:48] <jnthn> (finishes backlogging)

[09:48] <DanielC> jnthn: Is this your Rakudo day?

[09:49] <masak> DanielC: yes, he just said that. :)

[09:49] <masak> DanielC: "ahojte...to je Rakudo den :-)"

[09:49] <DanielC> masak: What language is that?

[09:49] <masak> DanielC: slovak.

[09:49] <DanielC> Do you know Slovak too?

[09:49] <masak> it's our second language here at #perl6.

[09:49] <masak> DanielC: no, I just pretend to know it.

[09:50] <DanielC> Ich wünsche, dass ich konnte Slowakisch sprechen.

[09:50] *** ejs2 joined
[09:51] <masak> well, at least you know German. :)

[09:51] <DanielC> :-)

[09:51] <DanielC> I'm gradually learning German.

[09:52] <DanielC> It'll be important, since my wife-to-be is German and much of her family doesn't speak English.

[09:52] <jnthn> Yes, it's Slovak. :-)

[09:52] <jnthn> masak: Second language? I thought that was lolspeak? ;-)

[09:53] <Matt-W> I always thought that a good way to improve my German would be to marry a German lady

[09:53] <DanielC> :-)

[09:53] * jnthn wouldn't be entirely opposed to taking such an approach to improve his Slovak...

[09:53] <Matt-W> But I don't meet many, and it seems a strange way to go searching for somebody

[09:53] <Matt-W> I don't really care what language she speaks, to be honest

[09:54] <Matt-W> Perl 6 would be good :)

[09:54] <DanielC> heh

[09:54] <Matt-W> jnthn: what's on the plan for rakudo day?

[09:54] <jnthn> Matt-W: first, git pull && make coffee

[09:54] <DanielC> I actually met my wife-to-be in the OpenOffice.org project. We were both volunteers there.

[09:54] <jnthn> After that, I'm open to suggestions, but am sure I'll find plenty in RT. :-)

[09:55] <jnthn> We currently have 344 tickets. Wow.

[09:55] <masak> jnthn: it's probably a pmichaud thing, but I'd really like to get the Perl6::Grammar.parse thing working...

[09:56] *** Muixirt joined
[09:57] <viklund> is there anyway of specifying encoding for a string in rakudo (or change)?

[09:58] <Matt-W> I'm sure there was something I really wanted to ask you to do jnthn

[09:58] <Matt-W> But now I can't remember what it was

[09:58] *** xinming joined
[09:58] <Matt-W> So I suppose it can't be all that important :)

[09:58] <jnthn> masak: Do we know why it's broken?

[09:58] <jnthn> rakudo: Perl6::Grammar.parse('42')

[09:59] <p6eval> rakudo 10a9b2: OUTPUT«Method 'parse' not found for invocant of class ''␤»

[09:59] <jnthn> Ah.

[09:59] <Matt-W> rakudo: class A { has @!l; method B { @!l[*-1] = 4; } }; say A.new.B;

[09:59] <p6eval> rakudo 10a9b2: OUTPUT«4␤»

[09:59] <Matt-W> cool that got fixed

[10:00] <DanielC> Question: Is there a difference between || and ?|  aren't they both just boolean OR ?

[10:00] <jnthn> rakudo: my ($meth) = Grammar.WALK(:name<parse>); $meth(Perl6::Grammar.new, '42')

[10:00] <p6eval> rakudo 10a9b2: OUTPUT«Null PMC access in find_method()␤in method Perl6Object::WALK (src/gen_setting.pm:3207)␤called from Main (/tmp/l9smLp1BMW:2)␤»

[10:01] <jnthn> Eww.

[10:01] <jnthn> OK, oddness.

[10:01] <jnthn> DanielC: || short-circuits.

[10:01] <DanielC> do this || die ...

[10:02] <Muixirt> the exit status of rakudo doesn't reflect if sth. went wrong while compiling, it's always? zero, will that change?

[10:02] <DanielC> jnthn: thanks

[10:02] <Matt-W> jnthn: sub/method return types

[10:03] * masak submits rakudobug

[10:03] <Matt-W> aah the first masakbug of the day

[10:03] <jnthn> Muixirt: That should be fixed...

[10:03] <jnthn> Matt-W: Yes?

[10:05] *** tulcod joined
[10:05] <jnthn> Matt-W: We have sub/method return types afaik. I seem to remember there being a ticket of some kind about 'em though...

[10:06] <masak> s1n: maybe it might be a better idea to do the Dallas.p6m announcements on perl6-users?

[10:06] <Matt-W> jnthn: I'm sure there was a problem using them in Form.pm, you get type mismatch errors all over the place

[10:08] <jnthn> Matt-W: I'm happy to help work out what's going on.

[10:08] <jnthn> Let me see if I can spot any RTs...

[10:08] <jnthn> I'm sure there was one on return value type checking.

[10:08] <Matt-W> I'm looking...

[10:09] <masak> s1n: p6l is more for language discussion, p6u more for community discussion...

[10:09] <Matt-W> http://rt.perl.org/rt3/Public/Bug/Display.html?id=58022 is just an 'implement' task

[10:09] <jnthn> ah, that is out of date since we already have "of"

[10:09] <jnthn> "as" we don't have, mostly due to lack of co-ercion at the moment.

[10:10] *** eiro joined
[10:10] *** eiro left
[10:11] <Matt-W> http://rt.perl.org/rt3/Public/Bug/Display.html?id=65128 might be related to what I remember from Form

[10:12] <jnthn> std: my Num List sub f () { return () };

[10:12] <p6eval> std 27000: OUTPUT«##### PARSE FAILED #####␤Multiple prefix constraints not yet supported at /tmp/ZpyIfLZt4o line 1:␤------> [32mmy Num List [31msub f () { return () };[0m␤    expecting typename␤FAILED 00:02 35m␤»

[10:13] <Matt-W> I can't find it exactly

[10:13] <Matt-W> Sorry :)

[10:13] <jnthn> OK. Well, that above bug needs a fix anyways...

[10:13] *** eiro joined
[10:13] <DanielC> while $fh.get -> $line { say $line }  only returns one line. ???

[10:13] <jnthn> rakudo: my Num List sub f () { return () }

[10:13] <p6eval> rakudo 10a9b2:  ( no output )

[10:14] <DanielC> Strange, because the while loop works fine with $*IN.

[10:16] <Matt-W> DanielC: you want for $fh.lines, I think

[10:17] <Matt-W> although maybe while $fh.get should work...

[10:17] <Matt-W> and it should if it works with $*IN.get...

[10:17] * Matt-W smells herring

[10:17] <DanielC> Yes, it should work.

[10:17] <masak> Matt-W: maybe take a shower?

[10:17] <masak> :)

[10:18] <DanielC> I know that $fh.lines works, but if $*IN.get works then so too should $fh.get

[10:18] <masak> jnthn: what about http://rt.perl.org/rt3/Ticket/Display.html?id=65960 ?

[10:20] <masak> jnthn: #65390 is kinda strange too...

[10:20] <jnthn> std: Role

[10:20] <p6eval> std 27000: OUTPUT«ok 00:02 35m␤»

[10:20] <jnthn> rakudo: role A {}; say A ~~ Role; say A.WHAT

[10:20] <p6eval> rakudo 10a9b2: OUTPUT«1␤A()␤»

[10:21] <jnthn> masak: Seems like it's fixed now. :-)

[10:21] <masak> jnthn: indeed. closing. :)

[10:21] <jnthn> masak: wait wait wait...need a regression test!

[10:21] <masak> jnthn: #64948 would be nice.

[10:21] <masak> jnthn: ok, I'll add that first.

[10:22] <Matt-W> tests++

[10:22] <masak> phenny: tell s1n maybe it might be a better idea to do the Dallas.p6m announcements on perl6-users? p6l is more for language discussion, p6u more for community discussion...

[10:22] <phenny> masak: I'll pass that on when s1n is around.

[10:22] <jnthn> masak: OK, or I can add it? But go ahead. :-)

[10:23] <masak> I'll add it. :)

[10:23] <masak> I'm already in ur test suite, adding a test.

[10:25] *** rjh left
[10:25] *** rjh joined
[10:25] <DanielC> rakudo: run "ls"

[10:25] <p6eval> rakudo 10a9b2: OUTPUT«operation not permitted in safe mode␤in Main (lib/Safe.pm:25)␤»

[10:26] <pugs_svn> r27001 | masak++ | [t/spec/S12-role] added role-does-role.t, with one test

[10:27] <jnthn> masak: S12-role?

[10:27] <jnthn> Roles are in S14...

[10:27] <masak> oh.

[10:27] <jnthn> I thought the tests had all been renamed.

[10:27] * masak moves the test

[10:28] <jnthn> Also, maybe you could put it in with an existing file?

[10:28] *** snarkyboojum joined
[10:28] <masak> jnthn: so that's why the S12-role dir was empty! :)

[10:28] <jnthn> S14-roles/basic.t is probably good.

[10:28] <jnthn> masak: ah, lol :-)

[10:29] <DanielC> if $fh.get { say "yes" } else { say "no" }  --> prints "no"

[10:29] <DanielC> that can't be right.

[10:29] <DanielC> (ie. the file does have lines)

[10:29] <jnthn> DanielC: If the line is "0" or "" that's false...

[10:30] <jnthn> Otherwise, maybe bug.

[10:30] <DanielC> wait... now it's saying "yes", something is fishy here.

[10:31] <DanielC> The line is not zero. But this is really weird. Some times it says "yes" and some times "no". I'm trying to narrow it down... one minute.

[10:32] <DanielC> jnthn: Actually... it behaves the *opposite* than what you'd expect.

[10:32] <pugs_svn> r27002 | masak++ | [t/spec] moved test from S12-role/ to S14-roles/

[10:32] <DanielC> my $fh = open('foo.txt', :r); if $fh.get { say "yes" } else { say "no" }

[10:33] <DanielC> says "yes"

[10:33] <DanielC> my $fh = open('foo.txt', :r); say $fh.get; if $fh.get { say "yes" } else { say "no" }

[10:33] <DanielC> says "no"

[10:33] <masak> lunch &

[10:33] <jnthn> Is $fh.get slurping up all of the file, by any chance?

[10:33] <DanielC> No, just one line.

[10:34] <DanielC> Or at least... say $fh.get only prints one line.

[10:36] <DanielC> Wait... I need to test a bit more...

[10:37] <DanielC> #!/usr/bin/perl6

[10:37] <DanielC> It looks as iff I remove that line from the file it behaves correctly. But that can't be right...

[10:37] * DanielC is bewildered

[10:38] <Matt-W> weird

[10:39] <DanielC> Ok, I can make a report.

[10:40] <DanielC> My open() line looks like this:  my $fh  = open('test.pl', :r);

[10:40] <DanielC> Where 'test.pl' is the file of the program. Yes, the file is reading itself (I was lazy, didn't want to make another file).

[10:40] <Matt-W> out of interest, does it behave if you read a different file?

[10:40] <DanielC> When test.pl starts with #!/usr/bin/perl6  the program behaves weird.

[10:41] <DanielC> Matt-W: It behaves correctly when you read a different file (!!!).

[10:41] <DanielC> When test.pl does not start with #!/usr/bin/perl6  the program behaves right.

[10:41] <DanielC> But when I read a different fie, the program always behaves right.

[10:42] <jnthn> DanielC: Erm. It isn't by any chance being stupid enough to run the program when it has the #! line at the top, is it?

[10:42] <jnthn> (If it is, then epic ouch...)

[10:42] <DanielC> Can you think of a way to test that?

[10:42] <DanielC> I'll put a sample program in pastebin...

[10:43] <rjh> strace it?

[10:43] <rjh> you could also add a sleep in the code, then run pstree

[10:44] <pasteling> "DanielC" at 92.227.64.74 pasted "Weird behaviour with open() and $fh.get" (15 lines, 232B) at http://sial.org/pbot/37044

[10:44] *** pmurias joined
[10:44] * jnthn fixes one half of RT#65128

[10:45] <jnthn> rakudo: sub Int f() { return "a" }; f()

[10:45] <p6eval> rakudo 10a9b2: OUTPUT«Malformed routine definition at line 2, near "Int f() { "␤in Main (src/gen_setting.pm:0)␤»

[10:45] <jnthn> rakudo: sub Int f() { "a" }; f()

[10:45] <p6eval> rakudo 10a9b2: OUTPUT«Malformed routine definition at line 2, near "Int f() { "␤in Main (src/gen_setting.pm:0)␤»

[10:45] <jnthn> oh gah

[10:45] <jnthn> rakudo: our Int sub f() { "a" }; say f()

[10:45] <p6eval> rakudo 10a9b2: OUTPUT«a␤»

[10:45] <DanielC> There's the sample code. If you either change the file that is being opened, or remove the #! line, the program works correctly.

[10:45] <jnthn> Gah, sucky.

[10:46] <jnthn> DanielC: Looking

[10:47] <jnthn> DanielC: Reproduced.

[10:47] <jnthn> DanielC: It doesn't by any chance come back if you have a blank line at the start of the file?

[10:47] <DanielC> Good to know I'm not crazy :)

[10:48] <jnthn> DanielC: Erm, two blank lines in a row...

[10:48] <DanielC> you are right...

[10:48] <DanielC> two blan lines => outputs "NO"

[10:48] <jnthn> DanielC: Right. Because $fh.get for a blank line returns ""

[10:48] <jnthn> Which is false.

[10:48] <DanielC> s/blan/blank/

[10:48] <rjh> DanielC: am I an idiot or does your first 'say $fh.get' not snaffle the #! line

[10:48] <rjh> leaving a blank line

[10:49] <jnthn> rjh: That's what I'm thinking too.

[10:49] <jnthn> rakudo: my $x = ""; if $x { say "yes" } else { say "no" }

[10:49] <p6eval> rakudo 10a9b2: OUTPUT«no␤»

[10:49] <jnthn> It's exactly like that.

[10:49] <jnthn> Remember that Perl 6 auto-chomps

[10:49] <jnthn> So the \n is gone and you just have an empty string

[10:49] <DanielC> rjh: You are correct, it seems.

[10:49] <jnthn> You probably want more like

[10:49] <jnthn> rakudo: my $x = ""; if defined($x) { say "yes" } else { say "no" }

[10:49] <p6eval> rakudo 10a9b2: OUTPUT«yes␤»

[10:50] <rjh> or maybe

[10:50] <DanielC> So maybe this is the problem with the while loop that the guy reported on the list.

[10:50] <DanielC> Maybe his input file has a blank line.

[10:50] <rjh> my $line = $fh.get; say $line; if $line { ... }

[10:50] <rjh> so you don't read twice

[10:50] <DanielC> So the while() gets "false" 

[10:50] <jnthn> DanielC: I very much suspsect so...

[10:50] <jnthn> q1faq!

[10:50] <jnthn> That's probably going to catch a few people out.

[10:51] <jnthn> But so far as I can see, Rakudo is behaving as spec'd in your program.

[10:51] <DanielC> So it seems now.

[10:51] <jnthn> Which list by the way? p6u?

[10:51] * jnthn should maybe subscribe to that

[10:52] <DanielC> yeah, users

[10:52] <jnthn> yeah, not subscribed there

[10:52] <jnthn> But anyway, seems you have an answer.

[10:52] <DanielC> yeah

[10:52] <jnthn> OK, let me try and fix up type checking of implicit return values...

[10:52] <DanielC> Oh, and I just noticed that he used  for loop instead of while. Is that wrong too?

[10:53] <DanielC> for $fh.get -> $line

[10:53] *** xinming left
[10:53] <jnthn> DanielC: Yes

[10:53] <DanielC> thanks

[10:53] <jnthn> for $fh.lines -> $line { } # will work

[10:53] <DanielC> ok, thanks for the clarification

[10:53] <jnthn> And will not be tripped up on the blank ines issue.

[10:54] <DanielC> I suspect that  ' while $*IN.get -> $line ' will be a very common construct.

[10:55] <jnthn> I hope not.

[10:55] <DanielC> Is there a way to make it behave as expected?

[10:55] <jnthn> No

[10:55] <DanielC> :-(

[10:55] <Matt-W> for $*IN.lines -> $line is equivalent

[10:55] <Matt-W> to what people want to do with while

[10:55] <jnthn> People should learn to use for $*IN.lines -> $line { } instead

[10:55] <DanielC> Matt-W: I know...

[10:55] <jnthn> while for IO is a p5ism.

[10:55] <Matt-W> and really

[10:55] <Matt-W> it makes more sense

[10:56] <Matt-W> sounds like a good article for someone's Perl 6-related blogging

[10:56] <DanielC> But the $*IN.get is something I learned right here in this channel.

[10:57] <jnthn> DanielC: Yes - for reading one line.

[10:57] <jnthn> That's fine.

[10:57] <DanielC> No, in a while loop I mean.

[10:57] <jnthn> Ah.

[10:57] <DanielC> So people in this channel are making the same error.

[10:57] <Matt-W> well it works fine as long as none of the lines you're reading are false

[10:57] <Matt-W> so maybe the person who told you never had that

[10:57] <jnthn> :-)

[10:57] <Matt-W> and hadn't realised

[10:57] <jnthn> Most likely.

[10:58] <jnthn> DanielC: At some level, everyone is still learning Perl 6.

[10:58] <Matt-W> now I suppose it's possible that .get could return $line but True, but... well

[10:58] <Matt-W> messy

[10:58] <DanielC> yeah

[10:58] <Matt-W> and .lines is great when we have lazy evaluation

[10:58] <jnthn> Matt-W: I pondered that for a moment but soon stopped pondering and realized it would probably cause more harm than good.

[10:58] <Matt-W> when are we getting lazy?

[10:58] <jnthn> Matt-W: We're putting it off until we have to do it.

[10:58] <Matt-W> jnthn: I think it would ripple unexpectedly outwards, people wouldn't realise it was stuck on True

[10:59] <jnthn> ;-)

[10:59] <DanielC> Matt-W: Is $fh.lines lazy?

[10:59] <Matt-W> DanielC: it will be

[10:59] <DanielC> good!

[10:59] <Matt-W> nothing's lazy in rakudo at the moment

[10:59] <Matt-W> but there will be lazy one day

[10:59] <DanielC> Matt-W: I was just thinking that the main problem with $fh.lines is that it might suck up the entire memory if you are going through a large file.

[10:59] <jnthn> Matt-W: Seriously though - it depends on a list refactor that I think pmichaud++ already has underway, or at least knows how to do.

[11:00] <DanielC> That's my concern with $fh.lines ... memory.

[11:00] <Matt-W> DanielC: yeah, which is why the idiom in so many languages is 'while I can read one more line'

[11:00] <DanielC> yeah

[11:00] <jnthn> Matt-W: After that, the major roadblock is probably cleared.

[11:00] <Matt-W> but with lazy evaluation, that goes away

[11:00] <Matt-W> jnthn: I'm glad to hear it. I had assumed it was a distant thing

[11:01] <Matt-W> woohoo!

[11:01] <jnthn> Matt-W: At NPW there was a discussion about laziness, and a lot of things became clearer on that area to pm and myself.

[11:01] <Matt-W> lunch &

[11:01] <Matt-W> jnthn: hurrah for NPW :)

[11:02] <Matt-W> I'm aware that laziness is not particularly easy to implement

[11:02] <jnthn> Matt-W: So there's at least a plan for moving forward now

[11:02] <Matt-W> So I'm trying not to be impatient for it

[11:02] <jnthn> It's not, but the fact that much of it hangs off gather/take helps.

[11:02] <Matt-W> yeah

[11:02] <Matt-W> once that works, a lot of stuff will be lazy automatically

[11:02] <jnthn> Right.

[11:02] <Matt-W> lunch really &

[11:02] <jnthn> That's why I'm really happy many things in the setting are using it.

[11:02] <jnthn> :-)

[11:04] <DanielC> jnthn: How about a "warnings" mode for Rakudo that detects probable bugs like 'while $*INC.get'?

[11:04] <DanielC> It could say "Excuse me, but this line might not do what you think it does"

[11:05] <rjh> I don't know, I'm going to feel weird about for $*IN.lines -> $line

[11:05] <jnthn> DanielC: Maybe more something for a kind of "lint" program.

[11:05] <rjh> you can stream into STDIN

[11:05] <rjh> 'while' seems more sensible to me

[11:05] <jnthn> DanielC: But thanks to having the Perl 6 grammar available that shouldn't be so hard.

[11:06] <DanielC> I'd bet my house that other people will make exactly the same mistake. Using 'for $fh.lines' actually looks wrong (it looks like it reads the entire file into memory).

[11:06] *** snarkyboojum left
[11:06] <DanielC> jnthn: What rjh said :)

[11:06] *** nsh_ joined
[11:06] <DanielC> jnthn: Perl Lint sounds like a great idea.

[11:06] <jnthn> DanielC: Heh, don't tell me, I just implement the spec. :-P

[11:07] <DanielC> :-)

[11:07] <jnthn> oh, hmm...checking implicit return types...less easy than first expected.

[11:07] <DanielC> Should someone mention this to TimToady?

[11:07] <rjh> perl 5 people are going to have to get used to lazy evaluation :)

[11:08] <jnthn> DanielC: He backlogs, I believe. 

[11:09] <DanielC> rjh: Problem is that you don't notice lazy evaluation most of the time... until it bites you. I'ts like Haskell where you *have* to learn about laziness before you can get anything done.

[11:09] <rjh> perl 6 is still an eager language by default, though?

[11:09] <DanielC> jnthn: Maybe he'll notice I mentioned his nick.

[11:10] <DanielC> rjh: Rather, some things are lazy but most is eager.

[11:10] <DanielC> rjh: Only lists are lazy.

[11:10] <jnthn> rjh: Different operations have different levels of laziness/eagerness.

[11:10] <jnthn> For example, array assignment is mostly eager.

[11:10] <DanielC> I thought it was binary: lazy or eager. Lists are lazy, everything else is eager.

[11:11] <jnthn> No.

[11:11] <jnthn> It's more broken down into 4 groups

[11:11] <rjh> :/

[11:12] <rjh> this is going to _more_ confusing than Haskell :)

[11:12] <jnthn> Array assignment is mostly eager in so far as my @a = 1,2,3,4; will be eager but my @a = 1..Inf; will not be.

[11:12] <rjh> jnthn: is @a = 1..Inf lazy list assignment, or is it a Range object?

[11:13] <jnthn> rjh: As far as I remember the discussion though, strict eagerness and strict laziness are things that are generally explicitly asked for.

[11:13] <jnthn> 1..Inf is a range object.

[11:14] <jnthn> @a = 1..Inf puts the 1..Inf into the "unevaluated" section of @a.

[11:14] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v

[11:14] <rjh> @shutup

[11:14] <lambdabot> Unknown command, try @list

[11:14] <jnthn> I think we mostly at the moment are tending to see arrays as having an evaluated and unevaluated part.

[11:14] <jnthn> Either of which may not exist.

[11:15] <jnthn> At least, that's the thinking at an implementation level.

[11:15] <rjh> So you have iterators masquerading as arrays too?

[11:16] <jnthn> It's more that the array contains the iterator.

[11:16] <jnthn> And just knows that if you ask for something beyond the "already evaluated" portion of the array, it should go and ask the iterator to give it some values.

[11:18] <rjh> ...so if you do an operation (map? grep?) on an array, you might get an iterator back?

[11:18] *** hanekomu joined
[11:18] <rjh> iterator-inside-an-array I mean

[11:19] <jnthn> Right.

[11:20] <jnthn> But if you then assign it to another array, it's going to be mostly eager and evaluate what it can (e.g. non-infinite bits) at that point.

[11:20] <jnthn> Non-infinite is really the wrong term though.

[11:20] <jnthn> More like "not readily available" or something.

[11:21] *** donaldh joined
[11:22] <rjh> I don't see much coverage in the spec

[11:22] <jnthn> S07 is about the best there is at the moment.

[11:23] <rjh> There's going to be real fun if you take an array/iterator and start pushing values into it

[11:23] <jnthn> But I agree it needs some filling out.

[11:23] <rjh> I guess you need to immediately coerce to a eager array at that point

[11:24] <jnthn> That or you push onto the ungenerated part if it contains infinite bits.

[11:24] <jnthn> erm

[11:24] <jnthn> lazy bits

[11:24] <jnthn> I'm not sure what push should do.

[11:24] <jnthn> my @a = 1..Inf; push @a, 42; # might be a little too surprising.

[11:24] <jnthn> (if it works)

[11:25] <jnthn> (in finite time ;-))

[11:25] <rjh> for me it appears to go into an infinite loop

[11:25] <rjh> as expected

[11:25] <rjh> Might be worth adding protection against this in the obvious cases

[11:26] <jnthn> Aye.

[11:26] <rjh> rakudo: my @a = 1..Inf; say @a[0];

[11:26] <p6eval> rakudo 10a9b2:  ( no output )

[11:26] <jnthn> Note Rakudo doesn't handle laziness at all yet.

[11:27] <rjh> ah

[11:29] *** pmurias left
[11:29] *** eiro left
[11:30] *** pmurias joined
[11:30] *** eiro joined
[11:30] *** cls_bsd joined
[11:30] *** frew joined
[11:30] *** pnu joined
[11:30] *** pugs_svn joined
[11:30] *** antiphase joined
[11:30] *** patmat joined
[11:30] *** Caelum joined
[11:30] *** jiing joined
[11:30] *** zev joined
[11:30] *** pmichaud left
[11:30] *** presh joined
[11:31] *** pmichaud joined
[11:31] <masak> young wippersnappers... first time I did 'while =$*IN' (as it was called at the time), I got a segmentation fault from Parrot. that's how I learned not to use that idiom! :)

[11:32] <jnthn> lol

[11:32] <masak> I remember it clearly (thanks to 'git log'). it was on the 23rd of July last year.

[11:33] <masak> we've sure come a long way since then.

[11:33] *** nsh- joined
[11:33] <jnthn> Less segfaults generally, methinks.

[11:33] <masak> oh yes.

[11:33] <masak> especially of the 'your program is very large and complex so I think I'll just segfault here' kind.

[11:33] <masak> very happy about that.

[11:34] *** pmurias left
[11:34] <jnthn> Yes, Parrot has certainly improved over the course of Rakudo's development.

[11:34] <masak> aye.

[11:35] * jnthn factors out some duplicated code

[11:35] <DanielC> I wish I could contribute so Rakudo. It would be so cool to work on a Perl 6 compiler.

[11:36] <jnthn> DanielC: You've already made a start. :-)

[11:36] <DanielC> :)

[11:36] <jnthn> (Bug reports are a useful contribution. :-))

[11:36] <DanielC> I've always thought of compilers as the sort of thing that only über-hackers do. Kind of like kernel development.

[11:37] <jnthn> Well, at the end of the day, compilers just take one thing and translate it into another.

[11:38] <jnthn> The complexity is that the thing we're translating from is Perl 6. ;-)

[11:38] *** kst joined
[11:39] <jnthn> Really though Rakudo mostly boils down to, a parser, a bunch of tree transformations, some built-ins and a few bits of C that do occasionally mind-bending things.

[11:39] <jnthn> (Thus why they're written in C. ;-))

[11:40] <DanielC> I'll make a point to finish S05. That should help me understand Rakudo.

[11:40] <jnthn> If you want to learn more and get a higher level overview, Pm and I both have slides on Rakudo too.

[11:40] <DanielC> I didn't know that Rakudo had anything in C. I thought it was all Parrot+Perl.

[11:40] <jnthn> That give a kind of overview.

[11:40] <jnthn> Rakudo has some little bits in C.

[11:41] <DanielC> I would love to see the slides.

[11:41] <jnthn> Mine are on http://www.jnthn.net/articles.shtml

[11:41] <DanielC> *click*

[11:41] <jnthn> Probably easiest is "Rakudo: Implementing Perl 6, in Perl 6, on Parrot"

[11:41] <jnthn> A little out of date in some spots no doubt, but probably not so far.

[11:42] <DanielC> found it...

[11:42] <jnthn> Also "All Your Dynamic Language Are Belong To Us" is an overview - not specific to Perl 6 - of the Parrot Compiler Toolkit, and goes through buliding a toy language.

[11:42] <jnthn> Rakudo is based on that same toolkit, and looking at a smaller example is probably a less overwhelming introduction to it.

[11:43] *** xinming joined
[11:43] <DanielC> Thanks. I've downloaded them.

[11:43] *** nsh_ left
[11:43] <DanielC> jnthn: Where are you located? Sweden?

[11:44] <DanielC> Nordic Perl Workshop, Stockholm University, etc

[11:44] <masak> :)

[11:45] *** zev left
[11:45] *** antiphase left
[11:45] *** pugs_svn left
[11:45] *** frew left
[11:45] *** patmat left
[11:45] *** jiing left
[11:45] *** Caelum left
[11:45] *** pnu left
[11:45] *** cls_bsd left
[11:45] *** eiro left
[11:45] *** presh is now known as bigpresh

[11:45] *** bigpresh left
[11:45] *** eiro joined
[11:45] *** cls_bsd joined
[11:45] *** frew joined
[11:45] *** pnu joined
[11:45] *** pugs_svn joined
[11:45] *** antiphase joined
[11:45] *** patmat joined
[11:45] *** Caelum joined
[11:45] *** jiing joined
[11:45] *** zev joined
[11:45] <DanielC> Actually, the lectures seem very spread out.

[11:45] *** presh joined
[11:46] <jnthn> DanielC: I'm located in Slovakia at the moment.

[11:46] <jnthn> But yes, I've talked in a lot of places.

[11:46] *** presh is now known as Guest92010

[11:46] <DanielC> k

[11:46] <jnthn> I travel quite a bit. :-)

[11:46] <DanielC> :-)

[11:50] *** snarkyboojum joined
[11:53] *** zev left
[11:53] *** antiphase left
[11:53] *** pugs_svn left
[11:53] *** frew left
[11:53] *** patmat left
[11:53] *** jiing left
[11:53] *** Caelum left
[11:53] *** pnu left
[11:53] *** cls_bsd left
[11:53] *** eiro left
[11:55] *** eiro joined
[11:55] *** cls_bsd joined
[11:55] *** frew joined
[11:55] *** pnu joined
[11:55] *** pugs_svn joined
[11:55] *** antiphase joined
[11:55] *** patmat joined
[11:55] *** Caelum joined
[11:55] *** jiing joined
[11:55] *** zev joined
[11:55] *** Guest92010 is now known as presjh

[11:55] *** presjh is now known as presh

[12:02] <pmichaud> http://www.pmichaud.com/2009/pres

[12:02] <pmichaud> (for my slides)

[12:02] <DanielC> *click*

[12:02] <DanielC> thanks

[12:02] * Matt-W will have to read those at some point

[12:02] <jnthn> pmichaud: Ah, that's the URL. :-)

[12:02] <pmichaud> npw-pct and npw-rakudo are the latest

[12:02] <Matt-W> but in the mean time, I venture that for $fh.lines reads very well to me

[12:02] <jnthn> pmichaud: I didn't find it linked anywhere on pmichaud.com

[12:02] <jnthn> morning, btw.

[12:02] <pmichaud> yeah, pmichaud.com is _way_ out of date :-(

[12:02] <Matt-W> I don't think it's a serious problem that people might have to learn about laziness. Oh, the horror!

[12:03] <pmichaud> good morning!

[12:03] <Matt-W> hi pmichaud

[12:04] <jnthn> > my Int sub foo() { "x" }; foo()

[12:04] <jnthn> Type check failed on return value

[12:04] <lambdabot>   <no location info>: parse error on input `"'

[12:04] <jnthn> woo

[12:04] * masak makes a mental note to sprinkle pointers to $fh.lines in appropriate places in u4x...

[12:04] <jnthn> Apart from it only works for that case...

[12:04] *** pmurias joined
[12:04] <Matt-W> jnthn: does it work if you give it an int?

[12:04] <jnthn> Matt-W: Yes. :-)

[12:05] <masak> pmichaud: you mentioned you could probably get #66270 to work...

[12:05] <pugs_svn> r27003 | pmurias++ | [re-smop] punned roles call BUILDALL during new if it's present

[12:05] <pugs_svn> r27004 | pmurias++ | removed debugging say

[12:05] <Matt-W> jnthn: excellent!

[12:05] <Matt-W> jnthn++

[12:05] <pugs_svn> r27005 | pmurias++ | [re-smop] default values from params

[12:05] <jnthn> (by that case I meant that sub foo($x --> Int) { } does work like that yet...)

[12:06] <pmichaud> jnthn: obtw... it's doubtful that Parrot calling conventions refactor will land before 1.4 release

[12:06] <jnthn> That one should be a sub call addition away though.

[12:06] <jnthn> pmichaud: omgz I'm like totally shocked... :-/

[12:06] <pmichaud> (based on latest perl 6 design meeting)

[12:06] <jnthn> (not)

[12:07] <jnthn> 1.4 is like, the release this month though?

[12:07] <pmichaud> no, July

[12:07] <pmichaud> June release is 1.3

[12:07] <jnthn> Oh. That's more ouch.

[12:07] *** xomas joined
[12:07] <jnthn> Did you get much indication of the time scale we're looking at?

[12:08] <DanielC> jnthn: I'm looking at "Implementing Perl 6 in Perl 6". Why do you need the outer $(  )  in the statement $then := $( $<block> ).

[12:08] <pmichaud> Allison said 1.5 (Aug) but I very much doubt that either unless someone else takes it up

[12:09] <jnthn> DanielC: That bit of the slides is kinda out of date, we write $<block>.ast now

[12:09] <DanielC> ok

[12:09] <jnthn> Which is a bit more self-explanator.

[12:09] <DanielC> yes, it is

[12:09] <jnthn> But menas "give me the PAST tree for this parse tree node"

[12:10] * jnthn much prefers the new syntax

[12:10] <DanielC> I forget what AST means, but I figure it is "A... Syntax Tree"

[12:10] <DanielC> Abstract

[12:11] <pmichaud> yes, I prefer the new syntax also.

[12:12] <DanielC> What is the difference between a PAST and an AST?

[12:12] <DanielC> P = Parrot?

[12:12] <jnthn> ye

[12:12] <jnthn> s

[12:12] <jnthn> oh noes, here's where we find out that the setting has type constraint issues.

[12:12] <jnthn>     our Bool multi method true() {

[12:12] <jnthn>         self!to_test($.from_exclusive ?? ++($.from.clone) !! $.from)

[12:12] <jnthn>     }

[12:13] <jnthn> I'm guessing to_test doesn't return a bool...

[12:13] <Matt-W> clearly it should

[12:13] <Matt-W> beat it up?

[12:14] <jnthn> Yeah, I'm curious how many things I'm going to have to beat up now... ;-)

[12:14] <jnthn> Example

[12:14] <jnthn>     our Str multi method Str() {

[12:14] <jnthn>         $.list

[12:14] <jnthn>     }

[12:14] <masak> :)

[12:14] <jnthn> .list is *not* going to return a Str!

[12:15] <masak> jnthn: it's all for the greater good...

[12:15] <pmichaud> Yeah, needs to be ~$.list

[12:15] <jnthn> Right.

[12:15] <pmichaud> can I see the diff?

[12:16] <jnthn> sure

[12:16] <pmichaud> I'm curious how the exception-return versus non-exception is being handled (more)

[12:16] <jnthn> You might be able tot hink of something better...

[12:16] <pmichaud> I've been thinking of refactoring PCT a bit there

[12:16] <pmichaud> I probably don't do anything immediately; just curious.

[12:16] <pmichaud> s/don't/won't

[12:17] <jnthn> http://gist.github.com/124262

[12:17] *** nsh- left
[12:17] <jnthn> pmichaud: Basically I force a return *if* we have a return type constraint (and only if we have one).

[12:17] <jnthn> pmichaud: I'm sure there's a more efficient way, but couldn't think of one without dipping into :inline's with a goto or PCT changes, which I'd rather you did.

[12:18] <pmichaud> agreed.  This looks good, actually.

[12:18] <pmichaud> obtw....

[12:18] <jnthn> ya?

[12:18] <pmichaud> (checking something)

[12:18] <pmichaud> there's no more trait_auxiliary or trait_verb   :-)

[12:18] <DanielC> proto infix:<+> is precedence('t=')  <--- What does "t=" mean?

[12:19] <pmichaud> DanielC: each predefined operator has a precedence level given by a string

[12:19] <jnthn> pmichaud: Oh, Larry is has a decision?

[12:19] <pmichaud> string comparisons are used to decide if one operator is tighter than another

[12:20] <pmichaud> so, for example,   an operator with precedence 'v='  would be tighter than infix:<+>

[12:20] <DanielC> pmichad: So it's like alphabetical order? a= is a higher precedence than b= ?

[12:20] <pmichaud> a= is lower than b=  (less tight)

[12:20] <DanielC> ok, got it backwards

[12:20] <pmichaud> the '='s are there to make it easier for us to dynamically create new precedence levels based on existing ones

[12:20] <pmichaud> for example, if someone does

[12:20] <DanielC> Why do you bother with the = sign? Why not just call it "a" or "u" ?

[12:21] <pmichaud> proto infix:<blah> is tighter(&infix:<+>) { ... }

[12:21] <pmichaud> then infix:<blah> ends up with a precedence level of   t>=

[12:21] <pmichaud> if someone then does

[12:21] <pmichaud> proto infix:<bar> is looser(&infix:<blah>)   that one ends up with a precedence level of   t><=

[12:22] <pmichaud> and if we sort/compare those, it turns out that we get the right ordering :-)

[12:22] <DanielC> Interesting.

[12:22] <DanielC> Thanks.

[12:22] <pmichaud> so, we insert a '<' to mean looser and a '>' to mean tighter

[12:23] <jnthn> oh wow, I didn't know it did that. That's cool! :-)

[12:23] <pmichaud> (and it works because '<' lt '=' and '>' gt '='

[12:23] <DanielC> This is indeed cool. Almost magical that it actually works.

[12:24] <DanielC> I's an interesting coincidence that in ASCII  < comes before = which comes before >

[12:24] <pmichaud> well, that's why I chose those chars :-)

[12:24] <pmichaud> if it hadn't worked out that way, I would've picked some different sequence

[12:24] <pmichaud> afk, kids to school

[12:25] <DanielC> for looser(&infix:<blah>)  I don't think you need  t><=   I think t<= should be enough.

[12:26] <DanielC> in fact... that's probably what pmichaud meant to type because ><= does the wrong thing :)

[12:28] <jnthn>     our Range multi method reverse() {

[12:28] <jnthn>         @.list.reverse;

[12:28] <jnthn>     }

[12:28] <jnthn> Is that really right?

[12:29] <masak> no.

[12:29] <jnthn> I mean, should a range being reverse return a range with the endpoints flipped?

[12:29] <jnthn> Or a reversed list of the range's elements?

[12:29] <masak> oh wait.

[12:30] * Matt-W is glancing through pmichaud's PCT slides with his jaw on the floor

[12:30] <masak> rakudo: say (1..4).reverse.perl

[12:30] <jnthn> I'm not sure if the return type is wrong or the body is wrong. :-)

[12:30] <p6eval> rakudo 10a9b2: OUTPUT«[4, 3, 2, 1]␤»

[12:30] <Matt-W> pmichaud: I didn't realise PCT did quite that much of the work

[12:30] <jnthn> Matt-W: PCT is The Awesome. :-)

[12:30] <masak> jnthn: this is what I'd expect, at least.

[12:30] <jnthn> masak: OK, in that case the return type wants to change.

[12:30] <Matt-W> jnthn: it is really really awesome

[12:30] <masak> jnthn: maybe some Range wizardry with :by(-1) could be used to acheive the same effect.

[12:31] <Matt-W> now I want to write a compiler

[12:31] <jnthn> Matt-W: Health warning: highly addictive

[12:31] <jnthn> ;-)

[12:32] <jnthn> Matt-W: Not sure.

[12:32] <jnthn> erm, masak

[12:32] <jnthn> :-/

[12:32] <jnthn> masak: Changing return type for now.

[12:32] <masak> aye.

[12:32] <masak> I can't think of a case where it matters.

[12:32] <masak> it's not like people would be trying to reverse 0..Inf anyway.

[12:33] <Matt-W> jnthn: if I got addicted to working on rakudo, I don't think that would be a problem

[12:33] <jnthn> rakudo: say (?1) ~~ Bool

[12:33] <masak> Matt-W: famous last words.

[12:33] <p6eval> rakudo 10a9b2: OUTPUT«1␤»

[12:33] <jnthn> rakudo: say (1..7).true.WHAT

[12:33] <p6eval> rakudo 10a9b2: OUTPUT«Int()␤»

[12:33] <jnthn> oh.

[12:34] <jnthn> rakudo: say (?((1..7).true)).WHAT

[12:34] <p6eval> rakudo 10a9b2: OUTPUT«Bool()␤»

[12:34] <jnthn> rakudo: say (?((1..7).true)) ~~ Bool

[12:34] <p6eval> rakudo 10a9b2: OUTPUT«1␤»

[12:35] <Matt-W> masak: indeed. Let's get our Form hackathon done first shall we?

[12:35] <masak> Matt-W: deal.

[12:35] <jnthn> Hmm. Well, checking implicitly returned values is going to make the setting a little more honest, at least...

[12:36] *** clintongormley joined
[12:36] <Matt-W> jnthn: no bad thing

[12:37] <masak> it's a kind of in-code tests, actually.

[12:40] <pmichaud> no, t><= is correct.

[12:41] <pmichaud> t<=  would make the other operator looser than infix:<+>, which it shouldn't be.

[12:42] <pmichaud> Range.reverse returns a Range.  However, we can't really do that until we implement :by

[12:42] * jnthn sticks some bacon in the frying pan

[12:42] <pmichaud> so we've been returning a list of the reversed elements

[12:42] <pmichaud> (so that it at least works somewhat)

[12:42] <pmichaud> for now, eliminate the return type constraint

[12:43] <pmichaud> or leave it as an embedded comment

[12:43] <masak> (...and maybe add a comment...)

[12:43] <pmichaud>    our #(Range) multi method reverse() { ... }

[12:43] <masak> ooh, nice!

[12:43] <jnthn> pmichaud: Done that, and added a comment to the body too.

[12:43] <pmichaud> (feel free to pick a different bracketing char :-)

[12:43] <jnthn> pmichaud: Saying what it should do eventually.

[12:43] <pmichaud> jnthn: excellent.

[12:43] * jnthn goes looking for the weirdest unicode bracketing char he can find 

[12:43] <jnthn> ;-)

[12:44] *** meppl joined
[12:44] <Matt-W> bacon++

[12:46] <jnthn> eww we fails a bunch of test scripts from type checks being enforced

[12:46] * jnthn fixes up

[12:46] <pmichaud> Matt-W:  (from backscroll)   yeah, I really like PCT.  Much of it was inspired by audreyt's work on Pugs and PIL.

[12:47] <Matt-W> pmichaud: good to know there are influences from that marvellous project

[12:47] <Matt-W> I remember when I heard about Pugs, I was overjoyed

[12:47] <Matt-W> To think that such an interesting language as Perl 6 was going to be implemented in a language I like as much as Haskell

[12:50] <pmichaud> (more backscroll)   difference between ?| and || is (1) short-circuit and (2)  ?| always returns a boolean

[12:51] <pmichaud> actually, ?| can short circuit if it wants

[12:51] <pmichaud> oh, perhaps it can't.  hmm.

[12:51] <pmichaud> anyway ?| returns a boolean.  || doesn't.

[12:51] <pmichaud> (er, || doesn't have to)

[12:52] *** skids_ joined
[12:53] <jnthn> Bacon. Inside fried bread.

[12:54] <jnthn> ...musteatandforgetimmediatelyhowgooditis...

[12:54] <Matt-W> || will if the side that comes out is a Bool :)

[12:54] <Matt-W> jnthn: mmmmm!

[12:54] * Matt-W goes to jnthn's for dinner

[12:57] *** agentzh joined
[12:57] *** FurnaceBoy joined
[13:14] *** hv2 joined
[13:17] *** snarkyboojum left
[13:17] <DanielC> Shoot. I burnt my pizza.

[13:17] <DanielC> I got distracted with Rakudo stuff.

[13:18] <jnthn> :-(

[13:18] * DanielC puts another pizza in the oven

[13:18] <pmichaud> It's important to keep priorities straight.  Pizza > Rakudo

[13:18] <DanielC> :)

[13:18] <DanielC> I find Rakudo interesting, so I get distracted.

[13:19] <pmichaud> Beer > Rakudo

[13:19] <DanielC> I get distracted eas... oh look at the bird!

[13:19] <pmichaud> I did get distracted by Rakudo while trying to cook some rice, however, so    Rakudo > Rice

[13:20] <jnthn> Beer > *

[13:20] <PerlJam> Dr Pepper > *

[13:20] <PerlJam> :-)

[13:20] <PerlJam> (hello btw)

[13:20] <DanielC> o/

[13:22] *** beggars joined
[13:22] *** rjh_ joined
[13:22] *** rjh left
[13:25] <DanielC> Regex: Can someone explain the difference between a rule and a token? When do you use each?

[13:25] <jnthn> pmichaud: http://www.pmichaud.com/perl6/rakudo-tests-2009-06-02.png is has a shrunk.

[13:25] <DanielC> I'm looking at the RPN calculator from jnthn's talk.

[13:25] <PerlJam> DanielC: rules have significant whitespace, tokens do not.

[13:25] <DanielC> thanks

[13:25] <pmichaud> jnthn: yes, I know.  That's what GD::Graph does, apparently.

[13:26] <DanielC> In the RPM calculator operators are tokens but values are rules.

[13:26] <pmichaud> I'm not sure what to do about it.

[13:26] *** beggars left
[13:26] <DanielC> rule Value { \d+[\.\d+]? };

[13:26] <pmichaud> DanielC: it has to do with where we allow whitespace

[13:26] <pmichaud> Oh, I don't know why that would be a rule.  Should be a token.

[13:26] <DanielC> Ok, so I'm not crazy :-)

[13:27] <pmichaud> I don't have enough evidence to judge that.

[13:27] <pmichaud> :-P

[13:27] <PerlJam> rakudo:  say "hello".trans( l => 'L' );  say "hello".trans( 'l' => 'L' );

[13:27] <DanielC> :-)

[13:27] <p6eval> rakudo 10a9b2: OUTPUT«hello␤heLLo␤»

[13:27] *** tulcod left
[13:27] *** mizioumt joined
[13:27] <PerlJam> What's happening on that first one?  Is rakudo interpreting a lowercase ell as something different?

[13:27] <pmichaud> named parameter vs Pair

[13:27] <jnthn> PerlJam: that looks...odd

[13:27] <jnthn> oh!

[13:27] <pmichaud> the first is a named param.  The second is a Pair.

[13:28] <PerlJam> ah.

[13:28] <jnthn> And methods ignore named params.

[13:28] <jnthn> oh huh?

[13:28] <PerlJam> (It's still surprising)

[13:28] <jnthn> # Looks like you planned 52 tests, but ran 52

[13:28] <jnthn> ...gee!

[13:39] <dalek> rakudo: 056847f | pmichaud++ | src/classes/Grammar.pir:

[13:39] <dalek> rakudo: Add .parse to base Perl6::Grammar and other non-Rakudo grammars. Fixes #66270.

[13:39] <dalek> rakudo: Eventually PGE will provide a .parse method by default, at which point

[13:39] <dalek> rakudo: we can inherit that one and omit this one.

[13:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/056847f74c18e342b2defe6c303aa4ff67db036d

[13:41] <jnthn> Yay :-)

[13:43] * jnthn spectests, hoping he's cleared up the setting's return type constraint issues now.

[13:43] <DanielC> jnthn: I'm having trouble getting your RPN calculator (from your slides) to work.

[13:43] <pasteling> "DanielC" at 92.227.64.74 pasted "RPN Calculator" (36 lines, 870B) at http://sial.org/pbot/37046

[13:44] <DanielC> Error: Statement not terminated properly at line 34, near "else {\n\tsa"

[13:44] <DanielC> Line 34 is the "else" right at the end of the file.

[13:47] <hv2> Hi guys, just trying to get up to speed on Rakudo, got 3 failures in the spectests. The first is one I think is known about: a coredump after the end of t/spec/S09-subscript_slice/slice; the second I don't see mentioned, a (different) coredump after the end of t/spec/S10-packages/basic; something similar to the third was reported and fixed before, in t/spec/S02-lexical-conventions/unicode:

[13:47] <hv2> error:imcc:syntax error, unexpected USTRINGC ('unicode:"\x{e4}\x{f6}\x{fc}"')

[13:47] <hv2>     in file 'EVAL_27' line 2553

[13:47] <hv2> Null PMC access in type()

[13:47] <hv2> in Main (t/spec/S02-lexical-conventions/unicode.rakudo:100)

[13:47] <hv2> FAILED tests 30-31

[13:47] <hv2>     Failed 2/31 tests, 93.55% okay (less 4 skipped tests: 25 okay, 80.65%)

[13:48] <hv2> Which ones should I open tickets for?

[13:50] <jnthn> hv2: I see the t/spec/S10-packages/basic one too 

[13:50] <jnthn> hv2: What platform are you on?

[13:50] <hv2> linux, FC6

[13:50] <jnthn> Ah, different form me then...so it ain't platform specific. 

[13:50] <jnthn> The unicode one - that's known too, actually a Parrot issue. We filed a Parrot ticket on it.

[13:51] <jnthn> t/spec/S10-packages/basic I'm not sure if fails for everyone?

[13:51] <PerlJam> DanielC: rather than $expr ~~ RPNExpression, try RPNExpression.parse($expr)  or  $expr ~~ /<RPNExpression>/;

[13:51] <jnthn> Feel free to file a ticket on that one.

[13:51] <jnthn> DanielC: What PerlJam said...

[13:51] <pugs_svn> r27006 | pmurias++ | [re-smop] fix bug in ReadonlyParam

[13:51] <hv2> Oh ok, most recent ref I could find for the unicode one was a bug closed by chromatic last month, for an earlier parrot revision than I fetched.

[13:51] <jnthn> DanielC: That older syntax is outdated.

[13:51] <hv2> ack

[13:51] <DanielC> jnthn/PerlJam: thanks

[13:52] <jnthn> hv2: I *think* pmichaud filed a new one recently for the unicode method names bug.

[13:52] <hv2> ok, Google might not have indexed it yet, I didn't search directly on the database

[13:53] <jnthn> Ah, OK.

[13:53] <jnthn> It was recent.

[13:54] <jnthn> https://trac.parrot.org/parrot/ticket/730

[13:54] <DanielC> Method 'postcircumfix:{ }' not found for invocant of class 'Failure'

[13:54] <DanielC> :-(

[13:55] <hv2> Is there a standard set of information to include, maybe even a rakudobug script? rt.perl.org just says "send a detailed email".

[13:56] <jnthn> Include your platform, the name of the spectest that fails and if you know how to (since it's segfaulting) then a gdb backtrace can be useful.

[13:56] <hv2> ok

[13:57] <hv2> Oh, how do I get the rakudo version that I git-cloned to?

[13:58] <PerlJam> git rev-parse HEAD

[13:58] <hv2> ty

[13:58] *** nsh_ joined
[13:58] *** ruoso joined
[14:00] <ruoso> HellO!

[14:00] <PerlJam> greetings ruoso

[14:04] *** Chillance joined
[14:06] <DanielC> Having trouble with the RPN calculator.

[14:07] <DanielC> http://sial.org/pbot/37047

[14:07] *** Scorp1us joined
[14:07] <DanielC> for $!parsetree<Expr> -> $cur { say $cur.perl }  <--  why is this wrong?

[14:08] <DanielC> I'm just trying to figure out how the jnthn's RPN calculator is supposed to work.

[14:08] <PerlJam> What makes you think there's somethign wrong with that line?

[14:08] <DanielC> The output is: undef and the -1

[14:08] <DanielC> But the expression is "2 3 +"

[14:09] <DanielC> s/and the/and then/

[14:09] *** snarkyboojum joined
[14:10] <PerlJam> DanielC: maybe put a $!parsetree.perl.say in there some where to get a look at the whole parse tree  ?

[14:10] <DanielC> I did that, and the whole tree looks fine (keeping in mind that I don't know exactly what it should look like).

[14:11] <DanielC> But to my untrained eyes it looked perfect.

[14:13] <pasteling> "DanielC" at 92.227.64.74 pasted "Parse tree" (52 lines, 1K) at http://sial.org/pbot/37048

[14:13] <DanielC> There's the output of $!parsetree.perl.say

[14:13] *** nsh_ left
[14:13] <DanielC> The undef and -1 at the end are just from the 'say $cur.perl'

[14:15] *** alester joined
[14:15] <jnthn> DanielC: moment, will look

[14:15] * jnthn is momentarily distracted

[14:17] <pmichaud> might need    for $!parsetree<Expr>.list -> ...

[14:17] <pmichaud> it would help to see the full code

[14:18] <pmichaud> there are also some known bugs for .perl on Match objects

[14:18] <DanielC> pmichaud: Right now the full code for the RPN calculator is at http://sial.org/pbot/37047

[14:18] <DanielC> I'll try .list

[14:19] <DanielC> no change

[14:19] <DanielC> Ultimately I'm just copy-pasting from Jonathan's talk.

[14:19] <pmichaud> note that the tree is actually in  $/<RPNExpression>, not just $/

[14:20] <pmichaud> so there's no $/<Expr> -- it would actually be $/<RPNExpression><Expr>

[14:20] <DanielC> Replacing $/ by $/<RPNExpression> made a big difference.

[14:21] <pasteling> "DanielC" at 92.227.64.74 pasted "Replacing $/ by $/<RPNExpression>" (33 lines, 522B) at http://sial.org/pbot/37049

[14:21] <DanielC> The 'undef' is now a parse tree.

[14:21] <PerlJam> DanielC: what is it you expect to be output btw?

[14:22] <DanielC> PerlJam: Honestly, I don't know. I got this code from jnthn's slides and I'm trying to figure out how it works.

[14:22] <DanielC> PerlJam: The first link I posted is a copy of Jonathon's code.

[14:23] <DanielC> Except I changed =$*IN to $*IN.get

[14:23] * jnthn is undistracted

[14:23] <DanielC> It seems to come from an older version of Perl 6.

[14:23] <jnthn> And spectests pass \o/

[14:23] <DanielC> jnthn++

[14:24] <pugs_svn> r27007 | pmichaud++ | Add a test for STD.parse() from RT #66270.

[14:26] <Matt-W> DanielC: the loss of prefix:<=> was quite recent, so there'll be a lot of example code floating around which will require that change

[14:26] <pugs_svn> r27008 | pmurias++ | [re-smop] :($foo) creates a new Signature

[14:26] <[particle]-> anyone offhand know the sive of an SV in p5?

[14:26] <[particle]-> *size

[14:27] <pmurias> ruoso: hi

[14:28] <ruoso> hi pmurias 

[14:28] <PerlJam> [particle]-: didn't it change from 5.8 to 5.10?

[14:29] <[particle]-> ooh, yeah. i need 5.8.

[14:29] *** decasm joined
[14:29] <pmurias> ruoso: re your lazyness post on p6l sometimes you can easily calculate a large chunk of a lazy list e.g. 1..100000 but you don't want to waste time & memory on unused values

[14:30] *** hv2 left
[14:30] *** nihiliad joined
[14:30] <ruoso> pmurias, that's why lazy lists should probably have buffer sizes

[14:30] <ruoso> so you only calculate some of it

[14:30] <ruoso> like Unix Pipes

[14:30] <PerlJam> ruoso: so ... laziness is a whole other form of IO ?  :)

[14:31] <dalek> rakudo: 636a2b6 | jnthn++ | src/parser/actions.pm:

[14:31] <dalek> rakudo: Fix one half of what is reported in RT#65128 - our T1 T2 sub f() { ... } now gives a compile time error like STD.

[14:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/636a2b6f7cb4d0b5c0d4944482918137a0713615

[14:31] <dalek> rakudo: 7a40779 | jnthn++ | src/setting/ (2 files):

[14:31] <dalek> rakudo: Fix up various return type constraints in teh built-ins.

[14:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7a40779c46512e8aee9721993e98bfb46c34eef0

[14:31] <ruoso> yeah... the way I see it is really in the same logic as unix pipes

[14:31] <[particle]-> pj: what header is SV defined in?  i'll try to look it up on github

[14:31] <dalek> rakudo: 8c09b53 | jnthn++ | src/parser/actions.pm:

[14:31] <DanielC> Ok, if I use $/<RPNExpression> but remove the .list the code seems to behave reasonably.

[14:31] <dalek> rakudo: Refactor setting of return types to eliminate duplicate code, and implement checking of implicitly returned values for the my T sub foo() { ... } and sub foo(--> T) { ... } cases.

[14:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8c09b534e9e5e7c85a07cbf2f19229850ae97150

[14:31] <dalek> rakudo: a89161f | jnthn++ | :

[14:31] <ruoso> except you exchange objects instead of strings

[14:31] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[14:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a89161fd83a47163c51b97ed46ea30e63ed98f8e

[14:32] <PerlJam> [particle]-: I haven't really looked at p5 in a while, but I would guess sv.h  :)

[14:32] <[particle]-> pj: yes, that was a silly question....

[14:32] *** snarkyboojum left
[14:33] <Matt-W> Is there any semantic difference between saying my Int sub foo() { ... } and my sub foo (--> Int) { ... }

[14:33] <PerlJam> Matt-W: I hope not.

[14:33] <jnthn> Matt-W: No.

[14:33] <Matt-W> jnthn: great

[14:33] <DanielC> What does the ~ do in ~$var ?

[14:33] <Matt-W> what about foo() returns Int

[14:33] <PerlJam> DanielC: stringifies

[14:33] <jnthn> Matt-W: In fact I just refactored Rakudo to call exactly the same some path for the two...

[14:34] <jnthn> returns Int - doesn't enforce on implicits yet.

[14:34] <jnthn> That's what I have left to fix now.

[14:34] <DanielC> PerlJam: thanks

[14:34] <jnthn> But it should be the same

[14:34] <jnthn> Also .of

[14:34] <jnthn> erm,

[14:34] <jnthn> sub foo() of Int I mean

[14:34] <Matt-W> hmm

[14:34] <Matt-W> so why do we have four ways to say the same thing

[14:34] <jnthn> It's like...there's only 4 ways to do it. :-)

[14:34] <jnthn> Heh

[14:34] <Matt-W> I know TMTOWTDI but this seems a bit silly

[14:35] <jnthn> Yes, I haven't found it too amusing trying to keep all four ways in sync.

[14:35] <Matt-W> 'as' is a different semantic, isn't it?

[14:36] <jnthn> as is coercion rather than check, yes

[14:36] <Matt-W> that's okay then

[14:36] <Matt-W> it's not five :)

[14:36] <PerlJam> Matt-W: perl always optimizes for expressivity.

[14:36] <Matt-W> so if you say sub foo() as Str, you basically get prefix:<~> called on anything you return?

[14:37] <jnthn> No

[14:37] <jnthn> IIRC, you get .Str called on everything you return

[14:37] <Matt-W> jnthn: that would make more sense

[14:37] <Matt-W> it's just that prefix:<~> usually ends up calling .Str :)

[14:37] <Matt-W> but I suppose you could change that

[14:38] <jnthn> It's either that or a multi-dispatch sub call Str($ret_val)

[14:38] *** frew left
[14:38] <jnthn> Oh, or is it not quite like that...

[14:38] <jnthn> Hmm

[14:38] <jnthn> Whatever co-ercion syntax would be anyway. I should check up on that.

[14:39] *** frew joined
[14:40] <pugs_svn> r27009 | jnthn++ | [t/spec] Tests for one issue reported in 65128.

[14:40] <DanielC> The RPN calculator works!!!  http://sial.org/pbot/37050

[14:41] <pmichaud> multi-dispatch sub call, I think.

[14:41] <pmichaud> (rakudo doesn't do it this way yet; it's one of those areas that I sense some spec volatility)

[14:41] <DanielC> jnthn: Do you mind if I post your RPN calculator in my blog?

[14:42] <jnthn> DanielC: Sure, fixed version I hope ;-)

[14:42] <jnthn> pmichaud: Yeah.

[14:42] <DanielC> jnthn: Thanks.

[14:43] <jnthn> pmichaud: Rakudo doesn't do coercion at all yet though AFAICT.

[14:43] <pmichaud> not through 'as', no.

[14:43] <pmichaud> but obviously prefix:<~> coerces to a Str  :-)

[14:45] <PerlJam> Does augment work in rakudo yet?

[14:45] <jnthn> pmichaud: Yes, I meant the general case.

[14:45] <pmichaud> no, it's still 'isa also'

[14:45] <pmichaud> *'is also'

[14:45] <PerlJam> thanks

[14:45] <jnthn> pmichaud: We can't in Rakudo currently write Str($x) afaik.

[14:45] <pmichaud> jnthn: correct.  I'm not sure what to do with that one.

[14:46] <pmichaud> I'm _very_ tempted to put some out-of-band handling for 'VTABLE_invoke' to get the original object.

[14:47] <jnthn> pmichaud: Well, if it just be multi sub I'd guess that it's only the result of 'is export' on multi-methods, no?

[14:47] <jnthn> class MyType { multi method Str() is export { return "badger" } }

[14:47] <pmichaud> no, I suspect people can write them as plain multisubs also

[14:47] *** kst left
[14:47] <jnthn> Oh, for sure.

[14:47] <pmichaud> but that's not the difficulty

[14:47] <jnthn> But I don't see how it's any more difficult than a plain 'ole multi.

[14:48] <pmichaud> it's not

[14:48] <pmichaud> the difficulty is vtable_invoke on protoobjects

[14:48] <pmichaud> er, type objects

[14:48] <jnthn> Oh!

[14:48] *** kst joined
[14:48] <jnthn> Ah, and this means we need to start storing subs as &foo before we can fix this too...

[14:49] <pmichaud> not necessarily

[14:49] <pmichaud> although that might be where we end up.  That's a conversion I'm not particularly looking forward to.

[14:49] <jnthn> Otherwise how will the proto Str and the multi Str($foo) co-exist in the namespace?

[14:49] <pmichaud> the proto can forward.

[14:50] <jnthn> Huh?

[14:50] <pmichaud> (yes, that's not clean or nice)

[14:50] <jnthn> For sure it can when the sub is &Str

[14:50] <jnthn> But I can only at the moment see the imported multi sub conflicting with the Str proto.

[14:50] <jnthn> e.g. trying to both go into the namespace slot Str.

[14:51] <pmichaud> I'm sure there are ways around it.  That said, I'm not sure I want to do any of those ways.

[14:51] <jnthn> rakudo: multi Str($x) { say "badger" };  Str(42)

[14:51] <p6eval> rakudo a89161:  ( no output )

[14:51] <pmichaud> std:  multi Str ($x) { say 'badger' };  

[14:51] <p6eval> std 27009: OUTPUT«ok 00:02 37m␤»

[14:51] <pmichaud> hmmm.

[14:51] <pmichaud> std:  multi Str foo($x) { say 'badger' };  

[14:52] <p6eval> std 27009: OUTPUT«##### PARSE FAILED #####␤Malformed block at /tmp/kFD2rGlZWR line 1:␤------> [32mmulti Str [31mfoo($x) { say 'badger' };[0m␤    expecting any of:␤ blockoid␤ routine_def␤      terminator␤       trait␤FAILED 00:02 35m␤»

[14:52] <jnthn> (btw, I just did that in my local Rakudo. It segv'd.)

[14:52] <jnthn> Yes, that's a syntax error

[14:52] <pmichaud> std:  multi sub Str ($x) { say 'badger' };  

[14:52] <p6eval> std 27009: OUTPUT«ok 00:02 37m␤»

[14:52] <pmichaud> std:  multi sub Str foo($x) { say 'badger' };  

[14:52] <p6eval> std 27009: OUTPUT«##### PARSE FAILED #####␤Malformed block at /tmp/QWHcfuOrFq line 1:␤------> [32mmulti sub Str [31mfoo($x) { say 'badger' };[0m␤    expecting any of:␤     blockoid␤ routine_def␤      terminator␤       trait␤FAILED 00:02 35m␤»

[14:52] <pmichaud> okay.

[14:52] <jnthn> std: our Str multi sub foo($x) { say 'badger mushroom' }

[14:52] <p6eval> std 27009: OUTPUT«ok 00:02 37m␤»

[14:52] <jnthn> Needs mushroom

[14:53] <pmichaud> std:  our Str foo($x) { ... }

[14:53] <jnthn> erm, I mean, needs a scope decl.

[14:53] <p6eval> std 27009: OUTPUT«##### PARSE FAILED #####␤Whitespace is required between alphanumeric tokens at /tmp/t5ynAqTx3j line 1:␤------> [32mour Str [31mfoo($x) { ... }[0m␤    expecting any of:␤  declarator␤       multi_declarator␤ typename␤FAILED 00:02 35m␤»

[14:53] <jnthn> And a routine decl. :-)

[14:53] <pmichaud> indeed.

[14:53] <jnthn> Which is afaik what Rakudo needs too.

[14:53] <pmichaud> anyway, converting to use '&' on subnames is going to pose some serious library conflicts.

[14:54] <pmichaud> (with PGE and PCT)

[14:54] <jnthn> rakudo: multi Str($x) { say "badger" }; say "alive"

[14:54] <p6eval> rakudo a89161:  ( no output )

[14:54] <jnthn> That segv's too

[14:54] <jnthn> Ah? Can PGE and PCT switch too?

[14:54] <pmichaud> likely no.

[14:54] <jnthn> Youch.

[14:55] <pmichaud> I'm also not sure if method names should get &'s as well

[14:55] <pmichaud> i.e., does it become   $P0.'&foo'(...)   ?

[14:55] <pmichaud> I suspect not.

[14:55] <jnthn> I suspect not too.

[14:55] <pmichaud> (an exported method should definitely have the & on its symbol table entry, but I'm not sure about the methodn name itself)

[14:55] <jnthn> But OTOH they should get entries in the lexpad or namespace with an &.

[14:56] <jnthn> OK, looks like we're agreeing. :-)

[14:57] <pmichaud> switching to & also means we have to be a lot more rigorous about when we stick things directly into a namespace (via namespace_keyed) and when we use 'add_sub'

[14:57] <pmichaud> er, set_pmc_keyed

[14:58] <jnthn> Ah yes, the typed interface fun.

[14:58] <pmichaud> and set_*_global

[14:58] <jnthn> Yay, of and returns now check implicit return values too.

[15:00] * jnthn does a spectest run in case there are any waiting surprises

[15:02] *** Jedai left
[15:07] <pmichaud> jnthn: likely to need my suggestions/ideas for anything else this morning?  I'm going to be having to do some errands shortly

[15:07] <pmichaud> (which will require ~3 hrs total)

[15:07] *** iblechbot joined
[15:07] <jnthn> pmichaud: I've not got much planned other than looking through tickets today.

[15:08] <jnthn> pmichaud: Unless there's anything you'd like me to work on.

[15:08] <pmichaud> nothing specific

[15:08] <jnthn> Oh, I might hack on the Perl6MultiSub hll_map branch too...

[15:08] <pmichaud> looking through tickets sounds really good -- I did some of that earlier in the week.

[15:08] <pmichaud> I found many that could be closed, or easily closed.

[15:08] <jnthn> Aye, we've plenty of 'em.

[15:14] <pmichaud> okay, I'm afk for a while

[15:14] <pmichaud> bbl

[15:20] <pugs_svn> r27010 | jnthn++ | [t/spec] Correct a type constraint.

[15:20] *** donaldh left
[15:20] <pugs_svn> r27011 | jnthn++ | [t/spec] Tests for type checking of implicitly returned values.

[15:21] *** donaldh joined
[15:22] *** Jedai joined
[15:23] *** unitxt joined
[15:24] <dalek> rakudo: fb2fd43 | jnthn++ | src/parser/actions.pm:

[15:24] <dalek> rakudo: Make sure we type check implicit return values for of and returns also. Completely resolves RT#65128.

[15:24] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/fb2fd43d4096fe46d5a988d0700a1dccc3b39900

[15:24] <DanielC> What does "$sel:" mean in somemethod($self:)  mean?

[15:24] <DanielC> What does "$sel:" mean in somemethod($self:)?

[15:24] <DanielC> s/sel:/self:/

[15:24] * DanielC can't type today

[15:25] *** ejs1 joined
[15:27] <[particle]-> it's the invocant

[15:27] <DanielC> If I don't plan to use it, do I still need it?

[15:27] <[particle]-> $self.somemethod($a) == somemethod($self: $a)

[15:28] * DanielC is having some trouble here

[15:28] <[particle]-> it's not much of a method if you don't need the invocant

[15:28] *** ejs1 left
[15:28] <jnthn> DanielC: You can access it via self normally

[15:29] <jnthn> DanielC: It's useful if you want to take the invocant into a variable of a different name, or apply extra constraints to it.

[15:29] <[particle]-> oh, right, you can name it by whatever ...

[15:29] <[particle]-> jnthn++

[15:29] <DanielC> What do you mean "access it via self"?

[15:29] <jnthn> The self keyword

[15:29] <DanielC> ah

[15:29] <jnthn> self.foo within a method calls foo on self

[15:30] <jnthn> As in, the current instance

[15:30] <DanielC> So I can write self.somemethod() inside a class.

[15:30] <jnthn> Right.

[15:30] <[particle]-> method foo { say self.bar() }

[15:30] <jnthn> But $.somemethod() is shorter and usually just fine. :-)

[15:30] <[particle]-> method foo { say $.bar() }

[15:30] <DanielC> Ok, that looks better than the exclamation mark way:  $self!bar()

[15:30] <[particle]-> method foo($this) { say $this.bar() }

[15:30] <[particle]-> er

[15:30] <jnthn> That's for calling your privates.

[15:30] <DanielC> self.bar()  <-- better

[15:30] <[particle]-> method foo($this:) { say $this.bar() }

[15:31] <DanielC> jnthn: I'm trying to see if I can simplify your RPN calculator a bit so it is easier to explain how it works.

[15:31] <[particle]-> . is used to call public methods

[15:31] <[particle]-> ! is used to call private methods

[15:31] <DanielC> ok

[15:32] <DanielC> and "my method" makes it private.

[15:32] <jnthn> DanielC: I think by now that's outdated.

[15:32] <DanielC> Ok.

[15:32] <jnthn> I think you write method !secret_thingy() { }

[15:32] <DanielC> It seems to work though.

[15:33] <jnthn> Aye, I think Rakudo trails the spec there.

[15:33] <DanielC> ok

[15:33] <DanielC> !secret_method() is more consistent with the syntax for public and private variables.

[15:33] <jnthn> *nod*

[15:34] <DanielC> Do you write  'method !secret()' or '!method secret()' ?  I assume the former.

[15:34] *** ejs2 left
[15:35] <jnthn> rakudo: class Foo { method !affair() { say "shhh" }; method what_you_doing() { self!affair(); return "washing up" } }; say Foo.new.what_you_doing

[15:35] <p6eval> rakudo a89161: OUTPUT«shhh␤washing up␤»

[15:35] <jnthn> Like that.

[15:35] <DanielC> thanks

[15:42] <pugs_svn> r27012 | pmurias++ | [re-smop] :($foo is ref)

[15:45] <pmurias> ruoso: is copy should work by calling .clone?

[15:47] *** hudnix left
[15:47] <pmurias> ruoso: it seems it must deal with readonly container specially so it won't be enough

[15:51] *** nihiliad left
[15:51] *** sri_kraih joined
[15:55] <TimToady> I don't think Str should be a multi

[15:55] <TimToady> Str produces a type object, which responds to .()

[15:55] <TimToady> that's all

[15:56] <TimToady> well, that's the top view, I guess you still need a way to specify different coercions by type

[15:57] <jnthn> TimToady: OK fine but then what does it do in response the .()?

[15:57] <jnthn> Call $the-thingy-passed.MyTypeName?

[15:57] *** justatheory joined
[15:57] <TimToady> not sure, lemme drink some coffee before spouting off further

[15:58] <jnthn> :-)

[15:59] <DanielC> jnthn: Is your RPN calculator supposed to be able to handle a more complex expression like "3 4 - 5 +" ?

[15:59] <TimToady> I think Str's .($x) calls $x.Str as a normal method

[15:59] <jnthn> TimToady: OK.

[16:00] <jnthn> TimToady: How does this play out with multi-joined names?

[16:00] <TimToady> because Str is a known type, it ignores any following () syntactically

[16:00] <jnthn> DanielC: I can't remember now...

[16:00] <DanielC> ok

[16:00] <TimToady> multi-joined names?

[16:00] <jnthn> class Foo::Bar { }

[16:01] <jnthn> Foo::Bar($x) # I want to coerce $x to a Foo::Bar

[16:01] <jnthn> $x."Foo::Bar" # but how to define that method?

[16:01] <TimToady> good question, more coffee

[16:01] <jnthn> :-)

[16:04] <jnthn> CDD # Caffeine Driven Development

[16:04] *** hercynium joined
[16:05] *** tulcod joined
[16:06] <pmichaud> yes, I remember TimToady saying once before that Str responded to .(), which is why I was thinking that & wasn't an issue for us here.

[16:06] <pmichaud> (back from errands part 1)

[16:08] <pmichaud> however, that does mean that Str() acts somewhat differently from the now-normal notions of if(), loop(), e(), rand(), etc.

[16:08] <pmichaud> (i.e., that immediate parens always indicate a sub call)

[16:12] <jnthn> pmichaud: In src/parser/expression.pir we have a comment:

[16:12] <TimToady> if we think of everything in terms of an abstract multi coerce(From,To), then .() is coerce(Any,Str)

[16:12] <jnthn> (FIXME Parrot bug RT#53296 prevents us from using :optional

[16:12] <jnthn> on the C<tighter> argument along with :slurpy :named parameters,

[16:12] <jnthn> so we use :multi as a temporary workaround.)

[16:12] <pmichaud> I think that bug has since been fixed.  Is it still using :multi?

[16:12] <jnthn> pmichaud: Do you know if that workaround can go away?

[16:13] <jnthn> pmichaud: It is still using multi, and it just exploded onto the scene in my hll_map Perl6Multi branch. :-)

[16:13] <pmichaud> if you can get it to work with   .param pmc tighter :optional, then yes, it can go away.

[16:13] <jnthn> pmichaud: OK, I'll try that.

[16:13] <DanielC> jnthn: Is this valid? rule Expr { <Value> | <Expr> <Expr> <Op> };

[16:14] <pmichaud> DanielC: it'll infinitely recurse

[16:14] <jnthn> pmichaud: Not if it parses a <Value> first, no?

[16:14] <DanielC> pmichaud: Until it hits values.

[16:14] <TimToady> | is parallel

[16:14] <DanielC> :-(

[16:14] <jnthn> Or do we need || for that?

[16:14] <pmichaud> If it doesn't find a <Value>, it'll infinitely recurse (in PGE)

[16:14] <jnthn> Right, I suspect that's what it relies on.

[16:15] <DanielC> yes

[16:15] <jnthn> If that was taken from the RPN example.

[16:15] <DanielC> Yes. It's a variation on jnthn's RPN example.

[16:15] <DanielC> You'd need to write a different class to manage the parse tree, but I figure that the above (recursive) regex is the "correct" parse tree.

[16:15] <jnthn> pmichaud: Does this mean we're saving ourselves a Parrot multi-dispatch per time we enter the expression parser? :-)

[16:16] <DanielC> rule Expr { <Value> || <Expr> <Expr> <Op> };

[16:16] <pmichaud> jnthn: yes, but I don't think that's significant from a time perspective.  (I'd be happy to be wrong about that, though.)

[16:17] <jnthn> pmichaud: I doubt it'll be a big difference.

[16:17] <pmichaud> jnthn: same here

[16:17] <jnthn> pmichaud: Just a little nice to have.

[16:17] <pmichaud> I'm looking for the original rt ticket that it was supposedly referring to

[16:17] <pmichaud> I guess I typoed it

[16:18] <jnthn> pmichaud: What might be a nicer win is that currently every infix:= to a scalar has to check it isn't really a Perl6Array or a Perl6Hash and then re-dispatch.

[16:18] <jnthn> Because Parrot's MMD didn't always get us the correct answer.

[16:18] <pmichaud> yes, that will indeed be nicer

[16:19] <pmichaud> the original bug was 53926

[16:19] <pmichaud> (transposed 2 and 9)

[16:19] <jnthn> We lose two isa-s and gain multi-dispatch caching.

[16:19] <jnthn> Ah, OK.

[16:20] <pmichaud> did you see that I split deref_objectref into two different opcodes?

[16:20] <jnthn> Yes

[16:20] <jnthn> Makes sense.

[16:21] <jnthn> Guess they are two different operations.

[16:21] <pmichaud> well, sometimes I need to completely dereference something (e.g., for dispatch)

[16:21] <pmichaud> other times we need to dereference only ObjectRefs

[16:21] <jnthn> *nod*

[16:21] <pmichaud> (so that we stop at a scalar)

[16:25] <ruoso> pmurias, re: is copy.... I think that's a question for TimToady... I'm not sure the spec is very clear on that...

[16:28] *** pmurias left
[16:29] *** Util joined
[16:31] * jnthn suspects a lot of the things in the PIR built-ins that are currently marked as multis may not be in the spec...

[16:31] *** hanekomu_ joined
[16:32] <jnthn> oh no, a lot of them are...

[16:33] <TimToady> I think maybe any surface coercion syntax ends up calling COERCE($x,Str), where class Str redirects &.() into an autogenerated COERCE(Any,Str), but class Rat redirects method Str into an autogenerated COERCE(Rat,Str)

[16:33] <TimToady> and the optimizer is always free to call COERCE directly if it can deduce that

[16:33] *** Psyche^ joined
[16:34] * pmichaud notes his "spec volatility" comment was spot-on again :-)

[16:35] <TimToady> but my $s = Str; $s.($x) still works, as does $x.$s

[16:35] <TimToady> or maybe COERCE is spelled infix:<as>

[16:36] <[particle]-> hrmm... we should have a spec volatility metric generated regularly

[16:36] <pmichaud> it still needs to be a trait or something, yes?

[16:36] <pmichaud> my sub foo($x as Str) { ... }

[16:36] *** rocket_guatemala joined
[16:36] <TimToady> that just turns any return $x into return $x as Str

[16:36] *** kst left
[16:36] <pmichaud> I mean from a parsing perspective.

[16:36] <TimToady> yes, the trait is just factoring out the operator

[16:36] *** rocket_guatemala left
[16:36] <pmichaud> okay.

[16:37] <TimToady> as a convenience

[16:37] <pmichaud> and actually, it's modifying $x, not the return value, right?

[16:37] *** kst joined
[16:37] * pmichaud sends TimToady some more caffeine.

[16:37] <TimToady> why would $x need to be modified?

[16:38] <pmichaud> isn't  my sub foo($x as Str)   different from   my sub foo($x --> Str )  { ... }

[16:38] <pmichaud> or am I way off again?

[16:38] <pmichaud> I thought that   $x as Str   coerced $x into a Str

[16:38] <TimToady> oh, on the input side

[16:38] *** rocket_guatemala joined
[16:38] <TimToady> sorry, didn't have a good night

[16:38] <TimToady> I was thinking sub foo($x) as Str

[16:39] <pmichaud> yes, in that case it parses "traitish" as well.

[16:39] <pmichaud> I'm fine with infix:<as>  -- just wanted to make sure the trait existed still.

[16:40] <TimToady> I view the parameter trait as binding to an anonymous temporary, then $x := $temp as Str

[16:40] <pmichaud> agreed

[16:40] <pmichaud> that's the way I've tended to think of it.

[16:40] <TimToady> but $x never can be rw

[16:41] <TimToady> well, can't refer to the arg

[16:41] <TimToady> as rw

[16:41] <pmichaud> agreed again.

[16:41] <TimToady> as implies copy

[16:41] <pmichaud> 16:35 <TimToady> but my $s = Str; $s.($x) still works, as does $x.$s

[16:41] <pmichaud> $x.$s confuses me.

[16:41] *** kst left
[16:41] <rocket_guatemala> hi, I am doing some work on the tests and i have a question: should the t/run be moved to the t/spec/S19 folder?

[16:42] <pmichaud> rocket_guatemala: if you're reasonably sure it's up-to-date with respect to the specs, then yes, please do so.

[16:42] *** donaldh left
[16:42] *** kst joined
[16:42] <rocket_guatemala> great, ill check each one before moving them

[16:42] <TimToady> pmichaud: it confuses me too

[16:42] <pmichaud> rocket_guatemala: that's the correct process, many thanks!

[16:43] <pmichaud> rocket_guatemala: if you end up with questions, [particle] is the current lead on that synopsis :-)

[16:43] <TimToady> just trying to indicate that $x."Str" would still work even if the optimizer doesn't turn it into infix:<as>

[16:43] <pmichaud> (but you can ask any of us and we'll venture an opinion)

[16:43] <pmichaud> I'm fine with $x."Str", so we're good there.

[16:44] <rocket_guatemala> thanks, ill chime in if i have any other question

[16:45] <TimToady> my basic point is that defining either .() or .Str still allows that syntax, but also guarantees the corresponding deep infix:<as> exists with appropriately typed args

[16:46] <pmichaud> it seems to me that there's also a difference between .() on a type object and .() on an instance

[16:46] <TimToady> sure, it's the abstraction thing again

[16:46] <pmichaud> i.e., if I define  method postcircumfix:<( )> { ... }   then I want to distinguish whether my invocant is the type object or an instance.... right

[16:47] *** hanekomu left
[16:49] *** Psyche^ is now known as Patterner

[16:49] <pmichaud> would something like     $x as 3    result in coercing $x to Int (the same type as 3) or a "no matching sub"?

[16:49] <pmichaud> i.e., is  infix:<as>  typically     infix:<as>($x, Abstraction $y)   ?

[16:50] <TimToady> no matching, I'd think

[16:50] <pmichaud> actually, I have a more general question

[16:51] <pmichaud> sometimes it seems as though methods delegate to operators

[16:51] <pmichaud> other times it seems as though operators delegate to methods

[16:51] *** ashizawa joined
[16:51] <pmichaud> in this particular instance, if I have

[16:51] <pmichaud> class A { method Str() { ... } }

[16:51] <pmichaud> then how does   my $a = A.new;   $a as Str

[16:51] <pmichaud> play out?

[16:52] <TimToady> if you have a more general question then I'll have a less specific answer :)

[16:52] <TimToady> thinking...

[16:52] <pmichaud> my more general question would be  "is there a guide for methods calling operators or vice versa"?

[16:53] <pmichaud> This also relates to the relationship of prefix:<?>, .bool, .Bool, .true, etc (more)

[16:53] <TimToady> yes, that's a question that's been niggling my subconscious for some time too

[16:53] <pmichaud> but we also have  prefix:<~>, .Str, and now  infix:<as>

[16:53] <pmichaud> and similar issues with prefix:<+>, .Num, .Int, ....

[16:53] *** mizioumt1 joined
[16:54] <pmichaud> fwiw, the model with .ACCEPTS and how it relates to type matching and infix:<~~>  seems to work very well in practice.

[16:54] <pmichaud> I don't know if there are parallels to be drawn here.

[16:55] <TimToady> overall my impression is that single dispatch tends to be more primitive than multi, but either there exceptions, or we're missing a level somewhere

[16:55] <TimToady> *there are

[16:55] <pmichaud> I'm fine with single dispatch being more primitive than multi -- I'd just be curious which are the single dispatchy things

[16:55] <pmichaud> the operators?  the methods?

[16:57] <TimToady> all surface operators are conceptually multi dispatch, even if unary

[16:58] <pmichaud> then if I'm understanding correctly, that would seem to argue in favor of operators-defined-in-terms-of-methods

[16:58] <TimToady> multi vs single is where we distinguish language-forcing from OO-forcing semantics

[16:58] <TimToady> in general

[16:58] <TimToady> and as does look a lot like the reverse dipatch of ACCEPTS

[16:59] <pmichaud> (side note:  we might want to think about how someone defining .ACCEPTS for a class keeps from overriding the typecheck form of .ACCEPTS for the type object.  Does the class definer have to remember to constrain the .ACCEPTS invocant to avoid grabbing the type object?)

[16:59] <TimToady> with secondary dispatch on the first arg

[17:00] <TimToady> which is why I wanted some easier syntax than Abstraction

[17:00] <TimToady> that can be negated

[17:00] <pmichaud> makes sense.  Although we could have  Concrete that is just the opposite of Abstraction :-)

[17:00] <TimToady> where { $_ !~~ Abstraction } is much too heavy

[17:01] <pmichaud> method ACCEPTS(Concrete $x: ...) { ... }

[17:01] <TimToady> well, something also to be said for that being the default

[17:01] <jnthn> multi method...

[17:01] <TimToady> and something else that means Abstraction|Concrete

[17:01] <jnthn> Object :-)

[17:01] <pmichaud> Maybe Abstraction isn't a subclass of Any

[17:02] <pmichaud> or Any is somehow constrained to !Abstract

[17:02] <jnthn> I think the thing to also keep in mind is that this is kinda "special" in that it almost breaks the rules of "no multiple prefix constraints"

[17:02] * TimToady starts picking up the pieces of his brain

[17:02] <jnthn> And also it's something that we want to be able to recognize and optimize (heavily) in the dispatcher.

[17:03] <TimToady> I was thinking of syntax more on the line of ! and ?

[17:04] <pmichaud> I thought about that also.

[17:04] <pmichaud> Seems like there might be cases where we'd want to say "anything _except_ this type :-)"

[17:04] <TimToady> wheren't Abstraction

[17:04] <[particle]-> prefix:<*>

[17:05] <pmichaud> exclude

[17:05] <pmichaud> sub foo($x excluding Abstraction ...)

[17:05] <TimToady> these are all pretty toxic

[17:05] <pmichaud> still probably too long :-)

[17:05] <pmichaud> well, errands part 2 is upon me, so I'll come back and read the solution in backscroll (hope hope)

[17:06] *** tulcod left
[17:07] <[particle]-> toxic, for sure.

[17:07] <TimToady> $x sans Abstraction is betterer

[17:08] <[particle]-> oh, great. french.

[17:08] <TimToady> $x sans { $_ % 2 }

[17:08] <[particle]-> what's the texas form of that?

[17:09] <TimToady> $x without_none_o'_that_thar Abstraction

[17:09] <TimToady> though that's more hillbilly, I guess

[17:11] <TimToady> shower &

[17:13] *** rocket_guatemala left
[17:15] *** M_o_C joined
[17:15] *** mizioumt left
[17:15] *** nihiliad joined
[17:23] *** broquaint left
[17:27] <pmichaud> 16:35 <TimToady> but my $s = Str; $s.($x) still works, as does $x.$s

[17:27] <pmichaud> oops

[17:27] <pmichaud> ignore that past-o

[17:30] <pmichaud> $x whole-nuther-thing Abstraction  # probably

[17:31] <pmichaud> or maybe

[17:31] <pmichaud> oh, never mind.  :-)

[17:31] <rjh_> $x not { $_ % 2 }, $x not Abstraction :)

[17:32] <pmichaud> $x butnot Abstraction 

[17:32] <rjh_> yeah, the negation should be longer than 'where'

[17:32] <rjh_> larry loves his huffman encoding

[17:33] <pmichaud> oh?  Then why is "no" shorter than "use"?   ;-)

[17:33] <pmichaud> it's 33% shorter, in fact.

[17:33] <pmichaud> and "not" is shorter than "true"  (25%)

[17:33] <rjh_> that's a point

[17:33] <rjh_> can we finally have don't { } blocks

[17:33] <pmichaud> and ! has a lot fewer 1-bits than ?

[17:34] <rjh_> you need to be less optimistic and start using "no" and "not" more often :)

[17:34] <pmichaud> even the frowny :-(  comes before the smiley :-)

[17:35] <rjh_> std: my $don't = 0;

[17:35] <pmichaud> rakudo:  say ":-(" lt ":-)"

[17:35] <p6eval> std 27012: OUTPUT«ok 00:02 36m␤»

[17:35] <p6eval> rakudo fb2fd4: OUTPUT«1␤»

[17:36] <jnthn> gaaahhh

[17:36] <rjh_> rakudo: sub don't (*@) { }; don't { say "Hello!" }

[17:37] <p6eval> rakudo fb2fd4:  ( no output )

[17:37] * jnthn changes Signature!add_param to not require a junction to be passed if if there's just one type...

[17:37] <jnthn> pmichaud: I implemented the "auto-generated a Signature by arity" thing, btw.

[17:37] <jnthn> pmichaud: Got that bit working now. :-)

[17:38] <pmichaud> oh, nice!

[17:39] <jnthn> Not caching 'em for sharing purposes yet - will do that later once I get things working.

[17:39] <jnthn> (Working in a branch)

[17:45] <jnthn> Ouch.

[17:45] <jnthn> (sitting in an infinite loop at startup)--

[17:47] <Tene> rakudo: sub circumfix:<:-( :-)> { say "☹ $^msg ☺" }; :-( "hi guys" :-)

[17:47] <p6eval> rakudo fb2fd4: OUTPUT«☹ hi guys ☺␤»

[17:47] <jnthn> omg

[17:48] <Tene> I read "the frowny :-(  comes before the smiley :-)" at the top of my buffer before scrolling up to read context, and thought of that.

[17:49] <jnthn> It's sick and wonderful that Rakudo can do that. :-)

[17:50] <Tene> TimToady: I see you using "use Foo:from<ruby>;" or some such in scrollback a while ago.  Is that actually specced?  Rakudo currently uses :lang<...>;

[17:54] *** nsh- joined
[17:55] *** PacoLinux joined
[18:01] *** PacoLinux left
[18:01] <DanielC> rule Expr { <Value> || <Expr> <Expr> <Op> };  <--- doesn't do what I want because Rakudo seems to match the smallest possible token.

[18:02] <DanielC> So if your string is "2 2 +" Rakudo only matches the first "2" instead of the whole string.

[18:02] <Tene> DanielC: put it inside of a rule that's like:

[18:02] <Tene> rule Foo { ^^ <Expr> $$ }

[18:02] <DanielC> ok

[18:03] <DanielC> Well, that did something... Now it doesn't recognize "2 3 +" as an expression...

[18:03] <DanielC> if $expr ~~ / ^^ <Expr> $$ /

[18:04] <jnthn> DanielC: I think I originally had it as rule TOP { ^ <Expr>+ $ }

[18:04] <TimToady> Tene: see S11:421

[18:05] <Tene> Ah.

[18:05] <Tene> Thanks.

[18:06] <DanielC> jnthn: I'd have to remove the + because with the new Expr rule I wrote, the whole thing is an expression.

[18:06] <TimToady> DanielC: you really mustn't do it with left recursion; that doesn't work in recursive descent

[18:06] <DanielC> ok

[18:06] <TimToady> then you've written an ambiguous grammar, probably

[18:06] <DanielC> So I'm barking up the wrong tree here. What is the correct way to do it?

[18:07] <DanielC> You'd think a grammar for a RPN calculator would be simple...

[18:07] <TimToady> to stick with recursive descent, you need to split the Expr concept into can-be-first, can't be first

[18:07] *** PacoLinux joined
[18:07] <TimToady> or you use a bottom up parser as a rule like STD does

[18:07] <TimToady> "as simple as possible, but no simpler"

[18:08] <DanielC> :-)

[18:08] <DanielC> I think I have a lot to learn about grammars.

[18:08] <DanielC> This is my first attempt to write a grammar for anything.

[18:09] <TimToady> figure out what distinguishes the first Expr from the second Expr, then you can do recursive descent

[18:09] <DanielC> ok

[18:09] * DanielC starts thinking

[18:09] <TimToady> but as it is, it's like writing a factorial function without an end condition

[18:09] *** nsh- left
[18:09] * DanielC was hoping that <Value> would be the end condition...

[18:10] <TimToady> what's the end condition between the two Exprs though, is the point

[18:11] <TimToady> but more generally, it's kinda strange to use a top-down parser to parse something that is designed to be processed bottom-up

[18:11] <TimToady> (reverse polish)

[18:12] <DanielC> I don't even know the difference between a top-down parser and a bottom-up parser.

[18:12] *** nsh- joined
[18:12] <PerlJam> DanielC++ trying to do something beyond your understanding.

[18:12] <PerlJam> :-)

[18:12] <DanielC> :)

[18:13] <DanielC> TimToady: The objective of this exercise is for me to learn something about grammars, so it's not surprising that I'm making elementary mistakes.

[18:14] <DanielC> Can anyone give me a link that explains the difference between a top-down and a bottom-up parser?

[18:14] <PerlJam> google can help with that.

[18:14] <PerlJam> or wikipedia

[18:15] <DanielC> I find that wikipedia often gives very broad explanations for a concept, so I may have trouble relating it to Perl.

[18:15] <DanielC> But I'll try wikipedia.

[18:15] <TimToady> http://www.google.com/search?q=top-down+bottom-up+parser

[18:15] * DanielC starts reading

[18:16] <TimToady> don't get distracted :)

[18:16] *** nsh- left
[18:26] *** DemoFreak joined
[18:29] *** bkeeler joined
[18:32] *** justatheory left
[18:32] <bkeeler> rakudo: grammar Foo { rule TOP { <ww> } }; Foo.parse("foo")

[18:32] <p6eval> rakudo fb2fd4: OUTPUT«Unable to find regex 'ww'␤Null PMC access in invoke()␤in regex Foo::TOP (/tmp/Iw6E4bKMzm:2)␤called from Main (/tmp/Iw6E4bKMzm:2)␤»

[18:32] <bkeeler> rakudo: grammar Foo is PCT::Grammar { rule TOP { <ww> } }; Foo.parse("foo")

[18:33] <p6eval> rakudo fb2fd4:  ( no output )

[18:33] *** gegloe joined
[18:33] <bkeeler> I shouldn't have to sub-grammar PCT::Grammar to get <ww> should I?

[18:34] <PerlJam> is <ww> spec?

[18:34] <pmichaud> you might -- I don't think <ww> has been added to PGE yet.

[18:34] <pmichaud> Yes, <ww> is now spec.

[18:34] <pmichaud> at least, it was spec last time I checked.

[18:34] <bkeeler> It's in S05 for sure

[18:35] <pmichaud> I can add <ww> to PGE pretty simply.

[18:35] <pmichaud> and then it'll show up by default.

[18:35] <bkeeler> That would be nice

[18:35] *** synth joined
[18:37] *** justatheory joined
[18:37] <PerlJam> Is there a way to see what rules a grammar has?

[18:37] <pmichaud> .methods?

[18:38] <pmichaud> rakudo:  Grammar.methods>>.say

[18:38] <p6eval> rakudo fb2fd4: OUTPUT«Method 'methods' not found for invocant of class ''␤»

[18:38] <jnthn> meta

[18:38] <pmichaud> hmmm.

[18:38] <jnthn> .^

[18:38] <pmichaud> rakudo:  Grammar.^methods>>.say

[18:38] <rjh_> rakudo: Grammar.^methods>>.say

[18:38] <p6eval> rakudo fb2fd4: OUTPUT«parse␤parsefile␤»

[18:38] *** ispy_ joined
[18:38] <rjh_> snap!

[18:38] <pmichaud> there are likely more than this -- right now I'm not sure how Rakudo's Grammar type is interacting with PGE::Grammar

[18:39] <pmichaud> I'm a little surprised it only came back with parse and parsefile, though.

[18:40] <TimToady> thinking more about abstraction and failure, I'm wondering if "while foo() -> $var {...}" should be defined as running until the binding fails, where presumably an undefined return from foo() fails to bind

[18:40] <pmichaud> that somewhat goes against the notion of    if $x { }  else -> $y { }   those

[18:40] <pmichaud> *though

[18:41] <pmichaud> not a big loss, but different.

[18:41] <TimToady> else -> $y where Abstraction

[18:41] <TimToady> or whatever sugar it turns out to be

[18:42] <pmichaud> it does seem like a good idea to not propagate failures except where explicitly allowed

[18:42] <TimToady> it's almost a variant of  else -> $y?

[18:42] <pmichaud> i.e., passing a Failure to a function that isn't prepared to handle it could be a form of "using the failure should throw the exception"

[18:42] <TimToady> could we overload ? to mean undef allowed?  hmm

[18:42] <pmichaud> that seems odd.

[18:43] <TimToady> or -> $y// somehow

[18:43] <pmichaud> I did (75% jokingly) suggest prefix:<//> in the meeting the other day.  :-)

[18:43] <TimToady> I'm thinking more suffix, since stands in for a where

[18:43] <pmichaud> sure.

[18:43] *** ispy_ left
[18:44] <pmichaud> that could work, but it doesn't have that "ring of truth" about it to me yet.

[18:44] <DanielC> PerlJam: Well... I think I have a bottom-up implementation. It works, but it's not very elegant. http://sial.org/pbot/37055

[18:44] <[particle]-> $m//

[18:45] <DanielC> PerlJam: Oops, that's missing the do_op() function, but you can guess what it does.

[18:45] <[particle]-> $y?

[18:46] <[particle]-> that doesn't really work in sigs

[18:47] <pmichaud> I wonder if/how this relates to the fact that we allow any scalar to hold undefs regardless of type constraint

[18:47] <pmichaud> the fact that it wouldn't bind by default but would assign by default seems... weird.

[18:47] <[particle]-> wait, what?

[18:47] <[particle]-> my int $x = 3; $x = undef; # no earth-shattering kaboom?

[18:48] <pmichaud> rakudo:  my Int $x = 3;  $x = undef;

[18:48] <p6eval> rakudo fb2fd4:  ( no output )

[18:48] <pmichaud> rakudo:  my Int $x = 3;  $x = undef;   say "no kaboom"

[18:48] <p6eval> rakudo fb2fd4: OUTPUT«no kaboom␤»

[18:48] <[particle]-> that's Int, and that i get.

[18:48] <[particle]-> i'm talking int.

[18:48] <TimToady> that's defined to kaboom anyway

[18:48] <pmichaud> sure, that kabooms

[18:48] <[particle]-> ok

[18:49] <[particle]-> that matches my expectations.

[18:49] <[particle]-> is 'int' not 'Scalar'?

[18:50] <TimToady> it's essentially the Just vs Maybe distinction of Haskell, we need a notation on the type itself as to whether it should be considered a subset that disallows undef

[18:50] <TimToady> and a decision on whether that should be default

[18:51] <StephenPollei> I thought section 02 said int couldn't hold a undef, I don't recall for certain

[18:51] <TimToady> because native types are naturally subset types

[18:52] <TimToady> and int in particular has no representation for undf

[18:52] <TimToady> *undef

[18:52] <TimToady> whereas num could translate at least some undefs to NaN

[18:52] <StephenPollei> thats what I recall S02 saying

[18:53] <pmichaud> S02 says that non-native typed variables can hold undef

[18:53] <pmichaud> native typed variables cannot (with the num exception that TimToady++ just cited)

[18:53] <StephenPollei> my int $y = undef;    # dies

[18:53] <TimToady> the can, but that's independent of whether the type check acts as a subset constraint or not

[18:53] <StephenPollei> my Int $x = undef;    # works

[18:53] <pmichaud> My original statement should've probably said "any non-native type constrained scalar"

[18:53] *** ruoso_ joined
[18:54] <pmichaud> In general I'm not referring to native types in any way, shape, or form unles I explicitly say so :-)

[18:54] <pmichaud> *unless

[18:54] <pmichaud> my original point was that    we allow 

[18:54] <pmichaud>    my Int $x = undef;

[18:54] <pmichaud> but would seemingly disallow

[18:54] <[particle]-> (Just vs Maybe)++

[18:55] <pmichaud>    sub foo(Int $x) { ... };    foo(undef)

[18:56] <[particle]-> so, in general, core non-native types follow 'maybe' semantics

[18:56] <[particle]-> native types follow 'just' semantics

[18:56] <[particle]-> but there are exclusions, in that some non-native types want 'just' semantics

[18:57] <TimToady> so even if we leave that default, we could tell people to write something like: while foo() -> just $x

[18:57] <[particle]-> and there needs to be a way to distinguish the semantics

[18:57] *** masak joined
[18:57] <masak> oh hai

[18:57] <TimToady> but really just Str $x

[18:57] <TimToady> if it modifies the type constraint

[18:57] <TimToady> well, I suppose just $x means just Any $x

[18:57] <pmichaud> I'm afraid I don't completely understand the meaning behind 'just' and 'maybe'

[18:58] <StephenPollei> multi sub foo(Int $x) { ... };    multi sub foo(Str $x) { ... }; foo(undef)

[18:58] <TimToady> as opposed to "not just any $x"  :)

[18:58] <[particle]-> Just = only this type and not undefined things

[18:58] <TimToady> haskell doesn't have the anti-just sense, afaik

[18:58] <pmichaud> that doesn't match my sense of "just"'s english meaning, though.

[18:58] <TimToady> the the don't care sense of maybe

[18:58] <pmichaud> To me, "just Int"  would mean "Int and only Int,"

[18:58] <TimToady> s/the/just

[18:59] <TimToady> not suggesting that syntax

[18:59] <TimToady> just trying to nail down the fact that it's a modifier on the type, not the $x

[19:00] *** ruoso left
[19:01] <pmichaud> agreed.

[19:01] <TimToady> it would be possible to interpret Int differently by default for assignment than for binding

[19:01] <pmichaud> yes, I thought of that -- that seems strange to me also.

[19:01] <TimToady> if we had a way to mark it either way

[19:02] * jnthn -> dinner, bbiab

[19:02] * masak eagerly waits for the Matt-W/masak hackathon to commence

[19:04] * Matt-W is just putting on some hacking music

[19:04] * masak is putting on his robe and wizard hat

[19:04] <TimToady> just don't put on some putting off hacking music

[19:07] <Matt-W> Right

[19:07] <Matt-W> There we go

[19:07] <masak> Matt-W: I'm looking at http://search.cpan.org/dist/Perl6-Form/Form.pm#Numerical_fields right now. you got an attack plan, or do we just wing it?

[19:08] <Matt-W> I think we throw together a plan, and then we grab hold of it and leap off into the unknown, attempting to use it as a parachute

[19:08] <Matt-W> There are clearly two areas required here

[19:08] <masak> sounds reasonable to me. and perfectly safe.

[19:08] <Matt-W> One is the extension of the grammar and actions and data structures to parse these fields and create the objects to describe them

[19:09] <Matt-W> The other end is the routines which actually do the work - a new Form::NumberFormatting module, I suspect

[19:09] <masak> aye.

[19:09] <Matt-W> And then we just stick them together with a little glue

[19:09] * masak runs './proto update form'

[19:10] <Matt-W> So do you feel more like grammar hacking, or writing formatting routines?

[19:11] <masak> I feel like writing tests!

[19:11] <Matt-W> You don't get out of writing tests either way :)

[19:11] <masak> oh. :)

[19:11] <masak> can I at least write the tests first? :)

[19:11] <Matt-W> Tests go hand in hand!

[19:11] <Matt-W> If you like

[19:11] * masak visualises the tests going hand in hang

[19:11] <masak> er, s/hang/hand/

[19:12] <Matt-W> yes, tests are very friendly and slightly archaic

[19:12] *** bkeeler left
[19:12] <Matt-W> culturally, that is, not at all archaic in software usefulness

[19:12] * Matt-W makes sure form works with latest rakudo

[19:13] *** bkeeler joined
[19:13] <Matt-W> masak: you should be able to push to mattw/form btw

[19:13] <Matt-W> all 100 form tests passing

[19:13] <Matt-W> better fix that

[19:13] <masak> :)

[19:13] *** payload joined
[19:14] <Matt-W> I'll do Form::NumberFormatting

[19:14] <masak> ooh, pmichaud++ # Perl6::Grammar.parse

[19:14] *** justatheory left
[19:14] <masak> I'm not sure I'll get any sleep tonight. :)

[19:14] <eiro> hello guys 

[19:14] <pmichaud> note that it will change to STD.parse at some point.

[19:15] <masak> eiro: o/

[19:15] <masak> pmichaud: yes, of course.

[19:15] <masak> I've lived through change before, I can do it again.

[19:16] <pmichaud> I suppose that as a temporary fix I can do:    grammar STD is Perl6::Grammar { };

[19:16] <pmichaud> :-P

[19:16] <Matt-W> :)

[19:16] <masak> oh, you don't have to. I can do it in my script instead.

[19:19] <sjohnson> hey ma

[19:19] <sjohnson> Matt-W: 

[19:19] <sjohnson> i mean

[19:20] * Matt-W considers how to do number formatting

[19:20] <Matt-W> sjohnson: hello

[19:21] <masak> Matt-W: number format parsing, does it go in its own .t file, or in an existing one, such as 01-fieldparsing.t?

[19:21] <japhb> Tene: ping again # sorry I missed you before

[19:21] <Tene> japhb: hi

[19:21] <japhb> Yay!  You're here.

[19:22] <japhb> .oO( Nice, reception, huh? )

[19:22] <Matt-W> masak: I'd put it in with the parsing tests for text

[19:22] <Tene> AFK, internet sabbatical for the next week.

[19:22] <japhb> OUCH

[19:22] * Tene lies.

[19:22] <Tene> Anyway, what's up?

[19:22] <japhb> I guessed.  :-)

[19:23] <japhb> I'm trying to get OpenGL working with Rakudo again.  Last time I had it working was before the HLL namespace change and your use Foo:from<bar> work.

[19:23] <japhb> So now I need to figure out how to get a Parrot module to load into current Rakudo.

[19:23] <japhb> Do you know offhand the right incantation, and if not, where in the code do I start looking for answers?

[19:24] <Tene> japhb: I know exactly what you need to do!

[19:24] <japhb> Yay again!

[19:24] <Tene> Check out... uh... 'sec

[19:24] * pmichaud is very interested to learn this also.  :-)

[19:25] * Tene pastes

[19:25] <Matt-W> do we have an integer division operator?

[19:25] <Tene> http://gist.github.com/124453

[19:25] <masak> hm, my Rakudo doesn't work. :/

[19:26] <Tene> japhb: like that.  Make sure that the namespace matches the file path, in the usual way, including case

[19:26] <TimToady> we have a type-specific div that could do that

[19:26] <Matt-W> masak: noooooooooo

[19:26] <TimToady> but it's not div in the Pascal sense

[19:26] <masak> pmichaud: has anyone reported the error message C<"load_bytecode" couldn't find file 'perl6.pbc'> lately?

[19:26] <Matt-W> TimToady: okay

[19:26] <pmichaud> masak: no.

[19:26] <masak> pmichaud: I had it earlier today on feather too.

[19:26] *** [particle]1 joined
[19:26] <masak> pmichaud: I'm thinking it might be because I insist on running bleeding-Parrot/bleeding-Rakudo.

[19:27] <pmichaud> masak: if running bleeding parrot, that could be an issue, yes.

[19:27] <pmichaud> I'll try bleeding parrot.

[19:27] <TimToady> div could integer division, but it wouldn't coerce to Int unless you supplied the extra multis

[19:27] * masak rebuilds

[19:27] <TimToady> *could do

[19:27] <japhb> Tene: When you say the namespace matches the file path ... where exactly does it need to be now?  For OpenGL, is the current location in parrot/runtime/parrot/library/OpenGL.pbc correct?

[19:27] <Tene> masak: I always run latest rakudo and parrot.  Where are you seeing that problem?

[19:28] <TimToady> div is really generic division, not integer

[19:28] <masak> Tene: when running the fakecutable.

[19:28] <Tene> japhb: if you have that path, you need to use the namespace ['OpenGL']

[19:28] <masak> Tene: nice to know I'm not alone in this habit. :)

[19:28] <pmichaud> the fakecutable of perl6, or some other fakecutable?

[19:28] <masak> pmichaud: the perl6 one.

[19:28] <pmichaud> okay.

[19:29] <TimToady> Matt-W: but otherwise you currently want Int($x/$y)

[19:29] <TimToady> or floor maybe

[19:29] <Matt-W> TimToady: thanks

[19:29] <Matt-W> I thought about it and I think floor is more appropriate

[19:29] <japhb> Tene: Line 81 of OpenGL.pir says .namespace ['OpenGL'] , so I'm good there.

[19:29] <pmichaud> (in rakudo, Int($x/$y) wont work.   use floor, or .int)

[19:30] <TimToady> .int should coerce to the native type, of course...

[19:30] <pmichaud> in our case, it probably does exactly that :-)

[19:31] <pmichaud> we can likely add a .Int, though.

[19:34] <japhb> Tene: does c.'export'('subname') have a lot of set up overhead?  In other words, do you expect a big difference between doing c.'export'('subname') several thousand times, versus doing names = join(list-of-thousands-of-names); c.'export'(names) ?

[19:34] *** EvanCarroll joined
[19:34] <EvanCarroll> I just had a brilliant idea.

[19:34] <EvanCarroll> Rather than unshift/shift, we should have pull/shove.

[19:34] <EvanCarroll> ;))

[19:34] <pmichaud> masak: the perl6 fakecutable appears to be working fine for me, bleeding rakudo/parrot

[19:35] <rjh_> EvanCarroll: beautiful

[19:35] <EvanCarroll> because it takes more force to shove something under an array, then it takes to push it on the top of an array...

[19:35] <Tene> japhb: I'm not sure whether the former will work at all

[19:35] <rjh_> can we use those for gather/take semantics as well?

[19:35] <Tene> lemme check

[19:35] <japhb> take($this_job) && .shove($_)

[19:35] <masak> pmichaud: I get the C<"load_bytecode" couldn't find file 'perl6.pbc'> error when running outside of the parrot/languages/rakudo dir. when I run from within it, it works for -e scripts.

[19:35] *** hercynium left
[19:35] <pmichaud> sounds to me like parrot may have changed its load_bytecode semantics.

[19:35] <masak> pmichaud: for Matt-W's first test file, I get a really weird error: C<A method named 'clone' already exists in class 'Perl6Object'. It may have been supplied by a role.>

[19:35] <EvanCarroll> rjh_: I'm being serious here... there is an easy mental connection between force and the begining of an array.

[19:36] <Tene> japhb: looks like the former would work (thousands of calls), but I wouldn't be too surprised if it was kinda slow.

[19:36] <japhb> Tene: OK, thanks

[19:36] <EvanCarroll> I'm just saying it would certainly be better than a confusing inconstant un- syntax.

[19:36] <rjh_> EvanCarroll: I actually think there's a clear mental distinction between push/pop and shift/unshift

[19:36] <japhb> Syntax tends to be very inconstant.

[19:36] <pmichaud> Tene: doesn't 'export' take an array also?

[19:37] <Tene> pmichaud: it should.  It currently doesn't.

[19:37] <rjh_> whereas push/shove are strongly associated words

[19:37] <EvanCarroll> but a shove is always a stronger form of a push.

[19:37] <rjh_> i don't really see the relation

[19:37] <rjh_> end-users don't need to be concerned that adding to the other end of a stack is more 'difficult'

[19:38] <pmichaud> masak:  how long since a realclean?

[19:38] <EvanCarroll> no they don't. but humans naturally think about this...

[19:38] <masak> pmichaud: a couple of minutes ago. I just rebuild everything.

[19:38] <pmichaud> hmmm.

[19:38] <rjh_> Perl6 arrays are presumably designed to work as queues or stacks

[19:38] <EvanCarroll> 100% of people view arrays as laying horizontally or vertically, no one thinks of them us internally ordered, non-sorted abstract lists.

[19:38] <masak> s/d/t/

[19:39] <pmichaud> I wonder how I fall outside of the 100%, then :-)

[19:39] <rjh_> imho, push/pull/shove are too similar to each other

[19:39] <Matt-W> pmichaud: it worked for me when I updated about 20 minutes ago

[19:39] <EvanCarroll> I'm just saying the connection is definitly there, I remember being confused about ``shifting onto an array'' or ``shifting off of an array'' niether of those made any sense to me when i start, and they still don't know

[19:39] <EvanCarroll> now*

[19:40] <pmichaud> masak/Matt-W:  I'm a bit stumped then.  It all appears to be working fine for me.

[19:40] <rjh_> I'll admit I only know what 'shift' does because of Perl 5 :)

[19:40] <pmichaud> fwiw, I knew of 'shift' from shell programming.

[19:40] <EvanCarroll> see.

[19:40] <masak> I admit it seems to be something on my system that fails.

[19:40] <pmichaud> "shift" is the way to process command line arguments in shell scripts.

[19:40] <masak> I'll try a clean download and see if that helps.

[19:40] <pmichaud> masak: that would be good.

[19:41] <rjh_> seems python doesn't have shift/unshift. it uses pop(0) to pop from the left side

[19:41] <rjh_> perhaps they agree with you

[19:41] <pmichaud> "shift" is also what we do with bit shifting , although it's normally called left-shift and right-shift.

[19:41] <japhb> Speaking of shell scripts, I've clearly spent too much time around you guys, because yesterday I yak shaved for a couple hours figuring out how to do functional programming in bash.  Quoting was an issue.

[19:41] *** kate21de joined
[19:42] * jnthn back

[19:42] <pmichaud> japhb: hey, don't blame me!  Most of my code is highly dis-functional.  :-)

[19:42] <jnthn> I eated a cheezburger!

[19:42] <jnthn> Greatest achievement all day...

[19:42] <japhb> mmm, did that last night

[19:42] <TimToady> Int:D is constrainted to defined, Int:U is constrained to undefined, and Int:P is constrained to stick out its tongue

[19:42] <pmichaud> I had a cheezburger for lunch

[19:42] <sjohnson> heheh

[19:42] <sjohnson> "eated"

[19:42] <jnthn> TimToady: Oh, pretty.

[19:42] <masak> I baked some delicious bread tonight.

[19:43] <pmichaud> Once again, TimToady gets the colon.

[19:43] <TimToady> I especially like :D

[19:43] <masak> and then I eated it.

[19:43] <TimToady> for a value that makes you happy

[19:43] <rjh_> :U looks aghast

[19:43] <japhb> Once again, my IM client is going to mangle my code ...

[19:43] <TimToady> it does at that

[19:44] <TimToady> well alloweing either is probably :B or some such

[19:44] <EvanCarroll> TimToady: shift/unshift, vs pull/shove ?

[19:44] <pmichaud> :U  looks like it's not quite complete.  Like it's somehow poorly defined... :-)

[19:44] <rjh_> "An undefined parameter? In MY subroutine?"

[19:44] <pmichaud> "Excuse me, you seem to be missing part of your mouth."

[19:44] <japhb> "Oh, Programmer, how *could* you?!?"

[19:45] <TimToady> then we just make -> $x default to Any:D and while -> work on binding success rather than boolean

[19:45] <japhb> "Any:D" ... isn't that a famous rapper?

[19:45] <pmichaud> ....binding success?

[19:45] <pmichaud> oh, just for while.

[19:45] <pmichaud> hmmm.

[19:45] <TimToady> and if

[19:46] <pmichaud> is that a special syntactic case, then?

[19:46] <TimToady> but it's specially generally, not just special specially :D

[19:46] <pmichaud> okay, I'm confused.

[19:46] <rjh_> DWIM++

[19:46] <TimToady> while -> is already a special syntactic form

[19:46] <pmichaud> while $a != 'hello' { ... }    #   is that binding failure?

[19:47] <TimToady> or at least if -> is

[19:47] <masak> how so?

[19:47] <TimToady> since the if changes the default arity of the block

[19:47] <masak> ah.

[19:47] <TimToady> so does while

[19:48] <EvanCarroll> How would i change perl6 to use pull/shove rather than shift/unshift? This is very important to me.

[19:48] <masak> nice to know there are still things Perl 6 sweeps under the carpet for me! :)

[19:48] <pmichaud> currently rakudo does if/while without changing the arity of the block.

[19:48] <pmichaud> and this sounds to me more like the arity of the block changing the meaning of the if/while

[19:48] <pmichaud> (unless it's truly syntactically special)

[19:48] <skids_> EvanCarroll: with macros, once they work (that is, not currently)

[19:49] <StephenPollei> EvanCarroll, probably just make alias ::= or something

[19:49] <sjohnson> what does the p6 community think of a $DUMMY compiler variable

[19:49] <TimToady> I have no idea what the p6 community thinks of anything :)

[19:49] <TimToady> most of them don't know they'll be a part of it someday

[19:49] <sjohnson> much like the other $VARIABLES_TO_USE in Perl

[19:49] <pmichaud> EvanCarroll:    class Array is also {  method pull(*@_) is export { self.unshift(@_); } ... }

[19:50] <pmichaud> EvanCarroll: (only works in Rakudo at the moment, will eventually change to 'augment')

[19:50] <pmichaud> sorry, s/unshift/shift/

[19:51] <rjh_> lol his point has been proven

[19:51] <pmichaud> not really.

[19:51] <pmichaud> I understand shift/unshift just fine, I got pull backwards.

[19:51] <rjh_> no, i was just goading you

[19:51] <rjh_> sorry :/

[19:51] <TimToady> he was shifting your leg

[19:51] <rjh_> heh :)

[19:52] <Matt-W> I found a bug!

[19:52] <TimToady> is it a butterfly?

[19:53] <Matt-W> rakudo: my $a = 0.14; $a *= 100; my $b = $a.floor; say $a == $b

[19:53] <p6eval> rakudo fb2fd4: OUTPUT«0␤»

[19:53] <TimToady> welcome to the world of floating point

[19:53] <pmichaud> anyway, back to if/while

[19:54] <pmichaud> I have trouble seeing     if foo() -> $y { ... }     as meaning "does foo() bind to $y" as opposed to doing a boolean check

[19:54] <Matt-W> rakudo: my $a = 0.14; $a *= 100; my $b = $a.floor; say $a == $b; say $a; say $b

[19:54] <p6eval> rakudo fb2fd4: OUTPUT«0␤14␤14␤»

[19:54] <Matt-W> I find it very hard to blame floating point arithmetic when they stringify to the same string

[19:54] <jnthn> pmichaud: fwiw, the same...

[19:54] <TimToady> Matt-W: 0.14 is not exactly represented in floating point

[19:54] <Matt-W> okay

[19:54] <Matt-W> so can I have a sane number system?

[19:55] <TimToady> rakudo: say 0.14.fmt("%16f")

[19:55] <StephenPollei> Matt-W, it happens that sometimes the stringify rounds some

[19:55] <p6eval> rakudo fb2fd4: OUTPUT«        0.140000␤»

[19:55] <pmichaud> rakudo:  my $a = 0.14;  $a *= 100;   say $a.fmt('%.15f');

[19:55] <p6eval> rakudo fb2fd4: OUTPUT«14.000000000000002␤»

[19:55] <masak> pmichaud: both errors still persist after clean install.

[19:55] <TimToady> rakudo: say 0.14.fmt("%.16f")

[19:55] <p6eval> rakudo fb2fd4: OUTPUT«0.1400000000000000␤»

[19:55] <TimToady> rakudo: say 0.14.fmt("%.20f")

[19:55] <p6eval> rakudo fb2fd4: OUTPUT«0.14000000000000001332␤»

[19:55] <Matt-W> I think I'll just rip all my hair out now

[19:56] <pmichaud> Matt-W: but if stringification is your criteria, then

[19:56] <StephenPollei> p6 has Rat if you need it

[19:56] <pmichaud> rakudo: my $a = 0.14;  $a *= 100;  my $b = $a.floor;  say $a eq $b;  say $a; say $b

[19:56] <p6eval> rakudo fb2fd4: OUTPUT«1␤14␤14␤»

[19:56] <masak> StephenPollei: p6 yes, r no...

[19:56] <TimToady> pugs: my Rat $a = 0.14; say $a.fmt("%.20f");

[19:56] <p6eval> pugs:  ( no output )

[19:56] <StephenPollei> otherwise with float point it's good idea never to test equality but if it's within epsilon

[19:56] <TimToady> pugs: my $a = 14/100; say $a.fmt("%.20f");

[19:56] <pmichaud> ...is 0.14 a Rat?

[19:56] <p6eval> pugs:  ( no output )

[19:57] <Tene> japhb: how's it going?

[19:57] <Matt-W> okay

[19:57] <Matt-W> so

[19:57] <Matt-W> using string operations to manipulate numbers

[19:57] <japhb> Tene: delayed by sudden need for sandwich.

[19:57] <pmichaud> I sometimes find myself wanting an "approx equal" operator.  I've been using ~==~ for that lately.

[19:57] <Matt-W> I've never been bitten by floating point like this before

[19:57] <pmichaud> Unfortunately it looks too much like a longhorn cattle.

[19:57] <StephenPollei> by p6 I mieant perl6 and I thought it was in S02 and others, unless I'm wrong

[19:57] <TimToady> what's the non-Texas form of that?

[19:58] <Tene> ≈

[19:58] <pmichaud> There is no non-Texas form.  :-)

[19:58] <Tene> ?

[19:58] <TimToady> nothing else approximates Texas...

[19:58] <pmichaud> longhorn cattle are unique to Texas :-P

[19:59] <japhb> Tene: but I did think of a possible issue.  How would I import the OpenGL functions in *pir*?  (For example, if I wanted to write OpenGL::Simple, say, and I decided to write it in PIR, how would I do the import after loading OpenGL.pbc?  Right now, there's a hand-coded import function in the OpenGL that you can call, but I'm hoping your work makes that redundant.)

[19:59] <StephenPollei> ≈ and ~==~ might be useful but often you have to specify the epsilon

[19:59] <pmichaud> StephenPollei: adverb

[19:59] <pmichaud> $a ~==~ $b :epsilon(0.1)

[20:00] <StephenPollei> yes I keep forgeting , I need to get used to perl6ish stuff

[20:00] <Tene> japhb: I can make it redundant shortly... speaking of which, do you expect to ever have any interest in importing a library written in a HLL from PIR?

[20:00] <Matt-W> pmichaud: would that get given to the infix op as a named parameter?

[20:00] <japhb> Tene: yes

[20:00] <Tene> japhb: Okay.

[20:00] <pmichaud> Matt-W: yes.

[20:01] <Matt-W> pmichaud: cool. does that work in rakudo?

[20:01] <pmichaud> Matt-W: no.

[20:01] <Tene> japhb: I'm thinking an 'import' method on the 'parrot' compiler... what sort of API do you expect?

[20:01] <Matt-W> aww

[20:01] <pmichaud> Tene: my expectation has been 'import' method.

[20:01] <pmichaud> Tene: however, I need to review TimToady's latest changes to S11

[20:01] <StephenPollei> rakudo: my Rat $a = 14 div 100; say $a

[20:01] <p6eval> rakudo fb2fd4: OUTPUT«Malformed declaration at line 2, near "Rat $a = 1"␤in Main (src/gen_setting.pm:0)␤»

[20:02] <pmichaud> rakudo doesn't have Rats yet.

[20:02] * Matt-W puts Rat on his christmas list

[20:02] <pmichaud> You want a Rat for christmas?

[20:02] <Tene> import(lang,list)?  import(lang,delimited-string)?

[20:02] <pmichaud> hmmmm....

[20:02] <Matt-W> I want a non-floating-point non-integer numeric type :)

[20:02] <pmichaud> Tene: why 'lang'?

[20:03] <Tene> pmichaud: japhb just said the he expects to want to import foreign libraries from PIR.

[20:03] <masak> pmichaud: I'm one step closer to encircling my problem. it doesn't trigger for small things like -e 'say "OH HAI"', but it triggers for a precompiled lib/Form/Grammar.pir in Matt-W's Form.

[20:03] <masak> pmichaud: when I remove the .pir file, everything works.

[20:03] <Tene> pmichaud: I could have a multi, though

[20:03] <Matt-W> masak: not a very productive hackathon really, is it

[20:03] <StephenPollei> also is S02 serious that there is going to be a rat and a Rat .. I don't know of any handware where rat is native, or am I overreading into what native means

[20:03] <masak> Matt-W: you don't get this error?

[20:04] <Matt-W> masak: works fine here

[20:04] <masak> Matt-W: how bleeding is your Rakudo?

[20:04] <Tene> masak: is the directory that contains perl6.pbc in your parrot search path?

[20:04] <masak> ditto Parrot.

[20:04] <Tene> masak: if not, how do you expect 'load_bytecode' to find it?

[20:04] <pmichaud> Tene: I think I need to review S11 a bit more first before committing to a design.  But I'll do that tonight.

[20:04] <masak> Tene: what's a Parrot search path?

[20:04] <pmichaud> Tene: the 'load_bytecode' is working for me no matter what directory I'm in.

[20:04] <Tene> masak: the places that parrot looks for stuff when you say 'load_bytecode'

[20:05] <japhb> Tene: even if I personally didn't think I would use it, I would still want to see it supported.  It should be possible to do from PIR anything an HLL do.  IOW, it should be a first-class language, just special to Parrot because it's "core".

[20:05] <Tene> pmichaud: you must have a different setup from masak

[20:05] <skids_> Speaking of Rat, do we have a "require BigNum" or something specced?  Or is it default, in which case is there a "no Bignum"?

[20:05] <pmichaud> Tene: sure, we're wondering what that difference might be

[20:05] <pmichaud> because I don't have anything special in my setup afaik

[20:05] <Tene> masak: run:

[20:05] <Tene> strace -estat -o perl6.log perl6 whatever.pl

[20:05] <Tene> then nopaste the perl6.log

[20:06] <pmichaud> my guess is that masak might be getting a different perl6 binary

[20:06] <pmichaud> i.e., one that is looking for perl6.pbc in the wrong place.

[20:06] <masak> I need to install strace, it seems.

[20:06] <pmichaud> masak: how are you invoking perl6?

[20:06] <pmichaud> with a full path, or just as 'perl6'?

[20:06] <Tene> pmichaud: I'll add a method to languages/parrot/parrot.pir, and if you don't like it, you can change it later, yes?

[20:06] <pmichaud> Tene: sure, as long as it doesn't become spec.

[20:07] <masak> pmichaud: I symlink from /usr/local/bin/perl6 into the fakecutable in the Rakudo directory.

[20:07] <Tene> pmichaud: the 'parrot' compiler isn't specced at all anywhere yet.

[20:07] <Tene> pmichaud: this is just a utility method for when writing PIR.

[20:07] <pmichaud> I know, but we still have to be careful about what people come to reply upon.

[20:07] <StephenPollei> skids, I think Int in Bignum-ish , not sure about Num

[20:07] <Tene> Okay.

[20:07] <masak> pmichaud: that's how I usually do. but here I call the perl6 fakecutable directly, just to be safe.

[20:07] <pmichaud> Technically the PGE stuff isn't specced anywhere either (outside of S05), but I still have to fundamentally deal with deprecation issues.

[20:08] <pmichaud> masak: and there's not some other libparrot floating around on the system that might be getting in the way?

[20:08] <masak> pmichaud: how do I test that?

[20:08] <masak> I really don't think so.

[20:09] <pmichaud> I don't know.  I really don't think so either, but I'm at a loss as to why you might be running into these issues.

[20:10] <pmichaud> I need a break -- bbiab

[20:11] <[particle]1> back from power-outage-induced lunch

[20:11] <masak> I have four Rakudo/Parrot setups (locally) built on my computer right now: the one I usually run, one installed by proto, another installed by another copy of proto, and the one I just built.

[20:11] <pmichaud> maybe try from a fresh shell?  Perhaps it's hashed the wrong copy.

[20:11] <masak> neither should interfere with any other.

[20:11] * masak tries from a fresh shell

[20:12] <pmichaud> I'm grasping at straws, yes.

[20:13] <masak> it works now. :)

[20:13] <masak> pmichaud++

[20:14] <masak> Matt-W: now, where were we? :)

[20:14] <TimToady> std: $a == $b :ϵ(1e-10)

[20:14] <p6eval> std 27012: OUTPUT«Potential difficulties:␤  Variable $a is not predeclared at /tmp/B1GzYvDNha line 1:␤------> [32m$a[31m == $b :ϵ(1e-10)[0m␤  Variable $b is not predeclared at /tmp/B1GzYvDNha line 1:␤------> [32m$a == $b[31m :ϵ(1e-10)[0m␤ok 00:02 36m␤»

[20:14] <masak> oh right, I was to add a test.

[20:15] *** pmurias joined
[20:15] <pmichaud> having:   $a == $b :ϵ   might be nice  :-)

[20:15] <masak> oh wait. :/ I tested the wrong thing. it still fails when I precompile...

[20:15] <masak> I guess I'll simply have to run un-precompiled tonight.

[20:15] <pmichaud> masak: what are you precompiling?

[20:15] * skids_ wonders whether TimToady forgets the "my" like everyone else, or just likes to show off STD's error handling.

[20:16] <masak> pmichaud: Matt-W's Form.

[20:16] <masak> pmichaud: you can easily compile it by doing './proto install form'

[20:16] <pmichaud> masak: and then you're running it directly with Parrot?

[20:16] <masak> pmichaud: then I'm running 'perl6 -e "use Form::Grammar"'

[20:16] <pmichaud> Hmm.

[20:16] <StephenPollei> $a == $b :ϵ(1e-10) looks nice TimToady++

[20:16] <Tene> masak: strace log?

[20:16] <masak> so, .pm file works, .pir file doesn't.

[20:17] <pmichaud> I didn't try that on my system.

[20:17] <masak> Tene: I'll try to find strace for Mac OS X.

[20:17] <Tene> masak: oh, OS X.  No idea.

[20:17] <TimToady> skids_: never attribute to malice that which can be easily explained by stupidity :)

[20:17] <Tene> I think they have something else there...

[20:17] <bkeeler> dtrace

[20:17] <japhb> Tene: Does c.'export'() just add subnames to the DEFAULT tag for now?  If so, what will be the syntax to add something to a different tag, or to multiple tags?

[20:17] <masak> ah, dtruss.

[20:18] <skids_> Does  :ϵ have a default.  I mean other than 50 points for the medium speed space invader?

[20:18] <pmichaud> japhb: they'll be additional parameters to 'export'

[20:18] <pmichaud> I don't know yet if they'll be named or positional

[20:19] <japhb> pmichaud: OK, thanks.

[20:19] <Tene> japhb: it just adds to the 'DEFAULT' and 'ALL' tags.  The syntax for anything else is whatever you want it to be. :)

[20:19] <skids_> Oh I guess :ϵ would be ϵ => 1.  Alas.

[20:19] <japhb> heh

[20:20] *** mizioumt1 left
[20:20] <pmichaud> actually,  :ϵ   is   ϵ => True    

[20:20] <pmichaud> (which numifies to 1, but "true" could be taken to mean some other constant in this case)

[20:20] <pmichaud> s/constant/value/

[20:21] <TimToady> so $a == $b :ϵ is integer comparison :)

[20:21] <pmichaud> oh?

[20:21] <TimToady> I'm just shifting your leg

[20:21] <pmichaud> 2.3 == 1.4 :ϵ    # not integer comparison

[20:22] <pmichaud> 2.3 == 1.4 :ϵ(1)    # not integer comparison

[20:22] <TimToady> I agree it could sigwise match Bool and do something else

[20:22] <StephenPollei> almost but not quite integer comparisom Int(4.5) == Int(5.2) and 4.5 == 5.2  :ϵ -- differ

[20:22] <masak> Tene: I don't really expect this to help/enlighten: http://gist.github.com/124489

[20:22] <skids_> Could be taken as "reasonable defloatification" for (Int, Num)

[20:22] <pmichaud> I like the sigwise match bool

[20:22] <Tene> No, not helpful. :)

[20:23] <pmichaud> and it could use $*EPSILON or something as the default :-)

[20:23] <TimToady> well, some small percentage of the large magnitude value

[20:23] <japhb> TimToady: How would you express matching to a particular number of significant bits, so that the looseness of the equality match is automatically proportional to the magnitude of the operands?

[20:23] <TimToady> *larger

[20:23] <StephenPollei> well I see $.EPSILON being part of class more helpful

[20:24] <TimToady> yes, though for floaters you want sigbits as japhb suggests

[20:24] <StephenPollei> japhb, I think yet another adverb might be needed

[20:24] <TimToady> just different for single vs double precision, for instance

[20:24] <japhb> Right.

[20:24] <skids_> There is a letter for relative error I think...

[20:25] <StephenPollei> num is always double iirc, and Num I don't know

[20:25] <japhb> skids_: that would be perfect

[20:25] <TimToady> yes, but num32 is not always double :)

[20:25] <japhb> StephenPollei: smaller nums are spec'ed.

[20:25] <japhb> Down to num16, at my suggestion.  :-)

[20:25] <StephenPollei> yes I show the native by size ones

[20:26] <StephenPollei> I also wondered what that mean for cpus without floating point, I guess the compiler decides

[20:26] <masak> Matt-W: just made my first commit. :)

[20:26] * TimToady is looking forward to ubiquitous num128s so time doesn't have to return a Rat

[20:26] <skids_> http://en.wikipedia.org/wiki/Relative_error

[20:27] <TimToady> Num is defined to allow Rat internals lazily converted to Num, though it's still more than a bit handwavey

[20:27] <StephenPollei> nad it isn't speced how much is matissa and how much is exponent .. hopefully terms right

[20:28] <TimToady> anyway :ϵ is close enough for now; I'll leave the rest to smart people :)

[20:28] *** gegloe left
[20:29] <pmichaud> Isn't that the definition of :ϵ ?    ;-)

[20:29] <TimToady> 1..10 :Δ(3)

[20:29] <skids_> Rat still needs some sort of .num, .den specced IIRC.  Also, have the advatages/disadvantages of Rat does Pair been weighed?

[20:29] <pmichaud> note that ".num" is taken.

[20:29] <japhb> skids_: so 1.1 == 1.0 :η(...) then, but what should the ... be?

[20:29] <pmichaud> TimToady: in S11, how much do you think is likely to change...?

[20:29] <pmichaud> (w.r.t need/defines/etc)

[20:30] <TimToady> defines is still a bit wobbly, syntaxwise

[20:30] <pmichaud> is it "generally correct" now, or do you think there's a good chance it will major shift?

[20:30] <TimToady> thinking about "defines *"

[20:30] <TimToady> or maybe making that the default

[20:30] <TimToady> it's all just syntax now

[20:30] <pmichaud> also, are tags simply identifiers that begin with a colon?

[20:31] <skids_> japhb: I meant there is a greek letter used for that, not that it's specced -- but that would be a number < 1 usually.

[20:31] <Tene> japhb: do you expect that foreign namespaces will be imported too?

[20:31] <TimToady> they're just adverbials, syntactically

[20:31] <japhb> Tene: urm.  Explain what you mean by that, please.

[20:31] <pmichaud> the spec doesn't show them parsing as adverbial, though.

[20:31] <Tene> japhb: if I do:

[20:32] <TimToady> are you referring to :MY<:ALL>?

[20:32] <japhb> skids_: I am just wondering if it's more useful to have a decimal number in the eta adverb, or some number of sigbits.

[20:32] <pmichaud> yes

[20:32] <Tene> compiler.import('perl6','Foo::Bar') would you expect that ['perl6';'Foo';'Bar'] is also available as ['parrot';'Foo';'Bar'] ?

[20:32] <pmichaud> I was also referring to   is export(...), but I see there they could be adverbial

[20:32] <Tene> I guess that's not as much of an issue for PIR, but other languages often expect that.

[20:32] <TimToady> it's handling the string ':ALL' specially

[20:32] <pmurias> ruoso_: ping

[20:32] <DanielC> Yay \o/  I now have  full RPN calculator with  bottom-up grammar. It's actually quite simple, but I had to learn the basics of grammars first.

[20:32] <TimToady> :MY<$x $y>

[20:32] <ruoso_> pmurias, pong

[20:33] <skids_> japhb: potentially putting 1/η in there would be prettier.

[20:33] <TimToady> '$x' and '$y' are just strings here

[20:33] <pmichaud> right.

[20:33] *** rocket_guatemala joined
[20:33] <pmichaud> I was looking for ":ALL is a string there".

[20:33] <pmichaud> (which I got)

[20:33] <TimToady> unless we go with something supra-declarational like defines (my $x, my $y)

[20:33] <pmichaud> in the case of

[20:33] <pmichaud>     sub bar is export(:DEFAULT :others) {...}  #  :DEFAULT, :ALL, :others

[20:33] <pmichaud> those are named parameters, syntactically?

[20:34] <TimToady> sec...

[20:34] <pmichaud> sorry, named arguments

[20:34] <pmurias> ruoso_: if new signatures will be used for subs and methods how will we bootstrap them?

[20:34] <japhb> Tene: that makes sense.  Might want to be able to turn that off, but as a default it makes sense to me.

[20:34] <pugs_svn> r27013 | rocket++ | Created the t/spec/S19-command-line-options folder and started moving the t/run tests into it.

[20:34] <pugs_svn> r27013 | rocket++ | Moved 01-dash-uppercase-i.t to t/spec/S19-command-line-options and added smartlinks to it.

[20:34] <Tene> japhb: I'll leave it commented out for now, and when someone wants it, they can work out the semantics.

[20:34] <japhb> skids_: true.  Now figuring out a good syntax for that without confusing mathemeticians ...

[20:34] <japhb> Tene: OK

[20:35] * japhb can barely keep up with IRC today and still continue to actually code ...

[20:35] <ruoso_> pmurias, I think it might be a mildew option like "--core-stage x" where that modifies the emitted code...

[20:35] <TimToady> is export is sugar for :export, so the question is whether :export(:DEFAULT :others) is treated as arglist or inside ()

[20:35] <ruoso_> probably '--target-stage x'

[20:36] <masak> Matt-W: oh! I see now why you dreaded the numeric parsing. :D

[20:36] <pmurias> ruoso_: the other option would be to use the default signature when defining Signature

[20:36] <ruoso_> what do you mean?

[20:36] <pmurias> using the implicit :(*@_,*%_) signature

[20:36] <pmurias> but that seems inelegant

[20:37] <TimToady> if :() is just (), then they're not named params, just as foo((:a :b)) aren't

[20:37] <pmichaud> right

[20:37] <TimToady> arguable the same for :MY()

[20:37] <pmichaud> also, S11 doesn't seem to give an example of importing from a tagset (via use)

[20:37] <TimToady> though :MY($x, $y) is problematic

[20:37] <japhb> Tene: oooh, just ran across a problem.  What about renames?  My custom exporter currently does this because it needs to rename a couple NCI functions before exporting:

[20:37] <japhb>     gl_namespace.'export_to'(to_namespace, export_list)

[20:37] <japhb>     gl_namespace.'export_to'(to_namespace, export_renames)

[20:37] <Tene> japhb: will this work for you: http://nopaste.snit.ch/16793 ?

[20:37] <pmurias> ruoso_: wouldn't it be better to use a pragma instead of a compiler flag?

[20:38] <pmichaud> unless it's

[20:38] <pmurias> ruoso_: like use adhoc-signatures; ?

[20:38] <TimToady> but we could go for defines my(:TAG, $x, $y) possibly

[20:38] <Tene> japhb: That's currently not handled at all.

[20:38] <ruoso_> pmurias, the Perl 6 code will be the same

[20:38] <ruoso_> pmurias, it's not the code that changes, but the compiler

[20:38] <pmichaud>     use Sense <common @horse>;

[20:38] <TimToady> and then it looks more like a real my declaration

[20:38] <pmichaud> "common"  is referring to the sub?

[20:39] <pmichaud> or is it a tag?

[20:39] <TimToady> not a tag

[20:39] <TimToady> was thinking sub

[20:39] <TimToady> but that's also a problem

[20:39] <pmichaud> yes

[20:39] <Tene> japhb: if you work out an API for it with pmichaud, I'll implement it.

[20:39] <Tene> Might take me a bit.

[20:40] <pmurias> ruoso_: could you explain? 

[20:40] <TimToady> use Sense my(&common, @horse)  would also need to have the my redefined like defines would do explicitly

[20:40] <pmichaud> Tene/japhb:  I'll have an API when I get S11 worked out

[20:40] <jnthn> rakudo: multi foo(Int, Any) { }; multi foo(Any, Int) { }; foo(1,1)

[20:40] <p6eval> rakudo fb2fd4: OUTPUT«Ambiguous dispatch to multi 'foo'. Ambiguous candidates had signatures:␤:(Int ::TYPE_CAPTURE17, Any ::TYPE_CAPTURE18)␤:(Any ::TYPE_CAPTURE19, Int ::TYPE_CAPTURE20)␤in Main (/tmp/Ohi1kel73X:2)␤»

[20:40] <TimToady> unless we do something like use Sense defines my(&common, @horse)

[20:40] <masak> Matt-W: I'm wondering if not some, most or all of the 'regex' keywords in Form::Grammar::Format couldn't be 'token' instead...

[20:40] <ruoso_> pmurias, eventually we might recompile the CORE code using the next --target-stage and get a more high-level code redefining the types...

[20:41] <ruoso_> pmurias, so the CORE is plain Perl 6

[20:41] <ruoso_> but the compiler evolves from a stage 0 compiler

[20:41] <ruoso_> that only uses the SMOP c implemented types

[20:41] <ruoso_> to later using the types defined in the CORE to build the CORE

[20:41] <ruoso_> and that's bootstrap

[20:41] <ruoso_> so the code in the CORE is always the same

[20:41] <Tene> pmichaud: Okay.

[20:42] <pmurias> shower&

[20:42] <Tene> japhb: do you need renaming to get OpenGL working at all?  Or will that just be nice eventually?

[20:42] <TimToady> Module my ($x, $y) our ($z)  # infix declarators in general?

[20:44] *** [particle]1 left
[20:45] <japhb> Tene: (re: your PIR module loading paste): So the parent code loads the 'parrot' language, and asks its compiler object to import module 'Foo'.  The parrot compiler object then knows to do a load_bytecode for the Foo.pbc. At :load time, Foo.pbc loads the 'parrot' compiler object again, registers its exports, and returns to the parrot compiler, which then does an 'import' operation, making use of the newly created export tags.  Then finally

[20:45] <japhb>  the original compiler.import('Foo') returns, and you're ready to go.  Do I have that all right?

[20:45] <pmichaud> seems like the infix declarators would want to follow 'defines'

[20:45] <TimToady> Module defines (my ($x, $y); our $z) is more likely to extned well

[20:45] <japhb> Tene: Actually required.  Can't get the callbacks working without the rename.

[20:45] <TimToady> nod

[20:45] <masak> Matt-W: ping

[20:46] <pmichaud> and tagsets?

[20:46] *** REPLeffect joined
[20:46] <Tene> japhb: that's right

[20:46] <TimToady> my (:foo, $x, $y) maybe

[20:46] <japhb> Excellent.  Let's hope the compiler object doesn't leak when reentered.  ;-)

[20:46] *** ST47 joined
[20:46] <pmichaud> is there a my/our default?

[20:47] *** simcop2387 joined
[20:47] <pmichaud> Module defines (:foo, $x, $y)

[20:47] <pmichaud> or is the my/our required?

[20:47] <TimToady> defines :(:foo)

[20:47] <pmichaud> what about caller and context?

[20:47] <TimToady> yeah

[20:47] <TimToady> it just doesn't quite mesh with normal binding either

[20:48] <pmichaud> or maybe just context

[20:48] <Tene> japhb: If you paste some code showing what you'd like to do, I'll implement it, as long as you're comfortable potentially changing it in a few days after pmichaud potentially decides on API changes here.

[20:48] <TimToady> maybe context is a declarator then :)

[20:48] <pmichaud> there is that possibilty.

[20:48] <pmichaud> maybe every trait is really a declarator.  :-|

[20:48] <japhb> I'm fine with potential energy.

[20:48] <pmichaud> since  "is also" became "augment"

[20:48] <pmichaud> and "is context" might become a declarator....

[20:49] <TimToady> lets make all types into declarators, and use * to dereference things

[20:49] * ruoso_ enjoys the idea of using simply "my $*a" instead of "my $a is context"

[20:50] <pmichaud> we still want the sense of context<rw> I suspect

[20:50] <ruoso_> "my $*a is rw"?

[20:50] *** [particle]1 joined
[20:50] <pmichaud> that makes it sound like the variable itself is rw

[20:50] <japhb> Tene: It would be nice if c.import() took all of: a space separated stringified list (as it does now), a real array, or a rename hash.  The latter two make it match the design of namespace.'export_to'(), which I use now.

[20:50] <pmichaud> we run into trouble with

[20:50] <pmichaud> sub foo($*a is rw) { ... }

[20:51] <pmichaud> which is different from    sub foo($a is rw is context) { ... }

[20:51] <Tene> japhb: it's import that you need renames for?

[20:51] <japhb> japhb: Tene: mind you, I'm not sure how you express the rename operation when you're just adding to tagsets.

[20:51] *** rocket_guatemala left
[20:51] <ruoso_> hmmm...

[20:51] *** jferrero joined
[20:52] * ruoso_ too tired to think

[20:52] <TimToady> I need to go to $job

[20:52] <japhb> Tene:  It doesn't matter to me if 'export' or 'import' actually does the rename.  Just that a function called ['parrot'; 'OpenGL'; 'glutcbFoo'] needs to be named ['perl6'; 'OpenGL'; 'glutFoo'] somehow. 

[20:52] <TimToady> anyway, apart from all that, it's just syntax :)(

[20:53] <pmichaud> TimToady: ultimately, you see tags more like named arguments than strings, yes?

[20:53] <Tene> japhb: I'd very much prefer that it happens in export, so that any other language that loads it will also see the renamed versions.

[20:53] <TimToady> yes, though processed more like slurpy args than bound like named

[20:53] <pmichaud> so, more like pairs than strings

[20:53] <japhb> I guess you need to mark the rename in 'export', then 'import' knows what to do with the mark.

[20:54] <Tene> Right.

[20:54] <pmichaud> Tene/japhb:  A rename simply means that the exported symbol has a different name in the EXPORT::* namespace

[20:54] <Tene> Exactly

[20:55] <japhb> pmichaud: speclink?

[20:55] <Tene> japhb: so, maybe passing a hash to export() ?

[20:55] <pmichaud> hash... probably not

[20:55] <japhb> Tene: yes, that's what I meant five minutes ago, but I typo'ed confusingly.

[20:55] <japhb> Sigh.  This is the problem with being too tired to keep up.

[20:56] <japhb> Should have been: "Tene: It would be nice if c.export() took all of ..."

[20:56] <Tene> ah

[20:56] <Tene> :)

[20:56] <pmichaud> I think I have enough info from TimToady now to indicate how I'd like import/export to work

[20:56] <pmichaud> I'll think it through tonight and either write up a spec or implementation tomorrow.

[20:58] <japhb> I guess then I will put this on the back burner until then.

[20:58] <pmichaud> it shouldn't be too difficult for us to implement

[20:58] *** bkeeler left
[20:58] <pmichaud> other than the syntax (in Perl 6)  :-P

[20:58] <jnthn> pmichaud: I've got some progress on the "Perl6MultiSub everywhere" branch.

[20:58] <pmichaud> jnthn: nice

[20:59] <pmichaud> faster?  slower?

[20:59] <jnthn> pmichaud: Like, we can actually build and startup now and pass some of the sanity tests.

[20:59] <jnthn> A tiny bit but not much slower, but I didn't do any signature caching yet.

[20:59] <pmichaud> is there a strong reason to switch over if it's not significantly faster?

[21:01] <jnthn> Several. 1) Being able to actually overload operators and various other builtins that we can't now. 2) Be able to toss the gen_junction special case code since it should all be handled by the auto-threading in Perl6MultiSub. 3) Correct dispatch semantics in line with the Perl 6 algorithm.

[21:01] <pasteling> "japhb" at 76.191.190.8 pasted "Tene, pmichaud: Rough draft of OpenGL.pir symbol export (to be called by :load routine)" (49 lines, 1.3K) at http://sial.org/pbot/37059

[21:01] <pmichaud> I thought we could solve (1) and (2) by writing the operators in setting

[21:01] <jnthn> 4) Won't need the hack in infix:= any more.

[21:01] <pmichaud> and (3) also

[21:02] <pmichaud> for (4), we could manually switch it over to a Perl6MultiSub instead of having it happen automatically, yes?

[21:02] *** decasm left
[21:02] <jnthn> We could do all of those things yes.

[21:02] <jnthn> Though we would pay the price of !SIGNATURE_BIND

[21:03] <jnthn> And also, we'll run into various other issues that I'm running into now.

[21:03] <jnthn> Example:

[21:03] <pmichaud> we could have a pragma/trait that removes the call to SIGNATURE_BIND

[21:03] <jnthn> .sub 'infix:+' :multi('Complex', _)

[21:03] <pmichaud> but in some sense we need/want SIGNATURE_BIND even for the operators

[21:03] <jnthn> .sub 'infix:+' :multi(_, 'Complex')

[21:03] <jnthn> We can't just translate this into Perl 6.

[21:03] <pmichaud> why is that an issue?

[21:03] <jnthn> Because it's an ambiguous dispatch.

[21:04] <jnthn> If you dispatch with two complex numbers, under Perl 6 MMD that's an error.

[21:04] <jnthn> Because the candidates are tied.

[21:04] <pmichaud> Perl 6 already supports that, though.

[21:04] <jnthn> ?

[21:04] <pmichaud> (looking up reference

[21:05] * ruoso_ decommute &

[21:05] *** ruoso_ left
[21:05] <jnthn> We get away with it now in Rakudo because we're using Parrot's MMD algorithm.

[21:06] <pmichaud> yes, I know.  I'm saying that commutativity of types is already in the spec.

[21:06] <pmurias> sleep&

[21:06] *** pmurias left
[21:07] <jnthn> Explain?

[21:07] <pmichaud> there's a way to specify multiple signatures on a sub (or, at least, there was)

[21:07] <jnthn> Ah, that.

[21:08] <jnthn> Yes, we don't support that in Rakudo at the moment...

[21:08] <pmichaud> all that the infix:+(Complex) case is doing is handling the case where either argument is a Complex.

[21:08] <jnthn> Right.

[21:08] <pmichaud> support that, and then the multi issue you just gave goes away

[21:08] <jnthn> Sure, we'd have to write the 3 signatures, but they could share a body.

[21:09] <pmichaud> exactly.

[21:09] <jnthn> Hmm. I hadn't planned to do that, but maybe it's better sooner than later.

[21:09] <pmichaud> that's all that the current :multi(...) is doing in Rakudo/Parrot

[21:09] <jnthn> Sure, I know that.

[21:09] <pmichaud> that might be a bigger win than trying to convert things to Perl6MultiSub, if we're not seeing a significant speed improvement

[21:09] <jnthn> I'm just pointing out that there's some things like this that crop up when looking at making the switch to the Perl 6 multi-dispatch algorithm.

[21:09] <pmichaud> right.

[21:10] <jnthn> We're just at a point now where we don't need to cheat on these things any more, and I'd rather we stopped doing so and got the semantics correct.

[21:10] <pmichaud> and I still like the idea of converting to Perl6MultiSub lazily (if that's at all possible)

[21:10] <pmichaud> I think the better non-cheat is to move them into settings

[21:11] <pmichaud> rather than try to keep them working in PIR

[21:11] <jnthn> Well the whole point of the branch I'm working on is that we don't have to convert at all.

[21:11] <jnthn> We just create the correct, mapped PMC in the first place.

[21:11] <pmichaud> fair enough.

[21:11] <pmichaud> If it doesn't give us a speed hit, I'm okay with doing it.

[21:12] <jnthn> (Since in theory, not having to convert will be less work at startup.)

[21:12] <pmichaud> (big speed hit, small speed hit okay)

[21:12] <pmichaud> I just don't know that it's worth troubleshooting many cases that really ought to move to setting anyway

[21:12] <pmichaud> as you said, let's fix it so that we don't need to cheat at all :-)

[21:12] <jnthn> Speed hit is like a few percent.

[21:12] <jnthn> Or less.

[21:13] <pmichaud> that's no problem.

[21:13] <pmichaud> I'd only be worried about 10%-20% or more.

[21:13] <pmichaud> and I'm more concerned about runtime speed than startup.

[21:13] <jnthn> And I kinda wonder if we're losing rather than winning because hll_map can be slow (as you noted for Int etc)

[21:13] <pmichaud> well, hll_map on subs shouldn't be an issue.

[21:14] <pmichaud> and hll_map to a PMC type shouldn't be an issue.

[21:14] <pmichaud> I think it's primarily when we hll_map to a ['parrot';'Object']

[21:14] <jnthn> Yes

[21:14] <jnthn> That's going to be slower. :-(

[21:15] <jnthn> Not sure how much we can improve on that.

[21:15] <pmichaud> I'm not sure what that's going to mean for things overall, unfortunately.

[21:15] <pmichaud> It might mean we have to come up with our own Perl6Object PMC type

[21:15] <masak> rakudo: Perl6::Grammar.parse("say <OH HAI>", :action(Perl6::Grammar::Actions.new)); say ?$/

[21:15] <pmichaud> which would mean ditching P6object altogether, or turning it into a PMC type

[21:15] <p6eval> rakudo fb2fd4: OUTPUT«1␤»

[21:15] <masak> \o/

[21:16] <pmichaud> masak: for non-declarational things, I think :action(...) might not be needed

[21:16] <jnthn> Well, to do a bunch of S09 things I'd figured we'd might need to do somehting like that.

[21:16] <masak> pmichaud: now, is there any way I can look into $/ ?

[21:16] <pmichaud> masak: sure, it's just a match object.

[21:16] <masak> pmichaud: please show me.

[21:17] <pmichaud> rakudo:  Perl6::Grammar.parse("say <OH HAI>");  say $/<TOP>;

[21:17] <jnthn> .oO( .perl )

[21:17] <p6eval> rakudo fb2fd4: OUTPUT«Use of uninitialized value␤␤»

[21:17] <masak> jnthn: I tried. it doesn't have one.

[21:17] <pmichaud> rakudo:  my $match = Perl6::Grammar.parse("say <OH HAI>");  say $match<TOP>;

[21:17] <p6eval> rakudo fb2fd4: OUTPUT«Use of uninitialized value␤␤»

[21:17] <jnthn> aww.

[21:17] <masak> neither can it be turned into a Hash.

[21:18] <pmichaud> rakudo:  my $match = Perl6::Grammar.parse("say <OH HAI>");  say $match.hash

[21:18] <p6eval> rakudo fb2fd4: OUTPUT«No result object␤in Main (/tmp/fVyY03YoaO:2)␤»

[21:18] <pmichaud> rakudo:  my $match = Perl6::Grammar.parse("say <OH HAI>");  say $match.PARROT

[21:18] <p6eval> rakudo fb2fd4: OUTPUT«Method 'PARROT' not found for invocant of class 'Perl6;Grammar'␤»

[21:18] <pmichaud> okay, I have to rework the inheritance a bit more.

[21:18] <masak> just wanted to alert you to the remaining issues. :)

[21:18] <jnthn> rakudo: my $match = Perl6::Grammar.parse("say <OH HAI>"); say $match<statement_block>

[21:18] <p6eval> rakudo fb2fd4: OUTPUT«say <OH HAI>␤»

[21:19] <jnthn> pmichaud: There you go. :-)

[21:19] <pmichaud> rakudo:  my $match = Perl6::Grammar.parse("say <OH HAI>");  _dumper($match);

[21:19] <masak> jnthn: hm, introspection by guessing... :P

[21:19] <p6eval> rakudo fb2fd4: OUTPUT«Could not find non-existent sub _dumper␤»

[21:19] <jnthn> masak: No, by looking at grammar.pg :-P

[21:19] <jnthn> "Educated guessing" ;-0

[21:19] <masak> jnthn: not sure that scales well...

[21:20] <pmichaud> rakudo:  class Perl6::Grammar is also { method perl() { Grammar::perl(self); } };   my $match = Perl6::Grammar.parse("say <OH HAI>");  say $match.perl;

[21:20] <p6eval> rakudo fb2fd4: OUTPUT«Null PMC access in invoke()␤in method Perl6::Grammar::perl (/tmp/HDQYLrGhRA:2)␤called from Main (/tmp/HDQYLrGhRA:2)␤»

[21:20] <pmichaud> rakudo:  class Perl6::Grammar is also { method perl() { Match::perl(self); } };   my $match = Perl6::Grammar.parse("say <OH HAI>");  say $match.perl;

[21:20] <p6eval> rakudo fb2fd4: OUTPUT«Method '!_perl' not found for invocant of class 'Perl6;Grammar'␤»

[21:21] <pmichaud> bah.

[21:21] <pmichaud> I'll have to rework the inheritance a bit.

[21:21] <pmichaud> jnthn: I'll need to run for a bit (more)

[21:21] <jnthn> pmichaud: OK. I'm getting tired and making dumb mistakes anyway, so think I'm going to stop coding here anyway.

[21:22] <pmichaud> on Perl6MultiSub, to the extent that it makes existing (source) code simpler, I'm very happy with it.  If it makes the source code more complicated, I'd prefer to stick with our existing approach (and work on moving things to settings) unless we get a speed improvement.

[21:22] <masak> pmichaud: I think that last one worked, but struck an error inside the Match somewhere, like the RT bug I submitted the other day.

[21:22] <pmichaud> it worked, but PCT::Grammar ends up not having a '!_perl' method.

[21:22] <pmichaud> because it's not really inheriting from Match

[21:23] <pmichaud> which if it did, would solve the .perl problem

[21:23] <pmichaud> thus

[21:23] <jnthn> pmichaud: I think from what I've seen today moving things to setting is going to be a better way to go.

[21:23] <pmichaud> I'll have to rework the inheritance a bit.

[21:23] <pmichaud> jnthn: I'm in agreement with that.

[21:23] <jnthn> pmichaud: But I think I want to get the alternative signatures syntax in place too.

[21:23] <pmichaud> yes, that's also very important to this.

[21:23] <jnthn> Sure. I hadn't realized that until now.

[21:23] <pmichaud> I'll see if I can get the "is equiv()" stuff in place.

[21:24] <pmichaud> with "is equiv()", we can move more operators to setting

[21:24] <jnthn> OK, great.

[21:24] <jnthn> Combining the load init blocks together would also be a win.

[21:24] <pmichaud> I'll look at that also.

[21:24] <jnthn> I'm also thinking we need to try and speed up signature creation some.

[21:24] <pmichaud> that would be a big win.

[21:25] <jnthn> Right, I'm just not sure how best to do it yet.

[21:25] <pmichaud> we may get a bit of a win if/when I can switch ro<->rw

[21:25] *** hanekomu_ is now known as hanekomu

[21:25] <pmichaud> the existing sig creation stuff was more "straightforward, works" than "fast"

[21:25] <jnthn> Aye.

[21:25] <pmichaud> as I said, I'm much more concerned about runtime performance than startup cost.

[21:26] <pmichaud> (startup cost is easier to explain away to people who say "performance stinks" :-)

[21:26] <jnthn> Sure, but we can't ignore startup cost completely either.

[21:26] <pmichaud> no, but we can point out ways that it's likely to be improved

[21:27] <pmichaud> that's harder to do with runtime performance right now.

[21:27] <jnthn> True.

[21:27] <jnthn> We'll know better with profiling tools.

[21:27] <jnthn> Plus when the everlasting calling conventions refactor lands.

[21:27] <pmichaud> oh, if you have any comments to add to the emails I sent to rdice earlier, they might be helpful.  :-)

[21:27] *** gegloe joined
[21:28] <pmichaud> chromatic expressed an interest in working on that.

[21:28] <jnthn> I intend to, will today or probably tomorrow since I will be more coherent then.

[21:28] <pmichaud> as in "soon"

[21:28] <jnthn> The profiler or the claling conventions?

[21:28] <jnthn> The profiler I know about.

[21:28] <pmichaud> calling conventions

[21:28] <jnthn> Oh, wow.

[21:28] <jnthn> That would be good.

[21:28] <jnthn> We might actually get them fast. :-)

[21:28] <jnthn> Or fastish.

[21:28] <pmichaud> as in "make it work immediately after 1.4 is released"  (since it's unlikely to be ready before 1.3 releases, and allison doesn't want significant changes between 1.3 and 1.4)

[21:29] *** skids_ left
[21:29] <jnthn> Ideally, I'd like to work in August on trying to get our signature stuff straightened out a bit.

[21:30] <jnthn> So that's just a bit after 1.4...

[21:30] <pmichaud> sounds good, I'm not sure how calling convention will play out.

[21:30] <jnthn> Sure, me either...gets frustrating waiting and wodnering.

[21:30] <pmichaud> I'm more than a little disappointed that it won't be here in 1.4, especially since I flagged it as critically important at PDS

[21:30] <pmichaud> (I flagged it as critically important for 1.0, even, but it got dropped from the list somehow)

[21:31] <jnthn> Right, it's slipped many months now.

[21:32] *** eternaleye joined
[21:33] <pmichaud> afk for a while

[21:33] <jnthn> k

[21:33] *** Whiteknight joined
[21:39] <masak> rakudo: module A { role B {}; class C does B {} }

[21:39] <p6eval> rakudo fb2fd4: OUTPUT«Null PMC access in find_method()␤in Main (/tmp/w0Ci3yOnXG:2)␤»

[21:46] *** [particle]1 left
[21:51] <masak> wow! I was naughty and wrote the implementation before the tests... so I git-stashed the implementation, wrote a few tests, made sure they failed, unstashed, and watched them pass! git++

[21:52] *** iblechbot left
[21:52] <viklund_> tdd ftw!!!

[21:53] *** eternaleye left
[21:53] <masak> tla ftw too :)

[21:54] <viklund_> what's too short for?

[21:55] <masak> "I Think You Know".

[22:09] <masak> Matt-W: I notice you're not testing for interesting failure modes in t/06-form.t.

[22:10] <masak> Matt-W: I'm momentarily stuck with the numeric field stuff, so I might add a few tests for that.

[22:15] *** nihiliad left
[22:16] *** snarkyboojum joined
[22:18] <masak> rakudo: say 'abcdefghi'.comb(/<[aei]>/).perl

[22:18] <p6eval> rakudo fb2fd4: OUTPUT«["a", "e", "i"]␤»

[22:18] <masak> rakudo: my $a="bacadae"; for $a.comb("a") -> $c { say $c }

[22:19] <p6eval> rakudo fb2fd4: OUTPUT«No applicable candidates found to dispatch to for 'comb'␤in Main (/tmp/NDXRKfHIWJ:2)␤»

[22:19] <masak> rakudo: my $a="bacadae"; for $a.comb(/a/) -> $c { say $c }

[22:19] <p6eval> rakudo fb2fd4: OUTPUT«a␤a␤a␤»

[22:20] *** M_o_C left
[22:23] <masak> rakudo: say /foo/ ~~ Regex

[22:23] <p6eval> rakudo fb2fd4: OUTPUT«1␤»

[22:23] *** clintongormley left
[22:24] <masak> the signature at src/setting/Any-str.pm:134 still says Code. should it be Regex instead, like in S32?

[22:24] <masak> rakudo: say 'abcdef'.comb({1}).perl

[22:24] <p6eval> rakudo fb2fd4: OUTPUT«Method 'to' not found for invocant of class 'Int'␤»

[22:25] * masak submits rakudobug

[22:25] <masak> (I can change the source too, if someone just nods.)

[22:37] *** frew|work joined
[22:37] *** snarkyboojum left
[22:44] *** snarkyboojum joined
[22:48] <jnthn> http://bratislava.pm.org/down/doc/Perl6-Spec-DocBook-r27013.pdf # jozef++ from my PM group does pod2docbook stuff and managed to PDF-ize the Perl 6 spec!

[22:50] *** eternaleye joined
[22:50] <DanielC> jnthn: I managed to make the RPN calculator (several hours ago). It's very nice. In the end I completely rewrote the program.

[22:50] <masak> jnthn: nice!

[22:50] <DanielC> jnthn: I have a very nice grammar for it, and it can handle complex expressions like  '5 4 + 3 / 5 3 - *'

[22:50] <jnthn> DanielC: Awesome!

[22:50] *** alester left
[22:50] <DanielC> jnthn: I'll put it somewhere in perl6-examples.

[22:53] *** ashizawa left
[22:53] <masak> DanielC++

[22:53] <DanielC> :-)

[22:53] <masak> ok, heading home for the night.

[22:53] * DanielC commits

[22:54] <masak> see y'all tomorrow.

[22:54] *** masak left
[22:54] <DanielC> night

[22:55] *** ashizawa joined
[22:55] *** Whiteknight left
[22:59] * jnthn is tired

[22:59] <jnthn> So, rest time

[23:00] <jnthn> night all

[23:00] <DanielC> night

[23:02] *** presh is now known as bigpresh

[23:03] *** nsh joined
[23:05] *** justatheory joined
[23:06] *** bigpresh is now known as bigpresh_

[23:06] *** Muixirt left
[23:08] *** frew|work left
[23:17] *** skids_ joined
[23:26] *** bigpresh_ left
[23:26] *** bigpresh joined
[23:26] *** bigpresh left
[23:27] *** hanekomu left
[23:27] *** bigpresh joined
[23:27] *** bigpresh left
[23:28] *** bigpresh joined
[23:28] *** bigpresh left
[23:28] *** bigpresh_ joined
[23:28] *** bigpresh_ left
[23:29] *** bigpresh_ joined
[23:29] *** bigpresh_ left
[23:30] *** bigpresh_ joined
[23:32] *** kate21de1 joined
[23:32] *** Lectus joined
[23:34] *** Limbic_Region joined
[23:35] *** unitxt left
[23:41] *** hercynium joined
[23:44] <sjohnson> the camel book shuold have on the front page

[23:44] <sjohnson> "Review the core modules at http://perldoc.perl.org/5.8.8/index-modules-A.html"

[23:44] <sjohnson> i can't believe how many times i've reinvented the wheel

[23:48] *** kate21de left
[23:50] *** rewt joined
[23:53] *** amoc joined
[23:58] <Khisanth> sjohnson: no, search CPAN :)

[23:59] *** DemoFreak left
