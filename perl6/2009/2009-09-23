[00:07] *** lmc left
[00:25] *** justatheory left
[00:32] *** Student left
[00:32] *** elmex left
[00:32] *** synth left
[00:32] *** lisppaste3 left
[00:32] *** rjh left
[00:32] *** garron left
[00:32] *** blaze-x left
[00:32] *** Woodi left
[00:32] *** leedo_ left
[00:32] *** Infinoid left
[00:32] *** buu left
[00:32] *** meteorjay left
[00:32] *** yves left
[00:32] *** solarion left
[00:32] *** clkao left
[00:32] *** christine left
[00:32] *** integral left
[00:32] *** dmpk2k left
[00:32] *** TiMBuS left
[00:32] *** rhr left
[00:32] *** omega left
[00:32] *** dbrock` left
[00:32] *** Patterner left
[00:32] *** cotto left
[00:32] *** japhb left
[00:32] *** hudnix left
[00:32] *** wolverian left
[00:32] *** mj41_ left
[00:32] *** zostay left
[00:32] *** ingy left
[00:32] *** silug left
[00:32] *** payload left
[00:32] *** dalek left
[00:32] *** zaphar_ps left
[00:32] *** frettled left
[00:32] *** diakopter left
[00:32] *** sri_ left
[00:32] *** mtve left
[00:32] *** jan_ left
[00:32] *** nothingmuch left
[00:32] *** jql left
[00:32] *** jrtayloriv left
[00:32] *** Limbic_Region left
[00:32] *** crythias left
[00:32] *** simcop2387 left
[00:32] *** zerhash left
[00:32] *** Matt-W left
[00:32] *** tylerni7 left
[00:32] *** Grrrr left
[00:32] *** sjohnson left
[00:32] *** mdxi left
[00:32] *** zev left
[00:32] *** lucs left
[00:32] *** mspauldi1g left
[00:32] *** arnsholt left
[00:32] *** Rint left
[00:32] *** pjcj left
[00:32] *** hcchien left
[00:32] *** kcwu left
[00:32] *** kst left
[00:32] *** avar left
[00:32] *** cls_bsd left
[00:32] *** moritz_ left
[00:32] *** allbery_b left
[00:32] *** Intensity left
[00:32] *** KatrinaTheLamia left
[00:32] *** avuserow left
[00:32] *** ezra left
[00:32] *** pugs_svn left
[00:32] *** s1n left
[00:32] *** hugme left
[00:32] *** nbrown left
[00:32] *** mikehh left
[00:32] *** BooK left
[00:32] *** drbean left
[00:32] *** sbp left
[00:32] *** phenny left
[00:32] *** pmichaud left
[00:32] *** buubot left
[00:32] *** devin left
[00:32] *** Caelum left
[00:32] *** ssm left
[00:32] *** tak11 left
[00:32] *** NorwayGeek|Away left
[00:32] *** szabgab left
[00:32] *** donaldh left
[00:32] *** [particle] left
[00:32] *** Confield left
[00:32] *** JarJarBinks left
[00:32] *** Maddingue left
[00:32] *** Helios- left
[00:32] *** kolibrie left
[00:32] *** Khisanth left
[00:32] *** frodwith left
[00:32] *** nsh left
[00:32] *** c9s left
[00:32] *** PerlJam left
[00:32] *** ewilhelm left
[00:32] *** tomaw_ left
[00:33] *** diakopter joined
[00:33] *** jrtayloriv joined
[00:33] *** TiMBuS joined
[00:33] *** Limbic_Region joined
[00:33] *** crythias joined
[00:33] *** rhr joined
[00:33] *** omega joined
[00:33] *** tak11 joined
[00:33] *** dbrock` joined
[00:33] *** Student joined
[00:33] *** elmex joined
[00:33] *** dalek joined
[00:33] *** Patterner joined
[00:33] *** zaphar_ps joined
[00:33] *** NorwayGeek|Away joined
[00:33] *** synth joined
[00:33] *** szabgab joined
[00:33] *** simcop2387 joined
[00:33] *** ssm joined
[00:33] *** donaldh joined
[00:33] *** avuserow joined
[00:33] *** zerhash joined
[00:33] *** lisppaste3 joined
[00:33] *** arnsholt joined
[00:33] *** mikehh joined
[00:33] *** mspauldi1g joined
[00:33] *** Confield joined
[00:33] *** nbrown joined
[00:33] *** tomaw_ joined
[00:33] *** japhb joined
[00:33] *** leedo_ joined
[00:33] *** mj41_ joined
[00:33] *** drbean joined
[00:33] *** ingy joined
[00:33] *** [particle] joined
[00:33] *** hcchien joined
[00:33] *** kst joined
[00:33] *** hudnix joined
[00:33] *** jan_ joined
[00:33] *** meteorjay joined
[00:33] *** cotto joined
[00:33] *** hugme joined
[00:33] *** lucs joined
[00:33] *** zev joined
[00:33] *** zostay joined
[00:33] *** clkao joined
[00:33] *** sri_ joined
[00:33] *** avar joined
[00:33] *** Woodi joined
[00:33] *** integral joined
[00:33] *** irc.freenode.net sets mode: +o diakopter

[00:33] *** Helios- joined
[00:33] *** mdxi joined
[00:33] *** KatrinaTheLamia joined
[00:33] *** nothingmuch joined
[00:33] *** kolibrie joined
[00:33] *** Khisanth joined
[00:33] *** sjohnson joined
[00:33] *** Intensity joined
[00:33] *** yves joined
[00:33] *** blaze-x joined
[00:33] *** wolverian joined
[00:33] *** pjcj joined
[00:33] *** garron joined
[00:33] *** Grrrr joined
[00:33] *** frettled joined
[00:33] *** kcwu joined
[00:33] *** buu joined
[00:33] *** buubot joined
[00:33] *** Caelum joined
[00:33] *** tylerni7 joined
[00:33] *** silug joined
[00:33] *** devin joined
[00:33] *** s1n joined
[00:33] *** jql joined
[00:33] *** BooK joined
[00:33] *** Rint joined
[00:33] *** Matt-W joined
[00:33] *** ewilhelm joined
[00:33] *** nsh joined
[00:33] *** dmpk2k joined
[00:33] *** Infinoid joined
[00:33] *** rjh joined
[00:33] *** solarion joined
[00:33] *** christine joined
[00:33] *** mtve joined
[00:33] *** allbery_b joined
[00:33] *** moritz_ joined
[00:33] *** cls_bsd joined
[00:33] *** sbp joined
[00:33] *** phenny joined
[00:33] *** pugs_svn joined
[00:33] *** ezra joined
[00:33] *** pmichaud joined
[00:33] *** irc.freenode.net sets mode: +oovo Matt-W moritz_ pugs_svn pmichaud

[00:33] *** JarJarBinks joined
[00:33] *** PerlJam joined
[00:33] *** Maddingue joined
[00:33] *** c9s joined
[00:33] *** frodwith joined
[00:33] *** irc.freenode.net sets mode: +o PerlJam

[00:43] *** Whiteknight joined
[00:54] *** payload joined
[00:54] *** PZt joined
[00:54] *** rhr_ joined
[01:07] *** rhr left
[01:08] <jrtayloriv> In NQP, if I'm trying to match the # sign in a token, can I just put it in quotes like '#', or do I have to do something special so that it's not treated as the beginning of a comment?

[01:08] *** drbean left
[01:08] *** drbean joined
[01:12] <pmichaud> ...nqp?

[01:12] <pmichaud> nqp doesn't do regexes yet.

[01:12] <pmichaud> (it probably will by the end of september, but it doesn't do it today)

[01:13] <jrtayloriv> lol -- oops PGE, sorry.

[01:15] <pmichaud> oh.  To match a #, it needs to be in single quotes for PGE, yes.

[01:15] <pmichaud> otherwise it's a comment.

[01:15] <jrtayloriv> thanks.

[01:16] <diakopter> vijs: say "blue" if 0

[01:16] <p6eval> vijs 28370: OUTPUT«blue␤␤ time in interpreter: 0.006814 s␤»

[01:16] <diakopter> perl6: say "blue" if 0

[01:16] <p6eval> elf 28374, pugs, rakudo 0eaf62:  ( no output )

[01:17] *** lambdabot joined
[01:17] * diakopter starts

[01:18] <diakopter> TimToady: ooohhhh; so that's what statement_mod_cond is for :)

[01:23] *** lambdabot left
[01:25] *** lambdabot joined
[01:26] <TimToady> @karma diakopter

[01:26] <lambdabot> diakopter has a karma of 22

[01:26] <crythias> my karma ran over my dogma

[01:27] <crythias> lambda... the dance of the forbidden greek letter.

[01:28] <TimToady> my lambda is wearing your kappa

[01:28] <crythias> Omicron Gamma

[01:29] <TimToady> psi! there's nothing nu.

[01:30] <crythias> I was delta bad hand.

[01:30] <TimToady> decom-mu-ting &

[01:30] <diakopter> snicker

[01:33] <crythias> Let's play a new gamma.

[01:34] <crythias> Iota try something ... what did you eta for dinner?

[01:34] *** kcwu left
[01:35] <crythias> If at first you don't compile, vi, vi again.

[01:42] *** Whiteknight left
[01:50] *** stephenlb left
[01:51] *** [1]Limbic_Region joined
[01:55] *** jrtayloriv left
[01:55] *** jrtayloriv joined
[01:57] *** dukeleto left
[02:08] *** nihiliad joined
[02:08] *** Limbic_Region left
[02:08] *** [1]Limbic_Region is now known as Limbic_Region

[02:30] *** dukeleto joined
[02:33] *** lambdabot left
[02:35] *** lambdabot joined
[02:42] <crythias> perl6: 10 GOTO 10

[02:42] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "GOTO"␤    expecting operator␤    at /tmp/uOvopJLgG4 line 1, column 4␤»

[02:42] <p6eval> ..rakudo 0eaf62: OUTPUT«Confused at line 2, near "GOTO 10"␤in Main (src/gen_setting.pm:3469)␤»

[02:42] <p6eval> ..elf 28374: OUTPUT«Parse error in: /tmp/4XMflHYfTW␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: 10 GOTO 10␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤  STD_red/std.rb:210:in

[02:42] <p6eval> ..`_UNI…

[02:42] <crythias> that's just scary

[02:43] *** rhr joined
[02:43] <crythias> perl6: 10 cls

[02:43] <p6eval> rakudo 0eaf62: OUTPUT«Confused at line 2, near "cls"␤in Main (src/gen_setting.pm:3469)␤»

[02:43] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "cls"␤    expecting operator␤    at /tmp/VlDMFOz83g line 1, column 4␤»

[02:43] <p6eval> ..elf 28374: OUTPUT«Parse error in: /tmp/V8stxc8WZO␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: 10 cls␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤  STD_red/std.rb:210:in

[02:43] <p6eval> ..`_UNIT'␤ …

[02:44] <crythias> perl6: 10 PRINT "HELLO, WORLD!";

[02:44] <p6eval> elf 28374: OUTPUT«Parse error in: /tmp/60x5a8Pxkg␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: 10 PRINT "HELLO, WORLD!";␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[02:44] <p6eval> ..STD_red/std.…

[02:44] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "PRINT"␤    expecting operator␤    at /tmp/o8h0QTPOZG line 1, column 4␤»

[02:44] <p6eval> ..rakudo 0eaf62: OUTPUT«Confused at line 2, near "PRINT \"HEL"␤in Main (src/gen_setting.pm:3469)␤»

[02:45] <crythias> perl6: say "Ain't no thing but a perl thang"

[02:45] <p6eval> elf 28374, pugs, rakudo 0eaf62: OUTPUT«Ain't no thing but a perl thang␤»

[02:46] <crythias> perl6: require HiRes::Graphics;

[02:46] <p6eval> rakudo 0eaf62: OUTPUT«invoke() not implemented in class 'Undef'␤in Main (/tmp/zhYNVOSfcj:2)␤»

[02:46] <p6eval> ..pugs: OUTPUT«*** Unsafe function 'require' called under safe mode␤    at /tmp/DOfshjyaaO line 1, column 1␤»

[02:46] <p6eval> ..elf 28374: OUTPUT«Undefined subroutine &GLOBAL::require called at (eval 122) line 3.␤ at ./elf_h line 5881␤»

[02:47] *** dukeleto left
[02:48] *** rhr_ left
[03:12] *** Limbic_Region left
[03:14] *** jrtayloriv left
[03:22] *** jrtayloriv joined
[03:22] *** __ash__ joined
[03:40] <tak11> http://pastebin.com/d7d6838ac  <= anyone know how to fix that error when running perl Makefile.pl in trying to build pugs,

[03:40] <tak11> cabal update, says command not found*

[03:52] *** crythias left
[04:02] *** PZt left
[04:15] *** __ash__ left
[04:17] *** tak11 left
[04:46] *** justatheory joined
[04:48] *** justatheory left
[04:48] *** justatheory joined
[05:02] *** __ash__ joined
[05:09] *** kent\n left
[05:13] *** charsbar left
[05:14] *** charsbar joined
[05:15] *** Student left
[05:28] *** rfordinal joined
[05:28] *** justatheory left
[05:29] *** masak joined
[05:29] <masak> morning, #perl6!

[05:30] <TimToady> top o' the evening t' ya

[05:35] *** rfordinal left
[05:45] *** __ash__ left
[05:47] *** JimmyZ joined
[06:05] *** kcwu joined
[06:21] <moritz_> \o/

[06:22] <masak> |o|

[06:43] *** mberends joined
[06:46] <masak> mberends: ahoj!

[06:46] <mberends> hai masak, moritz_ !

[06:48] <mberends> I'm in a Windows classroom this week, trying out various ways of building Rakudo

[06:48] <masak> last test I made work in Squerl: $dataset = Squerl::Dataset.new('').from('test'); my $sub = Squerl::Dataset.new('').from('something').filter('x' => 2); is $dataset.insert_sql($sub), 'INSERT INTO test SELECT * FROM something WHERE (x = 2)'

[06:49] *** ruoso left
[06:49] <moritz_> so a dataset is a also an SQL builder?

[06:49] <masak> yes, it outpus some sort of default SQL.

[06:50] <masak> but it seems very overridable, so I guess different adapters supply dialect modifications ad lib.

[06:57] <masak> s/pus/puts/

[07:04] <moritz_> yesterday night I tried to implement some of thew new features of infix:<...>

[07:04] <moritz_> but it depends on signature handling features that aren't available from perl yet (only PIR), it seems

[07:05] <moritz_> unless...

[07:06] <moritz_> rakudo: sub infix<....>(\$cap) { say $cap.perl }; 1, 2 .... 3, 4

[07:06] <p6eval> rakudo 0eaf62: OUTPUT«Malformed routine definition at line 2, near "infix<...."␤in Main (src/gen_setting.pm:3469)␤»

[07:06] <moritz_> rakudo: multi sub infix<...>(\$cap) { say $cap.perl }; 1, 2 ... 3, 4

[07:06] <p6eval> rakudo 0eaf62: OUTPUT«Malformed routine definition at line 2, near "infix<...>"␤in Main (src/gen_setting.pm:3469)␤»

[07:06] <moritz_> rakudo: multi sub infix:<...>(\$cap) { say $cap.perl }; 1, 2 ... 3, 4

[07:06] <p6eval> rakudo 0eaf62: OUTPUT«Malformed routine definition at line 2, near "infix:<..."␤in Main (src/gen_setting.pm:3469)␤»

[07:06] <moritz_> rakudo: multi sub infix:<...>($cap) { say $cap.perl }; 1, 2 ... 3, 4

[07:06] <p6eval> rakudo 0eaf62: OUTPUT«No applicable candidates found to dispatch to for 'infix:...'␤in Main (/tmp/NlVUcHTOME:2)␤»

[07:07] <moritz_> rakudo: multi sub infix:<...>(|$cap) { say $cap.perl }; 1, 2 ... 3, 4

[07:07] <p6eval> rakudo 0eaf62: OUTPUT«Malformed routine definition at line 2, near "infix:<..."␤in Main (src/gen_setting.pm:3469)␤»

[07:07] <masak> I think prefix:<|> is for call-side only.

[07:07] <moritz_> so what's the syntax for a signature that receives a raw capture?

[07:07] <masak> and I don't really see what prefix:<\> would mean in a signature.

[07:08] <masak> 'Capture $cap', perhaps?

[07:08] <masak> though even that would need to be special-cased, I guess...

[07:10] <moritz_> std: multi sub infix:<...>(\$cap) { say "hi" }

[07:10] <p6eval> std 28370: OUTPUT«ok 00:03 98m␤»

[07:14] *** explorer joined
[07:14] <masak> moritz_: I don't see any example of \$var in any signature in S06.

[07:15] <masak> std: multi foo(4) {}

[07:15] <p6eval> std 28370: OUTPUT«ok 00:01 99m␤»

[07:15] <masak> rakudo: multi foo(4) { say "OH FOUR" }; foo(4)

[07:15] <p6eval> rakudo 0eaf62: OUTPUT«OH FOUR␤»

[07:16] <masak> that is so cool.

[07:16] <moritz_> S06:2945:=item .cando(\$capture)

[07:17] <masak> but that's a call as well, isn't it?

[07:17] <masak> not a declaration.

[07:17] *** iblechbot joined
[07:18] <moritz_> I think it's a declaration

[07:18] <moritz_> STD.pm parses it.

[07:18] <moritz_> but I think it's underspecced

[07:19] *** nihiliad left
[07:19] <masak> std: multi foo(\$capture1, \$capture2) {}

[07:19] <p6eval> std 28370: OUTPUT«ok 00:01 96m␤»

[07:19] *** ejs joined
[07:20] *** donaldh left
[07:20] <JimmyZ> rakudo: multi foo(Int $a) { say "Int" }; multi foo(String $a) { say "String" };  foo(4); foo('4');

[07:20] <p6eval> rakudo 0eaf62: OUTPUT«Malformed routine definition at line 2, near "foo(String"␤in Main (src/gen_setting.pm:3469)␤»

[07:20] <masak> JimmyZ: Str.

[07:20] <JimmyZ> rakudo: multi foo(Int $a) { say "Int" }; multi foo(Str $a) { say "String" };  foo(4); foo('4');

[07:20] <p6eval> rakudo 0eaf62: OUTPUT«Int␤String␤»

[07:20] <JimmyZ> masak: ;)

[07:21] * masak looks forward to '$a as Int'

[07:23] * moritz_ too

[07:24] *** donaldh joined
[07:24] <moritz_> augment class Any { method sin($self as Num:) { ... } }

[07:28] *** dbrock` left
[07:29] *** ejs1 joined
[07:33] *** cmv joined
[07:35] *** am0c joined
[07:38] *** ejs left
[07:41] *** jauaor left
[07:41] *** araujo left
[07:48] *** cmv left
[07:54] *** meppl joined
[07:54] *** cmv joined
[08:04] *** TiMBuS left
[08:17] *** dukeleto joined
[08:19] <masak> what's the well-thought-out-practice way to test that a given method call produces a given exception?

[08:20] <moritz_> 1) write an exception hierarchy

[08:20] <masak> :P

[08:20] <moritz_> 2) write a test function that does the check

[08:20] <moritz_> 3) ...

[08:20] <Matt-W> 4) PROFIT

[08:20] <moritz_> 4) Prophet!

[08:21] <masak> my goal includes (1), but probably not the exception hierarchy you mean.

[08:21] <masak> it's for Squerl.

[08:21] <masak> moritz_: and your (2) is just evading my actual question...

[08:22] <moritz_> masak: I know.

[08:22] <moritz_> masak: a few months ago TimToady++ added a thorough description of $! to the specs

[08:23] <moritz_> masak: that all needs testing and implementing

[08:23] <moritz_> r26968, if you're curious

[08:24] *** zloyrusskiy joined
[08:24] <masak> rakudo: class MyException {}; class Cranky { method foo() { die MyException.new } }; Cranky.new.foo

[08:24] <p6eval> rakudo 0eaf62: OUTPUT«MyException()<0x2ad3a6f805e0>␤in method Cranky::foo (/tmp/k4r7IW97CC:2)␤called from Main (/tmp/k4r7IW97CC:2)␤»

[08:24] <masak> rakudo: class MyException {}; class Cranky { method foo() { die MyException.new } }; try { Cranky.new.foo }

[08:24] <p6eval> rakudo 0eaf62:  ( no output )

[08:24] <masak> rakudo: class MyException {}; class Cranky { method foo() { die MyException.new } }; try { Cranky.new.foo; CATCH { say "OH HAI" } }

[08:24] <p6eval> rakudo 0eaf62: OUTPUT«OH HAI␤»

[08:25] <masak> rakudo: class MyException {}; class Cranky { method foo() { die MyException.new } }; try { Cranky.new.foo; CATCH { say "OH HAI $!" } }

[08:25] <p6eval> rakudo 0eaf62: OUTPUT«OH HAI MyException()<0x2b72fa807000>␤»

[08:25] <masak> rakudo: class MyException {}; class Cranky { method foo() { die MyException.new } }; try { Cranky.new.foo; CATCH { say $! ~~ MyException } }

[08:25] <p6eval> rakudo 0eaf62: OUTPUT«0␤»

[08:25] <masak> o.O

[08:25] <masak> probably stringifies on the way...

[08:28] <moritz_> rakudo: class MyException {}; class Cranky { method foo() { die MyException.new } }; try { Cranky.new.foo; CATCH { say $!.WHAT }

[08:28] <p6eval> rakudo 0eaf62: OUTPUT«Unable to parse block; couldn't find final '}' at line 2, near ""␤in Main (src/gen_setting.pm:3469)␤»

[08:28] <masak> it's not unlikely that I will need this for Squerl, so that might motivate me to write Perl 6 spectests.

[08:28] <moritz_> rakudo: class MyException {}; class Cranky { method foo() { die MyException.new } }; try { Cranky.new.foo; CATCH { say $!.WHAT } }

[08:28] <p6eval> rakudo 0eaf62:  ( no output )

[08:29] <moritz_> rakudo: class MyException {}; class Cranky { method foo() { die MyException.new } }; say "hi"; try { Cranky.new.foo; CATCH { say $!.WHAT } }

[08:29] <p6eval> rakudo 0eaf62: OUTPUT«hi␤»

[08:29] <moritz_> am I doing something really stupid here?

[08:29] <Matt-W> interesting

[08:29] <Matt-W> that looks... buggy

[08:30] <moritz_> ah, it segfaults

[08:30] <Matt-W> Ah

[08:30] <masak> work remains to be done here(TM).

[08:30] <masak> QED.

[08:30] <Matt-W> Buggy

[08:30] <Matt-W> rakudobug@...

[08:30] * Matt-W gets the fly spray

[08:30] <moritz_> btw rakudo auto-updating on the p6eval server is currently b0rked

[08:30] <moritz_> I tried to be too clever

[08:33] <masak> :/

[08:35] <masak> rakudo: say 1/0; say "Alive"; say (1/0).Num

[08:35] <p6eval> rakudo 0eaf62: OUTPUT«Alive␤Divide by zero␤»

[08:35] <masak> note that the first &say call doesn't print anything.

[08:35] <masak> not even a newline.

[08:35] * masak submits rakudobug

[08:36] <moritz_> masak: I just submitted the segfault, FYI

[08:36] <moritz_> masak: I think yours is already submitted, but I'm not sure

[08:37] <masak> moritz_: ok.

[08:37] <masak> submitting it Justin Case.

[08:42] <moritz_> masak: could you please run t/spec/S32-num/rat.t and tell me if it succeeds?

[08:42] * masak runs it

[08:44] <masak> whoa, lots of tests...

[08:44] <masak> PASS

[08:44] <moritz_> thanks

[08:44] <moritz_> on my laptop at home it dies at the end

[08:44] <moritz_> and I have no idea why

[08:45] <moritz_> I nuked the parrot build

[08:45] <moritz_> and started from a fresh rakudo checkout

[08:45] <masak> hm, but it appears I didn't have the latest version... running again.

[08:47] <masak> hm, and it quickly becomes evident that I need to rebuild Rakudo itself. ;)

[08:57] <masak> rakudo: my %h; %h{42} = 1; say %h.keys[0].WHAT

[08:57] <p6eval> rakudo 0eaf62: OUTPUT«Str()␤»

[08:59] <masak> currently, since Rakudo hashes coerce to Str, there's not much of an issue concerning hash key identity. which equality predicate will be used when general keys can be added?

[09:00] *** synth left
[09:00] <jnthn> masak: I'd guess ===

[09:01] <masak> jnthn!

[09:01] <jnthn> masak!

[09:01] <masak> jnthn: sounds reasonable to me.

[09:01] * jnthn has awful wifi at this hotel...but it's a nice hotel otherwise.

[09:01] <jnthn> Going to Korea tomorrow.

[09:01] <masak> rakudo: say "OH HAI" === "OH HAI"

[09:01] <p6eval> rakudo 0eaf62: OUTPUT«1␤»

[09:01] <masak> phew.

[09:02] *** M_o_C joined
[09:02] <jnthn> masak: Aye, === generally does the right thing for value / referency type-y things.

[09:02] <masak> rakudo: say "OH HAI" === "OH " ~ "HAI"

[09:02] <p6eval> rakudo 0eaf62: OUTPUT«1␤»

[09:02] <masak> \o/

[09:02] <jnthn> Thus why it feels right to me here.

[09:02] <masak> (Perl 6)++

[09:02] <jnthn> Indeed.

[09:03] * jnthn is enjoying his travels, but also looking forward to digging back into Rakudo hacking.

[09:04] <masak> aye.

[09:07] * jnthn wonders what the RT bug count is

[09:08] <jnthn> Hopefully, I get to close up some of the oldest ones in the next couple of months.

[09:09] <masak> jnthn: we're at 494 new/opened/stalled RT tickets.

[09:09] <masak> pushing 500 :)

[09:09] <jnthn> oh noes

[09:10] <jnthn> epic need for rakudo hacking

[09:10] * masak wonders how pmichaud++'s PGE refactors are progressing

[09:11] * jnthn hopes they're going well, but hasn't been watching or talked to pm of late

[09:11] <masak> moritz_: oh, and that test file you asked about PASSes here even after I update Rakudo.

[09:12] <moritz_> masak: thanks

[09:19] *** am0c left
[09:23] *** iblechbot left
[09:26] *** agentzh joined
[09:44] *** pmurias joined
[09:44] <pmurias> diakopter: do we have any ideas how vivjs should be called once it's extracted from viv?

[09:48] <masak> TimToady: Google gives me 10 hits for 'guthlophikralique', all of them related to A12 :)

[09:49] <masak> hm, I probably just created an 11th hit.

[09:50] <masak> rakudo: class A { method foo { say "A"; nextsame } }; class B { method foo { say "B"; nextsame } }; class C is A is B { method foo { say "C"; nextsame } }; C.new.foo

[09:50] <p6eval> rakudo 0eaf62: OUTPUT«C␤A␤B␤»

[09:50] <masak> \o/

[09:53] <masak> if &foo is the way to refer to the sub 'foo', what's the way to refer to a method '.foo' of a class C?

[09:54] *** rfordinal joined
[09:55] <masak> ah, C::foo

[09:55] <masak> rakudo: class A { method foo { say "original" } }; (&A::foo).wrap({ say "before"; callsame; say "after" }); A.new.foo

[09:55] <p6eval> rakudo 0eaf62: OUTPUT«before␤original␤after␤»

[09:55] <masak> that is so cool.

[09:56] <masak> who needs the MONKEY_TYPING pragma when that's possible? :P

[09:57] *** rfordinal left
[10:00] <masak> rakudo: sub foo { say "=" x 40 }; for reverse ^40 -> $n { &foo.wrap({ say "=" x $n; callsame; say "=" x $n }); }; foo

[10:00] <p6eval> rakudo 0eaf62: OUTPUT«␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤========================================␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤»

[10:00] <pmurias> shouldn't it be MONKEY_PATCHING?

[10:00] <masak> pmurias: yes, but it got monkeypatched :P

[10:00] <masak> (there was a spec change)

[10:01] <masak> in the above code, why doesn't $n bind like I think it should?

[10:02] <masak> I had hoped it would produce a nice triangle of ='s.

[10:03] *** payload left
[10:05] <pmurias> rakudo: sub foo { say 40 }; for reverse ^40 -> $n { &foo.wrap({ say $n;  callsame; say $n }); }; foo

[10:05] <p6eval> rakudo 0eaf62: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤40␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[10:06] <pmurias> rakudo: sub foo { say 40 }; for reverse ^40 -> $n { say $n;&foo.wrap({ say $n;  callsame; say $n }); }; foo

[10:06] <p6eval> rakudo 0eaf62: OUTPUT«39␤38␤37␤36␤35␤34␤33␤32␤31␤30␤29␤28␤27␤26␤25␤24␤23␤22␤21␤20␤19␤18␤17␤16␤15␤14␤13␤12␤11␤10␤9␤8␤7␤6␤5␤4␤3␤2␤1␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤40␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0􏿽xE2

[10:06] <mikehh> rakudo (0220cc2) builds on parrot r41428 - make test / make spectest (up to 28374) PASS - Ubuntu 9.04 amd64

[10:07] <pmurias> masak: looks like some sort of a scoping bug

[10:07] * masak submits rakudobug

[10:07] <masak> rakudo: sub foo($n) { say $n; if $n { callsame($n-1) } }; foo(1)

[10:07] <p6eval> rakudo 0eaf62: OUTPUT«1␤Null PMC access in clone()␤in sub foo (/tmp/LZ0ZSuvObp:2)␤called from Main (/tmp/LZ0ZSuvObp:2)␤»

[10:07] * masak submits rakudobug

[10:09] *** iblechbot joined
[10:13] *** agentzh left
[10:26] <moritz_> wow, that reddit submission and twittering of my blog post brought about 1k additional visitors to my website (in one day)

[10:26] *** rfordinal3643 joined
[10:26] <masak> there's still a trickle of tweets about it.

[10:32] *** muixirt joined
[10:33] <muixirt> rakudo: my @a; @a[0, 0] = 1;

[10:33] <p6eval> rakudo 0eaf62:  ( no output )

[10:34] *** JimmyZ left
[10:35] <muixirt> rakudo: my @a; @a[0, 0] = 1; say @a.perl

[10:35] <p6eval> rakudo 0eaf62: OUTPUT«[undef]␤»

[10:43] <Matt-W> moritz_: the one about rats?

[10:44] <moritz_> Matt-W: aye

[10:45] <moritz_> somehow I regularly misjudge the popularity of my blog posts

[10:46] <moritz_> I got lots of good feedback on the "when we reach 100% we did something wrong", but I thought it was boring and lengthy

[10:46] <moritz_> now lots of talk about Rats, just because it has a pun in the title?

[10:48] <Matt-W> I think it's also because there are a lot of programmers out there who are sick of dealing with floating point

[10:48] <Matt-W> that's certainly why *I* find it interesting

[11:00] *** rfordinal joined
[11:00] *** dakkar joined
[11:02] <masak> the title certainly helps, though.

[11:06] <masak> moritz_: "It might come as a shock to you if you haven't looked at Perl 5's source tree, and never compiled it from source and run the tests (and actually looked at the results), but it's true." -- you call that boring? :) it's in-depth journalism!

[11:06] <moritz_> :-)

[11:07] <moritz_> I should ask here for creative titles more often :-)

[11:08] <masak> "Rats, Cats and KitchenSinks, oh my!" :P

[11:08] <moritz_> only when they are implemented :-)

[11:08] <masak> fair enough.

[11:08] <moritz_> rakudo: say KitchenSink.new

[11:08] <p6eval> rakudo 0eaf62: OUTPUT«Could not find non-existent sub KitchenSink␤»

[11:09] <moritz_> we had a thread called "reuse everything but the kitchen sink" on p6l. My first thought was "why shouldn't KitchenSink be reusable too?"

[11:11] *** rfordinal3643__ joined
[11:15] *** am0c joined
[11:16] *** frederico joined
[11:17] *** baest left
[11:17] *** baest joined
[11:20] *** rfordinal3643 left
[11:22] *** rfordinal3643 joined
[11:23] *** rfordinal left
[11:23] *** scottp joined
[11:25] *** M_o_C left
[11:32] *** payload joined
[11:33] *** am0c left
[11:33] *** rfordinal joined
[11:34] *** am0c joined
[11:34] <masak> rakudo: class Forest { class Frog { method speak { say "ribbit ribbit" } }; has Frog $.frog; method new() { my Frog $frog .= new; self.bless(*, :$frog) } }; Forest.new

[11:34] <p6eval> rakudo 0eaf62: OUTPUT«Null PMC access in type()␤in method Forest::new (/tmp/FM8h5DDtSA:2)␤called from Main (/tmp/FM8h5DDtSA:2)␤»

[11:34] * masak submits frog-bug

[11:35] <moritz_> masak: nested classes are documented to be no working on the status page (just FYI)

[11:35] <masak> that's ok.

[11:36] <masak> they also shouldn't be emitting Null PMC access errors. :)

[11:36] <moritz_> aye

[11:38] * moritz_ is pleased to notice that some core modules are deprecated in blead perl

[11:40] *** rfordinal3643 left
[11:42] *** rfordinal3643__ left
[11:43] *** rfordinal3643 joined
[11:54] *** frederico left
[11:54] *** chturne joined
[11:56] *** frederico joined
[11:57] *** rfordinal3643jlj joined
[12:02] *** rfordinal left
[12:05] <masak> rakudo: sub foo { say "OH HAI" }; &foo = &say; foo

[12:05] <p6eval> rakudo 0eaf62: OUTPUT«␤»

[12:05] <moritz_> excuse me?

[12:05] <masak> :)

[12:05] <masak> it's a bug, right?

[12:06] <moritz_> yes, but what is the bug?

[12:06] <masak> I reassigned &foo to &say.

[12:06] <masak> and Rakudo let me.

[12:06] <moritz_> that &foo is assignable? or that it doesn't print the "OH HAI"+

[12:06] <masak> that &foo is assignable.

[12:06] <moritz_> ok

[12:06] <masak> the non-printing of "OH HAI" is just a consequence of &foo being assignable.

[12:07] * masak submits rakudobug

[12:15] *** rfordinal3643 left
[12:17] *** ruoso joined
[12:17] <ruoso> bom dia, #perl6

[12:19] <masak> o/

[12:19] <masak> rakudo: sub funny-smiley {}; say &funny-smiley.signature.perl

[12:19] <p6eval> rakudo 0eaf62: OUTPUT«:()␤»

[12:19] <masak> :()

[12:20] <moritz_> \o|

[12:21] <masak> rakudo: sub zero(0) {}; say &zero.signature.perl

[12:21] <p6eval> rakudo 0eaf62: OUTPUT«:(Int ::TYPE_CAPTURE18 where all({ ... }))␤»

[12:21] * masak ponders whether to contribute a patch for that

[12:23] <masak> rakudo: say (:()).WHAT

[12:23] <p6eval> rakudo 0eaf62: OUTPUT«The opcode 'descalarref_p' (descalarref<1>) was not found. Check the type and number of the arguments␤in Main (src/gen_setting.pm:3469)␤»

[12:23] <masak> whoa!

[12:23] * masak submits rakudobug

[12:23] <masak> what is this, a year ago?

[12:27] *** PZt joined
[12:28] <moritz_> masak: betterworld reported a rakudo segfault with a 13 character program :-)

[12:28] <masak> impressive!

[12:29] <moritz_> I'm trying to convince him to write a bug report

[12:29] <masak> of course he should? why is there even hesitation? :)

[12:30] <moritz_> dunno

[12:30] <moritz_> say 4.HOW.HOW

[12:30] <masak> rakudo: say 4.HOW.HOW

[12:30] <p6eval> rakudo 0eaf62:  ( no output )

[12:30] *** rfordinal3643jlj left
[12:30] <masak> indeed.

[12:30] <masak> betterworld++

[12:40] <dalek> rakudo: e9a7966 | moritz++ | t/harness:

[12:40] <dalek> rakudo: submit smoker name to smolder, jdv79++

[12:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e9a79661c6aa2767d80289bc5422873f93819876

[12:44] *** iblechbot left
[12:52] <pugs_svn> r28375 | pmurias++ | [vivjs] make say print stuff in the firebug console in --jsx mode 

[12:52] <pugs_svn> r28376 | pmurias++ | [vivjs] extracted vivjs from viv into src/perl6/vivjs 

[12:53] <pmurias> diakopter: i extracted vivjs from viv if we have a better name we could rename it now

[12:57] <moritz_> does that mean the invocation to run vijs has changed?

[12:58] <pmurias> yes

[12:58] <moritz_> to?

[12:58] <pmurias> it's now vivjs

[12:59] <moritz_> pmurias: does it still work together with 'make snap'?

[12:59] <pmurias> what's that?

[12:59] <moritz_> that's the make target in src/perl6/ which the evalbot uses to compile STD.pm

[13:00] <moritz_> afk

[13:00] <pmurias> moritz_: coping vivjs should do it

[13:03] *** zloyrusskiy left
[13:05] <pmurias> diakopter: i'm disabling the interpreter took * seconds thing as it's annoying

[13:05] <pugs_svn> r28377 | pmurias++ | [vivjs] slight cleanup 

[13:06] <masak> phenny: tell moritz_ does this help to make a more complete modules graph for proto? http://gist.github.com/191981

[13:06] <phenny> masak: I'll pass that on when moritz_ is around.

[13:09] *** scottp left
[13:18] <pugs_svn> r28378 | jimmy++ | [Spec/S02-bits.pod]wrapping the line. 

[13:28] *** SmokeMachine joined
[13:28] <pmurias> ruoso: gcc -L. -lperl -I .  t-smopp5/basic.c should link with libperl.a?

[13:28] <diakopter> vijs: say 3

[13:28] <p6eval> vijs 28370: OUTPUT«read_file 'js/json2.js' - sysopen: No such file or directory at viv line 165␤»

[13:29] <pmurias> diakopter: hi

[13:29] <diakopter> hi

[13:29] *** JimmyZ joined
[13:30] <pmurias> diakopter: does the extracted vivjs work for you?

[13:30] <diakopter> why did you use vivjs instead of vijs

[13:31] <diakopter> it doesn't matter though; hopefully someone will contribute a better name :)

[13:32] <pmurias> i forgot it's vijs

[13:32] <diakopter> np

[13:33] <diakopter> technically I could work on fixing it in p6eval, but I don't have access yet to the new p6eval chroot on my vps

[13:35] <ruoso> pmurias, -l is for dynamic linking I think

[13:38] <pmurias> and for static?

[13:38] <diakopter> since when is svn update supposed to delete files with uncommitted changes without prompting

[13:39] <diakopter> I guess I'm supposed to check whether the directory holding the files with uncommitted changes has been deleted :[ :[

[13:39] <pmurias> svn is bug ridden

[13:39] <diakopter> :[

[13:40] <diakopter> there went a couple hundred lines

[13:41] *** JimmyZ_ joined
[13:42] <Patterner> -l is for telling the linker the name of a library. -static and -shared are for the type of linking.

[13:47] <diakopter> ok; I was wrong; it only said it D them; the modified files are still there in the original dir

[13:47] <diakopter> but it did delete the unmodified files

[13:48] <diakopter> you'd think the console output of svn update would say 'D this_file but din't actually delete it'

[13:49] *** payload left
[13:52] <diakopter> (but no, it just said:)

[13:52] <diakopter> D    js/builtins.js

[13:52] <diakopter> D    js/interp.js

[13:52] <diakopter> D    js/README

[13:52] <diakopter> D    js/libBigInt.js

[13:52] <diakopter> which frightened me. :)

[13:59] *** alester joined
[13:59] *** synth joined
[14:00] *** iblechbot joined
[14:01] *** rfordinal joined
[14:05] *** JimmyZ left
[14:08] *** icwiener joined
[14:10] *** crythias joined
[14:11] <crythias> perl6: say                                                          Hello, world!

[14:11] <p6eval> elf 28378: OUTPUT«Parse error in: /tmp/lb2nZYzVMP␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say                           ␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[14:11] <p6eval> ..STD_red…

[14:11] <p6eval> ..rakudo 0eaf62: OUTPUT«Confused at line 2, near "!"␤in Main (src/gen_setting.pm:3469)␤»

[14:11] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "!"␤    expecting "::", dot, ":", "(", term postfix, operator or ","␤    at /tmp/yfP38kcNWC line 1, column 74␤»

[14:11] <masak> crythias: you need quotes, not just massive amounts of whitespace :P

[14:11] <crythias> well, that's not what the intro says

[14:12] <masak> which intro?

[14:12] <crythias> the whatchacallit. motd

[14:12] <crythias> topic

[14:12] * masak looks

[14:12] <crythias> say 3

[14:12] <crythias> perl6: say 3

[14:12] <p6eval> elf 28378, pugs, rakudo 0eaf62: OUTPUT«3␤»

[14:12] <crythias> ok. but that's a number.

[14:12] <masak> well, there's a difference between 3 and 'hello world'.

[14:13] <masak> 3 is a number, it doesn't need quotes.

[14:13] <crythias> say 3+3

[14:13] <pmurias> diakopter: commit early, commit often and you'll limit the amount of work that gets wasted

[14:13] <crythias> perl6: say 3+3;

[14:13] <p6eval> elf 28378, pugs, rakudo 0eaf62: OUTPUT«6␤»

[14:13] <moritz_> masak: I found the source of my weird testing bug... ~/.perl6/lib contained a Test.pm which tainted rakudo's spectest

[14:13] <phenny> moritz_: 13:06Z <masak> tell moritz_ does this help to make a more complete modules graph for proto? http://gist.github.com/191981

[14:13] <moritz_> thanks phenny

[14:13] *** muixirt left
[14:14] <masak> moritz_: that's happened to me also. let's eradicate all Test.pm imposters before it's too late!

[14:14] <crythias> perl6: say "Test.pm"

[14:14] <masak> hm, 'impostors'?

[14:14] <p6eval> elf 28378, pugs, rakudo 0eaf62: OUTPUT«Test.pm␤»

[14:14] <moritz_> and merge back all changes worth keeping to rakudo's Test.pm

[14:14] <masak> aye.

[14:14] <masak> though most are probably just old versions.

[14:15] <moritz_> masak: re project list, any data between 2009-02 and 2009-06?

[14:15] <moritz_> erm, 2009-03 and 2009-06

[14:15] * masak looks

[14:16] <masak> oh, indeed.

[14:16] <masak> I'll update the gist.

[14:16] <moritz_> great

[14:16] <moritz_> btw I found that my way of obtaining the data is unreliable

[14:17] <masak> having done it manually, I'm not surprised :P

[14:17] <moritz_> it uses the @date form of git revisions

[14:17] <moritz_> but in that case the date refers to the reflog, not to the commit date of the objects

[14:17] <masak> there was a merge around 2009-02-16, for example. it wasn't really possible to give accurate numbers for a while.

[14:17] *** KyleHa joined
[14:17] <moritz_> so it depends on when I updated my proto repo :(

[14:18] <masak> huh.

[14:18] *** abra joined
[14:19] <masak> would you prefer one data point per date, or several?

[14:19] <moritz_> dontcare

[14:19] <moritz_> oh wait

[14:20] <moritz_> at most one data point per date

[14:20] <moritz_> but I don't need a datapoint for every date

[14:20] <masak> right.

[14:21] <diakopter> pmurias: that might be a good point, if I felt responsible in any way for deleting/losing my own work (and if that had actually happened).

[14:21] <moritz_> gnuplot++ # being smart enough when plotting dates

[14:22] <moritz_> diakopter: did the 'svn up' delete files that had local modifications?

[14:22] <diakopter> no, as I stated above

[14:22] <moritz_> I didn't read all the backlog

[14:22] <masak> moritz_: http://gist.github.com/191981

[14:23] *** justatheory joined
[14:25] <diakopter> I was perturbed that the js/ directory was deleted at all; I didn't realize I was assenting to that when I said it was ok for pmurias to fork viv

[14:26] <moritz_> I thought it was just moved

[14:26] <moritz_> masak: http://rakudo.de/proto-projects-list.png updated

[14:26] <diakopter> it might have been 'svn move'd, but it didn't merge my changes before the move.

[14:26] *** FCO joined
[14:27] <masak> moritz_: nice!

[14:27] <moritz_> diakopter: that's one of svn's shortcomings

[14:27] <masak> something in early July doesn't look right, though...

[14:28] <masak> s/July/June/

[14:29] <moritz_> that might have been the period where I didn't update proto for qutie some time

[14:30] <masak> bah, let's see if I can't automate this after all...

[14:32] <moritz_> a better method for obtaining the file contents at a given date would be most welcome

[14:33] *** SmokeMachine left
[14:35] *** __ash__ joined
[14:39] *** JimmyZ_ left
[14:40] *** Psyche^ joined
[14:41] <pugs_svn> r28379 | moritz++ | [src/perl6] update 'make snap' to symlink vivjs/, not js/ 

[14:41] *** Patterner left
[14:41] *** Psyche^ is now known as Patterner

[14:42] *** __ash__ left
[14:44] *** NorwayGeek|Away left
[14:44] <masak> hm, how do I show the contents of a file from another revision/commit, preferably without using git-checkout?

[14:45] <masak> I asked on #git, but they're having so much fun right now I don't think they saw my question. :)

[14:46] <BinGOs> cherry-pick perhaps ?

[14:46] <masak> well, I don't want to apply any new changes, just navigate the past.

[14:47] <BinGOs> yeah, it appears that will apply the commit.

[14:48] * BinGOs goes back to idling.

[14:48] <Infinoid> masak: git show <rev>:path/file

[14:48] <masak> Infinoid: thanks.

[14:49] *** mberends left
[14:50] *** SmokeMachine joined
[14:54] <pugs_svn> r28380 | moritz++ | [evalbot] fix path to vivjs 

[14:54] *** p6eval left
[14:54] *** p6eval joined
[14:54] <moritz_> vijs: say 3

[14:54] <p6eval> vijs 28379: OUTPUT«3␤»

[14:55] <diakopter> moritz_: thanks :D

[14:56] *** lucs_ joined
[14:59] *** frederico left
[14:59] <masak> moritz_: new data, completely undoctored. I hope I got it right. it doesn't seem to square exactly with the previous figures. http://gist.github.com/191981

[15:00] *** FCO left
[15:04] <moritz_> masak: updated http://rakudo.de/proto-projects-list.png with your new data

[15:06] <masak> still a strange discontinuity in June...

[15:06] <moritz_> anyway, for looking at trends it's good enough

[15:06] <masak> moritz_: I can't help but point out that "Date" collides with... a date.

[15:07] <moritz_> masak: should I remove the label altogether?

[15:07] <pugs_svn> r28381 | diakopter++ | [vijs] implement Bools & rudimentary (guessing :) Bool coercion, also trailing if condition on statement 

[15:08] <masak> possibly.

[15:08] <diakopter> vijs: say 3 if 0; say 2 if True;

[15:08] <p6eval> vijs 28379: OUTPUT«2␤»

[15:08] <moritz_> masak: done

[15:09] <diakopter> perl6: say 3 if 0; say 2 if True;

[15:09] <moritz_> masak: would you like to have the scripts in the proto repo?

[15:09] <p6eval> pugs, rakudo 0eaf62: OUTPUT«2␤»

[15:09] <p6eval> ..elf 28380: OUTPUT«Can't locate object method "Bool" via package "True" (perhaps you forgot to load "True"?) at (eval 123) line 6.␤ at ./elf_h line 5881␤»

[15:09] <TimToady> ＼⚉／

[15:09] <masak> moritz_: that might be a good idea. feel free to commit.

[15:09] <moritz_> masak: will do that from $home later today/tonight

[15:09] <masak> TimToady: nice, long arms, there. :)

[15:09] <moritz_> TimToady: angeber :-)

[15:10] <moritz_> (angeber = poser)

[15:10] <moritz_> rakudo: class A { method b() { } }; A.new.b(3)

[15:10] <p6eval> rakudo 0eaf62: OUTPUT«positional inside named args at position 2␤in method A::b (/tmp/ReMxAVMt4T:2)␤called from Main (/tmp/ReMxAVMt4T:2)␤»

[15:15] *** Student joined
[15:15] <diakopter> perl6: say True if "0"

[15:15] <p6eval> elf 28381, pugs, rakudo 0eaf62:  ( no output )

[15:16] <diakopter> vijs: say True if "0";

[15:16] <p6eval> vijs 28379:  ( no output )

[15:16] <diakopter> vijs: say True

[15:16] <p6eval> vijs 28379: OUTPUT«1␤»

[15:16] <diakopter> perl6: say True

[15:17] <p6eval> pugs, rakudo 0eaf62: OUTPUT«1␤»

[15:17] <p6eval> ..elf 28381: OUTPUT«True␤»

[15:17] <moritz_> diakopter: see t/spec/S03-operators/context-forcers.t for inspiration

[15:17] <crythias> vijs: say True if diakopterrocks=1;

[15:17] <p6eval> vijs 28379: OUTPUT«Undeclared routine:␤  diakopterrocks used at line 1␤»

[15:18] <crythias> vijs: say True if theRunningMan>theCabbagePatch

[15:18] <p6eval> vijs 28379: OUTPUT«Undeclared routines:␤ theCabbagePatch used at line 1␤   theRunningMan used at line 1␤execute(): execute error: undefined not yet implemented; srsly!!?!?␤last: termish␤0,1,2,phase,postDo,eval_args,invoker,context at vivjs line 66.␤»

[15:19] *** iblechbot left
[15:21] <moritz_> vijs: say True;

[15:21] <p6eval> vijs 28379: OUTPUT«1␤»

[15:21] <diakopter> vijs: say True # breaks :D

[15:22] <p6eval> vijs 28379: OUTPUT«1␤»

[15:22] <diakopter> I mean

[15:22] <diakopter> vijs: say True if False # breaks :D

[15:22] <p6eval> vijs 28379: OUTPUT«execute(): execute error: TypeError: Cannot read property 'result' of undefined at vivjs line 66.␤»

[15:23] *** payload joined
[15:24] *** am0c left
[15:27] *** cmv left
[15:28] <pugs_svn> r28382 | jimmy++ | [zh-cn/syn/S02-bits.pod]added more chinese description, just warm-up. 

[15:35] *** anonymous5783 joined
[15:36] *** dakkar left
[15:41] *** masak left
[15:41] *** nihiliad joined
[15:43] *** ejs1 left
[15:47] *** payload left
[15:53] *** ejs joined
[15:58] *** a2n joined
[16:03] *** __ash__ joined
[16:04] *** ejs1 joined
[16:05] *** a2n left
[16:06] <crythias> I tried to think about perl being prel (putting regular expressions linearly) but then I also thought .. what the heck does this have to do with keeping my hair nice and clean? Until I had someone regularly express that to me, for which, of course, I was grateful.

[16:07] <diakopter> I misread prel for purel, and I thought, "you put Purel in your hair?"

[16:08] *** anonymous5783 left
[16:08] <pugs_svn> r28383 | diakopter++ | [vijs] make single-statement statement_lists work 

[16:09] <crythias> of all nits to pick...

[16:11] *** payload joined
[16:12] *** ejs left
[16:13] *** hercynium joined
[16:14] <pugs_svn> r28384 | diakopter++ | [vijs] make single-statement statement_lists with a false trailing condition work :) 

[16:15] <diakopter> vijs: say 2 if 0

[16:15] <p6eval> vijs 28379:  ( no output )

[16:15] <diakopter> vijs: say 2 if 1

[16:15] <p6eval> vijs 28379: OUTPUT«2␤»

[16:16] <TimToady> vijs: say (2 if 0)

[16:16] <p6eval> vijs 28379: OUTPUT«Undef␤»

[16:16] <diakopter> rakudo: say (2 if 0)

[16:16] <p6eval> rakudo 0eaf62: OUTPUT«␤»

[16:16] <TimToady> well, I suppose that's about as close as you can get to Nil so far

[16:17] <TimToady> but rakudo is correct here

[16:17] <crythias> Especially if you don't want to violate the restraining order.

[16:17] <TimToady> a Nil interpolates () into a list

[16:18] <pugs_svn> r28385 | diakopter++ | [vijs] make the borogoves more mimsy 

[16:18] <TimToady> around here I usually have to restrain the violation orders

[16:20] <diakopter> pugs: say (2 if 0)

[16:20] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "if"␤    expecting operator or ")"␤    at /tmp/o6Unwpdbl7 line 1, column 8␤»

[16:20] *** ejs2 joined
[16:20] <crythias> TimToady rearranged is y Do it, Mat?

[16:21] <diakopter> would the real TimToady please stand up, please stand up?

[16:25] <pmichaud> good morning, #perl6

[16:25] <diakopter> or   I'm a Dotty

[16:26] <crythias> gotta love those dotty order violators.

[16:26] <diakopter> pmichaud: 'morn

[16:26] <TimToady> pmichaud: ＼⚉／

[16:26] <diakopter> don't be mournin'

[16:27] <TimToady> just keeping everyone honest about their unicode :)

[16:27] <pmichaud> TimToady: got time for two questions about Cursor.pmc ?

[16:27] <TimToady> soitnly

[16:27] <TimToady> maybe diakopter can answer them :)

[16:28] * diakopter has been reading it a bit lately

[16:28] <pmichaud> currently Cursor.pmc has a number of methods like add_macro, add_enum, etc.  Would those more properly be placed into STD itself, or should they exist for all Cursor objects?

[16:28] <pmichaud> (do_need, do_use, etc.)

[16:29] <TimToady> they're probably more related to STD, yes, but done in Cursor because gimme5 wasn't up to translating it yet...

[16:29] <pmichaud> okay

[16:29] <pmichaud> that's what I figgered

[16:29] <pmichaud> second question is longer

[16:29] * diakopter starts typing the answer sooner

[16:29] *** ejs1 left
[16:30] <TimToady> but also because implementation kinda depends on the backend in P5, so impl dependent

[16:30] <pmichaud> currently Cursor.pmc does the bulk of its work using lazymap and closures

[16:30] <TimToady> well, tries to avoid lazymap as much as possible

[16:30] <pmichaud> whereas PGE has done it by inlining the code

[16:31] <pmichaud> for example,  PGE actually builds an inlined loop for handling the star quantifier, and runs that loop relatively lazily

[16:31] <TimToady> which is more or less what all the "r" variants do under ratcheting

[16:31] <pmichaud> recognizing that Cursor.pmc is really using lazymap as a form of continuation handling

[16:31] <pmichaud> do you have a gut feeling for whether PGE should move more towards the way that Cursor is handling things, or stick with the "generate a block of inlined code"?

[16:32] <pmichaud> PGE has gone with the inlined code approach because subroutine calls in parrot tend to be a bit expensive, so it's betting that the inlined code approach is more efficient.

[16:32] <pmichaud> That could be entirely wrong, though.

[16:32] <TimToady> well, in theory the VM should do that for you :)

[16:33] <pmichaud> should be inlining the code?  heh

[16:33] <pmichaud> that's a nice theory.

[16:33] <TimToady> not just theory anymore for JS

[16:33] <TimToady> with tracing

[16:34] <TimToady> anyway, while I've put some effort into inlining some stuff in the generated STD.pmc code, that could be construed (eventually) as a microoptimizaiton

[16:35] * diakopter interjects: mepostulates the non-inlined approach would be more favorable for LTM, since more state can be cached, per arguments-set

[16:35] <TimToady> in a memoization sense, you mean?

[16:36] <diakopter> that was my [probably dead wrong] thought, yeah

[16:36] <TimToady> well, Cursor does memoize a number of things explicilty

[16:36] * TimToady has tagnly figners toady

[16:38] <TimToady> anyway, most of the overhead of STD matching doesn't seem to be in the quantifiers

[16:38] *** crythias left
[16:38] <pmichaud> oh

[16:38] <pmichaud> where is the overhead?

[16:38] <pmichaud> in the alternations?

[16:38] <TimToady> sec, ran NYTProf just yesterday...

[16:39] <pmichaud> the other advantage/reason for the mechanism that PGE currently uses is that it holds down GC pressure by not creating lots of gc-able objects

[16:39] <pmichaud> since object creation and collection is a bit expensive for parrot also

[16:40] <pmichaud> anyway, after looking at things over the past couple of weeks, I've come to a few conclusions (more)

[16:40] <pmichaud> 1. I'm basically rewriting PGE from the ground up to be able to better handle protoregexes.  It might even get a new name :)

[16:40] <pmichaud> 2. I have three basic approaches for the code that PGE generates

[16:41] <pmichaud> 2a.  Continue to generate inlined code, as PGE has done before.  Has the advantage that I already have existing code to draw from and we know it works somewhat okay, disadvantage might be that it's less portable to non-Parrot platforms (but I suspect that could be fixed as well)

[16:42] <pmichaud> 2b. Use something much closer to Cursor,pmc, which basically uses closures and lazymap to handle backtracking

[16:42] <diakopter> (2b similar to my grammar-interpreter as parser-generator)

[16:43] <pmichaud> 2c. Do something halfway between the two -- inline the code but use continuations to handle the loops and other constructs

[16:43] <diakopter> (2c even more similar to... )

[16:44] <pmichaud> (currently PGE uses simple stacks to handle "lightweight continuations"

[16:44] <[particle]> i suspect 2a is easiest to debug in current parrot

[16:44] <pmichaud> actually, they may be about equal

[16:44] <pmichaud> oh, another observation:  it looks very likely that I'll be able to write much or most of this in NQP 

[16:45] <pmichaud> which might have some big wins for portability

[16:45] <TimToady> you can seen at least the top index.html at wall.org/~larry/nytprof

[16:45] <[particle]> i mean to say, debug *and profile*

[16:45] <TimToady> but I didn't copy over all the subfiles because some of them are huge

[16:46] <pmichaud> [particle]: actually, I'd expect 2b to be easier to profile -- more subroutine entry/exit points

[16:46] <pmichaud> 2a makes a regex into a single subroutine

[16:46] <[particle]> hrmm, true

[16:46] <TimToady> taking GC pressure into account is also potentially considered a microoptimization with good generational GC

[16:46] <[particle]> i was thinking that we can't really profile yields well yet

[16:47] <[particle]> but it would be easier than One Big Sub

[16:47] *** stephenlb joined
[16:47] <pmichaud> [particle]: oh, with 2b/2c we probably don't have yields

[16:48] *** __ash__ left
[16:48] <pmichaud> i.e., the "coroutines" are actually managed as list of cursors and closures

[16:48] <pmichaud> *lists

[16:48] <[particle]> well, it seems to me that 2c can be more easily accomplished today, since you already have the inlining code ready, and that you can move from 2c to 2b

[16:49] <[particle]> so perhaps 2c is the practical way to go

[16:49] <pmichaud> at the moment they all seem equal-effort

[16:49] <PerlJam>  /me votes for 2c since you can vary the components of the mix from  0 to 100%

[16:49] *** iblechbot joined
[16:49] <pmichaud> true

[16:49] <PerlJam> what [particle] said about practicality

[16:50] <pmichaud> TimToady:  nytprof seems to put a fair bit of time in SUBSUMEr

[16:50] <TimToady> the main thing is you have to be very clear about what is mutable/immutable and never use continuations for anything mutable

[16:51] <pmichaud> copying a capture set into multiple cursors seems like it could get expensive (more)

[16:51] <pmichaud> PGE also avoids that, but at the cost of making its cursors mutable, which I agree isn't really desirable

[16:51] <TimToady> thing is, when you're ratcheting you can cheat with a mutable cursor

[16:52] <TimToady> which is a lot of the time

[16:52] <pmichaud> well, it's a lot of the time in STD :)

[16:52] <pmichaud> and in parsers

[16:52] <pmichaud> but not necessarily regexes :)

[16:52] <TimToady> nod

[16:52] <pmichaud> and not necessarily other grammars

[16:52] <pmichaud> *hll grammars

[16:52] <pmichaud> still, the point is a goodone

[16:53] *** explorer left
[16:53] <pmichaud> does STD currently cheat with mutable cursors in ratcheting?

[16:54] <pmichaud> if so, I wouldn't expect SUBSUMEr to be quite so high.  Or I'd be concerned about the time cost of SUBSUME without-the-r  :)

[16:54] <pmichaud> I have to go pick up kid from school (early release today)

[16:54] <TimToady> SUBSUMEr still makes a fresh cursor

[16:55] <pmichaud> okay, that's what I thought it did

[16:55] <pmichaud> I'll be back in an hour-ish

[16:55] <pmichaud> I'll backlog for other comments and thoughts -- thanks, this is all hugely helpful

[16:57] *** __ash__ joined
[17:09] *** MrRandom joined
[17:11] <MrRandom> Hello, Which implementation of Perl 6 will be official one?

[17:11] <TimToady> All of them

[17:11] <TimToady> they're not Perl 6 if they don't pass the test suite

[17:11] <pugs_svn> r28386 | diakopter++ | [vijs] implement leading if conditional -  if 1 { say 3 } 

[17:12] <diakopter> vijs: if 0 { say 3 }; if True { say True ~ ' and ' ~ True }

[17:12] <p6eval> vijs 28379: OUTPUT«1 and 1␤»

[17:12] <diakopter> std: if 0 { say 3 } if True { say True ~ ' and ' ~ True }

[17:12] <p6eval> std 28379: OUTPUT«===SORRY!===␤Missing semicolon or comma after block at /tmp/0GySzft0I0 line 1:␤------> if 0 { say 3 } ⏏if True { say True ~ ' and ' ~ True }␤    expecting any of:␤       infix stopper␤    statement␤Undeclared routine:␤      if used at line

[17:12] <p6eval> ..1␤FAILED 00:01 95m␤»

[17:13] * diakopter waits

[17:13] <diakopter> lots o backtracking methinks

[17:13] <MrRandom> Ok, so which implementation is 'the best' ? Which is worth of involve in?

[17:13] <diakopter> MrRandom: whichever one's host language[s] you enjoy writing the most?

[17:14] <TimToady> there are many different dimensions to be 'best' in

[17:14] <diakopter> or whichever one's code repository software you enjoy using the most

[17:14] *** ejs1 joined
[17:14] <diakopter> :)

[17:15] <MrRandom> diakopter: c# 

[17:15] <diakopter> well, it's just you and I in that camp, and perhaps jnthn on a good day

[17:17] *** ejs1 left
[17:17] *** cmv joined
[17:18] *** abra left
[17:21] <TimToady> diakopter: what does "lots o backtracking" refer to?

[17:21] <diakopter> failing on the std: input seemed very much slower than succeeding on the prior input

[17:22] <diakopter> maybe just p6eval host busyness

[17:22] *** ejs2 left
[17:22] *** MrRandom left
[17:23] <TimToady> time appears to be identical here, modulo my CPU ticker

[17:24] <diakopter> ok

[17:24] <diakopter> sry for the noise

[17:24] <TimToady> well, but it's an interesting question

[17:24] <TimToady> fact is that the error can fail as soon as sees the second {

[17:25] <diakopter> if 0 { say 3 } if else { say True ~ ' and ' ~ True }

[17:25] <TimToady> so in theory it could be quite a bit faster to fail, if there's lots more

[17:25] <diakopter> std: if 0 { say 3 } if else { say True ~ ' and ' ~ True }

[17:25] <p6eval> std 28379: OUTPUT«===SORRY!===␤Missing semicolon or comma after block at /tmp/1eu9H1sm9r line 1:␤------> if 0 { say 3 } ⏏if else { say True ~ ' and ' ~ True }␤    expecting any of:␤       infix stopper␤    statement␤Undeclared routines:␤     else used at line 1␤

[17:25] <p6eval> ..     if used at li…

[17:25] <diakopter> std: if 0 { say 3 } if XXX

[17:25] <p6eval> std 28379: OUTPUT«===SORRY!===␤Missing semicolon or comma after block at /tmp/wHZN9tSPB0 line 1:␤------> if 0 { say 3 } ⏏if XXX␤    expecting any of:␤      infix stopper␤    statement␤Undeclared name:␤ XXX used at line 1␤Undeclared routine:␤     if used at line

[17:25] <p6eval> ..1␤FAILED 00:0…

[17:25] <diakopter> std: if 0 { say 3 } if {

[17:25] <p6eval> std 28379: OUTPUT«===SORRY!===␤Missing semicolon or comma after block at /tmp/2109IVn99E line 1:␤------> if 0 { say 3 } ⏏if {␤    expecting any of:␤        infix stopper␤    statement␤FAILED 00:02 95m␤»

[17:25] <TimToady> might actually catch it sooner

[17:26] <TimToady> but it might be transmogrifying a later error into the actual error

[17:26] <TimToady> don't remember

[17:26] <diakopter> it's thinking fourth dimensionally

[17:27] <TimToady> actually, it's just an extra check at the end of a statement to see if there's trailing trash

[17:28] <TimToady> which it might or might not have got to by backtracking

[17:39] <pmichaud> hmmm, I wonder if I could speed up cursor generation by making the captures COW

[17:40] <TimToady> pmichaud: you can look at all the nytprof data now, if you don't mind slow uploading over DSL

[17:40] <TimToady> maybe, but the position changes constantly, so probably not much gain

[17:41] <TimToady> for the spots where only the position changes, I use cursor_tweak to mutate the position in the current cursor (when I think I can get away with it)

[17:41] <pmichaud> right

[17:41] <pmichaud> I don't mind creating multiple cursors, it's cloning the existing capture set that looks expensive to me

[17:41] <TimToady> on the nytprof stuff, don't try going into STD.pm because nytprof doesn't know about STD.pmc

[17:42] <pmichaud> (granted it's a shallow clone)

[17:43] <TimToady> if there are long stretches with the same non-pos data, that could be broken out and referenced by a [pos,immutableptr] pair

[17:43] <pmichaud> right

[17:43] <TimToady> you still have to clone for submatches though

[17:43] <pmichaud> that's kinda where I've been heading

[17:44] <TimToady> or go back to an approach I tried once before I knew what I was doing, and keep all the bindings as a linked list

[17:44] <pmichaud> ick

[17:44] <pmichaud> not going there :)

[17:44] <TimToady> but then the clone only carries a linked list pointer

[17:45] <pmichaud> interesting

[17:45] <TimToady> but yeah, Cursor currently depends on the hashness of itself to make it also a proto Match

[17:45] *** hercynium left
[17:45] *** araujo joined
[17:46] <TimToady> the problem with linked list is that you have to be able to manufacture a Match-ish object any time the user wants $<foo>

[17:46] <pmichaud> well, here's the sort of thing I'm looking at

[17:46] <pmichaud>     / [ <foo>+  <bar> ]   [ abc ]* /

[17:46] <pmichaud> ooops

[17:46] <pmichaud>     / [ <foo>+  <bar> ]*   [ abc ]* /

[17:47] <pmichaud> anyway, we get through the first part and end up with some cursors that have $<foo> and $<bar> in them

[17:47] <TimToady> which are already arrays because the outer rule set them up that way

[17:48] <pmichaud> but in the [ abc ]* part (which could be more complex, of course), we end up making clones of the hash containing $<foo> and $<bar>, even though they remain identical

[17:48] <pmichaud> seems to me that all of the cursors created for the latter part could share the same hash

[17:48] <pmichaud> and that they're copy-on-write, so that if something later needs to modify a cursor, we clone it then

[17:51] <araujo> hello

[17:51] <pmichaud> anyway, looks like that would work for me, and it's likely to be even more efficient than what PGE is currently doing

[17:51] *** __ash__ left
[17:52] <pmichaud> I did have a spec question, however

[17:52] <pmichaud> given a regex like

[17:53] <pmichaud>     / foo [ bar || <xyz>+ ] /

[17:53] <pmichaud> are we guaranteed that the resulting match object will have an Array in $<xyz> ?  Or does the Array exist only if the <xyz>+ part was matched?

[17:53] <pmichaud> i.e., if we matched the 'bar' part, is $<xyz> undef ?

[17:53] <pmichaud> (or non-existent)

[17:53] <TimToady> most of the clones are just copying pointers to bindings anyway

[17:54] <TimToady> it's probably the keys that are expensive

[17:54] <pmichaud> in PGE's case, it's likely to be the creation of the extra one-per-cursor hashes

[17:55] <pmichaud> and yes, shallow cloning hashes in Parrot isn't cheap at the moment either :-|

[17:55] <pmichaud> (it's cheaper than deep cloning, obviously, but there's not a built-in mechanism to do it)

[17:56] <pmichaud> in my regex question above, I think that $<xyz> doesn't exist if we matched the 'bar' part

[17:57] <TimToady> I believe STD inits the array anyway, checking

[17:57] <pmichaud> well, the example that proves the case is

[17:57] <pmichaud>    / foo [ bar <xyz> || <xyz>+ ] /

[17:57] <pmichaud> if we match the bar part, then $<xyz> isn't an array

[17:59] <TimToady> STD will make it an array anyway

[17:59] <pmichaud> what's the correct spec?

[18:01] <TimToady> I think STD's behavior is defensible, insofar as [...] doesn't submatch, and forces branches to share

[18:01] <pmichaud> I think that doesn't match S05, though

[18:01] <pmichaud> checking

[18:01] <TimToady> and STD is speck too :P

[18:01] <diakopter> speckled

[18:04] <lisppaste3> TimToady pasted "translation of pm's first regex" at http://paste.lisp.org/display/87565

[18:04] <pmichaud> S05:2970

[18:05] <pmichaud> and S05:3022

[18:05] <pmichaud> how does STD translate   / foo [ bar <xyz> | baz <xyz> ] /   ooc?

[18:06] <TimToady> but S05:3039

[18:06] <pmichaud> 3039 shows the case where there's a repeated subrule outside of the brackets

[18:07] <pmichaud> i.e., I agree that  /  foo [ bar <xyz> | baz ] <xyz> /    always ends up with $<xyz> being an array

[18:07] <pmichaud> because there's a scope alternation where it's repeated more than once

[18:07] *** donaldh left
[18:07] <TimToady> missing quant?

[18:07] <pmichaud> no

[18:08] <TimToady> I don't think that one ends up with an array

[18:08] *** donaldh joined
[18:08] <pmichaud> that's what S05:3039 is saying, though

[18:08] <pmichaud> the example from S05:3039 is

[18:08] <pmichaud>     / <file> ':' [ <file> | none ] /

[18:08] <pmichaud> and it says that $<file> is an array

[18:08] <TimToady> checking...

[18:08] <pmichaud> because there are two <file>'s in the same scope

[18:09] <pmichaud> but that's different from

[18:09] <pmichaud>    / foo [ <file> | none ] /

[18:09] <pmichaud> because there's only one $<file> in the scope

[18:09] <pmichaud> same with

[18:09] <TimToady> gimme5 would run about 5 times faster without unicode...

[18:09] <pmichaud>    / foo [ abc <file> | def <file> ] /

[18:09] <pmichaud> each alternation ends up with only one $<file>, so no array

[18:11] <TimToady> the latter STD doesn't make an array

[18:14] <TimToady> and / foo <xyz> [ bar <xyz> | baz ] / does make an array, so I think STD is sane

[18:14] <pmichaud> okay

[18:14] <TimToady> well, it's gimme5 doing it

[18:14] <pmichaud> so then what about

[18:14] <pmichaud>    / foo [ bar <xyz>+ | baz ] /

[18:14] <TimToady> it will certainly be an array

[18:14] <pugs_svn> r28387 | diakopter++ | [vijs] flesh out statement_control__S_if;  implement elsif (multiple, too), else blocks 

[18:14] <TimToady> even if you match baz

[18:14] <pmichaud> and then

[18:15] <pmichaud>    / foo [ bar <xyz>+ | baz <xyz> ] /  

[18:15] <pmichaud> ?

[18:15] <TimToady> it will still certainly be an array, I think

[18:15] <diakopter> vijs: if 0 { say 3 } elsif 0 { say 4 } elsif 0 { say 6 } else { say 5 }

[18:15] <p6eval> vijs 28379: OUTPUT«5␤»

[18:15] <pmichaud> okay, so the quantifiers can reach across alternations?

[18:15] <diakopter> vijs: if 0 { say 3 } elsif 0 { say 4 } elsif 1 { say 6 } else { say 5 }

[18:15] <p6eval> vijs 28379: OUTPUT«6␤»

[18:15] <TimToady> inside [], yes, but maybe not inside ()

[18:15] <TimToady> checking

[18:15] <pmichaud> right

[18:15] <diakopter> vijs: if 0 { say 3 } elsif 1 { say 4 } elsif 0 { say 6 } else { say 5 }

[18:15] <p6eval> vijs 28379: OUTPUT«4␤»

[18:16] <pmichaud> oh wait

[18:16] <pmichaud> it I would think it would need to be that way inside () also

[18:16] <diakopter> whee

[18:16] <pmichaud> because of

[18:16] <TimToady> mebbe

[18:16] <pmichaud>    / bar <xyz>+ | baz <xyz> /

[18:16] <pmichaud> does that force $<xyz> to be an array?

[18:17] <pmichaud> okay, I get it

[18:17] <pmichaud> "lexical scope" doesn't include alternations (more)

[18:18] <pmichaud> from S05

[18:18] <pmichaud> "If a subrule appears two (or more) times in any branch of a lexical

[18:18] <pmichaud> scope (i.e. twice within the same subpattern and alternation), or if the

[18:18] <pmichaud> subrule is quantified anywhere within a given scope,

[18:18] <pmichaud> ...

[18:18] *** rjh left
[18:18] <pmichaud> so, it's the appearance twice within a branch of a lexical scope

[18:18] *** lmc joined
[18:18] <pmichaud> or quantified anywhere in the scope

[18:18] <pmichaud> where   brackets and parens define the "scope"

[18:18] <pmichaud> I had been interpreting it that alternations defined a scope

[18:19] <pmichaud> so

[18:19] <pmichaud>     / foo [ bar | <xyz>+ ] /   always ends up with an $<xyz> empty array

[18:20] <pmichaud> sorry, only parens define lexical scopes

[18:20] <pmichaud> similarly,  / foo [ bar <xyz> | <xyz>+ ] /   ends up with $<xyz> as being an array, because it's quantified within the scope

[18:20] <pmichaud> even though it's not quantified in the bar branch

[18:21] *** rjh joined
[18:22] <TimToady> currently / bar <xyz>+ | baz <xyz> / appears to always make an array

[18:22] <pmichaud> I'm fine with that, based on my new understanding

[18:22] *** SmokeMachine left
[18:22] *** donaldh left
[18:22] <pmichaud> instead of "lexical scope" perhaps we should say "capturing scope" ?

[18:22] <pmichaud> where parens define a new capturing scope?

[18:23] <pmichaud> "lexical scope" seems to me like it ought to be defined with curlies.

[18:23] <buu> ingy: Hey, you around?

[18:23] <TimToady> well, it's a matter of whether there's a sub-Match object

[18:23] <pmichaud> right

[18:23] <pmichaud> wait

[18:23] <pmichaud> what do you mean by "sub-Match object"?

[18:23] <TimToady> I mean the Match inside () is different than the Match outside it

[18:23] <pmichaud> right

[18:24] <pmichaud> because () creates a new capturing scope

[18:24] <TimToady> with [] they share

[18:24] <pmichaud> [] doesn't create a new capturing scope, it's in the same capturing scope

[18:24] *** NorwayGeek joined
[18:24] <pmichaud> that's the current meaning of () and [], but S05 uses the phrase "lexical scope" for that

[18:24] *** NorwayGeek left
[18:25] <pmichaud> I'm wondering if "capturing scope" is more descriptive... especially since we now have the ability to define lexicals in regexes

[18:25] <pmichaud> er, lexical variables

[18:25] *** NorwayGeek joined
[18:25] <sjohnson> rakudo: say [1, 2, 3].WHAT

[18:25] <p6eval> rakudo 0eaf62: OUTPUT«Array()␤»

[18:25] *** lucs left
[18:26] <TimToady> well, but () is a lexical scope of sorts, since :i and such are lexically scoped

[18:26] <TimToady> but then so is [] that way

[18:26] <pmichaud> that's a "modifier scope"  :)

[18:26] <TimToady> so yeah, capture scope or some such

[18:26] <sjohnson> is [] a reference like in p5?

[18:26] <sjohnson> anonymous etc

[18:26] <pmichaud> sjohnson: we don't really have references in p

[18:26] <pmichaud> p6

[18:26] <TimToady> not inside regexen :)

[18:26] <TimToady> we try hard to hide all the references

[18:26] <sjohnson> what is the difference in p6 with [] () ?  both array contexts?

[18:27] <TimToady> [] has a list context inside, () is a Parcel that doesn't know yet

[18:27] *** donaldh joined
[18:27] <pmichaud> sjohnson: [] creates an array, () is just a grouper.  (1,2,3)  becomes a Parcel

[18:28] <pmichaud> (it's the comma that creates the Parcel, not the parens)

[18:28] <pmichaud> TimToady: okay, thanks for the spec clarification

[18:28] <pmichaud> PGE currently follows my (incorrect) interpretation of scopes; I'll update it in the new version

[18:29] <pmichaud> I like this way of thinking of it much better.

[18:29] <TimToady> (1) is a degenerate Parcel

[18:29] <diakopter> we don't serve their kind here

[18:30] <TimToady> std: 2<3<4

[18:30] <p6eval> std 28379: OUTPUT«===SORRY!===␤(Possible runaway string from line 1 to line 2)␤Whitespace required before < operator at /tmp/rL9admwpbs line 1:␤------> 2<⏏3<4␤    expecting escape␤FAILED 00:01 95m␤»

[18:30] <TimToady> diakopter: yeah, like that

[18:33] <diakopter> std: <3 Perl>>0

[18:33] <p6eval> std 28379: OUTPUT«ok 00:03 95m␤»

[18:34] <TimToady> it probably just appended that to your 0 file :)

[18:34] <pmichaud> TimToady: S08 currently says that the comma creates the parcels, not the parens

[18:34] <sjohnson> p6eval lost its cute plus sign 

[18:34] <TimToady> (1) is a virutal parcel, quickly anihilated

[18:34] <pmichaud> okay

[18:34] <TimToady> *virtual

[18:34] <pmichaud> I'm fine with that

[18:34] *** diakopter sets mode: +v p6eval

[18:35] <pmichaud> my $x = 1;   say $x.WHAT  # Int

[18:35] *** donaldh left
[18:35] <pmichaud> my $x = (1);   say $x.WHAT  # Int

[18:35] *** diakopter sets mode: +v lambdabot

[18:35] <pmichaud> my $x = (1,2);   say $x.WHAT  # Parcel ?

[18:37] <TimToady> probably not

[18:37] <TimToady> (1,@x) as a Parcel has 2 elements

[18:37] *** donaldh joined
[18:37] <TimToady> but = will evaluate the @x

[18:37] <TimToady> I suspect

[18:38] *** leedo_ left
[18:38] <pmichaud> oh, so then it becomes a List ?

[18:38] *** leedo joined
[18:38] <TimToady> seems likely

[18:38] <pmichaud> I think that works for me

[18:39] <pmichaud> would it flatten in the case of

[18:39] <pmichaud> my $x = (1, (2, 3));   

[18:39] <TimToady> and \(1,@x) would maybe keep it a Parcel

[18:39] <TimToady> yes, I think it would flatten that even when assigned to $x

[18:39] <pmichaud> okay

[18:39] <pmichaud> S08 needs some updating there, then.

[18:40] <TimToady> I suppose I should read it one of these months...

[18:40] <pmichaud> well, I think it was just added yesterday :)

[18:41] <[particle]> are the specs still read-once? someone should unset that bit.

[18:41] <TimToady> course I could change my mind about it tomorrow too

[18:41] <TimToady> read once but write-many

[18:41] <diakopter> WMRO

[18:42] <pmichaud> README is  write many, read never

[18:42] * TimToady is checking to see if his avocado is operative

[18:43] <diakopter> someone the other day made the mistake of saying the specs are specifications. I quickly corrected them of that nonsense; they're speculations.

[18:43] <pmichaud> amen

[18:44] *** icwiener left
[18:44] <pmichaud> okay, time to do some more branestorming

[18:44] <diakopter> I think that someone might have been myself :)

[18:45] *** crythias joined
[18:45] *** donaldh left
[18:45] *** donaldh joined
[18:46] <pmichaud> TimToady: how are you producing the regex translations as in the nopastes?  Is there a convenient command line tool for it?

[18:46] <TimToady> well, maybe they're SF, Specificational Fiction

[18:47] *** donaldh left
[18:47] <TimToady> I was editing a rule into STD and running gimme5 on it, but one could probably just do that with a separate grammar, now that I think of it

[18:47] *** donaldh joined
[18:48] * pmichaud attempts

[18:50] <TimToady> in fact, you can run gimme5 - and type a rule on the stdin

[18:50] *** mberends joined
[18:50] * diakopter adds gimme5 to p6eval ;)

[18:50] <moritz_> NOE

[18:51] <diakopter> gimme5: prepare to be flood-kicked

[18:52] <TimToady> some of my jokes are almost funny too

[18:53] * diakopter permutes emphases on different words of that last

[18:53] <crythias> So, a nun, a priest, and a rabbi walk into a bar. The bartender says, "What is this, some kind of joke?"

[18:54] <diakopter> std: jokefail or fakefail

[18:54] <p6eval> std 28379: OUTPUT«Undeclared routines:␤  fakefail used at line 1␤  jokefail used at line 1␤  or used at line 1␤ok 00:01 95m␤»

[18:56] *** justatheory is now known as RhodiumTode

[18:57] <pmichaud> ah yes, gimme5 is helpful

[18:57] <pmichaud> TimToady++

[18:57] *** RhodiumTode is now known as justatheory

[18:57] *** buubot left
[18:57] <diakopter> std: my && 3

[18:57] <p6eval> std 28379: OUTPUT«ok 00:02 125m␤»

[18:58] <pmichaud> afk for a bit

[18:58] <diakopter> std, wait, what?

[18:59] *** buubot joined
[18:59] <diakopter> buggo

[18:59] *** molaf joined
[19:00] <crythias> std: class jokefail { has $.value;}; class fakefail { has $.value };  jokefail.value=1; fakefail.value=2; say jokefail.value or fakefail.value;

[19:00] <p6eval> std 28379: OUTPUT«ok 00:01 96m␤»

[19:01] <diakopter> std: my & &3

[19:01] <p6eval> std 28379: OUTPUT«ok 00:03 124m␤»

[19:01] <diakopter> soar confused

[19:02] *** SmokeMachine joined
[19:02] *** cmv left
[19:02] *** buubot left
[19:03] <diakopter> rakudo: my & &3

[19:03] <p6eval> rakudo 0eaf62: OUTPUT«Malformed declaration at line 2, near "& &3"␤in Main (src/gen_setting.pm:3469)␤»

[19:03] *** buubot joined
[19:04] <diakopter> buubot: help

[19:05] <diakopter> TimToady: std: my & &3 # what does this mean

[19:06] <TimToady> you're &-ing an anonymous & variable with &3

[19:06] <TimToady> er, with 3

[19:06] <pmichaud> (my &) & 3

[19:06] <moritz_> std: my $x + 3

[19:06] <p6eval> std 28379: OUTPUT«ok 00:02 96m␤»

[19:06] <moritz_> std: my $ + 3

[19:06] <p6eval> std 28379: OUTPUT«ok 00:02 96m␤»

[19:07] <pmichaud> std:  my $dog does Bite

[19:07] <p6eval> std 28379: OUTPUT«ok 00:01 96m␤»

[19:07] <buubot> diakopter: Provides help text for a specific command. Try 'help echo'. See also the command 'plugins' to list all of the currently loaded plugins.     

[19:07] <diakopter> buubot: i c.

[19:07] <buubot> diakopter: i am me     

[19:07] <crythias> perl6: my $milkshake="Brings all the boys to they yard."; say $milkshake;

[19:07] <p6eval> elf 28387, pugs, rakudo 0eaf62: OUTPUT«Brings all the boys to they yard.␤»

[19:08] <pmichaud> std:  my $ does Inflate

[19:08] <p6eval> std 28379: OUTPUT«ok 00:02 96m␤»

[19:08] * diakopter apparently needs to discover anonymous variables somewhere in the specificulations

[19:09] <TimToady> taquitos and guac and sour cream and Mega Death Sauce, yum

[19:09] <crythias> perl6: my $TimToady="taquitos and guac and sour cream and Mega Death Sauce, yum"; say $TimToady;

[19:09] <p6eval> elf 28387, pugs, rakudo 0eaf62: OUTPUT«taquitos and guac and sour cream and Mega Death Sauce, yum␤»

[19:10] <crythias> hey. this is neat. it's almost like LOGO.

[19:11] <diakopter> std: my & && my $ && my %

[19:11] <p6eval> std 28379: OUTPUT«ok 00:06 124m␤»

[19:12] <TimToady> diakopter: S02:1881

[19:13] <diakopter> std: my &&&&3

[19:13] <p6eval> std 28379: OUTPUT«ok 00:02 125m␤»

[19:13] *** cmv joined
[19:13] <TimToady> Dear Historian: we apologize for using line numbers, but it's easier for us, and you can always look up the current SVN copy.

[19:13] <PerlJam>  someone should turn std into something that can deparse.

[19:14] <TimToady> hmm, viv can do that already

[19:14] <diakopter> theoretically the irclog cgi could derive the updated line numbers with some creative subversioning

[19:14] <TimToady> but it won't add extra parens for you

[19:15] <PerlJam> adding spaces would help even  :)

[19:16] <TimToady> viv tries very hard to preserve whitespace exactly as it was currently

[19:17] <TimToady> (as a round-tripping test)

[19:18] <PerlJam> I guess parens would be needed to aid in figuring out what expressions like  (* + * ** * - * * *).(2)  really mean

[19:18] <diakopter>  --desugar_level=3325

[19:19] <TimToady> funny how the Mega Death at 550k scovilles doesn't seem any hotter than Sudden Death at 105k--maybe I'm saturating the guages

[19:29] <pmichaud> ...does the "Mega" take longer than the "Sudden", I wonder?

[19:29] <pugs_svn> r28388 | diakopter++ | [vijs] implement Tight_and 

[19:29] <diakopter> vijs: say 1 && 3

[19:29] <p6eval> vijs 28379: OUTPUT«3␤»

[19:30] <diakopter> vijs: say (say 0) && (say 2)

[19:30] <p6eval> vijs 28379: OUTPUT«0␤2␤1␤»

[19:31] <PerlJam> vijs is 6 on javascript?

[19:31] <diakopter> STD-ridden JS, even plusser

[19:32] <PerlJam> cool

[19:32] <diakopter> 6ON, the Perl 6 you apply directly to your 6.

[19:33] <PerlJam> heh

[19:33] <PerlJam> diakopter: do you have an accompanying commercial with people slapping "Perl 6" stickers on every 6 they see?

[19:34] <diakopter> no, but that would rocketh

[19:34] <TimToady> just put camelia stickers everywhere

[19:34] <pmichaud> one could do something along the "All your base..." video :)

[19:35] *** donaldh left
[19:35] *** donaldh joined
[19:36] *** donaldh left
[19:37] <diakopter> PerlJam: tho there's Perlito, too, Perl 6 subset that actually emits JS, bootstrapping nearly

[19:37] *** donaldh joined
[19:37] <diakopter> from flavio_glock

[19:37] <diakopter> derivative/successor to mp6

[19:40] * diakopter looks online for Camelia stickers

[19:41] <pmurias> diakopter: perlito is an mp6 backend

[19:42] <sjohnson> it might help battle the ignorance of people thinking that Perl is a programming language that died 15 years ago

[19:42] <sjohnson> i hate talking to such people

[19:42] <sjohnson> i think Matt-W knows a few

[19:45] <PerlJam> sjohnson: I tend to just laugh at those people

[19:47] <sjohnson> they must really bet out of touch to think that, since most programs that support scripts use Perl or Python

[19:48] <pugs_svn> r28389 | diakopter++ | [vijs] implement Tight_or (and alias Loose_and to Tight_and) 

[19:53] <PerlJam> sjohnson: just myopic.  The web is the biggest new platform in the last 15 years.  If you're not dominating the most recent platform, you're dying or dead.

[19:55] <Matt-W> yes I do know some people like that

[19:55] <Matt-W> Most of them work with me :(

[19:56] <diakopter> "ooo Perl; it's so dead it's *ghostly*"

[19:58] *** ruoso left
[20:00] <TimToady> phone

[20:00] <TimToady> ☎

[20:02] <sjohnson> unicode has everything!

[20:02] <Matt-W> It's a little phone!

[20:02] <Matt-W> So cute

[20:02] <sjohnson> ✈

[20:03] *** ruoso joined
[20:04] <Patterner> It's a little starship!

[20:04] <Patterner> Not so cute

[20:06] <sjohnson> its.. a plane1

[20:06] <sjohnson> there should be a monthly challenge to find the cutest unicode character

[20:06] <pugs_svn> r28390 | diakopter++ | [vijs] implement Loose_or (as alias to Tight_or); yes, it treats all infix operators at those precedences as ||; the others will be implmented as well. 

[20:08] *** pmurias left
[20:09] <sjohnson> typo in 'implemented'

[20:09] <Patterner> is there a piglet unicode character?

[20:09] <diakopter> *implemented # sjohnson++

[20:11] <TimToady> actually, ✈ is plane 0

[20:11] <sjohnson> haha

[20:11] <sjohnson> excalamation mark fail on me

[20:11] <sjohnson> im sure you knew that tho

[20:11] <sjohnson> timtoady wit++

[20:12] <TimToady> @karma wit

[20:12] <lambdabot> wit has a karma of 1

[20:12] <crythias> My sister is a binary pest. I told her to stop Boolean me.

[20:13] <sjohnson> crythias: http://members.shaw.ca/smujohnson/snd/garlaff.mp3

[20:14] *** am0c joined
[20:17] <ingy> buu: hi

[20:23] *** chturne left
[20:24] *** NorwayGeek is now known as NorwayGeek|Away

[20:33] <jrtayloriv> crythias, Tell her she octal leave you alone.

[20:33] <diakopter> or else you'll put a hexa her

[20:36] <diakopter> bah-dum-ching.

[20:36] <crythias> ha ha ha 

[20:37] *** quietfanatic joined
[20:37] <crythias> There is no spoon. Unless you declare it first.

[20:39] <diakopter> Name it && claim it, I always say.

[20:39] <quietfanatic> rakudo: class Y {has $.z}; subset X of Y where {.z == 0}; my $q = 4; say $q ~~ X;

[20:39] <p6eval> rakudo 0eaf62: OUTPUT«Method 'z' not found for invocant of class 'Int'␤»

[20:40] <quietfanatic> It checks the where {} before checking that it's a Y.

[20:40] <quietfanatic> Bug?

[20:41] <moritz_> IMHO yes

[20:42] <moritz_> please submit

[20:42] <TimToady> should probably catch exceptions in a where

[20:43] <quietfanatic> How duz I submitted bug?

[20:43] <moritz_> but in this case the where-block shouldn't even be run, no?

[20:43] <moritz_> quietfanatic: mailto:rakudobug@perl.org

[20:45] <TimToady> moritz_: ja, you'd think.

[20:47] <TimToady> but maybe they're thinking of things like 2 ~~ subset * of Num where 1..4

[20:47] *** molaf left
[20:47] <quietfanatic> Any special things I should put in the message?

[20:48] <TimToady> usually just a paste of appropriate lines of IRC will do

[20:48] <quietfanatic> TimToady: Surely that'd be easier written as 2 ~~ Num & {1..4}

[20:48] <quietfanatic> or Num & 1..4

[20:49] <pmichaud> since it's effectively implemented using junctions, it's not short-circuiting on the junction yet

[20:49] *** explorer joined
[20:49] <pmichaud> i.e., it's testing both Y and where, but carping about the where

[20:50] <moritz_> pmichaud: IMHO it should use the "also" junction, which is an all() but with a defined order

[20:50] <pmichaud> moritz_: agreed, "also" is nyi

[20:50] <moritz_> and short-circuits

[20:50] <moritz_> I know

[20:50] <pmichaud> I'm just 'splaining

[20:51] <TimToady> in any case, a where that throws an exception should probably be treated as false, if try isn't too big an overhead

[20:51] <moritz_> ok :-)

[20:51] <pmichaud> I don't think try will be too big an overhead

[20:51] <pmichaud> we can certainly try it and see :)

[20:51] <TimToady> though the ~~ Y test should generally be faster anyway

[20:51] <TimToady> which argues for putting it first in any case

[20:53] <TimToady> though it could be argued on logical grounds that where { @pigs.fly } should make implication true

[20:55] *** ruoso left
[20:56] *** BooK left
[20:56] *** BooK joined
[20:58] *** crythias left
[21:02] *** hercynium joined
[21:29] *** cmv left
[21:32] *** nihiliad left
[21:32] *** nihiliad joined
[21:38] *** crythias joined
[21:41] *** KyleHa left
[21:42] *** tak11 joined
[22:10] *** lmc left
[22:19] *** [particle] left
[22:37] *** SmokeMachine left
[22:38] *** c1sung left
[22:39] *** meppl left
[22:59] *** iblechbot left
[23:05] *** am0c left
[23:06] *** am0c joined
[23:21] *** rhr_ joined
[23:31] *** astinus_ joined
[23:35] *** rhr left
[23:37] *** buubot left
[23:38] *** buubot joined
[23:38] *** buubot left
[23:39] *** buubot joined
[23:47] *** badanov joined
[23:47] <badanov> Hi

[23:47] <badanov> * taptaptap* Is this thing on?

[23:51] <Juerd> It is!

[23:54] *** guest1235123 joined
[23:55] <badanov> Okay then

[23:55] <badanov> dunno if I can help, but I guess we will see then

[23:55] <badanov> I can straight from the perl6 website

[23:59] <guest1235123> badanov: using the web interface?

[23:59] <badanov> yes

[23:59] <guest1235123> badanov: you can certainly help :)

