[00:09] <s1n> pmichaud: yay, i made a difference :)

[00:13] <Tene> rakudo: !!!

[00:13] <p6eval> rakudo 96de99: OUTPUT«Syntax error at line 1, near "!!!"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[00:13] <Tene> syntax error?

[00:13] <Tene> !!! is NYI?

[00:13] <Tene> rakdo: ???

[00:13] <Tene> rakdo: ...

[00:14] <Tene> rakudo: ???

[00:14] <Tene> rakudo: ...

[00:15] <p6eval> rakudo 96de99: OUTPUT«Syntax error at line 1, near "???"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[00:15] <p6eval> rakudo 96de99: OUTPUT«No exception handler and no message␤current instr.: 'return' pc 17364 (src/builtins/control.pir:39)␤»

[00:15] <Tene> Huh.

[00:16] *** justatheory_ left
[00:17] *** rocket_guatemala left
[00:24] <TimToady>  rakudo: ... message

[00:25] <p6eval> rakudo 96de99: OUTPUT«Statement not terminated properly at line 1, near "message"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[00:25] <TimToady> std: ... message

[00:26] <p6eval> std 26570: OUTPUT«Undeclared routine:␤   message used at 1 ␤ok 00:02 35m␤»

[00:26] <TimToady> std: ... 'message'

[00:26] <p6eval> std 26570: OUTPUT«ok 00:02 35m␤»

[00:28] *** bacek_ joined
[00:36] *** nihiliad joined
[00:53] <wayland76> TimToady: I'm working on a Perl6 keyboard layout for XCB (ie. XWindows).  Are there any characters you particularly want on it?  I've already got lots of quoting constructs, and the "cents" sign.  Anything else?

[00:56] *** km2 joined
[01:01] *** rocket_guatemala joined
[01:02] *** justatheory joined
[01:03] *** rocket_guatemala left
[01:04] <TimToady> hiragana? :)

[01:04] <wayland76> Oh, did I mention Greek?  That too :)

[01:06] <wayland76> It would probably be possible to set it up so that hiragana is an option, if people want that.  But I was more asking if there were any other Unicode characters you were planning to put into Perl6

[01:06] <TimToady> std: sub αβγ {...}

[01:06] <p6eval> std 26570: OUTPUT«ok 00:02 35m␤»

[01:06] <TimToady> you mean, besides all of 'em :)

[01:06] <wayland76> I had a rakudobug when I tried something like that on it.

[01:06] <TimToady> missing icu?

[01:07] <wayland76> TimToady: Yeah, I meant a limited number that might be used for operators or other special things like that

[01:07] <TimToady> rakudo: sub αβγ {...}

[01:07] <p6eval> rakudo 96de99:  ( no output )

[01:07] <TimToady> well, various latin-1 chars are more likely, though long term we'll end up using some number of the mathy ops like set ops

[01:08] <wayland76> rakudo: my $αβγ = 1

[01:08] <TimToady> seems like a compose key is more useful than a keyboard

[01:08] <p6eval> rakudo 96de99:  ( no output )

[01:08] *** amoc left
[01:08] <wayland76> rakudo: my $αβγ = 1; print $αβγ;

[01:09] <p6eval> rakudo 96de99: OUTPUT«1»

[01:09] <wayland76> I think it's fixed :)

[01:10] <wayland76> Ok, I was planning on working Latin-1 stuff in somehow.  and I'm assuming that the ISO standard Ctrl+Shift+U123 works, and multiple levels and stuff.  

[01:10] <wayland76> I'll look at the set operators particularly, though

[01:10] <wayland76> (since you mentioned them)

[01:10] <TimToady> then there's APL :P

[01:12] <wayland76> I've got them already :)

[01:12] <wayland76> Well, I'm working on them, anyway :)

[01:14] *** sephee joined
[01:14] <TimToady> I'd like a keyboard I can define my own compose sequences on the fly  :)

[01:15] *** PhatEddy joined
[01:15] <wayland76> TimToady: Seen the Avant Stellar?

[01:16] <wayland76> http://www.cvtinc.com/products/keyboards/stellar.htm

[01:17] *** hercynium joined
[01:18] <PhatEddy> rakudo: say $*NOTDECLARED

[01:18] <p6eval> rakudo 96de99: OUTPUT«Use of uninitialized value␤␤»

[01:18] <PhatEddy> rakudo: say ''

[01:18] <p6eval> rakudo 96de99: OUTPUT«␤»

[01:20] <PhatEddy> With the NOTDECLARED  - there's an open RT #57578 but I am not sure there is still a problem.  Anyone see one?

[01:23] *** japhb left
[01:24] <TimToady> can't complain at compile time because you don't know what your dynamic context will be

[01:24] <TimToady> and $* will look up the dynamic context

[01:25] <PhatEddy> Does the S02 proclamation "Most variables with twigils are implicitly declared or assumed to be declared in some other scope" apply here?

[01:27] <TimToady> yes

[01:27] <TimToady> with $*, the closest analogy is environment variables

[01:27] <TimToady> until you run the program you don't know whether it's defined at all

[01:28] <TimToady> it's just we're treating every dynamic scope as a "process" in that sense

[01:29] <PhatEddy> That ticket has not been updated in about a year so I will just forward the conversation to moritz (the author) and let him mull it over.  thx

[01:30] <pugs_svn> r26571 | azawawi++ | [S:H:P6] version 0.48 contains STD which now warns about redeclared variables

[01:39] *** azawawi joined
[01:40] *** dukeleto joined
[01:40] <azawawi> TimToady: how can i differentiate between an STD error and warning? I need to display them in separate categories in Padre Perl6 error list.

[01:41] <TimToady> for now, it always puts the warnings at the end, after "Other potential difficulties" or some such

[01:42] <TimToady> and currently the undef/redef errors are all warnings

[01:42] <TimToady> I suppose I could put out a special marker between

[01:43] <azawawi> so PARSE FAILED marks the beginning of errors and Other potential difficulties = warnings...

[01:47] <azawawi> TimToady: thx

[01:49] *** fridim_ left
[02:04] *** azawawi left
[02:04] <PhatEddy> std: //

[02:04] <p6eval> std 26571: OUTPUT«##### PARSE FAILED #####␤Can't understand next input--giving up at /tmp/221jjEvDXb line 1:␤------> [32m/[31m/[0m␤    expecting ws␤FAILED 00:02 37m␤»

[02:10] *** silug joined
[02:12] *** SamB left
[02:13] *** SamB joined
[02:14] *** nbrown joined
[02:17] *** justatheory left
[02:20] *** PhatEddy left
[02:21] *** alester left
[02:23] *** nbrown left
[02:23] *** nbrown joined
[02:47] *** eternaleye joined
[02:59] *** agentzh joined
[03:08] *** japhb joined
[03:15] *** sri_kraih joined
[03:17] *** agentzh left
[03:20] *** Limbic_Region left
[03:21] *** hercynium left
[03:26] <pugs_svn> r26572 | lwall++ | [gimme5] modify ||'s eval{} to allow panics through

[03:26] <pugs_svn> r26572 | lwall++ | [STD] parse \c, \o, \x consistently, helmut++

[03:26] <pugs_svn> r26572 | lwall++ | [STD] give better error message on //, PhatEddy++

[03:35] *** sri_kraih_ left
[03:37] *** orafu left
[03:37] *** orafu joined
[03:39] <s1n> perl6: my %p = <a 1 b 2>; for %p.keys -> $key { say %p<$key> }

[03:39] <p6eval> elf 26572: OUTPUT«Not a HASH reference at ./elf_h line 260.␤ at ./elf_h line 5881␤»

[03:39] <p6eval> ..pugs: OUTPUT«␤␤»

[03:39] <p6eval> ..rakudo 96de99: OUTPUT«Use of uninitialized value␤␤Use of uninitialized value␤␤»

[03:39] <s1n> so what am i doing wrong with that?

[03:40] <s1n> if i say just $key or %p<a> (or b), it works

[03:42] *** alanhaggai joined
[03:42] <pugs_svn> r26573 | lwall++ | [Cursor] fix bogus duplicate enum warnings

[03:42] <TimToady> %p{$key}, not <$key>

[03:43] <TimToady> <$key> is equiv to {'$key'}

[03:43] <s1n> oh yeah, i keep mixing that

[03:43] <s1n> <> and {} still doesn't seem intuitive yet

[03:43] <TimToady> <> always quotes

[03:43] *** agentzh joined
[03:44] <s1n> (this is totally out of honest curiousity, not judging) what was the need that made <> necessary?

[03:45] <TimToady> consistency with the qw form, convenience without special-casing {} like p5 does

[03:45] <TimToady> and the fact that so many hash lookups are done with fixed keys anyway

[03:45] <TimToady> not all of which are identifiers

[03:46] <s1n> oh okay (i always liked how {} made me / allowed me to do what i wanted)

[03:46] <s1n> i typically never have fixed lookup things :)

[03:46] <TimToady> and it became more important with adding the sigil into the variable name: CALLER:<$x>

[03:47] <TimToady> CALLER::<$x> rather

[03:48] <s1n> what's that?

[03:48] <TimToady> same as $CALLER::x

[03:48] <s1n> or better, where's that?

[03:48] <TimToady> but gets the sigil where it belongs

[03:48] <TimToady> likewise OUTER::<$x>, etc

[03:48] <TimToady> oh, S02:2000 or so

[03:50] <TimToady> fetch kid from karate &

[03:56] *** ab5tract joined
[03:59] *** sephee left
[04:03] *** alanhaggai left
[04:04] *** SamB left
[04:06] *** sri_kraih_ joined
[04:09] *** angelixd left
[04:21] *** Kisu left
[04:23] <pugs_svn> r26574 | lwall++ | [STD] allow any radint inside \c[...]

[04:25] *** justatheory joined
[04:25] *** bacek left
[04:26] *** sri_kraih left
[04:36] <pugs_svn> r26575 | lwall++ | [STD] put role params into new pad

[04:38] *** sri_kraih joined
[04:39] *** lambdabot left
[04:41] *** lambdabot joined
[04:56] <pugs_svn> r26576 | lwall++ | [hyper.t] dedup class

[04:58] *** sri_kraih_ left
[04:59] <pugs_svn> r26577 | lwall++ | [STD] lexical Foo::Bar symbols should be rooted in current lexpad

[05:08] *** ejs joined
[05:08] *** skids left
[05:12] *** zamolxes left
[05:13] <pugs_svn> r26578 | lwall++ | [eval.t] dedup EvalTester class

[05:16] *** orafu left
[05:16] *** orafu joined
[05:18] <pugs_svn> r26579 | lwall++ | [rule-in-class-Str.t] start turning 'is also' into 'augment' to see who screams :)

[05:22] <pugs_svn> r26580 | lwall++ | [times.t] dedup $stop

[05:30] <TimToady> zzz & # now dejetlagged to somewhere between CDT and MDT :)

[05:33] *** justatheory left
[05:44] *** lambdabot left
[05:48] *** lambdabot joined
[05:49] *** lambdabot left
[05:53] *** meppl joined
[05:53] *** lambdabot joined
[05:54] *** lambdabot left
[05:56] *** ejs left
[05:58] *** lambdabot joined
[06:21] <literal> http://perlgeek.de/blog-en/perl-6/tidings-2009-05.writeback

[06:21] <literal> moritz_: hm, post from the future? :P

[06:23] <moritz_> literal: so to say ;-)

[06:26] <moritz_> TimToady: Rakudo screams. I've submitted a patch to RT that turns 'is also' into 'augment', but I didn't want to apply it because it breaks too many of the test

[06:28] <pugs_svn> r26581 | moritz++ | [t/spec] remove pointless test import.t

[06:35] *** amoc joined
[06:35] *** ab5tract left
[06:41] *** iblechbot joined
[06:46] <pugs_svn> r26582 | moritz++ | [t/spec] simplfiy eval.t to not use lexical classes

[06:50] *** azawawi joined
[06:56] *** DemoFreak joined
[07:05] *** amoc left
[07:09] *** azawawi left
[07:12] *** amoc joined
[07:12] <arnsholt> rakudo: class A { method x { say 1; } }; class B is A { method x($self:) { A.HOW.dispatch(self, "x"); } }; (B.new).x;

[07:12] <p6eval> rakudo 2faf4b: OUTPUT«1␤»

[07:13] <arnsholt> rakudo: class A { method x { say 1; } }; class B is A { method x($self:) { A.HOW.dispatch(self, "x"); } }; B.x;

[07:13] <p6eval> rakudo 2faf4b: OUTPUT«maximum recursion depth exceeded␤current instr.: 'parrot;P6object;HOW' pc 54 (runtime/parrot/library/P6object.pir:98)␤»

[07:14] <arnsholt> Is this a bug, or something about dispatch of static method invocations I'm missing?

[07:18] *** wayland76 is now known as oracle

[07:18] <oracle> Reply hazy.  Ask again in 4 hours :)

[07:18] *** mberends joined
[07:18] *** oracle is now known as wayland76

[07:19] <moritz_> arnsholt: I don't know. In case of doubt submit it as a bug, and have it rejected if it's not a bug after all ;-)

[07:19] <wayland76> Ooh!  SOmeone who knows stuff is awake!  My apologies!  

[07:19] <lambdabot> wayland76: You have 3 new messages. '/msg lambdabot @messages' to read them.

[07:19] <moritz_> who? ;-)

[07:19] <wayland76> moritz_: Well, compared to me, anyway :)

[07:20] <mberends> @tell masak git pull proto - dogfood patch :)

[07:20] <lambdabot> Consider it noted.

[07:21] <arnsholt> moritz_: Sounds sane enough

[07:26] *** alanhaggai joined
[07:31] <eternaleye> (re embedding the git revision) Why not do something in tools/ that generates, say, a RakudoVersion.pir (.include'd where appropriate) containing the appropriate content for -V, that gets called by the makefile when building a binary? the script in tools/ could check for .git, and if it isn't present, use a commitish from a file.

[07:35] <mberends> eternaleye: aye. would it be able to generate some kind of ascending sequence in the version, eg 09-04-nnn as previously discussed?

[07:40] <mberends> Of course it could, if we want it to. Friendlier than (abbreviated) SHA-1 id.

[07:43] <Matt-W> Morning

[07:43] <mberends> Matt-W: Morning

[07:48] *** nihiliad left
[07:56] *** riffraff joined
[07:58] <eternaleye> mberends: run this in your rakudo clone: export LAST_TAG=`git tag -l '????-??' | sort -r | head -n 1`; echo $LAST_TAG `git log refs/tags/${LAST_TAG}..HEAD --pretty=format:'%h%n' | wc -l` `git log -1 --pretty=format:%h` | perl -nlpe 's/\s+/:/g'

[07:58] <eternaleye> Should give the right string

[07:59] <eternaleye> The export is necessary because `...` creates a nested scope.

[08:00] <eternaleye> The real issue will be rewriting that in pure perl instead of POSIX shell for the win32 folks

[08:01] *** rindolf joined
[08:01] *** rindolf left
[08:02] <Matt-W> But Perl's really good at just that sort of thing :)

[08:09] <eternaleye> http://dpaste.com/39539/

[08:09] <eternaleye> It was easier than I thought.

[08:09] <eternaleye> Just 4 lines :D

[08:10] *** amoc left
[08:10] <eternaleye> Although, reverse( sort() ) and shift() might be clearer

[08:10] <moritz_> or $throwaway[-1]

[08:11] * eternaleye facepalms

[08:12] <eternaleye> It followed from that it was initially pop( sort() ), and I only added @throwaway when perl complained about needing an array, not a reverse

[08:12] *** ejs joined
[08:12] <moritz_> use List::Util qw(maxstr);

[08:13] <moritz_> (it's a core module)

[08:17] <eternaleye> Yeah, I still haven't got what's in core affixed in my brain. Still, my code does accomplish its goal, and it really was just a JFDI to myself.

[08:18] <eternaleye> I just realized how perfect an example this could be of bikeshedding XD

[08:27] *** eMaX left
[08:37] *** masak joined
[08:42] <mberends> eternaleye: Good example :) Looks adaptable to other formats if preferred. Incrementing a counter in a file, similar to parrot/VERSION would be an easy extension.

[08:44] <masak> mberends: Goedemorgen, meneer.

[08:44] <lambdabot> masak: You have 1 new message. '/msg lambdabot @messages' to read it.

[08:44] <masak> @massage

[08:44] <lambdabot> mberends said 1h 23m 41s ago: git pull proto - dogfood patch :)

[08:45] <masak> :)

[08:45] * masak pulls

[08:46] <masak> mberends: cool.

[08:46] <mberends> masak: huomenta (?)

[08:47] <masak> that's not Dutch, is it? :)

[08:48] <mberends> quite. submitted a P6 for P5 devs talk proposal for YE2009.

[08:49] <masak> splendid.

[08:49] <masak> ah. Finnish.

[08:50] <masak> well, World TakeOver Plans should include flooding YAPC::EU talks with P6 stuff. :)

[08:50] <kane_> classic clues that you are reading finnish: 1) I is the most common vowel. 2) there are K's everywhere 3) every letter is repeated at least once in sequence

[08:50] <mberends> heh

[08:50] <masak> only (1) applies here, though.

[08:52] <kane_> funny observation in a dutch store. there's a brand called 'euroshopper', which is present in the UK, holland, germany, sweden, finland (and 1 or 2 more of 'those' countries). as such, the name of the product is written in dutch, swedish, etc on the package

[08:52] <kane_> now assume the length of the name is X in dutch/swedish. it is guaranteed >3X in finnish

[08:52] <kane_> it's like freaking entish at times

[08:53] <masak> it's a tradeoff.

[08:53] <masak> the win is structure and logic.

[08:53] <masak> (or so I've been told)

[08:53] <kane_> and 17 different cases (german has 4 and even THAT is confusing)

[08:53] <masak> meh. Finnish is easy. even small children can learn it.

[08:53] <kane_> making finnish rank extremely high on the 'hard to learn' curve... but yeah, the finns seem to manage just fine :)

[08:54] <mberends> it's said that 3 year olds in every nation have no problem learning the lingo.

[08:54] <kane_> i learned 4 out of 5 languages i speak before the age of 8

[08:54] <kane_> after that.. it got significantly harder

[08:55] <masak> mberends: I like your dogfood patch, but it has an unfortunate hidden assumption -- do you see it?

[08:56] <mberends> masak: I thought about the installer process overwriting its own source file, but the compile/execute mode should survive that. I guess you mean something else...

[08:57] <masak> yes.

[08:57] <masak> think about a recent commit you made.

[09:01] <mberends> ok, I give up. suspect that directories are somehow involved.

[09:02] <masak> "default rakudo and project directories to be same as where proto is installed, so that they all become siblings."

[09:02] <masak> but... it's only a default.

[09:02] <masak> not an inherent rule.

[09:03] <masak> which suggests that proto needs to be marked as special somehow in projects.list

[09:03] <mberends> ah, so the proto project needs an exception for itself... like you're saying

[09:03] <masak> I've been thinking of this for a while, and if we eventually include rakudo and parrot,

[09:03] <masak> they should be marked as special in the same way.

[09:03] <mberends> agreed.

[09:03] <masak> I suggest settting 'type' to 'meta' or some such.

[09:04] <masak> "masak's third rule of projects: every project evolves to contain the term 'meta' somewhere"

[09:05] <mberends> relatedly, I'm creating a Gitorious repository account to raise the baskets/eggs ratio.

[09:05] <masak> excellent.

[09:05] <masak> for what project?

[09:05] <wayland76> (Incidentally, Quenya is based on Finnish, in some ways :) )

[09:05] <masak> wayland76: aye.

[09:05] <masak> and Latin.

[09:06] <mberends> I think forking HTTP::Daemon out of perl6-examples will help dependent installations.

[09:06] <masak> mberends: if you do that, I'll cede the need for a copy in Web.pm

[09:06] <masak> and introduce a dep instead.

[09:07] <mberends> exactly, the right way forward imho.

[09:07] <masak> 是.

[09:09] *** wayland76 left
[09:09] * masak chooses to mark proto as type 'bootstrap' instead of 'meta'

[09:09] *** bacek_ left
[09:11] <masak> mberends: Druid grew and grew until it sort of burst out into a class hierarchy. I suspect proto will follow the same path, if it's still needed when it reaches that point. proto precompilation will then become an extra installation step.

[09:14] <mberends> good idea. 'installer' startup time is a little slow. that does mean a small 'installer' main program calling some kind of 'meta-installer' (sorry) PIR module.

[09:17] <masak> three lines. 'use v6;' 'use Proto::Installer;' 'Proto::Installer.run(@*ARGS);'

[09:18] <masak> we need that, too, if things like WTOP are supposed to use proto's API to query about all known Perl 6 projects.

[09:20] <mberends> I'll have tuits later today, if you want to delegate the refactoring.

[09:21] <masak> oh, gladly.

[09:21] <masak> I'm doing the 'bootstrap' patch now, but then I'll leave proto alone for the day.

[09:21] *** ejs left
[09:22] *** ejs joined
[09:24] *** c9s_ joined
[09:32] *** c9s left
[09:35] <jnthn> morning, 6folk

[09:35] <masak> jnthn: oh hai

[09:35] <masak> jnthn: Rakudo day today?

[09:36] <jnthn> masak: No, tomorrow.

[09:36] <jnthn> Too many distractions today.

[09:37] <masak> ok. tomorrow is actually better.

[09:37] <masak> Uppsala is pretty distracting today as well.

[09:37] <masak> and not in a good way. :/

[09:38] <mberends> tax returns are also distracting :( appropriate amount of fun <= 0

[09:43] <masak> bute sub of the day: http://gist.github.com/104370

[09:43] <masak> s/bute/cute/

[09:44] <masak> hm, we have &lines in Bratislava. \o/

[09:44] * masak fixes

[09:45] <jnthn> .grep({$^keep-all-nonempty-lines});

[09:45] <jnthn> :-)

[09:45] <masak> jnthn: that's what makes it cute.

[09:45] <jnthn> Yeah, took me a moment to catch on...

[09:46] <masak> :)

[09:46] <masak> self-documentation.

[09:51] <masak> mberends: I just force-pushed to proto on github, so if you pulled in the past half-hour, you might need to force-pull. sorry about that. :/

[09:52] <mberends> masak: git pulled now, all fine :)

[09:52] <masak> phew.

[09:52] <masak> in 'do not rebase upstream' is not a restriction in git istelf, only in its culture.

[09:52] <masak> (and rightly so, of course)

[09:54] <masak> ok, proto now assumes Bratislava or higher, not Oslo or higher.

[09:56] *** bacek joined
[10:02] * masak leaves proto for the day

[10:03] <masak> I like reading the comments in the 'installer' script. they all go 'when this happens, we need to think of this', '...and this', '...and this would be nice'. all very YAGNI.

[10:05] *** c9s joined
[10:21] *** c9s_ left
[10:28] <Matt-W> masak: Nice way to have comments

[10:28] <Matt-W> Too many things don't have enough comments

[10:28] <Matt-W> or the wrong kind of comments

[10:29] <Matt-W> Form needs more comments

[10:29] * jnthn suspects "'Do tha' stuff" counts as the wrong kind of comment

[10:34] <Matt-W> Generally one prefers a slight increase in precision regarding what stuff to do :)

[10:41] <jnthn> It's the one "English" comment in a file I just came accross.

[10:48] <Matt-W> What are the other comments written in?

[10:48] <masak> Swedish, I'd guess.

[10:49] <masak> jnthn: you've mentioned that comment before. commenting is somewhat of an art, I think.

[10:49] <masak> (one that I don't claim to be good at, but I'm slowly learning.)

[10:50] <jnthn> Aye, that one is an extreme example of how to be completely useless.

[10:51] <masak> somewhat higher on the scale, I'm becoming increasingly annoyed by commented-out code with no reason given for commenting it out.

[10:52] <masak> it's becoming one of those "pet peeves" of mine.

[10:52] *** payload left
[10:52] <jnthn> I've got a load of it in one system I'm working on. It was all generally old code that was replaced.

[10:53] <Matt-W> I try to tidy that sort of thing up when I've finished playing

[10:53] <masak> Matt-W: well, me too. but I play in-between commits.

[10:53] <Matt-W> I make no apology for the mess that is Form's code right now, I'm still playing with that

[10:54] <masak> Matt-W: no apology needed. I don't presume to impose my coding standards on others.

[10:54] <jnthn> (They had no version control before I took over, so I guess no way to get back to older versions.)

[10:54] *** meteorjay left
[10:55] <masak> jnthn: bitrot works much faster on commented-out code, as evidenced by the code in our DNA.

[10:56] <masak> and that codebase has _no_ explanatory comments whatsoever.

[10:56] *** Jedai left
[10:57] *** Jedai joined
[10:57] <jnthn> Oh, for sure it does.

[10:58] <jnthn> My inclination has been to rip out commented out code rather than maintain it.

[10:58] <masak> jnthn++

[10:58] <jnthn> Some of it has no doubt been commented out 5 years ago or maybe more.

[10:58] <masak> ouch.

[11:01] * masak moves to another hacking location

[11:01] *** masak left
[11:18] *** payload joined
[11:21] *** fridim_ joined
[11:27] *** zamolxes joined
[11:28] *** iblechbot left
[11:38] *** masak joined
[11:39] *** hanekomu joined
[11:41] *** |Jedai| joined
[11:46] *** DemoFreak left
[11:46] *** DemoFreak joined
[11:48] <moritz_> rakudo: say " ab ".trim

[11:48] <p6eval> rakudo 2faf4b: OUTPUT«ab␤»

[11:48] <moritz_> masak: that can simplify your cute sub from earlier even more

[11:49] <masak> moritz_: thank you.

[11:49] <masak> mberends: just diving in to fix that. pull --rebase as needed.

[11:50] <mberends> oki :)

[11:50] <frettled> jnthn++ - I tend to agree, at least as long as we have version control and can track the changes, that's _far_ more useful.

[11:51] <masak> rakudo: say ["  a", "b  ", "  c  "].map({.trim}).perl

[11:51] <p6eval> rakudo 2faf4b: OUTPUT«["a", "b", "c"]␤»

[11:51] <masak> rakudo: say ["  a", "b  ", "  c  "].map(*.trim).perl

[11:51] <p6eval> rakudo 2faf4b: OUTPUT«["a", "b", "c"]␤»

[11:51] <masak> Rakudo++

[11:51] <frettled> :)

[11:51] <moritz_> @karma Rakudo

[11:51] <lambdabot> Rakudo has a karma of 11

[11:51] <moritz_> @karma rakudo

[11:51] <lambdabot> rakudo has a karma of 11

[11:51] <moritz_> *.method is cute

[11:51] <frettled> @karma jnthn 

[11:51] <lambdabot> jnthn has a karma of 244

[11:51] <moritz_> @karma moritz

[11:51] <lambdabot> moritz has a karma of 577

[11:52] <moritz_> @karma moritz_

[11:52] <lambdabot> You have a karma of 53

[11:52] <moritz_> commits > irc

[11:52] <frettled> @karma masak 

[11:52] <lambdabot> masak has a karma of 143

[11:52] <masak> moritz_: it works very well with map, too.

[11:52] <frettled> everyone who matters have better karma than rakudo. ;)

[11:55] *** Jedai left
[11:58] <jnthn> @karma TimToady

[11:58] <lambdabot> TimToady has a karma of 31

[11:58] <jnthn> he matters too!

[11:59] *** alanhaggai_ joined
[11:59] <masak> jnthn: and he has better karma than rakudo. it still works. :)

[11:59] <moritz_> @karma lwall

[11:59] <lambdabot> lwall has a karma of 319

[11:59] <moritz_> lambdabot has lost much of its karma records it seems

[11:59] <moritz_> @karma audreyt

[11:59] <lambdabot> audreyt has a karma of 16

[12:00] <moritz_> perlbot used to have good karma records, but it's not in here anymore

[12:01] <masak> we need a bot written in Perl 6.

[12:02] <pmichaud> good morning, #perl6

[12:03] <masak> pmichaud: good *

[12:03] <masak> hanekomu is leaving use.perl.org. http://use.perl.org/~hanekomu/journal/38895

[12:03] <frettled> @karma pmichaud 

[12:03] <lambdabot> pmichaud has a karma of 391

[12:03] <frettled> @karma lambdabot

[12:03] <lambdabot> lambdabot has a karma of 0

[12:03] <masak> I agree with much he's saying, but I want to stay for now.

[12:03] <hanekomu> masak: yes, it's just too painful

[12:03] <frettled> lambdabot++

[12:04] <hanekomu> dagolden++

[12:04] <masak> it'd be nice to help improve use.perl.org somehow.

[12:05] <hanekomu> the front page might just aggregate journals entries, but then there's no point in having them in use.perl in the first place - there are enough aggregators already

[12:05] <frettled> masak: that way leads the road to madness ;)

[12:05] <hanekomu> and the journals are a bit low-tech

[12:05] <hanekomu> plus

[12:05] <hanekomu> you'd have to convince pudge, which, from what i've heard, is a bit... difficult

[12:05] <hanekomu> maybe if you packed your request into a political song, you might get a reply

[12:06] <masak> hanekomu: I hear what you're saying. and I've been frustrated with use.perl.org many times in the past 8 months.

[12:07] * jnthn sings...The democrats will lose, only if you choose, use.perl's resurrection, before the next election...

[12:07] <hanekomu> I think it only still exists (in any relevant form) because of the journal writers.

[12:07] <masak> plus, the site was ugly even at the time when sites were designed like that.

[12:07] <hanekomu> yeah :)

[12:08] <jnthn> I only post on use.perl.org because it seems to still have some readership, but if less and less people post there it's only going to lose it...

[12:09] <Matt-W> It's also very slow

[12:10] <hanekomu> Matt-W: yes. It's ok if you adblock all that crappy JavaScript.

[12:10] <hanekomu> It doesn't look much different without it...

[12:10] <masak> adblocking the crappy javascript. good idea.

[12:10] * masak does that

[12:11] <frettled> adblock?

[12:11] <frettled> NoScript!

[12:11] <frettled> Anybody browsing the web should either disable JavaScript etc. completely in their web browser, or use Firefox with NoScript.

[12:12] <ben> :\

[12:12] <frettled> (web browsers that don't support active client-side content excepted, of course)

[12:12] <ben> So many sites rely on JavaScript :[

[12:12] <frettled> the amount of 0-day exploits isn't even funny

[12:12] <frettled> ben: which is why NoScript allows you to permit javascript semi-selectively

[12:12] <ben> I realise that, but it still sounds like a chore.

[12:13] <ben> Also I might not even realise a site would be more usable with javascript when just using it without it.

[12:13] *** alanhaggai left
[12:13] <frettled> it's a bit bothersome, but not quite as bothersome as to watch your browser crash and burn, have your computer turned into a useful zombie for spamming/attacking others, etc.

[12:13] <LylePerl> Please have tried to update use.perl.org before, but pudge isn't having any of it

[12:13] <LylePerl> Please = People

[12:14] <LylePerl> It's like some of the other Perl sites and I find it really upsetting

[12:14] <LylePerl> lists.cpan.org hasn't worked for ages, I offered to fix and update it but was given a flat "no thanks"

[12:15] <LylePerl> It's like the Perl success stories on http://www.oreillynet.com/pub/a/oreilly/perl/news/success_stories.html

[12:16] <pmichaud> how many spectests do we lose by converting  'is also' -->  'augment'  ?

[12:16] <masak> pmichaud: let me know when you do, please :)

[12:16] <LylePerl> I offered to update that with modern success stories but got no where :(

[12:16] <moritz_> $ ack -l 'class.*is\s+also' t/spec|wc -l

[12:16] <moritz_> 14

[12:17] <pmichaud> well, it's slightly more than that because some 'is also's involve more than one test

[12:17] <pmichaud> but it doesn't look like _that_ high a number.

[12:17] <masak> rakudo: role A {}; role A is also { has $.foo }

[12:17] <p6eval> rakudo 2faf4b:  ( no output )

[12:17] <LylePerl> It's like some people who control certain core parts of Perl want to to get outdated

[12:17] <moritz_> tests like S04-statements/for.t need to be fudged

[12:17] <pmichaud> looking.

[12:17] <hanekomu> or just don't care but are too much of a control freak to give any of it up

[12:17] <moritz_> pmichaud: that was the number of files (-l), not of occurences

[12:18] <pmichaud> moritz_: ah, yes.  thanks.

[12:18] *** [particle]1 left
[12:18] <LylePerl> It's very frustrating

[12:18] <moritz_> without it's 27

[12:18] <pmichaud> surely for.t could be rewritten to not require 'is also'

[12:18] <LylePerl> I've been working on a new project, some details at wiki.perlportal.com

[12:18] <pmichaud> (or 'augment')

[12:19] <masak> hanekomu: couldn't one argue that with the privilege of having use.perl.org also comes the responsibility of listening to the community?

[12:19] <moritz_> LylePerl: agreed. Luckily the dev.perl.org admins accepted my patches to modernize some of the perl6 pages

[12:19] <pmichaud> is also/augment really should be thought of as EVILMONKEYPATCHING

[12:19] <masak> pmichaud: well, aren't they specced to need 'use MONKEY_PATCHING'?

[12:20] <Matt-W> They were last time I checked

[12:20] <LylePerl> It's annoyed me to the point that I'm thinking, if they aren't going to fix it, then I'll create a modern attractive alterative

[12:20] <hanekomu> masak: yes

[12:20] <fridim_> I think only doc.perl.org is fine :/

[12:20] <masak> we could patch EVIL_ in there, of course, but... :)

[12:20] <pmichaud> masak: perhaps so, but my point remains that unless we're specifically testing 'augment', we probably shouldn't be using it in the tests.

[12:20] <fridim_> s/doc/perldoc/

[12:20] <masak> fridim_: that one is very fine.

[12:21] <Matt-W> LylePerl: You could make us some amazing sites for Perl 6 :)

[12:21] <pmichaud> LylePerl: creating an alternative is a normal part of 'creative destruction'

[12:21] *** [particle]1 joined
[12:21] <LylePerl> Matt-W: Already working on it :)

[12:21] <fridim_> some catalyst clean code with great CSS :)

[12:21] <masak> it's sad, because use.perl.org is a very nice domain name.

[12:21] <frettled> yep

[12:21] <pmichaud> the main reason I post on use.perl.org is because I'm led to believe that's a primary source for people to get their Perl news.  If there's a better location, I'd likely use that.

[12:22] <masak> it ought to have a correspondingly nice software.

[12:22] <frettled> use-perl.org is available :)

[12:22] <moritz_> well, then you need blog.perl.org instead

[12:22] *** iblechbot joined
[12:22] <LylePerl> pmichaud: Hadn't heard that term before, but you are right

[12:22] <pmichaud> LylePerl: 'creative destruction' comes from economics, where new businesses replace older ones

[12:23] <arnsholt> pmichaud: Creative destruction, that's Bakunin, right?

[12:23] <arnsholt> Ah, right. Not Bakunin then

[12:23] <LylePerl> They could have news.perl.org and link it up with perlsphere and you've already got a better use.perl.org

[12:24] <masak> I'm conservative; I'll probably be one of the last to leave the sinking ship that is use.perl.org. but I'll happily try new alternatives as they arrive, and I hope that one will eventually replace use.perl.org

[12:24] <moritz_> it would be nice to have a leaner, selected feed, and a broad, cover-all feed

[12:25] <LylePerl> I'm going to provide perl moveable type blogs at blog.perlportal.com

[12:25] <LylePerl> Then several plagger agregators at news.perlportal.com

[12:26] <Matt-W> Oooh

[12:26] <masak> I want something where the HTML markup is less crippled. a non-ugly layout would be nice, too.

[12:27] <LylePerl> PerlSphere has got a bit big, things need to be broken down

[12:27] <Matt-W> Just something clean and simple would suit me

[12:27] <Matt-W> When I'm doing sites I have no patience for cross-browser compatibility hacks

[12:27] <masak> amen to clean and simple.

[12:27] <Matt-W> Probably a good thing I don't do them for a living

[12:28] <LylePerl> I was thinking that maybe things could be split by tag. Such that a blogger would add the tag Adv, Int or Beg and the aggregator would know to put it in the advanced feed, etc

[12:28] <moritz_> I don't like the division by skill level

[12:28] <moritz_> that would be good for tutorials, but nto for blogs

[12:28] <masak> agree.

[12:29] <masak> most often, I don't write at a particular skill level.

[12:29] <masak> I just write stuff.

[12:29] <Matt-W> It's hard to think in skill levels

[12:29] <Matt-W> Stuff I think is easy some people find really hard

[12:29] <ben> I am a beginner with perl but I do not think I would be interested in a feed tagged as being of low skill level

[12:29] <LylePerl> I just thought that someone new to perl might be put off by reading really complicated posts they don't understand, so could select more basic stuff they'd find useful

[12:29] <LylePerl> Maybe I'm wrong... Still early days

[12:30] <Matt-W> I think as long as they're titled appropriately, a beginner can easily pick out the kind of thing that covers basics

[12:30] <masak> LylePerl: it's an example of categorization, which works good in theory but bad in practice.

[12:30] <masak> see http://www.well.com/~doctorow/metacrap.htm for other examples.

[12:31] * jnthn -> slovak class

[12:31] *** payload left
[12:32] <LylePerl> I'll cross that bridge when I come to it. Still got a lot to do. Anyone who is interested in getting involved details are at wiki.perlportal.com

[12:32] <masak> jnthn: mať zodpovedajúce množstvo zábavy!

[12:32] * LylePerl feels like he's hijacked the channel and gone off topic so will stop now

[12:33] <masak> well, blogs are an important part of the Perl 6 community as well.

[12:34] <Matt-W> Yes

[12:34] <Matt-W> I even wrote a blog entry about Perl 6 once

[12:34] <masak> Matt-W: you too? :)

[12:35] <pmichaud> I think blog discussions are on-topic for Perl 6 -- we're often looking for better ways to "get the word out" about what is happening with Perl 6.

[12:36] <Matt-W> masak: don't you remember? It was about action methods for grammars

[12:36] <pmichaud> and yes, having use.perl.org as a primary outlet for p6 news often is at cross purposes with what we're hoping to do

[12:36] *** ejs left
[12:36] <masak> Matt-W: I remember it. it was good reading. please write more. :)

[12:36] <Matt-W> masak: I probably will write one about Form itself at some point before too long

[12:37] <Matt-W> If I get into the habit I'll have to see about getting onto planet perl 6

[12:37] <moritz_> that's why I'm spilling Perl 6 stuff on the ironman aggregator

[12:37] <masak> Matt-W: when the time is ripe, I plan to review your project.

[12:37] <frettled> moritz_: ditto

[12:37] <Matt-W> masak: meep

[12:37] <masak> :)

[12:37] <Matt-W> How are you on text justification algorithms?

[12:37] <Matt-W> I'm sure you can come up with a better one

[12:38] <masak> Matt-W: make sure you write code that stands public review, s'all. no pressure. :)

[12:39] <moritz_> no justifications; it's forgiveness here :-)

[12:39] <Matt-W> Oh it mostly does

[12:39] <Matt-W> It's just a bit scrappy in places

[12:39] <masak> all projects are.

[12:39] <Matt-W> I accept patches for tidyings :)

[12:39] <masak> Matt-W: that's much of what a review is about.

[12:40] <masak> Matt-W: when I reviewed Pod::Parser, I also sent 10 patches in a pull request to mberends.

[12:40] <Matt-W> :)

[12:40] <Matt-W> I started using reduction operators

[12:40] <frettled> Hey, I got good feedback for changes to my blog here, and I even implemented them.

[12:40] <Matt-W> they're fun

[12:41] <masak> aye.

[12:41] <Matt-W> It's like having foldr, but the syntax is nicer

[12:41] <masak> moritz_: I got this idea to code-review the spectest suite. given time, I might do that this weekend.

[12:41] <Matt-W> [+] @list instead of foldr (+) 0 list

[12:42] <moritz_> masak: if that results in patches... good

[12:42] <masak> :)

[12:42] <moritz_> masak: it's full of repetitions, and thus very bad code in very many places

[12:42] <masak> I think it would.

[12:42] <masak> moritz_: sounds promising.

[12:42] <Matt-W> yay

[12:42] <Matt-W> go masak

[12:43] <moritz_> but there's also a point to it - not using fancy features improves the chances of running them by early implementations

[12:44] <masak> I'm not sure that's such a strong argument.

[12:44] <masak> but I will know when I look at actual repetitive code.

[12:45] <masak> for loops are still a fairly simple construct.

[12:45] *** hanekomu left
[12:45] <pmichaud> I agree -- I'd like the tests to focus more on the feature they're testing and less on using some other fancier construct in the process.

[12:46] <moritz_> the second point is fudging

[12:46] <moritz_> having tests in a data structure makes fudging much harder

[12:47] <masak> nod.

[12:47] <masak> because fudging is out-of-band and selective on certain functions.

[12:48] <masak> moritz_: one could make two data structures in such a case; one with unfudged tests, and one with fudged ones.

[12:49] <moritz_> masak: that doesn't scale for multiple implementations

[12:50] <masak> oh. you're right.

[12:50] <masak> :/

[12:50] <frettled> simple tests for simple problems, eh?

[12:50] <masak> how many implementations are currently targetting the spectest suite, using the fudging system?

[12:51] *** alanhaggai_ left
[12:51] <moritz_> currently only one

[12:52] <masak> I call YAGNI.

[12:52] <moritz_> two, actuallz

[12:52] <moritz_> pugs does

[12:52] <masak> ok.

[12:52] <moritz_> and elf could be, if mncharity set up a proper test harness

[12:53] <moritz_> I'd be willing to help with fudging

[12:53] <frettled> mmm, fudge

[12:56] *** riffraff left
[12:58] *** xinming_ is now known as xinming

[13:03] <PerlJam> good swineflu er, morning #perl6

[13:03] <Matt-W> hi PerlJam

[13:04] <LylePerl> Is the logo on http://www.perl6-projects.org/ the official Perl 6 one? Or is it the usual onion?

[13:04] <moritz_> LylePerl: it's as close to official as we have one

[13:04] <moritz_> LylePerl: but it's not really final

[13:04] <PerlJam> LylePerl: Camelia is official-ish  (Larry created her and endorses her :)

[13:04] *** wolverian joined
[13:04] <Matt-W> Ow!

[13:04] <Matt-W> my eyes!

[13:05] <frettled> hee-hee

[13:05] <frettled> I suspect that some other stylistic representation of the butterfly is needed for an O'Reilly book.

[13:05] <frettled> well, at least in the reference series.

[13:05] <PerlJam> frettled: no, O'Reilly has a camel

[13:05] <Matt-W> yeah

[13:05] <frettled> PerlJam: for Perl 5, yes.

[13:05] <Matt-W> the camel is their logo for perl

[13:05] <Matt-W> they'll use it again I think

[13:05] <Matt-W> if they publish programming perl 6

[13:06] <frettled> Someone will have to talk with them about that.

[13:06] <PerlJam> frettled: Perl is Perl is Perl is Perl

[13:06] <Matt-W> I suppose they could switch to a two-hump camel for perl 6

[13:06] <frettled> PerlJam: :)

[13:06] <Matt-W> it's too big for a one-hump camel

[13:06] <frettled> Matt-W: you mean an actual camel rather than a dromedarian?

[13:06] <Matt-W> it might even need a three-hump camel

[13:06] <frettled> two camels humping?

[13:07] <Matt-W> lol

[13:07] <Matt-W> the booksellers might not like that

[13:07] <LylePerl> It doesn't come across as that attractive to corporate entities...

[13:08] <PerlJam> frettled: What makes bactrians "actual camels" and dromedaries not?

[13:09] <frettled> PerlJam: semantics :)

[13:09] *** masak left
[13:10] <arnsholt> PerlJam: They're just two different species of camel

[13:10] <arnsholt> But when most people say "camel", they usually mean the two-humped version

[13:10] *** ruoso joined
[13:10] *** masak joined
[13:11] <frettled> this is also a long-standing Perl joke

[13:11] <ruoso> Hello!

[13:11] <frettled> that is, I recall it being around around '94 or '95, when I first saw the camel book, I don't know if it's a really old joke.

[13:12] <LylePerl> As much as I truly respect Larry's programming abilities... That logo reminds me quite a bit of his website...

[13:15] *** masak left
[13:15] *** km2 left
[13:15] *** masak joined
[13:16] *** payload joined
[13:19] <TimToady> perhaps O'Reilly could just add a couple butterfly wings to their current camel...

[13:21] <ruoso> I like the camelia... but it's much more a mascot than a logo

[13:21] <ruoso> it has some practical problems when you try to use it as a logo

[13:21] <TimToady> well, okay, what's the logo of Linux that isn't Tux? :)

[13:21] <LylePerl> TimToady: Would you mind I had my designer make a smoothed off version?

[13:22] <ruoso> TimToady, linux doesn't really have a logo...

[13:22] <PerlJam> smoothed off?

[13:22] <ruoso> TimToady, but tux is considerably more logo-oriented than camelia

[13:22] <TimToady> if you want to make big camelia look a little more like the 32x32, esp in the P6, that'd be okay

[13:23] <pmichaud> LylePerl: http://groups.google.com/group/perl.perl6.language/msg/035ea2750d54cbef

[13:23] <ruoso> there needs to be a black-white version as well

[13:23] <TimToady> >>ö<< is a valid simplification :)

[13:23] <pmichaud> and 

[13:23] <pmichaud> http://groups.google.com/group/perl.perl6.language/msg/74b0228db755a860

[13:24] <pmichaud> (TimToady's previous musings on the subject)

[13:24] <moritz_> »ö« even?

[13:24] *** eric256 joined
[13:24] <TimToady> that too

[13:24] <pmichaud> Is Camelia from Texas?  ;-)

[13:25] <TimToady> when she wants to be

[13:25] <LylePerl> Ok. I'll see what we can come up with, I'll post some samples later...

[13:26] <ruoso> LylePerl, please consider getting the various applications of the logo as well, if that's possible

[13:28] <PerlJam> having a grey-scale or black and white version would be ncie.

[13:28] <PerlJam> er, nice

[13:28] * pmichaud misses dalek.

[13:29] <ruoso> usually, you need versions for monocolor, 2 colors and 3 colors besides the full color version (although you don't usually want to have a logo with more than three colors)

[13:30] <TimToady> LylePerl: note that the smoothest existing version is pugs/misc/camelia.odg currently, since it's in OpenOffice Draw

[13:31] *** masak left
[13:34] *** exodist joined
[13:34] <LylePerl> ok

[13:35] *** skids joined
[13:36] <TimToady> just had horrors of trying to work from the .png  :)

[13:37] <TimToady> the 16x and 32x versions are also in pugs/misc

[13:38] <TimToady> ruoso: well, maybe we can raise the bar on logos as we have raised the bar on other things  :)

[13:38] *** payload left
[13:38] <TimToady> but certainly camelia was designed to decolorize, among other things.  it's one of my requirements

[13:39] <ruoso> TimToady, well... yeah... but I'd delegate that raising for a graphic designer ;)

[13:39] <TimToady> pistols at dawn?

[13:39] <ruoso> heheh

[13:40] * ruoso notes that he does like the camelia, but it currently stands only as a mascot... we need a logo version of it...

[13:41] *** jhorwitz joined
[13:41] <skids> TimToady: just make sure you trademark her before book publishers do :-)

[13:41] <TimToady> well, I can leave that up to the various Perl Distribution Corporations to come up with

[13:43] <TimToady> yes, trademark is a potential issue

[13:44] *** masak joined
[13:44] <pmichaud> currently, if a book publisher attemped to use camelia as a trademark, wouldn't that be a copyright infringement?  ;-)

[13:45] *** riffraff joined
[13:45] <TimToady> but I'd really rather not have to say »ö«® or even »ö«™

[13:45] <PerlJam> rakudo:  sub time-it { "hi" }; say time-it();

[13:45] <p6eval> rakudo 69a37f: OUTPUT«Could not find non-existent sub it␤current instr.: '_block14' pc 68 (EVAL_16:45)␤»

[13:45] <TimToady> pmichaud: Oh, I don't doubt we could call them on it, but doing so could induce ulcers

[13:52] *** SamB joined
[13:54] *** [particle] joined
[13:55] <skids> They wouldn't use camelia.  They'd use a butterfly and TM "the use of a butterfly in association with perl6", so there'd be no recourse :-)

[13:58] *** km2 joined
[14:02] *** c9s_ joined
[14:03] *** c9s left
[14:03] *** c9s_ is now known as c9s

[14:05] *** DemoFreak left
[14:05] <pugs_svn> r26583 | lwall++ | [camelia] add a subtle TM to (maybe) prevent theft

[14:06] *** DemoFreak joined
[14:09] *** mj41 joined
[14:11] <diakopter> TimToady: I hope I didn't offend with the all-blown-up camelia...

[14:13] <diakopter> I thought it looked really neat way over-anti-aliased 

[14:14] <pugs_svn> r26584 | pmichaud++ | Some references and discussion surrounding Camelia.

[14:15] <pugs_svn> r26585 | lwall++ | [camelia] also add subtle TM to odg and svg versions

[14:16] <TimToady> diakopter: the latest version will probably blow up better since it's got more transparency info

[14:17] <pmichaud> TimToady: who/what is Camelia a TM of...?

[14:17] <pmichaud> (for now, at least?)

[14:19] <skids> perlfoundation has lawyers, no?

[14:19] <diakopter> (see the definition of foundation...) :P

[14:20] *** diakopter sets mode: -o diakopter

[14:20] <pmichaud> I'm not asking for a full legal treatment; just that normally one says "Camelia is a trademark of {TPF|Larry Wall|...}"

[14:21] <pmichaud> and I can put that in the camelia.txt file that was just committed.

[14:21] *** Eevee_ joined
[14:21] <ruoso> isn't the fact that we openly published it something that already prevents someone from registering it?

[14:22] <pmichaud> well, trademarks have to be defended, also.

[14:22] <skids> It's not the image itself, perse, it's the act of using it for a certain purpose.

[14:22] <diakopter> uspto.gov has no "camelia" registration record (for computer science... there are a couple for other contexts)

[14:24] <diakopter> but the use of that logo as a 2d/3d recognizable form is already protected by the initial use, afaik, ianal (but my siblings and father are)

[14:24] <pmichaud> it's slightly more complicated than that -- it has to be initial use "in commerce"

[14:24] <pmichaud> afaik, we haven't had a commercial transaction yet.

[14:25] * diakopter sends larry $5 on paypal

[14:25] <pmichaud> although placing camelia on perl6-projects.org is probably a good start.  And I have camelia as the logo at github.com/perl6

[14:26] <moritz_> should I also place it on rakudo.de?

[14:27] <moritz_> or should rakudo remain unassociated for now?

[14:27] <pmichaud> also, I suppose we should be writing "Camelia" instead of "camelia", since it's a proper name.  Camelia might not like the lowercase version :-)

[14:27] <pmichaud> rakudo has its own (temporary) logo -- see rakudo.org and github.com/rakudo

[14:27] <jnthn> And given life-size she's a few meters across, it's probably best to do what she likes.

[14:27] *** cj joined
[14:28] <moritz_> pmichaud: that's what I use as well

[14:28] *** spx2 left
[14:28] *** spx2 joined
[14:29] <jnthn> masak: (slovak) Did that couple from Google Translate? ;-)

[14:30] <jnthn> But yes, I did have. :-)

[14:30] <masak> jnthn: aye. how did I do? :)

[14:31] <masak> I'll be out eating barbecueue food, checking in on you regularly.

[14:31] <masak> &

[14:31] <skids> If I read this right, if we want Camelia to be freely usable across the OpenSource Perl6 community, we actually want to get it legally declared "diluted" at some point, and that's the way to prevent squatting/appropriation.

[14:32] <skids> So yes, using it as much as possible, from as many sources as possible would be good in that case.

[14:33] <skids> So rather than defending it, the exact opposite -- make it indefensible.

[14:33] <jnthn> masak: Well, you managed to use a couple of words I hadn't seen before. ;-)

[14:34] <pmichaud> skids:  I'm not sure that's exactly what is wanted.  (more)

[14:34] <pmichaud> it's not only a question of avoiding someone else grabbing the mark such that nobody else can use it

[14:34] <pugs_svn> r26586 | lwall++ | [camelia.txt] add some legalese about copyright and trademark status

[14:34] <TimToady> feedback welcome

[14:34] <pmichaud> we also want to make sure the mark isn't used for inappropriate purposes

[14:35] <pmichaud> i.e., so that someone doesn't start trading on the mark in a way that is contrary to the purposes of the mark

[14:35] <pmichaud> there are many ranges of opinion on that topic though.  :-)

[14:36] <pmichaud> TimToady++  # looks like an excellent start to me

[14:36] <TimToady> I think we have to undilute it before we dilute it  :)

[14:37] <skids> That may very well be the case :-)

[14:37] <TimToady> anyway, see misc/camelia.txt now

[14:37] <eric256> any idea when web 2.0 came to mean blogs? lol, got a marketing person refering me to a web2.0 page thats nothing but a blog...lame

[14:38] *** alester joined
[14:38] *** DemoFreak left
[14:38] <skids> http://en.wikipedia.org/wiki/Trademark_dilution#Blurring_and_tarnishment

[14:39] <TimToady> diakopter: thanx for the bux

[14:39] <skids> We'd want it blurred, but defended against tarnishment.

[14:39] <ruoso> eric256, don't be angry... web2.0 is already over... we're getting to web3.0

[14:40] <skids> (if I get pmichaud right)

[14:40] <eric256> ruoso:  ;)

[14:40] <pmichaud> skids: yes, I think that's about right.  Anyway, IANAL, but I think what TimToady++ has put in camelia.txt is a good enough start for now.

[14:41] *** rocket_guatemala joined
[14:42] <TimToady> it's unclear whether I'm a better lawyer than a graphic designer, but at least Artistic 1 has stood up in court (for now)

[14:43] <ruoso> TimToady, I think you more as an artist than as a graphic designer... and I think the camelia is a nice piece of art... 

[14:44] <TimToady> or would you prefer swords?

[14:46] <ruoso> ;)

[14:48] <skids> Whoohoo I managed to speed up rakudo a whopping 0.5% :-)

[14:48] *** Eevee left
[14:48] <jnthn> ftw

[14:49] * jnthn hopes he might manage to win us a little more than that cez may

[14:50] <jnthn> s/cez/during/

[14:50] <TimToady> ...not to mention the fact that I have two daughters who are both excellent at graphic design, and a son who has done the cover graphic on *two* books.

[14:51] <ben> Is that supposed to speak for your excellent artistic genes, or for knowing when to do outsourcing?

[14:51] * skids estimates max 2% to be gained by playing with rolling hashes in Parrot Str.

[14:51] <skids> So interesting as a passtime, but not too useful.

[14:51] <TimToady> ben: I'll never tell... ;)

[14:52] <pmichaud> we really need some profiling capabilities for parrot.  :-(

[14:52] <ruoso> TimToady, sorry if it looks that I was just bitching... but I'm honestly trying to make a constructive critique here...

[14:55] <skids> The 0.5% came from calculating the current naive hash in some places where it was being left uncalculated, string_make, substr, const_cstring_cache

[14:55] <skids> Because doing the math while it was in write cache saved pulling the contents into read cache later.

[14:56] *** frew|work left
[14:56] *** abra joined
[14:57] *** hercynium joined
[14:57] <skids> But there are some places hidden in the parser tools where a string with a calculated hash is manipulated without zeroing the hash, and that's nearly impossible to track down.

[14:57] *** mofino joined
[14:57] <TimToady> ruoso: detailed critique is fine, but meta-discussion tends not to be terribly useful to me, is all

[14:58] <TimToady> ☮

[14:58] <ruoso> TimToady, fair enough... I'll restrict my talk to the practical logo usage...

[14:59] <ruoso> TimToady, but, for sure, no hard feelings around it...

[15:06] *** alanhaggai joined
[15:07] *** Psyche^ joined
[15:09] *** Eevee_ is now known as Eevee

[15:09] *** justatheory joined
[15:14] *** rocket_guatemala left
[15:19] *** Patterner left
[15:19] *** Psyche^ is now known as Patterner

[15:21] *** pmurias joined
[15:33] *** baest joined
[15:37] <pmurias> ruoso: hi

[15:37] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[15:38] <pmurias> ruoso: i can't reproduce the segfault in mildew

[15:40] *** payload joined
[15:48] *** payload left
[15:48] *** payload joined
[15:49] <TimToady> maybe we should rename one of the things named "proto".  I'm thinking protoobjects could use a shorter name in any case.

[15:52] <jnthn> type object ain't much shorter, but construes its normal use

[15:52] <jnthn> Or a common use at least.

[15:54] <ruoso> hmm...

[15:55] <ruoso> I've been considering prototypes and protoobjects to be about the same

[15:55] <TimToady> I suppose we could just call them types...

[15:55] <ruoso> pmurias, hi

[15:55] <jnthn> On the other hand, protoobject kinda fits as "prototype", which always made more sense to me than the proto plurality declarator.

[15:56] <TimToady> but the idea of "prototype-based" OO is that your parent is a prototype, which isn't what these are about

[15:56] <jnthn> yeah

[15:56] <jnthn> I'm not sure I'd be too opposed to just calling them types.

[15:57] <jnthn> I guess they're only one type of thing that represents a type.

[15:57] <TimToady> the main thing is there's no Type type, since p6 types are just undefined instances

[15:59] <jnthn> If you allow for punning, then that definition essentially fits for roles too.

[15:59] <TimToady> I guess if we went QM they're most like leptons, as charge carriers with little mass

[16:00] <TimToady> thinking how we explain it...the type of a type is the same as any instance of the type, er...

[16:00] <TimToady> even for those types that can't have instances, er...

[16:00] <PerlJam> a one-syllable name would be nice  :)

[16:01] <TimToady> it's a type carrier the way certain particles are charge carriers, gluons and such

[16:03] <TimToady> I suppose we can just say "type object" when "type" is ambiguous

[16:03] <jnthn> type is a slightly hand-wavey thing in Perl 6 anyway. :-)

[16:04] <jnthn> Given that you can essentially use a value as a type constraint.

[16:04] <jnthn> It's just a very limited type.

[16:04] <PerlJam> call them models.

[16:04] <TimToady> sorry, that's two syllables :)

[16:04] <literal> mold

[16:05] <PerlJam> literal++

[16:05] <PerlJam> I couldn't think of any good one syllable words.

[16:05] <TimToady> course, type is three syllables in 日本語...

[16:06] <TimToady> mold...cast...caste...

[16:06] <mofino> so that's a door, a woman standing, and ... a bunch of boxes stacked together?

[16:06] <PerlJam> you could call them "kinds"

[16:07] <TimToady> O kinderlein kommet...

[16:07] *** meteorjay joined
[16:07] <ruoso> TimToady, not always...

[16:07] <ruoso> actually... depends on what you mean by parent

[16:07] <ruoso> jnthn, Dog{ :name<Fido> } is not a type

[16:08] <ruoso> exactly... they are proto-objects

[16:08] <ruoso> by the original sense of "proto" 

[16:08] <TimToady> that's a curried type

[16:08] *** sitaram joined
[16:08] <TimToady> that's why they sell curry combs for Dogs

[16:09] <jnthn> ruoso: Depends what you mean by "a type" - for sure you can't write it everywhere you can write type-ish things though...

[16:09] <TimToady> but any time you can name a type, or use .WHAT, it shows up as one of these objects

[16:09] <jnthn> Sure, if you name it it works out.

[16:10] <TimToady> it's a whatitis

[16:10] *** [particle]1 left
[16:10] <PerlJam> wotsit

[16:10] <TimToady> as opposed to whatisit, which in Hebrew is "mann", iirc

[16:10] <TimToady> *manna

[16:10] <jnthn> Though I hadn't really been expecting that ::T = Dog{ :name<Fido> }; sub foo(T $x) { } would have a sub that only accept types of Dog called Fido though...

[16:11] <jnthn> (Not sure if you were expecting that either...)

[16:11] <ruoso> jnthn, me neigther

[16:11] <ruoso> protoobjects are a bit more abstract than types

[16:11] <ruoso> type is a narrower definitino

[16:11] <TimToady> how so?

[16:11] *** sitaram left
[16:12] <jnthn> If a proto-object represents all possible values for an instance, then it fits very well as a type.

[16:12] <ruoso> jnthn, that's a definition of a class

[16:12] <jnthn> Erm, all possible values for a class...

[16:12] <pmurias> literal: mold would create confusion with smop mold's

[16:12] <jnthn> ruoso: There is no class object in Perl 6.

[16:13] <ruoso> a protoobject is simply a potential object

[16:13] <jnthn> Thus that leaves proto-objects filling the "represents everything in the domain" role.

[16:13] <literal> then use the British spelling, mould :)

[16:13] <ruoso> it's an "yet to be" object 

[16:13] <TimToady> that's not how we define class

[16:13] <PerlJam> so ... it's a "pot"?  :)

[16:14] <TimToady> in p6 a class is just a type with a certain kind of .HOW

[16:14] <TimToady> that happens to share a metaclass object among multiple values

[16:15] <ruoso> right... proto-objects might have whatever .HOW it pleases

[16:15] <TimToady> so .WHAT is really the identity op, while the type is a .HOW carrier

[16:16] <TimToady> so it's more of a howzit

[16:17] <TimToady> so far I'm not getting any bad vibes about renaming protoobjects to types

[16:18] <pmurias> ruoso: p6opaque doesn't work yet in re-mildew?

[16:19] *** [particle]1 joined
[16:19] <TimToady> there's only like 464 uses of the term already in the specs... :)

[16:21] <pugs_svn> r26587 | pmurias++ | [re-smop] fixed some warnings and a leftover smop_lowlevel_alloc in p6opaque

[16:21] *** Util joined
[16:22] <pmurias> ruoso: i'm porting over Array

[16:23] <ruoso> so you see Dog{ :name<Fido> } as a type?

[16:23] <ruoso> I'd see type much more from a Wittgesteinian perspective than a Hegelianian one... meaning... a type is not something that "represents everything in the domain", but "something that we use to define a domain, to the extent we can define it"

[16:23] <ruoso> so, that way, Dog{ :name<Fido> } isn't a type, because it has no use being used to define a domain

[16:23] <ruoso> my $dog = Dog.new( :name<Fido> }; say $dog.does(Dog{:name<Fido>});

[16:23] <ruoso> that returns False

[16:23] *** [particle]2 joined
[16:23] <ruoso> pmurias, p6opaque is not yet finished... 

[16:24] *** [particle] left
[16:24] <ruoso> but notice that there's no fundamental difference between Dog and Dog{ :name<Fido> }

[16:24] <ruoso> the same way as there isn't a difference between Dog and Dog.clone

[16:25] <ruoso> but if you say

[16:25] <ruoso> my $dog = Dog.new; say $dog.does(Dog.clone)

[16:25] <ruoso> it will also return False

[16:25] <mberends> [type] how about ilk: http://en.wiktionary.org/wiki/ilk

[16:27] <jnthn> rakudo: class Dog { }; my $dog = Dog.new; say $dog.does(Dog.clone)

[16:27] <p6eval> rakudo 69a37f: OUTPUT«1␤»

[16:28] <jnthn> rakudo: class Dog { }; my $dog = Dog.new( :name<Fido> }; say  $dog.does(Dog{:name<Fido>});

[16:28] <ruoso> hmmm... that surprises me

[16:28] <p6eval> rakudo 69a37f: OUTPUT«Statement not terminated properly at line 1, near "( :name<Fi"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[16:28] <TimToady>  hmm, "ilk has no plural"

[16:28] <jnthn> ruoso: How so?

[16:29] <mberends> we could manufacture 'ilken'

[16:29] <ruoso> jnthn, Dog and Dog.clone are different things

[16:29] <TimToady> but they have the same type

[16:29] <jnthn> I'd never really thought of cloning a proto-object as creating a new type.

[16:29] <PerlJam> I like something like "gist" or "essence" or "spirit" or "soul" more than "ilk" 

[16:29] <ruoso> but .does expects a Type, not something from witch it will take the type from

[16:30] <TimToady> you're thinking of protoobjects as prototypes again

[16:30] <PerlJam> (Or just "type"  :-)

[16:30] <TimToady> there's no such thing as a Type

[16:30] <jnthn> Dog{ ... } is still a proto-object, just one with a WHENCE

[16:30] <TimToady> all Dogs have the same type, including undefined ones

[16:31] <TimToady> or more linguistically, including the generic Dog

[16:31] <ruoso> ok... we got the an important point...

[16:31] <PerlJam> TimToady: including ones that have traits added to them too, right?

[16:31] <ruoso> so far, the spec is pretty liberal in the sense of thinking class-based or prototype-based

[16:31] <TimToady> I would think of a Dog with a WHENCE as a partially instantiated Dog

[16:31] <TimToady> but still a Dog

[16:32] <TimToady> actually, it's lazy instantiation

[16:32] <ruoso> in my mindset, Dog is the type

[16:32] <ruoso> I mean... the thing the name "Dog" points to

[16:32] <TimToady> since we can't really run the WHENCE until we have a real object to put the attributes in

[16:33] *** riffraff left
[16:33] <TimToady> all these things return the same Dog object for .WHAT

[16:33] <TimToady> including Dog itself

[16:33] <TimToady> Dog.WHAT.WHAT.WHAT.WHAT === Dog

[16:34] <TimToady> Dog.clone.WHAT === Dog

[16:34] <jnthn> Right. And Dog{ :name<Fido> }.WHAT == Dog

[16:34] <TimToady> ===

[16:34] <jnthn> Right. And Dog{ :name<Fido> }.WHAT === Dog

[16:35] <TimToady> basically we treat the issue of instantiation as completely orthogonal to the type

[16:35] <TimToady> Socrates does Man

[16:35] <TimToady> Man does Mammal

[16:36] <ruoso> right...

[16:36] <ruoso> but...

[16:37] <ruoso> ok...

[16:37] <ruoso> Dog has a pointer to itself as the WHAT

[16:38] <ruoso> so Dog.clone still points the WHAT to the original Dog

[16:38] <ruoso> but...

[16:39] <ruoso> when you do $dog.does(Dog.clone)

[16:39] <ruoso> does it mean it will ask the WHAT of the thing sent as parameter?

[16:39] <TimToady> yes

[16:39] <ruoso> rakudo: my $a = 1; say $a.does(2);

[16:39] <p6eval> rakudo 69a37f: OUTPUT«1␤»

[16:39] <pmurias> ruoso: what's the naming convention? some functions are named like SMOP__NATIVE__capture_positional and others as smop_nagc_unlock

[16:40] <ruoso> hmm... that's unexpected

[16:40] <jnthn> Heh, I'm surprised Rakudo got that one right...it wasn't what I expected either. :-)

[16:40] <ruoso> pmurias, hmm... I think we might just choose one of them...

[16:40] <pmichaud> I'm not surprised.

[16:40] <ruoso> but is that right?

[16:40] <jnthn> rakudo++ though

[16:40] <jnthn> ruoso: If we call .WHAT on it, it just falls out like that.

[16:40] <pmichaud> Rakudo actually does things more through the .HOW than the .WHAT

[16:40] <TimToady> well, 2 is a subset type of Int

[16:41] <ruoso> in that case it was supposed to fail

[16:41] <TimToady> but subset types don't show up as the types of actual storage

[16:41] <pmichaud> i.e.     $foo.does($x)  is really asking if $foo's .HOW does $x's .HOW

[16:41] <jnthn> ruoso: 2.WHaT === Int

[16:41] <jnthn> 1 does Int

[16:42] <ruoso> jnthn, I see that this is what happens

[16:42] <ruoso> I'm arguing about wether this is sane

[16:42] <ruoso> pmichaud, .HOW? wasn't it supposed to be .WHAT?

[16:42] <pmurias> TimToady: so a objects type would be itself?

[16:42] <jnthn> S12 reseves it.

[16:42] <jnthn> For now Perl 6 reserves the right to change how all these macros

[16:42] <jnthn> and the corresponding C<^> forms are defined in terms of each other.

[16:42] <TimToady> does's arg is taken as a storage type, not as a constraint type

[16:43] <TimToady> the type of True is Bool

[16:43] <TimToady> even though True is a constrained type of Bool

[16:43] <TimToady> rakudo: True.WHAT

[16:43] <p6eval> rakudo 69a37f:  ( no output )

[16:43] <TimToady> rakudo: say True.WHAT

[16:43] <pmichaud> (true is broken in rakudo, sorry)

[16:43] <p6eval> rakudo 69a37f: OUTPUT«()␤»

[16:43] <TimToady> pugs: say True.WHAT

[16:43] <p6eval> pugs: OUTPUT«Bool␤»

[16:43] <ruoso> pugs: say 0.does(True)

[16:43] <p6eval> pugs: OUTPUT«␤»

[16:44] <ruoso> pugs: say False.does(True)

[16:44] <p6eval> pugs: OUTPUT«1␤»

[16:44] <ruoso> that really surprises me

[16:44] *** nihiliad joined
[16:44] <TimToady> pugs: say False ~~ True

[16:44] <p6eval> pugs: OUTPUT«␤»

[16:45] <TimToady> just as Dog{} is a type plus a WHENCE, a constrained type is a type plus a constraint

[16:45] <ruoso> I'd expect the semantics of .does to be the same of $thing ~~ Type

[16:45] <TimToady> True is Bool where { 1 }

[16:46] <pmichaud> smartmatch is syntactically different, though. (more)

[16:46] <pmichaud> 1.does(2)  is different from 1 ~~ 2

[16:46] *** barney joined
[16:46] <jnthn> (second is 2.ACCEPTS(1)

[16:46] <pmichaud> but   1 ~~ 2.WHAT is more like what .does does.

[16:46] <jnthn> )

[16:47] <ruoso> I said $thing ~~ Type

[16:47] <ruoso> pugs: my $a = False; say $a ~~ True;

[16:47] <p6eval> pugs: OUTPUT«␤»

[16:47] <ruoso> pugs: my $a = False; say $a.does(True);

[16:47] <p6eval> pugs: OUTPUT«1␤»

[16:47] <pmichaud> I don't understand the $a ~~ True meme here

[16:47] <pmichaud> True isn't a type.

[16:48] <pmichaud> it's a special case in the smart match table (Bool)

[16:48] <ruoso> right...

[16:48] <TimToady> but subset types are like that, they're named as types, but if you try to use them as a type rather than a constraint, they squirrel off to being their actual base type

[16:48] <TimToady> this idea comes from Ada, actually

[16:49] <pmichaud> not to derail the conversation, but at some point I'd like a clarification on the meanings/dependencies of  .true, .Bool, and .defined

[16:50] <ruoso> rakudo: class Dog {}; my $a = Dog.new; say $a.does(Dog.clone); say $a ~~ Dog.clone

[16:50] <p6eval> rakudo 5a02ee: OUTPUT«1␤1␤»

[16:50] <pmichaud> and I'm guessing that from what TimToady said above, Bool is not an enum any longer?

[16:51] <jnthn> I think Bool is more special than an enum has been established for a while, *but* I'm still not completely clear on exactly what it is either. :-)

[16:53] <pmichaud> I'd really like to get rakudo's booleans straightened up, if only because we get the brokenness illustrated by 16:43 <TimToady> rakudo: say True.WHAT

[16:53] *** eternaleye left
[16:54] <jnthn> *nod*

[16:54] <jnthn> Same.

[16:54] <jnthn> also Rakudo explodes on 0 but True and the like.

[16:54] <TimToady> see http://irclog.perlgeek.de/perl6/2009-04-25#i_1093620

[16:55] <pmichaud> well, let's start with a basic question...  is there a .Bool method on Object (or Any) ?

[16:56] <masak> backlogging over all your .WHO and .WHAT makes it all look like an Abbott and Costello sketch.

[16:56] <pmichaud> Third base!

[16:56] <masak> :)

[16:57] <pmurias> ruoso: i'm not sure how to handle in the RI DSL's pairs of types which know each others internals like Array and ArrayProxy and Mold and MoldFrame

[16:57] <pmichaud> i.e., iiuc, the common way to override stringification is to provide a .Str method.  Does this generalize to .Bool also, or do we keep .true for that?

[16:57] <masak> couldn't we keep the fish =<> as a special term meaning $*IN.get ?

[16:57] <masak> (not an entirely serious suggestion)

[16:57] <pmichaud> masak: when would one use it?

[16:57] <masak> hm.

[16:57] <jnthn> golf?

[16:57] <jnthn> obsfucation?

[16:58] <masak> pmichaud: while =<> { ... }, perhaps.

[16:58] <ruoso> pmurias, pairs of types?

[16:58] <pmichaud> masak: that should probably be   for lines() { ... }

[16:58] <ruoso> pmurias, ah... i see what you mean... I usually call that "community" of types...

[16:58] <TimToady> pmichaud: did you look at my backref?

[16:58] <pmichaud> TimToady: yes, I did.

[16:58] <ruoso> pmurias, you simply allow them to know then internals of each other

[16:59] <pmurias> like %knows?

[16:59] <TimToady> all the boolean contexts call .true, so it's fairly fundamental

[16:59] <masak> pmichaud: aye, probably. I remember being thrown off when starting doing Perl 6 by the fact that looping over input is 'for', not 'while'.

[16:59] <jnthn> TimToady: So essentiall you're saying we have two different mix-in mechanisms?

[16:59] <ruoso> pmurias, just %include "something.h"

[17:00] <pmichaud> TimToady: so, there's not really a .Bool method by default, then?  (that's fine with me if that's the case)

[17:00] <TimToady> we can certainly provide a .Bool that calls .true and returns a Bool enum

[17:00] <pmurias> ruoso: i wander if having the community in the same file wouldn't make sense?

[17:00] <pmichaud> but defining method Bool on a class doesn't really affect its boolean value

[17:00] <pmichaud> (if I understand what you're saying)

[17:00] <TimToady> correct

[17:00] <pmurias> then they could use each other static functions/data

[17:00] <ruoso> pmurias, not necessary

[17:00] <TimToady> and .true may or may not map to a storage bit

[17:01] <TimToady> depending on whether we're using Bool:rw or Boo:ro

[17:01] <pmichaud> okay, a slightly related question -- how does one override numification?

[17:01] <TimToady> I think this rw vs ro thing runs through a lot of other roles too

[17:01] <TimToady> do we want the interface with or without the attributes, basically

[17:02] <TimToady> or maybe, if the accessor is overwritten and doesn't access the storage, we don't allocate it, but that might be hard to compute

[17:02] <pmurias> we will need a directive to disable emitting of the struct declaration if we are going to support the community of types via a .h

[17:03] <ruoso> pmurias, don't need to... just expose functions to access the internals

[17:04] <TimToady> like, there's Positional:rw and Positional:ro, and Associative:rw and Associative:ro

[17:04] <TimToady> give or take a notation or two

[17:04] <pmichaud> okay, I need to re-read the backref with all of this in mind.

[17:05] <jnthn> TimToady: I'm not sure why those two would want to be rw and ro?

[17:05] <jnthn> Since they don't imply a storage mechanism, just an interface contract?

[17:06] <TimToady> as soon as you allocate has Bool $.true it's a storage mechanism

[17:06] <ruoso> maybe it's an interface contract that allows storage decisions

[17:06] <TimToady> or bit, or whatever it is

[17:07] <TimToady> but we don't want $x but True to allocate a bit when it doesn't need to

[17:07] <Tene> enum Bool is also < FileNotFound >;

[17:08] <jnthn> ruoso: Then just do List or Array, which make the storage decision. :-)

[17:08] <TimToady> precisely because Array === Positional:rw

[17:08] <jnthn> erm...huh?

[17:09] <TimToady> okay, back up a step

[17:09] <TimToady> I'm trying to look at all the typish things we've defined so far

[17:09] <jnthn> I had it as role Array[::T] does Positional[T] { ... }

[17:09] <jnthn> (but Range also does Positional, etc)

[17:10] <TimToady> and we've given different names to things that are really the same interface, but with rw characteristics

[17:10] <jnthn> Well, List does Positional too...

[17:10] <jnthn> Which is ro.

[17:11] <TimToady> but the Bool discusion seems to indicate that we *haven't* done that with Bool

[17:11] <TimToady> there's a BoolBit vs a BoolIF

[17:11] <TimToady> we have no way of distinguishing those currently with a single name Bool

[17:12] <pmichaud> what are the two cases there?

[17:12] <pmichaud> I mean, example of BoolBit and example of BoolIf

[17:12] <pmichaud> I can come up with BoolBit

[17:12] <pmichaud> my $x = True;   # BoolBit

[17:12] <pmichaud> or even

[17:12] <pmichaud> my $x = ?(1);

[17:13] <jnthn> I figure when you say does True and does False you just want the methods, but when you say does Bool you want a storage location.

[17:13] <TimToady> it's basic value semantics vs variable semantics

[17:13] <TimToady> immutable vs mutable

[17:13] <TimToady> why do we split some of the names but not others?

[17:13] <jnthn> We could probably get somewhere in that one by saying True and False don't do Bool.

[17:13] <jnthn> But that causes other confusion...

[17:13] <jnthn> Or at least surprise.

[17:13] <TimToady> they don't do Bool:rw, but they do Bool:ro

[17:14] <TimToady> we have a Range with is Range:ro, and a RangeIterator which is Range:rw

[17:14] <jnthn> Where Bool:ro is syntactic sugar for "Bool without its attributes"?

[17:14] <TimToady> or maybe the other way around :)

[17:14] <jnthn> Or would we actually write a separate role Bool:rw { } and role Bool:ro { }

[17:14] <TimToady> I don't know, all I know is we're being very inconsistent

[17:15] <pmichaud> well, let me ask a slightly different one

[17:15] <pmichaud> if I have    "hello" but 42

[17:15] <pmichaud> what is that doing, exactly?

[17:15] <pmichaud> are we doing a :ro versus :rw sort of thing there also?

[17:16] <TimToady> it's a good question

[17:16] <TimToady> by analogy with the but True, I'd say

[17:16] <pmichaud> because I see    "hello" but True     as really being the same sort of thing.

[17:16] <TimToady> that 'but 42' adds an Int:ro role with a .Int method that returns the constant 42

[17:16] <TimToady> or something like that

[17:17] <pmichaud> that constant 42 has to be stored somewhere, yes?

[17:17] *** cj left
[17:17] <pmichaud> so we are talking about storage of something

[17:17] <TimToady> method Int () { return 42 }

[17:17] <pmichaud> okay

[17:17] <pmichaud> so we dynamically build a .Int method for the 42, I can buy that

[17:17] <TimToady> but with Bool it's method .true, seemingly

[17:17] <pmichaud> right, which is why I was asking about .Bool

[17:18] <pmichaud> seems like .Bool ought to be fundamental

[17:18] <jnthn> my $x = 100 but 42; say Int($x); # 42?

[17:18] <pmichaud> (more)

[17:18] <pmichaud> but also going back to another point I asked earlier

[17:18] <pmichaud> if I have   my $x = "hello" but 42;  say Num($x)

[17:18] <pmichaud> # ???

[17:19] <TimToady> well, .Bool and .true could just be the same thing.  It's true() and Bool() that are multis, and on a different level

[17:19] <pmichaud> is it still 0.0 because 42 happened to be an Int?

[17:19] <TimToady> I'd be okay with .Bool being fundamental, if it's more consistent

[17:20] <TimToady> that would depend on how Num() is dispatched, I suppose

[17:20] <TimToady> and what we consider the new type to be, since it's a mixin

[17:21] <ruoso> TimToady, i'd argue that we could require .true to return a native bool

[17:22] *** ejs joined
[17:22] <TimToady> as a runtime mixin, one could argue that the Intliness should override the Strliness

[17:23] <TimToady> on the theory that it's the new anonymous type that does Int directly, but Str is ancestral

[17:24] <TimToady> but it kinda plays havoc with our notion of pseudo-named equivalence

[17:24] <TimToady> we know that $x does Int and we know it does Str

[17:25] <ruoso> TimToady, wasn't that the reason for all the built-in types being Roles?

[17:25] <PerlJam> TimToady: but $x.WHAT is  ... ?

[17:25] <TimToady> nothing is ever "the reason" for anything

[17:25] <TimToady> there's always lots of reasons

[17:25] <TimToady> PerlJam: yes, that's the question

[17:25] <ruoso> so there's no conflict between being both Int and Str

[17:26] <PerlJam> TimToady: well, if we expose the implementation details a little bit, it's  ANONmumble  isn't it ?  :)

[17:26] <TimToady> it *does* both Int and Str

[17:26] * justatheory hands some Str to his ancestors

[17:26] <TimToady> but it *is* still a Str, I think most people would expect

[17:26] <jnthn> I'd expect so too.

[17:26] <PerlJam> I'd expect a string with a hidden stash of Int

[17:26] *** zamolxes left
[17:27] <TimToady> but how hidden?  $x ~~ Int

[17:27] <pmichaud> multi foo(Int $x) { say 'Int'; };  multi foo(Str $y) { say 'Str'; };    foo("hello" but 42)

[17:27] <pmichaud> ambiguous?  if not, which one wins?

[17:27] <PerlJam> pm: I'd expect the latter to win

[17:28] <PerlJam> (right this moment anyway ;)

[17:28] <jnthn> But why?

[17:28] <TimToady> arguably, they're tied

[17:28] <jnthn> If they are both roles, then we do both of them.

[17:28] <jnthn> So I'd expect tied in this case.

[17:28] <PerlJam> because the "but 42" always feels like postit notes to me

[17:28] <TimToady> and you have to say foo(+$x) or foo(~$x)

[17:29] <PerlJam> and postit notes don't change the essence of the thing.

[17:29] <jnthn> PerlJam: It's just simply that it both does Str and does Int so both candidates match.

[17:29] <ruoso> TimToady, I don't think it needs to be hidden at all

[17:29] <jnthn> And Int and Str are tied, thus the candidates are tied, and if you match both it's a tied dispatch.

[17:30] <PerlJam> jnthn: aye, I get what you're saying.  I'm just saying this is what my ape-brain expects.

[17:31] <pmichaud> I'm fine with that being tied.

[17:31] <pmichaud> just was curious about it.

[17:32] <TimToady> since we can argue it both ways, a failed tie is probably the correct answer

[17:32] <TimToady> and then require + or ~

[17:32] <pmichaud> anyway, when thinking about   "... but True"  I tend to want to have it work the same as "... but 42"

[17:32] <pmichaud> "the same" == "using a similar mechanism to"

[17:33] <TimToady> yes, which argues for .Bool (or .bool) being fundamental

[17:33] <jnthn> When you say but True, is it a problem if it always mixes in a storage location too?

[17:33] <pmichaud> does it need to?

[17:33] <pmichaud> i.e., does it need to any more or less than "but 42" does?

[17:33] <TimToady> why not just mix in a method

[17:33] <jnthn> Are we basically saying that...

[17:34] <jnthn> If the thing on the RHS of does is a role, we mix it in.

[17:34] <jnthn> If not, we generate a method of the name of the type of the thing on the RHS that returns that value?

[17:34] <jnthn> Thus $x but 42 => $x but role { method Int { 42 } }

[17:35] <jnthn> Could that work?

[17:35] <jnthn> That'd mean that you don't actually do Int.

[17:35] <jnthn> Which also might resolve the ambiguity problem.

[17:35] <pmichaud> At first blush, I like that.

[17:35] <TimToady> unless it's role Int:ro[42]

[17:35] <jnthn> It does mean that we'd have to make .Bool be the significant one.

[17:35] *** angelixd joined
[17:36] *** masak left
[17:36] <pmichaud> .true has just always felt very odd to me, once .Str and friends were introduced.

[17:36] <PerlJam> Can I mixin any value?  is my $x = $y but $z; perfectly valid?

[17:36] <jnthn> PerlJam: I don't see why not.

[17:36] *** masak joined
[17:37] <jnthn> PerlJam: Since you're just calling infix:does really.

[17:37] <pmichaud> I'd be fine with .true being     method true() { self.Bool }

[17:37] <PerlJam> jnthn: then what happens with  my $x = "hello" but 42;  my $y = 17 but $x;  # What method is created on $y?

[17:37] <jnthn> TimToady: I'm not too convinced yet by the :rw and :ro variants of roles.

[17:38] <jnthn> .WHAT gives Str, so you get a method Str { $y }

[17:38] <TimToady> well, at the moment we're making a fundamental distinction between 'but True' vs 'but Bool'

[17:38] <jnthn> OK, but with what I'm suggesting but True and but 42 are completely analogous.

[17:38] <PerlJam> jnthn: so, no matter how many things are mixed in, the value always keeps the "original type"?

[17:39] <ruoso> I wonder if there could be a way for we to stablish precedence in the object in order to pre-solve ties

[17:39] <ruoso> without require stringification or numification

[17:39] <jnthn> $x but True becomes $x does role { method Bool { True } } because True.WHAT stringifies to Bool.

[17:40] <jnthn> All you're doing is saying the way that you T-ify.

[17:40] <TimToady> well, this is all very simple in Ruby where everything is single inheritance and duck typing :)

[17:40] <jnthn> TimToady: Was that to me or ruoso?

[17:40] <TimToady> it was to the world at large

[17:40] <jnthn> If to me I didn't get the point...

[17:41] <jnthn> TimToady: All we're relying on here is that things do have some distinct type.

[17:41] <jnthn> PerlJam: Yes, that's what I'm essentially proposing.

[17:41] <TimToady> the point is that ruby doesn't do anything like role-based multiple dispatch, or even MI

[17:41] * skids looks up duck typing, guessing it has nothing to do with mallards.

[17:41] *** |Jedai| left
[17:42] <PerlJam> jnthn: and so ... how do you get at the 42ness of $x through $y?  Or does $y lose the 42ness?

[17:42] <TimToady> but in SI, the type is biased toward the derivative, not the parent

[17:42] <TimToady> so I'm leary of biasing toward the parent

[17:43] <jnthn> TimToady: The way I'm defining this is that you effectively are mixing in an anonymous role, and thus since in multi-dispatch you name things, it doesn't really play into it.

[17:43] <jnthn> PerlJam: It'd keep it, since the method that is generated would just return the exact value that is on the RHS of the does.

[17:43] *** masak left
[17:43] <jnthn> PerlJam: We just care about the original type for its name.

[17:44] <TimToady> if it's an anonymous role then $x ~~ Int would return false, which also seems bogus

[17:44] <PerlJam> jnthn: so, to get at the 42 that $x brought to $y, it would be  $y.Str.Int  ?

[17:44] <jnthn> TimToady: If you explicitly mixed in a role, e.g. $x does Int(42), you'd do Int.

[17:44] *** masak joined
[17:44] <[particle]2> $x.can(Int) is true, though

[17:45] *** [particle]2 is now known as [particle]-

[17:45] <jnthn> [particle]-: Yes, that's true.

[17:45] <jnthn> TimToady: But that'd also get you the storage location.

[17:46] <TimToady> well, we do want some way to do that, even to making .Int = 43 work sometimes

[17:47] <jnthn> TimToady: Sure; I saw $x does Int(42); $x.Int = 43; as working.

[17:47] <PerlJam> "sometimes"?  How would you designate those times?

[17:47] <jnthn> TimToady: But $x does 42; $x.Int = 42; would not.

[17:47] <PerlJam> (or, how do you force the ro-ness)

[17:47] <TimToady> I can imagine adding a $.Int that isn't rw

[17:47] <jnthn> Since in the first you have asked to fix in a storage location and initialized.

[17:47] <TimToady> but we don't have syntax for it

[17:47] *** ZuLuuuuuu joined
[17:48] <TimToady> unless you write the role yourself

[17:48] <jnthn> And in the second you have asked to mix in a method that returns a value.

[17:48] <[particle]-> does it need to be easy?

[17:48] <jnthn> TimToady: When would you (commonly) want the storage *and* ro-ness?

[17:48] <TimToady> I think add a .Int value and a .Int rw var are the two common desires

[17:49] <TimToady> adding a .Int ro var seems like something nobody will want to do

[17:49] <[particle]-> until you disallow it.

[17:49] <jnthn> Right, and if they do, they can go scribble their own role and mix in it. :-)

[17:49] <TimToady> having a ro var seems a bit perverse to me

[17:49] <TimToady> when you're already forcing it from the outside

[17:50] <TimToady> and nothing inside the old object knows how to change it anyway

[17:50] <jnthn> Aye.

[17:50] <TimToady> so Int(42) vs 42 seems reasonable

[17:51] <TimToady> or maybe Int{42} is more like what's going on

[17:51] <TimToady> if WHENCE took positionals...

[17:51] <jnthn> Well, either is syntactic sugar.

[17:51] <jnthn> So far as S14 defines it.

[17:51] <TimToady> trew

[17:52] <jnthn> does RoleName(thingy) isn't really a postcircumfix:<( )> on the role.

[17:52] <TimToady> okay, seems like we're achieving some kind of consensus, or at least mutual confusion

[17:52] <PerlJam> so,  Int(42) vs 42 is the same as Bool vs True  ?

[17:52] <jnthn> PerlJam: Or Bool(True) to initialize it, but yes.

[17:52] <TimToady> yes

[17:53] <jnthn> OK. This is feeling reasonably sane to me.

[17:53] <TimToady> and 'but Int' is short for 'but Int(Int)'

[17:53] <PerlJam> it makes enough sense for me  (as least I feel like I understand it :)

[17:53] <jnthn> *nod*

[17:54] * TimToady can die in peace now

[17:54] * jnthn can dine in peace now

[17:54] <[particle]-> VesselWithPestle(PelletWithPoison)

[17:54] *** wollmers joined
[17:54] <PerlJam> I guess that means the perl6 design is complete.

[17:54] <jnthn> TimToady: Do you want me to write this into S14 after dinner, or shall I leave it to you?

[17:54] *** masak left
[17:54] <TimToady> can't be, wolmers++ just joined  :)

[17:55] <TimToady> go ahead and scribble

[17:55] <jnthn> OK. I'm going to go ahead and eat first. ;-)

[17:55] <TimToady> *wollmers++

[17:55] <TimToady> sorry

[17:55] <wollmers> Good UTC evening;-)

[17:56] *** masak joined
[17:56] *** barney left
[17:56] <TimToady> wollmers: did you send those messages to p6l or just to me?

[17:57] <TimToady> they haven't shown up there yet, is all

[17:57] <TimToady> (haven't really had time to think about them yet)

[17:57] * jnthn -> dinner, be back in a little bit

[17:58] <pmichaud> lunch

[17:58] <TimToady> likewise lunch, still about on Mountain Time biologically...

[17:59] <jnthn> I'm a couple of timezones west too...

[18:02] *** alanhaggai left
[18:04] <wollmers> TimToady: Ooops, mistake. They were targeted for p6l ...

[18:05] <pmichaud> wollmers: I noticed your messages to me were just to me also, fwiw.

[18:05] <pmichaud> (thank you for them, btw)

[18:06] <pmichaud> really lunch

[18:08] *** Util left
[18:08] *** p6paste joined
[18:09] <literal> hm

[18:09] *** p6paste left
[18:12] *** FurnaceBoy joined
[18:16] *** cj joined
[18:16] *** abra left
[18:20] *** bkeeler joined
[18:21] *** frew|work joined
[18:22] *** bkeeler left
[18:22] *** bkeeler joined
[18:23] <wollmers> pmichaud: Sorry, the usual Reply-Button problem ...

[18:29] *** wollmers left
[19:04] *** FurnaceBoy left
[19:05] * masak wonders what it would take to implement the Quantum Fourier transform in Perl 6

[19:11] <mikehh_> \quit

[19:12] *** mikehh_ left
[19:18] *** ZuLuuuuuu left
[19:21] <meppl> good night

[19:22] *** meppl left
[19:29] *** masak left
[19:52] *** masak joined
[19:53] <jnthn> masak: Implemented that quantum fourier transform yet? ;-)

[19:53] <masak> jnthn: no, but I'm intrigued by the thought.

[19:54] <masak> jnthn: I actually know the perfect book for learning more about QC. I haven't gotten that far through it, but I can tell it's really good.

[19:54] <masak> I borrow it from the university library sometimes and get a few pages further.

[19:54] <masak> it's like yoga for the mind.

[19:55] <jnthn> :-)

[19:56] <masak> http://www.amazon.ca/Quantum-Computation-Information-Michael-Nielsen/dp/0521635039 # that's the book

[20:00] <jnthn> Seems from the reviews its well liked.

[20:00] <masak> far as I understand, it's _the_ introduction to the field.

[20:06] *** M_o_C joined
[20:22] <masak> rakudo: $*IN.get.say

[20:22] <p6eval> rakudo 5a02ee: OUTPUT«␤»

[20:23] *** [particle]1 left
[20:24] *** jhorwitz left
[20:30] <pugs_svn> r26588 | masak++ | [evalbot.pl] now feeds the Austrian national anthem

[20:30] <pugs_svn> r26588 | masak++ | on STDIN to elf and Rakudo

[20:35] <masak> rakudo: $*IN.get.say

[20:35] <p6eval> rakudo 5a02ee: OUTPUT«␤»

[20:35] * masak waits a little longer

[20:36] <mberends> was that the lyrics, or the soundtrack?

[20:36] <pmichaud> The remix.

[20:37] <mberends> ah, the transform

[20:37] <pmichaud> Although I wonder if the RIAA will be coming after masak++ now.  :-P

[20:38] <masak> I'd better hurry up with that Quantum Fourier Transform before they knock down my door.

[20:38] <masak> rakudo: $*IN.get.say

[20:38] <p6eval> rakudo 5a02ee: OUTPUT«␤»

[20:38] <masak> hrm.

[20:39] <masak> my commit has gone in, but something isn't working, it seems.

[20:39] *** ZuLuuuuuu joined
[20:40] <masak> oh.

[20:40] * masak slaps forehead

[20:41] <pugs_svn> r26589 | masak++ | [evalbot.pl] forgot quotes in last commit

[20:42] <masak> though the more I think about it, the more I doubt that this was the actual cause of things not working.

[20:44] *** pmurias left
[20:44] *** ruoso left
[20:45] *** bkeeler left
[20:47] <masak> rakudo: $*IN.get.say

[20:47] <p6eval> rakudo 5a02ee: OUTPUT«␤»

[20:47] <masak> :/

[20:48] <masak> rakudo: lines($*IN).elems.say

[20:48] <p6eval> rakudo 5a02ee: OUTPUT«2␤»

[20:48] <masak> rakudo: lines($*IN).perl.say

[20:48] <p6eval> rakudo 5a02ee: OUTPUT«["", ""]␤»

[20:49] <skids> evalbot should slurp the IRC log on stdin :-)

[20:49] <masak> skids: :)

[20:51] * masak gives up

[20:52] <masak> as far as I can see, my commit should have desired effect. and I have limited means to debug p6eval. guess I'll just wait for moritz_++ to return.

[20:54] <masak> what was the other thing I promised to do? oh yeah -- patch Match.

[20:56] <masak> std: return 42

[20:56] <p6eval> std 26589: OUTPUT«ok 00:02 35m␤»

[20:56] <masak> std: return [~] gather {}

[20:56] <p6eval> std 26589: OUTPUT«ok 00:02 37m␤»

[20:56] <masak> std: return [~] gather {␤}

[20:56] <p6eval> std 26589: OUTPUT«ok 00:02 37m␤»

[20:58] <masak> pmichaud: so, changing Match.perl to say 'Str' instead of 'text'. is it ok if I change just Match.pm, and not the underlying PGE::Grammar? or should I change the latter as well?

[21:02] *** DemoFreak joined
[21:03] *** [particle] joined
[21:11] *** bkeeler joined
[21:18] *** Whiteknight joined
[21:25] *** kidd left
[21:31] *** skids left
[21:41] <pugs_svn> r26590 | jnthn++ | [spec] Update S14 with new semantics for when a value appears on the RHS of a runtime mix-in operator (C<does> or C<but>), as discussed on #perl6 earlier today. Also a typo fix and a couple of headings to break the document into more managable chunks.

[21:46] <jnthn> pmichaud: And as the above commit notes, Bool can actually stay as an enum now. :-)

[21:47] *** [particle] left
[21:58] <masak> pmichaud: oh! if I'm reading PGE/Match.pir correctly, .text is already just an alias for .Str -- which means that I can call .Str directly on the Match object.

[21:58] * masak tries

[22:00] <pmichaud> masak: I've already converted PGE::Match to use .Str and the other items

[22:00] <pmichaud> just haven't gotten rid of the old ones yet -- wanted to give the other Parrot languages some time to migrate.

[22:00] <masak> nice.

[22:01] <masak> pmichaud: I've realized that I want to blog a review on PGE as well. I will probably do that after I review the spectest suite.

[22:01] <pmichaud> excellent.

[22:02] <masak> it was your comment about it being relatively small despite being all PIR that got me interested.

[22:02] *** eric256 left
[22:03] *** alester left
[22:04] *** iblechbot left
[22:08] *** [particle] joined
[22:10] *** km2 left
[22:17] * jnthn gets his YAPC::EU talks submissions done Just In Time.

[22:19] <pmichaud> (roles)  I'm not sure that "stringifying WHAT" is the right answer here, fwiw.

[22:22] <jnthn> No, it's a good approximation.

[22:22] <jnthn> But yeah, not spot on since they have () on the end I guess.

[22:23] *** ejs1 joined
[22:24] <jnthn> How would you write it better?

[22:24] *** [particle] left
[22:25] <jnthn> I guess it's something like "get the WHAT and then grab its shortname"?

[22:25] *** c9s_ joined
[22:28] *** M_o_C left
[22:29] <jnthn> I guess I can always implement it tomorrow and see what I end up using and patch the spec. ;-)

[22:36] <masak> rakudo: subset FooStr of Str where /^foo/; multi method trim(FooStr $self:) { return "OH HAI" }; say "foo".trim

[22:36] <p6eval> rakudo d4921c: OUTPUT«sh: ./perl6: No such file or directory␤»

[22:36] <jnthn> fail

[22:36] <masak> is it that time of the hour?

[22:36] <masak> or did I break something? :/

[22:37] <jnthn> or half hour...hmm

[22:37] *** breinbaas joined
[22:37] <pugs_svn> r26591 | lwall++ | get rid of the term "protoobject" in favor of "type object" or just "type"

[22:37] <pugs_svn> r26591 | lwall++ | get rid of redundant and confusing Number: lines

[22:37] <jnthn> You and your Austrian national anthem. :-)

[22:38] <TimToady> note that .perl returns the name without ()

[22:38] *** [particle] joined
[22:38] <masak> jnthn: referring to what, the p6eval breakage, or the fact that TimToady is now renaming "proto"? :)

[22:38] <TimToady> or should

[22:38] <jnthn> TimToady: Ooh, .WHAT.perl

[22:38] <masak> rakudo: subset FooStr of Str where /^foo/; multi method trim(FooStr $self:) { return "OH HAI" }; say "foo".trim

[22:38] <p6eval> rakudo d4921c: OUTPUT«sh: ./perl6: No such file or directory␤»

[22:38] * jnthn patches

[22:39] *** c9s left
[22:39] <jnthn> masak: Well, given you were hacking up p6eval to make Rakudo sing the Austrian national anthem... :-P

[22:39] * jnthn glances at the English translation of the lyrics

[22:39] <jnthn> "let us swear in unity"

[22:39] <masak> jnthn: it seemed like a good idea at the time...

[22:40] * jnthn invites the channel to swear in unity at masak ;-)

[22:40] <jnthn> (Only in German. ;-))

[22:40] <masak> look at it this way: things can only get better from here...

[22:41] <jnthn> :-)

[22:41] <TimToady> I dunno, there's always the French anthem...

[22:42] <masak> I'm not sure the actual choice of anthem is the problem with p6eval...

[22:43] <jnthn> Note so bad as Liechtenstein, who did write their own words but took the tune of the British one. ;-)

[22:43] <TimToady> $*IN.pick.say

[22:43] <masak> $*IN has .pick ? :)

[22:43] <TimToady> well, there's only maybe six or seven college songs in the U.S., melodywise...

[22:44] <TimToady> my highschool song was actually to the tune of Anchors Aweigh

[22:44] <TimToady> but then, Bremerton is a navy town, so it made sense

[22:46] <TimToady> masak: we have a phrase, "pick your poison"  :)

[22:46] <jnthn> TimToady: What do you think about getting list context and hash context be .List and .Hash instead of .list and .hash so they match other "get my thingy" calls?

[22:46] <TimToady> most anthems are pretty poisonous, in my experience :)

[22:46] <masak> seems so.

[22:48] *** skids joined
[22:49] <TimToady> jnthn: I dunno, it's not like we can't huffmanize on the Shift key occasionally when there's no conflict with a native type...

[22:49] <jnthn> TimToady: I'm thinking about

[22:49] <pugs_svn> r26592 | jnthn++ | [spec] .WHAT stringified gives back TypeName() so use .WHAT.perl to get just TypeName (pmichaud++, TimToady++).

[22:49] <jnthn> $x but list(1,2,3)

[22:49] <jnthn> $x but { a => 1, b => 2 }

[22:50] <jnthn> Which would generate .List and .Hash methods...

[22:51] <jnthn> oh, hmm...that list there on the RHS would flatten I suspect

[22:51] <jnthn> And end up as if I'd written $x but 1,2,3

[22:51] <masak> ok rakudo isn't building because of this make error:

[22:51] <masak> make: *** No rule to make target `src/parrot/misc.pir', needed by `perl6_s1.pbc'.  Stop.

[22:51] <jnthn> Which is an error.

[22:51] <TimToady> eh?  but binds tighter than ,

[22:51] <jnthn> oh, sorry

[22:51] <jnthn> I meant but (1,2,3)

[22:52] <TimToady> it gets coerced back to an item in any case

[22:52] <jnthn> Which would be an error.

[22:52] <jnthn> What about this case:

[22:52] <jnthn> You can also mixin a precomposed set of roles:

[22:52] <jnthn> $fido does (Sentry, Tricks, TailChasing, Scratch);

[22:53] <TimToady> special syntax, I think

[22:53] <jnthn> Is that a special syntactic form?

[22:53] <jnthn> OK.

[22:53] <jnthn> So 42 but list(1,2,3) is different to 42 but (1,2,3)

[22:53] <TimToady> yeah

[22:53] <jnthn> Nice.

[22:53] <TimToady> or not

[22:54] <jnthn> We can *almost* squeeze contextual return out of this...

[22:54] <jnthn> (Which is why I asked about the .list vs .List)

[22:55] <TimToady> not entirely clear if .list and .List mean the same thing yet

[22:56] <TimToady> might be a de jure vs de facto distinction there

[22:56] <TimToady> like the difference between interpolation of @$foo vs $foo non-interpolation

[22:57] <jnthn> Hmm, true.

[22:57] <TimToady> context is not strictly OO in perl

[22:57] <jnthn> tbh the whole "oh wows we can haz contextual return with this" was more an afterthough when trying to nail down all of the semantics (or at least not miss too many)...

[22:57] <jnthn> *afterthought

[22:58] <TimToady> contextual return is not a panacaea if it involves cloning a bunch of closures that will go unused

[22:58] <jnthn> I figured I should define what 0 but (x, y) where x and y ain't roles was, since the semantics are defined for when they are roles.

[22:58] <jnthn> Sure.

[22:58] <jnthn> Perhaps we shouldn't be encouraging this way. :-)

[22:58] *** nihiliad left
[22:59] <masak> ok, my local Rakudo doesn't build either.

[22:59] <TimToady> well, but (1,2,3) would give you a collision like (True,False)

[23:00] *** hanekomu joined
[23:00] <masak> I'm compiling it with a bleeding-edge Parrot. can anyone confirm?

[23:00] * masak checks Parrot commit log in the meantime

[23:02] <jnthn> TimToady: Yes.

[23:02] <masak> pmichaud: found it! your 5f0765da broke Rakudo.

[23:02] <jnthn> TimToady: Thus why I wondered if but list(1,2,3) was different.

[23:02] <masak> trying the obvious fix.

[23:03] *** ejs1 left
[23:03] *** Limbic_Region joined
[23:03] *** orafu left
[23:03] <jnthn> And there we were blaming it on Austria's anthem...

[23:03] *** orafu joined
[23:04] <masak> what were we thinking?

[23:04] <masak> Austria's anthem: come back. all is forgiven.

[23:05] *** ejs1 joined
[23:05] <masak> yah, now it builds. committing.

[23:06] <TimToady> maybe you should try Edelweiss instead and see if it works better...

[23:06] *** [particle] left
[23:06] <jnthn> rakudo: say $*IN.get

[23:06] <p6eval> rakudo d4921c: OUTPUT«sh: ./perl6: No such file or directory␤»

[23:06] <jnthn> ah, too soon

[23:07] <TimToady> I note, however that STD doesn't actually parse 'but' as a special form

[23:07] <masak> there, pushed.

[23:07] <jnthn> Rakudo doesn't parse it as a special form exactly, but it handles does Foo(42) for example specially

[23:08] <masak> but I'm getting a compile error later in the build process... :/

[23:08] <masak> perhaps due to the missing file. I dunno.

[23:08] <TimToady> but that's just a coercion of 42 to Foo

[23:08] <jnthn> ?

[23:08] <TimToady> which is why I was thinking of using Foo{42} instead

[23:08] <jnthn> $x does Foo(42) is ($x does Foo).Foo = 42 or something, right?

[23:09] <TimToady> yes, but how do you tell it was a coercion and set of rw?

[23:09] <TimToady> vs a bare Foo literal, whatever that is...

[23:09] <TimToady> how do we distinguish Int(42) from 42

[23:09] <jnthn> Syntax?

[23:10] <TimToady> not if it's not a special form

[23:10] <TimToady> but Int{42} could be lazy coercion

[23:10] <jnthn> OK, my point was it doesn't need to be parsed as a special form, the semantic analyzer can deal with it.

[23:10] <jnthn> That's how Rakudo handles it.

[23:10] <jnthn> Just treats the RHS of does and but specially.

[23:11] <TimToady> well, that's a possibility, but there could be other uses for Int{42}

[23:11] <TimToady> not to mention List{1,2,3}

[23:11] <jnthn> On the RHS of does and but?

[23:12] <jnthn> Hmm

[23:12] <TimToady> no, just other places where a positional WHENCE makes some kind of sense

[23:12] *** orafu left
[23:13] <jnthn> At the moment I'm essentially treating the 42 in $x does Int(42) as a kind of "and initialize with this" adverb to infix:<does>

[23:13] *** orafu joined
[23:14] <jnthn> Changing the syntax to Int{42} wouldn't make a huge difference and yes, I can see the analogy with WHENCE.

[23:14] <jnthn> And it means List(...) isn't ambiguous.

[23:15] <jnthn> So sounds sane...

[23:15] <masak> I'm going to bed now. there's a build error originating in src/parser/actions.pm.

[23:15] <TimToady> night

[23:15] <masak> Method 'ast' not found for invocant of class 'ResizablePMCArray'

[23:15] <masak> good night.

[23:15] <jnthn> night masak, see you tomorrow

[23:15] <masak> Rakudo day tomorrow! \o/

[23:15] <masak> hope it builds by then. :P

[23:15] * jnthn feels expectation pressure

[23:16] <jnthn> Yeah me too ;-)

[23:16] * masak sleeps

[23:16] *** masak left
[23:16] <TimToady> never happens to me.. ;)

[23:17] <jnthn> TimToady: So anyways, no opposition (and I think support...but I'm tired...) on changing to { } for the initialization value.

[23:17] <TimToady> well, something to think about, anyhoo

[23:17] <jnthn> Aye.

[23:18] <pmichaud> (broke rakudo).... checking

[23:18] <jnthn> I'll have a crack at getting the new stuff that went into S14 today into Rakudo tomorrow.

[23:18] <TimToady> and simplifies the run-time decision to "is it defined yet"

[23:18] <TimToady> if not defined, is rw, if is defined, is ro

[23:18] <jnthn> So we can play with it and see how it feels.

[23:18] <jnthn> Oh, hmm, that's a neat distinction.

[23:19] <jnthn> I was just going to say "is it a role"

[23:19] <jnthn> Oh hmm...so what about $x does SomeProtoObjectHere ?

[23:19] <pmichaud> oh yes, I forgot to add the file.

[23:19] <pmichaud> adding.

[23:20] <pmichaud> funny, the missing file doesn't show up when I do 'git status'

[23:20] <TimToady> is undefined, so adds SomeProtoObject slot with undef value, which happens to also have the type SumeProtoObject

[23:20] <TimToady> for same speeling or other

[23:20] <TimToady> but Foo turns into but Foo[Foo]

[23:20] <TimToady> Foo{Foo} rather

[23:21] <TimToady> if we end up with the WHENCE solution

[23:21] <jnthn> So in that case we generate a role { has Foo $.Foo } ?

[23:21] <TimToady> Foo is already a role, so we just use it

[23:21] <jnthn> Or a role { method Foo() { return Foo } } ?

[23:22] <jnthn> I was saying what if Foo isn't a role?

[23:22] <jnthn> class Foo { }; $x does Foo

[23:22] <pmichaud> my question is more along the lines of

[23:22] <TimToady> ah, well, we take an immutable snapshot, is what I've said in the past

[23:22] <pmichaud> my $x = MyInt.new;   $x = 42;   "hello" but $x

[23:22] <pmichaud> does that change the Int semantics of "hello" ?

[23:23] <jnthn> pmichaud: No.

[23:23] <pmichaud> okay, so we can use 'but' to affect values only for the natively coerced types

[23:23] <pmichaud> I'm fine if that's the case

[23:23] <TimToady> point is that $x is defined, so uses value override only

[23:24] <jnthn> pmichaud: You'd get a .MyInt mixed into the cloned "hello" though

[23:24] <TimToady> and value override doesn't affect the type of "hello"

[23:24] <pmichaud> also, I'm curious if   ~(Int.WHAT)  eventually ends up being   "CORE::Int()" instead of just "Int()"

[23:25] <pmichaud> I guess I"m asking if that sort of "but override" would affect +("hello" but $x)

[23:25] <pmichaud> I was also curious earlier about what happens with  ("hello" but 42).perl ..... but I'll leave that for another day :-)

[23:25] <jnthn> I thoguht .WHAT stringified to short name, and .WHO to long name?

[23:25] <pmichaud> "short name" means more like "generic name", not "last component"

[23:26] <jnthn> pmichaud: It's going to just dispatch to .perl on Str, as currently defined.

[23:26] <pmichaud> i.e., as opposed to something like   Int:auth<...>:ver<...>

[23:26] <pmichaud> (if I'm reading the spec right, at least)

[23:26] <jnthn> I think the spec has changed on that at some point too...

[23:26] <TimToady> well, all of these short names are presumably lexically aliased to the long name

[23:27] <jnthn> rakudo: class Foo::Bar { }; say Foo::Bar.WHAT

[23:27] <p6eval> rakudo d4921c: OUTPUT«sh: ./perl6: No such file or directory␤»

[23:27] <pmichaud> yes, but does the protoobject know its short name?

[23:27] <pmichaud> (just pushed fix so that perl6 hopefully builds again)

[23:27] <jnthn> pmichaud: In Rakudo, yes. ;-)

[23:27] <pmichaud> jnthn: no, currently   what you just gave will produce  "Foo::Bar()"

[23:27] <TimToady> its .perl should know it, I think

[23:28] <pmichaud> (yes, it used to give just "Bar", but with the recent changes it now produces "Foo::Bar()")

[23:28] <jnthn> pmichaud: OK, that's changed since last time I tried it.

[23:28] <jnthn> BTW, why are the () on there?

[23:28] <jnthn> I never quite caught onto the reasoning for that...

[23:28] <pmichaud> TimToady: so, .perl needs to be able to produce a protoobject's name relative to the lexical scope of .perl's caller?

[23:29] *** mizioumt1 joined
[23:29] <pmichaud> jnthn: it's to avoid

[23:29] <pmichaud> my Int $x;  say ~$x;   # "Int"

[23:29] <pmichaud> the parens are meant to indicate it's a little special

[23:29] <jnthn> Ah, OK.

[23:29] <TimToady> it's to avoid confusing data with metadata, basically

[23:29] <jnthn> OK, makes sense.

[23:29] <TimToady> and it happens that if you eval "Int()", you end up with Int anyway

[23:30] <jnthn> o rly?

[23:30] <TimToady> since empty coercion is defined to return the type object undefined

[23:30] <jnthn> Ah, OK.

[23:30] <jnthn> Is co-ercion a special syntactic form, or just postcircumfix:<( )>?

[23:30] <TimToady> Nil coerced to Anything is Anything, I guess you might say

[23:31] <pmichaud> so, back to my earlier question

[23:31] <TimToady> just postcircum

[23:31] <pmichaud> class MyInt is Int { ... };   my $x = MyInt.new;  $x = 42;  say +("hello" but $x);   # 0 ?

[23:31] <jnthn> TimToady: Just defined on proto-objects?

[23:32] <jnthn> TimToady: And other type-ish things?

[23:32] <pmichaud> although I guess that $x = 42 step doesn't do what I mean

[23:32] <pmichaud> so

[23:32] <TimToady> what's a protoobject?  :P

[23:32] <jnthn> type object :-P

[23:32] <pmichaud> class MyInt is Int { ... };   my $x = MyInt.new(42);  say +("hello" but $x);   # 0 ?

[23:32] <jnthn> pmichaud: Yes, as currently spec'd.

[23:33] <pmichaud> I'm okay if the result of the above is 0... just want to make sure that's the intent.

[23:33] *** ejs1 left
[23:33] <jnthn> pmichaud: And I can't see a clean way of making that do otherwise.

[23:33] <pmichaud> and it's partially why I'm wondering if "stringify type to build method" is correct.

[23:33] <TimToady> however, but MyInt{$x} is potentially a different matter

[23:34] <TimToady> since it's a proto^Wtype object with a WHENCE

[23:34] <pmichaud> and there's also    class Foo::Int { ... };   $x = Foo::Int.new;   +("hello" but $x);   # changed numification?

[23:34] <jnthn> Right. Then it is up to whatever is defiend by MyInt.

[23:34] <TimToady> so we might do something more official with the type mixin

[23:35] <TimToady> something more like MI

[23:36] <TimToady> or like official composition

[23:36] <jnthn> pmichaud: By CORE::Int gives us .Int I'd venture a yes to that one...

[23:36] <TimToady> anyway, it may be one of those "doctor it hurts when I do this" sort of things, at least until we think of something more consistent

[23:37] <pmichaud> anyway, I have to join family for dinner... but it just seems to me that stringifying the type to produce the method name of the mixin is akin to testing type identity by doing   $x.WHAT eq 'Int'

[23:37] <pmichaud> i.e., it's putting too much emphasis on the name.

[23:38] <pmichaud> (especially since names, as we've seen, aren't always what we expect them to be)

[23:38] <TimToady> sure, but what's the identity of a mixin then?

[23:38] <pmichaud> I don't know.

[23:39] <TimToady> would be simple if we weren't doing MI and multiple dispatch :)

[23:39] <pmichaud> I'm only raising the flag so that the snipers can shoot it down and I can later say "okay, I raised the flag"  :-)

[23:39] <TimToady> yes, it's a valid and strong point, but I don't think any of us are smart enough to figure it out tonight. :)

[23:39] <pmichaud> agreed.

[23:39] <pmichaud> I think that's exactly what I'm saying, in fact.

[23:39] <jnthn> Aye.

[23:40] <TimToady> do don't do that.  :)

[23:40] <TimToady> *so even

[23:40] <pmichaud> just that I noticed some things didn't quite smell right and so I'm alerting others to the possible smell.

[23:40] <TimToady> gah, blow my own punchline...

[23:40] <jnthn> In the meantime, we have something that's good enough and resolves the "how to sort out booleans".

[23:40] <pmichaud> jnthn: yes, until it doesn't.  :-)

[23:41] <TimToady> junctional types, here we come...

[23:41] <pmichaud> but it did also occur to me earlier that   ~(Int.WHAT)  may start producing "CORE::Int()"

[23:41] <pmichaud> since we're really talking about CORE::Int as the type.

[23:41] <jnthn> TimToady: Those are nasty.

[23:41] <TimToady> unless someone has hidden it. :)

[23:42] <TimToady> jnthn: you're tellin' me...

[23:42] <pmichaud> jnthn: it *also* occurred to me that since all of our types are really in "CORE::", we might end up avoiding conflicts with Parrot class names anyway :-P

[23:42] <jnthn> TimToady: I'm really worried about issues surrounding type identity and all sorts if we go down that road.

[23:42] <jnthn> TimToady: And hwo we'd define narrowness, which isn't unrelated to that.

[23:43] <TimToady> yes, well, if we solve it, we probably solve world hunger at the same time, not to mention global warming

[23:43] <TimToady> we'll just have to evolve it as we go on, assuming we haven't boxed ourselves into a corner

[23:43] <pmichaud> agreed, I'm a bit concerned about the box-into-a-corner part.

[23:44] <TimToady> and that depends on which people run into which pain points first, and loudest, I suppose

[23:44] <jnthn> For junctional types, we reserved the syntax.

[23:45] <jnthn> tbh I just don't think the returns of dealing with those in 6.0.0 are worth the returns.

[23:45] <TimToady> but changing the semantics of 'but Int(42)' to junctional or MI or whatever is a possible danger point

[23:45] <TimToady> if it ignores the Int type initially and people depend on it

[23:45] <jnthn> What exactly are you thinking it will do?

[23:46] *** mizioumt1 left
[23:46] <TimToady> eventually, something more like a real mixin

[23:46] <jnthn> I ddn't see that case ignoring the Int type.

[23:46] <jnthn> That takes the Int role, mixes it in and initializes the single attribute resulting from the mix-in.

[23:46] *** orafu left
[23:46] <TimToady> where there's a new anon type that *does* Int but isa something else that does Str

[23:46] <jnthn> Which is different from but 42

[23:47] *** orafu joined
[23:47] *** nbrown left
[23:47] <jnthn> That's already how such things work though?

[23:47] <TimToady> question is how $x then dispatches to ambig Int vs Str

[23:47] <jnthn> With an ambiguity if you do it like that.

[23:48] <TimToady> well, Int might be considered exact match because it's via does, while Str might be inexact since it's via isa

[23:48] <TimToady> from the viewpoint of the new anon type

[23:48] <jnthn> And the $x but 42 syntax did something different to avoid the ambiguity issue.

[23:48] <jnthn> Well, thing is, I was thinking we'd bias towards the isa rather than the does-a, so hmm.

[23:49] <TimToady> yes, it just mixed in the method without the role

[23:49] <jnthn> Right.

[23:49] <TimToady> well, with an anon role that isn't related to Int

[23:49] <jnthn> Sure.

[23:49] <jnthn> For constants we can generate one role and re-use it too.

[23:49] <TimToady> so it *might* just fall out of what we're already doing

[23:49] <jnthn> Yeah. The name issues that pmichaud mentioned are the main concern with this approach.

[23:49] *** mberends left
[23:49] <TimToady> and the actual downstream tweaks are how we calculate type distance

[23:50] <TimToady> which will be painful regardless

[23:50] *** mberends joined
[23:51] <jnthn> I currently have things very neatly falling out of .ACCEPTS on the narrowness calculations.

[23:51] <jnthn> I kinda like that because it's, well, neat.

[23:51] <jnthn> And easy to explain.

[23:51] <jnthn> Starting to stick is-a vs does-a stuff into there makes me worry that we're going to end up making it Too Magical.

[23:51] <pmichaud> But it insufficiently torments the implementors. :-)

[23:52] <jnthn> pmichaud: Well, to me being able to explain Perl 6's MMD as "it's just X" is kinda nice too...

[23:52] <pmichaud> jnthn: agreed.  :-)

[23:52] <TimToady> hmm, both Int and Str presumably supply a .Num coercion, which is ambiguous by composition, but with the extra isa of a mixin, isn't

[23:53] <TimToady> any way I argue it, it seems to me that +("foo" but Int(42)) should probably call Int's .Num rather than Str's .Num

[23:53] *** cj left
[23:53] *** SamB left
[23:53] *** antiphase left
[23:53] *** moritz_ left
[23:53] *** patmat left
[23:53] *** presh left
[23:53] *** PacoLinux left
[23:53] *** bkeeler left
[23:53] *** jeremiah_ left
[23:53] *** baest left
[23:53] *** c1sung left
[23:53] *** pdc303 left
[23:53] *** gbacon left
[23:53] *** integral left
[23:53] <TimToady> at that point it's just single dispatch

[23:54] *** moritz_ joined
[23:54] *** cj joined
[23:54] *** SamB joined
[23:54] *** PacoLinux joined
[23:54] *** patmat joined
[23:54] *** presh joined
[23:54] *** antiphase joined
[23:54] *** irc.freenode.net sets mode: +o moritz_

[23:54] *** hanekomu left
[23:54] *** bkeeler joined
[23:54] *** jeremiah_ joined
[23:54] *** arnsholt joined
[23:54] *** StephenPollei joined
[23:54] *** baest joined
[23:54] *** c1sung joined
[23:54] *** pdc303 joined
[23:54] *** gbacon joined
[23:54] *** jiing joined
[23:54] *** krunen joined
[23:54] *** integral joined
[23:54] <jnthn> TimToady: I wonder if tying prefix:<+> to .Num is the issue.

[23:54] <jnthn> There's more than one way to numify...

[23:54] <TimToady> it's just the Any version that does it

[23:54] <TimToady> but if the type is neither strictly Int nor Str, Any is what we get

[23:54] <TimToady> and it delegates to .Num

[23:55] <jnthn> Could it delegate to the least-derived .Num or .Int?

[23:55] <TimToady> that's nonstandard OO.

[23:55] <jnthn> I know.

[23:55] <TimToady> should call the most-derived

[23:55] <jnthn> oh crap

[23:55] <jnthn> I meant most derived

[23:56] <jnthn> The first one you find looking from the bottom of the inheritance hierarchy.

[23:56] <TimToady> yes, which with a mixin will be Int rather than Str

[23:56] <jnthn> Right.

[23:56] <TimToady> so +$x will tend to produce 42.0

[23:56] <TimToady> which I like a bit better than 0

[23:56] <TimToady> but only if we say Int{42} rather than 42, by current reckoning

[23:56] *** orafu left
[23:57] *** orafu joined
[23:57] <TimToady> since the "but" is implying that the override is also the type, not just the value

[23:57] <jnthn> Oh, I thought we were solving the "when I say 42" case

[23:57] <jnthn> I figured that does Int(42) would pull in a .Num method as well as a .Int because the Int role would define a .Num method.

[23:58] <TimToady> but 42 could still just be .Int mixin without implying type

[23:58] <jnthn> Yes.

[23:58] <jnthn> I figured it would be.

[23:58] <TimToady> or we could say it mixes in the type as well as the value, I suppose

[23:58] <TimToady> and just write an anonymous role explicitly if you want the other

[23:58] <jnthn> Yeah but if we mix in the type we get the storage location and all that lot.

[23:59] <TimToady> but role { method Int () { 42 } } is not onorous

[23:59] <jnthn> but role { method Bool() { True } } is worse than but True

[23:59] <TimToady> we could still mix in the type and ro interface without mixing in the storage

