[00:16] *** mikehh_ left
[00:17] *** amoc joined
[00:18] *** mikehh_ joined
[00:19] *** r0bby left
[00:20] *** ZuLuuuuuu left
[00:20] *** r0bby joined
[00:21] *** bacek__ joined
[00:22] *** mikehh_ left
[00:22] *** mikehh_ joined
[00:30] *** mikehh_ left
[00:33] *** mikehh_ joined
[00:37] *** mib_8hwlwu joined
[00:37] *** mib_8hwlwu left
[00:43] *** wollmers left
[00:44] *** mikehh_ left
[00:44] *** mikehh_ joined
[00:55] *** cls_bsd joined
[01:02] <meppl> good night

[01:03] *** meppl left
[01:10] *** cognominal left
[01:32] *** eternaleye joined
[01:40] *** nbrown joined
[01:55] *** yary joined
[01:55] *** Patterner left
[01:56] *** yary left
[01:59] *** Psyche^ joined
[01:59] *** Psyche^ is now known as Patterner

[02:05] *** Whiteknight left
[02:13] *** r0bby left
[02:13] *** r0bby joined
[02:27] *** alester joined
[02:44] *** nihiliad joined
[03:04] *** amoc left
[03:06] *** amoc joined
[03:07] *** japhb left
[03:14] *** Eevee left
[03:16] *** bacek joined
[03:16] *** japhb joined
[03:18] *** bacek_ left
[03:20] *** donaldh left
[03:20] *** donaldh joined
[03:23] *** mikehh_ left
[03:30] *** nihiliad left
[03:38] *** nihiliad joined
[03:39] *** orafu left
[03:39] *** orafu joined
[03:46] *** mikehh_ joined
[03:47] *** mikehh_ is now known as mikehh

[03:54] *** cdarroch left
[04:06] *** SamB left
[04:22] *** [particle]2 left
[04:26] *** skids left
[04:27] *** amoc left
[04:32] *** amoc joined
[04:36] *** [particle] joined
[04:58] *** cognominal joined
[05:11] *** mikehh left
[05:14] *** charsbar_ left
[05:14] *** charsbar joined
[05:22] *** cognominal left
[05:29] *** finanalyst joined
[05:30] *** hcchien left
[05:30] *** clkao left
[05:37] *** clkao joined
[05:49] *** DemoFreak joined
[05:51] *** sephee left
[05:52] *** sephee joined
[05:54] *** c9s joined
[06:11] *** justatheory left
[06:11] *** nihiliad left
[06:11] *** hcchien joined
[06:14] *** alester left
[06:33] *** Maghnus joined
[06:35] <moritz_> good morning

[06:39] *** redicaps joined
[06:42] *** iblechbot joined
[06:43] *** japhb_ joined
[06:43] *** japhb left
[06:47] *** redicaps left
[06:51] *** ejs joined
[06:53] <moritz_> rakudo: say sin(3.14)

[06:53] <p6eval> rakudo 6db88b: OUTPUT«Could not find non-existent sub sin␤current instr.: '_block14' pc 60 (EVAL_16:47)␤»

[06:53] <moritz_> rakudo: use Num :Trig; say sin(3.14)

[06:53] <p6eval> rakudo 6db88b: OUTPUT«0.00159265291648683␤»

[06:58] <dalek> rakudo: 966ea72 | moritz++ | docs/ChangeLog:

[06:58] <dalek> rakudo: [docs] update ChangeLog

[06:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/966ea72dea67306435fe389865922c071d5b1efe

[07:05] <Matt-W> Morning

[07:09] *** mberends joined
[07:12] <mberends> hi

[07:13] *** wollmers joined
[07:14] <wollmers> Morning

[07:16] <Matt-W> Hey

[07:20] *** donaldh left
[07:20] *** payload joined
[07:20] *** donaldh joined
[07:23] * mberends wishes Rakudo's 'Use of uninitialized value' was more explicit

[07:23] <finanalyst> mberends: i just tried running ./proto all and got:	Unrecognized subcommand 'all'. 

[07:23] <lambdabot> finanalyst: You have 1 new message. '/msg lambdabot @messages' to read it.

[07:24] <mberends> finanalyst: that was intended for './proto update all'

[07:25] <finanalyst> oh. shame.

[07:25] <mberends> the response could be clearer, I'll look at doing that in a few minutes.

[07:25] <finanalyst> i wanted to install all the modules to review perl6 idioms

[07:26] <finanalyst> by the way, there is a spelling mistake in README. Just a mo, will find it

[07:26] <mberends> finanalyst: './proto install all' might do the trick

[07:28] *** bacek__ left
[07:29] <finanalyst> mberends: in PIONEER, "This is what proto was designed for;" I think this should be ':' at the end, not ';'

[07:30] <mberends> yes, you're right. fixed locally, pushing soon. thanx.

[07:30] *** ejs left
[07:30] <finanalyst> mberends: now can find the minor error I saw before. trying install all

[07:31] <moritz_> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html very funny read

[07:33] <mberends> moritz_: excellent, from the first :)

[07:44] <wollmers> moritz_: missing two important languages in this article: APL and 'R' (later badly implemented as SQL)

[07:45] <moritz_> wollmers: there are many debatable choices in there, but foremost it's funny :-)

[07:50] <wollmers> history of IT is always funny - pragmatic (re-inventions of the wheel) versus never used academic solutions

[07:52] <Matt-W> lol

[07:52] <Matt-W> I love Haskell jokes

[07:52] <Matt-W> I'm sure they aren't as funny if you don't know Haskell

[07:53] <wollmers> Don't know Haskel;-)

[07:53] <wollmers> *Haskell

[07:53] <Matt-W> Haskell is great :)

[07:53] <Matt-W> Although Perl 6 is more generally practical

[07:56] <wollmers> Perl 5 is practical, Perl 6 I don't know good enough at the moment

[07:58] <Matt-W> Perl 6 is much more practical

[07:58] <Matt-W> Or at least, it will be when we've got more of it

[08:01] <wollmers> Will see, if I still will miss the possibilities of APL and Prolog for some (special) problems

[08:03] <moritz_> the nice thing about Perl 6 is that it's *very* extensible

[08:03] *** kane_ joined
[08:12] <Matt-W> Adding a prolog-style unification system might be pushing the extensibility a little...

[08:12] <Matt-W> but it's probably possible

[08:16] <wollmers> Or implement Prolog on Parrot, but Prolog seems to be nearly dead, very few users

[08:17] <Matt-W> Prolog is too weird for most programmers to swallow, I think

[08:17] <Matt-W> I noticed that at university

[08:17] <Matt-W> it was hard enough getting people to swallow Haskell, and that's nowhere near as weird as Prolog

[08:18] <Matt-W> where 'weird' indicates a deviation from the imperative programming style which is the most common thing these days

[08:18] *** sephee left
[08:19] <wollmers> Prolog was very hard to learn for me after six years using assembly language

[08:21] <wollmers> But mathematicians learn Prolog very fast.

[08:23] <wollmers> I teached them Prolog in 4 hours.

[08:25] *** amoc left
[08:28] <Matt-W> Traditional programmers tend to get set in their ways, it seems

[08:31] <wollmers> Of course. At the beginning I used Perl like an procedural language, in structured style.

[08:31] <moritz_> going from basic and C to perl was quite a change

[08:32] <moritz_> I took me some time, but the string operations were just fascinating

[08:32] <Matt-W> yeah that would've been an interesting transition

[08:32] <Matt-W> I learned Perl on the back of C++, Pascal and Java

[08:33] <moritz_> I wrote a very simple substitution cypher in basic, in about 50 lines. It was one in perl (tr///).

[08:38] <wollmers> My first Perl script was something like while ($line=<>) { if ($line =~ /.../) { print $line; } }

[08:40] <moritz_> aka "grep" :-)

[08:42] <finanalyst> mberends: tried ./proto install all and got a parrot error: too few arguments passed (0) - 1 params expected

[08:42] * mberends looks

[08:42] <wollmers> yeah, grep. But I had to use Win.

[08:47] *** fridim joined
[08:49] <mberends> finanalyst: thanks, you found a bug. fixed and testing...

[08:52] <mberends> finanalyst++: three more related bugs found and fixed.

[08:53] <finanalyst> i am using to perl6 to generate data that I would like to plot. GNUPLOT is used as a plotting backend for several CPAN modules. So where do I start in writing perl6 wrappers for GNUPLOT?

[08:53] <moritz_> where? in your head?

[08:54] <moritz_> I don't quite understand the question

[08:54] <moritz_> or do you mean where to get inspiration?

[09:00] <finanalyst> where. in my head surely. where should i start looking for how to do this. I havent written wrappers for C libraries before.

[09:00] <finanalyst> but i cant ask someone else to do it

[09:00] <finanalyst> so if i need gnuplot, i have to write the interfaces

[09:01] <moritz_> you can simply emit gnuplot scripts

[09:01] <moritz_> and pipe them into gnuplot

[09:01] <moritz_> no need to interface C libraries, IMHO

[09:02] <finanalyst> can i start a pipe in perl6 ?

[09:02] <finanalyst> has that been implemented?

[09:02] <moritz_> no

[09:03] <moritz_> but you can 'run("gnuplot < tempfile")'

[09:04] <finanalyst> thanx. will try that route. very glad i dont have to interface with C libraries 

[09:04] <moritz_> I think it's much easier to debug :-)

[09:06] *** payload left
[09:08] <Matt-W> also I don't think we've got an interface for C libraries yet have we?

[09:08] <Matt-W> Except writing the binding in Parrot

[09:08] *** cognominal joined
[09:09] <moritz_> right

[09:09] <Matt-W> and that's kind of nasty

[09:09] <mberends> finanalyst: './proto install all' is fixed and pushed to github.

[09:09] <jnthn>  H H

[09:09] <Matt-W> HAI jnthn

[09:10] <mberends> O   AI jnthn 

[09:11] <moritz_> jnthn: any news on your hague grant application?

[09:14] <jnthn> moritz_: Didn't finish doing email yet... :-)

[09:14] <moritz_> :-)

[09:18] <jnthn> moritz_: No news that I can see.

[09:18] <jnthn> moritz_: Ah well, it's Vienna.pm Rakudo Day today anyways. :-)

[09:18] <moritz_> :-)

[09:28] <wollmers> jnthn: you mean the funding by Vienna.pm?

[09:29] <jnthn> wollmers: Yes - I'm funded by them to hack a day a week on Rakudo. :-)

[09:30] <wollmers> Vienna.pm itself seems inactive

[09:30] <jnthn> wollmers: But I have more than one free day a week to do Perl 6 stuff, so I've got an application in for a Hague Grant also, instead of going looking for $other_paid_work

[09:30] <jnthn> Inactive?

[09:30] <jnthn> I went to a Vienna.pm meeting like, last month.

[09:30] <moritz_> wollmers: vienna.pm made the YAPC::EU last year

[09:31] <wollmers> I know, many of Erlangen.pm visited it

[09:31] <moritz_> yes. Sadly I wasn't one of them :(

[09:32] <jnthn> wollmers: They have meetings monthly or so.

[09:32] <jnthn> wollmers: I live not so far away from Vienna, so I attend now and then.

[09:32] <wollmers> couriously, I was not there, because of $payed-work. I still have my appartement in Vienna.

[09:41] * jnthn makes coffee and grabs the RT queue

[09:42] <finanalyst> i was looking for the equivalent of the perl5 heredoc << syntax . there seem to be quoting adverbs but rakudo does not implement them. How to stuff lots of lines into a variable?

[09:44] <mberends> finanalyst: just open quotes, enter several lines, close quotes

[09:46] <finanalyst> but if lines contain quotes

[09:46] <finanalyst> ?

[09:47] <mberends> finanalyst: qq[ ...several lines... ] is handy to put quotes inside

[09:48] <mberends> finanalyst: example http://gitorious.org/projects/http-daemon/repos/mainline/blobs/master/bin/httpd

[09:49] <finanalyst> thanx

[10:10] <jnthn> std: sub foo { }; sub foo { };

[10:10] <p6eval> std 26720: OUTPUT«ok 00:02 35m␤»

[10:29] *** wollmers left
[10:37] *** pmurias joined
[10:45] *** iblechbot left
[11:20] *** donaldh left
[11:20] *** dalek left
[11:20] *** dalek joined
[11:20] *** donaldh joined
[11:21] <pugs_svn> r26721 | jnthn++ | [t/spec] Un-todo 3 tests that we now pass.

[11:23] *** payload joined
[11:39] *** dalek left
[11:39] *** dalek joined
[11:43] <moritz_> rakudo: sub a { }; sub a { };

[11:43] <p6eval> rakudo dc680c: OUTPUT«Redefinition of routine a␤»

[11:43] <moritz_> rakudo: sub a { }; { sub a { }; };

[11:43] <p6eval> rakudo dc680c:  ( no output )

[11:43] <moritz_> jnthn++

[11:44] <jnthn> moritz_: Not completely sure we're right on that second answer.

[11:44] <moritz_> rakudo: sub a { "outer" }; { sub a { "inner" }; say a }; say a

[11:44] <p6eval> rakudo dc680c: OUTPUT«outer␤outer␤»

[11:44] <moritz_> neither am I

[11:44] <moritz_> rakudo: sub a { "outer" }; { my sub a { "inner" }; say a }; say a

[11:44] <jnthn> moritz_: Since default scope declarator is package, not lexical.

[11:44] <p6eval> rakudo dc680c: OUTPUT«outer␤outer␤»

[11:44] <jnthn> I knew that my patch wouldn't catch that case though...

[11:45] <moritz_> that for sure isn't right

[11:45] <jnthn> Huh? Lexical subs should work...

[11:45] <jnthn> OH

[11:46] <jnthn> *sigh*

[11:46] *** iblechbot joined
[11:46] <jnthn> rakudo: { my sub a { "inner" }; say a }; say a

[11:46] <p6eval> rakudo dc680c: OUTPUT«inner␤Could not find non-existent sub a␤current instr.: '_block14' pc 69 (EVAL_18:53)␤»

[11:46] <jnthn> Yeah. That.

[11:46] *** masak joined
[11:46] <jnthn> That's a Parrot bug.

[11:46] <masak> Rakudo Day!

[11:46] <moritz_> rakudo: my sub a { "outer" }; { my sub a { "inner" }; say a }; say a

[11:47] <p6eval> rakudo dc680c: OUTPUT«inner␤outer␤»

[11:47] <moritz_> masak: and a bug for you to submit (if you scroll back a little)

[11:47] <jnthn> (It says "oh, there's an a in our package, let's skip the lookup and directly reference the package one"

[11:47] <masak> moritz_: will do.

[11:47] <moritz_> jnthn: which is the wrong way, for rakudo

[11:47] <jnthn> moritz_: I've seen (and analysed) that bug before, or pm has analysed it and we've discussed it for sure. I'd be surprised if we didn't have a ticket already (but it's possible).

[11:48] <jnthn> moritz_: Yeah, it's an optimization fail for sure. :-(

[11:48] <moritz_> jnthn: don't know about the parrot side, but I'd be surprise if there were one for the rakudo side

[11:48] <moritz_> and IMHO we need a rakudo ticket, at least to make sure it gets proper test coverage

[11:49] <jnthn> moritz_: Yeah, I think we may have a rakudo ticket because this has come up before.

[11:51] * jnthn tries to fix up nested role composition to have the Perl 6 semantics

[11:53] <masak> rakudo: { my sub a { "inner" }; say a }; say a

[11:53] *** bacek left
[11:53] <p6eval> rakudo dc680c: OUTPUT«inner␤Could not find non-existent sub a␤current instr.: '_block14' pc 69 (EVAL_18:53)␤»

[11:54] <masak> what do you expect that to say?

[11:54] <moritz_> exactly that

[11:54] <masak> ok, I think I must have missed the bug, then.

[11:55] <masak> rakudo: sub a { "outer" }; { my sub a { "inner" }; say a }; say a

[11:55] <masak> that one?

[11:55] <moritz_> yes, that one

[11:55] <jnthn> yes

[11:55] <p6eval> rakudo dc680c: OUTPUT«outer␤outer␤»

[11:55] <jnthn> fail :-(

[11:55] <jnthn> .oO( thanks Parrot... )

[11:55] <moritz_> rakudo: fail

[11:55] <p6eval> rakudo dc680c: OUTPUT«No exception handler and no message␤current instr.: 'return' pc 16207 (src/builtins/control.pir:39)␤»

[11:55] <moritz_> fail fail

[11:56] <moritz_> :-)

[11:56] <masak> hah :)

[11:56] <jnthn> We fail at failing.

[11:56] <jnthn> .oO( so we win? )

[11:56] <masak> meta-failure.

[11:58] *** bacek joined
[12:03] <finanalyst> mberends: my ./proto install all has just run. It appears to have installed all the modules, but it ends in a failure, viz., Downloading all...Use of uninitialized value followed by some lines and a parrot failure message.

[12:03] *** eternaleye left
[12:04] *** eternaleye joined
[12:04] <masak> finanalyst: does it actually say 'downloading all...'?

[12:05] <masak> I don't remember it doing that.

[12:05] <finanalyst> i can nopaste you all the output ok?

[12:05] <masak> yes, please.

[12:06] <pugs_svn> r26722 | moritz++ | [t/spec] RT #64098, methods on enums

[12:07] <pasteling> "finanalyst" at 193.110.4.137 pasted "output from 'proto install all'" (68 lines, 3K) at http://sial.org/pbot/36505

[12:09] <masak> finanalyst: sir, you just found a bug. :) care to leave a bug report? http://github.com/masak/proto/issues

[12:09] <masak> just re-pasting the nopaste content should be enough, actually.

[12:10] <masak> (strange, this used to work.)

[12:10] * jnthn makes role composition infinite loop and use all his memory. Oops.

[12:11] <finanalyst> that's the second time today when running ./proto install all. :( mberends fixed one earlier.

[12:11] <finanalyst> filing bug

[12:11] <masak> yes, I see that from the logs.

[12:12] <masak> sorry about lingering bugs; proto is a bit unpolished still.

[12:14] <jnthn> oh, argh.

[12:15] <finanalyst> but its still won the Nobel prize :)

[12:16] <moritz_> probably the first software ever to do that

[12:16] <jnthn> The tests that claim to be for 63330 are actually testing 63332

[12:16] <jnthn> oh no, actually...one tests one, one tests the other...

[12:17] <masak> finanalyst: I should lie more often. proto has a wonderful rep nowadays. :)

[12:18] <moritz_> any bug admins around? RT #65492 is spam

[12:21] <jnthn> moritz_: Is fudge not meant to comment out a whole block if you put a skip above a block?

[12:22] <masak> finanalyst: fixed, thanks.

[12:22] <jnthn> moritz_: oh, never mind...it has to be an outer-most block, not a nested one...then it works.

[12:23] <masak> finanalyst: can't find your bug report, so I can't close it. :/

[12:25] <jnthn> And it passes now. w00t. masak can do diamonds. :-)

[12:25] <masak> yay!

[12:25] <masak> applying CS on Rakudo is a nice way to bring out bugs :)

[12:25] <pugs_svn> r26723 | moritz++ | [t/spec] RT #64104, constructing a Range in an action stub

[12:27] <jnthn> Yeah. I have a slight fear I may have broken some spectests, but we'll see...

[12:27] *** PhatEddy joined
[12:28] <masak> if it ain't broke, break it.

[12:28] <jnthn> rakudo: role A { }; role B { }; class C is A is B { }

[12:28] <p6eval> rakudo dc680c: OUTPUT«The class 'C' already has a parent class ''. It may have been supplied by a role.␤current instr.: '!meta_trait' pc -5324611 ((unknown file):-1)␤»

[12:29] <jnthn> Yeah, it's nothing to do with diamonds.

[12:29] <jnthn> oh ffs please say Parrot ain't going on string names for checking...

[12:29] <jnthn> rakudo: role A { }; role B { }; class C is A{ }

[12:29] <jnthn> rakudo: role A { }; role B { }; class C is A { }

[12:29] <PhatEddy> I rejected the spam RT.  If there is any other action I should take please let me know ...

[12:29] <p6eval> rakudo dc680c: OUTPUT«Unable to parse class definition at line 1, near ""␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[12:29] <p6eval> rakudo dc680c:  ( no output )

[12:30] <moritz_> PhatEddy: I meant deletion, not rejecting

[12:30] <moritz_> PhatEddy: but my privs don't allow that

[12:32] <jnthn> omfg

[12:32] <jnthn>             /* throw an exception if we already have this parent */

[12:32] <jnthn>             if (Parrot_str_equal(interp, current_name, parent_name))

[12:32] *** ruoso joined
[12:33] <masak> o_O

[12:33] <masak> rakudo: class A::C {}; class B::C {}; class D is A::C is B::C {}

[12:33] <p6eval> rakudo dc680c:  ( no output )

[12:34] <masak> hm. so that's not the problem...

[12:34] <jnthn> masak: I'm patching Parrot.

[12:34] <masak> jnthn++

[12:36] <ruoso> hello!

[12:36] <jnthn> hi ruoso 

[12:37] * jnthn smokes his Parrot fix

[12:37] <moritz_> in t/spec/S02-whitespace_and_comments/unspace.t 

[12:37] <moritz_> I get a Null PMC access in get_attr_str()

[12:37] <jnthn> moritz_: New bug?

[12:37] <jnthn> (failure)?

[12:38] <jnthn> erm, regression even... :-)

[12:38] <moritz_> jnthn: yes, I think so

[12:39] <moritz_> and t/spec/S04-statements/for.t segfaults after 50 tests

[12:39] <moritz_> (with parrot r38602, which is from today)

[12:40] * ruoso wonders if that rumour about we getting contextual variables today would be confirmed...

[12:40] <finanalyst> masak: i cant find my bug report (which u have fixed already). i labelled it 'install all....' in case it mysteriously appears

[12:40] <masak> oki.

[12:40] <masak> there appears to be issues with githubs issue-tracker :)

[12:41] <jnthn> masak: github has issues.

[12:41] <jnthn> ;-)

[12:41] <finanalyst> first time i used it, so i thought is had got it wrong

[12:41] <masak> jnthn: that's a better way of putting it. :)

[12:41] <finanalyst> s/is/it

[12:42] <finanalyst> s/it/I/ !!!!!!!

[12:42] *** kidd_ joined
[12:45] <jnthn> Damm. I did break t\spec\S14-roles\crony.t :-(

[12:46] <jnthn> otoh my Parrot patch passes all Parrot sanity tests.

[12:46] <jnthn> s/sanity///

[12:46] <masak> jnthn: gotta go study chinese, then have dinner with some friends, then watch the new Star Trek movie. good luck with the rest of Rakudo Day!

[12:47] <jnthn> masak: Dude, you'd think it was you living in the country that has today as national holiday. :-P

[12:47] <masak> (I got halfway hacking in '.=flip' last night. will try again later.)

[12:47] <jnthn> Have lots of fun (sounds hard not to with that lot...)

[12:47] <masak> jnthn: just working half-time, that's all.

[12:47] * masak bows, walking out backwards

[12:47] *** masak left
[12:48] *** iblechbot left
[12:48] <jnthn> ruoso: (context vars) maybe, if pmichaud wants to do them today and wants my help on some bits related to them too, I'll happily join in with working on that

[12:48] <ruoso> cool...

[12:48] * ruoso anxious to have faz working as expected...

[12:49] <jnthn> :-)

[12:50] <ruoso> which we then will probably be able to plug into masak's web stuff

[12:52] <ruoso> jnthn, I think I already asked this before... but I think I forgot the answer... does rakudo already support defining custom grammars with interleave with Perl 6 grammar?

[12:53] <jnthn> Such that we'd parse parts of our program differently? I don't think so.

[12:53] <ruoso> maybe the inverser

[12:53] <ruoso> *inverse

[12:53] <ruoso> a grammar that has parts of it in Perl 6

[12:54] <ruoso> i.e.:

[12:54] *** nihiliad joined
[12:54] <ruoso> controller Foo { action bar { perl 6 code here } };

[12:55] *** amoc joined
[12:57] <jnthn> Oh, that might not be so hard.

[12:57] <ruoso> hmm... 

[12:57] <jnthn> Thing is that it may not know when to terminate.

[12:57] <ruoso> what do you mean?

[12:57] <jnthn> That is, it may try and parse the last } } and say they are unmatched.

[12:57] <ruoso> hmm...right

[12:57] <jnthn> Rather than handing back over to your language.

[12:57] <ruoso> maybe we could start from the method rule

[12:58] <jnthn> True.

[12:58] <ruoso> isntead of comp_unit

[12:58] <jnthn> Aye, that may work.

[12:58] <ruoso> is it possible to hand that code later to the emitter?

[12:58] <moritz_> rakudo: say "(foo)" ~~ m/\( ~ \) <Perl6::Grammar::identifier> / && say $/

[12:58] <p6eval> rakudo dc680c: OUTPUT«(foo)␤1␤»

[12:59] *** LylePerl joined
[13:00] <jnthn> ruoso: You thinking of code-generating and eval'ing, in which case I guess what moritz_ just wrote...

[13:00] <ruoso> jnthn, and what if I want to get that compiled down to bytecode?

[13:01] <jnthn> $/.ast should give you the PAST, and I guess then you'd need to get hold of something that transforms that to bytecode.

[13:01] <jnthn> Oh, you mean you want to eval it and then save it as bytecode?

[13:02] *** payload left
[13:02] <ruoso> jnthn, well... what I want is that code to be compiled regularly...

[13:03] <jnthn> What do you mean by "regularly"?

[13:04] <ruoso> as if it was regular Perl 6 code

[13:04] <ruoso> actually... I think it could even be expressed as macros

[13:06] <moritz_> which are NYI, and quite a bit down the roadmap

[13:06] <jnthn> Aye, macros won't be for a while.

[13:06] <ruoso> hmm... maybe doing it as a different HLL in parrot?

[13:07] *** kidd_ left
[13:07] <moritz_> I don't think it's that easy :(

[13:07] <jnthn> Aye.

[13:07] <ruoso> hmmm... any reasonable way of doing it?

[13:07] <jnthn> ruoso: pmichaud is much more the person to ask about this stuff.

[13:08] <ruoso> right...

[13:08] <moritz_> ruoso: I fear you have to set up the compiling environment etc.

[13:08] <moritz_> ruoso: for now it's probably easiest to use string eval

[13:08] <jnthn> I'm not familiar with PGE guts and I don't know how hard the "knowing when to stop parsing" issue is.

[13:08] <jnthn> Or if that's a solved problem.

[13:08] <jnthn> (I fear not though.)

[13:09] <jnthn> As moritz_ said, the eval route - if you can get the parser to do what you want - should Just Work.

[13:09] *** payload joined
[13:09] <jnthn> Your other option is getting the PAST (I guess you need to somehow get the action grammar in place though).

[13:09] <moritz_> rakudo: say '(say "hi";)' ~~ /\( ~ \) <Perl6::Grammar::TOP> /

[13:09] <p6eval> rakudo dc680c: OUTPUT«Syntax error at line 1, near ")"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[13:09] <jnthn> And building up PAST nodes from your other surrounding rules that call into Perl 6.

[13:10] <jnthn> moritz_: Yeah, that's the issue I was expecting.

[13:10] <moritz_> jnthn: me too, but I had hopes for magic :-)

[13:10] <jnthn> moritz_: I don't understand enough to know how tractable that is as a problem. It could be anywhere from "easy" to "ouch". :-)

[13:10] <ruoso> rakudo: my $x = 'action foo { say "Hello!"; }'; $x ~~ / action <Perl6::Grammar::block> /; say $/.ast

[13:10] <p6eval> rakudo dc680c: OUTPUT«␤»

[13:11] <ruoso> rakudo: my $x = 'action foo { say "Hello!"; }'; $x ~~ / action <Perl6::Grammar::block> /; say $/;

[13:11] <p6eval> rakudo dc680c: OUTPUT«␤»

[13:11] <moritz_> rafl: if block is a token or rule, it won't backtrack to search for it

[13:11] <ruoso> rakudo: my $x = 'action foo { say "Hello!"; }'; $x ~~ / action { ~ } <Perl6::Grammar::statementlist> /; say $/;

[13:11] <moritz_> sorry, mean ruoso 

[13:11] <p6eval> rakudo dc680c: OUTPUT«Statement not terminated properly at line 1, near "~ } <Perl6"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[13:12] <ruoso> rakudo: my $x = 'action foo { say "Hello!"; }'; $x ~~ / action \{ ~ \} <Perl6::Grammar::statementlist> /; say $/;

[13:12] <p6eval> rakudo dc680c: OUTPUT«␤»

[13:12] <ruoso> rakudo: my $x = 'action foo { say "Hello!"; }'; $x ~~ / action \s foo \s \{ ~ \} <Perl6::Grammar::statementlist> /; say $/;

[13:12] <p6eval> rakudo dc680c: OUTPUT«action foo { say "Hello!"; }␤»

[13:13] <jnthn> aha!

[13:13] <jnthn> rakudo++

[13:13] <moritz_> indeed

[13:13] <moritz_> and pmichaud++, just to be sure :-)

[13:13] <jnthn> And pmichaud++ too.

[13:13] <jnthn> oh :-)

[13:13] <jnthn> Well, karma deserved.

[13:14] * jnthn thinks he's got the two tricky RT tickets on role composition errors fixed

[13:14] <jnthn> I've put those off for weeks...turned out not to be quite so bad after all.

[13:15] <jnthn> moritz_: Did you say you had problems with Rakudo + latest Parrot?

[13:15] <ruoso> I guess writing a DSL compiler in rakudo to be ran in this files is a possible way of doing it

[13:16] <ruoso> compiling from that to Perl 6

[13:16] <moritz_> jnthn: yes, two or three segfaults (one known, slice.t)

[13:17] <PhatEddy> A proposed rakudo independent workaround to spec tests checking for Null PMC: regex fairly_conclusive_platform_error {:i \N*<<Null?>>}

[13:17] <moritz_> jnthn: but I didn't do realclean in Parrot

[13:17] <jnthn> moritz_: slice.t is a known, yeah

[13:19] <jnthn> moritz_: I did some analysis on it and field a ticket with details...no ideas for a solution yet though.

[13:19] <moritz_> jnthn: I know, I've seen it

[13:34] *** sri_kraih joined
[13:36] *** exodist joined
[13:40] *** sri_kraih_ left
[13:45] <dalek> rakudo: 14cd976 | jnthn++ | src/ (2 files):

[13:45] <dalek> rakudo: Refactor the way we handle the composition of role cronies to be more in line with the spec. Fixes RT#63330 and almost fixes RT#63332 (that needs us bumping up to a fixed Parrot).

[13:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/14cd976cc0ef167efc2137c1bdac306a5760025a

[13:55] <pugs_svn> r26724 | jnthn++ | [t/spec] Unfudge test for RT#63330.

[13:55] *** hcchien left
[13:55] *** r0bby left
[13:55] *** betterworld left
[13:55] *** finanalyst left
[13:56] *** hcchien joined
[13:58] <ruoso> pmurias, hi

[13:58] *** r0bby joined
[14:00] *** iblechbot joined
[14:00] *** twigil joined
[14:00] *** Casan left
[14:01] *** betterworld joined
[14:04] <pmurias> ruoso: hi

[14:04] <ruoso> I'm working on getting p6opaque running

[14:06] <PhatEddy> giving one more chance to review my package test file (20 tests) before I commit/add: http://gist.github.com/108785

[14:06] <pmurias> ruoso: ok

[14:11] <pugs_svn> r26725 | ruoso++ | [smop][nagc] provides a version of the release code that doesnt call "free" for objects that need a more complex destruction process.

[14:11] <pugs_svn> r26725 | ruoso++ | [smop][tools/ri] provides a nagc.nofree attribute for choosing the more complex destruction

[14:11] <pugs_svn> r26725 | ruoso++ | [smop][p6opaque] uses the nagc.nofree option

[14:11] <pugs_svn> r26725 | ruoso++ | [smop][p6opaque] placeholder for dispatching the actual DESTROYALL method

[14:11] <ruoso> pmurias, now we just need to figure out a way to dispatch DESTROYALL on the object and still free the object later...

[14:12] <jnthn> rakudo: multi foo(Bool :$baz = Bool::False, *@vals) { say "foo" }; foo(:baz(Bool::True), 1, 2, 3);

[14:12] <p6eval> rakudo 14cd97: OUTPUT«No applicable candidates found to dispatch to for 'foo'␤current instr.: '_block14' pc 91 (EVAL_18:57)␤»

[14:13] *** skids joined
[14:13] <pmurias> we could have a LOST frame (factory) which would call DESTROYALL on an object and the free it

[14:14] <ruoso> pmurias, yeah... I was thinking about it also..

[14:15] *** PacoLinux joined
[14:15] <pmurias> ruoso: should i write it?

[14:16] *** jan_ left
[14:16] <ruoso> pmurias, please... I'm still getting the last pieces of p6opaque together

[14:16] <pugs_svn> r26726 | jnthn++ | [t/spec] Unfudge another now-passing role composition test after bug fixes.

[14:19] <pmichaud> good morning perl6

[14:19] <dalek> rakudo: 52419be | jnthn++ | build/PARROT_REVISION:

[14:19] <dalek> rakudo: Bump us up to Parrot revision with the string comparison to determine class identity in inheritance ripped out.

[14:19] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/52419be25dce00279aceb489228fca7799f5f618

[14:19] <pmichaud> 52419be++!!!

[14:20] <pmurias> ruoso: how should the module which does that be called?

[14:20] <jnthn> pmichaud: Yeah, I finally got onto two of the roles composition bugs I've had in my queue for ages, and found this was part of it...

[14:20] <ruoso> pmurias, I'm not sure it needs to be a module

[14:20] <ruoso> pmurias, maybe just a part of the p6opaque module

[14:21] <pmurias> yes, that would be better

[14:24] * pmichaud reads a couple of days of scrollback

[14:24] <jnthn> ouch.

[14:24] <ruoso> ouch indeed

[14:29] <pugs_svn> r26727 | ruoso++ | [smop][nagc] add smop_nagc_free as a visible function.

[14:29] <pugs_svn> r26727 | ruoso++ | [smop][tools/ri] call smop_nagc_free in the end of DESTROYALL if nagc.nofree is set - the idea is that you should return from DESTROYALL to interrupt the process and call it again when you really want it to be destroyed...

[14:29] <pugs_svn> r26727 | ruoso++ | [smop][p6opaque] the actual dispatching was missing...

[14:30] <PerlJam> Have any of you other language people seen this?  http://msdn.microsoft.com/en-us/oslo/dd548667.aspx

[14:30] <PerlJam> That M language looks an awful lot like Perl 6 Regex

[14:31] <PerlJam> (well, the syntax is completely different, but the same semantics appear to be there)

[14:33] *** payload left
[14:34] <PerlJam> the more I look at it, the more Perl 6 I see.

[14:34] <ruoso> it really look a lot like it...

[14:36] *** [particle] left
[14:39] *** mizioumt joined
[14:40] <pmurias> svn-- # insanity

[14:41] <Matt-W> Perl 6 doens't have interleave patterns

[14:41] <Matt-W> which seem liable to induce headaches

[14:41] <Matt-W> but then, parsing always does anyway

[14:41] <PerlJam> Matt-W: yes it does.

[14:41] <PerlJam> interleave is <ws>

[14:41] <PerlJam> syntax + interleave in M is the same as a rule in p6

[14:42] <Matt-W> hmm

[14:42] <pmurias> ruoso: what's the point of not setting nagc.nofree?

[14:42] <Matt-W> I still don't understand the differences between regex, rule and token

[14:43] <ruoso> pmurias, of not setting?

[14:43] <pmurias> yes

[14:43] <Matt-W> I just use regex for everything because I know it's not goign to do anything weird

[14:43] <ruoso> pmurias, what do you mean?

[14:43] <PerlJam> Matt-W: regex is just "normal" regex,  token is regex  with no backtracking,  rule is regex with not backtracking and with implicit whitespace

[14:43] <Matt-W> hmm

[14:44] <Matt-W> implicit whitespace where

[14:44] <pmurias> if the nagc.nofree is not set the object call smop_nagc_free itself and free doesn't get called from RELEASE

[14:44] *** twigil left
[14:44] <PerlJam> Matt-W: whitespace in your pattern matches (smartly) whitespace in the input

[14:44] <pmurias> s/is not set/is set/

[14:44] <pmurias> * calls

[14:45] <ruoso> the idea is that you interrupt DESTROYALL do whatever you need and call it again

[14:45] <ruoso> so you take advantage from the generated destruction code for attributes and stuff

[14:46] *** jiing joined
[14:46] <ruoso> pmurias, note the "return" in p6oaque DESTROYALL cod

[14:46] <PerlJam> Matt-W: regex foo { "a" "b" }  only matches "ab".  rule foo { "a" "b" } matches "   a    b  " or "a   b"  but not "ab"

[14:46] *** FurnaceBoy joined
[14:49] <pmurias> ruoso: what i mean it that we could always make DESTROYALL in charge of calling smop_nagc_free

[14:49] <pmurias> s/it/is/

[14:50] <ruoso> pmurias, yeah... we could... but now you can choose when you set up the RI

[14:54] <Matt-W> PerlJam: okay

[14:56] *** Eevee joined
[15:02] <PerlJam> Hmm.

[15:02] <PerlJam> rakudo:  rule foo { 'a' 'b' }

[15:02] <p6eval> rakudo 52419b:  ( no output )

[15:02] <PerlJam> rakudo: rule foo { "a" "b" }

[15:02] <p6eval> rakudo 52419b: OUTPUT«Statement not terminated properly at line 1, near "a\" \"b\" }"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[15:03] * jnthn thought double quotes were implemented recently?

[15:03] <pmurias> ruoso: i have to catch a train, so i'll write the LOST frame much later today/tommorow

[15:03] <pmichaud> implemented but patch not applied yet.

[15:03] <pmichaud> It's on my todo list for today.

[15:03] <jnthn> Ah, ok.

[15:03] <pmurias> but having switched to git-svn should avoid getting sidetracked by version control client bugs

[15:03] <jnthn> pmichaud: It's national holiday here and I've been invited out for dinner, so going to go do that soon. Will be back later on today though for more Rakudo stuff.

[15:04] <pmichaud> jnthn: that's fine.  I'm not sure what I'm working on today -- have a few things to catch up on from yesterday.

[15:04] <pmichaud> Happy $national-holiday though :-)

[15:04] <jnthn> Yeah, I'm not entirely sure what this one's for.

[15:04] <jnthn> But the sun is shining and there's opportunity to enjoy food and a beer or two outside. :-)

[15:05] *** donaldh left
[15:06] <jnthn> Just spectesting then hopefully applying a fix for 63920 first.

[15:07] <jnthn> ([TODO] default type for params in pointy blocks should be Object)

[15:07] <pugs_svn> r26728 | ron++ | Add S10-packages/basic.t.  Currently 20 tests including tests for 14 active RTs.

[15:09] *** PhatEddy left
[15:09] *** PhatEddy_ joined
[15:09] *** PhatEddy_ is now known as PhatEddy

[15:10] <pmichaud> jnthn:  (Parrot uses strings for testing class membership)  -- I've been carping about that particular design misfeature for months.  :-)

[15:10] *** justatheory joined
[15:10] <pmichaud> not only is it wrong, but it's slow, too.

[15:10] *** mikehh joined
[15:10] <jnthn> pmichaud: I literally replaced a string comp with a pointer comp.

[15:11] <pmichaud> that's far more correct, yes.  :-)

[15:11] <pmichaud> and what I would expect.

[15:11] <jnthn> All Parrot tests passed, another Rakudo test passed...

[15:11] <jnthn> Added a Parrot test too.

[15:11] <pmichaud> there are more instances of Parrot doing that in the code, iirc.

[15:11] <pmichaud> as in, a lot more instances.

[15:11] <jnthn> awww...I broke some of autothreding.t...

[15:11] <jnthn> Yeah, I know.

[15:12] *** pmurias left
[15:12] *** meteorjay joined
[15:15] <pmichaud> (from scrollback) -- to compile a Perl 6 string, as opposed to eval'ing it, in Rakudo one can do

[15:15] <pmichaud> my $code = Perl6::Compiler.compiler('...');

[15:15] <pmichaud> rakudo:  my $code = Perl6::Compiler.compile('say <hello>');   $code()

[15:15] <p6eval> rakudo 52419b: OUTPUT«hello␤»

[15:16] * moritz_ hilights ruoso

[15:16] <pmichaud> I _think_ it might also work to pass a Perl6::Grammar parse tree there (to avoid the duplicate parse), but I'm not sure that works yet.

[15:17] <pmichaud> actually, I suspect it doesn't.

[15:17] *** FurnaceBoy left
[15:17] * moritz_ currently tests the patch in RT #64868

[15:17] <moritz_> looks mostly good so far

[15:17] <moritz_> though I might upper-case some warnings

[15:18] <pmichaud> reviewing patch

[15:19] <moritz_> the `system(qw(make clean))'

[15:19] <moritz_> bothers me

[15:19] <moritz_> not every make utility is called `make'

[15:19] <jnthn> Mine sure ain't.

[15:19] <pmichaud> agreed.

[15:20] <pmichaud> I suspect the "make clean" should be done as part of Rakudo.

[15:20] <moritz_> but changing that $config{'make'} should work

[15:20] <pmichaud> yes, that would help

[15:20] <pmichaud> s/Rakudo/Configure.pl/ above

[15:20] <pmichaud> I don't want gen-parrot to do the rakudo "make clean" -- it's mixing pieces the wrong way.

[15:21] <moritz_> the problem with sticking it into the Makefile is that it'll fail epically on parallel builds

[15:21] <moritz_> at least I think so

[15:21] <pmichaud> so, Configure.pl then

[15:21] *** Kisu left
[15:22] <pmichaud> Oh.

[15:22] <pmichaud> I'd like this patch significantly refactored, actually.

[15:22] *** Kisu joined
[15:22] <pmichaud> "check-parrot-revision" belongs in gen_parrot.pl, not in Rakudo's Configure.pl

[15:23] <pmichaud> otherwise we end up with the parrot-version-checking code in two places.

[15:23] <moritz_> so do just want to always call gen_parrot.pl, potentially with options?

[15:23] <pmichaud> (gen_parrot.pl already checks Parrot revisions, and does the handling of build/PARROT_REVISION)

[15:23] <pmichaud> yes

[15:23] <moritz_> we could also factor out a module

[15:23] <pmichaud> I'm not sure that buys much

[15:24] <moritz_> you're the boss ;-)

[15:24] <pmichaud> in some sense...

[15:24] *** [particle] joined
[15:24] <PhatEddy> that Perl6::Compiler.compile example from earlier core dumps for me on cygwin (but not native windows).  anyone interested in verifying ...

[15:24] <moritz_> pmichaud: most of all I trust that you have much more experience with build systems than I have ;-)

[15:24] <pmichaud> gen_parrot could become the generic "do all of the parrot-related stuff" tool.

[15:25] <pmichaud> I don't know about "much more", but I've written a couple.

[15:25] <jnthn> PhatEddy: Quite believable, we do have other issues on cygwin I think.

[15:25] *** alanhaggai_ joined
[15:26] <moritz_> as opposed to 0 ;-)

[15:27] <pmichaud> oh, I think I know what I want.

[15:27] <pmichaud> I think I want my own "get the parrot config" wrapper.

[15:27] <pmichaud> that also optionally builds and tests the parrot version

[15:27] <pmichaud> and returns that result back to Configure.pl, which then generates the makefile.

[15:27] <pmichaud> (this would extend/replace the existing gen_parrot.pl)

[15:28] <pmichaud> that way Configure.pl doesn't have to worry about "how do I get/build Parrot" -- that's handled by the other wrapper.

[15:28] <moritz_> and if you want to make the "return" not a string, but a data structure, it will be in a module

[15:28] *** zamolxes joined
[15:28] <moritz_> that's where my idea came from

[15:28] <pmichaud> sure

[15:28] <pmichaud> but really the "get the parrot config" wrapper only needs to return the path to the correct 'parrot_config' to use.

[15:29] <TimToady> rehai

[15:29] <pmichaud> and Configure.pl simply call it for the configuration information it needs.

[15:29] <pmichaud> good morning, TimToady

[15:30] <pmichaud> jnthn: I saw the earlier conversation about "type methods" -- where did that end up?

[15:30] <TimToady> I've been thinking about that a lot

[15:30] <jnthn> pmichaud: It ended up with my brain exploding.

[15:30] <pmichaud> I'm curious how one writes "class methods" if we do that.

[15:31] *** alanhaggai_ is now known as alanhaggai

[15:31] <jnthn> Depends what sort of class methods you mean.

[15:31] <pmichaud> The kind where I can have    Int.foo and 3.foo both invoke the same method.

[15:31] *** clintongormley joined
[15:31] <jnthn> Anyway, I'd also missed out on something fairly major in the way smop does things.

[15:31] <TimToady> they used a fallback to normal dispatch for that, but I'm not sure I like that

[15:31] <pmichaud> TimToady: which one falls back, though?

[15:31] <pmichaud> I thought the fallback was backwards there.

[15:31] <TimToady> exactly

[15:32] <jnthn> Which basically called a halt fo the refactoring I was starting digging in to.

[15:32] <[particle]> role, role, role your boat...

[15:32] <TimToady> on the other hand, what motivated it was ACCEPTS, which needs to check validity first

[15:32] <pmichaud> well, it's not just ACCEPTS, at least to my view.

[15:32] <pmichaud> we also have various postcircumfixes and other method-like thingies 

[15:33] <jnthn> Indeed. Hash{ ... } and %foo{ ... } are different.

[15:33] <pmichaud> there are a number of ways in which a type object responds differently from a normal instance, and I'm not sure that all of them are syntactic.

[15:33] <jnthn> ACCEPTS is sure not syntactic.

[15:34] <jnthn> Anyway what I've essentially figured is that smop doesn't really do the "type objects and instances are the same type" any more literally than we currently do it in Rakudo.

[15:34] <jnthn> Differently, but still...

[15:34] <pmichaud> Yes, I often felt it was the to-may-to to-mah-to sort of thing.  We just pushed the "are you a type" bit into different places.

[15:35] <jnthn> I'm not convinced type object = empty instance + role mixed in is a wrong way to do it.

[15:35] <pmichaud> Rakudo chose to distinguish types by a role.  Which really is a form of "are you a type bit" at its core.

[15:35] <jnthn> *nod*

[15:35] <pmichaud> The question is whether using a role brings along other baggage that is fundamentally incorrect.

[15:35] <TimToady> part of the problem is that we're using type to mean several different things here

[15:35] <jnthn> We need to be a little careful where this gets us on representation vs metaclass.

[15:36] <pmichaud> or perhaps not "whether", but "to what degree" it brings along other baggage that we then have to fixup or work around.

[15:36] <pmichaud> yes, in jnthn's earlier list of things that a "type" is used for, I didn't see "package namespace handle"

[15:36] <TimToady> when we say ~~ $x we're using a type as a subset meaning "all the possible values"

[15:37] <TimToady> not as a type meaning "no valid value"

[15:38] <pmichaud> okay.  I was just checking to see if I followed the conversation, it appears that I did.

[15:38] <pmichaud> I don't have any new insights to add right now beyond what I've just written (or things I've written previously).

[15:39] *** jan_ joined
[15:39] <TimToady> I've thought in various directions on it, but not entirely happy with any of those yet

[15:39] <TimToady> but my gut feeling is that there's something going on with values being subset types

[15:39] <jnthn> OK, I need to go for a bit. Be back later.

[15:39] <pmichaud> jnthn: sure, thanks.

[15:40] <TimToady> laters

[15:40] <TimToady> I've also been working over the notion of language braids

[15:40] <pmichaud> TimToady: I think there's something there also, but I haven't been able to get beyond the "it sure seems like..." proposition to anything more concrete that fits well with the rest of what I know of Perl 6 (implementation)

[15:41] <TimToady> but I'm wary of dispatchers that reorder

[15:41] <pmichaud> agreed.

[15:42] <TimToady> the subset idea leads me to think that it's more like eligible vs ineligible, keeping the same order

[15:42] *** nihiliad left
[15:42] <pmichaud> I tend to fall back to  "if I have X and Y of the same type but X responds differently to various method-like things, then X must have an additional role, trait, or other thing applied that causes it to act differently"

[15:42] *** nihiliad joined
[15:42] <TimToady> but that also gets tangled

[15:42] <TimToady> there's a figure ground problem with that

[15:42] <TimToady> since roles are always added in

[15:42] <pmichaud> agreed.

[15:43] <TimToady> but sometime you want to see the concrete and sometimes the abstract as the figure

[15:43] <TimToady> or both, for $x.new

[15:43] <pmichaud> (and other "class methods")

[15:44] <TimToady> well, that's a bit of a mislabel too, if class method means +abstract-concrete

[15:44] <pmichaud> I think of "class method" in the traditional sense, where it can be invoked by either the abstract or concrete instances

[15:44] <TimToady> currently our methods are ++, but maybe we need "meta" "metamethod" and "method", or some such

[15:44] <pmichaud> (at least, that's "traditional" in my java and C++ version of OO stuff)

[15:45] *** nihiliad left
[15:45] <TimToady> meta meaning "I can handle an invalid value"

[15:45] <pmichaud> hmmmm

[15:45] <TimToady> and "method" meaning I can handle an ordinary value

[15:45] <TimToady> a valid valud

[15:45] <pmichaud> that has some good promise, I think.

[15:46] <TimToady> or something like that--seems too important to let traits deal with it

[15:46] <pmichaud> at first look, I kind of like the meta, metamethod, and method distinction

[15:46] <pmichaud> that feels... "clean"

[15:46] <TimToady> well, that's the direction I'm leaning, anyway, and it defaults normal methods to not seeing type objets

[15:46] <[particle]> would there be syntactic difference for calling those?

[15:47] <pmichaud> [particle]1: for defining them, I think.

[15:47] <TimToady> no

[15:47] <pmichaud> calling would be the same.

[15:47] <pmichaud> Type.foo   would call the "foo"'s that are meta or metamethod

[15:47] <pmichaud> $obj.foo   would call the foo's that are metamethod or method

[15:47] <[particle]> ok, so no self!method or !^meta kinda stuff

[15:47] <pmichaud> (assuming that $obj isn't a type object)

[15:48] <TimToady> no, this is trying to get the semantics of Plain Old Dispatch correct

[15:48] <[particle]> can you replace 'meta' with 'type'?

[15:48] <pmichaud> having those as declarators would also mean that it becomes much clearer about when a method would be valid on a type object (as opposed to an instance)

[15:48] <[particle]> meta is so generic

[15:49] <[particle]> maybe typemeta, typemethod

[15:49] <TimToady> type isn't any better

[15:49] <[particle]> well, we have type objects

[15:49] <[particle]> at least it's not protomethod...

[15:49] <TimToady> besides, we're labeling a method, and "type" would be misleading

[15:49] <TimToady> since ACCEPTS isn't a type

[15:50] <pmichaud> i.e.,  if I say    method foo() { say $.x; }     then it's pretty clear that   Type.foo   would result in a "method not found" error, instead of something where we have to explain that Type is not an instance

[15:50] <pmichaud> (and detect that because there's not an instantiated self)

[15:50] <pmichaud> if I want Type.foo  to also work, I'd have to declare it as a metamethod

[15:50] <[particle]> so, these are decorated upon definition

[15:51] <[particle]> how does only/multi factor in?

[15:51] *** Psyche^ joined
[15:51] <TimToady> orthogonal

[15:51] <[particle]> only metamethod foo {...}; multi method foo {...}; #okay

[15:52] <pmichaud> anyway, from a definition/clarity side, I like it.  I'm not entirely sure what it implies for dispatch (either Perl 6 or Parrot)

[15:52] <TimToady> only/multi is just saying whether we overload the name in the current namespace

[15:53] <TimToady> this is more like an extra bit on the binding constraints

[15:53] <pmichaud> (I should've used "$!x" in my example above, sorry.)

[15:53] <[particle]> so, my example wouldn't be okay, then.

[15:54] <[particle]> since the metamethod and method of the same name have the same sig, and one is marked only

[15:54] <TimToady> correct, you can't do only foo vs multi foo

[15:54] <[particle]> sensical.

[15:55] <TimToady> multi meta foo vs multi method foo is an interesting thing though, especially when you mention &foo to mean either

[15:56] <[particle]> is it a junction, then?

[15:56] <pmichaud> okay, my brane exploded.

[15:56] *** zamolxes left
[15:56] <pmichaud> (it was about to do that anyway -- I'm trying to hold too many projects in at once)

[15:56] <TimToady> well, we'll leave that one to cook for a bit longer

[15:56] * clintongormley welcomes pmichaud to the other side of the brane

[15:56] <TimToady> another brane exploder is the language braid thing

[15:57] <TimToady> a braid is really its own little namespace running through a compilation

[15:57] <[particle]> i've got to figure out this braid thing...

[15:57] <TimToady> I'd been emulating a braid with separate variables

[15:57] * [particle] consults 6perl notes

[15:57] <TimToady> $?Q vs $?Regex vs $?Quasi etc

[15:57] <TimToady> but then there's no way to treat them as a group

[15:58] <TimToady> it's not a package namespace though, more like a hash in the compiler

[15:59] <TimToady> so instead of identifying sublangs as $?Regex we'll probably given strands of the braid their own twigil namespace

[15:59] <TimToady> probably $~Regex means the currently defined regex language, for instance

[15:59] <pmichaud> at first instance that also sounds sane to me

[15:59] <TimToady> and we also get a new declarator to talk about that

[15:59] <[particle]> a group meaning the current working set of DSLs?

[15:59] <TimToady> yes

[15:59] <[particle]> ok.

[16:00] <TimToady> and since it has its own namespace that is specifcally *not* a package

[16:00] <[particle]> there's no ascii char that looks like a braid, save $

[16:00] <TimToady> we can use augment/supersede to mix into the current DSL

[16:00] <TimToady> so we get things like

[16:00] <pmichaud> I'm not sure that twigil needs to be ascii.

[16:00] <TimToady> I though ~ looks like a strand of a braid, is all

[16:00] <[particle]> all twigils need ascii variants imo

[16:00] <TimToady> *thought

[16:01] <TimToady> things like:

[16:01] <[particle]> yes, ~'s possible. # is a weave

[16:01] <[particle]> ^ is a toupee

[16:01] <TimToady> augment slang Regex { token backslash:sym<Y> {...} }

[16:01] <TimToady> and I like slang as an abbrev for sublanguage

[16:01] <[particle]> slang++

[16:02] <TimToady> because slang is a subset of the current language, not a lang of its own

[16:02] <TimToady> and it is invented for temporary use

[16:02] <TimToady> and may pass out of use after this era

[16:02] <[particle]> as opposed to creole

[16:02] <moritz_> .oO( you can solve any problem by inventing more syntax for it )

[16:02] <TimToady> yes, all the other words for lingos and such imply an entire language

[16:02] <TimToady> more than they do a subset of the current language

[16:03] <pmichaud> ooc, where does "dialect" fit in?

[16:03] <TimToady> well, there are linguistic terms, but they're unworkable, like "register"

[16:03] <TimToady> a dialect is also a complete patois

[16:03] <[particle]> dialect isn't a subset.

[16:03] <pmichaud> okay.

[16:03] <TimToady> *patoís (sp?)

[16:04] <pmichaud> it will be interesting to see when things graduate from being "slang" to being "official Perl 6"  :-)

[16:04] <TimToady> anyway, I think slang will do

[16:04] <TimToady> yes, it works well culturally as well

[16:04] <pmichaud> (yes, I know, that all slang is officially Perl 6...)

[16:04] * ruoso back from lunch

[16:04] <TimToady> it's really the right word

[16:04] <pmichaud> agreed.

[16:04] <ruoso> TimToady, the problem with using the name 'meta' is that it wrongly points to the metaclass (HOW)

[16:04] <clintongormley> the difference between a language and a dialect? an army and a navy

[16:04] <[particle]> std is the perl equivalent of oed.

[16:05] <moritz_> lisp has s-expressions, perl has s-languages ;-)

[16:05] <ruoso> TimToady, this is not a meta method, because meta methods are the one defined in the metaclass already

[16:05] <pmichaud> actually, I think std is more like "the Queen's English"

[16:05] <TimToady> and then we get to use the augment/supersede distinction to decide whether we're mixing in the slang or replacing the strand entirely

[16:06] <ruoso> TimToady, they are simply methods that are treated differently, as submethods are

[16:06] <TimToady> ruoso: but it's semi-meta in that it's primarily used as a carrier of .HOW information

[16:06] <ruoso> not really...

[16:06] <TimToady> well, I have other names up my sleeve too

[16:06] <ruoso> specially in the way rakudo is pointing now (which is to work as smop)

[16:07] <TimToady> a generic method is a policy

[16:07] <TimToady> so we could have policy, policymethod, and method

[16:07] *** Patterner left
[16:07] *** Psyche^ is now known as Patterner

[16:07] <ruoso> we're now pointing to storing the methods in the type object, and no longer in the HOW

[16:07] <ruoso> so the HOW is generic to all things that behave like that

[16:07] <ruoso> i.e. ClassHOW

[16:08] <pmichaud> ruoso: note that jnthn++ may be reconsidering rakudo's smop-ness

[16:08] <pmichaud> or, more precisely, that rakudo today may not be so far away from smop as initially thought

[16:09] <ruoso> but even then... the HOW defines how things in general work

[16:09] <ruoso> i.e. how classes work

[16:09] <ruoso> how roles work

[16:09] <ruoso> metamethods are part of the HOW protocol

[16:09] <pmichaud> 15:34 <jnthn> Anyway what I've essentially figured is that smop doesn't really do the "type objects and instances are the same type" any more literally than we currently do  it in Rakudo.

[16:09] <TimToady> though getting people to write "policy new" will be an interesting trick

[16:10] <TimToady> and requiring "policymethod" for something that responds either way will certainly discourage that practice

[16:10] * ruoso whispers "static"

[16:10] *** iblechbot left
[16:10] * TimToady shoots ruoso after carefully installing the silencer

[16:11] * pmichaud thinks he might've heard something, somewhere.  Probably not.

[16:11] * moritz_ enjoys the silence in the wood, where no tree has fallen

[16:11] <[particle]> virtual silence.

[16:12] <ruoso> TimToady, I guess they are not really methods

[16:12] <pmichaud> this would end up being interesting from a PGE/Rakudo perspective, though, where most tokens and rules expect to be handled more as "policymethods" than "methods"

[16:12] <ruoso> since a method is something you call on the object

[16:13] <TimToady> I guess I missed

[16:13] <[particle]> bullets for sale!

[16:14] * ruoso bullet-proof-jacket++

[16:14] <TimToady> maybe method is the middle one, and we need a concrete name

[16:14] <[particle]> landmine new {...}

[16:14] <moritz_> [particle]++

[16:14] <TimToady> so abstraction vs method vs concretion

[16:14] <ruoso> method being the middle one is cool

[16:15] <ruoso> because that is what most perl users expect

[16:15] *** Woody2143 left
[16:15] <TimToady> there a madness to it

[16:15] <[particle]> because that is what most perl users expect

[16:15] *** Woody2143 joined
[16:15] <pmichaud> it does mean that "method foo() { say $!x }"   still has to figure out how to respond to Type.foo .... but I'd probably be able to live with that.

[16:16] <pmichaud> (since we're already looking at living with that in the present state of things)

[16:16] <ruoso> just as in p5

[16:16] <TimToady> it just sets both notional bits, I respond to abstract/concrete calls

[16:16] *** iblechbot joined
[16:17] <pmichaud> do we have abstract/concrete submethods?

[16:17] <pmichaud> or does that not make any sense?

[16:18] <TimToady> submethods are particularly about partial objects

[16:18] <TimToady> and partially valid objects

[16:18] <ruoso> it's another axis

[16:18] <TimToady> they're infrastructure

[16:18] <TimToady> not ultrastructure

[16:18] * ruoso feels a glimpse of marxism...

[16:18] <[particle]> hyperdimensional spaces are groovy

[16:19] <pmichaud> [particle]1: I always thought of them as being more stringy :-)

[16:19] <TimToady> THE FROOT FLAIS ARE COMMING!!!

[16:19] <pmichaud> PLZ TO KEEP THE FROOT FLAIS AWAY FROM MY FROOT LOOPS.

[16:20] <moritz_> what are we doing today, then? string theory or science?;-) 

[16:20] <TimToady> the two are not mutually inclusive

[16:21] <moritz_> no, but only rarely overlapping, it seems

[16:21] *** a3r0 joined
[16:22] *** bejuryu joined
[16:23] <TimToady> let's throw out method, and go for solid/liquid/gas, and for the really academic type stuff, plasma

[16:23] <TimToady> liquid new () {...}

[16:23] <TimToady> gas ACCEPTS

[16:24] <TimToady> triplepoint WHAT

[16:24] <moritz_> and if we want more aggregate types, we can revert to BEC (bose einstein condensate)

[16:24] <TimToady> bose BUILD

[16:25] <TimToady> or maybe more like quantumfoam BUILD

[16:26] *** rindolf joined
[16:26] <TimToady> and we measure everything with units of ℎ instead of bits

[16:27] * ruoso opens a wormhole to bring everyone back to the point

[16:28] <pugs_svn> r26729 | lwall++ | [STD] add in slang declarator and twigil

[16:28] * TimToady feels singularly good

[16:28] *** nihiliad joined
[16:29] <[particle]> timtoady is a boson

[16:30] <[particle]> ...just when you think the spec has settled down...

[16:30] <TimToady> that's obvious to the most casual observer, oh drat...!@#$!(@*#($*(!@*#$*#(!$@#$

[16:30] <TimToady> I haven't specced it yet, just implemented it. :)

[16:31] <[particle]> ...along comes an implementation to prove that wrong.

[16:31] <TimToady> you shouldn't have observed the design until you were in the correct universe

[16:33] * ruoso considers this is not a change with huge impact

[16:33] <ruoso> the change in the way capture works was much heavier

[16:34] <TimToady> which change are you referring to, dispatch or slangs?

[16:34] <ruoso> dispatch

[16:34] *** clintongormley left
[16:35] <TimToady> well, the real design question is whether method should default to both or to concrete only

[16:35] <ruoso> IMNSHO, method should be both

[16:36] <TimToady> and it's in the defaults where we'll make most of our "new mistakes"

[16:36] <ruoso> Perl developers are already used for methods to have this dual-life

[16:36] <[particle]> perl 6 has proven again and again that perl developers are often wrong

[16:36] <TimToady> and swear at it occasionally

[16:37] <[particle]> although perl 6 hasn't proven that perl 6 developers are often right

[16:37] <TimToady> anyway, "P5 does it that way" is not a strong argument around here these days  :)

[16:37] <ruoso> even in Perl 6 we use this dual life...

[16:37] <TimToady> What Would Perl 5 Do?

[16:37] <ruoso> $x.new

[16:38] <TimToady> yes, but what if that ability had to be requested specially?

[16:38] <ruoso> the point is that the code in new can work with both an abstract and a concrete object

[16:39] <TimToady> and would setting the default more strictly help the optimizer

[16:39] <TimToady> yes, I'm not arguing with that

[16:39] <TimToady> the question is whether that should be the defalut

[16:39] <TimToady> *default

[16:40] *** kst joined
[16:40] <TimToady> is it worthwhile to say that a normal method can never be called with an invalid object, to put it another way

[16:41] <TimToady> in a Haskellian sense, do we build in Just typing a little harder than we have

[16:41] <ruoso> TimToady, point taken

[16:42] * ruoso .oO(what is a slang anyway?)

[16:42] <TimToady> backlog

[16:43] <TimToady> about 50 minutes ago

[16:43] <TimToady> just after pmichaud's brane exploded

[16:44] * ruoso foudn

[16:44] <ruoso> *found

[16:45] <TimToady> but the short answer, a current sublanguage such as Q or Regex

[16:46] <ruoso> so, we agree that there should be the different dispatching for type objects vs instances

[16:46] <ruoso> and instead of fallbacks, we have methods that are visible in both lookups

[16:47] *** samlh left
[16:47] <TimToady> we agree that the dispatcher should be able to restrict itself to abstract or concrete instances when it wants to

[16:47] <TimToady> that's not quite right either

[16:47] *** a3r0 left
[16:48] <ruoso> it's the method that chooses when to be seen, not the object... right?

[16:48] <TimToady> an instance's valid bit may be used by some candidates to disqualify themselves

[16:48] <TimToady> yes

[16:49] *** iblechbot left
[16:49] <TimToady> that being said, an optimizer might refactor that into multiple candidate lists

[16:49] <ruoso> but does that only applies to multi methods?

[16:50] <ruoso> I think that conceptually you have two candidate lists from start

[16:50] <TimToady> multi is orthogonal

[16:50] <ruoso> right... 

[16:50] <TimToady> no, if you have only two lists, you cna't easily dispatch to both at once

[16:50] <ruoso> it's just that candidate is usually used in the context of the multi dispatcher

[16:51] <TimToady> I use "candidate" for much more than that

[16:51] <ruoso> right... 

[16:51] <TimToady> all the single dipsatch candidates are also in a list

[16:51] <TimToady> wrapped routines are in a candidate list

[16:52] <TimToady> anything where "nextsame" means "Ignore me, keep trying"

[16:52] <ruoso> right

[16:53] <TimToady> again, only/multi is namespace management more than candidate list management

[16:54] <ruoso> Ok... 

[16:55] <TimToady> whether the name is a Highlander Name

[16:55] <TimToady> or whether we need to consider longnames

[16:55] <ruoso> so... I think it's a matter of visibility...

[16:55] <TimToady> or some other form of non-uniqueness

[16:55] *** cdarroch joined
[16:55] <ruoso> we have methods that are visible only to abstract objects, only to instances, and to both

[16:56] <ruoso> it's in an axis near the my/has/our axis

[16:56] *** alanhaggai left
[16:56] <ruoso> but it's still a different axis

[16:57] <TimToady> anyway, still thinking about defaults and huffman

[16:57] <pmichaud> lunch.

[16:58] <TimToady> biab &

[17:14] *** PhatEddy left
[17:27] *** cavelife^ joined
[17:29] <TimToady> it's starting to feel a lot more like a constraint on the invocant to me

[17:29] <TimToady> (which could theoretically be a constraint on any parameter)

[17:30] <TimToady> so whatever the notation, it desugars to ($self where { .STATE === BUILT }: ...) or some such

[17:30] <TimToady> assuming .STATE is a .WHAT-like macro

[17:31] <TimToady> or maybe it's .WHEN, as in when are we in this object's lifecycle

[17:31] <TimToady> and there could be more state than just BUILT vs UNBUILT

[17:32] <TimToady> we could say, for instance, that only submethods may be called on objects in BUILDING or DESTROYING state

[17:32] <ruoso> right... but that would require a multi for you to have different implementations for the two states

[17:33] *** DemoPhreak joined
[17:33] <TimToady> which is why it's orthogonal

[17:33] <TimToady> and why it's really a sig constraint

[17:33] <ruoso> but I mean...

[17:33] <ruoso> you might want to implement that on "only" methods

[17:33] <TimToady> that?

[17:34] <ruoso> different versions of the method, one for BUILT and other for UNBUILT

[17:34] <TimToady> then you're distinguishin on the sig, and it's a multi

[17:35] <ruoso> I see that's what you meant

[17:35] <TimToady> I think we could use a concise syntax for saying that a given parameter must be built

[17:36] <TimToady> use on an invocate is a degenerate case then

[17:36] <TimToady> *invocant

[17:36] <TimToady> unfortunately we've already used ? and ! in parameters

[17:37] <ruoso> I think we shouldn't promote asking that instead of .defined for other objects

[17:37] <TimToady> maybe defined === built

[17:37] <ruoso> by default it is

[17:37] <TimToady> and we don't give people a choce

[17:37] <TimToady> *choice

[17:37] <ruoso> it already is

[17:38] <ruoso> hmm...

[17:38] <ruoso> being able to override was precisely the reason I said that we shouldn't promote it

[17:39] <ruoso> but my point is that checking the invocant of a method is not intrusive....

[17:39] <ruoso> checking other parameters seems intrusive

[17:40] <TimToady> how is it any more intrusive than any other constraint?

[17:40] <TimToady> I don't understand the harm

[17:40] <ruoso> it's not the constraint that is intrusive

[17:40] <ruoso> is asking something that can't be overriden that is

[17:41] <TimToady> something has to be primitive; ain't gonna apologize for that

[17:41] <[particle]> can you replace the dispatcher?

[17:41] <TimToady> certainly

[17:42] <ruoso> TimToady, the point is that if we restrict that checking to the invocant

[17:42] <ruoso> that checking can be made in the dispatcher

[17:42] <TimToady> you do it every time you say .* instead of .

[17:42] <ruoso> which is in the HOW

[17:42] <TimToady> the dispatcher already throws out candidates that cannot bind

[17:42] <ruoso> and the HOW is the one that talks to the primitives

[17:43] <TimToady> if the dispatcher pays attention to this constraint, it's an *optimization*

[17:43] <ruoso> my point is about keeping that kind of check in the object's HOW

[17:43] <ruoso> ok... let me take one step back... I'm actually wondering if doing that in the signature is actually a good idea...

[17:45] <ruoso> when the HOW is already using primitives and is able to do it fairly easily

[17:46] <ruoso> we would only need a way for the method to define its visibility concerning the invocant state

[17:48] *** DemoFreak left
[17:48] <TimToady> a dispatcher can hoist any declared (immutable) constraints out of the declaration for optimization, but I still think the right place to hang a constraint on a parameter is in the sig, in general

[17:49] <TimToady> and the invocant is an ordinary parameter these days

[17:49] <ruoso> it is, but it isn't

[17:49] <TimToady> it's only special to the dispatcher

[17:49] <ruoso> it is in the capture with no special handling for it

[17:49] <ruoso> exactly

[17:49] <TimToady> ^^

[17:49] <ruoso> that's my point

[17:50] <TimToady> so optimizing outside the dispatcher is *premature*

[17:51] <ruoso> sorry... i misread your previous line

[17:51] <ruoso> it's not special only to the dispatcher

[17:51] <ruoso> it's special in the sense that it's already extracted from the capture before sending to the dispatcher

[17:51] <TimToady> no

[17:51] <ruoso> it needs to be, in order to find the HOW

[17:52] <ruoso> in order to call the dispatcher

[17:52] <ruoso> (extracted, but not removed

[17:52] <TimToady> we're calling two different things the dispatcher here, I think

[17:52] <ruoso> maybe

[17:52] <ruoso> we have the dotty op

[17:53] <ruoso> which knows how to call the dispatcher

[17:53] <ruoso> and we have the dispatcher

[17:53] <ruoso> which resides in the HOW

[17:54] <ruoso> so... 

[17:54] <ruoso> $foo.bar 

[17:54] <ruoso> is actually

[17:54] <ruoso> $foo.^dispatch($foo, 'bar', \($foo))

[17:54] <ruoso> sorry

[17:54] <ruoso> $foo.HOW.dispatch($foo, 'bar', \($foo))

[17:54] <ruoso> or...

[17:54] <ruoso> $foo.^dispatch('bar', \($foo))

[17:55] <ruoso> but the last one is really a syntax sugar for the longer 

[17:56] <TimToady> that's still the outer dispatcher

[17:56] <ruoso> exactly...

[17:56] <ruoso> the dispatcher itself is in the HOW

[17:56] <TimToady> there's an inner dispatcher loop that the outer dispatcher can factor things out of

[17:56] <TimToady> like which candidates might match

[17:56] <ruoso> hm?

[17:56] <ruoso> which inner dispatcher you mean

[17:56] <ruoso> ?

[17:56] <TimToady> the loop that nextsame interates

[17:57] <TimToady> *iterates

[17:57] <ruoso> I was considering that to be inside the dispatch metamethod

[17:57] <TimToady> which is the same for all dispatchers

[17:58] <ruoso> nextsame just throws a control exception that the metamethod knows how to handle... (or something like that)

[17:59] <TimToady> $obj.@candidates is calling the low-level dispatcher, I think

[18:00] <ruoso> hmm...

[18:00] <TimToady> so you can view any high-level dispatcher as setting up @candidates and calling that

[18:00] <ruoso> I always thougth that as invoking subs as methods...

[18:00] <ruoso> hmm...

[18:00] <TimToady> that's what a low-level dispatcher does!

[18:00] <TimToady> methods as subs, rather

[18:00] <ruoso> you mean $obj.@candidates enables nextsame?

[18:01] <TimToady> yes

[18:01] *** alester joined
[18:01] <ruoso> hmm...

[18:01] <TimToady> it's the minimal dispatcher loop over a (lazy) list that handles nextsame

[18:01] <ruoso> I wasn't aware of that

[18:01] <TimToady> with the candidate list generation factored out

[18:01] <TimToady> that's the intent

[18:02] <ruoso> I thought it was just a syntax sugar

[18:02] <TimToady> outside of that is some kind of WALK thing

[18:02] <TimToady> that generates @candidates

[18:02] <TimToady> it's notional, of course, and a given outer dispatcher can cheat

[18:02] <TimToady> but fundamentally, here's a list of candidates, try calling them in order till one works

[18:03] <ruoso> hmmm

[18:03] <ruoso> didn't $foo.@candidates mean call all of @candidates?

[18:03] <TimToady> and the fundamential difference between single and multi dispatch is where we look for the outer dispatcher

[18:03] <TimToady> that would be .*@candidates

[18:04] <TimToady> a different fundamental loop

[18:04] <TimToady> which is missing a "last" after the first success

[18:05] <ruoso> ok...

[18:05] <ruoso> anyway... that doesn't change my first question

[18:05] <TimToady> we'll have to ask your mama what your first question was

[18:05] <ruoso> ;)

[18:06] *** nbrown_ joined
[18:06] <ruoso> the HOW can build a list according to the state of the invocant

[18:07] <ruoso> I mean... it doesn't need to be in the signature

[18:07] <ruoso> it can simply be an attribute of the method, not of the method's signature

[18:07] <ruoso> the visibility of the method, according to the invocant's state

[18:07] <TimToady> and then what happens if you call it as a sub outside of a dispatcher, it suddenly allows bad data?

[18:08] *** M_o_C joined
[18:08] <TimToady> signature are already designed to apply constraints

[18:09] <ruoso> there are a lot of bad things that can happen by using methods as subs anyway

[18:09] <TimToady> duplicating that functionality is the job of an optimizer

[18:09] <TimToady> that's why we distinguish the call syntaxes so that doesn't happen, so no argument

[18:10] <ruoso> exactly... so... as long as you use methods as methods, everytihng is ok

[18:10] <ruoso> even if the signature doesn't check it

[18:10] <ruoso> if you use methods as subs, you should know what you're doing

[18:10] <TimToady> if the optimizer can cheat without getting caught, that's fine :)

[18:11] <TimToady> but the very dispatchers are relying on the fact that methods can be called as subs, in my view

[18:11] *** iblechbot joined
[18:11] <ruoso> but then can still be called as subs

[18:11] <ruoso> s/then/they/

[18:12] <TimToady> the *sub* dispatcher should not be penalized for the *method* dispatcher's cheating

[18:12] <TimToady> the constraint should be enforced by the sig when the sub dispatcher call it

[18:13] <TimToady> (but we have the same issue with other invocant type checks too)

[18:13] <ruoso> alright... I rest my case ;)... 

[18:16] <TimToady> rakudo: class A { method x () { say "oops" }; method test { &x.(42) } }; 

[18:16] <p6eval> rakudo 52419b:  ( no output )

[18:16] <TimToady> rakudo: class A { method x () { say "oops" }; method test { &x.(42) } }; A.new.test

[18:16] <p6eval> rakudo 52419b: OUTPUT«oops␤»

[18:16] <TimToady> should probably fail the sub call

[18:17] <TimToady> since 42 isn't an A

[18:17] <ruoso> that's because the dispatcher is looking at the invocant ;) not the signature ;)

[18:19] *** meppl joined
[18:19] <TimToady> in pure type theory the A is a constraint on the invocant, and the single dispatch order merely falls out of that

[18:19] <TimToady> so a sig test is redundant, but in type theory that doesn't matter

[18:20] <TimToady> so I think the dispatcher doing part of the signature's work should be considered an optmization, presuming we can disable the redundant check in the sig

[18:20] <TimToady> but the check is notionally part of the sig

[18:21] <TimToady> every invocant is notionally constrained to the class it's declared in

[18:21] <TimToady> and I think the sub call should enforce that too

[18:21] *** mizioumt1 joined
[18:22] <TimToady> unless the dispatcher specifically disables it because it already knows

[18:22] <ruoso> alright... that's indeed a design decision...

[18:23] * TimToady bows and knocks his head on the desk

[18:23] *** nbrown left
[18:23] *** nbrown_ is now known as nbrown

[18:24] * ruoso hopes it didn't hurt

[18:24] <TimToady> all that being said, the build status can be a special constraint; doesn't have to really be a role or a where

[18:24] *** hudnix left
[18:24] <ruoso> I think it doesn't even need to be .WHEN

[18:24] <ruoso> but simply .BUILT

[18:24] <ruoso> that returns true or false

[18:25] <TimToady> well, the parent part of an object can think it's built before the child part thinks it

[18:25] <ruoso> hm?

[18:26] <TimToady> BUILDALL isn't atomic

[18:26] <TimToady> when there's derivation

[18:26] <ruoso> well... sure... but... inside buildall there is one operation that is

[18:26] <ruoso> which is the one that initializes the instance storage

[18:26] <ruoso> ah... ok

[18:26] <TimToady> but that's when you start building, not when the data is there

[18:26] <ruoso> I've been thinking of BUILT as "having instance storage"

[18:27] <TimToady> it goes through states to get from empty to full

[18:27] <ruoso> right...

[18:27] <TimToady> and it's not clear which of those states might be intersting

[18:27] <ruoso> actually..

[18:27] <ruoso> it goes building from least-to-most specific

[18:27] <TimToady> can you call a .BUILT method on the parent part of an object that is partly built, for instance

[18:29] <TimToady> does each parent class keep its own "built" status?

[18:29] <ruoso> but it shouldn't be considered built anyhow before the end

[18:29] <ruoso> because a subclass might override

[18:29] <ruoso> almost any behavior

[18:29] <TimToady> should be able to rely on Liskov

[18:29] <ruoso> so it should only be BUILT in the end of BUILDALL

[18:30] <TimToady> the child's BUILD should be able to treat the already built object as a valid instance of the parent object, it would seem

[18:31] <TimToady> otherwise it wouldn't matter what order we did the BUILDs

[18:31] <TimToady> they don't necesarily have to track all their build states, as long as we know where the transition is

[18:32] <ruoso> well... 

[18:32] <ruoso> actually...

[18:33] *** rindolf left
[18:33] <TimToady> one could almost view BUILD as taking a parent object and transmuting it into a "me" object

[18:34] * ruoso trying to figure out how that fits together

[18:34] *** mizioumt left
[18:34] <TimToady> so any virtual method in a BUILD actually starts looking in the parent class (assuming C3 for siblings)

[18:35] <ruoso> geez... that looks uterly complicated

[18:35] <TimToady> eh? the only difference from what we have now is the low-level blessing at the end of BUILD from the parent to the actual class

[18:35] <ruoso> plus the C3 thing

[18:36] <TimToady> that's already there

[18:36] <ruoso> is it

[18:36] <ruoso> ?

[18:36] <TimToady> implied in the BUILDALL semantics

[18:36] <TimToady> how the heck are you going to do MI without constructing all the parents?

[18:36] <ruoso> that's not the problem

[18:36] <TimToady> and C3 is already mandated

[18:37] <ruoso> the problem is preserving C3 semantics during BUIDL

[18:37] <TimToady> I think of C3 as a way of making MI look like SI

[18:37] <TimToady> that's all

[18:37] <ruoso> in a A - B, C - D heart-shaped MI

[18:37] <ruoso> we build in the following order

[18:37] <TimToady> and for purposes of BUILDALL, that's all you need, I think

[18:37] <ruoso> A, B, C, D

[18:37] <ruoso> so, 

[18:38] <ruoso> in the end of A's BUILD it low-level blesses it as A

[18:38] <ruoso> in the end of B it low-level blesses it as B

[18:38] <ruoso> and has A as parent

[18:38] <ruoso> in the end of C, it low-level blesses it as C

[18:38] <ruoso> which has A as parent, and B is now out of the picture

[18:39] <TimToady> alternately, the BUILDING state means trust anything that's not me

[18:39] <ruoso> then, during D's BUILD

[18:40] <TimToady> so we low-level bless into new class, but $.foo doesn't dispatch to me, only to all my parents

[18:40] <TimToady> until BUILD is done

[18:40] <TimToady> well, something like that.

[18:41] <TimToady> we need to be able to define the new thing in terms of more primitive things

[18:41] <TimToady> and it would be nice not to call anything that requires BUILT on the part of the object that ain't yet

[18:42] <ruoso> maybe we just assume that we bless to the current class before calling BUILD

[18:42] <TimToady> so probably three-way constraint, unbuilt, building, and built is sufficient for BUILDALL policy

[18:43] <TimToady> ruoso: sure

[18:43] *** hudnix joined
[18:43] <TimToady> but that tends to make me want to say that by default "method" requires built

[18:43] <ruoso> which would mean that BUILD sees the object already as its own

[18:44] <TimToady> and we need to know more to allow on something that building

[18:44] <TimToady> that is building

[18:44] <TimToady> hmm, but then parent methods won't work, unless we know which class we're building

[18:45] <TimToady> we can assume that if our method is not in the class that the object is already blessed into,

[18:45] <TimToady> then that part is built

[18:45] <TimToady> I think

[18:46] <TimToady> so state == building implies an additional check to see if $obj.WHAT === $?CLASS

[18:46] <TimToady> built state is "yes/no/maybe"  :)

[18:46] <TimToady> or yes/no/it depends

[18:47] <[particle]> or abstract/method/concrete :)

[18:47] <TimToady> yes/no/anyone but Joe

[18:47] <TimToady> biab &

[18:49] <ruoso> what about .BUILT(type)

[18:52] *** alester left
[18:53] *** alester joined
[18:54] <TimToady> more like BUILDING == type, once it's BUILT we don't care, since ordinary inheritance is used to make type decisions

[18:55] <TimToady> were you thinking of type as the $?CLASS, or the type being matched against $?CLASS

[18:56] <TimToady> if .BUILT($?CLASS), then yes, if BUILDING state examines the parameter and the other states don't

[18:57] <TimToady> gah, noon, and still haven't backlogged...

[19:00] *** exodist left
[19:01] *** amoc left
[19:06] *** DemoFreak joined
[19:12] *** ZuLuuuuuu joined
[19:16] *** nbrown left
[19:17] *** nbrown joined
[19:20] <PerlJam> DHH mentioned perl 6 at railsconf

[19:20] *** DemoPhreak left
[19:20] <PerlJam> he didn't want rails 3 to "get sucked into perl6ism"

[19:21] <Infinoid> we has a famous

[19:24] *** Trashlord joined
[19:31] *** ruoso left
[20:03] *** nihiliad left
[20:07] *** alester left
[20:15] *** icwiener joined
[20:25] *** alester joined
[20:37] <dalek> rakudo: a579f31 | pmichaud++ | docs/spectest-progress.csv:

[20:37] <dalek> rakudo: spectest-progress.csv update: 383 files, 11032 passing, 0 failing

[20:37] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a579f3160bbbac4b9fd1ee3d541c0426741976c1

[20:42] *** nbrown_ joined
[20:43] *** Trashlord left
[20:59] *** nbrown left
[20:59] *** nbrown_ is now known as nbrown

[21:01] *** alialaasami joined
[21:02] *** alialaasami left
[21:02] *** bejuryu left
[21:04] *** frew|work left
[21:08] *** alester left
[21:09] *** frew|work joined
[21:14] *** payload joined
[21:15] *** mberends left
[21:19] *** Whiteknight joined
[21:22] *** skids left
[21:32] <TimToady> n

[21:33] *** simcop2387 left
[21:34] *** pmurias joined
[21:35] * jnthn is back

[21:36] *** simcop2387 joined
[21:37] <jnthn> omfg....OK, I read that backscroll tomorrow.

[21:37] <pmichaud> good $national-holiday ?

[21:37] <jnthn> pmichaud: Yes, in fact I had a nice evening with nice food and beer too.

[21:37] <jnthn> Which was kinda what I needed.

[21:37] <pmichaud> Excellent.  Those are always good to have.

[21:38] <pmichaud> I'm working on some build system cleanups at the moment... getting ready to test + commit.

[21:38] <pmichaud> er, test + push.

[21:38] * jnthn didn't sleep too weel last night because he couldn't stop thinking about the Perl 6 object model and metaclasses and representation polymorphism and smop guts and Parrot guts and Rakudo guts and...uff. :-)

[21:38] <jnthn> *well

[21:39] <jnthn> Build system cleanup is a Good Thing.

[21:40] <pmichaud> I didn't sleep well because other house occupants kept waking me.

[21:40] <pmichaud> :-)

[21:41] <jnthn> Ah, that's a different problem.

[21:41] <jnthn> :-)

[21:41] * jnthn doesn't have other house occupants, and it's both a good and a bad thing.

[21:43] <jnthn> I feel like I've spent the week trying to work out how the whole metaclasses and representation stuff is going to play out, and I'm not convinced I'm much further forward than at the start of the week. :-(

[21:44] *** simcop2387 left
[21:44] <pmichaud> I think we clarified the issues a lot, though.

[21:44] <jnthn> True.

[21:45] <pmichaud> That's progress, even if it's not measurable directly in code yet.

[21:45] <jnthn> Sure.

[21:45] <jnthn> I think for a while I had the idea that smop had a lot more things worked out that it actually really does.

[21:45] *** icwiener_ joined
[21:46] <jnthn> Which isn't a criticism, just not quite how it felt before I dug deeper.

[21:46] <meppl> good night

[21:46] *** simcop2387 joined
[21:46] <jnthn> I thought there was a lot more stuff I could take from there than I think we really can.

[21:47] <jnthn> The model seems to be "the most derived class owns the representation of the attributes".

[21:48] <jnthn> I don't think that's going to fly.

[21:49] *** meppl left
[21:49] <pmichaud> afk for a bit

[21:52] *** donaldh joined
[21:55] *** hudnix left
[22:00] *** icwiener left
[22:05] <pugs_svn> r26730 | jnthn++ | [t/spec] Unfudge block default parameter type tests for Rakudo.

[22:07] *** mizioumt1 left
[22:07] *** simcop2387-vnc joined
[22:07] <dalek> rakudo: f01d5d6 | jnthn++ | src/ (2 files):

[22:07] <dalek> rakudo: Make the default parameter type of routines be Any, and the default type of pointy blocks and others be Object. Resolves RT#63920 and brings us in line with the spec.

[22:07] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f01d5d6bae6a5d319a96fae1548751360b3ef28a

[22:09] *** payload left
[22:10] *** ZuLuuuuuu left
[22:14] *** wknight8111 joined
[22:15] <jnthn> pmichaud: I'm going to do more Rakudo stuff tomorrow rather than tonight. It'll work out better. :-)

[22:15] <jnthn> Consider it a distributed Rakudo day.

[22:16] *** Whiteknight left
[22:16] <pmichaud> jnthn: that sounds good.  I expect to be around most of the day tomorrow, also.

[22:16] <jnthn> Cool.

[22:16] <pmichaud> Unless I get called out for other household tasks (but I'm expecting not).

[22:19] <dalek> rakudo: 43f257d | pmichaud++ | :

[22:19] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[22:19] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/43f257d64e97a8802857dd5eb8360229d64c58dd

[22:19] <dalek> rakudo: 1f4ec5d | pmichaud++ | Configure.pl:

[22:19] <dalek> rakudo: Configure now verifies sufficient parrot revision (or dies).

[22:19] <dalek> rakudo: This completes RT #64868.

[22:19] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1f4ec5d5651f83de1fa9a6f03d6a37e01b52adf9

[22:19] *** M_o_C left
[22:23] *** amoc joined
[22:23] *** simcop2387 left
[22:27] <pugs_svn> r26731 | lwall++ | [t/spec] fix an "is also" that is giving STD fits

[22:28] *** DemoFreak left
[22:32] *** frew|work left
[22:34] *** DemoFreak joined
[22:37] *** iblechbot left
[22:40] *** pmurias left
[22:43] <pugs_svn> r26732 | lwall++ | [STD] %*LANG now holds language braid

[22:43] <pugs_svn> r26732 | lwall++ | unify $*PARSER with %*LANG<MAIN>

[22:43] <pugs_svn> r26732 | lwall++ | don't complain on role redefinition

[22:43] *** cdarroch left
[22:56] *** icwiener_ left
[22:58] *** skids joined
[23:07] *** [particle] left
[23:07] *** donaldh left
[23:24] <pugs_svn> r26733 | lwall++ | [S02] take stab at documenting how interwoven languages work

[23:28] *** [particle] joined
[23:39] <jnthn> I'll have to re-read the backlog again tomorrow to fully get it

[23:40] <jnthn> But something like a .STATE === BUILT kinda distinction sounds very sane to me. Best solution I've seen so far.

[23:40] <jnthn> OK, sleep, night all

[23:44] *** antiphase joined
[23:46] *** kate21de joined
