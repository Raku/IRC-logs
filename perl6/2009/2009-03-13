[00:00] <pmichaud> I've noticed that.

[00:00] <pmichaud> actually, I think I'm just exceptionally good at guessing where the spec is likely to change before I work on a feature :-)

[00:03] <TimToady> it's a useful skill, fershure--wish I had it... :)

[00:04] <pugs_svn> r25813 | moritz++ | [irclog] revert broken .htaccess changes

[00:09] <TimToady> bbl &

[00:23] *** tarbo2_ joined
[00:24] *** ujwalic joined
[00:25] *** cspencer left
[00:26] *** ujwalic left
[00:43] *** frioux joined
[00:59] *** yary joined
[01:01] *** Kimtaro left
[01:02] *** ruoso joined
[01:03] <yary> Hi all, I posted a question about arity to perl.perl6.users a couple days ago, and it hasn't shown up yet. So-

[01:03] <ruoso> Hello!

[01:04] <yary> 1, is there something I need to know about posting to that usenet group

[01:04] <yary> 2, here's the Q-

[01:04] <yary> If I make a sub "sub my_arg_example ($a, $b?, $c?) { say $a, $b, $c; }"

[01:05] <yary> how do I ask it for the number of optional arguments?

[01:12] *** Whiteknight left
[01:20] <yary> Need to go, will check for any answer on the logs later

[01:20] <diakopter> yary: I'm sure someone will address it, at some point...

[01:21] <diakopter> :)

[01:21] <yary> thanks, no prob, I appreciate all the volunteers and am not in hurry

[01:21] *** yary left
[01:21] <wayland76> As far as the usenet group goes, I'd never heard of it until you mentioned it, and I've been around here a few weeks

[01:24] *** nihiliad left
[01:29] <wayland76> rakudo: sub my_arg_example ($a, $b?, $c?) { say $a, $b, $c; say +self.signature.params }

[01:29] <p6eval> rakudo 087e29: RESULT«{ ... }»

[01:30] <wayland76> rakudo: sub my_arg_example ($a, $b?, $c?) { say $a, $b, $c; say $?ROUTINE.signature.params } my_arg_example(1, 2, 3)

[01:30] *** eternaleye joined
[01:30] <p6eval> rakudo 087e29: OUTPUT«Statement not terminated properly at line 1, near "my_arg_exa"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[01:30] <wayland76> rakudo: sub my_arg_example ($a, $b?, $c?) { say $a, $b, $c; say $?ROUTINE.signature.params }; my_arg_example(1, 2, 3);

[01:31] <p6eval> rakudo 087e29: OUTPUT«Scope not found for PAST::Var '$?ROUTINE' in my_arg_example␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[01:31] <wayland76> Is that a bug?

[01:32] <wayland76> Anyway, to answer yary's question, I think it's probably $?ROUTINE.signature.params - $?ROUTINE.arity

[01:32] <ruoso> wayland76, isn't it &?ROUTINE?

[01:33] <wayland76> rakudo: sub my_arg_example ($a, $b?, $c?) { say $a, $b, $c; say &?ROUTINE.signature.params - &?ROUTINE.arity }; my_arg_example(1, 2, 3);

[01:33] <wayland76> You're right ruoso

[01:33] <p6eval> rakudo 087e29: OUTPUT«123␤Null PMC access in find_method()␤current instr.: 'my_arg_example' pc 184 (EVAL_17:86)␤»

[01:33] <wayland76> So let me correct that to &?ROUTINE.signature.params - &?ROUTINE.arity

[01:34] <wayland76> But my question is, does he want the number of optional args the routine takes, or the number that have actually been passed?

[01:34] <ruoso> hmmm... I'm not sure asking how many were actually passed is that easy after the bind

[01:35] *** Kimtaro joined
[01:40] <wayland76> yary: ruoso usually knows what he's talking about

[01:40] <wayland76> (more so than me, anyway :) )

[01:47] *** frioux left
[01:47] *** frioux joined
[01:49] <pmichaud> afaik, &?ROUTINE isn't implemented in rakudo yet.

[01:50] <pmichaud> but the other answer is that it's probably &?ROUTINE.count - &?ROUTINE.arity

[01:51] <ruoso> pmichaud, about different arity in multis for reduce... I was thinking that using ~~ is not a good idea, because that happens inside postcircumfix:<( )>

[01:51] <ruoso> maybe that should be yet another argument to postcircumfix:<( )> itself

[01:51] <ruoso> (SMOP already declares :$cc in that signature)

[01:52] <ruoso> (as in "current-continuation")

[01:52] <diakopter> &?ROUTINE is both the routine model and the invocation, an instance of the model?

[01:53] <ruoso> yes, &?ROUTINE is specific to that invocation

[01:53] <ruoso> isn't it?

[01:53] <ruoso> I think it is... but I might be wrong...

[01:53] * diakopter warns you not to look at me :P

[01:53] <diakopter> (for the answer)

[01:53] <diakopter> lol

[01:56] <frioux> is foo bar: syntactically the same as bar.foo?

[01:57] <frioux> or have I been reading things on the mailing list wrong

[01:57] <diakopter> I think you mean to say semantically

[01:58] <frioux> sure

[01:58] <frioux> but isn't Str.chop semantically the same as chop(Str)?

[01:58] <frioux> but that just happens to be because of the is export

[01:58] <frioux> vs foo bar: which would always be the same as bar.foo

[02:00] <ruoso> frioux, yes... the ":" marks it as an indirect syntax

[02:00] <ruoso> std: my $foo; $foo.bar: ;

[02:00] <p6eval> std 25813: OUTPUT«ok 00:02 35m␤»

[02:00] <ruoso> ops

[02:01] <ruoso> std: my $foo; bar $foo: ;

[02:01] <p6eval> std 25813: OUTPUT«ok 00:02 36m␤»

[02:05] <frioux> another question: is 'is export' supposed to automatically export the method?

[02:06] <frioux> I only ask because of the sub split ... in Any-str.pm

[02:12] <ruoso> frioux, yes... that's what "is export" is about

[02:12] <ruoso> but sometimes the method has a different signature than the sub

[02:12] <ruoso> then you need two declarations

[02:13] <ruoso> split is one of them

[02:15] <frioux> ah, ok, understood

[02:15] *** alester joined
[02:15] *** AzureStone left
[02:15] <frioux> I thought that's what is export was for, but I wasn't sure why they also declared split

[02:15] <frioux> thanks ruoso

[02:18] <diakopter> where can I read about bvalues

[02:19] <diakopter> erm

[02:20] <s1n> frioux: are you the same as frooh?

[02:20] <frioux> s1n: yeah

[02:20] <frioux> one's home, one's work

[02:21] * diakopter searched irclog for bvalue and reads

[02:22] <s1n> frioux: okay, so when are we having the first p6m meeting?

[02:23] <frioux> as soon as you are ready!

[02:23] <diakopter> ruoso: 'bvalue' is short for 'bound value' or 'binding value' or ...?

[02:23] <frioux> I figure april would be fine, but we should probably fine more people than the three of us (that includes pmichaud)

[02:23] <frioux> find*

[02:24] <s1n> well, i'll be crazy busy for the next month, 1 meeting is fine, but i don't really want to stretch myself too thin

[02:24] <frioux> of course

[02:24] <frioux> you're in grad school after all

[02:24] <s1n> i have 3 assignments and 2 tests in the next 6 weeks

[02:24] <frioux> you took it further than the rest of us :-)

[02:25] <s1n> so this weekend i might have some time

[02:25] <frioux> well, I would figure that meeting more than once a month might be overkill anyway.

[02:25] <s1n> true

[02:25] <frioux> I have company this weekend, but *generally* I am free on saturdays, so normally that would have worked

[02:26] <s1n> okay, i would say next week(days) after tuesday is the last i can ensure any block of time

[02:27] <frioux> so you are saying the coming monday or tuesday is ok before you are bombarded?

[02:28] <s1n> no, i'm bombarded with work until tuesday

[02:28] <s1n> assignment due

[02:28] *** shinobi-cl joined
[02:28] <frioux> got it

[02:28] <frioux> would you prefer wed, thurs, or next sat?

[02:29] <frioux> I bet I could get some coworkers to come too btw

[02:29] <frioux> at the very least my roommate

[02:29] <shinobi-cl> rakudo: class A { method BUILD {say 'Constructor'} }; my A $Class; 

[02:29] <p6eval> rakudo 087e29: RESULT«A»

[02:29] <shinobi-cl> lol

[02:29] <shinobi-cl> what im thinking ..

[02:30] *** shinobi-cl left
[02:30] * frioux somehow crashed a single window of firefox, but not the whole browser

[02:30] <s1n> frioux: i would say thursday, i'm going to be in the library from sat through wednesday

[02:30] <frioux> alrighty

[02:31] * diakopter starts at S01:1.  again.

[02:31] *** nihiliad joined
[02:31] <frioux> we should find out who all wants to come, and then based on that decide on something like a Barnes and Noble to meet at

[02:31] *** shinobi-cl joined
[02:32] <frioux> if it's just you and me and people frm our area there is probably one on 75 in allen or something

[02:32] <s1n> pmichaud and i have been meeting at the market street in allen because of the free wifi and coffee (not free) :)

[02:33] <ruoso> diakopter, "bindable value"

[02:33] <ruoso> there isn't much beyond SMOP sources and IRC logs

[02:33] <frioux> I'm down with that.

[02:33] <ruoso> I don't think rakudo has anything similar to that

[02:33] <frioux> how about a time?

[02:34] <s1n> 7pm?

[02:34] <frioux> sure

[02:34] <frioux> are you on email?

[02:34] <s1n> yeah

[02:34] <frioux> you wanna msg it to me?

[02:34] <frioux> or if you don't care about spam just say it

[02:35] <s1n> sent

[02:35] <s1n> any news on the p6m domain? we have space ready to go on dallas.p6m.org?

[02:35] <frioux> we apparently have it

[02:35] <frioux> I checked, and it's gotten but it's bare (godaddy bare that is)

[02:36] <ruoso> diakopter, but in summary, it's a proxy for the actual value that remembers where the value comes from... so you can use it as if it was the actual value, but you can also bind something to it, and that will update the place where this value came from

[02:36] <ruoso> it also represents a lazy lookup of the actual value

[02:36] <diakopter> ruoso: ok, so essentially a lazy fetch

[02:37] <ruoso> which is essential so that %a<b><c><d><e><f> doesn't autovivify

[02:37] <s1n> pmichaud: is the hosting space you mentioned the same as rakudo.org?

[02:38] <diakopter> ruoso: is the lookup done by symbol at runtime or can the compiler bind it deterministically always?

[02:38] *** dukeleto joined
[02:38] <ruoso> diakopter, when you have plain variable lookups, yeah.. it can be done...

[02:39] <ruoso> but %a<b><c><d> := 1

[02:39] <ruoso> is a different scenario

[02:39] <ruoso> and that's completely runtime

[02:39] <diakopter> ok, so all the symbols must be persisted for the life of their scope if a usage like that exists?

[02:40] <ruoso> I don't follow

[02:41] <diakopter> hrm.  /me retracts the question; strike from record. 

[02:41] <diakopter> :)

[02:43] *** Limbic_Region left
[02:44] <diakopter> does each "{ use v5; ... }" block have its own __DATA__ and everything?  can a "use v6;" block inside a "use v5;" block interact with the scope of a "use v6;" block that surrounds the "use v5;" block?

[02:45] <frioux> phone&

[02:45] <ruoso> diakopter, that's pretty much undefined behavior yet

[02:45] <diakopter> it smells a tad undefinable

[02:46] <ruoso> for all implementors, it does

[02:46] <ruoso> I think it will heavily depend on implementation

[02:46] <shinobi-cl> rakudo: class A { submethod BUILD { say 'constructor' } }; my $something = A.new; 

[02:46] <p6eval> rakudo 087e29: OUTPUT«too many arguments passed (3) - 1 params expected␤current instr.: 'parrot;A;BUILD' pc 136 (EVAL_20:64)␤»

[02:48] <shinobi-cl> rakudo: class A { submethod BUILD { say 'constructor'; } }; my $something = A.new; 

[02:48] <p6eval> rakudo 087e29: OUTPUT«too many arguments passed (3) - 1 params expected␤current instr.: 'parrot;A;BUILD' pc 136 (EVAL_20:64)␤»

[02:51] <diakopter> ruoso: it seems to me that it would need to be all-or-nothing either way (in order to get all the compiler/interpreter/runtime phases/models to match up in the least...): either the perl5 runtime (embedded, concurrent, whatever) is able to access absolutely everything in the perl6 runtime (so essentially the perl6 implementation *is* in/beside the perl5 engine), *or* the perl6 runtime fully re-implements perl5 so that its Perl 5 is slightly-diet (less su

[02:52] <diakopter> argh; truncated again, didn't it

[02:52] <diakopter> .. its Perl 5 is slightly-diet (less sugary) Perl 6...

[02:53] <diakopter> dietperl

[02:53] <ruoso> well, I think for Inline code there isn't much a reason for not implementing a specific parser

[02:53] <ruoso> but my plan for SMOP do include merging it inside p5

[02:54] <diakopter> that was my understanding

[02:54] <diakopter> (albeit rudimentary)

[02:54] <diakopter> (my understanding, that is)

[02:55] *** alc joined
[02:55] <shinobi-cl> i dont get it.... what im doing wrong?

[02:56] <frioux> what exactly does $foo ~~ Whatever mean?

[03:00] <frioux> rakudo: 0 ~~ Whatever

[03:00] <frioux> rakudo: '' ~~ Whatever

[03:00] <frioux> rakudo: 'frew' ~~ Whatever

[03:01] <p6eval> rakudo 087e29: RESULT«0»

[03:01] <p6eval> rakudo 087e29: RESULT«0»

[03:01] <p6eval> rakudo 087e29: RESULT«0»

[03:01] <frioux> rakudo: nudef ~~ Whatever

[03:01] <frioux> rakudo: undef ~~ Whatever

[03:01] <p6eval> rakudo 087e29: OUTPUT«Could not find non-existent sub nudef␤current instr.: '_block14' pc 79 (EVAL_16:41)␤»

[03:01] <p6eval> rakudo 087e29: RESULT«0»

[03:01] <frioux> rakudo: (undef ~~ Whatever).perl

[03:01] <p6eval> rakudo 087e29: RESULT«"0"»

[03:02] <frioux> rakudo: ([] ~~ Whatever).perl

[03:02] <p6eval> rakudo 087e29: RESULT«"0"»

[03:02] <frioux> rakudo: ('frew') ~~ Whatever

[03:02] <diakopter> ruoso: I guess I'm more than a tiny bit worried/curious that nested-Perl 5 requirement will go away... are there tests for it in t/spec ?  (no)

[03:02] <p6eval> rakudo 087e29: RESULT«0»

[03:02] <frioux> rakudo: ('frew',1) ~~ Whatever

[03:02] <p6eval> rakudo 087e29: RESULT«0»

[03:02] <ruoso> diakopter, I don't think It'll go away... I just think it will be very implementation-specific

[03:03] <frioux> rakudo: my $f; $f ~~ Whatever

[03:03] <p6eval> rakudo 087e29: RESULT«0»

[03:03] <frioux> how is that ever true?

[03:03] <diakopter> ruoso: I mean, it would have to be more further specified which v5?  5.000 by default?

[03:04] <frioux> rakudo: sub foo($bar = *) { $bar ~~ Whatever;  }; foo()

[03:04] <p6eval> rakudo 087e29: RESULT«1»

[03:04] <frioux> rakudo: sub foo($bar = *) { $bar ~~ Whatever;  }; foo(1)

[03:04] <p6eval> rakudo 087e29: RESULT«0»

[03:04] <frioux> weird.

[03:04] *** shinobi-cl left
[03:04] <ruoso> diakopter, I'd argue "the version of p5 installed"... but that wouldn't make sense for parrot

[03:04] <frioux> rakudo: sub foo($bar = *) { $bar ~~ Whatever;  }; foo(1,1)

[03:04] <p6eval> rakudo 087e29: OUTPUT«too many arguments passed (2) - at most 1 params expected␤current instr.: 'foo' pc 84 (EVAL_17:50)␤»

[03:06] <diakopter> ruoso: ... nor any implementation I can imagine that would be embedding a parser... is it { use v5 "for the sake of easy copy-paste"; } or { use v5 "for the sake of something_else I can't think of"; }

[03:08] <diakopter> I mean, if it's just Inline for the sake of doing interesting FFI or some kind of speedup, then some other API (or syntax, or something) should make that easier...  but if it's just Inline for easy copy-paste, then.... I don't see the point.  I'm sure this is an ignorant question.

[03:11] <frioux> why do all the methods in Any-str.pm in the setting have mutli?

[03:11] <frioux> just in case or something?

[03:12] <diakopter> I mean, I can imagine the billions of lines of Perl 5 code out there in .pl and .pm files and inside database records and inside code generators written in Perl or other languages, and someone needs to do some modification, and decides to use Perl 6, so they create a fancy shmancy Perl 6 wrapper/interface to the existing code... I guess I'm having a hard time imagining a good use case for Inline::Perlv5PointWhatever.  I'm not saying there isn't one, I ju

[03:13] <diakopter> Inline::Perlv5PointWhatever.  I'm not saying there isn't one, I just don't see it at the moment

[03:17] <diakopter> but if we're saying that { use v5; } exists to allow writing *new* code in Perl 5 for a Perl 6 implementation, then I again don't see the point... because why would one do that?  Okay, if something is going to be easier/faster/neater/smokier/greener to write in Perl 5 over Perl 6, then doesn't that mean the redesign wasn't worth it?

[03:17] *** ihrd joined
[03:17] <ihrd> rakudo: ::?CLASS

[03:17] <diakopter> or could it just mean that someone is having difficulty switching their mind from Perl 5 mode for the time being and doesn't want to look up the Perl 6 way of doing it for a minute/while...

[03:17] <p6eval> rakudo 087e29: OUTPUT«ResizablePMCArray: Can't pop from an empty array!␤current instr.: 'parrot;Perl6;Grammar;Actions;typename' pc -3011976 ((unknown file):-1)␤»

[03:18] <ruoso> diakopter, I think it's more of an exercise of being able to inline whatever code

[03:18] <ruoso> not just Perl 6

[03:18] <ruoso> Perl 5

[03:18] <ruoso> but maybe Python

[03:18] <ruoso> Java

[03:18] <ruoso> or whatever

[03:19] <diakopter> that line of reasoning argues for the need-to-embed-desugarers-for-all-those-languages-to-Perl-6 eventuality

[03:19] <ruoso> it might make sense because a language might require a type hierarchy that is diverse from Perl 6

[03:19] <ruoso> so writing a small snippet in other language is easier than doing all the conversions

[03:20] <ruoso> that applies very well to Java

[03:20] <ruoso> and might apply to p5

[03:20] <diakopter> ok, but that use case implies that the Java->Perl6 desugarer would need to re-implement the JVM type system in the desugaring process

[03:21] <ruoso> yes

[03:21] <ruoso> but that's not a big deal,

[03:21] <ruoso> since most of the Java core classes are written in java

[03:21] <ruoso> see GNU Classpath

[03:21] <diakopter> seems to me it'd be a big deal

[03:22] <diakopter> I mean, being able to switch syntaxes is one thing.. but semantics?  down to the thousands of backwards-compatible corner cases of a foreign language?

[03:23] <diakopter> yes, I can see how switching out parsers could be done reliably

[03:24] <diakopter> but not reimplementing or generating all the glue interfaces

[03:25] <ruoso> it's unexplored territory actually

[03:25] <ruoso> it needs to be stressed out at some point

[03:26] <diakopter> my thought is that *to do it right*, you'd need a language/interpreter system that literally is not "optimized" at all.  all is malleable/hookable at runtime, all the abstractions are hierarchical, and the entire language system is generalized enough to encompass all other languages' semantics.  in the ideal case.  of course, it's not an unapproachable ideal.  That is, the direction toward that ideal is decently sketched.

[03:27] <diakopter> other languages' semantics.  in the ideal case.  of course, it's not an unapproachable ideal.  That is, the direction toward that ideal is

[03:27] <diakopter> decently sketched.

[03:27] <diakopter> I need to press Enter more often

[03:27] <diakopter> or less often, I guess :)

[03:29] * diakopter sighs and goes back to throwing rocks from a glass house built on sand.

[03:29] <ruoso> diakopter, there is a barrier in Perl 6 that not many other languages support

[03:29] <ruoso> actually, I'm not aware of any

[03:29] <ruoso> which is that the object internal repesentation is not assumed

[03:30] <ruoso> that provides an incredibly high level of interoperation

[03:30] <diakopter> reword/restate plz?

[03:30] <ruoso> in theory, 

[03:30] <ruoso> you can define a class in Perl 6

[03:30] <ruoso> a full-blown hierarchy

[03:30] <ruoso> and say

[03:30] <ruoso> MyClass.bless(Glib.CREATE)

[03:31] <ruoso> and you'll have a Glib object that works with your class

[03:31] <meppl> good night

[03:31] <diakopter> meppl: g'night

[03:31] <meppl> ;)

[03:33] <diakopter> ruoso: trying to understanding how your example congeals

[03:33] <diakopter> trying to understand

[03:33] <frioux> like blood?

[03:33] <diakopter> coalesces.

[03:33] <frioux> I like congeal better...it's more visceral :-)

[03:34] * skids moans

[03:34] <frioux> ?

[03:34] *** meppl left
[03:34] <ruoso> In Java, for instance, both Class and Object have their internal structure assumed

[03:34] <wayland76> Maybe he doesn't like thinking about congealing blood

[03:34] <skids> That was a particularly bad pun, is all.

[03:34] <ruoso> so the Java language can't really work with foreign objects

[03:34] <frioux> hahaha, that's not hard

[03:34] <wayland76> pun?

[03:35] <wayland76> I missed it

[03:35] <frioux> congeal, visceral

[03:35] <skids> visceral, viscous?  well, I guess I hallucinated it.

[03:35] <frioux> not really a pun, but kinda related

[03:35] <frioux> hahaha

[03:35] <frioux> nice

[03:35] <ruoso> in Perl 6 you have: "The representation", "the Metaclass" and the "class"

[03:35] <wayland76> *now* it's funny :)

[03:35] <ruoso> all that to deifine the object

[03:36] <diakopter> alright, the context (a type system unto itself) defines the representations, right?

[03:36] <wayland76> ruoso: We are listening; thanks :)

[03:36] <ruoso> diakopter, Perl 6 uses p6opaque by default

[03:36] <ruoso> Perl 5 would use a SV* of some sort

[03:37] <ruoso> Java would use java object

[03:37] <ruoso> and so on

[03:37] <ruoso> and as long as we get the APIs right

[03:37] <ruoso> you can interoperate them

[03:38] <diakopter> right, even with "out " parameters and concurrency and shared memory and such, if it's done right.

[03:38] <diakopter> as long all the necessarily permuted type converters are defined/generated.

[03:38] <ruoso> exactly

[03:38] <ruoso> the point of embedding a different language

[03:39] <ruoso> would be to require less conversions

[03:39] <ruoso> because you would have a single entry point and a single output

[03:39] <ruoso> instead of trying to convert arguments and return values for each individual call

[03:41] <diakopter> hrm.

[03:41] <diakopter> so the Inline block has access to its sibling lexicals through what symbols?

[03:43] * diakopter thinks again about MyClass.bless(Glib.CREATE)

[03:44] <ruoso> well... in theory, the compiler has to detect that the symbol being used is declared outside the scope

[03:44] <ruoso> which means that that value have to be interfaced

[03:44] * diakopter follows you so far

[03:45] <ruoso> and provide an inner version of that symbol already type-mapped

[03:45] <diakopter> ... which implies that the Inline block can't be "compiled" until runtime, unless you set up universal runtime converters

[03:45] <diakopter> casters

[03:46] <diakopter> for non-dynamic type systems

[03:46] <diakopter> I guess kinda like a bvalue, but importingtype-shifting.

[03:47] <diakopter> well, it definitely can't be type-checked in the traditional pre-runtime sense.

[03:48] <ruoso> but that's what a dynamic language is about, isn't it?

[03:48] <ruoso> making all that checkings as late as possible

[03:48] <ruoso> at least one thing we can be sure....

[03:49] <diakopter> although, frankly, I haven't seen very much (any) Perl 6 code (or chatter) that employs such dynamism... it seems that optional typing lends itself to typed objects staying that type for life, but non typed objects remaining... untyped.

[03:49] <ruoso> diakopter, think about runtime mixins

[03:49] <ruoso> that's life-changing

[03:50] <diakopter> ... aside from trivial context-inference and language-defined representations

[03:51] * diakopter thinks about runtime mixins, and expects my life to be changed.

[03:51] <diakopter> ;)

[03:53] <diakopter> sure, that "just" necessitates "type" (mmd decisions) recalculated at each change..... but the primitive types of the various languages should be able to be interfaced somewhat trivially.  I mean, you can always intercept *every* method invocation in your hosted runtime :P

[03:55] <diakopter> (isn't that what you'd have to do?)

[03:56] <ruoso> not really

[03:56] <ruoso> in the case of SMOP and P5 integration

[03:56] <ruoso> the idea is making the invocation completely delegated

[03:56] <ruoso> to wherever the object came from

[03:57] <ruoso> no need to have a SV* with the pointer address stored as an int

[03:58] <diakopter> hm.

[03:58] <ruoso> I need a modified p5 to do that

[03:59] <ruoso> but it's not a huge modification

[03:59] <ruoso> I just need to add a new member on top of SV

[03:59] <ruoso> I presume the same could be done with python (at least the stackless version)

[04:00] <ruoso> and probably smalltalk

[04:01] <diakopter> the CLR gets something comparable with .net4 - a special delegate type whose constructor is lazy/calledback, even outside the managed env

[04:02] <diakopter> so you really could write your program inside-out/backwards.

[04:03] <ruoso> except that in SMOP it's not specific to constructors

[04:03] <ruoso> it applies to absolutely any method call

[04:04] <diakopter> right, but also re-entrant, so the constructor *is* the type manager.

[04:04] <diakopter> since it can declare all its members as callbacks to its own continuation

[04:04] <ruoso> well... it can do whatever it wants...

[04:04] <diakopter> right, that's what I'm saying, *I think*

[04:04] <diakopter> lol

[04:05] <diakopter> ^!bed

[04:06] <ruoso> btw

[04:06] <ruoso> diakopter, that syntax in SMOP means a call supposed to be intercepted by the representation

[04:06] <ruoso> ;)

[04:07] <diakopter> yah

[04:09] <diakopter> tycho's object/actor system hooks the object/invocation system analogously.

[04:11] <diakopter> I'm finding I prefer APIs over syntax.

[04:14] <diakopter> is that bad?

[04:15] <PerlJam> diakopter: what's the difference?

[04:18] <diakopter> to me, some languages have syntax for things that can be expressed in an API that implements the "language feature" (the syntax) using other more-primitive parts of the language... in other words, the syntax can be desugared to a subset of the same language.  so, the syntax isn't really an intrinsic part of the language; it's an extension of some smaller version of the language.

[04:19] <diakopter> ... reducing that logic further leads to the idea of finding the smallest subset of a language that can't be refactored into itself

[04:19] <diakopter> into an implementation on itself, I mean

[04:20] <wayland76> diakopter: It means you're becoming a Python programmer

[04:20] <diakopter> the portion of the language requiring bootstrapping

[04:20] <diakopter> oh?

[04:20] * diakopter muses

[04:20] <wayland76> no, wait, I'm wrong

[04:21] <wayland76> http://en.wikipedia.org/wiki/One_instruction_set_computer

[04:22] <diakopter> but it also implies that a decent way to bootstrap a language might be to work "backwards" from the sugary tips

[04:22] <diakopter> s/implies/suggests/

[04:22] <wayland76> But seriously, it does sound like a Python or PHP sort of thing to do (doing most things via API)

[04:23] <wayland76> Now, have I missed something?  I don't want to stop your musing, in case it's useful :)

[04:26] <diakopter> to clarify, I'm finding I like the wordiness of APIs because they're clearer to me (and newcomers) than syntax.  I mean, golfing is fun to study and play, but I don't think I'm in the minority of developers when I say that it's much easier [for others (and self!)] to comprehend/maintain/support code that isn't golfed (golfable?).

[04:26] <diakopter> I mean, of course it's more fun for those who equate fun with challenging.

[04:27] <wayland76> Well, that's true

[04:27] <wayland76> There are a number of factors involved here

[04:27] <wayland76> The first is, if you have mostly not-so-bright developers, then yes, you're better off with a more B&D language like Python or Java

[04:27] <diakopter> ruoso: ^!bed ended up being a trampoline :P

[04:28] <diakopter> it doesn't have to be not-so-bright... just not-as-bright-as-golfers

[04:28] <wayland76> There are a number of advantages to Perl, though, that can be beneficial if your people can handle them

[04:29] <diakopter> afk :D  will comment l8r

[04:29] <frioux> speaking of, what do you guys think about using advanced techniques with "not-so-bright" devs?

[04:29] <frioux> for example, before I came to my current job they never used map

[04:30] <wayland76> One example is that it teaches you new programming methods.  For example, after I learned Perl, I started doing a lot more with hashes of subs.

[04:30] <wayland76> Which can sometimes eliminate redundant code that would be hard to remove otherwise

[04:30] <wayland76> (without creating a separate class for each)

[04:31] <wayland76> I also made myself learn regex, and the benefits paid off

[04:31] <frioux> hurray for anonymous subroutines :-)

[04:31] <s1n> i am of the opinion that new neural pathways must always be forged and the search for a better way to do things must never end. if it does, you have resigned yourself to a long wait to retirement and will make coworkers miserable for having to review your code

[04:31] <s1n> that's not positive, but i loathe people who "do it for the money"

[04:31] <wayland76> I like Perl because, while I like the control-freakness of other languages, they don't do things the way *I* like, whereas perl lets me :)

[04:32] <frioux> s1n: haha, but it's not (in my experience) hard to win over the people who do it for something other than the love of coding/learning

[04:32] <wayland76> s1n: agreed, with the exception that I wouldn't use the label "do it for the money"

[04:33] <s1n> i've worked with both kinds, and generally, the aforementioned group is the type to refuse to learn basic things like map

[04:33] <s1n> that to me is unacceptable

[04:33] <wayland76> map isn't an advanced technique :)

[04:33] <frioux> wayland76: for people who are used to c it is

[04:33] <s1n> wayland76: that was a shorthand, i was referring to people who treat it like a 9-to-5 and don't care how or what they do

[04:34] <wayland76> frioux: It depends to me how readable it is.  For example, if you're using things that others may not be familiar with, put in as many parens as needed to make things clear :)

[04:34] <frioux> wayland76: agreed.  I have just been mulling over it for a while

[04:34] <s1n> i will forgoe readability at the cost of greater flexibility any day of the week

[04:34] <s1n> i have no sympathy for coworkers who dislike code "because it's hard"

[04:34] <frioux> because when a co-worker came to me a month after I wrote a hash of subroutines and asked what the deal was I started to wonder if it was a bad idea or not

[04:35] <PerlJam> wayland76: the really big thing about perl is that it doesn't constrain you to doing things in whatever ways the language designer decided things should be it done.  It let's you tailor your solution to the actual problem by whatever means are useful.

[04:35] <PerlJam> Java is a good example of a language that constrains you to think about and solve problems in a particular way rather than in the "natural language" of the problem you're trying to solve.

[04:36] <wayland76> PerlJam: That's right, but I think we should apply our own constraints

[04:36] <PerlJam> (python is another weaker example)

[04:36] <wayland76> Btw, you may all be interested in http://www.perl.com/doc/FMTEYEWTK/sort.html

[04:36] <PerlJam> tchrist still lives!

[04:36] <wayland76> (Tom and Randal were big in the Perl community in the early years)

[04:37] <s1n> frioux: a similar story: i was given grief before because i made use of coderefs for parameters because it "could be hard to read and understand", i drew the line there and said "then pick up a book"

[04:37] <wayland76> Anyway, diakopter, does this help?

[04:37] <frioux> s1n: I just told my co-workers that I assumed that they are smart and can figure it out :-)

[04:37] <PerlJam> wayland76: did you just relegate them to a footnote?  :-)

[04:37] <s1n> frioux: my typical response: link to perldoc :)

[04:38] <frioux> well, they know how to look it up on perldoc

[04:38] <frioux> they are willing to learn

[04:38] <frioux> they just care about somethings more than coding

[04:38] <frioux> see, I am learning and writing perl6

[04:38] <frioux> they are reading about politics, playing video games, and raising children

[04:38] <s1n> blah

[04:39] <frioux> I won't criticise them for their choices, but I won't coddle them for them either

[04:39] <frioux> the latter them being the choices

[04:39] <wayland76> PerlJam: Sort of, just in case anyone here is too perl-young to remember them :)

[04:39] <PerlJam> Randal still does IRC you know.

[04:40] <PerlJam> Though he's on #git and #seaside (I think) these days rather than #perl

[04:40] <s1n> the mind is a terrible thing to waste, but that's coming from a 3rd year so i spend all day long learning basically :)

[04:40] <frioux> haha, yeah

[04:41] <wayland76> Well, Tom is still on p6l, and chipped in on a big Unicode argument a couple of months back

[04:41] <wayland76> And his name is on the front of Programming Perl too :)

[04:41] * frioux looks forward to Programming Perl 6

[04:41] <PerlJam> yeah, he rarely participates though.  I guess he's tired of emitting all of that prose  ;)

[04:41] <s1n> wayland76: and about  2 dozen of some highly critical modules

[04:42] <frioux> is Damian still around?

[04:42] <frioux> I read that he does stuff but all Ive seen is the latest OSCON

[04:42] <wayland76> They're still around, but I remember when the only big names were Larry, Tom, and Randal

[04:43] <s1n> frioux: he did oscon 2008

[04:43] <frioux> s1n: yeah, but he hardly spoke of perl6

[04:43] <frioux> which is cool

[04:43] <frioux> but still

[04:43] <PerlJam> wayland76: you must be an oldster.

[04:43] <wayland76> I haven't seen Damian recently, but Larry says that he's still responsible for the POD spec

[04:43] <wayland76> Not that old.  32 :)

[04:43] <wayland76> But I was on clpm when I was 19

[04:44] <s1n> frioux: the tiny perl6 book oreilly made talks about how p6 is a shift from the old gaurde to the new, those guys were the old

[04:44] <PerlJam> cool.   

[04:44] <frioux> I never saw that book

[04:44] <frioux> I thought it was too soon to make a book

[04:44] <frioux> so I didn't buy it

[04:44] <wayland76> is that perl6 and parrot?

[04:44] <s1n> they made one like 2 years ago lol

[04:44] <frioux> exactly

[04:44] <PerlJam> wayland76: I've been programming in perl since 1992 or so.  I'm an oldster (but not that old!)  :)

[04:45] <s1n> it talks about PASM and some PIR, pretty dated now

[04:45] <wayland76> I didn't get on the 'Net until '95

[04:45] <PerlJam> s1n: It's still a fairly good reference on some parrot things.

[04:45] <s1n> first half was about new culture/development and new changes from p5

[04:45] <PerlJam> s1n: most of the ops haven't changed for instance.

[04:45] <s1n> PerlJam: yes, i agree, i used it several times

[04:45] <wayland76> But at that point, I already knew BASIC, Pascal, x86 ASM, and a tiny bit of FORTRAN

[04:45] <PerlJam> (assuming you're talking about "Perl 6 and Parrot Essentials"

[04:45] <PerlJam> )

[04:46] <s1n> PerlJam: yes, i am

[04:46] <PerlJam> and not the older, more outdated book :)

[04:46] <s1n> i bought the first edition immediately, never got the second, waiting for a third :)

[04:46] <wayland76> I'm waiting for Parrot not to be essential :)

[04:46] <s1n> wayland76: that's not nice

[04:46] <s1n> don't bite the hand that feeds you :)

[04:47] <s1n> besides, PIR isn't that bad

[04:47] <wayland76> Well, you know what I mean -- I'm waiting for it to just work, so I don't need to know about it, except in a "I use Linux" sort of way :)

[04:47] <frioux> wayland76: agreed

[04:47] <frioux> I love the idea of parrot

[04:47] <wayland76> (and I've had a kernel patch accepted :) )

[04:48] <frioux> but I hate having error messages from it :-)

[04:48] <PerlJam> s1n: I always describe PIR as the "perl of assembly languages" :)

[04:48] <s1n> PerlJam: that's not bad, but it's only barely an assembly language

[04:49] <s1n> i've done assembly work before and it provides _lots_ of shortcuts and shorthands that you rarely get in languages like MIPS assembler

[04:49] <wayland76> Parrot VM: PANIC: Out of mem!

[04:49] <s1n> wayland76: poor error messages does not constitude poor product quality

[04:49] <frioux> I didn't say it was bad code

[04:49] <wayland76> That's what I get for modifying code I don't understand :)

[04:49] <frioux> I just don't *like* the error messages

[04:50] <frioux> vs perl 5

[04:50] <frioux> nice, palateable, helpful errors :-)

[04:50] <s1n> frioux: and how long as perl5 had to evolve?

[04:50] <frioux> haha, point taken

[04:50] <s1n> give parrot time and patience, it will shine

[04:50] <frioux> Oh I am sure it will

[04:50] <frioux> I hope that all the other langs start using it too

[04:51] <PerlJam> frioux: you know ... TimToady has been putting some really good error messages and such in STD.pm.  I was contemplating adding them to rakudo the other day  (I just have to find time)

[04:51] <frioux> wouldn't it be great if the ruby guys just gave up on all their speed and memory issues because of their weird impl and used parrot?

[04:51] <s1n> an avalanche is often started by the shifting of a single snowflake :)

[04:51] <frioux> PerlJam: I know, I saw that, and I have had good experience with some of the errors in perl 6

[04:51] <frioux> but when it gets to parrot I just know that something is wrong

[04:52] <PerlJam> frioux: experience will teach you what's wrong :)

[04:52] <frioux> I'm sure it will :-)

[04:52] <frioux> at work I do a ton of javascript and the errors there are useless

[04:52] <frioux> so I know what it's like

[04:52] <frioux> and you get used to it

[04:52] <PerlJam> experience and stack traces anyway :)

[04:52] <frioux> but you never like it

[04:52] <frioux> right

[04:53] <wayland76> Btw, as far as shifting error messages to rakudo, it's my impression from the ROADMAP that the possibility of using STD itself isn't too far away

[04:53] <frioux> that would be awesome

[04:54] <wayland76> http://github.com/rakudo/rakudo/blob/ea3283983825a3adc46e5e2e04e286f8ebf178eb/docs/ROADMAP

[04:54] <wayland76> Actually, maybe I'm wrong

[04:54] <wayland76> But it seems like once they get M1 done, it'll be a lot closer

[04:55] <frioux> btw, our on a class method just means not a private method, right?

[04:56] <frioux> in other words a public method

[04:56] <s1n> frioux: isn't adding our to a method redundant? ! turns it private, otherwise it's public right?

[04:56] <TimToady> our on a method now aliases it into the current package, my into the current lexical scope

[04:57] <TimToady> otherwise no alias is made

[04:57] <TimToady> and only the metaobject knows the method

[04:57] <wayland76> sort of like "is export to package"?

[04:57] <frioux> and the package just happens to be the class?

[04:57] <TimToady> yes, only your own package

[04:57] <TimToady> yes

[04:57] <frioux> gnarly.

[04:57] <TimToady> a class is a module is a package

[04:57] <frioux> right

[04:58] <TimToady> except for the meta bits :)

[04:58] <wayland76> Oh :)

[04:58] <wayland76> That answers my next question :)

[04:58] <frioux> lame.  I just got logged out of my blog because it's midnight

[04:58] <s1n> TimToady: i thought my was replaced with !

[04:58] <TimToady> for declaring private methods, yes

[04:59] <PerlJam> TimToady: and what does package Foo; class Bar { our method baz { ... } }   # do ?   :-)

[04:59] <TimToady> if you say my method foo you've got a normal method with a lexcial alias of &foo that can be called as a sub

[04:59] <s1n> is a normal method public?

[04:59] <TimToady> create a &Foo::Bar::baz subroutine

[05:00] <TimToady> along with a method in the Bar class metaobject

[05:00] <TimToady> yes, public

[05:00] <wayland76> s1n: I'm not sure whether you've gotten TimToady's careful distinction between public/private vs. export & scope

[05:00] <wayland76> (maybe not scope)

[05:00] <wayland76> (something, anyway :) )

[05:01] <s1n> i probably haven't

[05:01] <frioux> TimToady: do you know where you said that thing about the STAR language which would just DWIM?

[05:01] <TimToady> yes, has one verb * that does exactly what you want

[05:01] <TimToady> I think I got the language from Hofstadter

[05:02] <PerlJam> Hofstadter++

[05:02] <frioux> interesing; which book?  I didn't think it was in GED

[05:02] <TimToady> but we only use * for nouns in Perl 6 :)

[05:02] <frioux> either way, it's clearly the inspiration

[05:02] <wayland76> I haven't read it, but I have it near my bed

[05:02] <TimToady> seems to me it was GEB

[05:02] <frioux> maybe I should read it again.

[05:02] <frioux> it's been 4 years

[05:03] <wayland76> I heard a similar idea in my first year linguistics class

[05:03] <TimToady> it's been a lot longer for me :)

[05:03] <frioux> haha

[05:03] <TimToady> well, degenerate cases are always somewhat enlightening

[05:03] <TimToady> though not always useful

[05:03] <TimToady> I'm reminded of the cartoon 

[05:03] <TimToady> Gigantor

[05:04] <frioux> never heard of it.

[05:04] <TimToady> where the controller had maybe two buttons on it

[05:04] <wayland76> "No, no, you're saying it in the nominative case.  You need to use the degenerative case"

[05:04] <wayland76> :)

[05:04] <TimToady> but they always did just what the hero wanted

[05:04] <frioux> ah, got it

[05:04] <TimToady> Gigantor being the robot that obeyed the buttons

[05:04] <frioux> right

[05:05] <TimToady> one button must have meant "warmer" and the other one "colder"  :)

[05:05] <frioux> TimToady: can you explain how * is related to Whatever?

[05:05] <TimToady> Whatever is the *type* of *

[05:05] <frioux> I was looking at some code today and it was....strange

[05:05] *** awarefish joined
[05:05] <TimToady> so ~~ Whatever will almost always be false

[05:05] <TimToady> since most types don't *do* Whatever

[05:05] <frioux> ahhhhh

[05:06] <frioux> that explains it

[05:06] <TimToady> however any multi can write some cases in terms of type Whatever

[05:06] <TimToady> and * produces the Whatever value that lands on that multi case

[05:06] <TimToady> so ~~ * matches anything

[05:06] <wayland76> I'm not sure we should be allowed to do that to English :)

[05:06] <TimToady> but the multi is written sub foo (Whatever, Whatever), not (*,*)

[05:07] <TimToady> since it's matching the type

[05:07] <frioux> interesting

[05:07] <frioux> what abut sub ($foo = *) ?

[05:07] <frioux> that's slightly different right?

[05:07] <TimToady> that would just default $foo to *

[05:08] <TimToady> which can be a bit of a problem if you are not expecting to get dwimmery back from the sub

[05:08] <frioux> rakudo: sub foo($bar = *) { $bar ~~ Whatever;  }; foo()

[05:08] <p6eval> rakudo 087e29: RESULT«1»

[05:08] <frioux> rakudo: sub foo($bar = *) { $bar ~~ Whatever;  }; foo(2)

[05:08] <p6eval> rakudo 087e29: RESULT«0»

[05:08] <TimToady> it's really a type of currying, so * + 1 ends up returning a closure

[05:08] <TimToady> which is a kind of type failure if you were expecting a Num, say....

[05:09] <frioux> interesting

[05:09] <TimToady> so generally you don't want to use * at too many removes from the dwimmery

[05:09] <TimToady> or it gets confusing

[05:09] <frioux> haha, well ONE confused me

[05:09] <frioux> but i figured it out

[05:09] <TimToady> like feeding junctions to things that don't expect them

[05:10] <frioux> also: gather and take are awesome, so thanks for that

[05:10] <TimToady> it might work, but you might have trouble explaining why..

[05:10] <TimToady> you're welcome, was partly TheDamian's doing as well, iirc

[05:11] <frioux> well, it's surprising that it wasn't already something you could do simply

[05:11] <TimToady> but it's a nice decoupling of co-routines from the sub call apparatus

[05:11] <frioux> yeah

[05:11] <TimToady> to the extend that I'm not sure P6 even needs official co-routines

[05:11] *** alc left
[05:12] <TimToady> in fact, as soon as you have gather/take it seems like coro is a highly artificial restriction

[05:13] <TimToady> but having lazy lists as an abstraction separate from co-routines and iterators helps a lot with that too

[05:14] *** ruoso left
[05:14] <TimToady> remains to be seen whether we can get the p5 thinkers into that mindset, but lists seemed like the natural place to introduce laziness

[05:14] <frioux> well, I'd love to talk and listen more, but it's midnight here

[05:15] <frioux> night all!

[05:15] <TimToady> g'night

[05:15] <TimToady> they're dropping like flies in Texas, I guess... :)

[05:15] <PerlJam> I'm still up!

[05:16] <TimToady> I should know where you're located...Chicago?

[05:16] <PerlJam> Corpus Christi Texas  :)

[05:16] <TimToady> ah, well, at least it's not planet Houston

[05:19] <TimToady> I've been as close as San Antonio, I guess

[05:21] <s1n> way too lay for those of us with a $DAYJOB :)

[05:21] <s1n> TimToady: btw, i grew up in austin, went to school in san antonio, and now live in dallas :)

[05:22] <TimToady> well, Dallas, that's almost the middle of the country.  :)

[05:22] <TimToady> give or take a couple states

[05:22] <s1n> not my favorite town

[05:22] * bacek_ suspects that TimToady is XKCD author.

[05:23] <s1n> another one bites the dust

[05:23] <s1n> bed&

[05:23] <TimToady> if I were XKCD author I'd have known that you can end a Perl program with a right parenthesis

[05:24] <bacek_> Typos, just for conspiracy reasons :)

[05:24] <TimToady> 'sides, I take my theism seriously  :)

[05:25] <TimToady> I doubt M. Munroe teaches sunday school...

[05:26] <TimToady> or plays drums in his church's worship band...

[05:27] * bacek_ have no idea who are M. Munroe...

[05:28] *** justatheory left
[05:37] *** ilogger2_ joined
[05:37] <araujo> PerlJam, well, that depends, it could also be harder 

[05:37] <araujo> :P

[05:37] <wayland76> News Flash: Sociologists have discovered that all wars are caused by Yak beards!

[05:38] <pmichaud> will there be any need for "yacc"s after Perl 6?  ;-)

[05:38] <wayland76> Strangely enough, the only tool that will shave all yaks, and keep them shaven, is Perl 6, a programming language that has been years in the making

[05:39] <TimToady> I rather suspect there's an endless feed of yaks available, if we want them

[05:39] *** kate21de joined
[05:39] <TimToady> and there will still be the problem of getting someone to pay us to shave them

[05:39] <PerlJam> That rather sounds like O.S.Card's "ansible" where if you imagine it to be, it is.

[05:40] <PerlJam> (assuming I remember the Ender books well enough)

[05:40] <wayland76> Hmm.  I imagine there's no ansible :)

[05:40] <TimToady> my wife knows Scott Card, maybe we can get one from him

[05:40] <wayland76> Ah, to be a celebrity :)

[05:41] <TimToady> actually, only has to do with her writing, not me being a celebrity, or him... :)

[05:41] <wayland76> ok

[05:41] <TimToady> she wrote fiction reviews for a rag he was editing at one point

[05:41] <wayland76> Well, I guess I'll give up my plans to be a Perl celebrity then :)

[05:43] <TimToady> I do believe, like Card, that living one's life is a kind of sacrament

[05:46] <PerlJam> okay, it is now my bed time.  Good night from the body of christ :)

[05:46] * PerlJam sleep &

[05:46] <TimToady> heh

[05:46] <TimToady> night

[05:46] <wayland76> 'night

[05:46] <pmichaud> PerlJam: you're in CRP itself, not annaville or calallen or somewhere bizarre like that?  ;-)

[05:46] <PerlJam> pm: Calallen is within the city limits.

[05:46] <PerlJam> :)

[05:46] <pmichaud> that's what all of the people who live there say, yes.  :-)

[05:47] * PerlJam sleep for real this time &

[05:59] *** ejs joined
[05:59] *** WootKit joined
[06:02] <wayland76> We have a FSNode type that does a portable path, with the path separators as / or \ or whatever, depending on the platform

[06:03] <wayland76> Should we have a MultiPath type that will stringify multiple paths correctly, and join them with the environment variable separator?

[06:04] <wayland76> ie. /path/one:/path/two on Unix, and C:\path\one;C:\path\two on Windows?

[06:04] <wayland76> Or is that something for a library?

[06:15] *** awarefish joined
[07:28] *** DemoFreak joined
[07:32] <Matt-W> rakudo: my $str = "abc"; say $str.index('b');

[07:32] <p6eval> rakudo 087e29: OUTPUT«1␤»

[07:32] <Matt-W> rakudo: my $str = "abc"; say $str.index('f');

[07:32] <p6eval> rakudo 087e29: OUTPUT«Use of uninitialized value␤␤»

[08:09] *** Kimtaro_ joined
[08:10] *** masak joined
[08:11] <mikehh> rakudo (087e299) on parrot r37373 builds make test PASS make spectest FAIL Kubuntu Intrepid i386

[08:11] <masak> nice.

[08:11] <lambdabot> masak: You have 1 new message. '/msg lambdabot @messages' to read it.

[08:12] <masak> @massage

[08:12] <lambdabot> wayland76 said 3d 10h 14m 59s ago: in regards to CPAN6, see http://cpan6.org/ and S22 :)

[08:12] <moritz_> mikehh: what exactly fails?

[08:12] <masak> @clear

[08:12] <lambdabot> Messages cleared.

[08:12] <mikehh> t/spec/S02-literals/sub-calls.rakudo TODO passed:   16

[08:12] <moritz_> that's not a FAIL

[08:13] <mikehh> t/spec/S12-methods/instance.rakudo  Parse errors: Bad plan.  You planned 26 tests but ran 24.

[08:13] <mikehh> thats why I get a FAIL

[08:14] <moritz_> that file was changed in r25813..

[08:14] <mikehh> Failed 1/317 test programs. 0/9406 subtests failed - so not really a FAIL just bad test plan

[08:15] <moritz_> no, changed in r25809...

[08:16] <moritz_> aye. TimToady removed 4 tests and decreased the plan by 2

[08:16] <pugs_svn> r25814 | moritz++ | [t/spec] fix plan in instance.t

[08:16] <moritz_> mikehh: thanks for notifying me

[08:18] *** finanalyst joined
[08:19] <mikehh> I've been building parrot a few times a day and try to build rakudo against it when I do - even if the tests take half-an-hour :-}

[08:19] <szabgab> rakudo: my @x = (1, 2); say "@x = {@x.perl}"

[08:19] <p6eval> rakudo 087e29: OUTPUT«@x = [1, 2]␤»

[08:20] <szabgab> is there a way to reduce that further so I won't even have to write @x twice ?

[08:20] *** ilogger2 joined
[08:20] <masak> szabgab: put it in a sub.

[08:21] <szabgab> rakudo: my @x = (1, 2); say "@x = {@x.perl . @x.NAME}"

[08:21] <masak> szabgab: also, consider escaping the first @x, for future's sake.

[08:21] <p6eval> rakudo 087e29: OUTPUT«Statement not terminated properly at line 1, near ". @x.NAME}"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[08:21] <masak> szabgab: ~ is concatenation nowadays.

[08:21] <wayland76> rakudo: my @x = (1, 2); say "@x = {@x.perl ~ @x.NAME}"

[08:21] <p6eval> rakudo 087e29: OUTPUT«Method 'NAME' not found for invocant of class 'Perl6Array'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[08:21] <masak> oh, and NAME is not implemented yet. :)

[08:21] <wayland76> rakudo: my @x = (1, 2); say "@x = {@x.perl ~ @x.WHAT}"

[08:21] <szabgab> masak, escaping ? oh please no, don't tell me I can't rely on @x not being interpolated 

[08:21] <p6eval> rakudo 087e29: OUTPUT«@x = [1, 2]Array␤»

[08:22] <masak> szabgab: sorry, my bad.

[08:22] <masak> szabgab: it won't be.

[08:22] <masak> szabgab: not unless you write @x[]

[08:22] <moritz_> aye

[08:23] <szabgab> ah

[08:23] *** lambdabot joined
[08:23] <szabgab> masak, so how would you get back the name of the original variable from a sub ?

[08:23] <wayland76> phew :)

[08:24] <wayland76> rakudo: my @x = (1, 2); say "@x = {@x.perl ~ @x.name()}"

[08:24] <p6eval> rakudo 087e29: OUTPUT«Method 'name' not found for invocant of class 'Perl6Array'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[08:24] <szabgab> WHAT only gives the type

[08:24] *** ujwalic joined
[08:25] <szabgab> maybe we can have another method , eg   @x.superl   that will do that ?

[08:25] <moritz_> rakudo: my @x = <3 4 5>; my $s = \(@x); say $s.perl

[08:25] <p6eval> rakudo 087e29: OUTPUT«["3", "4", "5"]␤»

[08:26] <moritz_> rakudo: my @x = <3 4 5>; my $s = :(@x); say $s.perl

[08:26] <p6eval> rakudo 087e29: OUTPUT«too few arguments passed (0) - 1 params expected␤current instr.: '_block14' pc 40 (EVAL_17:28)␤»

[08:27] <masak> szabgab: there's .VAR, but I'm not sure it does what you want either.

[08:27] <lambdabot> masak: You have 1 new message. '/msg lambdabot @messages' to read it.

[08:27] <wayland76> I can't find anything for getting the name

[08:27] <masak> lambdabot: you're getting annoying now.

[08:27] <masak> @clear

[08:27] <lambdabot> Messages cleared.

[08:28] <szabgab> rakudo: my @x = (1, 2); say "@x = {@x.perl . @x.VAR}"

[08:28] <p6eval> rakudo 087e29: OUTPUT«Statement not terminated properly at line 1, near ". @x.VAR}\""␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[08:28] <szabgab> rakudo: my @x = (1, 2); say "@x = [@x.VAR}"

[08:28] <p6eval> rakudo 087e29: OUTPUT«@x = [@x.VAR}␤»

[08:28] <szabgab> rakudo: my @x = (1, 2); say "@x = {@x.VAR}"

[08:28] <p6eval> rakudo 087e29: OUTPUT«@x = 1 2␤»

[08:28] * szabgab needs coffein

[08:29] *** Tene joined
[08:29] <wayland76> Is that a coffin for French vampires?  :)

[08:29] <wayland76> (Yes, I know you meant caffeine)

[08:30] <masak> language is hard, let's go shopping!

[08:30] <wayland76> I remember there were some GI Joe dolls that apparently had that installed in their voiceboxes by accident

[08:31] <szabgab> rakudo: sub coffin(@a){say @a.VAR}; my @x = (1, 2); coffin(@x)

[08:31] <wayland76> Although the Barbies with macho voices were probably funnier :)

[08:31] *** renormalist joined
[08:31] <p6eval> rakudo 087e29: OUTPUT«12␤»

[08:31] <masak> hasta la vista, Barbie!

[08:32] <szabgab> wayland76, I was using Hungarian notation

[08:32] <szabgab> actually that would be koffein I think

[08:32] <wayland76> And here was me thinking it was really just a typo :)

[08:33] *** jferrero joined
[08:36] <mikehh> moritz_: that test passes now 

[08:59] <Matt-W> Morning

[09:00] * masak lifts hat at Matt-W

[09:01] <Matt-W> This morning's Form.pm progress report: I crashed Rakudo

[09:01] <masak> yay!

[09:01] <masak> that's the spirit.

[09:02] <Matt-W> heh

[09:02] <Matt-W> but it's okay

[09:02] * masak considers giving Matt-W a badge saying "I crash Rakudo today, so it won't crash for you tomorrow"

[09:02] <Matt-W> I created RT #63826

[09:02] <masak> Matt-W++

[09:02] <Matt-W> lol isn't that your job?

[09:03] <masak> I'm willing to share the burden.

[09:03] <masak> or rather, I'm happy when others help parallelize the crashing.

[09:04] <masak> excellent bug report. short and to the point.

[09:04] *** sri_kraih_ joined
[09:06] <Matt-W> it was nice and easy

[09:07] <Matt-W> I was delighted when it was reproducible with such a small test case

[09:08] <masak> that's often the case.

[09:08] <masak> I've been toying with the idea of reducing failures to minimal test cases with the help of Monte Carlo Markov Chain techniques.

[09:09] <Matt-W> sounds like the kind of thing you could write a paper on

[09:09] <masak> now there's an idea.

[09:09] <moritz_> it took me ages to reduce RT #63596 to a small test case

[09:10] <masak> moritz_: aye, looks involved.

[09:11] <masak> I remember #62828 with fondness.

[09:11] <moritz_> and the 'my' was actually not intentional, so you can imagine how bad I felt after spending 20 minutes on isolating it :/

[09:12] <masak> the one thing you want cloned objects _not_ to do is change along with the originals!

[09:12] <masak> moritz_: a good Perl 6 linter would catch that extra 'my'.

[09:15] <moritz_> masak: I look forward to it :-)

[09:16] <masak> moritz_: I'd tell you more, but I would have to kill you. ;)

[09:17] <masak> let's just say I have more secret projects now than I'd like.

[09:23] <Matt-W> I've started thinking about how to do word wrapping

[09:23] <moritz_> masak: being killed doesn't exactly sound like -Ofun to me :-)

[09:24] <Matt-W> Even pulling as many whole words off the front of a string as will fit into a given number of characters is potentially fraught with difficulty :(

[09:24] <Matt-W> Text is hard

[09:24] <masak> moritz_: I think some AI database somewhere has a triplet saying "Dying is disadvantageous." I've always liked that phrasing.

[09:24] <wayland76> Have to port Text::Autoformat first :)

[09:25] <Matt-W> wayland76: maybe

[09:25] <Matt-W> Certainly some of this background stuff could credibly go into another module

[09:25] <masak> wayland76: I find that modules tend to bud off from other modules when the need arises. at least with my projects.

[09:26] <masak> I factor things out when two projects need the same code.

[09:26] <masak> and proto takes care of my build dependencies nowadays.

[09:27] <Matt-W> I need a proper makefile.pl as well

[09:27] <Matt-W> at some point

[09:27] * Matt-W grumbles about build systems

[09:28] <masak> Matt-W: oh, it's no biggie. just let yourself be inspired by November or Druid.

[09:28] <wayland76> Don't you have to write some code after? :)

[09:28] <Matt-W> I looked at both of them

[09:28] <Matt-W> neither seem to be appropriate

[09:29] <masak> Matt-W: oh? please elaborate.

[09:29] <Matt-W> well I couldn't see anything that kicks off the test harness

[09:29] <masak> no?

[09:29] * masak gets link

[09:29] <Matt-W> and it all seems to be assuming you have a parrot/languages/rakudo

[09:29] <masak> Matt-W: aye.

[09:30] <Matt-W> which I don't

[09:30] <Matt-W> I have a rakudo/parrot

[09:30] <masak> oh.

[09:30] <masak> I see now.

[09:30] <masak> yes, that might actually be a problem.

[09:30] <masak> we need to standardize on something that allows both.

[09:30] <masak> please let's keep in touch about this. :)

[09:31] <Matt-W> yes

[09:31] <Matt-W> but I got the implication there was stuff about test suites in it

[09:31] <masak> as we speak, I'm reconfiguring proto to install Rakudo Vienna with Parrot in it by default.

[09:31] <Matt-W> and I didn't see that

[09:31] <masak> Matt-W: hold on.

[09:31] * Matt-W thinks about work for a bit

[09:32] <masak> Matt-W: http://github.com/viklund/november/blob/5db9a017fea454e239eacaec7565a329ac9b6ba6/Makefile.in#L24

[09:32] <Matt-W> oh no I have a meeting in 28 minutes!!!

[09:32] <Matt-W> prove?

[09:32] <Matt-W> and I'm sure that bit wasn't there earlier

[09:33] * Matt-W cleans his glasses

[09:33] <masak> Matt-W: there's Makefile.PL and there's Makefile.in

[09:33] <Matt-W> yes

[09:33] <Matt-W> I see you compile everything to PIR

[09:33] <masak> natuarlly.

[09:34] <Matt-W> bet that speeds up test invocations

[09:34] <masak> s/ar/ra/

[09:34] <masak> Matt-W: it does, and startup times too.

[09:34] <Matt-W> so what's prove?

[09:34] <masak> Matt-W: it's a Perl tool for running test suites.

[09:35] <masak> we just hijack it for Perl 6 tests.

[09:35] <Matt-W> because the output format is the same

[09:35] <Matt-W> right

[09:35] <masak> http://search.cpan.org/dist/Test-Harness/bin/prove

[09:35] <Matt-W> I'll go for that then

[09:35] <Matt-W> I need to reorganise my tests a bit

[09:35] <Matt-W> need one set for testing the data structures used for parsed fields

[09:35] <moritz_> newer prove's have the --perl option

[09:36] <masak> Matt-W: I hope we'll be able to reach a consensus about this such that proto can install Form and run the tests on it.

[09:36] <Matt-W> oh yes I'm sure we will

[09:36] <masak> great.

[09:36] <Matt-W> the only reason my system is as it is at the moment is that I just threw it together to get something I could use

[09:36] <Matt-W> and it's not great in any way at all

[09:36] <Matt-W> but I wanted to write some code, not scream at make

[09:36] <masak> aye.

[09:37] <masak> it'll get easier with time, as we get the tools.

[09:37] <Matt-W> but we are going to need a Makefile.PL that can handle parrot-in-rakudo

[09:37] <Matt-W> although does it really need to care

[09:37] <Matt-W> it just needs to know where the perl6 fakecutable is

[09:37] <masak> well, it needs to find Rakudo :)

[09:37] <masak> aye.

[09:37] <Matt-W> so it doesn't need to know where parrot is

[09:38] <masak> yes, if PARROT_DIR is set but RAKUDO_DIR isn't.

[09:38] <masak> I sense there's a kind of fallback order here.

[09:38] <Matt-W> unless there's some preference for using perl6.pbc over perl6

[09:38] <Matt-W> mmm

[09:38] <Matt-W> what about if rakudo is in PATH

[09:38] <masak> Matt-W: that should probably also be a fallback.

[09:38] <masak> the .pbc thing, that is.

[09:39] <masak> Matt-W: if Rakudo is in PATH, we still won't find Test.pm

[09:39] <Matt-W> true

[09:39] <masak> I think RAKUDO_DIR is sort of a minimal requirement.

[09:39] <Matt-W> although really Test.pm should be findable through some sort of standard Perl 6 library location thingy

[09:40] <Matt-W> :P

[09:40] <masak> PERL6LIB, yes.

[09:40] <masak> but in order to set that automatically, we need RAKUDO_DIR

[09:40] <Matt-W> mmm

[09:40] <masak> or PARROT_DIR, and a heuristic for getting the Rakudo dir from that.

[09:41] <Matt-W> if no RAKUDO_DIR, look in PARROT_DIR/languages/rakudo

[09:41] <Matt-W> if no PARROT_DIR either, erase the hard drive

[09:41] <Matt-W> oh no, the other thing

[09:41] <Matt-W> oh yes

[09:41] <Matt-W> complain

[09:41] <masak> right.

[09:41] <Matt-W> no problem

[09:42] <Matt-W> I can produce one for form that does that this evening

[09:42] <Matt-W> for once I have no concerts or music lessons or aikido classes to go to tonight

[09:42] <masak> cool.

[09:42] <masak> I'll see if I get the proto change in by then.

[09:42] <Matt-W> :)

[09:42] <Matt-W> I do intend Form to be proto-compatible fairly soon

[09:42] <masak> it's about time it started targeting Parrot-in-Rakudo-Vienna.

[09:42] <Matt-W> even though it won't be usable for some time

[09:43] * Matt-W likes Configure.pl --gen-parrot

[09:43] <Matt-W> takes the effort out of it

[09:43] <masak> I'm not sure I can call any of my projects "usable" yet. :)

[09:43] <masak> perhaps Druid.

[09:43] <Matt-W> although I'd like to be able to give -j2 to its make invocation

[09:44] <Matt-W> heh

[09:44] <Matt-W> well the plan is to get Form usable for basic things reasonably soon

[09:44] <Matt-W> the text wrapping algorithm is the major difficulty right now

[09:45] <masak> just keep it simple.

[09:45] <Matt-W> can always making it more elaborate later if necessary

[09:45] <masak> aye.

[09:45] <Matt-W> patches always welcome...

[09:45] <Matt-W> :P

[09:46] <masak> heh

[09:46] <Matt-W> I've got almost everything I need to find the last word break in the string and split there

[09:47] <Matt-W> what I need is to deal with the case where there are no suitable breaks within the size of the field

[09:48] * Matt-W suddenly realises he could do a much better job of this with a nice Perl 6 rule

[09:49] <masak> rules rule.

[09:51] <Matt-W> oh yes

[09:51] <Matt-W> according to S05, << is a left word boundary, and >> is a right word boundary

[09:51] <Matt-W> exactly what I need

[09:52] * Matt-W sends himself an email to remind himself to do that

[09:53] <Matt-W> I suppose I should be thinking about what to say in this meeting now

[09:54] <Matt-W> See you later

[09:54] <Matt-W> <- boring meeting &

[09:56] <masak> Matt-W: \o

[09:57] * masak notices that he has started assuming dashes-in-var-names in Perl 5

[09:59] <moritz_> hey, let's write a patch to allow that

[09:59] * moritz_ can imagine the outcries from #p5p

[10:01] <moritz_> I did a quick codesearch with google

[10:01] <moritz_> it wouldn't break compatilbility in normal code, since nearly nobody uses $var-subcall without spaces

[10:01] <moritz_> but in interpolation it's quite frequent

[10:02] <moritz_> => no easy way to introduce that in perl 5.

[10:03] *** mberends joined
[10:04] <masak> mberends: greetings.

[10:05] <masak> mberends: I've finally started the review of the Pod suite.

[10:05] <masak> pmichaud++ expressed interest in seeing such a blog entry, so I got motivated to start it.

[10:05] <mberends> masak: greetings. last night I confirmed all my bookings for Nordic Perl Workshop

[10:05] <masak> mberends: excellent.

[10:05] <masak> I should do the same. :)

[10:06] <mberends> all: I have booked a room at the Anker with 2 single beds (marginal extra cost), in case someone would like to share

[10:07] <masak> hm, sounds like a plan. how do I go about doing that?

[10:07] <wayland76> perl5: $variable-14

[10:07] <wayland76> :)

[10:08] <moritz_> notice that \w-\d isn't allowed in perl 6 variables either

[10:09] <mberends> ( afk $class )

[10:11] <wayland76> moritz_: That would solve it :)

[10:13] <moritz_> wayland76: that solves it.

[10:15] * masak watches proto successfully download and build Rakudo Vienna

[10:18] *** shinobi-cl joined
[10:20] <masak> here's how it looks: http://gist.github.com/78515

[10:21] <moritz_> that looks like a nice interface :-)

[10:21] <masak> we aim hard to please. :)

[10:22] <moritz_> I know some software that's written from psychologists for psychologists. Most of the target audience is pretty computer illiterate...

[10:22] <masak> next up, I think, will be progress bar dots showing how a download/build progresses.

[10:23] <moritz_> so all of the more frequent error messages are really soft formulated, with lots of "... but it's not so bad, we can fix it for you" and so on :-)

[10:23] <masak> moritz_: I think that might be a good idea in many cases.

[10:23] <jnthn> good morning, all

[10:23] <jnthn> Rakudo day is here.

[10:24] <masak> jnthn: good morning! Rakudo day! :)

[10:24] <moritz_> YaY!

[10:26] *** shinobi-cl left
[10:26] <masak> jnthn: what's planned for today?

[10:27] <jnthn> masak: pmichaud assigned me a flurry to tickets yesterday, which I plan to look through.

[10:27] <jnthn> Also, he wanted me to do a small refactor on dispatchy stuff.

[10:27] <jnthn> I'm open to suggestions if you have any tickets that especially matter to you, though.

[10:28] * moritz_ would very much like to see make() work in action methods

[10:28] <moritz_> but I guess that's a pmichaud topic

[10:28] <jnthn> I thought we already did have an implementation of make?

[10:29] <jnthn> Though I may be mistaking a patch sent in for a patch applied..

[10:30] <masak> jnthn: I don't have anything critical that needs fixing right now.

[10:30] *** rgs joined
[10:30] <jnthn> masak: OK, cool.

[10:30] <masak> jnthn: but I did have two tickets that sort of resurfaced in my mind lately. will dig them out, and maybe we can at least talk about them. :)

[10:30] <jnthn> OK, sounds good.

[10:31] * jnthn tries to figure out how to make RT tell him what tickets are assigned to him, and realizes he needs coffee before much else...

[10:33] <moritz_> rakudo: grammar A { token TOP { . {*} } }; class AA { method TOP(*@a) { make 3; } }; A.parse('f', :action(AA.new));

[10:33] <p6eval> rakudo 087e29: OUTPUT«Method 'result_object' not found for invocant of class 'Failure'␤current instr.: 'make' pc 19145 (src/builtins/match.pir:39)␤»

[10:33] <moritz_> jnthn: that's what I meant

[10:34] <moritz_> jnthn: the starting page ("RT at a glance") shows you the top 10 priority tickets assigned to you

[10:34] * rgs has a quick question

[10:34] <rgs> (hi there)

[10:34] <moritz_> hi rgs

[10:34] <rgs> does/should undef ~~ 0 and undef ~~ "" match ?

[10:34] * masak doesn't think so

[10:34] * moritz_ thinks so

[10:34] <masak> :)

[10:34] <masak> oh wait.

[10:34] <moritz_> rakudo: say undef ~~ 0

[10:34] <p6eval> rakudo 087e29: OUTPUT«Use of uninitialized value␤1␤»

[10:35] <moritz_> rakudo: say undef ~~ ''

[10:35] <p6eval> rakudo 087e29: OUTPUT«Use of uninitialized value␤1␤»

[10:35] <moritz_> so yes, both match

[10:35] <rgs> ok, good

[10:35] <masak> I've changed my mind. they should match. :P

[10:35] <rgs> rakudo: say 0 ~~ undef

[10:35] <moritz_> rgs: the type of the RHS determines the comparison

[10:35] <p6eval> rakudo 087e29: OUTPUT«0␤»

[10:35] <rgs> moritz_: will do the same in P5 then.

[10:35] <moritz_> rgs++

[10:35] <masak> jnthn: the tickets are #60142 and #62730. incidentally, both have their roots in Parrot, I think.

[10:36] <moritz_> and ~~ undef is a negated test for definedness

[10:37] <jnthn> rgs: To quote the spec: Any       Str       string equality         ~$_ eq X

[10:37] <jnthn> What that's saying is that you co-erce the LHS to a string.

[10:37] <jnthn> Well, stringify it...

[10:37] <jnthn> And ~undef is ""

[10:38] <jnthn> And similar for the number case.

[10:38] <jnthn> I'd imagine an implementation can follow pretty directly from that definition, but then I don't know Perl 5 guts. ;-)

[10:38] <moritz_> actuall ~undef is ('' but Warning) :-)

[10:39] <jnthn> moritz_: By Rakudo, or by spec?

[10:39] <moritz_> jnthn: that wasn't entirely serious

[10:39] <jnthn> Ah, OK.

[10:39] <jnthn> I was hoping you would point at the appropriate bit of the spec. :-P

[10:39] <moritz_> anyway, perl 5 has dualvars

[10:39] <moritz_> that's going to be ugly

[10:40] <moritz_> what kind of comparison will $stuff ~~ dualvar(3, 'b') do?

[10:41] <rgs> in Perl 5 ?

[10:41] <moritz_> rgs: yes

[10:41] <moritz_> in Perl 6 there are only junctions, and they have explicit comparison semantics

[10:41] <rgs> numerical values have precedence

[10:42] <moritz_> ah, simple as that :-)

[10:42] <rgs> in guts terms, it will test for IOK / NOK first.

[10:42] <wayland76> I have a message for those who weren't sure about detecting different distros: http://linuxmafia.com/faq/Admin/release-files.html

[10:44] <jnthn> masak: About 60142

[10:45] <jnthn> I think it's a Parrot bug. Allison IIRC did disagree with me. :-|

[10:45] *** AzureStone joined
[10:46] <masak> jnthn: interesting.

[10:46] <masak> as long as it gets fixed, you may disagree as much as you want about the cause... :)

[10:47] <jnthn> masak: I'm trying to find the related ticket in Parrot...

[10:49] <jnthn> Gah, can't. Hmm

[10:50] <mberends> masak: Nice proto gist. Pegging a parrot svn revision is easy, but how to specify a particular (known good) Rakudo revision?

[10:51] <masak> mberends: during which stage? I'm not sure I understand the question.

[10:51] <jnthn> http://rt.perl.org/rt3/Ticket/Display.html?id=61224

[10:53] <masak> mberends: you mean in config.proto? I suppose by a sufficient amount of SHA1 hex digits.

[10:53] <mberends> when proto fetches the Vienna Rakudo, how to tell git to clone a specific rakudo version.

[10:53] <masak> mberends: oh. it downloads the tarball.

[10:53] <mberends> yes, the SHA1 is so bulky and not serial /sequential

[10:53] <masak> I have a working patch here in a local branch.

[10:53] <masak> about to push now.

[10:53] <mberends> ok

[10:54] <mberends> cannot pull, sorry. $work has only mibbit this week.

[10:55] <masak> no prob.

[10:55] <masak> mberends: I hope to be able to finish the review of Pod during the weekend. I expect to fork you and send a lot of pull requests.

[10:56] <mberends> ok, thanks. Would you like to share my Best Western hotel room 15-19 April?

[10:57] <masak> mberends: aye, gladly. how do I do that? should I contact the hotel?

[10:57] <jnthn> "I expect to fork you"..."would you like to share my hotel room"...

[10:57] <jnthn> <ducks>

[10:59] <mberends> I booked a room with 2 single beds. You just have to wait until I check in, about 22:00 on 15 April.

[11:00] *** pnu joined
[11:00] <mberends> lunch &

[11:01] <masak> jnthn: *lol*

[11:01] <pnu> i've trouble building a fresh rakudo checkout on rhel5, any advice..? Building parrot (during perl Configure.pl --gen-parrot) seg-faults with Perl6Grammar.pir.

[11:02] <masak> mberends: oh, so basically, everythings fixed, and we just split the cost of the room?

[11:02] <masak> pnu: could you nopaste the make output?

[11:04] *** ruoso joined
[11:05] <pnu> masak: here http://nopaste.snit.ch/15874

[11:07] <moritz_> that looks a lot like older parrot on amd64 with --optimize

[11:07] <moritz_> lunch &

[11:07] <masak> moritz_: that's just uncanny.

[11:07] <masak> how do you know those things? :)

[11:08] <pnu> moritz_: Linux version 2.6.18-128.1.1.el5 (mockbuild@hs20-bc1-5.build.redhat.com) (gcc version 4.1.2 20080704 (Red Hat 4.1.2-44)) #1 SMP Mon Jan 26 13:59:00 EST 2009

[11:09] <s1n> if it's amd64, why is it using "-march=i386"

[11:09] <ruoso> Hello!

[11:10] <masak> ruoso: oh hai

[11:11] <wayland76> ruoso: Was it you that was saying it'd be difficult to detect distros reliably?

[11:11] <ruoso> yes

[11:11] <s1n> wayland76: if ruoso didn't say that, i raised that question in my response to a commit you made

[11:12] <pnu> is there anything i can do to help with this..?

[11:13] <ruoso> wayland76, and also, the "distro" concept only makes sense in the Linux world

[11:14] <s1n> wayland76: that's why i recommend changing $*DISTRO back to OS (iirc that's how it's referred to in p6)

[11:15] <pugs_svn> r25815 | masak++ | [u4x/README] fixed typo

[11:19] *** bacek joined
[11:20] <ruoso> s1n, better than OS, ARCH

[11:20] <wayland76> ruoso: Not sure I agree.  I'd argue that the term "Operating System" is too ill-defined to be useful, and that just because Windows is the name of both a kernel and a distro is no reason to lose the distinction

[11:20] <ruoso> OS is just a part of the ARCH information

[11:20] <pnu> masak: oh i noticed this during parrot configure initialization: Determine JIT capability...p = 0x9323000  PAGE_SIZE = 4096 (0x1000) ... failure: Permission denied   -- and thats selinux. Now it works.

[11:20] <pnu> sorry for not disabling that awful thing (selinux), should've known that.

[11:21] <ruoso> wayland76, The term DISTRO doesn't make sense in other operating systems as well

[11:21] <ruoso> it actually only makes sense in Linux, basically

[11:21] <wayland76> Not BSD?

[11:22] <wayland76> I'd argue that the term "OS" doesn't make sense for Linux :)

[11:22] <s1n> i'd argue otherwise

[11:22] <s1n> unless you are in the "GNU/Linux" camp

[11:22] *** jferrero left
[11:23] <s1n> and arch is useful, but does not imply OS

[11:23] <ruoso> wayland76, the term "OS" in linux *usually* means linux-gnu

[11:23] <wayland76> Well, I think the GNU/Linux people have a point; Linux is the kernel along

[11:23] <ruoso> s1n, the OS information is part of the arch infromation

[11:23] <s1n> ruoso: tell me what i'm running here then: Linux citadel 2.6.28 #3 SMP Fri Jan 16 22:13:42 CST 2009 x86_64 AMD Athlon(tm) 64 X2 Dual Core Processor 4600+ AuthenticAMD GNU/Linux

[11:24] <s1n> that's my actual uname information

[11:24] *** ejs joined
[11:24] <ruoso> s1n, x86_64-linux-gnu

[11:24] <s1n> ruoso: that's not my os

[11:24] *** WootKit joined
[11:24] <ruoso> exactly

[11:24] <s1n> or my distro

[11:24] <ruoso> that's your ARCH

[11:24] <s1n> so while that is useful, but it's not the os/distro

[11:24] <ruoso> it contains both the CPU and the OS

[11:25] <ruoso> distro simply doesn't make sense outside of linux, so I don't think it's worth being spec

[11:25] *** WootKit left
[11:25] <s1n> ruoso: my os is not "linux-gnu", sorry, that's completely worthless in linux

[11:25] <ruoso> s1n, er... worthless in what sense?

[11:25] <ruoso> that's what gcc uses 

[11:25] <ruoso> for instance

[11:25] <ruoso> that's what binutils use

[11:26] <s1n> doesn't mean anything to an application developer needing to know if you're redhat or opensuse

[11:26] <ruoso> s1n, that developer needs a library

[11:26] <ruoso> which is Linux-specific

[11:26] <s1n> that developer is wanting that from $*DISTRO or $*OS

[11:27] <s1n> i'm not saying arch isn't useful, but sometimes we need to go beyond that

[11:27] <ruoso> s1n, do you actually realize how hard it is to figure out that?

[11:27] <ruoso> in a portable manner

[11:27] <s1n> ruoso: yes, i do realize that

[11:27] <ruoso> ok.. my point is... take that to a library

[11:27] <wayland76> I don't.  See http://linuxmafia.com/faq/Admin/release-files.html

[11:27] <ruoso> no reason to be part of the CORE

[11:28] <wayland76> ruoso may well be right about this not being part of the core though

[11:28] <s1n> ruoso: i might agree with that

[11:28] <s1n> but i definitely don't like having $*DISTRO over $*OS

[11:28] <ruoso> that's not what I meant

[11:28] <ruoso> I meant ARCH over OS

[11:28] *** WootKit joined
[11:28] <ruoso> because ARCH *includes* OS information

[11:29] <wayland76> Not as currently specced :)

[11:29] <s1n> ruoso: i'll take arch, but it doesn't include OS

[11:29] <ruoso> s1n, "redhat" is not OS

[11:29] <ruoso> "linux-gnu" is

[11:29] <s1n> nope

[11:29] <ruoso> "linux-uclibc" is

[11:29] <s1n> RedHat Linux

[11:30] <ruoso> s1n, er... do you understand what the "linux-gnu" means in the arch triplet?

[11:30] <s1n> don't sully the good name of Linux by tacking on RMS's "GNU"

[11:30] <wayland76> ruoso: I think s1n just made my point about OS being too ill-defined :)

[11:30] <ruoso> s1n, it's not about that

[11:30] <ruoso> it's about using the GNU Libc

[11:30] <ruoso> which redhat does

[11:30] <s1n> ruoso: yes, i do understand that it's a flavor of the linux kernel, so what

[11:30] <ruoso> IT'S NOT

[11:30] <ruoso> you have two things 

[11:31] <ruoso> one is the kernel

[11:31] <ruoso> other is the userlevel library

[11:31] <wayland76> s1n: libc is a library that contains the basic C functions.  It is *not* supplied as part of the kernel

[11:31] <s1n> if you're referring to what gcc reports, sure

[11:31] <wayland76> ruoso: is it only libc, or some others?

[11:31] <s1n> i have only ever talked about uname example

[11:31] <ruoso> libc is the thing that defines the arch, yes

[11:31] <ruoso> s1n, that's because you're not hearing what I'm saying

[11:32] <s1n> when i build a gentoo system, i can really mess things up, here's how:

[11:32] <s1n> i can use the binary linux kernel, build libc for say amd64

[11:33] <ruoso> *sigh*

[11:33] <s1n> then i can really dork it up by building a i386 kernel

[11:33] <s1n> the more interesting case is the opposite

[11:33] <ruoso> that's the CPU

[11:33] <s1n> running the kernel built for amd64 with libc built for 386

[11:33] <wayland76> Lets try this.  (linux = kernel)    (gnu = libc)  kernel is pretty useless without libc.  What do you call it when you use both these basic components?

[11:33] <ruoso> that's the CPU

[11:33] <ruoso> the ARCH is CPU-PLATFORM-OS

[11:33] <ruoso> where PLATFORM is usually implied as "pc"

[11:34] <s1n> i guess you've never built both 386 and amd64 libc's

[11:34] <ruoso> *sigh*

[11:34] <ruoso> you're simply not getting the point

[11:34] <s1n> i am, you aren't

[11:34] <s1n> i can have both

[11:34] *** WootKit left
[11:34] <wayland76> I think you're both not getting each other's points

[11:34] <ruoso> we are not arguing about CPU

[11:34] <s1n> libc built for multiple platforms, which platform am i then?

[11:35] <ruoso> s1n, at the platform your current binary is linked to

[11:35] <ruoso> it cannot be linked to both libcs at the same time

[11:35] <s1n> i have to go to work now though, continue without me

[11:37] <wayland76> ruoso: Does my point about certain words not being well-agreed-upon ring true :)

[11:38] <ruoso> s1n, was simply not reading anything I was writing

[11:38] <wayland76> Having said that, I think s1n may have a better grip on things than Wikipedia :)

[11:38] <wayland76> ruoso: I think he was, just not carefully.  I was arguing on both sides depending on the mood of the moment :)

[11:39] <wayland76> Anyway, there's a thunderstorm here, so I'm going to shut down my computers

[11:44] <s1n> parting words, arch is useful only to the point of knowing what it was built against, not what the system truly is, which would be a nightmare to identify, talk amongst yourselves :)

[11:44] *** ujwalic_ joined
[11:45] <ruoso> s1n, you're still seeing DISTRO as OS... but these are different things

[11:45] <ruoso> "RedHat" is not "OS"

[11:46] <jnthn> .oO( Some discussions make the Win32 world seem oh so nice and easy. )

[11:46] <jnthn> ;-)

[11:47] <jnthn> Does Perl 6 core really want to have to care about identifying distro?

[11:47] <ruoso> I think it doesn't

[11:47] <jnthn> IMO, that's something for a 6PAN module.

[11:47] <ruoso> that's my point about DISTRO

[11:47] <jnthn> As a Perl 6 implementer, keeping up with distro detection is *not* something I want to have to care about.

[11:48] <jnthn> Not to mention the cases where you'd need that level of info feel to me few and far between.

[11:48] <ruoso> my point is: the only thing you can really know is the arch triplet

[11:50] <ruoso> so I argue for using $?ARCH, $?XARCH and $*ARCH

[11:50] <rgs> xarch ?

[11:51] <ruoso> cross compilation

[11:51] <ruoso> $?ARCH is the target arch

[11:52] <ruoso> $?XARCH is the host arch

[11:52] <ruoso> $*ARCH is the current arch

[11:52] <rgs> good

[11:55] *** ujwalic left
[11:58] *** ejs left
[12:00] <pnu> i'm sorry this is such an open topic, but what's a good stating point if i want to contribute to rakudo project..? I'm experienced with perl but don't have clue about parrot etc. I read somewhere that some perl6 features could be implemented to rakudo in perl6 already?

[12:02] <moritz_> pnu: they can. See http://rakudo.org/2009/02/rakudo-built-ins-can-now-be-wr.html for example

[12:03] <moritz_> pnu: also read http://rakudo.org/developers-guide 

[12:04] *** kanru joined
[12:05] <pnu> moritz_: yes, that was it.. ok, thanks.

[12:08] <pugs_svn> r25816 | jnthn++ | [t/spec] Tests for using roles as type constraints.

[12:11] <ruoso> std: sub foo(1,2,3) {...}

[12:11] <p6eval> std 25816: OUTPUT«ok 00:02 35m␤»

[12:11] <dalek> rakudo: 88b6c25 | jnthn++ | src/classes/Role.pir:

[12:11] <dalek> rakudo: Various fixes to using roles as type constraints. Resolves at least RT#62966.

[12:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/88b6c255198018c6cc1450e81ae53d7b9a97133c

[12:12] <ruoso> rakudo: multi foo(1) { say 1 }; multi foo(2) { say 2 }; foo(1); foo(2); foo(3);

[12:12] <p6eval> rakudo 087e29: OUTPUT«Malformed routine definition at line 1, near "foo(1) { s"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[12:12] <jnthn> Heh

[12:12] <ruoso> jnthn, is that already known?

[12:12] <masak> ruoso: can I submit a rakudobug on that?

[12:12] <jnthn> I didn't even know that was valid syntax... :-P

[12:12] <moritz_> rakudo: multi foo($ where 1) { 1 }, multi foo($ where 2) { 2 }; foo($_) for 1..3

[12:13] <p6eval> rakudo 087e29: OUTPUT«No applicable candidates found to dispatch to for 'foo'␤current instr.: '_block53' pc 602 (EVAL_20:231)␤»

[12:13] <moritz_> rakudo: multi foo($ where 1) { 1 }, multi foo($ where 2) { 2 }; foo($_) for 1..2

[12:13] <p6eval> rakudo 087e29: RESULT«Method 'HOW' not found for invocant of class 'Iterator'␤current instr.: '_block14' pc 77 (EVAL_20:44)␤»

[12:13] <moritz_> rakudo: multi foo($ where 1) { 1 }, multi foo($ where 2) { 2 }; say foo($_) for 1..2

[12:13] <p6eval> rakudo 087e29: OUTPUT«1␤2␤»

[12:13] <moritz_> std: multi foo(1) { 1 };

[12:13] <masak> NoirSoldats: what does the comma do?

[12:13] <p6eval> std 25816: OUTPUT«ok 00:02 35m␤»

[12:13] <masak> oops.

[12:13] <masak> moritz_: what does the comma do?

[12:14] <moritz_> which comma?

[12:14] <jnthn> Why on earth does the comma work?!

[12:14] <moritz_> ah

[12:14] <masak> moritz_: the one between your subs.

[12:14] <moritz_> I meant to use a ;

[12:14] <ruoso> std: multi foo($ where 1) { 1 }, multi foo($ where 2) { 2 }; say foo($_) for 1..2

[12:14] <moritz_> because it's a statement list in void context?

[12:14] <masak> ok, how many rakudobugs does this amount to? :)

[12:14] <p6eval> std 25816: OUTPUT«ok 00:03 38m␤»

[12:14] <moritz_> masak: -1

[12:14] <pnu> moritz_: oh, this is great! is it planned to implement all in classes/*.pir finally?

[12:14] <moritz_> pnu: most, probably not all

[12:15] <masak> surely one for the sub foo(1) { ... } case, no?

[12:15] <jnthn> pnu: Maybe not *all*, but...what moritz_ said.

[12:15] <ruoso> masak, I guess so...

[12:15] * masak submits

[12:15] <jnthn> Does the spec say you can do that?

[12:15] <moritz_> dunno

[12:15] <masak> screw the spec! STD says it's ok. :)

[12:15] <moritz_> never seen that syntax

[12:16] <pnu> ok, but at least a prototype for testing the specs and then maybe port to pir.. is a good practice?

[12:16] <ruoso> jnthn, well, it's a fantastic syntax...

[12:16] <moritz_> what do you want to port to pir?

[12:16] <ruoso> much better than "$ where 1"

[12:16] <moritz_> ruoso: it's a lot like haskellian pattern matching

[12:16] <masak> jnthn: I remember requesting that syntax on NPW2008. :)

[12:16] <pnu> moritz_: an imaginary method i implement in settings some day.. :-)

[12:17] <ruoso> specially for the multi-reduce web.pm dispatcher

[12:17] <masak> indeed.

[12:17] <moritz_> pnu: if you implement it in the setting, no need to backport it to pir. that's what compilers are there for :-)

[12:17] <masak> boy, do I have something to write about on Sunday! :)

[12:18] <masak> "we introduced new syntax in Perl 6 so that we could write a nicer dispatcher"

[12:18] <jnthn> I agree it's nice syntax, just wondered ifit's spec'd.

[12:18] <ruoso> implement it, we push it in later ;)

[12:18] <masak> agreed. :)

[12:18] <jnthn> Will look at STD.pm and see what it parses it as, anyway...

[12:18] <pnu> moritz_: ok :-) and after recompiling rakudo, things written in setting start to work? (ok, maybe i'll stop asking and just try it my self..)

[12:18] <jnthn> I'm a little surprised it does, but in theory it's easy to get Rakudo to handle it.

[12:18] <jnthn> pnu: Yes.

[12:19] <moritz_> pnu: if you did right, it works :-)

[12:19] <pmichaud> good morning, #perl6

[12:19] <jnthn> morning, pmichaud

[12:19] <moritz_> good morning rakudo hacker No. 1 :-)

[12:19] <masak> morning, pmichaud 

[12:19] <jnthn> Damm, pm is awake and I only fixed one bug so far!

[12:19] <pnu> jnthn: this is wonderful! :)

[12:20] <moritz_> I must be sick. Yesterday night I dreamed that TPF missed the application deadline for gsoc :)

[12:20] <ruoso> pmichaud, jnthn, does rakudo provide a way to programatically define a new multi and add the variants?

[12:20] <jnthn> pmichaud: Will do the dispatch refactor soon, just hunting through RT for any related tickets to the fix I just did on roles as type checks...

[12:20] <jnthn> ruoso: Well, I guess you can eval it...

[12:21] <ruoso> meh

[12:21] <pmichaud> jnthn: no problem

[12:21] <jnthn> ruoso: Of course we do have ways under the hood, for sure...

[12:21] <ruoso> let me explain

[12:21] <jnthn> But nothing exposed AFAIK.

[12:21] <ruoso> in the web.pm multi dispatcher thing

[12:22] <ruoso> there's no reason to expose the multi in any namespace

[12:22] <ruoso> it's probably better to just hold it into a variable

[12:22] <ruoso> so @url-parts.reduce: &multi; later

[12:23] <ruoso> and as we're probably having a sub-grammar to declare that

[12:23] <ruoso> it sounds like a requirement to be able to define a new multi object and add the variants when parsing that sub-grammar

[12:24] <jnthn> One related question I had on all of this is

[12:24] <jnthn> multi foo() { }; foo.WHAT.say # what do we get?

[12:24] <jnthn> Multi? or Sub?

[12:24] <ruoso> you mean &foo.WHAT

[12:24] <jnthn> Yes

[12:25] <ruoso> I'd guess Multi

[12:25] <masak> Multi sounds a bit saner.

[12:25] <jnthn> Good. :-)

[12:25] <jnthn> Well in that case

[12:25] <jnthn> my $x = Multi.new; push $x, sub ($x, $y) { ; # after declaring a proto-object creation for Perl6MutliSub PMC may just work off the bat.

[12:25] <jnthn> emm, missing a }

[12:26] <ruoso> Cool...

[12:26] <jnthn> Since that's essentially all we do internally.

[12:26] <jnthn> In a related question

[12:26] <jnthn> Do we not define .signature on Multi?

[12:26] <jnthn> But rather you ahve to iterate .candidates ?

[12:26] <ruoso> jnthn, I don't think s

[12:26] <jnthn> OK, good.

[12:27] <masak> rakudo: Multi.new

[12:27] <p6eval> rakudo 88b6c2: OUTPUT«Could not find non-existent sub Multi␤current instr.: '_block14' pc 53 (EVAL_16:38)␤»

[12:27] <ruoso> maybe .signature returns a Junction of the signature

[12:27] <ruoso> of each candidate

[12:27] <jnthn> I thought about that and then thought...hmm...do we really want to do that...

[12:27] <jnthn> :-)

[12:27] <jnthn> But yes, it was my obvious answer for if we're going to have signature.

[12:27] <masak> why is a junction preferable to a simple list?

[12:27] <ruoso> jnthn, we still need to deal with varying arity in the multi for reduce

[12:28] <ruoso> masak, because it preserves the API

[12:28] <masak> and, would it be a conjunction or a disjunction? :)

[12:28] <jnthn> disjunction is probably more useful.

[12:28] <moritz_> a weirdjunction

[12:28] <ruoso> you usually need to know if at least one of them match

[12:28] <masak> right.

[12:28] <masak> disjunction, then.

[12:28] *** rmt_ joined
[12:28] <jnthn> e.g. you can check if it's possible to bind a capture to any of the signatures - at least in principle...though of course that's not the way a multi-dispatch actually does it internally.

[12:29] <jnthn> I guess .arity is then a junction of all the possible arities....

[12:29] <jnthn> Not sure how that plays with .reduce though!

[12:29] <moritz_> well

[12:29] <moritz_> if you look at how it's implemented atm

[12:31] <ruoso> jnthn, we need a way to say "do a partial match and tell me how many items you consumed"

[12:31] <ruoso> so @foo.reduce: &multi; works as expected

[12:32] <ruoso> I was thinking that could be a named parameter to .postcircumfix:<( )>

[12:33] <jnthn> That feels...odd.

[12:33] *** DemoFreak joined
[12:34] <moritz_> since it can have named parameters themselves

[12:34] <ruoso> moritz_, the signature for .postcircumfix:<( )> is already ($capture), not (|$capture)

[12:34] <ruoso> SMOP already takes advantage of that to receive :$cc

[12:38] <ruoso> method postcircumfix:<( )> ($capture, :$partial-sig-match ) { ... }

[12:39] <ruoso> where we could assume that passing that argument would require you to declare

[12:39] <ruoso> my $partial-sig-match-count is context<rw>;

[12:40] *** finanalyst joined
[12:40] <ruoso> that... or we need "RWIterator ~~ Signature"

[12:40] <ruoso> hmm

[12:41] <ruoso> actually... that doesn't solve much... we need the signatures to be evaluated inside the multi

[12:41] <ruoso> maybe...

[12:42] <ruoso> when passing :partial-sig-match, it would expect the capture to be a RWIterator

[12:42] <ruoso> and pushback items when necessary

[12:42] <ruoso> so you can send the iterator to the next invocation...

[12:43] <jnthn> Sounds a tad messy.

[12:43] <ruoso> but I think the RWIterator is the way to go

[12:44] *** renormalist left
[12:44] <ruoso> we just need a good way to tell the Callable that

[12:46] * ruoso goes to sketch something about RWIterator in S07

[12:49] <masak> ruoso: excuse me, but what's an RWIterator?

[12:49] <ruoso> Read-Write Iterator

[12:50] <masak> I guessed that. what is it that can be read and written?

[12:52] <ruoso> ok... we might need to qualify the name a bit more

[12:52] <jnthn> OK, now in my local rakudo

[12:52] <jnthn> > multi foo() { 1 }

[12:52] <jnthn> > say &foo.WHAT

[12:52] <jnthn> Multi

[12:52] <jnthn> > &foo.push(sub ($x) { 2 })

[12:52] <jnthn> > say foo(); say foo(42);

[12:52] <jnthn> 1

[12:52] <lambdabot>   <no location info>: parse error on input `1'

[12:52] <lambdabot>   Not in scope: `say'    precedence parsing error

[12:52] <lambdabot>          cannot mix `(&)' [...

[12:52] <lambdabot>   <no location info>: parse error on input `;'

[12:52] <lambdabot>   <no location info>: parse error on input `&'

[12:52] <jnthn> 2

[12:52] <Matt-W> moritz_: not read all the backlog, but make operates on the current $/, so you have to call the parameter for your action methods $/, then it works nicely. This may not be ideal, but that's how it goes at the moment...

[12:52] <jnthn> ...thanks, lambdabot...

[12:52] <Matt-W> moritz_: see Form.pm for example

[12:52] <jnthn> ruoso: Does that look like what you wre thinking?

[12:52] <ruoso> masak, maybe we need to name it Iterator::PushBack for that specific meaning

[12:53] <masak> jnthn: cool!

[12:53] <masak> ruoso: I'm still not sure what it is you're building.

[12:53] <masak> ruoso: an iterator that can... what?

[12:53] <ruoso> jnthn, yes... just missing Multi.new

[12:53] <ruoso> masak, that you can consume the value, see it doesn't fit and push it back to the iterator

[12:54] <ruoso> so it can be consumed again

[12:54] <masak> ruoso: like a sort of peek() function?

[12:54] <ruoso> peek?

[12:55] <rgs> poke

[12:55] <moritz_> Matt-W: repo URL?

[12:56] <moritz_> man, github is slower than perlmonks right now

[12:56] <masak> moritz_: http://github.com/mattw/form/

[12:56] <ruoso> masak, rgs, yeah.. something like that

[12:57] <Matt-W> masak++

[12:57] <moritz_> Matt-W: thanks

[12:57] <Matt-W> remembering my url before I do

[12:57] <masak> moritz_: np. :)

[12:57] *** ejs joined
[12:57] <moritz_> ah, masak++ is was

[12:57] <moritz_> well, still Matt-W++ for writing the code :-)

[12:58] <masak> Matt-W: not so much remembering as using the Firefox awesomebar.

[12:58] <Matt-W> pmichaud++ for telling me how to make it work

[12:58] <Matt-W> masak: shush or you'll ruin it

[12:58] <masak> pmichaud++ for teaching me the original trick.

[13:00] <jnthn> Gah. Rakudo's Perl6MultiSub inherits from Parrot#s MultiSub which thanks to history rather than sanity inherits from ResizablePMCArray...which makes Rakudo thing it's doing an array assignment. Damm!

[13:01] <Matt-W> argh

[13:02] <masak> perhaps time to abandon history for sanity? :)

[13:02] <masak> that's what we tend to do in Perl 6.

[13:03] <Matt-W> I'm failing to see why MultiSub isa ResizablePMCArray

[13:03] <Matt-W> it doesn't seem like that's what inheritance is supposed to be for :)

[13:03] * moritz_ remebers a great lord-of-the-rings (the movie) quote that can be adopted here :-)

[13:04] <jnthn> > my $x = Multi.new; $x.push(sub { say 1 }); $x.push(sub ($a) { say 2 }); $x(); $x(42);

[13:04] <lambdabot>   <no location info>: parse error on input `='

[13:04] <jnthn> 1

[13:04] <jnthn> 2

[13:04] <masak> moritz_: "Fly, you fools!"? :)

[13:04] <jnthn> ruoso, masak: Look good for your dispatcher? :-)

[13:04] <moritz_> Gandalf to Saruman as he discovers the latter's treason: `tell me, "friend": when did Saruman the wise reason for madness'

[13:05] <masak> jnthn: indeed.

[13:05] <pugs_svn> r25817 | ruoso++ | [spec] Add Iterator::PushBack to S07

[13:05] <moritz_> with s/reason/history/

[13:05] <jnthn> masak: It also fixes

[13:05] <moritz_> s/madness/sanity/

[13:05] <ruoso> jnthn, looks perfect  :)

[13:05] <jnthn> rakudo: multi foo { }; say &foo.WHAT

[13:05] <p6eval> rakudo 88b6c2: OUTPUT«Null PMC access in find_method()␤current instr.: '_block14' pc 79 (EVAL_17:43)␤»

[13:05] <moritz_> what follows was cool but slightly ridiculous fight :-)

[13:05] <jnthn> Which in my local now says Multi

[13:05] <masak> moritz_: agreed.

[13:05] <moritz_> cool

[13:05] <moritz_> jnthn++

[13:05] <masak> jnthn++

[13:06] <jnthn> ruoso++ for badgering me into it ;-)

[13:06] <ruoso> now we just need to be able to use multis with different arity in @foo.reduce

[13:06] * ruoso points to his last commit in S07 and asks for evaluation

[13:09] *** ejs left
[13:09] <jnthn> > for &foo.candidates { .signature.perl.say }

[13:09] <jnthn> :()

[13:09] <jnthn> :(Any $x)

[13:09] <lambdabot>   <no location info>: parse error on input `.'

[13:09] *** ejs joined
[13:09] <masak> now we just need to make it seem like this was in the spec the whole time. :P

[13:09] <jnthn> ftw

[13:09] <jnthn> masak: Hey, I have a commit bit to the spec ;-)

[13:10] <masak> jnthn: hey, me too! :)

[13:10] <masak> this is too easy. :P

[13:10] <jnthn> Forgiveness. Permission.

[13:10] <jnthn> ;-)

[13:10] <ruoso> hmmm... 

[13:11] <ruoso> maybe it can simply be a different method of Callable

[13:11] <masak> jnthn: if you don't put it in today, I will tomorrow.

[13:11] <ruoso> that receives an Iterator::PushBack

[13:11] <moritz_> if it's a multi, * would be the better signature to return

[13:11] <moritz_> "signature" that is :-)

[13:11] <jnthn> moritz_: How so?

[13:12] <ruoso> hmm... so it can DWIM when you $capture ~~ $signature

[13:12] <jnthn> moritz_: Note there that I am iterating over the candidates and printing the .perl of their signatures

[13:12] <moritz_> it's a placeholder for whatever

[13:12] <moritz_> jnthn: ah

[13:12] <moritz_> jnthn: I got that wrong then

[13:12] <ruoso> $multi.signature could return a closure

[13:12] <jnthn> moritz_: I'm more inclined to have a junction of all possible signatures though...

[13:12] <jnthn> A closure?

[13:12] <ruoso> so you can still do $capture ~~ $signature

[13:12] <moritz_> a junction would be nice

[13:13] <ruoso> but it would then be handled by code that belongs to Multi

[13:13] <jnthn> ruoso: You could still do that with a junction.

[13:13] <moritz_> because it reflects the unorderedness

[13:13] <jnthn> moritz_: Right.

[13:13] <ruoso> jnthn, the junction is external to the Multi

[13:13] <jnthn> ruoso: So?

[13:13] <jnthn> So is the signature ;-)

[13:13] <ruoso> if you have more than one match, the Multi might want to choose the candidate

[13:14] <jnthn> ruoso: Please let's not confuse "is there any signature that could possibly match" with "is a dispatch possible?"

[13:14] <jnthn> Those are two completely separate questions.

[13:14] <ruoso> ok...

[13:15] <jnthn> But this confusion is why I'm kinda half-hearted about putting .signature on Multi.

[13:15] <ruoso> my question really is "is a dispatch possible? and how many arguments that represent?|

[13:15] <jnthn> At all.

[13:15] <jnthn> Because people may confuse the two as well.

[13:15] *** ejs left
[13:15] <ruoso> but I think a different invoke method for this would be ok

[13:16] <ruoso> .partial-invoke($iterator)

[13:16] <ruoso> vs .invoke($capture)

[13:16] <jnthn> And $capture ~~ any(&foo.candidates).signature isn't so hard

[13:16] <jnthn> And makes more explicit what is going on...

[13:16] <moritz_> ruoso: you are aware that it might need disambiguation?

[13:17] <moritz_> if I have two multis, with ($, $) and ($, $, $) and do a partial application against a list, both match if it's long enough

[13:17] <ruoso> that's precisely the reason I want it to be internal to the Multi

[13:18] <moritz_> I think the real problem is that there's no all-that-dwimmy disambituion rule

[13:18] <moritz_> not that if we had one it would be hard to implement

[13:18] <jnthn> ruoso: Are we sure that we're not trying to make some very general-purpose mechanism when we could just make .reduce handle this?

[13:18] <ruoso> jnthn, map for and friends also need it

[13:19] <ruoso> it is general-purpose indeed

[13:19] <masak> ruoso: commit looks good.

[13:20] <ruoso> &multi.invoke-iterating($iterator)

[13:20] <jnthn> ruoso: Do you think making it possible to &multi.push blows away our "we know the set of multi-variatns in a given scope" thingy?

[13:21] <ruoso> jnthn, I don't think so

[13:21] <ruoso> you might need to "close" some multi objects at some point

[13:21] <jnthn> Thing is, the set of multis can change now at runtime...

[13:21] <ruoso> and it is erroneous to do that on multis aliased to lexical scopes

[13:21] <jnthn> And for sure, Rakudo is clearing it's multi-cache so it ain't going to get weird...

[13:22] <jnthn> ruoso: Meaning?

[13:23] <ruoso> jnthn, you don't need to worry much if the user does it... changing a multi that is aliased to a lexical scope is defined to be undefined behavior, iirc

[13:23] <jnthn> Ah, OK.

[13:23] <jnthn> The "If you try and screw with it, it might screw you." principle. :-)

[13:24] *** ejs joined
[13:25] <jnthn> ejs: In Odessa?

[13:26] * jnthn was there like, recently...

[13:27] *** wayland76 joined
[13:28] *** yves joined
[13:31] <ruoso> jnthn, so... what do you think about the .invoke-iterating($iterator) thing?

[13:31] <ruoso> do you think it is possible?

[13:32] *** skids joined
[13:33] <jnthn> ruoso: Let me read your S07 tweaks in detail...just sorting this patch out...

[13:35] * ruoso EOUTOFCOFEE

[13:38] <jnthn> ruoso: So what exactly are you proposing? That we invoke instead of with argumetns with an itereator, and it picks the candidate wanting the most args (up to the limit of those available in the iterator), grabs as many values from the iterator as are needed and then does the call with those?

[13:39] <ruoso> In general, yes...

[13:40] <ruoso> but I think it's up to the Multi to decide if it does LTM or not

[13:40] <ruoso> because the topological sort still needs to be taken into account

[13:41] <jnthn> Hmm

[13:42] <ruoso> I think LTM might be an implicit disambiguator

[13:42] <jnthn> It sounds like a "can we match with the maximum arity? no, then let's try the next one down", etc.

[13:43] <ruoso> that's why it needs to be internal to the multi... 

[13:43] <ruoso> so that decision is not very hard to make later

[13:43] <dalek> rakudo: 76b2652 | jnthn++ |  (3 files):

[13:43] <dalek> rakudo: A bunch of multi-related changes. Perl6MultiSub is now mapped to Multi, so .WHAT works (spectest added, needs to make it into the specification but seems to have consensus on #perl6). Also defined .candidates, which has similar consensus, and .push which allows constructing a multi on-the-fly.

[13:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/76b2652ffc541a17bdfbf2bf073362e7a5451ec3

[13:43] <jnthn> Well, a first cut could try with the max arity, and if it got a failed to call exception, retry with one less...

[13:44] <jnthn> And that can be done external to the multi, though less efficiently...

[13:44] <ruoso> and more static as well

[13:44] <ruoso> doing it inside the multi allows each multi to override that behavior

[13:44] <ruoso> which seems like a good plan if we're not sure which is the best way to do it

[13:47] <jnthn> I still worry we might be making reduce too magical and it may be better for the dispatcher to specify its own that gets the semantics it wants.

[13:47] <jnthn> (It's own reduce-ish algorithm, that is...)

[13:47] <jnthn> OTOH, I can see an argument for making things like reduce handle multis sensibly somehow...

[13:48] <ruoso> jnthn, on the contrary... reduce will simply call .invoke-iterating()

[13:48] <ruoso> and that's not specific for multis

[13:48] <ruoso> because there are optional arguments

[13:49] <ruoso> so .invoke-iterating() is valid for only subs as well

[13:50] <jnthn> hmmm

[13:50] <jnthn> I think I'd rather delegate this one up to TimToady.

[13:50] <jnthn> This is more a language design issue than an implementation one.

[13:50] <wayland76> ruoso++ for pushback :)

[13:51] <wayland76> (err, Iterator::Pushback)

[13:51] <jnthn> I'm more worried about making reduce odder from a user perspective rather than a guts one.

[13:51] *** bacek left
[13:52] <ruoso> jnthn, in what sense?

[13:53] <jnthn> As in, is this going to do what people expect? Or are their expectaions on the dis-ambiguation too varied?

[13:53] <jnthn> There's a time to not be too clever. But that's why I really want to hear input from @Larry on this.

[13:54] <ruoso> jnthn, honestly, I think reduce with varying-arity is something that is going to be used by people that have read the manuals... it's not something a begginer will bump into

[13:55] <jnthn> Aye, true.

[13:55] <jnthn> I'm not against it, just think it needs a wider sanity check.

[13:55] <ruoso> sure... my concern is wether this is actually do-able in rakudo in the short-term

[13:56] <ruoso> since Web.pm is likely to require it

[13:56] <jnthn> As a separate method, probably.

[13:56] <jnthn> Well, Web.pm could write it's own reduce-ish thingy too. ;-)

[13:56] <jnthn> The introspection is all there.

[13:56] <jnthn> but yes, having the dispatcher expressed as one line of Perl 6 is neat. ;-)

[13:56] <ruoso> but the point of using reduce and multi is precisely to use the Perl 6 core features...

[13:57] <ruoso> otherwise we would go with the grammar idea

[13:57] <jnthn> I don't know that it's all that hard to do in Rakudo.

[13:58] <jnthn> Unless you need the pushback iterator stuff too...

[13:58] <ruoso> I don't think you can implement it without the pushback iterator

[13:58] <ruoso> otherwise you wouldn't have how to "undo" the item you consumed but didn't match

[13:59] <jnthn> is invoke-iterating expected to work its way through the whole iterator?

[13:59] <ruoso> no

[13:59] <jnthn> oh

[13:59] <ruoso> just that iteration

[14:00] <jnthn> Just do one?

[14:00] <jnthn> OK.

[14:00] <ruoso> it's one invocation

[14:00] <jnthn> Aha.

[14:00] <jnthn> Now I see the need for the pushback then...

[14:00] <ruoso> specially because reduce needs to do an extra push back

[14:00] <ruoso> with the value of the last invocation

[14:01] <ruoso> (which means this iterator needs to be writeable as well, not just pushback-able)

[14:01] <jnthn> Hmm

[14:01] <jnthn> again, probably not too hard to do, but I don't want to spend too much tuits on this until there's wide consensus that it's The Way To Go.

[14:02] <jnthn> It's not all that hard, but it's not a 30 minutes hack either.

[14:02] <ruoso> now it's time for the all mighty TimToady to throw a hammer

[14:02] <ruoso> ;)

[14:03] <jnthn> Right.

[14:03] <jnthn> I'd like to hear more generally thoughts from TimToady on S07. Like, is it generally the way to go, etc.

[14:04] <ruoso> yeah... S07 needs more input... it's basically a copy of my thoughts yet...

[14:06] <pugs_svn> r25818 | jnthn++ | [t/spec] Test for .WHAT on a multi.

[14:07] *** [particle]1 joined
[14:07] <ruoso> what would be a good name for an iterator that can unshift values?

[14:08] <ruoso> it would be interesting for it to be a specific role, because implementing only "unshift" is much easier than any other write operation

[14:09] <ruoso> it kinda works as pushback, but it doesn't require the value to have been consumed from this iterator earlier

[14:09] <ruoso> that's why it needs to be different than PushBack

[14:10] <ruoso> Iterator::Unshift?

[14:10] <jnthn> is pushback expected to keep track of previous values it provided?

[14:10] <jnthn> so it knows that something used to be part of the iterator?

[14:10] <ruoso> not really... it's "free" to refuse values that were not consumed from it

[14:10] <ruoso> but that's not a requirement

[14:11] <ruoso> it usually would mean that this iterator is backed by a immutable list

[14:12] <ruoso> while Iterator::Unshift would mean that either the original list is mutable, or that the object provide a local stack

[14:13] <jnthn> ah, OK

[14:13] *** hanekomu joined
[14:13] <jnthn> I was expecting pushback would have a local stack.

[14:13] <ruoso> jnthn, my idea of having two roles was to somehow say "expect to fail" or "expect to suceed"

[14:14] <ruoso> (for values not coming in the correct order from this same iterator, that is)

[14:15] *** ejs left
[14:22] <pugs_svn> r25819 | ruoso++ | [spec] Add Iterator::Unshift to S07

[14:22] <frioux> rakudo: 'frew'.split('',2)

[14:22] <p6eval> rakudo 76b265: RESULT«["f", "r", "e", "w"]»

[14:23] <moritz_> that's wrong.

[14:23] <frioux> yeah

[14:23] <frioux> it only does it for ''

[14:23] <moritz_> I know

[14:23] <moritz_> because I special-cased it

[14:23] <frioux> ah

[14:24] <frioux> haha, ok

[14:24] <frioux> well, I have to go to work

[14:24] <frioux> I just wanted to make sure I understood

[14:27] *** nihiliad joined
[14:31] *** hercynium joined
[14:31] <skids> ruoso: "percolate"?  or maybe "excrete" or "exude"?

[14:31] <ruoso> hm?

[14:32] <skids> You were looking for a name...

[14:32] <ruoso> ah... I assumed Iterator::Unshift for now

[14:32] <jnthn> ...excrete?

[14:33] <jnthn> That sounds crap.

[14:33] <jnthn> ;-)

[14:33] <skids> Yeah it was for humor.

[14:33] <skids> :-)

[14:33] <skids> Actually keeping things using the same old vocabulary is probably good, as long as the meaning is consistent.

[14:34] <skids> Though now I really, really want to write some sort of filter for something and call it "percolator" just for the sake of it.

[14:36] <moritz_> rakudo: say "foo".substr(Inf)

[14:36] <p6eval> rakudo 76b265: OUTPUT«Cannot take substr outside string␤␤»

[14:39] <[particle]1> rakudo: <foo>.substr(*).say

[14:39] <p6eval> rakudo 76b265: OUTPUT«Use of uninitialized value␤foo␤»

[14:39] <[particle]1> rakudo: 'foo'.substr(*).say

[14:39] <p6eval> rakudo 76b265: OUTPUT«Use of uninitialized value␤foo␤»

[14:42] *** ejs joined
[14:44] *** ejs left
[14:47] *** skids left
[14:47] *** [particle]2 joined
[14:57] *** hanekomu left
[14:58] <jnthn> Phew. The refactor pmichaud wanted has apparently been easy...

[14:59] *** dollardumb joined
[15:00] <dollardumb> anyone using the ilbot here?

[15:00] <dollardumb> gotta question on an unblessed reference

[15:00] <dollardumb> and AUTOLOAD for that matter

[15:05] *** [particle]1 left
[15:07] <frioux_> moritz_: so why did you special case the '' split?

[15:07] <frioux_> just curious

[15:07] <dollardumb> moritz_ can I ask a question on ilbot install/config?

[15:14] <dalek> rakudo: 4be7d28 | pmichaud++ | docs/spectest-progress.csv:

[15:14] <dalek> rakudo: spectest-progress.csv update: 317 files, 7160 passing, 4 failing

[15:14] <dalek> rakudo: Failure summary:

[15:14] <dalek> rakudo:     S06-multi/syntax.t aborted 1 test(s)

[15:14] <dalek> rakudo:     S12-role/basic.t 27 - attributes typed as roles initialized OK

[15:14] <dalek> rakudo:     S12-role/basic.t 28 - typed attribute accepts things it should

[15:14] <dalek> rakudo:     S12-role/basic.t 29 - typed attribute accepts things it should

[15:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4be7d289c50bdcdc99c4fd9bdba5a8b46432ef7a

[15:14] <dalek> rakudo: f6449a4 | jnthn++ | src/ (2 files):

[15:14] <dalek> rakudo: Minor refactor of method dispatch so we can better handle foreign objects from outside Rakudo, as suggested by pmichaud++.

[15:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f6449a477023db15fce095e484d0a8ca30a94856

[15:15] <dalek> rakudo: 7abaea2 | pmichaud++ | src/ (2 files):

[15:15] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[15:15] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7abaea26f1551edbae71351d0189dc6917212a83

[15:15] *** justatheory joined
[15:18] <jnthn> pmichaud: Huh? Weird results...

[15:19] <jnthn> pmichaud: It did get the spectests at the right period of time rather than latest spectests against old Rakudo?

[15:19] *** frioux joined
[15:19] <pmichaud> jnthn: my script grabs rakudo and tests as of 00:00 CDT, yes.

[15:20] <pmichaud> so the report is (or should be) the state of rakudo as of 00:00 CDT today.

[15:20] <jnthn> pmichaud: OK, but those tests it failed I added earlier today

[15:20] <jnthn> e.g. after 00:00 CDT...

[15:20] <pmichaud> I'll double-check it.

[15:21] <pmichaud> my script thinks it was r25813

[15:22] *** mberends left
[15:22] <pmichaud> maybe I invoked the script wrong earlier.

[15:23] <jnthn> ok, no big deal...guess if it does it again we can look deeper

[15:23] <jnthn> Those are certainly tests I have added today though.

[15:23] <jnthn> pmichaud: Did the dispatch refactor.

[15:24] <pmichaud> jnthn: yes, I saw that.  Looks good.

[15:24] <jnthn> OK, good. :-)

[15:24] <pmichaud> I was also wondering if HOW.dispatch might want some refactoring at some point, to separate out "find the candidates" from "make the call"

[15:25] <pmichaud> you might also review the irc logs w.r.t. the handling of BUILD()

[15:25] <pmichaud> TimToady made quite a few comments on it late yesterday, I think.

[15:25] <jnthn> Ah, OK.

[15:25] <pmichaud> effectively, though, BUILD is handled like a sub dispatch instead of a method dispatch.

[15:26] <jnthn> OK, not sure what the upshot of that is, will find and read...

[15:26] <jnthn> Just testing a multi dispatch fix atm.

[15:27] <jnthn> Edge case...

[15:28] <jnthn> pmichaud: How would you feel about being able to pass to P6Object's .register a named parameter saying "when you make the proto, use the copy opcode to assign it to this PMC, then install that in the namespace etc"

[15:28] <jnthn> The rationale is

[15:28] <jnthn> class A { has A $!x }

[15:29] <jnthn> We don't make the proto for A until after we add the attribute

[15:29] *** finanalyst left
[15:29] <jnthn> So it'd be nice to have some PMC in the namespace as A

[15:29] <pmichaud> I had been thinking that P6object should support incomplete protos.

[15:29] <jnthn> And the proto is copy'd onto it.

[15:30] <jnthn> And it Just Works (I think...)

[15:30] <jnthn> Something like this or a different mechanism?

[15:30] <pmichaud> it doesn't feel quite right to me.

[15:31] <jnthn> OK

[15:31] <jnthn> Then we need something that effectively does a similar thing but does feel right. ;-)

[15:31] <pmichaud> the way I had been thinking of going with p6object was to do basically what rakudo is doing now (more)

[15:32] <pmichaud> i.e., one can register a protoobject, but it's not actually tied to a class until we close the composition (or do an operation that requires the composition be closed)

[15:32] <jnthn> Something like that could work.

[15:32] <pmichaud> so, we do    (1) create protoobject, (2) add attributes, methods, etc, (3) close composition

[15:33] <pmichaud> and keep the same protoobject throughout.

[15:33] <jnthn> *nod*

[15:33] <pmichaud> then rakudo can use protoobjects instead of metaclass

[15:33] <jnthn> Something along those lines sound doable.

[15:33] *** Psyche^ joined
[15:33] <pmichaud> because protoobjects can represent a class in a partial state of composition.

[15:34] <pmichaud> thinking about it more...

[15:34] <pmichaud> ultimately I think what I just described ends up doing what you described, though.

[15:35] <pmichaud> because we have to replace our partial protoobject with another one that is an instance of the newly-composed class

[15:35] <pmichaud> and to do that we have to do a copy

[15:35] <pmichaud> (or a reference or something like that)

[15:37] <jnthn> Right.

[15:37] <pmichaud> how hard would it be to get the type to be attached after the class is finished composing?

[15:37] <jnthn> I was thinking your idea sounded more like a nice abstraction.

[15:37] <jnthn> interface

[15:37] <jnthn> But would boil down to the same...

[15:37] <jnthn> Hmm

[15:37] <jnthn> It'd be a pain...

[15:37] <jnthn> Not really hard.

[15:38] <jnthn> Just messier.

[15:38] <pmichaud> oh.

[15:38] <pmichaud> there's another big piece

[15:38] <pmichaud> (before we head too far down this path)

[15:38] <pmichaud> TimToady has significantly refactored block parsing in STD.pm

[15:39] <pmichaud> STD.pm now tries to do a lot of what I had been doing with $?BLOCK_OPEN

[15:39] <jnthn> That suggests you got it right. :-)

[15:39] <pmichaud> yes, what STD.pm has now is a lot more of what I had wished to see earlier.

[15:40] <pmichaud> but, that's a fairly significant refactor, and I'd prefer to do that after 1.0

[15:40] <pmichaud> (after Parrot 1.0)

[15:40] <pmichaud> i.e., not while I'm traveling about.

[15:40] <pmichaud> so....

[15:40] <pmichaud> I'm fine with your proposal.

[15:41] <pmichaud> i.e., adding a option or other interface to .register that says "use this PMC as the protoobject container"

[15:41] <jnthn> The extra parameter to...right.

[15:41] <pmichaud> we can deprecate it later, I don't expect it to get used much outside of rakudo just yet anyway.

[15:41] <jnthn> Whee. Looks like I got the MMD fix right...

[15:41] <jnthn> Well, how soon do you plan to do your set of changes?

[15:41] <jnthn> It's not a super-urgent bug...

[15:42] *** Psyche^ is now known as Patterner

[15:44] <pugs_svn> r25820 | jnthn++ | [t/spec] Add a couple of tests for MMD to make sure it enforces contraints properly when there's a single candidate with one on.

[15:47] <jnthn> moritz_: On ticket here is waiting for tests, if you get chance - I keep opening it each week to fix and then realize...just needs tests. ;-) http://rt.perl.org/rt3/Ticket/Display.html?id=62162

[15:47] <jnthn> *one

[15:47] <dalek> rakudo: cdd3e7d | jnthn++ | src/pmc/perl6multisub.pmc:

[15:47] <dalek> rakudo: The multi-dispatcher had an off-by-one that caused it not to enforce contraints if there was no tie-breaking needed. The rest of the patch makes sure we don't put stuff in the MMD cache that we should not (if there's a constraint, we can't use the nominal-type-based cache). Resolves RT#63812.

[15:47] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cdd3e7d44d0f407c34ff00658e8ed9875830c3f5

[15:47] <dalek> rakudo: e8a8fb6 | jnthn++ | docs/spectest-progress.csv:

[15:47] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[15:47] <pmichaud> my set of changes to the block stuff will probably be late next week; i.e., around the 20th-23rd

[15:47] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e8a8fb6d5a23e42b2e50dd8c0574548835acacb2

[15:48] <pmichaud> I'm okay with letting    has A $!x;   wait until then.

[15:48] <pmichaud> i.e., you can decide if you want to add the option to p6object or wait until the block refactors occur

[15:48] <jnthn> OK, then in that case I'm not inclined to spend time on a temporary fix that will last a couple of weeks.

[15:49] <pmichaud> with the block refactors it may happen that we end up getting protoobjects immediately after the "class A ..."  part -- before we parse the block.

[15:49] <jnthn> That people aren't clammering to get fixed.

[15:49] <jnthn> If people were lining up to do that I'd do it, but they ain't. So it can wait to be done properly. :-)

[15:51] *** Tene_ joined
[15:51] <pmichaud> my re-run of the spectests for 00:00 CDT came up with the same results -- investigating further.

[15:54] <jnthn> Task for anyone with tuits and some Perl6-fu: review http://rt.perl.org/rt3/Ticket/Display.html?id=63780 and see if it can be narrowed down to a small test case, if indeed it is a bug.

[15:54] *** ujwalic_ left
[15:57] <pmichaud> oh, I know the problem for 63780

[15:57] <pmichaud> the array is getting a reference to the original instead of a clone

[15:57] <pmichaud> it might have to do with our ObjectRef semantics

[15:58] <pmichaud> i.e., we may be checking for ObjectRef when we need to be checking for Perl6Scalar

[15:58] <jnthn> Ah

[15:58] <jnthn> I've fixed a few things like that before now. :-/

[16:00] *** [particle]2 left
[16:01] <jnthn> oh ouch :-|

[16:01] <jnthn> my %h = a => any(3, 4); for %h.kv -> $k, $v { say "$k: {$v.WHAT}" };

[16:02] *** Tene left
[16:02] <jnthn> Here, the value auto-threads correct...

[16:02] <jnthn> But we detect the need to do so inside signature bind

[16:02] <jnthn> And I was using 'return' to then hand back the formed results junction

[16:02] <jnthn> Which was fine for auto-threading routines...

[16:03] <jnthn> But not blocks.

[16:03] * jnthn ponders how to return from a level below...

[16:04] <ruoso> lift leave;

[16:04] <ruoso> :)

[16:04] <pmichaud> okay, I found the issue with the incorrect test reports.

[16:04] <jnthn> ruoso: lift?

[16:05] <ruoso> it's the new prefix 

[16:05] <ruoso> "run this code as if it was in the CALLER"... oh...  right... it doesn't work for that specific case

[16:05] <pmichaud> jnthn: 'return' and not '.return' ?

[16:05] <jnthn> pmichaud: I don't want to return from signature_bind, I want to return from the thingy that called it.

[16:06] <jnthn> I'd overlooked that blocks that werne't routines got signautures too...

[16:07] <pmichaud> wait... signature_bind is handling junction autothreading?

[16:07] <jnthn> yes and no

[16:07] <pmichaud> shouldn't the dispatcher be doing that?

[16:08] <ruoso> pmichaud, but what if the Signature expects Junction?

[16:08] <pmichaud> the dispatcher autothreads when we have arguments that don't match any of the available signatures (and at least one argument is a Junction)

[16:09] <pmichaud> if a Signature expects Junction, then the dispatcher uses it.

[16:09] <jnthn> It's along the lines of, try the call, if the signature fails to bind, then see if it's failed due to a junctional argument, and if so delegate to the junction dispatcher.

[16:09] <jnthn> For multis it's a bit different

[16:09] <jnthn> We cache the junction dispatcher in the table.

[16:09] <jnthn> *in the cache

[16:10] <pmichaud> either way I think the dispatcher should be handling autothreading, not the signature bind.

[16:10] <jnthn> What dispatcher?

[16:10] <pmichaud> whichever one is being called upon to do a dispatch :-)

[16:11] <pmichaud> you're referring to the case of a non-multi sub?

[16:12] <jnthn> Yes

[16:12] <jnthn> It's a neat and tidy implementaiton, this one issue non-withstanding.

[16:12] <pmichaud> I've been thinking that we might have to do sub-dispatch in the way we're currently handling method dispatch (after your changes this morning)

[16:12] <pmichaud> put another way -- Parrot's dispatch is insufficient for our needs.

[16:13] <jnthn> I'm not convinced.

[16:13] <jnthn> In fact, the way I have implemented this seems to me in line with a way S06 explicitly declares as a valid approach.

[16:13] <jnthn> See under Implementation note on autothreading of only subs

[16:13] <jnthn> Of note

[16:13] <jnthn> So it is also possible to implement autothreading

[16:13] <jnthn> of only subs based on failover from the binding failure.

[16:14] <pmichaud> yes, but there I think it's the dispatcher that notices the failover, not the sub itself.

[16:15] <jnthn> That's all well and good part from in Rakudo we're already *inside* the sub by the point we try binding

[16:15] <jnthn> *apart

[16:15] <pmichaud> right, the binding fails, that causes an exception, the dispatcher catches the exception and says "oh, maybe I need a Junction dispatch"

[16:16] <jnthn> I prefer the current approach. Doesn't involve throwing exceptions for one.

[16:16] *** pguillaum joined
[16:16] *** pguillaum left
[16:16] *** pguillaum joined
[16:17] <jnthn> Also note that if you add another dispatcher then you have to use it for things as simple as for @foo -> $x { }

[16:17] <pmichaud> yes, I know that.

[16:17] <jnthn> Not just for subroutine calls.

[16:17] <jnthn> Which feels very messy to me.

[16:17] <jnthn> If you have other use cases for having a separate sub dispatcher, I'm willing to be won over. But if this is the only one, I much prefer the current approach.

[16:18] <pmichaud> to me   for @foo -> $x { ... }   does involve a subroutine call -- or at least a block invocation (which in Parrot is a sub call)

[16:18] *** pguillaum left
[16:18] <jnthn> For me too.

[16:19] <jnthn> I just don't see that we need another !dispatch_sub layer.

[16:19] <pmichaud> also note that in this case you *still* have an exception taking place -- it's just a return exception instead of a binding failure

[16:19] <jnthn> Actually the return exception is a mistake, it turns out...

[16:19] <pmichaud> right, but you're not going to be able to avoid the exception.

[16:20] <pmichaud> either that or we start creating and passing continuations around.

[16:20] <jnthn> It did occur to me that in theory we "just" need to get an invoke our caller's ret cont.

[16:21] <pmichaud> the other option is to check the signature bind return

[16:21] <pmichaud> (which I don't think we do now)

[16:21] <pmichaud> but that seems messy also.

[16:22] <jnthn> Ah, hmm

[16:22] <jnthn> yes

[16:22] <pmichaud> I'd rather do an exception, I think.

[16:22] <pmichaud> we're going to have to have the ability to force .leave on a block anyway.

[16:23] <pmichaud> that sounds like an exception.

[16:23] <pmichaud> or a method on a block that finds the block's return continuation and invokes it

[16:23] <pmichaud> *that* sounds clean.

[16:24] <jnthn> That sounds like what .leave would do

[16:24] <pmichaud> then signature bind just does     CALLER.leave( junction_result )

[16:24] <jnthn> Right

[16:24] <jnthn> We need to implemented CALLER and leave anyway

[16:24] <pmichaud> I'd be fine with a .leave implementation for blocks.

[16:24] <pmichaud> CALLER we can get from within signature bind via getinterp

[16:25] <pmichaud> that sounds like fun, actually.

[16:25] <pmichaud> I'm afraid I have to go now -- have to help get things ready for airport.

[16:25] <pmichaud> (and we leave in 35 mins)

[16:25] <pmichaud> I'd go for the .leave approach.  I think we'll get some big wins that way.

[16:27] <pmichaud> jnthn: you're correct, my script was using the wrong test suite.  it would reset the suite to 00:00 CDT, and then a later step would inadvertently do an update to head

[16:27] <jnthn> pmichaud: Ah, OK. :-)

[16:27] <jnthn> I'll look at .leave

[16:28] <pmichaud> if PIR makes it possible to get at a Sub's return continuation, it shouldn't be too difficult.

[16:28] <jnthn> Have a good flight and break.

[16:28] <jnthn> Yes, not sure if it does...well, we'll see ;_)

[16:28] <pmichaud> I should be around again tonight and during the week, checking email at least.

[16:28] <pmichaud> I still have a number of parrot-related things to finish up over the weekend.

[16:29] <pmichaud> fortunately the first few days aren't loaded with activities.

[16:29] <jnthn> OK, sounds good.

[16:32] <TimToady> peddle hard

[16:33] <dalek> rakudo: 3797055 | pmichaud++ | docs/spectest-progress.csv:

[16:33] <dalek> rakudo: spectest-progress.csv correction: 317 files, 7152 passing, 2 failing

[16:33] <dalek> rakudo: Failure summary:

[16:33] <dalek> rakudo:     S12-methods/instance.rakudo aborted 2 test(s)

[16:33] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3797055f4b77e7156d890f3b183148cf35e2929a

[16:34] * jnthn looks at specs for .leave

[16:40] <jnthn> oh hey, it works :-D

[16:41] <jnthn> (not .leave, but the underlying Parrot thingy)

[16:45] <jnthn> ...well, nearly...

[16:47] *** dollardumb left
[17:01] <ruoso> TimToady, had you notice the new proposal on the partial match in reduce?

[17:02] <TimToady> still waiting for the blood to hit my coffeestream

[17:06] <diakopter> brain.splash()

[17:09] <TimToady> and the backlog today is monumental

[17:11] *** M_o_C joined
[17:11] <ruoso> in summary: the idea is to use a different invocation method. .invoke-iterating($iterator) that would receive a Iterator::PushBack

[17:11] <ruoso> instead of using plain .invoke 

[17:11] <ruoso> that way, it would consume the values, returning what it didn't use

[17:12] <ruoso> and then invoke

[17:12] <ruoso> s/returning/pushing-back/

[17:14] *** mberends joined
[17:17] *** c9s joined
[17:22] *** c9s left
[17:22] *** c9s joined
[17:25] *** barney joined
[17:25] *** ejs joined
[17:26] *** ejs left
[17:26] *** rindolf joined
[17:35] *** mberends left
[17:47] *** hercynium left
[18:08] *** masak joined
[18:23] <TimToady> ruoso: the actual name of Iterator::Unshift is probably just Array :)

[18:23] <Matt-W> what's the string repetition operator in Perl 6? Is it still x?

[18:24] <TimToady> presuming we give Array an Iterator role

[18:24] <jnthn> Matt-W: x for string rep

[18:24] <TimToady> yes

[18:24] <jnthn> xx for array rep

[18:24] <Matt-W> thanks

[18:24] <Tene_> TimToady: does CONTROL{} catch leave() ?

[18:24] <jnthn> Otherwise worded as, is leave a control exception?

[18:25] <TimToady> offhand, I'd say it seems more like a primitive for unwinding the stack *after* the exceptions have figgered things out

[18:26] <TimToady> gotta have some primitives somewhere...

[18:26] <TimToady> and it would be nice if they were exposed in Perl 6 to the extent they can be cross-platform

[18:26] <Tene_> huh.

[18:27] <TimToady> and I suspect leave can do that

[18:27] <Tene_> "exposed ... cross-platform" ?

[18:27] <jnthn> TimToady: Such that if a block had a "return continuation" in a given implementation, which left the block when invoked, it would be plausible that calling that is the right thing?

[18:27] <jnthn> (I know it won't be a way for implementations without continuations.)

[18:27] <TimToady> yes, provided you made sure all the exit hooks get run

[18:28] <jnthn> And the exit hooks of all enclosing blocks?

[18:28] <TimToady> unwinding the stack involves executing LEAVE blocks and such

[18:28] <jnthn> Ah, OK.

[18:28] *** simcop2387-vnc joined
[18:29] *** simcop2387-vnc left
[18:29] <TimToady> that has to be done synchronously; can't leave it up to GC

[18:29] <jnthn> Hmm

[18:29] <jnthn> OK

[18:29] <TimToady> since leave blocks are our replacement for timely destruction

[18:29] <jnthn> So leave needs to make sure all those are invoked down to the block that's being left.

[18:29] <TimToady> leave and variants

[18:29] <jnthn> ok

[18:30] <TimToady> basically, dynamic scopes have to be destroyed explicitly

[18:31] * TimToady is trying hard not to think about continuations right about now

[18:31] <jnthn> in

[18:31] <jnthn> &foo.leave: 1,2,3;          # Return from innermost surrounding call to &foo

[18:32] <jnthn> call implies to me dynamic scope and innermost surrounding implies to me lexical.

[18:32] *** Southen joined
[18:32] <jnthn> Are we looking for a foo up the static or dynamic chain?

[18:32] <TimToady> you're searching the dynamic context for a particular lexical context

[18:32] <TimToady> xkcd.com logo

[18:33] <Tene_> eh?

[18:33] <Tene_> http://imgs.xkcd.com/static/xkcdLogo.png ?

[18:34] <TimToady> what, I didn't type that... o_O

[18:34] <TimToady> I guess it was a past

[18:34] <TimToady> *paste

[18:35] <Tene_> you totally did.  I watched you type it.

[18:35] <TimToady> though I don't know it got copied in the first place...

[18:36] <TimToady> *know how

[18:36] <jnthn> Tene: OK, so if we are going to walk up the chain until we find the sub we're looking for, calling the various LEAVE etc on the way, then I guess we'd be then able to call the ret cont. Which brings me back to square one wiht the problem I was describing on #parrot...

[18:37] *** Southen_ left
[18:38] <TimToady> it's possible that leave isn't so primitive after all, of course

[18:38] <jnthn> True.

[18:39] <TimToady> but I think searching for the scope to leave is probably a separate pass from unwinding

[18:39] <TimToady> and it's the unwinding that actually runs the blocks

[18:39] <jnthn> That makes sense.

[18:40] <TimToady> in the case of normal exceptions, it's the exception handlers that, among themselves, decide how much to unwind

[18:40] <TimToady> in the case of something like LABEL.next, we have a lexically scoped symbol that just needs to be located in the dynamic context

[18:40] <TimToady> probably context() with a smartmatched arg

[18:41] <TimToady> and that then decided where to unwind, without any exception handling at all

[18:41] <TimToady> though it can be done with control exceptions too

[18:42] <TimToady> but an NEXT block isn't run by a control exception, but by the unwinding, since it's a LEAVE variant

[18:43] <TimToady> I suppose maximum flexibility does the context search using control exceptions, not context()

[18:43] <TimToady> but context() will probably be faster, if we can optimize to it

[18:44] <TimToady> kinda stupid to use a control exception to exit your own block, for instance

[18:44] <TimToady> when you know everything that's in it

[18:44] *** skids joined
[18:44] <TimToady> I guess the dynamic scope could register whether it wants to intercept control exceptions of various sorts

[18:45] <TimToady> and just use context() search out to wherever they were registered, then throw

[18:46] <TimToady> on the gripping hand, maybe context() is doing its searching with a control exception :)

[18:47] <TimToady> well, it's chortles all the way down...

[18:47] * jnthn sudders

[18:47] * masak udders

[18:48] <jnthn> *shudders... :-P

[19:06] *** kst joined
[19:07] *** kst left
[19:10] *** kst joined
[19:16] <jnthn> OK, dinner time. Back later

[19:16] *** barney left
[19:20] <mikehh> rakudo (3797055) on parrot r37384 builds make test make spectest PASS - t/spec/S02-literals/sub-calls.rakudo: TODO passed 16.

[19:20] <mikehh> thats on Kubuntu Intrepid i386

[19:22] *** rindolf left
[19:26] *** masak left
[19:53] <ruoso> TimToady, Iterator::Unshift can't pop, for instance... nor it provides .[]... 

[19:54] <ruoso> I'd guess Array does Iterator::Unshift...

[19:54] <ruoso> so you can use it wherever you would use an Iterator::Unshift

[19:54] <ruoso> but my concern is the opposite...

[19:54] <ruoso> I'd like to make sure you can implement the minimal API to get some functionality

[19:56] <ruoso> that's actually the same reasoning behind splitting IO into several roles

[19:58] <ruoso> so you can make a contract of using just a specific subset of API

[20:04] <ruoso> TimToady, in the specific case of .invoke-iterating and reduce, this iterator object would be a proxy to the actual capture that would consume the values from the immutable (which means only keeping a pointer) and also keeping a stack to receive the pushbacks and the result of each iteration via unshift... So it doesn't need to implement the whole Array API... just Iterator, Iterator::PushBack and Iterator::Unshift

[20:06] <ruoso> in the case of map and grep, it only needs to implement Iterator and Iterator::PushBack

[20:06] <ruoso> since it doesn't need to inject the result of the previous invocation in the parameters

[20:17] *** donaldh joined
[20:29] *** mberends joined
[20:29] <TimToady> I don't see a need to separate PushBack and Unshift, offhand

[20:31] <ruoso> I'm also quite unsure about that 

[20:31] <ruoso> but my idea was to provide room for optimization

[20:31] <ruoso> since pushback places a teoretical restriction on how it is used

[20:32] <ruoso> so an Iterator::PushBack that is backed by an immutable list can simply contain a pointer to the current position

[20:33] <ruoso> and it would check if the object being pushed back matches to the one in that list

[20:35] * ruoso just came to an interesting realization... SMOP objects can be binary-interoperable even if there are no common libraries being linked...

[20:43] <frioux> do you guys think it would be possible with perl6 to have some kind of lazily interpolated strings?

[20:44] <frioux> so like, DBI could autoescape "SELECT foo WHERE foo = $bar"

[20:44] <frioux> because that could be really cool

[20:44] <ruoso> frioux, that requirement is void if you use placeholders (which is something you should)

[20:44] <frioux> ruoso: oh of course

[20:45] <frioux> not using placeholders is ridiculous

[20:45] <frioux> but I am just thinking that it would be really cool if we could make the interface a little nicer

[20:45] * jnthn back from the food

[20:46] <frioux> kindav an autoplaceholder thing

[20:46] * ruoso decommute &

[20:46] <frioux> but maybe that's just too weird

[20:46] *** ruoso left
[20:52] *** yary joined
[20:53] <yary> Hello all again!

[20:53] <yary> Thanks to wayland76 and ruoso for answering my Qs off-line

[20:54] <yary> Re: wayland76 "As far as the usenet group goes, I'd never heard of it until you mentioned it..."

[20:54] <yary> they are referred to on http://www.perlfoundation.org/perl6/index.cgi?mail_lists_irc_archives

[20:55] <yary> and the one I had tried posting to is at http://groups.google.com/group/perl.perl6.users/topics

[20:56] <yary> I'm a bit more comfortable with newsgroups- for one thing I'm often interrupted- like now, I have to leave again for a bit!

[21:05] <skids> frioux: you could write a Str is enhanced module that checks for tags in a caller's package, but the challenge would be getting people to use it :-)

[21:07] <skids> (The extra poorness of that idea is now just dawning on me)

[21:08] <skids> So if I read this right, "let $a = x" is (let $a) = x, because it's a named unary.  OK now I'm much less confused.

[21:12] <frioux> hahaha

[21:15] <wayland76> yary: I'd recommend the mailing list perl6-users mentioned at http://dev.perl.org/perl6/lists/

[21:15] <wayland76> Actually, it's likely this links to the mailing list

[21:30] *** Limbic_Region joined
[21:30] <yary> If you try to subscribe and post to the list via the google groups page, it says your post succeeds, but it seems to go nowhere

[21:33] <frioux> yary: it takes a little while for your first post to go through

[21:34] <yary> I will subscribe to the perl6.users mailing list the normal way, but I found the google groups interface first, and I may not be the first.

[21:34] <yary> frioux: my post was 3-4 days ago and another persons post came in & worked after my attempt

[21:34] <frioux> 3-4 days is much longer than it should be

[21:34] <frioux> it should be like, 1-2 hours

[21:35] <frioux> although, I subscribed the normal way too, not the google groups way

[21:35] <frioux> so maybe there is some problem there

[21:36] <yary> My specific old post is not an issue now, as I have answers through here... just the larger issue of a post going missing, could dissuade a casual questioner.

[21:36] <frioux> right, agreed

[21:39] *** moritz_ left
[21:39] *** moritz__ joined
[21:43] <yary> I see there's now a note about google groups on the http://www.perlfoundation.org/perl6/index.cgi?mail_lists_irc_archives page, good job! (or was it always there and I missed it? ah well.)

[21:46] *** hercynium joined
[21:46] *** nihiliad left
[21:46] *** nihiliad joined
[21:54] *** donaldh left
[21:57] *** meppl joined
[22:00] *** pmurias_ joined
[22:03] *** sri_kraih_ left
[22:06] <yary> Encountering error when rebuilding a fresh checkout of rakudo ( to try out the fix for "Null PMC access in &f.signature.params")

[22:06] <yary> Null PMC access in get_pmc_keyed_str()

[22:07] <yary> gmake: *** [runtime/parrot/include/parrotlib.pbc] Error 1

[22:07] <yary> ^ that's the output from "perl Configure.pl --gen-parrot"

[22:11] *** M_o_C left
[22:26] *** skids left
[22:27] *** ruoso joined
[22:47] * wayland76 reboots to debug xorg some more

[22:47] *** wayland76 left
[22:47] *** Kimtaro joined
[22:51] <dalek> rakudo: 519b873 | jnthn++ | src/ (2 files):

[22:51] <dalek> rakudo: Avoid using a null PMC in param describing data structure, and use an undef instead; it only invites null PMC exceptions (as in RT#63570).

[22:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/519b8737281f8fc4999ae32c4fe9e690fe331f31

[22:51] <dalek> rakudo: 41267fd | jnthn++ | docs/spectest-progress.csv:

[22:51] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[22:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/41267fdc19291adbf10504372f89773579f00f1e

[23:14] *** wayland76 joined
[23:30] *** krunen_ joined
[23:31] *** Limbic_Region left
[23:31] *** skids joined
[23:32] <jnthn> ok, I have a working bunch of patches to make outer lexicals visible inside of an eval.

[23:33] <jnthn> But it involves a Parrot addition and a fix to set_outer that I need to write tests for, plus need to smoke Parrot and Rakudo with it, and I'm knackered...

[23:33] <jnthn> So, will put it all in tomorrow.

[23:43] *** araujo joined
[23:45] *** yary left
