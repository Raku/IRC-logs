[00:00] <TimToady> essentially, the BEGIN there is redundant, since 1+2 should do constant folding anyway

[00:00] <TimToady> but at some point you have the AST for 1+2, and you do $ast.run or some such, and it returns 3

[00:00] <diakopter> (but assuming optimizations entirely disabled)

[00:01] <TimToady> with the BEGIN it doesn't matter if they're disabled

[00:01] <TimToady> when BEGIN finishes parsing its block it automatically calls .run

[00:01] <TimToady> or .eval, or whatever the method should be

[00:02] <TimToady> in p5, BEGIN was only used for its side effects

[00:02] <TimToady> you can do that in p6 too, but it also returns a value now

[00:02] *** rkendall left
[00:03] <TimToady> if I say BEGIN { COMPILING::<&foo> := {...} }

[00:04] <TimToady> it's just like saying sub foo {...}

[00:04] <TimToady> er, make that sub {...} inside the begin

[00:04] <TimToady> or return won't work

[00:05] <TimToady> anyway, most declarations are just syntactic sugar for some code running and poking bindings into the COMPILING:: symbol table

[00:05] <diakopter> so the AST of { COMPILING::<&foo> := sub {...} }   is sent to the interpreter, including symbol tables and such

[00:06] <diakopter> and the modified symbol table is sent back to the parser?

[00:06] <TimToady> in general the parser short-circuits that for known declarations and just does it itself

[00:06] <TimToady> I'm speaking of declarations in the abstract

[00:06] <TimToady> it's not "sent back"

[00:07] *** Ariens_Hyperion left
[00:07] <TimToady> COMPILING:: *is* the symbol table

[00:07] <diakopter> ok... the interpreter reinvokes the parser from where it left off?

[00:07] <diakopter> or you're viewing the parser as the runtime of sorts.

[00:07] <TimToady> no, the parser calls the interpreter, and it just returns when done

[00:07] <TimToady> the parser is always in the outer dynamic scope

[00:08] *** japhb left
[00:09] <TimToady> the parser is just a running program

[00:09] <diakopter> ok, I'd call the parser the master runtime, then.  what about if the interpreter needs to invoke the parser in the course of its execution?

[00:09] <TimToady> it happens to be a program that parses

[00:10] <TimToady> the parser sets up the current language and parse state such that the interpreter can call methods on the the current parse if it wants to

[00:11] <TimToady> it's no different than, say passing the current Perl langauge down through regexes so that regexes know what langauge to run inside {...}

[00:11] <diakopter> ok; interesting.  perhaps injecting "callbacks" of sort to itself

[00:11] *** japhb joined
[00:12] <TimToady> gotta take kids to airport

[00:12] <TimToady> bbl &

[00:12] *** orafu joined
[00:15] *** orafu left
[00:15] *** orafu joined
[00:21] <pasteling> "samlh" at 151.159.106.132 pasted "patch for perl6-projects.org for moritz" (30 lines, 531B) at http://sial.org/pbot/35347

[00:22] *** kane_ joined
[00:34] *** japhb left
[00:37] *** japhb joined
[00:37] <pasteling> "samlh" at 151.159.106.132 pasted "patch for perl6-projects.org for moritz - v2 (looks better on IE)" (30 lines, 530B) at http://sial.org/pbot/35348

[00:40] *** armagad joined
[00:41] *** japhb left
[00:50] <wayland76> pmichaud: If it helps, I'm keen to have library calls too, just like japhb :)

[00:51] <wayland76> (I don't want to *bug* you about it, if you'll excuse the pun, :) )

[00:54] *** aindilis` joined
[00:55] *** bacek_ joined
[00:57] *** nihiliad joined
[01:04] *** japhb joined
[01:15] *** Sepheebear joined
[01:23] *** FurnaceBoy joined
[01:25] *** Patterner left
[01:35] *** Kimtaro joined
[01:37] *** Tene_ joined
[01:46] *** alc joined
[01:52] *** japhb left
[01:53] *** wknight8111 left
[02:18] *** hercynium joined
[02:19] *** xuser left
[02:19] *** xuser joined
[02:21] *** r0bby_ joined
[02:21] *** r0bby left
[02:24] *** c9s joined
[02:27] *** armagad left
[02:32] *** nihiliad left
[02:33] *** armagad joined
[02:35] *** felipe left
[02:55] *** c9s_ left
[03:00] *** nihiliad joined
[03:05] *** eternaleye_ joined
[03:07] *** nihiliad left
[03:13] *** tarbo2_ joined
[03:14] *** felipe joined
[03:14] *** Kimtaro left
[03:16] *** Kimtaro joined
[03:16] *** aindilis` left
[03:16] *** Kimtaro left
[03:16] *** tarbo2 left
[03:17] *** eternaleye joined
[03:23] *** eternaleye_ left
[03:23] *** ashizawa joined
[03:23] *** eternaleye left
[03:36] *** nihiliad joined
[03:45] *** hercynium left
[03:46] *** Limbic_Region left
[03:52] *** Kimtaro joined
[03:54] <pugs_svn> r25697 | lwall++ | [viv] bring up to date with <?> changes

[03:55] *** dduncan joined
[04:01] *** PZt joined
[04:07] *** orafu left
[04:07] *** OuLouFu joined
[04:13] <jaldhar> Correct me if I'm wrong but I can specify a unicode character like this \c[DEVANAGARI LETTER JA] yes?  Does rakudo currently not support that?

[04:16] <literal> rakudo: "\c[LATIN CAPITAL LETTER A]"

[04:16] <p6eval> rakudo 412cbe: OUTPUT«Syntax error at line 1, near "\"\\c[LATIN "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[04:16] <literal> oops

[04:16] <literal> oohm

[04:17] <literal> rakudo: say "\c97"

[04:17] <p6eval> rakudo 412cbe: OUTPUT«a␤»

[04:18] <literal> rakudo: say "\c[LATIN CAPITAL LETTER A]"

[04:18] <p6eval> rakudo 412cbe: OUTPUT«say requires an argument at line 1, near " \"\\c[LATIN"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[04:18] *** ab5tract joined
[04:21] *** meppuru joined
[04:24] <meppuru> good night

[04:25] *** alc left
[04:25] *** meppuru left
[04:29] *** frooh left
[04:29] <diakopter> std: \c[LATIN CAPITAL LETTER A]

[04:29] <p6eval> std 25697: OUTPUT«Undeclared names:␤     A used at 1 ␤     CAPITAL used at 1 ␤       LATIN used at 1 ␤ LETTER used at 1 ␤Undeclared routine:␤      c used at 1 ␤ok 00:02 34m␤»

[04:29] *** frooh joined
[04:29] <diakopter> std: "\c[LATIN CAPITAL LETTER A]"

[04:29] <p6eval> std 25697: OUTPUT«ok 00:03 34m␤»

[04:30] <diakopter> std: "\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]"

[04:30] <p6eval> std 25697: OUTPUT«ok 00:04 34m␤»

[04:30] <diakopter> std: "\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]\c[LATIN CAPITAL LETTER A]"

[04:30] <p6eval> std 25697: OUTPUT«ok 00:04 34m␤»

[04:30] <diakopter> it likes 34ms

[04:31] <bacek_> 34 megabytes

[04:31] <bacek_> 4 seconds

[04:44] <wayland76> jaldhar: To answer your question, it appears that rakudo doesn't do that at the moment, but that STD.pm does

[04:44] *** japhb joined
[04:44] <wayland76> As the plan is that rakudo will eventually use STD.pm, it's certainly part of the whole plan.

[04:47] <jaldhar> so for now it looks like I'll just have to use the literal characters. 

[04:47] <jaldhar> Or I can use \x I suppose.  That appears to work

[04:50] *** r0bby_ is now known as r0bby

[04:53] <jaldhar> spoke to soon

[04:53] <jaldhar> Could not find non-existent sub x0905

[05:00] <wayland76> rakudo: print "\x0905";

[05:00] <p6eval> rakudo 412cbe: OUTPUT«अ»

[05:00] <wayland76> Well, it works for me :)

[05:00] <wayland76> Did you put it in quotes?

[05:03] *** FurnaceBoy left
[05:04] *** FurnaceBoy joined
[05:04] *** FurnaceBoy left
[05:15] <TimToady> looks like the right character to me, DEVANGARI LETTER A is U+0905

[05:20] *** [particle]2 left
[05:21] *** [particle] joined
[05:23] <jaldhar> doh! sorry my fault. I had it single-quoted.

[05:23] <wayland76> That would do it :)

[05:24] <TimToady> single quotes would not complain about a non-existent sub though

[05:24] <wayland76> I do that sometimes :)

[05:24] <TimToady> had to have been outside of quotes

[05:24] <wayland76> rakudo: say '\x0905'

[05:24] <p6eval> rakudo 412cbe: OUTPUT«\x0905␤»

[05:24] <wayland76> rakudo: say \x0905

[05:24] <p6eval> rakudo 412cbe: OUTPUT«Could not find non-existent sub x0905␤current instr.: '_block14' pc 53 (EVAL_17:38)␤»

[05:24] <TimToady> I wonder how many of those kinds of errors STD can give informative messages on...

[05:24] <wayland76> rakudo: say x0905

[05:24] <p6eval> rakudo 412cbe: OUTPUT«Could not find non-existent sub x0905␤current instr.: '_block14' pc 53 (EVAL_16:38)␤»

[05:25] <TimToady> std: \x0905

[05:25] <p6eval> std 25697: OUTPUT«Undeclared routine:␤   x0905 used at 1 ␤ok 00:02 34m␤»

[05:26] <jaldhar> more egg on my face.  Yes there was an instance outside of quotes altogether as well as the one in single quotes

[05:27] <wayland76> Well, fry the egg and make an omlette :)

[05:28] <TimToady> I'm trying to decide if \foo ever makes sense in p6, or if we can restrict to \(), \@, \% etc.

[05:28] <TimToady> in scalar context foo() already returns a capture

[05:29] <wayland76> Probably sometime you'll want it to tokenise as \f oo or something :)

[05:29] <TimToady> not outside quotes

[05:29] <wayland76> Yeah, you're probably right

[05:29] <TimToady> but I'd like to recognize \x and such outside of quotes maybe and say something intelligent

[05:30] <wayland76> "To Unicode, or not to Unicode, that is the question" :)

[05:30] <wayland76> Or did you want more intelligent than that? :)

[05:30] <wayland76> Three \x's for Muster Mark? :)

[05:31] <TimToady> more like: Found \x outside of quotes where it doesn't make much sense

[05:31] <wayland76> Bad \x corrupts good character? :)

[05:31] <wayland76> Yeah, that would do it :)

[05:31] <TimToady> except arguably it does make a kind of sense

[05:31] <TimToady> it's just we don't support it by any current definition

[05:31] <wayland76> Oh, should we allow people to name their subroutines in unicode that way? :)

[05:32] <TimToady> that's not the idea

[05:32] <TimToady> but $x = \x263a; could be taught to put a smiley into $x

[05:32] <wayland76> I guess

[05:32] <TimToady> the use case seems weak however

[05:33] <wayland76> But I think we support enough things already :)

[05:33] <TimToady> no we don't--we support too many things already :)

[05:33] <ab5tract> hehe

[05:33] <wayland76> Well, that may well be true

[05:33] *** alc joined
[05:33] <TimToady> much of my spec work over the last couple years has been simplification

[05:33] <wayland76> Actually, we probably support the right number, but the wrong ones :)

[05:34] <TimToady> oh, undoubtedly

[05:35] <ab5tract> TimToady: That's at the heart of the beauty that you create. It's so overpowered the syntax has to become mutable to support, but you narrow it down to the bare essentials on the way.

[05:36] <ab5tract> and with Perl 6 s/you/We/ in the Royal sense of Community 'We;

[05:36] <TimToady> well, our nefarious plan is to make a perfectly extensible engine, and then give people so many options in CORE that they never feel the need to extend it.

[05:36] <wayland76> ...except in obfus :)

[05:37] <ab5tract> Oh no worries I am well aware of the plan.

[05:37] <ab5tract> ;)

[05:38] <TimToady> std: &[-rated]::={...}; 42 R-rated 123;

[05:38] <p6eval> std 25697: OUTPUT«############# PARSE FAILED #############␤Can't understand next input--giving up␤Unable to parse variable; couldn't find final ']'␤Unable to parse variable; couldn't find final ']'␤Unable to parse variable; couldn't find final ']'␤Unable to parse variable; couldn't find final ']'

[05:38] <p6eval> .....

[05:38] <TimToady> won't like it

[05:38] <wayland76> Question -- should output line/field separators be replaced with stringification separators?

[05:38] <ab5tract> Just wanted to take this beautiful lurker moment up a notch and deliver my compliments to you and the whole Perl 6 community for what has for the last 8 years been a gleam in the eye

[05:39] <TimToady> std: my &[-rated]::={...}; 42 R-rated 123;

[05:39] <p6eval> std 25697: OUTPUT«Undeclared routine:␤   rated used at 1 1 ␤ok 00:03 48m␤»

[05:39] <ab5tract> and is now Seriously Coalescing

[05:39] <TimToady> std: my &infix:<-rated>::={...}; 42 R-rated 123;

[05:39] <p6eval> std 25697: OUTPUT«ok 00:03 47m␤»

[05:39] <TimToady> probably should allow &[] form on lhs

[05:40] <TimToady> ab5tract: thanks!

[05:40] <TimToady> wayland76: that would be called "join"

[05:41] <wayland76> It would, rather.  That answers my question :)

[05:41] <ab5tract> TimToady: Your welcome. And I mean it sincerely. I've been namedropping Perl 6 on Parrot since before it was known as Rakudo, so...

[05:41] <wayland76> ...maybe

[05:41] <ab5tract> It's really satisfying to have been proven right.

[05:41] <ab5tract> BTW I have know idea what

[05:41] <ab5tract> std: my &infix:<-rated>::={...}; 42 R-rated 123;

[05:41] <p6eval> std 25697: OUTPUT«ok 00:03 47m␤»

[05:42] <ab5tract> is, but it's numerics are groovy.

[05:42] <wayland76> He declared a new infix operator called "-rated", and then used it :)

[05:42] <TimToady> with the R metaoperator

[05:42] <TimToady> which reverses the two args

[05:42] <wayland76> Ah, of course.  I knew there was something funny going on :)

[05:42] <ab5tract> Crap I haven't even heard of the metaoperators somehow

[05:43] <TimToady> you get X-rated for free too :)

[05:43] <wayland76> Meta-operators change how operators work

[05:43] <wayland76> TimToady: :)

[05:43] <ab5tract> lol No worries not digging for an explanation 

[05:43] <TimToady> you're familiar with the notion from C, perhaps, where += is the = metaoperator applied to +

[05:43] * ab5tract can RAFM

[05:44] <ab5tract> yes yes. Hm, I never thought of it so meta 

[05:44] <ab5tract> before

[05:44] <ab5tract> Had become intuitive.

[05:44] <TimToady> that's because C just hardwired it for some operators instead of generalizing the idea

[05:44] <wayland76> Another example from the manual is this...

[05:44] <wayland76> [+] 1, 2, 3;      # 1 + 2 + 3 = 6

[05:44] <ab5tract> Right. Like Perl 5 ;)

[05:44] <TimToady> std: sub infix:<***> {...}; my $x ***= 42;

[05:45] <p6eval> std 25697: OUTPUT«ok 00:03 35m␤»

[05:45] <ab5tract> though it is too clever for limitations and will not be bound

[05:45] <TimToady> std: sub infix:<***> {...}; my $xxx = [***] 1,2,3;

[05:45] <p6eval> std 25697: OUTPUT«ok 00:03 38m␤»

[05:45] <wayland76> Whereas [*] 1, 2, 3;      # 1 * 2 * 3 = 6

[05:46] <TimToady> any user-defined infix works too, you see

[05:46] <wayland76> [] is a meta-operator, in this case :)

[05:46] <ab5tract> TimToady: How do metaoperators relate to the concept of operator 'overloading' in something like Scala

[05:46] <TimToady> I don't know how Scala does overloading

[05:47] <TimToady> but all our operators are multi-dispatched on the types of both arguments

[05:47] <ab5tract> wayland76: Ah yes in that instance I see it intuitively!

[05:47] <ab5tract> TimToady: Holy Shit.

[05:47] <TimToady> when you say $a * $b, you're really calling infix:<*>($a,$b)

[05:47] <TimToady> and all normal sub calls dispatch on their argument types

[05:47] <ab5tract> Circle complete.

[05:48] <TimToady> you want a DSL, it's about three or four declarations away

[05:49] <wayland76> ( I only discovered recently DSL = Domain Specific Language)

[05:49] <TimToady> all these TLAs get heavily overloaded

[05:49] <TimToady> I was in an RPG when I got hit by an RPG programmed in RPG

[05:50] <ab5tract> std: sub infix: <x> {+}; print ([x] "I think I", "get it!";

[05:50] <p6eval> std 25697: OUTPUT«############# PARSE FAILED #############␤Malformed routine definition at /tmp/cMAvy83y15 line 1:␤------> [32msub infix:[31m <x> {+}; print ([x] "I think I", "get i[0m␤    expecting signature␤FAILED 00:02 34m␤»

[05:50] <wayland76> Well, Google wouldn't help me with DSL :)

[05:50] <ab5tract> wayland76: hehe

[05:50] <TimToady> we don't just drop args like Haskell does though

[05:50] <ab5tract> It seems to have risen into popularity with direct proportion to Rails

[05:50] <TimToady> that would foul up the parser's expectations of term vs infix

[05:50] <ab5tract> and my money is on it dying at relatively the same rate.

[05:51] <ab5tract> Sort of like referring to MMD as a 'Functor'

[05:51] <ab5tract> s/MMD/an object with MMD/

[05:51] <TimToady> std: sub infix:<x> ($a,$b) { $a + $b }; say [x] "I think I ", "get it!";

[05:51] <p6eval> std 25697: OUTPUT«ok 00:04 40m␤»

[05:51] <ab5tract> ahhh

[05:51] <ab5tract> dooooo

[05:51] *** _jaldhar joined
[05:52] <ab5tract> I see. And std is binary, then?

[05:52] <wayland76> "std" is our perl6 parser

[05:52] <TimToady> std runs the STD parser, which is written in Perl 6

[05:52] <wayland76> It's the most complete Perl6 parser known to man

[05:53] <wayland76> but it doesn't run the code afterwards

[05:53] <ab5tract> Gotcha. So of course it is pass/fail

[05:53] <TimToady> (though you're really running bits and pieces perl 5 underneath)

[05:53] <wayland76> The intent is that Rakudo will eventually adopt STD

[05:53] <TimToady> you can get an AST out of it, but that's too big for IRC

[05:53] <wayland76> And someone used it for a syntax highlighter :)

[05:54] <ab5tract> TimToady: You know I spent a significant amount of time trying to do longform transmissions in IRC (in Ruby) ... and I think the protocol is just too weak for it

[05:54] <TimToady> longform as in 1080? :)

[05:55] <ab5tract> It makes more sense in Jabber.

[05:55] <ab5tract> Yup, worrying over endianness and referring to RFCs stabilized ~ '96

[05:56] <ab5tract> getting a simple PRIVMSG ctcp request properly formatted

[05:57] *** nihiliad left
[05:57] <ab5tract> It required some digging :)

[05:58] <pugs_svn> r25698 | wayland++ | -  Moved "defined" and "undefined" from Scalar.pod to Any.pod, as per signature

[05:58] <pugs_svn> r25698 | wayland++ | -  Defined the Pattern role for Any

[05:59] *** jaldhar_ joined
[06:00] <ab5tract> TimToady: Actually I was trying to implement an IRC interface to the ruby util 'cheat'. Pretty cool little tool that serves as a surrogate '-h' by giving generic solutions to specific examples. Community generated, so kind of a CLI wiki. Recipes have been known to be shared.

[06:01] <ab5tract> At the same time as implementing an IRC interface to something like http://pastie.org/

[06:02] <ab5tract> s/specific/specific usage/

[06:04] *** jaldhar left
[06:12] *** _jaldhar left
[06:12] *** masak joined
[06:13] <masak> good morning.

[06:15] <ab5tract> masak: I was just complimenting #perl6 and TimToady in particular

[06:15] * masak backlogs

[06:16] <pugs_svn> r25699 | wayland++ | Changes to special variables as per "$?OS changes" discussion on mailing list.  Haven't 

[06:16] <pugs_svn> r25699 | wayland++ | worried about compatibility for now, though.  

[06:16] <wayland76> masak: 'morning :)

[06:17] <wayland76> (when it says "haven't worried about compatibility", I mean the distro compatibility stuff on the mailing list)

[06:18] <ab5tract> And complaining about IRC / the integration in Ruby

[06:21] *** [particle] left
[06:21] *** [particle] joined
[06:23] *** railmeat joined
[06:29] *** szabgab joined
[06:36] *** mberends joined
[06:43] *** justatheory left
[06:49] *** justatheory joined
[06:53] *** justatheory left
[07:01] <diakopter> TimToady: wouldn't \identifier escape (reference) the symbol/identifier/bareword?  as in... if the identifier "foo" is the name of a subroutine "foo", \foo might refer to the sub's declaration, or even continuation. or is there already something to get at a named sub as an object?

[07:01] <diakopter> erm, dereference, I think I meant.

[07:01] <diakopter> ruoso: hi

[07:02] <masak> diakopter: no, 'dereference' is when you turn a reference into the thing it refers to.

[07:07] <diakopter> right, I was viewing the name as the symbol that refers to the object.

[07:07] <diakopter> so, in bare context, escaping the symbol might dereference the symbol.

[07:09] <diakopter> well, I guess you could view that the other way, too.  \foo as a `reference` to the sub foo.

[07:10] <diakopter> \say($here) as a closure on $here in the declaring context of \say($here).  I dunno.

[07:10] <diakopter> there, it's a reference to the invocation.

[07:10] <diakopter> in my imaginary interpretation.

[07:10] <pugs_svn> r25700 | moritz++ | [docs] improve perl6-projects.org style, patch courtesy of samlh++

[07:11] <samlh> moritz: thanks!

[07:11] *** _jaldhar_ joined
[07:12] <diakopter> or would that be \&foo()  (and can one already do that)

[07:12] <masak> diakopter: to me, a closure with an invocation in it is a reference to the invocation. I've never thought of \ as doing something similar.

[07:12] <moritz_> samlh: thank you

[07:13] *** ejs joined
[07:17] *** Psyche^ joined
[07:17] *** Psyche^ is now known as Patterner

[07:22] <masak> 'the enum symbol is "poisoned".' nice metaphor.

[07:25] <masak> hm, is C<$<?>> proper POD?

[07:25] <literal> yeah

[07:26] <masak> ok, good.

[07:26] <literal> same number of embedded angles are allowed as long as they nest properly

[07:26] <masak> ah.

[07:27] <literal> if they don't nest properly, you can use C<< >>, C<<< >>>, or C« »

[07:28] <masak> oh, C« » in old POD even? I didn't know that.

[07:28] <literal> oh, not old Pod

[07:28] <literal> thought you meant Perl 6 Pod

[07:28] <masak> which one is used for the synopses?

[07:28] <literal> old, except for S26

[07:29] *** jaldhar_ left
[07:29] * masak thought so

[07:30] <masak> ab5tract: do you have an URL to this Ruby 'cheat' util?

[07:36] *** railmeat left
[07:38] <ab5tract> masak: http://cheat.errtheblog.com/s/git

[07:38] <masak> ab5tract: thank you.

[07:39] <ab5tract> Chris from github built cheat a while back. It runs on Sinatra, actually.

[07:40] <Tene_> that talks about git, not about any tool called 'cheat'

[07:40] <ab5tract> Tene_: cheat.errtheblog.com is the cheat source

[07:41] <ab5tract> Tene_:  http://rubyforge.org/projects/cheat/

[07:41] <ab5tract> for the project description

[07:41] <masak> ah, that's better.

[07:41] *** moritz_ changes topic to: http://perl6-projects.org/ | nopaste: http://sial.org/pbot/perl6 | evalbot: 'perl6: say 3;' | irclog: http://irc.pugscode.org/ | ~300 days 'til Xmas

[07:41] <Tene_> so it's man pages fetched from a wiki

[07:41] <Tene_> I don't understand the name.

[07:42] <masak> 'cheat sheets', I guess.

[07:42] <ab5tract> cheat as in a synonym for 'supply'

[07:42] <Tene_> reading the documentation is how you're supposed to do things... it's hardly cheating.

[07:42] <masak> say what? :)

[07:42] <ab5tract> hack is synonym for 'cheat'

[07:42] <Tene_> I've never seen either of those uses.

[07:43] <ab5tract> Tene_: expanding the documentation is how people like me contribute to things

[07:43] <ab5tract> along with test cases for Cardinal, which I keep putting off but get pissed about not accomplishing.

[07:43] <Tene_> ab5tract: but what's cheating about that?

[07:44] <Tene_> That's good.

[07:45] <ab5tract> Tene_: 'cheat' doesn't mean cheat in an Existential sense

[07:45] <ab5tract> it means 'bypass'

[07:46] <ab5tract> '-h' == "switches"; #=> true

[07:46] <masak> .oO( note to self: never choose a project name with possibly negative connotations. )

[07:46] <ab5tract> hehe

[07:47] <Tene_> heh

[07:47] <Tene_> I'll just take your word for it

[07:47] <Tene_> :)

[07:48] <masak> general question: proto is already awesome at installing things, but I feel a final step is missing after the installation. what should it print to the user so that she can start using the just installed program?

[07:48] <ab5tract> so, "cmd('wget -h');" is categorically different than "cmd('man wget');" or "cmd('cheat wget');"

[07:48] <moritz_> masak: "installed $project successfully"

[07:49] <masak> moritz_: I can do that.

[07:49] <masak> but that's not what I'm after.

[07:49] <ab5tract> you use each to approach your subject with varying angles. 

[07:49] <ab5tract> The kitchiness of 'cheat' as a CLI util is a bit laughable, I agree.

[07:49] <masak> it already says "Downloading $project...downloaded", "Building $project...built"

[07:50] <ab5tract> 'cht' would be much more appropriate ;)

[07:51] *** DemoFreak joined
[07:52] <pugs_svn> r25701 | moritz++ | [docs] a favicon for perl6-projects.org

[07:55] <ab5tract> masak: What was added to what shell var?

[07:55] <masak> ab5tract: I'm sorry, you've lost me completely. which shell var?

[07:57] <ab5tract> masak: print $PATH as grok'd through a script that elaborates a list full of excutables in $PATH that were created today|whenever

[07:58] <masak> ab5tract: please be patient with me, it's apparently very early here still. you're talking about a script somewhere which prints $PATH?

[07:58] <masak> and this script was pasted recently, here at #perl6?

[07:58] <masak> do you have a link to the script, or a link to the logs when this was mentioned?

[07:58] <ab5tract> compare that to a list of bin/ scripts in the just-installed-archive, which you present to the user: "Do you see: cheat? [y/n]"

[07:59] <ab5tract> masak: I'm sorry this would have been better presented in  privmsg, apologies

[07:59] <masak> ab5tract: I simply have no idea what you're talking about, that's all.

[07:59] <ab5tract> general question: proto is already awesome at installing things, but I feel a final step is missing after the installation. what should it print to the user so that she can start using the just installed program?

[07:59] <masak> it seems to make sense, but not with the little context I have.

[07:59] <masak> ah, yes.

[08:00] <masak> that's better.

[08:00] <masak> thank you.

[08:00] <ab5tract> :)

[08:00] <masak> now, how is what you've already said an answer to that?

[08:00] <masak> we  don't do global installs yet, just build things in their dirs.

[08:00] <ab5tract> grok $PATH through my $comb # or some sh*t ;)

[08:01] <masak> what I'd like is some small friendly instruction on how to get the Perl 6 program running.

[08:01] <masak> but I'm not sure how to make that general, so that projects don't have to jump through hoops to have that instruction shown upon installation.

[08:01] *** NoirSoldats joined
[08:01] <masak> perhaps some secret handshake in the README of the project?

[08:02] <moritz_> or even a README.afterinstall if such a file exists

[08:02] <masak> moritz_: good idea.

[08:02] <masak> .afterbuild perhaps, though.

[08:02] <masak> I think I'll do that and only that so far.

[08:04] *** s1n left
[08:04] *** bacek_ left
[08:06] *** s1n joined
[08:09] <pugs_svn> r25702 | moritz++ | [docs] section "Miscellanea" for irc logs and mailing lists

[08:09] * mberends likes to keep the filename count down, fwiw, masak

[08:10] <masak> mberends: indeed.

[08:10] <masak> mberends: so maybe detect a certain heading in the README instead?

[08:10] <moritz_> better add an option for a file name than imposing a README file format on the projects

[08:10] <mberends> tail README

[08:10] <masak> mberends: no, I don't like that.

[08:11] <masak> people should have whatever they want at the end of a README.

[08:11] <masak> it's too arbitrary.

[08:12] <masak> it has to be something more subtle, something like looking for '=== Once you've built'

[08:12] <moritz_> that won't work if they have POD in their README

[08:12] <moritz_> afk &

[08:12] <mberends> inside the README ?

[08:13] *** Maghnus_ joined
[08:13] <masak> true, and README files can be in Markdown format too, IIRC.

[08:13] * mberends writes POD inside READMEs anyway. it just works.

[08:14] <masak> mberends: I'm going to do the rw review of the 'proto' script now.

[08:14] <masak> I'm working in a branch, as usual.

[08:14] *** ejs left
[08:14] <masak> (git rebase)++

[08:17] <mberends> that cheat concept is great. I'm thinking about re-doing it for POD and November, and choosing a more suitable name

[08:18] <masak> that would be awesome.

[08:18] <mberends> link in u4x maybe as well

[08:19] <masak> u4x will likely not be user-driven, though.

[08:19] <mberends> fair enough

[08:19] <masak> its contents will be curated through a very strict process that only I know the extent of so far. :)

[08:20] <mberends> don't start spouting like Ted Nelson

[08:20] <masak> I think it'll have automatic tests checking that all words used in the explanations are in some English wordlist, for example.

[08:20] <mberends> a masak-bot

[08:21] <masak> mberends: I'll try to be down-to-earth, yes.

[08:21] <masak> I'll be committing a P2T1A file to u4x/ soon, with very short-term plans for a prototype.

[08:28] *** Maghnus left
[08:38] <masak> the + twigil is buried, yes?

[08:39] <moritz_> yes, think so

[08:41] <Matt-W> Morning

[08:41] <masak> Matt-W: good morning, sir.

[08:42] *** Maghnus_ left
[08:43] <Matt-W> masak: my grammar actions didn't work last night :(

[08:44] <masak> Matt-W: because of bugs in Rakudo, or in you? :)

[08:45] <Matt-W> I don't know

[08:45] <Matt-W> the methods just didn't seem to trigger

[08:45] <Matt-W> and I was too tired to chase it

[08:46] <Matt-W> not sure if I even managed to associate the actions class properly

[08:46] <Matt-W> but I did find a bug :)

[08:47] <masak> yah, saw that :)

[08:47] <masak> Matt-W++

[08:47] <Matt-W> not putting up with null PMC access anymore!

[08:47] <masak> gotta catch'em all.

[08:48] <Matt-W> http://blogs.gnome.org/jjongsma/2009/03/05/git-sucks/ hahahahahaha

[08:49] <masak> the example is actually a subtle example of how git rocks. :)

[08:49] <Matt-W> yes

[08:49] <Matt-W> it's clearly sarcastic

[08:49] <Matt-W> in context of all the git-bashing on planet gnome in the last few weeks, it's rather amusing to me :)

[08:50] *** ab5tract left
[08:51] <masak> mberends: by the way, have I or someone else told you about rebase, also known as "the best thing since Michael Dorn"?

[08:52] * mberends will find an excuse to give rebase a whirl

[08:53] *** dduncan left
[08:53] *** sri_kraih joined
[08:54] <masak> mberends: the short story: I'm in a branch, developing, but someone committed to master. oh noes! but fear not: 'git rebase' rewrites the branch history to make my commits come after those in master. it "re-bases", i.e. makes it seem that the branch was branched after the new commits in master. this makes merging later much, much easier.

[08:56] <mberends> that probably looks good on the tree at github as well

[08:56] <Matt-W> wow

[08:56] <Matt-W> that is exactly what we need at my work

[08:58] <moritz_> if you want that tree locally, start gitk

[08:58] <masak> mberends: but don't do it after you pushed to upstream.

[08:58] <mberends> is the effect on the merge algorithms to give priority to recent master updates?

[08:59] <masak> mberends: no.

[08:59] <masak> if there's a collision, the merge fails.

[09:01] <moritz_> and you have to fix that interactively

[09:02] <moritz_> luckily if the projects are a bit larger there aren't many conflicts, usually

[09:02] <Matt-W> it's handy if you're branched off something where people are generally working in other areas

[09:02] <masak> rebase does help alleviate the merge pains. they are like small merges, and in the branch instead of in master.

[09:03] <Matt-W> masak: btw, my non-working code is in form/master if you're bored. t/02-parseactions.t tries to do the necessary stuff.

[09:03] * Matt-W sends virtual chocolate

[09:03] *** [particle] left
[09:03] <masak> I'm quite busy today, but I'm also curious. might look at it.

[09:04] *** [particle] joined
[09:05] <Matt-W> There's no rush :)

[09:06] *** icwiener joined
[09:07] *** NoirSoldats left
[09:09] *** NoirSoldats joined
[09:09] <pugs_svn> r25703 | masak++ | [u4x/TODO] corrected and updated stuff

[09:09] <pugs_svn> r25703 | masak++ | 

[09:09] <pugs_svn> r25703 | masak++ | * Removed '+' twigil

[09:09] <pugs_svn> r25703 | masak++ | * Typo: s/0c/0x/

[09:09] <pugs_svn> r25703 | masak++ | * Removed some TimToady-deprecated grammar/regex builtin rules

[09:09] <pugs_svn> r25703 | masak++ | * Added idea about a fantastic OO guide

[09:09] <pugs_svn> r25704 | masak++ | [u4x/P2T1A] added short-term plan about prototype

[09:19] *** rkendall joined
[09:35] *** bacek joined
[09:53] *** rkendall left
[10:00] *** alc left
[10:14] *** Ehtyar left
[10:18] <masak> http://boasas.com/?c=1066 # sometimes Perl 6 feels like this

[10:19] <literal> haha

[10:21] <moritz_> :-)

[10:29] <oskie> haha.. those comics are great.. http://boasas.com/?c=1068

[10:29] <Matt-W> masak: perfect!

[10:30] *** ejs joined
[10:32] *** NoirSoldats_ joined
[10:34] *** ilogger2_ joined
[10:36] *** TimToady_ joined
[10:36] *** rhr left
[10:36] *** rhr joined
[10:36] *** cls_bsd joined
[10:40] *** ejs1 joined
[10:45] *** rhr left
[10:45] *** cls_bsd left
[10:45] *** cls_bsd joined
[10:54] *** rhr joined
[11:22] *** ejs2 joined
[11:33] *** ejs1 left
[11:37] *** baest joined
[11:58] *** meppl joined
[12:00] *** M_o_C joined
[12:06] <pugs_svn> r25705 | masak++ | [perl6-projects.org] touched up the style a bit

[12:07] <masak> hopefully for the better.

[12:07] <masak> if nothing else, it aligns better with my taste. :)

[12:08] * moritz_ will take a look when the page refreshes in two minutes

[12:11] <masak> there you go.

[12:14] <moritz_> IMHO that's not enough colour

[12:14] <pugs_svn> r25706 | masak++ | [u4x/P2T1A] added missing words to rationale

[12:14] <moritz_> granted, before it was too much

[12:15] <moritz_> what do you think of making the whole border a bit thicker, and in colour?

[12:15] <masak> moritz_: I'll let you decide; but IMHO if the colour dosn't actually carry any information in itself, it doesn't need to be very much at all.

[12:15] <masak> moritz_: I don't think that would add anything.

[12:15] <masak> thin borders are nice.

[12:17] <moritz_> I'll experiment a bit with it tonight

[12:19] <pugs_svn> r25707 | masak++ | [perl6-projects.org] de-capitalized a few nouns

[12:19] <moritz_> I see have gained a contributor :-)

[12:20] <moritz_> masak: if you want, feel free to introduce a box with Projects that use Perl 6

[12:20] <moritz_> like november, Web.pm, proto, druid ...

[12:20] <masak> moritz_: I'll think about it. as you say, it's a bit of work to keep updated.

[12:20] <masak> moritz_: right now, we have such a list already in proto.

[12:21] <moritz_> then maybe add proto to the misc section?

[12:21] <masak> aye, I'll do that.

[12:21] <masak> moritz_++

[12:21] <moritz_> btw I try to spell Perl 6 on that page with a non-breaking space, but it's no disaster if you write it with ordinary space

[12:22] <masak> noted.

[12:23] *** mberends joined
[12:25] <pugs_svn> r25708 | masak++ | [perl6-projects.org] added 'proto' in misc

[12:29] *** FurnaceBoy joined
[12:37] *** ejs1 joined
[12:38] *** oskie joined
[12:41] *** oskie left
[12:41] *** oskie joined
[12:45] *** ejs2 left
[12:52] *** ruoso joined
[13:02] <masak> the 'installer' script in proto gets a bit of extra beauty because of all its imperfection comments. 7 TODO, 2 XXX, and 6 RAKUDO comments. it gives it an air of work-in-progress and we-left-a-comment-because-we-care.

[13:02] <masak> http://github.com/masak/proto/blob/d0f235164772c8b8e372246b71397bcda16c19ed/installer

[13:09] *** kane_ joined
[13:13] <masak> might be the wrong forum for this question, but are global comments in a YAML file best put directly above or directly below the '---' line?

[13:13] <mberends> masak: installer:55 s/sore some value/for some value/

[13:14] <masak> mberends: okie. will fix.

[13:14] <mberends> above, to be consistent with item comments

[13:15] <masak> agree, but is it legal?

[13:15] *** kane_ left
[13:15] <masak> did the YAML parser grok it?

[13:15] *** kane_ joined
[13:15] <mberends> it probably drops the comment lines

[13:15] * masak tests

[13:17] <masak> seems to work, yes.

[13:17] *** kane_ left
[13:17] *** kane_ joined
[13:18] <masak> ok, I've done the review.

[13:18] <masak> next up, I plan to add verbose comments.

[13:19] *** kane_ left
[13:20] *** kane_ joined
[13:22] *** FurnaceBoy left
[13:31] *** kane_ left
[13:32] <masak> mberends: oh, and an interested question: you wrote in a comment that you thought there ought to be a law against hash-ending commas. why?

[13:35] <masak> also, I'm half-thinking of making $commentinfo into a file-level variable. that would mean that comments that were changed during manual edit of config.proto will revert to their original state on the next re-save. this might be considered either an advantage or a disadvantage.

[13:36] <literal> hash-ending commast as in { foo => bar, baz => quux, } ?

[13:37] <masak> aye.

[13:37] <masak> I don't see anything wrong with them.

[13:37] <masak> especially not when each kv pair is on a line of its own.

[13:37] <literal> yeah

[13:37] <masak> and there's the change of reordering/addition.

[13:37] <masak> that's why I was curious about the comment.

[13:38] <masak> s/change/chance/

[13:39] <mberends> it goes against my intuitive feel for programming languages generally. it would probably fail in C, java etc and could become a bad habit.

[13:39] *** kane_ joined
[13:39] <literal> that's just a shortcoming of those languages :)

[13:40] <mberends> perl6 rulez the world :)

[13:40] <literal> and Perl 5 has always allowed this...

[13:40] <masak> mberends: I think you'll find that those final commas are allowed in surprisingly many modern languages.

[13:40] <masak> they're good for the case when a list/hash is computer-generated.

[13:40] <masak> then you don't have to special-case the last item.

[13:41] <mberends> understood, but this old dog won't learn, or, like, that trick,.

[13:42] <literal> it would be equally silly to disallow a final semicolon in Perl 5 blocks, since it is a statement separator (not terminator), after all

[13:42] <masak> mberends: I tend to have little sympathy for people who refuse to adapt. :P

[13:43] <masak> Perl 6 is all about breaking old habits, and this feature isn't even new.

[13:43] <mberends> tmtowtdi, thank goodness

[13:44] <masak> ...says the person who wished for a law against it...

[13:44] <masak> ;)

[13:44] <mberends> ok, i withdraw the legislation proposal

[13:44] <mberends> it was a bit tongue in cheek

[13:44] <masak> of course. :)

[13:47] <mberends> otherwise i would have yanked that poor comma with a pair of pliers :)

[13:50] * mberends will try to collect his repaired laptop, but has rather enjoyed the eee and solid state drives

[13:52] *** Tene joined
[13:52] <masak> mberends: so you would recommend an eee?

[13:54] <mberends> only the one with the largest LCD. i chose the model 1000, Linux based. Xandros is a pain but the only one to do Skype properly. eeebuntu and even Debian Lenny manage almost all the peripherals.

[13:55] * masak likes the sound of that

[13:55] <mberends> it's cool to have a 4GB or 8GB Micro CD card as a swappable system drive :)

[13:55] <masak> I need to find my way back to the Linux world.

[13:55] <mberends> *SD

[13:55] <masak> aye, I can imagine. :)

[13:56] <mberends> FreeBSD is almost running. (the computer's name is meee)

[13:57] <Matt-W> :)

[13:57] * Matt-W names his computers names beginning with A

[13:57] * mberends used to name them after his friends, but ran out of names ;)

[13:58] <masak> mberends: you have a computer named after me? :)

[13:58] <Matt-W> I think my friends would leave if I named computers after them

[13:59] <mberends> thanks, now I have one more name :)

[13:59] <masak> nice save. :)

[13:59] * Matt-W applauds

[14:02] *** zamolxes joined
[14:02] * mberends must leave to collect the repaired laptop, which is/was named dash

[14:03] <Matt-W> hope it's good and healthy now

[14:04] <mberends> yes, it will need a new hdd. maybe I'll get an OCZ SSD

[14:04] <pmichaud> looooong scrollback this morning.

[14:04] <Matt-W> wish I could afford one of those :(

[14:05] <mberends> you can if you break your old drive. you then only have to justify the price difference

[14:05] <Matt-W> which is substantial

[14:05] <Matt-W> and I'm broke

[14:05] <Matt-W> ah well

[14:05] <Matt-W> I had the winter gas and electricity bills

[14:06] <Matt-W> winter + expensive fuel == bad for the bank balance

[14:06] <mberends> ouch, it's been cold this february

[14:06] <Matt-W> yeah

[14:07] <Matt-W> wish my bills were monthly instead of quarterly

[14:07] <mberends> bbl    o/

[14:07] <Matt-W> ah well

[14:07] *** mberends left
[14:14] *** ejs1 left
[14:19] * ruoso trying to grok last changes in Capture...

[14:22] <ruoso> first of all, it will basically change a *lot* of code in SMOP

[14:22] <ruoso> because Capture is perhaps the most important type....

[14:23] <ruoso> so in one change, the "invocant" slot of the capture no longer exists...

[14:24] <ruoso> at least we no longer turn any first positional argument into invocant...

[14:24] <ruoso> only the opposite

[14:24] <ruoso> any invocant is potentially a first positional argument

[14:27] *** skids joined
[14:28] <ruoso> so we need two different methods in capture...

[14:28] <ruoso> one to "get positional arguments without the invocant"

[14:28] *** Ariens_Hyperion joined
[14:28] <ruoso> and other to "get positional arguments with the optional invocant"

[14:31] <ruoso> basically capture would have a "talk to me as if I was a method" and "talk to me as if I was a sub" APIs

[14:33] <ruoso> and in the end "foo($a: $b, $c)" is the same as "foo $a: $b, $c", which is the same as $a.foo($b,$c)

[14:34] <Matt-W> That seems to be what the changes imply

[14:36] <Matt-W> if there is an invocant, it's the first positional argument with some sort of internal mark that it can be an invocant, but the first positional argument could just be an argument and not an invocant at all.

[14:37] <ruoso> what I don't get is that it still requires the signature transformation, since an un-marked first positional argument never becomes the invocant (afaics)

[14:38] <ruoso> so "method foo($a: $b, $c) is export" still needs the modified signature in its sub version

[14:38] <ruoso> TimToady_,  is that it?

[14:52] *** abra joined
[15:02] <AndyAway> Morning all!

[15:02] *** AndyAway is now known as alester

[15:03] <moritz_> god dag

[15:05] <diakopter> ruoso: well, at the implementation level, you needn't necessarily keep the first slot full for a non-method... just hide it if it's marked as such

[15:05] <masak> guten tag.

[15:06] <ruoso> diakopter, yeah... I think I'll keep the slot there

[15:06] <diakopter> I was going to say... talk about major rework

[15:07] <ruoso> but I'm still not very happy with the two different APIs

[15:07] <diakopter> that's what CIL does, btw... keeps the first slot empty if it's a non-method and marks it as "static"

[15:07] <ruoso> CIL?

[15:07] <diakopter> common intermediate language?

[15:07] <diakopter> MSIL.. .net

[15:07] <ruoso> ah

[15:07] <ruoso> ok

[15:07] <diakopter> CLR/mono

[15:08] <ruoso> my experience with mono/.net is simply as an application user

[15:08] <ruoso> I just note when mono packages get installed ;)

[15:08] <ruoso> but I still think I'm missing somethin

[15:09] <ruoso> since all this discussion was about removing the need for the transformed signatures in "is export"

[15:09] <ruoso> maybe TimToady_ just agreed with me

[15:09] * ruoso not very used to it ;)

[15:09] <diakopter> on an email list?

[15:10] <ruoso> diakopter, no, here on irc

[15:10] <diakopter> he's idle...

[15:11] <diakopter> Hi TimToady who might be watching the irclogs on http

[15:12] <ruoso> also, if a capture in item context returns itself.... does that mean that "sub foo { return 1} my $a = foo()" will put a capture in $a? 

[15:12] * diakopter goes back to optimizing his runtimes for inefficiency ;)

[15:13] <diakopter> semicolon after }  ?

[15:14] <diakopter> std: sub foo { return 1} my $a = foo()

[15:14] <p6eval> std 25708: OUTPUT«############# PARSE FAILED #############␤Syntax error (two terms in a row?) at /tmp/HYDnc8Wn5C line 1:␤------> [32msub foo { return 1} [31mmy $a = foo()[0m␤    expecting any of:␤        infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤ 

[15:14] <p6eval> ..terminator␤FAILED 0...

[15:14] * diakopter reads the diff

[15:14] <ruoso> diakopter, yes... I forgot it...

[15:20] <diakopter> for anyone who's listening... I solidified IronPerl's first milestone... to be able to treat the AST from viv/STD as an ultra-sugared C#3 AST.  Completely disregarding Perl 6-specific types for now, as well as the language features that go along with those... the first things I want to get (rudimentarily) working are the features that can translate directly: the classes/types/object system, structs, methods (and other routines), the CIL primitives tempor

[15:21] <diakopter> Captures and patterns after that... invocations and multis and signatures can wait; type-checking isn't absolutely necessary after all :P

[15:22] <moritz_> you need type checking for multi dispatch, to some degree

[15:23] <diakopter> oh; yes, I was including type-checking there in with "invocations, multis, signatures".

[15:24] <Matt-W> diakopter: great! Glad to hear there's progress

[15:26] <diakopter> C#'s lazy or eager evaluation (libraries), iterators/closures, runtime type/method generation (libraries), and implicit casting (libraries) should be enough to last a while...  at least once the various Contexts are more fully analyzed and classified, I'll be able to understand more fully how Perl 6's dynamism works

[15:29] <diakopter> Matt-W: well, progress on a theoretical axis.  I've collected an absolute glut of F/OSS C#/VB/F# libraries that would be quite helpful if arranged/glued in the proper ways

[15:29] <Matt-W> diakopter: excellent. What looms in the back of my mind now are the words 'grammar engine'

[15:30] <diakopter> is there a canonical list of the Contexts in the Synopses somewhere?

[15:30] <moritz_> there's an overview in S02, but it's not complete

[15:30] <diakopter> the grammar engine actually can wait... STD can be used for that indirectly for a while.... don't you think?

[15:31] <diakopter> ... to an extent.

[15:31] <diakopter> moritz_: here's a mean question: what's missing from the list in S02? :P

[15:33] <moritz_> There are also various container contexts that require particular kinds of containers (such as slice and hash context; see S03 for details).

[15:33] <moritz_> there you go, diakopter :-)

[15:33] <diakopter> I read that...

[15:34] <diakopter> are the container contexts a subcategory of item (scalar) context?

[15:34] <diakopter> (or list)?

[15:34] *** nihiliad joined
[15:35] <moritz_> afaict there are container contexts for items and lists

[15:35] <moritz_> for example 'is rw' provides an rw container context

[15:35] <moritz_> or am I totally off here?

[15:36] <moritz_> then there are contexts that allow autovivification

[15:38] <diakopter> I'll have to study how much of the context information is provided by STD's AST, and how much will need to be further inferred/deduced.

[15:38] *** Ariens_Hyperion left
[15:38] *** eric257 joined
[15:40] <diakopter> [some of?] the S03-operators tests are included in S02.html

[15:40] <diakopter> (under Context)

[15:41] <diakopter> oh.. I guess that's not a problem

[15:41] <diakopter> lots of tests in S02.html are from other Sxx

[15:42] *** zamolxes left
[15:42] *** justatheory joined
[15:42] <moritz_> the synpsis have some measure of overlap... :-)

[15:56] <ruoso> ok... just sent a reply to the changes in the capture, asking for more clarifications...

[16:02] *** TimToady_ is now known as TimToady

[16:05] <pmichaud> TimToady: (re <?>) -- after thinking about it a bit more last night, using the '?' key (or any key) for holding the result object doesn't feel quite right to me.  (more)

[16:05] * eric257 curses as php

[16:06] <pmichaud> TimToady: In general, all of the other keys tend to produce either a Match object or an Array of Match objects; so the '?' key ends up being an exception to that rule.  In that sense, "result object" feels more like a Match object attribute.

[16:06] <pmichaud> TimToady: all that said, using a special key like '' or '?' sounds _exactly_ like something I would choose to do, so I'm fine with leaving it that way if you are.  :-)

[16:07] <pmichaud> TimToady: Just wanted to note the "tinge" I had in thinking about it.

[16:07] <pmichaud> (end)

[16:07] *** abra left
[16:07] <PerlJam> What's a "result object"?

[16:07] <pmichaud> every Match has a "result object" that can be set using make()

[16:08] <pmichaud> before yesterday's changes to the spec, the result object was what was used to evaluate the Match object in string and numeric contexts.

[16:08] <pmichaud> PCT (and all of the languages based on it) use the result object for building up the AST inside of the parse tree.

[16:09] <pugs_svn> r25709 | masak++ | [u4x/TODO] added 'result object'

[16:12] <cognominal> This may be of interest to TimToady :  http://www.cse.chalmers.se/~bernardy/FunctionalIncrementalParsing.pdf

[16:13] <cognominal> is there a way to leave a message to someone using purl?

[16:13] <moritz_> cognominal: here you use lambdabot

[16:13] <moritz_> cognominal: with @tell nick message

[16:14] <cognominal> @tell TimToady  this may be of interest to you  http://www.cse.chalmers.se/~bernardy/FunctionalIncrementalParsing.pdf

[16:14] <lambdabot> Consider it noted.

[16:14] <cognominal> I forgot that lambdabot was here

[16:28] *** M_o_C left
[16:31] <[particle]1> and purl isn't here :)

[16:32] <masak> thankfully.

[16:32] *** Tene_ joined
[16:40] <masak> Tene_: good day.

[16:43] *** Tene left
[17:05] *** Ariens_Hyperion joined
[17:05] <masak> Matt-W: your t/02-parseactions.t passes here.

[17:06] <masak> Matt-W: oh, and you're currently misspelling Damian's name in the project description of Form.

[17:11] *** clintongormley joined
[17:15] *** mikehh joined
[17:19] *** gravity joined
[17:27] *** mberends_ joined
[17:28] <Tene_> masak: yes, good day

[17:29] <dalek> rakudo: fe2bc86 | pmichaud++ | docs/spectest-progress.csv:

[17:29] <dalek> rakudo: spectest-progress.csv update: 317 files, 7121 passing, 0 failing

[17:29] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/fe2bc8646f1fd0f771df8617724a97f110a3b633

[17:29] <masak> Tene_: hope you are feeling better.

[17:29] <Tene_> masak: mostly.  still coughing very badly, though.

[17:29] <Tene_> :(

[17:29] <masak> sad to hear that.

[17:30] <masak> Tene_: I haven't had much time to plan Web.pm today, but there's much to digest from the past few days.

[17:30] <masak> I'm really happy about how welcoming different web frameworks teams are when you approach them with questions.

[17:30] <Tene_> Let me know when you have something for me to look at.  Or just email me.

[17:30] <masak> Tene_: well, there's already a PLAN file in the Web.pm repo.

[17:31] <masak> I'm sort of thinking out lout in that one.

[17:31] <Tene_> Where is the web.pm repo?

[17:31] <masak> :)

[17:31] <masak> hold on.

[17:31] <masak> http://github.com/masak/web/

[17:31] <Tene_> Thanks.

[17:31] <masak> np.

[17:32] <masak> I'm just trying to get everything into PLAN right now, from large-scale ideas down to client code examples.

[17:33] <masak> hopefully, a plan of action will emerge from that.

[17:33] <masak> I hope to build my work around fairly small milestones consisting of cool examples of web things you can do.

[17:34] <masak> that might not always be possible, of course. but whenever it is, I hope to be able to do it like that.

[17:34] <masak> and blog about it.

[17:34] <Tene_> nice

[17:37] <masak> ihrd said he'll be considering next week his first in the time plan. I haven't decided if I should do the same, or if I should proceed to week #2. might depend on how ready I feel by the end of this week.

[17:38] <masak> oh. seems we're leaving now.

[17:38] <masak> gotta go. :)

[17:38] <Tene_> bye

[17:38] <masak> Tene_: get well soon.

[18:03] <pugs_svn> r25710 | moritz++ | [perl6-projects.org] color tweaks

[18:04] *** clintongormley left
[18:04] *** schmalbe joined
[18:07] *** jeremiah_ joined
[18:08] <jeremiah_> Congrats masak and viklund 

[18:08] <jeremiah_> http://www.athenalab.com/Perl_6_Wiki_Award.htm

[18:15] *** ilogger2 joined
[18:23] <ruoso> :( yes... invocant was dropped from runtime

[18:23] <ruoso> half of SMOP needs to be rewritten

[18:24] <[particle]1> welcome to the pain of writing implementations for an unfinished spec

[18:24] *** Kimtaro_ joined
[18:24] *** Kimtaro_ left
[18:24] <ruoso> [particle]1, didn't rakudo implement anything on invocants?

[18:24] *** smtms joined
[18:25] <diakopter> ruoso: I still don't see why that can't be emulated

[18:25] <ruoso> because a method looks at the first argument independent if it was marked as invocant or not

[18:25] *** Kimtaro_ joined
[18:25] <ruoso> the "invocant" concept now only exists in the compiler

[18:25] <[particle]1> rakudo needs to change for invocants, and both nqp and rakudo need to change for Match.result_object

[18:26] <[particle]1> ...and all languages written using nqp.

[18:26] <diakopter> so alias 'self' to the first argument when it's a sub

[18:26] <ruoso> yes

[18:26] <ruoso> well

[18:26] <diakopter> er, 2nd

[18:26] <ruoso> that isn't really necesary

[18:26] <ruoso> but if you use a method as a sub

[18:27] <ruoso> the first argument will be "self"

[18:27] <ruoso> the "my $self = shift" is implicit

[18:27] <diakopter> right, so always use the sub/method marker

[18:27] <diakopter> to determine whether 'self' is 1st or 2nd arg

[18:28] <ruoso> self is never the 2nd argumetn

[18:28] <diakopter> but it is if you do the emulation we were talking about above (leaving the 1st slot there at some level for subs)

[18:28] <ruoso> the thing is that SMOP did have runtime support for invocants 

[18:29] <ruoso> and invocants no longer exist at runtmie

[18:29] <ruoso> only at compile time

[18:29] <ruoso> the emulation is not really possible

[18:29] <ruoso> because it's on the call side

[18:29] <moritz_> diakopter: no. self is *always* the first argument. It just might be implictly provided

[18:29] <moritz_> unless I really misunderstood your emulation

[18:30] <ruoso> it's always the first argument (in a method), even if no invocant was sent by the callee

[18:30] <ruoso> *caller

[18:30] <ruoso> so...

[18:30] <ruoso> our foo($b,$c) { }; foo($a, $b, $c);

[18:30] <ruoso> sorry

[18:30] <ruoso> our method foo($b,$c) { }; foo($a, $b, $c);

[18:31] <ruoso> $a will be treated as the invocant

[18:31] *** Kimtaro_ left
[18:33] <diakopter> alright, so foo's implied signature has an instance of the class(and on up) that defines foo() as its first param?

[18:33] <ruoso> no

[18:33] <ruoso> foo's signature implies "self", because it's a method

[18:33] <ruoso> since $b and $c are actually the 2nd and 3rd parameters

[18:34] <ruoso> s/since/so/

[18:34] <ruoso> methods always start counting the parameters in 1, not 0

[18:34] <ruoso> because of the implied invocant

[18:34] <ruoso> subs, otoh, start at 0

[18:35] <ruoso> so

[18:35] <ruoso> our sub foo ($b, $c) { }

[18:35] <ruoso> really takes just two arguments

[18:35] <ruoso> our method foo ($b, $c) { }

[18:35] <ruoso> takes three

[18:35] <ruoso> the invocant now only exists at compile time 

[18:35] <ruoso> at runtime, it's plain positional arguments

[18:36] *** Psyche^ joined
[18:37] <ruoso> I think it's quite sad that we loose that semantics

[18:37] <diakopter> oh, but you would be able to distinguish them if the compiler supplied something to the runtime indicating whether it was called with .foo() or foo()

[18:38] <diakopter> but I guess TimToady's email explicitly forbids that

[18:38] *** Psyche^ is now known as Patterner

[18:38] <ruoso> I think TimToady's purpose on that change is precisely to eliminate that difference

[18:42] *** bacek_ joined
[18:43] <ruoso> now I have to start cutting losses in SMOP

[18:43] <diakopter> so what's the semantic difference between declaring a "method" and a "sub" with the same signatures

[18:43] <diakopter> and same exportedness

[18:44] <diakopter> for the dispatcher's purposes

[18:45] *** Kimtaro joined
[18:46] *** Tymir joined
[18:46] <ruoso> none

[18:46] <ruoso> what changes is the dispatcher itself

[18:46] <ruoso> you have the sub dispatcher

[18:46] <ruoso> and the object dispatcher

[18:47] <ruoso> the object dispatcher is actually private to each object

[18:47] <ruoso> the sub dispatch is private to each sub

[18:47] <ruoso> in a way

[18:47] <ruoso> basically

[18:47] <ruoso> foo($a,$b,$c)

[18:47] <ruoso> looks for &foo

[18:47] <ruoso> and calls .postcircumfix:<( )>(\($a, $b, $c))

[18:47] <diakopter> and the various foos' dispatchers make a consensus on which one to call?

[18:48] <ruoso> there's only one &foo visible

[18:48] <ruoso> that masks all the outer ones

[18:48] <ruoso> but it should have copied all the variants from the outer scopes

[18:48] <moritz_> so does this mean that a sub can also be called as method again?

[18:48] <ruoso> not really

[18:48] <ruoso> it means that foo($a: $b, $c) is *not* a sub dispatch

[18:49] <ruoso> which means it will *not* look for &foo

[18:49] <ruoso> it will look for $a

[18:49] <ruoso> and call foo there instead

[18:50] <diakopter> oh, but if you import a sub as a method, you can invoke (even "built-ins"?!) subs like methods, so the "invocant" becomes the first arg.  I like that a lot.  Not sure whether it had that before, though.

[18:51] <ruoso> yes, because the signature is the one doing the binding

[18:51] <ruoso> and you still have the signature from the sub

[18:52] <ruoso> even if it does get registered as a method

[18:52] <diakopter> that gives lots of possibilities for .meth1(meth1_arg2).func1(func1_arg2)

[18:52] <ruoso> it really looks like LISP 

[18:53] <ruoso> or not

[18:53] <ruoso> maybe my brain is melted already

[18:54] <ruoso> in the end, I think that also means we have a change in the meaning of "my" and "our" method

[18:54] <ruoso> so 'my' and 'our' stay with the same meaning as for everything else

[18:54] <ruoso> 'my method foo' creates a public method that is lexically aliased as &foo 

[18:54] <ruoso> 'our method foo' creates a public method that is both aliased as &foo and registered in $?PACKAGE

[18:55] <ruoso> 'method foo' creates a public method that is not aliased anywhere

[18:55] <ruoso> and it seems from yesterday conversation, that you use 'method !foo' to declare it as private

[18:56] <ruoso> while you still can use both 'my method !foo' and 'our method !foo'

[18:57] <ruoso> but I think 'my method !foo' still aliases to &foo

[18:57] * diakopter thinks about ways to further swizzle argument processing order with R.  Some variant of the , operator?  R, R, ?

[18:58] <ruoso> since &!foo looks like the private access to the attribute declared with 'has &!foo'

[18:58] <diakopter> RR, maybe swaps, shifts, pushes?

[19:00] <pugs_svn> r25711 | lwall++ | fix declaration syntax of private methods

[19:02] *** mberends_ joined
[19:07] <ruoso> TimToady, what happens if you have: method foo($b,$c) {}; and someone calls foo(((1,2),3),$b,$c)?

[19:07] <ruoso> captures doesn't flatten lists until you require it

[19:07] <ruoso> does that use the entire ((1,2),3) as invocant?

[19:08] * ruoso hopes so

[19:11] <pugs_svn> r25712 | lwall++ | more method declaration clarification, ruoso++

[19:12] <TimToady> yes, it does

[19:12] <lambdabot> TimToady: You have 1 new message. '/msg lambdabot @messages' to read it.

[19:13] <pugs_svn> r25713 | putter++ | [elf_h] More correct ||,&&,or,and,not.

[19:13] <pugs_svn> r25713 | putter++ | So more .Bool'ing.  5% speed hit on self-compilation (with cached parse).

[19:14] <ruoso> TimToady, ok... now I just have to rewrite half of SMOP

[19:14] <ruoso> ;)

[19:15] <TimToady> sorry, kind of :)

[19:15] <TimToady> wish I was smarter sooner sometimes...

[19:16] <ruoso> I think in mildew the effect can be a bit reduced

[19:16] <ruoso> but in SMOP it basically changes everything

[19:16] <ruoso> since Capture is *the* most important type

[19:16] <TimToady> but in addition to unifying things internally, I also think this will enhance interoperability with both Perl 5 and Python

[19:16] *** moritz_ sets mode: +o TimToady

[19:16] <ruoso> indeed

[19:17] <ruoso> although the dispatching itself was already private to each object or each sub

[19:17] <TimToady> and, in fact, you could just link in a Perl 5 sub as the implementation of a method now

[19:18] <ruoso> 'my $self = shift' is valid Perl 6

[19:18] <ruoso> semantically-speaking

[19:18] <PerlJam> greetings

[19:18] <PerlJam> What world-altering things have happened today?  :)

[19:18] <TimToady> but only if declared as a sub

[19:18] <ruoso> yes...

[19:19] <pugs_svn> r25714 | putter++ | [elf_h] PrimitivesP5.pm: More correct prefix:<!>(Any).

[19:21] <TimToady> I've been increasing the stress levels of both rakudo and smop folks by simplifying Match and Capture

[19:21] <ruoso> TimToady, are you planning to include the "capture in item context" dwimmery in the spec?

[19:22] <TimToady> sure, unless you beat me to finding the right place to put it

[19:22] <ruoso> hmm... I don't think so... ;)

[19:22] <TimToady> probably somewhere near where it already talks about list context, though that's probably misplaced as well...

[19:23] <ruoso> we do need S08, and you already asked me for it... ;)

[19:24] <diakopter> there's some list context in S02 and in S03

[19:31] *** riffraff joined
[19:32] <moritz_> std: class A { has method !foo { ... } };

[19:32] <p6eval> std 25714: OUTPUT«ok 00:02 34m␤»

[19:32] <moritz_> that'll need some updating in the test suite...

[19:34] <ruoso> std: class A { our method !foo {...} } # that's a bit more surprising

[19:34] <p6eval> std 25714: OUTPUT«ok 00:02 34m␤»

[19:36] <TimToady> well, when you think about it, a private method is more or less just a subroutine, since it's non-virtual in any case

[19:36] *** renormalist joined
[19:37] <diakopter> how does one restrict a method's self to only its home [room]class

[19:38] <ruoso> diakopter, what do you mean?

[19:38] <alester> I've added some new fields to your user accounts on rakudo.org.

[19:38] <diakopter> so even if it were exported as a sub, it would still be invoked (as a func call) only when the first arg was that class

[19:39] <alester> Are there other items we ought to track on people?

[19:39] <pugs_svn> r25715 | lwall++ | By principle of least damage, minimalize autopromotion of lists in item context

[19:39] <pugs_svn> r25715 | lwall++ |     to Capture rather than to Array.  (Let binding handle any subsequent

[19:39] <pugs_svn> r25715 | lwall++ |     promotions lazily.)

[19:39] <ruoso> diakopter, there isn't really "Class Methods" in Perl 6, 

[19:39] <PerlJam> alester: IRC nick  :)

[19:39] <alester> oooh, good

[19:40] <alester> done

[19:40] <diakopter> also, pugscode svn username, since those aren't always equivalent?  dunno.

[19:40] <ruoso> TimToady, Capture is immutable

[19:40] <alester> Why is pugscode username userful?

[19:41] <diakopter> ruoso: what do you mean? I wasn't referring to class methods, I didn't think...

[19:41] <ruoso> diakopter, so I didn't get what you meant

[19:41] <TimToady> diakopter: that's what submethods do, basically

[19:41] <moritz_> the svn username is what appears in the commit mesasges

[19:41] <moritz_> don't think it's worth the trouble, though

[19:41] <ruoso> TimToady, if "my $a = (1,2,3)" promotes the list to a capture, that means it will stay immutable

[19:42] <TimToady> indeed, but they can always use [] if they mean it

[19:42] <alester> So far, you can add: Nmae, PAUSE ID, Home page, Twitter page, AIM ID, Jabber ID, IRC nick

[19:42] <alester> And that's just contacty-type stuff.

[19:42] <ruoso> Ok, but beware that will surprise a lot of p5 people

[19:42] <TimToady> and I'm trying to bias things a bit toward immutability by default like a good FP designer, so we can keep control of parallelism

[19:43] <TimToady> a p5 person would expect that to assign the final element

[19:43] <TimToady> aka C comma operator

[19:43] <TimToady> we already broke that about 8 years ago :)

[19:43] <[particle]1> bleh. who designed that.

[19:43] <PerlJam> and be pleasantly surprised when it does not.

[19:44] <diakopter> http://xrl.us/beifzt

[19:44] *** Tymir left
[19:44] * moritz_ notes that we just created the next Perl 6 FAQ

[19:44] <TimToady> "different mistakes this time" :)

[19:44] <ruoso> TimToady, I'm fine with that, but I think it's worth making a note to remind people that capture is immutable at that point

[19:44] <TimToady> and that was already in the Perl 6 FAQ as different from P5

[19:45] <PerlJam> moritz_: there will always be FAQ for newbies, and for people coming from perl 5

[19:45] <moritz_> it would have been nice to get rid of one item entirely...

[19:45] <[particle]1> people coming from ruby will be very confused about @@

[19:45] <moritz_> PerlJam: that's no reason not to try hard to avoid FAQs

[19:45] <ruoso> everyone will be confused by @@

[19:45] <ruoso> we really could use a different sigil instead of a two-char sigil

[19:46] <TimToady> what the ruby folks need explained to them is that the ruby sigils have all turned into twigils

[19:46] <[particle]1> yep, but the spec isn't changing much anymore^W^W^W^W^W^W

[19:47] <moritz_> ah well ;-)

[19:47] <TimToady> believe me, I know some unicode characters that would replace @@ nicely, cause I've looked at them with malice aforethought

[19:47] <[particle]1> designing in anger

[19:47] <TimToady> just haven't seen any Latin-1 ones that I like, and trying to limit standard Perl 6 to Latin-1

[19:48] <ruoso> meh.. Latin-1 is so 20th century ;)

[19:48] <TimToady> but I think the @@ does convey that there are multiple lists

[19:49] <ruoso> TimToady, actually, it might contain hashes as well

[19:49] <TimToady> and it's kinda ugly on purpose

[19:49] <ruoso> it's just unflattened

[19:49] <ruoso> unflattened whatever

[19:49] <PerlJam> TimToady: limiting to latin-1 is just a temporary compromise until the rest of the world catches up, right?

[19:49] <TimToady> PerlJam: I would like to think so, but we're probably talking decades here...

[19:49] <ruoso> in fact... one could really think that @@ is the "Capture" sigil

[19:49] *** slango joined
[19:50] <PerlJam> TimToady: sure.   I'm just thinking about the perl I'll be coding when I'm 80  ;)

[19:51] <PerlJam> ruoso: I don't get that.

[19:51] <ruoso> we've been calling that "slice" context

[19:51] <ruoso> but it doesn't really mean that

[19:52] <ruoso> in fact, naming it "slice" doesn't really make much sense

[19:52] <TimToady> I try not to predict out that far.  Though I do like the one prediction: "I don't know what weapons World War 3 will be fought with, but World War 4 will be fought with sticks and stones."

[19:52] <PerlJam> ruoso: It made sense to me so far :)

[19:52] * [particle]1 thought $<191> (upside down ?) would look nice

[19:53] <PerlJam> ruoso: calling @@ the Capture sigil makes me wonder what happened to the hashy component.

[19:53] <TimToady> it's name that because it's what you want for @foo[ your slice here ]

[19:53] <TimToady> *named

[19:54] <ruoso> but that is just a very small use case for @@a 

[19:54] <TimToady> well, if we did call it the capture sigil, we could use ¢

[19:54] <ruoso> @@a = map { map { map { ... }, * }, *} ,* }, *

[19:54] <ruoso> ^ that's a pretty more important use case

[19:55] <PerlJam> ruoso: but that's still in the realm of "building a slice"

[19:55] <ruoso> PerlJam, a "slice" of what?

[19:55] <ruoso> it's the whole thing!

[19:55] <TimToady> a slice of reality :)

[19:55] <TimToady> a slice of life...

[19:56] *** Ariens_Hyperion joined
[19:56] <PerlJam> I'm okay with a slice of bread being the whole loaf.

[19:56] <diakopter> taste

[19:56] <TimToady> maybe we should go the other way and rename captures to slices

[19:56] <PerlJam> (it's just a much bigger slice than what people are used to)

[19:56] <moritz_> rakudo: for <foo bar baz>.kv -> $index, $item { if $item ~~ /ar/ { say $index; last } };

[19:56] <p6eval> rakudo fe2bc8: OUTPUT«1␤»

[19:57] <PerlJam> TimToady: "slice" still connotes strongly with lists or arrays to me.

[19:57] <PerlJam> TimToady: so, again, I'd wonder what happened to the hashy part.

[19:58] <diakopter> a slice can be the slicing or the sliced portion of the slicee

[19:58] <TimToady> but the point is taken, we may well be able to unify the concepts at some level

[19:59] * [particle]1 wonders how many years ago we reached the "too many levels of abstraction" problem

[19:59] <TimToady> so the texas sigil for ¢ would be @%

[19:59] <TimToady> which is nice, since we just kicked out the $

[19:59] <PerlJam> indeed

[19:59] <PerlJam> it looks odd, but somehow fitting :)

[20:00] <ruoso> so we have the "capture sigil"?

[20:01] <ruoso> my ¢foo = bar(); means not enforcing any context on the result of bar

[20:02] <ruoso> which is equivalent to

[20:02] <ruoso> my @%foo = bar();

[20:04] <ruoso> is that it?

[20:05] <SamB> why "texas"?

[20:05] <diakopter> full-bore?

[20:06] <TimToady> as in ten-gallon hat

[20:06] <TimToady> and the state itself, leaving out Alaska

[20:06] <PerlJam> SamB: « is french, but << is Texan  ;)

[20:07] <TimToady> and conveniently you can buy ¢ @ a % of $

[20:10] <pmichaud> I don't think the invocant change affects rakudo much, fwiw.

[20:10] <pmichaud> (after reading scrollback)

[20:10] <pmichaud> we were already headed down the line of "first argument is invocant"

[20:10] <pmichaud> because that's the way Parrot does it.

[20:11] <pmichaud> the only major thing that impacted rakudo and NQP is the change in meaning of $( ...matchobject... )

[20:11] <TimToady> what do you think about unifying slices and captures?

[20:11] <pmichaud> I kinda thought they were somewhat unified already.

[20:11] <TimToady> and that's mostly a mechanical change

[20:12] <moritz_> rakudo: class A { method !foo { say "in !foo" }; submethod BUILD(*@a) { self!foo } }; A.new()

[20:12] <p6eval> rakudo fe2bc8: OUTPUT«in !foo␤»

[20:12] * moritz_ is duely impressed

[20:12] <pmichaud> I'm duly shocked ---- why did that work?

[20:13] <moritz_> don't know, but the spec says it's right ;-)

[20:13] <pmichaud> I didn't think we parsed "method !foo { ... }"

[20:13] <moritz_> at least as of today

[20:13] <TimToady> well, it used to be that way once

[20:13] <pmichaud> I do find   $a = (1,2,3)   a bit weird.

[20:13] <TimToady> maybe we changed it for roles, or something

[20:14] <pmichaud> (resulting in $a being immutable)

[20:15] <PerlJam> pm: What's weird is that I don't find that weird  :)

[20:15] <pmichaud> but I also found it weird the way it promoted to Array, so perhaps it just takes getting used to.

[20:16] <pmichaud> with $a = (1, 2, 3) being immutable, just how immutable is it?   For example...

[20:16] <pmichaud> my $b = 5;  my $a = (1, $b, 3);   $b = 2;   say $a.perl;   # ???

[20:16] <ruoso> 2

[20:16] <ruoso> ah

[20:16] <ruoso> misread

[20:16] <ruoso> well, you're actually asking how eager it is

[20:16] <pmichaud> and

[20:17] <moritz_> pmichaud: $a.perl will likely be \(1, $b, 3)

[20:17] <pmichaud> my $b = 5;  my $a = (1, $b, 3);   @a[1] = 2;   say $b;   # ???

[20:17] <moritz_> did you mean $a[1] = 2 ?

[20:17] <moritz_> there's no @a

[20:17] <pmichaud> yes, $a[1] = 2, thanks.

[20:17] <ruoso> that's a failure, since it's immutable

[20:18] <moritz_> when captures are immutable... error

[20:18] <ruoso> oh wair

[20:18] <ruoso> I see what you mean\

[20:18] <pmichaud> :-)

[20:18] <pmichaud> "how immutable is it?"  

[20:18] <pmichaud> :-)

[20:18] <ruoso> well...

[20:18] <ruoso> it actually depends on how .[] works

[20:18] <ruoso> in SMOP it would probably fail

[20:18] <ruoso> because we do that kind of things with bvalue objects

[20:19] <ruoso> so you're not accessing the actual value when you .[]

[20:19] <ruoso> it just returns you a lazy lookup object

[20:19] <ruoso> that will do the lookup when you actually ask

[20:19] <ruoso> so if you try to store,

[20:20] <ruoso> it will try to store in the list

[20:20] <ruoso> and that will fail

[20:20] <ruoso> Also

[20:20] <ruoso> when you say 1, $b, 3

[20:20] <ruoso> you're gettting the value inside VAR($b)

[20:20] <ruoso> not the scalar itself

[20:21] <pmichaud> really?  is that always true?

[20:21] <ruoso> actually, it is supposed to be that way

[20:21] <moritz_> ruoso: not in a capture. 'is rw' wouldn't work then

[20:21] <ruoso> but I don't really know how

[20:21] <pmichaud> for ($a, $b, $c) { $_ = 3 };

[20:21] <TimToady> what about if it's subsequently b...what he said

[20:21] <moritz_> pmichaud: that could be the answer... my $a = (1, $b is rw, 3) would make $a[1] assignable, per default it would croak

[20:22] <pmichaud> moritz_: that has the 'is rw' on the wrong side of the bind, I think.

[20:22] <moritz_> though I don't know if '$b is rw' will be parsed without an explicit \ in front of the capture

[20:22] <ruoso> even then... "is rw" is in the Signature

[20:22] <ruoso> not in the capture

[20:23] <pmichaud> exactly.

[20:23] <moritz_> hm

[20:23] <moritz_> you're right

[20:23] <ruoso> in fact, that's a question I still didn't try to answer

[20:23] <moritz_> but I did ;-)

[20:23] <ruoso> I don't really know how to make methods that are not rw

[20:24] <ruoso> since return receives a captuer

[20:24] <pmichaud> to me it seems clear that even if captures are immutable, the elements of the capture aren't.

[20:24] <pmichaud> otherwise 'is rw' doesn't really work.

[20:24] <TimToady> what is immutable is the association with $b as a container

[20:24] <ruoso> yes... in fact, I don't know how to make them also immutable

[20:25] <pmichaud> what TimToady said.

[20:25] <TimToady> or @foo==> as a flow

[20:25] <pmichaud> i.e, we can't change the Capture to associate with something else, but we can change the thing it's associated with.

[20:25] <ruoso> so... if I "return $a" from a method

[20:25] <ruoso> how do I stop it from being rw

[20:26] <TimToady> declare your return type

[20:26] <moritz_> that's not very intuitive

[20:26] <TimToady> then it returns that instead of a capture

[20:26] <ruoso> every routine is rw by default?

[20:26] <ruoso> every block, actually?

[20:27] <moritz_> my @a = gather { my $a; take ++$a while 1 }; @a[5] = 8; # what will @a[6] be?

[20:27] <TimToady> use single-assignment semantics so $a is immutable :)

[20:27] *** rkendall joined
[20:28] <ruoso> it looks like a joke, but I didn't get it

[20:28] <pmichaud> are we still under the "any dependence on laziness is undefined" criteria?

[20:28] <ruoso> anyway... the way to force it to be ro in SMOP today

[20:28] <TimToady> that would be the FP answer, not really a joke

[20:29] <ruoso> would be to do a "return $a.FETCH'

[20:29] <pmichaud> (for moritz's example)

[20:29] <ruoso> then it would return the value inside $a, not $a

[20:29] *** mberends_ left
[20:29] <TimToady> return |$a

[20:29] <moritz_> that's... not very intuitive.

[20:29] <TimToady> hmm, maybe not

[20:29] <PerlJam> I kind thought that was the difference between = and := in a way

[20:29] <ruoso> I think that would fail, since the value of $a is not a capture

[20:30] <ruoso> PerlJam, the problem is that you don't write "return = $a"

[20:30] <ruoso> you write return($a)

[20:30] <moritz_> | interpolates also things that are not captures

[20:30] <ruoso> but a single value doens't have a meaningful value to interpolate to

[20:31] <PerlJam> ruoso: sure, but return always feels like = semantics (to me), so binding semantics need more syntax (I think)

[20:31] <ruoso> PerlJam, but = requires a context

[20:31] <ruoso> to which context are you assigning

[20:31] <ruoso> ?

[20:31] <moritz_> to the context your routine is called in?

[20:32] <TimToady> perhaps return does extra work if there isn't an "is rw" on the routine

[20:32] <pmichaud> looking at this from a different direction, perhaps there's an argument to be made that    my $a = (1,2,3);   assigns the value of 1 to $a

[20:32] <PerlJam> or maybe we could have "return $cap" versus "bind $cap"  (or something like that)

[20:33] <TimToady> the "is rw" factors that out

[20:33] <PerlJam> well, I was thinking that both sides would have to agree 

[20:34] <pmichaud> if  "my $a = (1,2,3)"   always assigns 1 to $a, then = is always list assignment?

[20:34] <pmichaud> I'm sure I'm overlooking something here.

[20:34] <TimToady> well, = has copy semantics even for item assignment

[20:35] <ruoso> so return would no longer be a regular function

[20:35] <pmichaud> it wouldn't?

[20:35] <pmichaud> I don't see that.

[20:35] <ruoso> and become a keyword that enforces the context of the sigil in each part of the arguments

[20:35] *** rkendall left
[20:36] *** rkendall joined
[20:36] <ruoso> return $a, $b, $c; would be seen by the compiler in order to enforce the context of each sigil in the arguments to return 

[20:36] <pmichaud> it'd still be a list, yes?

[20:36] <ruoso> yes

[20:36] <pmichaud> why do we have to enforce the sigil context?

[20:36] <ruoso> so all variable lookup would resolve to its value

[20:37] <ruoso> in the context of the sigil

[20:37] <pmichaud> uh, I'm lost.   return($a,$b,$c)   is just a normal function call.  What piece am I forgetting?

[20:38] <ruoso> ok, let me explain

[20:38] <ruoso> sub foo ( $a is ref, $b is ref, $c is ref ) { $a++; $b++; $c++ }; my $a, $b, $c; sub bar { return($a, $b, $c) }; foo(bar()); say $a, $b, $c;

[20:39] <pmichaud> foo(bar()) doesn't match there.

[20:39] <ruoso> sorry

[20:39] <ruoso> sub foo ( $a is ref, $b is ref, $c is ref ) { $a++; $b++; $c++ }; my $a, $b, $c; sub bar { return($a, $b, $c) }; foo(|bar()); say $a, $b, $c;

[20:40] <moritz_> rakudo on optimized parrot passes all tests here, on amd64

[20:40] *** hercynium joined
[20:40] <pmichaud> you're claiming that return($a, $b, $c) has to return references to $a, $b, and $c in that case, yes?

[20:40] <TimToady> oh, if it passes all tests, you can call it "Perl 6"  :D

[20:40] <ruoso> it doesn't "have to"

[20:40] <ruoso> but since it's a capture

[20:40] <ruoso> it does

[20:40] <diakopter> (quick, add some more tests)

[20:40] * moritz_ slaps TimToady a bit

[20:41] <TimToady> I like have bits slapped on my behalf

[20:41] <PerlJam> TimToady: great!  now I can tell all of the naysayers that perl 6 is ready for use.  :)

[20:41] <pmichaud> I don't see where the context had to be enforced in that example, though.

[20:41] <ruoso> pmichaud, otherwise "is ref" would never be able to work

[20:42] <ruoso> if return is a keyword that expands by the context of the variable

[20:42] <ruoso> it would be the same as 

[20:42] <pmichaud> the capture returned by bar() is bound to the arguments of foo().  It's foo that enforces the capture, not the return.

[20:42] <pmichaud> s/capture/context/

[20:42] <pugs_svn> r25716 | moritz++ | [t/spec] private methods are declared with ! now

[20:42] <ruoso> pmichaud, right... and that's the problem

[20:42] <ruoso> because that sub is not marked as "is rw"

[20:42] <pmichaud> but I'm not modifying the return value of bar.

[20:42] <pmichaud> at least, not directly.

[20:42] <ruoso> you are

[20:43] <ruoso> bar is returning values, it doesn't "is rw"

[20:43] <ruoso> foo asks for "is ref"

[20:43] <ruoso> that was supposed to break

[20:43] <ruoso> but the capture itself doesn't have a way to do it

[20:43] <ruoso> so return needs to do it

[20:44] <ruoso> but return itself can't know which context the original arguments had

[20:44] <ruoso> as a function, that is

[20:44] <pmichaud> bar's CONTROL handler could do it, though.

[20:44] <TimToady> or $a has to have some way of turning off its rw (bestowed by my) when it goes out of scope

[20:45] <ruoso> my idea

[20:45] <ruoso> is that "return" becomes a keyword

[20:45] <ruoso> that syntatically looks around

[20:45] <ruoso> and creates a new list with the proper values

[20:45] <ruoso> instead of the references to the containers

[20:45] <pmichaud> I don't want return to be a keyword, because then we have to consider the impact on fail, gather, warn, and the rest.

[20:45] <pmichaud> s/gather/take/

[20:46] <TimToady> which is why I wanted $a itself to be smarter

[20:46] <pmichaud> exactly.

[20:46] <pmichaud> idle thought:  perhaps putting the 'is rw' on the sub is the wrong place -- perhaps it belongs on the return.

[20:47] <pmichaud> or perhaps return really does return values, and if you want to return a capture you do it explicitly.

[20:47] <ruoso> pmichaud, but for it to return values

[20:47] <pmichaud> I suspect you all have been down these paths before.

[20:47] <ruoso> it needs to know how to traverse them

[20:48] <ruoso> the function has no idea of the format of the capture in depth

[20:48] <ruoso> it can only try to bind them

[20:48] <ruoso> s/them/it

[20:48] <ruoso> or assume one context

[20:48] <ruoso> which would blow things up

[20:48] <pmichaud> anyway, I'll just say that    my $a = (1,2,3);   assigning only the first element (or complaining about extra unassigned values)    feels really good to me.

[20:49] <pmichaud> but I can also get comfortable with the idea that it's a reference to a List or Capture or whatever.

[20:50] <TimToady> I think if we go ahead and let $a be accidentially bindable outside, it won't have much effect, since a typical my $a would be a different variable next time anyway

[20:50] <pmichaud> intuitively, I'd think that it becoming a capture would involve \(...)  somehow, though, and not be "automatic".

[20:51] <moritz_> TimToady: for return that's fine, but for take() that's weird

[20:51] <ruoso> TimToady, that's not true for OO code most of the time

[20:51] <diakopter> what if the binding/assignment context/destination/lvalue *implied* signature (if it existed) were available to return/fail/take/etc as a runtime binder? sorry if it's a naive question.

[20:52] <ruoso> diakopter, the problem is precisely the fact that you don't have a signature 

[20:52] <ruoso> and you can't imply one

[20:52] <TimToady> might take time travel

[20:52] <ruoso> unless...

[20:52] <ruoso> we make it sintatically

[20:52] <ruoso> if the routine is not marked as "is rw"

[20:53] <ruoso> we create a signature that matches that capture

[20:53] <ruoso> and implicitly bind that before returning

[20:53] <diakopter> well, the destination "cast" (yes, it can be a [list of] [tuple(s) of] types/contexts) travels backwards in .net

[20:54] <pugs_svn> r25717 | putter++ | [STD] Removed unused "my @list;" declarations from EXPR.

[20:54] <ruoso> diakopter, in Perl 6 you might not be able to tell that

[20:54] <ruoso> because you can "defer" contextualization

[20:54] *** rindolf joined
[20:54] <rindolf> Hi all.

[20:54] <ruoso> after all, that's what capture is about

[20:54] <rindolf> Does Rakudo have line numbers for run-time errors yet?

[20:55] <pmichaud> rindolf: not yet.  Still needs some updates to PGE.  

[20:55] <pmichaud> And every week that passes I'm glad that I haven't started updating PGE yet :-P

[20:55] <rindolf> pmichaud: ah.

[20:55] <rindolf> pmichaud: thanks.

[20:55] <ruoso> maybe there's some method in the capture

[20:55] <ruoso> to "auto-contextualize"

[20:55] <pmichaud> I thought "auto-contextualize" was "bind".

[20:55] <ruoso> using the syntatical information of how it was built

[20:56] <ruoso> "auto-contextualize" is "bind to a signature auto-generated from the syntatical structure that generated this capture"

[20:57] <ruoso> maybe every capture has a signature

[20:57] <ruoso> syntatically generated

[20:57] <pmichaud> I didn't realize that syntactical structure was part of the capture, to be honest.

[20:57] <ruoso> it isn't

[20:58] * moritz_ is totally lost, but that's probably OK

[20:58] <diakopter> (I pictured a capture as a type signature (however generic/nested), perhaps with symbols.  Maybe that's entirely wrong. I should read the S again/more.)

[20:58] <pmichaud> diakopter: "capture" corresponds to "arguments".  "signature" corresponds to "parameters".

[20:59] <ruoso> but the syntatical format of the capture composition 

[20:59] <ruoso> can be used to form a signature

[20:59] <ruoso> in order to make all the values "copies" not "references"

[20:59] <diakopter> I guess what you're discussing then is a return signature

[20:59] <ruoso> return signature is (|$capture)

[21:00] <ruoso> but return needs to copy the values if the routine is not "is rw"

[21:00] <ruoso> and using an auto-generated signature from the capture syntatical structure to bind the capture into would solve it

[21:00] <pmichaud> copy?  not just mark 'readonly'?

[21:01] <ruoso> or that

[21:01] <ruoso> or whatever

[21:01] <diakopter> cow?

[21:01] <ruoso> whatever the routine defines, actually

[21:01] <diakopter> "is cow"

[21:01] * ruoso need to go &

[21:02] <pmichaud> I must go also -- busy kid evening here tonight (soccer, fencing, dinner, cub scouts, and homework).

[21:02] <pmichaud> yes, all in one night.

[21:03] <moritz_> but not all by one kid?

[21:04] <pmichaud> not all by one kid.

[21:04] <pmichaud> two kids.

[21:05] <moritz_> parallelism++

[21:07] * [particle]1 misses fencing

[21:17] <alester> Could you put up a wall of some kind?

[21:18] <Matt-W> wow that is a busy evening

[21:18] <Matt-W> even for two

[21:22] *** mikehh joined
[21:23] <[particle]1> i'm building a fence, the next time i have a free weekend :)

[21:24] <rkendall> Hi alester - just wanted to check to see if you have had any luck with the MT data for rakudo.org

[21:25] <alester> oh crud, forgot.

[21:25] <alester> um.

[21:25] <alester> tonight.

[21:25] <rkendall> no probs

[21:26] <rkendall> also, noted you were using Markdown for formatting the pages

[21:27] <rkendall> ... if you were wondering why the headings weren't showing up it's because of the formating resrictions with "filtered html"

[21:28] <pugs_svn> r25718 | putter++ | [elfparse] emit5.pm: Unbreak the build (vis r25690).

[21:28] <pugs_svn> r25718 | putter++ | devEXPR.pm: Another porting/cleanup/make-it-less-likely-Ive-introduced-bugs edit.

[21:30] *** Chillance joined
[21:34] <rkendall> alester: You can allow extra html tags in the pages (like <h2>) here: http://rakudo.org/admin/settings/filters/1/configure

[21:34] *** [particle]1 joined
[21:34] <alester> rkendall: Yeah, prefer markdown.

[21:34] <alester> Are you saying that they're not getting allowed?

[21:34] <alester> and should be?

[21:35] <rkendall> yes, some of the Markdown html is getting stripped out by a filter

[21:35] <alester> ok, added h2, h3 and img

[21:35] <alester> thanks

[21:35] <rkendall> noted you had some <h1>s - but they are probably a bit big for inside content anyway

[21:36] <alester> Your test page is fantastic!

[21:37] <alester> I would never delete it!

[21:37] <rkendall> ha ha

[21:38] <rkendall> just changed headings to <h3> here: http://rakudo.org/how-to-help

[21:38] <alester> well, I allowed h1 anyway

[21:39] <rkendall> did you want to take of the "Submitted by" on the pages?

[21:39] <alester> yes

[21:39] <alester> I wouldn't mind if it was "last updated by" though.

[21:40] <diakopter> what was the conclusion for "is rw" return? implicitly capture the returned object[s] with its own signature (provided by the parser)?

[21:40] <diakopter> not is rw, I mean

[21:41] <diakopter> isn't rw

[21:41] <rkendall> Can choose which pages have it here: http://rakudo.org/admin/build/themes/settings

[21:41] <rkendall> would need to edit the theme to put in a "last updated"

[21:42] <alester> thanks

[21:42] <alester> now shows it on Story but not Page

[21:42] *** Chillance left
[21:43] <rkendall> are you sure about those <h1>s?  looks a bit messy on the front page

[21:43] *** Chillance joined
[21:43] *** ZuLuuuuuu joined
[21:44] <rkendall> ...it's a <h2> for the main page heading

[21:44] <alester> syeah, it's ok now

[21:44] <alester> I downgraded to ##

[21:53] <rkendall> Have to go already, but would be glad to help later with any website stuff.

[21:56] <alester> You're doing wonderfully.  I appreciate your in-depth knowledge here.

[21:58] <rkendall> Thanks, your welcome.  Have a good night/day

[22:01] *** rkendall left
[22:02] *** bacek_ left
[22:18] *** kst joined
[22:22] <estrabd> OT: is there a unix utility that, given a list, returns it sorted "randomly"?

[22:22] <estrabd> like the opposite of sort

[22:23] <Tene_> you could do it in perl...

[22:23] <PerlJam> estrabd: no, but you could make one quickly enough

[22:23] <estrabd> no doubt - thanks :)

[22:23] <moritz_> rakudo: (1..10).pick(*).perl.say

[22:23] <p6eval> rakudo fe2bc8: OUTPUT«[1, 3, 4, 9, 5, 10, 7, 2, 8, 6]␤»

[22:24] <rindolf> estrabd: shuf

[22:24] <Tene_> nice

[22:24] <rindolf> Though it may be a GNU extension.

[22:34] *** ZuLuuuuuu left
[22:42] *** hercynium left
[22:44] *** rindolf left
[22:44] *** bacek_ joined
[22:44] *** slango left
[23:04] *** bacek_ left
[23:07] *** riffraff left
[23:11] *** Chillance left
[23:13] <dalek> rakudo: e47c348 | pmichaud++ | src/parser/actions.pm:

[23:13] <dalek> rakudo: Default lexicals as Perl6Scalar instead of Failure.

[23:13] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e47c348771d2372384b57b8b2645aa02f03533fe

[23:13] *** alester is now known as AndyAway

[23:17] *** bacek_ joined
[23:19] *** cognominal joined
[23:25] *** Ariens_Hyperion left
[23:31] *** armagad joined
[23:32] *** armagad left
[23:32] *** armagad joined
[23:37] *** SamB left
[23:37] *** depesz joined
[23:39] *** SamB joined
[23:45] *** M_o_C joined
[23:54] *** wayland76 joined
[23:55] *** bacek_ left
