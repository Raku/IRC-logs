[00:00] *** tak11 joined
[00:04] <pmichaud> oh, $_, $!, and $/ are sooo easy now

[00:04] <jnthn> :-)

[00:04] <pmichaud> we just add them with method finishpad() ...

[00:05] <jnthn> ohsocool

[00:05] <pmichaud> yeah

[00:05] <jnthn> pmichaud: be careful with $_

[00:05] <jnthn> pmichaud: In the case that it needs to become a parameter.

[00:05] <pmichaud> that's easy too

[00:05] <jnthn> Yes, but don't forget to add a signature.

[00:05] *** __ash__ joined
[00:05] <pmichaud> yeah, but we already have a contextual telling us what we're declaring

[00:06] <jnthn> nod

[00:06] <jnthn> That doesn't mean it doesn't need a signauture added though. ;-)

[00:06] <pmichaud> no problem

[00:07] <pmichaud> this will let me see how signatures are done in the new system

[00:07] <jnthn> eek!

[00:07] <jnthn> ;-)_

[00:07] <pmichaud> if you hear a scream, you know I don't like it :)

[00:07] <pmichaud> and the block will already have a signature created, yes?

[00:07] <pmichaud> I just need to add a parameter

[00:07] <pmichaud> well, depending on the type of block

[00:07] <jnthn> At the moment, no

[00:07] <jnthn> Well

[00:07] <jnthn> If it's a pointy for example that woulda done so I guess.

[00:08] <jnthn> But we didn't do pointies yet.

[00:08] <pmichaud> anyway, I'll fix up the signature creation

[00:08] <jnthn> Sure.

[00:09] <pmichaud> oh.  trivial.

[00:10] *** Schwern left
[00:10] <jnthn> Yes, Perl6::Compiler::Signature makes it fairly easy to add a parameter. ;-)

[00:10] <pmichaud> oh, instead of $signature.add_parameter it might've been more consistent to use .push

[00:10] <jnthn> Maybe.

[00:11] <jnthn> I guess I was a tad nervous about it looking too much like a PAST::Node when it actually isn't one.

[00:11] <pmichaud> it might become one someday :-)

[00:11] <jnthn> True.

[00:12] <jnthn> I guess I won't mind if you rename it.

[00:12] <jnthn> I'd argue the current name is more descriptive though. :-)

[00:12] <pmichaud> I won't argue that.  :)

[00:13] *** quuxx left
[00:13] <jnthn> Also, add_parameter isn't quite a "push onto the end" either.

[00:13] *** payload joined
[00:13] <jnthn> We may get away with it in this re-write.

[00:13] <pmichaud> good point.

[00:13] <jnthn> But in the previous grammar, I had to be a tad careful about making sure $_ ended up before *@_ and so on.

[00:13] <jnthn> And it was kinda hard to make us push things in the right order.

[00:13] <pmichaud> right

[00:14] <jnthn> Just 'cus of the parse tree structure.

[00:14] <pmichaud> PAST::Var( :scope('parameter') ) takes care of ordering them properly for you

[00:14] <jnthn> I don't know how that'll fall out here, but since you're talking about handling $_ and .finishpad, I rather suspect we'll hit the same issue.

[00:14] <jnthn> Which is fine, because I left the code that handled this in place. ;-)

[00:14] <pmichaud> well, finishpad is easy

[00:14] <pmichaud> if the block already has a signature, then $_ isn't a parameter.

[00:15] <jnthn> erm, I meant *in* finishpad

[00:15] <pmichaud> $_ is only a parameter in blocks that don't have an explicit signature.

[00:15] <pmichaud> (unless of course the explicit signature mentions $_, in which case we aren't adding it anyway :-)

[00:15] <jnthn> There's a difference between sig and explicit sig, iirc.

[00:16] <jnthn> e.g. if I mention @_ and %_ is $_ a param too?

[00:16] <jnthn> oh, maybe not

[00:16] <jnthn> I can't remember if I correct a spectest or was caught out by one that was right or something...

[00:16] <jnthn> It related to this stuff though.

[00:17] <jnthn> Ah well, when we can run them we'll find out. :-)

[00:17] <pmichaud> the latest incarnation is that if @_ and %_ are mentioned, then $_ isn't an implicit param

[00:17] <jnthn> Isn't. Ok.

[00:17] <jnthn> That makes sense to me.

[00:17] <pmichaud> I'll double-check that, but I'm pretty sure that's the case.

[00:17] <jnthn> I'd rather like it to be. :-)

[00:18] <pmichaud> er, not if they're mentioned, but if they're params

[00:18] * pmichaud double-checks

[00:22] *** quuxx joined
[00:23] <pmichaud> S06:  Note that in this case, C<$_> is not treated as a placeholder because

[00:23] <pmichaud> there is already the C<@_> placeholder.  And C<@_> is a placeholder

[00:23] <pmichaud> only because the sub has no official signature.  Otherwise it would

[00:23] <pmichaud> be illegal (unless explicitly declared).

[00:24] <jnthn> OK.

[00:24] *** pointme joined
[00:24] <pmichaud> so the @_ will have already given the sub a signature, which suppresses the use of $_ as a parameter

[00:24] <jnthn> That's clean and easy.

[00:24] <pmichaud> afk for a bit, errands

[00:25] <pmichaud> anyway, I'll get $_, $!, $/ tonight.  Possibly placeholders also.

[00:25] <carlin> IRC::Simple can now respond to PINGs so pointme can be here fulltime :-)

[00:25] <pmichaud> oh, what do I need to do to make sure that placeholder variables are in the right order?

[00:25] <pmichaud> I guess I can look at master for clues

[00:28] <jnthn> pmichaud: call .add_placeholder_parameter on the signature object rather than .add_parameter

[00:28] <jnthn> But I didn't update that one yet to use the Parameter objects.

[00:28] <jnthn> But that's easy, I'll do it now. :-)

[00:29] * s1n_mini should be studying and not reading

[00:29] <s1n_mini> or lurking

[00:29] *** s1n_mini left
[00:29] *** justatheory joined
[00:31] <jnthn> pmichaud: done. Note that you only call this for _positional_ placeholders, whose order matters. :-)

[00:33] *** orafu left
[00:33] *** orafu joined
[00:42] *** envi^office joined
[00:42] *** envi^office left
[00:44] *** Limbic_Region joined
[00:44] <pmichaud> okay.  and Signature knows how to order the parameters lexicographically, yes?

[00:45] <pmichaud> (when using .add_placeholder_parameter)

[00:45] <pmichaud> that's.... awesome

[00:46] <pmichaud> yay, family finally is home

[00:46] <pmichaud> now we can go get dinner :)

[00:46] <jnthn> pmichaud: yes :-)

[00:48] <pmichaud> okay, time for dinner here

[00:48] <pmichaud> I'll bbl, then work on... lots of stuff :-)

[00:48] <jnthn> Cool

[00:48] <jnthn> I'll post in my blog, and then soon sleep. :-)

[00:49] <pmichaud> I think I'll have bunches of pieces of Test.pm running soon

[00:49] <pmichaud> it'll be interesting to start it on the spectests :-)

[00:49] <pmichaud> I'm sure we'll see    EPIC FAIL

[00:49] <jnthn> Prepare for epic fail!

[00:50] <pmichaud> we need something beyond EPIC

[00:50] <jnthn> APPOCALYPTIC FAIL

[00:50] <pmichaud> that's it

[00:50] <jnthn> ...cus we failed to implement what was in the appocalypses... ;-)

[00:51] <jnthn> (which given they're now out of date is actual a partial win, but anywyas... :-))

[00:51] <pmichaud> okay, gone here

[00:52] <pmichaud> bbl

[00:52] <jnthn> o/

[00:54] *** pnate joined
[00:59] *** __ash__ left
[01:03] *** quuxx left
[01:04] *** quuxx joined
[01:04] *** pointme left
[01:04] *** nihiliad left
[01:06] <quuxx> jnthn++ blogged "A productive weekend in Rakudo land": http://use.perl.org/~JonathanWorthington/journal/39829?from=rss

[01:07] *** pnate2 joined
[01:15] *** nihiliad joined
[01:18] *** Whiteknight left
[01:18] *** wknight8111 joined
[01:20] *** pnate2 left
[01:21] *** pnate left
[01:26] *** agentzh joined
[01:27] *** b0nk joined
[01:28] *** JimmyZ joined
[01:32] *** pnate joined
[01:33] *** __ash__ joined
[01:35] *** ihrd joined
[01:35] *** ihrd left
[01:35] *** b0nk left
[01:36] *** b0nk joined
[01:40] *** mjk joined
[01:40] *** IllvilJa left
[01:46] *** icwiener left
[01:47] *** pnate2 joined
[01:52] *** kidd left
[01:53] *** nihiliad left
[01:58] *** JimmyZ left
[02:01] *** pnate left
[02:06] *** mjk left
[02:06] *** cognominal joined
[02:15] *** pnate2 left
[02:18] *** JimmyZ joined
[02:19] *** JimmyZ left
[02:26] *** quuxx left
[02:51] *** jferrero left
[02:52] *** justatheory left
[02:56] *** Paks joined
[03:04] *** Limbic_Region left
[03:09] *** nihiliad joined
[03:11] *** tak_ joined
[03:11] *** tak_ left
[03:13] *** justatheory joined
[03:19] *** nickgibbon left
[03:21] *** jiing joined
[03:26] *** wknight8111 left
[03:47] *** envi^office joined
[03:51] *** justatheory left
[03:51] *** agentzh left
[03:57] *** revdiablo joined
[03:59] *** alester joined
[04:10] *** jerry_ joined
[04:11] <jerry_> hi, guys, can anyone give some advices on perl6 vs python 2.6?

[04:12] *** pnate joined
[04:12] <revdiablo> jerry_: Advice about what?

[04:13] <jerry_> I have learned python 2.6, and I want to learn perl 6, what will be the new things I need to know？

[04:13] <revdiablo> jerry_: Take a look at http://perl6.org/

[04:16] *** astrojp left
[04:16] <revdiablo> jerry_: Perl 6 is still a work in progress, so the docs are a bit spotty at the moment

[04:17] <jerry_> revdiablo : do you have any link which compare the two?

[04:21] *** meppl left
[04:22] *** jerry_ left
[04:23] *** meppl joined
[04:25] *** pnate2 joined
[04:38] *** pnate left
[04:38] *** pnate joined
[04:52] <dukeleto> pmichaud: ping!

[04:54] *** pnate2 left
[04:56] <dukeleto> pmichaud: i am slightly concerned that nqp-rx depends on a non-released version of parrot: http://nopaste.snit.ch/18528 . am I missing something?

[05:03] *** pnate2 joined
[05:06] *** lidden left
[05:08] *** pnate left
[05:09] <carlin> dukeleto: Parrot 42174 is released? run Configure.pl with the --gen-parrot option

[05:10] <dukeleto> carlin: i am concerned that it is pegged to a non-release version of parrot

[05:10] <carlin> ohh, I get you

[05:10] <dukeleto> carlin: if it is because that is a non-release version of nqp-rx, then that is fine. But i am not sure that is the case.

[05:12] <carlin> I see what you mean - ignore me :-)

[05:17] *** pnate joined
[05:31] *** pnate2 left
[05:31] *** pnate2 joined
[05:36] <pmichaud> dukeleto: pong

[05:37] <pmichaud> it's a non-release version of nqp-rx

[05:37] <pmichaud> but it's also the case that the latest released version of Parrot is not sufficient to run nqp-rx

[05:43] *** pnate left
[05:44] *** Bzek joined
[05:45] *** pnate joined
[05:46] *** am0c joined
[05:56] *** szabgab joined
[05:58] *** pnate left
[06:00] *** pnate2 left
[06:15] *** rgrau left
[06:16] *** pnate joined
[06:28] *** am0c left
[06:33] *** envi^office left
[06:38] *** nihiliad left
[06:39] *** nihiliad joined
[06:54] *** envi^office joined
[07:03] *** envi^home joined
[07:05] *** pnate left
[07:15] *** nihiliad left
[07:44] *** flip214 joined
[07:45] <flip214> Good morning everybody!

[07:47] <moritz_> oh hai

[07:47] <flip214> I'm about to really start developing with perl6 Real Soon Now ...

[07:48] <moritz_> that's great

[07:48] <flip214> But as the (existing) tests of my application (currently written in C) take some hours, I'd be interested to get my perl6-rewrite compiled.

[07:48] <flip214> So, are there any news for FFI, native types like int32 and LLVM integration?

[07:49] <flip214> I know that it'll be some time until I can really try to run my tests exhaustively, but if every single test takes a few seconds to start up, it gets a bit tedious.

[07:50] <moritz_> the parrot folks are working on the JIT compiler

[07:50] <moritz_> so far they have a proof-of-concept frame builder with a third-party JIT engine

[07:50] <moritz_> but nothing to JIT-compile PBC yet

[07:50] <flip214> Well, I'd be happier if it got "compiled" to C, for LLVM

[07:51] <flip214> I've started to play with swig a bit

[07:51] <flip214> is there anything done for FFI?

[07:51] <flip214> Maybe I could provide some (small) starting point

[07:51] <moritz_> parrot has a NCI (native call interface)

[07:52] <moritz_> which seems to work, mostly

[07:53] <moritz_> there are binding for SDL and SQLite, for example

[07:53] <moritz_> see examples/nci/ in the parrot repo

[07:53] *** quuxx joined
[07:54] *** Su-Shee joined
[07:54] <Su-Shee> good morning.

[07:54] <moritz_> good morning Su-Shee 

[07:56] <Su-Shee> meh. I'll have to swim to the office today :/

[07:56] *** baest joined
[07:56] *** __ash__ left
[07:57] <moritz_> :(

[07:57] *** iblechbot joined
[08:03] *** renormalist left
[08:16] *** mariuz joined
[08:24] *** alester left
[08:25] <moritz_> http://lastofthecarelessmen.blogspot.com/2009/10/its-alive.html last++

[08:26] <moritz_> I feel his summary is much more spot-on than my dry Tidings post

[08:31] <Su-Shee> I woke up with p6 ideas this morning. I really have to organize work and private projects better :/

[08:33] <moritz_> your subconcious tells you to work more on Perl 6 ;-)

[08:34] <Su-Shee> indeed :/

[08:34] <Su-Shee> if you start thinking about project x, you soon realize how much is still missing.

[08:36] *** mberends left
[08:42] *** rgrau joined
[08:49] *** IllvilJa joined
[08:55] *** am0c joined
[09:03] *** cosimo joined
[09:13] *** quuxx left
[09:14] *** quuxx joined
[09:20] *** ejs joined
[09:23] *** envi^office left
[09:26] *** xp_prg left
[09:31] *** renormalist joined
[09:53] *** meppl left
[09:59] *** Chillance joined
[10:00] *** am0c left
[10:05] *** estrai joined
[10:37] *** quuxx left
[11:07] *** wlan joined
[11:10] *** colomon left
[11:20] *** dakkar joined
[11:23] *** payload left
[11:24] *** wlan_ left
[11:29] *** colomon joined
[11:29] *** alester joined
[11:33] *** alester left
[11:34] *** KatrinaTheLamia left
[11:34] *** flip412 joined
[11:35] *** ejs left
[11:36] *** flip214 left
[11:45] *** krunen left
[11:47] *** krunen joined
[11:51] *** KatrinaTheLamia joined
[11:51] *** flip412 left
[11:51] *** flip412 joined
[11:52] *** zaslon joined
[11:54] <carlin> Hopefully it'll work ...

[11:54] <zaslon> loljnthnhazblogged! jnthn++ 'A productive weekend in Rakudo land': http://use.perl.org/~JonathanWorthington/journal/39829?from=rss

[11:54] <carlin> Argh

[11:55] <moritz_> looks like my patches got applied, \o/

[11:55] <zaslon> lolpmichaudhazblogged! pmichaud++ 'Failure()<0xb76d205c>': Failure()<0xb54b2e4c>

[11:55] *** zaslon left
[11:56] <carlin> Or not :(

[11:56] <carlin> Oh yes, moritz_++

[11:56] *** ejs joined
[11:57] <moritz_> carlin: I thought I wouldn't have to test pmichaud's blog separately, because it's the same feed generator (use.perl.org)

[11:57] <moritz_> apparently that was a wrong conclusion :-)

[12:01] *** flip412 left
[12:01] <carlin> I see what's wrong :-)

[12:01] *** flip412 joined
[12:03] *** zaslon joined
[12:03] <zaslon> lolpmichaudhazblogged! pmichaud++ 'Failure()<0xb76d205c>': Failure()<0xb54b2e4c>

[12:03] <carlin> Or not

[12:03] <jnthn> ...did pm actually blog?

[12:03] * jnthn hasn't seen a new post

[12:03] <colomon> I just looked and haven't found it yet...

[12:04] *** rgrau left
[12:04] <moritz_> Oct 21 is the newest

[12:05] *** zaslon left
[12:08] *** charsbar left
[12:08] *** charsbar_ joined
[12:10] *** envi^home left
[12:10] *** tak11 left
[12:10] *** zaslon joined
[12:11] *** rgrau joined
[12:12] <carlin> that looks better

[12:12] <carlin> now someone just needs to blog something :-)

[12:13] <jnthn> well, I'm sure masak will at some point today ;-)

[12:13] *** envi^home joined
[12:17] *** pointme joined
[12:29] *** lidden joined
[12:32] *** tak11 joined
[12:33] *** am0c joined
[12:40] *** iblechbot left
[12:42] *** pointme left
[12:51] *** payload joined
[12:52] *** masak joined
[12:53] <masak> oh hai, #perl6.

[12:53] <jnthn> yayitsSUPERBLOGGERmasak!

[12:54] <masak> it's only been one day :P

[12:54] <am0c> oh hai

[12:56] <jnthn> masak: Yes, and 29 to go. \o/

[13:00] *** payload left
[13:02] *** rgrau left
[13:02] *** payload joined
[13:04] *** takadonet joined
[13:04] <takadonet> morning all

[13:11] <carlin> one of zaslon's processes is leaking memory :/ one has sat at 110m, the other has kept going up - now at 228m

[13:12] <masak> takadonet: mornin'

[13:12] <jnthn> :-/

[13:12] <masak> carlin: I'm not surprised. I see that all the time.

[13:12] <masak> with long-running Rakudo scripts, I mean.

[13:12] <jnthn> My Parrot! It's leaking!

[13:14] <carlin> It's rss.pl ... maybe I could run that on a cron

[13:16] *** pmurias joined
[13:16] *** pmurias left
[13:16] <masak> hm. I liked this post by lilstevey++: http://use.perl.org/~lilstevey/journal/39827

[13:17] <masak> I'm not sure I'm awake enough to reply to it yet, but it sure touches on a lot of steps where I've been involved.

[13:17] *** tak11 left
[13:17] <masak> essentially, I think it's great that he's trying to make things work on win32. I'm not sure many people have tried that before.

[13:19] <jnthn> I "tried" to make proto work on Win32, as in, spent about 15 mins and decided it just wasn't going to because it involved bash scripts.

[13:19] <jnthn> I ain't tried again since.

[13:19] <jnthn> And that was a while ago.

[13:20] <masak> the bash script is just an auxiliary thing that creates new projects.

[13:20] <jnthn> Ah, I think that's the thing I wanted to do. ;-)

[13:20] <masak> it piggybacks on proto rather than being a part of it.

[13:20] <jnthn> Thing is, Rakudo / Parrot on Win32 works very well *if* you have the right compiler/OS version.

[13:20] <masak> that sounds like good news.

[13:21] <jnthn> (MS VC++ compiler on WinXP is fine.)

[13:21] <jnthn> Main reason being, that's where I develop.

[13:21] <jnthn> Annoyingly, because of some Microsoft bs, the compile that should work out great on Vista and Win7 doesn't right at the very last stage.

[13:22] *** am0c left
[13:22] <jnthn> But MS VC++ is probably the best route overall, provided the Vista/Win7 issue can be sorted out.

[13:23] <jnthn> I'll have a Win7 laptop in the next month or so anyway, so if nobody beats me to it, I'll sort it out so I cna hack on Rakudo on that.

[13:23] *** alester joined
[13:28] *** rfordinal joined
[13:32] *** pointme joined
[13:33] *** payload left
[13:35] *** alester left
[13:36] *** payload joined
[13:41] *** pmurias joined
[13:41] *** envi^home left
[13:43] *** reid04 joined
[13:44] *** rfordinal left
[13:47] *** hirschnase joined
[13:53] *** riffraff joined
[13:54] *** hirschnase left
[13:54] *** hirschnase joined
[13:57] *** alester joined
[13:57] *** alester left
[13:58] *** hirschnase left
[13:58] *** hirschnase joined
[14:00] *** payload left
[14:03] *** alester joined
[14:06] *** riffraff left
[14:08] <pmichaud> good morning, #perl6

[14:08] *** rfordinal joined
[14:09] <moritz_> \ö/

[14:10] <masak> \ↂ/

[14:11] * pmichaud decides to abandon the set of changes he was working on last night.

[14:11] <moritz_> speaking of abandoning changes...

[14:12] <jnthn> pmichaud: A night of sleep made them look less attractive? :-)

[14:12] <pmichaud> need a bit of a rethink

[14:12] <moritz_> yesterday night I showed the awesome simplifications I made to the reduction methods in JSON::Tiny... that did not work

[14:12] <pmichaud> they were less attractive when I worked on them last night, which is why they didn't get "commit"

[14:12] <moritz_> it turns out they almost work

[14:13] <jnthn> :-)

[14:13] <moritz_> the reason they don't work fully is that if <foo>* matches zero times, $<foo> is undef, not Nil

[14:13] <pmichaud> that's fixed in ng

[14:13] <moritz_> so $<foo>».ast dies with Method .ast not found for invocant of class Failure

[14:14] <moritz_> glad to hear that

[14:14] <pmichaud> nqp:  grammar ABC { token TOP { <foo>* abc };  token foo { foo } }; my $/ := ABC.parse('abc');  say $<abc>.WHAT;

[14:14] <p6eval> nqp: OUTPUT«Confused at line 1, near "say $<abc>"␤current instr.: 'parrot;HLL;Grammar;panic' pc 365 (src/cheats/hll-grammar.pir:197)␤»

[14:14] <moritz_> say()

[14:14] <pmichaud> nqp:  grammar ABC { token TOP { <foo>* abc };  token foo { foo } }; my $/ := ABC.parse('abc');  say($<abc>.WHAT);

[14:14] <p6eval> nqp: OUTPUT«Method 'WHAT' not found for invocant of class 'Undef'␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[14:14] <pmichaud> nqp:  grammar ABC { token TOP { <foo>* abc };  token foo { foo } }; my $/ := ABC.parse('abc');  say($<foo>.WHAT);

[14:14] <p6eval> nqp: OUTPUT«Method 'WHAT' not found for invocant of class 'ResizablePMCArray'␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[14:14] <pmichaud> heh

[14:15] <pmichaud> well, at lest you can see it's an Array :-)

[14:15] <pmichaud> *least

[14:15] <moritz_> ;-)

[14:15] <pmichaud> ETOOEARLYTOTYPE

[14:16] <pmichaud> pmichaud@orange:~/ng$ ./perl6 Test.pm

[14:16] <pmichaud> No applicable methods.

[14:17] <pmichaud> not the error I was expecting, but it looks like we compile and get to execution

[14:17] <pmichaud> afk, honeydew

[14:18] <mathw> hmm

[14:18] <mathw> what is this 'Nil'

[14:18] *** alester left
[14:18] <moritz_> mathw: it's a thing that is undef in item context, and the empty list in list context

[14:18] <moritz_> mathw: it's the thing that an empty return; does in Perl 5

[14:18] <mathw> aaah

[14:21] <moritz_> do we have a spec solution for map-on-lists yet?

[14:22] *** __ash__ joined
[14:22] <moritz_> ( (1, 2).map: {.say } tries to bind $_ as rw, but since lists are immutable, that will fail)

[14:24] *** rfordinal3643 joined
[14:24] <pmichaud> I think it needs a mention on p6l.  Or perhaps I can add it as a Pm-# question.

[14:28] <moritz_> I can write to p6l if you want me to

[14:28] <pmichaud> yes, please.

[14:29] <pmichaud> pmichaud@orange:~/ng$ ./perl6 Test.pm

[14:29] <pmichaud> No applicable methods.

[14:29] <pmichaud> that's such an annoying error message

[14:30] <masak> LTA.

[14:30] <pmichaud> I think it's even below LTA

[14:30] <mathw> But above something like 'No'

[14:30] <moritz_> abyssimal

[14:31] * pmichaud goes to fix it.

[14:31] <masak> LTA is a half-open interval. it's the bottom part that's open (and infinite) :)

[14:31] <masak> my $LTA = *..$awesome;

[14:31] <jnthn> pmichaud: heh, well, it tells you that it's not a Perl 6 Multi.

[14:31] <pmichaud> yeah, it's a parrot multi

[14:32] <jnthn> (Perl 6 ones at least report the sub name... ;-))

[14:32] <pmichaud> but it would be nice if it say "No applicable methods for sub ... "

[14:32] <jnthn> Right.

[14:32] <moritz_> masak: *..^$awesome please

[14:32] <pmichaud> and why is it "methods"?

[14:32] <masak> moritz_: oh, right. of course.

[14:32] <jnthn> pmichaud: heck knows

[14:32] <masak> and I really should have more whitespace. * ..^ $awesome

[14:32] <jnthn> pmichaud: p6ms does "No applicable candidates found to dispatch to for '%Ss'"

[14:33] <pmichaud> jnthn: perfect

[14:33] * pmichaud steals code

[14:33] <mathw> hmm

[14:33] <jnthn> pmichaud: I did ponder that we could dump a list of signatures that are possibles. ;-)

[14:33] <mathw> what about "I'm confused. What did you want me to call? I can't find anything like $thing which fits."

[14:34] <mathw> or maybe "unable to fit Str-shaped peg in Int-shaped hole"

[14:34] <jnthn> mathw: It's really not that simple.

[14:34] <mathw> Yeah multidispatch makes everything more complicated

[14:34] <mathw> fun, though

[14:34] <jnthn> mathw: I mean, there's a multitude of reasons why the dispatch may have found no applicable candidates.

[14:35] <mathw> and the compiler saying "YOU GOT IT WRONG" isn't necessarily going to be accurate

[14:35] <moritz_> it would be awesome to have a debug mode

[14:35] <jnthn> It may be a fun exercise to write a tool that analyses such things.

[14:35] <moritz_> where the error message contains a list of candidates

[14:35] <mathw> It might be good to get a list of candidates

[14:35] <moritz_> and for each of them tells you what part didn't match

[14:36] <mathw> Do we have an ambiguous dispatch error? That would be a good place for candidates

[14:36] <moritz_> we do

[14:36] <jnthn> mathw: We do, and it already tells you.

[14:36] <mathw> yay

[14:36] <jnthn> It actually only shows the ones that were in conflict, not all of them.

[14:36] <mathw> I like that we're at the stage where I can suggest things you've already written

[14:36] *** rfordinal left
[14:36] <moritz_> rakudo: multi a(Int $, Any $) { }; multi a(Any $, Int $) { }; a(2, 3)

[14:36] <p6eval> rakudo 33111d: OUTPUT«Ambiguous dispatch to multi 'a'. Ambiguous candidates had signatures:␤:(Int $, Any $)␤:(Any $, Int $)␤in Main (file <unknown>, line <unknown>)␤»

[14:36] <pmichaud> jnthn: so, last night I worked on $_ as parameter and placeholders....

[14:37] <moritz_> rakudo: multi a(Any $, Any $) {  }; multi a(Int $, Any $) { }; multi a(Any $, Int $) { }; a(2, 3)

[14:37] <colomon> That's such a great improvement over the old message...

[14:37] <p6eval> rakudo 33111d: OUTPUT«Ambiguous dispatch to multi 'a'. Ambiguous candidates had signatures:␤:(Int $, Any $)␤:(Any $, Int $)␤in Main (file <unknown>, line <unknown>)␤»

[14:37] <pmichaud> jnthn: I'm thinking that the complete separation of signatures from blocks isn't going to quite work out

[14:37] <moritz_> note that the Any, Any didn't end up iin the error message

[14:38] <mathw> moritz_: that'll be presumably because the two alternatives with Int in them are narrower, so Any, Any has already been thrown away when it determines ambiguity?

[14:38] <jnthn> pmichaud: Why?

[14:38] <pmichaud> several reasons

[14:38] <moritz_> mathw: correct

[14:38] <jnthn> It'll mean we have to do a few things a little differently, sure.

[14:39] <pmichaud> the first is that if we wait until   action routine_def to attach the signature, then blockoid can't report back about attempts to use placeholders in a block that has a signature

[14:39] <pmichaud> but more generally, we really want the variables to be in place before we get to parsing blockoid, not afterwards

[14:39] <pmichaud> s/variables/parameters

[14:39] <jnthn> Hmm.

[14:40] *** ejs left
[14:40] <pmichaud> however, I think there are some possibly easy fixes

[14:40] <jnthn> OK, here's what my real drive is here.

[14:40] <pmichaud> for one, we could attach a signature to the block only if $*IN_DECL is 'routine' or 'method'

[14:40] <jnthn> I don't mind if block creation goes looking to see if we've a signature parsed and ready to pick up and attach do it.

[14:40] <jnthn> I *do* mind if the action for signature creates a block.

[14:40] <pmichaud> well, it's certainly the case that signature won't create a block

[14:40] <jnthn> s/do it/to it/

[14:41] <pmichaud> that's the function of <.newpad>

[14:41] <jnthn> Right, but it did in the previous actions.pm, and it wasn't nice.

[14:41] <pmichaud> right, we're not doing that

[14:41] <jnthn> OK.

[14:41] <jnthn> Provided we don't do that, then I'm happy.

[14:41] <pmichaud> <.newpad> creates a new lexpad/block structure

[14:41] <pmichaud> signature just attaches itself to that

[14:41] <jnthn> hmm

[14:41] <pmichaud> but not always, because we don't want to attach a signature when we're in blokoid

[14:42] <pmichaud> *blockoid

[14:42] <jnthn> OK.

[14:42] <jnthn> STD does this "fakesignature" thing where it creates a throw-away pad.

[14:42] <pmichaud> right

[14:42] <jnthn> Which I kinda dislike.

[14:42] <pmichaud> that doesn't bother me too much

[14:42] <jnthn> It just doesn't feel especially clean.

[14:42] *** xinming left
[14:43] <pmichaud> it's not especially clean

[14:43] <pmichaud> but I've had that feeling about signatures in general anyway

[14:43] <pmichaud> I've been thinking about a contextual that says "attach me"

[14:43] <jnthn> Could work.

[14:44] <pmichaud> I'm a bit reluctant to add too many contextuals... although I do like them much better than flags

[14:44] <jnthn> tbh though, now I know you're not going to shove block creation into signature, I'm probably going to be happy enough with whatever you do. :-)

[14:44] <pmichaud> okay

[14:44] <pmichaud> good to know :)

[14:44] <jnthn> I just epicly didn't want to re-do that mistake. :-)

[14:44] <pmichaud> right

[14:45] <pmichaud> STD has a lot of little gems for us

[14:45] <pmichaud> for example, I think the place to generate signature (if we don't have one already) is <.getsig>

[14:45] <jnthn> Basically it's that and that the signature action method hands back a Perl6::Compiler::Signature.

[14:45] <jnthn> Then sigterm becomes trivial too.

[14:45] <pmichaud> <signature> definitely gives back a PCS

[14:45] <pmichaud> <signature> definitely does not create blocks

[14:46] <jnthn> OK, then I'm probably happy. :-)

[14:46] <pmichaud> okay, I'll rework my $_ patch along those lines.

[14:47] <jnthn> Great.

[14:47] <jnthn> pmichaud++

[14:48] <pmichaud> I do have it generating $/ and $!

[14:48] <pmichaud> and $_ when it knows that it cannot be a parameter

[14:53] <jnthn> OK, nice. :-)

[14:55] <pmichaud> hmmmmmmm......

[14:56] <jnthn> .oO( plz let next me "oh nm" )

[14:57] <masak> rot13 in Perl 6. not as simple as I'd hoped... http://gist.github.com/224204

[14:57] <masak> maybe I'm missing something.

[14:58] <pmichaud> masak:  ...trans?

[14:58] <moritz_> aye

[14:58] <masak> there you go. :)

[14:58] *** iblechbot joined
[14:58] <masak> that's what I missed.

[14:58] * masak makes a new, better version

[14:59] <pmichaud> oh nm

[14:59] <jnthn> phew, I'm not in trouble. :-)

[15:00] <pmichaud> no, it wasn't going to be you anyway.  I was thinking that there was something in S02 that indicated that --> was coercion instead of constraint

[15:00] <pmichaud> a second reading shows that S02 is correct (if perhaps unclear)

[15:00] <jnthn> masak++ # implemneting strong encryption mechanisms in Perl 6.

[15:01] <masak> here's the improved version: http://gist.github.com/224204

[15:01] <masak> looks a lot better :)

[15:01] <pmichaud> why not

[15:01] <mathw> double ROT13 is such a secure encryption that the text doesn't even look like it's encrypted

[15:01] <pmichaud> 'A..Za..z' => 'N..ZA..Mn..za..m'     # ?

[15:02] <masak> ooh!

[15:02] * masak does that

[15:03] <masak> http://gist.github.com/224204

[15:03] <masak> pmichaud++

[15:03] <mathw> now using placeholders

[15:03] <mathw> that's just showing off

[15:04] <masak> :)

[15:04] <mathw> also, my style sensor's going off

[15:04] <mathw> because surely you want a nice explicit signature to help people call it properly

[15:04] <pmichaud> masak: so, is perl 6 redeemed?

[15:04] <masak> pmichaud: sure. even from the start, I assumed that I was missing something, not Perl 6.

[15:04] <masak> mathw: but it's one line!

[15:05] <jnthn> masak: It still has a signature. :-)

[15:05] <jnthn> er

[15:05] <masak> surely this is the perfect time to use placeholders.

[15:05] <jnthn> mathw: ^^

[15:05] <masak> aye. though admittedly not an explicit one.

[15:05] <pmichaud> it's even explicit :-)

[15:05] <pmichaud> it's just not in pill form

[15:06] <jnthn> Interestingly they boil down to exactly the same Signature object being created.

[15:06] <masak> pmichaud: we have different definitions of 'explicit'.

[15:06] *** alester joined
[15:06] <Juerd> masak: sub rot13 ($_) { .trans(...) }

[15:07] * Juerd loves having $_ in a signature.

[15:07] <mathw> jnthn: oh, do placeholders cause signatures to be generated?

[15:07] <masak> Juerd: I like. I'll go with that.

[15:07] <mathw> Juerd: yes I rather like that too

[15:08] <masak> http://gist.github.com/224204

[15:08] <Juerd> Does the whole CALLER:: thing work? You could even let it default perhaps :D

[15:08] <pmichaud> there's even

[15:08] <pmichaud> sub rot13 { $^_.trans(...) }

[15:08] <masak> o.O

[15:08] <pmichaud> actually, that probably fails at the moment

[15:08] <Juerd> Style question: sub name (...) { ... } or sub name(...) { ... }, which makes more sense?

[15:09] <pmichaud> TimToady tends to use the first form

[15:09] <Juerd> pmichaud: Wha-wow.

[15:09] <pmichaud> I've tended to use the second

[15:09] <mathw> I tend to use the second in all other languages which have () around signatures

[15:09] <Juerd> The former feels more natural to me, but I've seen mostly the latter.

[15:09] <masak> Juerd: an argument for the first form arose in a discussion with mberends++.

[15:09] <mathw> Except in C++ operator overloads

[15:09] <Juerd> masak: Could you summarize it please?

[15:09] *** Exodist left
[15:09] <mathw> because things like operator ()() get a bit eye-bending

[15:10] <masak> Juerd: because space is not allowed in the call, it's more consistent not to use it in the declaration.

[15:10] <[particle]1> isn't $_ set as an implicit placeholder if none are mentioned, but one is passed?

[15:10] <pmichaud> ...what masak said

[15:10] <Juerd> Hm

[15:10] *** [particle]1 is now known as [particle]

[15:10] <pmichaud> [particle]: not in a routine

[15:10] <[particle]> ah

[15:10] <Juerd> masak: Isn't that an argument for the *second* form?

[15:10] <mathw> masak: yes, that was the second form

[15:10] <[particle]> so you can't do sub rot13 { .trans(...) }

[15:11] <masak> Juerd, mathw: oh. right. the second form.

[15:11] <pmichaud> [particle]: you *can*, but it doesn't do what you want, unless what you want is a "use of undefined value" warning

[15:11] <pmichaud> :-)

[15:11] <Juerd> Maybe it's that it *isn't* a call, that makes me want to use whitespace. Exactly to make the difference clear.

[15:11] <Juerd> But I'm just guessing now.

[15:11] <jnthn> mathw: yes, place holders just cause generation of a signature.

[15:12] <mathw> Juerd: it could be argued like that, yes

[15:12] <mathw> jnthn: unfortunately you have to look in the body of the routine to find the things, so it could easily become non-obvious

[15:12] <pmichaud> actually, placeholders are just an alternate mechanism for declaring a signature.  we always generate a signature.

[15:12] <mathw> I would hope people largely stick to using them for little blocks passed to map etc.

[15:12] <pmichaud> even    { say(4); }    has a signature.  :-)

[15:12] <mathw> rather than in their subroutines

[15:13] <mathw> yay! signature democracy!

[15:13] <jnthn> mathw: Yes, I'd hope so too.

[15:13] *** flip412 left
[15:13] <mathw> or is that signature communism

[15:13] <jnthn> mathw: They're nice for small things.

[15:13] <Juerd> masak: It's interesting to read the revisions of your rot13 thingy. How you've made it elegant in 4 steps :)

[15:13] <jnthn> mathw: The nice thing is that if you have an editor that has loaded the code and introspects the signature of a routine, it'll show up though.

[15:14] <jnthn> (e.g. if it's doing auto-complete style thingies for sigs)

[15:14] <mathw> mmm

[15:14] <mathw> but if you use vim...

[15:14] <masak> Juerd: yes. I just tweeted to that effect. :)

[15:14] <moritz_> then you need to make vim smarter ;-)

[15:14] <mathw> heh

[15:14] <mathw> need to get vim to be able to ask a Perl 6 runtime for help syntax highlighting

[15:15] <jnthn> I'm not convinced vim users are the target audience for code completion...

[15:15] <mathw> no probably not :)

[15:15] <mathw> I mostly dislike it, actually

[15:15] <mathw> it tends to get in my way

[15:15] <mathw> visual studio's interpretation of it for C# programming is infuriating, that dropdown thing always appears on top of something I want to look at

[15:15] <jnthn> I do like being able to grab a class, do Class.new. and then I have a list of the methods.

[15:15] <Su-Shee> too much gui action for my programming taste. 

[15:16] <Juerd> masak: What's your twitter username?

[15:16] <jnthn> mathw: I quite like Visual Studio's doing of it, fwiw.

[15:16] <Juerd> (Mine is Whreq, but I tweet mostly in Dutch)

[15:16] <Su-Shee> jnthn: yes. in a menu right or left for example, keeping the main code area visual.

[15:16] <jnthn> mathw: Though I then installed Resharper.

[15:16] <Juerd> (Oh, and Whreq is rot13("Juerd") ;))

[15:16] <jnthn> mathw: And that REALLY annoyed me. :-)

[15:17] *** zaslon left
[15:17] <pmichaud> ETOOMUCHLHF

[15:17] <pmichaud> [particle]: when might you want to chat briefly about S19?

[15:17] <Juerd> Too much Let's Have Fun?

[15:17] <Juerd> Long Haired Freaks? :)

[15:17] <pmichaud> Juerd: that, and also "low hanging fruit"

[15:18] <Juerd> Ah :)

[15:18] <jnthn> mathw: Guy who tried to get me to install it was like "it makes you more productive! install it!". A couple of days later, I told him that so far it'd lost a couple of hours of productivity to getting mad at it's constant interfering.

[15:18] <pmichaud> I have too many things I want to work on at once, most of which are very useful but not very difficult

[15:19] *** xinming joined
[15:19] <Juerd> pmichaud: In that case, redesign for imperfection so most of those things will become very difficult.

[15:20] <moritz_> pmichaud: in that case hide the IRC window ;-)

[15:20] <[particle]> pmichaud: seems i'm caught up enough at work that now (or soon) is good

[15:20] <Juerd> moritz_: Or what moritz_ said :D

[15:20] <Su-Shee> excellent idea. an ide which can "irc window close on code" ;)

[15:20] <pmichaud> [particle]: okay, my question of the moment is about using the type constraints in MAIN to determine the argument parsing

[15:21] <pmichaud> S06:2994 has the following:

[15:21] *** zaslon joined
[15:21] <pmichaud>     # Long names

[15:21] <pmichaud>     --name                     :name            # only if declared Bool

[15:21] <pmichaud>     --name=value               :name<value>     # don't care

[15:21] <pmichaud>     --name value               :name<value>     # only if not declared Bool

[15:22] <pmichaud> I don't thik that second choice can be "don't care"

[15:22] <pmichaud> *think

[15:22] <pmichaud> at least, not if we're following standard Perl 6 semantics

[15:23] <pmichaud> in particular,  in Perl 6,    mysub(:name<value>)    won't bind to     sub mysub(Bool :$name) { ... }

[15:24] <moritz_> unless TimToady continues to magicify the types of <...> quote contents

[15:24] <pmichaud> moritz_: that doesn't help with   mysub(:name('value'))

[15:24] <pmichaud> (which is really what this is, in any case)

[15:25] <pmichaud> it could be made to work if we say that the command line option processor looks at the signature of main and chooses to treat a Bool constraint as a coercion... but that seems a little inconsistent to me somehow.

[15:25] <moritz_> note that it would help with Int :$name

[15:25] <moritz_> because <3> now produces an Int

[15:25] <Juerd> Oh, signatures are going to be used for CLI arguments? Perlfect! :)

[15:26] <[particle]> so if you pass --name=True it might coerce to Bool?

[15:26] <moritz_> that's the question

[15:26] * Juerd asked about that in 2005 but the question remained unanswered :)

[15:26] <masak> a good question.

[15:26] <[particle]> but not --name=1

[15:26] <pmichaud> Juerd: oh yes, and they're multidispatch

[15:26] <masak> [particle]: why not? Bool::True == 1

[15:26] <pmichaud> but 1 is not a Bool

[15:26] <[particle]> --log-level=1

[15:27] <[particle]> --log-level=2

[15:27] <masak> rakudo: say 1 ~~ Bool

[15:27] <[particle]> it's a slippery slope

[15:27] <p6eval> rakudo 33111d: OUTPUT«0␤»

[15:27] <masak> aye.

[15:27] <[particle]> we're already guessing here

[15:27] <masak> enums are hard. :/

[15:27] <pmichaud> rakudo:  sub xyz(Bool :$x) { say $x; };   xyz(:x(1));

[15:27] <p6eval> rakudo 33111d: OUTPUT«Nominal type check failed for parameter '$x'; expected Bool but got Int instead␤in Main (file src/gen_setting.pm, line 324)␤»

[15:27] <jnthn> If it's just a bool, why not --foo = Bool::True, --foo=... = something else?

[15:28] <Juerd> --not-foo

[15:28] <pmichaud> jnthn: right now S06/S19 claim that the parsing of the arguments is based on the signature of MAIN

[15:28] <pmichaud> the problem is handling something like

[15:28] <pmichaud> $ mycmd  --switch something

[15:28] <jnthn> If MAIN is a multi, that gets more fun too. :-)

[15:28] <[particle]> jnthn: correct.

[15:29] <pmichaud> according to the current spec, if :$switch is not Bool, the above is parsed like   "$ mycmd --switch=something"

[15:30] *** Chillance left
[15:30] <jnthn> Part of me wonders if while we'd use the signature(s) of MAIN to generate usage info and so on, defining a transformation from command line arguments => capture and then letting normal dispatch take over would work out better.

[15:30] <pmichaud> whereas if :$switch is Bool, the above is parsed like "$ mycmd --switch=<True> something"

[15:30] *** Psyche^ joined
[15:30] <jnthn> pmichaud: This gets really fun if I declare

[15:30] <[particle]> i'm trying to think of a case that forcing booleans to be passed with --name or --/name (or :name or :/name) doesn't work for

[15:31] <jnthn> multi MAIN(Bool :$switch) { ... }; multi MAIN(Int :$switch) { ... }

[15:31] <jnthn> :-)

[15:31] <[particle]> because adding that constraint isn't onerous

[15:31] <pmichaud> [particle]: I think the difficulty is in trying to support   "--option xyz"   as being the same as "--option=xyz"

[15:32] *** Patterner left
[15:32] *** Psyche^ is now known as Patterner

[15:32] <pmichaud> if we eliminate that possibility, things get a lot simpler

[15:32] <[particle]> pmichaud: you mean that xyz could be an option value or an argument?

[15:32] <pmichaud> [particle]: yes, that's the way the current spec reads

[15:32] <pmichaud> we can't tell if xyz is an option value or argument without knowing the type of :$option

[15:33] <pmichaud> (and in multidispatch, :$option might have multiple types, as jnthn++ points out)

[15:33] *** pointme left
[15:33] <pmichaud> I think that perhaps   --option  should always mean    --option=TRUE

[15:33] *** __ash__ left
[15:33] <jnthn> nod

[15:33] <[particle]> yes, that's what i'm thinking about now

[15:34] <Juerd> pmichaud: --option value is very common and I'd dislike having to explain to users that a = is mandatory.

[15:34] <[particle]> yes, that too. sigh.

[15:34] <Juerd> It'd also be an upgrade blocker for Getopt::Long users

[15:34] <[particle]> de facto standard cmdline syntax suggests --option value means --option=value

[15:34] <jnthn> It feels weird to say that signatures influence how we interpret the command line arguemnts, but we also use multi-dispatch to decide which signature matches the arguments we were given.

[15:34] <pmichaud> Juerd: "--option value" is common?  hmmmm....  I'm trying to remember where I've seen that

[15:35] <[particle]> perl -e 1

[15:35] <Juerd> jnthn: That's how it's always been done with gnuish getopts, though.

[15:35] <pmichaud> that's "-option", not "--option"

[15:35] *** crazed joined
[15:35] <Juerd> perl's command line is ungnuish anyway

[15:35] <[particle]> perl --exeucute 1 # if only perl had long opts

[15:35] <pmichaud> single-hyphen means something different from double-hyphen

[15:35] <Juerd> It's execute? I reda it as eval :)

[15:35] <Juerd> s/reda/read/

[15:36] <[particle]> i can't spell either

[15:36] <pmichaud> I'm trying to remember if I've seen command line options where the double-hyphen accepts a space-separated argument

[15:36] <[particle]> i prefer --option value to mean --option=value

[15:36] <Juerd> pmichaud: ls --sort size

[15:36] <[particle]> because there's no syntactic difference between -o and --option in perl 6 cmdline

[15:36] <Juerd> pmichaud: With GNU ls.

[15:37] <Juerd> tar --file foo.tar

[15:37] <Juerd> etc

[15:37] <[particle]> every option has double dash form, and optionally has single dash form

[15:37] <pmichaud> [particle]: oh.  S06 doesn't demonstrate a single-dash form that accepts   "-e 1"

[15:38] <[particle]> hrmm, gotta consult the log for S06 on that one, it may have been removed for good reason

[15:39] * Juerd hopes it's an accidental omission

[15:39] <Juerd> Especially in the windows world it's very uncommon to leave out the space

[15:41] <[particle]> i'm thinking that Bool sigs can only be specified with -n or --name or --/name, never with equals or space then value

[15:41] <pmichaud> perhaps the best approach is for the option processor to look at a Bool constraint as a coercion, then

[15:41] <moritz_> +1

[15:41] <[particle]> then there is no ambiguity that can't be undone

[15:41] <pmichaud> moritz_: +1 to which ?

[15:41] <moritz_> pmichaud: to coercion

[15:42] <[particle]> will the coercion happen before multi selection?

[15:42] <pmichaud> it has to

[15:42] <pmichaud> because multi selection won't do it

[15:42] <pmichaud> but we still have jnthn's case, where multis could cause the same commandline to be interpreted entirely differently

[15:43] <masak> how does infix:<as> square with multi dispatch?

[15:43] <pmichaud> although I suppose the command line argument handler could equally complain about ambiguous dispatch when it tries to figure out the option meaning

[15:43] *** nihiliad joined
[15:44] <moritz_> masak: afaict it works after the dispatch

[15:44] <Juerd> pmichaud: Is type based mmd useful anyway, for cli arguments?

[15:44] <pmichaud> Juerd: it might be

[15:44] <Juerd> Essentially they're all strings...

[15:44] <pmichaud> for example, if we follow TimToady's latest <...> trickery

[15:44] <pmichaud> then --name=3  would result in   :name(3 but Str('3'))

[15:45] <masak> moritz_: that kinda makes sense. I think.

[15:45] <pmichaud> which means one could use mmd to distinguish between integers passed on the commandline and other strings

[15:45] <jnthn> masak: as doesn't play into the dispatch.

[15:45] <jnthn> masak: It's a signature binding level issue.

[15:45] <masak> oki.

[15:45] <jnthn> Which is post-dispatch.

[15:45] <jnthn> Well

[15:45] <jnthn> heh

[15:45] <jnthn> ish.

[15:45] <jnthn> :-)

[15:45] <masak> :)

[15:45] <masak> why ish?

[15:45] <jnthn> Depends if the signature needs a bindability check, but an "as" won't force one.

[15:45] <pmichaud> i.e.,   one could have     MAIN(Int :$name) { ... }    and   MAIN(Rat :$name)    and be able to dispatch based on --name=3 and --name=3/4

[15:47] <masak> pmichaud: will one have to provide escaped quotes for Str values?

[15:47] <pmichaud> masak: if one needed to distinguish a Str 3 form an Int 3 on the command line, yes.

[15:47] <masak> jnthn: could the 'as' make a bindability check fail somehow?

[15:47] <pmichaud> but that's getting pretty esoteric

[15:48] <masak> pmichaud: just thinking about how strings would be parsed.

[15:48] <Juerd> pmichaud: But you can't explicitly indicate that your 42 is supposed to be a string, then?

[15:48] <jnthn> masak: Heh. I guess if the coercion threw an exception. ;-)

[15:48] <jnthn> masak: But that's a super evil thing to do.

[15:48] <masak> jnthn: well, you know me. :)

[15:48] <jnthn> masak: Since it won't just fail the binder, it'll throw the exception back to the caller too.

[15:49] <pmichaud> Juerd: one could use  ":name('42')"

[15:49] <jnthn> That is, we'll fall out of the binder as well.

[15:49] <masak> sounds like fun.

[15:49] <pmichaud> (and would have to include the outer quotes on the command line)

[15:49] <jnthn> Well, it's the same as if a constraint throws an exception I guess.

[15:49] <pmichaud> jnthn: yes, I was about to point that out :)

[15:50] <pmichaud> I think an <as> coercion can throw an exception, but it doesn't happen by default

[15:50] <pmichaud> it's up to the coercer

[15:50] <jnthn> Anyway, I suspect coercers that want to say "oh noes wtf" should give back a Failure that will explode on use.

[15:50] <masak> jnthn: it's like constraints have a certain 'purity' to them, which expects you not to start throwing exceptions. I smell a Best Practice falling out of this.

[15:50] <jnthn> masak: Correct, and it's the same rule for coercers I suspect.

[15:50] <masak> jnthn: espectially because people have to be careful not to implicitly throw exceptions.

[15:51] <jnthn> masak: Sure, but a lot of things in Perl 6 are failsoft.

[15:51] <masak> they are. that definitely helps a lot.

[15:52] <moritz_> rakudo: say Complex.new('a', 'b').perl

[15:52] <Su-Shee> "fail save, fail soft - perl 6!" I can see it on tv!

[15:52] <p6eval> rakudo 33111d: OUTPUT«Complex.new(a, b)␤»

[15:52] <pmichaud> o_O

[15:53] <jnthn> wow

[15:53] <jnthn> That may just be a fail.

[15:53] <pmichaud> That's seriously broken.

[15:53] <moritz_> Complex doesn't do any type checks on its two slots

[15:53] <pmichaud> it should at least do coercions, though

[15:54] <moritz_> it should check for Numeric, probably

[15:54] <moritz_> which is NYI

[15:54] <pmichaud> and if not that, then it should at least .perl its re and im parts

[15:54] <pmichaud> and not just stringify them

[15:54] <pmichaud> it should probably .perl its re/im parts anyway

[15:54] <moritz_> agreed

[15:54] <pmichaud> relying on stringification for .perl is probably an anti-pattern

[15:55] <moritz_> spectesting the fix...

[15:57] *** Chillance joined
[15:57] <pmichaud> [particle]: anyway, if you come up with any ideas for resolving the boolean argument conundrum, let me know.  I may start prototyping a command line argument processor in NQP this week (will need it for the new hll compiler object)

[15:57] *** Chillance left
[15:57] *** Chillance joined
[15:58] <[particle]> my grant has me working on tests first, before the arg processor

[15:58] <[particle]> but i think those can be developed side-by-side

[15:58] <pmichaud> right

[15:58] <pmichaud> that's generally easier anyway

[15:58] <[particle]> and i have some time this week to work on an arg processor

[15:58] <[particle]> i only need to unblock one thing... i can't build rakudo

[15:59] <[particle]> this has blocked me for a few weeks

[15:59] <pmichaud> A couple of weeks ago I figured out a syntax to use for the argument processor

[15:59] <[particle]> but i'll fix it by changing platforms to ubuntu

[15:59] <[particle]> "fix" that is.

[15:59] <pmichaud> [particle]: oh, I think there should be a version written in nqp

[15:59] <pmichaud> so then it works for all of parrot, not just rakudo

[15:59] *** zloyrusskiy joined
[15:59] <[particle]> that'll work. nqp-rx.

[16:00] <pmichaud> anyway, I'll be very happy to prototype one up and then let you take over from there :)

[16:00] <[particle]> my idea was to prototype in p6, port to parrot, then rewrite in p6

[16:00] <[particle]> but nqp will fix the prototyping bill nicely

[16:00] <pmichaud> I think write one in nqp-rx, and the write another for rakudo based on the nqp-rx one

[16:00] <[particle]> yep

[16:00] <pmichaud> (but we'll keep the nqp-rx one for other compilers and tools to use)

[16:02] <pmichaud> anyway, as I said, I figured out how I think an interface should/could look, and started to write it in PIR, then said "I really want nqp-rx regexes to do this" and got back to work on nqp-rx :)

[16:02] <[particle]> :)

[16:02] <pmichaud> but then ran into the "Bool is a constraint, not a coercion" problem.

[16:02] <[particle]> i'll let the bool conundrum rattle around a bit

[16:02] <pmichaud> okay

[16:03] <pmichaud> for now I'll start with the idea that bool arguments can't have =

[16:03] <[particle]> okay

[16:03] *** jsut|work joined
[16:03] <[particle]> i think it'll become more clear by writing tests.  i like to see the syntax in action to determine how best an api should be designed

[16:04] <[particle]> so, i'll likely scribble some down

[16:12] *** REPLeffect_ joined
[16:13] *** pnate joined
[16:14] *** astrojp joined
[16:14] *** KyleHa joined
[16:18] *** wlan left
[16:21] <pmichaud> particle++  # some quick answers on S19/S06

[16:22] <moritz_> [particle]: for test writing Test::Util might be useful, which spawns another perl6 program\

[16:22] <moritz_> [particle]: though you might need to extend it a bit to allow custom options/ARGS to be passed to the script

[16:23] <pmichaud> although the more I think about it, the more it starts to feel like   introspect-and-coerce might be the better approach

[16:24] <pmichaud> or if we come up with a syntax that specifies coercion and constraint at once, that can work also.   (I'm not yet convinced the Any(Bool) syntax is going to work.)

[16:24] <moritz_> neither am I

[16:24] <jnthn> Especially given the last discussion on this had it just as sugar anyway, iirc.

[16:26] <pmichaud> pmichaud@orange:~/ng$ ./perl6 Test.pm

[16:26] <pmichaud> No applicable candidates found to dispatch to for '&infix:<=>'

[16:26] <pmichaud> okay, much more helpful.

[16:27] <moritz_> ship it!

[16:27] <moritz_> or so :-)

[16:27] <jnthn> Parrot. Learning from Rakudo. :-)

[16:28] <[particle]> moritz_++ didn't know about T:U

[16:28] <moritz_> (it's stored in t/spec/packages/)

[16:28] <moritz_> and KyleHa++ for writing it

[16:31] <pugs_svn> r28973 | lwall++ | [S06] correct $_ placeholder binding from "rw" to "ref", moritz++ 

[16:31] * moritz_ reads up on 'is ref'

[16:32] <pmichaud> I didn't think 'is ref' would be sufficient either, I need to re-read also

[16:33] <masak> I always associated 'is ref' with 'alias'.

[16:33] <jnthn> Same.

[16:33] <pmichaud> oh, it looks okay.

[16:33] <TimToady> well, it can't be rw, or you can't bind 1,2,3

[16:33] <pmichaud> right

[16:34] <moritz_> Unlike C<is rw>, the

[16:34] <moritz_> corresponding argument must already be a suitable lvalue

[16:34] <pmichaud> I know it can't be rw... but S06:2001 says that 'is ref' requires an lvalue

[16:34] <TimToady> if you modify it

[16:34] <pmichaud> okay, unclear spec

[16:34] <moritz_> right, that's what I was just looking at

[16:35] <masak> so, 'is ref' is the in-between DWIMmy cousing of 'is rw' and 'is readonly'.

[16:35] <pmichaud> 'is ref'  basically means "it's the exact same object, no aliases or proxies involved"

[16:36] <pmichaud> so you get the exact same rw-ness as the argument itself

[16:36] <masak> nod.

[16:37] <moritz_> so that part of the spec should probably read "Unlike C<is rw>, the corresponding argument must already be a suitable lvalue if an attempt is made to modify it"

[16:38] <jnthn> that means "it blows up at the point you modify it" yes?

[16:38] <moritz_> yes

[16:38] *** cotto_work joined
[16:39] <jnthn> Amusingly, that probably means that Rakudo's current impl of "is rw" is actually the correct semantics for "is ref" ;-)

[16:39] *** rfordinal3643 left
[16:40] <pmichaud> jnthn: does "is rw" do a direct bind at the moment?

[16:40] <jnthn> pmichaud: yeah

[16:40] <jnthn> :-)

[16:40] <pmichaud> yeah, that's "is ref"

[16:41] <jnthn> pmichaud: I didn't do anything for is rw because I was waiting on the rw flag to exist. ;-)

[16:41] <pmichaud> "is rw" needs to create a new container (same as readonly), set the "rw" flag and check the rw-ness of the thing it's binding to

[16:41] <pugs_svn> r28974 | lwall++ | [S06] clear up definition of 'is ref' 

[16:41] <jnthn> pmichaud: huh? why the container?

[16:41] <pmichaud> jnthn: it needs a type

[16:41] <jnthn> oh

[16:41] *** hirschnase left
[16:41] <jnthn> hmm.

[16:41] <pmichaud> sub mysub(Int $x is rw) { ... }

[16:41] <jnthn> Really?

[16:42] *** hirschnase joined
[16:42] <jnthn> Doesn't that just mean "the thing coming in must be an Int"?

[16:42] <pmichaud> "does Int"

[16:42] <jnthn> heh, netiher

[16:42] <jnthn> ACCEPTS Int. :-)

[16:42] <pmichaud> right

[16:42] <pmichaud> anyway, if I have

[16:43] <pmichaud> sub mysub($x where { $_ / 2 == 0 } is rw) { ... }

[16:43] <pmichaud> I not only have to do the check at binding time, but also for all subsequent assignments to $x

[16:43] <jnthn> orly?

[16:43] *** frodwith joined
[16:43] <jnthn> Spec reference?

[16:43] <moritz_> it's the same as

[16:43] <pmichaud> isn't it the same as    my $x where ....

[16:43] <moritz_> declaring a subset type

[16:44] <moritz_> rakudo: my $x = 3; sub f(Int $y is rw) { $y = 5; }; f($x); say $x

[16:44] <jnthn> It's not implemented like that now...

[16:44] <p6eval> rakudo 33111d: OUTPUT«5␤»

[16:44] <moritz_> rakudo: my $x = 3; sub f(Int $y is rw) { $y = 'foo'; }; f($x); say $x

[16:44] <p6eval> rakudo 33111d: OUTPUT«foo␤»

[16:44] <moritz_> rakudo: my Int  $x = 3; sub f(Int $y is rw) { $y = 'foo'; }; f($x); say $x

[16:45] <p6eval> rakudo 33111d: TIMED_OUT

[16:45] <pmichaud> jnthn: it needs to be.  Type constraints on containers in a signature need to be considered in addition to the constraints of the thing they reference

[16:45] <jnthn> pmichaud: I still want to see a spec reference for that.

[16:45] <jnthn> I don't recall reading one.

[16:46] <pmichaud> I think it falls out of the simple fact that parameters are like my-scoped variables

[16:46] <jnthn> It depends whether you interpret the type constraints in the signature as a part of the signature or also as influencing the resulting variable declaration.

[16:46] <jnthn> It isn't obvious to me that they should be both.

[16:47] <pmichaud> I see it as being no different than    my (Int $x) ....

[16:47] <pmichaud> clearly the type is influencing the variable declaration.

[16:48] <pmichaud> but we can add it as a Pm-## question

[16:48] <pmichaud> adding.

[16:48] <jnthn> Given that we already know the fact that we parse a signature there doesn't actually imply signature semantics in any wider sense doesn't really make that a sure-fire precedent.

[16:48] <pmichaud> fair enough, we'll just get clarification from the TimToady oracle

[16:48] <jnthn> Sure.

[16:49] <jnthn> Note that if we do need to implement this, it's not just setting the current constraint on the container.

[16:49] <jnthn> It's anding it with any other constraints already on the incoming thing.

[16:49] <pmichaud> right

[16:49] <pmichaud> that's what "need to be considered in addition to the..." means

[16:49] <jnthn> Which I guess we can do, but then we gotta start building up a type junction or something per rw we bind.

[16:49] <pmichaud> I figure it's just an and Junction

[16:50] <TimToady> I'm inclined towards pm++ish view, but let me think about performance a bit, and the relationship to single-assignment semantics

[16:50] <jnthn> Yeah, but do we really want to be building up that every binding?

[16:50] <pmichaud> is it that expensive?

[16:50] <pmichaud> just create a new 'and' junction with the two candidates

[16:50] <TimToady> sounds more like a derived anonymous subset type to me

[16:51] <jnthn> Well, if we approach everything as "is this individually expensive", I guess we could argue for a lot of things.

[16:51] <jnthn> Then we end up being slow overall.

[16:52] <TimToady> well, part of the reasoning for adding the constraints in multisigs is that checking is factored back into the dispatcher

[16:52] <TimToady> so doesn't need to be repeated in the body

[16:52] <TimToady> and for readonly parameters, that's the end of it

[16:52] <TimToady> rw parameters are fairly rare, actually

[16:53] <pmichaud> and creating a junction is really not that expensive

[16:53] <TimToady> rw my vars are much more common, of course

[16:53] *** zaphar_ps joined
[16:53] <pmichaud> (creating an anonymous subtype is likely a bit more expensive)

[16:54] <TimToady> well, presumably one leg of a junction can be an outer junction

[16:54] <pmichaud> right

[16:54] <jnthn> Well, true, your spec change did just make rw's more rare.

[16:54] <pmichaud> thus I'm thinking    all( $var_constraint, $arg_constraint)

[16:54] <pmichaud> where $arg_constraint could itself be a junction of constraints

[16:54] <jnthn> OTOH that means that :(Int $x is ref) and :(Int $x is rw) will have different semantics on what you can assign, unless we're going to wrap that one too.

[16:54] *** PerlPilot joined
[16:55] <pmichaud> I'm not sure about the "Int $x is ref"  case

[16:55] <jnthn> pmichaud: That'll get hilarious for deep recursion with rw parameters...

[16:55] <TimToady> well, the fact that there's a subtype is known at declaration time, so it's not anonymous in that sense

[16:55] <pmichaud> TimToady: yes, but we don't necessarily know the full details of the subtype until we have the argument we're binding with.  Or perhaps I'm misunderstanding how subtypes would work here.

[16:56] *** zloyrusskiy left
[16:56] * pmichaud aborts writing a new pm.txt question for now, since TimToady++ is engaged on the topic.  :-)

[16:56] <jnthn> TimToady: We don't know the constraints already on the container that is getting passed in.

[16:56] <jnthn> So we'd have to derive the subtype each time I guess.

[16:56] *** PerlPilot left
[16:57] *** PerlJam joined
[16:57] <jnthn> Doesn't really work out any better than the junction.

[16:58] <TimToady> the junction already has dedup logic, presumably

[16:58] <jnthn> Yeah, true.

[16:58] <jnthn> I guess it'd not get too huge.

[16:59] <jnthn> Or could be made OK.

[17:00] *** justatheory joined
[17:01] <TimToady> seems like 'is ref' doesn't commit to whether it's expecting an Int object or Scalar[Int]

[17:02] <TimToady> whereas 'is rw' requires Scalar[Int]

[17:03] <TimToady> or at least Container[Int]

[17:03] *** eternaleye left
[17:03] *** NorwayGeek left
[17:03] <pmichaud> I somehow think of  "Int $x is ref"   as being a bindability check but not a subsequent assignment check   (like what Rakudo's "is rw" is doing now)

[17:03] *** NorwayGeek joined
[17:04] <TimToady> and Scalar[Int] happens to be ACCEPTED by Int

[17:04] *** NorwayGeek left
[17:04] <jnthn> I guess that's just because the container is transparent in that case.

[17:04] <pmichaud> in particular, "is ref" isn't making a new container

[17:04] *** NorwayGeek joined
[17:05] <jnthn> pmichaud: Right. My issue is whether is rw should be making a new container also.

[17:05] <TimToady> rw is what drives autoviv

[17:05] <jnthn> That is, I'd seen is rw as is ref + rw-ness check

[17:06] <pmichaud> TimToady: so does autoviv imply that rw makes a new container?

[17:06] *** px3tado joined
[17:06] <pmichaud> (apologies if I'm missing the obvious answer)

[17:06] <TimToady> if you get a WHENCE object Scalar[Int]{ #`{stuff to insert into array/hash} }

[17:07] *** am0c joined
[17:07] <TimToady> which is what the array/hash ref returns for a non-existent element unless it knows for sure that it's only an rvalue

[17:07] <TimToady> in which case it can return the failure directly

[17:08] <TimToady> in the case of a multidimensional array you can get cascading WHENCEs

[17:08] *** NorwayGeek left
[17:09] <pmichaud> hmmm, ng is currently doing this in terms of a proxy type.  Hadn't considered the possibility of WHENCE

[17:09] *** NorwayGeek joined
[17:09] <TimToady> each of which adds the new element for that dimension

[17:09] <pmichaud> that makes good sense

[17:09] <TimToady> WHENCE *is* a proxy type, kinda

[17:09] <pmichaud> right

[17:09] <pmichaud> I see that now

[17:09] <pmichaud> cool

[17:09] <pmichaud> when we have WHENCE working again I'll convert to that :-)

[17:09] <TimToady> it's not just for lazily BUILDing role components

[17:10] <TimToady> in fact, in S12:2084 it's called an "autovivifying closure" directly

[17:11] <pmichaud> TimToady: right, I hadn't made the connection to autovivifying in a aggregate

[17:11] <pmichaud> but that makes excellent sense

[17:12] <pmichaud> anyway, 'is rw' semantics isn't something that I think we have to resolve today -- at least not for the things I'm working on

[17:13] <pmichaud> Test.pm now parses and gets to execution, failing on "Could not find non-existent sub &END

[17:13] <TimToady> another thing I'm going to have to rethink is that CANDO in packages seems a bit useless now, given we don't look in packages for multis

[17:13] *** px3tado left
[17:13] <TimToady> maybe lexical CANDO will work for that

[17:14] <moritz_> .oO( somehow CANDO always looks like the name of a nuclear reactor to me )

[17:14] <TimToady> though how that differs from a redispatching only, I'm not sure...

[17:14] <TimToady> that's DU

[17:14] <moritz_> right

[17:15] <pmichaud> not to be confused with MANDU, MANCHU, or CHOOCHOO  :-)

[17:15] <jnthn> mmmmm...mandu...

[17:15] <pmichaud> is there a canonical method for obtaining a package namespace from a type object?

[17:15] <jnthn> gah, I want Korean/Chinese food now. :-)

[17:15] <TimToady> I suspect that lexical CANDO might be a rather strong pessimization, at least for the tails of candidate lists

[17:15] <pmichaud> as in, something that I could do    TypeObject.method

[17:16] <TimToady> but the tail includes CORE

[17:16] <jnthn> TypeObject.WHO iirc

[17:17] <pmichaud> ooh

[17:17] <TimToady> so you wouldn't be able to optimize builtins

[17:17] <pmichaud> .WHO it is!

[17:17] <pmichaud> that's getting added to p6object, like, now.

[17:18] <jnthn> .oO( class Doctor { ... } )

[17:19] <pmichaud> I think I'll add .WHERE while I'm at it, too.

[17:19] <TimToady> maybe a CANDO only registers a routine to call if the normal dispatch (all the way out to CORE) fails

[17:20] <pmichaud> .WHERE will be useful for people writing nqp-rx

[17:20] <jnthn> pmichaud: Rakudo already had at least one of those two, fwiw.

[17:20] <jnthn> If not both.

[17:20] <pmichaud> WHERE

[17:20] <jnthn> (no object to them going into p6object, just mentioning)

[17:21] <jnthn> If you can find WHERE it is, you can just copy paste. :-)

[17:21] <pmichaud> I also want something like a PARROTHOW

[17:21] <TimToady> note that WHERE doesn't guarantee conversion to Int <evilgrin>

[17:21] <pmichaud> although I suppose now it's just   get_class $obj.WHO

[17:21] <jnthn> TimToady: Show me the hardware with non-integral memory addresses. :-P

[17:22] <TimToady> NUMA

[17:22] <jnthn> OK, you win.

[17:22] <jnthn> :-P

[17:23] <TimToady> .oO(I'm getting a real tongue-lashing)

[17:25] <TimToady> .(etymologically speaking, after a tongue-lashing one should be tongue-tied)

[17:28] *** Patterner left
[17:29] *** Psyche^ joined
[17:30] *** Psyche^ is now known as Patterner

[17:30] *** KyleHa left
[17:32] <TimToady> (actually, the two meanings of lash probably have different etymologies, though they're not entirely sure)

[17:33] <masak> swimming &

[17:33] <jnthn> masak: ...to Riga? ;-)

[17:34] <masak> jnthn: I'd better start now, haven't I? :P

[17:35] <masak> (hm... "hadn't I"? English is hard for us non-natives...)

[17:35] <pmichaud> "eh?"

[17:35] <pmichaud> as in "I'd better start now, eh?"  :P

[17:35] <masak> I said 'English', not 'Canadian'. :P

[17:36] <masak> & # really

[17:36] *** stephenlb joined
[17:37] <eiro> hello all 

[17:37] <takadonet> pmichaud is Canadian?

[17:37] <pmichaud> nope

[17:38] <japhb> He's Terran.  We think.

[17:38] <alester> mmm, not so sure on that.

[17:38] <japhb> Actually, nobody's completely sure.

[17:38] <alester> He said Texan, so all bets are off.

[17:38] <japhb> He could have a zipper on his forehead we just don't know about yet.

[17:38] <pmichaud> I'm American.  Or Californian.

[17:38] <pmichaud> I'm a Texas immigrant.

[17:38] <pmichaud> er, immigrant to Texas.

[17:39] <japhb> I used to work with a Swiss German Texan.  A drawl with a Swiss German accent is an amazing thing.

[17:39] <pmichaud> there are quite a few germanic pockets in Texas

[17:42] *** meppl joined
[17:42] *** dakkar left
[17:47] *** zloyrusskiy joined
[17:47] *** zloyrusskiy left
[17:47] <TimToady> I've got a few Texan pockets on some of my shirts...

[17:50] <jnthn> Ok...finally, @task done. I can probably spend the rest of the day on Rakudo. :-)

[17:55] *** xinming left
[17:56] *** pmurias left
[17:56] *** mariuz left
[17:58] *** am0c left
[17:59] *** icwiener joined
[17:59] *** cdarroch joined
[18:00] *** kidd` joined
[18:07] *** Su-Shee_ joined
[18:08] <pugs_svn> r28975 | lwall++ | [S10] install note about rapid fossilization of package CANDO section 

[18:10] <jnthn> ooh, sometimes deying the existence of sections of the spec that I didn't yet figure out how to implement does pay off...

[18:11] *** Su-Shee left
[18:13] <pmichaud> jnthn: that's been my experience :)

[18:13] <jnthn> pmichaud: What're you hacking on at the moment, out of curiosity?

[18:13] <pmichaud> END blocks

[18:13] <jnthn> (i'm just building stuff...)

[18:13] <jnthn> OK, cool.

[18:14] <jnthn> Last hurdle for Test.pm?

[18:14] <TimToady> it would be easy to install CANDOs as failovers, but overrides of core subs/methods is more problematic

[18:14] <pmichaud> (last hurdle)  might be.

[18:14] <jnthn> TimToady: I'd been sorta expecting it was going to be a failover mechanism. Hmm.

[18:14] <pmichaud> compiling Test.pm is a bit slow, so we may need some profiling soon

[18:14] <jnthn> pmichaud: Aww. OK.

[18:15] *** quietfanatic left
[18:15] <pmichaud> anyway, it's something that we can easily sic the parrot profilers on :)

[18:15] <jnthn> Yes.

[18:15] <jnthn> At least we have a profiler now!

[18:15] <pmichaud> especially since rakudo-ng is not so big that it takes hours to profile

[18:15] <jnthn> Yes.

[18:15] <pmichaud> (and profiling nqp is equally useful)

[18:15] <jnthn> Our startup time is kinda nice.

[18:15] <jnthn> Well

[18:15] <jnthn> Compared to master.

[18:16] <jnthn> I wonder how well we can keep it down.

[18:16] <jnthn> OK, what do you need most from me?

[18:16] <pmichaud> we'll figure out how to keep it manageable

[18:16] <moritz_> by not doing more stuff? ;-)

[18:16] <jnthn> If the answer is "nothing", I'll work on package decls.

[18:16] <pmichaud> I don't have anything I need most at the moment.  my guess would be class decls

[18:16] <jnthn> Oh, did you want the Code classes putting back in too?

[18:16] <pmichaud> oh, that would definitely be useful, yes.

[18:17] <pmichaud> either of those would be great

[18:17] <jnthn> OK, here's what I'll do.

[18:17] *** Su-Shee_ left
[18:17] <jnthn> I'll scribble a plan for what I want to do with package decls.

[18:17] <jnthn> Then at least the mentally challenging part is done before it gets much later into the day. :-)

[18:17] <pmichaud> wfmvm  (very much)

[18:17] <jnthn> Then I'll do the code types, and then the package delcs bits, which by then should just be a case of writing code. :-)

[18:17] *** Su-Shee joined
[18:25] <jnthn> pmichaud: ouch, something seems to have caused a regression in 07-simple-multisubs.t

[18:25] <pmichaud> possible

[18:26] <pmichaud> I don't think I committed any of my experiments last night, but it's possible I did

[18:26] <jnthn> it's a simple test file, it should be easy to work out why it's broken

[18:26] <jnthn> I'll look in a moment.

[18:26] <pugs_svn> r28976 | lwall++ | [eigenstates.t] fix parsefail 

[18:26] <pmichaud> yeah, afaict I left the <signature> stuff alone.

[18:27] <pmichaud> I changed a few other things dealing with blocks, though.

[18:27] <pmichaud> but I don't think I touched anything that impacts signatures

[18:27] <pmichaud> (although obviously I did :-)

[18:28] <jnthn> The multi generation still looks correct.

[18:28] <pmichaud> perhaps something else changed somewhere, then

[18:29] <jnthn> Hmm, the sig doesn't look wrong.

[18:30] <jnthn> oh hmm

[18:30] <jnthn> oh f**k

[18:31] <jnthn>     .lex "$arg1", $P72

[18:31] <jnthn>     .lex "$arg2", $P73

[18:31] <jnthn> I didn't put back the vivification of the parameter lexicals.

[18:31] <jnthn> Which is fine in theory for now.

[18:32] <jnthn> But in practicel Parrot-- is probably giving those two the same underlying register.

[18:32] <jnthn> Since $arg1 and $arg2 are ending up with arg2's value.

[18:32] <jnthn> :-|

[18:32] *** KyleHa joined
[18:32] <pmichaud> oh, I noticed that <default_value>  always ends up generating a closure

[18:32] <pmichaud> does it have to be that way?

[18:32] <jnthn> Only if there's a default value.

[18:33] <pmichaud> yeah, but having a closure for every    $x = 4   seems awfully icky

[18:33] <jnthn> It shouldn't generate anything if there's not.

[18:33] <pmichaud> the previous version did it w/o closures

[18:33] <jnthn> It needs to be a closure.

[18:33] <jnthn> Not since the new binder landed.

[18:33] <jnthn> You can't really avoid it.

[18:33] <jnthn> Well, not easily...

[18:33] <jnthn> I guess if it's just a PAST::Val we could store that directly in the signature...

[18:33] <TimToady> you can presumably optimize away the outer closure if the inside is constant

[18:34] <jnthn> Yeah

[18:34] <jnthn> I guess could do that.

[18:34] <jnthn> Well, optimization later...

[18:34] <pmichaud> it needs to be a closure because we have to do the binding checks after binding the defaults...?

[18:35] <jnthn> It needs a little care to make sure that :($x = { ... }) doesn't end up doing the wrong thing.

[18:35] <pmichaud> well, sure, but in that case we already have a closure

[18:35] <jnthn> pmichaud: If it's not a literal value, it needs to be a closure so the binder can run the code.

[18:35] <jnthn> pmichaud: Well yes but we shouldn't run it then.

[18:35] <jnthn> :-)

[18:35] <pmichaud> and the binder has to run the code because...

[18:35] <jnthn> ...what else is going to?

[18:36] *** mberends joined
[18:36] <pmichaud> previously it was being done as the prologue of the subroutine

[18:36] * jnthn isn't really understanding where this is going

[18:36] <jnthn> Yes, apart from we unpack the args ourselves now.

[18:36] <jnthn> Also it was kinda wrong-ish.

[18:36] <pmichaud> well, as far as default values is concerned, we were doing that level of unpacking ourselves also

[18:37] <jnthn> Anyway, we can optimize it for literals later on.

[18:37] <pmichaud> okay

[18:37] <jnthn> Before we were doing two passes over the sig and handling some aspects of the binding in one phase and some in another.

[18:37] <jnthn> Whereas really the signature is menat to be bound left to right.

[18:38] <pmichaud> you mean bound and checked

[18:38] <pmichaud> or you're including checking as part of binding

[18:38] <jnthn> Yes.

[18:38] <pmichaud> okay

[18:38] <pmichaud> I agree that's different

[18:38] <jnthn> What I'm trying to get at is, in ($a, $b) we need to do all the wrok for $a and then the work for $b really.

[18:39] <pmichaud> yes, okay, np

[18:39] <jnthn> Since if the binding of $a somehow affects it, and we use it in $b's default value...

[18:40] <pmichaud> that's the way it worked pre-binder as well, except that the typechecks were performed all at the end instead of after each argument

[18:40] <pmichaud> at least, that's the way I had imagined it working

[18:41] <pmichaud> anyway, if we optimize the constant case later, I'm happy

[18:41] <jnthn> Well, the issue is that type checks maybe aren't just checks, if you have a modifying constraint.

[18:41] <pmichaud> right

[18:41] <jnthn> But bigger deal was we were applying context in the second stage.

[18:42] <pmichaud> it's the same sort of issue we have with initializing attributes, btw

[18:42] <jnthn> Yeah, they need to be done in order.

[18:42] <pmichaud> so if we could somehow use the signature binder to initialize our attributes.... that migth be a big win

[18:42] <jnthn> ooh, evil.

[18:42] <jnthn> Kinda in an amusing way

[18:42] <jnthn> Given signatures already support attributive parameters ;-)

[18:42] <pmichaud> :($!a, $!b, $!c) := @_;

[18:42] <jnthn> ooh

[18:42] <pmichaud> or actually := %_

[18:42] <jnthn> Hmmm...mmm... :-)

[18:43] <pmichaud> then BUILD and new become much less expensive :-)

[18:43] <jnthn> Like!

[18:43] <pmichaud> and we just keep a signature for the class that we use in the binding

[18:43] <jnthn> Well yes, if you do it as :(:$!a, :$!b, :$!c) you can just have a hash over there on the right. :-)

[18:43] <pmichaud> and has declarations just build the signature object

[18:44] <jnthn> Mmm.

[18:44] * jnthn updates his notes

[18:44] <pmichaud> and their default values are just the same default values that we use in a signature bind, and constants can be optimized but everything else is a closure

[18:44] <pmichaud> okay, WIN

[18:44] <jnthn> Well, nearly.

[18:44] <jnthn> We have a slight issue.

[18:45] <jnthn> In that if a BUILD did init the attribute, we can't go and stomp on it with a default.

[18:45] <pmichaud> (if the caller did supply the parameter, we can't go stomp on it with a default)

[18:45] <jnthn> That's a bit different though.

[18:45] <pmichaud> why?

[18:46] <pmichaud> oh, I think I see

[18:46] <pmichaud> still, I think it can be handled

[18:46] <jnthn> class Foo { has $!a; has $!b = 42; has $!c; submethod BUILD { if moon_phase_check { $!b = 42 } } }

[18:47] <jnthn> oh fail

[18:47] <jnthn> class Foo { has $!a; has $!b = 42; has $!c; submethod BUILD { if moon_phase_check { $!b = 41 } } }

[18:47] <pmichaud> when do the attributes get initialized there?

[18:47] <jnthn> Foo.new() # $!b should sometimes end up as 41

[18:47] <pmichaud> i.e., relative to BUILD

[18:47] <jnthn> S12 says something like "if the BUILD method init'd it, we don't update it"

[18:47] <pmichaud> right, but when does that happen?

[18:48] <jnthn> Post-BUILD.

[18:48] <jnthn> We call a custom BUILD if there is one.

[18:48] <pmichaud> so, don't initialize any attributes that are non-null

[18:48] <jnthn> heh heh

[18:48] <jnthn> Well, no, not non-null I guess.

[18:49] <jnthn> Because $!b = 42 # $!b really best not be null, but rather an empty scalar

[18:49] <pmichaud> we can always check it for emptiness, same as we have to do for  @Foo::bar = 5

[18:49] <jnthn> Yeah, true.

[18:49] <jnthn> Then non-null works.

[18:49] <pmichaud> or let it default to a scalar with a WHENCE

[18:49] <pmichaud> (that then does the binding)

[18:49] <jnthn> Oh, that's interesting.

[18:50] <pmichaud> or we could initialize attributes to PMCs that mean "I'm not initialized yet"

[18:50] <jnthn> Or that.

[18:50] <pmichaud> seems like there are a lot of possibilities.  

[18:51] <jnthn> Yeah, it's just picking the best / most efficient one. :-)

[18:51] <pmichaud> but having the binder take care of defaults on attributes just feels like a huge win

[18:51] <pmichaud> because it replaces our slowish code with fastish code for object creation/initialization

[18:52] <jnthn> Yeah, agree.

[18:52] *** SmokeMachine joined
[18:52] <jnthn> Plus whenever we optimize the binder, that gets faster too.

[18:52] <pmichaud> right

[19:00] <pmichaud> bbiab

[19:14] *** lollan joined
[19:19] *** jferrero joined
[19:20] <pmichaud> (b)

[19:22] * pmichaud switches venues

[19:23] <pmichaud> it's mind-bogglingly beautiful weather outside today, so I'm working outside.

[19:23] <pmichaud> (coding, yes, but at least outside)

[19:28] *** abra joined
[19:28] <zaslon> lolpmichaudhazblogged! pmichaud++ 'Failure()<0xb53b19a8>': Failure()<0xb53b0bd4>

[19:29] <jnthn> ...orly?

[19:30] <pmichaud> I have no clue.

[19:30] <jnthn> Apparently if you did, your post was a failure in more than one way. ;-)

[19:30] <zaslon> lolpmichaudhazblogged! pmichaud++ 'Hague grant work: the new regex engine and NQP': http://use.perl.org/~pmichaud/journal/39779?from=rss

[19:31] <jnthn> btw, envious of the outside coding.

[19:31] <jnthn> Also, I think I have a way forward on package decls that I don't hate too much.

[19:31] *** lichtkind joined
[19:31] <pmichaud> yeah, about 22degC here.  No wind.

[19:31] <jnthn> ooh, nice.

[19:31] <pmichaud> well, just slight breeze

[19:31] <pmichaud> no clouds

[19:32] *** Bzek left
[19:32] <pmichaud> sun is autumn sun so it's not blindingly bright

[19:32] <jnthn> Texas. Perfect weather, a few days a year. ;-)

[19:33] <jnthn> Here it's already winter, practically.

[19:33] <pmichaud> This year has been exceptional weather, at least for me

[19:34] <pmichaud> cold weather from last winter lasted until late may, got hot over the summer but only for a short period of time, we're back to mild weather here in autumn, and lots of rainfall in Sep + Oct

[19:34] <jnthn> Wow

[19:34] <jnthn> That almost sounds nice. :-)

[19:34] <jnthn> Just need to escape during the really hot bit. :-)

[19:35] <jnthn> OK, I've got enough decided that I'm going to go ahead and implmenet it. :-)

[19:35] <pmichaud> \o/

[19:35] <jnthn> But after code blocks.

[19:35] <pmichaud> wait till you see what I've got :)

[19:35] <pmichaud> (it'll be another hour or two)

[19:35] <jnthn> Oh man, the suspense!

[19:36] <jnthn> I'm actually making an attempt at defining how people can (later) do custom meta-classes, and building our package support in that same way.

[19:36] <moritz_> regex assertion not terminated by angle bracket at line 152, near "($*IMPLICI"

[19:36] <pmichaud> moritz_: need to update nqp-rx, probably

[19:36] <jnthn> moritz_: ENQPRXTOOOLD

[19:36] <jnthn> Yes, that fixed the same error for me.

[19:37] *** jferrero left
[19:37] <pmichaud> I need to figure out a good way to get revision numbers into nqp-rx.  I'm still thinking "$release.$commitcount"

[19:37] <jnthn> So once there's a way to derive a slang, and add a new scope_declarator, we'll be in business. :-)

[19:38] <jnthn> Even better, I'm arranging it as something I'll be able to add in docs/, where everyone can ignore it. ;-)

[19:39] <jnthn> OK, code types and dinner cooking now...

[19:39] *** pyrimidine joined
[19:39] <jnthn> oh, and apparently a new Parrot.

[19:40] * pmichaud just realizes that with the vivify opcode he can simplify a ton of his other code

[19:41] <pmichaud> I guess I need to do vivify next :-)

[19:41] *** abra left
[19:43] <pmichaud> actually, I think I'll write it now

[19:46] <pmichaud> I guess there's not a way to have static functions in a *.ops file?

[19:47] <jnthn> pmichaud: yes

[19:47] <pmichaud> yes there's not a way, or yes it can be done?

[19:47] <jnthn> I think just put it between BEGIN_OPS_PREAMBLE and END_OPS_PREAMBLE

[19:48] <jnthn> And it should work fine.

[19:48] <pmichaud> ohhh

[19:48] <pmichaud> okay

[19:48] <pmichaud> I see

[19:48] <jnthn> afaik that code is just grabbed and shoved as-is into the generated C file.

[19:52] *** TimToady sets mode: +vv hugme iblechbot

[19:52] *** TimToady sets mode: +vvvv ilbot2 ilogger2 IRSeekBot lambdabot

[19:52] *** TimToady sets mode: +vvvv lisppaste3 p6eval phenny pugs_svn

[19:54] *** TimToady sets mode: +v zaslon

[19:56] * diakopter sortof awakens

[19:57] *** alester left
[19:59] <mberends> hi diakopter

[20:00] <diakopter> mberends: howdy

[20:01] <diakopter> E2MANYIDEASGOODANDBAD

[20:01] <mberends> heh

[20:04] *** xp_prg joined
[20:18] *** masak left
[20:20] *** pyrimidine left
[20:23] <pugs_svn> r28977 | kyle++ | [t/spec] fudge junction test Rakudo no longer runs 

[20:30] *** nihiliad left
[20:33] *** nihiliad joined
[20:34] *** TSa joined
[20:36] <TSa> HaloO

[20:36] <mberends> Oh HaI

[20:36] <PerlJam> greetings

[20:37] <TSa> how does one make an object an lvalue?

[20:37] <TSa> I mean one that is assigneble in an is ref param

[20:38] <moritz_> I'd like to know that too

[20:39] <TSa> Ohh

[20:43] <jnthn> is ref doesn't enforce assignability anyway - is rw is what does the "can we assign to it" check.

[20:44] <jnthn> I know what the "in Rakudo" answer to flag something rw, but I don't know the "in Perl 6" one.

[20:44] *** Su-Shee left
[20:45] <TSa> Can we write an infix;<=> ala the C++ assignment op and than autogenerate e,g, ++ from it?

[20:46] <moritz_> I somehow don't think overloading infix:<=> will be the way to go

[20:46] <moritz_> we discussed FETCH and STORE methods instead

[20:46] <moritz_> where STORE is called by infix:<=>

[20:48] <jnthn> Oh, if it's "how do we implement something that is assignable" - yes, FETCH and STORE.

[20:49] <jnthn> I'd understood the question more as, how do we flag something as being valid for assignment.

[20:49] <moritz_> how

[20:49] <moritz_> s/how/oh/

[20:50] <moritz_> maybe I just projected my own questions onto TSa's :)

[20:54] <jnthn> :-)

[20:55] <TSa> Well, now :($x is ref) is very much like :(Object $x)

[20:56] <jnthn> ...erm.

[20:56] <jnthn> No.

[20:56] <jnthn> :(Object $x) means "$x is readonly, and has an Object type constraint on it"

[20:57] <jnthn> :($x is ref) means "$x has whatever the default type constraint is depending on how the signature is used, and is exactly the thing that is passed"

[20:57] <TSa> yes, but you can call any modifying method on it

[20:57] <jnthn> Yes, but you can't assign to it.

[20:58] <TSa> but isn't STORE just another method?

[20:58] <jnthn> It's a method on the container rather than the value.

[20:58] *** simcop2387 left
[21:02] *** simcop2387 joined
[21:04] <TSa> So you can implement STORE in a class but it is called only when a param is ref?

[21:18] * PerlJam idly wonders if #parrot is making progress

[21:18] *** NorwayGeek left
[21:18] <jnthn> PerlJam: Frankly, it sucks that those of us who have experience implementing languages on Parrot have to have arguments like these to get things we need in place, thus blocking us from actually getting stuff done.

[21:18] <jnthn> *like this

[21:19] *** synth joined
[21:20] <PerlJam> jnthn: indeed.  From an interested-party-watching-on-the-sidelines, I've seen virtually this same discussion at least 3 times (maybe more)

[21:20] <PerlJam> not exactly the same, but the same nonetheless

[21:20] <jnthn> Yeah. Some days Parrot is as much a liability and an asset.

[21:20] <jnthn> s/and/as/

[21:24] <diakopter> as is every dependency with high fork-aversion...

[21:25] <TSa> Was that interested-party-watching-on-the-sidelines me? Sorry if I disturbed the flow of things.

[21:26] <PerlJam> TSa: no, no, I was referring to chatter in another channel that's intimately related to language dev with parrot.

[21:26] <PerlJam> (and since Rakudo is parrot-based it's relevant here obliquely :)

[21:27] <PerlJam> jnthn: perhaps you can answer this since pmichaud is occupied:  what's the minimum neede for an "empty" compiler using parrot + nqp-rx?

[21:28] <jnthn> "minimum need"?

[21:28] <moritz_> parrot and nqp-rx ;-)

[21:28] <jnthn> If you just mean what do I need to download and install, just those two, yes. :-)

[21:28] <PerlJam> moritz_: :-P  

[21:28] <jnthn> I'm suspecting you maybe meant something else, but I don't quite get what, sorry.

[21:29] <PerlJam> jnthn: If I were building a compiler, and I have an ueber simple grammar and actions and I can compile them with nqp, what else is needed to make a compiler out of it?

[21:30] *** hercynium joined
[21:30] <jnthn> PerlJam: A file like Compiler.pir that subclasses the HLL class, and is just the little bit of startup code/entry point.

[21:30] <jnthn> PerlJam: Soon you'll be able to do that in NQP too.

[21:30] <jnthn> PerlJam: And beyond that, just any language built-ins you have.

[21:31] <PerlJam> maybe I'll go write a small language later and then come back with more specific questions about stuff I can't get to work  ;)

[21:31] <jnthn> (I refer to Compiler.pir in src/Perl6/Compiler.pir btw)

[21:31] <jnthn> That one contains a bunch of Rakudo bits that you won't need - the NQP equivalent file is probably much simpler.

[21:33] <jnthn> PerlJam: Yes it's *way* simpler in NQP.

[21:33] <jnthn> http://github.com/perl6/nqp-rx/blob/master/src/NQP/Compiler.pir

[21:33] *** hirschnase left
[21:34] <PerlJam> ah, I think that points me in a useful direction.

[21:34] <PerlJam> thanks.

[21:36] <jnthn> diakopter: Saying "let's fork!" is simple. Making that lead to anything that is an overall win is far from that, and needs a lot of energy and resources.

[21:37] <KyleHa> jnthn: Are you talking about software?

[21:38] <jnthn> KyleHa: lol!

[21:38] *** masak joined
[21:38] <jnthn> KyleHa: I actually was this time... ;-)

[21:39] <PerlJam> I know when I said to my wife "let's fork!", she always wanted to spoon afterwards  ;>

[21:40] <TimToady> then there are the husbands that get knifed afterwards...

[21:44] <diakopter> or beforehand

[21:45] <jnthn> Or during.

[21:45] <masak> or just in general.

[21:45] <TimToady> PerlJam: you should try "Let's spork!" and see what happens.

[21:45] <PerlJam> We used the knife about 9 months later on the umbilical cord

[21:45] <diakopter> jnthn: I wasn't making a comment as to whether I thought a fork was a good idea... but I was pointing out the level of fork aversion (and you pointed out one of the reasons)

[21:47] * jnthn can't quite bear to watch #parrot right now

[21:47] <PerlJam> someone needs to use a knife to cut out some of the emotion and figure a better way to communicate

[21:47] * diakopter considers looking at it on perlgeek.de

[21:47] <masak> jnthn: could you please summarize the situation? I'm coming in late.

[21:48] <diakopter> oh.  started off with llvm

[21:49] <jnthn> masak: pmichaud++ wants a couple of new opcodes in Parrot that will make some very, very common operations we do both much shorter in PIR and a tad faster the boot.

[21:49] <masak> nod.

[21:49] <jnthn> It'll make code-gen massively easier and be a minor performance win.

[21:49] <masak> I think I've read about those opcodes.

[21:49] <diakopter> pir_eval?

[21:49] <jnthn> allison is getting in the way, and showring a massive fail of understanding between binding and assignment along the way.

[21:50] <jnthn> As well as proposing something that would create more problems we don't already have as a "solution" that would actually be completely useless for us.

[21:50] <masak> ouch.

[21:51] *** xp_prg left
[21:51] *** __ash__ joined
[21:51] *** PZt left
[21:53] *** pnate2 joined
[21:59] *** TSa left
[22:06] *** pnate left
[22:10] <Juerd> http://toons.gotblah.com/archive/geekandpoke/091102-22:01.jpg

[22:10] <jnthn> lol

[22:10] <masak> ceci n'est pas une pipe.

[22:11] <pmichaud> I totally cannot believe how much time I feel like I've wasted on talking about lvalue semantics

[22:11] <pmichaud> I totally cannot believe that allison had no clue how scalar assignment works in Perl (5)

[22:12] <TimToady> we all have our blind spots from time to time

[22:12] <PerlJam> being a dispassionate observer, I couldn't believe it either, but if you accept it, perhaps you can see where she is coming from? 

[22:12] <pmichaud> thanks, good perspective.  I've certainly had mine.

[22:13] <jnthn> pmichaud: Yes, it's silly.

[22:13] <jnthn> And frustrating.

[22:14] <pmichaud> PerlJam: I think I can see where she's coming from.  What's bothersome is how long it's taken me to convince allison that there's a problem.

[22:14] <pmichaud> my comments (and others') have often been handwaved away with "you don't understand, we already support this"

[22:14] <jnthn> The lack of understanding of assignment sematnics vs binding semantics is probably part of what the rest of the mis-understanding comes from.

[22:14] <PerlJam> Pick some other, non-perl languages to illustrate the problem and perhaps the multiple examples will trigger whatever part of her brain that needs triggering.

[22:14] <pmichaud> the python example was helpful

[22:15] <pmichaud> but I'm having trouble coming up with languages that don't have these particular semantics, at least somewhere

[22:15] <jnthn> pmichaud: PIR? ;-)

[22:15] <PerlJam> so maybe that's allison's problem.  This is only a problem for perl and no other langauge that parrot will support.

[22:15] <PerlJam> (that's how she might see it)

[22:16] <jnthn> pmichaud: btw, I'm getting on with the code types stuff.

[22:16] <pmichaud> jnthn: even PIR has this semantic, if you leave PMCs

[22:16] <jnthn> pmichaud: Yes, I know. I wsan't being entirely serious. :-)

[22:21] *** lollan left
[22:38] *** pnate joined
[22:38] *** xabbu42 joined
[22:45] *** lichtkind left
[22:50] <sjohnson> jnthn: http://www.xkcd.com/627/

[22:51] *** pnate2 left
[22:52] *** KyleHa left
[22:53] <masak> phew. 28 days left. :)

[22:55] <zaslon> lolmasakhazblogged! masak++ 'November 2 2009 -- fighting servers and giant squids': http://use.perl.org/~masak/journal/39833?from=rss

[22:56] *** pnate2 joined
[23:00] *** Whiteknight joined
[23:01] *** PZt joined
[23:03] <jnthn> pmichaud: For when you're back - I've put in the code to wrap subs in Perl 6 code objects. Regexes shouldn't be so hard to put back now. Let me know of any problems.

[23:07] <jnthn> Also, the regression in 07-simple-multi-subs.t was what I feared. And it's also fixed.

[23:08] <pmichaud> jnthn++ # yay, a bright spot in my afternoon

[23:08] <jnthn> masak: Nice post. :-)

[23:09] <jnthn> pmichaud: Happy I can provide one. 

[23:09] <masak> thanks. lots of gory details today.

[23:09] <masak> jnthn: your new binder keeps finding new bugs in my code. :)

[23:09] <jnthn> masak: Heh. The old binder was so fail.

[23:10] <masak> so is my code. :/

[23:10] <jnthn> Well, it's an easy issue to fix.

[23:11] *** pnate left
[23:11] <masak> yes, luckily.

[23:11] <jnthn> And happily, not too bad an error. :-)

[23:12] <masak> indeed. short and to the point.

[23:14] <jnthn> "I'm very sorry to report that you failed to pass a required named parameter. The missing named parameter is called 'projects-dir'. You can rectify this situation by passing it."

[23:14] <jnthn> ...nah, it can stay short and to the point. :-)

[23:14] <moritz_> you forgot to start with "Good $localtime Ladies and Gentlement" ;-)

[23:14] <masak> jnthn: :)

[23:15] <masak> now I'm going home to study carlins++' rssbot to see if I can use code from it to implement http://gist.github.com/189041

[23:15] <jnthn> moritz_: Where we compute $localtime based on the current localtime?

[23:15] <jnthn> ;-)

[23:15] <moritz_> sure.

[23:16] <jnthn> masak: wow, that's...beautiful...

[23:16] <masak> jnthn: it's just an idea. :)

[23:16] <jnthn> Yes, but if you can make it work... :-)

[23:16] <masak> we'll see.

[23:16] *** pnate joined
[23:16] <masak> I'd like to have something like that.

[23:17] <masak> anyway, sleep.

[23:17] <masak> good night, #perl6.

[23:17] <masak> see y'all tomorrow.

[23:17] <diakopter> 'night

[23:17] *** masak left
[23:23] *** iblechbot left
[23:29] *** pnate2 left
[23:32] *** xinming joined
[23:33] *** __ash__ left
[23:43] *** pnate2 joined
[23:47] <japhb> Wow, masak's IRC client idea really is beautiful.

[23:49] <jnthn> japhb: Yeah, it'd make writing IRC clients like, so easy.

[23:55] *** pnate left
[23:55] *** Exodist joined
[23:56] *** bpetering joined
