[00:00] *** payload2 joined
[00:00] *** payload left
[00:01] *** payload1 left
[00:03] *** DemoPhreak is now known as DemoFreak

[00:03] *** bacek left
[00:07] *** meppl joined
[00:16] *** Entonian joined
[00:19] <jnthn> my word, I can't believe the YAPC::EU schedule is out already.

[00:24] *** jhuni left
[00:34] *** eternaleye left
[00:36] <meppl> good night

[00:38] *** meppl left
[00:40] *** DemoFreak left
[00:50] *** dukeleto left
[00:52] *** dukeleto joined
[01:04] *** yary joined
[01:04] <yary> hello all- I was trying to search the rakudo tracker, but I get a 500 server error

[01:04] <yary> is it down, or is it me?

[01:04] <yary> can't get to http://rt.perl.org/rt3/Public

[01:05] *** dukeleto left
[01:12] <yary> ... a web search turned up the bug I hit so don't need to get to the tracker at the moment, still someone ought to poke it.

[01:16] *** sri_kraih_ left
[01:25] *** eternaleye joined
[01:29] <pugs_svn> r26610 | lwall++ | [camelia] some smoothing and de-linefication

[01:36] <pugs_svn> r26611 | lwall++ | [p6proj] update camelia

[02:08] *** hercynium joined
[02:11] *** dukeleto joined
[02:12] *** PhatEddy left
[02:17] *** Kisu left
[02:17] *** Kisu joined
[02:23] *** nihiliad joined
[02:27] *** dukeleto left
[02:30] *** japhb left
[02:35] *** Whiteknight left
[02:47] *** bacek joined
[02:49] <TimToady>  /e

[02:49] *** les_ joined
[02:51] *** les left
[02:51] *** les_ is now known as les

[02:53] *** Limbic_Region left
[02:55] *** M_o_C left
[03:03] <pugs_svn> r26612 | lwall++ | [camelia] add pdf version

[03:07] *** Casan left
[03:08] *** dukeleto joined
[03:12] *** justatheory left
[03:12] *** dukeleto left
[03:18] *** dukeleto joined
[03:19] *** jhuni joined
[03:32] *** hcchien left
[03:32] *** clkao left
[03:32] *** Entonian_ joined
[03:34] *** Entonian left
[03:37] * diakopter pictures an onion-camel cocooning in a chrysalis

[03:37] *** orafu left
[03:37] *** orafu joined
[03:42] <s1n> isn't there a perl social room? i thought it was like #perlsoc or some such

[03:44] *** japhb joined
[03:49] *** dukeleto left
[03:55] *** clkao joined
[04:11] *** mikehh_ joined
[04:17] *** km2_ left
[04:18] <pugs_svn> r26613 | lwall++ | [p6proj] smaller top wings on camelia

[04:19] *** yary left
[04:20] <pugs_svn> r26614 | lwall++ | [camelia] squarified to match favicon aspect better and enhance face

[04:27] *** mikehh left
[04:33] <pugs_svn> r26615 | lwall++ | [t] deduping, \c[1,2,3] tests

[04:33] <pugs_svn> r26615 | lwall++ | [p6-proj] make p6-proj link to pdf instead of svg

[04:33] <pugs_svn> r26615 | lwall++ | [STD] improvements to enum parsing/faking

[04:38] *** alester joined
[04:52] *** Infinoid joined
[04:52] *** dalek left
[04:52] *** dalek joined
[04:56] *** dukeleto joined
[04:59] *** hercynium left
[05:01] <diakopter> a bipedal insect

[05:01] <skids> some meany pulled off her other legs

[05:01] <diakopter> ouch

[05:02] <diakopter> now that she doesn't have legs on which to land, she'll be forced to fly forever.

[05:12] *** mikehh_ is now known as mikehh

[05:14] *** dukeleto left
[05:16] <pugs_svn> r26616 | lwall++ | [p6proj] debug the right margin

[05:16] <TimToady> they're there, but behind the front legs

[05:18] <TimToady> you realize this means that Perl 6 can never be fully debugged...

[05:21] *** frodwith_ joined
[05:23] *** xinming_ joined
[05:30] *** frodwith left
[05:31] * skids didn't want to be the one to draw that association :-)

[05:33] *** Kisu left
[05:33] <TimToady> Perl 6 will be beautiful, but not perfect. :)

[05:33] *** Kisu joined
[05:36] *** frodwith_ left
[05:39] *** xinming left
[05:39] <Infinoid> thus guaranteeing job security :)

[05:58] *** jhuni left
[06:04] <skids> median runstats for INITIAL_BUCKETS settings in hash.c (on my system YMMV)

[06:04] <skids> 16 19.21user 0.16system 0:21.25elapsed 91%CPU 28342minor pagefaults (default)

[06:05] <skids>  8 18.94user 0.16system 0:21.06elapsed 90%CPU 27677minor pagefaults

[06:05] <skids>  4 18.86user 0.16system 0:20.87elapsed 91%CPU 27285minor pagefaults

[06:05] <skids> but setting it to 4 exposes a race condition

[06:06] <skids> (this for a script that does little hashing perl side, so mostly backend hash use)

[06:25] *** cbk joined
[06:26] *** nihiliad left
[06:27] <cbk> how can i get user input from the keyboard in perl6?  "= =$*IN" doesn't seem to work for me...?

[06:30] *** skids left
[06:32] *** dukeleto joined
[06:37] *** Entonian_ left
[06:37] <eternaleye> cbk: the '=' prefix operator is dead, use $*IN.get

[06:38] <eternaleye> cbk: Also, there's the 'prompt' function. It takes a string argument, puts it on the console, and returns a line of user input.

[06:38] <pugs_svn> r26617 | lwall++ | [t] warning suppression

[06:43] <cbk> @eternaleye Thanks I will try that, In the future, where can I go to look this type of info up on my own?

[06:43] <lambdabot> Unknown command, try @list

[06:51] <TimToady> it's buried down in http://perlcabal.org/syn/S32/IO.html, but mentioned elsewhere in the synopses

[06:51] <TimToady> http://perlcabal.org/syn is the overview of the specs

[06:51] <TimToady> they live in pugs/docs/Perl6/Spec, so if you have the repo, you can grep it

[06:53] <TimToady> but this particular thing only changed a couple weeks ago, so is still non-obvious

[06:53] *** japhb left
[06:54] *** japhb joined
[06:54] <Matt-W> jnthn++ - hurrah for better enums

[06:55] *** xinming_ left
[06:58] *** xinming joined
[06:58] <cbk> @TimToday: Thanks for the links.

[06:58] <lambdabot> Unknown command, try @list

[07:01] <TimToady> don't need the @, it just confuses lambdabot

[07:01] <cbk> ok

[07:02] <TimToady> and also suppresses irssi hilighting, as it happens

[07:02] <TimToady> the @ just marks channel ops

[07:04] *** alester left
[07:05] <cbk> if prompt is a function, then could I do this (and have it work!)   $input.prompt

[07:06] <TimToady> there's no failover from methods to functions, or vice versa

[07:06] <TimToady> if that's what you're asking...

[07:08] <TimToady> wrt prompt, generally there's only one sensible place to prompt anyway...

[07:08] <TimToady> I suspect that's why there's only the function

[07:11] <cbk> well all I want to do is have a user type in there name and assign it to my $input var! the $*IN did not work?

[07:12] <TimToady> my $input = prompt("name: ")

[07:14] <TimToady> or print 'name: '; my $input = $*IN.get;

[07:19] <cbk> COOL!  thanks TimToday!  My faith in Per6 has been restored!

[07:19] <cbk> night

[07:19] <TimToady> good night

[07:19] *** cbk left
[07:23] <TimToady> zzz &

[08:16] *** orafu left
[08:16] *** orafu joined
[08:35] *** DemoFreak joined
[08:35] *** meppl joined
[09:06] *** iblechbot joined
[09:10] *** bacek_ joined
[09:12] *** bacek left
[09:29] *** c9s_ joined
[09:30] *** c9s left
[09:36] *** meteorjay joined
[09:39] *** M_o_C joined
[09:43] *** c9s_ is now known as c9s

[09:53] *** payload joined
[09:53] *** payload2 left
[09:58] *** sri_kraih joined
[10:00] *** cognominal left
[10:04] *** cognominal joined
[10:05] *** payload left
[10:05] *** payload1 joined
[10:11] *** kane_ left
[10:12] *** kane_ joined
[10:14] *** kane_ left
[11:00] *** jan_ left
[11:03] *** jan_ joined
[11:25] *** meppl left
[11:37] *** IRSeekBot joined
[11:38] *** rblasch joined
[11:46] *** kane_ joined
[11:59] *** Whiteknight joined
[12:16] *** masak joined
[12:17] <masak> hi #perl6, you wonderful channel you.

[12:17] * masak is on a bus

[12:19] *** payload1 left
[12:19] <sbp> yo masak

[12:20] <masak> sbp: \o

[12:20] <masak> I don't see anything wrong with [perl #65272] submitted by Arne Skjærholt.

[12:21] <masak> specifically, I'm not sure what a 'static method call' would mean in Perl 6. there might be some confustion as to what the supplied code should do.

[12:22] *** payload joined
[12:47] *** M_o_C left
[12:48] *** payload left
[12:56] <masak> rakudo: multi sub foo(Int $n where 1) { say "OH HAI" }; sub foo(Int $n) { say "CHEEZBURGER" }; foo(1)

[12:56] <p6eval> rakudo ec69e2: OUTPUT«CHEEZBURGER␤»

[12:56] <masak> something like "Rakudo wrongly allows declaration of a multi and an only sub in the same scope".

[12:56] <masak> anyone know if that's in RT already?

[13:09] <jnthn> That should be an error unless there is a proto in scope.

[13:09] <masak> right.

[13:09] <jnthn> (which in this case there wasn't)

[13:10] <masak> jnthn: does that mean that the presence of a proto makes 'multi' implicit on all sub declarations in the same scope?

[13:10] <jnthn> masak: Yes.

[13:11] * masak understands a bit more of the 'proto' semantics

[13:11] <jnthn> rakudo: proto foo() { }; sub foo(Int $x} { 1 }; sub foo(Str $x) { 2 }; say foo(1); say foo("a");

[13:11] <p6eval> rakudo ec69e2: OUTPUT«Unable to parse multisig; couldn't find final ')' at line 1, near "} { 1 }; s"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[13:11] <masak> bug?

[13:11] <jnthn> rakudo: proto foo() { }; sub foo(Int $x) { 1 }; sub foo(Str $x) { 2 }; say foo(1); say foo("a");

[13:12] <p6eval> rakudo ec69e2: OUTPUT«1␤2␤»

[13:12] <jnthn> masak: I typed a } where I shoulda typed a ).

[13:12] <masak> ah.

[13:12] * masak sees now

[13:12] <jnthn> Anyway, it works.

[13:12] <jnthn> Yeah, took me a moment too.

[13:12] <masak> jnthn: aye, but the CHEEZBURGER one shouldn't work.

[13:13] <jnthn> aye, we should complain loudly about that one.

[13:13] * masak makes a quick trip through RT before submitting

[13:13] <jnthn> fwiw I don't recall seeing an RT about that.

[13:13] <masak> kthx.

[13:14] <masak> 对了, submitting.

[13:16] <jnthn> ooh, tentative YAPC::Asia dates are out. :-)

[13:16] <masak> Asia++

[13:16] * jnthn never went to Japan before, so is pondering taking his chance.

[13:18] * jnthn confirms his accepted YAPC::EU talk

[13:18] <jnthn> The schedule looks pretty good. :-)

[13:20] *** nihiliad joined
[13:20] <TimToady> it was not the original intent that a proto allow unmarked subs to default to multi rather than only

[13:21] <TimToady> though that is more like what proto does on variables, I suppose

[13:22] <jnthn> TimToady: It seem to recall it said somewhere in the spec that it did cause that...

[13:22] <jnthn> *I

[13:22] <jnthn> TimToady: I think part of the motivation is in role composition too.

[13:22] <masak> cool, so now Web.pm has a deadline, of sorts.

[13:22] <masak> apart from the end of the grant, I mean.

[13:22] <jnthn> Where you resolve the conflict by putting a proto method in which forces multi-ness on the non-multi conflicters.

[13:23] <TimToady> but that's the other way around, scopewise

[13:23] <jnthn> That bit is certainly in S1[24]

[13:23] <jnthn> Other way around in what sense?

[13:23] <jnthn> In that the ones from the roles are being brought into that scope?

[13:24] <TimToady> or more to the point, timewise, causewise, something like that

[13:24] <TimToady> the two roles are written before the class that integrates them

[13:24] <masak> rakudo: multi method perl(Object $self where /foo/:) { "OH HAI" }; say "foo".perl

[13:24] <p6eval> rakudo ec69e2: OUTPUT«"foo"␤»

[13:24] <TimToady> whereas the proto is written before, and the calls put later

[13:24] <jnthn> TimToady: It's right at the top of S06.

[13:24] <jnthn> A C<proto>

[13:24] <jnthn> also adds an implicit C<multi> to all routines of the same short

[13:24] <jnthn> name within its scope, unless they have an explicit modifier.

[13:24] <TimToady> before temporally, I mean

[13:25] <TimToady> well, I probably decided that and forgot :)

[13:25] <jnthn> :-)

[13:25] <jnthn> I do tend to look at the spec and implement whatever it was you forgot. ;-)

[13:25] <TimToady> one tends to slip back to one's original conceptions

[13:26] *** amoc^ joined
[13:26] *** Casan joined
[13:26] <jnthn> OK, if you change your mind, please update the spec, and I'll get Rakudo to follow along.

[13:26] <TimToady> btw, is there really a need to expose a Multi type?

[13:26] *** jhorwitz joined
[13:26] <TimToady> there isn't one specced...

[13:26] <jnthn> It's handy for introspection.

[13:26] <TimToady> but there's a test for it

[13:26] <jnthn> But also consider

[13:27] <jnthn> multi foo($x) { }; multi foo() { }; # what is the type of &foo

[13:27] <jnthn> It can't be Sub.

[13:27] <jnthn> Because that's the singular. And also we may have others that were exported methods.

[13:27] <TimToady> ($x)|(), which is a multisig

[13:28] <jnthn> Or exported SubMethods

[13:28] <TimToady> std: sub foo ($x) | () {...}

[13:28] <jnthn> A signature is something a sub has, not is.

[13:28] <p6eval> std 26617: OUTPUT«ok 00:02 36m␤»

[13:29] <jnthn> OK, sure you can have that, but it doesn't hold when you have multiple bodies.

[13:29] <TimToady> I don't follow your other arg

[13:29] <TimToady> doesn't hold how so?

[13:30] <jnthn> OK, imagine I had written

[13:30] * TimToady is still in a pre-caffiene state...

[13:30] <jnthn> multi foo($x) { 1 }; multi foo() { 2 };

[13:30] <jnthn> There are two different implemenations there, not just two different signatures.

[13:31] <jnthn> I can see &foo.signature returning a junction of signatures. That's fine.

[13:31] <jnthn> But &foo.WHAT I'd seen as handing back some Multi type.

[13:31] <jnthn> Which provides, say, &foo.candidates

[13:31] <jnthn> For introspective purposes.

[13:32] <TimToady> why shouldn't any &foo be able to hand back a list of candidates, where only subs have only one candidate?

[13:33] <jnthn> I guess we could try and make it that way, but I'd always seen an only sub as singular.

[13:33] <TimToady> wrapping turns a singuler into a plural in place

[13:33] <jnthn> And a multi as "a collection of code objects"

[13:33] <TimToady> if wrapping is going to respond to callnext like other dispatchers

[13:34] <jnthn> That can happen without confusing single and multiple dispatch.

[13:34] *** ZuLuuuuuu joined
[13:35] <masak> key codes for slightly special keys, like the up arrow or the function keys, will they be covered by some part of the spec, or is that too platform-dependent?

[13:35] <TimToady> well, wrapped routines have their own subdispatcher in either case, I expect

[13:35] <TimToady> since all the candidates present the same interface, presumably

[13:35] *** skids joined
[13:37] <TimToady> masak: this seems like something that belongs in the definition of event handling, not the language itself, offhand

[13:37] <masak> TimToady: ok.

[13:37] <masak> but event handling will be part of the spec, to some degree, no?

[13:37] <TimToady> except, of course, to the extent that event handling *is* part of the language :)

[13:37] <masak> right.

[13:38] <jnthn> TimToady: Yeah, I'd taken in that the wrap mechanism and the next candidate mechanism all want to hang off the same thing.

[13:38] <jnthn> I think I know how to cleanly implement that.

[13:39] *** PhatEddy joined
[13:39] <TimToady> but if you do that, then &foo acquires more than one candidate

[13:39] <TimToady> when you wrap

[13:39] <jnthn> But I hadn't seen the distinction between one sub and a bunch of them going away.

[13:39] <TimToady> so a singular/plural unification seems in order there

[13:39] <jnthn> We still will need a way of talking about an individual candidate.

[13:40] <jnthn> Sub, Method, etc had all to me seemed very much singular.

[13:40] <TimToady> &foo is just a callable abstraction, and how it handles the call is probably best encapsulated

[13:40] <TimToady> like any object, they're singular on the outside, but potentially plural inside

[13:41] <jnthn> I consider "this is wrapped" and "this is a multi" being different kinds of plurality.

[13:41] <TimToady> that's because you're implementing them, not calling them :)

[13:42] <jnthn> I still don't see how we can really do away with a Multi type though.

[13:43] <jnthn> This is one place where smop and Rakudo seem to have gone down the same road, fwiw.

[13:43] <TimToady> I don't think &foo should change its outside type just because someone implemented differently

[13:43] <masak> rakudo: my $i = 0; do * until $i++ > 5; say "alive" # I've been missing the 'nothing' keyword, but this is not too bad either.

[13:43] <p6eval> rakudo ec69e2: OUTPUT«alive␤»

[13:43] <jnthn> If you want to do that, you need to specify what that type is.

[13:43] <masak> rakudo: my $i = 0; do Whatever until $i++ > 5; say "alive"

[13:44] <p6eval> rakudo ec69e2: OUTPUT«alive␤»

[13:44] <jnthn> And given you might have multi variants that come from exported methods, and others that are subs, etc, I'm not sure how you can just say "it's a Sub" and so on...

[13:44] * masak ♥ Perl 6

[13:45] <TimToady> &foo is just the name of whatever foo does in the current namespace

[13:45] <jnthn> So what does &foo.WHAT give?

[13:46] <TimToady> Code, I think

[13:46] <masak> rakudo: *

[13:46] <p6eval> rakudo ec69e2:  ( no output )

[13:47] <TimToady> let me think about it some more; maybe I can persuade myself not to care

[13:47] <jnthn> :-)

[13:48] <jnthn> TimToady: While you're on it, also ponder whether it's valid to wrap a bunch of multis wholesale or only one of the candidates. :-)

[13:50] <PhatEddy> naive question - someone was asked to use "my $in = $*IN.get;" to get a line of input yesterday.  Why not just "my $in = get;" ?

[13:50] <TimToady> jnthn: it just feels like a leaky abstraction if that matters to the user

[13:50] <masak> PhatEddy: because there's no sub 'get'...? :)

[13:51] <PhatEddy> should there be one?

[13:51] <TimToady> yes

[13:51] <TimToady> to go with lines()

[13:51] <masak> PhatEddy: patches welcome.

[13:51] <jnthn> TimToady: They are different things.

[13:51] <TimToady> to the implementor

[13:51] <jnthn> No, to the user too.

[13:51] <jnthn> Do I want to wrap the multi as a whole, and the callnext or whatever will do a multi-dispatch.

[13:52] <jnthn> Or do I want to find a single candidate that I care about and wrap just that one.

[13:52] *** amoc^ left
[13:52] <TimToady> I would think the Perl way would be to allow either, if you can name them

[13:52] <PhatEddy> RT #65120 was going to add lines() and slurp() - maybe I'll add get to it too ...

[13:52] <TimToady> if I &foo.wrap, it uses the current namespaces idea of &foo

[13:53] <TimToady> 's

[13:53] <masak> PhatEddy: sounds good.

[13:53] <jnthn> Right, agree.

[13:54] <jnthn> I just think that while you should always be able to get at &foo and call it or wrap it and not care, there are times when people will care.

[13:54] <jnthn> And want to know if the thingy they have is going to go off and do a single dispatch or a multiple dispatch.

[13:54] <TimToady> and then they can say &SomeModule::foo:(Int,Str).wrap instead to be more specifi

[13:54] <TimToady> why would they want to know that?

[13:55] <jnthn> Introspection?

[13:55] <TimToady> I would think they want to *not* know that most of the time

[13:55] <jnthn> I don't see how we can't have both.

[13:55] <TimToady> and when they do want to know it, they can introspect &foo via some method

[13:56] <jnthn> &foo() whether it's of type Code or Sub or Multi is going to look just the same if you invoke it, wrap it, unwrap it, and so on.

[13:57] <jnthn> Anybody who starts asking exactly what sort of thing it is is already at the point of introspection.

[13:58] <jnthn> And thus below the "don't have to care" level.

[13:58] <TimToady> okay, here's the thing that bothers me.  I don't mind if &foo does Multi, but the spec test is testing to see if it isa Multi, and I think that's over-orthogonalizing the space in a classish way

[13:59] <TimToady> at the end of t//spec/S06-multi/syntax.t

[13:59] <jnthn> I'm quite open to the idea that .isa is too strong a promise.

[13:59] <TimToady> I thought you'd be :)

[13:59] <TimToady> that's why I mentioned it...

[13:59] <jnthn> If your mainly wanting to see that test become .does(Multi)

[13:59] <jnthn> Or even the hand-wavey &foo ~~ Multi

[13:59] <jnthn> That doesn't bother me at all.

[14:00] <TimToady> though I think the marked case should actually be Only, from an optmization point of view

[14:01] <TimToady> well, even Only can become plural through wrapping

[14:01] <jnthn> Sure, but you still know fairly well where the dispatch is going.

[14:01] <TimToady> maybe the optimizer wants Inlineable instead. :)

[14:02] <TimToady> well, I still see wrapping and multiple dispatch as basically the same thing

[14:03] <TimToady> and the point of is inline is to disable wrapping, mostly

[14:03] <masak> .oO( do not wrap )

[14:04] <jnthn> I'm not convinced inlining of multis is always impossible.

[14:04] <TimToady> though there's something going on here like closing and finalizing classes, from a pessimization point of view

[14:04] <jnthn> If we statically know all of the candidates in a given scope and we statically know the types of the parameters, for example...

[14:05] <jnthn> On the other hand, inlining of something that can get wrapped probably always is.

[14:05] <TimToady> sure, just trying to make the possible common, to the extent possible :)

[14:05] <jnthn> And I guess that's part of why I would rather not see multi dispatch and wraping *so* closely entangled.

[14:05] <jnthn> Even if both do operate through the same kind of candidate list-ish mechanism.

[14:06] <TimToady> well, but making a hard type distinction is another form of entanglement, which is what I'm carping about

[14:07] <TimToady> but we can let it go for now, if we s/isa/does

[14:07] <jnthn> Sure, and I agree that .isa is too strong a check.

[14:08] <jnthn> Are you thinking of adding a check that .isa is false too, though? I'd rather leave that as a "not the way to check it, implemenation specific" kidna thing if we can.

[14:09] <jnthn> rakudo: multi foo() { }; say &foo ~~ Multi; say &foo.does(Multi);

[14:09] <p6eval> rakudo ec69e2: OUTPUT«1␤1␤»

[14:10] <pugs_svn> r26618 | lwall++ | [syntax.t] relax isa Multi to ~~ Multi

[14:10] <jnthn> .oO( phew )

[14:13] <pugs_svn> r26619 | lwall++ | [CORE] suppress Multi undef error

[14:30] *** dalek left
[14:30] *** dalek joined
[14:33] <Matt-W> hurrah

[14:33] <Matt-W> form works again

[14:33] <Matt-W> although I think I've made a mistake in the semantics

[14:33] <masak> Matt-W: anything pullable?

[14:33] <Matt-W> Damian's module counts a field spec of {<} as having width 3, my module counts it as width 1

[14:33] <Matt-W> so I think I need to fix that

[14:33] <Matt-W> masak: yes I just pushed it

[14:34] <Matt-W> masak: verbatim line and block fields now exist

[14:34] * masak pulls

[14:34] <Matt-W> Although I'm having some doubts about whether their behaviour is correct

[14:34] <Matt-W> I'll have to run a bunch of comparisons against Perl6::Form at some point

[14:34] <masak> Matt-W: what if I wanted a left-justified field of width 2?

[14:34] <Matt-W> masak: I don't know

[14:35] <Matt-W> That's why I just assumed the {} don't count

[14:35] <masak> Matt-W: you should make Perl6::Form and your module pass the same suite. :)

[14:35] <Matt-W> although if they do, it's nice for the layout of your picture strings

[14:35] <TimToady> the whole point of formats was to keep the picture consistent on columns, so {<} is 3 by that reckoning

[14:36] <Matt-W> but anything less than 3 is a problem

[14:36] <TimToady> wasn't a problem for p5 formats :)

[14:36] <TimToady> since we had @ and @< and @>

[14:37] <masak> Matt-W: what does '*@args is Scalar' do that '*@args' doesn't?

[14:37] <TimToady> if you want your columns to not line up, that's what sprintf is for :)

[14:37] <Matt-W> masak: I can't remember

[14:38] <TimToady> I don't think "is Scalar" means anything anymore

[14:38] <Matt-W> masak: probably something to do with passing arrays in

[14:38] <masak> I've never seen 'is Scalar' in working code before.

[14:38] <Matt-W> if it doesn't do anything, rakudo probably shouldn't accept it

[14:38] <TimToady> the idea was to evaluate each argument in scalar context

[14:38] <masak> Matt-W: I'll run the test suite, remove it, and run it again.

[14:39] <Matt-W> TimToady: right so you could say form("some string", @data, "Picture");

[14:39] <Matt-W> Which would be nice

[14:40] <Matt-W> (and have @data not interpolate into the arguments)

[14:40] <TimToady> we'll have to think about how that notion fits into the world of Captures

[14:41] <masak> I thought @data already didn't interpolate into the arguments.

[14:42] <masak> rakudo: sub foo(@data, $bar) { say $bar }; my @data = 1,2,3; foo(@data, 'OH HAI')

[14:42] <p6eval> rakudo ec69e2: OUTPUT«OH HAI␤»

[14:42] <TimToady> it's possible this is simply binding to *@@ these days

[14:42] <TimToady> but maybe not

[14:43] <TimToady> probably not, or slices will break when you say @x[1, @data, 3]

[14:44] <masak> Matt-W: removing 'is Scalar' doesn't make any tests fail.

[14:44] <Matt-W> masak: that's because none of them rely on it doing anything

[14:45] <masak> Matt-W: well, given that 'is Scalar' wasn't needed to make @data not interpolate in the parameter list, why keep it?

[14:46] <Matt-W> because I've not tested it

[14:46] <Matt-W> it's from the original spec for that sub

[14:47] <masak> ah, ok.

[14:47] <Matt-W> rakudo: sub foo(*@args) { say @args.elems; }; my @d = 1,2,3; foo(@d, 'a');

[14:47] <p6eval> rakudo ec69e2: OUTPUT«4␤»

[14:47] <Matt-W> see also ^

[14:47] <masak> oh.

[14:48] <masak> right, the splat thing might actually affect matters.

[14:48] <masak> rakudo: sub foo(*@data, $bar) { say $bar }; my @data = 1,2,3; foo(@data, 'OH HAI')

[14:48] <p6eval> rakudo ec69e2: OUTPUT«1 2 3␤»

[14:49] <masak> huh.

[14:49] <masak> I'd expect the splat to be more greedy than that.

[14:51] <diakopter> 02:23 <@TimToady> zzz &  .... 08:20 <@TimToady> it was ...

[14:52] <TimToady> I'm in two TZ at once :)

[14:52] <TimToady> std: sub foo(*@data, $bar) { say $bar }; my @data = 1,2,3; foo(@data, 'OH HAI')

[14:52] <p6eval> std 26619: OUTPUT«##### PARSE FAILED #####␤Can't put required parameter after variadic parameters at /tmp/spEF6EpDfd line 1:␤------> sub foo(*@data, $bar) { say $bar }; my @data = 1,2,3; foo(@d␤    expecting any of:␤ parameter␤        post_constraint␤  trait␤  whitespace␤FAILED 00:02

[14:52] <p6eval> ..36m␤»

[14:52] <TimToady> masak: see ^

[14:52] *** nbrown joined
[14:53] <TimToady> rakudo is being overly accepting here

[14:53] <Matt-W> bug!!!

[14:53] * masak submits!!!

[14:54] * Matt-W gone for a bit &

[14:54] <TimToady> will likely be put off till STD runs on rakudo :)

[14:57] *** nbrown_ joined
[14:57] <TimToady> rakudo: say Int.defined; say Int::.defined

[14:57] <p6eval> rakudo ec69e2: OUTPUT«0␤0␤»

[14:58] <TimToady> should be 0 1 if :: gets to the package for Int

[14:58] <TimToady> trying to figure out how to write tests like UNIT::OUTER:: === CORE:: and such

[14:59] <TimToady> but I need to know how to get the identity of a lexical symbol table from a typename

[15:04] <pugs_svn> r26620 | masak++ | [u4x/TODO] added a lot of terms for parameters

[15:04] <pugs_svn> r26621 | masak++ | [u4x/TODO] {result -> abstract} object

[15:09] <pmichaud> good *, #perl6

[15:11] <TimToady> yo

[15:12] <masak> H H

[15:12] <masak> O AI

[15:14] <TimToady> お愛

[15:14] <pmichaud> (reading scrollback)

[15:19] <TimToady> the mutable/immutable distinction is close to the mystery of time; we can only perceive the immutable scrollback, not the future mutable scrollforward

[15:19] <jnthn> oh hai

[15:20] <masak> the best way to predict the scrollforward is to create it.

[15:20] * jnthn ponders what to eat/cook for dinner

[15:20] <TimToady> masak: I knew you were going to say that :P

[15:21] *** nbrown left
[15:21] *** nbrown_ is now known as nbrown

[15:21] <masak> :)

[15:22] <masak> rakudo: my @a = <foo bar baz>; .=uc for @a; say @a.perl

[15:23] <p6eval> rakudo ec69e2: OUTPUT«Syntax error at line 1, near ".=uc for @"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[15:23] <TimToady> std: my @a = <foo bar baz>; .=uc for @a; say @a.perl

[15:23] <pmichaud> we still don't support   .= flip

[15:23] <p6eval> std 26621: OUTPUT«ok 00:02 36m␤»

[15:23] <pmichaud> er, .=flip

[15:23] <pmichaud> (as a term)

[15:24] <pmichaud> (.=uc being analogous here.)

[15:24] <pmichaud> std:  my @a = <foo bar baz>;  .= uc for @a; say @a.perl;

[15:24] <jnthn> rakudo: my @a = <foo bar baz>; .= uc for @a; say @a.perl

[15:24] <p6eval> std 26621: OUTPUT«##### PARSE FAILED #####␤Can't understand next input--giving up at /tmp/70EAuNVzdi line 1:␤------> my @a = <foo bar baz>;  .= uc for @a; say @a.perl;␤    expecting dotty method or postfix␤FAILED 00:02 36m␤»

[15:24] <p6eval> rakudo ec69e2: OUTPUT«Syntax error at line 1, near ".= uc for "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[15:25] <TimToady> I don't feel any great need to support that form...

[15:25] <pmichaud> TimToady: but the version without the space is supported?

[15:25] <pmichaud> std:  my @a = <foo bar baz>;  .=uc for @a; say @a.perl;

[15:25] <p6eval> std 26621: OUTPUT«ok 00:02 36m␤»

[15:25] <TimToady> already did that one above

[15:25] <pmichaud> right

[15:25] <pmichaud> just asking for confirmation

[15:26] <TimToady> 'yes' xx *

[15:26] <pmichaud> thanks

[15:26] <jnthn> .oO( why on earth are single flights more expensive than return ones )

[15:27] <jnthn> pmichaud: Do you know anything more about the plans for a Parrot Developer Summit around YAPC::EU?

[15:27] <pmichaud> jnthn: no details, no.

[15:27] <jnthn> pmichaud: OK. Am pondering trying to sort out flights/hotel etc soonish...

[15:27] <pmichaud> maybe a message to last year's attendees

[15:27] <pmichaud> yes, I will need to do the same.

[15:28] *** fridim_ joined
[15:28] <jnthn> I'm happy to see the Perl 6 is a bit more spread out in the schedule this year, rather than all bunched on one day.

[15:30] <jnthn> pmichaud: Ah, we're speaking one after the other, it appears.

[15:31] *** M_o_C joined
[15:31] <jnthn> 40 minutes for the talk you gave in IIRC 90 in Oslo will be interesting.

[15:33] <PhatEddy> I had trouble getting get() working through setting but found it fairly easy in PIR with the following 5 line pir patch: http://dpaste.com/40312/ .

[15:33] <PhatEddy> how badly is it needed in setting?

[15:34] <jnthn> did multi get() { $*IN.get() } not do it?

[15:35] <PhatEddy> no it didn't

[15:35] <jnthn> Hmm. What went wrong?

[15:35] <PhatEddy> get iss defined in classes/IO.pir without multi to begin with

[15:36] <jnthn> Sure, but you're defining a sub that calls the method. shouldn't be a conflict, afaict.

[15:36] <PhatEddy> I think I got: Null PMC access in find_method()

[15:36] <jnthn> Ugh. OK.

[15:37] <jnthn> I'd like to try and track down why we got that. It points to a bug of some kind.

[15:37] <PhatEddy> the setting code i used was something like 'multi sub get() { return $*IN.get; }'

[15:38] <jnthn> Yeah, that doesn't look wrong.

[15:38] *** Kisu left
[15:38] *** xinming left
[15:39] *** xinming joined
[15:40] <PhatEddy> the pir looks easy enough though ... should I file a rakudobug ?

[15:40] <jnthn> PhatEddy: Please file a ticket about that not working; it'd be good to fix the underlying bug rather than ignore it by writing stuff in PIR that we really should be able to write in Perl 6.

[15:42] *** payload joined
[15:43] <PhatEddy> ok

[15:43] *** masak left
[15:45] *** masak joined
[15:45] * jnthn -> shop

[15:46] <masak> bus wifi a bit flaky. got thrown off the Interwebz.

[15:46] *** meppl joined
[15:48] <masak> I had a patch going for .=flip at one point; sometime around the post-NPW hackathon. but I must have lost it.

[15:49] <pmichaud> (90 minutes talk in 40 minutes)   shouldn't be too much of a problem; it's an accordian talk where there are lots of things that can be added/removed

[15:50] <pmichaud> PhatEddy: did you put the multi sub inside the IO class or outside of it?

[15:50] <PhatEddy> outside - all the way at the bottom

[15:50] <pmichaud> hmmm.

[15:51] <pmichaud> I wonder if there's something else called 'get' somewhere.

[15:51] <PhatEddy> It's exported from src/classes/IO.pir 

[15:54] <masak> rakudo: sub get() { $*IN.get }; say get; say "alive"

[15:54] <p6eval> rakudo ec69e2: OUTPUT«␤alive␤»

[15:54] <masak> still no Austrian national anthem... :/

[15:54] <masak> PhatEddy: it works outside of the setting, it seems.

[15:55] <pmichaud> perl6: say 'ışığa'.uc;

[15:55] <p6eval> elf 26621, pugs, rakudo ec69e2: OUTPUT«IŞIĞA␤»

[15:56] <pmichaud> \o/

[15:56] <masak> pmichaud: wohoo! what changed?

[15:56] <pmichaud> I fixed $*IN, $*OUT, $*ERR to use utf8 encoding by default.

[15:56] <masak> excellent.

[15:57] *** Psyche^ joined
[16:06] <PhatEddy> rakudo: multi sub get () { $*IN.get } ; say get; say "alive"

[16:06] <p6eval> rakudo ec69e2: OUTPUT«push_pmc() not implemented in class 'Sub'␤current instr.: 'parrot;PCT;HLLCompiler;evalpmc' pc 306668 ((unknown file):-1)␤»

[16:06] <PhatEddy> should that have worked?

[16:06] * masak thinks so

[16:07] <masak> PhatEddy: would you like to submit a rakudobug?

[16:07] * PhatEddy still working on this ...

[16:08] * masak submits it, then

[16:10] <PhatEddy> I just replicated the error message from putting the definition in setting/IO.pm (got the error message wrong)

[16:11] <PhatEddy> error message is (still): too few arguments passed (0) - 1 params expected

[16:11] <PhatEddy> it's like it doesn't seem to find it from the setting.

[16:13] *** Patterner left
[16:13] *** Psyche^ is now known as Patterner

[16:18] <pmichaud> generally that means it either thinks it's a method instead of a sub, or there's something wrong with the outer contexts.

[16:21] <pmichaud> 22:34 <jnthn> pmichaud: If you know how, or are able to, giving PhatEddy an RT bit could be a good idea.

[16:21] <pmichaud> I think I offered one previously, but it was declined.

[16:21] <pmichaud> The offer remains, however.  :-)

[16:30] *** justatheory joined
[16:34] <diakopter> bouncing faether svn/apache2

[16:36] *** masak left
[16:36] *** ejs left
[16:42] *** justatheory left
[16:48] *** ejs joined
[16:50] *** nacho_ left
[16:50] <pugs_svn> r26622 | pmichaud++ | [t/spec]: Standardize a couple of plan declarations.

[16:52] *** amoc joined
[16:53] *** amoc is now known as amoc^

[16:53] *** amoc^ left
[16:54] *** amoc joined
[16:54] *** amoc is now known as Guest26623

[16:55] *** Guest26623 left
[16:55] *** M_o_C left
[17:16] *** amoc^ joined
[17:17] *** rblasch left
[17:20] *** meteorjay left
[17:23] *** justatheory joined
[17:28] *** finanalyst joined
[17:31] * skids wonders if anyone experiences an occasional spurious segv building rakudo.

[17:32] <finanalyst> perl6: my %x = %(<a b c d> X []); %x<a>[3]=2;%x.perl.say

[17:32] <lambdabot> finanalyst: You have 1 new message. '/msg lambdabot @messages' to read it.

[17:32] <p6eval> pugs: OUTPUT«\(\("a", \(undef, undef, undef, 2)),)␤»

[17:32] <p6eval> ..rakudo ec69e2: OUTPUT«{"a" => [undef, undef, undef, 2], "b" => [undef, undef, undef, 2], "c" => [undef, undef, undef, 2], "d" => [undef, undef, undef, 2]}␤»

[17:32] <p6eval> ..elf 26622: OUTPUT«Undefined subroutine &GLOBAL::infix_X called at (eval 129) line 3.␤ at ./elf_h line 5881␤»

[17:32] *** nbrown_ joined
[17:34] <skids> well, that's pretty weird.

[17:35] <finanalyst> can anyone tell me whether the rakudo response is the expected one? I was expecting to get different arrays for each member of the hash

[17:35] <finanalyst> instead one array is allocated and the others are aliases (I think)

[17:35] *** justatheory left
[17:37] <finanalyst> more like the pugs output, but pugs leaves out the c & d members

[17:37] <skids> Hrm, [] is an anonymous array, so I think it's correct, because you are assigning the same anon array to each index.

[17:37] <skids> But it is weird, because IIRC binding to array/hash is currently broken.

[17:38] *** c9s_ joined
[17:38] <finanalyst> why should it be the same anonymous array?

[17:39] <finanalyst> or what should be the syntax to generate new arrays?

[17:39] <TimToady> [] is supposed to generate a new array

[17:39] <TimToady> but X doesn't guarantee to re-eval

[17:40] <finanalyst> so is rakudo wrong?

[17:40] <finanalyst> or how do I get a re-eval?

[17:41] <skids> my $a; my %x = %(<a b c d> X $a); %x<a>=2;%x.perl.say

[17:41] <skids> rakudo: my $a; my %x = %(<a b c d> X $a); %x<a>=2;%x.perl.say

[17:41] <skids> X doesn't eval it's rhs multiple times.

[17:41] <p6eval> rakudo ec69e2: OUTPUT«{"a" => 2, "b" => undef, "c" => undef, "d" => undef}␤»

[17:41] <skids> (is why)

[17:41] <finanalyst> rakudo: my %x=<a b c d> Z ([], [], [], []);%x<b>[2]=3;%x.perl.say

[17:41] * skids wonders if he just inflooped evalbot

[17:41] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤Cannot reduce() empty list␤Cannot reduce() empty list␤{"a" => [], "b" => [undef, undef, 3], "c" => [], "d" => []}␤»

[17:42] <finanalyst> rakudo: my %x=%(<a b c d> Z ([], [], [], []));%x<b>[2]=3;%x.perl.say

[17:42] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤Cannot reduce() empty list␤Cannot reduce() empty list␤{"a" => [], "b" => [undef, undef, 3], "c" => [], "d" => []}␤»

[17:43] <finanalyst> using Z with a list of [] gets what I want, but suppose I dont know how many items there are in the "key name" array

[17:44] <skids> rakudo: my $a; my %x = %(<a b c d> X [234]); %x<a>=2;%x.perl.say

[17:44] <p6eval> rakudo ec69e2: OUTPUT«{"a" => 2, "b" => [234], "c" => [234], "d" => [234]}␤»

[17:45] <TimToady> rakudo: my %x = map { $_, [], }, <a b c d>; %x<a> = 2;  %x.perl.say 

[17:45] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤Cannot reduce() empty list␤Cannot reduce() empty list␤{"a" => 2, "b" => [], "c" => [], "d" => []}␤»

[17:45] <skids> seems inconsistent, unless [] is special somehow.

[17:45] <TimToady> rakudo: my %x = map { $_, [,], }, <a b c d>; %x<a> = 2;  %x.perl.say 

[17:45] <p6eval> rakudo ec69e2: OUTPUT«Statement not terminated properly at line 1, near ", [,], }, "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[17:45] <TimToady> rakudo: my %x = map { $_, [ ], }, <a b c d>; %x<a> = 2;  %x.perl.say 

[17:45] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤Cannot reduce() empty list␤Cannot reduce() empty list␤{"a" => 2, "b" => [], "c" => [], "d" => []}␤»

[17:46] <TimToady> it should not be parsing that as a reduce

[17:46] <TimToady> rakudo: my %x = map { $_, [()], }, <a b c d>; %x<a> = 2;  %x.perl.say 

[17:46] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤Cannot reduce() empty list␤Cannot reduce() empty list␤{"a" => 2, "b" => [], "c" => [], "d" => []}␤»

[17:46] <TimToady> rakudo: my %x = map { $_, [ () ], }, <a b c d>; %x<a> = 2;  %x.perl.say 

[17:46] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤Cannot reduce() empty list␤Cannot reduce() empty list␤{"a" => 2, "b" => [], "c" => [], "d" => []}␤»

[17:46] <TimToady> actually, it seems like something in .perl

[17:47] <jnthn> I struggle to see that it's mistaking it as a reduce, since we parse those as full tokens.

[17:47] <jnthn> At the moment.

[17:47] <finanalyst> rakudo: my %x = %(map { $_, [ () ], }, <a b c d>); %x<a> = 2;  %x.perl.say 

[17:47] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤Cannot reduce() empty list␤Cannot reduce() empty list␤{"a" => 2, "b" => [], "c" => [], "d" => []}␤»

[17:47] <TimToady> rakudo: my %x = map { $_, [ () ], }, <a b c d>; %x<a> = 2;  %x.say

[17:47] <skids> The reduce is from trying to say an empty list

[17:47] <p6eval> rakudo ec69e2: OUTPUT«a  2b      c       d       ␤»

[17:47] <jnthn> rakudo: my %x = %(map { $_, [ () ], }, <a b c d>);

[17:47] <p6eval> rakudo ec69e2:  ( no output )

[17:48] <TimToady> rakudo: my %x = map { $_, [], }, <a b c d>; %x<a> = 2;  %x.say

[17:48] <jnthn> Heh, yeah, something in .perl

[17:48] <p6eval> rakudo ec69e2: OUTPUT«a  2b      c       d       ␤»

[17:49] <TimToady> rakudo: say []

[17:49] <p6eval> rakudo ec69e2: OUTPUT«␤»

[17:50] <TimToady> rakudo: say [[]]

[17:50] <p6eval> rakudo ec69e2: OUTPUT«␤»

[17:50] *** nbrown left
[17:50] <TimToady> rakudo: say [[]].perl

[17:50] *** nbrown_ is now known as nbrown

[17:50] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤[[]]␤»

[17:50] <TimToady> there you go

[17:50] <pmichaud> rakudo:  say [].perl;

[17:50] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤[]␤»

[17:51] <TimToady> in both cases there's only one empty list

[17:51] <TimToady> rakudo: say ().perl

[17:51] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤[]␤»

[17:51] <jnthn> fail.

[17:51] <TimToady> rakudo: say Nil.perl

[17:51] <pmichaud> I can't even find where .perl is defined now.  It's been moved :-|

[17:51] <p6eval> rakudo ec69e2: OUTPUT«Nil␤»

[17:51] <jnthn>     method perl() {

[17:51] <jnthn>         return '[' ~ self.map({ .perl }).join(", ") ~ ']';

[17:51] <jnthn>     }

[17:52] <jnthn> That's the one in List...

[17:52] <pmichaud> okay, that's it.

[17:52] <pmichaud> so, .map is complaining about an empty list.

[17:52] <jnthn> o rly?

[17:52] <jnthn> rakudo: [].map(* * 2)

[17:52] <pmichaud> say   ().map({ $_ * 2 });

[17:52] <p6eval> rakudo ec69e2:  ( no output )

[17:52] <pmichaud> rakudo: say   ().map({ $_ * 2 });

[17:52] <TimToady> rakudo: map {42}, ()

[17:53] <p6eval> rakudo ec69e2: OUTPUT«␤»

[17:53] <p6eval> rakudo ec69e2:  ( no output )

[17:53] <TimToady> rakudo: say map {42}, ()

[17:53] <p6eval> rakudo ec69e2: OUTPUT«␤»

[17:53] <jnthn> rakudo: say ().join

[17:53] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤␤»

[17:53] <pmichaud> rakudo:   say [].map({ .perl });

[17:53] *** c9s left
[17:53] <p6eval> rakudo ec69e2: OUTPUT«␤»

[17:53] <jnthn> rakudo: say [].join

[17:53] <p6eval> rakudo ec69e2: OUTPUT«Cannot reduce() empty list␤␤»

[17:53] <jnthn> I think it's join.

[17:53] *** lumi left
[17:53] <skids> rakudo: my $a; my %x = %(<a b c d> X [234]); %x<a>[2]=2;%x.perl.say

[17:53] <pmichaud>     our Str multi method join(Str $separator = '') {

[17:53] <pmichaud>         @.list.reduce({ $^a ~ $separator ~ $^b })

[17:53] <pmichaud>     }

[17:53] <TimToady> say [~]()

[17:53] <p6eval> rakudo ec69e2: OUTPUT«{"a" => [234, undef, 2], "b" => [234, undef, 2], "c" => [234, undef, 2], "d" => [234, undef, 2]}␤»

[17:53] <TimToady> rakudo say [~]()

[17:54] <skids> my bad, not inconsistent, forgot the second subscript

[17:54] <TimToady> rakudo: say [~]()

[17:54] <p6eval> rakudo ec69e2: OUTPUT«␤»

[17:54] <TimToady> rakudo: say ().reduce(&infix:<~>)

[17:54] <p6eval> rakudo ec69e2: OUTPUT«Statement not terminated properly at line 1, near "(&infix:<~"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[17:54] <pmichaud> growl.  There's another one of those constraints on the builtin parameter.... :-(

[17:55] <TimToady> rakudo: say ().reduce(&[~])

[17:55] <jnthn> Aye, people are being a tad overzelous with the constraints. :-(

[17:55] <p6eval> rakudo ec69e2: OUTPUT«Statement not terminated properly at line 1, near "(&[~])"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[17:55] <jnthn> TimToady: We don't parse the operator syntax yet. :-(

[17:55] <pmichaud> anyway, the definition for .join looks wrong to me.

[17:55] <jnthn> Aye, relying on reduce function is probably a bad idea.

[17:55] <pmichaud> and I think I might just prefer the PIR version anyway.

[17:56] <jnthn> Well, given Parrot has a built-in join...

[17:56] <pmichaud> fixing.

[17:56] <skids> Well, some of the constraint problems are coming from the protos taken from S32 and other docs.

[17:56] <TimToady> why use reduce when you can use recursive lambdas :)

[17:56] <jnthn> May as well make use of the thigns Parrot does give us. ;-)

[17:56] <pmichaud> I should go through and eliminate the constrants from S32

[17:56] <pmichaud> fixing join.

[17:56] <jnthn> TimToady: Because we didn't implement &?ROUTINE yet. ;-)

[17:56] <jnthn> erm

[17:56] <jnthn> &?BLOCK

[17:57] <TimToady> well, there's always *named* lambdas...

[17:58] <TimToady> or even my $x = { ... $x()... }

[17:58] <jnthn> True.

[17:58] <skids> so now that everyone who builds frequently is awake, anyone ever notice a spurios segfault during rakudo build steps (parrot invocations?)

[17:58] <jnthn> I always think "anonymous" when I see "lambda"

[17:58] <skids> Becuase if so, I know how to agrravate the problem.

[17:58] <TimToady> you're putting me to sleep ...

[17:58] <pmichaud> skids: I haven't noticed one, no.

[17:59] *** rblasch joined
[17:59] <jnthn> Computer science degree has gotta be good for something. ;-)

[17:59] <TimToady> yeah, I should get me one of those some day...

[17:59] <jnthn> skids: I didn't notice that...only very occasional things when a realclean was needed or something.

[18:00] <TimToady> meanwhile, it's off to Fry's &

[18:01] <skids> Well, setting parrot/src/hash.c INITIAL_BUCKETS to 4 exposes a race quite nicely, FWIW.

[18:02] <jnthn> As in race condition?

[18:02] <skids> If I am masochistic enough this weekend I may even manage to track down why.

[18:02] <skids> Yeah, segfaults on some runs, not others.

[18:02] <jnthn> Uff.

[18:02] <skids> Probably just a missing write barrier, there's a couple in there.

[18:03] <jnthn> Did you think setting it to 4 would get us a small performance win?

[18:03] <skids> Setting to 8 gives a 1% speed gain and seems pretty stable.

[18:03] <skids> 4 was about 2%.  Stats are in the backlog

[18:03] * Matt-W has not had a build segfault for ages

[18:03] <skids> But it probably depends highly on your cache.

[18:04] <skids> might be more for 64bit

[18:05] <jnthn> We use hashes extensively for named lookup, so profiling/optimizing Parrots hashes (without introducing segfaults ;-)) is perhaps a good place to look for performance improvements.

[18:05] <skids> Yeah I've been looking at that a bit.

[18:05] <skids> phone

[18:06] * skids hates cell phone spam, someone needs to arrest those people.

[18:07] <skids> Parrot code seems to have been optimized by someone who overvalues CPU cycles.

[18:07] <jnthn> Indeed.

[18:07] <skids> And doesn't grok the impact of present/future 8 byte pointers.

[18:08] <skids> Stats on hash accesses by the way, from earlier:

[18:08] <skids> '1.say' hash number of elements % operations (0 to 8, then 63+)

[18:09] <skids> reads: 0.28 64.50 13.50 3.51 0.46 0.20 0.19 0.37, 12.72

[18:09] <dalek> rakudo: cacc976 | pmichaud++ | src/setting/Any-list.pm:

[18:09] <dalek> rakudo: Rewrite Any.join() to avoid the "Cannot reduce() empty list" error.

[18:09] <dalek> rakudo: Might as well use the Parrot 'join' opcode since we have one.

[18:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cacc9767a525299e075c5ff2246d4451c64c0d48

[18:09] <skids> writes: 14.23 9.03 6.18 4.40 3.58 2.96 2.39 2.18, 29.80

[18:09] <skids> So having a very efficient 1 and 2 element hash would be key.

[18:09] <jnthn> Certainly biased towards the lower end.

[18:10] <jnthn> Is that compiling 1.say or just running it?

[18:10] <skids> Well, except for the const_string hash.

[18:10] <skids> running it.

[18:11] <pmichaud> we also end up with a ton of 0-element hashes, because of :named :slurpy

[18:12] <jnthn> Aye.

[18:12] <skids> But we seem to only write them out and then forget about them.

[18:14] <skids> So I was thinking maybe making hash keep the buckets in its own PMC as a union with the bs/bi and other elements, then autoenlarge to a alloced store after.

[18:14] <literal> std: &foo

[18:14] <skids> Also no real reason to use real pointers in the bs, offsets would do and not need relocation.  We can afford the math.

[18:14] <p6eval> std 26622: OUTPUT«ok 00:03 47m␤»

[18:15] <jnthn> We'd get better cache locality with that?

[18:16] <skids> With the mini hashes yes, the pointer thing no, but it would cheapen realloc CPU-wise

[18:16] <skids> And if the offsets could be made a smaller datatype for small chunks, yes

[18:16] <jnthn> Sounds worth exploring/benchmarking.

[18:17] <skids> But once you get that far might as well consider an entirely different hash structure.

[18:17] <skids> It's the sort of think I like to do, and will if I can clear my head of $REAL_WORLD and $DAYJOB often enough.

[18:18] *** lumi joined
[18:18] <skids> But I'm still kinda fuzzy on GC stuff so that leaves me with some unknowns.

[18:20] <skids> Oh, other stats, but may not be from 1.say: inserts:

[18:20] <skids> 28.01 13.69 4.43 3.36 2.76 2.62 1.84 1.67

[18:20] <skids> 6.13% for 63 elements plus

[18:21] <skids> which is probably all const_string

[18:37] <dalek> rakudo: 06f0ae8 | pmichaud++ | :

[18:37] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[18:37] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/06f0ae8b379bb6485f75c538e12c01b6de1cc9df

[18:37] <dalek> rakudo: d4a0b3b | pmichaud++ | docs/spectest-progress.csv:

[18:37] <dalek> rakudo: spectest-progress.csv update: 378 files, 10991 passing, 0 failing

[18:37] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d4a0b3b8b5d3b9fb781ccdd154169d58472fbc06

[18:38] *** kingdong joined
[18:53] *** kingdong left
[18:55] *** rindolf joined
[18:57] *** payload left
[19:32] *** justatheory joined
[19:33] *** finanalyst left
[19:33] *** rindolf left
[19:35] <PhatEddy> @tell jnthn if I recode the pir get in classes/IO.pir pretty much like pop in classes/Array.pir and export with to_p6_multi the "get" setting problem goes away/works.

[19:35] <lambdabot> Consider it noted.

[19:41] *** payload joined
[19:46] *** M_o_C joined
[19:48] *** renormalist joined
[19:56] <s1n> rakudo: sub test($a, %b) { say "oh hai"; }; test('foo', <bar baz>);

[19:56] <p6eval> rakudo d4a0b3: OUTPUT«Parameter type check failed; expected something matching  but got something of type List() for %b in call to test␤current instr.: 'die' pc 16538 (src/builtins/control.pir:225)␤»

[19:56] *** payload left
[19:56] *** payload1 joined
[19:57] <s1n> does <> mean list? i thought i could assign key/value pairs that way

[19:57] *** dukeleto left
[19:58] <s1n> doh, i think  S02 says <a b> is ('a', 'b') and not {'a', 'b'}

[19:59] *** dukeleto joined
[19:59] *** dukeleto left
[20:01] *** payload joined
[20:01] *** payload1 left
[20:03] *** olaf_ joined
[20:04] *** ZuLuuuuuu left
[20:19] *** meteorjay joined
[20:25] <jnthn> s1n: Maybe you wanted :a<b>

[20:25] <lambdabot> jnthn: You have 1 new message. '/msg lambdabot @messages' to read it.

[20:26] <jnthn> @tell PhatEddy ah, sounds like a conflict between Parrot multis and Perl 6 multis then...

[20:26] <lambdabot> Consider it noted.

[20:27] *** amoc^ left
[20:28] *** amoc joined
[20:29] <PhatEddy> jnthn: should I still do a rakudobug?

[20:29] <lambdabot> PhatEddy: You have 1 new message. '/msg lambdabot @messages' to read it.

[20:33] *** ingy left
[20:34] *** ingy joined
[20:37] *** kane_ left
[20:37] *** kane_ joined
[20:38] *** s1n left
[20:43] <meppl> good night

[20:44] *** meppl left
[20:48] *** Whiteknight left
[20:48] *** Whiteknight joined
[21:09] *** dukeleto joined
[21:12] *** ZuLuuuuuu joined
[21:19] *** PacoLinux left
[21:20] *** PacoLinux joined
[21:21] *** DemoPhreak joined
[21:28] *** payload left
[21:28] *** payload1 joined
[21:30] *** olaf_ left
[21:32] *** dduncan joined
[21:34] *** jhuni joined
[21:34] *** DemoFreak left
[21:34] *** DemoPhreak is now known as DemoFreak

[21:52] *** s1n joined
[21:56] *** payload1 left
[21:56] *** payload joined
[22:02] *** rehall joined
[22:04] *** rehall left
[22:07] *** ingy left
[22:09] *** M_o_C left
[22:15] *** iblechbot left
[22:15] *** Kisu joined
[22:16] *** nbrown_ joined
[22:17] *** ingy joined
[22:18] *** nbrown_ left
[22:18] *** nbrown_ joined
[22:18] *** nbrown left
[22:18] *** nbrown_ is now known as nbrown

[22:20] *** rblasch left
[22:28] *** wormphlegm joined
[22:35] *** justatheory left
[22:41] <spx2> can I do a negative offset seek on SEEK_END ?

[23:03] *** renormalist left
[23:20] *** wormphlegm left
[23:24] *** ZuLuuuuuu left
[23:24] *** justatheory joined
[23:25] *** PhatEddy left
[23:31] *** justatheory left
[23:32] *** MariachiElf joined
[23:33] <MariachiElf> rakudo: say 'hi'

[23:33] <p6eval> rakudo d4a0b3: OUTPUT«hi␤»

[23:39] *** Limbic_Region joined
[23:40] <eternaleye> I just had an interesting idea for chaining comparisons on junctions.

[23:44] <eternaleye> Currently, my $a = 1|4|7; my $b = 2|5|8; my $c = 3|6|9; if( a < b < c ) { say ($a, $b, $c).join(' : ') } doesn't dwim. A simple way to make it dwim might be to make the chained comparison autothread like a block, such that $a < $b < c would become 1 < $b < $c, 2 < $b < $c, and 3 < $b < $c. The it would autothread on $b, $c, etc.

[23:45] <eternaleye> *Then

[23:45] <eternaleye> Hm, that if should havce sigils, and shouldn't have parens

[23:46] *** dukeleto left
[23:48] <eternaleye> Then we could make it so that branches taken based on the chained comparison use the autothreaded value, instead of the full junction

[23:53] *** amoc left
[23:56] *** dukeleto joined
[23:56] *** cognominal left
