[00:00] <pugs_svn> r25505 | wayland++ | Fixed S14 link to say "DRAFT"

[00:00] <wayland> Do it poorly, then someone else will do it for you :)

[00:00] <wayland> I presume S14 should be considered in draft mode at the moment

[00:01] <wayland> We can have Larry bless it later, I presume?

[00:02] <jnthn> Aye

[00:03] <wayland> [The "Do it poorly" line was in reference to me motivating others to do stuff :) -- I'm not recommending it to others :)]

[00:04] <jnthn> :-P

[00:04] * jnthn will probably do a Rakudo Day on Wednesday

[00:05] <jnthn> Before I start my conferences and vacation trip. :-)

[00:06] <wayland> well, enjoy all 3 :)

[00:12] *** DemoFreak left
[00:12] *** cas left
[00:13] *** Ariens_Hyperion left
[00:16] <pugs_svn> r25506 | wayland++ | IO.pod: Updated reference to Temporal.pod

[00:16] <pugs_svn> r25506 | wayland++ | S14: Gave credits properly

[00:17] *** skids joined
[00:21] <wayland> jnthn: I think one other thing might help get people writing Perl6 -- S20: Calling foreign code :)

[00:22] <wayland> I'll see if I can't do something on it (but if others want to, let me know; I'm happy that way too :) )

[00:22] <wayland> skids: Hi :)

[00:22] <skids> hi!

[00:25] * skids having another go at trying to figure out STD.pm/YAML::Syck usage.

[00:26] <TimToady> * ** 2 when * !% 2 for 1..*

[00:26] <lambdabot> TimToady: You have 1 new message. '/msg lambdabot @messages' to read it.

[00:28] <jnthn> TimToady: Uh...wtf is that?!

[00:28] <TimToady> pugs: say ( $_ ** 2 if $_ % 2 == 0 for 1..* )[^20]

[00:28] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "if"␤    expecting operator or ")"␤    at /tmp/3E5SMRoUzT line 1, column 15␤»

[00:28] <TimToady> I guess pugs doesn't really do list comprehensions yet

[00:28] <jnthn> Is that the whatever * there?

[00:29] <TimToady> yes

[00:29] <jnthn> What is it meaning here?

[00:29] <jnthn> Whatever ** 2 is?

[00:29] <jnthn> Some kinda stand-in for $_?

[00:30] <TimToady> plus generates {} around it

[00:31] <TimToady> when you say @foo[*-1] it's really @foo[{$_-1}]

[00:31] <jnthn> Around what? The $_ itself? Or the $_ ** 2 ?

[00:31] <jnthn> Ah, OK.

[00:31] <TimToady> and the subscript is handling closure args

[00:31] <TimToady> 1-ary

[00:32] <jnthn> * !% 2 is like * % 2 == 0 ?

[00:32] <TimToady> we defined % as one of the negatable operators

[00:32] <jnthn> Ah, yes, I remember now...

[00:32] <TimToady> it's "iffy"

[00:32] <TimToady> :)

[00:32] <jnthn> That is...disgustingly wonderful...

[00:32] * TimToady bows and falls over sideways

[00:34] <TimToady> but I probably would write {$_ ** 2} for clarity in any case, just because of the proximity of * an d**

[00:34] <jnthn> Yeah

[00:34] <jnthn> I found it rather tricky to parse...

[00:35] <TimToady> well, we're just lucky that * * * doesn't work as a 2-ary :)

[00:35] <jnthn> std: * * *

[00:35] <p6eval> std 25506: OUTPUT«ok 00:02 33m␤»

[00:35] <TimToady> does parse, of course...

[00:35] <TimToady> std: * ** 2 when * !% 2 for 1..*

[00:35] <p6eval> std 25506: OUTPUT«ok 00:02 33m␤»

[00:36] <jnthn> * ** * when * !% 2 for 1..*

[00:36] <jnthn> std: * ** * when * !% 2 for 1..*

[00:36] <p6eval> std 25506: OUTPUT«ok 00:02 33m␤»

[00:36] <TimToady> I just did that

[00:36] <jnthn> Ah, yes.

[00:36] <jnthn> Oh, I see

[00:36] <jnthn> It fails when though?

[00:36] <jnthn> At what stage to we know that * * 2 is OK and * * * is not?

[00:36] <TimToady> the when modifier is just a smartmatching if

[00:37] <TimToady> it doesn't do any break

[00:37] <TimToady> sec...

[00:40] <TimToady> at somepoint we dispatch infix:<**>(*,2) and it finds a multi with an appropriate Whatever sig

[00:41] <TimToady> but there is no (Whatever,Whatever) defined

[00:41] <jnthn> Ah, OK.

[00:41] <jnthn> So likely runtime/dispatch time failure.

[00:41] <TimToady> this can probably be known at compile time unless someone adds in a pragma to search packages

[00:42] <TimToady> but we're trying to limit multis by default to only look in lexical scopes

[00:42] <jnthn> *If* we know all the multi variants...

[00:42] <jnthn> Can't you eval('multi infix:<**>(Whatever $x, Whatever $y) { 42 }') though?

[00:42] <TimToady> we know that lexical scopes are closed at CHECK time

[00:42] <pugs_svn> r25507 | wayland++ | S31: Collected the pragmata from everywhere, and listed them here with cross-references

[00:43] <TimToady> multis in packages are basically ignored right now

[00:43] <jnthn> Ah.

[00:43] <jnthn> We're probably getting that very wrong in Rakudo then. :-(

[00:43] <TimToady> "is export" puts things into lexical scopes by deflut

[00:43] <TimToady> *default

[00:43] <TimToady> probably; we weren't clear on this till the past year or so

[00:44] <jnthn> For a definition of "probably" along the lines of "certainly, I wrote it and know full well it's wrong, just in denial about having to fix it" :-)

[00:44] <pugs_svn> r25508 | wayland++ | Added link to S31

[00:44] <TimToady> :)

[00:44] <jnthn> On a related note

[00:45] <jnthn> class Foo { eval('method bar() { 42 }') }

[00:45] <jnthn> What's this count as?

[00:45] <jnthn> (Someone submitted a Rakudo ticket with this in...people do the oddest things...)

[00:46] <TimToady> well, the question is exactly when does that block run

[00:46] <jnthn> I suspect after class composition time.

[00:46] <TimToady> and I think it runs once at class composition time, so the eval is essentially useless

[00:46] <TimToady> yes

[00:47] <TimToady> though it might give you a little switchability at that point

[00:47] <TimToady> but methods aren't really a big problem, since they're late dispatched anyway

[00:48] <TimToady> there's something fundamental going on here

[00:48] <jnthn> It'd be a minor pain to make it work (as in, add the method to the class).

[00:48] <TimToady> single-dispatch OO is independent of the current language, more or less

[00:48] <TimToady> so it's run-time dispatched to whatever the current class says

[00:48] <jnthn> But it'd be too late to resolve a conflict with a role...

[00:48] <TimToady> multi-dispatch is fundamentally defining the language

[00:48] <TimToady> so wants to be lexically scoped

[00:49] *** eternaleye joined
[00:49] <jnthn> Yes, I agree with the design call on that. :-)

[00:49] <TimToady> it's sort of the way C++ ought to have been, the part where you want some non-virtual methods, but not as single dispatch

[00:50] <TimToady> hence the distinction between multi dispatching even +$x unaries, because numification is a language choice, not an object choice

[00:50] <jnthn> Aye.

[00:50] <TimToady> vs $x."+" or whatever

[00:50] <TimToady> which would be the object's choice of + method

[00:50] <jnthn> Can you do that?

[00:51] <TimToady> std: $x."+"

[00:51] <p6eval> std 25508: OUTPUT«Potential difficulties:␤  Variable $x is not predeclared at /tmp/paprm8vcnE line 1:␤------> [32m[31m$x."+"[0m␤ok 00:04 33m␤»

[00:51] <jnthn> As in, wouldn't you have to write $x.prefix:<+> ?

[00:51] <TimToady> no, that would be the multi version again

[00:51] <jnthn> Is that not single dispatch first, still?

[00:52] <jnthn> As in, aren't prefix:<+>($x) and $x.prefix:<+>($x) different?

[00:53] <TimToady> I suspect that gets forced back into multi dispatch, since most other languages won't have the foggiest idea what to do with a method name like that

[00:53] <jnthn> (In the sense that the first is a multi-dispatch right off the bat, and the second is a method dispatch, followed by a multi-dispatch unless the class $x is an instance of defines an only infix:<+>

[00:53] <jnthn> Hmm, true...

[00:53] <pugs_svn> r25509 | wayland++ | S16: Referred to other documents

[00:53] <pugs_svn> r25509 | wayland++ | IO.pod: Got rid of filetest pragma

[00:54] <TimToady> anyway, we're intending the ."foo" notation as a way of constructing non-standard method names for the consumption of other languages

[00:54] <TimToady> since most of those languages don't make prefix/infix distinctions

[01:03] *** nihiliad joined
[01:07] <TimToady> so anyway, the .prefix and .infix forms might be considered macros like WHAT, perhaps

[01:09] <TimToady> also, we allow .:<+> as a short form of .prefix:<+>, which can be really handy when you just want to move the prefix to the end

[01:10] <TimToady> now that &[+] is allowed for the infix functional form, maybe .:[+] could be used for a multi infix in dotty form

[01:11] <TimToady> though there's less call for that, since that's where you'd put the infix anyway

[01:11] <TimToady> (albeit with precedence differences)

[01:11] <TimToady> well, I blathering

[01:12] <TimToady> my brane is in sideways at the moment, I think

[01:13] * araujo scratches his head

[01:13] <jnthn> They're just fancy ways of re-writing method names, they're not so hard to add.

[01:13] <TimToady> except if they're macros...

[01:13] <jnthn> But yes, macros could be the way to go.

[01:14] <jnthn> Apart from, we kinda don't have 'em in Rakudo.

[01:14] <jnthn> Is STD.pm handling them at all yet?

[01:14] <TimToady> well, there is that...

[01:14] <wayland> One document claims that $=foo is a file-scoped variable, and another claims that it's a POD variable.  Can someone clarify this?

[01:14] <jnthn> Or rather, do you expect STD.pm to have the infrastructure in for handling macros?

[01:14] <TimToady> std: (my $x = '').:<+>

[01:15] <TimToady> oh, macros

[01:15] <p6eval> std 25509: OUTPUT«ok 00:02 34m␤»

[01:15] <TimToady> at the moment it only has the part where it introduces names like infix:<op> into the lexical pad

[01:15] <TimToady> but macros actually have to run code at compile time

[01:15] <TimToady> so we really need a more-or-less full bootstrap of STD before we can do that

[01:16] <jnthn> Ah, yes.

[01:16] <TimToady> at least, the user-defined macros

[01:16] <TimToady> but we can do anything as grammar rules currently

[01:17] <TimToady> so .WHAT and such can certainly be parsed that way

[01:17] <jnthn> Do they not essentially install "stuff" into the grammar once they're parsed, though?

[01:17] <jnthn> e.g. new tokens etc?

[01:17] <TimToady> that part works already

[01:17] <jnthn> Aha, OK, cool.

[01:17] <TimToady> std: sub infix:<***> {...}; $a *** $b

[01:18] <jnthn> So "all" that's left is triggering the code and doing the relevant insertion into the parse tree/parse buffer?

[01:18] <p6eval> std 25509: OUTPUT«Potential difficulties:␤  Variable $a is not predeclared at /tmp/5s8cT1btHz line 1:␤------> [32msub infix:<***> {...}; [31m$a *** $b[0m␤  Variable $b is not predeclared at /tmp/5s8cT1btHz line 1:␤------> [32msub infix:<***> {...}; $a *** [31m$b[0m␤ok 00:05 38m␤»

[01:18] <TimToady> heh

[01:18] <TimToady> std: sub infix:<op> {...}; 42 op 24

[01:18] <jnthn> Is STD.pm handling "is parsed" yet also?

[01:19] <p6eval> std 25509: OUTPUT«ok 00:03 34m␤»

[01:19] <TimToady> that's just a standard trait, but it doesn't do anything with it

[01:19] <jnthn> Surely it somehow "extends" (I'm probably epic fail on the terminology here) the grammar, though?

[01:19] <TimToady> std: macro postfix:<WHAT> is parsed(/whatever/) {...}

[01:20] <p6eval> std 25509: OUTPUT«ok 00:04 37m␤»

[01:21] <jnthn> std: macro foo is parsed(/'?*?'/) { ... }; ?*?

[01:21] <TimToady> it's the postfix:<WHAT> that extends the grammar, but it will just parse as a standard postfix regardless of what "is parsed" says currently

[01:21] <p6eval> std 25509: OUTPUT«############# PARSE FAILED #############␤Obsolete use of ?: for the conditional operator; in Perl 6 please use ??!! instead at /tmp/2PiT7q65Bg line 1:␤------> [32macro foo is parsed(/'?*?'/) { ... }; ?*?[31m[0m␤FAILED 00:03 35m␤»

[01:21] <jnthn> OK.

[01:22] <TimToady> and you really need to tell it the grammatical category on a macro so it knows what state to leave it in afterward

[01:23] <TimToady> I suppose "macro foo" could default to "macro term:<foo>" though

[01:24] <jnthn> Ah, true.

[01:24] <TimToady> std: sub term:<[[[> {...}; [[[ + [[[

[01:24] <p6eval> std 25509: OUTPUT«ok 00:03 37m␤»

[01:25] <jnthn> Sick. :-)

[01:25] * TimToady bows and falls over the other direction this time

[01:26] <TimToady> std: sub prefix:<[[[> {...}; [[[ + [[[

[01:26] <p6eval> std 25509: OUTPUT«############# PARSE FAILED #############␤Can't understand next input--giving up at /tmp/rXNexAjDqf line 0:␤------> [32m[31m[0m␤    expecting any of:␤     circumfix␤        noun␤FAILED 00:03 35m␤»

[01:26] <TimToady> std: sub prefix:<[[[> {...}; [[[ + [[[ 42

[01:26] <p6eval> std 25509: OUTPUT«ok 00:03 35m␤»

[01:26] <jnthn> It's presumably parsing as prefix:<+> there?

[01:27] <TimToady> I think that's the default

[01:27] <TimToady> or is it ++

[01:27] <TimToady> symbolic unary, so +

[01:27] <TimToady> or !

[01:28] <TimToady> it also ignores equiv and friends currently

[01:28] <TimToady> again, trait handling requires a run-time :)

[01:29] <TimToady> well, doing it right does

[01:29] <TimToady> didn't stop me from cheating on enums though :)

[01:29] <jnthn> ;-)

[01:30] <jnthn> OK, it's later than I really should be concious...

[01:30] * jnthn sleeps

[01:30] <TimToady> night

[01:30] <jnthn> night, thanks for chat :-)

[01:32] <wayland> 'night jnthn

[01:33] <wayland> Oh, are $= variables file scoped, but considered POD variables because POD auto-creates them?

[01:33] <wayland> ie. could I do $=foo = "text", and have that work, but be an unusual usage?

[01:33] <TimToady> the design of $= variables is not really finalized

[01:33] <wayland> ok

[01:33] <wayland> :)

[01:33] <TimToady> we're just reserving the twigil

[01:34] <TimToady> might just be a big hash under %=POD or some such, who knows what Damian will come out with eventually

[01:34] <wayland> Ok.  

[01:35] <TimToady> though I'd guess we want to use the namespace directly for something

[01:36] <wayland> There was talk about how we might unify some of the special variables into $?ENV and $*ENV.  How would that work?  $ENV.OS or something?

[01:36] <TimToady> and we definitiely want the self-documenting aspect of the twigil

[01:36] <TimToady> to alert people to the abnormalcy of the data source

[01:36] <wayland> That makes sense :)

[01:36] <TimToady> $?ENV and $*ENV have nothing to do with each other

[01:37] <TimToady> $?ENV would be the environment of the compiler at that point in compilation

[01:37] <TimToady> $*ENV is the environment of the run time

[01:37] <TimToady> all ? vars are constants at run time

[01:37] <wayland> Yah, I know that.  That should've been $?ENV.OS (with alternatives being things like %*ENV{'OS'} or something)

[01:38] <TimToady> well, people aren't in the habit of setting OS in the environment, so it doesn't seem like it belongs

[01:38] <wayland> Or do we want things like $*ENV.operatingsystem ?

[01:38] <TimToady> and it's something you probably want a top-level name for

[01:38] <wayland> ok

[01:39] <wayland> It's just there's this comment in S28 that came from somewhere...

[01:39] <TimToady> ENV should reflect more or less what the environment vars are used for already

[01:39] <wayland> It said that you liked the idea of putting lots of other things in $*ENV, and then putting environment variables in $*ENV.environment

[01:40] <wayland> Maybe you've changed your mind :)

[01:40] <TimToady> the idea doesn't sound familiar to me at the moment, but it could just be senility

[01:40] <TimToady> or migraine...

[01:40] <TimToady> I'm one of those fortunate few who get painless migraines

[01:41] <TimToady> but all the miasma that goes with, I get to deal with

[01:41] * araujo finally understands why perl is like this

[01:42] <wayland> Ouch.  Anyway, it's currently in S28, http://svn.pugscode.org/pugs/docs/Perl6/Spec/S28-special-variables.pod at the bottom of the named variables section

[01:43] <TimToady> I see that, but I was probably agreeing that we wanted something more like we ended up with context vars

[01:43] <TimToady> where the program's dynamic scopes can set up little environments

[01:44] <wayland> OK

[01:44] <TimToady> or maybe I was just nodding my head the way people do when they don't really understand :)

[01:44] <wayland> :)

[01:45] <wayland> What would you say to something like %*PROC{PID}, %*PROC{UID}, and that sort of thing?

[01:45] <wayland> Or do you like them better the way they are? :)

[01:45] *** dukeleto joined
[01:46] *** sri_kraih joined
[01:47] *** sri_kraih left
[01:47] <TimToady> there are several competing design notions here

[01:47] <TimToady> we'd like to minimize globals that have to be set up in advance, but we'd also like to huffmanize common vars like $*PID

[01:48] <TimToady> I suppose some of these things could just be stubs in PROCESS:: or GLOBAL:: that lazily calculate if necessary

[01:49] <TimToady> not necessary for $*PID, since that's just a number known at startup

[01:49] <wayland> ok.  

[01:49] <TimToady> could even be autoloaded names, which PROCESS:: gets interrogated

[01:50] <TimToady> so just exists as a when 'PID' somewhere until someone actually asks for $*PID

[01:51] <TimToady> we've already got several ways to be lazy if we need to

[01:51] <wayland> ok.  I'm in the process of trying to knock S28 into shape :), so I'm mainly worried about labels.  But the autoload idea is cool :)

[01:51] <wayland> ("labels" used loosely here :) )

[01:52] <TimToady> to the extent possible, just try to attach things to the right namespace or object, and then delegate to that namespace or object

[01:52] <TimToady> course, if it's an object, it doesn't belong in S28 any more

[01:53] <TimToady> so $*VM can delegate everything to class VM_Descriptor or whatever...

[01:54] <TimToady> and as for which object attrs really ought to huffmanize upward, we'll just have to deal with that on a case-by-case basis

[01:54] <TimToady> much like deciding what is imported into CORE scope defines the standard Perl 6 langauge

[01:54] <wayland> Ok, I'll try to keep all that in mind :)

[01:55] <TimToady> easy things easy, hard things possible...

[01:55] <TimToady> course, deciding which is which is hard

[01:55] <wayland> :)

[01:56] <wayland> I'll try to keep that in mind too.

[01:56] <TimToady> and that natural languages generally prefer that principle over consistency :)

[01:57] <TimToady> which is why your most common verbs are the most irregular

[01:57] <wayland> Interesting :)

[01:57] <TimToady> recomended reading: The Search for the Perfect Language, by Umberto Eco

[01:58] <TimToady> s/m/mm/

[01:59] *** Maghnus left
[01:59] *** Maghnus- joined
[01:59] *** Maghnus- is now known as Maghnus

[02:00] <TimToady> Eco does a great job of explaining *why* you don't want absolute consistency in a language

[02:00] <TimToady> (in addition to why it can't be achieved in the first place)

[02:00] <wayland> Ok, I'll add it to my reading list :).  Looks interesting.  

[02:00] *** alc joined
[02:00] <TimToady> it's about all the people trying to invent "philosophical languages"

[02:01] <TimToady> like Wilkens, et al.

[02:01] <TimToady> but has great applicability to computer language design nonetheless

[02:02] <wayland> :).  I remember someone asking Damian why he wrote his "Perl in Latin" thing in Latin instead of Esperanto :)

[02:02] <TimToady> well, he knows Latin, for one...

[02:03] <TimToady> but Latin also has all the lovely declensions and cases and such

[02:03] <TimToady> me, I'd do it in Greek if I did it

[02:04] <s1n> moritz_: take a look at ef8bb8a9bbc102a2aa96af93b81ee513eb8f4158 again

[02:04] <s1n> specifically, Range.pir:41

[02:04] <s1n> it does a to/from on the topic

[02:04] <s1n> as well as self

[02:04] <wayland> knowing Latin was Damian's reason.  I was under the impression that Esperanto did cases, etc, too.  

[02:04] * wayland checs Wikipedia page

[02:05] <wayland> s/checs/checks/

[02:05] <s1n> moritz_: i believe all i did was move the ACCEPTS method directly to setting

[02:05] <TimToady> but it might be too regular to map well onto Perl 5

[02:05] <s1n> moritz_: to say it doesn't work means that i didn't move it over from setting correctly

[02:05] <TimToady> Esperanto, not Greek

[02:06] *** iblechbot left
[02:06] <TimToady> Latin and Greek both provide "enough rope"

[02:07] <TimToady> decommuting &

[02:07] <wayland> bye, and thanks :)

[02:10] <s1n> jnthn: ping

[02:10] * skids thinks when a nice, short, mnemonically advantageous, keyword is available from a language other than english, heck, use it.

[02:11] <skids> e.g. the opposite of "init" isn't exit, it's "fini" :-)

[02:12] <dukeleto> skids: +1

[02:14] *** justatheory_ joined
[02:14] <s1n> skids: no, init is an abbreviation for initialize, the opposite of that is terminate or better yet finalize

[02:14] <s1n> i believe fini is the italian equiv, which init is not

[02:15] <s1n> unless fini is not italian, or some other non-english-yet-latin translation, then you would be right

[02:16] <skids> Yes, but fini does mean finish/finalize, is easily recognizable for english speakers, and makes a nice graphically matched pair with init, even though they are from different natrual languages.

[02:17] *** justatheory left
[02:17] <s1n> no see, as an english speaker, i can choose to abuse my own language all i want at the risk of avoiding foreign languages like the plague :)

[02:17] <s1n> therefore, exit seems to look better to me :)

[02:19] <skids> heheh.  Actually for edification, fini in italian is "fine", it is finish in french, and in esperanto, and apparently is colloquially used in german speaking populations as finish.

[02:20] <skids> And I have no clue what fini is in Finnish.

[02:20] <s1n> case in point, fini is a bad choice simply because it would require me, a native english speaker, to have to interact with other languages

[02:20] <skids> What you never say "voila!" ?

[02:21] <s1n> usually only in a mocking tone :)

[02:22] <skids> OK fine think of it as "init" spelled backwards and upside down, then.

[02:26] *** frooh joined
[02:26] *** frooh left
[02:26] *** frooh joined
[02:27] <frooh> rakudo: my $foo = { bar => 'baz' }; $foo->{bar};

[02:27] <p6eval> rakudo 2a9382: OUTPUT«Statement not terminated properly at line 1, near "->{bar};"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[02:27] <frooh> rakudo: my $foo = { bar => 'baz' }; $foo.{bar};

[02:27] <p6eval> rakudo 2a9382: OUTPUT«Could not find non-existent sub bar␤current instr.: '_block14' pc 99 (EVAL_18:46)␤»

[02:27] <frooh> rakudo: my $foo = { bar => 'baz' };

[02:27] <p6eval> rakudo 2a9382: RESULT«{"bar" => "baz"}»

[02:28] <frooh> rakudo: my $foo = { bar => 'baz' }; $foo{bar};

[02:28] <p6eval> rakudo 2a9382: OUTPUT«Could not find non-existent sub bar␤current instr.: '_block14' pc 99 (EVAL_16:46)␤»

[02:28] <frooh> rakudo: my $foo = { bar => 'baz' }; $foo{'bar'};

[02:28] <p6eval> rakudo 2a9382: RESULT«"baz"»

[02:28] <frooh> rakudo: my $foo = { bar => {baz=>'bop'} }; $foo{'bar'};

[02:28] <p6eval> rakudo 2a9382: RESULT«{"baz" => "bop"}»

[02:28] <frooh> rakudo: my $foo = { bar => {baz=>'bop'} }; $foo{'bar'}{'baz'};

[02:29] <p6eval> rakudo 2a9382: RESULT«"bop"»

[02:29] <frooh> Can anyone here tell me if that's actually a hashref?

[02:30] <skids> rakudo: my $foo = { bar => {baz=>'bop'} }; $foo.WHAT;

[02:30] <p6eval> rakudo 2a9382: RESULT«Hash»

[02:30] <TimToady> we try not to talk about references, though yes, it is one

[02:30] <frooh> TimToady: why not?

[02:31] <TimToady> most of the time you just want to think about the object involved

[02:31] <TimToady> so it's just a Hash

[02:31] <frooh> also: That's great.  My coworkers are always confused about reference based data structures

[02:31] <frooh> right

[02:31] <frooh> which is good

[02:31] <TimToady> and most of the syntax lets you ignore the ref distinction, unlike in p5

[02:31] <frooh> clearly

[02:32] <frooh> and you told me that functions can specify that they want a ref in their signature so that we won't have to tell users to pass hash refs, right?

[02:32] <frooh> so it auto refs it

[02:32] <TimToady> if you say sub foo (@foo) it's expecting an array ref to bind to @foo

[02:33] <TimToady> and you just call it foo(@bar) to pass that ref

[02:33] <TimToady> since an array or hash in item context just returns itself

[02:33] <frooh> was the space in the previous line intentional/

[02:33] <frooh> or do spaces matter in function definitions?

[02:33] <TimToady> the space is optional in the declaratoin, but not in the call

[02:33] <frooh> got it

[02:35] <pugs_svn> r25510 | lwall++ | [STD] clarify the general principle in the if() catcher

[02:38] *** Whiteknight left
[02:47] <pugs_svn> r25511 | leto++ | Tests for rounding NaN and Inf

[02:49] *** agentzh left
[02:54] *** Maghnus- joined
[02:54] *** carpftb joined
[02:58] *** aindilis` left
[03:08] *** justatheory joined
[03:08] *** justatheory_ left
[03:10] *** Maghnus left
[03:10] *** Maghnus- is now known as Maghnus

[03:18] *** japhb joined
[03:23] *** agentzh joined
[03:33] <TimToady> std: if(42) {...}

[03:33] <p6eval> std 25511: OUTPUT«############# PARSE FAILED #############␤if() interpreted as function call at line 1 ; please use whitespace instead of parens␤Unexpected block in infix position (two terms in a row) at /tmp/RBiSTsDjBi line 1:␤------> [32mif(42) [31m{...}[0m␤    expecting any of:␤    infix or

[03:33] <p6eval> ..met...

[03:36] <frooh> is that supposed to happen?

[03:40] *** frooh left
[03:47] *** cspencer joined
[03:50] <TimToady> yes

[03:58] <skids> TimToady: WRT the :kv, :p etc adverbs, obviously %a{}:p{}:p is a parsing ambiguity and probably not very useful.  But is %a{}{}:p to be allowed or do we want to demand %a{;}:p always?

[04:00] *** dduncan joined
[04:00] *** dduncan left
[04:01] *** hercynium left
[04:11] <pugs_svn> r25512 | putter++ | [elfparse] EXPR porting continues.

[04:14] *** cspencer left
[04:15] *** cspencer joined
[04:17] <wayland> TimToady: Have we clarified $*MOST_RECENT_CAPTURED_MATCH vs. $/[-1] vs. $/[-$n] yet?

[04:32] *** hello\n joined
[04:36] <pugs_svn> r25513 | lwall++ | kill DEF* variants

[04:36] <TimToady> [-1] is almost always wrong

[04:38] <TimToady> %a{}:p %a{}{}:p %a{}{}{}{}{}{}{}:p all mean the same thing, since {} is a noop

[04:40] <skids> OK then,  %a{1,2}{2,3}:p 

[04:40] <TimToady> and I have no idea what you're intending by %a{;}, which looks like a two-dimensional null slice

[04:41] <skids> What's the preferred thing to jam in there to be clear you don't care what's in the {}'s  -- ... ?

[04:41] <TimToady> what kind of "don't care" are you not caring?

[04:41] <TimToady> what are you trying to do?

[04:41] *** sahadev1 joined
[04:42] <skids> Figure out whether the adverbs will be legal to apply to the old fashioned nested slices.

[04:42] <TimToady> adverbs apply to the topmost operator in scope, which for postfixes means the final one

[04:42] <skids> And I'm brouwsing try5 output and getting the impression that they are already in there as intended (?)

[04:44] *** nihiliad left
[04:45] <TimToady> hmm, haven't use try5 in months; I generally use viv

[04:45] <wayland> Btw, TimToady, I'm currently doing lots of the same things as your last commit :)

[04:45] <TimToady> I believe STD already parses them as intended, though of course I could be wrong :)

[04:45] <TimToady> where did you get that fossil about $FOO usually meaning the same as $*FOO?

[04:46] <TimToady> that hasn't been true for years...

[04:46] <skids> Thanks, I'll try that out.  Since you didn't seem to bat an eye at using them on the last in a nested bracket pair, I would say yes it looks like STD handles them like that.

[04:46] <TimToady> note, however, that if you say +%s{}:p it applies to the + rather than the subscript

[04:47] <TimToady> so you'd have to say +(%s{}:p) in that case

[04:47] <TimToady> not that that makes sense...

[04:47] <wayland> From one of the previous attempts at S28, I suspect :)

[04:47] <TimToady> ah

[04:48] <TimToady> which presumably dated from the Pugsian Era

[04:48] <skids> OK, so prefix ops suck up adverbs more greedily than postfix/postcircumfix.

[04:48] <TimToady> it's not about greed

[04:48] <TimToady> except insofar as precedence codifies it

[04:48] <skids> Or well I guess greed is an overloaded word

[04:48] <wayland> Oh, some of this stuff is definitely the Pugs era, which I was never very au fait with

[04:49] <TimToady> basically, the adverb is applied as a unary modifier on whatever top-level node is on the left

[04:49] <TimToady> which that is determined by precedence

[04:49] <TimToady> and generally conforms to the temporally last thing evaluated

[04:49] <skids> got it.

[04:49] <TimToady> that is tighter than =

[04:53] <TimToady> all this applies to %foo<key>:delete and %foo<key>:exists as well

[04:53] <TimToady> you probably see those more often

[04:53] <TimToady> which is odd, since they're huffman code longer

[04:53] <TimToady> *coded

[04:53] <TimToady> probably means :p should be :pairs

[04:54] *** Avada joined
[04:56] <pugs_svn> r25514 | wayland++ | Added a note about @*ARGS

[04:58] <pugs_svn> r25515 | wayland++ | Added some things taken from the S28 sources.  

[05:01] <skids> Would :p:delete and :delete:p both be valid?  And would we honor weird stuff like :kv:p?

[05:03] *** masak joined
[05:04] <pugs_svn> r25516 | lwall++ | more DEF extermination

[05:05] <TimToady> it would depend on how the multisigs are written

[05:05] <TimToady> they're just name arguments

[05:06] <TimToady> *named

[05:06] <TimToady> I expect :kv and :p would be exclusive

[05:07] <TimToady> but :delete:p would mean delete the entries and return them as pairs, which seems orthogonal

[05:07] <skids> so order cannot matter, if I get you...

[05:07] <TimToady> they're not supposed to, which is reportedly one of the benefits of named args :)

[05:07] <skids> :)

[05:08] <TimToady> evacuate quickly and quietly vs evacuate quietly and quickly

[05:09] <TimToady> could well be that the modified subscript op is written in terms of *%_ and it just looks for %_<delete> etc itslef

[05:10] <TimToady> then maybe there's a fast unmodified def for normal subscripting

[05:10] <pugs_svn> r25517 | wayland++ | -  Made twigils short (see S02 for full doco).

[05:10] <pugs_svn> r25517 | wayland++ | -  Rearranged main variable list

[05:11] <TimToady> or just :$p, :$delete, :$exists as separate args, but that seems a little strange

[05:11] <TimToady> s/args/params/

[05:13] <pugs_svn> r25518 | lwall++ | redelete fossil

[05:14] <skids> If I get that far, I'll just try to do what seems best for the most useful cases and later it can always be modified.

[05:17] <pugs_svn> r25519 | wayland++ | Lots of general reoganisation.  Still needs lots more work, and I will continue when I get 

[05:17] <pugs_svn> r25519 | wayland++ | the chance (probably tomorrow).  Hope I haven't reintroduced any old artifacts again :).  

[05:18] <wayland> Thanks all.  I'm going to disappear until tomorrow :)

[05:19] * skids heading bedward too, obviously up too late the enzyte commercials are on.

[05:22] <s1n> moritz_: please let me know what, if anything, you think i did wrong that hadn't already been done in the PIR version

[05:22] <s1n> bed&

[05:35] *** Tene_ joined
[05:40] *** Avada left
[05:44] *** hello\n left
[05:48] *** Tene left
[06:04] * masak appreciates the death of *DEF

[06:19] <masak> rakudo: subset Percentage of Int where { 0 <= $^perc <= 100 }; sub set_percentage(Percentage $perc is rw, Int $value) { try { return $perc = $value; CATCH { return $perc = 0 if $value < 0; return $perc = 100 } } }; my Percentage $p; say set_percentage($p, 50); say set_percentage($p, 101)

[06:19] <masak> the above hangs on my box.

[06:20] <p6eval> rakudo 2a9382: No output (you need to produce output to STDOUT)

[06:20] <TimToady> probably infinite regress on the test

[06:20] <masak> but it shouldn't, right?

[06:21] <TimToady> is the the bug where an error thrown in a handler gets recaught?

[06:21] <masak> might be.

[06:21] <masak> I know it hangs during the second call.

[06:21] <masak> rakudo: subset Percentage of Int where { 0 <= $^perc <= 100 }; sub set_percentage(Percentage $perc is rw, Int $value) { try { return $perc = $value; CATCH { return $perc = 0 if $value < 0; return $perc = 100 } } }; my Percentage $p; say set_percentage($p, 101)

[06:22] * masak tries to minimize the example locally

[06:22] <p6eval> rakudo 2a9382: No output (you need to produce output to STDOUT)

[06:27] <masak> I've now minimized away the subset. :)

[06:28] <masak> rakudo: sub s { try { return 1; CATCH { return 2 } } }; say s

[06:29] <masak> OK, seems like the try block catches return exceptions.

[06:29] <p6eval> rakudo 2a9382: No output (you need to produce output to STDOUT)

[06:29] * masak submits rakudobug

[06:39] <masak> rakudo: package A { sub foo { say "OH HAI" } }; A.foo # should this work?

[06:39] <p6eval> rakudo 2a9382: OUTPUT«Null PMC access in getprop()␤current instr.: 'parrot;P6object;HOW' pc 60 (runtime/parrot/library/P6object.pir:98)␤»

[06:40] <masak> the :: form works.

[06:40] <masak> rakudo: package A { sub foo { say "OH HAI" } }; A::foo

[06:41] <p6eval> rakudo 2a9382: OUTPUT«OH HAI␤»

[06:44] <masak> I guess A.foo above should not work, since foo is not a method on the package object A.

[06:45] <masak> rakudo: package A {}; A.foo

[06:46] *** ashizawa joined
[06:46] <p6eval> rakudo 2a9382: OUTPUT«Null PMC access in getprop()␤current instr.: 'parrot;P6object;HOW' pc 60 (runtime/parrot/library/P6object.pir:98)␤»

[06:48] *** f00li5h is now known as f00li5h[hireme]

[06:48] <masak> rakudo: method foo { say self }; foo(5)

[06:48] <p6eval> rakudo 2a9382: OUTPUT«5␤»

[06:49] <masak> hah.

[06:49] *** sahadev1 left
[06:49] <masak> a regression.

[06:49] * masak is pretty sure he's filed a ticket against that once already

[06:53] *** zamolxes left
[06:57] *** oskie joined
[07:00] <masak> RT is flaky today.

[07:16] *** cspencer left
[07:26] *** justatheory left
[07:48] <masak> perl6: my $b = True; --$b; say $b

[07:48] <p6eval> elf 25519: OUTPUT«No viable candidate for call to multimethod prefix__45_45($) at (eval 120) line 4␤ at ./elf_h line 4346␤»

[07:48] <p6eval> ..rakudo 2a9382: OUTPUT«Method 'pred' not found for invocant of class ''␤current instr.: 'parrot;Perl6Object;' pc 1594 (src/classes/Object.pir:696)␤»

[07:48] <p6eval> ..pugs: OUTPUT«0␤»

[07:48] <masak> who's right, Pugs, or those other two whiney implementations? :P

[08:01] *** meppl joined
[08:08] *** iblechbot joined
[08:18] <Maghnus> perl6: my $b = False; --$b; say $b

[08:18] <p6eval> elf 25519: OUTPUT«No viable candidate for call to multimethod prefix__45_45($) at (eval 120) line 4␤ at ./elf_h line 4346␤»

[08:18] <p6eval> ..rakudo 2a9382: OUTPUT«Method 'pred' not found for invocant of class ''␤current instr.: 'parrot;Perl6Object;' pc 1594 (src/classes/Object.pir:696)␤»

[08:18] <p6eval> ..pugs: OUTPUT«-1␤»

[08:19] *** dalek left
[08:20] *** dalek joined
[08:20] <Matt-W> Good morning

[08:21] <pugs_svn> r25520 | moritz++ | [t/spec] various small improvements, and tests for $str.index("0")

[08:22] <moritz_> Matt-W: you wanted to see Str.split in pure Perl? then git-pull now ;-)

[08:23] <masak> Matt-W, moritz_: morning, M-s :)

[08:23] <TimToady> comb was written in P6 for pugs too

[08:24] <TimToady> albeit P6 code that pugs could grok

[08:24] <masak> in the interests of release-early, here's my take on SVG for Perl 6: http://github.com/masak/svg/blob/63f52591635b584eca9d4f1d1887f48fcdd1353c/svg-example

[08:25] <moritz_> TimToady: I also wrote comb in Perl 6

[08:25] <masak> much remains to be done, but I'd be happy to receive comments on what's already there.

[08:25] <moritz_> TimToady: it's just a bit ugly right now, because rakudo doesn't support the :pos modifier yet, so I have to destruct the string piece-wise, so .from and .to in the match objects are wrong

[08:25] <moritz_> still, it's a start

[08:26] <TimToady> why do you have to destruct the string at all?  does rakudo support :g?

[08:27] <moritz_> no

[08:27] <masak> it doesn't?

[08:27] <moritz_> rakudo doesn't parse any adverbs

[08:27] <moritz_> rakudo: say "abc" ~~ m:g/\w/

[08:27] <TimToady> even inside the regex?

[08:27] <p6eval> rakudo 2a9382: OUTPUT«Statement not terminated properly at line 1, near "\\w/"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[08:27] <moritz_> rakudo: say "abc" ~~ m/:g \w/

[08:27] <p6eval> rakudo 2a9382: OUTPUT«a␤»

[08:27] <masak> rakudo: my $s = "aaa"; say $a.subst('a', 'b', :g)

[08:27] <p6eval> rakudo 2a9382: OUTPUT«Scope not found for PAST::Var '$a' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[08:27] <masak> rakudo: my $s = "aaa"; say $s.subst('a', 'b', :g)

[08:27] <p6eval> rakudo 2a9382: OUTPUT«bbb␤»

[08:28] <moritz_> ah, wicked

[08:28] <moritz_> I could do something like this:

[08:28] *** DemoFreak joined
[08:28] <moritz_> $s.substr($regex, { take $_ }, :g)

[08:29] <moritz_> for $str.comb

[08:29] <masak> .subst

[08:29] <moritz_> right

[08:29] <TimToady> might be easier to hack in :pos :)

[08:30] <TimToady> or sneak in a . ** { $pos } somehow

[08:31] <moritz_> you can't access outer vars in regex closures :(

[08:31] <Matt-W> moritz_: I'll take a look

[08:31] <TimToady> I said "sneak", not "do it right" :)

[08:32] <TimToady> or write an extra [.*?pattern]* inside

[08:33] <moritz_> well, it mostly works for now, so I'll leave it as-is until somebody implements :pos or :g (or sneaks them in ;-)

[08:33] <TimToady> rakudo: say "abc" ~~ m/[.*?(\w)]*/

[08:33] <p6eval> rakudo e074bf: OUTPUT«abc␤»

[08:34] <TimToady> rakudo: say ("abc" ~~ m/[.*?(\w)]*/).join(' ')

[08:34] <p6eval> rakudo e074bf: OUTPUT«a b c␤»

[08:34] <TimToady> there you go

[08:34] <Matt-W> moritz_: why say $limit = * in the argument list, and then turn that into Inf in the body? Why not just have Inf be the default value?

[08:34] <moritz_> Matt-W: because it's specced to be *

[08:34] <masak> rakudo: my $foo = "b"; say "aaa".subst("a", { $foo }, :g)

[08:34] <p6eval> rakudo e074bf: OUTPUT«_block26_block26_block26␤»

[08:34] <moritz_> Matt-W: and because $str.split(m/.../, *) has to work

[08:35] <Matt-W> moritz_: okay, fair enough

[08:35] <TimToady> my solution above will have correct .from and .to

[08:35] *** bacek_ left
[08:35] <Matt-W> moritz_: Looks nice, I really need to play around with gather/take

[08:35] <moritz_> TimToady: nice

[08:36] *** ejs joined
[08:36] <moritz_> rakudo: say ("abc" ~~ m/[.*?(<.before \w>)/).join('|')

[08:36] <p6eval> rakudo e074bf: OUTPUT«Statement not terminated properly at line 1, near "/[.*?(<.be"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[08:36] <moritz_> TimToady: now if I could interpolate into a regex, I could use that ;-)

[08:36] <moritz_> rakudo: say ("abc" ~~ m/[.*?(<.before \w>)]/).join('|')

[08:36] <p6eval> rakudo e074bf: OUTPUT«␤»

[08:36] <moritz_> rakudo: say ("abc" ~~ m/[.*?(<.before \w>)]*/).join('|')

[08:37] <TimToady> might loop a lot

[08:37] *** s1n left
[08:37] <p6eval> rakudo e074bf: No output (you need to produce output to STDOUT)

[08:38] <masak> I've lately started to miss the power of Perl 6 regexes in other languages.

[08:39] <Matt-W> I spend enough time missing Perl 5 ones

[08:40] <Matt-W> One day I'm going to have to get a job writing Perl 6 :)

[08:42] <pugs_svn> r25521 | moritz++ | [t/spec] tests for $str.index(0) (really, this time ;-)

[08:45] <TimToady> zzz &

[08:45] *** ejs1 joined
[08:53] *** alc left
[08:54] <masak> Matt-W: the way to get a job writing Perl 6 is to find a niche where Perl 6 can do something which other programming languages can't (easily) do, and write something great that people want.

[08:54] *** ejs left
[08:54] <Matt-W> masak: unfortunately people are fickle and frustrating

[08:55] <Matt-W> And we probably want a slightly more mature Perl 6 implementation before that can happen :)

[08:55] <masak> yes, but if they have an itch that your program scratches...

[08:55] <masak> the Perl 6.0.0 release is somewhat of a mirage.

[08:56] <masak> we all know that Perl 6 won't suddenly spring into existence.

[08:56] <masak> it grows, organically, through thousands of contributions.

[08:58] <masak> ...and while not yet finished, it already supports a few interesting applications.

[08:58] <Matt-W> indeed

[08:58] <Matt-W> And all we can do is continue to write stuff

[08:59] <Matt-W> I've been trying to put together a grammar for format fields

[09:01] <masak> Matt-W++

[09:01] <Matt-W> later this week, with any luck, I'll have something to push up and get feedback on

[09:01] <Matt-W> at the moment it's a horrible mess :)

[09:02] <masak> the trick is to push it before that stage :)

[09:03] <moritz_> there's something I don't really like about Perl6::Form - although only from a theoretical point of view, since I've never used it

[09:04] <moritz_> since the format and the variables are intermixed, the form processor has to count how many arguments to consider variables

[09:04] *** Lorn left
[09:04] *** yahooooo left
[09:04] *** edenc left
[09:04] *** avar left
[09:04] *** preflex left
[09:04] *** edenc joined
[09:04] *** avar joined
[09:04] <moritz_> and then the next argument is again interpreted as a form

[09:04] *** Lorn joined
[09:04] <Matt-W> yes

[09:04] <moritz_> that means that it can never produce good error messages such as "your templated suggested 5 variables, but you gave only 4

[09:04] *** yahooooo joined
[09:04] <moritz_> (unless it's at the end of the argument list)

[09:05] <masak> that's true.

[09:05] <masak> it's a bit unfortunate.

[09:05] <moritz_> maybe all variable-arguments should go into an Array?

[09:05] <Matt-W> there's a desire in it to keep the data variables close to the fields that they fill, I think

[09:05] <Matt-W> else I'd just stick the lot of them at the end like printf

[09:05] <moritz_> like process-form $format_string1, [$var1, $var2], $format_string2, [$var3, $var 4]

[09:06] <moritz_> Matt-W: not all into the same array, but all belonging to one format template into one array

[09:06] <moritz_> each

[09:06] <masak> moritz_: either that, or just disallow multiple format strings. and the format sub will have to be called again.

[09:06] *** preflex joined
[09:06] <masak> there's something to be said for mimicking sprintf, for example.

[09:07] <Matt-W> hmm

[09:07] <moritz_> masak: that's not so nice, because it means that it has to hide some state for you

[09:07] <Matt-W> moritz_: it would allow nicer error messages

[09:08] <Matt-W> and you could just take pairs of arguments, except where an argument has no fields

[09:08] <masak> oh, there's state involved.

[09:08] <masak> I didn't realize that.

[09:08] <moritz_> for stuff like tables with headings

[09:08] <masak> ah.

[09:08] <moritz_> they can't be rendered before the data is known

[09:08] <masak> then I like the array idea better.

[09:16] <Matt-W> If it was Java, we could also solve the problem by requiring the format parameters to be Format objects instead of strings, then we could easily tell them apart from data parameters :)

[09:17] <moritz_> I'm glad this is not java ;-)

[09:17] <Matt-W> me too

[09:17] <masak> you're making almost no sense at all. :)

[09:18] <Matt-W> of course then we'd probably also have to say Formatter formatter = FormatterFactory.createFormatter(new FormatterContext());

[09:18] * masak rolls his eyes at the Java bashing

[09:18] <masak> Java can be abused, just like Perl.

[09:18] <Matt-W> Sorry, I saw some Java yesterday and I need to work it out of my system

[09:18] <Matt-W> yes, it can

[09:19] <Matt-W> the trouble is, Java is abused in its standard library

[09:19] <masak> and the forces working towards abusing it are cluelessness and frameworkitude, rather than golfing and cargo culting as in Perl.

[09:19] <masak> but the bashing looks all the same to me.

[09:20] <masak> let's add that List contains too many parentheses, while we're at it. :P

[09:20] <masak> s/List/Lisp/

[09:20] <Matt-W> nothing wrong with Lisp that a Haskell-style syntax wouldn't fix, IMO

[09:20] <Matt-W> But I guess I'd get used to it as it is

[09:21] <Matt-W> (intermittently reproduceable deadlocks)--

[09:25] *** bacek joined
[09:29] *** pmurias joined
[09:32] *** jeremiah_ left
[09:34] *** jeremiah_ joined
[09:43] *** szabgab joined
[09:51] *** bacek left
[10:03] *** s1n joined
[10:31] *** s1n left
[10:43] *** s1n joined
[10:44] *** pmurias left
[10:46] *** ejs2 joined
[10:48] *** jferrero joined
[10:52] *** bacek_ joined
[10:57] *** ejs1 left
[11:09] *** szabgab left
[11:40] *** drbean_ joined
[11:52] *** drbean left
[11:57] *** jeremiah_ left
[11:58] <s1n> moritz_: i see what you're talking about, i'm going to fix it to mimic the logic in to_test and from_test

[12:08] <s1n> moritz_: okay, i conceed, i was trying to wrap the to_test and from_test into accepts and i didn't do it correctly. don't worry about this until i send you another pull request

[12:10] <s1n> moritz_: that is, it doesn't support string ranges, but the use of .to and .from look correct

[12:11] *** ludan joined
[12:13] *** alanhaggai_ joined
[12:13] *** alanhaggai_ is now known as alanhaggai

[12:13] *** Ariens_Hyperion joined
[12:14] *** alanhaggai left
[12:16] *** Ariens_Hyperion left
[12:19] *** charsbar_ left
[12:22] *** charsbar joined
[12:30] *** bacek_ left
[12:41] *** SamB left
[12:50] <pugs_svn> r25522 | masak++ | [u4x/TODO] added built-in grammar rules

[12:50] <pugs_svn> r25522 | masak++ | 

[12:50] <pugs_svn> r25522 | masak++ | (Richard Hainsworth)++

[12:51] <masak> that empty line was because I committed via git-svn, and git likes an empty line there. :)

[13:05] *** ashizawa left
[13:05] *** bacek joined
[13:11] *** SamB joined
[13:41] *** skids left
[13:50] *** jeremiah1 joined
[13:54] *** jeremiah1 left
[13:54] *** jeremiah_ joined
[13:58] <literal> moritz_: http://www.nntp.perl.org/group/perl.perl6.language/2009/02/msg30871.html

[13:59] <literal> you say that all references to @!foo must include the !, however, S02 says "$!foo       object attribute private storage (mapped to $foo though)"

[14:00] <bacek> moritz_: can you close #62168? It's not relevant anymore

[14:00] <masak> literal: I hope that's a fossil.

[14:00] <masak> bacek: I can close it.

[14:00] <bacek> masak: ok

[14:01] <literal> masak: can I ask why? it makes sense to me that you should be able to say $foo regardless of whether it has a public accessor

[14:01] <bacek> masak: and #62992 too.

[14:01] <masak> literal: I just think it's an unnecessary convenience, which might possibly be confusing.

[14:01] <literal> oh wait, do you also have to use the dot if it's $.foo ?

[14:02] <literal> if so, then it's not that strange

[14:02] <Matt-W> you do

[14:02] <literal> ok

[14:02] <Matt-W> or so I thought

[14:02] <masak> literal: when it's declared $.foo, you can refer to both $.foo and $!foo

[14:02] <masak> literal: and they mean slightly different things.

[14:02] <masak> (or very different things, depending)

[14:04] *** icwiener joined
[14:07] <literal> so, what's the deal with Temporal? why not call it Time? :P

[14:07] *** nihiliad joined
[14:09] <masak> I propose we name it Bike::Shed.

[14:09] <jnthn> literal: I'm sure somebody will explain it in an Instant. ;-)

[14:10] <literal> masak: but that's even longer than Temporal! :P

[14:10] <masak> literal: so you're saying you're not completely happy with that name? :P

[14:11] <masak> truth be told, as long as the implementation is not botched up, I'll accept a name as long as Temporal::Infinitessimal::Instant.

[14:11] <masak> just don't make a mess of the API.

[14:11] <masak> DateTime is a fine ideal by me.

[14:11] <literal> is there a reason why some synopses aren't HTMLized on perlcabal.org/syn/ ?

[14:12] <masak> literal: tuit shortage?

[14:12] <literal> tuit?

[14:12] <masak> literal: sorry. :)

[14:12] <masak> it's a unit of work.

[14:12] <literal> I see

[14:13] <literal> some new synopses have been HTMLized, but S17 and S22 haven't been for a long time

[14:13] <masak> http://masak.org/carl/w/index.php/Tuit

[14:14] <literal> I just thought this process was automatic and there was some reason that these weren't being converted

[14:14] <masak> the process is automatic, but things have moved around lately.

[14:15] <masak> and I guess there's an index/script somewhere that needs updating.

[14:19] * jnthn finally gets the boring ASP task off his plate

[14:20] <jnthn> OK, so who can tell me how to create a branch in GIT?

[14:20] <jnthn> As in, one that is visible to others on github.

[14:21] <Matt-W> github has a fork button when you're looking at a branch... I've never pressed it, but it might be a place to start looking

[14:21] *** xinming_ joined
[14:21] <masak> jnthn: I usually branch locally and then push to origin/mynewbranch

[14:21] *** dalek left
[14:22] *** dalek joined
[14:24] <jeremiah_> jnthn: http://book.git-scm.com/3_basic_branching_and_merging.html

[14:25] *** Ariens_Hyperion joined
[14:25] <PerlJam> jeremiah_: I think it's the push that he really needs help with

[14:26] <jeremiah_> PerlJam: Ah, okay. :)

[14:27] <jnthn> Aye. I have the branch locally.

[14:27] <jnthn> So I'd so like

[14:27] <jnthn> push origin/name_of_my_branch name_of_my_branch

[14:27] <jnthn> ?

[14:28] <masak> git push origin name_of_your_branch

[14:28] <masak> (don't ask me why, but that's the syntax)

[14:28] <jnthn> origin is the name for the remote server I'm pushing too?

[14:28] <masak> it's usually called origin by default

[14:29] <jnthn> And master in "git push origin master" is my local master branch?

[14:29] <masak> it's a convention, just like 'master'

[14:29] <jnthn> OK.

[14:29] <masak> jnthn: no, I _think_ origin and master are to be read together in git push.

[14:29] <masak> as in, they specify two parts of the target.

[14:29] <masak> but I'm just guessing, to be honest.

[14:30] <jnthn> Creating a local branch is sure *faster* than svn... :-)

[14:31] <PerlJam> well,  "git push origin master" is the same things as "git push origin master:master"  (the syntax is "git push <repo> <local-branch>:<remote-branch>")

[14:31] <PerlJam> (IIRC.  I haven't had to do much remote pushing lately)

[14:31] <jnthn> Aha, OK.

[14:31] <jnthn> git might make sense to me some day... :-)

[14:35] <moritz_> literal: I might not know every aliasing for attributes

[14:36] <moritz_> note to self: never try git-pull --rebase when you merged a branch and didn't push

[14:39] *** skids joined
[14:39] *** xinming left
[14:43] <jnthn> Hmm. Did anyone move split to the setting/

[14:43] <jnthn> ?

[14:43] <moritz_> yes, I did

[14:43] <jnthn> We now fail a spectest. :-(

[14:44] <moritz_> jnthn: in which file?

[14:44] <jnthn> t\spec\S29-str\split-simple.t        1   256    32   52  7-32

[14:44] <jnthn> Did you put it in Str or Any?

[14:44] <moritz_> I put it in Str, and a proxy method in Any

[14:44] <moritz_> it's all green here

[14:45] <jnthn> t\spec\S29-str\split-simple...............................ok 1/32Method 'split'

[14:45] <jnthn> not found for invocant of class 'Int'

[14:45] <moritz_> did you svn up?

[14:45] <jnthn> Hmm

[14:45] <jnthn> no, but I git pulled.

[14:45] <jnthn> ;-)

[14:45] <moritz_> and reconfigured rakudo?

[14:45] <jnthn> ...epic fail.

[14:46] <jnthn> moritz_: ah no

[14:46] <jnthn> even with a re-configure I still fail the same way.

[14:47] <moritz_> jnthn: can you see from your build log if Any.pm was compiled?

[14:47] <dalek> rakudo: 70d9081 | jnthn++ | src/setting/Pair.pm:

[14:47] <dalek> rakudo: Use $.key rather than self.key etc in Pair.pm; improvement suggested by moritz++.

[14:47] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/70d9081a0b5fcafc9984f152a3a4701792cf5cd6

[14:48] <jnthn> moritz_: Hmm...it ain't in my gen_setting.pm

[14:48] <jnthn> Though it is in Makefile.in

[14:48] <moritz_> /usr/bin/perl build/gen_setting_pm.pl src/setting/Any.pm src/setting/Array.pm src/setting/Bool.pm src/setting/Hash.pm src/setting/List.pm src/setting/Pair.pm src/setting/Str.pm src/setting/Whatever.pm  > src/gen_setting.pm

[14:48] <jnthn> SETTING = \ src/setting/Any.pm \

[14:49] <jnthn> Trying a make realclean...

[14:50] <jnthn> moritz_: OK, that did it.

[14:50] <jnthn> Hmm...wonder if that means some makefile rules are wonky...

[14:51] * moritz_ is reliefed

[14:51] <moritz_> src/gen_setting.pm: build/gen_setting_pm.pl $(SETTING)

[14:51] <jnthn> Looks right to me...

[14:52] <jnthn> Oh, can you get an odd situation where the makefile is changed, but it doesn't realize that Any.pm is now?

[14:52] <jnthn> *new?

[14:52] <moritz_> yes

[14:52] <jnthn> Oh.

[14:52] <jnthn> What's the Right Thing to do in such situations?

[14:53] <jnthn> Just say people should make clean?

[14:53] <moritz_> when you check out, build it, reconfigure, build again

[14:53] <moritz_> yes

[14:53] <jnthn> OK, good.

[14:53] <moritz_> always make clean before/after reconfigure

[14:55] *** Ariens_Hyperion left
[14:56] <jnthn> yay, my new branch is on github :-)

[14:57] <masak> I like $.key -- maybe the rule of thumb should be to use $.foo for accessors, and self.foo for non-accessor methods...

[14:58] <masak> (or other suitable sigils, of course)

[14:59] <jnthn> Yes.

[15:00] <masak> maybe I'll email that to the "Perl 6 best practices" thread on p6u. :)

[15:01] <masak> that would make it the fastest-forming best practice in the history of programming.

[15:03] *** jan_ left
[15:05] *** jan_ joined
[15:18] *** ejs2 left
[15:22] *** ejs joined
[15:24] <masak> rakudo: class A { has $!foo; method x { say $foo } }; A.new(:foo(5)).x

[15:24] <p6eval> rakudo 70d908: OUTPUT«Scope not found for PAST::Var '$foo' in x␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[15:24] <masak> rakudo: class A { has $!foo; method x { my $foo = 7; say $foo } }; A.new(:foo(5)).x

[15:24] <p6eval> rakudo 70d908: OUTPUT«7␤»

[15:25] *** justatheory joined
[15:25] <masak> if what S02:1402 says is true, the first should print 5, and the second should at least give a redeclaration warning.

[15:25] * masak submits rakudobug

[15:26] <masak> (but I hope S02:1402 is wrong)

[15:29] <masak> is it possible that the '(mapped to $foo though)' comment should really be on the table row talking about $^foo, not $!foo ?

[15:30] *** cas joined
[15:33] <jnthn> masak: I think Rakuod is right here.

[15:33] <jnthn> You'd have to say "has $foo" to get $!foo and $foo

[15:34] <jnthn> Unless there's been a recent spec change.

[15:34] <masak> S02:1402 simply says "mapped to $foo".

[15:34] <masak> something's gotta give.

[15:34] <jnthn> $!foo is mapped to $foo? :-S

[15:34] <masak> as I keep saying, I sure hope not.

[15:35] <masak> but S02 says so, clearly.

[15:35] * masak does svn blame

[15:35] <jnthn> I've no idea what it means.

[15:35] <jnthn> per S12

[15:35] <masak> it means that $!foo is mapped to $foo, according to S02. :)

[15:35] <jnthn> has $brain;     # also declares $!brain;

[15:36] <jnthn> OK, then I'm going to say S02 is wrong/unclear.

[15:36] <jnthn> Suggest mail to language list.

[15:36] <masak> OK.

[15:36] <masak> will do.

[15:36] <jnthn> S12 has been clear on this for quite a while...I suspect it's more likely typo/braino...

[15:37] <jnthn> Thanks.

[15:38] *** pmurias joined
[15:39] <Nom-> Ugh.  What I wouldn't give for a native Perl driver for DB2... it'd make things so much less painful :(

[15:39] <Nom-> s/native/pure perl/

[15:53] <TimToady> S02 is wrong

[15:54] <Matt-W> TimToady: hurrah! I assume you refer to the $!foo $foo mapping thing

[15:55] <PerlJam> gosh I hope so

[15:55] <Matt-W> Clearly the populace wants it to be wrong in that respect :)

[15:56] <jnthn> Oh noes...actions.pm makes use of List...and worse, treats them as mutable...

[15:57] <TimToady> *I* want it to be wrong; I don't want people writing $foo when they mean $!foo, which is why they have to declare it that way if they want it

[15:58] <TimToady> I think S02 meant "is mappable to $foo"

[15:58] <TimToady> not that that's the default

[15:58] <jnthn> *nod*

[15:58] <jnthn> s/mapped/mappable/ would clear it up, I think

[15:59] *** eternaleye left
[16:02] <pugs_svn> r25523 | lwall++ | remove confusing sidenote

[16:03] *** hercynium joined
[16:04] <jnthn> That clears it up too. ;-)

[16:05] *** alexn_org joined
[16:10] * masak rejects his own rakudobug

[16:11] *** icwiener left
[16:18] *** M_o_C joined
[16:23] <pmichaud> hello, all.

[16:23] <pmichaud> back from trip.

[16:23] <alester> If I ignore a commit in the fork queue, I'll still get it when it gets applied to rakudo/rakudo, right?

[16:23] <jnthn> pmichaud: Welcome back.

[16:24] <jnthn> Hope trip went smoothly/ok etc.

[16:24] <pmichaud> yes, it did go fairly smoothly.  Very enjoyable.  I didn't get much chance to work on Rakudo, though. :-|

[16:24] <pmichaud> time to rectify that.  :-)

[16:25] <jnthn> :-)

[16:25] <jnthn> I'm digging in to make List have a ResizablePMCArray for storage, rather than inherit from it.

[16:25] <pmichaud> okay.

[16:25] <jnthn> And found...well...the nastiness you predicted. ;-)

[16:25] <jnthn> I wish you were wrong sometimes. :-)

[16:26] <masak> welcome back, pmichaud.

[16:26] <masak> when's release day? :)

[16:26] <pmichaud> still may be tomorrow.

[16:26] <masak> cool.

[16:26] <pmichaud> might be late tomorrow, but tomorrow is still my target.

[16:26] <masak> aye.

[16:26] <pmichaud> when planning tomorrow as the release day I had taken into account that I might not get much done over the weekend.  :-)

[16:27] <jnthn> pmichaud: One Bad Thing was that we were using Rakudo's List class in various places in actions.pm

[16:27] <pmichaud> I'm surprised about that

[16:27] <jnthn> This was bad not only because we want to compile List...

[16:27] <jnthn> ...but also because we were treating it as mutable!

[16:27] <pmichaud> where is List being used in actions.pm ?

[16:28] <jnthn> One call to list() but mostly because @?BLOCKS was a List and not an RPA

[16:28] <jnthn> (Set up in perl6.pir, but used in actions.pm...)

[16:28] <pmichaud> oh.  @?BLOCKS can be an RPA.

[16:29] <jnthn> Ok, that's what I figured, so I fixed that up. Apart from...when you call .list() on an RPA it turns itself into a List. :-|

[16:29] <jnthn> for +@($thingy) { } now turns $thingy if it's an RPA into a List.

[16:29] <pmichaud> yes, that does make things more difficult.

[16:29] <jnthn> That's my current sticking point.

[16:30] <pmichaud> make @?BLOCKS into something inherited from RPA that returns self for .list

[16:30] *** rindolf joined
[16:31] <pmichaud> for that matter, @?BLOCKS could be a PCT node or a Match object.

[16:31] <pmichaud> we just need something that honors .push and .pop

[16:31] <pmichaud> and .list

[16:31] <jnthn> Aye

[16:31] <jnthn> That would save creating some other class.

[16:31] <jnthn> Any preference wish one?

[16:32] <pmichaud> PCT::Node sounds like a good choice.  or PAST::Node

[16:32] <jnthn> ok

[16:32] <pmichaud> heck, I bet it could even be Capture

[16:32] <jnthn> The Parrot Capture?

[16:32] <pmichaud> yes.

[16:32] <pmichaud> since that's what PCT::Node inherits from. 

[16:33] <jnthn> fail

[16:33] <jnthn> Method 'unshift' not found for invocant of class 'Capture'

[16:33] <pmichaud> weird.

[16:34] <pmichaud> oh, yes, that actually makes sense.

[16:34] <jnthn> Isn't it PCT::Node that adds those?

[16:34] <pmichaud> okay, try PCT::Node.

[16:34] <pmichaud> I'm thinking perhaps Capture should have them, the same way that RPA does.

[16:34] <pmichaud> but let's go with PCT::Node for now.

[16:34] <pmichaud> it's a relatively minor point at the moment.

[16:35] *** eternaleye joined
[16:35] *** Tene joined
[16:39] <jnthn> pmichaud: Ah, I know have "get_number() not implemented in class 'Capture'"

[16:40] <pmichaud> I suspect somewhere we have    +$list

[16:40] <pmichaud> +@($list)  should work though.

[16:41] <pmichaud> or we can add get_number to PCT::Node

[16:41] <jnthn> Yeah, trying that...

[16:41] *** riffraff joined
[16:41] <jnthn> pmichaud: Am pondering doing Rakudo day tomorrow - does that work at all for you?

[16:42] <pmichaud> yes.

[16:42] <jnthn> OK, great.

[16:42] <pmichaud> any day this week works.

[16:42] <jnthn> It's awkward doing it any other day...

[16:42] <pmichaud> okay, we'll go with that.  I may be doing release-ish types of things tomorrow, but I don't think that'll be an issue.

[16:42] <jnthn> Thursday will be a bit tied up with trip-prep, Friday I'm traveling etc.

[16:42] <jnthn> Sure - I can always do stuff in a branch if needed.

[16:43] <jnthn> I'm doing this current bunch of refactors in a branch.

[16:43] <jnthn> May focus on more bug fixes tomorrow though, to make a better release. :-)

[16:43] <pmichaud> good plan.

[16:45] <masak> yay, bug fixes!

[16:47] <jnthn> Yeah

[16:47] <jnthn> masakbugs-- ;-)

[16:47] <masak> :P

[16:47] <masak> you'll need it. :)

[16:47] *** Tene_ left
[16:48] <jnthn> pmichaud: Ah, epic fail :-(

[16:48] <masak> one strange effect of submitting most bug reports is that jnthn's bug fix blog posts seem eerily familiar. I'm reading them and going "why, this sounds a bit familiar. and this... and this. has someone been reading my thoughts lately?"

[16:48] <jnthn> Match nodes contain...a ResizablePMCArray.

[16:49] <pmichaud> jnthn: oh yes, that's an issue.

[16:49] <pmichaud> maybe we fix it so that .list on RPA returns self.

[16:49] <pmichaud> the other possibility is to have duplicate methods in place

[16:49] <jnthn> I'll just do that.

[16:50] <jnthn> And handle the fallout of it later.

[16:50] <pmichaud> note that having .list on RPA return self will epic fail in other areas.

[16:50] *** mikehh left
[16:51] <jnthn> Sure, but it might at least get us through the compile. ;-)

[16:51] *** mikehh joined
[16:51] *** jan_ left
[16:51] <pmichaud> the other possibility is to write the minimum methods needed for stage 1 compile in PIR.

[16:52] <pmichaud> and then let the settings .pm stuff override those when it's included.

[16:52] *** masak left
[16:52] <moritz_> the more methods we write in Perl 6 the slower the compiler becomes

[16:52] <jnthn> Yes, true, I did ponder something like that...

[16:53] <pmichaud> moritz_: the slower the compiler becomes?  afaik, right now the compiler isn't using any of the settings methods.

[16:53] <moritz_> pmichaud: I mean overall execution speed

[16:53] <jnthn> get_iter() not implemented in class 'Capture'

[16:53] <jnthn> *sigh*

[16:53] <moritz_> 2% slower for the test suite after converting .split and .comb to setting/

[16:54] <pmichaud> I'm curious about the .split conversion -- what's going on in Any.split?

[16:54] <pmichaud> I'm also wondering why it would be that much slower -- is .split used a lot?

[16:54] *** jan_ joined
[16:54] <moritz_> pmichaud: it re-dispatches to the Str.split methods

[16:55] <pmichaud> moritz_: shouldn't the Str.split methods be in Any, then?

[16:55] <moritz_> pmichaud: I thought that was cleaner than cramming Any.pm with all methods that go into any

[16:55] <moritz_> pmichaud: but I can also move them

[16:55] <moritz_> whatever you prefer

[16:55] <pmichaud> methods belonging to any definitely go in Any.

[16:55] <moritz_> ok.

[16:55] <pmichaud> that said, it's okay with me if we have   Any-str.pm, Any-num.pm, Any-list.pm, etc.

[16:59] <moritz_> ok, I've prepared the move, just waiting for the spectests to commit

[17:02] <pugs_svn> r25524 | hinrik++ | [url/perl6.vim] kill the + twigil

[17:02] <literal> url? typo..

[17:05] *** eternaleye left
[17:05] <jnthn> Ahhh...I makes it through the compile.

[17:05] *** ludan left
[17:06] * [particle] wonders what it would take to get 10k tests by rakudo's first independent release

[17:06] <moritz_> [particle]: about 3k more passing tests

[17:06] <[particle]> oh, right, i hate the regular test harness

[17:06] <[particle]> Files=314, Tests=9301, 1171 wallclock secs ( 0.87 usr +  2.84 sys =  3.72 CPU)

[17:07] <[particle]> of course, that's not 9301 passing tests

[17:07] <[particle]> i don't know how many are passing, but not todo/skip

[17:07] <[particle]> sigh.

[17:07] <moritz_> that's not so good, but at least it runs the tests in parallel

[17:08] <[particle]> not here, 1171s is 19+m

[17:19] <moritz_> I don't understand that... if I move .split to Any-str.pm, I get type check failures

[17:19] <moritz_> for the first parameter

[17:19] <moritz_> even though there's a multi with Any of the type

[17:20] <moritz_> so it means that it not participates in multi method dispatch correctly

[17:21] <jnthn> Hmm. Odd.

[17:23] <moritz_> I pushed the branch move_split_to_any_str to github

[17:23] <moritz_> if you want to take a look

[17:28] <moritz_> jnthn: http://nopaste.snit.ch/15707

[17:28] *** mikehh left
[17:28] <jnthn> moritz_: Ooooh!

[17:28] <jnthn> Yes. :-(

[17:29] <moritz_> that's very parrotish dispatch

[17:29] *** mikehh joined
[17:29] <jnthn> No, it's an incompleteness in multimethod dispatch in Rakudo. :-(

[17:30] <jnthn> I'll try and solve it tomorrow.

[17:30] *** aindilis joined
[17:34] <pugs_svn> r25525 | moritz++ | [t/spec] tests for calling multi methods of parent class

[17:34] <moritz_> jnthn: added a test, opened a ticket

[17:34] <jnthn> moritz++ # thanks!

[17:35] <pmichaud> yes, this is a fairly big issue with Parrot multimethod dispatch.  methods in subclasses override _all_ methods of parent classes.

[17:35] <jnthn> pmichaud: AFAIU MMD is bredth-first.

[17:35] *** dukeleto left
[17:35] <pmichaud> so as far as Parrot is concerned, Bar's "a" method completely hides any "a" methods of its parents.

[17:35] <jnthn> So if we find something that matches we run it, if not we look further up...

[17:36] <moritz_> still the error message in the move_split_to_any_str is "parameter type check failed", which still seems to be a different beast

[17:36] <pmichaud> jnthn: that's not been my experience with Parrot's dispatch.

[17:36] <jnthn> pmichaud: No, that's a Parrot dispatch issue, but we have our own dispatcher. ;-)

[17:36] <pmichaud> oh, okay.

[17:36] <pmichaud> if we're using our own dispatcher (and yes, we are), then jnthn++ will undoubtedly have it fixed.

[17:36] <jnthn> So in theory it's going to be a straightforward fix.

[17:37] <jnthn> pmichaud: On our dispatcher - just trying to make something that works now, but we'll undoubtably optimize the heck out of it further down the line. :-)

[17:37] <pmichaud> jnthn: yes, that works for me.

[17:37] <jnthn> pmichaud: Is the README on your list of documents you planned to update/tweak?

[17:37] <pmichaud> jnthn: yes.

[17:37] <pmichaud> but patches are welcome.

[17:38] <moritz_> pmichaud: do you plan to blog about us having a prelude? if not I might do it within the next two days

[17:38] <pmichaud> yes, I'm blogging that as well.

[17:38] <moritz_> ok, then I'll pick a different subject

[17:38] <pmichaud> I'm blogging the new build sequence, prelude, and release.

[17:38] <jnthn> I scribbled a little on that, but someone replied with...

[17:39] <jnthn> http://www.rakudo.org/2009/02/rakudo-built-ins-can-now-be-wr.html # see comment

[17:39] <jnthn> Wanting a kinda "plan"

[17:39] <TimToady> by the by, I'm not stuck on the @?BLOCKS interface if something more functionish would make more sense

[17:39] *** justatheory left
[17:39] <pmichaud> TimToady: no problem -- @?BLOCKS is just our punned version of the variable internally anyway.

[17:39] <TimToady> it's a synthetic variable at the best of times, I suspect

[17:40] <[particle]> @?BLOCKS.pick.() #whee!

[17:40] <pmichaud> jnthn: yes, I saw the request for a 'plan', which is why I'm planning to blog my vision for the plan.

[17:40] <pmichaud> TimToady: yes, a more functionish interface might be nice, though.

[17:41] <jnthn> pmichaud: OK, excellent.

[17:41] <pmichaud> that said, my 'plan' is likely to be less structured than some would like at this point.

[17:41] *** justatheory joined
[17:42] <TimToady> in STD I found that trying to shadow OUTER:: linkage with @?BLOCKS was kinda bogus

[17:42] <pmichaud> my limited experience in Rakudo matches yours there.

[17:43] <moritz_> somehow planetperlsix didn't pick up jnthn++'s rakudo.org blog post

[17:43] <TimToady> so paint @?BLOCKS et al. as somewhat deprecated

[17:44] * diakopter tried perl Configure.pl --gen-parrot

[17:46] <diakopter> C:\strawberry\perl\bin\perl.exe tools\build\c2str.pl --all

[17:46] <diakopter> src\string\api.c

[17:46] <diakopter> In file included from config/gen/platform/win32/threads.h:9, from ./include/parrot/parrot.h:274, from src\string\api.c:26:

[17:46] <diakopter> ./include/parrot/thr_windows.h:128: error: redefinition of `struct timespec'

[17:46] <diakopter> mingw32-make: *** [src\string\api.o] Error 1

[17:50] <jnthn> Hmm...I'm sure when I built with strawberry it found - somehow - cl and nmake...

[17:51] <jnthn> Were you building in the Strawberry command line shell etc?

[17:51] <jnthn> And are nmake and cl in your path?

[17:51] <diakopter> nmake is

[17:51] <diakopter> not cl, yet.

[17:52] <diakopter> I'm using nmake.exe 7.10.3077 btw

[17:53] <pugs_svn> r25526 | moritz++ | [t/spec] include ticket information in fudge message

[17:56] *** Whiteknight joined
[17:56] <[particle]> with strawberry, you should use mingw32-make and gcc

[17:56] <[particle]> cl and nmake shouldn't be in your path

[17:58] *** alexn_org left
[17:59] <diakopter> [particle]: about that error I pasted above (when using mingw32-make and gcc)

[18:00] <diakopter> is that a parrot bug fixed in some later revision?

[18:00] <diakopter> (than the one co'd by --gen-parrot)

[18:00] <jnthn> Hmmm...not so sure.

[18:00] <jnthn> When I built with Strawberry Perl on my laptop, I'm almost certian I ended up using nmake and cl...

[18:01] <[particle]> no sure either. i'm having usb device trouble atm preventing me from printing a contract, so i need to suspend all my VMs. can check later

[18:03] <diakopter> can rakudo (current git) not be used with parrot svn?

[18:03] <[particle]> you can use parrot head with rakudo head

[18:04] <diakopter> ok

[18:04] <[particle]> build parrot head, git clone in languages/rakudo

[18:05] <pmichaud> that's not the recommended build at the moment, fwiw

[18:05] <pmichaud> the recommended rakudo build is:    git clone rakudo, then   perl Configure.pl --gen-parrot

[18:06] <pmichaud> especially since Parrot trunk has had some breakages lately.

[18:06] <diakopter> pmichaud: I did that... see above

[18:06] <pmichaud> oh sorry, didn't see that part.

[18:06] <PerlJam> pm: --gen-parrot doens't just checkout HEAD?

[18:06] <pmichaud> PerlJam: no.

[18:06] <PerlJam> cool.

[18:06] <pmichaud> that's the whole point of --gen-parrot.

[18:06] <pmichaud> it does a checkout of whatever is in build/PARROT_REVISION

[18:07] * PerlJam will have to start playing with rakudo again 

[18:07] <pmichaud> diakopter: are you able to build Parrot at all on your system -- e.g., from a svn checkout of Parrot?

[18:08] <diakopter> a problem with pinning to a particular svn revision (without post applying patches, I suppose) is for situations like this where the parrot build fails and the build might be fixed in a later revision

[18:08] <pmichaud> diakopter: then we just re-pin.

[18:08] <diakopter> pmichaud: checking out parrot HEAD now

[18:08] <diakopter> heh, and I guess I'm getting all branches/tags too :P

[18:09] <pmichaud> but the point of build/PARROT_REVISION is that it should only be updated to a version of Parrot that is known to work/be stable.

[18:09] <pmichaud> For example, I don't think the recent handling of the changes to the String PMC was really done properly.

[18:10] <pmichaud> but that's probably because we're still learning about our new development configurations.

[18:10] *** rindolf left
[18:12] <diakopter> while all of parrot SVN is checking out, I'll try removing gcc/ming32-make from PATH and configuring parrot rPARROT_REVISION

[18:12] <pmichaud> we likely need our committers to be very wary of making updates to PARROT_REVISION (or things that depend on a new version of Parrot)

[18:12] <pmichaud> diakopter: faster is to just check out /trunk

[18:12] <pmichaud> checking out the entire repository is likely to take a very long time.

[18:12] <[particle]> diakopter: you mean remove msvc/cl from strawberry path?

[18:15] <diakopter> [particle]: no I'd like to try it jnthn's way first  since it didn't seem like cl/nmake were affecting parrot configure's selection/use of gcc/ming32-make

[18:19] <diakopter> inter::progs -        Determine what C compiler and linker to use...Compilation failed with 'cl'

[18:19] <diakopter> Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 15.00.30729.01 for 80x86

[18:19] *** riffraff left
[18:20] *** Psyche^ joined
[18:21] <jnthn> diakopter: Maybe things would be easier with ActivePerl...

[18:23] <pugs_svn> r25527 | lwall++ | clarify what happens when associativity conflicts arise

[18:23] <pugs_svn> r25527 | lwall++ | allow both tighter and looser at the same time

[18:23] <pugs_svn> r25527 | lwall++ | remove all the synthetic @? variables; use the symbol tables directly

[18:23] <[particle]> parrot/rakudo on strawberry perl used to just work.

[18:23] <jnthn> Yeah, it did for me not long back too...

[18:24] * [particle] restarts

[18:25] *** [particle] left
[18:27] <diakopter> well, maybe it's just rPARROT_REVISION.  trying from HEAD now

[18:29] <diakopter> build failed at the same spot

[18:31] * diakopter goes to download activeperl

[18:34] <pugs_svn> r25528 | rhr++ | [S28] we don't have both $*IN and $*STDIN etc.

[18:36] *** alexn_org joined
[18:36] *** Patterner left
[18:36] *** Psyche^ is now known as Patterner

[18:43] *** [particle] joined
[18:57] <diakopter> jnthn: you were right; it was a 64-bit issue... well, several.  three things had to align properly.  I needed to be running under the 32-bit cmd.exe (WINDOWS\SYSWOW64\cmd.exe), I needed to have run the 32-bit VC env vars batch script, and I tried ActivePerl 32-bit, not 64-bit (which I tried first).  However, now that parrot tried to Configure and nmake using cl, it died with nearly the exact same error.

[18:57] <diakopter> pmichaud: see ^

[18:58] <diakopter>         C:\Perl\bin\perl.exe tools\build\c2str.pl --all src\string\api.c

[18:58] <diakopter> C:\Users\xxxxxxx\source\parrot\trunk\include\parrot/thr_windows.h(128) : error C2011: 'timespec' : 'struct' type redefinition

[18:58] <diakopter>         C:\strawberry\c\include\pthread.h(307) : see declaration of 'timespec'

[18:58] <diakopter> NMAKE : fatal error U1077: 'C:\Perl\bin\perl.exe' : return code '0x2'

[18:59] <jnthn> Erm, huh...it's lookinf at pthread.h from Strawberry when building with cl?!

[18:59] <diakopter> no; c:\Perl\bin\perl.exe is activestate 32-bit 5.10

[19:00] <diakopter> strawberry/gcc are nowhere in the PATH

[19:00] <jnthn> no

[19:00] <jnthn> C:\strawberry\c\include\pthread.h(307)

[19:00] <diakopter> oh, hrm

[19:00] <jnthn> I suspect it's this include that's the issue...

[19:00] <diakopter> so it's not PATH

[19:00] <diakopter> yeah INCLUDE

[19:01] <diakopter> oh, and LIB

[19:02] <diakopter> .... nmake realclean

[19:04] <[particle]> http://rafb.net/p/c3DxQG57.html

[19:06] <diakopter> [particle]: neat, thanks.

[19:12] *** jferrero left
[19:17] *** M_o_C left
[19:17] *** M_o_C joined
[19:23] *** preflex left
[19:24] *** preflex joined
[19:32] *** pmurias left
[19:34] <jnthn> pmichaud: Turns out List and Array not being a ResizablePMCArray really does turn up a *lot* of stuff... :-|

[19:35] <pmichaud> jnthn: I figured that might be the case.

[19:35] <jnthn> It's taken me this long to only fail two sanity tets. :-|

[19:35] *** barney joined
[19:35] <jnthn> The test harness does run though.

[19:36] <pmichaud> we also have to consider what might happen when we do type mapping, as well.

[19:36] <jnthn> Eurgh.

[19:36] <jnthn> Yes.

[19:36] <jnthn> We're in *so* many places assuming it's OK to treat List as mutable.

[19:36] <pmichaud> well, that's easily fixed by changing to Array

[19:36] <jnthn> Fixing various of them to now deal with the underlying storage...

[19:37] <jnthn> Sure, but a lot of the cases are things that construct a List.

[19:37] <pmichaud> fine, we just promote it to an array.

[19:37] <jnthn> For even, say, things like split?

[19:37] <pmichaud> not in the function, but in the return value.

[19:37] <pmichaud> er, that's unclear.

[19:38] <pmichaud> when something calls 'split', we promote the result into an array -- exactly as we would do for Perl 6.

[19:38] <pmichaud> i.e.,  $P1 = $P0.'split'(...);    $P1 = $P1.item();

[19:38] <pmichaud> or something like that.

[19:39] <jnthn> I meant more that there are things that construct a list internally.

[19:39] <jnthn> in PIR we're doing a lot of

[19:39] <jnthn> $P0 = new 'List'

[19:39] <jnthn> push $P0, 42

[19:39] <pmichaud> so, change that to 'Array'

[19:39] <jnthn> That's the preferred option? OK.

[19:40] <pmichaud> still better would probably be

[19:40] <pmichaud> $P0 = new 'Array';  $P0.'push'(42)

[19:40] <jnthn> Yes

[19:40] <pmichaud> even better might be (someday)     $P0 = 'Array'(42)

[19:40] <jnthn> OK, I'll have a review and clean up all these things.

[19:40] <jnthn> Even better would be that much of the stuff that's written in PIR won't be.

[19:41] <pmichaud> exactly.

[19:41] <pmichaud> but this is part of the reason I haven't been pushing to clean up such things in PIR, because I'm hoping a lot moves to p6.

[19:41] <jnthn> You're right though - using Array and .push makes the code in PIR now closer to what the Perl 6 will be.

[19:41] <jnthn> Yeah, but trying to change the structure of Array and List *and* move them to Perl 6 at the same time feels too risky and too hard to me.

[19:42] <pmichaud> sure, that makes sense.

[19:42] <pmichaud> which is also why I was saying we want baby steps :-)

[19:42] <PerlJam> so, what will be left in PIR?

[19:43] <pmichaud> PerlJam: things that don't easily map to Perl 6, or where efficiency is a major concern

[19:43] *** IllvilJa left
[19:44] <PerlJam> that's the obvious answer  :-)  I guess I was looking for an example.  

[19:44] <jnthn> infix:does ;-)

[19:44] <pmichaud> infix:+

[19:44] <pmichaud> sorry, infix:<+>

[19:44] <jnthn> sorry, infix:<does>

[19:44] <jnthn> ;-)

[19:45] <[particle]> BEGIN {...}

[19:58] <pugs_svn> r25529 | lwall++ | initial whack at describing how settings are snapshotted

[19:58] <pugs_svn> r25529 | lwall++ | and how they interact with invocation of MAIN for settings

[19:58] <pugs_svn> r25529 | lwall++ | that want to install flow control around the user code.

[19:59] *** IllvilJa joined
[20:03] *** barney left
[20:06] *** alexn_org left
[20:08] *** arthurium joined
[20:08] <arthurium> perl6: say (6*3)/1*(1)

[20:08] <p6eval> elf 25529, pugs, rakudo 70d908: OUTPUT«18␤»

[20:09] <arthurium> perl6: say (6*0x3)/1*(1)

[20:09] <p6eval> elf 25529, pugs, rakudo 70d908: OUTPUT«18␤»

[20:09] <arthurium> perl6: say (6*0x103)/1*(1)

[20:09] <p6eval> elf 25529, pugs, rakudo 70d908: OUTPUT«1554␤»

[20:11] *** justatheory left
[20:11] *** justatheory joined
[20:20] *** alexn_org joined
[20:28] * jnthn observes the massive fail

[20:32] <diakopter> std: say (6*0x3)/1*(1)

[20:32] <p6eval> std 25529: OUTPUT«ok 00:02 33m␤»

[20:47] *** Ariens_Hyperion joined
[20:51] <TimToady> what massive fail?  0x103 is a hex number

[20:52] * PerlJam doesn't get it either

[20:53] *** icwiener joined
[20:57] *** ruoso joined
[20:57] *** kane_ joined
[20:59] *** duke_leto joined
[20:59] *** Whiteknight left
[21:02] *** Ariens_Hyperion_ joined
[21:02] <bacek> good morning

[21:02] <bacek> perl6: my $a = 42; $a min= *; say $a

[21:02] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "min"␤    expecting operator␤    at /tmp/xapqXVSFcc line 1, column 16␤»

[21:02] <p6eval> ..rakudo 70d908: OUTPUT«Multiple Dispatch: No suitable candidate found for 'cmp', with signature 'PP->I'␤current instr.: 'infix:cmp' pc 15790 (src/builtins/cmp.pir:146)␤»

[21:02] <p6eval> ..elf 25529: OUTPUT«Unknown rule: infix_postfix_meta_operator:=␤It needs to be added to ast_handlers.␤ at ./elf_h line 2042␤»

[21:03] *** duke_leto left
[21:14] <diakopter> pmichaud: as a (temporary? permanent?) workaround for the http url /->\\ problem in Makefile.in, put the trailing 't/spec' on the next line, and qualify the Configure.pl replacer line with 'unless $maketext =~ /pugscode/' or something...?

[21:15] <ruoso> std: my ($x, $y, $eps); if $x ~~ [..] $y ± $eps { ... }

[21:15] <lambdabot> ruoso: You have 1 new message. '/msg lambdabot @messages' to read it.

[21:15] <p6eval> std 25529: OUTPUT«############# PARSE FAILED #############␤Unable to parse array composer; couldn't find final ']'␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range at /tmp/JmLl8Est45 line 1:␤------>

[21:15] <p6eval> ..[32...

[21:15] *** Ariens_Hyperion_ left
[21:15] <pmichaud> diakopter: noted, thanks.  I'll be looking at that shortly.

[21:16] <ruoso> @tell pmurias re metaclass creating new objects instead of forcing p6opaque: You're absolutely right.

[21:16] <lambdabot> Consider it noted.

[21:16] <ruoso> isn't the range constructor an infix?

[21:17] <ruoso> std: my ($x, $y, $eps); sub infix:<±> {...}; if $x ~~ [..] ($y ± $eps) { ... }

[21:17] <p6eval> std 25529: OUTPUT«############# PARSE FAILED #############␤Unable to parse array composer; couldn't find final ']'␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range at /tmp/rt5vPBqgm3 line 1:␤------>

[21:17] <p6eval> ..[32...

[21:19] <TimToady> it *should* have said: Can't reduce a nonchaining operator because it's diffy and not chaining

[21:19] *** Ariens_Hyperion left
[21:20] <diakopter> I'm not getting any output from rakudo's nmake spectest or nmake test... how do I diagnose this?

[21:21] <diakopter> I *do* get output from nmake codetest

[21:22] <pugs_svn> r25530 | lwall++ | [STD] reign in an overreaching [1..] check

[21:24] <TimToady> std: [..] 1,2,3

[21:24] <p6eval> std 25529: OUTPUT«############# PARSE FAILED #############␤Unable to parse array composer; couldn't find final ']'␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range at /tmp/vX50nGwoxD line 1:␤------>

[21:24] <p6eval> ..[32...

[21:24] * TimToady twiddles his thumbs

[21:25] <pmichaud> diakopter: did t/spec get checked out?

[21:25] <pmichaud> i.e., is the t/spec directory populated?

[21:26] <diakopter> yep

[21:26] <pmichaud> was perl6.exe built?

[21:26] <diakopter> yep

[21:27] <diakopter> `C:\Perl\bin\perl.exe t\harness --fudge --keep-exit-code --jobs --tests-from-file=t\spectest.data`  spins for a few seconds, but nothing on stdout

[21:27] <pmichaud> does parrot/parrot.exe exist?

[21:27] <diakopter> nope; I built it elsewhere b/c I was building from trunk

[21:27] <diakopter> HEAD I mean

[21:27] <pmichaud> ah.  I suspect the harness isn't finding parrot.exe then.

[21:28] <pmichaud> and we haven't switched the harness to use the perl6.exe yet.

[21:28] <diakopter> hm. I'll try adding BUILD_DIR to my PATH

[21:28] <pmichaud> I think it currently looks explicitly for ..\..\parrot and parrot\parrot

[21:28] <pmichaud> i.e., I don't think it checks the path yet.

[21:28] <pmichaud> I'm working on an updated harness to fix this, but haven't checked it in yet.

[21:29] <diakopter> (adding parrot.exe's location to the PATH didn't help)

[21:29] <pmichaud> right, the t/harness file still requires Parrot's Test::Harness

[21:30] <pmichaud> as I said, I'm working on fixing that... but anyone else that wants to do it is very welcome to do so :-)

[21:31] <TimToady> std: [..] 1,2,3

[21:31] <p6eval> std 25530: OUTPUT«############# PARSE FAILED #############␤Unable to parse array composer; couldn't find final ']'␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range at /tmp/jdEKPB3mlo line 1:␤------>

[21:31] <p6eval> ..[32...

[21:31] * TimToady twiddles his thumbs more

[21:31] <pmichaud> the revision number says it updated

[21:32] <TimToady> actually, /me revises the patch...

[21:32] <pmichaud> i.e., it now says r25530 instead of r25529.

[21:32] <pmichaud> ah.

[21:34] <ruoso> TimToady, so... I'm a bit lost...

[21:34] <ruoso> is "[..] 1,10" ok?

[21:35] <ruoso> or in a more usefull way...

[21:35] <ruoso> is "[..] something()" ok?

[21:35] <ruoso> and... more to the point ;)

[21:35] <ruoso> is "[..] $x ± $eps" ok?

[21:37] <TimToady> no, you need to say &[..](|($x ± $eps)) for an operaotr like ..

[21:37] *** mikehh left
[21:38] *** ZuLuuuuuu joined
[21:38] <ruoso> TimToady, hmm... even if the operator does return a list of two values?

[21:39] <ruoso> (the other operator, not ..)

[21:39] <PerlJam> [..] 1,10 I think I can grok, but I'm not sure what to make of   [..] 1,10,20

[21:40] <ruoso> PerlJam, [..] 1,10,20 would fail because there isn't a candidate for infix:<..>($more,$than,$two_values)

[21:40] <diakopter> std: &[..](2,1)

[21:40] <p6eval> std 25530: OUTPUT«############# PARSE FAILED #############␤Can't understand next input--giving up␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range at /tmp/cnKoBTDgAF line 1:␤------>

[21:40] <p6eval> ..[32m&[[31m..](2,1)...

[21:40] <TimToady> that's why I'm revising the patch :)

[21:41] <ruoso> TimToady, but my point is that if something() does return a list of two values? why can't I use the reduction with it?

[21:41] <TimToady> because I'm a mean bastare

[21:41] <TimToady> *bastard

[21:41] *** alester left
[21:41] <TimToady> grr!

[21:41] <PerlJam> TimToady: what if the arity of something were explicit?

[21:42] <PerlJam> (or whatever you call the return list)

[21:42] <pmichaud> ...is there a candidate for  infix:<+>($more, $than, $two_values)   ?

[21:42] *** pmurias joined
[21:42] <pmurias> ruoso: hi

[21:42] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[21:42] <ruoso> TimToady, you mean that in terms of parsing or runtime? because in terms of runtime I didn't expect infix:<..> to be different from any other

[21:43] <ruoso> pmichaud, infix:<+>(*@items) as the associativity of some infix has changed

[21:43] <TimToady> then you can always call reduce &[..], whatever

[21:43] <pmichaud> ruoso: has that made it into a spec somewhere?

[21:43] <pmurias> ruoso: how do we call the protoobject creation method? create_protoobject?

[21:43] <ruoso> pmurias, no... simply CREATE

[21:43] <[particle]> what about Range(*@list)

[21:44] <TimToady> std: Range(*@list)

[21:44] <p6eval> std 25530: OUTPUT«############# PARSE FAILED #############␤Unable to parse argument list; couldn't find final ')' at /tmp/T3QRIBv76X line 1:␤------> [32mRange(*[31m@list)[0m␤    expecting any of:␤        POST␤   infix or meta-infix␤        infix stopper␤    postfix␤       

[21:44] <p6eval> ..postfix_prefix_meta_operator␤       standard stopper␤...

[21:44] <ruoso> pmichaud, it made into STD iirc

[21:44] <[particle]> hrmm

[21:45] <[particle]> std: Range(@list[0,1])

[21:45] <p6eval> std 25530: OUTPUT«Potential difficulties:␤  Variable @list is not predeclared at /tmp/eQlttHiVhU line 1:␤------> [32mRange([31m@list[0,1])[0m␤ok 00:02 34m␤»

[21:45] <ruoso> pmurias, I mean... $how.CREATE, not $obj.CREATE, of course

[21:46] <TimToady> [particle]: that would depend on whether Range knows how to coerce a list to minmax

[21:46] <[particle]> yep, it sure would.

[21:46] <ruoso> one could argue that to be a very nice feature of Range

[21:46] <pmichaud> ruoso: STD.pm seems to still indicate infix:<+> as being :assoc(left)

[21:46] <[particle]> so, i wonder....

[21:46] *** M_o_C left
[21:46] <pmichaud> or am I looking in the wrong place?

[21:47] <ruoso> pmichaud, I might be wrong... it's just something I remember...

[21:47] <TimToady> ruoso: we restrict syntactic reduce operators to those that make sense when used n-ary, since other use might well indicate a braino

[21:47] <TimToady> and because your trick is too cute to live :)

[21:47] <pmichaud> ruoso: I remember it being speculated, but I didn't see any official changes come through.  (otoh, I havent been following _every_ change so it's entirely possible I've overlooked it)

[21:48] <ruoso> TimToady, I wasn't even thinking about it as a trick... it just felt as a natural use of the reduction operator... I didn't meant a trick... 

[21:48] <pmichaud> I'm very familiar with the "too cute to live" side of things :-)

[21:48] <pmurias> ruoso: one thing i'm not sure how to do cleanly is defining things like infix:<+>:(int,int)

[21:48] <PerlJam> ruoso: it feels bizarre to me if natural to you  :)

[21:49] <ruoso> it has been said that I think sideways...

[21:49] <pmurias> it needs to be written in C for now, and yet has to .FETCH it's arguments

[21:49] <TimToady> if you're going to call a function with two arguments, call the function

[21:49] <ruoso> TimToady, I was also expecting [..] to DWIM

[21:50] <ruoso> i.e.: call minmax

[21:50] <pugs_svn> r25531 | lwall++ | [STD] revise previous patch to allow &[..]

[21:50] <jnthn> That feels...odd.

[21:50] <TimToady> ruoso: I'm doing your readers a favor :)

[21:51] <ruoso> pmurias, I've been using a trick there... which is to define a function in mold that would call another function in C after doing the FETCHs

[21:51] <jnthn> But @x ==> { *.min .. *.max } or similar ain't so bad. :-)

[21:51] <ruoso> TimToady, well, if I do think sideways... I think I shouldn't complain about that ;)

[21:52] <TimToady> :)

[21:52] *** skids left
[21:52] <TimToady> we don't allow ..= either

[21:52] <pmurias> ruoso: wouldn't that cause a lot of boilerplate for every function?

[21:52] <ruoso> pmurias, only for the ones we're going to define that way

[21:52] <ruoso> which are not supposed to be many

[21:53] <[particle]> .. is too fiddly

[21:53] <ruoso> TimToady, ahhhh.... I already had code using it ;) ;) ;)

[21:53] <pmurias> ruoso: all the arithmetic operators on native integers

[21:53] <TimToady> too diffy, actually

[21:53] <TimToady> meaning the type of the result differs from the arguments

[21:54] <[particle]> ah, right.

[21:54] <[particle]> my $x = 3; $x ..= 5; # diffy

[21:54] *** r0bby_ is now known as r0bby

[21:54] <ruoso> pmurias, but if you think about it... it's the same boilerplate that Perl 6 will do everytime...

[21:54] <ruoso> pmurias, so no much harm

[21:55] <TimToady> std: [..] 1,2,3

[21:55] <p6eval> std 25531: OUTPUT«############# PARSE FAILED #############␤Can't reduce a nonchaining operator because it's diffy and not chaining at /tmp/4GDs6vLxs1 line 1:␤------> [32m[..][31m 1,2,3[0m␤    expecting prefix_circumfix_meta_operator__S_081reduce␤FAILED 00:02 33m␤»

[21:55] <[particle]> how can i create a type that curries a value, like: my RangeFrom10 $x .= new 50;

[21:55] <ruoso> pmurias, of course it would be cute if we had something in the RI DSL to generate the code for the binding of the signature...

[21:56] <TimToady> std: &[..] |@foo

[21:56] <p6eval> std 25531: OUTPUT«############# PARSE FAILED #############␤Can't understand next input--giving up␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range at /tmp/0qYcrkA5uN line 1:␤------> [32m&[[31m..]

[21:56] <p6eval> ..|@foo...

[21:56] <pmurias> ruoso: one alternative i tried in my working copy is to wrap a C int_add with a infix:<+>:(int,int) written in perl 6

[21:56] <TimToady> std: &[..](|@foo)

[21:56] <p6eval> std 25531: OUTPUT«############# PARSE FAILED #############␤Can't understand next input--giving up␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range␤Please use ..* for indefinite range at /tmp/BqK9FwxHEX line 1:␤------>

[21:56] <p6eval> ..[32m&[[31m..](|@foo...

[21:56] <TimToady> I think the lex clobbering timer hasn't gone off yet

[21:56] <ruoso> pmurias, indeed... you can have the outer function in Perl 6, not mold...

[21:57] <ruoso> pmurias, then call a s1p_ccode that receives the actual arguments 

[21:57] <ruoso> and you do the FETCH in Perl 6

[21:59] <pmurias> i'm thinking of adding something like use NATIVE::int :from<C> :header<native_int.h>;

[22:00] <ruoso> pmurias, you don't need to... you just need to have nativeimpl:infix:<+>:(int,itn) available in the lexical scope

[22:00] <ruoso> TimToady, I suppose I can add as many parts as I want in my function name by using the ':'

[22:01] *** rob__ joined
[22:01] <ruoso> std: sub nativeimpl:infix:<+>:(int,int)($a,$b) {...}

[22:01] <p6eval> std 25531: OUTPUT«ok 00:02 33m␤»

[22:02] <TimToady> std: &[..](|[1,2])

[22:02] <p6eval> std 25531: OUTPUT«ok 00:03 46m␤»

[22:02] <pmurias> ruoso: do you think loading them in with use would be better than manually inserting them into the lexical scope/some namespace?

[22:02] <pmurias> shower&

[22:04] <ruoso> pmurias, we eventually could have a SMOP:: package where we store this odd functions and types

[22:04] * pmurias forgot the hot water is cut off due to repairs of some sort :(

[22:04] <ruoso> and then have this SMOP:: package in the lexical prelude

[22:05] <pmurias> what i'm unsure if it's better to insert the primitives manually or via a use :from<C>

[22:08] <ruoso> pmurias, let's insert them manually, but inside the SMOP:: package

[22:08] <ruoso> I'm not sure what kinds of weirdness we can have from a "use :from<C>"

[22:09] *** Ariens_Hyperion joined
[22:09] <ruoso> maybe we could think of something like "use s1p_add_int_int :from<SMOP__S1P__CCode>"

[22:10] <ruoso> which is more explicit on what it means

[22:10] <ruoso> and it could even check if that symbol is really a s1p_ccode 

[22:11] <ruoso> but I'm not sure implementing the symbol lookup is worth the trouble...

[22:11] <ruoso> it's probably better to register the symbols manually 

[22:23] *** alester joined
[22:25] <pugs_svn> r25532 | hinrik++ | [util/perl6.vim] allow R modifier on reduce operators

[22:25] <pugs_svn> r25533 | pmurias++ | [smop] added PRIMITIVES::int_add and used it to implement infix:<+>:(int,int)

[22:25] <pugs_svn> r25533 | pmurias++ | [mildew] remove lamed circular reference breaking

[22:25] <pugs_svn> r25533 | pmurias++ | added a noop RoleHOW

[22:27] <pmurias> ruoso: do you think the primitives can be defined like that (they should be moved out from lexical_prelude to a seperate file propably)?

[22:29] <pugs_svn> r25534 | pmurias++ | [smop] fixed bug with &PRIMITIVES::int_add

[22:39] *** ejs left
[22:42] <pugs_svn> r25535 | pmurias++ | [mildew] added &infix:<==>:(int,int),&infix:<->:(int,int)

[22:42] <pugs_svn> r25535 | pmurias++ | updated bootstrap.dot

[22:45] *** szabgab joined
[22:46] *** ruoso left
[22:50] *** cas left
[22:54] *** tarbo2 joined
[23:02] *** arthurium left
[23:05] *** mikehh joined
[23:09] *** ZuLuuuuuu left
[23:11] *** icwiener_ joined
[23:12] *** hercynium left
[23:15] *** icwiener_ left
[23:23] *** rob__ left
[23:25] *** Whiteknight joined
[23:26] *** bacek_ joined
[23:27] *** skids joined
[23:28] *** icwiener left
[23:36] *** bigpresh is now known as bigpresh_

[23:36] *** bigpresh_ is now known as presh

[23:36] *** nihiliad left
[23:36] *** presh is now known as bigpresh

[23:43] *** Ariens_Hyperion left
[23:43] *** pmurias left
[23:47] *** alester left
[23:58] *** Tene_ joined
