[00:06] *** ruoso_ joined
[00:08] *** ruoso_ left
[00:12] *** nsh left
[00:15] *** icwiener left
[00:15] *** ruoso left
[00:17] *** nsh joined
[00:20] <ab5tract> stjohnson, I like ruby but am also excited about perl 6

[00:23] *** lichtkind_ left
[00:23] *** nsh left
[00:25] *** pmurias left
[00:31] *** nsh joined
[00:43] *** kst left
[00:43] *** kst joined
[00:43] <sjohnson> ab5tract: i think Perl 6 will be my favourite

[00:43] <sjohnson> and i am excited as well

[00:45] *** mizioumt left
[00:45] *** frew|work left
[00:46] <ab5tract> sjohnson, why don't you like ruby 

[00:46] <sjohnson> if there wasn't perl 6 it would be my favourite, but not a fan of most blocks (like if, etc) being done with english words

[00:46] <sjohnson> as i like to hit the % key in Vim, and have it match the { and }'s

[00:47] <sjohnson> that's one reason off the top of my head

[00:47] <ab5tract> cool

[00:47] <sjohnson> another thing.. in perl, you can do if(@ARGV)

[00:47] <sjohnson> whereas in ruby, you will have to do if ARGV.empty?

[00:47] <sjohnson> or something like that

[00:47] <ab5tract> unless ARGV.empty? , yeah

[00:48] <sjohnson> yeah thats the one

[00:48] <sjohnson> unless

[00:48] <sjohnson> i prefer using if's and perl knowing what i am trying to do

[00:48] <ab5tract> yeah, they are two quite different branches on the family tree

[00:48] <sjohnson> i can usually write in Perl quite fast becuase the if statement can always figure out what i am trying to accomplish

[00:49] <ab5tract> Tene, are you there?

[00:51] <ab5tract> sjohnson, yes, that is a consequence of Ruby's everything-as-object model

[00:52] <sjohnson> i think the fact that things that are empty / 0 are true in ruby is the real issue

[00:52] <ab5tract> sjohnson, which is a consequence of the said model

[00:53] <sjohnson> but doesnt perl 6 do it too?

[00:53] <ab5tract> what? treat everything as an object?

[00:53] <sjohnson> yeah

[00:53] <sjohnson> rakudo: say 0.WHAT

[00:53] <p6eval> rakudo 23718a: OUTPUT«Int()␤»

[00:54] <sjohnson> rakudo: if 0 { } else { print "false"; }

[00:54] <ab5tract> i don't think so, or at least minus the limitations that Ruby's implementation constrains

[00:54] <p6eval> rakudo 23718a: OUTPUT«false»

[00:55] <ab5tract> rakudo: my $x; if $x { } else { print "false"; }

[00:55] <p6eval> rakudo 23718a: OUTPUT«false»

[00:56] *** wknight8111 left
[00:57] <sjohnson> rakudo: my $x; say $x.WHAT;

[00:57] <p6eval> rakudo 23718a: OUTPUT«Failure()␤»

[00:58] <sjohnson> in any case, i am super excited for Perl 6 to come out

[00:59] <sjohnson> it fixes many minor annoyances in perl 5, plus a whole lot more 

[01:00] <ab5tract> a whole whole lot more

[01:00] <sjohnson> rakudo:  my $x = do if 1 { 5 } else { 10};  say $x;

[01:00] <p6eval> rakudo 23718a: OUTPUT«5␤»

[01:00] <sjohnson> rakudo:  my $x = do(if 1 { 5 } else { 10});  say $x;

[01:00] <p6eval> rakudo 23718a: OUTPUT«5␤»

[01:00] <sjohnson> pugs:  my $x = do(if 1 { 5 } else { 10});  say $x;

[01:00] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "$x"␤    expecting "=", expression, ")", context, ":" or "("␤    postfix op␤    at /tmp/HbthV3fOE8 line 1, column 4␤»

[01:01] <sjohnson> pugs:  my $x = do if 1 { 5 } else { 10};  say $x;

[01:01] <p6eval> pugs: OUTPUT«5␤»

[01:01] <sjohnson> interesting

[01:01] <Tene> ab5tract: I am here.

[01:01] <ab5tract> i had a suggestion for the cardinal-rakudo bridging

[01:01] <Tene> ab5tract: go ahead.

[01:01] <ab5tract> idiomatic ruby would have a foreign_require "example"

[01:02] *** nbrown_ joined
[01:02] <Tene> ab5tract: I don't know what you mean.

[01:02] <ab5tract> but would normally never also have an option for loading a module within that

[01:02] <ab5tract> sorry

[01:02] <ab5tract> right now foreign_require takes two arguments, right?

[01:03] <ab5tract> the library to load and the module to load

[01:03] *** nbrown left
[01:03] <ab5tract> (the module within the library)

[01:03] <ab5tract> in idiomatic ruby you load the library

[01:03] <TimToady> std: my $x = do(if 1 { 5 } else { 10});  say $x;

[01:03] <p6eval> std 26923: OUTPUT«##### PARSE FAILED #####␤Unable to parse argument list; couldn't find final ')' at /tmp/Rqv5mgwJCg line 1:␤------> my $x = do(if 1 { 5 } else { 10});  say $x;␤    expecting nofun␤FAILED 00:02 36m␤»

[01:04] <ab5tract> and then explicitly include any modules you wish to use, when you wish to use them

[01:04] <ab5tract> so the example from the blog would be

[01:04] <Tene> ab5tract: no, it requires the language to load a library from, and the library.

[01:05] <ab5tract> oh okay yes i see that 

[01:06] <Tene> ab5tract: it's not rakudo/cardinal specifically, it's any language that supports the same API.

[01:06] <Tene> No other languages do yet.

[01:06] <ab5tract> can you send me the link to your blog i've misplaced it

[01:07] <Tene> And foreign_require is just the first way to load a library that i could think of.

[01:07] <Tene> http://blogs.gurulabs.com/stephen/

[01:08] <ab5tract> okay so the distinction im trying to make is

[01:08] <ab5tract> if Foo.pm was in fact a ruby library

[01:08] <ab5tract> when you do a require "foo"

[01:08] <ab5tract> you would still have to do an 'include Foo'

[01:09] <ab5tract> in order for greet to be visible

[01:09] <ab5tract> if sub greet were defined outside of module Foo, then they would be visible upon the load

[01:09] <Tene> OK, yes, that should probably be fixed.

[01:09] <Tene> I don't actually know ruby.

[01:10] <ab5tract> yeah i know so I just wanted to give you a heads up :)

[01:10] <Tene> I will accept and commit any patches to cardinal to work that way.  I'd love to see some work on that.

[01:10] <ab5tract> yeah I keep meaning to write test cases and all sorts of crap for cardinal

[01:10] <ab5tract> but i'm spread pretty thin

[01:10] <ab5tract> ill fork cardinal though

[01:11] <Tene> Even test cases would be great.

[01:12] <ab5tract> yeah like I said I've been meaning to do them I'm just working on like a million projects at once right now

[01:12] <ab5tract> anyway, you mentioned on your blog for suggestions on how to make it more ruby-like

[01:12] <ab5tract> ask and you shall receive ;)

[01:14] <Tene> Thank you.

[01:14] <Tene> If you could post tha tin a comment there, I'd be more likely to remember it. btw. :)

[01:14] <ab5tract> Tene, does cardinal assume I have parrot in my path?

[01:14] <ab5tract> sure thing

[01:15] <Tene> You can use an argument to Config.pl, I think...

[01:15] <Tene> If not, that's probably a bug

[01:16] <Tene> ah

[01:16] <Tene> --parrot-config=~/src/parrot/parrot_config

[01:17] *** DemoFreak left
[01:20] <ab5tract> cool thx

[01:21] *** M_o_C left
[01:24] *** ruoso joined
[01:24] <ab5tract> new comment in mod queue :)

[01:26] <Tene> ab5tract: the part about automatically importing subs not defined in a namespace is unlikely to be supported without some significant changes in Parrot, that won't happen for quite a while.

[01:27] <Tene> In Parrot, there isn't actually a way to say "What are the objects in this bytecode file?".  All you can do is load the bytecode, and then look for symbols in a specific namespace.

[01:28] <ab5tract> okay that is fune

[01:28] <ab5tract> *fine

[01:29] <ab5tract> it was more there as an example

[01:29] <ab5tract> indeed it is rarely done that way

[01:30] <ab5tract> awesome that cardinal has an interpreter shell!

[01:32] *** shinobi-cl joined
[01:34] *** bacek joined
[01:45] <Tene> :)

[01:45] *** IRSeekBot joined
[01:45] *** Chillance left
[02:01] *** ab5tract_ joined
[02:11] *** alester joined
[02:20] *** shinobi-cl left
[02:20] *** nsh left
[02:24] *** bacek_ joined
[02:25] *** alester left
[02:36] *** ruoso left
[02:38] *** bacek left
[02:46] *** VX64Z left
[02:52] *** ruoso joined
[02:59] <literal> rakudo: say <a #channel>

[02:59] <p6eval> rakudo 23718a: OUTPUT«a#channel␤»

[03:00] <literal> rakudo: say «a #channel»

[03:00] <p6eval> rakudo 23718a: OUTPUT«a#channel␤»

[03:06] <bacek_> rakudo: say 1.i

[03:06] <p6eval> rakudo 23718a: OUTPUT«Method 'i' not found for invocant of class 'Int'␤»

[03:07] <bacek_> rakudo: say eval("1.i")

[03:07] <p6eval> rakudo 23718a: OUTPUT«␤»

[03:07] <bacek_> perl6: say 1.i

[03:07] <p6eval> rakudo 23718a: OUTPUT«Method 'i' not found for invocant of class 'Int'␤»

[03:07] <p6eval> ..pugs: OUTPUT«*** No such method in class Int: "&i"␤    at /tmp/SKXgysFtjS line 1, column 5 - line 2, column 1␤»

[03:07] <p6eval> ..elf 26923: OUTPUT«Can't call method "i" without a package or object reference at (eval 123) line 3.␤ at ./elf_h line 5881␤»

[03:08] <bacek_> seen moritz_

[03:08] <bacek_> !seen moritz_

[03:09] <bacek_> say moritz_ Looks like is_approx(eval("sqrt($i.i)"), 1i, 'got the square root of -1.i') in S32/sqrt.t is incorrect

[03:09] <bacek_> msg moritz_ Looks like is_approx(eval("sqrt($i.i)"), 1i, 'got the square root of -1.i') in S32/sqrt.t is incorrect

[03:10] <bacek_> EWRONGDIALECT

[03:10] <bacek_> !say moritz_ Looks like is_approx(eval("sqrt($i.i)"), 1i, 'got the square root of -1.i') in S32/sqrt.t is incorrect

[03:13] <bacek_> perl6: say log10(-1i)

[03:13] <p6eval> elf 26923: OUTPUT«Undefined subroutine &GLOBAL::log10 called at (eval 124) line 3.␤ at ./elf_h line 5881␤»

[03:13] <p6eval> ..pugs: OUTPUT«0 + -0.6821881769209206i␤»

[03:13] <p6eval> ..rakudo 23718a: OUTPUT«0␤»

[03:13] <bacek_> perl6: say log10(-1i).WHAT

[03:13] <p6eval> rakudo 23718a: OUTPUT«Num()␤»

[03:13] <p6eval> ..elf 26923: OUTPUT«Undefined subroutine &GLOBAL::log10 called at (eval 125) line 3.␤ at ./elf_h line 5881␤»

[03:13] <p6eval> ..pugs: OUTPUT«Complex␤»

[03:15] *** bacek_ is now known as bacek

[03:15] <pugs_svn> r26924 | bacek++ | [t/spec] Mark all complex log10 as todo for rakudo. Including wrongly passing tests.

[03:24] *** cspencer joined
[03:39] *** meppuru joined
[03:48] *** cspencer left
[03:54] *** meppl left
[03:55] <ab5tract_> which editors have syntax highlighting for parrot and or perl 6 and where can I find them?

[03:55] <eternaleye> bacek: If you're looking for the messagebot, labdabot-- has @tell as his syntax, but is deprecated, and phenny++ has 'phenny: tell ..." as her syntax

[03:56] <eternaleye> *lambdabot

[03:56] <bacek> eternaleye: thanks

[03:56] <eternaleye> np

[03:56] <ab5tract_> by 'them' I mean the syntax highlighting configs

[03:57] <bacek> ab5tract_: both editors highlighting

[03:57] <bacek> has highlighting

[03:59] <eternaleye> ab5tract_: At very least Emacs and VIM have syntax hilighting, running a find command to locate the respective scripts (ISTR them being in the pugs repo)

[04:00] *** VX64Z joined
[04:00] <eternaleye> util/perl6.vim , misc/Syntax-Highlight-Perl6/lib/rsc/perl6.vim , and util/cperl-mode.el

[04:05] <meppuru> good night

[04:06] *** meppuru left
[04:07] <ab5tract_> eternaleye, why thank you very much

[04:12] <ab5tract_> strange, rakudo comes with no such thing

[04:15] <eternaleye> ab5tract_: http://svn.pugscode.org/pugs

[04:15] <eternaleye> (also the svn co url)

[04:16] <ab5tract_> just saying, thats a bit strange that it doesnt come with rakudo

[04:17] <eternaleye> Oh, I thought you were looking in the rakudo tree and couldn't find what I listed

[04:17] <eternaleye> :/

[04:18] * ab5tract_ is stupid but not quite that :)

[04:21] *** xinming_ joined
[04:24] * eternaleye is

[04:25] * eternaleye did that

[04:26] <pugs_svn> r26925 | jdlugosz++ | add C<> tags, fix typos, fix out-of-date \$args to |$args, use Callable (not Code or others) for the role, change .wrap to return a cookie object to unwrap, remove the only use of := that wasn't in a declaration (hoping for single-assign semantics) and show regular assignment

[04:26] <pugs_svn> ..for Routine to replace its "do" property without changing the Routine object's identity.

[04:38] *** xinming left
[04:48] <pugs_svn> r26926 | jdlugosz++ | Refer to actual concrete class C<Routine> where applicable, replace Code with actual class or role names.  Add mention of non-instantiatable roles were classes were listed instead of "etc."

[04:51] *** VX64Z left
[04:53] <TimToady> bacek: it's 1\i now, and .i is a normal method.  This applies to any postfix operators that start alphabetic

[04:53] <TimToady> it's not necessary on 1i, of course, but on $x\i it is.

[04:54] <TimToady> rakudo: say 1\i

[04:54] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "\\i"␤in Main (src/gen_setting.pm:0)␤»

[04:54] <TimToady> looks like rakudo doesn't do that yet

[04:54] <TimToady> std: say 1\i

[04:54] <p6eval> std 26926: OUTPUT«ok 00:02 35m␤»

[04:55] *** kst left
[04:55] *** kst joined
[04:57] *** bacek_ joined
[04:58] <TimToady> bacek_: see ^^

[05:00] <bacek_> TimToady: I missed previous line. And ilbot is absent...

[05:01] <TimToady> it's 1\i now, and .i is a normal method.  This applies to any postfix operators that start alphabetic

[05:01] <TimToady> it's not necessary on 1i, of course, but on $x\i it is.

[05:01] <TimToady> rakudo doesn't know it yet though

[05:01] <TimToady> but

[05:02] <TimToady> std: say 1\i

[05:02] <p6eval> std 26926: OUTPUT«ok 00:02 35m␤»

[05:02] <bacek_> rakudo: say 1\i

[05:02] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "\\i"␤in Main (src/gen_setting.pm:0)␤»

[05:02] <bacek_> ok. Test is definitely wrong.

[05:05] *** skids left
[05:05] <pugs_svn> r26927 | bacek++ | [t/spec] Remove wrong sqrt(-1.i) test. TimToady++ for clarification.

[05:11] *** FurnaceBoy left
[05:13] *** bacek left
[05:18] *** hcchien_ joined
[05:18] *** clkao left
[05:18] *** hcchien left
[05:21] *** clkao joined
[05:41] *** ejs joined
[05:51] *** ab5tract_ left
[05:56] *** ejs left
[05:58] *** sbp left
[06:01] *** finanalyst joined
[06:03] <finanalyst> rakudo: say foo(1,2,3);sub foo($a,$b is copy,$c?){$b=4;return $a+$b+$c}

[06:03] <p6eval> rakudo 23718a: OUTPUT«8␤»

[06:03] <finanalyst> rakudo: say foo(1,2,3);sub foo($a,$b is copy, $c=3){$b=4;return $a+$b+$c}

[06:03] <p6eval> rakudo 23718a: OUTPUT«8␤»

[06:04] <finanalyst> rakudo: say foo(1,2,3);sub foo($a,$b,$c=3 is copy){$c=4;return $a+$b+$c}

[06:04] <p6eval> rakudo 23718a: OUTPUT«Unable to parse multisig; couldn't find final ')' at line 1, near "is copy){$"␤in Main (src/gen_setting.pm:0)␤»

[06:05] <finanalyst> rakudo: say foo(1,2,3);sub foo($a,$b,$c=3 is copy ){$c=4;return $a+$b+$c}

[06:05] <p6eval> rakudo 23718a: OUTPUT«Unable to parse multisig; couldn't find final ')' at line 1, near "is copy ){"␤in Main (src/gen_setting.pm:0)␤»

[06:05] <TimToady> default has to follow traits

[06:06] <finanalyst> rakudo: say foo(1,2,3);sub foo($a,$b,$c is copy =3){$c=4;return $a+$b+$c}

[06:06] <p6eval> rakudo 23718a: OUTPUT«7␤»

[06:06] <finanalyst> ah

[06:08] *** sbp joined
[06:08] <sjohnson> rakudo:  say dazzle();

[06:08] <p6eval> rakudo 23718a: OUTPUT«Could not find non-existent sub dazzle␤»

[06:09] *** ejs joined
[06:09] <finanalyst> i just checked S06 again and did not find traits before defaults to be specified

[06:13] <finanalyst> TimToady: may I suggest a clarification to S06 specifying traits before defaults?

[06:16] <TimToady> it's clarified in STD :)

[06:19] *** ejs left
[06:20] <finanalyst> TimToady: is STD part of the description of perl6?

[06:20] <TimToady> effectively

[06:20] <finanalyst> how do i read it?

[06:21] <finanalyst> i mean, where is the latest version?

[06:21] <TimToady> src/perl6/STD.pm

[06:21] *** ejs joined
[06:22] <finanalyst> will STD be one of the defining documents for perl6, or is it a temporary condition - that the working copy is a part of the spec?

[06:22] <TimToady> the problem with putting traits after the default is it looks like the trait applies to the default value

[06:23] <TimToady> it is defining

[06:25] <finanalyst> is this a departure from the idea that perl6 should be defined independently from the implementation?

[06:26] <sjohnson> rakudo:  print do 1 + 3;

[06:26] <p6eval> rakudo 23718a: OUTPUT«4»

[06:26] <TimToady> sure, but it's a departure that's several years old

[06:27] <finanalyst> my perception was that as you found inconsistencies/better ways of doing things, you updated the specs

[06:28] <TimToady> STD is one of the specs

[06:28] <sjohnson> rakudo:  my $x = 100;  my $y = 0; my $ret;  do {   $y++;   $x++;    $ret .= "$x, "; } while ($y < 3);   print $ret;

[06:28] <p6eval> rakudo 23718a: OUTPUT«.= must have a call on the right hand side at line 1, near " .= \"$x, \""␤in Main (src/gen_setting.pm:2553)␤»

[06:29] <finanalyst> TimToady: STD is not yet cited on any of the sites as being a part of the specs, or official documentation

[06:29] <TimToady> tough nuggies :)

[06:29] <TimToady> std: my $x = 100;  my $y = 0; my $ret;  do {   $y++;   $x++;    $ret .= "$x, "; } while ($y < 3);   print $ret;

[06:29] <p6eval> std 26927: OUTPUT«Potential difficulties:␤  Possible obsolete use of .= as append operator; in Perl 6 please use ~= instead at /tmp/cfEqJLbxwC line 1:␤------>  $ret;  do {   $y++;   $x++;    $ret .= "$x, "; } while ($y < 3);   print $ret;␤ok 00:04 37m␤»

[06:31] <sjohnson> did i find a bug?

[06:32] <sjohnson> is is there a proper way to append strings other than .= 

[06:32] <sjohnson> in p6

[06:32] <TimToady> use ~=, since ~ is concat

[06:33] <TimToady> also, there's no do {} while

[06:33] <TimToady> std: my $x = 100;  my $y = 0; my $ret;  do {   $y++;   $x++;    $ret ~= "$x, "; } while ($y < 3);   print $ret;

[06:33] <p6eval> std 26927: OUTPUT«ok 00:04 37m␤»

[06:33] <TimToady> std: my $x = 100;  my $y = 0; my $ret;  repeat {   $y++;   $x++;    $ret ~= "$x, "; } while ($y < 3);   print $ret;

[06:33] <p6eval> std 26927: OUTPUT«ok 00:04 37m␤»

[06:34] <TimToady> rakudo: my $x = 100;  my $y = 0; my $ret;  do {   $y++;   $x++;    $ret ~= "$x, "; } while ($y < 3);   print $ret;

[06:34] <p6eval> rakudo 23718a: OUTPUT«101, 102, 103, »

[06:34] <sjohnson> std: my $x = 100;  my $y = 0; my $ret;  repeat {   $y++;   $x++;    $ret ~= "$x, "; } while ($y < 3);   print "$ret\n";

[06:34] <p6eval> std 26927: OUTPUT«ok 00:04 37m␤»

[06:34] <sjohnson> wow

[06:34] <sjohnson> oops

[06:34] <sjohnson> i broketed it

[06:35] <TimToady> the do form is supposed to be prohibited

[06:38] <sjohnson> std: my $x = 100;  my $y = 0; my $ret; do {   $y++;   $x++;    $ret ~= "$x, "; } while ($y < 3);   print "$ret\n";

[06:38] <p6eval> std 26927: OUTPUT«ok 00:04 37m␤»

[06:39] <sjohnson> neither one seem to work with std

[06:39] <TimToady> std doesn't do anything except parse

[06:39] <TimToady> biab &

[06:39] <sjohnson> doing this line exactly in perl 5 buggers up my prompt

[06:40] <sjohnson> my $x = 100; my $y = 0; my $ret; do { $y++; $x++; $ret .= "$x, "; } while ($y < 3); print "$ret"

[06:40] <sjohnson> if i dont put the "\n" after $ret, it buggers up my prompt

[06:40] <sjohnson> i wonder why

[06:40] * sjohnson is going to try on another shell

[06:40] <sjohnson> ahh works there

[06:41] <sjohnson> probably something to do with my fancy-shamncy bash color prompt

[06:48] <sjohnson> perl!

[06:55] *** sri_kraih joined
[07:00] *** hcchien_ left
[07:00] *** clkao left
[07:04] *** cognominal left
[07:21] *** nbrown_ left
[07:26] *** stepnem left
[07:28] *** iblechbot joined
[07:30] *** nemstep joined
[07:30] *** stepnem joined
[07:32] *** stepnem left
[07:36] *** nemstep left
[07:38] *** stepnem joined
[07:56] *** mikehh left
[08:07] *** mikehh joined
[08:16] *** sbp left
[08:17] *** sbp joined
[08:17] *** bacek_ left
[08:17] <sbp> #talis

[08:17] <sbp> er, sorry

[08:17] <sbp> "/join " in one tab, focus stolen, channel name in another... :-)

[08:19] *** ssm joined
[08:28] *** abra joined
[08:34] *** ejs left
[08:36] <sjohnson> worry not, friend

[08:42] *** bacek joined
[08:46] *** cognominal joined
[09:03] *** abra left
[09:12] *** nacho_ left
[09:14] *** DemoFreak joined
[09:35] *** clkao joined
[09:40] *** bacek left
[09:43] *** bacek joined
[09:48] *** pmurias joined
[09:49] *** nacho_ joined
[09:53] *** nacho__ joined
[09:54] *** nacho__ left
[09:54] *** nacho_ left
[10:12] *** ZuLuuuuuu joined
[10:14] <pmurias> ruoso: hi

[10:23] <finanalyst> i am running a rakudo program with an iterative loop. it generates a 'segmentation fault' at the same point in the loop for a variety of adjustments to the algorithm. anything i can do to isolate the problem?

[10:25] <Tene> finanalyst: try to reduce the program to as simple a program as possible that still segfaults.

[10:26] <Gothmog_> or run it with valgrind :)

[10:27] <finanalyst> what is valgrind?

[10:28] <finanalyst> ok just googled valgrind. anything special to apply to rakudo?

[10:28] *** M_o_C joined
[10:29] <Gothmog_> i dunno. should be compiled with debug symbols, though. :)

[10:36] <finanalyst> are debug symbols included by default with bleeding edge rakudo?

[10:43] *** skids joined
[10:50] *** Chillance joined
[10:54] *** abra joined
[10:55] *** bacek_ joined
[11:02] <skids> When not eagerized, 1..3 is a Range and 1..3.Iterator is a RangeIterator (if the spec is current).   Anyone want to hazard a guess as to what the corresponding roles for <a b c> xx 10 are?

[11:05] <skids> Or offer suggestions about how to prevent an explosion of such classes, e.g. a generic generator role with opaque state and assignable .get method?

[11:07] <skids> So that everything that gens a list is List does Generator but nothing more specific?

[11:09] *** bacek left
[11:11] *** bacek_ left
[11:13] *** wknight8111 joined
[11:14] *** iblechbot left
[11:15] *** meppl joined
[11:15] *** ejs joined
[11:22] *** REPLeffect left
[11:23] *** jferrero left
[11:23] *** finanalyst left
[11:24] *** kst left
[11:24] *** kst joined
[11:32] *** pmurias left
[11:43] *** lichtkind joined
[12:21] *** payload left
[12:23] *** kane_ left
[12:29] *** M_o_C left
[12:39] *** icwiener joined
[12:43] *** kane_ joined
[12:44] *** _Chillance_ joined
[12:53] *** Chillance left
[13:03] *** M_o_C joined
[13:19] *** pmurias joined
[13:22] *** fridim_ joined
[13:25] *** ElectricHeavyLan joined
[13:29] *** Kisu joined
[13:32] *** araujo left
[13:46] *** Chillance joined
[13:50] *** kst left
[13:51] *** kst joined
[13:52] *** araujo joined
[13:54] *** _Chillance_ left
[13:54] *** M_o_C left
[13:58] *** ElectricHeavyLan left
[14:25] *** M_o_C joined
[14:37] *** nsh joined
[14:47] *** ilogger2_ joined
[14:51] *** payload joined
[14:55] *** LylePerl joined
[15:10] *** Psyche^ joined
[15:15] *** FurnaceBoy joined
[15:20] *** Psyche^ joined
[15:23] *** hcchien joined
[15:25] *** Psyche^_ joined
[15:37] *** jferrero joined
[15:37] *** iblechbot joined
[15:38] *** araujo joined
[15:46] *** DJ-DONGDOT joined
[15:53] *** kst joined
[16:22] *** mikehh_ joined
[16:43] *** nbrown joined
[16:46] *** Psyche^ joined
[17:03] *** kst joined
[17:05] *** cspencer joined
[17:05] <cspencer> I've just built the latest build of rakudo, and the spectest is failing for me though it's not giving me a list of failed tests

[17:06] <cspencer> does anyone know why that might be?

[17:07] <cspencer> it looks something like this: http://pastie.org/488224

[17:18] <jnthn> cspencer: Heh, looks at first glance like it counts a passing todo test as a fail?!

[17:19] <cspencer> jnthn: i'm not sure...it was doing this on an earlier build last week and i don't recall the TODO being there at that time

[17:20] <jnthn> Wstat: 0 Tests: 29 Failed: 0

[17:20] <cspencer> hmmm

[17:20] <jnthn> oh, wait, that's just for the one file, not overall

[17:20] <jnthn> Hm. Odd.

[17:21] <cspencer> this is on os x, i'll do a check out on linux and see if i get the same result

[17:26] *** mberends joined
[17:27] <jnthn> Can't believe we fail at failing...

[17:30] * jnthn -> dinner

[17:35] <mberends> literal: ping

[17:48] *** amoc joined
[18:01] *** Lorn joined
[18:07] *** ilbot2 joined
[18:20] *** masak joined
[18:20] <literal> pong

[18:20] <masak> saluton, #perl6.

[18:23] <masak> sjohnson: oh, you're still here? in that case, welcome. :)

[18:27] *** nihiliad joined
[18:29] *** jferrero joined
[18:30] <mberends> literal: fwiw, just letting you know that I've decided to do a port of Pod::Parser to perl5 and v6.pm. I have no idea how it will come out, but scalability of parrot/rakudo has been bothering me and makes development and testing awkward. The port is actually research work for my talk in Lisbon.

[18:31] <mberends> masak: salutons 2 u 2.

[18:31] <masak> mberends: \o/

[18:31] <masak> mberends: a port? cool!

[18:32] <mberends> this v6.pm has been around a while and it needed to be tried out

[18:32] * masak googles 'cpan v6'

[18:33] <mberends> the docs are very scant so it seems best to dive in and try it

[18:33] <masak> Pugs, eh?

[18:33] <mberends> it has contributions from Pugs but appears to run completely in Perl 5

[18:34] <masak> o_O

[18:35] <masak> mberends: that sounds too good to be true...

[18:35] <mberends> it's just a subset of P6, too good to be true indeed

[18:36] <masak> sure, sure. but which subset? :)

[18:40] <literal> mberends: ok

[18:40] <literal> I've been using Damian's Perl6::Perldoc so far

[18:41] <mberends> literal: how has that worked for you?

[18:42] <masak> literal: g'day. tried to finish my pre-23rd work with u4x before leaving for the weekend, but I didn't get that far. I hope to look at it tomorrow. in the meantime, I'd be very happy to talk about the design of the grok tool.

[18:42] <literal> it's fast and understands everything except formatting codes with «» (though I think that's a bug)

[18:42] *** JDlugosz joined
[18:42] <literal> masak: ok

[18:42] <masak> literal: by the way, did you read moritz_++'s idea about meeting weekly in #perl6-gsoc?

[18:42] <JDlugosz> howdy folks

[18:43] <literal> masak: no, I must have missed that

[18:43] <masak> JDlugosz: saluton!

[18:43] <masak> literal: was a while ago.

[18:43] <mberends> JDlugosz, hi

[18:43] <literal> on FreeNode?

[18:43] <masak> literal: they did that last year. sounds like a good idea to me.

[18:43] <literal> yeah

[18:43] <masak> literal: yes, but that channel might not exist any more.

[18:44] <literal> it does now...

[18:44] <masak> ah http://irclog.perlgeek.de/ says #perl6-soc.

[18:44] <literal> ah, ok

[18:45] <JDlugosz> Hey masak, did you see my post to the mailing list?

[18:45] <masak> JDlugosz: I saw the link, but I was away and didn't have time to read it.

[18:45] * masak reads it now

[18:46] *** nsh joined
[18:47] <JDlugosz> The one that begins "my brain made a wrong turn some time on Tuesday."

[18:47] <masak> yes, I read that one.

[18:47] <masak> nice post.

[18:48] <masak> (I thought you meant the "Parameter Passing Examples" article linked from the first post in that thread.)

[18:48] <JDlugosz> So, can you offer any discussion to the questions I called out with arrows?

[18:49] <JDlugosz> The Parameter Passing is wrong, it seems.  But I'm glad to hear it will be good once it's straightened out!

[18:49] <masak> hm, I'm not one of the philosophers over here, I'm the guy who tries to beat Rakudo into submission... :)

[18:49] <JDlugosz> It's fuel to keep plugging away.

[18:50] <JDlugosz> The code-pounders often have real answers when the pholosophers (other than myself) don't see the issues.

[18:50] *** moritz joined
[18:50] <JDlugosz> To wit, "how does that happen"?  

[18:51] * masak reads the first question in the email carefully

[18:52] <masak> to be perfectly frank, the two levels of containers in Perl 6 always confused me a little.

[18:52] <JDlugosz> Or the second, which is short.

[18:53] <JDlugosz> It certainly has been confusing in the specs, so no doubt.

[18:55] <JDlugosz> I'm wondering if there is some level of DWIM implemented (not in the spec), or whether I'm missing something conceptually.

[18:55] <masak> JDlugosz: right now I'm backtracking from your first question, seeing how much of the previous part of the email I have to read to get the context.

[18:55] <masak> maybe I'll start by rambling about what I think happens with 'my $x = 1, 2, 3;'...

[18:55] <JDlugosz> Don't worry about what I said before on that thread.  I set up "from the top" in that post.  

[18:56] <JDlugosz> rambling:  OK.

[18:56] <masak> that's a scalar on the left and a list of stuff on the right.

[18:56] <JDlugosz> I'm all ears.

[18:56] <masak> the list gets turned into an array and stored into the scalar variable.

[18:57] <masak> I'm guessing you have no problem with that part.

[18:57] <JDlugosz> A little out of date... the list is now a Capture, and it doesn't get turned into anything else.  That is, in item context it returns itself.

[18:58] <masak> in that case, you know more than I do.

[18:58] <masak> rakudo: my $x = 1, 2, 3; say $x.WHAT

[18:58] <p6eval> rakudo 23718a: OUTPUT«Array()␤»

[18:58] <masak> that's my reality at present. :)

[18:58] <masak> I don't know about those fancy "Capture" thingies.

[18:59] <JDlugosz> Ah, in this case, say $x.WHAT, the method-on-scalar forwarding kicks in, and the WHAT applies to the contained object.  So it will indeed say it is a list (Array, List, Capture, depending on vintage of implementation).

[19:00] <JDlugosz> So we agree there:  $x is bound to a scalar, which holds the list object, which contains 3 Ints.

[19:00] <masak> JDlugosz: Array and List doesn't have to do with the age of the impl. they're just two different classes implementing Positional.

[19:01] <masak> rakudo: say Array ~~ List, List ~~ Array

[19:01] <p6eval> rakudo 23718a: OUTPUT«10␤»

[19:02] <masak> Arrays are a kind of List, but they're also mutable, which Lists aren't.

[19:02] <JDlugosz> vintage:  which type does the parenthetical comma-separated list create?

[19:02] <masak> the List. :)

[19:02] <masak> but I hear you, it's the Capture nowadays.

[19:02] <JDlugosz> but racudo shows Array.

[19:03] <masak> yes, because... hm, you really force me to think about the deep issues, don't you? :)

[19:03] <JDlugosz> Yes, the immutable "literal" sequence is now Captures throughout the synopses.

[19:03] <jnthn> je to masak! :-)

[19:03] <jnthn> masak: How was your weekend?

[19:03] <masak> jnthn: wonderful, thank you.

[19:04] <JDlugosz> Whatever.  It doesn't matter to the question at hand.  $x is bound to scalar, which contains something suitable for @.

[19:04] <jnthn> :-)

[19:04] <masak> jnthn: my brain is now running on pure Esperanto for a few days.

[19:04] <JDlugosz> When you say my @y := $x;  that should be an error because $x is not BOUND to something that does Positional.

[19:05] <JDlugosz> But should sub foo (&y) {...}  foo($x);   be expected to work via DWIM?

[19:05] *** ejs joined
[19:05] <masak> JDlugosz: as long as $x does Callable, sure.

[19:05] <JDlugosz> Sure, says I, when $x isn't bindable to &y, it goes with what $x contains, automatically.

[19:05] <JDlugosz> Callable?

[19:05] <jnthn> JDlugosz: I expect binding will dwim too, just needs a runtime check.

[19:05] <JDlugosz> foo does Callable.

[19:05] <masak> JDlugosz: Callable is the & role.

[19:06] <masak> just as Positional is the @ role.

[19:06] <jnthn> Callable is the role done by things that you can invoke.

[19:06] <JDlugosz> Sorry, I meant @y.

[19:06] <jnthn> Remember than a $foo can contain anything.

[19:06] <JDlugosz> Same difference.

[19:06] <masak> JDlugosz: ah.

[19:06] <masak> JDlugosz: is your question whether the Positional role has to sit on the variable or on its contents?

[19:06] <JDlugosz> "contains" == value or implementation type?

[19:07] <JDlugosz> masak:  Yes.  Seems that it must do both, to fit the intent.

[19:07] <masak> JDlugosz: yes, I think so.

[19:07] <masak> but my brain is foggy.

[19:07] <JDlugosz> Because you can certainly pass a real Array as the argument!

[19:07] <masak> sure.

[19:08] <JDlugosz> So, the argument bound to @y may be something that does Positional, or a scalar that contains such a thing.

[19:08] <masak> er.

[19:08] <masak> I don't think about it that way... :/

[19:09] <JDlugosz> my $x := @A;  foo($x);   # OK, bind directly to argument.

[19:09] <masak> when you do foo(@array), it passes the array in @array. when you do foo($array), and $array contains something that does Positional, it passes that.

[19:09] <JDlugosz> my $x;  $x=1,2,3;   foo($x);    # scalar doesn't do Positional.

[19:10] <masak> JDlugosz: why doesn't it do Positional?

[19:10] <jnthn> rakudo: my $x;  $x=1,2,3; sub foo(@a) { };  foo($x);

[19:10] <p6eval> rakudo 23718a:  ( no output )

[19:10] <jnthn> Good.

[19:10] <jnthn> JDlugosz: It does.

[19:10] * masak thought so

[19:10] <jnthn> JDlugosz: When you talk about $x you're really tending the mean "the value"

[19:11] <jnthn> If you want to talk about the container unambiguously, you would say $x.VAR

[19:11] <JDlugosz> Ah, might be old ideas?  Now, passing is done with a Capture, which doesn't know it needs to pull out the value.  It keeps everyting intact, for later use.  Think \( $x ).

[19:11] <JDlugosz> jnthn:  yes, I take that as a general design principle.

[19:12] <jnthn> JDlugosz: OK, so the upshot is that in the example above, it cares about whether the thing stored in the scalar does Positional.

[19:13] <masak> jnthn: btw, what's the latest word on the 'sub foo(Int @a) { ... }; my @a = 1..*; foo(@a)' issue? :)

[19:13] <JDlugosz> Yes.  In that particular call with that particular binding of $x.

[19:13] <jnthn> masak: Latest is you need to write my Int @a

[19:14] <masak> jnthn: ah. sounds familiar.

[19:14] <masak> jnthn: probably quite sane. if typing is done in one place, it could be done in both places.

[19:14] <jnthn> masak: This was discussed at NPW, because I kinda wanted to know too since I was trying to get parametric roles wrapped up at the time. And that was the outcome.

[19:14] <jnthn> masak: The other thing that came out though was that you can do

[19:14] <masak> jnthn: ok. I think I'm happy with that.

[19:14] <JDlugosz> if $x is bound directly to an Array, then foo($x); still works, but differently.

[19:14] <jnthn> sub foo(Num @x) { }; my Int @y; foo(@y)

[19:15] <jnthn> masak: Which it wasn't clear if you should be able to do before, but now it's clarified and in S14. :-)

[19:15] <jnthn> masak: I think it's a good enough balance of dwim vs implementation complexity.

[19:16] <masak> aye.

[19:16] <JDlugosz> Guys, what about my next question?  How does method calls on a scalar work?

[19:16] <jnthn> JDlugosz: Again, the container is just transparent.

[19:16] <jnthn> If you want to call a method on the container, do $foo.VAR.meth

[19:16] <JDlugosz> So the Scalar forwards all methods to its contents.

[19:17] <jnthn> Yes.

[19:17] *** icwiener_ joined
[19:17] <JDlugosz> Look what I said about nesting them.... right?

[19:17] <jnthn> Pretty much.

[19:17] <JDlugosz> So how does VAR actually work?

[19:18] <jnthn> Well, it's a macro.

[19:18] <jnthn> So the implementation can do whatever it feels like.

[19:18] <JDlugosz> Like what, specifically?

[19:19] <JDlugosz> It can't just wrap the scalar in something else, because forwading is a property of the scalar at run-time.

[19:19] <JDlugosz> I'm supposing that it returns a proxy.

[19:19] <jnthn> We do something along those lines in Rakudo, but the exact upshot is all a bit hazy at the moment.

[19:19] <jnthn> Yes, it's a kind of proxy.

[19:19] <jnthn> In Rakudo.

[19:19] <jnthn> There's probably more than one way to actually implement it.

[19:20] <jnthn> I'm not completely sure how it's all going to play out just yet. We're really cheating quite a lot of scalars in Rakudo.

[19:20] <JDlugosz> In general terms, to allow implementation freedom... I suppose $x.VAR.foo could be a macro that takes care of foo as well, doing a idfferent kind of dispatch.

[19:20] <jnthn> erm, *on scalars

[19:21] <JDlugosz> Or, it known to be a proxy, then $y= VAR$x;  should work.

[19:21] <jnthn> .VAR is a macro.

[19:21] <jnthn> It hands back something you can call a method on.

[19:21] <jnthn> It may just be soemthing that has a different HOw

[19:21] <jnthn> *HOW

[19:21] <jnthn> Thing is that some implementations may go down the road of really having a container and having that point to a value.

[19:22] <JDlugosz> OK.  That sounds good.  But it doesn't have to be a macro to do that... it could be a method that's not forwarded.

[19:22] <jnthn> In Rakudo we're kinda lazy about scalar containers, in an effort to have less garbage collectable objects around.

[19:22] <JDlugosz> How much of the expression does the macro suck up to rewrite?  Just the VAR as if it were a function, or the trailing dot and stuff as well?

[19:22] <jnthn> "I'll act like I've got a container when you ask me for it."

[19:23] <jnthn> Just the .VAR

[19:23] <jnthn> $foo.VAR.rw is I guess like ($foo.VAR).rw

[19:23] <JDlugosz> So if it works that way, is there any reason why it needs to be a macro, rather than just a member that's not forwarded?

[19:24] <jnthn> Because special cases in the dispatcher are a bad idea.

[19:24] *** kst joined
[19:24] <jnthn> Have you any reasons for it not to be a macro?

[19:25] <JDlugosz> I'm just thinking of more general cases, the universe of possible implementations that code might run on and expect to get the same behavior.

[19:25] <masak> JDlugosz: in case you're curious, I have no particular relation to the thing you refer to as 'method forwarding' above.

[19:25] <JDlugosz> So what is defined behavior needs to be considered carefully.

[19:25] <jnthn> Oh, also, you can use .VAR on non-scalars too and it works like the identity function, IIRS12C

[19:25] <JDlugosz> masak:  I don't understand.  relation?

[19:25] <masak> JDlugosz: I think of everything as working on the value inside the variable.

[19:26] <jnthn> And that means every single dispatcher that gets written would have to know about .VAR. So, certainly a macro. :-)

[19:26] <masak> JDlugosz: since I consider everything as being forwarded (I guess), this term isn't something I tend to use when thinking about these things.

[19:26] <masak> JDlugosz: to prevent forwarding, I'd have to use VAR($x) or some such.

[19:26] <jnthn> masak: That's probably because you're not meant to have to think about it most of the time. :-)

[19:26] <JDlugosz> Look at the call to $x.foo().  If $x is bound to something other than a scalar, it operates directly on it.

[19:27] <masak> jnthn: aye. that says something about the design of the language, that the seams aren't visible. :)

[19:27] <JDlugosz> Because $x can be bound to other containers, or anything really, such as a Dog.

[19:28] <masak> JDlugosz: I'm trying to formulate a question that makes you explain to me why I need to think in terms of forwarding. hang on. :)

[19:28] <JDlugosz> So if the compiler doesn't know to expect the item container, it sends foo to whatever is in $x, as it's "just an object".

[19:29] <masak> JDlugosz: and when isn't it "just an object"?

[19:29] <JDlugosz> The particular thing $x refers to then implements the Scalar behavior of reflecting that to the contained value instead.

[19:29] <JDlugosz> masak:  I think I just did that.

[19:29] <masak> ok. I'm not sure I follow, then.

[19:29] <masak> I always call methods on the things the variables contain.

[19:30] <JDlugosz> masak:  think about this case:  sub bar ($x) { $x.foo() }

[19:30] <JDlugosz> Now you can call it with bar(@A);

[19:31] <JDlugosz> and now in the body of bar, $x is not bound to a scalar, but directly to an Array.

[19:31] <masak> the only difference to me between @a and $a (if $a is an Array), is that @a auto-flattens in some cases.

[19:31] <masak> JDlugosz: yes, dure.

[19:31] <JDlugosz> The code inside the body can't assume the presence of a Scalar bound to $x.

[19:31] <masak> JDlugosz: what's strange about that?

[19:32] <masak> feels completely non-odd to me.

[19:32] <masak> by the way, I don't know what to think about Scalar either. :)

[19:32] <JDlugosz> The call to $x.foo can't assume the presence of a Scalar bound to $x.

[19:32] <masak> 'Scalar' is not something I use in my daily coding.

[19:32] <JDlugosz> The item container.

[19:33] <masak> um.

[19:33] <masak> I'm sorry I can't be more helpful in this instance.

[19:33] <JDlugosz> re S02:   my $spot is Scalar;  # this is the default

[19:33] <masak> yes, I recall you writing that.

[19:34] <masak> I have no idea what it means for Scalar to be the default, or for $x not being bound to a Scalar.

[19:34] <JDlugosz> And we went over the case of my $x = 1,2,3;   $x is bound to an item, which contains a list.

[19:34] <masak> in Perl 5, Scalar meant num or str, but I have the feeling it doesn't here.

[19:34] <JDlugosz> right.  Scalar is shown as the default concrete class for an item container.

[19:34] <jnthn> masak: Basically it boils down to, when you have an array you clearly have a container (the array) that holds values. In theory, for $foo, there is a container capable of holding one item.

[19:35] <jnthn> erm, one value

[19:35] <masak> JDlugosz: I see we don't share the same model of things here. I'm sure your model is closer to the spec, so I will try to absorb it as much as I can.

[19:35] <jnthn> masak: Thing is, we try and hide the existence of that container away msot of the time.

[19:35] <masak> jnthn: yes. and with me, you succeeded very well. :P

[19:35] <JDlugosz> I think I had your model -- item container always present, code knows to indirect off of it -- until last week when it was explained to me to be mistaken.

[19:35] <jnthn> masak: Down to the pointer that Rakudo is currently optimized for not really bothering with the container in a lot of cases.

[19:36] <masak> jnthn: I still haven't seen the seam where it all breaks apart.

[19:36] <jnthn> erm, the point

[19:36] <jnthn> masak: When you start applying traits to a scalar or you use .VAR.

[19:36] <masak> JDlugosz: that's good to know. I'll brace for a paradigm shift, then.

[19:36] <JDlugosz> Yes, I would expect the implementation to optimize away the item container when it can, inline the redirection elsewhere, etc.

[19:37] <jnthn> JDlugosz: We do tend to wrap parameters that are passed to a routine in a container when we need to.

[19:37] <masak> jnthn: nope, still don't see it. I know about using .VAR, and I don't find that strange. but I also don't see how that applies to $x containing an Array.

[19:37] <JDlugosz> masak:  if that's not a shift, how does racudo handle $x being bound directly to an Array?

[19:37] <masak> "rakudo".

[19:37] <JDlugosz> containing != bound to.

[19:37] <masak> JDlugosz: I don't see the problem. dollar variables can be bound to anything.

[19:38] <JDlugosz> Yes, they can.  So they are not always bound to item containers.

[19:38] <masak> no, why should they? :)

[19:38] <masak> dollar doesn't mean scalar any more. it means anything.

[19:38] <JDlugosz> So how does $x.foo work?

[19:38] <masak> only @, % and & shrink the types.

[19:38] <jnthn> .oO( $ is the interface uncontract )

[19:39] *** Chillance joined
[19:39] <masak> JDlugosz: the method foo is called on the value of $x.

[19:39] <JDlugosz> You said that in rakudo the method call assumes the existance of the item container, using the value instead.

[19:39] <JDlugosz> The "value" == the item inside the item container.

[19:39] <JDlugosz> What if it doesn't have an item container?

[19:39] <masak> 'assumes the existance of the item container'?

[19:39] <jnthn> JDlugosz: The method call just calls the method. It doesn't care what's underneath.

[19:40] <masak> JDlugosz: what's an item container?

[19:40] <masak> JDlugosz: sorry, model fail again. :/

[19:40] <jnthn> JDlugosz: If there's some kind of scalar container thing there, that'll just "forward on the dispatch".

[19:40] <JDlugosz> I thought we were on the same page re item containers.

[19:40] <jnthn> JDlugosz: If you can read C-ish code, check out src/pmc/objectref.pmc and src/pmc/perl6scalar.pmc

[19:40] <JDlugosz> or Scalar, by default.

[19:41] <masak> JDlugosz: I have no idea what an item container would be. I don't use the term Scalar. I don't need 'method forwarding' to explain things in my model.

[19:41] <masak> so far, you haven't shown why I'd need to.

[19:41] <masak> (or at least, I haven't noticed why.)

[19:42] <masak> that seam seems really well-hidden! :)

[19:42] <JDlugosz> What does the thing returned from VAR operate on?  E.g. the STORE and FETCH?

[19:42] <jnthn> JDlugosz: Maybe cleanest is to say: if there is any kind of item container, it'll forward. Method invocation is always on the thingy you current have - which you maybe just obtained from the lexpad or namespace or whatever.

[19:42] *** brunov joined
[19:42] <JDlugosz> What is the shared "lvalue" when you say my $x := $y; ?

[19:43] <masak> JDlugosz: ok, now we're getting somewhere.

[19:43] <masak> I can relate to lvalues.

[19:43] <jnthn> JDlugosz: I think that would pretty much boil down to taking whatever a lookup of $y gives and making future lookups of $x give back the same thingy.

[19:44] <jnthn> That is, from this point onwards a lookup of $x and a lookup of $y would give the same thing.

[19:44] <jnthn> Whatever that thing happens to be.

[19:45] <jnthn> Where the "what sort of thing is it" to me is very much a "we worry about it when we need to know" or maybe "if the optimizer can figure it out it can do so and maybe do something smart".

[19:45] <JDlugosz> I think I see your point about rakudo though:  the existance of the default item container is absorbed by the implementation.  It might fail on some subtle case according to the spec, but for the most part you expect them to be optimized out.

[19:46] <masak> if I do 'my ($a, $b, $c, $d) = 1, 2, 3, 4; $b := $a; $c := $b; $b := $d', will $c then be 1 or 4?

[19:46] <jnthn> JDlugosz: Oh, I know full well we'll have to patch up some of the rough edges in Rakudo on this.

[19:46] <pugs_svn> r26928 | schwarzer++ | [Perl6/Spec] typos

[19:47] <masak> JDlugosz: I've been learning Perl 6 mostly through Rakudo, so I've kinda fallen for the illusion that 'the default item container is absorbed', whatever that means. :)

[19:47] <brunov> masak++ # blogpost of that backlog

[19:48] * jnthn is reading it and wishing he'd thought more :-)

[19:49] <jnthn> Don't think I said anything too stupid though. Phew. :-)

[19:50] <jnthn> masak++ # well spotted

[19:51] <masak> :)

[19:51] <JDlugosz> Let me wrk it out in multiple lines...

[19:51] <JDlugosz>     my ($a, $b, $c, $d) = 1, 2, 3, 4; 

[19:51] <JDlugosz> For scalars holding Ints.

[19:51] <JDlugosz> $b := $a; 

[19:51] <JDlugosz>     I argue that binding ought to be single-assignment semantics... no examples of := in the synposes that aren't on the declaration.  But if allowed, $b now binds to the same item container as $a.

[19:51] <JDlugosz> $c := $b; 

[19:51] <JDlugosz>     $c bound to same container as $a and $b.  Let's call that S1, for a Scalar object with an "===" id of 1.

[19:51] <JDlugosz> $b := $d

[19:51] <JDlugosz>     $b changed again, bound to same object as $d, which is still S4.

[19:51] <JDlugosz> So $c refers to S1, which contains a value of 1.

[19:51] <masak> aye.

[19:52] <masak> that makes sense.

[19:52] <masak> JDlugosz++ # explanation

[19:52] <JDlugosz> re patch up the rough edges:  It sounds like taking on the Captures will be rough, since that will show the item containers more.  At least in the less-than-obvious uses cases that you optimize over already.

[19:53] <JDlugosz> brunov:  what blog?

[19:53] *** moritz_ joined
[19:53] <brunov> JDlugosz, http://use.perl.org/~masak/journal/39025?from=rss

[19:53] <jnthn> JDlugosz: Rakudo has generally proved itself to be pretty bendable. :-)

[19:54] <jnthn> JDlugosz: I'm only onto the third re-write of method dispatch now. ;-)

[19:54] <JDlugosz> blog or no, let me mention <http://www.nntp.perl.org/group/perl.perl6.language/2009/05/msg31635.html> for the record, for the benifit of backlogers.

[19:54] <masak> jnthn: and it just keeps getting better. :) jnthn++

[19:54] <JDlugosz> jnthn:  That is good.

[19:54] <jnthn> JDlugosz: In what you wrote above, for === I think you maybe watned =:= for container equality?

[19:55] <jnthn> Oh, wait, no.

[19:55] <jnthn> :-)

[19:55] <jnthn> oh, hang on...

[19:55] <JDlugosz> No, I was thinking of "object identity" of the containers.  

[19:55] <jnthn> :-)

[19:55] <JDlugosz> Containers thought of as objects.

[19:55] <JDlugosz> You got it. <g>

[19:55] <masak> jnthn: does 'container equality' mean 'the things have the same memory address'?

[19:56] <JDlugosz> =:= is a shortcut for VAR's and ===.

[19:56] <masak> oh, ok.

[19:56] <jnthn> Pretty much.

[19:56] <masak> both explanations make sense to me.

[19:56] <jnthn> masak: Yes and no. =:= should only be usable on container-ish things.

[19:56] <jnthn> 1 =:= 1 currently is allowed in Rakudo but shouldn't be afaik.

[19:57] <masak> jnthn: ah. well, yes.

[19:57] <JDlugosz> What happens if you try?

[19:57] <jnthn> If it is allowed the results are going to be very unpredictable anyway. :-)

[19:57] <masak> rakudo: say 1 =:= 1

[19:57] <p6eval> rakudo 23718a: OUTPUT«0␤»

[19:57] <masak> :)

[19:57] <JDlugosz> Good point re specification though.  

[19:57] <jnthn> I suspect that should be an error.

[19:58] <JDlugosz> At least use them on variables, not literals.  $x =:= $y means "bound to the same thiing?"  even if they are Dogs, not containers.

[19:58] <jnthn> Aye.

[19:58] <JDlugosz> Does VAR work on non-variables?  

[19:58] <jnthn> Just the identity function on non-scalars I think.

[19:58] <JDlugosz> While === will "fall though" to the value in an item container.

[19:59] <jnthn> *nod*

[19:59] <jnthn> Yeah, I guess that means .WHICH is container-transparent for scalars.

[19:59] <JDlugosz> So why not define $x =:= $b  as being exactly the same meaning as VAR($x)===VAR($y) .

[20:00] <JDlugosz> As far as I can tell, =all= methods fall through to the value.

[20:00] <jnthn> I highlighted it because IIRC .WHICH is meant to be a macro.

[20:00] <JDlugosz> That is why, it was mentioned a fewminutes ago, that VAR is a macro, not a special method that doesn't fall though.

[20:00] <jnthn> HOW and WHAT are anyways...

[20:01] <JDlugosz> HOW is a macro?  I thought HOW was a method on Object.

[20:01] <moritz_> no, HOW and WHAT don't participate in normal method dispatch

[20:01] <moritz_> not even in single dispatch

[20:01] <JDlugosz> S12 calls them metamethods.

[20:01] <jnthn> No

[20:01] <JDlugosz> Ah, "all actually macros"

[20:01] <jnthn> These are all actually macros, not true operators or methods.

[20:01] <jnthn> *nod*

[20:02] <JDlugosz> Just to get around any possible bootstrapping dispatch issues, I suppose.

[20:02] <jnthn> Yes.

[20:02] <JDlugosz> Not that Moose has any.

[20:02] <jnthn> Also so they're predictable

[20:02] <jnthn> And your own .WHAT method doesn't suddenly make things insane. :-)

[20:03] <JDlugosz> But that gives me another reason to appreciate why some things are defined as being macros.  Lets them be excluded when you say "all methods".  I suppose it makes it immune from changing the dispatcher logic.

[20:03] <jnthn> Aye. I see that as a good thing.

[20:03] <JDlugosz> Ah, and so $obj.$s won't call it, but will call any real method by that name.

[20:04] <jnthn> you probably mean $obj."$s"

[20:04] <JDlugosz> sayith S12:  And if you don't know the method name in advance, you'd be using the variable form anyway:

[20:04] <JDlugosz>     $obj.$somemeth

[20:05] <jnthn> Right, in that case $somemeth is meant to be a Callable.

[20:05] <jnthn> Or an array of callable in which case you've got a candidate list that you can defer over.

[20:05] <JDlugosz> Or a string.

[20:05] <jnthn> no

[20:05] <JDlugosz> $obj."foo";  $s="foo";  $obj.$s;

[20:05] <jnthn> rakudo: my $x = "abs"; say 42."$x"; say 42.$x;

[20:05] <p6eval> rakudo 23718a: OUTPUT«42␤get_pmc_keyed() not implemented in class 'Perl6Str'␤in Main (/tmp/AF0TiLIDi7:1)␤»

[20:06] <jnthn> No, you need quotes around the variable if you are using it as a name.

[20:06] <jnthn> $obj.$s expects $s to contain a method.

[20:06] <JDlugosz> Sayith S12:   $obj."$methodname"(1,2,3)   # use contents of $methodname as method name

[20:07] <jnthn> Right.

[20:07] <JDlugosz> OK, so you still put it in quotes.  It interpolates.

[20:07] <jnthn> Yes

[20:07] <jnthn> but $obj."$meth" means something very different from $obj.$meth

[20:07] <jnthn>  brb, getting zmrzlina :-)

[20:08] <JDlugosz> The quote tells it to use the string.  Different syntax to prevent errors, not because feature is unavailable.

[20:08] <JDlugosz> If the Callable stringifies to the method name, it would mean the same :)

[20:09] <JDlugosz> Save that for the "goofy tricks to mess with newbe's" column.

[20:09] <masak> we've also been promised that closures .perlify to their source code whenever possible. :)

[20:10] <JDlugosz> Hmm.  can't reload the source without the proper closure context to pick up the variables closed over.  So that is more for debugging then for marshalling.

[20:10] <JDlugosz> Great for "what is that?" when figuring out why it doesn't work.

[20:11] <jnthn> back...and mn'am! :-)

[20:11] <JDlugosz> Seeing for yourself { $field1=$_ } will help you understand why the button isn't exiting the form.

[20:11] <jnthn> .oO( great, now I'm going to blow all my earnings on travel, beer AND this ice cream... )

[20:12] <jnthn> JDlugosz: Callables won't always stringify to the method name though. :-)

[20:13] <JDlugosz> No, I expect more qualified names at the very least.  Just thinking that you could make one that did.

[20:13] <jnthn> You could.

[20:13] <jnthn> But, well, different syntax for different things. :-)

[20:13] *** kst joined
[20:13] <jnthn> And the difference is even more stark in $obj."@foo" and $obj.@foo ;-)

[20:14] <masak> jnthn: ah, zmrzlina. I get it now. :)

[20:15] <masak> it's мороженое in Russian. seems related.

[20:15] <jnthn> masak: Yes, that's one of our consonant-deprived words. Best thing is that it's written all over the place, in tourist areas, maintaining the language's terrifying image. ;-)

[20:15] <masak> jnthn: does 'zmrzlina' mean 'frozen'?

[20:16] <masak> jnthn: I'm not afraid of consonants. they tried to scare me in Slovenia, but it takes more than a čmrlj to freighten me. :)

[20:16] <jnthn> ;-)

[20:16] <JDlugosz> jnthn:  where are you located?

[20:16] <masak> s/ei/i/

[20:16] <jnthn> masak: It's very similar to the word for frozen

[20:16] <masak> jnthn: ha! :)

[20:17] <jnthn> mrazeny is IIRC the (masc nom) forzen

[20:17] <icwiener_> There is a sentence in S16 that seems to contains some error but I do not know how to fix it: "The NameServices role has a bunch of functions that between them will return the whole·Name Services database between them, as lists of objects.  The lists are specifically·intended to be lazy."

[20:17] <jnthn> (adjective)

[20:17] <jnthn> JDlugosz: I'm currently living in Bratislava, Slovakia.

[20:18] <patmat> one question, what can i use in perl 5.10 for "prompt" in perl6 :/

[20:18] <masak> jnthn: maybe there is a verb zmraz too, which only differs from mraz in aspect?

[20:18] <patmat> otherwise id ask in #perl i know there is <STDIN>

[20:18] <jnthn> masak: Well, all Slovak verbs end in soft t

[20:18] <jnthn> mrznut is to freeze

[20:18] <jnthn> I forget the aspect though :-(

[20:19] <masak> oh, ok.

[20:19] * jnthn looks it up

[20:19] <moritz_> there's IO::Prompt (but Unix only, or so I have been told)

[20:19] <patmat> moirtz_ great hanks!

[20:19] <jnthn> masak: oh, there's zmrznut too, which is almost certainly the other one

[20:19] <patmat> so there is a prompt :)

[20:19] <patmat> erm thanks hehe

[20:19] <jnthn> masak: I'd expect from instinct that zmrznut must be the "once"

[20:19] <masak> jnthn: looks that way, from what you just told me. :)

[20:20] <jnthn> Which would fit with with zmrzlina.

[20:20] <masak> uh huh.

[20:20] <masak> periodically frozen ice cream is such a drag.

[20:20] <patmat> moritz_ erm how do i use IO::Prompt correctly?

[20:20] *** LadyLunacy joined
[20:21] <moritz_> patmat: first you install it, then you follow the docs.

[20:21] <masak> patmat: './proto install io-prompt'

[20:21] <moritz_> masak: wrong major version ;-)

[20:22] <moritz_> erm, not wrong, but the other one

[20:22] <patmat> i can install it via cpan?

[20:22] <masak> no. wrong. :P

[20:22] <patmat> ahh i'm such a newbie!!

[20:22] <moritz_> patmat: yes

[20:23] <moritz_> or if you happen to run Debian, you can do 'aptitude install libio-prompt-perl'

[20:23] <icwiener_> patmat: If you use Linux, then your distro might have packages.

[20:23] <patmat> Ubuntu here :)

[20:24] <icwiener_> Likely the same an Debian then. :)

[20:24] <patmat> hehe ye

[20:24] <moritz_> well, the ubuntu packages might have a brown colour instead ;-)

[20:24] <icwiener_> hehe

[20:25] *** lambdabot joined
[20:25] <masak> rakudo: say Nil ~~ List

[20:26] <p6eval> rakudo 23718a: OUTPUT«0␤»

[20:26] <masak> rakudo: say Nil ~~ Positional

[20:26] <p6eval> rakudo 23718a: OUTPUT«1␤»

[20:30] *** tulcod joined
[20:31] *** lucs joined
[20:33] *** jferrero joined
[20:34] * jnthn afk for a bit

[20:35] <patmat> hrmm how do i use the IO::Prompt ?

[20:35] <patmat> module

[20:35] <masak> as described on its CPAN page?

[20:36] <patmat> ahh sorry here it is

[20:36] <masak> there's usually a SYNOPSIS part that gives a useage example.

[20:37] <masak> followed by more exact descriptions about different subs and methods.

[20:37] <masak> patmat: is there something Perl6-related I can help you with today? :)

[20:38] <patmat> masak hehe no thanks didnt have much time to do someething :((

[20:39] <masak> no wonder, if you keep getting distracted by Perl 5... :P

[20:39] <patmat> hehe

[20:40] <patmat> Cannot write to terminal: No such device or address at /home/patmat/code/mauslaus002.pl line 9

[20:41] <patmat> hrm no

[20:43] *** ZuLuuuuuu joined
[20:46] *** icwiener joined
[20:50] <masak> rakudo: sub infix:<.>($a, $b) { say "OH HAI" }; say "OH" . "NOES"

[20:50] <p6eval> rakudo 23718a: OUTPUT«OH HAI␤1␤»

[20:51] <masak> rakudo: sub infix:<.>($a, $b) { "OH HAI" }; say "OH"."NOES"

[20:51] <p6eval> rakudo 23718a: OUTPUT«Method 'NOES' not found for invocant of class 'Str'␤»

[20:52] <masak> how magical is the method-call dot? does it count as an ordinary infix op? I know it has some unspace requirements going on, so it would seem it isn't...

[20:53] <jnthn> (away really, drive by comment) I really don't see it as being an ordinary infix op.

[20:54] <masak> no, you're probably right.

[20:54] <masak> that means that the above is in order.

[20:54] <JDlugosz> Anybody know about enum types?

[20:54] <jnthn> We don't parse it like any old infix, it's got a syntactic category of its own (dotty)

[20:54] *** payload joined
[20:55] <masak> JDlugosz: don't ask to ask. :)

[20:55] <jnthn> JDlugosz: I did Rakudo's implemention, but I forgot about it as quickly as possible again afterwards... ;-)

[20:56] <masak> JDlugosz: also known as "I might not know, but I'm curious enough to listen to your question" :)

[20:56] <jnthn> I find that bit of S12 pretty hazy and found it hard to hold together all the demands. But at least the current implemention checks more boxes than the first one.

[20:56] <masak> (checking boxes)++

[20:56] <JDlugosz> S09 shows lower-case enum to define them, but S03 uses Enum as a type name.

[20:57] *** kate21de joined
[20:57] <jnthn> I'd mostly just gone on S12.

[20:57] <masak> rakudo: enum A <a b c>; say A.WHAT

[20:57] <p6eval> rakudo 23718a: OUTPUT«A()␤»

[20:57] <masak> rakudo: enum A <a b c>; say A ~~ Enum

[20:57] <jnthn> std: my Enum $x;

[20:57] <p6eval> rakudo 23718a: OUTPUT«Could not find non-existent sub Enum␤»

[20:57] <p6eval> std 26928: OUTPUT«##### PARSE FAILED #####␤Malformed my at /tmp/RfXn15xCyM line 1:␤------> my Enum $x;␤FAILED 00:02 35m␤»

[20:57] <jnthn> JDlugosz: Think S03's Enum type name is legacy.

[20:58] <masak> nod.

[20:58] <jnthn> (It doesn't fit with my model of enums from S12.)

[20:58] <JDlugosz> I think S03, on smart match, is referring to "some type name that is the name of an enumeration", just like matching class and role.

[20:58] <jnthn> Ah, OK.

[20:58] <jnthn> In that case it may be OK.

[20:59] <masak> JDlugosz: but it's listed in the column "Actual type"...

[20:59] <masak> JDlugosz: and all the others are actual types.

[20:59] <JDlugosz> Yes.

[20:59] <masak> which seems strange.

[20:59] <JDlugosz> That whole line is strange.  Class Enum Role are not the actual types, but categories of actual types.

[21:00] <masak> at the very least, it should be clearly marked that the name is metasyntactic.

[21:00] <JDlugosz> Just a meta-thing in the text.

[21:00] <masak> JDlugosz: aye, you're right.

[21:00] <jnthn> std: my Role $x;

[21:00] <p6eval> std 26928: OUTPUT«ok 00:02 36m␤»

[21:00] <jnthn> Role is a real type name.

[21:01] <jnthn> Class is maybe not but maybe is and if it is it probably means "something that is a meta-class" but we may end up s/Class/MetaClass/ or something.

[21:01] <jnthn> I'm not sure exactly where that'll end up

[21:01] <jnthn> We just need SomeLabel that we can multi-dispatch on with a metaclass for setting class traits.

[21:01] <masak> JDlugosz: S02 also mentions the 'Class' class, but makes it clear that it refers to an Abstraction-like thing, i.e. part of the namespace class hierarchy.

[21:02] * jnthn afk again

[21:02] <masak> hm, that wasn't a very clear explanation on my part.

[21:02] <masak> I interpret 'Class' as per S02 as something akin to 'Module' and 'Package'.

[21:02] <JDlugosz> "any type declared using class, enum, or role"

[21:03] <masak> rakudo: role A {}; say A ~~ Role

[21:03] <p6eval> rakudo 23718a: OUTPUT«0␤»

[21:03] <JDlugosz> Or perhaps it should now refer to "type objects".

[21:03] * masak submits rakudobug

[21:03] <JDlugosz> But a type object has the type of that type, not any kind of metaclass type.

[21:05] <JDlugosz> Since that is only used in the table for the "type membership" .does(X) test, it's clear that it is meant to be any prototype object, or a named value that is a type.

[21:06] <JDlugosz> The Class Enum Role probably means "named values declared as classes, etc."

[21:06] <masak> it might, but it shouldn't say it like that.

[21:07] <JDlugosz> I plan on editing S03 soon anyway.

[21:08] <JDlugosz> Since it's already in $_, it can't be a literal named value.  So any prototype object, now called "type object", is what it should say.

[21:08] <JDlugosz> Sorry, that's the X column.  It is a literal, not in $_.

[21:08] <JDlugosz> So any named value that is a type.

[21:09] *** rewt joined
[21:09] <masak> aye.

[21:10] <JDlugosz> A voice crys from the other room, "John.... are we going out?"

[21:10] <masak> of course we are. :)

[21:11] <masak> it's Sunday evening. we always go out on Sundays.

[21:11] <JDlugosz> She means to fix the fence, not to have fun.

[21:11] <masak> oh.

[21:11] <masak> um, you go right ahead. I'll... come out a bit later.

[21:13] *** kst joined
[21:18] <Matt-W> hey

[21:18] <Matt-W> masak: great blog entry

[21:18] *** SamuraiJack joined
[21:19] <Matt-W> I managed to come stay at my parents' house and not bring my laptop charger, so I've been on no rakudo time whereas I would have done some stuff :(

[21:29] <TimToady> rakudo: sub foo ($x) { say [1,2,$x].elems }; foo(<a b c d>)

[21:29] <p6eval> rakudo 23718a: OUTPUT«3␤»

[21:29] <TimToady> that is correct

[21:29] <TimToady> rakudo: my @a = <a b c d>; my $a := @a; say [1,2,$a].elems

[21:29] <p6eval> rakudo 23718a: OUTPUT«6␤»

[21:30] <TimToady> that is incorrect

[21:30] <TimToady> it is an invariant that $x never interpolates in list context

[21:30] <Matt-W> rakudo seems to be paying more attention to that @a it's bound to

[21:31] <TimToady> yes, but inconsistently with the sig binding earlier

[21:31] <Matt-W> indeed

[21:31] <Matt-W> not good

[21:31] <Matt-W> no wonder I get confused about list interpolation

[21:32] <masak> Matt-W: thank you. :)

[21:35] <TimToady> incidentally, people keep writing "my $x = 1,2,3;"

[21:35] <TimToady> this is also incorrect

[21:35] <Matt-W> should be [1, 2, 3]?

[21:35] <TimToady> (1,2,3) at least

[21:36] <TimToady> assignment to a scalar limits RHS to tighter than ,

[21:36] *** wknight8111 joined
[21:36] <masak> oh!

[21:36] <Matt-W> what should my $x = 1, 2, 3 do?

[21:36] <Matt-W> error or $x == 3 or?

[21:36] <TimToady> rakudo: loop (my $a = 1, my $b = 2; $a < 5; $a++, $b++) { say "$a $b" }

[21:36] <masak> I actually half-thought that thought earlier on today.

[21:36] <p6eval> rakudo 23718a: OUTPUT«Unable to set lvalue on PAST::Val node␤in Main (src/gen_setting.pm:3166)␤»

[21:36] <TimToady> that oughta work

[21:37] * masak reports rakudobug

[21:37] <Matt-W> masak: are you taking down bug reports?

[21:37] <TimToady> it's not because rakudo is parsing it as a list assignment

[21:37] <masak> Matt-W: so it seems. :)

[21:37] <TimToady> (a known bug, iirc)

[21:37] * masak searches

[21:38] <masak> we have too many known bugs! :P

[21:38] <Matt-W> perhaps I should take some time to learn how to fix some of them

[21:38] <TimToady> that's partly your fault

[21:38] <Matt-W> hah

[21:38] <masak> :)

[21:38] <Matt-W> TimToady: But if he didn't report them, they'd still be there, and known bugs are better than unknown bugs

[21:39] * masak has a tendency to produce lots of known bugs

[21:39] <Matt-W> In a similar way to how a known missing manhole cover on a dark road is better than falling down it

[21:39] <TimToady> we'd really like to accumulate a few more known unbugs

[21:40] <masak> nope, a cursort glance at a search for 'loop' & queue=perl6 does not yield anything substantial. reporting just in case.

[21:42] <masak> rakudo: loop (my $a = 1, my $b = 2;0;) { say "$a $b" }

[21:42] <p6eval> rakudo 23718a: OUTPUT«Unable to set lvalue on PAST::Val node␤in Main (src/gen_setting.pm:3166)␤»

[21:49] <masak> 'night, all.

[22:04] *** justatheory joined
[22:06] *** kst joined
[22:13] *** pmurias joined
[22:13] <pmurias> hi

[22:14] *** SamuraiJack joined
[22:26] <sjohnson> hi

[22:33] <ruoso> hi pmurias 

[22:46] <pmurias> ruoso: hi

[22:48] <pmurias> ruoso: i'm thinking about writing a trace gc we could use once in a while to free cycles

[22:49] <pmurias> ruoso: as i don't know how to solve some cycles with weakrefs (like $?BLOCK)

[23:07] <wayland76> ruoso / pmurias: Someone was asking me whether SMOP is ready to install

[23:07] *** nsh joined
[23:15] *** Chillance joined
[23:17] *** kst joined
[23:19] <pmurias> wayland76: installing smop isn't supported yet

[23:25] <wayland76> pmurias: Ok, thanks

[23:32] *** kate21de1 joined
[23:43] <sjohnson> rakudo:  my $x = 1,2,3;  print $x

[23:43] <p6eval> rakudo 23718a: OUTPUT«1 2 3»

[23:43] <sjohnson> rakudo:  my $x = 1,2,3;  print $x.WHAT

[23:43] <p6eval> rakudo 23718a: OUTPUT«Array()»

