[00:01] *** hercynium joined
[00:05] *** justatheory left
[00:16] *** netfish joined
[00:32] *** avar left
[00:32] *** avar joined
[00:35] <dalek> rakudo: ee1fd13 | pmichaud++ | src/classes/Multi.pir:

[00:35] <dalek> rakudo: Allow .WHAT and other p6object methods on Parrot MultiSub objects (RT #66928).

[00:35] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ee1fd13321ed5bbe1cc51fde5efce2d7c26049d5

[00:38] *** mizioumt1 left
[00:41] <dalek> rakudo: 7fdd7c8 | pmichaud++ | build/PARROT_REVISION:

[00:41] <dalek> rakudo: Bump PARROT_REVISION so we get some Parrot fixes (RT #66060).

[00:41] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7fdd7c8b8dd2bc374e14c19362369c333829431a

[00:42] *** frew_ left
[00:42] *** frew_ joined
[00:43] *** lambdabot left
[00:46] *** lambdabot joined
[00:50] *** Whiteknight left
[00:54] *** cdarroch left
[00:55] *** cls_bsd left
[00:55] *** cls_bsd joined
[00:56] *** orafu joined
[01:17] *** nihiliad joined
[01:17] *** orafu left
[01:18] *** orafu joined
[01:28] *** molaf_x left
[01:38] *** orafu left
[01:42] *** KyleHa joined
[01:44] *** orafu joined
[01:45] *** molaf_x joined
[01:45] <pugs_svn> r27345 | kyle++ | [t/spec] Test for RT #66928

[01:59] *** orafu left
[02:00] *** japhb left
[02:01] *** charsbar_ left
[02:01] *** charsbar joined
[02:05] *** orafu joined
[02:10] *** snarkyboojum left
[02:14] *** jhorwitz left
[02:16] *** dukeleto joined
[02:19] *** alester joined
[02:21] *** orafu left
[02:21] *** orafu joined
[02:22] *** szabgab left
[02:32] *** japhb joined
[02:33] *** amoc joined
[02:36] *** last left
[02:37] *** szabgab joined
[02:40] *** athomason left
[02:42] *** orafu left
[02:44] *** szabgab left
[02:45] *** szabgab joined
[02:45] <dalek> rakudo: 6c6299f | pmichaud++ | src/builtins/globals.pir:

[02:45] <dalek> rakudo: Fix %*VM<config> (RT #66818).

[02:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6c6299fccddffc1b2905ff6a4598559d006c5cd8

[02:45] <dalek> rakudo: 5351a33 | pmichaud++ | build/PARROT_REVISION:

[02:45] <dalek> rakudo: Bump PARROT_REVISION to get fix for RT #66840 (ternary error shouldn't exit)

[02:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5351a33da8a4d98a0610abea466e51cdfb7901aa

[02:46] *** Limbic_Region left
[02:48] *** orafu joined
[02:55] <pugs_svn> r27346 | kyle++ | [t/spec] unfudge the RT #66840 test since it passes in Rakudo 5351a33

[02:56] *** KyleHa left
[02:56] *** leon joined
[03:01] *** skids left
[03:01] *** leon left
[03:02] *** dukeleto_ joined
[03:02] <pugs_svn> r27347 | pmichaud++ | [t/spec]:  Unfudge test for unicode method names (now fixed in Parrot).

[03:03] *** leon_mu joined
[03:03] *** orafu left
[03:04] *** orafu joined
[03:04] *** orafu left
[03:09] *** orafu joined
[03:09] *** synth left
[03:23] *** orafu left
[03:23] *** orafu joined
[03:24] *** dukeleto left
[03:25] *** orafu left
[03:28] *** orafu joined
[03:32] *** orafu left
[03:32] *** molaf_x left
[03:37] *** dukeleto_ left
[03:37] *** orafu joined
[03:46] *** orafu left
[03:52] *** orafu joined
[04:07] *** orafu left
[04:08] *** orafu joined
[04:23] *** FurnaceBoy left
[04:28] *** orafu left
[04:29] *** orafu joined
[04:32] *** justatheory joined
[04:50] *** orafu left
[04:55] *** orafu joined
[05:01] *** japhb left
[05:11] *** orafu left
[05:11] *** orafu joined
[05:13] *** ihrd joined
[05:17] *** frew_ left
[05:18] *** agentzh left
[05:22] *** finanalyst joined
[05:23] *** dukeleto joined
[05:32] *** orafu left
[05:33] *** orafu joined
[05:36] *** agentzh joined
[05:37] *** netfish left
[05:45] *** alester left
[05:49] *** nihiliad left
[05:53] *** orafu left
[05:54] *** orafu joined
[06:05] *** zamolxes left
[06:06] *** azawawi joined
[06:06] <azawawi> good morning

[06:06] *** M_o_C joined
[06:08] <pugs_svn> r27348 | kyle++ | [t/spec] fix the plan I broke in what.t

[06:08] <Matt-W> morning azawawi

[06:09] <eternaleye> Hi azawawi, Matt-W

[06:09] <moritz_> good morning

[06:09] * Matt-W wants to know how to move an operator into the setting

[06:09] <eternaleye> oh hai, moritz_

[06:10] <eternaleye> Matt-W: Just define it in the setting, remove it from the PIR, and spectest!

[06:10] <Matt-W> eternaleye: it causes a null pmc access :(

[06:10] <moritz_> ... in find_method?

[06:10] <eternaleye> Well, that's _never_ right

[06:10] <moritz_> which operator?

[06:10] <Matt-W> moritz_: yes. I was trying to do infix:<leg>

[06:11] <eternaleye> I was just thinking, we're going to need to be careful defining operators in terms of other operators, because we might get an infinite recursion going.

[06:11] <moritz_> Matt-W: you also have to remove it from build/gen_junction_pir.pl

[06:11] <Matt-W> ah

[06:14] * Matt-W tries that

[06:14] *** synth joined
[06:14] <Matt-W> ah that's better :)

[06:15] *** mvuets joined
[06:15] *** orafu left
[06:15] <Matt-W> just have to wait for spectest now

[06:15] <eternaleye> rakudo: my @seed = 2, 3; .say for @seed ... -> *@prev { state $c = 0; return () if $c > 100; my $cur = @prev[*-1]; while ++$cur { return $cur unless $cur % any( @prev ) == 0 }; };

[06:15] <p6eval> rakudo 5351a3: OUTPUT«5␤»

[06:16] <eternaleye> rakudo: my @seed = 2, 3; .say for @seed ... -> *@prev { state $c = 0; return () if $c > 100; my $cur = @prev[*-1]; while ++$cur { last unless $cur % any( @prev ) == 0 }; $cur };

[06:16] <p6eval> rakudo 5351a3:  ( no output )

[06:16] <eternaleye> rakudo: my @seed = 2, 3; .say for @seed ... -> *@prev { state $c = 0; return () if $c > 100; my $cur = @prev[*-1]; while ++$cur { take $cur unless $cur % any( @prev ) == 0 }; };

[06:16] <p6eval> rakudo 5351a3: OUTPUT«Died␤in sub infix:... (/tmp/mAFnftJ9B8:2)␤called from Main (/tmp/mAFnftJ9B8:2)␤»

[06:17] <eternaleye> In any case, the first one appears wrong - it looks like it's returning from infix:<...>

[06:17] <eternaleye> Do we need to do a wrapping sub around $generator, so that it DWIMs

[06:17] <eternaleye> ?

[06:18] <eternaleye> When I define the generator as a sub, and then use &nextprime in infix:<...>, it works

[06:19] <eternaleye> rakudo: sub nextprime( *@prev ) { state $c = 0; return () if $c > 100; my $cur = @prev[*-1]; while ++$cur { return $cur unless $cur % any( @prev ) == 0 }; }; my @seed = 2, 3; .say for @seed ... &nexprime;

[06:19] *** leon_mu left
[06:19] <moritz_> return() is specced to exit a routine, not a block

[06:19] <p6eval> rakudo 5351a3: OUTPUT«No applicable candidates found to dispatch to for 'infix:...'␤in Main (/tmp/lsLy8NUC4i:2)␤»

[06:19] <eternaleye> Hmm

[06:19] <moritz_> you'd need leave() to leave the block, but I don't think it's implemented yet

[06:20] <moritz_> rakudo: say { leave 3 }

[06:20] <p6eval> rakudo 5351a3: OUTPUT«_block49␤»

[06:20] <moritz_> rakudo: say { leave 3 }.()

[06:20] <p6eval> rakudo 5351a3: OUTPUT«Could not find non-existent sub leave␤»

[06:20] <eternaleye> Ah

[06:20] *** rfordinal left
[06:20] *** orafu joined
[06:21] *** rfordinal joined
[06:21] <eternaleye> rakudo: my @seed = 2, 3; .say for @seed ... -> *@prev { state $c = 0; my $cur = @prev[*-1]; while ++$cur { break unless $cur % any( @prev ) == 0 }; $c > 100 ?? () !! $cur };

[06:21] <p6eval> rakudo 5351a3: OUTPUT«Died␤in sub infix:... (/tmp/LEbFssDoqU:2)␤called from Main (/tmp/LEbFssDoqU:2)␤»

[06:21] <eternaleye> rakudo: my @seed = 2, 3; .say for @seed ... -> *@prev { state $c = 0; my $cur = @prev[*-1]; while ++$cur { last unless $cur % any( @prev ) == 0 }; $c > 100 ?? () !! $cur };

[06:22] <p6eval> rakudo 5351a3:  ( no output )

[06:22] <eternaleye> Hm

[06:22] <eternaleye> Loop control is apparently NYI

[06:23] <moritz_> what do you mean by loop control?

[06:24] <moritz_> last should work

[06:24] <eternaleye> rakudo: sub nextprime( *@prev ) {{ state $c = 0; return () if $c > 100; my $cur = @prev[*-1]; while ++$cur { return $cur unless $cur % any( @prev ) == 0 }; }; my @seed = 2, 3; .say for @seed ... &nextprime;

[06:24] <p6eval> rakudo 5351a3: OUTPUT«Unable to parse block; couldn't find final '}' at line 2, near ""␤in Main (src/gen_setting.pm:3279)␤»

[06:24] <eternaleye> rakudo: sub nextprime( *@prev ) { state $c = 0; return () if $c > 100; my $cur = @prev[*-1]; while ++$cur { return $cur unless $cur % any( @prev ) == 0 }; }; my @seed = 2, 3; .say for @seed ... &nextprime;

[06:24] <p6eval> rakudo 5351a3:  ( no output )

[06:24] <eternaleye> moritz_: last doesn't seem to work, since it loops forever on that one. If I put a say in there, it just repeats

[06:24] <eternaleye> It should give a 5, a 7, etc

[06:25] <eternaleye> rakudo: my @seed = 2, 3; .say for @seed ... -> *@prev { state $c = 0; my $cur = @prev[*-1]; while ++$cur { last unless $cur % any( @prev ) == 0; say "hi" }; $c > 100 ?? () !! $cur };

[06:25] <p6eval> rakudo 5351a3:

[06:25] <p6eval> ..OUTPUT«hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi􏿽xE2

[06:25] * moritz_ still too tired to actually *look* at the code

[06:25] <eternaleye> or maybe...

[06:25] <eternaleye> rakudo: my @seed = 2, 3; .say for @seed ... -> *@prev { state $c = 0; my $cur = @prev[*-1]; while ++$cur { last unless $cur % any( @prev ) == 0; say "hi" }; $c > 5 ?? () !! $cur };

[06:25] <p6eval> rakudo 5351a3:

[06:25] <p6eval> ..OUTPUT«hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi􏿽xE2

[06:26] <eternaleye> Nope, that is what's happening

[06:26] <eternaleye> Also, does that look like a NL symbol to everyone else? Since it looks like lower-a, circumflex acce,t, space, Euro sign here

[06:27] <moritz_> it looks broken here too

[06:27] <moritz_> rakudo: say 'ö'

[06:27] <p6eval> rakudo 5351a3: OUTPUT«ö␤»

[06:27] <eternaleye> _weird_

[06:27] <moritz_> hm, that looks fine

[06:28] <eternaleye> Bug?

[06:28] <eternaleye> Running in local rakudo

[06:28] <moritz_> it loooks OK on the IRC logs, though

[06:28] <Matt-W> woohoo

[06:28] <Matt-W> my operator passed its part of the spectest

[06:28] <Matt-W> what's the preferred way to submit a patch?

[06:29] <moritz_> eternaleye: ah, I know why... the last NL character got trunkated, so our IRC client's autodetection thought "that's not valid UTF-8" and went beserk.

[06:29] <moritz_> Matt-W: [email@hidden.address]
[06:29] <Matt-W> moritz_: yes but how to make the patch

[06:29] <eternaleye> Ah

[06:29] <Matt-W> moritz_: unfamiliar with git for this

[06:30] <eternaleye> Matt-W: git format-patch --stdout 'HEAD^'

[06:30] <eternaleye> and nopaste/rakudobug/email/etc it

[06:30] <eternaleye> Or remove the --stdout and it'll make a file

[06:31] <eternaleye> I like the --stdout, so I can pipe it to wgetpaste

[06:31] <moritz_> Matt-W: first commit it (git commit -a)

[06:31] <moritz_> Matt-W: then git-format-patch HEAD^

[06:31] <moritz_> Matt-W: and attach the generated file

[06:34] * Matt-W sends

[06:34] <Matt-W> and just in time to go to work too

[06:34] <Matt-W> I'll be back later

[06:34] * Matt-W -> commuting &

[06:36] *** orafu left
[06:37] *** orafu joined
[06:37] *** orafu left
[06:39] *** rfordinal left
[06:42] *** orafu joined
[06:44] *** DemoFreak joined
[06:54] *** azawawi left
[06:57] *** orafu left
[06:57] *** orafu joined
[06:59] *** rfordinal joined
[07:02] *** spinclad joined
[07:05] *** japhb joined
[07:18] *** orafu left
[07:19] *** meppl joined
[07:20] *** orafu joined
[07:23] *** ejs joined
[07:26] *** mkindahl joined
[07:27] <moritz_> rakudo: say 'a' cmp 'b'

[07:28] <p6eval> rakudo 5351a3: OUTPUT«-1␤»

[07:28] <moritz_> rakudo: say 'b' cmp 'b'

[07:28] <p6eval> rakudo 5351a3: OUTPUT«0␤»

[07:28] <moritz_> rakudo: say 'c' cmp 'b'

[07:28] <p6eval> rakudo 5351a3: OUTPUT«1␤»

[07:33] *** ejs1 joined
[07:35] *** iblechbot joined
[07:40] *** orafu left
[07:40] *** ejs left
[07:41] *** orafu joined
[07:42] <moritz_> I just found out that mathematica has something similar to our [\...] meta operatr (called FoldList)

[07:44] * Matt-W back

[07:46] <Matt-W> moritz_: o rly?

[07:46] <Matt-W> list folds are generally very useful things

[07:48] *** mepplock joined
[08:01] *** eMaX joined
[08:01] *** orafu left
[08:02] *** orafu joined
[08:02] *** meppl left
[08:19] *** rfordinal left
[08:20] *** rfordinal joined
[08:22] *** orafu left
[08:23] *** orafu joined
[08:24] *** last joined
[08:25] *** sri_kraih joined
[08:27] <moritz_> I first searched for reduce in the mathematica docs, but that does something entirely different :-)

[08:37] *** PacoLinux left
[08:39] *** rfordinal left
[08:41] <jnthn> morning

[08:43] <jnthn> pmichaud++ # blogging

[08:43] <moritz_> indeed.

[08:43] *** orafu left
[08:44] *** orafu joined
[08:44] *** orafu left
[08:45] *** solarion left
[08:45] *** Chillance joined
[08:45] *** solarion joined
[08:45] <Matt-W> moritz_: what we call reduce feels a lot like what they call a fold in Haskell

[08:47] *** last left
[08:49] *** rfordinal joined
[08:50] *** pmurias joined
[08:57] *** m-i-l-a-n left
[08:59] *** m-i-l-a-n joined
[09:00] *** orafu joined
[09:04] *** m-i-l-a-n left
[09:05] *** orafu left
[09:06] *** orafu joined
[09:07] <moritz_> I know

[09:08] *** m-i-l-a-n joined
[09:09] *** Chillance left
[09:12] *** ihrd left
[09:13] <moritz_> Matt-W: I just replied to your patch. There's nothing wrong with this particular move, I'm just wandering of the overall design of that operator is sound

[09:14] *** m-i-l-a-n left
[09:14] *** mikehh joined
[09:15] *** m-i-l-a-n joined
[09:21] *** m-i-l-a-n left
[09:22] *** m-i-l-a-n joined
[09:26] *** orafu left
[09:28] *** m-i-l-a-n left
[09:29] *** m-i-l-a-n joined
[09:35] *** m-i-l-a-n left
[09:35] *** orafu joined
[09:36] *** m-i-l-a-n joined
[09:40] *** orafu left
[09:42] *** rfordinal left
[09:50] *** synth left
[10:15] *** cognominal left
[10:18] *** payload joined
[10:27] *** Muixirt joined
[10:35] *** cognominal joined
[10:44] *** masak joined
[10:53] <masak> IO.eof is gone?

[10:54] <masak> I do wish people would discuss these things a bit before attacking the spec... :/

[10:54] <jnthn> masak: I'm not sure it's gone as such, perhaps just gone missing. ;-)

[10:54] <masak> to me, IO::Endable is perilously close to abstraction astronautism.

[10:55] <masak> just give me the IO.end and be done with it.

[10:55] <masak> no need for a whole interface for it.

[10:55] <jnthn> (e.g. it was meant to be defined in IO::Endable, but somehow forgot)

[10:55] * masak mutters into his beard

[10:55] <jnthn> Yeah, it feels a bit...overkill.

[10:56] *** payload left
[10:56] <masak> also, I think ruoso++ had an argument about why that kind of role (including IO::Readable) doesn't work in practice.

[10:58] *** mjk joined
[11:00] *** jlaire joined
[11:03] <pugs_svn> r27349 | kyle++ | [t/spec] Fix a .WHAT test after review from jnthn++

[11:05] *** mjk left
[11:05] *** tarball joined
[11:06] *** mikehh left
[11:12] *** tarball left
[11:14] <masak> rakudo: my @a := (1,2,3,4); say @a.WHAT

[11:14] <p6eval> rakudo 5351a3: OUTPUT«List()␤»

[11:14] <masak> so far, so good. @a is bound to a List. I agree.

[11:14] <masak> rakudo: my @a := (1,2,3,4); @a.push(4); say @a.perl; say @a.WHAT

[11:14] <p6eval> rakudo 5351a3: OUTPUT«[1, 2, 3, 4, 4]␤List()␤»

[11:14] <masak> but this puzzles me.

[11:14] <masak> aren't Lists immutable?

[11:15] <moritz_> that's a rakudobug (known)

[11:15] <masak> oh.

[11:15] <jnthn> I think that's one of the things pm's rw work is meant to solve.

[11:15] <masak> ah.

[11:23] *** mikehh joined
[11:25] *** pmurias left
[11:27] *** last joined
[11:28] *** stepnem left
[11:32] *** rfordinal joined
[11:37] *** stepnem joined
[11:37] *** stepnem left
[11:38] *** eMaX left
[11:45] *** stepnem joined
[12:10] <dalek> grok: b1e7f47 | (Hinrik Örn Sigurðsson)++ |  (6 files):

[12:10] <dalek> grok: Support xhtml output

[12:10] <dalek> grok: Depend on latest Perl6::Perldoc::To::Ansi and Pod::Xhtml as well.

[12:10] <dalek> grok: review: http://github.com/hinrik/grok/commit/b1e7f478391d67d44cd46c1c961408b5a6a928f9

[12:10] <dalek> grok: 86f0183 | (Hinrik Örn Sigurðsson)++ | lib/App/Grok/Pod (2 files):

[12:10] <dalek> grok: Forgot to bump these version numbers earlier

[12:10] <dalek> grok: review: http://github.com/hinrik/grok/commit/86f0183ba87cbcb4bf97030b0029d35d54a884ca

[12:10] <literal> @tell azawawi preliminary support for xhtml output: http://nix.is/grok-0.07_01.tar.gz

[12:10] <lambdabot> Consider it noted.

[12:11] <masak> nice! literal++

[12:12] <literal> rakudo: say $?GRAMMAR

[12:12] <lambdabot> literal: You have 1 new message. '/msg lambdabot @messages' to read it.

[12:12] <p6eval> rakudo 5351a3: OUTPUT«Symbol '$?GRAMMAR' not predeclared in <anonymous> (/tmp/f6Iuf7KPUx:2)␤in Main (src/gen_setting.pm:3279)␤»

[12:12] *** MrKrueger joined
[12:27] *** mepplock left
[12:29] <masak> rakudo: say '_' ~~ <alpha>

[12:29] <p6eval> rakudo 5351a3: OUTPUT«0␤»

[12:40] *** ruoso joined
[12:41] <Matt-W> moritz_: Well argue that with the spec - I checked, and it just says it's defined in terms of ~$a cmp ~$b

[12:42] <Matt-W> moritz_: You may in fact be right about which way round things should be.

[12:43] <ruoso> Bom dia, #perl6

[12:43] <Matt-W> (trust me to pick an operator that causes a debate...)

[12:43] <pmichaud> good morning, #perl6

[12:43] <Matt-W> hi ruoso, pmichaud

[12:44] <jnthn> hi, pmichaud 

[12:44] <jnthn> pmichaud: Nice fixing and blogging!

[12:45] <pmichaud> jnthn: thanks, you too :-)

[12:45] *** pmurias joined
[12:45] <pmurias> hi

[12:45] <Matt-W> between the two of you things are looking a mite shinier today :)

[12:47] *** stepnem left
[12:47] *** mizioumt joined
[12:50] <literal> rakudo: say '_' ~~ /<alpha>/

[12:50] <p6eval> rakudo 5351a3: OUTPUT«_␤»

[12:50] <masak> oh, right.

[12:50] <masak> silly me.

[12:50] *** skids joined
[12:51] *** synth joined
[12:52] <pmurias> ruoso: do we have a long term smop plan/ROADMAP?

[12:53] <jnthn> Implement Perl 6. :-)

[12:53] <ruoso> heh... jnthn++

[12:53] <ruoso> but seriously... that's the plan... I mean

[12:53] <ruoso> once we have multi and module loading working

[12:53] <pugs_svn> r27350 | pmurias++ | [re-smop] correct indentation

[12:53] <pugs_svn> r27351 | pmurias++ | [re-mildew] fix if bug

[12:53] <ruoso> we can start working on Perl 6 features 

[12:54] <pmurias> and when's the bootstrap point?

[12:54] <ruoso> well, there's the type system bootstrap

[12:54] <ruoso> that should happen soon after we have module loading

[12:54] <ruoso> but then there's a long way before we implement a grammar engine in SMOP

[12:55] *** Chillance joined
[12:55] <ruoso> and then this grammar engine will have to be able to run STD

[12:55] *** Molaf left
[12:56] <ruoso> and we must be able to parse STD using that grammar engine

[12:56] <ruoso> and, finally, have this grammar engine being used to compile STD to SMOP

[12:56] <ruoso> and that's the real bootstrap

[12:57] <pmurias> a partial bootstrap would be to have mildew in Perl 6 and using the STD compiled down to perl5

[12:57] <masak> rakudo: / <[\x10000..\xEFFFF]> /; say "alive"

[12:57] <p6eval> rakudo 5351a3:  ( no output )

[12:57] <masak> pmichaud: is this a known issue?

[12:57] <pmurias> perl6: say [].true

[12:57] <masak> pmurias: locally, I had a bus error.

[12:57] <p6eval> elf 27351, rakudo 5351a3: OUTPUT«1␤»

[12:57] <p6eval> ..pugs: OUTPUT«␤»

[12:58] <masak> pmurias: oops, mistab.

[12:58] <pmichaud> masak: not known issue

[12:58] * masak submits rakudobug

[12:58] <pmichaud> I'm guessing parrotbug :-)

[12:58] <masak> PGE-bug, possibly.

[12:58] <ruoso> pmurias, even before that, just having all the Perl 6 type system written in Perl 6 is a very important milestone

[12:58] *** cls_bsd left
[12:58] <masak> pmichaud: note that it hangs during execution, not during compilation.

[12:59] <pmichaud> rakudo: / <[\x100..\xEFF]> /;  say "alive"

[12:59] <p6eval> rakudo 5351a3: OUTPUT«alive␤»

[12:59] <pmichaud> PGE gets that one right.

[12:59] <masak> and the hex numbers have to be high enough for it to trigger.

[12:59] <pmichaud> right

[12:59] <pmichaud> I suspect that Parrot strings are having difficulty with it.

[12:59] <pmurias> ruoso: type system meaning ClassHOW,RoleHOW etc?

[13:00] <ruoso> pmurias, and all the built-in types

[13:00] <pmichaud> rakudo:  say 0xeffff;

[13:00] <p6eval> rakudo 5351a3: OUTPUT«983039␤»

[13:01] <pmichaud> oh, the problem could also be that Parrot doesn't like creating a 920+K string.

[13:01] <pmichaud> rakudo:  say 0xeffff-0x10000;

[13:01] <p6eval> rakudo 5351a3: OUTPUT«917503␤»

[13:04] <pmurias> 14:59 <@pmichaud> I suspect that Parrot strings are having difficulty with it.

[13:04] <pmurias> 14:59 < pmurias> ruoso: type system meaning ClassHOW,RoleHOW etc?

[13:04] <pmurias> 15:00 < ruoso> pmurias, and all the built-in types

[13:04] <pmurias> 15:00 <@pmichaud> rakudo:  say 0xeffff;

[13:05] <ruoso> pmurias, I guess you have an issue with yuor touchpad

[13:08] <masak> rakudo: say "foo" ~~ /<[f] #[comment] + [o]>/

[13:08] <p6eval> rakudo 5351a3: OUTPUT«perl6regex parse error: Error parsing enumerated character class at offset 30, found '['␤in Main (src/gen_setting.pm:3279)␤»

[13:08] <masak> pmichaud: I posit that this should work.

[13:09] <pmichaud> pge doesn't understand embedded comments.

[13:09] <masak> it does outside of <>.

[13:09] <pmichaud> right

[13:09] <masak> rakudo: say "foo" ~~ / fo #[ comment here! ] o /

[13:09] <p6eval> rakudo 5351a3: OUTPUT«foo␤»

[13:09] <pmichaud> huh.

[13:10] <pmichaud> well, it's very likely that the part that parses <[ ... ]>  doesn't understand them then.

[13:10] <pmichaud> std:  /<[f] #[comment] + [o]>/

[13:10] <p6eval> std 27351: OUTPUT«ok 00:03 36m␤»

[13:11] * masak submits rakudobug

[13:12] *** iblechbot left
[13:13] *** mizioumt1 joined
[13:18] *** KyleHa joined
[13:19] *** stepnem joined
[13:20] <masak> rakudo: module M; grammar G {}; say "foo" ~~ /<M::G>/

[13:20] <p6eval> rakudo 5351a3: OUTPUT«Null PMC access in set_attr_str()␤in regex M::_block62 (/tmp/9t1CmrXEZb:2)␤called from Main (/tmp/9t1CmrXEZb:2)␤»

[13:20] <masak> I know that's not the way to match against a grammar, but -- look, a Null PMC access!

[13:20] * masak submits a rakuodbug

[13:22] *** mj41 left
[13:22] *** mj41 joined
[13:22] <PerlJam> why is that not a way to match against a grammar?

[13:24] *** pmurias left
[13:24] <masak> PerlJam: because what goes into the <> is regexes and the like. not types.

[13:24] <masak> PerlJam: it's deceptively easy to try and do something like that, though.

[13:25] <PerlJam> oh.  Indeed.  I apparently did a mental substitution of s/grammar/rule/  s/module/grammar/

[13:26] <masak> that's part of why it's easy, I guess.

[13:26] <Matt-W> Must remember that grammars are just funny classes

[13:27] <Matt-W> it's almost like 'grammar G' is sugar for 'class G is Grammar'

[13:27] *** clintongormley joined
[13:27] <masak> I haven't found that rule of thumb to help me yet. :)

[13:27] *** frew_ joined
[13:27] *** mizioumt left
[13:27] <masak> at least not more than "a grammar is just a funny module".

[13:27] <Matt-W> masak: I don't usually think about it, I've just got the 'use the .parse method' thing in my head

[13:28] <masak> aye.

[13:28] <moritz_> but that doesn't work if you want to handle control to another grammar

[13:28] <moritz_> from within a grammar

[13:29] <masak> g'ah, the error reporting sucks!

[13:29] <moritz_> like rule link { '<a' 'href=' <URI::Gramamr::Call> ... }

[13:29] <masak> does anyone want to help me diagnose a problem?

[13:30] * masak tickles himself with the "don't ask to ask" feather

[13:30] <masak> hold on, I'll just push the latest commits

[13:32] <masak> there. if someone would clone grampa, run 'make test' and tell me whence the 'Null PMC access in find_method()' comes...

[13:34] *** mikehh left
[13:36] *** Sark23 left
[13:36] *** stepnem left
[13:37] <masak> ah, found it. nvm.

[13:38] <moritz_> so what was it?

[13:38] <masak> rakudo: module A; grammar G {}; say ?G.parse("foo")

[13:38] <p6eval> rakudo 5351a3: OUTPUT«Null PMC access in find_method()␤in Main (/tmp/jx8uygHmjM:2)␤»

[13:38] <masak> rakudo: module A; grammar G {}; say ?A::G.parse("foo")

[13:38] <p6eval> rakudo 5351a3: OUTPUT«The grammar has no TOP rule to invoke.␤in Main (/tmp/hezoJQJVrc:2)␤»

[13:38] *** stepnem joined
[13:40] <masak> I don't know, but I have a feeling that one's reported.

[13:41] <masak> still very hard to track down. I realised that was it when I had completely disables the whole grammar and the problem still remained.

[13:41] <pmichaud> it's the general "we don't know how to handle nested namespaces" issue.

[13:41] <masak> aye.

[13:42] <pugs_svn> r27352 | kyle++ | [t/spec] Mark where RT #60992 is tested.

[13:44] <Matt-W> Hmm

[13:44] <Matt-W> Sounds like that one needs a fix

[13:44] <Matt-W> pmichaud: thanks for commenting on my patch

[13:44] <pmichaud> Matt-W: you're welcome -- thanks for the patch.

[13:45] <Matt-W> I just poked around until I found an operator that looked nice and simple

[13:45] <pmichaud> You picked a good one.  :-)

[13:45] <pmichaud> There are some others lying about.

[13:45] <Matt-W> Yeah I only had time for the one

[13:45] *** PacoLinux joined
[13:46] <pmichaud> From a performance perspective, it might be worthwhile to also write a    infix:<leg>(Str $a, Str $b) { ... }   variant.

[13:46] <Matt-W> Mmm good point

[13:46] <Matt-W> would save two calls to prefix:<~>(Str)

[13:46] <pmichaud> but we can/should probably wait until we have a way to measure the performance :-)

[13:46] <Matt-W> (in the str case)

[13:46] <Matt-W> yes :)

[13:47] <Matt-W> or perhaps until there aren't various other crippling performance issues :)

[13:48] *** krakan left
[13:48] *** PacoLinux left
[13:52] <masak> I keep forgetting that the '?' quantifier creates Arrays in the Match tree...

[13:52] <jnthn> masak: Took me a while to remember that one too. :-)

[13:52] <pmichaud> yes, I've had that trouble also.  Especially since in an earlier draft of the spec the ? quantifier *didn't* create arrays.  :-)

[13:54] <masak> oh, so it was added?

[13:54] <masak> would be interesting to hear the rationale for that.

[13:54] <masak> it doesn't feel immediately obvious that it should.

[13:54] <pmichaud> "all quantifiers produce arrays"

[13:54] <masak> ok, so consistency.

[13:54] <pmichaud> right.

[13:54] <pmichaud> also so that  ?  remains the same as   ** 0..1

[13:55] <masak> oh, that's a nice reason.

[13:55] <pmichaud> previously ? was the exception to the rule... and I think the desire was to eliminate exceptions.

[13:55] <Matt-W> it makes a nice consistency

[13:55] <Matt-W> ? not matching just gives you an empty array

[13:55] <Matt-W> which suits me

[13:56] <Matt-W> although I thought the whole capture thing was broken last night... turned out I'd made a stupid one-character mistake

[13:56] *** frew left
[13:56] <Matt-W> no matter how cool Perl 6 is, it's not going to protect us from those

[13:57] <masak> no, but clueful error messages go a long way.

[13:59] *** cls_bsd joined
[13:59] <Matt-W> well my mistake was syntactically valid...

[13:59] <Matt-W> I was just ending up with an undefined value

[13:59] <Matt-W> which should not have been undefined

[14:00] <Matt-W> I thought it wasn't capturing properly

[14:00] <Matt-W> but of course it was

[14:00] <Matt-W> noooo

[14:00] <Matt-W> $colleague over there *points* is eating an ice cream!

[14:01] *** frew joined
[14:03] *** frew_ left
[14:04] <masak> Matt-W: ice cream is overrated. it's just frozen sugar.

[14:04] <jnthn> Frozen flavorings too!

[14:10] *** mkindahl left
[14:15] <Matt-W> and frozen cream!

[14:16] *** dalek left
[14:17] *** dalek joined
[14:18] *** payload joined
[14:18] *** rfordinal left
[14:18] *** rfordinal joined
[14:21] *** Lorn left
[14:29] *** PacoLinux joined
[14:29] <masak> Rakudo still returns 0 when it finds a syntax error. :/

[14:31] <masak> that way, running 'make test' proceeds to the tests even when the build fails.

[14:33] *** mkindahl joined
[14:33] <masak> ooh, I found another one!

[14:33] <masak> rakudo: regex foo { foo }; "foofoofoo" ~~ /<foo>+/; bar($<foo>); sub bar(@foos) {}

[14:33] <p6eval> rakudo 5351a3: OUTPUT«Parameter type check failed; expected Positional, but got List for @foos in call to bar␤in sub bar (/tmp/FtrwyZv3La:2)␤called from Main (/tmp/FtrwyZv3La:2)␤»

[14:33] <masak> jnthn: how does that happen?

[14:34] * masak submits rakudobug

[14:37] <jnthn> Probably to do with the way Match objects are made perhaps

[14:37] *** rfordinal left
[14:37] <pmichaud> I'm guessing that ResizablePMCArray doesn't ~~ Positional

[14:37] <jnthn> rakudo: regex foo { foo }; "foofoofoo" ~~ /<foo>+/; say $<foo>.PARROT

[14:37] <p6eval> rakudo 5351a3: OUTPUT«ResizablePMCArray␤»

[14:37] <jnthn> Right.

[14:37] <pmichaud> That's likely to be an issue.

[14:38] <moritz_> rakudo: my @a = 3, 4; say @a.PARROT

[14:38] <masak> it is an issue.

[14:38] <p6eval> rakudo 5351a3: OUTPUT«Perl6Array␤»

[14:38] <jnthn> Not sure quite what we can do about it off hand.

[14:38] <moritz_> can't you just invoke some magic that type-maps RPA to Perl6Array?

[14:38] <pmichaud> moritz_: not easily.

[14:38] <masak> more workaroundly, what's the easiest way to convert the former to the latter?

[14:38] <buubot> masak: Sorry, no more output 

[14:38] <pmichaud> but in the larger sense, we need for non-Rakudo arrays to still be treated as Positional

[14:39] <masak> buubot: shush!

[14:39] <buubot> Couldn't match input.

[14:39] * moritz_ is about to kick buubot 

[14:39] <pmichaud> i.e., if we're ever to get language interop to work.

[14:39] <jnthn> Probably need to as a fall-back check if it provides array from a Parrot POV too.

[14:39] <pmichaud> I'd be fine with adjusting Positional.ACCEPTS to check  "does array"

[14:40] <jnthn> Me too, if that was actually easy to do.

[14:40] <pmichaud> it's not?

[14:40] <masak> ah. .list worked.

[14:41] <jnthn> Not until we have a decent way to provide a non-punning ACCEPTS on a role or something.

[14:42] <jnthn> I (and afaict the spec) are a bit hazy on that area.

[14:42] <pmichaud> how does Positional.ACCEPTS work now?

[14:43] <jnthn> It's just Perl6Role::ACCEPTS

[14:43] <jnthn> Positional is an instance of Perl6Role

[14:43] <pmichaud> and we can't override ACCEPTS ?

[14:44] <jnthn> Not without mixing another ACCEPTS into Positional, but not sure what else that would do as a side-effect.

[14:45] <pmichaud> okay.

[14:45] <jnthn> Though this is all tied into "how we do define non-punned methods on a role separate from punned ones?"

[14:45] <pmichaud> I don't understand "non-punned" versus "punned" in this context.

[14:45] <jnthn> And I've not seen an answer to that yet.

[14:45] <jnthn> role Foo { }; Foo.new # puns

[14:46] <jnthn> Foo.ACCEPTS($thingy) # can't pun

[14:46] <jnthn> At the moment, the dispatcher just has a "magic list"

[14:46] <jnthn> But that's almost certainly not the Right Answer.

[14:46] <jnthn> I just don't know what the right answer is.

[14:46] <pmichaud> Oh.  Do the :U, :D, etc modifiers have anything to do with that?

[14:46] <pmichaud> or is that totally separate?

[14:46] <jnthn> Possibly.

[14:47] <Matt-W> hmm, a magic list sounds bad

[14:47] <jnthn> We could maybe make them mean that in the role invocant case.

[14:47] *** kidd_ joined
[14:47] <jnthn> Would need to think some more on how sane that is.

[14:48] <Matt-W> In my head, it's all simple

[14:48] <Matt-W> Until I remember that PGE is a Parrot thing, and is going to speak Parrot types that don't know about things like ACCEPTS

[14:49] *** m-i-l-a-n left
[14:49] <pmichaud> well, I may be able to get PGE to do some sort of type mapping, but specifying that mapping is a bit of a pain atm.

[14:49] <masak> interoperability theory is so much easier than interoperability practice.

[14:49] <Matt-W> interoperability is easy the moment you try something more complicated than making something interoperate with itself

[14:49] <Matt-W> *until the

[14:50] *** m-i-l-a-n joined
[14:51] *** payload left
[14:52] <Matt-W> Does this also have impact on things like getting objects back from, say, a Ruby module?

[14:52] <Matt-W> Or is that a different problem

[14:52] <pmichaud> same problem.

[14:52] <Matt-W> well that's something at least

[14:52] <Matt-W> only have to solve it once...

[14:53] *** finanalyst left
[14:53] <Matt-W> seems easy to say oh let's have some sort of mapping so that we know that RubyList and ResizablePMCArray do Positional, but I guess that could get big and fragile

[14:54] <pmichaud> jnthn: why is it the method that does the punning?

[14:54] <jnthn> pmichaud: I don't get the question.

[14:54] <jnthn> pmichaud: ah

[14:54] <pmichaud> I would think it's vivification that forces punning.

[14:54] <jnthn> pmichaud: It's the dispatcher that realizes you're calling a method on a role and decides "ah, we need to pun"

[14:55] <jnthn> vivification?

[14:55] <pmichaud> well,  Foo.new   # vivifies, thus puns

[14:55] * jnthn is confused

[14:55] <pmichaud> Foo.bar   # may not involve vivification, so no punning

[14:55] <jnthn> Define vivifies.

[14:55] <jnthn> Oh

[14:55] <pmichaud> S12:  When the typename happens to be a role, autovivifying it involves

[14:55] <pmichaud> attempting to create a punned class of the same name as the role.

[14:56] <jnthn> Isn't that from the section on auto-vivifying protos, which we don't do yet anyway?

[14:56] <pmichaud> autovivifying objects, yes.

[14:56] <Matt-W> how does it know the difference between .new and .bar?

[14:57] <pmichaud> but that's the only place where I see any mention of role punning atm.

[14:57] <jnthn> Matt-W: There isn't one.

[14:57] <pmichaud> Matt-W: presumably the difference would come about when .new attempts to do a CREATE

[14:57] *** justatheory left
[14:57] <Matt-W> pmichaud: So the magic might actually be in CREATE then

[14:58] <pmichaud> Matt-W: right.

[14:58] <masak> how do I get all the named captures of a Match object?

[14:58] <pmichaud> %/.hash

[14:58] <pmichaud> %/.hash.kv  # maybe

[14:58] <masak> thanks.

[14:58] <masak> yes, that worked. I was trying .keys, but needed .hash.keys.

[14:59] <pmichaud> it's not clear to me what .keys on $/ should produce.  

[14:59] <moritz_> I think it was decreed that it should die with a friendly message

[14:59] <pmichaud> while we can do that, I'm curious then about:

[15:00] <pmichaud> <a b c d>.keys

[15:00] <moritz_> (although I voted for a combined list of .list.keys, .hash.keys)

[15:00] <masak> pmichaud: (0,1,2,3), no?

[15:00] <pmichaud> masak: yes.  But <a b c d>  is just a capture, and a Match object is a capture, so....

[15:01] <Matt-W> Hmm. I thought .keys only had meaning on something which actually has keys

[15:01] <Matt-W> i.e. a Hash

[15:01] <pmichaud> Matt-W: lists have keys also

[15:01] <moritz_> pmichaud: stop digging up problems, and solve them instead ;-))

[15:01] <masak> pmichaud: maybe die only in the Match case? though I wouldn't mind .keys being the same as .hash.keys for a Match.

[15:02] <masak> pmichaud++ # problem wrangler

[15:02] <pmichaud> masak: I can make it die in the Match case, yes.

[15:02] <Matt-W> pmichaud: they do??

[15:02] <pmichaud> masak: but should we then do the same for .kv, .values, .pairs, etc?

[15:02] <masak> s'pose so.

[15:02] <pmichaud> Matt-W: say <a b c d>.kv.perl;

[15:02] <pmichaud> rakudo: say <a b c d>.kv.perl;

[15:02] <p6eval> rakudo 5351a3: OUTPUT«[0, "a", 1, "b", 2, "c", 3, "d"]␤»

[15:02] <pmichaud> rakudo: say <a b c d>.pairs.perl;

[15:02] <moritz_> please don't act on my possibly mis-rememebered answer

[15:02] <p6eval> rakudo 5351a3: OUTPUT«[0 => "a", 1 => "b", 2 => "c", 3 => "d"]␤»

[15:03] <pmichaud> rakudo: say <a b c d>.keys.perl;

[15:03] <p6eval> rakudo 5351a3: OUTPUT«[0, 1, 2, 3]␤»

[15:03] <Matt-W> ooh

[15:03] <Matt-W> okay

[15:03] <Matt-W> that makes sense

[15:03] <Matt-W> thanks pmichaud

[15:03] <masak> pmichaud: right now it takes the patience of a saint to extract information out of Match trees. it's a really powerful tool, but it's far too easy to use it wrongly right now.

[15:04] <pmichaud> masak: suggestions for things that would help?

[15:04] <masak> pmichaud: $<a><b> not dying when $<a> isn't defined.

[15:05] <pmichaud> rakudo:  my %h;  say %h<a><b>

[15:05] <p6eval> rakudo 5351a3: OUTPUT«Method 'postcircumfix:{ }' not found for invocant of class 'Failure'␤»

[15:05] <KyleHa> Where would be a good place for a test for this bug:  http://rt.perl.org/rt3/Ticket/Display.html?id=67124

[15:05] <pmichaud> masak: I can fix that when I get containers cleaned up a bit.

[15:05] <masak> \o/

[15:06] <masak> pmichaud: right now, the if statements have to fill up with workaroundish circumscriptions due to that flaw.

[15:06] <pmichaud> masak: okay, I'll prioritize that a bit.

[15:06] <moritz_> KyleHa: t/spec/S05-metasyntax/charset.t

[15:06] <masak> yay

[15:06] <KyleHa> moritz_: Thank you!

[15:08] *** rfordinal joined
[15:09] <pmichaud> need lunch.... bbiaw

[15:09] *** jaldhar joined
[15:12] <dalek> rakudo: 2dded8e | pmichaud++ | docs/spectest-progress.csv:

[15:12] <dalek> rakudo: spectest-progress.csv update: 412 files, 11592 passing, 52 failing

[15:12] <dalek> rakudo: Failure summary:

[15:12] <dalek> rakudo:     S04-declarations/my.rakudo aborted 47 test(s)

[15:12] <dalek> rakudo:     S12-enums/basic.rakudo 27 - short name of the enum without parenthesis is an enum

[15:12] <dalek> rakudo:     S32-num/rand.rakudo aborted 4 test(s)

[15:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2dded8edc021a3a33c89daa31991a1f874bbc100

[15:12] *** nihiliad joined
[15:14] <masak> ok, Grampa now does something useful. it can now search for things like '//foo/bar', which puts it in an advantage versus just treating the Match tree directly.

[15:14] <masak> so if you ever need to recurse through a tree of Matches, Grampa's the thing.

[15:15] <pugs_svn> r27353 | kyle++ | [t/spec] Test for RT #67124

[15:16] *** exodist joined
[15:16] *** exodist left
[15:17] <jnthn> grampa?

[15:18] * jnthn can't keep track of all the Perl 6 projects :-)

[15:18] <masak> jnthn: it's easy, they're all listed in proto's projects.list :)

[15:18] <masak> jnthn: Grampa traverses Match trees with XPath expressions.

[15:20] <masak> since XPath is so darn useful in other places too, we'll likely make the core XPath engine pluggable.

[15:21] <masak> but DOM maps pretty nicely over Match trees, actually.

[15:22] *** mvuets left
[15:22] <masak> the <from to Str> things can be mapped to DOM attributes, for example.

[15:40] *** justatheory joined
[15:47] *** nihiliad left
[15:47] *** mj41 left
[15:47] *** KyleHa left
[15:47] *** skids left
[15:47] *** christine left
[15:47] *** drbean left
[15:47] *** elmex left
[15:47] *** kcwu left
[15:47] *** mdxi left
[15:47] *** cosimo left
[15:47] *** hexmode left
[15:47] *** scrottie left
[15:47] *** yves left
[15:47] *** jiing_ left
[15:47] *** ascent_ left
[15:47] *** c9s left
[15:47] *** ashizawa left
[15:47] *** nihiliad joined
[15:47] *** mj41 joined
[15:47] *** KyleHa joined
[15:47] *** skids joined
[15:47] *** christine joined
[15:47] *** drbean joined
[15:47] *** elmex joined
[15:47] *** kcwu joined
[15:47] *** mdxi joined
[15:47] *** cosimo joined
[15:47] *** c9s joined
[15:47] *** ashizawa joined
[15:47] *** scrottie joined
[15:47] *** hexmode joined
[15:47] *** yves joined
[15:47] *** jiing_ joined
[15:47] *** ascent_ joined
[15:49] <literal> @tell azawawi actually, just try 0.08 instead (it's on CPAN now)

[15:49] <lambdabot> Consider it noted.

[15:49] *** sri_kraih left
[15:50] <masak> literal: I'm going swimming soon. see you at 19 UTC?

[15:50] <literal> yep

[15:50] *** mikehh joined
[15:50] *** sri_kraih joined
[15:55] <dalek> grok: 2d5db1d | (Hinrik Örn Sigurðsson)++ |  (6 files):

[15:55] <dalek> grok: Detect whether a file contains Pod 5 or Pod 6

[15:55] <dalek> grok: review: http://github.com/hinrik/grok/commit/2d5db1dc0bbbd27b7ece577f1b0a3da7cfcb987a

[15:55] <dalek> grok: 1259af1 | (Hinrik Örn Sigurðsson)++ |  (2 files):

[15:55] <dalek> grok: Some minor Pod reformatting

[15:55] <dalek> grok: review: http://github.com/hinrik/grok/commit/1259af1e8b0aef9c7f6041f9f94dc667b035a32a

[15:55] *** masak left
[15:59] *** bruce joined
[16:08] <KyleHa> Where's a good place for the test for this bug:  http://rt.perl.org/rt3/Ticket/Display.html?id=67024

[16:13] *** Lorn joined
[16:25] *** cdarroch joined
[16:27] <TimToady> ya know, if we made captures return captures instead of arrays, a ? capture would naturally work as either an array or a scalar

[16:27] <TimToady> s:2nd/captures/Captures/

[16:28] <Matt-W> captures don't return Captures? Headache time...

[16:28] <TimToady> well, maybe they should be more unified :)

[16:29] <Matt-W> maybe they should

[16:29] <TimToady> that was part of the reason we named them captures in the first place

[16:29] <TimToady> because they're *like* match captures

[16:29] <TimToady> maybe they should be liker

[16:29] <TimToady> er, other way around

[16:29] <Matt-W> what are the captures with a small c that you're referring to? To be precise.

[16:30] <TimToady> /(...)/

[16:30] <Matt-W> ah captures in regexps

[16:30] <Matt-W> good

[16:31] <TimToady> masak was carping about ? producing an array like ** 0..1

[16:31] <Matt-W> he was

[16:31] <Matt-W> I agreed that consistency is good

[16:31] <Matt-W> and that I tend to think of ? as a synonym for ** 0..1 anyway

[16:31] <pmichaud> so, would  the other quantifiers also have the same effect?

[16:32] <pmichaud> for example:  "foo" ~~ / ('foo')+ /

[16:32] <pmichaud> the resulting single-element Capture would naturally work as either an array or a scalar?

[16:32] <TimToady> yes, I think so

[16:32] <TimToady> the [0] becomes optional

[16:33] <TimToady> whereas currently it's mandatory

[16:33] <Matt-W> what happens if it's captured multiple things and you treat it like a scalar? You get the first one?

[16:33] <TimToady> no, you get all of them.

[16:33] <TimToady> a scalar capture is still just a capture until it's bound

[16:33] <pmichaud> in my example above, what would be the value of   +$0  ?

[16:33] *** m-i-l-a-n left
[16:34] <TimToady> good question

[16:34] <pmichaud> or worse

[16:34] *** m-i-l-a-n joined
[16:35] <pmichaud> "123,123" ~~ / (\d+) ** ',' /;    #  +$0 == 2 

[16:35] <pmichaud> "123" ~~ / (\d+) ** ',' /;    #  +$0 == ??? 

[16:36] <Matt-W> 1, surely?

[16:36] <pmichaud> Matt-W: surely not.

[16:36] <pmichaud> We already have this issue to some extent, though:

[16:36] <pmichaud> rakudo:   say +<123 123>;

[16:36] <p6eval> rakudo 2dded8: OUTPUT«2␤»

[16:36] <pmichaud> rakudo:  say +<123>;

[16:36] <p6eval> rakudo 2dded8: OUTPUT«123␤»

[16:36] <Matt-W> pmichaud: doesn't that match at all then?

[16:36] <Matt-W> oooh

[16:36] <Matt-W> hmm

[16:37] <TimToady> if we went the total capture route, we'd have to train people to say $0.elems

[16:37] <pmichaud> or  +@$0

[16:38] <pmichaud> rakudo:  say +@(123)

[16:38] <TimToady> might be worth it for the consistency

[16:38] <p6eval> rakudo 2dded8: OUTPUT«1␤»

[16:38] <Matt-W> I tend to say .elems anyway, somewher eI got in my head that the array in scalar context thing didn't work in perl 6 anyway

[16:38] <Matt-W> I think the consistency is a big win, the trick is training people how captures behave

[16:38] <pmichaud> rakudo:  say +@(123,123)

[16:38] <p6eval> rakudo 2dded8: OUTPUT«2␤»

[16:39] *** Psyche^ joined
[16:39] <TimToady> rakudo: say (123).elems

[16:39] <p6eval> rakudo 2dded8: OUTPUT«1␤»

[16:40] * Matt-W must learn about captures

[16:40] * pmichaud must learn about captures, also.

[16:41] <pmichaud> it'd be nice if our specs about captures were as immutable as the captures themselves :-P

[16:41] <KyleHa> It'd be nice if the specs about captures were all in one place.

[16:41] <Matt-W> it'd be nice if the specs for a lot of things were a bit more immutable!

[16:41] <Matt-W> But that'll happen one day

[16:41] * TimToady looks for a convenient bus to get run over by

[16:42] <Matt-W> TimToady: you really want to leave it to us to finish? hah!

[16:43] *** m-i-l-a-n left
[16:43] *** last left
[16:43] <pmichaud> do we still have separate Capture and List types?  Or are they fairly unified these days?

[16:44] <TimToady> maybe, or possibly a List is a Capture that guarantees to have no nameds

[16:44] <TimToady> don't know if that's worth anything

[16:44] <pmichaud> would we still have   Array ~~ List, then ?

[16:46] <TimToady> so what's the mutable analog of Capture?  a Harry?

[16:47] <pmichaud> I don't know.  But I have a sense that Match objects want to be mutable, at least inside of regexes.

[16:47] <pmichaud> Could be wrong about that.

[16:51] <TimToady> in Cursor/STD we allow mutability to the extent that it doesn't interfere with simple backtracking by throwing away a cursor

[16:51] <pmichaud> okay.

[16:51] <TimToady> it's not "pure", and it might in fact be a premature optimization, but it seems to work out okay

[16:52] <Lorn> moritz++ #perl5_to_perl6 awesome

[16:52] <TimToady> it also sneakily reuses cursors when ratcheting when it knows it can get away with it

[16:53] <TimToady> but a user-embedded closure can kinda be considered a BUILDer for the next immutable closure, in a sense

[16:53] <TimToady> so it's allowed to cheat

[16:54] <KyleHa> kinda considered cheat, in a sense.

[16:54] <TimToady> when you assign to $<foo> in a closure, it's actually changing $¢<foo>, not $/<foo>

[16:54] <TimToady> those start out the same, but $/ is the match object within the closure, and would

[16:55] <KyleHa> See, even if I knew "user-embedded closure" and "BUILDer for immutable closure", I still wouldn't know what that meant.  I'm guessing.

[16:55] <TimToady> be overridden by an inner match, whereas $¢ is not

[16:55] *** Patterner left
[16:55] *** Psyche^ is now known as Patterner

[16:55] <TimToady> mumbling to pmichaud mostly

[16:56] <pmichaud> eagerly absorbing TimToady++'s mumblings (mostly)

[16:57] <pmichaud> servers for $otherjob crashed overnight, so today I'm having to resurrect them a bit.

[16:57] *** ejs1 left
[16:57] <TimToady> now if we ever implement "let $<foo> = ..." then we'll likely have to generate a new $¢ at that spot and let the old one exist unchanged in any backtracking lists

[16:57] <[particle]> rakudo: '¢' ~~ /<alpha>/

[16:57] <p6eval> rakudo 2dded8:  ( no output )

[16:57] <[particle]> rakudo: say '¢' ~~ /<alpha>/

[16:57] <p6eval> rakudo 2dded8: OUTPUT«␤»

[16:57] <TimToady> no more alphabetic than $

[16:57] <pmichaud> $¢ is special, like $/ $! and $_

[16:57] <TimToady> or €

[16:57] <[particle]> right

[16:58] <[particle]> why aren't i getting 0 there?

[16:58] <pmichaud> you didn't ask for a boolean

[16:58] <[particle]> what's the context from the smartmatch if i don't ask for boolean?

[16:58] <pmichaud> it's the context of the say

[16:58] <pmichaud> and that context is string

[16:59] <pmichaud> arguably, though, a failed match might ought to throw a warning in that case

[16:59] <[particle]> is the match returning Nil?

[16:59] <pmichaud> it's returning a Match object that evaluates "false" in boolean context

[16:59] <[particle]> rakudo: say ('¢' ~~ /<alpha>/).WHAT

[16:59] <p6eval> rakudo 2dded8: OUTPUT«Match()␤»

[16:59] <pmichaud> matches always return match objects.

[16:59] <[particle]> ah, right

[17:00] <TimToady> rakudo: say ~()

[17:00] <[particle]> and a Match in string context is the content of the match

[17:00] <p6eval> rakudo 2dded8: OUTPUT«Use of uninitialized value␤␤»

[17:00] <TimToady> rakudo: say ~Nil

[17:00] <p6eval> rakudo 2dded8: OUTPUT«Nil()␤»

[17:00] <pmichaud> so perhaps stringifying a failed match or otherwise using it for its value should throw an exception

[17:01] <pmichaud> (i.e., it should act like a Failure)

[17:01] <[particle]> yeah, i think so

[17:01] <TimToady> again, Nil is really a value, not a type

[17:01] <pmichaud> right -- I haven't been able to make that change yet.

[17:01] <[particle]> it is a failure, not a match

[17:01] <pmichaud> it's still a Match, but it has failure semantics in it.

[17:02] <TimToady> rakudo: say ?/nonesuch/.defined

[17:02] *** finanalyst joined
[17:02] <p6eval> rakudo 2dded8: OUTPUT«1␤»

[17:02] *** molaf joined
[17:02] <TimToady> if failures report defined, foo() // die won't work

[17:03] <pmichaud> right

[17:03] <pmichaud> so I think I need to adjust Match objects to have Failure semantics on failed matches

[17:03] <TimToady> we have failure to communicate :)

[17:04] <pmichaud> the spec probably wants some explication there.

[17:04] <pmichaud> because I didn't pick that up from reading the current spec.

[17:04] <TimToady> S02:616

[17:04] <pmichaud> I meant S05.

[17:05] <TimToady> hmm. in the Cursor model, failure to match really is ()

[17:05] <pmichaud> and ().defined is false?

[17:05] <pmichaud> rakudo:   say ().defined

[17:06] <p6eval> rakudo 2dded8: OUTPUT«0␤»

[17:06] <pmichaud> failure to match is really (), but is that also something that does Match ?

[17:06] <TimToady> rakudo: say () // "hi"

[17:06] <p6eval> rakudo 2dded8: OUTPUT«hi␤»

[17:07] *** bruce left
[17:07] *** bruce joined
[17:07] <TimToady> matching ? 0 times returns a new cursor with the same pos rather than ()

[17:10] <dalek> grok: 8227fcc | (Hinrik Örn Sigurðsson)++ | TODO:

[17:10] <dalek> grok: Add a bunch of stuff to the TODO file

[17:10] <dalek> grok: review: http://github.com/hinrik/grok/commit/8227fccc4cc1e6d29bba69d729e93dfa26566996

[17:10] <dalek> grok: 5446fa1 | (Hinrik Örn Sigurðsson)++ |  (3 files):

[17:10] <dalek> grok: Add homepage and source repository to Makefile.PL

[17:10] <dalek> grok: review: http://github.com/hinrik/grok/commit/5446fa1f37cdd02c756bcf1c531568263870b6a4

[17:10] <dalek> grok: 7d7f20f | (Hinrik Örn Sigurðsson)++ |  (4 files):

[17:10] <dalek> grok: Refactor the code a bit and document public methods

[17:10] <dalek> grok: review: http://github.com/hinrik/grok/commit/7d7f20f85dd46987a0c0b76b501f79e33d948d74

[17:10] <dalek> grok: 5a0d6ae | (Hinrik Örn Sigurðsson)++ |  (9 files):

[17:10] <dalek> grok: Add some author tests (Pod, Perl::Critic, etc)

[17:10] <dalek> grok: review: http://github.com/hinrik/grok/commit/5a0d6ae304df09783e6a9e08fd5ebdecb92890c9

[17:10] <dalek> grok: bb28e42 | (Hinrik Örn Sigurðsson)++ |  (3 files):

[17:10] <dalek> grok: Various fixes suggested by Pod::Coverage and Perl::Critic

[17:10] <dalek> grok: review: http://github.com/hinrik/grok/commit/bb28e424ecd611128171699e8068f04df1bb9e48

[17:10] <dalek> grok: b1dddd4 | (Hinrik Örn Sigurðsson)++ |  (4 files):

[17:10] <dalek> grok: Bump version to 0.09

[17:10] <dalek> grok: review: http://github.com/hinrik/grok/commit/b1dddd49697334e55ca3a4e98fa038d8d81736a1

[17:11] <TimToady> good think I have dalek lolighted in dark blue...

[17:11] <TimToady> s/k/g/

[17:12] <pmichaud> okay, so let me briefly test my understanding of captures (in the Perl 6 sense, not the regex sense)

[17:13] <pmichaud> (), (1), and (1,2,3)   all produce captures

[17:13] <pmichaud> Nil is just another way of saying ()

[17:13] <pmichaud> Nil.perl and ().perl should result in "()"

[17:15] <pmichaud> ().elems is 0,   (1,2,3).elems is 3

[17:15] <pmichaud> ($x).elems would end up invoking $x's .elems method

[17:16] <pmichaud> in fact, any capture with exactly one positional element delegates method calls to that element

[17:17] <pmichaud> (@a, @b).elems would produce ... ?

[17:18] <literal> is dalek's source available publicly?

[17:23] <pmichaud> I'm guessing (@a, @b).elems would be the same as @a.elems + @b.elems, because the .elems method on a capture will impose flattening list context on its positional elements

[17:23] <pmichaud> same for .keys, .values, etc.

[17:24] <jnthn> pmichaud: But foo(@a, @b) doesn't flatten, no?

[17:24] <pmichaud> jnthn: depends on how it's bound

[17:25] <bruce> what about (%a, %b).elems or (1, 2).elems?

[17:25] <pmichaud> (1, 2).elems would be 2

[17:25] <pmichaud> (%a, %b).elems would be %a.elems + %b.elems, or more precisely    (@%a, @%b)

[17:25] <pmichaud> (%a, %b).elems would be %a.elems + %b.elems, or more precisely    (@%a, @%b).elems

[17:26] <pmichaud> because .elems would implose flattening list context on %a and %b

[17:26] <pmichaud> *impose

[17:26] <pmichaud> in the foo(@a, @b) case, the arrays flatten if bound to a slurpy param

[17:26] <pmichaud> they don't flatten if bound to scalar or array params

[17:28] *** braceta joined
[17:28] <pmichaud> (perhaps "interpolate" is a better word than "flatten" here.)

[17:29] <bruce> so, (1, @a, %b).elems would work out as 1 + @a.elems + %b.elems, right?

[17:29] <pmichaud> yes.

[17:30] <pmichaud> but we're not distributing .elems over the components of the capture, we're actually building a flattened list from the capture and counting the elements in that

[17:30] <pmichaud> so it's more like  [1, @a, %b].elems  but without creating the Array component

[17:31] <pmichaud> (because the array composer imposes interpolating list context on its elements)

[17:32] <TimToady> I'm not sure about all that flattening in invocant position

[17:33] <TimToady> I think the capture delegates methods it doesn't recognize itself

[17:34] *** payload joined
[17:34] <TimToady> so there at least ought to be a .elems-ish method that a Capture can answer 1 to

[17:34] <pmichaud> what would it delegate to...?

[17:34] *** M_o_C left
[17:34] *** M_o_C joined
[17:34] <TimToady> even if you say (@x).capelems

[17:35] <TimToady> it only delegates if there's a single *mumble* in the Capture

[17:35] <TimToady> if it's not an element, what is it?

[17:35] <TimToady> .args?

[17:36] <pmichaud> I agree it would be good to ask a capture for its positionals without any flattening

[17:36] *** M_o_C left
[17:36] *** M_o_C joined
[17:36] <pmichaud> would  @x.capelems and (@x).capelems  be different in that case, though?

[17:36] * jnthn -> dinner, hopefully some Rakudo time later on

[17:37] <TimToady> there's no capture on the left one

[17:37] <pmichaud> so, it's no longer true that (@x)  is the same as @x

[17:37] <pmichaud> okay.

[17:37] <TimToady> but capelems is unweildy

[17:38] <TimToady> and it's really strange to ask a Match object for .args

[17:38] <pmichaud> jnthn: do we have an easy way to delegate methods (e.g., from a builtin?)

[17:38] <pmichaud> well, normally for a Match object I recommend   @$/.elems or  %$/.elems

[17:39] <pmichaud> which comes around to the earlier discussion that perhaps   $/.keys (and $/.values $/.elems etc.)  should throw an ambiguity exception of some sort

[17:39] <TimToady> +@()

[17:40] <ruoso> TimToady, I always understood that a capture returning an array something as "a capture returning something that behaves like an array"

[17:40] <dalek> grok: 8436b20 | (Hinrik Örn Sigurðsson)++ | lib/App/Grok (2 files):

[17:40] <dalek> grok: Make a couple of diagnostic messages friendlier

[17:40] <dalek> grok: review: http://github.com/hinrik/grok/commit/8436b20dfc0a141a1d9a7bdae9804eb6f5f7267d

[17:41] <TimToady> well, it does positional readonly, not necessarily read/write

[17:41] <TimToady> I fear a lot of our roles are really two different roles for ro vs rw

[17:41] *** pmurias joined
[17:41] <ruoso> TimToady, isn't ro/rw'ness a state?

[17:42] <TimToady> define state

[17:42] <ruoso> I mean... does it really make sense to have different roles for ro and rw?

[17:42] <ruoso> some list might be read only or read write depending on runtime issues

[17:42] <ruoso> is it really necessary to bring that distinction to the type system/

[17:42] <ruoso> ?

[17:43] *** clintongormley1 joined
[17:43] <TimToady> it's just a little strange to say that something provides the Array interface but will fail at anything outside Positional

[17:44] <TimToady> and does Positional include lvalue subscripts?

[17:44] *** japhb left
[17:44] <ruoso> I always thought so

[17:44] <pmichaud> I've lost the thread here, I fear.

[17:44] <ruoso> sometimes they are read only

[17:44] <ruoso> sometimes they are not

[17:44] <ruoso> pmichaud, I was backlogging

[17:45] <ruoso> and brought an issue from about 1 hour ago

[17:45] <pmichaud> we're still discussing that same issue, I thought.

[17:46] <ruoso> ok... trying to put it another way, if Capture has a capitalized C, it means any object can be a Capture

[17:46] *** clintongormley left
[17:46] <ruoso> since it's not a native type

[17:46] <pmichaud> thus far I've just been trying to nail down the behavior of captures, without worrying about whether it's a native type.

[17:47] <ruoso> the behavior, imho, is the union of Array and Hash

[17:47] <ruoso> but it is read-only

[17:47] <pmichaud> in which case you really mean List and Mapping

[17:47] <pmichaud> instead of Array and Hash?

[17:48] <ruoso> is there really a difference in API between List and Array?

[17:48] <pmichaud> yes.

[17:48] <pmichaud> Array.push

[17:49] <ruoso> but, in theory, "my List $a = (1,2,3); $a[$a.elems] = 2" wouldn't fail in compile-time, right?

[17:49] <ruoso> since List implements .[]

[17:50] <pmichaud> it's a readonly .[]

[17:50] <TimToady> the compiler is allowed to complain about things it knows will fail

[17:50] <pmichaud> but it's not required to complain here.

[17:50] <pmichaud> it would complain at runtime, though.

[17:50] <ruoso> does the Multi dispatch considers the return of the method when choosing the candidate?

[17:51] <pmichaud> ruoso:  consider    my Range $a = 1..3;  $a[$a.elems] = 2     # fail

[17:51] <ruoso> in run-time

[17:52] <ruoso> the compile can't know that the Range that will be stored in $a is read-only or not

[17:52] <ruoso> s/compile/compiler/

[17:52] <pmichaud> Ranges are immutable.

[17:52] <ruoso> the default Range implementation is immutable

[17:52] <pmichaud> at any rate, it can know as much in the Range case as it can in the List case you gave above, I think.

[17:52] <ruoso> but I can have some weird object that says true to .does(Range)

[17:52] <ruoso> pmichaud, that's the poitn

[17:53] *** KyleHa left
[17:53] <pmichaud> what's the point?

[17:53] <ruoso> it can't know about List as well

[17:53] *** fridim_ joined
[17:53] <pmichaud> fair enough.

[17:53] <pmichaud> but I don't understand the larger point that you're getting at.

[17:53] <ruoso> there's no point in having different roles for ro and rw

[17:53] <ruoso> this is a runtime state

[17:53] <ruoso> of each particular object

[17:54] <pmichaud> there could be a point other than compile-time detection of things, though.

[17:54] <pmichaud> or we could compile-time detect things other than the examples you've given

[17:55] <ruoso> I'm thinking about the API itself, not about the hints it gives to the compiler

[17:55] <pmichaud> I'm still lost.  But I don't feel a strong need to find myself on this particular issue.

[17:56] <ruoso> I'm proposing the merge of List and Array, Hash and Mapping

[17:56] <ruoso> and Capture is a union of both APIs

[17:56] <pmichaud> What methods would a capture object "recognize itself"?

[17:56] <ruoso> what do you mean?

[17:57] <pmichaud> 17:33 <TimToady> I think the capture delegates methods it doesn't recognize itself

[17:58] <ruoso> I'm not sure I see any delegation happening... 

[17:58] <ruoso> a Capture in Item context might return a different object, when there's only one item inside it

[17:58] <ruoso> but other than that, it's a regular container

[17:58] <pmichaud> clearly   ($x).foo delegates the foo method call to $x

[17:58] <ruoso> that's because ($x).foo uses the capture in item context

[17:59] <pmichaud> and in the case of   ($x, $y).elems ?

[17:59] <ruoso> 2

[17:59] <pmichaud> right, but what received the .elems ?

[17:59] <ruoso> the Capture

[17:59] <pmichaud> so the Capture *does* understand some methods

[18:00] <ruoso> and that's when the need for a capture sigil emerges

[18:00] *** mvuets joined
[18:00] <ruoso> pmichaud, the Capture understand the Array and Hash API

[18:01] <pmichaud> ruoso: I'm not disagreeing.  But then TimToady made his comment that "the capture delegates methods it doesn't recognize itself"

[18:01] <pmichaud> thus my question

[18:01] <pmichaud> 17:56 <pmichaud> What methods would a capture object "recognize itself"?

[18:01] * TimToady was blathering

[18:01] <TimToady> what can I say to get ((),(),()) to return 3

[18:02] <TimToady> @@, I guess

[18:02] <ruoso> ((),(),()).elems does return 3

[18:02] <pmichaud> No.

[18:02] <pmichaud> it returns 0.

[18:02] <TimToady> @ flattens

[18:02] <TimToady> @@ doesn't

[18:02] <lambdabot>  doesn't

[18:02] <ruoso> where is the @

[18:02] <ruoso> ?

[18:02] <pmichaud> ruoso:  (@a, @b).elems  

[18:03] <ruoso> ah... that's a different case

[18:03] <pmichaud> it's not.

[18:03] <ruoso> but... 

[18:03] <ruoso> I'm not sure (@a, @b).elems return somethign different from 2

[18:03] <ruoso> because it hasn't been flattened yet

[18:03] <ruoso> if you say

[18:03] <pmichaud> You didn't read my comments from earlier.

[18:04] <TimToady> then why does (@a).elems not return 1

[18:04] <pmichaud> fair enough.  If TimToady++ says that (@a, @b).elems returns 2, I'll make it happen that way in Rakudo.  

[18:04] <ruoso> my ¢foo = (@a, @b); say ¢foo.elems

[18:04] <pmichaud> but I don't think that's been the expectation.

[18:04] <ruoso> TimToady, because of the Capture DWIM

[18:04] <PerlJam> ruoso: but what about what *I* mean?  :)

[18:05] <ruoso> the barrier that determines the flattening is not the infix:<,>, nor is the circumfix:<( )>

[18:05] <ruoso> but the enforcing of the list context

[18:05] <PerlJam> I've only been paying attention for about a minute here and it already seems confusing.  I typically just look for a nice clear rule I can follow to predict how code will behave and I'm not seeing one.

[18:05] <ruoso> when you assign to @a, for instance

[18:05] <ruoso> PerlJam, there are two ;)

[18:06] <PerlJam> ruoso: that's one fewer than 0, 1, infinity at any rate  :)

[18:07] <pmichaud> ruoso: as I speculated earlier,   (@a, @b).elems returns @a.elems + @b.elems because .elems imposes list context on the capture.    But if (@a, @b) is to return 2, I'll happily adjust my worldview to that position.  I just want to see it clearly stated somewhere.

[18:07] <ruoso> pmichaud, how .elems imposes list context?

[18:07] <TimToady> the original question was how we get 0/1 from /(...)?/

[18:08] <TimToady> if we make it a real capture with the Capture DWIM

[18:08] <pmichaud> yes, but I'm just looking for clarification of how captures work in general.

[18:08] <ruoso> maybe the problem is the Capture DWIM

[18:08] <pmichaud> Obviously ruoso++ and I don't have the same picture in mind.

[18:09] <pmichaud> I don't mind if my picture is incorrect, but I'd like to know that's the case because... well, I'm tired of Rakudo reporting incorrect results for things like (), Nil, and the like.

[18:09] <pmichaud> I'd really like to fix it.

[18:10] <pmichaud> So I'm looking for clarification on what we really mean by something like   (@a, @b).elems   or   +(@a, @b)  

[18:11] <pmichaud> as well as the other items that I speculated above, following the section of "let me briefly test my understanding of captures..."

[18:11] <TimToady> so perhaps we should generate a short list of examples and what our various expectations of them might be

[18:11] <ruoso> I see... one thing I'm trying to keep in mind is that premature flatenning was one of the worst mistakes in p5

[18:11] <pmichaud> yes, that's what I was doing above.

[18:11] <pmichaud> (generate a short list of examples)

[18:12] <TimToady> scattered throughout IRC is not my idea of a list :P

[18:12] <pmichaud> fair enough -- we have wikis.

[18:12] <TimToady> we need to capture it :)

[18:12] <ruoso> )PGUP,PGUP(

[18:12] <pmichaud> we can also do something like google docs, which makes it easier to collaborate in real time

[18:12] * pmichaud starts a google doc

[18:13] <ruoso> trying to get to a more concrete question,

[18:13] <ruoso> I think the issue resides in "where is the flattening barrier?"

[18:15] <TimToady> ruoso: on a different subject (yesterday's), I'm currently thinking that for bare names we have an object in the stash that is not the type object but points to things like type object, stash, or value

[18:15] <TimToady> biab &

[18:15] * ruoso feels a disturbance in the force, by the remote presence of globs

[18:16] *** mizioumt joined
[18:19] *** clintongormley joined
[18:19] *** athomason joined
[18:22] <ruoso> TimToady, honestly, I think having more sigils, or even the "::" "post-sigil" is a much better elegant way to solve the problem

[18:23] <skids> Then there's http://www.perlfoundation.org/perl6/index.cgi?perl6_tasks   But of course, if we follow OpenSource tradition every time "we need a wiki page for that" we make a new one, even if 3 more alrwady exist :-)

[18:23] *** mberends joined
[18:23] *** nihiliad left
[18:23] <pmichaud> skids: I specifically didn't aim directly for the perl6 wiki because I find editing it to be a pain.

[18:24] <pmichaud> (and I like wikis.)

[18:24] <pmichaud> (other than the perl6 wiki, that is)

[18:24] *** clintongormley1 left
[18:24] <ruoso> (social text)--

[18:27] <Tene> pmichaud: ever tried the verious wiki-as-filesystem FUSE projects?

[18:27] <pmichaud> Tene: not really.

[18:28] <Tene> Okay.  Passingly curious.

[18:28] *** nihiliad joined
[18:28] <pmichaud> http://spreadsheets.google.com/ccc?key=rZOTUv_eJpM-ImYnFt5Ck1g  # a spreadsheet with initial capture notes

[18:28] <skids> .oO(collaborative editing mode/IRC integration for November?)

[18:28] <pmurias> Tene: are you a FUSE user?

[18:30] <Tene> pmurias: occasionally.

[18:30] *** macae joined
[18:33] *** mizioumt1 left
[18:35] <pmichaud> ruoso: perhaps Capture ~~ Positional and  Capture ~~ Associative

[18:35] <pmichaud> as opposed to Capture ~~ Array and Capture ~~ Hash ?

[18:36] <pmichaud> if Capture ~~ Array, then I would expect to be able to do  Capture.push

[18:36] <ruoso> pmichaud, well... yeah... I still don't see much the boundaries between Array, List and Positional

[18:36] <pmichaud> ruoso: that's reasonable.  I'm working more from "what is currently specced" than from "what I'd like to see"

[18:36] <pmichaud> I do know that it's traditional in Perl (5) to distinguish "list" and "array"

[18:37] <pmichaud> one key distinction is that   @a = ....   is different from ($a, $b) ====

[18:37] <pmichaud> oops, one =

[18:37] <pmichaud> @a = ...    # array assignment

[18:37] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v

[18:37] <pmichaud> ($a, $b) = ...   # list assignment

[18:38] <pmichaud> which somewhat argues that array != list

[18:38] <ruoso> is that *really* different? 

[18:38] <pmichaud> rakudo currently relies on the distinction, yes.

[18:39] <ruoso> I mean, in both cases, you need to take the rhs, get an iterator, and push into the lhs the values... the difference is what you do before that

[18:39] *** xomas left
[18:40] <pmichaud> "push into the lhs" is a little different, though.

[18:40] <ruoso> only to the extent that the lhs is different

[18:40] <ruoso> not the process 

[18:40] <pmichaud> right, but the lhs being different is exactly what I'm referring to here.

[18:41] <ruoso> but they are *implemented* differently

[18:41] <pmichaud> 18:38 <ruoso> is that *really* different? 

[18:41] <pmichaud> 18:41 <ruoso> but they are *implemented* differently

[18:41] <ruoso> but they follow the same API

[18:41] <pmichaud> answer to your question:  Yes, they're *really* different (in implementation)

[18:42] <ruoso> does that needs to be represented as the presence of other built-in type?

[18:42] <pmichaud> just because things follow the same API doesn't mean they are the same.

[18:42] <ruoso> couldn't it be private to the implementation?

[18:42] <pmichaud> That's the whole point of an API :-)

[18:42] <ruoso> pmichaud, but we're precisely discussing the API itself

[18:43] <pmichaud> iiuyc, you're saying that Array and capture (list) are essentially the same

[18:43] <pmichaud> I'm pointing out a place where their behavior differ

[18:43] <pmichaud> they may have the same api, but the fact that the behaviors differ argues for them being different types

[18:43] <pmichaud> or for one being a subtype of another

[18:43] *** clintongormley left
[18:44] <ruoso> ok, we're arguing about different things

[18:44] <ruoso> I'm talking about what's the built-in API

[18:44] <pmichaud> I'm still just trying to understand what a capture does :-)

[18:44] <ruoso> as the Perl 6 spec defines

[18:44] <ruoso> each implementation is free to have different types to fulfill implementation details

[18:44] <ruoso> so, back to capture

[18:44] <pmichaud> the primary way I know to understand a type is to know how it responds to certain stimuli

[18:44] <skids>     @a[0] := $a; @a[1]  := $b; (@a[1],@a[2]) = ...; @a[1..2] = ...; @a = ...; # which does what?

[18:45] *** justatheory left
[18:45] <ruoso> Capture does Positional | List | Array; # let's wait to collapse that later

[18:45] <ruoso> Capture does Associative | Mapping | Hash; # let's wait to collapse that later

[18:45] <pmichaud> ruoso: good by me

[18:45] <pmichaud> skids:  the first two assignments have the effect of modifying $a and $b

[18:46] <pmichaud> the last assignment simply gives @a a new set of values.

[18:46] *** masak joined
[18:46] *** japhb joined
[18:46] <skids> That's what I thought.  thanks.

[18:46] <masak> #p6s in 14.

[18:46] <pmichaud> ...#p6s ?

[18:46] <literal> #perl6-soc

[18:46] <pmichaud> ah, thanks.

[18:46] <masak> weekly meeting.

[18:47] <pmichaud> freenode?

[18:47] <masak> aye.

[18:47] * pmichaud lurks.

[18:47] * masak backlogs

[18:48] <ruoso> pmichaud, we're saying that () generates a capture... so what's the role of infix:<,>?

[18:48] <pmichaud> it separates the elements of a capture

[18:49] <ruoso> but what happens in 

[18:49] <pmichaud> I should note that I still haven't grown comfortable with the idea of () generating a capture... that ends up being a bit new to me.

[18:49] <ruoso> ¢foo = 1, 2, 3

[18:49] <ruoso> is that just a syntax sugar for (1, 2, 3)?

[18:49] <skids> .oO(implicit ()'s because there's a , ?)

[18:49] <pmichaud> I'm okay if infix:<,> also produces a capture.

[18:50] <ruoso> pmichaud, you mean instead of a List

[18:50] <pmichaud> internally I'm somewhat working from the premise that "capture" and "list" mean the same thing.

[18:50] <pmichaud> and that it's really "argument list"

[18:50] <pmichaud> but that we call it "list" for short.

[18:50] *** mizioumt1 joined
[18:50] <ruoso> if your list support named elements as well... 

[18:50] <pmichaud> yes

[18:50] <ruoso> that's the only difference

[18:50] <pmichaud> list might end up supporting named elements.

[18:50] <ruoso> (that and the DWIM

[18:51] <pmichaud> but that also make it fit better with the notion of "lists" from a syntactic sense, as in "argument lists"  (which can have named elements)

[18:52] <ruoso> ok... if we switch from () generating captures to infix:<,>

[18:52] <pmichaud> if we simply say that infix:<,> produces captures, then I'm not sure that we need circumfix:<( )> to do so.

[18:52] <ruoso> it might have some impact on the ($x).elems issue

[18:52] <pmichaud> heh... great minds think alike :-)

[18:52] <pmichaud> I think that ($x).elems should be the same as $x.elems

[18:53] <ruoso> ok... how that works in "return $x"?

[18:53] <ruoso> do we simply send $x instead of a capture

[18:53] <ruoso> ?

[18:53] <pmichaud> I don't know yet -- that part is still fuzzy to me.  Along with how we deal with "take $x" inside of a loop.

[18:54] <ruoso> in theory, it's the same issue

[18:54] <pmichaud> sure.

[18:54] <ruoso> if I see what you mean

[18:55] <pmichaud> the real question is how do we unpack the capture in    $a = foo()    where foo has done  "return $x"

[18:55] <pmichaud> (assuming there's a capture)

[18:55] <ruoso> that's when the DWIM emerged

[18:55] <pmichaud> for "return $x" itself, we know there's a capture because that's what is passed to the return() function.

[18:55] <pmichaud> I'm fine with capture of one element still delegating

[18:55] <ruoso> it doesn't delegate

[18:55] <ruoso> it disappears

[18:55] <ruoso> leaving that object in its place

[18:56] <pmichaud> just because ($x) doesn't produce a capture doesn't mean we still can't have captures-of-one-element

[18:56] <pmichaud> in particular,  ($x,)   could still be a capture.

[18:56] <ruoso> right

[18:56] <ruoso> it would, indeed

[18:57] <pmichaud> anyway, for  $a = foo()   I would guess that $a gets the item from the capture

[18:57] <ruoso> exactly

[18:57] <pmichaud> somewhat more interesting is the case where foo does    "return $x, $y"

[18:57] <ruoso> in that case, it will store the capture

[18:57] <pmichaud> in that case there probably ought to be a warning

[18:57] <ruoso> not $x

[18:57] <ruoso> why?

[18:58] <ruoso> since my $a = (1,2,3) doesn't

[18:58] <pmichaud> no, but   foo(1,2)  does give a mismatch

[18:58] <dalek> grok: f2b5b09 | (Hinrik Örn Sigurðsson)++ | lib/App/Grok/Pod (2 files):

[18:58] <dalek> grok: Fix a typo and change the wording of an error msg

[18:58] <dalek> grok: review: http://github.com/hinrik/grok/commit/f2b5b0941d78c18316c608831244633b09427296

[18:58] <ruoso> pmichaud, assignment is not binding

[18:58] <pmichaud> right

[18:58] <pmichaud> I know that.

[18:58] <ruoso> if you try

[18:59] <ruoso> :($a) := foo(); and foo return 1,2

[18:59] <ruoso> it will fail

[18:59] <masak> rakudo: my $r = 1..9; $r.pop; say $r.perl # pmichaud: if ranges are immutable, how come I can pop from them?

[18:59] <p6eval> rakudo 2dded8: OUTPUT«1..8␤»

[18:59] <pmichaud> it will also fail with   ($a, $b, $c) = foo()

[18:59] <ruoso> fail? $c will still be undefined, but not failure

[18:59] <pmichaud> no, it's failure.

[19:00] <ruoso> by spec?

[19:00] <pmichaud> ($a, $b, $c) = (1, 2)   # fails

[19:02] <pmichaud> perhaps I'm misremembering

[19:02] <pmichaud> the spec does say 

[19:02] <pmichaud> ($a, $b) = (1, 2, 3, 4)  # warns

[19:02] <ruoso> that's fair.. since the runtime can detect that some items were lost

[19:02] <TimToady> um, S03:2443

[19:03] <pmichaud> TimToady: okay, got it.  Thanks.

[19:03] <TimToady> my ($a,$b,$c) is a degenerate case of =()

[19:03] <pmichaud> so ($a, $b, $c) = (1, 2)   # leaves $c as undef

[19:03] <TimToady> yes

[19:03] <pmichaud> my apologies for getting it wrong

[19:04] <TimToady> not wrong, just not what is specced :)

[19:04] <pmichaud> still, having $a = foo()   give $a the capture itself feels funny

[19:04] <pmichaud> it feels like I should have a special notation that says "I want the capture"  rather than that being the default

[19:05] <ruoso> maybe we start requiring the capture sigil to get the capture

[19:05] <TimToady> that one is jsut the Capture DWIM

[19:05] <ruoso> and item will always get the first element

[19:05] <TimToady> no

[19:05] <skids> But then if it does return a capture and you use the notation, do you get a capture of a capture?

[19:05] <TimToady> no throwing away data like P5

[19:06] <ruoso> point taken

[19:06] <ruoso> so 

[19:06] <ruoso> my $a = foo(); 

[19:06] <ruoso> will get a capture, 

[19:06] <ruoso> which means that

[19:06] <pmichaud> okay.

[19:06] <ruoso> if foo return @a, @b

[19:06] <ruoso> $a.elems return 2

[19:06] <pmichaud> that still seems open for discussion.

[19:06] <pmichaud> in the same sense that

[19:06] <pmichaud> my $a = (@a, @b)

[19:07] <pmichaud> could have .elems return something other than 2

[19:07] <ruoso> indeed... 

[19:07] <pmichaud> (I'm fine with $a = foo() causing $a to get a capture.)

[19:07] <ruoso> it's a matter of where the flattening barrier is

[19:07] <ruoso> er... in my $a = (@a, @b), $a does get a Capture

[19:08] <pmichaud> right.

[19:08] <pmichaud> although whether that's because of the infix:<,> or the circumfix:<( )>  is undecided (based on earlier discussion in this thread)

[19:09] <ruoso> I actually currently think infix:<,> is a more precise way of defining it

[19:09] <pmichaud> I do like the notion that   3*($a+5)  doesn't involve any captures.

[19:09] <pmichaud> at least, not because of the parens

[19:10] <pmichaud> (we still get captures from infix:<*> and infix:<+>, I guess)

[19:10] <ruoso> yeah

[19:10] <pmichaud> (but they may be optimizable away)

[19:10] <ruoso> indeed

[19:10] <TimToady> return types have to be good for something...

[19:13] <pmichaud> masak:  (ranges)  there was a spec change at npw that declares ranges as immutable.  Rakudo hasn't caught up.

[19:13] <pmichaud> masak: in particular, .pop and .shift are now gone from that part of the spec.

[19:14] *** mizioumt left
[19:14] <pmichaud> masak: indeed, part of the reason that rakudo hasn't caught up is because Ranges need to be refactored to be properly Positional, and doing that means we really need a good understanding of captures.  Hence, the discussion today.

[19:14] * masak submits rakudobug

[19:15] <pmichaud> we also need to remove the tests for .pop and .shift from the suite.

[19:15] *** sri_kraih_ joined
[19:15] <masak> I like ranges better when they're immutable.

[19:15] <pmichaud> yes, me also.

[19:15] <TimToady> I'm thinking .elems should be undefined on a multi-arg capture, probably

[19:16] <pmichaud> TimToady: same for values, prefix:<+>, .keys, etc?

[19:17] <pmichaud> keep in mind we get weird things like

[19:17] <pmichaud> my $a = <a b c d>;  say $a.elems

[19:17] <pmichaud> which would not like having .elems undefined.

[19:18] <pmichaud> (the correct formulation would have to be  @$a.elems or something like that.)

[19:18] *** jlaire left
[19:18] *** ejs joined
[19:19] <TimToady> $a[].elems

[19:19] <ruoso> I think we'll need to assume lists work differently in p5 than in p6

[19:19] <ruoso> and that flattening needs to be explicit

[19:19] <ruoso> so 

[19:19] <ruoso> TimToady, the problem about that is that the flattening will have to be implemented by the capture itself

[19:20] <TimToady> or we need something VAR() like to get at naked capture

[19:21] <pmichaud> yes, there does seem to be a point where captures start to look like fancy containers.

[19:21] *** nihiliad left
[19:22] *** nihiliad joined
[19:22] <ruoso> that's why I think the flattening needs to be external to the capture

[19:22] <ruoso> by explicit operations

[19:23] <ruoso> $a[].elems kinda work

[19:23] <ruoso> because it means we have postfix:<[]>

[19:23] <pmichaud> there's still   prefix:<*>  :-)

[19:23] <TimToady> er, no

[19:23] *** caio joined
[19:23] <masak> :)

[19:23] <TimToady> have to know whether to expect term/infix after

[19:24] <pmichaud> okay.

[19:24] <ruoso> std: multi postfix:<[]> {}; say $a[].elems;

[19:24] <p6eval> std 27353: OUTPUT«Potential difficulties:␤  Variable $a is not predeclared at /tmp/pJNrZxsLxp line 1:␤------> multi postfix:<[]> {}; say $a[].elems;␤ok 00:03 43m␤»

[19:25] <ruoso> yeah... postfix:<[]> is ok... and this operator is responsible for getting it flatten

[19:25] <ruoso> so...

[19:25] <ruoso> (@a, @b)[].elems is different than (@a, @b).elems

[19:25] <pmichaud> wait, I have a question about that.

[19:26] <pugs_svn> r27354 | pmurias++ | [re-smop]

[19:26] <pugs_svn> r27354 | pmurias++ | prefix:<->

[19:26] <pugs_svn> r27354 | pmurias++ | Code.arity

[19:26] <pugs_svn> r27354 | pmurias++ | multis do simple sorting of signatures based on positionals

[19:26] <pugs_svn> r27354 | pmurias++ | stringifing negative integers works (as do negative integers)

[19:26] <pugs_svn> r27354 | pmurias++ | Role.ACCEPTS($object) also checks if the object has composed Role

[19:26] <pugs_svn> r27354 | pmurias++ | Array.true always returns true

[19:26] <pmichaud> my $a = (@a, @b);   say $a[5];   # flattens?

[19:26] *** amoc left
[19:26] <ruoso> pmichaud, no

[19:26] <pmichaud> how would I get @a or @b themselves out of the capture?

[19:26] <ruoso> $a[0] and $a[1]

[19:27] <pmichaud> oh, and to get the 5th flattened element it would be  $a[][5]  ?

[19:27] <pmichaud> (6th, whatever)

[19:27] <ruoso> my $a = (@a, @b)[]; otoh...

[19:27] <TimToady> ick

[19:28] <ruoso> it only looks ugly while we don't look at the use of unflattened lists

[19:29] <ruoso> I mean...

[19:29] <ruoso> use @ if you want a flattened lsit

[19:29] <pmichaud> (mostly eager flattened list)

[19:29] <ruoso> or use @a <== 

[19:29] <ruoso> if you want a mostly lazy flattened list

[19:30] *** sri_kraih left
[19:31] <pmichaud> afk for a bit

[19:32] <ruoso> I think this is one of the things we can say "Hey! This is really different in Perl 6, you'll have to get used to it"

[19:32] <huf> what's the reason for it?

[19:33] *** ejs left
[19:33] <huf> i'd like to know why it was changed because i kinda liked the automatic list flattening in perl5. 

[19:33] <ruoso> it still has flattening

[19:33] <ruoso> but it requires you to use the sigil to have it

[19:33] <skids> .oO(if lists/captures are the same and  have named, what's an ordered list of pair objects look like as a literal?)

[19:33] <ruoso> my @a = (@b, @c); will have it flattened

[19:34] <huf> ah.

[19:34] *** justatheory joined
[19:35] <huf> so how would you have an array with the $ sigil? arrayref? 

[19:35] <huf> or one of these captures acts like an array in some contexts, but doesnt flatten?

[19:35] <ruoso> huf, just backlog a bit, we've been discussing that exact issue

[19:36] <huf> will do, thanks

[19:36] <skids> huf: reference is a dirty word around here :-)

[19:36] <huf> yes, i know they are dead

[19:40] *** mvuets left
[19:45] *** last joined
[19:48] <PerlJam> ruoso: if @a = (@b,@c) flattens, then does (@a,@b) = (@c,@d) too?

[19:48] <ruoso> what is this line supposed to do?

[19:49] <PerlJam> I'd want (@a,@b) = (@c,@d) to copy the values from @c into @a, and same for @d and @b.

[19:50] <ruoso> I'm not sure that will do it

[19:50] <ruoso> :(@a is copy, @b is copy) := (@c, @d) 

[19:50] <ruoso> that would do it

[19:51] <ruoso> but in the assignment, it doesn't really have a way to know when to stop putting things on @a

[19:51] *** finanalyst left
[19:51] <ruoso> (except if @a has a pre-defined shape)

[19:54] <masak> could anyone with a bit more EBNF-fu than me explain how rules [3] and [11] would _not_ create an infinite regress in http://www.w3.org/TR/xpath ? because they do when I turn them into a Perl 6 grammar.

[19:55] <pmichaud> masak: ebnf doesn't concern itself with left-recursion issues

[19:55] <pmichaud> i.e., left-recursion is automatically taken care of

[19:56] *** xomas joined
[19:57] <masak> pmichaud: I sense there's some theory behind that, probably to be found in the Dragon Book or something?

[19:58] <pmichaud> yes, or a theory of languages course

[19:59] * masak reads up on http://en.wikipedia.org/wiki/Left_recursion

[19:59] <TimToady> [S09] add missing rat native types

[19:59] <TimToady> oops

[20:00] <TimToady> phone

[20:01] *** justatheory left
[20:03] <TimToady> n

[20:03] <TimToady> oops again

[20:06] * masak feels the S/N ratio of the channel drop sharply... :)

[20:07] *** exodist joined
[20:07] *** exodist left
[20:07] *** macae left
[20:07] <jnthn> masak: whoz up?

[20:07] <jnthn> ;-)

[20:08] <masak> 哈哈

[20:11] <masak> ok, rewriting the Grampa XPath grammar so it'll take advantage of Perl 6 grammars instead of trying to stay true to the XPath spec.

[20:14] <masak> when I have a part of a Match tree $<foo><bar> which I know to be a list, and I want to loop over it, do I write 'for $<foo><bar> { ... }' or 'for $<foo><bar>.values { ... }'?

[20:15] <pmichaud> maybe  @($<foo><bar>)

[20:15] <pmichaud> or  $<foo><bar>.list

[20:16] <masak> ok.

[20:16] <pmichaud> using $<foo><bar> by itself seems like it would only give one iteration

[20:16] <masak> yes.

[20:16] <masak> even though that particular thing is a List, the $ sigil makes Perl treat it like an item.

[20:17] <jnthn> rakudo: for 1..15 -> $n { when $n % (3&5) { say "FizzBuzz" }; when $n % 3 { say "Fizz" }; when $n % 5 { say "Buzz" } }

[20:17] <p6eval> rakudo 2dded8: OUTPUT«Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Fizz␤Use of uninitialized

[20:17] <p6eval> ..value␤Use of …

[20:17] <jnthn> Am I being especially stupid this evening, or are those unit value warnings a bug?

[20:17] <jnthn> *uninit

[20:18] <pmichaud> what are you matching against?

[20:18] <masak> jnthn: I thought 'when' matched against $_

[20:19] <jnthn> oh duh

[20:19] <pmichaud> note that $n % (3&5)  isn't a boolean :-)

[20:19] <jnthn> right

[20:19] <jnthn> gah

[20:19] <masak> ?() should solve it, then.

[20:19] <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn

[20:19] <masak> lambdabot: oh, hush.

[20:19] * jnthn was pondering doing some Rakudo hacking tonight and now wonders if he really should...

[20:19] <masak> @@ lambdabot is stupid

[20:19] <lambdabot>  lambdabot is stupid

[20:19] <masak> :)

[20:19] <jnthn> @@ sucks

[20:19] <lambdabot>  sucks

[20:20] <jnthn> more input is given by all non-stupid bots

[20:20] <buubot> jnthn: Sorry, no more output 

[20:20] <jnthn> ...output too.

[20:20] <masak> more output, buubot, please! we beg you!

[20:20] <buubot> masak: Sorry, no more output 

[20:20] <jnthn> we wish.

[20:21] * jnthn git stash apply's his traits work from Monday and continues hacking on it

[20:23] *** iblechbot joined
[20:24] * jnthn wonders when S14 got marked [DRAFT]

[20:25] <masak> is there any synopses which is not a draft?

[20:25] <ruoso> masak, there are several levels of draftness

[20:25] <PerlJam> It would be interesting to see one marked "final"  :)

[20:26] <jnthn> S12 isn't marked DRAFT for example.

[20:26] <ruoso> the thing is that several concepts haven't been stressed out yet

[20:26] <ruoso> and usually, as the implementations get there, it requires a lot of changes

[20:27] <jnthn> Aye, but S14 is probably the synopsis that Rakudo has the best coverage of. ;-)

[20:27] <masak> rakudo: take 5

[20:27] <p6eval> rakudo 2dded8: OUTPUT«Died␤in Main (/tmp/uuckDsGlCB:2)␤»

[20:27] <ruoso> masak, that's expected

[20:28] <masak> do we suddenly have no error message for take without gather?

[20:28] <ruoso> take should throw an exception

[20:28] <jnthn> Did we ever have one?

[20:28] <ruoso> a control exception

[20:28] <masak> I'd like one.

[20:28] <Tene> 'take' does throw an exception, one that 'gather' catches.

[20:28] <Tene> masak: you could add it to perl6.pir's global exception handler

[20:28] <Tene> check the type of the exception

[20:29] <masak> ok; let me just create the rakudobug first, in case I fail. :)

[20:29] <Tene> :)

[20:30] *** araujo left
[20:30] <Tene> TimToady: is there any specced behavior for 'take' without 'gather' or another EH?

[20:31] <masak> I'm not 100% it should halt execution...

[20:31] <masak> is there any way to resume it after giving a warning?

[20:31] <Tene> Yes.

[20:31] <Tene> In fact, you could just modify the 'take' sub to set the severity to 'normal'

[20:31] <Tene> and it should auto-resume

[20:32] <masak> cool!

[20:32] <masak> Tene++ Parrot++

[20:32] <Tene> ... except I think that rakudo's global exception handler grabs everything, not just non-fatal exceptions

[20:32] <Tene> so, maybe some issues there

[20:32] <jnthn> rakudo: say infix:<+>(2,2)

[20:32] <p6eval> rakudo 2dded8: OUTPUT«Statement not terminated properly at line 2, near ":<+>(2,2)"␤in Main (src/gen_setting.pm:3279)␤»

[20:32] <jnthn> std: say infix:<+>(2,2)

[20:32] <p6eval> std 27354: OUTPUT«ok 00:02 37m␤»

[20:33] <Tene> masak: in fact, it *does* auto-resume with the EH disabled

[20:33] <jnthn> trait_mod:<is>($declarand, $trait, &arg);

[20:33] <Tene> so, the EH needs to either rethrow or ignore non-fatals

[20:33] <jnthn> std: trait_mod:<is>($declarand, $trait, &arg);

[20:33] <p6eval> std 27354: OUTPUT«Potential difficulties:␤  Variable $declarand is not predeclared at /tmp/Sy7NusDoT1 line 1:␤------> trait_mod:<is>($declarand, $trait, &arg);␤  Variable $trait is not predeclared at /tmp/Sy7NusDoT1 line 1:␤------> trait_mod:<is>($declarand, $trait,

[20:33] <p6eval> ..&arg);[0…

[20:33] <Tene> probably the latter

[20:33] <Tene> I can do that.

[20:33] <masak> nice.

[20:34] <masak> I'll leave it in your competent hands, and go back to hacking on Grampa. :)

[20:34] <Tene> masak: try changing != to <= on perl6.pir:217

[20:34] <masak> ok.

[20:37] <masak> Tene: doing only that didn't help.

[20:37] <masak> Tene: do I also need to check for the exception type?

[20:37] <Tene> masak: no, you should not check for the exception type.  You should use >= instead of <= like I told oyu the first time.

[20:37] <Tene> ETENECANTREAD

[20:37] *** justatheory joined
[20:38] * masak tries again

[20:38] *** KyleHa joined
[20:38] <Tene> erm

[20:38] <Tene> just >

[20:39] * Tene fail

[20:39] <masak> :)

[20:39] <Tene> but seriously, it should just be '>'

[20:39] <Tene> I'm confident this time.

[20:39] <Tene> Again.

[20:40] <masak> I'll try that, then.

[20:42] <masak> Tene: that seems to work. now it survives the take-outside-of-gather.

[20:42] <masak> Tene: still no useful message, though.

[20:43] <masak> just a blank line in STDERR.

[20:43] <Tene> masak: well, no message is set in the take() function

[20:43] <justatheory> What is "huffmanized" or "The Huffman principal"? http://groups.google.com/group/perl.perl6.compiler/browse_thread/thread/34c2d1c64556ad07

[20:43] * masak looks

[20:43] <masak> justatheory: he's headmaster at the Huffman academy. *scnr*

[20:43] <justatheory> There should be a definition for this…

[20:43] <PerlJam> justatheory: things that are used often have the shortest token

[20:43] <Tene> add $P0['message'] = 'OMG HAI MASAK!!!' as line 88 of control.pir

[20:43] <justatheory> masak: No, that's the Huffmanator.

[20:44] <justatheory> PerlJam: I see.

[20:44] <masak> Tene: gotcha.

[20:44] *** skids left
[20:44] <PerlJam> justatheory: or perhaps you'd say that the length of your tokens are inversely proportional to their frequency of use.

[20:45] <justatheory> Is there a name for TimToady's rule that similar things should have very different names?

[20:45] <justatheory> PerlJam: That's nicely put, thans.

[20:45] <justatheory> *thanks

[20:45] <masak> justatheory: similar things should have different names? that sounds backwards.

[20:46] <masak> isn't it different things that should have different names? :)

[20:46] <justatheory> masak: Functions that do similar names should not be named too similarly. Something like that.

[20:46] <Tene> masak: "things that can be easily confused should have something to clearly distinguish them" perhaps

[20:46] <justatheory> right

[20:46] <masak> justatheory: IMO, .values and .elems are too similar in that respect.

[20:46] <PerlJam> Tene++

[20:46] <Tene> you wouldn't want "subst" and "substr" as functions that do slightly different things.

[20:47] <masak> Tene: right. :)

[20:47] <PerlJam> Tene++ again :)

[20:47] <justatheory> Yeah, is there a name for the concept?

[20:47] <justatheory> TimToady's Rule

[20:47] <masak> "different things should be different"

[20:47] <Tene> iirc there's a name in linguistics somewhere.

[20:47] <Tene> for something similar

[20:48] <justatheory> Hrm, allison would know, too, then.

[20:49] <pugs_svn> r27355 | pmurias++ | [re-smop] fix test count

[20:49] *** RonOreck joined
[20:50] <pmurias> masak: the point of "similiar things should be different" is that you don't confuse them

[20:50] <masak> pmurias: aye. I get it.

[20:50] <jnthn> .oO( pisat vs pistat )

[20:51] <masak> .oO( honourous vs onerous )

[20:51] *** fridim_ left
[20:51] <jnthn> .oO( laughter vs slaughter )

[20:52] * jnthn watches the spectests roll by

[20:52] <pmichaud> .oO( through versus though versus tough versus thorough versus throughout versus thought versus ...)

[20:52] <dalek> rakudo: 468c021 | masak++ |  (2 files):

[20:52] <dalek> rakudo: [control.pir] take without gather now warns

[20:52] <dalek> rakudo: Before this commit, a 'take' without a (dynamically) enclosing 'gather'

[20:52] <dalek> rakudo: block halted the program without explanation. This commit makes the

[20:52] <dalek> rakudo: condition non-fatal and adds a warning message. Tene++ for guidance.

[20:52] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/468c021f9a3480658bb973182b7f797220521d78

[20:53] *** KyleHa left
[20:53] <jnthn> trait_auxiliary is dead. :-)

[20:53] <jnthn> Long live trait_mod

[20:54] <pmichaud> yay!  die <trait_auxiliary>

[20:54] <masak> rakudo: die <trait_auxiliary>

[20:54] <p6eval> rakudo 2dded8: OUTPUT«trait_auxiliary␤in Main (/tmp/GyGvFtHLBn:2)␤»

[20:54] <jnthn> Tomorrow trait_verb can go away.

[20:55] <jnthn> Then we start refactoring towards multi-dispatch.

[20:55] <Tene> On that note, many years ago the Norwegian Broadcasting  Corporation decided to require all its weathermen to use the  non-standard form “aust” /æʉst/ (east) in lieu of the standard  form “øst” /øst/, because the latter could easily be confused  with “vest” /ʋest/ (west).

[20:55] <jnthn> Apart from, I need to fix up multi-dispatch before that...

[20:55] <Tene> -- from another channel, where I brought the question up

[20:55] *** caio left
[20:56] *** bruce left
[21:00] *** pmurias left
[21:03] *** masak left
[21:10] *** Whiteknight joined
[21:18] *** braceta left
[21:20] *** ruoso left
[21:21] *** eternaleye left
[21:25] *** eternaleye joined
[21:26] *** eternaleye left
[21:29] *** eternaleye joined
[21:31] *** mizioumt1 left
[21:36] *** mberends left
[21:42] *** perl7 joined
[21:44] *** netfish joined
[21:51] *** alester joined
[21:54] *** molaf left
[21:54] *** netfish left
[21:55] *** perl7 left
[22:01] *** iblechbot left
[22:02] *** wknight8111 joined
[22:07] *** Whiteknight left
[22:11] *** drbean left
[22:19] *** skids joined
[22:24] *** nihiliad left
[22:30] *** MrKrueger left
[22:32] *** meppl joined
[22:35] *** Limbic_Region joined
[22:37] *** meppl left
[22:39] *** netfish joined
[22:46] <dalek> rakudo: 59d2b7a | jnthn++ |  (5 files):

[22:46] <dalek> rakudo: More work on bringing our traits support closer in line with S14 and STD.pm. This kills trait_auxiliary in favor of trait_mod, adds parsing and an implementation of will (just delegates to is) and parsing of hides too (not yet implemnted), so now we should parse all the trait mods that STD does.

[22:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/59d2b7afe06d313f360cbe11ff0d26c595c0262a

[22:46] <dalek> rakudo: 3d94ef4 | jnthn++ | :

[22:46] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[22:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3d94ef4ef9c088d6e81f2a26b016aab202719d30

[22:55] *** Muixirt left
[22:58] *** kidd_ left
[23:01] *** frew_ joined
[23:14] <skids> justatheory: (backlogging) a close concept to the linguistic one you are looking for is the "avalanche effect" property of hash functions -- similar hash inputs must give much different outputs.

[23:25] <skids> ruoso: what test should be run before committing to re-smop?

[23:33] *** nihiliad joined
[23:33] *** nihiliad left
[23:37] *** M_o_C left
[23:43] *** sri_kraih_ left
[23:49] *** DemoFreak left
[23:52] *** DemoFreak joined
[23:58] *** wknight8111 left
