[00:04] <jnthn> lichtkind: The problem is that the class is globally modified.

[00:04] <jnthn> In place.

[00:04] <lichtkind> which is unclean

[00:04] <jnthn> A form of action at a distance.

[00:05] <jnthn> Aye.

[00:05] <jnthn> OK, sleep for me...

[00:05] <jnthn> dobru noc

[00:11] *** omega joined
[00:12] <omega> hms, did I flood?

[00:12] <lambdabot> omega: You have 1 new message. '/msg lambdabot @messages' to read it.

[00:12] <omega> ahh, it seems not :p

[00:14] *** amoc left
[00:16] *** nihiliad1 joined
[00:20] <lichtkind> dobrou

[00:20] *** lichtkind left
[00:21] *** nihiliad1 left
[00:24] *** amoc joined
[00:26] *** nihiliad left
[00:37] <snarkyboojum> laku noc even

[00:37] <snarkyboojum> or dobar noc

[00:49] *** nihiliad joined
[00:50] *** kate21de1 left
[00:55] *** unitxt_ joined
[00:55] *** nihiliad left
[01:01] *** eternaleye left
[01:02] *** FurnaceBoy joined
[01:02] <FurnaceBoy> The requested URL /pugs/docs/01Overview.html was not found on this server.

[01:05] *** amoc left
[01:06] *** unitxt left
[01:09] <TimToady> looks like it should be docs/Pugs/01Overview.html

[01:12] <sjohnson> hot day today

[01:16] *** amoc joined
[01:20] *** eternaleye joined
[01:23] *** amoc left
[01:23] *** amoc joined
[01:27] *** Chillance joined
[01:31] *** blas left
[01:34] <DanielC> S22 says that YAML will be "available standard in Perl 6". What Synopsis talks about this?

[01:35] <JDlugosz> Hi guys.

[01:47] *** unitxt joined
[01:54] *** synth left
[01:57] *** unitxt_ left
[02:04] *** DemoFreak left
[02:06] *** justatheory joined
[02:10] <DanielC> @tell pmichaud The problem with the k-nucleotide benchmark is definitely the ++. If you replace for loop by a "loop ($i=0; ...; $i+=1)" and change the "%table{...}++" to "+=1" the program runs 3 times faster.

[02:10] <lambdabot> Consider it noted.

[02:13] *** azawawi joined
[02:13] <azawawi> hi

[02:13] *** frew|work joined
[02:15] <DanielC> o/

[02:17] *** DanielC is now known as DanielC_zzzz

[02:17] *** jonathanturner joined
[02:20] *** DanielC_zzzz left
[02:20] *** justatheory left
[02:23] *** araujo left
[02:24] *** araujo joined
[02:25] *** araujo left
[02:26] *** araujo joined
[02:31] *** synth joined
[02:31] *** synth left
[02:43] *** araujo left
[02:44] *** araujo joined
[02:44] *** araujo left
[02:45] *** araujo joined
[02:45] *** araujo left
[02:46] *** araujo joined
[02:46] *** araujo left
[02:46] *** snarkyboojum left
[02:46] *** azawawi left
[02:47] *** araujo joined
[02:49] *** araujo left
[02:50] *** meppl left
[02:54] *** alanhaggai joined
[02:56] *** araujo joined
[03:01] *** wknight8111 joined
[03:07] *** Chillance left
[03:11] *** alanhaggai left
[03:38] *** justatheory joined
[03:40] *** agentzh left
[03:40] *** agentzh joined
[03:44] *** wknight8111 left
[03:50] *** xinming_ is now known as xinming

[04:18] *** snarkyboojum joined
[04:19] *** FurnaceBoy left
[04:29] *** cotto left
[04:46] *** cotto joined
[04:56] *** justatheory left
[05:01] *** charsbar_ joined
[05:10] *** snarkyboojum left
[05:11] *** fridim_ joined
[05:13] *** cotto left
[05:18] <pugs_svn> r26975 | lwall++ | [Cursor] switch to specced action api (tag separate from method name)

[05:32] *** cotto joined
[05:43] *** kate21de joined
[05:52] *** xinming_ joined
[05:59] *** brunov left
[06:09] <pugs_svn> r26976 | lwall++ | [S11] introduce declarators "need" and "defines", components of "use"

[06:09] *** xinming left
[06:12] *** snarkyboojum joined
[06:13] <JDlugosz> anybody around?

[06:15] *** unitxt left
[06:17] *** unitxt joined
[06:22] *** alexn_org joined
[06:38] <Tene> JDlugosz: I am.

[06:38] <JDlugosz> I don't think I've run into you before.

[06:39] <Tene> I've seen you around a bit.  I haven't been very vocal lately.

[06:39] <Tene> Busy with work and the girlfriend.

[06:40] <JDlugosz> Been with Perl 6 long?

[06:40] <Tene> about two or three years, I think.

[06:41] <JDlugosz> What have you worked on or been involved with?

[06:41] <Tene> so, depends on what you cpmare it to. :)

[06:41] <Tene> Rakudo, Parrot, Web.pm

[06:42] *** ejs1 joined
[06:42] <JDlugosz> Well, I read the Apocolypses when they came out one at a time, and figured it would be available soon.  Sooner than this!  It was a little over a year ago that I was disapointed in the progress to date.

[06:42] <Tene> I drift around... I did a lot of exceptions stuff a while back.  Recently I've been focusing on HLL interop.

[06:43] <Tene> Got Rakudo working together (kinda) with Cardinal, the Ruby compiler I wrote a year ago.

[06:43] <JDlugosz> When Kodak closed, I took a sabatical and decided to make a serious contribution.

[06:43] <Tene> What are you interested in working on?

[06:43] <JDlugosz> What's the attraction of Ruby?  Years ago it seemed to not hold up to Perl.

[06:44] <Tene> I wrote a ruby compiler because nobody else had written one and I didn't know ruby.

[06:44] <Tene> I think.  It was long enough ago that I don't remember my motivations too well.

[06:44] <Tene> It's been pretty abandoned for a while now, but it was an easy target for me to add HLL interop stuff to.

[06:44] <JDlugosz> My ongoing interest is to develop a real formal specifcation.  I'm also interested in type theory and the new "roles" idea, and ramifications of generics and interplay between typed and untyped code.  Whew!

[06:45] <JDlugosz> Care to read what I'm working on now?

[06:46] <Tene> I'll take a look at it, and read it if it catches my eye.

[06:47] <JDlugosz> <http://www.dlugosz.com/Perl6/web/info-model-TOC.html>

[06:47] <Tene> Ah, yes, I saw this on the ml.

[06:47] *** eMaX joined
[06:48] <JDlugosz> HLL interop is tricky business.  Look at the hype of C#.  They claim "write in any language" but they mean Java with your choice of syntax.  You have to program to their wimpy capabilities, and totally loose what makes a language unique or powerful.

[06:48] *** alexn_org left
[06:50] <Tene> Yes, very tricky.

[06:50] <Tene> My attempts right now are definitely wrong.

[06:51] <Tene> I spent a long time thinking about it, and didn't really get anywhere at all, so now I'm trying to implement *something* in hopes that it will either help me work out something better or attract the interest of someone who can do a better job.

[06:51] <JDlugosz> Ever use a program called Inkscape?

[06:51] <Tene> Occasionally.

[06:52] <JDlugosz> Not what it's cracked up to be, it seems.  Too brittle, strange bugs, etc.

[06:52] <Tene> Yeah, sounds familiar.

[06:52] *** cotto left
[06:52] <JDlugosz> Windows that don't behave, browse dialogs that are non-standard and don't remember the path you wanted...

[06:53] <JDlugosz> I just discovered I lost some work, from a file I was fighting to copy/paste from.

[06:53] <JDlugosz> Had to google discussions to figure out how to copy from one document to another!

[06:54] <Tene> Sounds like some of my first HLL interop attempts. :)

[06:54] *** LadyLunacy joined
[06:54] <JDlugosz> the open dialog shows all the files twice.

[06:55] <Tene> Interesting.

[06:57] <JDlugosz> You might find my type stuff interesting.

[06:59] *** cotto joined
[07:01] *** skids left
[07:05] *** viklund joined
[07:09] *** LadyLuna1y left
[07:26] <Tene> Nice... I now have PIR library loading working from Rakudo and Cardinal.

[07:26] <Tene> I need to figure out the makefile rules for this, though...

[07:26] *** alexn_org joined
[07:36] *** unitxt left
[07:37] *** unitxt joined
[07:51] <JDlugosz> PIR?

[07:52] <Tene> Parrot assembly.

[07:53] <JDlugosz> That's what I thought.  Just misparsed your grammar there.  Thought it was for Rakudo and for something else.

[07:54] <JDlugosz> So what do you think of F-Bounded Polymorphism?  Imagine getting that to interoperate with any lesser language!

[07:54] *** ejs1 left
[07:54] <Tene> use Foo:lang<parrot>;

[07:55] <JDlugosz> I mean, how can Java for example use a class that doesn't follow it's "isa" relationship rules?

[08:12] *** alexn_org left
[08:15] *** iblechbot joined
[08:20] *** unitxt left
[08:36] *** M_o_C joined
[08:38] *** ejs left
[08:53] *** alexn_org joined
[09:00] *** tulcod joined
[09:02] *** abra joined
[09:15] *** eMaX left
[09:17] *** agentzh left
[09:17] *** alexn_org left
[09:24] *** DemoFreak joined
[09:35] *** agentzh joined
[09:43] *** fridim_ left
[09:44] *** viklund left
[09:57] *** viklund joined
[09:59] *** pmurias joined
[10:10] *** sjohnson left
[10:13] *** amoc left
[10:15] *** amoc joined
[10:17] *** frew|work left
[10:21] *** M_o_C left
[10:23] *** sjohnson joined
[10:36] *** iblechbot left
[10:37] *** DanielC joined
[10:40] <DanielC> moin

[10:49] *** snarkyboojum left
[10:54] *** amoc left
[10:56] *** amoc joined
[11:06] *** kane__ joined
[11:13] *** masak joined
[11:14] <masak> happy summer salutations, #perl6 people.

[11:15] *** elmex_ joined
[11:15] * DanielC waves

[11:15] *** Whiteknight joined
[11:17] *** cotto left
[11:18] <masak> hm, it all comes down to module recognition in Rakudo.

[11:18] <masak> everything else comes after that.

[11:18] *** meppl joined
[11:18] <DanielC> What comes down to module recognition?

[11:19] <masak> DanielC: module management, and CPAN or a CPAN replacement.

[11:19] <DanielC> Rakudo doesn't support modules an packages yet?

[11:19] *** cognominal left
[11:19] <masak> DanielC: in my opinion, the discussion we're having about that is very useful, but it won't produce much code, because Rakudo doesn't implement modules as per S11 yet.

[11:19] <masak> and won't for at least a few months.

[11:19] <DanielC> :-(

[11:20] <masak> DanielC: it does support modules, but not as per S11.

[11:20] <DanielC> I was hoping for something tangible. You know.. round tuits and all.

[11:20] <masak> that's what I'd like too.

[11:20] <masak> that's why I'm thinking about what's blocking us right now.

[11:22] *** elmex_ is now known as elmex

[11:22] <masak> questions like "what's the least amount of coding that would allow us to store two modules with the same name, but with different versions? or different authors?"

[11:22] <masak> at the very least, we could write some spectests for this. that would definitely help.

[11:22] *** explorer__ joined
[11:23] <DanielC> Daniel Ruoso says that the package format is the most critical step, so perhaps it is possible to make progress there. But I'm no expert on package formats. I just suggested some improvements on S22.

[11:23] * DanielC hopes they are improvements

[11:24] <masak> I'm by no means an expert either. in what way does the package format affect the way we store modules so that Rakudo can access them?

[11:24] <DanielC> I don't know.

[11:25] <DanielC> I don't know a lot about either subject.

[11:25] <masak> the big step for Rakudo, I think, is that modules might not be able to sit directily on the disk any more.

[11:25] <masak> they might have to be stored in a database somewhere.

[11:25] <masak> that's a big change.

[11:25] <DanielC> Hmm... that doesn't sound like "the Unix way" or "the Perl way".

[11:26] <masak> indeed not.

[11:26] <masak> an alternative (perhaps) is something like URL encoding.

[11:27] <DanielC> Why can't we use regular directories to organize modules?  e.g. /<auth>/<version>/Foo/Bar.pm

[11:27] <masak> DanielC: because modules can have arbitrary Unicode names.

[11:27] <masak> and not all file systems appreciate that.

[11:28] *** unitxt joined
[11:28] <DanielC> That doesn't sound like a big problem. Just use some standard encoding like the URL encoding you said.

[11:28] <masak> yes.

[11:28] <masak> but it's exactly these small problems that I think we should start with.

[11:29] <masak> they are concrete, they can be solved today, even before Rakudo gets there, and they can be made to work and show us what the next set of real problems are.

[11:29] <DanielC> Most of the time, for most practical purposes, the module names are going to be ascii anyways.

[11:29] <masak> sometimes amrchair discussions about frameworks bore me.

[11:29] <DanielC> And even when they are not, lots of programming languages have tools for url encoding/decoding so the data would remain very accessible.

[11:30] <masak> yes.

[11:30] <masak> if it's at all practical not to involve a database, I think we should try to stay in the file system.

[11:30] <DanielC> yeah

[11:31] <DanielC> And I agree with picking small concrete problems we can start with today.

[11:31] <pochi> does that mean I can't create a module 動物.pm and copy it into the module path without URL encoding it first?

[11:31] <DanielC> pochi: What if the filesystem doesn't support unicode?

[11:32] <pochi> what happens if one tries to copy a unicode named file to a non-unicode filesystem anyway?

[11:32] <DanielC> I dunno

[11:32] <DanielC> Do we know of any non-unicode filesystem? Can we test?

[11:33] <masak> pochi: either the encoding would be uniform on all systems, and then you couldn't. or it'd be a matter of local configuration (when building Rakudo, say), and then you could if your system was configured like that.

[11:33] <masak> DanielC: old DOS systems ought to be non-unicode.

[11:33] <DanielC> ext3 seems to have no problem with Unicode. I just created a file called 動物.pm.

[11:33] <pochi> masak: the latter sounds good

[11:34] <masak> pochi: yes, but it has the drawback that you shouldn't indiscriminately copy Perl 6 libraries from one system to another.

[11:34] <masak> they might be configured differently.

[11:34] <masak> perhaps not such a large drawback, but still.

[11:34] <DanielC> masak: Or Rakudo could try both paths...  but then again, that could lead two conflicts (same module stored twice, once as unicode and once as URL encode).

[11:35] <masak> DanielC: that sounds like a hack due to lack of planning. :)

[11:35] <masak> I wouldn't do that if I didn't really have to.

[11:36] <DanielC> yeah... it seems to cause a lot of problems.

[11:38] <DanielC> Btw, I can think of another reason not to copy Perl 6 libraries around. The first computer could have the library stored as parrot bytecode and the second computer could have an implementation of Perl 6 that doesn't understand Parrot.

[11:38] <masak> indeed.

[11:38] <masak> std: use Dog:ver(Any):auth(Any);

[11:38] <p6eval> std 26976: OUTPUT«ok 00:02 35m␤»

[11:38] <masak> rakudo: use Dog:ver(Any):auth(Any);

[11:39] <p6eval> rakudo 764684: OUTPUT«Can't find ./Dog in @*INC␤in Main (src/gen_setting.pm:438)␤»

[11:39] <masak> hm, but it parses? interesting...

[11:39] <masak> maybe it wouldn't be too far-fetched to fork Rakudo on github and try some stuff for realz.

[11:39] <pochi> shouldn't "Any" be "*"?

[11:39] <masak> now _that_ thought excites me!

[11:39] <masak> pochi: I got that example from S11.

[11:40] <masak> rakudo: use Dog:<1.2.1>;

[11:40] <p6eval> rakudo 764684: OUTPUT«Can't find ./Dog in @*INC␤in Main (src/gen_setting.pm:438)␤»

[11:41] <masak> yep, Rakudo already parses the colonpairs after the module name.

[11:41] <masak> Rakudo++

[11:45] <masak> phenny: tell mberends I'm toying with the idea of creating a Rakudo branch and adding the ability to load versioned/authored modules. it would lead to questions about module semantics, directory structure, perhaps distribution. what do you think?

[11:45] <phenny> masak: I'll pass that on when mberends is around.

[11:45] *** M_o_C joined
[11:47] *** huma left
[11:55] *** lichtkind joined
[11:55] *** payload left
[11:59] *** viklund left
[12:02] <jnthn> hi all

[12:03] <masak> jnthn: o/

[12:04] <jnthn> hej masak :-)

[12:06] <jnthn> masak: Happy to see that you're interested in working on getting something solid together on versioned etc libraries. :-)

[12:06] <masak> I am.

[12:06] <masak> jnthn: is there a policy on branching of Rakudo?

[12:07] <jnthn> Branches don't affect anyone who isn't explicitly interested in playing with the branch.

[12:07] <jnthn> So just go ahead.

[12:07] * masak just goes ahead

[12:09] <lichtkind> hello

[12:10] <lichtkind> is syntax infix:{+} { ... } legal

[12:10] <masak> lichtkind: I wouldn't think so.

[12:10] <DanielC> there is a syntax that is *similar*, I just need to remember what it is...

[12:10] <masak> lichtkind: the <+> form autoquotes, and that corresponds to {'+'}

[12:11] <lichtkind> so you have to use masak true thanks

[12:11] <DanielC> masak: Is infix:<+> the same thing as infix:{'+'} ?

[12:11] <masak> DanielC: if the latter is legal, yes.

[12:11] <DanielC> and they mean the same...

[12:12] * DanielC can't imagine what else it could mean, but prefers to ask.

[12:12] <masak> well, that's what 'the same thing' implies, that they mean the same. :)

[12:12] <lichtkind> no you got it entiely i understood now

[12:12] <DanielC> masak: I missed the "if" in your reply, so I parsed your sentence wrong :)

[12:13] <masak> phenny: tell mberends http://github.com/rakudo/rakudo/tree/ver-auth-modules -- jnthn++ gave the go-ahead. :)

[12:13] <phenny> masak: I'll pass that on when mberends is around.

[12:13] <lichtkind> is prelude and STD.pm the same thing?

[12:13] <masak> lichtkind: no.

[12:13] <masak> lichtkind: prelude is a set of 'core' subs and methods written in Perl 6.

[12:14] <masak> lichtkind: STD.pm is a Perl 6 grammar.

[12:14] * masak jacks out of the Intertubes for a while

[12:14] *** M_o_C left
[12:14] *** masak left
[12:14] <lichtkind> masak: that i read but i cant imagine where one thing ends and other begins

[12:14] *** M_o_C joined
[12:16] *** |MoC| joined
[12:16] *** M_o_C left
[12:18] *** Whiteknight left
[12:18] <DanielC> masak: On the topic of versions and file systems... do you know of ':' and '.' are valid file name character in most file-systems? The package Foo::Bar version 1.2 could be stored literally as 'Foo::Bar-v1.2.pm'

[12:19] <DanielC> masak: Earlier I said /<auth>/<version>/Foo/Bar.pm but clearly that doesn't make any sense. Two unrelated modules with the same version number would end up together.

[12:20] *** payload joined
[12:21] <jnthn> DanielC: No, they're not.

[12:22] <jnthn> DanielC: I don't know anywhere . doesn't work, but : is a problem.

[12:22] <DanielC> Alternatively: /<auth>/Foo/Bar-<version>.pm

[12:22] <DanielC> Avoids the ::

[12:22] <jnthn> (On Windows at least.)

[12:22] <DanielC> (and still has version after "Bar")

[12:22] <jnthn> DanielC: I don't know. I'm not sure if auth, name and version are the only meta-data we'll ever care about.

[12:23] <jnthn> So something more extensible is probably wise.

[12:24] *** mikehh left
[12:24] <DanielC> jnthn: I can easily imagine us caring about the platform (Perl 6 vs Parrot).

[12:25] <DanielC> And given that Perl can even use stuff written in other languages, even today ("use ruby"), we might even have true Ruby modules stored.

[12:27] <DanielC> jnthn: I'm having trouble thinking of something extensible that doesn't make the modules inaccessible (e.g. storing them in a database).

[12:28] <DanielC> inaccessible = difficult to access to third-party tools, in particular Unix commands like 'find'.

[12:29] <jnthn> Yes because no way can we build the tools we'd need!

[12:29] <jnthn> :-S

[12:29] <jnthn> FWIW, as a Windows user, I don't really care about accessibility via Unix commands.

[12:29] <DanielC> jnthn: I was thinking in terms of "the Unix way" (plain text, etc)

[12:30] <DanielC> One thing I like about Unix/Linux is that the system is generally accessible. I can hack it.

[12:30] <DanielC> No registry. Config files are plain text. Things like that.

[12:30] <jnthn> You can still do something database-y and keep it generally accessible/hackable.

[12:31] <jnthn> Think Sqllite.

[12:31] <jnthn> *Sqlite

[12:31] <jnthn> Already lots of languages with bindings to it.

[12:31] <DanielC> If Rakudo used a database, sqlite would be my top choice.

[12:31] <DanielC> It is the most accessible of the databases I know.

[12:32] <jnthn> From the (limited) amount of thought I've givne this, it's felt to me that something database-ish is the way to go, and I'd much rather see us use something existing like sqlite than create yet another third party format.

[12:33] <DanielC> absolutely (reusing sqlite).

[12:34] <DanielC> Last thing this world needs is a vanity database just for Perl.

[12:35] <DanielC> jnthn: If we use sqlite, then sqlite support must be part of the standard library. You can't install with Sqlite support module without sqlite support...

[12:37] <jnthn> DanielC: Aye, though it'd need to be part of Rakudo's rather than Perl 6's.

[12:37] <DanielC> Is it ok for Rakudo to have a standard library that differs from Perl 6?

[12:38] <jnthn> I figure all implementations will have some extra little bits specific to their needs.

[12:39] <jnthn> And it depends how you define standard library too.

[12:39] <jnthn> They'd still have a consistent setting, and I guess that's what really matters.

[12:40] <DanielC> I guess that the Rakudo distribution could come with DBI and DBD::SQlite by default...

[12:41] <jnthn> Dunno, this is details...

[12:41] <jnthn> I'm mostly hoping that @other will fill in the gaps on this stuff.

[12:41] <DanielC> k

[12:41] <jnthn> So I don't have to think about it too much. :-)

[12:41] <DanielC> :-)

[12:42] <DanielC> The alternative to including DBD::SQlite is for Rakudo to come with its own, separate support for SQlite, but I can't imagine how that could possibly be useful.

[12:43] <pmurias> is there anything interesting happening on August 6th (other than the trainings)?

[12:44] <DanielC> jnthn: Here is one thing I like about the SQlite idea: It resolves the unicode problem we were discussing earlier (did you see the discussion).

[12:44] <jnthn> DanielC: Glanced over it.

[12:44] <DanielC> If you use SQlite you don't have to worry about what characters the filesystem supports.

[12:44] <jnthn> pmurias: Is that the day after YAPC::EU?

[12:44] <jnthn> pmurias: If so - potentially a Parrot Developer Summit also.

[12:45] <DanielC> masak: Have you followed this discussion about SQlite? What do you think?

[12:46] <jnthn> pmurias: Beyond that not aware of anything.

[12:46] <lichtkind> 	macro summe { 3 + 4 } does it return an AST containing 7 or 3+4 ?

[12:46] *** amoc left
[12:46] <lichtkind> i mean i i dont quote will it executed?

[12:47] <DanielC> lichtkind: I don't know, but if the compiler is smart, I would hope that it would just use 7.

[12:47] *** sri_kraih joined
[12:47] <lichtkind> DanielC: thanks but i dont mean optimasition but whot syn says

[12:48] <DanielC> Ok. I don't know what the syn says.

[12:49] *** ZuLuuuuuu joined
[12:50] *** mberends joined
[12:50] <DanielC> o/ ZuLuuuuuu  mberends

[12:51] * mberends waves: wow, lurking on the backlog is interesting, as always :)

[12:51] <phenny> mberends: 11:45Z <masak> tell mberends I'm toying with the idea of creating a Rakudo branch and adding the ability to load versioned/authored modules. it would lead to questions about module semantics, directory structure, perhaps distribution. what do you think?

[12:51] <phenny> mberends: 12:13Z <masak> tell mberends http://github.com/rakudo/rakudo/tree/ver-auth-modules -- jnthn++ gave the go-ahead. :)

[12:51] <mberends> wahey!

[12:53] *** Chillance joined
[12:53] <pmurias> jnthn: yes, that's the day after YAPC::EU

[12:54] <pmurias> jnthn: is the Parrot Developer Summit open to all or only parrot developers?

[12:55] <ZuLuuuuuu> hello DanielC

[12:55] *** sri_kraih_ left
[12:55] <mberends> before opting for anything sql-flavoured to manage module metadata, be aware that sql language comptatibility slows the inner data access routines by an order of magnitude. Google avoids SQL and XML for anything performance sensitive, and we definitely need to be that here.

[12:57] <jnthn> pmurias: I'm not 100% sure it will actually happen yet, I didn't yet book my flights etc. If it does, I think it will be mostly for discussing Parrot-level issues and planning Parrot dev generally rather than just stuff specific to Perl 6. I doubt it'd be a secretive-cabal-ish style meeting though...if you're interested in Parrot and want to come I'd not see a probem with that.

[12:58] <jnthn> And of course, Parrot issues relavent to Rakudo will certainly be some of what is discussed.

[12:59] <DanielC> mberends: I thought Google used MySQL.

[13:00] <mberends> DanielC: your're joking, right?

[13:00] <DanielC> No, I'm not.

[13:00] <DanielC> However, I might be wrong.

[13:01] <DanielC> But hasn't Google even submitted patches to MySQL?

[13:01] <mberends> If Google could use MySQL, they'd have bought the company. But Sun did, instead.

[13:01] <DanielC> http://www.mysql.com/customers/view/?id=555

[13:01] <DanielC> They are listed as a customer.

[13:03] <DanielC> http://www.informationweek.com/news/internet/showArticle.jhtml?articleID=199201237

[13:03] <mberends> DanielC: interesting, I shall dig into what they use it for.

[13:04] *** amoc joined
[13:05] <mberends> my concern if from another angle, several database engines were superbly fast until they got an SQL language interface on top, that slowed things down considerably. The reason, general purpose accessibility, is not warranted for Rakudo.

[13:06] <DanielC> jnthn: Were you thinking of storing the actual module in SQL or just some reference to a file on disk? (e.g. the name of the file on disk could be a hash sum of its metadata).

[13:07] <jnthn> DanielC: Just meta-data.

[13:07] <DanielC> ok

[13:08] <DanielC> I think that's the most reasonable.

[13:08] <mberends> DanielC: the SQLite alternative is much faster and more appropriate, but I'm still doubtful about making Rakudo depend on such a complex subsystem

[13:08] <jnthn> The other thing to figure into all of this is pre-compilation.

[13:08] <jnthn> That is, for efficiency the module installation process should probably compile modules to PBC.

[13:09] <DanielC> mberends: I understand. masak expressed similar concerns, and so did I. But jnthn makes good points.

[13:09] <jnthn> well, *an* other, not *the* other.

[13:09] <DanielC> PBC = Parrot Byte-Code   right?

[13:09] <jnthn> DanielC: Yes.

[13:09] <jnthn> Not a big deal, just something to keep in mind.

[13:10] <pmichaud> good morning, #perl6

[13:10] <lambdabot> pmichaud: You have 1 new message. '/msg lambdabot @messages' to read it.

[13:10] <pmichaud> @messages

[13:10] <lambdabot> DanielC said 11h 7s ago: The problem with the k-nucleotide benchmark is definitely the ++. If you replace for loop by a "loop ($i=0; ...; $i+=1)" and change the "%table{...}++" to "+=1" the program

[13:10] <lambdabot> runs 3 times faster.

[13:10] <DanielC> yet another thing to think about is that the user must be able to specify multiple sqlite databases (so the can store modules in his home directory)

[13:10] <jnthn> mberends, DanielC: I'm not so much attached to Sqlite, more that we don't re-invent a wheel we don't have to.

[13:11] <pmichaud> (sqllite versus filesystem)

[13:11] <mberends> DanielC: that would be no problem

[13:11] <DanielC> jnthn: ok

[13:11] <pmichaud> Last year at YAPC::NA I spent an hour or so talking to a representative from $large_financial_company about module access in Perl 6 (more)

[13:11] <pmichaud> In his company, they absolutely need the capability to have versioned modules

[13:12] <pmichaud> Which was why he cornered me for an hour to discuss it

[13:12] <pmichaud> One of the points he wanted to make was that the filesystem was almost certainly not fast enough to be able to handle it

[13:12] <mberends> jnthn: a Berkeley DB level of database (essentially a disk based hash) would perform far more efficiently

[13:12] <pmichaud> at least, the filesystem alone wasn't enough to do it.

[13:13] <mberends> but the WinFS disaster should have lessons for us

[13:13] <jnthn> mberends: *nod*

[13:13] <pmichaud> This wasn't speculation on his part, it was actual experience.  In fact, they came up with their own set of module management for Perl 5 (basically abusing @INC and all sorts of other things) because the facilities Perl 5 and CPAN provide weren't nearly capable of scaling to handle it.

[13:14] <mberends> pmichaud: *very* interesting

[13:14] <DanielC> pmichaud: Interesting. But if an SQlite database told you the direct path of the file you need, then it would be fast enough, right?

[13:14] <pmichaud> DanielC: Likely, yes.

[13:14] <DanielC> pmichaud: Do you still have his contact email? It sounds like he could contribute much to this discussion.

[13:14] <mberends> DanielC: SQLite itself will internally be slower that we are likely to expect

[13:16] *** cognominal joined
[13:16] <DanielC> mberends: Do you know anything better?

[13:16] <mberends> our own future custom solution ;)

[13:16] <DanielC> :)

[13:16] <pmichaud> DanielC: Yes, I could likely contact him; OTOH, he and his company wasn't much interested in being publicly known for working on Perl

[13:17] <DanielC> pmichaud: Sure, but he can join IRC, we won't know his name or his company.

[13:18] <pmichaud> I might let him know that discussions are taking place and invite him to monitor

[13:18] <pmichaud> This person was sufficiently high level that I doubt he'd be able to spend much time hanging around on IRC.

[13:18] <DanielC> pmichaud: Maybe he can delegate to an underling who knows what they need.

[13:18] <pmichaud> Good point.

[13:19] *** cotto joined
[13:20] *** amoc left
[13:21] *** amoc joined
[13:21] <mberends> just knowing that the @INC and filesystem solution *can* be improved successfully, is a very important fact. It sets standard Perl 5 up as a target for us to outperform.

[13:23] <mberends> btw, I think that burying our heads in the sand about performance is not going to last much longer, so optimizing is no longer premature in whatever we add to Rakudo.

[13:23] *** wolverian joined
[13:23] <pmichaud> mberends: oh, we're already on it.

[13:23] <mberends> :) I see that too.

[13:24] <pmichaud> I suspect that by the end of the day Rakudo performance will have doubled over what it was this time last week.

[13:24] <pmichaud> (as measured by "time to execute spectests")

[13:25] <jnthn> Wow.

[13:25] <mberends> pmichaud++: I know you care a lot about performance.

[13:25] <pmichaud> and perhaps even more if jnthn+'s dispatch improvements land today :-)

[13:26] <jnthn> pmichaud: I need to find the energy to debug segfaults.

[13:26] <pmichaud> jnthn: no pressure on this end -- was just a comment :-)

[13:27] <jnthn> pmichaud: I'm suffering a little with some kind of cold-ish virus that seems to be sapping a lot of my energy at the moment. :-|

[13:27] * jnthn has slept for 10 hours two nights running...

[13:28] <pmichaud> jnthn: ouch, sorry to hear that.  Hope things improve very soon.

[13:28] <mberends> jnthn: get well soon, what else can we say?

[13:28] <jnthn> Anyway, I'm very much wanting to land the dispatcher soon. :-)

[13:28] <jnthn> Excluding some exit-time segfaults, I'm down to two test files with issues (one easy, one hard).

[13:29] <jnthn> So it's *close*. :-)

[13:30] <jnthn> (If anyone is curious to know what's taking so long, I've got a 1500+ line diff against head.)

[13:30] <jnthn> (Which should give an idea of the order of magnitude of the refactor.)

[13:30] <lichtkind> is there any difference between 	macro summe { '3 + 4' } and 	macro summe { 3 + 4 } ?

[13:33] <mberends> lichtkind: surely just the same as if you placed the macro contents in the code calling the macro, so the first could not be used as an array subscript for example, but the second could.

[13:33] <bloonix> rakudo: say $*OUT "foo"

[13:33] <p6eval> rakudo 764684: OUTPUT«Statement not terminated properly at line 2, near "\"foo\""␤in Main (src/gen_setting.pm:0)␤»

[13:34] <bloonix> rakudo: say $*ERR "foo"

[13:34] <p6eval> rakudo 764684: OUTPUT«Statement not terminated properly at line 2, near "\"foo\""␤in Main (src/gen_setting.pm:0)␤»

[13:34] <bloonix> is the syntax wrong?

[13:34] <lichtkind> mberends: so basically would first return the compiled string and seconf 7?

[13:35] <mberends> bloonix: yes, you're using Perl 5 style

[13:35] <mberends> lichtkind: yes, I think so

[13:35] <lichtkind> mberends: but your not shure ? :)

[13:37] <mberends> lichtkind: I mainly understand what I use in Rakudo, and macros have not arrived yet. I haven't read the macro sysnopis recently, that's what I mean.

[13:37] <lichtkind> mberends: i do read but have problems anyway :)

[13:37] <DanielC> mberends: SQLite may not be fast, but the database table shouldn't be very large. I can't imagine someone having 10,000 modules installed.

[13:38] <lichtkind> mberends: thanks

[13:39] <bloonix> rakudo: $*OUT.say("foo")

[13:39] <p6eval> rakudo 764684: OUTPUT«foo␤»

[13:39] <mberends> DanielC: if we specify what goes into and come out of the database, SQL is not part of the requirement

[13:39] <DanielC> mberends: ok...

[13:40] <DanielC> mberends: So you want to use a custom non-SQL database?

[13:41] <mberends> DanielC: not absolutely, but they are likely to be more efficient

[13:42] <mberends> and I'm desperate to find the most efficient solution for the computer here, not for the Rakudo developer ;)

[13:43] <DanielC> The upshot is that it may be hard to write your own script to read the "Rakudo Registry".

[13:43] <mberends> we can discuss abstract designs in terms of tables, columns, indexes and so on.

[13:44] <mberends> DanielC: yes. it will be enough for Rakudo to be the interface to this "Registry"

[13:45] <mberends> If anything else can get access, it will be nice but not essential.

[13:45] <DanielC> ok

[13:47] <pmichaud> DanielC: fwiw, the person I was talking with did have thousands of modules installed.

[13:48] <pmichaud> maybe not 10,000, but definitely at least 4-digits.

[13:48] <DanielC> pimchaud: Ok. And since Perl 6 will also have module versions, the same customer might have the full 10,000 in Perl 6.

[13:48] <mberends> as masak++ wrote a few hours ago, the full implementation of the 'use' command is the problem in a nutshell. Installers, repositories etc are just supporting infrastructure that is allowed to be less efficient in execution that the 'use' command.

[13:49] <DanielC> I wonder how quickly SQLite can go through 10,000 records.

[13:50] <mberends> we'll build some test cases. performance testing is essential here.

[13:55] <mberends> it will help to visualize it at the lowest possible level: how many file I/O's must the perl6 process do for a 'use' command. CPU and memory are ample, filesystems are huge, but drives are slow.

[13:56] <DanielC> yes

[14:01] <pmichaud> fwiw, I should point out that there are three primary reasons why I've been saying that Rakudo wouldn't be attempting module versions until the August time frame

[14:02] <pmichaud> (1) in terms of "where to put modules" (in the filesystem), that really depends somewhat on being able to work with an installed Parrot, which thus far Rakudo hasn't been able to do.  I expect that to change this week.

[14:02] <lichtkind> mberends: but gerrally speaking macros are evaluated at compiletime and result is returned as an AST?

[14:03] <lichtkind> or has anybody else here clues about p6 macros?

[14:03] <pmichaud> More to the point, Parrot imposes its own ideas of where loadable modules should go, and so we (on the Rakudo side) have to keep those considerations in mind.  And Parrot hasn't fully defined its API for that yet.

[14:03] <lichtkind> mberends: s/gerally/generally/

[14:04] <pmichaud> (2) The specification itself needs more brainstorming about what is/is not required.  That's been happening this week on #perl6 and the mailing list, which is good.

[14:04] <mberends> lichtkind: I'm going to brush up my macro-fu in the Synopses to answer that ;)

[14:05] <lichtkind> mberends: thanks

[14:05] *** skids joined
[14:06] <mberends> buubot: spack macro

[14:06] <buubot> mberends: S02-bits.pod:16 S03-operators.pod:8 S04-control.pod:5 S05-regex.pod:8 S06-routines.pod:36 S09-data.pod:3 S11-modules.pod:6 S12-objects.pod:7 S29-functions.pod:2

[14:06] <pmichaud> (3) I hadn't envisioned that managing versioned modules was going to be significant for anyone before August.  I can understand that module packaging and distribution might be important, but being able to handle multiple versioned modules didn't seem like it was a likely high priority (Perl 5 lives without it, for example)

[14:07] *** sri_kraih left
[14:08] <mberends> pmichaud: we'd better get with the (1) program before bikeshedding then

[14:09] <pmichaud> mberends: well, I'm fine if we start exploring things.

[14:09] <DanielC> I'm surprised that Parrot puts restrictions on where a module can go.

[14:09] <pmichaud> DanielC: I was surprised about that too.

[14:09] <pmichaud> DanielC: "restrictions" is perhaps too strong a word -- "expectations" might be better.

[14:10] <pmichaud> i.e., parrot expects languages to store their modules in a subdirectory of the parrot tree

[14:10] <pmichaud> (which I think probably won't be what ultimately happens)

[14:11] <pmichaud> I think I've planted the seed/idea that each individual compiler should be responsible for its module management, with a common API to handle cross-language module loading, but it's not official yet.

[14:11] <DanielC> pmichaud: Any restrictions on the file name? Can the module Foo::Bar be stored in something like /parrot/perl6/1ffae822021bc

[14:12] <pmichaud> DanielC: that's still to be determined, a bit

[14:12] <pmichaud> from a personal perspective, I find hash keys to be lousy filenames, though.

[14:12] <pmichaud> I'd still like to be able to figure out what a file is from looking at a directory listing.

[14:13] <DanielC> I can't say I love them. I'm just thinking of the DB idea.

[14:13] <pmichaud> a DB can still map to a human-understandable name.

[14:13] <DanielC> true

[14:13] <mberends> the middle road is something like how Windows maps long file names to 8.3

[14:14] <mberends> not everything from Redmond is bad

[14:14] <pmichaud> anyway, my personal feeling is that there ought to be several achievable middle steps between "what we have today" and "full S11 support".

[14:14] <DanielC> pmichaud: If the module name is Foo::動物.pm  we an URL-encode the entire string, append metadata an make that the fie name.

[14:15] <DanielC> $filename = urlencode("Foo::動物.pm") ~ "-$version-$auth"

[14:15] <pmichaud> well, I'd hope there at least some level of directory hierarchy there

[14:15] <pmichaud> also probably need to url encode $version and $auth, too

[14:16] <pmichaud> and $auth is really long to be putting in a filename, not sure we need that

[14:16] <DanielC> Can two modules have the name but different authority?

[14:16] <pmichaud> of course.

[14:16] <pmichaud> But just because I don't like hashes as filenames doesn't mean they should be forbidden at all

[14:17] *** _Chillance_ joined
[14:17] <mberends> tokens for $version and $auth would be fine, database mapped

[14:17] <pmichaud> using Web::Foo-1ffae822021bc   would be fine for me

[14:17] <pmichaud> I can look at that name and say "oh, that's Web::Foo"

[14:17] <DanielC> $filename = urlencode("$module-$version") ~ ShortHash($auth)

[14:17] <DanielC> yeah

[14:18] <DanielC> Web::Foo-v1.2.0-1ffae822021bc looks good.

[14:18] <pmichaud> 11:19 <masak> DanielC: in my opinion, the discussion we're having about that is very useful, but it won't produce much code, because Rakudo doesn't implement modules as per  S11 yet.

[14:18] <pmichaud> I disagree somewhat with masak++ here, fwiw.

[14:19] <pmichaud> I think we can start producing code before Rakudo has finished S11

[14:19] <pmichaud> indeed, I think the two have to be designed together

[14:19] <DanielC> :-)

[14:19] <pmichaud> or at least take both components into consideration

[14:20] <pmichaud> thus my comment about "achievable middle steps" -- that's what we should be aiming for.  I'd be very happy to see us start with a completely filesystem-based module loader for a while, until some of the other parameters become known.

[14:21] <DanielC> ok

[14:21] <mberends> rakudo has a ver-auth-modules branch to try things out

[14:21] <pmichaud> I saw that, excellent.

[14:22] <pmichaud> At the moment I'd like us to just come up with a consensus opinion about module location, and perhaps a simple module-to-filename mapping.

[14:22] <pmichaud> (it can be rakudo specific)

[14:22] <DanielC> $filename = urlencode("$module-$version"); for (@all_other_metadata) { $filename = ShortHash($_) }   <-- this is automatically extensible.

[14:23] <DanielC> s/$filename = ShortHash($_)/$filename ~= ShortHash($_)/

[14:23] * DanielC is assuming that ~= exists

[14:23] <pmichaud> my feeling (and I could be wrong about this)  is that the demarcation between "what all Perl 6-compliant implementations must do" and "what is reserved to the implementation" is a very fuzzy concept at the moment

[14:24] <pmichaud> as far as module management is concerned

[14:24] <mberends> nod, because it's not specified anyway

[14:25] <pmichaud> I think I'm saying that it's not specified because we don't want to commit ourselves too soon to a particular view

[14:25] <DanielC> I like the " Web::Foo-1.2-1ffae21bc" idea. It is transparent, and it doesn't prevent us from adding a database layer later if that's faster than using the file system.

[14:26] <pmichaud> Also, I noticed there was some discussion yesterday about how one might specify a module to a command-line installer.

[14:26] <pmichaud> I think there might be something to be said to using the same syntax that is part of a 'use' statement :-)

[14:26] <pochi> could it be a hybrid system? look in db first, if not there then search the fs?

[14:26] <mberends> pochi: you could argue equally for the reverse order

[14:27] <pmichaud> could it be a hybrid system?  Sure, I can imagine that.

[14:27] <DanielC> pochi/mberends: That might miss the performance benefit of using a DB.

[14:27] <mberends> in fact the DB will always know everything, but it may not win on performance

[14:28] <pmichaud> "cpan install Module::Foo:ver<1.2.*>:auth<cpan:JRANDOM>"

[14:28] <pochi> it would add the module it found on the fs to the db, so that the next time the module is use()'d it would find it in the db.

[14:28] <pmichaud> pochi: that assumes write permission to the db

[14:28] <DanielC> pmichaud: What would that do? Install *all/any* modules that match 1.2.* ?

[14:29] <pmichaud> DanielC: I would think it would use the same criteria as a use statement.

[14:29] <pmichaud> "cpan install Module::Foo"   # give me latest / most appropriate version of Foo

[14:29] <pmichaud> "cpan install Module::Foo:auth<cpan:JRANDOM"   # give me latest version of Foo coming from cpan:JRANDOM

[14:30] <mberends> DanielC: therefore the latest 1.2.*

[14:30] <DanielC> Sounds good.

[14:30] <pmichaud> in other words, we already have a syntax for identifying a module, we ought to (re)use it

[14:30] <DanielC> Sounds very good, actually. Very useful.

[14:31] <DanielC> "give me the latest version of the branch that I know works with my program"

[14:31] <pmichaud> furthermore, that syntax is nicely extensible.  :-)

[14:31] <DanielC> yes

[14:32] <mberends> I like the idea of initially coding what works without a database, and then adding the lightest possible database only when there's a proven need.

[14:33] <DanielC> +1

[14:33] *** Chillance left
[14:34] <pmichaud> there was also some discussion about whether modules should re-use the existing CPAN infrastructure or make a new one

[14:34] <pmichaud> I don't think it should be an either-or choice

[14:34] <pmichaud> I think whatever is built should be able to interface nicely with CPAN, but not limit us to that.

[14:36] <pmichaud> (that statement, of course, is meant as a "in the long run" sort of thing, not necessarily what we do in the first steps)

[14:36] *** iblechbot joined
[14:37] <mberends> the idea that the existing CPAN is Perl's killer app is so important, it would be folly to ignore. And yes, decentralized repositories are the new archive network.

[14:39] <pmichaud> and there's more than one way to decentralize :-)

[14:40] <pmichaud> afk for a bit

[14:41] <lichtkind> mberends: true

[14:41] <lichtkind> mberends: did youz check s05?

[14:42] <mberends> as obra_++ wrote on May-28, we are welcome to try to distribute our Perl 6 projects via CPAN, and download/install with our proto tool

[14:42] <DanielC> mberends: I hear that Berkeley DB is faster than SQLite but it does not support SQL.

[14:43] <mberends> lichtkind: I'm reading S06 first, it has more relevant info

[14:43] <skids> Has anyone attempted to spec a robust replacement for -w?  If it's done soon enough module authors might actually standardize on one warning flag set.  And we could add a flag for "this is inefficient" so when people complain about performance, the fist question is "what does it say when you turn efficiency warnings on?"

[14:43] <mberends> DanielC: that makes sense

[14:44] <DanielC> RPM uses Berkeley DB...

[14:45] *** finanalyst joined
[14:46] <DanielC> Berkeley DB is now owned by Oracle, but it seems to have a compatible license (Sleepycat License).

[14:46] <skids> ]\

[14:46] <mberends> Perl 5 tied hashes also fitted Berkeley DB very nicely

[14:46] *** fridim_ joined
[14:47] <DanielC> BerKeley DB website: "Extreme performance—eliminates the overhead of SQL and interprocess communication"

[14:48] <mberends> there are also versions with more open licensing

[14:48] <DanielC> Ok. I didn't know that.

[14:48] * skids scolds cat

[14:48] <s1n> @seen masak

[14:48] <lambdabot> I saw masak leaving #perl6 2h 34m 6s ago, and .

[14:49] <pmurias> having the storage backend pluggable could be a good idea

[14:50] *** pmurias left
[14:50] *** ZuLuuuuuu left
[14:51] *** icwiener joined
[14:54] *** LadyLuna1y joined
[14:58] *** shinobi_cl joined
[15:03] *** DemoFreak left
[15:03] *** _Chillance_ left
[15:03] *** Chillance joined
[15:10] *** wolverian left
[15:10] *** LadyLunacy left
[15:13] <pugs_svn> r26977 | pmichaud++ | [t/spec]:  Change rakudo fudge from 'todo' to 'skip'.

[15:20] *** nihiliad joined
[15:24] <mberends> lichtkind: S06 'Macros' distinguishes between compile time and run time calls to macros, without and with the &, but you probably found that anyway.

[15:25] <lichtkind> yes

[15:25] <lichtkind> mberends: but i dont understand consequences

[15:25] <lichtkind> you mean runtime i get 7 comtiletime 3+4 ?

[15:26] *** ab5tract joined
[15:27] <DanielC> m/[\. || \d]/  matches a dot or a digit. How do I match anything that is *NOT* a dot or a digit? In other words, what is the opposite of the preceding regex?

[15:27] *** beggars joined
[15:30] <DanielC>  m/<-[\. || \d]>/ does not seem to do it.

[15:35] <pmichaud> you don't need || inside of character enumerations

[15:35] <DanielC> k

[15:36] <pmichaud> Rakudo doesn't support \d inside of character enumerations yet

[15:36] <pmichaud> you can always do

[15:36] <DanielC> 0..9 ok?

[15:36] <pmichaud> <!digit> <-[.]>

[15:36] <pmichaud> slightly faster might be   [ \D && <-[.]> ]

[15:37] <DanielC> I don't understand the first one. To me it looks like a match for a non-digit followed by a match for a non-dot.

[15:37] <pmichaud> the ! makes it zero-width

[15:37] <pmichaud> <!digit> means "don't match a digit at this point", but doesn't consume anything.

[15:38] <pmichaud> it's basically the same as    <!before \d>

[15:38] <DanielC> k

[15:38] <pmichaud> std:  say pi()

[15:38] <p6eval> std 26977: OUTPUT«Undeclared routine:␤   pi used at 1 ␤ok 00:02 35m␤»

[15:39] <DanielC> The firs one works, but /[\D && <-[.]>]/ gives an error: Statement not terminated properly

[15:39] <pmichaud> maybe just one &

[15:39] <DanielC> yeah

[15:39] <DanielC> that works, thanks

[15:39] <lichtkind> mberends: do you think that effect the return value of the macro if its called runtime oder compiletime?

[15:40] <mberends> lichtkind: no. (still writing another reply)

[15:41] <lichtkind> mberends: wont stress you take your time

[15:41] *** shinobi_cl left
[15:43] <mberends>  just the generated code. calling a macro at compile time should inline the definition at the point of call. preceding the macro name with & must cause the compiler to generate a runtime call to the code defined in the macro, thus treating it as a subroutine.

[15:44] <DanielC> my $filename = urlencode($module);

[15:44] <DanielC> for %metadata.sort.kv -> $k,$v {

[15:44] <DanielC> 	$v = $v ~~ m/[\D & <-[.]>]/ ?? $v !! md5($v).substr(0,5);;

[15:44] <DanielC> 	$filename ~= "-$k:$v";

[15:44] <DanielC> }

[15:44] <mberends> lichtkind: s/  just the generated code. //

[15:45] <DanielC> Extensible naming scheme for modules.

[15:45] <DanielC> Ex: Foo::Bar-auth:92de1-ver:1.2.0

[15:47] <lichtkind> mberends: so macro s {3+4} say 2 * s(); expands to say 2 * {3+4 }

[15:47] <mberends> DanielC: not bad

[15:47] <DanielC> :)

[15:48] <pmichaud> ...assuming that all Perl 6 implementations have a md5() builtin :-|

[15:49] <pmichaud> and that 5 chars of the md5 hash is sufficient to avoid a collision

[15:49] <mberends> lichtkind: it may expand to 2 * ( 3+4 ), because the { } are just macro constructing

[15:49] <DanielC> pmichaud: I thought the naming scheme only had to be implementation-specific. As long as *Rakudo* has any reasonable hash function...

[15:51] <mberends> DanielC: we may choose a more compact hash, and yes, implementations do not have to be interoperable.

[15:51] <DanielC> pmichaud: 5 hex chars => You can expect a collision after ~1e15 distinct values.

[15:51] <pmichaud> DanielC: good counterpoint, thanks.

[15:51] <lichtkind> mberends: true but to be hygeninical clean which syn states macros are by default it has to be in its own namespace ie block

[15:52] <pmichaud> DanielC: (~1e15)  where did you come up with that figure?

[15:52] <DanielC> sqrt(16^5)  => birthday paradox

[15:52] <DanielC> IIRC

[15:52] <pmichaud> that assumes md5 keys are evenly distributed in the first 5 hex digits, though.

[15:53] <DanielC> Yes, and they should be, to a good approximation.

[15:53] <pmichaud> why is that?

[15:53] <DanielC> because md5 was designed to be a cryptographically secure hash function.

[15:53] <DanielC> Any lack of randomness would be considered a break.

[15:53] <pmichaud> in the entire hash, yes.

[15:53] <pmichaud> not necessarily in the first five digits.

[15:54] <DanielC> If there any subset of the hash is not random, the hash is not random.

[15:55] <DanielC> If any subset of the hash is not evenly distributed as in a random function, that automatically constitutes an attack on the hash.

[15:55] <DanielC> s/attack/break/

[15:55] <pmichaud> anyway.

[15:56] <pmichaud> I'm not sure I entirely agree (and md5 has been broken), but I'll grant your point for now.

[15:56] *** alester joined
[15:56] <DanielC> md5 is broken => someone found a way to find collisions that is better than the birthday attack

[15:57] *** |MoC| left
[15:57] <DanielC> The attack is complex. Are we worried about an elaborate attack to get two modules with the same set of hashes?

[15:58] <pmichaud> I'm worried about two modules ending up with the same key.

[15:58] <DanielC> At most, it would have to be an intentional attack.

[15:59] <DanielC> It will not happen by chance, other than through the birthday paradox (ie. sqrt(16^digits))

[15:59] <pmichaud> Again, I'm not sure I agree to the first 5 characters of precision.

[15:59] <pmichaud> our keys aren't randomly distributed.

[15:59] <pmichaud> sorry, I miswrote.

[15:59] <pmichaud> our module names aren't randomly distributed.

[15:59] <DanielC> that has nothing to do with hashes.

[16:00] <DanielC> a random function will produce random output on non-random input.

[16:00] <DanielC> otherwise what's the point?

[16:00] <pmichaud> hashing isn't a "random function"

[16:00] *** M_o_C joined
[16:00] <DanielC> yes, it is

[16:00] <DanielC> That's the most central property of hashing

[16:00] <DanielC> well... pesudo-random

[16:01] <DanielC> pseudo-random = statistically equivalent to random

[16:01] <lichtkind> mberends: so macro s { '3+4' } say 2 * s(); expands to say 2 * '3+4' ; which still is 14 ?

[16:01] <pmichaud> the keys aren't "random", they just don't have any particular probability distribution

[16:01] <mberends> we only have to worry about the risk of collisions behind a specific module name.

[16:01] <pmichaud> and that can be true for the key as a whole without having to be true for all substrings of the key

[16:02] <mberends> lichtkind: yes, that's what I believe :)

[16:02] <pmichaud> anyway, I'll drop it here.

[16:02] <DanielC> If it makes you feel better, we can use sha256, but I tell you that the change is pointless unless you are worried about intentional attacks.

[16:03] <pmichaud> The purpose isn't cryptographic security, it's avoiding collisions.

[16:03] <mberends> even md5 is overkill, and most hash indexing schemes have a fallback for collisions

[16:03] <DanielC> intentional attacks = someone intentionally wanting to submit two modules with different (say) authorities that hash to the same file name.

[16:03] <pmichaud> that's my point, I'd like to see a fallback for collisions.

[16:03] <DanielC> pmichaud: avoiding collision is one of the central properties of a cryptographic hash.

[16:04] <mberends> the fallback, seldom invoked, can use the contents of the files

[16:05] <DanielC> pmichaud: The three properties of a cryptographic hash are (1) collision-resistance, (2) second pre-image resistance and (3) pre-image resistance.

[16:05] <pmichaud> (I said I'm dropping it, so that's what I'm doing.)

[16:05] <DanielC> sorry

[16:07] <mberends> DanielC: imagine a very compact hash, resulting in collisions 1% of the time. We can still design a fallback system around that and have only a 1% average inefficiency.

[16:08] <pmichaud> okay, I'll bring it up just to clarify.

[16:08] <pmichaud> I don't mind if we use md5.  I don't mind if it doesn't have a fallback to begin with.  But at present I don't have a good md5 implementation in Parrot/Rakudo, so something else might be easier.

[16:09] <pmichaud> more importantly, it may need to be fast-to-compute until there's an indexing system behind it.

[16:10] <DanielC> CRC is fast to compute... (not a cryptographic hash though)

[16:10] <mberends> good enough though, even CRC-16

[16:10] <DanielC> Are we worried about intentional attacks or just about accidental collisions?

[16:10] <mberends> the latter

[16:10] <pmichaud> I'm only worried about accidental collisions.

[16:10] <DanielC> Any hash should work then.

[16:10] <mberends> yes

[16:11] <pmichaud> there are other (better) mechanisms we can use for detecting/avoiding intentional attacks.

[16:11] <pmichaud> i.e., involving attacks on the file itself, not just its name.

[16:11] <DanielC> I first wrote MD5 because it is the simplest hash that is popular and is second-pre-image resistant.

[16:11] <pmichaud> sure, I would've chosen md5 first also, except that I know that md5 isn't immediately available in Rakudo.

[16:12] <DanielC> But CRC is cool too.

[16:12] <DanielC> I understand.

[16:12] <pmichaud> although I _think_ that parrot may be using md5 internally these days for some things, in which case we might be able to easily expose it to Rakudo.

[16:13] *** xinming_ is now known as xinming

[16:14] <pmichaud> std: undef()

[16:14] <p6eval> std 26977: OUTPUT«Undeclared routine:␤   undef used at 1 ␤ok 00:02 35m␤»

[16:16] *** mikehh joined
[16:19] <DanielC> If we are going for fast, the Adler-32 checksum is even faster than CRC, and is easy to implement.  http://en.wikipedia.org/wiki/Adler-32

[16:19] <pmichaud> I tend to vote for simple first.

[16:19] <pmichaud> i.e., it's good not to over-design before we know what we need.

[16:20] <DanielC> At first blush, Adler-32 seems like the simplest.

[16:20] <pmichaud> sounds good to me.

[16:22] <DanielC> It is a 32-bit sum. Assuming that the output is evenly distributed (and that's definitely an assumption now) it would take ~65,000 authorities to find a collision in the authority field.

[16:25] <DanielC> pmichaud: Do you think it'd be hard to change the algorithm later on?

[16:25] <pmichaud> no.

[16:26] <pmichaud> the other question is:  "how often do we think that the :auth will be the distinguishing characteristic for module names"?  In these early days, I'm thinking "not often"

[16:26] <DanielC> I just read that Adler-32 is especially week for short messages. So collisions will happen much sooner than ~65,000 modules.

[16:26] <pmichaud> we should know how we'll handle it when we get there, but I can envision baby steps where we don't worry about it.

[16:27] <DanielC> So Adler-32 may be a good choice "for now" because it's easy, but for deployment it might be better to pick something else.

[16:32] <lichtkind> mberends: but my most important issue is what is in the AST a macro returns the whole routine body or the return value?

[16:32] <mberends> DanielC: you're only hashing the authority, not the module name, so that would be 64k authorities per module. I would vote for Fletcher-16, Adler's predecessor. I used it once in C, long ago.

[16:33] <DanielC> mberends: It would be a lot less than 64k, but yes, it would be per module. In fact, it would be per module + version.

[16:34] <mberends> lichtkind: I think that's the distinction between compile time macro calling and run time macro calling. The compile time substitutes the return value, the run time substitutes the macro body.

[16:35] *** ZuLuuuuuu joined
[16:35] <mberends> DanielC: indeed, and we need to distinguish only a handful of authorities

[16:35] <DanielC> mberends: Yes.

[16:35] <lichtkind> mberends: now i get it big thanks

[16:36] <mberends> lichtkind: thanks to you too, I didn't know that much when you began asking :)

[16:36] <lichtkind> haha

[16:36] <DanielC> Fletcher-16 is faster but less reliable than Adler-32, right?

[16:36] <mberends> collides a bit more often

[16:37] <mberends> ISTR it's about 13 effective bits out of 16

[16:37] <DanielC> ok

[16:37] <mberends> 8k authorities per module + version

[16:37] <TimToady> that's not how macros work

[16:37] <DanielC> assuming that's randomly distributed, that gives us 90.

[16:38] <TimToady> nothing ever substitutes the macro body

[16:38] <mberends> lichtkind: heads up!

[16:38] <DanielC> 90 authorities before we expect a collision via the birthday paradox.

[16:38] <TimToady> a macro returns only a string or an AST

[16:38] <TimToady> a string is inlined (in its own scope) and reparsed

[16:39] <lichtkind> mberends: what does mean that? i hope you particpate also in the p6 tut in which will lead my search (still german only)

[16:39] <TimToady> if you have { 3+4 } it would be stringified to '3+4' and reparsed

[16:39] <TimToady> an AST is just inserted

[16:39] *** alester_ joined
[16:40] <DanielC> mberends: 13 random bits => 90 authorities before we get a collision (birthday paradox).

[16:40] <lichtkind> TimToady: so it doesnt matter if i write in the macro 3+4 or '3+4' but the difference if the macro is parsed or is reparsed?

[16:40] <TimToady> run time doesn't change this, but assumes a sub {} around the AST (which, for a string return, would have to be compiled)

[16:40] *** alester left
[16:40] <TimToady> there are only two possibilities, AST and everything else

[16:40] *** FurnaceBoy joined
[16:40] <mberends> DanielC: yes

[16:40] <TimToady> and everything else is assumed to be stringified

[16:42] <mberends> DanielC: that would be 1 collision per 90 distinct (module+version) instances that have multiple authorities. Still unimaginably remote.

[16:43] *** cotto left
[16:43] <DanielC> mberends: It does sound unlikely in practice. Generally there is only 1 authority per module...

[16:43] <mberends> nod

[16:43] *** Psyche^ joined
[16:45] <DanielC> mberends: On the other hand, do we really need the extra speed of a 16-bit sum? Is there any real harm in using a 32-bit sum? (Fletcher-32, Adler-32,CRC-32).

[16:45] *** justatheory joined
[16:46] <mberends> it results in shorter names for the filesystem

[16:48] <DanielC> 32-bits => 5 characters base 64.  16-bit => 3 characters base 64 (I think).

[16:51] <mberends> each base64 char is 6 bits

[16:52] <DanielC> So that means 6 characters vs 3 characters.

[16:53] <DanielC> Foo::Bar-auth:92de10-ver:1.2.0

[16:53] <DanielC> Foo::Bar-auth:a12-ver:1.2.0

[16:53] <lichtkind> TimToady: the is reparsed trait triggers the decision that a string is returned?

[16:54] <DanielC> I don't think the extra 3 chars make a big difference.

[16:55] <TimToady> has nothing to do with whether a string is returned, but what the supplied rule is expected to parse

[16:55] *** Patterner left
[16:55] *** Psyche^ is now known as Patterner

[17:00] <lichtkind> TimToady: thanks that was the crucial bit to me, i understood it yesterday the other way around

[17:00] *** rewt joined
[17:03] <lichtkind> TimToady:  so macro s  is reparsed { '3+4' } say 2 * s(); result would be 10 ?

[17:09] *** frew|work joined
[17:10] <mberends> DanielC: base64 could also give you Foo::Bar-auth:AnYtXt-ver:1.2.0

[17:10] <DanielC> mberends: yes

[17:10] <DanielC> And usually, it will.

[17:10] <mberends> :)

[17:12] *** alester_ left
[17:13] <DanielC> The Fletcher algorithm is really easy:  ($A,$B) = 0; for @blocks -> $D { $A += $D; $B += $A }

[17:13] <dalek> rakudo: 50ec44e | pmichaud++ |  (3 files):

[17:13] <dalek> rakudo: Use iso-8859-1 (fixed-width) instead of utf8 for parsing when we can.

[17:13] <dalek> rakudo: This improves the "make spectest" performance by about 13%.

[17:13] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/50ec44e24c1a0945130331a21d621ef68a97df80

[17:13] <dalek> rakudo: 0b9c9a3 | tene++ |  (2 files):

[17:13] <dalek> rakudo: Track changes in HLL library loading API.

[17:13] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0b9c9a357717595deeb1ab7269381e00f0e57376

[17:14] <mberends> DanielC: that may be why I once used it :)

[17:14] <DanielC> Fletcher16 and Fletcher32 are the same algorithm, with different block size.

[17:14] <DanielC> :)

[17:18] <mberends> it was probably on PC-DOS, so 16 bit :)

[17:18] <DanielC> buubot: split

[17:18] <DanielC> hm... 

[17:18] * DanielC wants to find the simplest way to split a string into characters.

[17:19] <mberends> buubot: spack split

[17:19] <buubot> mberends: S02-bits.pod:5 S03-operators.pod:2 S05-regex.pod:6 S06-routines.pod:2 S19-commandline.pod:9 S29-functions.pod:13

[17:19] <DanielC> thanks

[17:20] *** kane_ joined
[17:21] <DanielC> sub Fletcher16($str) {

[17:21] <DanielC> 	my ($A,$B) = (0,0);

[17:21] <DanielC> 	loop split //, $str -> $chr {

[17:21] <DanielC> 		$A = ($A + ord $chr) % 256;

[17:21] <DanielC> 		$B = ($B + $A) % 256;

[17:21] <DanielC> 	}

[17:21] <DanielC> 	return (chr $A) ~ (chr $B);

[17:21] <DanielC> }

[17:21] * DanielC thinks that's about right.

[17:22] <DanielC> s/loop/for/

[17:23] *** bloonix left
[17:23] <DanielC> Hmm... still need to convert the output to hex or base 64.

[17:24] <mberends> part of the debate was about Unicode chars in names, so ord $chr will probably overflow 256.

[17:24] <DanielC> hm

[17:24] <DanielC> indeed

[17:24] <mberends> but nevermind, it's close and a good first shot :)

[17:25] <DanielC> :-)

[17:26] *** bloonix joined
[17:29] <DanielC> s/256/255/

[17:29] *** ejs joined
[17:30] *** Traveler8 joined
[17:35] *** kane__ left
[17:39] <DanielC> rakudo: say ord "動"

[17:39] <p6eval> rakudo 764684: OUTPUT«21205␤»

[17:40] <DanielC> On my computer it says 229. Why?

[17:42] <sjohnson> kanji for "move"

[17:43] <DanielC> Any idea why my local Rakudo's ord function gives 229?

[17:43] <pochi> rakudo: say "動".chars

[17:43] <p6eval> rakudo 764684: OUTPUT«1␤»

[17:44] <pochi> it probably doesn't think of it as unicode?

[17:44] <DanielC> rakudo: say "動".bytes

[17:44] <p6eval> rakudo 764684: OUTPUT«ResizableStringArray: Can't shift from an empty array!␤in method Any::bytes (src/gen_setting.pm:242)␤called from Main (/tmp/HfNytq7uAt:2)␤»

[17:44] <DanielC> Did I call the wrong method?

[17:45] <mberends> DanielC: there may be differences between text from a script file and from your console, ie outside of rakudo

[17:46] <DanielC> mberends: Indeed, you are right.

[17:46] <mberends>  .bytes is fairly new and possibly untested for some inputs.

[17:46] <DanielC> I just put it in a file and now it gives the right answer.

[17:47] <pmichaud> Parrot doesn't always know how to read things as utf8 from the command line or from the console input

[17:50] *** [particle] joined
[17:53] *** sri_kraih joined
[17:59] <DanielC> Does Perl 6 have an integer division operator?

[18:00] *** wknight8111 joined
[18:00] <DanielC> int $a/$b will do.

[18:03] <mberends> DanielC: are you working on a Unicode hash now?

[18:04] <DanielC> yeah

[18:04] <DanielC> sub Fletcher16($str) {

[18:04] <DanielC> 	my ($A,$B) = (0,0);

[18:04] <DanielC> 	for split //, $str -> $chr {

[18:04] <DanielC> 		my $val = ord $chr;

[18:04] <DanielC> 		$A = ($A + $val % 255) % 255;

[18:04] <DanielC> 		$B = ($B + $A) % 255;

[18:04] <DanielC> 		

[18:04] <DanielC> 		if $val > 255 {

[18:04] <DanielC> 			$A = ($A + int $val/255) % 255;

[18:04] <DanielC> 			$B = ($B + $A) % 255;

[18:04] <DanielC> 		}

[18:04] <DanielC> 	}

[18:04] <DanielC> 	return int2hex($A*256 + $B);

[18:04] <DanielC> }

[18:04] <DanielC> But I think my "split" line is broken.

[18:05] <DanielC> rakudo: say split //,"hello"

[18:05] <p6eval> rakudo 0b9c9a: OUTPUT«Statement not terminated properly at line 2, near "//,\"hello\""␤in Main (src/gen_setting.pm:0)␤»

[18:06] <pmichaud>  // isn't a valid pattern

[18:06] <DanielC> :-(

[18:06] <pmichaud> try ''

[18:06] <DanielC> rakudo: say split '',"hello"

[18:06] <p6eval> rakudo 0b9c9a: OUTPUT«hello␤»

[18:06] <DanielC> rakudo: say (split '',"hello").perl

[18:06] <pmichaud> rakudo:  say (split '', 'hello').perl

[18:06] <p6eval> rakudo 0b9c9a: OUTPUT«["h", "e", "l", "l", "o"]␤»

[18:06] <DanielC> excellent.

[18:06] <sjohnson> rakudo: say split '', "happy house".join " "

[18:06] <p6eval> rakudo 0b9c9a: OUTPUT«Statement not terminated properly at line 2, near "\" \""␤in Main (src/gen_setting.pm:0)␤»

[18:07] <pmichaud> rakudo:  say 'hello'.split('').perl

[18:07] <p6eval> rakudo 0b9c9a: OUTPUT«["h", "e", "l", "l", "o"]␤»

[18:07] <sjohnson> rakudo:  say (split '', 'hello').join "-"

[18:07] <p6eval> rakudo 0b9c9a: OUTPUT«Statement not terminated properly at line 2, near "\"-\""␤in Main (src/gen_setting.pm:0)␤»

[18:07] <pmichaud> sjohnson: method calls required a : or ( ) for params

[18:07] <pmichaud> (the .join)

[18:07] <sjohnson> rakudo:  say (split '', 'hello').join("-")

[18:07] <p6eval> rakudo 0b9c9a: OUTPUT«h-e-l-l-o␤»

[18:08] <sjohnson> >_>

[18:08] <sjohnson> <_<

[18:08] <DanielC> rakudo: say ("hello".split('').map {.ord}).perl

[18:08] *** [particle]1 left
[18:08] <p6eval> rakudo 0b9c9a: OUTPUT«Statement not terminated properly at line 2, near "{.ord}).pe"␤in Main (src/gen_setting.pm:0)␤»

[18:08] <pmichaud> std.  say 'hello'.join '-'

[18:08] <pmichaud> std:  say 'hello'.join'-'

[18:08] <p6eval> std 26977: OUTPUT«##### PARSE FAILED #####␤Syntax error (two terms in a row?) at /tmp/wNVLmQIjDh line 1:␤------> [32msay 'hello'.join[31m'-'[0m␤    expecting any of:␤      POST␤   infix or meta-infix␤        infix stopper␤    method arguments␤ postfix␤        postfix_prefix_meta_operator␤      

[18:08] <p6eval> ..standard stopper␤       statement mod…

[18:08] <pmichaud> std:  say 'hello'.join '-'

[18:08] <p6eval> std 26977: OUTPUT«##### PARSE FAILED #####␤Syntax error (two terms in a row?) at /tmp/xyC66rM6M3 line 1:␤------> [32msay 'hello'.join [31m'-'[0m␤    expecting any of:␤     infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤FAILED 00:02 35m␤»

[18:09] <DanielC> rakudo: map { ord $^a } "hello".split('')

[18:09] <p6eval> rakudo 0b9c9a: OUTPUT«Statement not terminated properly at line 2, near "\"hello\".sp"␤in Main (src/gen_setting.pm:0)␤»

[18:10] <DanielC> :-(

[18:10] <pmichaud> need a comma between params

[18:10] <DanielC> rakudo: map { ord $^a }, "hello".split('')

[18:10] <p6eval> rakudo 0b9c9a:  ( no output )

[18:10] <DanielC> :-)

[18:10] <pmichaud> rakudo:  say map { .ord }, "hello".split('')

[18:10] <p6eval> rakudo 0b9c9a: OUTPUT«104101108108111␤»

[18:11] *** frew|work left
[18:11] <DanielC> On my computer it gives : too few arguments passed (1) - 4 params expected

[18:12] <DanielC> rakudo: say map { .ord }, "hello".split('')

[18:12] <p6eval> rakudo 0b9c9a: OUTPUT«104101108108111␤»

[18:12] <DanielC> ah, I know...

[18:12] <DanielC> stupid shell.

[18:12] <mberends> quotes, huh?

[18:13] <DanielC> yeah

[18:15] <mberends> afk & # birthday beers @neighbours

[18:16] <DanielC> pmichaud: Does Rakudo support #(( ... )) multi-line comments?

[18:17] <pmichaud> rakudo:  say   #(( not this ))   "yes, it does";

[18:17] <p6eval> rakudo 0b9c9a: OUTPUT«yes, it does␤»

[18:17] <DanielC> Mine says: Can't use embedded columns in column 1 at line 3, near "((\n\tmy $fi

[18:17] <pmichaud> oh, that should say "embedded comments"

[18:17] <DanielC> But mine is a multi-line comments.

[18:17] <pmichaud> multi-line comments aren't allowed to begin in column 1

[18:18] *** jdv79 joined
[18:18] *** jdv79 left
[18:18] *** abra left
[18:18] <DanielC> ?

[18:18] <pmichaud> S02

[18:18] *** jdv79 joined
[18:18] <DanielC> So I need to add a space before #?

[18:18] <lichtkind> mberends: still there?

[18:18] <DanielC> pmichaud: I added a space before # and now it works.

[18:19] <mberends> yes

[18:19] <pmichaud> S02:  "An embedded comment is not allowed as the first thing on the line."

[18:20] <jdv79> anyone know if there is any online version of the talk entitled "The Art of Ballistic Programming" by L. Wall?

[18:20] <pmichaud> should be

[18:20] <mberends> lichtkind: pong

[18:20] <pmichaud> it was broadcast live when he gave it at MIT

[18:21] <lichtkind> mberends: so if i understood larry correctly

[18:21] <lichtkind> mberends: so macro s  is reparsed { '3+4' } say 2 * s(); result would be 10 ?

[18:22] <mberends> lichtkind: I'm confused, because I would expect 14. but I'm really going now. Prost!

[18:22] <lichtkind> prost

[18:22] <lichtkind> mberends: 14 would be in parsed mode

[18:26] <skids> pmichaud: Apparently he wasn't mic'd well so only the slides came across.

[18:26] *** jdv79 left
[18:26] *** jdv79 joined
[18:27] <jdv79> if anyone answered me could you answer again - my dsl line just died:(

[18:28] <DanielC> mberends / pmichaud: Unicode implementation of Fletcher-16 located in perl6-examples/misc/Fletcher.pl

[18:29] <DanielC> I haven't tested it much.

[18:30] *** sri_kraih left
[18:33] <lichtkind> anybody here with clue about p6 macros?

[18:39] *** sri_kraih joined
[18:41] <skids> jdv79: From what I heard, they tried to tape that talk, but the audio didn't come out.

[18:47] *** finanalyst left
[18:48] *** justatheory left
[18:48] *** Traveler8 left
[19:06] *** DemoFreak joined
[19:07] *** cls_bsd left
[19:09] *** LadyLuna1y left
[19:09] *** LadyLunacy joined
[19:09] *** cls_bsd joined
[19:10] *** LadyLunacy left
[19:11] <DanielC> rakudo: "he_" ~~ /<-alpha -\_>/ 

[19:11] <p6eval> rakudo 0b9c9a: OUTPUT«perl6regex parse error: Error parsing enumerated character class at offset 29, found '\'␤in Main (src/gen_setting.pm:0)␤»

[19:12] <DanielC> Grr... I'm really struggling with the new regexes.

[19:12] <DanielC> I want to match anything that is not alphanumeric and not an underscore.

[19:14] <DanielC> rakudo: "he_" ~~ /<-alpha -[_]>/ 

[19:14] <p6eval> rakudo 0b9c9a:  ( no output )

[19:14] <DanielC> rakudo: "he_" ~~ /<-alpha -[_:-]>/ 

[19:14] <p6eval> rakudo 0b9c9a: OUTPUT«perl6regex parse error: Unescaped '-' in charlist (use '..' or '\-') at offset 32, found '-'␤in Main (src/gen_setting.pm:0)␤»

[19:14] <DanielC> rakudo: "he_" ~~ /<-alpha -[_:]>/ 

[19:14] <p6eval> rakudo 0b9c9a:  ( no output )

[19:15] <DanielC> rakudo: "he_" ~~ /<-alpha -[-_:]>/ 

[19:15] <p6eval> rakudo 0b9c9a: OUTPUT«perl6regex parse error: Unescaped '-' in charlist (use '..' or '\-') at offset 30, found '-'␤in Main (src/gen_setting.pm:0)␤»

[19:15] <DanielC> rakudo: "he_" ~~ /<-alpha -[\-_:]>/ 

[19:15] <p6eval> rakudo 0b9c9a:  ( no output )

[19:16] <DanielC> rakudo: if "ab_" ~~ /<-alpha -[\-_:]>/  { say "y" } else { say "n" }

[19:16] <p6eval> rakudo 0b9c9a: OUTPUT«n␤»

[19:17] *** ejs1 joined
[19:29] *** Maghnus left
[19:30] *** Maghnus joined
[19:31] *** eMaX joined
[19:42] *** Fuad joined
[19:42] <Fuad> Hello

[19:59] <Matt-W> hello

[20:00] <jnthn> hi Fuad :-)

[20:02] *** viklund joined
[20:03] <Fuad> howdy,jnthn:)

[20:07] *** Eevee joined
[20:07] <DanielC> rakudo: my @friends = ( {name=>"Joe"}, {name=>"Mike"} ); say @friends[0]{name};

[20:07] <p6eval> rakudo 0b9c9a: OUTPUT«Could not find non-existent sub name␤»

[20:08] <pmichaud> <name>

[20:08] <pmichaud> undeclared barewords are treated as subroutine calls in p6

[20:08] <DanielC> Am I supposed to put quotes around it?

[20:08] <DanielC> rakudo: my @friends = ( {name=>"Joe"}, {name=>"Mike"} ); say @friends[0]{'name'};

[20:08] <p6eval> rakudo 0b9c9a: OUTPUT«Joe␤»

[20:08] <DanielC> ah

[20:08] <pmichaud> you can either do   @friends[0]{'name'}   or   @friends[0]<name>

[20:08] <DanielC> thanks

[20:08] <DanielC> <name> is shorter.

[20:08] <pmichaud> That's one of the reasons it's there :-)

[20:09] <DanielC> Why does <name> work? I thought <> was a list constructor?

[20:09] <pmichaud> not precisely

[20:09] <pmichaud> <name>  is the same as ('name')

[20:09] <pmichaud> which isn't a list

[20:09] <jnthn> <name age> gets a hash slice though. :-)

[20:09] <pmichaud> <abc def>  is the same as ('abc', 'def')

[20:09] <pmichaud> which is a list

[20:09] <jnthn> %h<name age> that is

[20:09] <jnthn> iirc

[20:09] <DanielC> ok...

[20:10] <pmichaud> parens and angles don't construct lists

[20:10] <pmichaud> just like (3) is not a list

[20:10] <pmichaud> neither is <3>

[20:10] <DanielC> ok...

[20:10] <pmichaud> (caveat:  (3) might be a list now.)

[20:11] <pmichaud> (there's some spec changes taking place)

[20:11] <pmichaud> (regardless,   %hash<name>  is equivalent to %hash{'name'}

[20:11] <pmichaud> and %hash<name age>  is equivalent to %hash{'name', 'age'}

[20:13] <jdv79> skids: thanks

[20:14] *** ejs1 left
[20:25] *** wknight8111 left
[20:26] *** eMaX left
[20:27] *** cotto joined
[20:32] *** eternaleye left
[20:37] *** ejs left
[20:38] <DanielC> @karma

[20:38] <lambdabot> You have a karma of 5

[20:39] <DanielC> Hmm... I don't get karma points for committing to perl6-examples. Oh well.

[20:40] <DanielC> pmichaud: Is a module always one file?

[20:42] *** eternaleye joined
[20:44] *** Fuad left
[20:44] *** M_o_C left
[20:45] <pmichaud> I think Infinoid was going to switch dalek to report perl6-examples changes

[20:46] <DanielC> I thought he had already done it...

[20:46] <DanielC> Anyways, is a module always one file?

[20:47] <DanielC> I'm just wondering if a module can contain many files.

[21:05] *** hanekomu joined
[21:08] *** fridim_ left
[21:10] *** hanekomu_ joined
[21:26] *** hanekomu left
[21:51] *** frew|work joined
[21:53] *** volalba joined
[21:54] <volalba> who studies CS here

[21:57] *** iblechbot left
[21:58] *** volalba left
[22:12] *** jferrero joined
[22:21] *** explorer__ left
[22:27] *** tulcod left
[22:41] *** volalba joined
[22:44] <DanielC> This channel is quiet today.

[22:45] *** volalba left
[22:48] <jnthn> Sunday.

[22:48] <DanielC> I guess.

[22:49] <pochi> they're all celebrating whit sunday

[22:50] <DanielC> I'm looking at the Rakudo source code. It's hard to find anything written in Perl. It's all Parrot.

[22:50] <literal> check the setting

[22:50] <literal> src/setting

[22:50] <DanielC> ah, yes

[22:50] <DanielC> Lots of .pm files there. What is this directory for? Why is it called settings?

[22:51] <literal> not settings, but "the setting"

[22:51] <literal> aka. "the prelude"

[22:51] <DanielC> ok

[22:51] *** hanekomu_ left
[22:52] <literal> basically, the initial Perl 6 environment

[22:52] <literal> see S32 on http://perlcabal.org/syn/

[22:52] <DanielC> Ok, I see where it defines 'class Object'

[22:52] <DanielC> I see the basic classes here.

[22:53] <pmichaud> the other perl stuff is in src/parser/

[22:53] <pmichaud> src/parser/actions.pm is the bulk of the compiler

[22:53] <literal> I believe the idea is that this is the standard library which Perl 6 will provide by default, but in some environments people will swap it out for something else

[22:53] <pmichaud> src/parser/grammar.pg is the grammar

[22:54] <DanielC> pmichaud: What is a .pg file?

[22:54] <pochi> perl grammar?

[22:54] <DanielC> It looks like Perl code.

[22:54] <pmichaud> yeah, something like that.

[22:54] <pmichaud> it's Perl code, at any rate, with a little bit of embedded PIR

[22:55] <DanielC> One of these days I'll learn about the grammar features of Perl 6.

[22:55] <pmichaud> early on one of the Parrot architects wanted to distinguish grammars from other files, so .pg got chosen and we never really switched.

[22:55] <DanielC> I have never learned a grammar programming language, or whatever they're called.

[22:55] <pmichaud> in Perl 6 it's just regular expressions

[22:56] <pmichaud> (very advanced regular expressions, but just regular expressions)

[22:56] <DanielC> That's interesting.

[22:56] * DanielC makes a mental note to read all of S05

[22:56] <DanielC> S05 is... long.

[22:57] <pmichaud> yes, there's a lot there.

[22:57] <DanielC> This 'rule' feature looks very nifty.

[22:58] <DanielC> You can make hierarchical regular expressions...

[22:58] <skids> the enraging part is "i know i read something that did exactly what i want in S05, but can't find it now" :-)

[22:58] *** kate21de left
[22:59] <DanielC> Can rules be recursive? For example, in a Lisp grammar you might define an element to be a number, a string, or a list of elements.

[22:59] <skids> DanielC: more than hierarchal, regexes are subs and grammars classes

[23:00] <pmichaud> DanielC: yes, rules can be recursive.

[23:00] <DanielC> cool

[23:00] <DanielC> So you can define a natural number to be either 0 or 1 + a natural number :-)

[23:00] <skids> DanielC: if you really want to fry your brain, read STD.pm

[23:00] <DanielC> where can I find STD.pm ?

[23:01] <skids> in the pugs repository

[23:01] <DanielC> Ok. Maybe later.

[23:01] <literal> under src/perl6/

[23:01] <skids> yes, read s05 first :-)

[23:01] <DanielC> :-)

[23:01] <literal> http://svn.pugscode.org/pugs/src/perl6/STD.pm

[23:01] <DanielC> I've scanned up and down S05 a lot, but I haven't read everything.

[23:02] <DanielC> *click*

[23:02] <skids> he just couldn't resist, poor devil.

[23:03] <DanielC> Mental note: figure out what a 'token' is in Perl.

[23:03] <pmichaud> it's a regex with backtracking turned off by default

[23:03] <DanielC> What is a twigil?

[23:04] <pmichaud> (a token is a regex with backtracking turned off by default)

[23:04] <literal> the * in $*VARIABLE

[23:04] <skids> Second character after a sigil

[23:04] <DanielC> What is backtracking?

[23:04] <literal> http://en.wikipedia.org/wiki/Backtracking

[23:04] <DanielC> Sorry if I'm asking too many stupid questions.

[23:04] <DanielC> *click*

[23:05] <skids> You'll know when we start linking with lmgtfy.com :-)

[23:05] <DanielC> :-)

[23:06] <DanielC> In STD.pm I see twigils like . ! ^ : * + ?   Does that mean that I might find $+VAR, $!VAR, $:VAR, etc ?

[23:06] <skids> yep.

[23:06] <literal> well, $+VAR is deprecated, I think

[23:07] <DanielC> It's amazing that Perl would have that many variables.

[23:07] <skids> Twigils are for special purposes.

[23:07] <literal> it's not really different variables, but different scoping usually

[23:07] <skids> e.g. $!var is always an instance attribute.

[23:07] *** ZuLuuuuuu left
[23:08] <DanielC> ok

[23:08] <DanielC> Is $* always a file handle?

[23:08] <DanielC> $*FOO

[23:08] <literal> nah

[23:08] <DanielC> Seemed like a reasonable guess ($*IN)

[23:09] <skids> It's scoping.

[23:09] <literal> it's a global/contextual variable

[23:09] <literal> $*IN is global to your process, for example

[23:09] <pmichaud> well, not always :-)

[23:10] <DanielC> So $*FOO is visible in all files, whereas a regular global is only visible in the current file? Is that right?

[23:10] <pmichaud> $*FOO refers to the innermost dynamic scope that declared $FOO as a context var

[23:10] <pmichaud> if no such scope, then it looks in the process environment and some other places

[23:11] <DanielC> How is a context var different from other vars?

[23:11] <pmichaud> it's one that can be searched via the calling stack

[23:11] <pmichaud> it's like an environment variable in the shell

[23:11] <DanielC> ok

[23:12] <pmichaud> my $FOO is context;   some_sub();     # inside of some_sub, $*FOO would refer to the $FOO I just declared

[23:12] <pmichaud> my $IN is context = open('file.txt', :w);   say 'hello';    # outpus 'hello' to file.txt

[23:12] <pmichaud> *outputs

[23:13] *** beggars left
[23:13] <DanielC> In the $FOO example, why wouldn't you just use a global variable?

[23:14] <pmichaud> It's another way of controlling scope and reducing global variable conflicts.

[23:14] <pmichaud> Basically  $*FOO  means "the contextual $FOO defined by one of my callers

[23:15] <DanielC> Is it mainly to remind you that the thing you are looking at is a global variable?

[23:15] <DanielC> rakudo: my $a = 2; sub foo() { say $a }; foo()

[23:15] <pmichaud> more than a reminder

[23:15] <p6eval> rakudo 0b9c9a: OUTPUT«2␤»

[23:16] <pmichaud> oh, I see what you're saying.

[23:16] <pmichaud> it's more like this:

[23:16] <pmichaud> sub foo() { say $*a };  { my $a is context = 2;   foo() }

[23:16] <DanielC> ah

[23:17] <pmichaud> that's how print() can refer to a $*IN that isn't in print's lexical scope

[23:17] <pmichaud> it's in print's callers' lexical scope(s)

[23:17] <DanielC> rakudo: sub foo() { say $*a };  { my $a  = 2;   foo() } # should error

[23:17] <p6eval> rakudo 0b9c9a: OUTPUT«Use of uninitialized value␤␤»

[23:18] <DanielC> yeah

[23:18] <DanielC> That's very neat.

[23:18] <pmichaud> ("is context" isn't implemented in rakudo yet)

[23:18] <pmichaud> and rakudo still treats $*a as globals, per an earlier version of the spec.

[23:18] <DanielC> ok

[23:19] <DanielC> It's a very neat feature. So you can avoid making more truly-global variables.

[23:21] *** viklund left
[23:21] <DanielC> sub count() { $*cnt++ };  sub bar() { my $cnt is context = 10; count(); count() count() }

[23:22] * DanielC missed one ; 

[23:22] <pmichaud> in that case it would need to be  "is context<rw>"

[23:22] <DanielC> sub count() { $*cnt++ };  sub bar() { my $cnt is context rw = 10; count(); count(); count() }

[23:23] <DanielC> That's an interesting feature. I've never seen anything like that.

[23:28] *** justatheory joined
[23:44] *** DanielC left
[23:51] *** snarkyboojum joined
[23:52] *** justatheory left
[23:56] *** icwiener left
[23:57] *** snarkyboojum left
