[00:00] <jnthn> Yeah but then you need a way of saying what's in the ro interface.

[00:00] <TimToady> so we can mix in the type officially and still override the method to be just value

[00:00] <TimToady> in the case of True or 42

[00:01] <jnthn> Mixing in the type officially still doesn't give us a method Num that does the right thing.

[00:01] <TimToady> which takes me back to the notion that Bool is really two different roles...

[00:01] <jnthn> Plus a "mix in my name without by stuff" feels horrible.

[00:01] <jnthn> *my stuff

[00:02] <TimToady> well, what's the general way to make an immutable value out of an mutable type?

[00:02] <jnthn> Define how it responds to .WHICH.

[00:02] <pmichaud> just as a side note, it feels to me that stringification, numification, boolification, listification, and hashification really want to be one step removed from .Str, .Num/.Int/.Rat, .Bool, .List, .Hash

[00:02] <jnthn> pmichaud: That thought had occured to me too.

[00:02] <pmichaud> then .list/.hash continue to "feel right"

[00:03] <TimToady> maybe, but prefix:<~> isn't the answer

[00:03] <pmichaud> agreed, prefix:<~> isn't the answer.

[00:03] <jnthn> That prefix:<+> is kinda hand-wavey.

[00:04] <TimToady> at bottom, the primitives have to be single dispatch on an object, since the object decides what it means, not the language

[00:04] <TimToady> except maybe for really primitive functions that don't do MMD

[00:04] <TimToady> but those are very rare

[00:05] <pmichaud> it would be okay to me if "object stringification" delegated to .Str by default, but I'm not sure that it should *be* .Str

[00:05] <pmichaud> similar arguments for "numification" and .Int/.Num/.Rat   and "boolification"

[00:05] <jnthn> I guess it's the .list vs .List/.Array/.Range distinction.

[00:06] <TimToady> oops, gotta run off

[00:06] <jnthn> One is "give me something I can do list-y things with", the other is "give me exactly this type"

[00:06] <TimToady> will backlog

[00:06] <pmichaud> Yes, exactly.

[00:06] <TimToady> bbl &

[00:06] <pmichaud> I suspect conversation will close here for a while, as it's late where jnthn is, I have to fix a broken Rakudo build.

[00:06] <jnthn> Aye.

[00:06] <pmichaud> and we could all use time to ruminate on today's discussions

[00:06] <jnthn> Sure.

[00:07] <jnthn> I think "what do we tell people to override" plays into this as well. "Should I override .Num or .Int?" etc

[00:07] <pmichaud> exactly.... I'm kinda thinking "neither"

[00:07] <pmichaud> I'm thinking there's some other numification interface

[00:08] <pmichaud> just like we currently override .list to get the list-version of an object.

[00:08] <pmichaud> even if that list-version isn't a List

[00:08] <jnthn> There's already some other itemification, listification, and hashificiation interface.

[00:09] <jnthn> Since we seem to have picked numification, stringification and boolificiation as our value-based "ifications", I guess following the same kind of approach as we do in container space might be the way to go.

[00:09] <jnthn> But that sitll doesn't solve us the "what about $x but 42".

[00:10] <pmichaud> I kinda think we can't really think about "$x but 42"  until we decide what numification really means.

[00:10] <jnthn> Yes.

[00:10] <pmichaud> just like we can't really do  "$x but True"  until we decide what boolification really means.

[00:11] <jnthn> *sigh*

[00:11] <jnthn> Just when I thought we had an answer...

[00:11] <pmichaud> Sorry.

[00:12] *** orafu left
[00:12] *** OuLouFu joined
[00:12] <jnthn> No, they're all good counter-points.

[00:12] *** OuLouFu is now known as orafu

[00:12] <pmichaud> Well, I'm only half sorry.  I figure pain today may avoid larger pain tomorrow.

[00:13] <pmichaud> and thinking of ~(Int.WHAT) as "CORE::Int" was a bit of an eye-openrer.

[00:13] <pmichaud> *opener

[00:13] <jnthn> Doing anything by name is messy.

[00:13] <pmichaud> *"CORE::Int()"

[00:13] <pmichaud> (sigh)

[00:14] <jnthn> I was under the impression seen Foo($x) co-ercing to $x as becoming $x.Foo

[00:14] <jnthn> And that's how a class said "here's how I become a Foo"

[00:14] <jnthn> If that's the case, then we have a *much* wider problem of how to do co-ercion, than just what the "$x but 42" has exposed.

[00:15] <pmichaud> oh, I think that may still be true; I'm just not sure that stringification is directly .Str, nor numification is directly .Num

[00:15] <jnthn> I mean the namespacing problem.

[00:15] <jnthn> What does Foo::Bar($x) call?

[00:15] <pmichaud> depends on whether method Bar is export

[00:15] <jnthn> Or CORE::Int($x)

[00:15] <pmichaud> but yes, if it's a type...

[00:15] <jnthn> I meant co-ercion.

[00:16] <pmichaud> well, coercions are a bit syntactically special, yes.

[00:16] <pmichaud> but yes, it's not clear what method would define a coercion to a Foo::Bar

[00:16] <jnthn> Right, which is the *real* problem we have here.

[00:16] <pmichaud> that sounds very useful, yes.

[00:17] <pmichaud> (the identification of the problem, that is)

[00:17] <pmichaud> oh, switching tracks slightly

[00:17] <jnthn> Or at least the same one that does underly the "what Int" in $x but $y where $y maybe is an Int or a My::Int.

[00:17] <pmichaud> the other day we were talking about how PMC types keep their mros as string values... could they be type ints?

[00:17] <pmichaud> instead of strings?  the type ints are somewhat guaranteed to be unique, yes?

[00:18] <pmichaud> although I guess that wouldn't work for dynpmcs

[00:18] <jnthn> Yes apart from type IDs are meant to be going away.

[00:18] <jnthn> dynpmcs get a type ID too.

[00:18] <pmichaud> well, they still hang around internally

[00:18] <jnthn> They don't know it up front.

[00:18] <pmichaud> when type IDs disappear they'll just become pointers, I suspect.

[00:18] <jnthn> I think there's some kinda idea that one day we'll be free of type IDs.

[00:18] <pmichaud> I think we'll be free of "type ID as int"

[00:18] <pmichaud> I think we'll still have an ID, it'll just be an address.

[00:19] <jnthn> When I re-wrote Parrot's object system initially, we were free of integer type IDs and everything was about pointers.

[00:19] <pmichaud> I doubt it will be a string.  At least I hope it won't be that :-)

[00:19] <pmichaud> unless we start to guarantee string uniqueness :-)

[00:19] <jnthn> Then it was made to mesh into existing Parrot rather than existing Parrot made to mesh into it.

[00:19] <pmichaud> Understood.

[00:19] <pmichaud> and I know the feeling.  :->

[00:20] <pmichaud> okay, I _think_ I've fixed the build... testing now.

[00:20] <jnthn> Heh, what was it?

[00:23] <jnthn> Anyway, type IDs would be an improvement on strings.

[00:23] <pmichaud> oh, I'm refactoring things to enable .HLL mapping

[00:23] <jnthn> But we'd just have to get it past the "type IDs are dead" mentality.

[00:23] <pmichaud> but apparently I forgot to add a file to the repo

[00:24] <jnthn> (As in, they are alive and kicking internally for the foreseeable future)

[00:24] <pmichaud> and "git status" didn't show my unadded file

[00:24] <jnthn> Oh. Odd.

[00:24] <pmichaud> (which I'm a little surprised about)

[00:24] <jnthn> Yeah, same.

[00:24] <jnthn> I found git add a weird beast.

[00:24] <pmichaud> I think the death of type IDs has been exaggerated.

[00:25] <jnthn> Aye, same.

[00:25] <jnthn> I think anyone who really understands the issues knows they aren't going to disappear internally for quite a whioe.

[00:25] <jnthn> *while

[00:25] <pmichaud> right.

[00:25] <pmichaud> anyway, if mro could use type ids (even temporarily) instead of strings, that might be a huge win.

[00:25] <pmichaud> speed-wise, too.

[00:26] <jnthn> Yes.

[00:26] <jnthn> Wonder how hard it'd be...

[00:26] <jnthn> Maybe let's suggest it at the next #parrotsketch?

[00:26] <pmichaud> sure

[00:26] <pmichaud> it's an internals change, so wouldn't require deprecation.

[00:27] <jnthn> Yeah, it's VTABLE structure, and I hope people aren't mucking in there too much.

[00:27] <pmichaud> okay, I have to join family for dinner (belatedly, since rakudo appears fixed).  see you tomorrow

[00:27] <jnthn> Yeah, I sleep soon...enjoy dinner.

[00:43] *** orafu left
[00:43] *** OuLouFu joined
[00:43] *** OuLouFu is now known as orafu

[00:44] *** fridim_ left
[00:47] *** bacek_ joined
[00:49] *** eternaleye joined
[00:54] *** orafu left
[00:54] *** orafu joined
[00:59] *** exodist left
[00:59] *** shillo joined
[00:59] *** shillo left
[01:01] *** Whiteknight left
[01:04] *** orafu left
[01:05] *** orafu joined
[01:13] *** ZuLuuuuuu left
[01:15] *** orafu left
[01:16] *** orafu joined
[01:27] *** orafu left
[01:27] *** orafu joined
[01:31] *** Limbic_Region left
[01:37] *** ben left
[01:45] *** DemoFreak left
[01:47] *** hercynium left
[02:11] *** orafu left
[02:11] *** orafu joined
[02:13] *** orafu left
[02:14] *** OuLouFu joined
[02:14] *** OuLouFu is now known as orafu

[02:14] *** orafu left
[02:21] *** orafu joined
[02:25] *** PacoLinux left
[02:26] *** PacoLinux joined
[02:28] *** sri_kraih_ joined
[02:31] *** orafu left
[02:31] *** orafu joined
[02:42] *** sephee joined
[02:47] *** sri_kraih left
[02:50] *** orafu left
[02:50] *** orafu joined
[02:58] *** payload left
[02:59] *** orafu left
[02:59] *** orafu joined
[03:17] *** orafu left
[03:17] *** orafu joined
[03:28] *** nbrown joined
[03:37] *** orafu left
[03:37] *** orafu joined
[03:43] *** minazo joined
[04:01] *** alester joined
[04:06] *** SamB left
[04:10] <skids> more fun with printf in Parrot: total has accesses by key type for rakudo '1.say'

[04:10] *** mankash joined
[04:11] <skids> reads: tot 380000 I 0 CS 12130 S 367852 PMC 18 ptr 0

[04:11] <skids> writes: tot 92000 I 0 CS 904 S 91096 PMC 0 ptr 0

[04:11] <mankash> how \Q works

[04:11] <skids> in perl5?

[04:11] <mankash> yes

[04:12] <skids> \Qstuff\E, but go to channel #perl

[04:12] <mankash> $rtr=\Q$snmpget .1.3.6.1.4.1.9.2.1.3.0\Q

[04:12] <mankash> here \Q not working for me

[04:12] <skids> use \E at the end not \Q

[04:12] <mankash> ok

[04:12] <mankash> thx

[04:12] <skids> np

[04:14] <mankash> giving compilation error

[04:15] <mankash> $snmpget is a command

[04:16] <skids> inside quotes

[04:16] <skids> '1.say' hash number of elements % operations (0 to 8, then 63+)

[04:16] <skids> reads: 0.28 64.50 13.50 3.51 0.46 0.20 0.19 0.37, 12.72

[04:16] <skids> writes: 14.23 9.03 6.18 4.40 3.58 2.96 2.39 2.18, 29.80

[04:17] <skids> use quotes: $rtr="\Q$snmpget .1.3.6.1.4.1.9.2.1.3.0\Q"

[04:17] <skids> use quotes: $rtr="\Q$snmpget .1.3.6.1.4.1.9.2.1.3.0\E"

[04:17] <skids> even

[04:19] <mankash> now it is not giving any compilation error but add \ all the places

[04:35] *** alester left
[04:35] *** alester joined
[04:39] *** skids left
[04:43] *** minazo left
[04:43] *** c9s_ is now known as c9s

[04:56] *** km2 joined
[05:03] *** alanhaggai joined
[05:21] *** bkeeler left
[05:31] *** alester left
[05:38] *** nbrown left
[06:17] *** [particle]- left
[06:18] *** justatheory left
[06:41] *** alanhaggai_ joined
[06:43] *** alanhaggai left
[06:43] *** alanhaggai_ is now known as alanhaggai

[07:00] *** nbrown joined
[07:05] *** eMaX joined
[07:06] *** eMaX left
[07:06] *** eMaX_ joined
[07:25] *** nbrown left
[07:35] *** iblechbot joined
[07:42] *** jnthn left
[07:42] *** zev left
[07:42] *** buu left
[07:42] *** Maddingue left
[07:42] *** IRSeekBot left
[07:43] *** jnthn joined
[07:43] *** zev joined
[07:43] *** IRSeekBot joined
[07:43] *** Maddingue joined
[07:43] *** buu joined
[07:43] *** irc.freenode.net sets mode: +o jnthn

[07:48] *** |Jedai| joined
[07:59] *** bacek_ left
[08:14] *** bacek_ joined
[08:19] *** pmurias joined
[08:39] *** abra joined
[08:39] *** bacek_ left
[08:41] *** alanhaggai left
[08:48] *** mikehh joined
[08:51] <mikehh> rakudo (b83a0b0) builds on parrot r38415 - make test PASS / make spectest (pugs r26582) FAIL

[08:52] <mikehh> t/spec/S09-subscript_slice/slice.rakudo -  (Wstat: 11 Tests: 27 Failed: 0)

[08:53] <mikehh> t/spec/S12-class/basic.rakudo - TODO passed:   30

[08:54] <mikehh> ./perl6 t/spec/S09-subscript_slice/slice.rakudo handles all the tests then has a Segmentation fault

[08:54] *** smtms left
[08:54] *** smtms joined
[08:55] *** masak joined
[08:55] <mikehh> thats on Kubunt Jaunty (9.04) AMD64

[08:55] <masak> merry Friday, disruptive techies.

[08:58] <mberends> good rakudoday, masak

[08:59] <masak> \o/

[08:59] *** lumi left
[09:03] <masak> and, presto, Rakudo builds today.

[09:03] <masak> pmichaud++

[09:04] <mberends> @seen presto ;)

[09:04] <lambdabot> I haven't seen presto.

[09:07] *** lumi joined
[09:09] *** DemoFreak joined
[09:20] <pugs_svn> r26593 | azawawi++ | [S:H:P6] updated to v0.49 which contains the latest STD.

[09:29] <jnthn>  H H

[09:29] <jnthn> O   AI

[09:29] <mberends> O AI # did you drop something?

[09:29] <masak> !IAH HO

[09:30] <mberends> rakudo: "!IAH HO".flip.say

[09:30] <p6eval> rakudo b83a0b: OUTPUT«OH HAI!␤»

[09:31] <masak> rakudo: subset FooStr of Str where /^foo/; multi method trim(FooStr $self:) { return "OH HAI" }; say "foo".trim

[09:31] <p6eval> rakudo b83a0b: OUTPUT«OH HAI␤»

[09:31] <masak> that's just... so cool.

[09:32] <masak> I can haz dispatch on subtyped invocant! \o/

[09:32] <masak> rakudo: subset FooStr of Str where /^foo/; multi method trim(FooStr $self:) { return "OH HAI" }; say "bar".trim

[09:32] <p6eval> rakudo b83a0b: OUTPUT«No applicable candidates found to dispatch to for 'trim'␤current instr.: 'parrot;P6metaclass;dispatch' pc 243371 (src/gen_actions.pir:0)␤»

[09:32] <masak> jnthn: how come that doesn't work, though?

[09:33] <jnthn> masak: Because "bar" ~~ /^foo/ is false?

[09:33] <masak> I know that.

[09:34] <masak> my question is more along the lines of: why don't I get the ordinary .trim there?

[09:34] <jnthn> oh hang on...

[09:34] <masak> it seems an applicable candidate to me...

[09:34] <jnthn> You're deifning methods outside of a class...

[09:34] <masak> is that naughty?

[09:35] <masak> basement cat told me to do it!

[09:36] <masak> anyway, got to change locations again. please discuss appropriateness of defining methods outside of classes until I get back. :P

[09:36] <jnthn> Well, not sure, but we do also have a ticket somewhere along the lines of "you can define methods outside of a class", I'm sure...

[09:36] *** masak left
[09:38] *** xinming left
[09:38] *** xinming joined
[09:39] * jnthn pulls latest Rakudo

[09:40] *** les joined
[09:43] <jnthn> I think this ticket can be closed? http://rt.perl.org/rt3/Public/Bug/Display.html?id=57444

[09:43] <jnthn> Since :Trig tag is working...

[09:48] *** M_o_C joined
[09:50] *** pmurias left
[10:00] *** masak joined
[10:04] <masak> jnthn: re RT ticket about declaring methods outside of classes: no, I find no such ticket. at least not one matching the string 'method' in the subject line.

[10:05] <jnthn> Hmm, OK, I thought I'd seen one.

[10:05] <masak> jnthn: anyway... why doesn't the "bar" version dispatch to Str.trim?

[10:06] *** dalek left
[10:06] *** pmurias joined
[10:06] *** dalek joined
[10:07] <masak> more importantly, is it something I should tell RT about?

[10:08] <jnthn> masak: I'm not entirely sure how/why the first one works.

[10:08] <masak> :)

[10:08] <masak> it felt amazing that it did, to be sure.

[10:08] <jnthn> rakudo: "foo".trim

[10:08] <p6eval> rakudo b83a0b:  ( no output )

[10:08] <jnthn> OK, so there is something there

[10:08] <masak> I mean, who needs monkeypatching when you can dispatch on subtyped invocants?

[10:08] <jnthn> Well, you're essentially monkey-patching without the monkey.

[10:09] <masak> *lol*

[10:09] <masak> sounds like a good name for a blog post.

[10:11] <jnthn> Does it work if you do monkey-patch the method in?

[10:11] <masak> how do you mean?

[10:12] <masak> rakudo: subset FooStr of Str where /^foo/; multi method trim(FooStr $self:) { return "OH HAI" }; class Str is also { multi method trim() { return "CHEEZBURGER" } }; say "foo".trim; say "bar".trim

[10:12] <p6eval> rakudo b83a0b: OUTPUT«CHEEZBURGER␤CHEEZBURGER␤»

[10:13] <jnthn> I meant put the FooStr one inside the is also too.

[10:13] * masak tries

[10:14] <jnthn> omfg how many enums tickets do we have...

[10:14] <masak> so, enums day today? :)

[10:14] <masak> putting the subset decl inside the 'is also' decl brings back the "No applicable candidates" message.

[10:17] <jnthn> Yeah, I think it might finally be time to bite the bullet and sort out enums.

[10:18] * masak tries to understand why a line in a November test uses .WHAT for type equivalence

[10:20] <masak> ah, it was probably because smartmatching against the Match type object failed.

[10:21] <masak> seems to work now.

[10:21] <masak> rakudo: say ("foo" ~~ /foo/) ~~ Match

[10:21] <p6eval> rakudo b83a0b: OUTPUT«1␤»

[10:21] *** cognominal left
[10:25] *** rblasch joined
[10:28] <jnthn> masak: On subset decl issue, already there is 64098[BUG] MMD on subset types fails for short name

[10:29] <masak> oh, ok.

[10:31] <masak> not the same issue, I'd say.

[10:31] <masak> problem is, I don't really know what the issue should be with the monkey-sans-monkey-patching.

[10:31] <masak> is it that the original method is hidden?

[10:31] <masak> or that dispatching on subset types of the invocant shouldn't be allowed at all?

[10:33] <jnthn> I don't know that writing a method outside a class like that is allowed (other than having heard various references to some Main class...)

[10:33] <jnthn> (and either way, Main is not Any)

[10:34] <jnthn> My guess is that you're ending up augmenting the exported trim

[10:34] <masak> is there a place in the spec that mentions declaring methods outside of their class scope?

[10:34] <jnthn> And we didn't clone the multi that the class exported, and thus why it looked like it affectd the class.

[10:35] <jnthn> Anonlymous ones yes, named ones I can't recall one.

[10:35] <jnthn> But there are I think references to a class Main.

[10:35] <masak> jnthn: should I report it as a bug saying that the Str.trim should still work?

[10:35] * jnthn has a fix for both a masakbug and an ilyabug

[10:35] <jnthn> There's *something* wrong that your example reveals.

[10:35] <jnthn> I'm not completely sure what it is yet.

[10:36] <masak> me neither.

[10:36] <jnthn> I'm pretty sure that you should not have been able to affect the Str class though.

[10:36] <masak> I didn't! :)

[10:36] <jnthn> We might be missing some cloning in the exported.

[10:36] <jnthn> *in the exporter

[10:36] * masak hesitantly submits a rakudobug

[10:37] <jnthn> Well, I mean that a method with a Str invocant declared out of class Str or not monkey-patched into it should not affect instances of Str.

[10:37] <jnthn> I think that might be the real wtf here.

[10:38] <masak> jnthn: aye.

[10:38] <masak> feels like monkey-patching from the outside.

[10:38] <jnthn> moritz_: In http://rt.perl.org/rt3/Ticket/Display.html?id=65238 you mention a t/spec/integration/packages.t but I can't find it?

[10:39] * masak -> store

[10:39] <jnthn> moritz_: oh, I fail it, I didn't svn up

[10:44] *** fridim_ joined
[10:49] <jnthn> moritz_: ping

[10:59] *** nihiliad joined
[11:05] *** pmurias left
[11:07] *** cognominal joined
[11:11] <pugs_svn> r26594 | jnthn++ | [t/spec] eval should eval things into the namespace of its caller; correct a test that assumed otherwise, and fails under the corrected behavior.

[11:11] <masak> jnthn++

[11:12] <pugs_svn> r26595 | jnthn++ | [t/spec] Unfudge a test for eval/namespaces.

[11:13] <jnthn> That's two tickets.

[11:13] <jnthn> (both masak++ and ihrd++ had reported it)

[11:21] *** kane_ left
[11:23] <masak> guess it bugged us both. :)

[11:24] *** mizioumt joined
[11:25] *** zamolxes joined
[11:26] *** zamolxes left
[11:26] *** zamolxes joined
[11:29] *** zamolxes left
[11:35] *** IRSeekBot left
[11:38] *** mizioumt left
[11:57] *** |Jedai| is now known as Jedai

[11:57] *** Jedai is now known as |Jedai|

[12:00] *** |Jedai| is now known as Jedai

[12:00] *** Jedai is now known as |Jedai|

[12:00] *** |Jedai| is now known as Jedai

[12:04] *** minazo joined
[12:16] *** eMaX_ left
[12:17] *** eMaX joined
[12:19] * LylePerl is still working on Camelia and should have something ready for evaluation later today

[12:22] *** eMaX left
[12:35] *** eMaX joined
[12:42] *** eMaX left
[12:43] *** eMaX joined
[12:45] *** masak left
[12:55] *** eMaX left
[12:59] *** eMaX joined
[13:05] *** SamB joined
[13:06] <pugs_svn> r26596 | ron++ | added implicit topic match tests RT #61662

[13:12] *** minazo left
[13:13] *** rblasch_ joined
[13:13] *** DemoFreak left
[13:14] *** rblasch left
[13:14] *** DemoFreak joined
[13:18] *** DemoFreak left
[13:18] <PerlJam> rakudo: role R { has $.x is rw; } ; role S does R { } ; class C does S does R {} ;

[13:18] *** DemoFreak joined
[13:18] <p6eval> rakudo 44e1ca: OUTPUT«A conflict occurred during role composition due to method 'x'.␤current instr.: '!meta_compose' pc -94773 ((unknown file):-1)␤»

[13:18] <PerlJam> bug?

[13:20] *** km2 left
[13:21] <jnthn> Yes.

[13:22] <jnthn> Parrot and Rakudo have different ideas about roles composed from other roles.

[13:22] <jnthn> erm, Parrot and Perl 6.

[13:25] <PerlJam> ah, there's already a ticket for it too

[13:27] *** c9s left
[13:36] *** Southen joined
[13:41] <Matt-W> Hello!

[13:42] <jnthn> hi, Matt-W 

[13:56] *** skids joined
[13:59] *** mberends left
[14:02] *** km2 joined
[14:04] *** nihiliad left
[14:07] <jnthn>  > say True

[14:07] <jnthn>  0

[14:07] <jnthn>  > say False

[14:07] <jnthn>  1

[14:07] <jnthn> .oO( There's more than one way to screw it up... )

[14:08] <fridim_> oO

[14:11] *** alester joined
[14:12] <Matt-W> hah

[14:12] <Matt-W> that's the shell programmer's true :)

[14:13] <jnthn> :-)

[14:13] <jnthn> We make it through the sanity tests now, which is nice. :-)

[14:14] <jnthn> (With the re-write of enums that I'm working on.)

[14:14] <jnthn> also class Foo does MyEnum { } and MyEnum.pick work.

[14:14] <Matt-W> yay

[14:14] <jnthn> Still got a bunch of functionality left to add in though.

[14:14] <Matt-W> what's the status of using enums defined in other modules?

[14:15] <jnthn> Didn't look at that just yet.

[14:15] <jnthn> Nor export.

[14:15] <Matt-W> okay

[14:15] <Matt-W> because I'm sure that behaviour changed recently

[14:15] <jnthn> In the spec, or in Rakudo?

[14:16] <Matt-W> In Form I seem to be able to say EnumName::value and get an enum defined in a module I'm using

[14:16] <Matt-W> whereas before I had to redefine the enum

[14:16] <Matt-W> neither seems right

[14:16] <Matt-W> in Rakudo

[14:16] <jnthn> I think there's at least one ticket on such things.

[14:17] *** c9s joined
[14:20] <Matt-W> okay

[14:20] <Matt-W> I'll worry about it if it's weird after your enum rewrite anyway

[14:21] *** exodist joined
[14:26] <LylePerl> Ok, we've worked really hard on the logo

[14:26] <LylePerl> I think we've come up with something everyone will be happy with:-

[14:26] <LylePerl> http://www.perlportal.com/logo/4.png

[14:27] *** kane_ joined
[14:27] *** abra left
[14:28] <LylePerl> Thoughts on it? :)

[14:28] <jnthn> lol :-)

[14:28] <jnthn> ...are the wings big enough to actually get the camel off the ground?

[14:28] <Matt-W> hmm does the O'Reilly trademark cover winged camels?

[14:29] <jnthn> When is a camel not a camel. :-)

[14:29] <LylePerl> jnthn: yeah, they flap really fast :)

[14:29] <Matt-W> I assume the camel has internal modifications to make it lighter

[14:30] <LylePerl> TimToady said about a Camel with wings, maybe I could sell this to O'Reilly?

[14:30] <LylePerl> But seriously, here are the ones we've done:-

[14:30] <LylePerl> http://www.perlportal.com/logo/camelia.html

[14:31] <LylePerl> Camelia has never looked so good :) Actually we got her looking better than we initially thought we'd be able to ;)

[14:39] * LylePerl watches tumble weed blow past...

[14:41] <Matt-W> oooh shiny camelia

[14:43] <LylePerl> The posts pmichaud pointed me to said about Tux, so we tried to style her a bit more that way

[14:44] * jnthn quite likes some of the ones towards the bottom

[14:44] <jnthn> 5, 7 and 8 are perhaps my favorites

[14:45] <LylePerl> I guess it all depends on whether TimToady likes it...

[14:45] <jnthn> ('cus they better capture the colorfulness of the original suggestion, but are a bit simplified/sylistic)

[14:45] <Matt-W> It doesn't really seem right to me though

[14:46] <pmichaud> fwiw, there is no more "Main"

[14:46] <pmichaud> (from scrollback)

[14:47] <Matt-W> as in module Main?

[14:47] <pmichaud> correct.

[14:47] <Matt-W> interesting

[14:47] <Matt-W> what is ther einstead

[14:47] <pmichaud> It's now GLOBAL

[14:47] <pmichaud> or, more precicely, CORE::GLOBAL

[14:48] <LylePerl> Matt-W: Not right in what way?

[14:48] <jnthn> pmichaud: Is there a class GLOBAL or just a module?

[14:49] *** _REPLeffect joined
[14:49] <pmichaud> module, I think.

[14:50] *** _REPLeffect is now known as REPLeffect

[14:50] <jnthn> pmichaud: OK, so non-anonymous methods outside of a class/role/grammar probably ought to be an error.

[14:53] <pmichaud> my first thought is "yes", but I'm never certain of such things :-)

[14:54] <jnthn> pmichaud: You'll be glad to know that enum_declarator in actions.pm has taken a serious gutting.

[14:54] <pmichaud> You're correct, I'm very glad to know that.  :-)

[14:54] <jnthn> As has enum.pir.

[14:54] <jnthn> Which probably as a tenth as much code.

[14:54] <jnthn> *has

[14:55] <pmichaud> that feels more correct.

[14:56] <pugs_svn> r26597 | jnthn++ | [t/spec] Reviewed an enums test; don't see anywhere in the spec that says you can cheat on enum values other than with the special cheating-allowed syntax, so correct the test in line with that.

[14:56] <jnthn> Of course, the infamous guts.pir gets longer. ;-)

[14:56] <jnthn> I notice a bunch of stuff got broken out into src/parrot/ too.

[14:57] <pmichaud> that's okay, I prefer guts (once) to output of actions.pm (many)

[14:57] <pmichaud> (src/parrot/)  yes, in order to help with .HLL mapping I decided we should break out the parrot hll stuff into its own section

[14:57] <jnthn> Makes sense.

[14:58] <jnthn> Our additions to Parrot's role.pir may not stand.

[14:58] <pmichaud> and in some sense, src/parrot/ may end up being "well, we really oughtn't to be doing this... but here's where we're doing things outside our sandbox."

[14:58] <jnthn> (Might well subclass it to add what we need.)

[14:58] <pmichaud> IM IN YR HLL NAMESPACE, MESSIN WITH YR CLASSES AND ROLEZ

[14:59] <pmichaud> anyway, it was an attempt to reduce the number of .HLL directives to two.

[14:59] *** nihiliad joined
[14:59] <pmichaud> (one at the beginning, one to switch back to 'parrot')

[14:59] <jnthn> Sure. Also it is good to know where we're messing with Parrot.

[15:00] <jnthn> Or doing stuff that will have effects wider than just Rakudo.

[15:01] *** Psyche^ joined
[15:01] <pmichaud> ah, looks like one of my YAPC::EU talks was accepted!  :-)

[15:02] <jnthn> Yeah, looks like one of mine too. :-)

[15:04] <pmichaud> now I just have to figure out how to get there.  :-|

[15:05] * jnthn doesn't recommend swimming

[15:07] *** amoc joined
[15:08] <Matt-W> yay!

[15:08] <Matt-W> Hire a boat and sail there

[15:16] *** ZuLuuuuuu joined
[15:16] *** minazo joined
[15:17] *** Patterner left
[15:17] *** Psyche^ is now known as Patterner

[15:18] <jnthn> Both Portugal and Texas are coastal. Sounds feasible. :-)

[15:18] <pmichaud> well, I'm a pretty good distance from the coast at the moment

[15:19] <pmichaud> 500 km

[15:21] <jnthn> "My state is SO big that..."

[15:22] <jnthn> rakudo: say True.WHAT; say True.perl; say True.name;

[15:22] <p6eval> rakudo 44e1ca: OUTPUT«()␤.new()␤Could not locate a method 'name' to invoke on class ''.␤current instr.: 'die' pc 16588 (src/builtins/control.pir:225)␤»

[15:22] <jnthn> ...well at least we get those right in my local Rakudo...

[15:28] *** justatheory joined
[15:31] <pmichaud> yay.

[15:32] <jnthn> oh, interesting

[15:32] <jnthn> > my $x = 0 but True; say $x; say $x.Bool; say $x.true; say ?$x;

[15:32] <jnthn> 0

[15:32] <jnthn> 1

[15:32] <jnthn> 0

[15:32] <lambdabot>   <no location info>: parse error on input `='

[15:33] <jnthn> So if .true and .Bool are 1, wtf is ? not?!

[15:33] <pmichaud> because it's still using the get_bool vtable, probably.

[15:33] * jnthn might try fixing that up later

[15:33] <pmichaud> right now we don't attempt to intercept get_bool for the built-in types

[15:34] <pmichaud> like Str, Int, Num, etc.

[15:34] <jnthn> It seems that whatever comes of the proposal from last night, anyway, .Bool is the thing that Really Decides.

[15:34] <jnthn> Or at least part of it.

[15:34] <pmichaud> until we decide that boolification/stringification need to be a step removed from .Bool/.Str

[15:35] <jnthn> Sure.

[15:35] <jnthn> Anyway, but True under current Rakudo explodes IIRC

[15:35] <jnthn> rakudo: say 0 but True; say "alive"

[15:36] <jnthn> oh yeah, it inf-loops. :-)

[15:36] <p6eval> rakudo 44e1ca:  ( no output )

[15:36] <jnthn> oops. 

[15:36] <jnthn> So, improvement.

[15:36] <pmichaud> yes, I'm very happy with an implementation that gets us closer to truth, even if we don't know what that truth is yet.

[15:36] <jnthn> OK, let's see what I make of the spec tests for enums now.

[15:37] <jnthn> omg I pass all of basic.t that passed before like, straight off...

[15:37] <jnthn> And anonymous.t and as-role.t...

[15:38] <jnthn> ah, thorough.t is a disaster.

[15:39] <pmichaud> surprisingly, the Texas Gulf Coast is only 25 mi closer to El Paso than the California Pacific Coast :-)

[15:39] <jnthn> !!

[15:41] *** PhatEddy joined
[15:42] <jnthn> my $texas_area = 696241; my $slovakia_area = 49035; say "There are { $texas_area / $slovakia_area} Slovakias in Texas."

[15:42] <jnthn> rakudo: my $texas_area = 696241; my $slovakia_area = 49035; say "There are { $texas_area / $slovakia_area} Slovakias in Texas."

[15:42] <p6eval> rakudo 44e1ca: OUTPUT«There are 14.198857958601 Slovakias in Texas.␤»

[15:43] <jnthn> rakudo: my $texas_area = 696241; my $vatican_area = 0.44; say "There are { $texas_area / $vatican_area} Vaticans in Texas."

[15:43] <p6eval> rakudo 44e1ca: OUTPUT«There are 1582365.90909091 Vaticans in Texas.␤»

[15:43] <jnthn> rakudo: my $popes = 1; my $vatican_area = 0.44; say "There are { $popes / $vatican_area } popes per square kilometer in the Vatican."

[15:43] <p6eval> rakudo 44e1ca: OUTPUT«There are 2.27272727272727 popes per square kilometer in the Vatican.␤»

[15:44] *** ZuLuuuuuu left
[15:45] <PhatEddy> There is already an RT for the example below - I would just like to verify that an empty string and uninitialized value warning would be OK behavior (sorry no foreigners here) 

[15:45] <PhatEddy> rakudo: sprintf "%s"

[15:45] <p6eval> rakudo 44e1ca: OUTPUT«Null PMC access in get_string()␤current instr.: 'parrot;Str;sprintf' pc 5137 (src/classes/Str.pir:87)␤»

[15:46] <PhatEddy> empty returned string and warning OK?

[15:46] <pmichaud> I would think it would return a Failure

[15:47] <PhatEddy> OK

[15:47] <pmichaud> which then becomes a warning if used.

[15:47] <jnthn> rakudo: enum A <B C>; say A.perl

[15:47] <p6eval> rakudo 44e1ca: OUTPUT«Null PMC access in get_string()␤current instr.: 'parrot;Role;Str' pc 3962 (src/classes/Role.pir:394)␤»

[15:48] <jnthn> huh

[15:48] <jnthn> Oh!

[15:48] <jnthn> We weren't even running thorough.t

[15:50] * jnthn does make spectest

[15:50] <jnthn> Ugh. Fail a bunch of Bool.t

[15:51] <PhatEddy> pmichaud: just one second thought - in perl5 my $x = sprintf("%d"); with no int gives a warning right away

[15:52] <jnthn> We have these tests:

[15:52] <jnthn> isa_ok(Bool::True, Bool);

[15:52] <jnthn> isa_ok(Bool::False, Bool);

[15:52] <jnthn> I think isa is the wrong thing to be checking here.

[15:52] <jnthn> Since enum elements are not instances.

[15:53] <jnthn> I think the test should be more like Bool::True ~~ Bool

[15:53] <pmichaud> PhatEddy: this is a somewhat fundamental difference between p6 and p5

[15:53] <PhatEddy> OK

[15:53] <pmichaud> where p5 would "warn immediately", p6 tends to return Failure objects that warn on use.

[15:55] * jnthn hears no disagreement and changes the tests.

[15:55] <pmichaud> sorry, was delayed

[15:55] <pmichaud> I'd be surprised if   Bool::True.isa(Bool)  didn't work.

[15:56] <jnthn> I don't see how it can.

[15:56] <jnthn> isa tests inheritance relationships.

[15:56] <pmichaud> I thought it tested type membership.

[15:56] <pmichaud> (too)

[15:57] <pmichaud> rakudo:  say 3.isa(Int);

[15:57] <p6eval> rakudo 44e1ca: OUTPUT«1␤»

[15:59] *** Psyche^ joined
[15:59] <jnthn> I saw it as more "is an instance of X or something inheriting from it"

[15:59] <pmichaud> sure.  But most people tend to think of True,False as being instances of Bool

[16:00] <pmichaud> that might not be the case in Perl 6, but people will be surprised by that.

[16:00] <jnthn> Most people should probably get used to using infix:<~~> when they aren't sure what specific test they want.

[16:00] <pmichaud> It's not just that... the methods on Bool differ from a normal enum.

[16:00] <pmichaud> at least, I _think_ they differ.

[16:01] <jnthn> Yeah apart from when the spec says they aren't.

[16:01] <jnthn> S12 clear says enum Bool <False True>

[16:01] <jnthn> And I'm pretty sure TimToady referred to it as an enum last night too.

[16:02] <pmichaud> I wonder if that's actually a fossil.

[16:02] <pmichaud> hmmm.

[16:03] <pmichaud> okay, yes, it was referenced as an enum last night.

[16:04] <jnthn> Oh, hmm

[16:04] <jnthn> The other special thing is that True++ is meant to just stay as True.

[16:04] <jnthn> (e.g. it defines .succ as a no-op)

[16:04] <pmichaud> yes, that's one of the places wehre the method is different.

[16:05] <pmichaud> We also had (from last night):  http://irclog.perlgeek.de/perl6/2009-04-30#i_1107870

[16:05] <jnthn> That makes True a subset type.

[16:05] <pmichaud> True is Bool where { 1 }

[16:05] <pmichaud> right.

[16:05] <pmichaud> which wouldn't be an enum.

[16:05] <jnthn> Which you then went on to say

[16:05] <jnthn> True isn't a type.

[16:06] <pmichaud> I was talking specifically with respect to smart matching there

[16:06] <jnthn> You can't have it be a type and not a type.

[16:06] <pmichaud> True.

[16:07] *** Patterner left
[16:07] *** Psyche^ is now known as Patterner

[16:07] <pmichaud> But the fact that it was mentioned as a subset type means I'm not sure how strongly it's tied to being an enum.  

[16:07] <jnthn> I'd kinda like it to be an enum. But we can easily just do something custom.

[16:07] <pmichaud> The ability to correctly handle .succ and .pred comes to mind.

[16:07] <jnthn> But the moment I make this not an enum type, is where but True won't work again.

[16:08] <jnthn> Unless I implement last night's additions to S14, that is.

[16:08] <pmichaud> so, is this a question of test regression, or one of getting a correct implementation of Bool?  (more)

[16:08] <jnthn> (It hasn't worked before now, so it's not a problem...)

[16:09] *** amoc left
[16:09] <pmichaud> ah.

[16:09] <jnthn> Well, I fail tests now.

[16:09] <pmichaud> To me,  "but True" and "but 42" ought to be using the same mechanism.

[16:09] <jnthn> Because by getting enums more correct, they don't fit Bool as well as they did.

[16:10] <jnthn> OK, how about we try: (more)

[16:10] <jnthn> 1) We make Bool not be an enum in Rakudo, so it can keep its special behavior.

[16:10] <pmichaud> at this stage, I think that having "but True" working is relatively less important than being able to properly perlify/stringify enum types

[16:10] <pmichaud> and being able to properly report .WHAT and .isa membership on True/False values.

[16:11] <jnthn> .WHAT is fine.

[16:11] <jnthn> It's .isa that's an issue.

[16:11] <pmichaud> anyway, I'm in agreement with your (1)

[16:12] <jnthn> I was going to say then 2) implement what was dded to S14 so we can see how it actually works out.

[16:13] <pmichaud> I'm fine with that too as a testing measure to see how it works.  My gut says it's not going to survive in its current form.

[16:13] *** alanhaggai joined
[16:13] <pmichaud> (what was added to S14, that is)

[16:13] <jnthn> No, but if it's going to change then co-ercion and perhaps other stuff will have to change as well.

[16:14] <pmichaud> There's that also.  Being able to coerce to a nested-package-type is an interesting question.

[16:14] <jnthn> Well, all the mechanism in S14 is really doing is saying "this is how I coerce to this type"

[16:15] <jnthn> So AFAICT the solution for that just mirrors the solution for coercion.

[16:15] <pmichaud> sure.

[16:15] <jnthn> $foo."X::Y" is valid syntax to call a method literally named X::Y

[16:16] <pmichaud> anyway, based on what I've seen in rt reports and on-channel, the priority would be

[16:16] <jnthn> Thing is that method X::Y() { } is not valid for declaring a method of that name.

[16:16] <pmichaud> (1) stringification of enums and correct reporting of enum types

[16:16] <pmichaud> (2) .succ/.pred on Bool values

[16:16] <pmichaud> (3) getting "0 but True" to work

[16:16] <pmichaud> (in that order)

[16:16] <jnthn> stringification of enums themselves, or their values?

[16:17] <jnthn> Their values stringify just to the value.

[16:17] <jnthn> .name and .perl are what were missing that I think people were interested in (and .WHAT too)

[16:17] <jnthn> All of which I've got right now.

[16:17] <pmichaud> so, in

[16:18] <pmichaud> enum Foo < alpha beta gamma >

[16:18] <pmichaud> stringifying beta would give "1"  ?

[16:18] *** fridim_ left
[16:18] <jnthn> Yes.

[16:18] <jnthn> and beta.name would give beta

[16:18] <pmichaud> Hmm.  That doesn't match something I read before.

[16:19] <pmichaud> okay, I see that in the spec now.

[16:19] <jnthn> For any enum value of an object type, the object itself knows its own

[16:19] <jnthn> type, so the C<.perl> method will return its long name, while C<.name>

[16:19] <jnthn> returns its short name.  Other than that, number valued enums act

[16:19] <jnthn> just like numbers, while string valued enums act just like strings.

[16:19] <pmichaud> okay, excellent.

[16:19] <jnthn> So provided that bit of the spec is right... :-)

[16:20] <pmichaud> so assuming that True/False are enums:   say True;  # "1"

[16:20] <jnthn> Yes, but we can't assume that any more. :-)

[16:20] <pmichaud> well, even if they aren't enums,  having   ~True return "1" would still seem valid for now (i.e., until we hear otherwise)

[16:20] <jnthn> Meh. Bool has flip-flopped between "enum" and "not an enum" so many itmes...

[16:21] <pmichaud> anyway, yes, I was thinking of stringifying enums along the lines of .name and .perl (i.e., what people were interested in)

[16:22] <jnthn> OK, then hopefully I make some people happy. :-)

[16:22] <pmichaud> Definitely me.

[16:23] <pmichaud> rakudo:  say "pmichaud \c[SMILE]";

[16:23] <p6eval> rakudo cc1c74: OUTPUT«pmichaud ⌣␤»

[16:23] <jnthn> OK, so now we're back to Rakudo's Bool just being whats in Bool.pir

[16:24] <jnthn> Bemusignly, enum.pir and what's in there were intereacting in the strangest of ways...

[16:24] <pmichaud> Heh.

[16:24] <jnthn> Which just happened to sort of work.

[16:26] <jnthn> OK, we pass bool.t again now

[16:26] * jnthn spectests

[16:30] *** meteorjay left
[16:32] *** ejs left
[16:34] <jnthn> My wrod we're close to 11,000 tests passing...

[16:36] <pmichaud> lunchtime here -- bbiaw

[16:42] *** abra joined
[16:49] *** ejs joined
[16:51] *** eternaleye left
[16:55] <literal> @tell mberends http://sial.org/pbot/36310

[16:55] <lambdabot> Consider it noted.

[16:58] <jnthn> pmichaud: You'll like this:

[16:58] <jnthn> 7 files changed, 224 insertions(+), 442 deletions(-)

[17:00] <pugs_svn> r26598 | jnthn++ | [t/spec] Unfudge some enums tests that we now pass; add a test for .WHAT on an enum value.

[17:08] *** ZuLuuuuuu joined
[17:14] * LylePerl wonders when TimToady will see the Camelia designs

[17:15] <LylePerl> the suspense is kill me :/

[17:23] <skids> So is "but Failure" going to work soon then?

[17:24] *** me1970 joined
[17:26] <jnthn> That needs Failure to become a role.

[17:30] <japhb> Is github riding the fail whale right now, or is it just me unable to pull?

[17:32] <pugs_svn> r26599 | jnthn++ | [t/spec] Tweak and mostly fudge S12-enums/thorough.t.

[17:34] *** DemoPhreak joined
[17:34] *** DemoFreak left
[17:34] <pugs_svn> r26600 | jnthn++ | [t/spec] Add test for RT#63878.

[17:35] *** rblasch__ joined
[17:38] <jnthn> japhb: I pushed just a moment ago...

[17:39] <japhb> jnthn: And I just tried again, and it worked fine.  Sixth time is the charm, I guess ....

[17:40] <pmichaud> do we need "but Failure"?

[17:40] <pmichaud> I guess we do if we want to return more interesting values of things.

[17:41] <pmichaud> converting Failure to be a role in Rakudo would be a Good Thing.  I wonder if we could even get it into the Setting.

[17:41] <jnthn> pmichaud: I'm not sure we need but Failure, but it would just automatically work.

[17:42] <jnthn> (Once Failure became a role.)

[17:42] <pmichaud> I'm might look into that this weekend.

[17:42] <pmichaud> s/I'm/I/

[17:43] <jnthn> Cool

[17:43] <japhb> jnthn: Since we're both here ... did you get 'constant foo is export' working this week?

[17:43] <jnthn> japhb: Not yet, but the week hasn't yet ended. ;-)

[17:43] <japhb> True!

[17:44] <jnthn> japhb: The more I think about it though, the more I realize it's not completely trivial.

[17:44] * japhb holds out hope.  :-)

[17:44] <jnthn> Since Rakudo needs to know about the constant at compile time when importing it.

[17:44] <japhb> OK ... how about an eval adverb that doesn't introduce a new scope?

[17:44] <japhb> I'll fake what I need that way.  :-)

[17:45] <jnthn> Heh, that'd be harder than fixing up the importer. :-P

[17:45] <pmichaud> eval doesn't have a way to modify an existing scope.  Parrot doesn't even allow it (with its current lexical implementation)

[17:45] <japhb> awww

[17:45] <pugs_svn> r26601 | ron++ | add tests for missing argument and %C format: RT #62316 and RT #60672

[17:45] <japhb> *sigh*

[17:46] <jnthn> We get away with importing subs now since we don't need to know about them at parse time.

[17:46] <pmichaud> in fact, that's the reason why the REPL loop doesn't/can't easily remember lexically declared variables.

[17:47] *** payload joined
[17:47] <japhb> ... which brings me back to textual include

[17:48] <pmichaud> what do you need from constant that couldn't be done with, say, a package variable?

[17:49] <japhb> pmichaud: I've got several thousand constants ... I'd like to have them resolved away to ints at compile time.

[17:49] <japhb> And FWIW, it takes a LONG time for Rakudo to parse those constants.

[17:49] <pmichaud> japhb: afaik, that's not even happening now with our 'constant' declarator.

[17:50] <pmichaud> (it will eventually, yes, but I'm not sure it's happening at the moment.)

[17:50] <japhb> pmichaud: jnthn was discussing that as a possibility for near-term work.  And if he is going to work on that, I didn't want to write all my code twice.

[17:50] <pmichaud> fair enough.

[17:51] <pmichaud> I'm not sure that resolving them to ints will provide much of a performance improvement, fwiw.

[17:52] <pmichaud> not even in the near term.

[17:52] <japhb> Normally I wouldn't expect so ... but if I compile my code down to a .pbc, then at load time, Parrot won't be dealing with creating/managing thousands of events.

[17:52] <japhb> s/events/variables/

[17:52] <pmichaud> yes, it still will.

[17:52] <pmichaud> in fact, it'll have to create more PMCs.

[17:52] <japhb> ???

[17:52] *** rblasch_ left
[17:52] <japhb> Why?

[17:52] <pmichaud> let's consider:    constant $x = 3;

[17:53] <pmichaud> and:   my $y = 4 + $x;

[17:53] <pmichaud> with constant replacement, rakudo will produce code that looks like

[17:53] <pmichaud> $P0 = 'infix:+'(4, 3)

[17:53] <pmichaud> when that gets executed, Parrot will create Int PMCs for both the 4 and the 3

[17:54] *** silug left
[17:54] <japhb> wha?

[17:54] <pmichaud> to be passed along to 'infix:+'

[17:54] <japhb> oh.  I see.

[17:54] <pmichaud> without constant replacement, rakudo will produce

[17:54] <japhb> So basically, resolve to int does nothing without constant folding.

[17:54] <pmichaud> $P0 = find_lex '$x'

[17:54] *** donaldh joined
[17:54] <pmichaud> $P1 = 'infix:+'(4, $P0)

[17:55] <japhb> And the '4' does not get promoted?

[17:55] <pmichaud> in this case, Parrot will create the constant 3 for $x only once, and re-use that same PMC every time it's used in an expression (instead of creating a new one each time)

[17:56] <japhb> Then the performance difference if any just comes down to find_lex versus box opcodes, yes?

[17:56] <pmichaud> yes

[17:56] *** silug joined
[17:56] <pmichaud> but find_lex will likely be much easier on the system than box, because we create far fewer gc-able objects.

[17:56] <japhb> nodnod

[17:56] <japhb> Those were exactly what I was trying to avoid.

[17:57] <pmichaud> so, at least as things stand now, simply resolving constant values at compile time may produce a performance loss instead of a win.

[17:57] <japhb> That ... bites.

[17:58] <pmichaud> when we do a lot more advanced analysis, such as constant folding, or providing specialized versions of common methods that don't involve the autoboxing, we might get some improvements.

[17:58] <japhb> nod

[17:58] *** jbt joined
[17:58] <japhb> For some reason I thought constant folding was already a done deal.

[17:58] <jnthn> constant is not going to be any more efficient right now.

[17:58] <japhb> And I didn't even think of the case that 3 + 4 would involve two box ops.

[17:58] <jnthn> In the long run, I'd hope it won't.

[17:59] <japhb> jnthn: nod.  But at least the syntax and semantics are better.

[17:59] <jnthn> (We'd fold it at compile time.)

[17:59] <jnthn> constant is your way of saying to a future Rakudo, what it can optimize.

[17:59] <pmichaud> (we fold at compile time if we can determine that there's not a custom infix:<+> that is in scope)

[18:00] <japhb> pmichaud: 'we will' or 'we already do'

[18:00] <japhb> ?

[18:00] <pmichaud> we will.

[18:00] <japhb> ah, gotcha.

[18:00] <pmichaud> we don't do much in the way of optimization at the moment.

[18:00] <pmichaud> we're still just getting all of the mmd stuff in place.

[18:00] <pmichaud> (jnthn++ for that)

[18:00] <jnthn> pmichaud: note that writing a my multi infix:<+>(Int, Int) is only going to get you a conflict.

[18:00] <jnthn> erm, ambiguous dispatch

[18:01] <jnthn> Since there already is one.

[18:01] <jnthn> (We clone the outer/existing set of candidates and add our new ones)

[18:01] <pmichaud> jnthn: but there could be a   sub infix:<+>(Any, Any)

[18:01] <pmichaud> (non-multi)

[18:01] <jnthn> Oh, yes, that's true.

[18:01] <jnthn> my sub, but yes.

[18:04] * jnthn is happy with the number of enum related tickets he's being able to close, or to assign to moritz for spectests

[18:04] <pmichaud> me too.

[18:06] *** donaldh left
[18:07] <PhatEddy> just saw the em about :Trig and noticed that t/spec/S32-trig/trig.t and t/spec/S32-num/exp.t 'use Num :Trig'

[18:08] <jnthn> PhatEddy: In that case I think the ticket is well and truly closeable.

[18:08] <pmichaud> PhatEddy++  # keeping up with RT

[18:08] <jnthn> PhatEddy: Do you have privs to do it, or shall I?

[18:09] <PhatEddy> I don't have such privs as of now.

[18:10] <jnthn> resolved - thanks :-)

[18:11] *** masak joined
[18:12] <masak> today truly is enum fixing day.

[18:12] <masak> maybe after this, I'll start using enums in my programs.

[18:12] <jnthn> Yeah, I realized just how many tickets we had relating to them.

[18:12] *** gravity left
[18:13] *** jferrero joined
[18:14] <masak> rakudo: enum Rakudo <good cool awesome bad ugly weird>; say Rakudo.pick

[18:14] <p6eval> rakudo f934db: OUTPUT«3␤»

[18:14] <masak> rakudo: enum Rakudo <good cool awesome bad ugly weird>; say Rakudo.pick.perl

[18:14] <jnthn> :-)

[18:14] <p6eval> rakudo f934db: OUTPUT«[Rakudo::weird]␤»

[18:14] <masak> :P

[18:14] <jnthn> Well done Rakudo. :-)

[18:14] <masak> still werid, Rakudo.

[18:14] <jnthn> Normality is way overrated.

[18:14] <masak> s/ri/ir/

[18:14] <masak> aye, sooth.

[18:16] <masak> rakudo: say <<:a(1)>>.perl

[18:16] <p6eval> rakudo f934db: OUTPUT«":a(1)"␤»

[18:17] * masak reports rakudobug

[18:17] <jnthn> I wondered how long that would take. :-)

[18:18] <masak> it's a dirtly job, but somebody's gotta do it.

[18:18] <masak> wohoo, ranges of enums! jnthn++

[18:19] <pugs_svn> r26602 | jnthn++ | [t/spec] Tests for enum (i => 1, v => 5...) style stuff.

[18:20] <jnthn> rakudo: rakudo: enum A <a b>; say (a < *).WHAT

[18:20] <p6eval> rakudo f934db: OUTPUT«Statement not terminated properly at line 1, near ": enum A <"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[18:20] <TimToady> my multi is supposed to hide an outer multi of the same longname, not conflict

[18:20] <jnthn> TimToady: ah, that's a pain.

[18:21] <TimToady> it's specced

[18:21] <jnthn> It's still a pain. :-P

[18:21] <jnthn> rakudo: enum A <a b>; say (a < *).WHAT

[18:21] <p6eval> rakudo f934db: OUTPUT«Block()␤»

[18:22] <jnthn> rakudo: enum A <a b>; say (a < *).(-1)

[18:22] <p6eval> rakudo f934db: OUTPUT«0␤»

[18:22] <jnthn> rakudo: enum A <a b>; say (a < *).(2)

[18:22] <p6eval> rakudo f934db: OUTPUT«1␤»

[18:22] <jnthn> rakudo: 1 < *

[18:22] <p6eval> rakudo f934db:  ( no output )

[18:22] <jnthn> rakudo: enum A <a b>; a < *

[18:23] <p6eval> rakudo f934db:  ( no output )

[18:23] <jnthn> OK, I think 63880 is ok

[18:23] <masak> rakudo: say (*).perl

[18:23] <p6eval> rakudo f934db: OUTPUT«!whatever_dispatch_helper␤»

[18:23] <masak> !

[18:23] <masak> how long did you expect to hide that one from me? :P

[18:24] <jnthn> Damm!

[18:24] <masak> now I really caught you out.

[18:24] <jnthn> rakudo: enum A <a b>; say a < * # why you htink I didn't try this one ;-)

[18:24] <p6eval> rakudo f934db: OUTPUT«!whatever_helper_right␤»

[18:25] <masak> right.

[18:25] <masak> whatever.

[18:25] <jnthn> What should a block stringify to anyways?

[18:25] <masak> its contents?

[18:25] <TimToady> LylePerl: the 2nd camelia with rounded line is nice, though loses some of the woggliness that is bit charming. also, you lost the asymmetric smile, which is a no-no

[18:26] <jnthn> masak: that's .perl

[18:26] <jnthn> rakudo: sub foo { }; say &foo

[18:26] <p6eval> rakudo f934db: OUTPUT«foo␤»

[18:26] <jnthn> rakudo: my $x = { }; say $x;

[18:26] <masak> jnthn: well, I did do (*).perl

[18:26] <p6eval> rakudo f934db: OUTPUT«␤»

[18:26] <TimToady> the rest of them seem to be devolution to the forms that camelia went through to get where she is; she used to have a face more like a smiley, and the bugout eyes and asymmetric smile were added to get away from ☻

[18:27] <jnthn> masak: I'm not sure if *.perl and (*).perl are different...

[18:27] <TimToady> and frankly, I think the latter ones would look scary to a kid

[18:28] <masak> jnthn: I think they might be.

[18:28] <masak> jnthn: the former is like *.uc, no?

[18:28] <jnthn> Yeah, but we're currently treating the seoncd one like that too...

[18:28] <masak> ok.

[18:28] <jnthn> We're not doing it syntacticly.

[18:28] <pmichaud> iirc, method dispatch on Whatever is what creates the closure.

[18:28] <jnthn> Right.

[18:29] <masak> jnthn: I see your point now.

[18:29] <pmichaud> however, it does result in odd things with something like  *.Str.perl

[18:29] <pmichaud> because that ends up meaning  { $_.Str }.perl

[18:30] <pmichaud> which of course is different from  $_.Str.perl

[18:30] <masak> rakudo: say (*).WHAT.substr(0,-2).subst(/....$/,{"-{.uc}."})

[18:30] <p6eval> rakudo f934db: OUTPUT«What-EVER.␤»

[18:30] <TimToady> maybe there needs to be a type that is both Whatever and Closure

[18:30] <jnthn> pmichaud: Part of me wonders if rather than *.perl => { $_.perl } we want *.perl => * but role { postcircumfix:<( )> { $_.perl } } or similar.

[18:31] <jnthn> So then they just stack up around it.

[18:31] <TimToady> yes, but we have to be able to distinguish bare Whatever from Whatever{block}

[18:31] <TimToady> maybe it's a WHENCE :)

[18:31] <jnthn> TimToady: Why?

[18:31] <TimToady> @foo[*] vs @foo[*-1]

[18:31] <lambdabot> Unknown command, try @list

[18:32] <jnthn> Ah, true.

[18:32] <jnthn> WhateverClosure

[18:32] <jnthn> or whatever

[18:32] <jnthn> :-)

[18:32] <jnthn> The alternative (which I don't like much) is that *.foo.bar chains become a special syntactic form.

[18:32] <TimToady> Blotever

[18:32] <TimToady> don't like that either

[18:32] <jnthn> Good. :-)

[18:33] <TimToady> the particular problem with turning into Closure/Block is that not all methods are ignorant of that data type

[18:33] <TimToady> like .perl, though it may barf

[18:34] <TimToady> but expectation is that {...}.perl reproduces the block

[18:34] <TimToady> and doubtless Code has other methods that it recognizes

[18:34] <TimToady> {...}.arity .count etc

[18:35] <TimToady> so what does *.foo.arity mean then?

[18:35] <TimToady> even if we have Blockever, do we dispatch to Whatever or to Code?

[18:36] <TimToady> or is it a Code that isa Whatever, so it just dwims mostly

[18:37] <jnthn> Blockever is Whatever is Code

[18:37] <jnthn> Perhaps

[18:37] <TimToady> no, then *.foo.arity defaults to { $_.foo.arity }, which is probably not intended

[18:37] <TimToady> probably meant {$_.foo}.arity in that case

[18:38] <TimToady> so Blockever is Code is Whatever is what I was thinking

[18:38] <TimToady> and it hits Whatever only if no .arity, .count, etc

[18:38] <TimToady> I dunno, it's another DIHWIDT

[18:39] <TimToady> maybe I should talk about doctors this year at oscon

[18:39] <TimToady> "first of all do no harm", and all that :)

[18:41] <TimToady> but I suppose I can argue it the other way too, and *.foo just adds in .() responder, as jnthn suggested

[18:41] <TimToady> as long as it's also distinguishable by type

[18:41] <jnthn> Defaulting to { $_.foo.arity } feels OK to me...

[18:41] *** yar joined
[18:41] <TimToady> yes, avoids a non-linearity

[18:42] *** yar is now known as Guest24540

[18:42] <TimToady> maybe it's a Codever

[18:42] <jnthn> if any(map *.hanldler.arity, @thingies) == $wanted { }

[18:42] <TimToady> not to be confused with Codliver

[18:42] <TimToady> or Cadaver

[18:43] *** Guest24540 is now known as yari

[18:44] <ZuLuuuuuu> Hi folks, I wrote an article to an online Turkish magazine to introduce Perl 6 to Turkish programmers :) http://e-bergi.com/2009/Mayis/Gelisim-Sureci-ve-Yenilikler (This is part 1, part 2 will be published next month.)

[18:46] <masak> ZuLuuuuuu: looks nice.

[18:46] <TimToady> Perhaps this is not a time to confess that I know Greek better than Turkish  :)

[18:46] <ZuLuuuuuu> :)

[18:46] <ZuLuuuuuu> thanks, we share a lot of words between Greek and Turkish actually :D

[18:47] <TimToady> as for my picture, that's about as Turkish as I ever look.  :)

[18:47] <TimToady> I assume it has something about flying mugs, since Jon's picture is in there :)

[18:47] <ZuLuuuuuu> yes actually your mustaches makes you look as a typical Turkish guy :)

[18:48] <TimToady> though the shirt looks like I came out of a harem :)

[18:49] <ZuLuuuuuu> Yes, the article starts with the story how the whole Perl 6 project started (includes the mug story too) then continues with the installation of Parrot and Rakudo and starts giving the differences of Perl 5 and Perl 6

[18:49] *** ejs left
[18:49] *** PhatEddy left
[18:49] *** alester left
[18:49] *** Eevee left
[18:49] *** samlh left
[18:49] *** cls_bsd left
[18:49] *** dalek left
[18:49] *** xinming left
[18:49] *** hcchien left
[18:49] *** r0bby left
[18:49] *** frettled left
[18:49] *** rhr left
[18:49] *** s1n left
[18:49] *** ascent_ left
[18:49] *** SamB left
[18:49] *** lumi left
[18:49] *** clkao left
[18:49] *** scook0 left
[18:49] *** estrabd left
[18:49] *** gfldex left
[18:49] *** lisppaste3 left
[18:49] *** me1970 left
[18:49] *** justatheory left
[18:50] *** kane_ left
[18:50] *** charsbar left
[18:50] *** diakopter left
[18:50] *** phenny left
[18:50] *** Woody2143 left
[18:50] <ZuLuuuuuu> Yes, the article starts with the story how the whole Perl 6 project started (includes the mug story too) then continues with the installation of Parrot and Rakudo and starts giving the differences of Perl 5 and Perl 6

[18:50] <ZuLuuuuuu> part 1 mentiones about the arguably small differeces

[18:50] <TimToady> looks pretty clean; I didn't notice any typos :)

[18:51] *** samlh joined
[18:51] *** PhatEddy joined
[18:51] *** me1970 joined
[18:51] *** justatheory joined
[18:51] *** kane_ joined
[18:51] *** charsbar joined
[18:51] *** phenny joined
[18:51] *** diakopter joined
[18:51] *** Woody2143 joined
[18:51] <ZuLuuuuuu> part 2 will mention about smart matching rules grammers hyper operators

[18:51] *** SamB joined
[18:51] *** lumi joined
[18:51] *** clkao joined
[18:51] *** lisppaste3 joined
[18:51] *** scook0 joined
[18:51] *** estrabd joined
[18:51] *** gfldex joined
[18:51] *** alester joined
[18:51] <TimToady> and it makes it look like the Unicode handling is natural

[18:52] *** dalek joined
[18:52] *** xinming joined
[18:52] *** hcchien joined
[18:52] *** s1n joined
[18:52] *** ascent_ joined
[18:52] *** rhr joined
[18:52] *** frettled joined
[18:52] <ZuLuuuuuu> :D

[18:52] *** cls_bsd joined
[18:52] <ZuLuuuuuu> :) yes, actually the examples including Turkish characters aren't displayed correctly on terminal :)

[18:52] <masak> rakudo: say 'yılına'.uc

[18:52] *** ejs joined
[18:52] <p6eval> rakudo f934db: OUTPUT«Y

[18:53] <masak> hm, partial output?

[18:53] <pmichaud> I call p6eval bug.  Or Parrot bug.

[18:53] <ZuLuuuuuu> I got funny letters instead

[18:53] <masak> pmichaud: nod.

[18:53] <pmichaud> or even irc bug.  :-)

[18:53] * masak investigates locally

[18:54] *** me1970 left
[18:54] <pmichaud> $ cat x

[18:54] <pmichaud> say 'yılına'.uc

[18:54] <pmichaud> $ ./perl6 x

[18:54] <pmichaud> YILINA

[18:54] <masak> good.

[18:54] <ZuLuuuuuu> wow it is correct

[18:54] * masak got 'no ICU lib loaded' locally

[18:54] <ZuLuuuuuu> say 'ışığa'.uc

[18:54] <ZuLuuuuuu> perl6: say 'ışığa'.uc

[18:55] <p6eval> rakudo f934db: OUTPUT«I

[18:55] <p6eval> ..elf 26602, pugs: OUTPUT«IŞIĞA␤»

[18:55] <ZuLuuuuuu> perl6: say 'ışığa'.uc;

[18:55] <pmichaud> say 'ışığa'.uc

[18:55] <pmichaud> $ ./perl6 y

[18:55] <pmichaud> I^$ 

[18:55] <pmichaud> my font doesn't know what to do there.

[18:55] <p6eval> rakudo f934db: OUTPUT«I

[18:55] <p6eval> ..elf 26602, pugs: OUTPUT«IŞIĞA␤»

[18:55] <ZuLuuuuuu> ğugs gives correct result

[18:55] <ZuLuuuuuu> pugs

[18:56] <pmichaud> oh, ouch... rakudo on my system is outputting ucs2 for that one.

[18:56] <LylePerl> TimToady: notes taken, we'll make adjustments and get back

[18:57] <pmichaud> I wonder if rakudo should generally default its output to utf8.

[18:57] <pmichaud> I wonder if Parrot even lets me do that.

[18:58] <ZuLuuuuuu> you would make us very happy utf-8 would be default everywhere possible :)

[19:00] * pmichaud experiments.

[19:01] *** dalek left
[19:01] *** dalek joined
[19:02] <pmichaud> Parrot's .uc changes string encoding:  http://nopaste.snit.ch/16466

[19:04] <TimToady> parrot has tended to fall into the ruby mindset that any character set is as good as any other :/

[19:04] <TimToady> apparently it feels that way about encodings too...

[19:05] <pmichaud> well, I don't mind too much if Parrot changes the encoding to ucs2 here -- that's a bit faster at any rate -- but we do want it to be utf8 on output, I suspect.

[19:06] <TimToady> we want I/O to be *well typed*

[19:07] <TimToady> but for the western world, utf-8 is a pretty good default

[19:07] <TimToady> far east may well prefer utf-16 for their default

[19:07] *** Casan joined
[19:08] <TimToady> but we can't have I/O handles just guessing

[19:10] <yari> hi all, I'm a p6 beginner, looking at some of the emails on perl6-compiler about enums, with a beginner q-

[19:10] <yari> given something like "enum Muses <Calliope Clio Erato Euterpe etc>"

[19:11] * TimToady waits...

[19:11] <yari> can one ask the type of "Clio" - or another enum- and get back a string saying "Muses"

[19:11] <yari> I don't know why I'd want to, just want to know if / how

[19:11] <pmichaud> rakudo:  enum Muses <Calliope Clio Erato Euterpe>;  say Clio.WHAT

[19:11] <p6eval> rakudo f934db: OUTPUT«Muses␤»

[19:12] * pmichaud wonders if that should have parens.

[19:12] <jnthn> pmichaud: Yeah

[19:12] <jnthn> pmichaud: It's not just enums, its any role.

[19:12] <jnthn> pmichaud: On my todo list.

[19:12] <yari> On my local build, that says "()" without the "Muses"

[19:12] <TimToady> Clio is supposed to end up an immutable value of class/role Muses

[19:13] <jnthn> TimToady: That *does* role Muses, no?

[19:13] <jnthn> It's base type is Int in this case.

[19:13] *** jferrero left
[19:13] <pmichaud> yari: the changes to enums were just made a few hours ago -- have you recently updated?

[19:14] <jnthn> Well, ish. :-)

[19:14] <pmichaud> yari: you might also need to "make realclean; perl Configure.pl --gen-parrot"  to get the correct version of parrot.

[19:14] <yari> it was pretty recent (this morn) but I can try again, who knows who won that race!

[19:14] <TimToady> Why shouldn't the type be Muses?  it just num/strifies to 1

[19:14] *** PhatEddy left
[19:14] <TimToady> if the object is not well typed, how is $x.name supposed to work?

[19:15] <yari> yup src/builtins/enums.pir was out of date here, rebuilding

[19:15] <jnthn> TimToady: The spec says:

[19:15] <jnthn> For any enum value of an object type, the object itself knows its own

[19:15] <jnthn> type, so the C<.perl> method will return its long name, while C<.name>

[19:15] <jnthn> returns its short name.  Other than that, number valued enums act

[19:15] <jnthn> just like numbers, while string valued enums act just like strings.

[19:15] *** Infinoid joined
[19:15] <jnthn> If they're going to act like numbers and strings, they'd best just be numbers/strings.

[19:15] <jnthn> With enum-ness mixed in.

[19:15] <TimToady> doesn't folow

[19:15] <TimToady> *follow

[19:15] <jnthn> I went down the other road with the previous implementation and it was a Bad Idea.

[19:16] <TimToady> they act like numbers or strings only when *asked* to act like numbers or strings

[19:16] <TimToady> they're still objects, albeit immutable

[19:16] *** PhatEddy joined
[19:16] <jnthn> So are numbers and strings...

[19:17] <jnthn> rakudo: enum Day <Mon Tue Wed>; multi x(Int $x) { say "ok" }; x(Mon)

[19:17] <p6eval> rakudo f934db: OUTPUT«ok␤»

[19:17] <jnthn> rakudo: enum Day <Mon Tue Wed>; multi x(Day $x) { say "ok" }; x(Mon)

[19:17] <p6eval> rakudo f934db: OUTPUT«ok␤»

[19:17] <TimToady> now put both

[19:18] <jnthn> rakudo: enum Day <Mon Tue Wed>; multi x(Day $x) { say "ok 1" }; multi x(Int $x) { say "ok 2" }; x(Mon)

[19:18] <p6eval> rakudo f934db: OUTPUT«ok 2␤»

[19:18] <TimToady> is wrong

[19:18] <pmichaud> rakudo:  say Day ~~ Int

[19:18] <p6eval> rakudo f934db: OUTPUT«Could not find non-existent sub Day␤current instr.: '_block14' pc 79 (EVAL_16:51)␤»

[19:18] <jnthn> rakodu: say Day ~~ Int; say Int ~~ Day;

[19:18] <pmichaud> rakudo:  enum Day <Mon Tue Wed>; say Day ~~ Int

[19:18] <p6eval> rakudo f934db: OUTPUT«0␤»

[19:19] <jnthn> rakudo:  enum Day <Mon Tue Wed>; say Int ~~ Day

[19:19] <p6eval> rakudo f934db: OUTPUT«0␤»

[19:19] <jnthn> wtf? Thsoe two candidates shoudl be tied then...

[19:19] <jnthn> OH

[19:20] <jnthn> It's becasue of a bug i'm still working on.

[19:20] <pmichaud> naively I would expect Day.does(Int) ... is that correct?

[19:20] <TimToady> I think we should make it correct

[19:20] <jnthn> rakudo:  enum Day <Mon Tue Wed>; say Mon ~~ Day

[19:20] <p6eval> rakudo f934db: OUTPUT«1␤»

[19:20] <TimToady> since everyone else will expect it too

[19:20] <pmichaud> in that case, naively I would think that   Day is Int  :-)

[19:20] <jnthn> That can be done, and yes, it would resolve teh ambiguity.

[19:21] <jnthn> rakudo:  enum Day <Mon Tue Wed>; say Mon ~~ Int

[19:21] <p6eval> rakudo f934db: OUTPUT«1␤»

[19:21] <jnthn> I'm still not getting why the dispatch wasn't ambig... :-S

[19:21] <pmichaud> rakudo:  say Day.ACCEPTS(Int);

[19:21] <p6eval> rakudo f934db: OUTPUT«Could not find non-existent sub Day␤current instr.: '_block14' pc 53 (EVAL_16:43)␤»

[19:22] <pmichaud> rakudo:  enum Day <Mon Tue Wed> ;say Day.ACCEPTS(Int);

[19:22] <p6eval> rakudo f934db: OUTPUT«1␤»

[19:22] <pmichaud> rakudo:  enum Day <Mon Tue Wed>; say Day.ACCEPTS(Int);  say Day ~~ Int;

[19:22] <p6eval> rakudo f934db: OUTPUT«1␤0␤»

[19:22] <pmichaud> that's why.

[19:22] <TimToady> those are backwards

[19:22] <pmichaud> yes, just noticed that.

[19:23] <jnthn> rakudo:  enum Day <Mon Tue Wed>; say Int ~~ Day;

[19:23] <p6eval> rakudo f934db: OUTPUT«0␤»

[19:23] *** alanhaggai left
[19:23] <pmichaud> rakudo:  enum Day <Mon Tue Wed>; say Int.ACCEPTS(Day);  say Day ~~ Int;

[19:23] <jnthn> rakudo:  enum Day <Mon Tue Wed>; say Day ~~ Int;

[19:23] <p6eval> rakudo f934db: OUTPUT«0␤0␤»

[19:23] <p6eval> rakudo f934db: OUTPUT«0␤»

[19:23] <pmichaud> rakudo:  enum Day <Mon Tue Wed>; say Day.ACCEPTS(Int);  say Int ~~ Day;

[19:23] <p6eval> rakudo f934db: OUTPUT«1␤0␤»

[19:23] *** Kisu joined
[19:24] <TimToady> I think we've got some confusion here between manifest types and storage types, but I'll need to think on it over lunch

[19:24] <PerlJam> Do Str-based enums work in rakudo?

[19:24] <jnthn> pmichaud: Those two should certianly give the same answer...

[19:24] <jnthn> pmichaud: Yes, should do.

[19:24] <TimToady> A storage type cannot be a constrained type, but the known type of the object stored there might be more constrained than the storage type

[19:24] <PerlJam> (and presumably they'll does(Str) instead of Int)

[19:25] <jnthn> Yes.

[19:25] <pmichaud> jnthn: I suspect that ~~ Day isn't dispatching as a protoobject/type check.

[19:25] <jnthn> pmichaud: Something like that.

[19:25] <pmichaud> rakudo:  enum Day <Mon Tue Wed>;  say Day.PARROT;

[19:25] <p6eval> rakudo f934db: OUTPUT«␤»

[19:25] <pmichaud> rakudo:  enum Day <Mon Tue Wed>;  say Day.WHAT;

[19:25] <p6eval> rakudo f934db: OUTPUT«Day␤»

[19:25] <masak> literal: the problem is in your script. you're trying to index a variable $*ARGV, which isn't defined.

[19:25] <TimToady> that is, despite being a constrained type of Int, Day is also a valid object type, I think

[19:26] <masak> literal: it's @*ARGS in Perl 6.

[19:26] <TimToady> not sure what Liskov would say about it though... :)

[19:27] <masak> TimToady: speaking of Liskov...

[19:27] <TimToady> rakudo: enum Day <Mon Tue Wed>; say 42 ~~ Day

[19:27] <masak> TimToady: how do you feel about monkeyless monkeypatching?

[19:27] <p6eval> rakudo f934db: OUTPUT«0␤»

[19:27] <TimToady> rakudo: enum Day <Mon Tue Wed>; say 2 ~~ Day

[19:27] <p6eval> rakudo f934db: OUTPUT«0␤»

[19:27] <TimToady> hmm

[19:27] <literal> masak: oh, heh

[19:27] <TimToady> rakudo: enum Day <Mon Tue Wed>; say Tue ~~ Day

[19:27] <jnthn> TimToady: I figured that one is correct?

[19:27] <p6eval> rakudo f934db: OUTPUT«1␤»

[19:28] <jnthn> TimToady: Since S12 explicitly mentions a special form to use to "cheat".

[19:28] <masak> TimToady: or maybe, this question first: can methods be declared outside of their class declaration?

[19:28] <masak> named methods, that is.

[19:28] <TimToady> well, but ~~ is about pattern match, and what does it mean for Day to accept an integer?

[19:29] <jnthn> TimToady: I also have...

[19:29] <pmichaud> rakudo:  my Day $x;  $x = 2;

[19:29] <p6eval> rakudo f934db: OUTPUT«Malformed declaration at line 1, near "Day $x;  $"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[19:29] <pmichaud> rakudo:  enum Day <Mon Tue Wed>; my Day $x;  $x = 2;  say $x;

[19:29] <p6eval> rakudo f934db: OUTPUT«Type mismatch in assignment; expected something matching type Day but got something of type Int()␤current instr.: 'die' pc 16609 (src/builtins/control.pir:225)␤»

[19:29] <jnthn> rakudo: enum Day <Mon Tue Wed>; class Foo does Day { }; my $x = Foo.new; $x.Day = Wed; say "ok"; $x.Day = 2;

[19:29] <p6eval> rakudo f934db: OUTPUT«ok␤Type mismatch in assignment; expected something matching type Day[] but got something of type Int()␤current instr.: 'die' pc 16609 (src/builtins/control.pir:225)␤»

[19:29] <TimToady> masak: yes, but if they're not installed anywhere a dispatcher looks, they probably warrant a warning

[19:30] <jnthn> That is, you can't just throw something that happens to be the thing an enum value numifies to and treat it as if it's the enum vlaue itself.

[19:30] <literal> masak: heh, now I get an error about prefix:<=> being deprecated

[19:30] <masak> TimToady: I'm thinking something like 'method foo(Subtype $self:) {...}'. does that constitute being installed somewhere a dispatcher looks?

[19:30] <literal> oh well

[19:31] <masak> literal: that might indeed be Pod::Parser.

[19:31] <literal> yep

[19:31] <masak> literal: I'll give it a try over here.

[19:31] <masak> I can probably fix it for you.

[19:31] <pmichaud> afk, gotta pick up kid from school.

[19:32] <masak> literal: oh, and also, that'd be @*ARGS[0], I think.

[19:32] <TimToady> rakudo: subset Pos of Int where * > 0; say 42 ~~ Pos

[19:32] <p6eval> rakudo f934db: OUTPUT«1␤»

[19:32] <masak> Rakudo++

[19:33] <TimToady> the question is whether you mean Day as an object type or as a constraint when you say ~~

[19:33] <TimToady> if a constraint, 2 ~~ Day should match

[19:33] <TimToady> but enums are in an uncomfy position

[19:33] <TimToady> lunch & # thinking

[19:33] <jnthn> S12 says "An enum is a low-level class that can function as a role or property.

[19:33] <jnthn> "

[19:33] <jnthn> Right off.

[19:34] <dalek> rakudo: e33c004 | jnthn++ | src/builtins/guts.pir:

[19:34] <dalek> rakudo: Implement smart-matching on enum values.

[19:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e33c0049216026a5b3d8855dff0a3ab3bcb983c1

[19:34] <jnthn> yay dalek is back

[19:34] <jnthn> I can haz karmaz.

[19:34] <Infinoid> jnthn++

[19:35] <masak> dalek: welcome back, bot.

[19:35] <Infinoid> (problem was missing CPAN module on feather)

[19:35] *** Infinoid left
[19:37] <masak> Infinoid++

[19:39] <pugs_svn> r26603 | jnthn++ | [t/spec] Unfudge tests for smart-match on enum values, and add explicit tests for given/when.

[19:42] <masak> literal: try now.

[19:42] <pugs_svn> r26604 | jnthn++ | [t/spec] Unfudge a couple more smart-match and enum tests.

[19:44] * jnthn -> diiner, back soon

[19:51] <literal> masak: I get this now -> http://sial.org/pbot/36315

[19:51] <literal> but I gotta go

[19:51] <masak> ok.

[19:51] <literal> ignore that S26... on the command line, of course...

[19:52] <masak> literal: thing is, I tried it over here, and it worked.

[19:52] <masak> literal: not sure I'll be able to reproduce your error.

[19:52] <literal> ok

[19:52] <masak> literal: are you running latest Rakudo and perl6-examples?

[19:52] <literal> not the latest Rakudo, but from 2 days ago or so

[19:52] <literal> I'll try again later with the latest

[19:53] <masak> sounds good.

[20:04] <PhatEddy> Hi - I'm looking at an open RT about someone's broken spectests one day with few details.  Can I sort of say as policy that there is reason for an RT unless spectests are broken for 2-3 days?

[20:04] <PhatEddy> s/is reason/is no reason/

[20:05] <masak> PhatEddy: I think the overriding reason should be something like whether the ticket has an observable that can be fixed.

[20:06] *** exodist left
[20:08] * jnthn back from nom

[20:11] <pmichaud> In general, if a spectest is broken on a platform (and only one person observes it), we should ask for more details about the reporter's configuration and setup (and ask them to verify again with an up-to-date build).

[20:11] <pmichaud> if no response after a few days, okay to close the ticket.

[20:13] *** nacho_ joined
[20:14] *** lambdabot left
[20:14] *** abra left
[20:16] *** lambdabot joined
[20:20] <jnthn> I'm going to leave a couple of the enums tickets for now...but most of them are now resolved. :-)

[20:20] <PerlJam> jnthn++

[20:25] <PhatEddy> Just to note that Bool.succ (RT #64366) has a ready and waiting patch ...

[20:27] <jnthn> rakudo: my Bool $t; $t = Bool::True; print $t.succ

[20:27] <p6eval> rakudo e33c00: OUTPUT«Null PMC access in isa()␤current instr.: 'parrot;List;!flatten' pc 6724 (src/classes/List.pir:215)␤»

[20:27] <pmichaud> the patch in 64366 is backwards.

[20:27] *** FurnaceBoy joined
[20:28] <pmichaud> it's defining pred/succ in terms of --/++, when it should be the other way around.

[20:28] <jnthn> I don't quite get why it adds to succ and pred to the setting and has them in PIR too?

[20:28] <pmichaud> I suspect they were trying to keep the vtable version as well.

[20:28] <jnthn> ah

[20:28] <pmichaud> at any rate, rejecting patch.

[20:28] <PhatEddy> It takes them out of pir and moves them to setting

[20:29] <PhatEddy> why backwards?

[20:29] <pmichaud> yes, but it's not completely taking them out of pir -- it's keeping a version in PIR as well.

[20:29] * masak would like to upvote http://rt.perl.org/rt3/Ticket/Display.html?id=64388

[20:29] <PhatEddy> PIR still needs increment and decrement

[20:30] <pmichaud> it does?  why?

[20:30] <jnthn> masak: Ah yes, the whole BUILD fun...

[20:30] <PhatEddy> because they are not the same as int

[20:30] <PhatEddy> increment sets to 1 and decrement sets to 0

[20:30] <masak> jnthn: it's not terribly urgent, it's just that it'd remove a lot of .init workarounds...

[20:31] <pmichaud> PhatEddy: we don't use increment/decrement

[20:31] <PhatEddy> rakudo: my Bool $t; $t = Bool::True; say ++$t

[20:31] <p6eval> rakudo e33c00: OUTPUT«1␤»

[20:31] <PhatEddy> rakudo: my Bool $t; $t = Bool::True; say --$t

[20:31] <p6eval> rakudo e33c00: OUTPUT«0␤»

[20:31] <pmichaud> okay, I misspoke.

[20:31] <pmichaud> Our current implementation of increment and decrement is wrong.

[20:32] <PhatEddy> That may be ...

[20:33] <pmichaud> at any rate, increment/decrement should be defined in terms of .succ and .pred

[20:34] <PhatEddy> That is not true of Str and Int which base succ and pred on inc/dec the same way ...

[20:34] <pmichaud> as I said, our current implementation of increment and decrement is wrong.

[20:34] <pmichaud> they're from before there was clarification / definition of .succ and .pred

[20:35] <pmichaud> in the spec

[20:35] *** Southen left
[20:35] <PhatEddy> Sorry - did my best but based my implementation of bool on the other types ...

[20:36] <pmichaud> sure, makes sense.

[20:36] <pmichaud> I would've done the same lacking knowledge of other things going on :-)

[20:37] <pmichaud> I'm not intending to criticize the patch effort at all (and I'm failing in that, so my apologies)

[20:37] *** skids left
[20:38] <PhatEddy> no prob - it finally needs to be implemented some right way ...

[20:38] *** dduncan joined
[20:38] <pmichaud> yes, the current implementation of Bool.pir is definitely wrong also.

[20:38] *** dduncan left
[20:40] <pmichaud> I think I need to switch back to 32 bit linux... 64 bit seems so slow in several respects :-|

[20:42] *** mizioumt joined
[20:44] *** mizioumt left
[20:48] *** rblasch__ left
[20:51] * jnthn moves max to the setting so 58948 can be resolved at long last

[20:52] <pmichaud> \o/

[20:53] <jnthn> Also got a patch to add () to end of roles when stringified.

[20:54] <pmichaud> running spectest is taking waaaaay too long on my 64 bit box here.

[20:54] <pmichaud> so I think I definitely will move it back to 32 bit.

[20:56] *** FurnaceBoy left
[20:57] <jnthn> No no, stay there, it's an incentive to make Rakudo faster! ;-)

[20:58] <PerlJam> It's the parsing that needs speed and that's not really rakudo's fault.

[20:58] <pmichaud> I don't think it's just parsing anymore.

[20:58] <pmichaud> (that is slowing things down)

[20:58] <pmichaud> granted, the parser remains slow..

[20:58] <jnthn> It's not, but it can dominate.

[20:59] <jnthn> Consider assign.t

[20:59] <PerlJam> I was showing someone something in rakudo earlier and the first line of execution printed "started".  There was a noticably huge delay from when I hit enter to run the thing and when it output "started"

[20:59] <pmichaud> PerlJam: that's not necessarily just parsing.  There's also a _lot_ of initialization taking place now.

[21:00] <pmichaud> and every sub we add to the setting increases startup time.

[21:00] <PerlJam> true.

[21:00] *** ZuLuuuuuu left
[21:00] <pmichaud> and every metaoperator we add increases the time needed to initialize the parser itself.

[21:01] <jnthn> That should change once we parse them the STD.pm way though, no?

[21:01] <pmichaud> the metaoperator cost?  Perhaps.

[21:01] <pmichaud> but we still incur an extra cost in parsing that we don't have now, depending on how much LTM caching we can do.

[21:01] <jnthn> The init will be a big area to try and optimize though.

[21:02] <jnthn> I'm quite hopeful that I'm going to have method dispatch running a good bit faster next month.

[21:02] <jnthn> erm,

[21:02] <jnthn> this month

[21:03] <jnthn> It's already May.

[21:03] <PerlJam> jnthn: still doing rakudo day once a week? or will that change?

[21:04] <jnthn> PerlJam: That and hopefully http://news.perlfoundation.org/2009/04/hague_perl_6_grant_request_tra.html

[21:04] <jnthn> I've found myself with relativekly little work in May, which is a month I'd planned to not travel or have any conferences, but work.

[21:04] <jnthn> So, filed a grant app that hopefully gets approved...

[21:05] <PerlJam> Ah, D4 was something I was wondering about earlier today.   

[21:06] <jnthn> Anyway, in the process of doing D1 I'm planning a reasonbly big refactor.

[21:07] <jnthn> I want to try and straighten out our story on custom meta-classes and alternative representations.

[21:07] <PerlJam> you know how git gives you the + and - for a given file?  It always makes me smile a little when the number of + is small while the number of - is large.

[21:08] <jnthn> :-)

[21:08] <jnthn> If actions.pm has a lot of -, blame me. :-)

[21:09] <PerlJam> implementation trumps no implementation, so even if it's bloated and ugly, it's good.  the more - than + in actions.pm is just a sign of refactoring and  that's always good (because we still have stuff that works, only better :)

[21:11] <jnthn> Sure. enums really needed an extensive refactor.

[21:11] <jnthn> Even if the new implementation ain't perfect, it gets a lot of things right that we got wrong before.

[21:12] <jnthn> And with well under 2/3 the number of lines of code.

[21:12] <jeremiah_> OHAI jnthn 

[21:12] <jeremiah_> How is everything?

[21:12] <jeremiah_> Artemis says hi.

[21:12] <dalek> rakudo: e637cef | pmichaud++ | src/builtins/globals.pir:

[21:12] <dalek> rakudo: Get $*IN, $*OUT, $*ERR to default to utf8 encodings.

[21:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e637cef7f50df4157ebae9629737710ba1424c45

[21:12] <jeremiah_> Or rather miao.

[21:13] <jnthn> jeremiah_: OH HAI!

[21:13] <jnthn> And hi to Artemis :-)

[21:14] <jnthn> Things are pretty good here...how about up in Gothenburg?

[21:16] *** r0bby joined
[21:18] <jeremiah_> I am at our summer place where it is nice and warm. :)

[21:18] <jeremiah_> How is life in Bratislava?

[21:19] <jnthn> Nice, and warm also, but thankfully not too hot (yet). Was a national holiday here today...big fireworks show.

[21:19] <jnthn> Could see it right from where I live. :-)

[21:20] <jeremiah_> Oh cool. 

[21:20] <jeremiah_> Yesterday was the Kings birthday here.

[21:20] *** minazo left
[21:20] <jeremiah_> No fireworks.

[21:20] <jeremiah_> Swedes try and keep it on the 'lowdown'

[21:20] <jeremiah_> as it were.

[21:21] <jnthn> :-)

[21:22] <masak> jeremiah_: most Swedes here were busy getting extremely drunk. no time for fireworks.

[21:22] <jnthn> I was about to say. Just a few quiet bottles from the systemstore, but no fireworks. :-)

[21:23] <masak> "a few"? :)

[21:23] <jnthn> I didn't say they were bottles of beer. ;-)

[21:25] <jeremiah_> masak: Well, that is more Valborg then Kings birthday. :-)

[21:25] <jeremiah_> s/then/than/

[21:25] <jeremiah_> The System!

[21:25] * masak is no great fan of the current interpretation of Walpurgis night

[21:25] <jeremiah_> Systembologet.

[21:26] <jeremiah_> masak: Yeah, when did it turn into a mass alcoholic reverie?

[21:26] <jnthn> jeremiah_: That's the word I couldn't remember. :-)

[21:26] <masak> the one day of the year when the words "get off my lawn!" are not a joke.

[21:27] <jeremiah_> heh

[21:27] *** Whiteknight joined
[21:27] <jeremiah_> But in Sweden, we have allemansratt

[21:27] <jeremiah_> Of course it is spelled slightly differently.

[21:28] <jeremiah_> But it is like Germany - you can walk wherever you chose, as long as you lock the gate after you.

[21:29] <masak> ran spectests. two TODO passed in t/spec/S12-class/basic.rakudo -- do I unfudge them?

[21:30] <jnthn> masak: I've been seeing two unexpected passes there too, I don't quite know what they are.

[21:30] <masak> they are tests 30 and 31. :)

[21:31] <pugs_svn> r26605 | jnthn++ | [t/spec] Roles now have () on the end of their stringification, as type objects do.

[21:32] <masak> rakudo: class A { eval 'method x { say "OH HAI" }' }; say "alive"

[21:32] <p6eval> rakudo e637ce: OUTPUT«alive␤»

[21:33] * masak closes [perl #61354]

[21:33] <jnthn> w00t

[21:33] <jnthn> masak: teste?

[21:33] <jnthn> *tested?

[21:33] <masak> jnthn: well, that was the TODO'd tests that passed here...

[21:33] <dalek> rakudo: 5035385 | jnthn++ | src/classes/Role.pir:

[21:33] <dalek> rakudo: .WHAT on roles should stringify to something with () on the end.

[21:33] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5035385386acd6a2c8dfe9d6b28ba85e200b4a31

[21:33] <dalek> rakudo: 44c4879 | jnthn++ | src/ (2 files):

[21:33] <dalek> rakudo: Move max to the setting.

[21:33] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/44c4879faacc50b01fee3682465779a7bcad0d23

[21:33] <jnthn> masak: oh cool

[21:33] <masak> jnthn: I'll unfudge them after I close the RT ticket.

[21:34] <jnthn> that's fine

[21:34] <PhatEddy> masak: I put in the tests for 61354 relatively recently ... they might be rewritten a bit now that they don't "crash"

[21:34] <masak> PhatEddy: well, the RT ticket is clearly fixed, so no problem.

[21:35] <jnthn> Woo, 58948 is closed. :-)

[21:36] <jnthn> We're down to 319 tickets.

[21:36] * jnthn remembers the days when he could keep it down at 150.

[21:37] <PhatEddy> fudged test for 58948 in t/spec/S06-multi/syntax.t 

[21:37] <jnthn> masak: On the BUILD/BUILDALL stuff, I plan to take care of it during my various other planned refactors on object stuff.

[21:38] <masak> jnthn: ok.

[21:38] * masak likes that it's in the schedule somewhere

[21:38] *** yari left
[21:38] *** Ehtyar joined
[21:42] <jnthn> rakudo: say (1..10).min: { ($_-3) * ($_-5) };

[21:42] <p6eval> rakudo e637ce: OUTPUT«too many arguments passed (2) - at most 1 params expected␤current instr.: '_block23' pc 113 (EVAL_20:59)␤»

[21:43] <jnthn> rakudo: say (1..10).min

[21:43] <p6eval> rakudo e637ce: OUTPUT«1␤»

[21:43] <jnthn> rakudo: say (1..10).list.min: { ($_-3) * ($_-5) };

[21:43] <pugs_svn> r26606 | masak++ | [t/spec/S12-class/basic.t] unfudged two tests that now pass in Rakudo

[21:43] <p6eval> rakudo e637ce: OUTPUT«too many arguments passed (2) - at most 1 params expected␤current instr.: '_block24' pc 125 (EVAL_20:60)␤»

[21:44] <jnthn> rakudo: my @a = 1,2,3,4; my @a.min: { ($_-3) * ($_-5) };

[21:44] <p6eval> rakudo e637ce: OUTPUT«Redeclaration of variable @a␤Statement not terminated properly at line 1, near ".min: { ($"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[21:44] <jnthn> rakudo: my @a = 1,2,3,4; say @a.min: { ($_-3) * ($_-5) };

[21:44] <p6eval> rakudo e637ce: OUTPUT«too many arguments passed (2) - at most 1 params expected␤current instr.: '_block27' pc 144 (EVAL_20:67)␤»

[21:44] <masak> jnthn: that colon syntax doesn't work with arrays, unfortunately...

[21:44] <jnthn> rakudo: my @a = 1,2,3,4; say @a.min({ ($_-3) * ($_-5) });

[21:44] <p6eval> rakudo e637ce: OUTPUT«too many arguments passed (2) - at most 1 params expected␤current instr.: '_block27' pc 144 (EVAL_19:67)␤»

[21:45] <jnthn> rakudo: my @a = 1,2,3,4; say @a.min();

[21:45] <masak> jnthn: there's an RT ticket about it.

[21:45] <p6eval> rakudo e637ce: OUTPUT«1␤»

[21:46] <jnthn> Yeah, I know

[21:46] <jnthn> I'm looking at http://rt.perl.org/rt3/Ticket/Display.html?id=62742

[21:46] <jnthn> Thing is, min and max are defined as taking such a code parameter...

[21:47] <jnthn> multi method min( $values: Code $by = sub { $^a cmp $^b } ) {

[21:48] <jnthn> Oh!

[21:48] <jnthn> It's because that's an arity 1 block.

[21:48] <jnthn> And it expects a comparator.

[21:50] <jnthn> (e.g. arity 2)

[21:50] <masak> aha.

[21:50] <pmichaud> it should probably use the same logic that .sort is using.

[21:53] <masak> aye, .min and .max being narrow special cases of .sort

[21:54] <jnthn> pmichaud: aye

[21:54] <jnthn> pmichaud: The ticket says as much, and claims S29 says so too.

[21:54] <jnthn> ah well, it's an easy addition.

[21:59] *** nihiliad left
[22:01] <pugs_svn> r26607 | ron++ | simplify/streamline testing for now fixed RT #61354

[22:09] *** skids joined
[22:19] * jnthn thinks we must be getting close to the 11,000 point.

[22:22] <PhatEddy> If anyone is interested to ask, I think I know of about 5 tickets that may be closeable without coding ...

[22:23] <jnthn> Nice

[22:24] *** alester left
[22:24] <masak> rakudo: sub foo(%bar) {}; foo( -> {} )

[22:24] <p6eval> rakudo 44c487: OUTPUT«Parameter type check failed; expected something matching  but got something of type Block() for %bar in call to foo␤current instr.: 'die' pc 16538 (src/builtins/control.pir:225)␤»

[22:24] * masak submits rakudobug

[22:24] <jnthn> wtf

[22:25] <masak> jnthn: besides this small glitch, that new functionality is really neat, btw.

[22:25] <jnthn> rakudo: sub foo(%bar) { }; say &foo.signature.pler

[22:25] <jnthn> rakudo: sub foo(%bar) { }; say &foo.signature.perl

[22:25] <p6eval> rakudo 44c487: OUTPUT«Could not locate a method 'pler' to invoke on class 'Signature'.␤current instr.: 'die' pc 16538 (src/builtins/control.pir:225)␤»

[22:25] <p6eval> rakudo 44c487: OUTPUT«:( %bar)␤»

[22:26] <jnthn> rakudo: say Associative.WHAT

[22:26] <p6eval> rakudo 44c487: OUTPUT«Associative()␤»

[22:26] <jnthn> rakudo: say Associative.perl

[22:26] <p6eval> rakudo 44c487: OUTPUT«␤»

[22:26] <jnthn> rakudo: say Positional.perl

[22:26] <p6eval> rakudo 44c487: OUTPUT«␤»

[22:26] <jnthn> rakudo: say Positional[Int].perl

[22:26] <p6eval> rakudo 44c487: OUTPUT«␤»

[22:26] *** km2 left
[22:26] <PhatEddy> easiest to close (I think) RT #63094

[22:26] <jnthn> rakudo: sub foo(@a) { }; foo(1)

[22:26] <p6eval> rakudo 44c487: OUTPUT«Parameter type check failed; expected something matching  but got something of type Int() for @a in call to foo␤current instr.: 'die' pc 16538 (src/builtins/control.pir:225)␤»

[22:27] <jnthn> rakudo: sub foo(Int @a) { }; foo(1)

[22:27] <masak> ah, systemic fail.

[22:27] <p6eval> rakudo 44c487: OUTPUT«Null PMC access in get_string()␤current instr.: 'parrot;Role;perl' pc 3906 (src/classes/Role.pir:358)␤»

[22:27] <jnthn> gah. That worked like, veyr recently. How've I managed to hash that up...

[22:28] <jnthn> say Positional[Int]

[22:28] <jnthn> rakudo: say Positional[Int]

[22:28] <p6eval> rakudo 44c487: OUTPUT«␤»

[22:28] <jnthn> rakudo: say Positional

[22:28] <p6eval> rakudo 44c487: OUTPUT«Positional()␤»

[22:28] <jnthn> ah, that one works.

[22:28] <jnthn> rakudo: say Positional.perl

[22:28] <p6eval> rakudo 44c487: OUTPUT«␤»

[22:29] * jnthn looks confused

[22:30] <jnthn> PhatEddy: That works for me here too on Win32.

[22:31] <jnthn> And I'm on XP not Vista, and the other guy who said it worked said it worked on Vista.

[22:31] <jnthn> PhatEddy: So yes, agree, close.

[22:32] <pugs_svn> r26608 | masak++ | [t/spec/S06-multi/syntax.t] unfudged two tests

[22:33] <jnthn> PhatEddy: closed

[22:34] <jnthn> masak++ # that clears up all our unexpected success.

[22:34] <jnthn> pmichaud: If you know how, or are able to, giving PhatEddy an RT bit could be a good idea.

[22:36] <masak> recompiling Rakudo in one terminal window and trying to compile a Perl 6 project in another still throws me off sometimes. I should adopt a double buffering system.

[22:36] <masak> ...and then build it into proto.

[22:37] <PhatEddy> Next relatively easy (I believe) is the merger of RT #61918 with RT #62002.

[22:37] <jnthn> Does anybody see a failure in S11-modules/nested.t ?

[22:37] <masak> jnthn: not here.

[22:38] *** payload left
[22:38] <jnthn> PhatEddy: I'm inclined to leave those separate.

[22:39] <jnthn> PhatEddy: They are about the same thing, but one is explicitly tracking the lack of specification, the other the implemenation.

[22:39] *** jhuni joined
[22:39] *** frew|work left
[22:39] <jnthn> Having a [Spec] ticket is useful for tracking spec clarifications we're waiting on.

[22:41] <PhatEddy> Should there be a dependency or something?

[22:42] <jnthn> Yeah...probably.

[22:43] <PhatEddy> If you are willing to try one more you look at RT #57336 last July

[22:43] <dalek> rakudo: ec69e24 | jnthn++ | src/setting/Any-list.pm:

[22:43] <dalek> rakudo: Support arity-1 blocks being supplied to min and max.

[22:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ec69e248f03963aacbde7d54698584c89ec4331c

[22:45] <pugs_svn> r26609 | jnthn++ | [t/spec] Tests for .min and .max arity 1.

[22:47] <jnthn> ...and that's another RT. :-)

[22:47] <jnthn> PhatEddy: Looking.

[22:48] <jnthn> Uff

[22:48] <jnthn> It's a better error, but I think we can do even better than that.

[22:48] *** iblechbot left
[22:49] *** payload joined
[22:49] <jnthn> OK, I think I might call it a day at that.

[22:49] <jnthn> Fairly successful Rakudo day on the RT front. ;-)

[22:49] <PhatEddy> OK - the other two are less probable so I am inclined to quit here ... sorry if I overestimated

[22:50] <jnthn> no probs, we got one more closure out of it. :-)

[22:51] <PhatEddy> I think after this I may be more inclined to ask about tickets here before posting to the list about them ...

[22:51] <masak> jnthn: a successful day on the RT front here too. :) three new tickets in the pipe.

[22:52] <masak> PhatEddy: that's generally a good idea, I think.

[22:52] <jnthn> masak: Yeah, but today I closed more than you opened. :-P

[22:52] <jnthn> Which makes a change.

[22:52] <masak> jnthn++

[22:52] <masak> jnthn: you keep that up, and you might actually bring the number of tickets under 300 again. :P

[22:53] <jnthn> Of course, my crowning achievement today was getting my avatar on github set up.

[22:53] <masak> cool.

[22:53] <jnthn> There I was thinking it'd be just uploading an image BUT OH NO yet another acocunt on yet another site...

[22:53] <masak> GRRavatar!

[22:55] <masak> it's very late in the Eurozone. I'll be heading to bed now.

[22:56] <masak> long bus journeys tomorrow and the day after, so I expect to be fairly productive in the weekend.

[22:57] <jnthn> You're doing a lot of these long bus journeys.

[22:58] <masak> aye.

[22:58] <jnthn> Wait...Sweden...eurozone?

[22:58] <jnthn> ;-)

[22:58] <masak> Sweden belongs to the Eurozone!

[22:59] <masak> just because we're not smack in the middle of it...

[22:59] <jnthn> I've probably been biased into aliasing Eurozone to "countries who use the Euro as their currency".

[22:59] <jnthn> (Everyone here talked about Slovakia "entering the Eurozone")

[22:59] *** Juerd_ joined
[22:59] <masak> jnthn: oh, you're right.

[22:59] *** Juerd_ left
[23:00] <masak> I'm using the term wrongly.

[23:00] <jnthn> Well, I guess there's more than one way to define it. I've just seen eurozone meaning that an awful lot.

[23:00] <masak> no, we don't belong to the Eurozone. we've voted about it twice so far, I think.

[23:00] <masak> someday I will hold a Swedish Euro in my hand, I'm sure.

[23:01] <jnthn> Out of the Scandinavian countries, Sweden feels to me like the only one that might join it any time soon.

[23:01] <masak> aye, I believe that the sides are very even.

[23:01] * masak waves goodnight

[23:01] <jnthn> I'd not be at all surprised if Sweden were to join it before the UK.

[23:01] <jnthn> night, masak; safe journey tomorrow

[23:02] <masak> dz.

[23:02] *** masak left
[23:03] *** Limbic_Region joined
[23:27] *** km2 joined
[23:27] <jnthn> http://use.perl.org/~JonathanWorthington/journal/38910 # rakudo day report

[23:28] *** km2_ joined
[23:36] *** payload1 joined
[23:36] *** payload left
[23:42] <jnthn> Google fail # y'know, taking the ariel map when it was dark/nighttime maybe wasn't such a good idea...

[23:44] *** eternaleye joined
[23:46] <eternaleye> LylePerl: (re Camelias) I like #7

[23:47] <eternaleye> LylePerl: for the later ones, the pink smile is too much

[23:52] *** km2 left
[23:52] *** jbt left
[23:57] *** payload joined
[23:58] *** payload left
[23:58] *** payload joined
