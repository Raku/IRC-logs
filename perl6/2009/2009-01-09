[00:06] *** elmex left
[00:07] *** aindilis left
[00:09] *** aindilis` left
[00:10] *** aindilis` joined
[00:17] *** mberends left
[00:25] *** eternaleye_ joined
[00:25] <pugs_svn> r24817 | lwall++ | [STD] fix item assignment problem noticed by ruoso++

[00:26] *** eternaleye left
[00:32] *** iblechbot left
[00:40] *** cspencer joined
[00:41] <pugs_svn> r24818 | lwall++ | [STD] previous patch was overzealous wrt subexpressions and disallowed $($x) = 1

[00:41] *** pbuetow left
[00:57] *** wknight8111 left
[01:00] <pugs_svn> r24819 | lwall++ | [S02] clarify that Pairs and Mappings are mutable in value, but not in key

[01:00] <pugs_svn> r24820 | pmichaud++ | [t/spec]: #?rakudo skip test for nameless anonymous classes

[01:02] <pugs_svn> r24821 | pmichaud++ | [t/spec]:  Clean up passing-hashes.t, remove unneeded "returns Void"

[01:18] *** alc joined
[01:19] *** SamB joined
[01:24] *** FurnaceBoy joined
[01:33] *** icwiener left
[01:41] <azawawi> hi

[01:41] <azawawi> std: "hi";

[01:41] <p6eval> std 24821: OUTPUT«00:06 83m␤»

[01:41] <azawawi> std: "hi";

[01:41] <p6eval> std 24821: OUTPUT«00:07 83m␤»

[01:51] *** [particle] left
[01:51] *** c9s_ joined
[01:56] *** aindilis` left
[01:58] *** qiang joined
[02:07] <pugs_svn> r24822 | particle++ | [S19] delimited options use eager matching semantics, are invisible to MAIN, but are available via %+OPTS<...>

[02:11] *** c9s_ left
[02:12] *** c9s_ joined
[02:13] *** c9s_ left
[02:20] <pugs_svn> r24823 | particle++ | [S19] incorporate more of TimToady++'s notes, and format Notes section as proper Pod

[02:25] *** cornelius__ joined
[02:33] *** cspencer left
[02:50] *** gravity joined
[02:59] *** qiang left
[03:01] *** xuser joined
[03:19] *** stephens left
[03:27] *** Limbic_Region left
[03:34] *** Blasi joined
[03:38] *** meppuru joined
[03:39] *** gravity left
[03:39] *** aindilis joined
[03:39] *** meppl left
[03:39] *** meppuru is now known as meppl

[03:47] *** justatheory left
[03:47] *** FurnaceBoy left
[04:05] *** eternaleye_ left
[04:09] *** eternaleye joined
[04:20] *** aindilis` joined
[04:33] *** aindilis` left
[04:33] *** aindilis` joined
[04:34] *** aindilis left
[04:35] *** hercynium joined
[04:36] <hercynium> moritz: I found the answer for what I was asking about earlier!

[04:37] <hercynium> perl6 *does* have that syntactic sugar, in the form of binding

[04:37] * hercynium does a happy dance

[04:38] *** hercynium left
[04:48] *** Blasi left
[04:55] *** sail0r joined
[05:00] *** athenot_ left
[05:19] *** Blasi joined
[05:28] *** kisu joined
[05:41] *** cornelius__ left
[05:45] *** rhr_ joined
[05:52] *** athenot joined
[05:55] *** cornelius__ joined
[05:58] *** rhr left
[06:05] <pugs_svn> r24824 | pmichaud++ | [t/spec]:  #?rakudo skip an odd test in multiple.t.

[06:26] *** mberends joined
[06:29] *** ejs joined
[06:32] *** athenot left
[06:54] *** alc left
[07:11] *** sail0r left
[07:18] *** mtnviewmark joined
[07:18] <mtnviewmark> std: take 4

[07:18] <p6eval> std 24824: OUTPUT«00:05 85m␤»

[07:20] <mtnviewmark> std: my $a = take 5

[07:20] <p6eval> std 24824: OUTPUT«00:05 86m␤»

[07:20] <mtnviewmark> std: my $a = take 5;

[07:20] <p6eval> std 24824: OUTPUT«00:05 86m␤»

[07:20] <mtnviewmark> std: my $a = return 5;

[07:20] <p6eval> std 24824: OUTPUT«00:05 86m␤»

[07:21] * mtnviewmark is trying to see if take and return are just functions...

[07:21] <mtnviewmark> rakudo: (take 5) + (take 7)

[07:21] <p6eval> rakudo 35246: OUTPUT«Warning␤Warning␤»

[07:25] <eternaleye> mtnviewmark: Well, return in global context is an exit() call, so that'll always _parse_

[07:25] <mtnviewmark> I guess my question is - are "return" and "take" treated specially by the parser - or are they really just normal functions?

[07:25] <mtnviewmark> seems they are treated specially

[07:26] *** cls_bsd left
[07:26] <eternaleye> I think they generate control exceptions

[07:26] <eternaleye> At least, return

[07:27] <eternaleye> take doesn't need to be lexically in a gather {} block (it can be in a function, which is called in the gather block), so it may just be a function

[07:28] <eternaleye> Which warns when _executed_ outside a gather block

[07:31] *** avar left
[07:32] *** avar joined
[07:35] *** cls_bsd joined
[07:36] <mtnviewmark> ah okay - thanks - though I'm not sure where that leaves me.... trying to decide if they belong on the operator chart... I'm guessing no

[07:36] <mtnviewmark> the problem is that "die" and "warn" are listed in Syn 03 as operators

[07:36] <mtnviewmark> but it has been pointed out that they are no different than "return" or "take"

[07:45] *** vixey joined
[07:49] *** alc joined
[07:52] *** avar left
[07:52] *** avar joined
[07:52] *** mtnviewmark left
[07:54] *** pdcawley joined
[08:01] *** maerzhase joined
[08:02] *** iblechbot joined
[08:03] <azawawi> hi

[08:03] *** DemoFreak joined
[08:12] *** pmurias joined
[08:14] *** PZt left
[08:14] *** rafl left
[08:14] *** moritz_ left
[08:14] *** Eevee left
[08:14] *** kolibrie left
[08:14] *** cookys left
[08:14] *** shachaf left
[08:14] *** charsbar left
[08:14] *** moritz_ joined
[08:14] *** PZt joined
[08:14] *** Eevee joined
[08:14] *** charsbar joined
[08:14] *** cookys joined
[08:14] *** rafl joined
[08:14] *** kolibrie joined
[08:14] *** shachaf joined
[08:14] *** irc.freenode.net sets mode: +o moritz_

[08:14] *** corneliu1__ joined
[08:20] *** pbuetow joined
[08:22] *** cornelius__ left
[08:25] <pdcawley> Quick question: What's the best site to link to when referring to Perl 6 in an article? dev.perl.org/perl6/?

[08:28] <mberends> do you mean a specific implementation of Perl 6 like Rakudo, or the Perl 6 language specification?

[08:28] <pdcawley> Perl 6 the language

[08:28] <azawawi> pdcawley: http://feather.perl6.nl/syn/

[08:29] <mberends> yes, then what you said is best.

[08:29] <azawawi> pdcawley: http://en.wikipedia.org/wiki/Perl_6

[08:29] *** pbuetow left
[08:29] <azawawi> pdcawley: http://rakudo.org/

[08:30] <azawawi> pdcawley: http://irclog.perlgeek.de/perl6/today

[08:30] <azawawi> is that enough? ;-)

[08:30] <pdcawley> I think so, yes.

[08:30] <Matt-W> worldsbestprogramminglanguage.com?

[08:31] <pdcawley> worldsbestprogramminglanguagethatisntreadyforprimetimeyet.com? Or ruby-lang.com?

[08:31] <pdcawley> :)

[08:31] <azawawi> pdcawley: but http://rakudo.org/ is the coolest among them

[08:31] <pdcawley> I shall be linking to that from the Rakudo reference.

[08:31] <azawawi> lol that is a long .com

[08:31] <Matt-W> I'd like to hear someone try and read that out on the radio :)

[08:31] <azawawi> cool

[08:32] <pdcawley> I can't remember if theofficialmonsterravinglooneypartyofgreatbritainandnorthernireland.org.uk exists...

[08:36] *** elmex joined
[08:42] *** Eevee left
[08:54] <pmurias> TimToady: if i want to extract the position in the orginal source file from the VAST how should i do it?

[09:03] *** kisu_ joined
[09:06] *** kisu left
[09:11] *** masak joined
[09:11] <azawawi> hi masak

[09:11] <masak> azawawi: greetings.

[09:11] * azawawi is a bot

[09:11] <azawawi> ;-)

[09:11] * masak too

[09:12] <moritz_> ni hao

[09:12] <masak> moritz_: nin hao

[09:16] *** Eevee joined
[09:18] <masak> what's the current status of POD in Rakudo?

[09:18] <moritz_> it ignores it

[09:18] <moritz_> (very much like STD.pm)

[09:18] <masak> sounds good.

[09:18] <masak> (for now)

[09:21] <pugs_svn> r24825 | pmurias++ | [mildew]

[09:21] <pugs_svn> r24825 | pmurias++ | added fcall to AST::Helpers

[09:21] <pugs_svn> r24825 | pmurias++ | infix:<~> is correctly translated to a function call

[09:21] <pugs_svn> r24825 | pmurias++ | [smop]

[09:21] <pugs_svn> r24825 | pmurias++ | fixed a bug in LexicalScope (a non null terminated variable name was passed to printf)

[09:36] *** Eevee_ joined
[09:38] *** Eevee left
[09:46] *** mj41_ left
[09:57] <pmurias> TimToady: figured a (hackish way) how to make viv attach source positions

[09:59] *** Eevee_ left
[10:16] <pugs_svn> r24826 | pmurias++ | [viv] added VIV::SET_OPT to set some options stored in lexicals (hack)

[10:16] <pugs_svn> r24826 | pmurias++ | [mildew] added a hack to print out the thing which is unimplemented when XXX is called

[10:16] *** ejs left
[10:17] <masak> are regex, token and rule allowed outside grammars?

[10:17] <masak> names ones, I mean.

[10:18] <moritz_> masak: yes

[10:18] <masak> followup questions: how do I refer to them from regexes? and does it work in Rakudo?

[10:18] <moritz_> rakudo: regex foo { foo }; say "foo" ~~ m/<foo>/;

[10:18] <p6eval> rakudo 35262: OUTPUT«foo␤»

[10:19] <masak> well, that was easy. :)

[10:19] <masak> moritz_++

[10:19] <moritz_> that's how most test do it

[10:19] <masak> now how come when I tried it, it didn't work?

[10:19] * masak tries again

[10:19] <moritz_> you did it wrong? ;-)

[10:20] <moritz_> btw take a look at t/spec/S05-metachars/tilde.t ;-)

[10:20] <masak> I likely did do it wrong, yes.

[10:20] <masak> I'll take a look.

[10:21] <moritz_> it's not very special, just nice that it works

[10:22] <masak> :)

[10:23] <masak> I think I'll use that functionality in my last sekrit project.

[10:24] <masak> I agree that the last one shouldn't throw an exception. actually, regex matching in general shouldn't. :)

[10:27] *** azawawi left
[10:28] *** azawawi joined
[10:28] <masak> how do I do what I mean here?

[10:28] <masak> rakudo: my $g = "g"; regex foo { <[a..$g]> ]; say "c" ~~ m/<foo>/

[10:28] <p6eval> rakudo 35262: OUTPUT«␤»

[10:28] <moritz_> with eval()

[10:29] <masak> oh.

[10:29] <masak> that was the solution I finally arrived upon last night.

[10:30] <masak> moritz_: have you seen an example of a PIR assertion? I'm a bit curious about how they work.

[10:30] <moritz_> masak: I think grammar.pg contains some

[10:31] <masak> moritz_: I'll check it out.

[10:31] <moritz_> masak: for example in 'token ws'

[10:31] <masak> ah, yes

[10:32] <moritz_> rakudo: regex recursive { '(' ~ ')' [ 'a'* <recursive>* ] }; say '(aa)' ~~ m/<recursive>/

[10:32] <p6eval> rakudo 35266: OUTPUT«Syntax error at line 1, near "}; say '(a"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[10:33] <moritz_> rakudo: regex recursive { '(' ~ ')' [ 'a'*] }; say '(aa)' ~~ m/<recursive>/

[10:33] <p6eval> rakudo 35266: OUTPUT«Syntax error at line 1, near "}; say '(a"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[10:33] <moritz_> rakudo: regex recursive { '(' ~ ')' 'a'  }; say '(aa)' ~~ m/<recursive>/

[10:33] <p6eval> rakudo 35266: OUTPUT«Unable to parse , couldn't find final ')'␤current instr.: 'parrot;PGE;Match;FAILGOAL' pc 2927 (compilers/pge/PGE/Regex.pir:456)␤»

[10:33] <moritz_> rakudo: regex recursive { '(' ~ ')' 'a'*  }; say '(aa)' ~~ m/<recursive>/

[10:33] <p6eval> rakudo 35266: OUTPUT«(aa)␤»

[10:35] <moritz_> rakudo: regex recursive { '(' ~ ')' ['a'*]  }; say '(aa)' ~~ m/<recursive>/

[10:35] <p6eval> rakudo 35266: OUTPUT«Syntax error at line 1, near "}; say '(a"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[10:47] *** zostay joined
[10:47] *** mberends left
[10:56] <pugs_svn> r24827 | pmurias++ | [mildew] the compile error context takes maximum 6 lines

[11:12] *** cornelius__ joined
[11:15] *** corneliu1__ left
[11:18] *** ruoso joined
[11:20] <pmurias> ruoso: hi

[11:21] <ruoso> hi pmurias 

[11:21] <pmurias> have you seen by hack which makes XXX display the thing that is unimplemented

[11:23] <pmurias> ?

[11:24] <ruoso> I only saw the commit message while backlogging

[11:26] <pmurias> ruoso: EXPORTALL exports things to the callers packages

[11:26] <pmurias> at runtime

[11:27] <ruoso> yes

[11:27] <ruoso> it handles the known tags

[11:27] <pmurias> so how do we make it export to the scope at compile time?

[11:27] <ruoso> because EXPORTALL is run at compile-time

[11:28] <ruoso> because use is still in a BEGIN

[11:28] <pmurias> so it has an optional scope argument?

[11:28] <ruoso> no, it should probably use CALLER or something

[11:29] <pmurias> &

[11:33] *** xinming_ joined
[11:35] <ruoso> hmmm... last TimToady's change on STD broke item assignment in mildew

[11:35] <Matt-W> doh

[11:35] <Matt-W> that's a little inconvenient

[11:36] <ruoso> hmm...

[11:36] <ruoso> actually it fixed ;)

[11:36] <ruoso> mildew was wrong...

[11:36] <ruoso> ;)

[11:37] <ruoso> pmurias++ # the unimplemented message is very much helpful

[11:38] *** xinming left
[11:39] <ruoso> TimToady, there are still some things being parsed as List assignment where they are supposed to be item assignment

[11:40] <ruoso>  - $array.[1] = "something"

[11:40] *** kst left
[11:40] <ruoso>  - $hash.{'foo'} = "something

[11:41] <ruoso>  - $a.b = $c

[11:43] *** kst joined
[11:47] *** riffraff joined
[11:48] *** plainhao joined
[11:48] <pmurias> ruoso: how should EXPORTALL discover if it is run during compile time?

[11:48] *** plainhao left
[11:48] *** plainhao joined
[11:49] <ruoso> in fact... $a.b = $c needs to have its context delayed somehow, because sintatically, the context is undetermined

[11:49] <ruoso> pmurias, why would it need to?

[11:49] <pmurias> so it can export to a scope instead of a package?

[11:49] <avar> C/w 13

[11:50] <ruoso> pmurias, I presume it should be some $+VARIABLE

[11:50] *** Minthe joined
[11:51] <ruoso> or $*VARIABLE

[11:51] <pmurias> ruoso: btw. is there anything you want me to work on?

[11:51] <ruoso> well, if you have some spare time, you could take the named arguments

[11:52] <ruoso> I need to focus on other projects today

[11:53] <ruoso> there's the ROADMAP/signature-named.t test

[11:54] <pmurias> ok

[11:55] <pugs_svn> r24828 | ruoso++ | [mildew] implement Item assignment... List assignment is currently incorrect in mildew, but STD is misparsing a lot of things as List_assignment where they are not.\

[12:02] *** Minthe left
[12:04] <pmurias> ruoso: it might make sense if EXPORTALL received a target argument, as one might want to import thing into somewhere else

[12:05] <pmurias> like when implementing a policy module

[12:06] <ruoso> pmurias, there's something in the spec about ir

[12:13] <pmurias> ir = ?

[12:19] *** ruoso left
[12:22] *** alc left
[12:23] *** ruoso joined
[12:24] <ruoso> s/ir/it/

[12:24] <ruoso>  I'll throw out an idea here, just because it's been hammering my head for some time, but I couldn't actually structure it, and maybe someone makes it usefull... Somehow I think the grammar engine could benefit a lot from treating the string as an iterator and using continuations for each "branch" in the parsing... It also occured to me that this iterator could store cache information saying "the token foo failed at this position", or "the token bar suceeded 

[12:24] <ruoso> a t this position and here's a match object"... but as I said, it's just something that I've been thinking for a while without much development...

[12:27] <moritz_> ruoso: I think it's already planned (or even implemented in Cursor.pm) that way

[12:27] <moritz_> or at least that's what metholate tried to do, with the continuations in gather/take blocks

[12:28] <pmurias> STD.pmc uses Cursor objects

[12:29] <pugs_svn> r24829 | moritz++ | [t/spec] more tests for ~ in regexes

[12:31] <ruoso> moritz_, but does Cursor decides which continuation to execute at which moment? that would be the center of the idea, including for LTM

[12:32] <moritz_> ruoso: I don't know, I'm not that familiar with STD & co

[12:32] <ruoso> ok... well.. the idea is there for someone who, unlike me, knows what he's talking about ;)

[12:36] <ruoso> could someone give me access to the machine that runs the pugs-commit mail (or do the change in the hook without giving me access, which would be better ;)? 

[12:39] <pugs_svn> r24830 | moritz++ | [t/spec] tests for ~ in regexes with mutually recursive rules

[12:40] <moritz_> ruoso: see http://feather.perl6.nl/ - contact Juerd

[12:51] <pmurias> STD.pmc uses Cursor objects

[12:51] <pmurias> sorry

[12:52] *** Lorn joined
[12:56] <pmichaud> perl6: sub foo(@a) { say @a.elems; };  foo([1,2,3]);

[12:56] <p6eval> elf 24830, pugs, rakudo 35296: OUTPUT«3␤»

[12:56] <pmichaud> perl6: sub foo(@a) { say @a.elems; };  foo(([1,2,3]));

[12:56] <p6eval> elf 24830, pugs, rakudo 35296: OUTPUT«3␤»

[12:56] <pmichaud> perl6: sub foo(@a) { say @a.elems; };  foo(([1,2,3],));

[12:57] <p6eval> pugs, rakudo 35296: OUTPUT«1␤»

[12:57] <p6eval> ..elf 24830: OUTPUT«3␤»

[12:58] <moritz_> is the first one correct?

[12:58] <pmichaud> I'm thinking perhaps no.

[12:58] <pmichaud> rakudo gives a different answer in rvar.

[12:58] <pmichaud> (rakudo thinks the answer is 1)

[12:58] <moritz_> I can explain the current answer by assuming that [1, 2, 3] is bound to @a, not assigned

[12:59] *** ejs joined
[12:59] *** ejs left
[12:59] *** Helios- is now known as Helios

[12:59] <pmichaud> yes, I was thinking that also.  It just feels funny.

[12:59] <moritz_> but given that foo(1, 2, 3) certainly should give 3, it seems more logical to return 1 on foo([1, 2, 3])

[12:59] <moritz_> perl6: sub foo(@a) { say @a.elems; }; foo(1, 2, 3)

[12:59] <p6eval> elf 24830: OUTPUT«Can't call method "elems" without a package or object reference at (eval 121) line 4.␤ at ./elf_f line 3861␤»

[12:59] <p6eval> ..rakudo 35296: OUTPUT«too many arguments passed (3) - 1 params expected␤current instr.: 'foo' pc 86 (EVAL_14:50)␤»

[12:59] <p6eval> ..pugs: OUTPUT«*** No compatible multi variant found: "&foo"␤    at /tmp/giWgSoIR4T line 1, column 32 - line 2, column 1␤»

[12:59] <pmurias> ruoso: if you want the named parameter extraction to be done by STD does it make much sense for me to implement named parameters in mildew now?

[12:59] <pmichaud> no, foo(1,2,3) wouldn't match.

[13:00] <pmichaud> (3 args instead of 1)

[13:00] <moritz_> right

[13:00] <moritz_> perl6: sub foo(@a) { say @a.elems; }; foo((1, 2, 3))

[13:00] <p6eval> pugs, rakudo 35296: OUTPUT«3␤»

[13:00] <p6eval> ..elf 24830: OUTPUT«Can't call method "elems" without a package or object reference at (eval 121) line 4.␤ at ./elf_f line 3861␤»

[13:00] <pmichaud> (I'm guessing rebuild.)

[13:00] <pmichaud> okay, there.

[13:00] <moritz_> perl6: sub foo(@a) { say @a.elems; }; foo(<1 2 3>)

[13:00] <p6eval> elf 24830, pugs, rakudo 35296: OUTPUT«3␤»

[13:01] <masak> all three agree! :)

[13:01] <ruoso> pmurias, I think STD won't really be changed...

[13:01] <moritz_> masak: what a crazy randomhappenstance

[13:02] <masak> moritz_: it's a cause for celebration!

[13:05] <pmichaud> so, what's the right answer on the array passage?

[13:05] <pmichaud> 1 element, or 3?  ;-)

[13:05] <moritz_> "yes" *duck*

[13:06] <masak> :)

[13:06] <moritz_> I just don't know

[13:06] <pmichaud> oh, of course.   it's    any(1,3)   :-)

[13:06] <masak> Perl 6 is full of these mysteries.

[13:07] <moritz_> I think I've wrote tests for this

[13:07] <moritz_> t/spec/S06-signature/passing-arrays.t

[13:08] <pmichaud> rakudo currently passes those.

[13:08] <moritz_>     sub count(@a) {

[13:08] <moritz_>         my $x = 0;

[13:08] <moritz_>         $x++ for @a;

[13:08] <moritz_>         return $x;

[13:08] <moritz_>     }

[13:08] <ruoso> pmichaud, moritz_, foo(<1 2 3>) is one argument only 

[13:08] <pmichaud> what it had trouble with was integration/*31-49*

[13:08] <moritz_>     is count([1, 2, 3, 4]),       1, 'count([1, 2, 3, 4])';

[13:08] <pmichaud> ruoso: I know that -- no question there.

[13:08] <ruoso> where's the question then?

[13:08] <pmichaud> all of them are one argument.

[13:08] <moritz_> ruoso: what @a.elems should return

[13:09] <ruoso> 3

[13:09] <pmichaud> the question is whether   foo([1,2,3])  leaves @a with a single element or with three.

[13:09] <ruoso> [1,2,3] will leave a with 1 argumetn

[13:09] <moritz_> ok

[13:09] <ruoso> s/argument/element/

[13:09] <ruoso> for the same reason

[13:09] <ruoso> my @a = [1,2,3]; say @a.elems also returns 1

[13:09] <masak> seems reasonable.

[13:09] <ruoso> perl6: my @a = [1,2,3]; say @a.elems

[13:09] <moritz_> that's consistent with the first test in passing-arrays.t

[13:09] <p6eval> pugs, rakudo 35296: OUTPUT«1␤»

[13:09] <p6eval> ..elf 24830: OUTPUT«3␤»

[13:10] <moritz_> perl6: my @a := [1,2,3]; say @a.elems

[13:10] <p6eval> pugs: OUTPUT«1␤»

[13:10] <p6eval> ..elf 24830: OUTPUT«syntax error at (eval 117) line 3, at EOF␤ at ./elf_f line 3861␤»

[13:10] <p6eval> ..rakudo 35296: OUTPUT«3␤»

[13:10] * pmichaud snickers.

[13:10] <moritz_> that's where we start to differ

[13:10] <ruoso> that should be 3

[13:10] <pmichaud> anyway, if the answer to @a.elems is 1 for the foo([1,2,3]) case, I'm very happy with that.

[13:11] <ruoso> because you're binding... and binding means that @a will *be* the array [1,2,3]

[13:11] <moritz_> pmichaud: does it cause spec test (not integration) failures?

[13:11] <pmichaud> moritz_: no, spectests are almost all working now in rvar branch.

[13:11] <pmichaud> it's just the integration tests that are left.

[13:11] <moritz_> the 99problems*.t aren't reviewed that thoroughly; I just looked at those that didn't work in rakudo

[13:11] <pmichaud> (a couple of unrelated spectest failures)

[13:11] <ruoso> the binding of a value inside a signature is different from plain binding

[13:12] <moritz_> maybe some need @(...) around some arguments

[13:12] <ruoso> or (|[1,2,3]) if you really want

[13:13] <ruoso> because using @(...) will force list context before the binding

[13:13] <ruoso> and using (|[1,2,3]) will defer the context to the signature binding

[13:14] <moritz_> perl6: sub foo(@a) { say @a.elems; }; foo(|[1, 2, 3]) # I expect the worst...

[13:14] <p6eval> elf 24830: OUTPUT«Undefined subroutine &GLOBAL::prefix__124 called at (eval 123) line 5.␤ at ./elf_f line 3861␤»

[13:14] <p6eval> ..pugs: OUTPUT«*** No compatible multi variant found: "&foo"␤    at /tmp/rXO8tCn0VK line 1, column 32 - line 2, column 1␤»

[13:14] <p6eval> ..rakudo 35296: OUTPUT«too many arguments passed (3) - 1 params expected␤current instr.: 'foo' pc 108 (EVAL_14:52)␤»

[13:14] <ruoso> moritz_, notice that you need an extra () to make it one positional argument

[13:14] <ruoso> otherwise you're saying that you want to expand it as the capture

[13:14] <moritz_> perl6: sub foo(@a) { say @a.elems; }; foo((|[1, 2, 3])) # I expect the worst...

[13:14] <p6eval> rakudo 35296: OUTPUT«3␤»

[13:14] <p6eval> ..elf 24830: OUTPUT«Undefined subroutine &GLOBAL::prefix__124 called at (eval 123) line 5.␤ at ./elf_f line 3861␤»

[13:14] <p6eval> ..pugs: OUTPUT«*** No compatible multi variant found: "&foo"␤    at /tmp/ccXOJjtYpM line 1, column 32 - line 2, column 1␤»

[13:14] <ruoso> rakudo++

[13:15] <moritz_> rakudo++

[13:15] <moritz_> indeed

[13:15] <moritz_> pmichaud: I'll be gone over the weekend, but I can clean up passing TODO tests when I return on Sunday

[13:16] <moritz_> (I just was reluctant to do it with the subst.t ones, because we should get spec clarification first)

[13:16] <ruoso> and now STD also accepts \$foo in the signature to delay the context even more

[13:20] <ruoso> so you can say foo(bar(baz())) where bar delays the context of the return of baz to the signature of foo

[13:20] <ruoso> (ok, that could be done with the slurpy capture...)

[13:21] <ruoso> but foo(bar(baz(),1,2,3))

[13:21] <moritz_> it took me three attempts and to parse and understand that sentence ;)

[13:21] <moritz_> s/and//

[13:30] *** pmurias left
[13:35] *** cornelius__ left
[13:40] *** pmurias joined
[13:44] *** masak left
[13:46] *** kisu_ left
[13:47] *** araujo left
[13:51] *** mj41 joined
[13:51] *** kisu joined
[13:52] *** meppl left
[13:54] *** kisu left
[13:54] *** kisu joined
[14:00] *** ludan joined
[14:00] <rakudo_svn> r35300 | moritz++ | [rakudo] add test for ~ in regexes to spectest.data

[14:02] *** araujo joined
[14:02] *** riffraff left
[14:07] *** kisu left
[14:12] *** spx2 left
[14:12] *** kisu joined
[14:14] *** spx2 joined
[14:14] *** donaldh joined
[14:16] *** kisu left
[14:19] *** kisu joined
[14:23] <pugs_svn> r24831 | jnthn++ | [t/spec] Correct test count.

[14:25] <moritz_> jnthn: did you count them? now that test fails in trunk

[14:25] <jnthn> moritz_: Yeah, I did.

[14:26] <jnthn> I could see 24 tests.

[14:27] <jnthn> moritz_: Plus running it at the command line here gives output up to a test 24

[14:27] <moritz_> but why does it run only 21 in trunk? /me *confused*

[14:27] <jnthn> moritz_: I ponder if the line start my $eval1 = '{

[14:28] <jnthn> And the 3 tests in there

[14:28] <jnthn> Didn't get run

[14:28] <moritz_> ah

[14:28] <jnthn> But we never made sure that this eval succeeded

[14:28] <jnthn> ok eval('!try { my Num::Even $d }'), "lexically declared subtype went out of scope";

[14:28] <jnthn> And that one then probably passed for the wrong reason.

[14:30] <moritz_> ok, I commited a hack that works for now

[14:30] <pugs_svn> r24832 | moritz++ | [t/spec] hack subtypes.t to get right plan even if an eval() failed

[14:31] <moritz_> which isn't very good at all

[14:31] <moritz_> but at least the plan is right in both cases

[14:41] *** gbacon joined
[14:50] *** pdcawley left
[14:51] *** pdcawley joined
[15:00] *** cspencer joined
[15:02] *** alc joined
[15:05] *** athenot joined
[15:06] *** alc left
[15:06] *** mtnviewmark joined
[15:07] <pugs_svn> r24833 | jnthn++ | [t/spec] Remove some Win32-specific logic on a test that saw us flunk it on Win32, when in fact it works fine on Rakudo on Win32.

[15:10] *** mtnviewmark left
[15:15] *** jan_ left
[15:15] *** [particle] joined
[15:20] <rakudo_svn> r35307 | pmichaud++ | [rakudo]: spectest-progress.csv update: 279 files, 6172 passing, 0 failing

[15:22] <pugs_svn> r24834 | pmichaud++ | [t/spec]:  #?rakudo skip a test in 99problems-51-to-60.t

[15:30] *** DemoFreak left
[15:45] *** FurnaceBoy joined
[15:49] <pugs_svn> r24835 | pmichaud++ | [t/spec]:  #?rakudo skip some tests that may be incorrect.

[15:55] *** donaldh left
[15:57] *** FurnaceBoy left
[16:00] <rakudo_svn> r35311 | pmichaud++ | [rakudo]:  Merge rvar2 branch to trunk.

[16:00] <rakudo_svn> r35311 | pmichaud++ | This is a major refactor of variable and parameter handling in Rakudo.

[16:00] <rakudo_svn> r35311 | pmichaud++ | jonathan++, particle++, and others for assistance with the branch.

[16:05] *** eternaleye left
[16:05] *** alester joined
[16:06] *** alester left
[16:06] *** alester joined
[16:12] *** Eevee joined
[16:20] <rakudo_svn> r35312 | infinoid++ | [cage] More trailing whitespace fixes.

[16:20] <pugs_svn> r24836 | pmichaud++ | [rakudo]:  Unfudge passing todo in assign.t.

[16:22] <pugs_svn> r24837 | pmichaud++ | [t/spec]:  unfudge passing rakudo test in main.t.

[16:23] *** mtnviewmark joined
[16:29] *** jan_ joined
[16:31] *** DemoFreak joined
[16:32] *** mtnviewmark left
[16:32] <pugs_svn> r24838 | pmichaud++ | [t/spec]:  Unfudge passing todo in passing-arrays.t .

[16:33] *** stephens joined
[16:35] *** Eevee left
[16:35] *** Eevee joined
[16:37] <pugs_svn> r24839 | pmichaud++ | [t/spec]:  Unfudge passing todo test in instance.t (RT #61100)

[16:38] <pugs_svn> r24840 | pmichaud++ | [t/spec]:  Unfudge passing rakudo todo test from 99problems-01-to-10.t

[16:39] *** jhorwitz joined
[16:39] <pugs_svn> r24841 | pmichaud++ | [t/spec]:  Unfudge passing rakudo todo test from lexicals-and-attributes.t

[16:43] <pugs_svn> r24842 | pmurias++ | [mildew]

[16:43] <pugs_svn> r24842 | pmurias++ | mildew .so objects receive a back continuation

[16:43] <pugs_svn> r24842 | pmurias++ | added a --valgrind option

[16:43] <pugs_svn> r24842 | pmurias++ | the things the compiler hasn't implemented yet are highlighted with about 6 lines of context

[16:44] <pmichaud> perl6:  sub foo(@a) { say @a.WHAT; };  foo(1);

[16:45] <p6eval> rakudo 35312: OUTPUT«Array␤»

[16:45] <p6eval> ..pugs: OUTPUT«Array::Const␤»

[16:45] <p6eval> ..elf 24841: OUTPUT«Int␤»

[16:45] <cspencer> do multi methods dispatch based only on the parameter signatures, or will they also be eventually able to do so based on return types?

[16:45] *** ludan left
[16:46] <PerlJam> cspencer: the latter

[16:46] <pmichaud> S06-signature/passing-arrays.t:30 claims that the above should die.

[16:46] <cspencer> thanks :)

[16:46] <pmurias> but it's specced to be post 6.0.0

[16:46] <cspencer> ah ok

[16:46] *** DemoFreak left
[16:49] *** cspencer left
[16:50] <pmichaud> okay, time to close some tickets!

[16:51] <TimToady> @a should have 3 elements

[16:51] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v

[16:51] <TimToady> ruoso: those are specced to be list assignments

[16:52] <pmichaud> TimToady: you mean in my sub foo(@a) { say @a.elems; };   foo([1,2,3]); example?

[16:53] <TimToady> yes

[16:53] <pmichaud> ouch.

[16:53] <TimToady> always been that way

[16:53] <wolverian>  /aw

[16:53] <TimToady> the only reason foo((1,2,3)) works the same is by promotion of list in item context to Array

[16:54] <pmichaud> oh, I understand that part.

[16:54] <pmichaud> I'm wondering how to distinguish    foo([1,2,3])  from other uses of [1,2,3] in a list.

[16:55] <TimToady> such as?

[16:55] <pmichaud> foo(([1,2,3], 4));   # 2

[16:55] <TimToady> that's a list of 2 elements

[16:55] <pmichaud> right now rakudo has circumfix:<[ ]> returning a scalar reference to an array

[16:55] <pmichaud> so that it won't flatten in list context

[16:56] <pmichaud> as in this case:

[16:56] <pmichaud> my $a = [1,2,3];   foo($a);

[16:56] <TimToady> yes, that seems fine

[16:56] <TimToady> that should also say 3

[16:57] <pmichaud> last question, then:  how about   foo(1)?

[16:57] <pmichaud> it autopromotes the 1 into an Array?

[16:57] <TimToady> depends on what we decide about @a := 1

[16:57] <TimToady> but I'd say that 1 probably doesn't provide a Positional role

[16:57] <TimToady> so the binding fails

[16:58] <pmichaud> okay, that answers another question I had, then :-)

[16:59] *** fridim__ joined
[16:59] <TimToady> and 1.[0] only works because we force the 1 to promote to something positional

[17:00] <TimToady> not because 1 is intrinsically positional

[17:00] <PerlJam> TimToady: Just to see what I hope is the obvious answer, would a "string" provide a Positional role?

[17:00] <pmichaud> okay, that changes the answer I thought I had. :-)

[17:00] <TimToady> there's no such thing as a "string" in Perl 6 :)

[17:00] <TimToady> Str does not provide Positional, while Buf does

[17:01] <TimToady> (as currently specced)

[17:01] <PerlJam> makes sense to me.

[17:01] <pmichaud> so, to recap

[17:02] <pmichaud> with sub foo(@a) { say @a.elems; }

[17:02] <TimToady> Strs are unitary like numbers, so "foo".[0] returns "foo"

[17:02] <TimToady> any top-level commas contribute to the Capture, not to the first arg

[17:03] <pmichaud> foo(1)  # error, 1 ~~ Positional fails

[17:03] <pmichaud> foo((1,2,3))   # outputs 3

[17:03] <pmichaud> foo([1,2,3])   # outputs 3

[17:04] <pmichaud> my $a = (1,2,3);  foo($a);   # outputs 3

[17:04] <TimToady> and foo(1,2,3) fails

[17:04] <pmichaud> and yes, foo(1,2,3) fails   # too many params

[17:04] <pmichaud> okay, I can make that work.

[17:05] <TimToady> foo([1,2,3],) should probably produce 3 too

[17:05] <TimToady> since the top , is a Capture comma, not a List comma

[17:05] <TimToady> but we've never said anything about extra commas in Captures...

[17:06] <TimToady> seems like they should be allowed though

[17:07] <TimToady> interesting that that overloading of comma goes all the way back to C

[17:07] <pmichaud> another case

[17:07] <TimToady> arglist comma is not operator comma

[17:07] <pmichaud> oh, never mind.

[17:08] <pmichaud> I figured it out :-)

[17:08] <TimToady> :D

[17:10] <PerlJam> foo((1,2,3)) is weird though.  It wants to chunk in my head as "foo (( 1,2,3 ))" which makes me want to write it that way (mildly)

[17:10] <pmichaud> then write it as  foo([1,2,3])  :-)

[17:10] <TimToady> or as foo (1,2,3)

[17:11] <PerlJam> TimToady: but would   foo ((1,2,3)) have any adverse effects?  It seems like something you'd want a warning for "Hey, this is better written as ..."

[17:12] <pmichaud> I think that actually works out the same in this case :-)

[17:12] <pmichaud> it's eqivalent to   foo  [(1,2,3)]

[17:12] * pdcawley has recently had his head warped by Smalltalk, where comma is just another binary method so 'foo , bar' sends the message ', bar' to foo...

[17:12] <pmichaud> *equivalent

[17:13] *** hercynium joined
[17:14] *** km2 joined
[17:16] <pmichaud> okay, here's another set

[17:16] <pmichaud> sub foo(%h) { ... };   foo( (a => b) );

[17:17] <pmichaud> binding error?  

[17:19] <TimToady> I think a Pair is Associative

[17:19] <pmichaud> okay.

[17:20] <pmichaud> so  (a => 'b')<a>  gives 'b'

[17:20] <TimToady> yes

[17:20] <TimToady> and .keys differs from .key only in that it gives a list instead of an item

[17:23] *** cornelius__ joined
[17:23] *** cornelius__ left
[17:26] <ruoso> TimToady, I don't get it... why is "$a.[1] = 'bar'" a list assignment 

[17:26] <ruoso> ?

[17:27] <TimToady> because it's not a simple scalar *syntactically*.  it has a postfix

[17:27] <ruoso> but it's not a list also

[17:27] <ruoso> it might be undetermined

[17:27] <TimToady> we discovered in years past that this is a rathole :)

[17:28] <TimToady> which is why the rule is now simple

[17:28] <PerlJam> simplicity++

[17:29] <TimToady> course, it's not entirely a free lunch

[17:30] <TimToady> you still have to decide how to treat $x[1] vs $x[1,2] at run time

[17:31] <TimToady> so $x[1] = 1,2,3 turns 1,2,3 into [1,2,3]

[17:31] <TimToady> but $x[1,2] = 1,2,3 produces a warning about the discarded element

[17:32] <pmurias> TimToady: is there anything i could do to make STD faster?

[17:33] <TimToady> well, there are several possibilities for speedups

[17:33] <TimToady> a real DFA matcher, for one

[17:34] <TimToady> pulling out the prelude defs

[17:34] <TimToady> but that implies a mechanism for dumping current lexpads and for starting current compile in preexisting lexical scope for prelude

[17:35] <TimToady> having a real lazy list implementation in Perl 5 would help

[17:36] <TimToady> having recursive regex in P5 with real closures would help :)

[17:37] <TimToady> another thing that will speed up derived languages is not deriving all the data structures from scratch each time whenever you see a macro

[17:38] <TimToady> there's obviously a lot of commonality between related languages that is not adequately shared

[17:39] <TimToady> the token/fate longest token generation is currently done by patching together strings, which could be a more efficient data structure

[17:39] *** pbuetow joined
[17:40] <TimToady> but according to NYTProf, the using a trie matcher instead of a dfa matcher is probably what hurts the most right now

[17:41] <TimToady> so I don't know if the answer is "yes" or "no" :)

[17:42] <TimToady> I didn't want to tackle some of these things before gimme5 was rewritten as viv

[17:42] <TimToady> which stalled out

[17:45] <ruoso> TimToady, so every list assignment actually means "unknown context"

[17:45] <TimToady> it's also possible we could speed up things by changing the parsing rules for metaoperators so as not to inflict all the variants on the LTM, but I'd rather avoid that if we can make LTM work for large token sets

[17:46] <TimToady> yes, that was the price for not analyzing subscripts for itemicity, which led to madness

[17:47] <pmurias> TimToady: i seem to have lost the link to the tdfa paper, could you find it again?

[17:47] <TimToady> but this is reall only a problem for assignment, not binding

[17:47] <ruoso> so, let's just rename it to "unknown assignment" :)

[17:47] <ruoso> although... my @a = something has a more determined context

[17:48] <TimToady> pmurias: um, I don't think tdfa is what we want.  when I ripped out TRE it sped up twice as fast. :)

[17:49] *** cspencer joined
[17:50] <TimToady> the TRE algorithm was allocating 19MB on the stack for every match!

[17:51] <TimToady> something more like the dynamically generated state sets in egrep is what we need

[17:51] <TimToady> where we cache the first N of those in a trielike fashion

[17:51] <TimToady> but don't build out a full trie for \w* and such

[17:52] *** quatrix joined
[17:55] <pmurias> would using a normal DFA to find the longest token and then rematching with a NFA to find which parts of the string matched what work?

[17:55] <TimToady> well, "first N" is misleading.  we should cache common words in the trie, and branch out at varying quantifies of N

[17:55] <TimToady> *quantities

[17:56] <TimToady> we already rematch in the recursive descent

[17:56] <TimToady> the DFA merely has to produce the correct fate

[17:57] <TimToady> the egrep algorithm, unfortunately, loses info on which alternative you took

[18:00] <TimToady> bbl &

[18:03] <avar> Is that inherent in the algorithm or just a case of egrep not keeping around that data?

[18:04] * ruoso wonders how to detect the context at which the assignment is made

[18:04] * ruoso later &

[18:04] *** ruoso left
[18:10] <rakudo_svn> r35314 | jonathan++ | [rakudo] Get rid of !TYPECHECKPARAM, and make the one thing use it just do the check itself (will go away once we get Perl 6 prelude).

[18:12] <azawawi> std: if($n > 1) {}

[18:12] <p6eval> std 24842: OUTPUT«############# PARSE FAILED #############␤Syntax error at /tmp/BDxNV7RkE4 line 1:␤------> [32mif($n > 1) [31m{}[0m␤    expecting any of:␤  infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤00:05 86m␤»

[18:12] <azawawi> std: if ($n > 1) {}

[18:12] <p6eval> std 24842: OUTPUT«00:05 86m␤»

[18:13] *** estrabd left
[18:13] <azawawi> I think there is a problem with STD parsing here...

[18:14] <azawawi> moritz_: ping

[18:16] <azawawi> std: my $n = 1; if($n > 1) {}

[18:16] <p6eval> std 24842: OUTPUT«############# PARSE FAILED #############␤Syntax error at /tmp/ENWMYrMyzC line 1:␤------> [32mmy $n = 1; if($n > 1) [31m{}[0m␤    expecting any of:␤       infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤00:05 86m␤»

[18:16] <PerlJam> azawawi: er, what's the problem?  if() is not the same as if ()

[18:16] <azawawi> perljam: if() is a function?

[18:17] <PerlJam> looks like a duck, quacks like a duck ... it's a duck  :)

[18:18] <azawawi> rakudo: my $n = 5; if($n > 1) { ">5".say; }

[18:18] <p6eval> rakudo 35314: OUTPUT«>5␤»

[18:18] <azawawi> std: my $n = 5; if($n > 1) { ">5".say; }

[18:18] *** Psyche^ joined
[18:18] <p6eval> std 24842: OUTPUT«############# PARSE FAILED #############␤Syntax error at /tmp/AnWn0nOndt line 1:␤------> [32mmy $n = 5; if($n > 1) [31m{ ">5".say; }[0m␤    expecting any of:␤    infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤00:05 87m␤»

[18:18] <azawawi> perljam: it seems like a bug

[18:20] <rakudo_svn> r35315 | jonathan++ | [rakudo] Rip out more unused code.

[18:20] <rakudo_svn> r35317 | jonathan++ | [rakudo] One more unused function I missed last time that we can now rip out.

[18:22] *** lauct joined
[18:25] *** braceta joined
[18:26] *** braceta left
[18:26] *** braceta joined
[18:30] *** Patterner left
[18:30] *** Psyche^ is now known as Patterner

[18:35] *** justatheory joined
[18:35] <TimToady> azawawi: it is fundamental in p6 that foo() is always a function call, regardless of how the language might change around it

[18:36] <TimToady> just as it is fundamental that postfixes never allow intermediate whitespace

[18:37] <TimToady> we need a few absolutes to keep things flexible everywhere else

[18:37] <azawawi> TimToady: so in p5 if($x > 1) becomes in p6 if $x > 1, right?

[18:38] <TimToady> well, I never wrote it that way in p5 :)

[18:38] <TimToady> but yes

[18:39] <azawawi> so it seems rakudo assumes it is a p5 if...

[18:39] <azawawi> rakudo: my $n = 5; if($n > 1) { "greater than 1".say; }

[18:39] <p6eval> rakudo 35317: OUTPUT«greater than 1␤»

[18:39] <TimToady> that should fail

[18:40] <TimToady> you're calling the "interface" function or some such :)

[18:40] <azawawi> oh well it is win win situation... it was either an STD or rakudo bug :)

[18:40] <azawawi> actually i was trying the factorial example in rakudo and found out that STD in Padre does not like it.

[18:41] <azawawi> TimToady: thx

[18:41] <TimToady> p6 also requires whitespace before the block, so if($x){...} is doubly wrong, but parses

[18:41] <TimToady> fortunately, there's probably not an if() function

[18:42] <TimToady> std: if($x){return}

[18:42] <cspencer> will the "is instead" trait apply to classes as well as subroutines? 

[18:42] <p6eval> std 24842: OUTPUT«Unknown routines:␤     if called at 1 ␤00:05 86m␤»

[18:42] <cspencer> ie) if i wanted to replace a previously declared class, i'd use: class Foo is instead { ... }

[18:43] <TimToady> it was originally targetted at classes :)

[18:43] <cspencer> ah ok

[18:43] <TimToady> but then generalized

[18:43] <cspencer> i'd seen it in the subroutine section of S06 and was wondering :)

[18:43] <TimToady> there's a sense in which "multi" means "is also"

[18:44] <TimToady> so I wonder what a multi class is  :)

[18:44] <cspencer> heh :)

[18:45] <TimToady> maybe it's just a class that is documented as being extensible

[18:45] <TimToady> so class is also is Officially Evil, which multi class is Officially Good  :)

[18:45] <TimToady> s/which/while/

[18:45] <azawawi> rakudo: my $x = 0; if($x > 1) { say '>1' } else { say '<=1'; }

[18:45] <p6eval> rakudo 35317: OUTPUT«<=1␤»

[18:46] <cspencer> are classes not extensible by default?

[18:46] <TimToady> you get a warning without "is also"

[18:46] <cspencer> ah ok

[18:46] *** justatheory left
[18:46] *** justatheory joined
[18:47] <azawawi> @tell moritz_ rakudo should fail on if($x > 1) {} like STD

[18:47] <TimToady> and maybe a multi class cannot be closed by the optimizer

[18:47] <lambdabot> Consider it noted.

[18:47] <PerlJam> azawawi: do you have a pugs commit bit?

[18:48] <azawawi> perljam: yup

[18:48] <PerlJam> azawawi: submit a test for it (if there isn't one already)

[18:49] <azawawi> perljam: right away, Sir :)

[18:55] <[particle]> faster!

[18:55] <azawawi> found the related doc http://perlcabal.org/syn/S04.html#line_1210

[18:55] <azawawi> lol

[18:58] *** jhorwitz left
[19:08] *** justatheory left
[19:08] *** justatheory joined
[19:10] <rakudo_svn> r35318 | jonathan++ | [rakudo] Start getting the type registry stuff in place. This patch adds (currently stub) add_type and is_type method on Perl6::Grammar and inserts calls to them, following the STD.pm approach. No functional changes.

[19:19] *** wirefire joined
[19:36] <pugs_svn> r24843 | azawawi++ | [t/spec] Added test for required whitespace after a built-in statement (if,for,while).

[19:51] *** cspencer left
[20:00] *** kidd left
[20:03] *** Lorn left
[20:04] *** masak joined
[20:05] *** kidd joined
[20:15] *** fridim__ left
[20:21] *** Helios is now known as Helios-

[20:22] *** Helios- is now known as Helios

[20:26] *** braceta left
[20:28] *** pcbuetow joined
[20:28] *** kidd left
[20:42] *** kisu_ joined
[20:43] *** pbuetow left
[20:47] *** kisu left
[20:50] *** meppl joined
[20:57] <pugs_svn> r24844 | particle++ | [S19] a little copy-editing

[21:03] <pugs_svn> r24845 | Util++ | [t/spec] Typo - s/ precendence / precedence /

[21:05] <pugs_svn> r24846 | particle++ | [S19] describe how to avoid ambiguity when nesting delimited options

[21:11] <pmichaud> TimToady: I know I've asked this before, but I'm a bit confused again

[21:11] <pmichaud> if we have  (1, 2, 3, @a)   then @a flattens into the list

[21:11] *** Ehtyar joined
[21:11] <pmichaud> if we have (1, 2, 3, [4])  then the [4] doesn't flatten into the list

[21:11] <pmichaud> presumably @a and [4] are both of type Array, so what distinguishes them?

[21:13] <TimToady> I suspect [4] is more like \@a

[21:13] <TimToady> or Scalar of Array maybe

[21:13] <pmichaud> okay, that's what rakudo does now.

[21:13] <pugs_svn> r24847 | particle++ | [S19] add notes for further design review

[21:13] <pmichaud> basically \@a

[21:14] <pmichaud> so if we have sub foo(@x) { ... }   and then call foo([4])

[21:14] <pmichaud> @x gets bound to the Scalar of Array ?

[21:14] <lambdabot> Maybe you meant: . ? @ v

[21:14] <pmichaud> or we figure out that it's a scalar and de-scalarize it, or ...?

[21:14] <pmichaud> (because it's a Scalar that references a Positional)

[21:15] <TimToady> not sure what the best way to think of it is, except that Scalar loves to hide itself from method calls

[21:15] <TimToady> bit distracted--in a meeting (again)

[21:15] <pmichaud> okay

[21:15] <pmichaud> you gave me enough clues to go in the right direction, I think.  At least for a couple of hours.

[21:17] <diakopter> bit distracted by irc, or bit distracted by the meeting?

[21:17] <TimToady> the two are not mutually exclusive :)

[21:18] <pugs_svn> r24848 | particle++ | [S19] a note on assumptions

[21:22] <PerlJam> TimToady: Quick!  Say something profound and insightful that totally derails the meeting.  :)

[21:23] *** c9s_ joined
[21:35] *** donaldh joined
[21:36] <TimToady> pmurias: when I said DFA above, I really meant parallel NFA

[21:36] <TimToady> bad habit of mine to confuse NFA with backtracking...

[21:41] *** c9s left
[21:42] *** aindilis` left
[21:49] *** DemoFreak joined
[21:53] *** wirefire left
[22:01] *** kisu_ left
[22:04] *** ft joined
[22:06] *** kisu joined
[22:10] *** aindilis joined
[22:13] <masak> rakudo: my Any $x .= new; say $x.values

[22:13] <p6eval> rakudo 35320: OUTPUT«Method '!flatten' not found for invocant of class 'Any'␤current instr.: 'parrot;Any;values' pc 10962 (src/builtins/any-list.pir:642)␤»

[22:13] <masak> don't ask me how I find these.

[22:13] * masak submits rakudobug

[22:16] *** sri_kraih joined
[22:17] <TimToady> rakudo: say Any.values

[22:17] <p6eval> rakudo 35321: OUTPUT«Any␤»

[22:20] <TimToady> rakudo: say Any.new.values

[22:20] <p6eval> rakudo 35321: OUTPUT«Method '!flatten' not found for invocant of class 'Any'␤current instr.: 'parrot;Any;values' pc 10962 (src/builtins/any-list.pir:642)␤»

[22:20] *** pmurias left
[22:21] *** sri_kraih left
[22:21] *** sri_kraih joined
[22:26] *** mberends joined
[22:33] <masak> mberends: I am in your Pod::Parser, reviewing your code.

[22:34] <mberends> hi, and thanks. did you pull today from github, I posted some updates

[22:34] <masak> aye, just pulled.

[22:35] <mberends> first, tell me if the acknowledgements are they way you suggested

[22:35] <masak> when you write `if + @!podblocks > 0`, are you aware that `if @!podblocks` does the same thing?

[22:35] <masak> mberends: I'll look.

[22:36] <mberends> thanks, slimming is always good. that + was needed somewhere and became cargo

[22:36] <masak> mberends: that works, I think. the November project is only 'lea' by the two of us un the sense that we were first, not in the sense that we call the shots.

[22:36] <masak> mberends: it's more about using Perl's punning to your advantage than about slimming :)

[22:36] *** wknight8111 joined
[22:37] *** donaldh left
[22:37] <masak> overall, I like the compact style of your code.

[22:37] <mberends> re November, if the other members have another view, let me know

[22:37] <masak> I didn't think I would, but I do.

[22:37] <masak> ok.

[22:38] *** dukeleto left
[22:38] <masak> s/lea/lead/

[22:38] *** Exodist left
[22:38] <mberends> I went off K&R formatting and Perl Tidy a while back. perlcritic also drove me nuts.

[22:39] <masak> hm, you're inconsistent in where you put the opening method brace :)

[22:40] <mberends> the idea of compact layout is to reduce eye movement and scrolling. consistency is not everything, when it becomes rigidity.

[22:40] <TimToady> I'm consistently inconsistent

[22:40] *** Limbic_Region joined
[22:40] <TimToady> same line if it all fits on a line, and left margin otherwise

[22:40] <mberends> indeed

[22:40] <TimToady> well, lined up with keyword, not left margin

[22:41] <masak> that does not seem to be the rule here, however.

[22:41] <masak> here it's just sometimes same line, sometimes lined up

[22:41] <masak> anyway, I'm not complaining, just pointing it out.

[22:41] <mberends> I'm currently doing pod2xhtml and the pretty printing is not convenient, so I've bent the rules there too.

[22:42] <masak> it's a truly impressive chunk of code.

[22:43] <mberends> thanks, it's still evolving, there is a warning about refactoring

[22:43] <masak> yup, saw that.

[22:44] *** pdcawley left
[22:44] <masak> mberends: shouldn't you be doing that in a branch? :)

[22:44] <masak> rakudo: my @a = 1,2,3,4; say @a[*-1]

[22:44] <p6eval> rakudo 35321: OUTPUT«4␤»

[22:44] <masak> also, what's keeping you from using [*-1] ?

[22:45] *** riffraff joined
[22:45] <mberends> class A { has @!arr; method m { @!a[*-1] yada yada dies

[22:45] <masak> oh.

[22:45] <masak> should have guessed.

[22:45] <mberends> moritz asked yesterday

[22:46] <masak> rakudo: class A { has @!arr; ,method m { @!arr[*-1] } }; A.new.m

[22:46] <p6eval> rakudo 35321: OUTPUT«Unable to parse block; couldn't find final '}' at line 1, near ",method m "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[22:46] <masak> rakudo: class A { has @!arr; method m { @!arr[*-1] } }; A.new.m

[22:46] <p6eval> rakudo 35321: OUTPUT«Null PMC access in find_method()␤current instr.: 'parrot;A;_block31' pc 248 (EVAL_17:106)␤»

[22:46] <mberends> give it some data first

[22:46] <masak> is there a ticket for this?

[22:46] <mberends> dunno

[22:46] <masak> rakudo: class A { has @!arr = 1,2,3; method m { @!arr[*-1] } }; A.new.m

[22:46] <p6eval> rakudo 35321: OUTPUT«Null PMC access in find_method()␤current instr.: 'parrot;A;_block35' pc 292 (EVAL_17:114)␤»

[22:46] <masak> strange error.

[22:47] <mberends> you're much better at rakudobugs than I am

[22:47] <masak> mberends: yes, but I've deluged RT with tickets lately, so I can't find needles in haystacks anymore :/

[22:48] <masak> it takes some time, anyway.

[22:48] <mberends> did you see I submitted RT#62036?

[22:49] <masak> um, RT is slow.

[22:51] <mberends> you may have to patch your paths, but please read and run 'make test'

[22:51] <masak> hokay.

[22:52] <mberends> you'll understand why I was into backtick qx() etc a few weeks back

[22:52] <masak> I see an R#62030 submitted by you, but not an RT#62036.

[22:52] <mberends> sorry, 62030, yes

[22:53] * masak grumbles

[22:54] <masak> hm, yes, I remember seeing that ticket.

[22:56] <masak> mberends: the instructions in your Makefile contain the line 'make spectest_regression'. that is now spelled 'make spectest'.

[22:56] <mberends> consider it noted

[22:57] <masak> oh, I CAN HAZ PERL6LIB? I didn't know that!

[22:58] <masak> we should move some modules downstairs from p6w/, then.

[22:58] <mberends> essential for every module developer

[22:58] *** pdcawley joined
[22:58] *** pdcawley left
[22:59] <masak> well, apparently not. :/

[23:02] <masak> make WORKSFORME.

[23:03] <mberends> excellent. that's prove and Test::Harness in Perl 6 as well, none of this legacy nineties stuff

[23:04] <masak> sir, you rock.

[23:04] <masak> currently trying to get 'make test' to work.

[23:04] <masak> needs some path tweaking, because I don't store parrot where you do.

[23:05] <mberends> /home/me/parrot and /home/me/perl6-examples here

[23:05] <masak> yup. not here.

[23:05] <masak> guess I could just symlink for the time being.

[23:06] <masak> that worked.

[23:06] <mberends> it was a big kick to get unit tests going. In fact my dev work was thrashing without it.

[23:07] <masak> now getting thousands of "use of uninitialized value" warnings.

[23:07] <mberends> I'll need to sync up my parrot to feel your pain

[23:08] <masak> not sure you will feel it yet.

[23:08] <masak> might be here-specific.

[23:08] *** cspencer joined
[23:08] <masak> I still get "Unable to open filehandle" here.

[23:08] *** kisu left
[23:08] <mberends> probably directory related

[23:09] <masak> aye, probably.

[23:09] <mberends> insert $*ERR.say: "$stuff" for diagnostics

[23:10] <masak> mberends: should a `prove` without arguments really do nothing? the Perl 5 variety doesn't.

[23:11] <mberends> without arguments is wrong. maybe force in "t/*.t"

[23:11] <masak> I know it's wrong. I just tried it.

[23:12] <masak> ...to see what happened, I mean.

[23:12] <masak> IMO, an argumentless `prove` should recurse from the current directory, or something.

[23:13] <mberends> I think it's a directory problem. by glob() is a bit ugly, you may workaround with an absolute pathspec.

[23:13] <mberends> s/by/my/

[23:13] <masak> which line are we talking about?

[23:14] <pugs_svn> r24849 | Util++ | [docs] Typo - s/hueristic/heuristic/ in docs/Perl6/Makefile.PL

[23:16] <mberends> i guess prove --recurse t is drawing a blank. maybe call file_or_dir( '/home/masak/yada/t' )

[23:17] *** kisu joined
[23:17] *** kisu left
[23:17] <masak> mberends: I don't think that is the problem. it's more along the lines of perl6 not finding ../Test.pir

[23:17] *** kisu joined
[23:18] <masak> um, perhaps not. I'll try what you suggested.

[23:18] <hercynium> I'm playing with rakudo, and wonder if anyone can tell me what's wrong with this code:

[23:18] <hercynium> rakudo: sub f() { my @y = <1 2 3>; my @z = <a b c>; return (\@y,\@z) }; my (@a, @b) := f(); say @a; say @b; 

[23:18] <masak> mberends: so, which line are we talking about?

[23:18] <p6eval> rakudo 35321: OUTPUT«rtype not set␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[23:19] <masak> hercynium: 'return' currently does not take more than one argument.

[23:19] <hercynium> hmmm.... but it will someday, right?

[23:19] <masak> hercynium: yes.

[23:19] <masak> hercynium: for now, consider passing an array instead.

[23:20] <masak> as in `return [[@y], [@z]]`.

[23:20] <hercynium> yep... I was just scratching an itch for some syntax I dreamed up the other day and discovered is part of the spec :)

[23:20] <masak> heh. :)

[23:21] <masak> the spec and rakudo are slowly converging.

[23:21] <hercynium> binding a ref to a var that has a sigil that shows what the ref points to is *very* nice

[23:23] <masak> mberends: for line 11 in prove: &&= works. :)

[23:23] <mberends> re: prove, there is a separate Makefile target for Test.pir, because I wanted the Test.pm always out of parrot, so there are other paths involved. r35321 segfaults but passes 16 tests out of 21

[23:23] <masak> we should take Test.pm out of Parrot in November too. that's much better.

[23:24] <masak> mberends: ok, I'm officially stuck. I don't know how to make those tests.

[23:25] <masak> also, I'm thinking of sleep.

[23:26] <mberends> fair enough. and tomorrow you format you hard drive and use my directory layout, ok?

[23:26] <masak> meh

[23:26] <literal> http://zoffix.com/new/GumbyBRAIN-perl-urn-engraving/

[23:27] *** plainhao left
[23:27] <mberends> meantime I'll try to specify PARROT_DIR and LIB_DIR separately. new Makefile tomorrow.

[23:27] <masak> literal: I think that requires some explanation.

[23:27] <masak> mberends: looking forward to it.

[23:28] <mberends> thanks for being the guinea pig

[23:28] <masak> np.

[23:28] <masak> what goes around comes around. I assume you've tried to make November? :)

[23:29] <literal> masak: GumbyBRAIN is an IRC bot, basically an interface to one of these: http://megahal.alioth.debian.org/

[23:29] *** maerzhase left
[23:29] <masak> literal: yes.

[23:29] <masak> ...and the perl6 connection?

[23:29] <literal> it's just something he said

[23:29] <mberends> I read the November source closely to get started with grammar, but didn't run it

[23:29] <masak> aha.

[23:30] <pugs_svn> r24850 | pmichaud++ | [t/spec]:  Update split-simple.t to pass array arguments to list parameter.

[23:30] <masak> mberends: looking forward to you trying :) at least 'make test'.

[23:30] <mberends> goes around, comes around :) sure

[23:30] * masak sleeps

[23:30] *** masak left
[23:31] *** alester left
[23:35] *** dukeleto joined
[23:39] *** hercynium left
[23:40] <rakudo_svn> r35323 | jonathan++ | [rakudo] Get an UnderConstructionProto class added, and create it. However, don't put it in the namespace just yet - that causes breakage.

[23:44] *** vixey left
[23:49] *** mberends left
[23:50] <cspencer> rakudo: my @a = 1..4; for @a <-> $e { $e++ }; @a.join(' ').say

[23:50] <p6eval> rakudo 35323: OUTPUT«2 3 4 5␤»

[23:51] <cspencer> rakudo: my @a = 1..4; for @a <-> $e { $e *= 2 }; @a.join(' ').say

[23:51] <p6eval> rakudo 35323: OUTPUT«Cannot assign to readonly variable.␤current instr.: 'die' pc 15387 (src/builtins/control.pir:204)␤»

[23:52] *** dukeleto left
[23:52] <cspencer> shouldn't <-> make the $e variable rw?

[23:58] <cspencer> perl6: my @a = 1..4; for @a <-> $e { $e++ }; @a.join(' ').say

[23:58] <p6eval> rakudo 35323: OUTPUT«2 3 4 5␤»

[23:58] <p6eval> ..elf 24850: OUTPUT«Can't call method "flatten" without a package or object reference at (eval 119) line 4.␤ at ./elf_f line 3861␤»

[23:58] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected ">"␤    at /tmp/ClML5njBYA line 1, column 24␤»

