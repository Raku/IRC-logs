[00:10] *** DemoFreak left
[00:15] *** snarkyboojum left
[00:23] *** kate21de1 left
[00:25] <pmichaud> japhb: it would need to be "use OpenGL:from<parrot>;"    (no space before :from)

[00:25] <pmichaud> still it may not quite work yet.

[00:27] <japhb> pastebin?

[00:27] <japhb> sial.org dead?

[00:27] <japhb> or rather, the pastebot ...

[00:29] <japhb> pmichaud: Can you explain why 'use()' gets called twice here?  http://gist.github.com/128344

[00:33] <pmichaud> probably once at compile time, and then again when Parrot compiles the PIR.

[00:34] *** lichtkind left
[00:34] <pmichaud> We don't have the BEGIN semantics completely worked out yet in the implementation (although I know how to do it -- just haven't had a chance to implement it)

[00:34] <japhb> Ah, OK

[00:34] <pmichaud> Parrot doesn't give me a way to "compile this batch of PIR but don't load or execute it"

[00:35] <japhb> nodnod

[00:37] <DanielC> Speaking of Parrot PIR...

[00:37] <DanielC> pmichaud: Did you see that Q:PIR doesn't like sprintf?

[00:38] <pmichaud> sprintf is fine -- the Q:PIR gets confused by the %

[00:38] <pmichaud> It sees the %0 and tries to do an argument substitution.

[00:39] <DanielC> Ok.

[00:39] <pmichaud> try  "\x2502x  instead

[00:39] <pmichaud> or actually

[00:39] <DanielC> Well, I already solved the particular problem by doing the conversion in Perl 6, but I thought I'd mention the problem.

[00:39] <pmichaud> Q:PIR {{ ...     $S0 = sprintf "\x{25}02x", $P0

[00:40] <pmichaud> yes, it's a known issue.

[00:40] <DanielC> ok

[00:40] <pmichaud> it's not one I'm likely to do much about, since sprintf is a little uncommon and we have a workaround.

[00:40] <DanielC> Not the top priority I'm sure.

[01:12] <Meldrake_> rakudo: say +<1 2 3 4>

[01:12] <p6eval> rakudo 86aeaf: OUTPUT«4␤»

[01:12] <Meldrake_> rakudo: say +<1 2 3 4>.WHAT

[01:12] <p6eval> rakudo 86aeaf: OUTPUT«Use of type object as value␤0␤»

[01:13] <Meldrake_> Is this a bug?

[01:13] *** donaldh left
[01:13] *** donaldh joined
[01:13] <DanielC> It is parsing it as +(<1 2 3 4>.WHAT)

[01:13] <Meldrake_> Oh, ok.

[01:13] <Meldrake_> New here, just trying stuff out.

[01:13] <Meldrake_> Thanks

[01:13] <DanielC> rakudo: say (+<1 2 3 4>).WHAT

[01:14] <p6eval> rakudo 86aeaf: OUTPUT«Num()␤»

[01:14] <DanielC> trying is great

[01:14] <DanielC> I only started playing with Perl 6 just over two weeks ago.

[01:14] <Meldrake_> So how come it's a Num(), not an Int()?

[01:14] <DanielC> dunno

[01:15] <Meldrake_> OK :-)

[01:15] <DanielC> It does seem odd. Obviously the list length will not be an decimal.

[01:15] <Meldrake_> Yeah, that's what I thought

[01:15] <DanielC> rakudo: say <1 2 3>.elems.WHAT

[01:15] <p6eval> rakudo 86aeaf: OUTPUT«Int()␤»

[01:16] <DanielC> The + simply means "numerical context".

[01:16] <DanielC> Whereas .elems is a method, so it gives a more sensible answer.

[01:16] <DanielC> But still... I'd expect an array in list context to be an Int.

[01:17] <DanielC> rakudo: my $a = <1 2 3>; say $a.WHAT

[01:17] <p6eval> rakudo 86aeaf: OUTPUT«Array()␤»

[01:17] <Meldrake_> Me too. I guess I need to learn PIR 

[01:17] <DanielC> rakudo: my $a = +<1 2 3>; say $a.WHAT

[01:17] <p6eval> rakudo 86aeaf: OUTPUT«Num()␤»

[01:17] <DanielC> rakudo: my Int $a = +<1 2 3>; say $a.WHAT

[01:17] <p6eval> rakudo 86aeaf: OUTPUT«Type mismatch in assignment; expected something matching type Int but got something of type Num()␤in Main (/tmp/8cgdQ3938W:2)␤»

[01:17] <DanielC> Interesting.

[01:25] <pmichaud> currently rakudo treats + as always returning Num

[01:26] <DanielC> What does the spec say?

[01:26] *** agentzh left
[01:26] <pmichaud> well, clearly  + $foo numfies

[01:26] <pmichaud> numifies

[01:26] <pmichaud> but it's not always an Int

[01:26] *** agentzh joined
[01:26] <Meldrake_> rakudo: say +<1 2 3>.perl

[01:26] *** wayland76 joined
[01:26] <p6eval> rakudo 86aeaf: OUTPUT«0␤»

[01:26] <pmichaud> in this particular case, the spec isn't explicit.  But it's likely that +<1 2 3 4>  will return an Int -- rakudo just doesn't have that in place yet.

[01:27] <pmichaud> for example...

[01:27] <pmichaud> rakudo:  say +<3.4>;   

[01:27] <p6eval> rakudo 86aeaf: OUTPUT«3.4␤»

[01:27] <pmichaud> Rakudo gets that one right.  :-)

[01:28] <DanielC> <3.4> is not a list of one element?

[01:28] <pmichaud> it is not.

[01:28] <DanielC> k

[01:28] <pmichaud> <3.4>  is the same as ('3.4')  which is the same as '3.4'

[01:31] *** wayland joined
[01:31] *** silug left
[01:31] *** wayland76 left
[01:31] *** wayland is now known as wayland76

[01:32] <wayland76> pmichaud: just asking; has that makefile change happened yet?

[01:34] <Tene> japhb: it's still "use OpenGL:lang<parrot>;" in rakudo ATM.  I haven't fixed it to be spec-compliant yet.

[01:34] *** frobnitz left
[01:34] <pmichaud> wayland76: it's in a branch, I'm still awaiting testers.

[01:34] <pmichaud> We know that it currently fails on win32 but I don't have a system to be able to test/update.

[01:34] <japhb> Tene: I fixed that before dinner, but I've got a few more bugs to clear out this evening before it's all working.

[01:34] <wayland76> pmichaud: ok, thanks :)

[01:37] <Tene> japhb: I'm mostly settled down for now... I'll have a little spare time this evening.

[01:37] <japhb> k

[01:38] <Tene> So, lemme know.  I'm glad to do whatever needs done.

[01:40] <japhb> YEAH!  OpenGL in Perl 6 BAYBEEE!

[01:40] <japhb> OK, now to rip out hacks, and clean up messes ...

[01:41] *** frew|work joined
[01:42] *** clkao left
[01:49] <pmichaud> WTF?!?

[01:49] <pmichaud> sorry, wrong chan.

[01:49] *** wayland76 left
[01:51] *** hcchien joined
[01:53] <sjohnson1> heh

[01:54] *** donaldh left
[01:54] *** donaldh joined
[01:59] <frew|work> pmichaud: hey, I'm getting a (I think) apache error when I try to go to dallas.p6m.org

[02:01] <pmichaud> that's gotta be coming from some other system than mine

[02:01] *** frew|work is now known as frew

[02:02] <frew> if I go to p6m.afoolishmanifesto.com it works

[02:04] *** eternaleye joined
[02:08] <pmichaud> your system may be doing hostname-based virtual hosting

[02:08] <pmichaud> so when it sees a hostname of dallas.p6m.org, it doesn't know where to forward

[02:09] <frew> hmm.  Ok, let me try something

[02:11] <frew> indeed.  If I type in the ip it doesn't work.

[02:16] *** clkao joined
[02:20] *** Whiteknight left
[02:22] *** eternaleye left
[02:23] *** eternaleye joined
[02:24] *** DanielC left
[02:28] *** sjohnson1 is now known as sjohnson

[02:54] *** cookys left
[03:01] *** FurnaceBoy_ joined
[03:05] *** pmichaud left
[03:13] *** FurnaceBoy left
[03:20] *** donaldh left
[03:20] *** donaldh joined
[03:29] *** Meldrake` joined
[03:29] *** Meldrake_ left
[03:30] *** silug joined
[03:34] *** Molaf left
[03:34] *** Molaf joined
[03:38] <dalek> rakudo: a2b8ceb | pmichaud++ | src/parser/actions.pm:

[03:38] <dalek> rakudo: Bare parens should return Nil.  TimToady++

[03:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a2b8ceb4745a24f50bd4f3a79a51506c838135ef

[03:40] *** xinming joined
[03:50] *** Meldrake` left
[03:54] *** meppuru joined
[04:10] *** meppl left
[04:11] *** buubot left
[04:11] *** buubot joined
[04:15] *** meppuru left
[04:20] *** buubot left
[04:20] *** mberends left
[04:20] *** buubot joined
[04:41] *** FurnaceBoy_ left
[05:06] *** synthEEEE joined
[05:14] *** Molinari joined
[05:14] *** Molinari left
[05:22] *** synth left
[05:29] *** Sunbeam is now known as H1N1

[05:29] *** H1N1 is now known as Sunbeam

[05:31] *** Sunbeam is now known as Roxas

[05:38] *** justatheory left
[05:39] *** cognominal left
[05:40] *** sri_kraih joined
[05:46] *** sri_kraih_ joined
[05:49] *** frew left
[05:52] *** ihrd joined
[05:54] *** ihrd left
[06:04] *** sri_kraih left
[06:09] *** cognominal joined
[06:13] *** cognominal left
[06:33] *** finanalyst joined
[06:39] *** kate21de joined
[06:41] *** kate21de left
[07:03] *** DemoFreak joined
[07:13] *** dakkar joined
[07:14] <japhb> Anyone with Rakudo commit rights around?

[07:19] <Tene> I am.

[07:20] *** donaldh left
[07:20] <Tene> japhb: ping

[07:20] <japhb> here

[07:21] *** donaldh joined
[07:21] <japhb> hold on ...

[07:21] <japhb> Tene: can you apply and commit http://gist.github.com/128494 please?

[07:22] <japhb> the old code didn't work at all, but wasn't on a path that got used.

[07:22] <japhb> (yet, that is)

[07:22] <Tene> japhb: why did you change 'load-language' to load_language?

[07:22] *** xinming_ joined
[07:23] <japhb> Tene: because that's the op you taught me to use: http://gist.github.com/124453 (and, since it works, apparently the correct one :-)

[07:24] <japhb> Like I said, the existing code plain didn't work ... it just had never been tested.

[07:24] <Tene> japhb: 'load-language' is defined in src/parrot/misc.pir and just runs the load_language op, but from the 'parrot' HLL, to work around a parrot bug.

[07:25] * japhb shrugs

[07:25] <Tene> I'll make the first change.  That's according to spec, and I just hadn't gotten around to it.

[07:25] <japhb> Well, when my parrot stuff goes in, we'll see if it was needed or not.  It could have been a conflation of bugs, I suppose.

[07:25] <Tene> But using the load_language op has a side-effect of any dynpmcs ending up define din the HLL that it was run from.

[07:26] <Tene> so it needs to be executed from the 'parrot' HLL to work with any language that uses dynpmcs, like tcl

[07:27] <dalek> rakudo: d2b24d8 | tene++ | src/builtins/eval.pir:

[07:27] <dalek> rakudo: Fix the keyword for loading a foreign library (japhb++)

[07:27] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d2b24d8564805c66190f086bb7ea1aa9685ebc85

[07:28] *** masak joined
[07:28] <masak> saluton, actioncamels.

[07:28] <viklund_> o/

[07:28] <japhb> masak: o/

[07:29] <Tene> Hmm... problems...

[07:29] <Tene> hi masak

[07:29] <masak> \o/

[07:29] *** viklund joined
[07:29] <viklund> o/

[07:30] <viklund> masak: as you might have seen, November now accepts utf8 ;)

[07:31] <masak> viklund: I'm looking at it now.

[07:31] <masak> viklund++

[07:31] <japhb> Tene: FYI, I'm in the process of dotting i's and crossing t's for Parrot side of fixes.

[07:31] <masak> viklund: I will look at the commits, and then I will be back for questions. :)

[07:31] <viklund> it was a bit tricky

[07:32] <viklund> without pmichaud_++, may light forever shine on his path, it would have been very hard for me to do

[07:32] <viklund> he has patience

[07:33] <Tene> japhb: I can confirm that rakudo's use ...:from<>; does work.

[07:34] <japhb> Tene: fair enough; I'm willing to believe that I made two changes at a time and thought it was only one while debugging.  :-)

[07:35] <Tene> And with one more update, classes will work too.

[07:37] <viklund> rakudo: say chr(229), chr(9787)

[07:37] <viklund> rakudo: say chr(229)~ chr(9787)

[07:37] <p6eval> rakudo a2b8ce: OUTPUT«å☻␤»

[07:37] <p6eval> rakudo a2b8ce: OUTPUT«\xE5☻␤»

[07:38] <finanalyst> @seen jnthn

[07:38] <lambdabot> jnthn is in #perl6. I don't know when jnthn last spoke.

[07:38] <finanalyst> jnthn: ping

[07:38] <Tene> japhb: http://gist.github.com/128499

[07:39] <viklund> finanalyst: jnthn is on vacation

[07:39] <dalek> rakudo: e61569f | tene++ | src/parser/actions.pm:

[07:39] <dalek> rakudo: Oops... fix the keyword in one more place too.

[07:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e61569fdd4f56640467b2d396df2a4cd81591a5f

[07:39] <finanalyst> viklund: thanx

[07:39] <finanalyst> just read jnthn's blog on .wrap & .unwrap

[07:39] <japhb> Tene: nice!

[07:40] <viklund> yes, that's cool, the first thing I tried was wrapping a multi, it didn't work :(

[07:40] <finanalyst> looked at the spec, which gives .restore not .unwrap for rewinding

[07:40] <masak> buubot: ack unwrap

[07:40] <buubot> Couldn't match input.

[07:40] <masak> buubot: spack unwrap

[07:40] <buubot> Couldn't match input.

[07:41] <finanalyst> buubot: ack restore

[07:41] <buubot> Couldn't match input.

[07:41] *** xinming left
[07:41] *** xinming_ is now known as xinming

[07:42] <finanalyst> .restort S06:2309

[07:42] <finanalyst> s/restort/restore/

[07:44] <finanalyst> would there be a way to .wrap all the subs in the current package? Suppose I want to debug by tracing when subs are called and their signatures?

[07:45] <Tene> iterate over $?PACKAGE

[07:45] <Tene> iirc

[07:45] *** rfordinal joined
[07:47] *** jferrero joined
[07:48] <finanalyst> what about current scope?

[07:50] <masak> rakudo: <a b d d>.grep({$^a ~~ $^b}).perl.say

[07:51] <p6eval> rakudo e61569: OUTPUT«too few arguments passed (1) - 2 params expected␤in method Any::grep (/tmp/y69Yw73kJe:1)␤called from Main (/tmp/y69Yw73kJe:2)␤»

[07:51] <masak> should the above worK?

[07:51] <Tene> Huh.

[07:51] <Tene> ENOCLUE

[07:54] <viklund> masak: if it worked, what would you expect the return to be? <d d>, <d> or <d>?

[07:54] <viklund> I would say <d d>...

[07:54] <masak> aye.

[07:54] <masak> I'd expect it to proceed pairwise, like a for-loop would.

[07:55] <viklund> yup

[07:55] <masak> and return all the matching pairs.

[07:55] <viklund> where pairs in this case aren't :pairs...

[07:57] <masak> not unless you ask for it, no.

[07:57] <masak> the default is still flat lists.

[07:58] <Matt-W> Good morning

[07:59] <masak> good morning, Matt-W.

[08:01] *** barney joined
[08:03] <Matt-W> masak: so what does infix:<

[08:03] <Matt-W> infix:<~~> do

[08:03] <Matt-W> (~ is too close to enter)

[08:03] <masak> Matt-W: um. it smartmatches, I guess...

[08:04] <Matt-W> oh

[08:04] <Matt-W> doh

[08:04] <Matt-W> I know that

[08:05] * Matt-W needs caffeine, clearly

[08:06] <Matt-W> so you're expecting grep with a two-arg block to proceed pairwise? That would be nice.

[08:06] <Matt-W> although personally I don't like these $^ placeholder things

[08:06] <Matt-W> I'm a big convert to pointy blocks

[08:07] <Matt-W> mmm... pointy

[08:07] *** riffraff joined
[08:17] <viklund> mm... pointfree

[08:18] <Matt-W> hah

[08:18] * Matt-W ponders the use of pointfree style in Perl 6

[08:20] <Matt-W> hmm

[08:20] <Matt-W> you can't

[08:20] <Matt-W> well, not with the same elegance as in something like Haskell

[08:20] <Matt-W> since we have to call .assuming to produce curried forms

[08:21] <Tene> You could define a sub trait that would create additional multis for insufficient args that return a curried sub.

[08:21] <Tene> sub foo($a, $b, $c) is pointfree { ... }

[08:22] <Tene> you could also potentially try it with exceptions

[08:22] <Matt-W> mmm

[08:22] <Matt-W> that could be interesting

[08:23] <Matt-W> I think it's a style that's particularly suited to Haskell's syntax

[08:23] <Matt-W> but actually it might be possible to write a useful function composition operator

[08:23] <Matt-W> use introspection to wire up the parameters behind the scenes

[08:35] *** bacek left
[08:38] *** DanielC joined
[08:39] <viklund> o/

[08:39] <DanielC> hi

[08:39] <DanielC> moin

[08:41] <DanielC> @karma

[08:41] <lambdabot> You have a karma of 14

[08:45] <masak> moin, DanielC.

[08:48] <DanielC> moin masak

[08:53] <masak> hm, I need to pull the ethernet cable for a while, because I just restarted my Firefox session, and it crashes if it tries to load all the tabs.

[08:53] *** masak left
[08:53] <Matt-W> lo DanielC

[08:54] <DanielC> o/

[08:54] *** araujo left
[08:56] *** clintongormley joined
[09:03] <japhb> pmichaud_: Would you mind bumping PARROT_REVISION to 39521 ?

[09:03] * japhb really gone now ...

[09:04] *** masak joined
[09:15] <viklund> @seen moritz

[09:15] <lambdabot> I saw moritz leaving #perl6 6m 20d 15h 31m 1s ago, and .

[09:15] <viklund> @seen moritz_

[09:15] <lambdabot> moritz_ is in #perl6. I last heard moritz_ speak 1d 16h 14m 16s ago.

[09:17] <masak> moritz_ was on vacation until a few days ago. maybe he's only partly back still.

[09:17] <viklund> I'm looking at his json thingy

[09:23] <DanielC> masak: How do you tell git to remove a file from the repository? Can you just delete the file?

[09:23] <masak> DanielC: git rm.

[09:24] <DanielC> error: 'checksum.pir' has local modifications

[09:24] <DanielC> :-(   How do I restore checksum.pir so I can delete it?

[09:24] <viklund> git co checksum.pir

[09:25] <DanielC> git: 'co' is not a git-command

[09:25] * DanielC reads git --help

[09:25] <viklund> git checkout checksum.pir

[09:25] <masak> DanielC: take heart! these initial pains will pass, and then git will become your best friend.

[09:25] * viklund has command aliases, need to remember that when helping others

[09:25] <masak> viklund: skurk. giving examples with aliases in them. :)

[09:25] <DanielC> viklund: thanks!

[09:25] * viklund blushes

[09:25] <DanielC> masak: I already have a best friend. His name is Darcs :-)

[09:26] <masak> that's another nice friend, I've come to understand.

[09:26] <DanielC> Darcs and git actually feel very very similar.

[09:27] <DanielC> Branching is easier in Darcs, and merging is more flexible, but they are generally similar.

[09:28] *** synthEEEE left
[09:29] <masak> I need to play around a bit more with Darcs.

[09:30] <DanielC> It has less features, but is much easier to use.

[09:31] <DanielC> That has to do with the fact that the Darcs model is that every copy of the repository is a branch.

[09:31] <masak> phenny: tell pmichaud_ I'm mystified by [perl #66546]. It would be nice if you could take a look at it and determine if it's inherently easy or inherently difficult to fix.

[09:31] <phenny> masak: I'll pass that on when pmichaud_ is around.

[09:31] <DanielC> That makes many things a lot simpler, but it prevents a few obscure features that I couldn't name right now but I know they exist.

[09:32] <masak> DanielC: the git model is not that different. every commit is a potential branch. branches are just names for particular sequences of commits.

[09:32] <DanielC> Git and Darcs do feel generally similar.

[09:33] <DanielC> They even share the "push" and "pull" notation.

[09:34] <DanielC> masak: Could you do a "git pull" on the parrot-module-lib and confirm that t/03-checksum.t is gone and instead we have t/03-module_data.t ?

[09:35] <masak> DanielC: you have both.

[09:35] <DanielC> stupid git

[09:35] <DanielC> I said "git mv". Or at least I thought I did.

[09:36] <masak> seems you didn't. :)

[09:36] <DanielC> ah, no I didn't.

[09:36] <masak> git++ :)

[09:36] <Tene> danielc++

[09:36] *** ssm left
[09:36] <DanielC> I'm used to Darcs, which detects a whole bunch of things for you, so you don't make this sort of mistake.

[09:37] <Tene> in darcs, if you copy a file, it's an error?

[09:37] <DanielC> define copy?

[09:37] <DanielC> cp foo bar

[09:37] <DanielC> ?

[09:38] <DanielC> Darcs looks for changes to every file that it knows about in the repository and asks you which changes you want.

[09:38] <Tene> I understood that you implied that you ran 'git cp' instead of 'git mv'

[09:38] <DanielC> ah, no, I used plain "mv"

[09:38] <DanielC> Darcs would have said "this file is gone, do you want to record that?"

[09:38] <DanielC> and then I say "oops"

[09:38] <Tene> yes, git will do that

[09:39] <DanielC> It didn't for me.

[09:39] <Tene> git add --patch

[09:39] <Tene> you need to ask for it

[09:39] <DanielC> Darcs is more friendly :-)

[09:39] <Tene> if you just say "add this one file, and then make a commit", that's all it does.

[09:39] <DanielC> Darcs shows you the individual changes to the file.

[09:39] <Tene> eh, I'd be quite annoyed by being asked about all of my changes every time I try to commit.

[09:39] <Tene> Yes, that's what add --patch does

[09:39] <DanielC> If you change two lines in a fie, you can tell Darcs to record one but not the other.

[09:39] *** ssm joined
[09:40] <Tene> exactly

[09:40] <DanielC> In Darcs you can specify the individual files, if that's what you want, and the -a ("all") flag says "take all changes".

[09:40] <DanielC> It works really well, trust me.

[09:40] <Tene> that's exactly what 'git add' does. :)

[09:41] <DanielC> No, it doesnt.

[09:41] <Tene> Yes, it does work well.

[09:41] <DanielC> I have used git and darcs, you have only used git.

[09:41] <DanielC> Can you please trust me that I can't explain Darcs in IRC when I'm trying to do work?

[09:41] <masak> hey, calm down! :)

[09:41] <viklund> this parrot has ceased to be...

[09:41] <Tene> 'kay

[09:43] <masak> please defer your 'my SCM is more usable than yours' contests to #git or #darcs, where people are better equipped to argue against you. :P

[09:43] <DanielC> I didn't even say that Darcs is better. I said that it is better at some things.

[09:43] *** Yoi joined
[09:44] <DanielC> It is undoubtedly worse at others. It has fewer features.

[09:44] <DanielC> I got a bit stressed because I was trying to work too.

[09:44] <DanielC> Discussing the merits of SCMs requires more depth than I can afford right now.

[09:45] <DanielC> I got frustrated when someone basically says "I don't know the other scm but my one is just as good".

[09:46] <DanielC> So we had a bad convergence of events, resulting in an unhappy Daniel.

[09:46] <masak> DanielC: I'm sure Darcs is a very good SCM, despite being more minimal than git.

[09:46] <Tene> DanielC: I see what you meant now.

[09:46] <masak> but don't dismiss the way git does thing offhand. I agree with Tene that what git does makes sense too.

[09:47] <masak> s/thing/things/

[09:47] <Tene> "darcs record" without arguments asks you about each change

[09:47] <DanielC> I Git is a fabulous program.

[09:47] <DanielC> I know it can do things git can't do. I can't remember what they are.

[09:48] <DanielC> oops

[09:48] <DanielC> I know it [git] can do things Darcs can't do. I can't remember what they are.

[09:48] <Matt-W> The thing that always confuses me in git is how to take a file that's been changed locally and change it back to the version before those changes

[09:48] <Matt-W> like svn revert

[09:48] <DanielC> darcs unrecord

[09:48] <masak> Matt-W: git checkout.

[09:49] <Matt-W> masak: last time I tried that, it was a no-op

[09:49] <Matt-W> as in, it didn't change the file at all

[09:49] <masak> Matt-W: I know, it confused me in the beginning also.

[09:49] <Tene> DanielC: darcs' patch theory stuff is what you're thinking of.  darcs is rather better at pulling down only some changes from some remote.

[09:49] <masak> Matt-W: it's like, git misbehaves subtly the first half-year you use it. then it suddenly starts to make sense.

[09:49] <DanielC> Tene: I know patch theory :-)

[09:49] *** DemoPhreak joined
[09:50] <Tene> DanielC: oh, nm, i misread.

[09:50] <DanielC> Tene: It is more than just cherrypicking.

[09:50] <Matt-W> masak: but when people say 'git checkout' to do like svn revert, and then it doesn't do anything when you say 'git checkout that-file', what are you supposed to do?

[09:50] <viklund> the json grammar/action pair produces strange results... 

[09:50] <Matt-W> masak: it's tempting to think the person who told you to do it is wrong

[09:50] <Tene> DanielC: i read "Darcs can do things that git can't, but I don't remember what they are."

[09:50] <masak> Matt-W: no, that's the way you do it.

[09:50] <masak> Matt-W: but you have to know what you're doing. :P

[09:50] <Matt-W> masak: well it didn't work

[09:50] <Matt-W> what's to know?

[09:50] <Matt-W> if you say it's 'git checkout that-file'

[09:50] <Matt-W> and it doesn't work

[09:51] <Matt-W> then are you wrong?

[09:51] <Matt-W> or is git broken?

[09:51] <masak> Matt-W: could you nopaste a reproduced case where it doesn't work?

[09:51] <Matt-W> possibly

[09:51] <masak> would be interesting to see.

[09:51] *** explorer__ joined
[09:51] <Matt-W> I ended up giving up and just stashing it

[09:51] <DanielC> Tene: I wrote wrong the first time. I know someone on the Darcs list once gave me an example of something a bit obscure that git could do and was not possible with Darc's simpler model.

[09:51] <Matt-W> although now I'm going to have to figure out how to delete the stash

[09:51] <Matt-W> I'd found websites which said 'git checkout' as well

[09:51] <DanielC> Tene: But it was not something I understood. It was definitely an "advanced" feature.

[09:51] *** agentzh left
[09:51] <Matt-W> but I assumed they'd missed something out when it didn't work

[09:51] *** explorer__ left
[09:51] <Matt-W> because they weren't well-written in the first place

[09:52] <Matt-W> overly brief

[09:52] *** agentzh joined
[09:53] <Tene> Matt-W: http://nopaste.snit.ch/16880

[09:53] <Tene> Matt-W: like that?

[09:53] <viklund> Matt-W: were you trying to git checkout the file you git mv'd?

[09:53] <Matt-W> Tene: that is not what happened

[09:53] <Matt-W> viklund: no

[09:53] <viklund> hmm'

[09:53] * viklund trying to figure out why it didn't work

[09:54] <viklund> did you have anything in the index?

[09:54] <Matt-W> git pull -> make local edits to file -> git pull later on -> wanted to revert edits to file -> git checkout file -> file unchanged

[09:54] <Tene> Matt-W: did you commit the edits?

[09:54] <viklund> aha

[09:54] <masak> Matt-W: maybe you ended up in the no-man's-land between branches.

[09:55] *** tomaw- joined
[09:55] *** Yoi left
[09:57] <Matt-W> Tene: no

[09:57] <Matt-W> Tene: I didn't want them anymore

[10:03] *** DemoFreak left
[10:14] *** lichtkind joined
[10:14] *** lichtkind left
[10:16] *** payload left
[10:52] *** payload joined
[10:55] *** Muixirt joined
[10:55] <Muixirt> hi

[10:58] *** kane_ joined
[11:05] <Roxas> !UP

[11:08] <Roxas> ew amsg sucks in xchat

[11:08] <Roxas> sorry

[11:08] *** hanekomu joined
[11:09] <DanielC> I should convert my PHP code to LOLCODE. That would be fun.

[11:09] <Muixirt> the code snippet while 1 { }; leaks a lot of memory, is that a problem of rakudo too?

[11:10] <DanielC> dunno

[11:10] <DanielC> There are two people who know Rakudo really really well. One of them went on vacation yesterday and the other is in Texas and is not around here yet.

[11:14] *** payload left
[11:17] <masak> Muixirt: fwiw, I'm running Rakudo now, and it does seem to leak memory on that one-liner.

[11:17] <masak> 350Mb and rising...

[11:18] <Muixirt> it was mentioned some days ago

[11:19] <Muixirt> but i'm really puzzled, i even created a blog to write on this ;-)

[11:19] <masak> a whole blog, just for this? :)

[11:19] <masak> what's it called, 'The while 1 { } blog'?

[11:20] *** donaldh left
[11:20] <viklund_> that would be a good blogname actually

[11:20] <viklund_> "while 1 { ... }"

[11:20] <DanielC> @seen mberends

[11:20] <lambdabot> I saw mberends leaving #perl6 7h 24s ago, and .

[11:21] <masak> viklund_: I was thinking the same thing. :)

[11:21] *** donaldh joined
[11:21] <masak> viklund_: or you could name it "Leaking memory in an infinite loop" ;)

[11:23] <viklund_> ehm

[11:23] <viklund_> for @*THOUGHTS { .blog }

[11:23] <masak> :)

[11:23] <Muixirt> masak, done ... http://muixirt.wordpress.com/

[11:23] <masak> Muixirt: :D

[11:24] <masak> Muixirt: extra kudos if you actually fix the problem. :)

[11:25] <masak> Muixirt: (fwiw, I'd go with viklund_++'s suggestion, it's really nice)

[11:26] <masak> maybe even 'for self.thoughts { .blog }'...

[11:28] <Muixirt> you might have a look at http://nopaste.snit.ch/16881 the generated pir output of that not so infinite loop

[11:29] <Muixirt> i wonder why one have to do new $P20, "Int" endlessly

[11:29] <Muixirt> near loop27_test:

[11:29] <masak> one doesn't have to do that, I bet.

[11:30] <masak> it's just that this kind of optimisation hasn't been highly prioritized, between implementing new features and fixing bugs.

[11:30] <masak> patches welcome! :)

[11:36] *** mberends joined
[11:37] <mberends> howdy #perl6

[11:37] <DanielC> o/

[11:37] <masak> greetings, mberends.

[11:38] <mberends> masak: good day! just having a nice break from furniture shifting ;)

[11:38] <mberends> DanielC, your latest refactoring all works here now.

[11:38] <masak> my $nice-break = @furniture.shift;

[11:38] <DanielC> mberends: Great.

[11:40] <DanielC> mberends: Is there a reason why we should do everything in PIR? The YAML part would be much easier in Perl. I wonder if here is a way to mix Perl and PIR to do what we want.

[11:40] <mberends> yesterday's Class 'MD5' not found error was caused by debian having libssl0.9.8 installed but not libssl-dev.

[11:40] <DanielC> ah

[11:41] <DanielC> Ubuntu++

[11:42] <mberends> DanielC, there may some corner cases where is does not apply, but in general we are trying to make something to fit into the chassis of Rakudo. Dependencies on anything Perl might lead to Catch-22, chicken-or-egg, and suchlike. I'd rather not risk it.

[11:42] <masak> DanielC, mberends: if you do a YAML parser/emitter, please (1) make it a separate module, or at least a separate unit of code somehow, so others can re-use it, and (2) consider getting in touch with ingy -- he hangs out on #yaml on irc.perl.org -- because he and I have been discussing writing a YAML parser in p6 before.

[11:43] <masak> oh, ingy 's even here on the channel. :)

[11:43] <DanielC> masak: I was thinking of just writing a parser for a *very* limited subset of YAML. Not something usable in the general case.

[11:44] <masak> DanielC: been there, done that.

[11:44] <DanielC> masak: I wouldn't ind writing something usable in the general case, but then it would have to be written in Perl.

[11:44] <masak> it works, but it feels risky.

[11:44] <DanielC> s/ind/mind/

[11:44] *** finanalyst left
[11:44] <masak> DanielC: proto does quite a lot of limited YAML parsing.

[11:44] <mberends> masak, as discussed at the Mausoleum, a full blown YAML toolset is often overkill, and a quick and dirty little bastard yaml parser will often suffice. DanielC: +1

[11:45] <DanielC> masak: Yeah. But can you imagine trying to write a general parser for anything interesting in an assembly language.

[11:45] <masak> DanielC: PIR is actually not so bad. ask pmichaud_ :)

[11:45] <masak> DanielC: (he wrote PGE in PIR)

[11:46] <masak> mberends: I don't disagree. I'm just pointing you to the knowledgeable people, should you decide to go general.

[11:46] <DanielC> masak: PGE is a perl-like grammar, like? Or is it the full Perl 6 grammar?

[11:46] <mberends> masak, I'm rather enjoying PIR programming :) re: yaml, indeed yes

[11:46] <masak> no-one would be happier than I if we could standardize on a quick and dirty little bastard YAML parser.

[11:47] <masak> DanielC: it's a full P5/P6 regex/grammar engine. the Perl 6 grammar is meant to run on top of it.

[11:48] <DanielC> masak: I wonder if PGE can (in principle) be used to make a YAML parser usable from PIR.

[11:48] <masak> DanielC: sure.

[11:49] <DanielC> It may be an interesting project.

[11:49] <DanielC> On the other hand, a YAML parser that only uses Perl 6 would be usable to other implementations.

[11:49] <masak> DanielC: I'm browsing around in months-old code from when I last attempted this. found this comment: # <rjbs> the best advice to someone about to write a yaml parser is "don't"

[11:49] <DanielC> If I wanted to write a general YAML parser, I think I' pick Perl 6.

[11:50] <DanielC> masak: What does that advice mean?

[11:50] <masak> DanielC: that writing a YAML parser is harder than it first appears.

[11:50] <DanielC> ok

[11:50] <DanielC> It looks hard enough as it is.

[11:50] <masak> that's why I advise you to befriend the #yaml people.

[11:51] <DanielC> Not many people there.

[11:51] <DanielC> ingy is there.

[11:51] <mberends> for parrot-module-lib a subset of yaml is desirable but not even required. "What's the simplest thing that could possibly work?" Some domain specific data structure. The yaml is for hacking FTW.

[11:51] <masak> mberends: ack.

[11:52] <DanielC> A restricted YAML is pretty close to what I would pick for a domain-specific markup language.

[11:53] <masak> DanielC: .perl and eval(slurp $file) goes a long way, though.

[11:53] <DanielC> I would make a few non-YAML alterations, but that's all.

[11:53] <masak> DanielC: it works out of the box.

[11:53] *** szabgab left
[11:53] <DanielC> masak: Yes, but only if you are using Perl :-(   (remember.. PIR)

[11:54] <masak> oh. right.

[11:54] <DanielC> But PIR has arrays and hashes.

[11:54] <DanielC> Maybe we can use that.

[11:54] <masak> DanielC: you could copy the Array.perl and Hash.perl source code from Rakudo. :)

[11:54] <masak> it's open source.

[11:55] <DanielC> :-)

[11:55] <DanielC> Hey, Ingy is one of the YAML designers.

[11:55] <masak> yes.

[11:56] <DanielC> cool

[11:56] * mberends hears the "back to work" signal

[11:56] <masak> I almost, but not quite, sat down with him after NPW and ported YAML to Perl 6.

[11:57] <DanielC> JSON is easier to parse than YAML. Maybe we should use that.

[11:58] *** Molaf left
[11:58] <DanielC> Then again, even a JSON parser would be hard in PIR, so I would just end up restricting it anyways.

[11:58] <masak> DanielC: using PGE grammars and actions for this kind of parsing would help a lot, I think.

[11:59] <DanielC> y

[11:59] *** mberends left
[11:59] <DanielC> I don't suppose there is a tutorial for PGE anywhere.

[12:02] <masak> DanielC: http://www.pmichaud.com/2006/pres/yapc-parsers/start.html

[12:02] <masak> might be a bit outdated, but should get you started.

[12:02] <DanielC> *click*

[12:05] <masak> the Wikipedia article was quite nice, too.

[12:05] <DanielC> Wikipedia article on PGE?

[12:05] <masak> it's probably a bit dated as well, because it makes it sound as if Pugs is still in active development...

[12:05] <masak> http://en.wikipedia.org/wiki/Parser_Grammar_Engine

[12:05] <DanielC> *click*

[12:06] <DanielC> Maybe we can make a parser and use JSON.

[12:06] <DanielC> JSON is much simpler than YAML.

[12:06] <Matt-W> a lot of the wikipedia stuff on Perl 6-related tech is outdated

[12:06] * DanielC hacks together a sample file in JSON

[12:06] <Matt-W> we should make an effort to update it

[12:06] <masak> yes, we should.

[12:10] *** elmex joined
[12:16] <DanielC> masak: What is "proto" in the context of PGE?

[12:16] <DanielC> proto infix:+ is looser('term:') {...}

[12:16] <masak> DanielC: S05:1048.

[12:16] <DanielC> k

[12:17] <masak> 'if you predeclare a proto regex, you can write multiple regexes for the same category, differentiated only by the symbol they match.  The symbol is specified as part of the "long name".'

[12:18] <DanielC> I have read that paragraph a few ties, an seen the example, and I'm still confused.

[12:18] <DanielC> For starters, what is a category?

[12:19] <masak> DanielC: in the context of the example, the token 'sigil'.

[12:19] <DanielC> k...

[12:19] <masak> DanielC: heard of multisubs?

[12:19] <DanielC> yeah, I'm going to post a blog about mulltisubs today :-)

[12:19] <DanielC> coincidentally...

[12:19] <masak> DanielC: this seems to be the corresponding thing for regexes/tokens/rules.

[12:20] <DanielC> token sigil:sym<$>  { <sym> }

[12:20] <DanielC> The first problem I have with that is that it looks recursive.

[12:20] <masak> yeah.

[12:20] <masak> no.

[12:20] <DanielC> Second, the :sym<$> throws me off.

[12:21] *** kane_ left
[12:21] *** bejuryu joined
[12:21] <masak> I'll let the people who have more of a clue explain the details. fwiw, I read that as 'token sigil, where <sym> is "$"'

[12:22] <DanielC> based on longest-token matching  <---

[12:22] <DanielC> Ok, that explains the multi part better.

[12:23] <DanielC> "The advantage of writing it this way is that it's easy to add additional rules to the same category in a derived grammar"  <-- ok

[12:25] <masak> I wish more of STD.pm worked like that.

[12:25] <masak> I looked into adding a new statement postfix keyword the other week, and it doesn't look very easy at present.

[12:25] <masak> people will want to do such things.

[12:29] <DanielC> masak: Could you help me with something? http://pastebin.com/m51c438d  <-- What's wrong on line 25?

[12:30] <DanielC> "Statement not terminated properly at line 25,"

[12:30] <masak> DanielC: try adding a semicolon on the line above.

[12:30] <DanielC> I did, no change.

[12:30] <masak> DanielC: oh! infix:over should be infix:<over>.

[12:30] <masak> those <> are not optional.

[12:30] <DanielC> ah!

[12:31] <DanielC> oops

[12:31] <DanielC> thanks

[12:31] <masak> np.

[12:31] <masak> oh, and cool! Rats.

[12:31] <DanielC> I assumed it was just if you wanted "funny" characters like + or !

[12:31] <masak> DanielC: no, they're part of the sub name.

[12:32] <masak> I'm a bit surprised infix:over parses, actually.

[12:32] <masak> rakudo: sub infix:over() { say "OH HAI" }

[12:32] <p6eval> rakudo e61569:  ( no output )

[12:32] <masak> rakudo: sub infix:over() { say "OH HAI" }; infix:over();

[12:32] <p6eval> rakudo e61569: OUTPUT«Statement not terminated properly at line 2, near ":over();"␤in Main (src/gen_setting.pm:0)␤»

[12:33] <DanielC> Now it complains about the gcd function:  Null PMC access in find_method() in in sub gcd called from sub infix:over.

[12:33] <DanielC> But I tested gcd individually and it worked.

[12:34] <masak> DanielC: try and reduce it to a minimal test case.

[12:34] <masak> might be a bug.

[12:34] * DanielC starts reducing

[12:34] <Matt-W> go on! make masak happy!

[12:34] <masak> :)

[12:36] <DanielC> WTF?  The problem goes away when I remove the == functions.

[12:37] <DanielC> It is definitely the == functions. If I comment them out, the program stops complaining.

[12:38] <DanielC> Is == a multi-function?

[12:39] <DanielC> Any one of the infix:<==> functions is enough to make the program barf.

[12:39] <Matt-W> can you get it down to barfing on having just an infix:<==>?

[12:39] * DanielC reduces more

[12:40] <DanielC> Hmm... I *have* to call the "over" function to reproduce the error.

[12:41] * DanielC keeps reducing

[12:41] <masak> rakudo: sub gcd() {}; sub infix:<over>($a, $b) { gcd }; 4 over 5

[12:41] <p6eval> rakudo e61569:  ( no output )

[12:42] <masak> rakudo: sub gcd() {}; sub infix:<over>($a, $b) { gcd }; 4 over 5; multi sub infix:<==> (Int $a, Int $b) {}

[12:42] <p6eval> rakudo e61569:  ( no output )

[12:42] <masak> hm, not as simple as that, it seems...

[12:42] <DanielC> Indeed, it isn't.

[12:42] <masak> keep reducing; I've gotta go soon.

[12:42] <masak> I hereby bequeath to you the holy power of rakudobug reporting.

[12:43] <Infinoid> Don't spend it all in one place.

[12:43] <DanielC> This is bewildering. If I remove the gcd line it stops complaining.

[12:44] <masak> not so surprising, given that that line caused the error.

[12:44] <DanielC> gcd uses ==

[12:44] <DanielC> Maybe that's where the problem is.

[12:44] <DanielC> yeah

[12:45] <DanielC> now I can reduce a lot more.

[12:45] <masak> rakudo: role A {}; multi sub infix:<==>(A $a, A $b) {}; 42 == 42

[12:45] <p6eval> rakudo e61569: OUTPUT«Null PMC access in find_method()␤in Main (/tmp/5dgviLoPNU:2)␤»

[12:45] <masak> there you go. :)

[12:45] * masak submits rakudobug

[12:46] <DanielC> ?

[12:46] <DanielC> ah

[12:47] <DanielC> rakudo: role A {}; multi sub infix:<==>(A $a, A $b) {}; "42" eq "42"

[12:47] <p6eval> rakudo e61569:  ( no output )

[12:47] <DanielC> This is annoying though. How am I going to make my blog post now without an == operator?

[12:48] <masak> :)

[12:48] <masak> you'll find a way.

[12:48] <DanielC> :-P

[12:48] <masak> gotta go. see y'all.

[12:48] *** masak left
[12:48] <DanielC> bye

[12:50] *** jonathanturner left
[12:51] *** Whiteknight joined
[12:51] <Matt-W> you'll have to wait until the bug is fixed I suppose

[12:51] <Matt-W> time to start nagging people

[12:54] *** szabgab joined
[13:07] *** kane___ joined
[13:13] *** kane___ left
[13:14] *** jferrero left
[13:14] *** FurnaceBoy joined
[13:17] *** alanhaggai joined
[13:19] *** mizioumt joined
[13:20] *** skids_ joined
[13:21] *** frew joined
[13:21] *** beggars joined
[13:23] *** frew_ left
[13:24] *** alanhaggai_ joined
[13:26] *** alanhaggai left
[13:26] *** alanhaggai_ is now known as alanhaggai

[13:29] *** lichtkind joined
[13:35] *** Muixirt left
[13:35] *** jantore left
[13:35] *** felipe left
[13:35] *** dmpk2k left
[13:35] *** DQuest left
[13:35] *** Gothmog_ left
[13:37] *** kane___ joined
[13:37] *** dmpk2k joined
[13:38] *** DQuest joined
[13:38] *** mattp joined
[13:38] *** ruoso joined
[13:43] *** jantore joined
[13:45] *** decasm joined
[13:45] <ruoso> Hello!

[13:48] *** [particle] left
[13:48] *** [particle] joined
[13:48] *** Muixirt joined
[13:51] *** ihrd joined
[13:51] *** ihrd left
[13:54] *** kane__ left
[14:01] *** araujo joined
[14:12] <Matt-W> $self->{'stats'} = @_;

[14:12] <Matt-W> ^ too much Perl 6!

[14:12] <Matt-W> (I'm sure you all spot the bug)

[14:12] <DanielC> actually...

[14:13] <DanielC> ?

[14:13] <viklund> scalar context for @_ => returns length

[14:13] <Matt-W> yes

[14:13] <DanielC> ugh!

[14:13] <Matt-W> this was not the intent

[14:13] <Matt-W> later on I had a rather surprising message noting that I can't use '2' as an array reference

[14:13] <DanielC> $self->{'stats'} = \@_;  <--- is this what you wanted?

[14:13] <Matt-W> yes indeed

[14:14] <DanielC> Perl 5 is painful compared to Perl 6.

[14:14] <Matt-W> It's amazing how quickly it gets into your head

[14:14] <Matt-W> oh nice

[14:14] <Matt-W> now I have

[14:15] <Matt-W> Can't locate object method "year" via package "Fri Jun 12 15:12:57 2009"

[14:15] * Matt-W sighs and goes to fix that too

[14:17] *** beggars left
[14:18] <viklund> there's an error somewhere in moritz_ json perl6 thingy, it's hard to pindown...

[14:18] *** pmurias joined
[14:18] <pmurias> ruoso: hi

[14:19] <Matt-W> viklund: it's good for your brain :)

[14:19] <viklund> yes, well, but it's strange

[14:20] <viklund> '\n\t' becomes '\\\\\"'

[14:21] <Matt-W> umm

[14:21] <Matt-W> that is

[14:21] <Matt-W> err

[14:21] * Matt-W scratches his head

[14:21] <pmurias> ruoso: is the list of roles in ^!does flattened?

[14:23] <viklund> indeed

[14:27] <clintongormley> how complete is the regex engine?

[14:27] <clintongormley> is it supposed to work as spec'ed?

[14:27] <ruoso> pmurias, they are just the direct applied roles

[14:28] <ruoso> pmurias, they don't include parent's compositions

[14:31] * viklund scratches his beard

[14:32] <Matt-W> clintongormley: no, it doesn't quite work as specced. Some things are missing, and the most noteable omission is that it doesn't do longest-token matching yet

[14:32] <clintongormley> ahh still not?

[14:32] <pmurias> ruoso: should every punned class instance have an ACCEPTS method?

[14:32] <pmurias> or only the one instance which is directly punned?

[14:33] <clintongormley> i remember reading about TimToady's frustrations at getting that working, but i thought he'd conquered it

[14:36] <ruoso> pmurias, hmmm.. good question... I guess the punned class... 

[14:38] *** rfordinal left
[14:38] <pmichaud_> good morning, #perl6

[14:38] <phenny> pmichaud_: 09:31Z <masak> tell pmichaud_ I'm mystified by [perl #66546]. It would be nice if you could take a look at it and determine if it's inherently easy or inherently difficult to fix.

[14:38] <pmurias> ACCEPTS method is ovewritten by a lot of things, that would mean we would need something different from Signature.ACCEPTS to check if something is a signature

[14:39] <ruoso> pmurias, I guess it could simply delegate it to the meta 

[14:41] *** payload joined
[14:42] <ruoso> pmurias, I guess ACCEPTS is a multi method

[14:42] <viklund> good morning pmichaud

[14:43] <ruoso> rakudo: my $a = :($a, $b); say $a ~~ Signature

[14:43] <p6eval> rakudo e61569: OUTPUT«too few arguments passed (0) - 2 params expected␤in Main (/tmp/SfvHXBxtNs:0)␤»

[14:43] <viklund> thanks for the help yesterday with that utf8 <-> latin1 thing

[14:43] <ruoso> hah!

[14:44] <pmurias> ruoso: ?

[14:44] <pmichaud_> viklund: you're welcome.  We troubleshooted that bug a bit more in Parrot and found a few more issues to deal with.  :-|

[14:44] <ruoso> rakudo didn't solve that question as well

[14:44] <pmichaud_> rakudo:  say Signature;

[14:44] <p6eval> rakudo e61569: OUTPUT«Signature()␤»

[14:44] <viklund> yes, I followed that with interest...

[14:45] <ruoso> that's actually a good question...

[14:45] <pmichaud_> rakudo:  sub foo() { };   say &foo.signature ~~ Signature;

[14:45] <p6eval> rakudo e61569: OUTPUT«1␤»

[14:45] <ruoso> I can't really think of anything smart to solve it

[14:45] <ruoso> rakudo: sub foo($,$,$) { };  say &foo.signature ~~ Signature

[14:45] <p6eval> rakudo e61569: OUTPUT«1␤»

[14:45] *** moritz_ sets mode: +o pmichaud_

[14:45] <viklund> anyway, we have utf8 working in November now...

[14:46] <pmurias> ruoso: do we want to assume type checking and smart matching is the same thing?

[14:46] <pmurias> if so an ACCEPT method on an undefined Signature could only check if the argument does the Signature role

[14:46] <pmurias> * ACCEPTS

[14:46] <ruoso> that's kinda of an general assumption in Perl 6

[14:46] <ruoso> I mean...

[14:48] <ruoso> rakudo: my $a = :($a, $b, $c); say $a.defined

[14:48] *** justatheory joined
[14:48] <p6eval> rakudo e61569: OUTPUT«too few arguments passed (0) - 3 params expected␤in Main (/tmp/PMfD6mf7T5:0)␤»

[14:48] <pmichaud_> I don't think rakudo handles the :(...) syntax yet.

[14:48] <ruoso> ah...

[14:48] <ruoso> that explains it

[14:49] <pmichaud_> rakudo:  sub foo($a, $b, $c) { };  say &foo.signature.defined;

[14:49] <p6eval> rakudo e61569: OUTPUT«1␤»

[14:49] <ruoso> rakudo: sub foo($a, $b, $c) {}; say &foo.signature ~~ (1,2,3)

[14:49] <p6eval> rakudo e61569: OUTPUT«0␤»

[14:49] <ruoso> ok... I guess it should have been a 1 there

[14:50] <pmichaud_> actually it would need to go the other way

[14:50] *** hexmode joined
[14:50] <pmichaud_> (1,2,3) ~~ &foo.signature

[14:50] <pmichaud_> but Rakudo doesn't really do captures yet

[14:50] <ruoso> oh righht...

[14:51] <ruoso> but it is supposed to be done with ACCEPTS, rigth?

[14:51] <pmichaud_> it still thinks that (1,2,3) is a List (and doesn't grok the new relationship between List and capture)

[14:51] <pmichaud_> I'm not sure if rakudo is using ACCEPTS for signature binding yet

[14:52] <pmichaud_> I'm sure it _can_

[14:52] <ruoso> not binding, but checking

[14:53] <pmichaud_> oops, you're correct --  &foo.signature ~~ (1,2,3) also works   (I needed to look a little farther down the smart match table)

[14:53] <clintongormley> damn, the JS on the synopses makes the pages all but unusable, at least in firefox

[14:53] <ruoso> binding is SMOP goes with .BIND

[14:53] <pmichaud_> clintongormley: try svn.pugscode.org/pugs/docs/Perl6/Spec  (no js)

[14:53] <clintongormley> ta

[14:54] <Matt-W> I've never had any trouble with them on firefo

[14:54] <clintongormley> pmichaud_: Muuuuch better

[14:55] <clintongormley> Matt-W: my firefox hangs for 30 seconds at a time

[14:55] <Matt-W> hmm

[14:55] <Matt-W> not seen that

[14:55] <Matt-W> how odd

[14:55] <viklund> noscript ftw

[14:55] *** exodist joined
[14:56] <clintongormley> are heredocs not implemented yet?

[14:57] <moritz_> not in rakudo

[14:57] <pmurias> ruoso: there is a Any       Type      type membership         $_.does(X)

[14:57] <moritz_> STD.pm parses them

[14:57] <clintongormley> ta

[14:57] <clintongormley> moritz_: welcome back! long time

[14:57] <pmurias> ruoso: row in the smartmatch table

[14:58] <ruoso> pmurias, but it seems that isn't syntatical

[14:58] <pmurias> how is the Type role defined

[14:58] <pmurias> ?

[14:59] <pmurias> moritz_: i disabled the evalbot runtime limits for mildew

[14:59] <ruoso> pmurias, it isn't

[14:59] <pmichaud_> rakudo:  say 'a'..'z'

[14:59] <p6eval> rakudo e61569: OUTPUT«abcdefghijklmnopqrstuvwxyz␤»

[14:59] <ruoso> for now, it's just "undefined values"

[14:59] <moritz_> pmurias: please don't disable them entirely, in case it loops. Rather bump them up for mildew

[15:00] <ruoso> pmichaud_, one thing i just realized... can that be locale-specific?

[15:00] <pmichaud_> ruoso: I don't think so... I think it's defined in terms of the unicode codepoints

[15:00] <pmurias> locale specific? argh! :)

[15:01] <viklund> Huzzah!

[15:02] <ruoso> rakudo: say '𐌰'..'𐍊'

[15:02] <p6eval> rakudo e61569:  ( no output )

[15:02] <pmichaud_> at the moment rakudo only does the uppercase, lowercase, and ascii digit ranges

[15:02] <pmichaud_> (it can be extended to do more, but we just did those to start with)

[15:02] <pmurias> moritz_: i'm not sure which limits get violated

[15:03] <viklund> moritz_: I'm working with you json parser

[15:03] *** riffraff left
[15:03] <viklund> I've managed to get it to pass one more test ;)

[15:04] <ruoso> rakudo: say 'α'..'ω'

[15:04] <p6eval> rakudo e61569:  ( no output )

[15:06] <moritz_> pmurias: just do somthing that violates a limit, and I'll tell you which one

[15:06] <moritz_> viklund: cool. Want a commit bit?

[15:06] <viklund> moritz_: sure ;)

[15:06] <viklund> but I think it needs more structure tests

[15:07] <moritz_> sure, I was just getting started with them

[15:11] <moritz_> viklund: done

[15:11] *** mizioumt1 joined
[15:11] <viklund> moritz_: thx

[15:12] <moritz_> viklund: please test it, I never did that before ;-)

[15:13] <pmurias> moritz_: anything violates the limit

[15:13] <ruoso> moritz_, the problem is that mildew runs after running STD

[15:13] <viklund> I was thinking of actually trying it for real ;)

[15:14] <moritz_> ruoso: ... and?

[15:14] <ruoso> pmurias, one thing that would ease things in mildew would be to build the mold in perl directly and simply run it, instead of generating the m0ld to then generate the C, than compile it than run

[15:15] <ruoso> moritz_, it runs gcc from inside that same process

[15:15] <ruoso> after using all the memory STD uses

[15:15] <ruoso> and without releasing it

[15:15] <moritz_> ruoso: I still don't see the problem in figuring out a sensible resource limit for mildew, and setting it

[15:15] <ruoso> ah... sure...

[15:15] <moritz_> but not having any resource limit is just suicide.

[15:15] <ruoso> I was just explaining why it's so high

[15:16] <moritz_> ok

[15:16] * ruoso lunch &

[15:16] *** exodist left
[15:20] *** donaldh left
[15:20] *** donaldh joined
[15:24] *** mizioumt left
[15:24] <viklund> ohh, speedup after compile 36s -> 32s...

[15:29] <clintongormley> i realise this is a bad regex, but in perl5 it succeeds, in perl6 it just hangs:

[15:29] <clintongormley> say '  ' ~~ /\s*+/

[15:30] <moritz_> in perl 5 it's optimized out

[15:30] <clintongormley> ah ok

[15:31] *** masak joined
[15:31] <pmichaud_> rakudo/pge doesn't know how to handle quantified zero-length patterns

[15:32] *** nihiliad joined
[15:32] <pmichaud_> it tends to get stuck in infinite loops

[15:33] <clintongormley> it was actually a typo, and i couldn't figure out why rakudo was hanging on a simple white space match :)

[15:33] <masak> pmichaud_: thank you for your answer to #66546. getting a data structure representing a Perl 6 AST has become something of a holy grail for me. now it again seems like I'll need to reconsider my strategy.

[15:34] <masak> a shellout call to STD.pm and then parsing the YAML might be the more long-term solution anyway.

[15:37] <DanielC> Since I can't post my blog about Rational numbers yet, today I'm making a different post:  http://daniel.carrera.bz/2009/06/perl-6-and-the-josephus-problem/

[15:37] <DanielC> It's also nice, but not "cool" like the Rational numbers one.

[15:39] <masak> DanielC: why can't you post your piece about Rational numbers?

[15:39] <DanielC> masak: Because == won't work.

[15:39] <masak> DanielC: did you try a workaround?

[15:39] <DanielC> == is one of the parts that makes the post interesting.

[15:40] <DanielC> masak: I could... but the workaround would not look as interesting. It would look like a workaround.

[15:40] <DanielC> So it wouldn't be a great advertisement for Rakudo.

[15:40] <masak> DanielC: for example, try defining infix:<==> for two Ints, even though in real Perl 6, that wouldn't be needed.

[15:40] <masak> it could work, and it would only be one extra line.

[15:40] <pmichaud_> masak: you can always get Rakudo's AST format

[15:40] * masak perks up

[15:40] <masak> pmichaud_: how?

[15:41] <DanielC> masak: I could try that.

[15:41] <pmichaud_> rakudo:  say Perl6::Compiler.compile('say <hello>', :target('past')).perl;

[15:41] <p6eval> rakudo e61569: OUTPUT«Method 'perl' not found for invocant of class 'PAST;Block'␤»

[15:41] <pmichaud_> rakudo:  say Perl6::Compiler.compile('say <hello>', :target('past')).WHAT;

[15:41] <p6eval> rakudo e61569: OUTPUT«PAST::Block()␤»

[15:41] <masak> DanielC: over the last year, I've repeatedly lost and re-gained that enterprising spirit that makes me go after workarounds. I much prefer when I have it; it makes for more interesting solutions. :)

[15:42] *** scrottie joined
[15:42] <DanielC> masak: But the blog about the Josephus is not bad. It shows that Perl 6 now has really nice OOP syntax. It slightly beats both Python and Ruby.

[15:42] <pmichaud_> we could see about adding a .perl to PAST nodes

[15:42] <masak> DanielC: sorry -- when you say 'blog' you mean, like, a blog post. right?

[15:42] <DanielC> yeah, sorry

[15:42] <DanielC> post

[15:42] <masak> just checking.

[15:43] <masak> DanielC: 'beats'? in length, you mean?

[15:43] <DanielC> yeah

[15:43] <DanielC> both by line count and character count.

[15:43] <DanielC> I was surprised that Perl 6 was shorter than Python, but it is.

[15:44] <TimToady> seems like there would be a much shorter FP solution...

[15:44] <masak> it actually took me a while to get used to some aspects of Perl 6 OO.

[15:44] <masak> some parts of the journey hurt.

[15:44] <masak> but now I really like it.

[15:44] <DanielC> And I made every effort to implement the code the same way in all languages so no one can say that I was biased.

[15:45] <pmichaud_> I think that actually shows a bit of a bias in a different direction

[15:45] <DanielC> I made no real effort to make Perl 6 compact. It came out compact and easy to read all on its own.

[15:45] <pmichaud_> or, at least, it *can*

[15:45] <pmichaud_> (not sure it does in this case)

[15:45] <pmichaud_> the blog post is really cool, btw

[15:45] <masak> it is. DanielC++

[15:45] <DanielC> pmichaud_: Well, I can't avoid being biased (Perl rulez!). All I can do is try to control it.

[15:45] <DanielC> thanks :-)

[15:46] <masak> DanielC: typo in a comment in all the code snippets: s/Kill ever/Kill every/

[15:47] <DanielC> thanks

[15:47] *** hanekomu left
[15:47] * DanielC goes fix it

[15:47] <pmichaud_> I mean, how does one write the equivalent of    my @a = @b >>*<< @c >>+<< @d;      in Perl 5?   ;-)

[15:48] <DanielC> masak: fixed, thanks

[15:48] <TimToady> in fact, there's probably a one line solution using [^$n] ... {}

[15:48] <masak> pmichaud_: what's the precedence of that one? same as with * and +?

[15:48] <pmichaud_> masak: yes, I believe so.

[15:48] <pmichaud_> the hypers maintain their precedence

[15:48] <masak> ah, makes sense.

[15:49] <TimToady> yes, hypes are transparent, while X force list infix

[15:49] <TimToady> *forces

[15:49] <masak> [] makes infix into prefix, but still doesn't change precedence?

[15:49] <pmichaud_> makes it a listop

[15:49] <DanielC> rakudo: my @a=<1 1>; my @b = @a; my @c =<4 4>; (@a >>*<< @b >>+<< @c).perl.say

[15:49] *** pmichaud_ is now known as pmichaud

[15:49] <p6eval> rakudo e61569: OUTPUT«[5, 5]␤»

[15:49] <masak> oh, right. listop.

[15:50] <DanielC> rakudo: my @a=<2 2>; my @b = @a; my @c =<4 4>; (@a >>*<< @b >>+<< @c).perl.say

[15:50] <p6eval> rakudo e61569: OUTPUT«[8, 8]␤»

[15:50] <DanielC> Well, it behaves rationally.

[15:54] *** alanhaggai left
[15:56] <masak> going on a long cross-country bus trip tonight. expect to get some Perl 6 hacking done on the way.

[15:56] <barney> Shouldn't line 1932 of action.pm simply say;        $past<itype> := 'Perl6Scalar';    instead of $past<itype> := container_itype('Perl6Scalar');

[15:56] <barney> 'Perl6Scalar' is no Sigil

[15:56] *** szabgab left
[15:56] <pmichaud> looking

[15:57] *** meppl joined
[15:57] *** Gothmog_ joined
[15:57] <pmichaud> I'm guessing it should actually use the sigil

[15:57] <masak> pmichaud: I'm not sure I understood what you meant by "you can always get Rakudo's AST format" -- it sounds intriguing, though.

[15:57] <pmichaud> masak: Rakudo compiles first to PAST (its AST format) before going on to anything else

[15:57] <pmichaud> from the command line we do this via  --target=past

[15:58] <masak> ooh.

[15:58] <masak> yes, I'll try that.

[15:58] *** mkfort_ joined
[15:58] <masak> thanks.

[15:58] <pmichaud> but it can be done from code by calling the compiler directly, and passing   :target('past')

[15:58] <masak> even better.

[15:59] <pmichaud> unfortunately the PAST nodes don't know how to .perl themselves, but we could come up with something there

[15:59] <masak> yes, this looks like what I want, and not --target=parse.

[16:00] <masak> pmichaud: I'll make a try at making PAST nodes .perl themselves.

[16:00] *** payload left
[16:00] <pmichaud> ultimately they're just Captures (like Match objects

[16:00] <pmichaud> but they can/do have cycles in them

[16:01] * pmichaud decides to bring back '_dumper' for now.

[16:01] *** synth joined
[16:01] <TimToady> sub josephus ($n) { [^$n] ... { .push(.shift); .push(.shift); return .[0] if @$_ == 1; .shift; $_ } }

[16:01] <TimToady> or some such

[16:02] *** dakkar left
[16:04] <TimToady> well, using ... is probably overkill, since it's just looping over the same array

[16:04] *** mkfort left
[16:05] <masak> that infix:<...> operator is scary.

[16:06] <masak> anyway, going home to make food.

[16:06] <masak> have a good weekend, everyone!

[16:06] *** masak left
[16:06] <pmichaud> japhb: I can't bump PARROT_REVISION to 39521 yet -- something in Parrot at that revision is causing t/spec/integration/99problems-11-to-20.t to fail in the spectests.

[16:06] <barney> Is there a way to follow the references in the dumped PAST?    e.g.       [0] => \past

[16:07] <pmichaud> barney: the \past occurs whenever it refers to a node that was already displayed

[16:07] <pmichaud> it's something about the dumper code that is causing it to not display the full reference properly.

[16:07] <pmichaud> (I've not quite figured out what)

[16:07] <pmichaud> probably need to look at dumper.pbc and/or the 'dump' method

[16:09] <TimToady> rakudo: my @p = ^10; say gather while @p { take splice(@p, 2 % @p, 1) }

[16:09] <p6eval> rakudo e61569: OUTPUT«Could not find non-existent sub splice␤»

[16:09] <TimToady> aww

[16:09] <pmichaud> @p.splice 

[16:09] <lambdabot> Unknown command, try @list

[16:10] <pmichaud> rakudo:  my @p = ^10; say gather while @p { take @p.splice(2 % @p, 1) }

[16:10] <p6eval> rakudo e61569: OUTPUT«No applicable candidates found to dispatch to for 'splice'␤in Main (/tmp/Fr7ClbT5Kr:2)␤»

[16:10] <pmichaud> o_O

[16:10] <pmichaud> rakudo:  my @p = ^10; say @p.splice(2 % @p, 1);

[16:10] <p6eval> rakudo e61569: OUTPUT«No applicable candidates found to dispatch to for 'splice'␤in Main (/tmp/wC2lIwPTR1:2)␤»

[16:10] <pmichaud> rakudo:  my @p = ^10; say @p.splice(2 % +@p, 1);

[16:10] <p6eval> rakudo e61569: OUTPUT«No applicable candidates found to dispatch to for 'splice'␤in Main (/tmp/YnBL8QJRZO:2)␤»

[16:11] <pmichaud> bah.

[16:11] <pmichaud> rakudo:  my @p = ^10; say @p.splice(2, 1);

[16:11] <p6eval> rakudo e61569: OUTPUT«2␤»

[16:11] <pmichaud> rakudo:  my @p = ^10; say 2 % @p;

[16:11] <p6eval> rakudo e61569: OUTPUT«2␤»

[16:11] <TimToady> rakudo: my @p = ^10; say gather while @p { take @p.splice(int(2 % @p), 1) }

[16:11] <p6eval> rakudo e61569: OUTPUT«2345678901␤»

[16:11] <pmichaud> rakudo:  my @p = ^10; say (2 % @p).WHAT;

[16:11] <p6eval> rakudo e61569: OUTPUT«Num()␤»

[16:11] <pmichaud> I bet someone constrained it to Int

[16:11] <TimToady> oh, that's not right

[16:12] <TimToady> Bad Algorithm Go Home!!!

[16:12] <pmichaud> (agreed, 2 % @p should be Int)

[16:12] <pmichaud> (not easily done just yet.)

[16:12] <TimToady> I mean my josephus is wrong

[16:13] <sbp> try psellus

[16:14] <TimToady> rakudo: my @p = ^10; say gather while @p { @p.push(@p.splice(0,2); take @p.shift }

[16:14] <p6eval> rakudo e61569: OUTPUT«Statement not terminated properly at line 2, near "(@p.splice"␤in Main (src/gen_setting.pm:0)␤»

[16:14] <TimToady> rakudo: my @p = ^10; say gather while @p { @p.push(@p.splice(0,2)); take @p.shift }

[16:14] <p6eval> rakudo e61569: OUTPUT«2581607493␤»

[16:15] <TimToady> there you go

[16:15] <TimToady> DanielC: see ^^^ for a more idiomatic josephus

[16:16] <ruoso> DanielC++ # nice post

[16:17] <DanielC> TimToady: I'm blind. Where?

[16:17] <TimToady> my last rakudo command

[16:17] <DanielC> rakudo: my @p = ^10; say gather while @p { @p.push(@p.splice(0,2)); take @p.shift }

[16:17] <p6eval> rakudo e61569: OUTPUT«2581607493␤»

[16:18] <TimToady> it was 50, right?

[16:18] <TimToady> rakudo: my @p = ^50; say gather while @p { @p.push(@p.splice(0,2)); take @p.shift }

[16:18] <DanielC> Should be 28...

[16:18] <p6eval> rakudo e61569: OUTPUT«25»

[16:18] <DanielC> I think

[16:18] <TimToady> rakudo: my @p = ^50; say gather while @p { @p.push(@p.splice(0,2)); take @p.shift }

[16:18] <DanielC> I hope it's 28! Otherwise all my versions are wrong!

[16:18] <p6eval> rakudo e61569: OUTPUT«25811»

[16:18] <pmichaud> TimToady: rakudo resource limits 

[16:18] <DanielC> rakudo: my @p = ^40; say gather while @p { @p.push(@p.splice(0,2)); take @p.shift }

[16:19] <p6eval> rakudo e61569: OUTPUT«258»

[16:19] <pmichaud> moritz_: see "resource limits"

[16:19] <pmichaud> p6eval is aborting the process early

[16:19] *** pmurias left
[16:19] <DanielC> I don't understand the output though. What is 258 supposed to mean?

[16:19] <pmichaud> kill 2, then kill 5, then kill 8

[16:19] <DanielC> ruoso: thanks

[16:19] <DanielC> ah

[16:20] <pmichaud> rakudo: my @p = ^40; say (gather while @p { @p.push(@p.splice(0,2)); take @p.shift }).join(',')

[16:20] <p6eval> rakudo e61569: OUTPUT«2,5,8,11,14,17,20,23,26,29,32,35,38,1,6,10,15,19,24,28,33,37,3,9,16,22,30,36,4,13,25,34,7,21,39,18,0,31,12,27␤»

[16:20] <TimToady> yes, it's 28

[16:20] <TimToady> allowing for 0-based

[16:21] <DanielC>  my @p = ^40; say (gather while @p { @p.push(@p.splice(0,2)); take @p.shift }).join(','); say @p

[16:22] <TimToady> you want while @p > 1

[16:22] <DanielC> rakudo: my @p = ^40; say (gather while @p { @p.push(@p.splice(0,2)); take @p.shift }).join(','); say @p

[16:22] <p6eval> rakudo e61569: OUTPUT«2,5,8,11,14,17,20,23,26,29,32,35,38,1,6,10,15,19,24,28,33,37,3,9,16,22,30,36,4,13,25,34,7,21,39,18,0,31,12,27␤␤»

[16:22] * DanielC is trying to get Rakudo to say "the winner is 28"

[16:22] <TimToady> if you want the last one in @p

[16:22] <pmichaud> rakudo: my @p = ^40; say (gather while @p { @p.push(@p.splice(0,2)); take @p.shift })[*-1]

[16:22] <p6eval> rakudo e61569: OUTPUT«27␤»

[16:23] <DanielC> rakudo: my @p = ^40; say (gather while @p > 1 { @p.push(@p.splice(0,2)); take @p.shift }).join(','); say @p

[16:23] <p6eval> rakudo e61569: OUTPUT«2,5,8,11,14,17,20,23,26,29,32,35,38,1,6,10,15,19,24,28,33,37,3,9,16,22,30,36,4,13,25,34,7,21,39,18,0,31,12␤27␤»

[16:23] * ruoso working in another OO implementation of it... although it is certainly not a classical OOP problem, more of a functional problem instead

[16:23] <DanielC> rakudo: my @p = ^40; (gather while @p > 1 { @p.push(@p.splice(0,2)); take @p.shift }).join(','); say @p

[16:23] <p6eval> rakudo e61569: OUTPUT«27␤»

[16:23] <DanielC> yay

[16:24] <DanielC> Can you remove the "gather"?

[16:24] <DanielC> rakudo: my @p = ^40; (while @p > 1 { @p.push(@p.splice(0,2)); take @p.shift }).join(','); say @p

[16:24] <p6eval> rakudo e61569: OUTPUT«Died␤in Main (/tmp/HiA1rvTOnN:2)␤»

[16:24] <TimToady> rakudo: my @p = 1..40; while @p > 1 { @p.push(@p.splice(0,2)); take @p.shift }; say @p

[16:24] <DanielC> oops

[16:24] <p6eval> rakudo e61569: OUTPUT«Died␤in Main (/tmp/kUtcUyHHAw:2)␤»

[16:24] <TimToady> rakudo: my @p = 1..40; while @p > 1 { @p.push(@p.splice(0,2)); @p.shift }; say @p

[16:24] <p6eval> rakudo e61569: OUTPUT«28␤»

[16:25] <DanielC> Beautiful.

[16:25] <TimToady> seems like the push/splice is wrong

[16:25] *** Psyche^ joined
[16:25] <pmichaud> rakudo has a push problem I think.

[16:25] <pmichaud> it tends to push references instead of values

[16:25] <TimToady> but maybe it doesn't matter once it gets down to one element

[16:27] <TimToady> hmm, if push returned the array, we could say @p.push(@p.splice(0,2)).shift while @p > 1

[16:27] <DanielC> TimToady: I just added the compact solution as a comment to the blog post.

[16:28] <TimToady> if we had rotate we could do @p.rotate.rotate.shift

[16:28] *** M_o_C joined
[16:28] <TimToady> or @p.rotate(2).shift

[16:30] <pugs_svn> r27060 | pmichaud++ | [spec]:  Correct buglet in example -- 

[16:30] <pugs_svn> r27060 | pmichaud++ | squaring elements of array is @a Â»**Â» 2, not @a [**] 2.

[16:30] <pugs_svn> r27061 | pmichaud++ | [spec]:  Correct typo:  "fullwith" --> "fullwidth"

[16:33] <pugs_svn> r27062 | lwall++ | [Containers] add @array.rotate, define push and unshift to return array

[16:34] <pugs_svn> r27063 | lwall++ | [Containers] default rotation is 1

[16:35] <TimToady> okay, the solution is now officially @p.rotate(2).shift while @p > 1

[16:37] *** pmurias joined
[16:39] <Roxas> Drink the pineapple juice before you make the apple juice.

[16:41] <DanielC>  @p.rotate(2).shift would be really cool.

[16:41] *** Chillance joined
[16:41] <DanielC> my @p = 1..40; @p.rotate(2).shift while @p > 1; say @p

[16:42] *** Patterner left
[16:42] *** Psyche^ is now known as Patterner

[16:43] <ruoso> is rotate in-place modifier? or does it return a new list?

[16:43] <viklund> One more test passed

[16:43] <DanielC> In place would be cooler.

[16:44] <ruoso> DanielC, nah... that would break functional mind-set

[16:44] <DanielC> shift, pop, splice, push and unshift are all in-place.

[16:44] <DanielC> @p.rotate($n) is just @p.push(@p.splice(0,$n))

[16:44] <lambdabot> Unknown command, try @list

[16:45] <DanielC> But it's easier to read.

[16:46] <DanielC> I wonder if TimToady will add @p.rotate($n).

[16:46] <DanielC> my @p = 1..40; @p.rotate(2).shift while @p > 1; say @p

[16:46] <DanielC> I'd love to do that...

[16:46] <ruoso> if it weren't in-place...  it would be even prettier...

[16:46] <ruoso> or not...

[16:47] <ruoso> ah... forget it, misfire...

[16:47] <DanielC> :)

[16:47] <pmichaud> looks like it's inplace from the description

[16:47] <pugs_svn> r27064 | lwall++ | [Containers] more clarifications

[16:47] <DanielC> pmichaud: Description? You mean it exists?

[16:47] <TimToady> thought about requiring .=rotate

[16:48] <pmichaud> DanielC: TimToady just added them.

[16:48] <pmichaud> http://svn.pugscode.org/pugs/docs/Perl6/Spec/S32-setting-library/Containers.pod

[16:48] <pmichaud> on channel, that's what the following means

[16:48] <DanielC> *click*

[16:48] <pmichaud> 16:33 <pugs_svn> r27062 | lwall++ | [Containers] add @array.rotate, define push and unshift to return array

[16:48] <pmichaud> 16:34 <pugs_svn> r27063 | lwall++ | [Containers] default rotation is 1

[16:49] <pmichaud> i.e.,  @array.rotate was added to the spec in r27062.

[16:49] <pmichaud> in r27063 it was clarified to have a default rotation of 1.

[16:49] <DanielC> COOL

[16:49] <pmichaud> I might even get around to adding them to Rakudo today :-P

[16:49] <DanielC> I just showed my fiancee. She loved it :-)

[16:50] <DanielC> I had just finished explaining to her how TimToady's code worked.

[16:51] <ruoso> you're certainly a romantic guy

[16:51] <pmichaud> shift, splice, and push can be really .... ummm, never mind.

[16:51] <DanielC> She is geeky enough to appreciate a nice algorithm.

[16:51] <moritz_> boo, with latestet parrot t/spec/S10-packages/basic.t assertion-aborts on exit

[16:51] <pmichaud> moritz_: yes.

[16:52] <pmichaud> moritz_: the parrot folks have been working on cleaning up context gc so it doesn't leak, and there are a few issues yet.

[16:52] *** rfordinal joined
[16:52] <moritz_> and we have two passing TODOs, which I might clean up later

[16:56] <viklund> ahh, now json passes all tests

[16:56] <viklund> lets see if I can add a few more

[16:56] * moritz_ pulls

[16:56] <pugs_svn> r27065 | moritz++ | [t/spec] unfudge two passing tests for rakudo

[16:58] <moritz_> viklund: if you happen to have written a makefile, feel free to add it

[16:58] <moritz_> (or a build script, or whatever)

[16:58] <dalek> rakudo: 9aa210f | pmichaud++ | src/setting/Array.pm:

[16:58] <dalek> rakudo: Remove incorrect constraints on splice() arguments.

[16:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9aa210f6d020950d9de1cf8fd9cab3ebb8b53115

[16:58] <dalek> rakudo: 31443c0 | pmichaud++ | src/classes/Str.pir:

[16:58] <dalek> rakudo: Add some more ranges to Str.succ .

[16:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/31443c0e53e62b38b67e50c1b26832d3a9eed722

[16:59] <viklund> moritz_: ok

[16:59] <viklund> i made one actually

[16:59] <viklund> but first: supper

[17:02] <pmichaud> rakudo: say "updated?";

[17:02] <p6eval> rakudo e61569: OUTPUT«updated?␤»

[17:02] <pmichaud> not yet.  :-|

[17:02] * moritz_ triggers a pull/rebuild manually

[17:03] <TimToady> DanielC: pge's proto is not the same as p6's proto

[17:04] <TimToady> pge's proto is functioning at the macro level, not the grammar level

[17:06] *** barney left
[17:07] *** M_o_C left
[17:08] <pmichaud> rakudo: say ('⚀⚀'..'⚅⚅').join(' ');

[17:08] <p6eval> rakudo 31443c: OUTPUT«⚀⚀ ⚀⚁ ⚀⚂ ⚀⚃ ⚀⚄ ⚀⚅ ⚁⚀ ⚁⚁ ⚁⚂ ⚁⚃ ⚁⚄ ⚁⚅ ⚂⚀ ⚂⚁ ⚂⚂ ⚂⚃ ⚂⚄ ⚂⚅ ⚃⚀ ⚃⚁ ⚃⚂ ⚃⚃ ⚃⚄ ⚃⚅ ⚄⚀ ⚄⚁ ⚄⚂ ⚄⚃ ⚄⚄ ⚄⚅ ⚅⚀ ⚅⚁ ⚅⚂ ⚅⚃ ⚅⚄ ⚅⚅␤»

[17:09] <pmichaud> rakudo: say ('Α'..'Ω').join(' ');

[17:09] <p6eval> rakudo 31443c: OUTPUT«Α Β Γ Δ Ε Ζ Η Θ Ι Κ Λ Μ Ν Ξ Ο Π Ρ Σ Τ Υ Φ Χ Ψ Ω␤»

[17:09] <ruoso> Cool!

[17:09] <[particle]> :)

[17:09] <TimToady> rakudo: say <⚀⚀  ⚀⚁ > ... *

[17:09] <p6eval> rakudo 31443c: OUTPUT«Statement not terminated properly at line 2, near "... *"␤in Main (src/gen_setting.pm:0)␤»

[17:09] <ruoso> rakudo: say '𐌰'..'𐍊'

[17:09] <p6eval> rakudo 31443c:  ( no output )

[17:10] <ruoso> isn't there some generic way of detecting that sequences?

[17:10] <pmichaud> what sequence is that?

[17:10] <pmichaud> (short answer: doesn't appear to be a generic way)

[17:10] <ruoso> that is the gothic alphabet

[17:12] <viklund> rakudo: say ('⚀⚀'..'⚅⚅').pick

[17:12] <p6eval> rakudo 31443c: OUTPUT«⚅⚄␤»

[17:12] <pmichaud> viklund: looks like you win!

[17:12] <viklund> 11! yay

[17:13] <ruoso> how can I get the description of the character?

[17:13] * [particle] needs a font with better unicode support

[17:13] <pmichaud> I don't think we have a way to do that (in Rakudo, perhaps not defined in Perl 6)

[17:14] <ruoso> I saw that here some time ago

[17:14] <ruoso> as an output of rakudo in the evalbot

[17:14] <TimToady> hmm, the spec is contradictory in saying increment only does \w chars and then mentioning dice, i think

[17:15] <ruoso> the thing that returns "GOTHIC LETTER AHSA" for "𐌰"

[17:15] *** DemoPhreak left
[17:15] <TimToady> rakudo: say '⚀' ~~ /\w/

[17:15] <p6eval> rakudo 31443c: OUTPUT«␤»

[17:15] <pmichaud> does the spec say that increment only does \w chars?

[17:16] <TimToady> S03:431 seems to think so

[17:16] <pmichaud> rakudo:  my %dice = ( '⚀⚀'..'⚅⚅' Z ( 1..6 X+ 1..6 ) );  say %dice.perl;

[17:16] <p6eval> rakudo 31443c: OUTPUT«{"⚀⚀" => 2, "⚀⚁" => 3, "⚀⚂" => 4, "⚀⚃" => 5, "⚀⚄" => 6, "⚀⚅" => 7, "⚁⚀" => 3, "⚁⚁" => 4, "⚁⚂" => 5, "⚁⚃" => 6, "⚁⚄" => 7, "⚁⚅" => 8, "⚂⚀" => 4, "⚂⚁" => 5, "⚂⚂" => 6, "⚂⚃" => 7, "⚂⚄" => 8, "⚂⚅" => 9, "⚃⚀" => 5, "⚃⚁" => 6, "⚃⚂" => 7, "⚃⚃" => 8, "⚃⚄" => 9, "⚃⚅" => 10, "⚄⚀" => 6,

[17:16] <p6eval> .."⚄⚁" …

[17:16] <TimToady> but it's probably wrong

[17:17] <ruoso> depending on how standard the definition of "GOTHIC LETTER AHSA" is, you could probably get the "GOTHIC LETTER" part, and follow to the next one until you get a different "group"

[17:17] <ruoso> that would be a generic way of doing it

[17:18] <pmichaud> ruoso: there are a couple of places where we need to skip codepoints (in the greeks, for example)

[17:19] <ruoso> hmm... that's a shame

[17:19] <pugs_svn> r27066 | lwall++ | [S03] tweak rangechars not to be limited to \w

[17:19] <japhb> pmichaud: sorry to hear about  PARROT_REVISION to 39521 specfail.  Ah well, here's hoping we can bump it to a higher number soon, as this allows Rakudo to 'use Foo:from<parrot>;' .  Speaking of which, did you want to do the deprecation honors?

[17:19] <pmichaud> japhb: what gets deprecated?

[17:19] <ruoso> pmichaud, is there an easy way to get all characters from the "GOTHIC LETTER" group?

[17:19] <pmichaud> japhb: and we'll have to bump it to a higher revision on Tuesday

[17:19] <pmichaud> ruoso: I don't think ICU gives me an easy way to do that, no.

[17:20] <japhb> pmichaud: you said you wanted to immediately deprecate the import/export system, so that it was effectively marked "experimental" -- there being no direct way to do the latter.

[17:20] <pmichaud> oh, that.  Just add notes to DEPRECATED.pod

[17:21] <pmichaud> japhb: also, we'll have to bump the revision on Tuesday at the latest, so it should be addressed by then

[17:21] <TimToady> basically Perl 6 defines it own rangechar class to be all codepoints with a known cyclical successor

[17:21] <pmichaud> does the successor have to be at "codepoint plus 1" ?

[17:21] <TimToady> nope

[17:21] <pmichaud> right.

[17:21] <TimToady> spec says to skip trailing sigma, for instance

[17:22] <pmichaud> (which Rakudo does :-)

[17:22] <japhb> pmichaud: My understanding of DEPRECATED.pod is that you need a TT for each entry.  Do you want me to create a basic TT referencing your 'experimental' wishes?

[17:22] <pmichaud> sure.

[17:22] <TimToady> a TimToady? a TemplateToolkit?  :P

[17:22] <pmichaud> japhb: also, I'm currently bisecting parrot revisions to find the one that is causing the breakage, so we can report that.

[17:23] <pmichaud> I *think* it's likely a gc issue.

[17:23] <japhb> excellent.

[17:23] <pmichaud> TimToady: TT in parrot speak is "Trac Ticket"

[17:23] <TimToady> yes, I know

[17:23] <pmichaud> okay.

[17:23] <pmichaud> off to pick up daughter from Mandarin class

[17:23] <TimToady> but till now that usage as primarily been in #parrot, not #perl6...

[17:23] <TimToady> *has

[17:26] *** mizioumt1 left
[17:28] <japhb> TimToady: my apologies; sometimes I forget to switch to the other tab while talking to someone who is in both channels -- and we're talking about something that applies at the border between them.  :-/

[17:31] <TimToady> np

[17:31] <TimToady> just giving pm a hard time

[17:31] <TimToady> well, and you

[17:31] <TimToady> :)

[17:38] <japhb> :-)

[17:38] <viklund> moritz_: now it has a build system as well

[17:44] <pmichaud> the fact that TimToady gives me a hard time is how I know he still cares :-)

[17:44] *** rindolf joined
[17:45] <pmichaud> my $dice = '⚅';  say ++$dice;

[17:45] *** molaf joined
[17:45] <pmichaud> rakudo: my $dice = '⚅';  say ++$dice;

[17:45] <p6eval> rakudo 31443c: OUTPUT«⚀⚀␤»

[17:46] *** mizioumt joined
[17:46] *** Meldrake joined
[17:52] *** DanielC left
[17:56] *** bejuryu left
[18:19] *** felipe joined
[18:21] <pmurias> ruoso: so undefined object functioning as types is the way i should implement types in mildew?

[18:22] <ruoso> pmurias, that's the way it is in Perl 6 at the moment

[18:24] *** frew_ joined
[18:29] *** M_o_C joined
[18:29] <moritz_> viklund++

[18:34] <viklund> moritz_: I think I fixed the \uXXXX parsing as well

[18:34] <viklund> ;)

[18:36] *** DanielC joined
[18:40] <moritz_> viklund: parsing or transforming?

[18:40] <viklund> transforming

[18:41] <viklund> I've added two small tests

[18:41] <moritz_> viklund++ again

[18:42] <moritz_> I think we need a #perl6-all channel with reporting bots of the various Perl 6 projects

[18:42] <moritz_> it might get a bit croweded if we did that here

[18:42] <viklund> yes, I've been thinking of writing one in p6

[18:42] <viklund> but then I need a json parser for github ;)

[18:43] <viklund> IO::Socket::INET should be enough for the rest I think

[18:43] <viklund> need to implement the IRC protocol though

[18:44] <moritz_> json parser... ;-)

[18:44] <ruoso> TimToady, considering "my @a = 1,[2,[3,4]];" is @a[1;1;1] a valid access?

[18:44] <ruoso> or does that only applies to captures?

[18:44] *** frew_ left
[18:44] <DanielC> my @a = (1, 2, 3; 4, 5, 6; 7, 8, 9); @a.perl.say

[18:45] <ruoso> std: my @a = 1,[2,[3,4]]; say @a[1;1;1]

[18:45] <japhb> #perl6-bot-party

[18:45] <p6eval> std 27066: OUTPUT«ok 00:03 38m␤»

[18:45] <DanielC> rakudo: my @a = (1, 2, 3; 4, 5, 6; 7, 8, 9); @a.perl.say

[18:45] <p6eval> rakudo 31443c: OUTPUT«[7, 8, 9]␤»

[18:45] <DanielC> What does ; do?

[18:46] <ruoso> DanielC, it says there is one other level of captures

[18:46] <ruoso> but rakudo is not implementing it correctly now

[18:46] <japhb> It's the interdimensional rift operator

[18:46] <japhb> :-)

[18:46] <DanielC> one other level of capture == ?

[18:46] <japhb> DanielC: Capture containing captures.

[18:46] <viklund> moritz_: the fix for the \uXXXX was changing the grammar slightly

[18:47] <moritz_> it's supposed to be the same as @a = \(1, 2, 3), \(4, 5, 6), \(7, 8, 9) # not entirely sure though

[18:47] <DanielC> So, it's like (1,2,3,(4,5,6,(7,8,9))) ?

[18:47] <moritz_> DanielC: but if you assign it to an array, it's flattened anyway

[18:47] <DanielC> ah, no, thanks

[18:47] <moritz_> DanielC: so it's the same as @a = 1..9; really

[18:48] <DanielC> Yeah, but you could do something interesting with it, no?

[18:48] <ruoso> moritz_, looks like ((1,2,3),(4,5,6),(7,8,9)) as well... which looks easier

[18:48] <DanielC> Something more interesting than giving it to an array.

[18:48] <moritz_> yes, like assigning it to @@a or a scalar

[18:48] <DanielC> ok

[18:48] <ruoso> which remembers me of the ¢a idea

[18:50] *** molaf left
[18:55] * viklund delving deep into RFC-land

[18:55] <pmurias> ruoso: does the default ACCEPTS method disappear in defined punned class instances?

[18:55] <ruoso> the common understanding is that it will behave like a multi

[18:55] <ruoso> with a constraint in the invocant

[18:56] <ruoso> so you can simply do a if self.defined { ... } else { ... } for bootstrapping purposed

[18:56] <ruoso> *purposes

[19:09] <pmurias> ruoso: and the else ... should contain what?

[19:10] <ruoso> the code to make $signature ~~ Signature to work

[19:10] <ruoso> since $signature ~~ Signature actually means Signature.ACCEPTS($signature)

[19:11] *** hanekomu joined
[19:13] <pugs_svn> r27067 | moritz++ | [t/spec] RT #61988, $.foo form did not accept arguments

[19:13] *** masak joined
[19:13] <masak> greetings, fellow hacktivists.

[19:14] * masak is moving about 100 km/h

[19:14] *** masak left
[19:14] <moritz_> oh hai masak

[19:14] *** masak joined
[19:15] <ruoso> masak, it looks like your connection gets a bit flacky at 100km/h

[19:15] <ruoso> ;)

[19:15] *** jantore left
[19:16] <masak> ruoso: yes. guess you can't have everything.

[19:16] <masak> I'm also a constant three meters above ground.

[19:18] <moritz_> masak: is it a train?

[19:18] <masak> no, a bus.

[19:18] <DanielC> @seen pmichaud

[19:18] <lambdabot> pmichaud is in #perl6. I last heard pmichaud speak 1h 33m 25s ago.

[19:18] <ruoso> a flying bus?

[19:18] <masak> pmichaud: a closer look at PAST reveals that it's already too digested for my aims.

[19:18] <pmichaud> lambdabot: shhhh!  I'm not really here!

[19:18] <pmichaud> masak: possibly, yes.

[19:19] <DanielC> :-)

[19:19] <pmichaud> however, the PAST tree does contain the parse tree as well :-)

[19:19] <masak> ruoso: yes, we have flying buses in Sweden.

[19:19] <DanielC> pmichaud: I can't find pgc.pir in the Rakudo distribution.

[19:19] <pmichaud> ...pgc.pir ?

[19:19] <DanielC> pmichaud: PGE

[19:19] <pmichaud> PGE is part of parrot

[19:19] <DanielC> Parrot Grammar Engine?

[19:19] <masak> pmichaud: I guess. :) I'm not interested in the parse tree as such, but the structure of the program.

[19:20] *** donaldh left
[19:20] <masak> DanielC: Parser Grammar Engine.

[19:20] <DanielC> pmichaud: Yeah, but Rakudo includes parrot, no?

[19:20] <masak> (I learned that from Wikipedia today)

[19:20] <DanielC> in the rakudo/parrot directory.

[19:20] <pmichaud> DanielC: sure, Rakudo is built from parrot.  It'd be in the parrot/ subdirectory

[19:20] <pmichaud> more to the point, PGE is parrot/compilers/pge/

[19:20] *** donaldh joined
[19:20] <pmichaud> I think there might have been a pgc.pir at one time, but it's long gone

[19:21] <DanielC> pmichaud: I must have done something wrong. I could not find it with 'find'

[19:21] <DanielC> PGE.pir ?

[19:21] <[particle]> wikis are always wrong.

[19:22] <DanielC> [particle]: And slide presentations too :)   I got pgc.pir from one of pmichaud's presentations.

[19:22] <pmichaud> DanielC: what in particular are you looking for with PGE?

[19:22] <pmichaud> DanielC: from how long ago?!?  ;-)

[19:22] <DanielC> parrot pgc.pir simple.pg >simple.pir

[19:22] <DanielC> ^^^ that's what I'm looking for.

[19:22] <pmichaud> it's now  Perl6Grammar.pbc

[19:22] <pmichaud> in runtime/parrot/library/PGE

[19:22] <masak> pmichaud: 2007, methinks. :/

[19:22] <masak> sorry, I gave him that link.

[19:22] <viklund> bah, it will take too long to read the RFC, I'll go read Net::IRC instead

[19:22] <DanielC> thanks

[19:23] <pmichaud> we still had pgc in 2007?  wow.

[19:23] <moritz_> viklund: it might be even easier to read a dumb of the protocoll ;-)

[19:23] <masak> pmichaud: no, 2006 :/ http://www.pmichaud.com/2006/pres/yapc-parsers/start.html

[19:23] <DanielC> pmichaud: Wait... "runtime"? That's not in Rakudo, is it?

[19:23] <DanielC> ah... parrot/runtime

[19:24] <DanielC> not runtime/parrot :)

[19:24] <pmichaud> parrot/runtime/parrot/library/PGE

[19:24] <DanielC> ah, there it is.

[19:24] <DanielC> thanks

[19:25] <[particle]> anyone here good at setting up terminal, irssi, and %ENV set up for unicode?

[19:25] <DanielC> pmichaud: Can I copy that file to a different directory? Or does it depend on other files in that directory?

[19:25] <pmichaud> I think it can be copied around.

[19:25] <viklund> moritz_: aaahh, a dump...

[19:26] <DanielC> pmichaud: Seems to work. :-)

[19:26] <moritz_> viklund: right ;-)

[19:26] *** szabgab joined
[19:26] <viklund> yes, that might be better

[19:27] *** masak left
[19:27] *** masak joined
[19:27] <viklund> masak: 3g?

[19:27] <masak> (oops.)

[19:27] <pugs_svn> r27068 | pmurias++ | [re-smop] start of implementing .ACCEPTS for punned classes

[19:27] <masak> viklund: no, bus.

[19:28] <viklund> bus wifi?

[19:28] <masak> viklund: for the win.

[19:28] <viklund> cool

[19:28] <masak> swebusexpress++

[19:28] <japhb> bus wifi is getting fairly common, it seems.

[19:28] <japhb> Of course, when the bus is out of cell tower range (so it can't provide the next hop), you tend to experience fail.

[19:28] <Muixirt> pmichaud, please look at http://nopaste.snit.ch/16881

[19:29] <Muixirt> why is new $P20, "Int" inside the loop?

[19:30] <TimToady> ruoso: see my latest multi-dim speculation in p6l

[19:31] <ruoso> TimToady, you sent it just now?

[19:31] <ruoso> or is something older?

[19:32] *** estrabd left
[19:32] <viklund> wireshark requires... gnome-keyring??

[19:32] <TimToady> oh wait, hasn't left my mqueue yet...

[19:32] <ruoso> ah... 

[19:32] <pmichaud> Muixirt: we don't do any loop constant factoring yet

[19:32] <japhb> viklund: that's odd.  Perhaps so it can show you decrypted traffic?

[19:33] <masak> Muixirt: told you. :)

[19:33] * ruoso was pressing 'refresh the imap folder' constantly

[19:34] <TimToady> stupid isp doesn't like me forwarding spam for some reason...

[19:34] <TimToady> anyway, proposing @a[] to replace @@a

[19:34] <ruoso> uh?

[19:35] <ruoso> you mean @a[] = ?

[19:35] <TimToady> if @@ is a capture sigil, it's a no-op

[19:35] <TimToady> but we want a coercion

[19:35] <ruoso> we do?

[19:35] <Muixirt> pmichaud, the assignment of the constant integer isn't a problem

[19:36] <masak> "On #perl6, we're so up-to-date that we get confused by p6l emails that haven't even been sent yet."

[19:36] <pmichaud> Muixirt: what "problem" are you referring to, then?

[19:37] <ruoso> TimToady is a marketing wizard... he can even make a teaser about a mailing list post...

[19:37] <ruoso> :P

[19:37] <masak> "Coming soon to an inbox near you!"

[19:37] <Muixirt> pmichaud, that while 1 { }; leaks mem

[19:37] *** estrabd joined
[19:37] <pmichaud> Muixirt: the problem is very likely not rakudo.

[19:37] <pmichaud> it's very likely an issue in parrot.

[19:38] <ruoso> TimToady, btw... I really thought the capture sigil was precisely there to mean "no coercion"

[19:38] <pmichaud> Muixirt: here, I'll give a test program that is pure parrot as a demo

[19:38] <ruoso> actually... it wasn't still there, but it would be there...

[19:39] <pmichaud> (building a parrot demo... one moment)

[19:39] * ruoso still hitting "refresh" in his IMAP folder

[19:39] <Muixirt> pmichaud, http://nopaste.snit.ch/16885

[19:39] <pmichaud> Muixirt: ...?

[19:41] <Muixirt> that example leaks mem and is derived from the rakudo example

[19:41] <pmichaud> right

[19:41] <TimToady> okay, reset the network, and email went

[19:42] <pmichaud> Muixirt: that tells me it's a parrot bug

[19:42] <pmichaud> Muixirt: as parrot shouldn't be leaking memory there

[19:42] <pmichaud> Muixirt: how are you measuring "leaked memory", ooc?

[19:43] <Muixirt> pmichaud, via top and strace -c

[19:43] <pmichaud> Muixirt: anyway, it's a parrot bug, not a rakudo one.  

[19:43] <dalek> rakudo: de1e9f0 | moritz++ | docs/ChangeLog:

[19:43] <dalek> rakudo: [docs] initial changelog for 2009-06 release

[19:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/de1e9f0eb0ee15c069b39abd27314a24e41d4b9b

[19:43] <Muixirt> pmichaud, i think there are two bugs

[19:43] <Muixirt> one of parrot for not collecting $P0

[19:44] <Muixirt> and rakudo for placing the $P0 allocation inside the loop

[19:44] <pmichaud> Muixirt: I already said we don't do loop constant factoring

[19:44] <ruoso> TimToady, there is one thing that gets lost in that behavior

[19:45] <ruoso> my ¢a = (1,2,3;4,5,6;7,8,9); my @b = ¢a.rotate(1;1);

[19:45] <Muixirt> pmichaud, so the $P0 allocation and the assignment to it cannot be split?

[19:45] <pmichaud> Muixirt: suppose the loop was instead

[19:45] <pmichaud> while foo() { }

[19:45] <pmichaud> the call to foo() would have to be inside the loop, yes?

[19:45] <ruoso> TimToady, unless you meant that only "in addition" to the behavior described in the above code

[19:45] <ruoso> so the above would also work

[19:46] <TimToady> use @b[] = 

[19:46] <ruoso> no... I really meant to flatten at that point

[19:46] <ruoso> my point was precisely to have an unflattened structure, manipulate it, and only later flatten it

[19:47] <TimToady> @b = flattens

[19:47] <lambdabot> Maybe you meant: b52s babel bf bid botsnack brain bug . ? @ v

[19:47] *** payload joined
[19:47] <TimToady> maybe you have a brain bug, lambdabot

[19:47] <ruoso> right.. so your email only describes new behavio

[19:47] <masak> @botsnack

[19:47] <lambdabot> :)

[19:47] <ruoso> not replacing behavior ;)

[19:47] <TimToady> correct

[19:48] <pmichaud> Muixirt: from rakudo's perspective,   a constant 1  currently results in    $P0 = new 'Int'; assign $P0, 1;

[19:48] *** Helios left
[19:48] <pmichaud> it does not attempt to factor out all of the constant 1's that might exist into a single PMC

[19:48] <ruoso> TimToady, I think that's cool, and solves a lot of semantic issues as well... 

[19:49] *** Helios joined
[19:49] <pmichaud> it does not attempt to pre-allocate the PMCs before the assignment (as that could also be wrong)

[19:49] <pmichaud> what you're describing is properly an optimization, not a bug.

[19:49] <ruoso> TimToady, and I do think that means '@@' should die... leaving room for '@%' and '¢' in its place

[19:50] <Muixirt> pmichaud, ok thanks for the explanation

[19:50] *** M_o_C left
[19:51] *** masak left
[19:52] <ruoso> TimToady, one thing that should be noted, otoh, is that @a[] = (1,2,3;4,5,6;7,8,9) would create 4 new arrays....

[19:53] <pmichaud> Muixirt: it could indeed make a lot of sense to move all of the constant initializations to the beginning of the sub.

[19:53] <ruoso> in contrast to "¢a = (1,2,3;4,5,6;7,8,9)" which would simply store that capture in '¢a'

[19:53] <TimToady> sure, but that's how you say you want mutable subarrays

[19:53] <pmichaud> I may see about doing that in PCT.  We would get a speed and memory benefit.

[19:54] <ruoso> TimToady, right... makes sense... 

[19:54] <pmichaud> (we would get a penalty by constructing constants that might not get used, though)

[19:55] <TimToady> a penalty that Perl 5 pays continually, with not that much ill effect :)

[19:56] <pmichaud> TimToady: constructing constants at the beginning?

[19:56] <pmichaud> or on each reference?

[19:57] <TimToady> pmichaud: I don't follow

[19:57] <pmichaud> right now we construct PMCs for each constant that appears in the program

[19:57] <pmichaud> currently the PMC gets constructed at the point where the constant is actually used

[19:58] <pmichaud> so, if we have a loop:    while foo() { say 1; }

[19:58] <pmichaud> then the "1" constant ends up creating a PMC on each loop iteration

[19:58] <TimToady> why?

[19:58] <ruoso> pmichaud, but that certainly can be optimize

[19:58] <pmichaud> that's just the way the code generates at the moment

[19:58] <ruoso> *optimized

[19:58] <pmichaud> ruoso: yes, that's what I'm talking about.

[19:58] <TimToady> seems like a waste for value semantics

[19:59] <pmichaud> which part of "waste" are you referring to?  ;-)

[19:59] <Muixirt> and the problem is that parrots GC doesn't catch that

[20:00] * ruoso has a feeling that we're not talking about the same thing

[20:00] <TimToady> you should only ever have to create a single 1 pmc, and just reuse it, meseemeth

[20:00] <pmichaud> Muixirt: I'm after a different issue.

[20:00] <TimToady> as long as it's sufficiently readonly

[20:00] <pmichaud> TimToady: right.  So the question is, when does that 1 PMC get created?

[20:00] <pmichaud> at the beginning of the program?

[20:00] <ruoso> my guess is BEGIN

[20:00] <TimToady> sometime between the time it's compiled and the time it's used

[20:01] <pmichaud> so my question is,  does Perl 5 currently construct all such constants at the beginning?

[20:01] <ruoso> but that's one of the issues of code compilation that I don't see really solved yet

[20:01] <pmichaud> or does it do something more lazily?

[20:01] <ruoso> pmichaud, it stores in the optree as constant, iirc

[20:01] <ruoso> which means that it's done in the "compiling"

[20:02] <pmichaud> I don't presently have a way to store the already-compiled-PMC in the compiled parrot code.  I have to construct it at "runtime".

[20:02] <pmichaud> I can construct it at the beginning, though, and refer to it thereafter.

[20:03] <pmichaud> (then the questions become:  (1) where do I store them for easy lookup, and (2) is it more expensive to look them up than to create new ones?)

[20:03] <TimToady> the compiler has to be able to set up data and pass it preconstructed to the run time

[20:03] *** amoc is now known as amoc^sleep

[20:03] <ruoso> pmichaud, that's why I think you need to be able to serialize things into the bytecode

[20:03] <pmichaud> ruoso: I don't disagree.  I'm working with what I have available.

[20:03] <ruoso> in fact... the result of the compilation is supposed to be a serialized state of the runtime

[20:04] <pmichaud> Right now what we do is generate the code that sets up the data as preconstructed to the run time

[20:04] <ruoso> and I'm kinda reaching the conclusion that "use" means "static link" 

[20:04] <pmichaud> (and yes, this is part of why rakudo's startup is a bit slow)

[20:04] <ruoso> that's what mildew is doing now too

[20:05] <TimToady> note that the whole YOU_ARE_HERE setting thing is assuming a similar ability to dump the snapshot, just in a different spot than for normal compilation

[20:05] <pmichaud> agreed.

[20:05] <pmichaud> I do expect most of these problems to be solved in Parrot, I just don't expect them in the near future.

[20:06] <pmichaud> Unless, of course, we can convince jnthn++ do to them.  :-)

[20:06] <ruoso> my vision for this goes like

[20:07] <ruoso> if you "use", the "compiled" thing will contain all the "use"d modules

[20:07] <ruoso> if you don't want that, you need to "require"

[20:07] <pmichaud> (and yes, Parrot does have a serialization mechanism for bytecode in its design, I've just (1) had trouble getting it to work reliably and (2) have questions about how it's supposed to work when there are tons of references lying about)

[20:07] <ruoso> so.. "use" is "static link" and "require" is "dynamic link"

[20:07] <TimToady> it's really more of a Smalltalkian save-the-current-workspace kind of thinking

[20:07] <ruoso> pmichaud, just make sure everything is serialized

[20:08] <ruoso> and make sure BEGIN don't do anything bad

[20:08] <pmichaud> right now "everything" includes the entire compile environment, I fear.

[20:09] <TimToady> well, it has to, for eval to work right

[20:09] <ruoso> but we already know you need that

[20:09] <TimToady> hopefully that part doesn't get paged in unless you need it :)

[20:09] <pmichaud> you mean also serializing copies of the builtin library subs and the like?

[20:09] <ruoso> yes... you probably want to mmap the bytecode instead of reading it

[20:10] <ruoso> pmichaud, yes... *everything*

[20:10] <TimToady> except

[20:10] <ruoso> otherwise you won't really be able to have all the semantics

[20:10] <TimToady> again it comes down to a question of identity

[20:10] <pmichaud> ruoso: that is likely to be huge.  The bytecode image is already 3MB.

[20:10] <TimToady> you can cheat as long as you can nail down the identity of everything so it doesn't change

[20:11] <ruoso> right... except if your bytecode reader can assume the identity of built-in types

[20:11] <pmichaud> right, that's what I'm saying.  Parrot doesn't have support for those kinds of cheats yet.

[20:11] <ruoso> but that's not quite easy

[20:11] <TimToady> if it's going to grow back to that big anyway, better to have it pregrown

[20:11] <ruoso> agreed...

[20:11] <pmichaud> it doesn't grow back to that big

[20:12] <ruoso> that simply means you don't need to load the setting before running the file

[20:12] <pmichaud> the subs themselves are precompiled

[20:12] <ruoso> since the setting is part of the file

[20:12] <pmichaud> so we don't have to rebuild them.

[20:12] <pmichaud> we just rebuild the signature and other attributes that we don't have a way of compile-time attaching to the subs.

[20:13] *** mberends joined
[20:13] <TimToady> seems like a bogus dichotomy to me

[20:13] <ruoso> the problem is that you're trying too hard to split compile-time from run-time

[20:13] <pmichaud> TimToady: I don't entirely disagree; again, I'm kinda constrained by "what actually works in parrot"

[20:14] <pugs_svn> r27069 | moritz++ | [t/spec] RT #65674, multi subs in classes

[20:14] <ruoso> having the code compiled down in Perl 6 simply means: hibernate the process before INIT

[20:15] <TimToady> well, but pmichaud++'s point is sure to apply to other VMs as well

[20:15] <TimToady> maybe what we have is a model more like...

[20:15] <pmichaud> ruoso: Let me give a more concrete example.

[20:15] <TimToady> there's snapshot that has everything, and

[20:15] <pmichaud> let's say I'm compiling the following

[20:15] <pmichaud>     sub foo(Int $x) { ... }

[20:15] <TimToady> a snapshot that has the initial load for a particular VM

[20:16] <TimToady> and that intial load knows how to fetch anything else from the complete image as necessary

[20:16] <pmichaud> after compilation, there's an entry '&foo' in my current namespace, that points to a Sub object, that Sub object has a $!signature attribute, that $!signature attribute references the 'Int' type object

[20:16] <pmichaud> if I attempt to serialize &foo, I'm going to get a copy of 'Int' and everything that it references in my serialization

[20:18] <TimToady> no, not a copy, if you serialize everything

[20:18] <TimToady> you only get one Int, and everyone refs it

[20:18] <pmichaud> okay, so I have to serialize the entire compile-time enviornment

[20:18] <ruoso> exactly

[20:18] <pmichaud> my point is that a serialization of &foo includes everything that it references.

[20:18] <TimToady> that's what I'm saying goes into the complete snapshot

[20:18] <TimToady> the intial loader doesn't have to pull in everything though

[20:19] <TimToady> *initial

[20:19] <TimToady> it can be lazy

[20:19] *** decasm left
[20:19] <pmichaud> I'm still missing a piece here

[20:19] <TimToady> espically about loading in the compiler, if there's no eval

[20:19] <sjohnson> when is the next State of the Onion?

[20:20] <TimToady> the Onion has a new state continually :)

[20:20] <pmichaud> let's suppose I create Foo.pm, and compile it to bytecode.  That bytecode compilation has a copy of the entire compiler?

[20:20] <pmichaud> then I create Bar.pm, and compile it to bytecode.  It also gets a copy of the entire compile-time environment?

[20:20] <pmurias> why not?

[20:21] <TimToady> again, you can factor out immutables as long as the identity is fixed

[20:21] <pmichaud> right.

[20:21] <pmichaud> which is the piece I'm claiming is missing from Parrot.

[20:21] <ruoso> but...

[20:21] <TimToady> which is why I keep insisting that officially installed modules change version when modified

[20:22] <ruoso> you can have a compilation that targets "shared library"

[20:22] <ruoso> and in that "compilation mode" you produce a specialized bytecode

[20:22] *** Whiteknight left
[20:22] <ruoso> but that's different from the "runnable" bytecode

[20:22] <pmichaud> so the correct way of phrasing what Rakudo currently does is that it does the equivalent of a dynamic link when a bytecode module is loaded

[20:22] <ruoso> yes... but "use" is "static link"

[20:23] <pmichaud> ruoso: I'm sorry, but I really don't envision that we want every pre-compiled bytecode to have a complete copy of the Perl 6 library in it.

[20:23] <TimToady> in the abstract, yes

[20:23] <ruoso> that's why the Perl 6 library should be small

[20:24] <ruoso> but it's the same with C or C++

[20:24] <pmichaud> the Perl 6 library is anything but small.

[20:24] <pmichaud> 300+ operators pretty much guarantees that

[20:24] <pmichaud> (not to mention all of their multi variants)

[20:24] <ruoso> you always get the entire libc or libstdc++ 

[20:24] <pugs_svn> r27070 | moritz++ | [t/spec] RT #66552, Null PMC Access on user defined infix:<==>

[20:24] <TimToady> you'll note those are dynamically linked these days...

[20:24] <ruoso> pmichaud, one thing you're missing

[20:24] <pmichaud> What TimToady++ just said -- you get them, but normally through dynamic linking.

[20:25] <pmichaud> Try compiling a program with static linking that uses all of the library and see how big your .o and executable gets :-)

[20:25] <moritz_> rakudo: say Nil ~~ undef

[20:25] <p6eval> rakudo de1e9f: OUTPUT«1␤»

[20:26] <ruoso> pmichaud, that might mean we need to rethink the way we're building the Perl 6 CORE

[20:26] <moritz_> rakudo: say Nil ~~ ()

[20:26] <p6eval> rakudo de1e9f: OUTPUT«1␤»

[20:26] <moritz_> rakudo: say Nil.new ~~ ()

[20:26] <p6eval> rakudo de1e9f: OUTPUT«1␤»

[20:26] <moritz_> rakudo: say Nil.new ~~ undef

[20:26] <p6eval> rakudo de1e9f: OUTPUT«1␤»

[20:27] <ruoso> pmichaud, btw... the thing you're missing is that you're going to load the setting anyway... that being statically linked or dinamically linked... 

[20:27] <TimToady> any compiled module that starts with the standard setting does not need to serialize anything in the standard setting, as long as it can dynamically link back to the standard setting

[20:27] <pmichaud> ruoso: that's not at all what I'm missing.

[20:27] <ruoso> and unless we make it use the OS shared library mechanism, it will make little difference to be statically or dinamically linked

[20:28] <pmichaud> ruoso: I understand that we're going to load the setting anyway.  Your statement "serialize the entire compile-time environment" sounds like I'm having to serialize the setting as well.

[20:28] <moritz_> rakudo: say (42 if 0) ~~ undef

[20:28] <p6eval> rakudo de1e9f: OUTPUT«0␤»

[20:28] <moritz_> rakudo: say (42 if 0) ~~ ()

[20:28] <p6eval> rakudo de1e9f: OUTPUT«0␤»

[20:28] <pmichaud> and when I do "use Foo;" I've already got a copy of the setting in memory.  I don't want to load Foo's copy in on top of that.

[20:29] <ruoso> pmichaud, that's what I was talking about a specialized "compiling target" for "shared libraries"

[20:29] <pmichaud> ruoso: which libraries aren't shared?

[20:29] <pmichaud> in a perl 6 sense?

[20:29] <ruoso> the ones that were statically linked into your program

[20:30] <pugs_svn> r27071 | moritz++ | RT

[20:30] <pmichaud> anyway, the things TimToady is saying I can agree with, and it sounds similar to what we're doing now.

[20:30] <ruoso> I mean... a runnable file is usually not a "shared library"

[20:31] <moritz_> dammit, that shouldn't be the whole commit message

[20:31] <ruoso> can we guarantee that serialization of an old version can initialize a newer version of something in the setting?

[20:31] <[particle]> ...that makes it easy to agree with...

[20:32] <pmichaud> the notion of serializing the entire compile-time environment doesn't fit in my worldview, though.  serializing everything up to the parts that we know are "fixed" makes sense to me, and providing a way to link back to them upon load.

[20:32] <sjohnson> question:  I haven't learned OOP Perl 5 yet.  I have the Camel book.  Should I just learn Perl 6 OOP instead?

[20:32] <TimToady> the point is that there are boundaries through which reference happens in only one direction, and so while your program can have references into the used modules or into the setting, they cannot have references back into your code

[20:32] <moritz_> sjohnson: that depends on what you want to do

[20:32] <TimToady> pmichaud: yes, I think we're in violent agreement on that

[20:32] <moritz_> sjohnson: if you want to program in perl 5, read the camel book.

[20:32] <ruoso> my point is: the compilation of a "shared library" generates the bytecode that by being run will define the library...

[20:33] <moritz_> sjohnson: if you want to program Perl 6, learn the Perl 6 OO

[20:33] <ruoso> the compilation of a "runnable object" is the serialization of the vm

[20:33] * ruoso fu**ng lag

[20:33] <pmichaud> TimToady: I agree.  AFAIK, Parrot doesn't give me a "serialize up to the fixed parts" option yet.  It's pretty much "serialize everything".

[20:33] <sjohnson> moritz_: ok cool. i have decided that i might as well learn what's "up and coming"

[20:33] <sjohnson> as I will easily like Perl 6

[20:34] <pmichaud> regardless, we need the "link to the fixed portions" step in the initialization code, and that's part of what we generate

[20:34] <pmichaud> we also have to dynamically generate our constants, because they include hooks into the setting that have to be established

[20:34] <ruoso> pmichaud, yeah... one thing that got lost here is that I do think we might need to rethink how we define the CORE

[20:34] <pmichaud> ruoso: I'm fine with rethinking that.

[20:35] <sjohnson> TimToady: have you done your own "Just Another Perl Hacker" program?

[20:35] <ruoso> pmichaud, so it is more "shared library"-like 

[20:35] <pmichaud> sjohnson: learning the Perl 5 OO will probably be more of a distraction than help if you're wanting to mainly do Perl 6

[20:35] <pmichaud> sjohnson: if you're wanting to do Perl 5 stuff, then I'd recommend looking at Moose

[20:35] <TimToady> sjohnson: yes, it went out and looked up all of merlyn's JAPHs on the net, and ran one of them at randome

[20:35] <TimToady> *random

[20:35] <ruoso> pmichaud, we might need a 'header file' kind of thing

[20:36] <ruoso> one thing this brings up is the need of two different versions of the same module loaded by the run time

[20:37] <pmichaud> anyway, to get back to the issue that started this all -- Rakudo's idea of constants aren't quite read-only enough yet to be able to move them around cleanly, but they'll soon be that way when I've done my rw refactor.

[20:37] <TimToady> we need something yamlish that can not only detect duplicate copies and &1 them, but do the same for things already externally immutable and just put the external ref

[20:38] <TimToady> so, for instance, the ::OUTER link from ::UNIT to ::SETTING is broken and stored as an identity, not as a tree

[20:38] <pmichaud> Exactly.

[20:38] <TimToady> so from the standpoint of the compiler, it *thinks* it's serializing the whole magilla

[20:38] <ruoso> TimToady, even if the setting changes version?

[20:39] <TimToady> but it isn't

[20:39] <TimToady> THE IDENTITY INCLUDES VERSION AND AUTH!!!

[20:39] *** alester joined
[20:39] <TimToady> sorry

[20:40] <ruoso> so what happens if that specific version is not in the runtime? 

[20:40] <TimToady> in my parlance, if I say "identity", I mean the name of something immutable

[20:40] <TimToady> you don't throw away old versions of things that are still in use in P6

[20:40] <pugs_svn> r27072 | moritz++ | [t/spec] RT #66404

[20:41] *** kate21de joined
[20:41] <TimToady> it's just a library GC problem

[20:41] <ruoso> TimToady, but what if you take something compiled a while ago into a machine and sent to another machine with only the newer versions?

[20:41] * ruoso thinking about distributors...

[20:41] <moritz_> rakudo: (my @s)[0] //= 0; say @s.perl

[20:41] <p6eval> rakudo de1e9f: OUTPUT«[0]␤»

[20:41] <moritz_> rakudo: (my @s)[0] //= 3; say @s.perl

[20:41] <p6eval> rakudo de1e9f: OUTPUT«[3]␤»

[20:41] <TimToady> then you make sure they know how to get the old version

[20:41] <TimToady> which you can unambiguously name, because it has an identity

[20:41] <ruoso> alright... 

[20:42] <TimToady> reconstituting some programs requires more work than other programs

[20:42] <japhb> ... sorta like reconstituting old versions out of version control.

[20:43] <TimToady> and, in fact, you could probably do pretty good compression from one version to another :)

[20:43] <DanielC> I'm having trouble with 'token' vs 'rule': http://pastebin.com/m1e6c0850  <--  This should parse '(name Daniel)' as a list, but it doesn't. :-(

[20:44] <DanielC> rule List { \( <Word>+ \) }  <--- "rule" means that it won't care about spaces, yes?

[20:44] <pmichaud> there's nothing there to match the space between "name" and "Daniel"

[20:45] <StephenPollei> so you won't have have a require foo>=3.2 version .. or symbol versioning in the libraries

[20:45] <DanielC> pmichaud: I thought that "rule" meant that I didn't need anything to match the space.

[20:45] <StephenPollei> it's always exact match?

[20:45] <pmichaud> DanielC: "rule" means that spaces in the rule definition correspond to spaces in the target

[20:45] <pmichaud> <Word>+  doesn't have any spaces

[20:46] *** molaf joined
[20:46] <pmichaud> rule List { \( <Word> <Word> \) }    would match in this instance

[20:46] <pmichaud> because there's a space between the two <Word>'s

[20:46] <pmichaud> you probably want

[20:46] <pmichaud> rule List { \( [ <Word> ]+ \) }

[20:46] <DanielC> pmichaud: But that doesn't require a space after ( an before ) ?

[20:47] <TimToady> bbl &

[20:47] <pmichaud> DanielC: depends on where you want to allow spaces and where they are forbidden

[20:47] <DanielC> Why is the space between <Word> and <Word> significant while the space between \( an <Word> is not?

[20:47] <pmichaud> the space between \( and <Word> is significant in a rule

[20:47] <pmichaud> it means that spaces can occur between the paren and the first word

[20:48] <DanielC> Oh... so in a rule a space means \s*  ?

[20:48] <pmichaud> actually it means <.ws>

[20:48] <DanielC> ok

[20:48] <DanielC> I think I finally understand.

[20:48] <pmichaud> which by default means "not in the middle of a word"

[20:49] <DanielC> I had been really confused about token vs rule, but I think I finally get it:  In a rule a space means <.ws>

[20:49] <pmichaud> rule List { \(<Word>\) }    matches  "(Daniel)"  but not "( Daniel )" or "(Daniel )"  or "( Daniel)"

[20:49] <pmichaud> rule List { \( <Word> \) }   would match all three

[20:49] <DanielC> Thanks.

[20:50] <DanielC> Thank you very much. This has been nagging me for ages.

[20:50] * DanielC tries

[20:51] <DanielC> weird

[20:51] <DanielC> rule List { \( [ <Word> ]+ \) }  <-- should work, right?

[20:53] <DanielC> token List { \( [ <.ws> <Word> <.ws> ]+ \) }  <-- Even this fails, so I must be missing something more fundamental.

[20:54] <DanielC> It's the parens.

[20:54] <DanielC> Something is wrong with \(  and \)

[20:55] <StephenPollei> also if they old library has a bug like a security flaw is there anyway to fix it and have it automaticly be used

[20:55] <DanielC> Maybe ( are considered a "word" because they match \S

[20:56] *** icwiener joined
[20:56] <DanielC> rakudo: if "(" ~~ / <-[(]> / { say "y" } else { say "n" }

[20:56] <p6eval> rakudo de1e9f: OUTPUT«n␤»

[20:57] <DanielC> rakudo: if "(" ~~ / <\S -[()]> / { say "y" } else { say "n" }

[20:57] <p6eval> rakudo de1e9f: OUTPUT«Statement not terminated properly at line 2, near "\\S -[()]> "␤in Main (src/gen_setting.pm:0)␤»

[20:57] <DanielC> hm

[20:58] * DanielC is trying to make a regex that matches non-space characters except for ( and )

[21:00] <DanielC> rakudo: if "(" ~~ / <-[()] -ws> / { say "y" } else { say "n" }

[21:00] <p6eval> rakudo de1e9f:  ( no output )

[21:00] <DanielC> rakudo: if "daniel" ~~ / <-[()] -ws> / { say "y" } else { say "n" }

[21:00] <p6eval> rakudo de1e9f: OUTPUT«y␤»

[21:00] <DanielC> rakudo: if "( )" ~~ / <-[()] -ws> / { say "y" } else { say "n" }

[21:00] <p6eval> rakudo de1e9f: OUTPUT«n␤»

[21:01] <DanielC> rakudo: if "()" ~~ / <-[()] -ws> / { say "y" } else { say "n" }

[21:02] <p6eval> rakudo de1e9f: OUTPUT«n␤»

[21:02] <DanielC> rakudo: if "(" ~~ / <-[()] -ws> / { say "y" } else { say "n" }

[21:02] <p6eval> rakudo de1e9f: OUTPUT«n␤»

[21:02] <DanielC> I wonder why it was "no output" before.

[21:03] <japhb> rakudo: my @code = {"Hello, $^a"}, {"Goodbye, $^a"}; @code[0]("World").say

[21:03] <p6eval> rakudo de1e9f: OUTPUT«Hello, World␤»

[21:03] <japhb> rakudo: my @code = {"Hello, $^a"}, {"Goodbye, $^a"}; @code>>.("World").say

[21:03] <p6eval> rakudo de1e9f: OUTPUT«_block50_block61␤»

[21:03] <japhb> How do I make that second one work?

[21:05] *** ruoso left
[21:06] *** molaf left
[21:12] *** payload left
[21:12] <DanielC> rakudo: if "(name" ~~ /<-ws>/ { $/.perl.say } else { say "no match" }

[21:12] <p6eval> rakudo de1e9f: OUTPUT«Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ ast  => "a",␤ Str => "a",␤ from => 2,␤ to   => 3,␤)␤»

[21:13] <DanielC> This can't be right.

[21:13] <DanielC> It is matching the "a", not the "n"

[21:13] <DanielC> or the "(" actually

[21:13] <DanielC> <ws> means whitespace, so the first non-whitespace character is "("

[21:13] <DanielC> no?

[21:14] <DanielC> rakudo: if "(name" ~~ /^ <-ws>/ { $/.perl.say } else { say "no match" }

[21:14] <p6eval> rakudo de1e9f: OUTPUT«no match␤»

[21:14] <DanielC> :-P

[21:14] <StephenPollei> rakudo: if "(name" ~~ /^<-ws>/ { $/.perl.say } else { say "no match" }

[21:14] <p6eval> rakudo de1e9f: OUTPUT«no match␤»

[21:15] <StephenPollei> rakudo: if "(name" ~~ /^<[\(a..z]>/ { $/.perl.say } else { say "no match" }

[21:15] <p6eval> rakudo de1e9f: OUTPUT«Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ ast  => "(",␤ Str => "(",␤ from => 0,␤ to   => 1,␤)␤»

[21:16] <pmichaud> I'm not sure what you would expect <-ws> to match.

[21:16] <DanielC> Same as \S

[21:17] <pmichaud> but <ws> isn't the same as \s

[21:17] <DanielC> Ultimately I want to match characters that are not parens or spaces.

[21:17] <DanielC> <-[()] -???>

[21:18] <DanielC> I nee to figure out what to put in ???

[21:18] <StephenPollei> rakudo: if "(name" ~~ /^<a..z]>/ { $/.perl.say } else { say "no match" }

[21:18] <pmichaud> rakudo:  say "(  name" ~~ /<-[()] -space>/

[21:18] <DanielC> ah, thanks.

[21:18] <p6eval> rakudo de1e9f: OUTPUT«Statement not terminated properly at line 2, near "a..z]>/ { "␤in Main (src/gen_setting.pm:0)␤»

[21:18] <p6eval> rakudo de1e9f: OUTPUT«n␤»

[21:18] <pmichaud> I think <space> might be deprecated, though.

[21:19] <DanielC> :(

[21:19] <DanielC> What's the replacement?

[21:19] <pmichaud> no, it's not deprecated.

[21:19] <DanielC> I hope it doesn't go away because it works

[21:19] <pmichaud> <space> is the same as \s

[21:19] <DanielC> ah!

[21:19] <DanielC> good

[21:20] <DanielC> Ah... wonderful. I'm finally making progress with my grammar.

[21:20] * DanielC is making a LISP grammar.

[21:20] <StephenPollei> rakudo: if "(name" ~~ /^[<a..z]>/ { $/.perl.say } else { say "no match" }

[21:20] <p6eval> rakudo de1e9f: OUTPUT«Syntax error at line 2, near "]>/ { $/.p"␤in Main (src/gen_setting.pm:0)␤»

[21:21] <pmichaud> transpose [ and <

[21:21] <StephenPollei> rakudo: if "(name" ~~ /^<[<a..z]>/ { $/.perl.say } else { say "no match" }

[21:21] <p6eval> rakudo de1e9f: OUTPUT«no match␤»

[21:21] <StephenPollei> rakudo: if "(name" ~~ /<[<a..z]>/ { $/.perl.say } else { say "no match" }

[21:21] <p6eval> rakudo de1e9f: OUTPUT«Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ ast  => "n",␤ Str => "n",␤ from => 1,␤ to   => 2,␤)␤»

[21:23] <DanielC> Yay! \o/  I have a LISP grammar.

[21:23] <StephenPollei> http://www.dwheeler.com/readable/

[21:24] <DanielC> *click*

[21:25] *** rosch joined
[21:25] <DanielC> Honestly, I don't care. Lisp is readable enough for what I need, and much easier to parse.

[21:26] <StephenPollei> sure it's just something that some like, I didn't know if you wanted something more to test your  perl6 grammar stuff on

[21:26] <DanielC> ah, thanks

[21:27] *** rosch left
[21:29] <DanielC> Is it a rule that a lisp expression has to start with a token? Is this valid?:  ((foo bar)) ?

[21:30] <DanielC> The outer list does not start with a token. It just contains a list.

[21:37] <justatheory> StephenPollei: Us David Wheelers are insane. Pay no mind!

[21:38] <justatheory> See also http://xkcd.com/224/

[21:51] *** Whiteknight joined
[21:52] <StephenPollei> justatheory, you are a wheeler as well? I don't know many here well

[21:52] <justatheory> I'm a *David* Wheeler, in fact. :-)

[21:52] <justatheory> Just not the dwheeler.com David Wheeler.

[21:54] <StephenPollei> http://paulgraham.com/avg.html read this about lisp just the other day.. but don't want to get into language flame wars

[21:54] <justatheory> What else is there to do on the Internet?

[21:56] *** rewt left
[21:57] <StephenPollei> tons of stuff but to enumerate would surely be OT besides if I get some other stuff done I might write a few more things for t/spec

[21:57] <justatheory> :-)

[22:01] *** rewt joined
[22:04] *** pmurias left
[22:25] *** nihiliad left
[22:29] *** alester left
[22:35] *** hanekomu left
[22:35] *** clintongormley left
[22:36] *** sri_kraih_ left
[22:36] *** sri_kraih joined
[22:56] *** rindolf left
[23:01] *** Sunbeam joined
[23:13] *** Roxas left
[23:15] *** M_o_C joined
[23:19] *** amoc^sleep is now known as amoc

[23:20] *** donaldh left
[23:20] *** donaldh joined
[23:22] *** sri_kraih left
[23:23] <sjohnson> can anyone explain to me in plain english, how the &function(); syntax differs from function; ?

[23:23] <sjohnson> i have looked everywhere, read the camel book 5 times, and still cannot understand this in simple terms that my peanut brain can understand

[23:25] <DanielC> It doesn't.

[23:25] <DanielC> AFAIK

[23:26] <DanielC> rakudo: sub foo { say "hi" }; &foo(); foo();

[23:26] <p6eval> rakudo de1e9f: OUTPUT«hi␤hi␤»

[23:26] <sjohnson> i use it cause it looks nicer in my VIM perl syntax colouring

[23:26] <sjohnson>  rakudo: sub foo { say "hi" }; &foo(); foo;

[23:26] <p6eval> rakudo de1e9f: OUTPUT«hi␤hi␤»

[23:26] <japhb> sjohnson: Are you talking about the Perl 5  difference?

[23:26] <sjohnson> yes

[23:26] <DanielC> rakudo: sub foo { say "hi" }; &foo(); foo(); foo

[23:26] <p6eval> rakudo de1e9f: OUTPUT«hi␤hi␤hi␤»

[23:27] <sjohnson> i am wondering if i keep programming like the above rakudo example... if it will bite me in the ass

[23:27] <sjohnson> if i'm doing something really complicated

[23:27] <japhb> Ah.  &foo carries caller's @_ along, as I recall.  Been a while.

[23:27] *** frew left
[23:27] <sjohnson> will the real TimToady please stand up? :)

[23:27] <japhb> And goto &foo is a tail call of sorts.

[23:27] <sjohnson> japhb: thanks.. i will have to "read up"

[23:28] <DanielC> rakudo: sub foo { say "hi" }; &foo(); foo(); &foo; foo;

[23:28] <p6eval> rakudo de1e9f: OUTPUT«hi␤hi␤hi␤»

[23:28] <DanielC> hm

[23:29] <DanielC> rakudo: sub foo { say "hi" }; &foo;

[23:29] <p6eval> rakudo de1e9f:  ( no output )

[23:29] <DanielC> I wonder if that's correct.

[23:29] <japhb> DanielC: remember, in Perl 6, &foo by itself just returns the coderef

[23:29] <sjohnson> well, i know Mr. Wall said that perl 6 is different

[23:29] <DanielC> japhb: So () means "run me" ?

[23:29] <japhb> Code or Routine or whatever the heck the base type is now.

[23:30] <sjohnson> i shuold be asking on a perl5 chan, but you guys are just so goshdarn helpful, too

[23:30] <japhb> DanielC: yup.

[23:30] <japhb> "invoke"

[23:30] <japhb> sjohnson: we try.

[23:30] <DanielC> japhb: But plain foo works...

[23:31] <DanielC> Then again, foo is the real function and not a reference, based on what you said.

[23:31] <japhb> &foo is (in my mind) special cased.  STD may say that the other forms are the real special cases.  But that's the one I think of as different.

[23:31] <DanielC> But I didn't think that &foo was a reference. I thought it was the real thing.

[23:31] <japhb> DanielC: it *is* the real thing.

[23:31] *** LCamel joined
[23:31] *** icwiener left
[23:31] <japhb> But by including the sigil, you're telling it you want the Code object back, not to *call* the Code.

[23:32] <DanielC> yeah but &foo()

[23:32] <DanielC> A slight ambiguity there, by your description.

[23:33] <japhb> &foo is the real code. &foo() says "call the real code", which is the same as "foo()".  "&foo" is simply the name of the real code, and doesn't say to do anything with it.

[23:33] <japhb> rakudo: foo { say "Hello" }; bar($code) { $code() }; bar(&foo); 

[23:34] <p6eval> rakudo de1e9f: OUTPUT«Statement not terminated properly at line 2, near "{ $code() "␤in Main (src/gen_setting.pm:0)␤»

[23:34] <japhb> rakudo: foo { say "Hello"; }; bar ($code) { $code(); }; bar(&foo); 

[23:34] <DanielC> I still think that there is some inconsistency. Either "&foo" should run or "foo" should not (pick one).

[23:34] <p6eval> rakudo de1e9f: OUTPUT«Statement not terminated properly at line 2, near "{ $code();"␤in Main (src/gen_setting.pm:0)␤»

[23:34] <japhb> oh heh.

[23:34] <japhb> rakudo: sub foo { say "Hello"; }; sub bar ($code) { $code(); }; bar(&foo); 

[23:34] <p6eval> rakudo de1e9f: OUTPUT«Hello␤»

[23:34] <japhb> there

[23:34] <DanielC> rakudo: sub foo { say "Hello"; }; sub bar (&code) { code(); }; bar(&foo)

[23:35] <p6eval> rakudo de1e9f: OUTPUT«Hello␤»

[23:35] <japhb> DanielC: "foo" is using it as a listop or so.

[23:35] <DanielC> even better :-)

[23:35] <DanielC> rakudo: sub foo { say "Hello"; }; sub bar (code) { code(); }; bar(&foo)

[23:35] <p6eval> rakudo de1e9f: OUTPUT«Malformed routine definition at line 2, near "bar (code)"␤in Main (src/gen_setting.pm:0)␤»

[23:35] <DanielC> I guess that was too much to hope for.

[23:35] <japhb> DanielC: I was simply pointing out that the change of sigil from call point to signature didn't matter.  Only the fact that at the call you asked to hand it the real object

[23:36] <DanielC> ok

[23:36] <japhb> Although, technically my example was ambiguous

[23:36] <japhb> rakudo: sub foo { "Hello"; }; sub bar ($code) { say $code(); }; bar(&foo); 

[23:36] <p6eval> rakudo de1e9f: OUTPUT«Hello␤»

[23:37] <japhb> dammit.

[23:37] <DanielC> I just think that if "&foo()" and "foo()" do the same thing then "&foo" and "foo" should do the same thing too (whatever that might be).

[23:37] <japhb> oh

[23:37] <DanielC> You see what I mean?

[23:37] <japhb> rakudo: sub foo($who) { "Hello, $who"; }; sub bar ($code) { say $code("World"); }; bar(&foo); 

[23:37] <p6eval> rakudo de1e9f: OUTPUT«Hello, World␤»

[23:37] <japhb> There!

[23:38] <japhb> That disambiguates the call order.

[23:38] *** LCamel left
[23:39] <japhb> I understand what you mean.  I happen to disagree -- I think that's mistaken orthogonality.  Perl dimensions often go off at odd angles.  :-)

[23:39] <DanielC> :-)

[23:40] <DanielC> I think orthogonality is a good property. It makes the language more predictable.

[23:40] <DanielC> One of the things I love about Perl 6 is its increased orthogonality and predictability. There are a lot fewer special cases.

[23:41] <japhb> Fair enough.

[23:41] <japhb> I've just accepted this particular waterbed lump, I guess. :-)

[23:42] <DanielC> Yeah. This is the sort of thing one just has to accept.

[23:45] *** justatheory left
[23:47] <pugs_svn> r27073 | lwall++ | [Containers] define .rotate more like a PDL slice, rely on other ops for exact semantics

[23:52] <TimToady> verb phrases work differently from noun phrases in most languages

[23:53] <TimToady> leaving off the noun marker puts you into verb-phrase land

[23:53] <TimToady> and makes listops possible

[23:53] <TimToady> otherwise you can't know whether to expect a term or an operator after "foo"

[23:54] <TimToady> and that's fundamental to everything Perl does

[23:54] <japhb> Man, I really need to start remembering to explain things linguistically ....

[23:54] <TimToady> Perl knows that &foo has no arguments, and that foo might

[23:55] <TimToady> (syntactic arguments)

[23:55] <TimToady> the &foo object responds to .() of course

[23:56] *** Muixirt left
[23:56] <japhb> Which brings me back to my question from earlier:

[23:56] <japhb> rakudo: my @code = {"Hello, $^a"}, {"Goodbye, $^a"}; @code[0]("World").say

[23:56] <p6eval> rakudo de1e9f: OUTPUT«Hello, World␤»

[23:56] <japhb> rakudo: my @code = {"Hello, $^a"}, {"Goodbye, $^a"}; @code>>.("World").say

[23:56] <p6eval> rakudo de1e9f: OUTPUT«_block50_block61␤»

[23:56] <viklund> if foo is a multi, then I should be able to get a Perl6MultiSub object with &foo, right?

[23:57] <japhb> What am I saying wrong in the second example above?

[23:57] <TimToady> that's the intent, but rakudo doesn't implement it yet

[23:57] <viklund> Is there (or will there be) anyway of declaring an anonymous multi?

[23:57] <TimToady> &foo is the abstraction for "what would happen if I called foo() right here"

[23:57] <viklund> yes, I know I won't get it in rakudo yes...

[23:57] <viklund> *yet

[23:58] <TimToady> japhb: nothing, looks like a bug to me

[23:59] <japhb> AH!  OK.  I was going insane trying to wave chickens over that gumbo.

[23:59] <TimToady> oh, wait

[23:59] <TimToady> you need >>.say to

[23:59] <TimToady> *too

[23:59] <TimToady> rakudo: my @code = {"Hello, $^a"}, {"Goodbye, $^a"}; @code>>.("World")>>.say

[23:59] <p6eval> rakudo de1e9f: OUTPUT«_block50␤_block61␤»

[23:59] <TimToady> but still buggy

[23:59] <japhb> TimToady: only if I want them on separate lines.

[23:59] <TimToady> right

[23:59] <japhb> but yes, that was a thinko.

[23:59] <TimToady> should work without

