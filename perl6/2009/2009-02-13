[00:03] *** Tene_ left
[00:04] *** meppl left
[00:07] *** icwiener joined
[00:08] *** DemoFreak left
[00:13] *** hanekomu_ left
[00:21] *** AzureStone joined
[00:27] *** icwiener left
[00:40] *** skids joined
[00:56] *** blackxxxer joined
[00:56] <blackxxxer> is anyone active in here?

[00:58] *** blackxxxer left
[01:04] *** s1n1 joined
[01:04] *** s1n1 left
[01:06] *** alc joined
[01:07] *** wknight8111 joined
[01:22] *** shinobi-cl joined
[01:24] *** shinobi-cl left
[01:51] *** wknight8111 left
[01:55] *** eternaleye joined
[02:00] *** alester joined
[02:01] <alester> evening all

[02:01] <alester> Tomorrow starts The Great Rakudo.org Overhaul

[02:03] <mikehh> and pray tell what does that do?

[02:06] <alester> Gives us a new rakudo.org

[02:07] <mikehh> Ah?

[02:21] *** frew joined
[02:23] *** c9s_mv joined
[02:51] *** PZt joined
[02:55] *** justatheory left
[03:03] *** eternaleye left
[03:06] *** icwiener joined
[03:08] *** eternaleye joined
[03:14] *** Limbic_Region left
[03:33] *** ab5tract joined
[03:37] *** eternaleye left
[03:51] *** alester left
[03:51] *** eternaleye joined
[04:21] *** eternaleye left
[04:33] *** eternaleye joined
[04:34] *** frew left
[04:34] *** frew joined
[04:35] <frew> perl6: sub foo($bar) { $bar }

[04:35] <p6eval> pugs: No output (you need to produce output to STDOUT)

[04:35] <p6eval> ..rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[04:35] <p6eval> ..elf 25313: RESULTÂ«undefâ¤Â»

[04:36] <frew> perl6: sub foo($bar) { say $bar }; foo('bar')

[04:36] <p6eval> pugs: No output (you need to produce output to STDOUT)

[04:36] <p6eval> ..rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[04:36] <p6eval> ..elf 25313: OUTPUTÂ«barâ¤Â»

[04:36] <frew> perl6: sub foo (Scalar $bar) { say $bar }; foo('bar')

[04:36] <p6eval> pugs: No output (you need to produce output to STDOUT)

[04:36] <p6eval> ..rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[04:36] <p6eval> ..elf 25313: OUTPUTÂ«barâ¤Â»

[04:38] <frew> anyone here know of a good resource to learn about how to do stuff with method attributes in perl5?

[04:38] <frew> I am trying to read the source of CAP::AutoRunMode, but it's got a lot of deep magic...

[04:42] *** eternaleye_ joined
[04:42] *** eternaleye left
[04:42] *** iblechbot joined
[05:10] *** iblechbot left
[05:19] *** jhuni joined
[05:20] *** frew left
[05:37] *** Tene_ joined
[05:41] *** ab5tract left
[05:43] *** justatheory joined
[05:48] *** Tene left
[05:58] *** jhuni left
[06:18] *** justatheory left
[06:21] *** kanru joined
[06:23] *** wilx left
[06:41] *** araujo left
[06:53] *** ashizawa joined
[07:09] *** icwiener left
[07:12] *** DemoFreak joined
[07:12] *** stephenlb left
[07:18] *** spooneybarger joined
[07:24] <c9s_mv> perl6: sub foo ( Scalar $bar ) { say $bar }; foo('bar');

[07:24] <p6eval> pugs: No output (you need to produce output to STDOUT)

[07:24] <p6eval> ..rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[07:24] <p6eval> ..elf 25313: OUTPUTÂ«barâ¤Â»

[07:35] *** kate21de joined
[07:45] *** iblechbot joined
[08:04] *** [particle] joined
[08:21] *** [particle]1 left
[08:23] *** M_o_C joined
[08:24] *** AzureStone_ joined
[08:27] *** AzureStone left
[08:27] *** jan_ left
[08:27] *** drbean_ left
[08:27] *** SamB left
[08:27] *** jeremiah left
[08:27] *** mdxi left
[08:27] *** zev left
[08:27] *** Cyrus left
[08:27] *** Helios left
[08:27] *** dmpk2k left
[08:27] *** go|dfish left
[08:27] *** awwaiid left
[08:27] *** jjore left
[08:27] *** nipotan left
[08:27] *** Cyrus___ joined
[08:28] *** AzureStone joined
[08:28] *** jan_ joined
[08:28] *** drbean_ joined
[08:28] *** SamB joined
[08:28] *** jeremiah joined
[08:28] *** go|dfish joined
[08:28] *** Helios joined
[08:28] *** mdxi joined
[08:28] *** dmpk2k joined
[08:28] *** nipotan joined
[08:28] *** zev joined
[08:28] *** awwaiid joined
[08:28] *** jjore joined
[08:30] *** AzureStone left
[08:33] *** ejs joined
[08:42] *** riffraff joined
[08:43] <riffraff> hi

[08:44] <moritz_> hi riffraff 

[08:47] *** mberends left
[08:50] *** ludan joined
[08:53] *** hanekomu joined
[08:55] <bacek> hi there

[08:57] <moritz_> rakudo: 1629 / 60

[08:57] <p6eval> rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[08:57] <moritz_> elf: 1629 / 60

[08:57] <p6eval> elf 25313: RESULTÂ«27.15â¤Â»

[08:58] <bacek> ouch.

[09:10] *** elmex left
[09:10] *** elmex joined
[09:25] *** M_o_C left
[09:34] *** ejs left
[09:40] *** kate21de left
[10:05] *** ejs joined
[10:15] *** sri_kraih joined
[10:16] *** ejs1 joined
[10:23] *** go|dfish left
[10:25] *** ejs left
[10:25] <jnthn> morning all!

[10:25] <jnthn> Rakudo day it is.

[10:25] <moritz_> good morning jnthn 

[10:26] <moritz_> that's good news

[10:26] <jnthn> Aye, I didn't have one last week since I had someone visiting, plus was partly in Bulgaria. So, two this week. :-)

[10:29] <Matt-W> hurrah for Rakudo Day

[10:29] <Matt-W> I've just got Day of Three Meetings

[10:30] <Matt-W> But I should ask here as there are clever people who might know - Can anybody recommend any theoretical work on multithreaded programming?

[10:31] <moritz_> multithreaded, or concurrent in general?

[10:32] <Matt-W> well general might be useful, but I'm particularly focussed on the kind of thing you can do with POSIX or Windows threads (this is for work)

[10:32] <moritz_> sorry, can't help you with that

[10:33] <Matt-W> no problem, I'm sure I can find something

[10:33] <jnthn> Most of what I know - but it's not really detailed stuff in terms of implementation, but rather best practices - I put in a talk I gave a while ago...

[10:33] <Matt-W> jnthn: that could still be useful

[10:34] <Matt-W> Anything that can help me avoid making more thread soup

[10:34] <jnthn> The best thing about the talk is that the first slide contains pictures of yaks.

[10:34] <jnthn> Ah, here: http://www.jnthn.net/papers/2007-fpw-parallelism-slides.pdf

[10:35] *** M_o_C joined
[10:36] <Matt-W> If pictures of yaks are your highlight, does that really recommend it?

[10:38] <jnthn> It's a really good photo.

[10:38] <jnthn> ;-)

[10:39] *** Ehtyar left
[10:39] <Matt-W> heh it is nice

[10:39] <jnthn> Tibet FTW.

[10:40] <jeremiah> Yaks FTW

[10:40] <jeremiah> "Parallel New World" <- Good title.

[10:44] <Matt-W> yaks ftw indeed

[10:44] <Matt-W> thread soup ftl

[10:45] <Matt-W> you try to eat it, but it keeps blocking on a guy in a restaurant in New Zealand's use of the pepper grinder

[10:48] <jeremiah> Mmmm soup.

[10:49] <jnthn> Mmmm. I haz Ukrainian train tickets ordered. :-)

[10:49] *** anatolybogatyrev joined
[10:52] *** sri_kraih left
[10:53] *** anatolybogatyrev is now known as Gangl

[10:53] <Gangl> Hi, how can i do in Perl6 like that in  Perl 5: "perl -ne 'print if (/^1[0-9]+ +K/)' list.txt"?

[10:55] <jnthn> For now I don't think - at least in Rakudo anyway - we have a -n or equivalent.

[10:55] <moritz_> Gangl: do you mean today in rakudo, or in general in Perl 6 once it's finished?

[10:56] <Gangl> in Rakudo

[10:57] <moritz_> I fear you have to open the file manually

[10:57] <moritz_> some something along these lines:

[10:58] <moritz_> for @*ARGV -> $f { my $h = open $f; for =$h { .say if m/1\d+ " "+K/ }}

[11:00] <Gangl> thanks

[11:01] <moritz_> note that spaces aren't significant in Perl 6 regexes, so /\d+ +/ won't work

[11:01] <jnthn> for use lines function?

[11:02] <moritz_> so you either have to quote the space, or use \s or something

[11:02] <jnthn> for @*ARGV -> $f { for lines($f) { ... } }

[11:02] <moritz_> rakudo: say lines('README')

[11:02] <p6eval> rakudo b2e7ac: OUTPUTÂ«./parrot: error while loading shared libraries: libparrot.so.0.9.0: cannot open shared object file: No such file or directoryâ¤Â»

[11:02] * moritz_ sighs

[11:03] <moritz_> such demonstrations are much more impressive when they work :/

[11:03] *** philsf joined
[11:07] <moritz_> rakudo: say lines('README')

[11:07] <p6eval> rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[11:11] <moritz_> anybody want to take over maintainance of p6eval? :/

[11:15] *** M_o_C left
[11:15] *** M_o_C joined
[11:30] *** alc left
[11:37] *** alexn_org joined
[11:40] *** Gangl left
[11:42] *** kane_ joined
[11:48] *** pmurias joined
[11:50] *** meppl joined
[11:52] *** araujo joined
[11:57] <jnthn> In the smartmatch table we have:

[11:57] <jnthn>     Any       .foo      method truth            ?X       i.e. ?.foo

[11:58] <jnthn> If we do $x ~~ .foo, is that basically like ?$x.foo or ?$_.foo ?

[11:58] *** kane__ left
[11:59] <jnthn> The top of the table reads 

[11:59] <jnthn>     $_        X         Type of Match Implied   Match if (given $_)

[11:59] <jnthn> Which leads me to think that we take $_ to be the LHS of the smartmatch

[11:59] <jnthn> Rather than whatever $_ is.

[11:59] <jnthn> And ignoring the LHS, which would seem odd.

[11:59] <jnthn> Thoughts?

[11:59] <Matt-W> I've never quite understood that smartmatch table

[12:00] <Matt-W> and surely we can't be ignoring the LHS, if it implies that then I really really hope it's wrong

[12:00] <jnthn> (Masak seemed to think we would "irrelavent" ~~ .foo would not call .foo on "irrelavent" but whatever was in $_.)

[12:00] <Matt-W> hmm

[12:00] <jnthn> But I'm thinking...huh...why'd we do that...

[12:00] <Matt-W> I would immediately suspect that it calls $_.foo and smartmatches the result of that against the LHS of ~~

[12:00] <jnthn> In a given...when then $_ *is* the LHS.

[12:01] *** alexn_org left
[12:01] <Matt-W> but in a given...when, you'd want when .foo { } to be $_.foo == true and do { }

[12:01] <jnthn> If it did that it wouldn't be a special syntactic form.

[12:02] <Matt-W> hmmmm

[12:02] <jnthn> I think the spec must mean $x ~~ .meth is the same as ?$x.meth

[12:02] <Matt-W> that would be consistent

[12:02] <jnthn> It seems strange spec'ing a construct that ignores the LHS!

[12:02] <Matt-W> yes

[12:03] <Matt-W> what I suggested would be horrible, in hindsight

[12:03] <jnthn> Of course, in a when .meth { } then you *would* get a call on $_ thanks to the when

[12:03] <Matt-W> well, maybe

[12:03] <Matt-W> yes but that's only because when is like if ($_ ~~ <blah>) { }

[12:03] <Matt-W> so no special tricks

[12:03] <jnthn> Yes.

[12:04] *** jan_ left
[12:04] <Matt-W> I do sometimes get confused as to what saying ".meth" will do in any given place

[12:05] <jnthn> That implies maybe that when has to be aware of the special syntactic forms, though?

[12:05] *** jan_ joined
[12:06] <Matt-W> hmm

[12:06] <jnthn> rakudo: given 42 { when .sign { say "yes" } }

[12:06] <p6eval> rakudo b2e7ac: OUTPUTÂ«./parrot: error while loading shared libraries: libparrot.so.0.9.0: cannot open shared object file: No such file or directoryâ¤Â»

[12:06] <Matt-W> damn

[12:06] <Matt-W> that's really inconvenient

[12:06] *** pmurias left
[12:07] <jnthn> Like, I suspect

[12:07] <jnthn> given "hai" { when .chars { say "yes" } }

[12:07] <jnthn> That should say "yes"

[12:07] <jnthn> Because $_.chars is 3, which is true in boolean context

[12:07] <Matt-W> because "hai".chars is true

[12:07] <jnthn> But in Rakudo at the moment, it doesn't.

[12:07] <Matt-W> that is exactly what I'd expect to happen

[12:07] <Matt-W> what does it do?

[12:08] <jnthn> Invokes .chars and then smart-matches 3 against the string "hai" ("hai" as the LHS)!

[12:08] <jnthn> Which is what I mean by, when having to know about these things too.

[12:08] <Matt-W> ouch

[12:09] <Matt-W> see I'm still sort of thinking that $x ~~ .chars should do $_.chars and smartmatch the result against $x

[12:09] <jnthn> Well, that's what it's doing there.

[12:09] <Matt-W> but as you say, when you apply that to given...when it looks wrong

[12:09] <Matt-W> I hate these things you can argue either way

[12:09] <jnthn> Right. My first reading of the smart-match table was that it should do $x.chars rather than $_.chars.ACCEPTS($x)

[12:10] <jnthn> Well, ?$x.chars

[12:10] <jnthn> Where $x here is the LHS.

[12:11] <Matt-W> but if it behaves like that, you can't use given...when to do quick checks against predicate methods on an object

[12:12] *** BinGOs left
[12:12] <jnthn> You can, because the LHS of ~~ is $_

[12:12] <jnthn> given "hai" { when .chars { say "yes" } }

[12:12] <jnthn> Here, when .chars will do ?$_.chars and if it's true run the block.

[12:13] <jnthn> I think this is what's intended - so you *can* do predicate checks.

[12:13] <Matt-W> mmm

[12:13] <Matt-W> it makes sense there

[12:14] <Matt-W> what if you say $_ = "hai"; say "yes" if $_ ~~ .chars;

[12:15] *** BinGOs joined
[12:15] <jnthn> It would call $_.chars

[12:15] <jnthn> Aha

[12:15] <Matt-W> so $_.chars.ACCEPTS($_)

[12:15] <jnthn> You must be able to do predicate tests with when like that because S03 explicitly gives an example.

[12:15] <jnthn>     given $boolean {

[12:15] <jnthn>         when .true {...}

[12:15] <jnthn>         when .not  {...}

[12:15] <jnthn>     }

[12:16] <jnthn> There we clearly want the block to run if ?$_.ture rather than if $_ ~~ $_.true

[12:16] <Matt-W> so do we have a difference in behaviour between when and ~~

[12:16] *** masak joined
[12:16] <jnthn> No

[12:16] <jnthn> I'm just saying when needs to know that the .foo form is special too.

[12:16] <jnthn> Ah, here's the trouble-causer who filed the initial ticket. ;-)

[12:17] <Matt-W> I'm confused

[12:18] <masak> jnthn: good day. :)

[12:18] <lambdabot> masak: You have 1 new message. '/msg lambdabot @messages' to read it.

[12:18] <masak> @massage

[12:18] <lambdabot> moritz_ said 13h 42m 23s ago: I've changed the evalbot setup a bit; parrot and rakudo are built in ~/parrot and is rsync'ed to ~/built-parrot if successful

[12:18] <jnthn> masak: We're discussing http://rt.perl.org/rt3/Public/Bug/Display.html?id=60258

[12:18] <masak> oh, nice.

[12:18] <jnthn> masak: Yes, but I think your expectations in the ticket are wrong.

[12:19] <jnthn> (But Rakudo at present is *also* wrong.)

[12:19] <masak> :)

[12:19] <jnthn> class A { method alwaystrue { return 1 } }; given A.new {

[12:19] <jnthn> say "irrelevant" ~~ .alwaystrue }

[12:19] <masak> my expectations were based on S03, it seems.

[12:19] <masak> are you saying I read S03 wrong? or that S03 is wrong?

[12:19] <jnthn> I think we understand S03 differently. ;-)

[12:19] <masak> ah.

[12:19] <masak> the intricacies of interpretation. :)

[12:20] <Matt-W> I've lost track of what jnthn is advocating to be correct

[12:20] <jnthn> So the result Rakudo gives is certainly wrong.

[12:20] <jnthn> At the moment.

[12:20] * masak backlogs

[12:20] <jnthn> Because it calls .alwaystrue on $_ and then smart-matches what that returns against "irrelevant"

[12:21] <jnthn> However, I think that what it should be doing is ?("irrelevant".alwaystrue)

[12:21] <masak> (I agree, yaks FTW)

[12:22] <jnthn> Rather than ignoring the LHS (why would an operator do that?) and calling $_.alwaystrue

[12:22] <jnthn> Notice that if we take that definition, then in a given/when block, the LHS *is* $_ so this definition still gives what you want.

[12:22] <Matt-W> the trouble is that it looks like you mean "irrelevant" ~~ $_.alwaystrue

[12:23] <jnthn> Matt-W: Right, but S03 seems to say otherwise.

[12:23] <jnthn> Plus if that's true, then the following cannot work:

[12:23] <jnthn>     given $boolean {

[12:23] <jnthn>         when .true {...}

[12:23] <jnthn>         when .not  {...}

[12:23] <jnthn>     }

[12:23] <Matt-W> so it means you have to remember that the RHS of ~~ has a sort-of-topic of the LHS

[12:23] <Matt-W> I agree that it needs to work in when, I just hate what it ends up looking like in the ~~ form

[12:24] <jnthn> That's exactly what I'm thinking it means.

[12:24] <Matt-W> and I'm going to hope that nobody ever, ever does that

[12:24] <Matt-W> ever

[12:24] <Matt-W> because it will be misread

[12:24] <jnthn> Aye, I see what you're getting at.

[12:24] <jnthn> But, since they'd probably write $lhs.foo rather than $lhs ~~ .foo anyway...

[12:25] <Matt-W> but avoiding that would destroy the equivalence between when and ~~

[12:25] <Matt-W> and yes, they probably will

[12:25] <Matt-W> especially if they don't want me to come and throw rotten tomatoes at them

[12:25] <Matt-W> I guess we have to allow the possibility for people to write horrible things to get the power to write lovely things :)

[12:26] <Matt-W> You've convinced me, and I'm now going to go and indulge my stomach's demands for something to digest

[12:26] <Matt-W> lunch &

[12:28] <masak> with great power comes great rotten tomatoes.

[12:29] *** cognominal left
[12:31] <jnthn> masak: Any concurrence with me on S03? ;-)

[12:31] <jnthn> (Disagreement is fine too, in which case we can ask The List.)

[12:35] <masak> I'm not giving the issue 100% attention right now...

[12:35] <masak> I'm in the middle of some translation work.

[12:36] <jnthn> OK, no worries. :-)

[12:36] <masak> I'll get back to you.

[12:36] *** iblechbot left
[12:36] <masak> in the meantime, maybe reply to the ticket and cc p6c?

[12:36] <jnthn> Will do

[12:37] <jnthn> In the meantime, I'll apply the patch that I think is right. But it does factor stuff into one place so it's going to be easy to change if the answer comes back different. And it's closer to right than what we do now.

[12:38] <masak> å¥½çš„. er, I mean, "good".

[12:38] <jnthn> Is "bra" really Swedish for "good"?

[12:38] <masak> aye, it really is.

[12:38] <masak> for being so small, it's quite an inflexible word.

[12:39] <jnthn> Same in English. ;-)

[12:39] <jnthn> (Of course, with it's English meaning...)

[12:39] <masak> the Swedish version is worse.

[12:39] <masak> there's no definite form, for one.

[12:39] <jnthn> Huffmanization doesn't always quite work.

[12:40] <masak> which makes people say things like 'den bra-iga boken'...

[12:40] <masak> ...which I suppose works, but it's not formal enough by far to appear in print.

[12:42] <moritz_> the problem in human language is that you don't only need huffmanization, but also redundancy for error corrections

[12:42] *** r0bby left
[12:43] <masak> moritz_: I'm thinking a lot about that these days.

[12:43] <masak> Mandarin has its redundancy in different places that the Indo-European langs.

[12:44] <masak> some would say the Mandarin system is objectively better. I'm not sure I agree, but I can certainly, um,  sympathize with that viewpoint.

[12:49] <dalek> rakudo: 19c0210 | jnthn++ | src/parser/grammar.pg:

[12:49] <dalek> rakudo: Add better error message for else blocks on unless - a copy/paste from STD.pm.

[12:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/19c0210d7cc13c64e02759112abb9ee62569a97f

[12:50] <dalek> rakudo: 74d73d9 | jnthn++ | src/parser/actions.pm:

[12:50] <dalek> rakudo: Refactor handling of smart-match so we can implement the special syntactic forms, and add the .foo special form.

[12:50] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/74d73d925fb45f229b1dc36616ff11c1485ac017

[12:50] *** kanru left
[12:50] <jnthn> moritz_: Is it still OK to assign you tickets that need tests?

[12:51] <jnthn> If you're snowed under, I can write them myself. (Don't need them right now...)

[12:52] *** meteorjay joined
[12:52] <moritz_> jnthn: it's OK, but it'll take some time these days

[12:55] <jnthn> moritz_: OK, done that, thanks.

[12:55] <jnthn> Also cc'd p6l into my response to the ticket.

[12:56] <jnthn> If it stays quiet or is confirmed correct, I'll do .[...] and .{...} etc in the near future too, since it'll be the same answer for those.

[13:13] *** timbunce joined
[13:20] *** skids left
[13:25] *** timbunce left
[13:25] *** ashizawa left
[13:29] *** kanru joined
[13:30] * Matt-W wishes he knew enough about Rakudo's innards to understand what jnthn++'s patch is doing

[13:30] <Matt-W> meeting &

[13:31] *** M_o_C left
[13:34] *** cognominal joined
[13:38] <pugs_svn> r25314 | jnthn++ | Add tests for is copy in use with arrays and hashes.

[13:38] <dalek> rakudo: 6059ad9 | jnthn++ | src/classes/Signature.pir:

[13:38] <dalek> rakudo: Fix is copy trait for arrays and hashes. Resolves RT#60966.

[13:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6059ad9ec5c3fb47f8c30b6ea1a276bad2cb653e

[13:39] <moritz_> jnthn: I hope you know that 'is copy' is also broken for scalars?

[13:39] <moritz_> (or at least was last I tried to ran man-or-boy.t)

[13:40] <jnthn> moritz_: No, though I ain't entirely surprised.

[13:40] <jnthn> Is there a smaller test case?

[13:41] <jnthn> moritz_: man or boy tests all pass here, it appears?

[13:41] <moritz_> jnthn: don't know...

[13:41] <jnthn> moritz_: Yup, passes here.

[13:41] <jnthn> Shall I add it back to spectest.data?

[13:42] <moritz_> jnthn: ah, that might have been your ++ and -- fix then

[13:42] <moritz_> jnthn: yes, please

[13:42] <moritz_> it was using ++ on a "is copy" parameter

[13:42] <moritz_> don't know which of them was broken

[13:42] <jnthn> Ah.

[13:42] <jnthn> Not sure.

[13:42] <jnthn> Anyway, it passes now.

[13:43] *** masak left
[13:43] <moritz_> each time I forget to 'make clean' in Rakudo, I get error:imcc:syntax error, unexpected VAR, expecting '(' ('sub')

[13:45] <dalek> rakudo: 3e1a5e8 | jnthn++ | t/spectest.data:

[13:45] <dalek> rakudo: integration/man-or-boy.t now passes again due to @recent_fix.pick, add it back to spectest.data.

[13:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3e1a5e84289baeb83f675da26b113b01b81ffc12

[13:47] *** braceta joined
[13:50] <moritz_> I've opened a ticket about that man-or-boy thingy, will try to find it

[13:51] <jnthn> Oh, to find which issue it was?

[13:51] <jnthn> OK

[13:51] <moritz_> to close it

[13:53] <jnthn> Oh, I see.

[13:54] <moritz_> http://rt.perl.org/rt3/Ticket/Display.html?id=61982 don't know if it's 100% closable, will investigate later today

[13:55] <jnthn> Looking at

[13:55] <jnthn>     $locator = method { self.<here> }

[13:55] <jnthn>     $obj.$locator            # $obj<here>

[13:55] <jnthn> Does this imply that the default topic in a method is $_ always?

[13:55] <jnthn> erm

[13:55] <jnthn> is self, I meant?

[13:55] <jnthn> S12 isn't too clear, or I can't find the bit that is clear on that...

[13:56] <moritz_> I think it used to be $_ === self, but that was abandoned

[13:56] <moritz_> jnthn: but I don't see where $_ is involved in your example above

[13:57] <jnthn> oh

[13:57] <jnthn> Yes

[13:57] <jnthn>     $locator = { .<here> }

[13:57] <jnthn>     $obj.$locator            # $obj<here>

[13:57] <jnthn> Oh, hmm

[13:57] <jnthn> The spec says these two.

[13:57] <moritz_> there { ... } just is a closure with one parameter

[13:57] <jnthn> masak tried method { .<here> }

[13:57] <moritz_> that's assigned to $_

[13:57] <moritz_> just like for 1..2 { .say }

[13:58] <jnthn> Right.

[13:58] <jnthn> But method { .<here> } isn't spec'd.

[13:58] <moritz_> ask TimToady, or reject it :-)

[13:59] <moritz_> rakudo: my $fh = open("README"); my $res = try { $fh.perl} ; say "alive"

[13:59] <p6eval> rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[14:00] <jnthn> @tell TimToady Do methods get self in $_ by default? Spec doesn't say so, so I'm guessing not - if that's the case, I get to reject a ticket. ;-)

[14:00] <lambdabot> Consider it noted.

[14:03] *** chid joined
[14:03] *** chid left
[14:07] *** Southen joined
[14:08] *** magnarjg left
[14:15] *** philsf left
[14:21] <jnthn> rakudo: my $x = {}; say $x.WHAT

[14:21] <p6eval> rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[14:33] *** skids joined
[14:35] <jnthn> std: class A { method x { say "OH HAI" } }; my $c = class is A {}; $c.x

[14:36] <p6eval> std 25314: OUTPUTÂ«############# PARSE FAILED #############â¤Malformed "class" declarationâ¤Unable to parse class definitionâ¤Malformed method definition at /tmp/iiLuS9F4Tb line 1:â¤------> [32mclass A { method x { say "OH HAI" }[31m }; my $c = class is A {}; $c.x[0mâ¤    expecting blockoidâ¤FAILED

[14:36] <p6eval> ..00...

[14:36] <jnthn> @tell TimToady Should anonymous classes be able to inherit from stuff? If so, can they do class is Foo { ... } - at the moment STD.pm parsefails that (takes is to be the name of the class...)

[14:36] <lambdabot> Consider it noted.

[14:51] <dalek> rakudo: 9a5c690 | jnthn++ | src/parser/actions.pm:

[14:51] <dalek> rakudo: Fix NULL PMC accesses in various cases where we have empty blocks. Resolves RT#61034.

[14:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9a5c690de87947ce3fa075e29045aae8dc8a23e6

[15:18] *** Tene joined
[15:25] *** alester joined
[15:31] *** Tene_ left
[15:44] *** hercynium joined
[15:46] *** M_o_C joined
[15:48] *** jan_ left
[15:52] *** jan_ joined
[15:53] <TimToady> jnthn: methods do not get $_ := self by default, but you can always declare ($_:) in the sig

[15:53] <lambdabot> TimToady: You have 2 new messages. '/msg lambdabot @messages' to read them.

[15:53] *** eternaleye_ left
[15:53] <TimToady> .foo is a special form in any smart match, like anything known to return boolean

[15:54] <TimToady> and ~~ actually topicalizes the left side, so the right side sees the left side as $_

[15:54] *** Exodist joined
[15:54] *** iblechbot joined
[15:55] <jnthn> TimToady: OK, I'll reject the ticket and remove the test that assume $_ := self

[15:56] <jnthn> TimToady: And thanks for the clarification on $x ~~ .foo being basicaly ?$x.foo (provided I understood correctly!)

[15:56] <TimToady> so "foo" ~~ .bar means ?{ .bar }("foo"), basically

[15:57] <jnthn> Oh?

[15:57] * jnthn is confused

[15:57] <TimToady> well, same as you wrote, but it really does bind $_

[15:57] <TimToady> or maybe { ?.bar } is more accurate

[15:58] <jnthn> Ah, I see

[15:58] <Matt-W> I don't :(

[15:58] <jnthn> I mis-parsed what was going on there.

[15:58] <TimToady> "foo" ~~ $_ eq "foo" is true

[15:58] <TimToady> or more explicitly "foo" ~~ ?($_ eq "foo") is true

[15:59] <TimToady> so it really has to set $_

[15:59] <TimToady> still thinking about class is, but that'll take coffee...

[15:59] <Matt-W> I get that $_ on the rhs is the lhs

[16:00] <Matt-W> I don't quite get what happens with .bar on the rhs

[16:00] <jnthn> TimToady: OK. One easier one maybe...

[16:00] <jnthn> say "foofoofoo".subst("foo", "bar", :x(4))

[16:00] <jnthn> It cannot do 4 replacements, but should the result be an exception, the original string, or a fail?

[16:00] <moritz_> or is the :x(4) just a limit?

[16:00] <moritz_> so it tries as many as possible, but at most 4?

[16:01] *** Gangl joined
[16:01] <jnthn> oh, found it in the spec

[16:02] <moritz_> I guess there are a lot of tests for that which I wrote while mis-understanding the spec :/

[16:02] <jnthn> moritz_: I'm still trying to grok the spec. ;-)

[16:03] <jnthn> except that the string is unchanged unless all four matches are found.

[16:04] <Matt-W> home &

[16:07] <ruoso> I wonder what is the difficulty rakudo is having with the binding operator...

[16:07] <ruoso> as pmichaud stated in a mail to p6l

[16:14] <TimToady> see discussion above

[16:15] <TimToady> .foo is considered 1-ary on right side of ~~, so is evaluated for truth

[16:15] *** justatheory joined
[16:19] <ruoso> TimToady, it looks like you were talking to me... but I can't see the relation between the above discussion and binding

[16:20] <jnthn> ruoso: I think it was to pmichaud, but discussion is over on parrot :-)

[16:22] *** Tene_ joined
[16:23] *** stephenlb joined
[16:25] <ruoso> jnthn, Ok, I'll assume that discussion didn't raise anything that could affect SMOP

[16:26] <jnthn> ruoso: It's about $x ~~.foo

[16:26] <jnthn> Not binding.

[16:26] <jnthn> :-)

[16:26] <ruoso> ah

[16:27] *** ludan left
[16:28] *** ejs1 left
[16:32] *** hanekomu_ joined
[16:34] *** Tene left
[16:35] <TimToady> we, except that ~~ implicitly binds $_

[16:39] *** rindolf joined
[16:44] <pmichaud> the problem with binding is that Parrot doesn't make it easy to pass containers around.

[16:44] <pmichaud> especially containers inside of aggregates

[16:45] *** hanekomu left
[16:45] <jnthn> pmichaud: I had to implement for doing that kinda thing in .Net a kinda array-element-referencey kinda PMC.

[16:46] <pmichaud> jnthn: yes, I'm thinking that we'll be doing it with proxies

[16:46] <pmichaud> the difficult thing is recognizing when we want a proxy and when we don't.

[16:47] <jnthn> Aye.

[16:47] <jnthn> It was easy in .Net. :-|

[16:48] <jnthn> pmichaud: Is the Rakudo spectests graph updates broken for now, since we moved to git?

[16:49] <pmichaud> jnthn: yes -- I have to update my scripts a bit.

[16:49] <jnthn> OK, no hurry.

[16:49] <jnthn> (On my part.)

[16:49] <pmichaud> git doesn't appear to have a convenient "get a copy of the repo as of date x/y/z" feature.

[16:49] <jnthn> Ouch.

[16:49] <TimToady> sounds like Parrot wants Captures, or something like that

[16:50] <pmichaud> even Captures (at least as I've been thinking of them) doesn't seem to quite solve the problem.

[16:55] <PerlJam> pm: upgrading to git 1.6.1 didn't help?

[16:58] <pugs_svn> r25315 | jnthn++ | [t/spec] Unfudge a couple of tests for Rakudo.

[16:58] <pugs_svn> r25316 | jnthn++ | [t/spec] Remove test that doesn't conform to The Spec.

[16:59] <dalek> rakudo: 01811bf | jnthn++ | src/builtins/any-str.pir:

[16:59] <dalek> rakudo: Fix :x($n) in subst where $n is greater than the number of matches we can do. Resolves RT#61204.

[16:59] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/01811bf2f21d1b4d03e2c493750bc9493704e84d

[17:01] *** nihiliad joined
[17:04] <jnthn> pmichaud: When do you think you'll have time to work on prelude stuff?

[17:09] <pmichaud> s/prelude/setting/

[17:09] <pmichaud> very soon.

[17:09] <pmichaud> probably this next week.

[17:10] <pmichaud> PerlJam: no, upgrading didn't help.

[17:12] <jnthn> pmichaud: OK, great!

[17:13] *** ejs joined
[17:19] *** Exodist left
[17:20] *** maerzhase1 joined
[17:24] *** Exodist joined
[17:27] *** icwiener joined
[17:36] <pugs_svn> r25317 | jnthn++ | [t/spec] Tests for smart-matching where we have a couple of *s following each other.

[17:36] <dalek> rakudo: daa2eea | jnthn++ | src/classes/List.pir:

[17:36] <dalek> rakudo: Fix Array smart-matching when two Whatevers were written one after the other. Resolves RT#61452.

[17:36] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/daa2eea66cbd353836cd0eaf3332daa231a9ee4d

[17:39] <jnthn> TimToady: In the smartmartching table we have:

[17:39] <jnthn>     Array     Array     arrays are comparable   $_ «===» X (dwims * wildcards!)

[17:39] <jnthn> and

[17:39] <jnthn>     Any       Array     lists are comparable    @$_ «===» X

[17:39] <jnthn> Should the second one also dwim?

[17:44] <TimToady> sure, it's exactly the same, just with a coercion to Array, so calls the same .ACCEPTS

[17:45] <TimToady> it's always rhs.ACCEPTS(lhs)

[17:46] <jnthn> OK, that simplifies things. :-)

[17:46] <TimToady> (modulo the special synactic forms)

[17:46] <TimToady> ((which this isn't one o'))

[17:46] *** pmurias joined
[17:54] <pugs_svn> r25318 | jnthn++ | [t/spec] Couple more smart-matching on array tests.

[17:54] <dalek> rakudo: f7b4b86 | jnthn++ | src/classes/List.pir:

[17:54] <dalek> rakudo: Correct smartmatching Array on RHS when LHS is non-array and we co-erce it; turns out it should DWIM too. Resolves RT#61454.

[17:54] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f7b4b86502e2d63edc513220535aad0f5b818d69

[17:54] <pmurias> ruoso: hi

[17:54] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[17:57] *** Exodist left
[17:57] <pmurias> ruoso: where should the lowlevel multi variants (&infix:<+>:(int,int)) and the like be defined?

[17:57] *** Exodist joined
[17:57] *** silug joined
[17:59] *** abra joined
[17:59] *** abra left
[18:00] *** abra joined
[18:14] *** riffraff left
[18:16] *** hanekomu_ left
[18:23] *** schmalbe joined
[18:37] *** Psyche^ joined
[18:50] *** Patterner left
[18:50] *** Psyche^ is now known as Patterner

[18:55] *** abra left
[19:02] <dalek> rakudo: 0f87695 | jnthn++ | src/parser/actions.pm:

[19:02] <dalek> rakudo: Improvements to subtypes: anonymous ones can now handle something to smart-match against rather than a block (resolves RT#61654) and enforce read-onlyness on the thing we're testing unless it's decalred otherwise (resolves RT#61776).

[19:02] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0f87695c0fc4f135d43e87f241bf26263c979018

[19:02] *** pmurias left
[19:02] <ruoso> pmichaud, in SMOP we're using the context of 'bvalue'

[19:03] <ruoso> @tell pmurias &infix:<+>:(int,int) could be defined in SMOP prelude directly

[19:03] <lambdabot> Consider it noted.

[19:03] <moritz_> jnthn: in git land it's common to use a short summary on the first line of the commit message, then one blank line, and then the rest of the message

[19:03] <ruoso> pmichaud, bvalue is a variable in a context where it can be used as the container or you can use it as item, which resolved the actual value

[19:04] <moritz_> jnthn: some tools show only the first line, so it's good to stick to that convention

[19:04] <jnthn> moritz_: Heh, I write all my -m stuff at the command line rather than having an editor configured. ;-)

[19:04] <ruoso> pmichaud, we use that to make hash subject to binding... so postcircumfix:<{ }> really returns only a bvalue, which will only do the actual lookup when that is used as an item

[19:05] <moritz_> jnthn: not a vim fanboy? ;-)

[19:05] <jnthn> Oddly, no. :-P

[19:05] <pugs_svn> r25319 | jnthn++ | [t/spec] Some more tests for subtypes, covering a couple of recently resolved RT tickets.

[19:07] <ruoso> pmichaud, but the bvalue implements BIND, which replaces the container in the target object

[19:08] <jnthn> OK, finally the Rakudo ticket queue is down to "only" 250 tickets.

[19:09] <moritz_> should $a ~~ .b($c) call $a.b($c) ?

[19:09] <ruoso> moritz_, actually, AFAICS, it should ($_ := $a).b($c)

[19:10] <moritz_> ruoso: for my test writing that's close enough ;-)

[19:11] <ruoso> but... does that affect $_ for the end of the scope? or just for the term in the rvalue of ~~

[19:11] <jnthn> ruoso: It shouldn't affect it to the end of the scope.

[19:11] <jnthn> A better re-write is { .b($c) }($a)

[19:11] <ruoso> yeah...

[19:12] <ruoso> sounds sane

[19:12] <ruoso> but, can that be understood sintatically?

[19:14] <jnthn> The $x ~~ .foo can be, which is what we need to re-write, I believe.

[19:14] <jnthn> (And I don't re-write and re-parse, I just make different AST.)

[19:14] <ruoso> good.. so no run-time magic... it's basically a macro...

[19:15] <jnthn> I need to tweak it to really look at syntax rather than AST though.

[19:15] <ruoso> jnthn, but indeed, I'm not sure it really needs to be a real macro... I think transforming the AST should be ok

[19:15] <jnthn> Aye.

[19:16] <jnthn> Well, I guess, whatever the compiler implementor finds easiest. ;-)

[19:17] <moritz_> jnthn: http://nopaste.snit.ch/15611 4 of these 6 tests fail...

[19:17] <moritz_> jnthn: did I do something very wrong?

[19:18] <jnthn> is ($t ~~ .b: 3),   15, '$obj ~~ .method: arg calls the method';

[19:18] <jnthn> That one I'm not sure would work yet...

[19:18] <jnthn> ooh

[19:19] <moritz_> but the first two also fail

[19:19] <jnthn> No, those tests are wrong.

[19:19] <jnthn>     Any       .foo      method truth            ?X       i.e. ?.foo

[19:19] <jnthn> So it puts it in boolean context

[19:19] <moritz_> ok

[19:19] <jnthn> So you can't test you get a certain return value, just true or false.

[19:22] <pugs_svn> r25320 | moritz++ | [t/spec] smartmatch tests for $obj ~~ .method (RT #60258)

[19:23] *** maerzhase1 left
[19:25] <jnthn> moritz++ :-)

[19:26] *** cognominal left
[19:26] * jnthn gives moritz another one

[19:26] *** ejs left
[19:30] <pugs_svn> r25321 | moritz++ | [t/spec] tests for RT #61034

[19:30] <jnthn> std: sub List::a {}

[19:30] <p6eval> std 25320: OUTPUTÂ«ok 00:02 33mâ¤Â»

[19:31] <jnthn> omg I didn't eat yet

[19:34] *** maerzhase joined
[19:34] <pugs_svn> r25322 | moritz++ | test for RT #62196, smartmatch in a class

[19:34] <moritz_> this commit added the 100th test to smartmatch.t ;-)

[19:37] *** cognominal joined
[19:37] <jnthn> Nice!

[19:37] <moritz_> jnthn: do you have slides on multi dispatch somewhere? I'd like to get some "inspiration" for an article that I write

[19:38] <jnthn> Sure

[19:38] <jnthn> http://www.jnthn.net/articles.shtml

[19:38] <jnthn> See talk slides Theres More Than One Way To Dispatch It

[19:38] <moritz_> thanks

[19:38] <jnthn> Wow. We're down to 246 tickets.

[19:39] <moritz_> jnthn++, tickets-- ;-)

[19:41] <moritz_> I like your paper/scissor/stone example

[19:45] <moritz_> are there other nice, simple problems that can be solved by multi dispatch?

[19:45] <moritz_> rakudo: multi f($x where 0) { 1 }; multi f($x) { X * f($x-1) }; say f(4)

[19:45] <p6eval> rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[19:48] <moritz_> rakudo: multi f($x where 0) { 1 }; multi f($x) { X * f($x-1) }; say f(4)

[19:48] <p6eval> rakudo b2e7ac: OUTPUTÂ«Statement not terminated properly at line 1, near "f($x-1) };"â¤â¤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)â¤Â»

[19:48] <moritz_> rakudo: multi f($x where 0) { 1 }; multi f($x) { $x * f($x-1) }; say f(4)

[19:48] <p6eval> rakudo b2e7ac: OUTPUTÂ«maximum recursion depth exceededâ¤current instr.: 'parrot;P6object;HOW' pc 54 (runtime/parrot/library/P6object.pir:96)â¤Â»

[19:48] <moritz_> rakudo: multi f($x where 0) { 1 }; multi f($x) { say $x; $x * f($x-1) }; say f(4)

[19:50] <moritz_> it works locally here

[19:51] <rodi> +/quit

[19:52] <rodi> oops, sorry :-\

[19:52] *** rodi left
[19:52] <jnthn> fail

[19:52] <moritz_> +/quit is "quit from as many servers as possible, but at least one" ;-)

[19:52] <p6eval> rakudo b2e7ac:

[19:52] <p6eval> ..OUTPUTÂ«4â¤3â¤2â¤1â¤0â¤-1â¤-2â¤-3â¤-4â¤-5â¤-6â¤-7â¤-8â¤-9â¤-10â¤-11â¤-12â¤-13â¤-14â¤-15â¤-16â¤-17â¤-18â¤-19â¤-20â¤-21â¤-22â¤-23â¤-24â¤-25â¤-26â¤-27â¤-28â¤-29â¤-30â¤-31â¤-32â¤-33â¤-34â¤-35â¤-36â¤-37â¤-38â¤-39â¤-40â¤-41â¤-42â¤-43â¤-44â¤-45â¤-46â¤-47â¤-48â¤-49â¤-50â¤-51â¤-52â¤-53â¤-54â¤-55â¤-56â¤-57â¤-58â¤-59â¤-60â¤-61â¤-62â¤-63â¤-64â¤-65â¤-66â¤-67â¤-68â

[19:52] <diakopter> urgh

[19:55] <moritz_> that totally freaked out my irssi

[19:55] <jnthn> Same!

[19:57] * jnthn distracted for a while - cooking/eating

[19:59] *** Gangl left
[20:01] *** nihiliad left
[20:06] *** cognominal left
[20:08] <TimToady> probably truncated the U+2424 â¤ in the middle

[20:08] *** Gangl joined
[20:09] <moritz_> good explanation

[20:13] <TimToady> rakudo: print .chr for 0xf000..0xf100

[20:13] <p6eval> rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[20:13] <TimToady> rakudo: print chr($_) for 0xf000..0xf100

[20:13] <p6eval> rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[20:13] <moritz_> currently rakudo on evalbot is really broken

[20:14] <TimToady> pugs: print .chr for 0xf000..0xf100

[20:14] <p6eval> pugs: No output (you need to produce output to STDOUT)

[20:14] <TimToady> pugs: say .chr for 0xf000..0xf100

[20:14] <p6eval> pugs: No output (you need to produce output to STDOUT)

[20:14] <moritz_> my attempts to fix this by rsync'ing a built parrot + rakudo to a new location also failed

[20:15] <moritz_> because parrot looks in the old dir for libraries

[20:15] <TimToady> pugs: for 0xf000..0xf100 -> $c { say chr($c) }

[20:15] <p6eval> pugs: No output (you need to produce output to STDOUT)

[20:15] <moritz_> pugs: say 1

[20:15] <p6eval> pugs: No output (you need to produce output to STDOUT)

[20:15] <TimToady> oopsie

[20:15] * moritz_ sighs

[20:15] <moritz_> most likely ghc got oom-killed during build

[20:17] <moritz_> I'll try to rebuild it once more, and then disable the cron job until we see another commit to pugs

[20:20] *** nihiliad joined
[20:23] *** mberends joined
[20:27] <moritz_> pugs: say "alive"

[20:27] <p6eval> pugs: OUTPUTÂ«aliveâ¤Â»

[20:28] *** justatheory left
[20:37] *** maerzhase left
[20:41] <Tene_> rakudo: say "undead"

[20:41] <p6eval> rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[20:41] <Tene_> Nice. :)

[20:44] <wolverian> TimToady: as - is allowed in names, should MONKEY_PATCHING and other such be MONKEY-PATCHING instead?

[20:53] *** schmalbe left
[20:58] *** charsbar left
[20:58] *** charsbar_ joined
[20:58] <TimToady> _ is harder to type :)

[20:59] <TimToady> pugs: print .chr for 0xf000..0xf100

[20:59] <p6eval> pugs: OUTPUTÂ«ï€€ï€ï€‚ï€ƒï€„ï€…ï€†ï€‡ï€ˆï€‰ï€Šï€‹ï€Œï€ï€ï€ï€ï€‘ï€’ï€“ï€”ï€•ï€–ï€—ï€˜ï€™ï€šï€›ï€œï€ï€ï€Ÿï€ ï€¡ï€¢ï€£ï€¤ï€¥ï€¦ï€§ï€¨ï€©ï€ªï€«ï€¬ï€­ï€®ï€¯ï€°ï€±ï€²ï€³ï€´ï€µï€¶ï€·ï€¸ï€¹ï€ºï€»ï€¼ï€½ï€¾ï€¿ï€ïï‚ïƒï„ï…ï†ï‡ïˆï‰ïŠï‹ïŒïïïïï‘ï’ï“ï”ï•ï–ï—ï˜ï™ïšï›ïœïïïŸï ï¡ï¢ï£ï¤ï¥ï¦ï§ï¨ï©ïªï«ï¬ï­ï®ï¯ï°ï±ï²ï³ï´ïµï¶ï·ï¸ï¹ïºï»ï¼ï½ï¾ï¿ï‚€ï‚ï‚‚ï‚ƒï‚„ï‚…ï‚†ï‚‡ï‚ˆï‚‰

[20:59] <TimToady> rakudo: print .chr for 0xf000..0xf100

[20:59] <p6eval> rakudo b2e7ac: OUTPUTÂ«Class 'Perl6MultiSub' not foundâ¤current instr.: 'parrot;Perl6Role;!add_variant' pc 2645 (src/classes/Role.pir:42)â¤Â»

[21:03] * jnthn is back from eating and a nice walk in the snow

[21:06] <ruoso> I think I realized how to break the circularity in Perl 6 type-system bootstrap...

[21:07] <ruoso> I just need a way to re-bind some basic types 

[21:07] <ruoso> meaning

[21:07] <ruoso> Array starts as being the lowlevel C implementation

[21:07] <ruoso> but at some point I redefine it as the high-level

[21:08] <ruoso> but this is not the same as "is instead"

[21:08] <jnthn> class Array is instead { ... } ?

[21:08] <ruoso> because "is instead" modify the Array class

[21:08] *** braceta left
[21:08] <ruoso> I just want something different to be referenced by the "Array" name

[21:08] <jnthn> Ah

[21:09] <ruoso> meaning that stuff that resolved "Array" as the old value, keep that as it is

[21:09] <jnthn> Then it's just changing the entry in the namespace? Or copying over the location where the previous Array class is stored...or something.

[21:09] <ruoso> just changing the entry in the namespace

[21:09] <jnthn> Sounds quite easy. :-)

[21:10] <ruoso> so, if Multi was first defined with a very low level RoleHOW

[21:10] <ruoso> and the punned class has very few features

[21:10] <ruoso> I can re-define it later, after I have a complete RoleHOW and a complete ClassHOW

[21:10] <ruoso> so I get a different punned class

[21:10] <jnthn> Sounds workable.

[21:11] <ruoso> but it would be nice to have a Perl 6 construct to replace the symbol

[21:12] <ruoso> since all this types are going to be written in Perl 6 itself

[21:12] <ruoso> (because I actually need it, not because I want to be fancy)

[21:12] <jnthn> Just binding, isn't it?

[21:12] <jnthn> Well, you've always the option of a magic internals call. ;-)

[21:12] <ruoso> jnthn, the problem is that "magic internals" will have to make a huge effort to provide the semantics 

[21:13] <ruoso> so it's easier to have a Perl 6 compiler doing that

[21:13] <jnthn> I don't quite see why replacing a symbol in the namespace is tricky, but I don't understand sm0p guts well enough to really know.

[21:14] <ruoso> jnthn, smop is fine...

[21:14] <ruoso> but I don't want a Perl 6 first-stage-compiler

[21:14] <ruoso> I mean

[21:14] <ruoso> I don't want to have a custom compiler for the prelude

[21:14] <ruoso> so I'd like to use STD Perl 6 to do that re-definition

[21:15] <jnthn> Doesn't ::Array := $new_definition_of_array; work?

[21:15] <jnthn> Or similar...that won't quite work

[21:15] <TimToady> ::= more likely

[21:15] <jnthn> *nod*

[21:15] <TimToady> or it's substituting in a new CORE

[21:16] <ruoso> both in the CORE package and in the prelude

[21:16] <TimToady> CORE *is* the prelude

[21:16] <TimToady> now called the setting, btw

[21:16] <TimToady> because it's not just before

[21:17] <TimToady> any lexical scope can say "freeze me to a new setting" to be used in place of CORE

[21:17] <ruoso> so I can assume CORE is the outer of the outermost scope

[21:17] <TimToady> that's how -n and -p probably work

[21:18] <TimToady> yes, but it sound's like you want BOOT:: outside of that :)

[21:18] <TimToady> s/'//

[21:18] <ruoso> this confusing of lexical scopes and packages is getting me dizzy

[21:18] <TimToady> or maybe TURTLE:: or something :)

[21:18] <TimToady> this has nothing to do with packages

[21:19] *** iblechbot left
[21:19] <TimToady> GLOBAL has almost nothing in it except user-defined packages

[21:19] <ruoso> right... CORE is a pseudo-package

[21:19] <TimToady> CORE is the outermost lexical scope

[21:19] <TimToady> and almost all built-in types are CORE:: packages, not GLOBAL::

[21:19] <ruoso> so CORE is a pseudo-package, as CALLER

[21:20] <ruoso> that makes it clearer

[21:20] <TimToady> when you say Int it finds CORE::Int unless an inner lexical scope overrides

[21:20] <TimToady> see recent changes to S02

[21:20] <ruoso> cool

[21:21] <ruoso> I had seen it before, but missed the "pseudo-package" part

[21:22] <TimToady> maybe we define CORE as implementation independent, and outside that is IMPLCORE or some such for bootstrapping, that is implementation dependent

[21:22] <TimToady> I dunno, not sure that solves anything...

[21:22] <ruoso> I'm not sure that it needs the definition...

[21:22] <ruoso> because CORE is just something you do a lookup ok

[21:22] <ruoso> s/ok/on/

[21:22] <TimToady> but I'd like to keep implementation specifics out of the standard setting

[21:22] <ruoso> it doesn't matter how many outer scopes it has

[21:23] <ruoso> we just know that at some point we name "this is the standard CORE"

[21:23] <TimToady> CORE may well have scopes outer to it, but maybe it just hides them all under CORE

[21:23] <ruoso> since CORE is a pseudo-package

[21:23] <ruoso> that already happens in CALLER

[21:24] <ruoso> I call it "flattened lexical scope"

[21:24] <ruoso> (as in "there's a type with that name in SMOP")

[21:24] <ruoso> (ok, not that name exactly, but you got it)

[21:24] <dalek> rakudo: 1ac6625 | jnthn++ | src/builtins/io.pir:

[21:24] <dalek> rakudo: Implement prompt built-in.

[21:24] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1ac66258b5aad36a0f5dffee08982007c5baf07a

[21:25] <ruoso> TimToady, what would be really cool would be to have a runtime way to say: "The current lexical scope should be taken as CORE from now on"

[21:25] <TimToady> that's called eval

[21:25] <TimToady> :)

[21:25] <ruoso> hm?

[21:25] <TimToady> SETTING is what you're thinking of

[21:26] <TimToady> see S02

[21:26] <ruoso> It would be if I was a regular user ;)

[21:26] <ruoso> but I'm writing the CORE itself ;)

[21:26] <ruoso> so I need to re-define it after each step

[21:26] <jnthn> moritz_: I just implemented prompt and closed the ticket then thought....ah...test...

[21:26] <jnthn> moritz_: But what is status/planning for testing IO stuff like that?

[21:28] <moritz_> jnthn: stuck in the planning and experimenting phase :(

[21:28] <TimToady> commuting &

[21:29] <jnthn> moritz_: OK.

[21:30] <moritz_> jnthn: just assign it to me for now

[21:30] * ruoso trying to find a way to put another turtle under the elephant foot

[21:30] * moritz_ pities the turtles

[21:31] <jnthn> moritz_: Given.

[21:32] * ruoso wonder if "class CORE::Array {...}" is sane for that matter

[21:33] <ruoso> std: class CORE::Array {...}

[21:33] <p6eval> std 25322: OUTPUTÂ«ok 00:02 33mâ¤Â»

[21:37] *** pmurias joined
[21:38] <ruoso> now I just need a carefull planning of each stage of the bootstrap, realizing which types are going to be replaced from low-level to high-level and each types are going to be re-initted to use the features of the higher-level types...

[21:38] <ruoso> pmurias, hi

[21:40] <ruoso> pmurias, I think we are on time to sanitize the lexical prelude, and make a bootstrap timeline (not in the sense of development, but in the sense of actual loading of types)

[21:40] <pmurias> ruoso: hi

[21:40] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[21:42] <pmurias> ruoso: one think that bothers me with the replace Array with a better Array scheme, is won't the old version behave different?

[21:43] <ruoso> yes, but in the end we should be able to re-init all visible types in a way that the old version disappears from the user

[21:43] <ruoso> i.e. bootstrap

[21:45] <ruoso> that's why we need the timeline

[21:45] <pmurias> ah, got it

[21:46] *** Gangl left
[21:46] <ruoso> were we can have the types implemented in C in red, the one implemented in Perl 6, but still depending on C types in black, and the boostrapped types in blue...

[21:46] *** Gangl joined
[21:46] * ruoso thinks in a very wide SVG file

[21:46] *** Gangl left
[21:47] <moritz_> ruoso: or dot/neato

[21:47] <moritz_> very handy for graphs/trees

[21:47] *** Gangl joined
[21:47] <pmurias> bootstrapped time are the ones only needed at class creation time?

[21:47] <pmurias> s/time/types/

[21:48] <ruoso> bootstrapped are those who no longer see any lowlevel type during its initialization

[21:48] <ruoso> any lowlevel type or any high-level type that yet depends on a low-level type

[21:49] *** M_o_C left
[21:49] * ruoso commute &

[21:49] * ruoso will backlog &

[21:49] *** ruoso left
[21:51] *** cognominal joined
[21:52] *** pmurias left
[21:58] <dalek> rakudo: 7175fd0 | jnthn++ | src/ (2 files):

[21:58] <dalek> rakudo: Allow 'inheritance' from a role (puns the role into a class and inherits from the pun).

[21:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7175fd0be79be44cae99b89059bb26e1b3f95579

[21:59] *** meppl left
[22:09] *** r0bby joined
[22:17] *** kate21de joined
[22:19] *** kate21de left
[22:25] *** skids left
[22:30] *** kate21de joined
[22:37] *** Whiteknight joined
[22:47] *** lambdabot left
[22:47] <dalek> rakudo: a0a3902 | jnthn++ | src/parser/actions.pm:

[22:47] <dalek> rakudo: Check for $x ~~ .foo is syntactic and should thus be done on the parse three, not the PAST tree (pmichaud++ for input).

[22:47] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a0a3902bd7c96af1dbf94405826646573a4a127b

[22:48] <jnthn> OK, that's me done for the day.

[22:48] <jnthn> Report: http://use.perl.org/~JonathanWorthington/journal/38475

[22:49] *** lambdabot joined
[22:50] *** hercynium left
[23:11] *** iblechbot joined
[23:13] *** alester left
[23:13] *** hanekomu joined
[23:16] *** skids joined
[23:37] *** rindolf left
[23:39] *** kate21de left
[23:39] *** kate21de joined
[23:43] *** kate21de left
[23:48] *** Limbic_Region joined
[23:55] *** hanekomu left
