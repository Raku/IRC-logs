[00:01] *** mberends left
[00:04] *** Ariens_Hyperion left
[00:38] *** alester joined
[00:41] *** meteorjay joined
[00:41] *** nihiliad left
[00:46] *** alester left
[00:59] *** Eevee joined
[01:00] <pugs_svn> r25634 | putter++ | [elfparse] Starting to sketch in more efficient rx ratcheting support.

[01:05] *** DemoFreak left
[01:40] *** nihiliad joined
[01:46] <frooh> rakudo: sqrt(9)

[01:46] <p6eval> rakudo d3f407: RESULT«3»

[01:46] <frooh> rakudo: sqrt(5)

[01:46] <p6eval> rakudo d3f407: RESULT«2.23606797749979»

[01:46] *** Whiteknight left
[01:49] <frooh> rakudo: my $bar = sub ($foo) { $foo }; 

[01:49] <p6eval> rakudo d3f407: RESULT«{ ... }»

[01:49] <frooh> rakudo: my $bar = sub ($foo) { $foo }; $bar->(1);

[01:49] <p6eval> rakudo d3f407: OUTPUT«Statement not terminated properly at line 1, near "->(1);"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[01:49] <frooh> rakudo: my $bar = sub ($foo) { $foo }; $bar(1);

[01:49] <p6eval> rakudo d3f407: RESULT«1»

[01:52] <frooh> rakudo: for my $f 1..4 { say $f }

[01:52] <p6eval> rakudo d3f407: OUTPUT«Redeclaration of variable $f␤Statement not terminated properly at line 1, near "1..4 { say"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[01:52] <frooh> rakudo: for my $f, 1..4 { say $f }

[01:52] <p6eval> rakudo d3f407: OUTPUT«Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤»

[01:55] <pmichaud> bacek: I know that chain implies &&.  I'm saying I don't like the current factoring.

[01:57] <frooh> how do I do a for loop in perl 6?

[01:57] <frooh> (or where in the fine manual can I find out :-)

[01:57] <TimToady> S04

[01:57] <TimToady> rakudo: for 1..4 -> $f { say $f }

[01:58] <p6eval> rakudo d3f407: OUTPUT«1␤2␤3␤4␤»

[01:58] <TimToady> $f is a formal parameter to the block in p6

[01:58] <frooh> ah

[01:58] <frooh> I was searching for =item for

[02:02] <frooh> rakudo: '5' =~ /\d+$/

[02:02] <p6eval> rakudo d3f407: OUTPUT«Unable to set lvalue on PAST::Val node␤current instr.: 'parrot;PAST;Val;lvalue' pc 566 (src/PAST/Node.pir:161)␤»

[02:02] <frooh> rakudo: '5' ~~ /\d+$/

[02:02] <p6eval> rakudo d3f407: RESULT«Method 'perl' not found for invocant of class 'Match'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[02:02] <frooh> rakudo: if '5' ~~ /\d+$/ { say 'matches' }

[02:02] <p6eval> rakudo d3f407: OUTPUT«matches␤»

[02:02] <frooh> rakudo: if 'frew' ~~ /\d+$/ { say 'matches' }

[02:02] <p6eval> rakudo d3f407: RESULT«Method 'perl' not found for invocant of class 'Match'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[02:03] <frooh> rakudo: if my $f = 'frew' { say $f }

[02:03] <p6eval> rakudo d3f407: OUTPUT«frew␤»

[02:03] *** xinming_ joined
[02:11] <frooh> when rakudo tells me "No applicable methods" is there any way I can find out what line it's talking about?

[02:15] <frooh> ok, actually the issue is coming from doing this:

[02:15] <frooh> if my $f = %odt{$token} { $f(...) }

[02:16] <frooh> I tried replacing $ with &

[02:16] <frooh> still no good

[02:17] *** xinming left
[02:18] <frooh> oh weird

[02:18] <frooh> so I had an issue in the function

[02:18] <frooh> I had this:

[02:19] <frooh> push(@stack, pop(@stack) + pop(@stack));

[02:19] <frooh> I know that's no idiomatic perl6

[02:20] <frooh> but is it wrong/

[02:31] *** mikehh left
[02:32] *** mikehh joined
[02:33] <TimToady> std: push(@stack, pop(@stack) + pop(@stack));

[02:33] <p6eval> std 25634: OUTPUT«Potential difficulties:␤  Variable @stack is not predeclared at /tmp/mLVas1R668 line 1:␤------> [32mpush(@stack[31m, pop(@stack) + pop(@stack));[0m␤  Variable @stack is not predeclared at /tmp/mLVas1R668 line 1:␤------> [32mpush(@stack, pop(@stack[31m) + pop(@stack));[0m␤ 

[02:33] <p6eval> .....

[02:34] <TimToady> std: my @stack; push(@stack, pop(@stack) + pop(@stack));

[02:34] <p6eval> std 25634: OUTPUT«ok 00:02 34m␤»

[02:35] <frooh> rakudo: my @stack = [1, 2];  push(@stack, pop(@stack) + pop(@stack));

[02:35] <p6eval> rakudo d3f407: OUTPUT«No applicable methods.␤␤current instr.: '_block14' pc 141 (EVAL_16:52)␤»

[02:36] <TimToady> rakudo: my @stack := [1,2]; push(@stack, pop(@stack) + pop(@stack));

[02:36] <p6eval> rakudo d3f407: OUTPUT«No applicable methods.␤␤current instr.: '_block14' pc 127 (EVAL_16:50)␤»

[02:37] <TimToady> rakudo: my @stack := [1,2]; push(@stack, @stack.pop + @stack.pop);

[02:37] <p6eval> rakudo d3f407: RESULT«1»

[02:37] <TimToady> rakudo: my @stack := [1,2]; push(@stack, @stack.pop + @stack.pop);  say @stack[0]

[02:37] <p6eval> rakudo d3f407: OUTPUT«3␤»

[02:38] <TimToady> you either have to use := [] or = ()

[02:38] <frooh> I replaced all of them with @foo.bar, but it's still a bug right?

[02:38] <frooh> well, @stack is defined by push'es

[02:38] <TimToady> in theory pop(@stack) ought to work

[02:38] <frooh> ok

[02:38] <frooh> just making sure

[02:38] <TimToady> the push as a function seems to work

[02:39] <frooh> it works fine when I use the method syntax, which I prefer anyway, I was just curious

[02:39] <TimToady> rakudo: my @stack = (1,2); say pop(@stack)

[02:39] <p6eval> rakudo d3f407: OUTPUT«2␤»

[02:39] <frooh> also, what exactly is the diff between := = [] and () ?

[02:39] <TimToady> seems to work in isolation

[02:39] <TimToady> binding vs assignment

[02:39] <TimToady> [] creates a single scalar containing an array

[02:39] <frooh> so = value, := reference?

[02:40] <TimToady> if you assign that, you end up with only one element that happens to be an array

[02:40] <TimToady> yes, basically

[02:40] <frooh> interesting

[02:40] <Tene_> rakudo: my $a = 5; my $b := $a $b++; say $a

[02:40] <p6eval> rakudo d3f407: OUTPUT«Statement not terminated properly at line 1, near "$b++; say "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[02:41] <Tene_> rakudo: my $a = 5; my $b := $a; $b++; say $a

[02:41] <p6eval> rakudo d3f407: OUTPUT«6␤»

[02:41] <TimToady> decommuting &

[02:41] * Tene_ decommuting too!

[02:41] <Tene_> In 9 minutes.

[02:42] <frooh> my $f = [1,2,3];

[02:42] <frooh> rakduo: my $f = [1,2,3]; $f

[02:42] <frooh> rakudo: my $f = [1,2,3]; $f

[02:42] <p6eval> rakudo d3f407: RESULT«[1, 2, 3]»

[02:42] <frooh> rakudo: my $f := [1,2,3]; $f

[02:42] <p6eval> rakudo d3f407: RESULT«[1, 2, 3]»

[02:43] * frooh has trouble seeing the difference.

[02:43] <frooh> rakudo: my $f = (1,2,3); $f

[02:43] <p6eval> rakudo d3f407: RESULT«[1, 2, 3]»

[02:43] <frooh> rakudo: my @f = (1,2,3); $f

[02:43] <p6eval> rakudo d3f407: OUTPUT«Scope not found for PAST::Var '$f' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[02:43] <frooh> rakudo: my @f = (1,2,3); @f

[02:43] <p6eval> rakudo d3f407: RESULT«[1, 2, 3]»

[02:43] <frooh> rakudo: my @f := (1,2,3); @f

[02:43] <p6eval> rakudo d3f407: RESULT«[1, 2, 3]»

[02:48] *** Chillance left
[02:54] <frooh> pugs: 1 - 2

[02:54] <p6eval> pugs: RESULT«-1»

[02:54] <frooh> pugs: 1 R- 2

[02:54] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "R"␤    expecting operator␤    at /tmp/XSe9w7YqD2 line 1, column 3␤»

[02:55] <frooh> pugs: 1 R/ 2

[02:55] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "R"␤    expecting operator␤    at /tmp/DgcfqjC3D4 line 1, column 3␤»

[02:55] <frooh> pugs: 1 R== 2

[02:55] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "R"␤    expecting operator␤    at /tmp/Z5RZqbEJBq line 1, column 3␤»

[02:56] *** Sepheebear left
[02:56] *** edenc left
[02:56] *** broquaint left
[02:58] *** broquaint joined
[02:58] *** edenc joined
[03:15] *** Sepheebear joined
[03:15] *** Sepheebear left
[03:16] *** Sepheebear joined
[03:37] *** Sepheebear left
[03:42] *** aindilis` joined
[03:49] <frooh> sub f(Int $i) { say $i }; f(2); f('2');

[03:49] <frooh> rakudo: sub f(Int $i) { say $i }; f(2); f('2');

[03:49] <p6eval> rakudo d3f407: OUTPUT«2␤Parameter type check failed for $i in call to f␤current instr.: 'die' pc 16347 (src/builtins/control.pir:204)␤»

[03:49] <frooh> rakudo: sub f(Int $i) { say $i }; f(2); f(+'2');

[03:49] <p6eval> rakudo d3f407: OUTPUT«2␤Parameter type check failed for $i in call to f␤current instr.: 'die' pc 16347 (src/builtins/control.pir:204)␤»

[03:50] <frooh> rakudo: sub f(Int $i) { say $i }; f(2); f((+'2'));

[03:50] <p6eval> rakudo d3f407: OUTPUT«2␤Parameter type check failed for $i in call to f␤current instr.: 'die' pc 16347 (src/builtins/control.pir:204)␤»

[03:50] <frooh> rakudo: sub f(Int $i) { say $i }; f(2);

[03:50] <p6eval> rakudo d3f407: OUTPUT«2␤»

[03:50] <frooh> rakudo: 5

[03:50] <p6eval> rakudo d3f407: RESULT«5»

[03:50] <frooh> rakudo: '5'

[03:50] <p6eval> rakudo d3f407: RESULT«"5"»

[03:50] <frooh> rakudo: +'5'

[03:50] <p6eval> rakudo d3f407: RESULT«5»

[03:50] <frooh> hmmm

[03:50] <frooh> rakudo: ~5

[03:50] <p6eval> rakudo d3f407: RESULT«"5"»

[03:51] <frooh> rakudo: sub f(Int $i) { say $i };  f(+'2');

[03:51] <p6eval> rakudo d3f407: OUTPUT«Parameter type check failed for $i in call to f␤current instr.: 'die' pc 16347 (src/builtins/control.pir:204)␤»

[03:51] <frooh> rakudo: sub f(Int $i) { say $i };  my $foo = '2'; f(+$foo);

[03:51] <p6eval> rakudo d3f407: OUTPUT«Parameter type check failed for $i in call to f␤current instr.: 'die' pc 16347 (src/builtins/control.pir:204)␤»

[03:51] <frooh> rakudo: sub f(Int $i) { say $i };  my $foo = +'2'; f($foo);

[03:51] <p6eval> rakudo d3f407: OUTPUT«Parameter type check failed for $i in call to f␤current instr.: 'die' pc 16347 (src/builtins/control.pir:204)␤»

[03:51] <frooh> :-(

[03:55] <meppl> good night

[03:56] *** aindilis left
[03:56] <frooh> also: for @*ARGS -> $arg doesn't seem to work

[03:58] *** japhb joined
[03:59] *** meppl left
[04:01] <pmichaud> frooh: Rakudo currently sees +'2' as being a Num, not an Int.

[04:01] <pmichaud> I'm not exactly certain how to resolve that one yet.

[04:02] <frooh> huh

[04:02] <frooh> well, I guess that makes sense

[04:02] <frooh> but can't it say, "dude, this Num really *is* an Int!"

[04:02] <frooh> (I presume it can't or it would :-)

[04:02] <frooh> any idea about the @*ARGS thing?

[04:03] <pmichaud> as I said, I'm not exactly certain how to resolve that one yet.  Currently our  prefix:<+> returns a Num.

[04:03] <pmichaud> I guess we could work on getting prefix:<+> to return an Int if the string doesn't include a decimal point.

[04:03] <frooh> yeah, I'm just joking, I think returning a num makes more sense anyway

[04:03] <pmichaud> it's a bit complicated on the parrot internals side for that.

[04:04] <frooh> maybe I could do (+'f').int

[04:04] <frooh> er

[04:04] <frooh> '5'

[04:04] <pmichaud> looking at @*ARGS now

[04:06] <pmichaud> looks like it works to me:

[04:06] <pmichaud> $ cat x.pl

[04:06] <pmichaud> for @*ARGS -> $arg { $arg.say }

[04:06] <pmichaud> $ ./perl6 x.pl a b c

[04:06] <pmichaud> a

[04:06] <pmichaud> b

[04:06] <pmichaud> c

[04:06] <frooh> weird...

[04:06] <frooh> lemme look again

[04:07] <frooh> unless there is a really recent fix for rakudo (I built tongiht) it's busted here still

[04:07] <frooh> exact same code

[04:07] <pmichaud> can you pastebin/nopaste what you're testing?  

[04:08] <pmichaud> what output are you getting?

[04:08] <frooh> Statement not terminated properly at line 10, near "-> $arg { "

[04:08] <pmichaud> it's not even parsing?  that's odd.

[04:08] <frooh> lemme comment out the rest of the code

[04:08] <pmichaud> oh, so it's not the _exact_ same code :_)

[04:08] <pmichaud> I suspect the error is whatever follows the for loop body

[04:08] <frooh> weird

[04:09] <frooh> well

[04:09] <frooh> it's BEFORE the for loop

[04:09] <frooh> it's a sub

[04:09] <pmichaud> oh

[04:09] <pmichaud> yes, that's a known bug in Rakudo.

[04:09] <pmichaud> you need a semi after that sub.

[04:09] <frooh> really?

[04:09] <frooh> what is it exactly?

[04:09] <pmichaud> otherwise Rakudo sees it as    "sub xyz { } for ... "

[04:09] <frooh> oh

[04:09] <frooh> hih

[04:09] <pmichaud> and thinks that the 'for' is a statement modifier.

[04:09] <pmichaud> I guess I better fix that tomorrow.

[04:10] <frooh> so do sub xyz semi { ... }?

[04:10] <frooh> it's not a huge deal

[04:10] <pmichaud> (even if it ends up being an ugly-ish fix.

[04:10] <pmichaud> it needs to be:   sub xyz { ... };  for @*ARGS -> $arg { ... }

[04:10] <pmichaud> with the semicolon after the closing brace of the sub.

[04:10] <frooh> ahhh

[04:10] <frooh> git it

[04:11] <pmichaud> that's a problem that trips up a lot of folks, and we really need to fix it somehow.

[04:11] <frooh> got*

[04:11] <pmichaud> so, it's on my list for tomorrow.

[04:11] <pmichaud> rakudo:  sub foo(Int $x) { $x.say };   foo('5'.int);

[04:11] <p6eval> rakudo d3f407: OUTPUT«5␤»

[04:11] <pmichaud> no + needed.

[04:12] <frooh> got it

[04:12] *** Tene joined
[04:12] <frooh> so would it be worth it for me to learn pir to try to help or would it be better to try to help with the setting?

[04:12] <pmichaud> I think helping with setting is what most people will find most useful.

[04:12] <pmichaud> or most enjoyable.

[04:12] <frooh> cool

[04:12] <frooh> well, that's definately true

[04:13] <frooh> but I don't mind doing stuff that no one else wants to do

[04:13] <frooh> anything to make perl6 come sooner :-)

[04:13] <pmichaud> the PIR really is intended to be reserved for things that can't easily be done in Perl 6.

[04:14] <frooh> what exactly is the PGE that people keep talking about?

[04:14] <pmichaud> it's Rakudo's (and Parrot's) regular expression engine.

[04:14] <pmichaud> It's the thing that handles regex matching, as well as the parsing of Perl 6 code itself.

[04:14] <frooh> got it

[04:14] <pmichaud> there should be an entry for it in docs/glossary.pod

[04:15] <frooh> ahh

[04:15] <pmichaud> oh, there's not!  That's a bug.

[04:15] <frooh> haha

[04:15] <frooh> niec

[04:15] <frooh> nice*

[04:18] <dalek> rakudo: c1f3976 | pmichaud++ | docs/glossary.pod:

[04:18] <dalek> rakudo: Add entry for PGE to glossary.pod (frooh++)

[04:18] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c1f3976001a082a6d1ecb67fd27a718e9a226fc9

[04:19] *** tony_ joined
[04:19] * frooh reads glossary.pod

[04:21] <frooh> so does rakudo actually use STD.pm?  or is it just a validator/

[04:22] <pmichaud> rakudo doesn't use STD.pm yet.

[04:22] <frooh> but it will at some point?

[04:22] <pmichaud> PGE isn't sophisticated enough yet to parse STD.pm

[04:22] <frooh> ah, got it

[04:22] <pmichaud> the goal is to have Rakudo and other implementations converge on STD.pm, yes.

[04:22] <frooh> yeah, I didn't know if that meant use STD.pm itself or just something like it

[04:23] <pmichaud> whatever we end up with undoubtedly be very close to STD.pm, if not STD.pm itself.

[04:23] <pmichaud> it might end up being STD.pm with a couple of patches.

[04:23] <frooh> also: how about the Setting?  is it the goal that implementations can reuse that too?

[04:23] *** idemal joined
[04:23] <pmichaud> I don't know to what extent Perl 6 will have a "standard setting" (more)

[04:24] <pmichaud> there are some functions (primitives) that likely cannot be expressed in Perl 6

[04:24] <pmichaud> (more)

[04:24] *** Tene_ left
[04:24] <pmichaud> and things that are primitives on one platform might be fairly complex on other platforms

[04:24] <frooh> that makes sense

[04:25] <pmichaud> so, we may have a standard setting library that says "this is a reference for implementations", but individual implementations may want or need to use a slightly different internal implementation (that gives the same semantics).

[04:26] <frooh> yeah.  But the ability to change out settings  (or add them) is part of the spec right?

[04:26] <TimToady> std: sub foo {...} for 1..10 -> {...}

[04:26] <pmichaud> but yes, I'd like for Rakudo to be providing some settings that other implementations can re-use.

[04:26] <p6eval> std 25634: OUTPUT«############# PARSE FAILED #############␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/3BssYYhSx3 line 1:␤------> [32msub foo {...} for 1..10 [31m-> {...}[0m␤    expecting any of:␤  infix or meta-infix␤      infix

[04:26] <p6eval> ..stopper␤    ...

[04:27] <pmichaud> TimToady:  you may have answered this already,  but should  prefix:<+> be smart enough to return an Int for things like  +'5'  and a Num for +'5.0'  ?

[04:29] <TimToady> thinking...

[04:29] <pmichaud> or is there a "generic num/intify" that we should be doing on Str ?

[04:30] <TimToady> perhaps it returns a Rat  :)

[04:31] <pmichaud> if the answer isn't yet specced, I don't need it right now; was just curious if I had overlooked something (I'll have to leave very shortly)

[04:31] <TimToady> not specced yet

[04:31] <pmichaud> but I know that    sub foo(Int $x) { ... };   foo(+'5')     trips up a lot of folks.

[04:32] <pmichaud> in some sense I think it might be good if we say that such cases require an explicit .int on the argument

[04:32] <frooh> rakudo: +'5/7'

[04:32] <p6eval> rakudo c1f397: RESULT«5»

[04:32] <frooh> rakudo: +'5+7i'

[04:32] <TimToady> on the other hand, if Int does the Num role, it's fine to return an Int for a Num return type

[04:33] <p6eval> rakudo c1f397: RESULT«5»

[04:33] <frooh> rakudo: +'5.7'

[04:33] <pmichaud> but if Int does Num, then    foo(2.3) would seem to match?

[04:33] <p6eval> rakudo c1f397: RESULT«5.7»

[04:34] <pmichaud> or is my too-tired brain thinking of that backwards again?

[04:34] <TimToady> but it matches Num more closely

[04:34] <frooh> pmichaud: I agree, foo(2.3) should at least give a warning, right?

[04:35] <frooh> 2.3 isn't an Int, and foo only takes Int's...

[04:35] <TimToady> maybe they both do Numeric

[04:35] <TimToady> or maybe + just doesn't commit to a specific return type

[04:35] <pmichaud> well, I was headed that way, but there's also the case of

[04:36] * frooh want's + to be * for numeric coersions :-)

[04:36] <pmichaud>    foo('3' * 2)

[04:36] <pmichaud> so it's not just prefix:<+> that we have to consider.

[04:37] <TimToady> well, AnyAny would convert to IntInt in that case

[04:37] <TimToady> which seems okay

[04:37] <pmichaud> I don't understand that last part

[04:38] <TimToady> infix:<*>:(Any,Any) converts via +$x * +$y

[04:38] <TimToady> which would make two integers and call infix:<*>:(Int,Int)

[04:38] <pmichaud> okay.

[04:39] <TimToady> unless we short circuit the strings with extra candidates, but it doesn't seem necessary

[04:39] <pmichaud> right.

[04:39] <pmichaud> so then prefix:<+> does become the generic "make me a number" operator.

[04:39] <TimToady> basically, if people rely on the Any cases they get slowed down, so there some motivation to cast explicitly

[04:40] <pmichaud> I wasn't looking for a guaranteed return type for prefix:<+>; I was more asking if it was possible that prefix:<+>(Str) could choose to return a Num or an Int based on the conversion.

[04:40] <TimToady> yes, + can just make the most specific type it can, I suspect

[04:40] <frooh> hurray!

[04:41] <TimToady> even something to be said for Rat in some cases

[04:41] <pmichaud> agreed.

[04:41] <frooh> what about Complex?

[04:41] <frooh> or is that just going too far?

[04:41] <frooh> ;-)

[04:41] <pmichaud> it's not too far, it's just too complex.  :-) :-)

[04:41] <TimToady> esp if the string is '355/113'

[04:42] <TimToady> well, if the string is 1+.2i, what're you gonna do, truncate it?

[04:42] <pmichaud> where do we draw the line between numify and eval?  ;-)

[04:43] <TimToady> we guarantee to recognize radix numbers in strings too...

[04:43] <frooh> user defined types?

[04:43] <pmichaud> yes.  Somehow I see it as being "numify a term" as opposed to "numify an expression"

[04:43] <TimToady> starting to sound like a longest-token problem

[04:44] <TimToady> parse this string with term:* and ...

[04:44] <pmichaud> so far Rakudo's string-to-num converter follows the parsing for <number>

[04:45] <TimToady> but can other types add term: rules, I wonder...

[04:45] <pmichaud> (which includes the radix numbers)

[04:45] <TimToady> or maybe we need a number: category

[04:45] <pmichaud> anyway, you've given me the short-term answer for prefix:<+>, so I'm good with that for now.

[04:45] <TimToady> wouldn't be difficult to arrange

[04:45] <pmichaud> number: might be very nice

[04:46] <pmichaud> could be much cleaner for dealing with the complexes and rats

[04:46] <pmichaud> rakudo:   say +( ~ ( 3+.1i ) );

[04:46] <p6eval> rakudo c1f397: OUTPUT«3␤»

[04:47] <pmichaud> rakudo:  say ~(3+.1i)   # just checking

[04:47] <p6eval> rakudo c1f397: OUTPUT«3+0.1i␤»

[04:48] <pmichaud> might also help with parsing things like "Inf" and "NaN"

[04:48] <TimToady> indeed

[04:48] <TimToady> I love it when a plan comes together :)

[04:50] <pmichaud> token number:NaN { <sym> >> }

[04:50] <pmichaud> token number:Inf { <sym> >> }

[04:50] <pmichaud> helps to resolve the "Inf" versus "Info" issue, too.

[04:50] <TimToady> assuming we require $ too

[04:52] <pmichaud> rakudo:  say 2 + (Inf)i;  # just curious

[04:52] <p6eval> rakudo c1f397: OUTPUT«NaNInfi␤»

[04:52] <TimToady> probably we want to short-circuit normal ints and nums, and only revert to parse on fancy stuff

[04:53] <TimToady> but that depends on the overhead of regex setup

[04:53] <frooh> is the type for a function Sub?

[04:53] <pmichaud> depends on the function :-)

[04:53] <frooh> haha

[04:53] <frooh> anonymous subroutine?

[04:54] <TimToady> with or without the "sub"?

[04:54] <TimToady> they're different

[04:54] <frooh> good question..

[04:54] <frooh> I don't know...

[04:54] <frooh> let's say without for now

[04:54] <frooh> Block?

[04:54] <TimToady> pugs: (sub {}).WHAT

[04:54] <p6eval> pugs: RESULT«::Sub»

[04:54] <TimToady> pugs: ({}).WHAT

[04:54] <p6eval> pugs: RESULT«::Hash»

[04:54] <frooh> haha

[04:54] <TimToady> pugs: ({;}).WHAT

[04:55] <p6eval> pugs: RESULT«::Block»

[04:55] <frooh> is there something that would work for both?

[04:55] <TimToady> Code

[04:55] <frooh> awesome

[04:55] <frooh> that's what I would guess

[04:56] <TimToady> rakudo: {;} ~~ Code

[04:56] <p6eval> rakudo c1f397: RESULT«1»

[04:56] <TimToady> rakudo: sub {;} ~~ Code

[04:56] <p6eval> rakudo c1f397: RESULT«1»

[04:56] <pmichaud> rakudo:  {} ~~ Code

[04:56] <p6eval> rakudo c1f397: RESULT«0»

[04:57] <pmichaud> ...although why that returns "0" and not "" or "False" is beyond me.

[04:57] <TimToady> because it's a Hash

[04:57] <pmichaud> there's a lot of places where people keep using 0/1 instead of True/False

[04:57] <TimToady> oh, wait

[04:57] <pmichaud> (in the rakudo code base)

[04:57] <TimToady> the value of False is 0

[04:58] <pmichaud> rakudo:  3 == 4

[04:58] <TimToady> current spec only gets the name via .perl or .name

[04:58] <p6eval> rakudo c1f397: RESULT«Bool::False»

[04:58] <pmichaud> so, infix:<==>  is returning "false"

[04:58] <frooh> rakudo: my $foo = "{3==4}";

[04:58] <p6eval> rakudo c1f397: RESULT«"0"»

[04:58] <pmichaud> I suspect that Code.ACCEPTS()  in Rakudo is returning 0/1

[04:59] <pmichaud> I'll have to crack some more whips over those coders :-)

[04:59] <pmichaud> but right now my wife is cracking a whip at me, so I best go.  :-)

[04:59] <frooh> pmichaud: thanks for the help on bug avoidance :-)

[05:00] <TimToady> so we should probably generally only see 0 or 1 on output, unless it's .perled

[05:01] <TimToady> last week it was stringifying to False, but I decided that was inconsistent with the native type behavior

[05:02] <TimToady> False should never turn into '' though

[05:02] <TimToady> that's a p5ism

[05:02] * frooh is excited about perl6

[05:02] <frooh> is there a way to get the signature from a function?

[05:02] <frooh> like, &sub.signature?

[05:03] <TimToady> try it

[05:03] *** nihiliad left
[05:03] <frooh> rakudo: sub (Int $f, Code $b) { say $f }.signature

[05:03] <p6eval> rakudo c1f397: OUTPUT«Statement not terminated properly at line 1, near ".signature"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[05:03] <frooh> rakudo: sub (Int $f, Code $b) { say $f; }.signature

[05:03] <p6eval> rakudo c1f397: OUTPUT«Statement not terminated properly at line 1, near ".signature"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[05:03] <frooh> rakudo: sub foo (Int $f, Code $b) { say $f; }.signature

[05:03] <p6eval> rakudo c1f397: OUTPUT«Statement not terminated properly at line 1, near ".signature"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[05:03] <frooh> rakudo: sub foo (Int $f, Code $b) { say $f; }.sig

[05:03] <p6eval> rakudo c1f397: OUTPUT«Statement not terminated properly at line 1, near ".sig"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[05:04] <frooh> no?

[05:04] *** NoirSoldats joined
[05:04] <TimToady> not sure rakudo returns a value from a named declaration

[05:04] <frooh> the first few were anon

[05:04] <TimToady> rakudo: sub (Int $f, Code $b) { say $f; }.sig

[05:04] <p6eval> rakudo c1f397: OUTPUT«Statement not terminated properly at line 1, near ".sig"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[05:04] <TimToady> rakudo: &push.signature

[05:04] <p6eval> rakudo c1f397: OUTPUT«Null PMC access in find_method()␤current instr.: '_block14' pc 74 (EVAL_10:41)␤»

[05:05] <TimToady> rakudo: &push.sig

[05:05] <p6eval> rakudo c1f397: OUTPUT«Null PMC access in find_method()␤current instr.: '_block14' pc 74 (EVAL_10:41)␤»

[05:05] <TimToady> ah well

[05:05] <frooh> ok

[05:05] <TimToady> pugs: &push.sig

[05:05] <p6eval> pugs: OUTPUT«*** No such method in class Sub: "&sig"␤    at /tmp/SRL4Uz7B7t line 1, column 1 - line 2, column 1␤»

[05:05] <frooh> so it doesn't work for now

[05:05] <TimToady> pugs: &push.signature

[05:05] <p6eval> pugs: RESULT«:($?1 is rw is ref, @?1 is copy)»

[05:05] <TimToady> there you go

[05:05] <frooh> but could I theoretically do this:

[05:05] <frooh> sub (&foo.sig) {...} ?

[05:06] <TimToady> no

[05:06] <frooh> er

[05:06] <frooh> signature*

[05:06] <TimToady> you can't eval expressions as parameters

[05:06] <frooh> is there a way I could do that?

[05:06] <frooh> because it would be cool

[05:07] <TimToady> what are you expecting it to mean?

[05:07] <frooh> I want to make a function from another function that has the same signature

[05:07] <frooh> I could of course use a slurpy thing, but that loses accuracy

[05:07] <TimToady> what would be the use of that?

[05:08] <frooh> to make a generalized cache closure thing...

[05:08] * frooh is going through Higher-Order Perl with perl6

[05:08] <TimToady> you can do smart matching on signatures

[05:08] <frooh> although I guess with perl6 you could just do &foo.wrap

[05:08] <TimToady> so there's probably a way to do it

[05:09] <frooh> I'll just use a slurp for now since that works

[05:18] *** tony_ is now known as FIRERILL

[05:19] *** FIRERILL is now known as firedrillll

[05:21] *** alester joined
[05:25] *** bacek left
[05:26] <frooh> will perl6 support prototype based OO?

[05:29] <skids> You mean multi-dispatch?

[05:29] <frooh> uhh

[05:30] <frooh> no, like, classless OO

[05:30] <frooh> sorry, I should have been more clear

[05:32] <TimToady> yes, smop is proto-based

[05:32] <frooh> smop?

[05:32] <frooh> super mega object prototypes?

[05:32] <TimToady> the thing ruoso and pmurias have been working on for most of the last year

[05:33] <TimToady> Simple Matter Of Programming :)

[05:33] <frooh> but regular class based OO is also supported right?

[05:34] <TimToady> yes

[05:34] <frooh> can we use both at the same time?  like make a class that inherits from a...smop object?

[05:34] <TimToady> either can be modeled on the other

[05:35] <frooh> awesome...

[05:35] <TimToady> all depends on how you set up the responder interfaces

[05:35] <frooh> I don't know what that means exactly, but I am excited anyway?

[05:36] <TimToady> this is all swept under the carpet of the object's .HOW metaobject

[05:36] <frooh> rakudo: my $f = 2; $f.HOW;

[05:36] <TimToady> which decides how to be an object

[05:36] <p6eval> rakudo c1f397: OUTPUT«get_bool() not implemented in class 'P6metaclass'␤current instr.: 'parrot;PCT;HLLCompiler;command_line' pc 1502 (src/PCT/HLLCompiler.pir:790)␤»

[05:37] <TimToady> strange error, but you see it's in the metaclass

[05:37] <frooh> yeah

[05:37] <frooh> rakudo: my @f = (1,2); @f.HOW;

[05:37] <p6eval> rakudo c1f397: OUTPUT«get_bool() not implemented in class 'P6metaclass'␤current instr.: 'parrot;PCT;HLLCompiler;command_line' pc 1502 (src/PCT/HLLCompiler.pir:790)␤»

[05:37] <frooh> eh, same, but still

[05:38] <TimToady> rakudo: [].HOW.methods

[05:38] <p6eval> rakudo c1f397: OUTPUT«Could not locate a method 'methods' to invoke on class 'P6metaclass'.␤current instr.: 'die' pc 16347 (src/builtins/control.pir:204)␤»

[05:39] <frooh> TimToady: I love how perl lets me do things that are crazy

[05:39] <frooh> thanks again

[05:39] <frooh> and perl6 will be even better

[05:39] <TimToady> we surely hope so

[05:42] <alester> ok, I think rakudo.org is kinda looking decent.

[05:43] <frooh> alester: if you want any input I think the *'s next to username and password might be a little redundant

[05:44] <alester> frooh: That is waaaaaay far down on my list of things to think, but thank you.

[05:44] <frooh> alester: yeah, I don't blame you.

[05:45] <alester> hey, the nav links only show up if I log in as admin

[05:45] <frooh> yeah, all I have is Recent posts

[05:54] <skids> rakudo: sub foo ($a, *@@s) { $a.perl.say; @@s.perl.say; }; foo(1) <== 1,2,3;

[05:54] <p6eval> rakudo c1f397: OUTPUT«Unable to parse multisig; couldn't find final ')' at line 1, near "@s) { $a.p"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[05:54] <skids> pugs: sub foo ($a, *@@s) { $a.perl.say; @@s.perl.say; }; foo(1) <== 1,2,3;

[05:54] <p6eval> pugs: OUTPUT«*** No compatible multi variant found: "&foo"␤    at /tmp/zm9P4pVytW line 1, column 52-68␤»

[05:57] <skids> Is that supposed to work eventually?  Or does *@@slurp preclude other params?

[05:58] <alester> ok how about now frooh 

[05:58] <frooh> nope

[05:59] <frooh> hust Search and Recent Posts

[05:59] <frooh> just*

[05:59] <alester> nope what?

[05:59] <alester> what were you expecting?

[05:59] <frooh> I figured you had more links

[05:59] <frooh> sorry

[05:59] <alester> you don't have blog posts in the right column?

[05:59] <alester> syndicate?

[05:59] <alester> search?

[06:00] <frooh> oh, yeah, those are there

[06:00] <frooh> you said nav links before...

[06:00] <frooh> so I thought you meant the Navigation panel on the left

[06:00] <frooh> oh

[06:00] <frooh> sorry

[06:00] <frooh> yeah

[06:00] <frooh> that's blank

[06:00] <frooh> Syndicate has only an RSS icon

[06:00] <frooh> Search is there

[06:00] <alester> ok

[06:01] <frooh> Recent blog posts is there

[06:02] <TimToady> std: sub foo ($a, *@@s) { $a.perl.say; @@s.perl.say; }; foo(1) <== 1,2,3;

[06:02] <p6eval> std 25634: OUTPUT«ok 00:02 35m␤»

[06:17] <pugs_svn> r25635 | lwall++ | [STD] fix ruoso++'s little nested package bug

[06:20] <skids> std: multi sub foo ($a, *@s where { .elems > 1 }) {...}

[06:20] <p6eval> std 25635: OUTPUT«ok 00:02 34m␤»

[06:20] <alester> wowI think I have found the theem I love

[06:23] <TimToady> std: module Foo { our sub bar($arg) { say $arg; }; module Bla { our sub bar() { say "ok 1"; } } }; say "1..2"; Foo::Bla::bar(); Foo::bar("ok 2\n");

[06:23] <p6eval> std 25635: OUTPUT«Undeclared names:␤     Foo::Bla::bar used at 1 ␤ Foo::bar used at 1 ␤ok 00:04 35m␤»

[06:24] * TimToady becomes professional thumb twiddler

[06:25] *** alester left
[06:27] *** mberends joined
[06:28] <TimToady> std: module Foo { our sub bar($arg) { say $arg; }; module Bla { our sub bar() { say "ok 1"; } } }; say "1..2"; Foo::Bla::bar(); Foo::bar("ok 2\n");

[06:28] <p6eval> std 25635: OUTPUT«Undeclared names:␤     Foo::Bla::bar used at 1 ␤ Foo::bar used at 1 ␤ok 00:04 35m␤»

[06:29] <TimToady> I don't understand why std changes its revision number out of sync with clobbering lex...

[06:31] <TimToady> std: module Foo { our sub bar($arg) { say $arg; }; module Bla { our sub bar() { say "ok 1"; } } }; say "1..2"; Foo::Bla::bar(); Foo::bar("ok 2\n");

[06:31] <p6eval> std 25635: OUTPUT«Undeclared names:␤     Foo::Bla::bar used at 1 ␤ Foo::bar used at 1 ␤ok 00:04 35m␤»

[06:36] <TimToady> std: module Foo { our sub bar($arg) { say $arg; }; module Bla { our sub bar() { say "ok 1"; } } }; say "1..2"; Foo::Bla::bar(); Foo::bar("ok 2\n");

[06:36] <p6eval> std 25635: OUTPUT«Undeclared names:␤     Foo::Bla::bar used at 1 ␤ Foo::bar used at 1 ␤ok 00:06 39m␤»

[06:50] *** Maghnus_ joined
[06:54] *** bacek joined
[06:56] <TimToady> std: module Foo { our sub bar($arg) { say $arg; }; module Bla { our sub bar() { say "ok 1"; } } }; say "1..2"; Foo::Bla::bar(); Foo::bar("ok 2\n");

[06:56] <p6eval> std 25635: OUTPUT«ok 00:04 35m␤»

[06:56] <TimToady> 'bout time...

[07:02] *** abra joined
[07:07] *** Maghnus left
[07:07] *** Maghnus_ is now known as Maghnus

[07:08] <mberends> TimToady: and what changed? clobbered lex without bumping std revision?

[07:08] <lambdabot> mberends: You have 1 new message. '/msg lambdabot @messages' to read it.

[07:18] *** aindilis` left
[07:20] *** szabgab left
[07:20] *** mikehh left
[07:20] *** mikehh joined
[07:22] *** kanru joined
[07:24] <mberends> @tell masak your further changes to the proto script look very good - I am very pleased with the result

[07:24] <lambdabot> Consider it noted.

[07:25] <TimToady> I imagine some cron job woke up and rm'd lex/

[07:25] <mberends> :)

[07:38] <dalek> rakudo: 9e24621 | (Stephen Weeks)++ | src/parser/actions.pm:

[07:38] <dalek> rakudo: Fix exception handlers to not catch control exceptions.

[07:38] <dalek> rakudo: Make exception handlers mark $! as handled.

[07:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9e24621747a6160d6907af30ac2222fc784416f2

[07:50] <pugs_svn> r25636 | lwall++ | [STD] added number category so we can use <number> for prefix:<+> extensibility

[07:51] <TimToady> @tell ruoso addition of number category to STD may or may not break mildew

[07:51] <lambdabot> Consider it noted.

[07:52] <TimToady> @tell pmurias addition of number category to STD may or may not break mildew

[07:52] <lambdabot> Consider it noted.

[08:11] *** firedrillll left
[08:16] *** justatheory left
[08:27] *** DemoFreak joined
[08:35] *** masak joined
[08:35] <mberends> masak: a very fine morning to you

[08:35] <masak> mberends: and an excellent on to you, sir.

[08:35] <lambdabot> masak: You have 1 new message. '/msg lambdabot @messages' to read it.

[08:35] <masak> @massage

[08:35] <lambdabot> mberends said 1h 11m 44s ago: your further changes to the proto script look very good - I am very pleased with the result

[08:36] <mberends> masak++

[08:36] <masak> mberends: but wait -- there's more.

[08:36] <mberends> ooh

[08:36] <masak> I have hacked up a configuration-file thing.

[08:36] <masak> not quite ready yet, but give me 5-10 minutes, and I'll push it.

[08:36] <masak> I was offline when I wrote it, so I need to test it first.

[08:37] <mberends> ok

[08:37] * masak digs in

[08:56] <masak> heh, there ought to be a way to identify 'checkpoints' in all the massive output we're suppressing, and turn those into little dots of progress in the proto output. :)

[08:56] <masak> that sounds too good not to attempt.

[08:56] <masak> ...later.

[08:57] * mberends likes dotty progress bars

[08:58] *** szabgab joined
[08:58] <masak> and we'll take the chance to vertically align the 'completed' messages.

[08:58] <masak> pretty++

[09:00] <mberends> not only pretty, problems will stand out visibly

[09:01] <masak> how so?

[09:03] * masak gets a build failure when removing the 'rakudo dir' conf pair from the config file

[09:03] <masak> hm.

[09:03] <mberends> generally, if verbose output is scrappy, we do not read it closely, but if it is tidy, the unexpected attracts the eye. a bit like the rationale for consistent source code indentation.

[09:03] *** c9s_ joined
[09:03] *** c9s left
[09:03] <mberends> RAKUDO_DIR points to the Test.pm file

[09:03] <masak> mberends: ah. but the only info you get from the dots is how quickly each step is going, not what the steps are.

[09:04] *** c9s_ left
[09:04] <masak> mberends: that did not compute. :)

[09:04] <masak> mberends: oh, well. I'll push what I have, since it works in the default case.

[09:04] *** c9s joined
[09:04] <masak> and then I'll fix the problem I just found.

[09:05] <mberends> ok. I'll pull that before spending most of the day offline

[09:06] <masak> pushed.

[09:06] <masak> please deconnect your $PARROT_DIR and try it.

[09:09] <mberends> sorry, that RAKUDO_DIR remark concerned Configure and Makefile. pulled.

[09:10] <masak> I sure hope it works for you. I find the new setup very nice to work with.

[09:10] <masak> things are a bit inconsistent in 'proto' and 'installer', however.

[09:10] <masak> consider it 'release early'.

[09:12] * mberends must get YAML::Syck, not a desirable dependency for a bootstrapper. isn't the required functionality simple enough to inline in proto?

[09:12] <masak> I'm of two minds about that.

[09:12] <masak> one the one hand, I agree fully about the dep.

[09:13] <masak> no deps at all would be swell.

[09:13] <masak> on the other hand, I don't think we should be reinventing configuration formats.

[09:13] <masak> or attempting our own YAML parsing.

[09:13] *** lisppaste3 left
[09:14] * mberends is up for the challenge of YAML parsing (lite)

[09:15] <masak> mberends: give it a go then.

[09:15] <masak> maybe we should aim for a very limited subset of it.

[09:15] <masak> right now we're only serializing a hash, after all.

[09:15] <mberends> agreed, will do during offline time

[09:16] <masak> excellent.

[09:16] <masak> please take into account all kinds of escaping that might occur.

[09:16] <masak> colons, newlines, quotes, possibly other things.

[09:17] <mberends> right. but we mainly have to read just what we previously wrote.

[09:17] <masak> aye.

[09:18] <masak> still, we don't want to be caught misparsing correct YAML.

[09:18] <masak> better to throw an error on things we recognize but explicitly don't handle.

[09:18] <mberends> aye

[09:25] * masak tries to install Parrot-inside-Rakudo

[09:29] *** abra left
[09:33] *** duke_leto joined
[09:35] *** mikehh left
[09:37] <mberends> parrot-inside-rakudo works well for me, and jnthn++ and pmichaud++ seem to have nailed the double-free bug in the fake executable too

[09:38] <masak> aye.

[09:39] <masak> 'faktecutable' should probably be a setting value too.

[09:39] <masak> perhaps even the default.

[09:40] <mberends> masak: an important question similar to one I asked eric256 several months ago: do you approve of proto/projects/lib and proto/projects/bin directories, to act as unification nodes for diverse projects? I would deeply appreciate a 'yes'.

[09:40] <masak> I've fixed the 'Rakudo dir not defined' issue, so if the Rakudo dir is not set, it now sets it and re-saves the config file. I'll push in a minute.

[09:41] <masak> mberends: unh.

[09:41] <masak> mberends: so you're talking about copying stuff out of their native git directories?

[09:42] <mberends> yes. each project's Makefile.in says what to copy in the 'install' target

[09:42] <masak> at present, I'm very reluctant to such an idea.

[09:43] <mberends> ok

[09:43] <masak> proto's goal, in my eyes, is to keep the stricture of the projects, while still alleviating much of the pain of having many lib/ dirs

[09:45] <masak> basically, your PERL6LIB changes around a lot when you install new Perl 6 projects, but proto keeps the tabs and tells you what to set it to.

[09:46] <mberends> the PERL6LIB growth and maintenance is what I don't like

[09:46] <masak> that's what proto'll take care of for you.

[09:47] <masak> but szabgab has expressed similar misgivings, so I'm not all made up on this point.

[09:47] <masak> by the way, one reason I added the config.proto and the 'Proto projects directory' setting, is so that I'll go dogfooding very soon.

[09:48] <masak> I'll also want the 'update' subcommand, so I'll have a one-stop way to update all my installed Perl 6 projects. :)

[09:48] <mberends> and even update rakudo

[09:49] <masak> mberends: yes, but remember that the default will be 'released rakudo'

[09:49] <masak> hm, I'll add that setting too.

[09:49] <masak> ...which means that we'll leave git as our primary way to get Rakudo.

[09:50] <mberends> there is lots of recent debate about what 'release' etc means. To me, it has to mean 'not broken according to *all* testing'

[09:50] <masak> aye.

[09:50] <masak> that's what we want.

[09:51] <masak> and if it;s proto's default, hopefully Perl 6 projects will have to align to that default. :)

[09:51] <masak> specifically November, which uses many bleeding-edge features.

[09:52] <mberends> I like the fact that the debate is beginning to look at expanding testing to beyond the spectests into some modules or projects. Some of our stuff would be good candidates.

[09:52] <masak> indeed.

[09:52] <masak> I know pmichaud and others have (at times) been wary not to break November when doing great merges.

[09:53] *** protorom joined
[09:53] <masak> that has helped a lot, I believe.

[09:53] <masak> at least that's the impression I get from the few occasion where such care has not been taken. :P

[09:53] <mberends> we shall need 100+ november scale test cases eventually

[09:53] <masak> November has a fair amount of tests.

[09:54] * mberends plans to expand Pod::Parser and its tests soon

[09:54] <masak> but the fact of the matter is, that as deficiencies in the spectest suite are discovered through November, they usually get assimilated into the spectest suite.

[09:54] * masak will keep expanding SVG though TDD

[09:57] <mberends> pmichaud wants spectest to remain as concise (and fast) as possible, but seemed interested in broader testing. When announcing Perl 6, TimToady said CPAN would be the ultimate test suite ;)

[09:57] <masak> mberends: one thing I'm lacking in the config.proto file right now is comments. I'd like to at least be able to give the allowed values for ever setting. so I think custom generation of the config.proto file is a good idea.

[09:58] <mberends> yes. good feature.

[10:00] * masak adds the settings 'Parrot revision', 'Rakudo revision' (both with possible values 'bleeding' and 'release'), 'Test when building', and 'Test failure policy'

[10:00] *** mikehh joined
[10:00] <masak> currently the defaults are 'bleeding', 'bleeding', 'no', and 'die', respectively.

[10:01] <masak> but the first two should eventually be 'release, and 'release'.

[10:02] <masak> hm, config.proto file versioning -- good idea or bad?

[10:02] <masak> maybe duck typing is enough? :)

[10:02] * masak tentatively goes with date versioning

[10:03] <masak> ISO 8601.

[10:03] <masak> please stop me if I'm overdesigning.

[10:03] *** szabgab left
[10:04] *** ejs joined
[10:04] * mberends goes with dates too, assuming ISO 8601 means YMD ordering

[10:05] <masak> 2009-02-28.

[10:05] <mberends> my favo[u]rite!

[10:05] <masak> :)

[10:06] <masak> YAML::Syck ASCII sorts the keys of the serialized hash.

[10:06] <masak> I'm not sure if I like that.

[10:06] <masak> would be nicer if they came in insertion order, methinks.

[10:06] *** szabgab joined
[10:06] <protorom> hi guys, just trying to install parrot-0.9.0 on OS-X and Configure.pl seems to be failing - no parrot_config gets produced :-(

[10:07] <protorom> during the tests I get the error: dyld: lazy symbol binding failed: Symbol not found: _rl_get_keymap

[10:07] <masak> protorom: could you nopaste the output you're seeing?

[10:07] <protorom> nopaste?

[10:07] <masak> http://sial.org/pbot/perl6

[10:07] <masak> :)

[10:08] <masak> see above URL.

[10:08] <mberends> Some hashes do preserve order, despite being hashes. We can probably use arrays and grep/map them instead.

[10:08] <protorom> coming up...

[10:09] <masak> mberends: aye, as long as it's easy to add settings when constructing the $config_info variable, I'm fine with it.

[10:09] <protorom> heres the output: http://sial.org/pbot/35283

[10:10] <szabgab> masak, and he is using the released tarball

[10:10] <masak> szabgab: aye.

[10:11] <masak> protorom: I'm on OS X too. I'll try the tarball and see if I get the same.

[10:11] <masak> I think it has worked before, here.

[10:11] * masak needs to go soon

[10:11] <szabgab> masak, I am getting him to download the svn

[10:11] <protorom> that was the tarball :-( I'm just checking out the svn repo now

[10:12] <masak> goodie.

[10:12] <masak> but the tarball should work, too.

[10:13] <mberends> masak: I need to go soon too. Can you send out a draft config.proto file?

[10:15] <masak> just a minute.

[10:16] <masak> pushed.

[10:16] <masak> it's all yours.

[10:17] <masak> mberends: during the day, I might sketch out an 'update' subcommand, if that's ok.

[10:17] <masak> I'll be mostly mucking around in 'installer'.

[10:17] <masak> (and in a branch)

[10:18] <mberends> very ok. pulled. hopefully see you later

[10:18] <masak> not today, I fear.

[10:18] <masak> but very possibly tomorrow.

[10:19] <mberends> ok

[10:19] <masak> thanks for great work on proto so far -- and see you tomorrow.

[10:19] <protorom> masak: still getting the same problem. do you know which version worked for you?

[10:19] <masak> protorom: the tarball, several times, I think.

[10:19] *** mberends left
[10:20] <masak> protorom: now might be a good time to file a Parrot Trac ticket.

[10:20] <masak> protorom: or to ask on #parrot on irc.perl.org

[10:20] * masak waves

[10:20] *** masak left
[10:21] <protorom> ok - thanks

[10:26] <szabgab> rakudo: my %h = ("a" => 2, "b" => 1); for %h.kv -> $k, $v { say "$k, $v" }

[10:26] <p6eval> rakudo 9e2462: OUTPUT«a, 2␤b, 1␤»

[10:27] <szabgab> rakudo: my %h = ("a" => 2, "b" => 1); for %h.kv.sort(:by keys) -> $k, $v { say "$k, $v" }

[10:27] <p6eval> rakudo 9e2462: OUTPUT«Statement not terminated properly at line 1, near "(:by keys)"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[10:27] <szabgab> how do I sort that ?

[10:31] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.kv.sort :by keys -> $k, $v { say "$k, $v" }

[10:31] <p6eval> rakudo 9e2462: OUTPUT«Statement not terminated properly at line 1, near ":by keys -"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[10:34] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.kv.sort -> $k, $v { say "$k, $v" }

[10:34] <p6eval> rakudo 9e2462: OUTPUT«a, b␤1, 2␤»

[10:34] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.kv.sort { $b <=> $a } -> $k, $v { say "$k, $v" }

[10:34] <p6eval> rakudo 9e2462: OUTPUT«Statement not terminated properly at line 1, near "-> $k, $v "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[10:35] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.kv.sort({ $b <=> $a }) -> $k, $v { say "$k, $v" }

[10:35] <p6eval> rakudo 9e2462: OUTPUT«Scope not found for PAST::Var '$b' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[10:35] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.kv.sort({ $^b <=> $^a }) -> $k, $v { say "$k, $v" }

[10:35] <p6eval> rakudo 9e2462: OUTPUT«2, 1␤a, b␤»

[10:38] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.kv.sort({ $^b.key <=> $^a.key }) -> $k, $v { say "$k, $v" }

[10:38] <p6eval> rakudo 9e2462: OUTPUT«Method 'key' not found for invocant of class 'Str'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[10:38] <szabgab> wayland76, thanks

[10:38] <wayland76> But I haven't answered the question yet :)

[10:39] *** duke_leto left
[10:39] <szabgab> oh you have an answer :-)

[10:39] <szabgab> cool

[10:39] <wayland76> I don't have one yet, but I'm getting closer :)

[10:39] <szabgab> great

[10:40] *** pmurias joined
[10:41] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.p.sort({ $^b.key <=> $^a.key }) -> $k, $v { say "$k, $v" }

[10:41] <p6eval> rakudo 9e2462: OUTPUT«Method 'p' not found for invocant of class 'Perl6Hash'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[10:41] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.pairs.sort({ $^b.key <=> $^a.key }) -> $k, $v { say "$k, $v" }

[10:41] <p6eval> rakudo 9e2462: OUTPUT«a  2, b    1␤»

[10:41] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.pairs.sort({ $^b.key cmp $^a.key }) -> $k, $v { say "$k, $v" }

[10:41] <p6eval> rakudo 9e2462: OUTPUT«b  1, a    2␤»

[10:42] <wayland76> Ok, that's the answer

[10:42] <wayland76> Does that work for you?

[10:43] <pmurias> TimToady: "echo 123 > file;perl viv file" prints --- '123' and it doesn't work for other simple programs too

[10:43] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[10:43] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.pairs.sort({ $^b.value cmp $^a.value }) -> $k, $v { say "$k, $v" }

[10:43] <p6eval> rakudo 9e2462: OUTPUT«a  2, b    1␤»

[10:43] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.pairs.sort({ .key }) -> $k, $v { say "$k, $v" }

[10:43] <p6eval> rakudo 9e2462: OUTPUT«a  2, b    1␤»

[10:43] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.pairs.sort({ .value }) -> $k, $v { say "$k, $v" }

[10:43] <p6eval> rakudo 9e2462: OUTPUT«b  1, a    2␤»

[10:43] <wayland76> Cool :)

[10:44] <wayland76> szabgab: That might be a shorter answer :)

[10:45] <szabgab> wayland76++

[10:45] <szabgab> will it be wayland77 now ?

[10:45] <wayland76> Well, that would mean that I was younger, and that could be useful :)

[10:46] <wayland76> After all, youth is wasted on the young :)

[10:46] <wayland76> (I was born in '76)

[10:46] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.sort({ .key }) -> $k, $v { say "$k, $v" }

[10:46] <p6eval> rakudo 9e2462: OUTPUT«a  2, b    1␤»

[10:47] <wayland76> rakudo: my %h = ("a" => 2, "b" => 1); for %h.sort({ .value }) -> $k, $v { say "$k, $v" }

[10:47] <p6eval> rakudo 9e2462: OUTPUT«b  1, a    2␤»

[10:47] <wayland76> ...and shorter :)

[10:47] *** misfotto joined
[10:48] <wayland76> szabgab: Btw, I have the specs on my computer, and I searched them with ack (which is grep but better), and first I searched for "sort", and read that section

[10:50] <wayland76> ...and then I searched for .kv, and read the bits in S02.  Of course, I already knew I wanted to ensure I was getting 2 Pairs instead of 4 Scalars, so that helped :)

[10:50] <wayland76> Anyway, I have work to do.  &

[10:56] *** misfotto left
[10:56] *** kidd joined
[11:11] <kidd> hi guys.  I'm trying to do my first perl6 scripts, and I can't find a way to execute external processes with system nor ``. I haven't found any docs about that.  Pointers to documentation are really welcome

[11:16] *** pmurias left
[11:26] <wayland76> http://perlcabal.org/syn/

[11:26] <wayland76> That link documents how Perl6 is *supposed* to work

[11:26] <wayland76> That way the guys writing code know what to write

[11:27] <wayland76> It seems to imply that `` works as always

[11:27] <wayland76> and that an alternative could be qqx/$cmd $arg1/

[11:28] <wayland76> Or, if you don't want interpolation, qx{cmd arg}

[11:28] <kidd> oh, then I must be doing something wrong... I'll keep reading. thanks for the pointers wayland76

[11:28] <wayland76> The relevant document is the one called S02

[11:28] <szabgab> kidd, go over this http://szabgab.com/perl6.html and let me anything that is not clear

[11:28] <szabgab> let me "know" ...

[11:28] <wayland76> Which you get to from the "Synopsis" link next to "2 Bits and Pieces"

[11:29] <wayland76> I hate it when I a word out :)

[11:29] *** protorom left
[11:29] <wayland76> rakudo: print `echo hi`

[11:29] <p6eval> rakudo 9e2462: OUTPUT«print requires an argument at line 1, near " `echo hi`"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[11:30] <wayland76> rakudo: print qx/echo hi/

[11:30] <p6eval> rakudo 9e2462: OUTPUT«Statement not terminated properly at line 1, near "/"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[11:30] <wayland76> rakudo: print qx/echo hi/;

[11:30] <p6eval> rakudo 9e2462: OUTPUT«Statement not terminated properly at line 1, near "/;"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[11:30] <wayland76> rakudo: print qx"echo hi";

[11:30] <p6eval> rakudo 9e2462: OUTPUT«Statement not terminated properly at line 1, near "\"echo hi\";"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[11:30] <wayland76> rakudo: print qq"echo hi";

[11:30] <p6eval> rakudo 9e2462: OUTPUT«echo hi»

[11:31] <wayland76> Well, I guess the sandboxing must work :)

[11:31] <wayland76> Anyway, bedtime for me &

[11:31] <kidd> gnight

[11:34] <bacek> @tell pmichaud I've made single version of REDUCEMETAOP. http://github.com/bacek/rakudo/blob/84c89cd194ad62be57bb7f6ce5e9acae79c4521d/src/builtins/assign.pir But I don't like it... It's too complex

[11:34] <lambdabot> Consider it noted.

[11:37] <bacek> @tell pmichaud and chained version is not short-circuiting anymore...

[11:37] <lambdabot> Consider it noted.

[11:37] *** szabgab left
[11:40] *** rindolf joined
[11:55] *** hercynium joined
[11:57] *** AzureStone left
[12:09] *** AzureStone joined
[12:13] *** rindolf left
[12:14] *** ejs left
[12:28] *** meppl joined
[12:41] *** c9s left
[12:41] *** c9s joined
[12:53] *** riffraff joined
[13:36] *** rindolf joined
[14:03] *** ZuLuuuuuu joined
[14:08] *** ZuLuuuuuu left
[14:10] *** Whiteknight joined
[14:10] *** aindilis joined
[14:34] *** jan_ left
[14:35] *** jan_ joined
[14:52] *** hercynium left
[14:58] *** brunoV joined
[15:04] *** pmurias joined
[15:08] *** jhorwitz joined
[15:11] *** rindolf left
[15:24] *** kanru left
[15:35] *** kanru joined
[15:37] *** kidd left
[15:40] *** rindolf joined
[15:43] *** kanru2 joined
[15:55] *** cibs joined
[16:00] *** hercynium joined
[16:08] *** kanru left
[16:11] *** Ariens_Hyperion joined
[16:13] *** SamB left
[16:16] *** abra joined
[16:17] *** SamB joined
[16:22] *** Kimtaro joined
[16:28] *** nihiliad joined
[16:35] <dalek> rakudo: 57a0cf4 | pmichaud++ | docs/spectest-progress.csv:

[16:35] <dalek> rakudo: spectest-progress.csv update: 315 files, 7084 passing, 0 failing

[16:35] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/57a0cf440d3649db1430412903384d82994dfeb7

[16:35] <dalek> rakudo: f7a7bf4 | pmichaud++ | tools/test_summary.pl:

[16:35] <dalek> rakudo: We no longer need the "[rakudo]:" part of the commit message.

[16:35] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f7a7bf491584f29def2316532f0203986d483704

[16:40] *** justatheory joined
[16:40] *** Kimtaro_ joined
[16:40] *** Whiteknight left
[16:41] *** Kimtaro_ left
[16:42] *** aindilis` joined
[16:53] *** riffraff left
[16:56] *** aindilis left
[16:58] *** Kimtaro left
[17:03] *** Tene_ joined
[17:05] *** duke_leto joined
[17:07] *** duke_leto left
[17:13] *** rindolf left
[17:16] *** Tene left
[17:21] <pugs_svn> r25637 | putter++ | [elfparse] Sketch in more ratcheting (subrules).

[17:26] *** mikehh left
[17:29] *** pmurias left
[17:38] *** meppl left
[17:42] *** justatheory left
[17:51] *** cognominal left
[17:53] *** meppl joined
[17:56] *** Kimtaro joined
[17:56] *** simcop2387 left
[17:58] *** cognominal joined
[18:05] *** mikehh joined
[18:08] *** protorom joined
[18:14] *** simcop2387 joined
[18:15] *** Southen_ joined
[18:20] *** Psyche^ joined
[18:20] <protorom> rakudo: help

[18:20] <p6eval> rakudo f7a7bf: OUTPUT«Could not find non-existent sub help␤current instr.: '_block14' pc 53 (EVAL_16:38)␤»

[18:22] *** rindolf joined
[18:30] *** Patterner left
[18:30] *** Psyche^ is now known as Patterner

[18:32] *** rindolf left
[18:33] *** Southen left
[18:45] *** abra left
[18:49] *** protorom_ joined
[18:49] *** rindolf joined
[19:07] *** protorom left
[19:12] *** mberends joined
[19:14] *** mberends left
[19:14] *** mberends joined
[19:14] *** mberends_ joined
[19:14] *** mberends_ left
[19:14] *** mberends left
[19:28] *** protorom_ left
[19:47] <dalek> rakudo: d4c266b | pmichaud++ | src/parser/actions.pm:

[19:47] <dalek> rakudo: Revert "Fix exception handlers to not catch control exceptions."

[19:47] <dalek> rakudo: This reverts commit 9e24621747a6160d6907af30ac2222fc784416f2,

[19:47] <dalek> rakudo: which was causing numerous spectests to fail.

[19:47] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d4c266ba9072844956b662bf5a3271fe761f6337

[19:49] *** protorom joined
[19:50] *** aindilis` left
[19:50] <skids> point of confusion -- when we get %h{...}:exists, will we still have %h.exists(...)?

[19:50] <pmichaud> I think the .exists(...) form goes away.

[19:50] <lambdabot> pmichaud: You have 3 new messages. '/msg lambdabot @messages' to read them.

[19:52] <skids> I'm looking for a definite answer, since that might have been people overinterpreting the demise of sub exists/exists(%h{...}).

[19:53] <pmichaud> neither ".exists" nor ".delete" appear in the synopses.

[19:54] <pmichaud> nor is there any mention of a subcall form.  To me, that'd be pretty good evidence that it's only :exists and :delete.

[19:55] <skids> Where is the notation of "method :name" documented?

[19:55] <pmichaud> I think that's pseudo-notation.

[19:56] <skids> Ahh, ahh, aHH no pseudo-notation allowed :-)

[19:56] <pmichaud> i.e., I think that's a bit more made-up, unless it's meant to be a longname form somehow.

[19:56] <pmichaud> I haven't been following the syntactic details on that very closely.

[19:57] <pmichaud> otoh, .exists does appear in the spectests

[19:57] <pmichaud> so.... I dunno.

[19:57] * pmichaud checks the svn revision history.

[19:58] <skids> Yeah my personal hypothesis until I find a definitive source is that the idea that .exists and .delete are going away as methods is a snowballing rumor.

[19:59] <pmichaud> argggh, I can't seem to review the log that far back.

[20:03] <pmichaud> the message at http://groups.google.com/group/perl.perl6.language/msg/879755d89f7115f1  says

[20:03] <pmichaud> Note also that existence and deletion are now simply adverbs on subscript

[20:03] <pmichaud> operators. 

[20:04] *** pmurias joined
[20:04] <pmichaud> and S12 used to have a "%hash.:exists{...}" form, which is now gone.

[20:05] <pmichaud> (as shown in that same message)

[20:07] <pmichaud> so, I'm pretty sure the method forms are no more -- they're just adverbs on subscripts.

[20:07] <skids> Well, that explains where the idea of "method :name" might have come from.

[20:08] <pmichaud> one thing that does concern me about S29/S32 is that they still show .grep, .join, etc as being methods on List and not Any

[20:08] <skids> To me that seems maybe reading a bit too much into it (and besides, when we implement something like them will be needed at least internal to the class, because we don't want a flag switch run every time in postcircumfix:<{ }>.

[20:09] <pmichaud> flag switch?  That's what mmd is for.

[20:09] <skids> The only reason to ditch the method form IMO would be if there's no way to elegantly reconcile .delete(), .delete, and zen slices.

[20:12] <skids> Sorry I was mentally bactracking :-)

[20:16] <pmichaud> anyway, a message to p6l is probably in order then.

[20:17] <skids> I'm not subbed there, I just can't handle mls these days.

[20:21] *** mikehh left
[20:23] *** pmurias left
[20:24] <skids> By the way since you're around -- is there supposed to be a way to add multis on top of stuff that's written in PIR yet?  Doing so naively didn't work for me.

[20:24] *** protorom left
[20:26] <pmichaud> there's not a way to do that yet, no.

[20:26] <pmichaud> it's one of the reasons where moving things from PIR into settings/

[20:26] <pmichaud> s/where/we're/

[20:27] <skids> In that case, maybe an example of a q:PIR in settings by someone who really knows what they are doing might help encourage things.

[20:27] <pmichaud> sure -- I just haven't had a chance to write that yet.  I spent most of the week working on getting our first release out.

[20:27] <skids> s/settings/setting/

[20:27] <pmichaud> (our first non-Parrot release, that is.)

[20:27] <skids> :-) I know we take and take and take... :-)

[20:30] *** viklund joined
[20:32] *** justatheory joined
[20:42] <skids> Speaking of MMD, I was looking into what future multidim stuff might look like to optimize common cases and having a few convenience methods for where {...} might make things less ugly.  like .dims instead of .shape.elems which might do too much math, and something that quickly checks whether all slices are .elems == 1 to pick out single value accesses.  I guess that's far down the road though.

[20:45] *** mikehh joined
[20:48] <diakopter> hm, ./viv doesn't seem to work the same as it once did

[20:50] <pmichaud> std:  if(3) { say 'hello'; }

[20:50] <p6eval> std 25637: OUTPUT«############# PARSE FAILED #############␤if() interpreted as function call at line 1 ; please use whitespace instead of parens␤Unexpected block in infix position (two terms in a row) at /tmp/eUeZz8RwQD line 1:␤------> [32mif(3) [31m{ say 'hello'; }[0m␤    expecting any of:␤ 

[20:50] <p6eval> ..in...

[20:51] <diakopter> if (3) { say 'hello' }

[20:51] <diakopter> std: if (3) { say 'hello' }

[20:51] <p6eval> std 25637: OUTPUT«ok 00:02 34m␤»

[20:51] <diakopter> ./viv doesn't give an ast anymore ?

[20:52] *** protorom joined
[20:53] *** PZt left
[21:03] <diakopter> std: sub if($a) { $a }; if (3) { say if(3) };

[21:03] <p6eval> std 25637: OUTPUT«ok 00:02 36m␤»

[21:07] <pmichaud> std:  say 'hello' if(3);

[21:07] <p6eval> std 25637: OUTPUT«############# PARSE FAILED #############␤Syntax error (two terms in a row?) at /tmp/6pLyiRgJ2t line 1:␤------> [32msay 'hello' if[31m(3);[0m␤    expecting nofun␤FAILED 00:02 34m␤»

[21:16] <diakopter> TimToady: around? I removed ->item from line 67 of viv and it spits out the ast again, although it doesn't read from stdin

[21:21] *** Whiteknight joined
[21:27] *** brunoV left
[21:30] <dalek> rakudo: 0bb4da5 | pmichaud++ | src/parser/grammar.pg:

[21:30] <dalek> rakudo: Slight STD convergence -- switch "rule statement" to "token statement"

[21:30] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0bb4da56b71ae0e7a05a0fd1bc35de4ac2f10e47

[21:30] <dalek> rakudo: dd9b61c | pmichaud++ | src/parser/grammar.pg:

[21:30] <dalek> rakudo: Some more parsing fixes.

[21:30] <dalek> rakudo: * Parse certain keywords followed by parens as subcalls.

[21:30] <dalek> rakudo: * change some {{-tests to use <?{{...}}> instead.

[21:30] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/dd9b61c4eb703c3c2795dffdb30300e6183d1534

[21:32] *** rindolf left
[21:40] *** wayland76 left
[21:44] *** SamB left
[21:46] *** protorom left
[21:46] *** SamB joined
[21:57] <skids> rakudo: multi sub f (%h where { .{'a'} == 1 }) { say "OH HAI" }; multi sub f (%h where { .{'a'} != 1 }) { say "O NOES" };  my %c = <a 1 b 2>; f(%c);

[21:57] <p6eval> rakudo dd9b61: OUTPUT«Method 'postcircumfix:{ }' not found for invocant of class 'Str'␤current instr.: 'postcircumfix:{ }' pc 3797 (src/classes/Associative.pir:77)␤»

[21:59] <pmichaud> that's kinda weird.

[21:59] <skids> rakudo: multi sub f (%h where { %^j{'a'} == 1 }) { say "OH HAI" }; multi sub f (%h where { %^j{'a'} != 1 }) { say "O NOES" };  my %c = <a 1 b 2>; f(%c);

[21:59] <p6eval> rakudo dd9b61: OUTPUT«Non-Associative argument for %j in call to _block30␤current instr.: 'die' pc 16347 (src/builtins/control.pir:204)␤»

[22:00] <pmichaud> rakudo:  multi sub f (%h where { .PARROT.say }) { say "OH HAI" };  my %c = <a 1 b 2>;  f(%c);

[22:00] <p6eval> rakudo dd9b61: OUTPUT«OH HAI␤»

[22:00] <skids> Actually the first one differs from what I get at the cl.

[22:00] <pmichaud> rakudo:  multi sub f (%h where { .PARROT.say }) { say "OH HAI" };  my %c = <a 1 b 2>;  %c.PARROT.say; f(%c);

[22:00] <p6eval> rakudo dd9b61: OUTPUT«Perl6Hash␤OH HAI␤»

[22:01] <pmichaud> rakudo:  multi sub f (%h is rw where { .PARROT.say }) { say "OH HAI" };  my %c = <a 1 b 2>;  %c.PARROT.say; f(%c);

[22:01] <p6eval> rakudo dd9b61: OUTPUT«Perl6Hash␤OH HAI␤»

[22:01] <skids> There I get "Could not find non-existent sub a" when using .{}

[22:01] <pmichaud> rakudo:  multi sub f (%h is rw where { .PARROT.say }) { say %h.perl };  my %c = <a 1 b 2>;  f(%c);

[22:01] <p6eval> rakudo dd9b61: OUTPUT«{"a" => "1", "b" => "2"}␤»

[22:01] <pmichaud> rakudo:  multi sub f (%h where { .PARROT.say }) { say %h.PARROT };  my %c = <a 1 b 2>;  f(%c);

[22:01] <p6eval> rakudo dd9b61: OUTPUT«ObjectRef->Perl6Hash␤»

[22:02] <pmichaud> I suspect a problem with the where invocation.

[22:02] <pmichaud> rakudo:  multi sub f (%h where { +$_ == 2 }) { say %h.PARROT };  my %c = <a 1 b 2>;  f(%c);

[22:02] <p6eval> rakudo dd9b61: OUTPUT«ObjectRef->Perl6Hash␤»

[22:02] <pmichaud> rakudo:  multi sub f (%h where { +$_ == 3 }) { say %h.PARROT };  my %c = <a 1 b 2>;  f(%c);

[22:02] <p6eval> rakudo dd9b61: OUTPUT«ObjectRef->Perl6Hash␤»

[22:03] <pmichaud> yes, the where clause looks like it's having trouble there.

[22:06] *** szabgab joined
[22:23] *** eternaleye joined
[22:25] <pmichaud> std:   sub f() { say 'foo' } if;

[22:25] <p6eval> std 25637: OUTPUT«Undeclared routine:␤   if used at 1 ␤ok 00:02 34m␤»

[22:26] <pmichaud> std:   sub f() { say 'foo' } if

[22:26] <p6eval> std 25637: OUTPUT«Undeclared routine:␤   if used at 1 ␤ok 00:02 34m␤»

[22:26] *** jhorwitz left
[22:29] <skids> So what is the class that is "something that is not a List" for MMD-on-return-value purposes?

[22:43] *** viklund left
[22:43] *** ZuLuuuuuu joined
[23:01] *** aindilis joined
[23:09] *** aindilis left
[23:09] *** aindilis joined
[23:14] * skids kinda wonders what's up with Hash::reverse, both in the Synopsis and as it has been copied there, the setting.

[23:16] <skids> I could understand gather for %hash.kv -> $k, $v { take $v, $k; } for use to reverse hash explosions in List::reverse but...

[23:17] <skids> with the value to key aliasing if someone wants that it shouldn't be called reverse

[23:17] <skids> s/that/the thing that is now implemented/

[23:18] <dalek> rakudo: 36314e0 | pmichaud++ | src/parser/grammar.pg:

[23:18] <dalek> rakudo: Refactor check for curly brace statement terminator.

[23:18] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/36314e0c34ae0695773eddbd0e317a96c816a9f0

[23:18] <dalek> rakudo: 1e22a68 | pmichaud++ | src/parser/grammar.pg:

[23:18] <dalek> rakudo: Fix RT #57876 -- if/while/unless/for/etc on line following closing brace

[23:18] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1e22a68aa5a037513ab1fb387631893625bdce6b

[23:34] <pmichaud> skids: I think that .reverse needs a substantial re-think.

[23:34] <pmichaud> I commented on this last year -- just a sec.

[23:36] <pmichaud> http://groups.google.com/group/perl.perl6.compiler/msg/ecf3018c5d9509fd

[23:41] <skids> Well, whatever is done in that respect, surely what we have now is dead wrong.

[23:42] <skids> rakudo: my %f = <a 2 b 2 c 3>; %f.reverse.say

[23:42] <p6eval> rakudo 1e22a6: OUTPUT«2  b3      c␤»

[23:49] *** ZuLuuuuuu left
[23:53] <skids> Yeah looking at this, hashes explode to pairs, in no particular order, unless fully flattened.  Since they have no guaranteed order between calls, reversing them makes no sense.  And you have sort.reverse using List's reverse if you really need it.  So Hash should not export reverse.

[23:54] <skids> Though it might be nice to have a less-computationally-intense-than-sort method that keeps order intact between modifications of the underlying data.

[23:54] <skids> That is, so long as it isn;t modified.

[23:55] <pmichaud> there might be some discussion about that in S09.

[23:56] <pmichaud> I could potentially see   method reverse() { self.kv.reverse; }

[23:57] <pmichaud> so that %hash.reverse doesn't end up being the same as   @(%hash).reverse

