[00:01] <skids> and a more overarching utilization of the word "constrain" comes to mind for that.

[00:03] <skids> e.g a sub that wants a Num generally wont try to use something exclusive to Int on it.

[00:03] <jnthn> Right.

[00:05] <sjohnson> will anyone mind if i do a /version on the channel

[00:05] *** ElectricHeavyLan left
[00:09] *** meppl left
[00:10] <jnthn> OK, sleep time for me...night all.

[00:11] <wayland76> 'night

[00:11] <wayland76> sjohnson: What does that do?

[00:12] <sjohnson> just tells me what irc client people use

[00:12] <sjohnson> and also hints at possible active perl users

[00:13] <sjohnson> by that i mean ActivePerl / win32 perl

[00:14] <sjohnson> for example, wayland76, i take it you use a KDE version for linux of some sort?

[00:14] <wayland76> Well, Kinda

[00:15] <wayland76> I'm using Fedora 10, and it has both gnome and KDE

[00:15] <wayland76> So I'm using Konversation, but I lean towards Gnome stuff as a general rule

[00:16] <sjohnson> you can run K* programs in gnome without a hitch mostly?

[00:16] * sjohnson didn't know this fact

[00:17] <sjohnson> i was worried that their software only worked on KDE desktops

[00:17] <wayland76> I don't use either desktop

[00:17] <wayland76> I use Enlightenment :)

[00:17] <sjohnson> i remember when that was pretty spectuclar about 10+ years ago

[00:17] <sjohnson> and i can only imagine it still use back when i was playing with slackware linux

[00:18] <wayland76> Well, E17 is pretty cool :).  But it's still not claiming to be production-ready

[00:18] <wayland76> That said, I've had few problems with the version I'm using

[00:18] <wayland76> The main problem is that the maximise button doesn't work, and you have to right click on the title bar and choose maximise from the menu.  Other than that it's fine

[00:19] <sjohnson> wayland76, do you have any bookmarked links handy for a good "perl 6" page that explains all the cool tricks you can do?

[00:19] <wayland76> Oh, but I have both desktops installed, so any libraries, etc, are there.  They're just not running (but the libraries are no doubt called upon by the relevant programs)

[00:20] <sjohnson> i read the wiki page and learned some stuff, but i don't believe it was exhaustive

[00:20] <wayland76> sjohnson: Not sure that I do; have you checked out http://www.perl6-projects.org/ ?

[00:21] <sjohnson> i think this is what i am looking for, ty

[00:21] <wayland76> That links to the specs, and the specs can be quite readable (ie. compared to W3C or IETF stuff)

[00:22] <wayland76> Also, if you're after more tutorial-format, readable stuff, we don't have any official stuff yet, but JDlugosz stuff is quite readable

[00:23] <wayland76> JDlugosz's stuff: http://www.dlugosz.com/Perl6/web/

[00:23] <sjohnson> is the Perl 6 butterfly an official mascot? or just some guys cute drawing

[00:24] <skids> s/some guy/larry/

[00:24] <wayland76> sjohnson: The disadvantage of not running KDE or gnome is that it makes your programs load slower

[00:24] <wayland76> yes, official mascot for the specs, the STD grammar, and the test suite, but not the implementations

[00:25] <sjohnson> it is cute

[00:25] <wayland76> I'd be unsurprised, though, if implementation logos incorporated Camelia somehow (that's the name of the butterfly)

[00:27] * skids thinks larry should "quietly" open a cafe press account :-)

[00:28] * wayland76 googles cafe press

[00:29] <wayland76> idea++ :)

[00:30] <sjohnson> looks like t-shirt custom design page

[00:30] *** fridim_ left
[00:32] *** ElectricHeavyLan joined
[00:38] *** lambdabot left
[00:38] * sjohnson rubs his hands together.. perl6!

[00:40] *** lambdabot joined
[00:42] <sjohnson> question:  will Perl 6 have mutator methods like ruby's exclamation mark methods?

[00:42] <sjohnson> for example... @array_to_be_shuffled.pick!(*);

[00:42] <sjohnson> or something

[00:43] <skids> Not sure exactly what those do...

[00:44] <sjohnson> they affect the object calling it

[00:45] <sjohnson> in ruby:   a = [1, 2, 3].shuffle

[00:45] <sjohnson> b = [1, 2, 3]

[00:45] <sjohnson> b.shuffle!

[00:45] <sjohnson> will be the same idea

[00:45] <sjohnson> the exclamation mark will change the object calling it

[00:46] <sjohnson> where as:   a[1,2,3].shuffle   #  will not shuffle a permenantly

[00:46] <sjohnson> shuffle is a cute word, btw

[00:48] <sjohnson> especially with it has a ! at the end of it

[00:50] <skids> I don't think there will be a consistent syntax throughout for it, but methods can modify their invocant and any parameter (as long as they prototype it as "is rw")

[00:50] <skids> And they can return an lvalue, too.

[00:52] <skids> Also, there are attributes:

[00:52] <skids> rakudo: class A { has $.a is rw }; my $a = A.new; $a.a = 4; $a.a.say

[00:52] <p6eval> rakudo 23718a: OUTPUT«4␤»

[00:52] <wayland76> sjohnson: Basically, yes.  S12 (section 12 of the Perl 6 specifcation) has a Mutating Methods section

[00:52] <wayland76> And that seems to do what you want

[00:53] <wayland76> eg. @array .= sort;

[00:56] *** DemoFreak left
[00:56] *** H1N1 joined
[00:56] <skids> Oh right, but it's not really a "mutating method" perse but an operator that invokes a normal method and assigns the return value.   Hrm, though could you MMD-specify that as a variant somehow for true in-place?

[00:57] <wayland76> Well, I'm sure the optimiser will do it in-place :)

[00:57] <skids> Eh.  I never put much faith in optimizers, butam always willing to be impressed. :-)

[00:57] *** lichtkind joined
[00:58] <wayland76> I never write anything big enough to worry about optimisation :)

[00:58] <wayland76> If it can't be written in a month, it won't happen :)

[00:58] <skids> e.g. maybe S12 should specify it to search for ($self is rw:) first...

[01:01] <skids> rakudo: my $b = 5; sub foo { $b }; foo() = 4; $b.say # shouldn't this require sub foo is rw?

[01:02] <p6eval> rakudo 23718a: OUTPUT«4␤»

[01:04] *** H1N1[A] left
[01:05] *** M_o_C left
[01:05] <skids> sjohnson: anyway, you were asking about %{@{%h{f}}} messiness... attributes pretty much mitigate the need for that.

[01:08] *** H1N1[A] joined
[01:08] <JDlugosz> I like the use of "constrain".

[01:08] <lambdabot> JDlugosz: You have 1 new message. '/msg lambdabot @messages' to read it.

[01:09] <sjohnson> skids, how pretty can it look?

[01:11] <skids> Well, assuming what you were using them for was class-like storage: $a.b<foo>.c[4]

[01:11] <sjohnson> hmm, ok here's another question

[01:13] <sjohnson> anyway to pretty this up?

[01:13] <sjohnson> sub foo {

[01:13] <sjohnson>   # accepts an array and an int

[01:13] <sjohnson>   my @array = @{shift(@_)};

[01:13] <sjohnson>   my $int = shift;

[01:13] <sjohnson> }

[01:16] *** H1N1 left
[01:16] <skids> rakudo: sub foo (@rray of Int is rw, $i of Int is rw) { $i = @rray.shift; }; my @a = <a b c>; my $stuff; foo(@a, $stuff); @a.perl.say; $stuff.perl.say 

[01:16] <p6eval> rakudo 23718a: OUTPUT«["b", "c"]␤"a"␤»

[01:17] *** sjohnson left
[01:24] *** eternaleye joined
[01:25] *** cognominal left
[01:27] *** cotto left
[01:28] *** cotto joined
[01:45] *** gabiruh joined
[01:46] *** Eevee left
[01:47] *** rewt left
[01:54] *** rewt joined
[01:54] *** nbrown joined
[01:58] *** rewt left
[01:59] *** Eevee joined
[02:04] *** sjohnson joined
[02:06] *** jonathanturner left
[02:19] <sjohnson> perl6: say 'hi';

[02:19] <p6eval> elf 26914, pugs, rakudo 23718a: OUTPUT«hi␤»

[02:21] <sjohnson> rakudo:  print  5.^methods

[02:21] <p6eval> rakudo 23718a: OUTPUT«ScalarabsabsACCEPTSperlpredsuccWHICH»

[02:21] <sjohnson> rakudo:  print  5.times { "hi" }

[02:21] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "{ \"hi\" }"␤in Main (src/gen_setting.pm:0)␤»

[02:22] <sjohnson> rakudo:  print  5.times { "hi"; }

[02:22] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "{ \"hi\"; }"␤in Main (src/gen_setting.pm:0)␤»

[02:22] <sjohnson> rakudo:  print "moose".^methods

[02:22] <p6eval> rakudo 23718a: OUTPUT«Null PMC access in inspect_str()␤in Main (src/gen_setting.pm:3166)␤»

[02:22] <eternaleye> rakudo: say "'hi' x 5

[02:22] <p6eval> rakudo 23718a: OUTPUT«say requires an argument at line 1, near " \"'hi' x 5"␤in Main (src/gen_setting.pm:2400)␤»

[02:22] <eternaleye> erg

[02:22] *** clintongormley left
[02:22] <eternaleye> rakudo: say 'hi' x 5

[02:22] <p6eval> rakudo 23718a: OUTPUT«hihihihihi␤»

[02:22] * skids grumbles something about "stop installing avahi-daemon on my system!"

[02:23] <sjohnson> rakudo:  print "moose".uc

[02:23] <p6eval> rakudo 23718a: OUTPUT«MOOSE»

[02:24] <eternaleye> rakudo: say "\c[WHITE SMILING FACE]"

[02:24] <p6eval> rakudo 23718a: OUTPUT«☺␤»

[02:24] <sjohnson> rakudo: if (0) { print "no"; } else { print "yes";}

[02:24] <p6eval> rakudo 23718a: OUTPUT«yes»

[02:25] <eternaleye> sjohnson: In p6, the idiom has evolved into leaving out the parentheses on if, for, etc

[02:25] <skids> rakudo: multi sub foo (Int $a) { "integer" }; multi sub foo (Num $a) { "number" }; my Int $a = 3; $a.foo; my Num $n = 5.4; $n.foo

[02:25] <p6eval> rakudo 23718a: OUTPUT«Method 'foo' not found for invocant of class 'Int'␤»

[02:25] <eternaleye> rakudo: if True { say "yes" } else { say "no" }

[02:25] <p6eval> rakudo 23718a: OUTPUT«yes␤»

[02:25] <skids> rakudo: multi sub foo (Int $a) { "integer" }; multi sub foo (Num $a) { "number" }; my Int $a = 3; $a.foo.say; my Num $n = 5.4; $n.foo.say; 

[02:25] <p6eval> rakudo 23718a: OUTPUT«Method 'foo' not found for invocant of class 'Int'␤»

[02:26] <sjohnson> rakudo:  if (1) print "hi";

[02:26] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "print \"hi\""␤in Main (src/gen_setting.pm:0)␤»

[02:26] <sjohnson> i wish that would be implemented

[02:26] <eternaleye> sjohnson: Curlies are mandatory now

[02:26] <sjohnson> they always were

[02:26] <sjohnson> but i can see why

[02:26] <eternaleye> If you want to omit them, you need the modifier form

[02:27] <eternaleye> rakudo: if 1 { say "hi" }

[02:27] <p6eval> rakudo 23718a: OUTPUT«hi␤»

[02:27] <eternaleye> rakudo: say "hi" if 1

[02:27] <p6eval> rakudo 23718a: OUTPUT«hi␤»

[02:27] <skids> rakudo: multi sub foo (Int $a) { "integer" }; multi sub foo (Num $a) { "number" }; my Int $a = 3; foo($a).say; my Num $n = 5.4; foo($n).say; 

[02:27] <p6eval> rakudo 23718a: OUTPUT«integer␤number␤»

[02:27] <sjohnson> how can you get a list of all the STDLIB methods and such for Perl 6

[02:28] <sjohnson> so i can see all the cool stuff it can do

[02:28] <sjohnson> rakudo:  print < 1 2 undef 3>.collapse

[02:28] <p6eval> rakudo 23718a: OUTPUT«Method 'collapse' not found for invocant of class 'List'␤»

[02:28] <sjohnson> rakudo:  print < 1 2 undef 3>.methods

[02:28] <skids> Well, a good amount of that is in flux, but it is Synopsis 32 (S32)

[02:28] <p6eval> rakudo 23718a: OUTPUT«Method 'methods' not found for invocant of class 'List'␤»

[02:28] <sjohnson> rakudo:  print < 1 2 undef 3>.^methods

[02:28] <p6eval> rakudo 23718a: OUTPUT«invoke() not implemented in class 'ResizablePMCArray'␤in Main (src/gen_setting.pm:3166)␤»

[02:29] *** Whiteknight left
[02:29] <skids> What's collapse?

[02:30] <eternaleye> say <1 2 undef 3>.grep: { $_ !~~ undef }

[02:30] <eternaleye> rakudo: say <1 2 undef 3>.grep: { $_ !~~ undef }

[02:30] <p6eval> rakudo 23718a: OUTPUT«12undef3␤»

[02:30] <skids> simon says :-)

[02:30] <eternaleye> rakudo: say <<1 2 { undef } 3>>.grep: { $_ !~~ undef }

[02:30] <p6eval> rakudo 23718a: OUTPUT«Use of uninitialized value␤123␤»

[02:30] <sjohnson> rakudo: say <1 2 undef 3>.grep { $_ !~~ undef }

[02:30] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "{ $_ !~~ u"␤in Main (src/gen_setting.pm:0)␤»

[02:31] <eternaleye> sjohnson: It doesn't work because it's the string "undef", not an undef value

[02:31] <eternaleye> And the colon is necessary

[02:31] <sjohnson> rakudo: say <1 2 undef 3>.grep (defined)

[02:31] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "(defined)"␤in Main (src/gen_setting.pm:0)␤»

[02:31] <sjohnson> it was worth a shot :)

[02:31] <eternaleye> rakudo: say <1 2 undef 3>.grep: { $_ !~~ "undef" }

[02:31] <p6eval> rakudo 23718a: OUTPUT«123␤»

[02:31] <sjohnson> what does the second squiggle do?

[02:32] <skids>  say <<1 2 { undef } 3>>.grep { .defined }

[02:32] <skids> rakudo: say <<1 2 { undef } 3>>.grep { .defined }

[02:32] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "{ .defined"␤in Main (src/gen_setting.pm:0)␤»

[02:32] <eternaleye> ~~ is smartmatch, ! negates it

[02:32] <eternaleye> =~ does not exist in P6

[02:32] <skids> rakudo: say <<1 2 { undef } 3>>.grep: { .defined }

[02:32] <eternaleye> Nor !~

[02:32] <p6eval> rakudo 23718a: OUTPUT«Use of uninitialized value␤123␤»

[02:32] <sjohnson> oh i see

[02:32] <sjohnson> does it work the same way?

[02:32] <sjohnson> or is it totally different

[02:32] <eternaleye> Yes, but more intelligent

[02:33] <skids> arguably too dwimmy for its own good :-)

[02:33] <eternaleye> so `my Dog $rover; say $rover ~~ Dog` checks ISA

[02:33] <eternaleye> Or 'does' really

[02:36] <sjohnson> rakudo:  say ("moose" =~ m/oo/);

[02:36] <p6eval> rakudo 23718a: OUTPUT«Unable to set lvalue on PAST::Val node␤in Main (src/gen_setting.pm:3166)␤»

[02:36] <sjohnson> rakudo:  say ("moose" ~~ m/oo/);

[02:36] <p6eval> rakudo 23718a: OUTPUT«oo␤»

[02:37] <eternaleye> std: say ("moose" =~ m/oo/);

[02:37] <p6eval> std 26914: OUTPUT«##### PARSE FAILED #####␤Obsolete use of =~ to do pattern matching; in Perl 6 please use ~~ instead at /tmp/bOdZQh9SJR line 1:␤------> [32msay ("moose" =~[31m m/oo/);[0m␤FAILED 00:04 36m␤»

[02:37] <sjohnson> rakudo:  say ("m00se" ~~ m/00/);

[02:37] <p6eval> rakudo 23718a: OUTPUT«00␤»

[02:37] <sjohnson> rakudo:  if ("m00se" ~~ m/00/) { say 1 } else { say 0 }

[02:37] <p6eval> rakudo 23718a: OUTPUT«1␤»

[02:38] <sjohnson> rakudo:  if ('00') { say 1 } else { say 0 }

[02:38] <eternaleye> sjohnson: It returns a Match object, which stringifies to the matched text and boolifies to whether the match succeeded

[02:38] <p6eval> rakudo 23718a: OUTPUT«1␤»

[02:38] <sjohnson> rakudo:  if ('0') { say 1 } else { say 0 }

[02:38] <p6eval> rakudo 23718a: OUTPUT«0␤»

[02:38] <sjohnson> rakudo:  if ('000') { say 1 } else { say 0 }

[02:38] <p6eval> rakudo 23718a: OUTPUT«1␤»

[02:39] <skids> rakudo: if (?'00') { say 1 } else { say 0 }

[02:39] <sjohnson> that's good to know

[02:39] <p6eval> rakudo 23718a: OUTPUT«1␤»

[02:39] <eternaleye> rakudo: say ("moose" ~~ m/oo/).WHAT

[02:39] <sjohnson> what does the ?'00' do?

[02:39] <p6eval> rakudo 23718a: OUTPUT«Match()␤»

[02:39] <skids> rakudo: if (+'00') { say 1 } else { say 0 }

[02:39] <p6eval> rakudo 23718a: OUTPUT«0␤»

[02:39] <eternaleye> sjohnson: Coerces it to a boolean value

[02:39] <skids> sjohnson: boolean context

[02:39] <sjohnson> is this new to perl?

[02:39] <sjohnson> i never came across that in 5 :(

[02:39] <eternaleye> sjohnson: '+' is for numbers, '~' is for strings

[02:39] * skids too tired to look up the str boolification spec.

[02:40] <eternaleye> sjohnson: Yes, it's new

[02:40] <eternaleye> Only in Perl 6!

[02:41] <eternaleye> rakudo: say (?'00').WHAT, ' ', (+'00').WHAT, ' ', (~'00').WHAT

[02:41] <p6eval> rakudo 23718a: OUTPUT«Bool() Num() Str()␤»

[02:41] <skids> rakudo: say "0002" ~| "1234"; say "0002" +| "1234";

[02:41] <sjohnson> is there anything Perl 6 can't do?

[02:41] <p6eval> rakudo 23718a: OUTPUT«1236␤1234␤»

[02:42] <skids> rakudo: say "0" ?| "1234";

[02:42] <p6eval> rakudo 23718a: OUTPUT«1␤»

[02:42] <eternaleye> sjohnson: Anything that isn't implemented yet can't be done currently; I'm not sure if there's anything (besides pimc, pifl, and pire) that the final result of the spec can't do

[02:43] <eternaleye> http://c2.com/cgi/wiki?PimcPiflPire

[02:43] <eternaleye> Well, it can't solve the Halting Problem, but nothing else ever will be able to either ;D

[02:44] <sjohnson> rakudo:  exit();

[02:44] <p6eval> rakudo 23718a:  ( no output )

[02:45] <sjohnson> rakudo:  say "im still running!"

[02:45] <p6eval> rakudo 23718a: OUTPUT«im still running!␤»

[02:45] <eternaleye> sjohnson: p6eval writes the command to a temporary file, and run()'s that.

[02:45] <TimToady> sjohnson: the answer to your earlier question is simply sub foo (%array, $int) {...}

[02:46] *** orafu left
[02:46] <TimToady> you use signatures instead of all that fancy shifting

[02:46] *** orafu joined
[02:47] <skids> TimToady: up late? s/%/@/ :-)

[02:47] <TimToady> it's always too late for me

[02:47] <TimToady> except when it's too early

[02:47] <skids> I feel EXACTLY the same way :-)

[02:48] <TimToady> but then you can simply call it foo(@x, 42)

[02:48] *** hercynium joined
[02:48] <TimToady> no need for \@x anymore

[02:49] <TimToady> rakudo: @a = 1..10; @a.=pick(*); say @a

[02:49] <p6eval> rakudo 23718a: OUTPUT«Symbol '@a' not predeclared in <anonymous> (/tmp/9ZThr2qVSa:1)␤in Main (src/gen_setting.pm:3166)␤»

[02:49] <TimToady> rakudo: my @a = 1..10; @a.=pick(*); say @a

[02:49] <p6eval> rakudo 23718a: OUTPUT«29673541810␤»

[02:49] <TimToady> there's your mutator

[02:50] <sjohnson> TimToady:  was saying (%array, $int) a mistake?  is % == hash?

[02:50] *** kirillm left
[02:50] <TimToady> @array

[02:50] <lambdabot> I'll crush ye barnacles!

[02:50] <eternaleye> rakudo: sub foo( @bar, $baz --> Str) { return ([~] @bar) x $baz; }; my @arr = <qux corge grault>; say foo( @arr, 3 );

[02:50] <p6eval> rakudo 23718a: OUTPUT«quxcorgegraultquxcorgegraultquxcorgegrault␤»

[02:51] <skids> about that, can you MMD a variant on the method end somehow for in-place, or must you override .=?

[02:51] <sjohnson> with all this new technology it looks like my Perl 5 book i got work to pay for will be used as a doorstop

[02:51] <sjohnson> the one written by Larry Wall and friends

[02:51] <TimToady> rakudo: sub foo (@array, $int) { say @array[$int] }; foo('a'..'z', 15)

[02:51] <p6eval> rakudo 23718a: OUTPUT«p␤»

[02:52] <eternaleye> sjohnson: Perl 6 isn't (quite) ready for replacing Perl 5 yet

[02:53] <sjohnson> rakudo:  print ('a'..'c').WHAT

[02:53] <TimToady> Perl 6 is trying to turn all the other books into doorstops; Perl 5 isn't special that way :)

[02:53] <p6eval> rakudo 23718a: OUTPUT«Range()»

[02:53] <sjohnson> rakudo:  print ('a'..'c')[1]

[02:53] <p6eval> rakudo 23718a: OUTPUT«b»

[02:53] <skids> Plus, you can embed p5 regexe syntax in P6, so you'll still need it to debug code where other people punted.

[02:53] * sjohnson is frothing at the mouth for the new Perl 6

[02:54] * sjohnson snarls loudly

[02:54] <sjohnson> are block comments too much to ask for instead of pods in Perl 6 that work even if there it whitespace before them?

[02:55] <TimToady> use #{.....}

[02:55] <TimToady> or #(...) or #[....] etc

[02:55] <sjohnson> do those work in Perl 5?

[02:55] <TimToady> or #<<<...>>>

[02:55] <TimToady> no

[02:55] <sjohnson> heheh

[02:56] <sjohnson> the camel book was a very entertaining and funny read

[02:56] <sjohnson> i have never laughed so hard reading a manual in my life

[02:56] <sjohnson> my brother doesnt seem to get the jokes tho

[02:56] <skids> or #« 

[02:57] <TimToady> maybe your brother should program in Python

[02:57] <sjohnson> he's a C programmer mostly

[02:57] <sjohnson> i showed him this new Perl 6 stuff after he was whining about a lot of things in Perl he didn't like

[02:57] <sjohnson> he seemed pretty impressed

[02:58] <sjohnson> rukado:  say `uname -a`

[02:59] <TimToady> rakudo: say qx/uname -a/

[02:59] <p6eval> rakudo 23718a: OUTPUT«Linux timtowtdi 2.6.18-6-686 #1 SMP Mon Aug 18 08:42:39 UTC 2008 i686 GNU/Linux␤␤»

[02:59] <sjohnson> back ticks a thing of the past?

[02:59] <TimToady> yes, too unreadable

[02:59] <TimToady> also, reserved for user-defined syntax

[02:59] <skids> sjohnson: reserved for user-defined uses.

[03:00] <JDlugosz> Hi Larry.  I saw your sub foo.

[03:00] <JDlugosz> lambdabot is still not giving me my messages though.

[03:00] <TimToady> case (in)sensitivity?

[03:01] <JDlugosz> Even when I copy/paste from its instructions to me.

[03:01] <sjohnson> TimToady:  a faster way to do:   @technology = split ('\n', qx/ps aux/);  ?

[03:01] <sjohnson> err.."\n" i mean

[03:02] <skids> Awww F'd didn't get into the spec yet? :-)

[03:02] *** cosimo left
[03:03] <TimToady> space not allowed before that (, by the way

[03:03] <sjohnson> who are you referring to?

[03:03] <TimToady> you

[03:03] <TimToady> split( not split (

[03:03] <sjohnson> that must be new, right?

[03:03] *** cosimo joined
[03:03] <TimToady> unless you want it parsed as a listop

[03:04] <TimToady> solves the p5 problem with print (1+2)*3

[03:04] <skids> One of those areas where parsing/unambiguity trumps convenience.

[03:05] <sjohnson> Question:  Perl 6 have anything like basename() or pathname()?

[03:06] <TimToady> IO specs still developing; ask wayland76 

[03:06] <sjohnson> rakudo:  say basename("/etc/passwd");

[03:06] <p6eval> rakudo 23718a: OUTPUT«Could not find non-existent sub basename␤»

[03:06] <sjohnson> rakudo:  say base("/etc/passwd");

[03:06] <p6eval> rakudo 23718a: OUTPUT«Could not find non-existent sub base␤»

[03:06] <sjohnson> *scratches head*

[03:08] <sjohnson> rakudo:  my $x = if 1 { 10 } else { 15 } }; say $x

[03:08] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "{ 10 } els"␤in Main (src/gen_setting.pm:0)␤»

[03:08] <sjohnson> rakudo:  my $x = if 1 { 10 } else { 15 } ; say $x

[03:08] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "{ 10 } els"␤in Main (src/gen_setting.pm:0)␤»

[03:08] <sjohnson> rakudo:  my $x = (if 1 { 10 } else { 15 }) ; say $x

[03:08] <p6eval> rakudo 23718a: OUTPUT«10␤»

[03:09] <sjohnson> wow

[03:09] <sjohnson> thats neat

[03:09] * sjohnson cracks open a beer

[03:09] <JDlugosz> TimToady I saw your example foo.

[03:10] <TimToady> you keep saying that

[03:10] <sjohnson> heh

[03:10] <JDlugosz> Had me worried, with no examples of that in the current document.

[03:10] <sjohnson> 'foo or foo()?

[03:10] <skids> wait.  isn't if supposed to return the conditional?

[03:10] <TimToady> that's p5

[03:10] <TimToady> p6 doesn't, so you can write list comprehensions

[03:11] <JDlugosz> So I'm on the right track, that actual arguments are taken one at a time to match with the positional parameters, but THEN it is taken as list context to bind it.

[03:11] <TimToady> huh?

[03:11] <JDlugosz> <http://www.dlugosz.com/Perl6/web/passing_examples.html>

[03:12] <TimToady> it switches to pulling slurpy terms out of the positions when it's done binding mandatory and optional

[03:12] <JDlugosz> Working it through, I ran into a problem with Nil and "item context".

[03:12] <JDlugosz> I know, slurpy evaluates arg list in list context.

[03:12] <TimToady> there is no list context until slurpy-binding starts

[03:14] <JDlugosz> sub foo (@y) { ... }

[03:14] <JDlugosz> foo(Nil);

[03:14] <JDlugosz> We want @y to be bound to an empty list, not wonder how to bind to undef.  Nil gives up the empty list in list context, not item context.

[03:14] <sjohnson> rakudo:  @a = <1 2 3>; print $a[0].WHAT, @a[0].WHAT;

[03:14] <p6eval> rakudo 23718a: OUTPUT«Symbol '@a' not predeclared in <anonymous> (/tmp/lwUunSC1az:1)␤in Main (src/gen_setting.pm:3166)␤»

[03:15] <sjohnson> rakudo:  use lenient;  @a = <1 2 3>; print $a[0].WHAT, @a[0].WHAT;

[03:15] <p6eval> rakudo 23718a: OUTPUT«Can't find ./lenient in @INC␤in Main (src/gen_setting.pm:438)␤»

[03:15] <sjohnson> rakudo:  my @a = <1 2 3>; print $a[0].WHAT, @a[0].WHAT;

[03:15] <p6eval> rakudo 23718a: OUTPUT«Symbol '$a' not predeclared in <anonymous> (/tmp/tm9ZLfbDcQ:1)␤in Main (src/gen_setting.pm:3166)␤»

[03:15] <TimToady> the meaning of Nil is not precisely driven by item/list, I think

[03:15] <sjohnson> rakudo:  my @a = <1 2 3>; print $a[0].WHAT; @a[0].WHAT;

[03:15] <p6eval> rakudo 23718a: OUTPUT«Symbol '$a' not predeclared in <anonymous> (/tmp/tlhbtjBVoP:1)␤in Main (src/gen_setting.pm:3166)␤»

[03:15] <sjohnson> rakudo:  my @a = <1 2 3>; print @a[0].WHAT;

[03:15] <p6eval> rakudo 23718a: OUTPUT«Str()»

[03:16] <TimToady> binding Nil to @y should still bind ()

[03:16] <sjohnson> rakudo:  my @a = 1, <2 3>; print @a.perl;

[03:16] <JDlugosz> TimToady: it should be... that's the point of having it.  Nil as an object replaces "undef in item context, () in list context" exactly in the description of what some construct does.

[03:16] <p6eval> rakudo 23718a: OUTPUT«[1, "2", "3"]»

[03:16] <sjohnson> rakudo:  my @a = 1, (<2 3>); print @a.perl;

[03:16] <p6eval> rakudo 23718a: OUTPUT«[1, "2", "3"]»

[03:16] <JDlugosz> The machiery of contextualizer DOES THAT.  Now you ignore that and come up with another way.

[03:17] <TimToady> Nil is really just (), and undef is only if forced to mean something non-arrayish

[03:17] <sjohnson> rakudo:  say Nil.WHAT

[03:17] <p6eval> rakudo 23718a: OUTPUT«Nil()␤»

[03:18] <sjohnson> rakudo:  say undef.WHAT

[03:18] <p6eval> rakudo 23718a: OUTPUT«Failure()␤»

[03:18] <sjohnson> rakudo:  say (0 == 1).WHAT

[03:18] <JDlugosz> It gets far worse with flattening Captures with extra levels of nesting.  The context thing works for that, as desgined.  It just needs to get invoked at the right moment.

[03:18] <p6eval> rakudo 23718a: OUTPUT«Bool()␤»

[03:19] <sjohnson> rakudo:  say qx/w/;

[03:19] <p6eval> rakudo 23718a: OUTPUT« 03:19:10 up 262 days, 14:24,  0 users,  load average: 0.89, 0.32, 0.20␤USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT␤␤»

[03:19] <TimToady> if it is at all possible to interpret Nil as as (), it does so

[03:19] <skids> rakudo: (1,2,3,Failure,4).say

[03:19] <JDlugosz> I've identified where the passing description needs to be updated to go along with the context/Capture stuff, and it's elegant enough.  You just can't mix up "non-slurpy" with "item context".  Contexualizers (now) tell delayed objects what they should be.

[03:19] <p6eval> rakudo 23718a: OUTPUT«123Failure()4␤»

[03:20] <sjohnson> TimToady:  is it true that pick(*) is the shuffle() function for Perl 6?

[03:20] <TimToady> sjohnson: how many times do you need to be told before you believe it?

[03:20] <sjohnson> i know it works, but i was wondering if there was... a TimToady way to shuffle as well planned

[03:20] <JDlugosz> So, knowing that foo (@x, @y, $z) {...}  foo(@list1,@list2,$x);  is supposed to work, unless I'm missing something big here, I'd like to "run with that".

[03:21] <TimToady> that is the TimToady way to shuffle

[03:21] <sjohnson> i was just wondering if it was the only TimToady way tho

[03:21] <JDlugosz> It is the contextualizer "step" that makes Nil become () as opposed to undef.

[03:21] <wayland76> rakudo: say qx/ls/

[03:21] <p6eval> rakudo 23718a: OUTPUT«build␤Configure.pl␤CREDITS␤docs␤LICENSE␤Makefile␤parrot␤perl6␤perl6.c␤perl6.o␤perl6.pbc␤perl6.pir␤perl6_s1.pbc␤rakudo_revision␤README␤src␤t␤Test.pir␤Test.pm␤tools␤␤»

[03:21] <sjohnson> other than writing your own function

[03:22] <skids> rakudo:  for (1,2,3,Failure,4) { say $_ if $_; }

[03:22] <p6eval> rakudo 23718a: OUTPUT«1␤2␤3␤4␤»

[03:22] <JDlugosz> So even if it is wrong to say the arg is "in list context", it needs to call that same step to trigger that.

[03:22] <skids> Oh, Failure is the class. duh.

[03:23] <sjohnson> TimToady:  i will take your silence as a yes

[03:23] <TimToady> more like "being used as a list/Positional" than list context, but yes

[03:24] <TimToady> certainly a lot of the Any methods are in a similar state

[03:24] <TimToady> you're using the invocant as a particular type, but this is implied by the method itself, as part of the langauge

[03:24] <JDlugosz> Discusions with ruoso beat into me that the contextualizer is not the same as expressing the desired interface.

[03:24] <TimToady> item/list context are not the only kinds of context

[03:24] <wayland76> sjohnson: The philosophy of Perl 6 is to get as many functions out of the core and into libraries as makes sense.  I suspect that basename et. al. will be some of those

[03:25] <sjohnson> rakudo:  <b c a a b c c c a b a>.uniq.sort.say

[03:25] <p6eval> rakudo 23718a: OUTPUT«abc␤»

[03:25] <wayland76> There will be multiple Perl6 "distros", one that packages Perl 6 with lots of modules for doing web stuff, one with modules for sysadmin, etc

[03:25] <TimToady> but yes, basically, which is why a Positional interpretation of Nil should result in () even in "item" context

[03:25] <JDlugosz> invocant as a particular type... I don't know what you're getting at.

[03:25] <wayland76> one of those distros will presumably include basename

[03:25] <sjohnson> wayland76:  if you are in charge of the basename stuff, please name a basedir too *putty dog eyes*

[03:26] * skids heads in for precious 4 hours sleep.  Gah.  Planned outage windows suuhuhuck.

[03:26] <TimToady> rakudo: say "foo".join

[03:26] <p6eval> rakudo 23718a: OUTPUT«foo␤»

[03:26] <TimToady> join is not a method of Str

[03:26] <wayland76> sjohnson: I'm not really in charge.  I just write the specs, which are then ignored or rewritten by the implementors

[03:26] <TimToady> nevertheless, we use it as a list

[03:26] <JDlugosz> That's where I was a couple days ago... context same as choosing an interface role.

[03:26] <TimToady> and it treats it as a list of 1 elem

[03:26] <sjohnson> wayland76:  well thanks for reading my request / question seriously

[03:27] <wayland76> Basically, I'm completely unqualified to do anything to the Specs except rearrange them (which I did), but I provoke others into writing them by doing a really bad job of writing something :)

[03:27] <sjohnson> rakudo: my @a = 1,2,3;  @a.pick(*); @a.say;

[03:27] <p6eval> rakudo 23718a: OUTPUT«123␤»

[03:27] <TimToady> you need .=

[03:27] <sjohnson> rakudo: my @a = 1,2,3;  @a .= pick(*); @a.say;

[03:27] <p6eval> rakudo 23718a: OUTPUT«231␤»

[03:28] <sjohnson> just making sure :)

[03:28] <wayland76> is your suggested "basedir" the same as "dirname" in File::Basename (Perl 5)?

[03:28] <JDlugosz> Hmm, wouldn't it have to be a method of some base class (Any is the ultimate base, right)?

[03:28] <JDlugosz> So the body of that decides what to do with "self".

[03:28] <TimToady> correct

[03:28] <sjohnson> if FIle is a CPAN module you need to download, then yeah...  i hate having to do basic good wholesome things with CPAN

[03:28] <sjohnson> cause i'm usually not a sudo user on many computers i dick around on

[03:28] <TimToady> the Any version of join makes it a language feature, not just an OO feature :)

[03:28] <wayland76> Well, on my system, File::Basename comes with Perl 5

[03:29] <skids> Some out of the box distros are lean on modules.

[03:29] * sjohnson slaps himself

[03:29] <sjohnson> wayland76, thanks tho

[03:29] <sjohnson> it is likely what i was looking for

[03:29] <JDlugosz> In terms of explaining what goes on under the hood, the Smalltalk model is simple.  Method call.  Simple dispatch.  "self" is easy. <G>

[03:30] <wayland76> skids: Yes, but File::Basename was first released with perl 5

[03:30] <wayland76> sjohnson: Just "use File::Basename" :)

[03:30] <wayland76> skids: In other words, it comes with Perl 5, and they'd have to remove it to get rid of it

[03:30] <TimToady> yes, but it would be redundant to reinvent Smalltalk

[03:31] <sjohnson> TimToady:  are you a vi(m) kind of guy?

[03:31] <TimToady> I use vim, though I think its API beyond the vi bits are rather ad hoc

[03:31] <JDlugosz> Are we agreed that in principle, as things are now with Contexts and Captures, that Nil is a fragile object that turns into undef (I guess Nill is an interesting instance of undef) or () when needed.  Right?

[03:32] <JDlugosz> One way of triggering that is with the contextualizers, @(...) etc.

[03:32] <TimToady> for some def or other 

[03:32] <sjohnson> vim stands for VI, a Man's editor

[03:32] <JDlugosz> So parameter binding would draw upon the same behavior of the object.  Or any other object that has context-sensitive behavior.

[03:32] <wayland76> I want something like Emacs, but with Perl6 instead of Elisp

[03:33] <wayland76> (and of course, supporting VI keyboard interface as an option :) )

[03:33] <wayland76> Well, actually, $Parrot_based_language instead of Elisp :)

[03:34] <JDlugosz> On the next computer over, my wife is talking to her folks in China on the webcam.  It's a connected world.  Where is everyone now on this channel?  I'm in Texas.

[03:34] <sjohnson> Question:  in pick(*), what is the astrisk?  is that a high-level globbing?  or a special reserved keyword that means all elements or something

[03:35] <wayland76> JDlugosz: Australia

[03:35] * sjohnson is in Canada and is 27 years old

[03:36] *** nsh- joined
[03:36] * TimToady is in San Diego this weekend

[03:37] <TimToady> but usually in Mountain View, CA

[03:37] <wayland76> The "*" character as a standalone term captures the notion of "Whatever" (quoted from S02)

[03:37] <sjohnson> say *.WHAT

[03:37] <sjohnson> rakudo:  say *.WHAT

[03:37] <p6eval> rakudo 23718a: OUTPUT«Whatever()␤»

[03:37] <sjohnson> rakudo:  say *.WHAT.^methods

[03:37] <p6eval> rakudo 23718a: OUTPUT«perlACCEPTSScalar␤»

[03:37] <TimToady> * means the operator gets to pick a "globby" default answer

[03:38] <JDlugosz> Hmm, I'm thinking, TimToady, that Nil is too simple of an example.  It =can= express a Positional role and be interesting undef all at the same time.  Ruoso's examples are more challanging.

[03:38] <wayland76> JDlugosz: You're not in the Dallas/Fort Worth area are you?

[03:38] <JDlugosz> Yes I am.  Allen to be exact.  You?

[03:38] <JDlugosz> (my neice is still scared of me.  Webcams have their downsides too)

[03:39] <wayland76> JDlugosz: Australia, as I said.  I was just thinking that there are already at least 3 other Perl6ers in the DFW area

[03:39] <JDlugosz> I mean, you have a connection with D/FW?

[03:40] <JDlugosz> I noticed notices on the mailing list today... didn't notice them before.

[03:40] <wayland76> No, other than that I hold US citizenship as well as Australian :)

[03:41] <wayland76> Btw, sjohnson, if you're really slavering with anticipation and unable to restrain yourself, you could redirect some of that unrestraint into one of the P6 implementations

[03:41] <TimToady> sjohnson: many of the uses of * actually indicate an indefinite/infinite number of elements

[03:41] *** orafu left
[03:41] <wayland76> Rakudo or SMOP

[03:42] *** orafu joined
[03:42] <TimToady> so 1..* is an infinite range

[03:42] <TimToady> and "yes" xx * is an infinite number of "yes" list elements

[03:44] <TimToady> but to other operations it can mean "all the elements" or "the number of elements"

[03:46] *** mikehh left
[03:47] <JDlugosz> Oh, question on the svn and synopses.

[03:47] *** skids left
[03:47] <JDlugosz> Is incrementing the Version and Last Modified automated?

[03:48] <TimToady> no

[03:49] <TimToady> I answered policy on that somewhere...

[03:49] <TimToady> okay to incr for typos but not necessary

[03:52] *** nsh left
[03:58] <sjohnson> wayland76:  how can i help?  the only way i can think of helping is suggesting quick and easy things that might not be obvious, but would bring substantial peace of mind to Perl programmers

[03:59] <JDlugosz> You can read my essays and tell me if anything needs improving re tutorials.

[04:00] <eternaleye> JDlugosz: phenny is an option that isn't lambdabot.

[04:00] <eternaleye> phenny: tell JDlugosz phenny is helpful

[04:00] <phenny> eternaleye: I'll pass that on when JDlugosz is around.

[04:00] <JDlugosz> I'm not the one leaving messages for me.

[04:00] <phenny> JDlugosz: 04:00Z <eternaleye> tell JDlugosz phenny is helpful

[04:00] <eternaleye> JDlugosz: No @clear'ing :D

[04:01] <sjohnson> p6 makes p5 look like stone-age technology.  i am really glad i came here!

[04:02] <sjohnson> and i mean that without trying to offend anyone, but i cant wait till a solid working Perl 6 implementation comes out

[04:03] <sjohnson> so i will do look over your things JDlugosz

[04:04] <sjohnson> well, here's a suggestion.  could $string.trim! be an alias for $string .= trim?

[04:04] <sjohnson> ala Ruby

[04:04] <wayland76> sjohnson: What are your skills?  Documentation?  C Programming?  Any Programming necessary (ie. willing to learn new language to help)?  Packaging?

[04:05] <wayland76> sjohnson: That's a question for TimToady, but even if he says no, you can define a slang that lets you do that if you want

[04:06] <sjohnson> by the ! mark i mean that p6 would recognize the ! as a .= of that method invocation, so you don't to define 100 more methods with the same name, except a ! after it

[04:07] <JDlugosz> sjohnson: consider that a challenge.  Write a macro for postfix:<!> that does that.  Learn enough to take a stab at it.

[04:07] <JDlugosz> (See my APL and Perl 6 essay to get ideas)

[04:08] <sjohnson> let's say I figured it out, someone stick it on the p6-bot so i could test it out?

[04:08] <sjohnson> s/someone/could someone/

[04:09] <eternaleye> rakudo: sub postcircumfix:<. !>( $var, &method ) { $var = $var.&method.() }; my $str = "   foo   "; say $str.trim!

[04:09] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "!"␤in Main (src/gen_setting.pm:0)␤»

[04:09] <eternaleye> pugs: sub postcircumfix:<. !>( $var, &method ) { $var = $var.&method.() }; my $str = "   foo   "; say $str.trim!

[04:09] <JDlugosz> I think tht would be a bit much for any existing implementation to handle.  And not a one-liner.

[04:09] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "!"␤    expecting term postfix, operator, ":" or ","␤    at /tmp/exv7I77nol line 1, column 106␤»

[04:09] <sjohnson> looks like eternaleye might be close to figuring it out

[04:10] <eternaleye> sjohnson: But postcircumfix custom operators are NYI.

[04:11] <sjohnson> wayland76: skills

[04:11] <sjohnson> 1.  Documentation / explaining difficult in a very informal yet informative way.

[04:11] <sjohnson> 2.  Programming in high-level languages.  Perl 5 and PHP (I hate PHP but don't mind that it has many functions out of the box).

[04:11] <sjohnson> 3.  Anally-retentive / perfectionist.

[04:11] <wayland76> sjohnson: You can download your own copy of Rakudo if you want

[04:11] <wayland76> sjohnson: Sounds like you need to help with documentation and maybe spec then

[04:12] <sjohnson> oh and 4.  Finding easier ways of doing the same old thing that everyone else has been doing for 15 years.

[04:13] <sjohnson> though it seems that  a lot of my ideas are already included in Perl 6

[04:13] <wayland76> sjohnson: U4X might be a good place.  http://svn.pugscode.org/pugs/docs/u4x/ and http://use.perl.org/~masak/journal/38279

[04:14] <wayland76> U4X = Userdocs for Christmas

[04:14] <wayland76> When people ask "When is Perl 6 coming out", we say "Christmas", but we don't say which year.

[04:14] <wayland76> Hence the tradition of referring to Perl 6.0.0 as "Christmas"

[04:15] <wayland76> masak (Carl Masak) is in charge of U4X

[04:15] <wayland76> and we expect some of JDlugosz's stuff to go in there too

[04:15] <literal> rakudo: say "hi"

[04:15] <p6eval> rakudo 23718a: OUTPUT«hi␤»

[04:16] <wayland76> (I think he said he was cool with the idea, anyway)

[04:16] <JDlugosz> Yes, I'm cool.  I want generations of newbes to ponder how to say my name.

[04:17] <sjohnson> J. D. Lugozi

[04:17] <sjohnson> is my guess

[04:17] <sjohnson> sounds like Bela Lugosi

[04:17] <TimToady> I have a pretty good notion how it sounds, if you pronounce it the olde way :)

[04:19] <TimToady> the initial consonant cluster will, of course, stump most native English speakers

[04:19] <JDlugosz> No sjohnson, The L is actually a Ł, but that's hard to type.

[04:19] <eternaleye> sjohnson: No, he's John M Dlugosz

[04:19] <JDlugosz> It's not a consonant at all.

[04:19] <TimToady> well, laterals are always a liitle of both

[04:20] <JDlugosz> <http://www.dlugosz.com/Me/index.html>

[04:20] *** sjohnson is now known as DoGuess

[04:20] <DoGuess> this would help others out :)

[04:21] <JDlugosz> I like to eat (and make) pierogi, but I can't properly pronounce any of the consonants in it.

[04:21] *** DoGuess is now known as sjohnson

[04:21] <sjohnson> TimToady:  do you have any thoughts on the ! ruby exclamation mark self-invocation idea?

[04:23] <TimToady> I prefer to unify with the other mutating assignment operators

[04:23] <TimToady> and reserve ! for factorial :)

[04:23] *** mikehh joined
[04:23] <JDlugosz> Hmm, I need a favicon for my web pages.

[04:23] <TimToady> rakudo: sub postfix:<!> ($n) { [*] 1..$n }; say 5!

[04:23] <sjohnson> $string .= trim;  =>  $string.trim!

[04:24] <p6eval> rakudo 23718a: OUTPUT«120␤»

[04:24] <TimToady> so I think the Ruby notation is a dead end

[04:25] <sjohnson> wow you sure write really short code

[04:25] * sjohnson looks at the line with a stern eye

[04:25] <wayland76> sjohnson: That's what happens when you have the specs in your head

[04:26] <wayland76> The [] puts the * operator between all of the 1..$n

[04:26] <eternaleye> wayland76: He no need can haz spec, he iz spec!

[04:26] <wayland76> (in this case)

[04:26] *** nbrown_ joined
[04:26] <sjohnson> is that like a eval(join type thing?

[04:26] <wayland76> eternaleye: Well, that's true, but I was trying to indicate to sjohnson that he might be able to achieve short code too :)

[04:26] <eternaleye> sjohnson: It's the reduction operator, like foldr in haskell IIRC

[04:27] <wayland76> sjohnson: Well, kind of, if you want to think of it in Perl 5 terms

[04:27] <TimToady> it's supposed to work the same as eval join but without the eval or the join

[04:27] <eternaleye> [op] list, for any op, means to apply 'op' infixed between all items of the list

[04:28] <sjohnson> rakudo:  say <a b c>.[uc()]

[04:28] <p6eval> rakudo 23718a: OUTPUT«No applicable candidates found to dispatch to for 'uc'␤in Main (/tmp/0LyEso4V08:1)␤»

[04:28] <eternaleye> so if [<] @list checks if @list is in strict ascending order

[04:28] <sjohnson> im probably going to break the compiler one of these days with bad syntax

[04:28] <wayland76> sjohnson: [] only works on operators.  There's a function called "reduce" that does the same thing on functions

[04:29] <wayland76>  say <a b c>.reduce(uc())

[04:29] <wayland76> rakudo say <a b c>.reduce(uc())

[04:29] <eternaleye> rakudo: say <a b c>.map( *.uc )

[04:29] <p6eval> rakudo 23718a: OUTPUT«ABC␤»

[04:29] <wayland76> thanks

[04:29] <wayland76> rakudo: say <a b c>.reduce(uc())

[04:29] <p6eval> rakudo 23718a: OUTPUT«No applicable candidates found to dispatch to for 'uc'␤in Main (/tmp/dAcq78kugB:1)␤»

[04:29] <wayland76> rakudo: say <a b c>.reduce(*.uc)

[04:29] <p6eval> rakudo 23718a: OUTPUT«Cannot reduce() using a unary or nullary function.␤␤»

[04:30] <sjohnson> rakudo:  say <a b c>.reduce(uc)

[04:30] <p6eval> rakudo 23718a: OUTPUT«No applicable candidates found to dispatch to for 'uc'␤in Main (/tmp/Z9RFmyDxgp:1)␤»

[04:30] <eternaleye> rakudo: say <a b c>.reduce( cmp )

[04:30] <p6eval> rakudo 23718a: OUTPUT«Could not find non-existent sub cmp␤»

[04:30] <eternaleye> rakudo: say <a b c>.reduce( <=> )

[04:30] <p6eval> rakudo 23718a: OUTPUT«Parameter type check failed; expected something matching Code() but got something of type Str() for $expression in call to reduce␤in method Any::reduce (src/gen_setting.pm:93)␤called from Main (src/gen_setting.pm:3166)␤»

[04:30] <eternaleye> rakudo: say <a b c>.reduce( &infix:<cmp> )

[04:30] <wayland76> rakudo: say <a b c>.[cmp]

[04:30] <TimToady> you can' t hang bare operators out there as terms

[04:30] <p6eval> rakudo 23718a: OUTPUT«Null PMC access in find_method()␤in Main (src/gen_setting.pm:3166)␤»

[04:30] <p6eval> rakudo 23718a: OUTPUT«Could not find non-existent sub cmp␤»

[04:31] <TimToady> cmp is non associative

[04:31] <eternaleye> rakudo: say <a b c>.reduce( &infix:<lt> )

[04:31] <p6eval> rakudo 23718a: OUTPUT«Null PMC access in find_method()␤in Main (src/gen_setting.pm:3166)␤»

[04:31] <TimToady> that would be a bug

[04:32] <TimToady> say <a b c>».uc

[04:32] <TimToady> rakudo: say <a b c>».uc

[04:32] <p6eval> rakudo 23718a: OUTPUT«ABC␤»

[04:32] <sjohnson> shit my utf-8 isnt working

[04:32] <sjohnson> i cant see what he did

[04:32] <Infinoid> sjohnson: >>

[04:33] <sjohnson> (<A B C>) >>.uc

[04:33] <TimToady> utf-8 is pretty much a necessity on this channel

[04:33] <sjohnson> rakudo: say (<A B C>) >>.uc

[04:33] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near ">>.uc"␤in Main (src/gen_setting.pm:0)␤»

[04:33] <TimToady> can't have a space before a postfix!!!

[04:33] <sjohnson> rakudo: say (<A B C>)>>.uc

[04:33] <p6eval> rakudo 23718a: OUTPUT«ABC␤»

[04:33] <TimToady> rakudo: say <a b c>>>.uc

[04:33] <p6eval> rakudo 23718a: OUTPUT«ABC␤»

[04:33] <Infinoid> nice.

[04:33] <sjohnson> oops

[04:33] <sjohnson> i forgot to make the letters small

[04:34] <sjohnson> this perl 6 stuff is something else

[04:35] <eternaleye> rakudo: sub infix:<ö>( $l, $r ) { say "$l »ö« $r"; }; <Camelia Rose> »ö« <butterfly bumblebee>

[04:35] <p6eval> rakudo 23718a: OUTPUT«Camelia »ö« butterfly␤Rose »ö« bumblebee␤»

[04:35] <TimToady> rakudo: my $x = "uc"; say <a b c>>>."$x"

[04:35] <p6eval> rakudo 23718a: OUTPUT«ABC␤»

[04:35] <eternaleye> Wait, when did unicode hypers start working? :D

[04:35] <TimToady> rakudo: my $x = "uc"; my @x = <a b c>; @a>>.="$x"; say @a

[04:36] <p6eval> rakudo 23718a: OUTPUT«Symbol '@a' not predeclared in <anonymous> (/tmp/d8cGXp9I4z:1)␤in Main (src/gen_setting.pm:3166)␤»

[04:36] <TimToady> rakudo: my $x = "uc"; my @a = <a b c>; @a>>.="$x"; say @a

[04:36] <p6eval> rakudo 23718a: OUTPUT«ABC␤»

[04:36] <TimToady> there's one reason to use .= instead of !

[04:36] <TimToady> the ! would get lost after the quote

[04:38] <sjohnson> i think i can agree with you there

[04:39] <sjohnson> hmm

[04:39] <sjohnson> what if you knew you wanted to mutate it with a !, wouldn't you just make "uc!" string, and call it with a period still/

[04:39] <sjohnson> ?

[04:40] <TimToady> that changes the types

[04:40] <eternaleye> buubot: spack Junction

[04:40] <buubot> eternaleye: S02-bits.pod:5 S03-operators.pod:3 S06-routines.pod:1 S09-data.pod:4 S29-functions.pod:13

[04:41] <TimToady> you really shouldn't be calling a method with such different semantics invisibly

[04:41] <sjohnson> i think i will be just as happy with .= anyway

[04:41] <TimToady> it is much more extensible

[04:42] <TimToady> most of the places where Ruby has "cute" syntax tend to interfere badly with extensibility

[04:43] <TimToady> the spots where Perl 6 looks slightly klunkier are that way for a good reason, in general

[04:43] *** nbrown left
[04:43] *** nbrown_ is now known as nbrown

[04:44] *** justatheory joined
[04:44] <sjohnson> thank godness perl is free

[04:44] <sjohnson> as i use it a lot for day to day things

[04:45] <sjohnson> and it's on every unixy system i go to

[04:45] *** sri_kraih joined
[04:47] <sjohnson> anyone here like shooting pool?

[04:47] <wayland76> Was Hæl Larry!

[04:47] <TimToady> nah, the bullets slow down too fast in water

[04:47] <wayland76> (I was thinking of dead fish)

[04:48] <sjohnson> heh

[04:48] <wayland76> It kinda takes the sport out of the fishing, though :)

[04:48] <sjohnson> or young kids with goggles

[04:48] <TimToady> not nearly as much as dynamite

[04:48] <wayland76> sjohnson: Yes, but I only do it once every 5-10 years

[04:49] <wayland76> Hmm.  Have we just designed a new computer game? :)

[04:49] <TimToady> my wife is sure that game exists already embedded in some other game

[04:53] <sjohnson> alright guys thanks for chatting

[04:53] <sjohnson> gonna go play a game of pool with my shotgun

[04:53] <sjohnson> CYA!

[04:54] *** sjohnson left
[05:01] *** cognominal joined
[05:22] *** cognominal left
[05:23] *** davidad joined
[05:49] *** sjohnson joined
[05:51] <sjohnson> pugs:  my $x = ( if (1) { 5 } else { 10 } );  print $x;

[05:51] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "$x"␤    expecting "=", expression, ")", context, ":" or "("␤    postfix op␤    at /tmp/4rBlMEvu0J line 1, column 4␤»

[05:51] <sjohnson> whats the one with the r again

[05:51] <sjohnson> should be in the topic maybe

[05:51] <sjohnson> rutaku or something

[05:54] <wayland76> Rakudo?

[05:54] <wayland76> We had a really long topic, so we replaced it with http://perl6-projects.org/

[05:54] <sjohnson> rakudo: my $x = ( if (1) { 5 } else { 10 } );  print $x;

[05:54] <p6eval> rakudo 23718a: OUTPUT«5»

[05:55] <sjohnson> i wonder why pugs cant do that line

[05:55] *** justatheory left
[05:55] *** ashizawa joined
[05:59] <sjohnson> rakudo:  @list = 1,2,3;  print @list[1];

[05:59] <p6eval> rakudo 23718a: OUTPUT«Symbol '@list' not predeclared in <anonymous> (/tmp/yeMfwAIWky:1)␤in Main (src/gen_setting.pm:3166)␤»

[05:59] <sjohnson> rakudo:  my @list = 1,2,3;  print @list[1];

[05:59] <p6eval> rakudo 23718a: OUTPUT«2»

[06:02] <sjohnson> rakudo: say qx/whoami/;

[06:03] <p6eval> rakudo 23718a: OUTPUT«evalenv␤␤»

[06:04] *** lichtkind_ joined
[06:07] <sjohnson> is TimToady in bed?

[06:09] <TimToady> I'll never tell

[06:11] <TimToady> pugs: my $x = do if 1 { 5 } else { 10 }; print $x

[06:11] <p6eval> pugs: OUTPUT«5»

[06:11] <TimToady> the () syntax is more recent

[06:15] <sjohnson> TimToady: can you field this question for my brother who programs in C

[06:16] <sjohnson> (11:04:36 PM) [email@hidden.address] make it so you dont have to have  { }

[06:16] <sjohnson> (11:04:38 PM) [email@hidden.address] after an if

[06:16] <sjohnson> (11:04:44 PM) [email@hidden.address] it really annoys me.

[06:16] <sjohnson> (11:04:55 PM) [email@hidden.address] just wanna be able to say

[06:16] <sjohnson> (11:05:08 PM) [email@hidden.address] if $x print $var;

[06:16] <sjohnson> his response to just reversing it and putting the "if" after he knows, but says it's not what he wants

[06:19] <sjohnson> if ($var) print "hi!";

[06:21] *** lichtkind left
[06:24] <wayland76> sjohnson: There are many other short ways to do this kind of thing in perl

[06:25] <wayland76> rakudo: 1 and print "hi";

[06:25] <p6eval> rakudo 23718a: OUTPUT«hi»

[06:25] <wayland76> rakudo: 0 and print "hi";

[06:25] <p6eval> rakudo 23718a:  ( no output )

[06:28] <sjohnson> i take it Larry knows about this and probably has his own opinion as to why that wont work without the { }

[06:29] <sjohnson> thanks wayland76 tho, i didnt know about that trick

[06:29] <wayland76> You can also do ...

[06:29] <wayland76> rakudo: 0 or print "hi"

[06:29] <p6eval> rakudo 23718a: OUTPUT«hi»

[06:29] <wayland76> rakudo: 1 or print "hi"

[06:29] <p6eval> rakudo 23718a:  ( no output )

[06:30] <sjohnson> rakudo:  1 && print "hi"

[06:30] <p6eval> rakudo 23718a: OUTPUT«hi»

[06:30] <wayland76> I learned it from open(FILE, "filename") or die "message";

[06:30] <sjohnson> wayland76: are && and "and" the same?  or do they have some other differences

[06:30] <wayland76> different predence level

[06:30] <wayland76> "and" is very low, "&&" is the same as C

[06:31] <wayland76> I just always use "and", these days, because it's usually what I mean anyway

[06:31] <sjohnson> if i use ($var) && "print hi";

[06:31] <sjohnson> for simple things like that, it's okay?

[06:32] <sjohnson> cause i will likely forget if i should use && or and

[06:32] <wayland76> Well, if in doubt, you can always put parentheses in

[06:32] <sjohnson> i usually always do

[06:32] <wayland76> Yeah, && works well most of the time

[06:32] <sjohnson> i can never remember the order of operations

[06:33] <wayland76> About the only time it would make a difference is if you did something like $b = $a && $c = 1

[06:33] <wayland76> and yes, those are assignments there

[06:34] <sjohnson> you can do that in perl 6?

[06:34] <wayland76> I just think "and" is more readable, and more likely to be what I want, so I always use that

[06:34] <sjohnson> assign two vals in one statement?

[06:34] <wayland76> Well, that's Perl 5

[06:34] <wayland76> I don't know if you can in Perl6

[06:34] <sjohnson> oh

[06:34] <sjohnson> i see what you are doing

[06:34] <wayland76> It's probably a bad way to program

[06:35] <sjohnson> you are essentially doing if ($b = a$a) { $c = 1 }

[06:35] <wayland76> but it's an example of where there'd be a difference

[06:35] <sjohnson> err, $b = $a

[06:35] <sjohnson> something like that

[06:35] <wayland76> Well, the example I gave would be $b = ($a && $c = 1)

[06:36] <wayland76> Whereas you might want ($b = $a) and ($c = 1)

[06:36] <wayland76> The whole thing would be in an if statement or something

[06:36] <wayland76> (those two commands I wrote on the previous lines are the same with and without ()

[06:37] <wayland76> That first should maybe have been $b = ($a && $c) = 1 

[06:37] <sjohnson> hopefully i will never have to be that expressive when i program myself

[06:37] <wayland76> which would be really confusing.

[06:37] <wayland76> That first should maybe have been $b = (($a && $c) = 1 )

[06:37] <wayland76> Well, it's probably a bad idea all around, but we needed an example :)

[06:38] *** frew|work joined
[06:38] <wayland76> might also make a difference in if($a, $b and $c, $d) {...}

[06:38] <wayland76> Oh, wait, I think I remember who it's bad

[06:39] <wayland76> or good

[06:39] <wayland76> $a = $b && $c # does what you want here

[06:39] <wayland76> $a = $b and $c; # always sets $a to $b

[06:39] <wayland76> I think, anyway

[06:40] <wayland76> So it doesn't always do what you want :)

[06:43] <sjohnson> in that case

[06:43] <sjohnson> ill use english words "and" and "or" to do the die() stuff

[06:43] *** Psyche^ joined
[06:44] *** Patterner left
[06:44] *** Psyche^ is now known as Patterner

[06:48] <sjohnson> thanks for the answers wayland76 

[06:49] <sjohnson> you seem to be interested in perl 6 as much or more than i am 

[06:52] *** ElectricHeavyLan left
[06:54] *** FurnaceBoy left
[06:58] <sjohnson> i wish i could do something to help, but i will probably just keep asking q's until i find something good that isn't in perl 5

[07:00] *** azawawi joined
[07:00] <wayland76> sjohnson: Well, if you're not so keen on the Userdocs 4 Christmas approach...

[07:01] <azawawi> good localtime()

[07:01] <wayland76> You could write some actual working code, and submit any bugs you find back to the coding team

[07:01] <wayland76> Of course, you'd need to install one of the versions of Perl 6 for that :)

[07:02] *** DemoFreak joined
[07:02] <wayland76> azawawi: hi :)

[07:02] <sjohnson> what is the best one that is executable ? pugs?

[07:02] <wayland76> depends what you mean by "executeable"

[07:02] <wayland76> But if I was going to try one, it would be Rakudo

[07:02] <sjohnson> ... closest to bytecode

[07:02] <wayland76> sjohnson: remind me; what OS?

[07:03] <sjohnson> probably linux since thats what i do most of my perl in

[07:03] <wayland76> Anyway, I'd avoid Pugs, and go with either SMOP or Rakudo

[07:04] <wayland76> Rakudo is on the Parrot Virtual Machine (and is the one I lean towards), and SMOP is, IIRC, in native C

[07:05] <wayland76> Which Linux?

[07:05] <wayland76> Fedora?  Ubuntu?  Gentoo?  etc

[07:06] <sjohnson> old ass ubuntu

[07:06] <sjohnson> mostly run these on work computers

[07:06] <sjohnson> as i mostly use perl at work

[07:06] <wayland76> Oh, ok

[07:07] <wayland76> I don't know what the Debian/Ubuntu packaging status is for any of these projects

[07:07] <sjohnson> oh

[07:07] <sjohnson> i would just compile it if possible

[07:07] <sjohnson> it's so old that not even the packages work anymore

[07:07] <sjohnson> i have to compile most things from src 

[07:07] <sjohnson> thankfully, most of these things work with a ./configure && make

[07:08] <wayland76> :)

[07:08] *** azawawi left
[07:08] <wayland76> Rakudo has a built-in build script that will download and install Parrot for you.  I don't use it myself, though (I'm slowly working on making an RPM of it)

[07:09] <sjohnson> does it look like SMOP might end up being the fastest one?

[07:11] <sjohnson> in Perl 6, what was the better way again for writing this?  ${%hash{symbol}}

[07:11] <sjohnson> %hash.symbol ?

[07:11] <TimToady> do you mean symbol to be a string?

[07:12] <TimToady> %hash<symbol> if so

[07:12] <TimToady> %hash{symbol} would always call the symbol function

[07:12] <sjohnson> yeah like if it was a key

[07:12] <sjohnson> ${%hash{key}} is what i should have said

[07:13] <TimToady> there's no ${} anymore

[07:13] <sjohnson> thank god

[07:13] <TimToady> or @{} %{}

[07:13] <sjohnson> though i realize that was a bad example

[07:13] <sjohnson> $hash{key} would get you the stuff in p5

[07:13] <sjohnson> now my brother will be happy with perl

[07:14] <sjohnson> and myself too

[07:14] <sjohnson> well, i always am happy with it

[07:14] <TimToady> since the .<> subscript is based on qw, it automatically gives you slices

[07:14] <sjohnson> but im excited that he will be excited

[07:14] <TimToady> %hash<foo bar> is %hash{'foo','bar'}

[07:14] <sjohnson> %hash.foo won't work for foo only?

[07:15] <TimToady> that only works if there's a foo method

[07:15] <sjohnson> hmm... since <> is like qw

[07:15] <sjohnson> is there a different way to do it (out of curiosity only)?

[07:15] <TimToady> to do which?

[07:15] <sjohnson> just reference what's in the foo key in that %hash

[07:16] <wayland76> Yes.  Is it %hash{foo}{bar}

[07:16] <wayland76> or do I need a . in there somewhere?

[07:16] <TimToady> no, you never need the dot except on alphanumeric methods

[07:17] <TimToady> on all other postfixes it's optional

[07:17] <sjohnson> wayland76: but i dont want the bar thing

[07:17] <TimToady> %hash<foo><bar> if they're strings

[07:17] <sjohnson> just %hash{foo} and $hash<foo>   are the only ways to get this method?

[07:17] <TimToady> what method?

[07:17] <sjohnson> s/method/var

[07:17] <sjohnson> sorry too many beers tonight

[07:18] <TimToady> {'foo'} has to be quoted to be equivalent

[07:18] <sjohnson> unlike p5, correct?

[07:18] <TimToady> yes

[07:18] *** iblechbot joined
[07:19] <sjohnson> ... and that's it?  just {} and <>?  no other special trick?

[07:19] <TimToady> well, everything else is longer

[07:19] <sjohnson> and it's not considered overkill to use a <> type thing on only one key ?

[07:19] <sjohnson> i think the answer is "yes"

[07:20] <TimToady> %hash.postcircumfix:<{ }>('foo') or some such also works

[07:20] <sjohnson> ok i am happy with that

[07:20] <sjohnson> thanks larry

[07:20] <TimToady> why would that be overkill?

[07:20] <sjohnson> just cause i normally use qw() in perl 5 to do more than 1 item in a list

[07:20] <TimToady> it makes the autoquoting very visible

[07:21] <sjohnson> please note that i also understand why it's perfectly fine

[07:21] <sjohnson> because it is syntatically perfect

[07:21] <TimToady> well, a real <foo> as a qw would generally not be distinguishable from a 'foo'

[07:21] <TimToady> so there's no point, unlike with subscripts

[07:21] <TimToady> but you can't say %hash'foo'

[07:21] <sjohnson> is <foo> not an array though?

[07:21] <sjohnson> or does it not even matter in 99% of the cases

[07:22] <sjohnson> likely because the Hash object can take in that array etc

[07:22] <TimToady> the qw form is defined as equivalent to ('foo')

[07:22] <sjohnson> is my guess

[07:22] <TimToady> the subscript form is defined as equivalent to {'foo'}

[07:22] <sjohnson> rukado:  say ('foo').WHAT

[07:22] <sjohnson> damn i can never remember the name of this bot

[07:23] *** ssm left
[07:23] <TimToady> all you have to remember is that rakuda is "camel" in Japanese

[07:23] <sjohnson> rakudo:  say ('foo').WHAT

[07:23] <p6eval> rakudo 23718a: OUTPUT«Str()␤»

[07:23] <sjohnson> rakudo:  say <foo>.WHAT

[07:23] <p6eval> rakudo 23718a: OUTPUT«Str()␤»

[07:23] <sjohnson> rakudo:  say <foo bar>.WHAT

[07:23] <p6eval> rakudo 23718a: OUTPUT«List()␤»

[07:23] <sjohnson> i see.. the TRUTH now

[07:24] *** ssm joined
[07:24] <sjohnson> i think camel is "rakuda"

[07:24] <sjohnson> in japanese

[07:24] <TimToady> that's what I said

[07:25] <sjohnson> hahah

[07:25] <sjohnson> you are funny

[07:25] <sjohnson> heheheh

[07:25] <sjohnson> i can see why i liked the camel book so much

[07:27] <sjohnson> hmmm...

[07:28] <sjohnson> i cant think of another way to improve perl 5

[07:28] <sjohnson> i had a giant list of things too

[07:28] <sjohnson> well there is one thing:

[07:28] <sjohnson> string manipulation without regex.  things like  $food = 'cake';

[07:28] <sjohnson> $food[0] = 'C';

[07:29] <TimToady> we might be able to support something like that someday

[07:29] <sjohnson> it's as old as the hills... and it sure beats splitting it into a @food_chars list

[07:30] <TimToady> it kinda depends on whether we can make this thing called NFG work out

[07:30] <sjohnson> i found it particularily helpful i was programming in the wee hours a perl project to do that oxford hype thing

[07:30] <sjohnson> i shall show you

[07:30] <sjohnson> Lrray Wlal!  Tkhans for wrintig Prel 5 and sonupitprg and enicoranugg and diisscnsug the frtuue of Prel 6, its soscucser.

[07:31] <TimToady> My eyes!  I should go to be for real

[07:32] <TimToady> *bed

[07:32] <wayland76> 'night :)

[07:32] <TimToady> gotta get up in 6 hrs...

[07:32] <TimToady> zzz &

[07:32] <sjohnson> thanks hope to see you again soon

[07:32] <wayland76> sjohnson: You know this is all permanently recorded, and available on the 'Net? :)

[07:33] <wayland76> Oh, I don't think you could keep him away from here :)

[07:33] <sjohnson> so far i haven't said anything bad, have i?

[07:33] <sjohnson> or that i'm a super nerd

[07:33] <wayland76> Well, no, but that was some fairly beery typing :)

[07:33] <sjohnson> lol

[07:34] <sjohnson> it's called... obfuscated English

[07:34] <araujo> be careful, they might think perl6 is being developed by beery people

[07:34] <wayland76> ...and Beeri, as everyone knows, was a Hittite

[07:34] <wayland76> (which is probably the Old Testament equivalent of a Klingon or something)

[07:35] <wayland76> (Beeri was the father of one of Esau's wives in the Old Testament)

[07:35] <sjohnson> is it possible to read the Perl 6 test that must be passed to be considered a Perl 6 official-approved implementation?

[07:35] <wayland76> Yes

[07:36] <wayland76> But I forget where it is.  They refer to them as spectests, I think

[07:37] <wayland76> Tip: the link labelled "The official test suite" on perl6-projects links to the SVN for the spectests

[07:37] *** revdiablo left
[07:37] *** dukeleto left
[07:37] *** diakopter left
[07:37] <wayland76> But be warned that they're incomplete

[07:38] <sjohnson> time to write an ASM Perl 6 interpretor

[07:38] <wayland76> There is one.  If you call Parrot's Assembly langugage an ASM :)

[07:38] *** revdiablo joined
[07:38] *** dukeleto joined
[07:38] *** diakopter joined
[07:40] <sjohnson> hmm

[07:40] <sjohnson> rakudo: for (1..10) { print "hi!"; }

[07:40] <p6eval> rakudo 23718a: OUTPUT«hi!hi!hi!hi!hi!hi!hi!hi!hi!hi!»

[07:42] <sjohnson> rakudo: print qx/date/;  for (1..1000)   if (0 == 1) { print "buy a new computer"; }  print qx/date/;

[07:42] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "{ print \"b"␤in Main (src/gen_setting.pm:0)␤»

[07:42] <sjohnson> rakudo: print qx/date/;  for (1..1000) { if (0 == 1) { print "buy a new computer"; } }  print qx/date/;

[07:42] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "print qx/d"␤in Main (src/gen_setting.pm:0)␤»

[07:42] <sjohnson> rakudo: print qx/date/;  for (1..1000) { if (0 == 1) { print "buy a new computer"; } } ; print qx/date/;

[07:42] <p6eval> rakudo 23718a: OUTPUT«Sat May 23 07:42:47 UTC 2009␤»

[07:43] * sjohnson is waiting...

[07:44] *** kate21de joined
[07:47] <sjohnson> rakudo: print qx/date/.chomp;  for (1..1000) { if (0 == 1) { print "buy a new computer"; } } ; print qx/date/;

[07:47] <p6eval> rakudo 23718a: OUTPUT«Sat May 23 07:47:25 UTC 2009»

[07:51] <sjohnson> does the pugs creator hang around here too?

[08:01] <wayland76> sjohnson: Not any more, I think.  

[08:01] <wayland76> Unless I just don't know their handle

[08:04] <wayland76> Audrey Tang was the name

[08:05] *** nbrown_ joined
[08:06] <sjohnson> it is impressive that is a girl around my age that is doing Pugs

[08:06] <sjohnson> not something you see everyday

[08:11] *** abra joined
[08:22] *** nbrown left
[08:22] *** nbrown_ is now known as nbrown

[08:28] *** davidad left
[08:32] *** davidad joined
[08:54] *** kst left
[08:55] *** kst joined
[09:24] *** sbp is now known as sbp_

[09:24] *** sbp_ is now known as sbp

[09:24] *** phenny left
[09:25] *** phenny joined
[09:32] *** tulcod joined
[09:43] *** iblechbot left
[09:45] *** M_o_C joined
[10:06] *** araujo left
[10:10] *** |MoC| joined
[10:13] *** cognominal joined
[10:16] *** M_o_C left
[10:17] *** cognominal left
[10:17] *** frew|work left
[10:17] *** cognominal joined
[10:22] *** skids joined
[10:32] *** Whiteknight joined
[11:09] *** nsh joined
[11:14] *** nsh- left
[11:19] *** fridim_ joined
[11:21] *** meppl joined
[11:26] *** nsh- joined
[11:35] *** payload left
[11:35] *** abra left
[11:43] *** tulcod left
[11:54] *** ssm left
[11:56] *** nsh_ joined
[11:56] *** nsh left
[11:56] *** nsh- left
[11:56] *** nsh_ is now known as nsh

[12:06] *** justatheory joined
[12:06] *** nsh- joined
[12:06] *** nsh_ joined
[12:07] *** nsh left
[12:07] *** nsh_ is now known as nsh

[12:12] *** justatheory left
[12:20] *** CMA joined
[12:37] *** ZuLuuuuuu joined
[12:44] *** mizioumt joined
[12:55] *** pmurias joined
[12:55] <pmurias> ruoso: hi

[12:58] <pugs_svn> r26915 | pmurias++ | [re-mildew] added -x m0ld option to accept m0ld code

[12:58] <pugs_svn> r26916 | pmurias++ | [re-smop] added .perl to idconst

[12:58] <pugs_svn> r26917 | pmurias++ | [re-smop] added Hash.keys

[12:58] <pugs_svn> r26918 | pmurias++ | [re-smop] added a extremely crude way of listing leaks

[12:58] <pugs_svn> r26919 | pmurias++ | [re-smop] added a non-spec $OUT.describe for debugging purposes

[13:09] <pmurias> ruoso: what i'm considering is to always return the result from a method calls by setr

[13:09] *** ilbot2 left
[13:10] <pmurias> * i'm considering always returning the result from a method call by setr

[13:20] *** hercynium left
[13:23] *** ilbot2 joined
[13:33] *** justatheory joined
[13:44] *** abra joined
[13:45] *** icwiener joined
[13:47] *** justatheory left
[13:55] *** bacek joined
[13:55] <bacek> hi there

[13:56] <bacek> rakudo: say log10(1i)

[13:56] <p6eval> rakudo 23718a: OUTPUT«0␤»

[13:56] *** nsh- left
[13:56] <bacek> rakudo: say (2*log(10)

[13:56] <p6eval> rakudo 23718a: OUTPUT«say requires an argument at line 1, near " (2*log(10"␤in Main (src/gen_setting.pm:2400)␤»

[13:56] <bacek> rakudo: say (2*log(10))

[13:56] <p6eval> rakudo 23718a: OUTPUT«4.60517018598809␤»

[13:57] <bacek> rakudo: say 1i * pi

[13:57] <p6eval> rakudo 23718a: OUTPUT«0+3.14159i␤»

[13:57] <bacek> rakudo: say 1i * pi / (2*log(10)

[13:57] <p6eval> rakudo 23718a: OUTPUT«Statement not terminated properly at line 1, near "/ (2*log(1"␤in Main (src/gen_setting.pm:0)␤»

[13:57] <bacek> rakudo: say 1i * pi / (2*log(10))

[13:57] <p6eval> rakudo 23718a: OUTPUT«0+0.682188i␤»

[13:58] <bacek> rakudo: say abs(1i * pi / (2*log(10)))

[13:58] <p6eval> rakudo 23718a: OUTPUT«0.682188176920921␤»

[13:58] <bacek> rakudo: say abs(log10(i1) - (1i * pi / (2*log(10))))

[13:58] <p6eval> rakudo 23718a: OUTPUT«Could not find non-existent sub i1␤»

[13:58] <bacek> rakudo: say abs(log10(1i) - (1i * pi / (2*log(10))))

[13:59] <p6eval> rakudo 23718a: OUTPUT«0.682188176920921␤»

[14:03] *** ZuLuuuuuu left
[14:04] <bacek> rakudo: say log10(1i) - (1i * pi / (2*log(10)))

[14:04] <p6eval> rakudo 23718a: OUTPUT«0-0.682188i␤»

[14:05] <bacek> rakudo: say abs(log10(1i) - (1i * pi / (2*log(10))))

[14:05] <p6eval> rakudo 23718a: OUTPUT«0.682188176920921␤»

[14:07] <bacek> moritz_: ping?

[14:09] <pugs_svn> r26920 | pmurias++ | [re-mildew] fix test count

[14:09] <pugs_svn> r26921 | pmurias++ | [re-mildew] started working on RoleHOW

[14:10] *** amoc joined
[14:12] <bacek> msg moritz_ Can you check S32/log.t why "is_approx(log10(1i), 1i * pi / (2*log(10)), 'got the log10 of i');" is passing? Because it shouldn't...

[14:14] *** moritz_ left
[14:14] *** ilbot2 left
[14:26] <pmurias> bacek: they are supposed to be skipped on rakudo

[14:26] <pmurias> ?

[14:27] <bacek> Not all of them...

[14:27] <bacek> Ah. Yes. 

[14:27] <bacek> AFAIU all of them should be skipped.

[14:29] <bacek> perl6: my $a = [^0.1]; say $a.shift

[14:29] <p6eval> elf 26921: OUTPUT«Undefined subroutine &GLOBAL::prefix__94 called at (eval 124) line 3.␤ at ./elf_h line 5881␤»

[14:29] <p6eval> ..pugs, rakudo 23718a: OUTPUT«0␤»

[14:29] <pmurias> rakudo: say log10(1i)

[14:29] <p6eval> rakudo 23718a: OUTPUT«0␤»

[14:38] <bacek> perl6: say log10(1i)

[14:38] <p6eval> elf 26921: OUTPUT«Undefined subroutine &GLOBAL::log10 called at (eval 124) line 3.␤ at ./elf_h line 5881␤»

[14:38] <p6eval> ..rakudo 23718a: OUTPUT«0␤»

[14:38] <p6eval> ..pugs: OUTPUT«0 + 0.6821881769209206i␤»

[14:39] <bacek> rakudo is so wrong..,

[14:55] <Infinoid> bacek: I just left you a purl-message in #parrot.  tt452 saved 5.8 minutes of CPU time doing spectest

[15:04] <ruoso> pmurias, the result of any block happens in terms of setr

[15:04] <ruoso> but if you mean return as the function, then the control exception is actually a requirement

[15:05] *** Muixirt joined
[15:06] <pmurias> ruoso: what i mean is that we should stop returning values using the Cish return

[15:06] <ruoso> this dual-life form of SMOP_DISPATCH is important for bootstrap purposes

[15:06] <ruoso> but as soon as it evolves, less and less code will return directly from SMOP_DISPATCH...

[15:06] <ruoso> but basically...

[15:07] <Muixirt> hi, I wonder whether there is a 'exists' function in perl6

[15:07] <ruoso> you should only use "setr" if you have a continuation change

[15:07] <ruoso> if you don't touch the current continuation, then you should just return from MESSAGE

[15:07] <pmurias> when do we depend on dual-life form SMOP_DISPATCH

[15:08] *** bacek left
[15:09] <pmurias> ruoso: or is it just a bootstrapping shortcut?

[15:11] *** aindilis left
[15:11] *** Psyche^ joined
[15:12] <pmurias> shortcut meaning a way to write less code

[15:14] <pmurias> ruoso: continuation.eval could just call a interpreter.finished method instead of calling setr

[15:15] <pmurias> ruoso: most of the places where we depend on SMOP_DISPATCH returning a value we break encapsulation as we assume that a given method is implemented in a stackless manner

[15:21] *** rindolf joined
[15:21] *** kst left
[15:21] *** kst joined
[15:23] *** Muixirt left
[15:24] *** Patterner left
[15:24] *** Psyche^ is now known as Patterner

[15:27] *** meppl left
[15:29] <rindolf> Hi all.

[15:30] *** rindolf left
[15:31] *** rindolf joined
[15:33] *** Whiteknight left
[15:56] *** kane_ joined
[16:09] <pmurias> ruoso: one think we should keep in mind that we need to have a way for cyclic references to be collected

[16:12] <pmurias> ruoso: and we have to do it automatically like python as we can't expect the user do weaken references explicitly as other implementation are trace gc

[16:14] <TimToady> you should also delay destruction a random amount of time so people don't depend on it.  :)

[16:14] *** Lorn left
[16:14] <TimToady> * .25

[16:16] *** iblechbot joined
[16:20] *** payload joined
[16:25] *** skids left
[16:28] *** meppl joined
[16:49] *** nsh left
[16:52] *** nihiliad joined
[16:59] *** |MoC| left
[17:00] *** CMA left
[17:01] *** M_o_C joined
[17:04] *** root joined
[17:04] <root> woot woot woot!! I got perl 6 compiled on my Mac!! 

[17:04] <root> heh

[17:04] *** root is now known as dextius

[17:04] <dextius> heh, I just installed an irc client, forgot to change my name ;-)

[17:06] *** nsh_ joined
[17:06] *** nsh_ is now known as nsh

[17:06] <dextius> I have a question... Why does the function call "time" continue to return 5 digit precision when the underlying gettimeofday call has higher precision?  (In perl5, I could print the higher precision time by doing the following) printf("%f!\n", scalar(gettimeofday()));

[17:07] *** FurnaceBoy joined
[17:07] *** frew|work joined
[17:18] *** ElectricHeavyLan joined
[17:22] *** ZuLuuuuuu joined
[17:25] *** nsh_ joined
[17:29] *** ab5tract joined
[17:31] <ab5tract> hmm, just trying to compile rakudo from the github repo. perl Configure.pl --gen-parrot produces the following:

[17:31] <ab5tract> "Reading configuration information from parrot/parrot_config ..."

[17:32] <ab5tract> "Died at Configure.pl line 104."

[17:33] <ab5tract> any thoughts?

[17:33] <jnthn> ab5tract: I'm guessing it somehow failed to build Parrot. Do you have a parrot/parrot binary?

[17:33] <ab5tract> yeah

[17:33] <ab5tract> just put it into PATH?

[17:33] <jnthn> But I guess no parrot/parrot_config binary?

[17:33] <jnthn> Well, it needs parrot_config rather than just parrot

[17:34] <jnthn> But it's kinda weird you've got a parrot binary but no parrot_config...

[17:34] <ab5tract> sorry i thought you meant do i have a separate parrot compiled somewhere

[17:34] <ab5tract> there actually is a parrot_config binary in the rakudo/parrot dir

[17:36] *** nsh left
[17:37] <ab5tract> so i'm not sure what the problem here is

[17:38] <jnthn> Me either. :-S

[17:39] <jnthn> One thing to try 

[17:39] <jnthn> perl Configure.pl --parrot-config=path/to/parrot_config

[17:39] <jnthn> I'm guessing that's just parrot/parrot_config

[17:40] <ab5tract> right, unless i use the newest svn revision that i just compiled outside of the rakudo dir. but i figured it made more sense to use the one that rakudo is "tied" to

[17:40] <ab5tract> atm

[17:40] <jnthn> Yeah, it tends to

[17:40] <jnthn> You can try your other revision too.

[17:40] <ab5tract> weirdly enough that solved it

[17:40] <jnthn> Oh, hmm.

[17:40] * jnthn is confused as to why.

[17:40] <ab5tract> quite strange indeed

[17:41] <jnthn> Most strange is

[17:41] <jnthn> Line 104 is just

[17:41] <jnthn> close $PARROT_CONFIG or die $!;

[17:42] <jnthn> Why on earth does a close die. :-S

[17:42] <jnthn> (or more specifically, why in only one case...)

[17:42] *** Andronic left
[17:43] <ab5tract> bizarre

[17:43] <ab5tract> do you get the same effect ?

[17:44] <jnthn> dextius: I'm not sure if the issue with time() is that the number it returns doesn't have the precision or if the output of it is rounding it...

[17:44] <jnthn> ab5tract: No, I haven't seen that issue.

[17:45] <jnthn> I was just looking at what's on the line number in the configure script that was mentioned in the error you pasted.

[17:45] <s1n> jnthn: i'm getting a method not found for invocant error, but it doesn't indicate where it comes from

[17:45] <s1n> is there anyway of getting that information?

[17:45] <ab5tract> it might be interesting to try a cd /tmp; git clone git://github.com/rakudo/rakudo.git; cd rakudo; perl Configure.pl --gen-parrot

[17:45] <ab5tract> to see if this is specific or general

[17:45] <jnthn> s1n: In latest Rakudo?

[17:46] <jnthn> (or one just released, at least)?

[17:46] <s1n> jnthn: well, latest as of early this week :/

[17:46] <s1n> was there a change to report those errors better?

[17:47] <jnthn> s1n: Yeah, I sneaked a fix in just before the Parrot release, either late Monday or early Tuesday.

[17:47] <s1n> jnthn: okay, i'll update and see what it says about my bad code :)

[17:47] <jnthn> That particular fix did deal with some error reports not having a line number and backtace.

[17:47] <jnthn> So it's possibly you've found another bug, but my first guess is that you're missing the fix.

[17:48] <jnthn> rakudo: my $x; $x.this-does-not-exist;

[17:48] <p6eval> rakudo 23718a: OUTPUT«Method 'this-does-not-exist' not found for invocant of class 'Failure'␤»

[17:48] <jnthn> hmm

[17:48] <ab5tract> hehe

[17:48] <jnthn> rakudo: my Int $x; $x.this-does-not-exist;

[17:48] <s1n> that's the error :)

[17:48] <p6eval> rakudo 23718a: OUTPUT«Method 'this-does-not-exist' not found for invocant of class ''␤»

[17:48] <s1n> that one exactly

[17:48] <s1n> it doesn't have the class name

[17:48] <jnthn> oddness

[17:49] <jnthn> s1n: nod

[17:49] <jnthn> Hmm

[17:49] <s1n> i've been doing a bunch of stuff and i don't know which change i did broke it

[17:49] <s1n> and i haven't committed so i can't bisect :/

[17:51] <jnthn> s1n: OK, stuff that certainly did have a backtrace pretty recently - after I put a fix in - seems to have lost it.

[17:52] * jnthn wonders if somebody decided to "improve" his commit

[17:52] <s1n> jnthn: which commit (sha1) added backtraces?

[17:53] <jnthn> s1n: It was a Parrot level fix.

[17:54] <jnthn> s1n: However, I don't see any changes to the files I changed so hmm.

[17:54] <jnthn> s1n: Things that I know worked a couple of days back now seem not to be though.

[17:55] <s1n> jnthn: it worked with the version i had build on like monday or so, i didn't update/rebuild and that one showed up

[17:55] <s1n> jnthn: you might want to see if other backtraces work

[17:55] <jnthn> s1n: Yeah, if you explicitly die they do work.

[17:56] <TimToady> dextius: I suspect time should actually be returning a Rat, or a Num that can do Rat internally

[17:56] <jnthn> It seems to be in other cases...

[17:56] <jnthn> erm, seems not to be

[17:56] <s1n> jnthn: there were several times the backtraces helped save me hours of debugging, so they were definitely working

[17:56] <jnthn> s1n: Right.

[17:56] <jnthn> Do you know how to pull a specific git revision?

[17:57] <jnthn> Or to switch to one?

[17:57] <s1n> jnthn: not yet :)

[17:57] <s1n> jnthn: what do you have in mind?

[17:57] <jnthn> s1n: Trying to work out where things broke.

[17:58] <jnthn> http://github.com/rakudo/rakudo/commit/9d2934e1340b092f51b96f44b8155296550282c7 is where I bumped Rakudo's revision up.

[17:58] <jnthn> Parrot revision, that is.

[17:58] <jnthn> So that's when I'm fairly happy it was working.

[17:59] <jnthn> It'd help greatly to try that revision against current Parrot to see if something in Parrot changed or something in Rakudo did.

[17:59] <s1n> jnthn: i can just knock parrot's revision back down

[17:59] <jnthn> Of course, I can go debugging to find out too. :-)

[17:59] <jnthn> s1n: You maybe could try that.

[18:00] <s1n> jnthn: building rakudo master w/ parrot r38795

[18:04] <jnthn> s1n: thanks

[18:04] * jnthn is a little distracted at the moment from looking

[18:04] <jnthn> erm

[18:04] <jnthn> well yes, that too by s/from looking/by cooking/

[18:05] *** araujo joined
[18:07] <jnthn> s1n: It seems to be that the .backtrace() method hands back something with zero elements... :-S

[18:08] <s1n> jnthn: sorry, i got distracted (i'm trying to figure out flight plans to yapc with my wife lol)

[18:09] *** skids joined
[18:10] <s1n> jnthn: it won't build anymore with that version of parrot

[18:11] <ab5tract> s1n, what error do you get?

[18:13] <ab5tract> jnthn, very strange thing: i did the perl Configure.pl --gen-parrot over again (after rm -rf parrot) and it worked fine...

[18:13] <jnthn> ab5tract: on noes it's haunted!

[18:13] <ab5tract> hehe

[18:15] <s1n> jnthn: error:imcc:syntax error, unexpected '[', expecting '(' ('[') in file 'src/classes/Object.pir' line 230

[18:15] <s1n> it scrolls for quite a while

[18:16] <jnthn> s1n: Yes, yes, that Parrot will be Too Old

[18:16] <jnthn> OK, 39071 has the problem.

[18:16] <jnthn> So it was before then.

[18:22] <jnthn> s1n: I'm curious - if you have a moemnt to try it - if the release version had the issue.

[18:23] <jnthn> Just tried 39030 and also seeing the issue.

[18:23] <s1n> jnthn: yeah gimme a minute (booking my trip now)

[18:24] <jnthn> s1n: Trying 39007 here which is furthest we can go back without being unable to build, afaict.

[18:24] <jnthn> s1n: No hurry. :-)

[18:26] *** shinobi-cl joined
[18:26] <shinobi-cl> hi

[18:26] *** frew|work left
[18:28] <shinobi-cl> is there a way to use case-insensitive keys for perl6 hashes?

[18:31] <jnthn> rakudo: my CIHash { has %storage handles *; method postcircumfix:<{ }>($key) { return %storage{$key.lc} } }; my CIHash $x .= new; $x<a> = 42; say $x.keys; $x<A> = 42; say $x.keys;

[18:31] <p6eval> rakudo 23718a: OUTPUT«Malformed declaration at line 1, near "CIHash { h"␤in Main (src/gen_setting.pm:0)␤»

[18:31] *** eternaleye left
[18:32] <jnthn> rakudo: class CIHash { has %storage handles *; method postcircumfix:<{ }>($key) { return %storage{$key.lc} } }; my CIHash $x .= new; $x<a> = 42; say $x.keys; $x<A> = 42; say $x.keys;

[18:32] <p6eval> rakudo 23718a: OUTPUT«The use of a %hash with the handles trait verb is reserved␤in Main (/tmp/bQUbUd1fjY:1)␤»

[18:32] <jnthn> oh, gah.

[18:32] <jnthn> rakudo: class CIHash { has $storage handles * = Hash.new; method postcircumfix:<{ }>($key) { return $storage{$key.lc} } }; my CIHash $x .= new; $x<a> = 42; say $x.keys; $x<A> = 42; say $x.keys;

[18:32] <p6eval> rakudo 23718a: OUTPUT«No such attribute '$!storage'␤in method CIHash::postcircumfix:{ } (/tmp/vb58ZfsioC:1)␤called from method CIHash::postcircumfix:{ } (/tmp/vb58ZfsioC:1)␤called from Main (/tmp/vb58ZfsioC:1)␤»

[18:33] <jnthn> rakudo: class CIHash { has $!storage handles * = Hash.new; method postcircumfix:<{ }>($key) { return $storage{$key.lc} } }; my CIHash $x .= new; $x<a> = 42; say $x.keys; $x<A> = 42; say $x.keys;

[18:33] <p6eval> rakudo 23718a: OUTPUT«Symbol '$storage' not predeclared in postcircumfix:{ } (/tmp/eaoPYbEgVy:1)␤in Main (src/gen_setting.pm:3166)␤»

[18:33] <jnthn> rakudo: class CIHash { has $!storage handles * = Hash.new; method postcircumfix:<{ }>($key) { return $!storage{$key.lc} } }; my CIHash $x .= new; $x<a> = 42; say $x.keys; $x<A> = 42; say $x.keys;

[18:33] <p6eval> rakudo 23718a: OUTPUT«No such attribute '$!storage'␤in method CIHash::postcircumfix:{ } (/tmp/EHYfPdpRK3:1)␤called from method CIHash::postcircumfix:{ } (/tmp/EHYfPdpRK3:1)␤called from Main (/tmp/EHYfPdpRK3:1)␤»

[18:33] <jnthn> wtf

[18:33] *** nsh_ left
[18:33] <jnthn> shinobi-cl: yes, if you can make it work ;-)

[18:34] <shinobi-cl> thanks :) i got the idea

[18:34] <jnthn> oh, better way maybe

[18:34] <shinobi-cl> i though that can be done maybe using traits

[18:34] <shinobi-cl> like a case-insensitive trait

[18:34] <jnthn> oh, no, we can't do that yet...

[18:34] <jnthn> shinobi-cl: Yeah

[18:35] <jnthn> shinobi-cl: That'll probably be the answer in the long run.

[18:35] <jnthn> Rakudo is nearly but not quite there yet with making it possible to do it with a trait.

[18:36] *** nsh_ joined
[18:38] *** Kisu left
[18:40] *** lisppaste3 left
[18:43] *** abra left
[18:44] <TimToady> more likely a Hash with a declared key type of a canonicalized string

[18:45] <s1n> jnthn: okay, what is it you need me to do?

[18:46] <jnthn> s1n: Build the latest Rakudo release (Stockholm) along with the Parrot it wanted and see if backtraces work.

[18:46] <jnthn> perl6 -e 'foo()' # should give one if it does

[18:47] <s1n> build specifically the stockholm release and not git master?

[18:49] *** lisppaste3 joined
[18:50] <jnthn> s1n: yes

[18:50] <jnthn> s1n: At least that gives us a relativley recent point where it (hopefully!) worked.

[18:50] <jnthn> ok, my dinner is ready, I'll be back in 20 mins or so

[18:55] *** dextius left
[19:02] <s1n> jnthn: is there a way to switch to that git revision (using sha1)?

[19:05] <pugs_svn> r26922 | lwall++ | [Temporal.pod] prefer Rat from time()

[19:08] *** mikehh_ joined
[19:10] <pugs_svn> r26923 | lwall++ | [Temporal.pod] finish previous patch, urgh

[19:17] *** icwiener_ joined
[19:18] * jnthn back

[19:18] <jnthn> s1n: Probably but I couldn't work out how.

[19:23] *** mikehh left
[19:26] *** shinobi-cl left
[19:26] *** rindolf left
[19:29] *** nbrown_ joined
[19:30] *** ZuLuuuuuu left
[19:33] *** icwiener left
[19:47] *** nbrown left
[19:47] *** nbrown_ is now known as nbrown

[19:49] *** sjohnson left
[19:50] *** sjohnson joined
[19:52] *** mikehh_ is now known as mikehh

[20:11] *** nsh_ left
[20:16] *** cotto left
[20:17] *** cotto joined
[20:19] *** PacoLinux left
[20:22] *** PacoLinux joined
[20:26] *** ElectricHeavyLan left
[20:40] *** nsh_ joined
[20:45] *** icwiener_ left
[20:46] *** icwiener joined
[21:01] *** JDlugosz left
[21:02] *** nsh_ left
[21:02] *** bacek joined
[21:02] *** iblechbot left
[21:18] *** ejs joined
[21:37] *** tulcod joined
[21:51] *** ejs left
[21:53] *** PZt left
[21:58] *** kate21de left
[21:59] *** VX64Z joined
[22:03] *** kst left
[22:03] *** kst joined
[22:05] *** PZt joined
[22:06] *** ZuLuuuuuu joined
[22:07] <literal> so, what if I want to define a sigil for my new role?

[22:11] *** bacek left
[22:13] *** amoc left
[22:20] <ruoso> pmurias, it's not a shortcut in that sense... but the general idea is that it returns a meaningfull value *or* talks to the interpreter... this is not *just a shortcut*.. it's a fundamental concept on how we bootstrap the type system

[22:20] <literal> all sigils are tied to roles, right? $ is Object, @ is Positional, % is Associative & is Routine, etc

[22:21] <ruoso> literal, to define new sigil, you need to extend STD

[22:21] <ruoso> thus you have a new language

[22:21] <literal> ok

[22:22] <ruoso> then you can do whatever you want in your new language

[22:22] <literal> I was hoping for a more pedestrian way of adding a sigil :)

[22:23] <literal> like with new ops

[22:24] *** nsh joined
[22:31] *** nacho_ joined
[22:32] *** bacek joined
[22:35] *** justatheory joined
[22:41] <sjohnson> ruoso: hey you are working on the C implentation SMOP correct?

[22:41] *** nsh left
[22:41] <ruoso> sjohnson, yes

[22:42] <sjohnson> it is it coming along?

[22:42] <sjohnson> s/^it/how/

[22:43] <ruoso> well... we have a pretty solid base already

[22:43] <ruoso> and we're starting to get things running in Perl 6 level on top of it

[22:44] <ruoso> we still need to deal with some memory leaks

[22:44] <sjohnson> i went to the perlfoundation.org site for SMOP, but i have to say that the layout of the page is very strange, and I don't really see where it describes any overview of what SMOP is, and what i's progress is

[22:44] <sjohnson> i's => its

[22:44] <ruoso> yeah... and I kinda left the wiki a bit outdated... my bad...

[22:44] <ruoso> because I started writing some more concise documentations

[22:45] <ruoso> sjohnson, do you have pugs checked out?

[22:45] <ruoso> (SMOP is inside the pugs repo)

[22:45] <sjohnson> i checked out the Pugs website and found that more like something was looking for... ie, soemthing that describes the project

[22:45] *** ZuLuuuuuu left
[22:46] <ruoso> sjohnson, I mean the pugs svn

[22:46] <sjohnson> so forgive me if i ask obvious questions like.. what is SMOPS goal, etc

[22:46] <sjohnson> not sure what SVN stands for

[22:46] *** Chillance joined
[22:46] <ruoso> sjohnson, ok... basically, SMOP is a runtime library that implements the semantics needed by Perl 6

[22:47] <ruoso> it's not a Virtual Machine in the same sense as Parrot is

[22:47] <ruoso> but if you think in p5 as a VM, then SMOP is a VM too...

[22:47] <ruoso> SMOP is in the same level as p5, that is..

[22:47] <ruoso> and not in the same level as parrot...

[22:47] <literal> sjohnson: svn is subversion

[22:47] *** pochi joined
[22:47] <literal> http://svn.pugscode.org/pugs/

[22:48] <ruoso> sjohnson, for instance... Parrot will probably be able to implement ACL to memory access

[22:48] <ruoso> and that is something SMOP won't ever be able to do

[22:48] <sjohnson> ruoso: so after the runtime lib is done, then you will write something simple that interfaces with it, if you havent done so already?

[22:49] <ruoso> well... starting from the beggining

[22:49] <ruoso> SMOP, conceptually, is really just a .h file

[22:49] <ruoso> but then there are implementations that follow that .h file

[22:49] <ruoso> sjohnson, are you familiar with C programming?

[22:49] <sjohnson> a tiny bit

[22:50] <sjohnson> i have K&R's C book

[22:50] <sjohnson> but find myself having a hard time reading thru it, not because it's boring or hard, but because of a lack of ideas for what I would use it for

[22:50] <ruoso> http://svn.pugscode.org/pugs/v6/re-smop/lowdoc/01_base.pod

[22:50] <ruoso> the above link specifies what the base of SMOP is

[22:50] <ruoso> everything else is built on top of that

[22:51] <sjohnson> now, is SMOP the name for your imp. of Perl 6? or is SMOP something like Parrot in the sense that it can be used for othings that aren't related to Perl 6

[22:52] <sjohnson> as the title says "Simple Meta Object Programming / Simple Matter Of Programming" with no mention of Perl in it

[22:52] <sjohnson> i was a bit confused by that too

[22:52] <ruoso> sjohnson, SMOP is just a runtime library, it's not really a Perl 6 implementation... but we are already working on a Perl 6 implemenation that uses this runtime, which is mildew

[22:52] <sjohnson> is SMOP then going able to share it's "goods" for other uses other than Perl 6? is that the idea?

[22:53] <ruoso> it's not the primary goal, but it should be useable by other stuff.. ys

[22:53] <ruoso> *yes

[22:53] *** tulcod left
[22:53] <sjohnson> ok i c

[22:53] <ruoso> sjohnson, take a look at the link i posted...

[22:53] <sjohnson> because it's written in C, is the goal so that your Perl 6 runs fast?

[22:54] <sjohnson> i am looking at the link, a lot of it is over my head

[22:54] *** wknight8111 joined
[22:54] <ruoso> sjohnson, it's written in C because, well, there's nothing better to use... I never thought about using anything else...

[22:54] <ruoso> and it gets low-level enough to build a runtime library

[22:55] <ruoso> any other thing would include some runtime support

[22:55] <ruoso> C is bare-bones

[22:55] <sjohnson> isn't it tough programming in C though?  or is it really easy once you know what you are doing

[22:55] <ruoso> C is really like Perl

[22:56] <sjohnson> i am really fast at programming Perl I can say

[22:56] <sjohnson> so I am happy to hear that it's like C

[22:56] <ruoso> you just have no introspection

[22:56] <ruoso> so, data is just data

[22:57] <ruoso> and you have to know how to use it when you use it

[22:57] <sjohnson> is it not possible to write functions / methods that can determine the type of data being presented to them?

[22:57] <ruoso> no...

[22:57] <sjohnson> or are you saying that objects can't have methods that self-identify

[22:57] <ruoso> you can *try* to *guess*

[22:57] <sjohnson> or structs

[22:58] <ruoso> you can define something in the struct

[22:58] <ruoso> but the struct itself doesn't provide any label to tell you which type of struct it is

[22:58] <ruoso> (besides in the source code, of course)

[22:59] <sjohnson> you cant make a struct {  chat* name; } in there ?

[22:59] <sjohnson> ( i realize to you i must sound like a complete idiot, so forgive me)

[22:59] <ruoso> you can... but only the structs that have that char there will have the char there

[22:59] <ruoso> and if, eventually, you receive something that isn't that struct

[22:59] <ruoso> you might end up causing a segfault

[23:00] <sjohnson> oh i c

[23:00] <sjohnson> what would you do in perl that solves this problem?

[23:00] <skids> rakudo: my $a = 1; my $b = 2; (($a,$b) xx 1)[1] = 3; ($a, $b).say;

[23:00] *** icwiener left
[23:00] <p6eval> rakudo 23718a: OUTPUT«12␤»

[23:00] <skids> rakudo: my $a = 1; my $b = 2; (($a,$b) xx 2)[1] = 3; ($a, $b).say;

[23:00] <ruoso> sjohnson, well... in Perl you can use "ref" to know what it is

[23:00] *** icwiener joined
[23:00] <p6eval> rakudo 23718a: OUTPUT«3Use of uninitialized value␤␤»

[23:00] <ruoso> sjohnson, besides a lot of other introspection

[23:00] <ruoso> sjohnson, and predefined ways to access the data

[23:01] <sjohnson> you sound like you really know what you are doing

[23:01] <ruoso> it's been 2 years already

[23:01] <ruoso> (sort of)

[23:01] *** bacek left
[23:01] <sjohnson> the best thing i've done in perl is write my own "management system" that interfaces with multiple git trees at work to make my life easy

[23:01] <sjohnson> all in perl

[23:01] <ruoso> sounds cool

[23:01] <sjohnson> but the stuff you are talking about here sounds really advanced

[23:02] <ruoso> not really "advanced", just "low-level" and "abstract"

[23:02] <sjohnson> how long have you been writing in C / when or how did you learn?

[23:02] <ruoso> SMOP was my first real C project

[23:03] <sjohnson> i take it you are learning a lot at the same time

[23:03] <ruoso> I learn by coding

[23:03] <ruoso> but there isn't much to learn in C

[23:03] <sjohnson> yeah as Ritchie says, "C is not a complex language"

[23:04] <sjohnson> did you read that book too?

[23:04] <sjohnson> or learn on the internets

[23:05] <skids> ruoso: except it's close enough to the metal to get into some pretty complicated OS nuances e.g. alignment, etc.

[23:05] <ruoso> skids, yeah... sure... but you can get a long run without hitting that

[23:06] <ruoso> sjohnson, I really meant it when I say that I learn by coding... I recall having read half of "practical C" several years back

[23:06] <sjohnson> are there not times when you say "damnit, I wish C had Perl's regex stuff.." at all?

[23:07] <ruoso> sjohnson, when I come to that point, I usually use libpcre

[23:07] <sjohnson> i was writing a thing in C++ for my boss but i ended up just using C calls to do the work... but it was text manuipulation, and it got really tedious

[23:07] <sjohnson> i succeeded though with brute force character array tricks

[23:08] <sjohnson> ruoso: is C still as popular as it always was and has libraries for it?

[23:08] <sjohnson> i like C better than C++ in a lot of cases

[23:08] <sjohnson> as the C++ std lib is bloated as hell

[23:09] *** nsh joined
[23:09] <ruoso> sjohnson, well... C is... C... there's no substitute for that...

[23:09] <ruoso> when I need C, it's because nothing else fits

[23:09] * skids spits upon hearing C++

[23:10] <skids> not a fan 

[23:10] <sjohnson> skids: can you write in C too?

[23:10] <ruoso> I never had a reason to even look at C++

[23:10] <skids> Yeah, I do a bit of kernel hacking now and then in C.

[23:10] <ruoso> (besides trying to patch an app written in C++ with half of it using plain C

[23:11] <ruoso> the thing I don't understand is... why using C++ if half of your app is still going to need to be plain C?

[23:11] <sjohnson> it can be all C++ but most programmers find it easier to just use C stuff

[23:12] <sjohnson> i talked with the guy who wrote uTorrent on efnet asking him this kind of stuff

[23:12] <sjohnson> and he said he wrote uTorrent in like 95% C code and some C++ stuff to make his life a bit easier with object stuff

[23:12] <skids> The thing I don't understand is how a cantankerous OO system like that can be so attractive to use that it spawns 5x the useless redundant classes in a typical application than are needed.

[23:13] <sjohnson> that is a good question

[23:13] <sjohnson> probably simply hype and more readily available books a the library talking about C++ as .. the NEW C

[23:13] <sjohnson> would be my guess

[23:13] <sjohnson> and a lot of cases at school teach it and job employers look for it.  vicious cycle i suppose

[23:16] <sjohnson> have anyone of you heard of the game called Cave Story?

[23:16] <skids> Now I can understand a lot of classes in aneasy to use OO language, mind you.  I ilike the way Perl6 anonymizes and hides classes that are trivial mods of other classes, though.

[23:16] <sjohnson> i think it was written in C

[23:16] <skids> Can't say I have.

[23:17] <sjohnson> skids: can it be said that Perl 6 is like Ruby in that "Everything is an object" saying?

[23:18] <skids> To most extents, I think.

[23:18] <sjohnson> rakudo:  say 3.WHAT

[23:18] <p6eval> rakudo 23718a: OUTPUT«Int()␤»

[23:18] <sjohnson> seems to be an Int object

[23:19] <skids> but not to say everything is an Object :-)

[23:19] <sjohnson> what isn't one?

[23:19] <sjohnson> rakudo: {}.WHAT

[23:19] <p6eval> rakudo 23718a:  ( no output )

[23:19] <sjohnson> rakudo: { 5; }.WHAT

[23:19] <p6eval> rakudo 23718a:  ( no output )

[23:19] <ruoso> rakudo: say {}.WHAT

[23:19] <sjohnson> i got that to work somehow

[23:19] <p6eval> rakudo 23718a: OUTPUT«Hash()␤»

[23:19] <sjohnson> oh

[23:19] <sjohnson> forgot the say

[23:19] <ruoso> rakudo: say {5;}.WHAT

[23:19] <p6eval> rakudo 23718a: OUTPUT«Block()␤»

[23:20] <skids> sjohnson: I'll leave that question to jnthn, but I'm sure there are examples.

[23:20] <sjohnson> is jnthn a developer alongside Mr. Wall t?

[23:20] <sjohnson> ?

[23:20] <sjohnson> as he and one other guy have Ops in this channel

[23:21] <skids> For all intents and purposes 2 is an Int (which is an Object) but behind the scenes it is "autoboxed".

[23:22] <skids> So if you have an Array of Int, it is supposed to be packed in memory with each value stored consecutively.  But @a[*] will still behave as Int objects.

[23:23] <skids> jnthn and pmichaud are doing a great share of the class system work.

[23:25] <skids> (among many other things)

[23:25] <sjohnson> ruoso: is it just you working on SMOP?  or do you have some friends / community members also helping

[23:26] <ruoso> sjohnson, pmurias is a co-author of smop/mildew

[23:26] <skids> ruoso: which one of you is batman, and which one robin, anyway? :-)

[23:27] <ruoso> meh... bad analogy...

[23:27] <ruoso> I started SMOP, pmurias started mildew

[23:27] <ruoso> we both hack them inside out

[23:29] *** cotto left
[23:29] <sjohnson> has SMOP programming been fun or frustrating at times?

[23:30] <ruoso> sometimes fun, sometimes frustrating...

[23:30] <ruoso> but always with a line-of-sight to the end of the tunnel

[23:30] *** cotto joined
[23:31] <skids> ruoso: you're out of "refactor" mode now I take it?

[23:32] <ruoso> skids, yeah... the refactor is over... we still need to merge re-smop and re-mildew back to their original places... but that's less importatnt

[23:33] <sjohnson> ruoso: are you using HydraIRC?

[23:33] *** nsh left
[23:34] <ruoso> no...

[23:35] *** nsh joined
[23:35] <sjohnson> oh xchat that is right

[23:35] <sjohnson> i used to use that

[23:37] <ruoso> it's not that bad... it has some quirks... but it is useable

[23:37] <ruoso> and works nicely with several networks

[23:37] <sjohnson> the one i use, weechat-devel, is not widely known

[23:38] <sjohnson> but i think it is the best irc client i have ever used, far better than irssi

[23:38] <sjohnson> plus the author hangs out on freenode and actually accepted 2 of my suggestions to make this my "dream client"

[23:38] <sjohnson> weechat (devel version) i really mean

[23:39] *** frew|work joined
[23:45] *** fridim_ left
[23:48] <sjohnson> has anyone here tried ruby?  have they concluded that Perl 6 would be better for them?

[23:48] <sjohnson> i am feeling that way right now, but curious to hear what others think

[23:50] *** justatheory left
[23:51] *** orafu left
[23:52] *** sri_kraih left
[23:53] *** eternaleye joined
[23:54] <ruoso> sjohnson, I'm not that familiar with ruby

