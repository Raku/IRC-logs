[00:03] <zaslon> lolperl6adventhazblogged! perl6advent++ 'Day 24: The Perl 6 standard grammar': http://perl6advent.wordpress.com/2009/12/24/day-24-the-perl-6-standard-grammar/

[00:04] *** kensanata left
[00:04] *** mberends left
[00:05] *** Su-Shee left
[00:10] <Wolfman2000> ...to whoever keeps up with standards: are emails supposed to be case insensitive?

[00:11] <Juerd> pmichaud++  # great advent finale :)

[00:13] *** kensanata joined
[00:15] <arnsholt> Wolfman2000: Email addresses are case-insensitive IIRC

[00:15] <arnsholt> Er, actually, I'm not sure. Check Wikipedia. E-mail is a mess =)

[00:15] <Wolfman2000> according to wikipedia, the local part should be case sensitive. doesn't say about the domain part

[00:16] <diakopter> phenny: tell mberends and miguel adds multiple return to mono/C#: http://tirania.org/blog/archive/2009/Dec-23.html

[00:16] <phenny> diakopter: I'll pass that on when mberends is around.

[00:16] *** pdcawley left
[00:18] <arnsholt> The domain parts are resolved by DNS, which is insensitive as well

[00:18] <diakopter> Wolfman2000: the domain part is historically not case-sensitive; see http://en.wikipedia.org/wiki/Domain_Name_System and its link to RFC 4343

[00:19] *** ejs left
[00:19] *** ejs1 joined
[00:21] <diakopter> Wolfman2000: the local part should be case-sensitive, but many smtp servers treat it as case-insensitive

[00:21] <Wolfman2000> ...I'm starting to not like redesigning my website proper now. :(

[00:22] <diakopter> change how you're doing it so that you enjoy it?

[00:22] <Wolfman2000> diakopter: Get me more contributers so I'm not the only one doing it.

[00:22] <Wolfman2000> ...on second thought, don't worry about it.

[00:23] <diakopter> I wasn't going to worry about it anyway

[00:26] *** lestrrat is now known as lest_away

[00:29] *** TiMBuS joined
[00:35] *** ihrd1 joined
[00:35] *** ihrd1 left
[00:57] *** ejs1 left
[01:01] *** lest_away is now known as lestrrat

[01:04] *** ashizawa joined
[01:07] *** ShaneC1 left
[01:18] *** cotto left
[01:21] *** felipe left
[01:24] *** tsbtmn joined
[01:41] *** jferrero left
[01:43] *** Baggio_ joined
[01:44] *** wayland76 joined
[01:48] *** krunen left
[01:48] *** krunen joined
[01:53] *** Beetny joined
[01:56] <diakopter> phenny: tell mberends named capturing groups working, in addition to lookahead (pos and neg)

[01:56] <phenny> diakopter: I'll pass that on when mberends is around.

[01:58] *** Baggio_ left
[02:03] *** Baggio_ joined
[02:05] *** eiro_ joined
[02:05] *** kensanata left
[02:07] *** Baggio_ left
[02:07] *** cdarroch left
[02:12] <colomon> \o/ Advent calendar is done!

[02:13] <Juerd> :(

[02:16] *** yogurt_truck joined
[02:22] *** patspam left
[02:23] *** eiro left
[02:23] *** patspam joined
[02:26] <diakopter> colomon: but wait, there's 366 days until the following Christmas

[02:26] <diakopter> so, at least 366 more Advent Calendar posts to go!

[02:27] <colomon> diakopter: I wouldn't mind restarting it in the January.  But I'm very happy to celebrate a job well done now.  :)

[02:33] *** JimmyZ joined
[02:40] *** felipe joined
[02:50] *** meppl left
[02:51] *** agentzh joined
[02:53] *** mubot left
[02:53] *** pointme left
[02:53] *** zaslon left
[02:54] *** pointme joined
[02:54] *** mubot joined
[02:54] *** zaslon joined
[03:28] *** JimmyZ left
[03:35] *** rbaumer joined
[03:40] *** japhb left
[03:48] *** colomon left
[04:13] *** japhb joined
[04:21] *** rbaumer left
[04:22] *** rbaumer joined
[04:23] *** rbaumer left
[04:27] *** bluescreen left
[04:32] *** nihiliad left
[04:39] *** eiro_ is now known as eiro

[04:46] *** nihiliad joined
[04:46] *** justatheory left
[05:15] *** buubot left
[05:36] *** buubot joined
[05:42] *** niella joined
[05:43] *** silent11 joined
[05:44] *** gfx joined
[05:55] *** orafu left
[05:56] *** orafu joined
[05:59] *** nihiliad left
[06:06] *** bryan[c1] left
[06:08] *** silent11 left
[06:11] *** niella left
[06:19] *** tsbtmn left
[06:28] *** patspam left
[06:29] <diakopter> I'm tickled that Synopsis 5 on feather is the 2nd result on google for "S05"

[06:32] <diakopter> std: $///$////$$/

[06:32] <p6eval> std 29391: ok 00:01 106m␤

[06:34] *** youwin joined
[06:36] <youwin> does any other language have a .comb method or is it completely a new idea for perl6?

[06:42] <diakopter> it's kindof a global (but non-overlapping) match aggregator

[06:42] *** Baggio_ joined
[06:43] <diakopter> youwin: I don't know whether there is a precedent; likely someone somewhere wrote up a routine to do that sort of thing.

[06:43] <youwin> well its not exactly brand new thing, i could do a while (/../g), but this is the first ive heard it called that and made into a method of a string

[06:43] * Tene considers, after doing it YET AGAIN, echo "alias :w='git commit -a'" >> ~/.aliases

[06:43] <Tene> Probably not the best idea, but it's at least debatable.

[06:43] <youwin> its a great idea

[06:43] <youwin> i like it

[06:44] <youwin> if you provide split, you might as well have comb

[06:44] <Tene> Yes, I agree. :)

[06:44] *** yogurt_truck left
[06:44] <diakopter> youwin: well, there's the task of getting only the non-overlapping matches

[06:45] <youwin> theres no way to make it get overlapping matches?

[06:46] <youwin> not sure how useful that would be though

[06:46] <diakopter> that's what you get by iterating a "normal" global match

[06:54] <diakopter> std: token space_cadet { BEGIN { <.space_cadet> } }

[06:54] <p6eval> std 29391: ok 00:01 105m␤

[06:55] <diakopter> std: token token { <token> }

[06:55] <p6eval> std 29391: ok 00:01 104m␤

[06:57] <diakopter> std: token foo { ^^ . ^^ }

[06:57] <p6eval> std 29391: ok 00:01 104m␤

[07:04] *** mberends joined
[07:05] <diakopter> mberends: hi

[07:05] <mberends> hi diakopter, 7 hours was needed apparently. backlogging...

[07:05] <phenny> mberends: 00:16Z <diakopter> tell mberends and miguel adds multiple return to mono/C#: http://tirania.org/blog/archive/2009/Dec-23.html

[07:05] <phenny> mberends: 01:56Z <diakopter> tell mberends named capturing groups working, in addition to lookahead (pos and neg)

[07:05] <mberends> w00t!

[07:06] <mberends> "Sprixel Reloaded" is going to be awesome

[07:08] <diakopter> we'll see

[07:08] <diakopter> I'm sticking with the "there's that crazy diakopter" routine so as to keep expectations low, hopefully.

[07:09] <diakopter> oh wait, did I say that out loud? :/

[07:09] <diakopter> oh, and, it'll do 1e44 regex executions per second. ;)

[07:10] <mberends> yeah, we all know how it goes

[07:12] <diakopter> :)

[07:12] <diakopter> there's something different about working on code alone and "dark"

[07:13] <diakopter> much more freedom to fail, but also much more freedom to tinker and try newish things that are easy to label "throwaway" in hindsight

[07:13] <mberends> ...that you like?

[07:13] *** lestrrat is now known as lest_away

[07:15] <diakopter> yeah.. but of course there are detriments

[07:15] <mberends> I was itching to publish vill asap, but wanted a minimum proof of viability, and did not end up with what I had was aiming for

[07:16] <diakopter> imho, the bar (for "viability") will continually rise

[07:16] <diakopter> (as the costs go from opportunity to sunk)

[07:17] <diakopter> (and the pressure to justify previous decisions/activity rises)

[07:18] <mberends> "fail publicly" is ok, there are usually takeaway lessons. yes, justifying decisions publicly is harder, but then the extra brains are mostly helpful. pmurias++ also encourages me at multiple levels.

[07:20] * diakopter watched "Armored" (a movie) in a theater tonight.  An ok movie, as Matt Dillon/Laurence Fishburne heist movies go.

[07:20] <diakopter> , but visions of ILGenerators danced in my head

[07:21] * mberends had an xkcd # 224 type dream, except it was Perl 6

[07:24] <mberends> that C# Tuple reference doesn't impress. Break platform independence to achieve little more than syntactic sugar for a Collection-y thing.

[07:25] <diakopter> http://www.modernperlbooks.com/mt/2009/12/helping-perl-packagers-package-perl.html slashdotted

[07:26] <mberends> we could put the book on our Christmas lists, no, wait, oh...

[07:27] <diakopter> mberends: yeah, and I don't see how he'd distinguish an actual comma operator

[07:27] *** meppl joined
[07:27] <mberends> C# is stealing ideas from Perl! Again!

[07:28] <eiro> good thing! 

[07:28] <eiro> no ? 

[07:29] <mberends> good thing, if it were to be true, which I don't seriously believe

[07:31] <diakopter> o wait. no comma operator in C#.  /me feels silly

[07:35] <eiro> :)

[07:37] <mberends> under the C# Tuple article, 7 hours ago Robert Friberg commented "I have had classes Tuple<T,U> and Tuple<T,U,V> in my utilities library since 2.0...."

[07:39] <diakopter> yeah; shows that Robert Friberg didn't read the article

[07:41] <mberends> so the Tuple Patch is purely the assignment to a list of scalars, like Perl 5 does.

[07:41] <diakopter> and also the final slurpy slot

[07:42] <diakopter> basically, list context for assignment

[07:42] <mberends> ah, found the slurpy concept, missed it earlier

[07:50] <diakopter> I find it interesting that a MIPS jump address table header field is part of the CIL specification

[07:50] <mberends> chromatic is so good at thinking through improvements, also for Perl 5 packagers.  Hopefully this time the suggestions don't get blocked by the keep-off-my-lawn brigade.

[07:50] <mberends> diakopter: you're not serious, are you?

[07:50] <diakopter> yes

[07:51] <mberends> spec url?

[07:52] <diakopter> well, more precisely, it's part of the PE spec

[07:55] <mberends> MIPS not found in http://www.ecma-international.org/publications/standards/Ecma-335.htm

[07:55] <mberends> diakopter: but I believe you

[07:56] <diakopter> the portable executable spec

[07:57] <mberends> found lots of Microsoft pages

[07:58] <diakopter> http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/pecoff_v8.docx

[07:58] <mberends> and this one: http://ntcore.com/files/inject2exe.htm

[07:59] *** gfx left
[07:59] *** gfldex left
[07:59] *** gfldex joined
[08:03] *** JimmyZ joined
[08:03] <JimmyZ> Welcome to the website of Perl 9!

[08:03] <JimmyZ> Perl 9 is the next major release after Perl 6. Perl 8 has been left out because Perl 9 provides too much new features which would not fit into one major version number. Perl 9 combines all features of Perl 5 and Perl 6. This site only demonstrates some additional features over Perl 5 and Perl 6.

[08:03] <mberends> fair enough, MIPS alongside x86, PPC, ARM, Itanic etc

[08:04] <diakopter> JimmyZ: eh?

[08:04] *** FalseVinylShrub joined
[08:04] <JimmyZ> perl9.org ;)

[08:04] <diakopter> oh; heh

[08:04] <JimmyZ> somebody's site.

[08:05] <hejki> :D

[08:05] <mberends> a little innocent spoof

[08:06] <hejki> http://www.perl9.org/?site=New-Features/Random-Operator

[08:06] <hejki> :DD

[08:09] <diakopter> I was just about to paste that; my fav so far

[08:09] <mberends> nonsense, but fun. Hypergoto, Infinite-Loops and Megahyper-Operators are my faves

[08:13] <mberends> no mention of implementation - will require an Albatross VM

[08:16] <carlin> std: $foo (}}}}@.@{{{{) $bar;

[08:16] <p6eval> std 29391: ===SORRY!===␤Confused at /tmp/clTrqfilmi line 1:␤------> $foo ⏏(}}}}@.@{{{{) $bar;␤    expecting any of:␤       infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤Other potential difficulties:␤  Variable

[08:16] <p6eval> ..$foo is not pre…

[08:17] <carlin> I'm wondering what happened to Perl 7

[08:18] <Tene> That's left open for the other next version of Perl 6.

[08:19] <mberends> for Boxing Day

[08:38] *** kaare joined
[08:39] *** kaare is now known as Guest21602

[08:48] *** JimmyZ_ joined
[08:56] *** Baggio_ left
[08:56] *** JimmyZ left
[09:05] *** FalseVinylShrub left
[09:11] *** Baggio_ joined
[09:18] *** ejs joined
[09:21] *** [particle]1 joined
[09:25] *** [particle] left
[09:27] *** lest_away is now known as lestrrat

[09:37] *** iblechbot joined
[09:38] *** tempire left
[09:39] <masak> the Perl 9 site is the best parody of Perl 6 I've ever seen.

[09:39] <masak> oh, and g'morning on Christmas Eve, peeps.

[09:40] <masak> in Sweden, the 24th is the big day (with opening presents and celebrating in other ways), not the 25th as in the English-speaking world.

[09:42] *** pjcj joined
[09:42] <masak> anyway: most things on the Perl 9 site are wrong, but they are wrong in interesting ways -- it would almost be worth it to go through spoof and reality in parallel in a blog post, and compare them.

[09:42] <masak> like this:

[09:43] <masak> different grammars. spoof: an AI thingy senses whether you want to code Lisp or Python. reality: just predeclare on top to modify your grammar as you want.

[09:43] *** Baggio_ left
[09:44] <masak> infinite loops: spoof: an infinite loop runs really fast. reality: no, but we have this nice keyword 'loop' which ends the C hegemony or three arbitrary and silly ;-separated arguments, leading to insecure and hard-to-debug loop constructs.

[09:45] <masak> megamegahyper operators. spoof: just add on layers of >><< to go more mega and more hyper. reality: you don't need that; you get it for free in the first layer. neat, huh?

[09:46] <masak> mix up "contexes". spoof: some far-fetched idea where a variable behaves differently when used in scalar context or in list context. reality: some more mundane idea where a variable behaves differently when used in different contexts.

[09:48] <masak> reverse method syntax. spoof: you can do both $obj->method and method<-$obj. reality: you can't but if that floats your boat, just make a grammar-changing module, and predeclare it on top.

[09:49] <masak> ...so you see, if you remove the parodying grime from the lens, Perl 6 *is* Perl 9 already. :)

[09:50] <mberends> masak: there will be modules...   # afk again

[09:50] <masak> there will indeed.

[09:53] <carlin> the random operator could be declared as an infix

[09:54] <masak> for great justice.

[09:55] <masak> rakudo: sub infix:<(}}}}@.@{{{{)>($a, $b) { 'something random!' }; say 2 (}}}}@.@{{{{) 5

[09:55] <p6eval> rakudo 8dc189: something random!␤

[09:56] <masak> \o/

[09:57] *** cotto joined
[10:03] <Tene> masak: Making a lot of progress on quoting and macros in my scheme compiler.  Lots of fun.  I'm excited about implementing it in Rakudo, so a little sad that it looks like it won't be feasible in Rakudo until after ng replaces trunk.

[10:03] <Tene> I'm still hopeful about getting it in before *, though.

[10:04] <masak> Tene: woot!

[10:04] <Tene> I'm probably going to be playing with generating a parameterizable AST tomorrow.

[10:04] <masak> nice.

[10:05] <masak> I don't have wireless access to the 'Net where I am, so I'm slightly restriced in my movements.

[10:05] <masak> I hope to get a fair amount of GGE work and 7-wonders writing and Web.pm finalization done, though.

[10:05] <Tene> I should have a lot of free time this weekend, hopefully, so I really need to remember to go through all of the HLLs and make sure they work on latest Parrot, migrate them to NQP-rx, update them to the latest HLL interop spec, etc.

[10:06] <Tene> That's the actually-valuable grunt-work task I need to work through.

[10:06] *** jferrero joined
[10:06] <Tene> If I talk about it in public, greater chance I'll get it done.

[10:06] <Tene> shame-driven-development++

[10:07] * moritz_ wanted to work on the book a bit more, but hasn't really got around to it yet

[10:07] <JimmyZ_> masak: http://www.perl9.org/?site=Extended-Features/Megahyper-Operators

[10:07] <moritz_> having two families to celebrated christmas with is rather distracting :-)

[10:07] <Tene> JimmyZ_: 02:45 < masak> megamegahyper operators. spoof: just add on layers of >><< to go more mega and more hyper. reality: you don't need that; you get it for free in the first layer. neat, huh?

[10:07] <JimmyZ_> oh

[10:15] <masak> by the way: sometimes I wonder what the difference is between a module that does language tweaks for itself and one that does language tweaks for its importing module/script. does anyone know?

[10:16] <JimmyZ_> rakudo: sub infix:<(}}}}@.@{{{{)>($a, $b) { return ($a*$b,$a+$b).pick(1, :replace)}; say 2 (}}}}@.@{{{{) 5

[10:16] <p6eval> rakudo 8dc189: 7␤

[10:16] <JimmyZ_> rakudo: sub infix:<(}}}}@.@{{{{)>($a, $b) { return ($a*$b,$a+$b).pick(1, :replace)}; say 2 (}}}}@.@{{{{) 5

[10:16] <p6eval> rakudo 8dc189: 10␤

[10:17] <JimmyZ_> oh, perl 9 

[10:17] <Tene> masak: I conjecture that the macro is exported.

[10:17] <Tene> that is, the importing module fetches language modifications from the used module and installs them into its local grammar.

[10:18] <Tene> I don't recall if an API for that is defined or not.

[10:18] <moritz_> so can you write grammar modifications without applying them locally?

[10:18] <Tene> If not, that's a problem.

[10:18] <Tene> I don't see why you wouldn't be able to, though.

[10:18] <mberends> yes, the importing scope receives the language mods, provided the imported module does not encapsulate them in an inner scope.

[10:19] <masak> JimmyZ: why :replace if you only .pick once?

[10:20] <mberends> oh no, the module *is* a scope, which you need to puncture with 'is export'

[10:20] <JimmyZ_> masak: that's a mistake.

[10:20] <JimmyZ_> can  remove it.

[10:20] <masak> JimmyZ_: no problem, just wondering.

[10:20] <JimmyZ_> masak: ;)

[10:21] <JimmyZ_> rakudo: sub infix:<(}}}}@.@{{{{)>($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 (}}}}@.@{{{{) 5

[10:21] <p6eval> rakudo 8dc189: 7␤

[10:21] <JimmyZ_> rakudo: sub infix:<(}}}}@.@{{{{)>($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 (}}}}@.@{{{{) 5

[10:21] <p6eval> rakudo 8dc189: 0.4␤

[10:21] <masak> actually, even the '1' is redundant :)

[10:21] <JimmyZ_> yes

[10:23] <masak> ...but not wrong, of course.

[10:24] <JimmyZ_> rakudo: sub infix:<(+-*/ :random)>($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 (+-*/ :random) 5

[10:24] <p6eval> rakudo 8dc189: Syntax error at line 2, near ") 5"␤in Main (file <unknown>, line <unknown>)␤

[10:25] <masak> I'd venture that the space confuses the optable parser.

[10:25] <masak> try without it.

[10:25] <JimmyZ_> rakudo: sub infix:<(+-*/:random)>($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 (+-*/:random) 5

[10:25] <p6eval> rakudo 8dc189: 0.4␤

[10:25] <JimmyZ_> rakudo: sub infix:<(+-*/:random)>($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 (+-*/:random) 5

[10:25] <moritz_> right, whitespaces are not allowed in operators

[10:25] <p6eval> rakudo 8dc189: 10␤

[10:26] <masak> moritz_: but there should probably be a warning or something.

[10:26] <moritz_> agreed

[10:27] *** jrockway joined
[10:27] * masak submits rakudobug

[10:27] <moritz_> submit a specbug first :-)

[10:28] <JimmyZ_> I like the space there

[10:28] <masak> moritz_: you mean whitespace aren't explicitly disallowed in the spec?

[10:28] <JimmyZ_> ng has been stopped for a month?

[10:29] <moritz_> masak: they are, but it's not specced that it should warn

[10:29] <moritz_> std: multi infix:<a b>($a, $b) { }

[10:29] <p6eval> std 29391: ok 00:01 108m␤

[10:30] <JimmyZ_> rakudo: sub infix:<>>($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 > 5

[10:30] <p6eval> rakudo 8dc189: Malformed routine definition at line 2, near "infix:<>>("␤in Main (file <unknown>, line <unknown>)␤

[10:30] <JimmyZ_> rakudo: sub infix:< > >($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 > 5

[10:30] <p6eval> rakudo 8dc189: Malformed routine definition at line 2, near "infix:< > "␤in Main (file <unknown>, line <unknown>)␤

[10:31] <JimmyZ_> rakudo: sub infix:<< > >>($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 > 5

[10:31] <p6eval> rakudo 8dc189: maximum recursion depth exceeded␤in Main (file <unknown>, line <unknown>)␤

[10:31] * moritz_ hands JimmyZ_ a pair of « »

[10:31] <JimmyZ_> rakudo: sub infix:<<>>>($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 > 5

[10:31] <p6eval> rakudo 8dc189: Malformed routine definition at line 2, near "infix:<<>>"␤in Main (file <unknown>, line <unknown>)␤

[10:31] <JimmyZ_> can't use << >> ?

[10:31] <moritz_> NYI

[10:32] <JimmyZ_> rakudo: sub infix:< +-*/ >($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 +-*/ 5

[10:32] <p6eval> rakudo 8dc189: 10␤

[10:37] *** Su-Shee joined
[10:38] <Su-Shee> good morning.

[10:40] *** cls_bsd left
[10:40] *** sushant joined
[10:40] *** JimmyZ_ left
[10:41] <sushant> hi

[10:41] *** sushant left
[10:42] <moritz_> \o

[10:42] <moritz_> merry christmas to all who celebrate it today!

[10:42] *** szabgab left
[10:44] *** szabgab joined
[10:47] *** rgrau left
[10:56] *** agentzh left
[11:00] <carlin> It's now the 25th here :-)

[11:00] <carlin> Merry Christmas everyone

[11:01] <mberends> merry xmas carlin # .nz win

[11:09] <Juerd> Merry Christmas where applicable

[11:09] <Juerd> Merry *.

[11:12] *** FalseVinylShrub joined
[11:14] *** ejs left
[11:15] *** ejs joined
[11:17] *** TiMBuS left
[11:34] <wayland76> Btw, do you all know what Father Christmas' wife's name is?

[11:38] *** Helios joined
[11:40] *** ejs1 joined
[11:40] *** rodi joined
[11:40] <masak> wayland76: Mary, I'd venture.

[11:40] <wayland76> Yes, Mary Christmas :)

[11:41] <masak> :)

[11:42] <masak> On a gamesite where I play interesting connection games, there's a forum featuring players of varying degrees of language mastery. a year or so ago someone started a thread called "Marry Christmas!". it spawned an interesting discussion, with jokes intermixed with language discussion.

[11:46] *** Helios left
[11:47] *** Helios-- joined
[11:54] *** ejs left
[11:55] *** aindilis joined
[11:56] *** ejs1 left
[12:02] *** pmurias joined
[12:04] *** Su-Shee left
[12:05] <rodi> masak: thanks for the nice mention in your P6Advent post.  Sorry I didn't see your tweet, but of course you can use it :)

[12:09] <masak> rodi: I'm relieved, and happy my hunch was correct. :)

[12:09] <masak> rodi: it's also wonderful to see someone else make one-line Perl 6 scripts that output something neat.

[12:10] <masak> kudos.

[12:10] <rodi> I had a snow day on Monday, needed to celebrate :-P

[12:12] *** Su-Shee joined
[12:14] <masak> (people who celebrate by writing Perl 6)++

[12:16] * pmurias celebrates by writing some Perl 5

[12:17] *** jho joined
[12:21] *** Baggio_ joined
[12:27] *** Beetny left
[12:32] *** FalseVinylShrub left
[12:38] *** ejs joined
[12:38] *** Calimbeul left
[12:39] *** colomon joined
[12:42] <pmurias> mberends: hi

[12:43] <pugs_svn> r29392 | pmurias++ | [mildew] make -Cdesugar output slightly prettier 

[12:43] *** colomon left
[12:45] *** FalseVinylShrub joined
[12:47] *** colomon joined
[12:48] *** colomon left
[12:49] *** colomon joined
[12:50] <pugs_svn> r29393 | pmurias++ | [mildew] one more fix to -Cdesugar 

[12:55] *** rgrau joined
[12:56] <masak> std: gather take $_ for 1, 2, 3;

[12:56] <p6eval> std 29393: ok 00:01 108m␤

[12:56] <masak> does that parse as (gather take $_) for 1, 2, 3 or as gather (take $_ for 1, 2, 3) ?

[13:01] <pmurias> isn't for a statement_modifier?

[13:03] <pmurias> masak: it seems that it parses as gather (take $_ for 1,2,3))

[13:10] *** payload joined
[13:11] *** Su-Shee left
[13:15] *** eiro left
[13:15] *** eiro joined
[13:15] <pugs_svn> r29394 | pmurias++ | [mildew] remove useless files 

[13:19] <masak> pmurias: good. that's the most useful parsing, in my view.

[13:28] *** colomon left
[13:33] *** Su-Shee joined
[13:49] *** cls_bsd joined
[13:50] *** colomon joined
[13:53] *** orafu left
[13:53] *** orafu joined
[14:01] *** _jaldhar joined
[14:02] *** iblechbot left
[14:12] *** arthur-_ joined
[14:14] *** arthur-_ left
[14:25] *** arthur-_ joined
[14:27] *** Baggio_ left
[14:27] *** arthur-_ left
[14:28] *** IllvilJa joined
[14:31] <IllvilJa> Merry Christmas greetings from Sweden to everyone at #perl6! http://www.youtube.com/watch?v=2A3kMTZwSQ8

[14:35] *** arthur-_ joined
[14:35] *** arthur-_ left
[14:47] *** patspam joined
[14:56] <colomon> Any ng experts out there?  I was wondering what it would take to make ~~ accept Code or Callable or whatever it is called.

[14:56] *** jferrero left
[14:56] <colomon> Seems like a simple ACCEPTS would do it, but I'm not quite sure where....

[14:57] <colomon> Looks like Block already does this?

[15:01] *** cdarroch joined
[15:04] *** Psyche^ joined
[15:04] *** Patterner left
[15:04] *** Psyche^ is now known as Patterner

[15:05] <colomon> rakudo: my $a = { $^num > 0; }; say 10 ~~ $a;

[15:05] <p6eval> rakudo 8dc189: 1␤

[15:05] <colomon> ng: my $a = { $^num > 0; }; say 10 ~~ $a;

[15:05] <p6eval> ng 9d5018: 1␤

[15:13] <colomon> oh, so that works fine.  The broken thing is a block with $_ in it.

[15:13] <colomon> I think.

[15:14] <colomon> ng: my $a = { $_ > 0; }; say 10 ~~ $a;

[15:14] <p6eval> ng 9d5018: 0␤

[15:14] <colomon> ng: my $a = { $_ > 0; }; say $a.arity

[15:14] <p6eval> ng 9d5018: 0␤

[15:14] <colomon> ng: my $a = { $^num > 0; }; say $a.arity;

[15:14] <p6eval> ng 9d5018: 1␤

[15:15] *** patspam1 joined
[15:15] <colomon> ng: say (1...11).list

[15:15] <p6eval> ng 9d5018: sh: ./perl6: No such file or directory␤

[15:15] *** patspam left
[15:19] *** payload left
[15:21] *** arthur-_ joined
[15:24] *** arthur-_ left
[15:26] *** nihiliad joined
[15:30] *** JimmyZ joined
[15:30] *** arthur-_ joined
[15:30] <JimmyZ> o'hai

[15:31] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return ($a*$b,$a+$b,$a-$b,$a/$b).pick(1)}; say 2 +-*/ 5 #Will it be lazy?

[15:31] <p6eval> rakudo 8dc189: 0.4␤

[15:32] *** arthur-_ left
[15:32] <colomon> how would it be lazy? 

[15:32] <JimmyZ> first pick, then eval the expr

[15:33] <JimmyZ> not eval all expr, then pick

[15:33] <colomon> Ah.

[15:33] <colomon> My impression is the answer is no.

[15:34] <JimmyZ> I wish It'd be lazy

[15:34] <colomon> At least, not in rakudo master or ng.

[15:34] <colomon> Yeah, I can see where that might be handy in general.

[15:34] <JimmyZ> oh at least, Is there a lazy way?

[15:35] <JimmyZ> s/oh/or

[15:35] <colomon> I'm sure it could be conjured up, but it would be a lot more work.

[15:35] <JimmyZ> or Will it be lazy?

[15:36] <JimmyZ> I wish it will ;)

[15:36] *** ashizawa left
[15:37] <colomon> I've been making the solution too complicated.  What you really want is something like

[15:38] <JimmyZ> Any way that lazy is ok

[15:39] *** patspam joined
[15:39] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return (->{$a*$b},->{$a+$b}).pick()}; say 2 +-*/ 5

[15:39] <p6eval> rakudo 8dc189: _block83␤

[15:39] *** FalseVinylShrub left
[15:39] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return (->{$a*$b},->{$a+$b}).pick()}; say 2 +-*/() 5

[15:39] <p6eval> rakudo 8dc189: Confused at line 2, near "5"␤in Main (file <unknown>, line <unknown>)␤

[15:40] <colomon> rakudo: sub infix:< +-*/ >($a, $b) { (({ $^x * $^y }, { $^x + $^y }, { $^x - $^y }, { $^x / $^y }).pick(1))($a, $b); }; say 2 +-*/ 5;

[15:40] <p6eval> rakudo 8dc189: 0.4␤

[15:40] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return ((->{$a*$b},->{$a+$b}).pick())()}; say 2 +-*/ 5

[15:40] <p6eval> rakudo 8dc189: 10␤

[15:40] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return ((->{$a*$b},->{$a+$b}).pick())()}; say 2 +-*/ 5

[15:40] <p6eval> rakudo 8dc189: 10␤

[15:40] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return ((->{$a*$b},->{$a+$b}).pick())()}; say 2 +-*/ 5 # I think it's a lazy way.

[15:40] <p6eval> rakudo 8dc189: 7␤

[15:41] *** patspam2 joined
[15:41] <colomon> JimmyZ: look at my paste up there.  It is lazy in the sense you want.

[15:41] <colomon> s/paste/rakudo line/

[15:41] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return ((->{$a*$b},->{$a+$b}).pick())()}; say 2 +-*/ 5 # I think it's lazy to

[15:41] <p6eval> rakudo 8dc189: 10␤

[15:42] <colomon> Hmmm... yours might be too, though, now that I see what you're trying to do.

[15:43] <colomon> I believe -> is unnecessary.

[15:44] <dalek> rakudo/ng: 0977b1e | (Solomon Foster)++ | src/core/Any-list.pm:

[15:44] <dalek> rakudo/ng: Lightly tested ng versions of the Rakudo Any.first and Any.grep methods.

[15:44] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/0977b1ec693f8bff64b3af92e8c4432d22c394ff

[15:44] <JimmyZ> colonmon: we are the same, using block makes it's lazy

[15:44] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return (({$a*$b},{$a+$b}).pick())()}; say 2 +-*/ 5 # I think it's lazy to

[15:44] <p6eval> rakudo 8dc189: 10␤

[15:44] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return (({$a*$b},{$a+$b}).pick())()}; say 2 +-*/ 5

[15:44] <p6eval> rakudo 8dc189: 7␤

[15:45] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return ({$a*$b},{$a+$b}).pick()}; say 2 +-*/ 5

[15:45] <p6eval> rakudo 8dc189: _block72␤

[15:45] <colomon> JimmyZ: we're using a slightly different approach -- my pick returns a Block with arity 2 and no fixed variables, yours returns one with arity 0 and $a and $b baked in.

[15:45] <colomon> I don't have any feel yet for which approach is preferable.  :)

[15:46] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return ({$a*$b},{$a+$b}).pick()>>.()}; say 2 +-*/ 5

[15:46] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { return ({$a*$b},{$a+$b})>>.()}; say 2 +-*/ 5

[15:46] <p6eval> rakudo 8dc189: Can only transform an Object to p6opaque␤in Main (file src/gen_setting.pm, line 324)␤

[15:47] *** rgrau left
[15:49] *** SmokeMachine joined
[15:49] <JimmyZ> yep, they are all closure

[15:50] *** zamolxes joined
[15:52] <colomon> pmichaud, jnthn: I believe first and grep are basically right now, but unfortunately their tests depend heavily on $_ giving the correct arity in code blocks.  I guess I could rewrite all the tests to use $^a instead, but that seems wrong...

[15:52] <JimmyZ> rakudo: sub infix:< +-*/ >($a, $b) { (({$a*$b},{$a+$b}).pick())()}; say 2 +-*/ 5

[15:52] <p6eval> rakudo 8dc189: 7␤

[15:55] *** patspam1 left
[15:55] <dalek> rakudo/ng: 78e4226 | (Solomon Foster)++ | src/core/Any-list.pm:

[15:55] <dalek> rakudo/ng: Add protos for first and grep.

[15:55] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/78e42267d48141418ceafc7ed41676fa2acc51e8

[15:55] *** FalseVinylShrub joined
[15:56] <JimmyZ> rakudo: sub infix:< +||-||*||/ >($a, $b) { (({$a*$b},{$a+$b}, {$a-$b}, {$a/$b}).pick())()}; say 2 +||-||*||/ 5

[15:56] <p6eval> rakudo 8dc189: 10␤

[15:57] *** patspam left
[15:58] *** ^aristotle joined
[15:58] <^aristotle> is there a way to declare a hash as taking a pair of strings as keys?

[15:59] <colomon> ^aristotle: Yes in theory, I don't think it's implemented in Rakudo yet.  (And I don't know the syntax to do it.)

[16:00] <^aristotle> colomon: ok

[16:00] <^aristotle> are multidimensional hashes implemented, at least?

[16:00] <JimmyZ> like?

[16:00] <colomon> you mean like $a{"b"}{"d"} ?

[16:00] <colomon> hashes of hashes?

[16:01] <^aristotle> well the problem I have is that something like  ++$hash{$key1}{$key2}  will autovivify the second-level key

[16:02] <^aristotle> but apparently won't autovivify the top-level hash access

[16:02] <^aristotle> so I need to sprinkle  $hash{$key1} //= {}  around the place

[16:03] <^aristotle> that's not very nice

[16:03] <colomon> I'm pretty sure that's just Rakudo limitation, but I don't know any clever way around it.

[16:03] <^aristotle> well then I thought

[16:03] <colomon> But I'm hardly a hash expert.  

[16:03] <colomon> There may be a way around it I don't know.

[16:03] <^aristotle> what I really want to do is use a pair of strings as the key

[16:04] <^aristotle> I don't really want a hash of hashes there

[16:04] <diakopter> ^aristotle: so just concat them

[16:04] <colomon> If you could come up with a short string you knew wouldn't appear in the others, you could do something like $hash{$key1 ~ "safe string" ~ $key2}

[16:04] *** JimmyZ left
[16:05] <diakopter> o yeah; you'd need a delimiter

[16:05] <diakopter> <-- not yet awake

[16:05] <^aristotle> colomon: wait, I have 1991 on the phone, they want perl4 back

[16:06] *** reqamst_ left
[16:06] <colomon> ^aristotle: if it's a big problem for you, no one will complain if you implement it in Rakudo.

[16:07] <^aristotle> (perl4 didn't have references so the way you did multidimensional structures was by concating indices with some delimiter)

[16:07] <^aristotle> colomon: I'm just saying I'd rather do it the perl5 way than the perl4 way if rakudo doesn't yet let me do it the perl6 way

[16:12] *** rodi left
[16:14] <^aristotle> another question

[16:15] <^aristotle> I have two hashes

[16:15] *** arthur-_ joined
[16:15] <^aristotle> I want to perform an operation on the combination of each pair from one hash with each pair from the other hash

[16:16] <^aristotle> in other languages one would write a nested loop

[16:16] <^aristotle> in p6 I can do    for $h1.pairs X $h2.pairs -> $h1p, $h2p { ... }

[16:17] <^aristotle> but can I make that a destructuring bind somehow?

[16:17] <colomon> "destructuring bind"?

[16:17] <^aristotle> I tried this, on a lark:

[16:17] <^aristotle> for $h1.pairs X $h2.pairs -> ( $h1key, $h2val ), ( $h2key, $h2val ) { ... }

[16:17] *** arthur-_ left
[16:17] <colomon> ah.

[16:17] <^aristotle> that doesn't work... is that rakudo or my p6?

[16:18] <sjohnson> 3merry xmas eve to all

[16:18] <^aristotle> is there some way to write this so that I have a single loop and still all 4 values in one variable each?

[16:22] <diakopter> maybe not without breaking out each pair into its parts at the beginning of the loop

[16:22] *** arthur-_ joined
[16:23] * diakopter doesn't know

[16:24] *** arthur-_ left
[16:24] *** arthur-_ joined
[16:24] <sjohnson> honestkopter ^_^

[16:25] *** arthur-_ left
[16:26] *** arthur-_ joined
[16:29] *** abra joined
[16:31] *** abra left
[16:31] *** abra joined
[16:40] *** abra left
[16:40] *** abra joined
[16:52] <diakopter> mberends: I made a mono 2.6.1 .deb for lenny i386 (using alien); seems no problems.

[16:53] <diakopter> working on amd64

[16:55] <diakopter> mberends: I just had to apt-get install libglib2.0-0

[16:56] *** FalseVinylShrub left
[16:56] <^aristotle> how do I get from  [[1],[2,3],[4]]  to  [1,2,3,4]  ?

[16:57] <^aristotle> has to be some way to do this with some reduction operation?

[16:57] *** FalseVinylShrub joined
[16:59] *** justatheory joined
[17:00] *** abra left
[17:00] <sjohnson> rakudo:  my @a = <<1> <2 3> <4>>; my @b; for (@a) { @b.push(@a.keys)); }; say @b.perl;

[17:00] <p6eval> rakudo 8dc189: Unable to parse block; couldn't find final '}' at line 2, near "); }; say "␤in Main (file <unknown>, line <unknown>)␤

[17:00] <sjohnson> rakudo:  my @a = <<1> <2 3> <4>>; my @b; for (@a) { @b.push(&$_.keys)); }; say @b.perl;

[17:00] <p6eval> rakudo 8dc189: Unable to parse block; couldn't find final '}' at line 2, near "); }; say "␤in Main (file <unknown>, line <unknown>)␤

[17:00] <diakopter> extra )

[17:01] <sjohnson> rakudo:  my @a = <<1> <2 3> <4>>; my @b; for (@a) { @b.push(&$_.keys); }; say @b.perl;

[17:01] <p6eval> rakudo 8dc189: [0, 0, 0, 0]␤

[17:01] <sjohnson> rakudo:  my @a = <<1> <2 3> <4>>; my @b; for (@a) { @b.push(@$_.keys); }; say @b.perl;

[17:01] <p6eval> rakudo 8dc189: Symbol '@$_' not predeclared in <anonymous> (/tmp/YbwDLbKB3u:2)␤in Main (file <unknown>, line <unknown>)␤

[17:01] *** jho left
[17:01] <sjohnson> rakudo:  my @a = <<1> <2 3> <4>>; my @b; for (@a) { @b.push(@_.keys); }; say @b.perl;

[17:01] <p6eval> rakudo 8dc189: []␤

[17:01] <sjohnson> ahh who knows

[17:02] *** abra joined
[17:02] <sjohnson> rakudo:  my @a = <<1> <2 3> <4>>; my @b; for (@a) { print @a.WHAT~" "; }

[17:02] <p6eval> rakudo 8dc189: Array() Array() Array() Array() 

[17:03] <sjohnson> rakudo:  my @a = <<1> <2 3> <4>>; my @b; for (@a) { @b.push(@_.values); }; say @b.perl;

[17:03] <p6eval> rakudo 8dc189: []␤

[17:03] <sjohnson> rakudo:  my @a = <<1> <2 3> <4>>; my @b; for (@a) { @b.push(@_); }; say @b.perl;

[17:03] <p6eval> rakudo 8dc189: []␤

[17:03] <sjohnson> rakudo:  my @a = <<1> <2 3> <4>>; my @b; for (@a) { @b.push($_); }; say @b.perl;

[17:04] <p6eval> rakudo 8dc189: ["1>", "<2", "3>", "<4"]␤

[17:04] <sjohnson> ???

[17:04] <sjohnson> too advanced for my dinosaur-sized brain

[17:06] <sjohnson> oh

[17:06] <sjohnson> i c

[17:06] <sjohnson> hmm maybe not

[17:07] <sjohnson> can @_ be the array in a for loop like this?

[17:08] *** abra left
[17:08] *** abra joined
[17:10] *** colomon left
[17:10] <diakopter> rakudo: my @a = [[1], [2,3], [4]]; my @b; multi flatten(@d, @c) { for @c { flatten(@d, $_) } }; multi flatten(@d, $c) { @d.push($c) }; flatten(@b, @a); say @b.perl;

[17:10] <p6eval> rakudo 8dc189: [1, 2, 3, 4]␤

[17:11] *** obra is now known as obra_grinch

[17:12] *** obra_grinch is now known as obra

[17:12] <diakopter> rakudo: my @a = [[1], [2,[3,4,5]], [4]]; my @b; multi flatten(@d, @c) { for @c { flatten(@d, $_) } }; multi flatten(@d, $c) { @d.push($c) }; flatten(@b, @a); say @a.perl; say @b.perl; # sjohnson 

[17:12] <p6eval> rakudo 8dc189: [[[1], [2, [3, 4, 5]], [4]]]␤[1, 2, 3, 4, 5, 4]␤

[17:13] <diakopter> ^aristotle: see ^^

[17:15] <sjohnson> oh, is it because i need to use [] ref context?

[17:15] <sjohnson> or is that not even the case in p6 diakopter 

[17:16] <sjohnson> rakudo:  my @a = [[1], [2,[3,4,5]], [4]]; my @b; multi flatten(@d, @c) { for @c { flatten(@d, $_) } }; multi flatten(@d, $c) { @d.push($c) }; flatten(@b, @a); @b.=sort; say @a.perl; say @b.perl; # diakopter 

[17:16] <p6eval> rakudo 8dc189: [[[1], [2, [3, 4, 5]], [4]]]␤[1, 2, 3, 4, 4, 5]␤

[17:16] <diakopter> sjohnson: your example was:

[17:16] <sjohnson> rakudo:  my @a = [[1], [2,[3,4,5]], [4]]; my @b; multi flatten(@d, @c) { for @c { flatten(@d, $_) } }; multi flatten(@d, $c) { @d.push($c) }; flatten(@b, @a); @b.=uniq; say @a.perl; say @b.perl; # diakopter 

[17:16] <p6eval> rakudo 8dc189: [[[1], [2, [3, 4, 5]], [4]]]␤[1, 2, 3, 4, 5]␤

[17:16] <sjohnson> （　｀ー´）

[17:18] <diakopter> rakudo:  my @a = <<1> <2 3> <4>>; say @a.perl; # sjohnson: your example

[17:18] <^aristotle> diakopter: euhm

[17:18] <p6eval> rakudo 8dc189: ["1>", "<2", "3>", "<4"]␤

[17:18] <^aristotle> I don't want to flatten recursively

[17:18] <^aristotle> just append a bunch of arrays together

[17:19] <diakopter> oh :)

[17:19] <^aristotle> basically what is the equivalent to p5   @a = map { @$_ } @b

[17:19] <sjohnson> diakopter: is [] array ref context in p6?

[17:20] <diakopter> [] makes an array

[17:20] <^aristotle> anyway, I'm giving up on the whole thing for now and writing what it should look like in a full p6... rather than how it can be done in rakudo:

[17:20] <^aristotle> http://blogs.perl.org/users/ovid/2009/12/improve-my-perl-6.html#comment-197

[17:21] <^aristotle> in the rakudo of today, this is

[17:21] <^aristotle> I found that destructuring one array in a signature is supported in rakudo

[17:21] <^aristotle> but destructuring two does not work

[17:22] <sjohnson> diakopter: i thought <> makes an array as well, but using the qw() p5 type notation

[17:22] <^aristotle> ie   for @aoa, @aoa -> $pair, [ $k, $v ] { ... }   will work

[17:22] <^aristotle> and   for @aoa, @aoa -> [ $k, $v ], $pair { ... }   will also work

[17:23] <^aristotle> but   for @aoa, @aoa -> [ $k1, $v1 ], [ $k2, $v2 ] { ... }   won't work

[17:24] <^aristotle> and destructuring pairs appears not implemented (and possibly not specced, I didn't read enough of the specs)

[17:25] <diakopter> sjohnson: an array of strings, yeah

[17:26] <diakopter> ^aristotle: what about   for @aoa, @aoa -> [ [ $k1, $v1 ], [ $k2, $v2 ] ] { ... }

[17:26] <sjohnson> oh

[17:26] <sjohnson> i doth seen what i done did wrong

[17:26] <sjohnson> thanks diakopter++

[17:26] <sjohnson> i guess you can't nest that shizzle

[17:27] <sjohnson> is that TimToady-approved behaviour?

[17:27] <diakopter> ^aristotle: (did you try it with adding brackets around the others?)

[17:28] <^aristotle> diakopter: Symbol '$k1' not predeclared in <anonymous>

[17:29] <^aristotle> I get that for any remotely tricky signature

[17:29] *** kidd joined
[17:29] <diakopter> ^aristotle: oh

[17:31] <^aristotle> rakudo: for %h.pairs X %h.pairs -> ($k1,$v1),($k2,$v2) { $k1.say }

[17:31] <p6eval> rakudo 8dc189: Symbol '%h' not predeclared in <anonymous> (/tmp/ZUNnbSHbd7:2)␤in Main (file <unknown>, line <unknown>)␤

[17:31] <^aristotle> doh

[17:31] <^aristotle> rakudo: my %h = a => 1, b => 2; for %h.pairs X %h.pairs -> ($k1,$v1),($k2,$v2) { $k1.say }

[17:31] <p6eval> rakudo 8dc189: Symbol '$k1' not predeclared in <anonymous> (/tmp/Ux5J3eaevk:2)␤in Main (file <unknown>, line <unknown>)␤

[17:32] <^aristotle> rakudo: my %h = a => 1, b => 2; my ($k1, $k2, $v1, $v2); for %h.pairs X %h.pairs -> ($k1,$v1),($k2,$v2) { $k1.say }

[17:32] <p6eval> rakudo 8dc189:  ( no output )

[17:32] <^aristotle> well *I* get    Not enough positional parameters passed; got 0 but expected 4

[17:33] *** FalseVinylShrub left
[17:33] <^aristotle> anyway

[17:33] <^aristotle> I've already spent 2 hours fiddling with this...

[17:34] <diakopter> ^aristotle: :)

[17:35] *** arthur-_ left
[17:37] <masak> ^aristotle: you might want to make a subroutine to abstract away the $hash{$key1} //= {} everywhere. that might make things a little bit nicer until Rakudo does autovivification and indexing of undefs right.

[17:39] <masak> another thing that Rakudo doesn't do yet with hashes is index on non-strings.

[17:39] <masak> my current workaround for that (if I want to hash on object identity and not just equivalence) is to hash on $obj.WHICH

[17:40] <masak> because .WHICH is essentially a memory address, and that's unique per-object.

[17:44] <diakopter> I can't get hashes to work at all in p6eval

[17:44] <diakopter> ah well; gtg; bbl&

[17:48] <masak> rakudo: my %h; %h<foo> = 'bar'; say %h.perl

[17:48] <p6eval> rakudo 8dc189: {"foo" => "bar"}␤

[17:49] <masak> I can get them to work.

[17:51] *** slavik left
[17:53] *** slavik joined
[17:58] *** nihiliad left
[18:00] <^aristotle> masak: $obj.WHICH won't help if it'll treat different pairs containing identical keys and values as distinct

[18:03] <cognominal> how, in a derived grammar, operators can be redefined with a different precedence?

[18:03] <^aristotle> the point is that in a hash keying on pairs, I would expect at least,  ++$h{ $k1 => $k2 }  would increment the same value each time $k1 and $k2 have values they had a previous time

[18:05] <^aristotle> even though  ($k1 => $k2).WHICH  differs each time

[18:06] *** slavik left
[18:06] *** Guest21602 left
[18:17] <sjohnson> i <3 perl

[18:21] *** ejs left
[18:28] <masak> ^aristotle: what you might want to try is creating your own class, with an overloaded postcircumfix:<{ }> operator.

[18:29] <masak> ^aristotle: however, I must warn that -- even though the overloading itself works splendidly -- there are about four known bugs related to overloading of that operator.

[18:30] <masak> let's see if I can recite them by heart: (1) blocks get misparsed sometimes, need silly line-ending semicolons. (2) you can't use .{} within the definition of postcircumfix:<{ }>, even when recursion isn't the problem.

[18:31] <^aristotle> masak: that won't make my code shorter

[18:31] *** colomon joined
[18:31] <masak> (3) due to (2), you have to store the hash in a separate class. (4) some variables get reported as being declared doubly.

[18:32] <masak> ^aristotle: oh, ok. it sounded to me like it might help immensely to make your own hash access in this case.

[18:32] <masak> but you know your problem domain better than I do.

[18:32] <^aristotle> masak: did you see the link?

[18:33] <masak> no, I must have missed that.

[18:33] <masak> I have less focus on IRC than usual.

[18:33] <^aristotle> http://blogs.perl.org/users/ovid/2009/12/improve-my-perl-6.html#comment-197

[18:33] <masak> thanks.

[18:34] <^aristotle> I suppose I could just fall back to a HoH

[18:35] <masak> ^aristotle: or you find a function that returns the same value for equivalent pairs.

[18:35] <^aristotle> it would be nice though if it's not already specced that way that pairs automatically hash based on the pair of values they represent such that that code would do what a reader would expect

[18:36] <masak> ^aristotle: something like $key.WHICH +^ $value.WHICH, but perhaps there's something even better out there, something which guarantees that there won't be any collisions.

[18:36] <masak> &

[18:36] <^aristotle> hrm

[18:37] <^aristotle> I suppose if it's a hash indexing on Any it should use $pair.WHICH

[18:38] <^aristotle> but a hash indexing on Pair would use the value of the pair

[18:38] <^aristotle> I mean

[18:39] <^aristotle> it would equally work if I could just say (and I think this is actually specced?)  $hash{Str;Str}

[18:39] <^aristotle> the way I think it's specced for multidimensional arrays

[18:43] *** snearch joined
[18:53] <pmurias> how can i create a new repo at github?

[18:54] *** zloyrusskiy joined
[18:54] *** zloyrusskiy left
[18:55] <pmurias> found out using google

[18:59] <pmurias> diakopter: http://github.com/pmurias/javascript-v8 # i started rewriting V8.pm

[19:00] *** ejs joined
[19:03] *** ejs left
[19:10] *** abra left
[19:10] <diakopter> pmurias: cool :)

[19:13] *** tempire joined
[19:15] <s1n> masak: didn't you work on Druid? is that still active?

[19:27] *** payload joined
[19:32] <mberends> diakopter++: a Debian package of mono 2.6.1 will be very useful to many people. Could it be published by a willing Debian developer?

[19:32] <diakopter> no; there's a whole debian mono group

[19:32] <diakopter> they're way behind, tho

[19:33] <diakopter> hm, maybe not... there's mono 2.4.3 for lenny in backports

[19:34] <diakopter> their webpage is out of date, then (debian mono's)

[19:48] *** slavik joined
[19:50] <masak> s1n: in some sense, Druid is feature-complete. it has a complete CLI interface, and implements all the rules. I've been starting in on computer play, SVG rendering, and a Web.pm client. none of them are anywhere near completion.

[19:50] <rjbs> Druid?

[19:50] <hejki> http://github.com/masak/druid/

[19:52] <rjbs> Cool.

[19:52] <masak> rjbs: what hejki++ said. in November 2008 I (re-)discovered this game, and realized that I simply had to do a Perl 6 implementation.

[19:52] <rjbs> Was it fun?

[19:52] <rjbs> (to implement)

[19:52] <masak> oh yes.

[19:53] <rjbs> awesome

[19:53] <hejki> i bet :)

[19:53] <masak> and some lessons from that, I still haven't blogged about.

[19:53] <hejki> at least based on my skimmings on the strat guide

[19:53] <masak> I really should.

[19:53] <rjbs> Is really basic stdio working on Rakudo?

[19:53] <masak> yes,

[19:53] <rjbs> Could I write an inetd-based service with it?

[19:53] <rjbs> Excellent.

[19:53] <masak> hm. dunno what exactly that takes.

[19:53] <masak> but probably.

[19:53] <rjbs> stdio :)

[19:53] <masak> we have sockets.

[19:53] <rjbs> Oh really?

[19:53] <rjbs> I was unaware of that.

[19:54] <masak> ya really.

[19:55] <Tene> no select(), though.

[19:56] <hejki> oh and about Druid..

[19:56] <hejki> masak++

[19:56] <hejki> :)

[19:56] <rjbs> select() does too much for me to understand how I would be affected by lacking it.

[19:56] <rjbs> I guess it would affect my ability to poll properly.

[19:57] <rjbs> I hate select.

[19:58] *** cls_bsd left
[20:17] *** frew_ joined
[20:17] *** frew_ left
[20:24] *** Chillance joined
[20:26] *** Calimbeul joined
[20:27] <mberends> pmurias: thanks for the smop setup URL, I shall use it to try to document a full mildew build procedure on a standard Ubuntu 9.10 system

[20:30] <hejki> is there any CGI-implementation done?

[20:31] <Tene> There's been SDL bindings, but I don't think they work ATM.

[20:32] <hejki> also is there something equiv to {open,read,close}dir()? 

[20:32] <mberends> hejki: yes, there is a subset in http://github.com/viklund/november (in lib/November dir)

[20:33] <hejki> mberends: oh nice.. ty :)

[20:33] <mberends> hejki: not yet, for dir we have to workaround with qqx{ ls -l }

[20:33] <hejki> :<

[20:34] <s1n> masak: i'm mostly interested in the guts, board display, general player handling, but i want to make something new from it

[20:36] *** ejs joined
[20:44] <mberends> hejki: there is an example of dir scanning in line 91 of http://github.com/masak/proto/blob/installed-modules/lib/Ecosystem.pm

[20:47] *** Beetny joined
[20:49] *** colomon left
[20:52] *** colomon joined
[20:55] <mberends> another example in line 61 of http://gitorious.org/http-daemon/mainline/blobs/master/bin/httpd

[20:56] *** colomon left
[21:02] <pmurias> mberends: if you encounter any problems mention them and i'll try to help

[21:03] <mberends> :-) thanks, I'll try most of it tomorrow (between long distractions)

[21:13] <sjohnson> rakudo:  my @a = [[1 2] [3] [4]]; my @b; for (@a) { @b.push(@_.values); }; say @b.perl;

[21:13] <p6eval> rakudo 8dc189: Confused at line 2, near "2] [3] [4]"␤in Main (file <unknown>, line <unknown>)␤

[21:13] *** ejs left
[21:13] <pmurias> mberends: in JavaScript::V8 where should the info on how to install libv8 be?

[21:14] <pmurias> README or POD?

[21:14] <sjohnson> pugs:  my @a = [[1 2] [3] [4]]; my @b; for (@a) { @b.push(@_.values); }; say @b.perl;

[21:14] <p6eval> pugs: *** ␤    Unexpected "@a"␤    expecting "=", context, ":" or "("␤    at /tmp/Kn84fF6be6 line 1, column 4␤

[21:15] <mberends> pmurias: thinking... I'll get an idea from the old Sprixel setup

[21:15] <sjohnson> std:  my @a = [[1 2] [3] [4]]; my @b; for (@a) { @b.push(@_.values); }; say @b.perl;

[21:15] <p6eval> std 29394: ===SORRY!===␤Two terms in a row at /tmp/OIaIWMljJg line 1:␤------> my @a = [[1 ⏏2] [3] [4]]; my @b; for (@a) { @b.push(@␤    expecting any of:␤ infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤FAILED

[21:15] <p6eval> ..00:01 108m␤

[21:17] <diakopter> pmurias: I suggest README

[21:17] <diakopter> or INSTALL

[21:19] *** ^aristotle left
[21:20] <mberends> stick to README unless is becomes unmanageably big.  Extra files == directory pollution

[21:20] <mberends> *it

[21:23] <pmurias> does anyone read the README of CPAN modules?

[21:23] <arnsholt> Occasionally

[21:23] <Patterner> Sometimes

[21:24] <arnsholt> But mostly I just use CPAN.pm

[21:24] <mberends> pmurias: sure, and github treats README specially too

[21:24] *** patspam1 joined
[21:27] *** yath left
[21:29] *** ejs joined
[21:30] *** iblechbot joined
[21:30] <sjohnson> pmurias: not me

[21:30] <sjohnson> sjohnson@web1:/usr/local/lib/site_perl/Sjohnson$ cpan Thing::ToInstall

[21:30] <sjohnson> well, i use sudo

[21:32] <pmurias> sjohnson: i use the same invocation, that's why i doubt the usefullness of README

[21:34] *** szabgabx left
[21:35] <sjohnson> i learned that trick from Alias of Strawberry Perl fame

[21:36] *** payload left
[21:39] *** perigrin_ joined
[21:39] <pmurias> sjohnson: you mean the one of PPI fame? ;)

[21:40] *** perigrin_ is now known as perigrin

[21:41] *** patspam2 left
[21:46] <sjohnson> hmm, what is PPI?

[21:47] <sjohnson> ahh i am googling

[21:48] <sjohnson> Alias wrote this whole thing?

[21:48] *** patspam joined
[21:49] <pmurias> sjohnson: he might have had some help but he is the main author

[21:49] <sjohnson> interesting

[21:49] <eternaleye> phenny: tell ^aristotle one way to do the destructuring bind might be like this: for (%a.pairs X %b.pairs)>>.kv -> $akey, $aval, $bkey, $bval { ... }

[21:49] <phenny> eternaleye: I'll pass that on when ^aristotle is around.

[21:51] *** kidd left
[22:01] *** iblechbot left
[22:05] *** patspam1 left
[22:07] *** patspam left
[22:08] *** colomon joined
[22:10] *** colomon left
[22:37] *** mberends left
[22:41] *** patspam joined
[22:45] *** snearch left
[22:55] *** patspam1 joined
[22:56] <pugs_svn> r29395 | pmurias++ | [mildew-js] use JavaScript::V8 instead of V8 

[22:58] *** meppl left
[22:59] <pmurias> diakopter: mildew switched from V8 to JavaScript::V8 :)

[23:01] *** jferrero joined
[23:10] *** Su-Shee left
[23:11] *** vamped joined
[23:11] *** patspam left
[23:12] <vamped> hey, can anyone explain the subtle difference between @a=1,2,3 and $a=1,2,3 ? (or tell me where to look)

[23:12] <arnsholt> IIRC, my @foo is the same as my Type $foo

[23:12] <arnsholt> Where Type is Positional I think

[23:13] <huf> @ is an interpolating array

[23:13] <huf> the $ one's not

[23:13] <huf> for @a { } and for $a.list { } 

[23:14] <vamped> ok. so why would one want to do $a=1,2,3 ? or is $a a reference to an array?

[23:14] <huf> no, if i understand right, it's just a plain old array

[23:14] <huf> you can write it as you want 

[23:15] <vamped> hmm. lol. i thought perl 6 was supposed to be less confusing (oops - not trying to throw flaim bait). I suppose sooner or later it will click in my hed.

[23:15] <vamped> s/hed/head/

[23:15] <huf> i think the value is an array, and you bind it to a variable

[23:15] <huf> and if you bind it to a @variable, it interpolates in lists

[23:15] <huf> if you bind it to a $var, it dont

[23:15] <pmurias> vamped: S02:1608

[23:15] <huf> but i'm not sure that's correct. anyone?

[23:16] <pmurias> rakudo: my @foo=1,2,3;my @bar = 1,2,@foo;say @bar.perl

[23:16] <p6eval> rakudo 8dc189: [1, 2, 1, 2, 3]␤

[23:17] <pmurias> pug: my @foo=1,2,3;my @bar = 1,2,@foo;say @bar.perl

[23:17] <pmurias> pugs: my @foo=1,2,3;my @bar = 1,2,@foo;say @bar.perl

[23:17] <p6eval> pugs: [1, 2, 1, 2, 3]␤

[23:17] *** colomon joined
[23:18] <vamped> pmurias: is that line 1608?

[23:19] <pmurias> yes

[23:20] *** kaare joined
[23:20] <pmurias> rakudo: my $foo=1,2,3;my @bar = 1,2,$foo;say @bar.perl

[23:20] <p6eval> rakudo 8dc189: [1, 2, [1, 2, 3]]␤

[23:20] *** kaare is now known as Guest53549

[23:20] <vamped> pmurias:  ooh!

[23:22] *** ejs left
[23:23] *** colomon left
[23:26] *** colomon joined
[23:27] <vamped> rakudo: my $y = "bar baz"; «foo $y».perl.say;

[23:27] <p6eval> rakudo 8dc189: ["foo", "bar baz"]␤

[23:29] <pmurias> vamped: if you prefer to read the html version of the spec, irc.pugscode.org has turns S\d+:\d+ into links

[23:29] *** Chillance left
[23:30] <vamped> I've just always used http://feather.perl6.nl/syn/

[23:31] <vamped> still, i'm trying to figure out how to arrive at the same line number. i can use perldoc S02...pod

[23:33] <vamped> perldoc and typing 1608 doesn't seem to bring me to anyplace relevant

[23:33] <arnsholt> I always assumed the line numbers referred to the line count in the POD file?

[23:36] <eternaleye> arnsholt: They do

[23:37] *** nihiliad joined
[23:38] <eternaleye> vamped: http://perlcabal.org/syn/S02.html#line_1608

[23:38] <eternaleye> 'Sigils indicate overall interface'...

[23:39] <vamped> eternaleye: ok, so *that's* how it's done. thanks. I'll read it.

[23:40] <vamped> looks like what I wanted. thanks all.

[23:46] *** Guest53549 left
[23:56] *** pmurias left
[23:58] *** colomon left
[23:59] *** cdarroch left
[23:59] *** ihrd1 joined
