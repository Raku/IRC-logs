[00:00] *** nihiliad left
[00:13] *** payload joined
[00:23] <diakopter> std: say((3 and 4)) # TimToady

[00:23] <p6eval> std 28969: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[00:23] <diakopter> std: say(3 and 4)

[00:23] <p6eval> std 28969: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse argument list; couldn't find final ')' at /tmp/aniI3Vi6c4 line 1:‚ê§------> [32msay(3 [33m‚èè[31mand 4)[0m‚ê§    expecting an infix operator with precedence tighter than list infix‚ê§FAILED 00:01 104m‚ê§¬ª

[00:30] <diakopter> std: say (3 and 4)

[00:30] <p6eval> std 28969: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[00:31] <jnthn> pmichaud: btw, I won't be doing much more today. prob will do some more bits tomorrow...and count today + tomorro's bits as a Rakudo day.

[00:31] <jnthn> Thus will do an ng status blog post tomorrow.

[00:33] <jnthn> Let me know if there's anyting particular you want me to look at tomorrow (whenver you think of it...I'll backlog)

[00:36] <diakopter> jnthn: g'nite

[00:37] <jnthn> diakopter: not gone quite yet, just not got the brain cycles available to write code any more today either. ;-)

[00:37] <s1n> hehe

[00:37] <s1n> http://s1n.dyndns.org/index.php/2009/10/31/pump-king/

[00:37] *** orafu left
[00:37] *** OuLouFu joined
[00:37] *** OuLouFu is now known as orafu

[00:38] <jnthn> cooool!

[00:38] <jnthn> s1n++

[00:38] <s1n> :)

[00:38] <diakopter> flame on flame

[00:39] <s1n> that middle part removes, but it doesn't look true to the logo without it (and the narrow line is too narrow)

[00:45] *** lichtkind left
[00:48] *** alester left
[00:49] *** brunov joined
[00:50] <diakopter> the first terminal in STD.pm is token endid.  I suppose I'll start there. :)

[00:51] <diakopter> oh.  a lookahead.  har.

[00:54] * diakopter makes the commitment to track STD.pm's grammar changes from r28967... and proceed with a hand-translation to jsmeta... while also wedging/refactoring jsmeta's parsers into sprixel's runloop, since it's much better than jsmeta's

[00:55] <diakopter> (the alternative was an automatic translation from the AST produced by viv from STD.pm... but the AST is just too large :)

[00:55] <diakopter> (and there are too many spots that would have needed hand-translating anyway..)

[00:55] <diakopter> here goes nothing

[00:57] <diakopter> for those curious, jsmeta is roughly analogous to pge, and sprixel-rx is roughly analogous to nqp-rx...

[01:03] *** iGhost left
[01:10] *** NorwayGeek joined
[01:24] <diakopter> std: /''/ # null pattern?

[01:24] <p6eval> std 28969: OUTPUT¬´ok 00:01 103m‚ê§¬ª

[01:25] <jnthn> diakopter: well, maybe ;-)

[01:28] <diakopter> rakudo: say ('a' ~~ /^^''$$/ and True); say ('' ~~ /^^''$$/ and True)

[01:28] <p6eval> rakudo d154eb: OUTPUT¬´‚ê§1‚ê§¬ª

[01:29] <jnthn> heh

[01:29] <jnthn> Well, I don't really think we want to get in to exploring all of the possible patterns you could write that match an empty string. :-)

[01:30] <jnthn> I think the point was that // was not an OK regex. :-)

[01:30] <jnthn> std: "foo" ~~ //

[01:30] <p6eval> std 28969: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null regex not allowed at /tmp/ud8pAa2f5y line 1:‚ê§------> [32m"foo" ~~ //[33m‚èè[31m<EOL>[0m‚ê§FAILED 00:02 104m‚ê§¬ª

[01:30] * diakopter sets a new personal best for extent of S05 hand-waved/read in 1 sitting... (about 1/4) :D

[01:31] <jnthn> The NEW endurance sport!

[01:45] <jnthn> nqp: my $x := pir::box__PS('5 birds'); pir::say(pir::set__NP($x))

[01:45] <p6eval> nqp: OUTPUT¬´0‚ê§¬ª

[01:47] <pmichaud> nqp:  my $x := pir::box__Ps('5 birds');  pir::say(pir::set__NP($x))

[01:47] <p6eval> nqp: OUTPUT¬´0‚ê§¬ª

[01:47] <diakopter> what's set__NP

[01:48] <pmichaud> it's the  set $Nx, $Px   opcode

[01:48] <jnthn> diakopter: set opcode, specifying arg types.

[01:48] <jnthn> pmichaud: btw, I like that syntax. :-)

[01:48] <pmichaud> jnthn: thanks.  It's just the signature syntax from PAST, replacing the space with a double-underscore.

[01:48] <pmichaud> although I wonder if I should come up with identifier-versions of the *, :, +, and ~ keys

[01:49] <jnthn> pmichaud: Oh, I figured it was easy to add based on what PAST already gave. But X being not so hard doesn't mean X isn't something that you'd think of doing. :-)

[01:50] <pmichaud> well, while writing NQP there were several times where I thought "I just need one opcode, why do I have to write all of this other stuff around it?"

[01:50] <Juerd> diakopter: Oh, just read the first version. Much easier ;)

[01:50] *** IllvilJa joined
[01:50] <pmichaud> so I decided that had to be fixed

[01:50] <jnthn> Yeah

[01:50] <jnthn> I've used it multiple times alreayd.

[01:50] <jnthn> *already

[01:51] <Juerd> diakopter: Though keeping track of the changes became way too much for me

[01:51] <pmichaud> it also means there's at least a chance that someone could write a pir:: emulation library for non-parrot platforms :-)

[01:51] <pmichaud> which will be far simpler than parsing the internals of Q:PIR { ... }   :-)

[01:51] <jnthn> Well, we'll deal with such things when we or someone else gets to doing a port to another platform.

[01:52] <jnthn> Well, backend for, not port to.

[01:52] <jnthn> I hope.

[01:52] <jnthn> That is, I'd hope we'll be able to keep multiple backends as build options in one code base, rather than having forks. But that'll take effort.

[01:52] <pmichaud> bbiab

[01:52] <jnthn> bbitm ;-)

[01:53] <jnthn> o/

[01:54] *** nihiliad joined
[01:54] <diakopter> bye

[01:54] <diakopter> Juerd: oh :)

[01:55] <diakopter> luckily for me, Microsoft's MGrammar grammar-language (which jsmeta implements) is remarkably similar in overall expressiveness to Perl 6 regexes

[01:58] <diakopter> and lexical scoping of names

[01:59] *** nihiliad1 joined
[02:00] *** nihiliad left
[02:04] <pugs_svn> r28970 | kyle++ | [Test::Util] a little refactor 

[02:25] *** TiMBuS joined
[02:47] *** xabbu42 left
[02:52] <carlin> Argh, trying to parse RSS is turning out to be a real pain

[02:58] <pmichaud> ...implemented assignops, using infix_postfix_meta_operator instead of pre-generating them all at startup.  :-)

[03:13] *** Psyche^ joined
[03:24] *** Patterner left
[03:24] *** Psyche^ is now known as Patterner

[03:32] *** jaldhar joined
[03:55] *** fax joined
[04:26] *** tak11 joined
[04:40] *** brunov left
[04:47] *** nihiliad1 left
[04:51] *** mepplock joined
[04:54] <carlin> \o/ I can successfully parse use.perl RSS feeds

[04:54] *** envi^home joined
[04:55] <carlin> ... and wordpress feeds :D

[04:56] <carlin> and moritz's feed worked too. Fantastic.

[04:58] *** meppl left
[04:58] *** mepplock is now known as meppl

[05:12] *** fax left
[05:35] *** tak_ joined
[05:42] *** tak11 left
[06:13] *** eternaleye left
[06:19] *** envi^home left
[06:21] *** justatheory left
[06:51] *** Chillance left
[07:03] *** nbrown joined
[07:07] *** eternaleye joined
[07:29] *** PZt joined
[07:48] *** quuxx left
[07:48] *** quuxx joined
[08:14] *** iblechbot joined
[08:26] *** bpetering joined
[08:29] *** silug joined
[08:34] *** tak11 joined
[08:34] *** wolverian joined
[08:34] *** tak_ left
[08:35] *** carlin_ joined
[08:35] *** carlin_ left
[08:36] *** mberends left
[08:46] *** mberends joined
[08:55] *** silug left
[09:03] *** tak11 left
[09:05] *** Su-Shee joined
[09:05] <Su-Shee> good morning.

[09:05] <carlin> o/

[09:08] *** quuxx left
[09:09] <carlin> Argh

[09:09] *** quuxx joined
[09:09] <carlin> quuxx: stop segfaulting please :-)

[09:09] *** rfordinal joined
[09:13] <sjohnson> hi

[09:15] *** am0c joined
[09:45] *** meppl left
[10:01] *** kidd joined
[10:02] *** carlin sets mode: +v quuxx

[10:08] *** iblechbot left
[10:28] *** am0c left
[10:29] *** TopoMorto joined
[10:36] *** TopoMorto left
[10:43] <jnthn> o/

[10:43] <carlin> \o

[10:53] *** TiMBuS left
[11:05] *** pmurias joined
[11:07] <pmurias> diakopter: backlogging, i'm not sure if i understand your plan to hand translate STD into jsmeta?

[11:37] *** ejs left
[11:55] *** ejs joined
[12:01] *** Schwern left
[12:02] *** mjk joined
[12:13] *** rfordinal left
[12:13] *** mjk left
[12:19] *** redicaps joined
[12:20] *** envi^home joined
[12:22] *** redicaps left
[12:56] *** pnate2 joined
[12:57] *** pnate left
[13:00] *** fax joined
[13:05] *** desertm4x joined
[13:06] *** Whiteknight joined
[13:14] <quuxx> masak++ blogged "Here we go again; another full month of November": http://use.perl.org/~masak/journal/39825?from=rss

[13:15] *** masak joined
[13:16] <masak> greetings, #perl6-lings.

[13:20] <carlin> o/

[13:20] <masak> quiet Sunday in here today.

[13:21] <colomon> It's been ten whole hours since someone pushed to the ng branch.  :)

[13:21] <masak> oh, is that the branch I think it is?

[13:21] <masak> I still am note done backlogging...

[13:22] <colomon> yes it is.

[13:23] <colomon> amazing, amazing progress so far.

[13:23] <masak> I've been gone a day, and I find myself thinking "I've been gone too long..." :)

[13:24] <jnthn> colomon: Oh, it's just the calm before the storm. :-)

[13:24] <colomon> jnthn: I hope so!

[13:25] <jnthn> colomon: And also on my part, just needing a day doing something other than writing code. :-)

[13:25] <jnthn> Well, part of a day doing something other than... :-)

[13:25] <colomon> Watching you guys at work it yesterday was a lot more entertaining than the watching the football game... :)

[13:27] *** Patterner left
[13:28] <colomon> Hey, sweet, I wasn't aware we had working perl 6 library repositories in rakudo now.  (Following masak++'s links all around.)

[13:28] *** Psyche^ joined
[13:29] <masak> colomon: we have what? :P

[13:29] *** zaslon joined
[13:29] *** Psyche^ is now known as Patterner

[13:29] <carlin> Here's my progress from today

[13:29] <carlin> zaslon: ohhai

[13:29] <zaslon> Sorry, I don't understand that command

[13:29] <carlin> zaslon: link masak

[13:29] <zaslon> masak's blog is at http://use.perl.org/~masak/journal/

[13:29] <colomon> .perl6lib automatically in the library path, mostly.

[13:29] <carlin> zaslon: remove masak

[13:29] <zaslon> I am no longer following masak's blog

[13:29] <jnthn> zaslon: link jnthn

[13:29] <zaslon> jnthn's blog is at http://use.perl.org/~JonathanWorthington/journal/

[13:29] <carlin> zaslon: link masak

[13:29] <zaslon> Sorry, I don't know who masak is

[13:29] <carlin> zaslon: add masak http://use.perl.org/~masak/journal/rss

[13:30] <carlin> This takes a while

[13:30] <masak> carlin: cool. what's the bot written in?

[13:30] <zaslon> I am now following masak's blog

[13:30] <colomon> masak: you linked to the commit in the cheese speleology post you linked to today.  :)

[13:30] <carlin> zaslon: link masak

[13:30] <zaslon> masak's blog is at http://use.perl.org/~masak/journal/

[13:30] <masak> colomon: yes. what does it say we have?

[13:30] <carlin> masak: perl6 of course :-)

[13:30] <masak> carlin: really? carlin++

[13:30] * jnthn is impressed too :-)

[13:30] <jnthn> carlin++

[13:30] <masak> that is just amazingly cool.

[13:30] <jnthn> It's kinda useful *and* written in Perl 6!

[13:30] <colomon> masak: "preload $HOME/.perl6lib and languages/perl6/lib in @*INC"

[13:31] <masak> colomon: ah. yes.

[13:31] <colomon> obviously proto doesn't work yet, but I can put things there by hand.  (haven't actually tested yet...)

[13:32] <carlin> tomorrow's job is getting zaslon to poll the feeds and alert when there's an update and then quuxx can be retired

[13:33] <masak> \o/

[13:33] <masak> where does the name 'zaslon' come from?

[13:33] <carlin> masak: zaslon radar

[13:34] <masak> ah. cool.

[13:35] <colomon> (one wikipedia check later)  Flash Dance!  :)

[13:36] <colomon> carlin: I trust this means yesterdays RSS grammar writing went well?

[13:36] <carlin> heh

[13:36] <masak> another XML grammar? :P

[13:36] <carlin> The RSS part is called RSS::Hacks

[13:37] <carlin> I couldn't get any sense out of the xml grammar on proto :/

[13:38] <masak> sorry to hear that.

[13:38] <masak> it's also not very active, I fear.

[13:38] <masak> haven't seen krunen around here since NPW.

[13:39] <colomon> I was poking around in proto and some of the projects yesterday as well.  I think getting the installed modules branch working well will be a big step forward...

[13:39] <masak> nod.

[13:40] <slavik> so, when will rakudo get a smart make install?

[13:40] <colomon> slavik: for rakudo itself?

[13:40] <slavik> yes

[13:41] <masak> slavik: it could be argued that it's not Rakudo's responsibility...

[13:41] <masak> just as the python executable doesn't have a smart install, etc.

[13:41] *** jan_ left
[13:41] <colomon> my guess is pretty soon, but almost certainly not this month.

[13:41] <masak> oh, maybe I misunderstood.

[13:41] <slavik> masak: then I'd like packages. :)

[13:42] <colomon> masak: (or maybe I'm misunderstanding...)

[13:43] <masak> what would a smart 'make install' entail?

[13:44] <jnthn> What's wrong with Rakudo's current make install, btw?

[13:44] <jnthn> (I don't doubt it has issues, just curious what they are.)

[13:44] <colomon> doesn't install it in your path.

[13:45] <jnthn> Well, sure, by default.

[13:45] <jnthn> I think that's more a configuraiton issue though?

[13:45] <jnthn> Or more to the point, it'll install it where Parrot was configured to put binaries.

[13:46] <masak> my 'make install' installs a 'perl6' in my path. but I don't do --gen-parrot

[13:47] <colomon> rakudo: my $a = 2 < 3 ?? 42 !! 69; say $a;

[13:47] <p6eval> rakudo d154eb: OUTPUT¬´42‚ê§¬ª

[13:47] <jnthn> masak: Aye.

[13:47] <masak> I knew it would pay off one of these days! :P

[13:48] <jnthn> Well, --gen-parrot is great if you just want something self-enclosed to play with.

[13:48] <jnthn> If you're trying to get something installed to system paths, then it'll need a couple more flags, of preferably a ready-installed Parrot to configure against.

[13:51] <colomon> jnthn: sure, and it's certainly not bothering me now, but by Rakudo * it probably ought to default to installing in the path.

[13:51] <colomon> If you follow the default instructions for building and installing and it doesn't, people's first impression of Rakudo will be bad.

[13:53] *** envi^home left
[13:53] <jnthn> Sure - we'll have to consider what instuctions to give and what the defaults should be for that.

[13:53] <carlin> http://github.com/carlins/rssbot # pushed today's work

[13:54] *** zaslon left
[13:54] <colomon> carlin++

[13:55] <carlin> it is quite rough in places, especially around anything to do with parsing the RSS

[13:56] *** zaslon joined
[13:56] <jnthn> Heh. It's probably still better than the lolsql code. :-)

[13:56] *** desertm4x left
[13:57] *** zaslon left
[13:57] <Juerd> Was there a lolsql parser in perl6 yet?

[13:58] <carlin> Yip, jnthn++ wrote one

[13:58] <Juerd> url? :)

[13:58] <carlin> http://github.com/jnthn/lolsql

[13:58] <Juerd> Thanks

[13:59] <carlin> A proto IRC-bt might be nice; "proto: link lolsql"

[13:59] <carlin> *bot

[13:59] <masak> jnthn++

[13:59] <masak> jnthn: no tests? :)

[14:00] <Juerd> jnthn++

[14:00] *** zaslon joined
[14:01] <masak> also, it could be argued that "UR DOIN IT RONG" is a LTA error message... but you know that. :)

[14:01] <masak> I see I have a few things to add to proto's projects.list...

[14:02] *** zaslon left
[14:02] <jnthn> jnthn: :-P

[14:02] <jnthn> masak: Heh, I wrote it in just over an hour while watching other people's talks. :-)

[14:02] <colomon> Isn't  "UR DOIN IT RONG" in the lolsql spec?

[14:03] <jnthn> colomon: no, but it felt appropriate :-)

[14:03] <masak> jnthn: it's way cool.

[14:03] <jnthn> masak: Well, if you want to add good parse fail errors... It's fine if they're in lolspeak. ;-)

[14:03] <masak> jnthn: 'Be gud kitteh...' jnthn++

[14:04] <Juerd> Srsly lex and yacc are SO pwned now.  ++

[14:04] <masak> yup. that's the gist of Perl 6 grammars.

[14:06] <colomon> I really need to sit down and learn to use grammars.

[14:06] <carlin> .oO( Must get around to figuring out how to write propper grammar one day... )

[14:12] *** brunov joined
[14:15] *** rfordinal joined
[14:21] *** nihiliad joined
[14:27] *** zaslon joined
[14:27] *** zaslon left
[14:28] *** scallop joined
[14:30] *** NorwayGeek left
[14:30] *** NorwayGeek joined
[14:34] <pmichaud> good morning, #perl6

[14:35] <jnthn> afternoon, pmichaud 

[14:36] *** rfordinal left
[14:37] <pmichaud> oh, I forgot to push my commits!

[14:37] * pmichaud pushes 4 commits.

[14:38] <pmichaud> ...we can haz lazy lists.

[14:38] <jnthn> omg!

[14:38] <jnthn> pmichaud++ for 1...;

[14:39] <pmichaud> we'll also get lazy ranges and lazy IO shortly.

[14:39] <pmichaud> also, arrays are now called Array.  Not Perl6Array.  Array>

[14:40] <pmichaud> *Array.

[14:40] <jnthn> Wow. Unexpected.

[14:40] <jnthn> But very nice. :-)

[14:40] <jnthn> BTW, I note you do:

[14:40] <jnthn> $P0 = get_hll_global ['Bool'], 'True'

[14:40] <jnthn> setprop parcel, 'flatten', $P0

[14:42] <pmichaud> yes

[14:42] <jnthn> If you are just going to use a "did we get a null back" to test this, then you can just do setprop parcel, 'flatten', parcel ;-)

[14:42] *** icwiener joined
[14:42] <pmichaud> oh, true

[14:42] <jnthn> Since it doesn't matter what you stick in there.

[14:42] <pmichaud> I use that trick a few other places in the regex engine 

[14:42] <jnthn> Yeah, I've used it in Rakudo a bit before.

[14:43] <jnthn> Thing is, if we start sticking bools in places, then we not only have to do a null check, but should perhaps be checking for truth too.

[14:43] <pmichaud> question:  We currently store type constraint information in the 'type' property.  Should that be more properly named 'of' ?

[14:43] <jnthn> Good question.

[14:43] <jnthn> Well, for parametric arrays and hashes, the .of is really just coming from it being like

[14:44] <pmichaud> (bools):  well, I was using bools under the assumption that someday we might need to have the property present but still be able to indicate 'false'

[14:44] <jnthn> role Positional[::T] { method of() { T } ... }

[14:44] <jnthn> For scalars we kinda stash it away.

[14:45] <pmichaud> so, should we stash it somewhere named 'of'  ?  ;-)

[14:45] <pmichaud> instead of 'type' ?

[14:45] <jnthn> We can.

[14:45] <pmichaud> I think I would prefer that.  'type' is sometimes too overloaded a term

[14:45] <jnthn> But my point was more, the T in the role decl is more an implementation detail.

[14:45] <pmichaud> right

[14:45] <jnthn> The .of is what's exposed.

[14:45] <pmichaud> right

[14:46] <pmichaud> I think I follow the implementation, I'm just asking about where we stash it :)

[14:46] <jnthn> And $scalar.VAR.of is probably the related thingy here.

[14:46] <jnthn> Well, my point is that it kinda doesn't matter. ;-)

[14:46] <jnthn> I can go with of. It's 2 less chars to type. :-)

[14:46] <pmichaud> it does in the code when I go to ask for 'type'

[14:46] <jnthn> Well, yes, true. :-)

[14:47] <pmichaud> somehow the word "of" tells me more directly what I'm asking for (in this case, a type constraint, or the 'of' property)

[14:47] <jnthn> I menat doesn't matter in that it's guts, not user-visible.

[14:47] <pmichaud> right

[14:47] <jnthn> Anyway, let's go with "of"

[14:47] <pmichaud> I'm thinking strictly in terms of code maintenance for the compiler writers

[14:47] <jnthn> type is quite overloaded.

[14:47] <jnthn> And after all, it's exactly what gets stored for my $x of Int;

[14:47] <pmichaud> whenever there are two items that refer to the same concept, I like them to be similarly-named

[14:48] <jnthn> (which my Int $x is just sugar for)

[14:48] <masak> lazy lists! wicked! pmichaud++

[14:48] <jnthn> OK. Let's go with that. :-)

[14:49] <jnthn> BTW, put in the checking code now if you like, but I suggest not hacking in something to set the of property unless you really need it.

[14:49] <jnthn> (It needs to be done by a trait_mod:<of> dispatch)

[14:50] <jnthn> (And we can probably parse and run those soon.)

[14:50] <pmichaud> I'm only hacking in the things needed to pass tests, not features-for-features sake

[14:50] <jnthn> nod

[14:50] <pmichaud> and like the assignop code, when I can do it "the right way" I'm tending to go ahead and do that

[14:50] <pmichaud> oh, nopaste coming

[14:51] <pmichaud> http://gist.github.com/223545   # assignment metaop code generation

[14:52] <jnthn> niiice!

[14:53] <jnthn> If I do it in an eval, will it keep track of what ops we already generated and not re-do them?

[14:53] <pmichaud> yes.

[14:53] <pmichaud> well, I'll rephrase.

[14:53] <jnthn> Brilliant.

[14:54] <pmichaud> it will still generate the call to !gen_assign_metaop.  But !gen_assign_metaop will notice that the operator already exists and short-circuit.

[14:54] <jnthn> ah, ok

[14:54] <jnthn> That'll do for now.

[14:54] <jnthn> It's a huge improvemnet on generating them all.

[14:54] <pmichaud> thus if someone has a custom infix:<+=>, that gets used in preference and not overwritten

[14:54] <pmichaud> the call to !gen_assign_metaop is cheap, anyway.

[14:55] <colomon> how does that relate to overloading?

[14:55] <jnthn> nod

[14:55] <pmichaud> colomon: I haven't worked out the overloading details quite yet, but that should be simple also.

[14:55] <pmichaud> and we know where to put that code (in gen_assign_metaop)

[14:55] <colomon> I mean, if I define a custom infix:<+=> for my matrix class, I don't want it mucking up += for Int.

[14:56] <jnthn> Are folks allowed to define custom meta-op variants to make the set of meta-ops irregular?

[14:56] <pmichaud> colomon: right -- we'll want to switch it to be a multi.  There's even a "XXX" marker in the gen_assign_metaop code that says "this should be a Perl6MultiSub"

[14:56] <pmichaud> jnthn: yes, I believe so.

[14:56] <jnthn> ah, ok

[14:56] <jnthn> I think I read of some restriction at one point, but may be mis-remembering.

[14:56] <pmichaud> anyway, yesterday was nicely productive.

[14:57] <jnthn> Yes, indeed.

[14:57] <pmichaud> I'm looking at the level 1 things we're starting to knock off the roadmap :)

[14:57] <pmichaud> laziness... check.

[14:57] <pmichaud> real constants ... check

[14:57] <pmichaud> oh, and the array code also fixes the auto-vivification problem

[14:57] <jnthn> STD-like grammar ... well on the way :-)

[14:58] <pmichaud> if you say   @a[3] and @a[3] doesn't exist, it's not auto-bound into the array until you assign to it

[14:58] <jnthn> Great.

[14:58] <jnthn> That's another nasty gone.

[14:58] <pmichaud> and I think that  even   @a[3][4]  will work now, to auto-vivify @a[3] into an array

[14:58] * pmichaud tests

[14:59] <pmichaud> oh, not yet

[14:59] <pmichaud> need to handle undefs still

[14:59] <pmichaud> which brings up a question... is Failure a class, or is it a Role punned into a class ?

[15:00] <jnthn> This is especially nice because generating hundreds (thousands?) of unused meta-op variants that we never used and making calls to !TOPERL6MULTISUB were two of our biggest startup costs, and we are eliminating both.

[15:00] <pmichaud> more generally, what exactly do I get with undef()  ?

[15:00] <jnthn> I've heard it talked about muchly as a Role.

[15:00] *** pointme joined
[15:00] <jnthn> That can be mixed in to things.

[15:00] *** clkao joined
[15:00] <jnthn> undef is probably giving you the pun.

[15:00] <pmichaud> I'm fine with that... what does undef() return then?

[15:01] <pmichaud> it's just a generic Failure object?

[15:01] <pmichaud> hmmmm

[15:01] <carlin> pointme: lolsql

[15:01] <pointme> jnthn's lolsql is at http://github.com/jnthn/lolsql/

[15:01] <carlin> pointme: http-daemon

[15:01] <pointme> mberends's http-daemon is at http://gitorious.org/http-daemon/

[15:01] *** envi^home joined
[15:01] <jnthn> pontme: complete-perl-6-implementation

[15:01] <jnthn> pointme: complete-perl-6-implementation

[15:01] <pointme> Sorry, I don't know anything about that project

[15:01] <jnthn> aww!

[15:02] *** NorwayGeek left
[15:02] <masak> someone should start such a project. :P

[15:02] <pmichaud> not me!  waaaaay too difficult!

[15:02] <jnthn> Yeah!

[15:02] <carlin> pointme: all

[15:02] <pointme> Sorry, I don't know what just happened

[15:02] <jnthn> Me either!

[15:02] <jnthn> pointme++ # error WIN

[15:03] <jnthn> pmichaud: What's bothering you about the generic Failure object?

[15:03] <pmichaud> just putting together a plan for it

[15:03] <jnthn> OK.

[15:03] <pmichaud> how do I create a role in PIR ?

[15:03] <pmichaud> and how much of roles are in place in ng ?

[15:03] <pmichaud> (or, more precisely, "what are we missing?"

[15:03] <jnthn> pmichaud: Approx nothing of roles has gone back in yet.

[15:04] <jnthn> pmichaud: Apart from one dynpmc.

[15:04] <pmichaud> okay

[15:04] <jnthn> pmichaud: Creating a role from PIR is simple though, in that there's a helper for it.

[15:04] *** pointme left
[15:04] <jnthn> !create_simple_role('Failure') or so.

[15:04] <carlin> tomorrow's job is making the bot(s) respond to pings so they don't timeout

[15:04] <carlin> 'night all

[15:04] <jnthn> carlin++ # night!

[15:04] <pmichaud> carlin++ # excellent work

[15:04] <pmichaud> carlin++  # please blog it!

[15:05] <jnthn> yes!

[15:05] <carlin> oh good idea

[15:05] <carlin> Tomorrow :-)

[15:06] <jnthn> pmichaud: Again, some of it is in guts.pir.

[15:06] <jnthn> pmichaud: They probably want to be extracted.

[15:07] <pmichaud> jnthn:  that's what I was thinking :-)

[15:07] * jnthn hopes guts.pir can just die

[15:07] <jnthn> Because we already ripped out the things in it.

[15:07] <pmichaud> I've been reluctant to pull in guts.pir all-at-once

[15:07] <jnthn> Don't.

[15:07] <jnthn> We'll take bits from it as we need it.

[15:07] <pmichaud> I'm not in a rush for it

[15:07] <pmichaud> (well, not too much of a rush)

[15:07] <jnthn> And if we end up passing the spec tests with some stuff still left in there, well, we found dead code. ;-)

[15:08] <pmichaud> today I'll work on getting the other primitive types in place

[15:08] <jnthn> OK, sounds like a plan.

[15:08] *** NorwayGeek joined
[15:08] <pmichaud> I think it's very likely we'll have Test.pm by tonight

[15:08] <jnthn> What do we need beyond those to get us running the sanity tests?

[15:08] <pmichaud> not sure... looking

[15:08] <jnthn> OK. I can hack a bit on ng today too.

[15:10] <pmichaud> 'try' looks like it might be the most challenging item left.

[15:10] <pmichaud> everything else looks.... trivial

[15:10] <pmichaud> (well, relatively trivial)

[15:10] * masak likes to try to say 'ng'

[15:11] *** NorwayGeek left
[15:12] <pmichaud> I'm also reorganizing the sanity tests a bit, and eliminating things that aren't really needed for Test.pm

[15:12] *** NorwayGeek joined
[15:13] *** lidden joined
[15:13] <jnthn> masak: Unfortunately, there's not a chemical element Ng, which you coulda used instead. :-)

[15:13] <pmichaud> I did think of that possibility...

[15:13] <masak> jnthn: ≈ã

[15:13] <pmichaud> I just knew that "usenqprx" was going to get tedious for me to type for a while

[15:14] <masak> 'ng' is very cute as a name.

[15:14] <jnthn> There is a Pm in the periodic table though. ;-)

[15:14] <pmichaud> anyway, I'm hoping that within a week or so 'ng' will be better known as 'master'

[15:14] <pmichaud> jnthn: yes, one of my favorite elements.

[15:15] <colomon> a week!?!!!!!

[15:15] <jnthn> luminesent in the dark, according to Wikipedia. ;-)

[15:16] <pmichaud> named after Prometheus, the bringer of fire and knowledge to mankind

[15:16] <pmichaud> I like the parallels.  :)

[15:16] <jnthn> Fitting. :-)

[15:16] <pmichaud> heh

[15:16] <masak> ÂìàÂìà

[15:17] <pmichaud> very interesting parallels when one compares the myth to Perl 6

[15:17] <masak> "It was foretold in the table of the Elements..."

[15:17] <pmichaud> so, I'm responsible for bringing fire and knowledges from the gods  (TimToady++) to everyone else, and for my impertinence I get to spend every day chained to a rock and be tormented

[15:18] <pmichaud> (since Perl 6 exists to torment the implementors)

[15:18] <masak> there certainly are parallels.

[15:18] <pmichaud> s/6//

[15:21] <masak> also, Perl 6 rocks.

[15:26] *** simcop2387 joined
[15:30] *** rfordinal joined
[15:31] *** pmurias left
[15:31] *** Psyche^ joined
[15:32] <dalek> nqp-rx: 7df80c2 | pmichaud++ | README:

[15:32] <dalek> nqp-rx: README update with note that double-quoted strings now interpolate $-vars.

[15:32] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/7df80c2a61ba34166ba48044cc341cc817264f7d

[15:32] <dalek> nqp-rx: 2a9430b | pmichaud++ | src/HLL/Actions.pm:

[15:32] <dalek> nqp-rx: EXPR should prefer $/.ast to $<OPER>.ast when building node.

[15:32] <dalek> nqp-rx: Fix .panic message to occur on cursor object instead of Match.

[15:32] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/2a9430b2e463bc07b4a10983053e3aa86ef0f319

[15:33] *** Patterner left
[15:33] *** Psyche^ is now known as Patterner

[15:34] *** tak11 joined
[15:36] *** icwiener left
[15:42] *** justatheory joined
[15:43] <dalek> nqp-rx: fd51bde | pmichaud++ | src/cheats/hll-grammar.pir:

[15:43] <dalek> nqp-rx: Eliminate bogus debugging 'say' in cheats/hll-grammar.pir .

[15:43] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/fd51bde0a2f0b7db169697df7482e8e5deebfaa8

[15:43] <dalek> nqp-rx: 1ee030e | pmichaud++ | src/stage0/ (3 files):

[15:43] <dalek> nqp-rx: Update stage-0 files.

[15:43] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/1ee030e7d0a8717e6a316eac4ed3848ec7fb8fd0

[15:45] *** envi^home left
[15:46] * jnthn grabs the nqp-rx updates

[15:51] <pmichaud> note also that by adding the & sigils, we tend to avoid the imcc bug that sticks methods in namespaces :)

[15:51] <pmichaud> (because our method names don't have the & sigil)

[15:51] <jnthn> pmichaud: I've been pondering that.

[15:51] <jnthn> pmichaud: Method generation that is.

[15:51] <jnthn> May just bit the bullet and make it all meta-class invocations like it should be.

[15:52] <pmichaud> I'd probably be okay with that :)

[15:52] <jnthn> Well, if we don't do it now, we probably need to at some point.

[15:53] <jnthn> I suspect done right it'll make things cleaner for multi handling too.

[15:53] <jnthn> I was pondering having some helper class, like I do for signatures and parameters.

[15:53] <jnthn> That can collect together various details about the package.

[15:53] <jnthn> It'll make various bits of analysis easier.

[15:53] <pmichaud> ooc, what's the difference between Perl6::Compiler::Signature and just a plain signature?

[15:54] <pmichaud> (haven't looked, just curious)

[15:54] <jnthn> Perl6::Compiler::Signature is the compile-time object representing a signature.

[15:54] <jnthn> It actually just generates PAST in the end to build the signature.

[15:54] <jnthn> But keeps all the details of that out of actions.pm.

[15:54] <pmichaud> works for me

[15:54] <jnthn> It's only involved at compile time.

[15:55] <pmichaud> I wonder if (someday)  PAST will want to have PAST::Signatre

[15:55] <pmichaud> *PAST::Signature

[15:55] <pmichaud> to handle multi-methods at the parrot level

[15:55] <pmichaud> (rakudo won't use it, but others might)

[15:55] <jnthn> Possibly.

[15:56] <jnthn> My motivation for doing it was...well, a few things. One was that I wanted to encapsulate signature code generation.

[15:56] <pmichaud> sure, I understand it now.

[15:56] <jnthn> Another was that we often have to tweak a signature before we emit it.

[15:56] *** pmurias joined
[15:57] <pmichaud> Just like we have PAST::Block to represent compile-time blocks, Perl6::Compiler::Signature represents compile-time signatures

[15:57] <jnthn> Right.

[15:57] <pmichaud> wfm

[15:57] <jnthn> Another thing - more a future concern - is that I think we're going to want to be able to look at these things in a sane way in, say, an optimizer stage.

[15:57] <pmichaud> sure, that makes sense also

[15:58] <jnthn> I'm quite keen to do similar for package.

[15:58] <jnthn> So we have an easy way of getting hold of the package's methods table, or attributes.

[15:58] <pmichaud> package might be an even bigger candidate for a custom PAST type

[15:58] <jnthn> Yeah.

[15:58] <jnthn> I guess we can see how it works in Rakudo and extract the commonalities that could apply elsewhere.

[15:59] <pmichaud> > my $a = 3,4,5;  say $a.WHAT

[15:59] <pmichaud> List()

[15:59] <pmichaud> > my $a = [3,4,5];  say $a.WHAT

[15:59] <pmichaud> Array()

[15:59] <pmichaud> > 

[15:59] <lambdabot>   <no location info>: parse error on input `='

[15:59] <lambdabot>   not an expression: `'

[15:59] <pmichaud> yay

[15:59] <masak> lambdabot--

[16:00] <pmichaud> ...do we get any value out of lambdabot on the channel any longer?

[16:00] <jnthn> Excellent.

[16:00] <jnthn> pmichaud: Only karma.

[16:00] <masak> pmichaud: karma.

[16:00] <jnthn> karma++

[16:00] <masak> but today we've seen p6bots here, so...

[16:00] <masak> it won't be long now.

[16:00] <jnthn> karma lambdabot

[16:00] <jnthn> @karma lambdabot

[16:00] <lambdabot> lambdabot has a karma of 41

[16:00] <jnthn> how?!

[16:00] <masak> long and faithful service. :)

[16:00] <pmichaud> > my @a = 3,4,5;  say @a.elems;

[16:00] <pmichaud> 3

[16:00] <pmichaud> > my @a = [3,4,5];  say @a.elems;

[16:00] <pmichaud> 1

[16:00] <pmichaud> > 

[16:00] <lambdabot>   <no location info>: parse error on input `='

[16:00] <lambdabot>   not an expression: `'

[16:01] <jnthn> masak: Yes, but I haven't seen it ++'d in quite a while. ;-)

[16:01] <masak> jnthn: yes, but she's old here.

[16:01] <jnthn> Ah, true.

[16:01] <pmichaud> the use of a "flatten" flag makes the code muuuuuch simpler.  TimToady++

[16:01] <masak> jnthn: also, she frequents other channels.

[16:01] <masak> @seen lambdabot 

[16:01] <lambdabot> Unknown command, try @list

[16:01] <jnthn> lol

[16:01] <jnthn> pmichaud: Yes, I'm glad that was suggested.

[16:01] <jnthn> TimToady++

[16:01] <jnthn> That discussion was useful in many ways. :-)

[16:02] <masak> flattening will get you anywhere.

[16:02] * jnthn notes to flatten his admiree in the future, rather than flatter her, which has got him nowhere.

[16:03] <masak> I take no legal responsibility.

[16:03] <jnthn> What could possibly go wrong? ;-)

[16:03] <jnthn> masak: ohbtw

[16:03] <jnthn> masak: Did you do your fligg for Riga yet?

[16:03] <masak> I did.

[16:04] <jnthn> If so, what day(s) you there? I can book mine today and match up.

[16:04] <masak> arriving on the 19th, departing on the 23rd.

[16:04] <jnthn> 'k

[16:04] <masak> I haven't booked the hotel yet.

[16:05] <pmichaud> jnthn: oh, I have an important question

[16:05] <jnthn> Me either. Apparently the hotel where the conference is discount has for conference attendees.

[16:05] <pmichaud> how hard would it be to get method dispatch on parcel to itemize it first ?

[16:05] <jnthn> masak: erm, that sentence was so grammar fail

[16:06] <masak> jnthn: yes. I noticed that. don't know exactly how to secure a room, though.

[16:06] <jnthn> pmichaud: Heh, well, we already did special stuffs for Whatever...

[16:06] <pmichaud> that's becoming a big blocker for me :-(

[16:06] <jnthn> masak: Ah, I didn't get so far as looking at that.

[16:06] *** lichtkind joined
[16:06] <jnthn> pmichaud: OK, so what you need to happen?

[16:07] <jnthn> pmichaud: I just detect parcel on the invocant and then .item it?

[16:07] <pmichaud> that would work

[16:07] <jnthn> pmichaud: OK, another question.

[16:07] <jnthn> pmichaud: Does just the dispatcher need to see it as the unbound thing, or does it need to modify the actual thing?

[16:08] <jnthn> pmichaud: Put better, do you also need me to .item invocants that are Parcels when we bind the signature?

[16:08] <pmichaud> let's back up just a sec

[16:09] <jnthn> OK

[16:09] <pmichaud> currently Parcel has two methods

[16:09] <jnthn> There's a couple of issues here, that's all.

[16:09] <pmichaud> .item and .list

[16:09] <jnthn> OK.

[16:09] <pmichaud> both of them mutate the parcel into being whatever was requested

[16:09] <pmichaud> so, if you call .list on a Parcel, it actually becomes a List at that point

[16:10] <jnthn> pmichaud: mutate?

[16:10] <pmichaud> yes, mutate

[16:10] <jnthn> pmichaud: What does that actual mean?

[16:10] <pmichaud> what I just said.

[16:10] <jnthn> pmichaud: Do you mean, it changes itself in place?

[16:10] <pmichaud> yes.

[16:10] <jnthn> oh

[16:10] <jnthn> Well, that makes it all much simpler then. :-)

[16:10] *** parduncia joined
[16:10] <pmichaud> if you call .item on a Parcel, its behavior depends on the contents

[16:11] <pmichaud> if the parcel contains exactly one element, then it becomes an ObjectRef to that element

[16:11] <pmichaud> otherwise, the parcel calls .list on itself and becomes a List

[16:12] <jnthn> OK.

[16:12] <jnthn> I only worry a tiny bit we're about to open another can of worms.

[16:12] <pmichaud> possibly

[16:12] <jnthn> Because in master, method invocation always does a deobjectref on the invocant.

[16:12] <jnthn> And dispatches on that.

[16:12] <pmichaud> that should be just fine

[16:13] <pmichaud> that's actually the desired behavior here, I think.

[16:13] <jnthn> Well, not really, if the dispatcher in find_method is calling .item

[16:13] <jnthn> Because then we're already in find_method.

[16:13] <jnthn> Whereas now we actually invoke the dynop before we start.

[16:13] <pmichaud> that's why I wanted to back up a second

[16:14] <pmichaud> it may be that the dispatcher needs to duplicate the .item logic for Parcel without calling .item

[16:15] <pmichaud> I'm totally open to other approaches btw -- this is just how it's set up now.

[16:15] <pmichaud> and keep in mind that Parcel isa RPA, if that makes things any simpler

[16:15] <jnthn> OK.

[16:15] <jnthn> Erm

[16:15] <jnthn> How are we going to call .item and .list on the parcel? :-)

[16:16] <jnthn> If the method dispatcher is like "oh, you're calling a method on a parcel..." :-)

[16:16] <pmichaud> in some sense I don't really need to do that, if the dispatcher is doing it for me (more)

[16:16] <pmichaud> more details....

[16:16] <pmichaud> in general, I think dispatch on parcel is a bit "special" to begin with.  do you agree?

[16:17] <jnthn> Yes.

[16:17] <jnthn> Somewhat.

[16:17] <pmichaud> okay

[16:17] <pmichaud> then there's nothing that says that "itemize a parcel" and "listify a parcel" have to be methods on the parcel

[16:17] <jnthn> In the same way that dispatch on Junction and Whatever and a role also is...

[16:17] <pmichaud> they could just be private subroutines

[16:18] <pmichaud> I've done them as methods for now because that's the model we've been used to working with, but parcel is special

[16:18] <jnthn> We'll need ".Capture" later too perhaps, but yes.

[16:18] <jnthn> They could become subs.

[16:18] <pmichaud> so then the dispatcher could invoke the sub rather than a method dispatch

[16:18] <jnthn> Heck, we can cache the sub PMCs for those and we might even manage to be efficient.

[16:19] <pmichaud> actually

[16:19] <pmichaud> I wonder if there are any places that I currently call .list or .item on a parcel anyway

[16:19] <pmichaud> I think possibly not.

[16:19] <jnthn> ah, interesting.

[16:20] <pmichaud> well, I must do it somewhere, to get the Parcel->List behavior

[16:20] <jnthn> What happens in my @a = 1,2,3; ?

[16:20] <pmichaud> yeah

[16:20] <jnthn> Yeah, that's what I was wondeirng. :-)

[16:20] <pmichaud> oh, it's in the !FETCH method for Parcel

[16:21] <pmichaud> it itemizes the parcel and returns that

[16:21] <jnthn> erm, there's a !FETCH method on Parcel too?

[16:21] <jnthn> Will that object to the parcel being mutated first?

[16:21] <pmichaud> it's actually not an issue (more)

[16:21] <pmichaud> (you'll like this)

[16:22] <pmichaud> the default behavior for parcel's !FETCH is to itemize the parcel and return an objectref to it

[16:22] <jnthn> oh

[16:22] <jnthn> :-)

[16:22] <pmichaud> that's also the default behavior for List

[16:22] <pmichaud> (I think)

[16:22] <pmichaud> so.... guess what?

[16:23] <pmichaud> if you itemize the parcel, and then dispatch !FETCH to the resulting List.... it's the same thing.

[16:23] <jnthn> oh!

[16:23] <jnthn> whee

[16:24] <jnthn> OK, so are we going to make Parcel itemization be a special-case method call, or are we going to make it a sub call?

[16:24] * jnthn has the dispatcher open ready to hack on 

[16:24] <pmichaud> I prefer subcall

[16:24] <pmichaud> at the moment I'd like the idea of not having method calls on Parcel

[16:24] <jnthn> OK.

[16:24] <pmichaud> however, if having a special list of methodcalls is easier, I'm fine with that also

[16:24] <jnthn> Fix that, and tell me the names of the subs.

[16:25] <jnthn> I'll do the easiest impl that works for now.

[16:25] <pmichaud> okay

[16:25] <jnthn> And we can optimize later.

[16:25] <pmichaud> well, it may be that later we discover there are other things that really need to be methods on Parcel...

[16:25] <pmichaud> but somehow I'm hoping not

[16:25] <jnthn> oh btw

[16:25] <jnthn> oh crap, I forgot what I was going to say...

[16:25] <jnthn> ...it'll come back...

[16:26] <pmichaud> okay.  I need a dr pepper and then I'll make the switch.  Should be very quick.

[16:26] *** iblechbot joined
[16:26] <jnthn> oh!

[16:26] <jnthn> I remembered.

[16:27] <jnthn> transform_to_p6opaque

[16:27] <jnthn> Needs to have been called on the object.

[16:27] <jnthn> If you copied the .new stuff and are creating the Parcel through a .new call that happens automatically.

[16:27] <pmichaud> oh, please no

[16:27] <pmichaud> .new is hugely expensive for every parcel

[16:28] <jnthn> That's fine.

[16:28] <jnthn> transform_to_p6opaque it then.

[16:28] <pmichaud> okay

[16:28] <jnthn> That way, we end up in the correct dispatcher.

[16:28] <jnthn> Oh, wait...is this a PIR subclass?

[16:28] <pmichaud> right now &infix:<,> is the parcel constructor, I'll do it there

[16:28] <pmichaud> yes, it's a PIR subclass

[16:28] <jnthn> phew.

[16:28] <pmichaud> it's subclass of Any

[16:28] <jnthn> Good.

[16:29] *** crazed joined
[16:29] <jnthn> ok, go grab your dr pepper :-)

[16:29] <pmichaud> (basically the same structure List has in master... subclass of Any and RPA, RPA looks like a Parcel)

[16:29] <crazed> dr pepper?

[16:29] <crazed> shti now i want one

[16:31] * jnthn makes a cup of fruit tea...SO healtheir ;-)

[16:31] <crazed> so perl6, what's the main difference that everyone should know

[16:31] <crazed> i'm reading the 5 to 6 document slowly

[16:33] <avar> That unlike 1-5 it's a different language on a different implementation

[16:33] <crazed> completely rewritten?

[16:33] <avar> yes

[16:33] <pmichaud> jnthn: is it just   "transform_to_p6opaque $P0"  ?

[16:34] <jnthn> pmichaud: yup

[16:34] <jnthn> pmichaud: in-place vtable swap.

[16:34] <pmichaud> okay

[16:34] <crazed> hmm interesting

[16:34] <crazed> why the decision to rewrite?

[16:34] *** brunov left
[16:35] <pmichaud> it was felt we had reached the limits of being able to extend Perl 5

[16:35] *** am0c joined
[16:35] <pmichaud> (at least, to be able to extend it in new ways we wanted to go)

[16:35] <jnthn> crazed: It's hard to say there's a single "main difference". There's a lot of differences, ranging from small to large, that together make the coherent Perl 6 whole. :-)

[16:36] <crazed> ah interseting looks more object oriented?

[16:36] <mberends> wow, afk for a few hours and so much shiny appears in the backlog :-)

[16:36] *** nihiliad left
[16:37] <Su-Shee> crazed: in short: it tastes and feels like perl and yet somehow it has more chocolate chips and the cream is organic and it's real vanilla in it and the nuts are roasted crunchy..;)

[16:37] <pmichaud> mberends: you've not seen anything yet :-)

[16:37] <jnthn> crazed: Of note: grammars, new object model, mutable grammar (Perl 6 parses itself and it's easy to tweak the parser), cleaner syntax...

[16:37] <jnthn> New data structures (e.g. junctions)

[16:37] <mberends> pmichaud: I can imagine :-)

[16:37] <jnthn> Multiple dispatch too.

[16:38] <Su-Shee> more operators than you can carry.. ;)

[16:38] <crazed> it looks pretty cool to me

[16:38] <crazed> i may have to install it in a VM and start playing around

[16:39] <jnthn> crazed: It can build itself pretty self-contained anyway, and even if you do Configure it so it will make install to your bin directory, it goes in as perl6, and leaves your Perl 5 well alone. :-)

[16:39] <jnthn> So if VM is just for "don't screw my p5 installation up" you'll be fine. :-)

[16:40] *** meppl joined
[16:40] <crazed> haha nice but still i have enough room on my xen server and need reasons to use it up

[16:40] <jnthn> hehe ;-)

[16:40] <crazed> 2.7TB and 8gigs of ram

[16:40] <jnthn> pmichaud: Got me a name yet?

[16:40] <avar> I already bought this hammer...

[16:41] <jnthn> ...i can has nailz?

[16:41] *** nihiliad joined
[16:43] *** nihiliad left
[16:43] *** desertm4x joined
[16:43] <Su-Shee> a 4 steak knives set. 

[16:44] *** rfordinal left
[16:44] <jnthn> mmm...stejk. :-)

[16:44] <pmichaud> jnthn: it'll be '!parcel_item' in the Parcel namespace

[16:45] <pmichaud> I'm having to work out a couple of issues on this end

[16:46] <jnthn> pmichaud: kk

[16:47] *** nihiliad joined
[16:50] *** lichtkind_ joined
[16:50] *** nihiliad left
[16:50] <pmichaud> I think I may break the RPA masking in Parcel

[16:50] <pmichaud> i.e., Parcel isa RPA, but RPA doesn't think it's a Pacel

[16:50] <pmichaud> *Parcel

[16:50] <pmichaud> (shouldn't affect what you're doing)

[16:51] <jnthn> pmichaud: pushed

[16:51] <jnthn> obviously, untested. ;-)

[16:51] <pmichaud> jnthn++

[16:51] <pmichaud> np, I can get it from here :)

[16:51] <pmichaud> many thanks

[16:51] <jnthn> np, 'twas easy.

[16:51] <pmichaud> I figured it would be (for you)

[16:53] *** icwiener joined
[16:53] *** nihiliad joined
[16:54] <pmichaud> ...which is cheaper, an 'isa' check for RPA, or invoking a method on it?

[16:54] <pmichaud> ...I'm going to guess that the isa check is cheaper.

[16:55] <jnthn> I'd hope the isa check is cheaper.

[16:55] <pmichaud> (no pcc overhead)

[16:55] <pmichaud> okay

[16:55] <pmichaud> that lets me avoid a cheat :)

[16:56] <pmichaud> what's a little weird about this implementation now is that we convert RPAs to be Parcels to get the Parcel semantics, but as soon as it's placed in context the Parcel turns back into an RPA

[16:56] <pmichaud> (the Parcel's contents, that is)

[16:56] <jnthn> hmm

[16:56] <pmichaud> oh well, we'll go with that for now

[16:57] <jnthn> that's a lot of fiddling.

[16:57] <pmichaud> oh, wait

[16:57] <pmichaud> I don't need to do that

[16:57] <pmichaud> instead of Parcel isa RPA, I'll do Parcel has-a RPA

[16:57] <pmichaud> then there's no fiddling required, and Parcel is just an RPA wrapper

[16:58] <pmichaud> that's muuuuch cleaner

[16:59] <pmichaud> just a sec while I work this out :)

[16:59] <pmichaud> flattening is much nicer in the new implementation as well.  it's just a flag check

[16:59] <pmichaud> no isa checks

[17:01] *** Chillance joined
[17:01] <jnthn> :-)

[17:01] <jnthn> yay, isa relationships are dieing all around us!

[17:01] <pmichaud> (and it's lazy, too)

[17:02] <jnthn> pmichaud: BTW, for creating arrays and lists, you do .new there, or new ['...'] ?

[17:02] <pmichaud> new ['...']   currently

[17:02] <jnthn> hmm

[17:02] <pmichaud> I'll be sure to p6opaque those also

[17:02] <jnthn> That *might* hurt us later.

[17:02] <jnthn> Well, it's not that.

[17:03] <jnthn> It's that if you grab the proto and .new on it, it's like "oh lol I'm a role, let me do something punny"

[17:03] <jnthn> That is, if Array is a role.

[17:03] <pmichaud> okay, we can fix that when we make these into roles

[17:03] <jnthn> Whereas here you're trying to instantiate a Role.

[17:03] <jnthn> Well

[17:03] <jnthn> Doesn't new call VTABLE_instantiate anyway?

[17:03] <jnthn> If I just implement that... ;-)

[17:04] <pmichaud> I don't know for sure what opcode new calls

[17:04] <jnthn> checking

[17:04] <pmichaud> i just know that .new is *really* expensive for what we want

[17:04] <pmichaud> I suspect what we really need is BUILD

[17:04] <pmichaud> I just need to have an object of the appropriate type created

[17:05] <jnthn> yeah

[17:05] <jnthn> oh hmm

[17:05] <jnthn> so

[17:05] <pmichaud> but I don't want any attribute initialization, because I'm about to do that myself

[17:05] <jnthn> If Parrot_oo_get_class returns something, we call VTABLE_instantiate.

[17:06] <jnthn> So should be able to do something.

[17:06] <jnthn> Anyway, we'll cross that bridge later on.

[17:07] *** lichtkind left
[17:09] <pmichaud> oh, hey

[17:09] <pmichaud> hmmmmm

[17:09] <pmichaud> nm

[17:09] * jnthn was temporarily excited

[17:09] <pmichaud> ...would a check for a 'parcel' flag be better than an isa check?

[17:10] <pmichaud> it occurs to me that a Parcel is just a List with a 'parcel' flag attached :-)

[17:11] <pmichaud> both of them have RPAs

[17:11] <pmichaud> and the only reason for a Parcel at the moment is to become a List

[17:11] <pmichaud> so maybe it should just be a List to start with :-)

[17:12] *** brunov joined
[17:12] <pmichaud> s/reason/purpose

[17:13] <jnthn> pmichaud: lol

[17:13] <pmichaud> I'll keep them separate for now.  We might look into unifying them a bit later

[17:13] <jnthn> pmichaud: Yeah.

[17:13] <pmichaud> I keep wondering if Parcel is in fact just a special form of List

[17:13] <jnthn> pmichaud: If they're different types, you can have the multi-dispatcher treat them trivially as separate things. I dunno if we need to do that though.

[17:13] <pmichaud> that's true'

[17:14] <pmichaud> it may be that someday I do Parcel isa List

[17:14] <jnthn> aye

[17:14] <jnthn> Maybe separate is simpler for now though.

[17:14] <pmichaud> certainly better not to conflate things that perhaps ought not be conflated

[17:14] <jnthn> Especially as that bit of the spec is potentially fluid-ish, but I hope us having an implementation might change that.

[17:14] <pmichaud> easier to conflate later :)

[17:14] <pmichaud> I'm thinking this will do that.

[17:15] <pmichaud> this is going together far simpler than previous designs.... and we have laziness to boot :)

[17:15] <jnthn> The laziness is a wonderful win.

[17:15] <jnthn> I'm really happy we're doing it now though.

[17:15] <pmichaud> same here

[17:15] <jnthn> Even if it makes this branch last a couple of days longer, it's still better than breaking everything list-related again at some point in the future.

[17:15] <pmichaud> I briefly considered the non-lazy form last night, then said... no, let's try it now

[17:16] <pmichaud> I think it won't significantly delay the branch

[17:16] <pmichaud> besides, it knocks off a huge item on our roadmap

[17:16] <jnthn> Right, and tbh I'm happy enough with the pace of development on the branch so far.

[17:16] <jnthn> That it's not heading for drawn out.

[17:16] <pmichaud> it also makes things a lot faster overall, because we're not flattening things that we might never use anyway

[17:17] <jnthn> speeeeed

[17:17] <jnthn> we needs it

[17:17] <pmichaud> well, maybe not a lot faster

[17:17] <jnthn> Yeah

[17:17] <pmichaud> but certainly a little faster :)

[17:17] <pmichaud> we're definitely avoiding unneeded work

[17:18] <jnthn> I like avoiding unneeded work. :-)

[17:18] <jnthn> Just moving parse_name into Grammar now.

[17:19] <pmichaud> oh, nice

[17:19] *** NorwayGeek left
[17:19] <jnthn> Then I'll fix name parsing.

[17:19] <pmichaud> I'm going to steal a simpler version of that code into NQP

[17:19] <pmichaud> then NQP can handle  @Other::Package::var

[17:21] *** __ash__ joined
[17:21] <pmichaud> oh, maybe I do want Parcel isa RPA

[17:21] <pmichaud> :-)

[17:21] * pmichaud keeps playing with configs

[17:22] *** NorwayGeek joined
[17:24] *** Kodi joined
[17:24] *** pmurias left
[17:27] <Kodi> In March, `eigenstates` was re-specified to be a private method of the junction class, but we've still got a bunch of tests of it in t/S03-junctions. Should those tests be thrown out?

[17:27] *** nihiliad left
[17:28] *** __ash__ left
[17:29] *** __ash__ joined
[17:29] *** icwiener_ joined
[17:30] *** icwiener left
[17:33] *** leedo joined
[17:33] *** fridim_ joined
[17:35] <colomon> Kodi: where is the change to the spec?

[17:35] <crazed> shit there's types now

[17:35] <crazed> cool

[17:37] <Kodi> colomon: r25891

[17:37] <Kodi> "+Note this is a private method; you must arrange for yourself to be trusted

[17:37] <Kodi> +by the junctions class in order to call it, which probably involves evil

[17:37] <Kodi> +MONKEY_PATCHING."

[17:38] <Kodi> That was from S32-setting-library/Containers.pod.

[17:39] <colomon> Danke.

[17:40] <colomon> Kodi: seems to me those tests should be changed to use monkey typing, and an additional test should be written to make sure eigenstates is private.

[17:41] * colomon has no idea whatsoever how to do monkey typing...

[17:41] <Kodi> Ha, I was just about to ask how.

[17:41] <Kodi> Anyway, I agree about the additional test.

[17:42] <crazed> sweet! subs are much better now. i never liked the whole @_ thing

[17:42] <colomon> crazed: couldn't agree more.

[17:42] <Kodi> crazed: *And* it's still there if you want it, which, yes, does happen. Or at least I find it convenient sometimes.

[17:43] <Su-Shee> well if I stuff an array in anyway.. 

[17:43] <crazed> yeah perl6 is looking pretty nice so far

[17:44] *** nihiliad joined
[17:44] <pmichaud> man, I've messed something up here locally

[17:45] <jnthn> pmichaud: lol same

[17:45] <jnthn> pmichaud: Well, I think I fixed it.

[17:45] <jnthn> I replaced a token...apart from I didn't delete the previous definition.. :-/

[17:45] <colomon> Kodi: is "monkey typing" even a thing?  My web search seems to turn it up as a mistake where "monkey patching"  is meant.

[17:45] <Kodi> colomon: Hey, you brought it up!

[17:46] <Kodi> I thought you just meant "cheat the typing system, somehow".

[17:46] <colomon> Kodi: Oh, so it's my brain-o!  I see.

[17:46] <jnthn> colomon: monkey typing is a much funnier mental image though. ;-)

[17:46] <colomon> I just miscopied monkey patching.

[17:46] <Kodi> Not to be confused with a thousand monkeys typing Shakespeare.

[17:46] <colomon> Monkey patching is just adding "is also", no?  (Well, "auguments" in theory.)

[17:46] *** lilstevey joined
[17:46] <Kodi> Although they could probably be represnted rather well with a junction.

[17:46] <jnthn> colomon: kinda, ish.

[17:47] <jnthn> colomon: I think there's been some back and forth on the spec there...

[17:47] <Kodi> jnthn: But it's intended that there be some way to access somebody's private method if you need to, right?

[17:48] <jnthn> pmichaud: aww crap, I did a grammar change and now we have a stack overflow and segv.

[17:49] <jnthn> Kodi: $obj!method iirc.

[17:49] <jnthn> Kodi: Or at worst, just find it via introspection.

[17:50] <Kodi> Oh, very good. Then we can test the eigenstates method with (1|2)!eigenstates.

[17:50] <colomon> that can't be right, can it?  what's the point of being private then?

[17:50] *** brunov left
[17:50] <jnthn> Kodi: Only if the caller is trusted though, iirc.

[17:51] <colomon> rakudo: say (any(1,2)).WHAT

[17:51] <p6eval> rakudo d154eb: OUTPUT¬´Junction()‚ê§¬ª

[17:52] <Kodi> eigenstates is still public in Rakudo.

[17:53] <Kodi> jnthn: Any idea how we can get the eigenstates class to trust us? Otherwise, I guess I'll research privacy in the Synopses.

[17:53] <pmichaud> oh, suuure... *now* it works, and I have no idea why.

[17:53] <pmichaud> Kodi: I don't think it's well specced at the moment

[17:53] <jnthn> Kodi: Rakudo doesn't implement "trusts" yet

[17:53] <jnthn> pmichaud: OK, so if I take out...

[17:53] <jnthn> token name { <identifier> ** '::' }

[17:53] <jnthn> And add in

[17:54] <Kodi> pmichaud: Ah. Very well, then.

[17:54] <jnthn> token name { [ | <identifier> <morename>* | <morename>+ ]

[17:54] <jnthn> }

[17:54] <jnthn> token morename { '::' <identifier>

[17:54] <jnthn> }

[17:54] <jnthn> We stack overflow (at C level, not PIR!)

[17:54] <jnthn> Is there something very stupid I'm doing?

[17:54] *** nihiliad left
[17:54] <pmichaud> I'd look into the actions a bit and see what's happening there

[17:54] <jnthn> There's no action for name.

[17:55] <pmichaud> there might be in the HLL grammar

[17:55] <jnthn> HLL grammar? 

[17:55] <colomon> Is there a reason we can't just say "class Junction is also" and add a method to get at !eigenstates there?

[17:55] <pmichaud> some actions we inherit from HLL::Grammar

[17:55] <pmichaud> (see the top declaration)

[17:55] <pmichaud> for example, the actions for handling expressions, integer literals, strings, etc.

[17:55] <jnthn> You mean HLL::Actions ?

[17:55] <pmichaud> yeah, HLL::Actions

[17:56] <pmichaud> looking

[17:56] <pmichaud> no, nothing there

[17:56] <pmichaud> hmmm

[17:56] <crazed> damn the more i read about perl6 the less i want to use 5

[17:56] <pmichaud> jnthn: I don't see anything obviously wrong with what you're doing

[17:57] <jnthn> pmichaud: ouch.

[17:57] <jnthn> I prefer it when I do something stupid...

[17:57] <pmichaud> oh, yes I do

[17:57] <pmichaud> look for instances of $<name>  in the grammar

[17:57] <Kodi> crazed: Use Perl 5.10!

[17:57] <pmichaud> especially $<name><identifier>

[17:57] <pmichaud> they're expecting an array

[17:57] <jnthn> oh

[17:57] <pmichaud> but you've changed it to be a not-array

[17:57] <pmichaud> (which is what STD.pm does, yes)

[17:58] <jnthn> well, the main reason I changed it is so ::T parses too...

[17:58] <pmichaud> right

[17:58] <pmichaud> no problem

[17:58] <pmichaud> just fix the part that is expecting <identifier> to be an array :-)

[17:58] <jnthn> good job I just moved parse_name into the right place. :-)

[17:59] <pmichaud> I can do it after I'm through working out Parcel :)

[17:59] *** nihiliad joined
[17:59] <jnthn> I'll have a crack, I didn't realized things were digging into the name rule.

[18:00] <pmichaud> yeah, it's the cheap way to split up a name when you don't have parse_name :)

[18:00] <jnthn> ;-)

[18:00] <jnthn> ** '::' is really cute

[18:00] <jnthn> Too bad we can't keep it. :-)

[18:01] <pmichaud> okay, time to try out the shiny new dispatcher :)

[18:02] <pmichaud> (the one that fixes my parcels for me)

[18:02] <jnthn> The one I hope doesn't blow up. :-)

[18:02] <pmichaud> we'll know soon.

[18:02] <jnthn> .oO( somebody set up us the parcel bomb )

[18:03] *** __ash__ left
[18:04] *** Kodi left
[18:04] <pmichaud> jnthn: hmmm, doesn't quite work

[18:05] <jnthn> FAIL.

[18:05] <jnthn> In what way?

[18:05] *** am0c left
[18:05] <pmichaud> still investigating

[18:05] <pmichaud> the dispatcher does appear to be correctly getting the item

[18:05] <pmichaud> but then it can't find any of the item's methods

[18:06] <pmichaud> perhaps it needs to re-fetch a method table or something like that?

[18:06] <pmichaud> i.e., perhaps it thinks it still has a Parcel, even though the Parcel's type has changed?

[18:06] <jnthn> hmm...thought I'd taken care of that...

[18:06] <jnthn> oh wait, no

[18:06] <jnthn> silly me.

[18:07] *** payload left
[18:08] * pmichaud goes to look at the commits

[18:08] <jnthn> pmichaud: pushed

[18:08] <jnthn> pull and try again.

[18:09] <pmichaud> pulling, trying again

[18:09] <jnthn> I hadn't noticed we init'd a couple of things right up top in the decls.

[18:09] *** lambdabot left
[18:09] *** payload joined
[18:10] <pmichaud> WIN!

[18:10] <pmichaud> jnthn++

[18:10] <jnthn> yay

[18:12] * mberends applauds

[18:12] <pmichaud> oh this is sooo cewl

[18:13] *** fax left
[18:13] <jnthn> hehe

[18:14] <jnthn> With a *slight* dash of evil mixed in on the !FETCH. :-)

[18:14] <pmichaud> actually, it's pretty natural

[18:15] <colomon> mberends: Isn't watching this inspirational?

[18:16] <pmichaud> it'd be more inspirational with commit messages on the channel :)

[18:16] *** araujo joined
[18:16] <pmichaud> pushed

[18:16] <jnthn> pmichaud: nice

[18:17] <jnthn> pmichaud: I guess we have arrays and for loops and stuff soon out of this?

[18:17] <pmichaud> yes

[18:17] <pmichaud> well, we have arrays now

[18:17] <jnthn> huh...why does git think I'm already up to date... :-/

[18:17] <pmichaud> oh, failed to push here

[18:17] <jnthn> ah, that's why.

[18:17] <pmichaud> apparently another commit landed

[18:17] <pmichaud> merging

[18:17] *** lilstevey left
[18:17] <jnthn> neh neh!

[18:17] <pmichaud> done

[18:17] <pmichaud> testing

[18:18] <pmichaud> (rebuilding)

[18:18] <pmichaud> jnthn: are you in the mode (like me) of wanting to push commits quickly so that the other guy has to deal with the merge?  ;-)

[18:18] <jnthn> pmichaud: yes

[18:18] <jnthn> ;-)

[18:19] <pmichaud> source code control as a motivational tool

[18:19] <jnthn> But I feel less bad about it now that I know you're doing that too.

[18:19] <mberends> colomon: totally inspirational. What's also nice is how the process whirlpools back into the specs, and thus into the other implementations via STD :)

[18:20] *** stepnem left
[18:20] <pmichaud> pushed, for real this time

[18:21] * pmichaud looks around the house and thinks that perhaps he really should do some laundry and/or wash some dishes...

[18:22] <jnthn> I hate it when I want food and it's like, ENOCLEANDISHES.

[18:22] <jnthn> Well actually that doesn't happen much, I have lots of didhes.

[18:22] <jnthn> It's like ENOCLEANSAUCEPAN

[18:22] <pmichaud> same here, but in my case I'm not the primary culprit of ENOCLEANDISHES

[18:22] <colomon> It's amazing (or perhaps sad) how many times when I set out to cook, the first thing I do is the dishes.

[18:23] <colomon> I think what bugs me is ENOPLACETOPUTDIRTYDISHES.

[18:23] *** lambdabot joined
[18:23] <moritz_> good localtime() everybody

[18:23] <jnthn> pmichaud: Suspect inbalance of clean dish consumers and producers. ;-)

[18:24] <pmichaud> moritz! wb!

[18:25] <jnthn> moritz! \o/

[18:27] <moritz_> looks like a fairly big backlog :)

[18:27] <pmichaud> it is

[18:27] <pmichaud> but nothing much has happened

[18:27] <pmichaud> well, other than....

[18:27] <pmichaud>    jnthn has the multisub dispatcher working in the rakudo ng branch

[18:27] <pmichaud>    we now have lazy lists

[18:27] <pmichaud>     arrays vivify properly

[18:27] <pmichaud>     we now generate inplace operators dynamically

[18:28] <pmichaud>     lexicals are initialized properly

[18:28] <colomon> The ng branch commit log on github is both shorter than the #perl6 backlog and shockingly awesome.

[18:28] <pmichaud>      package vars are initialized properly

[18:29] <pmichaud>     lexical subs and multisubs are "done right"

[18:29] <moritz_> you're kidding, are you?

[18:29] <pmichaud> no

[18:29] <moritz_> WE HAVE LAZY LISTS?

[18:29] <pmichaud> we do

[18:29] *** dalek left
[18:29] <pmichaud> soon we'll have lazy ranges and lazy IO to go along with them

[18:30] * colomon does the lazy dance!

[18:30] *** dalek joined
[18:30] <pmichaud> of course, we don't even parse and/or run Test.pm yet, so....

[18:30] <pmichaud> take all of the above with a grain of salt :)

[18:31] <jnthn> Oh, don't forget we're already using the shiny signature binder too. :-)

[18:31] <colomon> Is !FETCH what provides the laziness?

[18:31] <pmichaud> no

[18:31] <pmichaud> the laziness is built into the List object itself

[18:31] <pmichaud> and !generate handles the converting of lazy values into generated ones

[18:31] <moritz_> so it now has-a RPA?

[18:31] <pmichaud> yes

[18:31] <moritz_> instead of is-a?

[18:31] <moritz_> wow

[18:31] <pmichaud> parcel isa RPA now

[18:32] <pmichaud> and parcels get lazily flattened

[18:32] <pmichaud> there's a very good chance I'll do lazy gather+take in the next day or so.  Perhaps even before for loops.

[18:33] <jnthn> well, depends how soon we want the test harness running.

[18:33] * jnthn isn't sure how high a priority that is

[18:33] <pmichaud> well, ultimately I want for() to just be map()

[18:33] <jnthn> yes

[18:33] <pmichaud> I might just write map eagerly for now, though.

[18:33] <jnthn> That means we need to deal with void context.

[18:34] <pmichaud> I don't see that as being too difficult either

[18:34] <jnthn> pmichaud: Is it helpful if I focus on getting class and role decls back in place?

[18:34] <pmichaud> roles, definitely

[18:34] <pmichaud> I'm doing Str now

[18:34] <jnthn> pmichaud: So we can start building things back in the setting again...

[18:34] <pmichaud> oh, you mean the decls

[18:34] <jnthn> Yeah

[18:34] <pmichaud> yes.

[18:34] <jnthn> ah, you wanted to be able to do roles again from PIR, didn't you...

[18:34] <pmichaud> right

[18:35] <pmichaud> so I can do Positional

[18:35] <pmichaud> and Failure

[18:35] <jnthn> I'll sort that out for you real soon now.

[18:35] <pmichaud> but I figure if you do role/class decls, you'll solve my want for roles in PIR :)

[18:35] <jnthn> heh

[18:35] <pmichaud> anyway -- yes, role+class decls would be good

[18:35] <jnthn> I don't see me finishing up role + class decls today

[18:35] <pmichaud> that's fine

[18:35] <jnthn> Well, I guess I could not sleep... ;-)

[18:36] <pmichaud> I have more than enough on my plate at the moment, I'm not truly blocked on anything

[18:36] <pmichaud> the role stuff would be nice-to-have

[18:36] <pmichaud> but isn't blocking

[18:36] <moritz_> non-blocking roles ;-)

[18:36] <jnthn> I akshually have to do a few @other_bit over the next couple of days too.

[18:36] <pmichaud> okay

[18:36] <jnthn> I propose doing something like Rakudo days split over 2 days.

[18:36] <pmichaud> I'll let you know if I get priorityneeds

[18:36] <jnthn> so like half on mon, half on tue for the next one.

[18:36] <pmichaud> at the moment, it would be roles-from-pir

[18:37] <pmichaud> class decls shortly after that

[18:37] <jnthn> I can surely have those for you today, since it's mostly bringing back in some other code.

[18:37] <jnthn> OK. What will you need in class decls?

[18:37] <pmichaud> that would be awesome

[18:37] <pmichaud> actually, we don't need much

[18:37] <jnthn> methods and attributes, I presume.

[18:37] <pmichaud> we can cheat "augment class ..."  by just saying "module"  :-)

[18:37] <jnthn> lol

[18:37] <jnthn> sicko.

[18:37] <jnthn> :-)

[18:37] <jnthn> I might *just* manage augment. :-)

[18:37] <pmichaud> if not, then we'll just do "module" for a short bit

[18:38] <jnthn> Given it's meant to be easy now. ;-)

[18:38] <jnthn> otoh I'm sorta in a "put this stuff back cleaner" mood.

[18:38] *** stepnem joined
[18:38] <pmichaud> right

[18:38] <jnthn> And a "make custom metaclasses easier to do later" mood too...

[18:39] <pmichaud> oh, I also forgot:

[18:39] <pmichaud>     subnames now begin with &

[18:39] <pmichaud>     no more funny "list" method conflicting with the "&list" builtin

[18:39] *** __ash__ joined
[18:39] <jnthn> Don't care about doing the custom metaclasses right now, but I think putting this stuff in such that I have a clear path to that later will help me get a decent design.

[18:40] <pmichaud> jnthn: +1

[18:40] <jnthn> And if I pretty much end up doing them by accident, well, win.

[18:41] <mberends> Lately each Rakudo Day is like a former Rakudo Month :-) Wow!

[18:46] *** payload left
[18:49] <Su-Shee> a hash key doesn't have to be something string-ish anymore, doesn't it?

[18:50] <jnthn> Su-Shee: In spec, or in Rakudo?

[18:50] <pmichaud> yeah, I'm looking at how quickly I'm closing in on my Hague grant items now :)

[18:50] <pmichaud> ("about time", I know :-)

[18:50] <Su-Shee> jnthn: in Rakudo - but is the spec different?

[18:50] *** Whiteknight left
[18:51] <jnthn> Su-Shee: Yes, Rakudo only copes with string ones at the moment, afaik.

[18:53] <colomon> rakudo: my %a; %a{1/2} = 1; say %a.keys.perl

[18:53] <p6eval> rakudo d154eb: OUTPUT¬´["0.5"]‚ê§¬ª

[18:53] <colomon> So Rakudo will take anything given to it as a hash key and stringify it?

[18:54] <jnthn> colomon: atm yes

[18:56] <Su-Shee> rakudo: sub add { 1 + 1; }; my %a; %a{ add() } = 1; say %a.keys.perl

[18:56] <p6eval> rakudo d154eb: OUTPUT¬´["2"]‚ê§¬ª

[18:57] <jnthn> rakudo: sub add { 1 + 1; }; my %a; %a{ &add } = 1; say %a.keys.perl # uh-oh

[18:57] <p6eval> rakudo d154eb: OUTPUT¬´["add"]‚ê§¬ª

[18:58] *** jan joined
[18:58] <Su-Shee> rakudo: sub add { 1 + 1; }; my %a; %a{ add } = 1; say %a.keys.perl

[18:58] <p6eval> rakudo d154eb: OUTPUT¬´["2"]‚ê§¬ª

[18:58] *** jan is now known as Guest91830

[19:01] *** Whiteknight joined
[19:03] *** jferrero joined
[19:07] <justatheory> s/monkey patching/fuck typing/

[19:08] <jnthn> At least if it was called that, nobody in a corporate environment would dare to do it in their code. ;-)

[19:10] *** wlan joined
[19:10] <justatheory> http://justatheory.com/computers/programming/methodology/fuck-typing.html

[19:10] <wlan> hiall

[19:10] <moritz_> hi

[19:11] <wlan> i read about perl6

[19:12] <wlan> i can't understand 

[19:12] <wlan> why better than perl5?

[19:12] <wlan> what*

[19:13] <moritz_> there are lots of things that are better

[19:13] <wlan> gm

[19:13] <moritz_> for example we have new, much more powerful and readable regexes

[19:13] <moritz_> we have a type system

[19:13] <moritz_> and optional type constraints

[19:13] <moritz_> lazy lists

[19:13] <moritz_> multi dispatch

[19:14] <moritz_> custom operators

[19:14] <moritz_> and so on, the list is rather long

[19:14] <Su-Shee> "real" OO...

[19:14] <wlan> and CPAN?

[19:14] <__ash__> i like the new regex things, the are nifty 

[19:14] <moritz_> and, very  importantly, we're fixing old things that can't be fixed in perl 5

[19:15] <moritz_> because it breaks backwards compatibility

[19:15] <moritz_> or because it's conceptually impossible in Perl 5

[19:15] <wlan> interisting

[19:15] <moritz_> wlan: we don't have a CPAN for Perl 6 yet, but we do plan to have one

[19:15] <Su-Shee> (I get sold every time.. ;)

[19:16] <wlan> what language written perl6?

[19:16] *** lichtkind_ left
[19:16] <pmichaud> mostly Perl 6.

[19:16] <moritz_> Perl 6 is a language specification - compilers can be written in any language people like

[19:16] <wlan> gm

[19:17] <moritz_> we don't have one implemention

[19:17] <wlan> i want say compilator

[19:17] <moritz_> *implementation

[19:17] <moritz_> we have one rather popular, called Rakudo

[19:17] <moritz_> that's based on parrot, a virtual machine

[19:17] <pmichaud> see also http://perl6.org/compilers/

[19:17] <wlan> i now see this portal

[19:19] *** cottoo left
[19:21] *** japhb joined
[19:23] <wlan> Pugs is written in Haskell, and has been inactive since mid 2007.

[19:23] <pugs_svn> r28971 | Kodi++ | [t/spec/] "Junction" -> "junction", ".eigenstates" -> "!eigenstates" (as per r25891). 

[19:23] <pugs_svn> r28971 | [t/TODO] Now we need to ensure that the tests can call junction!eigenstates.

[19:24] <wlan> redeyes

[19:24] <wlan> =))

[19:24] *** masak left
[19:26] *** NorwayGeek left
[19:27] *** NorwayGeek joined
[19:28] <moritz_> uhm, the point is that you can't call junction!eigenstates - it's a private method

[19:29] <Su-Shee> wth are eigenstates?!

[19:29] <colomon> moritz_:  but it's spec'ed so we need to test it.

[19:30] <colomon> rakudo: say any(1,2,3).eigenstates.perl

[19:30] <p6eval> rakudo d154eb: OUTPUT¬´[1, 2, 3]‚ê§¬ª

[19:30] *** NorwayGeek left
[19:30] <moritz_> colomon: it's spec that we can call !eigenstates?

[19:30] *** NorwayGeek joined
[19:30] <moritz_> Su-Shee: the components of a junction

[19:30] <pmichaud> keep in mind that rakudo's implementation of eigenstates was based on a conjectural spec

[19:30] <pmichaud> (which has since changed)

[19:32] *** NorwayGeek left
[19:32] *** NorwayGeek joined
[19:34] *** NorwayGeek left
[19:35] *** NorwayGeek joined
[19:35] <colomon> moritz_: S32 containers

[19:35] <colomon> "Note this is a private method; you must arrange for yourself to be trusted by the junctions class in order to call it, which probably involves evil MONKEY_TYPING."

[19:36] *** icwiener_ left
[19:36] <colomon> So we need to test that we can do that.

[19:36] <colomon> (If you couldn't call it, what would be the point of putting it in the spec at all?)

[19:36] <pmichaud> there's still an ongoing debate as to whether !eigenstates should exist at all

[19:37] <pmichaud> (iirc)

[19:37] <pmichaud> at any rate, I wouldn't accept this particular piece of the specification as being "correct"

[19:37] <pmichaud> it's still a best guess

[19:37] <__ash__> eigenstates sounds funny, does the spec have anything for eigenclasses? 

[19:38] *** NorwayGeek left
[19:38] <moritz_> __ash__: it's from the quantum mechanics analogy

[19:38] *** NorwayGeek joined
[19:39] <moritz_> __ash__: where eigenstates are the only things you can measure without an error

[19:39] <__ash__> ah, didn't know it about that use of the word

[19:40] * Su-Shee waits for the digest version for us common folks.. 

[19:40] *** NorwayGeek left
[19:41] *** silug joined
[19:41] <moritz_> Su-Shee: read the Perl 6 articles in the iX, eigenstates are described there ;-)

[19:43] *** dalek left
[19:43] *** bigpresh_ left
[19:43] *** Exodist left
[19:43] *** cls_bsd left
[19:43] *** carlin_ joined
[19:43] *** PerlJam left
[19:43] *** elmex left
[19:43] *** constant left
[19:43] *** PacoLinux left
[19:43] *** Whiteknight left
[19:43] *** yves left
[19:43] *** cognominal left
[19:43] *** araujo left
[19:43] *** edenc left
[19:43] *** cls_bsd joined
[19:43] *** cj joined
[19:44] *** clkao left
[19:44] *** Guest91830 left
[19:44] *** Chillance left
[19:44] *** crazed left
[19:44] *** fridim_ left
[19:44] *** ejs left
[19:44] *** bpetering left
[19:44] *** nbrown left
[19:44] *** synth left
[19:44] *** avar left
[19:44] *** astrojp left
[19:44] *** frew left
[19:44] *** Eevee left
[19:44] *** gfldex left
[19:44] *** ascent_ left
[19:44] *** jsut|work left
[19:44] *** revdiablo left
[19:44] *** kcwu left
[19:44] *** baest left
[19:44] *** avuserow joined
[19:44] <jnthn> ...whoa...

[19:44] <Su-Shee> moritz_: we should have the ixes in the office.. 

[19:44] *** carlin_ left
[19:44] *** cls_bsd left
[19:44] *** cj left
[19:44] *** avuserow left
[19:44] *** PacoLinux joined
[19:44] <pmichaud> moritz_: btw, do you know of any way to get dalek to report commits from the rakudo/ng branch?

[19:44] *** nbrown joined
[19:45] *** jan joined
[19:46] *** presh_ joined
[19:46] *** akl joined
[19:47] <moritz_> pmichaud: ask Infinoid++, all we need is an RSS/atom feed

[19:47] <pmichaud> okay

[19:47] *** masak joined
[19:47] <moritz_> pmichaud: since github offers only RSS feeds per branch, they have to be added manually for each branch we want tracked

[19:48] *** elmex joined
[19:48] <pmichaud> phenny tell Infinoid  could you add the rakudo/ng branch commits to dalek?  url is http://github.com/feeds/rakudo/commits/rakudo/ng

[19:48] *** carlin joined
[19:48] <pmichaud> phenny: tell Infinoid  could you add the rakudo/ng branch commits to dalek?  url is http://github.com/feeds/rakudo/commits/rakudo/ng

[19:48] <phenny> pmichaud: I'll pass that on when Infinoid is around.

[19:48] <pmichaud> Infinoid: ^^^

[19:48] *** cls_bsd joined
[19:49] <pmichaud> phenny:  tell Infinoid  I think it only needs reporting to #perl6

[19:49] <phenny> pmichaud: I'll pass that on when Infinoid is around.

[19:50] *** quuxx left
[19:50] *** dj_goku joined
[19:50] *** quuxx joined
[19:50] *** Schwern joined
[19:52] *** Bucciarati joined
[19:53] *** jan is now known as Guest41472

[19:53] *** constant joined
[19:54] *** christine left
[19:54] *** christine joined
[19:54] <moritz_> pmichaud: is there anything I can do to help with the ng branch?

[19:55] <pmichaud> what sort of task would you be interested in working on ?

[19:55] <pmichaud> if you're wanting to play with grammars at all, perhaps port in the full <ws> rule?

[19:55] <pmichaud> right now it doesn't recognize pod comments

[19:55] *** astrojp joined
[19:56] <pmichaud> I also need to come up with an improved build environment for the ng branch

[19:57] <moritz_> wrt importing nqp?

[19:58] <pmichaud> yes

[19:58] <moritz_> shouldn't we wait for a decision from the parrot folks?

[19:58] <pmichaud> although there's a discussion currently going on about making nqp-rx available in core parrot

[19:58] <pmichaud> yeah

[19:58] <pmichaud> but I don't want to wait too long if it means people can't be working in the branch easily

[19:59] <moritz_> ok

[19:59] <pmichaud> anyway, the pod_comment rule would be a good candidate

[19:59] <moritz_> I'll take a look

[20:00] <pmichaud> it's probably also worth looking at the pod_comment rule that is currently in rakudo's master

[20:00] <pmichaud> even just getting embedded comments to work might be instructive :)

[20:01] <moritz_> is there a reason not to use :dba where STD.pm does?

[20:01] <pmichaud> nqp-rx doesn't support it yet

[20:01] <pmichaud> for now we just comment it out

[20:01] <moritz_> ok

[20:02] *** nihiliad left
[20:03] *** wlan left
[20:03] *** araujo joined
[20:05] *** wlan_ joined
[20:06] <masak> oh hai. I ran into a little problem... http://gist.github.com/223686

[20:06] <masak> oh wait. I see what it is.

[20:07] <masak> it's referencing very old paths.

[20:07] <masak> nvm. :)

[20:07] <jnthn> lol its masak

[20:07] <jnthn> :D

[20:07] <masak> \o/

[20:07] *** felipe joined
[20:07] <masak> I'm doing my first day of puni... of November blogging. :)

[20:07] <jnthn> masak: Will book flights for Riga tonight. :-)

[20:07] <jnthn> hehe

[20:07] <jnthn> I look forward to the next 29 days.

[20:08] <jnthn> masak++ # epic blogging

[20:09] <carlin> A new blog post each day will be good for testing zaslon ;-)

[20:09] <masak> if this weekend is any indication, I look forward to every day until April. :)

[20:09] <mberends> aye

[20:09] <masak> it seems wonders have become the norm.

[20:10] <__ash__> what is rakudo ng branch for? 

[20:10] <pmichaud> ...which might be saying something, given that our previous norm was considered wondrous also :)

[20:11] <pmichaud> __ash__: it's the rebuild-the-rakudo-world branch

[20:11] <masak> __ash__: porting Rakudo to nqp-rx.

[20:11] <moritz_> oh, Makefile FAIL

[20:11] <__ash__> thought so, i saw all of pmichaud's mailing list post about nqp-rx 

[20:11] <moritz_> touching grammar.pg and then typing make doesn't rebuild anything

[20:12] <pmichaud> moritz_: in ng?

[20:12] <moritz_> pmichaud: yes

[20:12] <pmichaud> moritz_: the new stuff is in src/Perl6

[20:12] *** arnsholt joined
[20:12] <pmichaud> i.e., src/Perl6/Grammar.pm

[20:12] <moritz_> oh

[20:12] <moritz_> ok

[20:12] <pmichaud> (yes, we really are rebuilding the entire rakudo universe :-)

[20:12] *** base_16 joined
[20:13] <pmichaud> for people that want to see a really cool grammar:  http://github.com/rakudo/rakudo/blob/ng/src/Perl6/Grammar.pm

[20:13] <pmichaud> it's almost like writing in Perl 6!  :)

[20:14] <pmichaud> well, except that jnthn++ has put a huge block of PIR in the second method :-)

[20:14] <masak> :)

[20:14] * masak likes the pir::method calls

[20:15] *** eternaleye left
[20:15] *** eternaleye joined
[20:15] <jnthn> pmichaud: Yes, but see the comment I put at the top of it to bait people who think it's ugly. ;-)

[20:15] <pmichaud> I saw that

[20:15] <pmichaud> I'm almost baited :)

[20:16] <mberends> not many other people could ever be baited that way ;)

[20:17] <masak> oh, I wouldn't say that... :)

[20:17] *** pmurias joined
[20:17] <pmurias> diakopter: ping

[20:17] <pmichaud> jnthn: have you done anything like !fixup_routine_type in the ng branch yet?

[20:18] <pmichaud> (looks like "no")

[20:19] <jnthn> pmichaud: no

[20:19] <jnthn> "masak bait"

[20:19] <jnthn> pmichaud: I'm still pondering...what to do...about that.

[20:19] <pmichaud> I'm going to add it, I need it for regexes

[20:19] <pmichaud> we can switch it up a bit later

[20:19] <jnthn> ok

[20:19] <masak> jnthn: who knows? it might work. that masak is a gullible fellow.

[20:20] <jnthn> masak: If gullibility gets people to tidy up my code, I'm all for it!

[20:20] <masak> not today, though. today I'll be making the November test suite look decent again.

[20:21] * jnthn tries to find the masak riga dates in backlo

[20:21] <jnthn> g

[20:21] *** BinGOs joined
[20:21] <pmichaud> oh, fixup_routine_type gets into the question of "do we want our own custom Code objects"?

[20:21] <masak> jnthn: 19th - 23rd

[20:21] <pmichaud> hmmmmmmm

[20:22] <jnthn> pmichaud: Yes, that's why I was still pondering. :-)

[20:22] <jnthn> pmichaud: You mean "do we subclass sub"?

[20:23] <pmichaud> yeah, something like that

[20:23] <pmichaud> or do we create a Code object that has the parrot sub as a 'do' property

[20:23] <jnthn> pmichaud: oh

[20:23] <pmichaud> (and then subclass our other types from that)

[20:23] <jnthn> pmichaud: You know, I like the second of those...

[20:23] <jnthn> ...if it won't hit performance too horribly.

[20:23] <pmichaud> the do property?

[20:24] <jnthn> (it shouldn't)

[20:24] <jnthn> pmichaud: yes

[20:24] *** awwaiid joined
[20:24] <pmichaud> I think it shouldn't

[20:24] <jnthn> pmichaud: Same, especially as invoke goes looking for a proxy now anyway.

[20:24] <jnthn> pmichaud: In fact, it may get cheaper.

[20:24] <pmichaud> exactly

[20:24] <pmichaud> and closer to spec

[20:24] <jnthn> pmichaud: oh heh

[20:24] <jnthn> oh, wait...no

[20:24] <jnthn> :-)

[20:25] <pmichaud> argggh, no fair using my own tricks against me :)

[20:25] <jnthn> masak: Aww! AirBaltic in the future will fly from Blava to Riga direct. But not yet.

[20:25] <masak> jnthn: :/

[20:25] <pmichaud> jnthn: I had that happen last year... Southwest Airlines started flying to Minneapolis... 3 weeks after Frozen Perl.

[20:26] * pmichaud wonders if he's been overlooking any conference invitations in his inbox 

[20:26] <jnthn> masak: It's fine, Vienna airport isn't exactly hard for me to get to. ;-)

[20:26] <jnthn> What with the airport bus leaving < 10 minutes walk from my door.

[20:26] <masak> :)

[20:27] *** allbery_b joined
[20:27] <jnthn> I just hadn't seen Bratislava on AirBaltic's list before and got all excited.

[20:27] <pmichaud> jnthn: so, should I go with our old fixup_routine_type approach for now, or should we look at fixing up the Code object?

[20:27] <jnthn> Riga is AirBaltic's hub, which actually means I'll probably win a whole bunch of connecting flights...

[20:27] <jnthn> pmichaud: Let's do the code objects.

[20:27] <jnthn> pmichaud: After all, the way we're creating routines now makes that easy to shove in, no?

[20:28] <pmichaud> let me review what the synopses say about it, but I'll go with whatever you like better

[20:28] <jnthn> .oO( damm, I just volunteered )

[20:28] <jnthn> OK.

[20:28] <jnthn> I'm doing $flight at the moment anyway.

[20:28] <jnthn> And then roles.

[20:28] <jnthn> (enough for you to make 'em from PIR)

[20:29] *** desertm4x left
[20:29] <moritz_> I can't even find the token ws definition in src/Perl6/Grammar.pm

[20:29] <moritz_> is the default from nqp-rx used?

[20:29] <jnthn> masak: So I@m getting

[20:29] <pmichaud> moritz_: it's inheriting one from HLL::Grammar

[20:29] <jnthn> Th 19/11  14:25 Vienna  17:25 Riga

[20:29] <jnthn> Mo 23/11  11:55 Riga  12:55 Vienna

[20:29] <pmichaud> jnthn: the note about do properties is S06:2456

[20:29] <pmichaud> (it's mentioned other places in S06 as well)

[20:30] <pmichaud> I'll skip regexes for now, then

[20:30] <masak> jnthn: we'll be landing on the same time, exactly!

[20:30] <jnthn> pmichaud: Heh, I'd noticed that before and wondered how on earth we'd do that. :-)

[20:30] <jnthn> masak: oh wow

[20:30] <jnthn> masak: in that case, I hope on separate runways ;-)

[20:30] <masak> jnthn: also, my aircraft is a "Fokker 50"

[20:30] <moritz_> Fokker 50. Wow.

[20:30] <masak> doesn't sound too good, actually.

[20:30] <jnthn> "lol where's masak...oh...i can see the fokker"

[20:31] <jnthn> ;-

[20:31] <masak> does the pilot go "oh, fokk!" in mid-air?

[20:31] *** nihiliad joined
[20:31] <Su-Shee> I forbid you to fly. you all take the train. I want a finished Rakudo. 

[20:32] <moritz_> lol

[20:32] <masak> Su-Shee: it's "bus number", not "fokker number" :)

[20:32] <Su-Shee> masak: now it is. ;)

[20:32] <masak> dang. :)

[20:32] <Su-Shee> masak: and YOU can swim anyway! ;)

[20:32] *** pmurias_ joined
[20:32] *** pmurias_ left
[20:32] <masak> Su-Shee: you got me. I'm lazy. :P

[20:32] <jnthn> Su-Shee: There's a slight problem with building a train line between Riga and Stockholm ;-)

[20:33] <Su-Shee> jnthn: I already opted for masak swimming. he may take some boat, ok. ;)

[20:33] <jnthn> Su-Shee: Annoyingly, while I could go by train...

[20:33] <Su-Shee> actually - masak, can't you really go by ferry?

[20:33] <masak> Su-Shee: too late. already booked flight tickets.

[20:33] <masak> they were very comparable in price, and I like flying.

[20:34] <Su-Shee> a well. will end up in the water anyway.. ;)

[20:34] <Su-Shee> who doesn't.. european train connections are just sad with the short ways.. 

[20:35] <jnthn> Su-Shee: The train would take me 33 hours, just looking it up.

[20:35] <jnthn> Su-Shee: And involve 4 changes.

[20:35] <masak> bring "War and Peace".

[20:35] <jnthn> And also is scheduled brilliantly so I get to spend much of a night on Daugavpils platform...

[20:36] <jnthn> masak: That woulda been more fitting for the Trans-Sib.

[20:36] <jnthn> ;-)

[20:36] <masak> oh, indeed.

[20:36] * jnthn wonders whether he really needs more than just hand baggage

[20:37] <jnthn> hmm, borderline.

[20:37] <masak> I thought the same.

[20:37] <masak> in the end I opted for 1 luggage.

[20:37] <masak> you never know.

[20:38] <Su-Shee> ROTFL.. ok - berlin - riga is something like 850km and it takes 35 hours by train.. un-be-lie-va-ble.

[20:38] <jnthn> Su-Shee: Yeah. It's ridiculous as soon as you hit Poland and head north from there.

[20:38] <Su-Shee> you can go by bike :)

[20:38] <moritz_> and W√ºrzburg - Braunschweig is 350km and takes 2hrs or so

[20:39] *** tak11 left
[20:39] <Su-Shee> instead of crappy transrapids they should have connected all european capitals with a tgv/shinkanzen long ago..

[20:39] <jnthn> Su-Shee: I could also walk. It'd take 10 days.

[20:40] <jnthn> (according to google, assuming I skip sleep)

[20:40] <Su-Shee> jnthn: how did you google it?

[20:40] <pmurias> sleep is for the weak ;)

[20:42] <jnthn> oh hey, if I walk through Poland I can visit pmichaud

[20:42] <jnthn> erm

[20:42] <jnthn> pmurias: 

[20:42] <jnthn> :-)

[20:42] <jnthn> tab completion fail, not geography fail ;-)

[20:42] <jnthn> Su-Shee: maps.google.com

[20:42] <Su-Shee> jnthn: yeah, but what did you assume you walk per day?

[20:43] <Su-Shee> *hihi* perl 6 pilgrimage - walk with us from the south to the north.. and we can fetch everybody on the way. ;)

[20:43] <jnthn> Su-Shee: oh, 10 days was non-stop

[20:47] <moritz_> STD.pm has rules like token comment:sym<#> { '#' {} \N*

[20:47] <moritz_> }

[20:47] <moritz_> what's the {} for?

[20:48] <jnthn> LTM screw-up protection

[20:48] <jnthn> Or something.

[20:48] *** nihiliad left
[20:48] *** NorwayGeek joined
[20:48] <jnthn> pm can explain it better than that though ;-)

[20:48] <moritz_> so I'd write that '#' :: \N* in nqp?

[20:49] <jnthn> moritz_: pm told me to skip the {} for now

[20:49] <moritz_> ok

[20:49] <jnthn> masak: flight booked!

[20:49] <jnthn> masak: I get a Boeing WITH WINGLETS

[20:49] <masak> \o/

[20:49] <masak> wow, winglets!

[20:49] <jnthn> Yeah

[20:49] <jnthn> You'll be lucky if yours even has wings. ;-)

[20:50] <masak> oh fokk...

[20:50] <Su-Shee> do winglets work as well as applets in the web in the 90ties? ;)

[20:50] <jnthn> :-)

[20:50] <jnthn> masak: eh well, I guess now we can go and get lost together on the way to some hotel somewhere, rather than alone... :-)

[20:51] * jnthn akshually not that bad at finding places, if given a decent map

[20:51] <Su-Shee> one with a fokker, one with winglets.. I see you both swimming.. ;)

[20:54] *** Exodist joined
[20:54] *** nihiliad joined
[20:55] <masak> jnthn: did I tell about how I got lost last weekend already?

[20:55] <masak> I'm *very* good at doing that.

[20:56] <jnthn> Su-Shee: Ah well, at least it's two Perl programmers, not 3 French cats...

[20:56] <jnthn> masak: OK, I print off a very good map! :-)

[20:56] <masak> excellent.

[20:56] <masak> hm, I might have bought bus tickets from the Airport into town...

[20:57] <jnthn> oh, I might not have...

[20:57] <jnthn> d'oh

[20:57] <masak> :/

[20:57] <jnthn> oh well, I'm sure they sell them at the airport ;-)

[20:58] <jnthn> oh, can buy them on the bus, but only in cash, and only lats at that

[20:58] <jnthn> masak: found the form to buy them online.

[20:58] <jnthn> (separate from flight)

[20:58] <masak> the email from Andrew said they could also be bought on the plane.

[20:58] <jnthn> doing that, it'll save some hassle.

[20:59] <jnthn> Hmm...you can pay in LVL or LTL as well as EUR. Too bad I can't pay in LOL...

[20:59] <masak> ÂìàÂìà

[21:02] *** colomon joined
[21:02] <jnthn> masak: OK, I haz a bus ticket both ways now too. :-)

[21:02] <jnthn> masak: I guess that just means I need to submit talks.

[21:02] <jnthn> Well, 1 or 2...

[21:02] <masak> oh, thanks for reminding! I'll do that also.

[21:02] <masak> I have one talk.

[21:03] <masak> since it's only one day. :)

[21:03] <jnthn> yeah

[21:03] <jnthn> maybe I should have just one, not sure

[21:03] <jnthn> What you going to speak on, btw? Web.pm?

[21:03] <jnthn> Cheese?

[21:03] <jnthn> November?

[21:03] <moritz_> nqp: token foo_bar { 3 }

[21:03] <p6eval> nqp:  ( no output )

[21:04] <moritz_> nqp: token pod_comment { }

[21:04] <p6eval> nqp:  ( no output )

[21:04] <moritz_> nqp: token pod_comment { ^^ \h* }

[21:04] <p6eval> nqp:  ( no output )

[21:04] <masak> jnthn: I'm not telling. you have to wait like everyone else.

[21:05] <masak> :)

[21:05] <moritz_> nqp: token pod_comment { ^^ \h*  '=' <.unsp>? 'being' }

[21:05] <p6eval> nqp:  ( no output )

[21:05] <jnthn> masak: :-P

[21:05] <jnthn> masak: I'm pondering giving the "Solved in Perl 6" again...

[21:05] <masak> \o/

[21:05] <jnthn> It tends to go down well.

[21:05] <jnthn> I may submit a lightning talk on lolsql.

[21:05] <masak> that's a great idea.

[21:05] <masak> I should consider a lightning talk as well.

[21:06] <jnthn> "The funniest 5 Rakudo bugs I've filed"

[21:06] *** tak11 joined
[21:06] *** nihiliad left
[21:07] <masak> heh. :)

[21:07] <masak> it would be fun to have Druid in such a state that it could be lightning-talk'd.

[21:07] <jnthn> Heh, we could play each other online, amidst the segvs. ;-)

[21:07] <masak> aye. :)

[21:08] <masak> having the web app respawn automatically each time.

[21:08] *** quuxx left
[21:08] <carlin> You had to say segv didn't you? :-P

[21:09] *** __ash__ left
[21:09] *** quuxx joined
[21:09] <carlin> I hope that's magically fixed in zaslon but I doubt it ...

[21:09] <jnthn> quuxx: segv

[21:10] <jnthn> ...nah, we're innocent. :-)

[21:10] <jnthn> carlin: Any chance of a bt?

[21:10] *** Su-Shee left
[21:11] <carlin> Yes, actually. I did one from a segv last night.

[21:12] <carlin> http://gist.github.com/223728

[21:14] * jnthn updates his ACT photo with a more wintery image

[21:17] <jnthn> lolsql abstract is win!

[21:19] <jnthn> carlin: Heh, line 224 has *so* much that could be wrong! ;-)

[21:19] *** payload joined
[21:19] <jnthn> An opening curly is such a place to segfault.

[21:21] *** __ash__ joined
[21:21] <pmichaud> back from lunch

[21:22] <jnthn> pmichaud: Well, I committed nothing, but I did book a flight and submit some talks... :-)

[21:22] <carlin> jnthn: well, if you deleted it the segv wouldn't happen anymore ...

[21:22] <jnthn> carlin: Of course not!

[21:22] <jnthn> carlin: Only 'cus we fail to compile 'cus of unbalanced curlies though.

[21:22] <jnthn> ;-)

[21:22] <jnthn> pmichaud: srsly going to work on roles now :-)

[21:22] *** avuserow joined
[21:23] <pmichaud> jnthn: +1

[21:23] *** quuxx left
[21:23] *** quuxx joined
[21:24] <pmichaud> I vote to remove 06-use.t -- it's not testing anything helpful for Test.pm .

[21:25] <pmichaud> I vote to remove 07-binding.t -- Test.pm doesn't use the binding operator

[21:26] <jnthn> pmichaud: kill kill kill

[21:26] <jnthn> pmichaud: S09-types is also perhaps a candidate.

[21:26] <pmichaud> I vote to change Test.pm to used .defined instead of defined ()

[21:26] <pmichaud> and change 07-defined.t accordingly

[21:26] <jnthn> What is this, a democracy?

[21:26] <jnthn> ;-)

[21:26] <pmichaud> it's a chance for people to register objections

[21:26] <moritz_> note that in Auld Rakudo .defined would sometimes give Null PMC Access

[21:26] <moritz_> where defined() would work

[21:27] <jnthn> Ouch!

[21:27] <jnthn> That's...so wrong.

[21:27] <moritz_> it is.

[21:27] <jnthn> masak: lol my talk already is approved

[21:27] <masak> wow, that's fast!

[21:27] <jnthn> masak: the Perl 6 one.

[21:28] <jnthn> masak: Poor Andrew is still probably scratching his head wondering what on earth language I wrote the lolsql abstract in.

[21:28] <masak> :)

[21:28] <jnthn> pmichaud: No objects on my part to any of them.

[21:28] <jnthn> oh, approved anyway ;-)

[21:29] *** nihiliad joined
[21:29] <moritz_> nqp: regex foo { 'a' { say 'bar' } }

[21:29] <p6eval> nqp: OUTPUT¬´Unable to parse blockoid, couldn't find final '}' at line 1‚ê§current instr.: 'parrot;Regex;Cursor;FAILGOAL' pc 1616 (src/Regex/Cursor-builtins.pir:179)‚ê§¬ª

[21:29] <moritz_> how are assertions handled in nqp-rx?

[21:30] <jnthn> <?{ ... }>

[21:30] <jnthn> moritz_: see typename for an example

[21:31] <moritz_> nqp: regex foo { 'a' <?{ say 'bar' }> }

[21:31] <p6eval> nqp: OUTPUT¬´Unable to parse blockoid, couldn't find final '}' at line 1‚ê§current instr.: 'parrot;Regex;Cursor;FAILGOAL' pc 1616 (src/Regex/Cursor-builtins.pir:179)‚ê§¬ª

[21:31] <moritz_> nqp: regex foo { 'a' <?{ say('bar') }> }

[21:31] <p6eval> nqp:  ( no output )

[21:31] <moritz_> ah, much better

[21:31] <jnthn> :-)

[21:31] <masak> Test::is has no responsibility to return Bool::True if it succeeds, right?

[21:31] <masak> I have a test here that seemed to assume that.

[21:32] <moritz_> IMHO it should

[21:32] <moritz_> as hould all testing functions

[21:32] <masak> moritz_: it currently doesn't.

[21:32] <moritz_> masak: patches welcome ;-)

[21:32] <masak> sure, some other day. :)

[21:32] <masak> I'm racing towards fixing November today.

[21:33] <moritz_> you better should, since it's already November for more than 20 hours ;-)

[21:33] <masak> you can see why I'm a bit busy right now :P

[21:34] <jnthn> pmichaud: How do you feel about having a directory for PIR-y bits that are not actually built-ins per say, but more helpers for doing guts-y things?

[21:34] <pmichaud> jnthn: propose a name?

[21:34] <jnthn> guts ;-)

[21:34] <moritz_> guts-y.pir ;-)

[21:34] <jnthn> pmichaud: I'm just thinking we can try and keep builtins to stuff that's directly related to types and living in namespaces.

[21:35] <jnthn> pmichaud: And pull out things like, the helpers for constructing roles, dispatch helper bits, etc.

[21:35] <jnthn> Just feel it may be nicer than cluttering up builtins with them.

[21:36] <jnthn> I actually don't have a better name than "guts" :-/

[21:36] <jnthn> helpers?

[21:36] <pmichaud> yeah, I'm trying to come up with one also

[21:36] <pmichaud> helpers

[21:36] <pmichaud> internals

[21:36] <jnthn> evil

[21:36] *** payload1 joined
[21:36] *** payload left
[21:36] <pmichaud> magic

[21:36] <jnthn> ignorethis

[21:36] <jnthn> dragons

[21:36] <pmichaud> readme  # make sure nobody ever looks at them

[21:36] <jnthn> ok, win.

[21:37] <pmichaud> glue

[21:37] <jnthn> ooh, not bad.

[21:37] *** base_16 left
[21:37] <jnthn> OK, glue it is for now.

[21:37] <jnthn> We can easy enough rename later.

[21:38] <pmichaud> shims

[21:39] <pmichaud> glue is fine

[21:39] <pmichaud> we can change it later

[21:39] <pmichaud> I was a little partial to "magic"  :-)

[21:39] <moritz_> nqp: grammar A { token TOP { ^ a <?{ pir::say('foo') }> } }; A.parse('a');

[21:39] <p6eval> nqp: OUTPUT¬´foo‚ê§Null PMC access in get_bool()‚ê§current instr.: 'parrot;A;TOP' pc 73 (EVAL_1:35)‚ê§¬ª

[21:39] <jnthn> pmichaud: Yeah, I like that too.

[21:39] <moritz_> is that known/intended

[21:39] <moritz_> ?

[21:40] <pmichaud> not known, not intended, but not necessarily wrong

[21:40] <pmichaud> pir::say doesn't return a value

[21:40] <pmichaud> thus the Null PMC

[21:40] <moritz_> ok

[21:40] <moritz_> thought it returned 0/1 or true/false just like the perl 5 and perl 6 one

[21:40] <pmichaud> nope

[21:40] <pmichaud> returns void

[21:40] <moritz_> ok

[21:41] <pmichaud> nqp:  grammar A { token TOP { ^ a <?{ pir::say('foo'); 1; }> } };  A.parse('a')

[21:41] <p6eval> nqp: OUTPUT¬´foo‚ê§¬ª

[21:41] <moritz_> that's what I used now, yes

[21:42] <pmichaud> I not sure what to do with the case w/o the 1

[21:42] <pmichaud> of course, easier is just a plain closure, no <?

[21:42] <pmichaud> nqp:  grammar A { token TOP { ^ a { pir::say('foo'); } } };  A.parse('a')

[21:42] <p6eval> nqp: OUTPUT¬´foo‚ê§¬ª

[21:43] <pmichaud> note that there's also a <?DEBUG> rule

[21:43] <pmichaud> turns on tracing

[21:44] <pmichaud> nqp:  grammar A { token TOP { <?DEBUG> <abc> <def> }; token abc { abc <def> };  token def { def }; };  A.parse('abcdefdef');

[21:44] <p6eval> nqp: OUTPUT¬´0/1: START abc‚ê§3/1: START def‚ê§3/1: PASS  def at pos=6‚ê§0/1: PASS  abc at pos=6‚ê§6/1: START def‚ê§6/1: PASS  def at pos=9‚ê§0/1: PASS  TOP at pos=9‚ê§¬ª

[21:44] <moritz_> how can .*? every match anything in a token?

[21:44] <moritz_> s/every/ever/

[21:44] <pmichaud> because it has an explicit backtracking qualifier

[21:44] <moritz_> ah

[21:44] <pmichaud> (the ?)

[21:45] <pmichaud> however:     [.*?]   in a token will not match anything

[21:45] <pmichaud> nor will (.*?)

[21:45] <moritz_> ok

[21:48] <pmichaud> the <?DEBUG> rule applies only to the current match (and subrule matches) -- once leaving the rule that declares <?DEBUG> tracing is automatically turned off.  (I.e., it's contextual)

[21:49] *** justatheory left
[21:50] <pmichaud> okay, I'll keep defined()  but I'm removing undefine() -- Test.pm doesn't need it

[21:52] *** Whiteknight joined
[21:52] *** nihiliad1 joined
[21:53] *** nihiliad left
[21:56] *** xenoterracide left
[21:58] *** xenoterracide joined
[22:01] *** pnate joined
[22:01] <spinclad> (backlogged four hours, don't know if the world has changed again...) re  ::T  vs  ** '::'  , isn't leading  ::  (as in ::T) a sigil?  then <identifier> ** '::' should be right.

[22:01] <jnthn> spinclad: <identifier> ** '::' doesn't match a leading ::

[22:02] <jnthn> spinclad: But yes, ::T is for that.

[22:02] <jnthn> spinclad: <identifier> ** '::' matches identifiers with :: between them.

[22:02] *** xenoterracide left
[22:02] <spinclad> right

[22:03] <jnthn> But we need <name> to match ::T.

[22:04] <spinclad> so the sigil should be considered in an outer layer:  <innername> = <id> ** '::', <name> = <sigil><twigil><innername> or something

[22:04] *** xenoterracide joined
[22:05] <jnthn> Well, if :: is really a sigil in the same sense as the others anyway...

[22:05] <jnthn> STD treats it differently though.

[22:07] *** xenoterracide_ joined
[22:09] <quuxx> masak++ blogged "November 1 2009 -- a somewhat shaky start": http://use.perl.org/~masak/journal/39826?from=rss

[22:09] <masak> shaky, but fun! \o/

[22:10] <masak> (ask me again by the end of the month, though)

[22:13] *** pnate2 left
[22:14] *** pnate2 joined
[22:15] <jnthn> masak++ # nice post :-)

[22:15] <masak> thanks.

[22:15] <moritz_> maybe quuxx should say 'lolmasakblogged' or so ;-)

[22:16] <masak> I think that'd be very appropriate.

[22:16] *** quietfanatic joined
[22:17] <moritz_> I managed to write a rule that successfully matches a Pod comment

[22:17] <moritz_> 28/7: PASS  pod_comment at pos=60

[22:18] <moritz_> but still rakudo says Confused, quoting the line before the Pod comment

[22:19] <masak> that's confusing.

[22:21] <masak> time to sleep. see y'all tomorrow. o/

[22:21] <lisppaste3> moritz_ pasted "ws rule with POD comments kinda not-working" at http://paste.lisp.org/display/89655

[22:21] *** masak left
[22:21] <moritz_> good night

[22:24] *** xenoterracide left
[22:25] <moritz_> rakudo: sub jv(Object $j) { my @e; (-> Any $x { @e.push: $x }).($j); ~@e.sort }; jv(3|5|2)

[22:25] <p6eval> rakudo d154eb:  ( no output )

[22:25] <moritz_> rakudo: sub jv(Object $j) { my @e; (-> Any $x { @e.push: $x }).($j); ~@e.sort }; say jv(3|5|2)

[22:25] <p6eval> rakudo d154eb: OUTPUT¬´2 3 5‚ê§¬ª

[22:25] <jnthn> pmichaud: I'm getting a tad bogged down figuring out exactly how I want this roles stuff to really look in the end, so decided to just do something that works for now.

[22:25] *** xenoterracide_ left
[22:26] <jnthn> e.g. enough for what you need at the moment.

[22:26] <jnthn> And encapsulated enough that should be fine for the future.

[22:26] <pmichaud> jnthn: wfm

[22:26] <pmichaud> I don't mind if it changes in the future.

[22:27] <jnthn> pmichaud: I'm still thinking about how I want a few things to look overall.

[22:27] <jnthn> But not quite hit on a magic answer yet.

[22:27] <jnthn> Or at least, a sufficiently likable one.

[22:27] *** pnate left
[22:27] <jnthn> Probably it'll come when I get class and role decls back in place again.

[22:28] *** xenoterracide joined
[22:29] *** __ash__ left
[22:31] <moritz_> rakudo: say (3|4|5).pick

[22:31] <p6eval> rakudo d154eb: OUTPUT¬´any(3, 4, 5)‚ê§¬ª

[22:31] <jnthn> ...huh?

[22:32] * jnthn thought .pick was defined on junctions.

[22:32] <sjohnson> pakudo

[22:32] <sjohnson> oops

[22:32] <sjohnson> rakudo:  say (3|4|5).WHAT

[22:32] <p6eval> rakudo d154eb: OUTPUT¬´Junction()‚ê§¬ª

[22:35] <pmichaud> jnthn: I'm going to go ahead and model Code similar to the way we do it in master, but feel free to rip it out when you come up with the new model

[22:35] <pmichaud> I'm not going to have a bunch in there

[22:35] <pmichaud> just enough to keep moving forward

[22:36] <pmichaud> oh, I have something else to work on first

[22:37] <jnthn> pmichaud: OK

[22:38] *** __ash__ joined
[22:40] *** icwiener joined
[22:41] <pmichaud> oops.  Test.pm requires type-based multi subs.

[22:41] <pmichaud> I'll fix that.

[22:42] *** pnate2 left
[22:42] <jnthn> pmichaud: Those should already work.

[22:42] <jnthn> pmichaud: Just that you need to add the types. ;-)

[22:42] <pmichaud> yeah, but it's depending on Whatever

[22:42] <jnthn> oh.

[22:42] <pmichaud> I'm not sure I want to add that yet.

[22:42] <jnthn> Whatever you want. :-)

[22:43] <moritz_> seems like fudge doesn't like overlapping todo/skip directives ;-)

[22:44] <jnthn> .oO( toskip )

[22:45] <sjohnson> jnthn: did you know windows has a grep command?

[22:45] <jnthn> pmichaud: oooh, I think I may have something that works enough for you. :-)

[22:46] <jnthn> sjohnson: not a built-in one, no...

[22:46] <sjohnson> jnthn: findstr

[22:46] <sjohnson> try it :)

[22:46] <sjohnson> it's been in windows since before XP was out

[22:47] <sjohnson> i went many years without knowing about findstr :(

[22:47] <pugs_svn> r28972 | moritz++ | [t/spec] clean up some junction testing mess 

[22:47] <pugs_svn> r28972 | 

[22:47] <pugs_svn> r28972 | since eigenstates are now private, it's WRONG to rely on them heavily, even if

[22:47] <pugs_svn> r28972 | we may later on obtain a way to ask for them via monkey typing.

[22:47] <pugs_svn> r28972 | 

[22:47] <pugs_svn> r28972 | Also adds some rakudo skips. Needs more cleanups.

[22:48] <jnthn> sjohnson: wow

[22:49] <jnthn> pmichaud: pushed

[22:50] <jnthn> pmichaud: So basically, I added Positional but tweaked the way we make the role a bit.

[22:50] <jnthn> pmichaud: And I showed how you get hold of something to compose into List

[22:50] <jnthn> But stopped short of actually composing it in (will let you do that in your own time/readiness).

[22:51] <pmichaud> okay, great

[22:51] <pmichaud> that should work well for me

[22:52] <jnthn> In next couple of days I'll put back class and role decls.

[22:55] <jnthn> I'll need to be a tad more awake for that, though. :-)

[22:55] <pmichaud> np.  I have plenty to work on, and I need to write some reports as well as code :)

[22:55] * pmichaud adds trait parsing

[22:55] <jnthn> yes, I plan to blog a bit now.

[22:55] <jnthn> pmichaud: just parsing?

[22:55] <pmichaud> just parsing

[22:55] <jnthn> kk

[22:56] <pmichaud> to get us past the "is export(:DEFAULT)"  traits in Test.pm

[22:56] <jnthn> ah, fine.

[22:56] <jnthn> They'll probably have to follow fairly soon after class decls.

[22:56] <pmichaud> wfm

[22:56] <jnthn> Otherwise we can't do inheritance. :-)

[22:56] <pmichaud> I think I'll count lazy lists as my Rakudo Day :)

[22:56] <jnthn> ooh, good plan.

[22:57] <jnthn> Since they really are extra.

[22:57] *** iblechbot left
[22:57] <jnthn> To the grammar re-orgs. :-)

[22:57] <jnthn> I wasn't expecting those at all.

[22:57] <pmichaud> I wasn't either, but given the discussion yesterday, and the fact that I was already redoing STORE and FETCH for rw semantics, it seemed like a good time :)

[22:57] <pmichaud> we now make it to line 85 of Test.pm

[22:58] <pmichaud> oh.  rat parsing

[22:58] <pmichaud> actually non-integer parsing

[22:58] <jnthn> aww

[22:58] <pmichaud> can't call it "float", because they aren't "floats" any longer :-)

[22:58] <jnthn> May have to fake rats for now...givne the whole impl is setting.

[22:58] <pmichaud> 0.0001

[22:58] <pmichaud> lol

[22:59] <pmichaud> I can do   1/10000

[22:59] <pmichaud> instead of 0.00001

[22:59] <jnthn> heh

[22:59] <jnthn> :)

[23:00] <pmichaud> now we get to line 129

[23:00] <jnthn> Well, there's parsing it and there's running it. :-)

[23:00] <pmichaud> It doesn't recognize Callable as a typename

[23:00] <pmichaud> hmmmm.

[23:00] <jnthn> Oh

[23:00] <jnthn> We didn't pull that back in yet I guess.

[23:01] <pmichaud> well, Callable is really a Role.

[23:01] <jnthn> In master too.

[23:01] <pmichaud> is the role stuff far enough along that I could create Callable?  ;-)

[23:01] <pmichaud> (even if it's just a placeholder)

[23:02] <pmichaud> oh, but in order to for it to run, our code objects would actually have to be "does Callable"

[23:02] <jnthn> yeah, true

[23:02] <jnthn> well, just change Callable $foo to &foo

[23:02] <pmichaud> (this is one reason why I've not been a fan of type constraints in Test.pm)

[23:03] <pmichaud> I might just eliminate or comment out the constraint

[23:03] <moritz_> note that &foo has a long history of not working properly as a type constraint in rakudo

[23:03] <pmichaud> it's okay... the constraint is actually not useful in Test.pm

[23:03] *** samlh joined
[23:04] <pmichaud> or, if the constraint is important, it would be better to use .isa instead of relying on having a sophisticated enough dispatcher to do it

[23:04] *** __ash__ left
[23:04] <pmichaud> eliminating Callable gets us to line 133

[23:05] <moritz_> I think the importance in lives_ok and dies_ok is to detect when the user is stupid enough to confused it with the eval_lives_ok variant and pass a string ;-)

[23:05] <pmichaud> sure, in which case use .isa and give a useful error :-)

[23:05] <jnthn> heh, it's not that we don't have a sophisticated enough dispatcher, just that we don't have a sophisticated enough type hierarchy ;-)

[23:05] <pmichaud> jnthn: I'm thinking for implementations that may come after us

[23:05] <pmichaud> or if we port to somewhere else

[23:06] <pmichaud> ugh, the Null PMC checks require regexes to run

[23:06] <pmichaud> that's the only part of Test.pm that needs regexes....

[23:06] <moritz_> comment it out for now

[23:06] <jnthn> pmichaud: Just pulled Callable back in now.

[23:06] <pmichaud> okay, excellent

[23:06] <jnthn> We'll need Code objects to do it anyway.

[23:06] <pmichaud> that will give me a(nother) template for seeing how roles are set up

[23:07] <pmichaud> commenting out the regexes gets to line 190

[23:08] <pmichaud> ...  &infix:<Z> ?~?~

[23:08] <pmichaud> ?!?!?!?

[23:08] <lambdabot> Unknown command, try @list

[23:08] <pmichaud> geezum

[23:08] <pmichaud> I'll parse it but not run it.

[23:11] <jnthn> Callable pushed.

[23:14] <pmichaud> pulled, merged

[23:14] *** tak11 left
[23:14] <jnthn> If you don't beat me to the code thingy, I'll do it tomorrow.

[23:14] <jnthn> It shouldn't be hard, but I'm getting to the point where I'm liable to foo stuff up.

[23:14] <jnthn> (e.g. tiredish)

[23:14] <pmichaud> I'm not sure if I'll get to the code thingy tonight.  I might, but more useful is to see if I can get Test.pm running.

[23:15] <pmichaud> that will require END blocks and use, at minimum

[23:15] <pmichaud> that's likely enough for a night

[23:15] <pmichaud> (plus reports)

[23:15] <jnthn> Running Test.pm again in 3 days of hacking on this would be great progress either way.

[23:15] <jnthn> Especially since we know that in many areas we're *not* cheating.

[23:15] <pmichaud> yes

[23:16] <pmichaud> but I can also work on Mapping/Hash, Range, etc.

[23:16] <pmichaud> so there's a lot that can be done even w/o code

[23:16] <pmichaud> and with the role stuff you added, I can clean up Failure

[23:16] <jnthn> OK, if you want me to do that bit, that's fine.

[23:16] <pmichaud> and I might be able to fix Nil

[23:16] <pmichaud> so I'll leave Code for you until I hurt for it :)

[23:16] <jnthn> I'll try and do it before you hurt. :-)

[23:17] <pmichaud> we also need to be able to parse single-word typenames  (e.g. Int)  -- I can undoubtedly do that

[23:17] <jnthn> Oh, I nearly put that back in earlier.

[23:17] <jnthn> Yes, just call the assertion check.

[23:17] <jnthn> See old grammar.pg for how it influences the code gen, if you're unsure.

[23:17] <pmichaud> oh, it's no problem

[23:17] <pmichaud> I just have to prevent typenames from being treated as listops

[23:17] <pmichaud> that's purely in the grammar

[23:17] <jnthn> Right.

[23:17] <pmichaud> <!is_type(...)>

[23:18] <jnthn> STD has it like that?

[23:18] <jnthn> oddness.

[23:18] <pmichaud> pretty close

[23:18] <jnthn> But does it eventually call $c.is_name($the_name) ?

[23:18] <pmichaud> that's what <!is_name($the_name)>  means :-)

[23:18] <pmichaud> subrules are  $c.subrule()

[23:19] <jnthn> oh, cute.

[23:19] <jnthn> And yes, makes sense. :-)

[23:19] <pmichaud> phrased more directly,     <xyz>   is basically like    { $<xyz> = $c.xyz; }

[23:19] <pmichaud> with a few other things in place for quantified captures, etc.

[23:20] <pmichaud> actually, I guess more like   <?{ $<xyz> = $c.xyz; }>

[23:20] <jnthn> nod

[23:20] <pmichaud> anyway

[23:20] <pmichaud> subrules are just methods on the cursor

[23:20] <jnthn> $c.foo is equivalent to $/.CURSOR.foo?

[23:20] <pmichaud> and unlike PGE, which had to take an argument and slurpy hash for each subrule, the new engine doesn't need any params :-)

[23:21] <pmichaud> it's more accurate to say that  $/ is $c.MATCH

[23:21] <pmichaud> the cursor contains the match object, not vice-versa

[23:21] <jnthn> ok

[23:21] <pmichaud> .CURSOR is just an easy way to get back to the cursor from the match object

[23:22] <pmichaud> (in STD.pm, the Cursor _is_ the Match object, but there are a few problems with that approach that I think are better solved by having them separate.  Such as the difficulty in having a rule named "from", "to", "orig", etc.)

[23:22] <jnthn> I think I may have used .CURSOR once 'cus it's quicker to type than working out how to do the cent symbol. <embarrassed look>

[23:22] <pmichaud> in the new engine it will eventually be the case that avoiding the $/ match object will be more efficient

[23:22] <jnthn> Ah, OK.

[23:23] <pmichaud> match objects are generated lazily now, so if you ask for one you incur the cost of creating it

[23:23] <pmichaud> (if you're just about to return a match it doesn't make much of a difference, but if you're doing lots of backtracking you'll be generating them unnecessarily)

[23:23] <jnthn> Good to know.

[23:24] <jnthn> Maybe I'll try and be less lazy about typing $c

[23:24] <jnthn> erm, $...thingy...

[23:24] <jnthn> :)

[23:24] <pmichaud> on my keyboard it's  Ctrl-K + | + c

[23:24] <pmichaud> (in vim)

[23:24] <Juerd> That's any keyboard :)

[23:24] <pmichaud> or just plain right-alt + | + c   if not in vim

[23:24] <moritz_> Compose + | + c

[23:25] <pmichaud> as in ¬¢  :-)

[23:25] <pmichaud> anyway, that's the other advantage to  <!is_name(...)>  -- you don't have to type the ¬¢  :-)

[23:25] <moritz_> I'm still not sure if the Windows key should be the compose key or the window manager key

[23:26] <moritz_> bed &

[23:26] <jnthn> ¬¢

[23:26] <pmichaud> arrrrgh

[23:26] <pmichaud> looks like we need pointy subs

[23:26] <jnthn> AltGr + 0162

[23:26] <pmichaud> I really despise is_deeply

[23:26] <jnthn> pmichaud: Well, we already have signatures and blocks... ;-)

[23:26] <jnthn> pblocks should be easy enough.

[23:26] <Juerd> There. I configured a compose key in my new ubuntu install. ¬¢

[23:26] *** pmurias left
[23:27] <moritz_> pmichaud: you can try to replace is_deeply by ok ($a eqv $b)

[23:27] <Juerd> I chose caps lock for my compose key. Finally a good purpose for that key.

[23:27] <Juerd> :√æ

[23:27] <moritz_> pmichaud: that way you just have to parse infix:<eqv> for now, and worry about making eqv smart enough later

[23:27] <pmichaud> moritz_++

[23:27] <pmichaud> yeah, I'll do that.

[23:27] <Juerd> Note: compose c / works too on my machine. Saves me a shift.

[23:28] <pmichaud> hey, here also!

[23:28] <pmichaud> Juerd++  # Win!

[23:28] <jnthn> 

[23:28] <Juerd> That makes it only slightly less awkward, but it the long run you might benefit ;)

[23:28] <moritz_> http://github.com/moritz/json/commit/43a90e3f17dca240d38e232cf5a3d85d14c51f9d

[23:28] <pmichaud> is_deeply also makes heavy use of return

[23:28] <moritz_> that's a quite awesome commit

[23:29] <pmichaud> is_deeply is_evil

[23:29] <Juerd> Is return bad?

[23:29] <pmichaud> it requires setting up exception handlers to catch the returns

[23:29] <moritz_> I was amazed how much I could simplify some action methods now that I understand them, and rakudo isn't as infantile as it used to be

[23:29] <pmichaud> the new action methods (that don't require the {*}'s)  are really nice to work with

[23:30] <moritz_> looking forward to those too

[23:30] <pmichaud> saves a lot of "oops why didn't that work oh I forgot the stupid {*} again" comments

[23:30] * jnthn is grateful for that.

[23:30] <Juerd> moritz_: The change to pairlist is a load of fun to read :)

[23:30] <pmichaud> while writing nqp-rx I kept forgetting the {*}, after bootstrapping nqp-rx I've been like "hey, this is NICE."

[23:30] <moritz_> japhb: for array too

[23:30] <jnthn> moritz_: Wow, that's...quite an improvement. :-)

[23:30] <Juerd> Ah, for array too indeed.

[23:31] <Juerd> (Assuming tab completion fail)

[23:31] <jnthn> moritz_: j<tab> fail ;-)

[23:31] <moritz_> basically I looked into explaining them for the boook

[23:31] <moritz_> and though "there *must* be a simpler way"

[23:31] <jnthn> oh noes book

[23:31] <pmichaud> 0

[23:31] <pmichaud> +    make = $<pair>¬ª.ast;

[23:31] <pmichaud> huh?

[23:31] <pmichaud> (line 11, new version)

[23:31] <moritz_> what's "huh?" about that?

[23:32] <jnthn> oh, I missesd the = when reading that...

[23:32] <pmichaud> what does the '=' do there?

[23:32] <moritz_> oh

[23:32] *** payload1 left
[23:32] <jnthn> Just read it as make $<...

[23:32] <moritz_> OH NOES

[23:33] <moritz_> all the time I tested, I actually had JSON::TIny installed in ~/.perl6/lib

[23:33] <moritz_> so I have actually broken JSON::Tiny

[23:33] <moritz_> and my tests didn't catcht that

[23:33] <moritz_> because it used the wrong modules

[23:34] <pmichaud> :(

[23:34] <moritz_> t/01-parse.t ...... Can only transform an Object to p6opaque

[23:34] <moritz_> oh wow

[23:34] <moritz_> never seen that error before

[23:34] *** s1n_mini joined
[23:35] *** __ash__ joined
[23:36] *** nickgibbon joined
[23:36] <jnthn> Ouch.

[23:36] <jnthn> You gotta do something quite special to get that one...

[23:37] <moritz_> anyway, I'll try to track that down tomorrow

[23:37] <moritz_> sleeping time, for real

[23:37] <jnthn> night

[23:37] *** nihiliad1 left
[23:38] *** cotto joined
[23:38] <Juerd> Good night, moritz_ 

[23:41] <pmichaud> now up to 218 (of 251)

[23:41] *** nihiliad joined
[23:41] *** scallop left
[23:42] <pmichaud> okay, we parse all of Test.pm, fail because it doesn't know $! yet

[23:42] * pmichaud prepares to add $_, $!, and $/

[23:43] <s1n_mini> pmichaud: how's nqprx coming?

[23:43] <pmichaud> it's going great

[23:43] <pmichaud> I've pretty much stopped work on nqprx to work on moving rakudo over to it

[23:43] <s1n_mini> you guys have been wicked busy

[23:44] <pmichaud> and I think we're all in agreement that things are going far better than we had planned or expected

[23:44] <s1n_mini> that's great

[23:44] <jnthn> It's pretty fast paced. :-)

[23:45] <pmichaud> and we're fixing some long-outstanding big bugs and features

[23:45] <jnthn> It's not just that we're putting it back together - it's that many things are going back together so much nicer than they did the first time around.

[23:45] * s1n_mini wishes he had more time; haven't been able to utilize my toy

[23:45] <pmichaud> I'll be eager to close out a bunch of tickets in the perl6 queue with "no longer a problem in ng!"

[23:46] <s1n_mini> such as?

[23:46] <jnthn> That will be nice. :-)

[23:46] *** tak11 joined
[23:46] <pmichaud> array vivifications now work properly

[23:46] <pmichaud> lexicals are initialized properly

[23:46] <pmichaud> lists are lazy

[23:46] <jnthn> oh, I didn't look at the new lex init stuff properly...

[23:46] <pmichaud> ranges are lazy

[23:46] <pmichaud> IO (will be) lazy

[23:46] <s1n_mini> lists are lazy? that's awesome

[23:47] <s1n_mini> so BUILD is now properly supported?

[23:47] <pmichaud> I don't know about that part yet.  I'm sure it will be soon if it isn't.  :)

[23:47] <pmichaud> (where "soon" means "in the next couple of weeks")

[23:47] <pmichaud> a lot of our blockers are disappearing

[23:47] <s1n_mini> sounds like this change was a long time coming

[23:48] <pmichaud> oh, one can no longer write to constant values :)

[23:48] <s1n_mini> awesome heh

[23:48] <pmichaud> should be a lot fewer Null PMC errors

[23:48] <s1n_mini> and all you added to nqprx was regexes?

[23:48] <pmichaud> rewrote the regex engine, actually

[23:48] <s1n_mini> to do what?

[23:48] <pmichaud> protoregexes

[23:49] <pmichaud> but also the regex engine itself is now written in NQP :-)

[23:49] <jnthn> s1n_mini: It's also that we're just re-building a lot of things that would have on their own been big and challenging refactors.

[23:49] <pmichaud> (at least the parser/compiler parts are)

[23:49] <jnthn> But since we cna do them and then build out on top of them, it's a bunch easier.

[23:50] <pmichaud> http://github.com/perl6/nqp-rx/tree/master/src/Regex/P6Regex/  # code for compiling Perl 6 Regexes

[23:51] <s1n_mini> so Grammar.pm is the complete regex grammar for p6??

[23:51] <jnthn> pmichaud: heh heh, I see the magic. :-)

[23:51] <jnthn> $BLOCK[0].push($decl);

[23:51] <pmichaud> yes

[23:51] <pmichaud> initialize lexicals at the beginning of the block

[23:52] <jnthn> That'll kill some NPMCAs. :-)

[23:52] <pmichaud> a bunch of them.  In fact, I don't think I've really seen many Null PMC accesses while doing this

[23:52] <jnthn> Me either.

[23:53] <jnthn> But we ain't masak. :-)

[23:53] <pmichaud> s1n_mini: it also borrows from HLL::Grammar a bit

[23:53] <pmichaud> s1n_mini: mainly for the quote_EXPR rules and value rules

[23:53] <s1n_mini> that's not daunting at all

[23:53] <s1n_mini> quite compact actually, i sorta expected a huge mess lol

[23:53] <pmichaud> the protoregexes make it so much easier

[23:53] *** samlh left
[23:54] <s1n_mini> protoregexes are where?

[23:54] *** tak11 left
[23:54] <pmichaud> anything that is of the form    category:sym<...>

[23:54] <pmichaud> that's an entry in a protoregex

[23:54] <pmichaud> so

[23:54] <pmichaud> the last four lines of Grammar.pm are

[23:54] <jnthn> metachar:sym<bs> # lol

[23:55] <pmichaud>     proto token mod_ident { <...> }

[23:55] <pmichaud>     token mod_ident:sym<ignorecase> { $<sym>=[i] 'gnorecase'? }

[23:55] <pmichaud>     token mod_ident:sym<ratchet>    { $<sym>=[r] 'atchet'? }

[23:55] <pmichaud>     token mod_ident:sym<sigspace>   { $<sym>=[s] 'igspace'? }

[23:55] <pmichaud> the first line says that "mod_ident" is a protoregex.

[23:55] <pmichaud> The next three lines say that <mod_ident> will match any of those tokens

[23:55] <pmichaud> it's like writing

[23:55] <pmichaud>     token mod_ident {

[23:55] <pmichaud>         $<sym>=[i] 'gnorecase'?

[23:55] <pmichaud>         | $<sym>=[r] 'atchet' ?

[23:56] <pmichaud>         | $<sym>=[s] 'igspace' ?

[23:56] <pmichaud>     }

[23:56] <pmichaud> except the protoregex handles the alternation for you

[23:56] <s1n_mini> ahhh okay, that's what a protoregex is

[23:56] *** constant left
[23:56] *** constant joined
[23:56] <pmichaud> and the actions are then broken out by individual rules

[23:56] <pmichaud> so instead of having a single mod_ident action that has to handle all three cases, each entry in the protoregex gets its own action method

[23:57] <pmichaud> and the really cool thing is

[23:57] <pmichaud> the protoregex is smart enough that it can often select the correct candidate to call just by looking at the string to be matched

[23:57] <s1n_mini> it's like an overloaded token :)

[23:57] <pmichaud> for example, if we get to matching <mod_ident>, and the next character to be matched is an 'i', then it only tries the first candidate

[23:58] <pmichaud> it doesn't even attempt to match the other alternatives, because there's no way that 'r' or 's' could match what is next 

[23:58] *** __ash__ left
[23:58] <s1n_mini> neat, you learn something every day

[23:58] <pmichaud> and if the next character doesn't match any of the alternatives, the protoregex fails immediately without having to try any of them

[23:59] <pmichaud> i..e. the mod_ident protoregex knows that the only possible matches at that point are 'i', 'ignorecase', 'r', 'ratchet', 's', and 'sigspace'

