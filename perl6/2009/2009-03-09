[00:13] <wayland76> @tell moritz_ What was wrong with the bot was we put it in an infinite loop waiting for input :)

[00:13] <lambdabot> Consider it noted.

[00:28] <wayland76> @tell cspencer someone reorganised the test suite by putting lots of S29 stuff in S32.  I reorganised the spec like this, but someone else (I forget who now) did the spectests

[00:28] <lambdabot> Consider it noted.

[00:52] *** WootKit joined
[00:53] *** ujwalic left
[00:55] *** nbrown joined
[01:19] *** hercynium joined
[01:20] *** justatheory left
[01:38] *** WootKit left
[01:41] *** Whiteknight left
[01:43] *** kate21de1 left
[01:50] *** DemoFreak left
[01:57] *** justatheory joined
[01:59] *** revdiablo joined
[02:03] *** alester joined
[02:04] *** Coleoid left
[02:35] *** diakopter left
[02:36] *** TimToady joined
[02:36] *** justatheory left
[02:36] *** diakopter joined
[02:40] *** justatheory joined
[02:48] *** alester left
[02:53] *** justatheory left
[02:54] *** justatheory joined
[03:02] *** justatheory left
[03:06] *** justatheory joined
[03:25] *** justatheory left
[04:04] *** SamB left
[04:08] *** pidus left
[04:17] *** meppuru joined
[04:32] *** meppl left
[04:35] *** meppuru is now known as meppl

[04:36] <wayland76> Oh, meppuru = meppl.  I didn't know that :)

[04:36] *** Kimtaro_ is now known as Kimtaro

[04:41] <meppl> wayland76, "meppuru" is what happens, when japanese people try to pronounciate "meppl"

[04:42] *** hercynium left
[04:58] *** justatheory joined
[05:01] *** finanalyst joined
[05:06] *** c9s__ left
[05:13] *** justatheory left
[05:15] <wayland76> meppl: :)

[05:15] *** kjwcode joined
[05:21] *** sri_kraih joined
[05:29] *** REPLeffect joined
[05:40] *** sri_kraih_ left
[05:42] *** Kimtaro left
[05:43] *** ewilhelm left
[05:45] *** pidus joined
[05:49] *** AzureStone left
[05:50] *** AzureStone joined
[05:51] *** Kimtaro joined
[05:53] *** Tene joined
[06:01] *** kate21de joined
[06:05] *** ewilhelm joined
[06:06] *** Tene_ left
[06:09] *** nihiliad left
[06:10] *** cai joined
[06:15] *** REPLeffect left
[06:17] *** kjwcode left
[06:26] *** cai_ joined
[06:27] *** ujwalic joined
[06:33] *** araujo left
[06:48] *** cai left
[06:49] *** alc joined
[06:58] <pugs_svn> r25754 | lwall++ | [STD] refactor ? twigil checking so %?FOO is handled correctly in strings

[06:58] <pugs_svn> r25754 | lwall++ | [STD] canonicalize packaged vars before lookup

[06:58] <pugs_svn> r25754 | lwall++ | [STD] allow $?CALLER::LINE and such via canonicalization to CALLER::<$?LINE>

[06:58] <pugs_svn> r25754 | lwall++ | [STD] suppress complaints about DEBUG

[07:12] *** kate21de left
[07:13] *** kate21de joined
[07:16] *** WootKit joined
[07:19] *** WootKit left
[07:23] <pugs_svn> r25755 | moritz++ | [evalbot] try to avoid infinite loops when some program reads from STDIN

[07:26] *** p6eval left
[07:27] *** p6eval joined
[07:43] *** masak joined
[07:45] <pugs_svn> r25756 | masak++ | [u4x/TODO] added 'word' grammar rule

[07:45] <masak> S11:365:

[07:46] <masak> use Dog:ver(Any):auth({ .substr(0,5) eq 'cpan:'})

[07:46] <masak> While "Any" here is cute and pronounceable, I'd think both "*" and "Whatever" would be more logical.

[07:46] <masak> Also, can modules be re-entered without using 'augment' or some such? S11 doesn't seem to have an opinion on that.

[07:46] <moritz_> yes, * seems more logical

[07:46] <lambdabot> moritz_: You have 1 new message. '/msg lambdabot @messages' to read it.

[07:46] <moritz_> @massages

[07:46] <lambdabot> wayland76 said 7h 33m 42s ago: What was wrong with the bot was we put it in an infinite loop waiting for input :)

[07:47] <masak> moritz_: I thought the evalbots had a 60-second timeout or some such.

[07:47] <moritz_> masak: so did I; apparently it didn't work in connection with IO

[07:48] <moritz_> perhaps it only limits CPU time, not real execution time

[07:48] <masak> that's explain it.

[07:48] <masak> s/s/d/

[07:48] <moritz_> more general solutions are welcome, of course ;-)

[07:49] <masak> more questions: Ruby has Module#instance_method -- is there an equivalent in Perl 6? http://gist.github.com/76158

[07:51] <moritz_> does the promote a method to a sub?

[07:51] <moritz_> s/the/that/

[07:52] <masak> not instance_method in itself, no.

[07:53] <moritz_> then I don't understand what it does

[07:53] <masak> rather, it fetches a method that is supposed to be called on an object, but it isn't bound to an actual instance yet.

[07:53] <masak> the do_a et al are already instance methods in Interpreter.

[07:54] <masak> Dispatcher, then, is a hash of bytes to this kind of UnboundMethod objects.

[07:54] <masak> finally, the loop in interpret(string) binds and calls.

[07:54] <masak> I guess my question is: does Perl 6 have an equivalent of UnboundMethod?

[07:54] <moritz_> so all it does is taking a reference to a method?

[07:55] <masak> right.

[07:55] <moritz_> &Class::method ?

[07:55] <masak> and in the case of multis?

[07:55] <masak> hm, maybe that isn't a problem.

[07:56] <moritz_> the & thing points to a collection of multis in the general case, I think

[07:58] <masak> as it probably should.

[07:58] <masak> is there a way to do the dispatch without the call?

[07:59] <moritz_> dunno

[07:59] <moritz_> can you think of an application for that?

[07:59] <masak> that would probably be highly desirable in some cases.

[07:59] <masak> yes, something when you want pattern matching but not method calls for some reason.

[07:59] <masak> maybe such a use case is bogus. you might as well make the call as well.

[08:00] <masak> no, wait. delayed calls!

[08:00] <masak> you do dispatch on the server side, and send a method object to the client side. or something.

[08:00] <moritz_> that sounds a bit like abuse of the dispatcher ;-)

[08:01] <moritz_> in this case you can wrap the multi prior to dispatch, and unwrap later

[08:01] <masak> ok.

[08:02] <moritz_> that said, maybe there *is* such an API, and I just don't know about it

[08:03] <masak> understood.

[08:05] <Matt-W> Morning

[08:05] <wayland76> Matt-W: good localtime() (with apologies to whoever I stole that from :) )

[08:05] <Matt-W> :)

[08:05] <Matt-W> Did everyone have a wonderful weekend?

[08:06] * masak 

[08:06] <moritz_> Matt-W: sure, but it was way too short

[08:06] <masak> they all are.

[08:06] <Matt-W> yup

[08:06] <wayland76> I did too.  But life is too short :)

[08:07] <Matt-W> mine finished with watching the police climb over my garden gate and drag a man out of the shed under the glare of the helicopter searchlight, so it was... unusual

[08:07] <masak> wow.

[08:07] <masak> never a boring moment, eh?

[08:07] <wayland76> I hope that was your weekend and not your life that ended that way :)

[08:07] <Matt-W> but I do like to see stupid people get their comeuppance

[08:07] <wayland76> masak: Where is the Web stuff being discussed?

[08:07] <Matt-W> and trying to hide from the helicopter's heat camera in a very wobbly shed is really, really stupid

[08:08] <masak> wayland76: two places. #november-wiki and november-wiki as googlegroups

[08:10] * moritz_ snickers at today's xkcd

[08:17] *** bacek_ left
[08:24] *** kate21de left
[08:30] *** DemoFreak joined
[08:58] <bacek> good evening

[08:59] <masak> bacek: marnin'

[09:00] <bacek> masak: still lives in past? :)

[09:01] <masak> bacek: yes, I'd like a few hours warning every day before the next one arrives.

[09:01] <masak> I'm a late adopter in that sense, I guess.

[09:02] <bacek> masak: Good point. You have to trade something to get something.

[09:02] <masak> that's life.

[09:04] *** ujwalic_ joined
[09:06] *** pidus left
[09:16] <finanalyst> evalbot: perl6: my $x='ab';my $y='xxyuabhh';$y~~m/$x/ ?? say 'variables work' !! say 'variables dont match';

[09:16] <finanalyst> perl6: my $x='ab';my $y='xxyuabhh';$y~~m/$x/ ?? say 'variables work' !! say 'variables dont match';

[09:17] <p6eval> rakudo 8bbc31: OUTPUT«Null PMC access in get_string()␤current instr.: 'parrot;PGE;Grammar;' pc 300 (EVAL_17:121)␤»

[09:17] <p6eval> ..elf 25756: OUTPUT«Unknown rule: infix:conditional␤It needs to be added to ast_handlers.␤ at ./elf_h line 2044␤»

[09:17] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/evalenv/pugs/perl5/Pugs-Compiler-Rule/lib';␤    unshift @INC, '/home/evalenv/pugs/third-party/Parse-Yapp/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runti...

[09:20] *** ujwalic left
[09:21] *** rkendall joined
[09:22] *** alc left
[09:24] <finanalyst> perl6: my $x='ab';my $y='xxyuabhh';$y~m/$x/  and say 'variables work';

[09:24] <p6eval> elf 25756, pugs, rakudo 8bbc31: OUTPUT«variables work␤»

[09:25] <moritz_> ~ does a string concatenation

[09:25] <moritz_> probably not quite what you want

[09:25] <finanalyst> no it wasnt

[09:25] <pugs_svn> r25757 | bacek++ | [t/spec] Fix subroutine form of max.

[09:26] <finanalyst> but i thought pugs could match against variab;es

[09:26] <moritz_> pugs: my $var = 'a'; say "foobar" ~~ /$var/;

[09:26] <p6eval> pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/evalenv/pugs/perl5/Pugs-Compiler-Rule/lib';␤    unshift @INC, '/home/evalenv/pugs/third-party/Parse-Yapp/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runti...

[09:26] <moritz_> rakudo: my $var = 'a'; say "foobar" ~~ /$var/;

[09:26] <p6eval> rakudo 8bbc31: OUTPUT«Null PMC access in get_string()␤current instr.: 'parrot;PGE;Grammar;' pc 249 (EVAL_17:106)␤»

[09:26] <moritz_> it seems neither can

[09:28] <finanalyst> matching against variables is known not to work in rakudo

[09:28] <bacek> rakudo: say reduce -> $a, $b?, $c? { $a + ($b//0) + ($c//0) }, 1,2;

[09:28] <p6eval> rakudo 8bbc31: OUTPUT«Cannot reduce() using a unary or nullary function.␤current instr.: 'die' pc 16009 (src/builtins/control.pir:204)␤»

[09:28] <bacek> rakudo: my $f = -> $a, $b?, $c? { ... }; say $f.arity

[09:28] <p6eval> rakudo 8bbc31: OUTPUT«1␤»

[09:28] <finanalyst> i dont understand why it has such low priority for fixing

[09:29] <bacek> ouch....

[09:29] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.arity

[09:29] <p6eval> rakudo 8bbc31: OUTPUT«2␤»

[09:29] * bacek summons masak

[09:29] <masak> raaawr!

[09:29] * masak submits rakudobug

[09:29] <masak> wait, isn't that correct?

[09:29] <bacek> Team work in action :)

[09:30] <bacek> Why it's correct???

[09:30] <masak> it has two mandatory args.

[09:30] <bacek> but I expect arity to be 3.

[09:30] <masak> bacek: please provide evidence in spec for this.

[09:30] <masak> then I'll submit the bug for you.

[09:31] <bacek> masak: no, it's not a bug...

[09:31] <bacek>     $args_required = &foo.arity;

[09:32] <masak> right.

[09:32] <masak> an interesting question is which method gives you a 3.

[09:32] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.count

[09:32] <p6eval> rakudo 8bbc31: OUTPUT«Method 'count' not found for invocant of class 'Block'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[09:32] <wayland76> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.maxarity

[09:32] <p6eval> rakudo 8bbc31: OUTPUT«Method 'maxarity' not found for invocant of class 'Block'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[09:33] <wayland76> Well, I liked it, anyway :)

[09:33] <bacek> I can't spot proper method to find number of all arguments...

[09:33] <bacek> masak: but I still have bug for you :)

[09:34] <bacek> rakudo: say reduce -> $a, $b?, $c? { $a + ($b//0) + ($c//0) }, 1,2;

[09:34] <p6eval> rakudo 8bbc31: OUTPUT«Cannot reduce() using a unary or nullary function.␤current instr.: 'die' pc 16009 (src/builtins/control.pir:204)␤»

[09:34] <masak> haha :)

[09:34] * masak submits

[09:34] <bacek> It's because of '.arity'...

[09:35] <moritz_> rakudo: my $x = -> $a, $b?, $c? { ... }; say $x.count

[09:35] <p6eval> rakudo 8bbc31: OUTPUT«Method 'count' not found for invocant of class 'Block'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[09:35] <moritz_> rakudo: my $x = -> $a, $b?, $c? { ... }; say $x.arity

[09:35] <p6eval> rakudo 8bbc31: OUTPUT«1␤»

[09:36] <bacek> moritz_: Hey. I already checked it :)

[09:36] <moritz_> rakudo: my $x = { $_*2 }; say $x.arity

[09:36] <p6eval> rakudo 8bbc31: OUTPUT«0␤»

[09:36] <moritz_> that however is wrong

[09:37] * masak submits

[09:37] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.signature

[09:37] <ujwalic_> where to find for rakudo install dir layout

[09:37] <p6eval> rakudo 8bbc31: OUTPUT«Signature<0xb6193c90>␤»

[09:37] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.signature.perl

[09:37] <p6eval> rakudo 8bbc31: OUTPUT«:(Any $a, Any $b, Any $c?)␤»

[09:38] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.signature.params

[09:38] <p6eval> rakudo 8bbc31: OUTPUT«Null PMC access in find_method()␤current instr.: 'infix:=>' pc 10086 (src/classes/Pair.pir:44)␤»

[09:38] <moritz_> rakudo++ # I didn't know it did that

[09:39] <masak> that Null PMC access is already reported, btw.

[09:39] <bacek> Which spec describes Signature ?

[09:40] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say +$f.signature.params

[09:40] <p6eval> rakudo 8bbc31: OUTPUT«3␤»

[09:40] <moritz_> probably S02 or S06, if any

[09:40] <bacek> hooray. Here we go.

[09:40] <wayland76> Should be in S32/Callable as well

[09:41] <moritz_> rakudo: multi f() {...}; multi f($x) {...}; say $f.signature.params.WHAT

[09:41] <p6eval> rakudo 8bbc31: OUTPUT«Scope not found for PAST::Var '$f' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[09:41] <moritz_> rakudo: multi f() {...}; multi f($x) {...}; say &f.signature.params.WHAT

[09:41] <p6eval> rakudo 8bbc31: OUTPUT«Null PMC access in find_method()␤current instr.: '_block14' pc 84 (EVAL_21:45)␤»

[09:44] <moritz_> rakudo: multi sub f($z) {}; &f.arity.say

[09:44] <p6eval> rakudo 8bbc31: OUTPUT«Null PMC access in find_method()␤current instr.: '_block14' pc 79 (EVAL_16:43)␤»

[09:45] <moritz_> that's RT #63568

[09:45] <masak> aye.

[09:46] <moritz_> I'd expect an any() junction

[09:46] <moritz_> but maybe I'm wrong there

[09:47] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.signature.params[0].WHAT

[09:47] <p6eval> rakudo 8bbc31: OUTPUT«Mapping␤»

[09:47] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.signature.params[0]

[09:48] <p6eval> rakudo 8bbc31: OUTPUT«Null PMC access in find_method()␤current instr.: 'infix:=>' pc 10086 (src/classes/Pair.pir:44)␤»

[09:48] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.signature.params[0].perl

[09:48] <p6eval> rakudo 8bbc31: OUTPUT«Null PMC access in find_method()␤current instr.: 'infix:=>' pc 10086 (src/classes/Pair.pir:44)␤»

[09:48] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.signature.params[0].key

[09:48] <p6eval> rakudo 8bbc31: OUTPUT«Method 'key' not found for invocant of class 'Hash'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[09:48] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.signature.params[0].kv

[09:48] <p6eval> rakudo 8bbc31: OUTPUT«Null PMC access in find_method()␤current instr.: 'infix:=>' pc 10086 (src/classes/Pair.pir:44)␤»

[09:48] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.signature.params[0].keys

[09:48] <p6eval> rakudo 8bbc31: OUTPUT«Null PMC access in find_method()␤current instr.: 'infix:=>' pc 10086 (src/classes/Pair.pir:44)␤»

[09:48] <bacek> rakudo: my $f = -> $a, $b, $c? { ... }; say $f.signature.params[0].values

[09:48] <p6eval> rakudo 8bbc31: OUTPUT«Null PMC access in find_method()␤current instr.: 'infix:=>' pc 10086 (src/classes/Pair.pir:44)␤»

[09:54] <bacek> rakudo: say reduce -> $a, $b, $c { $a + ($b//0) + ($c//0) }, 1,2;

[09:54] <p6eval> rakudo 8bbc31: OUTPUT«3␤»

[09:56] <bacek> rakudo: sub f (Code $c) { say +$c.signature.params }; f(-> $a, $b? {...})

[09:56] <p6eval> rakudo 8bbc31: OUTPUT«Method 'params' not found for invocant of class ''␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[09:56] * bacek summon masak again...

[09:57] <masak> raaawr again!

[09:57] * masak submits

[09:57] <bacek> rakudo: my Code $c = -> $a {...}; say $c.signature.perl

[09:57] <p6eval> rakudo 8bbc31: OUTPUT«:(Any $a)␤»

[09:58] <bacek> rakudo: my Code $c = -> $a {...}; say $c.signature.perl; sub f(Code $f) { say $f.signature.perl }; f($c);

[09:58] <p6eval> rakudo 8bbc31: OUTPUT«:(Any $a)␤Failure␤»

[09:59] <bacek> interesting...

[10:00] <bacek> Ah!

[10:00] <bacek> rakudo: my Code $c = -> $a {...}; say $c.signature.perl; sub f(Code $f is copy) { say $f.signature.perl }; f($c);

[10:00] <p6eval> rakudo 8bbc31: OUTPUT«:(Any $a)␤Failure␤»

[10:00] <bacek> rakudo: my Code $c = -> $a {...}; say $c.signature.perl; sub f(Code $f is rw) { say $f.signature.perl }; f($c);

[10:00] <p6eval> rakudo 8bbc31: OUTPUT«:(Any $a)␤:(Any $a)␤»

[10:01] *** cai_ left
[10:01] <bacek> yes. ObjectRef doesn't proxy .signature properly.

[10:06] <bacek> or it is ClassHOW?

[10:11] <bacek> rakudo: my Code $c = -> $a {...}; say $c.signature.perl; sub f(Code $f is rw) { say $f.blah }; f($c);

[10:11] <p6eval> rakudo 8bbc31: OUTPUT«:(Any $a)␤Method 'blah' not found for invocant of class 'Block'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[10:17] *** bacek_ joined
[10:17] <bacek> rakudo: my Code $c = -> $a {...}; my ObjectRef $o = $c; say $o.signature.perl

[10:17] <bacek> hmmm... I broke evalbot again?

[10:17] *** bacek left
[10:17] <p6eval> rakudo 8bbc31: OUTPUT«Malformed declaration at line 1, near "ObjectRef "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[10:19] <masak> baest: isn't ObjectRef a Parrot type?

[10:20] <moritz_> I think it's a Rakudo type

[10:20] *** SamB joined
[10:21] <masak> ok. but it might still be an internal type, right?

[10:22] <moritz_> yes

[10:24] <bacek_> rakudo: my Code $c = -> $a {...}; my Any $a=$c; say $a.signature.perl

[10:24] <p6eval> rakudo 8bbc31: OUTPUT«:(Any $a)␤»

[10:25] <bacek_> rakudo: my Code $c = -> $a {...}; sub f(Code $f) { say $f.HOW }; f($c);

[10:25] <p6eval> rakudo 8bbc31: OUTPUT«get_string() not implemented in class 'P6metaclass'␤current instr.: 'print' pc 19094 (src/builtins/io.pir:26)␤»

[10:25] <bacek_> rakudo: my Code $c = -> $a {...}; sub f(Code $f) { say $f.perl }; f($c);

[10:26] <p6eval> rakudo 8bbc31: OUTPUT«{ ... }␤»

[10:27] <bacek_> rakudo: class Foo { has $!foo = 42; method bar { say $!foo } }; my Foo $f=Foo.new; $f.bar;

[10:27] <p6eval> rakudo 8bbc31: OUTPUT«42␤»

[10:28] <bacek_> rakudo: class Foo { has $!foo = 42; method bar { say $!foo } }; my Foo $f=Foo.new; $f.bar; sub blah($b) { $b.bar }; blah($f);

[10:28] <p6eval> rakudo 8bbc31: OUTPUT«42␤42␤»

[10:30] <bacek_> rakudo: sub foo($x) { say ~$x }; foo([1..2]);

[10:30] <p6eval> rakudo 8bbc31: OUTPUT«1 2␤»

[10:30] *** ujwalic_ left
[10:30] <bacek_> rakudo: sub foo($x) { say ~$x }; foo(\(1..2));

[10:30] <p6eval> rakudo 8bbc31: OUTPUT«1 2␤»

[10:32] <bacek_> rakudo: sub foo($x) { say ~$x }; say foo(1|2);

[10:32] <p6eval> rakudo 8bbc31: OUTPUT«1␤2␤Junction<0xb6145018>␤»

[10:32] <bacek_> rakudo: sub foo($x) { say ~$x }; foo(1|2);

[10:32] <p6eval> rakudo 8bbc31: OUTPUT«1␤2␤»

[10:34] <bacek_> yak...

[10:34] <moritz_> what's wrong with that?

[10:34] <moritz_> it autothreads, as it should

[10:35] <bacek_> If I understand correctly we has "parent-loop" for Code.

[10:35] <moritz_> I wonder if types in pointy blocks should default to Object instead of Any

[10:35] <bacek_> Code parents Sub and Any, Sub parent Routing, Routine parent is Block, Block's parent is Code...

[10:36] <bacek_> Sub's parent Routine.

[10:36] <moritz_> Code is Any, and all others should inherit from Code

[10:37] <bacek_> moritz_: lemme check it in local repo.

[10:38] <moritz_> rakudo: say Code ~~ Any

[10:38] <p6eval> rakudo 8bbc31: OUTPUT«1␤»

[10:38] <moritz_> rakudo: say Block ~~ Code

[10:38] <p6eval> rakudo 8bbc31: OUTPUT«1␤»

[10:38] <moritz_> rakudo: say Routine ~~ Code

[10:38] <p6eval> rakudo 8bbc31: OUTPUT«1␤»

[10:38] <moritz_> rakudo: say Sub ~~ Routine

[10:38] <p6eval> rakudo 8bbc31: OUTPUT«1␤»

[10:39] <moritz_> rakudo: say Method ~~ Routine

[10:39] <p6eval> rakudo 8bbc31: OUTPUT«1␤»

[10:39] <bacek_> rakudo: say Code ~~ Sub

[10:39] <moritz_> rakudo: say Routine ~~ Block

[10:39] <p6eval> rakudo 8bbc31: OUTPUT«0␤»

[10:39] <p6eval> rakudo 8bbc31: OUTPUT«1␤»

[10:39] <bacek_> hmm...

[10:39] <moritz_> maybe one of them is actually a role?

[10:40] <moritz_> everything is as I expect, except for Code ~~ Sub

[10:40] <wayland76> Code is the parent of sub

[10:41] <bacek_> yes, I misread Sub.pir.

[10:41] <moritz_> rakudo: say Sub ~~ Code

[10:41] <p6eval> rakudo 8bbc31: OUTPUT«1␤»

[10:41] <moritz_> rakudo: say Code ~~ Sub

[10:41] <p6eval> rakudo 8bbc31: OUTPUT«0␤»

[10:41] <moritz_> ah

[10:41] <wayland76> Not parent, the other thing 

[10:41] <moritz_> rakudo: say Routine ~~ Block

[10:41] <p6eval> rakudo 8bbc31: OUTPUT«1␤»

[10:41] <wayland76> Block does Code

[10:41] <wayland76> Routine does Block

[10:41] <wayland76> Sub does Routine

[10:41] <wayland76> See S32/Callable :)

[10:42] <moritz_> isn't Callable the role that it should do?

[10:42] * moritz_ confused

[10:42] <wayland76> Sorry, S32/Callable includes all related roles

[10:42] <wayland76> (Block Sub, Routine, etc)

[10:43] <wayland76> Kind of like Containers has a bunch of different things in it

[10:46] <moritz_> yes, I understood that

[10:46] <moritz_> well, I have to do other stuff anyway  :/

[10:49] * wayland76 is multitasking

[10:57] <mikehh> built rakudo [99bbc31] on parrot r37235 - spectest passes (35min for the spectest)

[10:59] <masak> mikehh++

[11:10] *** meppl left
[11:33] *** ruoso joined
[11:34] <ruoso> Hello!

[11:37] <wayland76> hello (except I'm mostly not here :) )

[11:39] <masak> hello (just got back)

[11:46] <ruoso> I think I'll take the fact that most of SMOP need to be refactored to the new capture

[11:46] <ruoso> and also refactor the several parts of SMOP into separated modules

[11:46] <ruoso> to make the dependencies more clear...

[11:56] <masak> ruoso++

[12:02] *** ihrd joined
[12:04] <rkendall> Hi, just have a question about the legal aspects of Rakuo.  The Perl Foundation looks after Perl 5, The Parrot Foundation looks after Parrot, but where does Rakudo fit in? (eg. managing trademarks, licence etc)

[12:05] <moritz_> TPF I think

[12:06] <rkendall> ...and what about other implementations of Perl 6?

[12:06] <moritz_> that depends on the implementation

[12:06] <moritz_> pugs is copyright "the pugs contributors", and they are listed in CREDITS

[12:06] <rkendall> thanks moritz - should probably mention something about that on the website

[12:07] <rkendall> i.e. Rakudo.org

[12:07] <moritz_> anyway, better ask pmichaud first

[12:07] <rkendall> ok

[12:08] <rkendall> noticed talk about 'contributor agreements'

[12:09] <rkendall> but I guess it's still being worked out

[12:09] <moritz_> when it was still part of the parrot repo, every committer had to send in a license agreement

[12:09] <moritz_> now that we moved out we need some kind of policy

[12:10] <moritz_> but that's the pumpking's decision

[12:10] <rkendall> ok, thanks

[12:20] * ruoso really would love to be able to stop worrying with things like licensing...

[12:22] * ruoso .oO( How I Learned to Stop Worrying and Love the Public Domain )

[12:22] <moritz_> well, you could, if everyting was public domain :-)

[12:24] <ruoso> but I actually learned that public domain is not a good idea everywhere

[12:24] <ruoso> in Portugal, and it seems most of Europe, public domain means "property of the state"

[12:24] <ruoso> which looks very bad

[12:25] <ruoso> in Brazil public domain simply means "not subject to copyright/author-right laws"

[12:25] <moritz_> in Germany you can't place code in the "public domain" in the brazil/US sense

[12:25] <moritz_> because you always retain some rights as the author, even if you don't want to

[12:26] <moritz_> so it's better to chose a particular license

[12:26] <ruoso> in Brazil, it's just a matter of making a public statement "this is in the public domain"

[12:28] <ruoso> there was even an interesting case in Brasil

[12:28] <ruoso> where a famous singer

[12:28] <ruoso> visited a country-side community, that had some traditional songs

[12:28] <ruoso> the "musica de quixabeira"

[12:28] <ruoso> and then he recorded an album stating that musics were public domain

[12:29] <ruoso> the people in the community entered in a lawsuit to revert that,

[12:29] <ruoso> and they actually won

[12:38] *** skids left
[12:39] <ruoso> TimToady, have you thought a bit more about the packages aliasing issue? I'm quite convinced the idea of "use" cloning the packages is very good, while if you really want to access a package globally, you would need to access GLOBAL::My::Package::<$VARIABLE>

[12:43] <ruoso> that way every package can have its meaning lexically re-defined.. 

[12:44] <ruoso> and it should also allow several interesting optimizations, since the use of globals would be very well determined...

[12:44] <ruoso> everything without a GLOBAL:: in the front might be considered local to that lexical scope

[12:49] <ruoso> with the benefit of making the use of globals very de-huffmanized

[13:00] <rkendall> masak: very glad to hear about Web.pm

[13:00] <masak> rkendall: thank you. :)

[13:00] <ruoso> masak, I suppose you don't mind I throw out crazy ideas for Web.pm here, do you?

[13:01] <masak> ruoso: au contraire, please do.

[13:01] <ruoso> one of the most important featuers I've been using in Catalyst is the fact that it is engine-agnostic

[13:01] <masak> ruoso: but know that the main discussion takes place on #november-wiki, as we speak and in general.

[13:01] <ruoso> oh

[13:01] <ruoso> at freenode?

[13:01] <masak> aye.

[13:02] * ruoso ETOOMANYCHANNELS.... need to leave some

[13:02] * masak has 10 channels open in Emacs ERC -- could easily have a few more

[13:03] <Matt-W> masak: is that on this network?

[13:03] <masak> Emacs rocks.

[13:03] <masak> Matt-W: aye.

[13:03] <ruoso> masak, it's not the client that's blocking me... it's the server

[13:03] <masak> oh.

[13:06] *** gfldex is now known as Guest82337

[13:06] *** gfldex_ joined
[13:14] *** finanalyst left
[13:18] *** Guest82337 left
[13:22] *** ujwalic joined
[13:45] <ruoso> pugs: class A {}; role B { method foo { say 1 }}; role C { method foo { say 2} }; my $a = A.new; $a does B; $a does C; $a.*foo()

[13:45] <p6eval> pugs: OUTPUT«*** Unknown syntactic construct: Syn "does" [Var "$a",Val (VType (mkType "B"))]␤    at /tmp/kKlMbMIb5Q line 1, column 92-101␤»

[13:45] <ruoso> rakudo: class A {}; role B { method foo { say 1 }}; role C { method foo { say 2} }; my $a = A.new; $a does B; $a does C; $a.*foo()

[13:45] <p6eval> rakudo 8bbc31: RESULT«[]»

[13:46] <ruoso> rakudo: class A {}; role B { method foo { say 1 }}; role C { method foo { say 2} }; my $a = A.new; $a does B; $a does C; $a.?foo()

[13:46] <p6eval> rakudo 8bbc31: RESULT«undef»

[13:46] <ruoso> rakudo: role B { method foo { say 1 }}; role C { method foo { say 2} }; class A does B does C { }; A.*foo()

[13:46] <p6eval> rakudo 8bbc31: OUTPUT«A conflict occurred during role composition due to method 'foo'.␤current instr.: '!meta_compose' pc 342508754 ((unknown file):-1)␤»

[13:48] <moritz_> rakudo: class A { multi method b ($x, $y?) { say "b1" }; multi method b($x) { say "b2" } }; A.new.+b(3)

[13:48] <p6eval> rakudo 8bbc31: OUTPUT«b1␤b2␤»

[13:48] <moritz_> rakudo: class A { multi method b ($x, $y?) { say "b1" }; multi method b($x) { say "b2" } }; A.new.*b(3)

[13:48] <p6eval> rakudo 8bbc31: OUTPUT«b1␤b2␤»

[13:48] <moritz_> rakudo: class A { multi method b ($x, $y?) { say "b1" }; multi method b($x) { say "b2" } }; A.new.?b(3)

[13:48] <p6eval> rakudo 8bbc31: OUTPUT«b1␤»

[13:48] <ruoso> hmmm

[13:48] <ruoso> they need to be multi

[13:48] <ruoso> right

[13:49] <ruoso> rakudo: role B { multi method foo { say 1 }}; role C { multi method foo { say 2} }; class A does B does C { }; A.*foo()

[13:49] <p6eval> rakudo 8bbc31: OUTPUT«1␤2␤»

[13:49] <ruoso> moritz_++

[13:49] <ruoso> rakudo: role B { multi method foo { say 1 }}; role C { multi method foo { say 2} }; class A does B does C { }; A.foo() # that should fail

[13:49] <p6eval> rakudo 8bbc31: OUTPUT«Ambiguous dispatch to multi 'foo'. Ambiguous candidates had signatures:␤:(Object self)␤:(Object self)␤␤current instr.: 'parrot;P6metaclass;dispatch' pc 130 (src/classes/ClassHOW.pir:93)␤»

[13:50] *** skids joined
[13:51] <moritz_> rakudo: role B { multi method foo { say 1 }}; role C { multi method foo { say 2} }; class A does B does C { }; A.*foo()

[13:51] <p6eval> rakudo 8bbc31: OUTPUT«1␤2␤»

[13:52] <bacek_> bacek@icering:~/src/parrot/languages/rakudo.bacek$ ./perl6  -e 'say (1..4).reduce: { $^a + $^b + $^c }'

[13:52] <bacek_> too few arguments passed (2) - 3 params expected

[13:52] <bacek_> bacek@icering:~/src/parrot/languages/rakudo.bacek$ ./perl6  -e 'say (1..4).reduce: -> $a, $b, $c? { $a + $b + ($c//0) }'

[13:52] <bacek_> 10

[13:52] <bacek_> Hooray. I did it :)

[13:53] <masak> bacek_++

[13:53] <bacek_> And it's pure Perl6 implementation :)

[13:54] <moritz_> and let me guess, it's less than 20 lines long

[13:55] <bacek_> moritz_: 21 including empty lines and comments about workarounds

[13:55] <pmichaud> what's the meaning of a 3-argument reduce?

[13:56] <bacek_> http://nopaste.snit.ch/15826

[13:56] <moritz_> it gets the previous result plus two items on each call

[13:57] <pmichaud> is that going into the synopsis somewhree?

[13:57] <ruoso> hmm

[13:57] <ruoso> I would expect it to consume n items at a time

[13:57] <moritz_> just like @list.map: -> $a, $b { ... } gets two at a time

[13:57] <moritz_> pmichaud: it seems I have to add it :)

[13:57] <moritz_> pmichaud: see current p6l thread

[13:58] <pmichaud> moritz_: I did look at the thread.

[13:58] <pmichaud> I didn't see anything about multi-argument reduce.

[13:59] <bacek_> At least it spectested.

[13:59] <moritz_> "The same question also arises for "magical" List.reduce and similar methods."

[13:59] *** mikehh left
[13:59] <pmichaud> moritz_: that question was with respect to how to handle lists that weren't multiples of the body arity

[13:59] <pmichaud> moritz_: it didn't say how reduce should choose to pick its elements

[14:00] <pmichaud> but if we're going to declare that reduce always takes n-1 items at a time, that's fine with me.

[14:00] <moritz_> that seems like the obvious generalization for me

[14:00] <PerlJam> good morning #perl6

[14:01] <moritz_> which works for all operators that are commutative and left-associative

[14:01] <pmichaud> I'm spectesting ".count" for blocks.

[14:01] <moritz_> nice

[14:01] *** pidus joined
[14:02] <moritz_> rakudo: say { $_ }.signature.perl

[14:02] <p6eval> rakudo 8bbc31: OUTPUT«Failure␤»

[14:02] <PerlJam> reduce wouldn't *always* take n-1 items at a time.  The first time it takes n items  :)

[14:02] <pmichaud> PerlJam: no, that's not how I interpreted it.

[14:03] <pmichaud> it could just take the first item and start with that.

[14:03] <PerlJam> oh, I see.

[14:04] <PerlJam> er, maybe

[14:04] <pmichaud> thus  say 10.reduce: -> $a, $b, $c? { $a + $b + ($c // 0) }    returns 10, having never called the block.

[14:04] <bacek_> rakudo: sub foo ($a, $b?) {...}; say $a.arity; say $a.count

[14:04] <p6eval> rakudo 8bbc31: OUTPUT«Scope not found for PAST::Var '$a' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[14:04] <bacek_> rakudo: sub foo ($a, $b?) {...}; say &foo.arity; say &foo.count

[14:04] <p6eval> rakudo 8bbc31: OUTPUT«1␤Method 'count' not found for invocant of class 'Perl6Sub'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[14:05] <pmichaud> bacek_: I said I'm spectesting it now.  :-)

[14:05] <bacek_> pmichaud: :)

[14:05] <pmichaud> I don't commit until after the spectest passes.

[14:05] <bacek_> It should be specced also... Or I can't find where .count is described.

[14:05] <moritz_> speaking of which, running rakudo on an optimized parrot build seems quite stable, all spectests pass

[14:05] <pmichaud> bacek_: Signature.count is described in S06

[14:06] <pmichaud> I'm presuming there's an equivalent .count for Code

[14:06] <bacek_> pmichaud: only in context of want().

[14:06] <PerlJam> pm: I interpretted Larry's email on arity to mean "carp if there aren't the required number of parameters".  your example has a block with 2 required parameters, so it shouldn't return 10.   IMHO

[14:07] <pmichaud> PerlJam: by that reasoning,   [+] 10        should carp.

[14:07] <bacek_> PerlJam: there is 3 params. One of them optional.

[14:07] <moritz_> pmichaud: no, [+] uses explicit default values

[14:07] <pmichaud> moritz_: the default values are for empty list.

[14:07] <moritz_> perl6: say [+];

[14:07] <p6eval> pugs: OUTPUT«0␤»

[14:07] <p6eval> ..elf 25757: OUTPUT«Parse error in: /tmp/4Ab5R3K0lw␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say [+];␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤  STD_red/std.rb:210:in

[14:07] <p6eval> ..`_UNI...

[14:07] <p6eval> ..rakudo 8bbc31: OUTPUT«say requires an argument at line 1, near " [+];"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[14:08] <pmichaud> rakudo:  say [+]();

[14:08] <p6eval> rakudo 8bbc31: OUTPUT«0␤»

[14:08] <moritz_> pmichaud: and [+] 10 would then be (default) + 10

[14:08] *** ihrd left
[14:09] <PerlJam> moritz_: and the default depends on the operation?

[14:09] <moritz_> PerlJam: yes

[14:09] <moritz_> perl6: my $x; $x *= 3;

[14:09] <p6eval> pugs: RESULT«\0»

[14:09] <p6eval> ..rakudo 8bbc31: RESULT«3»

[14:09] <p6eval> ..elf 25757: OUTPUT«Unknown rule: infix_postfix_meta_operator:=␤It needs to be added to ast_handlers.␤ at ./elf_h line 2044␤»

[14:09] <bacek_>     &prefix:<[*]> ::= &reduce.assuming(&infix:<*>, 1);

[14:10] <bacek_> S03.

[14:10] <PerlJam> moritz_: that tends to sound crazyish to me.  How is perl to know the defaults for user-defined ops?

[14:10] <pmichaud> S03:  If fewer than two arguments are given, a dispatch is still attempted

[14:10] <pmichaud> with whatever arguments are given, and it is up to the receiver of that

[14:10] <pmichaud> dispatch to deal with fewer than two arguments.

[14:10] <moritz_> PerlJam: by letting the user define a nullary sub of the same name

[14:10] <pmichaud> (this is for reduce metaoperator)

[14:10] <moritz_> or unary, for that matter

[14:11] <pmichaud> also from S03:   

[14:11] <pmichaud> By default, if there is one argument, the built-in reduce operators

[14:11] <pmichaud> return that one argument.

[14:11] <pmichaud> That seems to argue against moritz's   [+] 10     statement above.

[14:12] <moritz_> aye

[14:12] <pmichaud> thus I'd say that    @list.reduce   should return @list[0] if @list has only one argument.

[14:12] <pmichaud> s/argument/element.

[14:12] <pmichaud> at least, that's a reasonable interpretation.

[14:13] <pmichaud> and then all subsequent calls to the reduction function are using .count-1 elements from the list.

[14:13] <moritz_> that sounds good to me

[14:13] <bacek_> that what I've implemented in reduce :)

[14:13] <pmichaud> I'm not advocating for a particular interpretation; I'm just trying to understand what the actual interpretation should be.

[14:15] <pmichaud> fwiw, I don't like the shifting/splicing in bacek's reduce implementation

[14:16] <pmichaud> iterators are the answer.

[14:16] *** c9s__ joined
[14:16] <pmichaud> in particular, doing things like      my @list = $values.list;    creates an Array.

[14:16] <pmichaud> when $values might not be an Array.

[14:17] <PerlJam> reduce is repeated function application to turn N things into 1 thing.  What would turn N things into M things?

[14:17] <moritz_> PerlJam: for example map

[14:17] <pmichaud> PerlJam: map?

[14:17] <PerlJam> no, map isn't quite the same.

[14:17] *** pmurias joined
[14:17] <pmichaud> PerlJam: why isn't it?

[14:18] <moritz_> rakudo: (1..10).map( {$^a + $^b} ).perl.say

[14:18] <p6eval> rakudo 8bbc31: OUTPUT«[3, 7, 11, 15, 19]␤»

[14:18] <moritz_> that turns 10 things into 5 things

[14:18] <moritz_> now identifier N with 10 and M with 5...

[14:18] <pmichaud> rakudo:  (1..5).map( { $^a, $^a*2 } ).perl.say

[14:18] <p6eval> rakudo 8bbc31: OUTPUT«[1, 2, 2, 4, 3, 6, 4, 8, 5, 10]␤»

[14:19] <PerlJam> sure, but it doesn't do the repeated function application using the M  things as input to the next cycle like reduce does

[14:21] *** bacek_ left
[14:21] *** bacek_ joined
[14:21] <bacek_> yak... my ISP getting worth.

[14:22] <bacek_> rakudo: multi sub foo($a) {...}; multi sub foo($a, *@list) {...}; foo(1)

[14:22] <p6eval> rakudo 8bbc31: OUTPUT«Ambiguous dispatch to multi 'foo'. Ambiguous candidates had signatures:␤:(Any $a)␤:(Any $a, Any @list)␤␤current instr.: '_block14' pc 76 (EVAL_18:44)␤»

[14:22] <bacek_> Is it expected failure?

[14:23] * moritz_ summons jnthn

[14:23] * bacek_ thinks jnthn drinks gorilka in Ukrain :)

[14:23] <pmurias> ruoso: re capture refactoring does it amount to changing .invocant to .postcircumfix:<[ ]>(0) and .positional($i) to .postcircumfix:<[ ]>($i+1)

[14:24] <ruoso> .postcircumfix<[ ]> provides more semantics then .positional

[14:24] <ruoso> .positional doesn't do any kind of flattening

[14:24] <ruoso> .[] needs to

[14:24] <ruoso> but basically 

[14:24] <dalek> rakudo: 2d5f157 | pmichaud++ | src/classes/Code.pir:

[14:24] <dalek> rakudo: Add a .count method to Code objects.

[14:24] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2d5f15745be948c5cf8348df525c85dbfc8a038f

[14:25] <ruoso> .invocant turns into .positional(0)

[14:25] <ruoso> and .positional($i) turns into .positional($i+1)

[14:25] <pmurias> ruoso: what sort of flattening to we want .[] to do?

[14:25] <bacek_> rakudo: sub Reduce(Code $c, $prev, *@list) { @list ?? Reduce($c, &$c($prev, |@list.splice(0,$c.count-1)), @list) !! $prev }; say Reduce { $^a+$^b }, 1..5

[14:25] <p6eval> rakudo 8bbc31: OUTPUT«12345␤»

[14:25] <bacek_> rakudo: sub Reduce(Code $c, $prev, *@list) { +@list ?? Reduce($c, &$c($prev, |@list.splice(0,$c.count-1)), @list) !! $prev }; say Reduce { $^a+$^b }, 1..5

[14:25] <ruoso> pmurias, say (1,(1,(1,(1,2,3),2,3),2,3),2,3)

[14:25] <p6eval> rakudo 8bbc31: OUTPUT«12345␤»

[14:25] <bacek_> ouch

[14:26] <bacek_> rakudo: sub Reduce(Code $c, $prev, *@list) { +@list ?? Reduce($c, &$c($prev, |@list.splice(0,$c.count-1)), @list) !! $prev }; say Reduce({ $^a+$^b }, 1..5)

[14:26] <p6eval> rakudo 8bbc31: OUTPUT«12345␤»

[14:26] <ruoso> pmurias, .[] implies list context, so implies flattening

[14:26] <ruoso> I guess

[14:26] <bacek_> rakudo: sub Reduce(Code $c, $prev, *@list) { +@list ?? Reduce($c, &$c($prev, |@list.splice(0,$c.arity-1)), @list) !! $prev }; say Reduce({ $^a+$^b }, 1..5)

[14:26] <p6eval> rakudo 8bbc31: OUTPUT«12345␤»

[14:27] <pmurias> ruoso: is positional specced?

[14:27] <ruoso> pmurias, capture is not specced yet

[14:28] <bacek_> rakudo: sub Reduce(Code $c, $prev, *@list is rw) { +@list ?? Reduce($c, &$c($prev, |@list.splice(0,$c.arity-1)), @list) !! $prev }; say Reduce({ $^a+$^b }, 1..5)

[14:28] <p6eval> rakudo 8bbc31: OUTPUT«12345␤»

[14:28] <ruoso> pmurias, but I'd assume it's ok to provide that

[14:29] *** c9s___ joined
[14:31] <bacek_> rakudo: sub foo($a, *@b) { say $a }; foo(1..3)

[14:31] <p6eval> rakudo 2d5f15: OUTPUT«123␤»

[14:31] <bacek_> looks like a bug...

[14:31] <bacek_> Or I don't understand param passing at all.

[14:32] <bacek_> pugs: sub foo($a, *@b) { say $a }; foo(1..3)

[14:32] <p6eval> pugs: OUTPUT«123␤»

[14:32] <moritz_> bacek_: 1..3 is a Range object

[14:32] <moritz_> which is bound to $a

[14:32] <bacek_> pugs: sub foo($a, *@b) { say $a }; foo(list(1..3))

[14:32] <p6eval> pugs: OUTPUT«123␤»

[14:32] <bacek_> rakudo: sub foo($a, *@b) { say $a }; foo(list(1..3))

[14:32] <p6eval> rakudo 2d5f15: OUTPUT«1 2 3␤»

[14:32] <moritz_> perl6: sub foo($a, *@b) { say $a }; foo(|1..3)

[14:32] <p6eval> pugs: OUTPUT«123␤»

[14:32] <p6eval> ..rakudo 2d5f15: OUTPUT«argument doesn't array␤current instr.: 'infix:..' pc 8089 (src/classes/Range.pir:279)␤»

[14:32] <p6eval> ..elf 25757: OUTPUT«Undefined subroutine &GLOBAL::prefix__124 called at (eval 127) line 6.␤ at ./elf_h line 4377␤»

[14:33] <bacek_> rakudo: sub foo($a, *@b) { say $a }; foo(1,2,3)

[14:33] <p6eval> rakudo 2d5f15: OUTPUT«1␤»

[14:33] <moritz_> perl6: sub foo($a, *@b) { say $a }; foo(|(1..3).list)

[14:33] <p6eval> pugs: OUTPUT«123␤»

[14:33] <p6eval> ..rakudo 2d5f15: OUTPUT«1␤»

[14:33] <p6eval> ..elf 25757: OUTPUT«Undefined subroutine &GLOBAL::prefix__124 called at (eval 128) line 6.␤ at ./elf_h line 4377␤»

[14:33] <moritz_> I agree with rakudo here

[14:35] <bacek_> rakudo: sub TheReduce(Code $c, $prev, *@list is rw) { +@list ?? TheReduce($c, &$c($prev, |@list.splice(0,$c.arity-1)), @list) !! $prev }; sub Reduce(Code $c, $a) { TheReduce($c, |$a.list) }; }; say Reduce({ $^a+$^b }, 1..5)

[14:35] <p6eval> rakudo 2d5f15: OUTPUT«Syntax error at line 1, near "}; say Red"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[14:35] <bacek_> rakudo: sub TheReduce(Code $c, $prev, *@list is rw) { +@list ?? TheReduce($c, &$c($prev, |@list.splice(0,$c.arity-1)), @list) !! $prev }; sub Reduce(Code $c, $a) { TheReduce($c, |$a.list) };  say Reduce({ $^a+$^b }, 1..5)

[14:35] <p6eval> rakudo 2d5f15: OUTPUT«15␤»

[14:35] <bacek_> hooray. Single line reduce implementation :)

[14:36] <bacek_> rakudo: sub TheReduce(Code $c, $prev, *@list is rw) { +@list ?? TheReduce($c, &$c($prev, |@list.splice(0,$c.arity-1)), @list) !! $prev }; sub Reduce(Code $c, $a) { TheReduce($c, |$a.list) };  say Reduce({ $^a+$^b +$^c}, 1..5);

[14:36] <p6eval> rakudo 2d5f15: OUTPUT«15␤»

[14:36] <bacek_> rakudo: sub TheReduce(Code $c, $prev, *@list is rw) { +@list ?? TheReduce($c, &$c($prev, |@list.splice(0,$c.arity-1)), @list) !! $prev }; sub Reduce(Code $c, $a) { TheReduce($c, |$a.list) };  say Reduce({ $^a+$^b * $^c}, 1..8);

[14:36] <p6eval> rakudo 2d5f15: OUTPUT«too few arguments passed (2) - 3 params expected␤current instr.: '_block71' pc 557 (EVAL_19:181)␤»

[14:37] <bacek_> And even works as yet-to-be-specced :)

[14:37] <bacek_> rakudo: sub TheReduce(Code $c, $prev, *@list is rw) { +@list ?? TheReduce($c, &$c($prev, |@list.splice(0,$c.arity-1)), @list) !! $prev }; sub Reduce(Code $c, $a) { TheReduce($c, |$a.list) };  say Reduce( -> $a, $b, $c? { $a+$b * ($c//1)}, 1..8);

[14:37] <pmurias> an

[14:37] <p6eval> rakudo 2d5f15: OUTPUT«36␤»

[14:39] <bacek_> rakudo: sub TheReduce(Code $c, $prev, *@list is rw) { @list ?? TheReduce($c, &$c($prev, |@list.splice(0,$c.count-1)), @list) !! $prev }; sub Reduce(Code $c, $a) { TheReduce($c, |$a.list) };  say Reduce( -> $a, $b, $c? { $a+$b * ($c//1)}, 1..8);

[14:39] <p6eval> rakudo 2d5f15: OUTPUT«77␤»

[14:39] <bacek_> Is .tailcall "cheap" in parrot?

[14:42] *** c9s__ left
[14:45] <pmichaud> regardless of whether it's cheap, I'm not a fan of a recursive reduce implementation.

[14:45] *** rodi joined
[14:46] <bacek_> It's just for fun :)

[14:47] *** c9s__ joined
[14:49] *** pmurias left
[14:53] <dalek> rakudo: 065175b | pmichaud++ | docs/spectest-progress.csv:

[14:53] <dalek> rakudo: spectest-progress.csv update: 317 files, 7124 passing, 0 failing

[14:53] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/065175b26fbb9d2af5ed61e42575b749ba5cd39f

[14:55] *** c9s__ left
[14:56] *** c9s___ left
[14:57] <bacek_> pmichaud: is this http://nopaste.snit.ch/15830 better?

[14:59] <pmichaud> bacek_: no, because it's modifying the invocant.

[14:59] *** c9s___ joined
[15:00] <bacek_> pmichaud: otherwise it will require .list. Will it lead to eager flattening?

[15:01] <pmichaud> .list isn't eager.

[15:01] <moritz_> rakudo: my $s = sub ($x, $y!, $z) { ... }; say $s.count

[15:01] <p6eval> rakudo 065175: OUTPUT«3␤»

[15:01] <bacek_> pmichaud: ah. ok

[15:01] <pmichaud> rakudo:  ( -> $a, $b? $c? { ... } ).count.say

[15:02] <p6eval> rakudo 065175: OUTPUT«Syntax error at line 1, near "( -> $a, $"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[15:02] <pmichaud> rakudo:  ( -> $a, $b?, $c? { ... } ).count.say

[15:02] <p6eval> rakudo 065175: OUTPUT«3␤»

[15:02] <pmichaud> rakudo:  ( -> $a, $b?, $c? { ... } ).arity.say

[15:02] <p6eval> rakudo 065175: OUTPUT«1␤»

[15:03] *** frioux joined
[15:03] *** PZt joined
[15:03] <masak> rakudo:  -> $a, $b?, $c? { ... }.count.say

[15:03] <p6eval> rakudo 065175: OUTPUT«3␤»

[15:03] <masak> parens redundant.

[15:03] <pmichaud> when in doubt, add parens.  :-)

[15:04] <masak> I guess I'm simply not in doubt, then. :)

[15:04] <pmichaud> perhaps.  I always vote for what's clearer to read.

[15:04] *** eternaleye left
[15:04] <masak> that's a bit subjective, though.

[15:04] <pmichaud> having a term with spaces receive a .method just seems odd

[15:05] <pugs_svn> r25758 | bacek++ | [t/spec] Added test for List.reduce with optional args.

[15:05] *** bacek_ is now known as bacek

[15:05] <pugs_svn> r25759 | moritz++ | [t/spec] tests for .count on subs

[15:05] <bacek> pmichaud: and this one? http://nopaste.snit.ch/15831

[15:05] <masak> pmichaud: if you say so. I don't find that harder to read than terms without spaces. but nevermind.

[15:05] <moritz_> pmichaud: two of the new tests fail, and I have no idea why

[15:06] <moritz_> did I mess up something fairly obvious?

[15:06] <pmichaud> moritz_: in r25759?

[15:06] <moritz_> yes

[15:06] <pmichaud> looking.

[15:07] <pmichaud> I don't know if named params count.

[15:07] <pmichaud> i.e., I think .count might be only for positionals.

[15:08] <moritz_> might be

[15:08] <moritz_> ie we need specs

[15:08] <pmichaud> clearly:    sub foo($a, :$b) { ... };    foo(1,2);    #fail

[15:08] <moritz_> right

[15:08] <pmichaud> in the example I just gave, foo can take only one positional argument.

[15:09] <pmichaud> so I'd think   .count == 1

[15:09] <moritz_> rakudo: (-> $a, :$b! { ... }).arity.say

[15:09] <p6eval> rakudo 065175: OUTPUT«2␤»

[15:09] <moritz_> we should be consistent

[15:09] <pmichaud> I think that's the parrot named argument bug there.

[15:09] <pmichaud> Parrot has a (serious) bug in that it treats named arguments as positionals.

[15:10] <pmichaud> and there's not a way to turn that off yet.

[15:10] <bacek> rakudo:  +(-> $a, :$b! { ... }).signature.params

[15:10] <p6eval> rakudo 065175: RESULT«2»

[15:10] <bacek> rakudo:  +(-> $a, :$b! { ... }).count

[15:10] <pmichaud> I might be able to get signature.arity and signature.count to dtrt, though.

[15:10] <p6eval> rakudo 065175: RESULT«1»

[15:11] <pmichaud> it's tough to rely on .signature because non-rakudo subs don't have a .signature.

[15:11] <masak> why not?

[15:11] <pmichaud> because Parrot subs don't have signatures?

[15:12] <masak> hm.

[15:12] <bacek> Let's rewrite everything in Perl6 using Q:PIR!

[15:12] <masak> fair point.

[15:12] * bacek hides

[15:12] *** nihiliad joined
[15:13] <pmichaud> bacek: with    my @list = $values.list;    we're still creating an Array.  I'd prefer to see   my $list = $values.list;   or   my $list := $values.list;     to avoid that.

[15:13] <pmichaud> Also, why do people have an aversion to 'self' ?

[15:14] <pmichaud> I think that   self.list  reads far more clearly than $values.list

[15:15] <bacek> Because it's in spec. I prefer self.list too

[15:15] <pmichaud> The S29/S32 spec should be considered "provisional" in many respects.

[15:16] <pmichaud> even if $values is given in S32, self.list is still valid in the body of the code.

[15:18] <pmichaud> afk for a bit.

[15:19] *** PacoLinux joined
[15:19] *** NoirSoldats left
[15:21] * masak doesn't have an aversion to 'self', he just forgets to write it often

[15:21] <moritz_> you can even write  @.list

[15:21] <masak> I know.

[15:22] <masak> the problem is not that I don't like to write 'self'.

[15:22] <masak> the problem is that I forget I need to.

[15:23] <pugs_svn> r25760 | bacek++ | [t/spec] Put explicit undef as last argument of n-ary List.reduce

[15:23] <moritz_> rakudo: class Any is also { method listsay { .say for @.list } }; <a b c>.listsay; 3.listsay

[15:23] <p6eval> rakudo 065175: OUTPUT«a␤b␤c␤3␤»

[15:23] <moritz_> woot

[15:23] <moritz_> it even works :-)

[15:24] <moritz_> that could simplify some built-in methods

[15:24] <bacek> pmichaud: http://nopaste.snit.ch/15832 this is latest attempt.

[15:24] <bacek> afk & sleep.

[15:24] <bacek> 2:30 here. 

[15:28] *** NoirSoldats joined
[15:33] *** NoirSoldats left
[15:37] *** frioux left
[15:38] *** frioux joined
[15:38] *** NoirSoldats joined
[15:39] *** mikehh joined
[15:45] *** ingy joined
[15:45] <dalek> rakudo: d16d3c3 | pmichaud++ | src/classes/Code.pir:

[15:45] <dalek> rakudo: Temporary fix to get .signature to work on ObjectRefs (fixes RT #63744).

[15:45] <dalek> rakudo: The correct fix will likely be to have method dispatch

[15:45] <dalek> rakudo: dereference objects prior to dispatch.

[15:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d16d3c3baf3ba722a759c524cae4a77a1e9a95d5

[15:51] *** justatheory joined
[15:51] *** Tene_ joined
[15:59] *** [particle] joined
[15:59] *** pmurias joined
[15:59] <diakopter> pmurias: hi

[16:00] <TimToady> do we need a primitive way to match a Signature against an Iterator? which presumably iterates the iterator only if the signature matches, and to the extent it matches?

[16:00] <TimToady> and that explicitly says its okay to leave more values in the Iterator?

[16:01] <TimToady> *it's

[16:01] <diakopter> "why not?"

[16:01] *** moritz_ sets mode: +o TimToady

[16:01] <moritz_> TimToady: that was the easy part. now you have to come up with a syntax :-)

[16:01] <TimToady> that's not the question you're supposed to ask when you're designing

[16:01] *** Tene left
[16:01] <TimToady> or not the only question...

[16:02] <TimToady> you also need a good answer for "why?"

[16:02] <TimToady> but in this case it seems as though people are struggling to invent these semantics in terms of current syntax

[16:02] <moritz_> because that's what map, grep, reduce and similar methods all need

[16:02] <TimToady> so perhaps there's something missing

[16:03] <diakopter> i know; kidding. :D   a method on Iterator or a method on Signature? or a sub?

[16:03] <TimToady> well, Iterator.nibble(Signature) is probably good enough

[16:03] <moritz_> what does 'nibble' mean?

[16:03] <diakopter> don't bite off more than you can chew?

[16:03] <moritz_> chop off, byte by byte?

[16:04] <rodi> "look at the next one, bite only if it matches"

[16:04] <TimToady> well, I guess the question is whether .ACCEPTS should be doing it

[16:04] <TimToady> but it seems like the default match of a signature should want to match everything

[16:05] <rodi> moritz_: I think Knuth calls what you described a "nybble" :-P

[16:05] <TimToady> we could have an explicit marker in a signature that says "okay to have more args here", but then we'd have to modify the user's sig in map et al.

[16:05] <TimToady> nybble is half a byte

[16:07] <ruoso> TimToady, once an iterator is consumed, there's no turning back

[16:07] <ruoso> it's the role of a "lazy list" to keep the consumed values stored

[16:07] <TimToady> indeed, but that argues for a primitive that can try to match without consuming until "commit" point

[16:08] <ruoso> what do you mean by "commit" point/

[16:08] <ruoso> ?

[16:08] *** NoirSoldats left
[16:08] <TimToady> the point at which the signature is happy with the match

[16:08] <TimToady> it's a transaction that either succeeds or fails

[16:08] <diakopter> peek

[16:08] <ruoso> well, there only way a signature can match an iterator without consuming it

[16:08] <TimToady> or pushback

[16:08] <ruoso> is for it to be *@items

[16:09] <TimToady> *@items should consume it

[16:09] <ruoso> no, it binds lazily as well

[16:09] <TimToady> well, semantically it consumes it

[16:09] <ruoso> ok, we're talking about different things then

[16:09] <ruoso> let's take a practical scenario

[16:09] <TimToady> the iterator should report "done" after handing off the rest to @items

[16:09] *** [particle]2 joined
[16:09] *** NoirSoldats joined
[16:10] <ruoso> let's assume our iterator is reading from a pipe and splitting using IFS/IRS

[16:10] <pugs_svn> r25761 | dankogai++ | updated to Cabal-1.6.0.2

[16:10] <masak> TimToady: do I need to do 'augment' when re-opening modules?

[16:10] <ruoso> either you created a lazy list from that iterator

[16:10] <ruoso> which will store the consumed items

[16:10] <TimToady> masak: yes, I think

[16:11] <masak> ok.

[16:11] *** M_o_C joined
[16:11] <ruoso> but if you don't have such a lazy list, the item you consumed is not stored anywhere else

[16:11] <ruoso> and a pipe doesn't accept undo

[16:11] <masak> TimToady: S11:365: use Dog:ver(Any):auth({ .substr(0,5) eq 'cpan:'}) -- why 'Any' and not '*' or 'Whatever'?

[16:12] <TimToady> fossil

[16:12] <pugs_svn> r25762 | dankogai++ | updated to HTTP-4000.0.4

[16:12] <TimToady> that was written before * existed

[16:12] <masak> ah.

[16:13] <ruoso> TimToady, I think I'm looking at a barrier you're not

[16:13] <ruoso> TimToady, I see a barrier between the iterator itself and the lazy list that is being used as a proxy

[16:14] <TimToady> well, I'm not picky, if matching Signature against a lazy list is good enough for map etc.

[16:14] <TimToady> but somewhere we need that transactional support

[16:14] <ruoso> TimToady, pipes are not transactional

[16:14] <TimToady> and the bit that says it's okay to leave more stuff

[16:14] <pugs_svn> r25763 | dankogai++ | updated to zlib-0.5.0.0

[16:14] <TimToady> but pipe handles can be, if they support pushback

[16:15] <diakopter> TimToady: so, it treats it as immutable until it matches, then it actually consumes all those up to the commit point?  or just the ones that matched?

[16:15] <ruoso> then it's a lazy list that talks to that iterator, that's what I mean

[16:15] <ruoso> or a lazy scalar of some sort

[16:15] <ruoso> that happens to also be an Iterator

[16:17] *** NoirSoldats left
[16:17] <TimToady> I don't care what does it, but we have to support partial signature matching suffiently well to know whether we ran out of arguments in mid-signature, or ran out of signature in mid arguments, or they came out even

[16:18] <TimToady> and in each case, retain enough control to Do The Right Thing for whatever the current operator is, map, reduce, whatever

[16:18] <ruoso> for that matter, lazy lists seems to suffice

[16:19] <TimToady> List ~~ Signature should fail on partial match by default, it seems like

[16:20] <masak> rakudo: say "abcdefgh".substr(*-2) # would it be unreasonable to make this work like the .[*-2] case?

[16:20] <p6eval> rakudo d16d3c: OUTPUT«Use of uninitialized value␤gh␤»

[16:20] <pugs_svn> r25764 | dankogai++ | updated to cabal-install-0.6.2

[16:20] <ruoso> TimToady, a partial Signature match is not a match... is it?

[16:20] <TimToady> so we need some API to say not to do the default of "match all"

[16:21] <ruoso> isn't that declaring arguments as optional?

[16:21] <TimToady> Capture ~~ Signature is certainly "match all" semantics

[16:21] <ruoso> ahhhh

[16:21] <ruoso> I see what you mean

[16:21] <moritz_> maybe with | on one side?

[16:21] <TimToady> no, it's declaring the rest of the list as optional

[16:21] <TimToady> I don't think we want to modify the Signature to do it

[16:22] <pmichaud> agreed, modifying the signature seems wrongish.

[16:22] <ruoso> I always assumed the operators that did this were fetching n args from the list

[16:22] <TimToady> but it's also declaring it as transactional, so it doesn't eat any of the list if the match fails

[16:22] <ruoso> depending on the arity of the code

[16:22] <TimToady> see overnight discussion above

[16:23] <TimToady> nobody is having good success doing the transaction right in terms of current primitives

[16:23] <TimToady> nobody is thinking about the rollback part of it

[16:24] <pmichaud> correct.

[16:24] <pmichaud> agreed.

[16:24] *** [particle] left
[16:25] <TimToady> if signature matching is to be useful in the general case, we have to handle this correctly, or it would be like regex that randomly put the pos in the wrong place on backtracking

[16:25] <moritz_> maybe we could have a @(signature) form that creates an object that slices a list into captures?

[16:25] <ruoso> honestly, I've been neglecting transactions 

[16:25] <pmichaud> feels like it ought to be a method like 'map'; indeed, it's probably the foundation for map/reduce/etc.

[16:25] *** ejs joined
[16:25] <moritz_> I don't think it's easy to build reduce on top of map

[16:25] *** rkendall left
[16:26] <pmichaud> moritz_: I agree, which is why I think there's something else that map and reduce and grep are built on top of.

[16:26] <TimToady> well think about it guys, I have to go get ready for $work

[16:26] <ruoso> hmmm

[16:26] <ruoso> maybe Iterator itself provides a method to match a signature

[16:27] <ruoso> ok... this is where TimToady started few minutes ago

[16:27] * ruoso looping

[16:27] <pmichaud> perhaps we have a 'map'-ish method on Iterator

[16:29] <ruoso> pmichaud, the thing is that we shouldn't require iterators to be transational

[16:29] <diakopter> iterators (that do work that can't be rolled back (to generate/pump each item)) need to cache the results in case the signature gives up, and iterators whose (possibly lazy) feeds are state-dependent shouldn't do that at all

[16:29] <pmichaud> the method could be transactional without the iterator having to be.

[16:30] *** pmurias left
[16:30] <ruoso> ok... lazy lists do fullfit that part

[16:30] * ruoso needs to read the overnight discussino

[16:32] *** masak left
[16:33] * ruoso can't find it... any link?

[16:33] <pmichaud> it's primarily in scrollback on #perl6

[16:33] <pmichaud> the stuff about implementing .reduce in Perl 6

[16:33] <moritz_> maybe TimToady also meant the p6l thread?

[16:34] <pmichaud> possibly, but there's not a lot of detail there other than how map/reduce should handle argument lists that aren't multiples of some function of the arity

[16:34] <pmichaud> at any rate, the p6l thread is http://groups.google.com/group/perl.perl6.language/browse_thread/thread/552d77f581cb8940#

[16:36] <ruoso> hmmm... that doesn't seem to explain why each implementation of such features to use the arity of the code to fetch elements from the input

[16:37] <ruoso> er... why that would be a bad idea, i mean

[16:37] <diakopter> to support this, each Iterator needs to know whether its generating function 1) supports rollback 2) supports redo (if anything the function invokes is not deterministic) and 3) is pure (stronger version of supporting redo)

[16:38] <ruoso> but I think using it as a lazy list seems very much ok

[16:39] <ruoso> because then the iterator doesn't need to handle redo

[16:39] <ruoso> nor anything else

[16:39] <ruoso> the lazy list consumes the iterator, but the values won't go away

[16:40] <ruoso> but I think we have other question here

[16:40] <ruoso> which is how to say to the binding process

[16:40] <ruoso> "try to bind as many as possible, returning what's left"

[16:42] <diakopter> but if you're trying a succession of signatures... 

[16:42] <diakopter> hm

[16:42] <ruoso> using lazy lists

[16:42] <ruoso> so, if that doesn't suceed, you simply use the one you sent before

[16:43] <ruoso> the real question then is...

[16:43] <ruoso> is the Signature responsible for the binding?

[16:43] <ruoso> hmm

[16:44] <ruoso> actually

[16:44] <ruoso> Signature.ACCEPTS might set $?

[16:44] <ruoso> sorry

[16:44] <ruoso> $/

[16:46] *** mikehh left
[16:47] <ruoso> then, if successfull, the match object would say how many items it matched

[16:49] *** mikehh joined
[16:53] <ruoso> and in fact, you could even call &code.(|$/) 

[16:54] *** bacek left
[16:57] *** Exodist joined
[17:00] *** namenlos left
[17:01] *** namenlos joined
[17:01] *** krunen left
[17:02] *** bacek joined
[17:06] *** namenlos left
[17:07] *** PacoLinux left
[17:07] *** namenlos joined
[17:14] *** finanalyst joined
[17:14] *** jferrero joined
[17:15] <pugs_svn> r25765 | dankogai++ | updated to Cabal-1.6.0.2

[17:16] *** c9s___ left
[17:18] *** cspencer joined
[17:24] *** pmurias joined
[17:25] <pmurias> diakopter: hi

[17:26] <cspencer> moritz_: ping

[17:26] <lambdabot> cspencer: You have 1 new message. '/msg lambdabot @messages' to read it.

[17:27] <moritz_> cspencer: pong

[17:28] <cspencer> moritz_: looks like you beat me to the map/pairs fixes

[17:28] <moritz_> cspencer: I did indeed

[17:28] <cspencer> i've got a question re: the implementation though

[17:29] <moritz_> shoot

[17:29] <cspencer> if i remember correctly, pmichaud was concerned about the laziness of lists being affected by various things in the old implementation

[17:29] <cspencer> ie) expanding the list out in full 

[17:30] <moritz_> right

[17:31] <cspencer> in the pairs method, in the case that @indices was defined, if we did something like "for (@indices Z self.list[|@indices]) ...." instead of iterating over the whole list, is that a bad thing?

[17:31] <cspencer> ie) will that cause the list to be fully flattened out?

[17:32] <moritz_> that wasn't the concern in the .pairs method

[17:32] <cspencer> ah ok

[17:32] <moritz_> the concern was in the .map method

[17:32] <cspencer> oh, that was with map

[17:32] <cspencer> right

[17:32] <moritz_> where you used @array.end

[17:32] <cspencer> i'm getting my concerns muddled here :)

[17:32] <moritz_> that's... concerning ;-)

[17:32] <cspencer> it is indeed ;)

[17:33] <pugs_svn> r25766 | dankogai++ | updated to Cabal-1.6.0.2

[17:34] <moritz_> anyway, i'm updating the self.list things to @.list

[17:34] <moritz_> it's the same, just a bit more ideomatic

[17:34] <pmichaud> looks nicer, too.

[17:34] <cspencer> alrighty

[17:35] <cspencer> what does the "@." do? 

[17:35] <cspencer> does it access self in a list context?

[17:35] <pmichaud> $.list calls self.list in scalar context

[17:35] <pmichaud> @.list calls self.list in list context

[17:35] <lambdabot> No module "calls self.list in list context" loaded

[17:36] <moritz_> lambdabot: shut up

[17:36] *** moritz_ sets mode: +v lambdabot

[17:36] <cspencer> ok :)

[17:38] <pmichaud> afk, lunch

[17:48] <mikehh> built rakudo on parrot r37239 linux AMD64 spectests pass - t/spec/S32-list/reduce.rakudo TODO passed:   14

[17:50] <moritz_> same here

[17:51] *** PacoLinux joined
[17:52] <mikehh> make spectest took 37 min

[17:52] <moritz_> I compile parrot with --optimize, that makes it a bit faster

[17:54] <mikehh> I also use --optimize - took me 35 min on linux i386

[17:54] <pasteling> "ruoso" at 201.45.49.162 pasted "role ideas for the web.pm framework..." (156 lines, 3.9K) at http://sial.org/pbot/35421

[17:57] <mikehh> back in the days we had threading working it used to take just over 10 minutes

[17:58] *** AndyAway is now known as alester

[18:10] <moritz_> takes 17min here for one pass... you need to buy a faster computer ;-)

[18:10] *** jferrero left
[18:11] *** araujo joined
[18:12] <mikehh> more memory would probably help too

[18:12] <moritz_> does it swap?

[18:12] <moritz_> bbl

[18:14] *** ujwalic left
[18:14] <mikehh> not that I noticed - its an old Pentium D dual core with 2GB - I am trying for a quad core with a minimum of 4GB

[18:16] <dalek> rakudo: 960d251 | (Moritz Lenz)++ | src/setting/Any-list.pm:

[18:16] <dalek> rakudo: [setting] replace self.list with @.list in some places

[18:16] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/960d251759f8939a82763bdf7d82bbb2398a27b4

[18:17] <mikehh> my son has one my DIL just got one - I am waiting 'cos I only run Linux

[18:18] *** pmurias left
[18:23] <ruoso> can I do a ~~ inside a closure inside a regex and get it as a part of the match?

[18:23] <ruoso>  / bla { $foo ~~ $bar } ble /

[18:23] <ruoso> I see it will execute

[18:23] <ruoso> and if the block returns false, I think it will stop processing

[18:23] <ruoso> but... will it take the $/ set inside the block?

[18:24] <ruoso> basically

[18:24] <ruoso> I have a Pattern

[18:24] <ruoso> how do I use it inside a regex so that it integrates with the matching

[18:25] <ruoso> (i.e., $/.to, $/.from etc

[18:28] <TimToady> why isn't it just / bla $bar ble /?

[18:28] <TimToady> if $bar is a Regex, it should dwym

[18:28] <TimToady> bare {...} pays no attention to the bool return value, btw

[18:28] <TimToady> it's used only for side effects

[18:29] <TimToady> <?{...}> runs an assertion

[18:31] *** c9s__ joined
[18:31] *** schmalbe joined
[18:32] *** Psyche^ joined
[18:33] <TimToady> but STD does things like $¢ = $*PARSER.bless($¢); to change the current cursor

[18:34] <TimToady> which is not exactly single assignment...

[18:35] *** justatheory left
[18:35] *** justatheory joined
[18:39] *** mikehh left
[18:39] *** mikehh joined
[18:41] <ruoso> TimToady, consider I start to use Match objects to match in other places then regexes

[18:42] <ruoso> but then I want to mix using those (usually Patterns) with regex

[18:43] <ruoso> that would allow me to write something that would take part in matching, but is written as a simple ACCEPTS method

[18:43] <ruoso> that sets $/ and returns bool

[18:45] <TimToady> I almost never want to deal with $/ in STD; it's usually better to deal with cursors, because $/ is one level too "global", and $/ doesn't really understand everything a cursor needs to know, like what the current language is

[18:45] <ruoso> right... so, any idea on how to solve my problem?

[18:47] <TimToady> in theory positions are opaque, so you need something typologically correct to translate the submatch's idea of position into the surrounding Cursor's notion of position

[18:48] <TimToady> that being said, STD just uses codepoint positions :)

[18:48] <TimToady> because it's really just the p5 subset of p6 that STD is written in, more or less

[18:49] <TimToady> at least, the parts that don't end up being emulated by Cursor.pmc

[18:49] *** Patterner left
[18:49] *** Psyche^ is now known as Patterner

[18:49] <ruoso> so, having a way to call a closure that should leave $/ set on sucess is not that bad, is it?

[18:50] <ruoso> or at leasy

[18:50] *** dusty joined
[18:50] <ruoso> *least

[18:50] <ruoso> to use a Pattern object as part of the match

[18:50] <ruoso> where it should set CALLER::<$/>

[18:51] <TimToady> then your closure needs to extract the positional information from that and generate a new $¢ from the old one

[18:51] <ruoso> I mean having a syntax to hide that

[18:52] <TimToady> (btw, $/ turns into $M in STD.pmc)

[18:52] <TimToady> I don't think it's worth it witout more use cases to look at

[18:52] <ruoso>  something{   $_ starts at pos, and closure sets $/   }

[18:53] <ruoso>  or something<$pattern-object>

[18:53] <ruoso> that would call ACCEPTS on $pattern-object sending $_ starting on current position

[18:53] <TimToady> I'm not saying it won't be worth it eventually, but we need to see the actual usage patterns to know what the best sugar would be, or whether it occurs huffmanly often enough to deserve sugar

[18:53] *** armagad left
[18:54] <ruoso> TimToady, my use case is about matching a string against an arbitrary data structure...

[18:54] <ruoso> in this case

[18:54] <TimToady> I should probably get rid of $¢ = $*PARSER.bless($¢); though in any case

[18:54] <ruoso> a url

[18:54] <ruoso> against a linked list of objects

[18:55] *** dusty left
[18:56] <TimToady> right now you can just say $¢ = $¢.cursor($newpos) to set the new position, in STDese

[18:57] <ruoso> ok.. but that's not really Perl 6...

[18:57] <TimToady> yes it is

[18:57] <TimToady> $¢ is specced somewhere

[18:59] <ruoso> but ideally it would create an entire submatch, wouldn't it?

[18:59] <ruoso> how could it do that?

[19:00] <TimToady> S05:800

[19:00] <TimToady> well, same way STD does, presumably :)

[19:00] <TimToady> it's all just method calls...

[19:01] <TimToady> we can argue about the names of the method calls, of course

[19:01] <TimToady> but Cursor should be considered somewhat canonical in the same way that STD itself is

[19:03] *** nihiliad left
[19:04] <TimToady> Cursor uses variants of .SUBSUME to attach a submatch

[19:04] <ruoso> hmmm...

[19:04] <ruoso> I think I just had a better idea for the specific problem I'm dealing with

[19:05] <ruoso> which is to pre-build a regex representing the entire data structure

[19:05] <TimToady> depends on which kind of lazy you're aiming at :)

[19:05] <TimToady> if you can cache it, it's probably worth prebuilding

[19:06] <ruoso> yeah... the specific case of URL ~~ ChainedAction seems fine to prebuild

[19:06] <TimToady> also depends on the pass/fail statistics

[19:06] <ruoso> but there are cases where matching against a data structure will be indeed interesting

[19:06] <TimToady> "we'll burn that bridge when we get to it", as they say...

[19:08] <ruoso> does / ^ $.foo / mean " the value returned by $.foo at the start of the string? or do ^ mean something else now 

[19:08] <ruoso> ?

[19:09] <ruoso> or is that just plain wrong?

[19:10] *** nihiliad joined
[19:10] <TimToady> $.foo is a perfectly fine variabl name, as far as the regex is concerned

[19:10] *** c9s__ left
[19:10] <TimToady> so it's just like / ^ $foo /

[19:10] *** c9s__ joined
[19:10] <TimToady> that is, match whatever $foo matches at the start of the string

[19:11] <TimToady> use ^^ for start of line

[19:11] <TimToady> $ for end of string, $$ for end of line

[19:11] *** japhb left
[19:11] <ruoso> right

[19:12] <TimToady> std: / ^ $.foo /

[19:12] <p6eval> std 25766: OUTPUT«ok 00:02 34m␤»

[19:16] <ruoso> TimToady, so, if $regex contains a capture, will it be in a submatch of / foo $bar baz / ? or does it look like "in-line"?

[19:17] <TimToady> I don't understand your question at all

[19:17] <TimToady> did you mean if $bar contains a capture

[19:17] <TimToady> if $bar is a string it's just matched inline like a literal

[19:18] <ruoso> $bar = / (positional) $<named> := bar /;

[19:18] <ruoso> "foo positional bar baz" ~~ / foo $bar baz /

[19:19] <TimToady> that's matched inline unless you do $<newname> := $bar

[19:19] <ruoso> right...

[19:19] <ruoso> thankfully, that was what I expected ;)

[19:19] <TimToady> or <newname=$bar>

[19:20] <TimToady> should generally use the <$bar> form if you expect a regex rather than a string, just for documentation

[19:20] <TimToady> but it's still anonymous because of the $ in front

[19:21] <TimToady> same way that <.foo> makes <foo> anonymous, really

[19:22] <ruoso> cool

[19:22] <ruoso> so if I "return $url ~~ $regex" in the end, it will return all the captured values

[19:22] <ruoso> looks just fine

[19:26] <TimToady> also ($bar) will capture submatches in $0, though STD makes little use of this

[19:28] <ruoso> so then I use the match as argument to the methods in the (|$/) form

[19:32] <pasteling> "ruoso" at 201.45.49.162 pasted "updated role ideas for the web.pm framework..." (163 lines, 4.1K) at http://sial.org/pbot/35424

[19:36] <ruoso> TimToady, if you look at the code I pasted, you'll see that I build a lot of regexes, and then use a for loop to try to match each option...

[19:36] <ruoso> presumably, if this was all set into a single grammar

[19:37] <ruoso> an optimizer would be able to reuse match parts (considering the start is very much similar for a lot of regexes)

[19:37] <ruoso> is there a way to build in runtime a regex that would do that as a single match?

[19:39] *** M_o_C left
[19:40] <ruoso> considering I re-use the same regex object all over the place, it should be fairly optimizable

[19:43] *** c9s__ left
[19:43] <skids> ruoso: also that might be useful to abuse regex as a trie where you add a rule into a regex for every value you want to add to it, and occasionally somehow ask for the regex to be recompiled.

[19:44] <skids> That kinda inverts code and data though.

[19:45] <ruoso> skids, I would actually assume that when you do /foo $bar baz/ it would be free to optimize as much as it wans

[19:46] <ruoso> so if I'm reusing $bar in a lot of regexes

[19:46] <ruoso> it should be able to optimize it

[19:46] *** japhb joined
[19:48] <ruoso> TimToady, in that code, I'd like to have a token in the end that would look like / [ $regex1 { make $action1 } | $regex2 { make $action2 } | ... ]/

[19:48] <ruoso> but that can only be composed programatically,

[19:48] <skids> ruoso: Oh I guess we're not really talking about the same thing.  I thought you were asking about collapsing dynamically built up regexe.

[19:48] <ruoso> We are

[19:49] <ruoso> I'm just assuming it is free to collapse it as  it pleases

[19:50] <pugs_svn> r25767 | pmichaud++ | [spec]:  Update S05: remove <word>, add <ww>, revise <wb>, <ws>, <space>, and <blank>.

[19:55] *** NoirSoldats joined
[19:57] *** c9s__ joined
[20:06] *** icwiener joined
[20:07] *** c9s__ left
[20:11] <dalek> rakudo: d8a1926 | pmichaud++ | docs/guide_to_setting.pod:

[20:11] <dalek> rakudo: Some refinements to guide_to_setting.pod .

[20:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d8a192619260649c19d1779e98bcd1dbbccb738e

[20:12] <ruoso> TimToady, if <$bar> in-lines a Regex object... could <@bar> inline several?

[20:16] <alester> Itr drives me nuts that you have to check for $hash{key}'s existence in PHP.

[20:16] <alester> I'm going to cry from overtyping.

[20:17] <pmichaud> ...check for $hash{key}'s existence?

[20:17] <ruoso> TimToady, while <@bar> would mean the same as [<$bar[0]>|<$bar[1]>|<$bar[2]>]

[20:17] <pmichaud> ruoso: <@bar>:  each element is treated as a subrule

[20:18] <ruoso> with OR or AND?

[20:18] <pmichaud> OR -- same as @bar without the <...>

[20:18] <ruoso> cool

[20:18] <pmichaud> S05:1283

[20:18] <ruoso> it's fun when things works according to your expectations...

[20:18] <pmichaud> but they aren't "inlined" -- they're subrule calls.

[20:19] <ruoso> Ok, it doesn't change much, since each of them is going to have a { make ... }

[20:19] <pmichaud> in particular, by default they're non-capturing subrule calls.

[20:20] <pmichaud> so if they have a { make ... }   then the results need to be captured somewhere.

[20:21] *** NoirSoldats left
[20:22] <ruoso> hmm

[20:22] <ruoso> but if I do $<foo> := <@bar>

[20:22] <ruoso> does it capture ir?

[20:22] <pmichaud> yes, it should.

[20:23] <pmichaud> I suspect that   <foo=@bar>  would also work.

[20:23] <ruoso> hmm

[20:24] <ruoso> now consider I want both the value returned by "make"

[20:24] <ruoso> and the sub-match for each item of @bar

[20:24] <pmichaud> it's an alternation, so only one item of @bar matches.

[20:25] <ruoso> right... I meant that one, actually...

[20:25] <pmichaud> the thing that <@bar> matched would be $<foo>

[20:25] <pmichaud> the value returned by make would be $<foo><?>

[20:25] <ruoso> right

[20:27] <ruoso> while the submatch would still be $<foo>

[20:27] <pmichaud> correct.

[20:29] <ruoso> so... my $regexN = / something { make 'bla' } /; my @regexes = ($regexN,...); my $rx = / $<foo> := <@regexes>/; if $foo ~~ $rx { say $<foo>; say $<foo><?> }

[20:30] <pmichaud> keeping in mind that   say $<foo>  and   say $<foo><?>  will produce the same result.

[20:31] *** NoirSoldats joined
[20:31] <ruoso> right... but if "something" actually was a match that had another captures

[20:31] <ruoso> would I still be able to access that captures?

[20:31] <pmichaud> sure, you can access the captures through $<foo>   (more)

[20:32] <pmichaud> but stringifying $<foo> will give you its stringified result object by default.

[20:32] <ruoso> ok

[20:32] <pmichaud> if you want the text of whatever matched, use   $<foo>.text

[20:32] *** schmalbe left
[20:35] <pmichaud> it's all described at S05:2373

[20:37] *** NoirSoldats left
[20:38] *** cspencer left
[20:40] <pasteling> "ruoso" at 201.45.49.162 pasted "yet another version of the ideas for the web.pm framework" (168 lines, 4.2K) at http://sial.org/pbot/35425

[20:40] <ruoso> pmichaud, Dispatcher.compile in the pasted code above is the code that tries to do that... would you mind taking a look to see if it's ok?

[20:41] <pmichaud> looking 

[20:41] <pmichaud> depends on what you mean by "freezes the regexes"

[20:42] <ruoso> it means it will, only once, generate the regex to match URL x ChainedAction

[20:42] <ruoso> which is used in the "dispatch" method, just below

[20:43] <pmichaud> but yes, since the $.regex is effectively a closure, it should continue to refer to whatever values were in @subregexes at the time it was captured.

[20:43] <pmichaud> in particular, if I have

[20:43] *** mberends joined
[20:43] <pmichaud>    my @a = ...;   my $regex = / <@a> /;    @a[1] = ...;    'xyz' ~~ $regex

[20:43] <pmichaud> then the match will use whatever value of @a[1] is in the second assignment

[20:44] <ruoso> right... but since any other reference to that value is lost... it ends up "almost" read-only

[20:44] <pmichaud> correct.

[20:45] *** Tene_ is now known as Tene

[20:45] <pmichaud> I wonder if |$<action>  will also include '?' as a named parameter.

[20:46] <ruoso> is there a way to test it?

[20:47] <pmichaud> not at present... but naively I would expect   %($<action>) to include all of the elements in its hash interface, which would include <?>

[20:47] <ruoso> so it'd be better if I add an inner capture to avoid it

[20:47] <pmichaud> or we might want some confirmation/clarification from TimToady

[20:49] <ruoso>  / $<foo> := [ foo bar <baz ] / is valid, right?

[20:49] <ruoso> oops

[20:49] <ruoso> *<baz> that is

[20:49] <pmichaud> yes.

[20:49] <pmichaud> you end up with both $<foo> and $<baz>

[20:49] <ruoso> I mean... I can bind a non-capturing group to a capture variable

[20:49] *** Kimtaro_ joined
[20:49] *** Kimtaro_ left
[20:49] <pmichaud> $<foo> := [ foo bar <baz> ]  means that $<foo> will capture the text inside of the brackets

[20:49] <ruoso> but not the submatch?

[20:50] <pmichaud> the sub match would be $<baz>

[20:50] <pmichaud> if you want the submatch to be inside of $<foo>, it's

[20:50] <ruoso> right... so I should use ( ) then

[20:50] <pmichaud> $<foo> := ..... right, what you wrote.

[20:50] <pmichaud> with ( )   it's  $<foo><baz>

[20:50] <pmichaud> I have to go pick up kids from school... bbi30

[20:50] <pasteling> "ruoso" at 201.45.49.162 pasted "even yet another version of the ideas for the web.pm framework" (167 lines, 4.3K) at http://sial.org/pbot/35426

[20:51] <pmichaud> your basic approach seems workable, at any rate.

[20:51] <ruoso> pmichaud, thanks for the input

[21:02] *** meppl joined
[21:05] *** nihiliad left
[21:07] *** Kimtaro left
[21:07] *** araujo left
[21:07] *** NoirSoldats joined
[21:10] *** araujo joined
[21:19] <ruoso> is there a predefined order in the invocation of $foo.*method ?

[21:19] <ruoso> or is it up to the HOW?

[21:19] <ruoso> in the sense of "as returned by $foo.can

[21:20] *** nihiliad joined
[21:22] <PerlJam> See http://perlcabal.org/syn/S12.html#Calling_sets_of_methods

[21:26] *** NoirSoldats left
[21:28] *** namenlos_ joined
[21:28] *** namenlos left
[21:31] <ruoso> TimToady, btw... I'm already considering ¢foo as the way to store captures without enforcing any context... 

[21:36] *** NoirSoldats joined
[21:39] <moritz_> pmichaud: "Using them often makes the code less clear, and can sometimes be correct" - did you mean "incorrect"?

[21:43] <pugs_svn> r25768 | wayland++ | Added real/imaginary to Complex, and true/not to Object

[21:44] <moritz_> pmichaud: I'm too lazy to wait for your answer ;-) Just pushed it to github, if you disagree, please revert

[21:45] <dalek> rakudo: 95ce390 | (Moritz Lenz)++ | docs/guide_to_setting.pod:

[21:45] <dalek> rakudo: [docs] thinko in guide_to_setting.pod

[21:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/95ce390480c92744d170e3b3fd504ec7fbeff1b5

[21:45] <moritz_> wayland76: any objections to calling them .re and .im?

[21:45] <moritz_> wayland76: they occur quite frequently in Complex code to deserve a better huffmanization, IMHO

[21:46] <PerlJam> moritz_: why not just .r and .i then?

[21:46] <moritz_> PerlJam: the re() and im() are what's used in mathematics

[21:47] <moritz_> s/the/because/

[21:47] <moritz_> and .i means something different already

[21:47] <moritz_> rakudo: say 4.i

[21:47] <p6eval> rakudo 95ce39: OUTPUT«Method 'i' not found for invocant of class 'Int'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[21:47] <moritz_> anywa, that should be 4i

[21:48] <PerlJam> 4i !=  4.i   :-)

[21:48] *** Kimtaro joined
[21:48] <moritz_> 41 == 4.i

[21:48] <moritz_> if you believe the spec

[21:48] <moritz_> S02-bits.pod

[21:48] <moritz_> 898:The complex type defaults to NaN + NaN.i.  A buf type of known size

[21:49] <pugs_svn> r25769 | wayland++ | Changed real to re, and imaginary to im, as perl moritz_++ suggestion

[21:49] <wayland76> s/perl/per/ :)

[21:50] <moritz_> I make that typo as well, once in a while

[21:50] <wayland76> finger-o :)

[21:50] <PerlJam> I often do that too.

[21:50] <moritz_> especially at 11pm

[21:50] <PerlJam> usually it's with the word "perlson"  :)

[21:50] <wayland76> Well, it's 8:47am, so I don't have that excuse

[21:50] <wayland76> Ooh, I like "perlson" :)

[21:51] <moritz_> "before coffee" counts as excuse too ;-)

[21:51] <wayland76> (although it does make me wonder whether we shouldn't also have perldaughters :) )

[21:51] <wayland76> My whole life is "before coffee" :)

[21:51] <moritz_> they are too rare ;-)

[21:52] <moritz_> wayland76: there you go. Perlfect (sic) excuse ;-)

[21:52] <wayland76> :)

[21:52] *** mberends left
[21:53] *** jferrero joined
[21:54] <pugs_svn> r25770 | lwall++ | .i should be \i

[21:54] <pugs_svn> r25770 | lwall++ | .text should be .Str

[21:57] <wayland76> @tell masak in regards to CPAN6, see http://cpan6.org/ and S22 :)

[21:57] <lambdabot> Consider it noted.

[21:57] <pmichaud> wayland76: I don't think true/not can be 'is export'

[21:57] <pmichaud> moritz_: you're correct, I meant "incorrect".  Thank you for correctly correcting me.

[22:01] *** wknight8111 joined
[22:01] <pmichaud> TimToady: I'm a little confused about Match.text and Match.Str

[22:02] <pmichaud> if Match.Str returns the substring of the original target, then when/why/how does stringification of a Match object return the stringificationof the result object?

[22:02] <pugs_svn> r25771 | wayland++ | Removed "is export" from true/not, as per pmichaud++ s suggestion

[22:02] <moritz_> $<?>.Str

[22:02] <pmichaud> moritz_: that's not what the spec currently says in S05, though.

[22:03] <pmichaud> S05:2414:  In string context it evaluates to the stringified value of its

[22:03] <pmichaud> I<result object>, which is usually the entire matched string:

[22:03] <pmichaud> (where "it" == "Match object" in this sentence)

[22:03] <pmichaud> so, a Match object in string context should return the stringified value of its result object.

[22:04] *** alester left
[22:04] <pmichaud> But if .Str is defined to return the original matched text.... there seems to be a conflict there.

[22:06] *** ejs left
[22:06] *** ejs joined
[22:09] *** donaldh joined
[22:18] *** [particle]2 left
[22:19] <pugs_svn> r25772 | lwall++ | clarify semantics of invocant type checking on exported methods

[22:21] *** icwiener left
[22:24] <pugs_svn> r25773 | wayland++ | Updated in line with Larry's changes to S05

[22:25] <TimToady> I don't think ~ and + should be using the result object anymore

[22:25] <pmichaud> Okay.

[22:25] <TimToady> can always say ~$<?> if that's what you mean

[22:25] <pmichaud> so, they always stringify/numify the matched text?

[22:25] <TimToady> yes

[22:25] <pmichaud> okay.

[22:25] <pmichaud> In many ways that's very very helpful to PCT.

[22:25] <pmichaud> (changing it to not stringify the result objet)

[22:26] <pmichaud> *object

[22:26] <TimToady> objét d'arte

[22:26] <pmichaud> Another question that arose earlier:  would  %()   include an entry for '?'    ?

[22:26] <pmichaud> (if a result object was set)

[22:26] <TimToady> I'm of two minds on that

[22:27] <pmichaud> okay, it's a Junction then.  :-)

[22:27] <TimToady> it's really hard to write a parameter named ?

[22:27] <pmichaud> Agreed.

[22:27] <TimToady> so maybe only if *% is used

[22:28] <TimToady> well, that's not quite what you were asking

[22:28] <TimToady> I think it's definitely returned by %()

[22:28] <pmichaud> Okay.

[22:28] <pmichaud> and methods still have an implicit slurpy hash, yes?

[22:28] <TimToady> yes

[22:28] <pmichaud> Okay.

[22:28] <pmichaud> I'm fine with that.

[22:29] <pmichaud> While looking through the specs on <?>  I noticed an inadvertent pun on the <?> metasyntax operator.

[22:29] <pmichaud> Or perhaps it's not inadvertent?

[22:29] <TimToady> thought about that, decided it probably was neither pos nor neg

[22:30] <pmichaud> Excellent.  answers++

[22:30] <pmichaud> TimToady++

[22:30] <TimToady> and probably doesn't interfere unless someone tries to match $<foo><?>

[22:30] <TimToady> which seems silly anyway

[22:32] <pmichaud> I've gotta update a lot of PCT docs and add some deprecation notices to Parrot.  :-|

[22:34] <pugs_svn> r25774 | lwall++ | ~ and + now just stringify/numify the matched string, not the result object

[22:35] *** PZt left
[22:36] *** PZt joined
[22:40] *** nihiliad left
[22:46] <pugs_svn> r25775 | lwall++ | more result object demotion

[22:47] <pugs_svn> r25776 | moritz++ | [t/spec] test for Complex.re and .im

[22:48] <pmichaud> I'm curious if .re and .im are only defined for Complex, or are they defined for Any ?

[22:49] <moritz_> IMHO they are sufficiently domain specific to go into Complex

[22:49] <pmichaud> so, my $a = <3>;   say $a.re;   # method not found?

[22:49] <moritz_> *if* we make sure that methods that are supposed to return Complex always return Complex objects, and don't be "smart" about promoting to Num or Int

[22:49] <moritz_> pmichaud: yes

[22:50] *** skids left
[22:50] <pmichaud> There's also been discussion that  "3+4i"  would numify to a Complex.

[22:50] <moritz_> hm.

[22:50] *** jferrero left
[22:50] <pmichaud> (I don't know that this is specced yet.)

[22:51] *** japhb left
[22:51] <pmichaud> in STD,  <number>  will match Complex numbers, though.

[22:52] <TimToady> and Rats

[22:52] <pmichaud> which means that  3+4i  is now a term and not an infix:<+>  and postfix:<i>, yes?

[22:52] <TimToady> yes

[22:52] <TimToady> likewise 22/7

[22:52] <pmichaud> and thus numification of "3+4i" is a Complex

[22:54] <TimToady> hmm, I bet it doesn't parse "4i" right though...

[22:54] <pmichaud> ...but   3 + 4i  is not a term?

[22:54] <TimToady> correct

[22:54] <pmichaud> how about +"3 + 4i"  ?

[22:54] <TimToady> but then do we allow spaces on input

[22:54] <moritz_> but still an expression, I hope?

[22:55] <TimToady> yes, still an expression

[22:55] <TimToady> maybe + squeezed out whitespace before parsing?

[22:55] <pugs_svn> r25777 | moritz++ | [t/spec] tests for RT #63744

[22:56] <pmichaud> then.... +"3 4 5"    ?  

[22:56] <moritz_> would be 3, in good ol' perl 5 tradition?

[22:57] <TimToady> not if spaces squeezed first

[22:57] <moritz_> all spaces? not only leading?

[22:57] <TimToady> +"3 + 4i"

[22:57] <moritz_> that will cause confusion

[22:57] <pmichaud> moritz:  if we don't squeeze internal spaces... what TT said

[22:58] <moritz_> I'm more in favor of optimizing the common case (non-complex numbers)

[22:58] <TimToady> well, squeeze is the wrong word, remove

[22:58] <pmichaud> I'm being called to dinner -- bbl.

[22:59] <TimToady> that can be optimized, but if we get to the end of a normal number and it looks like there's more, it gives us more options

[23:00] <TimToady> we do have to be a little careful not to make it so powerful that a malicious user can feed us "4 + BEGIN { run 'rm -rf /' }i"

[23:01] <TimToady> so we can't just tell the user to parse with EXPR

[23:01] <TimToady> hopefully <number> is sufficiently restricted to be broken out of like that

[23:05] *** donaldh left
[23:10] *** gbacon left
[23:12] <TimToady> std: -Inf+NaNi

[23:12] <p6eval> std 25777: OUTPUT«Undeclared name:␤      NaNi used at 1 ␤ok 00:02 34m␤»

[23:13] <moritz_> std: -Inf+NaN\i

[23:13] <p6eval> std 25777: OUTPUT«ok 00:02 34m␤»

[23:13] <TimToady> parses as expression, not term

[23:13] <TimToady> meaning you can't type it at the prompt

[23:13] <TimToady> maybe literal form should allow optional \

[23:15] <TimToady> still not sure whether literal form should require 0+4i or allow 4i

[23:16] *** gbacon joined
[23:20] <TimToady> well, it only adds 16 more forms to the <number> lexer table

[23:21] <moritz_> std: 2 R** 3

[23:21] <p6eval> std 25777: OUTPUT«ok 00:02 34m␤»

[23:21] <moritz_> std: 2 RR** 3

[23:21] <p6eval> std 25777: OUTPUT«ok 00:02 34m␤»

[23:23] <TimToady> std: 2 RRRRRRRRRRRRRRRRRRRRRRRRR** 3

[23:23] <p6eval> std 25777: OUTPUT«ok 00:02 34m␤»

[23:23] <TimToady> std: 2 XXXXRRRXXXRRRXXRXRXRXXR** 3

[23:23] <p6eval> std 25777: OUTPUT«ok 00:02 34m␤»

[23:29] <wayland76> We need some vowel hyperoperators :)

[23:29] <wayland76> std: 2 ROAR 3

[23:29] <p6eval> std 25777: OUTPUT«##### PARSE FAILED #####␤Syntax error (two terms in a row?) at /tmp/Arz3FY209V line 1:␤------> 2 ROAR 3␤    expecting any of:␤ infix or meta-infix␤      infix stopper␤    standard stopper␤ terminator␤FAILED 00:02 34m␤»

[23:29] * moritz_ sense great opportunities for obfus

[23:29] <wayland76> std: 2 RandR 3

[23:29] <p6eval> std 25777: OUTPUT«Undeclared name:␤      R used at 1 ␤ok 00:02 34m␤»

[23:29] <wayland76> std: 2 RorR 3

[23:29] <p6eval> std 25777: OUTPUT«Undeclared name:␤      R used at 1 ␤ok 00:02 34m␤»

[23:29] <wayland76> std: 2 Ror 3

[23:30] <p6eval> std 25777: OUTPUT«ok 00:02 34m␤»

[23:30] <wayland76> std: 2 Rand 3

[23:30] <p6eval> std 25777: OUTPUT«ok 00:02 34m␤»

[23:30] <wayland76> std: rand Rand rand

[23:30] <p6eval> std 25777: OUTPUT«ok 00:02 34m␤»

[23:30] <wayland76> hehe

[23:30] <moritz_> ;-)

[23:30] <wayland76> That would help obfus :)

[23:30] <TimToady> std: $drugs RX= 42

[23:30] <p6eval> std 25777: OUTPUT«##### PARSE FAILED #####␤Can't cross a item assignment because it's too fiddly at /tmp/PqBEge01rg line 1:␤------> $drugs RX= 42␤Other potential difficulties:␤  Variable $drugs is not predeclared at /tmp/PqBEge01rg line 1:␤------> $drugs RX= 42␤FAILED

[23:30] <p6eval> ..0...

[23:32] <TimToady> std: 123 »XXX« 321

[23:32] <p6eval> std 25777: OUTPUT«ok 00:02 34m␤»

[23:32] <wayland76> rakudo: say rxrokr ~~ "ok"

[23:32] <p6eval> rakudo 95ce39: OUTPUT«Could not find non-existent sub rxrokr␤current instr.: '_block14' pc 82 (EVAL_16:42)␤»

[23:32] <wayland76> rakudo: say rx:rokr ~~ "ok"

[23:32] <p6eval> rakudo 95ce39: OUTPUT«Statement not terminated properly at line 1, near ":rokr ~~ \""␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[23:32] <wayland76> rakudo: say rx,ok, ~~ "ok"

[23:32] <p6eval> rakudo 95ce39: OUTPUT«Could not find non-existent sub rx␤current instr.: '_block14' pc 53 (EVAL_16:38)␤»

[23:33] <wayland76> rakudo: say rx/ok/ ~~ "ok"

[23:33] <p6eval> rakudo 95ce39: OUTPUT«Could not find non-existent sub rx␤current instr.: '_block14' pc 53 (EVAL_16:38)␤»

[23:33] <wayland76> rakudo: say rx:i/ok/ ~~ "ok"

[23:33] <p6eval> rakudo 95ce39: OUTPUT«Statement not terminated properly at line 1, near ":i/ok/ ~~ "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[23:33] <TimToady> perl6: my $rx = rx/ok/;

[23:33] <p6eval> elf 25777: RESULT«Regexp.new(!!!)␤»

[23:33] <p6eval> ..rakudo 95ce39: OUTPUT«Statement not terminated properly at line 1, near "/;"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[23:33] <p6eval> ..pugs: RESULT«\{regex}»

[23:34] <TimToady> looks like rx is unimpl

[23:34] <wayland76> std: rx/rx/ RX= "rx"

[23:34] <moritz_> aye

[23:34] <p6eval> std 25777: OUTPUT«##### PARSE FAILED #####␤Can't cross a list assignment because it's too fiddly at /tmp/UOkDWU0VEK line 1:␤------> rx/rx/ RX= "rx"␤FAILED 00:02 34m␤»

[23:34] <wayland76> std: rx/rx/ RXand "rx"

[23:34] <p6eval> std 25777: OUTPUT«ok 00:04 34m␤»

[23:34] <wayland76> std: rx/rx/ RX+ "rx"

[23:34] <p6eval> std 25777: OUTPUT«ok 00:04 34m␤»

[23:35] <wayland76> std: rx/rx/ RX~~ "rx"

[23:35] *** Limbic_Region joined
[23:35] <p6eval> std 25777: OUTPUT«ok 00:04 34m␤»

[23:35] <wayland76> No idea what the code would do though :)

[23:35] <TimToady> bbl &

[23:35] <moritz_> match 'rx' against rx/rx/

[23:36] <moritz_> an X on two single items doesn't make a difference

[23:36] *** bacek_ joined
[23:36] <moritz_> rakudo: say 2 X+ 3

[23:36] <p6eval> rakudo 95ce39: OUTPUT«5␤»

[23:37] <moritz_> bed&

[23:38] <wayland76> Cool.  That's what I hoped it'd do :)  Could help with obfus too :)

[23:41] <szabgab> rakudo: say 12 ~~ /^ \d+ $/ ?? 'ok' !! 'not'

[23:41] <p6eval> rakudo 95ce39: OUTPUT«ok␤»

[23:41] *** ejs left
[23:41] <szabgab> rakudo: grammar Y { regex TOP { ^ \d+ $ } }; say 12 ~~ Y ?? 'ok' !! 'not'

[23:41] <p6eval> rakudo 95ce39: OUTPUT«not␤»

[23:41] <szabgab> why is that not?

[23:42] <wayland76> Now you're scaring me with obfus ideas :)

[23:42] <wayland76> (btw, TOP has been deprecated in favour of a parse method, IIRC)

[23:43] <szabgab> rakudo: grammar Y { regex TOP { ^ \d+ $ } }; say 12 ~~ Y::TOP ?? 'ok' !! 'not'

[23:43] <p6eval> rakudo 95ce39: OUTPUT«Method 'ACCEPTS' not found for invocant of class 'PGE;Match'␤current instr.: 'infix:~~' pc 19380 (src/builtins/match.pir:18)␤»

[23:44] <szabgab> rakudo: grammar Y { regex TOP { ^ \d+ $ } }; say 12 ~~ /<Y::TOP>/ ?? 'ok' !! 'not'

[23:44] <p6eval> rakudo 95ce39: OUTPUT«ok␤»

[23:44] <szabgab> aha

[23:44] <wayland76> (oh, the TOP deprecation is in the spec, but may not be in rakudo yet)

[23:44] *** pmurias joined
[23:44] <szabgab> where in the spec?

[23:44] <wayland76> rakudo: grammar Y { regex TOP { ^ a\d+ $ } }; say 12 ~~ /<Y::TOP>/ ?? 'ok' !! 'not'

[23:44] <diakopter> pmurias: I'm back now

[23:44] <p6eval> rakudo 95ce39: OUTPUT«not␤»

[23:46] <szabgab> TOP is just an arbitrary word here, isn't it?

[23:46] <wayland76> szabgab: Not sure, but you'll not that TOP doesn't appear at all any more, except as part of STOP

[23:46] <wayland76> szabgab: TOP had some special meaning, but not any more

[23:46] <szabgab> yeah, I just grepped the Specs too

[23:46] <wayland76> But you can still use it as a rule name

[23:46] <szabgab> I did not know that

[23:47] *** skids joined
[23:48] <wayland76> Here's what I wanted...

[23:48] <wayland76> Matching against a C<Grammar> treats the grammar as a typename,

[23:48] <wayland76> not as a grammar.  You need to use the C<.parse> or C<.parsefile>

[23:48] <wayland76> methods to invoke a grammar.

[23:48] <wayland76> From S03

[23:48] <diakopter> pmurias: did you get a chance to build mono from svn?

[23:49] <szabgab> I don't understand that

[23:50] <szabgab> Matching against a "Grammar"   would mean if I declare XX as a grammar and then rry to match:    $str ~~ XX 

[23:55] <wayland76> Don't use X unless you want to do obfus -- X is a hyper-operator

[23:55] <wayland76> ...but to address your point...

[23:56] <wayland76> rakudo: grammar example {}; say example.perl

[23:56] <p6eval> rakudo 95ce39: OUTPUT«example␤»

[23:56] <wayland76> rakudo: grammar example { rule TOP { ^ \d+ $ } }; say example.perl

[23:56] <p6eval> rakudo 95ce39: OUTPUT«example␤»

[23:57] *** pmurias left
[23:57] <wayland76> rakudo: grammar example { rule TOP { ^ \d+ $ } }; say example ~~ /a/

[23:57] <p6eval> rakudo 95ce39: OUTPUT«Null PMC access in get_integer()␤current instr.: 'parrot;PGE;Match;new' pc 75 (compilers/pge/PGE/Match.pir:75)␤»

[23:57] <wayland76> rakudo: grammar example { rule TOP { ^ \d+ $ } }; say example ~~ "12"

[23:57] <p6eval> rakudo 95ce39: OUTPUT«0␤»

[23:57] <wayland76> rakudo: grammar example { rule TOP { ^ \d+ $ } }; say example ~~ 12

[23:57] <p6eval> rakudo 95ce39: OUTPUT«Use of protoobject as value␤0␤»

[23:58] *** mikehh left
[23:58] <wayland76> rakudo: grammar example { rule TOP { ^ \d+ $ } }; say example ~~ "12"

[23:58] <p6eval> rakudo 95ce39: OUTPUT«0␤»

[23:58] <wayland76> rakudo: grammar example { rule TOP { ^ \d+ $ } }; say example.parse("12")

[23:58] <p6eval> rakudo 95ce39: OUTPUT«12␤»

[23:58] <wayland76> Those last two lines illustrate the point it's trying to make

