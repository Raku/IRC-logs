[00:16] *** justatheory left
[00:36] *** alanhaggai joined
[00:36] *** alanhaggai left
[00:36] *** amoc joined
[00:38] *** alanhaggai joined
[01:00] *** abra left
[01:15] *** DemoFreak left
[01:29] *** Whiteknight left
[01:45] *** ilogger2_ joined
[02:14] *** eternaleye_ joined
[02:36] *** mikehh_ joined
[03:32] *** eternaleye joined
[03:40] *** orafu joined
[03:52] *** cognominal joined
[03:56] *** meppuru joined
[03:57] *** justatheory joined
[04:05] *** LadyLuna1y joined
[05:07] *** justatheory joined
[06:01] *** meteorjay joined
[06:05] *** M_o_C joined
[06:07] *** xinming joined
[06:09] *** dduncan joined
[06:17] *** dduncan left
[06:43] *** kate21de joined
[07:01] *** r0bby joined
[07:25] *** NoirSoldats joined
[07:35] *** tombom joined
[07:57] *** c9s joined
[08:16] *** someguy joined
[08:22] *** someguy left
[08:39] *** ejs1 joined
[08:47] *** Eevee joined
[08:51] *** iblechbot joined
[09:14] <Tene> There are lots of incorrect pages on perlfoundation.org/perl6/

[09:27] *** DemoFreak joined
[09:48] *** meteorjay joined
[10:03] *** bacek_ joined
[10:11] *** ejs1 joined
[10:28] *** fridim joined
[10:30] *** pmurias joined
[10:40] *** alanhaggai joined
[10:43] <pugs_svn> r26749 | moritz++ | [t/spec] get rid of an instace of "is also"

[10:50] <moritz_> std: sub f { 3 } sub g { 3 }

[10:50] <p6eval> std 26749: OUTPUT¬´##### PARSE FAILED #####‚ê§Statements must be separated with semicolon at /tmp/8m2GakLY7m line 1:‚ê§------> [32msub f { 3 } [31msub g { 3 }[0m‚ê§    expecting any of:‚ê§ infix or meta-infix‚ê§      infix stopper‚ê§    standard stopper‚ê§ statement‚ê§      statement modifier loop‚ê§   

[10:50] <p6eval> ..terminator‚ê§FAILED 00:02 3...

[10:55] <pugs_svn> r26750 | moritz++ | [t/spec] get rid of "is also" in unspace.t

[10:55] <pugs_svn> r26751 | moritz++ | [t/spec] get rid of some evals in unspace.t

[10:58] <literal> std: rx/ <foo(1, 2, 3)> /

[10:58] <p6eval> std 26749: OUTPUT¬´ok 00:03 37m‚ê§¬ª

[10:58] <literal> std: rx/ <foo_bar-baz(1, 2, 3)> /

[10:58] <p6eval> std 26749: OUTPUT¬´ok 00:02 37m‚ê§¬ª

[10:59] <literal> std: rx/ <foo_bar-baz'quux(1, 2, 3)> /

[10:59] <p6eval> std 26749: OUTPUT¬´ok 00:02 37m‚ê§¬ª

[10:59] <moritz_> std: [=>] <A B>, undef

[10:59] <p6eval> std 26749: OUTPUT¬´ok 00:03 38m‚ê§¬ª

[11:00] <pugs_svn> r26752 | moritz++ | [t/spec] correct and simplify chaining.t

[11:03] <dalek> rakudo: a74a9cf | moritz++ | t/spectest.data:

[11:03] <dalek> rakudo: we pass S12-methods/chaining.t

[11:03] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a74a9cf7105f9249960f3791e76dac035c2899fb

[11:25] <literal> @tell TimToady STD.pm line 2234 doesn't make much sense. $> == $() ?

[11:25] <lambdabot> Consider it noted.

[11:28] *** Whiteknight joined
[11:33] <moritz_> it should probably be '$> variable'

[11:33] <literal> yeah

[11:34] <pugs_svn> r26753 | moritz++ | [STD.pm] typo found by literal++

[11:34] <moritz_> forgiveness vs. permission ;-)

[11:43] <literal> hehe

[11:48] *** rindolf joined
[11:49] *** abra joined
[11:57] *** cognominal joined
[12:11] *** LadyLunacy joined
[12:16] *** kate21de joined
[12:20] *** minazo joined
[12:24] *** wknight8111 joined
[12:27] *** Psyche^ joined
[12:28] *** Psyche^ joined
[12:55] <literal> std: 1 <=> 2

[12:55] <p6eval> std 26753: OUTPUT¬´ok 00:02 35m‚ê§¬ª

[12:55] <literal> rakudo: 1 <=> 2

[12:55] <p6eval> rakudo a74a9c:  ( no output )

[12:55] <literal> rakudo: say (1 <=> 2)

[12:55] <p6eval> rakudo a74a9c: OUTPUT¬´-1‚ê§¬ª

[13:13] <diakopter> twimc: borrowing from Perl 6 - http://gavingrover.blogspot.com/2009/05/groovys-groovier-roadmap.html

[13:18] <jnthn> Aye, they directly mention Perl 6 too. :-)

[13:37] *** masak joined
[13:42] *** skids joined
[13:47] <masak> Tene: is Loldispatch available online somewhere?

[14:03] *** aindilis joined
[14:08] *** hacktor joined
[14:10] *** hacktor left
[14:12] *** fuad joined
[14:13] <diakopter> jnthn: right, that's what I meant.

[14:27] <pugs_svn> r26754 | moritz++ | [t/spec] s/is also/augment (also in file name)

[14:28] <masak> moritz_++

[14:28] <moritz_> note that it was not s/.../.../g

[14:29] <masak> no, it was s/.../...

[14:29] <masak> :)

[14:29] <masak> kinda open-ended.

[14:29] <moritz_> ;-)

[14:32] *** sri_kraih joined
[14:33] <pugs_svn> r26755 | moritz++ | [t/spec] s/is also/augment/ in open_closed.t

[14:33] <pugs_svn> r26755 | moritz++ | 

[14:33] <pugs_svn> r26755 | moritz++ | Also get rid of lives_ok { ... } around class defintions; the class

[14:33] <pugs_svn> r26755 | moritz++ | composition happen at compile time anyway, so that was pretty pointless.

[14:34] <moritz_> ok, 'is also' usage down to 5 files in t/spec, and they really need it (because it's what they test)

[14:35] <masak> moritz_: how do you mean?

[14:35] <masak> I thought 'is also' was deprecated.

[14:35] <moritz_> masak: I mean I removed all needless occurences of that feature, however it's called syntactically

[14:35] * masak still doesn't understand

[14:36] <masak> I'd better greo for it myself to grok it :)

[14:37] <moritz_> masak: I didn't remove all occurences of the deprecated 'is also' yet because I don't want to leave that untested in Rakudo

[14:37] <masak> ok.

[14:37] <moritz_> masak: I did s/is also/augment/ in some places that rakudo doesn't run anway...

[14:38] <moritz_> but most of the occurences weren't necessary for running the tests, so I removed them (or replaced by something simpler)

[14:38] <masak> excellent.

[14:39] <masak> so those 'is also' that remain are those that Rakudo runs, and that can't be replaced by somethine else?

[14:39] <masak> :q

[14:39] <masak> oops, window focus fail.

[14:40] <masak> I notice none of the test files that use 'is also'/'augment' do 'use MONKEY_PATCHING'

[14:40] <moritz_> yes, I'm going to change that soonish as well

[14:40] <masak> moritz_: do you need anything from Rakudo to be able to go through with it?

[14:51] *** nihiliad joined
[14:51] *** ZuLuuuuuu joined
[14:53] <pmichaud> fwiw, I'm find if we regress on the 'is also' tests.

[14:53] <pmichaud> *fine

[15:05] *** payload joined
[15:07] <jnthn> Aye. I think the use we make of is also in the setting will soon let us know if we broked it. :-0

[15:07] <jnthn> s/0/)/

[15:08] *** pmichaud joined
[15:11] <moritz_> masak: not really; I can simply fudge it out

[15:11] <masak> moritz_: fair enough. but that means we go down in passed tests...

[15:12] <masak> I thought there might be a good way to prepare for it.

[15:12] <moritz_> masak: sure, implemnt 'use MONKEY_PATCHING' and 'augment' ;-)

[15:12] <masak> :)

[15:17] *** justatheory joined
[15:22] *** fuadaw joined
[15:32] <pugs_svn> r26756 | moritz++ | [t/spec] rename is_also_instead.t and update syntax

[15:33] *** ZuLuuuuuu left
[15:35] <pmichaud> how many tests do we go down?

[15:36] <pmichaud> (approx)

[15:36] <pmichaud> 10? 100?

[15:36] <moritz_> I'm removing all, then I'll run the harness and tell you

[15:36] <moritz_> perhaps 50 to 100

[15:36] <pmichaud> I'll still live with the regression.

[15:37] <pmichaud> we can always start to ship a MONKEY_PATCHING.pm module to get "use MONKEY_PATCHING" to not fail :-P

[15:37] *** M_o_C joined
[15:37] <moritz_> that's something that can easily be fudge away

[15:37] <moritz_> don't worry on that front

[15:37] <pmichaud> that too. 

[15:37] *** fuadaw left
[15:38] <masak> pmichaud: an actual module would be dependent on the cwd of the user, and/or PERL6LIB.

[15:39] *** justlooks joined
[15:39] <pmichaud> masak: I'm thinking we might end up with a standard lib-location for rakudo-distributed modules.

[15:39] <masak> \o/

[15:39] <pugs_svn> r26757 | moritz++ | [t/spec] remove rest of "is also" on classes

[15:39] <moritz_> pmichaud: first step, move Test.pm to lib/, IMHO

[15:39] <masak> pmichaud: did I tell you about the time I tried to remove Test.pm from the November repo?

[15:40] <pmichaud> I think you mentioned it, but I forget the punchline

[15:40] <masak> turns out I couldn't bring myself to do it, because November's Test.pm is still objectively better than Rakudo's.

[15:40] *** PhatEddy joined
[15:40] <moritz_> what's the difference?

[15:40] <moritz_> diagnosis?

[15:40] <masak> I don't recall exactly in which ways, but likely candidates are got/expected and is_deeply.

[15:41] <masak> those are the two things we added.

[15:41] <pmichaud> I think got/expected in in Rakudo's Test.pm now.

[15:41] <masak> and they're deeply useful in our test suite.

[15:41] <moritz_> I'm pretty sure we backported is_deeply to Rakudo.

[15:41] <masak> :)

[15:41] <moritz_> pmichaud: I don't think so

[15:41] <moritz_> pmichaud: I tried to incorporate some of Ovid's patches, but had a few problems

[15:42] * pmichaud goes to look at November's Test.pm

[15:43] <pmichaud> afk for a bit

[15:44] <dalek> rakudo: cbc1bf6 | moritz++ | t/spectest.data:

[15:44] <dalek> rakudo: regress on a few tests tests that now use "augment" instead of "is also"

[15:44] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cbc1bf6140f9c31872b51ddf9c6a7161845c789c

[15:46] <Tene> ack

[15:46] <Tene> I just missed him

[15:47] <pmichaud> back

[15:48] *** Psyche^ joined
[15:48] <pmichaud> From a cursory look, I think I'd be fine with adopting November's Test.pm in place of Rakudo's.

[15:53] <PhatEddy> I've got a short regex program that hangs rakudo here: token chunk { <[a..z]>* }; say 'ok' if 'index/' ~~ /[ <chunk> '/'?]*/

[15:54] <PhatEddy> anything to do beyond mailing in a rakudobug?

[15:54] <moritz_> PhatEddy: it's known that PGE hangs on quantified zero width matches

[15:56] *** eternaleye_ joined
[15:57] <pmichaud> you might want

[15:58] <pmichaud> token chunk { <[a..z]>+ };   ...     / [ <chunk> ** '/' ]? /

[15:59] <PhatEddy> sorry - just didn't occur to me right off to search rt from PGE ...

[16:04] <moritz_> PhatEddy: it's known, but I don't know if it's in RT

[16:07] *** baest joined
[16:07] *** smtms joined
[16:07] *** c1sung joined
[16:08] *** pdc303 joined
[16:09] *** broquaint joined
[16:09] *** spx2 joined
[16:10] *** krunen joined
[16:10] *** Eevee joined
[16:13] *** payload1 joined
[16:13] *** H1N1[S] joined
[16:18] *** cognominal joined
[16:19] *** integral joined
[16:26] *** cavelife^ joined
[16:30] *** amoc joined
[16:37] *** masak joined
[16:56] *** mberends joined
[16:57] <mberends> masak: another nice blog, about yarn :)

[16:57] <masak> mberends: oh hai

[16:58] <masak> thanks. :)

[16:58] <mberends> does there need to be a yarn pumpkin as well as a proto pumpkin?

[16:59] <masak> nah, not yet, methinks.

[16:59] <masak> in fact, I'm not sure there "needs" to be a proto pumpkin... I just like the thought of the pumpkin enough to keep it up. :P

[17:00] <mberends> it's quite worrisome sleeping without a pumpkin, not knowing whether the world will be the same as when I drifted off...

[17:01] <masak> *lol*

[17:02] <jnthn> .oO( mmm....pumpkin soup )

[17:02] * masak rolls pumpkin over on mberends' desk

[17:02] * mberends will use git pull --rebase more often in future

[17:02] <masak> mberends: I meant to write that recursive-deps stuff today, but I was distracted by yaks.

[17:03] <Infinoid> damn yaks

[17:04] <mberends> I'm going to cage-clean HTTP::Daemon now

[17:04] <masak> mberends++

[17:09] *** mikehh_ joined
[17:14] <dalek> rakudo: e6363e8 | pmichaud++ | docs/spectest-progress.csv:

[17:14] <dalek> rakudo: spectest-progress.csv update: 383 files, 11085 passing, 1 failing

[17:14] <dalek> rakudo: Failure summary:

[17:14] <dalek> rakudo:     S32-io/IO-Socket-INET.t 2 - echo server and client

[17:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e6363e82c0c8bae8f673d9f5e4c061d830a5e753

[17:15] *** knewt joined
[17:23] <s1n> i think this is a parse error:

[17:23] <s1n> rakudo: class A { my $.foo; sub test() { say "oh hai!"; } }; my A $a .= new; $a.test();

[17:23] <p6eval> rakudo e6363e: OUTPUT¬´Could not locate a method 'test' to invoke on class 'A'.‚ê§current instr.: 'die' pc 16816 (src/builtins/control.pir:225)‚ê§¬ª

[17:24] <s1n> notice the misplaced 'my' seems to screw with how the rest of the class is being parsed

[17:24] <s1n> any thoughts?

[17:25] <jnthn> s1n: The error is completely correct.

[17:25] <jnthn> A has no method test.

[17:25] <jnthn> It has a sub test though. :-)

[17:25] <jnthn> rakudo: class A { my $.foo; method test() { say "oh hai!"; } }; my A  $a .= new; $a.test();

[17:25] <p6eval> rakudo e6363e: OUTPUT¬´oh hai!‚ê§¬ª

[17:26] <s1n> jnthn: i was getting that with a multi-method...

[17:26] <s1n> rakudo: class A { my $.foo; multi method test() { say "oh hai!"; } }; my A  $a .= new; $a.test();

[17:26] <p6eval> rakudo e6363e: OUTPUT¬´oh hai!‚ê§¬ª

[17:26] <s1n> wtf

[17:27] <s1n> what exactly is the difference between sub and method?

[17:28] <moritz_> ok, 11074 tests still passing

[17:28] <moritz_> s1n: a method has an invocant

[17:28] <moritz_> in $a.test, $a is the invocant

[17:29] <jnthn> Also, a method gets entered into the methods table and can be called as one. A sub does not.

[17:29] <s1n> why doesn't p6 just dwim and add the invocant if i called it with one?  :)

[17:29] <s1n> i really don't want to have to know that much, i just want to define a method on a class

[17:29] <jnthn> Then define one!

[17:29] <jnthn> Using the keyword designated for that purpose. :-)

[17:30] <moritz_> s1n: because perl 5 didn't do the distinction, and it was a mess

[17:30] <moritz_> s1n: if you are forced to declare it, optimizations and introspections can work

[17:31] <s1n> i would just like it to automatically know "hey, that's a method on the class, let's add the invocant" or "hey, that's a stand-alone method, don't add the invocant"

[17:32] <s1n> i already defined the class scope, why do i need to use a different keyword?

[17:32] <jnthn> Because you can also, quite legitimately, put a sub in a class too.

[17:32] <s1n> which do you think is more common?

[17:32] <jnthn> Which is something that is called without an invocant.

[17:33] <jnthn> In classes? methods.

[17:33] <s1n> so... why not have dwim keyword which automatically figures it out, unless i want something unusual

[17:34] <s1n> unless method was intended for that

[17:34] <s1n> because i keep screwing it up and placing subs/methods incorrectly and spend hours debugging it

[17:34] <jnthn> method is the keyword for "I'm defining something that can be invoked as a method on this class"

[17:34] <jnthn> In a class, you probably usually will want to be writing methods.

[17:35] <s1n> jnthn: the point is i already defined the class, everything inside it is _logically_ defined on the class by default, right?

[17:35] <s1n> otherwise, class is just a hackish way of doing packages from p5

[17:36] <s1n> i want a class, when i define 'class A { .. }' everything inside that closure should default to be defined against that class

[17:36] <jnthn> A class is a type of package, just as a role, a module, a grammar, etc is.

[17:36] <s1n> everytime i define a class, i constantly have to define the class contents within the contents of the class

[17:37] <jnthn> Myself, I'd rather not having subs suddenly changing their meaning in different types of package. If something is different it's probably best off if it looks different.

[17:37] <s1n> personally, i hate having to keep saying what's inside the class when i've already said what the class' scope is

[17:37] <jnthn> Anyways, if it bugs you and others enough, it's only a proto routine_declarator:dwimcode away. :-)

[17:38] <s1n> all i'm getting at is the class is already defined in the closure, everything in it _should_ belong to it by default

[17:39] <jnthn> It does, but there's a difference between "belongs in the package of the class" and "belongs in the method table of the class".

[17:39] <Tene> s1n: It's also useful to define class-scoped subs.  You don't want those showing up as methods on the class.

[17:39] <s1n> Tene: i know what class scoped methods are

[17:39] <Tene> s1n: I said class-scoped *subs*.  That aren't methods on the class.

[17:40] <Tene> class A { sub helper_function_one { ... } }

[17:40] <s1n> i can't help but think java got this right, i have to add 'static' to define something against the class

[17:41] <Tene> "Inside of a class declaration, 'sub' gets a new meaning, and we have a different keyword we have to use for what 'sub' used to mean."

[17:41] <Tene> Is a bad rule.

[17:41] <jnthn> Java doesn't have a sub keyword.

[17:41] <s1n> i think i've mistakenly used sub/method incorrectly about 10 times, and each time it takes me hours to figure out what i've done wrong

[17:42] <moritz_> jnthn: java doesn't have subs at all

[17:43] <s1n> to me, the sub/method thing is unintuitive and i will always screw it up

[17:43] <jnthn> moritz_: I know, I was more drawing out that there's no keyword at all in Java for declaring a chunk of code.

[17:44] <moritz_> that it's (IMHO bad) C++ heritage

[17:44] <s1n> you can, but it has to either be static on a class, or an anon closure

[17:45] <s1n> (that is, you can do { code } in both languages)

[17:45] <s1n> you just can't call it, it's just called in whatever closure it's currently in

[17:46] <s1n> code { more code } even more code => just plows through each of those in order

[17:47] <moritz_> ie it's not a declaration, just a new scope

[17:47] <s1n> moritz_: yeah, basically

[17:50] <Tene> s1n: You really think that it would be a good idea for 'sub' to magically mean something different in classes, and require 'sub-yes-really-a-sub' to mean what 'sub' used to mean?  You think that would be more intuitive and lead to fewer mistakes?

[17:51] <s1n> Tene: i dunno, but i'm sure i can't be the only one screwing that up

[17:51] <Tene> That's the first time I've heard anyone mention it.  That doesn't necessarily mean much, though.

[17:52] <s1n> it seems intuitive to me to have one keyword for all methods and one that says "this one is just a named closure and isn't defined on the class"

[17:52] <Tene> My feeling is that it's not so much unintuitive as it is just a (needed, IMO) change from Perl 5.

[17:53] <s1n> and everything else?

[17:53] <Tene> s1n: 'sub' in a class means the same thing as 'sub' in a namespace and 'sub' anywhere else.

[17:53] <s1n> i think i'm failing to express my point

[17:54] <Tene> how is "'sub' means exactly the same thing everywhere" less intuitive than "'sub' means the same thing everywhere, except in class blocks, where you have to say 'really-sub' to mean what 'sub' means everywhere else"?

[17:54] <Tene> Hm.  I think I already said that.

[17:54] <Tene> Or I'm failing to understand.

[17:55] <s1n> class A { method-on-A; method-on-A; method-not-on-A; } versus class A { method; method; method-not-on-A }

[17:55] <Tene> I have no idea what that means.

[17:55] <s1n> i've already declared the class, everything in it is in the class unless i say otherwise

[17:56] <jnthn> s1n: I think what you're missing is that there's different ways to be "in the class".

[17:56] <Tene> a sub isn't a method, though!

[17:56] <s1n> then why is it called "submethod"?

[17:56] <s1n> why not "code { }"

[17:56] <Tene> erm, submethod is different from sub

[17:56] <jnthn> s1n: As soon as you want sub to mean something else in there, you then have to go through all the other package types (role, grammar, etc) and say "so what does sub mean in there?"

[17:56] <s1n> Tene: how does that make sense??

[17:56] <jnthn> And then we get back to "memorizing lists of things".

[17:57] <jnthn> Which is something Perl 6 tries to avoid.

[17:57] <s1n> jnthn: i'm not sure i understood what you mean

[17:58] <jnthn> In a world where people can declare their own package types and routine types in derived forms of Perl 6, I think keeping the meanings of routines and the meanings of packages orthogonal is probably a win, even if it's at the expense of some dwim-i-ness.

[17:58] <s1n> we have method, sub, and submethod and they all mean something pretty different. no one else sees that as confusing?

[17:58] <jnthn> No, just as I don't see "we have module, grammar, class, role all meaning something pretty different" as confusing either.

[17:58] <Tene> Different names for different things.  it would be a lot more confusing if we only had one name for all of those things, or all of those names for one thing.

[17:58] <Tene> exactly

[17:59] * jnthn needs to eat - bbiab

[17:59] <s1n> okay, then i hope that works out for everyone else because they all sound the same to me and no one else seems to think it's even the slightest bit confusing

[18:00] <s1n> of course, you both have worked _on_ rakudo, so your views may be slanted

[18:00] <moritz_> s1n: casual users don't have to care about submethods

[18:00] <Tene> s1n: do you actually have a proposal for how things should be instead?  I might have missed it.

[18:00] <Tene> I came in a bit late.

[18:00] <s1n> moritz_: how are casual users going to know the difference?

[18:01] <Tene> i'm still not quite sure what your complaint is.

[18:01] <s1n> Tene: i thought i did but i guess not

[18:01] <moritz_> s1n: the just read a tutorial which covers the basics, and it will deal with subs and/or methods. They'll use what they'll be taught.

[18:01] <moritz_> it worked the same for Perl 5: the documentation uses some idioms, and people copied them

[18:02] <s1n> moritz_: i would agree, which means people are less likely to use or understand sub/submethod

[18:02] <s1n> because when they define a class, just just want to define a function on the class

[18:03] <Tene> s1n: can you explain "on the class"?

[18:03] <moritz_> they want to define a method on the class ;-)

[18:04] <moritz_> and nearly all other languages call that thing "method" as well

[18:04] <s1n> okay, lemme try with another example in another language

[18:05] <s1n> class A { void foo() { ... } };  #c++, foo is defined as a method on instances of A

[18:05] <s1n> requires no additional knowledge other than i put it inside A's definition

[18:06] <moritz_> s1n: at the cost of less flexibility

[18:06] <s1n> moritz_: how so?

[18:06] <moritz_> s1n: you can't declare a function in a class in C++

[18:06] <s1n> it defaults inside

[18:07] *** smtms joined
[18:07] <s1n> moritz_: class A { static void foo() { ... } };

[18:07] <moritz_> s1n: that's a static method, not a function.

[18:07] <s1n> wtf is the difference?

[18:07] <Tene> that's a... what mroitz said

[18:07] <moritz_> s1n: how do you call a static method?

[18:07] <s1n> A::foo()

[18:08] <moritz_> well, in Perl you call it as A.foo()

[18:08] <moritz_> and a sub as A::foo()

[18:08] <moritz_> or, if imported, simply as foo()

[18:08] <s1n> so what does A.foo() mean? shouldn't it be $a.foo()?

[18:09] <moritz_> A.foo() means "call a method on class A"

[18:09] <s1n> then what is A::foo()?

[18:09] <Tene> s1n: the issue is that @larry feel strongly that keywords suddenly having different behaviors in different places is a very bad thing.

[18:09] <moritz_> that's calling a function in A's namespace

[18:09] <moritz_> which is *not* a method call

[18:10] <Tene> because in Perl 5 it has lead to a large list of arbitrary things to memorize.

[18:10] <moritz_> and thus determined by lexical scope and namespace

[18:10] <Tene> instead of "This construct behaves this way", you had to memorize "This construct behaves in these three ways in these three different situations"

[18:10] <moritz_> a method call is always independent of namespace and scope

[18:11] <s1n> forget it, it's not worth it

[18:13] *** masak joined
[18:13] <Tene> hi masak

[18:13] <Tene> masak: I added LolDispatch to web.  it maybe needs a less silly name?

[18:21] *** ejs1 joined
[18:24] * moritz_ is a bit annoyed that his blog still doesn't show up in the ironman feed, and mst doesn't respond to emails anymore

[18:25] <masak> Tene: I think the name is very fitting. :)

[18:25] <masak> Tene: but you should definitely blog about it, and about the pastebin.

[18:34] <s1n> let's say i wanted to introduce or change some syntax (like a grammar) within the language, do i do that with protos?

[18:35] <moritz_> usually not

[18:36] <moritz_> either with macros

[18:36] <moritz_> or something like

[18:36] <moritz_> augment slang Regex { token backslash:std<\Y> { YY }; }

[18:37] <moritz_> that would introduce a new \Y token, which matches the literal YY

[18:37] <moritz_> (very silly, but what I used in a test recently)

[18:37] <moritz_> rakudo: rx:P5//

[18:37] <p6eval> rakudo e6363e: OUTPUT¬´Colons cannot be used as delimiters in quoting constructs at line 1, near ":P5//"‚ê§‚ê§current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)‚ê§¬ª

[18:38] <moritz_> rakudo: m:P5//

[18:38] <p6eval> rakudo e6363e: OUTPUT¬´Colons cannot be used as delimiters in quoting constructs at line 1, near ":P5//"‚ê§‚ê§current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)‚ê§¬ª

[18:41] <pugs_svn> r26758 | moritz++ | [t/spec] improve fudging of capture.t; vim modeline

[18:41] <pugs_svn> r26759 | moritz++ | [t/spec] avoid newlines in test descriptions

[18:46] <s1n> moritz_: can i augment any keyword or STD expression?

[18:47] <moritz_> s1n: yes

[18:48] <s1n> so i can do something like 'augment slang If { ... }'?

[18:48] <moritz_> no

[18:48] <s1n> #i don't know what the syntax in STD is for 'if'

[18:49] <s1n> well, i was trying to say, can i augment a keyword like 'if', is that just not possible?

[18:50] <moritz_> augment slang MAIN { token statement_control:sym<if> { IFF } }

[18:50] <moritz_> then you can write 'IFF 3 < 4 {  say "yes" } '

[18:51] <s1n> can i change IFF to be if with some other change?

[18:51] <s1n> that looks like i'm only allowed to alias things, i want to actually augment the existing tokens

[18:52] <moritz_> actually my example was bogus

[18:52] <s1n> heh

[18:52] <moritz_> you'd neet do put in the regex to match a whole `if' statement, including condition, else, elsif blocks etc.

[18:52] <s1n> even when you're just augmenting it?

[18:52] <moritz_> see STD.pm, lines 1256ff

[18:53] * s1n goes off to look

[18:53] <moritz_> what do you mean by "just augmenting"?

[18:53] <s1n> well, augment, to me, means i'm just augmenting existing behavior in some way, not redefining it

[18:54] <moritz_> so you want to change the semantics, not the syntax?

[18:54] <s1n> moritz_: both :)

[18:54] <moritz_> s1n: if you want to change both, you'd be better off with a macro

[18:54] <s1n> are there spectests for macros?

[18:54] <moritz_> yes, a few

[18:56] <s1n> Missing test file: t/spec/S12-class/is_also_instead.t

[18:57] <moritz_> uhm, did I forgot to push?

[18:58] *** abra joined
[18:58] *** fuad joined
[18:58] <moritz_> s1n: cbc1bf6140f9c31872b51ddf9c6a7161845c789c should have fixed that

[18:59] <s1n> moritz_: ahh, okay, i checked that out yesterday, so i updated

[19:00] <s1n> rakudo: macro f { '1 + 1' }; f.say;

[19:00] <p6eval> rakudo e6363e: OUTPUT¬´Could not find non-existent sub f‚ê§current instr.: '_block14' pc 64 (EVAL_16:49)‚ê§¬ª

[19:00] <moritz_> rakudo doesn't do macros

[19:00] <s1n> oh, bummer :(

[19:00] <moritz_> which is why there are so few tests

[19:02] <s1n> okay, well, can i do this then: macro if { True }; if False { say "oh hai"; }

[19:03] <moritz_> no

[19:03] <moritz_> if you tell me what you want to achieve, maybe I can help you better

[19:04] *** jan___ joined
[19:11] <s1n> moritz_: i want to alter the syntax and semantics of a keyword, let's start with the if statement

[19:11] <s1n> let's see, we can maybe add something like the comma operator from c?

[19:11] <s1n> (just an example to get me started)

[19:12] <moritz_> so what does the comma operator from C do?

[19:12] <s1n> kinda like shortcuircuting, so you can have multiple clauses

[19:12] <s1n> bad way of doing && :)

[19:13] <moritz_> well, the comma is taken in Perl 6 already

[19:13] <moritz_> so that's kinda hard

[19:13] <s1n> so let's invent one

[19:14] <s1n> btw, it's not entirely like &&, just trying to give an example: http://en.wikipedia.org/wiki/Comma_operator 

[19:14] <moritz_> let's say you want ,, to do the same thing that && does

[19:14] <moritz_> then you could do something along these lines:

[19:15] <moritz_> macro infix:<,,>($a, $b) { quasi {{{ $a && $b }}} }

[19:16] <s1n> i could then do 'if True ,, False { say "never happens" }'

[19:16] *** payload joined
[19:16] <moritz_> right

[19:17] <s1n> but that's not modifying 'if', it's adding a new infix operator

[19:18] <s1n> i'm trying to think of something else we could do to modify sym:if...

[19:18] *** M_o_C joined
[19:18] <s1n> maybe always return True

[19:19] <s1n> maybe if is a bad example

[19:19] <s1n> maybe make 'loop' behave like 'while'?

[19:19] <s1n> (one Bool clause)

[19:20] *** cspencer joined
[19:22] <moritz_> augment slang MAIN { token statment_control:loop is parse &statment_control:while { quasi {{{ while $/<xblock><EXPR>.compile { $/<xblock><pblock>.compile } }}} } } # perhaps something along these liens

[19:25] <dalek> rakudo: 496e1f0 | moritz++ | t/spectest.data:

[19:25] <dalek> rakudo: a few more files for t/spectest.data

[19:25] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/496e1f0dbe9401beebcfa0da40fe274d18f8434d

[19:26] *** jferrero joined
[19:29] *** masak joined
[19:30] <masak> does 'augment slang' require MONKEY_PATCHING, or something similar?

[19:30] <fuad> masak:hello friend

[19:30] <moritz_> masak: dunno

[19:30] <masak> fuad: greetings, fuad. also known as usr. :)

[19:31] <fuad> yeah:)

[19:31] <fuad> im here again

[19:31] * moritz_ only knows urs

[19:31] <masak> fuad: me too. :)

[19:31] <masak> fuad: as you can tell, the network I use in the evenings is flaky.

[19:31] *** [particle] joined
[19:32] <fuad> hi moritz_

[19:32] <moritz_> hi fuad ;-)

[19:33] <s1n> moritz_: that's an interesting macro, i'd like to see how that works out :)

[19:33] <moritz_> s1n: me too ;-)

[19:34] <s1n> i'm kinda interested in being able to do things like that, to see what i can get the lang to do :)

[19:37] *** abra joined
[19:38] <masak> s1n: re subs/methods, I've been using classes and methods for almost a year now, and I don't experience the issue you're describing -- accidentally combining class/sub, then trying to call the sub as a method and then spending hours searching for the problem.

[19:38] <s1n> masak: then i must be an idiot

[19:38] <masak> s1n: I suggest you examine whether this might not be a correct design in Perl 6 after all.

[19:39] <masak> s1n: I didn't say that.

[19:39] <s1n> masak: what do you mean examine if it's a correct design?

[19:39] <masak> s1n: it might simply be that you have more Perl 5 experience than I do.

[19:39] <masak> s1n: I mean that for me, it works very well.

[19:39] <masak> s1n: I use methods and subs interchangably in classes, and I don't often confuse them.

[19:39] <s1n> masak: well, i have more c/c++ experience than anything else, so that's where i'm coming from

[19:40] <masak> ok.

[19:40] <jnthn> masak: If you're using methods and subs interchangably, you might have issues. ;-)

[19:40] <masak> jnthn: how so?

[19:40] <s1n> masak: it's a matter of how every other language treats methods

[19:41] <masak> jnthn: I can call subs from methods. no harm in that.

[19:41] <masak> s1n: Perl 6 doesn't necessarily aspire to conform to how other languages do things. :)

[19:42] <s1n> masak: right, and everyone else here seems bent on keeping the current behavior

[19:42] <jnthn> masak: Ah, that was a sentence with more than one reading. :-)

[19:42] <jnthn> I get the one you meant now.

[19:42] <masak> s1n: including me. but I wouldn't describe it as 'bent on'. I just don't find a problem with it.

[19:44] <s1n> my main point was that sub/method/submethod all sound the same and mean the same thing to me mentally. i just wanted to define a function in the class (instance function), i really didn't want to have to think "gee, what kind of function is this" because i already put it inside the class

[19:44] <masak> jnthn: would it be possible to issue a warning message in s1n's confusion case, something like "did you mean to declare 'test' as a method?" ?

[19:45] <masak> s1n: I see your point.

[19:45] <masak> s1n: I use the distinction sub/method to my advantage within classes, so I'm not sure I would welcome your solution.

[19:45] <moritz_> once macros and syntax changes work, the obvious solution is to define your own Perl 6 slang

[19:45] <masak> "there will be modules."

[19:46] <s1n> well, if i put the class as a single line declarator, that makes sense to have to say, but i put the function _inside_ the class closure, it just made sense that it would figure it out for me

[19:47] <masak> s1n: there's still some dissonance between your model and mine, it seems.

[19:47] <masak> I cannot make sense of your last utterance.

[19:47] <s1n> heh

[19:47] <masak> "figure it out for me" -- please elaborate.

[19:47] <jnthn> masak: The error message is already very clear. "There's no method called foo on class A." Well, that suggests I think quite clearly enough "go look through class a for method foo". :-)

[19:48] <jnthn> *A

[19:48] <masak> jnthn: agreed.

[19:48] <jnthn> There's lots of Rakudo errors that aren't great, but that's one of the less bad ones, IMO.

[19:48] *** explorer__ joined
[19:48] <fuad> jnthn:Hi mate

[19:49] <masak> jnthn: nod.

[19:49] <s1n> when i think of code, i think in psuedocode, then translate. i thought "gee, i want to add a function to instances of this class", i accidentally translated that in perl6 to a 'sub' and i spent forever trying to find where i messed up on the function

[19:49] <jnthn> fuad: hi :-)

[19:49] <s1n> i put the sub inside the class but it didn't know that i meant method because it's inside class A{}

[19:49] <s1n> sub and method are too mentally similar to me and i messed it up

[19:49] <fuad> jnthn:im yesterday`s guy which have used nickname usr,so from now im with this nickname;)

[19:50] <masak> s1n: ok, so this is from the perspective of someone learning Perl 6, and that someone doesn't know subs from methods?

[19:50] <jnthn> fuad: Ah, OK. :-)

[19:50] <s1n> masak: this is from the perspective of someone wanting to put a function inside a class and perl6 not knowing that i will likely never mean sub and usually mean method

[19:51] <s1n> subs will probably go outside classes, methods inside

[19:51] <s1n> unless i've yet again misunderstood things

[19:53] <s1n> the only reason why i even discussed this was in the hopes that _someone_ might see my frustrations and say "hmm, is this the best way to do this?"

[19:53] <masak> s1n: does your usage of the word 'function' include both subs and methods?

[19:53] <masak> s1n: it's quite brave of you to enter a community in the hopes of changing its mind. :)

[19:53] <s1n> masak: my usage of function is a closure, where i put it or explicit definition is what separates method/sub

[19:54] <masak> s1n: ok, 'closure' and 'function' is another pair of terms which could create confusion in discussions between us. :)

[19:54] <s1n> masak: not trying to change it's mind, i just want the best product that will be fun to use and will attract lots of users, anything i can do to achieve that, the better

[19:54] <s1n> masak: how about "a block of code that can be called from somewhere by name" heh

[19:55] <masak> s1n: again, I'm one of those users. I'm happy with this aspect of Perl 6. you seem not to be.

[19:55] <masak> s1n: that definition works.

[19:55] <masak> s1n: it differs from my view of a closure as something ordinarily anonymous.

[19:56] <s1n> masak: right, like i said, i seem to be the only one

[19:56] <s1n> masak: a closure is just that block without a name :)

[19:56] <masak> s1n: yes. but a sub or a method in Perl 6 is not just a block with a name.

[19:56] <s1n> i always think conceptually before i write anything, it allows me to work with _many_ languages on a regular basis :)

[19:57] <masak> s1n: my only recommendation is to try using the 'method' keyword with an open mind.

[19:58] <s1n> masak: all i can really do is provide feedback

[19:59] <masak> s1n: sure. that's what #perl6 is for.

[19:59] <s1n> i don't necessarily have a solution (Tene) or maybe even a really good explanation (moritz_), i'm doing the best i can with the mental converters for perl6 that i have :)

[19:59] <s1n> i hunted down the same mistake after a number of hours enough to want to say something

[20:00] <s1n> no one agrees, so i guess the world keeps turning

[20:00] <masak> s1n: yes, I've often come into #perl6 with complaints having had similar experiences.

[20:00] <masak> s1n: but not with this one.

[20:00] <s1n> heh

[20:00] <masak> s1n: it might be your unique C/C++ background that makes you turn down this particular garden path.

[20:00] * s1n quits climbing uphill

[20:01] * skids skips technical nitpicking on what "closure" actually means because he'd probably just get owned by a CS major :-)

[20:01] <masak> skids: :)

[20:01] <masak> skids: a closure is just a thunk. :P

[20:02] <skids> thunk is an overloaded term even by CS standards.

[20:02] <s1n> i have to think conceptually like this because i work with no less than 5 languages at work, perl6 for a hobby, and the graduate degree that has no language focus (only conceptual ideas with implementations in whatever)

[20:05] <s1n> at the very least, i'd like to be able to alter this behavior

[20:06] *** LadyLuna1y joined
[20:07] <skids> So you have no intention of ever using class-global subs (no invocant, but part of a class?)

[20:08] <s1n> no i might, but i'd like something like 'static method foo' instead of 'sub foo'

[20:08] <s1n> but that's just a c/c++ weenie talking :)

[20:09] <s1n> that way all methods in a class are really instance methods for the class, and there is no sub :)

[20:10] <jnthn> s1n: The other thing to remember is that if you declare a method foo you can't just call it as a subroutine foo() in Perl 6. Sub dispatch and method dispatch are different things.

[20:11] <s1n> that way i can merrily do "class A { method foo{}; method bar{}; static method baz{} }" and mentally seperate baz out as something different

[20:11] <s1n> jnthn: i have no idea what you meant by that lol

[20:11] <masak> mberends: so, are you using that pumkin right now?

[20:11] *** FurnaceBoy joined
[20:12] <skids> s1n: you could do method foo is export... just you'd always have to have the invocant as first arg.

[20:14] <s1n> skids: sadly, i once again didn't understand that

[20:15] <skids> method foo is export will also generate an exported sub in the namespace.  multi method foo is export will let you do it from more than one class with the same method name.

[20:15] <jnthn> s1n: class A { method foo() { }; method bar() { foo() } } # This call to foo() is an error, you need to call it as a method

[20:15] <jnthn> s1n: class A { sub foo() { }; method bar() { foo() } } # This call to foo() works fine since you're using sub-calling syntax to call a sub

[20:15] <s1n> jnthn: to me, that's a failure in design, because self should be implied

[20:16] <skids> You don't always want self on helper functions.

[20:16] <jnthn> s1n: It's just about avoiding confusion between method dispatch and sub dispatch.

[20:17] <s1n> jnthn: still doesn't sound like a good idea

[20:17] <s1n> jnthn: you honestly think people aren't going to make that mistake enough to be put off by it?

[20:17] <jnthn> s1n: The maning of "push @foo, 42" changing because your class happened to define a push method to me seems like a worse one.

[20:17] <jnthn> *meaning

[20:18] *** frew|work joined
[20:19] <s1n> jnthn: i dunno, it seems unnatural that self is not implied

[20:19] <jnthn> Only if you want to overvalue object orientation at the expense of other paradigms.

[20:21] <s1n> jnthn: does perl6 have a full fledge object model or a second class object model? seems to me that method dispatch takes precedence

[20:21] *** pmurias joined
[20:22] <jnthn> I'm not even sure how you'd distinguish the two.

[20:22] <jnthn> I think it's safe to say that Perl 6 is a multi-paradigm language, and that object orientation is one paradigm that it provides a lot of support for. But it's not the only one that matters either.

[20:24] <frew|work> jnthn: couldn't we have both sub and method?

[20:24] <s1n> it's okay that no one else agrees with me now, but the first thing i'll do with macros is obsolete sub and change method to behave as i mentally mean it to

[20:24] <jnthn> frew|work: We do.

[20:24] <frew|work> but method doesn't imply self?

[20:24] <jnthn> frew|work: Yes, and also that the thing is callable as a method.

[20:24] <s1n> frew|work: only if the invocant is specified

[20:25] <jnthn> Which if you're calling it as self.foo() it is :-)

[20:25] <s1n> even within the class itself, self has to be specified

[20:25] <frew|work> but if I have this I'm good:

[20:25] <jnthn> Right. If you're calling another method.

[20:25] <s1n> again, bring on the macros :)

[20:25] <frew|work> method(:$self, $foo) {}

[20:25] <jnthn> frew|work: Did you mean for the colon to be after $self ?

[20:26] * frew|work can't remember invocant syntax

[20:26] <frew|work> sure?

[20:26] <frew|work> yeah

[20:26] <jnthn> ($self: $foo)

[20:26] <frew|work> that's not so bad.  And it should be easy to do what s1n wants with a grammar extension right?

[20:26] <jnthn> std:  method(:$self, $foo) {}

[20:26] <p6eval> std 26759: OUTPUT¬´##### PARSE FAILED #####‚ê§Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/xqquTAUi16 line 1:‚ê§------> [32mmethod(:$self, $foo) [31m{}[0m‚ê§    expecting any of:‚ê§   infix or meta-infix‚ê§      infix stopper‚ê§    standard

[20:26] <p6eval> ..stopper‚ê§ termina...

[20:27] <frew|work> when that works

[20:27] <jnthn> Ah, yes. Space needed if you're declaring an anonymous method.

[20:27] <jnthn> std:  method (:$self, $foo) {}

[20:27] <p6eval> std 26759: OUTPUT¬´##### PARSE FAILED #####‚ê§Can't put required parameter after variadic parameters at /tmp/4p6wHXhHnY line 1:‚ê§------> [32mmethod (:$self, $foo[31m) {}[0m‚ê§    expecting any of:‚ê§     parameter‚ê§        post_constraint‚ê§  trait‚ê§  whitespace‚ê§FAILED 00:02 36m‚ê§¬ª

[20:27] <jnthn> std:  method ($self:, $foo) {}

[20:27] <jnthn> gah!

[20:27] <p6eval> std 26759: OUTPUT¬´##### PARSE FAILED #####‚ê§Unable to parse multisig; couldn't find final ')' at /tmp/Pqv2c0yv3f line 1:‚ê§------> [32mmethod ($self:[31m, $foo) {}[0m‚ê§    expecting any of:‚ê§  parameter‚ê§        signature‚ê§        whitespace‚ê§FAILED 00:02 36m‚ê§¬ª

[20:27] <frew|work> nice try.

[20:27] <jnthn> lol, OK, I give up

[20:27] *** szbalint joined
[20:27] <jnthn> std:  method ($self: $foo) {}

[20:27] <p6eval> std 26759: OUTPUT¬´ok 00:02 36m‚ê§¬ª

[20:27] <jnthn> phew

[20:27] <frew|work> std: method ($self: $fo) {}

[20:27] <p6eval> std 26759: OUTPUT¬´ok 00:02 36m‚ê§¬ª

[20:28] *** antiphase joined
[20:28] <skids> yeah, the colon, comma equivalence is going to take some habituating here too.

[20:28] <frew|work> it makes sense

[20:28] <s1n> rakudo: class A { method foo($self: $fo){ say "oh hai" }; method bar { foo; } }; my A $a .= new; $a.bar;

[20:29] <p6eval> rakudo 496e1f: OUTPUT¬´too few arguments passed (0) - 2 params expected‚ê§current instr.: 'parrot;A;foo' pc 173 (EVAL_23:82)‚ê§¬ª

[20:29] <s1n> is that wrong?

[20:29] <jnthn> s1n: Yes.

[20:29] <jnthn> erm

[20:29] <jnthn> well, the code is wrong, Rakudo is right.

[20:29] <pmurias> s1n: btw what languages do you use at work?

[20:29] <skids> It does make sense, it's just getting my autonomous spurious-punctuation-and-overparenthesization system trained for it. :-)

[20:30] <jnthn> rakudo: class A { method foo($self: $fo){ say "oh hai" }; method bar { self.foo(42) } }; my A $a .= new; $a.bar;

[20:30] <s1n> pmurias: c, c++, (c-tran even), perl, shell scripting, java, python

[20:30] <p6eval> rakudo 496e1f: OUTPUT¬´oh hai‚ê§¬ª

[20:30] <s1n> jnthn: i was wanting to not have to say self

[20:30] <jnthn> rakudo: class A { sub foo($fo){ say "oh hai" }; method bar { foo(42) } }; my A $a .= new; $a.bar;

[20:30] <p6eval> rakudo 496e1f: OUTPUT¬´oh hai‚ê§¬ª

[20:30] <jnthn> Then write that second one.

[20:31] <jnthn> But remember that declares a sub, not a method.

[20:31] <frew> I think it would be cool if method defaulted the invokant into $self if one wasn't specified

[20:31] <pmurias> what's the point?

[20:31] <jnthn> frew: It's always available as "self". :-)

[20:31] <s1n> frew: jnthn just recommended otherwise

[20:31] <pmurias> you have self

[20:31] * frew didn't know that

[20:31] <frew> what's the point of defining $self if self is available?

[20:32] <jnthn> frew: Not much. :-)

[20:32] <jnthn> frew: method foo(@list: $x) { ... } can be useful though if your invocant is an array for example.

[20:32] <jnthn> But the scalar from is less useful.

[20:33] <pmurias> method foo(&f) {...} 

[20:33] <frew> well yeah, but if you are building a regualr class...

[20:33] <skids> It's for when you don't want to code in the first person :-)

[20:33] <jnthn> ;-)

[20:33] * frew regularly doesn't code in first person, but that's javascript

[20:33] <frew> prototypical OO, though weird, can be very sexy

[20:34] <pmurias> s1n: if one is confusing methods and subs wouldn't having them under a joint keyword confuse him even more

[20:34] <pmurias> ?

[20:35] * frew agrees with pmurias 

[20:35] <frew> now that I know that self is always available I don't see why you want to do what you want to do s1n 

[20:36] <skids> method talks($he: $babble) # coded by extrovert   ... method talk($you: $babble) # coded by dominatrix 

[20:36] <frew> does anyone know if we could have some kind of function case statement in p6?  so that you could do something like this:

[20:37] <frew> my $foo = given $foo { when 'bar' { 'baz' } };

[20:37] <s1n> pmurias: it wouldn't be under one keyword, the class-based method would need a modifier like multi

[20:37] <Tene> got a basic blog app running in 20 mins on rakudo. :)

[20:37] <s1n> frew: fyi, self isn't _always_ available, not in BUILD

[20:38] <pmurias> class-based method = ?

[20:38] <Tene> I heard masak did a speed-run blog app earlier, and I wanted to try.

[20:38] <frew> but self doesn't really exist in BUILD yet, does it?

[20:38] <pmurias> it should

[20:39] <pmurias> frew: submethods are just methods you don't inherit

[20:39] <frew> it should exist or self should work?

[20:39] <pmurias> it exists

[20:39] <Tene> will post when I get to my hotel.

[20:39] <s1n> i'm going to just take a backseat on this argument, it's clear my opinion is at odds here, i'd rather just deal with it until i get macros

[20:41] * frew hopes macros don't end up being sketch like filters are in p5

[20:41] <frew> I know they are supposed to be real macros, but still

[20:42] <s1n> if they're anything like c++ macros that let me fundamentally change anything as i see fit, i'll be a happy camper :)

[20:43] <frew> but shouldn't we theoretically be able to change syntax in p6 w/o a macro?

[20:43] <frew> just modify the grammar right?

[20:43] <pmurias> yes

[20:43] <frew> which can be done in code

[20:43] <jnthn> rakudo: my $tester = { given $^condition { when 42 { say "the answer" }; when 0 { say "nothing" } } }; $tester(42); $tester(0);

[20:43] <s1n> yeah, but macros let you do it in a module without redistributing the perl6 STD grammar

[20:43] <p6eval> rakudo 496e1f: OUTPUT¬´the answer‚ê§nothing‚ê§¬ª

[20:43] <frew> oooh

[20:43] <jnthn> frew: See above in answer to your question.

[20:44] <jnthn> rakudo: my &tester = { given $^condition { when 42 { say "the answer" }; when 0 { say "nothing" } } }; tester(42); tester(0); # may work too

[20:44] <p6eval> rakudo 496e1f: OUTPUT¬´the answer‚ê§nothing‚ê§¬ª

[20:44] <frew> woo!

[20:44] <jnthn> yay

[20:44] <frew> awsome

[20:44] <jnthn> That's a bit neater. :-)

[20:44] <frew> this means I will be writing dispatch tables 90% less often!

[20:45] <jnthn> frew: Don't forget there's multi-dispatch too. :-)

[20:45] <frew> oh I know

[20:45] <frew> and I miss it at work

[20:45] <jnthn> In this case it's more code, though.

[20:45] <s1n> actually, that was something i was looking for exactly for something else! thanks!

[20:45] <frew> :-)

[20:45] *** donaldh joined
[20:46] <frew> I am writing a web based test thing for at work, and multi dispatch and that version of given/when make the code even neater

[20:46] <frew> s/for at/for use at/

[20:59] *** zamolxes joined
[21:00] *** fridim joined
[21:01] *** nemstep joined
[21:13] <moritz_> I've added enough new tests that the overall number of passing tests increased ;-)

[21:13] <moritz_> 11179

[21:13] <frew> haha

[21:13] <fuad> moritz_ im off to bed dude,have a nice time.Take care:)

[21:13] <frew> how good do you think the coverage is for the language as a whole?

[21:14] <fuad> jnthn:take care dude,im out:)

[21:14] <moritz_> frew: dunno, perhaps 60%

[21:15] <jnthn> fuad: See you. :-)

[21:15] <jnthn> moritz_: Nice! :-)

[21:17] <moritz_> but most of the coverage isn't really good

[21:17] <moritz_> for example macros and object pipes are nearlly not tested, only a tiny bit

[21:18] <moritz_> but that's really hard to do as long as no compiler implements them

[21:21] <patmat> i wish everyone a good night!!

[21:21] <moritz_> good night

[21:21] <fuad> g`night patmat

[21:21] <jnthn> night

[21:22] <jnthn> moritz_: Yeah, I agree on the "hard to test without a compiler getting close to attempting them" thing.

[21:22] <moritz_> jnthn: speaking of which, are there any new features you want to do soonish, and which need more tests?

[21:23] <jnthn> moritz_: In theory, everything in http://news.perlfoundation.org/2009/04/hague_perl_6_grant_request_tra.html

[21:23] <jnthn> ;-)

[21:24] <moritz_> jnthn: yeah, I looked at it some time ago, and picked the item from the bottom ;-)

[21:24] *** meppl joined
[21:25] <jnthn> moritz_: There's this section called the project plan that gives an odering... ;-)

[21:26] <jnthn> erm, ordering... :-)

[21:26] <jnthn> moritz_: Traits tests are good though of course. :-)

[21:26] <jnthn> D3 should be not too hard to write tests for.

[21:26] <jnthn> But we may already have some.

[21:27] * moritz_ takes a look

[21:27] <jnthn> D2 has some coverage.

[21:28] <pugs_svn> r26760 | moritz++ | [t/spec] don't use outer lexicals in submethods.t

[21:28] <pugs_svn> r26761 | moritz++ | [t/spec] fudge capture.t for rakudo

[21:28] <pugs_svn> r26762 | moritz++ | [t/spec] bring new-symbols.t more in line with S02 and S05

[21:28] <pugs_svn> r26763 | moritz++ | [t] update TASK, tests for unary [!=] etc

[21:30] <mberends> general question, is it wrong that 'constant FOO =42;' in a module does not put FOO in the script using the module? Also tried adding 'is export', no dice.

[21:31] <jnthn> mberends: It's wrong, and is export will be the way to do it.

[21:31] <moritz_> rakudo: module A { constant FOO is export(:DEFAULT) = 3 }; say FOO

[21:31] <p6eval> rakudo 496e1f: OUTPUT¬´Null PMC access in isa()‚ê§current instr.: 'parrot;List;!flatten' pc 6781 (src/classes/List.pir:215)‚ê§¬ª

[21:31] <jnthn> But is export on a constant currently doesn't work.

[21:31] <moritz_> ticket!

[21:31] *** eternaleye joined
[21:31] <jnthn> oh noes where's masak?!

[21:31] <moritz_> where's masak when you need him? ;-)

[21:31] <mberends> shall I report it? ... ok moritz_ 

[21:31] <moritz_> mberends: go ahead please

[21:31] <jnthn> ...I love how "ticket" and "masak" are about synonyms now.

[21:32] <mberends> masak's neighbour probably switched off their communal router.

[21:32] <moritz_> "can you masak it?" ;-)

[21:32] <mberends> just a poor imitation, i'm afraid ;-)

[21:32] * skids notes small edit distance masak --> mistake --> ticket

[21:34] <jnthn> Rakudo has so many masaks.

[21:34] <jnthn> .oO( But I'm working to get rid of them. Mwaha. )

[21:35] <moritz_> does $obj.?method returns a list?

[21:35] <moritz_> I know .+ and .* does

[21:37] <jnthn> moritz_: Not AFAICR.

[21:37] <jnthn> moritz_: Just undef or the result.

[21:38] <moritz_> jnthn: thanks

[21:38] <jnthn> moritz_: Feel free to review my .WALK tests too.

[21:44] <moritz_> rakudo: say 3.3.int

[21:44] <p6eval> rakudo 496e1f: OUTPUT¬´3‚ê§¬ª

[21:51] <pugs_svn> r26764 | moritz++ | [t/spec] improve and extend parallel dispatch tests

[21:54] <moritz_> rakudo: use Test; plan 1; is_deeply((1, 2), [1, 2])

[21:55] <p6eval> rakudo 496e1f: OUTPUT¬´1..1‚ê§ok 1 - ‚ê§¬ª

[21:55] <frew> rakudo: use Test; plan 1; is_deeply([1, 2), [1, 2])

[21:55] <frew> rakudo: use Test; plan 1; is_deeply([1, 2], [1, 2])

[21:56] <p6eval> rakudo 496e1f: OUTPUT¬´Statement not terminated properly at line 1, near "([1, 2), ["‚ê§‚ê§current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)‚ê§¬ª

[21:56] <p6eval> rakudo 496e1f: OUTPUT¬´1..1‚ê§ok 1 - ‚ê§¬ª

[21:56] <moritz_> I guess is_deeply has no way to distinguish these

[21:56] <frew> rakudo: use Test; plan 1; is_deeply((1, 2), (1, 2))

[21:56] <p6eval> rakudo 496e1f: OUTPUT¬´1..1‚ê§ok 1 - ‚ê§¬ª

[21:56] <frew> hm.

[21:56] <frew> well isn't it supposed to be the same?

[21:56] <moritz_> not quite

[21:57] <moritz_> if you assign it to a scalar, (...) is promoted to a Capture (which is immutable)

[21:57] <moritz_> but [...] is a (mutable) Array

[21:58] <frew> rakudo: my $foo = [1,2,3];

[21:58] <p6eval> rakudo 496e1f:  ( no output )

[21:58] <frew> why is that legal?

[21:58] <frew> rakudo: my $foo = (1,2,3);

[21:58] <moritz_> why shouldn't it be?

[21:58] <p6eval> rakudo 496e1f:  ( no output )

[21:58] <frew> well, I thought we didn't have references like we did in p5, so I figure that $foo = [1,2,3] kinda kills the point of sigils

[21:59] <moritz_> actually it's the other way round: we don't need Perl5esq references because everything is an object anyway

[21:59] <moritz_> you can still use @a and %a to enforce particular types

[22:00] <moritz_> you can also write $a = [1, 2, 3]; is Perl 5

[22:00] <frew> rakudo: my $foo = [1,2,3]; $foo[1];

[22:00] <p6eval> rakudo 496e1f:  ( no output )

[22:00] <frew> rakudo: my $foo = [1,2,3]; say $foo[1];

[22:00] <p6eval> rakudo 496e1f: OUTPUT¬´2‚ê§¬ª

[22:01] <frew> so all @ really does is force it to be an array

[22:01] <moritz_> it still does a little more

[22:01] <moritz_> for example 'my @a' is not only a type constraint

[22:01] <moritz_> but it instantiates an array object

[22:02] <moritz_> 'my Array $x; $x.push(3)' wouldn't work, because there's no Array object in $x yet

[22:02] <frew> weird...

[22:02] <moritz_> (unless by some magic autovivification; but it sure wouldn't work in the general case)

[22:03] <frew> so $foo = [1,2,4] is like... a lightweight version

[22:03] <moritz_> lightweight compared to what?

[22:03] <frew> I dunno, the real object?

[22:03] <moritz_> the object in $foo is just a real array object like the one in @foo

[22:03] <moritz_> (when you do my @foo = 1, 2, 3;'

[22:04] <frew> but not yet instantiated?

[22:04] <moritz_> s/'/)/

[22:04] <moritz_> sure it's instantiated

[22:04] <frew> oooh

[22:04] <frew> sorry

[22:04] <frew> I didn't read what you said carefully enough

[22:05] <frew> that makes sense

[22:05] <frew> so my Array $a .= new; is equiv (more or less) to my @a;

[22:06] <moritz_> more or less, yes ;-)

[22:06] <moritz_> there are still other effects that I forgot

[22:06] <moritz_> for example @a = ... imposes list context

[22:07] <moritz_> $a = ... imposes item context, even if there's an Array stored in $x

[22:07] <frew> this making () and [] unnecessary

[22:07] <mberends> oops, rakudobug sent, forgot to prefix subject with [BUG]

[22:07] <frew> but ultimately this means that @ is much more sugar than it was before, correct?

[22:08] <moritz_> yes

[22:08] <moritz_> rakudo: say (1, 2, 3).perl; say (1, [2, 3]).perl

[22:08] <p6eval> rakudo 496e1f: OUTPUT¬´[1, 2, 3]‚ê§[1, [2, 3]]‚ê§¬ª

[22:08] <moritz_> # not quite unnecessary ;-)

[22:09] <moritz_> you *can* write Perl 6 like PHP, with only the $ sigil

[22:09] <moritz_> but it's not idiomatic, and not recommended

[22:10] <frew> what does that even mean?

[22:10] * frew doesn't know PHP

[22:10] <moritz_> PHP uses $ on all variables

[22:10] <frew> oooh

[22:11] <moritz_> they have a bit less syntax, and try to make up for it with more than 3000 functions in the default namespace ;-)

[22:11] <frew> yeah, I knew about that

[22:12] <moritz_> but ridiculing PHP is no fun; it's too easy

[22:12] <frew> I just think that something annoying could happen that could confuse people ( sub foo { return [1,2,3] }; my $bar = foo )

[22:12] <frew> is there a way to avoid that?

[22:13] <moritz_> yes, return (1, 2, 3) instead ;-)

[22:13] <frew> will that give an error?

[22:13] <moritz_> no

[22:14] <frew> but [] will give an error?

[22:15] <frew> rakudo: sub frew { return [1,2,3]; } my $station = frew; say $station;

[22:15] <p6eval> rakudo 496e1f: OUTPUT¬´Statement not terminated properly at line 1, near "my $statio"‚ê§‚ê§current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)‚ê§¬ª

[22:15] <frew> rakudo: sub frew { return [1,2,3]; }; my $station = frew; say $station;

[22:15] <p6eval> rakudo 496e1f: OUTPUT¬´1 2 3‚ê§¬ª

[22:16] <frew> rakudo: sub frew { return (1,2,3); }; my $station = frew; say $station;

[22:16] <p6eval> rakudo 496e1f: OUTPUT¬´1 2 3‚ê§¬ª

[22:16] * frew isn't sure what the difference is

[22:17] <pugs_svn> r26765 | moritz++ | [t/spec] set a few svn props

[22:17] <pugs_svn> r26765 | moritz++ | 

[22:17] <pugs_svn> r26765 | moritz++ | (git-svn)-- for not handling them, and svn-- for not having a sane default

[22:17] <moritz_> rakudo: sub a { (1, 2, 3) }; sub b { [1, 2, 3] }; for a { print "a" }; for b { print "b" };

[22:17] <p6eval> rakudo 496e1f: OUTPUT¬´Could not find non-existent sub for‚ê§current instr.: '_block14' pc 90 (EVAL_17:59)‚ê§¬ª

[22:17] <moritz_> rakudo: sub a { (1, 2, 3) }; sub b { [1, 2, 3] }; for a() { print "a" }; for b() { print "b" };

[22:17] <p6eval> rakudo 496e1f: OUTPUT¬´aaab¬ª

[22:17] <moritz_> frew: that's the difference

[22:18] <frew> weird...

[22:18] <frew> so why doesn't for iterate over the list?

[22:18] <frew> because [] means list right?

[22:18] <moritz_> because [] means "a scalar holding an Array"

[22:19] <moritz_> and () means "a list"

[22:19] <frew> ok

[22:19] <frew> got it.

[22:19] <moritz_> believe me, that has been confusing to all of us.

[22:19] <frew> it's a little strange to my perl5 shaped brain, but one day I'll get used to it and maybe see the benefit

[22:19] <frew> do you grok it and dig it now?

[22:20] <moritz_> the basics

[22:23] <jnthn> [ 1, 2, 3 ] gives you a reference to an array. (1, 2, 3) gives you a list that will flatten.

[22:23] <moritz_> don't mention references, you evil thing!

[22:23] <frew> I'm just gonna stop thinking about it.

[22:23] <jnthn> moritz_: Yeah, I know, but it's how it looks underneath. :-P

[22:24] *** sparc joined
[22:24] <moritz_> the problem with thinking in references is this:

[22:24] <moritz_> rakudo: sub a(@b) { print "b" for @b }; a([1, 2, 3])

[22:24] <p6eval> rakudo 496e1f: OUTPUT¬´bbb¬ª

[22:25] <moritz_> if we pass a reference in, where does the dereferncing happen?

[22:26] <jnthn> It doesn't, it's just a case of binding.

[22:26] <moritz_> so binding dereferences? ;-)

[22:27] <frew> zomg

[22:27] * frew is still confused

[22:27] <frew> don't explain to me

[22:27] <frew> I'm tired of thinking about it really

[22:28] <jnthn> frew: It Just Works. ;-)

[22:28] <jnthn> moritz_: Perhaps best to think of it is

[22:28] <frew> I just think that putting an array in a scalar is confusing and maybe shouldn't work....  It just doesn't seem like something I'd ever want to do

[22:29] <jnthn> rakudo: my @a = [1,2,3]; for @a { .say }

[22:29] <p6eval> rakudo 496e1f: OUTPUT¬´1 2 3‚ê§¬ª

[22:29] <jnthn> rakudo: my @a := [1,2,3]; for @a { .say }

[22:29] <p6eval> rakudo 496e1f: OUTPUT¬´1 2 3‚ê§¬ª

[22:29] <jnthn> So it's not about binding.

[22:30] <jnthn> But note that the @ on the LHS puts the RHS in list context.

[22:30] <jnthn> A [...] doesn't interpolate into a list.

[22:30] <mberends> rakudo: my $a = [1,2,3]; for $a { .say }

[22:30] <jnthn> However, when you pass it as an argument, there's no list context stuff going on there. So the array reference just gets bound.

[22:30] <p6eval> rakudo 496e1f: OUTPUT¬´1 2 3‚ê§¬ª

[22:31] <jnthn> gah, I said reference again!

[22:31] * jnthn thinks we should write the dictionary of Perl 6 swear words.

[22:31] <jnthn> "length" :-O

[22:31] <jnthn> "reference" :-O

[22:31] <frew> good idea

[22:31] <jnthn> It wasn't mine. :-)

[22:32] <jnthn> .oO( if in dobut, disclaim all responsibility )

[22:32] <jnthn> *doubt

[22:50] <skids> .oO(if in donut, eat way out)

[22:50] <dalek> rakudo: a27bbb6 | moritz++ | build/PARROT_REVISION:

[22:50] <dalek> rakudo: bump parrot revision to get Unicode identifiers in named arguments, chromatic++

[22:50] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a27bbb6b222a9da3237c82b6bfdca2ec49971ad3

[22:50] <jnthn> chromatic++ :-)

[22:55] <jnthn> rakudo: sub –º–∞—Ç(:$–¥–æ–±—Ä–µ) { say $–¥–æ–±—Ä–µ ?? "–ì–†–û–í–ù–û!" !! "–ï–ë–ê–¢" }; –º–∞—Ç(:–¥–æ–±—Ä–µ); –º–∞—Ç(:!–¥–æ–±—Ä–µ);

[22:55] <p6eval> rakudo 496e1f: OUTPUT¬´error:imcc:syntax error, unexpected USTRINGC, expecting STRINGC ('unicode:"\u0434\u043e\u0431\u0440\u0435"')‚ê§      in file 'EVAL_17' line 53‚ê§error:imcc:syntax error, unexpected USTRINGC, expecting STRINGC ('unicode:"\u0434\u043e\u0431\u0440\u0435"')‚ê§     in file 'EVAL_17' line

[22:55] <p6eval> ..56‚ê§error:im...

[22:56] <jnthn> Oh, too soon...

[23:11] *** eternaleye joined
[23:50] *** wknight8111 joined
[23:55] *** japhb__ joined
