[00:01] *** Whiteknight left
[00:02] *** eternaleye joined
[00:02] <TimToady> diakopter: and you can think of multiple dispatch as a dispatch to the lexical scope rather than to the object

[00:06] *** cdarroch left
[00:07] *** tak11 joined
[00:20] *** crythias joined
[00:27] <pugs_svn> r28485 | diakopter++ | [vijs/sprixel] sigh 

[00:28] <diakopter> vijs: my $a = 333333333333333333333333333333/444444444444444444444444444444; $a++; say $a;

[00:28] <p6eval> vijs 28484: OUTPUT«777777777777777777777777777777/444444444444444444444444444444␤»

[00:28] <diakopter> no idea whether that's correct

[00:29] <[particle]> vijs: say 777777777777777777777777777777/444444444444444444444444444444 - 333333333333333333333333333333/444444444444444444444444444444;

[00:29] <p6eval> vijs 28484: OUTPUT«execute(): execute error: Rat Additive not yet implemented; srsly!??!?! at vijs line 85.␤»

[00:30] <[particle]> and no easy way to check :)

[00:30] <diakopter> I meant the stringification :P I know the operation is correct

[00:32] <colomon> diakopter: actually, Rakudo stringifies Rats to decimal numbers.  I believe that is intended to be the way it works in the spec as well, though I don't know if the spec reflects that yet.

[00:32] <colomon> rakudo: say 333333/444444;

[00:32] <p6eval> rakudo 0331d6: OUTPUT«0.75␤»

[00:33] * diakopter looks for LCM operation in the libBigInt.js library

[00:33] * diakopter wonders whether Rats should be reduced...

[00:34] <colomon> Rakudo reduces Rats, and I wrote the spectests that way, too.

[00:34] <colomon> I don't think the spec actually says yet....

[00:35] <colomon> rakudo; say (333333/4444444).perl;

[00:35] <colomon> rakudo: say (333333/4444444).perl;

[00:35] <p6eval> rakudo 0331d6: OUTPUT«333333/4444444␤»

[00:35] <colomon> rakudo: say (333333/444444).perl

[00:35] <p6eval> rakudo 0331d6: OUTPUT«3/4␤»

[00:35] <diakopter> oh

[00:36] <colomon> woo-hoo!  My make spectest passed!  Matt-W++

[00:36] *** cj_ joined
[00:37] <colomon> .... on reflection, that makes me think the spectest might be missing some tests, because the prefix:<+> I added is pretty darned stupid...

[00:38] <eternaleye> I've been MIA for the last month or so, and Google isn't getting any result - what's vijs?

[00:38] <colomon> diakopter: The numeric portions of the spec are pretty sketchy right now, and the intent is to track Rakudo's implementation, so far as I know.

[00:40] <diakopter> ok

[00:41] <diakopter> eternaleye: it uses TimToady's STD parser in Perl 5, emits the AST to JS, and interprets it using a JS runtime in V8 (C++/linked in process to perl)

[00:42] <colomon> Oh !@#!$!$@#@#!, I somehow didn't save my changes to op.pir, so that make spectest was completely pointless.  Time to start over again....

[00:42] <eternaleye> Oooh, shiny!

[00:42] <diakopter> eternaleye: I'm just today getting it to sorta run the spectests...

[00:44] * diakopter adds .lcm() method [one-liner] to libBigInt.js   function lcm(b){ return this.multiply(b).divide(this.gcd(b)) }

[00:46] *** jauaor left
[00:48] *** cj left
[00:50] *** zerhash left
[00:54] *** zerhash joined
[00:57] <pugs_svn> r28486 | diakopter++ | [vijs/sprixel] add lcm method to libBigInt.js; implement Rat Additive (also subtraction) 

[00:58] <diakopter> vijs: say 777777777777777777777777777777/444444444444444444444444444444 - 333333333333333333333333333333/444444444444444444444444444444; # for [particle]

[00:58] <p6eval> vijs 28485: OUTPUT«444444444444444444444444444444/444444444444444444444444444444␤»

[01:03] <pugs_svn> r28487 | diakopter++ | [vijs/sprixel] make Rats reduce upon instantiation 

[01:03] <diakopter> vijs: say 777777777777777777777777777777/444444444444444444444444444444 - 333333333333333333333333333333/444444444444444444444444444444; # for [particle]

[01:03] <p6eval> vijs 28485: OUTPUT«1/1␤»

[01:04] <diakopter> heh

[01:04] *** japhb left
[01:05] <diakopter> vijs: say 3333/4444

[01:05] <p6eval> vijs 28485: OUTPUT«3/4␤»

[01:07] *** stephenlb left
[01:08] <colomon> diakopter++

[01:09] <colomon> pmichaud: ping?

[01:13] *** TiMBuS joined
[01:18] <crythias> sprixel: Sixth Perl Revision Is Xquisitely Enticing. LOL

[01:19] <diakopter> ++crythias

[01:23] *** SmokeMachine left
[01:33] *** japhb joined
[01:42] *** rhr joined
[01:47] <pugs_svn> r28488 | diakopter++ | [vijs/sprixel] implement "constant folding" for divisions of (only) two literal integers, coercing it to a Rat. 

[01:47] <diakopter> also fixed a bug in libBigInt.js.

[01:47] <diakopter> (not my bug, even!)

[01:47] <diakopter> java transliteration error.

[01:48] <diakopter> vijs: say say -3 / 4

[01:48] <p6eval> vijs 28487: OUTPUT«-3/4␤1␤»

[01:49] <diakopter> vijs: say 6 / 9

[01:49] <p6eval> vijs 28487: OUTPUT«2/3␤»

[01:55] *** rhr_ left
[02:02] *** meppl left
[02:07] *** zaphar_ps joined
[02:13] <pugs_svn> r28489 | diakopter++ | [vijs/sprixel] implement Rat.toString() as decimal stringification (in Rat.toNum()) 

[02:13] <diakopter> vijs: say -6 / 9

[02:13] <p6eval> vijs 28487: OUTPUT«-0.6666666666666666␤»

[02:13] <diakopter> whee

[02:14] <diakopter> vijs: say 5589162039876590823/38392635986432

[02:14] <p6eval> vijs 28487: OUTPUT«145579.12648462242␤»

[02:14] <diakopter> vijs: say 5589162039876590823552352332/38392635986432

[02:14] <p6eval> vijs 28487: OUTPUT«145579012648462.25␤»

[02:15] <diakopter> hmmmmm

[02:16] <diakopter> looks like it lost a leading zero there in the decimal part of the 2nd-to-last quotient

[02:17] *** rfordinal joined
[02:17] <diakopter> vijs: say 1/50

[02:17] <p6eval> vijs 28487: OUTPUT«0.2␤»

[02:17] <diakopter> yep

[02:18] <colomon> rakudo: say -6 / 9;

[02:18] <p6eval> rakudo 0331d6: OUTPUT«-0.666666666666667␤»

[02:19] <diakopter> so JS has a couple more precision

[02:19] <diakopter> but didn't round

[02:19] <diakopter> up

[02:19] *** rhr left
[02:20] * colomon is jealous of vijs's bignums.

[02:20] <diakopter> well

[02:20] <diakopter> don't be too jealous

[02:20] *** payload left
[02:21] <diakopter> since it's not stringifying correctly yet

[02:22] <diakopter> vijs: say ((1/50) * 50)

[02:22] <p6eval> vijs 28489: OUTPUT«execute(): execute error: Rat Multiplicative not yet implemented; srsly!??!?! at vijs line 85.␤»

[02:23] <diakopter> vijs: say (9/100 + 1/100)

[02:23] <p6eval> vijs 28489: OUTPUT«0.1␤»

[02:23] *** rhr joined
[02:23] <colomon> diakopter: speaking as someone who works with numbers all the time, I don't care about a number being off by 0.0000000000000001.

[02:24] <diakopter> colomon: it's not

[02:24] <diakopter> it's off by as much as 0.9

[02:24] <colomon> oh, it's the missing leading 0 in the decimal place?  I thought you'd already fixed that.  :)

[02:25] <diakopter> no; I'm blanking on how to stringify a quotient's remainder into decimal... having never done it before. :)

[02:25] <diakopter> my trick was to multiply it by 1e31 then divide by the divisor

[02:25] <colomon> ooooo

[02:25] <diakopter> but obviously that doesn't work

[02:26] <diakopter> that gets all the sigdigs except the leading zeroes. :)

[02:26] <diakopter> actually

[02:26] <diakopter> it just needs to pad on the left up to the number of digits in the divisor times 1e31

[02:26] <colomon> that seems right

[02:27] <diakopter> hm

[02:29] <zpmorgan> vijs: say abs((4.9-5) / 0.4)'

[02:30] <p6eval> vijs 28489: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/jd4SQYnPWK line 1:␤------> [32msay abs((4.9-5) / 0.4)[33m⏏[31m'[0m␤    expecting any of:␤ POST␤   bracketed infix␤    infix stopper␤    postfix␤        postfix_prefix_meta_operator␤       standard stopper␤       statement

[02:30] <p6eval> ..modifier loop␤    terminator␤     whitespa…

[02:30] <zpmorgan> vijs: say abs((4.9-5) / 0.4)

[02:30] <p6eval> vijs 28489: OUTPUT«Undef␤»

[02:30] <diakopter> it doesn't know about abs

[02:30] <zpmorgan> ok

[02:30] <diakopter> it's not currently throwing on missing subroutine, too :)

[02:31] <zpmorgan> do you know why perl5 would give 0.249999999999999 instead of .25?

[02:31] *** rhr left
[02:31] <colomon> that's the magic of floating point math

[02:31] <diakopter> yeah; b/c of the way floats/doubles are stored...

[02:32] <diakopter> vijs: say (4.9-5) / 0.4

[02:32] <p6eval> vijs 28489: OUTPUT«-0.2499999999999991␤»

[02:32] <diakopter> see? :)

[02:32] <diakopter> even wrongisher

[02:32] <zpmorgan> i've heard that 1/10 can't be represented in floatimg point

[02:33] <zpmorgan> somehow, perl does it correctly

[02:33] <colomon> rakudo: say (49/10 - 5) / (2 / 5);

[02:33] <p6eval> rakudo 0331d6: OUTPUT«-0.25␤»

[02:33] * diakopter afk

[02:33] *** rhr joined
[02:34] <zpmorgan> vijs: say (4.9-5) / (2/5)

[02:34] <p6eval> vijs 28489: OUTPUT«-0.2499999999999991␤»

[02:34] <diakopter> vijs: say (4.9-5)/(2/5)

[02:34] <p6eval> vijs 28489: OUTPUT«-0.2499999999999991␤»

[02:36] <diakopter> vijs: say (9.8/2-5/1)/(2/5)

[02:36] <p6eval> vijs 28489: OUTPUT«-0.2499999999999991␤»

[02:36] *** rfordinal left
[02:36] <diakopter> vijs: say (98/20-5/1)/(2/5)

[02:36] <p6eval> vijs 28489: OUTPUT«execute(): execute error: Rat Multiplicative not yet implemented; srsly!??!?! at vijs line 85.␤»

[02:37] *** justatheory left
[02:38] *** __ash__ left
[02:41] *** hercynium left
[02:49] *** __ash__ joined
[02:50] <diakopter> vijs: say (98/20-5/1) / (2/5)

[02:50] <p6eval> vijs 28489: OUTPUT«execute(): execute error: Rat Multiplicative not yet implemented; srsly!??!?! at vijs line 85.␤»

[02:54] *** zerhash left
[02:59] *** molaf joined
[03:01] *** zerhash joined
[03:03] <Tene> Yay, I'm getting github failures!  Pages refusing to load with "502 Bad Gateway -- nginx" messages.

[03:12] *** payload joined
[03:22] *** __ash__ left
[03:36] <carlin> On OpenSolaris, S03-operators/arith test 163 fails because 1**Inf = NaN, on Ubuntu 1**Inf = 1

[03:36] *** crythias1 joined
[03:46] *** jauaor joined
[03:54] *** crythias left
[03:59] *** Student left
[04:00] *** Student joined
[04:00] *** tak11 left
[04:07] *** crythias1 left
[04:11] *** envi^office joined
[04:14] <carlin> rakudo: say $*OSVER; say $*EXECUTABLE_NAME;

[04:14] <p6eval> rakudo 0331d6: OUTPUT«#1 SMP Sun Feb 24 18:08:45 EST 2008␤../p/bin/perl6␤»

[04:15] *** justatheory joined
[04:17] *** eternaleye left
[04:33] <carlin> What would it take to get $*OSVER to work on OpenSolaris? (its currently defined but blank)

[04:35] *** justatheory left
[04:45] *** reqamst left
[04:45] *** reqamst joined
[04:48] <mberends> carlin: needs a parrot solution, not fulfilling 'sysinfo .SYSINFO_PARROT_OS_VERSION' (rakudo/src/builtins/globals.pir:32)

[04:51] *** Woodi joined
[05:05] *** Student left
[05:27] *** mberends left
[05:31] *** synth^3 left
[05:32] *** Woodi left
[05:34] *** rfordinal joined
[05:42] *** Confield left
[06:08] *** NorwayGeek|Away left
[06:20] *** rfordinal left
[06:21] *** rfordinal joined
[06:22] *** zev left
[06:24] *** zev joined
[06:27] *** ihrd joined
[06:34] *** mberends joined
[06:35] *** NorwayGeek joined
[06:40] <mberends> moritz_: ready to commit rename vijs -> sprixel at the request of diakopter++, will do it when you're here to manage the evalbot end

[06:40] *** rfordinal left
[06:42] <moritz_> mberends: go right ahead

[06:45] <pugs_svn> r28490 | mberends++ | [sprixel] new name replacing vijs, see http://sprixel.blogspot.com 

[06:47] <mberends> moritz_, diakopter asked if you could give sprixel prefix s: in evalbot

[06:48] <mberends> :) 'sprixel' is an anagram of 'perlsix'

[06:49] <moritz_> so what's the new incantation to start sprixel?

[06:50] <mberends> perl sprixel.pl -e '...'

[06:52] *** ihrd left
[06:52] *** flip214 joined
[06:52] <mberends> 'make -f sprixel.mk test' passes two tests in t/01-sanity/04-if.t without fudging :)

[06:52] <diakopter> yay

[06:52] <flip214> Help, please?

[06:52] <diakopter> my local passes the first 34 tests of num.t

[06:52] <mberends> hiya diakopter 

[06:52] <flip214> rakudo: our $c=0; class T { has $.me=$c++; has T $.left; has T $.right;  }; my T $t .= new;

[06:52] <pugs_svn> r28491 | moritz++ | [src/perl6] adapt 'make snap' to new name 

[06:53] <mberends> \o/

[06:53] <p6eval> rakudo 0331d6: OUTPUT«Null PMC access in find_method()␤in Main (/tmp/jHMTiFuXGa:2)␤»

[06:53] *** lmc left
[06:53] <flip214> I'd think that's more or less directly from S12.

[06:53] <moritz_> flip214: yes, "Null PMC access" is alwasy a bug

[06:53] <flip214> Is $t still undef, so that .new can't be called?

[06:53] <diakopter> null pointer exception

[06:53] <diakopter> null reference exception

[06:54] <flip214> So? my error, or when will that be fixed?

[06:54] <flip214> ;-)

[06:54] <diakopter> NEVER NEVER NEVER

[06:54] <diakopter> :>

[06:54] <diakopter> kidding.  sorry.

[06:54] <flip214> np

[06:54] <flip214> I'm used to that

[06:54] <moritz_> diakopter: are you sure that 's:' as the prefix for sprixel is a good idea?

[06:55] <moritz_> diakopter: people will ask 'what's "s"' all the time

[06:55] <diakopter> moritz_: no, but I'd like to try it, and r: for rakudo and p: for pugs and e: for elf and m: for mildew

[06:55] <mberends> can we have a long and a short alias?

[06:56] <moritz_> not yet

[06:56] <mberends> later today?

[06:56] <mberends> ;)

[06:56] <moritz_> and I'm not sure if I get to it today, but evalbot.pl is in the repo after all, so you can patch it yourself

[06:56] <diakopter> moritz_, mberends: oh, it's morning to you two

[06:56] <diakopter> so g'morning

[06:57] <moritz_> :-)

[06:57] <mberends> "patches welcome" [tm]moritz_

[06:57] <pugs_svn> r28492 | moritz++ | [evalbot] s/vijs/sprixel/ 

[06:58] <mberends> sprixel: say "alive and kickin'"

[06:58] <diakopter> at least I didn't go with splerix or splixer or sexripl

[06:59] *** barney joined
[06:59] <mberends> thank goodness for that

[06:59] <diakopter> crythias came up with sprixel

[07:01] <diakopter> ++num.t

[07:01] <flip214> What should I do about my "Null PMC access"?

[07:02] <flip214> rakudo: our $c=0; class T { has $.me; }; my T $t=T.new

[07:02] <flip214> this works

[07:02] <p6eval> rakudo 0331d6:  ( no output )

[07:02] <flip214> this doesn't

[07:02] <flip214> rakudo: our $c=0; class T { has $.me=$c++; }; my T $t=T.new

[07:02] <p6eval> rakudo 0331d6: OUTPUT«Null PMC access in find_method()␤in Main (/tmp/9VV78Lrwsz:2)␤»

[07:02] <diakopter> evalbot control restart

[07:02] *** p6eval left
[07:02] *** p6eval joined
[07:02] <flip214> rakudo: our $c=0; class T { has $.me=$c++; }; my T $t=T.new

[07:02] <p6eval> rakudo 0331d6: OUTPUT«Null PMC access in find_method()␤in Main (/tmp/MX0Cn4ima5:2)␤»

[07:02] <diakopter> perl6: say 4,3,2,1

[07:03] <p6eval> vijs:  ( no output )

[07:03] <p6eval> ..elf 28492, pugs, rakudo 0331d6: OUTPUT«4321␤»

[07:03] <flip214> The only difference is the initialization to the global counter variable

[07:03] <flip214> With =0 it's ok

[07:03] <diakopter> moritz_: you missed one... (yesterday I added it to perl6:

[07:03] <diakopter> )

[07:05] <mberends> nothing shy about our diakopter ;)

[07:06] <mikehh> rakudo (0331d60) builds on parrot r41546 - make test / make spectest_smolder (up to r28490 -> #28284) PASS - Ubuntu 9.04 amd64

[07:07] <carlin> I couldn't get rakudo to build with gcc in Solaris, it worked with Sun CC and it worked with gcc a few weeks ago. Problem is that --optimize is now default

[07:07] <moritz_> diakopter: go ahead then

[07:07] *** mariuz joined
[07:07] <moritz_> carlin: then build parrt yourself, without --optimize

[07:07] <moritz_> carlin: and please open a parrot bug for not building on your platform with --optimize

[07:08] <TimToady> rakudo: our $c = 0; class T { has $.me = GLOBAL::<$c>++; }; my T $t .= new;

[07:08] <p6eval> rakudo 0331d6: OUTPUT«Null PMC access in getprop()␤»

[07:09] <moritz_> rakudo doesn't do GLOBAL or PROCESS yet

[07:09] <TimToady> rakudo: module X { our $c = 0; class T { has $.me = $X::c++; }; my T $t .= new;

[07:09] <p6eval> rakudo 0331d6: OUTPUT«Unable to parse block; couldn't find final '}' at line 2, near ""␤in Main (src/gen_setting.pm:3469)␤»

[07:09] <carlin> moritz_: that's what I did (to find that --optimize was the problem), I'll open a parrot ticket now

[07:09] <TimToady> rakudo: module X { our $c = 0; class T { has $.me = X::<$c>++; }; my T $t .= new;

[07:09] <p6eval> rakudo 0331d6: OUTPUT«Unable to parse block; couldn't find final '}' at line 2, near ""␤in Main (src/gen_setting.pm:3469)␤»

[07:10] <diakopter> evalbot control restart

[07:10] *** p6eval left
[07:10] <pugs_svn> r28493 | diakopter++ | [evalbot] one last rename of vijs to sprixel 

[07:10] *** p6eval joined
[07:10] <TimToady> flip214: rakudo doesn't see lexicals outside of classes yet

[07:10] <flip214> But AFAIK it should, right?

[07:10] <TimToady> and class T is a different package

[07:11] <TimToady> yes, it should

[07:11] <flip214> So it's just a matter of time.

[07:11] <flip214> Thanks a lot.

[07:11] <flip214> Does state already work?

[07:11] <moritz_> s/time/effort/

[07:11] <moritz_> flip214: yes

[07:11] <carlin> Would it be possible to have rakudo not --optimize on certain platforms or would it not be worth worrying about?

[07:11] <diakopter> perl6: say 4,3,2,1

[07:11] <p6eval> elf 28493, pugs, rakudo 0331d6, sprixel 28492: OUTPUT«4321␤»

[07:11] <mberends> \o/

[07:12] <flip214> thanks:

[07:12] <flip214> rakudo:  class T { state $c=0; has $.me=$c++; method P { say $.me }; }; my T $t .= new; $t.P

[07:12] <moritz_> carlin: that really depends on how hard it is for the parrot folks to fix it

[07:12] <diakopter> elf is one revision ahead of sprixel

[07:12] <p6eval> rakudo 0331d6: OUTPUT«0␤»

[07:12] *** rfordinal joined
[07:13] <moritz_> diakopter: the STD build, actually

[07:13] <diakopter> ah, oh

[07:13] <diakopter> makes sense

[07:26] *** iblechbot joined
[07:29] *** Woodi joined
[07:30] <flip214> Does "role Each" already work? I'd like to test the hyper-operator.

[07:35] <Matt-W> Morning

[07:38] <moritz_> flip214: I don't think so. Hyper operators work on infixes though

[07:41] *** ejs joined
[07:50] *** ejs1 joined
[07:57] *** ejs left
[08:02] <pugs_svn> r28494 | lwall++ | [STD] 

[08:02] <pugs_svn> r28494 | package name refactor; stashes now know their own unique id name

[08:02] <pugs_svn> r28494 | conflicting package symbols now report which package they conflict in

[08:02] <pugs_svn> r28494 | (lexicals are always assumed to conflict in the current scope)

[08:10] *** masak joined
[08:10] <masak> ahoj, #perl6!

[08:11] <moritz_> \o/

[08:20] *** ihrd joined
[08:20] *** ihrd left
[08:21] <Matt-W> yo masak

[08:33] <mberends> masak: hi, sorry about not working on proto lately, sprixel is a much nicer toy at the moment ;)

[08:36] * Matt-W totally failed to successfully move any operators into the setting last night

[08:37] *** NorwayGeek left
[08:37] <moritz_> Matt-W: which one(s) did you try?

[08:38] <Matt-W> infix:<xx>, which has signature problems

[08:39] <Matt-W> infix:<~>, which looked entirely plausible but I ran into a null PMC access, threw my hands in the air and went to play with the cat instead

[08:39] *** NorwayGeek joined
[08:40] <Matt-W> So that one may well be possible, but I gave up

[08:43] *** Lorn joined
[08:49] *** Lorn_ left
[08:55] * masak de-meetings

[08:55] <masak> mberends: hi, no worries.

[08:55] <masak> mberends: (what's sprixel?)

[08:55] <moritz_> vijs' new name

[08:55] <masak> Matt-W: oh, you didn't try infix:<< < >> and infix:<< > >> ?

[08:55] <masak> moritz_: ah, cool.

[08:57] <Matt-W> masak: no, sorry

[08:57] <masak> then maybe I'll try today.

[09:01] <colomon> Matt-W: I failed to move prefix:<+> into the setting last night as well....

[09:17] *** PerlJam left
[09:18] <Matt-W> :(

[09:18] <Matt-W> I think all the really easy ones are done

[09:18] <masak> .oO( high-hanging fruit )

[09:18] *** NorwayGeek left
[09:18] *** PerlJam joined
[09:23] <carlin> what would cause 1**Inf to return different values on different platforms?

[09:23] *** NorwayGeek joined
[09:25] <moritz_> colomon: I just pushed the branch native-complex to github...

[09:25] <colomon> moritz_: woah

[09:25] <moritz_> colomon: the idea is to implement the Complex class fully in Perl 6, and use the parrot Complex class through delegation

[09:25] <moritz_> colomon: currently there's just one commit in it, which rips out the old thing and adds a constructor , $.re and $.im to Complex

[09:25] <colomon> Will "git pull" pull it, or do I need to do something special?

[09:26] <moritz_> git pull

[09:26] <colomon> and then switch to the branch to use it, I presume.

[09:26] <moritz_> yes

[09:26] <moritz_> git checkout --track origin/native-complex

[09:26] <moritz_> git checkout -b native-complex

[09:27] <moritz_> I'm sure there's an easier invocation which does these two things in one...

[09:28] <colomon> I'm presuming this breaks lots of spectests at the moment?

[09:28] <moritz_> it does

[09:28] <moritz_> I haven't even bothered running them :-)

[09:29] <colomon> :)

[09:29] <moritz_> but since the parser doesn't emit proper Complex.new it's obvious that everything breaks

[09:30] <colomon> When I try "git checkout --track origin/native-complex", I get "git checkout: --track and --no-track require -b"

[09:30] *** pdcawley joined
[09:31] <colomon> Pro Git makes it look like "git checkout -b native-complex origin/native-complex" might do it?  But I don't see a mention of --track at all.

[09:31] <moritz_> colomon: I think --track is on by default in newer gits 

[09:32] <moritz_> colomon: but it doesn't hurt to use it anyway :-)

[09:33] <colomon> "git checkout -b native-complex origin/native-complex" replies

[09:33] <colomon> Branch native-complex set up to track remote branch refs/remotes/origin/native-complex.

[09:33] <colomon> Switched to a new branch "native-complex"

[09:33] <moritz_> then all is well

[09:33] <colomon> \o/

[09:33] <moritz_> since Makefile.in has changed, you need to run Configure.pl again

[09:35] <colomon> Answering my questions before I can even ask them, moritz_++

[09:36] <colomon> building now, I should probably go back to bed...

[09:36] *** huf_ joined
[09:39] *** clintongormley joined
[09:40] <masak> Woodi: oh hai, I read in the backlog that you 'hate proto'. we need more people like you! :) could you elaborate on what exactly it was you hated (something about 'already installed')? then maybe I can make the experience less hateful for the next customer.

[09:42] *** payload left
[09:44] *** huf left
[09:45] <masak> rakudo: our $c; class T { $c++ }; T.new

[09:45] <p6eval> rakudo 0331d6: OUTPUT«Null PMC access in find_method()␤»

[09:45] * masak submits rakudobug

[09:57] <Matt-W> another day, masak found another forty bugs

[09:57] <Matt-W> nice to know the world keeps turning even when my brain's melting

[09:57] <masak> this one was courtesy of flip214, actually.

[09:58] <masak> but he doesn't seem to have processed it, so I did.

[09:58] <Matt-W> naughty flip214

[09:58] *** meppl joined
[09:58] <masak> hugme: hug flip214 

[09:58] * hugme hugs flip214

[09:58] <Matt-W> although finding it is good

[10:00] <masak> actually, I suspect it's part of a larger, known set of issues.

[10:04] *** ruoso left
[10:06] <Matt-W> I never want to write a network app ever again

[10:06] <Matt-W> Just too much pain

[10:06] * carlin is having fun with cross-platform weirdness

[10:08] <Matt-W> I'd like the ability to time out a TCP send if it doesn't complete within a given period

[10:08] <Matt-W> Unfortunately Solaris doesn't support the socket flags for that

[10:08] <Matt-W> This is why I'd rather be writing Perl 6 stuff

[10:11] *** huf_ is now known as huf

[10:12] *** NorwayGeek left
[10:16] *** am0c left
[10:17] *** hanekomu joined
[10:18] *** pmichaud left
[10:20] *** pmichaud joined
[10:24] *** dakkar joined
[10:33] * colomon is back

[10:35] *** arthur-_ left
[10:48] *** arthur-_ joined
[11:06] <colomon> are there Complex arith tests somewhere in t/spec?

[11:06] <flip214> masak: while you're reporting bugs, here's another

[11:06] <flip214> working:

[11:06] <flip214> rakudo: class Int is also { multi method f(Int $self: Int $arg) { return $self-$arg;}; multi method infix:<+>(Int $self: Complex $arg) { return 0; } }; say 5.f(2)

[11:07] <p6eval> rakudo 0331d6: OUTPUT«3␤»

[11:07] <flip214> rakudo: class Int is also { multi method f(Int $self: Int $arg) { return $self-$arg;}; multi method infix:<+>(Int $self: Complex $arg) { return 0; } }; say 5.&infix:<+>(2)

[11:07] <p6eval> rakudo 0331d6: OUTPUT«Parameter type check failed; expected Complex, but got Int for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:876)␤called from Main (/tmp/BtSPjqelO3:0)␤»

[11:07] <flip214> For a plain method name that works ... using operators doesn't.

[11:08] <flip214> what gender is hugme?

[11:11] *** iblechbot left
[11:14] <moritz_> it's botgender

[11:15] <moritz_> flip214: you won't ever be able to declare infix methods

[11:15] <moritz_> infixes are looked up as subs, not as methods.

[11:20] <mikehh> rakudo (0331d60) builds on parrot r41551 - make test / make spectest_smolder (up to r28494 -> #28300) PASS - Ubuntu 9.04 amd64

[11:20] *** redicaps joined
[11:24] *** am0c joined
[11:29] * masak submits flip214's rakudobug

[11:32] <colomon> moritz_: the bot that announces commits to rakudo doesn't announce those to branches?

[11:34] <TiMBuS> can rakudo take multi-type function sigs? eg. foo(Int|Str $a){...}

[11:35] * Juerd notices that planet.perl6.org works now. Thanks, whoever made this work. (I forgot.)

[11:39] <masak> TiMBuS: no, I don't think so.

[11:41] <TiMBuS> yeah, i tried but the error wasnt telling me if i was doing something wrong or not

[11:41] *** kst` joined
[11:41] *** tylerni7 left
[11:41] *** dukeleto left
[11:41] *** simcop2387 left
[11:41] *** buubot left
[11:41] *** BooK left
[11:41] *** moritz_ left
[11:41] *** Grrrr left
[11:41] *** pjcj left
[11:41] *** mdxi left
[11:41] *** arnsholt left
[11:41] *** hcchien left
[11:41] *** mspauldi1g left
[11:41] *** Rint left
[11:41] *** sjohnson left
[11:41] *** avar left
[11:41] *** kst left
[11:41] *** allbery_b left
[11:41] *** Intensity left
[11:41] *** KatrinaTheLamia left
[11:43] *** simcop2387 joined
[11:43] *** moritz_ joined
[11:43] *** BooK joined
[11:44] *** mspaulding joined
[11:44] *** pjcj joined
[11:45] *** ejs2 joined
[11:45] <masak> rakudo: sub foo(Int|Str $) {}

[11:45] <p6eval> rakudo 0331d6: OUTPUT«Unable to parse multisig; couldn't find final ')' at line 2, near "|Str $) {}"␤in Main (src/gen_setting.pm:3469)␤»

[11:45] <wolverian> do feed operators not work with scalars at all?

[11:45] <masak> TiMBuS: it's telling you that it can't parse the '|'

[11:45] <moritz_> rakudo: say 1 ==>> 2

[11:46] <p6eval> rakudo 0331d6: OUTPUT«Feed operators are not yet implemented in Rakudo, sorry␤in sub infix:==>> (src/gen_setting.pm:1668)␤called from Main (/tmp/gz6vOFa9g7:0)␤»

[11:46] <TiMBuS> fair enough, masak

[11:46] <moritz_> Juerd: Daniel Wright made us a catch-all subdomain for perl6.org, and I did the redirect

[11:46] <TiMBuS> that makes sense actually.

[11:46] <moritz_> if anybody else wants to perl6.org subdomains, talk to me.

[11:47] <Juerd> moritz_: Thanks :)

[11:47] <pugs_svn> r28495 | colomon++ | [t/spec] Test that the two ways of making a Rat actually do make a Rat. 

[11:47] <TiMBuS> i do! not that id have anything perl6-ish to contribute but man it would be cool to have one

[11:48] <Juerd> perl6.nl subdomains are available too. Even free-er! :D

[11:48] <TiMBuS> depending on how you define 'cool'

[11:48] <Juerd> And much dutchier

[11:48] <moritz_> :-)

[11:49] * moritz_ can also offer subdomains of perl-6.de and rakudo.de

[11:49] <masak> flip214: oh wait. your bug is odd, because the .f method takes an Int, whereas the infix:<+> method takes a Complex.

[11:49] <masak> flip214: so it's kinda apples and oranges.

[11:50] <Juerd> Ooh, I almost forgot I also have rakudo.nl :D

[11:50] <carlin> On OpenSolaris, my rakudo compiled with gcc thinks log(-Inf) = -Inf, my rakudo compiled with SunStudio CC thinks log(-Inf) = NaN

[11:50] <TiMBuS> rakudo: class Int is also { multi method f(Int $self: Int $arg) { return $self-$arg;}; multi method infix:<+>(Int $self: Int $arg) { return 0; } }; say 5.&infix:<+>(3);

[11:50] <p6eval> rakudo 0331d6: OUTPUT«Parameter type check failed; expected Complex, but got Int for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:876)␤called from Main (/tmp/SiFN4iqq4G:0)␤»

[11:50] <TiMBuS> errr

[11:50] <flip214> masak: yeah, but try it with an Int - doesn't work either

[11:51] <flip214> rakudo: class Int is also { multi method f(Int $self: Int $arg) { return $self-$arg-1;}; multi method infix:<+>(Int $self: Int $arg) { return 0; } }; say 5.&infix:<+>(2)

[11:51] <masak> now, that's a bug.

[11:51] <p6eval> rakudo 0331d6: OUTPUT«Parameter type check failed; expected Complex, but got Int for $a in call to infix:+␤in sub infix:+ (src/gen_setting.pm:876)␤called from Main (/tmp/H9mrDeSBVN:0)␤»

[11:51] <flip214> Well? What did I say?

[11:51] <flip214> Listen to me, man...

[11:51] * masak submits rakudobug

[11:51] <masak> flip214: sure, but write it right the first time. :)

[11:51] <moritz_> flip214: I'll repeat it one last time: defining an infix operator as a method makes no sense at all.

[11:51] <TiMBuS> also, where is $a

[11:51] <masak> moritz_: but if you do, shouldn't you be able to call it?

[11:52] <flip214> moritz_: so if I do that some more, you won't complain?

[11:52] <TiMBuS> i guess its from the 'real' infix:<+>

[11:52] <moritz_> flip214: no, I'll just ignore you

[11:52] <moritz_> masak: no idea

[11:52] *** NorwayGeek joined
[11:52] <flip214> So, for me it's indistinguishable ... I won't hear from you ;-)

[11:52] * masak doesn't know whether to submit the bug anymore

[11:53] <moritz_> masak: it boils down to the question whether you can attache attributes to a method as part of the long name

[11:54] <flip214> moritz: how would I define operators on my classes? I'd thought that's the way to go.

[11:54] *** Grrrr joined
[11:54] <flip214> I guess I'll be off to S13

[11:54] <masak> moritz_: I don't understand.

[11:55] *** ejs1 left
[11:55] <masak> moritz_: 'attributes' as in Perl 6 OO attributes?

[11:55] <masak> or in some other sense?

[11:56] <moritz_> in some other sense, I assume

[11:56] <flip214> I think that's about the signature of the function/method

[11:56] <moritz_> just like :auth and :version are some kind of attributes

[11:56] <moritz_> which are part of the long name

[11:56] <flip214> "Does the signature of a function take place in the long name of a method" or something like that

[11:56] <masak> moritz_: I think you need another name for those than 'attribute'.

[11:57] <masak> today, t/spec/integration/99problems-21-to-30.rakudo failed in the spectest harness. when run standalone, it passes.

[11:57] <masak> it prints what looks like debug information before test 10.

[11:57] *** christine left
[11:58] <moritz_> masak: and I think we need more specs for that too (hilighting TimToady here :), just like for the :sym<...> part of proto regexes. I think too much of that is either implied by other parts of the spec, or just in some people's head

[11:58] *** KatrinaTheLamia joined
[11:58] <masak> moritz_: oh, I agree fully.

[11:58] <masak> call it 'epigenetic specification' :)

[11:59] * masak is a bioinformatician

[11:59] *** christine joined
[12:00] *** allbery_b joined
[12:02] *** buubot joined
[12:03] <moritz_> pmichaud, jnthn: we'd need some help from one of you in the native-complex branch: 3.5i should emit a call to Complex.new(0, 3.5) - that would greatly help us to actually test what we're doing right now :-)

[12:04] *** rblasch joined
[12:04] <moritz_> currently I can't even find where that case is handled

[12:06] <flip214> Is there a complex Rat, too?

[12:06] <flip214> Or a ratty Complex.

[12:06] * masak guesses 'no'

[12:07] <masak> just like there's not an integral Complex

[12:07] <flip214> What's that?

[12:07] <masak> they're called 'gaussian integers', I believe.

[12:07] <masak> it's (m + ni) where m and n are integers.

[12:08] <masak> they're interesting; they have their own definition of primality, for example.

[12:08] <flip214> oh, ok

[12:08] <colomon> Actually, the current "new" implementation of Complex on the branch allows for any sort of numeric component to be the real and imaginary parts of a Complex.

[12:08] <masak> oh?

[12:08] <masak> it's a parameterized role?

[12:08] <colomon> All my tests so far have involved complexes made of two Ints.

[12:08] <moritz_> no

[12:08] <colomon> No, it's just Any.

[12:08] <moritz_> it's just untyped

[12:09] <flip214> back to the question: masak | it's a parameterized role?   

[12:09] <masak> it could as well be Num, because Num covers Int and Rat.

[12:09] <Juerd> masak: I'm reading your Squerl journal post. How do you decide between $foo.bar: ...; and $foo.bar(...);?

[12:09] <masak> Juerd: usually I'm very much in favor of the latter.

[12:10] <flip214> and if it is, does it make sense to give two different types for .re and .im?

[12:10] <colomon> Num doesn't cover Int and Rat right now, they are all distinct types.

[12:10] <masak> Juerd: in this case, it was an urge to make it look more like the Ruby code I was copying that made me use :

[12:10] *** ejs2 left
[12:11] <Juerd> masak: Oh. I was hoping for some nice chunk of wisdom :)

[12:11] <colomon> moritz_: Just to avoid duplication of effort, I should point out I've already checked in some stuff for Complex on the branch.

[12:11] *** ruoso joined
[12:11] <masak> Juerd: that would be 'avoid the invocant colon as much as possible' :)

[12:11] <moritz_> colomon: yes, I've seen that

[12:11] <moritz_> colomon: thanks

[12:12] <masak> um, in invocations. it's fine in declarations, of course.

[12:12] <TiMBuS> feature request: Match objects can be smartmatched against regexes

[12:12] <colomon> I was starting up a separate test file for it -- I haven't spotted anywhere in the spectests that actually test basic complex arithmetic.  

[12:12] <Juerd> masak: I dunno. $fh.print: LIST; does still sound really convincing.

[12:12] <colomon> (But I wasn't looking that hard -- I was doing everything while holding a sleeping child, limiting my typing speed significantly.)

[12:13] <masak> Juerd: you have a point there.

[12:13] *** awwaiid joined
[12:13] *** ejs2 joined
[12:13] <Juerd> masak: But I don't know why I do like $fh.print: ...; while at the same time I dislike Class.new: ...;

[12:14] <Juerd> masak: Maybe it's just a perl5ism, that print thing.

[12:14] <masak> Juerd: it's a bit like some of the practices in PBP, where the Bad Thing isn't so much the syntaxtic feature itself, but the syntactic feature in combination with a lot of other things which make the situation more complex.

[12:14] <moritz_> colomon: oh, I think you're right, there's a significant lack of those tests

[12:14] <masak> Juerd: so, using 'unless' becomes bad when the thing being tested becomes a complicated expression...

[12:15] <colomon> moritz_: They're easy enough to add, of course.  My theory was to grab rat.t, then go through it and make complex versions of the tests for starters, just to have a framework.

[12:15] <Juerd> Especially *when* the thing being tested becomes complicated, I tend to start using "unless".

[12:15] <masak> Juerd: in the same way, I've been bitten by the invocant colon when I'd made further calls in the list of arguments. then the parentheses are really useful, and not having them leads to easy logic bugs.

[12:16] <Juerd> And for the simple cases, I use "if not $foo"

[12:16] <Juerd> Never "unless $foo"

[12:16] <colomon> moritz_: but now my theory is it's a good time to walk the dog, so it may be a while before I actually accomplish anything along those lines.  :)

[12:16] <masak> Juerd: I think I use 'if !' almost 100% nowadays.

[12:16] <masak> but de gustibus.

[12:17] <Juerd> I avoid !.

[12:17] <Juerd> ! is too narrow and tiny for something that has such a huge impact.

[12:17] <Juerd> Especially when used right next to a $

[12:17] <masak> use three of them :P

[12:17] <Juerd> Heh.

[12:17] <Juerd> Then "not" is prettier than "!!!" :)

[12:17] <moritz_> colomon: sure, don't hurry

[12:17] <Juerd> Besides that, !!! already means something in P6 :)

[12:17] <masak> aye, I realized that.

[12:18] <masak> you'd have to write ! ! !

[12:18] <flip214> I'm using "if", "unless", "if !" depending on what I'd expect them to do the most time over ...

[12:18] <moritz_> colomon: that branch was mostly meant to get us started, not as something that has to land soon

[12:18] <masak> I think I use 'unless' sometimes in conjunction with 'next' and 'last'...

[12:18] *** payload joined
[12:18] <flip214> so "die if ! $object", "print unless $found{$_}++", and so on

[12:18] <flip214> so that it's reads easily (for me)

[12:19] *** Lorn_ joined
[12:19] <moritz_> next unless /\d/

[12:19] <moritz_> ;

[12:19] <moritz_> or so

[12:20] <moritz_> is quite readable

[12:21] <cognominal>  rakudo: eval( 'sub A::t {  print @{$_[1]}, "\n"  }; bless {}, A', :lang<perl5> ).t( < j a p h > )

[12:21] <p6eval> rakudo 0331d6: OUTPUT«japh␤Scalars leaked: 1␤»

[12:25] <cognominal> rakudo: eval( 'sub A::t {  1..100  }; bless {}, A', :lang<perl5> ).t

[12:25] *** arthur-_ left
[12:25] <p6eval> rakudo 0331d6: OUTPUT«Scalars leaked: 100␤»

[12:27] <Woodi> masak: just found request for opinion on proto... so i had problems and impressions on what i expected (1. -MCPAN -e shell; 2. apt-get)

[12:27] <masak> Woodi: sure.

[12:28] <masak> not at all unreasonable.

[12:29] <masak> what I'm trying to take away from your feedback is whether what you experienced as a flaw is something we can fix or not.

[12:31] <Woodi> the biggest problem happen during install; eg. "./proto install web" after installing perl-sqlite failed becouse sqlite was installed (file exists). usully installation fails when dependencies are not installed :)

[12:31] <masak> oh!

[12:31] <masak> well, that certainly shouldn't happen.

[12:31] <masak> I'll see if I can reproduce that.

[12:32] <Woodi> and instaling perl6-examples failed becouse there was Test/Harnes.pm in place

[12:32] <masak> Woodi: and you're using the 'master' branch of proto, yes?

[12:33] <Woodi> at first then installed-modules

[12:33] <Woodi> but maybe not - maybe i created installed-modules with -b switch...

[12:33] <masak> uhm.

[12:34] <Woodi> i get git://.+ from github page

[12:34] <masak> oh well, I'll see if I can reproduce your bug reports with either branch.

[12:35] <Woodi> and if you include urls in project.list would be superb

[12:35] <masak> I doubt we'll do that.

[12:35] <Woodi> little tutorial would be nice

[12:36] <masak> so now's the time I say 'thanks for volunteering'? :)

[12:36] <moritz_> Woodi: my current, inofficial master plan is to create an external website that reads the projects.list, and assmebles informations and links about all these projects

[12:36] * masak writes down "Woodi will do a little proto tutorial"

[12:36] <Woodi> np man, i can torture you little more later :)

[12:37] <moritz_> but I'm very short on tuits, so it'll take some months to do that

[12:37] <masak> Woodi: looking forward to it. :) Woodi++

[12:37] <masak> moritz_: looks a bit like the yet-unnamed Cheese Speleology project.

[12:38] <masak> moritz_: I was going to call it Mozarella, but I realized it needs to be a cheese type with holes.

[12:38] <moritz_> :-)

[12:39] <Woodi> masak: and for dev project -v would be realy nice... later it can be as planned...

[12:39] * moritz_ tries to remeber if that geit oost had any holes in it.. probably not

[12:39] <Woodi> i mean: more verbousity

[12:40] <masak> Woodi: sure. I've tried to keep proto minimal so far, not adding bells and whistles. but I see what you mean.

[12:40] <Woodi> masak: problem is that technical ppls like messages ala linux booting :)

[12:40] <masak> Woodi: I personally like installers which don't blabber, like CPAN. but when something goes wrong, one definitely wants the output.

[12:41] <masak> Woodi: I didn't write proto for technical ppls.

[12:41] <masak> Woodi: I wrote it for people who dislike pain.

[12:41] <Woodi> do just debug mode :)

[12:41] <masak> patches welcome.

[12:41] <pmichaud> moritz_: until we're able to parse 3.5i as a complex constant, it'll have to be handled as (3.5)i

[12:41] <pmichaud> which shouldn't be a call to Complex.new

[12:42] <moritz_> pmichaud: so do I just need a method i in Num?

[12:43] *** rfordinal left
[12:43] <Woodi> is there way to croscompile rakudo for i386/i686 ?

[12:46] <pmichaud> well, that would be (3.5).i

[12:46] <pmichaud> (3.5)i  is postfix:<i>

[12:46] <pmichaud> (assuming there still is such a best)

[12:46] <pmichaud> *beast

[12:47] <pmichaud> over the weekend s1n created a patch for .i during our local hackathon.  I didn't get a chance to spectest it.

[12:47] <pmichaud> looking for the ticket.

[12:47] *** arthur-_ joined
[12:47] <pmichaud> RT #62382

[12:49] <lisppaste3> masak pasted "I've gotten this far in moving infix:<< < >> et al into the Setting" at http://paste.lisp.org/display/87887

[12:49] <masak> pmichaud: the spectests mostly pass, but I've lost the functionality of gen_junction and gen_whatever.

[12:50] <moritz_> pmichaud: uhm, that doesn't really help here

[12:50] <masak> I'm unsure how to add that back in the Setting, and looking for suggestions.

[12:50] <pmichaud> masak: gen_junction ought to be "automatic"

[12:50] <moritz_> in the method i it just multiplies with 1i

[12:50] <masak> pmichaud: it is.

[12:50] <pmichaud> moritz_: right

[12:50] <pmichaud> brb -- gotta take daughter to school

[12:50] <moritz_> but how and where is 1i transformed into $anything?

[12:51] <masak> pmichaud: the trouble is that I need to remove all non-Setting declarations of the ops just to avoid the Null PMC access I'm trying to fix in the first place.

[12:51] <masak> and that includes the ones in gen_junction and gen_whatever.

[12:51] <masak> moritz_: at parsetime?

[12:52] *** crythias joined
[12:52] <moritz_> masak: sure, somehow at parse time. But where and how?

[12:52] <masak> in actions.pm and by magic? :P

[12:53] <moritz_> oh, it really seems to be parsed as postfix:i already

[12:54] *** synth joined
[12:54] *** synth left
[12:56] *** redicaps left
[12:56] *** elmex left
[12:57] *** ejs1 joined
[12:57] *** elmex joined
[12:57] <masak> Tene: out of curiosity, what's the status of the manga-girl-with-Camelia-wings picture?

[12:59] *** orafu joined
[13:00] <pmichaud> back, briefly

[13:00] <pmichaud> yes, postfix:<i> is already implemented

[13:00] *** am0c left
[13:00] <moritz_> that's enough to get us started, thanks

[13:01] <moritz_> just pushed to the branch

[13:01] <moritz_> pmichaud++

[13:01] <pmichaud> but in particular, note that   ($a)i  isn't always the same as   Complex.new(0, $a)

[13:01] <pmichaud> unless the constructor knows how to deal with a complex $a :-)

[13:02] <moritz_> good point

[13:02] <moritz_> we should have tests for that :-)

[13:06] <flip214> What about (3+3i)i?

[13:06] <pmichaud> rakudo:  say (3+3i)i

[13:07] <p6eval> rakudo 0331d6: OUTPUT«-3+3i␤»

[13:07] <masak> rakudo++

[13:07] <flip214> rakudo: say ((((1+2i)i)i)i)i

[13:07] <p6eval> rakudo 0331d6: OUTPUT«1+2i␤»

[13:07] <flip214> rakudo: say ((1+2i)i)i)

[13:07] <p6eval> rakudo 0331d6: OUTPUT«Syntax error at line 2, near ")"␤in Main (src/gen_setting.pm:3469)␤»

[13:07] <flip214> rakudo: say ((1+2i)i)i

[13:07] <p6eval> rakudo 0331d6: OUTPUT«-1-2i␤»

[13:08] *** ejs2 left
[13:08] <flip214> So .i is more a "*Complex(0,1)" than a "Complex.new(0, $a)"

[13:08] <flip214> Fine

[13:09] *** ejs2 joined
[13:09] <dalek> rakudo: 9792a2e | moritz++ | :

[13:09] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[13:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9792a2e49e7e5cec9392e9b1c86208d935585835

[13:13] *** SmokeMachine joined
[13:15] *** crythias left
[13:18] *** ejs1 left
[13:19] <pmichaud> I'm okay if .i does something more direct than simply multiplying by 1i; it was just an easy solution at the time.

[13:20] <pmichaud> in some ways having the method rely on the operator is kinda backwards, I think.

[13:20] *** payload left
[13:21] <moritz_> isn't the method gone now?

[13:22] * moritz_ lost of track of what exists and what's gone

[13:22] <Woodi> flip214: look on Complex numbers like on numbers in coordinate system (x,y). x is real part and y is (i)maginary

[13:22] <moritz_> I'll re-read S03 later today,                      I think

[13:23] *** Lorn left
[13:23] *** Gothmog_ joined
[13:23] <Woodi> so (0,1) eq 0 + 1i and it is point in coordinate system

[13:24] <Woodi> + is just notation; i * i = -1

[13:24] <masak> rakudo: say i * i

[13:24] <p6eval> rakudo 0331d6: OUTPUT«src/call/context.c:1526: failed assertion 'Parrot_pcc_get_regs_used(interp, ctx, REGNO_PMC) > idx'␤Backtrace - Obtained 30 stack frames (max trace depth is 32).␤/home/p6eval//p1/lib/libparrot.so.1.6.0

[13:24] <p6eval> ..[0x2b6a505aedb3]␤/home/p6eval//p1/lib/libparrot.so.1.6.0(Parrot_confess+0x68) [0x…

[13:25] <masak> whoa.

[13:25] <masak> rakudo: say 1i * 1i

[13:25] <p6eval> rakudo 0331d6: OUTPUT«-1+0i␤»

[13:25] * masak submits rakudobug

[13:25] <moritz_> i * i should just call sub i(), and fail at that

[13:26] *** payload joined
[13:28] <moritz_> just 12 failing tests files in the native-complex branch :-)

[13:30] <Matt-W> yay

[13:30] <Matt-W> does that include every single file which uses complex numbers?

[13:30] *** __ash__ joined
[13:31] <moritz_> basically, yes :-)

[13:31] <Matt-W> :)

[13:31] <Matt-W> As long as it's not randomly breaking everything else, things arep proceeding within expected lines

[13:31] <moritz_> aye

[13:32] <moritz_> getting infix:<**> to work should give us back some of them

[13:32] <Matt-W> :)

[13:32] <moritz_> but $other_job first

[13:37] *** molaf left
[13:40] <Woodi> masak: what if i install parrot and rakudo into /usr/local ? proto assumes rakudo is nasted in parrot or vice versa

[13:40] <Woodi> so dir is /ur/local/bin

[13:40] <Woodi> s/ur/usr/

[13:41] <moritz_> in the installed-modules branch you can just tell it where rakudo is installed

[13:41] <masak> Woodi: proto cannot know magically where you have your Rakudo/Parrot. therefore, you have to edit config.proto manually.

[13:41] <Woodi> ah right, i'm on master again...

[13:41] <masak> Woodi: when you do that, it won't install Rakudo/Parrot.

[13:42] <masak> it works like that because that's the way it has to work, save for some magical way.

[13:46] *** NorwayGeek is now known as NorwayGeek|Away

[13:49] *** cj_ is now known as cj

[13:49] *** Rint joined
[13:50] *** sjohnson joined
[13:52] *** KyleHa joined
[13:53] *** flip214 left
[13:53] *** arnsholt joined
[13:55] *** Lorn_ left
[13:56] *** Lorn joined
[13:57] <masak> heh, only two test files fail under my patch. :) I can't help thinking that I'm fairly close to a solution.

[13:58] <moritz_> hm, patch for what?

[13:58] <masak> moving <, >, <=, >= to the Setting.

[13:59] <moritz_> ah, cool

[13:59] <masak> http://paste.lisp.org/display/87887

[13:59] <masak> but it fails somewhat because I cannot reproduce in the Setting what gen_whatever does.

[14:01] <moritz_> I think you have to manually write Whatever versions

[14:01] <masak> yes, I think so too.

[14:01] <masak> I'll try that.

[14:03] <Matt-W> it looks plausible

[14:03] <moritz_> maybe I should try to write an automatic whatever-operator generator... :-)

[14:04] <masak> it feels like a waste to roll out a for loop like this...

[14:17] <diakopter> sprixel: g'morning

[14:17] <p6eval> sprixel 28495: OUTPUT«Undeclared routine:␤       g'morning used at line 1␤»

[14:17] <diakopter> o_O

[14:18] <masak> rakudo: g'day

[14:18] <p6eval> rakudo 9792a2: OUTPUT«Could not find non-existent sub g'day␤»

[14:18] <masak> rakudo: optimal

[14:18] <p6eval> rakudo 9792a2: OUTPUT«Could not find non-existent sub optimal␤»

[14:19] <masak> is there any precedent to Rakudo's "Could not find non-existent" choice-of-words?

[14:20] <masak> it still feels borderline tautological to me.

[14:20] *** zloyrusskiy joined
[14:22] *** Confield joined
[14:24] *** ejs2 left
[14:24] <[particle]> could not find non-existent precedent masak

[14:25] <masak> that's right, I don't have any non-existent precedents. :)

[14:25] <masak> only tighter and looser precedents.

[14:26] <PerlJam> masak: you just want to drop "non-existent"?

[14:27] <masak> I haven't thought much about how best to formulate it.

[14:27] <masak> "Could not call non-existent sub foo" would also work.

[14:27] <moritz_> "could not call sub foo: it does not exist"

[14:28] <PerlJam> Well .. it's got to do the name lookup before it gets to the call.

[14:28] <moritz_> "could not call sub foo: no suitable candidate found"

[14:28] <moritz_> PerlJam: that's a detail the user is not interested in

[14:28] <masak> moritz_: that's actually less informative than not existing.

[14:28] *** Psyche^ joined
[14:28] *** pdcawley_ joined
[14:29] <masak> moritz_: if it's an only sub, I as a user does not want to hear about candidates.

[14:29] <masak> s/does/do/

[14:29] <moritz_> masak: that second example was for a different error condition

[14:29] <masak> oh, ok.

[14:30] <moritz_> I just think that similar errors should look similar

[14:30] <moritz_> "could not call sub foo: ambiguous dispatch"

[14:30] <moritz_> and so on

[14:30] *** iblechbot joined
[14:30] <moritz_> maybe s/sub/subroutine/

[14:32] *** TiMBuS left
[14:33] <masak> 'sub' rather than 'subroutine' is not so bad, since there's the keyword 'sub'.

[14:34] <masak> 'curly' instead of 'curly brace' is worse.

[14:44] *** Patterner left
[14:45] *** pdcawley left
[14:45] *** pdcawley_ is now known as pdcawley

[14:47] <[particle]> "Error while attempting to call subroutine 'foo': subroutine not found"

[14:48] <[particle]> or 'subroutine does not exist'

[14:48] <mberends> "Cannot call subroutine 'foo': not found"

[14:48] * masak likes

[14:49] <[particle]> 'not found' and 'does not exist' mean different things

[14:49] *** __ash__ left
[14:49] <[particle]> one assumes the compiler is omnicient. i argue it is not.

[14:50] *** __ash__ joined
[14:51] <mberends> diakopter: how is num.t doing? will it affect interp.js much?

[14:52] <[particle]> mmm... ecmaperl.

[14:52] <moritz_> [particle]: I don't like the "does not exist", because it might exist, just not in the current scope

[14:52] <[particle]> moritz_: i agree

[14:53] <diakopter> mberends: some

[14:53] <[particle]> i also believe compiler error messages should be humble and polite, not harsh and terse

[14:53] *** ejs joined
[14:54] <moritz_> agreed

[14:54] <[particle]> how would a butterfly tell you something's wrong?

[14:54] <diakopter> METHOD_MISSING NOT FOUND

[14:54] <moritz_> [particle]: it'd flap its wings in some particular angle :-)

[14:55] <[particle]> it's all in the hips.

[14:55] <moritz_> "can't call 'foo': no such sub" # that would be a Unix style error message

[14:55] <diakopter> "Undeclared routine" - "you may have declared this routine somewhere, but in the input you gave me!"

[14:55] <masak> 'Tried to call &foo, but could not find it'

[14:56] <moritz_> without the sigil please

[14:56] <masak> fair enough.

[14:56] *** nihiliad joined
[14:56] *** __ash__ left
[14:56] <moritz_> we should also decide if we want proper sentences

[14:56] <moritz_> "... but *I* could not find it"

[14:57] <masak> I doubt we'd want that.

[14:57] <masak> rakudo: sub foo(Int $a) {}; foo("OH HAI")

[14:57] <p6eval> rakudo 9792a2: OUTPUT«Parameter type check failed; expected Int, but got Str for $a in call to foo␤in sub foo (/tmp/F9UYeIf5T1:1)␤called from Main (/tmp/F9UYeIf5T1:0)␤»

[14:58] <masak> it also bothers me very slightly that 'foo' is mentioned twice in a row in that message.

[14:58] <masak> is there any situation when those two mentions will differ?

[14:58] <mberends> de-commute &

[14:58] <moritz_> well, the 'in foo' is part of the back trace

[14:59] <moritz_> but as a user I'd expect that it doesn't get that far

[14:59] *** mberends left
[14:59] <masak> then leave it out the first time.

[14:59] <moritz_> ie that the argument list binding happens before the call

[14:59] <moritz_> masak: no, that's the wrong solution (IMHO)

[14:59] <[particle]> moritz_: i think phrases by default, with a cpan module for more expressive errors

[15:00] <masak> moritz_: do you see a way to only say 'foo' once?

[15:00] <moritz_> masak: yes, have the error occur at the position of the caller, not the callee

[15:00] <diakopter> my suggestion: "Unexpected Str $a; expected Int $a NL in sub foo (...

[15:00] *** pmurias joined
[15:01] * masak submits rakudobug

[15:01] <diakopter> (implying that "Str $a" would be the signature if it would have succeeded

[15:01] <diakopter> )

[15:02] <diakopter> or

[15:03] *** mdxi joined
[15:03] <diakopter> "Expected Int $a, but got Str for parameter $a in sub foo..."

[15:03] <masak> nice one.

[15:04] <diakopter> basically just moves 'parameter' to the end and more concise

[15:05] * diakopter wades through pugs/src/perl6 changes from TimToady

[15:08] <colomon> moritz_: did your merge to master merge the complex branch

[15:09] <diakopter> ahah!

[15:09] <diakopter> sprixel: my $b = { say $b; my $b = 4 }; $b();

[15:09] <p6eval> sprixel 28495: OUTPUT«[31m===[0mSORRY![31m===[0m␤Lexical symbol $b (from line 1) is already bound to an outer scope implicitly␤  and must therefore be rewritten explicitly as OUTER::<$b> before you can␤  unambiguously declare a new $b in the same scope at /tmp/qqcruiX0RZ line 1:␤------> [32mmy

[15:09] <p6eval> ..$b =…

[15:09] <TimToady> diakopter: one difference is that PARENT:: became symbolic, which cuts down cycles

[15:10] <TimToady> that's the longest error message (not counting expectation lists)

[15:10] <diakopter> SORRY! (c) Milton Bradley

[15:11] <diakopter> after all, this is a game, right? :)

[15:11] <masak> there's a beautiful discussion going on at the google-summer-of-code-mentors-list about inappropriate jokes, cultural stereotypes, and open-source communities. it's beautiful because people, while visibly disapproving of the originator's behaviour, are also quite empathic.

[15:12] *** pmurias_ joined
[15:12] <pmichaud> ("Could not find non-existent sub...")   ...that message is actually coming from Parrot.

[15:12] *** hanekomu left
[15:12] <pmichaud> so "Rakudo" didn't have anything to do with the word choice :)

[15:13] <diakopter> sprixel: package Foo { my Int $b = 4; }; package Foo { my Str $b = "hiya"; };

[15:13] <p6eval> sprixel 28495: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of symbol Foo (from line 1) at /tmp/1G9uRw1qye line 1:␤------> [32mkage Foo { my Int $b = 4; }; package Foo[33m⏏[31m { my Str $b = "hiya"; };[0m␤»

[15:13] *** jauaor left
[15:14] <diakopter> sprixel: package Foo { my Int $b = 4; my Str $b = "hiya"; };

[15:14] <p6eval> sprixel 28495: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $b (from line 1) at /tmp/cqiR5AU5iO line 1:␤------> [32mpackage Foo { my Int $b = 4; my Str $b[33m⏏[31m = "hiya"; };[0m␤execute(): execute error: noun__S_package_declarator not yet implemented; srsly!!?!?␤last:

[15:14] <p6eval> ..stateme…

[15:14] <masak> by the rules of the game, it's still a Rakudobug. just as a Null PMC access is a Rakudobug.

[15:15] <TimToady> diakopter: conformance test is still just a comment :)

[15:15] <pmichaud> masak: I was simply answering the question above...

[15:15] <pmichaud> 14:19 <masak> is there any precedent to Rakudo's "Could not find non-existent" choice-of-words?

[15:16] <masak> oh, ah. I meant something more like "the words that are displayed there when Rakudo is run".

[15:16] <masak> :)

[15:16] <pmichaud> right

[15:16] <pmichaud> that's the question I was answering... Rakudo didn't choose those words, Parrot did :)

[15:17] <diakopter> sprixel: package Foo { Foo::bar };

[15:17] <p6eval> sprixel 28495: OUTPUT«Undeclared name:␤  Foo::bar used at line 1␤execute(): execute error: noun__S_package_declarator not yet implemented; srsly!!?!?␤last: statement␤T,T__noun__S_package_declarator,BEG,_specific,SYM,END,package_declarator,M,phase,postDo,eval_args,invoker,context at sprixel.pl line

[15:17] <p6eval> ..84.␤»

[15:17] <diakopter> sprixel: package Foo { Foo::bar 4 };

[15:17] <p6eval> sprixel 28495: OUTPUT«Undeclared name:␤  Foo::bar used at line 1␤execute(): execute error: noun__S_package_declarator not yet implemented; srsly!!?!?␤last: statement␤T,T__noun__S_package_declarator,BEG,_specific,SYM,END,package_declarator,M,phase,postDo,eval_args,invoker,context at sprixel.pl line

[15:17] <p6eval> ..84.␤»

[15:18] <TimToady> took it as a post-declared function, I guess

[15:18] <diakopter> std: package Foo { Foo::bar 4; sub bar {} };

[15:18] <p6eval> std 28495: OUTPUT«ok 00:02 95m␤»

[15:18] <pmichaud> TimToady: I have a question for you about protoregexes, when you get a chance...

[15:18] <pmichaud> http://nopaste.snit.ch/18112

[15:18] <TimToady> are you in a snit? :)

[15:18] * diakopter is sniveling

[15:18] <pmichaud> apparently :)

[15:18] <pmichaud> for some reason gist.github.com isn't accepting my nopaste, so I went to the snit.ch one instead :)

[15:19] <pmichaud> sorry, I screwed up the syntax

[15:19] <pmichaud> let me renopaste

[15:19] <TimToady> I see what you meant

[15:20] *** rfordinal joined
[15:20] <pmichaud> better one

[15:20] <pmichaud> http://nopaste.snit.ch/18113

[15:20] <pmichaud> argggggh

[15:21] <pmichaud> http://nopaste.snit.ch/18114  # "This time for sure!"

[15:24] <TimToady> I don't believe it should match.  The alternatives are constructed by calling the "PEEK" for each known method name, and only the derived one will answer with a B-ish token/fate

[15:25] <diakopter> TimToady: std does seem to parse num.t more quickly

[15:25] <TimToady> maybe you're just getting used to it :)

[15:25] *** Psyche^ left
[15:25] *** Psyche^ joined
[15:26] *** Psyche^ is now known as Patterner

[15:26] *** am0c joined
[15:27] <pmichaud> are   something:foo   and something:sym<foo>   the same "known method name"  ?

[15:27] <pmichaud> or are they different?

[15:27] <TimToady> anyway, wrt globals, I think you should find that $*DECLARAND<inpkg inpad> hold the names of the package or pad that it is being declared in

[15:28] <pmichaud> does S05 talk about the "regex something:foo { ... }"  syntax?

[15:28] <pmichaud> I don't see it there... I only see    "regex something:sym<foo> { ... }"

[15:28] <TimToady> pmichaud: STD considers them the same, but it's just sugar, and possibly rots the teeth

[15:29] *** pmurias left
[15:29] <pmichaud> so, one(True, False)  ?

[15:29] <pmichaud> ;-)

[15:29] *** abra joined
[15:30] <TimToady> "Go not to the elves for advice, for they will say both 'yes' and 'no'."

[15:30] <pmichaud> I'm fine with   regex something:foo { ... }    being sugar for  something:sym<foo>

[15:31] <TimToady> I've unwanted it a time or two, but not so much as to take it back out :)

[15:31] <dalek> rakudo: c8181aa | masak++ |  (5 files):

[15:31] <dalek> rakudo: Moved <, >, <=, and >= into the Setting

[15:31] <dalek> rakudo: In order for such a move to work, all declarations outside of the Setting

[15:31] <dalek> rakudo: had to be removed. This includes the nice autogeneration of subs in

[15:31] <dalek> rakudo: gen_whatever_pir, which unfortunately translates to eight quite similar

[15:32] <dalek> rakudo: methods in the Setting. Improvements welcome.

[15:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c8181aad2670fb74f7aaa1c905205e34e83101bd

[15:32] *** envi^home joined
[15:33] <TimToady> on your example, if you want to match, the derived rule should offer <nextsame> as an alternative

[15:33] <pmichaud> so, is having a separate "PEEK" method for each protoregex a semi-standard of some sort... i.e., the "expected" solution for P6 implementations?

[15:33] <TimToady> STD does this with Regex::ws for instance

[15:34] <TimToady> well, originally I was going to have it be an attribute of the method itself

[15:34] <TimToady> but P5 doesn't really support that

[15:34] <TimToady> however, it must reflect the actual dispatch

[15:34] <pmichaud> that's the way I've been heading as well

[15:34] <TimToady> so I made the parallel PEEK method

[15:35] <pmichaud> essentially I think I end up keeping track of which method names I've already visited and skip the ones already seen

[15:35] <pmichaud> that shouldn't be a problem

[15:35] <TimToady> presumably P6's .can returns the subs that can be asked for their "peekage"

[15:36] <TimToady> but the _PEEK solution also works okay

[15:36] <TimToady> so I don't think we need to spec it one way or the other

[15:36] <pmichaud> right, I agree

[15:36] <pmichaud> so the answer to my original question is that protoregex only considers the most-derived candidates by name (more)

[15:37] <pmichaud> and each most-derived candidate can delegate to its less-derived version by using <nextsame>

[15:37] <pmichaud> ...or does <nextsame> throw things back to the protoregex for the "next longest match"?

[15:37] <diakopter> yay: http://nopaste.snit.ch/18116

[15:37] <TimToady> I suspect that STD currently only really handles ||<nextsame>, not |<nextsame>

[15:38] <pmichaud> okay.

[15:38] <pugs_svn> r28496 | diakopter++ | [sprixel] first 35 of num.t pass 

[15:38] <pmichaud> wfmfn.

[15:38] <TimToady> so <nextsame>'s LTM is invisible outside

[15:39] <TimToady> or another way to say it is that we'd have to implement nextsame_PEEK to get the latter

[15:40] <TimToady> oh, I guess it'd really be nextsame__PEEK  :)

[15:40] <TimToady> can't remember my own implementation from moment to moment...

[15:41] <pmichaud> I know what you mean :)

[15:41] <pmichaud> diakopter++ # impressive work

[15:41] <masak> diakopter++

[15:41] <diakopter> pmichaud:  thanks :)

[15:42] <diakopter> masak: thanks :)

[15:42] <TimToady> ++diakopter  :)

[15:42] <masak> ++TimToday :)

[15:42] <masak> spread the hypocritical love!

[15:43] <TimToady> ++mäsak

[15:43] *** ChanServ sets mode: +o pmichaud

[15:43] <masak> "if a prefix karma autoincrement falls in the forest..."

[15:43] *** ChanServ sets mode: +o masak

[15:43] *** pmurias_ is now known as pmurias

[15:43] *** ChanServ sets mode: +o diakopter

[15:44] *** ChanServ sets mode: +v p6eval

[15:44] <pmurias> diakopter: how will/does method call work in sprixel?

[15:47] <diakopter> pmurias: it's currently modelling the Perl6 objects as JS objects directly (single-inheritance only), but

[15:48] *** abra left
[15:48] <diakopter> another dispatch/resolution layer (or four) could be added without much difficulty

[15:48] <diakopter> so for test 36 of num.t

[15:49] <diakopter> I'm trying to figure out to what it's resolving .Int

[15:49] <diakopter> of $a

[15:49] *** ejs1 joined
[15:50] <diakopter> you can enable global trace to see the enter/leave of node type labels

[15:50] <diakopter> http://nopaste.snit.ch/18118

[15:52] <diakopter> so, variable is not looking in the proper context

[15:53] *** zloyrusskiy left
[15:53] <diakopter> Methodcall needs to alter its childrens' context to be the invocant object instead of the lexical context(-tree)

[15:56] *** abra joined
[15:57] *** rfordinal left
[15:59] <PerlJam> diakopter: you could use Joose to get to Perl 6 objects in JS quickly I think.

[16:00] <masak> synergy++

[16:00] *** Student joined
[16:00] <diakopter> oh, I see, Methodcall knows nothing about method calls; only sub calls. :)  I see... /me writes responder protocol

[16:02] <diakopter> TimToady: the dotty ( Methodcall['.'][1] ) isn't lifted to a property of the Methodcall obj.. should it be?

[16:03] <TimToady> method calls are considered a postfix operator

[16:03] <TimToady> so in theory it the object should show up as an arg

[16:03] <TimToady> s/it//

[16:03] <diakopter> the .arg is the $a

[16:04] <mikehh> rakudo (c8181aa) builds on parrot r41559 - make test / make spectest_smolder (up to r28496 -> #28316) PASS - Ubuntu 9.04 amd64

[16:05] <diakopter> the POST is the '.'[0], and the .dotty of the POST is dotty__S_Dot, and the .methodop of that is...

[16:05] <diakopter> methodop,BEG,arglist,longname,args,END,M

[16:06] <diakopter> I mean, the POST is the '.'[1]

[16:06] <diakopter> and so forth

[16:09] <diakopter> I can find the method name by descending into this.M[1].dotty.dottyop.methodop.longname.name.identifier

[16:09] <diakopter> which is fine..

[16:10] *** ejs left
[16:14] <moritz_> colomon: no, that merge commit was unrelated (and an accident)

[16:16] <colomon> moritz_: gotcha

[16:16] *** justatheory joined
[16:17] <colomon> I see there are plenty of failures in the spectest to work on for the complex branch.

[16:17] <moritz_> an implementation of infix:<**> would help

[16:17] <colomon> I'm looking at that.

[16:18] <colomon> (among other things)

[16:22] *** cdarroch joined
[16:23] <moritz_> I hope you saw my other commits in that branch

[16:25] <colomon> moritz_: I keep pulling before I do anything.  :)

[16:26] <moritz_> great

[16:29] <colomon> Actually, once exp and ln work, we get ** for free.

[16:29] <colomon> I've got a quick implementation of exp (not tested or checked in), ln will be trickier.

[16:29] <moritz_> I know ;-)

[16:29] *** ejs1 left
[16:30] <moritz_> no, ln is not much trickier, with inline PIR

[16:30] <moritz_> just generate a Complex, set the re and im part

[16:30] <moritz_> $P1 = $P0.'ln'()

[16:31] <moritz_> generate a Perl 6 complex

[16:31] <moritz_> return that

[16:31] <colomon> Hmmmm...

[16:31] <moritz_> I might give it a shot

[16:31] <colomon> multi method exp() { Complex.new($.re.exp * $.im.cos, $.re.exp * $.im.sin); }

[16:31] <colomon> (I have to be afk for a bit...)

[16:32] *** pmurias left
[16:32] *** pmurias joined
[16:36] *** stephenlb joined
[16:36] <diakopter> pmurias: to more accurately answer your question, method calls aren't implemented :)

[16:37] <diakopter> I just made type coercions work..

[16:45] <diakopter> implemented bigint **

[16:46] * moritz_ tries to implement Complex.log

[16:52] *** mberends joined
[16:55] <masak> mberends: oh hai. I expect to give you a Temporal flux draft tonight.

[16:55] <mberends> jipee!

[16:59] <pugs_svn> r28497 | diakopter++ | [sprixel] 40/48 pass in num.t 

[17:00] *** ejs joined
[17:04] <colomon>  moritz_: just realized that exp(Complex) is failing even though I've defined Complex.exp...

[17:05] <masak> does Parrot emply CPS for function calls?

[17:05] <moritz_> masak: I'm pretty sure it does

[17:05] <moritz_> colomon: did you add the 'is export' trait?

[17:05] <colomon> trying that now...

[17:06] <masak> that's yet another strange mismatch between Rakudo and Parrot, then.

[17:06] <masak> today it was the re-invention of Complex, and lately it's been something with calling conventions.

[17:07] <masak> I increasingly long for first-class continuations in Perl 6, and it just feels so ironic that Rakudo then is built upon a VM that has'em.

[17:07] <masak> and still they're not even planned to be reachable, except awkwardly through gather/take!

[17:08] <colomon> moritz_: "is export" makes exp(Int) fail!

[17:08] <moritz_> masak: I think TimToady's plan is that not every Perl 6 implementation needs "real" continuations, because not every VM has them

[17:08] <moritz_> colomon: I just experience the same for log() here

[17:09] <colomon> I guess we can define Any.exp and export that?  Maybe?

[17:09] <masak> moritz_: which means that one can never write platform-indep Perl 6 which uses continuations. I understand TimToady's rationale, but I still think it's very sad.

[17:09] *** Woodi_ joined
[17:10] <moritz_> colomon: isn't there an Any.exp already?

[17:11] <moritz_> colomon: I think the 'is export' doesn't properly add the type constraint to the first arg of the multi...

[17:11] <moritz_> colomon: I'm trying now to use an explict multi sub log(Complex $x) { $x.log } instead

[17:11] <moritz_> there used to be such a bug, but I thought it was fixed.

[17:11] <masak> </rant>

[17:11] <moritz_> I might very well be wrong

[17:12] <colomon> moritz_: I don't see any sign of Any.exp in Any-num.pm

[17:12] *** envi^home left
[17:12] <moritz_> bah, now I did this I get a Null PMC access in find_method

[17:13] <moritz_> *sigh*

[17:14] <colomon> Trying Any.exp right now...

[17:15] *** crythias joined
[17:16] <colomon> No go.

[17:17] <moritz_> somehow this is all very strange

[17:17] <moritz_> ah

[17:17] <moritz_> it's because the ordinary sub log() is still in PIR

[17:17] <moritz_> the multi dispatcher doesn't like that.

[17:17] <colomon> exp too, I bet?

[17:18] <moritz_> aye

[17:18] <moritz_> src/builtins/math.pir

[17:18] <masak> that's the same issue I had today with infix:<< < >> et al.

[17:19] <colomon> moritz_: take the obvious approach to getting them out?

[17:19] <moritz_> colomon: aye

[17:19] <moritz_> I'm going to take care of log()

[17:20] <colomon> I'm trying exp.

[17:21] <diakopter> 47/48 pass in num.t.   lazyirc: would someone tell me what this means:  is +^1, -2, '+^1 == -2 as promised';

[17:21] <moritz_> numerical bitwise negation?

[17:22] * moritz_ guessing

[17:23] <diakopter> numeric xor

[17:23] <diakopter> but with what

[17:23] <masak> xor is binary.

[17:24] <moritz_> +^1 certainly looks like a prefix operator

[17:24] <diakopter> oh, numeric complement

[17:24] <masak> it's two complements' negation.

[17:24] *** pdcawley_ joined
[17:24] <diakopter> so in bigints that means...

[17:25] <moritz_> fun!

[17:25] <diakopter> heh

[17:25] *** ejs left
[17:25] <diakopter> downsample/cast to an int?  then +^  ?

[17:26] <colomon> moritz_: Huh.  Now exp(int) works again, but exp(Complex) is back to failing (even with "is export" on it)

[17:26] <pugs_svn> r28498 | mberends++ | [sprixel.mk] updated 'test' and 'spectest' targets 

[17:26] <masak> diakopter: that sounds slightly evil.

[17:27] <diakopter> masak: ok, but..

[17:27] *** pmurias left
[17:27] *** pmurias joined
[17:27] <masak> diakopter: throw an overflow exception?

[17:28] <diakopter> if the int is bigger than 2 ** 31 you mean?

[17:28] <pugs_svn> r28499 | diakopter++ | [sprixel] 47/48 pass in num.t.  Well, one is TODO (b/c lives_ok and dies_ok aren't implemented yet) 

[17:28] <masak> diakopter: aye.

[17:29] <moritz_> pugs: say +^2**33

[17:29] <p6eval> pugs: OUTPUT«-8589934593␤»

[17:29] *** mariuz left
[17:29] <moritz_> pugs: say +^2**34

[17:29] <p6eval> pugs: OUTPUT«-17179869185␤»

[17:29] <diakopter> hrm

[17:29] <diakopter> pugs: say +^2**65

[17:29] <p6eval> pugs: OUTPUT«-36893488147419103233␤»

[17:29] <diakopter> wow

[17:30] * diakopter goes hunting in the bigint lib

[17:30] <moritz_> pugs does real bigints.

[17:30] <moritz_> pugs: say 2**65

[17:30] <p6eval> pugs: OUTPUT«36893488147419103232␤»

[17:30] <moritz_> you see they differ by a sign and 1

[17:31] <moritz_> +^$x == -$x - 1 or so

[17:31] <moritz_> pugs: say +^0

[17:31] <p6eval> pugs: OUTPUT«-1␤»

[17:31] <moritz_> pugs: say +^1

[17:31] <p6eval> pugs: OUTPUT«-2␤»

[17:31] <moritz_> pugs: say +^-1

[17:31] <p6eval> pugs: OUTPUT«0␤»

[17:31] <moritz_> pugs: say +^-2

[17:31] <p6eval> pugs: OUTPUT«1␤»

[17:31] <moritz_> yap, that's it.

[17:31] <diakopter> ok, easy then

[17:31] <diakopter> heh

[17:31] <diakopter> moritz_: thanks

[17:32] <moritz_> diakopter: yw

[17:32] *** rblasch left
[17:32] * diakopter didn't take a compsci or electrical engineering class

[17:33] *** barney left
[17:33] <moritz_> the more I touch here, the more shatters to pieces

[17:33] <moritz_> $ ./perl6 -e 'say (30).log'

[17:33] <moritz_> 0

[17:33] <moritz_> ./perl6 -e 'say (30.3 + 2i ).log'

[17:33] <moritz_> 3.41114771251532 + 1.5707963267949i

[17:34] *** pdcawley left
[17:34] *** pdcawley_ is now known as pdcawley

[17:34] <moritz_> $ ./perl6 -e 'say (30.3 + 0i ).log'

[17:34] <moritz_> 3.41114771251532 + 1.5707963267949i

[17:34] <moritz_> why don't i believe that? ;-)

[17:34] <pmichaud> I don't think that Rakudo methods do mmd dispatched based on the invocant type yet

[17:34] <pmichaud> *dispatch

[17:34] <moritz_> so I should forget all about 'is export' for that right now?

[17:34] <pmichaud> probably

[17:34] <colomon> moritz_: ah, the problem I'm looking at is that the test uses Complex *, also not working yet.  can fix that quickly.

[17:35] <moritz_> that's easy, yes

[17:35] <pmichaud> and even if it did understand invocant types, I'm not sure that 'is export' knows how to combine multisubs yet

[17:35] *** crythias left
[17:36] <pugs_svn> r28500 | diakopter++ | [sprixel] 47/48 in num.t pass (and 1 TODO); moving on to another .t 

[17:36] <pmichaud> there's a lot of namespace-management code that tends to want to rebind symbols instead of merge multisubs

[17:36] <pmichaud> and that's a problem for multis

[17:36] <pmichaud> typically I've been simply creating global subs that then redispatch to the first argument

[17:36] <moritz_> and I'm having fun with that (fsvo fun)

[17:36] <pmichaud> i.e.,:    multi sub log($x) { $x.log }

[17:37] <moritz_> still I don't see why the method form doesn't work

[17:37] <pmichaud> oh, the method form should work, definitely.

[17:37] <lisppaste3> moritz_ pasted "method log() in class Num" at http://paste.lisp.org/display/87906

[17:38] <moritz_> is there any big WTF in there?

[17:38] <pmichaud> that $N0 = self looks wtfish

[17:38] <moritz_> what's wrong with it?

[17:38] <moritz_> and how to do it better?

[17:39] <pmichaud> why do $N0 = self  only to throw the result away on the next statement?

[17:39] <pmichaud> perhaps you mean  $N0 = log $N0  on the next line?

[17:39] <pmichaud> (or ln, or whatever)

[17:39] <moritz_> erm, yes

[17:40] <moritz_> or should I call self.'ln'() directly?

[17:40] <diakopter> in radix.t, basically :10('0b1110') is synonymous with :10('0b1110'.Int)

[17:40] <pmichaud> only if you expect all objects to have a .'ln' method

[17:40] <pmichaud> (which I wouldn't expect)

[17:40] <moritz_> only all Num objects ;-)

[17:41] <pmichaud> I wouldn't even expect that, necessarily :-)

[17:41] <pmichaud> if we know we're wanting to get to a floating-pointish thing, I'd go through the $N0 registers to get there.

[17:41] <moritz_> ok

[17:41] <pmichaud> $N0 = self;  $N0 = ln $N0;  %r = box $N0

[17:42] <pmichaud> at least I'd start there, as it has the least chance of doing bizarr-o things.

[17:42] <moritz_> bizzaro - the name of the next Perl 6 compiler ;-)

[17:42] <pmichaud> or the next phase of Rakudo development after "Rakudo *"

[17:43] <pmichaud> i.e., the "Rakudo Bizarro" series

[17:43] <moritz_> or that, yes ;-9

[17:43] <pugs_svn> r28501 | mberends++ | [sprixel] partial Replication - "A" x 3 gives "AAA" (but so does "A" xx 3) 

[17:43] <moritz_> s/9/)/

[17:45] *** abra left
[17:46] *** abra joined
[17:50] <pugs_svn> r28502 | lwall++ | [S02,S03,S32] 

[17:50] <pugs_svn> r28502 | add Stringy role

[17:50] <pugs_svn> r28502 | attempt to distinguish numeric objects from Numeric, Real, Integral, etc roles

[17:50] <pugs_svn> r28502 | split Pair into immutable PairVal and mutable Pair

[17:50] <pugs_svn> r28502 | split Mapping into immutable PairValSet and mutable PairSet

[17:50] <pugs_svn> r28502 | general typological housekeeping that will doubtless gobsmack the implementors

[17:51] <colomon> ye heavens, that commit log entry looks scary....

[17:51] <mberends> implementors, watch your gobs!

[17:53] * ruoso runs to the hills

[17:53] <moritz_> TimToady++

[17:53] <moritz_> is the Class class gone?

[17:56] <moritz_> anyway, that cleans up a lot of things, IMHO

[17:56] <TimToady> there never was a Class class really

[17:56] <moritz_> ok

[17:57] <moritz_> is Buf ~~ Stringy?

[17:57] <TimToady> I think so

[17:57] <TimToady> but not Unicodey :)

[17:57] <moritz_> :-)

[17:58] <moritz_> so how does a function like say() treats its arguments? by calling .encode() on them? or .Stringy, and encode if it's not a buffer?

[17:58] <TimToady> say requires a very low-level stringification that can even stringify a junction

[17:59] <TimToady> I think that neither ~ nor .Str will work

[17:59] <TimToady> since both of those should probably autothread

[17:59] <TimToady> so, .forcestr or some such

[18:00] <TimToady> or maybe it's .Buf that that force is :)

[18:00] <TimToady> *forces

[18:00] <PerlJam> what differentiates .Str and .forcestr such that one autothreads and the other doesn't?

[18:00] *** NorwayGeek|Away is now known as NorwayGeek

[18:00] <moritz_> the one that doesn't needs to be in Object

[18:01] <TimToady> well, but it's Object that actually does autothreading when it notices a junction that wasn't handled by the junction class

[18:02] <TimToady> oddly enough

[18:03] <TimToady> *notices a method that

[18:03] <moritz_> I thought that was the dispatcher, and in my mental model that belonged to the meta class, not to Object

[18:03] <PerlJam> I told a student today that anyone doing anything new is generally in a state of confusion most of the time.  That's how #perl6 often makes me feel. :-)

[18:04] <TimToady> well, whatever it is that would say "no such method" otherwise

[18:05] <TimToady> it seems more general to put the backstop into Object as a generic CANDO anything rather than making every possible dispatcher handle it

[18:07] <TimToady> anyway, under that model, there would be a .forcestr (or whatever) in the junction class itself that says how to stringify a junction

[18:07] <TimToady> you can't really write a generic forcestr in Object; each type has to know how to forcestr itself

[18:09] <TimToady> but anyway, the real name of .forcestr might actually be .Buf

[18:09] <TimToady> or some such

[18:10] <moritz_> hm

[18:10] <TimToady> or .Buf calls .forcestr

[18:10] <moritz_> that sounds saner

[18:10] *** |Jedai| joined
[18:12] <TimToady> probably should be .FORCESTR since it's often called implicitly, and is less likely to conflict with normal methods if we shout

[18:12] <moritz_> wfm

[18:12] <PerlJam> TimToady: +1

[18:13] <PerlJam> (I always think such special subs should be marked with some symbol, but perl already has the history of shouting)

[18:13] *** jaldhar left
[18:13] <PerlJam> it still bugs me that import isn't all-caps in perl 5 even.

[18:14] *** nihiliad left
[18:14] *** nihiliad joined
[18:15] <TimToady> I think I'll change Foo defines * to import Foo just to pull the keyword out front

[18:15] <TimToady> even it it does make it look like Python

[18:16] *** alester joined
[18:17] <masak> there are worse things than looking like Python.

[18:18] <moritz_> looking like cobol, or Fortran 77 ;-)

[18:18] <PerlJam> perhaps it's just my mathematical bent, but F77 doesn't look *that* bad.  COBOL on the other hand ... ick!

[18:19] <moritz_> PerlJam: well, if you like meaning based on the column position...

[18:19] <moritz_> (yes, F77 is still column based)

[18:19] *** jjore left
[18:20] <PerlJam> moritz_: only before the 8th column; everything from there on is "free form"  

[18:20] <moritz_> up to the... 78ths?

[18:21] <PerlJam> Herman Hollerith's legacy lives on!  :)

[18:21] <moritz_> and identifier length limited to 8, what happens when you use longer ones is up to the compiler

[18:21] <TimToady> maybe they should add line numbers to Python on the right

[18:21] <moritz_> :-)

[18:22] *** barney joined
[18:22] <PerlJam> They'll be a time in the not-too-distant future when you'll utter something like that and someone will churn out a slang that does it.

[18:23] *** pmurias left
[18:24] <PerlJam> Hmm.  making the barrier to entry of language design low enough and we may see a combinatorial explosion of new (but very familiar ;) languages

[18:24] <PerlJam> s/making/Make/

[18:25] <araujo> TimToady, it will look like Haskell!

[18:25] *** pyrimidine joined
[18:26] *** Jedai left
[18:26] <colomon> moritz_: you having any luck with Complex.ln there?  I'm still running in circles with Complex.exp, though I have defined some other useful stuff...

[18:27] <moritz_> colomon: yes, pushed

[18:29] *** am0c left
[18:29] <colomon> moritz_: \o/

[18:30] <colomon> now to figure out how to merge what I've got with what you pushed...

[18:30] *** abra left
[18:33] <moritz_> git pull --rebase; # manually merge what git couldn't;

[18:33] <moritz_> git add $merged_files

[18:33] <moritz_> git rebase --continue

[18:34] * diakopter feels slightly blameworthy for r28502

[18:34] <PerlJam> moritz_: why rebase exactly?

[18:35] *** nihiliad left
[18:35] *** nihiliad joined
[18:35] <moritz_> PerlJam: it's "a way", not "the way"

[18:35] <PerlJam> sure, and I'm asking what your reasoning is for that way :)

[18:36] <PerlJam> plus I've generally got a "rebase bad, merge good" thing in my head  since rebasing is very much like svn

[18:37] <Tene> PerlJam: it avoids the large number of mostly useless merge commits.

[18:37] <moritz_> well, it creates a linear history which is very easy to inspect

[18:37] <Tene> right.

[18:38] <Tene> run 'gitk' in rakudo's repo

[18:39] <colomon> darn, do we need basic complex arithmetic tests....

[18:39] <moritz_> http://d.hatena.ne.jp/ku-ma-me/20090916/p1

[18:40] <Tene> PerlJam: They don't really *hurt* anything much, just a little less than ideal.

[18:45] *** zloyrusskiy joined
[18:46] *** zloyrusskiy left
[18:47] <colomon> moritz_: Did you do Complex.ln or Complex.log?  I seem to only get the latter....

[18:47] <moritz_> colomon: .log

[18:48] <moritz_> there's no .ln, iirc

[18:48] <colomon> moritz_: ah, default base for log is e, eh?

[18:50] <moritz_> it is

[18:50] *** jjore joined
[18:51] <colomon> scrambling to get what I've got into non-embarrassing shape so I can push it.

[18:52] <colomon> I think we're going to have to move abs to the setting before we can get the Complex tests running correctly.

[18:52] <moritz_> (public code review)++ # makes you care a bit more about your stuff

[18:53] <moritz_> colomon: that might very well be possible, yes

[18:53] <colomon> moritz_: In this case it just doesn't quite work yet...

[18:53] <colomon> is_approx calls abs, if I recall correctly.

[18:53] <moritz_> colomon: that's fine - that's why it's a branch

[18:53] <moritz_> it's OK to break stuff in branches

[18:54] <moritz_> (that's how I started it all ;-)

[18:56] *** NorwayGeek left
[18:57] *** NorwayGeek joined
[18:58] <colomon> Okay, I've just pushed what I've got.  Complex.exp still fails with a mysterious error message in exp.t, but seems to work okay from REPL.

[18:58] <colomon> oh, duh, failure probably is because of abs.

[19:04] <moritz_> that shouldn't be so hard to move to the setting, shouldn't it?

[19:06] <moritz_> rakudo: say abs(-3).WHAT

[19:06] <p6eval> rakudo c8181a: OUTPUT«Use of type object as value␤0␤»

[19:07] <moritz_> WTF?

[19:07] <colomon> moritz_: I was just bracing myself to try it, now I just want to run away gibbering.

[19:07] <moritz_> colomon: I can do it (or at least trying)

[19:07] <colomon> go for it!

[19:11] *** pdcawley_ joined
[19:12] *** zerhash left
[19:17] *** pdcawley left
[19:17] *** pdcawley_ is now known as pdcawley

[19:19] <moritz_> colomon: done, and pushed

[19:19] * diakopter doesn't believe in fudging

[19:20] <diakopter> (anymore/yet)

[19:20] <diakopter> radix.t takes 38s to parse

[19:20] * moritz_ does

[19:20] <diakopter> for sprixel, I mean

[19:21] <mberends> go diakopter!

[19:22] <pugs_svn> r28503 | diakopter++ | [sprixel] 71/195 tests pass from radix.t so far 

[19:25] *** Woodi_ left
[19:31] <pugs_svn> r28504 | diakopter++ | [sprixel] 75/195 radix.t 

[19:33] *** pdcawley_ joined
[19:34] <diakopter> this test isn't correct, I think:  is(:16('0o377'),    0o377, ":16('0o255') converts from octal");

[19:36] *** dakkar left
[19:36] <TimToady> it's correct according to S02:2630

[19:38] *** jauaor joined
[19:39] <diakopter> the comment says 0o255 but there's 0o377 in the arg

[19:39] <mberends> the description could be made to match the test data

[19:40] <mberends> diakopter, you clobbered commit 28501 (partial Replication)

[19:41] <diakopter> mberends: :( sorry

[19:41] <diakopter> oh, b/c of the file move/rename

[19:41] <diakopter> I meant to check for that before I committed; I lapsed

[19:41] <mberends> forgiven :) will re-do

[19:42] <mberends> I'll ask for a hint how to complete it

[19:44] *** __ash__ joined
[19:46] <pugs_svn> r28505 | mberends++ | [sprixel] partial Replication again - "A" x 3 gives "AAA" (but so does "A" xx 3) 

[19:46] *** Lorn_ joined
[19:46] *** Lorn_ left
[19:47] *** barney left
[19:47] <mberends> diakopter, in interp.js:232, what member of 'this' indicates whether the function is processing an x or an xx ?

[19:47] *** szabgab joined
[19:48] * diakopter svn ups

[19:49] <diakopter> mberends: put a line at the top of that function that says:   throw keys(this);

[19:49] <diakopter> that will tell you the members

[19:50] <diakopter> (and the first member will contain the "Type")

[19:50] <diakopter> in its name

[19:50] <mberends> ok, thanx :)

[19:50] <diakopter> then you can descend each of the members if you want

[19:50] <diakopter> incl .eval_args

[19:51] <mberends> I saw you sometimes descending M.M.M.M etc - confusing!

[19:51] *** pdcawley left
[19:51] *** pdcawley_ is now known as pdcawley

[19:51] <diakopter> yeah

[19:52] <mberends> I did try 'this.keys' but that b0rked

[19:52] <diakopter> those highly particularized/tailored paths are usually specific to some pattern of reduction/match, and will of course need to be further generalized as the implementation discovers different varieties of match patterns

[19:53] <moritz_> rakudo: say sqrt(-4 + 0i)

[19:53] <p6eval> rakudo c8181a: OUTPUT«0+2i␤»

[19:54] <mberends> diakopter: yes. shall I add radix.t to 'make -f sprixel.mk spectest'?

[19:54] <diakopter> sure :)

[19:54] <diakopter> it dies at test 86 or something

[19:54] <diakopter> 87

[19:55] <mberends> hence the question, do you expect the death to be temporary?

[19:55] <diakopter> oh

[19:55] <diakopter> no, but nor do I expect otherwise.  I don't know

[19:56] <mberends> spectest should lock in what has been passed, I was being too hasty

[19:56] <diakopter> oh

[19:57] *** Lorn left
[19:57] *** Lorn joined
[19:59] <Tene> masak: you has IM?

[19:59] *** zerhash joined
[20:05] <colomon> moritz_: Just pushed working exp.  exp.t now passes, ** should work, I suspect a spectest will give us much more interesting results now.

[20:06] <moritz_> colomon: and I pushed a (partially working) move of sqrt to the setting

[20:08] <moritz_> $ ./perl6 -e 'say (-4+0i).sqrt'

[20:08] <moritz_> 0 + 2i

[20:09] <moritz_> though misteriously the sub form still fails

[20:11] <mberends> sprixel: say "V8 " x 8

[20:11] <p6eval> sprixel 28505: OUTPUT«V8 V8 V8 V8 V8 V8 V8 V8 ␤»

[20:12] <diakopter> neet

[20:12] <diakopter> sprixel: say 8 x "V8"

[20:12] <p6eval> sprixel 28505: OUTPUT«␤»

[20:12] <diakopter> heh

[20:12] *** stephenlb left
[20:12] <moritz_> do you have lists yet?

[20:13] <diakopter> yeah a teeny bit

[20:13] <diakopter> sprixel: my @a = 1,2,3; say @a;

[20:13] <p6eval> sprixel 28505: OUTPUT«123␤»

[20:13] <diakopter> see, sorta

[20:13] *** stephenlb joined
[20:13] <diakopter> array, anyway

[20:14] <moritz_> sprixel: my @a = 1,2,3; say @a[1]

[20:14] <p6eval> sprixel 28505: OUTPUT«execute(): execute error:

[20:14] <p6eval> ..sigil,name,context,value,WHAT,set,toString,increment,decrement,do_Additive,do_Multiplicative,toBool,do_infix__S_Lt,do_infix__S_LtEqual,do_infix__S_Gt,do_infix__S_GtEqual,do_infix__S_EqualEqual,do_infix__S_BangEqual,do_infix__S_lt,do_infix__S_le,do_infix__S…

[20:14] * diakopter doesn't know what that would do

[20:18] <diakopter> in sprixel, I mean. :)

[20:19] <moritz_> call method postcircumfix:<[ ]> on the Array object? ;-)

[20:19] <moritz_> oh wait, you don't have methods yet

[20:19] <moritz_> no methods, no cookies

[20:21] <diakopter> moritz_: ok, I'm persuaded.. but what about a partial-fudging... that is, only certain files (the ones that even work at all)

[20:22] *** ruoso left
[20:23] <moritz_> diakopter: sure, that's basically what rakudo does

[20:23] <moritz_> diakopter: there's a list of files in t/spectest.data that are supposed to pass (when run through fudge)

[20:23] <diakopter> oh ok

[20:24] <diakopter> maybe mberends or anyone else wants to tackle enabling that?

[20:26] <diakopter> :)

[20:26] <mberends> diakopter: maybe :)

[20:28] <mberends> the Rakudo t/harness script would need a bit of a rewrite, then I thought it would be better to specify the fudging outside of the test files themselves (somehow, I have the beginnings of a plan)

[20:29] <moritz_> mberends: the accuracy of meta data is inversely proportional to the distance of data and meta data

[20:29] <moritz_> mberends: if you keep the fudging outside, and somebody changes the test, the fudging will break.

[20:29] <masak> meta data is just pretentious normal data. :)

[20:29] <diakopter> I'm almost tempted to instead mark the tests that *do* pass

[20:30] <diakopter> with what revision they started passing

[20:30] <moritz_> diakopter: won't work easily for tests that depend on other code to run first

[20:31] * diakopter runs spec/S03-operators/arith.t

[20:33] <cj> Trey: what's the name of your perl module that does rollbacks?

[20:34] * cj notes that he is OT again

[20:37] <masak> hugme: hug cj

[20:37] * hugme hugs cj

[20:39] *** cst2703 joined
[20:40] *** cst2703 left
[20:40] *** cst2703 joined
[20:41] <Trey> cj: Commands::Guarded

[20:41] <cst2703> hi there

[20:41] <mberends> moritz_: I'm against the current implementation of fudging for the long term, because it pollutes the P6 specification with the deficiencies of poor implementations. I'm thinking of a way to anchor the fudging to the TAP calls (ok, is etc). Admittedly it separates the spec from the fudge, but by just a small distance. I'd like to try anyhow, and if nothing comes of it, at least I'll learn not do it that way ;)

[20:42] <masak> cst2703: hi there! welcome to #perl6.

[20:42] <mberends> hi cosimo

[20:42] *** pyrimidine left
[20:42] <moritz_> mberends: looking at TAP output doesn't help with the problem that skip() solves

[20:43] <mberends> TAP input: still fudge, but annotating outside the file.t

[20:43] <moritz_> hm

[20:43] <moritz_> mberends: if you come up with a good solution I'm happy to try it out

[20:44] <cst2703> masak: i just read your blog post on use.perl about Squerl. COOL!

[20:45] <masak> cst2703: thanks. :)

[20:45] <cst2703> i can has?

[20:45] <masak> cst2703: go right ahead.

[20:45] <masak> I look forward to someone else using it.

[20:48] <cst2703> masak: where is it?

[20:48] <masak> cst2703: in the Web.pm repo.

[20:49] <cst2703> ok

[20:50] <cj> thanks Trey :)

[20:50] <pmichaud> mberends: why does fudging "pollute the p6 specification?"  The test files are still valid Perl 6, even with the fudge markers present.  :)

[20:50] <pmichaud> and it's semi-trivial to grep -v the '#?' lines

[20:51] *** cst2703 left
[20:52] <pmichaud> I agree that perhaps the test files don't look as "clean" as they otherwise might, but it's very easy to produce "clean" ones whenever we want them.

[20:52] <mberends> pmichaud: fudging looks so hacky, and the t/spec repo is our "official" suite

[20:53] <pmichaud> mberends: even the p5 suite has skips and todos :)

[20:53] <mberends> so I don't like that either :)

[20:53] <pmichaud> :)

[20:54] <mberends> I believe a more elegant approach can work, and I'll try to write a P6 based harness to demonstrate

[20:54] <TimToady> I think fudging is great motivation to make the tests pass :)

[20:54] <mberends> heh

[20:55] <TimToady> and good for competition :)

[20:56] <TimToady> and it's very clear if you're cheating

[20:56] <TimToady> if the cheats are hidden, then they can be done secretly

[20:57] <mberends> hmm, interesting food for thought...

[20:57] <masak> the previous Temporal synopsis was overspecific. I find that the current one makes the reverse mistake in places. "=item formatter\n\nThe object that will stringify this specific object." yes, and what default does it provide?

[20:57] <masak> and what's the API for the formatter, and the base class/role?

[20:58] <mberends> masak: you noticed too! I thought the vagueness was our chance to go crazy!

[20:58] <masak> I guess it is.

[20:58] <masak> I'm in ur Temporal.pod, goin crazy.

[20:58] <mberends> go man go!

[20:59] <mberends> btw, are all the authors listed at the top signed up to the current revision?

[21:00] <masak> I don't understand the question?

[21:00] <masak> s/\?/./

[21:00] <cosimo> masak: about Squerl again, sorry, going back and forth, what SQLite3.pm are you using?

[21:01] <masak> cosimo: the one in perl6-sqlite.

[21:01] <cosimo> weird, that didn't work for me

[21:01] <masak> cosimo: the dependencies are listed in deps.proto in Web.pm.

[21:01] <masak> cosimo: in what way didn't it work?

[21:02] <masak> the first =head1 says 'Roles', and then there's no 'Classes' in the whole Temporal.pod. surely that's wrong?

[21:02] * masak renames it 'Classes' until he hears loud protests

[21:02] <mberends> masak: I followed the debate leading to the current revision, which changed huge parts, but most of the authors listed did not participate this time around.

[21:03] <masak> mberends: I'm not sure I feel empowered to remove authors.

[21:03] <mberends> masak: the previous version was also role-centric. The roles pun into classes when required.

[21:03] <cosimo> masak: sqlite-test.pl died on SQLite3::open()

[21:04] <cosimo> masak: I don't remember right now the exact error message, but I think can reproduce it

[21:04] <masak> mberends: forgive me if I don't immediately see the benefit of that.

[21:04] <mberends> masak: absolutely, each author should decide individually whether to participate.

[21:05] <masak> cosimo: I haven't run sqlite-test.pl in a while.

[21:05] <masak> but I know the Squerl tests all pass.

[21:05] <pugs_svn> r28506 | lwall++ | [S06,S11] kill infix:<defines>, replace with statement_control:<import> 

[21:05] <mberends> masak: I don't see the benefit either, but that's the way it was. The implementation didn't suffer (too much).

[21:06] <masak> mberends: I stand by my change s/Roles/Classes/. if someone feels they should be roles, they can explain why first. :)

[21:06] <pugs_svn> r28507 | lwall++ | [STD] replace defines with import 

[21:07] <Tene> masak: gf has a sketch; she's going to scan and work on it more tonight, she says.

[21:07] <mberends> masak: no objection

[21:07] <masak> mberends: then I get either a saner spec or a good explanation.

[21:07] <masak> Tene: cool!

[21:09] <mberends> masak: the author I'd like to hear from most is Dave Rolsky, because his experience with the P5 DateTime.pm would be very valuable.

[21:09] <masak> indeed.

[21:11] <masak> I have a slight inclination to do s/DateTime/Time/, for esthetic and Huffman reasons. Ruby seems to do fine calling an equivalent object Time.

[21:11] <masak> but I'll hold back for now.

[21:13] * Tene inclined to s/DateTime/Cookies/, 'cos kinda hungry

[21:13] <masak> :)

[21:14] <masak> we're trying to have a serious d... did you say cookies?

[21:14] *** szabgab left
[21:15] <mberends> one of the catalysts for this revisionizing was frettled++ fretting about leap seconds and the difference between TAI and UTC. Are we going to address that in Perl 6 land, or in Parrot?

[21:16] <pmichaud> Perl 6 land, likely

[21:16] <masak> it will be fun!

[21:16] <mberends> fsvo fun :/

[21:16] <pmichaud> I mean, Parrot might address it there also, but somehow I doubt it.  Regardless, it'll be nice if we have the Perl 6 stuff in place to address it

[21:16] <pmichaud> (for other implementations not based on Parrot)

[21:17] <mberends> ok

[21:17] <masak> Let's Do The Time Warp Again!

[21:17] <mberends> :)

[21:18] <moritz_> ;-)

[21:18] <pmichaud> it would also be good to have some p6 code that we can point to when people say "tai wtf?"

[21:18] *** icwiener joined
[21:23] <PerlJam> masak: regarding s/DateTime/Time/, I say go for it.

[21:24] <PerlJam> DateTime makes me think it's implying something about the calendaring system.

[21:25] <diakopter> TimToady: the ast for the following is incomplete:

[21:25] <diakopter> std: /i/

[21:25] <p6eval> std 28507: OUTPUT«ok 00:01 95m␤»

[21:25] <moritz_> OMG I HAZ BLOGGED: http://perlgeek.de/blog-en/perl-6/lots-of-momentum.html

[21:27] <diakopter> rakudo: say /i/

[21:27] <lisppaste3> moritz_ pasted "test summary in the native-complex branch" at http://paste.lisp.org/display/87918

[21:27] <p6eval> rakudo c8181a: OUTPUT«_block50␤»

[21:27] <masak> OMG, Temporal.pod specified year-of-week! srsly!

[21:28] <PerlJam> heh

[21:29] <masak> moritz_++ # a fine post of blog indeed

[21:34] <mberends> moritz_++ # we live in exciting times

[21:34] <mberends> masak: week-of-year is ISO8601, but what does year-of-week mean?

[21:35] <masak> mberends: it means that no-one ever reads Temporal.pod :/

[21:35] <masak> except when they want to change it, like me.

[21:37] <masak> mberends: this is what I have so far: http://github.com/masak/temporal-flux-perl6syn/commit/8fc19a39d470b013b61eb0daa08ca82edd541371

[21:37] <frettled> mberends: Thanks, but I like to think of my self as frettling, not fretting.  ;)

[21:37] <masak> I'll make another, similar one for Gregorian::Duration.

[21:38] <PerlJam> masak++

[21:38] <mberends> frettled: I'll remember that

[21:38] <frettled> hee-hee

[21:38] *** PacoLinux left
[21:38] <frettled> I don't know what to frettle means, though.

[21:39] <mberends> frettled: you may spec it, implement it and copyright it

[21:39] *** PacoLinux joined
[21:39] <frettled> and then eat some cake

[21:40] <mberends> I thought some might have frettled you in the past

[21:40] <mberends> *someone

[21:42] <frettled> :)

[21:42] <frettled> masak: FWIW, s/DateTime/Time/ seems sensible enough.  Less typing, no loss.

[21:42] *** hercynium joined
[21:43] <masak> frettled: I'll count that as one vote and stand by for a while longer.

[21:44] <frettled> Hmm, Temporal.pod has had a few changes since last I had time (pun intended).

[21:44] * mberends hesitates to vote. Date is date-only, Time is time-only, DateTime is both. Ok, vote against.

[21:45] <frettled> Well, that's one way to look at it.

[21:46] <mberends> timtowtlai

[21:46] <frettled> Another is to say that Time is the superset, Date is a specific subset of Time, TimeOfDay is another subset.

[21:46] <moritz_> colomon: Complex.new($.re.Num.exp * $.im.Num.cos, $.re.Num.exp * $.im.Num.sin); - is that correct? I somehow can't see how it would...

[21:47] <frettled> I think that it's a little bit problematic - but only a little bit - that specifications etc. say «time» when the meaning is «time of day».

[21:47] <mberends> the bikeshed is over there...

[21:47] <frettled> haven't got the time ;)

[21:48] <mberends> lol

[21:49] *** Whiteknight joined
[21:51] <frettled> Hmm, so the current draft of S32/Temporal only allows TAI seconds as input, references an epoch of some kind, but doesn't say what that epoch is.

[21:52] <frettled> I suspect that it would be natural to use the point in time when TAI and UT2 were in sync, 1958-01-01 00:00:00.000

[21:53] <frettled> in which case, it would also be natural to add sugar to handle the 32-bit Unix epoch 1970-01-01 00:00:00 UTC, since people are still quite fond of that.

[21:54] <frettled> Oooh, neat, there's a module on CPAN for lots of this stuff: Time::UTC

[21:54] <frettled> (and Time::TAI and and and)

[21:54] <frettled> Andrew Main has done quite a bit of work on this.

[21:55] <mberends> frettle: verb 1. to change one's mental state from calm competence to progressively worse confusion; 2. to impose that state change on others

[21:55] <frettled> lovely!

[21:55] <masak> mberends: next load: http://github.com/masak/temporal-flux-perl6syn/commit/7e57a04f0a42688f6c87ac3fc5b74ba8e67f70b4

[21:55] *** tak11 joined
[21:56] <mberends> I am frettled

[21:56] <masak> mberends: I'm done now.

[21:56] * mberends reloads

[21:56] *** FCO joined
[21:56] *** SmokeMachine left
[21:56] <masak> let's spend the rest of the week writing spectests and Rakudo implementation! :)

[21:56] <mberends> can it be done with 2.5 tuits?

[21:57] <frettled> are those metric tuits or imperial?

[21:57] <masak> if you just nibble on them each time, yes.

[21:57] <colomon> moritz_: what are you questioning there?

[21:57] <masak> .oO( unladen tuit )

[21:57] <colomon> I'm pretty sure the math is correct, unless a typo has snuck in.

[21:57] <frettled> masak++

[21:57] <moritz_> colomon: the mathematical correctness - it's not obvious to me where it comes from

[21:58] <colomon> moritz_: complex exp and trig functions are all tied together.

[21:58] <masak> sleep &

[21:58] <moritz_> colomon: that much I know ;-)

[21:58] <colomon> http://en.wikipedia.org/wiki/Exponential_function#Computation_of_ez_for_a_complex_z

[21:59] *** masak left
[21:59] <colomon> is where I got it from.  :)

[21:59] <frettled> masak: I concur, but allow me to amend it a little bit:  sleep(3600*7.5)

[21:59] <colomon> exp.t passes with it, but probably isn't thorough enough to be really confident.  :)

[21:59] <frettled> g'night, I'll try to be a good boy and do something useful this week

[21:59] <moritz_> colomon: eek, it's so simple ;-)

[21:59] <frettled> (besides, tomorrow night is blogging night again ;)

[22:00] <moritz_> colomon: thanks for the link

[22:00] <colomon> moritz_: math is beautiful.   8) 

[22:00] <moritz_> unless when it's not

[22:00] *** |theJackal| joined
[22:00] <moritz_> and your Green's functions all have major poles

[22:01] <moritz_> and you have to resolve to all sorts of trickery

[22:02] <moritz_> colomon: just pushed a fix for .sqrt which in turn also fixed .abs on Complex

[22:03] <moritz_> and by the same token is_approx

[22:03] <colomon> \o/

[22:03] <moritz_> arith.t and perl.t pass again

[22:03] <moritz_> as well as the integration tests

[22:03] <colomon> you haven't fixed complex division, have you?

[22:03] <moritz_> just 11 files left

[22:04] <moritz_> colomon: no

[22:04] <colomon> yeah, we definitely need to add tests for Complex.  :)

[22:05] <moritz_> there are basically two ways we can implement infix:</>

[22:05] <moritz_> one is via inline PIR

[22:05] <moritz_> the other is to do the basic math in Perl 6

[22:05] <colomon> It's a reasonably simple formula.

[22:06] *** mberends left
[22:06] <moritz_> aye

[22:06] <moritz_> I think I'll go for it

[22:07] <colomon> rakudo

[22:07] <colomon> rakudo: my $x; $x = $x + 1i; say $x;

[22:07] <p6eval> rakudo c8181a: OUTPUT«Use of uninitialized value␤0+1i␤»

[22:10] <moritz_> comples division pushed (untested)

[22:10] <moritz_> that was a mistake ;-)

[22:10] <moritz_> oh wait

[22:10] <moritz_> just didn't finished compiling yeet ;-)

[22:11] <moritz_> at least Complex / Real works ;-)

[22:13] *** iblechbot left
[22:15] <moritz_> and Real / Complex too

[22:17] *** ascent_ left
[22:17] <moritz_> ok, Complex / Complex also works now. Bed time here.

[22:18] <colomon> moritz_++

[22:18] *** kent\n left
[22:20] <colomon> rakudo: say 1i == 1i;

[22:20] <p6eval> rakudo c8181a: OUTPUT«1␤»

[22:20] <colomon> rakudo: say 1i == 1;

[22:20] <p6eval> rakudo c8181a: OUTPUT«1␤»

[22:21] <colomon> ah, the suck of Rakudo's complex handling.

[22:21] <moritz_> easy to fix in the setting - by adding hundreds of multis ;-)

[22:22] *** ascent_ joined
[22:24] <colomon> rakudo: my $x; $x *= 1i; say $x;

[22:24] <p6eval> rakudo c8181a: OUTPUT«0+1i␤»

[22:24] <colomon> that there is crazy.

[22:25] <moritz_> but it's a good way to be crazy

[22:25] <pugs_svn> r28508 | colomon++ | [t/spec] Change complex tests to use is_approx rather than ==. 

[22:25] <moritz_> undef is interpreted as the neutral element of the operation

[22:25] <colomon> It figures out to autovivify as 1 if you're multiplying and 0 if you're adding.

[22:26] <colomon> I assume the zero-argument operators are involved somehow...

[22:26] <colomon> So, autovivification.t works with those changes to the test.

[22:30] *** icwiener left
[22:34] <colomon> Just pushed a fix to make minmax.t work.

[22:37] *** KyleHa left
[22:40] *** nihiliad left
[22:42] *** jauaor left
[22:45] <moritz_> not quite in bed... made log10 working (and pushed)

[22:53] *** nErVe joined
[23:09] *** nErVe left
[23:15] *** clintongormley left
[23:22] *** arthur-_ left
[23:26] *** ihrd joined
[23:27] *** ihrd left
[23:27] *** FCO left
[23:32] *** cdarroch left
[23:40] *** meppl left
[23:41] *** patspam joined
[23:42] *** patspam1 joined
[23:42] *** patspam left
[23:42] *** ruoso joined
[23:49] <diakopter> zipadeedoodah

[23:50] *** TiMBuS joined
