[00:17] *** donaldh left
[00:18] *** donaldh joined
[00:34] *** |jedai| left
[00:35] *** |jedai| joined
[00:40] *** DemoFreak left
[00:48] *** [particle] joined
[00:53] *** [particle]1 left
[01:06] *** Chillance left
[01:24] <pugs_svn> r24967 | putter++ | [elf] Added Str::hex, Int::chr.

[01:24] <pugs_svn> r24967 | putter++ | [elfparse] Added "\xNNNN" escapes, and std.pm's %open2close.

[01:38] *** jhuni left
[01:39] *** jhuni joined
[01:40] *** meppl joined
[01:45] *** |jedai| left
[01:45] *** aindilis joined
[01:45] *** |jedai| joined
[01:51] *** hcchien_ joined
[01:52] *** hcchien left
[01:54] *** spx2 left
[01:57] *** justatheory left
[01:59] *** aindilis` joined
[01:59] *** spx2 joined
[02:10] *** |jedai| left
[02:10] *** |jedai| joined
[02:10] <melkonem> whose worked on scala

[02:17] <melkonem> anyone awake

[02:20] *** aindilis` left
[02:22] *** alc joined
[02:24] *** aindilis left
[02:28] *** melkonem left
[02:36] <s1n> what kind of method is :by()? are there other methods like it?

[02:38] *** |jedai| left
[02:40] *** |jedai| joined
[02:52] *** wknight8111 left
[02:59] *** |jedai| left
[03:00] *** |jedai| joined
[03:00] <pugs_svn> r24968 | putter++ | [elfparse] Aliases in elfgreen; some alias p6-ification; <sym>.

[03:01] *** jhorwitz left
[03:08] *** stephenlb left
[03:09] *** [particle]1 joined
[03:09] *** jhuni left
[03:17] *** [particle] left
[03:17] <s1n> anyone know anything about methods like :by()?

[03:17] *** meppuru joined
[03:22] *** aindilis joined
[03:33] *** meppl left
[03:34] *** alester_ joined
[03:44] *** alc left
[03:52] *** hcchien_ is now known as hcchien

[04:01] *** gravity left
[04:20] <rakudo_svn> r35787 | chromatic++ | [ops] Removed n_abs, n_bnot, n_bnots, and n_not opcodes; cleaned up langauges

[04:20] <rakudo_svn> r35787 | chromatic++ | which use them.  See RT #58410.

[04:24] *** alester_ left
[04:25] *** alester_ joined
[04:29] *** tmaesaka left
[05:01] *** justatheory joined
[05:04] *** justatheory left
[05:09] *** meppuru is now known as meppl

[05:09] *** justatheory joined
[05:25] <pugs_svn> r24969 | putter++ | [src/perl6/STD.pm] Converted tabs to spaces. (emacs M-x untabify)

[05:28] *** [particle] joined
[05:32] <pugs_svn> r24970 | putter++ | [elfparse] std.pm synced with current STD.pm.

[05:33] *** [particle]1 left
[05:43] *** stephenlb joined
[05:57] *** |jedai| left
[05:58] *** |jedai| joined
[06:00] *** donaldh left
[06:00] *** donaldh joined
[06:11] *** iblechbot joined
[06:13] *** justatheory left
[06:18] *** |jedai| left
[06:18] *** |jedai| joined
[06:33] <szabgab> s1n: I just recently looked at :by() adverbs, they were not implemented in rakudo a few days ago

[06:34] <szabgab> std: for 1..5:by(2) -> $i { say $i }

[06:34] <p6eval> std 24970: OUTPUT«00:05 87m␤»

[06:34] <szabgab> pugs: for 1..5:by(2) -> $i { say $i }

[06:34] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ":by"␤    expecting "_", fraction, exponent, term postfix, operator or block construct␤    at /tmp/TFeJjGekEw line 1, column 9␤»

[06:35] <szabgab> rakudo: for 1..5:by(2) -> $i { say $i }

[06:35] <p6eval> rakudo 35788: OUTPUT«Statement not terminated properly at line 1, near ":by(2) -> "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[06:43] <moritz_> rakudo: for Range.new(1, 5, :by(3)) { .print }

[06:43] <p6eval> rakudo 35788: OUTPUT«argument doesn't hash␤current instr.: 'parrot;Perl6Object;BUILD' pc 543 (src/classes/Object.pir:283)␤»

[06:51] *** ashizawa joined
[06:54] *** stephenlb left
[07:00] <rakudo_svn> r35789 | infinoid++ | [cage] Fix some codingstd failures.

[07:20] *** |jedai| left
[07:20] *** |jedai| joined
[07:21] *** Ehtyar joined
[07:41] *** jao left
[07:42] *** ejs joined
[07:45] *** _jedai_ joined
[07:45] *** |jedai| left
[07:49] *** [particle]1 joined
[07:52] *** smtms left
[07:58] *** vixey joined
[08:00] *** alester_ left
[08:05] *** DemoFreak joined
[08:08] *** [particle] left
[08:27] *** riffraff joined
[08:27] *** pbuetow joined
[08:31] *** _jedai_ left
[08:32] *** |jedai| joined
[08:36] *** pbuetow left
[08:55] *** |jedai| left
[08:56] *** |jedai| joined
[09:06] *** ejs left
[09:35] *** riffraff left
[09:45] *** schmalbe joined
[09:46] *** ejs joined
[10:09] *** [particle] joined
[10:15] *** vixey left
[10:23] *** ChrisDavaz joined
[10:27] *** [particle]1 left
[10:48] *** ChrisDavaz left
[11:01] *** |jedai| left
[11:02] *** |jedai| joined
[11:07] <jnthn> hi all

[11:25] *** zamolxes joined
[11:26] *** ruoso joined
[11:28] <ruoso> HellO!

[11:34] *** aindilis` joined
[11:48] *** aindilis left
[11:48] *** ashizawa left
[11:50] <rakudo_svn> r35796 | jonathan++ | [rakudo] Seems Test.pm was patched with extra features, but unfortunately that causes it to break on a few tests. This patch tweaks the workaround for some things not having a .perl method, which gets us passing pretty much everything again, aside from fail.t, which I'm really

[11:50] <rakudo_svn> ..not sure what is wrong with yet...

[12:01] *** Casan left
[12:06] *** ruoso_ joined
[12:08] *** ruoso left
[12:08] *** ruoso_ is now known as ruoso

[12:22] <pugs_svn> r24971 | jnthn++ | [rakudo] Unfudge test for using role parameter as type constraint, and add a few more for this.

[12:22] *** nnunley left
[12:23] *** pmurias joined
[12:23] <pmurias> hi

[12:29] *** pmurias left
[12:30] <rakudo_svn> r35798 | jonathan++ | [rakudo] newclosure clones, but the signature is lost during the clone since it's attached as a property. This re-instates it, which happily is all that's needed for role parameters to act as type constraints.

[12:30] *** [particle]1 joined
[12:38] <ruoso> hi pmichaud 

[12:38] <ruoso> hi pmurias 

[12:39] *** ejs left
[12:41] *** |jedai| left
[12:42] *** ejs joined
[12:42] *** |jedai| joined
[12:48] *** [particle] left
[13:00] *** _jedai_ joined
[13:00] *** |jedai| left
[13:01] *** aindilis` left
[13:01] *** aindilis` joined
[13:12] *** pmurias joined
[13:18] *** nothingmuch_ joined
[13:18] *** nothingmuch_ left
[13:19] *** ruoso_ joined
[13:19] *** nothingmuch_ joined
[13:19] *** ruoso left
[13:20] *** nothingmuch_ left
[13:23] *** ruoso_ is now known as ruoso

[13:24] <pugs_svn> r24972 | jnthn++ | [t/spec] Unfudge some .does tests for parametric roles.

[13:24] *** nothingmuch_ joined
[13:24] *** nothingmuch left
[13:25] *** nothingmuch_ is now known as nothingmuch

[13:25] *** Juerd left
[13:25] *** nothingmuch left
[13:25] *** nothingmuch joined
[13:29] <ruoso> pmurias, from now and then I consider doing a major refactor in SMOP splitting it in several different pieces...

[13:30] <rakudo_svn> r35799 | jonathan++ | [rakudo] Track what roles we have already created and re-use them appropriately. For example, every time you said does Foo[Int] before, it would have created a new Parrot role. Now it creates one and re-uses it. This means that .does(Foo[Int]) tests now work also.

[13:30] <ruoso> smop-base, which would contain only smop-base.h

[13:30] <ruoso> smop-native, which would contain only the native types

[13:30] <ruoso> (including idconst and native capture)

[13:31] <ruoso> smop-run, which would contain only the interpreter instance (but no interpreter implementation)

[13:32] <ruoso> smop-refcounting, which would contain lowlevel.sm0p with some other name

[13:32] <ruoso> (maybe bool and idconst should be in a different package, as they are not subject to garbage collection)

[13:34] <ruoso> smop-singleton, holding bool and idconst

[13:34] *** _jedai_ left
[13:34] <ruoso> smop-mold

[13:34] <ruoso> smop-pcl

[13:34] <ruoso> smop-p5

[13:34] <ruoso> and so on

[13:36] <ruoso> pmurias, somehow I think it would make our lifes easier

[13:37] *** |jedai| joined
[13:38] <ruoso> then we would need a package that would bundle all this into something useable, maybe that's the p5 binding SMOP.pm for instance... it could initialze all the stuff...

[13:40] *** pmurias left
[13:42] *** pmurias joined
[13:45] *** ZuLuuuuuu joined
[13:48] *** lambdabot left
[13:51] *** lambdabot joined
[14:03] *** SamB left
[14:04] <pugs_svn> r24973 | jnthn++ | [t/spec] More tests for punning a role into a class.

[14:06] *** |jedai| left
[14:06] *** |jedai| joined
[14:08] *** pmurias left
[14:09] *** SamB joined
[14:12] *** Exodist joined
[14:23] *** pmurias joined
[14:24] <pmurias> ruoso: you mean we should physically seperate the components?

[14:24] <ruoso> yeah...

[14:24] <ruoso> so we have a clearer view on the dependencies

[14:25] <pmurias> seems reasonable

[14:25] *** eric256 joined
[14:26] <ruoso> I was also thinking that we could have a "state machine" for some lowlevel operations that potentially need recursion

[14:26] <ruoso> so we don't make lowlevel.sm0p depend on mold

[14:29] <ruoso> this could also be used for some basic operations the native types need to do with the captures they receive

[14:30] <ruoso> (solving the $OUT problem, for instance)

[14:30] <rakudo_svn> r35806 | jonathan++ | [rakudo] Make a role pun a class when you call .new on it.

[14:30] <rakudo_svn> r35807 | jonathan++ | [rakudo] Add spectest for role punning/instantiation.

[14:30] <pmurias> a "state machine" won't be very hard to write by hand

[14:30] <ruoso> jnthn, I was wondering... shouldn't it pun a class on every invocation on a Role?

[14:31] <ruoso> pmurias, exactly, and it could be specific for each case, avoiding a lot of mallocs

[14:31] *** |jedai| left
[14:31] <ruoso> jnthn, is "new" really a special case?

[14:31] <pmurias> i'm wandering how efficient would a mold block compiled to one be

[14:31] *** |jedai| joined
[14:32] <jnthn> ruoso: We only discussed making .new work, as I remember it.

[14:32] <ruoso> jnthn, wasn't it because it was the example on hand?

[14:33] <jnthn> Not sure...

[14:33] <ruoso> what made me think that is that a role is a package declarator, and as a package declarator it has a HOW that is responsible for it... so we have a RoleHOW, as we have ClassHWO

[14:33] <jnthn> But I know that I sure want ACCEPTS on a role *not* to cause an instantiation.

[14:33] <ruoso> *ClassHOW

[14:33] *** ZuLuuuuuu left
[14:33] <jnthn> erm, a pun

[14:34] <ruoso> so basically, it would make sense that since a Role is represented by a p6opaque

[14:34] <ruoso> that the "pun" happens at "dispatch" time

[14:35] <ruoso> jnthn, you mean ACCEPTS as in $foo ~~ Array?

[14:35] <jnthn> Yes.

[14:35] <ruoso> jnthn, wasn't $foo ~~ Array expressed in terms of $foo.^does(Array)?

[14:35] <jnthn> I don't think type RHS is a special form.

[14:36] <pmurias> ruoso: what's our current ROADMAP towards getting &infix:<+>(int,int) to work?

[14:36] <ruoso> pmurias, loading Multi.pm

[14:37] <ruoso> spack: ACCEPTS

[14:37] <ruoso> buubot, spack ACCEPTS

[14:37] <buubot> ruoso: S03-operators.pod:17

[14:37] <jnthn> No, it's not.

[14:37] <jnthn> And it's $_.does(X)

[14:38] <jnthn> Thing is, if you're creating an instance and calling ACCEPTS on that you'd end up calling the ACCEPTS of the instance.

[14:38] <jnthn> Not of the proto.

[14:38] <jnthn> So I don't just saying "every method causes an instantiation" is going to work.

[14:38] <ruoso> but nobody is creating an instance

[14:38] *** nihiliad left
[14:38] <jnthn> Ah, you're saying we'd call it on the proto? Hmm.

[14:39] <jnthn> That still means we're doing the does test on the wrong thingy though.

[14:39] <ruoso> but you're not calling does on the proto

[14:39] <ruoso> you're calling does on the value

[14:39] <ruoso> passing the proto as argument

[14:40] <jnthn> role Foo { }; Foo.ACCEPTS($x); # Here, if we pun Foo, we are then calling ACCEPTS on the thing we get from punning the role, not on the role itself.

[14:40] <jnthn> And since $x probably doesn't do the class but does do the role, it'd give the wrong answer.

[14:41] <ruoso> right... but...

[14:41] * ruoso re-re-re-reading the spec

[14:43] <eric256> does feather have rakudo running and updated on it? wanted to use it to test stuff on, but didn't want to take up the space to download and make rakudo if its already on there

[14:45] <jnthn> Hmm. The section under =head1 Autovivifying objects

[14:45] <jnthn> Suggestions you may be able to call anything.

[14:45] <jnthn> But doesn't deal with the ACCEPTS issue.

[14:46] <ruoso> somehow I always read the ACCEPTS thing as a fallback to that table

[14:46] *** riffraff joined
[14:46] <ruoso> but that table would be implemented directly as-is

[14:46] <pmurias> ruoso: prepending ::MildewSOLoader.new.load('Prelude.mildew.so',$LexicalPrelude.FETCH); at the top of each program would work

[14:47] <jnthn> No, only the first batch of entries are dispatched on the form and the rest are via ACCEPTS.

[14:47] <riffraff> hi

[14:47] <pmurias> riffraff: hi

[14:47] <ruoso> jnthn, the first batch contains Any ~~ Type

[14:47] <jnthn> huh?

[14:48] <jnthn> You looking at http://svn.pugscode.org/pugs/docs/Perl6/Spec/S03-operators.pod ?

[14:48] <jnthn> The first section contains privileged syntax; if a match can be done

[14:48] <jnthn> via one of those entries, it will be.   These special syntaxes are

[14:48] <jnthn> dispatched by their form rather than their type.

[14:49] <ruoso> jnthn, I'm looking at that file, line 2960

[14:49] <jnthn>     Any       Type      type membership         $_.does(X)

[14:49] <jnthn> That one?

[14:49] <ruoso> yes

[14:49] <jnthn> That's not in the first section.

[14:50] <jnthn> The first group of them ends with Any       .<...> 

[14:50] <ruoso> er...

[14:51] *** [particle] joined
[14:52] <ruoso> jnthn, you really surprised me on that one...

[14:52] <jnthn> ruoso: I can't see how it could be any other way, since all of the things on the RHS below that point could be in a scalar.

[14:53] <jnthn> So we don't have a syntactic form to go by.

[14:53] <ruoso> what about is_type?

[14:53] <ruoso> since Type is not really a type

[14:54] *** ejs left
[14:54] <jnthn> It perhaps means "anything that does Abstraction"

[14:54] <jnthn> Which is what I've generally taken type to mean in Perl 6.

[14:55] <ruoso> I don't know... but I think there's no much meaning in the extra newline after the Any .<...> line

[14:56] <ruoso> pmurias, you could try instantiating a Multi then, and adding the variant you want...

[14:56] <jnthn> Well, we're best off just asking for answers to this stuff than guessing it...

[14:56] <ruoso> indeed... TimToady?

[14:56] <jnthn> For now, having .new at least do a pun will get me enough for now.

[14:57] <ruoso> fair enough... but this issue will be very much important for SMOP, because the RoleHOW.dispatch is the one creatign the pun, and I don't think it is a good idea for it to intercept ACCEPTS

[14:58] <jnthn> Right.

[14:58] <jnthn> We'd have to similarly special-case ACCEPTS in Rakudo too.

[14:58] <jnthn> Which doesn't feel greatly neat.

[14:59] <pmurias> ruoso: Multi doesn't have a .new

[14:59] <ruoso> oh right..

[14:59] <ruoso> in fact...

[15:00] <ruoso> I think it would be sane to implement Multi as a Role

[15:00] <ruoso> which means we need RoleHOW

[15:00] <ruoso> that implements the class pun at dispatch

[15:02] <jnthn> ruoso: That still doesn't handle the ACCEPTS issue.

[15:02] <ruoso> jnthn, I know... I still don't support smart match

[15:03] <jnthn> Ah, OK. ;-)

[15:04] <jnthn> I'll probably leave what I've got for now, until there's some clarification.

[15:04] <ruoso> pmurias, would you like to adventure yourself into RoleHOW?

[15:04] *** |jedai| left
[15:04] *** |jedai| joined
[15:07] *** [particle]1 left
[15:09] <ruoso> just a sanity check, but every punned class needs to declare that it is Object, right?

[15:09] <jnthn> ruoso: I think an Any

[15:09] <ruoso> right...

[15:09] <jnthn> so it's like a class Foo does TheRole { }

[15:10] <jnthn> (class Foo { ... } inherits for Any by default.)

[15:10] <ruoso> what about class Object {...} ?

[15:10] <jnthn> erm, *from*...

[15:10] <ruoso> heh

[15:10] <jnthn> heh

[15:10] <jnthn> I would imagine that doesn't. ;-)

[15:11] <jnthn> Guess that is special in some way.

[15:12] <ruoso> it would be interesting to know in what way...

[15:12] <jnthn> I guess just that it doesn't have any parens.

[15:12] *** kane_ joined
[15:13] <jnthn> *parents

[15:13] <ruoso> right... but in terms of syntax

[15:13] * ruoso considering one could start a different type hierarchy at some point

[15:14] <ruoso> and also, if you want to implement something that works in the level of a Junction, for instance

[15:16] <jnthn> class Junction is Object { .. }

[15:16] <jnthn> I don't know that there is any syntax specially for saying "it has no parents"

[15:16] <jnthn> Maybe you could just do a trait?

[15:18] <ruoso> clas Object is nothing {...]

[15:18] <ruoso> class Object is nothing {...}

[15:18] *** jhorwitz joined
[15:18] * ruoso .oO(I think I'll enter the "how many typos you can get into a single line" contest)

[15:20] <ruoso> class Object isn't Any {...} ;)

[15:20] <jnthn> lol

[15:21] <moritz_> :)

[15:21] * moritz_ thinks of Acme::Don't

[15:21] <ruoso> you know... with all this "built-in types are roles" thingy...

[15:21] <ruoso> I realised how to solve the "defining undef" problem

[15:22] <ruoso> if all the built-in types are roles,

[15:22] <ruoso> Object is also a Role

[15:22] <ruoso> and when you call Object.BUILDALL

[15:22] <ruoso> it will pun a new class and build it all

[15:23] <ruoso> then you will never make Object defined

[15:24] <jnthn> Hmm...

[15:24] * jnthn tries to follow that logic...

[15:25] *** pmurias left
[15:25] *** kisu_ left
[15:25] *** kisu_ joined
[15:32] <ruoso> jnthn, if we do that and also define that when you try to do "class Foo is Role {...}" causes Foo to inherit from the punned class... we even make it more protected against action-at-a-distance

[15:33] <ruoso> since modifying a Class affects its descendants... but modifying a Role doesn't affect it's composed classes

[15:33] <jnthn> We so don't want to encourage people to do this...

[15:33] <ruoso> s/it's/its

[15:33] <ruoso> inheriting from Roles?

[15:33] <jnthn> Yeah

[15:33] <jnthn> Though that doesn't mean it shouldn't be possible.

[15:34] <jnthn> Though you'd be really inheriting from the punned class.

[15:34] <ruoso> yes... 

[15:34] <ruoso> and protecting from action-at-a-distance indeed looks like an interesting feature

[15:35] <jnthn> Provided folks can't lay their hands on the punned class and is also it ;-)

[15:36] <ruoso> if they can, they need to get a private copy...

[15:36] <ruoso> the punned-class-sharing is an optimization that needs to be aware of that

[15:38] <jnthn> :-|

[15:38] <jnthn> Not sure I like that idea.

[15:38] <jnthn> How would we know if people were going to do changes later?

[15:38] <jnthn> Anyway, I can't think of a way you'd syntactically do it.

[15:38] <jnthn> So it's probably a non-issue.

[15:39] <ruoso> but if this issue raises, you'll need some form of COW

[15:39] <jnthn> We'll not raise it, because it's hard. ;-)

[15:40] <jnthn> (Plus if people *really* want to shoot themselves in the foot that badly...)

[15:40] * Matt-W mops brains off his monitor after reading the latest topic of discussion

[15:41] *** _jedai_ joined
[15:43] *** |jedai| left
[15:49] <ruoso> so, should I consider it is sane to think as:

[15:49] <ruoso> role Object { }

[15:50] <rakudo_svn> r35812 | pmichaud++ | [rakudo]: spectest-progress.csv update: 292 files, 6280 passing, 171 failing

[15:50] <rakudo_svn> r35812 | pmichaud++ | Failure summary:

[15:50] <rakudo_svn> r35812 | pmichaud++ |     S04-exceptions/fail.rakudo 1 - 42

[15:50] <rakudo_svn> r35812 | pmichaud++ |     S04-exceptions/fail.rakudo 3 - fail() causes our sub to return (1)

[15:50] <rakudo_svn> r35812 | pmichaud++ |     S12-attributes/delegation.rakudo aborted 41 test(s)

[15:50] <rakudo_svn> r35812 | pmichaud++ |     S12-class/anonymous.rakudo aborted 3 test(s)

[15:50] <rakudo_svn> r35812 | pmichaud++ |     S12-role/basic.rakudo aborted 3 test(s)

[15:50] <rakudo_svn> r35812 | pmichaud++ |     S29-str/chomp.rakudo aborted 14 test(s)

[15:50] <rakudo_svn> r35812 | pmichaud++ |     S29-str/unpack.t aborted 2 test(s)

[15:50] <rakudo_svn> r35812 | pmichaud++ |     integration/99problems-31-to-40.rakudo aborted 65 test(s)

[15:50] <rakudo_svn> r35812 | pmichaud++ |     integration/99problems-51-to-60.t aborted 37 test(s)

[15:50] <rakudo_svn> r35812 | pmichaud++ |     integration/say-crash.t aborted 4 test(s)

[15:51] <jnthn> ruoso: Not sure, trying to work through the implications of that...

[15:51] * ruoso lunch &

[15:51] <jnthn> The undefinedness comes through it being a proto, as I understood things..

[15:52] <ruoso> jnthn, sure... but the problem is that you can call methods on undefined values

[15:53] <ruoso> as well as in protos

[15:53] <ruoso> the problem is that one of those methods is the thing that turns undef into defined

[15:53] <ruoso> which is called during "new"

[15:53] <ruoso> more precisely, during "bless"

[15:54] <pmichaud> that confuses me.

[15:54] <jnthn> I think in Rakudo we see proto as being like an instance of the object that has proto-ness mixed into it.

[15:54] <pmichaud> the "turns undef into defined" part confuses me.

[15:54] <jnthn> (Or put another way, I don't really see the problem you're trying to solve...)

[15:54] <pmichaud> me either.

[15:54] <ruoso> pmichaud, take a look at ClassHOW.pm in smop/src-s1p

[15:55] <pmichaud> please don't make me look at code and try to figure out what you're saying.

[15:55] <ruoso> looking at code might be easier than looking at the spec ;)

[15:55] <ruoso> but anyway

[15:55] <pmichaud> I have to even find where smop is.

[15:55] <ruoso> pugs repo/v6/smop

[15:56] <ruoso> the process of creating a new object goes by:

[15:56] <ruoso> .new 

[15:56] *** _jedai_ left
[15:56] <ruoso> new calls CREATE and bless

[15:56] <jnthn> pmichaud: http://svn.pugscode.org/pugs/v6/smop/src-s1p/ClassHOW.pm

[15:57] <ruoso> CREATE is separated from new so you can send the :repr parameter

[15:57] <ruoso> and choose a different representation for your object

[15:57] <pmichaud> yes, I know this -- rakudo has a similar sequence.

[15:57] <ruoso> bless accepts a candidate object and turns it into a instance of the invocant prototype

[15:57] <pmichaud> =item method bless($how: $prototype, $candidate, *@protoobjects, *%initialize)

[15:57] <pmichaud> that looks wrong to me, at least according to the spec.

[15:57] <pmichaud> the prototype is the invocant.

[15:58] *** |jedai| joined
[15:58] <ruoso> pmichaud, ClassHOW is the HOW, it's not Object.pm

[15:58] <ruoso> that's why it has $how: as invocant

[15:58] <pmichaud> okay

[15:58] <ruoso> if you look at Object.pm in the same directory

[15:59] <ruoso> so, bless is the one that calls BUILDALL

[15:59] <ruoso> BUILDALL is a regular method

[15:59] <ruoso> that can be overriden

[15:59] <pmichaud> ruoso: I know this part.

[15:59] <pmichaud> I understand bless, BUILDALL, BUILD, CREATE, etc.

[15:59] <ruoso> right...

[15:59] <ruoso> so

[16:00] <ruoso> if you call Object.BUILDALL

[16:00] <ruoso> you're asking Object to be built

[16:00] <ruoso> it's the same as doing $some_undefined_value.BUILDALL

[16:00] <ruoso> there's no way to tell if the undef is supposed to be a class

[16:00] <ruoso> or if it's just something that wasn't yet initialized

[16:01] <pmichaud> "the undef is supposed to be a class" doesn't make sense to me.

[16:01] <pmichaud> $some_undefined_value still has a type.

[16:01] <pmichaud> its type isn't "undef".

[16:01] <ruoso> $some_undefined_value := Object; 

[16:02] <pmichaud> in that case it's exactly identical to Object.BUILDALL

[16:02] <pmichaud> Object already knows its own type

[16:02] <ruoso> which is "Object"

[16:03] <ruoso> so, if the BUILDALL method turns the invocant into a defined value

[16:03] <pmichaud> it doesn't.

[16:03] <pmichaud> at least, that's not how I read it.

[16:03] <pmichaud> let me check.

[16:03] <ruoso> someone needs to

[16:05] <pmichaud> Object.new calls .bless

[16:05] <jnthn> ruoso: I kinda don't get the issue. A proto is an instance of the class with some special behaviours. Creating a new instance of the class wouldn't create another proto though.

[16:05] <jnthn> It'd create an instance.

[16:05] <ruoso> jnthn, right... I got what the problem is...

[16:05] *** eternaleye left
[16:05] <pmichaud> .bless calls .CREATE to create a candidate object .  That candidate object is "defined"

[16:05] <pmichaud> it's already defined at that point

[16:06] <ruoso> pmichaud, is that spec?

[16:06] <pmichaud> which part?

[16:06] <pmichaud> undefinedness is a property of protoobjects

[16:06] <ruoso> it being defined from the return of CREATE

[16:06] <pmichaud> I don't think it's speced to that detail, no.  But it works that way.

[16:06] <ruoso> pmichaud, undefinedness is a matter of the return of the "defined" method

[16:07] <pmichaud> it's also not speced that BUILD turns an undefined object into a defined one.

[16:07] <pmichaud> regardless, it doesn't seem to matter.

[16:07] <pmichaud> we get a candidate object, and we call BUILD on that object.

[16:07] <ruoso> pmichaud, autovivification makes that

[16:08] <ruoso> S12:682

[16:08] <ruoso> "The C<bless> function automatically calls all appropriate C<BUILD> routines by calling the C<BUILDALL> routine for the current class,which initializes the object in least-derived to most-derived order."

[16:09] *** vixey joined
[16:09] <pmichaud> I still don't understand the problem you're trying to solve.

[16:10] <ruoso> you don't see it because we disagreed wether CREATE should return something defined or not

[16:10] <pmichaud> no, even if CREATE returns an undefined object, I don't see the problem.

[16:11] <ruoso> if CREATE returns an undefined object, BUILDALL turns it into a defined object

[16:11] <ruoso> which means BUILDALL makes the invocant defined

[16:12] <pmichaud> I think the difference is whether CREATE returns a *typed* undefined object

[16:12] <ruoso> there's no such thing as untyped undef

[16:12] <pmichaud> okay, if we agree on that (we do)

[16:12] <pmichaud> then I really don't see the problem.

[16:12] <pmichaud> I don't see how definedness comes into play with what you're saying.

[16:13] <ruoso> do you assume that the Type and the Value have the same representation

[16:13] <ruoso> ?

[16:13] <ruoso> both "p6opaque" by default?

[16:14] <pmichaud> depends on what you mean by "type"

[16:14] <pmichaud> do you mean "protoobject"?

[16:14] *** ejs joined
[16:14] <ruoso> the protoobject is the thing we can refer to when talkign about the type

[16:14] <ruoso> in this case "Object"

[16:15] <pmichaud> okay, Object is a protoobject.

[16:15] <ruoso> and is a type

[16:15] <pmichaud> as such, it has the same representation as the values of that type.

[16:15] <ruoso> do you agree that Object.clone returns an identical undefined object

[16:15] <ruoso> ?

[16:16] <ruoso> but the namespace points the name "Object" to the first

[16:16] *** stephenlb joined
[16:17] *** spx2 left
[16:17] <pmichaud> I don't have a problem with Object.clone returning an identical undefined object, no.

[16:17] *** spx2 joined
[16:17] <ruoso> considering that... is there a fundamental difference between "Object.clone" and "Object.CREATE"? 

[16:17] <pmichaud> there can be, yes.

[16:17] <pmichaud> Object.CREATE creates a new object.  That's different from Object.clone, at least as I've been looking at it.

[16:18] <jnthn> ruoso: Are you basically saying that smop creates an instance by cloning the proto-object and then doing something to it to make it defined?

[16:18] <ruoso> Object.CREATE returns a new object, if it returns a defined value

[16:18] <ruoso> but it returns a protoobject, if we assume it returns an undefined value

[16:18] <ruoso> jnthn, that's what a "knowhow" is

[16:18] <ruoso> not a class

[16:19] *** justatheory joined
[16:19] <pmichaud> my understanding is that CREATE is used to construct a new instance of a class.

[16:19] <jnthn> ruoso: I don't follow.

[16:19] <pmichaud> not to clone an existing object.

[16:20] <ruoso> is this new instance defined or not?

[16:20] <pmichaud> (1) that's up to the 'defined' method

[16:20] <ruoso> my understanding is that it is only defined after it is fully initialized

[16:20] <moritz_> ruoso: isn't definedness an aspected of how that cless defines .defined?

[16:21] <moritz_> s/cless/class/

[16:21] <ruoso> (I mean the behavior implemented by Object)

[16:22] <pmichaud> (2) a protoobject may have different behaviors from instances of the class

[16:22] <ruoso> pmichaud, so you assume there are different types of typed undef

[16:22] <ruoso> the ones that can become defined

[16:22] <ruoso> and the ones that can't

[16:22] <ruoso> is it?

[16:22] *** riffraff left
[16:23] <pmichaud> right now we just do it that protoobjects are instances of a class that have additional "protoobject" roles.

[16:23] *** simcop2387 left
[16:23] <ruoso> so they can't become defined

[16:23] <pmichaud> S12: Some objects

[16:23] <pmichaud> may tell you that they are defined, while others may tell you that

[16:23] <pmichaud> they are undefined.  That's up to the object, and depends on how the

[16:23] <pmichaud> metaclass chooses to dispatch the C<.defined> method.

[16:24] <ruoso> I'm talking about the behavior implemented by Object

[16:24] <pmichaud> a protoobject differs from other objects by how it responds to the .defined method

[16:24] *** broquaint joined
[16:24] <ruoso> so Object.BUILDALL fails?

[16:25] *** simcop2387 joined
[16:25] <pmichaud> I have trouble seeing when we'd ever do   Object.BUILDALL

[16:25] <pmichaud> you mean you're trying to initialize the protoobject itself?

[16:25] *** |jedai| left
[16:25] <ruoso> yes... 

[16:26] <pmichaud> I think that probably *should* fail.

[16:26] *** |jedai| joined
[16:26] <ruoso> ok... I think the major misunderstanding point here... 

[16:26] <ruoso> is that SMOP has a more prototype-based OO

[16:27] *** Whiteknight joined
[16:27] <ruoso> while Parrot/Rakudo has a more class-based OO

[16:28] <ruoso> so in SMOP there's only the protoobject... not the protoobject *and* the class

[16:28] <pmichaud> but that's not what S12 says.

[16:30] <pmichaud> as I read S12, we have objects and (meta)classes

[16:30] *** alester left
[16:30] <pmichaud> a protoobject is simply an object that serves as the placeholder for the class

[16:30] <ruoso> metaclass instances, actually

[16:30] <pmichaud> metaclass instance is fine

[16:30] <pmichaud> the point being that protoobjects are not metaclasses.

[16:31] <pmichaud> rakudo/parrot follows this model.

[16:31] <ruoso> right... and that metaclasses are not classes

[16:31] <pmichaud> there's not really a "class"

[16:32] <ruoso> exactly... there's something that knows how to dispatch methods for some object

[16:32] <ruoso> (defined or not)

[16:32] *** Whiteknight is now known as wknight8111

[16:32] <eric256> jnthn++ #parametric roles

[16:34] <ruoso> pmichaud, but the point is that S12 doesn't force the information about the methods to be stored in the metaclass instance or in the protoobject

[16:34] <ruoso> because it supports both class-based and prototype-based oo

[16:34] <pmichaud> but we're talking about Object, and things derived from Object

[16:35] <pmichaud> S12: "However, by default, objects derived from Object support a fairly

[16:35] <pmichaud> standard class-based model.

[16:35] *** km3 joined
[16:35] *** km2 left
[16:36] *** tux300181 is now known as tux300181we

[16:36] *** tux300181we is now known as tux300181

[16:37] <ruoso> pmichaud, some other parts of S12 relaxes that...

[16:37] *** aindilis` left
[16:37] <ruoso> but maybe it needs some clarification

[16:38] *** aindilis` joined
[16:38] <pmichaud> just because p6 supports prototype-based oo doesn't mean that prototype-based oo has to be the foundation for all of its classes and methods

[16:38] <pmichaud> and it's pretty clear that Object follows a more class-based approach

[16:38] <pmichaud> we can of course get objects that use a different metamodel by creating them with different representations

[16:38] <ruoso> pmichaud, it's not that all clear (except for that specific wording)

[16:39] <ruoso> pmichaud, metamodels and representations are not related

[16:39] <ruoso> you're supposed to be able to use different representations with the same metamodel

[16:39] <ruoso> as well as different metamodels with the same representation

[16:40] <pmichaud> all I'm saying is that clearly much of S12 was designed with a class-based representation in mind, and Rakudo follows that.

[16:40] *** nihiliad joined
[16:41] <ruoso> pmichaud, and I'm saying that it pretty much fits a prototype-based... and was relaxed in several points to allow that

[16:41] <ruoso> I'm not at alll saying it should be one or another....

[16:42] <ruoso> on the contrary, I'm advocating it needs to be agnostic...

[16:42] <pmichaud> then yes, we need clarification from p6l I guess.

[16:42] <pmichaud> regardless

[16:42] <ruoso> (as it almost is, the only part of the spec that implies otherwise is that specific phrase in S12)

[16:43] <pmichaud> saying "Object.BUILDALL" doesn't make much sense to me, because "Object" is supposed to remain an undefined protoobject.

[16:43] <ruoso> pmichaud, sure sure... 

[16:43] <ruoso> pmichaud, this is just a corner case

[16:43] <ruoso> and it's not supposed to work gracefully

[16:43] <ruoso> it's a huge shoot in the foot

[16:44] <ruoso> the question is how to handle it...

[16:44] <pmichaud> so the notion of "converting an undefined to defined" instance doesn't really follow for me either, nor do I see why it's an issue.

[16:44] <ruoso> it's an issue if you think of protoobjects as something that can become an object

[16:44] <ruoso> which is not the case for Parrot/Rakudo AFAICS

[16:44] <pmichaud> protoobjects are objects

[16:44] <ruoso> *defined object, that is

[16:44] <pmichaud> they just respond differently to .defined

[16:45] <pmichaud> in particular

[16:45] <pmichaud> if I say:    $p = Object.clone;   $p.BUILDALL     it's not clear to me that should work.

[16:45] <ruoso> let me rephrase

[16:45] <pmichaud> perhaps it should, but there's nothing in the spec to indicate that.

[16:45] <ruoso> it's an issue if you think a protoobject and a defined object share the same implementation of .defined

[16:46] <ruoso> which sees if the value is initialized

[16:46] <pmichaud> what does "value is initialized" mean in this case?

[16:46] <ruoso> the instance storage has been populated with the instance data

[16:46] <pmichaud> with all of it, or with some?

[16:46] <ruoso> with all of it

[16:46] <ruoso> as in

[16:47] <ruoso> Dog{ name => 'fido' } is undefr

[16:47] <ruoso> but it becomes defined later

[16:47] <pmichaud> no it does't.

[16:47] <pmichaud> no it doesn't.

[16:47] <ruoso> er...

[16:47] <ruoso> S12:2065

[16:48] <pmichaud> does it have to be the *same* instance?

[16:48] <jnthn> my $x = Dog{ name => 'fido'}; my $y = $x.new; # $y is defined now. But $x ain't.

[16:48] <pmichaud> right

[16:48] <pmichaud> $y is a new instance

[16:48] <pmichaud> it's not the same as $x

[16:48] <jnthn> Right.

[16:48] <ruoso> but my $x = Dog{ name => 'fido' }; $x.wag; 

[16:48] <ruoso> $x is defined nwo

[16:48] <ruoso> now

[16:48] <jnthn> Huh?

[16:49] <ruoso> S12:206

[16:49] <pmichaud> but does $x have to be the same instance?

[16:49] <ruoso> S12:2065

[16:49] <ruoso> well, I'm implementing as it being the same

[16:49] <pmichaud> yes, but is that required?

[16:49] <ruoso> I'm not sure how you'd track down every container that holds it

[16:49] <pmichaud> how do you mean?

[16:49] <pmichaud> "track down every container..."?

[16:50] <ruoso> if you store that inside several hashes and arrays

[16:50] *** |jedai| left
[16:50] <rakudo_svn> r35817 | jonathan++ | [rakudo] If a routine is marked as proto, then all routines after that not declared multi will be made to be multis.

[16:50] <ruoso> it should autovivify and become available in all that containers

[16:50] <pmichaud> oh, Rakudo does that.

[16:50] <pmichaud> no problem.

[16:50] *** |jedai| joined
[16:50] <jnthn>     my $dog = Dog{ :name<Fido> }; defined $dog or say "doesn't exist";  # Fido doesn't exist $dog.wag()                            # Fido wags his tail

[16:50] <jnthn> In those three lines, does $dog end up defined?

[16:50] <ruoso> yes

[16:50] <pmichaud> yes

[16:50] <jnthn> *after those...

[16:51] <jnthn> ok

[16:51] * jnthn didn't realize Rakudo was doing that, but good.

[16:51] <pmichaud> Rakudo isn't doing that yet

[16:51] <pmichaud> but I haven't figured out what causes it to happen.

[16:51] <jnthn> Ah, OK.

[16:51] <pmichaud> i.e., what triggers the conversion to defined

[16:51] <jnthn> pmichaud: I really dunno.

[16:51] <pmichaud> it's not simply the calling of a method.

[16:51] <jnthn> It can't be ...right.

[16:51] <jnthn> Because then .new would make the proto defined.

[16:51] <ruoso> autovivifying implies calling BUILDALL

[16:52] <pmichaud> either way, in Rakudo it's not at all a problem for us to take the object and replace it with a defined instance.

[16:52] <jnthn> Indeed.

[16:52] <jnthn> But it's a case of when it happens.

[16:52] <jnthn> ruoso: Sure, but would wag here do that explicitly?

[16:52] <ruoso> jnthn, I still didn't figure out what triggers that exactly... but yes... 

[16:52] <ruoso> wag would do that explicitly

[16:53] <pmichaud> ruoso:  but what makes it defined in this case?

[16:53] *** ejs left
[16:53] <ruoso> in my understanding... BUILDALL

[16:53] <pmichaud> okay

[16:53] <pmichaud> but having BUILDALL convert an undefined to a defined instance isn't at all a problem (at least not in Rakudo

[16:54] <ruoso> alright... I presume that is because of Parrot features

[16:54] <pmichaud> even w/o parrot features

[16:54] <pmichaud> if we simply assume that  Object has a $!defined attribute

[16:54] <pmichaud> and that BUILDALL sets $!defined to true

[16:54] <pmichaud> (it doesn't have to be a visible one -- could be handled internally)

[16:55] <pmichaud> then protoobjects don't have $!defined set, and BUILDALL sets $!defined

[16:55] <ruoso> right... you ended up with the same as I do

[16:55] <ruoso> you can call $proto.BUILDALL and make it defined

[16:56] <ruoso> which is where we started

[16:56] <ruoso> :)

[16:56] <pmichaud> as I said, I don't see it as being a problem.  :-)

[16:57] <ruoso> so what happens when you do Object.BUILDALL ?

[16:57] <pmichaud> I think it should be an error.

[16:58] <ruoso> how do you detect that?

[16:58] <pmichaud> Perhaps "Object" has a readonly property on it.

[16:58] <pmichaud> yes, that does become an issue if you assume that creating a new object involves cloning a protoobject (and the readonly property gets cloned)

[16:58] <ruoso> which is set to false when you Object{ :attr }

[16:59] <pmichaud> although I tend to think of "Object" as being a container just like "$x"

[17:00] <pmichaud> and then Object{ :attr }  has an implicit clone in it, because it's really   Object but WHENCE({ :attr })

[17:01] <ruoso> phew... I think we're getting somewhere now ;)

[17:02] <pmichaud> afk, inauguration

[17:07] <ruoso> so I get back to 1 hour ago ;) ;)... 

[17:07] <ruoso> if every built-in type is a Role

[17:07] <ruoso> is Object a role?

[17:08] * ruoso lunch &

[17:08] *** hercynium joined
[17:11] *** [particle]1 joined
[17:23] <moritz_> std: for (my $i = 1; $i <= 3; $i++) { say $i; }

[17:23] <p6eval> std 24973: OUTPUT«00:05 86m␤»

[17:27] *** ntgrl joined
[17:27] <eric256> rakudo: role Greet[Str $greeting] { method greet() { say "$greeting!"; } }; class English { does Greet["Hello"]; }; English.new.greet();

[17:27] <p6eval> rakudo 35819: OUTPUT«Could not find non-existent sub does␤current instr.: 'parrot;English;_block38' pc 426 (EVAL_21:149)␤»

[17:28] <moritz_> eric256: you have to write it as 'class English does Greet["Hello"] { ... }' for now

[17:28] <jnthn> eric256: You have to put the does up after the class English for now.

[17:28] *** [particle] left
[17:29] *** ntgrl is now known as integral

[17:29] <eric256> ok ;)

[17:29] *** ruoso left
[17:29] <eric256> just trying out the synopsis S12 since there doesn't appear to be an S14 yet 

[17:29] *** |jedai| left
[17:30] *** |jedai| joined
[17:30] *** szbalint left
[17:32] <jnthn> eric256: Yes, some of S12 will move to S14.

[17:33] <eric256> makes since

[17:33] <eric256> lots of role stuff in there

[17:34] <jnthn> Aye.

[17:34] *** ruoso joined
[17:34] <jnthn> I'm planning to work on that in the not too distant future.

[17:34] <eric256> now i just have to figure out a real world example for roles ;) lol

[17:34] <jnthn> You'll find plenty once they settle into your head. :-)

[17:35] <eric256> of that i'm sure

[17:35] <eric256> gettings classes and roles and parametric roles all at once is alot to digest

[17:36] <jnthn> Yes!

[17:36] <ruoso> does "role Foo[:$something]" means that there's an attribute with that name? or is that a lexical variable that should be installed?

[17:36] <jnthn> You can see it as a lexical.

[17:36] <jnthn> What's between the [...] is just a signature.

[17:36] <jnthn> In Rakudo we quite literally just bind it like a normal call.

[17:36] <ruoso> I see...

[17:37] <jnthn> Then do some magic to make sure we get the scoping of methods right.

[17:37] <jnthn> Also, you do a multi-dispatch to decide which role to do.

[17:37] <moritz_> rakudo: role foo[:$a] { method m { say $a } }; (1 but foo[:a<z>]).m

[17:37] <p6eval> rakudo 35819: OUTPUT«No applicable candidates found to dispatch to for '_block20'␤current instr.: 'parrot;Perl6Role;!select' pc 2444 (src/classes/Role.pir:108)␤»

[17:37] <eric256> is there any reason roles take [] instead of ()?

[17:37] <moritz_> rakudo: role foo[:$a] { method m { say $a } }; (1 does foo[:a<z>]).m

[17:37] <ruoso> actually, it's not that hard once you have to support $?CLASS pointing to the class where the role was composed into

[17:37] <p6eval> rakudo 35819: OUTPUT«No applicable candidates found to dispatch to for '_block20'␤current instr.: 'parrot;Perl6Role;!select' pc 2444 (src/classes/Role.pir:108)␤»

[17:37] <moritz_> jnthn: should that work?

[17:38] <jnthn> moritz_: I *think* so.

[17:38] <ruoso> rakudo: role Foo { method m { say $?CLASS } }; class Bar does Foo { }; Foo.m;

[17:38] <jnthn> I can guess why it doesn't.

[17:38] <p6eval> rakudo 35819: OUTPUT«Scope not found for PAST::Var '$?CLASS' in m␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[17:38] <moritz_> jnthn: should I open a ticket?

[17:39] <jnthn> I've not written the tests for named parameters yet. ;-)

[17:39] <jnthn> moritz_: You can, but it's already in the line of fire.

[17:39] <moritz_> ok, then I don't bother

[17:39] <jnthn> ruoso: I suspect all roles will take an implicit $?CLASS as their first parameter.

[17:39] <jnthn> Not done that yet, but...

[17:40] <jnthn> rakudo: role Foo[Pair $x] { }; 1 but Foo[:x<1>]

[17:40] <p6eval> rakudo 35819: RESULT«1»

[17:40] <jnthn> Aye, 'tis what I expected.

[17:40] <jnthn> missing build_call...

[17:40] <ruoso> jnthn, I was guessing the role composition would glue an additional outer scope to the method being composed

[17:41] <ruoso> declaring $?CLASS

[17:41] <ruoso> not an additional, actually... but it would add a new scope in the hierarchy

[17:41] *** zamolxes left
[17:42] <moritz_> rakudo: grammar A { }; my $a = A.new; say $a ~~ A;

[17:42] <p6eval> rakudo 35819: OUTPUT«too few arguments passed (1) - 3 params expected␤current instr.: 'parrot;PGE;Match;new' pc 28 (compilers/pge/PGE/Match.pir:54)␤»

[17:42] <ruoso> jnthn, I think [:x<1>] is always a named parameter, isn't it?

[17:42] <jnthn> ruoso: Yeah.

[17:42] <ruoso> you'd have to add an additional ( ) to make it a positional

[17:42] <jnthn> ruoso: It is, but it's not being turned into one, it's being passed as a pair object.

[17:43] <jnthn> I was just checking that the bug was what I thought it was. :-)

[17:46] <eric256> running 0 but True; seems to hang perl6 at the command line

[17:46] *** ejs joined
[17:47] <moritz_> same here

[17:47] *** nihiliad left
[17:47] <eric256> did know if but was working...guessing it isn't lol

[17:48] <jnthn> The re-write of enums gets ever more desparate...

[17:48] <moritz_> 0 but Str also loops

[17:48] <jnthn> Hmm

[17:48] <jnthn> That's odd - I'd have expected an error... :-S

[17:49] <jnthn> (Since Str is a class atm, rather than a role, and such issues.)

[17:49] <moritz_> I know

[17:50] *** |jedai| left
[17:50] * jnthn wonders why something failed during make spectest, and yet runs just fine at the command line

[17:50] *** |jedai| joined
[17:57] *** nihiliad joined
[18:00] <rakudo_svn> r35821 | jonathan++ | [rakudo] Compose roles at class composition time, rather than as we encounter them.

[18:01] *** pdcawley joined
[18:05] <eric256> rakudo: role Err { has $.reason is rw;}; my $x = 1 but Err("Test"); say $x; say $x.reason;

[18:05] <p6eval> rakudo 35819: OUTPUT«1␤Test␤»

[18:05] <eric256> ;)

[18:06] <moritz_> rakudo: enum Foo <bar baz>; my $x = 1 but Foo::bar; say $x.Foo

[18:06] <p6eval> rakudo 35819: OUTPUT«Use of uninitialized value␤␤»

[18:11] *** Casan joined
[18:12] *** rindolf joined
[18:16] *** kst left
[18:17] *** kst joined
[18:17] *** |jedai| left
[18:18] *** |jedai| joined
[18:19] *** aindilis` left
[18:20] *** aindilis` joined
[18:21] <moritz_> perl6: sub f($a, $b) { say "$a|$b" }; my @a = <1 4>; f(|@a)

[18:21] *** kst` joined
[18:21] <p6eval> pugs: OUTPUT«*** No compatible multi variant found: "&f"␤    at /tmp/obfojECJqI line 1, column 47 - line 2, column 1␤»

[18:21] <p6eval> ..rakudo 35825: OUTPUT«1|4␤»

[18:21] <p6eval> ..elf 24973: OUTPUT«Undefined subroutine &GLOBAL::prefix__124 called at (eval 124) line 6.␤ at ./elf_h line 4307␤»

[18:22] <rindolf> Rakudo seems the only one right.

[18:23] <moritz_> aye

[18:23] <moritz_> rakudo: rakudo: for "foo\nbar\nbaz".split( /\n ** 2..*/ ) { say

[18:23] <moritz_> .trans([ /\s+/ => " " ]) }

[18:23] <p6eval> rakudo 35825: OUTPUT«Statement not terminated properly at line 1, near ": for \"foo"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[18:23] <moritz_> rakudo: rakudo: for "foo\nbar\nbaz".split( /\n ** 2..*/ ) { say .trans([ /\s+/ => " " ]) }

[18:23] <p6eval> rakudo 35825: OUTPUT«Statement not terminated properly at line 1, near ": for \"foo"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[18:24] <moritz_> what is complaining about?

[18:24] <pmichaud> the extra "rakudo:"

[18:24] <pmichaud> rakudo doesn't understand labels yet.

[18:24] <moritz_> rakudo: for "foo\nbar\nbaz".split( /\n ** 2..*/ ) { say .trans([ /\s+/ => " " ]) }

[18:24] <p6eval> rakudo 35825: OUTPUT«foo bar baz␤»

[18:24] * moritz_ blind

[18:24] <moritz_> pmichaud: do you want to (temporarily?) revert the Test.pm changes?

[18:25] <pmichaud> yes.

[18:25] <moritz_> good.

[18:25] <pmichaud> if you could easily do that, it would be great.

[18:25] <pmichaud> if not I'll do it, but have to hunt them down.

[18:25] <moritz_> I'll look into it

[18:25] <pmichaud> could probably simply restore the Test.pm that was in effect yesterday.

[18:26] <pmichaud> instead of finding+reverting patch.

[18:26] <moritz_> I found the offending commit

[18:27] <moritz_> now running spectest to see if it works out

[18:30] *** ruoso left
[18:35] *** km3 left
[18:36] *** kst left
[18:38] *** masak joined
[18:44] *** riffraff joined
[18:44] *** Patterner left
[18:49] *** Psyche^ joined
[18:49] *** Psyche^ is now known as Patterner

[18:50] <rakudo_svn> r35830 | moritz++ | [rakudo] revert changes to Test.pm that broke some tests in fail.t

[18:50] <rakudo_svn> r35830 | moritz++ | We we re-evaluate the patch from Ovid++ after the release

[18:50] <jnthn> moritz_: fail.t passes again after this?

[18:53] <moritz_> jnthn: all tests pass here

[18:54] <jnthn> w00t

[18:54] <moritz_> jnthn: although I've seen some non-reproducible failures of t/spec/S16-filehandles/io_in_for_loops.t

[18:54] <moritz_> jnthn: no #parrotsketch for you?

[18:56] <jnthn> moritz_: Oh? Is it now?

[18:56] <moritz_> jnthn: yes, question time already

[18:56] <jnthn> ooops!!!

[18:58] <pugs_svn> r24974 | jnthn++ | [t/spec] Various extra tests for proto.

[19:01] <rakudo_svn> r35836 | jonathan++ | [rakudo] Final fix needed to get a proto in the class to avoid conflicts with methods of the same name in roles (by bringing them into the multi).

[19:01] *** simcop2387 left
[19:01] *** simcop2387 joined
[19:08] <moritz_> mail sent to p6l. Let's see if we get some kind of productive response...

[19:12] <jnthn> A flame war produces emails. ;-)

[19:14] *** cosimo joined
[19:16] <masak> aie! all the work I did on Text::Markup::Wiki::MediaWiki has just mysteriously disappeared! :O

[19:16] * moritz_ blames git

[19:16] <moritz_> oh wait, I can't. Git is a saint...

[19:16] *** schmalbe left
[19:17] <masak> blaming git is close at hand right now.

[19:17] <masak> but I'll withhold judgment. it's just as likely I or someone else did something wrong.

[19:18] <masak> ok, found it.

[19:24] <masak> still mystified, though.

[19:24] *** zamolxes joined
[19:25] * jnthn afk for a bit - dinner

[19:26] <masak> oh. I think I get it now.

[19:27] <masak> merging, though marvellously simple, is not always easy.

[19:30] *** kst` is now known as kst

[19:30] <diakopter> @tell ruoso libpcl won't build on windows; I tried several environments.... although I guess I haven't tried vc++

[19:30] <lambdabot> Consider it noted.

[19:31] *** On left
[19:31] *** On joined
[19:32] *** [particle] joined
[19:34] * eric256 reads about roles and traits and then wanders the halls mumbling to himself

[19:35] *** pmurias joined
[19:35] <diakopter> pmurias: :( libpcl won't build on windows; I tried several environments.... although I guess I haven't tried vc++

[19:35] <diakopter> pmurias: howdy :D

[19:40] *** kst` joined
[19:40] <pmurias> diakopter: hi

[19:40] <pmurias> diakopter: libpcl is not really required for anything

[19:41] <diakopter> okay... so src/pcl_coro.c is extraneous?

[19:41] <diakopter>  .ri I mean

[19:42] <pmurias> src/pcl_coro.ri is not used by anything other than it's test

[19:42] *** pbuetow joined
[19:42] * diakopter renames it

[19:43] * pmurias was doing just it 

[19:43] *** km2 joined
[19:43] <eric256> is there a way to get a Match object to give up its keys? 

[19:43] * pmurias svn reverts

[19:44] <masak> eric256: you give it a meaty bone instead?

[19:44] <diakopter> well, that was quite the excursion

[19:44] <eric256> masak: ;)

[19:44] <masak> eric256: have you tried $/.keys?

[19:44] <eric256> yep

[19:44] <masak> eric256: did it work?

[19:45] <eric256> rakudo: rule a {H}; say "Hello" ~~ /<a>/; say $/.keys.perl;say $/<a>;

[19:45] <p6eval> rakudo 35839: OUTPUT«H␤[]␤H␤»

[19:45] <eric256> no ;)

[19:45] <masak> eric256: did you submit a rakudobug?

[19:45] <eric256> i don't even know if it is a bug, cause i can't find a sepc for Match...but thats cause i'm slow

[19:45] *** riffraff left
[19:45] <eric256> lol

[19:45] *** |jedai| left
[19:45] <pmurias> diakopter: does it compile now?

[19:45] <masak> eric256: please do. that's easier than asking.

[19:46] <masak> "it's easier to get bugfixes than explanations"

[19:46] *** |jedai| joined
[19:46] <eric256> only if it is suppose to handle .keys

[19:46] <masak> eric256: as I said, there's only one way to find out :P

[19:46] <eric256> lol

[19:46] <eric256> alright alright

[19:46] <masak> eric256: (I've wanted that functionality at times too)

[19:47] <moritz_> it's a bit tricky

[19:47] <moritz_> $/ is both a hash and an array

[19:47] <moritz_> and both have .keys methods

[19:47] <moritz_> but I guess it's more dwim'my to assume hash semantics for .keys, .values, .kv etc.

[19:48] <masak> yes, I agree.

[19:48] <moritz_> rakudo: rule a {H}; "Hello" ~~ /<a>/; say %($/).keys.perl;

[19:48] <p6eval> rakudo 35839: OUTPUT«["a"]␤»

[19:48] *** [particle]1 left
[19:48] <masak> there's no way to satisfy Liskov in this case.

[19:50] *** p6eval left
[19:50] *** p6eval joined
[19:52] *** silug left
[19:52] *** pasteling left
[19:52] *** Patterner left
[19:52] *** literal left
[19:52] *** tux300181 left
[19:52] *** moritz_ left
[19:52] *** kcwu left
[19:52] *** lisppaste3 left
[19:52] *** cotto left
[19:52] *** Helios left
[19:52] *** zostay left
[19:52] *** AzureStone left
[19:54] *** kst left
[19:55] *** kst` left
[19:56] <eric256> oh cool ;)

[19:58] <eric256> rakudo: class Match is also { method keys () {return %($self).keys }; }; rule a {H}; say "Hello" ~~ /<a>/; say $/.keys.perl;

[19:58] <p6eval> rakudo 35839: OUTPUT«Scope not found for PAST::Var '$self' in keys␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[19:59] <eric256> rakudo: class Match is also { method keys () {return %(self).keys }; }; rule a {H}; say "Hello" ~~ /<a>/; say $/.keys.perl;

[19:59] <p6eval> rakudo 35839: OUTPUT«H␤["a"]␤»

[19:59] <eric256> sweet

[20:01] <masak> eric256++ # taking matters into self.hands

[20:01] <jnthn> masak: Actually, details here is probably more on-topic. :-=)

[20:01] *** nihiliad left
[20:02] <masak> jonathan: foo( :$bar ) doesn't work anymore.

[20:02] <jnthn> hmm

[20:02] <masak> jnthn: but it _is_ a Rakudo implementation question.

[20:02] <jnthn> I can't believe we don't have spectests for that!

[20:02] <jnthn> masak: True. :-)

[20:02] <masak> oh, so it isn't a conscious regression?

[20:02] <jnthn> But it's noisy on #parrot at the moment

[20:02] <jnthn> No, it's not.

[20:02] <eric256> if i aksed all my questions as a bug report there would be like 100 new bugs ;)

[20:02] <jnthn> Not knowingly on my part, anyway...

[20:03] * eric256 needs a #perl6-users channel

[20:03] <PerlJam> eric256: do that right *after* the release.

[20:03] <masak> eric256: bring 'em on.

[20:03] <eric256> or this should be #perl6-rakudo-dev ;)

[20:03] <jnthn> rakudo: sub foo(:$x) { say $x }; my $a = 42; foo(:$a)

[20:04] <p6eval> rakudo 35839: OUTPUT«complex varname colonpair case not yet implemented at line 1, near ")"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[20:04] <masak> jnthn: I find your lack of spectests disappointing.

[20:04] <jnthn> rakudo: sub foo(:$x) { say $x }; my $a = 42; foo(:a($a))

[20:04] <p6eval> rakudo 35839: OUTPUT«too many named arguments - 'a' not expected␤current instr.: 'foo' pc 95 (EVAL_17:52)␤»

[20:04] <jnthn> rakudo: sub foo(:$x) { say $x }; my $a = 42; foo(:x($a))

[20:04] <p6eval> rakudo 35839: OUTPUT«42␤»

[20:04] <eric256> rakudo: class Match is also { method keys () {return %(self).keys }; }; rule a {H}; say "Hello" ~~ /<a>/; say $/.keys.perl;say $/.WHO;

[20:04] <p6eval> rakudo 35839: OUTPUT«H␤["a"]␤Method 'WHO' not found for invocant of class 'Match'␤current instr.: 'parrot;P6metaclass;dispatch' pc 119 (src/classes/ClassHOW.pir:95)␤»

[20:04] <eric256> rakudo: class Match is also { method keys () {return %(self).keys }; }; rule a {H}; say "Hello" ~~ /<a>/; say $/.keys.perl;say $/.WHAT;

[20:04] <jnthn> rakudo: sub foo(:$x) { say $x }; my $x = 42; foo(:$x)

[20:04] <p6eval> rakudo 35839: OUTPUT«"load_bytecode" couldn't find file 'PGE.pbc'␤current instr.: 'parrot;PCT;Grammar;onload' pc 0 (src/PCT/Grammar.pir:41)␤»

[20:04] <jnthn> rakudo: sub foo(:$x) { say $x }; my $x = 42; foo(:$x)

[20:04] <p6eval> rakudo 35839: OUTPUT«complex varname colonpair case not yet implemented at line 1, near ")"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[20:05] <jnthn> masak: I did write well over 50 new ones this week. :-P

[20:05] <jnthn> Or close to anyway...

[20:05] <masak> jnthn: I know, I'm not actually complaining.

[20:05] *** cosimo left
[20:05] <jnthn> :-P

[20:05] <masak> just paraphrasing Darth Vader.

[20:05] <pmichaud> masak: I don't think the  foo(:$x)  syntax was ever implemented.

[20:05] <masak> pmichaud: oh, it was.

[20:05] <jnthn> pmichaud: I seem to remember it working...

[20:05] <masak> pmichaud: I had working code using it.

[20:05] <pmichaud> okay, then it's been broken since rvar.

[20:06] <jnthn> masak: Any idea on what timescale?

[20:06] <pmichaud> because I don't think I put it into rvar.

[20:06] <masak> jnthn: late November.

[20:06] <jnthn> If last couple of days, I'm surprised. If rvar, I'm less so.

[20:06] <jnthn> Ah, OK.

[20:06] <masak> it was before rvar.

[20:06] <jnthn> OK.

[20:06] <masak> but I'm still sad it's gone.

[20:06] * jnthn blames rvar

[20:06] <pmichaud> in which case, we don't have tests for it.

[20:06] <masak> grr!

[20:06] * pmichaud blames spectest.

[20:06] <masak> (lack of tests)--

[20:07] * jnthn will look at it in parallel with make nom

[20:07] *** cosimo joined
[20:07] <masak> jnthn++

[20:07] <pmichaud> what is responsible for handling :$x anyway?  Is that colonpair?

[20:07] <pmichaud> because if so, I didn't do anything to colonpair.

[20:07] <pmichaud> (in rvar)

[20:08] <pmichaud> ...and that might be why it's broken.

[20:08] <jnthn> pmichaud: 

[20:08] <jnthn> ah.

[20:09] <jnthn> it's because desigilname used to capture a name

[20:09] <jnthn> And now captures it as longname

[20:09] <jnthn> And actions.pm wasn't updated to follow that change in method colonpair.

[20:09] <pmichaud> ah, std compiliance.

[20:09] <jnthn> Aye, grammar.pg is right, actions.pm just didn't track it.

[20:10] <jnthn> pmichaud: What whould we do in the :$foo::bar case? Is that illegal, I wonder?

[20:10] <jnthn> But if so, I wonder why not just have ident...

[20:10] <pmichaud> jnthn: I have no idea.

[20:10] *** silug joined
[20:10] *** pasteling joined
[20:10] *** moritz_ joined
[20:10] *** Patterner joined
[20:10] *** literal joined
[20:10] *** tux300181 joined
[20:10] *** kcwu joined
[20:10] *** lisppaste3 joined
[20:10] *** Helios joined
[20:10] *** AzureStone joined
[20:10] *** cotto joined
[20:10] *** zostay joined
[20:11] <jnthn> heh, nor does S02. :-)

[20:11] <pmichaud> it also means that :$$name  would parse also.

[20:11] <eric256> rakudo: class Match is also { method keys () {return %(self).keys }; }; rule a {H}; say "Hello" ~~ /<a>/; say $/.keys.perl; my $x = $/; $x.keys.perl.say;

[20:11] <p6eval> rakudo 35839: OUTPUT«H␤["a"]␤Null PMC access in find_method()␤current instr.: 'parrot;Match;keys' pc 345 (EVAL_24:106)␤»

[20:12] <masak> eric256: Null PMC accesses are free rakudobugs!

[20:12] <masak> submit, submit!

[20:12] <jnthn> $key = $<var><desigilname>.text

[20:12] <jnthn> (from sTD.pm)

[20:12] <eric256> masak: lol okay i'm off to file two bugs then

[20:13] <jnthn> Well, that can't be wrong. ;-)

[20:13] <masak> eric256++

[20:13] <pmichaud> okay, that works for me.  Do you want to do the colonpair change or shall I?

[20:13] <jnthn> building it now...

[20:16] <masak> rakudo: class A { has &.f; method t { &.f } }; A.new( f => { say "OH HAI" } ).t

[20:16] <p6eval> rakudo 35839: OUTPUT«Method 'f' not found for invocant of class 'A'␤current instr.: 'parrot;A;t' pc 245 (EVAL_20:96)␤»

[20:16] <masak> jnthn: this used to work as well >:(

[20:16] <moritz_> masak: please add to  t/spec/S12-attributes/instance.t 

[20:17] <masak> moritz_: with all due respect, I'm too busy writing workarounds right now :(

[20:17] <masak> we're on a tight schedule tonight.

[20:17] <moritz_> masak: ok

[20:17] <pmichaud> masak: what did you expect that to do?  return a sub?

[20:17] <masak> pmichaud: no, run it.

[20:17] <masak> oh.

[20:17] <jnthn> You probably need parens for that.

[20:17] <moritz_> &.f is short for &( self.f )

[20:17] <masak> rakudo: class A { has &.f; method t { &.f() } }; A.new( f => { say "OH HAI" } ).t

[20:17] <p6eval> rakudo 35839: OUTPUT«Method 'f' not found for invocant of class 'A'␤current instr.: 'parrot;A;t' pc 245 (EVAL_20:96)␤»

[20:17] <masak> would that be enough?

[20:18] <jnthn> ok, i haz colon pair fix

[20:18] *** kane_ left
[20:18] <jnthn> will write spectest for it now, then run the tests...

[20:18] <masak> jnthn: yay.

[20:18] <moritz_> jnthn: and I have a test locally here

[20:19] *** kane_ joined
[20:19] <jnthn> moritz_: Oh? Commit away then.

[20:19] <masak> if I write that test, will the &.f regression be fixed sooner? :)

[20:19] <masak> I'm willing to bargain here.

[20:19] <pmichaud> rakudo:  class A { has $!f; method t { $!f() } }; A.new( f => { say "OH HAI" } ).t

[20:19] *** kane_ left
[20:19] <p6eval> rakudo 35839: OUTPUT«OH HAI␤»

[20:19] <jnthn> oh, I thought you meant for colonpair.

[20:19] <pugs_svn> r24975 | moritz++ | [t/spec] tests for mysub(:$named_arg)

[20:20] <masak> pmichaud: oh, that helps. kthxbai.

[20:20] <jnthn> oh, moritz++

[20:20] *** kane_ joined
[20:20] <jnthn> moritz_: Which file was it in? I'll unfudge it locally...

[20:20] <moritz_> jnthn:  t/spec/S06-signature/named-parameters.t, one of them can probably be unfudged wih your fix

[20:20] <pmichaud> rakudo:  class A { has &!f; method t { &!f() } }; A.new( f => { say "OH HAI" } ).t

[20:20] <p6eval> rakudo 35839: OUTPUT«No such attribute '!f'␤current instr.: 'parrot;A;t' pc 209 (EVAL_20:83)␤»

[20:20] *** [particle]1 joined
[20:20] <pmichaud> I don't know that we have subroutine attributes working yet in Rakudo.

[20:20] <masak> pmichaud: I'm surprised constructors can assign to privates.

[20:20] <pmichaud> subroutines are weird because we have to do funky things to sigils.

[20:21] <pmichaud> masak: I'm pretty sure that was the spec that was decided upon (assigning to privates)

[20:21] <moritz_> masak: they ahve to be initialized by .perl output somehow

[20:21] <masak> moritz_: Perl 6 and I don't agree on what a private is, then.

[20:21] <moritz_> ok, back to the question: is &.f() actually allowed?

[20:21] <pmichaud> rakudo:  class A { has $.f; method t { $.f() } }; A.new( f => { say "OH HAI" } ).t

[20:21] <p6eval> rakudo 35839: OUTPUT«OH HAI␤»

[20:21] <pugs_svn> r24976 | pmurias++ | [mildew] start of a Prelude

[20:21] <pugs_svn> r24976 | pmurias++ | it is for now only loaded by load_prelude.p6

[20:21] <pmichaud> I have to think about &.f() a bit.

[20:22] <moritz_> I mean it's self.f() in Callable context

[20:22] <pmichaud> yes, that's what it looks like to me.

[20:22] <moritz_> so the return value better be coerced to a sub... which won't work

[20:22] <pmichaud> I'm not even sure that $.f()  is correct here.

[20:23] <moritz_> but you could declare it as &.f and call it as $.f() or so

[20:24] <pmichaud> I think it would have to be  (&.f)()

[20:24] <pmichaud> and ($.f)()

[20:25] *** |jedai| left
[20:25] *** On left
[20:25] <pmichaud> because $.f()  would be  self.f()  in scalar context.

[20:25] <pmichaud> er, in $ context

[20:25] <moritz_> since @.f means "call self.f in List context", the former would mean "call self.f in Code context", which doesn't amek sense to me

[20:25] *** |jedai| joined
[20:26] <moritz_> $.f() or @.f() should do, though

[20:26] <pmichaud> $.f and $.f() are equivalent.

[20:26] <pmichaud> both are method calls.

[20:26] <moritz_> right

[20:26] <pmichaud> both are method calls with no arguments.

[20:26] <pmichaud> so, if $.f returns a sub to be invoked, then it would have to be  ($.f)()

[20:26] <moritz_> with "former" I meant "(&.f)()"

[20:27] <pmichaud> in order to invoke it.

[20:27] <moritz_> hm, right

[20:27] <pmichaud> and rakudo gets that wrong for now, because it doesn't recognize the   $.method(...) syntax.

[20:28] <moritz_> aye

[20:28] *** alester joined
[20:29] <pmichaud> some pieces of the grammar are really weird.

[20:30] <pmichaud> I bet I can get &.foo(args)  to work if we ignore the sigil for now.

[20:31] <pmichaud> masak:  use   ($!f)()  as your workaround for now, otherwise it'll break again when we fix Rakudo.

[20:31] <masak> pmichaud: acknowledged.

[20:31] <pmichaud> masak:  or   ($.f)()

[20:31] <masak> aye.

[20:32] *** cosimo left
[20:32] <pmichaud> (and it's very likely that those are in fact the "correct" Perl 6 in the long run)

[20:33] <alester> hey pmichaud

[20:33] <alester> I have much to talk with you about.

[20:33] <pmichaud> alester: if you can handle my possibly being distracted at a moment's notice today -- shoot :-)

[20:33] <alester> Actually, I'd like to talk voice this evening, if possible.

[20:34] <pmichaud> it's possible.

[20:34] <pmichaud> have a time in mind?

[20:37] <alester> 8ish?  9ish?

[20:37] *** [particle] left
[20:37] <alester> I don't know what your home life is like.

[20:37] <pmichaud> either of those work for me.

[20:37] <pmichaud> (I'm CST, btw)

[20:37] <alester> will you be online?

[20:37] <alester> Yeah, I know. 

[20:37] <alester> TX

[20:37] <pmichaud> I don't know if I'll be online or not.  I can break away from whatever I'm doing to take a call;  I can't necessarily sit in front of the computer waiting for one, though.

[20:39] <pmichaud> if you just call 8ish 9ish or whatever that should be fine.

[20:40] <pmichaud> phone # coming via priv msg

[20:40] <alester> no, that's fine.

[20:40] <PerlJam> text messages make good pings.

[20:41] <pmichaud> afk # kids from school

[20:41] <pugs_svn> r24977 | jnthn++ | [t/spec] Fix and unfudge a colonpair test.

[20:42] <alester> pmichaud: My agenda is roughly: What are we doing on rakudo.org?  What do we want people to do in Perl 6?  I'm working on my keynote for FP2009.

[20:43] <jnthn> masak: fixed

[20:43] * jnthn -> nom

[20:43] <masak> jnthn: woot!

[20:43] <masak> looks promising for tonight's upgrade.

[20:43] *** rhr_ joined
[20:44] *** rob joined
[20:44] *** rob is now known as Guest38745

[20:48] <eric256> okay apparently RT is smarter than me...is there anyway to submit a bug other than emailing it in?

[20:49] <eric256> i got a bitcard account and logged in, but i don't see any way to submit a bug

[20:49] <Guest38745> does anyone else find vim eats up a lot cpu whilst highlighting perl6 code? I am using the syntax file from the pugs repo

[20:49] <PerlJam> eric256: are you sure you're looking at the correct interface?

[20:50] <eric256> PerlJam: nope

[20:50] <masak> eric256: I usually email them in.

[20:50] <rakudo_svn> r35840 | jonathan++ | [rakudo] Make :$foo form of colonpair work again.

[20:50] <eric256> PerlJam: http://rt.perl.org/rt3/

[20:50] <Khisanth> eric256: which module do you want to report a bug for?

[20:50] <eric256> perl6

[20:51] <eric256> so i clicked perl6 on the right, got a list of bugs, but no submit or new ticket or.

[20:51] *** viklund joined
[20:52] *** |jedai| left
[20:52] *** |jedai| joined
[20:52] <moritz_> Guest38745: update your copy of perl6.vim, that has been improved a few days ago

[20:53] <moritz_> for bug reports you *must* send a mail (rakudobug@perl.org), there's no way to submit them via a web form

[20:53] <eric256> ahh okay

[20:54] *** rhr left
[20:54] *** cosimo joined
[20:54] <Guest38745> ah thanks moritz_ :)

[20:55] *** Guest38745 is now known as rob___

[20:56] *** smtms joined
[20:57] *** rindolf left
[21:00] <eric256> bugs away

[21:02] <eric256> rakudo: Null PMC access in find_method()␤current instr.: 'parrot;Match;keys' pc 345 (EVAL_24:106)

[21:02] <p6eval> rakudo 35839: OUTPUT«"load_bytecode" couldn't find file 'PGE.pbc'␤current instr.: 'parrot;PCT;Grammar;onload' pc 0 (src/PCT/Grammar.pir:41)␤»

[21:03] <eric256> lol if you paste that in the interactive mode you get a segmentation fault... i dunno why its a segfault instead of a parse error

[21:04] <masak> eric256: probably because you're running ./perl6

[21:06] *** ejs left
[21:06] *** mberends joined
[21:07] <eric256> ahh yea

[21:07] <PerlJam> pmichaud, alester: I hope the two of you come up with a "standard" place to send people for rakudo stuff.

[21:08] <alester> That's part of it, yes.

[21:08] <pmichaud> PerlJam: that will happen.  The only question is where and how.

[21:08] *** wknight8111 left
[21:08] <pmichaud> (I guess that's really two questions)

[21:09] * eric256 would love to see it be rakudo.org  ;) but the blog isn't realy cutting it as an general information source

[21:09] <alester> we realy only have 2.5 weeks to get rakudo.org in a state that I can show off in Minneapolis.

[21:09] <PerlJam> For instance ....

[21:09] <alester> eric256: Yes, we know.

[21:09] <alester> We are aware that rakudo.org needs more on it.

[21:09] <eric256> ;) i figured ++ to both of you by the way

[21:09] <PerlJam>  < ben_m> PerlJam: currently looking for how to install rakudo.

[21:09] <alester> That is one of the things we will be discussed.

[21:09] <PerlJam> from one of the #perl

[21:09] <eric256> i'd be happy to help with anything you can offload ;)

[21:09] <alester> eric256: thanks, I'm sure there will be stuff.

[21:10] <eric256> i'm trying to focus on examples etc since i can't seem to get enough time to get update on internals, but i'd love to help with some documentation for newbies too. i'm still green enough to sympathize with them

[21:11] <alester> ANYTHING we write will be a win.

[21:11] <eric256> i think that package idea on the comments is good too, i just went through getting all the stuff for rakudo and it is a bit of work hunting around

[21:12] *** perl7 joined
[21:13] <mberends> rakudo: grammar G { regex r { \r }; regex b { \b }; }; if "b" ~~ G::b { say "blue"; };

[21:13] <p6eval> rakudo 35839: OUTPUT«Method 'ACCEPTS' not found for invocant of class 'PGE;Match'␤current instr.: 'infix:~~' pc 19585 (src/builtins/match.pir:18)␤»

[21:13] <mberends> rakudobug, anyone?

[21:14] <masak> mberends: that syntax is deprecated.

[21:14] <jnthn> mberends: No, that code is wrong.

[21:14] <mberends> good, then I can stand corrected!

[21:14] <jnthn> try /<G::b>/

[21:15] <mberends> ok, thanks!

[21:15] <jnthn> e.g. "b" ~~ /<G::b>/

[21:15] <masak> mberends: I have at least two things I want to talk to you about. :) but I don't have time tonight.

[21:15] <jnthn> The other way did work in Rakudo for a while, but due to a shortcoming in Rakudo rather than because it was spec. :-)

[21:15] *** |jedai| left
[21:16] <masak> we used that shortcoming a bit too much in November :P

[21:16] *** |jedai| joined
[21:17] <mberends> masak: and my internet this week is an unreliable hotel wifi. I also want to discuss u4c and other matters with you.

[21:17] <masak> aye, that's one of the things.

[21:17] <mberends> sign me up, anyways

[21:17] <masak> consider it done.

[21:18] <diakopter> @tell ruoso never mind; pmurias informed me libpcl wasn't strictly necessary

[21:18] <lambdabot> Consider it noted.

[21:24] <perl7> when will be the next version of parrot released?

[21:25] <PerlJam> perl7: today

[21:25] *** gravity joined
[21:25] <perl7> nice! 0.9?

[21:25] *** gravity left
[21:26] *** gravity joined
[21:31] *** |jedai| left
[21:33] *** |jedai| joined
[21:43] <diakopter> pmurias: are you around for smop building help?

[21:51] <pmurias> diakopter: sort of 

[21:52] *** [particle] joined
[21:52] *** pmurias left
[21:53] *** pmurias joined
[21:54] <diakopter> pmurias: build\idconst.o: In function `SMOP__NATIVE__idconst_createn':

[21:54] <diakopter> C:/Users/mwilson/source/pugs/v6/smop/build/idconst.c:132: undefined reference to `_imp__pthread_rwlock_rdlock'

[21:54] <pugs_svn> r24978 | moritz++ | [irclog] try to make things like 'tt #202' link to trac tickets

[21:55] <diakopter> but the pthread.h it's using definitely defines pthread_rwlock_rdlock (but I don't know about the _imp__ prefixed one)

[21:56] <diakopter> though there are some cases in the pthread.h where it wouldn't define most/certain things

[21:56] <pugs_svn> r24979 | moritz++ | [irclog] fix typo in regex

[21:57] <pmurias> diakopter: dunno

[21:57] <pmurias> diakopter: you could #define all the pthread stuff to empty strings

[21:58] <pmurias> as we don't depend on multi threading for now

[21:58] <diakopter> okay... do you know what the _imp__ prefix is/does?

[21:58] <pmurias> no

[21:59] <diakopter> oh; it might be a windows thing

[22:00] <pmurias> i don't have anything like that in my pthread.h

[22:00] <pmurias> what compiler are you using?

[22:01] <diakopter> gcc

[22:01] <diakopter> 3.4.5 I think

[22:01] <diakopter> on mingw

[22:01] <diakopter> no it's not in my pthread.h

[22:03] <pmurias> i see it mentioned in http://www.phpman.info/index.php/info/gcc

[22:03] <pmurias> the _imp__

[22:03] <pmurias> prefi

[22:03] <pmurias> x

[22:06] <pmurias> diakopter: your compiler wasn't shipped with Dev-C++ right?

[22:08] *** nihiliad joined
[22:08] <diakopter> pmurias: no..

[22:08] <diakopter> it's the gcc/mingw bundled with strawberry-portable

[22:09] <diakopter> with mingw32-dlfcn-0-0.3.r11 and mingw32-pthreads-2.8.0-3 added in

[22:09] *** [particle]1 left
[22:12] *** perl7 left
[22:13] *** mberends left
[22:16] <pmurias> diakopter: you could try "#define pthread_rwlock_rdlock(...) "

[22:17] <pmurias> i'm really clueless about windows so i can't help you much with getting pthread to work there

[22:22] *** cosimo left
[22:28] *** jhorwitz left
[22:28] *** mberends joined
[22:29] <moritz_> rakudo: class Object is also { method perl { 'faked' } }; class A { }; say A.new.perl;

[22:29] <p6eval> rakudo 35840: OUTPUT«faked␤»

[22:29] <moritz_> rakudo++

[22:30] <moritz_> rakudo: class Object is also { method w { self.WHAT } }; class A { }; say A.new.w

[22:30] <p6eval> rakudo 35840: OUTPUT«A␤»

[22:30] <PerlJam> jonathan++  pmichaud++ even

[22:30] <moritz_> aye

[22:32] *** |jedai| left
[22:33] *** pmurias left
[22:34] *** |jedai| joined
[22:36] <mberends> this diagnostic used to work, but not now, please help: perl6 -e '$*ERR.say: "hello";' # result: Cannot write to a filehandle not opened for write

[22:37] <moritz_> mberends: please submit a bug report

[22:37] <moritz_> that's one of the things we can't test yet with pure Perl 6 tests :(

[22:37] <mberends> ok, will do.

[22:37] <moritz_> so it's not tested, and breaks frequently

[22:38] <diakopter> pmichaud: ok thanks

[22:38] <diakopter> oops

[22:38] <diakopter> pmurias: ok thanks

[22:39] *** wknight8111 joined
[22:52] *** masak left
[22:56] *** _jedai_ joined
[22:58] *** |jedai| left
[23:04] <mberends> moritz_: $*ERR bug is RT#62540. If I can figure out a spectest using perl5 qx(), should I submit a patch or could I commit the test to pugs?

[23:04] *** Exodist left
[23:04] *** eric256 left
[23:05] <moritz_> mberends: the spectests should be pure Perl 6. But feel free to write a rakudo specific test for now

[23:05] <moritz_> using perl 5, that is

[23:05] <moritz_> and attach it to the ticket

[23:06] <mberends> will do, cannot promise a test because capturing stderr might be tricky. shades of open3()...

[23:09] <nihiliad> Based on the advice of masak++ yesterday, I built Parrot and Rakudo and ran "make test && make spectest", in preparation for writing tests based on the synopses. Any particular place I should start in the synopses? Anyone else working on this, with whom I should coordinate?

[23:10] *** iblechbot left
[23:11] <mberends> moritz++ is our testking, and masak++ is bugking

[23:11] *** pbuetow left
[23:11] <moritz_> nihiliad: please consult http://svn.pugscode.org/pugs/t/TASKS

[23:12] <moritz_> nihiliad: it contains a list of things that need to be done. If none of them is of your liking, just say here "I'm now writing a test for $feature", we don't need more coordination right now

[23:13] <nihiliad> moritz_: Thanks! Just what I was looking for.

[23:14] <mberends> nihiliad: several people are planning similar work, see backlogs http://irclog.perlgeek.de/perl6

[23:14] <moritz_> but on the other hand the test suite is *so* large, that even with uncoordinated work collisions are rare

[23:15] <moritz_> just commit early, commit often

[23:16] *** _jedai_ left
[23:17] *** |jedai| joined
[23:30] *** vixey left
[23:40] <rakudo_svn> r35844 | chromatic++ | [languages] Fixed POD formatting errors.

[23:55] *** mberends left
[23:56] *** |jedai| left
[23:57] *** |jedai| joined
[23:57] <pugs_svn> r24980 | lwall++ | [STD] head off attempt to use C-style for loop

