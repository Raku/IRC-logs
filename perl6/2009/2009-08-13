[00:00] <TimToady> and probably currently for my @array is StrangeArray you end up creating a normal array container and then throwing it away when you see the "is"

[00:00] <pmichaud> that's fine

[00:00] <pmichaud> we can certainly patch in that case as well without difficulty.

[00:00] <pmichaud> (same as how we currently do "is also" and other things)

[00:01] <pmichaud> anyway, if it's likely that contextual declarations will change, it would be extra-helpful to me to know a few more details before I do my next set of refactors :-)

[00:01] <pmichaud> since contextuals are one of the big pieces we're missing at the moment that we've decided we need

[00:01] <TimToady> fershure

[00:02] <TimToady> and I'm all in favor of radically simplifying things for the implementors to the extent that they don't complexify things for the users

[00:02] <TimToady> (Lisp need not apply)

[00:02] *** winthrowe joined
[00:04] <pmichaud> I'm at least 1-2 weeks away from the point of needing the details, though

[00:04] <pmichaud> since most of this week will be taking up with family stuff, and there's about a week of prep-work for the other parts of the refactoring

[00:05] <pmichaud> *taken

[00:05] <pmichaud> (man I can no longer type anymore.  Or my fingers type much faster than my brane)

[00:06] <TimToady> I find my hemispheres desync more frequently as I get older.  And I'm of two minds about that...

[00:06] <pmichaud> heh

[00:06] <pmichaud> afk for a bit

[00:07] * Limbic_Region recently learned how dolphins sleep

[00:07] *** SmokeMachine joined
[00:07] <Limbic_Region> they have severed hemispheres - for 8 hrs a day both halves are awake, 8 hours 1/2 sleeps and the other for the remaining 8

[00:09] *** frew__ left
[00:17] <ruoso> TimToady, if we think on "is context" as marking the lexical scope instead of the container... shouldn't it be a different scope declarator instead of a trait?

[00:19] *** cdarroch left
[00:25] *** nihiliad joined
[00:26] <pmichaud> "is context" marks a dynamic scope more than a lexical one.

[00:27] <ruoso> pmichaud, but the point is that this mark is not in the container, as a trait sounds

[00:27] <pmichaud> ruoso: that's reasonable, yes.

[00:35] *** nihiliad left
[00:41] <TimToady> that's what I was saying above, basically

[00:41] <TimToady> using the * twigil is a mark in the symbol table

[00:41] *** Whiteknight left
[00:41] <TimToady> but we probably leave the rw/ro up to the container

[00:43] <ruoso> TimToady, but how do you declare for the first time?

[00:43] <TimToady> it's really important for threading to know whether a contextual value can be treated as immutable, so that should be the default, I think

[00:43] <TimToady> at the moment thinking context $*x vs temp$*x

[00:44] <TimToady> the difference being whether it defaults to empty or the outer value

[00:45] <TimToady> and "context $*x is rw" would make it mutable, otherwise immutable after initialization, a dynamic constant

[00:47] <ruoso> after initialization is an important point...

[00:47] <TimToady> and maybe temp would only be allowed on rw, otherwise you have to redeclare an "outermost" with context

[00:48] <TimToady> point is whether you can rely on just copying the values into the subthread

[00:48] <TimToady> or whether you have to track an object outside your thread

[00:48] <TimToady> in which case you copy in the ref rather than the value

[00:49] <ruoso> can we consider only readonly for 6.0.0?

[00:49] <TimToady> I use rw in STD, so no :P

[00:50] <TimToady> context vars are essentially just implicit parameters that can be used to pass data either in or out

[00:50] <TimToady> we optimizer for in, rather than out

[00:50] <TimToady> s/r//

[00:50] <pmichaud> are you thinking we'd lose the possibility of having something lexically rw but contextually ro ?

[00:51] <TimToady> potentially

[00:51] <ruoso> that seems what it looks like

[00:51] <pmichaud> I don't see a bit issue with that.

[00:51] <pmichaud> *big

[00:51] <pmichaud> (arrrgh)

[00:52] <ruoso> but I'm not quite sure how to make it "readonly after first initialized"

[00:52] <ruoso> execpt for a big "if"

[00:52] <pmichaud> we have to do something like that for "constant" anyway

[00:52] * ruoso trying to think in a more elegant approach

[00:52] <ruoso> indeed

[00:53] <TimToady> it's kind of a single assignment sort of notion, so I think it's already almost elegant :)

[00:53] <pmichaud> single assignment as in...    (more)

[00:53] <pmichaud> constant $x;  $x = 5;   # valid ?

[00:53] <TimToady> no

[00:54] <TimToady> basically only "my $x = 5" if you are strict about it

[00:54] <pmichaud> you mean  "constant $x = 5"?

[00:55] <TimToady> no, that's constant at compile time

[00:55] <pmichaud> okay.

[00:55] <TimToady> you can do single assignment at run time

[00:55] <TimToady> you just never modify a value once set

[00:55] <TimToady> from, say, the previous loop iteration

[00:55] <TimToady> and $i++ is right out :)

[00:56] <TimToady> it's a style that some poeple will want to enforce on themselves

[00:56] <TimToady> as a way of reducing side effects, which will never interact well with laziness

[00:56] <TimToady> have to run off for a bit &

[00:57] <cognominal> happy birthday pmichaud 

[00:59] <pmichaud> cognominal: thank you :-)

[00:59] <cognominal> thx facebook.

[01:00] <cognominal> wish my family was in facebook...

[01:01] <dalek> rakudo: 1e358a9 | pmichaud++ | docs/spectest-progress.csv:

[01:01] <dalek> rakudo: "2009-08-12 00:00",a5dfe96,12303,0,535,2260,15098,17636,428

[01:01] <dalek> rakudo: spectest-progress.csv update: 428 files, 12303 passing, 0 failing

[01:01] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1e358a92dcdabf12d71d0773bd06e192067943cf

[01:04] *** eternaleye left
[01:05] *** sri_kraih left
[01:06] *** rfordinal left
[01:10] *** jdv79 joined
[01:11] <jdv79> how come the spectest target for rakudo tries to run invalid tests?

[01:11] <pmichaud> which tests are "invalid"?

[01:12] *** tak11 joined
[01:13] <jdv79> t/spec/S02-builtin_data_types/parsing-bool.t ................... No subtests run

[01:13] <jdv79> there are lots like that

[01:14] <pmichaud> that seems odd.  They pass on my system.

[01:14] <jdv79> oh, maybe something is broke here.  i'll poke around.

[01:17] <jdv79> definitely hosed over here.  thanks.

[01:21] *** dukeleto left
[01:22] *** duckyd left
[01:26] *** KyleHa joined
[01:28] *** SmokeMachine left
[01:38] *** stimpi joined
[01:40] *** eternaleye joined
[01:44] *** stimpi left
[01:50] *** meppl left
[01:50] *** kane__ left
[01:53] *** dukeleto joined
[01:56] *** nihiliad joined
[02:08] *** molaf joined
[02:10] *** Limbic_Region left
[02:17] *** nihiliad left
[02:28] *** snarkyboojum left
[02:45] *** nihiliad joined
[02:46] <dalek> rakudo: 2befdd3 | pmichaud++ | src/ (2 files):

[02:46] <dalek> rakudo: Move infix:<x> to setting.

[02:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2befdd3874d6fe7f93ed1d9714b0dd2a52bad6f2

[02:46] <dalek> rakudo: 4e906bc | pmichaud++ | :

[02:46] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[02:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4e906bcfff861aa74665a690635c014764af3715

[02:55] <ruoso> http://daniel.ruoso.com/categoria/perl/smopp5-first-steps

[02:56] *** rdice left
[03:00] <KyleHa> std: say "\x[ c4, 20, c4 ]";

[03:00] <p6eval> std 27972:  ( no output )

[03:01] <KyleHa> p6eval bein' a slow poke?

[03:01] <KyleHa> std: say "\x[ c4, 20, c4 ]";

[03:01] <p6eval> std 27972:  ( no output )

[03:02] *** molaf left
[03:06] *** Psyche^ joined
[03:07] <KyleHa> std: say "\x[ c4, 20, c4 ]";

[03:07] <p6eval> std 27972: OUTPUT«ok 00:04 37m␤»

[03:12] *** nihiliad left
[03:12] *** nihiliad joined
[03:16] *** makerboy joined
[03:16] *** makerboy left
[03:18] *** Patterner left
[03:18] *** Psyche^ is now known as Patterner

[03:18] *** dukeleto left
[03:19] <pugs_svn> r27973 | kyle++ | [t/spec] Still more RT #64948 tests

[03:19] <pugs_svn> r27974 | kyle++ | [t/spec] Test for RT #64990

[03:19] <pugs_svn> r27975 | kyle++ | [t/spec] Test for RT #65004

[03:19] *** molaf joined
[03:27] <KyleHa> rakudo: given 'foo' { if /bar/ { 1 } }

[03:27] <p6eval> rakudo 4e906b:  ( no output )

[03:30] *** nihiliad left
[03:39] *** dukeleto joined
[03:45] <pugs_svn> r27976 | kyle++ | [t/spec] A test for c[] also

[03:46] *** nihiliad joined
[03:48] *** KyleHa left
[03:48] *** nihiliad left
[03:54] *** jrtayloriv joined
[03:55] <jrtayloriv> What is the rationale for why I have to say 'say $thing.WHAT' rather than 'say $thing.what' -- i.e. why the caps? Is this part of a naming convention or something

[04:00] <PerlJam> uppercase methods are "reserved" by convention.

[04:01] *** nihiliad joined
[04:01] *** abbe joined
[04:02] *** mkfort joined
[04:04] *** simcop2387 joined
[04:05] *** Psyche^ joined
[04:06] <PerlJam> lot of #perl6 joiners suddenly

[04:06] <PerlJam> welcome all!

[04:09] <jrtayloriv> PerlJam -- Where in the docs would I look for what the implications of a method being reserved?

[04:10] <jrtayloriv> Does it just mean that I can't override it with my own definition?

[04:10] <PerlJam> Dunno.  Probably S12.   No, no, you probably *can* override it, but you do so at your own peril.

[04:11] <PerlJam> for instance,  $obj.^methods is a shortcut for calling $obj.HOW.  if you override the HOW method in your class, $obj.^methods may not do something sane.

[04:12] <jrtayloriv> PerlJam: OK, thank you.

[04:13] <PerlJam> But that's a general convention in Perl -- ppercase things belong to Perl.

[04:14] *** zloyrusskiy joined
[04:14] <PerlJam> See BEGIN, CATCH, NEXT, etc.

[04:19] <s1n> pmichaud: what was up with the dallas.p6m wiki thing we were going to have setup?

[04:20] *** dukeleto left
[04:22] *** Patterner left
[04:22] *** Psyche^ is now known as Patterner

[04:27] <PerlJam> s1n: are people showing up for dallas.p6m ?

[04:30] *** jrtayloriv left
[04:31] <s1n> PerlJam: our largest meeting was 8

[04:32] <s1n> PerlJam: we regularly have 6-8

[04:32] <s1n> including pmichaud and gbarr

[04:36] *** nihiliad left
[04:36] *** abbe left
[04:43] *** kane_ joined
[04:45] *** tak11 left
[04:49] *** alester__ joined
[04:56] *** kane_ left
[05:01] <dalek> rakudo: 69eee0d | pmichaud++ | docs/release_guide.pod:

[05:01] <dalek> rakudo: Add chromatic as December release manager.

[05:01] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/69eee0d01659803bdf05986cc8e429aa9a10e004

[05:07] *** dukeleto joined
[05:15] *** hercynium left
[05:38] *** tak11 joined
[05:42] *** dukeleto_ joined
[05:45] *** orafu left
[05:45] *** orafu joined
[05:47] *** rfordinal joined
[05:48] *** dukeleto left
[05:57] *** dukeleto_ left
[06:00] *** guest_007 left
[06:21] *** alester__ left
[06:28] *** rfordinal left
[06:42] *** mberends joined
[06:54] <moritz_> phenny: tell KyleHa in r27973 you test for %(...).exists. Note that Hash.exists is a Rakudo workaround for %hash{$item}:exists, not part of the spec

[06:54] <phenny> moritz_: I'll pass that on when KyleHa is around.

[07:05] *** rfordinal joined
[07:09] *** Su-Shee joined
[07:09] <Su-Shee> good morning.

[07:11] <moritz_> oh hai

[07:18] *** tann joined
[07:19] <tann> rakudo: my %h; push %h<k>, 1, 2, 3; say %h.perl;

[07:19] <p6eval> rakudo 69eee0: OUTPUT«No applicable candidates found to dispatch to for 'push'␤in Main (/tmp/flI9YktQ8J:2)␤»

[07:19] <tann> nyi

[07:24] *** szabgab left
[07:36] *** jd8hh57 joined
[07:43] *** alanhaggai joined
[07:46] *** KatrinaTheLamia joined
[07:50] *** shachaf left
[07:50] <mikehh> rakudo (69eee0d) builds on parrot r40515 - make test/make spectest (up to 27976) PASS - Ubuntu 9.04 amd64

[07:53] *** dukeleto joined
[07:54] <eternaleye> rakudo: my %h; push @( %h<k> ), 1, 2, 3; say %h.perl

[07:54] <p6eval> rakudo 69eee0: OUTPUT«No applicable candidates found to dispatch to for 'push'␤in Main (/tmp/y9tge8pN3p:2)␤»

[07:55] <eternaleye> rakudo: my %h; @( %h<k> ).push: 1, 2, 3; say %h.perl

[07:55] <p6eval> rakudo 69eee0: OUTPUT«too many arguments passed (4) - 2 params expected␤in Main (/tmp/s3epu3zy3o:2)␤»

[07:56] *** szabgab joined
[07:57] <tann> rakudo: .say for qqx/ls -la/;

[07:57] <p6eval> rakudo 69eee0: OUTPUT«operation not permitted in safe mode␤in Main (lib/Safe.pm:25)␤»

[07:57] *** xinming left
[07:58] <lisppaste3> tann pasted "qqx test output" at http://paste.lisp.org/display/85304

[07:58] <tann> ^^^ qqx doesn't behave right?

[07:59] <eternaleye> tann: No, it's correct

[08:00] <eternaleye> qx and qqx produce a string, not an array

[08:00] <eternaleye> the string just happens to contain newlines

[08:00] <tann> eternaleye: no longer multiple lines in list context?

[08:00] <eternaleye> use qqx/foo/.split("\n")

[08:01] <tann> so quite differently from p5's qx or `` ?

[08:01] <eternaleye> tann: There really is no 'list context' or 'scalar context' any more, just type coercions

[08:03] <eternaleye> For instance, () creates a 'Nil' object, which can be both a null value 'undef' when treated as a scalar, or an empty list () when treated as a list

[08:04] <moritz_> but a particular function or method can't know if it's called in list context or in item context

[08:05] <eternaleye> tann: The p5 model of 'context' flowing inward is fundamentally incompatible with multiple dispatch.

[08:05] *** zloyrusskiy left
[08:05] <tann> ok, thanks for the explanation

[08:06] *** zloyrusskiy joined
[08:06] <damyan^> hi. guys. i got a dumb regex-question - hi would i match "anything not starting with '+' or '-'"?

[08:06] <damyan^> ^([^+]&[^-]) seems not to be what I'm looking for...

[08:07] <moritz_> damyan^: in Perl 6 with / ^ <-[+-]> /

[08:07] *** rfordinal3643 joined
[08:07] <moritz_> damyan^: for Perl 5 you're in the wrong channel

[08:07] <damyan^> moritz_: thanks.

[08:07] <tann> perl 5 is /^[^+-]/ :)

[08:08] *** guest_007 joined
[08:08] <tann> so <- replaces [^ now

[08:09] <tann> me likes me likes

[08:10] *** damyan^ left
[08:14] *** rfordinal3643 left
[08:14] *** szabgab left
[08:14] *** rfordinal left
[08:14] *** mikehh left
[08:14] *** iblechbot left
[08:14] *** payload left
[08:14] *** synth left
[08:14] *** s1n left
[08:14] *** Lorn left
[08:14] *** lisppaste3 left
[08:14] *** elmex left
[08:14] *** bionoid left
[08:14] *** arthur-_ left
[08:14] *** gabiruh left
[08:14] *** nsh left
[08:14] *** sbp left
[08:14] *** cxreg left
[08:14] *** mj41 left
[08:14] *** omega left
[08:14] *** mattp_ left
[08:15] *** renormalist joined
[08:16] *** rfordinal3643 joined
[08:16] *** szabgab joined
[08:16] *** rfordinal joined
[08:16] *** mikehh joined
[08:16] *** iblechbot joined
[08:16] *** payload joined
[08:16] *** synth joined
[08:16] *** s1n joined
[08:16] *** Lorn joined
[08:16] *** lisppaste3 joined
[08:16] *** elmex joined
[08:16] *** bionoid joined
[08:16] *** arthur-_ joined
[08:16] *** gabiruh joined
[08:16] *** nsh joined
[08:16] *** sbp joined
[08:16] *** cxreg joined
[08:16] *** mj41 joined
[08:16] *** omega joined
[08:16] *** mattp_ joined
[08:20] *** pmurias joined
[08:24] *** tann left
[08:24] *** rfordinal left
[08:32] <Matt-W> Morning

[08:41] *** xinming joined
[08:43] *** jferrero joined
[08:46] *** kane_ joined
[08:46] *** masak joined
[08:48] <masak> be greeted, #perl6.

[08:48] <phenny> masak: 12 Aug 21:11Z <jnthn> tell masak submethod BUILD(Druid::Game :$game!, Int :$color! where { $_ == 1|2 }) { # can just write where 1|2

[08:48] <frettled> good morning :D

[08:48] <masak> jnthn: gracias.

[08:48] <masak> mberends: ping.

[08:48] <frettled> pmichaud++ (happy birthday)

[08:48] *** xinming left
[08:48] <masak> oh, it's pmichaud's birthday today?

[08:49] *** xinming joined
[08:49] *** synth left
[08:49] <frettled> Yep, the other day, he told us he's born on Friday 13th.

[08:49] <frettled> This is what I've been saying for nearly thirty years: Friday 13th is a lucky day.

[08:50] * masak believes it's orthogonal to luck

[08:50] <masak> that's the thing about stochastic variables, see: they're independent of most things. :)

[08:51] <masak> phenny: tell KyleHa that I think the 'return fail()' in his recent RT #64990 test looks a bit redundant. shouldn't 'fail()' be sufficient?

[08:51] <phenny> masak: I'll pass that on when KyleHa is around.

[08:51] <frettled> masak: I like to think of luck as a stochastic constant

[08:52] *** kane_ left
[08:52] <masak> frettled: you may do that. in the end, it might all come down to definitions whether we agree or not.

[08:52] <Matt-W> luck is an illusion

[08:54] <masak> I'd buy that.

[08:54] <Matt-W> on a t-shirt?

[08:55] <frettled> masak: insert smiley at appropriate place in previous statement :)

[08:57] *** eMaX joined
[08:57] *** xinming left
[08:57] *** xinming joined
[08:58] <frettled> Matt-W: on a shoulder bag, while you wear a Google «I'm feeling lucky» t-shirt

[08:58] <masak> frettled: oh, sure. I just have a tendency to answer seriously no matter what the jokinglyness of the thing I reply to.

[08:58] <frettled> masak: ouch, you're too much like me in that regard.

[08:59] <frettled> BTW, wouldn't it be nicer if we had a sofa in here?

[08:59] <masak> frettled: I've been wanting one for years!

[08:59] <Matt-W> frettled: no, I'd prefer the primary message to be primary

[08:59] <masak> standing up makes my legs sore.

[09:02] *** xinming_ joined
[09:05] <frettled> If I've read the synopsis right, $foo = <<EOF; (…stuff…) EOF  has been replaced with $foo = q:to/EOF/; (…stuff…) EOF

[09:05] <masak> frettled: indeed.

[09:06] <frettled> or qq:/to/EOF/ if I want interpolation

[09:07] <cono> q:to/.*EOF$/ ?

[09:09] <frettled> But, AFAICT, this doesn't yet work in rakudo, or am I missing something?

[09:12] <masak> it doesn't yet work in Rakudo.

[09:12] <masak> it's pending grammar updates.

[09:13] *** EDevil joined
[09:19] <frettled> aha

[09:21] *** sri_kraih joined
[09:21] <Matt-W> is it one of the things we should get when Rakudo's using STD.pm?

[09:21] <moritz_> yes

[09:22] <moritz_> I'm really looking forward to that day.

[09:22] <Matt-W> me too

[09:22] <Matt-W> s/// as well :D

[09:24] <masak> and macros!

[09:24] <masak> I predict macros will be as much of a killer feature as grammars.

[09:25] <moritz_> how much macros does STD.pm do?

[09:25] *** xinming left
[09:26] <masak> good question!

[09:27] <masak> std: macro foo { "I CAN HAZ MACROS!?" }; say foo

[09:27] <p6eval> std 27976: OUTPUT«ok 00:04 37m␤»

[09:28] <masak> I can't think of a way to test it in better detail.

[09:28] <moritz_> std: macro infix:<|||>($a, $b) { quasi {{{ $a + $b }}} }; 4 ||| 5

[09:28] <p6eval> std 27976: OUTPUT«ok 00:03 41m␤»

[09:29] <Matt-W> I'd need to learn exactly how it works first

[09:29] <masak> ah, good idea.

[09:29] <Matt-W> moritz_: what does 'quasi' mean?

[09:29] <masak> Matt-W: think "subroutines called at compile time"

[09:29] <moritz_> Matt-W: it's a quoting construct that turn perl code into syntax trees

[09:29] <moritz_> it means "don't run this thing, but return (and interpolate) the AST it generated"

[09:30] * masak tries not to drool

[09:30] <moritz_> (if I understood that correctly)

[09:31] <Matt-W> ah

[09:31] <Matt-W> so that's how you replace a macro invocation with a different bit of code

[09:31] <moritz_> std: macro moose () { quasi { $COMPILING::x } }; moose() # should be an error because $x as not defined where moose() is called

[09:31] <p6eval> std 27976: OUTPUT«ok 00:03 40m␤»

[09:33] <masak> moritz_: but should STD.pm detect it? it only does syntax checks.

[09:34] <moritz_> masak: that's a tough question

[09:34] <moritz_> it *is* a syntax check

[09:34] <moritz_> but one that requires to run code at compile time

[09:34] <moritz_> d'oh

[09:34] <masak> tough indeed.

[09:36] * moritz_ notes that d'oh is a valid identifier in Perl 6

[09:36] <frettled> hehe

[09:38] *** xinming_ left
[09:41] *** _timbunce joined
[09:44] <mberends> masak: pong

[09:44] <masak> mberends: oh hai. sorry I'm late. my body overslept today.

[09:44] <masak> it's funny, I got up without a problem every day in Lisbon. at home it's harder.

[09:46] <mberends> :) I'm expecting interruptions soon, so shall we discuss HTTP::Daemon?

[09:46] <cono> masak: u need to have everyday conference at 9:00 :D

[09:46] <masak> cono: yes, that'd really help.

[09:46] <frettled> masak: it's the time differential and jet lag, combined with a low sunspot activity

[09:47] <cono> and early breakfast at alif...

[09:47] <masak> mberends: I'm currently 80% preoccupied at $WORK, but let's try.

[09:47] <frettled> cono: and the Portuguese pastries, which helped me gain nearly 3 kg.

[09:47] <masak> mberends: the objective is to abstract away H::D into a Web::Handler.

[09:48] <masak> mberends: Rack contains all the prior art we need. seems to me Rack::Handler::Webrick is a good template to start from.

[09:48] <cono> frettled: what about Radisio ? :D

[09:48] *** wknight8111 joined
[09:48] *** donaldh joined
[09:49] *** alanhaggai left
[09:51] <jnthn> oh hai

[09:51] <mberends> masak: does Webrick also run as the application main process, calling back other handlers when browser requests arrive?

[09:51] <masak> mberends: yes, I think so.

[09:51] <masak> jnthn: o/

[09:51] <mberends> jnthn: hi

[09:51] <cono> jnthn: privet :D

[09:52] <mberends> oh, visitors. afk &

[09:53] <frettled> cono: what's Radisio?

[09:54] <cono> frettled: oh, it will be hard w/ my english :D

[09:54] <cono> frettled: you was at yapc party?

[09:55] *** xinming joined
[09:55] <cono> some restaurants purpose this stuff, when they bring meet meet meet :D

[09:55] <cono> near hotel alif was restaraunt w/ radisio

[09:56] <cono> so many restaraunts w/ radisio in Lisbon

[10:01] *** xinming left
[10:03] <jnthn> cono: привет :-)

[10:04] <jnthn> masak: Sleep's a weird thing. I epicly failed to fall asleep last night and thus spent most of the morning sleeping. :-/

[10:05] <cono> :D

[10:09] <masak> jnthn: I have this bug in my awakening program right now: I wake up, get up, detect how tired I am, and go back to bed. thus, I'm never tired enough in the evenings, and I fall asleep too late.

[10:10] * jnthn files masakbug

[10:10] <jnthn> ;-)

[10:11] <masak> oh, if t'were that simple! :/

[10:13] <Matt-W> it's simple

[10:13] <Matt-W> it's just not easy to fix

[10:13] *** payload left
[10:13] <Matt-W> I'm sure your parents were advised about getting your system software written in INTERCAL

[10:14] <EDevil> cono: It's called Rodisio. :)

[10:14] <jnthn> So the fix is COMEFROM BED ?

[10:15] * masak likes how Threaded INTERCAL allows threads simply by allowing multiple COME FROMs from the same label

[10:18] *** xinming joined
[10:20] *** iblechbot left
[10:22] <cono> EDevil: ah, my bad :D Thanks

[10:22] <Matt-W> jnthn: yes but where?

[10:23] <Matt-W> masak: that's very much in keeping with the INTERCAL spirit

[10:24] <masak> Matt-W: so is the later-added I/O. I'm still not sure I grok that part.

[10:25] <Matt-W> I don't grok any of it to the point where I could write anything non-trivial in it

[10:26] *** wknight8111 left
[10:26] <jnthn> Matt-W: Probably somewhere near COFFEEMACHINE ;-)

[10:27] <Matt-W> :)

[10:27] <Matt-W> or in the Perl 6 module

[10:27] <Matt-W> because then he arrives somewhere interesting

[10:29] *** Patterner left
[10:30] * jnthn tweaks Parrot's config stuff for his compiler and sees if he can build Rakudo now.

[10:34] <jnthn> Arrgh!

[10:34] <jnthn> It doesn't even copy the .lib file we need into the build tree...

[10:35] <Matt-W> Oh dear

[10:35] * Matt-W is reminded of building some stuff at work recently

[10:36] <Matt-W> including one third-party library that's old enough that the platform I was building it on didn't even exist then

[10:36] <Matt-W> and which apparently had a broken build system in that release anyway

[10:36] *** rdice joined
[10:38] *** xinming_ joined
[10:42] *** Psyche^ joined
[10:43] *** Psyche^ is now known as Patterner

[10:52] *** xinming left
[10:53] *** stepnem left
[10:54] *** ihrd joined
[10:54] *** ihrd left
[10:55] *** xinming joined
[10:55] *** ruoso left
[10:58] *** mikehh_ joined
[11:01] *** xinming_ left
[11:01] <frettled> cono: Yes, I was at the YAPC parties, and EDevil++ for helping me find the Wikipedia article; yes, I really like Rodisio!  That was also a probably cause for my weight increase.

[11:04] <jnthn> Ahh...YAPC parties. :-)

[11:04] <jnthn> Damm, *so* close but still not managed to fix the Rakudo build on MSVC++ :-(

[11:05] <frettled> There was only one downside to the Rodisio dinner: noise.  It was near impossible to hold a conversation there.

[11:12] *** mikehh left
[11:13] *** payload joined
[11:15] *** meppl joined
[11:20] *** donaldh left
[11:20] *** xinming left
[11:21] *** xinming joined
[11:22] *** donaldh joined
[11:22] *** stepnem joined
[11:24] *** stepnem left
[11:26] *** xinming_ joined
[11:29] <masak> could someone explain the "hyperpun" (as implied by TheDamina) in raiph's message?

[11:29] <moritz_> TheDamina? :-)

[11:29] <jnthn> masak: I didn't get it either, fwiw.

[11:30] <masak> moritz_: s/ina/ian/

[11:30] <masak> ("With this whiny man exchange ultimately having bourne supreme fruit, the apocalypse watch for the post damian weekend begins...")

[11:30] <jnthn> Phew, I now have a working Rakudo build again.

[11:30] <moritz_> where was that? p6l?

[11:30] <jnthn> Sorry in advance if my hackings have caused anyone else any breakage, but I'm hopeful not.

[11:31] <jnthn> Though gah, the dependencies are kinda shafted somehow such that make test after make goes and rebuilds a bunch of stuff. HOw wonderful.

[11:31] <masak> moritz_: aye.

[11:33] <masak> ooh! a Perl quiz! it's been a while...

[11:33] *** xinming__ joined
[11:33] <masak> I have a good mind to solve it in Perl 6, of course.

[11:34] *** xinming left
[11:34] <dalek> rakudo: 75293d3 | jnthn++ | build/PARROT_REVISION:

[11:34] <dalek> rakudo: Bump us up to latest Parrot revision to get Win32/MSVC++ install related fixes.

[11:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/75293d3db44760020681bf04e754f475044e8eaf

[11:34] <dalek> rakudo: 0d4fe08 | jnthn++ |  (2 files):

[11:34] <dalek> rakudo: A copule of tweaks to get Rakudo building on MS VC++ and Win32 again after the ins2 branch merge. I'm hopeful that this will not break things too much for @other.

[11:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0d4fe08d2e6f249211a33a8f9b122599fadbe862

[11:36] *** ihrd joined
[11:36] <masak> ihrd: o/

[11:36] <ihrd> masak: :)

[11:37] <ihrd> your presintation is relay cool!

[11:37] <masak> ihrd: thank you. :)

[11:37] <jnthn> BTW, now Rakudo implements .^parents(:tree), it's just begging for somebody to use the SVG module to write a script to plot inheritance charts. ;-)

[11:37] <masak> ihrd: I hope to release the presentation software as a CPAN module.

[11:37] <frettled> masak: Perl quiz? Where?! 

[11:38] <ihrd> masak: are you use p6 in this software?

[11:38] <masak> frettled: on a list called, I think, perl-qotw-discuss.

[11:39] <frettled> masak: aha

[11:39] <masak> ihrd: yes. it will be a p5/p6 twin module. equally runnable on perl and perl6.

[11:39] <moritz_> jnthn: btw build continues to work $here

[11:39] <frettled> masak: where do I subscribe? :D

[11:39] <masak> frettled: I don't have the faintest. google for it.

[11:40] <frettled> masak: I'm feeling lucky.

[11:40] <masak> here we go again. :)

[11:41] <moritz_> ah, the old MJD hat

[11:41] <moritz_> with the links to the archives being 404s

[11:42] <jnthn> moritz_: Great, thank you.

[11:43] <colomon_> rakudo: ((2,3,4) <<*>> (2,2,2,2,2)).perl.say

[11:43] <p6eval> rakudo 69eee0: OUTPUT«[4, 6, 8, 8, 8]␤»

[11:44] *** xinming_ left
[11:44] <moritz_> is <<*>> the "sunshine operator"

[11:45] <colomon_> looks like a flying saucer to me.  :)

[11:45] <pugs_svn> r27977 | pmurias++ | started Inline::Mildew

[11:48] *** jd8hh57 left
[11:48] *** xinming__ left
[11:48] <huf> looks like the big spider: http://www.mobygames.com/game/dos/gobliiins/screenshots/gameShotId,5429/

[11:49] *** payload left
[11:52] <frettled> masak: Apparently, it's not possible to subscribe anymore, hee-hee.

[11:53] <frettled> It's a very exclusive list!

[11:53] <masak> slight spec wording suggestion: for the keys/values/pairs methods in Hash in S32/Containers, change "Iterates the elements of C<%hash> in no apparent order" to "Iterates the elements of C<%hash> in a non-determinable order". what do y'all think?

[11:53] <masak> frettled: is that so! well, I had nothing to do with it. :)

[11:54] *** xinming joined
[11:56] <frettled> masak: perhaps you destroyed it, hmm?  :D

[11:56] <frettled> masak: I'd prefer a choice of words similar to that I changed S09 to ;)

[11:56] <moritz_> masak: I'd rather write "in an arbitrary order"

[11:56] <frettled> But I forgot to fiddle with S32/Containers while I was at it.

[11:57] <masak> moritz_: I liked 'non-determinable', because to me it's more to the point than 'arbitrary'.

[12:00] <frettled> masak: "arbitrary" is more frequently used.

[12:01] <masak> agreed.

[12:01] <masak> but to me, "arbitrary" might as well mean, "the order is fixed by an arbitrary decision of ours".

[12:02] <moritz_> "arbitrary and impleemntation dependent"

[12:02] <moritz_> s/ee/e/

[12:02] <masak> slightly better.

[12:02] *** test_ joined
[12:02] *** ruoso joined
[12:03] *** test_ left
[12:04] <pmurias> ruoso: hi

[12:04] <lambdabot> pmurias: You have 3 new messages. '/msg lambdabot @messages' to read them.

[12:04] <ruoso> hi pmurias 

[12:04] <ruoso> have you seen my blog post?

[12:04] <pmurias> yes

[12:05] <ruoso> do you think it's a good plan?

[12:05] <pmurias> can't think of a different one

[12:05] <frettled> masak: I think the words used in S09 now are "implementation dependent and arbitrary" :)

[12:06] <pmurias> ruoso: we need to have a way of running perl6 code from perl5 to test the perl5 values RI's work correctly

[12:06] <ruoso> pmurias, that is the part of "Implementing the SMOP interpreter and continuation class APIs in the perl5 interpreter"

[12:07] <masak> frettled: that's fine, too; the order of the descriptions doesn't... oh wait. :) have we gotten stuck in a metacircular discussion?

[12:07] *** xinming_ joined
[12:07] <frettled> masak: or a circular metadiscussion?

[12:08] <masak> halp!

[12:08] <ruoso> or a meta-masak and meta-frettled circling discussion?

[12:08] <frettled> Oh, freddled gruntlebuggit, thy micturations are to me ...

[12:08] <pmurias> ruoso: we might want to do before filling in the RI's for SV* as we should be able to test things before we implement them

[12:09] <pmurias> s/do/do that/

[12:13] *** xinming left
[12:15] <pmurias> ruoso: you are aware how the current perl5 intergration works?

[12:16] <lisppaste3> frettled pasted "S32/Containers iterator rephrase" at http://paste.lisp.org/display/85318

[12:17] <masak> frettled: I like.

[12:17] <moritz_> +1

[12:17] <frettled> goodie.

[12:19] *** KyleHa joined
[12:19] <moritz_> rakudo: say *.()

[12:19] <p6eval> rakudo 0d4fe0: OUTPUT«invoke() not implemented in class 'Undef'␤in Main (/tmp/Bb59HvSYH9:2)␤»

[12:19] <ruoso> pmurias, adding the RI slot to SV* can be tested at first with the current p5 test suite

[12:19] <pugs_svn> r27978 | jani++ | S32/Containers iterator rephrase (similar to S09 hash keys spec)

[12:19] <ruoso> it shouldn't cause any trouble in p5 code

[12:19] * moritz_ tries to make that a closure that invokes its first argument, and fails

[12:20] <ruoso> pmurias, I'm aware current integration works, and I'm counting on it for the item 3

[12:20] <ruoso> pmurias, after having the perl5 interpreter as the smop interpreter

[12:20] <ruoso> we're going to use the current scheme to allow p5 code to call smop code

[12:21] *** jd8hh57 joined
[12:21] <KyleHa> Good morning, #perl6!

[12:21] <phenny> KyleHa: 06:54Z <moritz_> tell KyleHa in r27973 you test for %(...).exists. Note that Hash.exists is a Rakudo workaround for %hash{$item}:exists, not part of the spec

[12:22] <phenny> KyleHa: 08:51Z <masak> tell KyleHa that I think the 'return fail()' in his recent RT #64990 test looks a bit redundant. shouldn't 'fail()' be sufficient?

[12:22] <masak> yo, KyleHa.

[12:22] <KyleHa> Yes, 'return fail()' is a little redundant, but I don't think it's wrong.

[12:23] <KyleHa> Seems like { 1 } vs. { +1 } to me.

[12:23] <masak> KyleHa: then I think it's more redundant than you think.

[12:23] *** jferrero left
[12:23] <masak> KyleHa: fail() already exits the sub.

[12:23] <moritz_> I agree it's not wrong, though

[12:23] <masak> sure, but it looks slightly unprofessional.

[12:23] <moritz_> the arguments of return() are evaluated before the actual return

[12:24] <KyleHa> I'm shocked to find that .exists is not part of the spec.  I'll have to rework that stuff.

[12:24] <masak> it's no better than 'return return 42'

[12:24] <pmurias> ruoso: the right place to set the RI on SV* seems to be new_SV

[12:24] <moritz_> masak: this is the test suite. We test weird cases, and don't have to look professional at all

[12:24] <KyleHa> Oh, I get it.  I forgot that fail() exits.  So it's like { exit die }

[12:24] <moritz_> IMHO we should  have both

[12:24] <masak> KyleHa: yes.

[12:24] <ruoso> pmurias, we first need to initialize the RI

[12:24] <moritz_> one fail(), and one 'return fail()'

[12:25] <masak> moritz_: I think I worded that wrong. it looks as if the test writer misunderstood the semantics of fail().

[12:25] <ruoso> pmurias, and we probably need to set the SV RI into some var of the perl interpreter, so it can know it

[12:25] <masak> moritz_: which, without a comment, is confusing to the reader.

[12:25] <moritz_> masak: agreed

[12:25] *** zamolxes joined
[12:27] <pmurias> ruoso: so how is our initialisation sequence supposed to look like?

[12:27] <ruoso> we need to inject the intialization of the p5 RIs in the PerlInterpreter initialization

[12:27] <ruoso> and probably inject other initializations as well

[12:28] <pmurias> and where is the polymorphic runloop initalised?

[12:28] <ruoso> in the p5 interpreter itself

[12:29] <pmurias> we need the p5 runloop to load Coro

[12:29] <jnthn> loliblogged

[12:29] <jnthn> http://use.perl.org/~JonathanWorthington/journal/39455

[12:33] <frettled> jnthn++ - I think that's the first explanation .HOW I actually think I understood.

[12:33] <KyleHa> moritz_: So anything that says .can( 'exists' ) or .exists( $x ) is bogus?  Should the bug itself be rejected, or do I just change my syntax?

[12:34] <KyleHa> rakudo: say %( 'foo' ~~ /<alpha> oo/ ){ 'alpha' }:exists

[12:34] <p6eval> rakudo 0d4fe0: OUTPUT«Statement not terminated properly at line 2, near ":exists"␤in Main (src/gen_setting.pm:3369)␤»

[12:34] *** takadonet joined
[12:34] <moritz_> the adverb form is NYI

[12:34] <takadonet> morning all

[12:34] <ruoso> pmurias, maybe we can get the lowlevel Coro part before the high-level

[12:35] <moritz_> KyleHa: I don't remember the bug report. In some sense it's sensible to expect normal Hash behaviour from whatever %(...) returns...

[12:36] <moritz_> but still we can't put a test for this in the spectests, because "normal hash behaviour" doesn't conform to current specs right now

[12:36] <masak> rakudo: class A {}; class B is A {}; class C is A {}; class D is B is C {}; say D.^parents(:tree).perl

[12:36] <p6eval> rakudo 0d4fe0: OUTPUT«[[B, [A, [Any, [Object]]]], [C, [A, [Any, [Object]]]]]␤»

[12:36] <masak> ah. nice.

[12:36] <pugs_svn> r27979 | kyle++ | [t/spec] Test fail() and return fail() both

[12:37] <moritz_> indeed. jnthn++

[12:37] <masak> strangely enough, I get a Null PMC access locally.

[12:37] <ruoso> jnthn++

[12:37] <masak> on a fairly new Parrot and Rakudo.

[12:37] <Matt-W> jnthn++

[12:37] <ruoso> jnthn, anyway... any idea of when lazyness gets to be implemented?

[12:38] <pmurias> ruoso: so when do we initialise the RI's?

[12:38] <pmurias> perl_construct?

[12:38] <ruoso> I guess

[12:39] <jnthn> ruoso: Before Rakudo * ;-)

[12:39] <jnthn> ruoso: pmichaud++ will be taking on the initial refactor to get us in that direction.

[12:39] <jnthn> ruoso: But some PGE refactors that are blocking other things are higher priority.

[12:40] <pugs_svn> r27980 | kyle++ | [t/spec] Cut out the tests for RT #64948

[12:40] <pugs_svn> r27980 | kyle++ | 

[12:40] <pugs_svn> r27980 | kyle++ | The tests as written don't conform to the spec.  I'm cutting instead of

[12:40] <pugs_svn> r27980 | kyle++ | fixing due to time constraints with intent to return to this later.

[12:40] <ruoso> right

[12:40] <masak> (PGE refactors)++

[12:40] <jnthn> So I'm not completely sure where it is on pm's schedule.

[12:40] <moritz_> is it the dreaded isa-RPA vs. has-a-RPA refactor that's needed?

[12:41] <jnthn> For one, I want to move our lexical and scope handling to be more what STD does, but that blocks on contextuals, which blocks on PGE progress.

[12:41] <jnthn> moritz_: Yes, it is.

[12:41] <KyleHa> Thanks for your supervision, moritz++ and masak++  I feel much more comfortable going forth with my best guesses knowing that they're likely to be reviewed by folks more knowledgeable than I.

[12:42] <masak> KyleHa: thanks for enduring our reviews. :) and for lots of great tests.

[12:43] <jnthn> moritz_: Though pm seems to dread it less than I. ;-)

[12:43] *** KyleHa left
[12:45] <Matt-W> jnthn: is LTM one of these PGE refactors required?

[12:46] <pmurias> ruoso: i changed SV_HEAD to have SMOP__Object__BASE instead of just a pointer to RI

[12:46] <ruoso> pmurias, ah... right... 

[12:46] <jnthn> Matt-W: Yes, that needs to happen, though not as urgently as some other things.

[12:48] <masak> jnthn: why do I get a Null PMC access in isa() when doing the last 'rakudo:' one-liner on my computer, with new-built Parrot and Rakudo?

[12:48] * masak runs the spectests

[12:50] <Matt-W> jnthn: I believe it's one of the requirements for STD.pm?

[12:50] <frettled> D'oh!  I forgot to check whether the spectests finished at my home Mac this morning.

[12:51] <moritz_> yes, but STD.pm also requires otehr stuff, like proto regexes

[12:51] <Matt-W> oh yes those

[12:51] <Matt-W> I have no idea what they do :)

[12:53] <jnthn> Matt-W: The .^parents(:tree) one?

[12:54] <moritz_> Matt-W: proto regexes are multiple regexes with the same name, and if you match against them, you match against all the alternatives separated by |

[12:54] <jnthn> Matt-W: Yes, it is. However, afaiu the operator precedence parser in STD hangs off protoregxes, plus they should get us a big speed win, so afaik pm plans on doing those first.

[12:54] <masak> jnthn++ # blog post

[12:54] *** ihrd left
[12:55] <masak> (big speed win)++

[12:55] <pmurias> lunch&

[12:56] <jnthn> masak: oh, I meant you, not Matt-W above...

[12:57] <jnthn> erm, 2 up

[12:57] <jnthn> masak: I can't reproduce a null pmc access locally.

[12:57] <jnthn> :-S

[12:58] <Matt-W> moritz_: okay umm why?

[12:59] *** molaf left
[12:59] <moritz_> Matt-W: it means that you can add alternatives by subclassing without having to list all existing alternatives

[12:59] <masak> jnthn: right, and neither can p6eval.

[12:59] <masak> jnthn: so I wonder what's going on...

[13:00] <moritz_> masak: try a clean checkout?

[13:00] <masak> spectests look fine so far, but I'm only on S06.

[13:00] <masak> moritz_: urgh. maybe later. :/

[13:00] <moritz_> Matt-W: I wrote a bit about the importance in this piece: http://perlgeek.de/en/article/mutable-grammar-for-perl-6

[13:00] <Matt-W> moritz_: that's handy

[13:01] * Matt-W looks

[13:01] *** abra joined
[13:07] <Matt-W> moritz_: ahah! Now I comprehend. Very cunning.

[13:13] <colomon_> Hi all.

[13:13] <colomon_> Are where clauses implemented yet in Rakudo?

[13:13] <masak> colomon_: aye.

[13:14] <colomon_> Yay!

[13:17] *** polettix joined
[13:19] <polettix> perl6: my %H=(whatever=>76); my $x=%H.delete('whatever'); say $x; say $x+0;

[13:19] <p6eval> rakudo 0d4fe0: OUTPUT«76␤1␤»

[13:19] <p6eval> ..pugs: OUTPUT«76␤76␤»

[13:19] <p6eval> ..elf 27980: OUTPUT«76␤137732896␤»

[13:20] <polettix> is this a known bug in rakudo?

[13:21] <masak> polettix: what's the bug?

[13:21] <masak> polettix: looks right (but weird) to me.

[13:21] <polettix> say $x prints 76, but say $x+0 says 1

[13:22] <masak> perl6: my %h = whatever => 76; my $x = %h.delete('whatever'); say $x.WHAT

[13:22] <p6eval> elf 27980: OUTPUT«Can't locate object method "delete" via package "Pair" at (eval 125) line 4.␤ at ./elf_h line 5881␤»

[13:22] <p6eval> ..pugs: OUTPUT«Int␤»

[13:22] <p6eval> ..rakudo 0d4fe0: OUTPUT«Array()␤»

[13:22] <masak> polettix: ah, so that's why.

[13:22] <polettix> I see now

[13:22] <masak> polettix: that might be a bug.

[13:23] <Matt-W> hmm why would delete on a hash return an array

[13:23] <masak> that's the question.

[13:23] <polettix> I hope so, otherwise it would be - let's say - counterintuitive :)

[13:23] *** synth joined
[13:23] <masak> even .pick() doesn't return an array for single items nowadays.

[13:23] <polettix> maybe because of slices?

[13:23] <masak> in fact, .pick() and .delete() are quite similar in that respect.

[13:23] <masak> they should return the same types as far as possible.

[13:24] <Matt-W> oooh

[13:24] <Matt-W> delete on List is definitely meant to return a list

[13:24] <Matt-W> as it can take a list of subscripts

[13:24] <Matt-W> so I assume the same for Hash

[13:24] <polettix> it was driving me nuts in a naive implementation of Eratosthenes' sieve

[13:24] <Matt-W> S32/Containers doesn't mention .delete on Hash, only :delete. This seems a little odd.

[13:25] <masak> grrr.

[13:25] <masak> there's too little decision-making going on in that region of the spec.

[13:25] <masak> and has been, for over a year.

[13:25] <Matt-W> yeah it's all a bit nebulous

[13:26] <masak> :exists and :delete have been on the way in for a long time now.

[13:26] <colomon_> I thought someone said upstream that %hash.exists is a Rakudo-ism, and :exists is proper.

[13:26] <Matt-W> I was looking at it at one point, but it was just like 'eeerrrr where do I start'

[13:26] <masak> and .exists and .delete have been on their way out, maybe, sometimes.

[13:26] <colomon_> Presume delete would be the same?

[13:26] <Matt-W> I believe it's supposed to be :exists and :delete because they reuse the existing subscripting mechanism

[13:26] <colomon_> Personally, I prefer .exists and .delete.

[13:27] <masak> I don't care which one it ends up being, but I don't like living in an in-between world.

[13:27] <Matt-W> mmm

[13:27] <Matt-W> and we certainly shouldn't have both, IMO

[13:27] <masak> having both's OK with me too.

[13:27] <Matt-W> that would just be ridiculous

[13:27] <masak> :)

[13:27] <Matt-W> I know TMTOWTDI

[13:27] <Matt-W> but there are limits...

[13:28] <masak> I simply don't care enough in this issue. it's the indeterminacy that miffs me.

[13:28] <Matt-W> mmm I'd accept either right now

[13:30] *** tak11 left
[13:31] <frettled> What's the point of using colons for that?

[13:31] * frettled asks a stupid question. :)

[13:31] <Matt-W> it's because it's a modification to the usual subscripting operation

[13:31] <Matt-W> they're adverbs, not methods

[13:32] <polettix> crap, I recompiled rakudo and now it can be called only from its compilation directory...

[13:32] <frettled> so are there other cases where we have things that aren't methods, but which are specified with the dotted syntax anyway?

[13:32] <frettled> polettix: make install

[13:32] <polettix> has this changed since yesterday?

[13:33] <jnthn> polettix: Yes.

[13:33] <polettix> ahahah fantastic

[13:33] * frettled was useful! o/

[13:35] *** payload joined
[13:35] *** abra left
[13:36] <polettix> thank you frettled 

[13:37] *** abra joined
[13:38] <Matt-W> frettled: I wouldn't rule it out, but those are the ones I know about

[13:39] <frettled> Matt-W: if they're the only cases, then I'd argue that they should go, and we should rather learn (and teach others) consistent use of adverbials.

[13:39] *** JimmyZ joined
[13:39] <frettled> In this case, understanding is probably aided by skipping the dotted form.

[13:40] <Matt-W> having both is bound to lead to piles of unpleasant confusion

[13:40] <Matt-W> I do like the elegance of the adverbial form

[13:41] <Matt-W> it means there's one way to select members, and then you can either get them, delete them or see if they exist

[13:42] <Matt-W> I suppose they just end up as named optional parameters to postcircumfix:<{ }>

[13:45] <colomon_> Matt-W: I have to say that explanation (even if not technically true (yet?)) makes :exists make a lot more sense to me.

[13:45] <Matt-W> well :exists does work :)

[13:45] <Matt-W> (I think)

[13:45] <colomon_> Ah, I thought .exists was only there because :exists doesn't work yet.

[13:46] <Matt-W> rakudo: my %h = (foo => 'bar'); say "yes" if %h<foo> :exists;

[13:46] <p6eval> rakudo 0d4fe0: OUTPUT«sh: ./perl6: No such file or directory␤»

[13:46] <Matt-W> doh

[13:47] <PerlJam> Matt-W: NYI I think

[13:47] <Matt-W> I'm sure I used it the other day

[13:49] <masak> I don't think you did.

[13:53] <PerlJam> perl6: my %h = (foo => 'bar'); say "yes" if %h<foo> :exists;

[13:53] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ":exists"␤    expecting operator␤    at /tmp/4NlbdZbYwb line 1, column 46␤»

[13:53] <p6eval> ..rakudo 0d4fe0: OUTPUT«Statement not terminated properly at line 2, near ":exists;"␤in Main (src/gen_setting.pm:3369)␤»

[13:53] <p6eval> ..elf 27980: OUTPUT«Parse error in: /tmp/6SJj0UENLM␤panic at line 1 column 52 (pos 52): No previous operator visible to adverbial pair ([#<Match:0x817c214 @on_str="my %h = (foo => 'bar'); say \"yes\" if %h<foo> :exists;", @from=45, @to=52, @bool=true, @hash={:value=>#<Match:0x817c2c8 @on_str="my %h

[13:53] <p6eval> ..= …

[13:53] <masak> ah!

[13:53] <masak> jnthn: I've got it!

[13:53] <PerlJam> (on the odd chance that one of the implementations groks it)

[13:53] <masak> jnthn: it's when I run rakudo outside the rakudo directory!

[13:54] <jnthn> masak: Had you make install'd?

[13:54] <masak> jnthn: what, Rakudo? no...

[13:54] *** KatrinaTheLamia left
[13:54] * masak tries that

[13:55] <jnthn> masak: I think you need to make install Rakudo now, to run it outside the build directory.

[13:55] <PerlJam> masak: what happens when you run rakudo outside of the rakudo tree?

[13:55] <masak> jnthn: correct. now it works.

[13:55] <masak> PerlJam: previously, I got a Null PMC access.

[13:56] <masak> now it works again. jnthn++

[13:56] *** DakeDesu joined
[13:56] <Matt-W> hmm

[13:56] <polettix> should I report about the possible bug with .delete() somewhere?

[13:56] <Matt-W> I may be hallucinating

[13:56] <PerlJam> "Null PMC access" will be the bane of rakudo's existence.

[13:57] <masak> polettix: yes, please do. [email@hidden.address]
[13:57] <polettix> OK

[13:58] <jnthn> PerlJam: It's like segfaulting without the segfault. :-)

[13:58] *** synth left
[13:58] *** synth joined
[13:58] <pmichaud> good morning, #perl6

[13:58] <cono> morning

[13:59] <moritz_> good morning pmichaud, and happy birthday to you

[13:59] <JimmyZ> & good evening, #perl6 ;)

[13:59] <PerlJam> jnthn: then perhaps a goal for Rakudo* should be to *never* *ever* output a "Null PMC access"  :)

[13:59] <Matt-W> pmichaud: I believe it's the day we give thanks for your birth

[13:59] <masak> happy birthday, pmichaud!

[13:59] <cono> pmichaud: happy birthday!

[13:59] <PerlJam> pmichaud: happy birthday!

[13:59] <JimmyZ> happy birthday pmichaud!

[13:59] <pmichaud> thank you all :)

[14:00] <JimmyZ> ;)

[14:00] <PerlJam> pmichaud: check your facebook page for a message from Cyndi too  :)

[14:02] *** pyrimidine joined
[14:04] <JimmyZ> I can't open facebook. because of Chinese Great FireWall :(

[14:06] <masak> of course. Facebook is subversive, and not nearly Marxist-Leninist enough.

[14:06] <Matt-W> fortunately you can talk about Perl 6

[14:07] <Matt-W> facebook's fairly missable really

[14:07] *** azawawi joined
[14:07] <azawawi> hi

[14:07] <masak> and we have an eight-month plan! :)

[14:07] <JimmyZ> and I can't open wikipedia.org before. :)

[14:07] <Matt-W> although of course in principle it should be accessible

[14:07] <Matt-W> masak: it's almost like being pregnant

[14:08] <JimmyZ> I think tor is my friend now

[14:08] <azawawi> pmichaud: any idea how to debug a Perl 6 app using parrot_debugger?

[14:08] <masak> Matt-W: "Perl 6: almost like being pregnant"

[14:09] <PerlJam> masak: does that mean there's going to be a painful birthing?

[14:09] <jnthn> rakudo: eval 'dmbtt!Cjsuiebz!|!nvmuj!nfuipe!qn)A*!|!#up!zpv#!~<!nvmuj!nfuipe!qn)&*!|!#qnjdibve#!~!~<!)#Ibqqz!cjsuiebz!#!==⌂==!)Cjsuiebz/qn)\^*!yy!3-!Cjsuiebz/qn)|~*-!Cjsuiebz/qn)\^***??/tbz'.reverse.subst(/(.)/, { chr(ord(~$0) - 1) }, :g)

[14:09] *** __ash__ joined
[14:09] <Matt-W> masak: no I think it's "Developing Rakudo Star: almost like being pregnant"

[14:09] <p6eval> rakudo 0d4fe0:  ( no output )

[14:10] <jnthn> aww

[14:10] <jnthn> rakudo: eval 'dmbtt!Cjsuiebz!|!nvmuj!nfuipe!qn)A*!|!#up!zpv#!~<!nvmuj!nfuipe!qn)&*!|!#qnjdibve#!~!~<!)#Ibqqz!cjsuiebz!#!==⌂==!)Cjsuiebz/qn)\^*!yy!3-!Cjsuiebz/qn)|~*-!Cjsuiebz/qn)\^***??/tbz'.reverse.subst(/(.)/, { chr(ord(~$0) - 1) }, :g)

[14:10] <p6eval> rakudo 0d4fe0:  ( no output )

[14:10] <jnthn> rakudo: say "alive"

[14:10] <p6eval> rakudo 0d4fe0: OUTPUT«alive␤»

[14:10] <Matt-W> did you remember to stick a print statement in there anywhere?

[14:10] <jnthn> rakudo: eval 'dmbtt!Cjsuiebz!|!nvmuj!nfuipe!qn)A*!|!#up!zpv#!~<!nvmuj!nfuipe!qn)&*!|!#qnjdibve#!~!~<!)#Ibqqz!cjsuiebz!#!==⌂==!)Cjsuiebz/qn)\^*!yy!3-!Cjsuiebz/qn)|~*-!Cjsuiebz/qn)\^***??/tbz'.reverse.subst(/(.)/, { chr(ord(~$0) - 1) }, :g)

[14:10] <p6eval> rakudo 0d4fe0:  ( no output )

[14:10] <jnthn> rakudo: eval 'dmbtt!Cjsuiebz!|!nvmuj!nfuipe!qn)A*!|!#up!zpv#!~<!nvmuj!nfuipe!qn)&*!|!#qnjdibve#!~!~<!)#Ibqqz!cjsuiebz!#!==⌂==!)Cjsuiebz/qn)\^*!yy!3-!Cjsuiebz/qn)|~*-!Cjsuiebz/qn)\^***??/tbz'.reverse.subst(/(.)/, { chr(ord(~$0) - 1) }, :g); say "alive"

[14:10] <p6eval> rakudo 0d4fe0: OUTPUT«alive␤»

[14:10] <jnthn> huh

[14:11] <jnthn> oooh...unprintable char

[14:11] *** eternaleye left
[14:12] <PerlJam> jnthn: you failed to check the return value of your eval  :)

[14:13] *** szabgab left
[14:13] <jnthn> oh well, I'll just go for the less obfuscated...

[14:13] <jnthn> rakudo: class Birthday { multi method pm(@) { "to you" }; multi method pm(%) { "pmichaud" } }; ("Happy birthday " <<~<< (Birthday.pm([]) xx 2, Birthday.pm({}), Birthday.pm([])))>>.say

[14:13] <p6eval> rakudo 0d4fe0: OUTPUT«Happy birthday to you␤Happy birthday to you␤Happy birthday pmichaud␤Happy birthday to you␤»

[14:16] <azawawi> jnthn: any idea how to debug a Perl 6 app using parrot_debugger?

[14:16] <jnthn> azawawi: I'm not entirely sure how to debug a Parrot app using parrot_debugger ;-)

[14:16] <jnthn> Maybe ask over at #parrot, I really don't know the status of the debugger

[14:16] <Matt-W> jnthn: that is slightly less impressive that way

[14:17] <jnthn> Matt-W: Indeed. It all worked great locally, but something got messed up in the paste.

[14:17] <Matt-W> :(

[14:17] <jnthn> rakudo: say 'dmbtt!Cjsuiebz!|!nvmuj!nfuipe!qn)A*!|!#up!zpv#!~<!nvmuj!nfuipe!qn)&*!|!#qnjdibve#!~!~<!)#Ibqqz!cjsuiebz!#!==⌂==!)Cjsuiebz/qn)\^*!yy!3-!Cjsuiebz/qn)|~*-!Cjsuiebz/qn)\^***??/tbz'.reverse.subst(/(.)/, { chr(ord(~$0) - 1) }, :g);

[14:17] <azawawi> jnthn: it works nicely... but using trace it sometimes fails

[14:17] <p6eval> rakudo 0d4fe0: OUTPUT«class Birthday { multi method pm(@) { "to you" }; multi method pm(%) { "pmichaud" } }; ("Happy birthday " <<⌁<< (Birthday.pm([]) xx 2, Birthday.pm({}), Birthday.pm([])))>>.say␤»

[14:18] <jnthn> Oh, it was the ~

[14:18] <jnthn> oh, turns out ~ is char 126

[14:18] <jnthn> And 127 is DEL

[14:18] <jnthn> In ASCII at least.

[14:19] <PerlJam> maybe you should've -1 instead.

[14:19] <azawawi> jnthn: my idea was to automate parrot debugger process to get a visual Padre debugger... alas it still fails

[14:19] *** arthur-_ left
[14:19] <PerlJam> oh, -1 wouldn't have worked either.

[14:20] <jnthn> PerlJam: Didn't work for spaces...

[14:20] <masak> jnthn: (re p6eval script) scary :)

[14:24] * PerlJam wonders how big a base64 decoder would be ...

[14:25] <PerlJam> (and could it fit in the method call chain?)

[14:25] <pmichaud> jnthn: any joy on getting a build to work for msvc++ yet?

[14:26] <pmichaud> (I'm distracted a bit this morning -- just discovered that marriott-- took it upon themselves to unilaterally change our hotel reservations for this weekend)

[14:26] <jnthn> pmichaud: Yes. Already comitted fixes to Parrot and Rakudo this morning.

[14:26] *** mkfort left
[14:26] <pmichaud> jnthn: excellent.  did you see my discussion with allison yesterday?

[14:26] <jnthn> Yes

[14:26] <pmichaud> great

[14:26] <jnthn> Read that before doing the changes.

[14:26] * pmichaud goes to look at the changes

[14:27] <pmichaud> hmmm... we eliminated the _cg and _cgp stuff altogether?

[14:27] <pmichaud> does that.... wokr?

[14:27] <pmichaud> *work?

[14:28] *** alester left
[14:28] <moritz_> it still builds for me on linux, but I only checked with the default run core

[14:28] <jnthn> pmichaud: Well, yes and no

[14:28] <jnthn> pmichaud: I don't think anyone defaults to using those run cores.

[14:29] <jnthn> pmichaud: That is, they're not defaults on any platform.

[14:29] <pmichaud> okay

[14:29] <pmichaud> if they aren't defaults, I can probably live with that

[14:29] <jnthn> And given I don't think perl6 fakeexecutable offers up a way to change the runcore at the command line anyway...

[14:29] <pmichaud> right.

[14:29] *** Patterner left
[14:29] <pmichaud> I was thinking they might not even link properly or something

[14:29] <jnthn> IMO, we can add 'em back when there's a sensible way to know what to build.

[14:29] *** Psyche^ joined
[14:29] *** Psyche^ is now known as Patterner

[14:30] <jnthn> Probably a question for #parrotsketch as to what's the standard way to do that going to be.

[14:30] <pmichaud> I agree -- for some reason I figured they were necessary to even get a build to run (even if not using the runcore)

[14:30] <jnthn> No, they ain't.

[14:30] <pmichaud> then they can be ignored for now.

[14:30] <jnthn> It builds a DLL per runcore and just loads the applicable one.

[14:37] *** leedo_ joined
[14:41] *** rfordinal3643 left
[14:41] *** rfordinal joined
[14:46] *** hercynium joined
[14:49] *** szabgab joined
[14:52] *** synth left
[14:52] *** synth joined
[14:54] *** Front_slash joined
[14:56] *** azawawi left
[15:00] *** rfordinal left
[15:03] *** xxx_hi joined
[15:04] *** xxx_hi left
[15:04] <masak> rakudo: module A { class B { #`(how do I refer to C from here?) } }; class C {}

[15:04] <p6eval> rakudo 0d4fe0:  ( no output )

[15:05] <JimmyZ> ugly comment :(

[15:06] <moritz_> masak: by pre-declaring C, of course

[15:06] <TimToady> if it's ugly, then it's obvious to the eye that it isn't real Perl code :P

[15:06] <masak> JimmyZ: I disliked them too in the beginning. it's abating.

[15:06] <masak> moritz_: oh. sorry. assume C is before A, then.

[15:06] <moritz_> well, with 'C'

[15:06] <masak> the problem was how to refer to things that aren't in the same module.

[15:07] <moritz_> or maybe ::C

[15:07] <JimmyZ> rakudo: module A { class B { #(how do I refer to C from here?) } }; class C {}

[15:07] <p6eval> rakudo 0d4fe0: OUTPUT«Embedded comments now require backticks at line 2, near "(how do I "␤in Main (src/gen_setting.pm:3369)␤»

[15:07] <moritz_> I think that Rakudo has a problem with seeing outer lexicals across class boundaries

[15:07] <masak> moritz_: wouldn't ::C be a type parameter?

[15:07] <JimmyZ> rakudo: module A { class B { #\(how do I refer to C from here?) } }; class C {}

[15:07] <p6eval> rakudo 0d4fe0: OUTPUT«Unable to parse block; couldn't find final '}' at line 2, near ""␤in Main (src/gen_setting.pm:3369)␤»

[15:07] <moritz_> masak: isn't C a type?

[15:07] <masak> moritz_: it is.

[15:07] *** Psyche^ joined
[15:07] <JimmyZ> rakudo: module A { class B { ##(how do I refer to C from here?) } }; class C {}

[15:08] <p6eval> rakudo 0d4fe0: OUTPUT«Unable to parse block; couldn't find final '}' at line 2, near ""␤in Main (src/gen_setting.pm:3369)␤»

[15:08] <masak> moritz_: that's a bit of a non-sequirur question, though.

[15:08] <moritz_> rakudo: class C { }; class A { class B { method foo { say C.perl } } }

[15:08] *** Patterner left
[15:08] *** Psyche^ is now known as Patterner

[15:08] <masak> s/sequirur/sequitur/

[15:08] <p6eval> rakudo 0d4fe0:  ( no output )

[15:08] <JimmyZ> rakudo: module A { class B { #@(how do I refer to C from here?) } }; class C {}

[15:08] <p6eval> rakudo 0d4fe0: OUTPUT«Unable to parse block; couldn't find final '}' at line 2, near ""␤in Main (src/gen_setting.pm:3369)␤»

[15:08] <moritz_> std: class C { }; class A { class B { method foo { say C.perl } } }

[15:08] <p6eval> std 27980: OUTPUT«ok 00:02 37m␤»

[15:08] <JimmyZ> rakudo: module A { class B { #$(how do I refer to C from here?) } }; class C {}

[15:08] <p6eval> rakudo 0d4fe0: OUTPUT«Unable to parse block; couldn't find final '}' at line 2, near ""␤in Main (src/gen_setting.pm:3369)␤»

[15:09] <moritz_> rakudo: class C { }; class A { class B { method foo { say C.perl } } }; A::B.foo

[15:09] <p6eval> rakudo 0d4fe0: OUTPUT«C␤»

[15:09] <moritz_> masak: see, it even works

[15:09] <TimToady> std: class C {...}; class A { class B { method foo { say C.perl } } }; augment class C {}

[15:09] <p6eval> std 27980: OUTPUT«ok 00:02 37m␤»

[15:09] <masak> in short, type names are always absolute?

[15:09] <moritz_> TimToady: in a perfect Perl 6 you wouldn't need the 'augment' because C is only stubbed, right?

[15:10] <TimToady> std: class A { class B { method foo { say ::C.perl } } }; class C {}

[15:10] <p6eval> std 27980: OUTPUT«ok 00:02 37m␤»

[15:10] <TimToady> correct

[15:10] <TimToady> but std doesn't grok that yet

[15:10] <JimmyZ> I'd say, so ugly comment!

[15:10] <TimToady> std: class C {...}; class A { class B { method foo { say C.perl } } }; class C {}

[15:10] <p6eval> std 27980: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of package symbol C at /tmp/t8zqEanRia line 1:␤------> [32m{ method foo { say C.perl } } }; class C[33m⏏[31m {}[0m␤FAILED 00:02 37m␤»

[15:10] <moritz_> ugliness is in he idea of the beholder

[15:11] <TimToady> comments are supposed to be ugly so they stand out :)

[15:11] <JimmyZ> It hurt my eyes.

[15:11] <TimToady> I should make a syntax category for comment so it's easy to define your own

[15:12] <moritz_> JimmyZ: then don't use them :-)

[15:12] <mofino> define your own comments?!?  wow

[15:12] *** nihiliad joined
[15:12] <JimmyZ> why not #()? any problem?

[15:12] *** nihiliad left
[15:12] <TimToady> see the large thread in p6l about that

[15:12] *** polettix left
[15:12] <PerlJam> heh

[15:12] <JimmyZ> ok

[15:17] * synth always liked //, dunno why

[15:18] <masak> TimToady: if someone defines an operator containing '#', will it take precedence over the comment syntax?

[15:18] <TimToady> it will follow LTM, like anything else

[15:18] <JimmyZ> rakudo: sub #() {}

[15:18] <TimToady> currently #` is a token

[15:18] <p6eval> rakudo 0d4fe0: OUTPUT«Embedded comments now require backticks at line 2, near "() {}"␤in Main (src/gen_setting.pm:3369)␤»

[15:19] <JimmyZ> rakudo: sub prefix:#() {}

[15:19] <p6eval> rakudo 0d4fe0: OUTPUT«Malformed routine definition at line 2, near "prefix:#()"␤in Main (src/gen_setting.pm:3369)␤»

[15:20] *** donaldh left
[15:20] <TimToady> synth: you probably like // because it *doesn't* look like C/C++ code

[15:21] <JimmyZ> rakudo: sub prefix:<#>() {}

[15:21] <TimToady> (un)fortunately, it does look like Perl code

[15:21] <p6eval> rakudo 0d4fe0:  ( no output )

[15:21] *** donaldh joined
[15:21] <JimmyZ> rakudo: sub prefix:<#>() {}; #();

[15:21] <p6eval> rakudo 0d4fe0: OUTPUT«Embedded comments now require backticks at line 2, near "();"␤in Main (src/gen_setting.pm:3369)␤»

[15:21] <moritz_> LTM win, rakudo++ # or so

[15:22] <synth> TimToady: Guess I didnt realize it also looks like an empty RE match

[15:22] <TimToady> or a defined-or, where infix expected

[15:23] *** zloyrusskiy left
[15:23] <moritz_> the empty regex is forbidden in Perl 6 anyway

[15:23] <TimToady> std: //

[15:23] <p6eval> std 27980: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null regex not allowed at /tmp/3dTpesexwy line 1:␤------> [32m//[33m⏏[31m<EOL>[0m␤FAILED 00:02 36m␤»

[15:23] <TimToady> std: / a | b | /

[15:23] <p6eval> std 27980: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null pattern not allowed at /tmp/shZfKVgfnM line 1:␤------> [32m/ a | b | [33m⏏[31m/[0m␤    expecting any of:␤      termish␤ ws␤FAILED 00:02 37m␤»

[15:24] <synth> are those ANSI escapes p6eval is spitting out?

[15:24] <PerlJam> std: / | a | b /

[15:24] <TimToady> color codes

[15:24] <p6eval> std 27980: OUTPUT«ok 00:02 37m␤»

[15:24] <synth> xchat does not parse

[15:24] <TimToady> or look at http://irclog.perlgeek.de/perl6/today

[15:24] <synth> i love my pretty printing

[15:24] <synth> thanks

[15:25] <PerlJam> TimToady: could not the trailing | be treated just as the empty |  ?  Or do you think the null pattern usage is yet too ingrained?

[15:25] <PerlJam> er, empty leading |

[15:25] <moritz_> though printing ANSI terminal escape sequences to IRC is a bit evil :-)

[15:25] <synth> moritz_: I was gonna say :)

[15:26] <synth> this aint ircII! :)

[15:26] <TimToady> the leading null is allowed so that you can prefix all your alternatives with | or || as STD does in many places

[15:26] <TimToady> but it doesn't mean to match a null string in that case

[15:27] <PerlJam> sure, but a trailing | seems like it could be ignored just like trailing commas in a list (or the leading |).

[15:27] <TimToady> it could, but I arbitrarily don't want to encorage postfix | over prefix | :)

[15:27] <TimToady> s/cor/cour/

[15:28] <PerlJam> fine by me, you're the language designer :)

[15:29] *** pyrimidine left
[15:33] *** arthur-_ joined
[15:34] <guest_007> rakudo: @5th=<earth water fire wind love>; say "Fifth element: "~@5th.elem;

[15:35] * synth really has to find the time to follow perl6 closer.. too busy working

[15:35] <p6eval> rakudo 0d4fe0: OUTPUT«Syntax error at line 2, near "@5th=<eart"␤in Main (src/gen_setting.pm:3369)␤»

[15:35] <masak> guest_007: an identifier can't start with a digit.

[15:35] <PerlJam> and you need a my

[15:36] <moritz_> and you have to declare your variables

[15:36] <moritz_> and I strongly recommend whitespaces around infix operators

[15:36] <guest_007> rakudo: my @5th=<earth water fire wind love>; say "Fifth element: " ~ @5th.elem;

[15:36] <p6eval> rakudo 0d4fe0: OUTPUT«Malformed declaration at line 2, near "@5th=<eart"␤in Main (src/gen_setting.pm:3369)␤»

[15:37] <guest_007> )))

[15:37] <PerlJam> guest_007: you have to listen to *everything* people tell you

[15:37] <guest_007> okay

[15:37] * [particle] gets synth fired

[15:37] <[particle]> we need more followers.

[15:38] *** rfordinal joined
[15:38] <synth> please do, I'll give you IBM's # and everything

[15:38] * synth hates his job ..

[15:38] <PerlJam> [particle]: better would be to find a job that pays to work on perl6

[15:38] * synth spends all his free time writing perl and dayjob as an SA for a fortune 500 client for IBM

[15:38] <[particle]> PerlJam: believe me, this i know.

[15:38] <synth> the enterprise world sucks ;)

[15:38] <[particle]> synth: oracle or db2?

[15:39] <synth> I'm just a Linux jockey

[15:39] <synth> got 300 ProLiants

[15:39] <[particle]> oh, heh, i read SA as DBA

[15:39] *** KyleHa joined
[15:40] <synth> i love perl but I am trying to study 6 because I am very interested int he language becoming more... semantically clean?

[15:40] <synth> I love perl with all my heart, it's such a fun language to 'think in' -- but the bar for entry being so high due to the assumptions one must know to work w/out strict and warn

[15:40] <synth> scares most folk off

[15:41] <[particle]> synth: start writing small programs with rakudo

[15:41] <[particle]> solve some SA-type problems

[15:41] <moritz_> at least a 'use 5.11;' also enables strict

[15:41] <PerlJam> synth: Good!  We only want those that exhibit perseverance

[15:41] <synth> PerlJam: this is true

[15:42] <synth> [particle]: on my own sure, but I cant deploy that in this env even if its my own tool

[15:42] <synth> I could deploy it on my test box...

[15:42] <PerlJam> you know, the tenets of taekwondo would be good tenets for the perl community too.

[15:42] <synth> PerlJam: "Take kids Money? "

[15:43] <PerlJam> honesty, courtesy, integrity, perseverance, self control, courage, community

[15:43] <moritz_> PerlJam: is that ordered by importance? :-)

[15:43] <PerlJam> (and they recently added: strenght, humility, knowledge for some reason.)

[15:44] <PerlJam> moritz_: I never thought about it, but I hope not!  :)

[15:44] <synth> PerlJam: I did tae kwon do for 5 years and I all I got was some supressive holds, countering throws and the forms

[15:44] <moritz_> doesn't that conflict with hubris? :-)

[15:44] <[particle]> PerlJam: it seems, by recently adding some, that laziness is also implied :)

[15:45] * synth is a 1st dan black belt

[15:45] <JimmyZ> I love perl6, because I'm lazy :(

[15:45] <[particle]> rakudo: say "i love laziness, because i'm perl 6 :)"

[15:45] <p6eval> rakudo 0d4fe0: OUTPUT«sh: ./perl6: No such file or directory␤»

[15:45] <synth> 5 years of paying and 3 years of private study.. took forever..

[15:45] <PerlJam> synth: which tkd faction were you in?

[15:45] * [particle] kicks p6eval

[15:46] <TimToady> std: @5th=<earth water fire wind love>; say "Fifth element: "~@5th.elem;

[15:46] <p6eval> std 27980: OUTPUT«[31m===[0mSORRY![31m===[0m␤Whitespace is required between alphanumeric tokens at /tmp/YzIqtjLbiM line 1:␤------> [32m@5[33m⏏[31mth=<earth water fire wind love>; say "Fi[0m␤    expecting any of:␤     POST␤   postfix␤  postfix_prefix_meta_operator␤       standard stopper␤

[15:46] <p6eval> ..terminator␤     whit…

[15:46] <synth> PerlJam: WTF

[15:47] <PerlJam> synth: figured.  I'm in ITA :)

[15:47] <synth> PerlJam: at least you guys get to spar with helmets..

[15:47] <synth> and pads :

[15:47] <synth> :)

[15:47] <moritz_> hey, I could try to install rakudo into a sub dir to reduce the downtime when recompiling rakudo

[15:47] * synth still remembers all his Forms and everything, been at least 10 years... sorry to hijack the #perl6 topic

[15:47] <PerlJam> (and as of yesterday I'm now a 1st degree level 2 black belt)

[15:48] <PerlJam> I don't know if WTF does the levels thing.

[15:48] <JimmyZ> I want to get a perl job, but never had it. 

[15:48] *** jd8hh57 left
[15:48] <synth> PerlJam: yeah each belt has levels

[15:48] <synth> not just degrees

[15:48] <PerlJam> synth: well, 1st degree ~ 1st dan

[15:49] <synth> yeah

[15:49] <synth> well congrats on the new belt even if you're not allowed to show pride

[15:49] <synth> show some :)

[15:49] * synth once did 300 pushups for showing too much pride

[15:51] *** mikehh_ is now known as mikehh

[15:52] <mikehh> rakudo (0d4fe08) builds on parrot r40525 - make test/make spectest (up to 27980) PASS - Ubuntu 9.04 amd64

[16:01] *** zamolxes left
[16:07] *** JimmyZ left
[16:09] *** cdarroch joined
[16:09] <__ash__> moritz_: i think i figured out a good place to add in calling a parent class explicitly, with the p6protoobject find_method function you can see if the function called contains a '::' and if it does, assume whatever is before the '::' is the parent class your going to look for, i haven't implemented it, but it sounds like it should work 

[16:11] <KyleHa> Would it make sense for there not to be a .defined method on @arrays and %hashes, or does that violate some rule such as "every Any must have a .defined method"?

[16:11] <TimToady> @array := Array is undefined

[16:11] <lambdabot> Smartly me lass

[16:12] <KyleHa> I'd like @array.defined to throw an error.  I'd like { ! @array.can( 'defined' ) }

[16:13] <TimToady> why is everyone so throw-happy these days

[16:13] <pmichaud> .defined is one of those methods that probably should not ever throw an error

[16:13] <TimToady> throws are evil under multithreading

[16:13] <pmichaud> the whole point of .defined is to be able to ask "am I likely to encounter an error?"

[16:13] <KyleHa> Hmmm.

[16:13] <pmichaud> in short, I disagree with uri's email comment that @a shouldn't have a .defined on it

[16:14] <jnthn> __ash__: I suspect that's not really the way - better is to generate something a bit different at compile time.

[16:14] <KyleHa> It sounded sensible at the time,  8-)

[16:14] <jnthn> __ash__: That is, construct a P6Invocation that knows to start the search at a different place.

[16:14] <TimToady> .defined is how we tell type objects form their instantiations

[16:14] <moritz_> I think either we spec defined/undef arrays/hashes properly, or require it to always return true

[16:15] <pmichaud> it can't always return true

[16:15] <pmichaud> my @array := Array

[16:15] <pmichaud> say @array.defined   # false

[16:15] <jnthn> my @array; # equivalent to my @array := Array.new; ?

[16:16] <pmichaud> jnthn: that does seem to be the question at present

[16:16] <jnthn> Ah.

[16:16] <pmichaud> I can see either side

[16:16] <pmichaud> we could do  

[16:16] <pmichaud> my @array;  # equivalent to my @array := Array

[16:16] <__ash__> jnthn: okay, i'll look into adding it there

[16:16] <pmichaud> where manipulating @array causes it to autovivify

[16:16] <pmichaud> er, "to become defined"

[16:16] <pmichaud> or we could say

[16:17] <pmichaud> my @array;  # equivalent to my @array := Array.new

[16:17] <TimToady> much like my $x; $x[0] = 1; autovivs $x in Perl 5 maybe

[16:17] <TimToady> $x->[0] rather

[16:17] <pmichaud> where @array is then defined as soon as it's declared, as an empty array

[16:17] <TimToady> (in p5)

[16:17] <jnthn> __ash__: I'd been maybe pondering a dynop.

[16:18] <jnthn> Though not quite convinced myself of that yet.

[16:18] <pmichaud> __ash__: I'm not sure I follow what you're trying to accomplish

[16:18] <jnthn> pmichaud: $foo.SomeParent::method(...) is meant to call the method from SomeParent, I think.

[16:18] *** pyrimidine joined
[16:19] *** pyrimidine_ joined
[16:19] <pmichaud> hmmm

[16:19] <jnthn> Ah, that said, what I just suggested wouldn't work out so well for $foo.SomeRole::method(...)

[16:19] <pmichaud> and "method" isn't exported into the namespace?  Seems like we need a better syntax there.

[16:19] <pmichaud> or I'm missing something

[16:19] <jnthn> tbh I didn't really work out exactly what semantics that syntax should have

[16:19] <jnthn> I'm not convinced it's menat to be a namespace lookup.

[16:19] <pmichaud> right

[16:20] <jnthn> But I'm not quite sure what it *should* be.

[16:20] <pmichaud> if it's not a namespace lookup, we need a way to contextually flag it as being a method lookup on the SomeParent type

[16:20] <jnthn> Yeah

[16:20] <jnthn> The only issue then is, how do we resovle SomeParent.

[16:20] <pmichaud> same as we always do

[16:20] <jnthn> And relative to what.

[16:21] <pmichaud> SomeParent would be the lexical name for a type object, yes?

[16:21] <jnthn> I'd guess so.

[16:21] <pmichaud> I don't see why it's any different than any other type object name

[16:21] <jnthn> It probably need not be.

[16:21] <jnthn> I'm just pondering how things get worked out if it's a role.

[16:22] <jnthn> Also that

[16:22] <pmichaud> we don't have a way to do a find_method on a role?

[16:22] <jnthn> I think this syntax can be usable for calling methods the class didn't actually compose

[16:22] <TimToady> anything starting Foo:: is always search for up the lexical scopes first

[16:22] <jnthn> TimToady: Including for the part that follows Foo?

[16:22] <jnthn> Or just for Foo itself?

[16:22] <TimToady> so it suffices to have a lexical alias to anything that is outside the lexical scope that you want visible

[16:23] <jnthn> OK

[16:23] <jnthn> So $x.Foo::bar looks up Foo in the lexical scope

[16:23] <pmichaud> right.

[16:23] <jnthn> And then works out, which bar would Foo provide

[16:23] <pmichaud> Correct.

[16:23] <TimToady> even GLOBAL:: is found in the lexical scope (of CORE::)

[16:23] <jnthn> My question is, is this syntactic sugar for:

[16:23] <TimToady> or maybe UNIT::

[16:24] <TimToady> probably changing to UNIT::GLOBAL, actually

[16:24] <jnthn> my $temp := Foo.WALK(:name<bar>)[0]; $x.$temp(...)

[16:24] <jnthn> (Or something similar to that)

[16:25] <jnthn> That is, can we compose it of a lookup and an indirect method call?

[16:25] <TimToady> outer lexical scopes aren't supertypes

[16:25] <TimToady> at least, not yet :)

[16:25] <jnthn> Erm.

[16:25] <jnthn> Huh?

[16:25] *** ujwalic joined
[16:25] <jnthn> That's not even related to what I said.

[16:25] <TimToady> Foo.WALK would only traverse supertypes

[16:26] <jnthn> Right, is that the correct semantics?

[16:26] <TimToady> that's not how it is currently

[16:26] <jnthn> So how should it be?

[16:26] <TimToady> you just follow $?OUTER links to find your outer lexical objecct

[16:27] <TimToady> outer stash, in fact

[16:27] <pmichaud> that's how we get to Foo, yes

[16:27] <jnthn> That is, given $x.Foo::bar, we find Foo. How do we get from this to having the method.

[16:27] <jnthn> ?

[16:27] <pmichaud> the question is -- once having obtained Foo, how do we get Foo::bar from it?

[16:27] <jnthn> Correct.

[16:27] <pmichaud> in the case of   $x.Foo::bar()

[16:28] <jnthn> Who do we ask to find bar?

[16:28] <jnthn> Foo? Or $x?

[16:28] <jnthn> That is, is this along the lines of

[16:28] <jnthn> $x.Foo::bar(...) is like $x.bar(...) with a note to the dispatcher to walk the hierarchy until it finds a class with type object Foo?

[16:29] <jnthn> Ir so, that will never work when Foo is a role name.

[16:29] <jnthn> Or alternatively, do we find Foo, ask it to give us a bar somehow (maybe by looking at its metaclass), and then act as if it's an indirect method invocation.

[16:30] <TimToady> no, we get to the Foo stash and there's a link in there to the type object

[16:30] *** molaf joined
[16:30] <TimToady> the latter

[16:30] <jnthn> OK, so essentially the type object for Foo controls the dispatch?

[16:30] <pmichaud> sure

[16:31] <pmichaud> that's what  $x.Foo::bar()  essentially means :-)

[16:31] <jnthn> OK, that's fine.

[16:31] <cognominal> @array := Array  # I can't fathom what it is supposed to mean

[16:31] <lambdabot> Aye

[16:31] <TimToady> Foo:: tells the dispatch where to start

[16:31] <jnthn> TimToady: That could mean two different things.

[16:31] <payload> in a recent post on planetsix i read     multi describe($c, $prefix) { take "$prefix " ~ $c.perl ~ "\n";

[16:31] <pmichaud> .Foo::bar() is essentially saying "I want something other than the normal dispatch -- I want to dispatch based on Foo, not on $x"

[16:32] <payload> is a take without gather allowed but not implemented in rakudo?

[16:32] <TimToady> payload: there must be a gather in the outer dynamic scope

[16:32] <pmichaud> payload: I think there needs to be a ... what TimToady said

[16:33] <TimToady> biab &

[16:33] <jnthn> That is, it could mean "find the type object for Foo and ask it to find bar" - which seems to be the answer - but it could also if you phrase it that way be taken as "do the dispatch from $x but note that it should start at Foo"

[16:33] <jnthn> Thus my confusion.

[16:33] <jnthn> Anyway, I'm happy with the answer (find type object for Foo and it controls the dispatch).

[16:34] <pmichaud> that's the way I view it, yes.

[16:34] <pmichaud> cognominal: we're allowed to bind @var to any object that does the Positional role

[16:34] <pmichaud> cognominal: the Array type object does the Positional role

[16:34] <jnthn> __ash__: So basically, that means that you look up Foo, do a find_method on that which should give back the P6Invocation, and then it's just an indirect method invocation. Deferal should Just Work from this if you're lucky.

[16:35] <cognominal> ok, now I have to find what it does when I iterate on it.

[16:35] <pmichaud> probably returns a Failure

[16:35] *** masak left
[16:35] <pmichaud> same as any other use of an undefined value

[16:36] <pmichaud> (or throws some sort of warning/exception, like other undefined values do)

[16:36] <cognominal> so what it the purpose of making the class Array a Positional as opposed to its instances?

[16:36] <pmichaud> Positional is a role

[16:36] *** pyrimidine left
[16:36] <pmichaud> Positional says  "I know how to do index-based subscripting"  or "I can handle .[ ]"

[16:37] <pmichaud> the type object is an (undefined) instance of the type

[16:37] <cognominal> so instances gets the roles defined by their class?

[16:37] <pmichaud> cognominal: yes, instances get the roles defined by the class.  That's somewhat the purpose of roles :-)

[16:37] <cognominal> oh, I forgot that point, a class is an undefined instance of its own type.

[16:38] <pmichaud> we prefer "type object" around here (these days)

[16:38] <pmichaud> in code, the symbol "Array"  would mean "the type object representing the Array class"

[16:38] <pmichaud> but yes, it's an instance of the type

[16:40] <cognominal> Scala uses the keyword object for singletons and shove there everything C++ call static. So I suppose this is close to a class object in Perl 6

[16:42] *** pyrimidine_ is now known as pyrimidine

[16:52] *** abra left
[16:54] *** shachaf joined
[16:57] *** ujwalic left
[17:05] *** KyleHa left
[17:10] <cdarroch> moritz_ ... this is off-topic, most likely, but thank you for your blog comments re parrot trac #757 and concurrency;

[17:10] <cdarroch> I tried to take a look, put a couple of patches into trac, but wound up over my head :-/

[17:10] <cdarroch> but thanks nevertheless

[17:10] <__ash__> jnthn: The indirect method invocation works, i have tried it (very primitively) before, however, what in the case of roles? the indirection method won't work there

[17:12] <colomon_> rakudo: "[42] foo [69]".subst(/\[(\d+)\]/, "{$0 - 10}", :g).say;

[17:12] <p6eval> rakudo 0d4fe0: OUTPUT«Use of uninitialized value␤-10 foo -10␤»

[17:13] <colomon_> Shouldn't $0 be set to the parenthetical match?

[17:14] <pmichaud> not as a string, no.

[17:15] *** Su-Shee left
[17:15] <pmichaud> rakudo:  "[42] foo [69]".subst(/\[(\d+)\]/, { "{$0 - 10}" }, :g).say

[17:15] <p6eval> rakudo 0d4fe0: OUTPUT«32 foo 59␤»

[17:16] <pmichaud> but shorter would then be

[17:16] <pmichaud> rakudo:  "[42] foo [69]".subst(/\[(\d+)\]/, {$0 - 10}, :g).say

[17:16] <p6eval> rakudo 0d4fe0: OUTPUT«32 foo 59␤»

[17:16] <colomon_> I thought "{$0 - 10}" was "evaluate $0 - 10 and then stringify it"?

[17:17] <pmichaud> sure, but the $0 in that case is the current $/, not the one in the .subst match

[17:17] <pmichaud> i.e., the $0 gets evaluated before being passed to the .subst method

[17:17] <colomon_> Oh!

[17:18] <colomon_> No, wait, I only thought I understood.

[17:18] <PerlJam> colomon_: don't worry, it took me a while to get used to it too.

[17:18] <pmichaud> if you want to refer to the captures in the .subst match, you have to pass a closure.

[17:18] <pmichaud> otherwise the $0, $1, etc. will be evaluated using the current value of $/ before the .subst method is called

[17:18] <colomon_> Oh!

[17:19] <colomon_> So it evaluates the string using the pre-subst $0, and then pass it to subst.  Right?

[17:19] <pmichaud> right

[17:19] <colomon_> Okay, that's all I need to get back on track here.  Thanks!

[17:19] <colomon_> pmichaud++

[17:19] <pmichaud> because double-quoted strings get evaluated before being passed to a method or function

[17:21] <colomon_> Yes, that makes perfect sense if I think of it as, say, a normal C++ function, rather than magic Perl stuff.  :)

[17:21] <PerlJam> ew

[17:22] <jnthn> __ash__: find_method on a role may well just do the Right Thing anyway (pun).

[17:22] <jnthn> Oh, though that probably ain't quite the Right Thing in this case. Hmm.

[17:22] <pugs_svn> r27981 | lwall++ | [STD] make comment into a syntax category

[17:22] <__ash__> it currently doesn't though 

[17:22] *** kane_ joined
[17:23] <jnthn> Punning does work.

[17:23] <jnthn> rakudo: role Foo { method bar { say 42 } }; Foo.bar

[17:23] <p6eval> rakudo 0d4fe0: OUTPUT«42␤»

[17:24] *** payload left
[17:24] <__ash__> rakudo: role A { method bar { say 'test'; } }; class B does A { method foo { self.A.bar } }; my B $b .= new; $b.foo;

[17:24] <p6eval> rakudo 0d4fe0: OUTPUT«Method 'A' not found for invocant of class 'B'␤»

[17:24] <__ash__> is what I am referring too

[17:25] <jnthn> Rakudo is correct there.

[17:25] <jnthn> You're calling a method A on self.

[17:25] <jnthn> Did you mean self.A::bar?

[17:25] <__ash__> eh, well, i never saw in the spec the 'right way' to call that (that was my guess) 

[17:25] <__ash__> it still wouldn't work with self.A::bar 

[17:26] <jnthn> I think self.A::bar is the one that should work, I think.

[17:26] <jnthn> As in, that Rakudo needs to support.

[17:26] <jnthn> It doesn't right now.

[17:26] <__ash__> got ya

[17:26] <__ash__> well, re-writing that into an indirect call wouldn't work either

[17:26] <__ash__> rakudo: role A { method bar { say 'test'; } }; class B does A { method foo { A.bar } }; my B $b .= new; $b.foo;

[17:26] <p6eval> rakudo 0d4fe0: OUTPUT«test␤»

[17:27] <__ash__> maybe it does... 

[17:27] <jnthn> That works but only because A.bar anywhere else would.

[17:27] *** EDevil left
[17:28] <jnthn> (which is fine, it should work that way, but it's different from self.A::bar

[17:28] <jnthn> )

[17:29] <moritz_> cdarroch: I'm glad somebody found it useful :-)

[17:31] <__ash__> so the correct way should be self.Role::method (same as a class call) then? 

[17:31] <cdarroch> I'll try to take another look in a few weeks, but there's a lot to learn and paid work to be done in the meantime

[17:33] <jnthn> __ash__: In that case, Role should be looked just as it would if it appeared alone.

[17:33] <jnthn> __ash__: Then it would be asked to find the method named 'method'

[17:34] <jnthn> We'd then have the method and could emit the same code as if it was an indirect invocation, probably. Though if you just use find_method I suspect it may still get it not quite right.

[17:34] <jnthn> But as a first cut for the superclass case, that should work.

[17:35] <jnthn> Needs a little bit of work in actions.pm

[17:36] <__ash__> but if find_method is the wrong way to do this, i'd rather do it the right way 

[17:36] <__ash__> if you have a method signature can you call it with respect to any object? or does it actually check if the object has the method? 

[17:37] <jnthn> Once you get the method object, you can call it with any object.

[17:37] <jnthn> Well, I'm not completely sure what the right way is just yet.

[17:37] <pmichaud> method(invocant, args...)

[17:38] <pmichaud> or in PIR, I suppose one could do    invocant.$P0(args)     # $P0 is the method

[17:40] <jnthn> Aye

[17:40] <jnthn> I forget exactly what PAST we generate for indirect method calls but it's quite possibly a call rather than a callmethod pasttype.

[17:42] <jnthn> The thing is, while doing find_method is just the right thing if it's a superclass, I'm not so sure it'll quite do the Right Thing on a role. But I suspect we can tweak the punner so that it will work out.

[17:42] <pmichaud> I would think just pun the role and then use find_method on that

[17:42] <pmichaud> (naively)

[17:43] *** rfordinal left
[17:44] <jnthn> pmichaud: Yeah, the thing is that then we need to know if we've got a role or not.

[17:44] *** rfordinal joined
[17:45] <pmichaud> ?

[17:45] <jnthn> Which means we probably have to do more work at runtime than we might be able to get away with.

[17:45] <pmichaud> at which step?

[17:45] <jnthn> I guess it'd be nice if generating $x.Foo::bar didn't depend on having to know if Foo is a role or not.

[17:46] <jnthn> In actions.pm that is.

[17:46] <jnthn> That is, we'd be able to emit the same thing without caring.

[17:46] <pmichaud> what currently happens with     my Foo $a;    ?

[17:46] <jnthn> (I'm pondering if we can make find_method work for all cases)

[17:46] *** aindilis left
[17:46] <jnthn> my Foo $a will do a call trait_mod:<of>($a, Foo)

[17:46] <__ash__> do roles live in the all_parents part of the a pmc? 

[17:46] <jnthn> See traits.pm to see what happens next.

[17:47] <jnthn> __ash__: No.

[17:47] <pmichaud> jnthn: and trait_mod:<of> is then responsible for punning the role?

[17:47] <__ash__> where do roles live then? 

[17:48] <pmichaud> rakudo:  role Foo { method bar() { say 'bar' } };  say Foo.WHAT

[17:48] <p6eval> rakudo 0d4fe0: OUTPUT«sh: ./perl6: No such file or directory␤»

[17:48] <pmichaud> bah

[17:49] <__ash__> or rather how does an object know what roles it has attached? 

[17:49] <jnthn> pmichaud: I don't understand why we would pun.

[17:49] <pmichaud> because it gives us an easy handle to get the method

[17:50] <jnthn> I meant in the case that you just mentioned.

[17:50] <jnthn> When setting the type constraint we've no need to pun.

[17:50] <pmichaud> oh

[17:50] <pmichaud> okay, I got confused.  We need to pun when doing Foo.new

[17:50] <pmichaud> got it

[17:50] <jnthn> __ash__: The roles that a class does hang off that class.

[17:50] <jnthn> .^roles will get 'em.

[17:51] <jnthn> pmichaud: Right. In my Foo $a .= new; then it's the call to new that puns.

[17:51] <pmichaud> right

[17:51] <pmichaud> okay

[17:51] <pmichaud> anyway, punning seems like it'd be an easy way to get the method

[17:51] <jnthn> In this case, yes, punning the role would indeed give us something from where find_method would Just Work.

[17:51] <pmichaud> there might be a way to get the method from a role, but in Parrot that seems to not be part of the model

[17:52] <pmichaud> for example, in Parrot it's not currently possible to grab a method directly from a class object without going through the inspect interface somehow

[17:52] <jnthn> pmichaud: Right.

[17:53] <pmichaud> the tricky part about   $x.Foo::bar()   is being able to recognize that the 'bar' part is a different sort of lookup from what we normally do with Foo::bar

[17:53] <pmichaud> normally 'bar' would be a namespace lookup

[17:54] <jnthn> Right.

[17:54] <pmichaud> anyway, lunchtime here

[17:54] <jnthn> It takes some munging.

[17:54] <pmichaud> bbiaw

[17:55] <__ash__> why not find the last :: and check if whats before it is a class? so in $x.Bar::Foo::Baz::test(); it would check for Baz in the Bar::Foo namespace? or could that end up being wrong? 

[17:55] <pmichaud> __ash__: because a class also defines a namespace

[17:56] <__ash__> (this is why in php 5.3 with namespaces they separate namespaces with \ )

[17:56] <pmichaud> class Foo { sub bar() { ... };   method baz() { ... } }

[17:56] <pmichaud> Foo::bar()   # works

[17:56] <jnthn> Aye, we only need to transform this if it is in a dotty.

[17:58] <pmichaud> afk lunch for real this time

[18:08] *** hercynium left
[18:13] <__ash__> brb i need to restart

[18:13] *** __ash__ left
[18:16] *** alester joined
[18:17] *** kane_ left
[18:19] <arthur-_> how do I add some code to an object that gets executed just after new ?

[18:19] <arthur-_> some cool way to do it or I must write new myself ?

[18:19] <moritz_> arthur-_: submethod BUILD is called automatically on new()

[18:19] <arthur-_> moritz_: thanks

[18:19] <moritz_> rakudo: class A { submethod BUILD { say "OH HAI" }}; A.new

[18:20] <p6eval> rakudo 0d4fe0: OUTPUT«OH HAI␤»

[18:25] *** Front_slash left
[18:27] *** KyleHa joined
[18:28] <KyleHa> std: say %( 'foo' ~~ /<alpha> oo/ ){ 'alpha' }:exists;

[18:28] <p6eval> std 27981: OUTPUT«ok 00:03 38m␤»

[18:29] <KyleHa> std: say %( 'foo' ~~ /<alpha> oo/ ).exists( 'alpha' );

[18:29] <p6eval> std 27981: OUTPUT«ok 00:02 37m␤»

[18:29] <KyleHa> That's "I can parse that even though it doesn't do anything", right?

[18:30] <moritz_> right.

[18:33] <PerlJam> arthur-_: what do you want to get executed after new?

[18:33] <arthur-_> a bit of code to split a proprety into a private property ...

[18:33] <KyleHa> rakudo: say %("foo" ~~ /foo/).exists("foo")

[18:33] <p6eval> rakudo 0d4fe0: OUTPUT«Method 'exists' not found for invocant of class 'Hash'␤»

[18:34] <KyleHa> That's the original bug report  (http://rt.perl.org/rt3/Ticket/Display.html?id=64948).

[18:34] <PerlJam> arthur-_: you *might* be able to call wrap() on your class' new method

[18:35] <arthur-_> # Looks like you failed 5 tests of 14 ... submethod BUILD breaks my tests, is there any doc about it ? i don't find a lot

[18:35] <moritz_> KyleHa: I think you can't test that in a meaningful way that works both in Rakudo and in Perfect Perl 6

[18:36] <KyleHa> I'll settle for testing it in Perl 6.

[18:37] <KyleHa> Seems like this ought to be true:  %( 'foo' ~~ /<alpha> oo/ ){ 'alpha' }:exists;

[18:37] <moritz_> correct

[18:41] <KyleHa> Moritz:  I commented on this one of yours:  http://rt.perl.org/rt3/Ticket/Display.html?id=65080

[18:41] *** kane_ joined
[18:42] <moritz_> rakudo: given 'foo' { if /bar/ { 1 } }

[18:42] <p6eval> rakudo 0d4fe0:  ( no output )

[18:43] *** __ash__ joined
[18:43] *** hercynium joined
[18:44] <moritz_> KyleHa: we can close it if no testing is possible, at least with reasonable effort

[18:44] *** KyleHa left
[18:44] *** KyleHa joined
[18:45] <PerlJam> If Rakudo* never outputs a "Null PMC access", it will be a tremendous success.  :)

[18:46] <moritz_> PerlJam: I don't think it's too hard to warp a "Null PMC acccess" into a generic "internal error"

[18:48] <KyleHa> Is it safe to say { ! %( ... ).can( 'exists' ) }  ?

[18:50] <pmichaud>  I suspect that most of our null pmc accesses will disappear when we fix up lexicals

[18:51] <PerlJam> KyleHa: what do you mean by "safe to say"?  :)

[18:51] <pmichaud> ('foo' ~~ /<alpha> oo/).hash.exists('alpha')

[18:51] <pmichaud> rakudo: ('foo' ~~ /<alpha> oo/).hash.exists('alpha')

[18:51] <p6eval> rakudo 0d4fe0: OUTPUT«Method 'exists' not found for invocant of class 'Hash'␤»

[18:51] <pmichaud> rakudo:  my %x = 1..4;   say %x.exists('1')

[18:51] <moritz_> KyleHa: I don't think it makes sense to test such a thing

[18:51] <moritz_> KyleHa: we can't test for a huge list of method names

[18:52] <PerlJam> moritz_: why not?

[18:52] <p6eval> rakudo 0d4fe0: OUTPUT«1␤»

[18:52] <pmichaud> if the question is writing a test for .exists, the tests hould simply be   %a.exists

[18:52] <KyleHa> We can test for one we know is/was wrong.

[18:52] <moritz_> PerlJam: we can, but we don't gain much

[18:52] * moritz_ not convinced

[18:52] <PerlJam> moritz_: if the spec says class C must have method M, we gain the knowledge that it indeed does. :)

[18:52] <moritz_> anyway, proceed as you see fit

[18:54] <PerlJam> btw, is there a way to execute something at composition time?  

[18:54] <moritz_> composition time is compile time

[18:55] <PerlJam> I was thinking a little finer grained than that.

[18:55] <pmichaud> why does #65080 "defy testing"?

[18:55] <jnthn> Well, specifically it's at the point that class is composed.

[18:56] <jnthn> PerlJam: Would you want to run it before or after the class was composed though?

[18:56] <PerlJam> jnthn: after, but why not both?

[18:56] <pugs_svn> r27982 | kyle++ | [t/spec] feeble test for RT #64948

[18:56] <jnthn> PerlJam: Well, I can imagine uses for both.

[18:56] <moritz_> pmichaud: well, it could be tested by launching a new perl process...

[18:57] <pmichaud> why would we need a new perl process?

[18:57] *** payload joined
[18:57] <pmichaud> I don't understand what the problem is.

[18:57] <moritz_> pmichaud: how would you write a test for that?

[18:58] <pmichaud> my $val = 0;  given 'foo' { if /bar/ { $val = 1; } };  ok $val, 'passed'

[18:58] <PerlJam> jnthn: the original reason that I was thinking about this has since excaped me, but it was something like having a role that dynamically creates methods based on what's already composed into the class.

[18:58] <pmichaud> or switch up the values

[18:58] <PerlJam> s/ex/es/

[18:58] <pmichaud> my $val = 1;  given 'foo' { if /bar/ { $val = 0; } };  ok $val, 'passed'

[18:58] <jnthn> PerlJam: I think it's come up before at some point.

[18:58] *** kent\n joined
[18:58] <jnthn> PerlJam: My feeling is that we're going to want to have a .^compose or similar on a metaclass.

[18:59] <moritz_> pmichaud: iirc even 'use Test;' made the problem go away

[18:59] <jnthn> PerlJam: You should write a trait that does something like

[18:59] <moritz_> pmichaud: but I don't remember specifics - I'd have to check out an old rakudo to try it

[18:59] <PerlJam> jnthn: or perhaps PRECOMPOSE/POSTCOMPOSE blocks that you can put in roles and classes

[18:59] <pmichaud> obviously whatever problem it had uncovered is no longer present, then.

[18:59] <pmichaud> we can either include the exact test given in the ticket, or we can decide it's untestable

[19:00] <pmichaud> I'm fine with either approach.

[19:00] <jnthn> $metaclass does role { method compose($obj) { ...pre-things...; $proto = callsame; ...post-things...; return $proto; } } # note very hypothetical

[19:00] *** M_o_C joined
[19:00] <jnthn> PerlJam: Yes, or we could have some sugar like that.

[19:00] <jnthn> PerlJam: Even if that doesn't make it into core though, it'd be something I expect you could easily build later on as a module.

[19:01] <pmichaud> it does concern me that we're getting a lot of "lives_ok" sorts of tests in the suite.  The whole point of fudging was so that we wouldn't have to be doing eval on a bunch of tests.

[19:02] <PerlJam> your wrap-a-like version is neat enough that maybe we could just use wrap itself.   role R { };  R.wrap(...)

[19:02] <jnthn> .wrap is defined on routines.

[19:02] <PerlJam> I know, I'm saying extend it.

[19:02] <jnthn> Ah.

[19:02] <PerlJam> MMD++  :)

[19:04] *** eternaleye joined
[19:05] *** KyleHa left
[19:07] *** gigabo left
[19:08] *** frederico left
[19:09] <__ash__> jnthn: so, um.... did you ever decided if it would be appropriate to modify find_method for explicit parent calls? 

[19:09] <jnthn> __ash__: I just pondered it a bit over dinner.

[19:09] *** sri_kraih left
[19:09] *** iblechbot joined
[19:11] <jnthn> __ash__: I think we can make it by just looking up the thingy in the namespace (as in, the Foo in .Foo::bar(...)), a call to find_method supplying what we looked up for Foo and the 'bar' as the name to find, and then emitting a normal call on that, passing along the invocant.

[19:11] <jnthn> That makes it work for parent classes. We'd need to detect and special-case SUPER, but we'll worry about that later.

[19:12] <jnthn> And for roles, we can fix up the punning code to be smart enough to handle this, and still keep it reasonably cheap.

[19:12] <jnthn> If you can get a patch to make it work for the parent classes, I'm happy to do the role punning tweak.

[19:13] <cxreg> heh, rakudo's .gitignore is amusing

[19:13] <jnthn> But I'm pretty sure we can make it all work this way.

[19:13] <cxreg> some duplicates, and specific .o files named but others not

[19:13] *** payload left
[19:13] <jnthn> cxreg: Well, given I didn't know it existed... ;-)

[19:13] <cxreg> :)

[19:13] <jnthn> cxreg: Patches welcome. :-)

[19:14] *** sri_kraih joined
[19:16] <__ash__> jnthn: i will work on that, I can see what I can get done (i am still not very familiar with all the inner workings perl6, this is how i was planning on getting to know it) 

[19:17] <jnthn> __ash__: Feel free to ask questions, I'll try and answer.

[19:17] <jnthn> __ash__: My expectation is that you can get it working for the parent class case with only changes in actions.pm.

[19:17] <jnthn> I'll also point you at the parse_name method, which will help you.

[19:17] <jnthn> (look for other usages of it in actions.pm)

[19:18] <__ash__> alright, thanks, i'll go over the actions.pm file and try to get a better understanding, and i'll read up on parse_name first

[19:18] *** payload joined
[19:19] <jnthn> Basically it is a split on :: with some extra bits. :-)

[19:20] *** donaldh left
[19:20] *** SmokeMachine joined
[19:20] *** donaldh joined
[19:21] <arthur-_> moritz_: your BUILD code kinda makes properties dissapear

[19:21] <arthur-_> rakudo: class A { has $.a; }; my $a = A.new( a => 2 ); say $a.a

[19:22] * moritz_ doesn't understand what arthur-_ means

[19:22] <p6eval> rakudo 0d4fe0: OUTPUT«2␤»

[19:22] <frettled> N00b question: I'm trying to some naïve CSV file parsing where I need to strip the final [\r\n]+ from each line, and strip beginning and ending spaces within each field. I've gotten this far, but don't seem able to easily get rid of the spaces in each element: http://gist.github.com/167399

[19:22] <arthur-_> rakudo: class A { has $.a; submethod BUILD { say "OH HAI" } }; my $a = A.new( a => 2 ); say $a.a

[19:22] <frettled> (I know i can loop over the split again, but I thought there might be a more elegant way)

[19:23] <PerlJam> frettled: you already use trim, use it again!

[19:23] <p6eval> rakudo 0d4fe0: OUTPUT«OH HAI␤Use of uninitialized value␤␤»

[19:23] <frettled> PerlJam: split().trim results in weirdness.

[19:23] <moritz_> split()>>.trim

[19:23] <frettled> ahaaaa

[19:24] <moritz_> you need to apply it to each element returned by split

[19:24] <arthur-_> moritz_: http://pastebin.ca/1528437

[19:24] <jnthn> arthur-_: Rakudo bug rather than moritzbug.

[19:24] <moritz_> rakudo: class A { has $.a; submethod BUILD { say "OH HAI" } }; my $a = A.new( a => 2 ); say $a.a

[19:24] <p6eval> rakudo 0d4fe0: OUTPUT«OH HAI␤Use of uninitialized value␤␤»

[19:24] <moritz_> arthur-_: jnthn is right - could you please submit that to [email@hidden.address]
[19:25] * moritz_ wonders if masak++ has a workaround for that (and why he didn't submit that already)

[19:25] <frettled> moritz_: Thanks, I knew I was forgetting something vital.

[19:25] <arthur-_> moritz_: i was not sure i was doing correct perl6 ...

[19:25] <arthur-_> i submit

[19:25] <moritz_> arthur-_: it should work

[19:25] <moritz_> frettled: you can also split on / \s* ',' \s*/

[19:26] <PerlJam> frettled: or  $string.split(rule { ',' }) too I think

[19:26] <jnthn> moritz_: It's been discussed here on #perl6 before, for sure.

[19:28] <frettled> moritz_: ah, I should've seen that myself, thanks.

[19:28] <frettled> PerlJam: what would the use of rule do there?

[19:29] <PerlJam> frettled: rules automatically have :sigspace on, so you get <.ws> where ever there is whitespace in your pattern

[19:30] <frettled> aha!

[19:30] <PerlJam> frettled: though splitting on comma like that won't handle triming leading spaces from the first element.  It's best to call trim() if you really do mean to trim it.

[19:31] <ingyfoo> hi. can I patch rakudo to have Configure.pl generate a 'make install' target that puts `perl6` next to the `perl` that was used to run Configure.pl?

[19:31] <ingyfoo> s/can/may/

[19:32] <PerlJam> ingyfoo: you want "make install" to create /usr/bin/perl6 if /usr/bin/perl was used ?

[19:32] <ingyfoo> oui

[19:33] <PerlJam> you can always fork or make a branch that does that.

[19:33] <ingyfoo> is make install not wanted?

[19:34] <PerlJam> There's already a make install.  The question is "install where?"  :)

[19:35] <frettled> PerlJam: actually, that's probably better handled by doing a per-line trim(), things get funky if I try to use >>.trim() twice.  I've updated the gist now with a version that very nearly pretty-prints like I want to (which would be one line per dimension, or something)

[19:35] <diakopter> [OT] for those curious: http://www.ibm.com/developerworks/opensource/library/os-blue/index.html

[19:38] <PerlJam> looks like prototype-based OOP

[19:39] <PerlJam> and they've been around python of javascript too much

[19:39] <PerlJam> s/of/or/

[19:42] <ingyfoo> PerlJam: I know how to fork and pull request. Just wondering if that fix is desired for rakudo. Why is there not a make install target?

[19:42] <PerlJam> there *is* a make install.

[19:42] <ingyfoo> oh

[19:42] *** eternaleye_ joined
[19:43] <ingyfoo> well someone should update http://rakudo.org/how-to-get-rakudo

[19:43] <ingyfoo> :)

[19:43] <jnthn> ingyfoo: To be fair, the make install branch was only merged yesterday or so. ;-)

[19:43] <PerlJam> indeed.

[19:43] <jnthn> But yes, that needs an update now. :-)

[19:44] <__ash__> you can make install perl6 ? 

[19:45] <__ash__> rakudo i guess i should be asaying

[19:45] <jnthn> __ash__: Yes, as of yesterday.

[19:45] <jnthn> Plus it was broken on Win32 / MSVC++ until today.

[19:45] <jnthn> But latest should be installable.

[19:45] <PerlJam> Sounds like there should have been an announcement or something  :)

[19:45] <__ash__> cool, does it install parrot also? 

[19:47] <frettled> it does *

[19:47] <jnthn> (* see terms and conditions)

[19:48] <jnthn> (If you do --gen-parrot, it'll just make an installed Parrot under parrot_install in your build directory - if you want more control, then build/install Parrot, then build Rakudo using the installed Parrot.)

[19:51] *** eternaleye left
[19:55] <cotto> jnthn, I really liked the Perl 6 code in your latest use Perl post.

[19:57] <jnthn> cotto: Nice. :-)

[19:57] *** zamolxes joined
[19:58] *** tak11 joined
[19:58] <cotto> It's helpful to see those language features combined to do something (moderately) useful.

[19:59] *** KyleHa joined
[19:59] <KyleHa> This public wifi stinks.

[19:59] <takadonet> cotto: url please :)

[19:59] <moritz_> takadonet: you should follow the http://planetsix.perl.org/ feed ;-)

[20:00] <jnthn> Maybe I should try and do some more slightly larger examples in future posts, to show how things get used together. :-)

[20:00] <cotto> takadonet, http://use.perl.org/~JonathanWorthington/journal/39455

[20:00] <KyleHa> While I've been semi-online, I chased down RT 65080 some more.

[20:00] <takadonet> moritz_: I do just lazy right  now

[20:00] <cotto> jnthn, I'd love that.

[20:00] <takadonet> and just realized I seen it already hehe

[20:01] <KyleHa> I went back to the Rakudo that had the problem and reproduced it.  If it's in a file, it only bombs if it's at the end of the file.  A comment after it makes it go away.

[20:01] *** KyleHa left
[20:01] *** eMaX left
[20:01] *** KyleHa joined
[20:01] <KyleHa> *sigh*

[20:02] <KyleHa> Anyway, an eval_lives_ok with it fails, but it's a different error than "Null PMC".

[20:02] <pmichaud> I don't want there to be an eval_lives_ok there.

[20:03] <KyleHa> Can you think of another way to test it, then?

[20:03] <pmichaud> just put it there and skip it.

[20:03] <frettled> PerlJam: I think I finally grokked how to use subst(), and managed to get a pretty nice result.  Thanks for the help.

[20:03] <pmichaud> (if it's not working in current rakudo)

[20:03] <pmichaud> we don't need to be putting eval around every test.

[20:03] <KyleHa> It IS working in current Rakudo, and it'll work in the old Rakudo too if you just put it there and skip it.

[20:04] <pmichaud> then we don't need eval_lives_ok

[20:04] <KyleHa> Maybe my other message got lost...the thing only croaks if it's at the end of the file.

[20:04] <pmichaud> eval_lives_ok should really be reserved for those things where we might reasonably expect an exception to be thrown by an almost-complete perl 6 implementation

[20:05] <pmichaud> eval_lives_ok should not be used just to wrap tests where rakudo is broken and currently throws exceptions that it's not supposed to be throwing

[20:05] <pmichaud> "rakudo broken" is what fudge is for.

[20:06] * moritz_ sent a mail to p6c with a nice (but non-working) patch some hours ago, but it seems from the wrong email address

[20:06] <KyleHa> I don't see how this case can be tested using only fudges.  If we'd like to leave it untested (since it's now fixed), that's fine.  I'm just saying that fudge won't handle everything.

[20:07] <moritz_> so far it didn't percoluate through

[20:07] <pmichaud> if you're saying that fudge won't handle the case of someone using a months-old version of rakudo, that's fine.

[20:07] <pmichaud> moritz_: unrecognized addresses on p6c are often moderated

[20:07] <takadonet> cya tomorrow everyone

[20:07] *** takadonet left
[20:08] <KyleHa> It won't handle the case of a bug that bug that's triggered by code being at the end of input, unless we're willing to devote a file to the test.

[20:08] <pmichaud> okay.

[20:08] <pmichaud> and using eval exposes that?

[20:08] <KyleHa> Yes.

[20:08] <KyleHa> Well, sort of.  That's what I was here to talk about.

[20:09] <KyleHa> The eval dies with a syntax error while the bug out in the wild dies with Null PMC access.

[20:10] <pmichaud> does the bug shows up if parrot is run with -G ?

[20:10] <lisppaste3> moritz_ pasted "gives "Method 'postcircumfix:( )' not found for invocant of class 'WhateverCode'" when called as (*.()).(1+*) " at http://paste.lisp.org/display/85338

[20:11] <pmichaud> moritz_: why are you overriding the existing invocation on Whatever ?

[20:11] <moritz_> rakudo: *()

[20:11] <p6eval> rakudo 0d4fe0: OUTPUT«invoke() not implemented in class 'Undef'␤in Main (/tmp/34mbaDUUIF:2)␤»

[20:11] <moritz_> pmichaud: there is no existing invokation

[20:11] <KyleHa> I'm using the perl6 executable.  How do I run via Parrot?

[20:11] <pmichaud> Whatever is not Code, afaik

[20:11] <moritz_> pmichaud: only in WhateverCode, not in Whatever

[20:11] <pmichaud> KyleHa: parrot_install/parrot -G perl6.pbc ...

[20:12] <moritz_> pmichaud: I want to be able to write @array_of_closures.sort: *.(5)

[20:12] <moritz_> which would sort by the result of calling the closures with .(5)

[20:13] <KyleHa> Yes, the bug's still triggered with parrot -G

[20:13] <pmichaud> KyleHa: okay.  I'm fine with eval_lives_ok then.

[20:13] <pmichaud> KyleHa: thanks for being patient with me :)

[20:13] <moritz_> if I call it as (*.()).(-> $x { say $x }) then I get "Method 'postcircumfix:( )' not found for invocant of class 'Block'"

[20:13] <KyleHa> And it turns out I'm wrong about eval.  It died for some other reason.

[20:13] <pmichaud> rakudo:  $_ = { say $^a };    $_.(5);

[20:13] <p6eval> rakudo 0d4fe0: OUTPUT«5␤»

[20:14] <pmichaud> rakudo:  $_ = { say $^a };    .(5);

[20:14] <p6eval> rakudo 0d4fe0: OUTPUT«5␤»

[20:14] <moritz_> but why does it try to call the postcircumfix, and not the invoke vtable?

[20:14] <pmichaud> rakudo:  $_ = { say $^a };    (*.(5))($_);

[20:14] <p6eval> rakudo 0d4fe0: OUTPUT«invoke() not implemented in class 'Undef'␤in Main (/tmp/TOj5sEPvwf:2)␤»

[20:14] <KyleHa> What does running with parrot -G do?

[20:14] <moritz_> KyleHa: doesn't run the GC

[20:14] <pmichaud> moritz_: I suspect that *.(5)   should return a WhateverCode

[20:14] <pmichaud> instead of overloading invoke on Whatever

[20:15] <KyleHa> moritz: I see, so if it survives that, you know that it's the garbage collector causing the problem.

[20:15] <pmichaud> but yes, I see the chicken-egg problem there.

[20:15] <moritz_> pmichaud: can I rebless the returned block to be of type WhateverCode?

[20:16] <pmichaud> KyleHa: there are a number of "weird parrot bugs" where -G makes them disappear 

[20:16] <KyleHa> OK.  That's good to know, thanks.

[20:16] *** frew__ joined
[20:17] <pmichaud> moritz_: I'm not quite sure how to do the that rebless at the moment.

[20:17] <pmichaud> s/the//

[20:18] <jnthn> rakudo: say WhateverCode ~~ Whatever

[20:18] <p6eval> rakudo 0d4fe0: OUTPUT«0␤»

[20:18] <pmichaud> WhateverCode is a subclass of Code

[20:18] <pmichaud> not of Whatever

[20:18] <moritz_> anyway, it's not a high priority, it would just have made an obfu more gra^Wawesome

[20:18] <pmichaud> currently build/gen_whatever manages it by explicitly calling !fixup_routine_type from PIR

[20:19] <pmichaud> note that I expect we will need to completely refactor all meta-operator handling in Rakudo if we want to get infix:<+> overloading to work

[20:19] <pmichaud> (based on working on it yesterday)

[20:19] <moritz_> so should I wait a bit longer before investing more time on it?

[20:20] <pmichaud> I would wait, yes.

[20:20] <pmichaud> I'm currently looking at operator refactors.

[20:20] <pmichaud> because I really want overloading of builtin ops to work

[20:21] <frettled> I have another coding question :)  Let's say I have this awful autogenerated two-dimensional array of mine, generated from a CSV file with a header line, and want to convert that to a hash where the keys are the elements of the header line.  Is there a shortcut trick for that?

[20:21] <jnthn> pmichaud: (refactor all meta-operator handling) - how come?

[20:22] <pmichaud> well, in the case of infix:<+>, we also have to make the whatever forms into multis

[20:22] <frettled> I know I can do my %data = @data[0] Z @data[1] for the first line

[20:22] <moritz_> frettled: look at %hash.push

[20:22] * frettled feels there's something just out of grasp here, waiting to leave me gobsmacked.

[20:23] <pmichaud> but more to the point, I'm dissatisfied with the current deconstruction of our metaop handling in Rakudo

[20:23] <moritz_> you can write %hash.push: %( @data[0] Z @data[$i] )

[20:23] <pmichaud> it's very special-cased in places it shouldn't be.

[20:23] *** _timbunce left
[20:23] <frettled> moritz_: ooh

[20:23] *** eternaleye_ is now known as eternaleye

[20:24] <pmichaud> frettled: I wonder if   %data = @data[0] Z @data[1..*-1]      works

[20:25] <pmichaud> actually, I guess not.

[20:25] * moritz_ would be surprised if it would

[20:25] <frettled> pmichaud: nopes, that assigns rows to columns

[20:25] <frettled> actually, I did that without the -1 until I realized that I was off my rocker.

[20:28] *** KyleHa_ joined
[20:29] *** KyleHa left
[20:29] <pmichaud> rakudo:  my $x = *.xyz();   say $x.WHAT;

[20:30] <p6eval> rakudo 0d4fe0: OUTPUT«Block()␤»

[20:30] <pmichaud> rakudo:  my $x = *.xyz.abc;   say $x.WHAT;

[20:30] <p6eval> rakudo 0d4fe0: OUTPUT«Method 'abc' not found for invocant of class 'Block'␤»

[20:30] *** KyleHa_ left
[20:30] <pmichaud> I suspect that *.xyz should be returning a WhateverCode now

[20:31] <jnthn> pmichaud: Weren't those going to be done syntactically?

[20:31] <jnthn> Or did the spec move again? Or did I mis-remember?

[20:31] <pmichaud> jnthn: that was before we had WhateverCode objects

[20:31] <pmichaud> I don't know if we still recognize it syntactically

[20:32] *** japhb left
[20:32] <pmichaud> but I'm pretty sure that *.xyz.abc  is going to want to mean  { $_.xyz.abc }   and not  { $_.xyz }.abc

[20:32] <jnthn> Agree

[20:33] <pmichaud> then I suspect a similar situation exists for *.()

[20:33] <pmichaud> if we're going to cover moritz's case

[20:33] *** timbunce joined
[20:34] <pmichaud> on the other hand, it's useful to note that   *.() and  (*+1).()   would mean entirely different things

[20:34] <pmichaud> so perhaps .() doesn't "whateverize" its lhs

[20:34] <pmichaud> i.e., the way to do the equivalent of   *.(5)  is to actually do   { $_.(5) }

[20:40] <[particle]> then what is (*.xyz).abc ?

[20:40] *** iblechbot left
[20:41] *** timbunce left
[20:41] <[particle]> or (*.xyz).()

[20:42] <moritz_> the latter is an error.

[20:44] <[particle]> doesn't *.xyz execute before .() ?

[20:44] <moritz_> yes, it generates a closure of arity one

[20:44] <moritz_> and .() calls it with 0 args => error

[20:45] <[particle]> ah, ok. so .(...) then

[20:45] <[particle]> i'm looking to avoid arity problems here, just figuring out how * behaves

[20:45] <[particle]> better, how an expression involving * is interpreted

[20:50] *** timbunce joined
[20:51] <pmichaud> in general, expressions involving * tend to generate closures

[20:51] <pmichaud> it's interesting to speculate on whether * is in fact itself a WhateverCode object :-)

[20:52] <jnthn> How would you then get a Whatever? ;-)

[20:52] *** payload left
[20:52] <jnthn> It may be possible to unify the two somehow though...

[20:52] <jnthn> ...maybe...

[20:53] <pmichaud> it would be nice, because as things stand now we end up with four variants of each binary operator

[20:53] *** leedo_ left
[20:53] *** ujwalic joined
[20:54] *** molaf left
[20:55] <pmichaud> that number grows further when we start mixing with other metops

[20:55] <pmichaud> *metaops

[20:56] *** timbunce left
[20:58] <ujwalic> to know the OS from Perl6 what should be used $?KERNEL or $*KERNEL or $?VM or $?DISTRO 

[20:59] <moritz_> rakudo: say %*VM.perl

[20:59] <p6eval> rakudo 0d4fe0: OUTPUT«{"config" => {"libparrot_for_makefile_only" => "\$(LIBPARROT_SHARED)", "-Wstrict-prototypes" => "1", "-Wno-shadow" => "1", "rm_rf" => "\$(PERL) -MExtUtils::Command -e rm_rf", "ld_debug" => "", "int8_t" => "long long", "hugeintval" => "long long", "inc" => "include/parrot",

[20:59] <p6eval> .."-Wneste…

[21:00] <mkelly32> where are all those neat things documented?

[21:00] <mkelly32> (both the magic variables, and things like .perl)

[21:02] *** payload joined
[21:02] <moritz_> mkelly32: S32::* and S28

[21:03] <mkelly32> moritz_: thanks.

[21:03] <ujwalic> moritz_: I am on windows t\spec\S02-literals\quoting.rakudo q:x fails due to \r\n

[21:05] <moritz_> ujwalic: thanks, I'll try to fix it

[21:08] <jnthn> fwiw, I've been seeing that fail for a while too, but thought it was a Parrot issue for some reason.

[21:09] *** Whiteknight joined
[21:10] <mkelly32> moritz_: so, is my best option to just read all the synopsis? 

[21:11] <mkelly32> and, is http://perlcabal.org/syn/ the right place to get them from?

[21:11] <moritz_> it is

[21:11] *** hercynium left
[21:11] <moritz_> mkelly32: well, there are other resources too, but not as comprehensive

[21:11] <moritz_> mkelly32: for example I wrote http://perlgeek.de/blog-en/perl-5-to-6/

[21:12] <moritz_> (read them in the order of the left column links)

[21:13] <mkelly32> oh, yeah. i think i remember seeing your thing a while ago. at least one or two of them.

[21:14] *** japhb joined
[21:15] <ujwalic> moritz_: what is the type of %*VM.perl

[21:16] <moritz_> ujwalic: .perl always returns strings

[21:16] *** pyrimidine left
[21:17] <ujwalic> moritz_: thaks .. I was trying to get %*VM.perl<win32>

[21:18] *** Patterner left
[21:18] <szbalint> I wonder if the recent YAPC::EU talk is up on slideshare or somewhere else about perl5->6

[21:18] *** kent\n left
[21:18] <moritz_> szbalint: the one from mberends is in the pugs repo

[21:18] <moritz_> docs/talks/ or so

[21:19] *** tann joined
[21:19] <szbalint> excellent, ty

[21:21] *** frederico joined
[21:23] <cxreg> so, hyperoperators should probably support GPGPU, eh? :)

[21:23] <moritz_> cxreg: patches welcome ;-)

[21:24] <moritz_> there are a myriad of possibilities in Perl 6. They just need to be implemented

[21:24] <cxreg> i wonder how much of the vm you'd have to mangle for that to work

[21:24] <cxreg> maybe just simple SIMD is a better first step

[21:24] <cxreg> perl --use-mmx2

[21:25] <moritz_> actually a usable sse2 implementation would help a lot in terms of speed

[21:26] <jnthn> ooh, slides from yapc...I should upload those...

[21:27] <frettled> moritz_: considering that they are all but ubiquitous right now, that's only going to improve

[21:27] <frettled> jnthn: yes, please :)

[21:27] <frettled> I wonder if Paul Fenwick has gotten around to uploading his yet ...

[21:29] <szbalint> Heghlu'meH QaQ jajvam!

[21:31] *** Psyche^ joined
[21:31] <mkelly32> hrm... 'but False' is an interesting concept. better than some of the voodoo DBI does to get a '0 but True' by returning '0E0'

[21:31] *** Psyche^ is now known as Patterner

[21:36] <frettled> szbalint: My Klingon is weak.

[21:39] <szbalint> (today is a good day to die)

[21:40] *** ujwalic left
[21:45] <frettled> Aha!

[21:47] <jnthn> frettled: Now linked from http://www.jnthn.net/articles.shtml

[21:51] *** pmurias left
[21:54] *** SmokeMachine left
[21:55] *** M_o_C left
[21:59] <arthur-_> i'm pretty sure I saw a way to do something like this : for @a, @b -> $from_a, $from_b { ... } ... but I find nothing in the docs

[22:01] <PerlJam> arthur-_: for @a Z @b -> $a, $b { ... }

[22:01] <arthur-_> PerlJam: thanks a lot

[22:02] * PerlJam idly wonders if Arrays will support a .transpose method

[22:03] <PerlJam> then that problem that frettled was struggling with earlier would be easy

[22:04] <arthur-_> wooo, worked !

[22:06] <frettled> jnthn++ - brilliant

[22:08] *** timbunce joined
[22:08] *** timbunce left
[22:14] *** ujwalic joined
[22:14] <pugs_svn> r27983 | moritz++ | [evalbot] use an installed parrot + rakudo to avoid downtime on rebuild

[22:15] *** p6eval left
[22:15] *** p6eval joined
[22:15] <moritz_> rakudo: say "test"

[22:15] <p6eval> rakudo 0d4fe0: OUTPUT«test␤»

[22:18] *** ruoso left
[22:21] *** __ash__ left
[22:22] <frettled> jnthn: BTW, if you think it's a good idea, Someone™ has added a group on slideshare.net (http://www.slideshare.net/event/yapceu2009) for this.

[22:22] <frettled> I've added a link to the PresentationSlides part of the YAPC2009 Wiki.

[22:23] <frettled> PerlJam: I was about to say something about that, but at that time, pmichaud et al were already involved in another discussion regarding complications ,)

[22:28] <moritz_> after rebuilding and installing parrot and rakudo about twenty times I now have a dual dir setup for p6eval 

[22:28] <frettled> PerlJam: I was also thinking about something using pairs() with the original wd array, but that may have been sleepiness talking.

[22:28] <moritz_> it first installs parrot and rakudo into ~/p1/

[22:28] <moritz_> and then uses ~/p1/bin/perl6

[22:28] <frettled> …to bootstrap the next one?

[22:29] <moritz_> the next rebuild installs into ~/p2/, and only switches usage after it has been  completely installed

[22:29] <moritz_> frettled: no, it's just to avoid the downtime which occured these days when rakudo was rebuild

[22:29] <frettled> Aha.

[22:30] <frettled> Should I submit the test results for «make spectest» somewhere, BTW, since I compiled on a platform that's growing old and weird? :)

[22:31] <moritz_> we don't have a centralized smoke server :(

[22:31] <frettled> Okay.

[22:32] *** rfordinal left
[22:32] <frettled> I see three cases of redeclared variables, and two cases of failed assertions (the same assertion, I think, but in two different tests).

[22:32] <moritz_> yes, that's known

[22:33] <frettled> Nothing special about my platform for that, then.

[22:33] <frettled> Just that annoying thing with the failing version check in Parrot.

[22:47] *** jferrero joined
[22:49] <pugs_svn> r27984 | ujwal++ | refactored q:x for MSWIN32

[23:18] *** mersel joined
[23:20] *** donaldh left
[23:20] <pugs_svn> r27985 | lwall++ | [STD] parse indented pod

[23:21] *** donaldh joined
[23:30] <frettled> Hmm, perhaps there could be a transpose operator and not just a .transpose.  Muahaha.

[23:35] <TimToady> Do mathmeticians define transpose on anything other than 2-D arrays?

[23:35] *** explorer__ joined
[23:36] <TimToady> *mathematicians, grr

[23:36] <frettled> I can't say that I recall, but then I flunked elementary linear algebra.

[23:36] *** explorer__ left
[23:36] <frettled> I have this vague nightmarish memory that we were trying to transpose 2D matrices in 3D space, though.

[23:37] <frettled> I haven't looked at this since 1993, so please bear with me.  :)

[23:38] <frettled> Ah, it appears that transposition is defined as a swap of rows for columns and vice versa.

[23:39] <frettled> I found this: http://en.wikipedia.org/wiki/In-place_matrix_transposition

[23:39] <TimToady> maybe it's related to the autoindex section of S09

[23:39] <TimToady> If it's in-place, it's a side effect, and therefore evil under FP :)

[23:40] *** Limbic_Region joined
[23:41] <frettled> Well, the memory handling is implementation dependent and arbitrary too, isn't it? :D

[23:42] <ujwalic> I found this http://mathworld.wolfram.com/Transpose.html

[23:42] <frettled> Yep, that's referenced in the WP article on Transpose.

[23:43] <ujwalic> and this http://mathworld.wolfram.com/ConjugateTranspose.html

[23:43] <ujwalic> ok

[23:44] *** ihrd joined
[23:45] *** cdarroch left
[23:45] <frettled> If we were to have a transpose operation, then the spec would only have to say that it should work as a regular n x m matrix transposition, wouldn't that be sufficient?  Writing a simple spec test should also be feasible.  (Though _I_ am not quite there yet.)

[23:46] <frettled> use Mathematica;

[23:50] <frettled> Hmm, perhaps better:

[23:50] <TimToady> see S09:Parallelized parameters and autothreading

[23:51] *** jferrero left
[23:52] <TimToady> use autoindex; do { @out[$^k,$^j] = @in[$^j,$^k] }

[23:52] <frettled> TimToady: you're thinking of do -> @wild { @b[[;] reverse @wild] = @a[[;] @wild] };

[23:52] <frettled> ?

[23:53] <TimToady> er, make those ; instead of ,

[23:53] *** mintsoup joined
[23:53] <frettled> hmm!

[23:53] <mintsoup> i heard this is an mmo, can i join a guild

[23:54] <frettled> mintsoup: yes, but you have to finish a quest first.

[23:54] <TimToady> you need a commit bit for that

[23:54] <TimToady> which is kinda like a horse bit

[23:54] <frettled> with you at the reins

[23:54] <mintsoup> what sort of endgame pvp is there? cuz if it's just battlegrounds all the way down again im not interested

[23:55] *** DakeDesu is now known as KatrinaTheLamia

[23:55] *** KatrinaTheLamia left
[23:55] <TimToady> the behind-the-scenes GM enforces convergence on a pleasing story line

[23:56] <mintsoup> does that mean there's exciting world events?

[23:56] <frettled> TimToady: anyway, yes, autoindex would solve the problem, it seems, and then I^Wsomeone could just create a macro or something for it ;)

[23:57] <frettled> I'll make a note of the syntax you mentioned above.

[23:57] <TimToady> perhaps we could go as far as to invent statement_prefix:<authindex> or some such

[23:59] <TimToady> mintsoup: we tend to optimize for fun rather than exciting

