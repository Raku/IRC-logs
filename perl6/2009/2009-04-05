[00:03] *** Tene_ is now known as Tene

[00:47] *** DemoFreak left
[01:02] *** meppl joined
[01:26] *** nihiliad left
[01:28] *** PhatEddy joined
[01:32] *** PhatEddy left
[01:33] *** PhatEddy joined
[01:34] <PhatEddy> rt 64450, recently opened, is spam - if anyone is around to get rid of oit

[01:36] *** nihiliad joined
[01:36] *** PhatEddy left
[01:39] *** xinming joined
[01:41] <pmichaud> deleted, thanks.

[01:59] *** M_o_C left
[02:01] *** ab5tract left
[02:03] *** payload left
[02:05] *** dKingston left
[02:05] *** dKingston joined
[02:19] *** jferrero left
[02:23] *** payload joined
[02:23] *** amoc joined
[02:34] <eternaleye> Hi, in Perl 6, how would one go about codifying in a regex "match any of 'a', 'b', or 'c', but match each at most once". Would this be possible without using { ... or fail } constructs, or not? If so, how would one go about checking the condition?

[02:34] <eternaleye> s/so/not/

[02:36] <literal> m:P5/([abc])(?!\1)/   :P

[02:36] *** amoc left
[02:37] <s1n> literal is cheating :)

[02:38] <eternaleye> Yeah, one sec while I nopaste what I have so far

[02:38] <eternaleye> http://dpaste.com/24049/

[02:39] <eternaleye> The place I'll put what I'm asking for is denoted by the #[ FIXME ] comment

[02:39] <s1n> rakudo: class Foo { ... }; my Foo $f .= new; say "broken" if $f ~~ Does::Not::Exist

[02:40] <p6eval> rakudo 0310a3: OUTPUT«No exception handler and no message␤current instr.: 'return' pc 15520 (src/builtins/control.pir:39)␤»

[02:40] <eternaleye> And different ones may occur, so for instance 'abc' would match, but 'abb'

[02:40] <eternaleye> would fail

[02:40] <s1n> eternaleye: just out of curiousity, what are you working on there?

[02:40] <literal> looks like a fronted to Portage, Gentoo's package system

[02:40] <eternaleye> A use flag editor for Paludis, my preferred package manager.

[02:41] <eternaleye> An alternative for Portage

[02:41] <s1n> a palidus conf parser

[02:41] <eternaleye> Basically, flagedit for paludis

[02:41] <s1n> ahh, okay

[02:41] <eternaleye> hence 'flagpal'

[02:41] * s1n a long time gentoo user, since 0.8-pre

[02:42] <s1n> jnthn: think  that error i uncovered needs _something_ to clarify

[02:42] <eternaleye> Yeah, I started around 2.6.15 (can't remember the year, but I remeber the kernel XD) with Gentoo as my first linux install.

[02:43] * literal only recently switched from Gentoo

[02:43] <literal> I think the kernel version was 2.5.30 or something when I started :)

[02:43] <eternaleye> Nice.

[02:44] <s1n> i don't remember the kernel version that i started, but i was around for the 2.4 - 2.6 switch, gcc 2.8 to 3.0 switch

[02:44] <s1n> i think 2002 was when i started

[02:44] <literal> hm, probably closer to 2.5.70

[02:45] <s1n> no, i was ~x86 then, it was definitely 2.4 branch

[02:45] * s1n just realized you were making a self reference

[02:45] <literal> :)

[02:45] <pmichaud> there's always  / a[bc?|cb?]? | b[ac?|ca?]? | c[ab?|ba?]? /   :-)

[02:45] <eternaleye> Heh, I just realized I changed the name of the first grammer in the file but not where the other grammars reference it. Well, sed -i time!

[02:45] <literal> I really like ebuilds

[02:46] <eternaleye> pmichaud: Yes, but there are 5 options, and I'd rather not have a giant combinatorial mess

[02:46] <s1n> pmichaud: i think you're missing some '?' there...

[02:47] <eternaleye> Also, each one is several chars long

[02:48] <TimToady> well, you don't really want to use a regex for the constraint.  <?{ panic if %seen{$x}++ }> is more like it, but I don't know how well rakudo would support that yet.

[02:48] <lambdabot> TimToady: You have 1 new message. '/msg lambdabot @messages' to read it.

[02:48] <TimToady> @messages

[02:48] <lambdabot> moritz_ asked 3d 12h 51m 27s ago: S04: while something() -> { ... $^thing ... } # should the arrow be removed here?

[02:49] <TimToady> @clear

[02:49] <lambdabot> Messages cleared.

[02:49] <pmichaud> maybe:    / [ $<a>=[a] | $<b>=[b] | $<c>=[c] ]* /    and then check afterwards that none of $<a>, $<b>, or $<c> are bigger than 1

[02:49] <TimToady> # again, sigh

[02:49] <TimToady> that's the other way, yes

[02:49] <TimToady> and probably gives you the chance to give a good error message

[02:50] <eternaleye> That's probably the best way. Thanks everybody!

[02:50] <TimToady> but trying to enforce semantic constraints with syntactic checks is usually suboptimal

[02:51] <TimToady> It's hard to get a parser to say much more than "Oops, didn't understand that."

[02:51] <eternaleye> So maybe use {*} and check in the action?

[02:52] <TimToady> if you want to prevent _alpha_alpha, sure, that'd be a good way

[02:53] <TimToady> though you shouldn't really need the {*} for a check on the entire rule, since there's one implied on the whole rule anyway.  but I don't think rakudo supports that yet

[02:54] <eternaleye> Hm. I'll probably need to do a for @{ $<versionSpec> } and check for each versionSpec in the file.

[02:54] <eternaleye> Since there is one versionSpec per packageSpec, and there may be multiple packageSpecs

[02:55] <eternaleye> And I'd really only need {*} for the versionSpec token

[02:55] <pmichaud> correct, rakudo (and PGE) still want explicit {*}.

[03:03] <eternaleye> Although, if I wanted to use an embedded { some_function_that_checks_counts( SOMETHING ) or fail }; what should SOMETHING be?

[03:03] <pmichaud> Rakudo doesn't support embedded p6 in regexes yet (coming soon)

[03:03] <eternaleye> So that I could catch the error as the line is being processed, rather than afterwards by traversing $/

[03:04] <pmichaud> that said, it'd still be based on $/, which would be the current (sub)match

[03:05] <eternaleye> pmichaud: That's okay, I'm less concerned with actually _running_ this program ( Vim is enough to make it non-annoying ) than _writing_ it

[03:05] <eternaleye> And that makes sense, ( $/ being the submatch ), what I meant by "not traverse $/" was the $/ for TOP

[03:08] *** dKingston left
[03:17] <eternaleye> So would this work if Rakudo supported embedding p6 in regexes? http://dpaste.com/24054/

[03:26] <eternaleye> Ooh, just realized the brackets around the alternation need to be capturing parens. S05++

[03:26] <TimToady> not necessarily, if you just want to capture strings

[03:27] <eternaleye> Nah, I want a hierarchial arrangement

[03:28] <eternaleye> Since I'm looping over the list of repeated matches to the quantified submatch

[03:28] <eternaleye> Er, I think

[03:30] <eternaleye> Or would foofoobar ~~ / $<var> = [foo|bar] / give $/ with $<var>[0,1,2] as ( 'foo', 'foo', 'bar' )?

[03:30] <eternaleye> Er, s/]/]*/

[03:31] *** meppuru joined
[03:34] <eternaleye> Yeah, empirical testing says I need () instead of []

[03:35] <eternaleye> rakudo: 'foofoobar' ~~ / $<var>=(foo|bar)* /; say ~@( $<var> )

[03:35] <p6eval> rakudo 0310a3: OUTPUT«foo foo bar␤»

[03:35] <eternaleye> rakudo: 'foofoobar' ~~ / $<var>=[foo|bar[* /; say ~@( $<var> )

[03:35] <p6eval> rakudo 0310a3: OUTPUT«perl6regex parse error: Quantifier follows nothing in regex at offset 34, found ' '␤current instr.: 'parrot;PGE;Perl6Regex;parse_error' pc 10552 (compilers/pge/PGE/Perl6Regex.pir:1323)␤»

[03:35] <eternaleye> rakudo: 'foofoobar' ~~ / $<var>=[foo|bar]* /; say ~@( $<var> )

[03:35] <p6eval> rakudo 0310a3: OUTPUT«0␤»

[03:37] <pmichaud> I'm not certain if @(...) works yet.

[03:38] <pmichaud> rakudo: 'foofoobar' ~~ / $<var>=[foo|bar]* /; say $<var>.list.perl;

[03:38] <p6eval> rakudo 0310a3: OUTPUT«[Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ ast  => "foofoobar",␤ text => "foofoobar",␤ from => 0,␤ to   => 9,␤)]␤»

[03:47] *** meppl left
[03:47] <eternaleye> rakudo: 'foofoobar' ~~ / $<var>=(foo|bar)* /; say $<var>.list.perl;

[03:47] <p6eval> rakudo 0310a3: OUTPUT«[Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ ast  => "foo",␤ text => "foo",␤ from => 0,␤ to   => 3,␤), Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ ast  => "foo",␤ text => "foo",␤ from =>

[03:47] <p6eval> ..3,␤...

[03:48] <eternaleye> It does seem to work

[03:48] <eternaleye> rakudo: 'foofoobar' ~~ / $<var>=(foo|bar)* /; say ~@( $<var> )

[03:48] <p6eval> rakudo 0310a3: OUTPUT«foo foo bar␤»

[03:50] *** orafu left
[03:50] *** OuLouFu joined
[04:19] <meppuru> good night

[04:20] *** meppuru left
[04:20] <dalek> rakudo: 7dc65fd | pmichaud++ | build/Makefile.in:

[04:20] <dalek> rakudo: Re-order Makefile targets into slightly more logical sense.

[04:20] <dalek> rakudo: Add a check for Makefile versus build/Makefile.in .

[04:20] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7dc65fde3fdddcba401cec53a30560481ace74c5

[04:34] *** FurnaceBoy left
[04:38] *** iblechbot joined
[04:44] <eternaleye> Oh you have got to be kidding me.

[04:45] <eternaleye> I misread the Package Manager Spec. Repeat version suffixes ar not forbidden, eg =foo-bar/baz-0_alpha_alpha is permitted

[04:45] <eternaleye> Oh well, it was worth it anyway since I learned something

[04:53] *** dduncan left
[05:06] *** iblechbot left
[05:14] *** brunoV left
[05:14] *** mfwitten left
[05:17] *** [particle]2 joined
[05:21] *** Patterner left
[05:22] *** meteorjay joined
[05:30] *** Psyche^ joined
[05:30] *** Psyche^ is now known as Patterner

[05:32] *** justatheory left
[05:40] *** [particle]1 left
[05:41] *** davidad joined
[06:33] *** Khisanth left
[06:40] *** Kisu joined
[06:44] *** rgs joined
[06:55] *** barney joined
[07:16] *** nacho left
[07:22] *** [particle]1 joined
[07:23] <szabgab> rakudo: class Z { has $.x is rw; }; my $t = Z.new; $t->x(10)

[07:23] <p6eval> rakudo 0310a3: OUTPUT«Statement not terminated properly at line 1, near "->x(10)"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[07:23] <szabgab> rakudo: class Z { has $.x is rw; }; my $t = Z.new; $t.x(10)

[07:23] <szabgab> sorry

[07:23] <p6eval> rakudo 0310a3: OUTPUT«too many arguments passed (3) - 1 params expected␤current instr.: 'parrot;Z;x' pc 177 (EVAL_20:67)␤»

[07:23] <szabgab> is rw accessor generation not implemented yet ?

[07:24] <szabgab> or am I using it incorrectly ?

[07:24] <literal> rakudo: class Z { has $.x is rw; }; my $t = Z.new; $t.x = 10;

[07:24] <p6eval> rakudo 0310a3:  ( no output )

[07:25] <szabgab> ah, thanks

[07:25] <literal> don't know if that's correct, actually, was just trying it

[07:26] <literal> seems to be, judging from S12

[07:26] <szabgab> it gest the assignment

[07:26] <szabgab> where do you see it in S12?

[07:26] <literal> http://perlcabal.org/syn/S12.html#Attributes

[07:27] <literal> the second test file there has a "$foo.bar = ..." test

[07:28] <szabgab> oh I have forgotten to look at the test files, just looked at the spec 

[07:28] *** Southen left
[07:29] *** nihiliad left
[07:34] *** [particle]2 left
[07:35] *** DemoFreak joined
[07:36] *** ejs joined
[07:42] *** [particle]1 left
[07:42] *** [particle]1 joined
[07:47] *** [particle]2 joined
[07:48] *** masak joined
[07:48] <masak> morning, parrotcamels.

[07:49] <moritz_> oh hai

[07:52] * masak is looking at the GSoC proposals

[07:53] <literal> how many are Perl 6-related?

[07:53] <masak> nice list of proposals.

[07:53] <moritz_> indeed

[07:53] <masak> literal: at least three that I can see right away.

[07:54] <moritz_> literal: four, in the broader sense

[07:54] <moritz_> one is actually parrot

[07:54] <moritz_> one is yours

[07:54] <moritz_> one is a november-wiki

[07:54] <moritz_> and one is smop

[07:54] <literal> ok

[07:54] <masak> right.

[07:54] <masak> didn't include the parrot one in my count.

[07:55] <moritz_> I find that particularly interesting

[07:55] <moritz_> use llvm's JIT in parrot

[07:56] <pugs_svn> r26093 | masak++ | [u4x/README] s/psi/grok/g

[07:56] <pugs_svn> r26093 | masak++ | 

[07:56] <pugs_svn> r26093 | masak++ | Turns out there's already a famous tool named 'psi' out there. On #perl6, we

[07:56] <pugs_svn> r26093 | masak++ | settled on 'grok' instead.

[07:56] *** [particle]2 left
[07:57] <moritz_> I had a different idea, but maybe that's too late now

[07:57] <literal> idea for what? a name?

[07:57] <moritz_> I thought 6d might be a good name

[07:57] <masak> it's certainly suggestive.

[07:57] <moritz_> it stands for Perl 6 docs, but also for the number of dimensions in which the language tries to be orthogonal ;-)

[07:58] <masak> 哈哈

[07:58] <moritz_> and when somebody wants to port it to Perl 5, there's an obvious name for it

[07:58] *** iblechbot joined
[07:58] <masak> moritz_: it's not too late to change. if enough people '+1' the name '6d', we'll simply change it.

[07:59] <masak> JIT decisions are the hallmark of the Perl 6 community.

[07:59] *** samdc joined
[07:59] <literal> I like it, but I somehow find it off-putting because it starts with a digit (not a valid identifier!) :)

[07:59] <masak> I had the same thought.

[08:00] <moritz_> literal: I think if you implement it, it's your decsion in the end

[08:00] <masak> don't know how bad that is, though.

[08:00] <moritz_> that's a strength, because nobody else uses such names ;-)

[08:00] <moritz_> for class names you'd have to spell it SixD or so

[08:01] <masak> moritz_: well, there is some game which starts with a digit that always turns up first on the MacPorts module list...

[08:01] <moritz_> ;-)

[08:01] <masak> ah, 2Pong and 4th.

[08:01] <moritz_> anyway, it's just an idea... feel free to pick it up or discard it

[08:02] <masak> ditto.

[08:02] <moritz_> I like grok as as well

[08:02] <masak> aye.

[08:09] <masak> today I plan to give proto and Web.pm a bit of love.

[08:10] <moritz_> nice

[08:10] <moritz_> I have to give my computer science students some love :(

[08:10] <moritz_> not as exciting as Perl 6, but it gets paid

[08:10] <masak> no details. :)

[08:10] <moritz_> (I have to prepare stuff, not work with them directly on Sunday ;-)

[08:10] <masak> ah.

[08:11] *** [particle]1 left
[08:22] *** |jedai| left
[08:23] *** samdc left
[08:25] <moritz_> rakudo passes 8436 tests. Nice.

[08:26] <masak> aye. as pmichaud noted, this is shaping up to be a productive month.

[08:36] <literal> wow

[08:38] *** [particle]1 joined
[08:38] *** ejs left
[09:04] *** DemoFreak left
[09:09] *** barney left
[09:30] *** PerL_MonK joined
[09:39] *** mikehh left
[09:44] *** pmurias joined
[09:46] <pugs_svn> r26094 | pmurias++ | [re-smop] remove accidently commited file

[09:46] *** M_o_C joined
[10:09] *** |jedai| joined
[10:11] <pugs_svn> r26095 | pmurias++ | [re-smop] ported over Scalar

[10:13] *** iblechbot left
[10:17] *** Southen joined
[10:23] <jnthn> oh hai

[10:25] <pmurias> hi

[10:31] *** PerL_MonK left
[10:40] <masak> oh hai

[10:51] *** namenlos_ left
[11:05] *** agentzh left
[11:09] *** ihrd joined
[11:09] <ihrd> hi there

[11:09] <ihrd> rakudo: for [1,2,3] Z ['a','b'] -> $a, $b { say $a, $b }

[11:09] *** agentzh joined
[11:09] <p6eval> rakudo 0310a3: OUTPUT«1a␤2b␤»

[11:10] <ihrd> this works without errors in last rakudo

[11:10] <ihrd> is it right behavior?

[11:10] <moritz_> looks good to me

[11:11] <ihrd> It is usefull for my propouse, but in previos version it is died with erorr about iteratior

[11:11] <moritz_> I think that zip should truncate to the length of the shorter list

[11:12] <ihrd> rakudo: for [1,2,3] -> $a, $b { say $a, $b }

[11:12] <p6eval> rakudo 0310a3: OUTPUT«StopIteration␤current instr.: '_block14' pc 143 (EVAL_18:59)␤»

[11:12] <ihrd> aha

[11:12] <masak> :)

[11:12] <masak> there it is :)

[11:12] <moritz_> it should throw an error, but maybe a more descriptive one ;-)

[11:12] <moritz_> unless $b is optional, of course

[11:12] <ihrd> yes

[11:13] <ihrd> I will go to read Z specs, to be sure this is right behavior

[11:13] <masak> rakudo: for 1, 2, 3 Z <a b>, undef xx 1000 -> $a, $b { say $a, $b }

[11:13] <p6eval> rakudo 0310a3: OUTPUT«1a␤2b␤3Use of uninitialized value␤␤»

[11:13] <moritz_> either S32/containers, or S03

[11:15] <moritz_> the zip() form should do the same as infix:<Z>

[11:15] <moritz_> the rational behind it is that 1..* Z @array should work

[11:18] <ihrd> you`r right

[11:18] <ihrd> "By default the C<zip> function reads to the end of the shortest list,

[11:18] <ihrd> but a short list may always be extended arbitrarily by putting C<*>

[11:18] <ihrd> after the final value, which replicates the final value as many times

[11:18] <ihrd> as necessary."

[11:18] <masak> nice.

[11:18] <masak> bet it's not implemented yet, though.

[11:18] <ihrd> ups. this special <*> behavoir NIY

[11:19] <ihrd> and it is change my dispatcher logic when it is implemented :(

[11:20] <masak> one word: workaround.

[11:20] <masak> and leave a RAKUDO comment. :)

[11:22] <ihrd> and I will send rakudobug with hope some one implemented this soon

[11:23] *** xinming left
[11:23] *** xinming joined
[11:25] *** barney joined
[11:27] *** [particle]2 joined
[11:27] *** [particle]2 left
[11:28] *** [particle]2 joined
[11:29] <szabgab> rakudo: class A { method f() {say "A"}}; class B is A {method f() {say "B"; self.f()}}; my $x=A.new; $x.f;

[11:29] <p6eval> rakudo 0310a3: OUTPUT«A␤»

[11:29] <szabgab> how can I call the same method in SUPER ?

[11:30] <szabgab> I thought WALK should do that but AFAIK it is not yet implemented

[11:30] <szabgab> any other way ?

[11:30] <masak> szabgab: yes.

[11:30] <masak> I saw it the other day.

[11:30] <masak> don't remember exactly, but ruoso did it.

[11:36] <masak> szabgab: found it. http://irclog.perlgeek.de/perl6/2009-04-02#i_1033479

[11:37] <szabgab> thanks

[11:37] <masak> np.

[11:37] <masak> I need to memorize that one too. :) it's useful.

[11:38] <szabgab> rakudo: class A { submethod f() {say "A"}}; class B is A {submethod f() {say "B"; self.f()}}; my $x=A.new; $x.f;

[11:38] <p6eval> rakudo 0310a3: OUTPUT«A␤»

[11:38] <szabgab> rakudo: class A { submethod f() {say "A"}}; class B is A {submethod f() {say "B"; self.f()}}; my $x=B.new; $x.f;

[11:38] <masak> infinite loop.

[11:38] <masak> forgot to warn you about that.

[11:38] <masak> that's actually the expected behaviour.

[11:38] <szabgab> oh , infinite loops I can write alone :-)

[11:38] <masak> indeed.

[11:39] <masak> and this one will probably blow the stack, too.

[11:39] <szabgab> rakudo: class A { submethod f() {say "A"}}; class B is A {submethod f() {say "B"; self.f()}}; A.HOW;

[11:40] <szabgab> oh,  killed it :-)

[11:40] <szabgab> I'll stand in the corner now for a while, sorry

[11:40] <masak> it'll probably be back.

[11:40] <masak> it's just a bit busy at the moment.

[11:40] <moritz_> why should that loop?

[11:41] <moritz_> rakudo: say 2

[11:41] <masak> moritz_: B.f calling itself?

[11:41] <moritz_> ah, right

[11:41] *** p6eval left
[11:41] *** p6eval joined
[11:42] *** [particle]1 left
[11:42] <moritz_> on my machine such a thing says "maximum recursion depth exceeded" after a few moments

[11:42] <moritz_> less than a second, actually

[11:42] <moritz_> rakudo: say "alive"

[11:42] <p6eval> rakudo 0310a3: OUTPUT«alive␤»

[11:42] <masak> \o/

[11:43] *** c9s_ left
[11:44] <szabgab> oh I am glad it is back

[11:44] <pugs_svn> r26096 | moritz++ | [evalbot] saner CPU limit; remove kp6

[11:45] <moritz_> rakudo: sub f { f() }; f()

[11:45] <szabgab> but I still don't see how can I call the parent

[11:45] <p6eval> rakudo 0310a3: OUTPUT«maximum recursion depth exceeded␤current instr.: 'parrot;Signature;params' pc 3355 (src/classes/Signature.pir:179)␤»

[11:45] <moritz_> setrlimit++

[11:46] <moritz_> submethods aren't designed to be callable from the child

[11:46] <masak> oh, I totally missed that they were submethods!

[11:46] <szabgab> I tried it with regulare method and that did not work either

[11:46] <masak> szabgab: what moritz_ said.

[11:47] <masak> submethods have 'self', like methods, but are invisible from the outside, like nonexported subs.

[11:47] <szabgab> rakudo: class A { method f() {say "A"}}; class B is A {method f() {say "B"; }}; my $x=B.new; $x.f;

[11:47] <p6eval> rakudo 0310a3: OUTPUT«B␤»

[11:47] <moritz_> rakudo: class A { method m { say "A" } }; class B is A { method m { say "B"; self.SUPER::m() } }; B.new.m

[11:47] <p6eval> rakudo 0310a3: OUTPUT«B␤Could not locate a method 'SUPER::m' to invoke on class 'B'.␤current instr.: 'die' pc 15853 (src/builtins/control.pir:204)␤»

[11:47] <szabgab> but if I add self.f() it will recurse again

[11:48] <masak> I'm afraid ruoso's trick is the only one that works right now.

[11:48] <moritz_> do we have a TODO ticket?

[11:48] <szabgab> I think the keyword is WALK here

[11:48] <masak> moritz_: dunno.

[11:48] *** barney left
[11:49] <szabgab> I don't see that in the linked IRC log

[11:49] <jnthn> I guess eventually we should have $x.SUPER::foo or similar working.

[11:50] <masak> szabgab: I mean the exact line I linked to.

[11:50] *** [particle]1 joined
[11:50] <szabgab> rakudo: class A { submethod foo { say 1 } }; class B is A { submethod foo { say 2 } }; my $b = B.new; A.HOW.dispatch($b,'foo');

[11:50] <p6eval> rakudo 0310a3: OUTPUT«1␤»

[11:50] <masak> aye, that one.

[11:51] <masak> that's a bit magical.

[11:51] <szabgab> rakudo: class A { submethod foo { say 1 } }; class B is A { submethod foo { say 2 } }; my $b = B.new; foo();

[11:51] <p6eval> rakudo 0310a3: OUTPUT«Could not find non-existent sub foo␤current instr.: '_block14' pc 82 (EVAL_20:43)␤»

[11:51] <szabgab> rakudo: class A { submethod foo { say 1 } }; class B is A { submethod foo { say 2 } }; my $b = B.new; $b.foo();

[11:51] <p6eval> rakudo 0310a3: OUTPUT«2␤»

[11:51] <masak> both the fact that you can call A's foo on a B object, and the fact that you can see submethods for the outside. :)

[11:51] <szabgab> rakudo: class A { submethod foo { say 1 } }; class B is A { submethod foo { say 2; A.HOW.dispatch(self,'foo') } }; my $b = B.new; $b.foo();

[11:51] <p6eval> rakudo 0310a3: OUTPUT«2␤1␤»

[11:51] <jnthn> Being able to call submethods is fine.

[11:52] <jnthn> AFAIUTS.

[11:52] <moritz_> shouldn't dispatch be a method in the meta class?

[11:52] <moritz_> ie $obj.^dispatch?

[11:52] <jnthn> It just won't look at any in a parent class.

[11:52] <szabgab> how can I get the name of the current method and the current class within the method ?

[11:52] <jnthn> $obj.^dispatch(...) is just sugar for $obj.HOW.dispatch($obj, ...)

[11:53] <szabgab> rakudo: class A { submethod foo { say 1 } }; class B is A { submethod foo { say self.WHAT; say 2; A.HOW.dispatch(self,'foo') } }; my $b = B.new; $b.foo();

[11:53] <p6eval> rakudo 0310a3: OUTPUT«B␤2␤1␤»

[11:53] <moritz_> jnthn: ah, right

[11:53] <masak> moritz_: wouldn't $obj.^dispatch be the same as $obj.HOW.dispatch ?

[11:53] <masak> oh, you already said that. :P

[11:53] <szabgab> rakudo: class A { submethod foo { say 1 } }; class B is A { submethod foo { say self.ISA; say 2; A.HOW.dispatch(self,'foo') } }; my $b = B.new; $b.foo();

[11:53] *** [particle]2 left
[11:53] <p6eval> rakudo 0310a3: OUTPUT«Could not locate a method 'ISA' to invoke on class 'B'.␤current instr.: 'die' pc 15853 (src/builtins/control.pir:204)␤»

[11:53] <jnthn> masak: It's not the same, because note where it also sticks $obj

[11:53] <masak> oh, right.

[11:53] <masak> I remember now.

[11:54] * jnthn has managed to injure his knee and can't go for a nice walk. :-(

[11:54] <jnthn> On the up side, I might get some code and (ooh, shock) my NPW slides done...

[11:55] <masak> I've started procrastinating my slides early this time.

[11:55] <szabgab> rakudo: class A { submethod foo { say 1 } }; class B is A { submethod foo { say 2; A.HOW.dispatch(self,'foo') } }; my $b = B.new; $b.foo();

[11:55] <p6eval> rakudo 0310a3: OUTPUT«2␤1␤»

[11:55] <szabgab> rakudo: class A { method foo { say 1 } }; class B is A { method foo { say 2; A.HOW.dispatch(self,'foo') } }; my $b = B.new; $b.foo();

[11:55] <p6eval> rakudo 0310a3: OUTPUT«2␤1␤»

[11:55] <masak> szabgab: there you go.

[11:56] <szabgab> so this works on methods as well

[11:56] <masak> aye.

[11:56] * jnthn also has his email pile to deal with

[12:02] *** Southen left
[12:05] <eiro> http://pastebin.com/m9ca91b2

[12:05] <buubot> eiro: The paste m9ca91b2 has been copied to http://erxz.com/pb/16830

[12:06] <eiro> il compiles, but when i run perl6, it eat all my cpu and doesnothing :(

[12:06] *** meteorjay left
[12:06] <eiro> so i wonder to myself: how to debug now ? 

[12:06] *** iblechbot joined
[12:06] <eiro> read the pir ?

[12:09] <masak> eiro: if I were you, I would start with the smallest possible grammar, and make it do the right thing.

[12:09] <masak> then build it up piece by piece.

[12:09] <moritz_> that's good advice; grammars are hard to get right with top down approach

[12:10] <eiro> masak, that was what i expected : a good stragetgy 

[12:10] <eiro> strategy! thanks 

[12:10] <masak> good luck!

[12:10] <moritz_> the best stragey is to use split() ;-)

[12:10] <eiro> thanks

[12:11] <eiro> moritz_, :-))

[12:11] <moritz_> eiro: but if you want to use grammars... beware that rule { ... } implies whitespaces

[12:11] <moritz_> eiro: if you don't want that, use a token (non-backtracking) or a regex (backtracking)

[12:12] <moritz_> [^:]+ doesn't do what you think

[12:12] <moritz_> <-[:]> would be a negated character class

[12:12] <moritz_> matchiing everything but :

[12:12] <moritz_> rakudo: say ?("abc" ~~ m/^<-[:]>*$/)

[12:12] <p6eval> rakudo 0310a3: OUTPUT«1␤»

[12:12] <moritz_> rakudo: say ?("a:bc" ~~ m/^<-[:]>*$/)

[12:12] <p6eval> rakudo 0310a3: OUTPUT«0␤»

[12:13] <moritz_> [...] are non-capturing groups, ^ is an anchor (start of string)

[12:13] <moritz_> and : is a non-backtracking assertion

[12:13] <moritz_> so [^:] is something very obscure ;-)

[12:14] <masak> no, it's just a non-capturing group with a start-of-line and a colon in it.

[12:14] <masak> nothing obscure about it. :)

[12:14] <masak> sorry, start-of-string.

[12:15] <moritz_> so what is the meaning of a colon after an assertion?

[12:15] <moritz_> it's redundant, I think

[12:15] <masak> oh, right. it needs to be quoted to be a literal colon.

[12:17] <masak> maybe it should even be an error in its unquoted form?

[12:17] * masak senses a rakudobug...

[12:17] <moritz_> no, because : has a meaning

[12:17] <moritz_> 14:13 <@moritz_> and : is a non-backtracking assertion

[12:17] <moritz_> "assertion" is probably the wrong word

[12:18] <masak> hm. right.

[12:18] <masak> rakudo: say "foo" ~~ /[^:]/

[12:18] <p6eval> rakudo 0310a3: OUTPUT«␤»

[12:18] <masak> how come that one doesn't match?

[12:18] <moritz_> it does match

[12:19] <masak> oh.

[12:19] <moritz_> but captures a zero-length string

[12:19] <moritz_> rakudo: say ?("foo" ~~ /[^:]/)

[12:19] <p6eval> rakudo 0310a3: OUTPUT«1␤»

[12:19] <masak> my bug hunting senses are thrown off today.

[12:20] <eiro> oh ... ok!

[12:20] <eiro> i'll try to fix 

[12:23] <pmurias> ruoso: how should it i specify in a %method signature that a given param is pre-FETCH'ed?

[12:30] <ruoso> hi pmurias 

[12:30] <ruoso> pmurias, that's what it usually is

[12:30] <ruoso> :($foo) means it is fetched

[12:31] <pmurias> ruoso: hi

[12:32] <ruoso> :($foo is ref) means otherwise

[12:32] <ruoso> I'm still unsure about wich is the difference between is ref and is rw

[12:33] <pmurias> i'm not sure how converting to a lvalue would look like

[12:33] <moritz_> sub f($x is rw) { $x = 3 }; sub g($x is ref) { $x = 3 }; f(@a[0]) # no autoviv g(@a[0]) # autovivication

[12:34] <moritz_> (I think so, not 100% sure though)

[12:34] <ruoso> yes... is rw tries to turn it into a lvalue

[12:34] <ruoso> is ref doesn't

[12:35] <ruoso> pmurias, I think "is rw" will work with a bare value

[12:35] <ruoso> rakudo: sub f($x is rw) {say $x}; f(3);

[12:35] <p6eval> rakudo 0310a3: OUTPUT«3␤»

[12:36] <ruoso> rakudo: sub f($x is rw) {say $x++}; f(3);

[12:36] <p6eval> rakudo 0310a3: OUTPUT«3␤»

[12:36] *** davidad left
[12:36] <ruoso> rakudo: sub f($x is ref) {say $x++}; f(3);

[12:36] <p6eval> rakudo 0310a3: OUTPUT«Cannot assign to readonly variable.␤current instr.: 'die' pc 15853 (src/builtins/control.pir:204)␤»

[12:37] <ruoso> which means that it actually needs a way to figure out if it's enclosed in a container or not...

[12:37] <ruoso> in the "is rw" case, that is

[12:37] <eiro> it doesn't match but it ends correctly .. that's my step of the day... thanks all, go with my children

[12:38] *** meppl joined
[12:39] <ruoso> pmurias, but I guess that for the purposes of the RI DSL, we can have only bare "$x" and "$x is ref"

[12:39] <pmurias> ruoso: maybe a CONTAINER method could work, which would wrap the object in a container if nessesary

[12:41] <pmurias> maybe LVALUE would be a better name

[12:41] <ruoso> but how to detect if ther is a container already?

[12:41] <ruoso> moritz_, are you aware how rakudo does it?

[12:41] <pmurias> a container knows if it's a container and would return itself, values would wrap themself up in a Scalar

[12:42] <ruoso> ah...

[12:42] <ruoso> I see what you mean

[12:42] <ruoso> hmm...

[12:42] *** xinming left
[12:42] <moritz_> ruoso: I don't think rakudo does it all (ie the ref/rw distinction)

[12:43] <ruoso> moritz_, it does... see p6eval above 

[12:43] <ruoso> pmurias, well... maybe it is an interesting way of doing it

[12:44] <ruoso> and it also allows the object to decide which type of container it wants

[12:46] <ruoso> pmurias, yes... I'm convinced... that can be done that way...

[12:46] * pmurias is looking how rakudo does it

[12:47] * ruoso later &

[12:55] *** payload left
[12:58] <jnthn> I don't *think* Rakudo knows much about is ref just yet

[12:58] <jnthn> is rw we should be getting right

[12:58] <jnthn> I guess maybe we'll have to so some check that we have a container passed in...

[12:58] <jnthn> Maybe something to check during the sig binding or something.

[13:01] <ruoso> jnthn, but how do you figure out it is a container?

[13:02] <jnthn> I guess look at the type of thingy it is.

[13:03] <jnthn> Not sure if there's a standard way of something saying "btw I'm a container"

[13:03] <jnthn> Probably needs to be if one isn't spec'd.

[13:03] <pmurias> ruoso: the LVALUE method would be sort of an lvalue context

[13:03] <ruoso> I don't think it is spec'd

[13:03] <ruoso> yes

[13:04] <ruoso> that's why I think it fits in the model

[13:04] *** Southen joined
[13:10] <jnthn> hmmm

[13:10] <jnthn> .can('STORE') ?

[13:14] *** c9s_ joined
[13:18] *** Southen left
[13:20] *** nihiliad joined
[13:21] <pmurias> jnthn: everything can STORE in smop

[13:21] <jnthn> 3.can(STORE)?

[13:22] <pmurias> but some things die during STORE with an immutable error message

[13:23] <jnthn> Ah. That approach won't work for smop then.

[13:23] <jnthn> It may cut it for Rakudo, though I don't think we're exposing STORE much just yet...

[13:25] *** Kisu left
[13:25] *** Kisu joined
[13:27] *** Southen joined
[13:33] <masak> oh no, that won't do. that won't do at all.

[13:34] <jnthn> masak: Huh?

[13:34] <masak> mberends++ does cool things in the create-new-project script, but it also introduces increased coupling between projects and proto.

[13:35] <masak> specifically, that script creates a Configure.p6 which defers to a module included in proto.

[13:36] <masak> making proto a necessary (and undeclared) dependency -- kind of the antithesis of what proto should be.

[13:36] <jnthn> Ah.

[13:36] <masak> but I realise it's a tricky problem.

[13:37] <masak> it's better to do it a little wrong in the beginning. :)

[13:37] *** DemoFreak joined
[13:37] <masak> at least if the alternative is spending an eternity in an ivory tower.

[13:37] <jnthn> "Works but needs improvements" is probably better than "doesn't exist" :-)

[13:37] <masak> exactly.

[13:37] <jnthn> Plus getting stuff spot on first time is, well, hard.

[13:38] <masak> it's more than hard. it's a superpower.

[13:38] <masak> I'll add an XXX comment and move on for now.

[13:41] *** Khisanth joined
[13:42] *** araujo joined
[13:43] <jnthn> .oO( sometimes it's easy to mistake a couple of lines of IRC for spam subjects )

[13:49] <masak> 哈哈

[13:49] *** DJ-DONGDOT joined
[13:51] <masak> jnthn: and I haven't even told you about the cheap meds and university diplomas yet. :)

[13:53] <masak> someone should do memetic studies on the different Perl 6 projects on github. ideas are forming and "borrowed" into other projects. not just source code, but also the config and make files.

[13:53] *** xinming joined
[13:54] <jnthn> Hopefully the good ideas are the ones being borrowed. :-)

[13:54] <masak> time will tell, but yes, that's the idea.

[13:58] <masak> they are "good" in the sense that the author has a goal, and deserts her own solution for one from another project that she feels has greater fitness.

[13:58] <masak> it's author-driven evolution.

[14:03] * jnthn glares at the bruise on his hand that is making typing marginally more painful today

[14:04] <jnthn> Turns out not noticing a step, tripping and falling over isn't a great idea...

[14:04] <masak> ouch. be careful, we need you.

[14:04] *** payload joined
[14:05] <masak> g'ah! foiled again by the Makefile format's insane whitespace policies!

[14:06] <jnthn> There is a slightly amusing irony in that after managing all through the icy winter - where there were amples chances to slip - that I managed not to, and instead did so on pretty much the first day of the year where we had t-shirt weather.

[14:06] <jnthn> Oh? You put spaces instead of tabs?

[14:06] <jnthn> Guess what? My make program doesn't complain about that. :-|

[14:07] <masak> good for you. :P

[14:08] <masak> mine just fails mysteriously.

[14:08] <jnthn> It's only good until I push my changes. ;-)

[14:08] *** jan_ left
[14:14] <dukeleto> mornin'

[14:15] *** xinming left
[14:17] <masak> Matt-W, mberends, moritz_: I've just adapted Druid to build under proto. The configure and make files contain all manner of subtle differences from create-new-project in proto, all of which I would like to discuss at some point.

[14:17] <masak> actually, I should probably make a list of those differences.

[14:17] * masak does that

[14:26] <masak> here: http://github.com/masak/druid/commit/9c33add1c3456689b9ee06c6c8568a819a4aeb22

[14:30] *** xinming joined
[14:32] *** |jedai| left
[14:37] *** xinming left
[14:37] *** xinming joined
[14:37] <pmichaud> good morning #perl6

[14:38] <masak> hi pm

[14:45] <s1n> good morning

[14:46] *** pmurias left
[14:50] <s1n> oo question: i want to define some class members in a derived class as early as possible. what's the best way to go about that? overload CREATE?

[14:51] <jnthn> Probably BUILD...

[14:51] <s1n> what's the difference?

[14:51] <masak> jnthn: but they were class members...

[14:51] <jnthn> oh

[14:51] <jnthn> class members

[14:51] <jnthn> Just assign to them?

[14:51] <s1n> yeah, i did a has $.blah

[14:51] <s1n> jnthn: where?

[14:51] <jnthn> Oh, those aren't class members, they're instance members.

[14:51] <masak> I'd also guess just assign to them. top of the class def.

[14:52] <jnthn> has $.answer = 42;

[14:52] <s1n> perl6 has class level members as well?

[14:52] <jnthn> my $.answer = 42;

[14:52] <jnthn> Well, really they're lexicals but write a . and the compiler throws in a bonus accessor method. ;-)

[14:52] <s1n> i.e. with java, tacking 'static' defines the member on the instance of the class versus the instance

[14:53] <masak> rakudo: class A { my $.foo = 42 }; class B is A { $.foo = 7 }

[14:53] <p6eval> rakudo 0310a3: OUTPUT«Lexical 'self' not found␤current instr.: 'parrot;B;_block30' pc 177 (EVAL_19:78)␤»

[14:53] <s1n> heh

[14:53] <masak> jnthn: should that work? :)

[14:53] <pmichaud> no.

[14:53] <pmichaud> There's no $.foo in scope.

[14:53] <masak> right. makes sense.

[14:53] <masak> the error is a bit strange, though.

[14:54] <s1n> rakudo: class A { has $.foo = 42 }; class B is A { my $.foo = 7 }; say $B.foo

[14:54] <p6eval> rakudo 0310a3: OUTPUT«Scope not found for PAST::Var '$B' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[14:54] <masak> maybe simply disallow $.foo-like vars outside of methods-level blocks?

[14:54] <s1n> err i can never get that last accessor right, what did i do wrong there?

[14:54] <masak> s1n: B.foo

[14:54] <s1n> should i have used :: instead of .?

[14:55] <jnthn> Hmm. Wasn't there some speculation that we'd make self be the proto-object inside the class body at some point...

[14:55] <s1n> rakudo: class A { has $.foo = 42 }; class B is A { my $.foo = 7 }; say B.foo

[14:55] <masak> jnthn: I think so. it might even have been I who suggested it.

[14:55] <pmichaud> jnthn: perhaps, but since the proto doesn't really exist yet...

[14:55] <p6eval> rakudo 0310a3: OUTPUT«7␤»

[14:55] <pmichaud> (in rakudo, at least)

[14:55] <s1n> pmichaud: is that the proper way?

[14:55] <jnthn> pmichaud: Ah, yes, that is a slight issue. ;-)

[14:55] <masak> don't remember when. oh yes, it was because one might want to do 'my $.foo = $.bar + 2'

[14:56] <jnthn> Oh, I think that has a different solution.

[14:56] <jnthn> (the RHS is a closure with self defined)

[14:56] <pmichaud> s1n: it's proper depending on what you want to do

[14:56] <masak> jnthn: ah.

[14:56] <pmichaud> jnthn: note 'my'

[14:56] <pmichaud> no closure with 'my'

[14:56] <pmichaud> just with 'has'

[14:56] <masak> :)

[14:56] <s1n> pmichaud: set the inherited members as early as possible

[14:56] <jnthn> Oh, yes.

[14:57] <pmichaud> s1n: what you wrote above creates a new member, not set the member of A

[14:57] *** jan_ joined
[14:57] <jnthn> Aye. I think Rakudo is giving the correct answer there.

[14:57] <s1n> pmichaud: okay, how do i do what i want? in a CREATE?

[14:58] <pmichaud> I suspect override method new.

[14:58] *** brunoV joined
[14:58] <pmichaud> (note that I know how to do that part yet either.)

[14:59] <pmichaud> s/note/not/

[14:59] <s1n> so we have BUILD, CREATE, and new methods that all are involved in a class defining what to do during construction?

[14:59] <pmichaud> CREATE does the creation of the object

[14:59] <pmichaud> BUILD says how to initialize the object for a given class

[14:59] <pmichaud> new indicates how to build an object when requested by a client

[15:00] <pmichaud> i.e., new calls (through some layers) CREATE and BUILD

[15:00] <s1n> new and BUILD sound very similar

[15:00] <pmichaud> BUILD only does it for a single class

[15:00] <pmichaud> not for the entire hierarchy

[15:00] <s1n> i don't follow

[15:00] <pmichaud> if I have class A   and class B is A,   then B's BUILD submethod would identify how to initialize the members of B.  It would not indicate how to initialize the members of A.

[15:01] <s1n> that's kinda goofy, why would that be a feature of the language?

[15:01] <s1n> why not simplify it down to just the new?

[15:02] <s1n> when i inherit a class, i generally want to initialize the whole mess...

[15:02] <masak> s1n: new and BUILD fill different niches.

[15:02] <masak> s1n: you override the one you need to.

[15:02] <s1n> masak: yeah i get that but generally, i'll just overload new and do whatever i want

[15:03] <masak> s1n: no, overloading new is only for those times when overloading BUILD isn't enough.

[15:03] <masak> ...if I understood it correctly.

[15:03] <pmichaud> by having a separate BUILD and new, a class can indicate how it should be initialized without having to worry about calling the .new's of its parent classes.

[15:03] <s1n> masak: yes, but it just seems easier to _always_ overload new and use it as i see fit

[15:03] <masak> s1n: it isn't.

[15:04] <pmichaud> indeed, calling the .new's of its parent classes would be wrong, because those would create new objects instead of initializing the existing instance

[15:04] <s1n> pmichaud: do you have to call the .new of the entire hierarchy?

[15:04] <masak> BUILD does a subpart of what new does.

[15:04] <pmichaud> s1n:  the default .new calls all of the BUILDs for you

[15:04] <s1n> can i call the default .new?

[15:04] <s1n> i.e. like java's super()?

[15:05] <s1n> or in c++

[15:05] <pmichaud> you probably don't want to call super.new, though, because that would create new objects.  Not initialize the existing one.

[15:06] *** Psyche^ joined
[15:06] <s1n> oh i was thinking wrong

[15:06] <s1n> i mean, can i call the default .new for my class? that will basically call all the BUILD methods and then i can do what i need?

[15:06] <s1n> so if i overload .new, is the original still available?

[15:07] <pmichaud> yes, probably as   Object.new or Object::new or something like that.  I'm not certain of the syntax.

[15:07] <pmichaud> tbh, I haven't really thought much about how this stuff gets used -- I've just implemented whatever the spec says :-)

[15:08] <pmichaud> afk for a bit

[15:08] *** ihrd left
[15:08] <s1n> basically, i'm trying to see if i can work around having to think about new versus BUILD

[15:08] * jnthn recommends going to the pub instead ;-)

[15:09] <masak> proto now tries to clone a private repo before it tries the public one.

[15:09] <jnthn> s1n: Generally, new is probably what you want to change to control the external interface of how an object instantiation looks.

[15:10] <jnthn> As in, what does creating an object of that type look like. What values should be initailizable? With named or with psotional params? All those things.

[15:10] <masak> now there's nothing stopping me from dogfooding proto for all my projects.

[15:10] <jnthn> Whereas if you just want to do setting defaults but it's more complex than you can do on the has $.x = ... line, BUILD is probably the place.

[15:11] <s1n> hmmm this is interesting, i don't really recall anything similar to other languages

[15:11] <s1n> i.e. in java/c++, you just overload your constructor to change it's external interface

[15:12] <s1n> whereas perl6 made 2 methods: one to just init itself, and a set to define the constructors

[15:12] *** dKingston joined
[15:12] <jnthn> s1n: Aye, it's different.

[15:13] <s1n> out of curiousity, why was this adopted? i can't really do much with a proto after BUILD anyways, right?

[15:15] <jnthn> Might be partly to do with the separation of representation and metaclass stuff.

[15:16] <jnthn> p6l is perhaps more the place to ask though, for a language design perspective.

[15:16] <masak> yes, it must have to do with Perl 6 being OO methodology agnostic.

[15:17] <s1n> i'm just curious, i'm still having trouble grasping perl6's OO model (or lack thereof)

[15:17] <masak> it has less of a lack thereof than Perl 5. :)

[15:17] <s1n> which doesn't say much :)

[15:17] <masak> indeed.

[15:19] *** Patterner left
[15:19] *** Psyche^ is now known as Patterner

[15:22] <s1n> rakudo: class Foo { has $.yay }; class Bar is Foo { method BUILD { self.yay = "yay"; }}; my Bar $y .= new; say $y.yay

[15:23] <p6eval> rakudo 0310a3: OUTPUT«too many arguments passed (3) - 1 params expected␤current instr.: 'parrot;Bar;BUILD' pc 242 (EVAL_20:94)␤»

[15:23] <s1n> what am i doing wrong there?

[15:23] <s1n> $y.yay isn't calling the autogenerated method?

[15:24] <masak> s1n: for one, you didn't declare $.yay as rw.

[15:24] <masak> but also, I don't know if 'self.yay = ...' works.

[15:24] <masak> I'd have written '$!yay = ...'

[15:25] <s1n> rakudo: class Foo { has $.yay }; class Bar is Foo { method BUILD { self.yay = "yay"; }}; my Bar $y .= new;

[15:25] <p6eval> rakudo 0310a3: OUTPUT«too many arguments passed (3) - 1 params expected␤current instr.: 'parrot;Bar;BUILD' pc 216 (EVAL_20:91)␤»

[15:25] <masak> s1n: ah. the problem is in the parameters to BUILD.

[15:25] <masak> you're not supplying any.

[15:26] * s1n checks the spec again

[15:26] <masak> Rakudo doesn't implement the spec right now, I'm afraid.

[15:26] <masak> there's an RT ticket about it.

[15:26] <masak> but supply two parameters and you'll be fine.

[15:27] <s1n> two? what are they?

[15:29] <masak> prototype and new object, I think.

[15:29] <masak> let's see if I can dig up the discussion about this from a few days ago.

[15:31] <masak> ah. one object.

[15:31] <masak> http://irclog.perlgeek.de/perl6/2009-04-02#i_1033380

[15:31] <masak> one parameter. the other one is the invocant.

[15:31] <s1n> does it have to be defined as a submethod?

[15:31] <masak> that's the idea, at least.

[15:31] <masak> I don't think it has to, though.

[15:32] <masak> not sure.

[15:33] <s1n> rakudo: class A { has $.foo is rw; submethod BUILD($obj) { $obj.foo = 7 } }; A.new

[15:33] <p6eval> rakudo 0310a3: OUTPUT«Null PMC access in getprop()␤current instr.: 'infix:=' pc 14068 (src/builtins/assign.pir:21)␤»

[15:33] <s1n> what does that error mean?

[15:33] <masak> that things have gotten worse since Friday. :)

[15:34] *** plash joined
[15:34] <masak> sorry, Thursday.

[15:34] *** amoc joined
[15:34] *** DJ-DONGDOT left
[15:35] <masak> s1n: that error, and related ones, made me use 'new' for the time being, instead of 'BUILD'.

[15:36] <masak> http://rt.perl.org/rt3/Ticket/Display.html?id=64386

[15:40] <pmichaud> yes, BUILD needs to be a submethod.

[15:40] <pmichaud> Otherwise it gets inherited.

[15:41] <masak> but is it a convention, or is it enforced?

[15:41] <pmichaud> well, things can break if you do it as a method.

[15:41] <pmichaud> for example:

[15:41] <masak> so, it's a convention.

[15:41] <s1n> if it's required, shouldn't it be a runtime error?

[15:41] <pmichaud>     class A { method BUILD { ... } };   class B is A { ... };     #  oops!

[15:41] <s1n> or even a compile error

[15:42] <pmichaud> B ends up inheriting A's build.

[15:42] <pmichaud> instead of inheriting Object's BUILD, which is what B will need in order to instantiate its attributes.

[15:42] *** |jedai| joined
[15:42] <masak> pmichaud: aye.

[15:43] <jnthn> Don't forget that bless fits into this picture somewhere too.

[15:44] <pmichaud> and yes, Rakudo needs to be updated to follow the (corrected) spec.  The version of BUILD that I wrote (the one Rakudo currently has) was taken from the sm0p guidelines.

[15:44] <pmichaud> and the spec has since evolved differently.

[15:44] <masak> aha. so that's what happened.

[15:45] <masak> well, the Druid sources are already rid of their init() method workarounds.

[15:45] <masak> they are using new() right now, and will move over to BUILD as soon as that's possible.

[15:45] *** |jedai| is now known as jedai

[15:45] <jnthn> Maybe something to review on my Rakudo day next week.

[15:45] <jnthn> Or Oslo. ;-)

[15:46] *** PhatEddy joined
[15:46] * masak really looks forward to NPW

[15:46] <pmichaud> same here.

[15:46] <jnthn> Me too!

[15:46] <pmichaud> I'm glad I have lots of days there.

[15:46] <jnthn> Yeah, same.

[15:47] <jnthn> Glad hackathon is 3 days not 2.

[15:47] <pmichaud> glad I went ahead and extended my trip for the 3-day hackathon instead of just 2.

[15:47] <jnthn> Yes. :-)

[15:48] <jnthn> pmichaud: How up to date is the ROADMAP at the moment?

[15:48] <jnthn> Is it on your things to review list, or was it recently reviewed, or is it a little old but still pretty much stands?

[15:49] <pmichaud> it's on my things to review list.

[15:49] <jnthn> Updated: 2008-08-16 - suggests either the first or third of those. :-)

[15:49] <jnthn> Ok.

[15:49] <pmichaud> If not before NPW, then on the Wednesday before NPW

[15:50] <jnthn> Isn't that before NPW either way? ;-)

[15:50] <masak> jnthn: don't complain! :P

[15:51] <pmichaud> Well, I could say I'll do it in May, which is before NPW '10

[15:51] <jnthn> ;-)

[15:52] <jnthn> OK. I'm sort of pondering, what to work on next.

[15:52] <jnthn> Actually, looking through this current ROADMAP, I'm kinda taken by how much of it we've actually achieved.

[15:53] <masak> (both of you)++

[15:53] <pmichaud> jnthn: have you finished the queue of RT tickets I assigned to you?  ;-)

[15:53] *** mib_0gaypc joined
[15:54] <jnthn> pmichaud: Not all. Some are hard. :-P

[15:54] <mib_0gaypc> rakudo: say "hello"

[15:54] <p6eval> rakudo 0310a3: OUTPUT«hello␤»

[15:54] * pmichaud wonders if he should put an easter egg in rakudo so that when it's run from p6eval it goes "Look, I'm tired of saying 'hello' all the time."

[15:54] <mib_0gaypc> rakudo: (1..Inf)[*-1]

[15:54] <p6eval> rakudo 0310a3: OUTPUT«elements() not implemented in class 'Range'␤current instr.: 'postcircumfix:[ ]' pc 5020 (src/classes/Positional.pir:138)␤»

[15:54] <pmichaud> rakudo doesn't support infinite ranges yet.

[15:54] <masak> pmichaud: :D

[15:55] <jnthn> ...and when it does, getting the last element of it may not be too performant. ;-)

[15:55] <masak> rakudo: say (1..8)[*-1]

[15:55] <jnthn> Well, I guess we can hand back Inf.

[15:55] <p6eval> rakudo 0310a3: OUTPUT«elements() not implemented in class 'Range'␤current instr.: 'postcircumfix:[ ]' pc 5020 (src/classes/Positional.pir:138)␤»

[15:55] * masak submits rakudobug

[15:55] <mib_0gaypc> this is szabgab, showing off in class :-)

[15:56] <masak> hi, class!

[15:56] <jnthn> Didn't we have another ticket field on postcircumfix recently?

[15:56] * jnthn needs to be in that code in the next couple of days anyways...

[15:56] <PhatEddy> yes

[15:56] <pmichaud> Range doesn't understand Positional yet.

[15:56] <masak> jnthn: we have tickets on everything. :)

[15:57] <jnthn> Ah, yes, I guess Range will want its own implementation of Positional.

[15:57] <mib_0gaypc> rakudo: class A { method f() {say "hi"}}; my $x = A.new; $x.f

[15:57] <p6eval> rakudo 0310a3: OUTPUT«hi␤»

[15:57] <mib_0gaypc> rakudo: class A { method f() {say "hi"}}; my $x = A.new; $x.WHAT

[15:57] <p6eval> rakudo 0310a3:  ( no output )

[15:58] <jnthn> mib_0gaypc: Need .say on the end there. :-)

[15:58] <mib_0gaypc> rakudo: class A { method f() {say "hi"}}; my $x = A.new; $x.WHAT.say

[15:58] <p6eval> rakudo 0310a3: OUTPUT«A␤»

[15:58] *** aindilis left
[15:59] *** Psyche^ joined
[15:59] <PhatEddy> ticket is rt 57790 and my patch for the range case gives "Use of uninitialized value <NL>Method 'postcircumfix:[ ]' not found for invocant of class 'Range' " which seems close ...

[15:59] <PhatEddy> s/for/in/

[16:00] *** ejs joined
[16:04] *** davidad joined
[16:05] <dalek> rakudo: 078012a | pmichaud++ | docs/spectest-progress.csv:

[16:05] <dalek> rakudo: spectest-progress.csv update: 349 files, 8436 passing, 0 failing

[16:05] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/078012ab24258cc0922523ee6433138be5dc6c63

[16:07] <jnthn> 8,436...and still over two weeks of development time until the next release. :-)

[16:08] *** Southen left
[16:09] *** alester joined
[16:10] * masak idly wonders when we'll run out of tests to pass

[16:11] *** masak left
[16:11] <pmichaud> I've been working on analyzing the remainder of the test suite.

[16:12] <pmichaud> (as part of updating the roadmap)

[16:12] <jnthn> *nod*

[16:12] <pmichaud> it'll be a blog post, and part of my presentation.

[16:12] <jnthn> However, some things that should be on the roadmap we just don't have tests for.

[16:12] <pmichaud> Yes.

[16:12] * jnthn points at S09.

[16:12] *** amoc left
[16:13] <pmichaud> but when looking at the grey area of the charts, I'd like to know what we're not attempting and why.

[16:13] <jnthn> I know we could win a 3-figure number by being able to pass positionals as nameds.

[16:13] <pmichaud> for example, there's approximately ~2k tests having to do with Unicode features where we need some additional work in Parrot

[16:13] <pmichaud> (primarily character properties)

[16:14] *** frzntoz joined
[16:14] <jnthn> Is that something you'd look to delegate?

[16:14] <jnthn> Or that you expect to put in yourself?

[16:14] <pmichaud> if there's someone available to delegate it to, sure.

[16:14] <pmichaud> at the moment it's going to need some design decisions made first... probably from allison.

[16:14] <jnthn> OK.

[16:15] <jnthn> There may be people in #parrot we can rope in to helping with that.

[16:15] <pmichaud> for example:   "Given a character, how do we decide if that character has the unicode X property"

[16:15] *** Patterner left
[16:15] *** Psyche^ is now known as Patterner

[16:15] <pmichaud> where X might be any of "L", "Lu", "Ll", "M", "Z", "Latin", "Cyrillic", etc.

[16:15] <jnthn> I'm guessing the answers is "use the Parrot API for doing such things which in turn goes and asks ICU"

[16:16] <pmichaud> yes, but there's no Parrot API for such things.

[16:16] <pmichaud> at least, not yet.

[16:16] <jnthn> OK. So it's (a) design an API (b) implement it in Parrot (c) use it from Rakudo.

[16:16] <pmichaud> correct.

[16:17] <pmichaud> (b) is really easy (unless the API chooses to make it hard)

[16:17] <jnthn> Yeah, I was figuring that while I don't know enough to do (a) well, once it's done (b) is probably mostly donkey work.

[16:18] <jnthn> But I think we have a non-zero chance of getting someone other than us to do that bit too.

[16:18] <pmichaud> well, since it would ultimately be interfacing with PGE, I wouldn't mind doing that bit of work.  But the API is the blocker.

[16:19] <jnthn> Ah, OK.

[16:19] <pmichaud> i.e., it's already taken us longer to talk about it than it would likely be for me to implement it :-) 

[16:19] <jnthn> It sounds like a relatively easy-ish way to win 2,000 tests though.

[16:20] <pmichaud> it would also be good to have autoloaded methods for it as well.

[16:20] <jnthn> autoloaded methods?

[16:20] <pmichaud> well, in S05, we have   <isLu>, <isLetter>, <isM>, <isPs>, etc.

[16:20] <pmichaud> there's a _bunch_ of these.

[16:21] <pmichaud> but they're not common.  Instead of creating all of the methods for each property up front, it might be better to create them on-demand.

[16:21] <jnthn> Hmm. 

[16:21] * jnthn glances at CANDO is S1

[16:21] <jnthn> *S12

[16:22] *** justatheory joined
[16:23] <jnthn> Ah, the details are in S10.

[16:24] *** c9s_ left
[16:24] <pmichaud> anyway, I'm more curious how to do it from a Parrot level.

[16:25] <jnthn> Ah. I'm less sure about that.

[16:26] <jnthn> Override find_method is one way...

[16:26] <pmichaud> yes, although overriding find_method in PIR sounds expensive :-)

[16:26] <pmichaud> we _really_ are going to need some way to make those calls less expensive.

[16:26] <jnthn> Ah, true.

[16:27] *** c9s_ joined
[16:27] <s1n> jnthn: (reading back) if you want something to do, i'd actually like to see namespaces (package/module) working better (i had problems the other day) i'd do it myself, but i need some sort of guiding. if you want to either work that or show me how to find my way around, that'd be great:

[16:27] <jnthn> What aspects of them are you finding lacking?

[16:28] <s1n> lemme check the logs...

[16:28] <jnthn> (I know a bunch of stuff is not done, but knowing what you're running into would help me prioritise a bit...)

[16:29] <s1n> http://irclog.perlgeek.de/perl6/2009-04-02#i_1032140

[16:29] <s1n> i tried that so i resorted in working around it

[16:29] <s1n> i just renamed the class: 'class Foo::Bar {...}'

[16:30] <s1n> i tried looking at actions.pm but i don't really know NQP well enough and not really sure what of the package_declaration (iirc) is broken

[16:30] <jnthn> We are somewhat handling nested namespaces.

[16:31] <jnthn> rakudo: use v6; package Foo { class Bar { method baz { say "baz"; } }; Bar.baz; }

[16:31] <p6eval> rakudo 0310a3: OUTPUT«Null PMC access in can()␤current instr.: '!dispatch_method' pc 17110 (src/builtins/guts.pir:104)␤»

[16:31] <s1n> also, this BUILD thing, i'm having a hard time using it correctly

[16:31] <jnthn> Ugh.

[16:31] <s1n> yeah, so that's something i want to use now

[16:31] <jnthn> Aye.

[16:31] <jnthn> OK, I'll pop them on my task list.

[16:32] <s1n> i can work around it, but it's kinda kludgy

[16:32] <s1n> at the very least, maybe you could show me around and help me fix it

[16:32] <pmichaud> I think part of the issue is that we don't have a clean way to do a nested namespace search -- i.e.,  converting 'Bar' into 'Foo::Bar'

[16:32] *** justatheory left
[16:32] <s1n> best way to learn is to do, but i don't know how to do yet :)

[16:33] <jnthn> pmichaud: Yes, that's for sure part of it.

[16:34] <jnthn> I should check what *should* work too. I mean, is Foo::Bar inside a package Foo actually meant to mean the equivalent in the otuer scope of Foo::Bar or Foo::Foo::Bar.

[16:36] <jnthn> Anyway, afk for a bit.

[16:36] <pmichaud> jnthn: I've never quite understood that one either.

[16:36] *** cspencer joined
[16:36] <pmichaud> I know it came up recently.

[16:37] <pmichaud> it's one of the reasons why 'is also' was changed to 'augment'

[16:37] <s1n> i'd like to help, if anyone is willing to help me :/

[16:37] <s1n> dog_training&

[16:43] *** drbean left
[16:43] *** drbean joined
[16:44] *** mib_0gaypc left
[16:48] *** justatheory joined
[16:49] *** ab5tract joined
[16:57] *** Southen joined
[17:00] *** rabbits77 joined
[17:01] *** plash left
[17:01] *** justatheory_ joined
[17:12] *** justatheory__ joined
[17:12] *** agentzh left
[17:12] *** mberends joined
[17:16] *** justatheory left
[17:22] *** justatheory_ left
[17:23] *** jferrero joined
[17:24] *** dKingston left
[17:25] *** dKingston joined
[17:27] *** Southen left
[17:43] *** davidad left
[17:44] *** rabbits77 left
[17:47] *** eternaleye left
[18:10] *** c9s_ left
[18:15] *** Southen joined
[18:16] *** PhatEddy left
[18:18] *** davidad joined
[18:28] *** ejs left
[18:30] *** mfwitten joined
[18:37] *** eternaleye joined
[18:38] *** ejs joined
[18:42] *** mfwitten_ joined
[18:52] *** ejs1 joined
[18:55] *** rindolf joined
[18:55] *** ejs left
[18:57] *** rindolf left
[18:57] *** rindolf joined
[18:58] *** rindolf left
[18:59] *** mfwitten left
[18:59] *** payload1 joined
[19:05] *** szabgab joined
[19:05] *** rindolf joined
[19:05] <rindolf> Hi all.

[19:06] *** payload1 left
[19:06] *** payload1 joined
[19:16] *** payload left
[19:19] *** cspencer left
[19:20] *** mfwitten_ left
[19:24] *** payload1 left
[19:24] *** payload joined
[19:25] *** alester left
[19:45] *** ab5tract left
[19:46] *** justatheory__ left
[19:51] *** wolverian joined
[19:55] *** pmurias joined
[19:55] <pmurias> jnthn: not having a STORE instead of die'ing with a helpfull message might be a better choice

[20:05] <jnthn> pmurias: I guess it means you could use that as a heuristic for "is it a container"...

[20:06] <jnthn> I just didn't see things that couldn't store having a store method, but I guess we have fairly different underlying architectures.

[20:09] <ruoso> jnthn, pmurias, the thing is that for SMOP, can is considerably more expensive...

[20:09] <ruoso> so, having LVALUE as a coercion is better...

[20:10] <ruoso> and it has the benefit that is not the signature that choose the container, but the object itself

[20:10] * ruoso later &

[20:26] *** sri_kraih joined
[20:32] *** mberends left
[20:38] *** justatheory joined
[20:39] *** dKingston left
[20:40] *** ejs1 left
[20:43] *** sri_kraih_ left
[21:02] *** Helios left
[21:03] *** M_o_C left
[21:06] <pugs_svn> r26097 | pmurias++ | [re-smop] started rewritting the s1p hash, the Lexical Prelude is constructed

[21:21] *** Helios joined
[21:22] *** justatheory left
[21:34] *** rindolf left
[21:41] *** Southen left
[21:43] *** nekobaka joined
[21:46] *** daemon joined
[22:02] *** cspencer joined
[22:06] *** cognominal left
[22:09] *** daemon left
[22:10] *** daemon joined
[22:11] *** Southen joined
[22:19] *** pdc joined
[22:21] *** dKingston joined
[22:24] *** pmurias left
[22:32] *** Southen left
[22:38] *** frzntoz left
[22:40] *** Southen joined
[22:44] *** payload left
[22:56] *** FurnaceBoy joined
[23:00] *** plash joined
[23:01] <pdc> compared to Python, is it unfair to say that Perl is better suited to writing utility scripts, rather than full applications? If not, why don't I see more apps written in perl? Does Perl6 change this at all?

[23:04] <literal> Perl 6 is more "disciplined" by default, which might make it more suitable for that.

[23:05] <literal> And has a very good object model, though Perl 5 also gained a similarly good one (Moose) recently

[23:07] *** payload joined
[23:08] <pdc> I am torn between learning Perl or Python to go alongside C. Python appealed to me because it seems like it would allow me to do everything I can do in C, in half the time. Which would be really handy sometimes. But Perl 6 has some very nice features and a new version should get rid of the 'perl is dying' mentality. Python does seem more geared for full apps, though

[23:08] <literal> But I think being well-suited to write utility scripts doesn't necessarily have to negatively affect a language's usefulness in large applications

[23:09] <literal> I don't think you'd be able to do everything you can in C, in half the time, in Perl 6 right now. Maybe in a couple of years...

[23:09] <pdc> Python is very big on the desktop now (GTK+ apps, etc). Perl doesn't seem to even have a presence in the area

[23:09] <literal> Perl 5 would definitely work for that.

[23:10] <literal> Yeah, I've noticed that.

[23:10] <literal> Perl has all the stuff necessary, though. Bindings, etc.

[23:10] <moritz_> pdc: yes, perl bidings for graphic widgets have traditionally been weak... except for Tk, which looks like 1982 still

[23:11] <pdc> hehe

[23:11] <literal> The Wx and GTK+ are in good shape, as far as I know...

[23:11] <literal> +bindings

[23:11] <pdc> oh really? That's good to know

[23:12] <literal> Here's one recent Perl application in Wx, for example: http://padre.perlide.org/wiki/Screenshots

[23:12] <moritz_> literal: yes, Wx is rather hard to build

[23:13] <literal> moritz_: is that any different when using it from Python?

[23:14] <moritz_> literal: dunno

[23:14] <wolverian> the Gtk+ bindings are fine

[23:14] <pdc> and when perl 6 is released, will the majority of Perl programmers move on to 6 (as far as the community is aware)? So we can also expect CPAN to fast gain modules targetted at Perl 6, bindings, documentation, etc?

[23:14] <literal> I doubt it

[23:14] <pdc> oh!

[23:14] <literal> Perl 5 is still the most useful programming language out there, as far as I know :)

[23:15] <literal> But slowly and surely, they will probably switch, because Perl 6 is awesome.

[23:15] <moritz_> well, I do expect adaption rate to grow

[23:16] *** jferrero left
[23:16] <pdc> Perl 6 does indeed look awesome. and I think I will opt for Perl rather than Python

[23:17] *** iblechbot left
[23:17] <pdc> I presume learning Perl 5 isn't a bad precursor to learning Perl 6?

[23:17] <literal> quite the opposite

[23:18] <literal> Perl 6 is still Perl :)

[23:18] <pdc> I said "isn't a bad"

[23:18] <pdc> so I'm right?

[23:18] <wolverian> the two are not mutually exclusive, either, though naturally starting with one is probably better.

[23:18] <literal> yeah, it's a good precursor

[23:18] <pdc> hehe ok

[23:18] <pdc> great

[23:19] <pdc> well that's all my major questions answered. I hear that Perl people were nice guys :)

[23:19] <pdc> unlike ##c !

[23:19] <wolverian> we _were_ nice? :(

[23:19] <literal> hehe

[23:20] *** nekobaka left
[23:20] <pdc> I look forward to making unreadable Perl soon, then. As soon as my studies are completed in a few weeks

[23:20] <wolverian> yay!

[23:20] <literal> pdc: what sort of stuff programs do you (intend to) write?

[23:20] <literal> -stuff

[23:21] <wolverian> bookmark http://learn.perl.org 

[23:22] <pdc> literal: I'm not sure, tbh. I'm looking for a second language to go with my C. So it will be anything and everything. I want it to be a scripting language so I have something to complement C

[23:23] <literal> ok

[23:23] <pdc> Python, as I said, seemed like a great lang for rapid software development. Python, I'm sure, can fullfil that to a large extent

[23:23] <literal> Perl's best asset, which I think no other language can match (still), is CPAN

[23:23] <wolverian> absolutely.

[23:24] <pdc> it seems strange to me that a collection of unofficial, non-quality-assured code is so important. I'm sure I will come to love it

[23:25] <pdc> nb: I don't really know CPAN. I may have got those aspects of it very wrong

[23:25] <wolverian> it's just pragmatic.

[23:25] <literal> its quality is assured through reuse and testing

[23:25] <wolverian> and reviews. :)

[23:26] <literal> the CPAN Testers are great, all the modules on CPAN are tested architectures, operating systems, and Perl versions, if you ship tests with your modules

[23:26] <literal> tested on*

[23:26] <literal> I don't think other languages' code repositories do this

[23:27] <moritz_> pdc: well, there are about 17k modules on CPAN. Even if 90% of them are crap, there are nearly 2k of awesome modules remaining ;-)

[23:27] <pdc> oh wow you're suggesting that 90% of CPAN possible isn't good? :)

[23:27] <pdc> s/possible/possibly/

[23:28] <moritz_> pdc: 90% of all software is crap ;-)

[23:29] <moritz_> (personal opinion only)

[23:29] *** Tene left
[23:29] <literal> pdc: the archive on this blog might be of interest to you -> http://modernperlbooks.com/

[23:29] * moritz_ -> bed

[23:30] <pdc> good night moritz_ 

[23:30] <pdc> literal: bookmarked, thanks

[23:31] <literal> it's not really about Perl books, though :)

[23:31] <pdc> and thank you for all your answers and thought. I look forward to getting started on Perl 5 in a few weeks

[23:31] <literal> feel free to bug me if you've got more questions

[23:33] <pdc> thanks. I will no doubt idle here and in #perl anyhow

[23:33] <literal> cool

[23:56] *** DemoFreak left
