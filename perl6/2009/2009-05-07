[00:00] <ruoso> but that is different in syntax level

[00:00] <jnthn> Oh, you think that is handled syntacticly?

[00:00] <ruoso> that's what the spec says

[00:00] * jnthn checks the smart-match table

[00:00] <jnthn> (or where else should I look?)

[00:00] <ruoso> the smart-match table indeed

[00:01] <ruoso> the first is compiled as 42.does(Int) 

[00:01] <jnthn> ruoso: It's not in the top bunch of entries that are syntactic forms though?

[00:01] <ruoso> jnthn, I think we already had that conversation... ;)

[00:01] <jnthn> Yeah, did we ever get an answer?

[00:02] <ruoso> I guess it was that the entire table counts

[00:02] <jnthn> It can't be. You can't syntactically know what's in $scalar.

[00:02] <jnthn> And that means we can't go syntax-based on protos either.

[00:02] <jnthn> rakudo: my $foo = Int; say 42 ~~ $foo;

[00:02] <p6eval> rakudo 615936: OUTPUT«1␤»

[00:03] <jnthn> If you just went on syntax we'd get the wrong answer there.

[00:03] <ruoso> and that's calling .ACCEPTS 

[00:04] <jnthn> Yes, but how do you differentiate Int.ACCEPTS(42) from 1.ACCEPTS(42)?

[00:04] <jnthn> Other than something somewhere knowing that some methods just need to dispatch differently?

[00:04] <ruoso> hmm....

[00:05] <ruoso> I wasn't really thinking on that in terms of Int.ACCEPTS

[00:05] <ruoso> but... wouldn't that be solved by the multi dispatch of ~~ ?

[00:06] <ruoso> multi infix:<~~>(Any $x, Abstraction $y) { $x.does($y) }

[00:07] <jnthn> Smart-match isn't supposed to be multi-dispatch though.

[00:07] <ruoso> hmm....

[00:08] <jnthn> Plus it doesn't solve the ACCEPTS case

[00:08] <jnthn> In Rakudo we've got away with this so far because our proto-object had a different type.

[00:08] <jnthn> (Basically, a mix-in to an instance of the type)

[00:09] <ruoso> well... ACCEPTS itself could test for definedness

[00:09] <jnthn> We already said definedness doesn't tell us about proto-ness, and that's mean we make every ACCEPTS method on every type aware of the difference.

[00:10] <jnthn> Basically we need to dispatch ACCEPTS somehow differently on a type object than on an instance.

[00:10] <jnthn> Despite them still being the same type.

[00:10] <jnthn> Catching it in the dispatch is the best I've thought of so far on that though. :-|

[00:10] <ruoso> ok... we're moving to the second question without answering the first

[00:11] <ruoso> how do we know it's a type object or just an bare undefined value

[00:11] <jnthn> My suggestion is that it claims that it does Abstraction.

[00:11] <ruoso> we're going in circles

[00:11] <ruoso> heh

[00:11] <ruoso> how does it know it is a type object

[00:11] <ruoso> ?

[00:12] <jnthn> That's probably a decision for the representation?

[00:12] <jnthn> (e.g. "do I have instance storage" seems to be a sensible way to do it in P6opaque)

[00:12] <ruoso> er...

[00:12] <ruoso> so a type object is an object without instance storage

[00:13] <jnthn> That seems to be to be the way you're doing it in smop?

[00:13] <jnthn> OK, you're basing your default .defined off this too.

[00:13] <jnthn> But that's the test that .defined in the repr is currently based on, if I understand correctly?

[00:13] <ruoso> I didn't care so much about that, actually... in fact you could even use a defined object as the type object ...

[00:14] <ruoso> in fact... that's what happen when you do a runtime mixin

[00:14] <ruoso> but yes, .defined delegates to .^defined that usually will delegate to .^!instance_storage

[00:15] <jnthn> OK, so I think we agree at this point that .defined isn't our way of saying "is this a type object"?

[00:16] <ruoso> yeah...

[00:17] <ruoso> but the question is...

[00:17] <ruoso> what defines a type object?

[00:17] <ruoso> I mean...

[00:17] <ruoso> in  SMOP I mostly didn't care so far...

[00:17] <jnthn> :-)

[00:18] <ruoso> because a type object was simply something I used as a type object

[00:18] <ruoso> I never needed to define it per e

[00:18] <ruoso> *per se

[00:18] <jnthn> Aye. That only holds for so long, and Rakudo is a long way beyond that point. :-)

[00:18] <ruoso> does that mean you already know how to do it?

[00:19] <ruoso> :)

[00:19] <jnthn> Well, I know how we are doing it today, but it isn't really in line with S12.

[00:20] <jnthn> (Which is that our proto-object is an instance of the class + a mix-in, which means it's of a different type)

[00:20] <ruoso> yeah... it certainly doesn't fit with a more prototype-based OO... which seems where you're heading to

[00:20] <jnthn> Plus S12 says that that the type object is of the same type.

[00:21] <jnthn> Plus I've seen a couple of places where us not having them being the same type is liable to trip us up.

[00:21] <ruoso> ok...

[00:21] <jnthn> Plus I don't know that it fits too well with the whole meta-class vs representation model.

[00:21] <jnthn> Which seems to require something more prototype-ish.

[00:21] <ruoso> let's examine why we need to define them per se

[00:21] <ruoso> instead of just defining them by the way we use them

[00:22] <ruoso> where does that bite us?

[00:22] <ruoso> I mean... why do we need an Abstraction role?

[00:23] <jnthn> I guess that partly arises out of the "all sigils (but $) imply a role".

[00:23] <jnthn> So ::T = ... would want the RHS to do Abstraction

[00:24] <ruoso> but :: isn't really a sigil

[00:24] <ruoso> in fact ::T is explicitly saying T without a sigil ;)

[00:24] <jnthn> Yeah, :: is a bit special.

[00:24] <jnthn> I'm not sure we need an Abstraction role per se.

[00:25] <ruoso> right...

[00:25] <jnthn> It is, however, handy.

[00:25] <ruoso> why do we need to test if this is a "type object" or not?

[00:25] <jnthn> During the parse we most certainly need to know what is a type object.

[00:25] <ruoso> but during the parse we know by their name, not by themselves

[00:26] <jnthn> Not for stuff in the package, which will have been fully compiled when we did a "use" of the module they were in.

[00:26] <ruoso> you still need a header-like information for that symbols, don't you?

[00:26] <jnthn> But yes, sometimes it goes off known names too.

[00:27] <jnthn> We don't have one.

[00:27] <jnthn> In the pre-compiled case, that's even trickier to get.

[00:27] <jnthn> We rely in the parse on being able to know if something is a type or not, and I don't see that changing.

[00:28] <jnthn> Both by checking names we know, and by falling back to looking at the thing.

[00:28] <ruoso> what happens if we neglect the fallback?

[00:28] <jnthn> We parse wrongly.

[00:29] <jnthn> And then generate the wrong code.

[00:29] <jnthn> And then we fail it. :-)

[00:29] <ruoso> hmmm..

[00:29] <ruoso> wouldn't it be more elegant if we had a header-like information?

[00:30] <ruoso> since we can't really define what the fallback needs to look for...

[00:30] <jnthn> And anyway, we already had a case (Int.ACCEPTS(42) vs 1.ACCEPTS(42)) aside from this one where it matters whether it's a type object or not.

[00:30] <jnthn> (because we need to dispatch .ACCEPTS differently)

[00:31] <ruoso> ok...

[00:31] <jnthn> What the fallback needs to look like is going to be a tad implementation-dependent too.

[00:31] <ruoso> what's the difference between...

[00:31] <ruoso> my Int $x; 1 ~~ $x;

[00:31] <jnthn> In Rakudo, we're going to have to care about things from other langauges too.

[00:31] <ruoso> my $x = Int; 1 ~~ $x;

[00:32] <jnthn> Difference in result? None.

[00:32] <jnthn> Difference is that the first constraitns $x and the second doesn't.

[00:32] <ruoso> did you read the code carefully?

[00:32] <jnthn> Yes.

[00:32] <ruoso> at the first I just have an uninitialized value

[00:33] <ruoso> and the second I explicitly set Int

[00:33] <ruoso> semantically... it's very much different

[00:33] <jnthn> No, if you have a typed variable it's initialized to the proto-object.

[00:33] <ruoso> exactly...

[00:33] <jnthn> That's now my Dog $fido .= new() works.

[00:33] <jnthn> Either way, $x ends up containing Int.

[00:33] <ruoso> my question is wether 1 ~~ $x should ever be understood as a type check

[00:34] <jnthn> yes yes yes

[00:34] <jnthn> Because it means $x.ACCEPTS(1)

[00:34] <jnthn> Which is *exactly* what the multi-dispatcher and everything else involved in type-checking hangs off in Rakudo.

[00:34] <ruoso> considering it means $x.ACCEPTS(1)

[00:35] <ruoso> should it do a type check in that ACCEPTS call?

[00:35] <ruoso> I mean

[00:35] <ruoso>  1 ~~ $x is a type check

[00:35] <ruoso> sorry

[00:35] <ruoso>  1 ~~ Int is a type check

[00:35] <ruoso> syntatically

[00:36] <ruoso> the parser can figure that out...

[00:36] <jnthn> I don't quite see what you're getting at.

[00:36] <jnthn> This isn't syntactic.

[00:36] <ruoso> ok... let me try to ellaborate a bit more...

[00:36] *** nihiliad left
[00:37] <ruoso> I'm trying to see how far the idea of not being able to define the type object per se can go

[00:37] <ruoso> and in that process

[00:37] <ruoso> I'm contemplating the idea that 

[00:37] <ruoso> my Int $x; 1 ~~ $x;

[00:38] <ruoso> should be false

[00:38] <ruoso> because the ACCEPTS of Int is always the same

[00:38] <ruoso> so you're comparing 1 with undefined

[00:38] <ruoso> and that's false

[00:39] <jnthn> And for 1 ~~ Int|Str

[00:39] <jnthn> Now we have to recognize that syntactically too

[00:39] <jnthn> ?

[00:39] <ruoso> well.. there we have a junction

[00:39] <ruoso> ok.. I see what you mean

[00:40] <jnthn> It's interesting to contemplate what happens if we say we don't have a way of knowing whether something is a type object or not by looking at it.

[00:40] <jnthn> But having spent the last year thinking a lot about and implementing a lot of Perl 6 type-based stuff, I just don't think it's going to fly.

[00:41] * ruoso afraid we're going to end up with a .^!abstraction flag

[00:42] *** wollmers left
[00:42] *** wollmers joined
[00:42] <jnthn> There's just too many places I can think of that it matters, where it gets really hard to see where I'd go with those if we decided it didn't matter.

[00:42] *** cwe_Q17dh-aYEn joined
[00:42] <ruoso> so, from the user perspective...

[00:42] <ruoso> what defines a type object?

[00:42] <ruoso> is that something declared with class/role/etc?

[00:43] <jnthn> So far my list of type-ish things are:

[00:43] *** cwe_Q17dh-aYEn left
[00:43] <jnthn> * classes

[00:43] <jnthn> * roles

[00:43] <jnthn> * subsets

[00:43] <jnthn> * enums

[00:43] <jnthn> I think that's abou tit.

[00:44] <ruoso> ok... besides the ^!abstraction flag (which might be the actual solution here)

[00:45] <ruoso> there's one thing we could try

[00:45] *** bacek joined
[00:45] <ruoso> which is about the process of getting it by its name

[00:46] <jnthn> More...?

[00:46] * ruoso still trying to find how to explain the fuzzy idea he just had

[00:47] <jnthn> Remember that some of our type-ish things can also be anonymous.

[00:47] <ruoso> like mixins in the undefined value...

[00:47] <ruoso> my Int $x; $x does Bar;

[00:48] <ruoso> >

[00:48] <ruoso> ?

[00:48] <jnthn> That (in Rakudo) takes the type of $x, derives a subclass that does the role, and re-blesses $x into the new type.

[00:48] <jnthn> I'm aware in smop you can probably do that in a different kinda way.

[00:49] <ruoso> I can mixin in the object itself

[00:50] <jnthn> Sure. We have backends that differ in there proto-oo-ness. :-)

[00:50] <jnthn> (Which is a good thing, since if we want to see Perl 6 on other VMs, they differ in their levels of proto-oo-ness too.)

[00:50] <ruoso> but the question here really is...

[00:50] <jnthn> *their

[00:51] <jnthn> But basically a mix-in in Rakudo changes the type.

[00:51] <ruoso> rakudo: my Int $x; say $x === Int;

[00:51] <p6eval> rakudo 615936: OUTPUT«1␤»

[00:51] <ruoso> rakudo: my Int $x; say $x =:= Int;

[00:51] <p6eval> rakudo 615936: OUTPUT«0␤»

[00:51] <jnthn> =:= Int is about container identify IIRC

[00:51] <ruoso> right...

[00:51] <jnthn> That should maybe even fail because the RHS isn't a container.

[00:51] <ruoso> rakudo: my Int $x; say $x.WHICH, Int.WHICH;

[00:52] <p6eval> rakudo 615936: OUTPUT«-1240611912-1240611912␤»

[00:52] <jnthn> Right, which is why === gives the same.

[00:52] <ruoso> but should it be the same?

[00:52] <jnthn> Yes.

[00:52] <jnthn> $x is just initialized to Int

[00:52] <jnthn> (which is undefined)

[00:53] <jnthn> (because it's a type object)

[00:53] <ruoso> ok... which undefined values are not types then?

[00:54] <jnthn> class Foo { method defined { False } }; Foo.new # <-- undefined

[00:54] <ruoso> right

[00:54] <hatseflats> perl6 has support for coroutines, right?

[00:54] <jnthn> It's getting later here. I suspect best will be to both go away and think on it a bit.

[00:55] <jnthn> And hope that TimToady will show up with a magic answer in the meantime. ;-)

[00:55] <ruoso> yeah... my mind is kinda foggy...

[00:55] <ruoso> better sleep...

[00:55] <jnthn> Yeah, and you're a few timezones over from me. :-P

[00:56] <ruoso> but I have a 5-mo old baby in the house ;)

[00:56] <hatseflats> actually, never mind that, what happens when I call coroutine x { statement; yield 5; } two times?

[00:56] *** eternaleye joined
[00:56] <jnthn> Ah, I can imagine that serves as quite a sleep-spoiler, but nice in many other ways. :-)

[00:56] <hatseflats> in this case, please ignore the fact that that's probably not proper perl :)

[00:56] *** bacek__ joined
[00:57] <ruoso> jnthn, no doubt about that ;)

[00:57] <jnthn> hatseflats: I'm not sure what the status of coroutines in Perl 6 are at the moment off the top of my head.

[00:57] <ruoso> hatseflats, Perl 6 doesn't have explicit coroutines

[00:57] <jnthn> Last I knew S17 had the most info.

[00:57] <ruoso> although you can easily implement them

[00:57] <ruoso> but the language itself won't provide the "coroutine" construct

[00:57] <jnthn> OK, night all

[00:58] <hatseflats> nite jnthn 

[00:58] <ruoso> it should be fairly easy to implement it in a module tho

[00:59] <hatseflats> what I'm trying to figure out is, is the default behavoir of a coroutine an implied for(;;) loop, or does the syntax break if you reach the end of your coroutine without yielding

[01:00] <ruoso> hatseflats, that will be up to whoever implement the coroutine module...

[01:00] <ruoso> and we're probably going to have more than one

[01:00] <hatseflats> no concensus as of yet then, ookay

[01:01] <ruoso> there is consensus

[01:01] <ruoso> the consensus is that it is not part of the language core

[01:02] <ruoso> because maintaining the state of the coroutine raises concurrency issues...

[01:02] <ruoso> and semantic issues as wel

[01:02] <hatseflats> and thus leave the implementation up to whoever writes a mod for it

[01:02] <ruoso> exactly... we do know that the language provides all the runtime features to implement all coroutine models I'm aware of

[01:03] <hatseflats> hmhm

[01:04] <hatseflats> just for shits 'n giggles, top off your hat, name one of the concurrency issues

[01:04] <hatseflats> I can't deduce one myself :(

[01:04] <ruoso> considering you have a coroutine named foo

[01:05] <ruoso> therefore registered in the lexical scope as &foo

[01:05] <hatseflats> yeah

[01:05] <ruoso> therefore available for code that can be running asynchronously

[01:05] <ruoso> how do you know which state of &foo will it call when each of those codes call it?

[01:05] <hatseflats> yep, that's one

[01:06] <ruoso> hatseflats, are you aware of the gather/take construct?

[01:06] <hatseflats> not by name

[01:07] <ruoso> hatseflats, http://perlcabal.org/syn/S04.html 

[01:07] <ruoso> http://perlcabal.org/syn/S04.html#The_gather_statement_prefix

[01:09] <ruoso> hatseflats, it's almost the same as a coroutine, but it's not a routine and it maintain its state in a lazy list...

[01:09] <hatseflats> I see

[01:10] <hatseflats> hmm

[01:33] *** ab5tract joined
[01:43] *** silug left
[01:44] *** Whiteknight left
[01:55] *** chid joined
[02:03] *** japhb left
[02:04] *** viirya joined
[02:05] *** PhatEddy left
[02:06] *** nihiliad joined
[02:09] *** chid left
[02:13] <s1n> ruoso: congrats on the gsoc, i hope that works out well and reignites smop development

[02:14] <ruoso> s1n, thanks...

[02:29] *** mizioumt left
[02:46] *** Kisu joined
[02:46] *** Kisu left
[02:47] *** Kisu joined
[02:47] *** Kisu left
[02:48] *** Kisu joined
[02:49] *** cspencer joined
[02:50] *** cls_bsd left
[02:54] <cspencer> rakudo: (a x=> 2).say

[02:54] <p6eval> rakudo 615936: OUTPUT«Could not find non-existent sub a␤current instr.: '_block14' pc 61 (EVAL_16:47)␤»

[02:54] <cspencer> rakudo: 'a' X=> 1

[02:55] <p6eval> rakudo 615936: OUTPUT«Statement not terminated properly at line 1, near "X=> 1"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[03:01] *** hercynium left
[03:11] *** japhb joined
[03:20] *** donaldh left
[03:20] *** donaldh joined
[03:39] *** orafu left
[03:40] *** orafu joined
[03:42] *** silug joined
[03:43] <s1n> ruoso: so is there any documentation that indicates what's going on with smop? there's lots of pieces to that and i was always kind of curious about it

[03:57] *** viirya left
[04:00] *** justatheory joined
[04:13] *** justatheory left
[04:13] *** cdarroch left
[04:17] *** justatheory joined
[04:17] *** jrockway joined
[04:18] *** mikehh_ is now known as mikehh

[04:19] *** justatheory left
[04:21] <s1n> TimToady: i question the need for Str.words (S32:389) when it will most likely only ever be useful in the most basic case. i'm not sure you should clutter the spec with that

[04:43] *** H1N1[A] left
[04:46] <TimToady> I think it will be used frequently enough in the first code other people see that it's worth it for readability

[04:47] <TimToady> jnthn: I wouldn't mind a valid bit of some sort that is returned by .defined by default.

[04:47] *** bacek left
[04:47] <TimToady> assuming the storage itself doesn't indicate validity

[04:48] <TimToady> so .ACCEPTS only works on the value if it's valid

[04:48] <TimToady> otherwise it looks at the .WHAT (which probably matches the cases of smartmatching failures as well)

[04:49] <TimToady> er, that was not well put...

[04:49] <TimToady> but anyway, I think the bit is on data validity more than abstraction.

[04:49] <TimToady> or maybe there's two bits

[04:50] <TimToady> I really don't mind bits--I hope there's a taint bit in there too :)

[04:50] <TimToady> later &

[04:56] *** mikehh left
[04:56] *** cspencer left
[04:56] *** mikehh joined
[04:59] *** H1N1[A] joined
[05:02] *** H1N1[A] is now known as H1N1[S]

[05:09] <s1n> TimToady: you could alternatively rename it, as .words() is very misleading

[05:16] *** mikehh_ joined
[05:16] *** mikehh left
[05:16] *** mikehh_ is now known as mikehh

[05:28] *** bacek joined
[05:29] *** nihiliad left
[05:37] *** ejs joined
[05:38] *** cls_bsd joined
[05:41] *** skids left
[05:49] *** ab5tract left
[06:02] *** ejs left
[06:05] *** mikehh left
[06:07] *** Rolo joined
[06:08] *** Rolo is now known as Kyosuke_Kiryu

[06:10] *** cls_bsd left
[06:16] *** mikehh joined
[06:46] *** azawawi joined
[06:46] <azawawi> good localtime()

[06:47] <moritz_> greetings.

[07:09] *** DemoFreak joined
[07:13] *** kst left
[07:14] *** azawawi left
[07:20] *** donaldh left
[07:20] *** donaldh joined
[07:22] *** mberends joined
[07:27] <spx2> moritz_: hi

[07:27] <spx2> moritz_: read the blackjack article , that was pretty awesome

[07:28] <spx2> why isn't there a project for documenting p6 ?

[07:28] <spx2> moritz_: is the test suite of p6 written and you just have to write code so that all tests pass ?

[07:28] <moritz_> spx2: there is.

[07:28] <spx2> moritz_: or not even the test suite is complete yet ?

[07:29] <moritz_> spx2: it's not finished yet, no

[07:29] <spx2> is there any empirical possible way of telling when the hell it's going to be done ?

[07:29] <spx2> so I can know if it's worth starting to learn it or not

[07:31] *** viirya joined
[07:31] <moritz_> you can extrapolate the number of passing tests...

[07:31] <moritz_> I did that on perlmonks somwhere, let me find that thread for you..

[07:32] <spx2> moritz_: that would be fantastic

[07:32] <spx2> moritz_: I'd really like to take a look

[07:33] <moritz_> spx2: see http://www.perlmonks.org/?node_id=751341

[07:33] <wollmers> spx2: Failed 7/381 test programs. 18/13580 subtests failed.

[07:33] <wollmers> spx2: on my desktop with a fresh pull of rakudo

[07:34] <spx2> ok how long does it take to carry out all the tests ?

[07:34] <moritz_> 7 test programs? what did you do? ;-)

[07:35] <moritz_> spx2: about half an hour on my machine... rakudo is still very slow

[07:35] <wollmers> moritz_: git pull; make clean; make; make spectest;

[07:35] <moritz_> IMHO it's already worth playing around with

[07:36] <spx2> moritz_: how experienced are you in order to be able to write code on it ? I think you already know it's grammar pretty well and you have actually written parts of the language and that is probably the reason why you would find it easy to write in it

[07:39] *** iblechbot joined
[07:39] <moritz_> spx2: I've been hanging around here for 2.5 years or so, reading other people's code... but if you know Perl 5 it's not so hard to get started

[07:40] <arnsholt> rakudo: my @a = ['a', 'b', 'c']; say @a.perl;

[07:40] <p6eval> rakudo 615936: OUTPUT«[["a", "b", "c"]]␤»

[07:40] <arnsholt> Is that correct behaviour?

[07:40] <moritz_> spx2: and I try to blog about it so that others can learn from my experience ;-)

[07:40] <moritz_> arnsholt: yes

[07:41] <arnsholt> Right ho.

[07:41] <moritz_> arnsholt: you assing a scalar to an array, making it the only element

[07:41] <moritz_> rakudo: my @a := [<a b c>]; say @a.perl

[07:41] <moritz_> wait

[07:41] <p6eval> rakudo 615936: OUTPUT«["a", "b", "c"]␤»

[07:41] <moritz_> ah yes

[07:41] <moritz_> with binding you replace the array

[07:48] <arnsholt> Right. Now I see the difference between () and []

[07:50] *** meppl joined
[07:56] *** cls_bsd joined
[08:06] <wollmers> rakudo: my $j = 1|2; say ~WHAT($j);

[08:06] <p6eval> rakudo 615936: OUTPUT«Junction()␤»

[08:08] <wollmers> moritz_: should it return 'Junction()' or 'Junction'?

[08:10] <moritz_> the parens are correct

[08:14] <wollmers> moritz_: says 'Junction' on my desktop, so something with my local build went wrong. This explains the failed tests.

[08:15] <moritz_> wollmers: maybe your parrot is out of date?

[08:15] <moritz_> 'make parrot'

[08:15] <wollmers> Yes, assumed the same.

[08:21] <moritz_> we really need warnings in that case

[08:26] <wollmers> now got the faults at execution, rebuild rakudo

[08:27] <wollmers> warnings, or include a distinctive version of parrot into rakudo

[08:28] <wollmers> same for spectest - include instead of svn update

[08:28] <moritz_> for releases, yes

[08:28] <moritz_> for development: no

[08:28] <wollmers> ACK

[08:29] <moritz_> and since Rakudo's releases target Parrot's releases, there's not much point in including it

[08:30] <moritz_> but the last rakudo release did include a copy of the spec tests

[08:32] <wollmers> IMHO Rakudo and Parrot are very comfortable to build compared to other projects

[08:35] <wollmers> didn't try all, but failed spectests work now with fresh parrot

[08:39] *** goksie joined
[08:42] *** [particle]1 joined
[08:50] <pugs_svn> r26710 | azawawi++ | [S:H:P6] version 0.53 contains the latest STD

[08:52] *** goksie left
[09:00] *** [particle] left
[09:06] *** bacek__ left
[09:11] *** masak joined
[09:12] <masak> greetings, spec-camels.

[09:12] *** breinbaas left
[09:12] *** breinbaas joined
[09:12] <moritz_> aren't we spec bugs now? (see perl6-projects.org) ;-)

[09:13] <masak> we're definitely in a larval stage still...

[09:14] <masak> rakudo: say 3 ~~ ["a", "b", "c"]

[09:14] <p6eval> rakudo 615936: OUTPUT«0␤»

[09:15] <masak> there are some factual inaccuracies in http://en.wikibooks.org/wiki/Perl_6_Programming/Control_Structures#Smart_Matching

[09:15] <moritz_> masak: feel free to improve them ;-)

[09:15] <masak> I'm discouraged to go in and fix them, because the edits are held in quarantine.

[09:15] <masak> someone else might be more inclined.

[09:16] *** bacek left
[09:16] <masak> I think I've gotten too much of a taste for immediate improvement to accept quarantines.

[09:16] <masak> everything else around here is immediate. :)

[09:17] <moritz_> masak: maybe to talk to WhiteKnight on #parrot, I think he did some of the wikibook

[09:17] <masak> ah. yes.

[09:19] <masak> we might throw out the onion background while we're at it. it's the ghastly tiled background of the 00's.

[09:20] <mberends> mmorning mmasak

[09:20] <masak> morning mmberends

[09:20] <masak> is that a pumpkin in your pocket...?

[09:22] * mberends rolls the pumpkin onto masak's desk

[09:23] <mberends> could you finish the updates you were doing to proto? eg Installer.pm line 304: .map(*.trim)})\

[09:23] <masak> already fixed.

[09:23] <masak> I hope I pushed that, though.

[09:23] <masak> oh, seems I didn't.

[09:23] <masak> it's pushed now.

[09:23] <masak> sorry. :/

[09:23] <mberends> :) forgiven

[09:24] <masak> I have a feeling Installer.pm will break apart into at least two smaller units.

[09:24] <masak> I'm thinking of WTOP as a use case.

[09:24] <masak> it will want to ask proto about all installed projects.

[09:24] * mberends frowns

[09:24] <masak> that's not specifically an installer task.

[09:25] <masak> it's more of a projects-db task.

[09:25] * mberends frowns more deeply

[09:26] <masak> do not want?

[09:26] <mberends> yes, but .HOW ?

[09:26] <masak> that's the 1e6-$ question.

[09:26] *** eternaleye left
[09:26] *** jnthn left
[09:26] *** buu left
[09:26] *** hcchien left
[09:26] *** Maddingue left
[09:27] <masak> all the information we want is contained in %!project-info.

[09:28] <masak> maybe we just make it a separate class instead of a hash.

[09:28] <masak> in the absence of user-defined ops, we'll have to access it through methods, but that's no problem, as workarounds go.

[09:29] *** krukk joined
[09:29] *** jnthn joined
[09:29] *** eternaleye joined
[09:29] *** hcchien joined
[09:29] *** Maddingue joined
[09:29] *** buu joined
[09:29] *** irc.freenode.net sets mode: +o jnthn

[09:29] *** krukk left
[09:29] <mberends> would you settle for that, and the existence of the installed directory as proof that it's been installed? (what's the simplest thing that could work?)

[09:31] <masak> I think it's all we _can_ assert.

[09:31] <masak> ...with reasonable certainty, at least.

[09:31] <mberends> but just a random mkdir would throw it :/

[09:32] <masak> that still doesn't catch interruptet downloads, for example. or random mkdirs.

[09:32] <masak> but we're not building the ultimate solution here.

[09:32] <masak> we're building something that works for the great majority.

[09:32] <masak> a random mkdir, simple though it may be, can be considered conscious sabotage for now.

[09:33] <mberends> yes, agreed. Installer.pm still unhappy, BTW

[09:33] <masak> OH!

[09:33] * masak checks

[09:34] <mberends> line 304: meaning .map({*.trim})\ ?

[09:35] <masak> no, the {} should be implicit by the *

[09:35] <masak> I thought I fixed that...

[09:36] <masak> oh, there's an extra ) as well. :/

[09:37] <jnthn>  H H

[09:37] <mberends> O    AI jnthn 

[09:38] <masak> jnthn: Rakudo Da... oh, that was tomorrow. :)

[09:39] <masak> there, pushed.

[09:39] * masak installs faz to see that proto really works

[09:41] <jnthn> masak: Yeah, but I've so little other work at the moment most days I'm doing Rakudo stuff.

[09:41] <jnthn> I'm afraid a lot of it is currently a bit "behind the scenes" as it were though.

[09:42] <masak> that's ok.

[09:42] <masak> that's important too.

[09:42] * mberends hapy dat proto workz hear

[09:43] * masak feels he should review his push policy

[09:43] <masak> mberends: here, a pumpkin.

[09:44] <masak> it was lying on my desk while I was about to $work.

[09:44] * mberends likes pumpkins but thinks better git-fu would be superior

[09:45] <masak> oh, and the 'precompiling..' message doesn't have a corresponding newline later on.

[09:45] <mberends> nah, it was documented as a "delete me when I irritate you" line

[09:45] <masak> re git-fu: I think I was just distracted last night. doing mostly Rakudo hacking, not focusing on proto.

[09:46] <masak> mberends: what does that mean, then?

[09:46] <masak> I think for consistency it should say 'Building proto...'.

[09:46] <mberends> it's optional whether you want to keep the precompiling message or turf it out

[09:47] <masak> I also think that WTOP dictates that we eventually create a configure and a Makefile.in for proto...

[09:48] <mberends> yes, but as we get along without one, it's currently future cruft

[09:49] <masak> it's on our list of technological debt.

[09:51] <mberends> re: the Configure name, I agree that Configure.p6 looks wrong, but am not convinced about no extension at all, because that file doesn't know how to execute itself.

[09:52] <mberends> I would suggest Configure.pl, and let the 'use v6;' do its work.

[09:54] <masak> I don't think I care enough to argue against that. :)

[09:54] <masak> I don't like extensions generally, but if it makes some Windows user happy, then let's have .pl

[09:55] <mberends> :) will do, and add Gitorious support now.

[09:56] <masak> nice.

[10:04] <Matt-W> Morning

[10:05] <mberends> mmmorning MMMatt-W

[10:07] <masak> rakudo: say 'm' x 10 ~ 'orning!'

[10:07] <p6eval> rakudo 615936: OUTPUT«mmmmmmmmmmorning!␤»

[10:07] *** cls_bsd left
[10:08] <spx2> anyone here ever used IPC::ShareLite in p5 ?

[10:10] <mberends> spx2: no, but it interests me

[10:10] <spx2> mberends: really ?

[10:11] <spx2> mberends: do youneed shared memory operations ?

[10:12] <mberends> yes, because I had some multitasking stuff, and multithreading was not always the right answer.

[10:12] <mberends> it's been a while since I worked on that though, Perl 6 got me quite distracted ;)

[10:12] <spx2> so , if multithreading was not the right answer , how did you implement ?

[10:13] <spx2> poe ?

[10:14] <mberends> I didn't move to poe yet because it looked like too much sledgehammer for a little nut at the time. Today I would seriously look at POE before re-inventing the wheel (pun intended).

[10:16] <mberends> the application was a database backend with a web server and multiple scheduled tasks. Sharing the database connection was a problem in threads.

[10:16] *** bacek joined
[10:17] *** Kyosuke_Kiryu left
[10:17] <spx2> well it's almost the same for me

[10:17] *** viirya left
[10:17] <spx2> except that I have some other things also to do

[10:18] <spx2> anyway I was very disapointed in IPC::ShareLite and I gave it a bad rating here http://cpanratings.perl.org/dist/IPC-ShareLite

[10:21] <mberends> spx2: I see. Is the maintainer active? (a bit off topic for #perl6). There are people here looking at making POE equivalents for Perl 6 though.

[10:23] <spx2> the maintainer not sure

[10:24] <spx2> I think I tried to email him

[10:24] <spx2> but didn't get any answer

[10:26] <mberends> well Perl 6 does not do shared memory today and it does not seem to be a priority. Rakudo would depend on Parrot doing it first, and that's not very evident either.

[10:30] *** Kisu left
[10:31] *** Kisu joined
[10:37] <mberends> spx2: reading the other (happier) CPAN rating and the IPC::Sharelite docs, it is Lite and shares only scalars, not objects as you desire. Your usage is out of spec and criticism unfairly harsh. Try the other modules mentioned instead. Anyway, enough P5, sorry.

[10:42] *** mikehh_ joined
[10:47] *** iblechbot left
[10:48] *** ruoso left
[10:57] *** mikehh left
[10:58] *** payload left
[10:58] *** fridim joined
[11:02] *** H1N1[S] is now known as H1N1[A]

[11:09] <pmichaud> Good morning.

[11:10] <mberends> good am, pm

[11:12] <jnthn> morning pm

[11:16] *** fridim left
[11:17] * pmichaud has a few minutes waiting at the airport.  :-)

[11:20] *** donaldh left
[11:20] *** donaldh joined
[11:22] *** fridim joined
[11:23] *** pancake joined
[11:29] <pmichaud> well, time to board.  bbl.

[11:33] *** breinbaas left
[11:33] *** breinbaas joined
[11:34] <arnsholt> baest: Was it you who was interested in my SQL grammar thing?

[11:34] <baest> arnsholt: it was

[11:34] <arnsholt> Just pushed the first stuff to git://github.com/arnsholt/SQL-Grammar.git

[11:35] <baest> arnsholt: uh nice

[11:36] <arnsholt> If you're still interested that is. It's ludicrously basic, but at least people can look at it if they want

[11:36] <baest> arnsholt: I am. I will have a look in the weekend. Maybe send you some patches if I have time and is inspired :)

[11:37] <arnsholt> Sure. And patch away. There's mountains of stuff to do =)

[11:37] *** hanekomu joined
[11:37] *** hanekomu left
[11:45] <baest> arnsholt: regarding your readme, I'm not sure that it's possible to avoid actions at all, but it's not that bad

[11:46] *** mizioumt joined
[11:47] <jnthn> oh noes! http://news.bbc.co.uk/2/hi/technology/8037688.stm

[11:47] <arnsholt> baest: I don't want to avoid actions as such, I'd just like to override the default parse method with a method that automatically supplies the action object

[11:48] <baest> arnsholt: yes, I just saw that in the code, sorry

[11:48] <jnthn> .oO( And I thought DNF was going to be Perl 6's killer app )

[11:48] <arnsholt> And then passes the call on to Grammar.parse, but for some reason I can't get the dispatch to Grammar.parse to work properly

[11:48] <baest> jnthn: I've already heard the "oh then perl6 might be release before duke nukem forever anyways"-joke

[11:49] <jnthn> ;-)

[11:49] <jnthn> I thought Duke Nukem Forever was taking so long because they wanted to write it in Perl 6. :-)

[11:50] <arnsholt> I think the joke will be on the doubters though, when they suddenly realise that Perl 6 has come into existence, right under their noses =)

[11:50] <baest> arnsholt: might be that there are some trickery going on. Have you looked at the outputted pir

[11:52] <arnsholt> Not yet. My primary focus has been just getting the bare basics sort-of working

[11:52] <arnsholt> I'll do that though

[11:55] *** amoc joined
[12:04] <masak> Duke Nukem Forever will be written, one way or the other. The idea is too concrete to just fizzle away.

[12:06] *** Casan joined
[12:08] *** mizioumt1 joined
[12:10] <baest> masak: so when are you ready with it written in perl6 :)

[12:10] *** mizioumt1 left
[12:10] *** mizioumt1 joined
[12:10] <masak> baest: we'll see. I have a couple other projects right now taking priority.

[12:11] <masak> baest: in fact, I have a very nice idea for a MUD framework that I've been thinking about since 2003, that is more or less waiting for Perl 6 to mature.

[12:11] <baest> masak: :)

[12:14] <masak> rakudo: my Int $n = +("foo 5 bar" ~~ / foo (\d+) bar / and $0); say "you can assign numified matches to Int variables"

[12:14] <p6eval> rakudo 615936: OUTPUT«Type mismatch in assignment; expected something matching type Int but got something of type Num()␤current instr.: 'die' pc 16547 (src/builtins/control.pir:225)␤»

[12:15] <masak> :(

[12:15] *** mizioumt left
[12:18] <masak> maybe I have unreasonable expectations on the type system, but I think that the "scalar types" (Str, Num, Int...) should be flexible and do some kind of "late binding", allowing things like the above to work.

[12:19] <moritz_> then don't declare types.

[12:19] <moritz_> seriously

[12:20] <moritz_> if you want to use a variable like a Num whether it's a Num or not, don't declar a type, and just use it as that

[12:20] <moritz_> or declare a cocercion (NYI)

[12:20] <masak> yes, you're probably right.

[12:21] <moritz_> that said, numification not returning an Int where appropriate is a known bug in Rakudo

[12:21] <moritz_> or you can call it "limitation"

[12:21] <masak> moritz_: oh, I thought that too was only an unspecced opinion of mine.

[12:21] <masak> good news, in that case.

[12:21] <moritz_> it's in RT:

[12:21] <moritz_> s/:/./

[12:21] <masak> I know. :)

[12:21] <masak> I put it there.

[12:22] <moritz_> iirc pmichaud acknowledged it as a bug

[12:22] <masak> the original issue is from Druid, where I feel I need to do excessive casting.

[12:22] <moritz_> anway, .int exists

[12:22] <masak> that's my workaround at present.

[12:23] <masak> I'm very happy Perl 6 allows me to type 'my Dog $d = Dog.new' as 'my Dog $d .= new'. but in the above case I still have to type something like 'my Int $row = int(...)'

[12:24] <moritz_> my $row as Int = ...;

[12:24] <masak> oh, ok. I still need to gork 'as', though.

[12:25] <masak> s/gork/grok/

[12:25] <moritz_> I don't know exactly if it works like that

[12:26] <moritz_> but in a signatures

[12:26] <moritz_> sub sin($x as Num) { ... }; sin "3.14"; works

[12:26] <moritz_> by coercing $x to Num

[12:27] <masak> well, that gives me almost no type safety at all, if I understand the feature correctly.

[12:27] <masak> because most everything can be coerced to an Int.

[12:28] <moritz_> and if that casting happend automatically (as you proposed before), then you'd have next to no type safety at all ;-)

[12:28] <masak> you have a point. :)

[12:29] <moritz_> for non-core type it's a good idea though

[12:29] <moritz_> typecasting will give you a friendly error message if it doesn't work ;-)

[12:29] <masak> there's a very nice deliberate confusion between numbers and strings in Perl. it sometimes seems we lose too much of that niceness when we add type checking.

[12:30] <moritz_> yes, we tend to overuse types

[12:30] <moritz_> because we can.

[12:30] <masak> I guess I'm sort of looking for a middle ground, even though I know that type systems are best when they're unforgiving.

[12:33] *** Kisu left
[12:34] *** Kisu joined
[12:37] *** ruoso joined
[12:38] *** payload joined
[12:42] <ruoso> HellO!

[12:42] <moritz_> OH HAI

[12:46] <frettled> I know it's old and stuff, but: http://www.flickr.com/photos/34034335@N00/3262204184  (no, no reason to worry, please visit Trondheim)

[12:47] * ruoso backlogging to see if anything came out from yesterday's open issue....

[12:47] <frettled> So, how about YAPC::EU in Trondheim next February?  :)

[12:48] <moritz_> what about a *cheap* town for once? ;-)

[12:50] <arnsholt> Oooh. YAPC::EU in Norway would be excellent. I'm gonna try to get to Lisboa this year, but if it were in Norway I'd definitely go

[12:51] <frettled> moritz_: I refuse to answer that question as it could be used as evidence against me at a future time.

[12:52] <jnthn> frettled: That's...a long way north! :-D

[12:52] <jnthn> frettled: I already did visit once to Trondheim. :-)

[12:52] <arnsholt> frettled: Nice picture. For a second I even thought it was real =)

[12:52] <jnthn> ok, slovak class time, laters...

[12:52] <moritz_> frettled: If I could find a sponor I'd surely come ;-)

[12:53] <frettled> jnthn: mm, although we Norwegians only consider it the "middle" of Norway, although it's still around 500 km south of the north-south center.

[12:53] <frettled> arnsholt: but it is real.

[12:53] <ruoso> TimToady, one thing that bugs me about it is that if you have a my Int $x; on the begging of the code and in a corner case it ends up not being initilized, when you do $a ~~ $x, it will do a type check instead of a value check...

[12:53] <frettled> arnsholt: I mean, real pixels.

[12:54] <arnsholt> *snort* Quite =D

[12:54] *** iblechbot joined
[12:54] <ruoso> jnthn, did you notice TimToady's reply?

[12:56] <arnsholt> frettled: Riktig festlig bilde da. Jeg vurderer å spre det til mine andre utenlandske venner >:)

[12:56] <frettled> arnsholt: but I totally agree, we should apply for a YAPC::EU in a few years.  We just have to make sure that sjn and the rest of them forget how much work NPW 2009 was.

[12:56] <frettled> arnsholt: gj􏿽xF8r det!

[12:57] <arnsholt> When I lived in France, there were some people who wondered if polar bears roamed the streets of Norway. We really should've had that photo back then =D

[12:58] <frettled> yep.

[12:59] *** abra joined
[13:00] <mberends> masak: pushed proto (early), Gitorious support almost complete.

[13:01] <masak> nice.

[13:01] <masak> I have to do some $work still, so keep the big orange one with you for now.

[13:01] *** cls_bsd joined
[13:01] <masak> mberends: maybe I'll have some time to review your commits, though.

[13:02] <mberends> ok, gotta &think() about the repo directory structure differences.

[13:02] <Matt-W> My eyes are going funny

[13:03] <Matt-W> Next time somebody suggests to me that I do something involving reading a 3MB diff, I'm going to throw them out of the window

[13:03] <Matt-W> Or at least secure a copious amount of caffeine first

[13:04] <mberends> you can't seriously read that much text manually

[13:04] <Matt-W> fortunately I could excise a big chunk of it automatically

[13:04] <Matt-W> I'm down to having to peruse about 600KB

[13:04] <Matt-W> aaaw no

[13:04] <Matt-W> this file's been completely replaced

[13:04] <Matt-W> because it's been converted from windows to unix line endings

[13:04] <Matt-W> ow ow ow

[13:05] <Matt-W> subversion's supposed to take care of that!

[13:05] <masak> we have a long way to go with 'smart diffs'.

[13:05] <Matt-W> yeah

[13:05] <Matt-W> still need a person to do anything clever with this stuff

[13:05] <Matt-W> I much prefer reading rakudo commit messages :)

[13:07] * mberends remembers it's market day locally, and cycles off for groceries

[13:08] <Matt-W> mmm groceries

[13:08] <masak> Matt-W: I was going to say that! :)

[13:08] <Matt-W> masak: oh dear

[13:08] <Matt-W> clearly there's more than just the M thing going on

[13:09] <spx2> mberends: sorry for the late answer , I used Storable to serialize the objects , which proved ok , up to the point where in the destructor I was using ->fetch , that was the actual problem , ->fetch didn't work in DESTROY always, sometimes it did , sometimes it didn't

[13:09] <masak> Matt-W: 'manuscript'?

[13:09] *** riffraff joined
[13:10] *** skids joined
[13:10] <Matt-W> how to convince a large, international company that funding the development of Perl 6 is absolutely vital, and, more to the point, that they should be funding me to do it.

[13:11] <Matt-W> of course

[13:11] <Matt-W> telepathic aliens

[13:11] <masak> Matt-W: you should acquire some sharks with figging lasers on their heads.

[13:14] <Matt-W> But then I'd need a pool to put them in

[13:15] <masak> aye.

[13:24] *** exodist joined
[13:32] *** sri_kraih_ joined
[13:32] *** scook0_ left
[13:32] *** xinming_ left
[13:32] *** cotto left
[13:32] *** jan_ left
[13:32] *** hatseflats left
[13:32] *** nemstep left
[13:32] *** Tene left
[13:32] *** aindilis left
[13:32] *** Tene joined
[13:32] *** scook0_ joined
[13:32] *** xinming_ joined
[13:32] *** aindilis joined
[13:32] *** nemstep joined
[13:32] *** jan_ joined
[13:32] *** hatseflats joined
[13:32] *** cotto joined
[13:32] *** irc.freenode.net sets mode: +o Tene

[13:34] *** araujo joined
[13:37] *** riffraff left
[13:37] *** ashizawa left
[13:37] *** ashizawa joined
[13:38] <frettled> Matt-W: try selling how important Perl 6 is for the future development of software, how today's software solutions may suffice for the time being, but that future growth is dependant on upgrades.  none of today's programming languages offer the economy, flexibility, scalability, security and performance that Perl 6 will.

[13:39] <masak> frettled: I don't know if you're right, but that's very nicely put.

[13:40] <PerlJam> frettled: what happens when they ask "how does perl6 offer economy as compared to ruby?"   Or something like that.

[13:41] <frettled> PerlJam: paddle

[13:42] <Matt-W> it's a real language, not a pile of bits taped together...

[13:42] <Matt-W> I think I'd better start with something smaller

[13:42] <Matt-W> like convincing them to use a decent revision control system

[13:43] <frettled> hehe, yeah, like git.

[13:44] <Matt-W> yes

[13:44] <Matt-W> in fact git would be my preference

[13:44] <Matt-W> what I've been trying to do these last two days would have been much easier if we had git

[13:44] <Matt-W> you know, something that understands what branches are actually for

[13:44] <Matt-W> and what you want to do with them

[13:47] *** skids left
[13:48] *** sri_kraih left
[14:00] *** payload left
[14:13] *** DJ-DONGDOT joined
[14:18] *** justatheory joined
[14:29] *** [particle] joined
[14:30] <masak> rakudo: grammar A { token TOP { <text> }; token text { d } }; say ?A.parse('d')

[14:30] <p6eval> rakudo 615936: OUTPUT«1␤»

[14:30] <masak> \o/

[14:30] *** [particle]2 joined
[14:31] <moritz_> yes, that works these days ;-)

[14:31] <masak> nice.

[14:31] <masak> I'm trying to understand what http://rt.perl.org/rt3/Ticket/Display.html?id=57864 needs to be closed.

[14:32] <masak> in it, pm says 'inheritance and method dispatch don't seem to be working quite properly, and we'll need to get that fixed'.

[14:32] <moritz_> there's just one thing that doesn't work in inheritance

[14:32] <moritz_> and there's a separate ticket for that

[14:32] *** [particle]nyc left
[14:33] <masak> so I can go ahead and close? which other ticket?

[14:33] * jnthn back

[14:33] <moritz_> rakudo: grammar A { token a { a } }; grammar B is A { }; say 'a' ~~ /<B::a>/

[14:33] <p6eval> rakudo 615936: OUTPUT«Null PMC access in invoke()␤current instr.: 'parrot;PGE;Grammar;' pc 499 (EVAL_20:216)␤»

[14:33] <moritz_> this one

[14:33] <moritz_> don't know what ticket it is, though

[14:34] <masak> I'll have a look around.

[14:34] <jnthn> ruoso: I saw TimToady's response. Didn't think about it yet though. :-)

[14:35] <masak> rakudo: grammar WSOverride { token TOP { <tok_foo> <.ws> <tok_bar> }; token tok_foo { foo }; token tok_bar { bar }; token ws { [ \h | \v | '%' ]+ } }; say WSOverride.parse($_) for 'foo bar', "foo\nbar", "foo%%%\nbar"

[14:35] <p6eval> rakudo 615936: OUTPUT«foo bar␤foo␤bar␤foo%%%␤bar␤»

[14:36] <mberends> mmm, fish fried in batter :) masak, did you see the proto changes?

[14:36] <masak> mberends: no, looking now.

[14:37] <masak> moritz_: are you sure that one's in RT? my searches for 'grammar' and 'inherit' turn up nada.

[14:38] <ruoso> jnthn, I'm not sure I got it right... but it seems he's suggesting that ACCEPTS should always check for definedness...

[14:38] <mberends> masak: there may be a small Installer.pm patch to follow for Gitorious projects, working on that now.

[14:38] <moritz_> masak: nearly sure

[14:39] <moritz_> rakudo: given 'foo' { if /bar/ { 1 } }

[14:39] <p6eval> rakudo 615936:  ( no output )

[14:41] *** DJ-DONGDOT left
[14:41] <masak> moritz_: nope. really not finding it.

[14:41] * masak submits, just to be sure

[14:41] <moritz_> masak: ok

[14:46] <Matt-W> rakudo: class A {}; my A $a; say $a ~~ A ?? "A" !! "O";

[14:46] <p6eval> rakudo 615936: OUTPUT«A␤»

[14:47] <jnthn> ruoso: Or type-object-ness at least.

[14:47] <Matt-W> ah good. I was correct.

[14:47] <jnthn> ruoso: I think it's more than not aCCEPTS should

[14:47] <jnthn> ruoso: It's about dispatching differently when we have a type object.

[14:48] <jnthn> We can't force everyone who writes an ACCEPTS method to go look at the type-object-ness.

[14:48] <jnthn> And then decide what to do.

[14:48] <ruoso> that gets me to an issue I always had thought about

[14:48] *** [particle] left
[14:48] <ruoso> there are some methods that are only valid on defined objects

[14:48] <jnthn> So anyway, I'm probably going to handle this in the dispatcher. It's a pretty cheap check.

[14:48] <jnthn> Well, of course. Any that depend on state. :-)

[14:49] <jnthn> I think we need to stop talking about defined here though.

[14:49] <jnthn> It's going to get horribly confusing.

[14:49] <ruoso> right

[14:49] <jnthn> We should probably talk about "type objects" and "instanes" or something.

[14:49] <ruoso> there are methods that are supposed to be called on instances and other only in type objects

[14:49] <jnthn> Though that's still not quite right. :-)

[14:49] <ruoso> I mean... from the user perspective

[14:50] <jnthn> Well, there are cases where we want to dispatch a method differently on instances from on type objects.

[14:50] <ruoso> I was thinking that we might define that as a OO feature

[14:50] <ruoso> i.e.: type methods vs instance methods

[14:52] <jnthn> Heh, maybe that's what we steal method ^foo() { } for ;-)

[14:54] <jnthn> class Object is also { method ^ACCEPTS($topic) { $topic.does(self) } }

[14:54] <masak> mberends: looks good to me.

[14:55] *** payload joined
[14:55] <ruoso> jnthn, yeah... but I guess using ^ is a bit confusing

[14:55] <masak> mberends: I once had this idea that the different repos should probably match to different classes in a hierarchy. then the 'given/when' blocks in various places would translate to inheritence polymorphism instead, bringing light and peace to the world.

[14:56] <jnthn> ruoso: Yeah, it isn't really consistent with .^ at all.

[14:56] <mberends> masak: oh yeah, peace, man!

[14:56] <jnthn> ruoso: method !OMFG!ACCEPTS { ... }

[14:56] <jnthn> ;-)

[14:56] <jnthn> .oO( might discourage people from trying it... )

[14:56] <ruoso> maybe it's a different declarator

[14:57] <ruoso> i.e.

[14:57] <ruoso> type method ACCEPTS {...}

[14:57] <moritz_> isn't that called method ICANHAZ?

[14:57] <jnthn> I don't think we're going to get a single-use declarator past TimToady. :-)

[14:57] <jnthn> (erm, single-purpose)

[14:57] <ruoso> it's just a scope-like declarator

[14:58] <jnthn> Yeah, ish...but only relevant to the type object.

[14:58] <ruoso> not really... it's relevant to the object system as a whole

[14:58] <ruoso> you have two dispatchers in each object

[14:59] <jnthn> Essentially I guess you're declaring a method that gets preference (even if it's higher in the inheritance hierarchy) on dispatches on the type object.

[14:59] <ruoso> I think you get two hierarchies

[14:59] <jnthn> Yeah.

[14:59] <jnthn> I worry a little about this though.

[14:59] <ruoso> while it falls back to type dispatch

[14:59] <ruoso> if the instance dispatch doesn't fullfit it

[14:59] <jnthn> No, the other way around.

[15:00] <ruoso> hm?

[15:00] <jnthn> If it's a type object one you gotta check the type object specific stuff first.

[15:00] <jnthn> Otherwise you'd go to the instance ACCEPTS always.

[15:00] <ruoso> 1.foo tries to call regular methods

[15:00] <jnthn> Yes.

[15:01] <jnthn> Int.foo tries to call type methods, and the instance methods if it can't do the first.

[15:01] *** nihiliad joined
[15:03] <jnthn> Not completely sure if we want to make this a more general OO feature just yet or not.

[15:03] <jnthn> I think for 6.0 maybe we can get away with special case.

[15:04] <jnthn> And punt the issue to the future.

[15:04] <ruoso> and if that fails, it goes through type methods

[15:04] <ruoso> but Int.foo only tries type methods

[15:04] <mberends> masak: the repo class hierarchy will naturally fall out of refactoring the given/when cases, assuming we cover all repo types before we boil them down. We should try to incorporate tarballs and some plain directory sources eg cdrom before shaping the hierarchy imho.

[15:04] <ruoso> so new would become a type method, for instance

[15:04] <ruoso> this also solves the issue of when to autovivify an object

[15:04] <ruoso> when you have Dog{ :name<Fido> }

[15:04] <ruoso> calling a regular method would fail,

[15:04] <ruoso> but then it checks for the WHENCE

[15:05] <ruoso> autovivifies it and tries calling again

[15:05] * ruoso lagging...

[15:05] <masak> mberends: why tarballs and plain directory sources?

[15:05] <ruoso> jnthn, I think we might have just solved a lot of issues

[15:05] <ruoso> by making it a more general OO feature

[15:06] <jnthn> Hmm.

[15:06] * ruoso lunch &

[15:06] <jnthn> I guess a level of caching would make performance less of a problem.

[15:07] <jnthn> (Looking all the way up to Object's ^ACCEPTS or however we make them look is gonna make type checking slow.)

[15:07] <jnthn> (If we don't optimize it somehow.)

[15:07] <mberends> masak: because it would be nice to use an installer offline in some cases.

[15:07] <ruoso> "all evil is premature optimization squared"

[15:07] <moritz_> another indirection layer is not always a good solution

[15:07] <ruoso> jnthn, there are a lot of tricks possible here...

[15:08] <jnthn> On the other hand, painting ourselves into a corner that we can't later optimize ourselves out of is also evil.

[15:08] <masak> mberends: all I hear is "more code to administer and keep fresh"... we have enough to do with the codebase already written. :/

[15:08] <ruoso> sure...

[15:08] <ruoso> but we were about to check in ACCEPTS anyway

[15:08] <jnthn> I just want to make sure we don't do that.

[15:08] <ruoso> I mean

[15:08] <jnthn> No, I never was. :-)

[15:08] <ruoso> even if in the dispatcher, I mean

[15:09] <jnthn> I was always proposing a dispatch level solution. We've just got ourselves a more advanced dispatcher solution. :-)

[15:09] <ruoso> we were about to have a "is this a type object" flag

[15:09] <jnthn> Erm, we still are though at some level?

[15:09] <jnthn> The dispatcher still has gotta know.

[15:09] <ruoso> yes...

[15:09] <masak> mberends: there are plenty of higher-prioritized candidates for code that we might need in the future, IMO. the recursive-deps stuff, for example.

[15:09] <ruoso> so let's make some use of it ;)

[15:09] <ruoso> instead of an exception to the rul

[15:09] <ruoso> *rule

[15:10] <jnthn> Sure, it's just that once you expose something to users you can't un-expose it.

[15:10] <ruoso> yeah... sure... 

[15:10] <jnthn> OTOH, a behind-the-scenes special exception can be replaced if we realize it was wrong later, or find a better way.

[15:10] <mberends> masak: ok, let's not prematurely overdesign.

[15:10] <ruoso> I'm just excited because it's the first time I see a solution for "when does the object autovivifies"

[15:11] <jnthn> Being able to define your own ACCEPTS on the type-object could be interesting for parametric roles too.

[15:11] <jnthn> In Perl 6 as currently defined, my @a = 1,2,3; sub foo(Int @x) { }; foo(@a) is an error.

[15:12] * ruoso really lunch &

[15:12] <jnthn> If on the other hand the role can say "try .does and then also try checking the values" in its type-object-y ACCEPTS.

[15:12] <moritz_> and who type-checks the arguments passed to ACCEPT?

[15:13] <jnthn> moritz_: Not quite sure I follow

[15:13] <jnthn> ?

[15:13] <masak> mberends: btw, github now has issue tracking, so I added your November bug report from long ago.

[15:14] *** skids joined
[15:14] <SamB> masak: does it have git mirroring yet?

[15:14] <moritz_> jnthn: I don't know if I understood your discussion correctly... but if you want to do type checking through ACCEPT methods, then you have a bootstrapping problem

[15:15] <masak> SamB: what, github? dunno.

[15:15] <jnthn> moritz_: We already do do type checking through ACCEPTS.

[15:17] <SamB> masak: yeah, github

[15:17] <SamB> it'd be really sweet if one could set up automated mirroring of one or more "upstream" repositories for a project ...

[15:17] <masak> SamB: well, dunno. never had a need for that.

[15:18] <SamB> and also have one of his/her own

[15:18] <masak> trying to comment on http://news.perlfoundation.org/2009/04/hague_perl_6_grant_request_tra.html#more

[15:18] <masak> getting "Comment Submission Error"

[15:18] <SamB> then you could use that "network" page to look at the commit graph

[15:18] <masak> whom should I contact?

[15:20] <mberends> SamB: possibly the Subproject facility approaches your goal.

[15:20] *** donaldh left
[15:20] * jnthn cheers on masak

[15:20] *** donaldh joined
[15:20] <jnthn> masak: maybe rdice?

[15:21] <masak> jnthn: is he on freenode or irc.perl.org?

[15:22] <jnthn> masak: neither atm

[15:26] <masak> maybe I should just blog about it. :)

[15:27] <jnthn> You could always leave a com...oh, wiat.

[15:28] * masak blogs about it

[15:30] <spx2> can file locks be made on directories ?

[15:31] <mberends> spx2: yes, that's how rmdir fails when another process is cd'd there.

[15:33] *** iblechbot left
[15:38] <spx2> mberends: thanks

[15:42] <masak> http://use.perl.org/~masak/journal/38936

[15:42] <masak> rdice already replied, saying he'd take a look.

[15:45] <mberends> It's time for Web.pm to power a blogging site. Volunteers?

[15:45] <masak> mberends: have you seen ihrd's Maya?

[15:46] * mberends runs 'proto install maya'

[15:46] <masak> ...and it works! proto++

[15:47] <masak> mberends: I haven't looked closely at it, but it's likely the closest we have to a Perl 6 blogging app right now.

[15:50] *** mizioumt joined
[15:51] *** eternaleye left
[15:52] *** Psyche^ joined
[15:55] <mberends> masak: maya is only partly written, largely templating functions so far.

[15:57] <masak> mberends: anyway, I volunteer.

[15:58] <mberends> can I volunteer to help?

[15:58] <masak> mberends: I don't know, it was your call to arms! :)

[15:58] <masak> logic dictates you make up the rules for who can volunteer.

[15:59] *** Patterner left
[15:59] *** Psyche^ is now known as Patterner

[16:01] <mberends> this could get recursively ossified. it does make a case for nested project dependencies, Blog -> Web -> Template + HTTP::Daemon

[16:03] <masak> indeed.

[16:05] <masak> ok, so it turns out perlfoundation's comment function is not broken after all.

[16:05] <masak> rather, it depends somehow on Javascript to work properly, and I had recently installed NoScript.

[16:05] <masak> turning js on made everything work again.

[16:06] * moritz_ hates it when pages that need javascript don't tell you so

[16:07] <masak> well, it did say "invalid request" :)

[16:08] <s1n> masak: you're one of the authors of november, correct?

[16:08] <masak> s1n: aye.

[16:08] <moritz_> that's not the same as saying "you need javascript to use the comment function"

[16:08] <s1n> masak: i assume you know the tests don't pass?

[16:08] <masak> s1n: that's a broad statement. :) I have a nightly smoke, and they passed for me last midnight.

[16:09] *** mizioumt1 left
[16:09] <masak> moritz_: had it said that, I wouldn't have to blog, send two emails, and then update my blog post...

[16:09] <masak> s/have/have had/

[16:09] <masak> s1n: what, in particular, doesn't pass for you?

[16:10] <masak> s1n: a nopaste would be nice.

[16:10] <s1n> masak: sure, it's running right now

[16:11] <moritz_> s1n: and be sure to include the Rakudo and Parrot version in your nopaste

[16:11] <masak> yes, please.

[16:11] <masak> ISTR my smoke is running against Bratislava.

[16:12] * masak checks

[16:13] <masak> seems to be quite an old Rakudo, from Feb 16, no less.

[16:13] <masak> maybe that's the discrepancy, then.

[16:14] <s1n> what's the best way to get the git revision?

[16:14] <masak> s1n: first line of 'git log'.

[16:14] <moritz_> git show|head -n 1

[16:14] <masak> or that.

[16:14] <masak> ah right, I had difficulties building newer Rakudo revisions on feather. :/

[16:15] *** Kisu left
[16:15] <PerlJam> git rev-parse HEAD # is the *best* way IMHO (for the current branch)

[16:15] <PerlJam> :-)

[16:16] <masak> PerlJam++ # that's obviously the correct answer

[16:16] *** iblechbot joined
[16:16] * s1n tries to remember how to get revisions from svn

[16:16] <moritz_> svn info

[16:17] <moritz_> PerlJam++

[16:17] <s1n> PerlJam++

[16:18] <s1n> http://gist.github.com/108190

[16:18] <s1n> i wonder if i should update rakudo/parrot...

[16:18] <moritz_> masak: http://nopaste.snit.ch/16494 november readme patch

[16:20] <masak> moritz_: thanks.

[16:20] <jnthn> ruoso: ping

[16:20] <mberends> masak: from the docs, ihrd has volunteered already to build a blogging engine, and inputs directly into Web.pm. A second such project would be wasted effort. We can best offer to help him. Call for volunteers withdrawn.

[16:20] <masak> s1n: you're running Bratislava, it seems.

[16:20] <s1n> masak: what's Bratislava?

[16:20] <masak> s1n: if you run bleeding Rakudo, that problem will go away.

[16:20] <masak> s1n: Bratislava is the latest monthly.

[16:21] <s1n> oh yeah, i used proto to build rakudo/parrot

[16:21] <masak> aye, I see that now.

[16:21] <masak> it defaults to latest monthly.

[16:21] <s1n> how do you tell it to use bleed?

[16:21] <masak> I'm really, really sorry I didn't check November against Rakudo before the release.

[16:22] <masak> s1n: actually, your best shot might be to replace the rakudo directory in proto/projects with a git checkout.

[16:23] <masak> http://rakudo.org/how-to-get-rakudo

[16:23] <s1n> yeah i know how to get/build it, i'm just lazy :/

[16:24] <masak> I appreciate that. :) it's fun to have proto users.

[16:24] * masak ponders whether to inject Bratislava workarounds into November

[16:24] *** azawawi joined
[16:25] <s1n> masak: i don't think it would be worth it

[16:25] <s1n> sounds like a moving target you'll soon regret

[16:25] <masak> depends on the complexity of the workarounds.

[16:25] <s1n> any workaround is bound to be temporary anyways

[16:26] <masak> but I do seem to recall looking at it and deciding not to...

[16:26] <masak> s1n: yes, temporary workarounds are par for the course for us Perl 6 project devs. :)

[16:26] <azawawi> masak: greeting :)

[16:26] <azawawi> masak: s

[16:27] <s1n> eventually, you'll have to start maintaining the work arounds for workarounds (workarounds for workounds for missing perl6 features), sounds like a death march

[16:27] <mberends> http://backports.november-wiki.org ;)

[16:29] <masak> s1n: nah. our workarounds don't last that long. :) the average life expectancy for a workaround in a Perl 6 project is between 1 and 2 months.

[16:29] <masak> azawawi: oh hai!

[16:30] <s1n> azawawi: it must be summer :)

[16:30] * azawawi prepares to watch the hunt for gollum :)

[16:32] * masak is thinking of wrapping up and going home

[16:33] <masak> s1n: working around actually looks feasible. I might get around to it tonight.

[16:34] <masak> s1n: anyway, thanks for giving November a spin. sorry about the mixed results.

[16:34] * masak blames entropy

[16:35] <azawawi> masak: tonight im going to enable the user to use Rakudo/PGE or STD syntax highlighter in Padre Perl6...

[16:36] <masak> azawawi: you mean you're going to implement choosing between them?

[16:36] <azawawi> masak: yup

[16:36] <masak> azawawi: nice.

[16:36] <masak> good luck.

[16:36] <azawawi> masak: along with ability to choose which runtime to use (mildew/rakudo)... etc

[16:36] <masak> I should really look at that highlighting code, btw.

[16:37] <masak> I want to do cool stuff with Perl 6 ASTs, but haven't figured out how yet.

[16:37] <azawawi> masak: it is on my todo list once i refactor STD_syntax_highlight cron job..

[16:37] * mberends clutches the proto pumpkin tightly as masak prepares to leave

[16:37] <azawawi> masak: to add november, STD and t/spec and perl6 examples...

[16:38] <masak> mberends: it's yours for now.

[16:38] * masak heads home

[16:38] *** masak left
[16:40] *** ZuLuuuuuu joined
[16:46] *** rocket_guatemala joined
[16:48] <rocket_guatemala> Hello, Im adding smart links to the spect tests in pugs, and I started with the S02-builtin_data_types/array_extending.t file

[16:48] <rocket_guatemala> but i can't find a synopsis wich mentions this explicitly

[16:49] <moritz_> rocket_guatemala: have you looked into S09?

[16:49] <rocket_guatemala> yep

[16:49] <rocket_guatemala> my question is, should i just add a smart link to a genera header?

[16:49] <ruoso> jnthn, pong

[16:49] <rocket_guatemala> general header, sorry

[16:50] <moritz_> rocket_guatemala: yes, and write a TODO comment that it needs better spec coverage

[16:50] <rocket_guatemala> where should I add the TODO comment? in the test file?

[16:50] <jnthn> ruoso: I fear I'm missing a point somewhere. :-|

[16:50] <ruoso> jnthn, where?

[16:51] <moritz_> rocket_guatemala: yes

[16:51] <rocket_guatemala> moritz_: great thanks

[16:51] <jnthn> It appears that it's not just that a meta-class can be used with many representations. It's rather than any individual class can.

[16:51] <rocket_guatemala> going back to coding

[16:52] <jnthn> So first up: when I write a class, is it's proto-object always a p6opaque?

[16:52] <moritz_> rocket_guatemala: I assume you have a commit bit already?

[16:52] <rocket_guatemala> morit_: I do, yes, thanks

[16:53] <jnthn> And second: what does it then mean to create an instance with a different representation? Does that representation essentially have to be giving all of the methods and attributes etc of the proto in some kind of copying?

[16:54] <jnthn> And if that is the case, what does that?

[16:56] * jnthn sort of thought he'd understood a lot of this, and then found it all quickly unraveling when he tried to do a concrete implementation of it...

[16:57] <ruoso> jnthn, no... nothing stops you from usign a glib object as an instance of Int

[16:57] <PerlJam> jnthn: the proto-object is always p6opaque unless it's been blessed otherwise.  (as I understand things)

[16:58] <ruoso> PerlJam, the proto-object is p6opaque *by default&

[16:59] <PerlJam> right, that's what I said  :)

[16:59] <PerlJam> bless is the mechanism to change the defualt.

[16:59] <PerlJam> s/ua/au/

[16:59] <jnthn> ruoso: Right, I basically knew that. But the mechanism by which we enable that is confusing me a bit now.

[16:59] <ruoso> that's up to the HOW

[17:00] <ruoso> and that's the reason behind the REPR API

[17:00] <jnthn> ruoso: Do we have to essentially "copy" the set of methods and so forth to the other repr?

[17:00] <ruoso> it depends... in a standard OO

[17:01] <ruoso> you will only install the methods declared directly there in the proto

[17:01] <ruoso> and save the reference to the superclass there as well

[17:01] <pugs_svn> r26711 | moritz++ | [spec] some EOL conversion; set SVN props to avoid that in future

[17:01] <ruoso> but the HOW is the one that will traverse that to find the methods

[17:01] <PerlJam> er, I guess it's really CREATE that determines whether we use a p6opaque or not.   Not bless.

[17:01] <ruoso> yes... CREATE

[17:02] <jnthn> PerlJam: Right. You call CREATE to get a candidate to bless.

[17:02] <jnthn> ruoso: I see your ClassHOW in bless doing things like

[17:02] <jnthn> $candidate.^!methods = ();

[17:02] <jnthn> But I don't see where that gets initialized?

[17:02] <spx2> jnthn: I see you're doing alot of Perl6 presentations ? how does the ratio time_to_develop/time_to_present look ?

[17:03] <ruoso> right... it gets initialized by the compiler

[17:03] <ruoso> by calling add_method

[17:03] <ruoso> add_attribute

[17:03] <ruoso> compose_role

[17:03] *** M_o_C joined
[17:03] <jnthn> oh, hang on

[17:03] <spx2> jnthn: is it  >1 or <1 ?

[17:03] <jnthn>       $candidate.^!isa = $prototype;

[17:03] <jnthn> spx2: It takes longer to prepare than to deliver.

[17:03] <jnthn> spx2: How much longer depends on the level of re-use.

[17:04] *** rocket_guatemala left
[17:04] <jnthn> ruoso: Does that line I pasted above mean that we add to the list of parents?

[17:04] <ruoso> yes

[17:04] <jnthn> erm. Does that not mean that your instances are not really a derived type?

[17:05] <jnthn> Rather than an instance per se?

[17:05] <ruoso> it is an instance as it has instance storage

[17:05] <jnthn> Ok, but basically in the smop world there's not really any such thing as an instance per se?

[17:06] <ruoso> yeah... that's the prototype-oo influence in SMOP

[17:06] <ruoso> there's no fundamental difference between a type and an instance

[17:06] <jnthn> An instance is a representation + storage allocated + the first parent is the type object?

[17:06] <ruoso> yes...

[17:06] <jnthn> Uff. I hadn't quite realized that bit.

[17:06] <ruoso> but nothing stops an instance to have more declarations

[17:06] <ruoso> and in that case it is its own type

[17:07] <ruoso> i.e.: mixins

[17:07] <pugs_svn> r26712 | moritz++ | [t/spec] fix roles smartlinks

[17:08] *** mizioumt1 joined
[17:08] <jnthn> OK.

[17:08] * jnthn needs to think this lot through a bit and see how this might end up looking

[17:09] <moritz_> szabgab: it seems that quotes don't work in header sections of smartlinks...

[17:09] <ruoso> jnthn, basically this is how you have ClassHOW as a HOW, and the types being regular objects

[17:09] <moritz_> szabgab: L<S04/"The lift statement prefix"/ doesn't work, but <S04/The C<lift> statement prefix> works

[17:10] <ruoso> the cool thing about that, is that you could have a XMLRPCHOW that looks for the methods in the prototypes but dispatches them to a remote site

[17:10] <ruoso> as well as 

[17:10] <ruoso> DBIx::Class::HOW

[17:10] <ruoso> which would look for the definitions of the classes in the prototypes

[17:11] <ruoso> but would be actually mapping that to the rdbms of choice

[17:11] <jnthn> Sure, I'd figured out that custom meta-classes were cool. I've been trying to work out the representatiosn side of all of this too.

[17:11] <jnthn> It seems to me that if you're forwarding everything over XMLRPC then your actual representation wouldn't matter so much though?

[17:11] <ruoso> exactly... 

[17:11] <ruoso> but you still need to ask which methods you have and with which parameters

[17:12] <ruoso> and then you ask that to the type objects

[17:13] <szabgab> moritz_, I don't really have time in the next few weeks, you could add these to the smartlinks module with a TODO: comment ?

[17:14] <ruoso> and in the case of the DBIx::Class::HOW, it would use the instance storage to save the local version of the data

[17:14] <jnthn> Yes, true.

[17:19] <moritz_> szabgab: I'll do my best

[17:21] <moritz_> szabgab: I don't grok 03-process-t-file.t... should I just add a verbal description?

[17:21] *** cls_bsd left
[17:24] *** mizioumt left
[17:24] <pugs_svn> r26713 | moritz++ | [Text::Smartlinks] add TODO

[17:25] <szabgab> moritz_, just verbal descr

[17:26] <szabgab> though better to have it in writing ...

[17:29] <pugs_svn> r26714 | moritz++ | [t/spec] fix all but 3 smartlinks

[17:29] <azawawi> szabgab:hi

[17:29] <azawawi> szabgab: did u try the latest Perl6 plugin? :)

[17:31] <pugs_svn> r26715 | moritz++ | [t/spec] remove tests for hash interpolation in regexes (gone from spec)

[17:37] *** amoc left
[17:39] *** amoc joined
[17:44] *** nemstep` joined
[17:45] *** minazo joined
[17:46] *** cognominal left
[17:48] *** nemstep` left
[17:49] *** kane___ left
[17:49] *** nemstep left
[17:50] *** cognominal joined
[17:52] *** nemstep joined
[17:54] *** azawawi left
[18:01] *** kaether left
[18:02] *** cdarroch joined
[18:02] <moritz_> rakudo: regex text { "foo" }; say "foo" ~~ /<text>/

[18:02] <p6eval> rakudo 615936: OUTPUT«Statement not terminated properly at line 1, near "foo\" }; sa"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[18:09] *** abra left
[18:09] *** ejs joined
[18:14] *** yary joined
[18:16] *** rocket_guatemala joined
[18:17] <yary> newb q: how do I get a list to repeat indefinitely, eg what goes on the right to make "say (1,2,3,4,5) >>*>> (0,1,...?)" show (0,2,0,4,0)

[18:17] <pugs_svn> r26716 | rocket++ | Added smart links to array_extending.t

[18:24] <jnthn> yary: I guess (0,1) xx * might do it, but rakudo doesn't have lazy lists just yet so that won't work out so well at the moment. :-)

[18:25] <yary> thanks, I tried that beforehand and got a counter-intuitive result, now I know why!

[18:26] <yary> just reading through the synopses slowly and trying out ideas as I read

[18:27] <yary> oh, it is working in this case-

[18:27] <yary> perl6: say (0,0,0,0,0,0) >>+>> ((1, 2) xx *)

[18:28] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ">>+>>"␤    expecting operator, ":" or ","␤    at /tmp/FwMnNqmHzT line 1, column 19␤»

[18:28] <p6eval> ..elf 26716: OUTPUT«Parse error in: /tmp/yRnq4o3QfQ␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say (0,0,0,0,0,0) >>+>> ((1, 2␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[18:28] <p6eval> ..STD_r...

[18:28] <p6eval> ..rakudo 615936: OUTPUT«Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤000000␤»

[18:28] <yary> huh, it worked on my machine

[18:28] <yary> perl6: say (0,0,0,0,0,0) »+» ((1, 2) xx *)

[18:29] <p6eval> elf 26716: OUTPUT«Unimplemented infix_prefix_meta_operator or infix_circumfix_meta_operator at ./elf_h line 2947␤»

[18:29] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "\187+\187"␤    expecting operator, ":" or ","␤    at /tmp/udRyN7sSl1 line 1, column 19␤»

[18:29] <p6eval> ..rakudo 615936: OUTPUT«Use of uninitialized value␤Non-dwimmy hyperoperator cannot be used on arrays of different sizes or dimensions.␤current instr.: 'die' pc 16547 (src/builtins/control.pir:225)␤»

[18:29] *** pancake left
[18:29] <yary> rakudo: say (0,0,0,0,0,0) »+» ((1, 2) xx *)

[18:29] <p6eval> rakudo 615936: OUTPUT«Use of uninitialized value␤Non-dwimmy hyperoperator cannot be used on arrays of different sizes or dimensions.␤current instr.: 'die' pc 16547 (src/builtins/control.pir:225)␤»

[18:29] <yary> I'm getting "121212" as a result locally

[18:30] <yary> but when I quit rakudo and restart it, I get a different answer! hmmm

[18:31] <yary> rakudo: my @x=(11,22,33); say @x[*-1]; say (0,0,0,0,0,0) >>+>> ((1, 2) xx *)

[18:31] <p6eval> rakudo 615936: OUTPUT«33␤121212␤»

[18:31] <yary> put that in your pipe and smoke it

[18:34] *** rocket_guatemala left
[18:35] <Infinoid> nice

[18:35] <jnthn> Heh, I didn't know that works. :-)

[18:37] <yary> It only works after the fiddling with @x, otherwise the last "say" returns :Use of uninitialized value (x6) 000000

[18:39] <PerlJam> crazy

[18:40] <jnthn> Indeed.

[18:41] <jnthn> That sounds very odd.

[18:41] <PerlJam> It's the *-1 that does something to make it work.

[18:42] <PerlJam> well, @x[*-1]  (I guess a *-1 by itself won't help  ;-)

[18:43] <jnthn> Ah, that's believable.

[18:46] <PerlJam> yary: did you rakudobug it?

[18:48] *** alester joined
[18:48] *** M_o_C left
[18:55] *** mizioumt1 left
[18:58] <pugs_svn> r26717 | jnthn++ | [t/spec] Tests for .WALK.

[19:00] <yary> I will

[19:01] <yary> lunch break at the moment

[19:03] <pugs_svn> r26718 | jnthn++ | [t/spec] Improve description.

[19:14] *** cognominal left
[19:20] *** donaldh left
[19:20] *** donaldh joined
[19:23] <yary> submitted

[19:23] <yary> it got stranger

[19:23] *** cognominal joined
[19:24] <yary> rakudo: my @x=(9); say @x[*-1]; say (0,0,0,0,0,0) >>+>> ((1,2) xx *)

[19:24] <p6eval> rakudo 615936: OUTPUT«9␤122222␤»

[19:24] <yary> rakudo: my @x=(7,8); say @x[*-1]; say (0,0,0,0,0,0) >>+>> ((1,2) xx *)

[19:24] <p6eval> rakudo 615936: OUTPUT«8␤121222␤»

[19:24] <yary> rakudo: my @x=(4,5,6); say @x[*-1]; say (0,0,0,0,0,0) >>+>> ((1,2) xx *)

[19:24] <p6eval> rakudo 615936: OUTPUT«6␤121212␤»

[19:25] <yary> that's the bug report

[19:25] <yary> sent it in

[19:26] <moritz_> scary.

[19:26] <PerlJam> whoa.   That *is* strange

[19:26] <PerlJam> But I can kinda see how it would happen.

[19:28] <jnthn> IIRC *-1 is handled rather specially at the moment.

[19:28] <jnthn> And thus some stuff is working "accidentally".

[19:32] <dalek> rakudo: 06e2f1d | jnthn++ | src/parrot/ClassHOW.pir:

[19:32] <dalek> rakudo: When generating parents list, need to stop at Perl 6's Object.

[19:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/06e2f1d2d94db42630bb2354a749be7eeb980423

[19:32] <dalek> rakudo: 194b524 | jnthn++ | src/setting/Object.pm:

[19:32] <dalek> rakudo: Fill out the implementation of .WALK such that it passes all of S12-introspection/walk.t.

[19:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/194b524fee6adf282440768f376f724caff1acb0

[19:32] <dalek> rakudo: 6db88b0 | jnthn++ | t/spectest.data:

[19:32] <dalek> rakudo: Add S12-introspection/walk.t.

[19:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6db88b0fb26dc84c925bc9792688354d8e01907a

[19:45] *** mizioumt joined
[19:46] <jnthn> EURGH that tea is *cold* :-/

[19:46] * jnthn should keep _one_ mug on this desk at a time.

[19:52] * ruoso .oO ( cold tea is not as bad as cold cofee )

[19:53] <PerlJam> cold sweet tea is actually quite good.

[19:53] *** yary left
[19:54] <jnthn> ruoso: True.

[19:54] <jnthn> PerlJam: Yeah, some tea is good cold. Not this sort.

[19:55] * jnthn drinks coffee by morning, tea by afternoon, and beer by evening.

[19:56] <jnthn> If I drink coffee too late on in the day, I have trouble sleeping.

[19:56] <jnthn> OTOH, if I don't drink coffee early on in the day I have trouble doing anything. :-)

[19:57] * PerlJam always drinks tea at night

[19:57] <PerlJam> that might be why I sometimes have trouble sleeping :)

[19:59] <jnthn> If tend to go for green or fruit teas rather than black tea, so less caffeine.

[20:00] *** bacek_ joined
[20:01] * jnthn takes dinner break; more Perl 6 hacking soon.

[20:01] <PerlJam> I need to find a good place to buy real green tea.  The local markets here have something called "green tea" but it's nothing like the green teas I'm used to drinking

[20:01] *** Kisu joined
[20:01] *** bacek left
[20:10] *** avar is now known as cabin

[20:11] *** cabin is now known as serendipity

[20:15] *** serendipity is now known as avar

[20:19] *** ruoso left
[20:38] *** amoc left
[20:42] *** amoc joined
[20:53] *** ejs left
[20:54] *** alester left
[21:22] *** mberends left
[21:32] *** skids left
[21:43] *** mizioumt1 joined
[21:44] *** Whiteknight joined
[21:45] *** mizioumt left
[21:57] <pugs_svn> r26719 | lwall++ | [STD] split gobbling message to both before and after globbled block

[22:05] *** hudnix left
[22:06] *** mizioumt joined
[22:12] *** mizioumt2 joined
[22:13] *** iblechbot left
[22:18] <TimToady> std: for map {...}, lines {...};

[22:18] <p6eval> std 26719:  ( no output )

[22:20] *** mizioumt1 left
[22:21] <moritz_> sh: line 1: 20667 CPU time limit exceeded /usr/bin/perl tryfile /tmp/Gzrvw40wnX >> /tmp/LOYjRoTuw2 2>&1

[22:21] <moritz_> there's a lot of strain on the server right now :(

[22:21] <moritz_> std: for map {...}, lines {...};

[22:21] <p6eval> std 26719: OUTPUT«##### PARSE FAILED #####␤Function 'lines' needs parens to avoid gobbling block at /tmp/haeUnR3ByV line 1:␤------> for map {...}, lines {...};␤Missing block (apparently gobbled by 'lines') at /tmp/haeUnR3ByV line 1:␤------> for map {...}, lines {...};␤

[22:21] <p6eval> .....

[22:23] *** hudnix joined
[22:25] *** rocket_guatemala joined
[22:26] <pugs_svn> r26720 | rocket++ | Added smartlinks to test files.

[22:26] *** payload left
[22:27] * jnthn afk; Rakudo day tomorrow. :-)

[22:27] *** mizioumt left
[22:31] *** exodist left
[22:34] *** rocket_guatemala left
[22:39] *** Whiteknight left
[22:42] *** Whiteknight joined
[22:53] *** nihiliad left
[23:20] *** donaldh left
[23:20] *** donaldh joined
[23:28] *** eternaleye joined
[23:31] *** mizioumt2 left
[23:32] *** skids joined
[23:38] *** amoc left
[23:39] *** fridim left
[23:51] *** eternaleye left
[23:53] *** DemoFreak left
