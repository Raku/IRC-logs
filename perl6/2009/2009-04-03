[00:00] <mncharity> I keep wondering if elf should have been switched earlier to multiple dispatch.  Things would be much cleaner.  But while elfcl would be fine with it (already is multis everywhere), the elfp5 hit is just not happy.  With a cached parse, elf recompiles itself in 10 sec.  To test a bootstrap, you do that 3 times.  Bumping 30 s to maybe something vaguely like 45 s just to use multis... sigh.

[00:00] <jnthn> Speed - sure, we don't have a performance focus just yet, I'll agree there.

[00:00] <jnthn> And multiple dispatch - Rakudo I think by now it's fair to say has the most complete implementation of this out of all the implementations.

[00:00] <mncharity> nod

[00:01] <jnthn> Actually multi dispatch is one plase we do consider performance more.

[00:01] <jnthn> We have a cache in place there, for example.

[00:02] <Tene> what's the reason for multiple backends in elf?

[00:03] <mncharity> phone

[00:03] <jnthn> I'm uncomfortable with digging into working on the Rakudo optimizer just yet because I don't think we have enough test coverage or a full enough idea of feature interactions to be able to safely develop one.

[00:03] <jnthn> Of course, that's a separate issue to the parser speed, which is going to improve lots in the near future.

[00:05] <skids> jnthn: any ideas on my question above -- how to getthe equivalent of a .param string in inline PIR?

[00:05] <jnthn> skids: tbh I didn't quite follow what you were trying to do, sorry.

[00:05] <jnthn> Can you give me a slightly higher-level idea of what you're aiming for?

[00:06] <skids> I was trying to use the in-place substitution form of the substr op.

[00:06] <skids> But I could not get an S register to refer to the original string, only ever copies of it.

[00:06] *** kulp joined
[00:07] *** kulp left
[00:07] <jnthn> Ah, was this to try and implement lvalue substr in Perl 6?

[00:07] <skids> No, actually for some private stuff where I need buf but don't have it yet.

[00:08] <jnthn> ah, OK

[00:08] <jnthn> Hmm

[00:08] <jnthn> I suspect you'll ahve to pull it out, operate on it, then $P0 = $S0 on it to put the string back into the Str again.

[00:08] <jnthn> Hmm. Seems like Buf is kinda wanted...

[00:10] <skids> Well, I certainly want it but I don't know if anyone else is chafing on that yet.

[00:11] <jnthn> I think masak mentioned it recently.

[00:13] <skids> Without at least buf, It's sorta like playing with a big set of legos when you're used to an erector set :-)

[00:13] <jnthn> ;-)

[00:14] <jnthn> I'll try and keep in mind that you want buf. Maybe I can give it some tuits soon.

[00:15] <skids> if you leave breadcrumbs I MIGHT be able to figure out how to add some of the "native" types.  But no promises I'm fairly incompetent :-)

[00:16] <jnthn> tbh I didn't think too hard about some of that yet myself

[00:16] <jnthn> But I'm certainly happy to delegate implementation work. :-)

[00:22] <jnthn> OK, sleep time, night all

[00:22] <skids> n8

[00:23] <wayland76> 'night

[00:24] * skids not getting auth to pugs svn to work.

[00:24] <skids> Changed my password to be sure, but feather doesn't seem to know me.

[00:29] <mncharity> back, sorry

[00:30] <mncharity> ah, bummer.

[00:30] <mncharity> jnthn:  g'night.  thanks for the conversation

[00:31] <mncharity> Tene: you had a couple of questions, let's see..

[00:34] <mncharity> re IR analysis?, eg, type and dataflow analysis.  eg, can I make this call uncontainerized and unboxed, or does it need a full Closure, or... .

[00:36] <mncharity> so not trying to replace say CL's compiler smarts and optimization, let alone anything remotely haskellish, but basic "I the compiler understand at least a little about p6, and so I know I don't have to do this little bit the hard/slow/general way".

[00:36] <Tene> No, rakudo doesn't do any of that currently, but there are certainly plans for it eventually.

[00:39] <mncharity> right.  so apropos the 'what might be lost by punting elf' question, elf knew up front that fast was critical, so IR analysis was needed now rather than later.  It's still an ugly rev 0, which, for instance, deals very very poorly with tree rewrites after analysis begins.   Vision was, get it started, others will sketch in something better.  First part happened...

[00:39] <mncharity> re, let's see...

[00:41] <mncharity> pigeon search capabilities--

[00:44] <mncharity> re "what's the reason for multiple backends in elf?", different backends have different capabilities.  elfp5 compiles fast.  let's you suck in cpan modules.  include bits of p5 code.  elfcl has a real compiler.  multis are fast.  there's a clear optimization path to 10x+ p5 speed.  the oo system is designed to permit swapping in something like p6's instance based oo.  might even manage smop like low level ops.

[00:44] <mncharity> real debugger (SLIME is quite nice on elfcl).

[00:47] <mncharity> elfcl regexps are often faster than p5's, and eventual regexs, especially STD.pm like things with lots of embedded code, will blaze on CL, faster than anything that will be managed on p5.

[00:47] <Tene> but... for a real implementation you'll need everything in one backend anyway

[00:48] <mncharity> maybe a threaded jit javascript with regexp vm instructions might match it (webkit), but otherwise.

[00:48] <mncharity> yes, but...

[00:48] *** Cybera left
[00:48] *** Khisanth left
[00:51] <mncharity> just as jruby and C ruby address different needs, and python, ironpython, and the various others, there will eventually be a jperl6, a jsperl6, and it seems likely a CL perl6, and a haskell perl6.  each will have beyond spec capabilities the others lack, and each will have strengths and weaknesses with spec.

[00:52] <mncharity> the reason I expect p6 will get a CL backend, despite neither ruby or python having one, is p6 has a compile-time story which makes it worth while.  there's not much you'd be able to do with a real compiler on ruby and python.  so you're left with only jit.

[00:55] <mncharity> jit is getting quite good.  arguably will displace compilation for many things.  but... it's still just jit.  it removes abstraction costs but doesn't understand large scale program structure enough to say "and here you don't have to even bother", let alone "I've looked at your grammar, note it can be wizzily implemented as an LALR(1) parser, and have silently built one for you".

[00:56] *** nihiliad joined
[00:58] <mncharity> so for now, its back to the "what is the goal" thing.  If you feel the need to write non-small p6 now, backends give you a way to deal with "I really need to use a p6 regex engine faster than p5's regexp engine".  or whatever.  and long term, you are going to want the though that went into the assorted runtimes anyway.

[01:00] <pmichaud> one comment from scrollback

[01:00] <pmichaud> 23:24 <mncharity> I don't know how well rakudo is set up to do IR analysis.  My impression is it's mostly direct-to-pir,

[01:00] <pmichaud> that's categorically not true.

[01:01] <pmichaud> rakudo goes first to an abstract syntax tree representation, which then goes to an opcode representation, which then goes to pir, which then goes to bytecode

[01:01] <pmichaud> there's room (and hooks) for optimization at the parse tree, abstract syntax tree, opcode tree, pir, and bytecode levels

[01:02] <pmichaud> indeed, part of the point of having a common-ish abstract syntax tree representation at the parrot level is that multiple languages can take advantage of optimizations that take place at the higher "what is this code doing" levels.

[01:03] <mncharity> and compared to rakudo/parrot, these are all very low cost endeavors.  iblech wrote the pugs js backend, much of it in a couple of weeks.  the pugs p5 backend was me and fglock, and similar.  elf is me, and dealing with parsing has been far more pain than the backends.

[01:03] * mncharity reads comment from scrollback...

[01:03] *** eternaleye joined
[01:04] <mncharity> nod.  great.

[01:04] <pmichaud> yes, things can be much simpler if one goes with an existing backend instead of creating a new one.

[01:04] <mncharity> i sit corrected :)

[01:04] <pmichaud> for whatever reason, the perl 6 design team chose not to take that path.

[01:04] <mncharity> (and puzzled by the last line)

[01:04] <mncharity> err, second to last

[01:04] <pmichaud> sorry, I think we had a cross-conversation there.

[01:05] <mncharity> :)

[01:05] <pmichaud> I was responding to "backends in a couple of weeks".  Yes, that's easier when there's a robust backend already in place.

[01:06] <mncharity> ah, so building on CL/js/whatever rather than building a vm?

[01:07] <mncharity> the cost argument was just part of the reply to Tene, "why backends?".  A: you get capabilities, and it's not very expensive.

[01:07] <pmichaud> ah, understood.

[01:08] <mncharity> the  nod.  great. i sit corrected :)  were pointed at the parrot IR analysis.

[01:08] <mncharity> :)

[01:08] <pmichaud> right -- I caught that.

[01:08] <pmichaud> I think I crossed the streams.  :-)

[01:09] <mncharity> lol

[01:09] <pmichaud> have to go help son with his homework -- be back later.

[01:09] <mncharity> (image of stream crossing via log/allegator hopping from some vid game seen recently comes to mind)

[01:10] <mncharity> cheers.  thanks for the conversations and help.

[01:10] <mncharity> Tene, anyone: I think I dropped some questions as they went by.  please feel free to reraise.

[01:13] <mncharity> hmm... reraise... resumable execeptions are something unlikely to be seen outside of a CL or scheme backend.  Ie, error is thrown, you catch it, fiddle with things at the point where it was raised, _and then resume execution_.  :)   sigh, I miss lispms.

[01:13] *** abc joined
[01:15] <skids> mcharity: the videogame would have been "frogger"

[01:16] <mncharity> ok, so I need to fiddle with the status report.  sigh.  it's so easy when you don't have external deadlines to put things off until tomorrow, rather than just ripping at things and going with "good enough" crud.

[01:16] <mncharity> skids: yeah, that's it. :)  still don't remember context though. ah well.

[01:16] <mncharity> thanks :)(

[01:17] <mncharity> s/\(/

[01:17] <skids> Probably daily show, with a sombrero.

[01:17] <mncharity> that's it. :)

[01:17] <mncharity> thank you hulu.

[01:18] <cxreg> speaking of: http://www.engadget.com/2009/04/01/hulu-begins-encrypting-html-content-to-thwart-non-browser-apps/

[01:19] <skids> mmm. brains.

[01:19] <mncharity> sigh

[01:20] *** abc left
[01:20] *** abc joined
[01:21] *** abc left
[01:23] <mncharity> so one take on my wondering about rakudo is, is rakudo no longer just another pugs - nice to have, but due to hard internal characteristics, not something which will directly help with building xmas.  something like that.

[01:24] <mncharity> hmm, and since performance is a critical part of the latter, it can't yet be.

[01:24] <mncharity> so the next question is,

[01:25] <mncharity> should elf be put on hold for a quarter, either because I'm tired of working solo, or it removes a distraction from community focus on rakudo, or a 3 mo hit is cheap and can reeval rakudo then, or... whatever.

[01:26] *** disismt1 joined
[01:26] <mncharity> hmm, but the only immediate issue is what to write in the status report re current state, and my thoughts on which way to go.

[01:27] <mncharity> that's easier.

[01:27] *** disismt1 left
[01:28] <mncharity> as an example of what elf could provide, while writing an rx engine in p6 is probably something which would still be painful to do in rakudo, it would be easily done in elf.  and if someone did that now, pm wouldn't have to n months from now.

[01:29] <mncharity> ah well, end of day.

[01:29] <mncharity> thanks all.

[01:29] *** mncharity left
[01:56] *** kidd` joined
[02:18] <Tene> mncharity: Parrot has resumable exceptions.

[02:18] <Tene> Oh, he's gone

[02:18] <Tene> and ENOPURL

[02:19] *** Limbic_Region left
[02:20] *** dKingston left
[02:24] *** davidad joined
[02:24] *** davidad left
[02:25] *** davidad joined
[02:25] *** davidad left
[02:29] * skids ponders why jnthn's rakudo.org is always last modified "6 min 27 sec" ago no matter how many times he reloads.

[02:30] <skids> erm jnthns rakudo.org post, that is.

[02:31] <skids> Oh it must update on hours server-side.

[02:46] *** alc joined
[02:52] <skids> rakudo: "\c[GREEK RHO SYMBOL]\c[COPTIC SMALL LETTER SHIMA]".say

[02:52] <p6eval> rakudo 913094: OUTPUT«ϱϭ␤»

[02:53] <skids> rakudo: "\c[GREEK RHO SYMBOL]\c[COPTIC CAPITAL LETTER SHIMA]".say

[02:53] <p6eval> rakudo 913094: OUTPUT«ϱϬ␤»

[02:58] <skids> rakudo: my $case = "CAPITAL"; "\c[GREEK RHO SYMBOL]\c[COPTIC $case LETTER SHIMA]".say

[02:58] <p6eval> rakudo 913094: OUTPUT«perl6regex parse error: Unrecognized character name COPTIC $case LETTER SHIMA at offset 46, found 'C'␤current instr.: 'parrot;PGE;Perl6Regex;parse_error' pc 10552 (compilers/pge/PGE/Perl6Regex.pir:1323)␤»

[02:58] <skids> Yeah didn't think so.

[03:05] *** davidad joined
[03:07] *** c9s_ joined
[03:15] *** alester joined
[03:35] *** justatheory left
[03:45] *** nihiliad left
[03:59] *** payload1 left
[03:59] *** payload joined
[04:01] *** wayland76 joined
[04:06] <wayland76> Nice try with the variables in characters

[04:07] <wayland76> my $case = "CAPITAL"; $test = "'\c[GREEK RHO SYMBOL]\c[COPTIC $case LETTER SHIMA]'.say"; $test.eval

[04:07] <wayland76> rakudo: my $case = "CAPITAL"; $test = "'\c[GREEK RHO SYMBOL]\c[COPTIC $case LETTER SHIMA]'.say"; $test.eval

[04:07] <p6eval> rakudo 913094: OUTPUT«perl6regex parse error: Unrecognized character name COPTIC $case LETTER SHIMA at offset 55, found 'C'␤current instr.: 'parrot;PGE;Perl6Regex;parse_error' pc 10552 (compilers/pge/PGE/Perl6Regex.pir:1323)␤»

[04:08] <wayland76> rakudo: my $case = "CAPITAL"; $test = '"\c[GREEK RHO SYMBOL]\c[COPTIC $case LETTER SHIMA]".say'; $test.say

[04:08] <p6eval> rakudo 913094: OUTPUT«Scope not found for PAST::Var '$test' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[04:08] <wayland76> rakudo: my $case = "CAPITAL"; my $test = '"\c[GREEK RHO SYMBOL]\c[COPTIC $case LETTER SHIMA]".say'; $test.say

[04:08] <p6eval> rakudo 913094: OUTPUT«"\c[GREEK RHO SYMBOL]\c[COPTIC $case LETTER SHIMA]".say␤»

[04:08] <wayland76> rakudo: my $case = "CAPITAL"; my $test = "\"\c[GREEK RHO SYMBOL]\c[COPTIC $case LETTER SHIMA]\".say"; $test.say

[04:08] <p6eval> rakudo 913094: OUTPUT«perl6regex parse error: Unrecognized character name COPTIC $case LETTER SHIMA at offset 59, found 'C'␤current instr.: 'parrot;PGE;Perl6Regex;parse_error' pc 10552 (compilers/pge/PGE/Perl6Regex.pir:1323)␤»

[04:09] <wayland76> rakudo: my $case = "CAPITAL"; my $test = "\"\\c[GREEK RHO SYMBOL]\\c[COPTIC $case LETTER SHIMA]\".say"; $test.say

[04:09] <p6eval> rakudo 913094: OUTPUT«"\c[GREEK RHO SYMBOL]\c[COPTIC CAPITAL LETTER SHIMA]".say␤»

[04:09] <wayland76> rakudo: my $case = "CAPITAL"; my $test = "\"\\c[GREEK RHO SYMBOL]\\c[COPTIC $case LETTER SHIMA]\".say"; $test.eval

[04:09] <p6eval> rakudo 913094: OUTPUT«Method 'eval' not found for invocant of class 'Perl6Str'␤current instr.: 'parrot;P6metaclass;dispatch' pc 637 (src/classes/ClassHOW.pir:161)␤»

[04:09] <wayland76> bah :)

[04:09] <wayland76> rakudo: my $case = "CAPITAL"; my $test = '"\\c[GREEK RHO SYMBOL]\\c[COPTIC $case LETTER SHIMA]".say'; $test.eval

[04:10] <p6eval> rakudo 913094: OUTPUT«Method 'eval' not found for invocant of class 'Str'␤current instr.: 'parrot;P6metaclass;dispatch' pc 637 (src/classes/ClassHOW.pir:161)␤»

[04:10] <wayland76> rakudo: my $case = "CAPITAL"; my $test = '"\\c[GREEK RHO SYMBOL]\\c[COPTIC $case LETTER SHIMA]".say'; $test.say

[04:10] <p6eval> rakudo 913094: OUTPUT«"\c[GREEK RHO SYMBOL]\c[COPTIC $case LETTER SHIMA]".say␤»

[04:10] <wayland76> rakudo: my $case = "CAPITAL"; my $test = "\"\\c[GREEK RHO SYMBOL]\\c[COPTIC $case LETTER SHIMA]\".say"; $test.say

[04:10] <p6eval> rakudo 913094: OUTPUT«"\c[GREEK RHO SYMBOL]\c[COPTIC CAPITAL LETTER SHIMA]".say␤»

[04:10] <wayland76> rakudo: my $case = "CAPITAL"; my $test = "\"\\c[GREEK RHO SYMBOL]\\c[COPTIC $case LETTER SHIMA]\".say"; $test.eval

[04:10] <p6eval> rakudo 913094: OUTPUT«Method 'eval' not found for invocant of class 'Perl6Str'␤current instr.: 'parrot;P6metaclass;dispatch' pc 637 (src/classes/ClassHOW.pir:161)␤»

[04:10] <wayland76> Anyway, that's probably as good as it's going to get

[04:11] <wayland76> rakudo: my $case = "CAPITAL"; my $test = "\"\\c[GREEK RHO SYMBOL]\\c[COPTIC $case LETTER SHIMA]\".say"; eval $test

[04:11] <p6eval> rakudo 913094: OUTPUT«ϱϬ␤»

[04:11] <wayland76> There you go :)

[04:12] <wayland76> skids: am I right in presuming you're no longer working on S17?

[04:18] *** payload left
[04:27] *** iblechbot joined
[04:28] *** kulp joined
[04:42] *** justatheory joined
[04:53] *** bacek_ left
[04:57] *** vinay left
[05:12] *** justatheory left
[05:39] *** iblechbot left
[05:47] *** Tene_ joined
[05:51] *** alester left
[05:51] *** alc left
[05:55] *** c9s_ left
[05:59] *** DemoFreak joined
[06:18] *** kimtaro joined
[06:26] *** M_o_C joined
[06:26] *** kulp left
[06:26] *** Kisu joined
[06:27] *** DemoFreak left
[07:45] <Matt-W> Morning

[07:50] <dukeleto> mornin'

[07:54] *** masak joined
[07:58] <masak> greetings, fellow Perl Sixers.

[07:58] <masak> (especially all M people.)

[08:01] <moritz_> but we don't want to discriminate against the w and d people :-)

[08:02] <masak> of course not.

[08:02] <masak> in fact, we're very tolerant towards people whose nicks start with other letters of the alphabet.

[08:02] <masak> we even encourage it.

[08:04] <Matt-W> :)

[08:05] *** plu joined
[08:06] * masak finished writing the tests for Druid

[08:07] <masak> and I still have this enthusiasm over Test::Ix that I haven't been able to explain to anyone.

[08:09] <Matt-W> What's Test::Ix?

[08:09] * Matt-W is still abusing templates like crazy

[08:13] <masak> Matt-W: Test::Ix is a testing... thingie... that I wrote for the tests in Druid.

[08:14] <masak> it encourages this kind of workflow: list all the tests you want to write, hierarchically.

[08:14] <masak> use a little script to generate empty subs for you. each sub contains a failing test with the correct description.

[08:14] <masak> write the tests, one by one.

[08:15] <masak> whenever you realize you need additional tests, add them to the hierarchical index and run the script again.

[08:17] <masak> the result can be seen in t/01-game-rules.t in the druid repo.

[08:18] <masak> I'd link to it on github, but github seems broken in some way today.

[08:20] <eiro> hello world 

[08:21] <masak> eiro: oh hai

[08:27] <eiro> in the perl6 doc, i try to figure out what's the $$ at the end of the grammar rules 

[08:27] <eiro> any link to another doc ? 

[08:27] <moritz_> S05

[08:27] <moritz_> it means 'end of line'

[08:28] <moritz_> rakudo: say  "a\nb" ~~ m/ a $$ /

[08:28] <p6eval> rakudo 913094: OUTPUT«a␤»

[08:28] <moritz_> rakudo: say  "ac\nb" ~~ m/ a $$ /

[08:28] <p6eval> rakudo 913094: OUTPUT«␤»

[08:28] <moritz_> rakudo: say ?( "ac\nb" ~~ m/ a $$ / )

[08:28] <p6eval> rakudo 913094: OUTPUT«0␤»

[08:29] <eiro> lol .. i known it but i tried to understand it as a variable

[08:29] <eiro> thx moritz_ 

[08:32] <moritz_> most punctuation variables went away

[08:32] <moritz_> only $!, $/ and $_ remains

[08:32] *** ejs joined
[08:33] <moritz_> s/s$$//

[08:33] *** DemoFreak joined
[08:34] <masak> :)

[08:34] <masak> well, and @_ and %_

[08:34] <eiro> i read it ... but i write per5 every day so i have a lot of bad habits 

[08:36] <eiro> is there a way to get/set an handler that is launched at the end of a rule ? 

[08:36] <moritz_> {*}

[08:36] <eiro> i mean : rule marc_dump { <marc_record>* } ... 

[08:37] <eiro> ohhh ... like in perl6 grammar ! i have to view the jnthn talk about it

[08:37] <eiro> thx moritz_ 

[08:37] *** mikehh joined
[08:37] <masak> people sure like those action markers.

[08:38] <masak> ihrd and I have an unresolved problem relating to those and November's HTML::Template.

[08:38] <masak> we think maybe pmichaud can provide some guidance, but I haven't asked him about it yet.

[08:44] <moritz_> http://www.perlmonks.org/?node_id=755196 # asks for perl 6 solution as well

[08:46] *** c9s joined
[08:51] *** iblechbot joined
[08:55] *** pmurias joined
[08:57] <masak> should be able to use classify there somehow...

[08:59] <moritz_> yes, included that in my answer

[08:59] <moritz_> %h = $in.classify: { $_ };

[08:59] <masak> moritz_++

[09:00] <moritz_> actually it might even work with .classify: *; :-)

[09:00] <moritz_> but I'm not sure

[09:01] <masak> I suppose the push-on-empty-hash-bucket-fails problem has been RT ticketed long ago...?

[09:01] *** DemoFreak left
[09:02] <moritz_> I suppose so

[09:02] <moritz_> what we really need is a spec

[09:02] <moritz_> ie a list of methods and what they autovivify to

[09:03] <moritz_> eg push, unshift autoviv to Array

[09:03] <moritz_> ++ and -- to Int

[09:03] <moritz_> etc

[09:03] <masak> let's just write something somewhere, and let the Magic of Community unfold it into something beautiful :)

[09:07] <masak> only question is "where?".

[09:07] <masak> S09?

[09:08] <masak> probably, under "Autovivification". http://perlcabal.org/syn/S09.html#Autovivification

[09:08] <moritz_> S12 has a section Autovivifying objects

[09:08] <moritz_> hm, S09 looks better

[09:09] <masak> aye.

[09:10] <moritz_> masak: are you doing it?

[09:11] <masak> moritz_: in a while, I am.

[09:11] <moritz_> masak: ok

[09:11] <masak> just doing some $WORK first, to ail my conscience. :)

[09:11] *** sri_kraih joined
[09:16] *** PZt left
[09:17] *** NoirSoldats joined
[09:21] *** Helios joined
[09:24] <wayland76> I'm wondering if the autovivification stuff doesn't belong in S32?

[09:24] <wayland76> ie. under Array.push, document what it autovivifies to

[09:25] <wayland76> Anyway, food time for me

[09:26] <moritz_> wayland76: no, it's Failure.push or Object.push or so that does the autovivificatioin

[09:33] *** bacek joined
[09:42] <ruoso> moritz_, wayland76, actually, the autovivification uses a lazy object 

[09:42] <ruoso> It's still not clear what triggers the autovivification

[09:42] <ruoso> but basically

[09:43] <ruoso> @a[0] will return an object that is a lazy lookup

[09:43] <lambdabot> Unknown command, try @list

[09:44] <ruoso>  @a[0][1] will cause an attempt to collapse the lazy lookup

[09:44] <moritz_> ruoso: yes, it's specced that assigning to that does the autoviv...

[09:44] <ruoso> moritz_, yes... right... but autovivification is not only to arrays and hashes

[09:45] <ruoso> it applies to any object

[09:45] <ruoso> we know that assigning is one of those things that should cause autovivification

[09:45] <ruoso> but how it triggers the autovivification is still unclear

[09:45] <moritz_> ruoso: but what's missing is a list of method that cause autoviv

[09:45] <ruoso> not really, since S12 seems to imply that an arbitrary method can autovivificate

[09:46] <moritz_> ruoso: but to what?

[09:46] <ruoso> my $dog = Dog{ name => 'fido' };

[09:46] <ruoso> say 'undefined' if not defined $dog; 

[09:46] <ruoso> # it says it

[09:46] <ruoso> $dog.wag();

[09:46] <ruoso> # dog is autovivified

[09:47] <moritz_> that doesn't answer my question

[09:47] <ruoso> what do you mean then?

[09:47] <moritz_>  @a[0].foo # if that autovivifies @a[0], to an object of which type?

[09:48] <ruoso> of the type @a[0] created

[09:48] <moritz_> Object?

[09:48] <moritz_> please don't

[09:48] <moritz_> @a[0].push: $foo; # should create an Array

[09:48] <ruoso> that's the point that is unclear in the spec yet

[09:48] <lambdabot> Unknown command, try @list

[09:49] <moritz_> that's what masak++ wants to change

[09:49] <ruoso> it seems that @a[0] needs a special whatever-like type

[09:49] <ruoso> that can mutate itself, depending on how it is used

[09:50] <masak> what about this? my $something; $something.push(5)

[09:50] <ruoso> that's a plain failure

[09:50] <masak> why? what's the difference?

[09:50] <masak> it's not in a data structure?

[09:50] <ruoso> the difference is that @a[0] is the one doing the magic

[09:51] <masak> I'm looking for the underlying philosophical difference.

[09:51] <ruoso> the method postcircumfix:<[ ]> returns a special lazy object

[09:51] <masak> ok.

[09:52] <masak> I see.

[09:52] <ruoso> maybe it is a special lazy object, that when used as an array, creates an array in the target object, and start proxying all the calls to it

[09:53] <masak> sounds like an abstraction that might easily leak.

[09:53] <ruoso> and when used as a hash, creates a hash in the target object, and start proxying all the calls to it

[09:53] <ruoso> masak, that only exists in the process of autovivificating the value

[09:53] <moritz_> maybe we need functions (not methods) that handle autovivification

[09:53] <ruoso> after that, once you try to access it, you'll get the actual value

[09:53] <masak> ruoso: ok. fair enough.

[09:53] <moritz_> I have a spark of an idea, I'll try to think about it during lunch

[09:54] <ruoso> SMOP already has a related concept, which is the bvalue

[09:54] <ruoso> the bvalue is this special lazy object I'm talking about

[09:55] <ruoso> it still doesn't know how to do this deep autovivification...

[09:55] <ruoso> but first-level autovivification is already there...

[09:55] <ruoso> i.e. Hash of Scalar

[09:56] * ruoso commute &

[09:59] <masak> I've started hanging out on PerlMonks more lately. it's amazing how people don't try to reduce their code snippets to a bare minimum.

[09:59] <masak> I always figured that the smaller the code snippet, the more people will read it and try to help you.

[09:59] <moritz_> aye

[10:00] *** Helios left
[10:01] *** Helios joined
[10:06] *** payload joined
[10:13] *** pjcj joined
[10:13] *** ludan joined
[10:26] *** SamB joined
[10:34] *** c9s_ joined
[10:34] *** DemoFreak joined
[10:35] *** ludan left
[10:39] *** bacek left
[10:44] *** ludan joined
[10:44] *** ludan left
[10:44] *** bacek joined
[10:45] *** ludan joined
[10:45] *** ludan left
[10:52] *** c9s left
[10:55] *** pmurias left
[11:00] *** ruoso joined
[11:01] * ruoso back

[11:04] *** riffraff joined
[11:06] *** payload left
[11:11] *** NoirSoldats left
[11:13] <ruoso> moritz_, masak, thinking about a bit more... I think Array/Hash autovivification is actually unrelated with Object autovivification

[11:13] <ruoso> S09 autoviv can be implemented with a smart proxy object, and, actually, I think that's the only way to do it...

[11:13] *** NoirSoldats joined
[11:14] <ruoso> S12 autoviv requires you to predefine which type you want autovivified, so it doesn't really match with S09 autoviv

[11:14] <ruoso> as a reference, take a look at smop hash_bvalue... it already implements an interesting part of that...

[11:19] *** meppl joined
[11:21] *** SamB left
[11:28] <masak> ruoso: ok, nice.

[11:29] <masak> ruoso: so I'll add something to S09, then, about Arrays, Hashes and Ints autovivifying.

[11:29] *** cognominal joined
[11:35] *** skids left
[11:35] *** clintongormley joined
[11:41] *** SamB joined
[11:46] *** [particle]1 joined
[11:51] *** kimtaro left
[11:51] *** kimtaro joined
[11:52] *** kimtaro left
[12:25] *** davidad left
[12:29] *** skids joined
[12:37] *** masak left
[12:42] *** kimtaro joined
[12:50] *** kulp joined
[12:50] *** kulp left
[12:56] *** riffraff left
[12:58] *** mberends joined
[13:09] *** ejs1 joined
[13:09] <TimToady> surely Arrays and Hashes already know what kind of container to autoviv, if only Scalar

[13:09] <lambdabot> TimToady: You have 1 new message. '/msg lambdabot @messages' to read it.

[13:15] *** moritz_ sets mode: +oo TimToady ruoso

[13:15] *** c9s joined
[13:17] <ruoso> TimToady, do they ?

[13:19] *** ejs left
[13:19] *** c9s left
[13:19] <moritz_> TimToady: the questions was, on %h{$key}.push(...) it seems that it should autoviv an array... but where is the mapping from .push to Array defined?

[13:21] *** jhorwitz joined
[13:23] <ruoso> TimToady, I see what you mean... the Array contain Scalars, but the issue is with the value stored inside that scalar

[13:23] <ruoso> i.e. the array autovivified when you do %h{$key}.push(...)

[13:26] <ruoso> my guess is that the value returned by %h{$key} is a special lazy object that knows how to handle that autovivification

[13:27] <ruoso> which in SMOP, is the "bvalue" object

[13:41] *** jan_ left
[13:43] *** mberends left
[13:51] *** ejs1 left
[13:59] *** alester joined
[14:01] <TimToady> airport &

[14:01] *** nihiliad joined
[14:21] *** dKingston joined
[14:25] *** davidad joined
[14:32] *** c9s joined
[14:36] *** brunoV joined
[14:37] <mikehh> Hi - I was just looking at the "Official Perl 6 Wiki" at http://www.perlfoundation.org/perl6/index.cgi and I noticed it is NOT picking up Rakudo.org feeds any more

[14:38] <mikehh> I know the Rakudo.org site has changed but maybe someone could look into this?

[14:46] *** exodist joined
[14:47] *** payload joined
[14:48] *** c9s_ left
[14:51] *** jcrigby left
[14:54] <mikehh> well http://rakudo.org/rss.xml seens to give the same stuff so rakudo.org needs to fix the feeds 

[14:56] <mikehh> to give the latest news as per http://rakudo.org/tracker

[14:56] *** Tene joined
[14:58] *** eternaleye left
[15:03] *** Psyche^ joined
[15:08] *** Tene_ left
[15:18] <payload> the talk of larry isnt online yet, isntit?

[15:20] *** Psyche^ is now known as Patterner

[15:20] *** PZt joined
[15:22] <brunoV> 10 hours ago when I last checked, it wasn't

[15:29] *** Tene_ joined
[15:35] <japhb> Is proto still the current way to install modules for Rakudo?

[15:35] *** Tene left
[15:36] <moritz_> japhb: it is

[15:37] <japhb> moritz_: thanks.  Is it your creation?

[15:37] * japhb about to go look for it on github ...

[15:37] <moritz_> japhb: no, masak's

[15:38] <japhb> moritz_: Ah, OK

[15:41] <japhb> Hmmm.  I get octocat trying to access http://github.com/masak/proto/tree

[15:43] <moritz_> seems to be a github error

[15:43] <moritz_> the git clone works, though

[15:43] <moritz_> git clone git://github.com/masak/proto.git

[15:44] <japhb> yeah ... saw something similar last night doing a fork, but then everything worked fine a minute later.  They appear to have broken something ...

[15:44] <PerlJam> github is cool, but it's getting used enough that these little hiccups are quite annoying.

[15:44] <japhb> PerlJam: YES

[15:45] <japhb> Time to leave behind the fast and free startup mentality ...

[15:45] *** justatheory joined
[15:46] <PerlJam> I wonder what they use to implemenet github?  (I bet it's rails and the problems we see are evidence that it doesn't scale well  ;)

[15:46] <japhb> moritz_: hmmm, I guess I can clone now, then later when they fix things (and if I have something to contribute) only then fork, add a remote, and push to the fork ...

[15:46] <japhb> PerlJam: They are definitely Ruby guys.  Beyond that, not sure.

[15:48] <PerlJam> moritz_: your response to Xiao's second item on p6l seems to be cutoff

[15:49] <moritz_> PerlJam: thanks, I'll write a follow-up

[15:50] *** kimtaro left
[16:02] *** [particle]2 joined
[16:14] *** dKingston left
[16:29] *** pmurias joined
[16:35] <dalek> rakudo: 881ed3d | pmichaud++ | docs/spectest-progress.csv:

[16:35] <dalek> rakudo: spectest-progress.csv update: 344 files, 8081 passing, 0 failing

[16:35] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/881ed3d69a12cf49dffade78e5919666c79ff13a

[16:42] *** ruoso left
[16:46] *** mikehh left
[16:52] *** pmurias_ joined
[17:03] *** mncharity joined
[17:03] *** pmurias left
[17:03] *** pmurias_ left
[17:06] <mncharity> masak++  # re "let's just write something somewhere, and let the Magic of Community unfold it into something beautiful" :)

[17:06] *** [particle] joined
[17:09] <mncharity> ruoso: re "and start proxying all the calls to it", or .becomes ?

[17:17] <mncharity> re larry's talk, still doesn't seem to be online. :/

[17:17] <mncharity> could have used the "implementations" slide info.

[17:17] <mncharity> s/could have/could/

[17:19] <pmichaud> mncharity: from what I saw of the talk, the slides were takahashi-based

[17:19] <pmichaud> (i.e., very little info beyond the names of the implementations)

[17:21] <mncharity> ah, ok.  it was streamed, so hopefully there is vid out there.  maybe I'll drop by sipb...

[17:22] *** [particle]2 left
[17:22] <mncharity> tnx

[17:23] *** pmurias joined
[17:30] <pugs_svn> r26064 | putter++ | [elf_h] Revert r26027, as it broke elfish/on_lisp.

[17:36] *** jan_ joined
[17:43] <mncharity> random thought: if http://perl6-projects.org/  doesn't have links to the rakudo and smop settings directories, that would be nifty.

[17:43] <moritz_> mncharity: I can add that later

[17:44] <moritz_> mncharity: or you can, it's in the pugs svn ;-)

[17:44] <moritz_> docs/feather/

[17:47] *** hercynium joined
[17:48] <pmichaud> ...is there an easy way to do links to directories in git?

[17:48] <pmichaud> er, github ?

[17:49] <pmichaud> ahhh:  http://github.com/rakudo/rakudo/tree/master/src/setting

[17:49] <pmichaud> nice.

[17:53] *** amoc joined
[17:53] <skids> pmichaud: would you like me to move http://www.perlfoundation.org/perl6/index.cgi?perl6_tasks over to the github wiki?

[17:53] *** clintongormley left
[17:53] <pmichaud> skids: looking.

[17:54] <skids> I was thinking maybe then I'd use that as a place for "standards todo"

[17:54] <pmichaud> either the github wiki, or to rakudo.org

[17:54] <pmichaud> http://rakudo.org/status

[17:54] <skids> thanks.  I'll make sure it's well linked.

[17:54] <pmichaud> but yes, we should generally be moving things away from the perlfoundation.org wiki

[17:55] <pmichaud> another place to put tasks is in RT

[17:55] <pmichaud> (arguably that's *the* place to put tasks)

[17:56] <skids> I'll take care of it later today, back to strangling CISCO gear now.

[18:01] <pmurias> mncharity: the smop setting lives in v6/mildew/CORE but it's not something usefull in none-smop content now

[18:05] <mncharity> pmurias: nod.  I'm scribbling on the elf status report now, alternatives section.  suggesting people interested in writing Setting look to rakudo, elf, and mildew.  for such, accessible pointers are nice.

[18:06] <mncharity> You can currently write standard library (aka "setting" formerly aka

[18:06] <mncharity> "prelude") code for rakudo, elf, and mildew/smop.  They need quite

[18:06] <mncharity> different code, but that's fine.  There's a vast difference between "X has

[18:06] <mncharity> been written for one", and "X hasn't been written for any".  It's easy

[18:06] <mncharity> enough to port from the one.  So choose one, and push back the darkness.

[18:06] <mncharity> oops, sorry.

[18:06] <pmurias> ?

[18:07] <mncharity> ? <- ??

[18:07] <pmurias> oops, sorry <- ?

[18:07] <pmurias> :)

[18:08] <skids> sub ? (? --> ?)

[18:08] <mncharity> cut-n-paste direct to irc - line spewage

[18:08] <mncharity> lol # re sub ?

[18:18] <mncharity> pmurias: ... hmm.  I was about to ask if m/smop needs C developers, but...

[18:18] <mncharity> the question suggests I'm doing the wrong thing.

[18:19] <mncharity> part of the elf Q1 report is turning into a general consensus "here's how to help with p6".

[18:19] <mncharity> which doesn't seem quite the right mechanism

[18:21] <mncharity> never the less,

[18:21] <mncharity> pmurias: does smop "need C hackers"?

[18:22] <skids> IMO people who really like C should be working on datastructure optimizations -- both SMOP and Parrot could use that.

[18:24] <pmurias> mncharity: yes ;) we need mostly C or perl5 hackers

[18:24] <mncharity> skids: you're sure of the smop part?  at some phases of projects, extra hands just muddle things.  r isn't online. :(

[18:24] <mncharity> ok, tnx

[18:24] <skids> I shouldn't answer for ruoso, you are right.

[18:26] <skids> But when we get to concurrency we'll be neeeding various shades of atomicity, plus people trying large junctions will need them to be tries, etc.

[18:28] <pmurias> smop isn't concerned with performance atm

[18:28] * mncharity looks forward to an erlang+X p6 backend.  where X can be any other backend - smop, rakudo, whatever.

[18:29] <pmurias> mncharity: what to you mean by erlang+X?

[18:33] <jnthn> Woo. Seems I've solved pretty much all the hard problems with getting Callable to be parametric.

[18:34] <mncharity> nodes in an erlang system can be written in an arbitrary language.  so the idea is start with a single node p6, and attempt to offload threads into erlang, which it does more-or-less uniquely well.

[18:34] <mncharity> !! # re Callable

[18:36] <pmurias> mncharity: got any pointers to how something like that should be done?

[18:39] <mncharity> http://erlang.org/doc/tutorial/cnode.html  But, given the p6 compiler support needed, the thought was more a 'I look forward to this post-xmas thing', rather than something which seems plausible to pursue at the moment.

[18:39] <mncharity> could be wrong though.  might be a nice way to shake down concurrency support.

[18:40] *** Tene_ is now known as Tene

[18:41] *** barney joined
[18:41] <mncharity> but if that's the goal, it might be worth stepping back a looking at the wide range of options, before choosing.

[18:44] <pmurias> the perl6 node will be running a seperate process connecting with sockets to other erlang nodes right?

[18:44] *** JD_o4u joined
[18:44] *** JD_o4u left
[18:45] <mncharity> re http://perl6-projects.org/ , perhaps link to the language-spec-style language spec someone was working on?  with appropriate "not all of this is spec" disclaimers.

[18:45] *** PhatEddy joined
[18:46] <mncharity> re nodes, right.  the big payoff would be if you could take some of your p6 threads, and emit them as erlang.

[18:48] <PhatEddy> rakudo: my Bool $t = Bool::False; say ++$t; say $t.perl; say $t.succ

[18:48] <p6eval> rakudo 881ed3: OUTPUT«1␤Bool::True␤Null PMC access in isa()␤current instr.: 'parrot;List;!flatten' pc 5960 (src/classes/List.pir:227)␤»

[18:50] * mncharity tries to find the unofficial p6 language spec someone was working on... any pointers?

[18:51] <PhatEddy> In Int.pir "succ" clones and increments.  I could try to do the same for Bool but it seems easier tor just return Bool::True from the prelude.

[18:52] <PhatEddy> Any one have a reason to prefer one solution over the other?

[18:52] <mncharity> the idea being, while it has issues, it's the closest thing p6 has to what other communities thing of when you say "language spec".  we'd like to attract good language folks.  pointing them only at Snn... tends to yield a "WTF?  what are these people thinking??" moment.  supplementing it seems a good idea.

[18:56] <mncharity> lol.  an old irc log:  11:12 moritz_    barbeqq1: the problem is that Perl 6 is a very complex and very new kind of language [...] 11:12 barbeqq1   moritz_: more complex than haskell for example ?  [...] 11:12 moritz_    barbeqq1: yes 11:12 barbeqq1   OMG 

[18:58] *** dKingston joined
[18:58] <mncharity> anyone remember where that "formal language specification" like document is?  i'm losing...

[18:58] <mncharity> hmm, and this of task.   but, it'd be nice if it ended up on p6-projects.

[18:59] *** nihiliad left
[19:00] <kolibrie> mncharity: http://www.dlugosz.com/files/specdoc.pdf

[19:01] <dalek> rakudo: f6886e3 | jnthn++ | src/ (2 files):

[19:01] <dalek> rakudo: Make Signature not be dependent on List and Failure, to break a dependency chain that got in the way of the bootstrap.

[19:01] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f6886e3af1a4ea7e00e4d4a1d349cded9af15a46

[19:01] <dalek> rakudo: b015a2a | jnthn++ |  (2 files):

[19:01] <dalek> rakudo: Remove Junction's deendence on Array and List, then move it to an earlier spot in the built-ins list.

[19:01] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b015a2afd6a502a7209d60a63f99a5de10baea01

[19:01] <dalek> rakudo: 4a7fe22 | jnthn++ | src/builtins/guts.pir:

[19:01] <dalek> rakudo: For registering parametric roles in the stage one set of built-ins, !meta_compose must not depend on having a constructed Perl6 Compiler object yet.

[19:01] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4a7fe22242241c7292363787d6b02ad89b0f0c0c

[19:01] <dalek> rakudo: 903a782 | jnthn++ | src/classes/Callable.pir:

[19:01] <dalek> rakudo: Callable role becomes parametric (like role Callable[::T = Object] { }).

[19:01] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/903a782d2af11b640d5a398db706e3847c5547c7

[19:01] <dalek> rakudo: fff26a1 | jnthn++ | :

[19:01] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[19:01] <kolibrie> mncharity: except I get a Not Found

[19:01] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/fff26a1407f76cc26b5c2a8ca188c7ff17ab1d10

[19:03] <mncharity> kolibrie: thanks! :)

[19:03] <kolibrie> mncharity: this one works: http://www.dlugosz.com/Perl6/

[19:03] *** nihiliad joined
[19:04] * PhatEddy Guessing a clone type approach might play better with inheritance ...

[19:05] <mncharity> awesome.  now if only we had a community editable version.

[19:06] <mncharity> any objections to it going on p6-projects, tagged as "one person's ...  something

[19:06] <moritz_> mncharity: no objects

[19:07] <moritz_> p6-projects is "ask for forgiveness rather than permission" ;-)

[19:07] <mncharity> audrey++ :)

[19:09] <pugs_svn> r26065 | moritz++ | [perl6-projects.org] link to Dlugosz' spec docs

[19:11] <mncharity> lol.  svn up, open editor, find link already there.  :)  that's a delightful blast from the p6 past.  moritz++

[19:11] <moritz_> mncharity: I'm adding the setting links now

[19:12] <moritz_> is there a good link to elf's prelude/setting?

[19:12] <mncharity> nifty.  hmm, don't know what to suggest for elf.  no separate directories.  maybe...

[19:13] <mncharity> http://perlcabal.org/svn/pugs/view/misc/elfish/on_lisp/PrimitivesSBCL.pm and

[19:14] <jnthn> (Note about my pre-dinner commits: if you grab them you'll need to re-Configure.)

[19:14] <mncharity> eh, how about just that and http://perlcabal.org/svn/pugs/browse/misc/elf/elf_h_src 

[19:16] <pugs_svn> r26066 | moritz++ | [perl6-projects.org] setting links, mncharity++

[19:18] <mncharity> kolibrie++

[19:24] *** exodist left
[19:25] *** exodist joined
[19:28] *** ZuLuuuuuu joined
[19:30] <pasteling> "ZuLu" at 193.140.225.206 pasted "Gives error on 13th line" (23 lines, 560B) at http://sial.org/pbot/35840

[19:31] <pmichaud> might want  <Pascal::tanimlayic_isim>

[19:31] <pmichaud> instead of dot

[19:31] <moritz_> ZuLuuuuuu: first you need to declare your variables

[19:31] <pmichaud> oh, that too.

[19:31] <ZuLuuuuuu> pmichaud & moritz_: oh ok thanks

[19:32] <moritz_> wohoo, thankful junctions ;-)

[19:32] <PerlJam> heh

[19:33] <PerlJam> Though, every time I see "junctions" now I cringe a little bit because of the utterly useless (IMHO) discussions about them on list.

[19:34] <moritz_> PerlJam: same here

[19:34] <moritz_> especially all these "we might not expect junctions here"

[19:35] <moritz_> if a sub returns a junction, it better document that

[19:35] <moritz_> where else could it come from?

[19:35] <moritz_> not from parameters?

[19:35] <moritz_> s/?//

[19:35] <moritz_> because they autothread

[19:36] <PerlJam> depends on if they are Object or Any  ;)

[19:36] <moritz_> well, yes

[19:36] <moritz_> but if you say Object that you can blame yourself

[19:37] <moritz_> and it's a natural law of programming that your program does bullshit if you have wrong expectations on what a subroutine returns

[19:37] <moritz_> </rant>

[19:37] <pasteling> "ZuLu" at 193.140.225.206 pasted "says "expression_1 is NOT well formed."" (15 lines, 340B) at http://sial.org/pbot/35842

[19:37] <jnthn> I can't say I've been following it so closely. I looked at one post recently and my eyes glazed over...

[19:37] *** sri_kraih_ joined
[19:38] *** ruoso joined
[19:38] <ZuLuuuuuu> I rearranged the code now does not give error but it does not give what I expect

[19:38] <ZuLuuuuuu> changed variables into english so you can understand faster :)

[19:39] <moritz_> ZuLuuuuuu: s/rule/token/ should help

[19:40] <jnthn> ZuLuuuuuu: I looked and thought exactly the same as moritz_ :-)

[19:40] <moritz_> ZuLuuuuuu: 'rule' implies that you expect <.ws> tokens wherever there's a whitespace in the rule...

[19:40] <jnthn> It's because rule inserts <.ws> which prevents two alphanumerics following each other (e.g. ab).

[19:40] <ZuLuuuuuu> hmmmmm

[19:40] <ZuLuuuuuu> oh ok I'll try it now

[19:40] <moritz_> ZuLuuuuuu: and that whitespace is *not* optional between two word letters

[19:41] *** justatheory left
[19:41] <ZuLuuuuuu> ok it worked now, thanks very much. Is there a broader information about the difference between rule and token?

[19:41] <PhatEddy> It looks like Bool.pir, Int.pir and Str.pir are all trying to do about the same thing with 'pred'/'succ'.

[19:41] <ZuLuuuuuu> I was reading the Perl 6 and Parrot essentials, does not contain info about token

[19:42] *** sri_kraih__ joined
[19:42] <PhatEddy> Any thoughts about trying to inherit and fix all three instead of just fixing bool?

[19:42] <moritz_> ZuLuuuuuu: that's a bit outdated; S05 contains all (*ALL*) the gory details

[19:43] <ZuLuuuuuu> moritz_:  thanks

[19:43] <ruoso> while thinking about chained comparison and junctions...

[19:43] <ruoso> i.e.

[19:44] <ruoso> rakudo: my $x = 1|5; say "is it?" if 1 < $x < 5;

[19:44] <p6eval> rakudo 881ed3: OUTPUT«is it?␤»

[19:44] <moritz_> PhatEddy: the Bool one does things quite differently

[19:44] <ruoso> I realized that chained operations should somehow return the value that mathed the criteria

[19:44] <PerlJam> ruoso: cool.

[19:44] <moritz_> PhatEddy: and as for Str/Int... it's just 3 lines ... factoring it out would probably be more code

[19:45] <ruoso> rakudo: my $x = 1|5; say "is it?" if [<] 1, $x, 5;

[19:45] <p6eval> rakudo 881ed3: OUTPUT«get_integer() not implemented in class 'Junction'␤current instr.: '!MAKE_JUNCTION' pc 8875 (src/classes/Junction.pir:222)␤»

[19:45] *** justatheory joined
[19:46] <ruoso> but the question is... which side to return?

[19:46] *** sri_kraih__ left
[19:47] <PhatEddy> moritz_: thx, ok I'll try just fixing Bool then

[19:51] <ruoso> rakudo: say [<] 1, 3, 5;

[19:51] <pmichaud> Bool.succ should probably return Bool::True;   Bool.pred should probably return Bool::False

[19:51] <p6eval> rakudo 881ed3: OUTPUT«1␤»

[19:51] <ruoso> pmichaud, how does reduce work with comparison operators?

[19:51] <moritz_> rakudo: my $x = Bool::True; say ++$x

[19:51] <p6eval> rakudo 881ed3: OUTPUT«1␤»

[19:51] <moritz_> rakudo: my $x = Bool::True; say --$x

[19:51] <p6eval> rakudo 881ed3: OUTPUT«0␤»

[19:51] <pmichaud> ruoso: I think it just does them pairwise (stopping at the first false comparison)

[19:52] <ruoso> ah... but where is the exception to work with comparison?

[19:52] <ruoso> I mean

[19:52] <ruoso>  [+] 1, 3, 5

[19:52] *** exodist left
[19:52] <ruoso> is simply calling the first two, getting the result and calling with the third

[19:52] <jnthn> We take a different code-path for comparrisons...can't quite remember what controls it.

[19:52] <jnthn> May be chaining precedence?

[19:53] <moritz_> that would make a lot of sense

[19:53] <pmichaud> isn't   infix:«<»   list associative now?

[19:53] <pmichaud> oh wait, it's chain associative

[19:53] <pmichaud> that said, I suspect that chain implies list

[19:53] *** hercynium left
[19:54] <pmichaud> currently rakudo does it by a special codepath for chained operators

[19:54] <jnthn> Oh, at the moment get just list the difference in get_metaop

[19:54] <ruoso> alright... so chain operators imply that its result is a bool

[19:54] <moritz_> well, meta ops are sort of a hack in Rakudo right now

[19:54] <pmichaud> I don't think the result has to be a bool.  

[19:54] <moritz_> std: say 2 RRR+ 4

[19:54] <p6eval> std 26066: OUTPUT«ok 00:02 35m␤»

[19:54] <moritz_> rakudo: say 2 RRR+ 4

[19:54] <p6eval> rakudo 881ed3: OUTPUT«Statement not terminated properly at line 1, near "RRR+ 4"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[19:55] <ruoso> pmichaud, at least it is evaluated in boolean context

[19:55] <pmichaud> ruoso: yes.

[19:55] *** sri_kraih left
[19:55] <ruoso> and when a chained op is reduced, it will return a bool

[19:55] <pmichaud> I would think it returns the result of the last comparison.

[19:55] <ruoso> right...

[19:55] <ruoso> so every chained operator is a comparison operator?

[19:55] <pmichaud> $a op $b op $c    is equivalent to  ($a op b and $b op c)

[19:56] <eiro> the control code under { } aren't perl6 code ? 

[19:56] <eiro> rule uid     { (\d**1..6) { 0 <= $0 <= 66666 or fail } }

[19:56] <pmichaud> rakudo doesn't understand closures in rules yet.

[19:56] <pmichaud> coming soon.

[19:56] <eiro> ok... that's why :)

[19:56] <eiro> thanks 

[19:56] <pmichaud> (I should probably put a parse error in PGE for that.)

[19:57] <lucs> pmichaud: Equivalent, but evaluates $b only once, I suppose?

[19:57] <pmichaud> lucs: yes, evaluates $b only once.

[19:57] <pmichaud> the point being that the result of a chained operator (even reduced) wouldn't have to be a bool.

[19:58] *** sri_kraih_ left
[20:00] <ruoso> so maybe the way to get chained to work with junctions is to take the same decision taken with reduce...

[20:00] <pmichaud> I'm curious to see if junctions in reduce will "just work" if/when we get the comparisons to be junctionized.

[20:01] <jnthn> I'd have expected so.

[20:01] <pmichaud> it could also be a bug in PCT's chaining code.

[20:01] <pmichaud> (since I think comparisons are already junctionized, iirc)

[20:02] <jnthn> Yeah, actually, I was just thinking...we already special-cased operators...

[20:02] <pmichaud> rakudo:  say [<] 1, 3|5, 7;

[20:02] <p6eval> rakudo 881ed3: OUTPUT«get_integer() not implemented in class 'Junction'␤current instr.: '!MAKE_JUNCTION' pc 8875 (src/classes/Junction.pir:222)␤»

[20:02] <pmichaud> I suspect a dispatch issue somewhere.

[20:03] <pmichaud> rakudo:   say 1 < (3|5);

[20:03] <p6eval> rakudo 881ed3: OUTPUT«1␤»

[20:03] <ruoso> maybe the autothreading code should somehow detect a chain

[20:03] <pmichaud> I think it's just that our reduction code isn't going through normal dispatch.

[20:03] *** exodist joined
[20:03] <jnthn> That may be it...

[20:03] <jnthn> Oh, but why is it failing *inside* Junction?

[20:04] <pmichaud> it's not failing inside of Junction

[20:04] <pmichaud> it's complaining when infix:<  attempts to get a numeric value from a junction

[20:04] <jnthn> current instr.: '!MAKE_JUNCTION'

[20:04] <pmichaud> which means that we called the wrong  infix:<

[20:04] <pmichaud> oh, inside of !MAKE_JUNCTION

[20:04] <pmichaud> hmmm.

[20:06] <jnthn> (I'd look, but in the middle of something else...)

[20:06] <ruoso> i think maybe chained ops require a dispatcher on its own

[20:07] <jnthn> ruoso: Not really, I think this should all just fall out of normal junction dispatch.

[20:07] <jnthn> The presence of a junction in a chaining will just lead to a junction at the end, which then collapses in the boolean context.

[20:07] <pmichaud> I'll look later.  I'm not sure why we have separate DISPATCH_* routines for single and multiple

[20:07] <ruoso> rakudo: say ?( 1 < 1|5 < 5 )

[20:07] <p6eval> rakudo 881ed3: OUTPUT«1␤»

[20:07] <ruoso> that's wrong

[20:08] <pmichaud> it is?

[20:08] <jnthn> It looks right to be.

[20:08] <jnthn> *me

[20:08] <pmichaud> I agree, it looks correct to me.

[20:08] <jnthn> It may not be what you _expect_ otoh.

[20:08] <ruoso> TimToady, just said that in p6l

[20:09] <jnthn> rakudo: ?( 1 < 1&5 < 5 )

[20:09] <p6eval> rakudo 881ed3:  ( no output )

[20:09] <jnthn> rakudo: say ?( 1 < 1&5 < 5 )

[20:09] <p6eval> rakudo 881ed3: OUTPUT«0␤»

[20:10] <literal> which synopsis talks about ?( ) ?

[20:10] <pmichaud> yes, with what larry says in p6l, we may need some specialized dispatch 

[20:10] <pmichaud> literal: S02

[20:10] *** barney left
[20:10] <pmichaud> literal: or maybe S03

[20:10] <literal> ok

[20:10] <pmichaud> literal:  prefix:<?>  is the "boolean" operator

[20:10] <ruoso> "I consider a chained "1 < $x < 2" to be a

[20:10] <ruoso> single function from the standpoint of autothreading"

[20:11] <pmichaud> ruoso: yes -- just saw that.  That's a bit different.

[20:12] <pmichaud> and that's going to be a bit tricky.

[20:12] <jnthn> pmichaud: (separate multi and single auto-threading cases) comments should make clear why, see also Perl6MultiSub, but ask if you need more.

[20:12] <pmichaud> jnthn: yes, just haven't had an opportunity to read the comments yet.

[20:12] <pmichaud> I'm working on getting icu-skipping support in the harness.

[20:12] <jnthn> Nice :-)

[20:12] <pmichaud> I think I have it done -- just running a spectest now.

[20:13] <jnthn> I'm fighting trait_verb handling in actions.pm with subs...

[20:13] <pmichaud> if you have a quick moment, I have a question about public/private attributes.

[20:14] <jnthn> Sure

[20:14] <pmichaud> in src/setting/Range.pm, starting at line 8

[20:14] <pmichaud> there's a definition for ACCEPTS.  It's wrong, but that's not the focus of my question at the moment.

[20:15] <pmichaud> suppose I wanted to make $.from_exclusive and $.to_exclusive private instead of public

[20:15] <pmichaud> how would I then get to the from_exclusive and to_exclusive attributes of $topic?  Or is it "you can't do that"?

[20:15] <jnthn> You mean, from outside?

[20:15] <jnthn> (outside of the class)

[20:15] <pmichaud> no, in the way it's currently being used int hat ACCEPTS method

[20:15] <jnthn> Or inside of it?

[20:16] <jnthn> oh

[20:16] <jnthn> ($.from == $topic.from) && ($.to == $topic.to) && for example would just become

[20:16] <jnthn> Oh, I see...

[20:16] <jnthn> You mean the $topic.from bit?

[20:16] <pmichaud> yes, if we were to make $!from private there.

[20:17] <pmichaud> (I don't need to make $.from private, which is why I asked about $.from_exclusive

[20:17] <jnthn> I'm not aware of a way to do that...

[20:17] <jnthn> I mean, $topic!from_exclusive

[20:17] <ZuLuuuuuu> rakudo: rule can :ignorecase { Can };

[20:17] <p6eval> rakudo 881ed3: OUTPUT«Malformed regex definition at line 1, near "can :ignor"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[20:17] <jnthn> is a private method call

[20:17] <pmichaud> ZuLuuuuuu: rakudo doesn't understand modifiers outside the braces yet.  

[20:18] <ZuLuuuuuu> hmmm

[20:18] <pmichaud> try   rule can { :ignorecase Can }

[20:18] <ZuLuuuuuu> we can put them inside bracets?

[20:18] <ZuLuuuuuu> ok

[20:18] <ZuLuuuuuu> thank you very much

[20:18] <pmichaud> or maybe just    rule can { :i Can }

[20:18] <jnthn> pmichaud: But merely declaring has $!from_exclusive is not going to give you that method.

[20:18] <pmichaud> jnthn: right.

[20:18] <pmichaud> so we'd have to also create the private method call.

[20:18] <jnthn> Aye

[20:19] <pmichaud> okay, that answers my question.  I suspect people will want a shortcut for that.

[20:19] <jnthn> Yeah, me too.

[20:19] <pmichaud> maybe I'll ask about it on p6l.

[20:19] <jnthn> *nod*

[20:19] <pmichaud> now we need to poke cspencer to fix the ACCEPTS method :-)

[20:20] <jnthn> ;-)

[20:21] <pmichaud> although (reviewing commit) it was wrong in the original he copied from, too.

[20:22] <ruoso> pmichaud, re: chained... I think we just won yet another dispatcher... 

[20:23] <pmichaud> ruoso: we may have.  

[20:23] <jnthn> oh great just what we need...

[20:23] <pmichaud> ruoso: that might not bother me too much, though, because Rakudo's current method of doing it through PAST isn't very clean either.

[20:23] <jnthn> How many dispatchers do we need. :-|

[20:23] <ruoso> but at least it is completely syntatical

[20:23] <pmichaud> I'll have to think about it a bit more over the weekend.  There are too many different things floating around my head as it is.

[20:23] <ruoso> Chained, Multi, Method, Private

[20:24] <pmichaud> we might be able to make it work neater if we treat chained ops as thunking ops

[20:25] <ruoso> thunking ops?

[20:25] <ruoso> in what sense?

[20:25] *** sri_kraih joined
[20:26] * ruoso .oO( I think we'll be needing a periodic table of dispatchers soon )

[20:26] <pmichaud> thunking the arguments means we can get the short-circuit semantics from within the chained operator handling

[20:27] <pmichaud> i.e., we might not need a totally separate dispatcher.  Or, another way of looking at it, is that the chaining function is the dispatcher (but not in the same sense as a method dispatch or function dispatch)

[20:28] <pmichaud> as I said, I'll have to think about it a bit more.  Rakudo and PCT's current implementation of chaining was more "make it work" than "this is the right way to do it"

[20:28] <jnthn> sub foo() returns Int { }; say &foo.of # Int - yay

[20:28] <pmichaud> although TimToady's p6l post is a bit unexpected -- hadn't seen that one coming.

[20:29] <ruoso> me neigther... but it actually makes sense

[20:29] <ruoso> makes Junctions a lot more usefull

[20:29] <pmichaud> I've been meaning to post this but haven't had a chance -- I think one can use functions to autothread conditionals, too.

[20:29] <pmichaud> for example, to make

[20:30] *** REPLeffect left
[20:30] <pmichaud> my $x = 3|4;    if $x == 3 { foo } else { bar }

[20:30] <pmichaud> one might be able to do:

[20:30] <pmichaud> .... oh, never mind, it doesn't quite work :-(

[20:31] <ruoso> yeah... the junction needs to collapse sometime

[20:31] <pmichaud> (I was thinking     sub if($x, $y, $z) {   $x ?? $y() !! $z() }

[20:31] <pmichaud> and then   if( $x == 3, { foo }, { bar } )     

[20:31] <pmichaud> which autothreads over the if, but we don't know how the $x collapsed.

[20:32] <pmichaud> I would've figured that out while posting, I guess :-)

[20:32] <jnthn> pmichaud: About $block.control('return_pir');

[20:33] <jnthn> pmichaud: I want to do something Rakudo-specific in the return handling code.

[20:33] <skids> IRC -- the braino deterrent

[20:33] <jnthn> (namely, the type check for returns, now I've got it all in place)

[20:33] <jnthn> However, it looks like that is a special case in PCT.

[20:34] *** ZuLuuuuuu left
[20:34] <pmichaud> it's overridable.

[20:34] <pmichaud> 'return_pir' is PCT's default.

[20:34] <pmichaud> you can actually put a PAST tree there with whatever you want to have happen instead.

[20:35] <jnthn> .control(...past tree here...) ?

[20:35] <pmichaud> yes.

[20:36] <jnthn> oh, I see, and I use the register var exception

[20:36] <jnthn> To test if it's of the type I want.

[20:36] <jnthn> oh no, that's done for me.

[20:36] <jnthn> So I know ti's the CONTROL_RETURN. Win!

[20:37] *** REPLeffect joined
[20:37] <pmichaud> I don't think I followed all of that.

[20:37] <jnthn> pmichaud: I thought at first I would end up catching any exception there and have to check it was a CONTROL_RETURN in my PAST.

[20:38] <jnthn> But it seems not, if I'm following PAST::Compiler correctly.

[20:38] <pmichaud> by that point we know it's a CONTROL_RETURN

[20:38] <jnthn> Which makes it nice and easy.

[20:38] <pmichaud> that is one of PCT's goals, yes :-)

[20:38] <jnthn> ;-)

[20:38] <jnthn> Oh, I did have one other question you might have some insight on.

[20:39] <jnthn> I think if you declare like my Int @array you can then say @array.of and get the Int proto back.

[20:39] <jnthn> Similarly for my Int %hash

[20:39] <pmichaud> seems reasonable.

[20:39] <jnthn> However, Match is a sticking point.

[20:39] <jnthn> Because it does Positional and Associative.

[20:40] <jnthn> I suspect Capture may be too.

[20:40] <pmichaud> I don't see the sticking point.

[20:40] <jnthn> I figured .of should be defined in the Positional and Associative roles.

[20:40] <jnthn> However, you get a role composition conflict.

[20:41] <pmichaud> I figure it's a property of the container

[20:41] <pmichaud> not of the role

[20:41] <jnthn> Ah, OK.

[20:41] <jnthn> In that case, it waits until later.

[20:41] <pmichaud> i.e., all containers have .of

[20:41] <jnthn> Because that means we gotta make the containers parametric roles too.

[20:41] <pmichaud> but that's a guess.  Again, I haven't thought much about these items yet.

[20:41] <jnthn> Which depends on the refactor to List etc.

[20:42] <pmichaud> well, we already know that @array needs some sort of property on it to constrain its elements to Int

[20:42] <pmichaud> I figure that's a property of @array itself.

[20:43] <pmichaud> much like if I say     my Int $x;    there's a constraint on the $x container

[20:43] <jnthn> It's not quite a property, but rather a role parameter, which we have a property that can then return.

[20:43] <japhb> pmichaud: do you guys accept github pull requests?

[20:43] <ruoso> maybe both Positional and Associative imply a Container role

[20:43] <pmichaud> japhb: we still prefer patches to RT

[20:43] <japhb> aw, dang

[20:44] <japhb> Well, that explains the silence.  ;-)

[20:44] <japhb> rt?

[20:44] <jnthn> For now that'll jsut mean your array does Positional[Int] but eventually it should mean we pun an Array[Int] which in turn does Positional[Int]

[20:44] <jnthn> (Probably transitively through List[Int])

[20:44] <pmichaud> Array[Int]  I somewhat understand.   Positional[Int]  I don't quite understand.  But I haven't read the specs for details yet.

[20:45] <pmichaud> japhb:  rt == [email@hidden.address]
[20:45] * jnthn quickly makes this all clear in S14. ;-)

[20:45] <japhb> pmichaud: thanks

[20:45] <pmichaud> japhb: so far we haven't found the fork queue on github to be at all usable for patch review

[20:45] <jnthn> But in summary, sub foo(Int @a) { } has a first parameter of type Positional[Int]

[20:46] <pmichaud> jnthn: okay, _that_ makes it clearer.

[20:46] <jnthn> (A *single* type.)

[20:46] <jnthn> (Yes, a parameterized type, but still one single type.)

[20:46] <pmichaud> japhb: you might look at http://wiki.github.com/rakudo/rakudo/steps-to-create-a-patch

[20:47] <pmichaud> there's also http://wiki.github.com/rakudo/rakudo/frews-recommended-workflow

[20:47] <japhb> reading ...

[20:48] <pmichaud> and also http://rakudo.org/developers-guide

[20:49] *** skids left
[20:49] *** dKingston left
[20:50] <japhb> pmichaud: What about the pull requests make it difficult for patch review?  I had assumed you would end up just clicking on my fork name, going to the commits tab, and looking at the various commits.  Is that assumption incorrect? (I've never *received* a github pull request ...)

[20:50] <pmichaud> it's the "looking at the various commits"

[20:51] <pmichaud> for one, the fork queue shows not only the commits you've made, but all of the commits you may have pulled

[20:51] <pmichaud> in some cases that's 30-40 commits for a single pull request

[20:51] <pmichaud> so then we have to go through them all and figure out which ones are relevant to what you're submitting

[20:52] <japhb> That's annoying

[20:52] *** davidad left
[20:52] <pmichaud> then, if your contribution was done locally as a series of small commits, we have to either review each one individually and mentally put them together, or do some other stuff to try to see it all as a single commit.

[20:53] <pmichaud> and if your series-of-small-commits contains places where you started down one path of development, backed up, and started down a different path, we have to follow that whole chain of logic instead of just looking at the results.

[20:53] <japhb> ah

[20:53] <japhb> hence all that "smash into one commit" stuff

[20:53] <pmichaud> exactly.

[20:54] <japhb> It's gotten hard to think that way, since I've gotten so used to micro-commits

[20:54] <pmichaud> micro-commits are fine -- just squash them at the end.

[20:54] *** mikehh joined
[20:54] <pmichaud> there's a good thread on the mailing list about this:  http://groups.google.com/group/perl.perl6.compiler/browse_thread/thread/a309daf77e96acda

[20:55] *** jhorwitz left
[20:55] <japhb> Nodnod, I meant reviewing them that way ... so it's strange to think about reviewing a megacommit.  :-)

[20:55] <pmichaud> and chrisdolan posted an excellent message on the topic:  http://groups.google.com/group/perl.perl6.compiler/msg/d648c85f5bfc47f0

[20:56] <japhb> reading again ...

[20:59] <pmichaud> as an example of what the fork queue looks like on github -- here's a screenshot:  http://pmichaud.com/sandbox/fq-4.jpg

[21:01] <japhb> Oh blech

[21:01] <jnthn> fork me that's huge!

[21:01] <pmichaud> and you can't see it from the screenshot, but at the end of that long list of red commits there's a line that says  "Showing the first 50 of 134 pending commits", which means that your pull request doesn't even show up in the fork queue because leto's request from 3 days ago is eating up the first 50 slots.

[21:02] <pmichaud> so until someone resolves leto's request somehow, your request isn't even visible.

[21:04] <pmurias> ruoso: hi

[21:05] <ruoso> hi pmurias 

[21:07] <dalek> rakudo: 07af82b | pmichaud++ |  (3 files):

[21:07] <dalek> rakudo: Update the harness to recognize icu flags on spectest.data,

[21:07] <dalek> rakudo: and to check for icu availability when running 'make spectest'.

[21:07] <dalek> rakudo: Add a icu-dependent test to spectest.data (which should be skipped

[21:07] <dalek> rakudo: on platforms that don't have icu present).

[21:07] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/07af82bcd971d8893f813df09f32eeaa74b8ba67

[21:07] <japhb> pmichaud: ouch

[21:07] <pmichaud> If someone who doesn't have icu currently installed could check "make spectest" after that last commit, I'd appreciate it greatly.

[21:07] <pmurias> ruoso: what do we need in s1p? LexicalScope,Hash,Code,AdhocSignature?

[21:07] <pmichaud> Note that it requires a reconfigure.

[21:07] <jnthn> pmichaud: Can do.

[21:07] <pmichaud> (to rebuild the Makefile)

[21:08] <jnthn> pmichaud: Just about to run a make spectest for my next commits anyway.

[21:08] <pmichaud> jnthn: okay, great.

[21:08] <pmichaud> I think I'm going to add a rule in the Makefile to warn when the Makefile is out of date.

[21:10] <eiro> is there a collection of perl6 snippets ? i can't figure out how to use my grammar in real life ...

[21:10] <pmichaud> eiro:  github.com/eric256/perl6-examples

[21:10] <pmichaud> see also perl6-projects.org

[21:11] <pmurias> ruoso: i re-read the README and found the list

[21:11] *** Limbic_Region joined
[21:11] <eiro> pmichaud, thanks 

[21:12] <ruoso> pmurias, I'm not sure the list is completely sane... maybe we should only move what is really being used

[21:12] <pasteling> "mncharity" at 98.216.110.149 pasted "Perl 6 project Elf - 2009 Q1 status report [DRAFT-1]" (204 lines, 9.9K) at http://sial.org/pbot/35843

[21:13] <mncharity> woops, 5pm.  draft ^^.  comments encouraged.

[21:13] <mncharity>  /me wonders if the "So what?" section is too... something.

[21:13] <pmurias> ruoso: Signature::Adhoc can replace Signature::BlockDefault

[21:14] <mncharity>  And the "big picture" section... sigh.

[21:14] <mncharity> not really part of a quarterly report.

[21:15] <ruoso> pmurias, yes, indeed... but BlockDefault is used in too many places... having it as a type on its own is probably not a bad idea 

[21:15] <mncharity> but since the whole point of elf is to attract developers... shrug.

[21:17] <japhb> pmichaud: previous fork pull request now resubmitted as rakudobug with patch

[21:20] <mncharity> thoughts, comments, anything?

[21:20] <mncharity> on or off channel

[21:21] <pmurias> mncharity: what's the connection between the education system and Perl 6?

[21:22] <pmurias> ruoso: we can have a $BlockDefault signature

[21:22] <ruoso> yeah... maybe... but it doesn't need to be exposed in the lexical scope

[21:22] <ruoso> it's s1p code that needs it

[21:23] <pmurias> the exceptions could be in perl 6?

[21:23] <ruoso> it's mostly in mold already

[21:24] <ruoso> but there are some fallbacks that are written in C

[21:24] <mncharity> ok, yank that paragraph.  I repeated encounter the concept, well, two variants - Hs and CL users saying "sure everyone not using our great language is screwed, who cares?", and others saying "sure there are powerful language features out there that my favorite language doesn't have, but I like it, it has a nice community, so who cares?".  the paragraph was an attempt to address those.

[21:24] <mncharity> ie, fundamentally, why does it matter that software development ceases to be a crippled disaster.

[21:26] <mncharity> and the related, why does the "we'll just reimplement the world in our language X" not suffice.

[21:26] <ruoso> mncharity, btw... in SMOP all the lowlevel implementations are seen as "bootstrap throwaway" (except for the native types) 

[21:27] <mncharity> awesome.  good to know.

[21:28] <pmurias> it should be possible to write the s1p in Perl 6 when we can emit sufficently native code

[21:28] <mncharity> s1p?

[21:29] * pmurias looks up what the acronym  means

[21:29] <mncharity> need a lambdabot p6 abbreviation dictionary :)

[21:29] <pmurias> i think it meant the stage 1 Perl

[21:29] <mncharity> s/need/fun to imagine/

[21:30] <pmichaud> for those testing the new "has icu" -- you can tell it's working if you (a) don't have icu and S02-literals/char-by-name isn't tested, or (b) have icu and S02-literals/char-by-name is tested.  

[21:30] <pmurias> we use it to call the set of classes we need in C

[21:30] <jnthn> pmichaud: No ICU here, and no fails as a result of your patch.

[21:30] <pmichaud> (when running "make spectest")

[21:30] <ruoso> mncharity, yes... s1p (read swamp) is the the first stage implementation of the Perl 6 types

[21:30] <jnthn> (And one fail as a result of my locals. fail.)

[21:31] <pmichaud> jnthn: excellent.  The only place where a failure might occur at this point is S02-literals/char-by-name.  But I'm about to add another batch.

[21:31] <ruoso> mncharity, it should be thrown away (actually, not away, just deep inside the bootstrapping) as soon as we get the typesystem bootstrapped

[21:32] <ruoso> mncharity, which is why we already have a CORE in Perl 6, so early in the proces

[21:32] <eiro> wow! unitary tests are usefull to understand syntax!  :)

[21:32] <ruoso> eiro, TDD people belive the test is the documentation

[21:33] <eiro> :)

[21:33] <jnthn> pmichaud: No, for sure no fails there.

[21:34] *** dKingston joined
[21:34] <ruoso> mncharity, in fact, if pmurias' proposal get accepted in SoC, it will get us much closer of having a incredibly bigger set of the CORE written in Perl 6

[21:35] *** nihiliad left
[21:36] <mncharity> ruoso: anything about "Big picture" you'd like changed from a smop perspective?

[21:37] <mncharity> jnthn/pmichaud: same question vis rakudo.  it ended up a rather general "come, help with p6!" monster.

[21:40] <pasteling> "mncharity" at 98.216.110.149 pasted ""So what?" redraft pmurias++" (12 lines, 844B) at http://sial.org/pbot/35844

[21:44] <eiro> http://rafb.net/p/vGOVMY94.html

[21:44] <eiro> my first (almost) working parser

[21:44] <eiro> failed with 

[21:44] <eiro> > perl6 posixAccount.p6   

[21:44] <eiro> Method 'close' not found for invocant of class 'IO'

[21:44] <eiro> current instr.: 'close' pc 19354 (src/builtins/io.pir:93)

[21:44] <lambdabot>   Not in scope: `perl6'Not in scope: `posixAccount'Not in scope: `p6'

[21:45] <mncharity> lol

[21:45] <pmichaud> mncharity:  from a rakudo perspective, the new draft is much improved.  Thanks for the effort.

[21:47] <pmichaud> (overall it's also much improved, but I particularly appreciate the way rakudo is presented.)

[21:49] <mncharity> ok.  danke

[21:49] <pmurias> mncharity: you belive that by writing better educational software the school system will be improved?

[21:50] <japhb> pmurias: I believe that is the fundamental belief of Sugar Labs ...

[21:50] <eiro> grammar.parsefile  works ? 

[21:51] <mncharity> re improved, yes, definitely.  OLPC... well, olpc had lots of problems.  but "python is the best language we have to work with" was a big one.

[21:51] <japhb> Redhat influence, mayhaps?

[21:51] <mikehh> t/spec/S02-literals/char-by-name.rakudo  passes on rakudo (07af82b) on parrot r37894

[21:51] <pmurias> shower&

[21:52] <mikehh> t/spec/S02-literals/char-by-name.t  fails on Unrecognized character name LINE FEED at offset 616, found 'L'

[21:52] <mncharity> the difference between "repeat after me class, a virus is a ...", and surfing over to wikipedia to play with the 3d dynamic interactive models of viruses... is not small.

[21:54] <pmichaud> I'm not sure that "LINE FEED" is a valid unicode character name. 

[21:54] <pmichaud> At least, ICU (the way I'm using it) doesn't seem to recognize it as one.

[21:55] <pmichaud> I haven't found a way to make it work yet, and perhaps it needs a message to p6l.

[21:55] <mncharity> http://unicode.org/charts/charindex.html

[21:55] <mncharity> doesn't look like it

[21:56] <mncharity> oops

[21:56] <mncharity> wrong page.  http://unicode.org/charts/charindex2.html   'tis.

[21:56] <pmichaud> that's apparently a "character name alias"

[21:56] *** PhatEddy left
[21:57] <pmichaud> I haven't found out how to get ICU to translate character name aliases.

[21:57] <mncharity> 000A <control>     = LINE FEED (LF)     = new line (NL), end of line (EOL)

[21:57] <eiro> good nigh all 

[21:57] <pmichaud> correct -- the name is actually   "LINE FEED (LF)"

[21:57] <eiro> (thx for help)

[21:57] <mncharity> ah

[21:57] <mncharity> g'night

[21:57] <pmichaud> and ICU correctly recognizes that one (as does Rakudo now)

[21:58] <mncharity> eep.  unicode - a whole world of linguistic pain.

[21:58] <pmichaud> yes, which is why I like punting the pain to ICU.

[22:01] <pmichaud> gone for a while -- taking daughter to fencing lessons :-)

[22:03] <mncharity> fencing++ 

[22:03] <japhb> aikido++

[22:04] *** ejs joined
[22:04] <japhb> "My dad can make sure your dad doesn't kick my ass."

[22:08] <mncharity> vs rugby, which is sort of a mutual bloodletting?

[22:09] <japhb> Any sport where you have to tape your ears to your head or risk having them ripped off ... isn't far from bloodsport.

[22:10] *** ejs left
[22:11] <mikehh> even in cricket you get to wear helmets these days

[22:12] <japhb> Note: I personally think rugby is a much more "real" sport than American rules football ... but you'd not catch me playing full contact versions of either one, these days.

[22:13] <mncharity> ok, draft off to Boston.pm for comment.

[22:14] <mikehh> haven't played either since my schooldays - way too many years ago

[22:14] <mncharity> fun concept: pedagogic puppet patypi.   (re flexible OO).   William.Ricker++

[22:17] *** pmurias left
[22:18] <mncharity> thanks all for the help.  g'night &

[22:18] *** mncharity left
[22:30] *** Limbic_Region left
[22:41] *** alester left
[22:50] <mikehh> rakudo  (07af82b) builds on parrot r37894 - make test/make spectest PASS - Kibuntu Intrepid i386

[22:57] *** exodist left
[23:04] *** ashizawa left
[23:07] *** ashizawa joined
[23:10] *** Sepheebear left
[23:25] *** Limbic_Region joined
[23:26] *** meppl left
[23:27] *** ab5tract joined
[23:28] *** wayland76 left
[23:29] *** wayland76 joined
[23:29] *** Guest19007 joined
[23:31] *** Guest19007 left
[23:55] *** kidd left
