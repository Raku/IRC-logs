[00:08] *** ihrd joined
[00:10] *** eternaleye_ joined
[00:10] *** eternaleye left
[00:27] *** jlaire left
[00:31] <amoc> rakudo: module A { method foo { .say } }; A.new; # null pmc at wrong code

[00:31] <p6eval> rakudo 0e0671: OUTPUT«Null PMC access in getprop()␤in Main (/tmp/IqyHLjRYoI:2)␤»

[00:33] <amoc> rakudo: module A { ... } # module NYI ?

[00:33] <p6eval> rakudo 0e0671: OUTPUT«Can't return outside a routine␤in Main (/tmp/CixkB6wUt7:2)␤»

[00:35] *** payload joined
[00:42] *** ihrd left
[00:46] *** japhb left
[00:53] *** Whiteknight left
[01:06] <last> So, if one wanted to track down why t/01-sanity/07-isa.t is failing with "Method 'succ' not found for invocant of class 'Block'", where would one start looking?

[01:07] <skids> well, first you check rt for already filed bugs.

[01:08] *** Simcop2387 is now known as simCOP2387

[01:08] *** simCOP2387 is now known as simcop2387

[01:09] <last> skids: I believe I filed one for it, in fact.

[01:10] *** payload left
[01:10] *** payload joined
[01:11] <last> http://www.nntp.perl.org/group/perl.perl6.compiler/2009/06/msg4367.html

[01:11] <last> I don't see any responses to it, other than my two followups with additional information.

[01:13] <skids> well, my build is somewhat custom at the moment, have you asked anyone with a different arch to see if that test is failing for them?

[01:14] <last> I haven't.  (Though it also fails for me on x86_64 Linux.)

[01:15] <skids> probably a test that was sacrificed for a feature, then.

[01:15] <skids> (and will be refixed later)

[01:16] * skids tries to figure out what the deal is with $*IN from the commandline

[01:16] <last> Really?  I'd always assumed the "make test" tests were core tests and failures there equated to a broken build.

[01:17] <skids> I'm not entirely sure of that.

[01:17] <skids> But I wouldn't be the one to ask.

[01:18] *** japhb joined
[01:20] <skids> well, I hand run those tests and they seem to work for me outside prove.

[01:21] <skids> Unfortunately I think right now my hacking may have broken the test harness, so someone else will need to check.

[01:24] *** dukeleto left
[01:27] *** dukeleto joined
[01:27] *** eternaleye_ is now known as eternaleye

[01:28] <lichtkind_> .get returns lines or an iterator?

[01:28] <last> I can verify I get the bug when I run that test on its own, for what it's worth.

[01:28] *** dukeleto left
[01:29] <skids> .get returns the result of an iteration.  For file, a line, by default.

[01:32] *** s1n1 joined
[01:37] *** nihiliad joined
[01:37] <lichtkind_> skids true but what is called iterator :)

[01:40] <last> (Hmmm... all tests pass on my 32-bit Linux box.)

[01:50] <skids> lichtkind_: maybe rephrase the question?

[01:51] *** lichtkind_ is now known as lichtkind

[01:51] <lichtkind> skids: does .lines method return an iterator?

[01:52] *** mycelium joined
[01:52] *** mycelium left
[01:52] <skids> I think the array returned by .lines might be lazy, if that is what you are asking.

[01:53] <lichtkind> skids: yes but people who talked here in #perl 6 used the word iterator which confused me :)

[01:54] <skids> see s07.

[01:54] *** s1n1 left
[01:55] <skids> lines would likely return the equivalent of @a <== do while (!$f.eof) { $f.get }

[01:57] <lichtkind> skids: i dont see it in http://svn.pugscode.org/pugs/docs/Perl6/Spec/S07-iterators.pod

[01:57] <skids> For what definition of "it"?

[01:58] * skids wonders why S32 says $f.lines[^5] wouldn't be lazy.

[01:58] <skids> rakudo: my $f = open("/tmp/dict"); $f.get.say; $f.get.say;

[01:58] <p6eval> rakudo 0e0671: OUTPUT«operation not permitted in safe mode␤in Main (lib/Safe.pm:25)␤»

[01:59] *** jferrero left
[02:01] *** molaf_xx joined
[02:01] *** molaf_x left
[02:01] <skids> rakudo: my $f = open("/usr/share/dict/american-english", :rw(Bool::False)); $f.get.say; $f.get.say;

[02:01] <p6eval> rakudo 0e0671: OUTPUT«operation not permitted in safe mode␤in Main (lib/Safe.pm:25)␤»

[02:02] <lichtkind> skids: thanks but its not so important have to solve proofreading now :)

[02:02] <skids> hrm, well, what I wanted to demonstrate is that the first .get seems not to actually get.

[02:05] <skids> And, secondly, .get chokes when it gets down to Asunción

[02:05] <skids> "Malformed UTF-8 string"

[02:07] <lichtkind> skids: thanks but i know how they work, i was unshure how thats called :)

[02:07] <skids> no, that's not what I expected to happen, couple of bugs I think.

[02:12] <eternaleye> rakudo: my slurpy( *@args ) { }; say &slurpy.count

[02:13] <p6eval> rakudo 0e0671: OUTPUT«Malformed declaration at line 2, near "slurpy( *@"␤in Main (src/gen_setting.pm:0)␤»

[02:13] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.count

[02:13] <p6eval> rakudo 0e0671: OUTPUT«0␤»

[02:13] <eternaleye> Don't I feel dumb!

[02:14] <skids> heh.  Well that "my" becomes reflex, to be sure :-)

[02:14] <skids> Just have to train the reflex :-)

[02:15] <eternaleye> moritz_: re implementing infix:<...>; what are slurpy generators specced to do? Your sorta-working function would call them with no arguments (if it didn't get weird in the range spec), which doesn't seem very dwimmy to me

[02:17] <eternaleye> TimToady: See ^^^ for a spec question

[02:17] *** cls_bsd left
[02:17] *** cls_bsd joined
[02:19] *** dukeleto joined
[02:20] <lichtkind> good nicht

[02:20] <lichtkind> night

[02:20] *** lichtkind left
[02:26] *** eternaleye left
[02:32] *** eternaleye joined
[02:43] *** last left
[02:49] *** jonathanturner left
[02:57] *** felipe left
[02:59] *** skids left
[03:05] *** Limbic_Region left
[03:06] <TimToady> eternaleye: I think slurpy should get all the existing values

[03:10] <TimToady> zzz &

[03:13] *** KyleHa joined
[03:13] *** rfordinal joined
[03:13] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.^methods

[03:13] <p6eval> rakudo 0e0671: OUTPUT«␤»

[03:14] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.HOW.methods

[03:14] <p6eval> rakudo 0e0671: OUTPUT«too few arguments passed (1) - 3 params expected␤in Main (src/gen_setting.pm:3225)␤»

[03:14] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.WHAT

[03:14] <p6eval> rakudo 0e0671: OUTPUT«Sub()␤»

[03:15] <eternaleye> rakudo: say Sub.methods.join( " " );

[03:15] <p6eval> rakudo 0e0671: OUTPUT«Method 'methods' not found for invocant of class ''␤»

[03:16] *** meppl joined
[03:17] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.arity

[03:17] <p6eval> rakudo 0e0671: OUTPUT«0␤»

[03:19] *** rfordinal left
[03:20] *** donaldh left
[03:20] <KyleHa> Does that 'bot have any protection against "say 'flood' while 1" ?

[03:20] *** meppuru joined
[03:20] *** donaldh joined
[03:21] <eternaleye> KyleHa: It timelimits stuff, and newlines are turned into '␤' symbols rather than sending multiple IRC lines

[03:21] <KyleHa> *nod*

[03:21] <Tene> rakudo: say 'flood' while 1

[03:21] *** meppl left
[03:21] *** meppuru is now known as meppl

[03:21] <p6eval> rakudo 0e0671:

[03:21] <p6eval> ..OUTPUT«flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤flood␤…

[03:21] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.^methods

[03:21] <p6eval> rakudo 0e0671:

[03:21] <p6eval> ..OUTPUT«!add_param!set_default_param_type!add_implicit_self!make_parameters_rwparamsperlcanisadoes111keyskv21values11111srand1rootsunpolar111111111trans2111111111reverse1111rand11111111111112111111clonedefinedhashitemiteratorprintsaytrueArrayHashIteratorScalarStrblessBUILDBUILDALLCREATEnew…

[03:22] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.^methods.join( " " )

[03:22] <p6eval> rakudo 0e0671: OUTPUT«!add_param !set_default_param_type !add_implicit_self !make_parameters_rw params perl can isa does 1 1 1 keys kv 2 1 values 1 1 1 1 1 srand 1 roots unpolar 1 1 1 1 1 1 1 1 1 trans 2 1 1 1 1 1 1 1 1 1 reverse 1 1 1 1 rand 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 clone defined

[03:22] <p6eval> ..hash it…

[03:22] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.^methods.grep( { $_ !~~ /^\d+$/ } ).join( " " )

[03:22] <p6eval> rakudo 0e0671: OUTPUT«Can't set self from this type␤in regex PGE::Grammar::_block74 (/tmp/LPVgfCr3SZ:2)␤called from method Any::grep (/tmp/LPVgfCr3SZ:2)␤called from Main (/tmp/LPVgfCr3SZ:2)␤»

[03:23] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.^methods.grep( { $_ !~~ /\d+/ } ).join( " " )

[03:23] <p6eval> rakudo 0e0671: OUTPUT«Can't set self from this type␤in regex PGE::Grammar::_block74 (/tmp/hOveSo7goi:2)␤called from method Any::grep (/tmp/hOveSo7goi:2)␤called from Main (/tmp/hOveSo7goi:2)␤»

[03:24] <eternaleye> rakudo: sub slurpy( *@args ) { }; say grep &slurpy.signature.^methods: { $_ !~~ /\d+/ }

[03:24] <p6eval> rakudo 0e0671: OUTPUT«positional inside named args at position 3␤in Main (src/gen_setting.pm:3225)␤»

[03:24] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.^methods.grep( { $^a !~~ /^\d+$/ } ).join( " " )

[03:24] <p6eval> rakudo 0e0671: OUTPUT«!add_param !set_default_param_type !add_implicit_self !make_parameters_rw params perl can isa does keys kv values srand roots unpolar trans reverse rand clone defined hash item iterator  print say true Array Hash Iterator Scalar Str bless BUILD BUILDALL CREATE new PARROT

[03:24] <p6eval> ..REJECTS !S…

[03:25] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.^methods.grep( { $^a !~~ /^\d+$/ } ).reverse.join( " " )

[03:25] <p6eval> rakudo 0e0671: OUTPUT«WALK  !.= !.^ !MANY_DISPATCH_HELPER !.+ !.* !.? !rebox !cloneattr WHICH WHERE WHENCE !STORE REJECTS PARROT new CREATE BUILDALL BUILD bless Str Scalar Iterator Hash Array true say print  iterator item hash defined clone rand reverse trans unpolar roots srand values kv keys does

[03:25] <p6eval> ..isa …

[03:25] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature

[03:26] <p6eval> rakudo 0e0671: OUTPUT«Signature()<0xb688b808>␤»

[03:26] <KyleHa> These are methods that the slurpy sub implicitly has available?

[03:27] <eternaleye> KyleHa: $object.^methods returns a list of methods that object supports. So I'm getting a list of the methods that the sub's _signature_ supports

[03:28] <KyleHa> So...methods that have a slurpy signature?

[03:28] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.hash.perl

[03:28] <p6eval> rakudo 0e0671: OUTPUT«Odd number of elements found where hash expected␤in Main (/tmp/1Ene3NaOL6:2)␤»

[03:28] <eternaleye> KyleHa: You can get the signature of any sub with the .signature method

[03:29] <eternaleye> I'm trying to figure out a way to programmatically recognize slurpy subs so that moritz_++'s infix:<...> operator can handle them correctly

[03:29] <KyleHa> The .signature method seems to return a signature object.

[03:29] <eternaleye> KyleHa: Indeed

[03:29] <KyleHa> Oh, I see.

[03:29] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.Array.perl

[03:29] <p6eval> rakudo 0e0671: OUTPUT«[:(Any *@args)]␤»

[03:30] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.kv.perl

[03:30] <p6eval> rakudo 0e0671: OUTPUT«[0, :(Any *@args)]␤»

[03:30] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.[0].WHAT

[03:30] <p6eval> rakudo 0e0671: OUTPUT«Method 'postcircumfix:[ ]' not found for invocant of class 'Signature'␤»

[03:30] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.perl

[03:30] <p6eval> rakudo 0e0671: OUTPUT«:(Any *@args)␤»

[03:31] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.Iterator.[0].perl

[03:31] <p6eval> rakudo 0e0671: OUTPUT«:(Any *@args)␤»

[03:31] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.Iterator.[1].perl

[03:31] <p6eval> rakudo 0e0671: OUTPUT«set_pmc_keyed() not implemented in class 'Iterator'␤in Main (/tmp/00txsSJtWI:2)␤»

[03:32] *** dukeleto left
[03:32] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.Iterator.[0].WHAT

[03:32] <p6eval> rakudo 0e0671: OUTPUT«Signature()␤»

[03:32] *** frew joined
[03:34] <eternaleye> phenny: ask TimToady is there a specced way to find the nature (slurpy, named, etc) of the individual parameters in a Signature object? EVery single method in .^methods that I've tried just hands me back the whole signature, rather than something identifiable programmatically. The only solution I can see is to manually write a grammar to parse the .perl of the signature, which is decidedly icky.

[03:34] <phenny> eternaleye: I'll pass that on when TimToady is around.

[03:34] *** jaldhar joined
[03:37] *** KyleHa left
[03:40] *** japhb left
[03:41] <eternaleye> oh wait

[03:41] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.signature.params.perl

[03:41] <p6eval> rakudo 0e0671: OUTPUT«["named" => 0, "slurpy" => 1, "name" => "\@args", "multi_invocant" => 1, "nom_type" => Any, "type" => Any, "cons_type" => undef]␤»

[03:42] <eternaleye> phenny: tell TimToady nevermind, I seem to have simply overlooked the .params method. I think I may need new glasses.

[03:42] <phenny> eternaleye: I'll pass that on when TimToady is around.

[03:43] *** japhb joined
[03:44] *** japhb left
[03:46] *** japhb joined
[03:46] <eternaleye> rakudo: sub slurpy( *@args ) { }; say "yes" if &slurpy.signature.params.<slurpy> > 0

[03:46] <p6eval> rakudo 0e0671: OUTPUT«sh: ./perl6: No such file or directory␤»

[03:47] <eternaleye> rakudo: sub slurpy( *@args ) { }; say "yes" if &slurpy.signature.params.<slurpy> > 0

[03:47] <p6eval> rakudo 0e0671: OUTPUT«sh: ./perl6: No such file or directory␤»

[03:47] <eternaleye> grr

[03:48] <eternaleye> rakudo: sub slurpy( *@args ) { }; say "yes" if &slurpy.signature.params.<slurpy> > 0

[03:48] <p6eval> rakudo 0e0671: OUTPUT«yes␤»

[03:50] <eternaleye> moritz_: re infix:<...>, TimToady++ says that slurpy generators should get all previously generated values. This could probably be done by checking if &generator.signature.params.<slurpy> > 0 

[04:00] <pmichaud> I suspect one could also check if  &sub.count is Inf

[04:05] *** nihiliad left
[04:08] *** nihiliad joined
[04:16] <eternaleye> pmichaud: .count returns 0 on slurpies. Is this a rakudobug?

[04:17] <eternaleye> rakudo: sub slurpy( *@args ) { }; say &slurpy.count

[04:17] <p6eval> rakudo 0e0671: OUTPUT«0␤»

[04:17] <pmichaud> eternaleye: yes, it could be considered a bug.  But it's also unspecced, so it's not a bug :-)

[04:17] <eternaleye> pmichaud: If it returned Inf, moritz_++'s operator would DTRT

[04:18] <pmichaud> having a sub with a .count of Inf is (afaik) speculative at the moment

[04:18] <pmichaud> also, it's not clear how to reliably return Inf in Parrot.

[04:19] <eternaleye> rakudo: my @list = ( 1, 2, 3, 4, 5 ); say @list[*-Inf..*].join( ", " )

[04:19] <p6eval> rakudo 0e0671:  ( no output )

[04:20] <eternaleye> ^^ I gues moritz_'s operator wouldn't DTRT after all :(

[04:20] <pmichaud> oh, I'm not sure that *-Inf works there

[04:20] <pmichaud> I'm pretty sure it doesn't.

[04:21] <pmichaud> We're still having to figure out how to get ranges to work properly.

[04:21] <eternaleye> pmichaud: That's what his implementation did. $c = &gen.count; gen(|@arr[*-$c..*])

[04:21] <pmichaud> sure.

[04:22] <pmichaud> But I know that rakudo already gets ..* wrong.

[04:22] <eternaleye> So it still might be more robust to directly check for slurpies in the signature

[04:22] <pmichaud> and it wouldn't surprise me if rakudo also didn't understand *-Inf..

[04:23] *** justatheory_ joined
[04:24] <pmichaud> at any rate, I'm planning to work on ticket closures and small bugfixes for tomorrow's Rakudo day, so feel free to submit the .count  == Inf one :-)

[04:24] <eternaleye> buubot: spack Signature object

[04:24] <buubot> Couldn't match input.

[04:24] <eternaleye> buubot: spack Signature

[04:24] <buubot> Couldn't match input.

[04:28] *** netfish joined
[04:41] *** justatheory left
[04:50] *** spx2 left
[04:51] *** jlaire joined
[05:00] <eternaleye> pmichaud: Since you seem to be up, and you know the specs pretty darn well, I'll ask you this: If i have a sub foo( *%bar *@baz ) {...}; how can I specify both via feed? %qux ==> foo <== @corge ?

[05:00] <eternaleye> s/r \*@/r, *@/

[05:01] <pmichaud> I'm not up-to-speed on the feed ops yet, sorry.

[05:02] <eternaleye> Okay

[05:30] *** justatheory_ left
[05:34] *** FurnaceBoy left
[05:43] *** rfordinal joined
[05:48] *** dukeleto joined
[05:56] *** cotto left
[05:57] *** nihiliad left
[06:03] *** frew left
[06:04] *** spx2 joined
[06:09] *** synth left
[06:15] *** rfordinal left
[06:27] *** amoc left
[06:35] *** twigil joined
[06:36] <moritz_> rakudo: sub a(*@x) { }; say &a.count

[06:36] <p6eval> rakudo 0e0671: OUTPUT«0␤»

[06:37] <moritz_> that's... confusing.

[06:38] *** simcop2387 left
[06:38] <moritz_> maybe a slurpy param should return a *

[06:38] <moritz_> and ($a, *@b) *+1

[06:42] *** huf left
[06:47] *** iblechbot joined
[06:50] <pugs_svn> r27214 | azawawi++ | [S:H:P6] version is 0.64 with included STD.pm that allows whitespacey 

[06:50] <pugs_svn> r27214 | azawawi++ | [S:H:P6] forms in rand(N) and [-1]

[06:53] *** araujo left
[07:01] *** xinming_ joined
[07:02] *** zamolxes left
[07:03] *** rfordinal joined
[07:04] *** rfordinal left
[07:06] *** xinming left
[07:13] *** dakkar joined
[07:13] *** agentzh left
[07:13] *** agentzh joined
[07:20] *** donaldh left
[07:20] *** donaldh joined
[07:23] *** viklund joined
[07:24] *** araujo joined
[07:28] *** jlmoko left
[07:34] *** Chillance joined
[07:45] *** jlmoko joined
[07:46] <pugs_svn> r27215 | azawawi++ | [S:H:P6] a better symbol table that identifies keywords/roles/grammars/classes/variables. No scope yet.

[07:46] *** japhb left
[07:48] *** pmurias joined
[07:49] *** japhb joined
[07:50] *** elmex left
[07:50] *** elmex joined
[07:52] <pugs_svn> r27216 | azawawi++ | [S:H:P6] our/my keywords into the symbol table...

[07:53] *** Molaf left
[07:53] *** Molaf joined
[07:56] *** _Chillance_ joined
[07:59] *** Chillance left
[08:06] *** xinming_ left
[08:06] *** xinming joined
[08:17] *** pmurias left
[08:21] <Matt-W> o/ #perl6

[08:21] *** pmurias joined
[08:21] <pmurias> rakudo: say \(1,2,3).elems

[08:21] <p6eval> rakudo 0e0671: OUTPUT«3␤»

[08:21] <pmurias> rakudo: say \(a=>1).elems

[08:21] <p6eval> rakudo 0e0671: OUTPUT«1␤»

[08:21] <pmurias> rakudo: say \(a=>1,2,3).elems

[08:21] <p6eval> rakudo 0e0671: OUTPUT«3␤»

[08:22] <pmurias> the Capture.elems returns the number of named arguments + positionals?

[08:22] <Matt-W> looks like it

[08:22] <Matt-W> Whether it's supposed to or not, I don't know

[08:24] <moritz_> we need much better specs for Capture

[08:24] <pmurias> say (\(1,2,3)).perl

[08:25] <pmurias> rakudo: say (\(1,2,3)).perl

[08:25] <p6eval> rakudo 0e0671: OUTPUT«[1, 2, 3]␤»

[08:25] <pmurias> ah

[08:25] <moritz_> rakudo: say (\(1,2,a => 5)).perl

[08:25] <p6eval> rakudo 0e0671: OUTPUT«[1, 2, "a" => 5]␤»

[08:25] <pmurias> moritz_: we need much better specs for most of the CORE roles

[08:25] <moritz_> ie it just constructs a list

[08:25] <moritz_> pmurias: aye

[08:29] * Matt-W reminds himself that a Capture is not the same as a Signature

[08:30] <pmurias> it's the exact oposite

[08:30] <pugs_svn> r27217 | azawawi++ | [S:H:P6] Beautify symbol table output

[08:30] *** azawawi joined
[08:30] <azawawi> hi

[08:31] *** huf joined
[08:33] <azawawi> moritz_: ping

[08:33] *** Su-Shee joined
[08:33] <Su-Shee> good morning

[08:33] *** [particle] left
[08:34] *** [particle] joined
[08:35] <moritz_> azawawi: pong.

[08:35] *** jaldhar left
[08:35] <Matt-W> pmurias: I'm not sure I'd say they're opposites... but they are different. I think. I need to read up on it again.

[08:35] *** jjore_ left
[08:36] *** DemoFreak joined
[08:36] <pugs_svn> r27218 | azawawi++ | [S:H:P6] Handle package declarations and add 'grammar' as keyword...

[08:37] *** cj left
[08:37] <azawawi> moritz_: an update on S:H:P6 output, http://gist.github.com/135751

[08:38] *** cj joined
[08:38] <moritz_> azawawi: that seems to be a bit more than a syntax hilighter

[08:38] *** jaldhar joined
[08:39] <azawawi> moritz_: exactly... for refactoring...

[08:40] *** jjore joined
[08:44] *** snarkyboojum joined
[08:48] *** cj left
[08:48] *** cj joined
[08:50] <pugs_svn> r27219 | azawawi++ | [S:H:P6] started to borrow from perl6.vim keyword classes...

[08:52] *** rfordinal3643 joined
[08:52] *** Gorbad left
[08:52] *** rfordinal3643 left
[08:53] <azawawi> moritz_: I noticed that in perl6.vim p6Module includes subset and enum; in std these are type_declarators not package_declarators

[08:55] *** amoc joined
[08:56] <pmurias> Matt-W: a signature receives a capture

[08:57] <moritz_> azawawi: does perl6.vim have a separate category for type declarators?

[08:57] <pugs_svn> r27220 | azawawi++ | [S:H:P6] a wider table and supports slang and module package_declarators

[08:57] <Matt-W> pmurias: Could it be considered to describe the structure of a capture it might want to receive?

[08:58] <moritz_> aye

[08:58] <azawawi> moritz_: As i far as i have seen, no.

[09:03] <literal> it might

[09:04] <literal> what exactly is a type declarator? my, our, let, temp?

[09:04] <rgs> C-minded people would call that a storage class

[09:04] <moritz_> no, these declare variables, not types

[09:05] <moritz_> basically module, class etc. all define types

[09:05] <moritz_> and enum and subset define types, but not package

[09:05] <literal> I grouped a few of those under the "p6Module" syntax group

[09:05] <moritz_> but for syntax hilighting I don't think there's much use distinguishing them

[09:05] <literal> namely: module, class, role, package, enum, grammar, slang, subset

[09:06] <azawawi> literal: subset, enum => type_declarator

[09:06] <literal> ok

[09:11] <pmurias> Matt-W: yes

[09:12] <pugs_svn> r27221 | pmurias++ | [re-smop] added Capture.named_count

[09:12] <pugs_svn> r27221 | pmurias++ | positionals can be passed through named parameters

[09:12] <pugs_svn> r27221 | pmurias++ | excess named arguments are not accepted

[09:22] *** azawawi left
[09:24] *** amoc__ joined
[09:24] *** amoc__ is now known as am0c

[09:29] *** rjh left
[09:33] <pmurias> moritz_: should i add ok(1) to 02-test-pm/1-basic.t?

[09:35] <moritz_> pmurias: I don't care for that directory for now

[09:35] <moritz_> I have no idea how much up-to-date it is

[09:36] <pmurias> do the tests for Test.pm live somewhere else now?

[09:36] <moritz_> there's no one official Test.pm, and it's not test officially either

[09:36] <moritz_> lunch &

[09:39] *** amoc left
[09:41] *** am0c left
[09:41] *** amoc joined
[09:46] *** maja_ joined
[09:46] <pugs_svn> r27222 | pmurias++ | [re-smop] named parameters are not required by default

[09:46] <pugs_svn> r27222 | pmurias++ | Signature handles all parameters in a generalised way

[09:47] <pugs_svn> r27223 | pmurias++ | [re-smop] update t/signature.t

[10:02] *** felipe joined
[10:08] <pugs_svn> r27224 | pmurias++ | [ere-smo] added &is to Test.pm

[10:08] <pugs_svn> r27224 | pmurias++ | copied over the part of test-pm/1-basic.t that already works

[10:10] *** amoc left
[10:11] *** iblechbot left
[10:15] *** dalek left
[10:15] *** dalek joined
[10:21] *** cj left
[10:22] *** xinming left
[10:29] *** payload left
[10:32] *** snarkyboojum_ joined
[10:33] *** xinming joined
[10:41] *** rjh joined
[10:41] *** snarkyboojum left
[10:52] *** lichtkind joined
[10:54] *** last joined
[10:55] *** araujo left
[10:56] *** rfordinal joined
[10:56] *** ejs joined
[11:04] <pugs_svn> r27225 | pmurias++ | [re-smop] nameless parameters don't have the .variable and .name

[11:04] <pugs_svn> r27225 | pmurias++ | attributes set, added S06-signature/positional.t to TESTS as it passes

[11:04] <pugs_svn> r27226 | pmurias++ | [re-smop] updated .gitignore

[11:05] *** netfish left
[11:12] *** iblechbot joined
[11:17] <moritz_> literal: grok changes should now be reported in here - please test it!

[11:18] <Infinoid> Oh, the suspense :)

[11:18] *** moritz_ sets mode: +o Infinoid

[11:19] *** kst` joined
[11:20] *** donaldh left
[11:21] *** donaldh joined
[11:28] <viklund> Is it possible to create match-objects (in rakudo)?

[11:28] <moritz_> only by matching, I think

[11:29] <moritz_> maybe with Match.new, but so far I haven't figured out what arguments to pass to it

[11:29] <viklund> hmm, would be nice if it was possible to do in some other way

[11:29] <moritz_> aye

[11:29] <viklund> I guess it's possible to write PIR for it...

[11:29] *** kst left
[11:30] <moritz_> then Match.perl would also be able to emit working Perl 6 code

[11:30] <viklund> yes

[11:44] *** masak joined
[11:49] *** iblechbot_ joined
[11:49] *** iblechbot left
[11:58] *** simcop2387 joined
[11:59] *** mizioumt joined
[11:59] <masak> 399 tickets!

[12:00] <moritz_> and today is pmichaud++'s bug squashing day?

[12:00] <masak> yeah.

[12:00] <masak> kinda puts the pressure on finding that last bug, no?

[12:00] <moritz_> http://www.braincells.com/perl/index.cgi?item=1245913315|1981 I like the term "darkmongers" ;-)

[12:04] <masak> the world is probably full of darkmongers.

[12:04] <moritz_> phenny, ask alester could you please give me enough privileges to delete spam comments on rakudo.org? (or clean it up yourself, if you have too much time ;-)

[12:04] <phenny> moritz_: I'll pass that on when alester is around.

[12:05] * masak hugs phenny

[12:09] <last> So, still trying to (slowly) track down why the 07-isa test fails on my Mac and 64-bit Linux platforms, I just ran valgrind while running some of the test scripts.  Appears that the parrot GC is throwing up lots of uninitialized value errors (including "conditional depends on").  Is this expected?

[12:09] <masak> in some instances, yes.

[12:10] <masak> parts of it are due to unimplemented features, I think.

[12:13] <last> Okay, I won't bother reporting that as a bug, then.

[12:13] <masak> dang. :)

[12:18] *** kidd_ left
[12:20] <pmurias> http://pmurias.livejournal.com/ # newest blog post

[12:21] <masak> pmurias++

[12:22] <moritz_> pmurias: would you consider adding your blog the ironman (http://ironman.enlightenedperl.org/) and perlsphere.net aggregators?

[12:23] <moritz_> more exposure would be great, IMHO

[12:23] <moritz_> and in both cases it's just sending a short a email

[12:25] *** murray joined
[12:26] *** murray left
[12:43] <moritz_> mildew: say 1, 2

[12:43] <p6eval> mildew: OUTPUT«Bareword found where operator expected at perl6-snapshot/STD.pm line 4, near "$LANG is"␤  (Missing operator before is?)␤Bareword found where operator expected at perl6-snapshot/STD.pm line 5, near "$PKGDECL is"␤   (Missing operator before is?)␤Bareword found where operator expected

[12:43] <p6eval> ..at…

[12:44] <masak> lichtkind: you keep referring to 'double colons' in your post http://use.perl.org/~perl6doc/journal/39171 -- but I see only single colons all the way. are you sure you mean 'double'?

[12:50] *** mizioumt1 joined
[12:52] *** exodist joined
[12:55] * TimToady stirs in his den

[12:55] <phenny> TimToady: 03:34Z <eternaleye> ask TimToady is there a specced way to find the nature (slurpy, named, etc) of the individual parameters in a Signature object? EVery single method in .^methods that I've tried just hands me back the whole signature, rather than something identifiable programmatically. The only solution I can see is to manually write a grammar to parse the .perl of the signature, which is decidedly icky.

[12:55] <phenny> TimToady: 03:42Z <eternaleye> tell TimToady nevermind, I seem to have simply overlooked the .params method. I think I may need new glasses.

[12:55] *** mizioumt left
[12:56] <TimToady> I suspect that .arity and .count are misnamed and/or misdesigned

[12:56] <TimToady> but shower and breakfast first... &

[12:56] *** cj joined
[12:58] <pmurias> moritz_: the build-smop.sh is likely not doing it's magic properly - i'm checking it out

[13:01] *** lichtkind left
[13:01] *** lichtkind joined
[13:05] *** exodist left
[13:08] <masak> std: [+] ;

[13:08] <p6eval> std 27226: OUTPUT«##### PARSE FAILED #####␤Unable to parse array composer; couldn't find final ']' at /tmp/LHmhR7PPrC line 1:␤------> [32m[+] [31m;[0m␤    expecting any of:␤       noun␤   prefix or meta-prefix␤FAILED 00:02 37m␤»

[13:10] *** finanalyst joined
[13:11] <pmurias> mildew: say 1

[13:11] <p6eval> mildew: OUTPUT«Bareword found where operator expected at perl6-snapshot/STD.pm line 4, near "$LANG is"␤  (Missing operator before is?)␤Bareword found where operator expected at perl6-snapshot/STD.pm line 5, near "$PKGDECL is"␤   (Missing operator before is?)␤Bareword found where operator expected

[13:11] <p6eval> ..at…

[13:11] <pmurias> mildew: say 1

[13:11] <p6eval> mildew: OUTPUT«Bareword found where operator expected at perl6-snapshot/STD.pm line 4, near "$LANG is"␤  (Missing operator before is?)␤Bareword found where operator expected at perl6-snapshot/STD.pm line 5, near "$PKGDECL is"␤   (Missing operator before is?)␤Bareword found where operator expected

[13:11] <p6eval> ..at…

[13:14] <pugs_svn> r27227 | pmurias++ | [evalbot] fixed path to mildew

[13:14] <pmurias> evalbot control restart

[13:14] *** p6eval left
[13:14] *** p6eval joined
[13:14] <pmurias> mildew: say 1

[13:14] <p6eval> mildew: OUTPUT«1␤»

[13:14] <pmurias> mildew: say 1,2

[13:15] <p6eval> mildew: OUTPUT«12␤»

[13:15] <moritz_> http://www.sdtimes.com/link/33566

[13:16] *** skids joined
[13:17] *** azawawi joined
[13:17] <azawawi> hi

[13:19] <azawawi> mildew: say "who are u?";

[13:19] <azawawi> mildew: 1;

[13:19] *** snarkyboojum_ left
[13:20] <azawawi> std: 1;

[13:20] <p6eval> mildew: OUTPUT«who are u?␤»

[13:20] <p6eval> mildew:  ( no output )

[13:20] <p6eval> std 27227: OUTPUT«ok 00:02 35m␤»

[13:20] <azawawi> mildew: 1;

[13:20] <azawawi> hmmm evalbot takes its time

[13:20] <p6eval> mildew:  ( no output )

[13:21] <moritz_> it's a weak machine, and mildew isn't optimized for speed

[13:21] *** cotto joined
[13:21] *** snarkyboojum joined
[13:21] *** spx2 left
[13:22] <azawawi> std: 1

[13:22] <p6eval> std 27227: OUTPUT«ok 00:02 35m␤»

[13:22] <azawawi> mildew: 1 == 1 ? 1 : 2;

[13:22] <p6eval> mildew: OUTPUT«##### PARSE FAILED #####␤Obsolete use of ?: for the conditional operator; in Perl 6 please use ??!! instead at /tmp/RCYcwpUGKj line 1:␤------> [32m1 == 1 ?[31m 1 : 2;[0m␤»

[13:22] <azawawi> ah std inside

[13:23] *** last left
[13:26] <lichtkind> moritz_: conspiracy

[13:26] *** [bjoern] joined
[13:26] * masak makes theremin sounds

[13:27] <azawawi> mildew: rand(10);

[13:27] <azawawi> mildew: rand( 10);

[13:27] <azawawi> mildew: rand(10 );

[13:27] <azawawi> mildew: rand( 10 );

[13:27] <[bjoern]> I take it rakudo does not support :keepall yet, what other options are there to make a grammar, match it against a string, and print out the parse tree in some form?

[13:28] <p6eval> mildew: OUTPUT«Could not find variable &rand in the lexical scope.␤»

[13:28] <p6eval> mildew: OUTPUT«Could not find variable &rand in the lexical scope.␤»

[13:28] <p6eval> mildew: OUTPUT«Could not find variable &rand in the lexical scope.␤»

[13:28] <p6eval> mildew: OUTPUT«Could not find variable &rand in the lexical scope.␤»

[13:28] <azawawi> mildew: 

[13:28] <masak> [bjoern]: that's the million-dollar question right now.

[13:28] <masak> [bjoern]: there's .chunks, which moritz_ seems to be championing now and then.

[13:28] <masak> [bjoern]: then there's .perl on Match objects, with some known bugs.

[13:29] <azawawi> mildew: module Foo::Bar { }; module Bar { };

[13:29] <masak> [bjoern]: I've yet to successfully traverse a tree of Match objects.

[13:29] <p6eval> mildew:  ( no output )

[13:29] <[bjoern]> That sounds unpromising

[13:29] <masak> [bjoern]: by all means, try a few things.

[13:29] <masak> I might have missed something obvious.

[13:30] <moritz_> well, I managed to break up a parse tree into a flat stream of tokens

[13:30] <azawawi> mildew: module Foo::Bar { }; module Bar { };

[13:30] <p6eval> mildew:  ( no output )

[13:30] <moritz_> but you're better off if you construct your data structures from action methods directly, instead of first building the parse tree and then traversing it

[13:31] <azawawi> mildew: module Bar { }; module Bar { };

[13:31] <azawawi> mildew: package A; package B;

[13:31] <p6eval> mildew:  ( no output )

[13:31] <p6eval> mildew: OUTPUT«##### PARSE FAILED #####␤Malformed "package" declaration␤Unable to parse package definition at /tmp/CjTsGOnL6f line 1:␤------> [32mpackage A; package B[31m;[0m␤    expecting any of:␤ trait␤  whitespace␤»

[13:32] <azawawi> pmurias: so mildew has the latest std inside. pmurias++. Very nice.

[13:33] <[bjoern]> Well I am a bit more interested in playing with Rules to learn them, and getting a parse tree would make inspecting results that much easier; I care little about building my own data structures

[13:33] <masak> [bjoern]: then .perl is for you.

[13:34] <moritz_> aye, IMHO that's still very helpful

[13:34] <pmurias> azawawi: actually the std parser in mildew is rather oldish

[13:34] <masak> rakudo: 'foo' ~~ /foo/; say $/.perl

[13:34] <p6eval> rakudo 0e0671: OUTPUT«Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ ast  => "foo",␤ Str => "foo",␤ from => 0,␤ to   => 3,␤)␤»

[13:34] <[bjoern]> Okay I'll try a few things with .perl then

[13:34] <azawawi> pmurias: how old?

[13:36] <pmurias> checking...

[13:36] <moritz_> it looks much nicer on a normal terminal, with line breaks and indentation

[13:37] *** xinming_ joined
[13:37] *** synth joined
[13:38] <pmurias> azawawi: 2009-03-31

[13:41] <pmurias> azawawi: viv's output was changing a lot right then so i took a snapshot (i think it was brokenish at some point) and it was good enough till now

[13:41] <TimToady> std: package; package;

[13:41] <p6eval> std 27227: OUTPUT«Undeclared routine:␤   package used at 1 1 ␤ok 00:02 35m␤»

[13:42] <TimToady> std: package A; package B;

[13:42] <p6eval> std 27227: OUTPUT«##### PARSE FAILED #####␤Too late for semicolon form of package definition at /tmp/QRZHg8JYai line 1:␤------> [32mpackage A; package B[31m;[0m␤    expecting any of:␤     trait␤   whitespace␤FAILED 00:02 35m␤»

[13:42] <TimToady> before you get too carried away inventing symbol tables, STD is pretty close to being able to emit those with proper scoping

[13:44] <TimToady> and then CORE.pad will be autogenerated from CORE.pm

[13:44] <pmurias> TimToady: that was aimed at azawawi's project?

[13:44] <TimToady> mostly :)

[13:44] *** ejs left
[13:45] *** xinming left
[13:45] <pmurias> TimToady: would it be worth switching mildew to the newest STD?

[13:46] <TimToady> pretty soon

[13:50] *** zpmorgan left
[13:51] <TimToady> actually, CORE.pad would then probably turn into CORE.yaml or some such

[13:52] *** snarkyboojum left
[13:52] <TimToady> but at the moment I'm still chasing the [+] bug

[13:53] <TimToady> it's driving me insane(r)

[13:53] *** FurnaceBoy joined
[13:53] *** ejs joined
[13:55] <masak> so it turns out '[+]' was a statement after all. that's actually quite funny.

[13:55] <masak> rakudo: [+]

[13:55] <p6eval> rakudo 0e0671: OUTPUT«Syntax error at line 2, near "[+]"␤in Main (src/gen_setting.pm:0)␤»

[13:55] * masak submits rakudobug

[13:55] <TimToady> it should parse just like 'print'

[13:55] <masak> yes! \o/

[13:55] <[bjoern]> If I have something like grammar Test { regex A { a }; regex B { <A> }; regex C { <Test::A> } ... }; why is the capture in B named "A" and not "Test::A" (as it would be in C)? If they are invoked via /<Test::B>/ you get the prefix in the outermost capture but not in the others.

[13:56] <moritz_> .oO( maybe we should register insaner.org as a domain for a perl 6 blog aggegator/rater like digg :-)

[13:56] <moritz_> std: print

[13:56] <p6eval> std 27227: OUTPUT«ok 00:02 35m␤»

[13:56] <moritz_> TimToady: shouldn't bare 'print' be a syntax error?

[13:56] <TimToady> a semantic error, but not a syntax error

[13:56] <masak> moritz_: I really like that idea.

[13:57] <TimToady> and in fact [*] should return 1

[13:57] <moritz_> TimToady: then S16 or S32 or so is out of date

[13:57] <moritz_> rakudo: print

[13:57] <p6eval> rakudo 0e0671: OUTPUT«print requires an argument at line 2, near ""␤in Main (src/gen_setting.pm:2416)␤»

[13:57] <moritz_> [bjoern]: generally the capture is named the same way as the rule you're calling

[13:58] <moritz_> if you call it as Test::B, then it's Test::B

[13:58] <moritz_> if you mean B, say B

[13:59] <moritz_> when you have multiple inheritance of two grammars, are tokens of the same name resolved by matching an alternation of them?

[13:59] *** twigil left
[14:00] <masak> ...and, if so, is that specced? are there spectests?

[14:00] <moritz_> I don't think I've read about grammar mi

[14:02] <pmurias> rakudo: say;

[14:02] <p6eval> rakudo 0e0671: OUTPUT«say requires an argument at line 2, near ";"␤in Main (src/gen_setting.pm:2416)␤»

[14:02] <pmurias> rakudo: say 1,2;

[14:02] <p6eval> rakudo 0e0671: OUTPUT«12␤»

[14:02] <pmurias> why does say require an argument?

[14:02] <moritz_> because it's specced that way :-)

[14:02] <moritz_> to warn those who still think it defaults to $_

[14:03] <[bjoern]> My question was more like, why is it better to name the captures after the references rather than their resolved names; how the subrules are invoked strikes me more as an implementation detail, and if one were to traverse the match object using the names, you would have to depend on an implementation detail.

[14:04] <moritz_> [bjoern]: when you see a regex, you don't see the resolved names, so you'd have to think harder to know what the name of the capture is

[14:04] <moritz_> it forces you to do the job that your compiler is supposed to do

[14:04] *** bionoid left
[14:05] <huf> is the logo really a butterfly? *really*?

[14:06] <masak> huf: really.

[14:06] <moritz_> ;-)

[14:06] <TimToady> a call to <subrule> resolves like any other method, unless it's a category, in which case it does LTM across all subrule:sym variants

[14:06] <TimToady> we want to brainwash the 3-year-old girls into becoming programmers someday

[14:07] <TimToady> but that's one tough butterfly

[14:07] <TimToady> 3-meter wingspan

[14:07] <huf> i'm kinda trying to teach my sister perl5

[14:07] <TimToady> larval form was a camel

[14:07] <huf> havent progressed far yet

[14:07] <Su-Shee> probably more effient but other methods to get more women into computing. ;))

[14:07] <TimToady> show her the butterfly, and hope for the butterfly effect

[14:07] <sbp> dinofly

[14:08] <TimToady> http://www.cafepress.com/cp/moredetails.aspx?showBleed=false&ProductNo=391273958&pr=F

[14:08] <moritz_> whoa

[14:08] <moritz_> I need that as a T-Shirt

[14:09] <Su-Shee> make it two. :)

[14:09] <masak> nice font.

[14:09] <TimToady> http://www.cafepress.com/rakudo.391291260

[14:09] *** a3r0 joined
[14:10] <PerlJam> what happens if Camelia is really in a pupal stage now (with a really large chrysalis that includes us and the rest of the world)?

[14:10] <Su-Shee> hm, my perl memorabilia are all perl5 still.. 

[14:10] <TimToady> well, I think Camelia actually is still about to hatch out of her chrysalis

[14:11] <TimToady> she's been in there a long time

[14:11] <moritz_> hm, that page has an option to show prices in EUR, but it doesn't work :(

[14:11] <TimToady> masak: thanks, Geneva and I picked it together

[14:12] <masak> it works for this. looks like a programming language talking.

[14:12] <PerlJam> TimToady: Really?  From my perspective she's only gotten through the first 90%.  It's that second 90% that's a doozy.

[14:12] <TimToady> I think we're well into the second 90%

[14:12] <masak> I don't know what you people are mumbling about. to me, Perl 6 is already out there. I use it every day.

[14:13] <TimToady> I'm just hoping there isn't a 3rd 90%

[14:13] <sbp> .gcs dinofly dynamofly

[14:13] <phenny> dinofly (3,750), dynamofly (16)

[14:14] <sbp> wait. dinopter would be perfect

[14:14] <sbp> 3ft wingspan... terrible wing. perfect

[14:14] <[bjoern]> So let's say I make a Regexp::Common-like package to parse http://... URLs; users would include my module and do, say, "http://example.org" ~~ /<Grammar::URI::http>/; there would be a subrule, say, "host" which initially I define as part of my package;

[14:14] <[bjoern]> Later someone makes a Grammar::URI::Generic package which also defines a "host" rule; I update Grammar::URI::http to reference <Grammar::URI::Generic::host> instead of my own.

[14:14] <[bjoern]> It seems users of my module would then get a capture named Grammar::URI::Generic::host and not "host", for the host component, so this change in my Grammar::URI::http module may break other people's code. Do I have that right?

[14:15] <PerlJam> Maybe I should recalibrate, but while perl6 is "out there", it's only out there for early adopters.   ergo it still feels to me, like we've got a good chunk of the second 90% to go.

[14:15] <moritz_> Su-Shee: which size?

[14:15] *** macae joined
[14:15] <TimToady> masak: yes, we looked at maybe 200 fonts that Geneva has collected; that was the most computery looking font that didn't look outdated or overused, and made the S's stand out correctly

[14:16] <Su-Shee> moritz_: M - but I'd like it in black. :)

[14:16] <moritz_> Su-Shee: you're in Germany?

[14:16] <TimToady> unfortunately, I don't remmeber the name of the font offhand

[14:17] <Su-Shee> moritz_: yes. 

[14:17] <TimToady> maybe pmichaud remembers

[14:17] <PerlJam> [bjoern]: perhaps think of rules more like subroutines.  How is the analgous problem solved there? 

[14:17] <TimToady> they're really methods, not subroutines

[14:18] <TimToady> the invocant always represents the current language+matchstate

[14:18] <PerlJam> well, no matter how you think of them, there's 7 ways to solve the problem  :)

[14:18] <moritz_> Su-Shee: well, I don't see an option to order it in black - am I missing something? or do we have to convince TimToady/pmichaud of creating a black version?

[14:19] <moritz_> [bjoern]: you can always alias the rules

[14:19] <moritz_> so if you want to change it from <host> to <Foo::host>, you actually change it to <host=Foo::host>

[14:19] <[bjoern]> Well if the fact that I initially had <host> in my grammar is part of the public interface, I would have to alias "host" and Grammar::URI::Generic::host of course

[14:19] *** jhorwitz joined
[14:19] <moritz_> thus preserving the interface

[14:19] <moritz_> the <alias=rulename> syntax is very convenient for that.

[14:19] <TimToady> for Cafe Press we'd probably have to arrange to have a subtle border around it, though Camelia herself works as an icon on a black background, since the color fills out most of where the wings are

[14:20] * PerlJam wonders what Camelia looks like color-inverted

[14:22] <TimToady> well, we could always claim that she can change here wing colors at will

[14:22] <TimToady> the original Camelia didn't have black wings, in fact

[14:23] <[bjoern]> (the subroutine analogy was not very helpful, if I had sub host { ... } I would change it to sub host { generic::host ... } which would not affect the caller, but changing rule host { ... } to rule host { <generic::host> } would, I think)

[14:23] <[bjoern]> But I guess for now I'll just accept that rule references are in essence public api, then

[14:23] <[bjoern]> (the details of those references, that is)

[14:25] <PerlJam> [bjoern]: you have the option to capture or not on <generic::host>  (i.e., make that part of the interface or not)

[14:26] *** finanalyst left
[14:27] <TimToady> for the original camelia see http://wall.org/~larry/cameliagreen.pdf

[14:28] <[bjoern]> (The difficulty is more realizing that it makes a difference whether you reference Grammar::Rule as <Rule> or <Grammar::Rule> than with dealing with the consequences, I think)

[14:28] <moritz_> since you test your code, you notice that pretty quickly ;-)

[14:29] <TimToady> the fact that Grammar::Rule was called is more in the province of the action routine that automatically fires off when that method reduces

[14:30] <moritz_> I think the real difficulty will be to appropriately document the order of captures etc. without having to show the whole source code

[14:30] *** azawawi left
[14:30] <PerlJam> "order of captures"?

[14:30] <moritz_> that's maybe the wrong term

[14:31] <moritz_> more like, which captures are optional, contain arrays under what condition etc.

[14:31] <[bjoern]> the structure of the parse tree

[14:31] <moritz_> right

[14:31] <TimToady> "contain arrays" is generally lexically determined by * or by <foo> <foo>

[14:31] <PerlJam> ah.  yes, that might be a tad difficult ... if we didn't have Perl there to help us  ;-)

[14:31] <PerlJam> TimToady: it's that <foo>? one that always gets me though.

[14:32] <PerlJam> (you'd think I'd learn, but apparently I have a blind spot there or something)

[14:32] <TimToady> it's more consistent this way, at least in how the thing is stated: any quantifier...

[14:32] <PerlJam> yes, I agree.  It still trips me up.

[14:33] *** icwiener joined
[14:34] <TimToady> I wonder to what extent we can make an array of one element delegate Matchness to that element

[14:34] <moritz_> please not by stuffing more behaviour into Array

[14:34] <TimToady> it already does ~@a and /@a/ correctly, I think

[14:35] <sbp> hmm. the closest I can come to cameliagreen.pdf (top) in unicode is: «☺͈̎»

[14:35] <sbp> if there are combining double quotes above and below, I cannot find them

[14:35] <TimToady> where does the trip-up actually show up in symptoms?  Usually in trying to call a method that is defined on Capture/Match but not on Array

[14:36] <PerlJam> right

[14:36] <TimToady> sbp: that image cheats, actually

[14:38] *** icwiener_ joined
[14:38] <masak> I've done the following error a few times in the past year: `for $match<submatch> -> $match` -- $match<submatch> turns out not to exist -- I get one iteration over Failure.

[14:38] <sbp> whoops, and I didn't notice the wings were obviously the other way around. »☺͈̎«

[14:38] <TimToady> and that certainly doesn't render in any terminal that screws up overstriking, as most of them do

[14:38] * sbp won't attempt to do (bottom) in unicode... :-)

[14:38] <moritz_> masak: that's a rakudobug

[14:39] <moritz_> masak: because it shouldn't stuff undef into it, but Nil

[14:39] <sbp> even Firefox and Safari don't render multiple combiners properly

[14:39] <masak> moritz_: ah, that's good news.

[14:39] <moritz_> masak: so the for-loop should simply iterate 0 times, afaict

[14:39] <masak> aye.

[14:40] *** iblechbot_ left
[14:40] *** leedo left
[14:42] *** leedo joined
[14:43] <TimToady> in my experience xterm does the best at overstriking currently, which is funny

[14:44] <TimToady> there's some kind of inverse relationship between glitz and functionality 

[14:45] <moritz_> IME xterm doesn't care about bidi properties

[14:45] <moritz_> don't know if that's a good thing

[14:47] <Su-Shee> "terminal" works fine for unicode, input methods and bidi.

[14:49] <TimToady> and kterm really screws it up

[14:49] <TimToady> it turns the above into 損財彩ﾍ束

[14:50] <TimToady> it's probably interpreting utf-8 as utf-16 or some such

[14:50] *** alexn_org joined
[14:50] *** jlmoko left
[14:50] <masak> encodings are hard!

[14:51] <TimToady> or maybe it's assuming I'm Japanese...

[14:51] <moritz_> at least encodings appear to be hard

[14:53] <TimToady> oh, wait, kterm is kanji term, not kde, duh

[14:54] <Su-Shee> konsole is KDE's term.

[14:54] *** icwiener left
[14:54] <viklund> \O/

[14:54] <viklund>  |

[14:54] <[bjoern]> is <[\x[20ac] .. \x[20ff]]> the best (brief, readable) syntax for a unicode character range if you do not want to specify the characters literally?

[14:55] <Su-Shee> [bjoern]: specific ranges have human readable names, don't know wether or not they are already know to perl6.

[14:55] <masak> viklund: for some reason, you reminded me of this: http://bash.org/?4281

[14:55] <[bjoern]> entirely user defined ranges

[14:55] *** icwiener_ is now known as icwiener

[14:56] <moritz_> yes

[14:56] <[bjoern]> thanks

[14:56] <viklund> :)

[14:56] <TimToady> looks like konsole throws away the overstrikes

[14:57] <TimToady> shouldn't need the square brackets, in theory

[14:57] <TimToady> the inner ones, that is

[14:57] *** _Chillance_ left
[14:58] *** _Chillance_ joined
[14:58] <moritz_> rakudo: say ?(chr(:16<20bb>) ~~ / <[ \x20ac .. \x20ff ]> /)

[14:58] <p6eval> rakudo 0e0671: OUTPUT«1␤»

[14:58] <moritz_> s/theory/theory and practise/ # ;-)

[14:58] <pmichaud> Good morning, #perl6

[14:58] <moritz_> oh hai pmichaud 

[14:59] <TimToady> howdy doody

[14:59] <viklund> ...

[14:59] <TimToady> eek, I'm starting to sound like Dan again :)

[14:59] <masak> helo pm

[14:59] <pmichaud> ehlo masak :-)

[14:59] <masak> :)

[14:59] <masak> pmichaud: 400 tickets! :)

[15:00] <pmichaud> masak:  not for long!  :)

[15:00] <viklund> masak: have you found that bug yet?

[15:00] <masak> viklund: yup.

[15:00] <viklund> ahh, nice

[15:00] <TimToady> pmichaud: are you checked out of your hostel yet? you can dump luggage here...

[15:00] <masak> viklund: [+] oughta parse as a statement.

[15:00] <viklund> oh

[15:00] <moritz_> ;-)

[15:00] <masak> viklund: quote amusing after yesternight's discussion :)

[15:00] *** payload joined
[15:00] <TimToady> but I haven't made STD parse it right yet...

[15:00] <viklund> quite?

[15:01] <masak> quite, even. thanks.

[15:01] <viklund> then, yes

[15:01] <masak> quote amusing: "amusing"

[15:01] <TimToady> I think I need to teach EXPR to allow a nulltermish after a prefix op

[15:01] <moritz_> std: ~

[15:01] <TimToady> the other listops actually cheat and parse as terms

[15:02] <p6eval> std 27227: OUTPUT«##### PARSE FAILED #####␤Can't understand next input--giving up at /tmp/WRJcpVPhIO line 1:␤------> [32m[31m[0m␤    expecting noun␤FAILED 00:02 37m␤»

[15:02] <masak> TimToady: so [+] is a prefix op, but it still works like a listop?

[15:02] <TimToady> supposed to

[15:02] <masak> so some prefix ops are listops, and some are not?

[15:02] <TimToady> most are not listops

[15:02] <TimToady> depending on how you define "most"

[15:02] <PerlJam> std: [+]

[15:03] <p6eval> std 27227: OUTPUT«##### PARSE FAILED #####␤Unable to parse array composer; couldn't find final ']' at /tmp/oEJyvBE6bv line 1:␤------> [32m[31m[0m␤    expecting noun␤FAILED 00:02 37m␤»

[15:03] <TimToady> fails over to array composer parser

[15:03] <TimToady> unlike ~

[15:03] <PerlJam> That seems like a failure of LTM to me since it's interpreting that as an array composer.

[15:03] <TimToady> reduce operators are the one of two places in the grammar that rely on backtracking

[15:04] <PerlJam> ah

[15:04] <TimToady> originally I tried to shoehorn reduce into LTM, but got exponential explosion in the LTM tables

[15:04] <viklund> ouch

[15:05] <TimToady> [>>[XR>>+=<<]<<]

[15:05] <TimToady> not to mention

[15:05] <TimToady> [>>[XR>>+=<<]<<]<<

[15:06] *** nihiliad joined
[15:06] <pmichaud> TimToady: (1)  Where's "here"?

[15:07] <TimToady> so nowadays the different meta-bits are parsed as separate tokens, and if we can parse to the ] as an infix without spaces, it's assumed to be a reduce, not an array composer

[15:07] <TimToady> resnik 580

[15:07] <pmichaud> TimToady: (2)  I'm actually departing tomorrow.  Tonight my wife arrives and we're taking a trip from there.

[15:07] <pmichaud> (so I'm still in my hotel until tomorrow morning)

[15:07] <TimToady> oh, I thought you were leaving tonight

[15:07] <TimToady> okay

[15:07] <TimToady> maybe it was two other people

[15:08] <TimToady> anyway, you're welcome to hang out here

[15:08] <TimToady> I haven't looked down the hall to see if there are any other hackathoners in the lounge

[15:09] <TimToady> maybe I'll wander down there now

[15:09] <[bjoern]> What's wrong with   regex LWSP { (<WSP> | <CRLF> <WSP>){0,1} };  ? Rakudo gives me "Statement not terminated properly"

[15:09] <TimToady> std: regex LWSP { (<WSP> | <CRLF> <WSP>){0,1} };

[15:09] <p6eval> std 27227: OUTPUT«ok 00:03 38m␤»

[15:09] <TimToady> heh

[15:10] <TimToady> well, quantifier syntax is ** 0..1 now

[15:10] <pmichaud> I think I misled you last night in my phrasing :-)

[15:10] <TimToady> I'm easily misled

[15:10] *** ejs left
[15:10] <pmichaud> I'm currently in the university center common area, but the wireless has been spotty.  Seems okay now.

[15:10] <TimToady> and rakudo only catches it because it doesn't implement closures yet

[15:10] <TimToady> been rock solid here

[15:11] <[bjoern]> Ah, I grepped S05 for the syntax, and didn't see the m:P5// in the example...

[15:11] <pmichaud> If people start to congregate in a lounge somewhere I'll move there.

[15:11] *** last joined
[15:11] <TimToady> checking... &

[15:12] <pmichaud> rakudo:   say  "hello" ~~ / \w ** {3..4} /

[15:12] <p6eval> rakudo 0e0671: OUTPUT«hell␤»

[15:12] <pmichaud> (it recognizes closure syntax when the closure contains a constant range :-)

[15:12] <moritz_> aka "it cheats"

[15:13] <pmichaud> aka "it cheats", yes.

[15:13] <TimToady> nobody in the 5th floor lounge yet...

[15:13] <TimToady> could be off in one of the rooms though

[15:13] <pmichaud> there are quite a few in uc lounge (outside of "Entropy") at the moment

[15:14] <TimToady> are there plugs out there?

[15:14] *** rfordinal left
[15:14] <pmichaud> yes

[15:15] <TimToady> well, maybe I'll wander down then

[15:15] *** christine joined
[15:15] <TimToady> unless everyone else decides to wander up, but there's more coffee down there :)

[15:15] <pmichaud> I also heard there's some hackathoning on 3rd floor resnik

[15:15] <pmichaud> yes, more coffee.  also not quite as cramped.

[15:16] <TimToady> I'll wander down then

[15:19] *** masak left
[15:19] *** d4l3k_ joined
[15:19] *** baest_ joined
[15:20] *** donaldh left
[15:20] *** lichtkind_ joined
[15:20] *** ejs joined
[15:20] <[bjoern]> Okay, now I have a working grammar; It's automatically generated with lots of redundant white space, bad indentation, etc.; any way to pretty print the code?

[15:20] *** donaldh joined
[15:20] *** lichtkind left
[15:20] *** dalek left
[15:20] *** pmurias left
[15:20] *** s1n left
[15:20] *** baest left
[15:20] *** Khisanth left
[15:20] *** sjohnson left
[15:20] *** avar left
[15:20] *** lichtkind_ is now known as lichtkind

[15:20] <moritz_> I know none

[15:21] *** d4l3k_ is now known as dalek

[15:21] <moritz_> std: $*FOO

[15:21] <p6eval> std 27227: OUTPUT«ok 00:02 36m␤»

[15:22] *** avar joined
[15:26] *** maja_ left
[15:26] <[bjoern]> lisppaste3: url?

[15:26] <lisppaste3> To use the lisppaste bot, visit http://paste.lisp.org/new/perl6 and enter your paste.

[15:27] <lisppaste3> [bjoern] pasted "Quick and dirty RFC 3986 (URI) grammar" at http://paste.lisp.org/display/82493

[15:28] <moritz_> [bjoern]: nice. Would you consider setting that up as a git repo, for example?

[15:28] <dalek> rakudo: c7ff050 | pmichaud++ | docs/spectest-progress.csv:

[15:28] <dalek> rakudo: spectest-progress.csv update: 405 files, 11548 passing, 4 failing

[15:28] <dalek> rakudo: Failure summary:

[15:28] <dalek> rakudo:     S12-enums/basic.rakudo 27 - short name of the enum without parenthesis is an enum

[15:28] <dalek> rakudo:     S32-num/rand.t aborted 3 test(s)

[15:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c7ff050a032c94c2f1e32f31d39d03f803c14a2b

[15:28] <viklund> another URI.pm?

[15:28] <viklund> oh well...

[15:29] <moritz_> is the other one closely modeled after that RFC?

[15:29] <PerlJam> viklund: strength through diversity :)

[15:29] <viklund> looks like this is the biggest one so far

[15:29] <viklund> I don't think so

[15:29] <moritz_> it can be simplified

[15:29] <moritz_> for example ** 0..* is simply *

[15:30] <[bjoern]> I could add a ABNF->Perl6 conversion script to the examples for http://search.cpan.org/dist/Parse-ABNF/

[15:30] <moritz_> [bjoern]: that would be nice

[15:30] <PerlJam> a perl6 version would be nice too

[15:30] <viklund> ihrd has a URI on github

[15:30] <[bjoern]> Parse::ABNF has an example script that converts to XML, I just wrote an XSLT that turns the XML into what I've pasted...

[15:31] <viklund> I don't know anything about it though

[15:31] <viklund> I guess it's derivative of the November URI grammar he made

[15:31] <viklund> http://github.com/ihrd/uri/

[15:32] <viklund> it seems he tried to model it after the RFC

[15:33] <viklund> PerlJam: yes, timtwtdi

[15:33] <TimToady> viv -6 could be turned into a pretty printer relatively easily

[15:33] <viklund> oops, forgot an 'o'

[15:33] <viklund> good work [bjoern]!

[15:33] <pmichaud> http://rt.perl.org/rt3 only shows 398 tickets.  :-|

[15:34] <pmichaud> but yes, my other query shows 400.

[15:34] <moritz_> yes, I've rejected one and closed one

[15:34] *** ejs left
[15:34] <pmichaud> ah.

[15:35] *** Khisanth joined
[15:48] *** araujo joined
[15:52] *** dakkar left
[15:55] *** justatheory joined
[16:01] <Matt-W> Does Rakudo yet have the facilities in place for me to programatically generate subroutines and insert them into the symbol table?

[16:02] <moritz_> with eval, yes

[16:03] <moritz_> rakudo: my &a := sub { say "foo" }; a()

[16:03] <p6eval> rakudo c7ff05: OUTPUT«foo␤»

[16:03] <moritz_> or like that ;-)

[16:03] <Matt-W> that'll do nicely :)

[16:03] <Matt-W> I think

[16:03] <moritz_> I don't know if variable names work without eval

[16:06] <pmichaud> moritz_: how do you mean?  Seems like they should work.

[16:06] <Matt-W> What about if I want to give it a name I'm constructing on the spot...

[16:06] <moritz_> pmichaud: I mean if you have a variable $a holding the name of the subroutine you want to install

[16:06] <Matt-W> yes that :)

[16:07] *** FurnaceBoy left
[16:07] <moritz_> pmichaud: exit; still doesn't work on the repl, for me

[16:10] *** jhorwitz_ joined
[16:11] <[bjoern]> [...] is the new (?:...) while (...) is still (...) in rules?

[16:11] <Matt-W> yes

[16:13] *** viklund_ joined
[16:15] <Matt-W> rakudo: my $a = "foo"; my &($a) = sub { say "foo"; }; foo();

[16:15] <p6eval> rakudo c7ff05: OUTPUT«Malformed declaration at line 2, near "&($a) = su"␤in Main (src/gen_setting.pm:0)␤»

[16:15] <Matt-W> rakudo: my $a = "foo"; my &::($a) = sub { say "foo"; }; foo();

[16:15] <p6eval> rakudo c7ff05: OUTPUT«Malformed declaration at line 2, near "&::($a) = "␤in Main (src/gen_setting.pm:0)␤»

[16:15] <Matt-W> awww

[16:15] <Matt-W> As far as I can see, that should work

[16:17] <Matt-W> rakudo: my $a = "foo"; my $::($a) = "hello"; $foo.say;

[16:17] <p6eval> rakudo c7ff05: OUTPUT«Malformed declaration at line 2, near "$::($a) = "␤in Main (src/gen_setting.pm:0)␤»

[16:17] <Matt-W> guess it's just not supported yet

[16:17] <pmichaud> we don't do namespace interpolation yet, sorry.

[16:17] * Matt-W sniffles

[16:18] <pmichaud> I hadn't even thought about lvalued namespace symbols, though :-(

[16:19] <Matt-W> People will be wanting that

[16:19] <Matt-W> People other than me, that is

[16:19] <moritz_> Matt-W: what do you need it for right now?

[16:20] *** azawawi joined
[16:20] <Matt-W> moritz_: I want a module to generate a bunch of similar-but-different subroutines based on a list of things

[16:20] *** pmurias joined
[16:20] *** baest joined
[16:20] *** sjohnson joined
[16:20] *** s1n joined
[16:22] <Matt-W> moritz_: at this stage I would accept being able to do it for methods of a class (in fact that might turn out to be preferable, but I need to experiment with actually using stuff to decide that)

[16:22] *** mofino joined
[16:22] <[bjoern]> Is it possible to adment previously defined rules in a grammar, ala, grammar Test { rule foo { foo1 }; rule foo { foo2 } } where Test::foo = foo1 | foo2? (ABNF grammars may use ... foo = foo1 ... foo /= foo2 ... to this effect; it would be nice to avoid merging them into a single rule)

[16:23] <moritz_> Matt-W: you could emulate that with an attribute and handles

[16:23] <moritz_> Matt-W: the 'handles' can use a hash or a closure to dispatch

[16:23] <Matt-W> hmm

[16:24] <moritz_> [bjoern]: I don't quite understand what you want... if foo is always an alternation of foo1 and foo2, you can use categories (though not yet implement in Perl 6)

[16:25] <moritz_> for most other kind of mutations you can use inheritance

[16:25] <moritz_> s/Perl 6/Rakudo/

[16:26] *** jhorwitz left
[16:28] *** a3r0 left
[16:28] *** rjh left
[16:28] <[bjoern]> Putting it differently, I'd want to write grammar Test { rule foo { foo1 | foo2 } } as grammar Test { rule foo { foo1 } ... rule foo { foo2 } } with whatever sugar necessary.

[16:28] <TimToady> you can't add symbols to the lexical pad at run time, but you can say:

[16:28] <TimToady> std: my sub foo { say "hi" }; my &bar := &::('&foo'); bar()

[16:28] <[bjoern]> In RELAX NG you could do something like <define name='foo'>foo1</define> ... <define name='foo' combine='choice'>foo2</define>. In ABNF foo = foo1 ... foo /= foo2 ... as above

[16:28] <p6eval> std 27227: OUTPUT«ok 00:04 49m␤»

[16:28] <TimToady> (not supported by rakudo yet though)

[16:29] <Matt-W> you can't? oh.

[16:29] <TimToady> MY shuts down at the end of compiling that block

[16:29] *** rjh joined
[16:29] <moritz_> [bjoern]: what does /= mean?

[16:30] <TimToady> it's only modifyable while it's aliased to COMPILING

[16:30] <[bjoern]> A = B ... A /= C is the same as A = B / C

[16:30] <Matt-W> what about other places, like class methods?

[16:30] <moritz_> what is / ?

[16:30] <[bjoern]> alternation

[16:30] <moritz_> ah.

[16:31] <moritz_> well, you can always subclass you grammar, and define token A { <B> | <C> }

[16:31] <moritz_> in the child class

[16:33] *** netfish joined
[16:33] <[bjoern]> I take it the short answer is that there is currently no way to write it like that, I have to collect all the definitions first, and then merge them before converting them to a perl6 grammar

[16:35] <pmichaud> [bjoern]: you're looking for protoregexes

[16:36] <Matt-W> TimToady: I can't add to the lexical pad at runtime, can I add symbols at the package level?

[16:36] <pmichaud> protoregexes allow multiple definitions to be combined into a single rule name

[16:37] <[bjoern]> so something like grammar { proto regex foo { foo1 }; proto regex foo { foo2 }; } ?

[16:37] <pmichaud> close

[16:38] <pmichaud> it follows the categories item that moritz mentioned a little earlier

[16:38] <TimToady> Matt-W: sure, but routines won't be visible to multi dispatch if they're in a package

[16:38] <pmichaud> I don't recall the exact syntax at the moment (because Rakudo hasn't implemented them yet)

[16:38] <moritz_> [bjoern]: http://svn.pugscode.org/pugs/src/perl6/STD.pm contains examples

[16:39] <[bjoern]> Thanks, I guess I will come back to that later.

[16:39] <Matt-W> TimToady: but it's okay if they're not multis?

[16:39] <pmichaud> [bjoern]: it'd be something like

[16:39] <pmichaud> proto rule foo { }

[16:39] <pmichaud> proto rule foo:a { <A> }

[16:39] <pmichaud> proto rule foo:b { <B> }

[16:40] <pmichaud> er

[16:40] <pmichaud> change those last two "proto" to "multi"

[16:40] <moritz_> with "proto" only in the first line

[16:40] <moritz_> pmichaud: multi is not necessary if there's a proto

[16:40] <pmichaud> right.

[16:40] <pmichaud> as I said, I haven't written a bunch of these yet :-)

[16:41] <moritz_> pmichaud: would you benefit from a bunch of LTM and tie-breaking tests?

[16:42] <pmichaud> I don't understand the question, sorry.

[16:42] <pmichaud> oh, you mean tests in the suite

[16:43] <pmichaud> yes.

[16:43] <pmichaud> that would be helpful.  But I'm still a few weeks from that point.

[16:43] <pmichaud> (although I do see light at the end of the tunnel there)

[16:46] *** lichtkind_ joined
[16:46] *** cotto left
[16:46] *** Psyche^ joined
[16:46] <pugs_svn> r27228 | azawawi++ | [S:H:P6] sym table has methods/routines along with p6Parameters...

[16:46] *** Patterner left
[16:46] *** Psyche^ is now known as Patterner

[16:51] *** xinming joined
[16:53] * Matt-W plays games with .wrap

[16:54] *** cdarroch joined
[16:54] *** lichtkind left
[16:55] *** baest left
[16:55] <pmichaud> rakudo:   say Nil.new.perl;

[16:55] <p6eval> rakudo c7ff05: OUTPUT«undef␤»

[16:56] <pmichaud> ...what should that be?

[16:56] <moritz_> Nil

[16:56] <moritz_> oh wait

[16:56] <moritz_> rakudo: () ~~ undef

[16:56] <p6eval> rakudo c7ff05:  ( no output )

[16:56] <moritz_> rakudo: say () ~~ undef

[16:56] <p6eval> rakudo c7ff05: OUTPUT«1␤»

[16:56] <moritz_> pmichaud: () should work

[16:58] *** payload left
[16:58] <pmichaud> rakudo:  say (42 if 0).perl;

[16:58] <p6eval> rakudo c7ff05: OUTPUT«[]␤»

[16:59] <pmichaud> rakudo:  say ().perl;

[16:59] <p6eval> rakudo c7ff05: OUTPUT«undef␤»

[17:04] *** hercynium joined
[17:04] *** icwiener_ joined
[17:04] *** donaldh left
[17:04] *** xomas is now known as xomas_

[17:04] *** xomas_ is now known as xomas

[17:05] <moritz_> let's say I have token a { a+ ::: b* } and token b { \w+ }

[17:05] <moritz_> and then I match against <a>|<b>

[17:05] <moritz_> does the LTM involve a+ and \w+?

[17:05] <pmichaud> yes.

[17:06] <moritz_> ok, thanks

[17:06] *** baest_ is now known as baest

[17:08] <pugs_svn> r27229 | azawawi++ | [S:H:P6] more scoping and support for method calls

[17:08] *** xinming_ left
[17:11] <Matt-W> rakudo: class A { method a { } }; &A.a.wrap( -> { say "foo"; } ); A.a();

[17:11] <p6eval> rakudo c7ff05: OUTPUT«Method 'wrap' not found for invocant of class 'List'␤»

[17:11] <moritz_> Matt-W: A::a

[17:11] <Matt-W> rakudo: class A { method a { } }; &A::a.wrap( -> { say "foo"; } ); A.a();

[17:11] <p6eval> rakudo c7ff05: OUTPUT«foo␤»

[17:11] <Matt-W> moritz_: thanks

[17:11] <Matt-W> of course, I was calling it

[17:11] <Matt-W> silly me

[17:14] *** cotto joined
[17:15] *** lisppaste3 left
[17:15] <viklund_> is it possible to create an instance of a class if I have the name of that class as a string?

[17:15] <moritz_> sure, with eval

[17:16] <viklund_> ;)

[17:19] <pugs_svn> r27230 | moritz++ | [t/spec] a few more LTM tests, including tie-breaking and LTM stopper

[17:19] <moritz_> man, constructing LTM tests requires quite some head-wrapping

[17:20] *** icwiener left
[17:20] *** xomas is now known as xomas_

[17:20] *** xomas_ is now known as xomas

[17:21] <pugs_svn> r27231 | moritz++ | [t/spec] fudge ltm tests a bit

[17:21] <moritz_> review appreciated, of course

[17:24] <Matt-W> rakudo: role R { method r { 'r'.say; } }; my &a := sub { 'a'.say; }; &a does R; a(); &a.r();

[17:24] <p6eval> rakudo c7ff05: OUTPUT«a␤r␤»

[17:24] <Matt-W> I love Perl 6

[17:24] *** rindolf joined
[17:24] <rindolf> Hi all.

[17:25] <rindolf> What should I do about the rakudo failures I got?

[17:25] *** ZuLuuuuuu joined
[17:25] <moritz_> report them via [email@hidden.address]
[17:26] <moritz_> woah, LTM is a scary thing.

[17:26] <pugs_svn> r27232 | moritz++ | [t/spec] implicit <.ws> stops LTM

[17:27] <Matt-W> rakudo: role R { method r { say "r"; } }; class C { method c { }; &c := method { } but R; }; &C::c.r()

[17:27] <p6eval> rakudo c7ff05: OUTPUT«r␤»

[17:27] <Matt-W> ^ is there a more elegant way to do that?

[17:29] <moritz_> wtf? ;-)

[17:29] <Matt-W> composing a role into the method object :P

[17:29] <moritz_> rakudo: role R { method r { say "r"; } }; class C { method c { }; &c does R }; &C::c.r()

[17:30] <p6eval> rakudo c7ff05: OUTPUT«Attempt to use rebless_subclass where the new class was not a subclass␤in Main (/tmp/3IMducolDJ:2)␤»

[17:30] *** lisppaste3 joined
[17:33] <Matt-W> moritz_: that's as close as I could get, and I also caused a null pmc access somewhere, I should probably bug that as we shouldn't be doing that even for wrong code

[17:34] <pugs_svn> r27233 | azawawi++ | [S:H:P6] identifies p6FlowControl keywords...

[17:36] *** alexn_org left
[17:40] *** netfish left
[17:41] <Matt-W> rakudo: class C { method c { }; method d { }; }; C.^methods.perl.say;

[17:41] <p6eval> rakudo c7ff05: OUTPUT«[{ ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ...

[17:41] <p6eval> ..}, { …

[17:41] <Matt-W> oh

[17:41] <Matt-W> foolish

[17:41] <Matt-W> trying to print out code objects

[17:41] <Matt-W> must mean it's time for dinner

[17:41] <moritz_> rakudo: class C { method c { }; method d { }; }; say C^methods.map: *.name

[17:41] <p6eval> rakudo c7ff05: OUTPUT«Could not find non-existent sub methods␤»

[17:42] <moritz_> rakudo: class C { method c { }; method d { }; }; say C.^methods.map: *.name

[17:42] <p6eval> rakudo c7ff05:

[17:42] <p6eval> ..OUTPUT«cdcanisadoesComplexelemsendkeyskvpicksortvaluesabsintlogpolarsqrtsrandtruncaterootsunpolarcharschomp:d:e:findexmatchrindexsubstrtranssubstevalfilefirstgrepjoinmapmaxminpairsreducereverseceilingchrcisfloorrandround!to-radians!from-radiansbytescapitalizechopfmtlclcfirstordp5chompp5ch…

[17:42] <moritz_> rakudo: class C { method c { }; method d { }; }; say C.^methods.map(*.name).join(', ')

[17:42] <p6eval> rakudo c7ff05: OUTPUT«c, d, can, isa, does, Complex, elems, end, keys, kv, pick, sort, values, abs, int, log, polar, sqrt, srand, truncate, roots, unpolar, chars, chomp, :d, :e, :f, index, match, rindex, substr, trans, subst, evalfile, first, grep, join, map, max, min, pairs, reduce, reverse,

[17:42] <p6eval> ..ceiling, c…

[17:42] <Matt-W> moritz_: that's more like what I was looking for :)

[17:42] *** netfish joined
[17:44] *** amoc joined
[17:46] <PerlJam> moritz_++

[17:46] <Matt-W> argh

[17:46] <PerlJam> though, I'd throw a sort in there.

[17:46] <Matt-W> can't remember what the thing for a slurpy list parameter is

[17:47] <PerlJam> Matt-W: sub foo (*@slurp) { }

[17:47] <Matt-W> PerlJam: thanks!

[17:47] *** krunen left
[17:47] <PerlJam> perl is a crazy cool language these days.

[17:48] <PerlJam> rakudo: class C {}; C.^methods.map(*.name).sort.join(',').say;

[17:48] <p6eval> rakudo c7ff05: OUTPUT«sh: ./perl6: No such file or directory␤»

[17:48] <PerlJam> aww...

[17:48] <PerlJam> that code is awesome though

[17:49] <pugs_svn> r27234 | azawawi++ | [S:H:P6] no more p5 emitter code

[17:50] *** jaldhar left
[17:50] <Matt-W> oh dear

[17:50] <Matt-W> I'm getting an error that just says

[17:50] <Matt-W> rtype not set

[17:50] <Matt-W> in Main (src/gen_setting.pm:3225)

[17:51] *** FurnaceBoy joined
[17:51] *** icwiener_ is now known as icwiener

[17:53] <Matt-W> not the most helpful error ever seen

[17:53] * Matt-W -> food

[17:53] <Matt-W> (I'll worry about it later)

[18:01] *** Molaf left
[18:01] *** Molaf joined
[18:03] <pugs_svn> r27235 | azawawi++ | [S:H:P6] symbol table is now called token table; removed the p6 prefix from types

[18:06] <pugs_svn> r27236 | azawawi++ | [S:H:P6] emit_color => emit_token

[18:07] *** mvuets joined
[18:13] *** amoc left
[18:16] <[bjoern]> I want to put literal text into a regex, what's the syntax that requires the least amount of escaping (and what needs to be escaped)?

[18:16] <moritz_> '...'

[18:16] <TimToady> 'some literal text'

[18:16] <moritz_> only needs escaping of ' and \

[18:17] <[bjoern]> Okay. What's the meaning of <'...'>?

[18:18] <pugs_svn> r27237 | azawawi++ | [S:H:P6] cleanup..

[18:18] <TimToady> std: /<'...'>/

[18:18] <p6eval> std 27236: OUTPUT«##### PARSE FAILED #####␤Unrecognized regex assertion at /tmp/gFzpLBfFvZ line 1:␤------> [32m/<[31m'...'>/[0m␤    expecting any of:␤      assertion␤        name␤FAILED 00:03 36m␤»

[18:19] <TimToady> no meaning :)

[18:19] <TimToady> if you have something that says <'...'> it's very obsolete

[18:19] *** silug joined
[18:20] <[bjoern]> rakudo: grammar Name { regex rulename { <ALPHA> (<ALPHA> | <DIGIT> | <'-'>) ** 0..* }; };

[18:20] <p6eval> rakudo c7ff05: OUTPUT«Unable to parse block; couldn't find final '}' at line 2, near ") ** 0..* "␤in Main (src/gen_setting.pm:0)␤»

[18:20] <viklund_> std: class T is also { }

[18:20] <moritz_> the error message isn't that good

[18:20] <p6eval> std 27237: OUTPUT«ok 00:02 35m␤»

[18:23] <[bjoern]> there is no :ignoreasciicase that only treats A..Z = a..z and is otherwise entirely code point sensitive?

[18:23] <moritz_> [bjoern]: no

[18:24] <moritz_> but you can use :i in lexical scopes, maybe that helps you

[18:25] <[bjoern]> if i can specify the rules for :i in the scope it might...

[18:26] <PerlJam> [bjoern]: you can probably lexically override the meaning of :i in Perl 6, but I don't think anyone has implemented it yet.

[18:27] <[bjoern]> rakudo: say "'A' | 'B' | 'C' | 'D' | 'E' | 'F'".lc

[18:27] <p6eval> rakudo c7ff05: OUTPUT«'a' | 'b' | 'c' | 'd' | 'e' | 'f'␤»

[18:34] <pugs_svn> r27238 | azawawi++ | [S:H:P6] sub keyword..more cleanup...

[18:35] *** azawawi left
[18:47] <Tene> um... I thought 'is also' was deprecated in favor of 'augment'...

[18:48] *** mdxi joined
[18:48] <PerlJam> Tene: true, just not implemented anywhere (except perhaps STD.pm)

[18:48] <PerlJam> std: augment Int { }

[18:48] <p6eval> std 27238: OUTPUT«##### PARSE FAILED #####␤Malformed augment at /tmp/DpTFlw3rex line 1:␤------> [32maugment Int [31m{ }[0m␤    expecting any of:␤   multi_declarator␤ typename␤FAILED 00:02 36m␤»

[18:48] <PerlJam> std: augment class Int { }

[18:48] <p6eval> std 27238: OUTPUT«ok 00:02 35m␤»

[18:49] <PerlJam> std: class Int is also { }

[18:49] <p6eval> std 27238: OUTPUT«ok 00:02 35m␤»

[18:49] <PerlJam> std: class Int is foobar { }

[18:49] <p6eval> std 27238: OUTPUT«ok 00:02 35m␤»

[18:49] <PerlJam> okay, makes sense.  :)

[18:50] * Matt-W goes back to his 'rtype not set' error

[18:50] *** bionoid joined
[18:51] *** athomason joined
[18:54] *** alester joined
[18:55] *** payload joined
[18:55] *** desertm4x joined
[18:56] <TimToady> STD doesn't know one trait from another

[18:56] <TimToady> they're all just \w+ to it

[18:56] <PerlJam> yeah, I figured that out :)

[18:57] <PerlJam> what semantics does STD pay attention to?

[18:57] <PerlJam> It has to know about name declarations ... anything else?

[18:58] <TimToady> well, it knows about parameter zones

[19:05] *** _Chillance_ left
[19:05] <last> Is there a Perl 6ish way to get the unique members of a list?  (I mean, I can dump it as the keys of a hash and then extract them again, but that feels awkward.)

[19:06] <Tene> last: is it okay if they're sorted?

[19:07] <last> Tene: since my next step is to sort them, yup.

[19:07] <moritz_> rakudo: say <a b c a c d>.uniq.perl

[19:07] <p6eval> rakudo c7ff05: OUTPUT«["a", "b", "c", "d"]␤»

[19:07] <Tene> ... nm. :)

[19:08] <moritz_> don't know for sure if it's specced, though

[19:10] <last> Beauty!  Thanks.

[19:10] *** icwiener left
[19:11] <last> rakudo: uniq(map { ($_ * $_) % 256 }, 1..128).join(" ").say

[19:12] <p6eval> rakudo c7ff05: OUTPUT«1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 0 33 68 105 185 228 17 113 164 217 73 132 193 65 201 89 241 145 57 233 161 97 41 249 209 177 153 137 129␤»

[19:12] <last> That's harkening back to the cheap square detection discussion from yesterday.  :)

[19:13] *** payload left
[19:13] *** payload joined
[19:14] <Tene> rakudo: my @uniq = gather { for <a b b b c c d> { take $_ unless state $last eq $_; $last = $_ } }; say @uniq.perl

[19:14] <p6eval> rakudo c7ff05: OUTPUT«Use of uninitialized value␤["a", "b", "c", "d"]␤»

[19:14] <Tene> IWBNI there was a way to do a post-assign.

[19:14] <Tene> $x++ vs ++$x

[19:32] <dalek> rakudo: e0a9d86 | pmichaud++ | perl6.pir:

[19:32] <dalek> rakudo: Allow operator definitions in settings (resolves RT #66826).

[19:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e0a9d869bc47e9bb914e6852b46025b710184386

[19:32] <dalek> rakudo: c6b283f | pmichaud++ | :

[19:32] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[19:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c6b283f44abaa998229cbb63089cdb0dc68625d0

[19:43] *** macae left
[19:47] <lichtkind_> moritz_: in case you wondere euler ha updatelatency 

[19:48] * moritz_ doesn't understand anything

[19:48] <lichtkind_> there were just 2 chars missing :)

[19:48] <Matt-W> argh

[19:48] <lichtkind_> >	moritz_: in case you wonder (because my last msg) euler had an update latency

[19:49] <Matt-W> there are so many weird things around trying to mix roles into method objects that I don't quite know where to begin

[19:49] <Matt-W> including things that break differently if you're doing a one-liner or reading from a file with linebreaks in it...

[19:49] * lichtkind_ is busy straighten tables of special vars

[19:49] *** lichtkind_ is now known as lichtkind

[19:51] <pugs_svn> r27239 | moritz++ | [t/spec] fix/fudge series operator tests

[19:54] *** rafl left
[19:55] <dalek> rakudo: 62094c1 | moritz++ |  (2 files):

[19:55] <dalek> rakudo: implement (eager) series operator

[19:55] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/62094c10e9ab4b946937a83c93de1d87747a59a2

[19:55] <dalek> rakudo: d03148d | moritz++ | t/spectest.data:

[19:55] <dalek> rakudo: test series operator

[19:55] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d03148d57c5ff3e1e4b69c47afa30fb9acde4ebf

[19:56] <Matt-W> std: role R { }; sub a { }; &a does R;

[19:56] <p6eval> std 27239: OUTPUT«ok 00:03 48m␤»

[19:58] *** desertm4x left
[20:00] *** mvuets left
[20:06] *** eMaX joined
[20:09] *** cotto left
[20:10] <pmichaud> http://www.sdtimes.com/link/33566

[20:10] <moritz_> pmichaud: you're late ;-)

[20:11] <pmichaud> apparently so.

[20:11] <pmichaud> Easy to be late -- too busy hacking.  :-)

[20:11] <Matt-W> hi pmichaud

[20:11] <Matt-W> any idea what 'rtype not set' means?

[20:12] <Matt-W> it seems to be coming from somewhere inside PCT

[20:13] <pmichaud> it means a binding is failing.

[20:13] <Matt-W> aaah

[20:13] <Matt-W> that would make sense

[20:13] <pmichaud> Rakudo and PCT have difficulty with certain binding operations.

[20:14] <Matt-W> what was odd is that it doesn't seem to happen if yo uconvert the code to a one-liner. I filed a bug about that.

[20:14] <pmichaud> what bug #?

[20:14] <Matt-W> #66966

[20:16] <pmichaud> that looks pretty odd.  At any rate, I'm not sure that &a := method { ... };   should work there.

[20:16] <Matt-W> Well that's a possibility too, but I felt it should at least fail consistently if it's on one line or many

[20:16] <pmichaud> agreed there.

[20:17] <pmichaud> I suspect the second is failing a parse or something.

[20:17] <pmichaud> well, I need to go pick up my wife from the airport.  bbiaw

[20:17] <Matt-W> Go safely!

[20:17] <pmichaud> will do.  :-)

[20:17] <Matt-W> you can't get squashed until you've fixed all the bugs :P

[20:22] *** [bjoern] left
[20:26] *** jlmoko joined
[20:27] *** jlaire left
[20:29] <moritz_> whoa, 'make spectest' is a big mess for me

[20:29] <moritz_> 8 failures or so

[20:35] *** ivast joined
[20:37] <viklund_> std: sub a { ... }

[20:37] <p6eval> std 27239: OUTPUT«ok 00:02 36m␤»

[20:37] <viklund_> std class A { ... }

[20:37] <viklund_> std: class A { ... }

[20:37] <p6eval> std 27239: OUTPUT«ok 00:02 35m␤»

[20:37] <viklund_> rakudo: class A { ... }

[20:38] <p6eval> rakudo c6b283: OUTPUT«Can't return outside a routine␤in Main (/tmp/FOR1XZBHqx:2)␤»

[20:38] <viklund_> bug?

[20:38] <moritz_> well, NYI

[20:38] <viklund_> rakudo: sub a { ... }

[20:38] <p6eval> rakudo c6b283:  ( no output )

[20:38] <viklund_> that's implemented (I think)

[20:39] <viklund_> rakudo: sub a { ... }; a()

[20:39] <p6eval> rakudo c6b283:  ( no output )

[20:39] <viklund_> rakudo: sub a { ... }; a(); say "Tjo"

[20:39] <p6eval> rakudo c6b283: OUTPUT«Tjo␤»

[20:39] <moritz_> ... (as a term) is a thing that fail()s

[20:39] <moritz_> apparently fail()ing at class building time isn't handled yet

[20:40] <viklund_> right, that's an earlier step

[20:43] *** frew joined
[20:43] *** mizioumt1 left
[20:48] *** viklund left
[20:58] *** ejs joined
[21:03] *** nsh left
[21:03] *** sbp left
[21:04] *** pmurias left
[21:06] *** ejs left
[21:06] * lichtkind extended and reformated special vars

[21:10] *** Whiteknight joined
[21:12] *** ZuLuuuuuu left
[21:13] <pugs_svn> r27240 | lwall++ | [STD] fix for [+] without arguments

[21:14] *** [bjoern] joined
[21:14] <[bjoern]> I don't suppose there is some debugging aid to figure out why a string won't match a grammar-based regex yet?

[21:15] <moritz_> [bjoern]: by installing action methods with say() statements you can find out how far it got

[21:15] <moritz_> but there are no real tools for it right now

[21:15] <[bjoern]> Ah, okay, will read up on that then

[21:16] <moritz_> [bjoern]: http://svn.pugscode.org/pugs/t/spec/S05-grammar/action-stubs.t contains some examles

[21:16] <[bjoern]> There is some ambiguity, if i recall correctly, in the white space handling in the ABNF grammar in RFC 5234, or some oddity that interacts poorly with backtracking, so my automatic conversion of the grammar fails pretty consistently...

[21:18] *** Su-Shee left
[21:20] <PerlJam> std : [+]

[21:20] <moritz_> std: [+]

[21:20] <p6eval> std 27240: OUTPUT«##### PARSE FAILED #####␤Unable to parse array composer; couldn't find final ']' at /tmp/KRQNt2i7tF line 1:␤------> [32m[31m[0m␤    expecting noun␤FAILED 00:02 37m␤»

[21:20] <moritz_> p6eval is picky about whitespaces ;-)

[21:20] <PerlJam> oops, that's moritz_ 

[21:20] <PerlJam> er, *thanks*

[21:21] <PerlJam> Apparently giving blood affects my ability to type more than usual

[21:21] <moritz_> not sure if the revision reporting works well with the 'make snap' thing that me and TimToady worked out

[21:21] *** hercynium left
[21:22] *** frew left
[21:22] <PerlJam> It looks the same as it did before the fix to me, so I'd guess there's a caching problem somewhere

[21:22] <PerlJam> (or the fix wasn't a fix or I'm missing something)

[21:23] <Matt-W> PerlJam: how much blood did they take??

[21:23] <PerlJam> 610 milligrams if I read the digital readout correctly.

[21:24] <Matt-W> that's not very much

[21:24] <Matt-W> unless they replaced it with brandy :)

[21:24] <PerlJam> (It was up-side down and a little bit away from me and in blocky glaring red LED letters)

[21:24] <Matt-W> are you sure it wasn't 610 millilitres?

[21:25] <PerlJam> that sounds better but the readout looked like mgs to me.  maybe that's something else.

[21:25] <Matt-W> maybe they have a special unit just for blood

[21:25] <PerlJam> well, 610 whatever units then  :)

[21:27] <moritz_> std: [+]

[21:27] <p6eval> std 27240: OUTPUT«ok 00:02 36m␤»

[21:28] <PerlJam> moritz_: did you run something or know the timing of some cron job or what?

[21:28] <moritz_> PerlJam: I ran something

[21:28] <PerlJam> (or just figured that "make snap" hadn't finished?)

[21:28] <PerlJam> ah.

[21:30] <viklund_> should a key get instantiated if I do this %s<a> ~~ :e ?

[21:30] <viklund_> or is that a rakudo bug?

[21:31] <[bjoern]> So if I set up a action method TOP and pass the object via :action to .parse, shouldn't that always get called if there is some match?

[21:32] <moritz_> it should, but rakudo currently requires a {*} token at the end of token TOP for that

[21:32] <viklund_> hmm

[21:32] <moritz_> viklund_: rakudobug (known)

[21:32] <viklund_> nvm

[21:33] <viklund_> I always check before I submit ;)

[21:33] <viklund_> ~~ didn't work anyway though

[21:33] <dalek> rakudo: 7187b9f | moritz++ | docs/ChangeLog:

[21:33] <dalek> rakudo: [docs] update ChangeLog

[21:33] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7187b9f2c33b2eb1ee131fe241963fd8197f49a1

[21:33] <dalek> rakudo: 9e9c3cc | moritz++ | src/setting/Operators.pm:

[21:33] <dalek> rakudo: oops, forgot to add Operators.pm

[21:33] <dalek> rakudo: Now also with some initial implementation of infix:<eqv>

[21:33] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9e9c3cc6825745c3f28a0e06dbf4123772a7ba4e

[21:33] <viklund_> rakudo: my %s="a" => 1, "b" => 2; say %s<a> ~~ :e

[21:33] <p6eval> rakudo c6b283: OUTPUT«sh: ./perl6: No such file or directory␤»

[21:34] <PerlJam> viklund_: are you saying that rakudo autovivifies that key and it shouldn't?

[21:34] <viklund_> yes

[21:35] <[bjoern]> Hmm I get

[21:35] <viklund_> plus it doesn't run the :e test ;)

[21:35] <[bjoern]> No applicable methods.

[21:35] <[bjoern]> in method ABNF::Actions::TOP (abnf.p6:5)

[21:35] <[bjoern]> called from regex ABNF::TOP (abnf.p6:10)

[21:35] <[bjoern]> called from Main (abnf.p6:168)

[21:35] <moritz_> pmichaud: see last commit, the infix:<...> works, but the infix:<eqv> still dies with "Null PMC access in find_method()"

[21:35] <[bjoern]> If I add the {*} to the end

[21:35] <moritz_> what's the signature of the TOP method?

[21:35] <moritz_> and what do you do in that method?

[21:36] <[bjoern]> I tried with having both multi method TOP($/) and multi method TOP($match) and just method TOP($/)

[21:36] <[bjoern]> perhaps multi method TOP($match, $tag) ... trying

[21:36] <moritz_> could you nopaste an example?

[21:37] <[bjoern]> with multi method TOP($match, $tag) I get Null PMC access in invoke() ...

[21:37] <[bjoern]> Will try to minify an example...

[21:37] <pugs_svn> r27241 | moritz++ | [src/perl6] not current svn revision in 'make snap'

[21:38] <[bjoern]> lisppaste3: url?

[21:38] <lisppaste3> To use the lisppaste bot, visit http://paste.lisp.org/new/perl6 and enter your paste.

[21:40] <lisppaste3> [bjoern] pasted "This dies with Null PMC access in invoke() (but using the single argument forms for the TOP method works)" at http://paste.lisp.org/display/82518

[21:41] <moritz_> [bjoern]: anyway, the error message is wrong - could you submit that as a bug to [email@hidden.address]  please?

[21:41] <TimToady> which error message, "No such file or directory"?

[21:42] <TimToady> that message is correct

[21:42] <moritz_> no, "Null PMC access in invoke()"

[21:42] <TimToady> in a sense...

[21:42] <TimToady> ah

[21:42] <[bjoern]> If you give me a proper subject line?

[21:42] <TimToady> since :e is testing file "1"

[21:43] <moritz_> [bjoern]: "action methods with too many parameters die with Null PMC Access"

[21:44] <[bjoern]> done

[21:45] <viklund_> ?

[21:45] <moritz_> thank you

[21:45] <moritz_> viklund_: bug report submitted

[21:45] <pugs_svn> r27242 | lwall++ | [CORE] generate EXPORT::DEFAULT entries from export tags like a real compiler would

[21:46] <viklund_> nice

[21:46] *** p6eval left
[21:47] *** p6eval joined
[21:47] <moritz_> std: 1

[21:47] <p6eval> std 27242: OUTPUT«ok 00:02 35m␤»

[21:47] <moritz_> reports the wrong revision :(

[21:48] * [bjoern] would probably have refused had submitting a bug report involved using Trac or Bugzilla... :-)

[21:48] *** skids left
[21:48] <moritz_> I kinda hate trac too

[21:48] <moritz_> for parrot's trac you first have to create an account

[21:49] <[bjoern]> I've been through that already...

[21:49] *** jferrero joined
[21:51] <pugs_svn> r27243 | moritz++ | [evalbot] report svn revisions for STD.pm correctly, hopefully

[21:51] *** p6eval left
[21:52] *** p6eval joined
[21:52] *** mofino left
[21:53] <viklund_> std: [+]

[21:53] <p6eval> std 27241: OUTPUT«ok 00:02 36m␤»

[21:54] <TimToady> how often does std get a new snapshot?

[21:55] *** jferrero left
[21:56] <moritz_> 0-59/18 * * * * is the cronjob entrie

[22:01] <moritz_> TimToady: there's something with LTM I don't quite understand... when there's an action method associated with a token, it's always executed when it finished matching... does that limit LTM?

[22:02] <TimToady> you mean does it have side effects that last beyond backtracking?

[22:02] <moritz_> or is that action method called after the LTM step, so it already knows which path will win?

[22:02] <pmichaud>  /msg TimToady  Paula's flight is delayed by 40 mins.

[22:02] <pmichaud> oops

[22:02] <TimToady> ok :)

[22:03] <TimToady> not hungry yet

[22:03] <pmichaud> okay, good.

[22:03] <moritz_> TimToady: I mean it's a closure, and thus by defintion is not declarative

[22:03] <pmichaud> I already have the car however, so should be direct-ish.

[22:04] <TimToady> it doesn't count those

[22:04] <TimToady> so I don't think LTM is adversely affected

[22:05] <moritz_> ok, thanks

[22:05] <TimToady> though {*} it counts

[22:05] <pmichaud> does an explicit {*} affect LTM?

[22:05] <pmichaud> okay.

[22:05] <pmichaud> :-)

[22:05] <pmichaud> that matches my expectations.

[22:05] <TimToady> viv doesn't use *any* of the {*} stubs; just throws 'em away

[22:05] <TimToady> it's all running off the implicit actions

[22:07] *** nsh joined
[22:13] <pmichaud> moritz_: (eqv)  Note that eqv semantics are supposed to be match === semantics.

[22:13] <pmichaud> So I suspect it should be defined in terms of ===

[22:14] <pmichaud> (for the immutable types)

[22:15] <pmichaud> I'm not sure why the null find_method shows up.  It's very likely/possible that actions.pm is somehow depending on the availability of 'eqv' -- if so, then we need a non-setting version.

[22:15] <moritz_> pmichaud: ok

[22:15] <pmichaud> (about to lose battery here)

[22:15] <moritz_> I don't think it does, since we didn't have an eqv before

[22:16] <pmichaud> okay, makes sense.  The operator definitions are a bit sensitive to load sequence.

[22:17] <pmichaud> yes, if we didn't have an eqv before, then that's probably not the cause.  (but we should still get our eqv to follow s03 :-)

[22:17] *** ivast left
[22:17] <moritz_> sure

[22:18] <pmichaud> hmmpf

[22:18] <pmichaud> maybe i'm not losing battery as soon as I thought

[22:18] <pmichaud> system gave me a warning alert, but it shows 42 minutes left :-)

[22:20] <moritz_> I'm not quite sure I  understand what S03 says about eqv

[22:21] <Tene> pmichaud: cat /proc/acpi/battery/BAT0/{info,state}

[22:21] *** sri_kraih joined
[22:21] <dalek> rakudo: 6c43f93 | moritz++ | src/setting/Operators.pm:

[22:21] <dalek> rakudo: make eqv rely on infx:<===> more

[22:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6c43f93dc9b0bd16f705d7e6b22b741539e3fd6a

[22:22] <pmichaud> present rate:            990 mA

[22:22] <pmichaud> remaining capacity:      603 mAh

[22:22] <moritz_> rakudo: say 603/990*60

[22:22] <p6eval> rakudo 9e9c3c: OUTPUT«36.5454545454545␤»

[22:22] <Tene> present rate:            20987 mW

[22:22] <Tene> remaining capacity:      46960 mWh

[22:27] <viklund_> how do I call a method in the super class?

[22:28] <viklund_> nextsame?

[22:28] *** alester left
[22:29] <viklund_> yep

[22:29] *** acajou left
[22:30] <moritz_> note that this might also pick a different multi in the same class, if there is one

[22:31] <viklund_> can I force the super some how?

[22:31] <moritz_> I'm sure you can, but I don't know how

[22:31] <viklund_> ;)

[22:31] <viklund_> rakudo: class A { method a(*@A) { say "a {@A.perl}" } }; class B is A { method a(*@A) {nextwith("A STRANGE ARG", |@A)} }; B.new.a("MORE STUFF");

[22:32] <p6eval> rakudo 9e9c3c: OUTPUT«a ["MORE STUFF"]␤»

[22:32] <viklund_> why don't I get "A STRANGE ARG" before "MORE STUFF" here?

[22:33] <viklund_> ahh, it's become self...

[22:33] <viklund_> kind of strange

[22:33] <moritz_> rakudo: class A { multi method x($) { say "A::x" } }; class B is A { multi method x($) { say "B::x(Any)" }; multi method x(Int $a) { say "B::x(Int)"; nextsame; } }; B.new.x(3)

[22:33] <p6eval> rakudo 9e9c3c: OUTPUT«B::x(Int)␤B::x(Any)␤»

[22:34] <moritz_> rakudo: class A { multi method x($) { say "A::x" } }; class B is A { multi method x($) { say "B::x(Any)"; nextsame }; multi method x(Int $a) { say "B::x(Int)"; nextsame; } }; B.new.x(3)

[22:34] <p6eval> rakudo 9e9c3c: OUTPUT«B::x(Int)␤B::x(Any)␤A::x␤»

[22:34] *** nihiliad left
[22:34] <pmichaud> afk for a while

[22:34] <viklund_> rakudo: class A { method a(*@A) { say "A self={self.perl} arg={@A.perl}" } }; class B is A { method a(*@A) {nextwith("A STRANGE ARG", |@A)} }; B.new.a("MORE STUFF");

[22:34] <p6eval> rakudo 9e9c3c: OUTPUT«A self="A STRANGE ARG" arg=["MORE STUFF"]␤»

[22:34] <viklund_> self becomes the string...

[22:34] <viklund_> MMD bug?

[22:35] <moritz_> I think so, yes

[22:35] <viklund_> the workaround is easy though

[22:36] <moritz_> still worth submitting (hint, hint ;-)

[22:36] <viklund_> alright

[22:36] * viklund_ wanders of to gmail

[22:37] *** jferrero joined
[22:38] *** sri_kraih_ left
[22:43] <viklund_> submitted.

[22:43] <moritz_> great

[22:43] * moritz_ submits himself to bed

[22:44] <viklund_> sounds like a good idea

[22:46] *** lichtkind_ joined
[22:47] *** cotto joined
[22:52] *** jevin joined
[23:00] *** viklund_ left
[23:00] *** snarkyboojum joined
[23:04] *** lichtkind left
[23:05] *** DemoFreak left
[23:11] *** Limbic_Region joined
[23:12] *** jferrero left
[23:15] *** renormalist left
[23:15] *** renormalist joined
[23:15] *** nsh left
[23:15] *** eMaX left
[23:15] *** nsh joined
[23:15] *** Caelum left
[23:15] *** Caelum joined
[23:16] *** literal left
[23:16] *** literal joined
[23:19] *** netfish left
[23:29] *** gbacon left
[23:30] *** skids joined
[23:32] <sjohnson> Quick p5 question:  anyone know the TimToady-approved way to reset the $" variable?

[23:36] <sjohnson> instead of doing a hack like... my $old = $" ; $" = ', '; stuff(); $" = $old;

[23:36] <lichtkind_> :sigspace means whitespace is ignored?

[23:36] *** lichtkind_ is now known as lichtkind

[23:37] <jevin> sjohnson: local + a block?

[23:38] <jevin> http://perldoc.perl.org/perlsub.html#Temporary-Values-via-local()

[23:41] *** rindolf left
[23:48] *** jevin left
[23:49] *** justatheory left
[23:49] *** payload left
[23:51] *** nsh left
[23:55] * skids realizes "rolling hash best seed" is not a google query that is going to result in anything to do with modular arithmetic.

[23:59] *** nsh joined
