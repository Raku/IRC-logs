[00:01] *** mikehh joined
[00:10] <cspencer> jnthn: you still around?

[00:12] *** Diederich joined
[00:16] *** lichtkind_ joined
[00:25] *** Tene left
[00:34] *** lichtkind left
[00:35] *** gdonald joined
[00:36] *** gdonald left
[00:37] *** Whiteknight joined
[00:41] *** kate21de left
[00:41] <pugs_svn> r25969 | lwall++ | clarify (we hope) how the top-level lexical, package, and dynamic scopes interact

[00:56] *** alc joined
[01:16] *** Whiteknight left
[01:25] *** gdonald joined
[01:26] *** Entonian joined
[01:26] <skids> @tell ruoso http://www.abrij.org/~bri/S07-tempurl.diff    S07 edits + new coro section

[01:26] <lambdabot> Consider it noted.

[01:27] <pugs_svn> r25970 | lwall++ | clarifications to .caps and .chunks requested by moritz++

[01:33] *** gdonald left
[01:34] *** dukeleto joined
[01:35] *** gdonald joined
[01:39] *** jferrero left
[01:41] *** gdonald left
[01:51] <cspencer> S32-setting-library/Numeric.pod seems to indicate that some of the functions/methods we're currently putting into Any-*.pm will be located elsewhere at some point - is Any.pm just a temporary repository for them?

[01:52] <dukeleto> cspencer: seems that way

[01:52] <cspencer> dukeleto: any idea why that's the case for the momen

[01:52] <cspencer> t?

[01:52] <cspencer> moment, rather? :)

[01:53] <dukeleto> cspencer: the whole setting ideas is somewhat new, and I think that I was thinking of the any-*.pir files

[01:53] <dukeleto> but in general, I think S29 and S32 are still in flux

[01:54] <cspencer> alrighty

[01:58] *** Entonian left
[01:59] <mikehh> rakudo (1c263b0) builds on parrot r37843 - make test PASS, make spectest FAIL 1/327 test programs. 1/9577 subtests failed. - t/spec/S05-capture/caps.t - failed test 6

[02:01] *** Entonian joined
[02:07] *** Limbic_Region left
[02:07] <pugs_svn> r25971 | leto++ | Tests for roots() of a Complex

[02:07] *** Entonian left
[02:10] <TimToady> Any is a place for methods that (as a language policy) redirect to some more specific type, such as the various operators that coerce to list

[02:12] *** cspencer_ joined
[02:14] <cspencer_> TimToady: I'd just seen a reference in S32::Numeric to a Num role which seemed (to me at least) to include many of the methods currently in Any, and was wondering how that'd work

[02:15] *** cspencer left
[02:15] *** jyy joined
[02:25] <TimToady> In general methods should be defined in the class they make the most sense, with the assumption that their invocant is already of the right type.

[02:25] <TimToady> any extra coercion is presumably in the Any version of it that delegates to the List (or Num, or whatever) version of it

[02:26] <TimToady> but we do have to think about the cases where the type of the invocant is specified

[02:26] <TimToady> esp where exported as a multi

[02:27] <TimToady> and if there's a mechanism for using the same def in all those places, it's probably worthwhile not having the extra indirection overhead

[02:27] <TimToady> but I'd rather have correct first...

[02:27] <cspencer_> ok.  so in the case of something like "exp" or "log10", where would you suggest they end up?

[02:28] <dukeleto> or roots()? currently I have a version in any-num.pir that calls out to math.pir

[02:29] <TimToady> if there's a method version of them, in the package of their invocant, first of all

[02:29] <TimToady> additional aliases are gravy

[02:29] <dukeleto> TimToady: there is a method version and a non-method version of roots

[02:30] <TimToady> what is the invocant of the method version?

[02:30] <dukeleto> TimToady: Complex or Num or Int

[02:31] <TimToady> if defined in their respective classes, and then exported to CORE, is there any reason they can't multi dispatch based on the same type?

[02:32] <TimToady> and the Any version of it can decide how to coerce and call one of the others, if it wants to be a function that will coerce its first arg from, say Str

[02:32] <dukeleto> TimToady: i have single PIR function that works for Num and Int currently and is very close to working for Complex

[02:33] <TimToady> we could probably arrange to be able to import methods from one class to another via use :has<> or some such

[02:34] <TimToady> but for now I'd just say put it into one class or another and have the other call it

[02:34] <TimToady> or dup the code, we can refactor later

[02:35] <TimToady> but if someone calls Num::foo() it'd be nice to actually have something there, and not just shadowed in another class, I suppose

[02:35] <TimToady> but whatever

[02:36] <TimToady> if the interfaces are right, we can factor out commonalites later

[02:36] <TimToady> and presumably we can even do some tailcalls for delegation; I think parrot supports those...

[02:37] <TimToady> could be wrong...

[02:37] <dukeleto> TimToady: currently S32 does not mention that roots() works on Complex numbers, do you have any comments on that? 

[02:37] <TimToady> I try to stay out of mathematical debates :)

[02:37] <TimToady> I are a lingrist

[02:38] <TimToady> family &

[02:38] <meppl> good night

[02:39] <dukeleto> wasn't trying to debate so much as clarify

[02:40] *** meppl left
[02:41] <lichtkind_> what is \q in p6?

[02:41] *** lichtkind_ is now known as lichtkind

[02:45] *** cspencer_ left
[02:46] <skids> \q in an interpolated string allows nesting of general quote operators

[02:46] <skids> http://www.perlfoundation.org/perl6/index.cgi?witch_littleq

[02:47] <pugs_svn> r25972 | hinrik++ | [util/perl6.vim] remove int routine, add iterator routine, highlight PIR code in Q:PIR// strings

[02:47] <frooh> rakudo: "\q"frew""

[02:47] <p6eval> rakudo 1c263b: OUTPUT«Statement not terminated properly at line 1, near "frew\"\""␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[02:48] <skids> Not sure if it's implemented yet.

[02:48] <frooh> I'd assume it isn't :-)

[02:48] <skids> rakudo: "\q'frew'"

[02:48] <p6eval> rakudo 1c263b: RESULT«"q'frew'"»

[02:49] <skids> rakudo: qq(\q(frew))

[02:49] <p6eval> rakudo 1c263b: OUTPUT«Syntax error at line 1, near ")"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[02:55] <pugs_svn> r25973 | hinrik++ | [util/perl6.vim] only catch block labels when there's nothing but whitespace or a newline before it, so as not to catch invocant markers as well

[02:56] *** Kisu left
[02:58] <msmatsko> I'm trying to build rakudo on cygwin under Vista-64 and get a link error for perl6_group.dll: undefined references to '__imp__Parrot_str_new_constant' among others.  The g++ path seems to be set to the right place.  Does anyone have any experience with this?

[02:59] *** kimtaro joined
[03:02] *** frooh is now known as frooh_away

[03:05] *** nbrown04 joined
[03:06] *** nbrown04 left
[03:08] *** Kisu joined
[03:19] <lichtkind> skids: thanks a lot

[03:28] *** disismt left
[03:33] *** FurnaceBoy left
[04:19] *** tarbo2 left
[04:34] *** tarbo2 joined
[04:40] *** orafu left
[04:41] *** orafu joined
[05:01] *** msmatsko left
[05:02] *** msmatsko joined
[05:42] *** japhb left
[05:44] *** japhb joined
[05:51] *** amoc joined
[05:56] *** kate21de joined
[06:05] *** r0bby_ is now known as r0bby

[06:09] *** msmatsko left
[06:21] <pasteling> "szabgab" at 192.117.127.193 pasted "cannot build rakudo" (10 lines, 477B) at http://sial.org/pbot/35656

[06:23] <dukeleto> I got roots() of complex numbers work, yay

[06:23] <dukeleto> s/work/working/

[06:23] <szabgab> sirry, after make realclean I could build it

[06:23] <szabgab> sorry too

[06:38] *** parduncia joined
[06:40] <pugs_svn> r25974 | leto++ | Tests for cube roots()

[06:57] <szabgab> jnthn, bug report with Segmentation fault from yesterday night sent to rakudobug

[07:01] *** Kisu left
[07:15] *** ejs joined
[07:24] *** nihiliad left
[07:25] *** ejs1 joined
[07:25] *** nihiliad joined
[07:26] *** nihiliad left
[07:29] <moritz_> good morning

[07:30] <moritz_> rakudo: my @a = 1, 2; say @a.pairs.perl

[07:30] <p6eval> rakudo 1c263b: OUTPUT«[0 => 1, 1 => 2]␤»

[07:31] *** mberends joined
[07:32] *** ejs left
[07:32] *** DemoFreak joined
[07:33] <dukeleto> moritz: mornin'

[07:34] <dukeleto> moritz; i have my roots() working nicely for everything I can throw at it

[07:36] <moritz_> dukeleto: did you modify it to make the method do all the work?

[07:36] *** disismt joined
[07:38] <pugs_svn> r25975 | lwall++ | [STD] handle .caps on list assoc; nibble text is now match object

[07:38] <pugs_svn> r25975 | lwall++ | [Cursor] add keys into .caps pairs

[07:38] <dukeleto> moritz: what exactly do you mean by that? I deleted one of the multi subs that I had before, now one multisub in math.pir does all the work, with a wrapper in any-num.pir that calls out to roots(x,n) to make x.roots(n) work

[07:40] <moritz_> dukeleto: all the other builtins are just done the other way round: for example $s.split($delim) does all the work, split($delim, $s) calls this method - I would prefer it if it worked the same way for roots

[07:41] <dukeleto> moritz: that seems doable

[07:43] <dukeleto> moritz: i have mostly been squashing bugs, adding docs and tests

[07:44] <dukeleto> moritz: but it seems pretty solid now, so I will convert it so that roots(x,n) calls x.roots(n) 

[07:44] <moritz_> dukeleto: great

[07:44] <moritz_> dukeleto: I might not have time for a thorough review today, but I should be able to do it tomorrow

[07:44] <dukeleto> moritz: currently all 40 tests in roots.t are passing

[07:45] <dukeleto> moritz: no prob, I don't know how long it will take me to convert the calling method, but hopefully not long

[07:45] <moritz_> dukeleto: ok, just ping me when you're done

[07:45] <dukeleto> moritz: sounds good

[07:58] <pugs_svn> r25976 | leto++ | Tests for cube roots() of negative numbers

[08:05] <moritz_> can anybody reach rt.perl.org?

[08:06] <moritz_> rakudo: class Match is also { method t { say %(self).pairs.[0].value.WHAT; } }; "a" ~~ /<xdigit>/; $/.t; say $<xdigit>.WHAT

[08:06] <p6eval> rakudo 1c263b: OUTPUT«Str␤Match␤»

[08:10] <moritz_> rakudo: class Match is also { method t { say %(self).{"xdigit"}.WHAT; } }; "a" ~~ /<xdigit>/; $/.t;

[08:10] <p6eval> rakudo 1c263b: OUTPUT«Match␤»

[08:15] *** disismt left
[08:15] *** disismt joined
[08:22] <mberends> rt.perl.org (netlabs.develooper.com (63.251.223.170)) and www.nntp.perl.org (63.251.223.163) seem to be down

[08:27] *** bacek_ left
[08:40] *** cognominal left
[08:46] *** disismt left
[08:47] *** DemoFreak left
[08:48] *** alc left
[08:53] *** masak joined
[08:53] *** disismt joined
[08:53] *** disismt left
[08:53] *** disismt joined
[08:56] *** pmurias joined
[09:01] <mberends> jnthn++ # excellent slides http://www.jnthn.net/articles.shtml

[09:01] <pugs_svn> r25977 | leto++ | Fix typo in roots() test descriptions

[09:09] *** Caelum is now known as Caelum[Shootme]

[09:10] *** broquaint joined
[09:14] *** araujo left
[09:31] <masak> trapping signals in Perl 6? how, where, when?

[09:31] <masak> oh, and good morning, people.

[09:32] <masak> here's how Ruby does it. looks OK to me. http://gist.github.com/83484

[09:32] <mberends> gm masak, that was IPC in p5, so probably NYI

[09:33] <masak> mhm

[09:33] <mberends> those progress dots, huh?

[09:33] *** ejs2 joined
[09:33] <masak> mberends: yes -- you want them? :)

[09:33] <mberends> can live without. it's eye candy.

[09:34] <masak> I'm sitting in a local branch called 'dogfood' in proto as we speak.

[09:34] <mberends> ...although free candy is welcome

[09:34] <masak> will add private github repo download, so I can start using proto myself in my everyday work.

[09:34] <masak> I don't think the progress dots are such a hard problem, so I might throw them in while I have the momentum.

[09:35] <masak> mberends: did you see viklund++'s cleanup of the Perl 5 bootstrapper?

[09:35] <mberends> masak: yes, it was an almost total rewrite

[09:35] <masak> aye.

[09:35] <mberends> p2t1a :)

[09:36] <masak> indeed. :)

[09:36] * mberends is preparing 2 throw Pod::Parser v1 away...

[09:36] <masak> why?

[09:37] <mberends> that {*} appeals to me

[09:37] <mberends> and the scalability results were disappointing

[09:38] *** Caelum[Shootme] is now known as Caelum

[09:38] <moritz_> aye, {*} rocks

[09:38] <mberends> and Matt-W++ showed an excellent architecture in form

[09:38] <masak> {*} is indeed appealing. as if Perl 6 wasn't good enough already at hiding complexity. :)

[09:38] <masak> mberends: oh? need to check it out again.

[09:38] <moritz_> but I'm regularly fighting small bugs in Match objects

[09:38] <masak> moritz_: such as?

[09:39] <mberends> moritz_, you're doing great stuff with Match objects

[09:39] <moritz_> masak: for example %($/).pairs and .kv stringify the values

[09:39] <masak> I must say that being part of a language community that's just forming is one of the best things that has happened to me as a programmer.

[09:39] <literal> I'm curious. What does {*} do?

[09:39] <masak> moritz_: is there a rakudobug for that?

[09:39] <moritz_> masak: and und some condition there's a Null PMC access in get_bool when doing 'if %(sefl)'

[09:40] <moritz_> masak: yes

[09:40] <masak> and the second one too? :)

[09:40] <moritz_> literal: it tells the grammar engine to execute a method of the same name as rule from a supplied object

[09:40] <moritz_> masak: sure

[09:40] <masak> moritz_: great.

[09:41] <literal> ok

[09:41] <moritz_> rakudo: grammar A { rule TOP { (\d+) '+' (\d+) } }; say A.parse('3 + 4')

[09:41] <p6eval> rakudo 1c263b: OUTPUT«3 + 4␤»

[09:42] <moritz_> rakudo: grammar A { rule TOP { (\d+) '+' (\d+) {*} } }; class B { method TOP($/) { make $/[0] + $/[0] } }  say A.parse('3 + 4', :action(B.new)).ast

[09:42] <p6eval> rakudo 1c263b: OUTPUT«Statement not terminated properly at line 1, near "say A.pars"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[09:42] *** ejs1 left
[09:42] <moritz_> rakudo: grammar A { rule TOP { (\d+) '+' (\d+) {*} } }; class B { method TOP($/) { make $/[0] + $/[0] } };  say A.parse('3 + 4', :action(B.new)).ast

[09:42] <p6eval> rakudo 1c263b: OUTPUT«6␤»

[09:44] <moritz_> literal: that's a nice example of what the reduction methods can do

[09:44] <moritz_> literal: and part of a potential GSOC project would also be to extensively test that facilty (hint, hint :-)

[09:45] <literal> heh

[09:45] <moritz_> speaking of which, applications must be done by April 3rd, iirc

[09:46] <literal> yeah

[09:47] <mberends> moritz_: does it only make sense to call make once in a .parse (in TOP)? when I tried several others, only the last make argument was returned.

[09:48] <moritz_> mberends: I think it's specced that way... $/ has only one .ast, so there's nothing else it could do

[09:48] <mberends> that's ok then, my expectations were unsure

[09:49] <moritz_> but you can always make [@( $/.ast ), $new_value]

[09:50] * mberends needs a cuppa to ponder that one

[09:50] <moritz_> that's basically the same as $/.ast.push($new_value), but it should atually work :-)

[09:51] <mberends> that's slightly more grokkable, but .ast is beyond by ken

[09:51] <mberends> *my

[09:52] <moritz_> .ast is the same as $(), ie the payload that you put onto the Match object by calling make

[09:53] <mberends> .oO( lightbulb )

[09:56] *** amoc left
[09:57] *** ejs1 joined
[10:04] *** ejs2 left
[10:12] <masak> mberends: I'm looking at http://www.webrick.org/ -- do you think that a HTTP server in Perl 6 would be of use?

[10:14] *** araujo joined
[10:15] <jnthn> morning all

[10:15] <masak> jnthn: morning!

[10:15] <mberends> masak: been there, done that http://autoexec.demon.nl:8888/

[10:16] <masak> mberends: oh, so HTTP::Demon already is such a server?

[10:16] <mberends> yep

[10:16] <mberends> for Druid too

[10:16] * masak rushes to read source

[10:17] <mberends> just needs netcat -> socat swap for BSD

[10:18] * masak tries

[10:19] <masak> mberends: I think I'll try and plug some Web.pm things I'm writing into HTTP::Server during the day.

[10:19] <masak> this is exactly what I need.

[10:19] <masak> mberends++

[10:20] *** kate21de left
[10:21] <masak> mberends: 'make help' doesn't contain the target 'podserver'.

[10:22] <mberends> oops :)

[10:22] <masak> mberends: wouldn't you know, the server works on the first attempt!

[10:23] <masak> it's slow, but it works.

[10:23] <mberends> \o/

[10:23] *** bacek joined
[10:23] <jnthn> Rakudo can haz web server?! :-)

[10:24] <jnthn> You folks scare me. :-)

[10:24] <masak> I hope to have a lobster ready by this afternoon.

[10:24] <masak> http://github.com/chneukirchen/rack/blob/master/lib/rack/lobster.rb

[10:31] <masak> mberends: I'll probably have to copy HTTP::Server to the web repo, creating a temporary duplication.

[10:31] <mberends> cool

[10:32] <masak> it's not a good long-term solution, but might be worth it to create a nice working example without an inter-project req.

[10:32] <masak> s/req/dependency/

[10:32] <mberends> fine

[10:32] * masak is glad he introduced the LICENSE file in the root of the perl6-examples repo :)

[10:34] <masak> mberends: I've been thinking of ways to introduce pseudoprojects in proto to handle the different projects residing in perl6-examples.

[10:34] <mberends> copy -r /projects/lib ;)

[10:35] <masak> -bash: syntax error near unexpected token `)'

[10:36] <masak> mberends: it might be possible to find a solution that doesn't depend on copying things. part of the "problem" is that the modules in perl6-examples are highly interdependent.

[10:37] <masak> in anthropomorphic terms, they like to live together.

[10:38] <mberends> the perl6-examples/lib is a mini PERL6LIB of the future

[10:38] <masak> aye.

[10:38] *** disismt left
[10:39] *** disismt joined
[10:40] <masak> ooh, things have indeed changed in Form since I last looked at it.

[10:40] <masak> Matt-W++

[10:40] <mberends> aye

[10:42] *** pmurias left
[10:50] *** cognominal joined
[10:50] *** cognominal left
[10:51] *** cognominal joined
[10:55] *** jyy left
[10:56] *** frooh_away left
[10:56] *** [particle]2 left
[10:56] *** rgs left
[10:56] *** PerlJam left
[10:56] *** plu_ left
[10:56] *** Woody4286 left
[10:56] *** bacek left
[10:56] *** japhb left
[10:56] *** buu left
[10:56] *** TimToady left
[10:56] *** frioux left
[10:57] *** TimToady joined
[10:57] *** bacek joined
[10:57] *** japhb joined
[10:57] *** buu joined
[10:57] *** frooh_away joined
[10:57] *** Woody4286 joined
[10:57] *** [particle]2 joined
[10:57] *** rgs joined
[10:57] *** PerlJam joined
[10:57] *** frioux joined
[10:57] *** plu_ joined
[10:57] *** ingy joined
[10:57] *** charsbar joined
[10:57] *** miloux joined
[10:57] *** cotto joined
[10:57] *** irc.freenode.net sets mode: +o TimToady

[11:00] *** amoc joined
[11:04] <masak> lunch &

[11:10] <mikehh>  rakudo (1c263b0) builds on parrot r37846 - make test PASS, make spectest FAIL 1/327 test programs. 1/9577 subtests failed. - t/spec/S05-capture/caps.t - failed test 6

[11:42] *** ruoso joined
[11:44] <ruoso> Hello!

[11:44] <lambdabot> ruoso: You have 1 new message. '/msg lambdabot @messages' to read it.

[11:49] *** disismt left
[11:49] *** disismt joined
[11:51] *** Grrrr left
[11:51] <ruoso> @tell skids the changes you sent are mostly ok, but ideally the item iterator returns one item at a time, not one capture at a time, which implies that if a capture contains more than one item, it will be stored and each of its values is consumed one by one. As well as doing additional calls if an empty capture is returned... At least that was my original intent

[11:51] <lambdabot> Consider it noted.

[11:51] *** Grrrr joined
[11:52] * Matt-W gets a big grin on his face

[11:53] *** Caelum left
[11:53] *** Caelum joined
[11:53] *** orevdiabl joined
[11:54] *** SamB left
[11:54] <ruoso> @tell skids but maybe I'm wrong and no flattening should be done in contexts other than list...

[11:54] <lambdabot> Consider it noted.

[11:57] <ruoso> masak, I'd suggest leaving a Perl 6 HTTP::Daemon as a different project... most people don't mind using apache...

[12:00] *** SamB joined
[12:13] <mberends> Matt-W: is the hubris getting to you? we do eventually want running code ;)

[12:13] <Matt-W> it's hard to be overproud about code when the compiler keeps throwing new ways to break it at you

[12:14] *** bacek left
[12:15] *** bacek joined
[12:16] <mberends> nm, I like the way you've structured you project. I'm taking memes into Pod::Parser.

[12:17] <mberends> *your

[12:17] <Matt-W> it's thrown up a few bugs in rakudo :)

[12:18] <Matt-W> still not sure why my fourth test file won't work

[12:18] <Matt-W> sometihng to do with instantiating objects of classes made with roles in multilayer namespaces or something

[12:18] <Matt-W> I intend to do a test case later

[12:20] <mberends> how about just pushing it and let me pull and also look. the user base can tolerate some downtime.

[12:20] <Matt-W> it's already up there

[12:21] <Matt-W> just pull it and make test

[12:21] <Matt-W> I know 03 fails, that's algorithmic

[12:21] <Matt-W> 04 looks like rakudo though

[12:21] <mberends> ok, it may then be pulled already. I did see fails late last night as you signed off.

[12:22] <Matt-W> I pushed it because it was preferable to the infinite loop that was there before :)

[12:23] <mberends> indeed, did that one here too :)

[12:23] <masak> ruoso: well, considering that the code is already written...

[12:23] <Matt-W> I'm currently operating no rules about code pushed in form requiring to work :)

[12:24] <masak> ruoso: I think there's certainly a use case for running your web stuff without Apache as a dependency.

[12:24] <Matt-W> rails shows that having an easy way to start up a project in a web server is really nice

[12:24] <Matt-W> just... let's not have the bit where it's really hard to get a rails project running in apache :)

[12:25] <masak> agreed.

[12:25] <masak> Rack does this wonderfully, it seems.

[12:25] <masak> it has some kind of "middleware" adapters.

[12:25] <masak> and all of them work with the same interface.

[12:26] <Matt-W> cool

[12:27] <masak> yes; it's a bit funny that I discovered Rack after specifying Web.pm -- they share many things, from goals to specific design points

[12:27] <Matt-W> great minds thinking alike?

[12:28] <masak> must be. :P

[12:28] <mberends> Matt-W: suggest commenting out all failing tests and looking at them one at a time (in any order)

[12:28] <masak> but there are also plenty of things that Rack does which I never thought about. that's ok, they're still stealable.

[12:29] <masak> RT down. :/

[12:30] <masak> did I overload it yesterday, perhaps? :P

[12:30] <jnthn> masak: Yeah, too many tickets. :-P

[12:30] <masak> I;d say sorry, but I'm not. :P

[12:30] <mberends> perhaps a network outage, other hosts also affected

[12:32] *** kimtaro_ joined
[12:32] <Matt-W> mberends: yeah I will

[12:32] <Matt-W> mberends: I'm only worried about the apparent lack of ability to construct a TextField in 04

[12:32] <moritz_> http://log.perl.org/2009/03/downtime-move-starting-now.html

[12:32] <masak> moritz_: ahoj!

[12:33] *** kimtaro_ left
[12:33] <moritz_> hi masak :-)

[12:34] *** unobe left
[12:35] <masak> moritz_: weekend good?

[12:35] <moritz_> masak: weekend good, but ended with $girlfriend sick :/

[12:36] <masak> :/

[12:36] *** pmurias joined
[12:36] <pmurias> ruoso: hi

[12:39] <mberends> Matt-W: is this blocking you? 'Could not find non-existent sub left'

[12:39] <ruoso> hi pmurias 

[12:39] <Matt-W> mberends: where did you get that from?

[12:40] <mberends> bypass 'prove' and run 'perl6 t/04yada.t'

[12:40] <masak> jnthn, moritz_: I'm still slightly unsatisfied with the way Parrot won't reveal byte information of strings. it feels silly to have to recreate this information on the Rakudo level. but if there's no other short-term solution, that's what I'll implement in Rakudo for now.

[12:41] <pmurias> ruoso: do you think doing OO and multis would be appropriate for GSoC?

[12:41] <moritz_> masak: did you send a mail to parrot-dev asking for help?

[12:41] <moritz_> masak: that might be worth a try

[12:41] <masak> moritz_: good idea.

[12:41] <ruoso> pmurias, what do you mean by OO?

[12:41] <masak> I'll start with that.

[12:41] <ruoso> pmurias, ah... OO in mildew

[12:42] <pmurias> yes

[12:42] <ruoso> pmurias, yes... I think so... 

[12:42] <moritz_> oh, rt status improved... before it was unreachable, now I get a ssh connection and "bad gateway"

[12:42] <mberends> Matt-W: the 'left' identifier never occurs standalone, always before an underscore. maybe try camelCase instead of underscores.

[12:43] *** FurnaceBoy joined
[12:44] *** kimtaro left
[12:44] <pmurias> ruoso: "implementing S12 in smop" seems a neat way to sum up what i intend to do

[12:46] <moritz_> pmurias: remeber that the meta-object stuff you're doing is quite far off from what the average programmer already knows...

[12:46] <ruoso> pmurias, yes... but that's a bit ambitious

[12:46] <moritz_> so it might not be ideal for a student

[12:47] <ruoso> pmurias, try to be a bit more specific on what you plan to do... 

[12:47] <ruoso> remember that it's a time-limited project

[12:47] <ruoso> moritz_, he is the student

[12:48] <szabgab> anyone read the blog entry about embedding Perl 6 into Perl 5 ? http://szabgab.com/blog/2009/03/1237797959.html

[12:48] <szabgab> where should I put the source code of that module and how should I call it?

[12:49] <pmurias> on CPAN?

[12:49] *** skids left
[12:49] <szabgab> I mean vcs

[12:49] <moritz_> szabgab: github, if you are happy with git

[12:49] <szabgab> and I wonder if it should be just any version control

[12:49] <moritz_> or pugs svn, if you prefer svn

[12:50] <szabgab> I am new to git but that could be ok

[12:50] <szabgab> and what name to use ? Inline::Rakudo ?

[12:51] <moritz_> From Inline::* modules I expect a similar interface as Inline::C

[12:51] <mberends> szabgab: Nicely written. I had watched the conversation in #perl6.

[12:51] <moritz_> but maybe I'm a bit off here

[12:51] *** disismt left
[12:52] <szabgab> moritz_, that's why I am not really happy with the name

[12:52] *** disismt joined
[12:52] <szabgab> thought probably I should be unhappy with the API 

[12:52] <mberends> szabgab: github names do not support punctuation or uppercase letters

[12:52] <moritz_> szabgab: maybe Rakudo::Inline?

[12:52] <szabgab> so on github I can just call it perl6_in_perl5 

[12:53] *** kane_ joined
[12:53] <mberends> even the underscore might be on thin ice, and that's risky in Israel.

[12:53] <szabgab> and the real package name can be decided once and if the code is actually useful

[12:54] <mberends> true

[12:54] <masak> szabgab: or use dashes; that's nicer :)

[12:56] <Matt-W> mberends: I see nothing about not being able to find a nonexistent sub

[12:56] <masak> Matt-W: have you committed and pushed everything?

[12:57] <Matt-W> ah I just rebuilt from scratch

[12:57] <Matt-W> now I see it

[12:57] <Matt-W> the disadvantage of precompiling modules

[12:57] <mberends> there's a utility called 'make' ;-)

[12:58] <Matt-W> yeah it doesn't seem to be getting the dependencies right

[12:58] <Matt-W> I'll have to check my makefile.in

[12:58] <Matt-W> duh

[12:58] <Matt-W> bash bash bash

[12:58] <Matt-W> stupid stupid stupid

[12:58] <masak> Matt-W: I've learned to write 'make; perl t/testfile.t' as a reflex

[12:58] <mberends> er, perl6 ?

[12:58] <pmurias> ruoso: the GSoC proposal has to specify a list of task with a schedule?

[12:58] <masak> mberends: ah, right. :)

[12:59] <masak> Matt-W: as a rule, build .pm files bottom-up according to the dep tree.

[12:59] <Matt-W> mberends: right, now I'm back to "Null PMC access in invoke()

[12:59] <Matt-W> "

[12:59] <Matt-W> masak: yes I realise that :)

[13:00] <masak> Matt-W: we should have a utility that builds Makefile.in for us :)

[13:00] <ruoso> pmurias, yes

[13:00] <ruoso> I think

[13:01] <mberends> masak: who gets that job?

[13:01] <moritz_> the one who asks

[13:01] <masak> d'oh!

[13:01] <Matt-W> masak does!

[13:01] <Matt-W> go go go!

[13:01] <masak> it's not that hard, really.

[13:02] <masak> assumind 'use' statements are at the top of the file.

[13:02] <masak> I'll see what I can throw together in five minutes :)

[13:03] * Matt-W pushes to form

[13:03] <Matt-W> now we have the fun part

[13:03] *** PZt joined
[13:04] <mberends> I preferred the previous error message :)

[13:05] <Matt-W> yes so did I

[13:05] <Matt-W> the trick will be figuring out what circumstances trigger that and filing a bit

[13:05] <Matt-W> bug*

[13:05] * Matt-W goes to experiment

[13:07] <Matt-W> doh

[13:07] <Matt-W> again

[13:07] <Matt-W> stupid stupid stupid

[13:07] <Matt-W> oh maybe not

[13:07] <Matt-W> that was a bug I hadn't triggered yet that I just fixed :)

[13:10] *** kimtaro joined
[13:10] <Matt-W> interesting

[13:10] <Matt-W> the bug is to do with enums

[13:11] <mberends> enums are a bit... incomplete

[13:12] <jnthn> Aye, enums need work.

[13:12] * moritz_ submitted a few enum tickets as well

[13:12] <moritz_> rakudo: say Bool::True.perl; say True.perl;

[13:12] <jnthn> Basically they want a re-write.

[13:12] <p6eval> rakudo 1c263b: OUTPUT«Bool::True␤.new()␤»

[13:13] <moritz_> in the second case it picks up the method from Object

[13:13] <moritz_> even though True and Bool::True should be aliases

[13:13] <jnthn> Heh, and then there's the whole "is Bool really an enum" thing. ;-)

[13:14] <moritz_> and the "is an enum really a role as well" thing

[13:14] <Matt-W> and the whole 'why do I have to say Bool::True' thing

[13:14] <masak> ta-daa! http://gist.github.com/83545

[13:15] <mberends> Matt-W: moritz_++ clarified earlier today that only one 'make' per .parse actually produces output. The makes in Actions will clobber each other as the nested matches unwind. Is that how you see it?

[13:15] *** pmurias left
[13:15] <Matt-W> mberends: yes

[13:15] <mberends> ok, looking elsewhere

[13:15] <szabgab> jnthn hi

[13:16] <Matt-W> it should be pulling the result from the previous make, doing something to it, then make()ing that

[13:16] <Matt-W> the bug is using an enum in another module somehow

[13:16] <szabgab> yesterdays helpwas rally great!

[13:16] <Matt-W> just trying to boil it down as much as possible

[13:16] <szabgab> and I should type slower

[13:16] *** PerlJam left
[13:16] *** PerlJam joined
[13:17] <Matt-W> right

[13:17] <Matt-W> do we have this bug already

[13:17] <Matt-W> rakudo: module A { enum B<a b c>; }; my $e = A::B::b;

[13:17] <szabgab> any idea why do I get an error t/01-simple...."load_bytecode" couldn't find file 'PCT.pbc' if I run my script from any other place than the parrot root directory ?

[13:17] <p6eval> rakudo 1c263b: OUTPUT«Null PMC access in invoke()␤current instr.: '_block21' pc 63 (EVAL_25:41)␤»

[13:18] <jnthn> szabgab: Glad yesterday helped. ;-) I suspect issue is Parrot is having...issues...locating PCT.pbc. I'm not sure where it's trying to look though.

[13:18] <jnthn> Which would be interesting to know.

[13:19] <Matt-W> oh do we have no RT at the moment

[13:19] <jnthn> I'm not sure if it's possible to specify extra places to look...

[13:21] <szabgab> ok, I just called load_bytecode path/to/PCT.pbc 

[13:21] <szabgab> which then complained about another thing

[13:21] <szabgab> I am not sure it's a good idea to add them one by one

[13:22] <mberends> Matt-W: move the enum out of the module for a slight loss of encapsulation but a working result.

[13:23] <Matt-W> mberends: multiple modules require the enum

[13:23] <Matt-W> putting it in any of them would be wrong

[13:23] <Matt-W> other than the one it's in

[13:24] <Matt-W> I could duplicate for the time being I suppose

[13:24] <mberends> rakudobug now; refactor later

[13:24] <masak> mberends++

[13:25] <mberends> running code wins every time ;)

[13:25] <Matt-W> pfft

[13:25] <Matt-W> it wouldn't work at all if they didn't translate into numbers

[13:27] <Matt-W> but I don't like thinking of them like that

[13:27] <Matt-W> they're new unique values that don't translate into any other domain

[13:27] <Matt-W> (in this context, anyway)

[13:27] <mberends> and then there's reality

[13:27] <Matt-W> it's overrated

[13:28] * masak likes lines($file)

[13:29] <Matt-W> does Rakudo understand $match_object.ast yet?

[13:29] <moritz_> it does

[13:29] <Matt-W> excellent

[13:29] <Matt-W> I can tidy up a bit then

[13:29] <Matt-W> I do prefer it to having to do $( $match_object )

[13:29] <moritz_> it just proxies $( $/ ) for now, but that might change in future

[13:29] <Matt-W> don't care :)

[13:30] <moritz_> :-)

[13:30] <Matt-W> that's what encapsulation is for

[13:30] <Matt-W> I don't *have* to care

[13:30] <moritz_> aye

[13:30] <Matt-W> all I know is that I get the result object

[13:30] <Matt-W> in a way that makes a bit more sense

[13:30] <moritz_> I had to care at the time I implemented .ast

[13:30] <Matt-W> well yes

[13:31] * Matt-W ticks off one more passing test in form

[13:31] <Matt-W> found another one that doesn't though

[13:31] <Matt-W> boooooooo

[13:34] <Matt-W> the result object seems to be a Str, not a TextField

[13:34] <Matt-W> boooo

[13:35] <Matt-W> ahah

[13:36] <Matt-W> (half-finished new features)--

[13:39] <masak> do we have an equivalent of Ruby's String#ljust ?

[13:39] <masak> http://gist.github.com/83548

[13:41] <mberends> just the job for Form

[13:41] <masak> :)

[13:41] <Matt-W> okay, if I have a rule that's like /(a)*/ and I've got its match object, can I get a list of captured subpatterns?

[13:42] <masak> mberends: I was hoping not to have to include another module to do this.

[13:42] <PerlJam> eval: sprintf(":%-20s:", "foo");

[13:42] <PerlJam> er ... do that right

[13:42] <PerlJam> and that's it.

[13:42] <masak> PerlJam: thanks.

[13:42] <PerlJam> rakudo: printf(":%-20s:\n", "foo");

[13:42] <p6eval> rakudo 1c263b: OUTPUT«:foo                 :␤»

[13:42] <Matt-W> masak: we will, when I write it for Form :)

[13:43] <masak> rakudo: say sprintf("%-20s", "foo")

[13:43] <p6eval> rakudo 1c263b: OUTPUT«foo                 ␤»

[13:43] <Matt-W> and it'll be in Form::TextFormatting

[13:43] <masak> Matt-W: cool.

[13:43] *** xinming left
[13:43] <Matt-W> every time there's a gust of wind, the lamppost outside the window wobbles in a most alarming manner

[13:43] *** riffraff joined
[13:44] <jnthn> Matt-W: Forthcoming lamppost fail? :-)

[13:44] <Matt-W> jnthn: I hope not, it's in a good position to break a great deal of my landlord's glass

[13:45] * Matt-W consults S05

[13:45] *** xinming joined
[13:46] *** skids joined
[13:49] <amoc> is it right that Perl6 is based on MetaObjectProtocol ?

[13:50] <moritz_> it is

[13:50] <PerlJam> only time will tell if it's right or not  ;-)

[13:50] <masak> we're also based heavily on operators.

[13:51] * amoc inserts perl6 link at see also entry in Metaobject wiki page..

[13:52] <masak> is there a method form of .() ?

[13:53] <ruoso> masak, postcircumfix:<( )>($capture)

[13:53] <jnthn> Matt-W: Would make a create failblog entry though. ;-)

[13:53] <jnthn> s/create/great/

[13:53] * jnthn can't type anything right today

[13:53] <ruoso> masak, but supposedly, .() is a multi that happens to call that method at some point in the default implementation

[13:53] <Matt-W> maybe by somebody who didn't live in the house it crushes :)

[13:53] <PerlJam> jnthn: step away from the rakudo  then!  ;-)

[13:55] <masak> ruoso: I'm asking, because Ruby's Rack ducktypes on .call methods, making it possible to supply a Rack application with a closure.

[13:55] <jnthn> PerlJam: I comitted nothing today. :-P

[13:56] <ruoso> masak, but you can simply say $foo.()

[13:56] <ruoso> and it will consider $foo to be a callable

[13:57] <masak> ruoso: yes, sure. but I meant on the callee side.

[13:57] <masak> ruoso: in Ruby, one simply defines a 'call' method.

[13:57] <ruoso> ah...

[13:57] <ruoso> you define postcircumfix:<( )>($capture)

[13:57] <ruoso> it's in Ssomething

[13:57] <moritz_> so $x.foo calls $x.call('foo') ?

[13:57] <masak> yeah.

[13:57] <ruoso> ah...

[13:58] <ruoso> in that case it's a bit more complex

[13:58] <moritz_> masak: rakudo implements 'handles'

[13:58] <ruoso> since that's made through HOW

[13:58] <bacek> good night

[13:58] <masak> ruoso: do you agree that postcircumfix:<( )> is slightly less pretty than 'call'?

[13:58] <ruoso> masak, it's not the same thing... 

[13:58] <masak> moritz_: I don't see how that helps me.

[13:58] <PerlJam> perl6 has call() too, doesn't it?   Or am I conflating memories ?

[13:58] <ruoso> masak, postcircumfix:<( )> is the API of callable

[13:58] * bacek reading parrot's documentation on localhost:1234 using httpd.pir

[13:59] <masak> ruoso: well, so is 'call' for Ruby lambdas.

[13:59] <bacek> http://localhost:1234 of casue :)

[13:59] <ruoso> masak, what you want is $foo.dispatch('foo', $catpure);

[13:59] <ruoso> masak, er... that's not what moritz_ pointed and you agreed

[13:59] <masak> buubot: spack \bdispatch\b

[13:59] <buubot> masak: S02-bits.pod:5 S03-operators.pod:22 S04-control.pod:1 S05-regex.pod:4 S06-routines.pod:16 S09-data.pod:1 S12-objects.pod:35 S13-overloading.pod:7

[13:59] <moritz_> masak: it allows you for example to turn all calls of the form $x.is_something into calls to $x.attrib.your_method()

[13:59] <Matt-W> gargh

[14:00] * masak is 100% confused now

[14:00] <jnthn> bacek: You got Parrot sockes working?!

[14:00] <jnthn> *sockets

[14:00] <Matt-W> everything is fine until I get to the action method for TOP, which is suddenly only seeing strings as match objects from the subpattern

[14:00] <Matt-W> nnnnrgh

[14:00] <bacek> jnthn: unix version

[14:00] <jnthn> bacek++

[14:00] <moritz_> Matt-W: there's a bug that .kv and .pairs stringify matches...

[14:00] <Matt-W> moritz_: not using those

[14:01] <bacek> jnthn: It took little bit more than I expected...

[14:01] <ruoso> masak, sorry... $foo.^dispatch('method', $capture)

[14:01] <ruoso> but in that case $foo is a regular object that implements 'method'\

[14:01] <moritz_> Matt-W: and that usually also occurs when you forgot to add {*} to the subrules that TOP calls

[14:01] <masak> ruoso: I think we're talking across purposes.

[14:01] <Matt-W> moritz_: they're there, I can see the action methods being called

[14:01] <moritz_> Matt-W: if it's neither of those, file a bug report once RT is back up

[14:01] <masak> ruoso: I'm not looking to do dispatch.

[14:02] <ruoso> masak, what are you looking for?

[14:02] <Matt-W> moritz_: I haven't yet convinced myself I'm doing this right

[14:02] <masak> ruoso: I'm looking to emulate Ruby's ducktyping on the 'call' method for objects sent into Rack.

[14:03] <masak> ruoso: where the nice thing is that lambdas (Rubese for 'closures') already have such a method.

[14:03] <ruoso> I don't really see what you mean...

[14:03] * ruoso going to look what "call" does in Ruby

[14:03] <masak> ruoso: given a closure, it invokes that closure.

[14:04] <ruoso> masak, thats .()

[14:04] <moritz_> ruoso: if you find a nice explanation let me know

[14:04] <masak> ruoso: aye.

[14:04] <moritz_> so what's the problem now?

[14:04] <ruoso> masak, $foo.() assumes $foo is Callable

[14:04] <jnthn> masak: If the closure is in $foo, just $foo() would call it

[14:04] <ruoso> Callable defines method postcircumfix:<( )>($capture)

[14:04] <masak> ruoso: so my conclusion is that doing the equivalent of defining 'call' in Perl 6 is slightly less elegant than in Ruby.

[14:05] * ruoso likes the extra dot ;)

[14:05] <ruoso> masak, I don't get it... how is ".()" less elegant than ".call()"

[14:05] <masak> ruoso: it's not, on the caller side.

[14:05] *** alester joined
[14:05] <moritz_> I think what masak wants to do is turning an object into something callable

[14:05] <masak> moritz_: more or less.

[14:05] <ruoso> you just need to implement Callable

[14:05] <ruoso> what's wrong about that?

[14:05] <moritz_> masak: what's the "less" part?

[14:06] <masak> moritz_: well, for one postcircumfix:<( )>() is longer than call()

[14:06] *** parduncia_ joined
[14:06] <masak> moritz_: I'd also guess that it's harder to remember.

[14:06] *** parduncia_ left
[14:07] <moritz_> aye

[14:07] <masak> oh well.

[14:07] <ruoso> masak, the syntatical category of the ops is already used by a lot of objects...

[14:08] <ruoso> Positionals need to implement postcircumfix:<[ ]>

[14:08] <ruoso> and so on

[14:08] <masak> ruoso: I'm not proposing we change anything :)

[14:08] <masak> ruoso: I'm just designing Web.pm out loud.

[14:09] <ruoso> masak, alright then ;)

[14:11] <masak> rakudo: class A { method postcircumfix:<( )>() {} }

[14:11] <p6eval> rakudo 1c263b: OUTPUT«Malformed method definition at line 1, near "postcircum"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[14:11] *** nihiliad joined
[14:11] <moritz_> treating things as callable is a cool idea, because it means you don't have to come up with a standardized method name :-)

[14:12] <[particle]> rakudo doesn't understand foo:<bar> syntax yet

[14:12] <masak> moritz_: another cool idea stolen from Rack. :)

[14:12] <masak> [particle]: I suspected that.

[14:13] <ruoso> masak, remember it is important that the action processing takes at least two different stages...

[14:14] <ruoso> execute happens from least specific to most specific

[14:14] <ruoso> end happens from most specific to least specific

[14:14] <ruoso> (that assuming chains....)

[14:15] <masak> ruoso: I'm not the guy with that abstraction level.

[14:15] <masak> ruoso: I'm doing requests and responses.

[14:15] <ruoso> ah... ok...

[14:15] * Matt-W pushes form: all current parsing tests now work

[14:16] *** ZuLuuuuuu joined
[14:16] <masak> Matt-W++

[14:16] <Matt-W> finally figured out what was going on

[14:16] <Matt-W> Might try and write it up right now, actually

[14:16] <masak> Matt-W: do it!

[14:18] *** Exodist joined
[14:21] *** zamolxes joined
[14:24] *** parduncia left
[14:28] <pmichaud> good morning #perl6

[14:28] <masak> oh hai pmichaud 

[14:28] <moritz_> hi there

[14:28] <PerlJam> morning pm

[14:29] *** xinming_ joined
[14:30] <jnthn> morning pmichaud 

[14:33] *** ejs1 left
[14:35] *** disismt left
[14:36] *** disismt joined
[14:39] *** hercynium joined
[14:41] *** xinming left
[14:48] <moritz_> pmichaud: currently .kv and .pairs on Match objects stringify their values... could you take a look at it sometimes soon? things I'm working on in Match.chunks etc. are blocking on it

[14:48] <moritz_> I could also use some very ugly workarounds...

[14:49] *** ruoso left
[14:50] <pmichaud> moritz_: yes, I can take a look at it very soon.  Much of Match is set to be refactored soon anyway.

[14:50] <pmichaud> e.g., to set up .ast and eliminate .item and the like.

[14:52] <masak> and .text

[14:52] <moritz_> pmichaud: great

[14:53] <jnthn> pmichaud: Planning a Rakudo day this week. Thu is not so good (Slovak class), Fri neither (flying in the evening), but tomorrow or Wed would work for me. How about you?

[14:54] <pmichaud> either tomorrow or Wed should be fine.  Wed _might_ be a little better because I'm finding there's a lot of other things I'm having to catch up on.

[14:54] <jnthn> (I've got a huge task list of stuff if you're not going to be about anyway...)

[14:54] <jnthn> Ah, Ok.

[14:54] <jnthn> OK, Wed it is.

[14:54] <pmichaud> I should be about all week.

[14:54] <jnthn> I'm away weekend + Monday.

[14:54] <pmichaud> but I might have to work on non-Parrot/Rakudo stuff while I'm here.

[14:55] <jnthn> (Mostly or entirely offline away)

[14:55] <pmichaud> for example, right now I have to take my car back into the shop to find out why the wheels are making a funny noise.

[14:55] <jnthn> :-S

[14:56] <pmichaud> also have to get our taxes done this week :-|

[14:56] <jnthn> Ugh.

[14:57] * jnthn got his out of the way in January. Then, his deadline was end of Jan...

[14:57] <pmichaud> yes, this year is slightly challenging for taxes in many respects -- both Paula and I had significant events in 2008

[14:58] <jnthn> Yes. And from what I've heard, the US tax system is optimized for consuming people's time and providing potential to make mistakes...

[14:58] <jnthn> Since the UK developed online filing, the whole thing became scarily efficient...

[14:59] <jnthn> Unfortunately, I've now left the UK.

[14:59] <jnthn> Well, unfortunate it that sense.

[14:59] <jnthn> Fortunate in others. :-)

[14:59] <pmichaud> well, "potential to make mistakes" also leaves lots of room for tax evasi.... er, creative accounting.  :-)

[14:59] *** Kisu joined
[14:59] <jnthn> Tax *optmization*. ;-)

[15:00] <jnthn> dotax -Otax_payable

[15:00] <pmichaud> it's a time-honored tradition among many high-ranking government officials in the U.S.

[15:00] <pmichaud> (or "wannabe high-ranking officials")

[15:00] <jnthn> ;-)

[15:01] *** nihiliad left
[15:02] *** ruoso joined
[15:02] <pmichaud> okay, off to take my car back to the shop, visit the bank, the post office, etc.  bbiah

[15:03] <TimToady> moritz_: I did clarify your .caps yesterday, but perl.org hasn't coughed up the email yet

[15:05] <ruoso> TimToady, I was backlogging and see you comment on @@ and slices... that reminded me of the idea of replacing '@@' by ¢, replacing "slice context" by "capture context"... do you think that change is going to happen?

[15:06] <TimToady> we could just make @@ the Texas form of ¢

[15:07] <ruoso> right... but you do remember that the idea was to make it clear that it's not just about lists, right?

[15:07] <moritz_> TimToady: I've seen it, thanks

[15:07] <TimToady> I'm not big on clarity at this time of morning :)

[15:07] <moritz_> TimToady: at least I saw the commit

[15:07] <TimToady> also a commit about top-level namespaces

[15:08] <TimToady> which should also imply some tests

[15:08] <ruoso> TimToady, ok... I just wanted to bring it on again, so that doesn't hurt us too much in the future (as the last change in captures did ;)

[15:08] <TimToady> UNIT::OUTER == SETTING, for instance

[15:08] <moritz_> when I have a regex like /[ (\d) \s*]+/, then $0 is List - can I assume that this will flatten?

[15:08] <TimToady> ruoso: I can understand that :)

[15:08] <moritz_> so that $/.caps will have two pairs 0 => Match.new(...) when the bracket matched twice

[15:09] <ruoso> moritz_, it should only flatten if you assign it to a list...

[15:09] <TimToady> moritz_: correct, there can be dup keys

[15:09] <moritz_> ruoso: the question is if $/.caps flatten it... which TimToady just answered :-)

[15:09] <moritz_> TimToady: ok, then I understood it correctly... will update the tests soon

[15:11] <TimToady> and STD/Cursor has a prototype implementation of .caps, but of course the P5 version of it just pushes keys and values in alternation

[15:12] <ruoso> TimToady, is it sane to define as a general policy that flattening only happens in list assignment?

[15:13] <TimToady> assignment?

[15:13] <TimToady> or context?

[15:13] *** PacoLinux joined
[15:13] <ruoso> TimToady, I was thinking that maybe a bind to a list could keep it unflattened

[15:14] <ruoso> my @a := foo();

[15:14] <ruoso> so...

[15:14] <ruoso> my @a := (((1,2,3),2,3),2,3); say @a[0].per; #prints "((1,2,3),2,3)"

[15:14] <TimToady> seems like map {...}, list foo() should flatten

[15:15] <ruoso> ok... 

[15:15] <ruoso> point taken

[15:15] <TimToady> course, map is already list context, but that's the point

[15:16] <ruoso> it might be a bit tricky to get the above example to work

[15:16] <TimToady> but then what about slice map {...}, foo()

[15:16] <ruoso> i.e. to amke it flatten... (I mean the example I wrote)

[15:16] <ruoso> TimToady, the signature of map causes the flattening...

[15:17] <ruoso> but I'm not sure how that works...

[15:19] <ruoso> maybe there's an explicit coercion going on before the bind

[15:20] <TimToady> hmm, map seems more like a factory factory that takes a closure and a capture and generates a factory that generates a filter when it actually knows the whether its context is list/slice/eager/hyper whatever

[15:21] <TimToady> or something like that...

[15:21] <ruoso> hmm... I'm not sure it is map-specific

[15:21] <ruoso> my @a := (((1,2,3),2,3),2,3); 

[15:22] *** gdonald joined
[15:22] <ruoso> exposes the same issue

[15:23] <ruoso> pugs: my @a := (((1,2,3),2,3),2,3); say @a.perl; 

[15:23] <p6eval> pugs: OUTPUT«\(1, 2, 3, 2, 3)␤»

[15:23] <ruoso> pugs: my @@a := (((1,2,3),2,3),2,3); say @@a.perl; 

[15:23] <p6eval> pugs: OUTPUT«\(1, 2, 3, 2, 3)␤»

[15:23] <ruoso> ok... pugs is not building the list lazily

[15:23] *** kane__ joined
[15:24] <ruoso> er... unflattened, actually

[15:24] <TimToady> I sense that if we get too fancy here we'll turn into Haskell  :)

[15:24] *** gdonald left
[15:24] <ruoso> TimToady, right... but... do we have a choice?

[15:24] <ruoso> I mean

[15:25] <ruoso> we support unflattened lists... 

[15:25] <ruoso> that flatten automatically

[15:25] <ruoso> this is "too fancy"

[15:26] <PerlJam> ruoso: my @a = flatten (((1,2,3),2,3),2,3);  #  :-) problem "solved"

[15:26] <masak> rakudo: my $a = "foobar"; $a ~~ /foo/; say $a.substr($/.to) # emulating $'

[15:26] <p6eval> rakudo 1c263b: OUTPUT«bar␤»

[15:26] <masak> Rakudo++

[15:27] <ruoso> PerlJam, while making the flattening explicit is completely unexpected... It's not that all a bad idea...

[15:28] <PerlJam> well, I don't know that I made it explicit really.  I just changed one syntax for another.

[15:31] <ruoso> because in fact, all the "flattening" process is very much obscure yet...

[15:31] *** kane___ joined
[15:31] <ruoso> we all agree that @a = (((1,2,3),2,3),2,3); should result in (1,2,3,2,3,2,3)

[15:31] <ruoso> but...

[15:32] <PerlJam> yes.  Perhaps it needs to be "louder" than happen en passant in certain contexts

[15:33] <ruoso>  my @a = map { ($_,$_),$_) }, 1,2,3

[15:33] <ruoso> what defines the flattening... is it the use of "(" ")"?

[15:33] *** ejs joined
[15:34] <ruoso>  my @a = map { (($_,$_),$_) }, 1,2,3

[15:34] <ruoso> the line before that was wrong

[15:34] <masak> in a 'when' expression, can I match against either of two regexes somehow? an or-junction, perhaps?

[15:35] <ruoso> masak, yes... that's one of the primary uses for junctions...

[15:35] <TimToady> seems like binding a capture into @x causes the binding to happen to generator of @x, not the array container itself

[15:35] <masak> rakudo: my $a = "foo"; given $a { when /foo/ | /bar/ { say "OH HAI" } }

[15:35] <p6eval> rakudo 1c263b: OUTPUT«OH HAI␤»

[15:35] <masak> cool.

[15:36] <TimToady> or looking at it the other way, when a capture finds itself being bound into a container of a certain type, it transforms itself into something suitable to be bound to that container

[15:36] <ruoso> the problem is that binding doesn't really touch the rvalue

[15:36] <TimToady> which in the case of an array is an empty array fed by the flattened capture list

[15:36] <ruoso> at least until now

[15:37] <TimToady> doesn't have to, just provides a different iterator, I think

[15:37] <[particle]> so, captures are amorphous solids, they are not rigid, and given proper conditions, *eventually* take the shape of their containers.

[15:37] <ruoso> that sounds weird

[15:38] <TimToady> well, time travel is usually weird, but that's the whole point of captures

[15:38] <ruoso> the problem is that this works fine for assignemnt... but sounds strange for binding

[15:38] <TimToady> they're an entanglement of arguments that don't collapse until observed

[15:38] <PerlJam> masak: though, I don't see Junction explicitly mentioned in the smart match table in S03, so maybe that needs more documentation.

[15:39] <TimToady> forget assignment, it's a second-order operation

[15:39] <masak> PerlJam: maybe it simply autothreads.

[15:39] <[particle]> i'm trying to stay with classical mechanics here--you just can't resist going quantum :)

[15:39] <TimToady> you of all people...

[15:39] <masak> PerlJam: though I'm a bit uncerain what would happen in the face of several simultaneous matching regexes.

[15:39] *** kane_ left
[15:40] * [particle] waves

[15:40] <PerlJam> heh

[15:40] <masak> TimToady: maybe he's both classical and quantum, depending on one's perspective. :)

[15:40] <PerlJam> so ... a capture is a quantum of uncertainty?

[15:40] <TimToady> well, we're emulating quantum with classical, of course, just as we are with junctions

[15:40] <[particle]> i'm moving slowly this morning, like timtoady

[15:40] <ruoso> hmm...

[15:40] <masak> saving relativistic for the evening.

[15:40] <TimToady> it's an entanglement that has not yet been observed

[15:41] <ruoso> that means 1 of 2 things...

[15:41] <TimToady> context is the observation

[15:41] *** pmurias joined
[15:41] <ruoso> 1) every value has the chance of modifying itself for a bind operation

[15:41] <ruoso> 2) the runtime checks to see if that's a capture, which might need to modify itself for a bind operation

[15:41] <TimToady> more like

[15:42] <TimToady> 1) capture has the chance to modify itself as soon as it knows the context

[15:42] <TimToady> 2) binding is one way of providing context

[15:43] <ruoso> right... right... but in order to "capture" to have a chance, we either make it an exception, or provide that to every object...

[15:43] <ruoso> hmm... can we know syntatically when we're dealing with captures?

[15:44] <TimToady> I believe so

[15:44] <TimToady> though of course $x could contain one without knowing it

[15:45] <[particle]> or an anonymous closure

[15:45] <TimToady> but that's the difference between \ and not \

[15:45] <ruoso> but it doesn't perform as a capture unless you de-reference it

[15:45] <TimToady> right, so basically yes, wrt naked captures

[15:45] <TimToady> we've tried to keep that an invariant

[15:46] <ruoso> ok... so the only way of getting a capture as-is is to use the capture sigil

[15:46] <ruoso> or use the capturize opertor

[15:46] <TimToady> or binding to an appropriate thingie

[15:47] <ruoso> like?

[15:47] <TimToady> we currently have |$x and @@x which we're thinking how to unify

[15:47] <TimToady> possibly using ¢

[15:48] *** kane__ left
[15:48] <TimToady> e=m¢²

[15:49] <ruoso> so... "my $a := \foo()" is the same as "my ¢a = foo()"

[15:49] <ruoso> actually

[15:49] <ruoso> "my $a = \foo()" is the same as "my ¢a = foo()"

[15:50] <ruoso> "foo(|$a)" is the same as "foo(¢a)"

[15:50] <TimToady> funny that ¢ can be taken to mean "no context"

[15:50] <ruoso> yes... precisely...

[15:51] <skids> ...or french \(

[15:51] <lambdabot> skids: You have 2 new messages. '/msg lambdabot @messages' to read them.

[15:51] <[particle]> ahem. that's E, not e.

[15:51] <TimToady> that would be precisement

[15:52] <ruoso> my $a = \foo() is an explicit request to "enclose the capture in a scalar"

[15:52] <TimToady> sorry, git doesn't support uppercase

[15:52] <ruoso> my ¢a = foo() is simply "don't do anything with the return of foo"

[15:53] <TimToady> I can see some styles of programming where that turns into my a = foo(), but nevermind

[15:53] <[particle]> ¢grammar

[15:53] <[particle]> there's only one reasonable thing that variable can contain.

[15:54] <TimToady> not C#?

[15:54] <[particle]> :)

[15:56] <skids> But if it's also @@ that means it indexes, right,  􏿽xA2a[0]?  In fact you have to index it?

[15:56] <TimToady> nature abhors a naked ¢ingularity, but that will confuse the phone people...

[15:56] <ruoso> skids, the question is not if you index it or not... but if you flatten it or not...

[15:57] <TimToady> which is to say [0] produces something different on the capture than on the flattened list

[15:57] *** nihiliad joined
[15:57] <TimToady> well, depending on whether the first positional is itself a capture...

[15:57] <[particle]> captures are as confusing as soap envelopes

[15:58] <ruoso> captures are more unstable matter than junctions

[15:58] <Matt-W> All I've done with captures is rather akin to a Perl 5 reference - stopping a hash interpolating into a list

[15:58] *** meppl joined
[15:59] <ruoso> Matt-W, except that it holds both positional and named...

[15:59] * ruoso .oO( that looks like a php array ;)

[15:59] <TimToady> php confuses the two

[15:59] <TimToady> captures keep them separate

[15:59] <Matt-W> yeah well I just did a very simple thing, I know they can do a whole load of weird stuff I don't understand yet

[16:01] <TimToady> in Perl 5 terms, they let us defer the decision on the context of (@array,1,2,3) until we know whether we're calling push or say

[16:02] <masak> rakudo: 'class A { has %!env; method new(%env) { return A.bless({ env => %env }); }; method foo { return %!env<foo> } }; say A.new({ "foo" => "OH HAI"}).foo

[16:02] <p6eval> rakudo 1c263b: OUTPUT«Syntax error at line 1, near "'class A {"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[16:02] <masak> rakudo: class A { has %!env; method new(%env) { return A.bless({ env => %env }); }; method foo { return %!env<foo> } }; say A.new({ "foo" => "OH HAI"}).foo

[16:02] <p6eval> rakudo 1c263b: OUTPUT«Use of uninitialized value␤␤»

[16:02] <masak> what am I doing wrong?

[16:02] <ruoso> masak, iirc, bless receives the candidate object as first argument...

[16:03] <ruoso> so it seems you're reblessing the hash as A

[16:03] <masak> isn't that what I want?

[16:03] <masak> I took the syntax out of S12.

[16:03] <skids> Anyway a question I sent ruoso yesterday still stands for @@a = (1,foo(),2;3,4,5); # given special capture meaning of @@, does @@a[0] call foo or only @@a[0;1]?

[16:03] <masak> this is the first new method I try to write.

[16:04] <ruoso> masak, that's actually a point I always forgot to ask for clarification...

[16:04] <masak> ok, so let's do it now. :)

[16:04] <ruoso> masak, in SMOP that is implemented through the REPR api

[16:04] * TimToady hides

[16:04] <masak> :D

[16:04] <ruoso> in my head, we need to add a special cast there...

[16:05] <ruoso> because as you can create an actual hash,

[16:05] <Matt-W> Here we go: the results of the last couple of hours of writing, testing code and fighting Wordpress: http://alledora.co.uk/wordpress/archives/2009/03/23/377 <- some gushing over grammars and action methods, probably containing mistakes.

[16:05] <masak> TimToady: come back! we need to ask you something.

[16:06] <ruoso> masak, the usual way of doing it is bless(::p6opaque.^!CREATE()) -- if we assume the REPR API

[16:06] * [particle] brews a pot of coffee for timtoady

[16:06] <TimToady> what .bless does may certainly be type dependent

[16:06] <masak> TimToady: but in the above case...?

[16:08] <ruoso> TimToady, hmm... if the candidate to bless is a hash... hmm....

[16:10] <ruoso> I'm not sure how that could be done without the REPR API

[16:10] <ruoso> but...

[16:10] <TimToady> skids: .[0] of a slice is supposed to produce the list before the first ;

[16:11] <ruoso> TimToady, but the call to foo() happens at accessing time?

[16:12] <masak> jnthn: is it possible to override 'new' in Rakudo today?

[16:12] <TimToady> no, functions are called when the capture is evaluated, but may return lazy lists themselves

[16:12] <ruoso> with the REPR API, that hash could be enclosed into ::blessedHash, which implements the REPR API using the candidate hash as storage...

[16:12] <ruoso> ok that was what I expected... and the actual question skids asked ;)

[16:12] <TimToady> $x = \(1,2,3,die "oops"); # dies before $x is assigned

[16:13] *** sri_kraih joined
[16:13] <TimToady> I don't see how it could possible get [0;1] when the first slice starts with 1

[16:13] <TimToady> *possibly

[16:14] <masak> jnthn: more precisely, if I want to override the 'new' method as I did above, how would I go about it?

[16:15] <TimToady> biab &

[16:16] <ruoso> masak, last time I checked, rakudo don't support representation polymorphism... and no plans on supporting it yet...

[16:16] <masak> ruoso: is that answer an answer to my question? :)

[16:16] <ruoso> yes...

[16:16] <masak> I was asking about the 'new' method.

[16:16] <masak> not about 'representation polymorphism'.

[16:16] <ruoso> ah... sorry... I thought it was about your earlier question

[16:17] <masak> which one?

[16:17] <jnthn> masak: (sorry, bit distracted on $other_thing atm)

[16:17] <masak> jnthn: ok.

[16:17] <jnthn> masak: I think new should be overridable

[16:17] <ruoso> the  A.bless({ env => %env }) questin

[16:17] <jnthn> Yes, basing things on other representations we don't support just yet

[16:17] <masak> ruoso: the 'bless' was just a means to an end; creating a 'new' method.

[16:17] <masak> jnthn: do you see what it is I want to do?

[16:18] <masak> (and that it doesn't work)

[16:18] <jnthn> rakudo: class Foo { method new { say 42 } }; Foo.new

[16:18] <p6eval> rakudo 1c263b: OUTPUT«42␤»

[16:18] <ruoso> you need jnthn to expose p6object to Perl 6

[16:18] <ruoso> (is that how it is called?)

[16:18] <masak> jnthn: well, saying 42 is nice and all...

[16:18] <masak> jnthn: I'd like .new to return a new object. :P

[16:18] <jnthn> Damm, awkward ain't you. :-P

[16:18] <masak> aye.

[16:19] <jnthn> masak: I think the answer involves create...can you give me some moments to finish up the other thing I'm working on, and I'll get back to you?

[16:19] <masak> jnthn: absolutely.

[16:19] <jnthn> Thanks.

[16:19] <masak> you make it sound as if I'm doing you the favour. :P

[16:21] *** FurnaceBoy is now known as FurnaceBoy|afk

[16:21] * jnthn just found one comment written in English amongst a sea of Swedish comments in a file.

[16:21] <jnthn> The comment?

[16:21] <jnthn> 'Do tha' stuff

[16:21] <jnthn> ...useful...

[16:21] <masak> 哈哈

[16:22] <masak> those Swedes...

[16:22] * jnthn sometimes wonders when reading some code if a brain isn't a pre-requisite for programming...

[16:25] * Matt-W celebrates

[16:25] <Matt-W> all Form tests now pass

[16:25] <Matt-W> no, I didn't take any of them away to achieve that

[16:25] <mberends> Matt-W++ # also for the gushing blog

[16:25] <masak> Matt-W: time to write more tests! :)

[16:26] <Matt-W> masak: no, time to make dinner, but in principle yes more tests

[16:27] <ruoso> Matt-W, btw, you don't need the gather/take to get lazyness in "for"

[16:28] *** sri_kraih_ left
[16:30] *** ejs left
[16:31] <szabgab> is there a perl 5 module that can read/read perl 6 data structures (aka .perl stringifications) ?

[16:31] <mberends> szabgab: eval()

[16:31] <szabgab> and I mean read/write of course

[16:31] <szabgab> hmm

[16:32] <masak> szabgab: read: eval. write: .perl

[16:32] <szabgab> thta's the perl 6 side

[16:32] <szabgab> and on perl 5 side that would be Data::Dumper I guess

[16:32] <szabgab> and eval

[16:32] <pmurias> v6.pm

[16:32] <Matt-W> ruoso: I don't??

[16:33] *** blongden joined
[16:33] <ruoso> Matt-W, for is lazy

[16:33] <Matt-W> oooh

[16:33] <Matt-W> okay

[16:33] <Matt-W> still, gather/take is cool

[16:33] <ruoso> Matt-W, you need to use "loop" if you really want imperative-style

[16:33] <pmurias> szabgab: to read perl6 code you need a perl6 implementation

[16:33] <Matt-W> ruoso: no thankyou :)

[16:34] <szabgab> pmurias, I am only interested in data structues that perl5 can understand

[16:34] <szabgab> BTW I put my code here: http://github.com/szabgab/perl6-in-perl5/tree/master

[16:34] <ruoso> pmurias, btw... I realized the refactoring in smop is going to make it clearer on how to implement SMOPP5

[16:35] <ruoso> SMOPP5 will just need to replace the "interpreter" module

[16:35] <ruoso> (in the smop side, that is)

[16:36] <mberends> szabgab: language independent data structures would be YAML. Perl 5 libs are stable, Perl 6 ones are in development.

[16:37] <szabgab> yeah, that might be one way to pass parameters

[16:39] <pmurias> szabgab: if you are doing language interop stringifing stuff is not a good idea

[16:39] *** blongden left
[16:39] <pmurias> unless you are interfacing with tcl

[16:39] <szabgab> I am trying to allow calling perl 6 code running in rakudo  from perl 5

[16:40] <pmurias> i guessed that ;)

[16:40] <pmurias> you should wrap the pmc as a sv and the sv as pmcs

[16:40] <jnthn> szabgab: I guess you'd need to transform the P5 variables into PMCs.

[16:41] <jnthn> I don't know a great deal of p5guts, though...

[16:41] <ruoso> rakudo: say Object.CREATE;

[16:41] <p6eval> rakudo 1c263b: OUTPUT«Object<0xb609ce80>␤»

[16:41] <ruoso> masak, that's what you need

[16:41] <ruoso> :)

[16:41] <masak> ruoso: ah.

[16:41] <pmurias> szabgab: i did something similiar for smop as my uni C course task

[16:41] <diakopter> it takes guts to learn guts

[16:42] <ruoso> p5 guts is not that complicated... 

[16:42] <szabgab> pmurias, for now the simple case of passing individual scalar works

[16:43] <szabgab> and it is not clear to me yet how should other things work

[16:43] <ruoso> szabgab, the trick is implementing a P5V PMC 

[16:43] <ruoso> *P5SV

[16:43] <szabgab> what is that ?

[16:43] <masak> ruoso: and if I want to CREATE the object with one attribute set? (as in my original one-liner)

[16:44] <szabgab> ah an SV ?

[16:44] <szabgab> don't know anything about those, but it works :-)

[16:45] <ruoso> masak, then you need the REPR API

[16:45] <ruoso> masak, but...

[16:45] <masak> ah, a glimmer of hope!

[16:45] <ruoso> BUILDALL accepts a set of protoobjects

[16:45] <ruoso> I don't know if that is implemented in rakudo

[16:46] <masak> ruoso: maybe I can CREATE, and then use the accessors on the object?

[16:46] <masak> that'd work for me.

[16:46] <ruoso> rakudo: say Int.CREATE;

[16:46] <p6eval> rakudo 1c263b: OUTPUT«0␤»

[16:46] <ruoso> rakudo CREATE is a bit smarter than expected

[16:47] <ruoso> it doesn't simply create a storage of that representation... I don't think you even need to call bless..

[16:47] <masak> rakudo: class A { has %.env is rw }; my $a = A.CREATE; $a.env = { foo => 'bar' }; say $a.env<foo>

[16:47] <ruoso> but that's not exactly the way it's specced

[16:47] <p6eval> rakudo 1c263b: OUTPUT«Null PMC access in getprop()␤current instr.: 'infix:=' pc 13848 (src/builtins/assign.pir:21)␤»

[16:47] <masak> wohoo!

[16:47] * masak submits rakudobug

[16:47] <masak> rakudo: class A { has %.env is rw }; my $a = A.CREATE; $a.env = { foo => 'bar' };

[16:47] <p6eval> rakudo 1c263b: OUTPUT«Null PMC access in getprop()␤current instr.: 'infix:=' pc 13848 (src/builtins/assign.pir:21)␤»

[16:48] <masak> rakudo: class A { has %.env is rw }; my $a = A.CREATE;

[16:48] <p6eval> rakudo 1c263b: RESULT«A.new()»

[16:48] <masak> that assignment should work, right?

[16:48] <ruoso> rakudo: class A { has  %.env is rw }; my $a = A.CREATE; $a.BUILDALL(env => {foo => 'bar'});

[16:48] <pmurias> are there any TPF application guidelines/templates

[16:48] <p6eval> rakudo 1c263b: OUTPUT«too many named arguments - 'env' not expected␤current instr.: 'parrot;Perl6Object;BUILDALL' pc 1272 (src/classes/Object.pir:331)␤»

[16:48] <ruoso> rakudo: class A { has  %.env is rw }; my $a = A.CREATE; $a.BUILDALL(A{ env => {foo => 'bar'}});

[16:48] <p6eval> rakudo 1c263b: OUTPUT«too few arguments passed (2) - 4 params expected␤current instr.: 'parrot;Perl6Object;BUILDALL' pc 1272 (src/classes/Object.pir:331)␤»

[16:49] <ruoso> rakudo: class A { has  %.env is rw }; my $a = A.CREATE; $a.BUILDALL((env => {foo => 'bar'}));

[16:49] <p6eval> rakudo 1c263b: OUTPUT«too few arguments passed (2) - 4 params expected␤current instr.: 'parrot;Perl6Object;BUILDALL' pc 1272 (src/classes/Object.pir:331)␤»

[16:49] <ruoso> masak, you can submit that as a rakudobug also...

[16:49] <ruoso> ah wait...

[16:49] * masak waits

[16:49] <ruoso> rakudo: class A { has  %.env is rw }; my $a = A.CREATE; A.BUILDALL($a, (env => {foo => 'bar'}));

[16:49] <p6eval> rakudo 1c263b: OUTPUT«too few arguments passed (3) - 4 params expected␤current instr.: 'parrot;Perl6Object;BUILDALL' pc 1272 (src/classes/Object.pir:331)␤»

[16:50] <ruoso> rakudo: say Object.BUILDALL.signature

[16:50] <p6eval> rakudo 1c263b: OUTPUT«too few arguments passed (1) - 4 params expected␤current instr.: 'parrot;Perl6Object;BUILDALL' pc 1272 (src/classes/Object.pir:331)␤»

[16:50] <jnthn> rakudo: class A { has  %.env is rw }; my $a = A.CREATE; A.BUILDALL(A, $a, (env => {foo => 'bar'}));

[16:50] <ruoso> rakudo: say Object.^can('BUILDALL').signature

[16:50] <p6eval> rakudo 1c263b: OUTPUT«shift_pmc() not implemented in class 'Perl6Pair'␤current instr.: 'parrot;Perl6Object;BUILDALL' pc 1341 (src/classes/Object.pir:363)␤»

[16:50] <p6eval> rakudo 1c263b: OUTPUT«Method 'signature' not found for invocant of class 'Integer'␤current instr.: 'parrot;P6metaclass;dispatch' pc 637 (src/classes/ClassHOW.pir:161)␤»

[16:51] *** Psyche^ joined
[16:51] <ruoso> rakudo: class A { has  %.env is rw }; my $a = A.CREATE; A.BUILDALL(A, $a, A{env => {foo => 'bar'}});

[16:51] <p6eval> rakudo 1c263b: OUTPUT«argument doesn't hash␤current instr.: 'parrot;Perl6Object;BUILD' pc 1142 (src/classes/Object.pir:281)␤»

[16:51] <masak> that's a reported parrotbug, methinks.

[16:51] <ruoso> jnthn, but why does BUILDALL receives A twice?

[16:52] <jnthn> ruoso: I dunno. ;-)

[16:52] <jnthn> ruoso: I haven't really looked at the object initialization stuff.

[16:52] <ruoso> rakudo: class A { has  %.env is rw }; my $a = A.CREATE; A.BUILDALL(A, $a, {env => {foo => 'bar'}});

[16:52] <p6eval> rakudo 1c263b: OUTPUT«argument doesn't hash␤current instr.: 'parrot;Perl6Object;BUILD' pc 1142 (src/classes/Object.pir:281)␤»

[16:52] <ruoso> interesting...

[16:52] <jnthn> It's managing to call a BUILD and then blowing up. Hmm.

[16:53] <jnthn> rakudo: class A { has  %.env is rw }; my $a = A.CREATE; my %h = env => { foo => 'bar' }; A.BUILDALL(A, $a, %h)

[16:53] <p6eval> rakudo 1c263b: OUTPUT«argument doesn't hash␤current instr.: 'parrot;Perl6Object;BUILD' pc 1142 (src/classes/Object.pir:281)␤»

[16:54] <jnthn> rakudo: class A { has  %.env is rw }; my $a = A.CREATE; my %h = env => { foo => 'bar' }; A.BUILDALL(A, $a, env => { foo => 'bar' })

[16:54] <p6eval> rakudo 1c263b: OUTPUT«too many named arguments - 'env' not expected␤current instr.: 'parrot;Perl6Object;BUILDALL' pc 1272 (src/classes/Object.pir:331)␤»

[16:54] <jnthn> meh

[16:54] <jnthn> I'll have to look at the spec/source.

[16:54] <ruoso> BUILDALL was supposed to have *%_ as args

[16:54] <jnthn> Yeah, I thought so too.

[16:54] <jnthn> (I actually thought it did...)

[16:55] <jnthn> (As in, did in Rakudo.)

[16:55] <ruoso> it's $proto.BUILDALL($candidate, *@protoobjects, *%attributes) IIRC

[16:58] <masak> it would be good if I could define my own 'new' method...

[16:59] <mberends> masak: it's supposed to be possible, if you make it bless your $object ... somehow

[16:59] <mberends> read that on #perl6

[16:59] <jnthn> masak: The problem isn't writing your own .new, it's just what to write in there. :-)

[16:59] <jnthn> masak: I'll look into it.

[17:00] <masak> jnthn: thank you.

[17:00] <ruoso> basically the problem seems to be in BUILDALL... all the rest seems to be working just fine

[17:00] <jnthn> Just trying to get some other bits polished off so I can spend the evening on Rakudo stuff.

[17:00] <pmichaud> I suspect that Rakudo's BUILD/BUILDALL isn't completely following the SMOP OO API yet

[17:00] <jnthn> pmichaud: Feel free to beat me to investigating; I need to finish some stuff up and then do dinner yet...

[17:01] <pmichaud> I'm still working through my backlog here -- but yes, one of us should get to it soon.

[17:01] <jnthn> Aye.

[17:01] <pmichaud> I don't have a problem with refactoring the existing BUILD/BUILDALL to be more "correct"

[17:01] <pmichaud> (i.e., I don't have a problem if someone else works on it)

[17:01] <jnthn> Sure. I just don't want to make it less correct in the process. ;-)

[17:01] <pmichaud> what's there now was simply attempting to get us through the parameter refactor earlier in the year.

[17:02] <TimToady> bless is supposed to call BUILDALL for you automatically

[17:02] <TimToady> but only if the metaclass needs it :)

[17:02] *** masak left
[17:02] <jnthn> pmichaud: Ah, OK. I feel less bad about hacking on it in that case.

[17:02] *** zamolxes left
[17:02] <ruoso> while not spec, the implementation in pugs_repo/v6/smop/src-s1p/*.pm is a result of a deep process of trying to understand S12

[17:02] <jnthn> Well, I didn't feel bad anyway, but... :-)

[17:03] <ruoso> specially ClassHOW.pm and Object.pm

[17:03] <jnthn> ruoso: Thanks, I've glanced at those before, I'll take another look.

[17:03] <jnthn> ClassHOW I already did look at a bit and followed somewhat on the dispatch thingy.

[17:04] <jnthn> But now I'm less sure dispatch's interface is really enough.

[17:05] <ruoso> jnthn, I really wish we could promote the REPR API to spec someday 

[17:05] <jnthn> (e.g. for implementing .*, .?, .+ and so forth)

[17:05] <ruoso> jnthn, I was assuming .* .? and .+ were external to the object

[17:06] <jnthn> Built through the introspection interface?

[17:06] <ruoso> yes...

[17:06] <ruoso> but...

[17:06] <jnthn> Since how a metaclass does the storage of its method table is stuff that only it knows.

[17:06] <ruoso> maybe it works as adverbs to the dispatch method

[17:06] <jnthn> Yeah

[17:06] <jnthn> I also pondered .WALK

[17:06] <ruoso> :quantifier

[17:06] <jnthn> Because surely the metaclass needs to help with that too...

[17:07] <jnthn> Or is that already in the HOW API?

[17:07] <ruoso> if it's not, it should be written

[17:07] *** Patterner left
[17:07] *** Psyche^ is now known as Patterner

[17:07] *** pmurias left
[17:08] <jnthn> Aye. But the another bit of me though, well, if we have WALK, do we really need .dispatch, or could we give .WALK an adverb saying "just the first matching one akshually"

[17:08] <jnthn> s/the/then/

[17:08] <jnthn> Which would provide our method lookup. And then it's just invoking it...

[17:08] <ruoso> jnthn, I actually wasn't thinking in WALK as a real type...

[17:08] <ruoso> I was thinking of it more like an abstract idea

[17:09] <jnthn> ruoso: Type? You mean method?

[17:09] <ruoso> er... the method is ^can

[17:09] <jnthn> OK, but my point is that if we've got all these, do we really need ^dispatch too?

[17:09] *** pmurias joined
[17:10] <ruoso> jnthn, I see your point...

[17:11] <jnthn> ruoso: (BTW WALK is listed as a method in S12)

[17:11] <jnthn> ruoso: I'm just thinking that it feels like it'd be duplication of code.

[17:11] <ruoso> hmm...

[17:11] <baest> hello, I've found a test file in t/spec which isn't used in rakudo, but 14 out of 17 tests passes fine (with a single error correction in the test). I've added 'rakudo skip' for the failed tests for now. Can I submit a patch and if yes where to?

[17:11] <ruoso> I missed that..

[17:12] <ruoso> jnthn, I think this represents different levels of abstraction

[17:12] <jnthn> baest: You can likely just have a commit bit to the Pugs repo to update the spectest.

[17:12] <ruoso> .^dispatch being the most opaque

[17:12] <ruoso> .WALK being the most transparent

[17:12] *** gdonald joined
[17:12] <jnthn> baest: But patches can go to [email@hidden.address]
[17:13] <baest> jnthn: I think I've have a commitbit for pugs, but I've misplaced it (never used it and got 2 years ago)

[17:13] *** gdonald left
[17:14] <baest> jnthn: great thanks, just a update to t/spectest.data so I'll post that

[17:14] <jnthn> OK, great.

[17:14] <ruoso> jnthn, I think I assumed WALK is a type becuase of "Unlike in Perl 5 where .can returns a single Code object, Perl 6's version of .^can returns a "WALK" iterator for a set of routines that match the name" in S12

[17:14] <jnthn> Yeah

[17:15] <jnthn> I'm not thinking...hmm, so what is the difference between can and WALK other than that WALK lets you walk in different orderings...

[17:15] <jnthn> Oh, and gives a list rather than an interator.

[17:15] <jnthn> Hmm.

[17:16] <jnthn> Oh, or maybe it is an iterator that gets fully evaluated on the binding.

[17:16] <ruoso> jnthn, it can be just a lazy list, can't it?

[17:16] <jnthn> Yeah, for sure.

[17:16] <jnthn> Well

[17:17] <jnthn> If we want to assume lazy lists exist at that kinda level

[17:17] <jnthn> (I'm thinking bootstrapping stuff.)

[17:17] <ruoso> I think .WALK shouldn't really be spec...

[17:17] <ruoso> it looks too much implementation specific

[17:17] <ruoso> ok... spec yes,

[17:18] <ruoso> but not required on every object...

[17:18] <ruoso> that's a different thing...

[17:18] <ruoso> like... if HOW does Walkable

[17:18] <ruoso> because not all object systems will have this information available

[17:19] <ruoso> that's where I think the different levels of abstraction play an important role

[17:19] <ruoso> for instance...

[17:19] <jnthn> Hmm.

[17:19] <ruoso> it might be possible that a HOW knows how to implement .^dispatch

[17:19] <jnthn> But what about .can in that case?

[17:19] <ruoso> but doesn't know how to implement .^can

[17:19] <ruoso> can is a in-between

[17:19] <jnthn> Since it would seem to need to return an interator of the same info.

[17:19] <jnthn> Just with less options for getting at it.

[17:19] <ruoso> but it doesn't support a lot of stuff WALK does

[17:20] <jnthn> OK, but the point is that the first result of the iterator can hands back is enough to dispatch, no?

[17:20] <jnthn> I can see why we'd not want to mandate WALK

[17:21] <ruoso> but even .^can... one object could live a long life only providing .^dispatch

[17:21] *** amoc left
[17:21] <jnthn> (To be fair, part of my point behind all of this is that while .^dispatch really doesn't fit well into the Parrot model, .^can does)

[17:22] <ruoso> .^dispatch simply provides the most opaque abstraction to call an arbitrary method in that object

[17:22] <ruoso> for instance...

[17:23] <ruoso> .^can returns a list of the candidates

[17:23] <jnthn> (If we say that it's allowable to implement . by taking the first thing .^can hands back or by calling .^dispatch and that's an implementation specific decision and the meta-class should make sure it is smart enough about that, I'm happy enough.)

[17:24] <ruoso> jnthn, that doesn't make much difference while you don't think about representation polymorphism

[17:24] <ruoso> but if you take repr into account... it makes a big difference...

[17:25] <jnthn> If you're saying that .^can should always be available, even if not .^WALK or whatever is behind WALK, I don't see how that follows.

[17:25] <ruoso> so... I'd say that you're free to optimize however you like for the known case...

[17:25] *** khisanth_ joined
[17:25] <ruoso> I say that we can even make .^can optional

[17:26] <ruoso> and provide several layers of abstraction to the metaclass implementation to choose

[17:26] <ruoso> (of course you can't use multiple dispatch if it doesn't provide WALK)

[17:26] <jnthn> Can you give me a concrete situation when this makes sense?

[17:26] <jnthn> (Not providing ^can, but providing ^dispatch)

[17:27] <ruoso> hmm..

[17:27] <ruoso> I'm mostly thikning about foreign object systems

[17:28] <ruoso> and allowing a low-barrier for the implementation of such interoperability

[17:28] <ruoso> for instance...

[17:29] <ruoso> a kinda-oo implementation in C

[17:29] <pugs_svn> r25978 | baest++ | Adding myself to AUTHORS

[17:29] <ruoso> that defines a pattern on the name of the methods

[17:29] <Matt-W> like GObject?

[17:29] *** NordQ joined
[17:29] <ruoso> yeah... for instance... (but GObject is powerful enough to provide the introspection)

[17:29] <Matt-W> true

[17:30] <Matt-W> I'm hoping one day we can get a GTK+ binding autogenerated for Perl 6 using introspection

[17:30] <pugs_svn> r25979 | baest++ | Fixing a minor bug and adding rakudo skips

[17:30] <jnthn> Hmm.

[17:30] <Matt-W> but even if it didn't have that ,it's always had a strong name patter

[17:30] <Matt-W> n

[17:31] <jnthn> Yeah, perhaps you're right there will be cases.

[17:31] <ruoso> jnthn, so simply implementing .^dispatch would allow me to use that oo system in Perl 6 

[17:31] <jnthn> Of course, ^can could always hand back an iterator of something that when you invoke it will attempt to do a call by that name.

[17:31] <jnthn> e.g. just thunk it.

[17:31] <ruoso> right... but why fake it?

[17:31] <jnthn> So there are solutions for those systems in .^can too.

[17:32] <jnthn> To be able to avoid .^dispatch.

[17:32] *** Khisanth left
[17:32] <jnthn> e.g. the need for .^dispatch

[17:32] <ruoso> what's so bad about it?

[17:32] <jnthn> Parrot's model for method invocation is two-step. Lookup, then invoke what the lookup returns.

[17:32] <ruoso> (remember, if you know the HOW and you know the REPR... you're free to optimize it)

[17:32] <jnthn> .^dispatch adds a layer of indirection.

[17:32] *** khisanth_ is now known as Khisanth

[17:33] <jnthn> Sure, but it's nice if it doesn't need optimizing. ;-)

[17:33] <ruoso> jnthn, in SMOP, for instance, .^can is considerably more expensive than .^dispatch

[17:33] <jnthn> Hmm. :-)

[17:34] <jnthn> I guess if it's optimizable for the default meta-class it's less of a concern.

[17:35] <ruoso> jnthn, but actually... I don't think we need to spec one way or another

[17:36] <jnthn> Well, we do if ^can is meant to be optional. ;-)

[17:36] <ruoso> right...

[17:36] <TimToady> it would be nice if nextsame were not implementation dependent though

[17:36] <TimToady> at least for P6 objects

[17:36] <TimToady> point taken about foreign methods

[17:37] <ruoso> my point was actually just about that

[17:37] <ruoso> I mis-expressed myself

[17:38] <ruoso> jnthn, in SMOP every invocation is internal to the object... that's the fundamental difference in our pov

[17:38] <jnthn> ruoso: Clarify what you mean by "internal to the object"

[17:39] *** kolibrie joined
[17:39] <ruoso> it means that $obj.foo in Perl 6 turns out to be $obj.foo in the low-level as well

[17:39] <ruoso> the invocation is equal in low-level or high-level

[17:39] <jnthn> Right, which I'd kinda like to be true in Parrot. ;-)

[17:39] <ruoso> but that means I have no public vtable

[17:40] <ruoso> every invocation is the high-level invocation... receiving a caputre

[17:40] <jnthn> Thing is that the lookup of what to call is internal to the object.

[17:40] <jnthn> (In Parrot)

[17:40] <jnthn> That's what find_method does

[17:41] <ruoso> but the invocation itself is external 

[17:41] <jnthn> find_method hands back what to invoke

[17:41] <jnthn> And we it's invoked

[17:42] <jnthn> s/we/then/

[17:42] <ruoso> where find_method is in the vtable, is it?

[17:42] <jnthn> Or put another way, ^can and postcircumfix:{ } map quite neatly down to Parrot

[17:42] <jnthn> Yes, find_method is in the PMC vtable.

[17:42] <ruoso> having dispatch in the PMC vtable would be too bad?

[17:42] <jnthn> Where as ^dispatch maps less neatly.

[17:43] <jnthn> It would be. The point is that vtable calls are pretty "low-level" things.

[17:44] <jnthn> You perform larger operations by building them up from smaller ones.

[17:44] <jnthn> dispatch is built up from find_method and invoke.

[17:44] <ruoso> but can't it be installed in the same level?

[17:44] <jnthn> No.

[17:45] <ruoso> because of re-entrancy/

[17:45] <ruoso> ?

[17:45] <ruoso> because I mean... find_methods can be something not really low-level

[17:45] <ruoso> like... it might require traversing a WSDL

[17:45] <ruoso> (considering a SOAP Object System)

[17:46] <jnthn> Sure, and we can re-enter, but it's costly.

[17:46] <jnthn> A dispatch v-table method is *doable*.

[17:46] <jnthn> But it's not making good use of Parrot's architecture.

[17:46] <pmichaud> ...but it doesn't sound very perlish to me.

[17:47] <ruoso> the vtable must have the same entries for every PMC? 

[17:47] *** eternaleye_ left
[17:47] <jnthn> The vtable is per-class.

[17:47] <jnthn> Per type of PMC

[17:48] <ruoso> Ok...

[17:48] <jnthn> Depends if you're using PMC in that sentence to mean pMC instance or not.

[17:48] <jnthn> But basically it boils down to

[17:49] <jnthn> If you want to make a call in a v-table method, you have to then do it in another run-loop.

[17:49] <jnthn> That is, make a call back to high-level stuff.

[17:49] <jnthn> And that's expensive.

[17:49] <jnthn> We'd like to be able to make the common case - $object.method - fast.

[17:50] <jnthn> If we have to keep ^dispatch, then as you note, we can probably optimize it away in a lot of cases.

[17:50] <ruoso> right... can $object.method behavior be dependent on the pmc type of $object?

[17:50] <jnthn> Yes.

[17:50] <pmichaud> welll.....

[17:50] <ruoso> so the question is solved

[17:50] <pmichaud> I'm not so sure I agree with jnthn's answer

[17:51] <jnthn> OK, it depends what you mean by "type of $object"

[17:51] <ruoso> which answer?

[17:51] <jnthn> If you mean the type of the PMC, then yes, it can be.

[17:51] <ruoso> "PMC Type" of $object

[17:51] <pmichaud> iiuc,   $object.method at parrot's normal level actually translates into two operations

[17:51] <jnthn> In that case, yes, find_method can be implemented per PMC.

[17:51] <pmichaud> find_method and invoke

[17:51] <jnthn> Right. That's what I've been saying, essentially.

[17:51] <ruoso> ok... that was not what I asked ;)

[17:52] <pmichaud> find method can be dependent on the type of the pmc.... invoke is less so.

[17:52] <jnthn> So in Perl 6 terms, that's a bit like ^can and postcircumfix:{ }

[17:52] <pmichaud> I think you mean postcircumfix:<( )>

[17:52] <jnthn> Huh?

[17:52] <jnthn> Oh, angles. :-)

[17:52] <pmichaud> invoke is postcircumfix-parens, not postcircumfix-braces

[17:52] <jnthn> Oh!

[17:52] <jnthn> Yes.

[17:52] <jnthn> Sorry.

[17:53] <jnthn> what pm said :-)

[17:53] <ruoso> but....

[17:53] <ruoso> find_method, invoke

[17:53] <ruoso> happens independent of the PMC type

[17:53] <pmichaud> the fact that   obj.'method'(...)   translates to find_method and invoke is independent of the PMC type, yes.

[17:53] <ruoso> no matter how each of them are implemented

[17:54] <pmichaud> what find_method returns is polymorphic on the PMC

[17:54] <pmichaud> and what invoke does is polymorphic on the PMC

[17:54] <pmichaud> (in the case of invoke, it's based on the PMC returned by find_method)

[17:54] <jnthn> Note that what invoke does is polymorphic on _the PMC returned by find_method_.

[17:54] <ruoso> right...

[17:54] <pmichaud> so,   obj.'method'(...) becomes essentially:

[17:54] <pmichaud>     $P1 = find_method obj, 'method'

[17:55] <pmichaud>     $P1(obj, ...)

[17:55] <ruoso> pmichaud, you use obj.'method', but I assume obj.method (without the quotes) is the same

[17:55] <pmichaud> ruoso: in PIR the quotes are required around a method name.

[17:55] <ruoso> ah... ok

[17:56] <pmichaud> (that's relatively recent)

[17:56] <ruoso> how hard would it be to pessimize on unknown PMC types?

[17:56] <pmichaud> what's an "unknown PMC type", though?

[17:56] <[particle]> otherwise it looks for a named register (.pmc local method) and calls get_string on that, and tries to invoke that

[17:57] <ruoso> not in the parrot core

[17:57] <pmichaud> at runtime the PMC types are known.

[17:57] <pmichaud> at compile-time, all PMC types look the same.

[17:57] <pmichaud> i.e., registers aren't "typed"

[17:57] <[particle]> ruoso: all pmcs have an invoke vtable, so any pmc can be invoked.

[17:57] <ruoso> right... let me rephrase

[17:58] <[particle]> if the pmc doesn't implement invoke vtable, it inherits one

[17:58] <[particle]> it may inherit from Null PMC, which throws an exception

[17:58] <pmichaud> (actually I think it inherits from 'default' PMC)

[17:58] <jnthn> Or the default pMC, which throws a different exception.

[17:58] <[particle]> ah, right, default.

[17:59] <[particle]> so you can catch that exception, and realize it's not Invokable

[17:59] <ruoso> I assume every PMC needs to implement find_method as well

[18:00] <pmichaud> it's inherited from the default if not implemented.

[18:00] <jnthn> No, but there is a default one that is inherited.

[18:00] <ruoso> yes... that's what I mean...

[18:00] <[particle]> there are 140+ vtable entries, every pmc has an entry of each

[18:00] <pmichaud> every PMC has a vtable entry, yes.

[18:00] <pmichaud> every PMC has a vtable entry for find_method, yes.

[18:00] <ruoso> so the vtable is static

[18:00] <ruoso> that's a better way of putting that question...

[18:01] <ruoso> the vtable access is static, that is

[18:01] <[particle]> the vtable is the api.

[18:01] <TimToady> the RI?

[18:01] <jnthn> Right. The vtable is a set of operations that something might know how to do.

[18:01] <ruoso> kinda... but SMOP RI has only one entry... (besides the gc stuff)

[18:01] <jnthn> (Or might not know how to do, in which case you'll get an exception.)

[18:02] <ruoso> jnthn, so it wouldn't be so hard to pessimize with a TryCallingDispatchInstead....

[18:02] <ruoso> *TryCallingDispatchInsteadException....

[18:03] <TimToady> an I'm-Really-Prototype-Based exception :)

[18:03] <ruoso> jnthn, but then I guess you can get the HOW without having to call find_method, right?

[18:04] <jnthn> ruoso: I don't quite see what your suggesting...

[18:04] *** rafl_ joined
[18:04] <ruoso> if that HOW can't implement .^can

[18:04] <ruoso> it will throw an exception in find_method

[18:04] <ruoso> TryCallingDispatchInsteadException ;)

[18:04] <jnthn> Ah

[18:05] <ruoso> does it fit?

[18:05] * jnthn thinking

[18:05] <jnthn> Possibly.

[18:05] <pmichaud> it still bugs me that all of our method dispatch is having to go through the HOW

[18:05] <pmichaud> that's "overhead" to Parrot.

[18:05] <TimToady> the I-can't-can exception :)

[18:05] <[particle]> yep, can't use parrot's can

[18:05] <pmichaud> I should say "that's additional overhead" to Parrot.

[18:05] <jnthn> pmichaud: Aye, thus this discussion.

[18:06] <pmichaud> okay.

[18:06] <pmichaud> jnthn's the lead for the Parrot side of this discussion :-)

[18:06] <jnthn> Gah! Responsibility?!

[18:06] <jnthn> ;-)

[18:06] <ruoso> pmichaud, not all method dispatch needs to go through the HOW

[18:06] * TimToady cheers loudly for both teams!!!

[18:06] <ruoso> if you know the low-level for every involved

[18:06] <ruoso> you can cheat

[18:07] * [particle] wonders who the referee is

[18:07] <[particle]> ...and boos him loudly

[18:07] <moritz_> ceiling cat ;-)

[18:07] <pmichaud> at compile-time I don't think we know the low-level for everything involved.

[18:07] <pmichaud> perhaps we can do that... but it seems 'iffy'

[18:07] <ruoso> that's what JIT is for, isnt' it?

[18:07] <jnthn> sub foo($x) { $x.bar(); } # we don't know about $x

[18:07] <PerlJam> TimToady: just like IBM backed both ASCII and EBCDIC at one point?

[18:07] <[particle]> iffy is taken, you need a new term :)

[18:07] * TimToady is fortunately to have gathered players who need cheering more than they need to have fouls called on them.

[18:08] <TimToady> s/ly//

[18:08] <pmichaud> as far as "that's what JIT is for..."  I'm not exactly sure what you're referring to there.

[18:09] <ruoso> pmichaud, check if $x is P6Object, if its how is ClassHOW, then call this optimized version

[18:09] <ruoso> (actually, you don't even need JIT to do that)

[18:09] <pmichaud> that's still "overhead"

[18:09] <TimToady> more like trace optimizatoin

[18:09] <pmichaud> ideally we'd like to just generate    x.'method'(...)    and not have to do the checks.

[18:09] <ruoso> yeah... I'm not really aware of most of those techiniques... but nothingmuch convinced me that some people know how to make it be fast ;)

[18:10] <pmichaud> if we have to do the checks, then it becomes    '!dispatch'(x, 'method', ...)      and we get the overhead

[18:10] *** Kisu left
[18:10] <[particle]> unless there's a super-lightweight check, like a 'nativeobject' flagbit

[18:11] <ruoso> [particle], that's what I'm talkign about... that's what I mean for "known pmc types"

[18:11] <pmichaud> I still don't understand 'known pmc types'.  at compile-time, we don't know the type.

[18:11] <pmichaud> at runtime, we know all of the types.

[18:12] <[particle]> 'known' as in 'i know how to dispatch this, no need to check'

[18:12] *** M_o_C joined
[18:12] <ruoso> by known I mean the ones you can assume the internal low-level layout

[18:12] <ruoso> pmichaud, but I think we lost a point here...

[18:13] <pmichaud> I already know the low-level layout of a PMC.  That's what a PMC defines.

[18:13] <TimToady> checking a bit sounds wrong

[18:13] <[particle]> yeah, to me too, it's just an example

[18:13] <ruoso> pmichaud, is the ICantCanException still overhead?

[18:13] <TimToady> any VM is going to have native thingies, and other things that are proxied through the native thingies

[18:13] *** Woody4286 left
[18:13] <pmichaud> ruoso: depends on what you want to be doing the 'canning' ?

[18:13] <ruoso> TimToady, er... SMOP supports completely unknown things...

[18:14] *** Woody4286 joined
[18:14] <[particle]> smop is a collection of vm's

[18:14] <[particle]> :)

[18:14] <moritz_> in 2009 you write meta-VMs

[18:14] *** xinming_ is now known as xinming

[18:14] <pmichaud> in the phrase ICantCanException, what is the "I" ?

[18:14] <ruoso> pmichaud, the PMC

[18:14] *** rafl_ is now known as rafl

[18:15] <pmichaud> you're asking if a PMC can throw an exception for methods it doesn't understand?

[18:15] <ruoso> pmichaud, the point here is making $object.^can optional

[18:15] <jnthn> pmichaud: This comes down to, ruoso thinks that ^can should be optional.

[18:15] <ruoso> so foreign implementations can go straight for .^dispatch

[18:15] <ruoso> so, as parrot always do a two-step invocation

[18:15] <pmichaud> okay, I'm missing a point then.

[18:16] <ruoso> I was considering that if find_method raised an exception for the cases where .^can is not implemented

[18:16] <ruoso> it could use a different invocation mechanism

[18:16] <jnthn> pmichaud: I think that I'd rather do away with ^dispatch, and ^can in the event that you have a metaclass that doesn't know without trying what methods it can dispatch will hand back something that you can then invoke, and it will then fail when you try to invoke it.

[18:17] <pmichaud> jnthn: what are you envisioning as the invocation sequence for   $x.bar()  ?

[18:17] <pmichaud> i.e., the PIR code generated?

[18:17] <jnthn> $P0 = find_lex '$x'

[18:17] <jnthn> $P0.bar()

[18:17] <pmichaud> okay, that's what I want also.

[18:17] <jnthn> pmichaud: And we'd not use Parrot's Object PMC, but our own that does the Right Thing in the find_method vtable.

[18:17] <pmichaud> so where does ^can fit into this?

[18:17] * ruoso confused... 

[18:18] <jnthn> pmichaud: ^can maps down more to find_method than Parrot's idea of can.

[18:18] <TimToady> how does nextsame work?

[18:18] <pmichaud> jnthn: no problem, I got that.

[18:18] <pmichaud> but I don't see ^can   in the   $P0.bar()  sequence.

[18:18] *** eternaleye joined
[18:18] <jnthn> pmichaud: find_method *is* our ^can

[18:19] <pmichaud> okay.  thinking.

[18:19] <jnthn> (And anything that isn't based on our default - optimized - P6Opaque will have a find_method that actually calls the metaclass' can)

[18:19] <ruoso> jnthn, not only P6Opaque, but the HOW also

[18:19] <pmichaud> actually, anything that isn't based on our P6Opaque would end up doing Parrot's normal find_method semantics, yes?

[18:19] <jnthn> pmichaud: Yes.

[18:20] <jnthn> pmichaud: Apart from in Perl 6 you might have written a knowhow

[18:20] <jnthn> And want to call its ^can

[18:20] <pmichaud> jnthn: so then our P6Opaque's find_method would do any needed HOW checking and pessimizing?

[18:20] <ruoso> exactly... you have to look both at the representation *and* the HOW 

[18:21] <jnthn> pmichaud: I was proposing we have a P6Opaque PMC that doesn't need to pessimize at all, and another one that is the basis for the other representations.

[18:21] <pmichaud> jnthn: I don't understand "other representations"

[18:21] <ruoso> jnthn, that doesn't fit... you need to pessimize on the HOW

[18:21] <ruoso> jnthn, you can use different metaclasses with the same representation

[18:21] <jnthn> ruoso: Instances of an object can be used to find a HOW.

[18:21] <jnthn> Right?

[18:22] <ruoso> I didn't see what you mean

[18:22] <jnthn> So find_method for anything other than P6Opaque would look up the HOW, then find and call ^can

[18:22] <pmichaud> jnthn: what else is there besides P6Opaque, though?

[18:22] <pmichaud> (more)

[18:22] <pmichaud> because to me, "anything other than P6Opaque"  includes Parrot objects

[18:22] <ruoso> pmichaud, in theory anything the user wants

[18:22] <pmichaud> and those Parrot objects already have a find_method

[18:23] <pmichaud> that doesn't look up the HOW

[18:23] <jnthn> pmichaud: Which is completely fine.

[18:23] <jnthn> pmichaud: I'm talking about the third case

[18:23] <ruoso> jnthn, I didn't see what you mean... P6Opaque also needs to look up the HOW... 

[18:23] <pmichaud> jnthn: I don't understand the third case.

[18:24] <jnthn> ruoso: Ah, because you could have a different HOW also using P6Opaque?

[18:24] <ruoso> yes

[18:24] <jnthn> Ah.

[18:24] <pmichaud> jnthn: I see the case where we have things that are P6Opaque, and we have things that aren't P6Opaque (i.e., Parrot objects).  What's the third case?

[18:24] <ruoso> P6Opaque using ClassHOW

[18:24] <ruoso> vs P6Opaque using SomeOtherHOW

[18:24] *** muideen joined
[18:24] <jnthn> pmichaud: When you have written a knowhow specifying a ^can yourself.

[18:25] <pmichaud> I don't have a problem with that.... SomeOtherHOW can override find_method also.

[18:25] <ruoso> er...

[18:25] <ruoso> SomeOtherHOW is not the one receiving the find_method call

[18:25] <ruoso> is it?

[18:25] <jnthn> pmichaud: Yeah, it's just that we're confusing representation and HOW a bit.

[18:25] <ruoso> P6Opaque => REPR

[18:25] <ruoso> ClassHOW => HOW

[18:25] <ruoso> nativeint => REPR

[18:26] <ruoso> p5blessedhash => REPR

[18:26] <ruoso> RoleHOW => HOW

[18:26] <ruoso> you can interchange them at will

[18:26] <pmichaud> I'll rephrase.

[18:27] <pmichaud> I don't have a problem with that -- find_method in P6Opaque can check the HOW easily enough

[18:27] <ruoso> right... and that's it

[18:27] <pmichaud> there's lot of cheating available there.

[18:27] <jnthn> Right.

[18:27] <ruoso> if you have P6Opaque with ClassHOW you can cheat as long as you want

[18:27] <lichtkind> jnthn: hello

[18:27] *** muideen is now known as goksie

[18:27] *** goksie is now known as muideen

[18:27] <jnthn> lichtkind: hi!

[18:28] *** muideen is now known as goksie

[18:28] * TimToady lazily appreciates that you guys are doing the Hard Work

[18:28] <jnthn> But our ability to do that cheat all depends on us being able to emit $P0.'bar'() where $P0 contains the object.

[18:28] <pmichaud> jnthn: and yes, your idea of returning an invokable PMC that then calls the correct dispatcher (for non-standard HOWs) sounds fine to me.

[18:29] <jnthn> Oh hey! We could return a curried invocation of dispatch...

[18:29] <pmichaud> it does make me wish that the name by which a Sub PMC was invoked was available to the Sub itself.

[18:29] <pmichaud> I've often wanted that in Parrot and can't find a way to do it.

[18:30] <jnthn> pmichaud: It's not available because of the 2-step find_method/invoke that we're talking about here. :-)

[18:30] <TimToady> ln -s sendmail mqueue

[18:30] <ruoso> so... we're all happy with optional .^can? 

[18:30] <jnthn> I guess we can deal with it.

[18:31] <pmichaud> ruoso: I'm happy if jonathan's happy, and if we're aiming again at the $P0.'bar'(...) sort of dispatch.

[18:31] <ruoso> cool...

[18:31] * ruoso brb &

[18:31] <pmichaud> I have to run to the post office (went by earlier... line was too long)

[18:31] <pmichaud> so, bbiab

[18:31] <TimToady> thanks everyone

[18:31] <jnthn> ruoso: So long as it's OK that Parrot does the equivalent of trying .^can first, rather than promsing a $x.bar() actually really calls .^dispatch.

[18:32] <jnthn> Which I think we are agreeing that it can.

[18:32] <jnthn> Because we'll fall back to .^dispatch in the cases that it can't.

[18:32] *** riffraff left
[18:33] <jnthn> And I might find we can promise something stronger than that, even.

[18:33] <jnthn> Anyway, me & too - need dinner

[18:35] *** NordQ left
[18:39] *** schmalbe joined
[18:41] *** protorom joined
[18:42] *** eternaleye left
[19:02] *** FurnaceBoy|afk is now known as FurnaceBoy

[19:10] <szabgab> I'd appreciate your comments on the code and the docs of Inline::Rakudo 

[19:10] <szabgab>  http://github.com/szabgab/perl6-in-perl5/tree/master

[19:11] *** pmurias left
[19:11] <szabgab> and if anyone know why o I need to chdir that would be great

[19:12] *** Schnueff joined
[19:20] *** rindolf joined
[19:23] *** goksie left
[19:25] <mberends> szabgab: I think this is one of those inventions whose time has not yet come. You are probably pushing for this kind of functionality for Padre-related reasons, which are quite sophisticated. I think the majority of developers will only start to appreciate this facility when Rakudo nears completion, because then the demand for 5 <-> 6 integration will increase. For myself, pure Perl 6 is currently an adequate playground to explore.

[19:26] *** disismt left
[19:27] *** disismt joined
[19:34] *** protorom left
[19:37] *** kidd joined
[19:40] <mberends> szabgab: does interop in the reverse direction already exist, or is that coming next? I have no idea about the chdir puzzle btw, sorry.

[19:41] <szabgab> do you mean embedding perl5 in perl 6 ?

[19:41] <szabgab> I have no idea about that

[19:41] <mberends> yes. Pugs did a bit of that for regexes, afair.

[19:42] <szabgab> no, I don't understand that kind of C level stuff

[19:44] *** [particle] left
[19:45] <mberends> too bad. the demand for both 5->6 and 6->5 will get bigger as people start porting their existing code to Rakudo, which will probably start happening in late 2009 when a 'Beta' is officially completed.

[19:47] <mberends> did you write that you were resuming Padre work without the pressure of a grant?

[19:48] <szabgab> oh I was working on Padre anyway

[19:48] <szabgab> just not on this part

[19:48] <szabgab> but now that I have this started I'll where does it lead me

[19:51] *** netsquire joined
[19:51] <mberends> cool. it will lead to the most satisfying result.

[19:52] <mberends> looking forward to meeting you at NPW next month

[19:56] * jnthn back from dinner

[19:58] <japhb> jnthn: two part question: a) any movement on the 'use Foo:from<parrot>;' front yet, and b) do you think it would be difficult for someone else to work on?

[19:58] <japhb> I'm thinking of trying my hand at it, but I don't have a huge amount of time to spare.  :-(

[19:59] * jnthn glances around for pmichaud

[19:59] <jnthn> japhb: On my part, no movement since you last asked, and I didn't see any other commits related to that.

[20:00] <jnthn> Really I'm blocking more on pmichaud's input on how he wants that to look.

[20:00] <jnthn> I'm happy to write the code if I know that.

[20:00] <jnthn> (To be fair, I haven't exactly asked for said input. But I'll try and pursue it more actively now.)

[20:01] <japhb> What is there to decide?  (That's an honest question -- I mean, is it because there are a couple possible implementation paths?)

[20:02] *** M_o_C left
[20:02] <japhb> jnthn: much appreciated re: active pursuit.  The official OpenGL bindings for Perl 5 are currently quite broken, and I can't get my fix.  ;-)

[20:02] <japhb> Besides, no time like the present to switch to Perl 6 development for new gfx code.

[20:03] <japhb> I'm taking the death of the P5 bindings as a sign.

[20:03] <japhb> ;-)

[20:03] <jnthn> I just am aware that pm has thought it through somewhat, or maybe quite a lot, and I really haven't.

[20:04] <jnthn> I think that it may be a case of trying to do something at a PCT level.

[20:04] <jnthn> Rather than just some Rakudo-specific thing.

[20:05] <japhb> nodnod

[20:05] <szabgab> mberends, me too it will be cool in Oslo

[20:07] <jnthn> Oslo will be The Awesome. :-)

[20:31] *** [particle] joined
[20:31] *** ujwalic joined
[20:33] <ruoso> jnthn, yes... it is ok to try .^can first... 

[20:35] <Diederich> was there ever any consensus about what the CPAN for Perl6 would look like?

[20:35] <ruoso> Diederich, not really... there are some sketches in the spec

[20:35] <Diederich> there was some talk about it on Perlbuzz a while back

[20:36] <ruoso> one thing we do know is:

[20:36] <Diederich> I think there should be something, no matter how primitive,

[20:36] <Diederich> as the canonical Perl 6 module repo

[20:36] <ruoso> we have three different issues

[20:36] <ruoso> 1) source file format

[20:36] <Diederich> it can just be a github thing

[20:36] <ruoso> 2) installation process

[20:36] <ruoso> 3) distribution software

[20:36] <Diederich> those need to be solved,

[20:36] <Diederich> but having an 'official' place for the modules to exist is a lot simpler than that

[20:36] <Diederich> (tied together to be sure..)

[20:37] <Diederich> but some place should be selected far sooner than later, even if it changes later

[20:37] <Diederich> if such a place existed, the chances of me working on some P5->P6 modules right now would be higher

[20:37] <ruoso> Diederich, that is the distribution software... there's work by markov about it

[20:37] <Diederich> and I think that's true of everyone

[20:38] <Diederich> s/everyone/many people/

[20:38] <ruoso> www.cpan6.org

[20:38] <mberends> Diederich: have you looked at pugs/misc/sixpan ?

[20:38] <Diederich> #doesn't want to get too far ahead of things

[20:38] <Diederich> I have looked at pugs...

[20:38] <Diederich> not that URL

[20:38] <Diederich> The CPAN6 network

[20:38] <Diederich>     * can be used to collect any kind of data: software, publications, photos, ...anything into archives; 

[20:38] <Diederich> cool...got it in one, Mr. Garabaldi.

[20:38] <alester> Diederich: There will be no consensus.

[20:39] <Diederich> there may be

[20:39] <alester> It will be created by the people who make it happen first.

[20:39] <Diederich> there may be after it's already there

[20:39] <ruoso> specially because the network is *a network*

[20:39] <Diederich> see CPAN...

[20:39] <ruoso> it depends on people getting along

[20:39] <Diederich> that's an amazing thing...that could happen again

[20:40] <Diederich> the current CPAN, in my opinion, is the biggest reason that Perl5 is still relevant

[20:41] <Diederich> Perl6 the language will be awesome by itself...and highly relevant

[20:41] <alester> We all agree that CPAN is good.

[20:41] <Diederich> Perl6 + CPAN6 (or whatever it is) will be way over the top

[20:41] <alester> We all agree that Perl 6 will need a way to distribute code.

[20:41] <alester> There is nothing else that can be said.

[20:41] <alester> There is no Perl 6 toolchain.

[20:42] <ruoso> alester, I consider even that there shouldn't be *a* Perl 6 toolchain

[20:42] <alester> ruoso:  THere you go.

[20:42] <Diederich> yeah, with multiple implementation, that gets tricky

[20:42] <ruoso> multiple implementations

[20:42] <alester> So, again: There will be no consensus.

[20:42] <ruoso> multiple architectures

[20:42] <alester> There will be no advance planning.

[20:43] <alester> People will do what works for them and will accrete momentum.

[20:43] <Diederich> hm..that's kind of dour

[20:43] <ruoso> that's why, I insist, the only thing we know so far...

[20:43] <alester> Dour?  How?

[20:43] <ruoso> is that the three problems are completely separated

[20:43] <Diederich> there certainly will be advanced planning!

[20:43] <ruoso> 1) source file format

[20:43] <Diederich> perhaps most of it will be wrong

[20:43] <ruoso> 2) installation process

[20:43] <alester> Certainly?

[20:43] <ruoso> 3) distribution software

[20:43] <alester> Who's doing the planning?

[20:43] <Diederich> well, in a very very limited way, I guess I am

[20:43] <ruoso> alester, actually there is some planning...

[20:43] <ruoso> Ssomething

[20:43] <mberends> the bazaar will beat the cathedral, in the words of Eric Raymond

[20:43] <Diederich> it looks like [email@hidden.address] is doing some planning too

[20:44] <ruoso> there's a DRAFT spec 

[20:44] <ruoso> I think one thing needs spec

[20:44] <ruoso> in the "cathedral" sense

[20:44] <ruoso> which is the "source file format"

[20:44] <alester> So much "It needs this, it needs that"

[20:44] <alester> and yet, precious little JFDI.

[20:44] <Diederich> I agree that it'll be impossible to predict what the many 'it's' will look like in a few years

[20:45] <ruoso> alester, sure sure... but we're still quite far from facing that problem...

[20:45] <ruoso> we need Perl 6 out first

[20:45] <alester> Which problem?

[20:45] <ruoso> then we bother on how to distribute it

[20:45] <alester> ruoso: I suspect that someone will have the CPAN part worked out well before Perl 6 is "out", whatever that means.

[20:45] <Diederich> well, I'm going to mail the cpan6 person and talk to him about what's on his mind

[20:45] <Diederich> and maybe help over there

[20:46] <Diederich> which leads to some small 'JFDI' I guess

[20:46] <alester> "The" CPAN6 person?  There's not a single cpan6 person.

[20:46] <ruoso> alester, currently, mostly there is

[20:46] <Diederich> I'm looking at the web page

[20:46] <ruoso> markov is mostly behind cpan6

[20:46] <alester> "the" web page?

[20:46] <Diederich> http://www.cpan6.org/

[20:46] <Diederich> that was mentioned earlier

[20:46] <Diederich> I'm sure there are more than that around

[20:46] <Diederich> it's a place to start..instead of being negative about it

[20:47] <alester> That's great, but it's irrelevant if nobody uses it.

[20:47] <Diederich> it's unlikely it'll be nobody!

[20:47] <ruoso> alester, I'm not quite getting your point..

[20:47] <alester> I think you might be surpirsed.

[20:47] <Diederich> such carelessly used absolutes are a very good way to discourage many people from doing anything

[20:47] <alester> What aboslutes?

[20:48] <Diederich> thus causing your predictions to be true

[20:48] <alester> I said it's irrelevant if nobody uses it.

[20:48] <mberends> significantly, pugs/misc/sixpan is by a different group of developers

[20:48] <alester> My point is that the first solution to get to relased will win.

[20:48] <mberends> aye

[20:48] <alester> cpan6.org has not been released.

[20:49] <ruoso> are there other initiatives going on? I'm not aware of any...

[20:49] <alester> Doesn't matter if there are or not.

[20:49] *** sri_kraih_ joined
[20:49] <ruoso> so... what's the point?

[20:49] <alester> My point is that just because this placeholder exists doesn't mean that it's what will happen.

[20:50] <ruoso> agreed... but it is *something*

[20:50] <alester> I guess, for some value of "something"

[20:50] <ruoso> and certainly not a "placeholder"

[20:50] <alester> It's a lot of planning and something is started.

[20:50] <alester> See also: Pugs.

[20:50] <Diederich> alester, I have a firm understanding of your perspective, thanks.

[20:50] <ruoso> alester, I really don't understand why you're so angry about it...

[20:50] <alester> I'm not angry at all.

[20:52] <mberends> suggestion: let's develop many pilots and apply natural selection ;)

[20:52] <alester> That's what's going to happen, whether you suggest it or not, mberends ;

[20:52] <alester> People will do what works for them.

[20:54] <ruoso> jnthn, what do you think about making a role hierarchy for the HOW API? to specify the features each one implements?

[20:54] <jnthn> ruoso: I guess that implies RoleHOW has to exist in order to define ClassHOW? (Which is probably fine...)

[20:55] <ruoso> I guess so... specially because the built-in types are roles anyway

[20:55] <ruoso> but which roles does RoleHOW do?

[20:55] <ruoso> ;)

[20:55] <jnthn> Yes, true.

[20:55] <jnthn> No, don't go there. :-P

[20:56] <jnthn> I've got enough issues just trying to extract List and Array out to be pure Perl 6...

[20:56] <alester> If I had any sort of software to release under P6, I'd probably host it on github and make a toolchain of my own until another came along.

[20:57] <ruoso> alester, er... that's what people already do...

[20:57] <alester> what is out there in Perl 6 now?

[20:57] <ruoso> november

[20:57] <jnthn> druid

[20:57] <jnthn> Form

[20:57] <alester> I oughta put up a page of it.

[20:58] *** gdonald joined
[20:58] <jnthn> alester: See also http://www.perl6-projects.org/

[20:58] <ruoso> jnthn, but have you realized that  (1,2,3) is not a List?

[20:58] <jnthn> ruoso: Erm...?

[20:59] <ruoso> it is a capture

[20:59] <jnthn> That's be \(1,2,3) surely?

[20:59] <ruoso> that's a capture enclosed in a scalar

[20:59] <ruoso> I've just realized that, after trying to figure out how to deal with flatten vs unflatten

[20:59] *** awwaiid joined
[20:59] <ruoso> (((1,2,3),2,3),2,3)

[21:00] <jnthn> Is this spec, or the results of your ponderings?

[21:00] <ruoso> results of my ponderings...

[21:00] <jnthn> Ah.

[21:00] <ruoso> which usually are more dangerous than spec ;)

[21:00] <jnthn> That's different.

[21:00] <jnthn> Yeah

[21:00] <jnthn> ;-)

[21:00] <ruoso> anyway... 

[21:00] <jnthn> The thing that makes me suspect otherwise is that

[21:00] <jnthn> my $x = (1,2,3); # $x holds a capture now

[21:00] <jnthn> I think ti's the item context that makes it beomce a capture.

[21:01] <jnthn> That changed recently-ish (before, it became an Array).

[21:01] <alester> anyone got a URL for Form?

[21:02] <ruoso> jnthn, an capture in item context returns itself, unless it contains only one parameter (named or positional)

[21:02] <ruoso> and capture implements both .[] and .{}

[21:02] * ruoso decommute &

[21:02] *** ruoso left
[21:03] *** DemoFreak joined
[21:03] <jnthn> alester: You may also find http://github.com/masak/proto/tree/master interesting.

[21:03] <alester> Interesting how?

[21:03] <alester> What is it

[21:04] <jnthn> See README but basically a lightweight module installer.

[21:04] <jnthn> That knows where to find from github a bunch of Perl 6 related proejcts.

[21:04] <jnthn> http://github.com/masak/proto/blob/e8627fc7952b0faa89c14dfde9c096794da6535b/modules.list actually tells you where Form is too ;-)

[21:05] *** ejs joined
[21:05] <jnthn> (http://github.com/mattw/form/tree/master)

[21:05] *** sri_kraih left
[21:06] <alester> http://rakudo.org/perl-6-projects started

[21:09] *** Whiteknight joined
[21:14] *** gdonald_ joined
[21:16] *** gdonald left
[21:25] *** mj41 left
[21:29] *** gdonald joined
[21:30] *** schmalbe left
[21:30] *** mj41 joined
[21:31] <moritz_> rakudo: Q<< foo < ' > bar >>.say

[21:31] <p6eval> rakudo 1c263b: OUTPUT« foo < ' > bar ␤»

[21:36] *** ejs left
[21:39] *** gdonald_ left
[21:48] *** ujwalic left
[21:50] <moritz_> http://github.com/moritz/json/tree/master very early grammar for JSON

[21:54] *** gdonald left
[21:55] <frioux> moritz_: that's really cool!

[21:55] <moritz_> frioux: thanks

[21:56] <moritz_> it's still a *very* early version

[21:56] <Matt-W> So much exciting stuff going on these days

[22:01] *** skids left
[22:01] *** bacek left
[22:02] *** pmurias_ joined
[22:02] <moritz_> rakudo: rule a { '[' ~ ']' A? }; say '[ ]' ~~ /<a>/

[22:02] <p6eval> rakudo 1c263b: OUTPUT«Unable to parse a, couldn't find final ']'␤current instr.: 'parrot;PGE;Match;FAILGOAL' pc 2927 (compilers/pge/PGE/Regex.pir:456)␤»

[22:03] <moritz_> a bug?

[22:04] * moritz_ wants LTM

[22:04] <jnthn> rakudo: rule a { '[' ~ ']' A? }; say '[]' ~~ /<a>/

[22:04] <p6eval> rakudo 1c263b: OUTPUT«[]␤»

[22:05] <jnthn> rakudo: rule a { '[' ~ ']' [ A? ] }; say '[ ]' ~~ /<a>/

[22:05] <p6eval> rakudo 1c263b: OUTPUT«[ ]␤»

[22:05] *** wknight8111 joined
[22:05] <jnthn> moritz_: Dubious.

[22:05] <moritz_> jnthn: probably up for debate

[22:05] <jnthn> moritz_: It's to do with whether there's a <.ws> see either side of the A?

[22:05] *** Whiteknight left
[22:06] <jnthn> s/'?'/./

[22:06] <moritz_> jnthn: I know

[22:06] *** rindolf left
[22:06] <jnthn> But hard to call, what the answer on that is.

[22:06] <moritz_> the current behaviour makes kind of sense

[22:06] <moritz_> because ~ acts on the next two atoms

[22:06] <jnthn> Right.

[22:06] <moritz_> and if you count implicit <.ws> as atoms, then DWIM is in trouble

[22:07] <jnthn> Aye.

[22:07] <moritz_> so not ticket ;-)

[22:07] <jnthn> Phew! ;-)

[22:08] <moritz_> anyway, the <.ws> thing usually *really* dwims

[22:08] <moritz_> for the JSON grammar I'm writing that's cool

[22:09] *** ejs joined
[22:10] *** pmurias joined
[22:10] *** Schnueff left
[22:10] *** pmurias_ left
[22:10] *** pmurias left
[22:11] *** ejs left
[22:11] <moritz_> and it's so nice that $somebody already wrote tests

[22:15] *** gdonald_ joined
[22:15] *** gdonald_ left
[22:18] *** Diederich left
[22:22] *** hercynium left
[22:26] *** [particle] left
[22:34] <moritz_> all JSON parsing tests pass. Nice.

[22:34] *** wknight8111 left
[22:34] <moritz_> that was... not too hard

[22:35] <moritz_> I'll wait with the action methods und .caps and .chunks are updated in Rakudo...

[22:35] <moritz_> which I plan to do as soon as %($/).pairs stops to stringify its value

[22:39] *** alester left
[22:43] <dalek> rakudo: 7487710 | (Moritz Lenz)++ | t/spectest.data:

[22:43] <dalek> rakudo: Add S05-metasyntax/repeat.t to t/spectest.data

[22:43] <dalek> rakudo: Patch courtesy of Martin Kjeldsen, baest++

[22:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/748771092a53e8910df4c633567c9a57b090a12e

[22:44] *** Diederich joined
[22:47] *** netsquire left
[22:50] *** fridim_ joined
[22:51] *** skids joined
[23:09] *** nihiliad left
[23:11] *** frioux is now known as frioux_Away

[23:13] *** Exodist left
[23:15] <frooh_away> moritz_: what are all the {*}'sin the JSON grammar?

[23:15] *** frooh_away is now known as frioux

[23:15] *** frioux is now known as frooh

[23:20] *** Whiteknight joined
[23:21] <moritz_> frooh: they are hooks for action methods (soon to come)

[23:21] <frooh> ooh

[23:21] <frooh> cool

[23:21] <frooh> so I can make a SAX-like parser with this.

[23:26] *** kidd left
[23:29] *** ludan joined
[23:40] *** hercynium joined
[23:42] <meppl> good nightz

[23:43] *** meppl left
[23:45] *** gdonald joined
[23:47] *** frooh left
[23:47] *** frioux joined
[23:48] *** gdonald left
