[00:00] <jnthn> How's the unicode props stuff going, by the way?

[00:06] *** FurnaceBoy joined
[00:11] *** felipe joined
[00:15] *** Doubi left
[00:31] <pmichaud> ooops, had to run to store.

[00:31] <pmichaud> unicode stuff is going very well, although ICU is a bit frustrating at times (the docs, not the implementation)

[00:39] <pugs_svn> r26141 | hinrik++ | [util/perl6.vim] the slashes in //= are part of an operator, not a pattern

[00:39] <pugs_svn> r26142 | hinrik++ | [util/perl6.vim] timestamp, etc

[00:54] *** frew|wor1 joined
[01:00] *** Whiteknight left
[01:08] *** Doubious left
[01:11] <pugs_svn> r26143 | lwall++ | plant some camelias

[01:19] *** justatheory left
[01:19] <pugs_svn> r26144 | autarch++ | Fix a very tiny typo in Temporal::Datetime.iso8601

[01:19] *** justatheory joined
[01:20] <pugs_svn> r26145 | pmichaud++ | [t/spec]:  More Unicode property tests refactored from properties.t .

[01:23] *** dukeleto left
[01:26] *** justatheory left
[01:37] <pmichaud> The unicode properties tests for S05 include   things like <isInArabic>,  <isInArrows>, etc., for checking if codepoints are members of a specific block.  But Synopsis 5 doesn't mention <isIn...>  -- shall I assume that it's supposed to?

[01:38] <pmichaud> (The "InArabic", "InArrows", etc. categories appear to be a p5-ism.)

[01:40] *** frew|wor1 left
[01:41] *** kst joined
[01:45] *** justatheory joined
[01:46] *** payload left
[01:47] <pugs_svn> r26146 | pmichaud++ | [t/spec]:  Last bit of refactoring for Unicode properties.t .

[01:48] <pugs_svn> r26147 | pmichaud++ | [t/spec]:  Once again, failing to plan is planning to fail (properties-derived.t)

[01:58] <TimToady> pmichaud: I don't think those turned out to be terribly useful

[01:59] <pmichaud> how about  isBidiL, isBidiES, etc?

[02:02] <TimToady> doesn't the Bidi stuff come from the consortium?

[02:02] <pmichaud> they don't appear to be standard property names

[02:02] <pmichaud> the standard names are L, ES, etc.  in the bidi class, if I'm reading this right.

[02:02] <pmichaud> I think adding "Bidi" to the front might be another p5-ism

[02:03] <pmichaud> for example:

[02:03] <pmichaud> 002B;PLUS SIGN;Sm;0;ES;;;;;N;;;;;

[02:03] <pmichaud> the "ES" indicates the bidi class of the plus sign.

[02:04] <TimToady> I don't know if I added that or someone else

[02:04] <pmichaud> well, I just about have them working, so I'll leave them in for now.  If we decide they're not part of the spec, we can remove the tests from the suite.

[02:04] <TimToady> whatever looks like it might be useful...

[02:04] *** brunov is now known as brunoVi

[02:05] <pmichaud> the InArabic, InArrows, etc., tests for block membership contains ~670 tests.

[02:05] <pmichaud> (which Rakudo mostly passes now :-)

[02:10] <pugs_svn> r26148 | pmichaud++ | [t/spec]:  Unfudge Bidi* tests in properties-script.t .

[02:10] *** dukeleto joined
[02:11] *** brunoVi is now known as brunov

[02:15] *** payload joined
[02:30] *** cdarroch left
[02:38] <cspencer> rakudo: say 1..5.int

[02:38] <p6eval> rakudo 0a9dd6: OUTPUT«12345␤»

[02:38] <cspencer> rakudo: say (1..5).int

[02:38] <p6eval> rakudo 0a9dd6: OUTPUT«5␤»

[02:44] *** payload left
[02:58] <dalek> rakudo: 85ab143 | pmichaud++ | src/ops/perl6.ops:

[02:58] <dalek> rakudo: Refactor is_uprop opcode a bit.

[02:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/85ab143d56697a03e65b19b17c03b9c792391d85

[02:58] <dalek> rakudo: a2bb078 | pmichaud++ | :

[02:58] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[02:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a2bb078c088190f1bec84d34cc9f072e18b61ce0

[02:58] <dalek> rakudo: f545fee | pmichaud++ | src/ops/perl6.ops:

[02:58] <dalek> rakudo: Add "Bidi" and "In" support to unicode character properties.

[02:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f545feea2941a9fd106e5900679407aa5a7da2c6

[02:59] *** sitaram joined
[03:09] *** sri_kraih joined
[03:14] *** FurnaceBoy left
[03:20] <pugs_svn> r26149 | pmichaud++ | [t/spec]: Remove properties.t (it's been refactored into four separate files).

[03:21] *** dukeleto left
[03:23] *** justatheory left
[03:27] *** Kisu left
[03:38] *** dukeleto joined
[03:40] <dalek> rakudo: 4ae560c | pmichaud++ | t/spectest.data:

[03:40] <dalek> rakudo: Update spectest.data with properties.t tests.

[03:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4ae560c5634444a4956d9c8a09c99614c5fb3d98

[03:43] *** hercynium left
[03:46] *** Kisu joined
[03:48] *** dukeleto left
[03:52] *** [particle] left
[03:53] *** [particle] joined
[04:11] *** skids left
[04:16] <cspencer> pmichaud: ping

[04:17] *** cspencer left
[04:28] *** sephee left
[04:29] *** dukeleto joined
[04:31] *** Tene_ joined
[04:34] *** dukeleto left
[04:35] *** sephee joined
[04:35] *** dukeleto joined
[04:38] *** nekobaka joined
[04:39] *** frew|wor1 joined
[04:41] *** frew|wor1 left
[04:42] *** kst left
[04:42] *** kst joined
[04:45] *** Tene left
[04:46] *** araujo left
[04:49] *** araujo joined
[04:52] *** dukeleto left
[05:22] *** [particle]1 joined
[05:27] *** [particle]1 left
[05:28] *** orafu joined
[05:36] *** [particle]1 joined
[05:40] *** [particle] left
[05:40] *** dukeleto joined
[05:46] *** brunov left
[06:03] *** agentzh left
[06:06] *** agentzh joined
[06:11] *** TimToady left
[06:12] *** diakopter left
[06:14] <moritz_> good morning

[06:16] <pmichaud> good morning

[06:16] * pmichaud drum rolls....

[06:16] <moritz_> I've seen you've been busy

[06:17] * pmichaud drum rolls a bit more...

[06:17] <pmichaud> (waiting for dalek)

[06:18] <dalek> rakudo: e05aff7 | pmichaud++ | docs/spectest-progress.csv:

[06:18] <dalek> rakudo: spectest-progress.csv update: 354 files, 10224 passing, 0 failing

[06:18] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e05aff7d21562af848a55c50f3fae87ee0f298e6

[06:18] <moritz_> woot!

[06:18] <moritz_> I CAN HAZ 10k!

[06:18] <eiro> hello world 

[06:19] <moritz_> pmichaud++

[06:21] *** justatheory joined
[06:23] <pmichaud> rakudo:  say 10224/15627

[06:23] <p6eval> rakudo 4ae560: OUTPUT«0.654252255711269␤»

[06:23] <pmichaud> 65%

[06:24] <moritz_> rakudo: printf '%0.2f', 10224/15627

[06:24] <p6eval> rakudo 4ae560: OUTPUT«0.65»

[06:27] *** justatheory left
[06:30] <pmichaud> okay, time for bed here.  More writing tomorrow.

[06:30] <moritz_> good night

[06:52] <pugs_svn> r26150 | moritz++ | [t/spec] unfudge tests for typed arrays

[07:04] <pugs_svn> r26151 | moritz++ | [t/spec] unfudge type-based.t

[07:17] *** masak joined
[07:18] <masak> hello #perl6, you wonderful channel you.

[07:18] <lambdabot> masak: You have 2 new messages. '/msg lambdabot @messages' to read them.

[07:18] <masak> @massage

[07:18] <lambdabot> jnthn said 7h 30m 30s ago: maybe if you have time take a look at http://rt.perl.org/rt3/Ticket/Display.html?id=62968 and see if you think we're looking good on that one now.

[07:18] <lambdabot> jnthn said 7h 30m 4s ago: we may want some tests for it if so; scribble on the ticket if there's still issues there :-)

[07:18] <masak> so, 10k eh?

[07:18] <masak> \o/

[07:22] *** Doubi joined
[07:25] *** iblechbot joined
[07:29] <moritz_> rakudo: class O { method oO { } }; try { given O.new { .oO( ... ) } }; say "alive"

[07:29] <p6eval> rakudo e05aff: OUTPUT«alive␤»

[07:29] <moritz_> YaY, .oO( ... ) is valid Perl 6 ;-)

[07:30] <eiro> lol! right!

[07:31] <moritz_> afk

[07:32] *** kst left
[07:32] *** kst joined
[07:33] *** kidd` joined
[07:38] *** ejs joined
[07:48] <Matt-W> Morning

[07:48] *** ejs left
[07:49] * masak tips hat

[07:49] <Matt-W> masak: I did some Form last night!

[07:49] <masak> Matt-W: I saw, in the backlog!

[07:49] <masak> kudos.

[07:49] <Matt-W> Unfortunately after I did some useful things I got sidetracked trying to figure out an algorithm for full justification

[07:49] <Matt-W> Which was probably not a useful use of my time

[07:50] <Matt-W> because it seems ridiculously complicated, and it causes a null pmc access

[07:50] <masak> Matt-W: what's the part of full justification that you considered?

[07:50] <Matt-W> I suppose it might at least help me find a rakudo bug

[07:51] *** meppl joined
[07:54] <masak> Matt-W: seems to me full justification boils down to line breaking + inserting extra spaces as evenly/invisibly as possible.

[07:59] *** DemoFreak joined
[08:02] *** szabgab left
[08:04] <moritz_> rakudo: class A { has Int @.a is rw }; my $x=A.new; $x.a = (2, 3, 4); say $x.a.perl

[08:04] <p6eval> rakudo e05aff: OUTPUT«[2, 3, 4]␤»

[08:04] <moritz_> rakudo: class A { has Int @.a is rw }; my $x=A.new; $x.a = (2, 3, 4); $x.a.push: 'foo';  say $x.a.perl

[08:04] <p6eval> rakudo e05aff: OUTPUT«[2, 3, 4, "foo"]␤»

[08:05] <moritz_> masak: care to submit? :-)

[08:05] <masak> bug.

[08:05] * masak submits

[08:05] <moritz_> rakudo: class A { has Int @.a is rw }; my $x=A.new; $x.a = <foo bar> say $x.a.perl

[08:05] <Matt-W> masak: yes, that's basically it

[08:05] <p6eval> rakudo e05aff: OUTPUT«Statement not terminated properly at line 1, near "say $x.a.p"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[08:05] <moritz_> rakudo: class A { has Int @.a is rw }; my $x=A.new; $x.a = <foo bar>; say $x.a.perl

[08:05] <p6eval> rakudo e05aff: OUTPUT«["foo", "bar"]␤»

[08:05] <Matt-W> masak: it's more complicated if you have a proper layout system of course

[08:06] <masak> Matt-W: 'proper layout system'?

[08:06] *** szabgab joined
[08:06] <Matt-W> masak: as in one where you can adjust letter spacing and things

[08:06] <masak> yes. ouch,

[08:06] <moritz_> you mean a rendering engine?

[08:06] <moritz_> like pango?

[08:07] *** agentzh left
[08:11] <sitaram> moritz_: in the @list.sort example within the comments at http://perlgeek.de/blog-en/perl-6/y-combinator-not-needed.writeback, did the spaceship operator disappear due to HTML interpretation at some point?  I see only dollar-hat-b-space-dollar-hat-a.  Normally I wouldn't ask but am trying to learn perl 6, and the syntax is new enough that I want to make sure this isn't some new way of specifying a sort sub

[08:11] <sitaram> (I assume that page is yours; apologies if not)

[08:12] <moritz_> sitaram: it is. Let me take a look...

[08:13] *** alexn_org joined
[08:14] <moritz_> sitaram: yes, it should be $^a <=> $^b

[08:14] <sitaram> thanks :-)

[08:14] <sitaram> little things matter when taking baby steps into a new language, especially after a long gap!

[08:15] <moritz_> apologies for the inconvience

[08:15] <moritz_> I've since then fixed the blog software

[08:15] <sitaram> (and actually, for that specific point you were making, the b should come first

[08:15] <moritz_> (and in the mid term or long run I'll switch over to perlblog.org)

[08:16] <sitaram> moritz_: not a problem at all!  thanks for your help

[08:18] <sitaram> (and I was so caught up in grokking that example I didn't even look one para down, where you already said that the blog software ate the < and > signs (blush!)

[08:18] <moritz_> :-)

[08:19] <moritz_> u haz a spazeship but i eated it

[08:21] *** ejs joined
[08:29] *** ejs left
[08:30] *** ejs joined
[08:34] *** agentzh joined
[08:36] <Matt-W> Wow

[08:36] <Matt-W> 10,000 spectests

[08:36] <Matt-W> everyone++

[08:40] <sitaram> aah -- now I know what that 10k meant...!

[08:40] <sitaram> (still new; too new... sigh!)

[08:41] *** alexn_org left
[08:51] *** payload joined
[09:02] *** szabgab left
[09:04] <moritz_> sitaram: if there are more terms that you don't understand, don't hesitate to ask

[09:04] *** bacek_ left
[09:05] *** szabgab joined
[09:11] <sitaram> will do; thanks!

[09:11] <sitaram> this sounded like something I could guess or would come through eventually :)

[09:12] *** hanekomu joined
[09:26] *** DemoFreak left
[09:32] *** hanekomu left
[09:36] *** riffraff joined
[09:50] <jnthn> morning folks

[09:51] <moritz_> good morning jnthn 

[09:52] <moritz_> jnthn: I found you another bug... types on array attributes don't work ;-)

[09:52] <moritz_> lunch&

[09:54] <jnthn> pmichaud++ # 10,000!!

[09:54] <jnthn> moritz_: Ah, yes...that's not so surprising.

[10:03] *** payload left
[10:05] *** bacek joined
[10:16] *** payload joined
[10:30] *** schinkelm joined
[10:36] *** payload left
[10:45] <pmichaud> It's just 10,000, not 10,000!  (which would be a huge number :-)

[10:46] <jnthn> pmichaud: Did you actually, like, sleep? ;-)

[10:47] <pmichaud> for a couple of yours, yes.

[10:47] <jnthn> :-)

[10:47] <pmichaud> *hours

[10:47] <pmichaud> (obviously didn't sleep much -- can't type again :-)

[10:47] <jnthn> Ah, planned sleep deprevation for beating NPW jet-lag. ;-)

[10:48] <pmichaud> Paula woke up and so I'm now able to make YAPC::NA travel arrangements (because I know her schedule)

[10:52] *** orafu left
[10:53] *** davidad left
[11:00] *** DemoFreak joined
[11:02] *** payload joined
[11:04] *** schinkelm left
[11:11] *** bacek left
[11:13] <jnthn> Hmm. The tests in http://svn.pugscode.org/pugs/t/spec/S06-advanced_subroutine_features/wrap.t seem to think that .wrap gives you back some kind of invokable handle.

[11:13] <jnthn> However, the specs say nothing like that.

[11:14] * jnthn goes with the spec

[11:20] <moritz_> i think there's a different method that does that

[11:20] <moritz_> feel free to correct the tests

[11:23] <jnthn> moritz_: Aye, will do.

[11:25] *** payload left
[11:25] *** payload joined
[11:28] *** kidd` left
[11:46] <masak> rakudo: my @a = 1..4; say @a[1..*].perl

[11:46] <p6eval> rakudo e05aff: OUTPUT«[2, 3, 4, undef]␤»

[11:46] <jnthn> masak: I worked out why we get that wrong this morning.

[11:46] <masak> nice.

[11:46] <jnthn> masak: But it didn't lead me to realizing an obvious fix.

[11:47] <jnthn> Basically though we end up substituting * for the number of arguments.

[11:47] <jnthn> So you're not actually constructing an infinite range, which is what it probably should do.

[11:47] <masak> mm.

[11:47] <jnthn> But instead the finite range 1..@a.elems

[11:47] <masak> * has many meanings in indices.

[11:47] <moritz_> instead of 1..@a.end

[11:47] <jnthn> Which then gives you an off-by-one.

[11:48] <jnthn> Amusingly, 1..^* would probably work. ;-)

[11:48] <masak> aye.

[11:48] <masak> rakudo: my @a = 1..4; say @a[1..^*].perl

[11:48] <p6eval> rakudo e05aff: OUTPUT«[2, 3, 4]␤»

[11:48] <jnthn> Yeah

[11:48] <jnthn> I hadn't tried it, just looked at the code...

[11:48] <moritz_> for *-1 to work you have to pass it @a.elems

[11:48] <moritz_> so you need to special-case 1..*

[11:49] <jnthn> Maybe.

[11:49] <jnthn> But *-1 should by itself construct a block { $_ - 1 } IIUC

[11:49] <jnthn> Whereas 1..* would not?

[11:49] <jnthn> Or does 1..* count in with the operators where * forms a block too?

[11:50] <moritz_> maybe it should construct a block { 1.. $_ } - but then you'd get the offbyone again

[11:50] <jnthn> Ugh. That would can probably go more than one way. :-|

[11:50] <jnthn> moritz_: Well, exactly...

[11:50] <jnthn> moritz_: We're faking constructing that block now.

[11:50] <jnthn> But getting the semantics as if we had.

[11:59] <masak> why faking it?

[12:01] <jnthn> masak: 'cus we aren't doing the general block-building thingy.

[12:01] <masak> ok.

[12:01] <jnthn> rakudo: say (*-1).WHAT

[12:02] <p6eval> rakudo e05aff: OUTPUT«Use of uninitialized value␤Num␤»

[12:02] <jnthn> Output should be Block

[12:07] <masak> * -- the blockless block.

[12:11] *** s1n left
[12:11] *** cls_bsd left
[12:11] *** jnthn joined
[12:11] *** s1n joined
[12:11] *** cls_bsd joined
[12:11] *** Maddingue joined
[12:11] *** buu joined
[12:11] *** ingy joined
[12:11] *** irc.freenode.net sets mode: +o jnthn

[12:20] <dalek> rakudo: 43b9e57 | jnthn++ | src/classes/Routine.pir:

[12:20] <dalek> rakudo: First cut of wrap and unwrap.

[12:20] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/43b9e579520092c5661ff6866cf492bafbff2e55

[12:20] <pmichaud> I didn't implement the closure-semantics of Whatever yet (because they weren't defined at the time).

[12:21] <pmichaud> What Rakudo does now was just a guess in order to get things to work while the spec was being fleshed out :-)

[12:23] <jnthn> pmichaud: Sure, that bit of spec came after the postcircumfix work. :-)

[12:23] <jnthn> pmichaud: Thing is, I ain't completley sure even changing it to be what the spec says will deal with the 1..* issue.

[12:27] <jnthn> pmichaud: BTW, for the 1 + * becomes { 1 + $_ } stuff, any thoughts on how to implement it?

[12:27] <jnthn> I see we can go two ways: multi variants recognizing a Whatever, or compiler transform.

[12:30] *** skids joined
[12:36] *** payload left
[12:38] <pmichaud> I think that TimToady was describing it as multi variants.

[12:38] <pmichaud> I'd have to review the logs... but I'm pretty sure that's what it was.

[12:40] <pmichaud> also, fwiw, in yesterday's design meeting TimToady mentioned that he had been thinking of leave semantics as not being exception-based

[12:40] <pmichaud> I meant to ask at #parrotsketch about subroutine exit triggers but forgot.  :-(

[12:55] *** payload joined
[12:56] <jnthn> If they're a bunch of multi variants, then I guess we want to generate them just as we generate the junctional variants.

[12:57] <pmichaud> makes sense.

[12:58] <jnthn> If I can ever get to the bottom of what I've screwed up in implementing callwith so wrap is actually useful, I might pop those in...

[13:02] *** bacek joined
[13:06] <dalek> rakudo: 508a18c | (Moritz Lenz)++ | t/spectest.data:

[13:06] <dalek> rakudo: fix typo in t/spectest.data, moritz--

[13:06] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/508a18c5f211d20afb0fedcecd6cdaa995c78b94

[13:11] *** Khisanth left
[13:12] <moritz_> since Str.reverse is Str.flip now - shouldn't it be also findex instead of rindex? ;-)

[13:12] <pmichaud> how many people want to find their ex?

[13:12] <moritz_> actually index and rindex look like they could be unified to one function, with a named arg to decide the search direction

[13:13] <moritz_> with :backwards = Bool::False or so

[13:13] <pmichaud> actually, we could make all of the builtins into a single function with a named arg to decide the function.  :-)

[13:13] *** Doubious joined
[13:13] <moritz_> pmichaud: syscall()

[13:13] <pmichaud> I propose that this single function be called ""

[13:14] <masak> convenient.

[13:14] <moritz_> ;-)

[13:14] <masak> then you can call it with just .

[13:14] <pmichaud> and that the first identifier following the "" will be the function identifier

[13:14] *** Tene_ left
[13:15] <moritz_> and if you leave that out, it returns a junction of the results of all builtins ;-)

[13:15] <pmichaud> heh

[13:15] <moritz_> but to get back to serious language design busines, I don't think that index and rindex are sufficiently distinct to warrant a different sub each

[13:16] <moritz_> they might be implemented quite differently, but from a language perspective we shouldn't care

[13:16] <masak> moritz_: I think it's good to have them separate.

[13:16] <moritz_> just my 2¢

[13:16] <moritz_> masak: why?

[13:16] <masak> rindex is a good deal shorter than anything you can do with named args.

[13:17] <masak> it's huffmannized.

[13:17] <moritz_> how often do you use it?

[13:17] <masak> moritz_: perhaps 10% as often as index.

[13:17] <masak> maybe less.

[13:17] <masak> I don't use either much.

[13:17] <masak> Perl 5/6 often has better ways to manip strings.

[13:17] *** cognominal left
[13:17] <moritz_> aye

[13:18] <moritz_> let's see what TimToady thinks when he returns

[13:18] <masak> maybe if you called the named arg :r...

[13:18] <moritz_> that would be fine by me as well

[13:18] <masak> but even then, it feels a bit like premature abstraction to me.

[13:19] <moritz_> and like justified abstraction to me ;-)

[13:19] <masak> $abstraction.is-in( $beholder.eye )

[13:20] <moritz_> ::a ∈ Eye of Beholder

[13:21] <moritz_> remeber, ::-sigiled variables do Abstraction anyway ;-)

[13:21] <masak> perhaps there's a middle ground here. we could add the named arg to index, but keep rindex and add a :forwards = False to it... :P

[13:21] <moritz_> ;-)

[13:21] <pmichaud> afk for a short while

[13:21] <moritz_> $str.rindex($s, :forward) :/

[13:22] <masak> exactly.

[13:24] <moritz_> :forward, :flip, :reverse)

[13:24] <masak> no-one can blame us for not being general enough.

[13:25] <moritz_> hey, what about up, down and the diagonals?

[13:25] <moritz_> we're thinking way too one-dimensional

[13:26] <moritz_> masak: I see that you haven't commented or voted on the gsoc proposals yet...

[13:26] <moritz_> masak: will you change that?

[13:26] <masak> moritz_: how much time do I have left?

[13:26] <masak> I have looked through them, but didn't take the time to vote/comment.

[13:27] <moritz_> masak: if you want to leave the students the chance to react on your feedback, you should do it in the next two days or so

[13:27] <masak> I can do that.

[13:28] <masak> bit busy these days, but two days should be fine.

[13:28] <moritz_> on April 15th everything must be decided

[13:28] <masak> aye.

[13:28] <masak> moritz_++ # for reminding

[13:30] <pugs_svn> r26152 | jnthn++ | Unfudge 5 tests for type checked arrays.

[13:30] <pugs_svn> r26153 | jnthn++ | Review, correct and simplify (as in relying on less unrelated features) some of the tests for wrap.

[13:32] <jnthn> (And just pushed changes to get us passing those wrap.t tests now they're reviewed.)

[13:32] *** payload left
[13:32] *** Doubi left
[13:33] *** orafu joined
[13:33] *** cognominal joined
[13:38] <dalek> rakudo: a36c3b2 | jnthn++ | src/classes/Routine.pir:

[13:38] <dalek> rakudo: Some tweaks to the first cut of wrap; assign could get things confused, plus also need to track relations of Parrot and Rakudo level subs.

[13:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a36c3b2eebc9418c9574ed6c83d2b1766f639b59

[13:38] <dalek> rakudo: 6bcccd6 | jnthn++ | src/builtins/control.pir:

[13:38] <dalek> rakudo: Implement callwith for the wrapped sub case.

[13:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6bcccd60eb53636e068a766c70fdddbc971677b2

[13:38] <dalek> rakudo: 8abc537 | jnthn++ | t/spectest.data:

[13:38] <dalek> rakudo: Add wrap.t to spectest.data.

[13:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8abc5379a6cbd396680cea4b445eed1a79a01b79

[13:38] <dalek> rakudo: 4561d2f | jnthn++ | :

[13:38] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[13:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4561d2f2d0c8295ae92b481bb093bbaddc4ecd69

[13:39] <pugs_svn> r26154 | jnthn++ | [t/spec] Tests for out-of-order unwrapping and making sure re-unwrapping and unwrapping something never wrapped dies.

[13:45] *** Doubious left
[13:45] *** davidad joined
[13:47] *** cognominal left
[13:48] *** cognominal joined
[13:49] *** cognominal left
[13:51] *** Tene joined
[13:51] <PerlJam> good morrow #perl6

[13:52] <moritz_> hi PerlJam 

[13:52] * PerlJam pulls a fresh rakudo

[13:53] <masak> PerlJam: good day, sir.

[13:54] *** alester joined
[14:01] <moritz_> jnthn: t/spec/S09-typed-arrays/arrays.t fails three tests here, which is somewhat my fault because I mis-spelled it in t/spectest.data :)

[14:02] <jnthn> moritz_: I tought it had 3 tests towards the end fudged?

[14:02] <jnthn> I unfudged 5 that were passing...

[14:03] <moritz_>   Failed tests:  33-34, 36

[14:03] <moritz_>   TODO passed:   35, 37

[14:03] <jnthn> odd

[14:03] <jnthn> OK, fudge as needed.

[14:03] <moritz_> oh wait

[14:03] <moritz_> I didn't realclean or so

[14:03] <moritz_> let me try that first

[14:06] <jnthn> moritz_: I fail 33,34, 36

[14:06] *** cognominal joined
[14:06] <moritz_> still the same here afer realclean + rebuild

[14:07] *** payload joined
[14:07] <moritz_> jnthn: can you take care? you know better than me what's supposed to work ;-)

[14:08] <jnthn> moritz_: Can do. Those ones that are failing are ones that I expected to.

[14:08] <moritz_> I'l be gone for about 10 days, easter vacations and all ;-)

[14:08] <jnthn> But I thought they were fudged.

[14:08] <jnthn> Will check the file.

[14:08] <jnthn> Wow!

[14:08] <moritz_> maybe I'll find a stray internet cable here and there, but no promisies ;-)

[14:08] <masak> moritz_: haveaniceeastervacation.

[14:08] <moritz_> masak: thank you

[14:09] <jnthn> Actually any of that block of tests that pass are bogus passes anyway.

[14:10] *** frew|work joined
[14:11] <pugs_svn> r26155 | jnthn++ | [t/spec] Skip some tests that mostly fail; any that pass are false positives anyway (thus why skip and not todo).

[14:14] <jnthn> moritz_: Enjoy your break. :-)

[14:15] <jnthn> Eek. callsame is a tad tricky...

[14:26] *** rindolf joined
[14:29] *** LylePerl joined
[14:31] *** ihrd joined
[14:35] *** nihiliad joined
[14:37] *** payload left
[14:46] *** TimToady joined
[14:47] *** ihrd left
[14:47] *** diakopter joined
[14:50] *** ashizawa left
[14:51] *** frzntoz joined
[14:53] *** ashizawa joined
[15:02] *** Tene_ joined
[15:05] *** ashizawa left
[15:06] *** ashizawa joined
[15:06] *** ashizawa left
[15:06] *** ashizawa joined
[15:07] *** ashizawa left
[15:07] *** ashizawa joined
[15:10] *** ashizawa left
[15:13] *** ashizawa joined
[15:14] *** ashizawa left
[15:15] *** iblechbot_ joined
[15:15] <jnthn> pmichaud: ping

[15:15] *** ashizawa joined
[15:16] <pmichaud> pong

[15:16] *** Tene left
[15:17] <jnthn> pmichaud: I'm working on wrap

[15:17] <jnthn> I'm having a bit of fun with...guess what...lexicals. :-)

[15:17] <jnthn> In wrapping.t it basically does wrap with a block in a loop.

[15:18] <jnthn> It seems if I clone that block in wrap though, I end up losing the right lexical context.

[15:18] <pmichaud> line number?

[15:18] <jnthn> I have local changes but see around 45

[15:18] <jnthn> Starts for (1..10) -> $num {

[15:19] <pmichaud> what's that $^t parameter supposed to be?

[15:19] <jnthn> wait, I'll commit a less buggy version of the test

[15:20] <pugs_svn> r26156 | jnthn++ | [t/spec] Some tweaks to wrapping.t.

[15:20] <jnthn> pmichaud: OK, comitted.

[15:20] <jnthn> pmichaud: I think that was somebody not understanding postfix++ and readonlyness when the test was written. ;-)

[15:20] <pmichaud> what's that $^t parameter supposed to be?

[15:20] <masak> we have both wrap.t and wrapping.t ?

[15:21] *** payload joined
[15:21] <jnthn> It's just the parameter that is taken by the block that is serving as the wrapper.

[15:21] <jnthn> masak: Yeah, they are testing some different things, probably candidates for a merge though.

[15:22] <jnthn> So the idea is that we'd end up wrapping more and more deeply, and since we can with $^t + 1 each time, we have a number that represents the wrap level.

[15:23] <jnthn> The problem I am hitting is that I maintain as properties on the block the chain of inners.

[15:23] *** iblechbot left
[15:23] <jnthn> They're chained through stuff in the prop hash, that is.

[15:23] <jnthn> But to do that, I need to clone them.

[15:24] <jnthn> But if I clone the wrapping block in the wrap call, things in wrap.t start failing, since they reference outer lexicals of where the block being used to wrap.

[15:26] <pmichaud> failing meaning segfault, or ... ?

[15:27] <pmichaud>                 callwith( $^t + 1 );

[15:27] <pmichaud> what exactly does that mean here?

[15:27] <pmichaud> (I need to review S06)

[15:27] <jnthn> Let me back up a bit.

[15:27] <jnthn> sub foo($x) { say $x }

[15:27] <jnthn> foo(1); # 1

[15:28] <dalek> rakudo: 531fe43 | jnthn++ | src/builtins/control.pir:

[15:28] <dalek> rakudo: Add a stubby callsame that works for argumnetless case. Not figured out how to handle getting the arguments so well just yet, but this is probably enough to pass some of wrapping.t which only needs that.

[15:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/531fe43370c4131104815d4783326feca8061932

[15:28] <dalek> rakudo: 04f63fc | jnthn++ | src/classes/Routine.pir:

[15:28] <dalek> rakudo: Make sure accessing the non-existent return value of unwrap doesn't cause Null PMC Access by handing back Nil.

[15:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/04f63fcd03ee79114787244d3057b189b93b6eb9

[15:28] <dalek> rakudo: 4866942 | jnthn++ | src/classes/Code.pir:

[15:28] <dalek> rakudo: Implement .callwith method for Code objects.

[15:28] <jnthn> &foo.wrap({ callwith($^t + 1) });

[15:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/48669427e7af1ef21c2122c8b827208f75c009f9

[15:28] <jnthn> foo(1); # 2

[15:28] <jnthn> Because callwith calls the inner thingy, that we wrapped

[15:28] * masak finally makes some headway with the Lobster

[15:29] *** Tene_ is now known as Tene

[15:29] <jnthn> rakudo: sub foo($x) { say $x }; foo(1); &foo.wrap({ callwith($^t + 1) }); foo(1);

[15:29] <p6eval> rakudo 4561d2: OUTPUT«1␤2␤»

[15:29] <jnthn> So if we wrap again

[15:29] <jnthn> rakudo: sub foo($x) { say $x }; foo(1); &foo.wrap({ callwith($^t + 1) }); foo(1); &foo.wrap({ callwith($^t + 1) }); foo(1);

[15:29] <p6eval> rakudo 4561d2: OUTPUT«1␤2␤3␤»

[15:29] <jnthn> Which is fine. The problem comes if we do, say

[15:30] <jnthn> rakudo: sub foo($x) { say $x }; foo(1); for 1..2 { &foo.wrap({ callwith($^t + 1) }); foo(1); }

[15:30] <p6eval> rakudo 4561d2: OUTPUT«1␤2␤Parrot VM: PANIC: Out of mem!␤C file src/gc/memory.c, line 52␤Parrot file (not available), line (not available)␤␤We highly suggest you notify the Parrot team if you have not been working on␤Parrot.  Use parrotbug (located in parrot's root directory) or send an␤e-mail to

[15:30] <p6eval> ..parro...

[15:31] <jnthn> Basically, because when we do a wrap, we use properties ont he block pased - the { $^t + 1 } in this case - to chain them.

[15:31] <jnthn> "This is my inner block that callwith() should invoke."

[15:31] <jnthn> Apart from, they don't get cloned, so the chaining gets messed up.

[15:32] <jnthn> But I can't make wrap clone the block because if the block cares about its outer lexical scope (see examples pushing to @log in wrap.t) the clone causes issues there, it seems.

[15:33] <pmichaud> cloning shouldn't be causing problems.

[15:34] <pmichaud> short answer is that you have to clone the block.

[15:34] <pmichaud> (or that you should be cloning the block)

[15:34] <jnthn> Yeah, doing that makes wrap.t go and fail. :-(

[15:34] <pmichaud> then I suspect the issue is in wrap.t

[15:34] <pmichaud> (or the code trying to execute wrap.t)

[15:35] <jnthn> It does stuff like

[15:35] <jnthn> sub wrapper { push @log, "wrapper before"; try { callwith() }; push @log, "wrapper after";

[15:35] <jnthn> }

[15:35] <jnthn> Where @log is in the outer lexical scope of the wrapping block

[15:35] <jnthn> I'll make sure it really is a lexical-ish issue...or if it's something else that the clone throws up.

[15:36] *** ejs left
[15:36] *** brunov joined
[15:37] <pmichaud> I don't quite understand the spec's intended mechanics for callwith()

[15:38] <jnthn> How so?

[15:38] <pmichaud> in wrap.t, that first call to wrapper() ends up with an exception for callwith() ?

[15:38] <jnthn> Yes

[15:38] <jnthn> thus why it's in a try

[15:38] <pmichaud> and it's an exception because...?

[15:38] <jnthn> (That was the way I found the test. I think it's just to sanity check.)

[15:38] <jnthn> Because there's nothing to call.

[15:39] <pmichaud> where "something to call" comes from ?

[15:39] <jnthn> It's only when you apply it as a wrapper to something else that callwith then calls the thing that was wrapped.

[15:39] <jnthn> $handle = &thermo.wrap( { callwith( ($^t-32)/1.8 ) } );

[15:39] <pmichaud> how does callwith detect that?

[15:39] <jnthn> When you do that, thermo() now calls that block, and callwith calls the original block.

[15:40] <pmichaud> how does callwith know "the original block" ?

[15:40] <jnthn> Well, how callwith does that is implementaiton specific I guess - the spec doesn't seem to lay any constraints on that. But in Rakudo's case it stores the original block in a property ont he sub.

[15:40] <pmichaud> on which sub?

[15:40] <jnthn> And callwith looks for that property on its caller.

[15:40] <jnthn> Or an outer up to the limit of a routine anyway.

[15:41] *** hercynium joined
[15:41] <pmichaud> but in the case of wrapper() there,  the caller to callwith()  is always wrapper

[15:41] *** bacek left
[15:41] <pmichaud> the caller to the block containing callwidth() is always wrapper

[15:41] <jnthn> *nod*

[15:41] <pmichaud> there's not a way to call that block directly.

[15:41] <jnthn> *confused*

[15:41] <pmichaud> so it can't just be "my caller"

[15:42] <jnthn> No, it's not as simple as "my caller" really.

[15:42] <jnthn> The block ends up associated with the original sub...which means that yes, we really do need to clone it...

[15:42] <pmichaud> which block ends up associated with the original sub ... ?

[15:42] <jnthn> The clone of wrapper in the case above.

[15:43] <jnthn> Routines are mutable.

[15:43] <pmichaud> but that still doesn't answer my question

[15:43] <jnthn> I don't really follow what you're asking.

[15:43] <pmichaud> how does callwith find "the original block"  ?

[15:43] <jnthn> Because it's attached as a property to the (should be clone) of the wrapping block.

[15:44] <pmichaud> how does callwith find the wrapping block?

[15:44] <TimToady> a wrap sets up a call to a candidate list.  callwith/callsame/nextwith/nextsame always interact with some caller's candidate list

[15:44] <jnthn> By examining first its caller, then its callers outers.

[15:44] <pmichaud> that's my point

[15:44] <pmichaud> oh, wait

[15:44] <jnthn> (Limiting the seach to within one routine.)

[15:44] <TimToady> it has to be the same mechanism as used by multis and methods

[15:45] <pmichaud> jnthn: I'm missing something very fundamental in your description here.

[15:45] <TimToady> !@#$!@#$!

[15:46] <jnthn> pmichaud: Maybe the code will be clearer than I am?

[15:46] <TimToady> HELLO, IS THIS MIKE ON???

[15:47] <masak> rakudo: say (1,2,3).map: { $_ }

[15:47] <jnthn> TimToady: I can see that callwith, callsame etc also deal with those, yes.

[15:47] <p6eval> rakudo 486694: OUTPUT«123␤»

[15:47] <masak> rakudo: module Foo { say (1,2,3).map: { $_ } }

[15:47] <p6eval> rakudo 486694: OUTPUT«Parameter type check failed for expr in call to map␤current instr.: 'die' pc 16596 (src/builtins/control.pir:222)␤»

[15:47] * masak submits rakudobug

[15:47] <pmichaud> jnthn: with  &foo.wrap( &wrapper ), what happens, exactly?

[15:47] <TimToady> but you seem to be wanting to invent a different mechanism for wraps than for other dispatches

[15:48] <jnthn> TimToady: So how exactly is it meant to work?

[15:49] <TimToady> callwith does exactly the same thing in a method calling a SUPER that it does in a multi calling the next candidate, and a wrap calling it's next wrappee

[15:49] <jnthn> That is, what should wrap really be doing?

[15:49] <TimToady> it makes a candidate list

[15:49] <TimToady> and a call to the function name calls the dispatcher to the first wrap candidate, which may call the others, or not

[15:50] <TimToady> think of them all as "next METHOD" where there's some implicit dispatcher loop labelled METHOD:

[15:51] <TimToady> only with more finesse about the arguments and tailcalls

[15:52] <jnthn> OK, but what is that candidate list associated with?

[15:52] <jnthn> The Routine?

[15:54] <LylePerl> hi

[15:54] <TimToady> whatever gets called first thing when you say &foo.()

[15:54] *** Psyche^ joined
[15:54] <TimToady> where do you hide the candidate list for a multi?

[15:55] <jnthn> The thingy in the symbol table/lexpad/method slot for a multi is an instance of some type Multi which holds all of the variants.

[15:55] <LylePerl> masak: ping

[15:55] <TimToady> this is about one level down from that, a sub-dispatcher associated with the &foo routine that delegates

[15:56] <TimToady> wrapping is a level of indirection hidden inside the &foo symbol

[15:56] <masak> LylePerl: pong.

[15:56] <TimToady> so &foo contains a dispatcher instead of the bare routine

[15:56] <jnthn> Whereas at the moment for a single routine foo() we install it directly into such a slot.

[15:56] <jnthn> Ah, OK.

[15:57] <jnthn> Do you see callsame() etc then as essentially being exceptional control flow?

[15:57] <LylePerl> masak: Getting Perl 5 scripts to work properly on IIS usually requires FindBin and chdir. I can't seem to find these for Perl 6, do they exist?

[15:57] <TimToady> and if we wrap something that's already wrapped, we can just keep the one dispatcher and add to its candidate list

[15:58] <masak> LylePerl: I highly doubt it.

[15:58] <jnthn> That is, they throw exceptions that the current dispatcher catches and then knows to invoke the next thing in the candidate list?

[15:58] <masak> LylePerl: furthermore, the things those modules encapsulate are currently fairly hard to do in Rakudo.

[15:58] *** amoc joined
[15:58] <masak> LylePerl: we do them in our projects, but with difficulty and hardship.

[15:59] <TimToady> pugs has a FindBin

[15:59] <literal> how hard would it be to port this? http://svn.pugscode.org/pugs/ext/FindBin/lib/FindBin.pm

[15:59] <TimToady> yes, that

[15:59] * masak looks

[15:59] <TimToady> might be bitrotted, but it is in p6

[16:00] <TimToady> might also depend on pugs primitives

[16:00] <masak> it depends on File::Spec...

[16:00] <LylePerl> TimToady: thanks

[16:00] <pmichaud> File::Spec :   http://svn.pugscode.org/pugs/ext/File-Spec/

[16:00] <masak> LylePerl: it definitely looks port-able.

[16:01] <LylePerl> :)

[16:01] <masak> I see nothing strange in FindBin.pm that Rakudo would choke on.

[16:01] * masak looks at File::Spec

[16:01] <pmichaud> it'd be nice to get rid of the :P5's in File::Spec::Win32

[16:02] <TimToady> rakudo: eval "say 'hi'"

[16:02] <p6eval> rakudo 486694: OUTPUT«hi␤»

[16:03] <masak> LylePerl: I see some things in File::Spec::Unix that will cause problems under Rakudo.

[16:03] <pmichaud> masak: at npw I think it might be really good for us to talk about library packaging ideas :-)

[16:03] <masak> pmichaud: indeed.

[16:03] <LylePerl> What about chdir? I read some converstations in 2005 about using @CWD instead?

[16:03] *** payload left
[16:04] <jnthn> TimToady: Or put another way, would an implementation that did the dispatcher flow in terms of an exception model sound wrong to you?

[16:04] <PerlJam> LylePerl: chdir doesn't yet exist in rakudo

[16:04] <masak> LylePerl: Rakudo, as far as I know, doesn't do anything there.

[16:04] <masak> ah. what PerlJam said.

[16:04] <pmichaud> ...but it could.

[16:04] <pmichaud> assuming that Parrot gives us access to chdir, at least.

[16:04] <masak> LylePerl: I think it's certainly doable to port these modules to Rakudo. if you're willing to negotiate some small features with the Rakudo devs.

[16:04] <pmichaud> (well, we could make it work even if Parrot doesn't :-)

[16:05] <pmichaud> I think I'd be quite eager to get some of the modules into Rakudo

[16:05] <jnthn> Method chdir ont he OS PMC.

[16:05] <[particle]-> anyone have a camelia image link? i can't find it

[16:05] <pmichaud> and to think about how we might want to set up libraries

[16:05] <masak> jnthn: sounds promising.

[16:06] <jnthn> masak: If you wants it I can write it...

[16:06] <masak> [particle]-: http://www.wall.org/~larry/camelia.pdf

[16:07] <LylePerl> would make november on IIS much easier

[16:07] <[particle]-> ah, pdf! thanks.

[16:07] <pmichaud> particle:  http://svn.pugscode.org/pugs/misc/

[16:07] <masak> jnthn: it would make life easier for proto, that's for sure.

[16:07] <TimToady> use the camelias in pugs/misc

[16:07] *** frzntoz left
[16:07] <pmichaud> pugs/misc has .odf version

[16:07] <pmichaud> and .svg

[16:07] <pmichaud> and .ico

[16:07] <TimToady> 32 and 16

[16:07] <jnthn> masak: OK. is chdir in S32, I wonder...or S16...

[16:08] <LylePerl> S29

[16:08] <masak> @spack chdir

[16:08] * lambdabot loves chdir, so no slapping

[16:08] <masak> :P

[16:08] <masak> buubot: spack chdir

[16:08] <buubot> masak: Sorry, I couldn't find any matches for: chdir

[16:08] <LylePerl> isn't not part of the default namespace

[16:08] <LylePerl> http://perlcabal.org/syn/S29.html

[16:08] <[particle]-> not as cute as glenda, the plan 9 bunny, but with an artist's help... maybe.

[16:08] <TimToady> jnthn: when I say "next METHOD" I'm referring to an exception model, it would seem

[16:09] <pmichaud> given that IO and filesystem stuff are currently a bit underspecified in the synopses, I'm willing to be a bit liberal about what Rakudo implements

[16:09] *** justatheory joined
[16:09] <pmichaud> i.e., we can put things in Rakudo that aren't official spec.  But we should also keep a list of warning-warning-warning about them somewhere.

[16:09] <[particle]-> io stuff was waiting for parrot implementation a bit iirc

[16:09] <[particle]-> so rakudo impl will likely influence the spec there

[16:10] <TimToady> either that, or whack someone upside the head to put it into the spec :)

[16:10] <TimToady> or, given current state of S32, just put it into the spec yourself :)

[16:10] <jnthn> TimToady: OK, I'll ponder that a bit...

[16:10] <[particle]-> well, any of us here can do that, it's in the pugs repo, after all

[16:10] *** Patterner left
[16:10] *** Psyche^ is now known as Patterner

[16:10] *** kst left
[16:11] <pmichaud> my suggestion:  whoever wants chdir implemented in rakudo can just write it.  Or, if they're not inclined/empowered to do that, they should write the spec for it in S32 or somewhere and then file a ticket to have it implemented :-)

[16:11] <pmichaud> oh, and tests.

[16:12] <masak> LylePerl: got that? :)

[16:12] <TimToady> it would be nice if there were a mechanism that different dynamic scopes could think they were in different directories, but perhaps that's not a feature we should delay 6.0 for

[16:12] <LylePerl> It's above me, I only started looking at Rakudo on Sunday and Parrot a couple of days ago :(

[16:13] <pmichaud> LylePerl: writing the spec or tests shouldn't be above you :-)

[16:13] <pmichaud> or, at least, not too far above you :-)

[16:13] <masak> LylePerl: you can count on help from me and others on this channel with any questions you have.

[16:13] <pmichaud> audreyt had a very nice policy of trading new features for tests.  

[16:13] <LylePerl> I'll give it a go, prob take me a while though ;)

[16:14] <pmichaud> I think we can do a similar thing with rakudo -- write the spec and tests that you want, and someone else will likely pick up the feature implementation itself fairly quickly.

[16:14] <masak> no worries. keep it simple, small iterations.

[16:14] <masak> (that was for LylePerl)

[16:15] <LylePerl> ok. Where do I start, gimme a list of things to lookup and I'll read up and work through it

[16:15] <pmichaud> masak, others:  any thoughts about opening up a cpan-like repository on github for things like File::Spec, Find::Bin, etc. that could be shared among multiple implementations?

[16:15] <pmichaud> or should we just keep it all in pugs (and fix what's there now...?)

[16:15] *** frzntoz joined
[16:15] <masak> pmichaud: I think perl6-examples is that repository already.

[16:16] <masak> pmichaud: just look inside its lib/ directory and you'll see what I mean. :)

[16:16] <masak> all sorts of goodies there.

[16:16] <pmichaud> masak: okay.  I have the 'perl6' account on github, so I'm wondering if it perhaps should move there.

[16:16] <pmichaud> then we could have perl6/examples, perl6/library, etc.

[16:16] <masak> pmichaud: I don't mind.

[16:17] <TimToady> it's the GPAN...

[16:17] <masak> but you should perhaps negotiate that with eric256.

[16:17] <pmichaud> yes, of course.

[16:17] <masak> pmichaud: until such a move happens, I think perl6-examples is more than adequate for such modules.

[16:18] <pmichaud> masak: I'm thinking more about packaging issues... at some point I suspect that rakudo should "ship" with such modules already in place.

[16:18] <masak> pmichaud: ok.

[16:18] <LylePerl> TimToady: Guinea Pig Adoption Network gpan.net ? :p

[16:18] <pmichaud> but I don't think the rakudo repo is the correct place for those modules to be housed

[16:19] <masak> pmichaud: not even Test.pm, methinks.

[16:19] <pmichaud> masak: well, we keep saying that Test.pm will really be core, so it's already a bit of a misnomer

[16:19] <masak> right, right.

[16:19] * masak likes Test.pm as it is :)

[16:19] <pmichaud> i.e., in theory we could start moving Test.pm into setting/

[16:19] <pmichaud> and it then just becomes part of the standard build.

[16:20] <TimToady> gpan.org is available, if gpan.net isn't  :)

[16:20] * masak has to go RSN

[16:20] <pmichaud> where "gpan" == "github ... " ?

[16:20] <TimToady> that's was the original pun, yes

[16:20] <pmichaud> okay.  

[16:20] <masak> gpun.

[16:20] <pmichaud> I'm a bit slow and sleep-deprived this morning, I think.

[16:20] <TimToady> well, the pun was the resemblance between G and C, actually

[16:21] <pmichaud> and the G does look kinda like a "6"  :-)

[16:21] <pmichaud> almost halfway between CPAN and 6PAN  :-)

[16:21] <TimToady> but now I feel unclean :)

[16:21] <TimToady> shower &

[16:22] <pmichaud> LylePerl: (where to start)  here's my suggestion

[16:22] <pmichaud> assuming that you need a chdir function available in Rakudo to support whatever it is you're wanting to do

[16:22] <LylePerl> I was saying on #parrot the other day it would be good if cpan (or the new one) was part of TPF

[16:23] <LylePerl> pmichaud: yes

[16:23] <pmichaud> (1) review existing synopses and spectests to see if chdir has already been worked on

[16:23] <pmichaud> if yes, then see if it makes sense and point the developers at it. 

[16:23] <pmichaud> "point the developers" generally means "file a ticket"

[16:23] <pmichaud> if there's nothing existing for chdir, then

[16:23] <masak> LylePerl: I'll be away for a day and a half, but I'm sure others in the channel will help you if you need it. also, I will backlog, so just saying things loudly works too, but possibly with a bit of a delay.

[16:24] <masak> LylePerl: good luck.

[16:24] <pmichaud> (2)  draft what you think chdir should look like

[16:24] <pmichaud> to draft it, look at other functions in S32 or other places to see how they've been documented

[16:24] * PerlJam is pretty sure LylePerl is going to quickly move to step 2

[16:24] *** kst joined
[16:25] <pmichaud> also, we don't completely ignore Perl 5 -- so look at Perl 5's documentation and see if you think it makes sense for Perl 6

[16:25] <pmichaud> and just try to adapt it to a Perl 6 sort of idea

[16:25] <masak> PerlJam: aye. there's only one mention of 'chdir', and it's in S29. it only lists chdir and moves on.

[16:25] <pmichaud> if what you draft is incorrect, no problem -- others will fix it.  We definitely prefer "progress with errors" to "everyone waits on everyone else to do something"

[16:25] * masak moves on too

[16:26] *** masak left
[16:26] <LylePerl> masak: ok, catch up later

[16:26] <LylePerl> pmichaud: ok :)

[16:27] <pmichaud> also, RT #49171 is our "high priority meta ticket".  So, if something is really important, you can (get someone to) attach your ticket as a dependency of #49171.

[16:28] <PerlJam> pm: how important do you think it is to get rakudo working with IIS?  :)

[16:29] <pmichaud> pj:  that's actually a bit high on my priority list

[16:29] <pmichaud> because Web.pm will likely want or need it

[16:29] <pmichaud> and we still tend to be very application-driven

[16:29] <PerlJam> LylePerl: remember pmichaud's answer to my question when you create that first ticket  ;)

[16:29] <pmichaud> so if LylePerl++ and masak++ both are saying "we need feature XYZ", then I think it deserves some quick attention

[16:30] <pmichaud> (assuming it can be done relatively quickly, as this one can)

[16:30] <LylePerl> I see

[16:30] <pmichaud> we also have people who are interested in hacking on Rakudo over the next few months -- tickets like this are good entry points into learning about how things work.

[16:31] <pmichaud> which is partially why I'm not jumping to implement chdir myself right now -- I think it'd be good to find someone else (perhaps LylePerl, perhaps another) to do it

[16:31] <LylePerl> ok :s

[16:31] <pmichaud> but things are nicer when we start with the spec and/or tests

[16:31] <pmichaud> and that doesn't really require Parrot knowledge

[16:32] <pmichaud> afk for a bit

[16:34] <LylePerl> ok. I'd better get back to £work£. I read up on all this tonight/tomorrow. Thanks for all your help

[16:39] *** frzntoz left
[16:43] *** Tene_ joined
[16:43] *** japhb left
[16:48] *** legis joined
[16:52] *** cdarroch joined
[16:53] *** Tene left
[17:10] <dalek> rakudo: 4cc08e8 | jnthn++ | src/parser/actions.pm:

[17:10] <dalek> rakudo: Add multiple prefix constraint check, as done by STD.pm.

[17:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4cc08e81ec2c0c6e04bad073a4c14535dbad0857

[17:11] <TimToady> well, we'll certainly need a primitive process-wide chdir, even if we hide it from people most of the time

[17:11] <TimToady> we don't want a web server's subprocesses chdiring other subprocesses unexpectedly, for instance

[17:12] <TimToady> so I'd guess our IO system as a whole wants to track current directory separately from the process as a whole

[17:12] <TimToady> which probably means the current directory is contextual

[17:12] <TimToady> (dynamically scoped, that is)

[17:14] <TimToady> and { temp $*CD = chdir('..'); open($file); } would be taught to do the right thing in context

[17:15] <TimToady> $*CD would be an object representing the current directory, not a string

[17:16] *** ChanServ sets mode: +o TimToady

[17:17] <TimToady> well, maybe just have chdir set the current $*CD, whatever its dynamic scope is.

[17:18] *** frzntoz joined
[17:19] *** [particle]1 left
[17:21] *** frzntoz left
[17:24] *** diakopter left
[17:24] *** davidad left
[17:24] *** agentzh left
[17:24] *** dukeleto left
[17:24] *** zostay left
[17:26] *** frzntoz joined
[17:26] *** betterworld joined
[17:28] <LylePerl> TimToady sounds good

[17:30] <LylePerl> There is a thread about it here from 2005 http://groups.google.com/group/perl.perl6.language/browse_thread/thread/c1ff319f1cf023f5/7e74d2a1ae9d0a76?#7e74d2a1ae9d0a76

[17:31] <LylePerl> At the time you were talking about @CWD

[17:31] *** xinming left
[17:32] *** zamolxes joined
[17:34] <rindolf> rakudo: [+] (5,6,7)

[17:34] <p6eval> rakudo 4cc08e:  ( no output )

[17:34] <rindolf> rakudo: [+] [5,6,7]

[17:34] <p6eval> rakudo 4cc08e:  ( no output )

[17:34] <rindolf> perl6: [+] [5,6,7]

[17:34] <p6eval> pugs, rakudo 4cc08e:  ( no output )

[17:34] <p6eval> ..elf 26156: OUTPUT«/home/evalenv/pugs/misc/STD_red/match.rb:117:in `block in to_dump0': undefined method `to_dump0' for nil:NilClass (NoMethodError)␤     from /home/evalenv/pugs/misc/STD_red/match.rb:117:in `map'␤       from /home/evalenv/pugs/misc/STD_red/match.rb:117:in `to_dump0'␤  from

[17:34] <p6eval> ../home/evalenv/pugs/...

[17:35] <jnthn> rakudo: say [+] (5,6,7)

[17:35] <p6eval> rakudo 4cc08e: OUTPUT«18␤»

[17:38] <PerlJam> jnthn: any clue where to start looking for this one ...

[17:38] <PerlJam> rakudo: my @a=1..10; say @a[4..*];

[17:38] <p6eval> rakudo 4cc08e: OUTPUT«5678910Use of uninitialized value␤␤»

[17:38] <PerlJam> ?

[17:38] <jnthn> PerlJam: Yeah, in fact I did look for it earlier...

[17:38] <rindolf> rakudo: say [*] (1..7)

[17:38] <p6eval> rakudo 4cc08e: OUTPUT«5040␤»

[17:39] <jnthn> PerlJam: The thing is that * here ends up evaluating to the number of elements in the array

[17:39] <jnthn> Which is what you want for *-1

[17:39] <jnthn> But gives an off-by-one in 1..*

[17:39] *** IRSeekBot joined
[17:39] <rindolf> rakudo: sub myop ($x, $y) { $x + 2 * $y} say [myop] (1..7)

[17:39] <p6eval> rakudo 4cc08e: OUTPUT«Statement not terminated properly at line 1, near "say [myop]"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[17:39] *** IRSeekBot left
[17:41] <jnthn> PerlJam: Thing is, it's not immediately clear to me in 1..* should construct an infinite range or a { 1 .. $_ } block.

[17:41] <PerlJam> Well, we can always use  @a[1..^*]  instead  :-)

[17:41] *** sitaram left
[17:42] *** IRSeekBot joined
[17:42] *** [particle] joined
[17:42] <PerlJam> jnthn: can you give me some more context wrt your statement of  *-1  ?  Where would that show up? 

[17:42] <jnthn> PerlJam: Yes, and that one *does* work in Rakudo. :-)

[17:43] <jnthn> PerlJam: Context in Rakudo or spec?

[17:43] <PerlJam> spec I guess.   

[17:43] <jnthn> @array[*-1]       # Last element of the array

[17:43] <lambdabot> Unknown command, try @list

[17:43] <jnthn> In S09

[17:44] <PerlJam> Hmm.

[17:44] <jnthn> Also on S02

[17:45] <jnthn> Most of the built-in numeric operators treat an argument of C<*> as

[17:45] <jnthn> indicating the desire to create a function of a single unknown, so:

[17:45] <jnthn> * - 1

[17:45] <jnthn> produces a function of a single argument:

[17:45] <jnthn> { $_ - 1 }

[17:45] <PerlJam> okay, where's that in rakudo?  I assume that the handling of @a[1..*] happens in Range somewhere and  @a[*-1] happens somewhere else?

[17:46] <[particle]-> whatever.

[17:46] <jnthn> I've got a local patch that sort of starts refactoring that a bit, but look for postcircumfix:[ ]

[17:46] <TimToady>  @a[*-1] turns into @a[ { $_ - 1 } ]

[17:46] <jnthn> And especially src/classes/Positional.pir

[17:46] <TimToady> so the subscripter sees a closure and calls it with +@a.elems

[17:47] <jnthn> TimToady: And 1..* constructs an infinite range? Certainly not { 1..$_ }

[17:47] <TimToady> infix:<..> has a (Int,Whatever) and a (Whatever,Int)

[17:47] <TimToady> and a (Str,Whatever) and a (Whatever,Str)

[17:47] <jnthn> Right, which construct infinite ranges, not closures?

[17:47] <[particle]-> int or num?

[17:47] <TimToady> and Whatever is taken as either pos or negative infinity

[17:47] <jnthn> OK. :-)

[17:48] <TimToady> well, *..'a' doesn't make sense

[17:48] <TimToady> so forget that case

[17:48] <jnthn> ;-)

[17:48] <TimToady> but yes, .. doesn't make closures

[17:48] <jnthn> OK, thanks.

[17:48] <TimToady> nor does xx *

[17:49] <jnthn> OK.

[17:49] <jnthn> S02 says "numeric" operators

[17:49] <TimToady> any operator is allowed to have an idiosyncratic interpretation of *

[17:49] <jnthn> So I figure * ~ "thingy" doesn't count?

[17:49] <[particle]-> i wonder what the idiomatic way is to generate a range around 0, like -5 .. 5

[17:49] <jnthn> (As a closure-forming...)

[17:49] <TimToady> just most of the standard math ops don't, and just have * cases that make closures

[17:50] <jnthn> OK.

[17:50] <TimToady> but it's all multi dispatch driven

[17:50] <jnthn> Sure, I planned to do it just by generating a bunch of multis.

[17:50] *** Khisanth joined
[17:51] * jnthn ponders dinner

[17:53] <TimToady> note that the subscripter handles * directly different than *-1

[17:53] <TimToady> since one is of type Whatever and the other is of type Code

[17:53] *** [particle] left
[17:54] <TimToady> a subscript of Whatever turns into 0..* or some such

[17:55] <TimToady> PerlJam: a * is always handled in the next operator it sees, regardless of its outer context

[17:55] *** riffraff left
[17:55] <TimToady> in @a[*-1] the - handles Whatever,Int with no knowledge that it happens to be inside @a[...]

[17:56] <TimToady> likewise 0..* doesn't know or care what its outer context is

[17:56] <PerlJam> makes sense

[17:57] <TimToady> actually, the subscripter doesn't necessarily supply @a.end; it has to supply the appropriate end for that dimension of the subscript

[17:58] <TimToady> which may either be the shaped end or the actual end, depending on whether that dimension is open-ended

[17:58] *** LylePerl left
[17:59] <jnthn> TimToady: It gives .elems and not .end, no?

[17:59] <PerlJam> jnthn: that sounds like it would be off by one.

[17:59] <TimToady> yes, elems

[17:59] <TimToady> sorry

[17:59] <jnthn> TimToady: Since .end - 1 is .end.

[17:59] <jnthn> Right. :-)

[17:59] <[particle]-> um.

[18:00] <TimToady> and of course, once it's implemented correctly @a[1..^*] will stop working...

[18:00] <[particle]-> jnthn: you wanna review that bit of math?

[18:00] <jnthn> TimToady: Because of lack of multi?

[18:00] <jnthn> [particle]-: oh it's fine if .end returns a junction :-P

[18:00] <jnthn> s:2nd/end/elems/

[18:00] <jnthn> erm

[18:00] <jnthn> 1st

[18:01] <jnthn> Yeah. Certainly it's time for dinner. :-)

[18:01] <TimToady> well, I suppose it might still work if 1..^* means all the integers excluding Inf

[18:01] <[particle]-> heh, better

[18:01] <jnthn> What's Inf - 1? ;-)

[18:02] <PerlJam> I think I'm still confused.   my @a = 1..10;   @a[5..*];   # the Whatever is @a.elems or @a.end ?  The latter is what makes sense to me.

[18:02] <TimToady> I guess the subscriptor is using a range as a lazy list, and ignores running off the end if the range is known to be infinite

[18:02] <TimToady> that * doesn't know about @a

[18:02] <TimToady> at all

[18:02] <jnthn> PerlJam: I think in this case the...yes, what TimToady said.

[18:02] <jnthn> We'll have to teach postcircumfix:<[ ]> about infinite ranges.

[18:03] <TimToady> it makes an infinite range, and @a[] knows what to do with that

[18:04] <jnthn> std: multi sub my_abs (Num where { $^n <  0 } $n){ -$n }

[18:04] <TimToady> @a[] also knows what to do with a closure, which is call it with the dimension's .elems (or shape)

[18:04] <lambdabot> Maybe you meant: arr ask

[18:04] <p6eval> std 26156: OUTPUT«##### PARSE FAILED #####␤Malformed multi␤Malformed routine␤Malformed routine␤Multiple prefix constraints not yet supported at /tmp/okDOoskiZC line 1:␤------> ulti sub my_abs (Num where { $^n <  0 } $n){ -$n }␤    expecting any of:␤      infix or meta-infix␤     

[18:04] <p6eval> ..infix stopper...

[18:04] <jnthn> goody

[18:05] <pugs_svn> r26157 | jnthn++ | [t/spec] Correct test that used two prefix constraints.

[18:07] *** barney joined
[18:09] *** japhb joined
[18:09] *** diakopter joined
[18:09] *** davidad joined
[18:09] *** agentzh joined
[18:09] *** dukeleto joined
[18:09] *** broquaint joined
[18:09] *** zostay joined
[18:09] <TimToady> I'll wager my spell checker doesn't like either of subscriptor or subscripter...

[18:10] <pugs_svn> r26158 | jnthn++ | [t/spec] Tests for multiple prefix constraints being an error and for %hash<>.

[18:12] <dalek> rakudo: b512bdc | jnthn++ | src/classes/Associative.pir:

[18:12] <dalek> rakudo: %h<> should return everything in the hash, like @a[] returns everything in the array.

[18:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b512bdca731d06c1488e4b302351e6c0f8f2fb3d

[18:12] <dalek> rakudo: 9854f25 | jnthn++ | src/parser/actions.pm:

[18:12] <dalek> rakudo: Enforce a single prefix type constraint on parameters.

[18:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9854f25c842fff91e79c33ec9507cb9ad36dcd4b

[18:12] <dalek> rakudo: 07ed756 | jnthn++ | src/classes/Range.pir:

[18:12] <dalek> rakudo: Implement postcircumfix:[ ] in Range. It doesn't know about infinite ranges, but not much else does yet either.

[18:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/07ed7564110d0f3e48beec46af5cc2a171fd2dfb

[18:13] *** ejs joined
[18:13] * jnthn -> dinner, back later

[18:14] <PerlJam> So ... the following should be equivalent (modulo my syntax errors):    my $r = Range(*,5);  my @a = "a".."z";  say @a[$r];  say @a[*..5];

[18:15] <PerlJam> as an aside, can I use Whatever in place of * ?

[18:15] <PerlJam> @a[Whatever..5]

[18:15] <lambdabot> Unknown command, try @list

[18:16] <PerlJam> lambdabot: you really should ignore unknown commands.

[18:21] *** jferrero joined
[18:27] <pmichaud> back from lunch

[18:27] *** amoc left
[18:29] *** LylePerl joined
[18:30] * pmichaud really likes the graph at rakudo.org/status much better now.  :-)

[18:33] *** barney left
[18:33] <literal> hm, what caused that jump?

[18:33] <pmichaud> support for unicode properties in regexes

[18:34] <pmichaud> also a lot of jnthn++'s work on parameterized types

[18:35] <literal> what's the number now?

[18:35] <pmichaud> 10,224 as of this morning.

[18:35] <literal> nice

[18:36] *** pmurias joined
[18:37] <literal> hm, how many tests does Perl 5 have?

[18:37] <PerlJam> many more

[18:38] *** [particle] joined
[18:38] <jrockway> i was looking at the rakudo web page today, and wondered something

[18:39] <jrockway> why is it 楽土 and not 楽道 ?

[18:39] <jrockway> (i always assumed the second one)

[18:40] <[particle]-> !!!

[18:41] <[particle]-> almost 10K tests

[18:41] <pmichaud> I asked some people I knew in Japan for the logo and that's what they sent.  :-)

[18:41] <pmichaud> ...almost 10K tests?

[18:41] <[particle]-> rakudo: say 10 * 1024;

[18:41] <p6eval> rakudo 07ed75: OUTPUT«10240␤»

[18:41] <[particle]-> ;)

[18:41] <pmichaud> oh,  _that_ K.

[18:41] <pmichaud> we might already be >10,240 with jnthn++ and moritz++ latest updates to suite.

[18:42] * pmichaud does a test run just to find out.

[18:47] <PerlJam> pm:  #moose is arguing about the meaning of that graph 

[18:49] * skids tries to parse S12:

[18:49] <skids> "All public method calls are "virtual" in the C++ sense. More surprisingly, any class name mentioned in a method is also considered virtual, that is, polymorphic on the actual type of the object."

[18:50] <skids> Trying to grok exactly what that last part is talking about -- "mentioned" how?

[18:50] <PerlJam> skids: I think it meant to say "method signature"

[18:51] <skids> That's sorta what I was taking away from it.

[18:52] <pmichaud> pj:  what's the crux of the argument?

[18:52] <pmichaud> pj:  and should I bother to join in, or just let them argue?  ;-)

[18:53] <PerlJam> pm: nah, it's petered out.   Basicaly rjbs was reacting to the idea that "more green == more perl6" 

[18:53] <pmichaud> it's not as if I went out and added a bunch of tests just to add more green.

[18:53] <pmichaud> These are tests that came from Pugs.

[18:54] * pmichaud wonders if there's a #moose log somewhere.

[18:55] <skids> Yeah if we wanted to just fake out tests .... just Class int8 is Int where {...} or something :-)

[18:56] <pmichaud> or phrased another way -- people often talk about how great pugs is because it passes N tests.  Rakudo is for the most part simply re-using those same tests.

[18:56] <pmurias> assuming that the tests don't duplicat themself and that what's not tested doesn't work one could prove that more passing tests == more perl6 working

[18:56] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[18:56] <PerlJam> I don't often see anyone saying anything about pugs other than it's bitrotten.

[18:57] <literal> pmurias: ...and that the new tests aren't testing something that already worked in Rakudo

[18:57] <PerlJam> though there have been a few people in here over the last year asking how to get started with pugs, but I generally assume that's because they don't know about rakudo.

[18:58] *** legis left
[18:59] <brunov> pmurias, the actual argument was that there shouldn't be a reason to be proportionately excited with the number of tests passing, because the coverage per test is not constant

[18:59] <brunov> at least that's what I understood

[18:59] <brunov> so you should get equally excited with one more test passing that with 10 more tests passing

[18:59] <PerlJam> in some ways pugs has stolen the thunder from any other perl6 implementation.   Now when people talk about another implementation you'll get reactions like "but doesn't pugs already do that?" and "oh sure, it'll end up abandoned like pugs" and such.

[19:01] <PerlJam> brunov: It didn't seem like he was interested in modulating the excitement as much as tempering it with reality  :)

[19:01] <pmichaud> actually, with this latest commit I'm more excited about percentage of spectest coverage than raw numbers of tests.

[19:01] <brunov> PerlJam, I did my best

[19:01] <pmichaud> now that the green is the majority of the vertical scale :-)

[19:02] <pmichaud> it makes it look as though we don't have as far to go as it previously did

[19:02] <pmichaud> previously, people could say "oh, we're not even halfway to pugs yet".  Now, we are almost 2/3rds of the way :-)

[19:05] <PerlJam> but pugs isn't the bar most people are interested in.

[19:06] <pmichaud> but it did set a high water mark

[19:06] <pmichaud> and people take that as a measure of progress

[19:07] *** PhatEddy joined
[19:07] <PerlJam> as long as you be sure to add a line on the graph to show where pugs was when rakudo passes it  :)

[19:07] <pmichaud> unfortunately, I don't know what that was.

[19:09] <Khisanth> hmm so this is rakudo progress but not perl6 progress ...

[19:09] <PhatEddy> rakudo: my @a = 1..4; say @a[*..2].perl

[19:09] <p6eval> rakudo 07ed75: OUTPUT«Multiple Dispatch: No suitable candidate found for 'cmp', with signature 'PP->I'␤current instr.: 'parrot;Range;!to_test' pc 10000 (src/classes/Range.pir:250)␤»

[19:09] <pmichaud> oh, I think it's perl6 progress also.

[19:10] <pmichaud> The tests that Pugs passed when it was passing tests aren't the same today.

[19:10] <skids> rakudo: class D is ::C {}; class C is also { };

[19:10] <pmichaud> and the tests evolved due to improvements in our understanding of Perl 6

[19:10] <p6eval> rakudo 07ed75: OUTPUT«Null PMC access in get_string()␤current instr.: '!meta_trait' pc -95315 ((unknown file):-1)␤»

[19:11] <TimToady> 楽土 means "paradise", literally pleasure earth.  earth is "do", short.  "way" is "dou", long, so the proper romanization of 楽道 would be rakudou, the way of pleasure

[19:11] *** iblechbot_ left
[19:11] <TimToady> it can also be taken as a shortening of rakudadou, the way of the camel

[19:12] <TimToady> but then it'd be 駱駝道

[19:12] <skids> Eh, as software names go "pleasure earth" ain't that bad :-)

[19:12] <PerlJam> pm: your sentence seems to assume a hypothetical perfect perl 6 that is as yet undiscovered.  It seems to me that a physicist is better positioned to find it  ;)

[19:14] <PhatEddy> Is it reasonable to conclude from the synopses that the leading * in my range example should pretty much always be 0?

[19:14] <pmichaud> pj:  I think you go a little farther than I do, there.  :-)  I don't necessarily assume a hypothetical perfect Perl 6; but I do know that over the past N years we've improved our understanding of the language such that its more expressive, more powerful, has fewer inconsistencies, etc.  :-)

[19:15] <pmurias> TimToady: re All public method calls are "virtual" in the C++ sense. More surprisingly, any class name mentioned in a method is also considered virtual, that is, polymorphic on the actual type of the object." What does the virtual class name part mean?

[19:16] <PerlJam> PhatEddy: it should be the index of the first element in the array perhaps.  I don't know that I can say it will always be 0  :)

[19:17] *** ejs left
[19:18] <pmurias> TimToady: does the class name get refer to subclasses in a subclassed method?

[19:18] <TimToady> yes

[19:18] <PhatEddy> If I do "my @a; @a[2] = 'b'; say @a[ * .. 2 ]" is "*" 2 or 0?

[19:19] <PhatEddy> s/is/should be/

[19:19] <pmichaud> It's -Inf  :-)

[19:20] <PhatEddy> No according to S09 in reference to range slices ...

[19:21] <pmichaud> the fact that the beginning of the range is -Inf may cause postcircumfix:<[ ]>  to start at zero

[19:21] <pmichaud> such that the result of   @a[*..2]   is the same as  @a[0..2]

[19:21] <pmichaud> but the * itself doesn't change.

[19:22] <pmichaud> i.e., it's neither 2 nor 0.  The range is *..2, and postcircumfix:<[ ]>  treats that range as being the same as 0..2

[19:22] <TimToady> pmurias: see A12 at about line 4074, "In Classes" for an explanation of virtual classes

[19:23] *** ejs joined
[19:24] <skids> what's the plan for "is also" --> "is enhanced" as far as the test suite goes, once rakudo goes that way?

[19:24] <pmichaud> I think it's   "augment" now, isn't it?

[19:25] <skids> Oh maybe, sorry.

[19:25] * PerlJam read "is enhanced" as "is enchanted" for some reason.

[19:25] <pmichaud> moritz++ already has some patches to the test suite to switch "is also" to "augment", but I don't know how quickly Rakudo will be able to make that switch.

[19:25] <skids> Mainly will someone patch up pugs, or do we just break the test for it?

[19:26] <pmichaud> we can fudge the tests for pugs :-)

[19:26] <PhatEddy> pmichaud: The star is currently implemented as a whatever object.  If you do something like "@a[ *..2, *-1]" I am not sure how to get the current implementation to see whatever as both 0 and 3.

[19:27] <pmichaud> the current implementation is wrong.

[19:27] <pmichaud> the current implementation was done before the current definition of Whatever handling was in place.

[19:27] <pmichaud> i.e., the spec changed somewhat after we implemented * in subscripts.

[19:28] <pmurias> where can I find the apocalypses in pod form?

[19:28] <pmichaud> pmurias:   http://svn.perl.org/perl6/doc/trunk/design/apo, I think

[19:31] <pmichaud> PhatEddy: in particular, currently Rakudo's implementation "thunks" the expression inside of the brackets so that the whatever * can be evaluated lazily.  That's no longer consistent with the spec.  Instead what will happen is that the postcircumfix:<[ ]> operator will need to look at the types of its arguments and dispatch accordingly

[19:31] <pmichaud> so  @a[ *..2, *-1 ]   would end up calling postcircumfix:<[ ]>  with a List

[19:32] <pmichaud> postcircumfix:<[ ]>  would then need to go over the elements of that List, producing slices as it goes

[19:32] <pmichaud> in this case the List contains a Range and a closure

[19:32] <pmichaud> the Range is *..2

[19:32] <pmichaud> the closure is effectively   { $^whatever - 1 }

[19:33] <pmichaud> the closure would be produced by  infix:<->

[19:33] <PhatEddy> It more or less does that now.  I have a patch that makes it DTRT in array slice context but may not be right for @a = 5 .. * type ranges.

[19:34] <pmichaud> unless you've changed it substantially, there's a fairly significant difference between what I just described and what Rakudo currently does.

[19:34] <pmichaud> what rakudo currently does is to thunk the expression inside the brackets

[19:35] <pmichaud> so that  @a[ *..2, *-1 ]  ends up looking like   @a[ { *..-2, *-1 } ]

[19:35] <pmichaud> and then postcircumfix:<[ ]>  sets the value of * to the number of elements in the array, and call the closure.

[19:35] <pmichaud> which, as you noted earlier, causes problems with seeing the * as both 0 and 3.

[19:36] <PerlJam> I don't think it even does the thunking currently.  I'm looking at Positional's postcircumfix:<[ ]> and it looks like it just builds a list with special handling for Whatever.

[19:36] <pmichaud> PerlJam:  it's a multi

[19:36] <pmichaud> .sub 'postcircumfix:[ ]' :multi(_, 'Sub')

[19:37] <pmichaud> the 'Sub' form handles the case of when it receives a thunked closure.

[19:37] <PerlJam> aye, I see that now

[19:38] <pmichaud> I have to pick up Matthew from school... bbiab

[19:39] * PerlJam makes a mental note for the future ... when searching for a sub, don't stop at the first one you come across that has the name you're looking for   :)

[19:44] *** sri_kraih left
[19:46] <jrockway> TimToady: thanks for the explanation

[19:47] <jrockway> upon further reflection, it makes sense

[19:47] <jrockway> i always think of perl6 as a path, rather than a destination

[19:47] <jrockway> but... rakudo is actually the destination

[19:47] <jrockway> clearly you should rename perl6 to rakudou ;)

[19:48] *** LylePerl left
[19:49] *** davidad left
[19:50] <TimToady> actually, now Perl 6 itself should be 蝶蝶道, chouchoudou

[19:51] <jrockway> heh

[19:52] <TimToady> or maybe just 蝶道, if you're Chinese

[19:52] <jnthn> oh hai I'm back

[19:53] <TimToady> I like that the character for butterfly breaks down into "bug" and "leaf" radicals

[19:54] <TimToady> actually, more like "flat" than "leaf"

[19:55] <TimToady> "leaf" adds the "plants" radical

[19:56] <pugs_svn> r26159 | pmurias++ | [re-smop]

[19:56] <pugs_svn> r26159 | pmurias++ | added exists and lookup_key to S1P::Hash

[19:56] <pugs_svn> r26159 | pmurias++ | moved the utility hash from capture to util

[19:59] <TimToady> I think the original meaning of 枼 was a perhaps circular flat piece of wood, that is, a piece of wood in the shape of the world (presumably thinking of the world as a disk)

[20:00] <TimToady> std: $枼 = "world wood";

[20:00] <p6eval> std 26159: OUTPUT«Potential difficulties:␤  Variable $枼 is not predeclared at /tmp/ZhN99pKghn line 1:␤------> $枼 = "world wood";␤ok 00:05 41m␤»

[20:01] <TimToady> std: constant 枼 = "world wood";

[20:01] <p6eval> std 26159: OUTPUT«ok 00:04 35m␤»

[20:04] *** iblechbot joined
[20:05] *** M_o_C joined
[20:05] <TimToady> std: class 枼 {...}; constant 枼 = "world wood";

[20:05] <p6eval> std 26159: OUTPUT«##### PARSE FAILED #####␤Malformed constant at /tmp/FH6fNZnQtB line 1:␤------> class 枼 {...}; constant 枼 = "world wood";␤    expecting any of:␤    multi_declarator␤ typename␤FAILED 00:02 35m␤»

[20:08] <pugs_svn> r26160 | hinrik++ | [util/perl6.vim] 'self' should look like a variable, not a function

[20:11] <jrockway> std: constant 2 = 3; 2 + 2

[20:11] <p6eval> std 26160: OUTPUT«##### PARSE FAILED #####␤Malformed constant at /tmp/GlXnKEzKGD line 1:␤------> constant 2 = 3; 2 + 2␤    expecting scoped declarator␤FAILED 00:02 34m␤»

[20:11] <pugs_svn> r26161 | jnthn++ | [t/spec] Couple of tests for postcircumfix:<[ ]> on ranges.

[20:14] <pmichaud> I think tonight I'll refactor postcircumfix:<[ ]>  so that it doesn't thunk its arguments.

[20:15] <pmichaud> We'd get a good speed win out of that 

[20:15] <pmichaud> and yes, I know to be wary of Postcircumfix[::T]  :-)

[20:15] <pmichaud> er, Positional[::T]

[20:16] *** xinming joined
[20:16] <pmichaud> jnthn:  is  "Positional[::T]"  simply "the Positional role that can be parameterized"?

[20:16] <pmichaud> (as in the get_hll_global symbol in Parrot)

[20:17] <jnthn> pmichaud: Yes

[20:17] <pmichaud> or are all Positionals now parameterized?

[20:17] <jnthn> pmichaud: They are.

[20:17] <pmichaud> i.e., is there still a  get_hll_global 'Positional'  ?

[20:17] <jnthn> pmichaud: Let me summarize a little for you - it's not so scary.

[20:18] <pmichaud> it doesn't look all that scary

[20:18] <jnthn> There *is* still a get_hll_global 'Positional'

[20:18] <pmichaud> but yes, a summary would be very helpful.

[20:18] <jnthn> However, you don't "do" it directly.

[20:18] <jnthn> Notice the call !TOPERL6ROLE

[20:18] <jnthn> This does all the "neat stuff"

[20:18] <pmichaud> TOPERL6ROLE is in ... actions.pm ?

[20:18] <jnthn> No, guts.pir I think.

[20:19] <pmichaud> (the call)

[20:19] <jnthn> actions.pm also calls it.

[20:19] <jnthn> wlel

[20:19] <pmichaud> okay.

[20:19] <jnthn> actions.pm emits code that calls it.

[20:19] <pmichaud> I assume all-caps things are in guts.pm

[20:19] <pmichaud> so when I ask "where is ..." I'm generally asking "where it's called from"  :-)

[20:19] <jnthn> Basically it constructs a Perl6Role object.

[20:19] <jnthn> Ah, OK.

[20:19] <jnthn> It's called IIRC from the loadinit of the role body.

[20:20] <jnthn> Anyway, it adds the role body as a parametric candidate.

[20:20] <pmichaud> I don't see a TOPERL6ROLE anywhere

[20:20] <jnthn> erm, yes

[20:20] <jnthn> sorry

[20:20] <jnthn> I was thinking of TOPERL6MULTISUB...

[20:21] <jnthn> It's "!ADDTOROLE"(block)

[20:21] <jnthn> And yes, in the loadinit.

[20:21] <jnthn> Anyway, in the loadinit (or the PIR equivalent in Positional) we call this.

[20:21] <jnthn> block is the Positional role body.

[20:22] <jnthn> We give it a signature too, since it's subject to the Perl 6 multi-dispatcher.

[20:22] <pugs_svn> r26162 | hinrik++ | [util/perl6.vim] some cleanup

[20:22] *** M_o_C left
[20:22] <jnthn> It creates, if it doesn't already exist, a Perl6Role representing and installs it in the NS as Positional

[20:22] <pmichaud> (side note:  would it have been better to use .const 'Sub' instead of get_hll_global '_positional_role_body' ?

[20:22] <jnthn> However, Positional itself is not a role as such.

[20:23] <jnthn> (reply: I copied what the generated code did, but did wonder why it didn't use that too.)

[20:23] <jnthn> Positional is probably best of think of as a "role factory"

[20:23] <pmichaud> well, from generated code we have a symbol

[20:23] <pmichaud> so it's a package lookup

[20:23] <pmichaud> are all non-parameterized roles essentially "role factories" ?

[20:23] <jnthn> er, best to think of

[20:24] <jnthn> All roles are parametric, yes.

[20:24] <jnthn> Some of them might have a (potentially single) variant that takes no explicit parameters.

[20:24] <jnthn> And nothing more.

[20:24] <pmichaud> ahhhhh

[20:24] <pmichaud> because it's in the declaration of the role

[20:25] <pmichaud> thus    role Foo[::T] { ... }    is like a role factory

[20:25] <jnthn> However, we can't know that we won't end up with more candidates imported later.

[20:25] <pmichaud> and role Bar { ... }   is a role factory but with no args?

[20:25] <jnthn> Yes

[20:25] <pmichaud> okay.

[20:25] <jnthn> Well, strictly speaking

[20:25] <jnthn> role Foo[::T] { ... }; role Foo { };

[20:25] <jnthn> Those both are "role factories" in some sense.

[20:26] <pmichaud> right

[20:26] <pmichaud> I actually kinda get it.

[20:26] <jnthn> However, the second of them will only ever produce a single role.

[20:26] <pmichaud> okay, two questions (to save you a bit of time now)

[20:26] <pmichaud> (1)  are you covering this at all at NPW in your talks?

[20:26] <jnthn> Note that there is a bunch of stuff done such that a given parameterization of a role only ever produces a single Parrot-level role.

[20:26] <pmichaud> (2)  does any postcircumfix handling take place outside of what is currently in Positional.pir ?

[20:27] <pmichaud> (possibly Range.pir has some.)

[20:27] *** FurnaceBoy joined
[20:27] <jnthn> (1) Yes, at some level. I want to fix type-checking on slurpy arrays, and then I can run an example like: role Table[@column_types] { method insert(*@args where { $_ >>~~<< @column_types) { ... } }

[20:28] <jnthn> (Table type that checks types of paramters passed on inserts etc)

[20:28] <jnthn> (2) Yes, but only from a very recent patch. See postcircumfix:[ ] in Range.pir.

[20:28] <pmichaud> okay.

[20:29] <pmichaud> here's my quick takeaway

[20:29] <pmichaud> (a)  I can pretty safely work on postcircumfix: refactors without interfering with your roles work. 

[20:29] <jnthn> I am half way into a patch making * + 1 etc make a block, BTW - just in case that was on your hit list too.

[20:29] <pmichaud> you can put that in also... but we've also got to fix the calling side in actions.pir

[20:29] <pmichaud> and I'm thinking of also hitting the autovivify issues as well.

[20:29] <jnthn> OK, that'd be cool.

[20:30] <jnthn> Thing to be aware of.

[20:30] <pmichaud> it all kinda hangs together.

[20:30] <pugs_svn> r26163 | hinrik++ | [util/perl6.vim] some changes to function highlighting

[20:30] <jnthn> Note in postcircumfix:[ ]

[20:30] <jnthn> In Positional.pir

[20:30] <pmichaud> (b)  the rest of the stuff I'd like to know about parametric role handling I can probably get from your talk

[20:30] <jnthn> It finds the type object.

[20:30] <jnthn> (the find_lex "T")

[20:31] <pmichaud> yes, I see.

[20:31] <jnthn> The positioning of where we set types on things was kinda subtly done but I believe correct.

[20:31] <jnthn> But feel free to do it righter. ;-)

[20:31] <pmichaud> it initializes undefs to the protoobject

[20:31] *** FurnaceBoy left
[20:31] <jnthn> And sets the type property.

[20:31] <pmichaud> that's what I was expecting, yes.

[20:31] <jnthn> Then assignment type checks.

[20:31] <jnthn> The key thing is that I only do it on undefs.

[20:31] <jnthn> I don't know how your auto-viv plans hit that.

[20:32] <jnthn> But if you understand how it works, then that's fine. Also, there is some test coverage.

[20:32] <pmichaud> undefs will become Proxy objects, but they'll have the type property on them.

[20:32] <jnthn> On (a) - parametric roles themselves are - at least I like to think - fairly stable.

[20:32] <pmichaud> yes, what I've seen thus far looks really good on the design end.

[20:32] <jnthn> Yes, there'll be tweaks, optimizations, I think the way that you do a particular version of a role (calling !select) will have to change.

[20:33] <pmichaud> I may want to refactor the codegen in actions.pir, but the basic design looks really good to me.

[20:33] <jnthn> The design is - we piggy-back everything off multiple dispatch and lexicals. ;-)

[20:33] <pmichaud> amd tjat

[20:33] <pmichaud> oops

[20:33] <PhatEddy> If you work on array autovivification you may want to look at rt 62948 - if nothing else you may supersede the patch and be able to close it ... (http://rt.perl.org/rt3/Public/Bug/Display.html?id=62948)

[20:33] <pmichaud> and that's what I like about it this design :-)

[20:34] <pmichaud> PhatEddy: yes, that's one of the reasons why it's on my hit list.  And I'm thinking it'll be better to have it fixed before NPW.

[20:34] <jnthn> Yes, the moment I had the realization that we really could make it hang together pretty much just off those two was a happy one.

[20:34] <pmichaud> and that I can whip it out in an evening or so.  I've been thinking about the issue and mulling implementation items in my head for the past couple of weeks.

[20:34] <pmichaud> anytime we can implement things with multi dispatch and lexicals I feel it's fundamentally the right answer.

[20:35] <pmichaud> anytime we have to attach properties on things or use flags of some sort I think we're missing the underlying design.

[20:35] <pmichaud> (or squirrel things away in odd symbols)

[20:36] <jnthn> Aye. Sometimes it takes time to realize such a design though.

[20:36] <jnthn> Anyway, I'm happy that you're happy with the parametric role stuff.

[20:37] <pmichaud> very.

[20:37] <jnthn> On this whatever block patch - if I find that it handling *-1 does funny things relating to postcircumfix:[ ], do you want me to just omit that from the list of things it fixes up?

[20:37] <pmichaud> I can guarantee it's going to do funny things with the existing actions.pm implementation.

[20:37] <jnthn> And let you know, rather than fixing it up myself in postcircumfix:[ ]?

[20:37] <jnthn> OK

[20:38] <pmichaud> I guess I'm suggesting that you might be saved a few headaches, since I know where the roadbumps are already.

[20:39] <jnthn> OK. 

[20:39] <jnthn> I'll omit infix:<->

[20:39] <pmichaud> that will work.

[20:45] <pmichaud> what happens with   @a[* / 2 + 1]   ?

[20:46] <pmichaud> istr that we also speculated the handling of closures with math ops... but that's not specced

[20:48] <jnthn> Eww

[20:48] <jnthn> That'll be nasty.

[20:48] <jnthn> By precedence you'll end up doing a dispatch on * / 2 which will then give you a Block, at which point you'll try Block + 1

[20:48] <pmichaud> right

[20:48] *** ejs left
[20:48] <pmichaud> that's the case that caused me to take rakudo's current approach to things :-)

[20:48] <jnthn> rakudo: say { $_ * 2 } + 1

[20:48] <pmichaud> maybe we don't support that case :-0

[20:48] <p6eval> rakudo 07ed75: OUTPUT«get_number() not implemented in class 'Sub'␤current instr.: 'infix:+' pc 22429 (src/builtins/op.pir:284)␤»

[20:49] <jnthn> A non-silent error.

[20:49] <[particle]-> @a[*.ides]

[20:49] <lambdabot> Unknown command, try @list

[20:52] *** rindolf left
[20:53] *** brunov left
[20:58] <jnthn> > my $x = * * 2; say $x(4);

[20:59] <jnthn> 8

[20:59] <lambdabot>   <no location info>: parse error on input `='

[20:59] <jnthn> .oO( that one looks funny... )

[20:59] <jnthn> std: my $x = * * 2; say $x(4);

[20:59] <p6eval> std 26163: OUTPUT«ok 00:02 35m␤»

[20:59] <jnthn> :-)

[21:02] <jnthn> pmichaud: spectesting now, if it works I'll put it in. infix:<-> omitted.

[21:02] <pmichaud> jnthn:  there's   .sub 'postcircumfix:[ ]' :multi(_, 'Sub')

[21:02] <pmichaud> oops

[21:02] <pmichaud> wrong paste

[21:02] <[particle]-> this is going to be hell for folks creating prefix:<*> operators

[21:02] <pmichaud> http://irclog.perlgeek.de/perl6/2009-02-27#i_942578

[21:02] <[particle]-> or postfix, for that matter.

[21:04] <jnthn> pmichaud: Is this the thingy that became lift?

[21:05] <jnthn> pmichaud: Oh, are you meajing the

[21:05] <jnthn> multi infix:<eq> (&f:($), Any $b)       { -> $a { meta f($a) eq $b } }  # user's eq

[21:05] <pmichaud> yes.

[21:05] <pmichaud> I'm okay if we leave that unimplemented for now.

[21:05] <jnthn> Me too... ;-)

[21:05] <pmichaud> I'm primarily interested in only the * - $x  case

[21:05] <jnthn> Hmm

[21:06] <jnthn> I wonder if this means the multi-dispatcher has to worry about the sub-signature.

[21:06] <jnthn> Or if we treat bindability to thatt as a tie-breaker.

[21:06] <jnthn> (Also, we don't support sub-sigs yet.)

[21:07] <jnthn> (Though we could cheat since we know what's code.)

[21:10] <pmichaud> oh,  with    my $x = 3..*;   say ?($x.to ~~ Inf);    #  true or false ?

[21:11] <jnthn> Off the top of my head without a spec reference, I think true.

[21:11] <pmichaud> i.e., does the Range .to return a Whatever or Inf ?

[21:11] <jnthn> I think inf.

[21:11] <pmichaud> okay.

[21:11] *** bacek joined
[21:11] <jnthn> infix:<..>(Whatever, Any) and infix:<..>(Any, Whatever) are defined (sure I read that before)

[21:11] <pmichaud> we can do it that way until we're told not to.   :-)

[21:11] <pmichaud> yes, they're defined.

[21:11] <pmichaud> I'm just wondering what they store :-)

[21:12] <jnthn> I figured the purpose of their existence is that they can stick and infinity there.

[21:12] <jnthn> Rather than the Whatever, which we'd get stuck in there if they didn't exist.

[21:12] <pmichaud> yes, but I wonder if there's a distinction to be made between   0..* and  0..Inf   in some contexts.

[21:13] <pmichaud> like, maybe,   postcircumfix:<{ }>

[21:13] <pmichaud> %h{0..*}   might be different from   %h{0..Inf}   :-)

[21:13] <jnthn> I see your point...

[21:13] <pmichaud> anyway, it's just idle curiosity on my part.

[21:13] <jnthn> Would you really want in infinitely big slice? ;-)

[21:14] <skids> maybe shaped arrays?

[21:14] <jnthn> Of the various things I could see being lazy, taking of slices hadn't been one of 'em.

[21:15] <skids> I seem to recall someone at sometime inferring they were.

[21:15] <jnthn> meh. Now I haz to re-start my spectest run because I forgot to re-bless the Parrot sub into a Perl 6 Block.

[21:15] <skids> Damned if I can remember who or when.

[21:17] <jnthn> pmichaud: BTW, while you're working on postcircumfix, you could also handle junctions in slices. I pondered in the shower this morning that it may not be so hard - just spot them and re-call postcircumfix:<[ ]> through the junction dispatcher on that element.

[21:18] <jnthn> and incorporate what comes back into the resultant slice.

[21:18] <pmichaud> it'll likely just be   postcircumfix:<[ ]>(Junction)

[21:18] <pmichaud> (so, yes, no problem)

[21:19] <jnthn> yeahbut I'm thinking of like @a[1, 2|3, 4] where only one bit of the slice is junctional.

[21:19] <jnthn> Anyway, shouldn't be too bad.

[21:19] <pmichaud> well, I'm thinking that the postcircumfix:<[ ]>(List)  case decomposes down into smaller postcircumfix calls.

[21:19] <bacek> good morning

[21:20] <pmichaud> in particular, I don't think that overriding postcircumfix:<[ ]>  for any given class should require all of the multi versions

[21:20] <bacek> +~2k passed tests in one day! What happened???

[21:20] <pmichaud> i.e., the basic version is postcircumfix:<[ ]>(Int), and the others resolve down to that somehow.

[21:21] <jnthn> bacek: pmichaud happened

[21:21] <skids> http://perlcabal.org/syn/S09.html#line_866

[21:21] <bacek> jnthn: :)

[21:21] <jnthn> pmichaud: Giving Parrot's calling speed, multiple calls to postcircumfix:<[ ]> doesn't inspire me too much on performance...

[21:21] <skids> hrm map {...} <== @a[1..5,4|3,1..*]

[21:21] <pmichaud> jnthn: we can optimize some cases down, yes.

[21:22] <pmichaud> but we're already doing multiple calls to postcircumfix:<[ ]>

[21:23] <pmichaud> in fact, we're even doing it for the simple case of   @a[3]

[21:23] <pmichaud> which is why I think fixing this up may get us an important Speed Win

[21:23] <pmichaud> (because we can avoid that)

[21:24] <pmichaud> by far the most common cases are likely to be single element access, list slices, and range slices.  We can make those fast.

[21:24] <pmichaud> I was very concerned when I started thunking the arguments to postcircumfix:<[ ]> about our performance, but it didn't turn out to be as bad as I had feared.

[21:27] <jnthn> Yeah

[21:27] <jnthn> We shouldn't worry *too* much about performance just yet.

[21:27] <jnthn> But there has been an increase in comments on such things of late.

[21:28] <[particle]-> the people need to complain about something

[21:28] <[particle]-> if you focus on performance, they'll complain about missing features

[21:29] <jnthn> [particle]-: Oh, of course. ;-)

[21:29] <jnthn> And if you focus on features they complain about rising number of bugs. ;-)

[21:29] <jnthn> Hard balance. :-)

[21:30] <[particle]-> yep, then throw time to delivery into the equation...

[21:30] <jnthn> We Don't Talk About Time To Delivery.

[21:30] <jnthn> :-P

[21:30] <pmichaud> we _really_ are getting to the point where we need a good profiler for parrot, though.

[21:30] <[particle]-> yes, we certainly are.

[21:30] <jnthn> yeah, I know.

[21:30] <[particle]-> we have some really bad profilers

[21:30] <[particle]-> they're just not working

[21:31] <pmichaud> I fear that the decreases in performance aren't mostly PGE-related.

[21:31] <jnthn> I was kinda hoping some profiler wizz would appear and write one.

[21:31] <pmichaud> i.e., I can work on improving parsing speed, but I think our runtime speed is starting to suffer.

[21:31] <jnthn> pmichaud: For sure it is.

[21:31] *** Tene_ is now known as Tene

[21:31] <pmichaud> OTOH, I think allison expects to have new calling conventions stuff in place shortly after 1.1 release

[21:31] <pmichaud> she indicated that the conversion had gone surprisingly well.

[21:31] <jnthn> pmichaud: Consider how many actual Parrot calls we currently do in class A { method m($x) { } }; A.new.m(42)

[21:32] <pmichaud> oh, and also, it looks like we will indeed get a :capture flag

[21:32] <jnthn> And I mean runtime, not initialization.

[21:32] <pmichaud> which means we just get the arguments without parrot doing any unpacking, and we unpack ourselves.

[21:32] <[particle]-> pmichaud: it's just a piece of the conversion done so far, though

[21:33] <pmichaud> [particle]: yes, perhaps I'm naively optimistic again.

[21:33] <[particle]-> well, you're free to try her branch, if things actually compile there

[21:33] <[particle]-> there are no api changes

[21:33] <pmichaud> I'll wait until the merge

[21:33] <pmichaud> I have plenty else to keep me occupied :-)

[21:34] <[particle]-> that's probably good, you can stay naively optimistic that way, too

[21:34] <pmichaud> Right.  And at NPW I can say "allison will be speeding up Parrot calling conventions in a couple of weeks"  rather than "I tried out the calling conventions branch and we're in for big trouble.  :-P"

[21:35] <[particle]-> marketing++

[21:35] <pmichaud> (plausible deniability)++

[21:35] *** LylePerl joined
[21:36] <skids> first make it work, then make it work well, then make it work fast, then drive it off a cliff.

[21:44] <jnthn> Dobre...moj patch funguje!

[21:44] *** Util joined
[21:44] <jnthn> oh language choice fail

[21:45] <jnthn> Perl, PIR and English would be enough...

[21:45] <skids> lolcat!

[21:45] <skids> dont forgetz

[21:46] <jnthn> oh noes do not want for brainaches!

[21:47] <jnthn> *more

[21:47] <jnthn> oh geck, now look what I've gone and done...

[21:47] <jnthn> ...OK, nobody watch the bot output to see how well I failed in comitting this patch...

[21:47] <pmichaud> kick the bot, quick!  :-)

[21:47] <[particle]->  /kick dalek

[21:48] * pmichaud prepares for the horror

[21:48] * [particle]- smiles preemptively

[21:48] <jnthn> pmichaud: Heh, the commit message is only the start of it, then there's the patch itself. ;-)

[21:48] <jnthn> At least it is done in terms of lexicals. ;-)

[21:49] <jnthn> pmichaud: y'know, the most evil thing about putting properties on subs, is we gotta be all careful over clones losing them...

[21:49] <pmichaud> I'm open for other suggestions.

[21:49] <jnthn> I ain't got any just yet. :-(

[21:49] <pmichaud> I'm also open for having Subs clone their properties.

[21:49] <jnthn> Other than when we do get HLL Map

[21:49] <jnthn> Well

[21:49] <pmichaud> (or at least clone the property reference)

[21:50] <jnthn> Some properties we *want* them to lose.

[21:50] <jnthn> Example: the property where we stash state variable state between invocations.

[21:50] <dalek> rakudo: 5658a57 | jnthn++ | build/ (2 files):

[21:50] <dalek> rakudo: Implement * mathop val and val mathop * generating blocks. Left out infix:<-> for now.

[21:50] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5658a570660e385cc6cd2bb609a2918544bffb7e

[21:50] <dalek> rakudo: 4a95115 | jnthn++ | perl6.pir:

[21:50] <dalek> rakudo: Oops, forgot this file too. Epic git usage fail...

[21:50] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4a9511518f3911f9fd2b021d681594c4b46e6df8

[21:50] <jnthn> Oh good dalek

[21:50] <pmichaud> well, that's part of the reason why I wasn't keen on using properties for state variables.  :-)

[21:51] <jnthn> pmichaud: Yeah but the point is that we *want* to lose them on a clone because That's The Spec. :-)

[21:51] <pmichaud> right

[21:51] <jnthn> (BTW I managed to run two commits with the first message...)

[21:51] <bacek> jnthn: you can use "git rebase --interactive HEAD~2" to merge two commits in one. (But don't try is after git push)

[21:51] <pmichaud> if they weren't properties, we wouldn't have a problem with needing to lose them.

[21:51] <jnthn> (But dalek was kind enough to only show one of them)

[21:51] <jnthn> pmichaud: I don't follow.

[21:51] *** pmurias left
[21:51] <pmichaud> right now state variables are being attached as properties on subs

[21:52] <PerlJam> pmichaud: if they weren't properties, where would you store them?

[21:52] <jnthn> The current properties semantics give us exactly what we want for state vars.

[21:52] <jnthn> pmichaud: I'm thinking more than we may - when we can have our own Sub PMC, subclass Parrot's sub and have an extra attribute in there for $!signature

[21:52] <pmichaud> why is using a property for a state variable an advantage?

[21:53] <jnthn> Because when you clone a block it's properties are lost.

[21:53] <jnthn> Also, because then the state is attached to the block.

[21:53] <jnthn> Which means as closures are GC'd the state gets neatly GC'd with it.

[21:53] <pmichaud> okay, I'll buy that.

[21:53] <jnthn> Which would be much harder if you stuck globals beneath them.

[21:54] <jnthn> At least, I couldn't see a neat way...

[21:54] <pmichaud> anyway, yes, when we have our own Sub PMCs this becomes quite a bit easier

[21:54] <pmichaud> fwiw, I don't see why we can't have our own Sub PMC class now.

[21:54] <jnthn> We kinda could but...

[21:54] <pmichaud> we already have rebless available, yes?

[21:54] <jnthn> Yeah.

[21:54] <jnthn> I'm lazily waiting for .HLL to be done

[21:55] <pmichaud> .HLL will help?

[21:55] <jnthn> Yeah, then we'll just have the right PMC created int he first place.

[21:55] <jnthn> (.HLL_map)

[21:55] <pmichaud> will it help even though we got rid of .HLL_map ?  Or are we planning to use :immediate for that ?

[21:55] <jnthn> WE...got rid of HLL_map?

[21:55] <pmichaud> yes, I think so.

[21:55] <jnthn> The syntax or the functionality overall?

[21:55] <pmichaud> the syntax.

[21:55] <jnthn> Ah, OK

[21:55] <pmichaud> the compile-time syntax, that is.

[21:55] <jnthn> Whatever the new syntax is.

[21:55] <jnthn> Ah.

[21:56] <jnthn> Geck.

[21:56] <pmichaud> I think all that is left is the runtime syntax.

[21:56] <jnthn> Oh well. :-)

[21:56] <jnthn> Anyway, that's tidy-ups for later.

[21:56] <pmichaud> I'm not so sure that getting rid of .HLL_map was a good thing to do :-|

[21:56] <jnthn> I wasn't even aware if was gone.

[21:56] <jnthn> *it

[21:56] <pmichaud> but can't the Perl6Sub PMC install itself as the mapping?

[21:56] <jnthn> I'm not sure.

[21:56] <jnthn> I didn't think it could...

[21:57] <jnthn> I think my last attempt got bogged down in the Closure vs Sub PMC stuff.

[21:57] <pmichaud> I know there's a hll_map directive im pmclass (or, at least istr there was one)

[21:57] <pmichaud> But since there's no more Closure PMC ... :-)

[21:57] <jnthn> That was a compile time thing.

[21:57] <jnthn> So yeah, dunno if it's still there.

[21:57] <pmichaud> sure, it's a compile-time thing, which is what we want in this case.

[21:57] <jnthn> Agree.

[21:57] *** brunov joined
[21:57] <pmichaud> I'm also thinking we may regret not having .HLL_map for namespace mapping.

[21:58] <jnthn> I didn't think too much about that one yet.

[21:58] <jnthn> In time, namespaces are probably going to become less important for us.

[21:59] <jnthn> Given that in the future we're gonna need to make a bunch of stuff that is in the namespace now lexical instead.

[21:59] <pmichaud> well, we still need them (e.g. for 'our' stuff).  But yes, they'll be much less prominent.

[21:59] <jnthn> rakudo: my $a of Str; $a = 42;

[21:59] <p6eval> rakudo 07ed75:  ( no output )

[21:59] <pmichaud> https://trac.parrot.org/parrot/ticket/314  # deprecation and removal of .HLL_map

[21:59] <jnthn> std: my $a of Str; $a = 42;

[22:00] <pmichaud> alas, I voted +1 for it, too.

[22:00] <p6eval> std 26163: OUTPUT«ok 00:02 35m␤»

[22:01] <pmichaud> pmichaud--   # Once again you have paid the price for your lack of vision.

[22:01] *** iblechbot left
[22:01] <jnthn> rakudo: say map * + 2, 1,2,3;

[22:01] <p6eval> rakudo 07ed75: OUTPUT«sh: ./perl6: No such file or directory␤»

[22:01] <jnthn> oooh...'tis the hour of da rebuild

[22:02] <jnthn> rakudo: say map * + 2, 1,2,3;

[22:02] <p6eval> rakudo 07ed75: OUTPUT«sh: ./perl6: No such file or directory␤»

[22:02] * PerlJam marks down "spectacles" as a possible xmas or birthday present for pmichaud 

[22:02] <jnthn> pmichaud: I think at the time we were finding we needed to be a lot more dynamic...

[22:03] <jnthn> std: say map *.abs, 1,-2,3,-4;

[22:03] <p6eval> std 26163: OUTPUT«ok 00:02 38m␤»

[22:03] <jnthn> how does'th thou parse it?

[22:04] <pmichaud> it's just .abs on the whatever term :-)

[22:05] <jnthn> Likewise, the single dispatcher recognizes C<*.meth> and returns C<{ $_.meth }>,

[22:05] <jnthn> so it can be used where patterns are expected:

[22:05] <jnthn> @primes = grep *.prime, 2..*;

[22:05] <lambdabot> Unknown command, try @list

[22:05] <jnthn> Ah

[22:05] <jnthn> Goes in .^dispatch I guess

[22:06] <pmichaud> yes.

[22:06] <jnthn> rakudo: say map * + 2, 1,2,3;

[22:06] <p6eval> rakudo 4a9511: OUTPUT«345␤»

[22:06] <jnthn> w00t!

[22:06] <pmichaud> jnthn++

[22:06] <pmichaud>         $P0 = get_hll_global "$_"   #   ugh!

[22:06] <jnthn> OK, now I feel like I actually achieved something today...

[22:06] <jnthn> ?

[22:06] <jnthn> oh, that Perl script is horrbilus.

[22:07] <pmichaud> why the set_outer ?

[22:07] <jnthn> (Note that $_ becomes the name like infix:== in the ouput!)

[22:08] <jnthn> pmichaud: Because the helper uses lexical lookup for the op.

[22:08] <jnthn> We can't know the outer beforehand.

[22:08] <jnthn> well, it could be one of many things

[22:08] <jnthn> thus why we clone and then set_outer

[22:08] <pmichaud> why not just do something like .assuming ?

[22:09] <jnthn> We do do something like assuming.

[22:09] <jnthn> However, assuming has the luxury of there being a helper used for *one* sub.

[22:09] <jnthn> So it can statically have :outer('assuming')

[22:09] <jnthn> Note we don't generate one helper sub per operator.

[22:10] <pmichaud> yes, I understand that.

[22:10] <jnthn> I was thinking of assuming when I wrote this...

[22:10] <pmichaud> it just looks like the long-way-around to get assuming to me.

[22:10] <jnthn> Then realized it wouldn't be quite as neat.

[22:10] <jnthn> What would you change?

[22:11] <jnthn> You can't statically set the outer because you don't know what it is (unless we want to generate a bunch more code, which feels like a bad thing).

[22:11] <jnthn> You can set the outer until you've cloned it.

[22:11] <jnthn> And you can't capture the lexical scope until you've done both

[22:11] <pmichaud> but you can call something that is statically the outer

[22:11] <pmichaud> and I think you don't need the whatever helper left and whatever helper right

[22:12] <jnthn> ...statically the outer?

[22:13] <pmichaud> you call a given function

[22:13] * jnthn is starting to wish he'd just slipped it in with properties instead now...

[22:13] <pmichaud> pass it the params you're wanting

[22:13] <PerlJam> jnthn: is there a reason you left out infix:-  ?  :-)

[22:13] <pmichaud> PerlJam: because it'll epically break  @a[*-1]  right now.

[22:13] <pmichaud> oh, it might work, but at the cost of some serious extra indirection.

[22:13] <jnthn> Right.

[22:14] <jnthn> I was going for, low amount of generated code.

[22:14] <pmichaud> jnthn: so am I.

[22:14] <pmichaud> I think I can get lower than what you have :-)

[22:14] <pmichaud> anyway, it's harder to explain than to write (and see what's done), so I might take a crack at it later.

[22:15] <jnthn> Aye.

[22:15] <jnthn> I don't doubt you'll find a way to shorten it somehow...

[22:15] <jnthn> I just don't get what you're suggesting.

[22:16] <pmichaud> right -- I think you're too used to thinking in terms of explicitly doing .set_outer on things :-)

[22:16] <jnthn> What I've done is essentially equivalent to multi infix:<+>(Whatever, Any $y) { return { $^x + $y } }

[22:16] <jnthn> But without having to have code generated for all of the inner closures.

[22:17] <pmichaud> yes, I'm saying the same.

[22:17] <pmichaud> I'm explicitly *not* generating lots of code for each multi version.

[22:17] <pmichaud> indeed, each multi will end up with one or two lines of PIR

[22:17] <jnthn> With some additional helper sub called?

[22:17] <pmichaud> yes.

[22:17] <pmichaud> which will be statically defined/compiled.

[22:17] <jnthn> ah

[22:17] <pmichaud> and only one.

[22:18] <jnthn> Still think it's gonna be more indirection.

[22:18] <pmichaud> just like in Junction, where we have

[22:18] <jnthn> But I'll reserve judgement until I see it.

[22:18] <pmichaud>         .sub '$_' :multi('Junction', _)

[22:18] <pmichaud>             .param pmc x

[22:18] <pmichaud>             .param pmc y

[22:18] <pmichaud>             .tailcall '!DISPATCH_JUNCTION'('$_', x, y)

[22:18] <pmichaud>         .end

[22:18] <jnthn> Indeed. Another level of indirection.

[22:18] <jnthn> I was happily avoiding having one of those.

[22:19] <pmichaud> oh, you're wanting to avoid the tailcall

[22:19] <jnthn> Right.

[22:19] <jnthn> It's not a big win not to I guess.

[22:19] <pmichaud> at the cost of of adding a 'set_outer', though.

[22:19] <pmichaud> I think it's an even tradeoff.

[22:19] <jnthn> Very possibly, yes.

[22:20] <jnthn> Anyway, it's certainly not wroth spending a lot of time either way over, IMO.

[22:20] <pmichaud> and there's an extra tailcall when the closure gets invoked.

[22:20] <jnthn> (Also, I like that at the moment everything relating to this logic is in one file. guts.pir is huge.)

[22:20] <pmichaud> oh, I can leave it in the same file -- that's no problem.

[22:20] <jnthn> OK. :-)

[22:20] <pmichaud> see, for example, the way I did  gen_uprop

[22:21] <pmichaud> (the helper function is in gen_uprop, but only one shared by all of the instances)

[22:21] <jnthn> Yes

[22:22] <jnthn> You went for a dynop rather than waitng for the working out of Parrot's API? :-)

[22:22] <pmichaud> Yes.

[22:23] <pmichaud> Ultimately much easier than anything else I could come up with.

[22:23] <pmichaud> also, I'm now thinking it may be rakudo-specific-enough that it may remain a dynop.

[22:23] <jnthn> That's fair enough.

[22:23] <pmichaud> I'm not sure that PGE will want to implement all of the isFoo rules internally.

[22:24] <pmichaud> (it might show up in PCT, though.)

[22:25] <literal> rakudo: my @foo = 1,2,3; say @foo􏿽xAB*􏿽xBB42;

[22:25] <p6eval> rakudo 4a9511: OUTPUT«Statement not terminated properly at line 1, near "\ufffd*\ufffd42;"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[22:26] <jnthn> rakudo: my @foo = 1,2,3; say @foo<<*>>42;

[22:26] <p6eval> rakudo 4a9511: OUTPUT«Statement not terminated properly at line 1, near "42;"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[22:26] <jnthn> huh?

[22:26] <TimToady> two terms in a row 

[22:26] <jnthn> rakudo: my @foo = 1,2,3; say @foo <<*>> 42;

[22:26] <p6eval> rakudo 4a9511: OUTPUT«4284126␤»

[22:26] <PerlJam> whitespace is your friend.

[22:26] <pmichaud> @foo<<*>>  is a postcircumfix :-)

[22:26] <lambdabot> Unknown command, try @list

[22:26] <TimToady> std: my @foo = 1,2,3; say @foo«*»42;

[22:26] <jnthn> OH RLY?

[22:26] <p6eval> std 26163: OUTPUT«##### PARSE FAILED #####␤Syntax error (two terms in a row?) at /tmp/tT6k1FTPjE line 1:␤------> my @foo = 1,2,3; say @foo«*»42;␤    expecting any of:␤    POST␤   infix or meta-infix␤        infix stopper␤    postfix␤        postfix_prefix_meta_operator␤       standard

[22:26] <p6eval> ..stopper␤       statement modifie...

[22:27] *** PhatEddy left
[22:27] <TimToady> nya, nya, nya

[22:27] <jnthn> But...but...that makes them less useful for obsfucation!

[22:27] <TimToady> nya, nya, nya

[22:27] <pmichaud> Perl 6 giveth, and Perl 6 taketh away

[22:27] <PerlJam> it'll be awesome when rakudo gets all of those helpful hints from std  :)

[22:27] <jnthn> TimToady: For things like map *.prime @list

[22:28] <TimToady> std: map *.prime @list

[22:28] <jnthn> TimToady: Are you expecting map *.thing($arg, $arg) @list to also work?

[22:28] <p6eval> std 26163: OUTPUT«##### PARSE FAILED #####␤Syntax error (two terms in a row?) at /tmp/4HyLtpcQBK line 1:␤------> map *.prime @list␤    expecting any of:␤        infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤FAILED 00:02 35m␤»

[22:28] <jnthn> oh, needs comma

[22:28] <jnthn> std: map *.thing($arg, $arg), @list

[22:28] <p6eval> std 26163: OUTPUT«Potential difficulties:␤  Variable $arg is not predeclared at /tmp/5F3TuhV1wl line 1:␤------> map *.thing($arg, $arg), @list␤  Variable $arg is not predeclared at /tmp/5F3TuhV1wl line 1:␤------> map *.thing($arg, $arg), @list␤  Variable @list is not

[22:28] <p6eval> ..pr...

[22:28] <jnthn> std: my ($arg); map *.thing($arg, $arg), @list

[22:29] <p6eval> std 26163: OUTPUT«Potential difficulties:␤  Variable @list is not predeclared at /tmp/CRnwkhqVlq line 1:␤------> y ($arg); map *.thing($arg, $arg), @list␤ok 00:02 38m␤»

[22:29] <jnthn> yeah yeay

[22:29] <pmichaud> std:  map *.thing(1,2), <a b c>

[22:29] <p6eval> std 26163: OUTPUT«ok 00:02 36m␤»

[22:29] <jnthn> Neat

[22:29] <TimToady> I should have it say "Now you're talking sense..."

[22:30] <jnthn> It's easter. Have an egg.

[22:30] <TimToady> the yolk's on you

[22:31] *** frzntoz_ joined
[22:32] <TimToady> well, sigh, I forgot to run screen before I started irssi... :(

[22:32] *** TimToady left
[22:32] *** TimToady joined
[22:34] <Util> rakudo: my ($a,$b,$c,$d) = { foo => 1 } xx 4; say keys(   $a  ), keys( %($b) ), keys( % $c  ), keys(  %$d  );

[22:34] <p6eval> rakudo 4a9511: OUTPUT«Scope not found for PAST::Var '%$d' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[22:34] <Util> In Perl 5, you could dereference with `%{$href}`, or just plain `%$href`.

[22:34] <Util> S03 (Changes to Perl 5 operators, first bullet) says that `%{...}` becomes `%(...)`, but is not explicit about whether `%$href` should still work.

[22:34] <Util> Rakudo requires a space: `% $href`, but I cannot tell if this is a quirk of the current implementation.

[22:35] <TimToady> still works

[22:35] <Util> Should `%$href` still work in Perl 6, or must I add whitespace?

[22:35] <pmichaud> rakudo doesn't understand %$href yet

[22:35] <pmichaud> I have to refactor variable handling a bit for that.

[22:35] <TimToady> std: my ($a,$b,$c,$d) = { foo => 1 } xx 4; say keys(   $a  ), keys( %($b) ), keys( % $c  ), keys(  %$d  );

[22:35] <Util> Great, thanks!

[22:35] <p6eval> std 26163: OUTPUT«ok 00:03 38m␤»

[22:35] <TimToady> std: my ($a,$b,$c,$d) = { foo => 1 } xx 4; say keys(   $a  ), keys( %($b) ), keys( % $c  ), keys(  % $d  );

[22:35] <p6eval> std 26163: OUTPUT«ok 00:03 38m␤»

[22:35] <TimToady> hmm I didn't expect that one to work

[22:36] <TimToady> oh wait, it tests that earlier

[22:36] <Util> right, with $c

[22:36] <TimToady> I guess it works, but I'd never write it that way

[22:37] <Util> S03: Listop-like forms use the bare sigil following by whitespace.

[22:37] <TimToady> so it's in danger of being made illegal :)

[22:37] <pmichaud> the listop form is the one that rakudo currently implements

[22:38] <pmichaud> but I completely agree that it's a prime candidate for confusion

[22:38] <TimToady> arguable the %() form is also just the functional form, but...

[22:38] <Util> Making case $c fail is fine with me.

[22:39] <TimToady> and they all have named forms, except for maybe &()

[22:39] <Util> I am writing a tinker-toy 5->6 converter with PPI, and was looking for clarity w.r.t. S03.

[22:39] <TimToady> well, one more thing to (not) think about...

[22:40] *** frzntoz left
[22:40] <TimToady> anyway, yes, STD, uses %$foo all over the place

[22:40] <Util> Oh, wait... Case $c works in Perl5. Yuck.

[22:40] <TimToady> because it's easy to backtranslate to P5

[22:40] *** Limbic_Region joined
[22:41] <TimToady> yes, well, perl allows space in '$ foo'

[22:41] <TimToady> Perl 5

[22:41] <TimToady> in Perl 6 that'd be a foo() call

[22:42] <TimToady> std: $ foo

[22:42] <p6eval> std 26163: OUTPUT«Undeclared routine:␤   foo used at 1 ␤ok 00:02 35m␤»

[22:42] *** frzntoz_ left
[22:42] <TimToady> the fact that Perl 5 allows that space is one of the reasons Perl 6 doesn't.  :)

[22:43] <TimToady> and why @ $foo might be disallowed if I get mean enough

[22:45] <Util> PPI mis-parses the percent in `% $foo` as an Operator. It correctly parses as a Cast in `%$foo`. 

[22:45] <jnthn> rakudo: say (*).worreva

[22:45] <TimToady> well, that's why the existing p5-to-p6 translator is based off of MAD instead...

[22:46] <p6eval> rakudo 4a9511: OUTPUT«Could not locate a method 'worreva' to invoke on class 'Whatever'.␤current instr.: 'die' pc 16685 (src/builtins/control.pir:222)␤»

[22:46] *** frzntoz joined
[22:46] <jnthn> rakudo: say *.worreva

[22:46] <p6eval> rakudo 4a9511: OUTPUT«Statement not terminated properly at line 1, near ".worreva"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[22:46] *** frzntoz left
[22:46] <jnthn> pmichaud: Any clues why the parser might not be liking the second of those?

[22:47] <pmichaud> jnthn: it's parsing as infix:<*>

[22:47] <pmichaud> i.e., it's parsing as   (say) * (.worreva)

[22:47] <jnthn> Oh.

[22:47] <jnthn> That's unfortunate.

[22:47] <pmichaud> (that's a guess)

[22:47] <Util> Right, but when I poked at MAD last year, it quickly drove me mad.

[22:47] <pmichaud> rakudo:  say * 3

[22:47] <p6eval> rakudo 4a9511: OUTPUT«Statement not terminated properly at line 1, near "3"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[22:47] <pmichaud> oh, maybe not.

[22:47] <pmichaud> hrm.

[22:48] <pmichaud> rakudo:  say * .int

[22:48] <p6eval> rakudo 4a9511: OUTPUT«Statement not terminated properly at line 1, near ".int"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[22:48] <pmichaud> okay, that's not it.

[22:48] <Util> So this is low-hanging-fruit version. -Ofun

[22:49] <Util> Also, it will make me read every word of the specs.

[22:49] <TimToady> have the appropriate amount of fun

[22:49] <pmichaud> jnthn: it's because we have

[22:49] <jnthn> pmichaud: If it's helpful, it's dying in called from Sub 'parrot;Perl6;Grammar;eat_terminator

[22:49] <pmichaud> token expect_term { | <noun> <post>* {*}                         #= noun | '*' {*}                                    #= *

[22:50] <pmichaud> }

[22:50] <Util> Thanks, all!

[22:50] <pmichaud> i.e., for some reason '*' is being treated specially outside of <noun>

[22:50] <TimToady> should just be a term:

[22:51] <pmichaud> yes.

[22:51] *** shachaf joined
[22:52] <TimToady> commuting &

[22:54] * jnthn looks at the email of things NPW want

[22:54] <jnthn>  1) A list of 4-6 points (max 3-5 words each) of the main things you'd

[22:54] <jnthn>     like people to remember from your talk. 

[22:54] <jnthn> ...4-6 points from a 2 hour talk is tricky!

[22:55] <pmichaud> people won't remember more than 4-6 anyway :-)

[22:55] <jnthn> * Perl 6 rocks

[22:55] <jnthn> * Get it at www.rakudo.org

[22:55] <jnthn> * Buy Jonathan beer

[22:56] <jnthn> * Contribute!

[22:56] <jnthn> done

[22:56] <pmichaud> s/Contribute!/Write applications/

[22:56] <pmichaud> make it more specific how they can contribute :-)

[22:56] <jnthn> ...I wasn't being enitrely serious with that list... ;-)

[22:56] <jnthn> But maybe something like that is the way to go.

[22:56] <pmichaud> yes, I think so.

[22:56] <jnthn> I'm not sure I'll get away with the third though...

[22:57] <jnthn> OK, moved * to term...let's see how this fares in the tests.

[22:57] <pmichaud> don't forget to update actions.pm (I know youlikely didn't...)

[22:57] <jnthn> Akshually I did.

[22:58] <jnthn> nyah nay

[22:58] <jnthn> Sanity tests run. Here goes more make spectest...

[22:58] <jnthn> (This has the *.abs => { $_.abs } patch in too... :-))

[22:59] <pugs_svn> r26164 | hinrik++ | [util/perl6.vim] operator highlighting fixes

[23:01] <jnthn> pmichaud: While you're working on postcircumfix, here's another ticket you might want to be aware of if you ain't already: http://rt.perl.org/rt3/Ticket/Display.html?id=63986

[23:02] *** wknight8111 joined
[23:02] <pugs_svn> r26165 | hinrik++ | [util/perl6.vim] update TODO

[23:02] <pmichaud> okay, will do that.

[23:03] <pmichaud> ... we check specifically for '-1' ?

[23:03] <pmichaud> wow.  :-)

[23:03] *** nihiliad left
[23:04] <pmichaud> actually, we check specifically for '[-1]'  :-)

[23:04] <pmichaud> s/we/STD.pm/

[23:05] <pmichaud> that's easy !  :-)

[23:06] <pmichaud> std:  my @a = 1..5;  @a[-1];

[23:06] <p6eval> std 26165: OUTPUT«##### PARSE FAILED #####␤Obsolete use of [-1] subscript to access final element; in Perl 6 please use [*-1] instead at /tmp/E6XYpcIuYR line 1:␤------> my @a = 1..5;  @a[-1];␤FAILED 00:02 38m␤»

[23:06] <pmichaud> std:  my @a = 1..5;  @a[-2];

[23:06] <p6eval> std 26165: OUTPUT«ok 00:02 38m␤»

[23:07] <skids> rakudo: class D is ::H {}; 1;

[23:07] <p6eval> rakudo 4a9511: OUTPUT«Null PMC access in isa()␤current instr.: '!meta_trait' pc 19173 (src/builtins/guts.pir:640)␤»

[23:07] <skids> rakudo: class D is ::H {};

[23:07] <p6eval> rakudo 4a9511: OUTPUT«Null PMC access in isa()␤current instr.: '!meta_trait' pc 19173 (src/builtins/guts.pir:640)␤»

[23:07] <jnthn> rakudo: ::H

[23:07] <p6eval> rakudo 4a9511:  ( no output )

[23:07] <jnthn> rakudo: say ::H

[23:07] <p6eval> rakudo 4a9511: OUTPUT«Null PMC access in isa()␤current instr.: 'parrot;List;!flatten' pc 7464 (src/classes/List.pir:236)␤»

[23:07] <skids> rakudo: my ::H $a;

[23:07] <p6eval> rakudo 4a9511:  ( no output )

[23:07] <skids> rakudo: my ::H $a; 1;

[23:08] <p6eval> rakudo 4a9511:  ( no output )

[23:08] <jnthn> rakudo: class D is H { }

[23:08] <p6eval> rakudo 4a9511: OUTPUT«The type H does not exist. at line 1, near "{ }"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[23:08] <jnthn> rakudo: class D is H1B::Visa { }

[23:08] <p6eval> rakudo 4a9511: OUTPUT«The type H1B::Visa does not exist. at line 1, near "{ }"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[23:08] <jnthn> oh i noez

[23:08] <jnthn> We see ::H and consider it a type capture.

[23:08] <jnthn> std: class D is ::H { }

[23:08] <p6eval> std 26165: OUTPUT«ok 00:02 34m␤»

[23:08] <jnthn> std: class D is H { }

[23:09] <p6eval> std 26165: OUTPUT«ok 00:02 34m␤»

[23:09] <pmichaud> ::H declares a lexical type, yes.

[23:09] <jnthn> ah, std doesn't care for non-existent types yet

[23:09] <pmichaud> ::H is a declaration.

[23:09] <jnthn> Aye.

[23:09] <pmichaud> it's not a claim that H exists.

[23:09] <pmichaud> oh, you mean in the second one.

[23:09] <pmichaud> nm.

[23:09] <skids> ::H is a declaration if it is in a declaration, not if it is in an rvalue

[23:10] <jnthn> Part of the issue is more that is_type sees the leading ::H and adds H to the types it knows.

[23:10] <jnthn> But H could well be a null PMC.

[23:10] <jnthn> If we didn't set it to something.

[23:10] <jnthn> rakudo: ::H := Int; my H $x = 42; say $x; $x = "fail"

[23:10] <p6eval> rakudo 4a9511: OUTPUT«42␤Type mismatch in assignment.␤current instr.: 'die' pc 16685 (src/builtins/control.pir:222)␤»

[23:11] <jnthn> rakudo: ::H; my H $x = 42; say $x; $x = "fail"

[23:11] <p6eval> rakudo 4a9511: OUTPUT«42␤»

[23:11] <pmichaud> I think ::H might be a declaration even as an rvalue.

[23:11] <jnthn> rakudo: my ::H $x = 42; say $x; $x = "fail"

[23:11] <p6eval> rakudo 4a9511: OUTPUT«42␤»

[23:11] <jnthn> rakudo: my ::H $x = 42; say $x; $x = "fail"; say H

[23:11] <skids> spec says "as an rvalue" is "is a noop"

[23:11] <p6eval> rakudo 4a9511: OUTPUT«42␤Null PMC access in isa()␤current instr.: 'parrot;List;!flatten' pc 7464 (src/classes/List.pir:236)␤»

[23:12] <pmichaud> skids:  where does it say that?

[23:13] <jnthn> pmichaud: Also, when you add infix:<-> to the list of * ops, there's two tests to unfudge and http://rt.perl.org/rt3/Ticket/Display.html?id=62066 can be closed. :-)

[23:13] <jnthn> Hey, at this rate we might even get back down to 300...

[23:13] <skids> S12 line 82

[23:14] <jnthn> std: my Blah $x;

[23:14] <pmichaud> okay.  So ::H as an rvalue doesn't declare H

[23:14] <p6eval> std 26165: OUTPUT«##### PARSE FAILED #####␤Malformed my␤In "my" declaration, typename Blah must be predeclared (or marked as declarative with :: prefix) at /tmp/Q1LdaLDCqy line 1:␤------> my Blah $x;␤FAILED 00:02 34m␤»

[23:14] <jnthn> std: ::Blah; my Blah $x;

[23:14] <p6eval> std 26165: OUTPUT«##### PARSE FAILED #####␤Malformed my␤In "my" declaration, typename Blah must be predeclared (or marked as declarative with :: prefix) at /tmp/1NbNsovliM line 1:␤------> ::Blah; my Blah $x;␤FAILED 00:02 34m␤»

[23:15] <jnthn> std: class X is ::Blah { }; my Blah $x;

[23:15] <p6eval> std 26165: OUTPUT«##### PARSE FAILED #####␤Malformed my␤In "my" declaration, typename Blah must be predeclared (or marked as declarative with :: prefix) at /tmp/XJvtbHe3SM line 1:␤------> class X is ::Blah { }; my Blah $x;␤FAILED 00:02 35m␤»

[23:15] <jnthn> OK, STD.pm gets it right, it seems.

[23:15] <pmichaud> the error message there seems a bit misleading   "marked as declarative"

[23:15] <pmichaud> if ::H is "declarative", I'd expect it to have declared H.

[23:15] <jnthn> std: my ::Blah $x;

[23:15] <p6eval> std 26165: OUTPUT«ok 00:02 35m␤»

[23:16] <jnthn> hmm

[23:16] <TimToady> traits are not declarative

[23:16] <skids> is is "is X" considered declarative "context"?

[23:16] <TimToady> or is foo($x) would declare $x

[23:16] <TimToady> that was actually a bug I had to fix in STD once upon a time

[23:17] <skids> I guess that answers that.  So at least it's a *good* thing that rakudo behaves differently with my ::H $a.

[23:17] <TimToady> std: my ::Blah $x; my Blah $y;

[23:17] <p6eval> std 26165: OUTPUT«ok 00:02 35m␤»

[23:17] <TimToady> whew

[23:18] <TimToady> std: my $x = ::Blah;

[23:18] <p6eval> std 26165: OUTPUT«ok 00:02 35m␤»

[23:18] <jnthn> TimToady: In this case, what would you expect Blah to be?

[23:18] <TimToady> to that extent, it's not a no-op

[23:18] <TimToady> a type that hasn't been declared yet

[23:19] <TimToady> presumably the lookup would have to be delayed till later

[23:19] <skids> my ::H $a; class H is also { has $.s }; $a = H.new;

[23:19] <pmichaud> but it does signal that Blah is a valid type for the remainder ot he scope, yes?

[23:19] <skids> rakudo: my ::H $a; class H is also { has $.s }; $a = H.new;

[23:19] <pmichaud> skids:  I don't think 'is also' would be needed there

[23:19] <p6eval> rakudo 4a9511: OUTPUT«Null PMC access in find_method()␤current instr.: '!meta_attribute' pc 19322 (src/builtins/guts.pir:703)␤»

[23:19] <pmichaud> saying     my ::H $a;   doesn't create a class.

[23:19] <TimToady> should need augment/is also on a stubbed class

[23:19] <jnthn> Such that a later ::Blah = Int; would retroactively affect assignments to $a from that point onward?

[23:19] <TimToady> *shouldn't

[23:19] <skids> my ::H $a; class H {};

[23:20] <skids> rakudo: my ::H $a; class H {};

[23:20] *** frew|work left
[23:20] <p6eval> rakudo 4a9511: OUTPUT«Re-declaration of type H at line 1, near ";"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[23:20] <TimToady> we don't know the actual run-time class of H at that point

[23:20] <pmichaud> rakudo doesn't have stubs yet.

[23:20] <TimToady> only that H whatever type $a is initialized to

[23:20] <TimToady> which, since there is none, is a problem :)

[23:21] <jnthn> TimToady: Is Rakudo thus correct to complain H has already been declared as a type, though?

[23:21] <TimToady> types with :: in a decaration are captured en passnat

[23:21] <pmichaud> (I think no.)

[23:21] <TimToady> *passant

[23:21] <TimToady> my ::H $a declares type H, yes

[23:21] <TimToady> it's not a stub

[23:21] <pmichaud> oh.

[23:21] <jnthn> Right. So the type is declared.

[23:22] <TimToady> mainly this syntax is used in signatures

[23:22] <jnthn> So trying to redeclare it is a re-declaration on the order of class H { }; class H { }

[23:22] <TimToady> (::T $x, T $y)

[23:22] <jnthn> Right. We handle it in signatures.

[23:22] <TimToady> and presumably my ::T $x = something() does the same thing

[23:23] <jnthn> That's...tricky...

[23:23] <jnthn> But could be made to work, yes.

[23:23] <pmichaud> that seems... tricky.

[23:23] <jnthn> The difficulty is that it's assignment and not binding.

[23:23] <pmichaud> even as binding it's tricky-ish.

[23:23] <jnthn> True.

[23:23] <jnthn> Neither are easy.

[23:23] <pmichaud> with   my ::T $x = something, does that mean that T is always "whatever type $x has"  or  "whatever type $x is initialized to"?

[23:24] <jnthn> The first scares me... :-)

[23:24] <pmichaud> both scare me :-)

[23:24] <pmichaud> yes, the second scares me less.

[23:24] <pmichaud> but since it ends up parsing as     (my ::T $x) = something

[23:24] <pmichaud> that's... icky.

[23:25] <jnthn> Implementing either scares me. The potential to screw up using it with the first semantics scares me more.

[23:25] <TimToady> that might force the first choice

[23:25] <TimToady> well, maybe not

[23:27] <skids> also if I get this right in my/our ::H $a;  ::H shares the my/our ?

[23:28] <pugs_svn> r26166 | jnthn++ | [t/spec] Couple of tests for *.foo generating a closure.

[23:29] <jnthn> (plus rakudo patches just pushed make that pass :-))

[23:29] <dalek> rakudo: f9a2236 | jnthn++ | src/parser/ (2 files):

[23:29] <dalek> rakudo: Fix parsing of whatever.

[23:29] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f9a2236d7f1d3e9190ce9917edfb233459034a45

[23:29] <dalek> rakudo: 70fc009 | jnthn++ | src/classes/ClassHOW.pir:

[23:29] <dalek> rakudo: Implement *.foo generating the closure { $^wob.foo }.

[23:30] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/70fc00959385ab9e435c6ec30c8f57f4e48149ab

[23:31] <jnthn> Tene: I've left off the annotations stuff today...let me know if you don't have time to do more on it, and I can look at it some though.

[23:31] <TimToady> skids: don't understand what you're asking

[23:32] <pmichaud> skids:    ::H is always "my"

[23:32] <pmichaud> i.e., the H is lexically scoped.

[23:32] <skids> S12 says "binds a new type name within the declaration's scope"

[23:32] *** DemoPhreak joined
[23:32] <pmichaud> our ::H $a   declares $a as a package variable, but the 'H' is only relevant to the current lexical scope.

[23:33] <pmichaud> (at least, that's what I seem to remember being told before :-)

[23:33] <skids> OK, so it's within the scope the declaration is in, not within the scope the declaration specifies.

[23:34] <pmichaud> that's what I remember.

[23:35] <TimToady> yes, that's correct

[23:35] <TimToady> all of these declarations are primarily lexical, but some of that have an additional scope, like "our" and "has"

[23:36] <TimToady> has ::T $.attr = something() is a bit mind blowing though

[23:37] * skids reminisces his youth when "scope" was just a brand of mouthwash

[23:38] <TimToady> well, some people distinguish scope from lifetime

[23:38] <pmichaud> s/brand of mouthwash/device used to analyze electrical signals/

[23:38] * jnthn is still youthful.

[23:39] <TimToady> nah, it's what you put on top of your deer rifle

[23:39] <jnthn> Though most people looking at me think I'm 5-10 years older than I actually am. :-|

[23:40] <TimToady> is it better to be thought wiser or more foolish than you really are?  :)

[23:40] * jnthn will write rakudo-day report tomorrow, otherwise it'll probably be full of typos.

[23:40] <pmichaud> TimToady:  "Yes."

[23:40] <jnthn> ;-)

[23:43] <TimToady> rakudo: class A { has ::T $.attr = 42; method sayt { say T.WHAT } }; A.new.sayt

[23:43] <p6eval> rakudo 70fc00: OUTPUT«Null PMC access in can()␤current instr.: '!dispatch_method' pc 18204 (src/builtins/guts.pir:110)␤»

[23:44] <TimToady> rakudo: class A { has ::T $.attr = 42; method sayt { say T.WHAT } }; A.new(:attr(42)).sayt

[23:44] <p6eval> rakudo 70fc00: OUTPUT«Null PMC access in can()␤current instr.: '!dispatch_method' pc 18204 (src/builtins/guts.pir:110)␤»

[23:44] <TimToady> am I doing something wrong?

[23:46] <TimToady> rakudo: class A { has ::T $.attr = 42; method sayt { say $!attr.WHAT } }; A.new(:attr(42)).sayt

[23:46] <jnthn> TimToady: It's not putting anything in T

[23:46] <p6eval> rakudo 70fc00: OUTPUT«Int␤»

[23:46] <jnthn> TimToady: You're getting the equivalent of a null pointer exception minus the segfault. :-)

[23:46] <pmichaud> rakudo doesn't know to bind ::T on an assignment.

[23:46] <TimToady> well, it's not exactly an assignment...

[23:46] <pmichaud> correct

[23:46] <jnthn> initilization

[23:46] <jnthn> whatever

[23:46] <pmichaud> but it still doesn't know to do it.

[23:47] <pmichaud> it knows to do it on subroutine call binding

[23:47] <jnthn> I hadn't actually ever considered that you'd write a ::T there.

[23:47] *** DemoFreak left
[23:47] <TimToady> rakudo: my ::T $x := 42; say T.WHAT

[23:47] <p6eval> rakudo 70fc00: OUTPUT«Null PMC access in can()␤current instr.: '!dispatch_method' pc 18204 (src/builtins/guts.pir:110)␤»

[23:47] <jnthn> And then knowing that I am curious if T is then per instance.

[23:47] <TimToady> I expect it would be

[23:47] <pmichaud> if ::T is "my" scope, then....

[23:47] <TimToady> it's polymorphic, just like any other class name :)

[23:49] <TimToady> well, I guess we'd have to decide whether it was the class of $!attr or of $.attr, since those could differ...

[23:50] <TimToady> $!attr is more sane, but $.attr is more like actual polymorphic classnames

[23:50] <TimToady> the "virtual" classnames discussed earlier

[23:50] <pmichaud> I find it a bit "weird" to think of it per-instance.  Normally ::T creates a lexically-scoped thing.

[23:51] <TimToady> it's a lexically scoped name

[23:51] <pmichaud> ...such that later when I say 'T',  I'm doing a lexical lookup

[23:51] *** bacek_ joined
[23:51] <pmichaud> as opposed to an attribute lookup

[23:51] <TimToady> but in this case, it makes sense only if it points to something else

[23:51] *** bacek left
[23:52] *** LylePerl left
[23:52] <TimToady> has $x is also lexically scoped, but refers to the current object

[23:53] <TimToady> just because a name is lexically scoped doesn't mean that its meaning can't be dynamically determined

[23:53] <pmichaud> okay.

[23:54] <TimToady> but presumably that possibility can be inferred from the declarator in question

[23:54] <jnthn> pmichaud: I more worry that class A { has ::T $x; method x { say T } }; A.new(x => 42).x; A.new(x => 'boo').x # what would this do?

[23:54] <pmichaud> jnthn: that's the problem I'm seeing, yes.

[23:54] <jnthn> pmichaud: Thus why I thought it might have to be per instance if it's going to make sense.

[23:55] <TimToady> I think that can only mean the type of $x in the current instance

[23:55] <pmichaud> I'm not arguing against it being per-instance; it just feels weird.  I have to adjust my internal scope a bit.

[23:56] <pmichaud> so,   ::T  in a 'has' declarator really has per-instance scope, similar to the way that  $x  in 'has $x'  does.

[23:56] <jnthn> pmichaud: Trying seeing the ::T affected by the scope declarator, perhaps.

[23:56] <pmichaud> I think I could handle that.

[23:57] <pmichaud> it breaks my concept that '::T' always declares T as being something like 'my', but that's not a big issue for me.

[23:57] <pmichaud> i.e., I just have to readjust.  Plus I'm a bit sleep deprived this evening.

[23:57] *** wknight8111 left
[23:58] <jnthn> pmichaud: Sleep deprived? How come? ;-)

[23:58] <pmichaud> got to bed late last night, woke up early this morning.

[23:58] <jnthn> Don't worry, soon you'll have some jet lag to help with it. ;-)

[23:58] <pmichaud> so, ~ 2hrs sleep.

[23:58] <jnthn> !!

[23:58] <jnthn> ouch!

[23:58] <jnthn> For me that would take...a LOT of coffee.

[23:58] <skids> I CAN HAS PILLOWZ?

[23:59] <pmichaud> I'm normally most productive (programming wise) in the late evening, so I tend to stay up very late.

[23:59] <pmichaud> But lately Paula has been working overtime for $job, which means I'm also the early riser for kiddies.

[23:59] <skids> Yeah me too.  I think my body tries to kill me when I sleep and the poison only wears off in the evening.

