[00:01] *** rdice left
[00:21] <jnthn> Well, Rakudo builds under it fine here. Haven't benchmarked it, but it'd probably shave some off our spectest run if it improves every startup...

[00:21] <jnthn> Anyways, sleep...night all

[00:25] *** buubot left
[00:26] *** buubot joined
[00:31] *** bacek__ joined
[00:36] *** Kisu left
[00:40] *** [particle] left
[00:40] *** Kisu joined
[00:42] *** wollmers left
[00:42] *** eternaleye joined
[00:52] *** nbrown joined
[01:04] *** avar joined
[01:10] *** avar left
[01:10] *** avar joined
[01:15] *** agentzh left
[01:19] <s1n> so was it changed to have self refer to whatever is constructed at the time of use?

[01:21] <dalek> rakudo: r4d7fe56 | pmichaud++ | src/ops/perl6.ops:

[01:21] <dalek> rakudo: Revise d86c014 (NotFound++) a bit so that we're not mixing our types as much.

[01:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4d7fe56044f338d8f25b5be96faf584a3183ffb6

[01:21] *** ZuLuuuuuu joined
[01:26] *** Whiteknight left
[01:29] *** c9s_ joined
[01:29] <meppl> good night

[01:31] *** c9s left
[01:31] *** meppl left
[01:32] *** c9s_ is now known as c9s

[01:38] *** agentzh joined
[01:40] *** ZuLuuuuuu left
[02:01] *** cdarroch left
[02:01] *** Kisu left
[02:10] *** s1n left
[02:10] *** hercynium left
[02:11] *** s1n joined
[02:19] *** alester_ joined
[02:32] *** nihiliad joined
[02:44] <s1n> moritz_: ping

[02:50] *** avar left
[02:50] *** avar joined
[02:51] *** alester_ left
[03:02] *** nbrown left
[03:14] *** alester_ joined
[03:15] <mikehh> I am still failing t/spec/S09-subscript_slice/slice.rakudo - rakudo (4d7fe56) on parrot r38475

[03:16] <mikehh> ./perl6 t/spec/S09-subscript_slice/slice.rakudo - runs through all the tests says # FUDGED! then Segmentation fault

[03:18] *** skids left
[03:18] <mikehh> that's om Kubuntu Jaunry (9.04) Amd64

[03:18] <mikehh> s/om/on/

[03:19] <mikehh> all the other spectests pass

[03:25] <mikehh> in the test - ok 1..11, ok 12..19 (SKIP), ok 20..25, nok ok 26..27 (TODO), # FUDGED!, Segmentation fault

[03:27] <mikehh> s/nok/not/ and Jaunty in prev

[03:50] <avar> mikehh: (I'm not a parrot or rakudo dev): If you compile parrot with "-ggdb3 -O0" cflags and run that under gdb you could produce a more useful bug report

[03:50] <avar> e.g. $ gdb ./perl6

[03:50] <avar> run t/spec/S09-subscript_slice/slice.rakudo

[03:50] <avar> bt full

[03:50] <avar> but your setup is common enough that they'll probably find out about this soon enough if they haven't already

[04:03] *** SamB left
[04:06] *** SamB joined
[04:17] <pmichaud> (segfault on slice.t)  Yes, I get that segfault also.  It's not a rakudobug, really -- it's something segfaulting on Parrot exit.

[04:38] *** mikehh is now known as mikehh_

[04:38] *** mikehh_ is now known as mikehh__

[04:41] *** mikehh__ is now known as mikehh

[04:42] *** SamB left
[04:59] *** alc joined
[05:06] *** jhuni joined
[05:39] *** nihiliad left
[05:43] *** ejs joined
[05:44] *** orafu joined
[05:48] *** justatheory left
[05:55] *** DemoFreak joined
[06:06] *** wollmers joined
[06:12] *** orafu left
[06:13] *** orafu joined
[06:20] *** masak joined
[06:20] <moritz_> s1n: pong

[06:21] <masak> good morrow, socketcamels.

[06:22] <mberends> good morrow, mask

[06:22] <moritz_> h h

[06:22] *** ejs left
[06:23] * masak does a Jim Carrey impersonation

[06:24] <mberends> masak: thanks for the netstat info. could you please check out a test for me?

[06:25] <masak> mberends: certainly.

[06:27] <mberends> masakbot: cd ~/rakudo; svn up t/spec; ./perl6 t/spec/S32-io/IO-Socket-INET.t

[06:28] <masak> output: PASS

[06:29] <mberends> :D

[06:29] <masak> mberends++

[06:30] <moritz_> now we need to find out what happens if somebody has no netcat installed

[06:30] *** FurnaceBoy left
[06:31] * mberends will try that immediately

[06:36] <mberends> moritz_: ok, it works without either netcat or socat. Would you advise inflicting this socket test on spectest users?

[06:37] <moritz_> mberends: in principle, yes. But I'd like to have jnthn++ test it on windows first

[06:38] *** eMaX left
[06:38] <mberends> O NOES! it cannot work on windows because of the shelly things. It should skip everything silently though.

[06:39] *** zamolxes joined
[06:39] <mberends> but good idea. let's wait until it's rakudo-am in Bratislava.

[06:39] <masak> if ($*OS ~~ Suck) { ... }

[06:40] <mberends> in Dutch slang pipe === blowjob

[06:41] <masak> no, I meant the other way around. them that don't hav'em suck.

[06:41] <mberends> true

[06:43] *** meppl joined
[06:44] <mberends> with tests in place I have the courage to tinker with IO::Socket::INET a little more.

[06:48] <masak> tests++

[06:48] * mberends hands the proto pumpkin to masak

[06:48] <moritz_> let's add it to the spectests.t and have $people complain if it doesn't work somewhere ;-)

[06:49] <masak> :)

[06:50] <mberends> ;-) works here! what do you mean, tests fail? must be your setup!

[06:50] <masak> mberends: I'm holding another pumpkin at present. says "$work" on it. have to put the proto pumpkin here on the ground along with the other spheroid objects.

[06:52] <masak> rakudo: say { a => 1, b => 1 }.invert.perl

[06:52] <p6eval> rakudo 4d7fe5: OUTPUT«[1 => "a", 1 => "b"]␤»

[06:52] * masak submits rakudobug

[06:52] *** alester_ left
[06:52] *** avar left
[06:52] *** avar joined
[06:52] *** iblechbot joined
[06:53] <moritz_> why?

[06:53] <mberends> duplicate key

[06:53] <moritz_> .invert returns a list.

[06:54] <mberends> ah, not a hash

[06:54] <masak> reading spec now.

[06:54] <masak> I don't seem to find that this is an error.

[06:54] <masak> maybe my brain isn't synched with the latest spec...

[06:54] <moritz_> rakudo: my %h; %h.push: { a => 1, b => 1 }.invert; say %h.perl

[06:54] <p6eval> rakudo 4d7fe5: OUTPUT«{"1" => ["a", "b"]}␤»

[06:55] <masak> moritz_: ah.

[06:55] * masak stands down red rakudo-alert

[06:56] <mberends> next yak: pure Perl 6 Net::SMTP for command line rakudobugs

[06:56] <masak> yay!

[06:58] *** ElectricHeavyLan left
[06:58] <moritz_> let's make Perl 6 attractive for spammers ;-)

[06:59] <mberends> imagine the questions in #perl6 in 6 months time

[07:00] <mberends> "hello, I want send email w/attachment. can u help with this?"

[07:01] * moritz_ hopes that in 6 months the questions will be like this: "this last release was *so* cool - how can I help?"

[07:03] <masak> moritz_: you should blog-post an FAQ with only questions like that. prime people in the right direction. :)

[07:03] <masak> ok, #perl6. I'm a bit stumped with .invert at present. maybe you can help me.

[07:04] <masak> rakudo: say $*IN.slurp.join.comb.map(-> $k {$k=>1}).perl

[07:04] <p6eval> rakudo 4d7fe5: OUTPUT«["Land" => 1, "der" => 1, "Berge," => 1, "Land" => 1, "am" => 1, "Strome," => 1, "Land" => 1, "der" => 1, "Äcker," => 1, "Land" => 1, "der" => 1, "Dome," => 1, "Land" => 1, "der" => 1, "Hämmer," => 1, "zukunftsreich!" => 1, "Heimat" => 1, "bist" => 1, "du" => 1, "großer" => 1,

[07:04] <p6eval> .."S...

[07:04] <masak> now, I'd like to invert this list of pairs.

[07:04] <masak> how do I do that?

[07:04] <masak> should be easy, right?

[07:04] <moritz_> what do you mean by "invert"?

[07:04] <moritz_> invert each pair?

[07:05] <moritz_> rakudo: say $*IN.slurp.join.comb.map(-> $k {$k=>1}).map(*.invert).perl

[07:05] <p6eval> rakudo 4d7fe5: OUTPUT«Method 'invert' not found for invocant of class 'Perl6Pair'␤current instr.: 'parrot;P6metaclass;!whatever_dispatch_helper' pc 243809 (src/gen_metaop.pir:8)␤»

[07:05] <moritz_> rakudo: say $*IN.slurp.join.comb.map(-> $k {$k=>1}).map(*.hash.invert).perl

[07:05] <p6eval> rakudo 4d7fe5: OUTPUT«Method 'invert' not found for invocant of class 'Block'␤current instr.: 'parrot;P6metaclass;dispatch' pc 243614 (src/gen_actions.pir:0)␤»

[07:06] <moritz_> rakudo: say $*IN.slurp.join.comb.map(-> $k {$k=>1}).map({.hash.invert}).perl

[07:06] <p6eval> rakudo 4d7fe5: OUTPUT«[1 => "Land", 1 => "der", 1 => "Berge,", 1 => "Land", 1 => "am", 1 => "Strome,", 1 => "Land", 1 => "der", 1 => "Äcker,", 1 => "Land", 1 => "der", 1 => "Dome,", 1 => "Land", 1 => "der", 1 => "Hämmer,", 1 => "zukunftsreich!", 1 => "Heimat", 1 => "bist", 1 => "du", 1 => "großer",

[07:06] <p6eval> ..1 ...

[07:06] <masak> thank you.

[07:06] <moritz_> (chained method calls don't work with *)

[07:07] <masak> in the past few seconds, I've realized I don't need to invert. :)

[07:07] <masak> but that's ok, I have a new problem.

[07:07] <masak> rakudo: %*h.push: $*IN.slurp.join.comb.map(-> $k {$k=>1}); say %*h.perl

[07:07] <p6eval> rakudo 4d7fe5: OUTPUT«{}␤»

[07:07] <masak> I would expect something non-empty.

[07:08] <moritz_> rakudo: our %*h; %*h.push: $*IN.slurp.join.comb.map(-> $k {$k=>1}); say %*h.perl

[07:08] <p6eval> rakudo 4d7fe5: OUTPUT«get_pmc_keyed_str() not implemented in class 'String'␤current instr.: '_block14' pc 68 (EVAL_20:51)␤»

[07:08] <masak> huh?

[07:08] <moritz_> IMHO both are "ouch"

[07:08] <masak> double rakudobug coming up!

[07:10] <masak> rakudo: %*h.push: 1 => 2; %*h.perl.say

[07:10] <p6eval> rakudo 4d7fe5: OUTPUT«{}␤»

[07:13] <masak> rakudo: our %*h

[07:13] <p6eval> rakudo 4d7fe5: OUTPUT«get_pmc_keyed_str() not implemented in class 'String'␤current instr.: '_block14' pc 63 (EVAL_11:49)␤»

[07:14] <masak> rakudo: our $*h

[07:14] <p6eval> rakudo 4d7fe5:  ( no output )

[07:14] <dalek> rakudo: r4d3a38f | (Moritz Lenz)++ | t/spectest.data:

[07:14] <dalek> rakudo: run socket tests, mberendes++

[07:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4d3a38f97e57f91ffca7289ace25dbf22513e2b2

[07:20] <Matt-W> Morning

[07:20] <masak> Matt-W: o/

[07:20] <masak> rakudo: my %h; %h.push: $*IN.slurp.join.comb.map(-> $k {$k=>1}); say +.value, "\t", .key for %h.pairs.sort({ -.value })

[07:20] <p6eval> rakudo 4d3a38: OUTPUT«5  Land␤4   der␤3    Österreich,␤3      Österreich!␤2      du␤2    vielgerühmtes␤2     vielgeprüftes␤2    in␤2    und␤2    vielgeliebtes␤1     Berge,␤1  am␤1    Strome,␤1 Äcker,␤1 Dome,␤1    Hämmer,␤1       zukunftsreich!␤1     Heimat␤1  bist␤1   großer␤1  Söhne,␤1       

[07:20] <p6eval> ..Volk,␤1   begnadet␤1        für␤1     das␤1   Schöne,␤1  Heiß␤1    umfehdet,␤1        wild␤1  umst...

[07:21] <masak> should have taken the 10 most frequent.

[07:21] <masak> rakudo: my %h; %h.push: $*IN.slurp.join.comb.map(-> $k {$k=>1}); say +.value, "\t", .key for %h.pairs.sort({ -.value })[^10]

[07:21] <p6eval> rakudo 4d3a38: OUTPUT«5  Land␤4   der␤3    Österreich,␤3      Österreich!␤2      du␤2    vielgerühmtes␤2     vielgeprüftes␤2    in␤2    und␤2    vielgeliebtes␤»

[07:21] <mberends> nice

[07:22] <masak> I'm a bit bummed at the '-> $k { $k => 1 }' thing, though.

[07:22] *** ejs joined
[07:24] <masak> it's needed because just '{ $_ => 1 }' is interpreted as a hash, and map gets sad.

[07:24] <masak> maybe overloading map to take a Hash would save a lot of future FAQ grief...

[07:25] <masak> OTOH, maybe it would cause some grief also.

[07:26] <mberends> implementing map on a hash might delay Christmas :/

[07:26] <masak> mberends: no, that's not what I meant.

[07:27] <masak> mberends: I meant that when the Code is accidentally a Hash, it should DWIM.

[07:27] <masak> for example [email@hidden.address] $_ => 1 })'

[07:27] <masak> it looks like it should work...

[07:27] <Matt-W> There's some rule about when {} is a Hash and when it's a Callable

[07:28] <masak> Matt-W: aye.

[07:28] <mberends> whitespace as syntax ?

[07:28] <masak> as far as I'm concerned, it's a good rule.

[07:28] *** eMaX joined
[07:28] <masak> it's still a bit surprising when it bites you, though.

[07:28] <masak> mberends: no, whitespace is not a part of it.

[07:29] <masak> meeting &

[07:29] *** jhuni left
[07:31] <moritz_> if it's a list of pairs inside, it's a hash. otherwise it's a block.

[07:31] <Matt-W> and of course $_ => 1 looks like a pair

[07:31] <moritz_> {; $_ => 1 } is the common Perl 5 disambiguation

[07:34] *** ejs1 joined
[07:34] *** H1N1[A] left
[07:35] <Matt-W> Isn't this somewhere that the * would be useful?

[07:37] <moritz_> like * => 1?

[07:37] <moritz_> rakudo: say <a b c>.map(* => 1).perl

[07:37] <p6eval> rakudo 4d3a38: OUTPUT«Parameter type check failed; expected something matching  but got something of type Pair() for expr in call to map␤current instr.: 'die' pc 16538 (src/builtins/control.pir:225)␤»

[07:38] <moritz_> no.

[07:38] <moritz_> rakudo: say (* => 1).perl

[07:38] <p6eval> rakudo 4d3a38: OUTPUT«!whatever_dispatch_helper => 1␤»

[07:38] *** ejs left
[07:38] <moritz_> rakudo: say *.perl

[07:38] <p6eval> rakudo 4d3a38: OUTPUT«!whatever_dispatch_helper␤»

[07:39] <moritz_> that looks so wrong.

[07:39] *** H1N1[A] joined
[07:39] * moritz_ summons masak

[07:39] <Matt-W> rakudo: say (<a b c>.map: * => 1).perl

[07:39] <p6eval> rakudo 4d3a38: OUTPUT«Parameter type check failed; expected something matching  but got something of type Pair() for expr in call to map␤current instr.: 'die' pc 16538 (src/builtins/control.pir:225)␤»

[07:40] <Matt-W> bah

[07:40] <Matt-W> okay so you can't fool it into doing that

[07:40] <Matt-W> std: say <a b c>.map(* => 1).perl

[07:40] <p6eval> std 26674: OUTPUT«ok 00:02 35m␤»

[07:40] <moritz_> it just constructs a Pair

[07:40] *** H1N1[A] is now known as H1N1

[07:41] <Matt-W> You can do things like map(*.methodname) though

[07:41] <Matt-W> interesting

[07:41] <Matt-W> Is that a bug, or intentional

[07:42] <moritz_> I don't know

[07:42] <Matt-W> Neither do I

[07:42] <Matt-W> Maybe masak knows

[07:42] <Matt-W> When his meeting is done

[07:42] * moritz_ hopes that TimToady knows :-)

[07:44] <Matt-W> Yes I hope so too

[07:44] <Matt-W> Because if he doesn't...

[07:47] *** ejs2 joined
[07:58] *** ejs1 left
[08:17] * moritz_ just created his first binary from a Perl 6 program

[08:18] *** donaldh joined
[08:21] *** elmex joined
[08:21] *** bacek__ left
[08:28] * masak is back from the meeting

[08:28] <masak> I think it's a bug.

[08:28] * masak submits rakudobug

[08:33] <masak> hm, wait.

[08:33] <masak> where are expressions like (* - 1) documented in the spec? S09?

[08:34] <moritz_> S02

[08:35] <moritz_> Most of the built-in numeric operators treat an argument of * as indicating the desire to create a function of a single unknown, so:

[08:35] <moritz_> * - 1

[08:35] <moritz_> produces a function of a single argument:

[08:35] <moritz_> { $_ - 1 }

[08:35] <masak> 'numeric'.

[08:35] <masak> so, not a bug.

[08:35] <moritz_> no, it's the .perl output that looks weird to me

[08:36] <masak> oh.

[08:36] * masak resumes submitting

[08:36] <moritz_> rakudo: say (* => 1).perl

[08:36] <p6eval> rakudo 4d3a38: OUTPUT«!whatever_dispatch_helper => 1␤»

[08:36] <masak> well, that's obbviously wrong.

[08:37] <pugs_svn> r26675 | wollmers++ | precised reason for rakudo skip

[08:39] *** elmex left
[08:44] *** elmex joined
[08:45] <Matt-W> so is that perhaps a bug in infix:<=>>

[08:45] <moritz_> rakudo: say *.perl

[08:45] <p6eval> rakudo 4d3a38: OUTPUT«!whatever_dispatch_helper␤»

[08:46] <moritz_> no.

[08:46] <moritz_> it's much simpler :)

[08:46] <masak> it's just piping showing through.

[08:46] <moritz_> rakudo: say *.isa(Whatever)

[08:46] <Matt-W> Oooh your piping is showing! Scandalous!

[08:46] <p6eval> rakudo 4d3a38: OUTPUT«!whatever_dispatch_helper␤»

[08:47] <moritz_> there is a slight problem

[08:47] <masak> rakudo: say ?(*)

[08:47] <p6eval> rakudo 4d3a38: OUTPUT«1␤»

[08:48] <moritz_> who to decide which methods should generate a closure?

[08:48] <Matt-W> Something consistent

[08:48] <moritz_> since Whatever ~~ Any, most interesting methods (defined in Any) are also existing methods on Whatever

[08:48] <masak> rakudo: say Whatever.flip

[08:48] <p6eval> rakudo 4d3a38: OUTPUT«)(revetahW␤»

[08:49] <masak> :)

[08:49] <moritz_> :-)

[08:49] <masak> we should have a .flip that also flips parens.

[08:49] <masak> and turns 'b' into 'd'.

[08:49] <moritz_> that would be .mirror :-)

[08:49] <masak> right.

[08:50] <moritz_> .oO( Text::UpsideDown )

[08:54] <mberends> :) in the days of single sided floppy disks, once installed a splash screen on the second side that displayed a reversed message saying "Error: diskette upside down"

[08:55] <masak> moritz_: ¿ƃuıɥʇǝɯos ǝq ʇɐɥʇ ʇ,upʃnoM

[08:56] <mberends> wow!

[08:56] <masak> http://www.fileformat.info/convert/text/upside-down.htm

[09:01] *** ejs2 left
[09:12] *** kidd` joined
[09:16] *** donaldh_ joined
[09:16] *** donaldh_ left
[09:21] *** alc left
[09:30] <pugs_svn> r26676 | wollmers++ | rakudo skip

[09:31] *** ejs2 joined
[09:31] <moritz_> wollmers: please prefix commit messages to the test suite with [t/spec'

[09:31] <moritz_> [t/spec] actually

[09:31] <moritz_> afk

[10:05] *** ejs2 left
[10:08] <wollmers> moritz_: ACK

[10:15] *** Muixirt joined
[10:35] <jnthn>  H H

[10:36] <moritz_>  LL HL TH VWLLSS LLSPK

[10:38] *** icwiener joined
[10:42] <arnsholt> E A S OE?

[10:45] *** zamolxes left
[10:46] <masak> arnsholt: well, you wouldn't be able to distinguish between "OH HAI" and "NO WAI", for example...

[10:48] <moritz_> masak, literal: in last year's GSOC we had weekly IRC meetings with status reports, much like #parrotsketch... what do you think about doing it like that this year? (once the coding time has started, of course)

[10:49] <arnsholt> masak: Yeah. It's just that it's a natural extension of the no-vowels thing. I'm a sucker for language games

[10:49] <arnsholt> Which is part of the reason I like Perl as much as I do, I suspect =)

[10:50] <moritz_> Muixirt: my complains are not that there are no possiblities for optimization, but that the default thing (whiche 90% of all people use) sucks

[10:51] <masak> moritz_: +1

[10:51] <masak> (for the meetin idea)

[10:51] <masak> s/in/ing/

[10:51] <pugs_svn> r26677 | wollmers++ | [t/spec] fudge and unfudge for current rakudo

[10:52] <masak> arnsholt: Perl is definitely the language for people who like languages.

[10:53] <Muixirt> moritz_, but if parrot isn't ready (the fast cores) rakudo users have to wait

[10:53] <Matt-W> arnsholt, masak: Definitely!

[10:54] <wollmers> masak: true for me, mostly because regex and \p{}

[10:55] <Muixirt> moritz_, did you watch the Lars Bak video?

[10:55] <moritz_> Muixirt: I know. no reason not to rant.

[10:55] <moritz_> and "no" to the video

[10:56] <wollmers> masak: I do NLP and NER in ~300 languages with Perl 5

[10:57] <masak> wollmers: nice.

[10:59] * jnthn has got a backtrace of the slice.t crash, but it isn't making it especially obvious what's wrong...

[11:02] *** payload joined
[11:03] <jnthn> Ugh. And it fails in a different way under -G.

[11:05] <masak> I'm still thinking about putting together a grant application for summer Rakudo work. I have another idea which might be considered to be on the critical path as well.

[11:05] <masak> all those collection classes, Bag, HashSet, and the like.

[11:06] <Muixirt> moritz_, what a pity :-) the was a passage in the talk that reminded me instantly about parrot/rakudo

[11:07] <Muixirt> moritz_, of course i don't know whether Lars Bak looked at parrot/rakudo, and, of course, i might got it wrong

[11:07] <jnthn> masak: They need to get done at some point. :-)

[11:07] <masak> yes. and they need a bit of spec work and tests as well.

[11:07] <jnthn> Indeed.

[11:07] <masak> I think it could be a nice summer project.

[11:07] <jnthn> Same.

[11:08] <masak> the advantage of doing it in one concentrated time period is that there might actually be some consistence to the design. :)

[11:08] <masak> s/ce/cy/

[11:08] <masak> ugh.

[11:08] <wollmers> moritz_: Should all Unicode related tests go from some-file.t to somefile.unicode.t?

[11:09] <moritz_> wollmers: no

[11:09] *** payload left
[11:09] <moritz_> wollmers: Unicode is integral part of Perl 6, no need to separate them

[11:10] <wollmers> moritz_: UTF-8;-)

[11:12] <masak> Set, Bag, KayHash, KeySet, and KeyBag.

[11:12] *** hcchien left
[11:12] *** hcchien joined
[11:12] <moritz_> masak: "container types"

[11:13] <masak> Mr Bloch's tutorial on Java's collections really opened my eyes to the richness of collections in Java, and the need to do this well. http://java.sun.com/docs/books/tutorial/collections/index.html

[11:13] <masak> I should perhaps start by tentatively translating all the code in that tutorial.

[11:13] <masak> ...and blogging about it. :)

[11:13] <jnthn> :-)

[11:15] <moritz_> mberends: the socket test passes here when run separately, but fails one (the third) when run during 'make spectest'

[11:15] <moritz_> at least on one machine

[11:16] *** spx2 left
[11:17] <jnthn> Ouch.

[11:17] <jnthn> rakudo: my @array = (3,7,9,11); say @array[0..1]

[11:17] <p6eval> rakudo 4d3a38: OUTPUT«37␤»

[11:18] <jnthn> Can somebody try running that but with Parrot's -G on?

[11:18] <jnthn> e.g. ../../parrot perl6.pbc -e ' my @array = (3,7,9,11); say @array[0..1]'

[11:18] <jnthn> oops

[11:18] <jnthn> -G after parrot

[11:18] <jnthn> Try it with and without and let me know if you see a difference in the output too.

[11:18] <moritz_> maximum recursion depth exceeded

[11:18] <moritz_> current instr.: 'parrot;Int;succ' pc 5513 (src/classes/Int.pir:81)

[11:18] <jnthn> Same here. :-(

[11:18] <moritz_> (with -G)

[11:19] <moritz_> and 37 without -G

[11:19] <jnthn> OK, reproducable at least. Hmm.

[11:19] <jnthn> (This is from the slice.t issue)

[11:20] *** donaldh left
[11:20] *** donaldh joined
[11:20] <jnthn> Not quite sure, what to make of this.

[11:21] <jnthn> It's almost like a GC bug that makes things work.

[11:21] <jnthn> (But in slice.t our luck runs out and we segfault during exit)

[11:23] <jnthn> If I fudge out all the tests in slice.t that do ranges inside postcircumfix:<[ ]> then the segv goes away.

[11:26] <s1n> masak: "In general, it is good API design practice not to make users pay for a feature they don't use."  (from the introduction, always been a good quote)

[11:32] <masak> s1n: nod.

[11:42] * jnthn files a ticket with this discoveries, not wanting to spend all day debugging a GC issue.

[11:47] *** mmayr joined
[11:47] *** mmayr is now known as desertm4x

[11:53] *** fridim_ joined
[12:03] *** kidd` left
[12:05] *** ruoso joined
[12:07] <ruoso> Hello!

[12:08] <masak> ruoso: o/

[12:10] <ruoso> masak, how's everything in web.pm?

[12:11] <masak> ruoso: there's progress.

[12:12] <ruoso> I kinda lost track of it... do you have a dispatcher already?

[12:12] <masak> ruoso: I'm not sure about the big picture yet. there's a lot of details to get lost in. but I like working on it.

[12:12] <masak> ruoso: ihrd has been working on something called Routes. don't know how close to an actual dispatcher that is.

[12:12] <ruoso> is it in the github repo?

[12:13] <masak> yes.

[12:14] <ruoso> do you have a link to that specific part of the code?

[12:14] <masak> aye, hold on.

[12:15] <masak> http://github.com/masak/web/blob/master/lib/Routes.pm

[12:16] <masak> I don't know too much about it -- only that I recognize parts of it from the Dispatcher.pm code in November, that one also written by ihrd++,

[12:16] <masak> and that Routes is said to have ties to the model in some way.

[12:22] <ruoso> hmm... I miss the use of context variable

[12:22] <ruoso> s

[12:23] <masak> ruoso: I haven't seen this code in actual use yet. it's what I feel is missing right now, an actual use.

[12:24] <masak> now that we have sockets and the Web.pm request/response groundwork, we should really focus on pushing things out onto the browser, so that we can see them.

[12:30] <ruoso> masak, what happen to the idea of using a generic role for Request and Response?

[12:30] <ruoso> s/happen/happened/

[12:31] *** donaldh left
[12:31] <masak> ruoso: what was that idea again? I vaguely recall us talking about it, but not why that was preferrable... :/

[12:32] <ruoso> because it would make the framework useable in more situations

[12:32] <masak> that's a generic answer.

[12:32] <masak> ruoso: put it like this: the current model works for Rack, why won't it for us?

[12:33] <ruoso> it's the other way around

[12:33] <ruoso> I'd like to use it for non-web things

[12:33] <ruoso> or at leasy

[12:33] <ruoso> non http

[12:33] <masak> ruoso: ah, now I remember.

[12:33] <ruoso> http://github.com/masak/web/blob/2b4a056b04b05b793773d5e76d7ba3fde1d26508/doc/stages

[12:34] <masak> ruoso: you know, non-http is really outside of the scope of our grant.

[12:34] <ruoso> as I said

[12:34] <ruoso> at that time

[12:34] <ruoso> I don't expect you to implement non-http

[12:34] <masak> right.

[12:34] <ruoso> I just asks for it to be possible for someone else to do it

[12:34] <masak> yes.

[12:34] <ruoso> i.e.: me

[12:34] <ruoso> (as I already did with catalyst...)

[12:35] <masak> at that time, I didn't know as much about Rack's Request and Response as I do now.

[12:36] *** abra joined
[12:37] *** zev left
[12:38] <ruoso> masak, http://github.com/masak/web/blob/2b4a056b04b05b793773d5e76d7ba3fde1d26508/doc/web-framework-roles

[12:38] *** ZuLuuuuuu joined
[12:38] <ruoso> that was my sketch at that time, in case you don't recall

[12:39] <masak> ruoso: I recall.

[12:40] *** zev joined
[12:40] <masak> ruoso: is there something in particular that I can relay to ihrd, the one tasked with implementing this part of Web.pm?

[12:40] <ruoso> two things specially

[12:40] <ruoso> one is the use of contextual variables

[12:41] <masak> (I know he has health problems in the family, so he's not very available right now.)

[12:41] <pugs_svn> r26678 | wollmers++ | [t/spec] fudge test for rakudo; softlink

[12:41] <ruoso> the other is the different stages of the action processing

[12:43] <masak> I will tell him when he's around.

[12:44] *** Jedai left
[12:45] *** [particle] joined
[12:56] <Matt-W> masak: oh yes, I read your blog about Web.pm and I thought that using parse actions to generate a tree, and then doing top-down processing on the resulting tree is probably going to be very common.

[12:57] <masak> Matt-W: I believe so.

[12:57] <dalek> rakudo: rd500f20 | jnthn++ | src/pmc/p6invocation.pmc:

[12:57] <dalek> rakudo: More work on P6Invocation. There'll be room for optimization, but this serves well as at least a POC.

[12:57] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d500f20dcd77c54324fafe600d4399b3774640fb

[12:57] <masak> Matt-W: I also believe a good project at this point, for whoever has the time to do it, would be to pair up XPath and Match objects.

[12:59] <wolverian> would it make sense to compile xpath to rules? probably not.

[13:00] <masak> wolverian: it might make sense to compile them to code.

[13:00] <wolverian> easier to wrap an xpath engine inside a Match impl, or so.

[13:01] <wolverian> yeah, but that is a pain.

[13:01] <moritz_> since PGE can't do matches on anything but strings... no way

[13:01] <masak> moritz_: you could convert the Match tree to a string :)

[13:02] * moritz_ sends the waves of agonizing pain that this statement caused back to masak

[13:02] <masak> aie. :)

[13:05] <jnthn> woo. p6invocation has come together more easily than expected.

[13:05] *** payload joined
[13:06] <wolverian> convert Match to XML and then run xpath on *that*

[13:09] *** exodist joined
[13:09] <Matt-W> replace PGE with an xpath engine

[13:09] <Matt-W> make everything be XML internally

[13:10] <Matt-W> <assign><my identifier="a" /><string value="foo" /></assign>

[13:10] * Matt-W runs and hides

[13:11] <jnthn> I once saw a library that let you declare regexes in .Net using the query expression syntax.

[13:11] <Matt-W> that sounds like a nice thing for xml people

[13:12] <mberends> moritz_: t/spec/S32-io/IO-Socket-INET.t randomly fails tests 2 and 3 when run repeatedly. Using ' netstat --tcp --all --numeric' at the same time shows the tested socket in TIME_WAIT state. Let me try to change the socket options before keeping this in spectest.data.

[13:14] <jnthn> A lot of folks in the .Net world don't really seem to grok regexes, and write all kinds of string manip code that a regex woulda handled for them much more easily.

[13:16] <Matt-W> you have to give them some slack

[13:16] <Matt-W> a lot of them probably came from C++

[13:16] <Matt-W> and nobody ever introduced them to boost::regex or PCRE

[13:16] <jnthn> Oh, quite possibly, yes.

[13:17] *** FurnaceBoy joined
[13:17] <Matt-W> Or on the web side, they game from VBScript

[13:17] <jnthn> Aye.

[13:17] <Matt-W> And .NET doesn't really encourage use of Regex, it just provides it

[13:18] <jnthn> C# 3.0 is a good language, and the .Net stuff ain't so bad either, but the code I see by a lot of people might as well have been written in VBScript or Java.

[13:18] <Matt-W> People don't use it like they should

[13:18] <jnthn> It goes for any language though.

[13:19] <Matt-W> Absolutely

[13:19] <jnthn> It's not like everyone uses Perl like they should. :-)

[13:19] <Matt-W> I've met a fair few people who work with .NET but have no idea how they could benefit from lambda functions

[13:19] <jnthn> Aye.

[13:19] <Matt-W> Whereas when I've worked in .NET I use them all the time

[13:19] <Matt-W> But that's because I'm a functional programmer whenever I get the chance

[13:20] <dalek> rakudo: ree10f59 | jnthn++ |  (2 files):

[13:20] <dalek> rakudo: Method on P6Invocation to check if we have more candidates, and tests for it.

[13:20] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ee10f59487ea845c7e7b1717cfcb077da5293064

[13:20] <jnthn> There's also a camp of people in the .Net world who are along the lines of, "object orientation is the one true paradigm and these extra things pollute the purity of it".

[13:20] <Matt-W> Urgh

[13:20] <Matt-W> No no no

[13:20] <Matt-W> OO is much easier if you mix in some functional stuff

[13:21] <jnthn> I know, but when they announced anonymous methods in C# 2.0, I was pretty horrified by the number of comments along those lines that I saw.

[13:21] <Matt-W> Particularly if you're playing with threads or event-driven programming

[13:21] <ruoso> jnthn, taking an old question... do we have a plan for @list.reduce being called with a multi with varying arity?

[13:21] <Matt-W> It's just ignorance

[13:21] <jnthn> ruoso: Not that I'm aware of...

[13:21] <Matt-W> And I don't think anonymous delegates sit outside the OO paradigm at all

[13:21] <Matt-W> All you have to do is say 'code is an object'

[13:22] <masak> jnthn, ruoso: what's the issue? is there a small piece of code that highlights it?

[13:22] <jnthn> Oh, for sure.

[13:22] <jnthn> ruoso: Part of me still wonders if that's a task for a module.

[13:22] <ruoso> masak, the muti-based action dispatcher would require it in order to be sane

[13:22] <Matt-W> jnthn: they'd probably also consider Smalltalk's object system to be wrong though :)

[13:22] *** ejs2 joined
[13:23] <masak> ruoso: I assumed that's why you asked, yes.

[13:23] <masak> Matt-W: http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent

[13:25] *** nihiliad joined
[13:28] *** dalek left
[13:28] <Matt-W> masak: I love those pages, where you find your opinion being modified as you read all the arguments on the way down

[13:28] *** dalek joined
[13:28] <masak> Matt-W: me too.

[13:29] <Matt-W> frustrating meeting &

[13:29] *** sri_kraih_ joined
[13:29] <jnthn> oh noes I forgot lunch

[13:30] *** sri_kraih left
[13:30] * ruoso .oO( good thing to be to the west, so I get a reminder for lunch by people who forgot lunch )

[13:31] <masak> jnthn: Google Imeages search for "oh noes I forgot lunch" gave this: http://www.ramblestrip.com/pictures/lolcats_oh-noes_ihasletgo.jpg

[13:32] <jnthn> :-D

[13:34] *** dalek left
[13:34] *** dalek joined
[13:38] *** amoc left
[13:48] *** desertm4x left
[13:50] <pugs_svn> r26679 | lwall++ | [STD] start contextualizing language braids for user-overridability

[13:53] <TimToady> ruoso> one is the use of contextual variables

[13:53] *** amoc joined
[13:53] <TimToady> I'm curious whether this is ++ or --

[13:53] <ruoso> this is that he was supposed to use contextual variables, and he's not

[13:54] <TimToady> okay, good :)

[13:54] *** PacoLinux joined
[13:54] <TimToady> (I hope)

[13:54] <TimToady> since STD uses 'em all over the place, probably places where it shouldn't...

[13:54] <ruoso> TimToady, take a look at  http://github.com/masak/web/blob/2b4a056b04b05b793773d5e76d7ba3fde1d26508/doc/web-framework-roles

[13:55] *** pmurias joined
[13:57] <TimToady> extra semi on line 50

[13:59] <PerlJam> TimToady: can you make perl give error messages like that?  :-)

[13:59] <TimToady> sometimes

[14:00] <TimToady> the fact that the next statement is "if $.foo;" is indicative

[14:00] <TimToady> sort on line 90 missing its :

[14:00] <wolverian> can line 20 be self.?begin-closure(self)? though that looks rather weird.

[14:01] <TimToady> the bindings in regex should be = rather than := these days

[14:01] <TimToady> that's just an optional call, okay if it fails

[14:01] <wolverian> and $_.priority can be .priority

[14:02] *** donaldh joined
[14:02] <TimToady> line 110 has --> for ->

[14:02] * masak fixes those issues

[14:02] <masak> TimToady++

[14:03] <wolverian> lines 155-156 have extra ;s 

[14:03] <wolverian> and are they missing ...s

[14:03] <wolverian> ?

[14:03] <PerlJam> the extra semicolons there are harmless.

[14:03] <masak> probably.

[14:04] <masak> aye.

[14:04] <masak> removed them anyway.

[14:04] <masak> wolverian++ PerlJam++

[14:05] <TimToady> and for some reason STD doesn't like the CONTROL block, but probably a STD bug

[14:05] <TimToady> also, it didn't like the use of URI without declaraiton

[14:05] <wolverian> can self.*foo be written .*foo? :)

[14:05] <TimToady> not unless $_ === self

[14:06] <wolverian> yeah, well, it is there. I mean the syntax .? syntax without the preceding noun.

[14:06] <masak> at this point I'd like to point out that this is only a draft. :)

[14:06] <wolverian> s:1st/syntax//

[14:06] <TimToady> std: say .*foo

[14:06] <wolverian> masak: but it is so much fun to bikeshed...

[14:06] <p6eval> std 26679: OUTPUT«ok 00:02 35m␤»

[14:06] <wolverian> ah, yeah. thanks. :)

[14:06] <PerlJam> masak: but does rakudo reasonably grok most of it?

[14:06] <TimToady> well, it mighta found a STD bug

[14:06] <masak> wolverian: absolutely. don't mind me. :)

[14:06] <masak> PerlJam: I have no idea. I think so.

[14:07] <TimToady> ah, no, it's confused because ControlExceptionDetach isn't declared

[14:07] <TimToady> so it assumes it's a listop and eats the block

[14:07] <masak> ah.

[14:07] <masak> not much I can do about that, 'sides creating the real thing.

[14:07] <TimToady> well, could perhaps give a better error message

[14:08] <TimToady> after noting that we assumed ControlExceptionDetach was a listop

[14:08] <masak> well, if you insist. :)

[14:08] <TimToady> I insist, therefore I exist.

[14:09] <TimToady> Caesar's version of it :)

[14:09] <masak> :)

[14:09] <masak> .oO( ControlExceptionDetach iacta est... )

[14:10] *** azawawi joined
[14:10] <azawawi> hi *

[14:11] *** skids joined
[14:11] <wolverian> .oO( *.hi($azawawi) )

[14:14] *** PhatEddy joined
[14:16] <PhatEddy> rakudo: package A::B {}; say ~A::B; say ~A

[14:16] <p6eval> rakudo ee10f5: OUTPUT«B␤invoke() not implemented in class 'NameSpace'␤current instr.: '_block14' pc 84 (EVAL_20:51)␤»

[14:17] <PhatEddy> looking at RT #62900 and will probably use above as test ...

[14:17] <PhatEddy> rakudo: package A::B {}; say ~A::B

[14:17] <p6eval> rakudo ee10f5: OUTPUT«B␤»

[14:17] <PhatEddy> is that right ?

[14:17] <PerlJam> It doesn't look right to me.

[14:17] * jnthn eated a cheezburger!

[14:18] <PerlJam> Your first snippet looked like 2 bugs to me.

[14:19] <masak> ...both of which are in RT already...

[14:20] <PhatEddy> just looking at adding (or documenting tests).  If I find the RT for ~A::B I will note the # ...

[14:22] * masak looks

[14:22] <PerlJam> The tests aren't annotated with RT#s are they?

[14:23] <PhatEddy> I did a search on both rt #s in t/spec

[14:23] <masak> nope. the RT tickets are Rakudo-specific.

[14:23] <PerlJam> I would be neat if there were a way to do that though

[14:24] <masak> PhatEddy: alternatively, it might be that A::B actually should stringify to 'B'...

[14:24] <PerlJam> then when jonathan or pmichaud or whoever implements something, it could say "because these tests pass, these RT#s have been fixed"  or something

[14:25] <masak> PerlJam: I do that in almost all of my Perl 6 projects.

[14:25] <masak> PerlJam: I mark things up with a RAKUDO comment and an RT number.

[14:25] <PerlJam> rakudo:  package A::B {}; say A::B.perl;

[14:25] <p6eval> rakudo ee10f5: OUTPUT«Null PMC access in getprop()␤current instr.: 'parrot;P6object;HOW' pc 60 (runtime/parrot/library/P6object.pir:100)␤»

[14:26] <PerlJam> I wonder if that should work

[14:26] *** SamB joined
[14:26] <masak> it shouldn't throw that error, at least.

[14:26] * masak submits rakudobug

[14:26] <PerlJam> right

[14:26] <jnthn> aye

[14:26] <jnthn> I'm not entirely sure what it should do.

[14:26] <jnthn> But not that. Never that. :-)

[14:27] <PerlJam> rakudo: class A::B {};  say A::B.perl

[14:27] <p6eval> rakudo ee10f5: OUTPUT«A::B␤»

[14:27] <PerlJam> (just checking :)

[14:27] <PhatEddy> PerlJam: afaik we CAN add these tests to spec with fudges reading "#?rakudo todo 'RT #NNNNN'"

[14:27] <masak> rakudo: package A {}; say A.perl

[14:27] <p6eval> rakudo ee10f5: OUTPUT«Null PMC access in getprop()␤current instr.: 'parrot;P6object;HOW' pc 60 (runtime/parrot/library/P6object.pir:100)␤»

[14:28] <PerlJam> rakudo: class A::B {}; say A::B.WHAT

[14:28] <p6eval> rakudo ee10f5: OUTPUT«A::B()␤»

[14:28] <PerlJam> I guess it doesn't matter if the class names are just Foo or if they are Foo::Bar::Baz

[14:29] *** iblechbot left
[14:31] <ruoso> jnthn, is there a way to implement a control exception in rakudo already?

[14:32] <jnthn> ruoso: Not sure, Tene would know. I really haven't been following the exceptions work very closely.

[14:32] <ruoso> Tene?

[14:32] <jnthn> I haven't seen it done yet, though.

[14:33] <ruoso> are you there?

[14:33] <jnthn> I think he said he was quite busy this week...try leaving a message.

[14:33] <ruoso> I'll try to get that sketch code I posted above to work in rakudo

[14:35] *** goksie joined
[14:36] *** PhatEddy left
[14:37] *** [particle]1 joined
[14:41] *** payload left
[14:45] <ruoso> rakudo: role A::B { }

[14:45] <p6eval> rakudo ee10f5:  ( no output )

[14:45] <Tene> ruoso: what do you want to know about exceptions?

[14:46] <ruoso> Tene, how can I declare a custom control exception in rakudo?

[14:46] *** mizioumt joined
[14:47] <Tene> You can't.

[14:47] <pugs_svn> r26680 | lwall++ | [STD] improve error message on accidental listops

[14:47] *** abra left
[14:48] <Tene> if you can show me what that should look like in rakudo, I can implement it for you, but it might take me a few days.

[14:49] <ruoso> Tene,  well... I guess it's just a subclass of ControlException

[14:49] <ruoso> that you can call .throw on

[14:50] <Tene> and CONTROL blocks catch all subclasses of ControlException?

[14:51] <ruoso> the way you say it seems to imply that they would also be seen by CATCH blocks

[14:51] <ruoso> but it's more like

[14:51] <ruoso> .throw on a control exception will look for a CONTROL block

[14:51] <ruoso> just as

[14:51] *** frodwith joined
[14:52] <ruoso> .throw in a failure will look for a CATCH block

[14:52] <Tene> can you put this stuff in a spec test?

[14:52] *** azawawi left
[14:53] <ruoso> right... I just won't be able to do it now... I notice you when I have it there...

[14:53] <Tene> thank you

[14:53] <Tene> as jnthn said, I'm really busy with work this week, but I should have some time available.

[14:54] <TimToady> rakudo: my %h; %h.push: $*IN.slurp.join.comb.[^3]

[14:54] <p6eval> rakudo ee10f5: OUTPUT«Trailing item in Hash.push␤»

[14:54] <Tene> also, has "Is ControlException a role or a class" been debated already?

[14:55] <TimToady> rakudo: say $*IN.slurp.join.comb.[^3]

[14:55] <ruoso> Tene, every built-in type is a role

[14:55] <p6eval> rakudo ee10f5: OUTPUT«LandderBerge,␤»

[14:55] <TimToady> rakudo: say $*IN.slurp.comb.[^3]

[14:55] <p6eval> rakudo ee10f5: OUTPUT«LandderBerge,␤»

[14:55] <TimToady> rakudo: say $*IN.comb.[^3]

[14:55] <Tene> OK

[14:55] <p6eval> rakudo ee10f5: OUTPUT«IO()<0xb5fe8808>Use of uninitialized value␤Use of uninitialized value␤␤»

[14:55] <TimToady> aw

[14:56] <jnthn> Anybody know where in the specs Selector is defined?

[14:56] * jnthn can't find it...

[14:56] <ruoso> pmichaud, http://github.com/masak/web/blob/2b4a056b04b05b793773d5e76d7ba3fde1d26508/doc/web-framework-roles in line 102 is failing to parse... any clue

[14:56] <ruoso> ?

[14:56] <ruoso> jnthn, if you happen to have any clue of the above, I'd apreciate

[14:57] <jnthn> ruoso: what error?

[14:57] <TimToady> jnthn: perhaps it's really Matcher

[14:57] <ruoso> Statement not terminated properly at line 27, near "$<_parent_"

[14:57] <jnthn> ruoso: oh, because Perl 6closures in regexes aren't implemented yet.

[14:58] <jnthn> TimToady: I'll look for that. It's mentioned in the spec for WALK.

[14:58] <jnthn>     :omit(Selector)     # only classes that don't match selector

[14:58] <ruoso> jnthn, how do I workaround it?

[14:58] <TimToady> S29 sez: subset Matcher of Object where { $_.can('ACCEPTS') };

[14:59] <ruoso> jnthn, considering the specific case, which is what I need to do

[14:59] <TimToady> masak: anyway, you don't need .slurp.join

[14:59] <TimToady> and shouldn't even need the .slurp since .comb is supposed to work on filehandles

[15:00] * ruoso lunch... brb &

[15:00] <jnthn> ruoso: Actually looking at the error, it may be that we don't ahve := either...

[15:02] <TimToady> ruoso: I already said above that regex binding doesn't use :=

[15:03] *** payload joined
[15:04] <TimToady> std: / $x := (.) /

[15:04] <p6eval> std 26680: OUTPUT«##### PARSE FAILED #####␤Unrecognized regex metacharacter at /tmp/YtuKJvUOTD line 1:␤------> [32m/ $x :[31m= (.) /[0m␤    expecting any of:␤      quantifier␤       regex atom␤       rxinfix␤        ws␤Other potential difficulties:␤  Variable $x is not predeclared at

[15:04] <p6eval> ../tmp/YtuKJvUOTD line 1:␤------> [...

[15:05] <TimToady> shower &

[15:07] <masak> TimToady: .slurp.join ... I should take up coffee, it seems. :)

[15:07] <masak> TimToady: re .comb and filehandles: cool! didn't know that.

[15:08] <masak> TimToady: I don't believe .comb is currently specced to work on filehandles, though.

[15:10] <dalek> rakudo: 8009acf | jnthn++ | src/parser/actions.pm:

[15:10] <dalek> rakudo: Add lexical slot for dispatcher to store candidate list holder in methods.

[15:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8009acf6a0f19eeb4864e4031a49aa2bf55466d9

[15:12] *** riffraff joined
[15:14] *** aaronpk joined
[15:15] *** goksie left
[15:16] <[particle]1> candidate list holder?

[15:16] *** [particle]1 is now known as [particle]-

[15:16] <aaronpk> moritz_: is it possible to modify your irclog bot to also log usernames?

[15:17] <[particle]-> aaronpk: what's not logged? http://irclog.perlgeek.de/perl6/today

[15:17] <jnthn> [particle]-: Think callnext, etc.

[15:17] <skids> rakudo: @a = $*IN.lines; @a[0..2].say;

[15:17] <[particle]-> jnthn: so, list of lists?

[15:17] <p6eval> rakudo ee10f5: OUTPUT«Scope not found for PAST::Var '@a' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:105)␤»

[15:17] <skids> rakudo: my @a = $*IN.lines; @a[0..2].say;

[15:18] <p6eval> rakudo ee10f5: OUTPUT«Land der Berge, Land am Strome,Land der Äcker, Land der Dome,Land der Hämmer, zukunftsreich!␤»

[15:18] <aaronpk> [particle]-: the username associated with the nick. on my channel, usernames correspond to the person's real name, while their nick can change.

[15:18] <jnthn> [particle]-: No, a P6Invocation...I think. :-)

[15:19] <[particle]-> i need to review a few of jnthn++'s commits today

[15:19] <jnthn> [particle]-: I'm not really expecting to get this lot right on the first attempt. Done some planning of course, but taking more the "baby steps" approach. :-)

[15:20] *** donaldh left
[15:21] *** donaldh joined
[15:22] <[particle]-> so, is this P6Invocation a cache that gets invalidated if a method is injected into the class/object after the initial invocation?

[15:22] <jnthn> [particle]-: No, it's more iterator-ish.

[15:24] <jnthn> It'll need to end up doing Iterator-ish stuff.

[15:24] <[particle]-> so if a multi is added/deleted during dispatch, it'll DTRT?

[15:24] <jnthn> It's not just about multi.

[15:24] <[particle]-> yes, that's an example.

[15:24] <jnthn> And it's generated per invocation (for now...)

[15:24] <jnthn> No, it's not about caching at all.

[15:25] <jnthn> It's also missing most of what it'll eventually need.

[15:25] <jnthn> Baiscally at the moment we do something like...

[15:25] <jnthn> $P0 = find_method obj, 'name'

[15:25] <[particle]-> will it work like for @a { @a.pop } ?

[15:25] <jnthn> $P0(...)

[15:26] <[particle]-> ...i'm thinking about edge cases again...

[15:26] <jnthn> Apart from callmethodcc encapsulates it a bit...but it boils down to a find_method and then an invoke vtable call.

[15:26] <[particle]-> ok

[15:26] <[particle]-> that makes sense.

[15:26] <jnthn> Anyway, find_method instead of handing back just the method will wrap it up in one of these, and give it enough stuff that it can (lazily usually) produce the rest of the candidates if needed.

[15:27] *** abra joined
[15:27] <jnthn> It will also on invoke fudge itself into the lexpad of the method it invokes.

[15:27] <jnthn> That way, callnext anf friends can find this thing and use it to obtain the Next Thing to invoke.

[15:27] <jnthn> At the moment it's not that far along.

[15:28] <jnthn> My plan for now is to just handle the $foo.*@candidates() case.

[15:28] <jnthn> Where we already have a list of candidates.

[15:28] <[particle]-> yeah, i get the idea.  seems it's pretty clear in your head, at least at this level

[15:29] <jnthn> Well, still various bits to figure out, and the current way isn't as performant as I'd like to end up with.

[15:30] <jnthn> But so far, things have gone pretty smoothly.

[15:30] <jnthn> Fudging the thing into the lexpad Just Worked at least...got a short PIR test script for P6Invocation checked in.

[15:31] <jnthn> Anyway, now I'm diverting attention to the meta-class stuff.

[15:31] <TimToady> masak: ./S32-setting-library/Str.pod:You may also comb lists and filehandles.  C<+$*IN.comb> counts the words on

[15:31] <jnthn> Want to get a bunch of things added into there, or a first cut.

[15:31] <jnthn> Then try and write .WALK entirely in terms of the meta-class methods.

[15:32] <masak> TimToady: oh, ok.

[15:32] <TimToady> rakudo: $*IN.lines(3).say

[15:32] <p6eval> rakudo 8009ac: OUTPUT«Land der Berge, Land am Strome,Land der Äcker, Land der Dome,Land der Hämmer, zukunftsreich!␤»

[15:32] <masak> TimToady: mind if I mention it in IO.pod too?

[15:32] <TimToady> skids: ^

[15:32] <TimToady> not at all

[15:32] * masak mentions

[15:32] <jnthn> Plus the tedious work of going through Rakudo and finding everywhere we cheated and didn't use the metaclass and really should be...

[15:32] * jnthn digs back in

[15:33] <skids> rakudo: regex ldb12l { ^^ Land .* $$ <.ws> ^^ Land .* $$ } ; join("\n", $*IN.lines(3)).match(/<ldb12l>/).say;

[15:33] <p6eval> rakudo 8009ac: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤»

[15:33] <[particle]-> convert to metaclass access first, then rip out old code?

[15:34] <jnthn> Well, more replace the code that doesn't use the metaclass to use the metaclass.

[15:34] <skids> rakudo: rule ldb2 { ^^ Land .* $$ }; regex ldb12 { ^^ Land .* $$ <ldb2> };  join("\n", $*IN.lines(3)).match(/<ldb12>/).say;

[15:34] <p6eval> rakudo 8009ac: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤»

[15:35] <jnthn> At some point I think we'll need to give Rakudo its own metaclass distinct from the one used by the toolchain stuff.

[15:35] <[particle]-> but not yet.

[15:36] <TimToady> skids: . match everything, did you mean \N?

[15:36] <TimToady> or are you testing backtracking?

[15:36] <jnthn> Not yet, but probably not too far into the future.

[15:37] <skids> I'm trying to figure out why embedding a rule in a regex is doing non-dwimmy things with $$ and ^^.

[15:37] <skids> rakudo: rule ldb2 { ^^ Land .* $$ }; regex ldb12 { ^^ Land .* $$ <ldb2> };  join("\n", $*IN.lines(2)).match(/<ldb12>/).say;

[15:37] <jnthn> Anyway, this should get us towards having our representation vs metaclass story somewhat more sorted out.

[15:37] <p6eval> rakudo 8009ac: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤»

[15:37] <TimToady> what do you "mean" by .?

[15:37] <skids> Bizarre, I must be doing something different on my script here.

[15:38] <TimToady> .* is going to match multiple lines

[15:38] <PerlJam> skids: perhaps you want \N instead of . ?

[15:38] <skids> Erm, . == end of English sentence

[15:38] <skids> :-)

[15:38] <PerlJam> skids: or maybe you want to make * less greedy ?

[15:39] <TimToady> are you trying to match one line?

[15:39] <skids> No, it's actually doing what I want, just not on my own install.

[15:57] *** ilogger2 joined
[15:58] *** SamB joined
[15:58] <jnthn> rakudo: sub foo() { }; say &foo.name

[15:58] <p6eval> rakudo 8009ac: OUTPUT«Method 'name' not found for invocant of class 'Perl6Sub'␤current instr.: 'parrot;P6metaclass;dispatch' pc 243661 (src/gen_actions.pir:0)␤»

[15:58] <moritz_> aaronpk: what do you mean? user names appear in the log

[16:00] <aaronpk> moritz_: i only see a "nick" column, no "username" column

[16:00] <moritz_> aaronpk: what would you want to appear in the username?

[16:00] *** cognominal joined
[16:00] <moritz_> the ircname?

[16:01] <aaronpk> when i join an irc server i enter a "nick" and a "username". in my channel, usernames correspond to people's real names, while the nick can change. i want to log their real names too

[16:02] <moritz_> aaronpk: that's not available in the channels I log, so I won't implent it. Of course you're free to do it yourself

[16:02] <moritz_> afk

[16:03] <aaronpk> moritz_: in this channel your username is set to "i=moritz". that's the field i'm trying to get to

[16:03] *** hercynium joined
[16:03] <skids> rakudo: rule ldb2 { ^^ Land \N* $$ }; regex ldb12 { ^^ Land \N* $$ <ldb2> };  join("\n", $*IN.lines(3)).match(/<ldb12>/).say;

[16:03] <p6eval> rakudo 8009ac: OUTPUT«Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤»

[16:04] <Matt-W> Woohoo, another working day over

[16:04] <skids> OK, why does that match the second two lines and not the first two, tuens out to be my problem.

[16:04] *** eMaX joined
[16:08] <pmichaud> ruoso:  (line 102)   PGE might not like the leading underscore in the rule name.  I'm also pretty sure it doesn't know what to do with <$act.regex>

[16:10] <pmichaud> good morning, #perl6

[16:10] <Tene> good morning, pmichaud

[16:10] *** justatheory joined
[16:11] <masak> good time of day, pmichaud.

[16:11] <jnthn> morning, pmichaud 

[16:12] <skids> rakudo: rule l { ^^ L $$ }; "\n\nL".match(/<l>/).say;

[16:12] <p6eval> rakudo 8009ac: OUTPUT«␤␤L␤»

[16:12] <skids> rakudo: rule l { ^^ L $$ }; "\nL\n".match(/<l>/).say;

[16:12] <p6eval> rakudo 8009ac: OUTPUT«␤»

[16:12] <skids> rakudo: rule l { ^^ L $$ }; "L\n\n".match(/<l>/).say;

[16:12] <p6eval> rakudo 8009ac: OUTPUT«␤»

[16:14] <jnthn> pmichaud: It turns out that I can use multis to make the old and current forms of the metaclass methods co-exist.

[16:14] <pmichaud> jnthn: excellent.

[16:14] <jnthn> pmichaud: Added the other variants locally just throwing exceptions, then ran through all of the p6object, nqp, pge and rakudo tests to make sure we never call the wrong one. All passing.

[16:14] <ruoso> pmichaud, but it was supposed to accept the leading underscore, right?

[16:14] <pmichaud> ruoso: yes, it should.

[16:15] <ruoso> righ

[16:15] <pmichaud> rakudo:   regex _abc { foo };    "xyz foo bar".match(/<_abc>/).say;

[16:15] <p6eval> rakudo 8009ac: OUTPUT«foo␤»

[16:15] <pmichaud> hmm, looks like the leading underscore isn't the problem.

[16:16] <ruoso> yeah... it still fails here...

[16:16] <pmichaud> Okay, I think it's the <$act.regex> that it's having difficulty.

[16:16] <ruoso> let me get it into a variable first

[16:16] <pmichaud> probably won't help -- PGE doesn't know what to do with (Perl 6) variables yet.

[16:17] <ruoso> hmm...

[16:17] <ruoso> how do I work-around it?

[16:17] <pmichaud> maybe put it into a sub variable

[16:17] <pmichaud> my &regex = $act.regex;

[16:17] <pmichaud> .... / <regex> /

[16:18] <pmichaud> that might work.

[16:18] <ruoso> cool

[16:18] <ruoso> gone to another problem now

[16:19] <ruoso> how do I work around the { make $act } 

[16:19] <ruoso> ?

[16:19] *** goksie joined
[16:19] *** icwiener_ joined
[16:19] <pmichaud> that one's tougher.

[16:20] <pmichaud> I'm not sure how to grab $act reliably.

[16:20] <ruoso> maybe using a closure...

[16:20] <ruoso> and invoking it with <foo>

[16:22] <ruoso> how should a closure be written to replace { make $act }? 

[16:22] <pmichaud> I'm not sure.

[16:23] <ruoso> does it receive the match object as argument?

[16:23] <pmichaud> {{ ... }}   will get a match object in the 'match' register... but the internals are PIR

[16:23] <pmichaud> one could do

[16:23] <pmichaud> {{ match.'!make'( ... ) }}

[16:23] <pmichaud> but I'm not sure how to get $act

[16:24] <ruoso> right... 

[16:24] <ruoso> in the previous suggestion

[16:24] <ruoso> I created a perl 6 level closure that is invoked as a rule

[16:24] <ruoso> does this rule receive the outer match?

[16:24] <pmichaud> yes, the current match object is the invocant.

[16:24] <pmichaud> (I'm not sure that's correct Perl 6, but that's what PGE does.)

[16:25] <ruoso> so, in theory, I could call the same method in Perl 6 level, couldn't i?

[16:25] <ruoso> like...

[16:25] <moritz_> +        my $m = $¢.explain_mystery();

[16:25] <moritz_> TimToady++

[16:25] <ruoso> my &cl = -> $match { $match."!make"( $act ) };

[16:25] <pmichaud> sub make_act( $/ ) { make $act }   # might work

[16:25] <ruoso> just calling make ?

[16:26] <pmichaud> make always works on its caller's lexical $/

[16:26] <pmichaud> which we set to the invocant parameter here.

[16:26] <ruoso> cool

[16:26] <ruoso> it parses, at least  ;)

[16:26] <ruoso> pmichaud, hmm... it doesn't seem to support <@subregexes>

[16:27] <pmichaud> anything dealing with Perl 6 level variables we don't support yet.

[16:27] <PerlJam> rakudo: %*h.push: 1 => 2; %*h.perl.say

[16:27] <p6eval> rakudo 8009ac: OUTPUT«{}␤»

[16:27] <ruoso> right... right... 

[16:27] <pmichaud> Keep in mind that Parrot has only had working lexicals in the last 6 months.  PGE hasn't had a chance to catch up on that yet.

[16:27] <PerlJam> rakudo: %*h = (); %*h.push: 1 => 2; %*h.perl.say

[16:27] <p6eval> rakudo 8009ac: OUTPUT«{"1" => 2}␤»

[16:28] <ruoso> pmichaud, right... I assume I could as well write a closure to emulate <@subregexes>...

[16:28] <pmichaud> ruoso: likely.

[16:29] <ruoso> should it return a new match?

[16:29] <pmichaud> yes.

[16:29] <ruoso> or false, if none match

[16:29] <pmichaud> it returns a false match if no match

[16:29] <ruoso> is it?

[16:29] <pmichaud> it always returns a match

[16:29] <ruoso> how do i get a false match?

[16:29] <ruoso> in Perl 6

[16:29] <pmichaud> in PGE, set the match's .to value to be less than its .from

[16:30] <pmichaud> that indicates a boolean false

[16:30] <ruoso> less or equal? or just less

[16:30] <pmichaud> less

[16:30] <pmichaud> equal means a zero-length match.

[16:30] <pmichaud> (but successful)

[16:30] <ruoso> ok

[16:31] <PerlJam> rakudo: %*h = 1; %*h.push: 1 => 2; %*h.perl.say

[16:31] <p6eval> rakudo 8009ac: OUTPUT«Odd number of elements found where hash expected␤current instr.: 'parrot;Perl6Hash;!STORE' pc 9254 (src/classes/Hash.pir:237)␤»

[16:31] <PerlJam> rakudo: %*h.push: 1 => 2; %*h.perl.say

[16:31] <p6eval> rakudo 8009ac: OUTPUT«{}␤»

[16:31] <pmichaud> shouldn't %*h be giving errors as undeclared on all of these?

[16:32] <Infinoid> pmichaud: (PGE catching up with parrot lexicals) is that a pmichaud-only task, or is it something you can use some help with?

[16:32] <pmichaud> s/shouldn't/should/

[16:32] <PerlJam> dunno

[16:32] <Infinoid> (I've been meaning to learn some more about that side of parrot.)

[16:32] <PerlJam> (I would guess yes, but I haven't read the spec on globals recently)

[16:32] <pmichaud> Infinoid: since PGE's parser is about to be significantly rewritten to match STD's version of regexes, I'm not sure I'd inflict it on anyone else.

[16:33] <PerlJam> rakudo: eval "%*h = 1"; %*h.perl.say; %*h.push: 1=>2; %*h.perl.say;

[16:33] <Infinoid> Oh, that does sound daunting.  Oh well, I'm still a willing victim for lesser tasks

[16:33] <p6eval> rakudo 8009ac: OUTPUT«{}␤{"1" => 2}␤»

[16:33] <TimToady> in STD a false match is a return of (), since the model is using lazy lists to represent possible paths forward

[16:33] <TimToady> but we're not returning match objects, rather cursors

[16:33] <TimToady> lists of cursors

[16:33] <ruoso> rakudo: "a" ~~ /a/; my $clone = $/.clone; $clone.to = $clone.from - 1; say $clone.perl;

[16:34] <p6eval> rakudo 8009ac: OUTPUT«Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ ast  => "",␤ Str => "",␤ from => 0,␤ to   => -1,␤)␤»

[16:34] <pmichaud> ruoso: right now I think that creating a new Match object  (via Match.new)   returns one that is "false"

[16:34] <pmichaud> TimToady: a regex should generally return Match objects, though, yes ?

[16:34] <ruoso> rakudo: my $m = Match.new; say $m.perl;

[16:34] <p6eval> rakudo 8009ac: OUTPUT«too few arguments passed (1) - 3 params expected␤current instr.: 'parrot;PGE;Match;new' pc 28 (compilers/pge/PGE/Match.pir:57)␤»

[16:35] <pmichaud> arggh.

[16:35] <moritz_> rakudo: my $m = Match.new(0, 1); say $m.erl

[16:35] <pmichaud> ruoso: okay, false lead I guess.  Sorry about that.

[16:35] <p6eval> rakudo 8009ac: OUTPUT«positional inside named args at position 2␤current instr.: 'parrot;PGE;Match;new' pc 28 (compilers/pge/PGE/Match.pir:57)␤»

[16:35] <moritz_> rakudo: my $m = Match.new(0, 1); say $m.perl

[16:35] <p6eval> rakudo 8009ac: OUTPUT«positional inside named args at position 2␤current instr.: 'parrot;PGE;Match;new' pc 28 (compilers/pge/PGE/Match.pir:57)␤»

[16:35] <ruoso> pmichaud, is it ok to clone the input match?

[16:35] <moritz_> rakudo: my $m = Match.new(:from(0), :to(1)); say $m.perl

[16:35] <pmichaud> ruoso: yes.  You might even ben able to do  $/.new

[16:35] <p6eval> rakudo 8009ac: OUTPUT«invalid arg type in named portion of args␤current instr.: 'parrot;PGE;Match;new' pc 28 (compilers/pge/PGE/Match.pir:57)␤»

[16:35] <TimToady> pmichaud: a regex should return something that *does* Match; in STD it also happens to be a Cursor

[16:36] <TimToady> and an instance of the current language

[16:36] <pmichaud> TimToady: okay, got it.

[16:36] *** azawawi joined
[16:37] <TimToady> all the .MATCHIFY methods make sure the current Cursor looks like a valid Match object

[16:37] <moritz_> wollmers: r26676 confuses me - why did you fudge that test? was it failing?

[16:38] <TimToady> and also happen to call the implicit reduction action, which is why we don't need {*}

[16:38] <ruoso> pmichaud, hmm... how do I invoke another regex from inside the closure? should I just use the sub form? 

[16:38] <pmichaud> ruoso: yes, that should work.

[16:39] <jnthn> pmichaud: If we're going to add a parrotopaque kinda PMC (along the lines of p6opaque without without the Perl 6 specific bits...will add thsoe in a subclass), should it be a dynpmc? Is this something we need to ask about in parrotsketch?

[16:39] <ruoso> okay... it compiles now...

[16:40] <pasteling> "ruoso" at 189.97.249.112 pasted "work-around over <@subregexes>" (17 lines, 422B) at http://sial.org/pbot/36399

[16:40] <pmurias> ruoso: out of curiosity what are you using Perl 6 rules for?

[16:40] <pmichaud> jnthn: I still haven't figured out the criteria for what should be a dynpmc and what shouldn't.

[16:41] <ruoso> pmurias, I'm working on getting the regex based dispatch for the web framework

[16:41] <ruoso> pmichaud, does the above paste look sane?

[16:41] <TimToady> ruoso: in the STD model, you always invoke as a method using some Cursor or other

[16:41] <jnthn> pmichaud: OK, I'll try and remember to ask in #ps.

[16:41] <ruoso> TimToady, I'm not sure what that means...

[16:42] <pmichaud> jnthn: allison has been mentioning that things like CodeString ought to become dynpmcs

[16:42] <TimToady> there's no such thing as an implicit "current match state"

[16:42] <TimToady> it's all explicitly represented with Cursor objects, which you can think of as a kind of continuation

[16:42] <ruoso> right... 

[16:42] <jnthn> pmichaud: I don't mind if it's a dynpmc or core myself, just would rather know and do it right first time.

[16:42] <ruoso> TimToady, but how does that look like in code?

[16:42] <TimToady> so {{ return () }} means there are no more possibilities to try

[16:42] <pmichaud> what's the advantage to having it as a dynpmc?

[16:43] <TimToady> ruoso: see STD.pm :)

[16:43] <TimToady> it's all over the place

[16:43] *** lambdabot joined
[16:43] <pmichaud> TimToady: how closely do you feel that PGE needs to follow that particular model ?

[16:43] <jnthn> pmichaud: Only needs to be in memory if it's being used by something, so doesn't bulk up the Parrot executable I guess.

[16:43] <TimToady> methods are called self.meth or $¢.meth

[16:43] <ruoso> TimToady, right... but I don't have a grammar here

[16:44] <pmichaud> jnthn: let's put it this way.  Anything using PGE or PCT will end up using P6object.

[16:44] <jnthn> pmichaud: However, as it's going to be used by everything that uses the compiler tools...otoh, so is CodeString...

[16:44] <TimToady> where self is the state upon entering the regex, and $¢ is the current match state passed into the closure

[16:44] <ruoso> I just have a bunch of anon regexes

[16:44] <pmichaud> jnthn: right, which is why I didn't understand why CodeString ought to become a dynpmc.

[16:44] <jnthn> pmichaud: Me either, since PCT is the likely route for most people building compilers.

[16:45] <pmichaud> I mean, if it's _always_ used, then having it as a dynpmc would seem to actually slow things down and increase resource usage.

[16:45] <jnthn> Right.

[16:45] <ruoso> does rakudo support $¢?

[16:45] <TimToady> ruoso: those are called by assuming the current namespace is a class, and token is a method

[16:45] <pmichaud> ruoso: not yet.

[16:45] <TimToady> even if the current namespace isn't really a class

[16:45] <moritz_> that's easy in Perl 5 ;-)

[16:46] <jnthn> pmichaud: OK, let's try get a general answer form allison in #ps since it would seem whatever applies to CodeString is the rule to follow for parrotopaque.

[16:46] <pmichaud> I still haven't gotten my brain completely around the 'what is a Cursor and what does it do?' yet.

[16:46] <pmichaud> jnthn: sounds good.

[16:46] <ruoso> so I presume the paste above is the sanest way to do it in current parrot/rakudo

[16:47] <pmichaud> yes, keeping in mind that the @subregexes isn't going to handle backtracking into the regex the way it's written there.

[16:48] <ruoso> you mean the closure wouldn't backtrack...

[16:48] <pmichaud> right

[16:48] <pmichaud> so once it finds a match, you're stuck with that one.

[16:49] <ruoso> ok... I think I don't need it to backtrack at this point...

[16:49] <ruoso> and since it's a work-around... I think it's enough as it is now...

[16:50] <pmichaud> (in case my earlier message got overlooked in the flood)

[16:50] *** lambdabot left
[16:50] <pmichaud> TimToady:  how closely do you feel that PGE ought to be following STD's model of Cursor/Match interaction?

[16:53] *** lambdabot joined
[16:58] <TimToady> closely enough that the closures in STD run :)

[16:59] <TimToady> but the basic distinction is that Cursors are immutable, and backtracking consists only of throwing away Cursors, not modifying anything to its privious state

[17:00] *** hercynium left
[17:00] <TimToady> having mutable match states is just asking for reentrancy problems

[17:00] <TimToady> see P5

[17:02] <TimToady> that being said, one of the optimizations that STD does is re-using cursors that can't backtrack due to ratcheting.  but that's cheating

[17:03] *** barney joined
[17:03] <pmichaud> yes, I'm not quite sure how this all maps into PGE's current model, where backtracking states are actually managed by the program counter

[17:03] <pmichaud> and backtracking instantly jumps back to the point of the backtrack

[17:04] <[particle]-> timtoady: does that break with :keepall?

[17:04] <moritz_> I think that's orthogonal

[17:04] <pmichaud> I don't mind chucking PGE's current model in favor of something else... but I need to understand the something else a bit clearer.

[17:04] <moritz_> :keepall is about keeping matches, backtracking is about finding them

[17:06] <[particle]-> i'm not clear on the semantics of :keepall, i should reread before asking.  wondered if it kept the state of the backtracking, too.  how 'all' is 'all'?

[17:06] *** pmurias_ joined
[17:07] <moritz_> :keepall forces non-capturing subrules to capture

[17:07] <TimToady> I should probably split out the methods in Cursor.pmc a little better, but basically all the methods starting at _MATCHIFY are the regex engine

[17:07] <moritz_> and it also augments matched literals with match positions etc

[17:07] <moritz_> but it doesn't provide backtracking information

[17:08] <pmichaud> TimToady: okay, that's a very useful guidepost.

[17:08] <TimToady> everything down to sub bless

[17:08] <TimToady> after that is longest token extractor

[17:08] * ruoso introduces "Faz" - the action dispatching framework... http://github.com/ruoso/faz/tree/master

[17:09] <[particle]-> simple comments in the code could help others

[17:09] <TimToady> 'couse, none of it makes much sense without seeing how it's called from STD.pmc

[17:09] <ruoso> unfortunally it dies with Null PMC at this point ;)

[17:09] <moritz_> STD.pm is version 5.0.0.alpha? ;-)

[17:10] <pugs_svn> r26681 | lwall++ | [STD] correct version, moritz++

[17:11] <TimToady> and that STD.pmc code has two basic forms, depending on ratcheting

[17:11] <TimToady> the ratchet code is assiduously avoiding calls to lazymap(), since that's slow to emulate in p5

[17:12] <jnthn> I'm trying to get the varous orderings that WALK suppots into my head.

[17:12] <jnthn> Can somebody review http://gist.github.com/107058 ?

[17:12] <TimToady> my nefarious plan is to retarget viv at some point to putting out rakudo code

[17:12] <TimToady> it would be nice if lazy lists were implemented by then :)

[17:13] <moritz_> TimToady: thanks for your p6l mail

[17:13] <pmichaud> TimToady: they're on their way, actually.

[17:13] <pugs_svn> r26682 | azawawi++ | [S:H:P6] Added 'tmp_prefix' to control where STD stores its temporary files.

[17:13] *** pmurias_ left
[17:13] <ruoso> pmichaud, I'm getting a null pmc and I'm not sure where it is coming from... the code is the one at http://github.com/ruoso/faz/tree/master

[17:13] <jnthn> In what I just pasted breadth and ascendent end up looking the same. Can somebody explain the difference to me?

[17:13] <TimToady> I use roles heavily too, which would be much more difficult in p5 without moose

[17:14] <jnthn> (or show me an example where it differs)

[17:14] <pmichaud> ruoso: in general I refer Null PMC accesses in class-related stuff to jnthn++  :-)

[17:14] <jnthn> ruoso: in general I refer Null PMC accesses in regex related stuff to pmichaud++

[17:14] <jnthn> ;-)

[17:14] <[particle]-> ascendent isn't F E B A C D?

[17:14] <jnthn> [particle]-: Maybe but that'd make it the same as pre-order. ;-)

[17:15] *** eMaX left
[17:15] <[particle]-> ah, hrmm.

[17:15] <TimToady> moritz_: actually sent that mail earlier, but my mailq was clogged

[17:15] <PerlJam> jnthn: you just don't have enough node to elucidate the difference adequately  :)

[17:15] <jnthn> PerlJam: You got a better example?

[17:15] <moritz_> TimToady: np, from your commits I figured that while the syntax was a bit wrong, it couldn't be all that bad ;-)

[17:16] *** ejs joined
[17:16] <jnthn> PerlJam: I can't think of one right off that makes it clearer...

[17:16] <PerlJam> me either.

[17:16] <jnthn> PerlJam: Or does it more show up when a class appears multiple times in an inheritance hierarchy?

[17:16] <jnthn> Ah, OK.

[17:17] <[particle]-> what i you hook the A over the C?

[17:17] <TimToady> still working on the tests that try to modify regex syntax though.  need to work out syntax for deriving new sublanguages inline

[17:17] <TimToady> merely declaring a token doesn't make it a token for the language you're using for the rest of the block

[17:18] <pugs_svn> r26683 | azawawi++ | [Cursor] Added 'tmp_prefix' to control where STD stores its temporary files.

[17:18] <TimToady> and have to be able to derive new Q or Regex language while not in those languages too

[17:18] <moritz_> hrm

[17:18] <TimToady> what we have is five or six different langauges braided together

[17:19] <TimToady> and normal Perl has to be able to redefine any of the braids for the lexical scope

[17:19] <ruoso> jnthn, btw... the null pmc issue was because the role was indirectly loaded, so the parser recognized the name, but the name wasn't installed in the current namespace

[17:19] <jnthn> [particle]-: Not much different from what I can see

[17:19] <TimToady> something like language Q { token backslash:<Y> {...} }

[17:19] *** icwiener-_- joined
[17:19] <jnthn> ruoso: Ah, are you using nested namespaces?

[17:20] <ruoso> yes... 

[17:20] <ruoso> Faz::Action::Chained

[17:20] <jnthn> Those are quirky at the moment.

[17:20] <ruoso> but it solves it if I use explicitly 

[17:20] <jnthn> OK, but you wrote a role inside one of them. That's probably what it didn't like.

[17:20] <Matt-W> yeah I have to do that

[17:20] <moritz_> TimToady: but if it's available in regexes and not double quoted strings... should it still go into language Q?

[17:20] <jnthn> OK.

[17:20] <TimToady> and the current rule_backslash category is completely bogus

[17:20] <TimToady> no, then it'd go into Regex

[17:20] <ruoso> jnthn, it still don't support yada methods in roles, right?

[17:21] <TimToady> what's going on from the user's point of view is that $?Regex or some such is redefined for the rest of the scope

[17:21] <jnthn> ruoso: no

[17:21] <TimToady> from the view of the compiler it's a dynamic variable $*Regex

[17:22] <[particle]-> jnthn: i'd wander over to #moose and ask stevan or nothingmuch

[17:22] <TimToady> that's what my previous change to STD did, make dynamic variables for the braids

[17:22] <jnthn> [particle]-: Yeah, good plan. Will do so after dinner.

[17:22] <TimToady> (already had one for $*LANG, but just generalized the braiding notion)

[17:23] <TimToady> (a lot of these context vars probably want to be tied to the Cursor eventually instead; I'm using dynamic scoping at the moment for speed under P5)

[17:25] <ruoso> rakudo: class A { method a { say 'a' } }; class B { has A $.other is rw = A.new handles a }; say B.new.a;

[17:25] <p6eval> rakudo 8009ac: OUTPUT«Statement not terminated properly at line 1, near "handles a "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[17:25] <TimToady> basically, as soon as the user starts redefining the current language, all the affected languages in the braid become anonymous grammars

[17:26] <ruoso> rakudo: class A { method a { say 'a' } }; class B { has A $.other is rw handles <a> = A.new }; say B.new.a;

[17:26] <p6eval> rakudo 8009ac: OUTPUT«Unable to set lvalue on PAST::Val node␤current instr.: 'parrot;PAST;Val;lvalue' pc 623 (src/PAST/Node.pir:163)␤»

[17:26] <TimToady> I already do that for infix:<foo> and such, but needs to extend to explicit derivation with a mixed in new grammar (including by import)

[17:27] <ruoso> how do I define an attribute that is rw, that handles some methods and has a default value?

[17:27] <TimToady> well, enuff branedump

[17:27] <pmichaud> TimToady++ # thanks for branedump, very helpful

[17:27] <moritz_> better braindump than brain dumb

[17:27] <jnthn> ruoso: Hmm. That doesn't look wrong...

[17:28] <jnthn> rakudo: class A { method a { say 'a' } }; class B { has A  $.other handles <a> = A.new }; say B.new.a;

[17:28] <p6eval> rakudo 8009ac: OUTPUT«Unable to set lvalue on PAST::Val node␤current instr.: 'parrot;PAST;Val;lvalue' pc 623 (src/PAST/Node.pir:163)␤»

[17:28] <[particle]-> is it parsing <a> = A.new ?

[17:28] *** ejs left
[17:28] <jnthn> That's be surprising...

[17:29] <ruoso> std: class A { method a { say 'a' } }; class B { has A $.other is rw handles <a> = A.new }; say B.new.a;

[17:29] <jnthn> rakudo: class A { method a { say 'a' } }; class B { has A  $.other handles <a> }; say B.new(a => A.new).a;

[17:29] <p6eval> std 26683: OUTPUT«ok 00:03 38m␤»

[17:29] <p6eval> rakudo 8009ac: OUTPUT«a␤1␤»

[17:29] *** estrabd joined
[17:29] <pmichaud> jnthn:

[17:29] <pmichaud> rule trait_verb { [ | $<sym>=[of|returns] <typename> | $<sym>=[handles] <EXPR>

[17:29] <pmichaud> note <EXPR>

[17:30] <jnthn> That'd be it...

[17:30] <pmichaud> so that ends up grabbing  <a> = A.new

[17:30] * jnthn checks STD

[17:30] <[particle]-> there you go.

[17:30] <jnthn> rule trait_verb:handles {<sym> <noun> }

[17:30] <jnthn> That's the one.

[17:31] * jnthn will fix later tonight

[17:32] <pugs_svn> r26684 | azawawi++ | [S:H:P6] version 0.51 includes tmp_prefix and latest STD

[17:32] <jnthn> OK, dinner time, before #parrotsketch

[17:35] *** icwiener_ left
[17:38] <TimToady> pmichaud: one other note about Cursor.pmc, the quantifying methods are tagged with r, g, f for ratchet, greedy, frugal

[17:38] <TimToady> and _rev is for reverse matching for afterness

[17:42] *** LylePerl joined
[17:43] *** szabgab joined
[17:48] <ruoso> rakudo: class A { has $!rx; method do { $!rx = / some regex / }; }; A.new.do; #pmichaud

[17:48] <p6eval> rakudo 8009ac: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;PGE;Match;new' pc 33 (compilers/pge/PGE/Match.pir:65)␤»

[17:48] <ruoso> rakudo: class A { has $!rx; method do { $!rx = / some regex /; 1}; }; A.new.do; #pmichaud

[17:48] <p6eval> rakudo 8009ac:  ( no output )

[17:48] <ruoso> if the regex fall out as the implicit return, it causes the null pmc

[17:49] <ruoso> rakudo: class A { has $!rx; method do { $!rx }; }; A.new.do; #pmichaud

[17:49] <p6eval> rakudo 8009ac:  ( no output )

[17:49] <ruoso> rakudo: class A { has $!rx; method do { $!rx = 1}; }; A.new.do; #pmichaud

[17:49] <p6eval> rakudo 8009ac:  ( no output )

[17:50] <ruoso> it's regex related

[17:50] <pmichaud> rakudo: class A { has $!rx; method do { $!rx = { say 1; } }; }; A.new.do;

[17:50] <p6eval> rakudo 8009ac:  ( no output )

[17:50] * ruoso submitted rakudobug

[17:51] <pmichaud> rakudo: class A { has $!rx; method do { $!rx = regex { some regex} }; }; A.new.do;

[17:51] <p6eval> rakudo 8009ac: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;PGE;Match;new' pc 33 (compilers/pge/PGE/Match.pir:65)␤»

[17:51] <pmichaud> It's trying to do a match.

[17:51] <ruoso> why?

[17:51] <pmichaud> something is causing the regex to be evaluated in boolean context.

[17:51] <ruoso> ah

[17:51] <ruoso> sure... at some point later

[17:51] <ruoso> maybe

[17:51] <pmichaud> I mean as part of returning the regex.

[17:52] <pmichaud> rakudo: class A { has $!rx; method do { $_ = 'foo'; $!rx = regex { some regex} }; }; A.new.do;

[17:52] <p6eval> rakudo 8009ac: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;PGE;Match;new' pc 33 (compilers/pge/PGE/Match.pir:65)␤»

[17:52] <pmichaud> hmm.

[17:53] <[particle]-> rakudo: sub a { my $x = / some regex; }; 1;

[17:53] <p6eval> rakudo 8009ac:  ( no output )

[17:53] <[particle]-> rakudo: sub a { my $x = / some regex; }; a();

[17:54] <p6eval> rakudo 8009ac: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;PGE;Match;new' pc 33 (compilers/pge/PGE/Match.pir:65)␤»

[17:54] <[particle]-> rakudo: sub a { my $x = / some regex /; }; a();

[17:54] <p6eval> rakudo 8009ac: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;PGE;Match;new' pc 33 (compilers/pge/PGE/Match.pir:65)␤»

[17:54] <[particle]-> interesting that the first one parsed.

[17:54] <pmichaud> yes, looks like a bug in the regex parser.

[17:54] <ruoso> rakudo: my $x = /some regex/; $x

[17:54] <p6eval> rakudo 8009ac: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;PGE;Match;new' pc 33 (compilers/pge/PGE/Match.pir:65)␤»

[17:54] <ruoso> rakudo: my $x = /some regex/;

[17:55] <p6eval> rakudo 8009ac: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;PGE;Match;new' pc 33 (compilers/pge/PGE/Match.pir:65)␤»

[17:55] <ruoso> rakudo: my $x = /some regex/; 1

[17:55] <p6eval> rakudo 8009ac:  ( no output )

[17:55] <pmichaud> oh, wait.  It might be a p6eval bug.

[17:55] <pmichaud> p6eval is trying to evaluate the result of A.new.do

[17:55] <pmichaud> I'm building and testing locally, though.

[17:56] <[particle]-> ah, of course.

[17:56] *** goksie left
[17:56] <pmichaud> okay, I get it locally also.

[17:56] <pmichaud> nm.

[17:56] <ruoso> it fails in rakudo directly as well

[17:56] <pmichaud> Yes, I see it here.

[17:56] *** eMaX joined
[17:57] <pmichaud> rakudo: class A { has $!rx; method do { $!rx = regex { some regex } }; }; A.new.do; 1;

[17:57] <p6eval> rakudo 8009ac:  ( no output )

[17:57] <pmichaud> there.

[17:57] <pmichaud> It's not a regex bug, at least not directly.  :-)

[17:57] <[particle]-> i found a parse bug, though :)

[17:57] <pmichaud> Something is trying to evaluate the return value of the program, and *that's* where the bug occurs.

[17:57] <ruoso> yes... it sure looks like something outside rakudo itself

[17:58] <pmichaud> anyway, the error occurs when the program itself returns a regex.

[17:59] <pmichaud> rakudo: class A { has $!rx; method do { $!rx = regex { some regex } }; }; $_ = 'foo'; A.new.do;

[17:59] <p6eval> rakudo 8009ac: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;PGE;Match;new' pc 33 (compilers/pge/PGE/Match.pir:65)␤»

[18:00] <pmichaud> okay, I think I know how to resolve this one.

[18:00] *** hercynium joined
[18:05] <pmichaud> jnthn: ping (when back from dinner)

[18:08] <pmichaud> jnthn: actually, dog needs a walk -- I'll catch you during #ps

[18:08] <pmichaud> afk 

[18:10] <ruoso> rakudo: sub foo { say $*foo }; my $foo is context = 'hello'; foo();

[18:10] <p6eval> rakudo 8009ac: OUTPUT«Use of uninitialized value␤␤»

[18:10] <ruoso> rakudo: sub foo { say $+foo }; my $foo is context = 'hello'; foo();

[18:10] <p6eval> rakudo 8009ac: OUTPUT«Scope not found for PAST::Var '$+foo' in foo␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:105)␤»

[18:11] <TimToady> std: sub foo { say $+foo }; my $foo is context = 'hello'; foo();

[18:11] <p6eval> std 26684: OUTPUT«Potential difficulties:␤  The + twigil is deprecated, use the * twigil instead at /tmp/mKDTftjOXl line 1:␤------> [32msub foo { say $+[31mfoo }; my $foo is context = 'hello'; foo[0m␤ok 00:02 36m␤»

[18:13] <ruoso> TimToady, I was aware of that... I was just wondering if rakudo was still with the old syntax... since $*foo didn't work

[18:13] <TimToady> what I figgered

[18:13] <TimToady> I was just curious what std would say

[18:14] <ruoso> rakudo: sub foo { say $*foo }; my $foo is context; $foo = 'hello'; foo();

[18:14] <p6eval> rakudo 8009ac: OUTPUT«Use of uninitialized value␤␤»

[18:14] <TimToady> it's possible rakudo still treats $* as global

[18:15] <moritz_> I think it never did "real" context vars

[18:15] <ruoso> it also seems that PGE doesn't like Perl 6 closures 

[18:16] *** Jedai joined
[18:17] <ruoso> rakudo: sub foo { my sub bar { }; return / foo <bar> /; }; my $rx = foo; say 'a' ~~ $rx;

[18:17] <p6eval> rakudo 8009ac: OUTPUT«␤»

[18:17] <ruoso> rakudo: sub foo { my sub bar { }; return / foo <bar> /; }; my $rx = foo; say 'foo ' ~~ $rx;

[18:17] <p6eval> rakudo 8009ac: OUTPUT«Unable to find regex 'bar'␤Null PMC access in invoke()␤current instr.: 'parrot;PGE;Grammar;' pc 614 (EVAL_19:239)␤»

[18:24] <pmichaud> jnthn: reping

[18:24] <pmichaud> (PGE doesn't like Perl 6 closures) -- sure, this is a long-standing issue.  :-)

[18:25] <pmichaud> rakudo still treats $* as global, yes.

[18:27] <ruoso> pmichaud, is there any support for context vars?

[18:27] <pmichaud> in regexes?

[18:27] <pmichaud> or in general?

[18:28] <pmichaud> short answer is no, rakudo doesn't haven't them yet.  We have the pieces in place for them, though.

[18:28] <ruoso> hmm... too bad

[18:29] <PerlJam> rakudo: say a => 3;  # what's going on here?

[18:29] <p6eval> rakudo 8009ac: OUTPUT«␤»

[18:29] *** ElectricHeavyLan joined
[18:29] <pmichaud> rakudo: say (a=>3);

[18:29] <p6eval> rakudo 8009ac: OUTPUT«a  3␤»

[18:29] <moritz_> p6eval: say() seemms to ignore named arguments

[18:29] <pmichaud> ah yes.

[18:29] <moritz_> sorry, meant PerlJam 

[18:29] <pmichaud> it's a named arg.

[18:29] <PerlJam> got it.

[18:29] <PerlJam> does say have any named args to accept?

[18:30] <moritz_> no

[18:30] *** goksie joined
[18:30] <moritz_> at least I can't think of any

[18:32] <ruoso> pmichaud, it seems I can't even use "my sub &foo" in the regex

[18:34] <pmichaud> ruoso:  I don't entirely understand... but basically PGE doesn't have any clue about how to parse things that aren't regex syntax.

[18:35] <ruoso> the problem is not parsing

[18:35] <pmichaud> then I fall back on the "I don't entirely understand" part.

[18:36] <ruoso> the problem is that it will look the symbol somewhere else, not in the lexical scope where the rx was defiend

[18:36] <pmichaud> it's possible that the regexes aren't properly lexically scoped, yes.  See earlier statement about "PGE hasn't caught up to Parrot lexicals yet."

[18:37] <ruoso> are you aware on a way to make it work?

[18:37] <ruoso> (I'm open to useing PIR where needed...)

[18:37] <pmichaud> not off the top of my head.  I'm sorry if it sounds like I'm being obstructionist... I just have more problems on my plate than time to fix them all.

[18:38] <ruoso> pmichaud, it didn't sound like that... ;)

[18:38] <skids> IMO say should pass named args to Str.

[18:39] <pmichaud> okay, good.  I just know I'm providing more issues than answers at the moment, and that's not a mode I'm happy about being in.

[18:39] <pmichaud> skids: hmm?

[18:40] <skids> If you want to override say with named arguments for a class, and also Str, then youhave to write in a custom say  that passes named args to Str

[18:40] <ruoso> pmichaud, anyway... I'll leave that code there for now then... the issues I'm blocking are contextual variables and closures in the regex....

[18:40] <skids> IMO that should be the default behavior.

[18:40] <pmichaud> ruoso: noted.  I might be able to get contextuals working relatively quickly.

[18:40] <jnthn> pmichaud: I'm back now

[18:41] <pmichaud> jnthn: question on P6metaclass refactors.  Ideally, what should the first argument to add_method, add_attribute, etc. be?

[18:42] <jnthn> The "prototype" (which is an instance of the representation, and what will be our proto-object.)

[18:42] *** icwiener-_- left
[18:42] <pmichaud> I think I'd like the refactored versions to accept *only* prototypes, then.

[18:42] <pmichaud> and not be calling 'get_parrotclass' to figure it out.

[18:42] <jnthn> Indeed, but we don't have those yet. :-)

[18:43] <pmichaud> the deprecated versions can do the mapping to the prototype if needed.

[18:43] <pmichaud> i.e., I don't want them to accept parrotclasses, names of classes, namespaces, etc.

[18:43] <jnthn> yes, understood. I'll try and remember that once I get parrotopaque in place; yell at me if I forget. :-)

[18:44] <pmichaud> in looking at traces of things (especially signature binds) we end up making *lots* of calls to get_parrotclass.  I'd like to optimize that out for cases where we know the incoming argument is well behaved.

[18:45] <pmichaud> And I'd like to enforce a bit more strictness on callers to only work through the prototype and not be able to pass "whatever" and have P6object dwim... at least not for those metaclass methods.

[18:45] <pmichaud> (things like 'register', 'new_class', etc. can still have some dwimminess)

[18:45] <japhb> Anyone have a link for a screenshot (or online javascript page) showing Perl 6 syntax highlighting that includes {} interpolating into a string?  I'm trying to explain the coolness to a friend, and it's clear I need a visual aid ....

[18:46] <moritz_> japhb: wait a sec...

[18:46] <japhb> moritz_: than queue

[18:46] <jnthn> Ah, signature binds. Another area that'll want some opt. :-)

[18:47] <pmichaud> well, that would be a first step.  Basically, we end up doing lots of get_parrotclass stuff whenever we're doing a typematch, and part of the reason is because the existing methods are more forgiving than they should be about the type object.

[18:48] <moritz_> japhb: http://feather.perl6.nl/~azawawi/html/spec/S02-literals/misc-interpolation.t.html has a few basic examples

[18:48] <ruoso> pmichaud, jnthn, the faz project is in http://github.com/ruoso/faz/tree ... I'll leave it there while I have those blockers... but just noting the repo so you can play with it around if you like...

[18:49] <japhb> moritz_: excellent.  I'll go wandering around near there.

[18:49] <moritz_> japhb: if you like vim, you can get http://svn.pugscode.org/pugs/util/perl6.vim

[18:50] <moritz_> it hilights interpolating closures correctly

[18:50] <japhb> I'll recommend that too him, he's a vim guy.

[18:50] <pmichaud> I wonder if perl6.vim should be distributed with Rakudo, also.

[18:50] <moritz_> if so, we should get the latest version from http://github.com/hinrik/perl-vim/

[18:51] <japhb> pmichaud: that seems like a win.

[18:52] <moritz_> (oh, it's http://github.com/hinrik/vim-perl actually)

[18:52] <[particle]-> but it violates dry

[18:52] <japhb> [particle]: git submodule ... no need to copy

[18:53] <japhb> But it can be packaged into the releases.  And (hopefully) kept in sync with changes to Rakudo.

[18:54] *** ElectricHeavyLan left
[18:55] <japhb> (The power of submodules was the one thing I thought git was really missing ... and then it got them.)

[18:55] <moritz_> japhb: do you know an introductory document to them?

[18:56] <japhb> moritz_: Hmmm, I stumbled over one a couple weeks back.  Lemme see if I can find it.

[18:58] <japhb> moritz_: A couple github links show up in my history: http://github.com/guides/developing-with-submodules and http://github.com/guides/using-git-submodules-to-track-plugins

[18:58] *** LylePerl left
[19:00] <PerlJam> japhb: you didn't think partial checkouts were something git was missing too?

[19:00] <japhb> Hmmm, and a quick scan of the Git User Manual's chapter 8 looks decent: http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#submodules

[19:00] <moritz_> japhb: thanks

[19:02] <japhb> PerlJam: Yes and no ... there are a couple repos for which a partial checkout would have been nice for me, but I always found it infuriating in my earlier SCM days when I had to expand my checkout scope ... so I eventually got in the habit of always checking out full repos.  This is a lot easier when a clone is a fast operation.  Unlike, say, in SVK.

[19:02] <japhb> OR git-svn for that matter.

[19:07] <japhb> (And to finish the flip side of the thought ... the Venn diagram describing the interaction of the MPlayer and FFMPEG repos was what convinced me submodules weren't just nice, but basically essential to maintain some semblance of sanity and convenience.  Apparently those projects felt the same.)

[19:11] *** wolv joined
[19:13] *** barney left
[19:14] <japhb> rakudo: say "Perl 6 is { « magic "sufficiently advanced technology" ».pick.uc }"

[19:14] <p6eval> rakudo 8009ac: OUTPUT«Unable to parse block; couldn't find final '}' at line 1, near "\x{ab} magic \"s"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[19:15] <japhb> std: say "Perl 6 is { « magic "sufficiently advanced technology" ».pick.uc }"

[19:15] <p6eval> std 26684: OUTPUT«ok 00:04 36m␤»

[19:15] *** donaldh joined
[19:15] <japhb> std: say "Perl 6 is { « magic 'sufficiently advanced technology" ».pick.uc }"

[19:15] <p6eval> std 26684: OUTPUT«ok 00:04 36m␤»

[19:15] <pmichaud> rakudo doesn't parse « yet, I don't think.

[19:15] <japhb> pmichaud: Ah!

[19:16] *** minazo joined
[19:16] <pmichaud> rakudo:  say "Perl 6 is { << magic 'sufficiently advanced technology" >>.pick.uc }"

[19:16] <p6eval> rakudo 8009ac: OUTPUT«Perl 6 is MAGIC␤»

[19:16] <pmichaud> rakudo:  say "Perl 6 is { << magic 'sufficiently advanced technology" >>.pick.uc }"

[19:16] <p6eval> rakudo 8009ac: OUTPUT«Perl 6 is MAGIC␤»

[19:16] <pmichaud> rakudo:  say "Perl 6 is { << magic 'sufficiently advanced technology" >>.pick.uc }"

[19:16] <p6eval> rakudo 8009ac: OUTPUT«Perl 6 is ADVANCED␤»

[19:16] <pmichaud> rakudo:  say "Perl 6 is { << magic "sufficiently advanced technology" >>.pick.uc }"

[19:16] <PerlJam> heh

[19:16] <p6eval> rakudo 8009ac: OUTPUT«Perl 6 is MAGIC␤»

[19:16] <japhb> pmichaud: had a misquote

[19:16] <pmichaud> rakudo:  say "Perl 6 is { << magic "sufficiently advanced technology" >>.pick.uc }"

[19:16] <p6eval> rakudo 8009ac: OUTPUT«Perl 6 is SUFFICIENTLY ADVANCED TECHNOLOGY␤»

[19:17] <PerlJam> the << >> parser could look for quotes and warn

[19:19] <japhb> pmichaud: Is there any reason for « » to be difficult to parse?  Or is it Unicode problems raising their collective ugly heads?

[19:19] <pmichaud> Unicode problems.

[19:19] <jnthn> The one with Parrot hashes and unicode keys?

[19:19] <pmichaud> I think so, yes.

[19:20] *** donaldh left
[19:20] *** donaldh joined
[19:21] <japhb> Is there a way to weight the choice of a .pick ?

[19:21] <japhb> (Other than copying terms to make appropriate ratios)

[19:21] <moritz_> no

[19:21] *** goksie left
[19:22] <moritz_> you could sort on weight * rand(), and then take the first one

[19:22] <moritz_> or so

[19:22] <japhb> Hmmm, actually, that's not a bad idea, mixed with some of MJD's discussions on algorithms for finding smallest terms "nearly correct" fractions

[19:22] <japhb> s/that's/copying terms/

[19:23] <japhb> well, you get the point.

[19:23] <jnthn> rakudo: my @values = 1,2,3; my @weights = 2, 4, 2; say @values >>xx<< @weights;

[19:23] <p6eval> rakudo 8009ac: OUTPUT«11222233␤»

[19:23] <jnthn> ^ easy way to do the copying terms way

[19:23] *** donaldh left
[19:23] <japhb> jnthn: nice!

[19:23] *** donaldh joined
[19:23] <arnsholt> But having an optional weights parameter might be better_

[19:24] <arnsholt> s/_/?/

[19:24] <moritz_> rakudo: my %w = a => 1, b => 2, c => 3; <a b c>.sort( { rand * %w{$_} }).[0].say

[19:24] <arnsholt> If the array to pick from is large, starting to copy might be an unreasonable suggestion

[19:24] <jnthn> arnsholt: multi pick(@list, @weights) { ... }

[19:24] <p6eval> rakudo 8009ac: OUTPUT«a␤»

[19:24] <moritz_> rakudo: my %w = a => 1, b => 2, c => 3; <a b c>.sort( { rand * %w{$_} }).[0].say

[19:24] <p6eval> rakudo 8009ac: OUTPUT«c␤»

[19:25] <moritz_> rakudo: my %w = a => 1, b => 2, c => 3; for 1..10 {<a b c>.sort( { rand * %w{$_} }).[*-1].print }

[19:25] <arnsholt> moritz_: Right. That works too

[19:25] <p6eval> rakudo 8009ac: OUTPUT«bbccccbcca»

[19:25] <moritz_> ... if I do it right, yes ;-)

[19:25] <japhb> moritz_: nice.

[19:25] <moritz_> arnsholt: pick with weight is a nice feature for a library, IMHO

[19:26] <japhb> moritz_: sure, I've got no problem with that at all.  It certainly feels more like library functionality than core to me ....

[19:26] *** azawawi left
[19:26] <arnsholt> Yeah, it sounds like a reasonably common operation

[19:26] *** ZuLuuuuuu joined
[19:34] *** lisppaste3 joined
[19:35] *** donaldh left
[19:51] * ruoso later &

[19:59] *** wolv left
[20:04] *** amoc joined
[20:06] *** amoc left
[20:06] *** wolv joined
[20:11] <dalek> rakudo: cfc5e82 | pmichaud++ | docs/spectest-progress.csv:

[20:11] <dalek> rakudo: spectest-progress.csv update: 379 files, 11011 passing, 0 failing

[20:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cfc5e82ae1e30c63a64047c168cb7a38e421fdfa

[20:17] *** amoc joined
[20:18] <jnthn> rakudo: multi foo() { }; my @a; @a.push(&foo)

[20:18] <p6eval> rakudo cfc5e8:  ( no output )

[20:25] *** PhatEddy joined
[20:26] <PhatEddy> rakudo: enum B <a> ; say B::a

[20:26] <p6eval> rakudo cfc5e8: OUTPUT«0␤»

[20:26] <PhatEddy> rakudo: enum A <a> ; say A::a

[20:26] <p6eval> rakudo cfc5e8: OUTPUT«0␤»

[20:26] <jnthn> :-)

[20:27] <jnthn> (Though that much worked just fine before the recent refactor...)

[20:28] <PhatEddy> rakudo: class A { say "This is class $?PACKAGE" }

[20:28] <p6eval> rakudo cfc5e8: OUTPUT«Scope not found for PAST::Var '$?PACKAGE' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:105)␤»

[20:28] <PhatEddy> that one was closed once I think

[20:29] <jnthn> rakudo: class A { say $?PACKAGE }

[20:29] <p6eval> rakudo cfc5e8: OUTPUT«Scope not found for PAST::Var '$?PACKAGE' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:105)␤»

[20:29] <jnthn> rakudo: module A { say $?PACKAGE }

[20:29] <p6eval> rakudo cfc5e8: OUTPUT«Scope not found for PAST::Var '$?PACKAGE' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:105)␤»

[20:29] <jnthn> Yeah, I thoguht so too.

[20:29] <PhatEddy> was RT #59484

[20:30] <PhatEddy> working on package tests ...

[20:38] *** rewt left
[20:43] *** LadyLunacy joined
[20:52] *** Kyosuke_Kiryu joined
[21:01] <PhatEddy> rakudo: package Simple { sub pkg { $?PACKAGE } }

[21:01] <p6eval> rakudo cfc5e8: OUTPUT«Scope not found for PAST::Var '$?PACKAGE' in pkg␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:105)␤»

[21:04] *** mizioumt1 joined
[21:07] *** payload joined
[21:09] *** iblechbot joined
[21:12] *** rewt joined
[21:12] *** ejs joined
[21:15] *** hercynium left
[21:19] <PhatEddy> rakudo: package Simple{class Bar {sub baz {'hi'}}}; say Simple::Bar.new.baz;

[21:19] <p6eval> rakudo cfc5e8: OUTPUT«Could not locate a method 'baz' to invoke on class 'Simple::Bar'.␤current instr.: 'die' pc 16538 (src/builtins/control.pir:225)␤»

[21:19] <PhatEddy> oops

[21:20] <dalek> rakudo: 9a1cacd | jnthn++ |  (2 files):

[21:20] <dalek> rakudo: Add .^methods and .^isa introspection methods. Also bump us up to the Parrot build where I put in the P6object changes that are needed to go with this.

[21:20] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9a1cacdcfd9cdeb4b7f7b07a4564e175bd97dc0b

[21:20] <dalek> rakudo: c77bd19 | jnthn++ | :

[21:20] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[21:20] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c77bd19af86be6eba0d3ba0362b27cdac202b754

[21:20] <PhatEddy> rakudo: package Simple{class Bar {method baz {'hi'}}}; say Simple::Bar.new.baz;

[21:20] <p6eval> rakudo cfc5e8: OUTPUT«hi␤»

[21:23] *** Kisu joined
[21:25] *** ejs left
[21:26] *** nihiliad joined
[21:33] *** iblechbot left
[21:33] *** amoc left
[21:35] *** amoc joined
[21:45] *** LadyLunacy left
[21:52] *** wknight8111 joined
[21:59] <dalek> rakudo: 53f7059 | jnthn++ | src/parser/ (2 files):

[21:59] <dalek> rakudo: STD tracking: handles trait verb followed by noun, not EXPR.

[21:59] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/53f70591a6e20a0a09a4fbccdfe91d4c7739a9d1

[22:02] *** skids joined
[22:02] <PhatEddy> rakudo: package A { enum B <a> }; package P { role B {}; class C does P::B {} }

[22:03] <p6eval> rakudo c77bd1: OUTPUT«The type P::B does not exist. at line 1, near "{} }"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[22:03] <PhatEddy> rakudo: package A { enum B_different <a> }; package P { role B {}; class C does P::B {} }

[22:03] <p6eval> rakudo c77bd1:  ( no output )

[22:04] <hatseflats> so how are method collisions handled in perl6 when a role has a method named like a method contained in the class importing it?

[22:05] <jnthn> The method in the class always wins.

[22:05] <hatseflats> so there is no late binding?

[22:05] <hatseflats> hmmm

[22:05] <jnthn> Two roles both trying to bring in methods of the same name, without any method in the class to resolve it, is an error though (at composition time)

[22:05] <jnthn> (e.g. compile time)

[22:06] <[particle]-> class construction time

[22:06] <hatseflats> veering a bit off, wouldn't it be better to throw an error regardless?

[22:06] <jnthn> No, since in Perl 6 writing a method in the class is *the* mechanism for conflict resolution.

[22:07] <PhatEddy> In that example above - any good reason for the role and enum in different packages to conflict?

[22:07] <hatseflats> okay

[22:07] <jnthn> PhatEddy: No, it's an error.

[22:07] <jnthn> rakudo: role A { method m { } }; role B { method m { } }; class C does A does B { }

[22:07] <p6eval> rakudo 53f705: OUTPUT«A conflict occurred during role composition due to method 'm'.␤current instr.: '!meta_compose' pc -614965 ((unknown file):-1)␤»

[22:07] <jnthn> rakudo: role A { method m { } }; role B { method m { } }; class C does A does B { method m { } }

[22:07] <p6eval> rakudo 53f705:  ( no output )

[22:08] <hatseflats> so besides the difference in overriding behavoir and conflicting imports, and that roles do not add to the inheritance chain, are there any other differences, technically, between extending and using a role?

[22:08] <hatseflats> or traits for that matter

[22:09] <jnthn> Yes and no.

[22:09] <[particle]-> extending?

[22:09] <jnthn> [particle]-: synonym for inheriting

[22:09] <jnthn> For example, a role can also be used as a mix-in.

[22:09] <jnthn> Also, roles are immutable. Classes are mutable.

[22:09] <hatseflats> my bad, I seem to be mixing terminology a lot, I'm not used to perl, and draw a lot of the vocabulary from other sources

[22:10] <hatseflats> and a mix-in would be a non-abstract version of a role, correct?

[22:10] <jnthn> No, a mix-in is just applying a role to an object on a per-object basis.

[22:10] <hatseflats> oh, okay

[22:11] <hatseflats> ah yes, that trick is particularly interesting

[22:11] <jnthn> Well, I guess you could say we have the action of mixing in (a verb) more than a construct that we call a mix-in (a noun).

[22:11] <jnthn> Thus you mix in a role. :-)

[22:11] * PerlJam sprinkles chocolate and pecans and cinnamon on his vanilla ice cream and starts mixing.

[22:11] <hatseflats> I see :)

[22:12] <hatseflats> I'm asking because I'm trying to develop a bit or a nice language as part of my school project, and since the perl userbase seems to have the most exp. points, so to speak, on the subject, I ask here.

[22:13] <hatseflats> In my case, roles will be classes that are used as roles

[22:13] <[particle]-> jnthn: we need to be careful about language, because so many oo framworks have different meanings for different words, so i asked.

[22:13] <jnthn> [particle]-: Yes, you're right.

[22:13] <jnthn> [particle]-: I move between a bunch of different ones all the time...

[22:14] <[particle]-> like, perl 6 roles are smalltalk traits, 'cept our roles have state

[22:14] <jnthn> What we call attributes, C# calls fields, and its attributes are something every different...

[22:14] <[particle]-> yep, attributes versus properties, too

[22:14] <hatseflats> others call them members

[22:15] <jnthn> And what Perl 6 calls a trait (mixing in a role to something at compile time) is not what smalltalk calls a trait.

[22:15] <jnthn> well

[22:16] <jnthn> that's not quite what Perl 6 calls a trait, but it's often the upshot...

[22:16] <hatseflats> that's kinda... confusing

[22:16] <hatseflats> regardless, thanks for the info

[22:16] <PerlJam> If only they all used standardized terminology ...

[22:17] *** simcop2387 joined
[22:17] <hatseflats> heh

[22:17] <hatseflats> 'they all'

[22:20] <pugs_svn> r26685 | lwall++ | [Containers] some work on various structures related to KeyHash

[22:20] <pugs_svn> r26685 | lwall++ | define .pick to work rationally on structures whose values represent weights.

[22:22] *** Jedai left
[22:23] <TimToady> I'd be open to renaming 'traits' to something less confusing

[22:25] <hatseflats> how about, non-inheriting, non-overriding, non-instantiatable classes

[22:25] <jnthn> TimToady: I'm not so fussed....SmallTalk ain't *that* mainstream.

[22:25] <jnthn> If Java used it to mean something else, I'd probably feel differently.

[22:26] *** hercynium joined
[22:26] <hatseflats> someone has to set a trend

[22:26] <hatseflats> antiquated words get revised meanings all the time

[22:26] <hatseflats> who's to say that Java won't pick up on Perl-style traits and roles

[22:26] <hatseflats> or maybe we'll have world peace and Perl and Python will combine into one language

[22:27] <PerlJam> hatseflats: what makes you think that world would be peaceful?

[22:28] <hatseflats> everyone will be too busy trolling on the internet on the subject to make war?

[22:29] <arnsholt> PerlJam: But at least we would be able to focus on the really important questions

[22:29] <arnsholt> Like which editor people should use =)

[22:29] <hatseflats> heh

[22:29] <jnthn> Notepad!!!

[22:29] <PerlJam> arnsholt: you use vi to edit perl 6  (see how vi and 6 are the same?  :)

[22:30] <arnsholt> PerlJam: Obviously. vi is the one true editor, after all =)

[22:30] <TimToady> well, but Python and E-lisp are both just dialects of Perl 6...

[22:30] <hatseflats> *cringe*

[22:30] <jnthn> oh hey, that means so is lolcode...

[22:30] <PerlJam> arnsholt: yeah ... even if it's skin looks like vim, it's still got vi on the insides somewhere.

[22:31] <PerlJam> What *isn't* a dialect of perl 6 ? 

[22:31] <arnsholt> Yeah. vim is just vi with makeup on

[22:31] <TimToady> strawberries

[22:31] <TimToady> black holes

[22:31] <PerlJam> TimToady: now you're tempting the Damian.

[22:31] <TimToady> probably quarks, but we're not sure

[22:31] <hatseflats> I'd say Basic is a pretty safe bet to claim as not-perl based

[22:32] <TimToady> you don't understand; Perl 6 can easily mutate into *any* other computer language

[22:32] <TimToady> even Basic

[22:32] <jnthn> { use Basic; 10: PRINT "HELLO" }

[22:32] <hatseflats> if that's true

[22:32] <TimToady> you forgot the 'goto 10'

[22:33] <hatseflats> than isn't perl just scheme with a fancy community?

[22:33] <TimToady> well, lisp with a syntax

[22:34] <TimToady> the eventual goal is to convert Paul Graham :)

[22:34] <PerlJam> That's more Haskell

[22:34] <hatseflats> yeah... how would one classify haskell

[22:35] <hatseflats> as if the gods created the world with it, but then ditched it and wrote the bulk of the things on it in perl

[22:35] <TimToady> well, you can end a Perl program with a right paren

[22:37] <TimToady> in any case, the universe would consider indentation as syntax to be magical action at a distance, unless there are particles travelling back and forth between the text and the left margin

[22:37] <TimToady> .oO(spaces, the final frontier)

[22:38] <hatseflats> heh... hehehe :)

[22:38] <PerlJam> use Acme::Bleach

[22:38] *** Kyosuke_Kiryu left
[22:40] <TimToady> well, when Haskell gets around to inventing the QM monad, the universe will implode as self-referential, I expect

[22:40] <pmichaud> and here I figured that a self-reference was what kicked the whole thing off in the first place.

[22:40] <hatseflats> sorry, ah whatshamacallit monad?

[22:40] <TimToady> fortunately monads are still one-dimensional

[22:41] <TimToady> QM = Quantum Mechanical

[22:41] <pmichaud> Someone overflowed the stack somewhere and this universe is the result.

[22:41] *** Kyosuke_Kiryu joined
[22:41] <jnthn> rakudo: sub foo() { my @a = 1; return @a; }; my @x = foo(); say @x[0].perl;

[22:41] <p6eval> rakudo 53f705: OUTPUT«1␤»

[22:41] <PerlJam> The big thing in haskell is arrows now, not monads.  (which works well for entropy and time and such)

[22:42] <japhb> PerlJam: OK, last time I looked at Haskell, I had figured out monads, more or less.  What are arrows now?

[22:42] <TimToady> better monads :)

[22:42] <japhb> oh.

[22:42] <PerlJam> japhb: http://www.haskell.org/arrows/

[22:43] <japhb> "But if you're using a structure that's very like a monad, but isn't one, maybe it's an arrow."

[22:43] <japhb> heh

[22:43] <PerlJam> or it could be Higgs Boson

[22:44] <TimToady> maybe we should rename traits to arrows and confuse everyone

[22:44] <hatseflats> how would that be more confusing?

[22:45] <PerlJam> hatseflats: are you saying that we've reached maximal confusion?  There is no more?

[22:45] <TimToady> well, I guess an argument can be made that everyone is already confused

[22:45] <hatseflats> PerlJam: if the universe dies of maximal entropy, why not a similar fate for us humans

[22:46] <jnthn> pmichaud: ping

[22:46] <pmichaud> jnthn: pong 

[22:46] <jnthn> oh hai

[22:46] <pmichaud> also

[22:46] <pmichaud> jnthn: ping  :-)

[22:46] <jnthn> I'm doing something like

[22:46] <jnthn> @classes = self.^isa();

[22:46] <lambdabot> Unknown command, try @list

[22:46] <jnthn> That method is implemented in PIR

[22:47] <jnthn> And creates an Array and returns it. .return (the_array)

[22:47] <jnthn> Which ends up with @classes containing a first element that is that array.

[22:47] <jnthn> However, that differs from the case I fed to Rakudo above.

[22:47] <jnthn> Am I doing something obviously stupid?

[22:47] <jnthn> (the isa method is implemented in PIR, i mean)

[22:47] <pmichaud> rakudo:  sub foo() { my @a = 1;  @a };  my @x = foo(); say @x[0].perl;

[22:48] <p6eval> rakudo 53f705: OUTPUT«1␤»

[22:48] <TimToady> well, returns should generally be returning Captures, if they don't know what context they'll be used

[22:48] <pmichaud> is the_array really an Array?

[22:48] <jnthn>     result_list = get_hll_global 'Array'

[22:48] <jnthn>     result_list = result_list.'new'()

[22:48] <jnthn> ...

[22:48] <jnthn>     .return (result_list)

[22:48] <hatseflats> say $*IN;

[22:48] <hatseflats> err

[22:49] <hatseflats> rakudo: say $*IN;

[22:49] <hatseflats> ?

[22:49] <p6eval> rakudo 53f705: OUTPUT«IO()<0xb6b73668>␤»

[22:49] <pmichaud> jnthn: afaik, that should work out okay.  I'd probably want to see more detailed code.

[22:49] <pmichaud> You could try   $P0 = result_list.'list'();  return $P0

[22:49] <pugs_svn> r26686 | lwall++ | [STD] make lookup of $?FOO overridable in derived languages

[22:50] <pmichaud> i.e., to see the definition of whateveris handling '.^isa'

[22:50] <hatseflats> rakudo: say $*IN.lines().pick();

[22:50] <p6eval> rakudo 53f705: OUTPUT«Hast seit frühen Ahnentagen␤»

[22:51] <hatseflats> ah yes, the austrian anthem

[22:51] <jnthn> pmichaud: If I do .perl of the thingy that I'm returning inside the method it's [A]

[22:51] <jnthn> So looks right

[22:51] <jnthn> Let me get you a link though...

[22:51] <pmichaud> well, several things will cause it to return [A] though.

[22:51] <pmichaud> indeed, I wonder if it's in fact a reference to an array somehow.

[22:52] <jnthn> http://github.com/rakudo/rakudo/blob/53f70591a6e20a0a09a4fbccdfe91d4c7739a9d1/src/parrot/ClassHOW.pir

[22:53] <jnthn> methods below has the same issue.

[22:53] <pmichaud> oh, fwiw, the line

[22:53] <pmichaud>     result_list = get_hll_global 'Array'

[22:53] <pmichaud> is going to be wrong.

[22:53] <japhb> PerlJam: Thanks for the Arrows link.  Makes sense, but brain didn't expand.  Which either means they are common sense, or I'm missing something.

[22:54] <jnthn> pmichaud: Because...?

[22:54] <japhb> Perhaps "common sense if monads are already understood"

[22:54] <pmichaud> because this code is running in the 'parrot' HLL namespace.

[22:54] <hatseflats> haha

[22:54] <jnthn> Ah.

[22:54] <pmichaud> and Rakudo's 'Array' protoobject will be in a different namespace.

[22:54] <jnthn> Yes, yes.

[22:55] *** amoc left
[22:55] <jnthn> Well, that said, by the time we get .HLL in place, Rakudo's metaclass and P6object may be been broken out.

[22:55] <pmichaud> could be.

[22:55] <jnthn> (As in, Rakudo may have its own one in its own HLL)

[22:55] <pmichaud> at any rate, most array-like-stuff will end up being in RPA

[22:55] <pmichaud> i.e., Parrot's RPA will map to Rakudo's Array

[22:56] <pmichaud> is the code in 'isa' "new code", or has it been around a while?

[22:56] <jnthn> New.

[22:56] <jnthn> Though it'll change once get_parrotclass stops being needed.

[22:56] <pmichaud> right.

[22:57] <jnthn> Just trying to fill out the metaclass enough so that I can ween other places off using Parrot classes.

[22:57] <pmichaud> some things to try

[22:57] <pmichaud> (1)   use     new 'Perl6Array'   instead of going through the 'Array' protoobject.  I'm just curious if it makes a difference.

[22:57] <pmichaud> (2)  find out what   result_list.'PARROT'()  says

[22:59] <pmichaud> oddly, when I run it on my box it appears to do the assignment correctly.

[22:59] <hatseflats> why choose arrays to be pseudo or proto-objects?

[22:59] <jnthn> oh, hmm

[22:59] <pmichaud> $ cat y

[22:59] <pmichaud> my @isa = 1.^isa();

[22:59] <pmichaud> say @isa.perl;

[22:59] <pmichaud> $ ./perl6 y

[22:59] <pmichaud> [Int, Any]

[22:59] <pmichaud> $ 

[22:59] <jnthn> oh, hmm

[23:00] <jnthn> What if that's Int.^isa() ?

[23:00] <jnthn> Oh, ugh, that is quite bogus too (should just be Any - the Int is coming because we inherit from Parrot's Integer)

[23:00] <pmichaud> $ cat z

[23:00] <pmichaud> my @isa = Int.^isa();

[23:00] <pmichaud> say @isa.perl;

[23:00] <pmichaud> $ ./perl6 z

[23:00] <pmichaud> [Int, Any]

[23:00] <pmichaud> $ 

[23:00] <pmichaud> ^H^H^H^H^H^H[B[B[B[A[A

[23:01] <pmichaud> doesn't 'parents' end up returning the class itself in the list?

[23:02] <pmichaud> istr that the first element of introspecting parents was that it returned the class itself.

[23:02] <jnthn> I think ^isa by default is just the immediate parents

[23:03] <jnthn> Not the full MRO.

[23:03] <pmichaud> I think that Parrot's "parents" is the full mro.

[23:03] <pmichaud> maybe not, checking.

[23:03] <jnthn> No, there's two things

[23:03] <hatseflats> perl5: say 42;

[23:03] <jnthn> parents and all_parents

[23:04] <jnthn> First is immediates, second is MRO.

[23:04] <pmichaud> you're correct.

[23:04] <pmichaud> but yes, technically, Int has two parents right now.

[23:04] <jnthn> I think something odd is going on though.

[23:04] <jnthn> Because a shorter snippet just gave me the answer I expected...

[23:06] *** H1N1 joined
[23:07] <pmichaud> I think I'm going to add "is vtable(...)"  as one of our allowed traits.

[23:07] *** kane___ joined
[23:07] <pmichaud> so we can write vtable functions in the setting.

[23:08] <jnthn> Were we not going to just map 'em all in Object?

[23:08] <pmichaud> I'm not sure they always map.

[23:08] <pmichaud> I might go that approach to begin with.

[23:09] <jnthn> OK, no objections from me if you need it.

[23:09] <jnthn> Guess it'll be a compiler-handled trait rather than one we dispatch on.

[23:09] <pmichaud> I was going to handle it the same as the other sub traits.

[23:09] <pmichaud> i.e., it would call sub_trait_vtable and do the vtable insertion.

[23:10] <pmichaud> at least as a first cut, since that's easy (and consistent with our other trait handling)

[23:11] <pmichaud> but maybe I'll go with mapping them all in Object for now.

[23:11] <pmichaud> (these are with respect to refactoring List and Array)

[23:11] <jnthn> That's fine.

[23:11] <jnthn> I'm not going to be doing traits for a bit.

[23:12] <pmichaud> Somehow it seems I spend most of my time rewriting/refactoring existing code.  :-|

[23:13] <pmichaud> I guess that's normal, though.

[23:13] <jnthn> Heh, in the next couple of weeks I've probably gotta re-write all of the method dispatcher, .*, .+, .?, wrap, unwrap...

[23:13] <pmichaud> I'm glad to let you do that :-)

[23:14] <jnthn> Gah. :-( So I take the code out of the setting, pretty much copy-paste, into a separate .p6 file and it works... :-|

[23:14] <TimToady> bootstrap dependency?

[23:15] <jnthn> TimToady: Maybe, but then I'm struggling to think where. The code isn't being called until everything else is compiled...

[23:15] <pmichaud> oh, on a related topic

[23:16] <pmichaud> I think we might get to the point soon where we ship with a "bootstrapping" settings.pir

[23:16] <pmichaud> this is used to compile the real settings, which then replace it.

[23:16] <jnthn> I'd been thinking we might end up with that.

[23:16] <pmichaud> same here.

[23:17] <pmichaud> but I'm getting to the point where I really prefer to be writing things in p6 (with inline PIR) than pure PIR.

[23:17] <jnthn> Some things are getting quite a nuisance now.

[23:17] <hatseflats> stupid question, but why does it make sense that I can access a package created outside the local scope?

[23:17] <jnthn> Like, if you re-declare a variable in the setting.

[23:18] <jnthn> Then warn uses join which isn't existing until we've compiled the setting.

[23:18] <jnthn> And so you never get the error.

[23:18] <pmichaud> warn could always use the opcode join :-)

[23:18] <jnthn> It just whines about not finding join.

[23:18] <pmichaud> but yes, our bootstrapping version could provide a join that warn can use.

[23:18] <jnthn> Yeah of course. It's just an example of the sort of problem.

[23:19] <jnthn> Like, most of IO is defined in the setting.

[23:19] <pmichaud> that is then replaced by the 'real' join.

[23:19] <jnthn> say() just delegates.

[23:19] <jnthn> To $*OUT.say

[23:19] <jnthn> Which doesn't exist.

[23:19] <jnthn> So you stick a say(...) in actions.pm for debugging and it fails.

[23:20] <TimToady> hmm, an exported method has an implicit *%_, which might explain say( a => 42 ) throwing away the pair

[23:20] <jnthn> (which sucks when you're trying to debug...)

[23:20] <pmichaud> TimToady: yes, I was thinking that earlier.

[23:21] <pmichaud> But I think it may also related to the discussion on pairs  in  list(...)   and hash(...)

[23:21] <pmichaud> *relate

[23:21] <TimToady> maybe we can refine the automatic *%_ rule somehow

[23:21] <pmichaud> for the time being, we could probably have  say()  warn if it gets any named params.

[23:22] <pmichaud> Is there a strong reason for the automatic *%_ rule?

[23:22] <jnthn> pmichaud: this is odd...

[23:22] <jnthn>         say "before loop: " ~ @classes.perl;

[23:22] <jnthn>         for @classes -> $class {

[23:22] <jnthn>             say $class.perl();

[23:22] <jnthn>         }

[23:22] <jnthn> Output

[23:22] <jnthn> before loop: [A]

[23:22] <jnthn> [A]

[23:23] <pmichaud> jnthn: it's possible that .perl is subtly modifying its invocant somehow.

[23:23] <pmichaud> I know that there was some other oddities with .perl recently.

[23:24] <pmichaud> what is @classes.PARROT;  reporting?

[23:24] <jnthn> True, but it's consistent with what goes wrong next...

[23:24] <jnthn> (Which is that I do $class.^methods and it gives me the methods of Array...

[23:24] <jnthn> )

[23:25] <jnthn> I change the .perl to .PARROT and get

[23:25] <jnthn> before loop: Perl6Array

[23:25] <jnthn> Perl6Scalar->Perl6Array

[23:25] <pmichaud> aha

[23:25] <pmichaud> yes, something is converting @classes into a Perl6Scalar

[23:26] <meppl> good night

[23:26] <jnthn> Note the second line is inside the loop

[23:26] <jnthn> e.g. say $class.PARROT

[23:26] <pmichaud> try  @classes[0].PARROT

[23:26] <pmichaud> (before the loop)

[23:27] <pmichaud> wait.

[23:27] <pmichaud> I might know.  What exactly is *in* @classes at this point?

[23:27] <jnthn> As far as I can see nothing shoulda touched it other than what came back from @classes = self.^isa();

[23:27] *** PhatEddy left
[23:27] *** ZuLuuuuuu left
[23:27] <pmichaud> try  @classes[0].PARROT

[23:28] <pmichaud> we know that @classes is a Perl6Array, I need to know its first element.

[23:28] <jnthn> I do say 'before loop @classes[0]: ' ~ @classes[0].PARROT;

[23:28] <jnthn> and the output is just

[23:28] <jnthn> before loop @classes[0]:

[23:28] <jnthn> (e.g. .PARROT gives nothing)

[23:28] <pmichaud> because it's an (unnamed) proto.

[23:29] <pmichaud> protoobjects don't get class names by default.

[23:29] <jnthn> ah, yes

[23:29] <pmichaud> which proto is it?

[23:29] <jnthn> I just defined two classes

[23:29] <jnthn> class A { method x() { say 1 } }

[23:29] <jnthn> class B is A { method x() { say 2 } }

[23:29] <jnthn> And it'd be A's proto

[23:29] <pmichaud> testing.

[23:30] <pmichaud> and @classes is....    B.^isa() ?

[23:30] <jnthn> aye

[23:31] <pmichaud> you have some local mods in place?

[23:33] <jnthn> The method I'm writing in the setting

[23:33] <jnthn> oh

[23:33] <jnthn> And the return value to list thing you suggested.

[23:33] <pmichaud> what's the method you're writing in the setting?

[23:33] <jnthn> WALK

[23:34] <jnthn> (at least partly as an attempt at proof-of-concept of the introspection stuff...)

[23:34] <pmichaud> on my system:  http://nopaste.snit.ch/16478

[23:34] <pmichaud> can I see what you have for WALK ?

[23:35] <jnthn> one second, I'm just pulling it out of the setting into an is also to make sure it's really not setting specific...

[23:35] <pmichaud> oh, I know what else it might be.

[23:35] <pmichaud> What *other* methods do you have defined in there...?

[23:35] <jnthn> Just git stash'd what i had before.

[23:35] <pmichaud> and what class is this being defined in?

[23:36] <jnthn> Object.

[23:36] <pmichaud> Yes, that's the problem.

[23:36] <jnthn> OH NOES

[23:36] <jnthn> Yes, I think I can guess where this one is going... :-(

[23:36] <pmichaud> Object has its own "list" method, and that's being called as part of the 'list' function.

[23:36] <pmichaud> because

[23:36] <pmichaud>     for @classes -> $class { ... }

[23:36] <pmichaud> is really

[23:37] <pmichaud>     for list(@classes) -> $class { .... }

[23:37] <pmichaud> but

[23:37] <pmichaud> because Parrot sticks its methods into the namespace

[23:37] <pmichaud> and because IMCC short-circuits to any named sub in the same namespace

[23:37] <pmichaud> you're not getting the global version of list(), you're getting Object's version of .list()

[23:37] <pmichaud> which returns a list of itself.

[23:37] <pmichaud> i.e., what you're getting is the same as

[23:38] <pmichaud>     for Object::list(@classes) -> $class { ... }

[23:38] <jnthn> Yeah. Ugh.

[23:39] <pmichaud> I _really_ wish we could get that particular namespace bug fixed.

[23:39] <jnthn> you're right...

[23:40] <jnthn> http://nopaste.snit.ch/16479

[23:40] <jnthn> That works, but s/Any/Object/ (to add it to Object) and if blows up.

[23:41] <pmichaud> right, because Any doesn't have a 'list' method/sub defined.

[23:41] <jnthn> Can't believe we just lost another hour to a stupid Parrot fail attempt at optimization.

[23:41] <pmichaud> so IMCC doesn't do the short-circuit optimization.

[23:41] <pmichaud> Perhaps the workaround/solution here is to get PCT to always use  :method('name') when generating methods.

[23:41] <pmichaud> And give the sub an empty or nonsense or otherwise mangled name.

[23:42] <jnthn> Only works if it's not an our method though...

[23:42] <jnthn> The others need to be in the ns.

[23:42] <pmichaud> hmmm?

[23:42] <jnthn> If it's an our method it has to go in the NS.

[23:42] <jnthn> I'm not sure what stuff in the setting counts for on that front though.

[23:42] <pmichaud> do we have anything that really makes use of 'our methods'?

[23:43] <jnthn> I'm not sure. Is it the default?

[23:43] <jnthn> The point is more, do other people have code that is making use of them...

[23:43] <pmichaud> no, the question is, "what is Spec"?

[23:43] <pmichaud> if people have code that relies on it, and it's not spec, then I'm not too worried about breaking it.

[23:44] <jnthn> Sure.

[23:44] <jnthn> I don't know which is spec...checking...

[23:44] <pmichaud> but I don't remember that methods go into the namespace.  This was discussed recently.

[23:44] <pmichaud> I thought they stayed out of the namespace unless 'is export' was present.

[23:44] <pmichaud> (I can be misremembering this.)

[23:45] <jnthn> Unlike with most other declarations, C<method> declarations do not

[23:45] <jnthn> default to C<our> semantics, or even C<my> semantics, but rather

[23:45] <jnthn> C<has> semantics. 

[23:45] <jnthn> You're right.

[23:45] <pmichaud> right

[23:45] <pmichaud> and the sentence after that.

[23:45] <jnthn> yes, that's the upshot of what I pasted.

[23:45] <pmichaud> I don't think anyone is using 'our'

[23:46] <pmichaud> if they are, we can certainly arrange for it to go back into the namespace

[23:46] <jnthn> sure

[23:46] <jnthn> and lo and behold

[23:46] <jnthn>  .namespace ['Perl6Object']

[23:46] <jnthn> -.sub 'list' :method

[23:46] <jnthn> +.sub '' :method('list')

[23:46] <jnthn> Solve the issue.

[23:46] <pmichaud> oh, do that for now.

[23:46] <pmichaud> My apologies that it wasn't done sooner.

[23:46] <pmichaud> We should do that for most built-in methods.

[23:46] <jnthn> No, no, sorry for dragging you into the debugging.

[23:47] <jnthn> I shoulda guessed that one sooner...

[23:47] <pmichaud> it often trips me up

[23:47] <pmichaud> I didn't realize you were working inside of Object.

[23:47] <jnthn> I did know about Parrot's failtimization.

[23:47] <pmichaud> more to the point, however.

[23:47] <pmichaud> because I've also had it happen in settings code

[23:47] <pmichaud> I think I should update PCT to allow :nsentry

[23:48] <pmichaud> and then Rakudo should default to :nsentry('')  unless 'our' is present.

[23:48] <pmichaud> that way the sub can still have a name, but we control where it goes in the namespace.

[23:48] <jnthn> *nod*

[23:49] *** c1sung joined
[23:50] <pmichaud> this of course, is the other reason we should probably start doing  p6-with-inline-PIR instead of pure PIR, to avoid these sorts of things in the first place.

[23:52] <pmichaud> afk for a while -- need a walk.

[23:53] *** mizioumt1 left
