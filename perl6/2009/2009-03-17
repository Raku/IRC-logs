[00:01] *** ced-2 left
[00:01] *** jferrero joined
[00:03] *** ZuLuuuuuu joined
[00:11] *** frooh joined
[00:11] *** PZt joined
[00:18] <frooh> s1n: we stil on for Thursday?

[00:20] *** ced-2 joined
[00:21] *** Exodist left
[00:31] <japhb_> I'm getting a segfault trying to build Rakudo:

[00:31] <japhb_> /home/geoff/git/rakudo/parrot/parrot  -o perl6_s1.pbc perl6.pir

[00:31] <japhb_> make: *** [perl6_s1.pbc] Segmentation fault

[00:31] <japhb_> I'm up to date ... is this known?

[00:32] <japhb_> i486-linux-gnu, FWIW

[00:33] <frooh> lemme try rebuilding and seeing what's up

[00:33] <frooh> did you do a make realclean first?

[00:33] <frooh> I always do before a major(ish) rebuild

[00:34] * frooh rebuilds parrot and rakudo

[00:34] <japhb_> I nuked and recreated the parrot submodule ... I believe I realcleaned rakudo, as well, but let me just do it again just in case

[00:35] *** ced-2_ left
[00:36] <japhb_> hmmm, it's getting farther this time -- perhaps I just needed to nuke and rebuild parrot *before* doing a realclean and configuring rakudo without --gen-parrot

[00:36] <jnthn> japhb_: Platform? And is this latest Parrot?

[00:36] *** alester is now known as AndyAway

[00:36] <jnthn> japhb_: Generally, the Parrot version in build/PARROT_REVISION is the one we *know* it works under though I often develop against latest too.

[00:37] <japhb_> jnthn: nevermind.  I fixed it ... looks like I just didn't clean up exactly right the first try

[00:37] <jnthn> Aha, OK, good. :-)

[00:37] <frooh> japhb_: I actually wrote a script that would update parrot and rakudo from source and then build them, if you're interested I could send it to you

[00:39] <japhb_> frooh: Back in the day that Rakudo was in the Parrot repo, I did as well ... but I have a feeling it probably doesn't work any more.

[00:39] <japhb_> It was .../tools/rebaase-rakudo.pl

[00:39] <frooh> well, the benefit here is that I don't have to entirely re checkout parrot

[00:39] <frooh> I have it in a separate folder and this will make a symlink to it

[00:39] *** explorer__ joined
[00:40] <frooh> but yeah, if you got it all working that's fine

[00:41] <japhb_> Like I said, it *used* to work.  Glancing at it now, I'm positive that it no longer works, because it uses 'git svn'.  :-)

[00:41] *** eternaleye joined
[00:42] <japhb_> frooh: But in any case, I was going to recommend that you put your script in rakudo/tools/ ... or even better, merge the smart stuff in your script with whatever you can salvage from mine.

[00:42] <frooh> I don't have commit access to rakudo

[00:42] <frooh> or do you mean in parrot?

[00:43] <japhb_> frooh: It's on github ... just fork it.  :-)

[00:43] <frooh> that's true

[00:43] <frooh> pmichaud: speaking of, did you look at that patch I sent to RT?

[00:44] *** explorer__ left
[00:44] <frooh> japhb_: your script is much more involved than mine :-)

[00:46] <japhb_> frooh: I was hoping to make it semi-official ... unfortunately, I think A) my timing was bad, and B) the hardcore Rakudo people already had whipped mini-scripts of their own and saw no reason to switch.

[00:46] <frooh> right

[00:51] <japhb_> rakudo: my $word = 'abcd'; my $match = $word ~~ /<[a..d]+>/; print $match.perl

[00:51] <p6eval> rakudo 84920e: OUTPUT«perl6regex parse error: Error parsing enumerated character class at offset 49, found '>'␤current instr.: 'parrot;PGE;Perl6Regex;parse_error' pc 10167 (compilers/pge/PGE/Perl6Regex.pir:1219)␤»

[00:52] <japhb_> rakudo: my $word = 'abcd'; my $match = $word ~~ /<[a..d]>+/; print $match.perl

[00:52] <p6eval> rakudo 84920e: OUTPUT«Null PMC access in get_bool()␤current instr.: 'parrot;Match;_block1034' pc 32535 (src/gen_setting.pir:3469)␤»

[00:52] <japhb_> frack.

[00:52] <japhb_> BTW, who owns evalbot?

[00:57] *** ZuLuuuuuu left
[01:10] <jnthn> japhb_: I think the source is in the pugs repo, I can't remember who looks after it, it may be moritz_ (or moritz_ would probably know who).

[01:10] <jnthn> japhb_: That looks like a Rakudo bug, BTW.

[01:10] <s1n> frooh: yeah, thursday at 7pm

[01:10] <s1n> i'm really run ragged the last few days though, hopefully i will be mentally recovered :)

[01:10] <jnthn> rakudo: my $word = 'abcd'; say $word ~~ /<[a..d]>+/;

[01:11] <p6eval> rakudo 84920e: OUTPUT«abcd␤»

[01:11] <frooh> haha, hopefully

[01:11] <jnthn> rakudo: my $word = 'abcd'; my $match = $word ~~ /<[a..d]>+/; 

[01:11] <frooh> you know if pmichaud will be there?

[01:11] <p6eval> rakudo 84920e: RESULT«Null PMC access in get_bool()␤current instr.: 'parrot;Match;_block1034' pc 32535 (src/gen_setting.pir:3469)␤»

[01:11] <frooh> I doubt any of my coworkers will show up.  The only one who was a sure bet is in CO

[01:11] <s1n> frooh: i haven't spoken to him lately, i haven't even walked my poor dog :(

[01:11] <frooh> hahaha

[01:11] <jnthn> rakudo: my $word = 'abcd'; my $match = ($word ~~ /<[a..d]>+/).WHAT; 

[01:11] <frooh> that's a drag

[01:12] <p6eval> rakudo 84920e: RESULT«Match»

[01:12] <jnthn> rakudo: Match.new

[01:12] <s1n> only 4 hours left to the deadline and about 30 (of 100) points left to finish :(

[01:12] <p6eval> rakudo 84920e: OUTPUT«too few arguments passed (1) - 3 params expected␤current instr.: 'parrot;PGE;Match;new' pc 28 (compilers/pge/PGE/Match.pir:54)␤»

[01:12] <jnthn> rakudo: Match.new("x")

[01:12] <frooh> that sucks

[01:12] <p6eval> rakudo 84920e: RESULT«Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ text => "",␤ from => 0,␤ to   => -1,␤)»

[01:12] <frooh> get off of irc and finish it!

[01:12] <jnthn> rakudo: my $x = Match.new("x")

[01:12] <p6eval> rakudo 84920e: RESULT«Null PMC access in get_bool()␤current instr.: 'parrot;Match;_block1034' pc 32535 (src/gen_setting.pir:3469)␤»

[01:13] <s1n> i just saw the orange pidgin indicator and scrolled back :)

[01:13] <frooh> ah, ok

[01:13] <frooh> well, good luck on that

[01:13] <jnthn> Assigning match objects makes Rakudo explode. :-|

[01:15] * s1n slumps into his chair to finish creating a text author/speaker detection program

[01:15] <s1n> thank god for perl5

[01:16] <frooh> indeed :-)

[01:17] <s1n> TimToady++ for 1..*

[01:17] * frooh considers having evalbot do that for real...

[01:18] <s1n> it should

[01:18] <s1n> make the karma ~~ Inf

[01:18] <frooh> I think it is Inf on irc.perl.org

[01:18] <s1n> TimToady.karma(:by<Inf>)

[01:20] *** justatheory left
[01:20] *** jferrero left
[01:22] *** sri_kraih_ left
[01:22] *** justatheory joined
[01:23] *** justatheory left
[01:24] *** Kimtaro left
[01:25] <japhb_> rakudo: my %params; %params<foo> = [] unless %params<foo>; %params<foo>.push("bar"); say %params.perl

[01:25] <p6eval> rakudo 84920e: OUTPUT«{"foo" => ["bar"]}␤»

[01:26] <japhb_> Is there any way to golf that under current Rakudo?

[01:27] <japhb_> I'd love to just get rid of the whole second statement (containing 'unless') ... but barring that, using ||= would be nice, but that appears not to work.

[01:27] <frooh> I thouht //= worked...

[01:27] <s1n> yeah i was going to recommend //=

[01:27] <japhb_> Ooh, let me try that

[01:28] <japhb_> Ah-ha!

[01:28] <japhb_> OK, that's at least a step forward.  Though it's weird that //= works but ||= does not.

[01:28] <frooh> agreed

[01:28] <frooh> rakudo: my $frew; $frew ||= 5; say $frew;

[01:28] <p6eval> rakudo 84920e: OUTPUT«get_iter() not implemented in class 'Integer'␤current instr.: 'prefix:=' pc 20151 (src/builtins/misc.pir:17)␤»

[01:28] <frooh> rakudo: my $frew; $frew //= 5; say $frew;

[01:29] <p6eval> rakudo 84920e: OUTPUT«5␤»

[01:29] <frooh> weird

[01:29] <frooh> I wonder if maybe it's a parsing error

[01:30] <s1n> rakudo: my $frew //= 5; say $frew

[01:30] <p6eval> rakudo 84920e: OUTPUT«5␤»

[01:30] <jnthn> frooh: Yes

[01:30] <frooh> yes it's a parsing issue?

[01:30] <jnthn> frooh: It's parsing it as infix:<||> prefix:<=>

[01:30] <frooh> ah, ki

[01:30] <frooh> k*

[01:30] <jnthn> (Because we didn't define a ||=

[01:30] <jnthn> )

[01:30] <frooh> and // isn't an infix?

[01:31] <japhb_> jnthn: ah, and foo= does not autogenerate yet?

[01:31] <jnthn> IIRC we can't just define it like a normal meta-op because it needs to short-circuit.

[01:31] <jnthn> japhb_: Well, the thing is we need to handle the short-circuit at the compiler level. I think.

[01:31] <jnthn> Actually I fear //= is not short-circuiting in Rakudo as it should.

[01:31] <jnthn> rakudo: my $x = 42; $x //= say "hi";

[01:31] <p6eval> rakudo 84920e: OUTPUT«hi␤»

[01:32] <jnthn> Aye.

[01:32] <jnthn> fail

[01:32] <frooh> hmm

[01:32] <japhb_> rakudo: my %params; %params<foo> //= ["foo"]; %params<foo> //= ["bar"]; say %params.perl

[01:32] <jnthn> Though //= is fairly useful.

[01:32] <p6eval> rakudo 84920e: OUTPUT«{"foo" => ["foo"]}␤»

[01:32] <japhb_> at least that works

[01:32] <jnthn> As is.

[01:32] <jnthn> Yeah

[01:32] <jnthn> I figured a mostly-works was worth it.

[01:33] <frooh> rakudo: my $x = 42; $x //= "hi"; say $x;

[01:33] <p6eval> rakudo 84920e: OUTPUT«42␤»

[01:33] <jnthn> (OK, actually I wasn't thinking clearly at all when I put it in, truth be told...)

[01:33] <frooh> it looks to me like it works fine...

[01:33] <jnthn> frooh: It works apart from it evalutes the RHS when it needn't.

[01:33] <japhb_> frooh: appears to be something wrong with mixing //= and the return from say

[01:33] <jnthn> frooh: It should not evaluate the RHS if the LHS is defined.

[01:33] <frooh> oooooh

[01:33] <frooh> right

[01:33] <frooh> got it

[01:34] <jnthn> So right results if your RHS is pure. ;-)

[01:34] <frooh> rakudo: my $x = 42; $x // $x = say "hi";

[01:34] <p6eval> rakudo 84920e: OUTPUT«hi␤»

[01:34] <japhb_> jnthn: why would 'say' return its printed value?  Shouldn't it return Bool?

[01:34] <s1n> rakudo: say undef // 4

[01:34] <p6eval> rakudo 84920e: OUTPUT«4␤»

[01:35] <s1n> rakudo: 1 // 2

[01:35] <jnthn> japhb_: say say "hi"; 

[01:35] <jnthn> erm

[01:35] <jnthn> rakudo: say say "hi"

[01:35] <frooh> I think s1n killed it

[01:35] <s1n> ooo

[01:35] * frooh tries locally

[01:35] * jnthn tried using japhb_ as an evalbot ;-)

[01:35] <frooh> it works here just fine

[01:35] * s1n kills evalbots for fun :)

[01:35] <japhb_> ENOTSILICONBASEDLIFEFORM

[01:36] <p6eval> rakudo 84920e: RESULT«1»

[01:36] <p6eval> rakudo 84920e: OUTPUT«hi␤1␤»

[01:36] <frooh> weird

[01:36] <s1n> yay

[01:36] <s1n> rakudo: 1 // 2

[01:36] <s1n> again!

[01:36] <frooh> haha

[01:36] <p6eval> rakudo 84920e: RESULT«1»

[01:36] <frooh> it's fast here, but that may be computer speed differences

[01:36] <s1n> 20 seconds to do that one op

[01:37] <s1n> it took a minute earlier

[01:37] <frooh> weird

[01:37] <frooh> rakudo: 1 || 2

[01:37] <frooh> whenever it get's around to it

[01:37] <p6eval> rakudo 84920e: RESULT«1»

[01:38] <s1n> rakudo: my $g = undef // 1

[01:38] <p6eval> rakudo 84920e: RESULT«1»

[01:38] <s1n> seems to take a while for that op

[01:38] <s1n> rakudo: my $g = undef

[01:39] <p6eval> rakudo 84920e: RESULT«undef»

[01:39] <japhb_> rakudo: my %params; (%params<foo> //= []).push("bar"); %params.perl

[01:39] <frooh> you know pir right? maybe you should look at it after you finish you paper or whateevr :-)

[01:39] <s1n> the operators aren't written in pir

[01:39] <p6eval> rakudo 84920e: RESULT«"\{\"foo\" => [\"bar\"]}"»

[01:39] <japhb_> rakudo: my %params; (%params<foo> //= []).push("bar");

[01:39] <s1n> well, sorta

[01:39] <frooh> oh....  oh well

[01:39] <p6eval> rakudo 84920e: RESULT«1»

[01:40] <japhb_> rakudo: my %params; (%params<foo> //= []).push("bar"); print %params.perl

[01:40] <p6eval> rakudo 84920e: OUTPUT«{"foo" => ["bar"]}»

[01:41] *** ced-2_ joined
[01:41] *** tomheady left
[01:41] <s1n> the lure to smash the eval bot is too great, i gotta move this window to another desktop :)

[01:43] <frooh> haha

[01:43] *** Kimtaro joined
[01:48] *** wknight8111 left
[01:48] *** ced-2 left
[01:51] *** ced-2_ left
[01:52] *** ced-2 joined
[02:00] *** japhb_ is now known as japhb

[02:13] <frooh> rakudo: sign -5

[02:13] <p6eval> rakudo 84920e: RESULT«-1»

[02:13] <frooh> rakudo: floor -5

[02:13] <p6eval> rakudo 84920e: RESULT«-5»

[02:15] *** amoc left
[02:15] *** amoc joined
[02:16] *** ced-2_ joined
[02:19] <frooh> anyone in here know of any examples of putting PIR in perl6 inline?

[02:20] <skids> Yeah I did it with rand but haven't cleaned the patches up yet.

[02:21] <frooh> could you nopaste the code so I can see the syntax etc?

[02:21] *** Grrrr left
[02:22] * skids waiting for github to stop being slow

[02:22] <frooh> if your code is on github a link to that would be fine too

[02:22] <frooh> but you might wanna tinyurl the link :-)

[02:24] <skids> http://github.com/skids/rakudo/commit/3aa2125e5ee368ecce20ee74d2fc3d4fac8f9d76

[02:24] <skids> and then

[02:24] <skids> http://github.com/skids/rakudo/commit/153a5002f63694dcf29f20b909c7dcb88234d264

[02:25] <frooh> thanks skids

[02:29] *** alester joined
[02:31] *** ced-2 left
[02:33] * frooh thought that he wouldn't need to learn PIR for the setting

[02:33] *** ced-2 joined
[02:33] <skids> only little bits.

[02:33] <skids> Most of which can be copied from what's there :-)

[02:34] <frooh> that's true...

[02:34] <frooh> any idea how I can pass a value to a parrot method?

[02:34] <frooh> I tried q:PIR{...}($foo)

[02:34] <frooh> but that doesn't seem to work

[02:35] <skids> I remember self was just self inside q:PIR{...} lemme look a bit.

[02:36] *** firelord joined
[02:37] <firelord> hey everyone

[02:37] <frooh> hi

[02:37] <firelord> man... been a long time since I was here last.

[02:40] <firelord> The current built of perl6, can it perform a 'system call' to external programs ?

[02:40] <frooh> firelord: yeah, but you can't easily get the output

[02:40] <frooh> I wrote something to fake it, but it's slow

[02:41] <frooh> fake getting the output that is

[02:41] <firelord> well I do not need the output really, just need it to call an external app

[02:41] <frooh> yeah, that's easy

[02:41] <skids> frooh: I think it's ".param num n" at the top, then "func n"

[02:41] <firelord> the external app will produce some lovely files

[02:42] <skids> see round, etc in builtins/math.pir

[02:42] <firelord> skids: excellent, thank you

[02:42] * frooh tries

[02:43] <firelord> you too frooh

[02:43] <frooh> no prob

[02:43] <frooh> firelord: you might want to try 'run("command")'

[02:44] <firelord> frooh: thanks frooh! that should do it

[02:44] <frooh> yep, enjoy

[02:45] <skids> Oh I guess you may not need the .param -- that's if you are creating a PIR sub

[02:45] <frooh> yeah

[02:45] <skids> As to whether to use $var or var I don't know.

[02:45] <frooh> but even doing q:PIR{ ... }($foo) doesn't work

[02:45] <frooh> so I'll try it?

[02:45] <skids> The foo will have to go inside {}

[02:46] *** ced-2_ left
[02:46] <frooh> hmmm

[02:47] <frooh> no dice..

[02:48] <frooh> it doesn't like me doing q:PIR{ ..., foo $bar }

[02:48] <frooh> it doesn't like me doing q:PIR{ ..., '$!foo' $bar }

[02:48] <frooh> rather

[02:50] *** simcop2387 left
[02:51] <firelord> thanks guys! Finally I can start writing some test bioinformatics software with perl6

[02:51] <frooh> firelord: have fun :-)

[02:51] <skids> oh method not sub... something like subset.'add_role'($foo) ?

[02:52] <frooh> well, it's a sub and I am making it a method

[02:52] <firelord> Have a good night everyone or morning if you are in Europe.

[02:53] *** firelord left
[02:59] <skids> wait, are you trying to put a function call at the end of a PIR arglist for some other function call?

[03:00] <frooh> uhhhh

[03:00] <frooh> I don't follow

[03:00] <frooh> I am trying to call a PIR function from perl6

[03:01] <frooh> http://rt.perl.org/rt3/Public/Bug/Display.html?id=63874

[03:06] *** Grrrr joined
[03:06] *** Eevee left
[03:07] *** Eevee joined
[03:15] <skids> playing with it.  Would self work? I know that works.

[03:15] <frooh> I'll try, but it's not a method

[03:15] <frooh> ie

[03:16] <frooh> rakudo: 5.sign

[03:16] <p6eval> rakudo 84920e: OUTPUT«Method 'sign' not found for invocant of class 'Int'␤current instr.: 'parrot;P6metaclass;dispatch' pc 320 (src/classes/ClassHOW.pir:161)␤»

[03:16] <frooh> rakudo: sign 5

[03:16] <p6eval> rakudo 84920e: RESULT«1»

[03:17] <skids> yeah jnthn was super helpful by just giving q:PIR{ say 'hello' } as an example, no vars pulled in :-)

[03:18] <frooh> rakudo: q:PIR{ say 'hello' };

[03:18] <frooh> ?

[03:18] <p6eval> rakudo 84920e: OUTPUT«hello␤»

[03:18] <frooh> wow

[03:18] <frooh> didn't think that would work

[03:20] *** donaldh left
[03:20] *** donaldh joined
[03:20] <frooh> rakudo: q:PIR{ rand 5 };

[03:20] <p6eval> rakudo 84920e: OUTPUT«error:imcc:syntax error, unexpected INTC, expecting '(' ('5')␤     in file 'EVAL_15' line 38␤»

[03:20] <frooh> rakudo: q:PIR{ sign 5 };

[03:20] <p6eval> rakudo 84920e: OUTPUT«error:imcc:syntax error, unexpected INTC, expecting '(' ('5')␤     in file 'EVAL_15' line 38␤too few arguments passed (0) - 1 params expected␤current instr.: 'sign' pc 19384 (src/builtins/math.pir:90)␤»

[03:21] <frooh> rakudo: q:PIR{ sign(5) };

[03:21] <p6eval> rakudo 84920e: RESULT«Null PMC access in can()␤current instr.: '!dispatch_method' pc 16869 (src/builtins/guts.pir:104)␤»

[03:24] *** hercynium left
[03:37] *** aindilis joined
[03:37] *** Woody4286 left
[03:37] *** Southen_ left
[03:37] *** pnu left
[03:37] *** baest left
[03:38] *** Woody4286 joined
[03:38] *** Southen_ joined
[03:38] *** pnu joined
[03:38] *** [particle] joined
[03:38] *** lisppaste3 joined
[03:38] *** PerlJam joined
[03:38] *** Porsbo joined
[03:38] *** baest joined
[03:38] *** frodwith joined
[03:38] *** Maddingue joined
[03:38] *** IRSeekBot joined
[03:42] *** sri_kraih joined
[03:43] <frooh> rakudo: q:PIR{ sign 5 };

[03:43] <p6eval> rakudo 84920e: OUTPUT«error:imcc:syntax error, unexpected INTC, expecting '(' ('5')␤     in file 'EVAL_15' line 38␤too few arguments passed (0) - 1 params expected␤current instr.: 'sign' pc 19384 (src/builtins/math.pir:90)␤»

[03:50] *** [particle]1 left
[03:50] *** PacoLinux left
[03:50] *** drbean_ left
[03:50] *** Sepheebear left
[03:50] *** yves left
[03:50] *** Woody4286 left
[03:50] *** baest left
[03:50] *** [particle] left
[03:50] *** pnu left
[03:50] *** Porsbo left
[03:50] *** IRSeekBot left
[03:50] *** Southen_ left
[03:50] *** PerlJam left
[03:50] *** frodwith left
[03:50] *** Maddingue left
[03:50] *** lisppaste3 left
[03:51] *** [particle]1 joined
[03:51] *** PacoLinux joined
[03:51] *** drbean_ joined
[03:51] *** Sepheebear joined
[03:51] *** yves joined
[03:51] *** p6eval joined
[03:51] *** gravity joined
[03:51] *** allbery_b joined
[03:51] *** szbalint joined
[03:51] *** f00li5h joined
[03:51] *** cxreg joined
[03:51] *** ilbot2 joined
[03:51] *** scrottie joined
[03:51] *** IRSeekBot joined
[03:51] *** Maddingue joined
[03:51] *** frodwith joined
[03:51] *** baest joined
[03:51] *** Porsbo joined
[03:51] *** PerlJam joined
[03:51] *** lisppaste3 joined
[03:51] *** [particle] joined
[03:51] *** pnu joined
[03:51] *** Southen_ joined
[03:51] *** Woody4286 joined
[04:01] *** r0bby left
[04:02] *** Grrrr left
[04:03] *** simcop2387 joined
[04:03] *** simcop2387-vnc joined
[04:03] *** simcop2387-vnc left
[04:05] <meppl> good night

[04:06] *** meppl left
[04:07] *** xinming left
[04:10] *** xinming joined
[04:31] <skids> well, I got next to nowhere aside from figuring out to use box to get stuff back out.

[04:32] <frooh> it's cool, I have to hit the hay anyway

[04:32] <frooh> thanks for trying :-)

[04:32] <skids> me too.

[04:33] <skids> If I could figure out how to send nl's to evalbot, I'd show how far I got

[04:33] <frooh> haha, it's alright.

[04:33] <frooh> if you wanna paste something or email me that's cool, but I am beat

[04:33] <skids> n8

[04:33] *** alester left
[04:40] *** justatheory joined
[04:43] *** mikehh joined
[04:44] <mikehh> rakudo (84920ea) builds on parrot r37508 - make test/make spectest PASS - Ubuntu Intrepid AMD64

[04:49] <s1n> ruck my funny

[04:49] <s1n> frooh: i finished, err well submitted it

[04:53] *** japhb left
[04:54] *** japhb joined
[05:12] *** Woody4286 left
[05:24] *** simcop2387 left
[05:30] *** Kisu joined
[05:42] *** justatheory left
[05:45] *** tomheady joined
[05:47] *** carpftb_ left
[05:47] *** cj left
[05:47] *** pmichaud left
[05:47] *** d4l3k_ joined
[05:47] *** d4l3k_ is now known as dalek

[05:48] *** cj joined
[05:48] *** Caelum joined
[05:49] *** carpftb joined
[05:49] *** cj left
[05:49] *** pmichaud joined
[05:49] *** cj joined
[05:49] *** carpftb_ joined
[05:49] *** irc.freenode.net sets mode: +o pmichaud

[05:49] *** cj__ joined
[05:49] *** pmichaud left
[05:57] *** masak joined
[06:01] *** cj left
[06:01] *** carpftb_ left
[06:02] *** carpftb_ joined
[06:02] *** carpftb_ left
[06:07] *** Tene_ joined
[06:11] *** Tene left
[06:11] *** Tene_ is now known as Tene

[06:13] *** PerlJam left
[06:13] *** PerlJam joined
[06:38] *** DemoFreak joined
[06:55] *** Grrrr joined
[07:00] *** alc joined
[07:20] *** donaldh left
[07:20] *** donaldh joined
[07:22] *** mberends joined
[07:31] *** eternaleye left
[08:05] *** PZt left
[08:06] *** PZt joined
[08:10] <Matt-W> Morning

[08:10] *** PZt left
[08:10] <moritz_> good morning

[08:11] *** PZt joined
[08:11] <masak> merry morning, my M-letter friends!

[08:12] <Matt-W> #perl6 is brought to you this morning by the letter M and a great deal of coffee.

[08:14] <masak> ah, the letter M is the bringer of such good things!

[08:14] <szabgab> M as in Morning ?

[08:15] *** alc left
[08:15] <moritz_> M as in morning, masak, Matt-W, moritz_, mikehh, Maghnus, mberends, mtve, miloux, meteorjay and Maddingue (sorry for excessive hilight)

[08:15] <Matt-W> I decided to try and be productive today

[08:15] <Matt-W> So I've got my laptop

[08:16] <Matt-W> And I shall try and write some Form at lunchtime

[08:16] <masak> \o/

[08:16] <Matt-W> Although I just realised that it won't have internet access, and I don't have a local copy of the spec

[08:16] <Matt-W> oh well

[08:16] <Matt-W> I need to get my head around gather/take

[08:16] <masak> who doesn't?

[08:16] <Matt-W> If it works like I think it does, I can use it quite handily

[08:16] <Matt-W> and exploit future laziness

[08:17] <masak> mm, future laziness...

[08:17] <Matt-W> I believe if I say

[08:17] *** Gothmog_ left
[08:18] <Matt-W> my @a = gather <something loopy> { <do stuff> take $something; } I end up with a (potentially) lazy list in @a which is made of the $somethings

[08:18] <Matt-W> is that right?

[08:18] <szabgab> rakudo: say 1 == any(@n) ?? "is" !! "isnt"

[08:18] <p6eval> rakudo 84920e: OUTPUT«Scope not found for PAST::Var '@n' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[08:18] <moritz_> Matt-W: it is

[08:18] <Matt-W> woohoo

[08:18] <Matt-W> I can definitely use it then

[08:19] <szabgab> rakudo: my @n=(1,2); say 1 == any(@n) ?? "is" !! "isnt"

[08:19] <p6eval> rakudo 84920e: OUTPUT«is␤»

[08:19] <szabgab> rakudo: my @n=(1,2); say 1 == any @n ?? "is" !! "isnt"

[08:19] <p6eval> rakudo 84920e: OUTPUT«Junction<0xb616ddf8>␤»

[08:19] <Matt-W> the line wrapping function will return a gathered list of lines - if you don't end up using them all, so what, they're lazily generated :D

[08:19] <Matt-W> (once we have laziness, anyway)

[08:20] <szabgab> is that on purpose?

[08:20] <Matt-W> Althoguh generally I think you'll either use one of them or all of them

[08:20] <moritz_> actually many built-ins work that way

[08:20] <szabgab> that ?? is stronger than any()

[08:21] <moritz_> szabgab: yes

[08:21] <moritz_> szabgab: according to S03, at least

[08:21] <moritz_> so that you can use the ternary operator to pass arguments to functions

[08:21] <szabgab> so I keep my ()s

[08:22] <Matt-W> rakudo: my @n=(1,2); say (1 == any @n) ?? "is" !! "isnt"

[08:22] <p6eval> rakudo 84920e: OUTPUT«is␤»

[08:23] <moritz_> rakudo: my @n=1, 2; say 1 == [|] @n ?? "is" !! "isnt"

[08:23] <p6eval> rakudo 84920e: OUTPUT«Junction<0xb60d8be8>␤»

[08:23] <moritz_> same "problem"

[08:23] *** kanru left
[08:23] <szabgab> do you know who is running http://planetsix.perl.org/ ? who should I beg to add my Perl 6 feed?

[08:24] <moritz_> szabgab: [email@hidden.address]
[08:24] *** eternaleye joined
[08:24] <szabgab> tx

[08:31] <Matt-W> Actually instead of writing some Form at lunchtime I might take the opportunity to write about grammars and actions

[08:31] *** simcop2387 joined
[08:32] <szabgab> my $n = any(12, 345); $n.perl.say; my $k = substr($n, 0, 1); $k.perl.say;

[08:32] <szabgab> rakudo: my $n = any(12, 345); $n.perl.say; my $k = substr($n, 0, 1); $k.perl.say;

[08:32] <p6eval> rakudo 84920e: OUTPUT«any(12, 345)␤"J"␤»

[08:32] <szabgab> what, I already drank like 3 cups of tea!

[08:33] <szabgab> rakudo: my $n = any(12, 345); $n.perl.say; my $z = substr($n, 0, 1); $z.perl.say;

[08:33] <p6eval> rakudo 84920e: OUTPUT«any(12, 345)␤"J"␤»

[08:33] <szabgab> ah, that's the first character of the word "Junction" :-)

[08:33] <moritz_> yes

[08:34] <moritz_> PIR builtins don't autothread over junctions

[08:34] <moritz_> one more reason to rewrite them in Perl 6

[08:34] <moritz_> (or at least wrap them in Perl 6)

[08:34] <szabgab> so the above is a bug in rakudo, right ?

[08:34] <szabgab> it should give any(1, 3)

[08:34] <moritz_> right.

[08:36] <szabgab> so you mean the substr() function should be implemented in Perl 6 ?

[08:36] *** Kimtaro left
[08:36] <moritz_> aye

[08:36] <moritz_> it should use the PIR substr function under the hood, though

[08:37] *** PZt left
[08:37] <moritz_> http://rakudo.org/2008/12/rakudo-now-supports-inline-pir.html

[08:37] <szabgab> oh I wsih I could already use rakudo from Perl 5..

[08:39] <Maddingue> use Inline::Parrot;

[08:41] <szabgab> Hi Maddingue 

[08:41] <szabgab> last time I checked i could not yet do this - only run PIR -

[08:41] <szabgab> that's why I stopped my grant for the Parrot+Padre integration

[08:41] <Maddingue> hello szabgab 

[08:42] <Maddingue> of course, I was only joking, I have no idea of the state of Inline::Parrot :)

[08:43] <Matt-W> It's a shame Ponie died

[08:43] <moritz_> I guess know that parrot is more capable and more stable it might be worth to try again

[08:43] <moritz_> OTOH Perl 5 is so unaccessible...

[08:44] <Matt-W> It would still be incredibly difficult I think

[08:44] *** broquaint joined
[08:44] <moritz_> with tie(), magic and stuff

[08:44] <Matt-W> don't forget no spec

[08:44] <moritz_> at least it has a very good test suite

[08:44] <Maddingue> AIUI, it was because Perl5 internals, even with Nicholas and others hackers cleanings, just could not fit on top of Parrot

[08:45] <moritz_> much better than anthing Perl 6 has right now :/

[08:45] <moritz_> *anything

[08:46] <Matt-W> well they've had more time to write one

[08:46] <Matt-W> Maddingue: I understand it was extremely difficult

[08:46] <Matt-W> And reimplementing from scratch was not considered a particularly good idea

[08:46] <Maddingue> I haven't followed P5P recently, but remember recently reading Nicholas listing what was missing to serialize Perl5 code, and there was still major things left to do

[08:48] *** Gothmog_ joined
[08:48] <szabgab> though Inline::Parrot - if I could already use it to run Rakudo code would be the other direction

[08:48] *** alc joined
[08:48] <szabgab> and should not be that difficult , to someone who understands XS and Parrot

[08:49] <moritz_> it seems that those who understand parrot and have time are absorbed by the release process

[08:49] <Matt-W> Well if Inline::Parrot works, it's very conceivable that Inline::Rakudo could work

[08:50] *** ejs joined
[08:58] *** Grrrr left
[08:59] *** Grrrr joined
[09:06] <szabgab> Inline::Parrot can be used to run PIR from Perl 5 code

[09:07] <szabgab> just locatting the main method of Rakudo did not work

[09:07] <szabgab> as it used multiple namespaces

[09:11] *** ejs1 joined
[09:21] *** ejs left
[09:33] *** ejs1 left
[09:42] *** donaldh left
[09:50] *** ejs joined
[10:03] *** DemoFreak left
[10:10] <masak> mberends: been thinking more about PERL6LIB in proto. that one feels like the most blatant absence right now in the list of services to provide. it is set internally in proto, but should be set outside as well.

[10:11] <masak> it's a challenge to do that non-intrusively.

[10:12] <masak> I'm thinking a friendly message at the end of a proto installation, saying "You now need to update your PERL6LIB. Run './update-perl6lib' to do that automatically.

[10:12] <masak> "

[10:13] <moritz_> isn't that '. ./update-perl6lib' or 'source ...'?

[10:13] <masak> well,

[10:14] <masak> right now I'm thinking maybe we should avoid that.

[10:14] <Matt-W> source would only work if it was written for the shell the person was using at the time

[10:14] <masak> what the script will mainly do is update the user's ~/.bash_profile or equiv.

[10:14] <masak> and then the user can simply source that instead.

[10:14] <masak> that feels less intrusive and safer for all involved.

[10:15] <moritz_> less intrusive? I disagree

[10:16] <moritz_> japhb: if you have any more questions about evalbot, feel free to ask

[10:16] <masak> moritz_: good. I like to hear points of view on this.

[10:16] <moritz_> masak: changing a user config which has rather global effects for that user isn't unintrusive

[10:17] <masak> moritz_: you have a point.

[10:17] <moritz_> that said .bash_profile is only sourced by login shells

[10:17] <masak> perhaps offer the commands that will make the right change instead?

[10:17] <moritz_> so it's not necessarily a good place

[10:17] <moritz_> masak: that's better

[10:17] *** alc left
[10:17] * masak switches to wanting that

[10:18] <moritz_> echo 'export PERL6LIB="$path"' >> ~/.bash_profile

[10:18] <moritz_> or .bashrc, whatever is appropriate

[10:18] <masak> moritz_: no, need to do a replace somehow.

[10:18] <masak> perhaps sed would be the right tool here.

[10:19] <masak> mberends: I think the proto projects directory and PERL6LIB are the two sources of information about installed modules. if they disagree, proto can warn about out-of-synchitude.

[10:20] *** kane__ joined
[10:20] <masak> lunch &

[10:21] <bacek> good evening

[10:22] <bacek> rakudo: my $a = \(:b<42>); my $b := |$a; say $b

[10:22] <p6eval> rakudo 84920e: OUTPUT«b  42␤»

[10:22] <bacek> wow... It works!

[10:22] <bacek> rakudo: my $a = \(:b<42>); my $b := |$a; say $a.perl

[10:22] <p6eval> rakudo 84920e: OUTPUT«"b" => "42"␤»

[10:22] <moritz_> rakudo: my $a = \(:b<42>); my $b := |$a; say $b.WHAT

[10:22] <p6eval> rakudo 84920e: OUTPUT«Pair␤»

[10:23] <moritz_> rakudo: my $a = \("b" => 42); my $b := |$a; say $b.WHAT

[10:23] <p6eval> rakudo 84920e: OUTPUT«Pair␤»

[10:27] <bacek> rakudo: sub foo { :a<42> }; my $b := |foo; say $b.perl

[10:27] <p6eval> rakudo 84920e: OUTPUT«"a" => "42"␤»

[10:28] <bacek> rakudo: sub foo { (:b<1>, :a<42>, :c<88>) }; my $b := |foo; say $b.perl

[10:28] <p6eval> rakudo 84920e: OUTPUT«["b" => "1", "a" => "42", "c" => "88"]␤»

[10:28] <bacek> not good...

[10:28] <bacek> pugs: sub foo { (:b<1>, :a<42>, :c<88>) }; my $b := |foo; say $b.perl

[10:28] <p6eval> pugs: OUTPUT«\(\("b", "1"), \("a", "42"), \("c", "88"))␤»

[10:28] <bacek> perl: sub foo { :b<1>, :a<42>, :c<88> }; my $b := |foo; say $b.perl

[10:28] *** elmex_ joined
[10:29] <bacek> oops. I broke evalbot, didn't I?

[10:31] *** pguillaum joined
[10:32] *** pguillaum left
[10:32] *** pguillaum joined
[10:34] <bacek> moritz_: I broke evalbot :(

[10:34] *** elmex_ is now known as elmex

[10:36] <jnthn> oh hai

[10:38] <bacek> hi jnthn!

[10:42] <moritz_> rakudo: say "alive"

[10:42] <p6eval> rakudo 84920e: OUTPUT«alive␤»

[10:42] <moritz_> bacek: ORLY?

[10:42] <moritz_> bacek: I think you just forgot the 6 in perl6: :-)

[10:42] *** pguillaum left
[10:42] <bacek> moritz_: O WAIT... :)

[10:42] <bacek> perl6: sub foo { :b<1>, :a<42>, :c<88> }; my $b := |foo; say $b.perl

[10:42] <p6eval> elf 25860: OUTPUT«Undefined subroutine &GLOBAL::prefix__124 called at (eval 131) line 4.␤ at ./elf_h line 4383␤»

[10:42] <p6eval> ..rakudo 84920e: OUTPUT«["b" => "1", "a" => "42", "c" => "88"]␤»

[10:42] <p6eval> ..pugs: OUTPUT«\(\("b", "1"), \("a", "42"), \("c", "88"))␤»

[10:44] <bacek> moritz_: are there other versions of Perl apart 6? :)

[10:44] <moritz_> bacek: yes

[10:46] <bacek> moritz_: how it's can be??? 

[10:47] <moritz_> bacek: ask TimToady, he wrote them :-)

[10:47] <jnthn> 267 tickets. :-O

[10:48] <bacek> jnthn: It's almost all masak's fault! :)

[10:51] <moritz_> yes, he encourages all people to submit bug reports :-)

[10:56] <bacek> rakudo: my $a = \(:foo<bar>, :b<42>); my $b := |$a; say $b

[10:56] <p6eval> rakudo 84920e: OUTPUT«foo        bar b   42␤»

[10:56] <bacek> hmm...

[11:03] *** meppl joined
[11:10] *** amoc left
[11:11] *** ced-2_ joined
[11:26] *** ced-2 left
[11:30] *** ruoso joined
[11:31] <ruoso> Hello!

[11:31] <lambdabot> ruoso: You have 1 new message. '/msg lambdabot @messages' to read it.

[11:33] *** pmurias joined
[11:34] <pmurias> ruoso: hi

[11:35] <ruoso> hi pmurias 

[11:35] <ruoso> about the empty capture

[11:36] <ruoso> I think I got confused... the empty capture is actually the "interpreter capture"

[11:37] <ruoso> pmurias, btw... I think it's time for we to add support for weak references

[11:37] <ruoso> since it requires an additional RI member

[11:37] <ruoso> and an additional macro as well

[11:37] <masak> .oO( I've been planning my conspiracy for months now... to overthrow Rakudo development with a deluge of rakudobug tickets... )

[11:38] <masak> did I just think that out loud?

[11:38] <pmurias> what's the next thing to port over after idconst and bool?

[11:38] <jnthn> masak: :-P

[11:39] <jnthn> masak: I'm mostly ignoring your conspiracy for the moemnt and distracting myself with trying to implement state variables...

[11:39] <masak> my henchmen are standing by with the rakudobug guns at the ready. be afraid, be very afraid.

[11:40] <japhb> moritz_: I wanted to know the syntax for getting evalbot to work via /msg ... /msg evalbot rakudo: stuff   wasn't working for me

[11:40] <masak> no, actually, bug ticket reporting is a bit lower than average right now. but still nonzero.

[11:41] <ruoso> pmurias, I was thinking that the WEAKREF member should return an object that masks the actual object but starts masking false after that value is lost... then we keep in each object a list of the weakrefs pointing to it, so we go there and override it before calling DESTROYALL....

[11:42] <ruoso> pmurias, that way, it fits into the REFERENCE/RELEASE policy in a way that you simply use WEAKREF where you would use REFERENCE....

[11:44] <pmurias> we could have a WEAKENED member that would be called on the reference when the object it's pointing to gets collected

[11:45] <pmurias> as being overriden with a native false might be something not all weak references want

[11:45] <ruoso> right... although WEAKENED doesn't quite mean that

[11:45] <ruoso> maybe LOSTREF

[11:45] <pmurias> better

[11:46] <ruoso> but that doesn't need to be in the standard responder interface, do it?

[11:46] <pmurias> it can be a method

[11:46] <ruoso> yeah... an special .^! method

[11:47] <ruoso> but...

[11:47] <ruoso> that can be done later,

[11:47] <pmurias> and what happens if the weak reference itself is collected before

[11:47] <pmurias> ?

[11:47] <ruoso> it de-register itself from the referred object...

[11:48] <ruoso> pmurias, for starts, the weakref object is private to the smop-gc code... noone else will be aware of it...

[11:49] <ruoso> so it can do some stuff without calling methosd

[11:49] <ruoso> a more sofisticated implementation of weak references can be done latr

[11:50] <pmurias> so smop-gc is the next thing i should be porting over?

[11:50] <ruoso> once we have all the s0native types, I think so

[11:51] * ruoso changing smop-base to support SMOP_WEAKREF

[11:52] *** skids left
[11:52] <pmurias> ruoso: what do we need the stage 0 interpreter for?

[11:53] <ruoso> to be able to call "new" on mold

[11:53] <ruoso> wait...

[11:53] * ruoso missing caffeine

[11:53] <pugs_svn> r25861 | pmurias++ | [re-smop] removed the empty capture from the list of things needed in s0native

[11:56] <ruoso> pmurias, yes... that's it... 

[11:57] <ruoso> pmurias, if you look at the current interpreter code, you'll see that there's a "prototype interpreter"

[11:57] <ruoso> which is mixed in the interpreter code

[11:57] <ruoso> it implements "goto" by recursing in the C stack

[11:57] <ruoso> this is how the actual interpreter can be destroyed

[11:57] <ruoso> I wanted to make that more explicit

[11:58] <ruoso> specially since this implementation doesn't require gc

[11:59] <pugs_svn> r25862 | ruoso++ | [re-smop] adds support for SMOP_WEAKREF

[12:03] <pmurias> i'm wondering if the gc shouldn't be called refcnt or lowlevel

[12:03] <pugs_svn> r25863 | ruoso++ | [re-smop] implement noop weakref in s0native

[12:03] <ruoso> pmurias, I was wondering the same thing... I simply couldn't find a reasonable name

[12:04] <ruoso> maybe refcnt-gc

[12:05] <ruoso> or gc-refcnt

[12:05] <ruoso> or defaultgc

[12:06] <pmurias> refcnt-gc seems best

[12:07] <pmurias> or gc-refcnt, as opposed to gc-tracing

[12:07] <moritz_> japhb: with s/evalbot/p6eval/ it works

[12:08] <ruoso> pmurias, the problem is that we don't really support gc-tracing

[12:08] <ruoso> so that's a bit misleadin

[12:09] <pmurias> it should be possible to implement a tracing gc in the future

[12:10] <ruoso> trace gc requires all objects to do the tracing

[12:11] <ruoso> otherwise some objects will not be seen as referenced

[12:11] <pmurias> you can keep the alive bit for the objects that don't support it in a hash

[12:11] <ruoso> hm?

[12:14] <pmurias> it's possible to mark an non-trace-gc'ed object by storing the alive bit in an outside data structure (like a hash table)

[12:15] <ruoso> that's not the problem

[12:15] <ruoso> the problem is tracedobj ---references--> non-tracedobj ---references--> anothertracedobj

[12:17] <pmurias> the traced object will need to have a refcnt too

[12:17] <pmurias> * objects

[12:18] <ruoso> so what's the point?

[12:21] *** ujwalic joined
[12:23] <pmurias> ruoso: you're right that doesn't seem very sensible

[12:25] <pmurias> ruoso: the prototyped interpreter seems to only have it's new and DESTROYALL methods invoked in pre-refactored smop

[12:28] *** ruoso left
[12:32] *** DemoFreak joined
[12:36] *** maerzhase joined
[12:58] *** Whiteknight joined
[13:00] *** ruoso joined
[13:03] *** skids joined
[13:04] <ruoso> pmurias, I might be wrong, but I think "goto" is also implemented by the prototype interpreter

[13:04] <ruoso> and it causes the continuation to be invoked recursing in the C stack

[13:07] <ruoso> but yes, I think that only happens at the moment you are creating and destroying the first interpreter

[13:08] <masak> starting from a UTF-8 string, how do I deliberately re-encode it as a string of 7-bit characters? (for use in URI escaping, for example)

[13:09] <moritz_> masak: for URI escape you take the bytes and encode them as %FF and the line

[13:10] <moritz_> masak: other encodings are base64 or utf7

[13:10] <masak> moritz_: it's the 'take the bytes' step I'm asking about.

[13:10] <moritz_> masak: you mean... in Rakudo?

[13:10] <masak> moritz_: both in Rakudo and in Perl 6.

[13:11] <masak> I'm looking for both answers. (as I usually am.)

[13:11] <moritz_> I'd guess you pack it into a Buf

[13:11] * masak thought so

[13:11] <moritz_> or maybe we need more builtins for that

[13:11] <moritz_> something like Str.encode($encoding, :$normalizatioon)

[13:12] <masak> can this type of thing be done with pack/unpack?

[13:12] <moritz_> in Perl 5 it can, I think

[13:12] <masak> good.

[13:12] <masak> then I'll find out how, and then implement that in Rakudo.

[13:13] <moritz_> U   A Unicode character number.  Encodes to a character in character m

[13:13] <moritz_> ode and UTF-8 (or UTF-EBCDIC in EBCDIC platforms) in byte mode.

[13:13] <moritz_> from perldoc -f pack

[13:14] <masak> great.

[13:14] <masak> should be doable in Parrot, I think.

[13:14] <masak> chr/ord works that way, if nothing else.

[13:14] <moritz_> no.

[13:14] <moritz_> chr/ord don't deal with bytes

[13:14] <moritz_> they deal with characters

[13:15] <moritz_> rakudo: say 1;

[13:15] <p6eval> rakudo 84920e: OUTPUT«1␤»

[13:15] <moritz_> rakudo: say ord('␤')

[13:15] <p6eval> rakudo 84920e: OUTPUT«10␤»

[13:15] <moritz_> oh noes, p6eval translates that to a newline

[13:15] <masak> :)

[13:16] <moritz_> rakudo: say ord('λ')

[13:16] <p6eval> rakudo 84920e: OUTPUT«955␤»

[13:16] <moritz_> UTF-8: 0xCE 0xBB

[13:16] *** ejs left
[13:16] <masak> moritz_: ah, and the transformation from 955 to 0xCE 0xBB is nothing I want to implement myself?

[13:16] <Matt-W> Woohoo!

[13:16] <Matt-W> I got my modules bug down to a test case

[13:16] <masak> Matt-W++

[13:17] <Matt-W> I'll file a rakudobug when my laptop has internet again this evening

[13:17] <moritz_> masak: that has to be accessible from within Perl 6 somehow

[13:17] <masak> aye.

[13:17] <moritz_> that's what all IO does

[13:18] <masak> I want all this, but my head is too small for encodings today.

[13:18] <masak> I'm at a loss to formulate my requirements.

[13:20] <moritz_> you need to decompose a character into bytes using UTF-8

[13:20] <moritz_> and then you want to percent-escape bytes that aren't valid in URIs

[13:20] <moritz_> s/decompose/encode/

[13:20] <masak> moritz_: I've got the percent-escape part covered. stole it from Rack.

[13:21] <moritz_> .trans is good for that, I guess :-)

[13:22] <masak> moritz_: ah, you've just contributed to Web.pm :)

[13:22] *** araujo left
[13:23] <moritz_> :-)

[13:26] <moritz_> didn't jnthn wanted to do his rakudo day today?

[13:27] <jnthn> moritz_: I'm doing it... :-P

[13:27] <moritz_> jnthn: ah

[13:27] <masak> jnthn: you're doing it very quietly. :)

[13:27] <jnthn> moritz_: The lack of flurry of commits is because I'm working on something bigger (state vars)

[13:27] *** zamolxes joined
[13:27] <moritz_> ah

[13:27] <masak> jnthn++

[13:28] <moritz_> rakudo: sub a { state $x++ }; say a() for 1..5

[13:28] <p6eval> rakudo 84920e: OUTPUT«Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤»

[13:35] *** vladusagnu joined
[13:36] <moritz_> well, at least we seem to have plenty of test cases for state vars

[13:36] <jnthn> moritz_: Yes.

[13:36] <moritz_> t/spec/S04-declarations/state.t and some integration tests, as well as several spread out over the test suite

[13:37] <moritz_> finally something where you profit from it :-)

[13:37] <moritz_> (the tests for parametric roles were pretty catastrophic, I think :-)

[13:38] <Matt-W> \o/ state vars!

[13:39] <jnthn> I don't begrudge anyone for not wanting to think deeply about parametric roles. ;-)

[13:40] <Matt-W> I'm not sure what they are yet

[13:40] <Matt-W> But they sound scary

[13:40] <Matt-W> I showed a colleague some Perl 6 - he said it looked odd

[13:40] <mikehh> rakudo (84920ea) buikds on test 1.0.0 tarball - make test/make spectest PASS

[13:41] <Matt-W> it was a gather/take construct and he doesn't understand laziness

[13:41] <mikehh> that's on Kubuntu Intrepid i386

[13:42] <moritz_> Matt-W: I think from a user's point of view you can get used to it pretty quick

[13:42] <moritz_> just need more examples

[13:44] <Matt-W> moritz_: yeah well I have :)

[13:46] <jnthn> I figured I'd learn about lazy lists when I need to use one.

[13:47] <jnthn> woo, progress

[13:47] <jnthn> > sub foo { state $x = 1; say $x++ }

[13:47] <jnthn> > foo(); foo(); foo();

[13:47] <jnthn> 1

[13:47] <jnthn> 2

[13:47] <lambdabot>   <no location info>: parse error on input `;'

[13:47] <lambdabot>   <no location info>: parse error on input `$'

[13:47] <jnthn> 3

[13:47] * Matt-W knows lazy lists due to being a Haskell programmer

[13:48] <jnthn> Well, now we pass at least the first five tests of state.t

[13:48] <Matt-W> woooooooooooo

[13:48] <Matt-W> jnthn++

[13:49] <krunen> jnthn: Hi! About your P6 Express talk at NPW, we've had some program changes - a half hour extra. Can you fill up 130 mins? Or should we find some other stuff to put in?

[13:51] <krunen> jnthn: maybe we could add a "Play with perl6 - questions answered" item?

[13:52] *** ejs joined
[13:53] *** AndyAway is now known as alester

[13:54] <pugs_svn> r25864 | ruoso++ | [re-smop] define the structure of re-smop in a bit more details...

[13:54] <jnthn> krunen: I can haz more time?!

[13:55] <jnthn> krunen: I can probably wab on about Perl 6 for days, an extra 30 minutes is no problem...

[13:55] <krunen> jnthn: I know, a real luxury :)

[13:56] <jnthn> I tend to encourage questions along the way anyway rather than a load at the end. Thoguh sometimes get both. Really depends on the audience... :-)

[13:56] <ruoso> moritz_, btw... I saw in the backlog that you asked about it... re-smop is refactored smop. We're splitting it up in several modules to make the dependencies clearer and the build system saner, as well as do the capture refactoring, remove "void* data" from "struct SMOP__Object" and add support for weak references...

[13:56] <moritz_> rakudo: role Tax[$percent] { method pay { my $x = $.amount * $percent; say "paying $x"; $.amount -= $x}}; class Worker does Tax[0.18] { has $.amount is rw }; Worker.new(amount => 200).pay

[13:56] <p6eval> rakudo 84920e: OUTPUT«paying 36␤»

[13:57] * masak starts saving up questions for jnthn's talk

[13:57] <moritz_> ruoso: ok

[13:57] <ruoso> 'struct SMOP__Object' is now just '{ SMOP__ResponderInterface* RI }'

[13:57] <krunen> jnthn: OK, I'll put in a short break, so you'll have 80+40 minutes, if that's ok. You can arrange the rest as you like.

[13:57] <jnthn> masak: "When will you fix RT#\d+?" is not a valid question. :-P

[13:57] <jnthn> krunen: Short break is good.

[13:58] <jnthn> Last time I talked for that long I drained the speakers water jug...

[13:58] <masak> jnthn: it isn't? dang...

[13:58] <krunen> jnthn: :) - great, thanks!

[13:58] <jnthn> krunen: No probs. :-)

[13:59] <jnthn> krunen: In reality I'll probably read the schedule about a week before the conference and just prepare for what it says I'm doing. ;-)

[14:00] <krunen> jnthn: that also works, and is really easy for us :)

[14:05] <jnthn> OK, I can pass half of state.t so far. Not a bad start...

[14:07] *** Kisu left
[14:07] <jnthn> (And six of them depend on other features unrelated to state, so only 4 are issues I need to dig into.)

[14:08] *** vladusagnu left
[14:11] *** Exodist joined
[14:14] <rgs> I have a smart match question

[14:14] <rgs> in the table in S03 there is :     Hash      Regex     hash key "boolean grep" .any.match(X)

[14:15] <rgs> what does that mean when the hash is empty ? that the match fails ?

[14:15] <skids> jnthn: is there a magical incantation to get a lexical into inline PIR?

[14:15] * rgs not very familiar with .any

[14:15] <skids> (other than "self")

[14:15] <moritz_> rakudo: say ?any()

[14:15] <p6eval> rakudo 84920e: OUTPUT«0␤»

[14:16] <moritz_> rgs: any() on empty thins is false

[14:16] <rgs> moritz_: so that fails

[14:17] <jnthn> skids: Yes

[14:17] <pugs_svn> r25865 | jnthn++ | [t/spec] Fudge state.t for forthcoming Rakudo commit; we can pass half of it (of the missing ten tests, six we can't do yet due to other missing features, four a probably bugs in the first cut of state).

[14:17] <jnthn> $P0 = find_lex '$x'

[14:18] <jnthn> rgs: Agree with moritz - any is afaik "at least one thing or more matches"

[14:18] <rgs> thanks

[14:18] * rgs will put some of that in perl 5

[14:19] <rgs> through a few layers of adaptation of course

[14:19] <jnthn> rgs: While any epxresses the concept quite neatly in the specification, I find it unlikely that we'll actually do that in Rakudo using junctions...

[14:19] <pmurias> ruoso: re goto i greped interpreter.c and only the real one implements goto

[14:20] <ruoso> pmurias, ok then... I think it's lowlevel.sm0p that checks if the interpreter is the prototype one recurses directly instead of creating a mold

[14:20] <pmurias> ruoso: i remove a bunch of unneeded stuff from the prototype one at some point

[14:21] <rgs> jnthn: nor in perl 5

[14:21] <ruoso> pmurias, cleanup is always good

[14:24] <ruoso> pmurias, ok... that probably mean we can have the s0 interpreter with the "unimplemented" message

[14:24] <jnthn> rgs: I figured, though in Rakudo we do hvae junctions so it would be a more realistic approach.

[14:24] <pugs_svn> r25866 | jnthn++ | [t/spec] Unfudge a state test in multiple.t that we now pass.

[14:25] <ruoso> pmurias, because we can add exceptions in s0native, gc, mold and native about it... and that means it should only be used until you really can't have a real interpreter

[14:25] *** DemoFreak left
[14:26] <ruoso> pmurias, we can even call it "empty interpreter"... 

[14:27] <dalek> rakudo: 4ff1b17 | jnthn++ |  (4 files):

[14:27] <dalek> rakudo: First cut implementation of state variables in Rakudo. Not perfect, but passes at half of state.t (and 5/7ths of what in state.t we can pass without implementing extra unrelated features). Needs makefile re-generated to build.

[14:27] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4ff1b172b44aceaa04e1721a4be65ea2f4dc5b03

[14:27] <dalek> rakudo: e43118a | jnthn++ | perl6.pir:

[14:27] <dalek> rakudo: Ooops; last commit missed updated perl6.pir to reference PCT state extension.

[14:27] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e43118a79fddced1d615becafacfb3c563851946

[14:27] <dalek> rakudo: 042444b | jnthn++ | t/spectest.data:

[14:27] <dalek> rakudo: Add S04-declarations/state.t to spectest.data.

[14:27] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/042444b96b7496bc74f0043369b67f6c5c57dd37

[14:27] <dalek> rakudo: 5af6f41 | jnthn++ |  (2 files):

[14:27] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[14:27] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5af6f41baa29dd74105b8c9e31b83b4b6f494959

[14:31] <skids> jnthn: muchas gracias

[14:33] <jnthn> skids: de nada

[14:33] *** Kisu joined
[14:34] *** hercynium joined
[14:37] *** disismt joined
[14:39] <moritz_> rakudo: sub f returns Num { 1 }; say &f.signature.perl

[14:39] <p6eval> rakudo 5af6f4: OUTPUT«:()␤»

[14:40] <moritz_> rakudo: sub f returns Num { "foo" }; say f()

[14:40] <p6eval> rakudo 5af6f4: OUTPUT«foo␤»

[14:40] <moritz_> rakudo: sub f returns Num { return "foo" }; say f()

[14:40] <p6eval> rakudo 5af6f4: OUTPUT«foo␤»

[14:41] <jnthn> moritz_: ENOTYETIMPLEMENTED

[14:42] <jnthn> So to get the example in 99-problems to run turns out I had to fix a bug in gather...take.

[14:42] <moritz_> jnthn: I know, there's a perlmonks question about it

[14:42] <moritz_> so I wanted to be sure

[14:42] <jnthn> ah crap

[14:42] <jnthn> fixing that causes a gather take test to fail.

[14:44] <Matt-W> urgh I hate it when things like that happen

[14:44] <Matt-W> I think one of the main reasons we have so much broken code at work is that there's so much other code relying on it being broken

[14:44] <moritz_> http://www.perlmonks.org/?node_id=751203

[14:44] <jnthn> Matt-W: Actually the test in gather.t was right too

[14:44] <jnthn> Matt-W: My fix is what's at fault.

[14:45] <masak> the great thing about having tests is that they flag things like that.

[14:46] <masak> they're like "yes, but..." and you go "oh, of course" and develop a better patch.

[14:46] <masak> not bad for some soulless snippets of code.

[14:46] <jnthn> aye

[14:46] <Matt-W> jnthn: You didn't have to admit that :)

[14:46] <moritz_> anyway, spectest is clean here

[14:46] <jnthn> Apart from I ain't completely sure what the right thing to do is... :-|

[14:46] <Matt-W> yes good tests are so useful

[14:46] <masak> Matt-W: tests rock.

[14:46] <jnthn> maybe a cuppa tea will help...

[14:47] <masak> jnthn: good idea!

[14:47] * masak makes a cup of flax tea

[14:47] <moritz_> Matt-W: he had to, because otherwise I'd have investigated which tests are at fault

[14:47] <moritz_> :-)

[14:48] <jnthn> btw nice work to whoever ported gather/take to Perl 6. :-)

[14:48] <jnthn> erm

[14:48] <jnthn> map even

[14:48] <jnthn> To use gather take

[14:49] <Matt-W> I believe that was one of the other M people

[14:49] * moritz_ raises hand

[14:49] <moritz_> and cspencer++ contributed grep, which inspired me

[14:51] *** namenlos joined
[14:51] <jnthn> Nice

[14:52] <jnthn> Eventually I want all of that lot in Perl 6...

[14:54] <jnthn> (Then we s/class/role/, add a type parameter, scatter it around the signatures, etc...)

[14:55] <Matt-W> do parametric roles work yet?

[14:55] <jnthn> Matt-W: Yes.

[14:55] <Matt-W> cool!

[14:55] <jnthn> Matt-W: See various tests in S12-role. :-)

[14:57] <masak> wait, so map and grep will eventually be lazy too?

[14:57] <moritz_> Matt-W: I posted an example earlier, with a Tax role that is parameterized by the tax percentage

[14:58] *** ejs left
[14:58] <jnthn> Matt-W: I posted examples in my journal involving linguistics and alcohol.

[14:59] <Matt-W> masak: of course!

[14:59] <masak> :)

[14:59] <Matt-W> why have lazy lists if you don't have lazy map/grep?

[14:59] <masak> yes, now that I think about it...

[15:00] <Matt-W> then you can implement my functional programming lecturer's way of solving Countdown number rounds in Perl 6

[15:00] <Matt-W> (it relies very heavily on lazy lists in Haskell)

[15:01] *** pmichaud2 joined
[15:01] <Matt-W> oh no there are two of them now...

[15:02] *** pmichaud2 is now known as pmichaud

[15:02] <Matt-W> :)

[15:02] <jnthn> oh no? 2 pmichauds would be great!

[15:02] <Matt-W> this is true

[15:02] <moritz_> Matt-W: be careful, Perl 6 doesn't assert lazyness other than on infinite lists

[15:02] <Matt-W> two jnthns would be great too

[15:03] <Matt-W> moritz_: how fortunate...

[15:03] <pmichaud> good morning/localtime, everyone.

[15:03] <Matt-W> moritz_: oh no, they don't end up infinite. hmm. There is a better way to do it in Perl 6 anyway, since it has side effects

[15:03] <jnthn> pmichaud: OH HAI

[15:04] * masak would like to see http://okmij.org/ftp/Haskell/number-sieve.lhs implemented in Perl 6

[15:04] <jnthn> rakudo: sub foo { state $x = 1; say $x++ }; foo() for 1..4;

[15:04] <p6eval> rakudo 5af6f4: OUTPUT«1␤2␤3␤4␤»

[15:04] <masak> pmichaud: good afternoon/localtime.

[15:04] <pmichaud> jnthn: yes, I saw the diff.  :-)

[15:04] <jnthn> pmichaud: Thoughts?

[15:04] <pmichaud> well, I saw the commit, but not the diff yet.

[15:04] <jnthn> Ah.

[15:04] <jnthn> Damm, I thoguth the ":-)" was indicative of a positive code-review.

[15:05] <jnthn> ;-)

[15:05] <Matt-W> masak: you really need laziness for that...

[15:05] <jnthn> pmichaud: I'm not handling binding properly yet.

[15:05] <pmichaud> I'll probably review it a bit later.  For now I'm very glad that it works.

[15:05] <Matt-W> masak: well, if you want it to run reasonably fast anyway

[15:05] <jnthn> pmichaud: If you have a moment, I'd like to pick your brain on a bug I'm trying to work out a solution for.

[15:05] <pmichaud> sure, I have a moment -- at least until @family wakes up.

[15:05] <masak> Matt-W: yes, it definitely needs laziness. doesn't stop someone from writing an ideal Perl 6 version, though.

[15:06] <Matt-W> masak: no absolutely not

[15:06] <jnthn> pmichaud: OK, I haven't *quite* got it down to its essence yet but

[15:06] <jnthn>     my $compress = sub ($x) {

[15:06] <jnthn>         state $previous;

[15:06] <jnthn>         return $x ne $previous ?? ($previous = $x) !! ();

[15:06] <jnthn>     }

[15:06] <jnthn>     my @compressed = map $compress, <a a a a b c c a a d e e e e>;

[15:06] <jnthn> map is not using gather/take

[15:06] <jnthn> *now

[15:06] <jnthn> It's implemented in the setting etc

[15:06] <jnthn> @compressed.perl ends up holding

[15:07] <lambdabot> Unknown command, try @list

[15:07] <jnthn> ["e", "e", "e", "e", "e", "e"]

[15:07] <jnthn> If you do a "say" in take, it gives the expected output for each time...

[15:07] <pmichaud> there was a long discussion related to this last week or so

[15:07] <pmichaud> the discussion centered around how we handle "return" values

[15:08] <pmichaud> but it applies to "take" also.

[15:08] <jnthn> Ah, OK.

[15:08] <jnthn> So I haven't got a state-specific issue? That is good to know at least...

[15:08] <pmichaud> the problem is that take is returning the same PMC each time.

[15:08] <jnthn> Right.

[15:08] * diakopter cingular gprs from amtrak somewhere in southeastern colorado

[15:09] <pmichaud> but if we simply make "take" clone the value, then it can't really be used for creating Lists

[15:09] <jnthn> Was there a decided solution, or is it still on the things-to-think-about list?

[15:09] <jnthn> Yeah, I pondered clone then thought...no.

[15:09] <jnthn> Then I tried !DEREF which of course is epic fail...

[15:09] <pmichaud> I had to leave before I saw a decided solution, and I haven't gone back to read the logs

[15:09] <jnthn> (Since if you're returning array refs it messes things up...)

[15:10] *** Tene_ joined
[15:11] * jnthn tries to search the irclogs

[15:11] <pmichaud> anyway, the problem isn't specific to 'state' variables.  There's also an rt about it already (looking)

[15:13] <jnthn> 20:18 pmichaud did we ever get resolution on captures, return, and the like?  I didn't see it in the scrollback.

[15:13] <jnthn> 20:18 ruoso pmichaud, I saw the scrollback... but we got no resolution

[15:13] <pmichaud> well.... there ya go :-)

[15:13] <pmichaud> RT #62178 is also related.

[15:13] <jnthn> OK

[15:14] <jnthn> I think in that case I'll not try and put in a fix for this...seems it needs some more serious thinking and so forth.

[15:14] <pmichaud> agreed, and I suspect the ultimate fix will be a little hairy.

[15:14] <jnthn> Aye.

[15:15] <jnthn> This is one of the cases where not to scatter workarounds in the codebase for the time being IMO.

[15:15] <pmichaud> agreed.

[15:15] <jnthn> OK, well, at least we have state support to some degree now.

[15:15] *** nihiliad joined
[15:15] <jnthn> Got 4 tests in state.t that I think we could pass but currently are not.

[15:16] <pmichaud> in rakudo's case it may come down to the pmc vs. immutable problem again -- Parrot's model of "container" doesn't match Perl 6's model

[15:16] <jnthn> (And 6 that depend on other features)

[15:18] *** [particle]1 left
[15:19] *** ced-2 joined
[15:20] <pmichaud> looks like things are starting to happen here -- will check in again later.  

[15:21] <jnthn> OK. :-)

[15:21] *** Tene left
[15:21] <jnthn> Gah. my $bug is nasty

[15:22] <ruoso> jnthn, we actually did 

[15:22] <ruoso> a bit after that

[15:23] <ruoso> capture in item context returns itself unless there is one and only one argument (positional or named)

[15:23] <ruoso> in which case it returns that argument

[15:23] *** [particle]1 joined
[15:24] <pmichaud> ruoso: I don't think that addresses this problem directly, though.

[15:24] <ruoso> I can't see where it doesn't...

[15:24] <ruoso> (the biggest confusion was because of the invocant, which no longer exists in the capture)

[15:24] <ruoso> invocant is now only a compile-time concept

[15:25] <pmichaud> our issue isn't to do with the invocant.

[15:25] <ruoso> what is your issue then?

[15:26] <pmichaud> 'take' executed repeatedly on the same scalar causes that scalar to appear multiple times in the output, even if the scalar changes value between separate invocations of take

[15:26] <ruoso> ah... that's the other issue indeed... 

[15:27] <ruoso> which is, a value always "is ref" in a capture

[15:27] <pmichaud> right.

[15:27] *** Psyche^ joined
[15:29] <pmichaud> afk for a while # vacation

[15:29] <ruoso> my last thought on it was that the capture could provide an auto-generated signature depending on how it was built and the traits of &?ROUTINE

[15:30] <ruoso> so methods like "take" and "return" can apply that capture against the signature to enforce the appropriate context

[15:33] <japhb> moritz_: thank you!

[15:36] *** sri_kraih_ joined
[15:37] *** smtms left
[15:40] *** ced-2_ left
[15:41] <ruoso> pmichaud, jnthn, maybe the compiler could autogenerate a lexically scoped candidate for return depending on how it was invoked in that block enforcing the traits of the &?ROUTINE...

[15:42] *** ced-2_ joined
[15:42] <jnthn> ruoso: That feels hacky...

[15:43] <jnthn> (and feels like we're missing some deeper issue...)

[15:43] <ruoso> the thing is that the capture object doesn't hold all the information to apply that contstraints

[15:43] <ruoso> for instance...

[15:43] <jnthn> Since this equally applies to take also and maybe more things.

[15:43] *** Patterner left
[15:43] *** Psyche^ is now known as Patterner

[15:43] <ruoso> it can't make a copy without knowing the context

[15:43] <ruoso> the sigil provides context, otoh

[15:44] <ruoso> so the answer is in the code

[15:44] <ruoso> return $a, @b, %c 

[15:44] <ruoso> would mean making a scalar assignment, a list assignment and a hash assignment

[15:44] <ruoso> hmm...

[15:44] <jnthn> I suspect in that case it's about how we constrct the capture.

[15:45] <ruoso> yes... my guess is that the answer is in the sigil

[15:45] <jnthn> that is, does it actually reference $a or ($anon = $a)

[15:45] <ruoso> the capture currently actually references $a

[15:45] <ruoso> otherwise sub foo ($a is ref) wouldn't be able to work

[15:46] <jnthn> Or is rw...

[15:46] <ruoso> yes

[15:46] <ruoso> it's just that "is ref" is the strongest, so every capture need to be constructed that way

[15:48] <mberends> </lurk> masak: yes, PERL6LIB and a bin directory in PATH are external dependencies for proto or any installer. How to do it (.profile, .bashrc, Windows Environment) is inherently non portable. To handle it in proto is treading the slippery slope of OS detection :( ISTR you once wrote (and I think so too) that you can exit installer with a message suggesting how the user should update her environment. In per6-examples I have temporarily settled for cd <

[15:48] <mberends> project_dir> and make <action>, where <action> can grok PERL6LIB etc relative to `pwd`.

[15:49] <ruoso> jnthn, but I still feel that we're going to end defining return, take and the like as keywords that apply that constraints... that seems to be the most sane way of doing it atm

[15:50] <[particle]1> mberends: i've been thinking about providing a command-line shortcut for setting an environment var... that would be portable, then.

[15:50] <ruoso> jnthn, because the answer is in the AST

[15:50] <[particle]1> at least, the method of setting the vars would be portable

[15:51] <masak> mberends: message on exit is probably the best course of action, yes. that was the solution moritz_++ and I arrived at today.

[15:51] <mberends> masak: the shortcut is shell dependent, like source <script>

[15:51] <masak> we won't do that.

[15:51] *** ced-2 left
[15:51] *** sri_kraih left
[15:52] <mberends> I saw the backlog. It's been frustrating to watch so much activity scroll by this week and be unable to participate :(

[15:53] <masak> mberends: I can imagine.

[15:54] <jnthn> ruoso: Having to have return and take generated on a sub-by-sub or whatever bass really doesn't feel the way to go; if we can make them do the right thing in a generic way, though...

[15:55] *** ced-2 joined
[15:56] <jnthn> *basis

[15:56] <mberends> I would like to thank jnthn++ for guiding me through a simple PIR patch in the weekend instead of doing it in a tenth of the time himself. That helps me dare try a bit more PIR in future, which was probably exactly what he intended.

[15:57] *** tomheady left
[15:58] *** zamolxes left
[15:59] *** justatheory joined
[15:59] *** Kisu left
[16:01] *** disismt left
[16:09] *** Kisu joined
[16:12] <jnthn> Oh!! The one infinite recursion bug in state.t turns out not to be an issue with state vars, but because //= doesn't short-circuit properly...

[16:14] *** tomheady joined
[16:19] *** ced-2_ left
[16:19] <pugs_svn> r25867 | jnthn++ | [t/spec] Tweak and unfudge another couple of state.t tests.

[16:23] <pugs_svn> r25868 | pmurias++ | [re-smop] added empty interpreter to s0native

[16:24] <dalek> rakudo: cc85a31 | jnthn++ | src/ (3 files):

[16:24] <dalek> rakudo: Sometimes you have to screw it up before getting it right(er). Refactor state variables a bit. Gets all tests in state.t that aren't broken due to other features missing/broken passing.

[16:24] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cc85a31ab053f3218d49eed4d4d3d324fa8f8506

[16:26] <jnthn> masak: ping

[16:26] <masak> jnthn: you pang?

[16:26] *** bigpresh joined
[16:27] *** bigpresh left
[16:28] *** bigpresh joined
[16:28] <jnthn> masak: About one of your tickets. :-)

[16:28] <masak> yes? :)

[16:28] <masak> which one?

[16:28] <jnthn> my $i = 0;

[16:28] <jnthn> my $func = { state $x = $i++; say $x };

[16:28] <jnthn> my ($a, $b) = $func.clone, $func.clone; 

[16:28] <jnthn> $a(); $b(); $a();

[16:28] <jnthn> I this code, before rakudo gave 0 1 2 which we can agree is wrong. 

[16:28] <masak> did I submit that one? wow.

[16:28] <jnthn> You expect however 0 1 1.

[16:28] <masak> yes.

[16:28] <jnthn> I expect 0 1 0.

[16:28] <masak> ok.

[16:29] * moritz_ expects 0 0 1

[16:29] <masak> let's talk about the final digit then.

[16:29] <masak> oh, I'm with moritz_.

[16:29] <masak> my expectation had a typo in it. :)

[16:29] <moritz_> I'd expect the state var to be per closure

[16:29] <moritz_> so that $a(), $a() would return 0, 1

[16:29] <masak> exactly.

[16:29] <pmurias> ruoso: what is the method that we invoke with the "interpreter capture"

[16:29] <masak> that must have been the point of the ticket.

[16:29] <moritz_> and $b() should be totally independent

[16:30] <jnthn> moritz_: $b *is* totally independent.

[16:30] <jnthn> It has its own state var.

[16:30] <moritz_> ah, but $i is different

[16:30] <moritz_> ouch

[16:30] <jnthn> Yes, you change $i

[16:30] <jnthn> Well no, $i is the same $i for all of 'em.

[16:31] <moritz_> right

[16:31] <moritz_> but the initialization part is only executed the first time the closure is called

[16:31] <jnthn> So when you do $a() the first time, it sets state $x to $i which is 0.

[16:31] <moritz_> right.

[16:31] <jnthn> And post-increments $i

[16:31] <jnthn> So when you then do $a() again later, it still has the value of 0.

[16:31] <moritz_> then when you call b, b's state var is set to 1

[16:31] <jnthn> Right.

[16:31] <masak> jnthn: I'm with you again.

[16:31] <moritz_> ok

[16:32] <masak> I didn't look closely enough at the code.

[16:32] <moritz_> then I'm with you too

[16:32] <moritz_> weird test :-)

[16:32] <masak> (did I really write that?) :)

[16:32] <jnthn> masak: Yes. It's a good one.

[16:32] <jnthn> But certainly had me scratching my head for a while.

[16:32] <masak> :)

[16:32] <jnthn> I *think* that 0 1 0 is the correct output though.

[16:33] <masak> aye.

[16:33] <jnthn> (And happily, the one that Rakudo now gives.)

[16:33] *** mberends left
[16:33] <jnthn> I'm going to add this to the spectests. :-)

[16:33] <moritz_> please do

[16:33] <masak> jnthn++ spectests++

[16:34] <moritz_> and add a comment "think thrice about this one before changing it" or something :-)

[16:34] <masak> "you are not expected to understand this."

[16:35] <pugs_svn> r25869 | moritz++ | [t/spec] a tiny unfudge

[16:35] *** tomheady left
[16:39] <pugs_svn> r25870 | jnthn++ | [t/spec] State/cloned closure interaction tests; based of bug report from masak++.

[16:39] <jnthn> heh, and now Nick wants to know know if it works properly for lists... :-)

[16:40] <moritz_> :-)

[16:40] <jnthn> rakudo: my @bar = 1,2,3; sub foo { state (@foo) = @bar; say @foo; @foo[0]++ }; foo() for 1..3;

[16:40] <masak> they're never satisfied, those programmers. :)

[16:40] <p6eval> rakudo cc85a3: OUTPUT«123␤223␤323␤»

[16:40] <moritz_> rakudo: sub f { state @x = 3, 4; say ++@x[1] }; f, f, f

[16:40] <p6eval> rakudo cc85a3: OUTPUT«5␤6␤7␤»

[16:41] <moritz_> looks like it does

[16:41] <jnthn> I think that's a yes...

[16:41] <moritz_> don't we have tests for state arrays/hashes?

[16:41] <jnthn> moritz_: One

[16:41] <jnthn> But it currently infinitely recurses

[16:41] <moritz_> damn.

[16:41] <jnthn> Due to //= not short-circuiting.

[16:42] <jnthn> I hunted for a state var bug for about 10 minutes before realizing that's what was wrong though.

[16:42] <jnthn> Re-writing it not to use //= made it work fine.

[16:42] <moritz_> rakudo: sub f {state $x = do { say "init" } }; f(); f();

[16:42] <jnthn> But maybe the answer is to fix //= :-)

[16:42] <p6eval> rakudo cc85a3: OUTPUT«init␤»

[16:42] <jnthn> .oO( phew, glad I made sure we only run the RHS when we need to )

[16:43] <moritz_> I'd have caught you soon :-)

[16:47] *** maerzhase1 joined
[16:47] *** maerzhase left
[16:48] <jnthn> moritz_: Not sure if we have a good spectest to cover impure right hand sides in fact...

[16:50] <moritz_> jnthn: I'll add one

[16:50] *** eternaleye left
[16:51] *** cj__ is now known as cj

[16:54] <jnthn> moritz_: Or I can?

[16:54] <jnthn> Just adding some for arrays for Nick...

[16:54] <moritz_> jnthn: sure you can

[16:54] <jnthn> moritz_: I'm just in the file already, and have local diffs, so...

[16:58] *** masak left
[16:58] <pugs_svn> r25871 | jnthn++ | [t/spec] Tests for impure RHS of state variable initialization as suggested by moritz++ and for state variable and list assignment as suggested by (Nick Clark)++.

[17:00] <jnthn> Thanks all, for helpful feedback. :-)

[17:00] <jnthn> community++

[17:00] <rgs> Nicholas++

[17:03] *** M_o_C joined
[17:04] <jnthn> $?PROGRAM was changed to $?PROGNAME right?

[17:04] <moritz_> rakudo: say $?PROGRAM_NAME

[17:04] <p6eval> rakudo cc85a3: OUTPUT«Scope not found for PAST::Var '$?PROGRAM_NAME' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[17:04] <moritz_> rakudo: say $?PROGRAMM

[17:05] <p6eval> rakudo cc85a3: OUTPUT«Scope not found for PAST::Var '$?PROGRAMM' in ␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[17:05] <jnthn> Ah, it's the compiler version, we have $*PROGNAME I think

[17:06] <moritz_> rakudo: say $*PROGNAME

[17:06] <p6eval> rakudo cc85a3: OUTPUT«Use of uninitialized value␤␤»

[17:09] *** kane__ left
[17:14] <jnthn> rakudo: &map.assuming({})

[17:14] <p6eval> rakudo cc85a3: OUTPUT«Method 'assuming' not found for invocant of class 'Perl6MultiSub'␤current instr.: 'parrot;P6metaclass;dispatch' pc 637 (src/classes/ClassHOW.pir:161)␤»

[17:16] <jnthn> rakudo: our $x; class Foo { $x = 3 }; say $x

[17:16] <p6eval> rakudo cc85a3: OUTPUT«Null PMC access in getprop()␤current instr.: 'infix:=' pc 14332 (src/builtins/assign.pir:21)␤»

[17:16] <jnthn> Hmm.

[17:16] <jnthn> rakudo: our $x; class Foo { $x = 3 };

[17:16] <p6eval> rakudo 285279: OUTPUT«Null PMC access in getprop()␤current instr.: 'infix:=' pc 14332 (src/builtins/assign.pir:21)␤»

[17:21] <dalek> rakudo: 285279b | jnthn++ | build/gen_metaop_pir.pl:

[17:21] <dalek> rakudo: Fix LHS-dwimming hyper-op unicode variant generation. Patch thanks to krunen++.

[17:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/285279b0cfce47dfca90616dbc9c65b8e8c0bf89

[17:21] <jnthn> rakudo: say 1 ~~ Junction

[17:21] <p6eval> rakudo 285279: OUTPUT«0␤»

[17:22] <jnthn> rakudo: say any(1) ~~ Junction

[17:22] <p6eval> rakudo 285279: OUTPUT«Null PMC access in get_integer()␤current instr.: 'parrot;Junction;!type' pc 9503 (src/classes/Junction.pir:180)␤»

[17:22] <jnthn> gah

[17:22] *** pmurias left
[17:33] *** tomheady joined
[17:34] *** lucs joined
[17:35] *** tomheady left
[17:35] *** tomheady joined
[17:35] *** Tene_ is now known as Tene

[17:36] *** sahadev joined
[17:37] *** Psyche^ joined
[17:40] *** tomheady1 joined
[17:42] *** ced-2_ joined
[17:45] <pugs_svn> r25872 | jnthn++ | [t/spec] Test difference between state @foo = @bar and (state @foo) = @bar. Test submitted by nicholas++.

[17:50] *** Patterner left
[17:50] *** Psyche^ is now known as Patterner

[17:52] *** tomheady left
[17:54] *** tomheady joined
[17:54] *** tomheady1 left
[17:55] *** ced-2 left
[18:00] *** FurnaceBoy joined
[18:15] <jnthn> oh hey, we have a test file of 22 tests that we pass all of that wasn't in spectest.data!

[18:15] * jnthn adds S03-junctions/basic.t to spectest.data

[18:16] <dalek> rakudo: 90c8b8e | jnthn++ | src/classes/Junction.pir:

[18:16] <dalek> rakudo: We need to be a little careful when auto-threading ~~ to make sure we can still do $x ~~ Jonction and have it be a type-check. I'm quite hopeful this hack can go away when we are using the Perl 6 multi-dispatch algorithm; either way, this makes it work now and lets us add a test so we don't miss it when we make that switch.

[18:16] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/90c8b8e8dacb45fbe6d9034cb1946cb004898481

[18:16] *** Trollinator joined
[18:16] <moritz_> Last Changed Author: moritz

[18:16] <moritz_> whoo would've guessed...

[18:16] <jnthn> moritz_: On basic.t?

[18:16] <moritz_> jnthn: yes

[18:17] <jnthn> moritz_: I was looking for a test file to add a $j ~~ Junction style test to.

[18:17] <jnthn> basic.t seemed the right one so I opened it up and thought...huh..it has one.

[18:17] <jnthn> Why didn't it fail.

[18:17] <jnthn> Then I realized...we weren't running it. :-)

[18:17] <jnthn> Well, that was an easy win.

[18:17] <moritz_> ;-)

[18:17] <jnthn> Almost +50 passing today

[18:18] *** Trollinator left
[18:21] *** M_o_C left
[18:21] <dalek> rakudo: 17238ba | jnthn++ | t/spectest.data:

[18:21] <dalek> rakudo: Add the fully-pasing S03-junctions/basic.t to spectest.data (covers also $junc ~~ Junction).

[18:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/17238bae08bbb784dac4562356e9b8caba2667d2

[18:22] <pugs_svn> r25873 | moritz++ | [t/spec] don't rely on exact .perl value

[18:23] *** M_o_C joined
[18:27] *** masak joined
[18:32] *** schmalbe joined
[18:33] *** ced-2 joined
[18:34] *** ruoso left
[18:38] *** FurnaceBoy left
[18:46] *** ced-2_ left
[18:50] <pugs_svn> r25874 | jnthn++ | [t/spec] Tests for .eigenstate on non-junctions.

[18:50] *** araujo joined
[18:50] <dalek> rakudo: 1ea27f2 | jnthn++ | src/setting/Object.pm:

[18:50] <dalek> rakudo: Implement eigenstates on Object too.

[18:50] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1ea27f2788e85ae8aa862b5bc9af0350b9f5b52c

[18:50] *** ruoso joined
[18:51] <moritz_> 7227 passing tests. YaY

[18:51] <jnthn> Ooh, nice.

[18:51] <masak> tests++

[18:52] <jnthn> literally.

[18:52] <masak> iteratedly.

[18:53] * jnthn goes to wash up and peel some veg.

[19:01] *** maerzhase1 left
[19:03] *** tomheady left
[19:04] <masak> is there a syntax similar to 'does (Foo, Bar)' ? I'm not finding anything to that effect in S12.

[19:04] <moritz_> there's 'does Foo does Bar'

[19:04] <masak> aye.

[19:04] <masak> and nothing else?

[19:04] <jnthn> masak: What moritz_ said. And no, there's no does (Foo, Bar)

[19:04] <moritz_> masak: what else are you looking for?

[19:04] <jnthn> At least, I've never seen it...

[19:04] <moritz_> there's also 'but' on objects

[19:05] <masak> right.

[19:05] <moritz_> std: class Foo does (Int, Str) { }

[19:05] <p6eval> std 25874: OUTPUT«##### PARSE FAILED #####␤Malformed "class" declaration␤Unable to parse class definition at /tmp/3QwKd7V51D line 1:␤------> [32mclass Foo does [31m(Int, Str) { }[0m␤    expecting module_name␤FAILED 00:02 34m␤»

[19:05] <masak> moritz_: I'm just curious if there is sugar here. I'm perfectly happy if there isn't.

[19:05] <moritz_> there isn't ;-)

[19:05] <masak> then I'm perfectly happy. :)

[19:05] * moritz_ envies masak

[19:07] * jnthn too

[19:07] <masak> ...it passed. dang. :P

[19:07] <masak> oh well.

[19:08] * masak goes off to improve Rakudo's &unpack

[19:10] <jnthn> yay! :-)

[19:10] <jnthn> Rakudo is getting some nice improvements today.

[19:11] *** mberends joined
[19:12] <Tene> jnthn: orly?

[19:16] *** carpftb left
[19:17] *** Kisu left
[19:20] <masak> perl6: say ord('☺')

[19:20] <p6eval> pugs, rakudo 1ea27f: OUTPUT«9786␤»

[19:20] <p6eval> ..elf 25874: OUTPUT«Undefined subroutine &GLOBAL::ord called at (eval 125) line 3.␤ at ./elf_h line 4383␤»

[19:26] <jnthn> Tene: YA RLY

[19:26] <mberends> perl6: say ord('⠝')  # Braille dots 1345, looks like Game of Life 'glider'

[19:26] <p6eval> pugs, rakudo 1ea27f: OUTPUT«10269␤»

[19:26] <p6eval> ..elf 25874: OUTPUT«Undefined subroutine &GLOBAL::ord called at (eval 125) line 3.␤ at ./elf_h line 4383␤»

[19:27] *** ced-2_ joined
[19:28] *** Kisu joined
[19:28] <masak> mberends: it looks nothing like a glider! :)

[19:28] <masak> a glider is not rectangular.

[19:28] <mberends> true, but in the Game of Life it does glide :)

[19:29] <mberends> *does is relevant to #perl6

[19:31] <mberends> the backlogs of yesterday and today are massive. I regret missing out on the installer and CPAN-ng debate.

[19:32] <masak> there'll be more occasions, I'm sure.

[19:33] <mberends> are you any more settled on a PERL6LIB strategy? it looks like an open verdict.

[19:35] <masak> mberends: current strategy: at the end of an installation or uninstallation, check PERL6LIB against the proto projects dir.

[19:35] <masak> if they disagree, offer a better value for PERL6LIB.

[19:36] <masak> the savings will be that the user doesn't have to (1) remember to set PERL6LIB herself, (2) figure out what it should be after installing a handful of modules.

[19:36] <jnthn> std: constant pi = 3.1;

[19:36] <p6eval> std 25874: OUTPUT«##### PARSE FAILED #####␤Malformed "constant" declaration at /tmp/OTAH6sYMqf line 1:␤------> [32mconstant [31mpi = 3.1;[0m␤    expecting any of:␤ scoped declarator␤        typename␤FAILED 00:02 34m␤»

[19:37] <moritz_> std: constant foo = 3;

[19:37] <p6eval> std 25874: OUTPUT«##### PARSE FAILED #####␤Malformed "constant" declaration at /tmp/SoZQvmQ1qX line 1:␤------> [32mconstant [31mfoo = 3;[0m␤    expecting any of:␤  scoped declarator␤        typename␤FAILED 00:02 34m␤»

[19:37] <mberends> std: constant Int foo = 3;

[19:37] <p6eval> std 25874: OUTPUT«##### PARSE FAILED #####␤Malformed "constant" declaration at /tmp/f5Edwe6YCe line 1:␤------> [32mconstant Int [31mfoo = 3;[0m␤    expecting any of:␤      multi_declarator␤ typename␤FAILED 00:02 34m␤»

[19:38] <mberends> not typename then :(

[19:38] <jnthn> rakudo: constant Num 0{B  = atan(2,2) * 4;

[19:38] <p6eval> rakudo 1ea27f: OUTPUT«Malformed declaration at line 1, near "Num 0{B  ="␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[19:38] <moritz_> I think we use enums to declare constants these days :)

[19:38] <jnthn> rakudo: constant Num pi  = atan(2,2) * 4;

[19:38] <p6eval> rakudo 1ea27f: OUTPUT«Malformed declaration at line 1, near "Num pi  = "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[19:39] <jnthn> moritz_: Erm?

[19:39] <jnthn> moritz_: Like pi? ;-)

[19:39] <moritz_> jnthn: like pi

[19:39] <jnthn> ?

[19:39] <jnthn> constant is a recognized declarator

[19:39] * masak likes pi

[19:39] <moritz_> enum Num (pi => 3.14159, e => 2.7... )

[19:39] <jnthn> std: constant $pi = 3.124

[19:39] <p6eval> std 25874: OUTPUT«ok 00:02 35m␤»

[19:39] <moritz_> jnthn: enums don't always go from 0 in integer steps

[19:39] <jnthn> moritz_: I know it just feels...odd

[19:40] <jnthn> Also that'd stop you declaring a role Num...

[19:40] <jnthn> Plus constant is in S04.

[19:40] <moritz_> ok

[19:40] *** ced-2 left
[19:41] *** ruoso left
[19:44] *** DemoFreak joined
[19:53] *** maerzhase joined
[19:58] *** Chillance joined
[20:01] <masak> mberends: oh, and I think the proto installer should warn if neither RAKUDO_DIR or PARROT_DIR is set.

[20:02] *** schmalbe left
[20:05] *** ced-2 joined
[20:05] <jnthn> szabgab: Read your first three Perl 6 mails. Nice! :-)

[20:06] <szabgab> tx

[20:08] <alester> Am I missing a way to get log_filename to pipe to a process (cronolog in this case)?

[20:08] <alester> sorry, ww

[20:10] <skids> So adding junction types should be pretty cheap, right?  Just the handling code for the boolean case?

[20:11] <moritz_> in theory, yes

[20:11] <moritz_> in practice not every junction is implemented as a separate type

[20:11] <skids> I was think "less" "half" and "more" would make good junctions.

[20:14] *** PerlJam left
[20:14] *** PerlJam joined
[20:14] <moritz_> the idea is nice, but so far I haven't felt the need for them

[20:15] <skids> I only mentioned it cause it looked like it wouldn't take much.

[20:15] <moritz_> I fear it takes a little more than it should :/

[20:16] *** Whiteknight left
[20:18] <moritz_> anybody else gets segfaults with rakudo HEAD on parrot r37527 in t/spec/S32-str/substr.t?

[20:19] *** ced-2_ left
[20:21] *** nbrown left
[20:22] *** alester left
[20:22] *** alester joined
[20:26] *** amoc joined
[20:26] * masak drags &unpack, kicking and screaming, over to the setting

[20:27] <masak> my first setting function :)

[20:28] <moritz_> masak++

[20:29] <masak> entirely motivated by laziness, I might add.

[20:29] <masak> I didn't want to implement my additions in PIR.

[20:30] <jnthn> masak: Happy you're doing it in the setting. :-)

[20:30] <moritz_> lazyness++

[20:31] *** nbrown joined
[20:33] <jnthn> oh, argh, I missed ParrotSketch. Again. :-|

[20:33] *** ejs joined
[20:34] <dalek> rakudo: 72f522d | (Carl Masak)++ | src/ (2 files):

[20:34] <dalek> rakudo: translated &unpack from PIR to Setting

[20:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/72f522dcb4b7e3932fb44655d9c2808ce4a80561

[20:37] <masak> moritz_: interesting fact: I cannot implement what I set out to implement today ('H' in unpack) without solving the question you helped me ask earlier (how to get the UTF-8 bytes out of a given character).

[20:38] <masak> perl -e 'print unpack("H6", "☺"), "\n"' # gives e298ba

[20:38] <moritz_> masak: didn't you have an UTF-8 encoding/decoding hack in November somewhere?

[20:39] <masak> moritz_: we had our own ord/chr before they existed in Rakudo.

[20:39] <masak> Parrot has all this infrastructure for encoded strings. shouldn't this be easy?

[20:40] <masak> I looked at the relevant pdd earlier tonight. it contained an ocean of details on how strings and encodings work in Parrot.

[20:40] <masak> no specifics on how to get a sequence of bytes, though.

[20:44] *** M_o_C left
[20:52] <moritz_> aye

[20:53] <moritz_> just glanced over pdd28 too

[20:53] <moritz_> no informations on the PIR interface at all

[20:54] <masak> all this infrastructure, and I'm not authorised to look at my data.

[20:54] <masak> it's the modernist nightmare.

[20:55] <moritz_> src/string/encoding/utf8.c has to to_encoding function

[20:55] <moritz_> s/to/a/

[20:55] <masak> a glimmer of hope!

[20:56] * masak looks

[20:56] <Tene> My girlfriend just sketched out a proposal for a rakudo logo, based on Justin Simoni's proposal to use Gimel: http://pleasedieinafire.net/~tene/logo/gimelanarchy.html

[20:56] * masak is currently getting well-deserved flak from viklund for the shortcomings of Proto

[20:57] <masak> Tene: cool. very anarchistic.

[20:57] <Tene> That's the idea.

[20:57] <moritz_> aye

[20:57] <masak> sort of a cross between a Haskell lambda and the anarchists' symbol.

[20:58] <Tene> The gimel proposal was http://www.nntp.perl.org/group/perl.perl6.users/2009/01/msg938.html

[20:59] <moritz_> masak: look at t/op/string_cs.t...

[20:59] <Tene> She asked me to emphasize that it's a very rough sketch. :)

[21:00] <moritz_> masak: it uses a file handle ($P0, line 499), and then sets $P0.'encoding'("utf8")

[21:00] <masak> Tene: tell her '+1' from me.

[21:00] * jnthn back from the shops - ran out of candy

[21:00] <moritz_> masak: and then prints to that handle

[21:00] <Tene> candy++

[21:01] <moritz_> masak: so if you can do that for an arbitrary IO object, and get the bytes from that... you're done

[21:01] <masak> \o/

[21:01] <masak> moritz_: very cool. will you help me do that? viklund is still grinding me about Proto design...

[21:02] <moritz_> masak: I'm doing my best

[21:02] <masak> "We do what we must because we can."

[21:03] * jnthn tries to work out wtf is wrong with his attempt to do //= correctly...

[21:04] <Tene> jnthn: feel free to nopaste

[21:05] <jnthn> oh typo

[21:08] <moritz_> looking at http://rakudo.org/2008/12/rakudo-now-supports-inline-pir.html - how do I access Perl 6 variables from PIR?

[21:09] <moritz_> or parameters, at least?

[21:09] <jnthn> $P0 = find_lex '$thingumy'

[21:09] <jnthn> Where $P0 is the Parrot register that you want to put the variable in.

[21:10] <moritz_> thanks

[21:10] <jnthn> Remember to do assignments to variables call

[21:10] *** Woody2143 joined
[21:10] <jnthn> 'infix:='(target, source)

[21:10] <moritz_> ok

[21:10] <jnthn> *not* target = source in PIR

[21:10] <skids> jnthn: that would mean no need to "box" right?

[21:11] <jnthn> skids: It'd probably mean binding rather than assignment.

[21:11] <jnthn> But it depends. ;-)

[21:11] <jnthn> (On the types of target and source)

[21:12] <skids> moritz_: figure it all out for us and use every construct even if you don't need to.  Once there's an example in setting we can all just copy off you :-)

[21:13] <moritz_> skids: ;-)

[21:13] <masak> skids: that's what I was thinking also. :)

[21:14] <moritz_> I'll try to do uc in Perl 6 + embedded PIR

[21:14] <moritz_> then on to masak's problem

[21:14] <masak> great.

[21:14] * masak needs to go home and sleep soonish

[21:14] <masak> but will backlog.

[21:15] <masak> moritz_++

[21:15] *** mikehh left
[21:15] <jnthn> masak: Doing ||= for you. :-)

[21:15] <masak> jnthn: wohoo!

[21:15] <jnthn> (Well, you filed rakudobug... ;-))

[21:16] <masak> aye.

[21:16] <masak> I remember it as if it was yesterday.

[21:16] <jnthn> I'm re-doing //= along the way, and putting in &&= too.

[21:16] <jnthn> (Getting the short-circuit semantics right...)

[21:16] <masak> sounds great.

[21:17] <skids> drive time &

[21:17] *** dduncan joined
[21:18] <jnthn> Should win us some more tests.

[21:18] <jnthn> From the almighty assign.t

[21:18] <moritz_> lol

[21:18] *** mikehh joined
[21:19] *** skids left
[21:19] <jnthn> That file is _huge_.

[21:19] <moritz_> aye

[21:19] <moritz_> and not very accessible

[21:20] <masak> 996 lines. eep.

[21:20] <moritz_> most Perl 5 test files contain at least 200 tests

[21:21] <moritz_> I've got a patch for Str.uc in setting

[21:21] <moritz_> spectesting now

[21:21] <Tene> I'll post to the list after she does another few revisions.

[21:22] <moritz_> http://nopaste.snit.ch/15903 review welcome

[21:23] <jnthn> moritz_: I don't mind it being large.

[21:23] <masak> moritz_: looks good to me.

[21:24] <moritz_> jnthn: what do you mean by that? could it be done much shorter?

[21:24] <masak> moritz_: no, he was talking about assign.t

[21:24] <moritz_> ah

[21:25] <masak> moritz_: why the '$P0 = $S0' step?

[21:25] <moritz_> masak: because it doesn't work otherwise

[21:25] <masak> moritz_: good reason.

[21:25] <moritz_> masak: it's cargo-culted from any-str.pir

[21:26] <masak> ah.

[21:26] <masak> I guess it boxes the string in a PMC or sump'n.

[21:27] <moritz_> it'll probably be parrot string vs. Perl 6 Str

[21:27] <moritz_> and the latter is a PMC, yes

[21:28] <moritz_> could anybody please spectest that? I get some segfaults here, but I don't think they are new

[21:29] <jnthn> moritz_: Yes, was talking about assign.t :-)

[21:29] *** donaldh joined
[21:31] *** masak left
[21:31] *** masak joined
[21:32] *** ejs left
[21:35] *** masak left
[21:38] <dalek> rakudo: 39b1290 | (Moritz Lenz)++ | src/ (2 files):

[21:38] <dalek> rakudo: implement uc builtin in setting, with inline PIR. Reviews welcome!

[21:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/39b12900d6bcbbf36626dc7c1088bad30e09b796

[21:40] <pugs_svn> r25875 | putter++ | [elfparse] Support for internal parsing.  ./elfdev -v -r1 -e 'say 3' runs (with a misparse).

[21:40] <pugs_svn> r25875 | putter++ | [elf_h] CommandLine.pm: -r1 added (for using $*compiler1 on the active runtime).

[21:40] <pugs_svn> r25875 | putter++ | [STD_red] Explicitly #! ruby1.9 (an old forgotten edit).  Treat STD as a type.  

[21:40] <jnthn> moritz_: You may get away with

[21:40] <jnthn> %r = new 'Str'

[21:40] <jnthn> %r = $S0

[21:41] <jnthn> (That is, think you maybe can write %r more than once to refer tot he result register)

[21:41] <moritz_> I'll try it, thanks

[21:42] *** dduncan left
[21:44] *** Whiteknight joined
[21:54] *** sahadev left
[22:05] *** ced-2_ joined
[22:06] *** donaldh left
[22:10] *** alester left
[22:13] <pugs_svn> r25876 | jnthn++ | [t/spec] Unfudge various tests relating to //=, ||= and &&= for Rakudo.

[22:14] <dalek> rakudo: b117c67 | jnthn++ | src/ (3 files):

[22:14] <dalek> rakudo: Implement ||= and &&=, and re-work //= to short-circuit.

[22:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b117c67290798be851d56e2b13e0b9dfed939895

[22:14] <dalek> rakudo: 75cd4a8 | jnthn++ | src/ (2 files):

[22:14] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[22:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/75cd4a886b61189930aa01315ac012b7ebf2c82e

[22:14] <jnthn> And that's another 15 tests unfudged. Woo.

[22:15] <jnthn> Today might even make a couple of pixel mark on the graph. ;-)

[22:17] <Tene> jnthn++

[22:18] *** ced-2 left
[22:20] <[particle]1> $($<block>) becomes what, now?

[22:20] <[particle]1> $<block>.<?>

[22:20] <moritz_> in Perl 6 it's $<block>.rob

[22:21] <[particle]1> ugh. thanks.

[22:21] <moritz_> rob = result object

[22:21] <Tene> [particle]1: why?

[22:21] <jnthn> http://use.perl.org/~JonathanWorthington/journal/38658 # report

[22:21] <[particle]1> i'm preparing a presentation on parrot 1.0 for tonight

[22:21] <[particle]1> however, i don't think i'll get into $(...), it's too messy

[22:22] <jnthn> [particle]1: Where you giving it?

[22:22] <Tene> [particle]1: I'm presenting on it tomorrow... curious to see your slides.

[22:22] <[particle]1> seattle.pm

[22:22] <jnthn> Ah, cool.

[22:22] <jnthn> OK, that's all for Rakudo day - I can't concentrate enough to do much more.

[22:22] *** maerzhase left
[22:22] <moritz_> that was quite some cool stuff, jnthn++

[22:23] <jnthn> It's nice to spend some time hacking on features. :-)

[22:24] <Tene> jnthn: you see my gf's rakudo logo proposal?

[22:25] <jnthn> Tene: Yeah - looks interesting :-)

[22:25] <jnthn> Tene: Fairly simple, which is a good thing.

[22:26] *** maerzhase joined
[22:26] <moritz_> is there anything like ulimit for windows?

[22:27] <jnthn> Not that I can think of...

[22:29] *** skids joined
[22:33] *** hercynium left
[22:37] * moritz_ tries to add an execution time limit to autounfudge.pl

[22:37] <moritz_> does anybody use that on windows?

[22:38] <Tene> moritz_: can you use BSD::Resource on win32?

[22:39] <[particle]1> IPC::Run++

[22:39] <moritz_> Tene: not according to http://bbbike.radzeit.de/~slaven/cpantestersmatrix.cgi?dist=BSD-Resource+1.2902

[22:39] <Tene> Ah. :(

[22:39] <[particle]1> use IPC::Run. timers and timeouts work great on windows

[22:40] <Tene> [particle]1: can I get a copy of your slides when you're done?  I could use some inspiration for the Parrot part of my PCT talk.

[22:40] <[particle]1> tene: sure!  i hope i finish them tonight :/

[22:41] <moritz_> [particle]1: I'll take a look.. but probably not today :/

[22:44] <dalek> rakudo: 521a5f1 | (Moritz Lenz)++ | src/setting/Any-str.pm:

[22:44] <dalek> rakudo: some simplifications to inlined PIR suggested by jntn++

[22:44] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/521a5f12cf187431e343064e593b1acb74d8a711

[22:44] *** Exodist left
[22:45] <moritz_> autounfudge doesn't find much these days, jnthn++ is very thorough in unfudging his tests ;-)

[22:45] * [particle]1 heads home &

[22:58] <jnthn> moritz_: I got royally fed of up re-fixing thigns that once worked. ;-)

[22:58] <moritz_> jnthn: ;-)

[22:58] <moritz_> jnthn: do you use autounfudge? or do you do it by hand?

[22:59] *** maerzhase left
[22:59] <jnthn> moritz_: I'm tending to go looking for tests.

[22:59] <jnthn> And then reviewing them and doing it by hand.

[23:00] <jnthn> Quite often I discover the tests are about in the sutie where I would first look, if they exist. Which is a good thing. :-)

[23:01] <moritz_> that's good news ;-)

[23:02] <TimToady> I've added in "constant pi = 3;" and "constant Num pi = 3.1;" to STD, checking it out now

[23:02] <jnthn> TimToady: OK. They are certainly staying? :-)

[23:03] <jnthn> TimToady: I guess good compilers are expected to inline them?

[23:03] <jnthn> But in reality an implementation that makes them read-only is sufficient.

[23:04] *** frooh left
[23:05] <TimToady> yes, the compile is free to poke the actual constant value in directly, as with $?LINE and such

[23:05] <TimToady> *compiler

[23:05] <jnthn> OK. :-)

[23:05] <moritz_> are things like 'constant pi = $variable' allowed?

[23:05] <TimToady> yes, if $variable is known at compile time

[23:06] <TimToady> inits on declarators happen at the time defined by the declarator (see state)

[23:06] <TimToady> or has, for that matter

[23:07] * jnthn saw state today ;-)

[23:10] *** nihiliad left
[23:16] *** krunen left
[23:17] *** krunen joined
[23:23] *** xuser joined
[23:24] <pugs_svn> r25877 | lwall++ | [STD] add support for non-sigiled constant declarations

[23:24] <pugs_svn> r25877 | lwall++ | [viv] more progress on correct --p6 output

[23:24] <pugs_svn> r25877 | lwall++ | [Cursor] fix mysterious regression on heredoc parsing

[23:27] <TimToady> @tell ruoso r25877 is likely to have broken mildew in statement:if and in nibbler, and maybe elsewhere

[23:27] <lambdabot> Consider it noted.

[23:27] <TimToady> @tell pmurias r25877 is likely to have broken mildew in statement:if and in nibbler, and maybe elsewhere

[23:27] <lambdabot> Consider it noted.

[23:38] <pugs_svn> r25878 | moritz++ | [t/spec] more fudging for pugs specifics

[23:39] *** d4l3k_ joined
[23:39] *** dalek left
[23:40] *** d4l3k_ is now known as dalek

[23:44] *** PZt joined
[23:52] <TimToady> std: constant pi = 3;

[23:52] <p6eval> std 25878: OUTPUT«ok 00:02 34m␤»

[23:53] <TimToady> std: constant Num e = 2.7182818;

[23:53] <p6eval> std 25878: OUTPUT«ok 00:02 34m␤»

[23:53] <TimToady> std: my Num e = 2.7182818;

[23:53] <p6eval> std 25878: OUTPUT«##### PARSE FAILED #####␤Malformed "my" declaration at /tmp/zcdds2iFX6 line 1:␤------> [32mmy Num [31me = 2.7182818;[0m␤    expecting any of:␤    declarator␤       multi_declarator␤ typename␤FAILED 00:02 34m␤»

[23:54] <jnthn> TimToady: Nice. :-)

[23:59] <TimToady> std: constant π = atan2(1,1)*4;

[23:59] <p6eval> std 25878: OUTPUT«ok 00:02 35m␤»

