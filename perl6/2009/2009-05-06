[00:04] <pugs_svn> r26687 | lwall++ | [STD] more work on lexically scoped language braids

[00:04] <pugs_svn> r26687 | lwall++ |      allow :temp and scope declarators in regex language

[00:04] <pugs_svn> r26687 | lwall++ | [gimme5] translate temp to maintain P6 semantics wrt old value

[00:08] *** PhatEddy joined
[00:10] <PhatEddy> just to note that the role/enum conflict I tested earlier might be a variant of RT #65022

[00:10] <PhatEddy> rakudo: package A { class Baz{ } }; package P { class Baz{ } }

[00:11] <p6eval> rakudo 53f705: OUTPUT«Re-declaration of type Baz at line 1, near "}"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[00:13] <jnthn> Oh, they probably all boil down to the same underlying issue.

[00:14] <PhatEddy> since I am doing package tests I will probably associate the last example with the RT and add a comment on the variations

[00:15] <jnthn> Sounds fine. :-)

[00:38] *** payload left
[00:38] <pmichaud> back.

[00:39] <pmichaud> but only for a bit.  dinner.

[00:42] *** eternaleye joined
[00:42] * jnthn thinks he has a working first cut of WALK.

[00:44] *** bacek__ joined
[01:01] <PhatEddy> rakudo: package A{our $fifty = 42; my $thirty = 30}; say $A::fifty ; say $A::thirty

[01:02] <p6eval> rakudo 53f705: OUTPUT«42␤Use of uninitialized value␤␤»

[01:02] <s1n> PhatEddy: looks like a bug

[01:02] <PhatEddy> Am I right in thinking that $A::thirty should have complained harder?  Am I over-testing packages?

[01:02] <jnthn> How so?

[01:03] <jnthn> It maybe should have complained harder, not sure.

[01:03] <jnthn> It certainly should not have printed 30, which it didn't. :-)

[01:03] <s1n> does 'my' always imply private?

[01:03] <jnthn> It implies lexical.

[01:03] <jnthn> $A::thirty is a package lookup.

[01:04] <s1n> what scope is 'our'?

[01:05] <jnthn> package

[01:05] <jnthn> well, lexical alias to a package variable...

[01:12] *** Kyosuke_Kiryu left
[01:14] *** Kyosuke_Kiryu joined
[01:15] <TimToady> note however that STD currently assumes that "my $A::b" is short for "my package A { our $b }", more or less

[01:18] <TimToady> without the declarator, $A::b scans outward for an A package

[01:18] <TimToady> decommuting &

[01:18] <PhatEddy> rakudo: package A { constant $pi = 3.14 }; say $A::pi

[01:18] <p6eval> rakudo 53f705: OUTPUT«Use of uninitialized value␤␤»

[01:21] * PhatEddy realizes not sure what that was supposed to do

[01:23] <dalek> rakudo: c0480a5 | jnthn++ | src/classes/Object.pir:

[01:23] <dalek> rakudo: list is just a method, and should not get a namespace entry. We need to do this more widely, but this scratches an immediate itch.

[01:23] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c0480a55873ca5ee638db924393eddadc9c0168c

[01:23] <dalek> rakudo: 902f999 | jnthn++ | src/parrot/ClassHOW.pir:

[01:23] <dalek> rakudo: Need to lie about top of the Perl 6 object hierarchy.

[01:23] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/902f9991dfcdc5ab16c987dd25d2bf9d1dab7a70

[01:27] *** wknight8111 left
[01:34] <dalek> rakudo: b7b3c60 | jnthn++ | src/classes/Routine.pir:

[01:34] <dalek> rakudo: .name method for Routines.

[01:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b7b3c60b8877a580a45c06b061787a5497f61f0b

[01:34] <dalek> rakudo: 71c69d0 | jnthn++ | src/setting/Object.pm:

[01:34] <dalek> rakudo: First cut of WALK; doesn't know all of the various orderings, but knows how to handle canonical and super.

[01:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/71c69d02e860e7f28a8f4065c530dfaf6bba9536

[01:36] <jnthn> erm, 3:30am. Sleep time.

[01:36] * jnthn ide spat. Dobru noc. :-)

[01:57] *** cognominal left
[02:23] *** PhatEddy left
[02:42] *** mikehh_ joined
[03:20] *** charsbar_ joined
[03:37] *** lucs left
[03:40] *** orafu joined
[04:04] *** SamB left
[04:06] *** hercynium left
[04:07] *** fridim_ joined
[04:15] *** alester_ joined
[04:23] *** fridim_ left
[04:29] *** skids left
[04:29] *** Kisu left
[04:41] *** Kisu joined
[05:03] *** renormalist joined
[05:08] *** renormalist left
[05:15] *** iblechbot joined
[05:28] *** justatheory left
[05:31] *** alester_ left
[05:38] *** jhuni joined
[05:42] *** jhuni left
[05:54] *** spx2 joined
[06:15] *** wollmers joined
[06:19] *** iblechbot left
[06:27] <moritz_> good morning

[06:27] *** nihiliad left
[06:34] *** ejs joined
[06:46] <patmat> good morning moritz_!

[07:04] <moritz_> there's a game called "world of padman", and I always mis-read "patman" as "padman" on first sight ;-)

[07:10] *** DemoFreak joined
[07:10] *** eMaX left
[07:10] <Matt-W> Morning

[07:15] <moritz_> rakudo: sub foo(){}; say &foo.name

[07:15] <p6eval> rakudo 71c69d: OUTPUT«foo␤»

[07:15] <moritz_> rakudo: module A { sub foo(){}}; say &A::foo.name

[07:15] <p6eval> rakudo 71c69d: OUTPUT«foo␤»

[07:16] <pugs_svn> r26688 | wollmers++ | [t/spec] add verbosity for diagnosis

[07:17] <pugs_svn> r26689 | azawawi++ | [S:H:P6] version 0.52 released which includes latest STD 

[07:17] <pugs_svn> r26689 | azawawi++ | [S:H:P6] updated Moose dependency to 0.77

[07:17] <pugs_svn> r26689 | azawawi++ | [S:H:P6] removed dependency on Readonly

[07:17] *** Kyosuke_Kiryu left
[07:47] *** meppl joined
[07:57] <pugs_svn> r26690 | wollmers++ | [t/spec] typo

[07:58] *** ejs left
[07:59] *** AzureStone joined
[08:08] <moritz_> rakudo: say 'a' ~~ /[ a | <fail: "no a"> ]/

[08:08] <p6eval> rakudo 71c69d: OUTPUT«a␤»

[08:08] <moritz_> rakudo: say 'b' ~~ /[ a | <fail: "no a"> ]/

[08:08] <p6eval> rakudo 71c69d: OUTPUT«too many arguments passed (6) - 1 params expected␤current instr.: 'parrot;PGE;Match;fail' pc 2275 (compilers/pge/PGE/Regex.pir:83)␤»

[08:08] <moritz_> so how do I fail from a regex?

[08:08] <moritz_> rakudo: say 'b' ~~ /[ a | <panic: "no a"> ]/

[08:08] <p6eval> rakudo 71c69d: OUTPUT«Unable to find regex 'panic'␤Null PMC access in invoke()␤current instr.: 'parrot;PGE;Grammar;' pc 308 (EVAL_16:138)␤»

[08:10] *** riffraff joined
[08:23] *** payload joined
[08:26] <pugs_svn> r26691 | wollmers++ | [t/spec] simplified and unfudged

[08:28] *** minazo left
[08:30] *** donaldh joined
[08:33] <pugs_svn> r26692 | wollmers++ | [t/spec] minor cleanup

[08:34] <moritz_> wollmers: are you sure that is() autothreads?

[08:35] <moritz_> ok $?OS eq $osnames, ...; would be safer

[08:39] *** masak joined
[08:40] <pugs_svn> r26693 | wollmers++ | [t/spec] eq is safer, moritz++

[08:40] <masak> greetings, pickcamels.

[08:41] <moritz_> h h

[08:41] <moritz_> are we known to be that picky? :-)

[08:41] <Matt-W> pickcamels?

[08:42] <masak> oh, don't overanalyze. just accept it. :P

[08:45] *** nemstep` joined
[08:58] *** nemstep left
[08:59] *** bacek__ left
[09:04] <moritz_> masak: if we don't overanalyze, we have nothing to say :-)

[09:05] <masak> moritz_: uh, correct. everybody please resume your overanalysis.

[09:06] <pugs_svn> r26694 | masak++ | [S32/Containers] fixed minor typo

[09:10] *** nemstep` left
[09:11] *** nemstep` joined
[09:12] *** smtms joined
[09:21] <pugs_svn> r26695 | wollmers++ | [t/spec] fudge tests for rakudo

[09:27] *** ZuLuuuuuu joined
[09:29] <pugs_svn> r26696 | wollmers++ | [t/spec] fudge tests for rakudo

[09:32] <moritz_> wollmers: there's no use in fudging tests for rakudo if rakudo doesn't implement the feature being tested

[09:33] <moritz_> lunch &

[09:33] *** donaldh_ joined
[09:35] *** donaldh_ left
[09:47] *** cognominal joined
[10:39] *** aindilis joined
[10:49] <jnthn>  H H

[10:51] <Matt-W> OH HAI

[10:52] *** payload left
[10:52] *** masak left
[11:08] * jnthn needs to do some stuff for $OTHER_WORK...will get onto Perl 6 things a bit later today. :-)

[11:09] *** mikehh_ is now known as mikehh

[11:20] *** donaldh left
[11:20] *** donaldh joined
[11:23] <pugs_svn> r26697 | wollmers++ | [t/spec] added TODO: clarify

[11:32] *** pancake joined
[11:35] <pancake> are private classes declared as the apocalypsis says? 'class :Name' ? does this changed or its just a missfeature of rakudo?

[11:35] *** Jedai joined
[11:36] <moritz_> don't read the apocalypsis, they are historical documents only

[11:36] <moritz_> the synopsis are the specification

[11:36] <moritz_> I'd guess it's 'my class Name { .. }' these days

[11:36] <moritz_> std: my class A { }

[11:36] <pancake> yep, i know, but im so clicks far from the synopsis and prefered to ask :)

[11:36] <p6eval> std 26697: OUTPUT«ok 00:02 35m␤»

[11:37] <pancake> ok :)

[11:37] <pancake> my looks better

[11:38] <pancake> but didnt seems to work

[11:39] <pancake> http://pastebin.com/m5571ef12

[11:39] <buubot> pancake: The paste m5571ef12 has been copied to http://erxz.com/pb/17440

[11:39] <moritz_> then it's NYI

[11:40] <moritz_> (NYI is "not yet implemented")

[11:41] <pancake> yep, easily deductible acronim :)

[11:43] *** payload joined
[11:48] *** xinming_ joined
[12:04] *** pancake left
[12:06] <pugs_svn> r26698 | wollmers++ | [t/spec] added TODO: 

[12:07] *** wolv is now known as wolverian

[12:13] *** azawawi joined
[12:14] <pugs_svn> r26699 | wollmers++ | [t/spec] added TODO: 

[12:36] *** ruoso joined
[12:37] <jnthn> std: class Foo:ver<0.0.1> { {

[12:37] <jnthn> std: class Foo:ver<0.0.1> { }

[12:37] <ruoso> Hello!

[12:37] <p6eval> std 26699: OUTPUT«##### PARSE FAILED #####␤Unable to parse blockoid; couldn't find final '}' at /tmp/SCWYpneOmP line 0:␤------> [32m[31m[0m␤    expecting statement list␤FAILED 00:02 37m␤»

[12:37] <p6eval> std 26699: OUTPUT«ok 00:02 35m␤»

[12:37] <jnthn> hi ruoso 

[12:38] <ruoso> jnthn, do you have any plans on implementing contextual variables in rakudo?

[12:39] <jnthn> It's on the "things that should probably happen soonish" list.

[12:39] <azawawi> hi

[12:40] <jnthn> I think pmichaud wants to get the support for them into PCT too, or will also need them in PGE, so I haven't rushed to get them into Rakudo just yet.

[12:41] <azawawi> ruoso: hi, did u manage to find out why make mildew was croaking on kubuntu...?

[12:42] <ruoso> azawawi, no... I haven't found...

[12:43] <azawawi> ruoso: oh well, im nearly finished with the run mildew/rakudo option on Padre::Plugin::Perl6...

[12:44] <ruoso> azawawi, great... don't be worried about the problem in mildew tho, because we're getting the refactored smop/mildew on shape pretty soon, and that shall fix the problems you're having

[12:45] <azawawi> jnthn: what is the status of PGE syntax highlighting that i previously disabled (or hijacked :)) in Padre Perl6?

[12:46] <jnthn> azawawi: No idea - I think Gabor added it at the Hackathon?

[12:47] <jnthn> But not sure it's had any changes (or needed them) on the PGE side since then.

[12:48] <azawawi> jnthn: today im going to finish the STD/PGE syntax highlighting switch...

[12:48] <jnthn> OK, nice.

[12:49] <azawawi> hmmm, rakudo parrot build failed on win32 xp... was working yesterday.

[12:50] <jnthn> That's odd - works here for me today. :-S

[12:50] <jnthn> details?

[12:50] <jnthn> oh, and make sure you have the correct Parrot revision..it was bumped up yesterday.

[12:51] <moritz_> azawawi: did you remember to 'make parrot'?

[12:51] * azawawi make realclean; &

[12:53] <jnthn> ruoso: S12 specs a method ^isa() (as opposed to ^isa($possible_parent)) to get the parents of the current class.

[12:53] <jnthn> I'm thinking by default that would want to return just the immediate parents?

[12:53] <jnthn> Perhaps with a flag that makes it get the whole MRO?

[12:53] <jnthn> Your ClassHOW for s1p is missing this, btw.

[12:53] <ruoso> jnthn, a flag doing the opposite

[12:54] <jnthn> You think the mro should be the default?

[12:54] <ruoso> for .^methods and .^attributes TimToady agreed to have a :local named argument to fetch declarion local to that type

[12:54] <azawawi> jnthn: i ran perl Configure.pl --gen-parrot; mingw32-make failed; but im going to try it again after mingw32-make realclean

[12:54] <jnthn> Oh, so the default is "everything"?

[12:54] <ruoso> jnthn, yes... because, usually, you don't care how it is defined, you only want to know if it is

[12:54] <jnthn> And you pass :local for "just this class"?

[12:54] <jnthn> OK.

[12:55] <ruoso> yes

[12:55] <jnthn> kthnx, will implement.

[12:55] <moritz_> and spec, please

[12:55] <jnthn> aye, S12 wants an update.

[12:55] <ruoso> about ^isa

[12:55] <ruoso> I think we have an API inconsistency there...

[12:55] <jnthn> yes

[12:56] <ruoso> because ^does receives an argument

[12:56] <jnthn> $foo.^isa(Int) # is $foo an Int

[12:56] <jnthn> $foo.^isa() # get me the list of parents of Foo

[12:56] <jnthn> Oh, you mean

[12:56] <jnthn>     roles         list of roles

[12:56] <ruoso> I thought about it too... but it looks weird for it to return different types....

[12:57] <jnthn> Probably wants to de

[12:57] <jnthn>     does

[12:57] <jnthn> *be

[12:57] <jnthn> ?

[12:57] <ruoso> jnthn, yeah... maybe ^roles and ^super

[12:57] <jnthn> If they're different multi variants we're fine.

[12:57] <ruoso> jnthn, but it looks weird

[12:57] <ruoso> maybe the parameter is a filter

[12:58] <jnthn> Well, not ^super because that implies "only the direct superclasses"

[12:58] <jnthn> You could do it as an optional parameter.

[12:58] <ruoso> ^isa(Int) return all the types in the hierarchy that matches Int

[12:58] <jnthn> I think that we should probably have isa and does being the arguemnt and non-argument form.

[12:58] <jnthn> *or* have a separate ^parents and ^roles

[12:59] <jnthn> e.g. name them both matching or both different.

[12:59] <jnthn> But not one matching and one not.

[12:59] <ruoso> jnthn, true....

[12:59] <ruoso> what about the filter idea?

[12:59] <jnthn> Don't like it.

[12:59] <azawawi> jnthn: mingw32-make failure log: http://sial.org/pbot/36440

[12:59] <jnthn> I want ^isa(Foo) to tell me Fast.

[12:59] <ruoso> right

[13:00] <ruoso> I'd be pretty much ok with ^roles and ^parentes

[13:00] <ruoso> s/tes/ts/

[13:00] <jnthn> Yeah

[13:00] <ruoso> do we need TimToady's blessinh?

[13:00] <jnthn> And part of me thinks requiring multi-dispatch and optional parameter stuff for something so fundemental and up in Object is probably not great.

[13:01] <ruoso> or we just tell him we implemented that way :P

[13:01] <jnthn> For sure, Rakudo doesn't have a bootstrap issue there, but I can appreciate for smop that may not be the case.

[13:01] <ruoso> jnthn, and using multis to change the actual meaning of a method is weird... you usually want to customize behavior, not be an entirely different method

[13:01] <jnthn> Yeah, that too.

[13:02] <jnthn> OK, let's go for ^roles and ^parents and stop overloading meanings onto one method name.

[13:02] <ruoso> good

[13:02] <jnthn> We could always apply the forgiveness vs permission rule. ;-)

[13:02] <moritz_> that's the general trend anyway

[13:02] <moritz_> see the reverse -> .flip split

[13:02] <moritz_> reverse -> reverse|flip|invert actually :-)

[13:02] <jnthn> I'll patch S12 and the sepc tests and Rakudo.

[13:03] *** abra joined
[13:03] <ruoso> cool

[13:03] <jnthn> and you can patch src-s1p. ;-)

[13:03] <moritz_> hattrick!

[13:03] *** riffraff left
[13:04] <ruoso> jnthn, should roles and parents be available in Object as well? or just as meta methods? I'd argue to be just metamethods... 

[13:05] <jnthn> I think just as meta-methods.

[13:05] <Matt-W> seems like meta-method thing to me

[13:05] <jnthn> .^methods is for sure only in the meta-class.

[13:05] <jnthn> ruoso: Oh, I wanted to pick your brains on one other thing too.

[13:05] <jnthn> in smop as far as I understand it you have the metaclass as a "singleton"

[13:05] <wolverian> can I specify that a role Foo can be composed only into classes that also compose Bar

[13:05] <wolverian> s,$,?,

[13:06] <ruoso> jnthn, not really singleton, but shared amongst a lot of types

[13:06] <jnthn> OK, but is there a single "instance" of ClassHOW essentially?

[13:06] <ruoso> in practical terms, yes

[13:06] <jnthn> I appreciate instance is maybe not quite the word in the prototye-OO world.

[13:07] <jnthn> OK, so that's the direction I'm thinking we'll head in Rakudo too.

[13:07] <jnthn> With that in mind though, I'm not too clear on:

[13:07] <ruoso> jnthn, yes... ClassHOW is not really an instance

[13:07] <jnthn> (from S12)

[13:07] <jnthn> Alternately, you can associate a class method with the current metaclass instance,

[13:07] <jnthn> which as a singleton object knows your package, and can function as a more traditional

[13:07] <jnthn> "class" method:

[13:07] <jnthn> our $count; method ^count { return $count }

[13:07] <ruoso> but conceptually, you could have something that was really an instance

[13:08] <ruoso> jnthn, I think that part of S12 is just broken ;)

[13:08] <jnthn> OK, we should probably ask TimToady about it.

[13:09] <jnthn> I can't see how we can have the metaclass both as a "pure prototype" (is that how you call it in smop?) or as we'll have it in Rakudo more of a singleton, and yet still have it know about individual classes...

[13:09] <jnthn> Oh, unless the representation API knows the package...

[13:09] <ruoso> jnthn, it does

[13:09] <ruoso> .^!who

[13:09] <jnthn> (as in, provides a way to get at it)

[13:09] <jnthn> ah, OK

[13:10] <ruoso> in SMOP, the "class" information is in the protoobject^Wtype object

[13:10] <ruoso> the HOW knows how to use it

[13:10] <ruoso> that's why you have the same ClassHOW being used by most classes

[13:10] <ruoso> a more class-based OO would have the methods stored in the HOW itself

[13:10] <jnthn> Rakudo is heading in a pretty similar direction.

[13:11] <ruoso> jnthn, that's very much cool

[13:11] <jnthn> Sure, but I don't see how you can really do that and do the represenation stuff too.

[13:11] <ruoso> think of the representation stuff just as a way to get the actual data stored into the object

[13:12] <jnthn> Right.

[13:12] <ruoso> in SMOP it is a method call, but there's no reason for you to do that in Parrot

[13:12] <ruoso> since parrot has a much more defined low-level structure

[13:12] <ruoso> in SMOP it is a method call, simply because that's the only thing SMOP knows how to do

[13:12] <ruoso> (call methods)

[13:12] <jnthn> It turns out that a subset of the Parrot vtable methods actually match up pretty closely with your representation API. :-)

[13:13] <jnthn> Not enough that we can really easily unify it.

[13:13] <ruoso> exactly... so you can map the code using .^! directly to vtable calls

[13:13] <ruoso> jnthn, I'm open to work through getting it unified

[13:13] <jnthn> Well, it's not always going to be a direct mapping.

[13:14] <jnthn> One awkward point for us is your repr API's assumption that instance storage is a HoH.

[13:14] <ruoso> right... that's very Perl6-ish

[13:14] <ruoso> which is not very parrot-ish

[13:15] <ruoso> how would parrot need for it to look like?

[13:15] <jnthn> Well, thing is, as I understand it the repr API is meant to allow us to easily interoperate with other object models.

[13:15] <jnthn> And it seems like too big an assumption in general.

[13:16] <jnthn> Well, Parrot knows how to get an attribute, set an attribute, and those two can optionally take the class the attribute belongs to, otherwise it will just grab the nearest attribute up the mro.

[13:16] <ruoso> yes... my idea is that we can interchange HOW and REPR as pleased

[13:16] <ruoso> so you could use a different representation with ClassHOW, as long as that REPR provided all the API ClassHOW requires

[13:16] <ruoso> i.e.: using a Glib object with ClassHOW

[13:17] <jnthn> Right, but does a GLib object really conveniently provide a HoH view or its attribute store?

[13:17] <jnthn> *of its...

[13:17] <jnthn> HoH is not really an efficient object layout.

[13:18] <ruoso> jnthn, that's why I'm very open on getting the REPR unified... It wasn't still tested with other REPR implementations

[13:18] <jnthn> OK.

[13:18] <ruoso> btw... wasn't the mro supposed to be implemented by the HOW itself?

[13:19] <jnthn> Interesting question.

[13:19] <jnthn> I mean, ^dispatch and ^can are two places that are affected by this.

[13:19] <jnthn> And those are fine...

[13:20] <jnthn> Oh, hmm

[13:20] <jnthn> What does $!foo (getting at instance storage) compile down to in smop?

[13:20] <ruoso> I mean... I should be able to implement a different MRO by using a custom HOW

[13:20] <jnthn> e.g. class Foo { has $!foo; method x { $!foo } } # the $!foo reference in the method

[13:20] <ruoso> self.^!instance_storage.{$?PACKAGE}<foo>

[13:20] <jnthn> Is attribute lookup meant to be via the metaclass too?

[13:21] <jnthn> OK, so that goes straight via the repr API?

[13:21] <ruoso> jnthn, S12 makes it very clear that private attributes are not virtual

[13:21] <ruoso> so... I think it's ok to go through the REPR api directly

[13:22] *** exodist joined
[13:22] <jnthn> Sure, Parrot provides for them being, and we'll have to customize that in p6opaque or something.

[13:22] <jnthn> Or maybe not even there.

[13:22] <jnthn> Just in emitting something that specifies the package always.

[13:22] <jnthn> (We currently are going through what I'd call our repr API today, e.g. the vtable methods, for attribute lookup.)

[13:23] <ruoso> yes... in mildew the above line is pretty much the result for $!foo

[13:23] <jnthn> (But I'm pretty sure we ain't always getting the right answers.)

[13:23] <jnthn> Ok, so we're consistent-ish in smop and Rakudo there already. Great.

[13:23] *** skids joined
[13:25] <jnthn> So, I think the best way forward, is I'll dig into getting Rakudo moving in the right kinda direction, and then once I've got our HOW/repr distinction straightened out some, we can look at how we might be able to unify it some.

[13:26] <jnthn> azawawi: Looking at your nopaste, I suspect it may be due to some recent Parrot changes in the way dynpmcs related to Parrot.

[13:29] *** Jedai left
[13:30] *** sri_kraih joined
[13:31] *** masak joined
[13:36] *** PhatEddy joined
[13:36] *** smtms left
[13:36] <pugs_svn> r26700 | jnthn++ | [spec] Rename ^isa() to get list of parents to ^parents so there's no confusion with .^isa(Foo) and consistency with .^does(Foo) and .^roles(). Also fill out the introspection specification a little more.

[13:37] <pmichaud> jnthn++ ruoso++

[13:37] <pmichaud> That use of .isa() to "get list of parents" really bugged me.

[13:37] <jnthn> Hey, you had a commit bit too. ;-)

[13:38] <pmichaud> I find that my ideas for design improvements are ultimately rejected more often than not.  :-|

[13:38] <pmichaud> at least, it seems that way. :-)

[13:38] <pugs_svn> r26701 | wollmers++ | [t/spec] cosmetic cleaning: remove trailing space

[13:39] <jnthn> btw, what are we going to call the new Parrot PMC for doing the proto-y object stuff?

[13:39] <jnthn> ProtoObject is tempting now Perl 6 ain't using it. ;-)

[13:39] <pmichaud> I'll let you decide that.  Allison suggested Protoobject.

[13:39] <pmichaud> I'm find with Protoobject, but please don't capitalize the 'O'.

[13:39] <jnthn> :-(

[13:40] <pmichaud> *fine

[13:40] <jnthn> I liked it much better with the capital O...

[13:40] <pmichaud> but the word is consistently "protoobject", not "proto object"

[13:40] <jnthn> hmm...true

[13:41] <pmichaud> similarly we say "prototype" and not "proto type".  I.e., we would say  Prototype and not ProtoType

[13:41] <jnthn> *nod*

[13:41] <jnthn> I guess we can also be 1337

[13:41] <jnthn> prot00bject!

[13:41] <jnthn> w00t!

[13:41] <jnthn> OK, Protoobject it is.

[13:42] <pmichaud> When I was actively teaching (and serving as committee member on graduate projects), I often ran into an Over Eagerness to Capitalize Words that seemed Important.

[13:42] <jnthn> And you Really didn't like It? ;-)

[13:43] <pmichaud> I continually saw project proposals (and even some final reports) where the writer thought it was important to always capitalize things like "Web Browser"

[13:43] <pmichaud> as in:

[13:43] <pmichaud> "The user opens the Web Browser and navigates to the start page for the application."

[13:43] <jnthn> Ugh.

[13:43] <moritz_> pmichaud: they were all Germans in their heart :-)

[13:43] * masak agrees with pmichaud 

[13:43] <moritz_> we capitalize nouns, and it's hard to get rid of that habit

[13:43] <jnthn> moritz_: I was thinking about German too. :-)

[13:43] <pmichaud> It must have been German then.

[13:43] <jnthn> "Mein Hund ist kaput."

[13:44] <masak> UnNecessary CaPitaliSation Should Be AvoidEd.

[13:44] <jnthn>        ^ capital 'cus it's noun

[13:44] <jnthn> uh, one too far over :-)

[13:44] <pmichaud> But I did see it a lot.  It also bugged me a bit that the committee chairpersons (who were supposed to have revised the draft before getting to me) didn't notice or think to correct the author on it first.

[13:45] <pmichaud> anyway, "Protoobject."  :-)

[13:45] *** clkao joined
[13:46] <jnthn> rant win :-)

[13:46] <pmichaud> although with  prot00bject I can always aim my laser right between the "eyes".

[13:46] <masak> :)

[13:46] <pmichaud> (The zero in my current font has a dot in the middle, which makes them look like a miniature xeyes application :-)

[13:47] *** ruoso left
[13:47] <pmichaud> Ugh, I really don't want to do $otherjob today.

[13:49] *** hcchien joined
[13:49] <masak> don't do it, then!

[13:51] <pmichaud> Well, if I don't, then I might not have $otherjob tomorrow.  Plus I'm supposed to travel to $otherjob.location tomorrow to demonstrate the current state of the project, which is likely to be Nil() unless I do $otherjob.work today.

[13:52] *** H1N1 is now known as H1N1[A]

[13:52] <jnthn> Ugh. Un-fun.

[13:53] <pugs_svn> r26702 | ruoso++ | [smop/src-s1p] add ^roles and ^parents... the implementation is yet very naive... thats probably where the mro gets in

[13:53] <pmichaud> and yes, this also means I'm likely to be scarce tomorrow (travel, meetings, travel)

[13:53] <pmichaud> I should be back around on Fri.

[13:53] <masak> pmichaud: good luck with $otherjob!

[13:55] <jnthn> I expect I'll do Rakudo Day on Friday.

[13:55] <masak> IO::Encoded.ins: "Returns the number of lines or records that have been input. Now with cleaned-up localization usage." what does the latter sentence mean?

[13:58] <masak> also, why must getc have C<Int $chars = 1> as a param? nearly all other methods are content with being called repeatedly...

[13:58] <masak> $*IN.getc for ^$n;

[13:58] <masak> also, given that it _does_ have this param, isn't the C<Char> return type wrong?

[13:58] <masak> or is the intention to only return the last char read?

[13:59] <moritz_> masak: because IO without proper buffering is painfully slow, perhaps

[13:59] *** nemstep` is now known as nemstep

[13:59] <moritz_> masak: but yes, the return type looks wrong

[13:59] <masak> moritz_: I question both the need for the param and the return type.

[13:59] <moritz_> masak: feel free :-)

[13:59] <masak> in no other language is getc required to read several chars, AFAIK.

[14:00] <masak> let's save experiments in overdesign for the external libraries as far as possible.

[14:00] <donaldh> slightly off-topic question: how is pugs_svn implemented?

[14:00] <moritz_> donaldh: with Bot::BasicBot

[14:00] <moritz_> masak: right. that's what read() is for :-)

[14:00] <masak> moritz_: that, too.

[14:00] <donaldh> moritz_: is it listening to commit emails? or triggers, or what?

[14:01] *** ruoso joined
[14:01] <moritz_> donaldh: it uses SVN::Log to talk to the svn server directly... should I put the code somewhere?

[14:02] <donaldh> moritz_: yes that would be great. I've already started tinkering with ilbot since I find it one of the prettiest IRC log bots I've seen.

[14:03] <donaldh> moritz_: is it polling the svn server then?

[14:03] <ruoso> jnthn, proto-y?

[14:05] *** smtms joined
[14:05] <moritz_> donaldh: http://moritz.faui2k3.org/files/svnbot.pl.txt

[14:05] <moritz_> donaldh: problem is, currently it polls too often

[14:05] <moritz_> it should be ever 20s, but I fear it does it more often, actually

[14:05] <jnthn> ruoso: ?

[14:06] <ruoso> jnthn, sorry... I didn't backlog fully in the last days... what is the proto-y thing you mentioned?

[14:08] <jnthn> ruoso: A PMC that gives us something a bit more prototype-oo based - basically to avoid some of the "faking" our P6object library does today.

[14:08] <jnthn> And help get us more to the representation/meta-class separation point.

[14:08] <ruoso> I see.... 

[14:09] <ruoso> isn't that p6opaque?

[14:09] <donaldh> moritz_: thanks, I'll take a look.

[14:09] <jnthn> yes and no

[14:09] <jnthn> p6opaque will be a subclass of it

[14:09] <ruoso> ah... ok

[14:09] <jnthn> Which adds some Perl 6 specific bits.

[14:10] <ruoso> makes sense...

[14:10] <ruoso> jnthn, wouldn't this get you really close to the ResponderInterface concept as in SMOP?

[14:11] *** amoc joined
[14:12] <jnthn> In my view, Parrot's never been so far away from it anyway.

[14:12] <jnthn> Your ResponderInterface is essentially a list of things you expect a representation to be able to do, so far as I can tell.

[14:13] <jnthn> Which isn't all that different from Parrot's vtable, apart from Parrot's v-tables provide a more extensive range of things, not just object-y ones.

[14:13] <ruoso> jnthn, except that not all ResponderInterfaces need to implement the REPR api

[14:13] <ruoso> but yes... I see what you mean

[14:14] <jnthn> Not all Parrot PMCs implement all of the vtable either.

[14:14] <ruoso> so the Protoobject is basically a PMC that will be able to implement the REPR api

[14:14] <jnthn> Right. It'll basically subclass Object, and let you do things like add_method, etc.

[14:14] <jnthn> Without having to explicitly deal with the fact that there's also a Class behind the scenes.

[14:15] <ruoso> "also a class"?

[14:15] <jnthn> So you'll be able to just deal with one object and not two. And that one object will handle the full repr API.

[14:15] <jnthn> Right. Remember that Parrot is essentially class-based behind the scenes.

[14:16] <jnthn> This will just help us ignore that a bit more. :-)

[14:16] <ruoso> right... got that...

[14:16] <ruoso> so you really could call it ResponderInterface instead ;)

[14:16] <jnthn> (While still allowing everything else that thinks in a class-based way to continue inter-operating just fine with us.)

[14:16] <jnthn> Well, things that go into Parrot should be not specific to Perl 6.

[14:16] <ruoso> ResponderInterface is not

[14:17] <ruoso> it's simply an abstraction that hides how the objects are laid out in low-level

[14:17] <jnthn> I really don't think that name is going to fly. :-)

[14:17] <ruoso> ok... not really important...

[14:17] <ruoso> but it's cool that we're getting the same building blocks at this point

[14:17] <jnthn> Yes.

[14:18] <jnthn> It's nice that smop has come and investigated this area in more detail.

[14:19] <ruoso> it does make me proud of it ;)

[14:19] <ruoso> knowing that no matter what, SMOP was already worth the work ;)

[14:21] <jnthn> Oh, I think it's for sure that SMOP has been helpful in fleshing out various areas of the spec and working out how to do stuff.

[14:21] <ruoso> now I need to get my secret plan going... which is to make perl 5.12 to run Perl 6

[14:21] <ruoso> by merging SMOP inside perl5

[14:23] <masak> \o/

[14:23] <moritz_> well, it's not secret anymore :-)

[14:23] <jnthn> That's certainly a "rather you than me" task. :-)

[14:23] <masak> ruoso: I've said it before: the moment that happens, smop will turn up on my radar like a frikkin' blimp.

[14:24] <ruoso> I think as soon as this refactoring is over, I'll be able to start working on that

[14:24] <moritz_> how much work is left?

[14:24] *** [particle]1 joined
[14:25] <pugs_svn> r26703 | jnthn++ | [t/spec] Update an introspection test to be inline with the spec and correct a few other bits in it, and fudge it for Rakudo.

[14:25] *** frettled joined
[14:25] <ruoso> moritz_, we need to finish porting p6opaque and the low-level HOWs

[14:26] <ruoso> and then get mildew passing all the tests it was passing before

[14:27] <PhatEddy> I have been working on package RT tests and believe I have come up with a file of tests for 14 otherwise (afaict) untested package related RT's (19 tests).

[14:27] *** [particle]1 is now known as [particle]nyc

[14:27] <jnthn> PhatEddy++ # thanks!

[14:27] *** frettled left
[14:27] <PhatEddy> Anyone willing to look at the file before I decide what to do with it next.  I could put up a gist link ...

[14:28] <moritz_> jnthn: are you planning to make :ver<1.0> parse in Rakudo?

[14:28] <moritz_> PhatEddy: sure

[14:28] <TimToady> gah, you guys talk too fast--how am I ever supposed to backlog all that? :)

[14:28] *** frettled joined
[14:29] <PhatEddy> link to package tests: http://gist.github.com/107520

[14:29] <[particle]nyc> my $backlog is lazy;

[14:29] * TimToady is not allowed to be lazy when it comes to Perl 6

[14:29] <[particle]nyc> for @need-to-know.lines { ... }

[14:29] *** iblechbot joined
[14:29] <TimToady> well, except vicariously lazy

[14:30] <moritz_> PhatEddy: the first one... shouldn't that stringify to AlsoEmpty() (with the parens)?

[14:31] <moritz_> PhatEddy: the third one is wrong... it shouldn't live, it just shouldn't give a Null PMC access

[14:32] <moritz_> PhatEddy: same with the next one

[14:33] <moritz_> is eval('Simple::B1::a'), 1, 'enum in package' # - I don't see no B1 anywere - should that be just B?

[14:33] <PhatEddy> first one gives invoke() not implemented error now ...

[14:33] <TimToady> ruoso: we're going to have to figure out the relationship of p5 and p6 namespaces, and I'm afraid it ain't gonna be pretty...

[14:33] <masak> http://gist.github.com/107541 # only in Perl...

[14:33] <ruoso> pmichaud, if I use a PIR closure in the regex, will it be possible to see the Perl 6 lex from that closure?

[14:34] <ruoso> TimToady, the cool thing in P6 is that the namespace is not global

[14:34] <ruoso> so it makes it very easy to solve that

[14:34] <PhatEddy> if you think the first one should be AlsoEmpty() I can test for that ...

[14:34] <moritz_> yes

[14:34] * PhatEddy working on third and fourth

[14:34] <TimToady> it's just that dispatchers that want to interoperate will often need to look in two places

[14:34] <moritz_> #65022 - you can simply use an eval_lives_ok here

[14:35] <ruoso> TimToady, why? if you're in P6, you look in the lexical scope only...

[14:35] <ruoso> if you're in p5, you look in the package only

[14:35] <TimToady> there are things that have to look in both p5 and p6 lexical scopes interleaved, if we can interleave code

[14:35] <moritz_> same with RT #64204

[14:35] <ruoso> sure... but that's when doing lexical lookup... no problem there

[14:36] <masak> oh my, pun is still un-updated after the prefix:<=> thing... :/

[14:36] <ruoso> the dispatcher only have to decide if it does a lexical or package lookup

[14:36] <ruoso> the P6 dispatcher is lexically-based

[14:36] * TimToady is vaguely reassured

[14:36] <ruoso> the P5 dispatcher is package-based

[14:36] *** pmurias joined
[14:36] <jnthn> masak: nice!

[14:37] * masak ♥e Perl 6

[14:37] <PhatEddy> If you are asking to make the third and fourth like the tests for # 64204 I can do that and it would make sense.

[14:37] <masak> er, s/e//

[14:37] <moritz_> PhatEddy: yes, I think so

[14:37] <TimToady> well, lovee would be the opposite of the lover

[14:37] <TimToady> and I think Perl 6 loves you too

[14:38] <pmurias> jnthn: re HoH a representation doesn't have to store it that way it just needs to expose such an iterface

[14:38] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[14:38] <TimToady> well, at least it ♥s you...

[14:38] <PhatEddy> Ok and that B1 should be 'B'  ...

[14:39] <pmurias> jnthn: the other choice would be to have an Arrayish interface to the data

[14:39] * amoc also ♥s Perl

[14:40] <ruoso> btw... for those wondering... "faz" comes from the verb "fazer" in portuguese, which is "to do".... but when used with the singular third person (and portuguese allows it to have the subject hidden)... 

[14:40] *** SamB joined
[14:40] <PhatEddy> moritz_: Well once I fix the warts and it runs, will it be OK to name it basic.t in S10-packages and commit it?

[14:40] <moritz_> (to me "faz" is a big German newspaper :-)

[14:40] <masak> TimToady: I think you're right. :)

[14:41] <moritz_> PhatEddy: yes

[14:41] <masak> for those of you who haven't tried out pun yet, I can do this and you can't: perl6n -e '.say if .chars > 78' lib/Installer.pm

[14:41] <masak> (neener neener)

[14:42] <PhatEddy> moritz_: thank you so very much for spotting the problems.  I don't really understand karma or I would try to play with it ... :)

[14:43] <moritz_> PhatEddy: there's not much to understand. If I type PhatEddy++, you get karma. That works for everyone here :-)

[14:44] <PhatEddy> moritz_++

[14:44] <masak> karma++

[14:44] *** ejs joined
[14:46] <TimToady> everyone here++

[14:47] <frettled> That didn't work, someone needs to file a bug.  ;)

[14:48] <TimToady> .oO(I know a bug who would not like to be filed...)

[14:49] <skids> .oO(filing bugs is hard, given the unibody construction)

[14:49] <moritz_> @karma here

[14:49] <lambdabot> here has a karma of 1

[14:50] <moritz_> well, that worked.

[14:51] <TimToady> everyone here++

[14:51] <SamB> don't expect lambdabot to remember your karma for long ;-P

[14:51] <TimToady> @karma everyone here

[14:51] <lambdabot> everyone􏿽xC2 has a karma of 0

[14:51] <TimToady> stupid lambdabot

[14:51] <SamB> what the HECK???

[14:51] *** azawawi left
[14:52] <TimToady> lambdabot is running in Latin-1 mode :(

[14:52] <SamB> ah

[14:52] <SamB> you used some wierd UTF-8 space!

[14:52] <TimToady> actually, I used a Latin-1 space, but encoded in utf-8

[14:53] <moritz_> the non-breaking space

[14:53] <SamB> well, it doesn't look like it would have worked anyway

[14:53] <TimToady> shoulda, if lambdabot were doing Unicode correctly

[14:53] <TimToady> another good reason for writing our own...

[14:54] <SamB> oh, wait ...

[14:54] * SamB remembers that the second byte of a utf-8 encoded latin-1 char isn't the same as the n

[14:54] <frettled> @karma everyone here

[14:54] <lambdabot> everyone has a karma of 3

[14:54] <TimToady> sometimes it is, and sometimes it isn't the same

[14:55] *** payload left
[14:55] *** mberends joined
[14:56] <TimToady> @karma ¥

[14:56] <lambdabot> ¥ has a karma of 0

[14:56] *** nihiliad joined
[14:56] <frettled> @karma lambdabot 

[14:56] <lambdabot> lambdabot has a karma of -1

[14:57] <TimToady> Perl 6++

[14:57] <TimToady> @karma Perl 6

[14:57] <lambdabot> Perl 6 has a karma of 1

[14:58] <TimToady> now *that* one is a weird Unicode space

[14:58] *** ejs left
[14:59] <TimToady> @karma Perl 6

[14:59] <lambdabot> Perl 6 has a karma of 0

[14:59] <frettled> Ah, time for that Oslo.pm meet where Marcus will repeat his G(et)it talk for the benefit of those of us who didn't attend during NPW.

[14:59] <TimToady> that's probably the one we *should* be using "NARROW NO BREAK SPACE"

[15:00] <frettled> or just regular space :D

[15:00] <TimToady> with a :nobreak adverb

[15:00] <TimToady> :!break, excuse me

[15:00] <frettled> \o/

[15:02] <TimToady> must...back...log...

[15:02] <masak> TimToady-eval: say +['foo', 'bar'].comb(/foobar/)

[15:03] <TimToady> Nil

[15:03] <TimToady> er, 0

[15:03] <masak> TimToady: in what way, then, is a list treated as a string?

[15:03] <TimToady> [] makes an array, not a list :P

[15:03] <masak> er.

[15:03] <TimToady> actually, comb should probably work on array too

[15:03] <masak> rakudo: say Array ~~ List

[15:03] <p6eval> rakudo 71c69d: OUTPUT«1␤»

[15:04] * masak stands arms akimbo

[15:05] <masak> Liskov says "comb should work on Array too!"

[15:05] * moritz_ says "that's what we have >>. for"

[15:05] <TimToady> well, if comb works for lists at all; is that specced anywhere?

[15:05] <masak> TimToady: aye.

[15:05] <masak> S32/Str

[15:06] <moritz_> that's a weird place for that :-)

[15:06] <masak> we talked about it yesterday; I'm making the required additions in Container and IO right now.

[15:06] <moritz_> TimToady: what do you think, should .comb always return a List of Match objects?

[15:06] <moritz_> or optionally strings?

[15:07] <masak> btw, S32/Containters.pod contains a lot of signatures on the form 'our Junction multi method none( @values: )' -- I suppose that's not a valid way to supply a return type in Perl 6?

[15:08] <moritz_> why not?

[15:08] <jnthn> It's valid.

[15:08] <masak> oh. ok.

[15:08] <moritz_> std: our Junction multi method none( @values: ) { }

[15:08] <p6eval> std 26703: OUTPUT«ok 00:02 37m␤»

[15:08] *** wolverian left
[15:08] <jnthn> rakudo: our Int multi foo() { }; say &foo.returns

[15:08] <p6eval> rakudo 71c69d: OUTPUT«Object()␤»

[15:08] <jnthn> rakudo: our Int sub foo() { }; say &foo.returns

[15:08] <masak> for a moment, I thought it was someone's Java interference.

[15:08] <p6eval> rakudo 71c69d: OUTPUT«Int()␤»

[15:09] <jnthn> Ah, for multis heck knows what it returns. :-)

[15:09] <moritz_> and heck ~~ Object

[15:09] <masak> good thing it doesn't blow up, at least.

[15:09] <jnthn> rakudo: our Int sub foo() { }; say &foo.candidates[0].returns

[15:09] <p6eval> rakudo 71c69d: OUTPUT«Method 'candidates' not found for invocant of class ''␤current instr.: 'parrot;P6metaclass;dispatch' pc 248543 (src/gen_actions.pir:23326)␤»

[15:09] <jnthn> rakudo: our Int multi foo() { }; say &foo.candidates[0].returns

[15:09] <p6eval> rakudo 71c69d: OUTPUT«Int()␤»

[15:10] <jnthn> w00t

[15:10] <masak> jnthn: maybe only subs should also have a .candidates?

[15:10] <jnthn> masak: dunno

[15:10] <jnthn> môže byť

[15:10] <masak> TimToady: I'm now blocked on the .comb-on-lists commit. should I just scrap it for now?

[15:11] <masak> I could adapt the comment in Str.pod acoordingly...

[15:11] <TimToady> at the moment the spec seems to assume that strings should be returned by default.  I didn't write that part...

[15:11] <moritz_> TimToady: I know, that's why I'm asking

[15:11] * masak does git svn blame

[15:11] * jnthn makes a cuppa and digs back in

[15:11] <moritz_> IMHO it would be sane to assume that Matches are returned by default

[15:12] <moritz_> and that :str or so would be an optimization

[15:12] <TimToady> well, if it's really cat mediated, then foobar should certainly match across the boundary

[15:13] <TimToady> and I think Match objects should be the default, not string

[15:13] <TimToady> since Match can autopromote to string at need, but not the other way

[15:14] <moritz_> aye

[15:14] <TimToady> though the real sticking point for implementation is cat

[15:14] <TimToady> if you don't cheat and do it eagerly

[15:15] <dalek> rakudo: 45fcaee | pmichaud++ | docs/spectest-progress.csv:

[15:15] <dalek> rakudo: spectest-progress.csv update: 380 files, 11013 passing, 0 failing

[15:15] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/45fcaee8853cd631b69c5c8f07e7dc888f5c0403

[15:15] <TimToady> we've said that StrPos is opaque, but returning a match across an array boundary will certainly stress that

[15:16] <masak> TimToady: git-svn claims you wrote the "You may also comb lists and filehandles" part.

[15:16] <TimToady> and then there's the whole mutable/immutable problem, which we also have with returning string results

[15:16] <pmichaud> s/you wrote/last edited/  # perhaps

[15:16] <masak> pmichaud: nope. wrote.

[15:17] <masak> I went all the way back.

[15:17] <TimToady> svn claims that line is wayland

[15:17] <pmichaud> even into S29?

[15:17] <masak> aye.

[15:17] <masak> at that time, it was called Functions.pod.

[15:17] <TimToady> oh, S29

[15:17] <TimToady> okay

[15:17] <masak> TimToady: you're only on the first layer if you find wayland. :)

[15:17] <TimToady> yes, I don't mind that part :)

[15:17] <pmichaud> git-svn ftw

[15:17] <masak> TimToady: then why did my array example eval to 0?

[15:18] <TimToady> I already changed my mind on that

[15:18] <masak> oh, ok.

[15:18] <masak> I missed that.

[15:18] <masak> so, 1, then.

[15:19] <TimToady> yes, returns one match object

[15:19] <TimToady> which, even if returned as a Capture and autoitemized, still returns 1

[15:19] <TimToady> but I think comb can stay explicit List return rather than Capture

[15:20] *** donaldh left
[15:20] <TimToady> there being little use case for using comb to extract a single value

[15:20] *** donaldh joined
[15:20] <pugs_svn> r26704 | masak++ | [S32/IO] removed $chars param from .getc

[15:20] <pugs_svn> r26704 | masak++ | 

[15:20] <pugs_svn> r26704 | masak++ | See <http://irclog.perlgeek.de/perl6/2009-05-06#i_1122346> for the

[15:20] <pugs_svn> r26704 | masak++ | discussion about this.

[15:20] <pugs_svn> r26705 | masak++ | [S32/Containers] added .comb

[15:20] <pugs_svn> r26705 | masak++ | [S32/IO] added .comb

[15:25] *** payload joined
[15:28] <TimToady>  on the other hand, using comb(/./) will generate an awful lot of Match objects

[15:29] <TimToady> looking at the getc discussion, I wonder if there wants to be something that says: whatever this is, return me its characters in order

[15:29] <TimToady> and *that* could have a limiter

[15:29] <skids> http://irclog.perlgeek.de/perl6/2009-04-17#i_1071956 <-- previous conversation on return value of comb

[15:29] <TimToady> unfortunately, ..chars is taken

[15:34] <TimToady> I like the "spec fight!" part  :)

[15:35] <TimToady> well, to argue it the other way for a bit, in most simple cases strings are indistinguishable from match objects except in boolean context

[15:35] <TimToady> (and methods)

[15:38] <moritz_> maybe .chars and .bytes etc. just return lazy lists of characters?

[15:38] <TimToady> I'm half inclined to leave it as strings, but change the default to . instead of \S+

[15:38] <moritz_> and they know their lengths, so that they can be used as numbers efficiently

[15:38] <TimToady> (comb, that is)

[15:38] <moritz_> (don't know if that's feasible, and if it's a good idea)

[15:38] <TimToady> setup of a lazy chars object just to get the length is probably rather heavyweight

[15:38] <moritz_> right

[15:40] <TimToady> but if .comb is split(''), then it already applies to most of the things you might want the chars from, including filehandles

[15:40] <TimToady> and already has the limiter we removed from getc

[15:41] <TimToady> we could have a .words that was short for .comb('\S+') if we decided to go that way

[15:41] <TimToady> er,

[15:41] <TimToady> /\S+/

[15:41] <TimToady> I think I just made a good argument for .words  :)

[15:42] <TimToady> (by accident)

[15:42] <TimToady> so I think .comb() is the new split('')

[15:43] <TimToady> so we can say .comb.mumble.join without arguments

[15:43] <masak> words++

[15:43] <masak> I've actually wanted this at times.

[15:43] <TimToady> for words() {...}

[15:43] <dalek> rakudo: 871c1e3 | jnthn++ | src/ (2 files):

[15:43] <dalek> rakudo: Get .^parents and .^methods a bit more in line with spec; update WALK.

[15:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/871c1e3836d4bfea56a0a1ac4840d0912e7019c9

[15:43] <dalek> rakudo: bd1c1e9 | jnthn++ | t/spectest.data:

[15:43] <dalek> rakudo: Add S12-introspection/meta-class.t.

[15:43] <masak> \o/

[15:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/bd1c1e9ae0b64b800a3a26a776c329e85951889e

[15:43] <dalek> rakudo: 79eb819 | jnthn++ | src/parser/ (2 files):

[15:43] <dalek> rakudo: Get us able to parse module names with colonpairs in (don't do anything with them for now though; this just brings us closer to STD.pm and lets us parse a spectest I want to be able to run).

[15:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/79eb819c6ae0253d9813c73c64b14476ba9a567b

[15:43] <TimToady> like lines() that way

[15:44] <masak> exactly.

[15:44] <TimToady> though I wish we weren't overloading plural for two different meanings that way; maybe lazy iterators are okay for the longer units

[15:45] <moritz_> jnthn: you brought us a large step closer to running most of the modules in pugs/ext/ :-)

[15:45] <TimToady> esp if the iterator can optimize when it finds itself in numeric context

[15:45] <jnthn> moritz_: By...?

[15:45] <moritz_> jnthn: by the parsing commit

[15:45] <jnthn> moritz_: Oh.

[15:45] <jnthn> :-)

[15:45] <moritz_> jnthn: they all start with module Name:v<0.0.1> or so

[15:45] <jnthn> I only did it so I could get away with parsing a spectest. :-)

[15:46] <jnthn> TimToady: $object.*@candidates(@args);

[15:46] <jnthn> And $object.@candidates(@args);

[15:46] <jnthn> In the second one, IIUC, we call the first one, and if it just returns rather than defers we don't bother with the rest of the list.

[15:46] <jnthn> With .* what would happen?

[15:46] <jnthn> Would we call them all anyway?

[15:47] *** Su-Shee joined
[15:47] <Su-Shee> Hi.

[15:47] <TimToady> masak: are you editing S32 then?

[15:47] <jnthn> And if one of them did defer, so we consumed part of the candidate list, would we then resume calling the next unconsumed thing, rather than re-calling?

[15:47] <masak> TimToady: I'll need to backlog and re-read, but sure.

[15:47] <TimToady> thanks

[15:48] <masak> TimToady: er, does this mean that IO and List will also have .words, in addition to .comb?

[15:49] <TimToady> yes

[15:49] <masak> gotcha.

[15:50] <TimToady> and that there's a function words that reads from $*ARGFILES

[15:50] <TimToady> or whatever we're calling it today

[15:51] <moritz_> $*MAGICARGS :-)

[15:51] <jnthn> $*ARGH

[15:51] <TimToady> std: for lines {...}

[15:51] <p6eval> std 26705: OUTPUT«##### PARSE FAILED #####␤Missing block at /tmp/YK1AF1COtS line 0:␤------> [32m[31m[0m␤    expecting parameterized block␤FAILED 00:02 35m␤»

[15:51] <masak> rakudo: for lines { ... }

[15:51] <p6eval> rakudo bd1c1e: OUTPUT«No applicable candidates found to dispatch to for 'lines'␤current instr.: '_block14' pc 70 (EVAL_19:52)␤»

[15:52] <TimToady> std: for lines {...};

[15:52] <p6eval> std 26705: OUTPUT«##### PARSE FAILED #####␤Missing block at /tmp/vuSQ7kzZfZ line 1:␤------> [32mfor lines {...}[31m;[0m␤    expecting any of:␤      blockoid␤ parameterized block␤      standard stopper␤ terminator␤     whitespace␤FAILED 00:02 35m␤»

[15:52] <TimToady> hmm, why isn't it...oh, right...

[15:52] <TimToady> std: for foo {...}

[15:52] <p6eval> std 26705: OUTPUT«##### PARSE FAILED #####␤Missing block (eaten by accidental listop?) at /tmp/DN5DFyJCUA line 0:␤------> [32m[31m[0m␤    expecting parameterized block␤Undeclared routine:␤  foo used at 1 ␤FAILED 00:02 35m␤»

[15:52] <Su-Shee> moritz_: it seems your indispensable documentation in your blog has a little link mistake..

[15:53] <TimToady> I was looking for 'eaten by accident' but lines is already defined

[15:53] <TimToady> so my test didn't catch it

[15:53] *** Psyche^ joined
[15:53] <moritz_> Su-Shee: that happens... which post, which link?

[15:53] <Su-Shee> moritz_: all of the perl 6 basics series linked from "posts in category" in your left-side "menu"

[15:54] *** justatheory joined
[15:54] <Su-Shee> moritz_: 03-control-structures.html/03-control-structures.html for example

[15:55] <moritz_> Su-Shee: I see what you mean... I'll look into that tonight

[15:55] <moritz_> Su-Shee: thanks for the notice

[15:55] *** kidd joined
[15:56] <Su-Shee> moritz_: thanks for writing it. :)

[15:59] <masak> rakudo: my $x = "OH HAI"; "foo" ~~ / ^ foo {{ $P1 = find_lex␤say $P1␤}} $ /

[15:59] <p6eval> rakudo bd1c1e: OUTPUT«The opcode 'find_lex_p' (find_lex<1>) was not found. Check the type and number of the arguments␤current instr.: 'parrot;PGE;Grammar;' pc 276 (EVAL_18:127)␤»

[15:59] <masak> oops.

[15:59] <masak> rakudo: my $x = "OH HAI"; "foo" ~~ / ^ foo {{ $P1 = find_lex "$x"␤say $P1␤}} $ /

[15:59] <p6eval> rakudo bd1c1e: OUTPUT«Lexical '$x' not found␤current instr.: 'anon' pc 3 (EVAL_19:3)␤»

[15:59] * masak submits rakudobug

[15:59] <ruoso> masak, pmichaud already told me PGE didn't catch up with perl 6 lexicals yet

[16:00] <ruoso> pmichaud, but I wonder if there's any way to work-around it in the meanwhile...

[16:00] <masak> yes, but did he tell RT? :)

[16:00] <masak> this was supposed to be the workaround.

[16:00] <masak> that's why it's important to complain when it doesn't work.

[16:00] <masak> things such as variable access are half the utility of closures.

[16:03] *** kaether joined
[16:03] <TimToady> BLing, I'm fine with .^parents

[16:04] <TimToady> I pretend not to care about anything behind .HOW in any case

[16:04] <ruoso> one thing it would be interesting for you to care about HOW would be to define the different roles that a HOW could implement

[16:05] <ruoso> which would define which OO features it supports

[16:08] *** cdarroch joined
[16:08] *** Psyche^ is now known as Patterner

[16:09] * masak just wrote C<a ? b ! c> in Java, uncomprehending about the syntax errors he got

[16:09] <TimToady> should I show up for the parrot thingy before YAPC, or is that likely to be VM-only-ish?

[16:09] <jnthn> Oh, is it defined as before YAPC now?

[16:09] <pmichaud> TimToady: I think you could go either way.

[16:09] <pmichaud> The hackathon is post-YAPC.

[16:09] <jnthn> Oh, are we talking about YAPC::EU or YAPC::NA?

[16:09] <pmichaud> YAPC::NA

[16:09] <jnthn> ah.

[16:09] <TimToady> I'm talking about NA

[16:10] <pmichaud> "the parrot thingy" == "Parrot Virtual Machine Workshop"

[16:10] <TimToady> is that a hackathon?

[16:10] <pmichaud> TimToady: I expect it to be more tutorial-like than hackathon-like.

[16:10] <TimToady> k

[16:10] <jnthn> yeah, as opposed the "the other parrot thingy" == "Parrot Developer summit"

[16:10] <TimToady> and the other is after EU?

[16:10] <TimToady> or NA?

[16:10] <pmichaud> particle would be the person to ask about the PVMW at YAPC::NA

[16:10] <TimToady> Glo seems to want to know where I'll be when :)

[16:11] <ruoso> masak, btw... I think the fix to that bug would be the fix to accessing named closures from the Perl 6 lexical scope itself, which is how it is implemented now....

[16:11] <jnthn> TimToady: I've heard discussion of something Parrot-ish at YAPC::EU, but don't know before or after or if...

[16:11] <TimToady> so there's a hackathon after NA?

[16:11] <pmichaud> so, the current schedule (as I understand it):   PVWM  Jun 20-21,  YAPC::NA Jun 22-24,  Hackathon Jun 25-26

[16:11] <masak> ruoso: ok.

[16:12] <jnthn> ruoso: The fix is probably more about setting :outer correctly.

[16:12] <jnthn> (I suspect the regex doesn't know its outer lexical scope.)

[16:12] <TimToady> ok, Daniel didn't seem to know about the post-hackathon

[16:12] <pmichaud> the regex does, its embedded closure doesn't.

[16:12] <jnthn> Ah, OK.

[16:12] <ruoso> pmichaud, the embedded doesn't do it properly tho

[16:13] <pmichaud> the regex does, its embedded closure doesn't.

[16:13] <ruoso> sorry

[16:13] <ruoso> the regex doesn't

[16:13] <ruoso> rakudo: sub foo { sub bar { }; return / foo <bar> /;}; "foo " ~~ foo();

[16:14] <p6eval> rakudo bd1c1e: OUTPUT«No such attribute '$.pos'␤current instr.: 'parrot;PGE;Grammar;' pc 583 (EVAL_16:233)␤»

[16:14] <ruoso> hmm... let me try to reproduce the specific problem a bit better

[16:14] <pmichaud> bar isn't returning anything that PGE understands.

[16:14] <ruoso> that wasn't the problem I was trying to reproduce

[16:15] <ruoso> rakudo: sub foo { my sub bar { }; return / foo <bar> /;}; "foo " ~~ foo();

[16:15] <p6eval> rakudo bd1c1e: OUTPUT«Unable to find regex 'bar'␤Null PMC access in invoke()␤current instr.: 'parrot;PGE;Grammar;' pc 586 (EVAL_18:234)␤»

[16:15] <ruoso> there it is

[16:15] * masak submits rakudobug

[16:15] <jnthn> ruoso: Does making bar non-lexical change anything?

[16:15] <ruoso> it stops solving my problem ;)

[16:16] <ruoso> jnthn, but the above error was a sane error

[16:16] <ruoso> jnthn, as it wasn't lexically scoped, it was found

[16:17] <ruoso> (by above I mean the one before the last)

[16:17] <pmichaud> rakudo:  sub foo { my sub bar { 1 };  return { bar(); } };   foo();

[16:17] <p6eval> rakudo bd1c1e:  ( no output )

[16:18] <pmichaud> rakudo:  sub foo { my sub bar { 1 };  return { bar(); } };   foo().say;

[16:18] <p6eval> rakudo bd1c1e: OUTPUT«_block38␤»

[16:18] <ruoso> rakudo:  sub foo { my sub bar { 1 };  return { bar(); } };   foo().().say;

[16:18] <p6eval> rakudo bd1c1e: OUTPUT«1␤»

[16:19] <masak> ah, that one is in RT already.

[16:20] <arnsholt> Hmm. Rakudo doesn't want to build after I updated a few minutes ago. Anyone else?

[16:20] <ruoso> pmichaud, does that mean it is a different problem than you initially thought?

[16:20] <jnthn> arnsholt: details?

[16:21] <jnthn> (I've got Rakudo building fine here...

[16:21] <jnthn> )

[16:21] <moritz_> arnsholt: did you reconfigure + 'make parrot'?

[16:21] <arnsholt> Says "Class 'Perl6MultiSub' not found", and a stack trace

[16:21] <ruoso> pmichaud, as an absolutely misinformed bystander... it seems to be that PGE is taking the package as the namespace instead of the closer lexical scope...

[16:21] <pmichaud> ruoso: not precisely

[16:21] *** payload left
[16:22] <pmichaud> ruoso: PGE uses parrot's find_name opcode, which first checks the lexical scope, then checks package scope.

[16:22] <moritz_> pmichaud: iirc you wanted to review the patch to the build system... any progress on that? or do you want me to do a first pass?

[16:22] <arnsholt> moritz_: I reconfigured, and I think it does make parrot as part of the top-level rule. At any rate, it says that parrot is up to date now

[16:22] <TimToady> jnthn: when does the code in a role block execute?

[16:22] <jnthn> TimToady: When you create a particular parameterization of the role.

[16:22] <jnthn> role Foo[::T] { };

[16:22] <ruoso> pmichaud, oh right... so it really seems to be an :outer problem...

[16:22] <moritz_> arnsholt: you could also try a 'make clean' in rakudo

[16:23] <arnsholt> Yeah, Trying that now

[16:23] <jnthn> class C1 does Foo[Int] { }; # runs once here

[16:23] <TimToady> I wonder if we need a COMPOSE {...} block

[16:23] <jnthn> class C2 does Foo[Str] { }; # runs again here

[16:23] <TimToady> to check things at compose time

[16:23] <jnthn> class C3 does Foo[Int] { }; # doens't run again, we already had a Foo[Int] created

[16:24] <arnsholt> Yeah, that worked

[16:24] <jnthn> TimToady: So you can do things like, checking if another role has been composed too?

[16:24] <TimToady> earlier wolverian was asking if there's a way to require another role in the composition

[16:24] <jnthn> *nod*

[16:24] <TimToady> (still bling)

[16:24] <TimToady> so kind of COMPOSECHECK, really

[16:24] <TimToady> or POSTCOMP

[16:24] <jnthn> Right. post-compose

[16:24] <TimToady> implying possibly PRECOMP

[16:25] <jnthn> "is there anything about this class independent of what else is composed into it that I care about?"

[16:25] <jnthn> Hmm. Perhaps.

[16:25] <jnthn> I'd really want it post compose I guess because the order of composition is not meant to matter.

[16:25] <TimToady> would probably be a mistake to overload PRE/POST

[16:25] <ruoso> I'm not sure we need such blockx

[16:26] *** M_o_C joined
[16:26] <TimToady> ruoso: as a primitive for building other assertions about the composition, mostly

[16:26] <ruoso> I think that's something that could be delegated to the HOW of the role

[16:26] <ruoso> we could promote custom HOW instead of hook blocks

[16:26] <jnthn> ruoso: Most users aren't going to write HOWs.

[16:27] <TimToady> well, presumably most users wouldn't write POSTCOMP either, but something that desugars to it

[16:27] * ruoso a bit afraid of the huge amount of hook blocks we have now in Perl 6

[16:27] <jnthn> True.

[16:28] <masak> as long as they don't slow down people who don't use them...

[16:28] * TimToady waves hands frantically in the direction of the optimizer, then hides behind a tree

[16:28] <masak> 休

[16:29] <pmichaud> I think the problem is that our regexes aren't getting a capture_lex on them, so they aren't capturing the lexical environment.

[16:30] <pmichaud> oh, alas, that appears not to be the problem.

[16:31] <ruoso> jnthn, TimToady, one thing I just realized however, is that compose_role is on the side of the target class at this point...

[16:31] <pmichaud> oh, I see the problem.  Yes, PGE bug.  Its outer handler is properly lexical, but the inner one is not.

[16:31] <ruoso> pmichaud, sounds easy to fix when you say it ;P

[16:31] <masak> pmichaud++

[16:31] <ruoso> jnthn, TimToady, maybe it should be done in the side of the role

[16:31] <TimToady> it?

[16:31] <ruoso> the role composition

[16:32] <pmichaud> rakudo:  sub foo { sub bar { };  return token / foo <bar > /; };   "foo " ~~ foo();

[16:32] <p6eval> rakudo bd1c1e: OUTPUT«Malformed regex definition at line 1, near "/ foo <bar"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[16:32] <TimToady> compose yourself...

[16:32] <pmichaud> rakudo:  sub foo { sub bar { };  return token { foo <bar > }; };   "foo " ~~ foo();

[16:32] <p6eval> rakudo bd1c1e: OUTPUT«Syntax error at line 1, near "};   \"foo "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[16:32] <ruoso> compose yourself into that class

[16:32] <TimToady> I think the class and the role should each say "after you" a couple times first

[16:32] <pmichaud> rakudo:  sub foo { sub bar { };  return token { foo <bar> }; };   "foo " ~~ foo();

[16:32] <TimToady> "no I insist"

[16:32] <p6eval> rakudo bd1c1e: OUTPUT«No such attribute '$.pos'␤current instr.: '_block35' pc 547 (EVAL_17:220)␤»

[16:32] <pmichaud> there.

[16:33] <ruoso> what changed

[16:33] <ruoso> ?

[16:33] <pmichaud> token versus regex

[16:33] <ruoso> cooo

[16:33] <ruoso> cool

[16:33] <pmichaud> regex has to take a continuation -- that continuation didn't have its outer lexical context set properly

[16:33] * ruoso testing

[16:33] <pmichaud> token doesn't have to take a continuation (no backtracking), so there's no inner continuation to have to worry about.

[16:34] <TimToady> token can have explicit backtracking

[16:35] <TimToady> .*? and .*!

[16:35] <pmichaud> but we don't backtrack into the token

[16:35] <pmichaud> within the token, yes, there's backtracking.

[16:35] <TimToady> trew

[16:35] <ruoso> pmichaud, .clone is not implemented in Match...

[16:35] <ruoso> is it?

[16:35] <pmichaud> I don't think it is.

[16:35] <moritz_> isn't there some modifier to force backtracking?

[16:35] <ruoso> right

[16:35] <pmichaud> Match objects are not things that lend themselves to cloning.

[16:35] <ruoso> what are the parameters to Match.new?

[16:36] <pmichaud> an existing Match object will work.

[16:36] <pmichaud> Match.new($/)

[16:39] *** kaether_ joined
[16:40] *** sri_kraih left
[16:40] *** AzureStone left
[16:40] *** Kisu left
[16:40] *** kane___ left
[16:40] *** DemoFreak left
[16:40] *** simcop2387 left
[16:40] *** rewt left
[16:40] *** pmichaud left
[16:40] *** Helios left
[16:40] *** allbery_b left
[16:40] *** awwaiid left
[16:40] *** yahooooo left
[16:40] *** revdiablo left
[16:40] *** kcwu left
[16:40] *** pasteling left
[16:40] *** kaether left
[16:40] *** jrockway left
[16:40] *** literal left
[16:40] *** mtve left
[16:40] *** hcchien left
[16:40] *** eternaleye left
[16:40] *** H1N1[A] left
[16:40] *** xinming_ left
[16:40] *** aindilis left
[16:40] *** nemstep left
[16:40] *** Tene left
[16:40] *** cotto left
[16:40] *** amoc left
[16:40] *** SamB left
[16:40] *** wollmers left
[16:40] *** cxreg left
[16:40] *** Aisling left
[16:41] *** kaether_ is now known as kaether

[16:41] <PhatEddy> rakudo: package A {} ; try { A::nonesuch }; say "hi"; A::nonesuch

[16:42] <p6eval> rakudo bd1c1e: OUTPUT«hi␤Null PMC access in invoke()␤current instr.: '_block14' pc 110 (EVAL_20:66)␤»

[16:42] *** Eevee joined
[16:42] <PhatEddy> should try catch the Null PMC there?

[16:42] *** Aisling joined
[16:43] *** jnthn joined
[16:43] *** literal joined
[16:43] *** frew|wor1 joined
[16:43] *** hcchien joined
[16:43] *** xinming_ joined
[16:43] *** aindilis joined
[16:43] *** nemstep joined
[16:43] *** eternaleye joined
[16:43] *** H1N1[A] joined
[16:43] *** jan_ joined
[16:43] *** hatseflats joined
[16:43] *** [particle] joined
[16:43] *** japhb joined
[16:43] *** buu joined
[16:43] *** Maddingue joined
[16:43] *** Tene joined
[16:43] *** cotto joined
[16:43] *** irc.freenode.net sets mode: +oo jnthn Tene

[16:43] * PhatEddy I guess otherwise how would you catch it?

[16:44] <masak> PhatEddy: no. a Null PMC access should never occur in the first place.

[16:44] <masak> It Is Simply Wrong.

[16:45] *** rafl joined
[16:45] *** awwaiid joined
[16:45] *** yahooooo joined
[16:45] *** revdiablo joined
[16:45] *** kcwu joined
[16:45] *** pasteling joined
[16:46] <PhatEddy> TimToady: I happened to notice that my proposed spec tests sometimes check for ~$! ~~ /:s Null PMC/ which is rakudo specific ... rationalizing the question I guess.

[16:46] *** SamB joined
[16:46] *** wollmers joined
[16:46] *** cxreg joined
[16:46] *** phenny joined
[16:46] *** diakopter joined
[16:46] *** Woody2143 joined
[16:47] *** pmichaud joined
[16:47] *** cls_bsd joined
[16:47] *** DemoFreak joined
[16:47] *** simcop2387 joined
[16:47] *** rewt joined
[16:47] *** avar joined
[16:47] *** Helios joined
[16:47] *** allbery_b joined
[16:47] *** irc.freenode.net sets mode: +o pmichaud

[16:47] *** sri_kraih joined
[16:47] *** gfldex joined
[16:47] *** scook0 joined
[16:47] *** breinbaas joined
[16:47] *** rhr joined
[16:47] *** ascent_ joined
[16:47] *** ingy joined
[16:47] *** bacek joined
[16:47] *** broquaint joined
[16:47] *** kane___ joined
[16:47] *** Kisu joined
[16:47] *** AzureStone joined
[16:47] *** dalek joined
[16:47] *** agentzh joined
[16:47] *** bacek left
[16:47] *** rhr left
[16:47] *** ingy left
[16:47] *** Kisu left
[16:47] *** AzureStone left
[16:47] *** broquaint left
[16:47] *** ascent_ left
[16:47] *** kane___ left
[16:47] *** AzureStone joined
[16:47] *** Kisu joined
[16:47] *** kane___ joined
[16:47] *** broquaint joined
[16:47] *** bacek joined
[16:47] *** ingy joined
[16:47] *** ascent_ joined
[16:47] *** rhr joined
[16:47] *** kaether_ joined
[16:47] *** amoc joined
[16:47] *** Infinoid joined
[16:47] *** silug joined
[16:47] *** sephee joined
[16:48] *** kaether left
[16:48] *** kaether_ is now known as kaether

[16:48] <TimToady> .oO(netsplits are Simply Wrong too)

[16:48] <pmichaud> spectests should probably not do anything Rakudo specific.

[16:48] <pmichaud> (or any-other-implementation-specific)

[16:49] <TimToady> no "probably" about it

[16:50] <TimToady> though generally the attempt should indicate the specs aren't clear enough at some point

[16:51] <TimToady> so what *should* the generic error "My platform blew up" look like to Perl 6?

[16:51] *** eternaleye left
[16:51] <jnthn> segmentation fault

[16:51] <jnthn> ;-)

[16:51] *** ALFONSO joined
[16:51] *** kaether_ joined
[16:52] <TimToady> well, then, is it $! ~~ ESIGSEGV?

[16:52] <ruoso> pmichaud, does the match contain the full string being matched? how do I get it?

[16:53] <TimToady> for extra credit, make $! ~~ ESIGKILL work  :)

[16:53] <PhatEddy> Please bear in mind someone could do a 'die "lost in space"' from a setting/prelude some day ...

[16:53] <pmichaud> ruoso: the match does contain (a reference to) the full string being matched... I'm not sure there's a method to get to it yet, though.

[16:54] <ruoso> hmm... it seems it is not copied using Match.new($/)

[16:54] <pmichaud> well, it would take the same original target that $/ has.

[16:54] <TimToady> well, culturally we can prohibit string exceptions where we decide they're detrimental, or at least classify them all as X_RANDOM or some such

[16:54] <pmichaud> Assuming that $/ is a Match object.

[16:54] <ruoso> it is...

[16:55] <ruoso> but $/.perl doesn't seem to be very usefull

[16:55] *** hudnix joined
[16:55] <pmichaud> I'll add .orig to PGE

[16:55] <ruoso> pmichaud, it currently dies with null pmc at get_string when I try to coerce it to bool

[16:55] *** kaether left
[16:55] *** kaether_ is now known as kaether

[16:56] <pmichaud> it?

[16:56] <ruoso> rakudo

[16:56] <pmichaud> rakudo dies with null pmc at get_string when you try to coerce ?? to bool

[16:56] <ruoso> the match...yes...

[16:56] <pmichaud> which match?

[16:57] <ruoso> pmichaud, I'm pushing the code to github...

[16:57] <pmichaud> okay.

[16:57] <ruoso> http://github.com/ruoso/faz/blob/40aca7f7c3172de5580558c79ff6076f5ecbb1fe/lib/Faz/Dispatcher.pm

[16:57] *** IRSeekBot joined
[16:58] <ruoso> it dies between 'subrx 4' and 'subrx 4.1'

[16:58] <pmichaud> because $_ isn't set.

[16:58] <pmichaud> at least, that's my guess.

[16:58] <ruoso> what should it have?

[16:58] <pmichaud> well, wiat.

[16:58] <pmichaud> I misread the rx(...) part.

[16:59] <pmichaud> you're passing the Match object to a regex?

[16:59] <pmichaud> you need to either send 'pos', or set the Match object's .to()

[16:59] <ruoso> in that same call

[16:59] <ruoso> ?

[16:59] <pmichaud> (that still doesn't quite explain the null pmc)

[17:00] *** km2 joined
[17:00] <pmichaud> creating a new Match object creates a false match unless you do something to turn it into a valid one.

[17:00] <ruoso> but the submatches are actually a pge token directly

[17:01] <pmichaud> I'm not quite sure what you're wanting    $submatch = $/.new($/);  .... $result = rx($submatch);   to do

[17:01] <PhatEddy> Just noting that we do string "die" from places in setting as of now ...

[17:01] <pmichaud> PhatEddy: "die" is standard Perl 6.  There's no problem with that.

[17:01] <ruoso> pmichaud, I thought it would be needed to have a new match

[17:01] <pmichaud> regexes will create + return a new match

[17:01] <pmichaud> you don't have to create one for the regex to populate.

[17:02] <ruoso> right...

[17:03] <PhatEddy> Could someone then explain: (TimToady) well, culturally we can prohibit string exceptions

[17:03] <TimToady> culturally: if you do that, you will be taken out and shot

[17:03] <ruoso> cool

[17:04] <pugs_svn> r26706 | masak++ | [S32/Str] comb now defaults to /./, use words for /\S+/

[17:04] <pmichaud> I took 'string exceptions' to mean "keying off of specific strings returned by an exception"

[17:04] <TimToady> but more likely it means we need a better way of implicitly typing our exceptions in various scopes

[17:04] <TimToady> so anything thrown in the compiler defaults to a syntax error type

[17:04] <TimToady> and anything thrown in the setting defaults to some other exception type

[17:05] *** mizioumt joined
[17:05] <TimToady> alternately, it's not default types, but mixins of who has seen this exception go past

[17:05] <[particle]nyc> and anything thrown in a string defaults to a string exception type? same for regex, expression, and other dsl's?

[17:05] <TimToady> so an exception gains a pedigree as it passes up the stack

[17:05] <[particle]nyc> sounds like swine flu

[17:05] <[particle]nyc> bird-pig-human

[17:06] *** masak left
[17:06] *** ALFONSO left
[17:07] <ruoso> interesting...

[17:07] <TimToady> but probably in general we need to have helper routines that die with an appropriately typed exception, panic, parsefail, settingfail, whatever

[17:08] <[particle]nyc> so !!! in a setting gives a different typed exception than in a rule

[17:08] <TimToady> or we go through at some point and change every die "foo" to die new XYZ: "foo"

[17:08] <[particle]nyc> brr

[17:08] <PhatEddy> there aren't that many in the rakudo setting right now I think

[17:09] <[particle]nyc> die XYZ("foo") would do it, too

[17:09] <pmichaud> ...and many places that are currently "die" may need to become "fail".

[17:09] <TimToady> I think perhaps, since any type defines a coercion, we can just say XYZ("foo")

[17:09] <TimToady> usually fail XYZ("foo")

[17:10] *** azawawi joined
[17:10] <[particle]nyc> XYZ("foo").fail ?

[17:10] <ruoso> pmichaud, hmm.... now the program just go nowhere...  it says "before" but not "after" nor "fail".... I pushed the last version to github...

[17:10] <[particle]nyc> does invoking an exception throw it?

[17:10] <dalek> rakudo: 2e2f74b | jnthn++ | src/pmc/p6invocation.pmc:

[17:10] <dalek> rakudo: P6Invocation should act more like a mutable iterator; we'll only clone it if we have to.

[17:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2e2f74b02a1fa574aa3b8530c762f7345b6816ab

[17:10] <dalek> rakudo: cab8784 | pmichaud++ | build/PARROT_REVISION:

[17:10] <dalek> rakudo: Bump PARROT_REVISION so we get fixes to PCT and .orig in PGE.

[17:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cab87843fa5d0c341e72f3967d8faf0c49739300

[17:10] <moritz_> adn that would automatically gather information about the source location etc?

[17:10] <dalek> rakudo: c38a2ea | pmichaud++ | :

[17:10] <dalek> rakudo: Merge branch 'master' of [email@hidden.address]
[17:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c38a2eab4fdc2e9ea1c1d6b330a82bfa9cb59155

[17:10] <TimToady> certainly not

[17:11] <TimToady> at least, not if you mean invoking the type object

[17:11] <TimToady> it's currently undefined on an actual exception object

[17:11] *** japhb left
[17:11] <TimToady> afaik

[17:12] <TimToady> and I think it's bad huffman to use .() for control flow

[17:13] <TimToady> even .fail is a bit bogus, from the standpoint of keeping the control flow out front where it can be easily seen

[17:13] <[particle]nyc> i like your reasoning on that.

[17:13] *** mico joined
[17:13] <pmichaud> what does 'return' mean in this context?  do we 'return' from pointy subs?

[17:14] <ruoso> pmichaud, ah... sorry...

[17:14] <TimToady> and I still think that if we want to encourage people to avoid string exceptions, we should huffmanize exception types as much as possible

[17:14] <[particle]nyc> you LEAVE them iiuc

[17:14] <TimToady> Exception:: is completely bogus in that regard

[17:14] <TimToady> and I've long been asking for something like X:: instead

[17:15] <TimToady> or even XFOO to go with EFOO

[17:15] <pmichaud> TimToady: I'd be very happy if you defined some basic exception types for us implementors to use as a model.

[17:15] <pmichaud> or gave us a model to work from.

[17:15] <[particle]nyc> the X! sigil/twigil pair :)

[17:16] * TimToady OH NOES

[17:16] <Tene> that would be really great.

[17:16] <TimToady> X-Files

[17:16] <[particle]nyc> X-Org

[17:17] <TimToady> an exceptional organization, to be sure

[17:18] <skids> Exceptions seem to be the exception to huffmanization.  IDoNotKnowHowToHuffmanizeException.

[17:18] <[particle]nyc> X'Cept

[17:18] <TimToady> X'I-DIDN'T-LIKE-IT

[17:20] <TimToady> I actually kinda like X' as a productive prefix unlikely to run into other uses of X-

[17:20] <pmichaud> although it does look like a metaop.

[17:20] <pmichaud> X~ X+ X-cetrera.

[17:20] <TimToady> I expect the rest of the word to be in Klingon

[17:20] <pmichaud> *-cetera

[17:20] <Tene> TimToady: if you could spec out some core exception classes or roles, I'd be very pleased.

[17:21] <TimToady> X'GBOR'TH!!!

[17:21] <Tene> klingon doesn't use X

[17:21] <TimToady> does now :)

[17:21] <pmichaud> Gesundheith.

[17:21] <pmichaud> Grrr.

[17:21] <pmichaud> Can't type today.

[17:21] <pmichaud> (or any other day lately)

[17:21] <TimToady> I can'th thype eithher.

[17:21] <skids> ><

[17:21] <pmichaud> pbthbhthth

[17:22] <pmichaud> see also:  Ack Phhth

[17:22] <PhatEddy> I don't know if I followed this well enough to do a detailed RT ticket - but I think I could open a somewhat vague one on 'typed exceptions for prelude'

[17:22] <TimToady> probably not worth a ticket till specced

[17:22] <pmichaud> Perhaps what we need is to find the current instances of die/fail and decide what they should be.

[17:23] <pmichaud> then from that we can start to understand the exception types we want.

[17:23] <TimToady> what, build the sidewalks where there are already paths in the grass?

[17:23] <pmichaud> Oh, right.  Never mind, that will never work.  :-)

[17:23] <moritz_> sounds not perl6ish enough

[17:23] <azawawi> pmichaud: im trying to build rakudo on win32 and it keeps failing.  http://sial.org/pbot/36440. Any ideas how to fix it?

[17:23] <pmichaud> we'll probably violate some language zoning ordinance or something.

[17:24] <TimToady> but, but, but, think of all the prior art we could mangle into unrecognizability

[17:24] <pmichaud> azawawi: unfortunately, I don't have win32 to be able to test much (more)

[17:25] * azawawi tries it on feather1...

[17:25] <TimToady> I do kinda like the notion of exception types as mixins though

[17:26] <pmichaud> azawawi: that said, I know that some recent Parrot commits removed PARROT_EXPORT from a number of functions, and it's possible that doing so has caused dynpmcs to stop working in certain Windows compilers.

[17:26] <TimToady> especially if an exception handler can mix in a new type and rethrow

[17:26] <pmichaud> well, the Failure role seems to me as though it really wants to be used as a mixin

[17:27] <TimToady> that'd be F'd now...

[17:28] <pmichaud> for example,   assuming that infix:</> should return a Failure instead of immediately dying... what should that look like in Perl 6?

[17:28] <TimToady> return Num but F'd;  :)

[17:28] <pmichaud> return Num but F'd("Divide by zero");   # ?

[17:28] <TimToady> well, s/return/fail

[17:28] <jnthn> azawawi: It works under the MS VC++ compiler; it may be something specific to mingw

[17:28] <pmichaud> and is it "return" or.... right

[17:29] <jnthn> F'd?

[17:29] <jnthn> oh, Failed...

[17:29] *** mizioumt left
[17:29] <jnthn> not...right... :-)

[17:29] <pmichaud> And  X'd  can be "X-rated"  :-)

[17:29] <jnthn> .oO( Failed wasn't the first word that came to mind )

[17:29] <TimToady> to the pure all things are pure :P

[17:30] <pmichaud> well, Perl 6 can certainly be colorful.  We're moving out of simply using punctuation for swearing to actually having it in the identifiers.  :-)

[17:30] <PerlJam> greetings.

[17:30] <pmichaud> it seems odd to me that we would do      fail Num but F'd(...);    though.  Why two "fail"s?

[17:31] <TimToady> my F'ing $F'er is F'd;

[17:31] <azawawi> jnthn: I am going to investigate it then. :)

[17:31] <pmichaud> azawawi: did this just start showing up?

[17:32] *** mico left
[17:32] <azawawi> pmichaud: after today's parrot svn update...

[17:32] <ruoso> pmichaud, cool... it parses already... now I'm struggling to get the captures...

[17:33] <[particle]nyc> how do you access the return type of a sub inside the sub?

[17:33] *** M_o_C left
[17:33] <PhatEddy> azawawi: I am getting the same think with mingw and Activestate - am working with the latest pull on cygwin ...

[17:33] <TimToady> fail Num: "divide by zero";  # maybe

[17:34] <jnthn> std: ::F'ing := Failure; my F'ing $F'er is F'd;

[17:34] <p6eval> std 26706: OUTPUT«##### PARSE FAILED #####␤In "my" declaration, typename F'ing must be predeclared (or marked as declarative with :: prefix) at /tmp/QEM2pH3BOX line 1:␤------> [32m::F'ing := Failure; my F'ing [31m$F'er is F'd;[0m␤FAILED 00:02 35m␤»

[17:34] <[particle]nyc> seems you'd want to "return {whatever-type-i-should-be-returning} but F'd"

[17:34] <[particle]nyc> ...frequently, so it may deserve a shortcut

[17:34] <azawawi> PhatEddy: strawberry + mingw here 

[17:34] <moritz_> std: ::F'ing ::= Failure; my F'ing $F'er is F'd;

[17:34] <p6eval> std 26706: OUTPUT«##### PARSE FAILED #####␤In "my" declaration, typename F'ing must be predeclared (or marked as declarative with :: prefix) at /tmp/gakuGGANGC line 1:␤------> [32m::F'ing ::= Failure; my F'ing [31m$F'er is F'd;[0m␤FAILED 00:02 35m␤»

[17:35] <TimToady> std: subset F'ing of Failure; my F'ing $F'er is F'd;

[17:35] <p6eval> std 26706: OUTPUT«ok 00:02 36m␤»

[17:35] <pmichaud> That's just F'd.

[17:36] <[particle]nyc> Mo'Fo, the new exception-based web framework for perl 6

[17:36] <pmichaud> we might be careful with that -- Morrison and Forrestor might come after us.

[17:36] <pmichaud> *Forrester  (grrr!)

[17:36] <jnthn> Or the Mozilla Foundation. ;-)

[17:36] *** kaether left
[17:36] <dalek> rakudo: ee7d456 | jnthn++ |  (2 files):

[17:36] <dalek> rakudo: P6Invocation should become more Iterator-ish.

[17:36] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ee7d456d0c5351aa9293d84fb39bda25738632a4

[17:36] <dalek> rakudo: 663cde0 | jnthn++ | src/ (2 files):

[17:36] <dalek> rakudo: Refactor indirect method dispatch, and make $x.@foo form do something along the lines of what we'll eventually want it to.

[17:36] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/663cde070f66f97f77296ae200f25007183f96b1

[17:37] <[particle]nyc> my $typing is F'd;

[17:37] <skids> E'pic F'

[17:37] <moritz_> skids: that's a parse error ;-)

[17:37] <TimToady> std: E'pic F'

[17:37] <p6eval> std 26706: OUTPUT«##### PARSE FAILED #####␤Syntax error (two terms in a row?) at /tmp/2H2iX1Azy8 line 1:␤------> [32mE'pic F[31m'[0m␤    expecting any of:␤ POST␤   argument list␤      infix or meta-infix␤      infix stopper␤    postfix␤        postfix_prefix_meta_operator␤       standard

[17:37] <p6eval> ..stopper␤       statement modifier loop␤    ...

[17:38] * ruoso continues to pester pmichaud...

[17:39] <ruoso> pmichaud, I've just pushed a last version...

[17:39] <ruoso> it already parses...

[17:39] <ruoso> but i'm failing to get the captures...

[17:39] <pmichaud> azawawi/others:  I suspect that the point where PARROT_REVISION was bumped in 9a1cacdc is the beginning of compilation problems under Win32 (more)

[17:40] <TimToady> sigh, *still* backlogging...

[17:40] <[particle]nyc> pmichaud: i agree. i think jonathan F'd up there.

[17:40] *** literal left
[17:40] <TimToady> I believe in victorian capitalization, Gentle Reader

[17:40] <pmichaud> my suggestion is to get a known version of rakudo before that (I suggest 4d7fe560), but try building it with the latest Parrot.

[17:40] <pmichaud> I suspect you'll get the same error.

[17:40] *** literal joined
[17:41] <TimToady> fouled up?

[17:41] <pmichaud> "failed up"

[17:41] <[particle]nyc> there's trouble with the parrot makefile when using nmake

[17:41] <moritz_> followed up?

[17:41] *** literal left
[17:41] <jnthn> What most likely happened is that the Parrot change happened, but we didn't bump our Parrot revision for a couple of days later.

[17:41] <[particle]nyc> ooh, "failing up" sounds like a good self-help book title

[17:42] <jnthn> I suspect it's whoever did the dynpmc changes that really failed up.

[17:42] <TimToady> What The Failure?

[17:42] <pmichaud> correct.

[17:42] <pmichaud> I also suspect there aren't any direct "dynpmc" changes.

[17:42] <[particle]nyc> cotto did dynpmc, i believe they were tested on strawberry

[17:43] <[particle]nyc> i tested fine on msvc

[17:43] <pmichaud> [particle]: I think those changes are in a branch, ye?

[17:43] <pmichaud> *yes ?

[17:43] <[particle]nyc> no, merged to trunk

[17:43] <jnthn> [particle]nyc: It seems it's just mingw

[17:43] <[particle]nyc> maybe that affects rakudo, if it wasn't modified to match something new?

[17:43] <[particle]nyc> strawberry uses mingw, no?

[17:43] <TimToady> std: sub infix:<the> {...}; *.WHAT the *

[17:43] <pmichaud> [particle]: I think PARROT_EXPORT has been removed recently.

[17:43] <p6eval> std 26706: OUTPUT«ok 00:03 36m␤»

[17:44] <pmichaud> (from a variety of functions)

[17:44] <jnthn> [particle]nyc: I saw fperrad asking about the patch in #parrot recently IIRC, and he builds on mingw

[17:44] <jnthn> (IIRC)

[17:44] <azawawi> [particle]nyc: yes, strawberry+mingw

[17:44] *** literal joined
[17:45] *** kaether joined
[17:45] <pmichaud> does Parrot's "make test" do any testing of dynpmc building and linking?

[17:45] <[particle]nyc> pmichaud: it was removed from pmc2c

[17:45] <[particle]nyc> so vtable functions are no longer exported in pmc or dynpmc.

[17:45] <jnthn> They musta done a bit more than just rip that out.

[17:45] <jnthn> Otherwise it wouldn't work on MS VC++.

[17:46] <pmichaud> ISTR that one of the reasons we had to leave PARROT_EXPORT in was because otherwise things wouldn't link properly on certain Win32 compilers

[17:46] <jnthn> I don't know enough about mingw to know why it'd break that and not MS VC++ though.

[17:46] <[particle]nyc> there's runtime resolution of which vtable functions are needed, rather than compile time

[17:46] <jnthn> pmichaud: I believe they look up the vtable indirectly now.

[17:46] <[particle]nyc> ...when building pmc's.

[17:46] <pmichaud> jnthn: okay.

[17:46] <jnthn> pmichaud: Which would be a legit change, IMO.

[17:46] <pmichaud> Sure, I'm fine with that.

[17:47] <skids> X'pt, F'd, E'vt, C'tl, S'gl, N'n <-- just trying stuff on

[17:47] <jnthn> MS VC++ was certainly one of the compilers that did need PARROT_EXPORT before.

[17:47] <pmichaud> azawawi: just to verify, you've done "make realclean" in both the rakudo and parrot trees and then built from that?

[17:47] <pmichaud> azawawi: or even better, start from a completely fresh checkout...?

[17:47] <azawawi> pmichaud: yup i did that...

[17:48] <[particle]nyc> ...with no installed parrot

[17:48] <azawawi> pmichaud: im going to pull it out again on another directory

[17:48] <[particle]nyc> you're failing during link time, so it could be trying to link with an old libparrot

[17:49] <pmichaud> in particular, the link failures all appear (to me) to be the vtable functions.

[17:49] <[particle]nyc> yes

[17:50] <TimToady> maybe we should reserve X' for builtin types for X in A..Z

[17:50] <pmichaud> +1

[17:50] * skids thinks maybe spec-reserving idents { <[A-Z]> ' <ident> } ... 

[17:50] <[particle]nyc> X'kcd

[17:50] <[particle]nyc> why not <upper>?

[17:51] <[particle]nyc> or whatever the real unicode type is

[17:51] <[particle]nyc> s/type/class/

[17:51] <TimToady> Your code is Σ'd

[17:52] <pmichaud> I wonder if S'task, T'Pring, or any of those characters might complain, though.

[17:52] <skids> Sorry A..Z or is that S'ry?

[17:54] <[particle]nyc> I'm U'r M'n

[17:54] *** azawawi left
[17:55] *** azawawi joined
[17:55] *** azawawi left
[17:56] <TimToady> I'd think O'Reilly would really like Perl 6, except for the fact that we reserved his name...

[17:56] <TimToady> revenge for the camel :)

[17:57] <pmichaud> Otoh, at least O'Reilly is a valid identifier in Perl 6.  That's more than can be said for many languages.

[17:57] <skids> O'right  common usage F'

[17:57] <pmichaud> and we could reserve the O' section of the namespace for "really good documentation"

[17:57] <TimToady> std: F*d

[17:57] <p6eval> std 26706: OUTPUT«Undeclared name:␤      F used at 1 ␤Undeclared routine:␤   d used at 1 ␤ok 00:02 35m␤»

[17:58] *** scook0_ joined
[17:59] <pmichaud> ruoso: you're having difficulty getting the captures?

[17:59] *** azawawi joined
[17:59] *** Aisling left
[17:59] <pmichaud> It looks to me as though they should simply be in  $<subrx>

[17:59] <ruoso> pmichaud, I got a little further with that...

[17:59] <ruoso> now I need to be able to use a match as a capture

[17:59] *** Aisling joined
[17:59] <pmichaud> "use a match as a capture..."?

[18:00] <pmichaud> matches are already captures.

[18:00] *** scook0 left
[18:00] <ruoso> when I try to do self.run-action($<subrx>.ast, |$<subrx><rx>)

[18:00] <ruoso> it dies

[18:01] <moritz_> how so?

[18:01] <pmichaud> rakudo has no clue how to do  |$<subrx><rx>, afaik

[18:01] <ruoso> ah... right...

[18:01] <pmichaud> I know rakudo can do   |@array   and |%hash... but I think that's it for now.

[18:01] <ruoso> ok..

[18:01] <ruoso> so if I 

[18:02] <ruoso> my %a = $<subrx><rx>; my @a = $<subrx><rx>; foo(|@a, |%a);

[18:02] <ruoso> would that work?

[18:02] *** japhb joined
[18:02] <pmichaud> it might -- I'm not sure what will happen when $<subrx><rx> gets copied into %a.

[18:02] <pmichaud> my %a := ...    might work in that case.

[18:02] <moritz_> you'll need %(...) and @(...) before the assignment

[18:02] <moritz_> (presumably)

[18:02] <pmichaud> and yes, what moritz++ said.

[18:04] <pmichaud> time for me to grab some lunch, and then really focus on $otherjob for a while.

[18:16] *** abra left
[18:19] <PhatEddy> Given our discussion on catching the Null PMCs, might eval_perl6_lives_ok and eval_platform_lives_ok (no dies) be plausible additions to Test.pm.

[18:20] <PhatEddy> We could fake with string pattern matching for now ...

[18:20] <PhatEddy> (sorry about the m'ss'ng p'nct'ti'n)

[18:20] <azawawi> pmichaud, jnthn: ok, rakudo worked now on a fresh directory. must be something missing in realclean/clean. thx

[18:21] <pugs_svn> r26707 | lwall++ | slight braino

[18:21] *** LadyLunacy joined
[18:22] *** mizioumt joined
[18:27] <PerlJam> TimToady: heh, I was just about  to make that change.

[18:28] <szabgab> azawawi, fixed some Padre code in your Plugin

[18:32] <azawawi> szabgab: hi there :)

[18:32] <szabgab> yeah , hi me :-)

[18:33] <szabgab> when are we going to have a perl 6 debugger in Padre ?

[18:34] <ruoso> rakudo: sub bar { }; sub foo (*@_, *%_) { bar(|@_, |%_) }; foo();

[18:34] <moritz_> probably two days after we have the first Perl 6 debugger at all

[18:34] <p6eval> rakudo ee7d45:  ( no output )

[18:35] *** ZuLuuuuuu left
[18:39] <azawawi> pmichaud: after investigating the win32 build problem, it seems that neither clean/realclean delete generated files in rakudo pmc/

[18:39] *** mizioumt left
[18:40] <azawawi> pmichaud: after removing them; rakudo win32 build worked again.

[18:43] *** kaether left
[18:46] *** mtve joined
[18:46] *** desertm4x joined
[18:49] *** amoc left
[18:49] <ruoso> considerign I have a token like token { <a> <b> }

[18:50] <ruoso> is there a way for me to expand the captures of <b> as if it was inlined, instead of being a subtoken?

[18:50] <PhatEddy> I counted about 40 perl6 rts, either open or new, with Null PMC in the title. find/grep through t/spec turned up only one of the rt#s ...

[18:50] <moritz_> ruoso: $/ = $<b>

[18:51] <moritz_> or maybe $/ := $<b>

[18:51] <ruoso> but that would override <a> wouldn't it?

[18:51] <ruoso> (and rakudo doesn't like it, anyway)

[18:51] <moritz_> ah, now I know what you mean

[18:52] <moritz_> don't think you can

[18:52] <ruoso> hmm...

[18:52] <moritz_> (though I've wished for that functionality as well)

[18:52] <moritz_> <|b>

[18:53] <ruoso> maybe I could change the match in a closure after that...

[18:54] <moritz_> matches are immutable, notionally

[18:54] *** pmurias left
[18:58] *** Kisu left
[18:59] <pmichaud> azawawi: perhaps you could do a "make realclean" and let us know which files are getting left behind...?

[19:02] <azawawi> pmichaud: sure... but im new to git; how do i get a list of ignored files?

[19:05] <pmichaud> from a built copy of rakudo, just do 'make realclean' and then let us know which files are in the directory.

[19:05] <pmichaud> There are only six that are part of the repository.

[19:05] <pmichaud> mutablevar.pmc          p6invocation.pmc   perl6scalar.pmc

[19:05] <pmichaud> objectref_pmc.template  perl6multisub.pmc  perl6str.pmc

[19:05] <pmichaud> so any files outside of those six ought to be removed by 'make realclean'

[19:07] <Infinoid> That realclean issue sounds like http://rt.perl.org/rt3/Public/Bug/Display.html?id=65006

[19:07] <Infinoid> Does the patch attached to that ticket help?

[19:08] *** r0bby joined
[19:08] <ruoso> does rakudo support slurpy named arguments?

[19:08] <pmichaud> yes.

[19:08] <pmichaud> (slurpy named arguments: yes.)

[19:08] <pmichaud> (patch attached to ticket:  probably yes.)

[19:09] <pmichaud> I'll apply the patch in 65006, just a sec.

[19:09] <Infinoid> LylePerl++ for providing the patch

[19:09] <Infinoid> I had initially balked at how some lines had double-backslashes but others don't, but it turns out it's only needed for wildcards

[19:10] <pmichaud> same here.

[19:10] <azawawi> pmichaud: it seems that it is the issue im talking about. i am seeing *.o all over rakudo src/...

[19:10] <pmichaud> azawawi: agreed.

[19:10] <ruoso> pmichaud, what about mixing explicit named args with |%named?

[19:10] <pmichaud> ruoso: I'm pretty sure that works.

[19:10] <pmichaud> ruoso: it might not work if there are duplicate named args, though.

[19:11] *** mizioumt joined
[19:11] <ruoso> not the case... althought still not working...

[19:11] <moritz_> rakudo: sub a(:$b){say $x }; my %h = b => 5; say a(|%h)

[19:11] <p6eval> rakudo ee7d45: OUTPUT«Scope not found for PAST::Var '$x' in a␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:105)␤»

[19:11] <moritz_> rakudo: sub a(:$b){say $b }; my %h = b => 5; say a(|%h)

[19:11] <p6eval> rakudo ee7d45: OUTPUT«5␤1␤»

[19:11] <pmichaud> looks like it works :)

[19:12] <ruoso> rakudo: sub a(*%_) { say %_<a> }; my %h = a => 5; say a(|%h);

[19:12] <p6eval> rakudo ee7d45: OUTPUT«5␤1␤»

[19:12] <ruoso> rakudo: sub a(*@_, *%_) { say %_<a>; say @_[2]; }; my @a = 1,2,3; my %h = a => 5; say a(|@a, |%h);

[19:13] <p6eval> rakudo ee7d45: OUTPUT«5␤3␤1␤»

[19:13] <ruoso> hmm....

[19:15] <ruoso> rakudo: class A { method a(*@_, *%_) { say %_<a>; say @_[2]; } }; my $o = A.new; my @a = 1,2,3; my %h = a => 5; $o.a(|@a, |%h);

[19:15] <p6eval> rakudo ee7d45: OUTPUT«5␤3␤»

[19:16] <ruoso> rakudo: class A { method a($b, *@_, *%_) { say %_<a>; say @_[2]; } }; my $o = A.new; my @a = 1,2,3; my %h = a => 5; $o.a(9, |@a, |%h);

[19:16] <p6eval> rakudo ee7d45: OUTPUT«5␤3␤»

[19:16] <ruoso> I don't get it... it looks very much like this in the code I'm trying...

[19:16] <azawawi> ruoso: hi

[19:16] * ruoso pushing to github

[19:16] <ruoso> azawawi, hi

[19:17] <azawawi> ruoso: is development on mildew on github or something since im not seeing any activity here in pugs repo...

[19:17] <ruoso> azawawi, there has been a stall this week... but it's still in the pugs repo

[19:17] <ruoso> pmichaud, http://github.com/ruoso/faz/blob/14156c09b204235903478567fa06f10b8b17fd51/lib/Faz/Dispatcher.pm

[19:18] <ruoso> about line 66

[19:18] <azawawi> ruoso: cool :)

[19:18] *** nihiliad left
[19:18] <pmichaud> maybe try it with a binding for %named and @pos (instead of assignment) ?

[19:18] * jnthn takes a break from the -Opain task of refactoring p6object

[19:19] <ruoso> pmichaud, changing to assignment was already me trying something else ;)

[19:19] <ruoso> most importantly...

[19:19] <ruoso> the hash is there 

[19:19] <ruoso> in the say before the call

[19:19] <ruoso> but is empty in the say inside the method

[19:20] *** donaldh left
[19:20] *** donaldh joined
[19:20] <pmichaud> did you try defining run-action without the explicit *%_ ?

[19:21] <pmichaud> (since it gets one implicitly)

[19:21] * ruoso will try now

[19:21] <ruoso> no deal

[19:21] <pmichaud> are the positionals appearing as expected?

[19:21] <pmichaud> and just the named arguments missing?

[19:21] <ruoso> the @pos array is empty

[19:21] <ruoso> both sides

[19:22] <ruoso> but the explicit positional arg is there

[19:22] <ruoso> let me add a positional capture in the outermost token 

[19:24] <ruoso> positionals failing too

[19:25] <ruoso> I think the problem is with the slurpy

[19:25] <ruoso> getting the expected items in the run-action signature gets the value

[19:26] <ruoso> both named and positional...

[19:26] <pmichaud> checking... I think I might know what the problem is.

[19:26] <ruoso> hah

[19:26] <ruoso> got it

[19:27] <ruoso> if I use the slurpy with a name different than @_ and %_ it works

[19:27] <pmichaud> I think that rakudo currently thinks that any block with @_ and %_ gets those as arguments.

[19:29] <pmichaud> which is wrong -- it should be only blocks that otherwise have placeholder vars.

[19:30] *** desertm4x left
[19:30] <pmichaud> yes, looks like rakudo puts @_ or %_ as parameters to any block.

[19:30] <pmichaud> (in which they are used)

[19:32] <pmichaud> TimToady: is it only blocks containing placeholders that get the implicit @_/%_ when used?

[19:32] <pmichaud> for example:

[19:32] <pmichaud>     sub foo($x) { say @_.perl; }     #  does sub foo get a *@_ parameter?

[19:33] <pmichaud> clearly:   sub foo { say $^a.perl, @_.perl; }     #  sub foo($a, *@_) { ... }

[19:34] <ruoso> pmichaud, yes... this issue was raised before once...

[19:36] <ruoso> hmmm... just got into an unexpected issue...

[19:36] <ruoso> my action class has an "end" method

[19:37] <ruoso> and in order to allow customization via composition

[19:37] <ruoso> I call it by doing $action.*end

[19:37] <ruoso> it turns out that Any seems to have an "end" method as well (apparently from the list api)

[19:37] <ruoso> so it fails as it tries to call end there as well

[19:38] <baest> pmichaud: hello, in the tests in parrot/t/compilers/pge/perl6regex/rx*, is it possible to test for exceptions, like parse errors (thrown exceptions)

[19:38] <pmichaud> baest: yes -- see rx_syntax for some examples

[19:38] <ruoso> why does Any has a end method?

[19:38] <pmichaud> we look for a pattern instead of 'y' or 'n'

[19:38] <baest> pmichaud: cool, thanks

[19:39] <pmichaud> ruoso: are you asking why it's defined in S32?

[19:40] <ruoso> pmichaud, no... I'm asking why rakudo implements it

[19:40] <pmichaud> ...because it's specced in S32.  :-)

[19:40] <ruoso> is it?

[19:40] <ruoso> where?

[19:40] *** desertm4x joined
[19:40] <pmichaud> item end

[19:40] <pmichaud> our Any method end (@array: ) is export

[19:40] <pmichaud> Returns the final subscript of the first dimension; for a one-dimensional

[19:40] <pmichaud> array this simply the index of the final element.

[19:41] <ruoso> er... that is in the Array section...

[19:41] <pmichaud> (Containers.pod)

[19:41] <pmichaud> so is .elems, which we know is defined on Any.

[19:41] *** mizioumt1 joined
[19:41] <pmichaud> as are .keys, .values, .kv, .pairs, etc.

[19:42] <ruoso> I strongly feel we should rethink that

[19:42] <ruoso> pmichaud, but really... in Containers.pod it mention as part of the Array API, not Any

[19:43] <pmichaud> Yes, but we already know that some things mentioned as part of Array/List/Str/Num are really defined on Any.

[19:44] <pmichaud> so Containers.pod is known to be wrong in a few areas already.

[19:44] <ruoso> pardon me for my memory... but why do we know that?

[19:44] <moritz_> ruoso: you can't rely on type information in S29 and S32*

[19:44] <pmichaud> Because TimToady has declared it so

[19:44] <ruoso> TimToady, around?

[19:44] <pmichaud> specific known cases are .grep, .elems, and .join

[19:45] <pmichaud> 1.join(' ')   # "1"

[19:45] *** goksie joined
[19:45] <pmichaud> 3.elems   # 1

[19:45] <ruoso> btw... Faz works nwo

[19:46] <baest> pmichaud: I'll send the quote word literal patch for pge to you tomorrow. I have some time in the weekend, do you have any other stuff in the pipeline that I could do?

[19:46] <ruoso> it does the action processing completely... there are some issues that need to be solved in rakudo yet... (mostly contextual variables)

[19:46] <pmichaud> I'm not arguing that .end _should_ remain part of Any; I'm just saying that that's how Rakudo has been consistently interpreting the spec, except in places where it obviously makes little sense  

[19:46] *** ungluecksfee joined
[19:46] <pmichaud> I started working on contextuals this morning... should have it done on Friday.

[19:46] *** mizioumt left
[19:46] <pmichaud> (Would be done sooner but $otherjob commands my time today/tomorrow)

[19:47] <ruoso> pmichaud, I see... but I've just got at this point in a behavior that really scared me out

[19:47] <ruoso> $foo.*bar is a good way of implementing plugins by composition

[19:47] <moritz_> I know one more (small) PGE bug... ~ reports nonsense in the error message if the terminator is not a literal

[19:47] *** hercynium joined
[19:47] <moritz_> rakudo: 'a' ~~ /~ a [b]/

[19:47] <p6eval> rakudo ee7d45:  ( no output )

[19:48] <moritz_> rakudo: 'a' ~~ /~ a [b]/ || say $!

[19:48] <p6eval> rakudo ee7d45: OUTPUT«Use of uninitialized value␤␤»

[19:48] <moritz_> uhm, where can I find the error message?

[19:49] <ruoso> I realised we've been too tolerant on what should be part of the Any API...

[19:49] <ruoso> and $foo.*bar will suffer a lot from that

[19:49] <pmichaud> ruoso: I'm open for changes or clarifications to the spec, that's for sure.

[19:49] <ruoso> I think that's something we weren't taking into perspective

[19:50] <pmichaud> more particularly, we really ought to start updating S32 with the things we do "know" already.

[19:50] <pmichaud> like eliminating type constraints when they really shouldn't be there.

[19:50] * moritz_ is also scared by the shear number of methods in Any

[19:50] * ruoso renaming end to finalize in Faz in the meanwhile

[19:51] * ruoso s/finalize/finish/

[19:54] <baest> moritz_: looks something I should be able to do, but I'm not sure that I understand what the problem is

[19:54] <ruoso> it's cool how Perl 6 makes some things so damn easy...

[19:54] <pmichaud> baest: I don't know of many tasks off the top of my head

[19:54] <ruoso> Faz almost reimplements the core of the Catalyst framework

[19:54] <moritz_> baest: and I can't demonstrate it because I don't see how the error message can be made available

[19:54] *** nihiliad joined
[19:55] <pmichaud> moritz_: you're seeing an error message somewhere, yes?

[19:55] <pmichaud> so a sample rakudo program would demonstrate it, even if p6eval won't show it.

[19:55] <baest> pmichaud: ok, it might be you had something. I'll find something

[19:55] <moritz_> pmichaud: no. The point of ~ in regexes is that it should provide some good error messages...

[19:56] <moritz_> pmichaud: since it doesn't throw an exception anymore, I don't know how to access that error message

[19:56] <pmichaud> baest: I'll be eager to look at/apply the double-quote patch.

[19:56] <pmichaud> moritz_: oh, I thought you were referring to a parsing error in the regex.

[19:56] <moritz_> pmichaud: iirc TimToady said it should be in $!, if it's not a thrown exception

[19:56] <baest> pmichaud: cool, you have it, right?

[19:56] <pmichaud> rakudo:  'a' ~~ /~ a [b] [c]/

[19:56] <p6eval> rakudo ee7d45:  ( no output )

[19:56] <pmichaud> rakudo:  'ab' ~~ /~ a [b] [c]/

[19:56] <p6eval> rakudo ee7d45: OUTPUT«Unable to parse , couldn't find final a␤current instr.: 'parrot;PGE;Match;FAILGOAL' pc 3008 (compilers/pge/PGE/Regex.pir:477)␤»

[19:57] <moritz_> ah

[19:57] <moritz_> I got that wrong somhow

[19:57] <pmichaud> it needed a 'b' to match.

[19:57] <moritz_> rakudo: 'ab' ~~ / ~ [a] b c /

[19:58] <pmichaud> it's easier to see with

[19:58] <p6eval> rakudo ee7d45: OUTPUT«Unable to parse , couldn't find final [␤current instr.: 'parrot;PGE;Match;FAILGOAL' pc 3008 (compilers/pge/PGE/Regex.pir:477)␤»

[19:58] <pmichaud> rakudo: 'abc' ~~ / a ~ c b /

[19:58] <p6eval> rakudo ee7d45:  ( no output )

[19:58] <pmichaud> rakudo: 'ab' ~~ / a ~ c b /

[19:58] <moritz_> baest: that's the error message I mean

[19:58] <p6eval> rakudo ee7d45: OUTPUT«Unable to parse , couldn't find final c␤current instr.: 'parrot;PGE;Match;FAILGOAL' pc 3008 (compilers/pge/PGE/Regex.pir:477)␤»

[19:58] <moritz_> baest: it says couldn't find final [

[19:58] <baest> pmichaud: the double-quote patch. I think I did send it to you, but I'm not sure

[19:59] <pmichaud> baest: oh yes, you did.  I meant to say I'm eager to see the quote word literal patch (sorry!)

[19:59] <moritz_> ie the first character of the regex to be matched, even if it's not a literal

[19:59] *** azawawi left
[19:59] <pmichaud> yes, we ought to be able to fix that error message somehow.

[20:00] <moritz_> if it's not easy to extract a good target for the error message, it would be nicer to just say "couldn't find delimiter"

[20:00] <moritz_> or so

[20:00] <baest> pmichaud: oh, yes that was more difficult (and fun) :)

[20:00] <pmichaud> rakudo: 'ab' ~~ / a ~ 'c' b /

[20:00] <TimToady> phone

[20:00] <p6eval> rakudo ee7d45: OUTPUT«Unable to parse , couldn't find final 'c'␤current instr.: 'parrot;PGE;Match;FAILGOAL' pc 3008 (compilers/pge/PGE/Regex.pir:477)␤»

[20:00] <pmichaud> I'm guessing that [b] doesn't set its .to and .from properly.

[20:01] <baest> moritz_: ah, the wrong char is reported

[20:01] <moritz_> baest: exactly

[20:01] <ruoso> pmichaud, is there some way to Dump a regex in rakudo?

[20:01] <pmichaud> ideally I'd expect it to say  "...couldn't find final [b]..."

[20:01] <pmichaud> ruoso: _dumper($/)

[20:01] <baest> but shouldn't [b] just be 'b', that should be the same

[20:01] <pmichaud> oh wait

[20:01] <pmichaud> you said regex

[20:01] <pmichaud> no.

[20:01] <pmichaud> a regex is just a sub.

[20:02] <pmichaud> at execution time, it's already been turned into code.

[20:02] <ruoso> right... 

[20:02] <TimToady> nick and I are getting lonely

[20:02] <pmichaud> on my way

[20:02] <pmichaud> having to locate telephone apparti

[20:02] <pmichaud> apparati

[20:03] <moritz_> rakudo: 'ab' ~~ / ~ 'b' a c /

[20:03] <p6eval> rakudo ee7d45: OUTPUT«Unable to parse , couldn't find final 'b'␤current instr.: 'parrot;PGE;Match;FAILGOAL' pc 3008 (compilers/pge/PGE/Regex.pir:477)␤»

[20:03] <moritz_> rakudo: 'ab' ~~ / ~ (b) a c /

[20:03] <p6eval> rakudo ee7d45: OUTPUT«Unable to parse , couldn't find final (␤current instr.: 'parrot;PGE;Match;FAILGOAL' pc 3008 (compilers/pge/PGE/Regex.pir:477)␤»

[20:04] <baest> weird it says final. It wonder if it know it is the last one

[20:04] <baest> s/I/It/

[20:04] *** LadyLunacy left
[20:05] <pugs_svn> r26708 | lwall++ | [STD] better error message for 'for lines {...}'

[20:05] *** mizioumt1 left
[20:08] *** masak joined
[20:10] <masak> I won't stay long.

[20:11] <jnthn> oh noes!

[20:11] <masak> just thought I'd update Rakudo to chase the spec changes I introduced today.

[20:11] <jnthn> yay :-)

[20:11] <masak> (change the signature of .comb, implement .words)

[20:11] <masak> in fact, I did this already. :)

[20:11] <masak> took just under a minute.

[20:11] <masak> running spectests now.

[20:13] *** ejs joined
[20:13] *** kaether joined
[20:13] <masak> ok, t/spec/S32-str/comb.t is going to break badly.

[20:13] <masak> maybe I should just rename it words.t :P

[20:13] * jnthn -> nom, bbs

[20:14] <baest> moritz_: it looks like the ~ actually upsets the PGE parsing of the regex. I'll be happy to take a look at it in the weekend if nobody beats me to it

[20:14] *** mizioumt joined
[20:15] * baest is off

[20:20] <ruoso> masak, hmm... you're not on #november-wiki...

[20:21] <ruoso> I just sent you a message there ;)

[20:21] *** pmurias joined
[20:21] <masak> ruoso: I'm only partially here, that's why...

[20:22] <pmurias> ruoso: do you use a debugger when working on smop?

[20:22] <ruoso> pmurias, ddd

[20:22] <ruoso> or gdb if the problem is not so hard

[20:31] <Tene> pmichaud: will i be stepping on any toes if i work on refactoring rakudo's trait handling to get it up to spec?  or did you do that already?

[20:31] * Tene git log

[20:32] <moritz_> Tene: more likely jnthn will do

[20:32] * Tene nods.

[20:35] *** goksie left
[20:38] *** Jedai joined
[20:40] <pmichaud> Tene: I think it's not too far away from spec now.  We have to consider how we want things like 'readonly', 'rw', etc. to work.

[20:40] <pmichaud> but I'm fine with aiming to bring it closer to spec.

[20:41] <pugs_svn> r26709 | masak++ | [S32-str]

[20:41] <pugs_svn> r26709 | masak++ | * changed comb.t to new specced signature

[20:41] <pugs_svn> r26709 | masak++ | * added words.t which partially takes comb's place

[20:41] <jnthn> We need some parsing improvements to be able to parse multi trait_auxiliary:is

[20:41] <pmichaud> that may actually happen soonish (like, within ~10 days)

[20:41] <jnthn> I wasn't planning to hack on traits stuff for a copule of weeks myself...

[20:41] <pmichaud> I'm rapidly wanting to define builtins in p6.

[20:41] <jnthn> Sure.

[20:41] <jnthn> That'd be nice. :-)

[20:41] <pmichaud> and parsing things like "trait_auxiliary:is" would be part of that.

[20:42] *** bacek left
[20:43] <moritz_> rakudo: multi trait:auxiliary:<is> { }; say "alive";

[20:43] <p6eval> rakudo ee7d45: OUTPUT«Malformed routine definition at line 1, near "trait:auxi"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[20:43] <dalek> rakudo: a40974a | jnthn++ | src/ (2 files):

[20:43] <dalek> rakudo: Use getinterp instead of new ParrotInterpreter to improve performance.

[20:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a40974aa13b5a59249c498f5513f4621276cf5fd

[20:43] <dalek> rakudo: 45ddf59 | jnthn++ | src/builtins/ (2 files):

[20:43] <dalek> rakudo: Use getinterp instead of new ParrotInterpreter to improve performance (part 2...missed some!)

[20:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/45ddf592a2e700125c852b55f5c93fd119297b91

[20:43] <moritz_> rakudo: multi trait_auxiliary:<is> { }; say "alive";

[20:43] <p6eval> rakudo ee7d45: OUTPUT«Malformed routine definition at line 1, near "trait_auxi"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:86)␤»

[20:44] <moritz_> masak: it's nice to write builtins in Perl 6, no? ;-)

[20:45] <masak> moritz_: surprisingly painless. :)

[20:45] <moritz_> aye ;-)

[20:45] * pmichaud squirrels away that quote for future use.  :-)

[20:45] <ruoso> writing everything in Perl 6 is surprisingly painless

[20:46] <pmichaud> painless for *some*  :-)

[20:46] <ruoso> I'm still surprised how easy it was to get Faz running from some sketches...

[20:46] <masak> ruoso: but it takes some time to write everything.

[20:46] <masak> std: macro f { '1 + 1' }; say f()

[20:46] <p6eval> std 26709: OUTPUT«ok 00:02 36m␤»

[20:46] <literal> Faz?

[20:47] <ruoso> http://github.com/ruoso/faz/tree/master

[20:47] <masak> std: quasi { say "foo" };

[20:47] <p6eval> std 26709:  ( no output )

[20:48] <masak> TimToady: ^

[20:48] <masak> why didn't it say "ok"?

[20:48] * mberends grabs the proto pumpkin while masak's not looking

[20:48] <masak> mberends: just make sure to pull, 's all.

[20:48] <Su-Shee> how do I say perl 5's wantarray in perl 6?

[20:49] <jnthn> You don't.

[20:49] <masak> mberends: I made a commit minutes ago.

[20:49] <dalek> rakudo: 35c6746 | masak++ | src/setting/Any-str.pm:

[20:49] <dalek> rakudo: [setting/Any-str] implemented .words

[20:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/35c6746483387f34dc0471ac04b6038abea048af

[20:49] <dalek> rakudo: 6b962c2 | masak++ | src/setting/Any-str.pm:

[20:49] <dalek> rakudo: [setting/Any-str] changed signature of .comb

[20:49] <dalek> rakudo: ...chasing earlier spec change today.

[20:49] <TimToady> std: ;

[20:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6b962c26975cead19d71ffba0c5fd44e55d47367

[20:49] <dalek> rakudo: 615936e | masak++ | t/spectest.data:

[20:49] <p6eval> std 26709: OUTPUT«ok 00:02 34m␤»

[20:49] <dalek> rakudo: [spectest.data] added S32-str/words.t

[20:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/615936e4206945aba1c73fa6e8428e049786f4d6

[20:49] <masak> my work here is done.

[20:49] <masak> good night, peeps.

[20:49] <pmichaud> masak++

[20:49] <jnthn> Su-Shee: There's no wantarray kinda thing in Perl 6.

[20:49] <jnthn> Su-Shee: Instead, you return something that behaves the right way in different contexts.

[20:49] <masak> dalek reports commits out of order!

[20:49] <masak> dalek--

[20:50] *** masak left
[20:50] <TimToady> hmm, works okay here

[20:50] *** desertm4x left
[20:50] * jnthn brb

[20:51] <TimToady> std: quasi { say "foo" };

[20:51] <p6eval> std 26709: OUTPUT«ok 00:04 40m␤»

[20:51] <TimToady> must've been recompiling or something

[20:52] <ruoso> TimToady, I've just (about an hour ago) hit a design issue in the API

[20:52] <moritz_> TimToady: it did report it as a pass

[20:52] <moritz_> TimToady: just obscured by dalek

[20:52] <TimToady> no, that was me

[20:53] <TimToady> his explicitly said (no output)

[20:53] <moritz_> ah

[20:53] <moritz_> before the ;

[20:53] <ruoso> TimToady, basically... the Any API is too big, and causing unexpected effects when using $foo.*bar (backlog for more details)

[20:54] * ruoso throws the issue in the airs and throws himself out of the chair in order to go home...

[20:54] <pmichaud>  start of relevant backlog:  item end

[20:54] <pmichaud> our Any method end (@array: ) is export

[20:54] <pmichaud> Returns the final subscript of the first dimension; for a one-dimensional

[20:54] <pmichaud> argggh

[20:54] <pmichaud> sorry

[20:55] <pmichaud> start of relevant backlog: http://irclog.perlgeek.de/perl6/2009-05-06#i_1123715

[20:55] <TimToady> I think C<hides> was invented to stop .* propagation

[20:55] <ruoso> hmmm... that's a new one to me

[20:56] <TimToady> classes intended to be used with .* have to be specially written anyway

[20:58] <ruoso> so all methods in Any have this "hides" thing?

[20:58] <pmichaud> I would think that a derived class would use <hides> to obscure the ones in Any.  (Haven't read the spec... reading now.)

[20:59] <TimToady> or Any is marked "is Hidden"

[20:59] *** iblechbot left
[21:00] <TimToady> afk &

[21:00] <ruoso> class Action hides Any ?

[21:00] <pmichaud> Yes.

[21:00] <ruoso> but what if Action is a Role

[21:00] <ruoso> is role Action hides Any still valid?

[21:01] *** km2 left
[21:01] * ruoso really decommute &

[21:01] *** ruoso left
[21:08] *** ungluecksfee left
[21:15] *** Whiteknight joined
[21:20] *** skids left
[21:22] *** donaldh_ joined
[21:23] *** pmurias left
[21:33] *** ejs left
[21:39] *** hercynium left
[21:40] *** Su-Shee left
[21:41] <TimToady> in any case the base class for a .* method should probably use 'lastcall' in that final method, which would prevent propagation into Any

[21:41] <TimToady> (it's possible that should be "is lastcall" as a trait on the method so it can return normally)

[21:42] <jnthn> TimToady: Did you see my question earlier about .* and an explicit candidate list?

[21:47] <TimToady> it just calls them all till "lastcall" suppresses the rest

[21:49] <jnthn> OK, but suppose I have

[21:49] <jnthn> class A { method m { } }; class B is A { method m { nextsame } }

[21:50] <jnthn> my $x = B.new; my @cands = $x.WALK(:name<m>);

[21:50] <jnthn> $x.*@cands();

[21:50] <jnthn> How many times is m in class A called?

[21:50] <jnthn> That is, does the "nextsame" in B's method m consume one of the candidaets in the "iterator"

[21:51] <jnthn> And thus when we fall back into the .* dispatcher it sees that there is nothing left?

[21:52] <TimToady> it's erroneous to mix .* and "next"

[21:52] <jnthn> Oh?

[21:52] <jnthn> OK.

[21:53] <TimToady> as I said earlier, you have to write your methods specially to use .*

[21:53] <TimToady> it's not transparent

[21:53] <jnthn> OK, so .* does not give nextsame etc a candidate list to work with, so it's an error.

[21:54] <TimToady> it could still mean something

[21:54] <TimToady> but it would mean "skip this iteration and don't return a value in the list"

[21:54] <TimToady> next means "I'm not here"

[21:54] <jnthn> Hmm.

[21:55] <TimToady> so it's not erroneous in that sense, I guess

[21:55] <jnthn> That's a tad trickier to handle, but do-able I guess.

[21:55] <jnthn> What about if I do

[21:55] <jnthn> $x.m()

[21:55] <TimToady> it's just a different dispatcher loop without a last

[21:55] <jnthn> In the above example.

[21:56] <jnthn> I didn't say there was a list of candidates to call here.

[21:56] <TimToady> has a last in the dispatcher's loop after first success

[21:56] <TimToady> there's always potentially a list of candidates for a method call

[21:56] <TimToady> if there are parent classes

[21:56] <jnthn> OK, that's what I'm getting at

[21:56] <jnthn> So with class A { method m { } }; class B is A { method m { nextsame } }

[21:56] <TimToady> .@foo overrides that list

[21:56] <jnthn> my $x = B.new; $x.m;

[21:57] <jnthn> Then the nextsame will call m in A?

[21:57] <jnthn> Or rather, defer to...

[21:57] <TimToady> yes

[21:57] <jnthn> OK, I understand that bit then. :-)

[21:57] <TimToady> but if you call it .@foo, it defs to the next one in @foo

[21:57] <jnthn> Yes.

[21:58] <TimToady> whatever dispatcher it's in the middle of, that's the one it iterates

[21:58] <jnthn> And .$foo (where $foo is a Callable) just calls that, and a nextsame in that is an error because there's no next candidate?

[21:58] <TimToady> likely

[21:59] <jnthn> OK.

[21:59] <TimToady> arguably it's just a function call written as single dispatch

[21:59] <TimToady> but ."$foo" is symbolic, so calls A

[21:59] <jnthn> That just interpolates $foo as a string, right?

[21:59] <TimToady> yes

[22:00] <pmichaud> open question from scrollback, before I close my window where I was working on it....

[22:00] <pmichaud> 19:32 <pmichaud> TimToady: is it only blocks containing placeholders that get the implicit @_/%_ when used?

[22:03] <TimToady> which would you rather?

[22:04] <pmichaud> from a rakudo implementation perspective, it's -slightly- easier if we allow it for any signatured block.

[22:04] *** mikehh_ joined
[22:04] <pmichaud> but only very slightly.  User-level concerns would weigh stronger.

[22:05] <TimToady> I can see that { @_ } might be surprising occasionally, but it seems more consistent

[22:05] <TimToady> so I think I'm okay with that

[22:05] <pmichaud> well, I'm presuming the block has to have a signature of some sort before we get the magical @_

[22:05] <pmichaud> otherwise it's a simple lexical

[22:05] <TimToady> but does it autogen a sig like a placeholder?

[22:06] <pmichaud> I hope not.

[22:06] <pmichaud> Otherwise we end up with an inability to get to a sub's @_ from a nested block.

[22:06] <TimToady> that's what I meant when I said "surprising"

[22:06] <pmichaud> Oh.

[22:06] <pmichaud> My original question was presuming the block had some sort of other signature generator already in place.

[22:07] <TimToady> well, only placeholders do that so far, right?

[22:07] <pmichaud> Correct.

[22:08] <TimToady> but we could automatically allow autoslurpy of @_ and %_ on any existing sig

[22:08] <TimToady> if there isn't already a slurpy there

[22:08] <TimToady> -> { @_ } would work then

[22:08] <TimToady> but it still seems a bit chancey

[22:09] <TimToady> *@_ = OUTER::<@_> maybe

[22:09] <pmichaud> actually, I think that's the case that decides it for me (more)

[22:09] * moritz_ doesn't like -> { @_ }

[22:09] <pmichaud> -> $a, $b { @_ }

[22:09] <TimToady> wait, you can't default a slurpy :)

[22:09] <pmichaud> I'd expect the @_ to be the OUTER @_, and not an implicit *@_ on the pointy block.

[22:10] <TimToady> well, I guess we can restrict it to placeholders then

[22:10] <pmichaud> because then the pointy block would slurp up all of the values of the loop

[22:10] <pmichaud> if we had

[22:10] <pmichaud>    for @list -> $a, $b { @_ }

[22:10] <pmichaud> we'd only get one iteration.

[22:10] <pmichaud> oh, maybe not.

[22:10] <pmichaud> but you kinda get the idea.

[22:10] <pmichaud> @_ becomes a bit too magical in that case.

[22:10] <lambdabot> Maybe you meant: . ? @ v

[22:11] <TimToady> given our other talks about $a, $b, $c? I'd think it'd slurp all the args

[22:11] <pmichaud> right

[22:11] <TimToady> well, I gotto run away for a while

[22:11] <pmichaud> I'm wondering if a sub with a slurpy positional ends up with .count == Inf

[22:11] <moritz_> if I explicitly write I signature, I wouldn't like the idea of it getting messed with by some internal magic

[22:11] <TimToady> anything else hanging fire?

[22:11] <TimToady> moritz_: agreed

[22:11] <pmichaud> no, I just needed to know that one so I can add the correct fix to Rakudo.

[22:11] <TimToady> probably be back online later tonight

[22:12] <pmichaud> any other fires from me will have to wait until Friday, I suspect.

[22:13] <TimToady> driving to Santa Rosa &

[22:14] <jnthn> pmichaud: We have a test that looks like this:

[22:14] <jnthn> (for P6object)

[22:14] <jnthn>     obj = proto.'new'()

[22:14] <jnthn>     isa_nok(obj, 'P6Protoobject', objname)

[22:14] *** exodist left
[22:15] <jnthn> Oh, hmm, let me think how to ask this... :-)

[22:15] <pmichaud> okay to deprecate/change.

[22:15] <jnthn> Ok.

[22:15] <jnthn> I mean, everything is an instance of the Protoobject PMC now.

[22:15] <pmichaud> I don't think anything depends on that.  But it is nice to have some way to ask "are you a protoobject"

[22:15] <jnthn> $thingy === $thing.WHAT 

[22:16] <pmichaud> that's not exactly the same.

[22:16] <jnthn> or $thingy =:= $thing.WHAT 

[22:16] <jnthn> No, true.

[22:16] <pmichaud> there's not ever just one protoobject

[22:16] <pmichaud> Dog{ :name<fido> }   is still a "protoobject"

[22:16] <jnthn> Yeah, of course.

[22:16] <pmichaud> but it's not =:= Dog.

[22:17] <jnthn> True.

[22:17] <moritz_> uhm, =:= only queries containers, not types?

[22:17] <jnthn> I mean, I know how to make the information available.

[22:17] <jnthn> erm, rephrase

[22:17] <pmichaud> That's fine.  As long as there's a way to determine protoobject-ness, I'm happy.

[22:17] <jnthn> I know how to determine it cheaply (in the PMC)

[22:17] <jnthn> I just don't know the best way to make it available.

[22:18] <pmichaud> presumably we could expose it as a method or via some obscure vtable.

[22:18] <jnthn> not as a method, but as a vtable perhaps, yes.

[22:18] <jnthn> inspect_str is the obvious one.

[22:18] <pmichaud> yes, except "inspect" really worries me at times.

[22:18] <jnthn> Or get_pointer. You can do anything with get_pointer. ;-)

[22:18] <pmichaud> because of its putative "cloning semantics".

[22:19] <jnthn> That might be something we choose to fix in Protoobject.

[22:19] <pmichaud> Also, if what we have *isn't* a protoobject, I'd be a bit worried about running inspect_str on it.

[22:19] <jnthn> True.

[22:19] <jnthn> That may not work out so well.

[22:19] <jnthn> Hmm.

[22:19] *** mikehh left
[22:20] <jnthn> It needs to be some vtable thing I guess rather than a method.

[22:20] <pmichaud> So, is the Protoobject PMC analogous to P6protoobject or to P6opaque ?

[22:20] <jnthn> p6opaque

[22:20] <jnthn> There is no p6protoobject as such after this though.

[22:20] <pmichaud> I think I'd prefer it to _not_ be named Protoobject, then.

[22:20] <pmichaud> because Protoobject really meant something else.

[22:21] <jnthn> parrotopaque made most sense to me.

[22:21] <pmichaud> I hadn't quite made the connection that the PMC replacing P6protoobject would be the base class for all objects.

[22:21] <pmichaud> I like Parrotopaque

[22:21] <pmichaud> you can even capitalize the 'O' in that case, if you want.

[22:21] <jnthn> :-P

[22:21] <pmichaud> Parr0t0paque.

[22:21] <jnthn> Yeah, there's no separate proto-object thingy any more.

[22:22] <jnthn> There's just one thingy that is a proto by virtue of having no instance storage.

[22:22] <pmichaud> so how do we implement .ACCEPTS on proto-object thingies, then?

[22:22] <pmichaud> same way we do .defines and .Str ?

[22:22] <pmichaud> that feels.... messy.

[22:23] <jnthn> I can only see that we'd be able to intercept them.

[22:23] <pmichaud> I don't quite grok "intercept" in this case.

[22:23] <jnthn> It is, but I guess it's a dispatcher decision.

[22:23] <jnthn> Currently in the defined vtable method I do

[22:23] <pmichaud> You mean on every method dispatch to every object we'd be looking for special instances of protoobject thingies?

[22:24] <jnthn> Well, we'd be saying "is this a proto" first and only then doing it.

[22:24] <pmichaud> what would be saying that?

[22:25] <jnthn> The dispatcher in the meta-class probably should be. I'm fully expecting we'll cheat in the common case.

[22:25] <pmichaud> I'm having trouble seeing even the cheat.

[22:25] <pmichaud> But essentially you're saying the dispatcher has to be aware of all proto-object specific methods?

[22:26] <jnthn> Yeah. I'm not entirely sure I like that, but I don't see another way.

[22:26] <jnthn> Of course

[22:26] <pmichaud> I definitely don't like it.

[22:26] <jnthn> We don't have to look at the method name.

[22:26] <jnthn> It looks more like how I have defined.

[22:26] <jnthn>         Parrot_Protoobject_attributes *po = (Parrot_Protoobject_attributes*)PMC_data(SELF);

[22:26] <jnthn>         if (!PMC_IS_NULL(po->attrib_store))

[22:26] <jnthn>             return SUPER();

[22:26] <jnthn>         else

[22:27] <jnthn>             return 0;

[22:27] *** AzureStone left
[22:27] <jnthn> That is, if we have storage allocated, we're an instance, do whatever an Object would do.

[22:27] <pmichaud> I understand it at the vtable level, yes.

[22:27] <pmichaud> But I'm asking specifically about .ACCEPTS

[22:27] <jnthn> Otherwise, we're undefined.

[22:27] <jnthn> OK, in this case our find_method would looke like the above.

[22:28] <pmichaud> except we wouldn't return 0

[22:28] <jnthn> Apart from instead of "return 0" we'd say something like "look in this set of proto-specific methods"

[22:28] <jnthn> Plus in p6opaque we won't call SUPER() but instead we'll have the Perl 6 dispatcher right there (in the p6opaque/default metaclass version).

[22:28] <pmichaud> could those methods come from a Role or something like that?

[22:29] <jnthn> We could have a way of saying "use the methods from this role"

[22:29] <jnthn> (as the proto-fallback ones)

[22:29] <pmichaud> I'm a bit more comfortable with that.

[22:29] <jnthn> And it'd basically steal the role's methods hash.

[22:29] <jnthn> Essentially it comes the "proto-overrides" list.

[22:29] <pmichaud> Does Perl 6 have a way to ask an object "are you a type object"?

[22:30] <pmichaud> other than simply checking it for definedness?

[22:30] <jnthn> It's hand-wavey. There's the Abstraction role.

[22:30] <pmichaud> oh, type objects do Abstraction, yes?

[22:30] <jnthn> But sicne the proto-object is just meant to be, well, a not-so-defined normal object...

[22:30] <pmichaud> well, clearly the normal objects don't "do Abstraction"

[22:31] <jnthn> How exactly Abstraction fits in isn't so clear to me.

[22:31] <pmichaud> I still think that type objects (protoobjects) differ by a role of some sort.

[22:31] <pmichaud> Abstraction being the obvious case.

[22:31] <jnthn> They can lie about doing the Abstraction role easy enough. And that's probably the easiest way.

[22:32] <jnthn> We can't just go in-place mixing in to a proto-object though.

[22:32] <jnthn> The proto-object and the real objects today are different types so far as Parrot is concerned, and I don't think that's really the way things should be.

[22:33] *** mberends left
[22:33] <jnthn> (where real object = the instance of)

[22:33] <pmichaud> it sounds to me like a type object is ultimately something that .does(Abstraction) -- no matter how we internally cheat to get it that way.

[22:34] <jnthn> Not least because S12 says otherwise, but because even in writing the meta-class extra bits recently I've seen places where we're going to have to cheat elsewhere if we don'thave it like that.

[22:34] <jnthn> Yes, I agree.

[22:34] <jnthn> .does(Abstraction) being true is The Way.

[22:34] <pmichaud> it doesn't bother me that they're different types -- since they actually respond differently.

[22:34] <jnthn> It does bother me.

[22:34] <jnthn> I think it's going to cause us problems.

[22:35] <pmichaud> in the Parrot version of this, I think it should be   .does("abstraction")   

[22:35] <jnthn> I can make it that way.

[22:35] <pmichaud> in the same sense that Parrot currently has a "scalar" type

[22:35] <jnthn> *nod*

[22:35] <pmichaud> (and "array" and "hash")

[22:36] <pmichaud> then in the Rakudo version, we promote to checking for the Abstraction role

[22:36] <jnthn> *nod*

[22:36] <pmichaud> and the Abstraction/abstraction role(s) can then do the cheating to say "okay, are you _really_ an abstract object?"   and provide the alternate method definitions.

[22:36] <pmichaud> s/abstract object/type object/

[22:37] <jnthn> Yes.

[22:37] <pmichaud> because we have to overload not only .ACCEPTS, but also various postcircumfixes and lots of other things that are type-object-dependent

[22:37] <jnthn> Right.

[22:38] <jnthn> As you can imagine, this isn't the most -Ofun refactor. I'd not be doing this if I didn't think we really needed to.

[22:38] <pmichaud> anyway, for now I'm happy with    $I0 = does $P0, "abstraction"    as being the "are you a type object" test.

[22:38] <jnthn> OK, great.

[22:39] <pmichaud> for backwards compatibility, we might temporarily overload   VTABLE_isa to explicitly check for "P6protoobject" until we can get through a deprecation cycle.

[22:39] <pmichaud> (since non-protoobjects would obviously return false in that case.)

[22:39] <pmichaud> i.e., we can have a false P6protoobject class that hangs around for backwards compability until we can fully deprecate it.

[22:39] <pmichaud> I _hope_ not too many people have installed methods in P6protoobject.

[22:40] <pmichaud> (if they have, we could have our dispatcher check for those also for a while)

[22:40] <jnthn> I find it quite unlikely.

[22:40] <jnthn> Heh, we could go look up the methods in P6protoobject and use them as our abstraction ones...

[22:40] <pmichaud> Right

[22:40] <pmichaud> That might be a nice intermediate.

[22:41] <pmichaud> But deprecate it in favor of some other better-named role for the future.

[22:41] <pmichaud> (or alias it somehow)

[22:43] <jnthn> OK

[22:56] *** AzureStone joined
[22:56] <mizioumt> help /me

[22:58] <mizioumt> oops, sorry

[22:59] *** ruoso joined
[23:01] *** frew|work joined
[23:03] *** frew|wor1 left
[23:03] <jnthn> rakudo: say Int === Int

[23:03] <p6eval> rakudo 615936: OUTPUT«1␤»

[23:04] <jnthn> rakudo: say Int{ :Int(42) } === Int

[23:04] <p6eval> rakudo 615936: OUTPUT«1␤»

[23:04] <jnthn> Hmm.

[23:04] <jnthn> rakudo: say Int{ :Int(42) } =:= Int

[23:04] <pmichaud> I'm gone for the rest of the evening and most of tomorrow -- gotta finish my $otherjob stuff.

[23:04] <p6eval> rakudo 615936: OUTPUT«0␤»

[23:05] <pmichaud> See you all late tomorrow night, or Friday.

[23:05] <jnthn> pmichaud: OK, hope it goes smoothly.

[23:05] <pmichaud> Me too, although I think it will all go fine.

[23:05] <jnthn> :-)

[23:05] <pmichaud> later

[23:05] <jnthn> cu

[23:05] <jnthn> rakudo: say Int{ :Int(42) }.WHAT =:= Int.WHAT

[23:05] <p6eval> rakudo 615936: OUTPUT«1␤»

[23:08] *** donaldh_ left
[23:15] *** samlh joined
[23:15] *** payload joined
[23:16] <Infinoid> aa

[23:16] <Infinoid> (oops)

[23:17] <meppl> good night

[23:19] *** meppl left
[23:20] *** donaldh left
[23:20] *** donaldh joined
[23:26] *** hercynium joined
[23:30] *** Kyosuke_Kiryu joined
[23:33] *** Kyosuke_Kiryu left
[23:36] *** DemoFreak left
[23:53] <ruoso> jnthn, btw... the idea for the object to lie about .does(Abstraction) is interesting... I'm still unsure on how that relates to uninitialized values and autovivifiable objects...

[23:54] *** skids joined
[23:54] <ruoso> since an uninitialized object is a type of Failure, and failures are undefined as well

[23:54] <ruoso> which mean they don't have instance storage

[23:55] <jnthn> ruoso: definedness is not just about "doesn't have instane storage"

[23:55] <ruoso> what else is it about?

[23:56] <jnthn> It's up to the HOW how it chooses to dispatch .defined (if I remember my S12 correctly)

[23:56] <jnthn> Though at a more basic level I guess you can write a .defined method.

[23:56] <ruoso> yes... Object implements .defiend

[23:56] <ruoso> .defined

[23:56] <jnthn> Sure, but you can override it to do what you like.

[23:57] <jnthn> But this means .defined isn't a way really to say "is this a proto-object or not".

[23:57] <ruoso> that's my point...

[23:57] <ruoso> how do you say that?

[23:57] *** justatheory left
[23:57] <jnthn> Well, that's what the discussion was about. But I'm guessing "says is does the Abstraction" role could be an answer...

[23:58] <ruoso> right... you're just moving the question to someone else ;)

[23:58] <jnthn> Since type-y things are meant to.

[23:58] <ruoso> how do a object knows if it is a type object or not

[23:58] <ruoso> how does it decide to say true to .does(Abstraction)

[23:58] <jnthn> Oh, for *that* I'm just going off "does it have instance storage" for type objects.

[23:59] <ruoso> heh...

[23:59] <jnthn> I'm curious though how in smop you plan to handle methods that dispatch differently in the type object?

[23:59] <jnthn> e.g. 42 ~~ Int is very different from 42 ~~ 1

