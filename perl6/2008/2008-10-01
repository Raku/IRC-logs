[00:00] *** kulp left
[00:15] *** Aisling left
[00:17] *** Aisling joined
[00:21] *** mncharity joined
[00:23] *** ashleyb joined
[00:27] *** pochi left
[00:46] *** wknight8111 joined
[00:58] *** wolverian left
[00:59] *** PerlJam left
[01:01] *** dalek left
[01:01] *** pmichaud left
[01:02] *** Juerd left
[01:02] *** eternaleye_ left
[01:16] *** pugs_svnbot joined
[01:16] *** dalek joined
[01:16] *** Juerd joined
[01:17] <Juerd> Blown fuse

[01:18] <Juerd> I shouldn't have mentioned the high uptime earlier today

[01:19] <wknight8111> as soon as you say something like that, Murphy comes down from space to rub his law in your face

[01:20] <Juerd> Wish he'd done that sooner than 3 am

[01:24] *** justatheory left
[01:31] <mncharity> lol

[01:36] *** hercynium_ joined
[01:39] *** kanru left
[01:45] <pugs_svn> r22466 | putter++ | [elfish/on_sbcl] More box cleanup.  Better Hash design.  Added reordering of emitted CL code so a sub can be used above its decl.  Var mangling improved.  Misc.

[01:46] <pugs_svnbot> r22466 | putter++ | [elfish/on_sbcl] More box cleanup.  Better Hash design.  Added reordering of emitted CL code so a sub can be used above its decl.  Var mangling improved.  Misc.

[01:48] *** penk joined
[01:49] *** eternaleye_ joined
[01:54] <pugs_svn> r22467 | putter++ | [elf_h] IRx1_FromAST now uses the Match x.hash accessor, instead of p5-ish x{'hash'}.

[01:54] <pugs_svn> r22467 | putter++ | The resulting performance hit has not yet been measured.  If it's a problem, we'll revert, and add a kludge postcircumfix:<{ }> method to Match for on_sbcl..

[01:54] <pugs_svn> r22467 | putter++ | More "missing last required arg" fixes.

[01:54] <pugs_svnbot> r22467 | putter++ | [elf_h] IRx1_FromAST now uses the Match x.hash accessor, instead of p5-ish x{'hash'}.

[01:54] <pugs_svnbot> r22467 | putter++ | The resulting performance hit has not yet been measured.  If it's a problem, we'll revert, and add a kludge postcircumfix:<{ }> method to Match for on_sbcl..

[01:54] <pugs_svnbot> r22467 | putter++ | More "missing last required arg" fixes.

[01:54] <mncharity> nibbling away at it.

[01:56] *** mncharity left
[02:13] *** alester joined
[02:14] *** meppl left
[02:18] *** Ontolog left
[02:23] *** jhorwitz left
[02:24] *** ashleyb left
[02:29] *** wknight8111 left
[02:33] *** Ontolog joined
[02:40] *** alanhaggai_ joined
[02:44] *** justatheory joined
[02:55] *** alanhaggai left
[03:02] *** elmex_ joined
[03:06] *** elmex left
[03:06] *** elmex_ is now known as elmex

[03:22] *** sail0r joined
[03:23] *** hercynium_ left
[03:23] *** kanru joined
[03:27] *** pugs_svnbot left
[03:29] *** alanhaggai__ joined
[03:30] *** justatheory left
[03:30] *** sail0r left
[03:32] * diakopter killed pugs_svnbot

[03:32] <diakopter> permanently.

[03:33] *** drbean left
[03:45] *** alanhaggai_ left
[03:55] *** kanru left
[03:57] *** kanru joined
[04:05] *** sri_work left
[04:13] *** Bzek joined
[04:45] *** meppl joined
[04:57] *** alanhaggai__ left
[05:07] *** drbean joined
[05:16] *** Awatto joined
[05:17] *** Psyche^ joined
[05:20] *** meppl left
[05:31] *** Patterner left
[05:31] *** Psyche^ is now known as Patterner

[05:32] *** PerlJam joined
[05:45] *** alester left
[05:45] *** pugs_svn left
[05:46] *** pugs_svn joined
[05:54] *** azawawi joined
[06:02] <moritz_> diakopter++ # permantly killing stuff ;)

[06:09] *** japhb joined
[06:21] *** Ehtyar left
[06:27] *** eternaleye_ left
[06:29] <pugs_svn> r22468 | azawawi++ | [t/spec] Fudged S10-packages/import.t for rakudo

[06:36] *** ashizawa joined
[07:01] *** smtms left
[07:02] *** drbean_ joined
[07:02] *** broquaint left
[07:02] <pugs_svn> r22469 | azawawi++ | [t/spec] Moved LoadCounter.pm to t/spec/packages since it is needed by 

[07:02] <pugs_svn> r22469 | azawawi++ | S10-packages/require_and_use.t

[07:02] *** smg left
[07:04] *** smg joined
[07:04] *** rafl left
[07:05] *** rafl joined
[07:07] *** drbean__ joined
[07:07] *** smtms joined
[07:13] *** drbean___ joined
[07:14] *** drbean left
[07:20] *** drbean_ left
[07:22] <pugs_svn> r22470 | azawawi++ | [t/spec] Fudged S12-methods/indirect_notation.t for rakudo

[07:26] *** drbean__ left
[07:31] *** drbean___ left
[07:34] *** drbean___ joined
[07:40] *** drbean joined
[07:40] *** icwiener joined
[07:40] *** iblechbot joined
[07:45] *** drbean_ joined
[07:50] *** zamolxes left
[07:51] *** drbean__ joined
[07:51] *** drbean___ left
[07:53] <pugs_svn> r22471 | azawawi++ | [t/spec] Fudged S29-context/eval.t for rakudo

[07:56] *** drbean___ joined
[07:59] *** drbean left
[08:04] *** drbean_ left
[08:06] *** cosimo joined
[08:07] *** drbean_ joined
[08:09] *** drbean__ left
[08:12] *** drbean__ joined
[08:14] *** drbean___ left
[08:26] *** drbean_ left
[09:00] *** zamolxes joined
[09:12] *** drbean joined
[09:29] *** drbean__ left
[09:30] <azawawi> @seen bacek

[09:30] <lambdabot> I haven't seen bacek.

[09:31] <moritz_> lambdabot--

[09:31] <azawawi> moritz_: hi

[09:32] <moritz_> hi

[09:32] <azawawi> i've been looking at recent P6 RTs

[09:32] <azawawi> and im thinking of taking this one for a starter http://rt.perl.org/rt3/Ticket/Display.html?id=59476

[09:32] <lambdabot> Title: #59476: [TODO] Refactor Str.capitalize.

[09:33] <moritz_> I think Str.chop is easier as a start

[09:33] <moritz_> but .capitalize should work out as well

[09:34] <azawawi> perl6.exe on windows for parrot 0.7.1 is broken

[09:34] <moritz_> msvc, or cygwin?

[09:35] <azawawi> the one from http://sourceforge.net/project/showfiles.php?group_id=211372

[09:36] <moritz_> you should tell fperrad in #parrot (when he's present)

[09:36] <azawawi> will do...

[09:36] <azawawi> basically it has a fixed library path to his own dev env

[09:37] <moritz_> I think rurban is working on fixing stuff like that in his pdd30_install branch

[09:38] <azawawi> win32 parrot/perl6 releases are always bad

[09:38] <moritz_> time to change that!

[09:39] <azawawi> ;-)

[09:39] <moritz_> anyway, re Str.capitalize, patches welcome!

[09:39] * azawawi starts working on Str.* patches

[09:57] *** krunen joined
[09:58] *** zamolxes left
[10:07] *** Awatto left
[10:15] *** iblechbot left
[10:29] *** smtms left
[10:39] *** zamolxes joined
[10:51] *** iblechbot joined
[10:57] <azawawi> moritz_: http://rt.perl.org/rt3/Ticket/Display.html?id=59480 done...

[10:57] <lambdabot> Title: #59480: [TODO] Refactor Str.chop

[10:59] * moritz_ runs the tests

[11:05] <rakudo_svn> r31541 | moritz++ | [rakudo] simplified Str.chop. Patch by azawawi++

[11:08] *** alanhaggai joined
[11:08] <azawawi> moritz_: thx

[11:08] <moritz_> thank *you*

[11:09] * azawawi is now busy with RT #59476

[11:25] *** masak joined
[11:42] *** alanhaggai left
[12:12] *** icwiener left
[12:14] *** icwiener joined
[12:15] *** ashizawa left
[12:30] *** azawawi left
[12:31] *** tomyan joined
[12:35] *** zamolxes left
[12:43] *** penk left
[12:54] *** Lorn joined
[13:02] *** Bzek left
[13:04] *** sri_work joined
[13:11] *** wolverian joined
[13:13] *** debianLIVE joined
[13:15] *** cookys joined
[13:18] *** pmichaud joined
[13:35] <moritz_> perl6: my $x; say $x.defined

[13:35] <p6eval> pugs: OUTPUT[␤]

[13:35] <p6eval> ..rakudo 31543: OUTPUT[set_attr_str() not implemented in class 'Undef'␤current instr.: 'parrot;Failure;!exception' pc 8482 (src/gen_builtins.pir:5344)␤]

[13:35] <p6eval> ..elf 22471: OUTPUT[Can't call method "defined" on an undefined value at (eval 117) line 4.␤ at ./elf_f line 3861␤]

[13:38] <masak> elf--, rakudo-- # that's just stupid :)

[13:38] <moritz_> indeed ;)

[13:38] <masak> pugs++ # accordingly

[13:38] <moritz_> actually defined($x) works in rakudo

[13:38] <masak> that's a start

[13:39] <moritz_> perl6: my $x; say defined($x)

[13:39] <p6eval> elf 22471, pugs: OUTPUT[␤]

[13:39] <p6eval> ..rakudo 31543: OUTPUT[0␤]

[13:47] <diakopter> [OT] amazon ec2 adds windows VMs... \o/

[13:48] <rakudo_svn> r31544 | moritz++ | [rakudo] Convert some 'new Failure' instances to '!FAIL', as per RT #58646

[13:48] <rakudo_svn> r31544 | moritz++ | Patch courtesy by ronaldxs++

[13:49] *** azawawi joined
[13:51] <rakudo_svn> r31545 | moritz++ | [rakudo] add a file to spectest_regression, and restore alphabetical order

[13:56] <moritz_> rakudo: use Test; plan 1; my Int $x; isa_ok($x, Int);

[13:56] <p6eval> rakudo 31545: OUTPUT[Can't find ./Test in @INC␤current instr.: 'die' pc 12739 (src/gen_builtins.pir:7935)␤]

[13:56] <pmichaud> perl6:  say undef.isa(Int);

[13:56] <p6eval> elf 22471, pugs: OUTPUT[␤]

[13:56] <p6eval> ..rakudo 31545: OUTPUT[0␤]

[13:57] <pmichaud> perl6:  my $x = undef;   say $x.isa(Int);

[13:57] <p6eval> elf 22471, pugs: OUTPUT[␤]

[13:57] <p6eval> ..rakudo 31545: OUTPUT[0␤]

[13:57] <moritz_> since Bool is an Enum of int, the 0 stringification seems correct to me

[14:00] <masak> aye

[14:01] * moritz_ wonders if there's a test for that

[14:01] <masak> probably not.

[14:04] <pugs_svn> r22472 | moritz++ | [t/spec] tests for stringifying True and False (and add smartlink)

[14:04] <masak> moritz_++

[14:05] *** alester joined
[14:08] *** ashleyb joined
[14:12] *** barney joined
[14:17] *** alanhaggai joined
[14:17] <diakopter> karma moritz_ 

[14:18] <diakopter> @karma moritz_ 

[14:18] <lambdabot> moritz_ has a karma of 7

[14:18] <diakopter> @karma moritz

[14:18] <lambdabot> moritz has a karma of 175

[14:18] <moritz_> perlbot: karma moritz_

[14:18] <perlbot> Karma for moritz_: 79

[14:18] <moritz_> perlbot: karma moritz

[14:18] <perlbot> Karma for moritz: 1289

[14:18] <moritz_> I think lambdabot has stopped counting at some point

[14:19] <diakopter> while 1 { lambdabot-- }

[14:19] <moritz_> integer overflow

[14:20] <moritz_> erm, underflow ;)

[14:21] <masak> no, overflow.

[14:21] <masak> the sign doesn't matter

[14:21] <masak> underflow is for floating-point numbers

[14:21] <Tene> Juerd: tab-completion causes scary errors about missing fds on feather3

[14:22] <masak> uh oh.

[14:22] <Tene> Hmm.  There's no Bot::BasicBot on feather3 anymore

[14:23] * Tene installs.

[14:23] <Tene> some locale issues too

[14:27] <Tene> It's very difficult for me to type without trying to tab-complete.

[14:27] <Tene> did someone need a polyglotbot in #perl6de?

[14:28] <moritz_> #perl6de is dead, to the best of my knowledge

[14:28] <masak> long live #perl6de!

[14:29] <moritz_> I hung out there for about 4 months (together with bloonix and a few others), but we didn't really discuss anything

[14:30] <moritz_> now I answer the occasional Perl 6 questions in #perlde instead, everybody is happy and I have less open irssi windows ;)

[14:41] *** debianLIVE left
[14:44] *** TJCRI joined
[14:45] *** abra joined
[14:54] <rakudo_svn> r31547 | tene++ | [pct]

[14:54] <rakudo_svn> r31547 | tene++ | * Generate an exception handler for CONTROL_LOOP_NEXT exceptions in for loops

[14:54] <rakudo_svn> r31547 | tene++ | [perl6]

[14:54] <rakudo_svn> r31547 | tene++ | * Add a 'next' sub to throw CONTROL_LOOP_NEXT exceptions

[14:54] <rakudo_svn> r31547 | tene++ | [cardinal]

[14:54] <rakudo_svn> r31547 | tene++ | * Add a 'next' sub to throw CONTROL_LOOP_NEXT exceptions

[14:58] <masak> Tene++

[15:01] *** z80ASM joined
[15:02] <z80ASM> hi Larry ;)

[15:02] <z80ASM> timtowtdi

[15:04] *** masak left
[15:05] *** kanru left
[15:06] *** kanru joined
[15:09] <z80ASM> TimToady

[15:10] <pugs_svn> r22473 | moritz++ | [t/spec] simplified next.t a bit to use initialized variables; fudged for

[15:10] <pugs_svn> r22473 | moritz++ | rakduo.

[15:11] *** Bzek joined
[15:12] *** z80ASM left
[15:15] *** z80ASM joined
[15:33] *** ashleyb left
[15:34] *** abra left
[15:36] <rakudo_svn> r31548 | moritz++ | [rakudo] add tests for next to spectest_regression, Tene++

[15:37] *** smtms joined
[15:41] *** smg left
[15:43] *** z80ASM left
[15:49] *** tomyan left
[15:53] *** justatheory joined
[15:53] *** Bzek left
[15:58] *** gbacon left
[16:01] *** armagad joined
[16:01] *** gbacon joined
[16:22] *** Exodist joined
[16:22] <rakudo_svn> r31549 | pmichaud++ | [rakudo]: spectest-progress.csv update: 194 files, 4381 passing, 7 failing

[16:35] *** eternaleye_ joined
[16:38] *** masak joined
[16:42] <Juerd> 16:21 < Tene> Juerd: tab-completion causes scary errors about missing fds on feather3

[16:43] <Juerd> Tene: Can't reproduce that myself. Paste please

[16:44] <moritz_> Juerd: if you have some tuits... the links at http://www.parrotvm.org/svn/parrot/revision?rev=30851 return only empty pages

[16:44] <Juerd> No tuits whatsoever

[16:44] <Juerd> Sorry

[16:46] <azawawi> Juerd: Please type 'perl', space and then tab on feather3

[16:46] <Juerd> Oh, feather3

[16:46] <Juerd> It's there clearly in Tene's message but I didn't see it

[16:47] <Juerd> No problem for me

[16:47] <azawawi> Juerd: I think it happened after i safe-upgraded to unstable

[16:47] <moritz_> maybe just a broken /etc/bash_completion ?

[16:47] <Juerd> azawawi: Are you using an old screen session?

[16:47] <Juerd> Oh, I get it after loading /etc/bash_completion

[16:48] <Juerd> Apparently that's not in root's .bashrc

[16:48] <Juerd> I'd say the bash_completion is broken indeed.

[16:48] <Juerd> It shouldn't go looking for things that aren't there :)

[16:48] <moritz_> rm /etc/bash_completion; aptitude reinstall bash

[16:48] <Juerd> Go ahead; gotta go

[16:48] <azawawi> will do it

[16:48] * moritz_ doesn't have acccess to feather3

[16:51] <azawawi> moritz_: it works now... thx

[16:53] <moritz_> np

[16:56] <speckbot> r14583 | larry++ | Describe how assignment metaoperators initialize undefined lvalues.

[16:57] <Tene> I figured it was something like that.

[16:57] <masak> Tene: I've been trying to break the new 'next' feature, but no luck. :) Tene++

[16:58] <moritz_> masak: just use a while or loop statement

[16:58] <masak> rakudo: for { next } { say "O RLY?"; $_(); say "YES RLY!" } # even this works!

[16:58] <p6eval> rakudo 31550: OUTPUT[O RLY?␤]

[16:58] <masak> moritz_: oh, didn't try that :/

[16:58] <moritz_> masak: it seems to work only on for atm

[16:58] <masak> rakudo: while * { next }

[16:58] <p6eval> rakudo 31550: OUTPUT[No exception handler and no message␤current instr.: 'next' pc 12684 (src/gen_builtins.pir:7904)␤]

[16:59] <masak> hm. yes.

[16:59] <masak> Tene: why is that?

[17:00] <moritz_> I think it's the block generating code

[17:00] <masak> TimToady++ # notional "reduction" to an accumulator variable

[17:01] <pmichaud> the while loop doesn't implement next yet.

[17:01] <pmichaud> I could probably do that after lunch.  Also get   while $x -> $a { say $a; }   to work.

[17:01] <moritz_> pmichaud: you mean on PAST level?

[17:02] <pmichaud> moritz_: correct -- the code that PAST::Op 'while' nodes generates doesn't handle CONTROL_LOOP_NEXT exceptions yet.

[17:03] <moritz_> is the plan to change PCT, or to simply add a :handles_excpetion<CONTROL_LOOP_NEXT> or something along these lines?

[17:03] *** armagad left
[17:03] <pmichaud> change PCT so that all of the loops understand the control exceptions.

[17:03] <moritz_> ok

[17:04] <pmichaud> afk, lunch.

[17:05] <rhr> TimToady: s/autovivificatoin/autovivification/ in spec update

[17:07] <[particle]> rakudo: map { .say; .next } 1..3;

[17:07] <p6eval> rakudo 31550: OUTPUT[Statement not terminated properly at line 1, near "1..3;"␤␤current instr.: 'parrot;PGE::Util;die' pc 119 (runtime/parrot/library/PGE/Util.pir:82)␤]

[17:07] <[particle]> rakudo: map { .say; .next }, 1..3;

[17:07] <p6eval> rakudo 31550: OUTPUT[1␤Method 'next' not found for invocant of class 'Int'␤current instr.: '_block15' pc 157 (EVAL_13:58)␤]

[17:08] <[particle]> rakudo: map { .say; next }, 1..3;

[17:08] <p6eval> rakudo 31550: OUTPUT[1␤No exception handler and no message␤current instr.: 'next' pc 12684 (src/gen_builtins.pir:7904)␤]

[17:09] <masak> should &next work inside a map?

[17:09] <moritz_> don't think so

[17:09] <masak> it doesn't in Perl 5

[17:09] <masak> ha! so for loops and maps aren't synonymous!

[17:10] <moritz_> unless map() catches that exception

[17:10] <moritz_> dunno

[17:10] <[particle]> map is for

[17:10] <moritz_> so what should it return when next() is called? no item?

[17:11] <masak> [particle]: except that for doesn't return a value and map doesn't care for &next

[17:11] *** smg joined
[17:11] <moritz_> rakudo: until 0 { say "yes"; next; };

[17:11] <p6eval> rakudo 31550: OUTPUT[yes␤No exception handler and no message␤current instr.: 'next' pc 12684 (src/gen_builtins.pir:7904)␤]

[17:12] *** viklund joined
[17:18] <speckbot> r14584 | larry++ | typo from Bob Rogers++

[17:19] <TimToady> oh, rhr++ too :)

[17:21] *** kanru left
[17:21] <TimToady> masak: for is specced to return a value just like map

[17:22] <masak> TimToady: but not to catch &next calls?

[17:22] *** ryanc left
[17:23] <TimToady> why shouldn't map catch next calls?

[17:23] <TimToady> it's just a control exception

[17:23] *** ryanc joined
[17:25] *** eternaleye_ left
[17:26] *** kst` left
[17:26] *** ashleyb joined
[17:26] *** kst` joined
[17:26] <masak> TimToady: I didn't find anything about it in the specs. and Perl 5 doesn't catch next

[17:41] *** ruoso joined
[17:43] <ruoso> TimToady, er... my $foo; $foo *= 5; say $foo; does it print "5" or I did misunderstood the latest change in the spec?

[17:44] <moritz_> ruoso: it does. The infix:<*> operator knows its neutral element

[17:44] <moritz_> that's also specced $somewhere

[17:44] <ruoso> that's wildly unexpected... I should say...

[17:44] <masak> ruoso: aye, it prints 5

[17:44] <masak> I like it.

[17:45] <masak> and I don't think it's more unexpected than 0

[17:45] <moritz_> ruoso: not at all. Otherwise [*] wouldn't work properly with an empty list

[17:47] * ruoso doesn't really see how that's related...

[17:50] <moritz_> wait, the synopsis says "If you apply an assignment operator to a *protoobject*"

[17:50] <masak> aye

[17:50] <moritz_> so perhaps it only works for my Num $foo; $foo *= 5;

[17:50] <masak> but the new change also talks about uninitiated hash slots

[17:51] <masak> that should be about the same as non-typed undefined variables, methinks

[17:51] <moritz_> presumably my $x; fills $x with some kind of Object or Scalar proto object

[17:52] <masak> there is no Object object, but yes, presumably

[17:54] <TimToady> the Object object is what you used to think of as "undef" :)

[17:54] <masak> TimToady: ah.

[17:54] <masak> I sit corrected.

[17:54] <moritz_> so does my $x; $x *= 5; yield 5?

[17:54] <TimToady> yes

[17:54] <moritz_> without type declaration on $x

[17:54] <moritz_> good

[17:54] * masak exhales

[17:55] * moritz_ writes tests

[17:55] <masak> moritz_++

[17:55] <ruoso> while my $x; $x += 5; still yelds 5

[17:55] <moritz_> yes

[17:56] <masak> except that you can't write like that :)

[17:56] <TimToady> and ++ is semantically defined as +=

[17:56] <TimToady> += 1

[17:56] <TimToady> except for all the .succ and .pred stuff, which doesn't assume 1

[17:57] <moritz_> "except where it's not"

[17:58] <ruoso> I presume this is valid for plain "my %a; say %a<abc> + 1;"

[17:58] <pugs_svn> r22474 | moritz++ | [t/spec] tests for autovivification with assignment meta operators

[17:59] <moritz_> maybe assignment-metaops.t would have been the better test name

[17:59] <moritz_> s/test/file/

[17:59] <moritz_> not sure

[17:59] <TimToady> ruoso: I think that's a warning

[18:00] <ruoso> so this is just for the (something)= operators

[18:00] <TimToady> yes

[18:00] *** barney left
[18:01] <masak> makes sense.

[18:01] <ruoso> so it's the operator that checks for 'defined' and use the "neutral" value otherwise

[18:02] <ruoso> but "undef" still knows how to morph itself into other objects, to support array and hash autovivification...

[18:03] <ruoso> 'my $foo; $foo<abc> = 3;' turns $foo into a hash

[18:03] <TimToady> an outer container returns an autovivifiable protoobject in that case

[18:03] <TimToady> a bare undef can't morph in-place, of course

[18:03] <ruoso> alright... that specific kind of undefs can morph...

[18:04] <ruoso> like my %a; %a<a><b><c><d>

[18:04] <TimToady> but in general we need not tag rvalues with where they came from

[18:05] <TimToady> if it's known that %a<a><b><c><d> is in rvalue contexxt it can just propagate a non-autoviv undef

[18:05] <TimToady> which is likely cheaper to generate

[18:05] <ruoso> right... as an optimization...

[18:07] *** meppl joined
[18:07] <TimToady> but maybe delete could pessimize that and trace an element back to its container

[18:08] *** icwiener left
[18:08] <ruoso> one thing I'm still not really sure.. is what triggers autovivification... for hashes and arrays, the spec says the binding process triggers it...

[18:09] <ruoso> but what about other objects?

[18:09] <ruoso> in S12 it seems to imply otherwise...

[18:09] <ruoso> (binding and storing, of course)

[18:11] <TimToady> if you bind something to a writeable location, you have to ask the argument to make itself writeable

[18:11] <TimToady> and either it's intrinsically writeable already

[18:11] <TimToady> or it is a prototype with a closure

[18:11] <TimToady> and the closure does the autoviv

[18:11] <TimToady> I don't see why that restricts it to hashes and arrays

[18:12] <TimToady> except insofar as those are the basic types that already provide such protoobjects

[18:12] <TimToady> well, and scalars, in some circumstance

[18:12] <TimToady> s

[18:12] <TimToady> $a<b><c> can autoviv $a

[18:13] *** rindolf joined
[18:13] <ruoso> TimToady, in S12:2070 it shows an example where a method call autovivifies the object

[18:15] <TimToady> indeed

[18:16] <TimToady> which seems to demonstrate that invocants are rw

[18:16] <ruoso> hmm... that's getting even worse ;)

[18:17] <TimToady> self = new Dog;  :)

[18:17] <ruoso> TimToady, the problem is not replacing the invocant...

[18:17] <moritz_> not Dog.new?

[18:17] <masak> you can _replace_ self?

[18:17] <ruoso> because the protoobject is something in the middle between the type Dog and a defined Dog

[18:18] <ruoso> it's like a Dog soul ready to reincarnate...

[18:18] <ruoso> ;)

[18:18] <TimToady> well, maybe only if you explicitly declare the invocant rw

[18:18] <masak> rakudo: class A { method x { self = 2 } }; my $a = A.new; $a.x; say $a

[18:18] <p6eval> rakudo 31553: OUTPUT[2␤]

[18:18] <masak> yuck.

[18:18] <moritz_> scary.

[18:18] <TimToady> but the $dog.wag autoviv could be handled by the dispatcher outside of the method, perhaps

[18:19] <ruoso> TimToady, right... that's the point...

[18:19] <moritz_> rakudo: class A { method x { self = 2 } }; my $a = A.new; $a.x; say $a; say $a.WHAT

[18:19] <p6eval> rakudo 31553: OUTPUT[2␤Int␤]

[18:19] <ruoso> TimToady, Dog{ .name => 'Fido' } is something supported even without 'rw invocant'

[18:19] <masak> IMHO, declaring all arguments readonly but the invocant rw is a big mistake...

[18:19] <ruoso> all the initialization of the object presumes that

[18:20] <ruoso> the different stages

[18:20] <TimToady> the object can be rw without the invocant parameter being rw

[18:20] <ruoso> in p6opaque, it's like an object that was CREATEd but still not BUILD(t)

[18:20] <TimToady> our rw-ness is not deep

[18:21] <TimToady> well, just make it all work

[18:21] <ruoso> the problem is not with the autovivificatoin process at all

[18:21] * TimToady waves his hands around vaguely

[18:21] <ruoso> because it's just a matter of calling BUILD

[18:21] <ruoso> the problem is knowing *when* to do it

[18:21] *** abra joined
[18:22] <TimToady> the invocant of a constructor isn't the object to be built

[18:22] <TimToady> so I don't see a big problem

[18:22] <ruoso> for instance... .exists is a method

[18:22] <ruoso> why calling .exists doesn't autovivify it?

[18:23] <ruoso> while calling $foo.wag() does

[18:24] * ruoso . o O ( does it have to do with that magical "bvalue context" thingy? )

[18:25] * ruoso . o O ( 'bvalue' methods doesn't autovivify... .postcircumfix<{}> usually is a 'bvalue' method... )

[18:25] * ruoso . o O ( it really looks sane )

[18:26] <moritz_> don't look for sanity when you want to implement Perl 6 ;)

[18:26] <ruoso> moritz_, believe it or not, I do have a coherent model for implementing Perl 6 in my head ;) ;) ;)

[18:26] <TimToady> the question is to what extent the compiler has to know about bvalue methods

[18:27] * azawawi finishes RT #59476 (http://rt.perl.org/rt3/Ticket/Display.html?id=59476)

[18:27] <lambdabot> Title: RT Error

[18:27] <ruoso> TimToady, autovivification is something runtime should be aware... not the compiler...

[18:27] <ruoso> (except for marking explicit cases where it should not autovivify)

[18:27] <TimToady> s/compiler/optimizer/

[18:28] <ruoso> well... 'bvalue context' degreades to 'rvalue' or 'lvalue' too easily

[18:28] <TimToady> if you assume the default of rvalues always returning something with a backref to the container, then the optimizer can be conservative

[18:28] <azawawi> moritz_: 'Refactor Str.capitalize' is finished; could u please apply the patch?

[18:29] <moritz_> azawawi: I have to get some supper, then I can take a look

[18:29] <ruoso> TimToady, at this point I'm assuming the non-optimized version always is 'bvalue' (i.e. backref to the container)

[18:29] <TimToady> I can see situations where you might want to pass everything you can as bvalues so that you can get a better error message

[18:29] <azawawi> moritz_: thx

[18:30] <ruoso> TimToady, except on places it isn't at all (like methods not marked as rw)

[18:30] <TimToady> "bvalue by default" might be one of those pessimizations that turns out to support a disruptive technology

[18:30] <TimToady> on the other hand, it could easily blow up your performance

[18:30] * ruoso trust people that knows how to optimize things...

[18:31] * ruoso doesn't

[18:31] <TimToady> there's a sense in which parrot is already bvaluish with PMCs

[18:31] * ruoso thinks he knows how to leave room for that people to work, tho

[18:31] <ruoso> but very few methods need to be 'bvalue'

[18:32] <ruoso> .exists, .postcircumfix<{}>, .postcircumfix<[]>

[18:32] <ruoso> not many more...

[18:32] *** zamolxes joined
[18:32] <TimToady> and we can probably notice them by lexically scoped declaration somehow

[18:32] <ruoso> you mean, 'is bvalue'?

[18:33] <TimToady> $self is ref maybe?

[18:33] <ruoso> but it's not $self, but the return value of a method

[18:34] <TimToady> .exists is worried about $self, unlike .{}

[18:34] <ruoso> in .postcircumfix<{}>, it's the return of the method that is bvalue, not the invocant...

[18:35] <TimToady> but .{} also wants bvalue for the invocant

[18:35] <ruoso> in a sense, it does...

[18:35] <masak> what's a bvalue?

[18:35] <ruoso> and that's what makes it non-autovivication-trigger?

[18:35] <TimToady> and I think "is ref" may provide the clue

[18:35] <TimToady> rather, lazy autoviv trigger

[18:36] <TimToady> just give me a ref to the object and let me decide whether to autoviv

[18:36] <ruoso> masak, it's something not yet in spec... but it basically means, 'bind context' 

[18:36] <ruoso> TimToady, oh... that was not the path I was taking...

[18:36] <masak> oy, "not yet in spec" :) I'm dizzy enough from the things already in the spec...

[18:36] <ruoso> TimToady, I was thinking the dispatcher would decide to autovivify...

[18:37] <ruoso> TimToady, and it would not autovivify in 'bvalue' methods

[18:38] <TimToady> and I think a 'bvalue' method is maybe determined by the invocant's declaration

[18:38] <TimToady> where the unmarked case is the undeclared form

[18:39] <ruoso> right... although I still argue "$self is ref" is not really the thing... 

[18:39] <ruoso> because the autovivification won't CREATE another object,

[18:40] <ruoso> it will just BUILD the current protoobject

[18:40] *** abra left
[18:40] <ruoso> using the WHENCE

[18:40] <ruoso> TimToady, take a look at src-s1p/Object.pm inside smop repo...

[18:40] <ruoso> an autovivifiable object would be an object where only of "new" would be executed...

[18:41] <TimToady> right, it's notionally already a constructed object, only without actually

[18:42] <TimToady> (or we couldn't use it to define role values)

[18:42] <ruoso> s/only of "new"/only half of "new"/

[18:43] <ruoso> I always thought that was the meaning for the splitting of CREATE and BUILD

[18:44] *** Lorn left
[18:44] <TimToady> well, one of the meanings, perhaps, though CREATE and BUILD were not envisioned as a laziness mechanism

[18:45] <ruoso> heh... they are now ;)

[18:47] <TimToady> so you're saying that Foo{ a => 42 } is basically doing CREATE in the Foo role

[18:47] <TimToady> and it's the BUILD on that which would fail if the role is not instantiable

[18:48] <ruoso> yep

[18:48] <TimToady> makes some kind of sense

[18:48] <ruoso> actually BUILDALL...

[18:49] <ruoso> but it doesn't really matter

[18:49] <TimToady> so a role's repr could be "can't", whereas a class's repr would be P6opaque

[18:49] <TimToady> and a punned role/class could just use a role that can do P6opaque, really

[18:50] <TimToady> or maybe that's oversimple

[18:50] * ruoso parsing....

[18:50] * ruoso E_TOO_MANY_4LETER_WORDS

[18:50] <TimToady> probably worth generating the punned class from the role in any case

[18:50] *** eternaleye_ joined
[18:51] <ruoso> the protoobject repr has no direct relation with its instances repr... that's for sure...

[18:51] <ruoso> so Foo{ a => 42 } probably creates a p6opaque anyway

[18:52] <TimToady> but it need not commit to a representation, since it's just holding initializers

[18:52] <ruoso> I'd argue the syntatic construct allows the runtime to choose some repr

[18:53] <ruoso> (since there's no syntax to defining the repr of an autovivifiable object)

[18:54] <TimToady> but there's an api with a closure to call that returns something of a specific type

[18:54] <ruoso> which is used as the candidate in BUILDALL

[18:55] *** hercynium_ joined
[18:55] <TimToady> maybe, maybe not

[18:56] <ruoso> wait... 

[18:56] <TimToady> maybe we only feed it to BUILD for its arguments

[18:56] <ruoso> that's it...

[18:56] <TimToady> and we don't care

[18:56] <ruoso> see src-s1p/P6Meta.pm

[18:56] <ruoso> method bless

[18:57] <ruoso> BUILDALL accepts several protoobjects as positional arguments... that protoobjects should be used to initialize the object in each BUILD call

[18:58] <ruoso> S12:650

[18:59] <TimToady> yes, but there's no requirement that the protoobject have the representation of the object we're BUILDing

[18:59] <TimToady> though in some cases it would be convenient

[18:59] <ruoso> like when autovififying a hash entry

[19:00] *** meppl left
[19:00] *** Ontolog left
[19:00] *** ting left
[19:00] *** jfredett left
[19:00] *** clkao left
[19:00] *** [particle] left
[19:00] *** hcchien left
[19:00] *** allbery_b left
[19:00] *** zamolxes left
[19:00] *** ruoso left
[19:00] *** gbacon left
[19:00] *** Patterner left
[19:00] *** Juerd left
[19:00] *** literal left
[19:00] *** spinclad left
[19:00] *** nnunley left
[19:00] *** szbalint left
[19:00] *** Guest16015 left
[19:00] *** idemal left
[19:00] *** araujo left
[19:00] *** beppu left
[19:00] *** ewilhelm left
[19:00] *** obra left
[19:00] *** sunnavy left
[19:00] *** simcop2387 left
[19:00] *** rindolf left
[19:00] *** Torment left
[19:00] *** Southen left
[19:00] *** cxreg left
[19:00] *** xinming left
[19:00] *** jiing_ left
[19:00] *** avar left
[19:01] *** mncharity joined
[19:01] <TimToady> then calling the closure has to have the side effect of installing the key in the hash, as well as returning the arguments for the new object

[19:01] <mncharity> hi all

[19:01] <moritz_> hi

[19:01] <mncharity> I've just now updated http://perl.net.au/wiki/Elf .

[19:01] <lambdabot> Title: Elf - PerlNet

[19:03] <mncharity> TimToady: apropos the Wed weekly meeting, I note I/elf would appreciate community assistance on (1) modifying or forking the src/perl6 parser to tag its Match nodes with the name of the rule which generated them; and 

[19:04] <mncharity> (2) exercising STD.pm, either using (a) STD_blue with the current untagged parses, (b) STD_blue on new tagged parses from 1, or (c) rakudo.  Basically,

[19:05] *** ruoso_ joined
[19:05] <mncharity> a grammar/parser can't really be declared working until something is actually emitting from it - parse output is generally too hard to validate otherwise.

[19:05] *** zamolxes joined
[19:05] *** rindolf joined
[19:05] *** meppl joined
[19:05] *** ruoso joined
[19:05] *** gbacon joined
[19:05] *** Patterner joined
[19:05] *** Ontolog joined
[19:05] *** Juerd joined
[19:05] *** Torment joined
[19:05] *** literal joined
[19:05] *** ting joined
[19:05] *** clkao joined
[19:05] *** hcchien joined
[19:05] *** allbery_b joined
[19:05] *** jfredett joined
[19:05] *** [particle] joined
[19:05] *** xinming joined
[19:05] *** Southen joined
[19:05] *** araujo joined
[19:05] *** avar joined
[19:05] *** simcop2387 joined
[19:05] *** jiing_ joined
[19:05] *** sunnavy joined
[19:05] *** cxreg joined
[19:05] *** obra joined
[19:05] *** Guest16015 joined
[19:05] *** ewilhelm joined
[19:05] *** idemal joined
[19:05] *** spinclad joined
[19:05] *** nnunley joined
[19:05] *** szbalint joined
[19:05] *** beppu joined
[19:05] <mncharity> Ideal, from elf standpoint, would be for someone to get 

[19:05] <mncharity> drats.  ill timed partition.

[19:06] *** ruoso left
[19:06] *** ruoso joined
[19:06] *** ruoso left
[19:06] <mncharity> eh, both logs have it.  anyway,

[19:06] <ruoso_> TimToady, yes... that's what I had thought 

[19:07] <TimToady> I have a version of STD that does implicit {*} on method exit

[19:08] <TimToady> breaks macro defs though, so haven't checked it in yet

[19:08] <mncharity> If the mechanism of shaking down STD is a tagged STD_blue which elf can self-compile on, that would be shiny.

[19:08] <TimToady> so we could attach reduction actions soon now

[19:08] <mncharity> oooo, nifty

[19:08] <TimToady> my goal is to rewrite gimme5 in STD plus actions

[19:08] <pmichaud> TimToady: does the recent change to S03 mean that    my $x;  $x %= 3;  would cause $x to have the value 3?

[19:08] <TimToady> and then we can presumably translate a large subset of p6 to p5

[19:09] <ruoso_> pmichaud, the question you should ask is "which is the neutral value for the % operator"

[19:09] <TimToady> pmichaud: yes, though of course that's fairly nonsensical

[19:09] <mncharity> hmm... /me ponders...

[19:09] <pmichaud> ruoso_: S03 currently says the operator itself is dropped and it becomes simple assignment.

[19:09] *** ruoso_ is now known as ruoso

[19:09] <TimToady> I thought about calling prefix:<[op]> for the neutral value, but decided this was likely more basic

[19:10] <TimToady> and the reduction ops are likely defined in terms of op=

[19:10] <pmichaud> TimToady: and  my $x;  $x -= 3;   would cause $x to have 3 also?

[19:10] <mncharity> before pondering, the last bit of info was the tagging, etc, is something which, at my current level of effort, won't be needed for a couple of weeks.  back to pondering...

[19:10] <TimToady> ooh, that's a good one

[19:10] <pmichaud> (it's okay if the answers are 'yes', I'm just verifying)

[19:10] <TimToady> hmm

[19:10] <ruoso> my guess would be -3

[19:10] <pmichaud> also  $x--

[19:11] <ruoso> since the "neutral value" for sum and subtract is 0

[19:11] <pmichaud> ruoso: again, I'm just reading from the latest spec.  :-)

[19:11] <pmichaud> I'm not advocating -- just confirming.

[19:11] <moritz_> pmichaud: are you thinking that $x op= $y should just take $y if $x is undef?

[19:11] <ruoso> pmichaud, the thing is the "neutral" value... which is in the latest spce

[19:11] <TimToady> well, for a while I had it calling prefix:<[op]>()

[19:11] <pmichaud> moritz_: I'm simply saying what the latest spec says.

[19:12] <TimToady> maybe I'll go back to that

[19:12] <masak> pmichaud: I agree with moritz_. I, too, read it as -3

[19:12] <pmichaud> r14583 says:  +If you apply an assignment operator to a protoobject, it is assumed that

[19:12] <TimToady> it bothered me that the nullary reduce loses type info, though

[19:12] <pmichaud> +you are implementing some kind of notional "reduction" to an accumulator

[19:12] <pmichaud> +assignment is done instead.

[19:12] <pmichaud> +variable.  To that end, the base operator is dropped and a simple

[19:12] <TimToady> so maybe if there is a defined nullary reduce, we use that, otherwise assign

[19:12] <pmichaud> based on this reading of the spec,   $x -= 3   would result in $x being 3.

[19:13] <TimToady> that seems like a misfeature

[19:13] <pmichaud> I agree that it would be confusing.

[19:13] <masak> indeed

[19:13] <ruoso> oh... where did the "neutral" value thing came from?

[19:13] <pmichaud> in many ways I kinda prefer it when undef defaults to zero.

[19:13] <TimToady> on the other hand, [-] 3,4,5 gives the same semantics

[19:13] <pmichaud> my reasoning being that I don't have to memorize a list of operators to know what their default reduction is.

[19:14] <moritz_> pmichaud: that's not a general solution, because it doesn't work for strings and other types

[19:14] <masak> there's a lot of DWIM in default reductions

[19:14] <pmichaud> okay, defaults to empty string for string context, empty list for list context

[19:14] <ruoso> one could argue that coercing undef to number is an error...

[19:14] <pmichaud> i.e., roughly the same as p5 semantics.

[19:14] <TimToady> and then you have to special case the non-warnings like p5

[19:14] <TimToady> which I don't like

[19:15] <pmichaud> I don't mind if +=  doesn't generate  a warning.

[19:15] <pmichaud> it seems reasonable to assume that assigning to an undefined value doesn't cause a warning.

[19:15] <pmichaud> even if it's an "operator assignment"

[19:16] <ruoso> I think it's confusing... 

[19:16] <TimToady> sure but *= won't work if undef returns 0

[19:16] <ruoso> since most people read $a += $b as $a = $a + $b

[19:16] <pmichaud> it depends on what we mean by "work"  :-)

[19:16] <pmichaud> yes, that's a good point

[19:16] <pmichaud> my $a *= 5;   becomes more like   $a = [*] 5;     instead of $a = $a * 5;

[19:17] <TimToady> or $a = ([*]()) * 5

[19:18] <pmichaud> in some sense it's "easier"  (although that may just be "traditional")  that undef values are zero, empty string, false, or empty list depending on context (and not on operator)

[19:18] <moritz_> pmichaud: but that works only as long as you can't define new operators

[19:18] *** kane_ left
[19:18] <[particle]> so is $a = 5 something like $a = [] 5 ?

[19:19] <TimToady> :P

[19:19] <[particle]> :)

[19:19] <[particle]> because ::= is trouble then

[19:19] <pmichaud> if someone wants   %hash<key> *= 5;   to work, I'd write it as   %hash<key> = [*] 5;

[19:19] <pmichaud> er,

[19:19] <pmichaud> fap

[19:19] <pmichaud> if someone wants   %hash<key> *= 5;   to work, I'd write it as   %hash<key> = [*] %hash<key>, 5;

[19:19] <pmichaud> which I admit is icky.

[19:20] <moritz_> can you reduce that to %hash<key> [*]= 5? # *me ducks*

[19:20] <TimToady> and probably won't work either

[19:20] <mncharity> TimToady: any thoughts on how much calendar time until there's a running/working action-refactored STD?

[19:21] <TimToady> yes, "too much"  :)

[19:21] *** betterworld joined
[19:21] <mncharity> :)  :/

[19:21] <pmichaud> anyway, I'll leave it to others to hash out -- I just thought the current spec looked weird in the cases of %= and -= and the like.

[19:21] <TimToady> the action refactoring is not difficult

[19:21] <TimToady> I already have a _REDUCE method

[19:21] <TimToady> it just has to call somehting

[19:22] <mncharity> *groan*

[19:22] <TimToady> and my latest change merely makes _MATCHIFY call _REDUCE with an appropriate tag

[19:22] <mncharity> re "leave it to others to hash"

[19:23] <TimToady> but as I say, that broke my user-define operator installer

[19:23] <TimToady> and everyone wants their factorials...

[19:24] <TimToady> it might even be a trivial fix, just haven't had time

[19:24] <[particle]> i don't want the world, i just want your half.

[19:24] <mncharity> re time, understood.

[19:24] <pmichaud> I hate to propose another global, but perhaps a %*REDUCE  hash keyed by operator that says what the reduction value will be?

[19:25] <pmichaud> %*REDUCE<*> = 1

[19:25] <pmichaud> %*REDUCE<+> = 0

[19:26] <TimToady> why are you reinventing what is already specced in "Reduction operators"?

[19:26] <[particle]> hee

[19:26] <pmichaud> sorry, hadn't read that section yet :-|

[19:27] <[particle]> ESPECTOOBIG

[19:27] <TimToady> just call prefix:<[*]>()

[19:27] <pmichaud> right.

[19:27] <pmichaud> got it.

[19:27] <pmichaud> note to self:  read the whole section before saying anything.  :-)

[19:28] <pmichaud> 2nd note to self:  also a good idea to do an 'ack' on the whole synopsis directory, in case it's further described in another synopsis.

[19:28] <TimToady> I think maybe what we call is just prefix:<[op]>($x) where $x is the rvalue in question

[19:28] <[particle]> need a google search box on spec.pugscode.org

[19:29] <pmichaud> [particle]: eh, I just keep an up-to-date copy of svn.perl.org/perl6/doc/trunk and ack that.  :-)

[19:29] <[particle]> sure, i have a copy, too

[19:29] <[particle]> but i like fancy html

[19:31] <TimToady> cottage cheese and kimchee, yum

[19:31] * moritz_ would like to have a tool that only searches in C<...> and code blocks

[19:32] <moritz_> if you search for builtins that are also common english words, it's really painful to do it the normal way

[19:32] <mncharity> background is STD_red limitations (really old STD.pm and then some) are getting annoying.  but given the absence of minons, I'd like the next parser version to be the one which gets bootstrapped on, rather than another temporary one.

[19:32] *** eternaleye_ left
[19:33] <[particle]> moritz: like a Pod::Strip plugin for ack?

[19:33] <moritz_> [particle]: something along these lines

[19:33] <alester> Mind you, we DO have plugins, Mortiz

[19:34] <alester> If you were the first one to write one, I'd give you a dollar.

[19:34] <moritz_> alester: that's great (and expected ;)

[19:34] <mncharity> which suggests elf should do "fill in the gaps", ie, a p6 version of the elfish/rx_on_re regex engine (for the CL backend).  And place bootstrap on project hold pending refactoring.  But... that invites calendar time to slide by.

[19:34] <alester> Basically, you write a Perl/Pod handler that iterates over the file, and only hands back those lines of the file that aren't pod

[19:34] <alester> or ARE pod

[19:34] <mncharity> sigh.

[19:34] <alester> your choice.

[19:35] <moritz_> alester: sounds possible, with Pod::Simple

[19:35] * moritz_ adds that to his TODO list

[19:35] <[particle]> Pod::Strip is a Pod::Simple subclass

[19:35] <[particle]> it's a little more complicated if you also want to search C<...>

[19:36] <moritz_> [particle]: I don't want to strip Pod, I want to evaluate only the embedded code examples in POD

[19:36] <mncharity> TimToady: ok, ignore old elf wish list.  Current elf wish list is, I believe, "help TimToady with STD refactoring".

[19:36] <[particle]> but not too much more

[19:36] *** justatheory left
[19:36] <mncharity> though I suspect I may want a copy of your unchecked in gimme.

[19:36] <[particle]> moritz_: sorry, of course, for some reason i had .t files in my head, not .pod files

[19:36] <mncharity> elf doesn't use factorial. ;)

[19:37] <mncharity> and at this point, elf is entirely focused on bootstrap rather than t/.  and STD.pm doesn't use factorial either.

[19:38] <TimToady> but the test suite that I test STD with uses factorial in several places

[19:38] <TimToady> anyway, I'll go ahead and check in the change even with the brokenness in macros

[19:39] <mncharity> doesn't have to stop the current one.  feel free to drop it on the side.  misc/elfish/foo?

[19:39] <mncharity> *stomp

[19:39] <mncharity> and needn't drop it right now.

[19:39] <mncharity> that was more a "might ask you for it in a week or two" comment.

[19:40] <pugs_svn> r22475 | lwall++ | [STD] add implicit {*} hook at end of rules

[19:40] <mncharity> but whatever. :)

[19:41] <TimToady> anyway, a grammar can now just override Cursor::_REDUCE to call actions by name

[19:42] <mncharity> big picture is simply that looking ahead at the tasks between now and elf bootstrap, some of them seemed like "there's no reason someone from the community couldn't be working on this, rather than me, so when I get there, it's already done".  and the Wed meeting seemed a context to bring it up.

[19:43] <mncharity> re _REDUCE, hmm... maybe I'll reshuffle task order...

[19:43] <mncharity> thanks

[19:44] <TimToady> though if _REDUCE is going to add result objects, it needs to add it to $self "en passant"

[19:45] *** masak left
[19:45] <TimToady> probably to {''}, since that's what ->item() pulls out

[19:46] <mncharity> I'd simply like the Match nodes to end up with a $m<rule> = "name_of_the_rule_which_made_me" field.

[19:46] <mncharity> so I don't have to guess, based on what their parent Match called them.

[19:47] <rindolf> Hi all.

[19:47] <rindolf> http://run.pugscode.org/ does not work.

[19:54] <speckbot> r14585 | larry++ | Revision to accumulator semantics so that -= dwims

[19:55] <[particle]> does the ::EXPORT inner module always exist, or only if something is export?

[19:56] *** zamolxes left
[19:59] <mncharity> I'm off.  So Match tagging is back to being a community request.  I hope to have elf self-compiling on the new common-lisp backend over the next week or so.  Given a tagged parse tree, I'd probably then exercise STD by attempting to get elf to self-compile on it.  And then elf to compile and run STD itself.

[19:59] <mncharity> thanks for all the fish. &

[19:59] *** mncharity left
[20:03] *** mncharity joined
[20:03] <mncharity> s/community request/request to the community/  ;)

[20:03] *** mncharity left
[20:03] *** viklund left
[20:05] *** rindolf left
[20:06] <pugs_svn> r22476 | moritz++ | [t] move topic.t to spec/, small HOWTO updates

[20:09] <moritz_> I forgot the result of our last discussion on junctions...

[20:09] <moritz_> should (1 | 2 | 3).values return a list, or a junction?

[20:14] <PerlJam> why would that return a junction?

[20:14] <PerlJam> my $j =  1 | 2 | 3;  $j.values; should be the same 

[20:15] <moritz_> I think that pmichaud that .values autothreads on its invocant just like all other methods

[20:15] <moritz_> *mentioned

[20:20] *** ruoso left
[20:22] <moritz_> rakudo: say "abc".substr(1,-1)

[20:22] <p6eval> rakudo 31554: OUTPUT[b␤]

[20:22] <azawawi> pugs: say $?OS;

[20:22] <p6eval> pugs: OUTPUT[linux␤]

[20:22] <azawawi> rakudo: say $?OS;

[20:22] <p6eval> rakudo 31554: OUTPUT[Scope not found for PAST::Var '$OS'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤]

[20:24] <azawawi> moritz_: i tried to define set_hll_global for OS in globals.pir but i cant get perl6 to understand the differance between $?OS and $*OS

[20:25] *** adrian__ joined
[20:25] <moritz_> azawawi: don't know what to do there

[20:26] *** eternaleye_ joined
[20:27] *** zamolxes joined
[20:30] <pugs_svn> r22477 | moritz++ | [t] move noncap.t to spec/, added deprecation comment to junction_functions.t

[20:33] *** elmex left
[20:34] <azawawi> moritz_: do we need to implement p5chop and p5chomp?

[20:35] <moritz_> azawawi: yes, but they are less trivial than it might look like, because strings are immutable in Perl 6

[20:35] * azawawi reminds moritz_ about RT #59476

[20:35] <moritz_> azawawi: I'm appliying that as we talk

[20:36] <rakudo_svn> r31557 | moritz++ | [rakudo] refactored Str.capitalize to use find_cclass.

[20:36] <rakudo_svn> r31557 | moritz++ | Patch courtesy by azawawi++

[20:36] <azawawi> moritz_++

[20:37] *** Chillance joined
[20:38] *** adrian__ left
[20:38] <pugs_svn> r22478 | moritz++ | [t] move pod_in_multi_line_exprs.t to spec and $fn ~~ s/_/-/g

[20:38] *** justatheory joined
[20:39] <azawawi> moritz_: i noticed that a couple of tests in S26-str can be unfudged... did we lately apply any patches to unicode support?

[20:40] <azawawi> moritz_: namely uc.t, lc.t, lcfirst.t, and capitalize.t 

[20:40] <moritz_> azawawi: these tests only pass if parrot is built/linked with `libicu' 

[20:41] <moritz_> azawawi: so on those systems without icu these tests fail, which is why they are fudged

[20:41] <moritz_> (and which is why tools/autofunfudge.pl ignores all fudges with "unicode" in the comments)

[20:41] <azawawi> nice

[20:42] * moritz_ would prefer it if rakudo died with "Perl 6 needs Unicode" if it runs on parrot wihtout icu

[20:42] * azawawi searches for an interesting RT

[20:43] * [particle] would prefer if rakudo worked without icu

[20:44] <moritz_> [particle]: I think if there are "non-Unicode Perl 6 compiler" out there, then people will start recommeding to not use Unicode in their Perl 6 programs to keep them portable

[20:45] <moritz_> [particle]: then we get an anti-Unicode Best Practice fanatism

[20:45] <moritz_> [particle]: Perl 6 without Unicode is just as unthinkable to me as Perl without regexes

[20:46] * azawawi thinks unicode support is a must.

[20:46] <[particle]> parrot will implement unicode without icu someday

[20:46] <[particle]> i didn't say "without unicode"

[20:46] * [particle] wants native parrot unicode support today

[20:47] <moritz_> why reimplement icu functionality in parrot?

[20:47] <TimToady> icu doesn't implement NFG

[20:47] <moritz_> ok, point taken

[20:47] <azawawi> NFG? ;-)

[20:48] <TimToady> </wink>

[20:48] <TimToady> Normalization Form Grapheme

[20:48] <pugs_svn> r22479 | moritz++ | [t] remove xx-uncategorized/short_circuiting.t. Tested in much greater detail

[20:48] <pugs_svn> r22479 | moritz++ | in spec/S03-operators/short-circuit.t

[20:48] <[particle]> there are platforms where icu won't compile and parrot will run

[20:49] <TimToady> as soon as you implement NFG all your strings become arrays of integers, which is easy to deal with

[20:50] <pmichaud> there's a plan to re-implement string support in Parrot, and at that point they're completely revisiting the unicode support issues

[20:50] <azawawi> any resources on NFG?

[20:50] <pmichaud> even today "without icu" doesn't mean "without unicode"  :-)

[20:51] <TimToady> the PDD that simon wrote

[20:51] <pmichaud> http://svn.perl.org/parrot/trunk/docs/pdds/pdd28_strings.pod

[20:51] <moritz_> azawawi: it has been discussed on #parrot, so you could check the logs

[20:51] <azawawi> moritz_: thx

[20:52] <TimToady> you certainly won't find anything on it from the unicode folks though

[20:52] <TimToady> unless they've noticed us more than we thing they have

[20:53] <TimToady> *think

[20:54] *** hercynium left
[20:55] *** mofino left
[21:18] <rakudo_svn> r31558 | moritz++ | [rakudo] add two more small files to spectest_regression

[21:31] *** iblechbot left
[21:42] *** wknight8111 joined
[21:44] *** TJCRI left
[21:46] <pugs_svn> r22480 | particle++ | [t] add test file and module for export testing

[21:48] <moritz_> [particle]: that test needs a bit tweaking

[21:48] <moritz_> [particle]: is() compares with string semantics...

[21:48] <[particle]> what did i do wrong?

[21:48] <[particle]> ah, right

[21:48] <moritz_> (at least at the moment)

[21:48] <[particle]> i need =:=

[21:48] <moritz_> or ===

[21:49] <[particle]> ok( &Foo::foo =:= &Foo::EXPORT::ALL::foo, ...

[21:49] <[particle]> look good?

[21:49] <moritz_> yes

[21:49] <moritz_> also note that the implementations don't chdir to spec/S*/ before exeucting the tests

[21:49] <moritz_> so it won't find Foo.pm

[21:50] <[particle]> ah, hrm

[21:50] <[particle]> so maybe i'll put the module inline

[21:50] <moritz_> there's also packages/

[21:51] <[particle]> does rakudo know about that?

[21:51] <moritz_> it knows about t::spec::packages::Foo if there's a Foo.pm ;)

[21:52] <moritz_> std: use t::spec::S11-modules::Foo;

[21:52] <p6eval> std 22480: OUTPUT[parsed␤]

[21:53] <moritz_> (hyphens-in-identifiers)++

[21:53] <[particle]> indeed!

[21:54] <moritz_> I'm not yet 100% sure what's the best cross-platform and spec conformant way of making modules findable

[21:58] <[particle]> how about i create t::spec::packages::S11-modules-Foo

[21:58] * moritz_ would like ::spec::packages::S11-modules::Foo better

[21:59] <[particle]> that's fine, too

[21:59] <moritz_> that's easier to autocomplete with the tab key ;)

[22:00] *** meteorjay joined
[22:03] <pugs_svn> r22481 | particle++ | [t] move a test module to t/spec/packages subdir to set a (better?) de-facto standard

[22:07] *** eternaleye_ left
[22:08] <moritz_> [particle]++ # test suite hacking

[22:08] <[particle]> finally! and moritz++ for keeping me honest

[22:08] <moritz_> rakudo: my ($x, $y); say $x =:= $y

[22:08] <p6eval> rakudo 31558: OUTPUT[Could not find non-existent sub infix:=:=␤current instr.: '_block11' pc 126 (EVAL_16:49)␤]

[22:09] <[particle]> yeah, well, first i have t\spec\S11-modules\export....Can't find ./t/spec/S11 in @INC

[22:09] <[particle]> to deal with

[22:10] <moritz_> parsing problem

[22:10] <[particle]> likely the -

[22:10] *** justatheory left
[22:11] <moritz_> aye

[22:12] <[particle]> i guess rakudo needs its own <ident>

[22:12] <moritz_> aye

[22:19] <[particle]> actually, it needs <apostrophe> and <identifier>. adding...

[22:23] <meppl> good night

[22:25] *** alester left
[22:26] <pmichaud> [particle]: you shouldn't need to make it a separate Foo.pm

[22:26] <[particle]> pmichaud: i'm trying to get the example in the synopsis to work

[22:26] <[particle]> anyway, rakudo needs to support <apostrophe> so i'm doing that now

[22:27] <[particle]> i guess i don't have to test importing to test exporting, so i can export from the current namespace

[22:27] *** meppl left
[22:28] <[particle]> rakudo: say $?MODULE

[22:28] <p6eval> rakudo 31560: OUTPUT[Scope not found for PAST::Var '$MODULE'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤]

[22:28] <[particle]> rakudo: say $?CLASS

[22:28] <p6eval> rakudo 31560: OUTPUT[Scope not found for PAST::Var '$CLASS'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤]

[22:28] <[particle]> rakudo: say $?PACKAGE

[22:28] <p6eval> rakudo 31560: OUTPUT[Scope not found for PAST::Var '$PACKAGE'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤]

[22:29] <[particle]> i'm getting two bonus tests in spectest_regression

[22:29] <[particle]> Passed TODO                               Stat Wstat TODOs Pass  List of Passed

[22:29] <[particle]> -------------------------------------------------------------------------------

[22:29] <[particle]> t\spec\S05-transliteration\trans.rakudo                  2    1  16

[22:29] <[particle]> t\spec\S06-signature\named-parameters.rak                4    1  2

[22:29] <[particle]> Files=198, Tests=6256, 465 wallclock secs ( 0.00 cusr +  0.00 csys =  0.00 CPU)

[22:31] <[particle]> what's the name of the current namespace? is it 'main'?

[22:31] <[particle]> will &foo === &::EXPORT::ALL::foo work?

[22:31] <[particle]> (once i implement exporting, of course)

[22:38] *** justatheory joined
[22:39] *** hercynium_ left
[22:42] *** hercynium_ joined
[22:45] *** [particle]1 joined
[22:49] *** [particle] left
[22:50] *** justatheory left
[23:02] *** [particle]1 is now known as [particle]

[23:04] <rakudo_svn> r31561 | particle++ | [rakudo] add apostrophe and identifier tokens to grammar; not using them yet

[23:22] *** kanru joined
[23:45] <Tene> TimToady: you have a minute to talk about block labels?

[23:46] <TimToady> sure

[23:47] <Tene> Is a block label just a lexical identifier for the block itself?

[23:47] <Tene> Or is it a separate object, or is it an object at all?

[23:47] <Tene> Can I call "FOO: { say FOO.WHAT() }", and if so, what does it print?

[23:47] <TimToady> A label is defined as a pseudo-type, more or less

[23:48] *** hercynium_ left
[23:49] <TimToady> so I suspect .WHAT just returns FOO

[23:50] <Tene> What about FOO.perl()?

[23:50] <TimToady> well, that also probably just returns FOO

[23:51] <Tene> Can I assign FOO to a variable?  $x = FOO?

[23:51] <TimToady> a label's value is really its name, and the fact that it's visible from the current scope

[23:51] <TimToady> yes, but if you use it in a different scope, it may have a different interpretation

[23:51] <TimToady> on the other hand, perhaps it's more than that

[23:52] <TimToady> and any use of a label resolves to a particular lexical scope before the assignment

[23:52] <TimToady> in which case it's probably some other kind of object

[23:52] <Tene> It's NOT an identifier for the block itself, though, right?

[23:53] <TimToady> I think it's primarily a name and an identity

[23:54] <TimToady> and the actual structures are found by scanning for structures that have the same identity

[23:54] <TimToady> generally outward in the dynamic scope

[23:55] <TimToady> so FOO: { FOO: { FOO.leave }} creates two labels with the same name but different identities, and the inner one passes its identity for the scan of which block to leave

[23:56] <TimToady> so they would differ in .WHICH but not in .WHAT

[23:56] *** Exodist left
[23:56] <TimToady> it may be that it should return "Label" for .WHAT

[23:57] <TimToady> but it's the fact that it's declared outside a particular scope that allows it to be used as a bareword

[23:57] <TimToady> and that is the sense in which it's like a type

[23:58] <TimToady> a goto might have to be special cased for a following label though

[23:58] <TimToady> or written goto "FOO" maybe.

[23:59] <TimToady> anyway, FOO.leave is allowed only because FOO is predeclared

[23:59] <TimToady> otherwise it'd be an illegal bareword

[23:59] *** Limbic_Region joined
[23:59] <TimToady> and it parses as a type, basically

