[00:05] *** bennett left
[00:05] *** explorer__ left
[00:09] *** elmex left
[00:29] *** meppl left
[00:30] *** meteorjay joined
[00:34] *** eternaleye_ left
[01:07] *** Limbic_Region left
[01:10] *** ruoso left
[01:15] *** eternaleye joined
[01:16] <speckbot> r14588 | larry++ | Added ~ twiddle macro to make it easier to write bracketing constructs.

[01:27] <pmichaud> AIIIIIIIIIE!!!!!

[01:27] <pmichaud> that said, ~ (twiddle) is wicked cool, too.  

[01:28] *** ab5tract left
[01:40] *** hercynium joined
[01:45] *** mncharity joined
[02:01] *** wknight8111 left
[02:06] * mncharity notes the specbot links at the top of http://irclog.perlgeek.de/perl6/2008-10-06 , to http://www.perlcabal.org/svn/p6spec/revision?rev=14586 and http://www.perlcabal.org/svn/p6spec/revision?rev=14587 , yield blank pages.

[02:07] <lambdabot> Title: IRC log for #perl6, 2008-10-06

[02:12] *** alester_ joined
[02:18] <mncharity> A curiousity: http://feather.perl6.nl/syn/S06.html#Flattening_argument_lists says "The | operator flattens lazily -- the array is flattened only if flattening is actually required within the subroutine.".  However, it's not just the routine which needs the arguments, the multimethod dispatcher needs them too.  So the sentence seems incorrect?  And the necessary behavior/spec, more complex.

[02:18] <lambdabot> Title: S06

[02:19] <mncharity> Hmm.   Though... I guess the mmd dispatcher could count as "within the subroutine".  ok, nm.

[02:30] <mncharity> @tell wayland76 apropos testrole, elf likely currently supports multi infix:<==>.  fyi.

[02:30] <lambdabot> Consider it noted.

[02:49] <mncharity> @tell masak re "elf--, rakudo-- # that's just stupid :)", re "my $x; say $x.defined", I've added  class Any { method defined { defined(self) } } to misc/elf/elf_h_src/Prelude.pm.   Extending the elf prelude is easy.  Contributions welcome.

[02:49] <lambdabot> Consider it noted.

[03:01] *** s1n left
[03:03] *** alester_ left
[03:06] *** Ontolog joined
[03:07] *** hercynium left
[03:13] *** eternaleye left
[03:14] *** eternaleye joined
[03:15] <pugs_svn> r22521 | putter++ | [elf_h] Startup (main) refactored to make Elf derivatives easier.  Fixed elf code bugs: missing required arguments; object fields accessed as hash.  Added list argument recognition (for on_sbcl).

[03:28] <pugs_svn> r22522 | putter++ | [elfish/on_sbcl] elfcl runs fib.

[03:31] <mncharity> departing footsteps echo in the empty chamber

[03:31] <mncharity> night shift out.  cheers. &

[03:31] *** mncharity left
[03:54] *** agentzh left
[03:54] *** agentzh joined
[04:00] *** mellifluidicpuls joined
[04:14] *** mellifluidicpuls left
[04:14] *** mellifluidicpuls joined
[04:19] *** mellifluidicpuls left
[04:19] *** mellifluidicpuls joined
[04:46] *** justatheory left
[04:54] *** s1n joined
[05:06] *** Psyche^ joined
[05:19] *** zamolxes left
[05:21] *** Patterner left
[05:21] *** Psyche^ is now known as Patterner

[05:22] *** eternaleye left
[05:23] *** BinGOs left
[05:24] *** eternaleye joined
[05:29] *** Bzek joined
[05:36] *** BinGOs joined
[05:37] *** iblechbot joined
[05:45] *** dduncan joined
[05:45] <dduncan> I have a grammar question

[05:46] <dduncan> concerning repetition by separator, eg: 'foo' ** ',' ...

[05:47] <dduncan> I know from S05 that that pattern will match one or more occurrances of 'foo' that are separated by commas ...

[05:47] <dduncan> my first question is, will that pattern also match zero occurrances?

[05:49] <dduncan> also, what is the best way to say, repeat by the separator but that there must be at least or at most N matches?

[06:23] *** iblechbot left
[06:35] *** bsb joined
[06:50] *** ashizawa joined
[06:50] *** mellifluidicpuls left
[06:54] *** zamolxes joined
[07:05] *** jferrero joined
[07:30] <moritz_> dduncan: I don't think you can add counts to **, so you have to fall back to 'foo' [',' 'foo']**2..10 

[07:34] *** smg left
[07:35] *** cosimo joined
[07:49] *** elmex joined
[07:50] <dduncan> moritz_ okay, but my main question, can 'foo' ** ',' match zero occurrances of 'foo', or only 1+?

[07:50] <dduncan> that's what I want to know the most

[07:52] *** pmurias joined
[07:52] <pugs_svn> r22523 | pmurias++ | [smop] converted s1p_lexicalscope to RI, and extended the RI language to make it work

[07:56] <moritz_> dduncan: I think it has to match the atom on the left at least once

[07:56] <moritz_> dduncan: not 100% sure though

[07:56] <dduncan> I'll look at S05 again, and if I can't find a definitive answer, I'll ask on p6l

[07:57] <pmurias> dduncan: what's the state of Muldis?

[07:58] <moritz_> "If you supply any other atom (which may be quantified), it is interpreted as a separator (such as an infix operator), and the initial item is quantified by the number of times the separator is seen between items:"

[07:58] <dduncan> the language spec is 95% done, the reference implementation about 10% done

[07:58] <moritz_> and then <ident> ** ',' matches 'foo'

[07:58] <moritz_> where it's quantified by zero commas

[07:59] <moritz_> and it matches 'foo,bar' where it's quantified by one comma

[07:59] <moritz_> so I guess to match the empty string you'd need -1 commas ;-)

[07:59] <dduncan> moritz_ I was under the impression that the commas were just a means of saying that you want to match a bunch of 'foo'

[08:00] *** pmurias left
[08:00] <dduncan> say we want to match a list of items, but the list might be empty, and the whole list is delimited by brackets

[08:01] <moritz_> right, but that's not how I read the specs

[08:01] <dduncan> now, if the ** syntax in question always matches at least 1 foo, then I would qualify a zero or more list by grouping the whole thing with a []?

[08:02] <dduncan> which is fine

[08:02] <dduncan> but if the syntax can match zero or more, I would wonder how to say I want at least 1

[08:02] <dduncan> eg, the distinction between * and +

[08:03] <moritz_> call that *+ ;-)

[08:04] *** Ontolog left
[08:08] <dduncan> pmurias, so as I said, 95% and 10% ... this next day or 2 I've been focusing on improving the actual grammar (the 'Tiny' dialects), including adding specific syntax for routine and type declarations, so people can write those in a manner like a normal programming language, rather than having to write those indirectly by way of data literals (which the compiler turns the former into)

[08:09] <dduncan> the new version, of PTMD_Tiny at least, would also lend itself much better to support by text editors for syntax coloring and function extraction

[08:10] <dduncan> I've also been working on a textless language module for BBEdit that would take advantage of taht

[08:15] *** sri_work left
[08:16] *** sri_work joined
[08:29] *** Ontolog joined
[08:30] *** barney joined
[08:49] *** meppl joined
[08:49] <meppl> good morning

[08:58] *** zamolxes left
[09:01] <barney> chromatic++ for http://www.reddit.com/r/programming/comments/75gke/perl_6_offers_no_less_than_eq_eqv_and/

[09:01] <lambdabot> Title: Perl 6 offers no less than eq, ==, eqv, ===, =:=, and ~~ : programming, http://tinyurl.com/3zvpby

[09:05] *** smg joined
[09:14] *** alanhaggai joined
[09:21] *** masak joined
[09:22] *** barney left
[09:25] *** viklund left
[09:26] *** Alias_ joined
[09:26] *** viklund joined
[09:27] *** Alias_ is now known as adamkennedy

[09:50] *** masak left
[10:07] *** Ontolog left
[10:11] *** Bzek left
[10:13] *** c1sung_ joined
[10:17] *** Patterner left
[10:17] *** meteorjay left
[10:17] *** smtms left
[10:17] *** Lorn left
[10:17] *** jrockway left
[10:17] *** cotto left
[10:17] *** spinclad left
[10:17] *** szbalint left
[10:17] *** nnunley left
[10:17] *** pjcj left
[10:17] *** xinming_ left
[10:17] *** Guest16015 left
[10:17] *** c1sung left
[10:18] *** literal left
[10:18] *** idemal left
[10:18] *** beppu left
[10:18] *** Juerd left
[10:18] *** gbacon left
[10:18] *** ewilhelm left
[10:18] *** obra left
[10:18] *** sunnavy left
[10:18] *** Patterner joined
[10:18] *** meteorjay joined
[10:18] *** smtms joined
[10:18] *** Lorn joined
[10:18] *** jrockway joined
[10:18] *** xinming_ joined
[10:18] *** pjcj joined
[10:18] *** cotto joined
[10:18] *** gbacon joined
[10:18] *** Juerd joined
[10:18] *** literal joined
[10:18] *** sunnavy joined
[10:18] *** obra joined
[10:18] *** Guest16015 joined
[10:18] *** ewilhelm joined
[10:18] *** idemal joined
[10:18] *** spinclad joined
[10:18] *** beppu joined
[10:18] *** szbalint joined
[10:18] *** nnunley joined
[10:19] *** Bzek joined
[10:23] *** ewilhelm_ joined
[10:27] *** ewilhelm left
[10:28] *** tomyan joined
[10:30] *** Juerd_ joined
[10:30] *** Juerd left
[10:32] *** Lorn__ joined
[10:32] *** sunnavy left
[10:33] *** sunnavy joined
[10:34] *** smtms left
[10:34] *** smtms joined
[10:34] *** dduncan left
[10:37] *** meteorja1 joined
[10:37] *** lumi left
[10:37] *** lumi joined
[10:38] *** Lorn left
[10:38] *** meteorjay left
[10:47] *** jrockway left
[10:47] *** jrockway joined
[10:48] *** beppu left
[10:48] *** beppu joined
[10:50] *** nnunley_ joined
[10:50] *** plash_ joined
[10:51] *** szbalint_ joined
[10:51] *** Psyche^ joined
[10:52] *** nnunley left
[10:52] *** szbalint left
[10:52] *** Patterner left
[10:52] *** Psyche^ is now known as Patterner

[10:59] *** literal left
[11:00] *** literal joined
[11:02] *** ewilhelm_ left
[11:05] *** ewilhelm joined
[11:13] *** ewilhelm left
[11:13] *** sunnavy left
[11:13] *** spinclad left
[11:13] *** cotto left
[11:13] *** pjcj left
[11:13] *** xinming_ left
[11:13] *** Guest16015 left
[11:13] *** idemal left
[11:13] *** obra left
[11:13] *** gbacon left
[11:13] *** ewilhelm joined
[11:13] *** sunnavy joined
[11:13] *** xinming_ joined
[11:13] *** pjcj joined
[11:13] *** cotto joined
[11:13] *** gbacon joined
[11:13] *** obra joined
[11:13] *** Guest16015 joined
[11:13] *** idemal joined
[11:13] *** spinclad joined
[11:24] *** Deepi joined
[11:34] *** masak joined
[11:37] *** ewilhelm left
[11:39] *** spinclad_ joined
[11:42] *** BinGOs left
[11:44] *** spinclad left
[11:44] *** cotto left
[11:44] *** pjcj left
[11:44] *** xinming_ left
[11:44] *** Guest16015 left
[11:44] *** idemal left
[11:44] *** obra left
[11:44] *** sunnavy left
[11:44] *** gbacon left
[11:46] *** sunnavy joined
[11:46] *** xinming_ joined
[11:46] *** pjcj joined
[11:46] *** cotto joined
[11:46] *** gbacon joined
[11:46] *** obra joined
[11:46] *** Guest16015 joined
[11:46] *** idemal joined
[11:46] *** spinclad joined
[11:46] *** BinGOs joined
[11:47] *** pjcj left
[11:47] *** pjcj joined
[11:50] *** spinclad left
[11:53] *** ewilhelm joined
[11:54] *** pmurias joined
[12:05] *** pmurias left
[12:05] *** ewilhelm left
[12:05] *** cotto left
[12:05] *** xinming_ left
[12:05] *** Guest16015 left
[12:05] *** idemal left
[12:05] *** obra left
[12:05] *** sunnavy left
[12:05] *** gbacon left
[12:05] *** pmurias joined
[12:05] *** ewilhelm joined
[12:05] *** sunnavy joined
[12:05] *** xinming_ joined
[12:05] *** cotto joined
[12:05] *** gbacon joined
[12:05] *** obra joined
[12:05] *** Guest16015 joined
[12:05] *** idemal joined
[12:20] *** cotto left
[12:20] *** xinming_ left
[12:20] *** pmurias left
[12:20] *** Guest16015 left
[12:20] *** idemal left
[12:20] *** obra left
[12:20] *** sunnavy left
[12:20] *** gbacon left
[12:20] *** ewilhelm left
[12:25] *** pmurias joined
[12:25] *** ewilhelm joined
[12:25] *** sunnavy joined
[12:25] *** xinming_ joined
[12:25] *** cotto joined
[12:25] *** gbacon joined
[12:25] *** obra joined
[12:25] *** Guest16015 joined
[12:25] *** idemal joined
[12:25] *** ewilhelm_ joined
[12:29] *** alanhaggai left
[12:30] *** ewilhelm_ left
[12:30] *** cotto left
[12:30] *** xinming_ left
[12:30] *** pmurias left
[12:30] *** Guest16015 left
[12:30] *** idemal left
[12:30] *** obra left
[12:30] *** sunnavy left
[12:30] *** gbacon left
[12:30] *** ewilhelm left
[12:30] *** Guest16015 joined
[12:30] *** gbacon joined
[12:30] *** xinming joined
[12:31] *** idemal joined
[12:32] * moritz_ thinks about a macro prefix:<http://> is parsed { S+ } { "$_" }

[12:32] <moritz_> then you could write (escaped) bareword URLs ;)

[12:33] <moritz_> presumably even with check for well-formedness at compile time ;)

[12:43] *** lisppaste3 left
[12:43] <masak> moritz_: neat, but why? :)

[12:43] <lambdabot> masak: You have 1 new message. '/msg lambdabot @messages' to read it.

[12:43] *** lisppaste3 joined
[12:45] <moritz_> masak: because we can?

[12:45] <masak> @tell mncharity tell mncharity re method defined: cool, re contributions to elf: I'll keep that in mind

[12:45] <lambdabot> Consider it noted.

[12:50] *** ewilhelm joined
[12:50] *** sunnavy joined
[12:50] *** obra joined
[12:51] *** zamolxes joined
[12:52] <masak> moritz_: yes, I saw that reason. I was wondering if you had any deeper use for it. also, I thought Perl 6 was sort of moving away from barewords... :)

[12:53] <moritz_> masak: then don't call it "bareword". It's an elaborate quoting construct, of which Perl 6 has more than perl 5 ;)

[12:53] <masak> aah.

[12:53] * masak sees it now

[12:54] <masak> great! carry on.

[12:55] <moritz_> I think the actual use is very little, but it's a nice proof-of-concept of what macros can do

[12:56] <masak> aye.

[13:05] *** ashizawa left
[13:11] <rakudo_svn> r31750 | pmichaud++ | [rakudo]: spectest-progress.csv update: 205 files, 4363 passing, 74 failing

[13:23] <moritz_> wow, google has indexed S11 from perlcabal.org

[13:24] <moritz_> a slightly more permissive robots.txt is very helpful ;)

[13:29] *** plash_ left
[13:33] *** sri_work left
[13:52] *** iblechbot joined
[14:00] <TimToady> that would be term:<http://>

[14:00] *** TJCRI joined
[14:00] *** Deepi left
[14:01] *** Deepi joined
[14:04] <moritz_> token term:<http://> { <sym> \S+ }; # like this?

[14:05] <moritz_> or can you declare macro term:... ?

[14:07] <TimToady> macro term:<http://> is parsed / <sym> \S+ /

[14:07] <TimToady> but if token it must be term:sym<http://> instead

[14:08] <TimToady> the name of the rule is distinguished from the name of the operator

[14:09] <TimToady> inside the grammar, term:<http://> would be the operator that the grammar is using, not the one it's parsing

[14:09] <TimToady> we must make this distinction or we can't parse P6 using P6

[14:10] * masak 's head spins

[14:10] *** alanhaggai joined
[14:10] <TimToady> @tell dduncan yes, you must use []? currrently to get 0 instances of <foo> ** ','

[14:10] <lambdabot> Consider it noted.

[14:10] <moritz_> .oO( maybe we need #perl6-for-dummies )

[14:11] <masak> moritz_: oh yes, pretty please! I would be there all the time.

[14:11] <TimToady> just cargo cult the rules in STD.pm and you should be fine  :)

[14:12] <TimToady> I'm about to check in the version of STD that uses the new '(' ~ ')' <expr> notation, but still have a few bugs

[14:12] <TimToady> where it currently has all those ugly <in:...> calls

[14:12] * moritz_ hasn't quite understood that either

[14:13] * masak neither

[14:13] <TimToady> which I want to get rid of because it fills the AST with "in" nodes that are relatively useless

[14:14] <moritz_> does ~ only counts nesting constructs that are matched by other rules that use ~ ?

[14:14] <TimToady> the ~ is actually a kind of parser combinator I stole from Haskell, where it's called 'between" iirc

[14:15] <TimToady> on first inspection it merele rewrites <a> ~ <b> <c> to <a> <c> <b>

[14:16] <masak> why would one want that?

[14:16] <TimToady> but the reason to pull <b> out front in the notation is because you're really setting up the final goal

[14:16] <TimToady> and it's very important to know the goal in order to know when to quit

[14:17] <TimToady> and in the absence of finding the goal, what the correct error message is

[14:17] <masak> hm. so this helps in generating better error messages?

[14:17] <TimToady> yes

[14:17] <masak> that's good.

[14:18] <TimToady> as well as passing the terminator down to the intermediate rule

[14:18] <masak> ooh

[14:18] <TimToady> in the error messages in the new bit of S05 text, you'll see that it was complaining that it couldn't find ']'

[14:19] <TimToady> that's the goal that was specified by the ~

[14:19] <moritz_> so <c> somhow knows that it expects a <b> as the terminator?

[14:19] <moritz_> and if so, how?

[14:19] <TimToady> yes, in fact STD currently sets $+GOAL as a context var

[14:19] * masak starts to see the uses of this

[14:20] <TimToady> you can also read ~ as "before b find a c"

[14:20] <TimToady> but there's also the readability issue of putting the two brackets right next to each other

[14:21] <TimToady> and in a visually parallel construct, which <in:> isn't

[14:21] <TimToady> nor was the old form with '(' <EXPR> [ ')' || fail ]

[14:21] <moritz_> aye, that was a real cludge

[14:22] <TimToady> '(' ~ ')' <EXPR> is much clearer

[14:22] <masak> yes, and it packages a common idiom, too

[14:22] <masak> TimToady++

[14:22] <TimToady> well, stole it from Haskell

[14:22] <TimToady> specifically, parsec

[14:22] <masak> Parsec++, too

[14:23] <TimToady> the one thing that bugs me is that it still isn't really a combinator in the haskellian sense

[14:23] <TimToady> it's really only a macro

[14:23] <TimToady> but we don't have an easy notation for first class chunks of pattern

[14:24] <masak> maybe that's next :)

[14:24] <TimToady> when we do, perhaps ~ will be defined in terms of it

[14:24] <moritz_> and I thought S05 was pretty stable

[14:24] <TimToady> it's just something I wanted while trying to clean up STD

[14:25] <masak> TimToady: speaking of grammars, if I thought long and hard on how to connect {*} in a particular grammar to a particular class, and then wrote to p6l about it, would there be a chance such a feature could be added to Perl 6?

[14:25] <TimToady> um, I'm already doing it

[14:25] <TimToady> look at viv

[14:25] <masak> viv?

[14:25] *** ruoso joined
[14:25] <moritz_> gimme5 that uses STD

[14:26] <TimToady> the vi-to-v translator that will replace gimme5

[14:26] <masak> that's good news

[14:26] <moritz_> (if I remeber the commit message correctly)

[14:26] <moritz_> TimToady: any thoughts on http://www.nntp.perl.org/group/perl.perl6.language/2008/09/msg29636.html ?

[14:26] <masak> is that written in Perl 6?

[14:26] <lambdabot> Title: [PATCH] How to match against a grammar - nntp.perl.org, http://tinyurl.com/4rcksm

[14:26] <TimToady> not yet

[14:26] <masak> TimToady: then does it really count?

[14:26] <moritz_> ah well, it's not pressing

[14:26] <TimToady> not yet

[14:26] <ruoso> hi!

[14:26] <TimToady> not yet!

[14:27] <moritz_> ;)

[14:27] <masak> I mean, is there a strategy for how to syntactically connect a grammar and a class in Perl 6?

[14:27] <masak> not yet... :/

[14:27] <masak> that's what I was planning to propoe

[14:27] <masak> propose*

[14:28] <TimToady> all I do currently is set a context var to the class or object I want to call reduction actions in.

[14:28] <TimToady> with a name constructed from the {*} tag

[14:28] <TimToady> that seems quite general

[14:28] <masak> TimToady: a context var in the grammar?

[14:29] <TimToady> a context var set in the code calling the grammar

[14:29] <TimToady> again, see viv

[14:29] <masak> oki

[14:29] <TimToady> a context var in Perl 5 looks like $::ACTIONS because it's just emulated with local

[14:29] <masak> ah.

[14:29] <pugs_svn> r22524 | moritz++ | vim modeline for viv

[14:30] <TimToady> ruoso: btw I am seriously considering merging $+foo with $*foo now

[14:30] <masak> actually, the end goal would be not to have to write tree traversal code in a class that uses a grammar

[14:30] <ruoso> TimToady, with or without falling back?

[14:31] <TimToady> with considering GLOBAL to automatically be contextual unless declared otherwise

[14:32] <ruoso> ok, so the global variables declared by the prelude are visible as contextual

[14:32] <TimToady> yes, by and large, haven't thought about whether I want any exceptions

[14:33] <ruoso> as opposed to having the contextual lookup falling back to global lookup

[14:33] <TimToady> well, depends on whether you just count GLOBAL as outermost lexical

[14:33] <TimToady> (well, unless there's PROCESS, which is outside GLOBAL)

[14:34] <TimToady> but the context lookup might not even know it's getting into a symbol table that is also considered a top-level package

[14:35] <TimToady> so not "fallback" in the cognitive sense, at least

[14:35] <ruoso> I wasn't planning GLOBAL to be the outermost lexical 

[14:35] <ruoso> I was planning "prelude" to be the outermost lexical

[14:35] <ruoso> and "prelude" "use" the builtin

[14:36] <TimToady> maybe prelude can set up more than one level of outer lexical...hmm...

[14:37] <TimToady> down 18 levels of brackets, we find a little call to the insert_user_code_here() macro...

[14:37] <TimToady> and maybe prelude is really wrapper

[14:37] <TimToady> so it's also postlude

[14:38] <ruoso> oh... wait...

[14:38] <ruoso> there are two senses of prelude here..

[14:38] <TimToady> much like p5 used to wrap programs in a loop when you use -p or -n

[14:38] <ruoso> one which is the code that invoke the actual program

[14:38] <ruoso> and other which is the outermost scope

[14:39] <TimToady> good question whether they need to be or even should be distinct

[14:39] <ruoso> the good thing about they being distinct is that every new file shares this same object as the outermost scope

[14:39] <TimToady> but I would argue that part of the definition of a language is specifying how the parse tree is handled at the end

[14:40] <TimToady> "every new file"?  no, every file in a given language

[14:40] <TimToady> different languages have different preludes

[14:40] *** eternaleye left
[14:40] <TimToady> preludes/postludes

[14:40] <ruoso> actually... every "STD Perl 6 comp_unit"

[14:41] <TimToady> well, if we don't give them the opportunity to tweak the calling code, then it's immutable at least by convention

[14:41] <TimToady> but we want to change it ourselves with new versions of Perl 6

[14:42] <TimToady> but I think prelude as wrapper would be an easy thing for people to grok

[14:42] <ruoso> ok, maybe the prelude scope is itself a contextual var (at the time of "use")

[14:44] *** jhorwitz joined
[14:44] <TimToady> maybe use treats the calling code as prelude wrapper for the called module

[14:45] <TimToady> no, that won't work

[14:45] <TimToady> violates audreyt's separate compilation concerns

[14:45] <ruoso> TimToady, one thing is "ultimate outer scope" and the other is "ultimate caller scope"

[14:45] <ruoso> "outer" and "caller" are different axes in variable lookup 

[14:46] <TimToady> yes, but perhaps they both end up at the same place, and that might buy us something or other

[14:46] <ruoso> i'm not sure how that can happen...

[14:46] <TimToady> you can go out dynamic contexts, but you keep ending up in someone's lexical context

[14:47] <TimToady> so they're already interwoven

[14:47] <ruoso> yes... of course...

[14:47] <ruoso> that's the exact point

[14:47] <ruoso> contextual lookup goes "back" in the "caller" axis, making regular lookups where the variable has the "is context" trait

[14:47] <TimToady> the question is whether outer and caller from the main scope end up at the same place

[14:48] <ruoso> you do realize that will make all your globals visible as local variables, don't you?

[14:48] <ruoso> i.e. $OUT

[14:50] *** icwiener joined
[14:50] <TimToady> hmm, well, maybe $*OUT merely tells the compiler to bypass lexical lookup and go straight to looking up $OUT dynamically

[14:50] <ruoso> yeah... that's the "contextual lookup" I've been referring to 

[14:50] <ruoso> and there's the "ultimate caller"

[14:51] <ruoso> which declares "my $OUT is context = $GLOBAL::OUT"

[14:51] <TimToady> but there could be great value in confusing lexical and dynamic notation if we want to implement temp using context on lexicals

[14:52] <ruoso> we could assume that temp $OUT would create a local copy to $*OUT

[14:53] <TimToady> question is how 'my $x; temp $x = foo()" gets the temporized $x into its dynamic scope.

[14:53] <ruoso> we had been there before...

[14:53] <TimToady> it's not in the dynamic scope, since $x isn't visible there

[14:53] <ruoso> temp needs contextual vars

[14:53] <TimToady> but if you access $x lexically, it doesn't know to look it up dynamically

[14:54] <ruoso> that's why "my $x; temp $x" is supposed to be a failure...

[14:54] <ruoso> "my $x is context; temp $x" otoh, should do the trickl

[14:54] <TimToady> eh, not specced as failure in p6

[14:54] <ruoso> TimToady, yeah... I know... we discussed that before :)

[14:54] <ruoso> TimToady, and we agreed at the time that temp can only be applied to contextual vars...

[14:55] *** d4l3k_ joined
[14:55] <TimToady> I don't recall agreeing to that, but maybe I'm getting senile, or maybe I just didn't understand what you were saying

[14:55] *** alanhaggai left
[14:56] <ruoso> heh...

[14:56] <TimToady> I can always blame jet lag too

[14:56] <ruoso> oh wait... I'm the one getting senile..

[14:56] *** pmichaud_ joined
[14:56] *** pmichaud left
[14:56] *** PerlJam left
[14:56] <ruoso> it's "temp $x" that means "my $x is context"

[14:56] *** Juerd joined
[14:56] *** PerlJam joined
[14:56] *** Juerd_ left
[14:57] <ruoso> so it's a "my $x; temp $x" causes a 'redefining variable in the same scope' warning...

[14:57] *** dalek left
[14:57] <TimToady> defining temp as "is context" doesn't help

[14:57] <ruoso> why

[14:57] <ruoso> ?

[14:57] *** masak left
[14:57] <ruoso> inside the current scope, you can use the local name...

[14:57] <TimToady> because you'll have some code that sees $x lexically and will go straight to the lexical without looking in the dynamic context

[14:58] <TimToady> and the dynamic context is not guaranteed to be in the lexical context

[14:58] *** d4l3k_ is now known as dalek

[14:58] <TimToady> when you have routines calling back and forth

[14:58] *** alanhaggai joined
[14:58] <ruoso> oh... I think I see what you mean...

[14:58] <TimToady> I think I see what needs to happen though

[14:58] <TimToady> if you temporize $x somewhere, it's because it's already visible and mutable in the lexical scope

[14:59] <TimToady> so it retroactively "mutes" it to a context var, so that anyone who looks it up lexically knows to look it up dynamically instead

[14:59] <ruoso> but that doesn't solve the following:

[15:00] <ruoso> package foo { my $var = 1; sub bar { say $var } }; my $var is context = 2; foo::bar()

[15:00] <TimToady> It globally records the *fact* of temporization like p5, but doesn't track the *data* of it like p5

[15:00] <TimToady> so the data is still contextual

[15:01] <ruoso> TimToady, should foo::bar() say "1" or "2" on the above example?

[15:02] <ruoso> I don't think there's a way to actually avoid the twigil to mean 'this lookup should be subject to contextual lookup'

[15:02] <TimToady> it should say 1

[15:02] <TimToady> if you want to force dynamic lookup, you need the *

[15:03] <ruoso> right.. so it seems we agree after all

[15:03] <TimToady> but then it throws away the * and looks for $foo and any dynamically surrounding lexical scope

[15:03] <TimToady> (where declared contextual)

[15:04] <TimToady> (or temporized contextual)

[15:04] <TimToady> againg the "fact" of temporization, but not the value

[15:04] <pugs_svn> r22525 | ruoso++ | [smop] SMOP__S1P__AdhocSignature lets you define a signature with custom molds for ACCEPTS and BIND

[15:04] <ruoso> TimToady, should that mean that $*foo looks in the current scope for a contextual var first?

[15:05] <TimToady> well, the fact comes from lexical lookup, then the value presumably comes from somewhere inner to the lexical that was temporized

[15:05] * ruoso lunch &

[15:05] <TimToady> will think about current scope

[15:05] *** hercynium joined
[15:06] <TimToady> first answer, probably

[15:08] <TimToady> and maybe $+foo forces one CALLER in there

[15:08] <TimToady> 'course, that means $?foo should mean here or in my direct caller  :)

[15:10] <TimToady> but if $*foo looks in this scope first

[15:10] *** justatheory joined
[15:11] <TimToady> and if we make temp mark the current lexical as temporarily contextual

[15:12] <TimToady> then the redirection of $foo to $*foo on temporized variable would be wrongish, I think

[15:12] <TimToady> since it would find the lexical again first

[15:12] <TimToady> so maybe it redirects to $+foo instead

[15:12] <TimToady> but then, what if the temp was done in the current scope?

[15:13] <TimToady> which I think argues that temp must also set up a contextual mirror in the current scope, and then we redirect to $*foo

[15:14] <TimToady> so in the case of "my $x; temp $x" in the same scope, we can probably just mark the my as contextual to begin with instead of complaining

[15:14] * TimToady is getting mushbrain, need more coffee

[15:16] <TimToady> I do like that this seems to be getting closer to the p5 local model while extracting out the damaging component of global state

[15:17] <TimToady> makes me feel happier about emulating p6 context with locals in p5

[15:17] <TimToady> and maybe p5 could move to this model someday

[15:17] <TimToady> and then get localized my vars :)

[15:24] * TimToady suspects that coffee will only help a little with TimToady's kind of mushbrain...

[15:25] <[particle]> a long walk and lots of wires might help

[15:31] <TimToady> coffee already gets me wired, and makes me walk down the hall occasionally

[15:32] *** alanhaggai left
[15:47] *** justatheory left
[15:49] *** adamkennedy left
[15:58] *** rindolf joined
[15:58] *** Lorn__ left
[15:58] *** zamolxes left
[16:07] *** Exodist joined
[16:21] *** justatheory joined
[16:25] *** cosimo left
[16:29] *** betterworld left
[16:30] *** mncharity joined
[16:41] *** Deepi left
[16:41] *** pyrimidine joined
[16:42] *** pmurias joined
[16:43] <pmurias> ruoso: hi

[16:43] <rakudo_svn> r31757 | particle++ | [rakudo] [perl #59570] $*OS and $*EXECUTABLE_NAME globals initial implementation

[16:43] <rakudo_svn> r31757 | particle++ | ~ add support for $*OS, $*OSVER, $*EXECUTABLE_NAME

[16:43] <rakudo_svn> r31757 | particle++ |   modified and expanded from azawawi++'s original code

[16:47] <mncharity> rakudo: say [$*OS, $*OSVER, $*EXECUTABLE_NAME]

[16:47] <lambdabot> mncharity: You have 1 new message. '/msg lambdabot @messages' to read it.

[16:47] <p6eval> rakudo 31667: OUTPUT[Null PMC access in get_string()␤current instr.: 'parrot;P6metaclass;add_parent' pc 95 (runtime/parrot/library/P6object.pir:126)␤]

[16:47] <mncharity> masak: :)

[16:48] * mncharity notes 31667 seems << than 31757

[16:49] * moritz_ should take a look at evalbot

[16:51] *** Bzek left
[16:51] <moritz_> rakudo needed a 'make clean', it seems

[16:51] <moritz_> rebuilding now

[16:53] <moritz_> rakudo: say [$*OS, $*OSVER, $*EXECUTABLE_NAME].perl

[16:53] <p6eval> rakudo 31667: OUTPUT[["./parrot", "./parrot", "./parrot"]␤]

[16:54] <moritz_> [particle]: do you want a ticket? ;-)

[16:54] <[particle]> hrmm, what happened there... oh, i think i know

[16:54] <[particle]> no ticket

[16:58] <[particle]> moritz++

[16:58] <rakudo_svn> r31758 | particle++ | [rakudo] silly me (particle--), i forgot to create a new string every time

[16:59] <rakudo_svn> r31759 | particle++ | [rakudo] refactor package definition exit code based on feedback from pmichaud++

[17:00] <moritz_> actually it's mncharity++ for detecting ;)

[17:00] <[particle]> rakudo: say [$*OS, $*OSVER, $*EXECUTABLE_NAME].perl

[17:00] <p6eval> rakudo 31757: OUTPUT[["./parrot", "./parrot", "./parrot"]␤]

[17:01] * [particle] kicks p6eval :P

[17:01] *** Lorn joined
[17:02] <moritz_> [particle]: no need for kicking, parrot is rebuilt every full hour on p6eval's server

[17:03] <[particle]> hourly... good to know. on the hour?

[17:03] <moritz_> yes

[17:03] <[particle]> rakudo: say [$*OS, $*OSVER, $*EXECUTABLE_NAME].perl

[17:03] <p6eval> rakudo 31757: OUTPUT[["linux", "", "./parrot"]␤]

[17:03] <[particle]> good, except the version is wrong

[17:03] <moritz_> [particle]++

[17:04] <[particle]> s/version/revision/

[17:04] <moritz_> where should parrot get the os version from?

[17:04] <[particle]> it gets it during config, i think

[17:04] <[particle]> from what, i'm not sure

[17:04] <moritz_> uname -a?

[17:04] <moritz_> or more like /etc/debian_version?

[17:04] <[particle]> maybe on linux

[17:04] <[particle]> not on windows :)

[17:05] <[particle]> anyway that $* stuff is compiler-specific

[17:05] <[particle]> so, it's definitely not a rakudo bug, it's a parrot bug

[17:06] *** rindolf left
[17:07] <[particle]> did spectest_regression get slow again, or is it just so many more tests?

[17:09] <moritz_> I think mostly more tests

[17:09] <moritz_> http://rakudo.de/progress.png

[17:09] <moritz_> just look at the total

[17:09] <[particle]> yeah

[17:15] *** jferrero left
[17:15] <moritz_> [particle]: spectest_regression is up to ~9m CPU time again, which is roughly where it was before precompiled modules

[17:16] *** PZt left
[17:16] <[particle]> ok, that's how it felt to me (i never remember to look at the time at the end)

[17:16] *** cotto joined
[17:17] *** cotto left
[17:17] <moritz_> due to parallel testing I'm now at 5m20 real time

[17:17] <[particle]> how do i enable that?

[17:17] <moritz_> (2 CPUs; I need to get more of them)

[17:17] <[particle]> i have 4, hoping for 8 by next year

[17:17] <moritz_> TEST_JOBS=2 make spectest_regression

[17:17] <moritz_> (on linux)

[17:17] <moritz_> ok, maybe TEST_JOBS=5 for you ;)

[17:18] <moritz_> you might need a fairly recent version of TAP::Harness on windows

[17:19] <mncharity> perl6: "a".length

[17:20] <p6eval> rakudo 31760: OUTPUT[Method 'length' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 21 (EVAL_10:13)␤]

[17:20] <p6eval> ..pugs: OUTPUT[*** No such method in class Str: "&length"␤    at /tmp/b6hbFJ9DW3 line 1, column 1 - line 2, column 1␤]

[17:20] <p6eval> ..elf 22525: RESULT[1␤]

[17:20] <pugs_svn> r22526 | pmurias++ | [mildew] say "Hello World" compiles correctly

[17:20] <moritz_> length is a banned word ;)

[17:23] <mncharity> :)   now gone from elf.   The current 1 minute CL elf compile is a pain.

[17:24] * moritz_ wonders if mncharity has ever built gcc ;)

[17:25] <mncharity> lol

[17:25] *** khisanth_ joined
[17:25] <moritz_> perl6: print "ab".chars

[17:25] <p6eval> elf 22526, pugs, rakudo 31760: OUTPUT[2]

[17:25] <moritz_> perl6: print "ab".codes

[17:25] <p6eval> elf 22526, pugs: OUTPUT[2]

[17:25] <p6eval> ..rakudo 31760: OUTPUT[Method 'codes' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 21 (EVAL_12:13)␤]

[17:25] <mncharity> many, many times.  but I'd not consider the gcc build process a model of sanity.

[17:25] *** Khisanth left
[17:26] <mncharity> (at least as of some years aog()

[17:26] *** khisanth_ is now known as Khisanth

[17:26] <mncharity> *ago

[17:29] <mncharity> perl6: print "切".codes

[17:29] <p6eval> rakudo 31760: OUTPUT[Method 'codes' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 21 (EVAL_12:13)␤]

[17:29] <p6eval> ..elf 22526, pugs: OUTPUT[1]

[17:29] <mncharity> perl6: print "切".bytes

[17:29] <p6eval> elf 22526, pugs: OUTPUT[3]

[17:29] <p6eval> ..rakudo 31760: OUTPUT[Method 'bytes' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 21 (EVAL_12:13)␤]

[17:30] <moritz_> perl6: my $s = "A\c[COMBINING ACUTE ACCENT]"; say $s.codes; say $s.chars; say $s.graphs;

[17:30] *** pmurias left
[17:31] <p6eval> elf 22526: OUTPUT[Can't locate String/Multibyte.pm in @INC (@INC contains: /etc/perl /usr/local/lib/perl/5.10.0 /usr/local/share/perl/5.10.0 /usr/lib/perl5 /usr/share/perl5 /usr/lib/perl/5.10 /usr/share/perl/5.10 /usr/local/lib/site_perl .) at ./elf_f line 89.␤ at ./elf_f line 3861␤27␤27␤]

[17:31] <p6eval> ..rakudo 31760: OUTPUT[Method 'codes' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 42 (EVAL_11:20)␤]

[17:31] <p6eval> ..pugs: OUTPUT[2␤1␤1␤]

[17:31] <TimToady> wow, I didn't expect pugs to get that right

[17:32] * moritz_ neither

[17:32] <TimToady> I wonder if it \c canonicalized to NFC

[17:33] <TimToady> pugs:  my $s = "-\c[COMBINING ACUTE ACCENT]"; say $s.codes; say $s.chars; say $s.graphs;

[17:33] <p6eval> pugs: OUTPUT[2␤1␤1␤]

[17:33] <rhr> pugs has a .graphs in prelude that has an incomplete list of combining chars

[17:33] <moritz_> perl6: my $s = "A\c[COMBINING ACUTE ACCENT]"; say $s.codes; say $s.chars; say $s.graphs;

[17:33] <p6eval> rakudo 31760: OUTPUT[Method 'codes' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 42 (EVAL_11:20)␤]

[17:33] <p6eval> ..elf 22526: OUTPUT[27␤27␤27␤]

[17:33] <p6eval> ..pugs: OUTPUT[2␤1␤1␤]

[17:33] <moritz_> ah, elf doesn't interpolate \c 

[17:41] <ruoso> TimToady, hmm... I was thinking earlier that you were meaning to merge $*foo and $+foo as being the same thing... which would mean dropping one of the syntaxes 

[17:43] <ruoso> TimToady, I was thinking on 'temp $x' declaring a local name '$x' that points to the contextual variable... which would be kinda the same of 'my $x is context<rw>'

[17:45] <ruoso> then in that scope, you could either use '$x' or '$*x' but to access a temp variable not declared "here", you would always need the '$*x' syntax

[17:45] <mncharity> re elf \c , more generally, the old STD didn't really support strings, so strings are kludged in elf.  no interpolation in general.  with new STD_blue, can do better.

[17:45] * ruoso .oO(is there going to be a STD_green?) ;) ;) ;)

[17:46] <TimToady> green is my favorite color, though I like purple better

[17:46] <mncharity> STD_blue is a hopefully minimal wrapper around gimme5.  written in p5.  STD_something is a version written in p6.  then the parser disappears into elf.

[17:47] <TimToady> have you looked at viv?  it spits out something ASTish now

[17:48] <TimToady> and at least once I successfully spat out the VAST for STD.pm

[17:48] <TimToady> for some definition

[17:48] *** ab5tract joined
[17:50] *** tomyan left
[17:52] <ruoso> TimToady, btw... I think I have my mind clearer now... and I think a good model could be dropping either '$*foo' or '$+foo', as both would mean the same thing, that variable would start looking for contextual vars *in the current scope*, and falling to the callers... 'temp $x' would just be a synonim for 'my $x is context<rw>'... and I think that's all 

[17:53] <ruoso> I think that addresses all the issues you raised...

[17:54] <TimToady> not if the intent of temp $foo is to override someone's use of $foo without them having to say $*foo

[17:55] <TimToady> I'm looking for something a little closer to the spirit of local

[17:56] *** mberends joined
[17:57] <ruoso> TimToady, "someone" where?

[17:57] <ruoso> in an inner scope? or in an inner caller?

[17:57] <TimToady> in the lexical scope of the original my $foo but not in the lexical scope of the temp $foo

[17:58] <ruoso> hmmm...

[17:58] <TimToady> the purpose of temp is different than the purpose of "is context"

[17:58] <TimToady> temp overrides the meaning of the root variable without changing its scope

[17:59] <TimToady> we need at least a bit in that variable that says, "oops, look in the dynamic scope instead"

[17:59] <ruoso> it's weird the idea of a code being able to mess with the closure's variables

[17:59] <mncharity> TimToady: viv?  no, I haven't - awesome.  

[17:59] <ruoso> I mean... if that variable is marked as contextual, ok...

[18:00] <ruoso> but it looks like a huge mess to support that for non-contextual variables

[18:01] <rakudo_svn> r31762 | particle++ | [rakudo] make branch explicit in 'variable' action method

[18:01] <ruoso> because that would be automagically turning a 'my $foo' into 'my $foo is context'

[18:02] <ruoso> TimToady, is there some use case for this specific feature?

[18:02] <TimToady> well, the overhead is not on that end, but on the rvalue end that has to check the bit and redirect

[18:03] <TimToady> not sure, but you're not implementing temp correctly if it doesn't change the root variable's meaning everywhere that can see it

[18:04] <ruoso> *that can see it*

[18:04] <ruoso> you said well..

[18:04] <TimToady> lexically

[18:04] <ruoso> 'my $x' is *not* visible from some scope that is not an inner scope

[18:04] <ruoso> 'my $x' is *not* visible by an inner "caller"... just by an inner "scope"

[18:05] <ruoso> you can't say 'temp $x' in that case, because 'my $x' is not visible to you...

[18:06] <TimToady> but I can call into a routine that is in the tree of $x, and it can temporize during that call, even though I'm not called by the code that declared $x in the first place

[18:07] <ruoso> that looks like p5 local, meaning that it's treating the variable as if it were global

[18:07] <TimToady> anyway, ETOOMANYCONVERSATIONS for the moment, gotta concentrate on #parrot

[18:10] <ruoso> btw... if both codes can see the variable, why can't the code just set a value for that variable, and reset it to the original value when exitting that scope?

[18:18] *** kjs_ joined
[18:19] <Gothmog_> Hm. What about refs to that variable? And what about big objects?

[18:23] *** riffraff joined
[18:23] <Gothmog_> So if you have a capture of your outer $x, I suppose it should still point to the outer $x after you temp $x.

[18:23] <Gothmog_> Just thinking loud.

[18:27] *** icwiener left
[18:31] *** tewk joined
[18:31] *** riffraff left
[18:34] <ruoso> Gothmog_, in theory yes... 'temp' would just mess with future lookups of the variable...

[18:38] <Gothmog_> So if it's that way, and you just overwrite the variable, captures wouldn't work.

[18:40] <ruoso> what do you mean?

[18:42] <mncharity> TimToady:  re viv, yay! :)

[18:43] <mncharity> so STD_blue becomes a thin wrapper around viv.

[18:44] <Gothmog_> If you overwrite the value at the original location of my $x when you write temp $x, and your capture is in fact a pointer to that original location, it would suddenly contain the inner $x, and it would be virtually impossible to work around that.

[18:45] <Gothmog_> Of course, everything under the assumption that a capture of the outer $x is supposed still to contain the outer one when you do temp $x.

[18:46] <Gothmog_> gtg

[18:46] <Gothmog_> bye!

[18:49] *** azawawi joined
[18:49] <azawawi> hi

[18:49] <moritz_> hi azawawi ;)

[18:50] <azawawi> moritz_: how r u?

[18:50] *** alanhaggai joined
[18:50] <moritz_> distracted

[18:51] <azawawi> rakudo: 1.unpolar(0)

[18:51] <p6eval> rakudo 31762: RESULT[1+0i]

[18:52] <azawawi> rakudo: cis(0)

[18:52] <p6eval> rakudo 31762: RESULT[1+0i]

[18:52] <azawawi> rakudo: cis(0) == 1.unpolar(0)

[18:52] <p6eval> rakudo 31762: RESULT[Bool::True]

[18:54] *** alanhaggai left
[19:20] *** pmurias joined
[19:25] <pugs_svn> r22527 | putter++ | [viv] Simplify using viv as a library - if($0 eq __FILE__).

[19:29] <pugs_svn> r22528 | putter++ | [elfish/on_sbcl] Still struggling towards self compilation.

[19:29] <pugs_svn> r22528 | putter++ | [elf_h] Tweaks.

[19:29] *** pmurias left
[19:31] *** mncharity left
[19:33] *** rdice joined
[19:39] <azawawi> moritz_: is there a new parrot release on the way?

[19:40] <moritz_> azawawi: there's a parrot release every month

[19:41] <azawawi> moritz_: cool

[19:45] *** rdice left
[19:58] <pugs_svn> r22529 | ruoso++ | [smop] removing old_src dir, since its been a while since anyone touches it

[19:58] *** jferrero joined
[20:00] *** ab5tract left
[20:01] *** pmurias joined
[20:02] <pmurias> ruoso: have you seen the version of lexical scope converted to the RI DSL

[20:02] * pmurias finally has internet in his room ;)

[20:03] <ruoso> :)

[20:03] <ruoso> pmurias, yeah... I just saw it...

[20:03] <ruoso> it looks great...

[20:04] <ruoso> and yeah... I know I'm not using it yet ;), but that was because the ri I created was copy'n'pasted from other one

[20:04] <pmurias> the RI DSL has only became usable in that commit

[20:05] *** justatheory left
[20:05] <ruoso> yeah... it indeed looks much better

[20:06] <ruoso> have you seen test/36?

[20:07] <ruoso> pmurias, I think 'sub dispatch' will be needed sooner than I expected...

[20:07] <ruoso> but that's a good thing...

[20:07] <ruoso> because it means that the code will be closer to actual Perl 6

[20:07] <ruoso> that came with the realization that the prelude should be populated by the things in src-s1p

[20:07] <pmurias> 'sub dispatch' = ?

[20:08] <ruoso> pmurias, yeah... how &map, &infix:<+> work

[20:09] <ruoso> and in fact, 'multi sub dispatch' is what I mean

[20:09] <ruoso> since &infix:<+> will have an important variant for (int,int)

[20:10] <ruoso> that's why I started AdhocSignature...

[20:11] <ruoso> to allow the signatures in src-s1p to be compiled to blocks of m0ld code

[20:11] <ruoso> that will both reply to ACCEPTS and to BIND

[20:11] <ruoso> remember the idea of having the signature translated to the start of the routine?

[20:11] <ruoso> that's an improved version of that ;)

[20:13] <pmurias> is signature introspection required for something?

[20:14] <ruoso> some introspection is...

[20:14] <ruoso> .arity should probably be added to AdhocSignature

[20:15] *** pmichaud_ is now known as pmichaud

[20:15] <ruoso> but I don't think full introspection is really needed...

[20:15] <ruoso> at least not for start

[20:15] <moritz_> .count is needed for map, isn't it?

[20:15] *** pmurias left
[20:15] *** pmurias joined
[20:16] <ruoso> moritz_, wasn't 'arity' used for that?

[20:16] <moritz_> ruoso: if you want @list.map( -> $x? { 2 * $x } ); to pass an argument to the block, you need .count

[20:17] <ruoso> hmm...

[20:18] <ruoso> alright then... .arity and .count

[20:18] <moritz_> but that example is nonsense

[20:18] *** Caelum joined
[20:18] * ruoso was trying to figure out what that meant

[20:19] <moritz_> perhaps if we had a rand() that could be both unary and nullary

[20:19] <moritz_> like perl 5's

[20:19] <ruoso> sub rand ( $i? = 1 )

[20:19] <moritz_> then @list.map(&rand) would behave differently, depending on wheter you use .count or .arity

[20:20] <moritz_> ruoso: exactly

[20:20] <ruoso> anyway... adding both shouldn't be a trouble

[20:21] <TimToady> for things that work left to right, it makes some sense to use .arity and bind the extra params only if they're there

[20:21] <TimToady> for right-to-left things like the new ..., it really needs .count

[20:21] <TimToady> since *@_ is arity 0

[20:21] <TimToady> but count *

[20:22] <TimToady> (yes, the spec on ... is inaccurate there)

[20:22] <ruoso> pmurias, anyway... I think we should consider translating as much as we can to the RI DSL, since that will allow us a nicer transition to supporting non-native captures and identifiers

[20:23] <TimToady> hmm, I wonder if we can play games with an invocant declaration...

[20:23] <TimToady> for map -> $prevcap: $_ { $$prevcap + $_ } 

[20:24] <pmurias> ruoso: ;) 

[20:24] <TimToady> but what would you do the first time?  O_o

[20:24] <moritz_> TimToady: pass a capture to the entire array as invocant? ;)

[20:25] <moritz_> not that it's useful in any way ;)

[20:25] <ruoso> TimToady, is it possible to have invocant declaration in a sub? what does it point to? 

[20:26] <TimToady> would presumably depend on what kind of capture you try to bind to it

[20:26] <TimToady> if you're binding a capture with an invocant, it's obvious

[20:26] <TimToady> if one without, maybe first arg

[20:26] <ruoso> hmm.... that brings us back to an old discussion...

[20:26] <moritz_> isn't that old, deprecated method fallback?

[20:27] <ruoso> the signature of .postcircumfix:<( )>

[20:27] <TimToady> yes, but I have to commute to work before we can rehash that.  :)

[20:27] <TimToady> moritz_: we're talking about how you write a method dispatcher in p6 without assuming methods

[20:27] * ruoso stands for '.postcircumfix:<( )> ($capture)' instead of '.postcircumfix:<( )> (|$capture)'

[20:27] <TimToady> I think &method should be callable as a subroutine

[20:28] <TimToady> anyway, gotta rn

[20:28] <TimToady> *run

[20:29] * ruoso planning on how to implement multi sub

[20:30] <pmurias> ruoso: re multi sub dispatch its not difficult to write a simple version of it, but having it fast is complicated 

[20:30] <ruoso> pmurias, I'd be happy with "good enough"

[20:31] <ruoso> for some reason, I think SMOP won't be that slow 

[20:31] *** rdice joined
[20:32] <ruoso> (even without optimizations, I mean)

[20:32] *** kjs_ left
[20:32] *** rdice left
[20:32] <ruoso> pmurias, most importantly, I'm ok with having a first implementation that will be replaced somewhere in the future

[20:32] <pmurias> the runloop as done is propably a huge performance hit

[20:34] <pmurias> ruoso: do we really need multis now? having mildew compile more stuff could be a better idea

[20:34] <ruoso> pmurias, the thing is that for mildew to compile correctly, we need multis

[20:34] <ruoso> otherwise we will need to rework it in a very near future

[20:36] <ruoso> I mean... 'say "Hello"' is a multi dispatch

[20:36] <ruoso> we can have mildew working before multi, but it will be simply wrong...

[20:36] *** pyrimidine left
[20:36] <ruoso> and we will need multis for the code in src-s1p

[20:38] <moritz_> diakopte1: ping

[20:40] *** zamolxes joined
[20:41] <pmichaud> class Foo { ... };    say Foo.WHAT;    # "Foo\n"

[20:41] <pmichaud> module Bar { ... };   say Bar.WHAT;    # ???

[20:41] <ruoso> pmichaud, 'cannot find class Bar in the current scope'

[20:42] <pmurias> ruoso: you can look at how jonathan implemented multis in parrot

[20:43] <ruoso> pmurias, good point...

[20:43] *** justatheory joined
[20:43] *** Jedai left
[20:44] *** Jedai joined
[20:46] *** jferrero left
[20:46] <ruoso> pmichaud, I was trying to find in the specs, but I couldn't... TimToady said someday in the irc that Bar.something always look for a class... if you want to use it as a package you need to use ::

[20:47] <pmichaud> ruoso: thanks, that's a big help.

[20:48] <pmichaud> ruoso++

[20:49] <ruoso> :)

[20:54] <azawawi> moritz_: regarding RT #56226 - (roots.pl), did u mean to use unpolar instead of polar in @results?

[20:54] <pmurias> ruoso: is there anything else missing before mildew can start compiling stuff which runs correctly?

[20:54] *** pyrimidine joined
[20:55] <moritz_> azawawi: sorry, don't have concentration at the moement... care to reply to the ticket?

[20:56] <ruoso> pmurias, we need P6Meta.pm to be completed

[20:56] <ruoso> unless you consider using only pureprototypehow

[20:57] <ruoso> pmurias, compiling P6Meta.pm seems to be the target for mildew, I think

[20:57] <ruoso> (the first target, of course... many others to come later ;)

[20:58] <azawawi> moritz_: done...

[20:58] <ruoso> pmurias, that means also implementing the Capture Expansion

[20:58] <ruoso> pmurias, to support foo(|@bar)

[20:59] <ruoso> then gather/take

[20:59] <ruoso> feed operators

[20:59] <ruoso> pretty much what's in the ROADMAP

[20:59] <pmurias> P6Meta could be simpilified

[21:00] <ruoso> pmurias, seems fine to me..

[21:00] <ruoso> but our next major milestone is to have both P6Meta.pm and Object.pm compiled

[21:01] <ruoso> if we can simplify them a little bit, I think there's nothing wrong with it (as long as they do what they are supposed to do)

[21:02] <ruoso> but one thing that's missing on P6Meta is "method dispatch"

[21:02] <ruoso> I was hoping someone could write it..

[21:02] * ruoso have to run...

[21:02] <ruoso> pmurias, I'll try to get back online asap... 

[21:03] * ruoso will backlog later...

[21:03] *** ruoso left
[21:06] <pmurias> sleep&

[21:06] *** pmurias left
[21:08] *** mberends left
[21:09] *** zamolxes left
[21:13] *** TJCRI left
[21:15] *** pyrimidine left
[21:17] *** xuser left
[21:20] *** iblechbot left
[21:27] <pugs_svn> r22530 | moritz++ | [irclog] point r\d+ in #perl6 to SVN::Web instead of trac, because trac's CSS

[21:27] <pugs_svn> r22530 | moritz++ | is a 404, and I don't know how to fix that.

[21:28] <moritz_> that worked.

[21:41] *** justatheory left
[21:42] *** justatheory joined
[21:47] *** ruoso joined
[21:49] *** pyrimidine joined
[21:50] *** pyrimidine left
[22:09] *** Lorn__ joined
[22:14] *** jferrero joined
[22:18] *** alester left
[22:19] <ruoso> cool... parrot implementation of multis is pretty close to what I had thought also...

[22:22] *** Lorn left
[22:22] *** cognominal joined
[22:22] *** Lorn_ left
[22:24] *** ab5tract joined
[22:26] *** wknight8111 joined
[22:28] *** sri_work joined
[22:33] *** jferrero left
[22:33] *** cls_bsd left
[22:50] <azawawi> moritz_: roots() and polar() are now implemented in any-num.pir (RT #56226)

[22:52] *** azawawi left
[22:53] *** justatheory left
[22:54] *** Alias_ joined
[22:56] *** plash_ joined
[23:10] *** araujo left
[23:14] <meppl> good night

[23:18] *** meppl left
[23:36] *** Chillance joined
[23:42] *** Lorn__ left
[23:44] *** Kitchy joined
[23:45] <Kitchy> If the Perl 5 to Perl 6 translator that

[23:45] <Kitchy> ...I mean...

[23:46] <Kitchy> If the Perl 5 to Perl 6 translator that's been discussed actually happens, would we be able to put an end to Perl 5?

[23:46] *** justatheory joined
[23:47] <Kitchy> Because all I've heard was that Perl 5 will still be around. Maybe it doesn't need to be.

[23:47] <pmichaud> why shouldn't it be?  Perl 5 is excellent.

[23:48] <Kitchy> If you could do it with just Perl 6 installed, you'd be able to use it.

[23:48] <Kitchy> It would be like a perl 5/6 combo that's billed as Perl 6 but works with Perl 5 too.

[23:48] <ab5tract> sounds like a waste of time

[23:49] <Kitchy> It kind of sounded like Perl 6 will have such a translator anyway.

[23:49] <pmichaud> Kitchy: sure, it probably will.  But we're not ones to believe in "only one way of doing things"  :-)

[23:51] <Kitchy> If the translator is easily enough invoked from within Perl 6, it's not really limiting and dedicated Perl 5 could be discontinued.

[23:51] <pmichaud> Perl 5 will be "discontinued" when people decide they no longer need it.  Personally, I think that may be a while.

[23:54] <ab5tract> wasn't there going to be a perl 5 for parrot?

[23:57] <ab5tract> anyway, lots of perl 5'ers seem to also love hating perl 6. so threatening (or even implying) to 'discontinue' their choice platform probably wouldn't go over too well.

[23:57] <ab5tract> not to mention: what's the necessity of it anyway?

[23:58] <Kitchy> I mean requiring them to install Perl 6 and do something to invoke Perl 5 if they want to use it.

[23:58] *** justatheory left
[23:58] <TimToady> this will all work itself out over the long run.  we need a story for those who want to migrate, and a story for those who don't.

[23:59] <TimToady> those need not be the same story

[23:59] *** Exodist left
[23:59] <pmichaud> I like the notion of "story" here -- very good.

