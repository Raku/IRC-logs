[00:00] <rakudo_svn> r33212 | jonathan++ | [rakudo] Add another spectest.

[00:01] <jnthn> Hmm. I guess you should be able to do things like "&my_sub does Foo;".

[00:01] <TimToady> and rakudo will presumably allow us to attach info to methods better than p5 does

[00:02] <TimToady> not sure if we can say "call this method, but not really, just return its property..."

[00:02] <jnthn> Should do. We might have a little fun with constant vs non-constant PMCs along the way. :-|

[00:02] <TimToady> in p5 I guess that's a ->can()

[00:02] <jnthn> Oh yes, hmm. How to get a sub props... :-)

[00:02] <jnthn> &foo.SUB.prop_name

[00:03] <TimToady> well, can certainly fake that up in rakudo like we do for STD currently, if need be

[00:03] <jnthn> Sure.

[00:03] <jnthn> Shouldn't be too hard.

[00:04] <TimToady> &foo.prop_name isn't the problem, it's finding the right &foo to call it on :)

[00:04] <jnthn> Ahhh...yes.

[00:04] <jnthn> OK.

[00:05] <TimToady> my token's lexer is based on some other set of tokens, many of which might come from other grammars, treated as virtual methods

[00:06] <TimToady> that's the thing that STD is very careful to do correctly

[00:06] <jnthn> It's essentially just inheritance and composition, though?

[00:06] <jnthn> With the overriding etc that comes with it?

[00:07] <TimToady> yes, but the composition is hairy since it has to work the patterns in parallel to preserve LTM

[00:07] <TimToady> RE::sequence::longest has to work rather hard at that

[00:08] <TimToady> since it has to do cross product of what might match before and what might match after

[00:08] <jnthn> Ouch.

[00:09] <jnthn> I'm glad you worked out how to do this... :-)

[00:09] <TimToady> it would be very easy to define a lexer with millions of tokens, so the grammar writer needs to be a bit careful

[00:10] <TimToady> at the moment I've got STD limited to expecting 8299 tokens where a term is expected

[00:10] <TimToady> but meta-operators tend to multiple that

[00:10] <jnthn> That's why we're not letting those be nested recursively without predeclaring, right?

[00:11] <TimToady> not letting them nest at all, at the moment

[00:11] <TimToady> if you predeclare, it's just an ordinary operator

[00:11] <TimToady> as far as the lexer is concerned

[00:12] <TimToady> assuming you declare it infix or some such

[00:12] <jnthn> So you can do [*] and >>*<< but not [>>*<<]?

[00:12] <jnthn> If that last one even makes sense...

[00:12] <TimToady> you can nest different types

[00:12] <jnthn> Ah, OK. But not many of the same.

[00:12] <TimToady> so [>>*<<] is allowed

[00:12] *** ZuLuuuuuu joined
[00:12] <TimToady> but not >>X>>*<<X<<

[00:13] <TimToady> and, in fact, STD accepts [>>*<<]

[00:13] <jnthn> I think I'm glad of that from a language design point of view too. :-)

[00:13] <TimToady> well, LTM basically can't handle left recursion, is all

[00:14] <TimToady> not if you're going to enumerate all possible token patterns

[00:14] <jnthn> Sure. But I'm not sure there's so many people who could look at  >>X>>*<<X<< and be like "oh yeah, it does..."

[00:14] <jnthn> :-)

[00:14] <TimToady> agree, it's probably a feature

[00:14] <jnthn> So I don't think it's a big loss not being able to nest.

[00:16] <jnthn> Thanks for all of the answers/explanations. I'm sure I'll be back for more once I start implementing...

[00:16] <TimToady> it's enough that it allows [\>>minmax<<]<<

[00:16] <TimToady> 'k, I may be spottily connect over the next two weeks, given I'm going around the world

[00:17] <TimToady> *connected

[00:17] <jnthn> That sounds like the tiring kind of fun I like. :-)

[00:17] <jnthn> Conferences, vacation, boht?

[00:17] <jnthn> *both

[00:17] <TimToady> Australia, then Amsterdam

[00:17] <jnthn> That's a lot of flying.

[00:17] <TimToady> conferences, bit of sightseeing in Australia

[00:17] *** Exodist left
[00:17] <TimToady> I'm in denial

[00:18] <TimToady> and I'm trying to figure out if I lose a day or gain a day in my life that way...

[00:18] *** vixey left
[00:19] <jnthn> I would say just think, Australia is probably nice and warm right now. But you're not living in a cold place. :-)

[00:19] <TimToady> it'll pretty close to the same

[00:19] <TimToady> but probably a bit wetter there

[00:19] <jnthn> Oh, I can never figure out timezone stuff too well.

[00:19] <jnthn> When I travelled across Russia, all the train tickets have Moscow time on them. So I kept my watch on that the whole trip in an effort not to mess things up.

[00:20] <jnthn> It was successful in that sense, but it menat explaining a few things to confused Russians who asked me the time. :-)

[00:21] <TimToady> must be strange for the sun to rise at 1:00 am...

[00:21] <TimToady> well, far enough north, it does that anyway  :)

[00:21] <jnthn> Ah, I was pretty far south at that point in the journey (Vladivostok).

[00:21] <TimToady> but it might explain the cavalier attitude toward time zones

[00:22] <TimToady> since no amount of daylight savings time can make up for that much swing

[00:22] <jnthn> China is a curiosity, since they have the same time zone across the whole country.

[00:22] <TimToady> China doesn't have that excuse though

[00:23] <jnthn> All the way west in Tibet, it feels a bit odd.

[00:23] <TimToady> "We don't care.  We don't have to.  We're the phone company."

[00:24] <TimToady> takeoff on an old phone company ad we used to hear

[00:24] <jnthn> Sounds like phone companies.

[00:24] <TimToady> well, the original was "We care.  We have to.  We're the phone company."

[00:24] *** pcbuetow joined
[00:25] <TimToady> anyway, there's a kind of monopoly in China, you might say

[00:25] <jnthn> If they're anything like most phone companies I've dealt with, it's a rather uncaring definition of caring...

[00:25] <TimToady> hence the parody

[00:25] <jnthn> Yes.

[00:26] <jnthn> When the advertising you think will be good, backfires. :-)

[00:26] <TimToady> it doesn't matter how hard you think about how to name your kids; junior highers will find a way to make fun of anything...

[00:26] <jnthn> In the UK, people seemed to take to giving the train companies alternative names.

[00:27] <jnthn> "Worst Late Western"

[00:27] * jnthn doesn't miss this aspect of UK life at all

[00:27] <TimToady> yeah, we used to fly on Hughes Air Worst

[00:27] <TimToady> I'm flying to Oz on Untied

[00:28] <jnthn> I flew with them to the Parrot Summit.

[00:28] *** ab5tract joined
[00:28] <jnthn> I've had better, I've had worse.

[00:28] <TimToady> they're a bit on the sardine side

[00:29] *** km2 left
[00:29] <jnthn> Is it direct flight down to Oz?

[00:29] <TimToady> I believe so

[00:30] <jnthn> Ah, not so bad.

[00:30] <jnthn> Oz from here is a long, long way.

[00:30] <jnthn> Can't do it direct. At least, not without a touchdown for refueling somewhere.

[00:32] <TimToady> 14h 27m

[00:32] <jnthn> Longer than any I've done yet.

[00:32] <TimToady> I guess it's not that much worse than the 11h to Japan

[00:32] <jnthn> I figure once it gets beyond 10 hours, it's just looooong.

[00:34] <TimToady> I vote for suborbital.

[00:35] <jnthn> Hey, supersonic wouldn't be so bad...

[00:36] <TimToady> well, hypersonic maybe

[00:36] <jnthn> That'd be awesome, but if we didn't make supersonic affordable...

[00:36] <TimToady> slow enough to keep a bit of gravity

[00:36] <jnthn> Or economical, anyways...

[00:36] <jnthn> On Japan, I'm pondering trying to make YAPC::Asia next year, provided there is one.

[00:37] <TimToady> but if the can fly it back and forth 5 times in the same time as the old plane flies once...

[00:37] <TimToady> *they

[00:37] <jnthn> Sure, but I think the problem was more maintenance costs/wear and tear etc...

[00:37] * jnthn has never been to Japan

[00:37] *** pbuetow left
[00:37] <TimToady> I guess I've been there five times now

[00:38] *** araujo joined
[00:38] <jnthn> Worth it?

[00:38] <jnthn> I guess if you've been five times it can't be so bad... :-)

[00:40] <TimToady> I've enjoyed it immensely, but then I'm a crazy japanophile...

[00:40] <jnthn> My biggest fear, is that I don't eat fish/sea food.

[00:40] <jnthn> Which is pretty much everywhre.

[00:40] <jnthn> But I guess it's possible to get by without eating that.

[00:40] <TimToady> well, neither do I, because I'm allergic to it

[00:40] <jnthn> Ah, OK.

[00:41] <TimToady> it's possible to get by

[00:41] <jnthn> I'm not allergic, I've just never been able to find it likable.

[00:41] <jnthn> I've tried a few times, in various places, and just can't enjoy it at all.

[00:41] <TimToady> alas, I like it...

[00:41] <TimToady> got any other allergies you'd like to trade?

[00:44] <jnthn> I haven't got much in the way of allergies. Just various pigmentation problems from different sides of the family.

[00:45] <jnthn> My eyesight problem is because I lack sufficient pigment in my retinas, meaning a bunch of the rod and cones are defective, which basically means I see in low resolution. Though in full color.

[00:45] <jnthn> (Thus why the trains always running late in the UK drove me nuts. I didn't have much choice but to use them...)

[00:46] <TimToady> huh.  everything wrong with my eyes has been in front, and hence fixable, fortunately

[00:46] <jnthn> Yeah. This one is unfixable.

[00:46] <jnthn> However, thankfully, it's stable.

[00:46] *** japhb__ left
[00:46] <TimToady> well, I probably ought to pretend to work...

[00:46] <jnthn> I wear glasses for a minor lens issue (they don't help with the retina one). But more so for the color-change lenses...

[00:47] <jnthn> Yeah, I guess I ought to pretend to sleep.

[00:47] * jnthn hasn't slept normal hours since the Parrot Summit

[00:47] <TimToady> night

[00:47] <jnthn> night

[00:51] *** japhb joined
[00:52] *** DemoFreak left
[01:06] <wayland76> Btw, re: warmth in Australia, it's not cold any more, but it's not that warm either

[01:07] <wayland76> ...although I'm near Melbourne, and people talk about "Melbourne weather" :)

[01:10] <wayland76> Re: junior higher's mocking names, I know a family who had division of labour in choosing names for their children; the mother would suggest names, and the father tried his best to mock them

[01:10] <wayland76> When they came up with something less mockable, they used that

[01:14] *** ZuLuuuuuu left
[01:20] *** smallfish joined
[01:22] *** smg left
[01:32] *** PZt left
[01:34] *** kst` joined
[01:47] *** mbtrimpe joined
[01:47] *** mtrimpe left
[01:50] *** mbtrimpe left
[01:51] *** mtrimpe joined
[01:51] *** FurnaceBoy joined
[01:54] *** ab5tract left
[02:02] <pugs_svn> r23093 | lwall++ | [t/spec] my() is a function call

[02:14] *** ab5tract joined
[02:16] *** PZt joined
[02:25] <pmichaud> rakudo is treating   ^@a   as being prefix:<^> applied to a List.

[02:26] <pmichaud> rakudo:  say ^(3,3);

[02:26] <p6eval> rakudo 33212: OUTPUT[012012␤]

[02:27] <pmichaud> (it's doing it wrongly, but that's what it's dong.)

[02:27] <pmichaud> *doing

[02:27] <pmichaud> so, how should we distinguish   ^@a   from ^(3,3)    ?

[02:27] <jnthn> @a is an Array, (3,3) is a List?

[02:27] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v

[02:29] <pmichaud> S03 doesn't make any explicit mention of ^@a

[02:29] <jnthn> Ah.

[02:29] <jnthn> I'm not sure what a sensible thing for that to do is anyway.

[02:30] <pmichaud> it does discuss   0..^@a, and it says that ^$n is equivalent to 0..^$n

[02:30] <jnthn> Yeah

[02:30] <jnthn> But ..^ is a separate operator

[02:30] <pmichaud> but it also says that ^(list)  produces a multidimensional set of subscripts.

[02:30] <pmichaud> so there's some ambiguity about ^@array

[02:30] <jnthn> Right

[02:31] <jnthn> Because I'm sure sure that we can (by the spec) say that Array is a subclass of List

[02:31] <pmichaud> I'm pretty certain that the ^@array form will end up meaning 0..^@array -- but I'm curious what the disambiguation will be.

[02:31] <jnthn> If it were, we could go by implication...

[02:31] *** mtrimpe left
[02:31] <jnthn> hmm

[02:31] <jnthn> I don't know.

[02:32] <jnthn> I did have one question for you about something else...

[02:32] <jnthn> On subid

[02:32] <jnthn> I guess every PAST::Block will get a subid

[02:32] <pmichaud> yes.

[02:33] <jnthn> But will there be a way to say in the PAST tree "I want to get hold of that block by its subid"?

[02:33] <jnthn> But without ending up duplicately having that block in the tree.

[02:33] <pmichaud> yes, there will be a way to do it.

[02:33] <pmichaud> I don't know what it will be yet.

[02:34] <pmichaud> certainly we'll allow HLL compilers to assign subids that override the default generated one.

[02:34] <jnthn> (Reason: subset types need to have their condition block live in the lexical scope they were declared in, but we want to create them earlier than that to set up the type in the namespace)

[02:34] <jnthn> So I'd want to put the block in the right lexical scope (and thus in the right place in the PAST tree, but be able to look it up in init code.

[02:35] <jnthn> So I can create the subtype referencing it.

[02:35] <pmichaud> oh, the loadinit code will still have a 'block' register variable.

[02:35] <pmichaud> that will be initalized with the block's PMC

[02:35] *** jferrero left
[02:35] <jnthn> Oh, I can do it that way too I guess...

[02:35] <jnthn> Ah, aye. As a loadinit on the block that is the condition.

[02:35] <jnthn> Cunning.

[02:35] <jnthn> Why don't I think of this stuff.

[02:35] <jnthn> :-

[02:35] <jnthn> )

[02:36] <pmichaud> yes, the point is that these days are largely taken care of for you

[02:36] <pmichaud> s/these days/these types of recordkeeping/

[02:36] <pmichaud> (can't type .. a little tired tonight.)

[02:36] <jnthn> I wish these days were taken care of for me. Then I could spend them relaxing.

[02:36] <jnthn> It's tonight where you are too?

[02:36] <jnthn> Oops.

[02:36] <pmichaud> 20:36 localtime

[02:36] <jnthn> I've slept at the wrong times since the Parrot summit. :-)

[02:36] <pmichaud> I'm very familiar with that :-)

[02:37] *** FurnaceBoy left
[02:38] <jnthn> Partly because I don't care about sleeping at the "right times"

[02:38] <pmichaud> me neither.

[02:38] <jnthn> Only day I need to be up earlyish is Sunday for church. That's about it.

[02:39] <jnthn> I'm Rakudo daying tomorrow.

[02:39] <pmichaud> okay, excellent.  I should be around much of the day.

[02:39] <jnthn> Plan to mostly look at RT.

[02:39] <pmichaud> However, kids are off from school, so I may get distracted.

[02:39] <pmichaud> yes, I'm wanting to look at RT as well.  :-)

[02:39] <jnthn> There's at least one patch from Chris Dolan I want to reivew.

[02:39] <pmichaud> I'll probably do a few PCT things here and there, and maybe work on the HLLCompiler refactor so that we can start moving to .hll

[02:39] <jnthn> Oh, yes, please.

[02:39] <pmichaud> either that or I'll work on p6 builtins.

[02:40] *** Limbic_Region left
[02:40] <jnthn> As in, having a Perl 6 prelude?

[02:40] <pmichaud> yes.

[02:40] <jnthn> OK

[02:40] <jnthn> One thing I really want to do

[02:40] <jnthn> Refactor variable declarator.

[02:40] <jnthn> Then I can do has $.answer = 42;

[02:41] <pmichaud> don't we need to fix signature first for that?

[02:41] <jnthn> Not really

[02:41] <jnthn> I mean, yes, to get it *really* right we do.

[02:41] <jnthn> But I'd rather do it a step at a time.

[02:42] <jnthn> Any objections?

[02:42] <pmichaud> depends on what you mean by "a step at a time"

[02:42] <jnthn> Until I look at it, I won't know exactly.

[02:43] <jnthn> Probably though, just fixing up the grammar to parse the initialization as in STD.pm

[02:43] <pmichaud> ...that's kinda my point.

[02:43] <jnthn> And then doing that initialization in variable_declarator

[02:43] <jnthn> OK, so you'll maybe object after I've worked it out? ;-)

[02:44] <pmichaud> I'm trying to find where the initialization occurs now in STD.pm

[02:44] <jnthn> I *can* leave this on your plate if you prefer. But I am keen to get "has $.x = 42" style tings working.

[02:44] <jnthn> oh my, don't say it's changed...

[02:44] <pmichaud> yes, it has.

[02:45] *** slavik joined
[02:45] <jnthn> argh

[02:46] <jnthn> What on earth is :dba

[02:46] <pmichaud> "doing business as"

[02:46] <pmichaud> it says how   '(' ~ ')'  <EXPR>   should report back if the match fails

[02:47] <jnthn> Ah, OK

[02:47] <pmichaud> anyway, I'm not sure if   my $a = 3;   parses as assignment or as something else.

[02:47] <jnthn> Looking at this, now I'm really not sure how the initialization is parsed.

[02:47] <slavik> who do I bother about not being able to do %hash = 1..5 | 6..10;

[02:48] <pmichaud> slavik: what are you wanting that to do?

[02:48] <pmichaud> that looks like a junction of two ranges.

[02:48] <jnthn> Hopefully give an error.

[02:48] <slavik> rakudo: say (1..5 | 6..10).perl

[02:48] <p6eval> rakudo 33212: OUTPUT[1..any(5, 6)..10␤]

[02:48] <slavik> rakudo: say (1..5 Z 6..10).perl

[02:48] <p6eval> rakudo 33212: OUTPUT[elements() not implemented in class 'Range'␤current instr.: 'infix:Z' pc 3915 (src/gen_builtins.pir:2519)␤]

[02:48] <slavik> right, that

[02:48] <pmichaud> oh, you want infix:<Z>.  Send email to rakudobug.

[02:48] <pmichaud> [email@hidden.address]
[02:49] <slavik> pmichaud: zip() doesn't work at all I think

[02:49] <pmichaud> one of Jonathan, myself, or our other incredible team of coders will look at it.

[02:49] <slavik> rakudo: say zip(1..5, 6..10)

[02:49] <p6eval> rakudo 33212: OUTPUT[Could not find non-existent sub zip␤current instr.: '_block11' pc 63 (EVAL_15:23)␤]

[02:49] <pmichaud> We might not be able to do much with it because we don't have slices implemented yet.

[02:49] <pmichaud> or captures.

[02:49] <slavik> pmichaud: I have a grammar that produces two arrays, one of keys and other of values ... so I want to stick them into a hash

[02:50] <jnthn> slavik: Infix Z works, I believe.

[02:50] <pmichaud> rakudo:  say (3,3) Z (1,2);

[02:50] <p6eval> rakudo 33212: OUTPUT[3132␤]

[02:50] <pmichaud> that doesn't look right.

[02:50] <jnthn> No?

[02:51] <pmichaud> oh wait, yes it does.

[02:51] <jnthn> Why not?

[02:51] <slavik> hmm

[02:51] <pmichaud> rakudo:  say ((3,3) Z (1,2)).perl;

[02:51] <p6eval> rakudo 33212: OUTPUT[[3, 1, 3, 2]␤]

[02:51] <slavik> maybe I am doing something wrong

[02:51] <pmichaud> rakudo:  my %h = <1 2 3 4> Z <a b c d>;   say %h.perl;

[02:51] <p6eval> rakudo 33212: OUTPUT[{"1" => "a", "2" => "b", "3" => "c", "4" => "d"}␤]

[02:51] <pasteling> "slavik" at 67.100.227.140 pasted "URL grammar" (37 lines, 1.3K) at http://sial.org/pbot/33362

[02:51] <pmichaud> yummy.

[02:52] *** smg joined
[02:53] *** ihrd joined
[02:53] <pmichaud> that's going to be a bit weird, since the components being zipped are Match objects

[02:53] <pmichaud> I'm not sure how the hash composer is going to deal with those.

[02:53] <slavik> it doesn't

[02:53] <slavik> I get a {}

[02:53] <slavik> how can I coerce them into lists?

[02:53] <slavik> @() didn't work

[02:53] <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn

[02:53] <pmichaud> they're already lists (of match objects)

[02:54] <slavik> oh ...

[02:54] <slavik> so $? contains a tree of match objects, not scalars or hashes or lists?

[02:54] <pmichaud> $/, yes

[02:54] <slavik> right, $/

[02:55] <slavik> how can I make it a list of scalars though?

[02:55] <slavik> { %get{$^a} = "$^b" } for $/<resource>[0]<getstr>[0][0] Z $/<resource>[0]<getstr>[0][1];

[02:55] <slavik> that works

[02:56] <pmichaud> can also do prefix:<~>

[02:56] <pmichaud> { %get{~$^a} = ~$^b } for ...

[02:56] <slavik> pmichaud: I want strings there :)

[02:56] <pmichaud> prefix:<~> makes strings.

[02:56] <slavik> oh

[02:56] <slavik> right

[02:57] <ihrd> perl6: sub it { for 1..5 { $_ }; }; say it();

[02:57] <p6eval> pugs: No output (you need to produce output to STDOUT)

[02:57] <p6eval> ..elf 23093: OUTPUT[Useless use of a variable in void context at (eval 123) line 4.␤␤]

[02:57] <p6eval> ..rakudo 33212: OUTPUT[-1␤]

[02:57] <jnthn> ihrd: Trust you. :-P

[02:57] <ihrd> hi

[02:58] <pmichaud> rakudo doesn't know return values in for loops yet.

[02:58] <jnthn> Maybe, the loop control exception stuff gets in the way?

[02:58] <ihrd> but I understand right, it should return 5?

[02:58] <pmichaud> I'd have to go back an look -- iirc, the return value of a for loop is a list of the results of its body

[02:59] <slavik> pmichaud: like a map?

[02:59] <jnthn> O RLY?

[02:59] <jnthn> That's...nuts. And so Perl 6...

[02:59] <ihrd> (1,2,3,4,5) in that case?

[02:59] <jnthn> OH NOES! It's 4am...I should sleep!

[03:00] <slavik> map works in this what ...

[03:00] <slavik> jnthn: lieas, 10PM

[03:00] <jnthn> Where's lieas?

[03:00] <slavik> bah

[03:00] <slavik> lies*

[03:00] <jnthn> Oh

[03:00] <jnthn> No, it feels like 4am too :-)

[03:00] <slavik> has timemachine() been implemented yet?

[03:01] <jnthn> Only on OSX. ;-)

[03:01] <pmichaud> S04, "Loop statements": The value of a loop statement is the list of values from each iteration.

[03:02] <slavik> jnthn: wrong time machine ;)

[03:02] <slavik> very limited ...

[03:02] <jnthn> pmichaud: ...is that as ambiguous as I think it is? ;-)

[03:02] <pmichaud> jnthn: not really.

[03:02] <jnthn> The values could be the values produced...or the values iterated over...

[03:02] <pmichaud> 'for' and 'map' are equivalent, essentially.

[03:02] <pmichaud> it's the value returned by each execution of the body

[03:02] <slavik> jnthn: values produced, like map

[03:02] <jnthn> I suspect that's the useful answer and what was meant, yes.

[03:03] <pmichaud> not only that, but .next and .last can specify the value to be returned for the current iteration

[03:03] <jnthn> Perl 6 is nuts. :-)

[03:03] <pmichaud>    &?BLOCK.next(3);     # return a value of 3 for this iteration

[03:03] <pmichaud> thus

[03:03] *** dukeleto_ joined
[03:03] <jnthn> Thus why I love working on it. ;-)

[03:04] <slavik> pmichaud: wha ... ?

[03:04] <pmichaud>    sub it { for 1..5 { &?BLOCK.next(3); } };   say it();   # "33333\n"

[03:04] <slavik> I don't get the .last and .next think

[03:04] <jnthn> Nice!

[03:04] <jnthn> OK, I am now going to sleep.

[03:04] <slavik> and if it was ,last?

[03:05] <jnthn> Probably will be about midday european time.

[03:05] <pmichaud> sub it { for 1..5 { &?BLOCK.last(3); } };   say it()   # "3\n"

[03:05] <jnthn> night all

[03:05] <slavik> jnthn: night

[03:06] <ihrd> good night jnthn

[03:08] *** ab5tract left
[03:09] <slavik> pmichaud: so, how can I coerce the list of matches into a list of scalars?

[03:15] <slavik> rakudo: for 0..7 say $_;

[03:15] <p6eval> rakudo 33212: OUTPUT[Statement not terminated properly at line 1, near "say $_;"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[03:15] <slavik> rakudo: for 0..7 { say $_; }

[03:15] <p6eval> rakudo 33212: OUTPUT[0␤1␤2␤3␤4␤5␤6␤7␤]

[03:16] <ihrd> excuse me, but I still in some confusion,  if I want return only last value from loop, how can I do that?

[03:17] <slavik> ihrd: like if it generates a sequence based on previous things?

[03:18] <ihrd> slavik: I just do some method in loop, and whant to now last returned value from it

[03:19] <slavik> hmm

[03:19] <ihrd> right now I use workaround, like

[03:19] *** japhb left
[03:19] <slavik> @(for 1..10 { $_ })[-1]

[03:19] <lambdabot> Unknown command, try @list

[03:19] <slavik> or something

[03:19] <slavik> rakudo: say @(for 1..10 { $_ })[-1];

[03:19] <p6eval> rakudo 33212: OUTPUT[Statement not terminated properly at line 1, near "@(for 1..1"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[03:19] <slavik> rakudo: say @(for 1..10 { $_; })[-1];

[03:19] <p6eval> rakudo 33212: OUTPUT[Statement not terminated properly at line 1, near "@(for 1..1"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[03:19] <slavik> rakudo: say for 1..10 { $_; };

[03:20] <p6eval> rakudo 33212: OUTPUT[Statement not terminated properly at line 1, near "{ $_; };"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[03:20] <slavik> rakudo: say (for 1..10 { $_; });

[03:20] <p6eval> rakudo 33212: OUTPUT[-1␤]

[03:20] <slavik> :(

[03:20] <slavik> it doesn't work yet

[03:20] *** jhorwitz left
[03:21] <ihrd> perl6: my $r;  sub some { $^d ** 2 };  sub it { for 1..5 { my $r =some($_) } }; say $r;

[03:21] <p6eval> rakudo 33212: OUTPUT[␤]

[03:21] <p6eval> ..elf 23093: OUTPUT[Global symbol "$d" requires explicit package name at (eval 127) line 4.␤ at ./elf_f line 3861␤]

[03:21] <p6eval> ..pugs: No output (you need to produce output to STDOUT)

[03:21] <pmichaud> do placeholder variables work in subs...?

[03:22] <ihrd> perl6: my $r;  sub some { $^d ** 2 };  sub it { for 1..5 { my $r =some($_) } }; it(); say $r;

[03:22] <p6eval> rakudo 33212: OUTPUT[␤]

[03:22] <p6eval> ..pugs: No output (you need to produce output to STDOUT)

[03:22] <p6eval> ..elf 23093: OUTPUT[Global symbol "$d" requires explicit package name at (eval 129) line 4.␤ at ./elf_f line 3861␤]

[03:22] <ihrd> It worked for my

[03:23] <pmichaud> well.... we can't really tell what some() is returning there.

[03:23] <pmichaud> because the $r we're saying isn't the $r we're assigning.

[03:24] <ihrd> perl6: my $r;  sub some{ $^d ** 2 };  sub it { for 1..5 {  $r =some($_) } }; it(); say $r;

[03:24] <p6eval> pugs: No output (you need to produce output to STDOUT)

[03:24] <p6eval> ..elf 23093: OUTPUT[Global symbol "$d" requires explicit package name at (eval 129) line 4.␤ at ./elf_f line 3861␤]

[03:24] <p6eval> ..rakudo 33212: OUTPUT[25␤]

[03:24] <ihrd> yes, excuse me

[03:24] <ihrd> now right

[03:25] <ihrd> so this is workaround, how can I do the same in perl6 without $r?

[03:27] <ihrd> Can I see somehow the last iteration in loop?

[03:28] <ihrd> something like: for 1..5 { do($_); last(1) if .it_is_last_iteration }?

[03:30] <pmichaud> rakudo doesn't have a last() implemented yet.

[03:30] <pmichaud> we're waiting for a couple of fixes to parrot exception handling.

[03:30] <pmichaud> (and a refactor of control blocks in general)

[03:31] <slavik> pmichaud: are exceptions the only way to return errors?

[03:31] <slavik> or can we return undef

[03:32] <pmichaud> the common way to signal an error is to use fail()

[03:33] <pmichaud> that returns a "special undef" that has the exception attached

[03:33] <pmichaud> if anything tries to use that undef, the exception gets thrown

[03:33] <pmichaud> (where "use the undef" means "do something other than check it for truth or definedness")

[03:33] <slavik> ie: sub f { fail(); } if(f == undef) { say "failed" }

[03:34] <slavik> or something

[03:34] <pmichaud> if (!f) { say "failed" }

[03:34] <pmichaud> or

[03:34] <pmichaud>     if (!f.defined) { say "failed" };

[03:34] <pmichaud> comparing with == undef is often wrong, because there's not just a single value of undef.

[03:34] <slavik> so, try catch finally aren't necessary ...

[03:35] <pmichaud> only if you want to try/catch exceptions :-)

[03:35] <pmichaud> you could do:

[03:35] <pmichaud>     {  say f();   CATCH { say 'failed'; } }

[03:36] <pmichaud> and if f() returns a Failure object then the CATCH block gets invoked because we attemped to use the returned Failure

[03:36] <slavik> I see

[03:36] <pmichaud> (except that CATCH isn't working yet in Rakudo.  See above note about needing to implement control blocks :-)

[03:36] <slavik> but inside the if statement, it doesn't get used, just looked at, correct?

[03:36] <pmichaud> testing for truth or definedness doesn't count as "used", no.

[03:37] <pmichaud> trying to get an int, num, or str does.

[03:37] <pmichaud> (I'm not sure what else does.)

[03:37] <slavik> hmm

[03:37] <slavik> does fail work?

[03:37] <pmichaud> in Rakudo?  Yes.

[03:38] <pmichaud> at least I think it works.  Need tests.  :-)

[03:38] <pmichaud> 'try' still needs a bit of work.

[03:38] <ihrd> I know about last in Rakudo, my question about perl6

[03:39] <ihrd> excuse me lag :)

[03:39] <ihrd> slavik: [-1] do not work in perl6 as in perl5

[03:39] <slavik> pmichaud: if I wanted to have pir bindings for C libraries ... what is the major difficulty in this endeavor ?

[03:40] <slavik> ihrd: huh?

[03:40] <ihrd> slavik: in you exapmle should be [*-1]

[03:40] <slavik> oh

[03:40] <slavik> ok

[03:40] <pmichaud> oh.  Normally we say "Perl 6" when asking about the language.  But yes,  last(1) would cause the for loop to put a 1 as the last value in its return list.

[03:40] <pmichaud> slavik: I don't know, I'm not too familiar with invoking C from PIR

[03:41] <pmichaud> slavik: I know it can be done and people are doing it, but I haven't done it in years and so I'm not familiar with the details.

[03:41] <ihrd> pimchaud: ok, thank you! but hov can I see that is last iteration?

[03:41] <TimToady> @tell jnthn STD currently just parses initialization as assignment, and delegates any change in meaning of = to the semantic analysis phase

[03:41] <lambdabot> Consider it noted.

[03:41] <pmichaud> TimToady: yay, excellent.

[03:41] <pmichaud> TimToady: that's actually what rakudo does now, so jnthn (and I) are happy to hear this.

[03:41] *** Psyche^ joined
[03:42] <TimToady> it just seems like the sane thing to do, though we'll have to be careful with (state $x) += 2 and such

[03:42] <pmichaud> TimToady: did you see my comment about ^@a being treated as prefix:<^> on a List ?

[03:42] <TimToady> yes

[03:42] <TimToady> dunno what to think about that

[03:42] <pmichaud> okay.

[03:43] <TimToady> I want contradictory things, it seems.  not the first time...

[03:43] <pmichaud> I'm wondering if ^(3,3) is all that important or useful as a shortcut.  Maybe a different shortcut.

[03:43] <pmichaud> sometimes I think (language) design is just about resolving our contradictory desires.  :-)

[03:43] <TimToady> ^« maybe

[03:44] <TimToady> rakudo: say ^<<(3,3)

[03:44] <p6eval> rakudo 33212: OUTPUT[Statement not terminated properly at line 1, near "^<<(3,3)"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[03:45] <pmichaud> @tell jnthn (comment on TimToady's note)  yay!  So it is assignment, which rakudo already does, and you can start working on has $.x = 3;  based on that :-)

[03:45] <lambdabot> Consider it noted.

[03:45] <pmichaud> yeah, rakudo doesn't understand the hypers yet.

[03:45] *** wayland76 left
[03:46] <pmichaud> silly meta_postfix_prefix_inafix_wontfix operator parsing.

[03:47] <TimToady> there's only 8299 possible termish tokens currently...

[03:48] *** km2 joined
[03:48] <TimToady> oops, 8298 really

[03:48] <pmichaud> "8299 tokens in term from the Wall... 8299 tokens in term... take one down, meta it around, 16598 tokens in term from the Wall..."

[03:48] <TimToady> much much better

[03:48] <pmichaud> :D

[03:48] <TimToady> forgot the first line is the dba

[03:52] *** ihrd left
[03:56] *** wayland76 joined
[03:57] <pmichaud> time for sleep or relaxation here -- see you all tomorrow

[03:58] *** Patterner left
[03:58] *** Psyche^ is now known as Patterner

[03:59] <TimToady> does that mean you don't relax when you're asleep?

[03:59] <slavik> rofl

[03:59] <slavik> so, TimToady ... cups

[04:00] <TimToady> Common Unix Printing System

[04:01] <slavik> not that one

[04:01] <slavik> the broken cups ... heh

[04:02] <slavik> there should be an easter egg relating to it

[04:03] *** elmex_ joined
[04:17] *** elmex left
[04:17] *** elmex_ is now known as elmex

[04:25] *** stephens left
[04:25] <pugs_svn> r23094 | putter++ | [elf_h] Match.pm: Fix string literals with unquoted escapes.

[04:25] <pugs_svn> r23094 | putter++ | [STD_blue] Triage remaining elf source files.

[04:27] <pugs_svn> r23095 | hinrik++ | [util/perl6.vim] add support for directives (=use, =config, =encoding) and verbatim regions

[04:47] *** ab5tract joined
[04:48] *** ab5tract left
[04:48] *** alc joined
[04:51] *** revdiablo joined
[04:56] *** wayland76 left
[04:57] *** slavik left
[05:04] *** xinming joined
[05:11] *** xinming_ left
[05:45] *** apeiron left
[05:48] *** smg left
[06:11] *** Bzek joined
[06:45] *** kst` left
[06:45] *** kst` joined
[06:46] *** ashizawa joined
[06:49] *** wayland76 joined
[06:56] *** aindilis` left
[06:56] *** aindilis` joined
[07:05] *** DemoFreak joined
[07:18] *** smg joined
[07:34] *** Jedai left
[07:34] *** Coleoid__ joined
[07:34] *** Jedai joined
[07:35] *** japhb joined
[07:37] *** pnu left
[07:38] *** pnu joined
[07:39] *** Coleoid left
[07:39] *** Coleoid__ is now known as Coleoid

[07:48] <moritz_> rakudo: say (^(2,3)).perl

[07:48] <p6eval> rakudo 33212: OUTPUT[[0, 1, 0, 1, 2]␤]

[07:48] <moritz_> rakudo: say (^(3,3)).perl

[07:48] <p6eval> rakudo 33212: OUTPUT[[0, 1, 2, 0, 1, 2]␤]

[07:51] *** justatheory joined
[07:51] <wayland76> rakudo: say .WHAT()

[07:51] <p6eval> rakudo 33212: OUTPUT[Failure␤]

[07:51] <moritz_> rakudo: say (^(10,3)).perl

[07:51] <p6eval> rakudo 33212: OUTPUT[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2]␤]

[07:51] <wayland76> Well, it was worth a go :)

[07:52] <moritz_> wayland76: it's not wrong, $_ is undef, which can be an instance of class Failure

[07:58] *** pcbuetow left
[08:00] *** justatheory left
[08:01] *** lambdabot joined
[08:05] *** bacek_ left
[08:05] <wayland76> Oh, I agree it's not wrong, I just wanted to see what it would do (I was being silly)

[08:06] <wayland76> rakudo: y0!

[08:06] <p6eval> rakudo 33212: OUTPUT[Statement not terminated properly at line 1, near "!"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[08:06] <wayland76> rakudo: 0!

[08:06] <p6eval> rakudo 33212: OUTPUT[Statement not terminated properly at line 1, near "!"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[08:07] <wayland76> No zero-factorial :)

[08:10] <moritz_> postfix:<!> is not part of the language

[08:10] <moritz_> (we had to leave at least one simple example for those who want to show off with defining operators :-)

[08:30] *** iblechbot joined
[08:33] <wayland76> rakudo: sub postfix:<!> { say "Sending mail using postfix... :)"; }

[08:33] <p6eval> rakudo 33212: OUTPUT[Statement not terminated properly at line 1, near ":<!> { say"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[08:34] <wayland76> rakudo: sub postfix:<!>() { say "Sending mail using postfix... :)"; }

[08:34] <p6eval> rakudo 33212: OUTPUT[Statement not terminated properly at line 1, near ":<!>() { s"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[08:34] <wayland76> rakudo: sub postfix:<!>(String a, String b) { say "Sending mail using postfix... :)"; }

[08:34] <p6eval> rakudo 33212: OUTPUT[Statement not terminated properly at line 1, near ":<!>(Strin"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[08:34] <moritz_> wayland76: rakudo doesn't let you define operators yet

[08:35] <moritz_> wayland76: and the signature would be ($a), not (String a, ...) or something

[08:35] <wayland76> Oh, yeah, forgot; I have a project or two that are waiting on operator overloading :)

[08:36] <wayland76> (ie. so I should've known); thanks :)

[08:36] <moritz_> STD.pm does parse it correctly, and even parses the defined operator with correct precedence

[08:36] <moritz_> std: 5!

[08:36] <wayland76> STD: sub postfix:<!>(String a, String b) { say "Sending mail using postfix... :)"; }

[08:36] <p6eval> std 23095: OUTPUT[############# PARSE FAILED #############␤Syntax error at /tmp/JaFLgI1O8t line 1:␤------> [32m5[31m![0m␤    expecting any of:␤    POST␤    infix or meta-infix␤       infix stopper␤    postfix␤        postfix_prefix_meta_operator␤       standard stopper␤ statement modifier loop␤ 

[08:36] <p6eval> ..terminator␤     whitespace␤00:0...

[08:37] <wayland76> STD: sub postfix:<!>($a) { say "Sending mail using postfix... :)"; }

[08:37] <moritz_> wayland76: you still need sigils on your variables (and String isn't a builtin type)

[08:37] <wayland76> STD: sub postfix:<!>($a) { say "Sending mail using postfix... :)"; } 5!

[08:38] <moritz_> I think we borked evalbot :)

[08:38] <wayland76> Uh-oh -- now that I know how to do it... :)

[08:39] *** p6eval joined
[08:39] <moritz_> std: sub postfix:<!>($a) { say "Sending mail using postfix... :)"; } 5!

[08:39] <p6eval> std 23095: OUTPUT[############# PARSE FAILED #############␤Syntax error at /tmp/A43rmv7nyt line 1:␤------> [32my "Sending mail using postfix... :)"; } [31m5![0m␤    expecting any of:␤    infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤00:12

[08:39] <moritz_> ah no, it's just case sensitive

[08:39] <p6eval> ..156m␤]

[08:39] <moritz_> std: sub postfix:<!>($a) { say "Sending mail using postfix... :)" }; 5!

[08:40] <wayland76> Ok :)

[08:40] <p6eval> std 23095: OUTPUT[00:12 156m␤]

[08:40] <moritz_> and there need to be a ; after } unless it's followed be a newline

[08:40] <wayland76> Ok :)

[08:49] <DemoFreak> rafl: gm ;)

[08:53] <rafl> DemoFreak: moin!

[08:55] *** schmalbe joined
[09:01] *** justatheory joined
[09:10] *** ejs joined
[09:11] *** revdiablo left
[09:13] *** kane_ left
[09:19] *** dukeleto_ left
[09:21] *** justatheory left
[09:21] *** kane_ joined
[09:44] *** smallfish left
[09:47] *** smg left
[10:21] *** alc left
[10:55] *** apeiron joined
[10:59] *** drbean joined
[11:17] *** smg joined
[11:23] *** smg left
[11:25] *** ashizawa left
[11:25] *** ashizawa joined
[11:25] *** cookys joined
[11:25] *** lisppaste3 joined
[11:25] *** rafl joined
[11:51] *** kanru left
[11:52] *** kanru joined
[12:05] *** vixey joined
[12:15] *** drbean_ joined
[12:28] *** drbean left
[12:33] *** meppl joined
[12:34] *** dalek left
[12:34] *** dalek joined
[12:34] *** alech left
[12:36] <pugs_svn> r23096 | jnthn++ | [t/spec] Unfudge complex autoviv test for Rakudo.

[12:40] <rakudo_svn> r33214 | jonathan++ | [rakudo] Complex multis for various ops should coerce their maybe-not-Complex argument so we don't run into Parrot MMD errors. Do it by introducing .Complex method on Any and calling that.

[12:54] *** smg joined
[12:54] *** sri_kraih_ joined
[12:55] *** Bzek left
[13:03] *** Bzek joined
[13:04] *** d4l3k_ joined
[13:04] *** wolv joined
[13:04] *** jnthn_ joined
[13:04] <pugs_svn> r23097 | jnthn++ | [t/spec] Tests for declaring and doing roles in namespaces.

[13:05] *** pmichaud_ joined
[13:05] *** wolverian left
[13:05] *** PerlPilot joined
[13:05] *** wolv is now known as wolverian

[13:05] *** dalek left
[13:05] *** pmichaud left
[13:05] *** PerlJam left
[13:05] *** d4l3k_ is now known as dalek

[13:05] *** jnthn left
[13:10] <rakudo_svn> r33215 | jonathan++ | [rakudo] Fix declaration and doing of roles in multi-jointed namespaces. Patch partly courtesy of Chris Dolan.

[13:10] <rakudo_svn> r33216 | jonathan++ | [rakudo] Add namespaced roles test file.

[13:12] *** sri_kraih left
[13:12] *** jnthn_ left
[13:26] *** StephenPollei joined
[13:32] *** ruoso joined
[13:35] <ruoso> Hello!

[13:35] <lambdabot> ruoso: You have 1 new message. '/msg lambdabot @messages' to read it.

[13:40] <rakudo_svn> r33217 | jonathan++ | [rakudo] Fix bug in enum code generation. When adding a vtable method, you need to mark it anon too, otherwise it'll also appear as a normal method.

[13:49] <ruoso> @tell pmurias git clone [email@hidden.address]
[13:49] <lambdabot> Consider it noted.

[13:51] <ruoso> @tell pmurias but I didn't start anything yet there... I'm quite convinced we can do a lot of things without it, like most of the boostrapping of ClassHOW and Object...

[13:51] <lambdabot> Consider it noted.

[13:55] *** jonathan_ joined
[13:55] *** jonathan_ is now known as jnthn

[13:55] <jnthn> rakudo: eval { class A { has $.x } }; say A.new(x=>5).x

[13:55] <p6eval> rakudo 33217: OUTPUT[5␤Null PMC access in find_method()␤current instr.: 'parrot;Perl6;Compiler;main' pc 138837 (src/gen_actions.pir:14613)␤]

[13:55] <jnthn> Hmm. But it doesn't do that in the REPL...

[13:56] <jnthn> But with -e it does. Oddness.

[13:58] *** schmalbe left
[14:00] <rakudo_svn> r33218 | jonathan++ | [rakudo] Add a missing null check in !clone_attr.

[14:00] <rakudo_svn> r33219 | bernhard++ | [codingstd] remove a trailing space

[14:22] *** PerlPilot is now known as PerlJam

[14:25] *** pmichaud_ left
[14:25] *** pmichaud joined
[14:27] *** PerlJam left
[14:27] *** PerlJam joined
[14:32] *** ejs left
[14:32] *** ejs joined
[14:38] *** masak joined
[14:42] *** ashizawa left
[14:57] <pugs_svn> r23098 | jnthn++ | [t/spec] Eliminate useless/wrong use of eval.

[14:57] *** ejs left
[14:58] *** smg left
[15:00] <rakudo_svn> r33220 | jonathan++ | [rakudo] Should check the parameter passed to eval is a string, in line with S29.

[15:09] *** ejs joined
[15:11] *** adc_penner joined
[15:12] <pugs_svn> r23099 | ruoso++ | [mildew] simplify lexical-sub test a little bit...

[15:20] <rakudo_svn> r33221 | jonathan++ | [rakudo] Call panic on sub-nodes of EXPR nodes, which end up being PGE::Match rather than Perl6::Grammar. This means we show the intended, helpful error.

[15:20] *** ejs left
[15:30] <rakudo_svn> r33222 | jonathan++ | [rakudo] When we fail a type check on a parameter, report the name of the thing we were calling.

[15:34] *** Lorn joined
[15:39] <pugs_svn> r23100 | ruoso++ | [mildew] lexical subs working!!!!

[15:46] *** jhorwitz joined
[15:55] *** stephens joined
[16:01] <pugs_svn> r23101 | ruoso++ | [smop] idconst supports .true, it is only false for 0-sized identifiers...

[16:01] <pugs_svn> r23101 | ruoso++ | [mildew] a test showing that recursion on lexical subs work!

[16:04] <moritz_> ruoso: did you see the "man or boy" test?

[16:04] <ruoso> moritz_, I don't think so

[16:05] <moritz_> ruoso: t/spec/integration/man-or-boy.t

[16:05] <moritz_> ruoso: in that file there's a link to wikipedia with background

[16:05] <moritz_> ruoso: it''s basically a heavy regression test for lexial vars and subs

[16:07] <ruoso> cool

[16:07] <ruoso> I'll take a look

[16:08] <moritz_> ruoso: you might need to desugar it a bit before it runs on mildew, but if lexical subs work than all the grunt work is already there

[16:09] <ruoso> moritz_, yes... mildew still lacks "for", which is the next thing on list btw

[16:09] <ruoso> and comparison tests also

[16:09] <ruoso> but besides that, I kinda think it would work

[16:10] *** pmurias joined
[16:10] <pugs_svn> r23102 | ruoso++ | [mildew] small fix in the way to treat arguments to terms

[16:10] <ruoso> moritz_, mildew is kinda coming the other way around if we compare to rakudo, for instance...

[16:11] <pmurias> ruoso: hi

[16:11] <lambdabot> pmurias: You have 2 new messages. '/msg lambdabot @messages' to read them.

[16:11] <moritz_> ruoso: yes, I noticed :-)

[16:11] <ruoso> hi pmurias 

[16:11] <pmurias>         

[16:11] <pmurias> (touchpad)---

[16:12] <moritz_> pmurias++ # keep karma preservation law valid :-)

[16:13] <ruoso> btw... mildew pass 30 tests now... of its own test suite, of course...

[16:13] <pmurias> that's not much

[16:13] <ruoso> well.. it's 100%

[16:13] <ruoso> :D

[16:13] <ruoso> that's a prettier number ;)

[16:14] <masak> statistics++

[16:17] <ruoso> now we just need "for", "map" and "grep" to support ClassHOW.can

[16:17] <ruoso> then we might have the proper ClassHOW.dispatch implemented

[16:17] <pmurias> we could just use "map" instead of those 3 things

[16:18] <ruoso> yeah... it's almost the same thing...

[16:18] <ruoso> but I still would like to have some clarification on the iterator issues

[16:18] <ruoso> before we implement it

[16:19] <ruoso> but for some reason I think TimToady is expecting us to TITS and then he will realize if it's a good approach

[16:20] <pmurias> ruoso: re smop5 it would be usefull if we wanted a proper compiletime/runtime mixing

[16:20] <rakudo_svn> r33225 | jonathan++ | [rakudo] Refactor .= operator so that it now handles having a container looked up from a keyed access on the LHS.

[16:20] <ruoso> pmurias, indeed... but I think we still have a lot of work to do before we can do that type of mixing

[16:23] <ruoso> TimToady, do you think you would have clarifications on the iterator issues soon? or are you expecting implementations to experiment and do all the proofs of concept before we have a detailed spec?

[16:24] <pmurias> ruoso: how much things do we need before we can bind a C++ class?

[16:25] <ruoso> pmurias, it depends whether you want to callback smop or nto

[16:25] <ruoso> s/nto/not/

[16:25] *** sri_kraih joined
[16:25] <pmurias> i just want to try binding the Ogre game engine ;)

[16:26] <ruoso> using foreign objects should be fien

[16:26] <ruoso> fine

[16:26] <ruoso> you just need a typemap

[16:26] <pmurias> ruoso: why is callbacking smop difficult

[16:26] <pmurias> ?

[16:27] <ruoso> pmurias, because it would probably require longjmp hacks

[16:29] *** smg joined
[16:29] *** sri_kraih__ joined
[16:29] <ruoso> pmurias, but maybe implementing a longjmp SMOP frame would be a good idea 

[16:30] <ruoso> there's probably a way to do it as a generic thing

[16:30] <ruoso> probably something like setting up a continuation for a C call...

[16:31] <ruoso> which is a SMOP interpreter

[16:31] <ruoso> rephrasing...

[16:31] <ruoso> a "C Coroutine SMOP Interpreter"

[16:31] <ruoso> so it could interoperate with other interpreters

[16:33] <ruoso> that's actually a freaking cool idea

[16:33] <ruoso> and a very important step in the SMOPP5 project, to support XS-Compatibility

[16:34] <pugs_svn> r23103 | jnthn++ | [rakudo] Some tests for .= operator.

[16:36] <pmurias> ruoso: how is it supposed to work?

[16:37] *** dukeleto joined
[16:37] <ruoso> pmurias, the glue code would setup this "c coro interpreter" before calling the actual C code

[16:37] <ruoso> in the middle of the C code, when calling back to SMOP

[16:38] <ruoso> it would save the current C context inside a new "SMOP continuation", which would be set as the "current continuation"

[16:38] <ruoso> and it would return to the main SMOP loop, using the context saved before calling the actual C code

[16:39] *** Exodist joined
[16:39] <ruoso> then the SMOP code would set a new continuation

[16:39] <ruoso> continue the loop

[16:39] <ruoso> eventually call setr

[16:39] <ruoso> and goto

[16:39] <ruoso> then it would call eval

[16:39] <ruoso> and it would simply resume the C coroutine 

[16:40] <ruoso> probably returning the value sent in the setr

[16:40] <pmurias> ruoso: you are aware we can only unwind the stack with setjmp/longjmp

[16:41] <ruoso> hmmmm...

[16:41] *** sri_kraih_ left
[16:41] <ruoso> there should be a way

[16:44] *** sri_kraih left
[16:44] <ruoso> pmurias, I'm not sure that's entirely true

[16:45] *** hercynium joined
[16:45] <ruoso> pmurias, isn't it possible to save a state before calling a function, save another state inside the function, longjmp to the outer state and longjmp to the inner state again?

[16:46] <ruoso> as long as the functions that call setjmp don't return

[16:46] <ruoso> which is the case for the SMOP main loop

[16:47] <pmurias> ruoso: not safely

[16:47] <ruoso> why?

[16:47] <pmurias> if you recurse in that function you overwrite the stack

[16:47] <ruoso> hm?

[16:49] <pmurias> setjmp doesn't save the stack it only saves the location of the stack top

[16:49] <ruoso> right... that's why you can't return

[16:50] <ruoso> (without invalidating the saved stack)

[16:50] <pmurias> when i longjump to the outer state and call a function the new function uses the part of the stack used by the inner function

[16:52] <ruoso> you mean that it can't have two stacks with the same root

[16:53] <ruoso> well... I think there are coro implementations in C

[16:53] <ruoso> they probably already solved all this issues

[16:55] <pmurias> ruoso: it's possible if you reserve space on the stack

[16:57] * pmurias has to think it over

[16:57] *** pmurias left
[16:57] *** schmalbe joined
[16:58] <ruoso> @tell pmurias http://www.softpanorama.org/Lang/Cilorama/coroutines_in_c.shtml

[16:58] <lambdabot> Consider it noted.

[17:04] <ruoso> @tell pmurias better yet: http://www.xmailserver.org/libpcl.html

[17:04] <lambdabot> Consider it noted.

[17:07] *** IRSeekBot left
[17:13] *** renormalist left
[17:15] *** masak left
[17:18] *** d4l3k_ joined
[17:18] *** dalek left
[17:18] *** d4l3k_ is now known as dalek

[17:28] *** [particle] joined
[17:32] *** araujo left
[17:32] *** dukeleto left
[17:55] *** smg left
[18:20] <rakudo_svn> r33228 | jonathan++ | [rakudo] Use the Class PMC's new add_vtable_override method.

[18:27] *** bacek left
[18:28] *** km3 joined
[18:29] <pugs_svn> r23104 | moritz++ | [t/spec] simplify man-or-boy.t

[18:40] *** [particle] left
[18:40] <rakudo_svn> r33230 | jonathan++ | [rakudo] Make 'my &x = sub { ... }' store the sub lexically.

[18:40] *** km2 left
[18:41] <TimToady> what's with all the "sub {...}" when bare "{...}" should work just the same?

[18:41] <moritz_> paranoia ;)

[18:42] *** bacek joined
[18:46] *** [particle] joined
[18:52] *** mtrimpe joined
[19:08] *** tewk_ is now known as tewk

[19:08] *** [particle] left
[19:09] *** [particle] joined
[19:09] *** [particle] left
[19:10] <rakudo_svn> r33231 | jonathan++ | [rakudo] Bug fix for subs that take parameters with the & sigil; we need to register the symbol after we stripped.

[19:11] *** mtrimpe left
[19:13] *** ZuLuuuuuu joined
[19:13] *** kst` is now known as kst

[19:14] *** aindilis` left
[19:14] *** aindilis joined
[19:20] <TimToady> hmm, looks like commmitbit is down again  :(

[19:20] <TimToady> well, can't look at it now, gotta do a school run...

[19:20] <TimToady> bbl &

[19:21] *** ZuLuuuuuu left
[19:24] <moritz_> TimToady: it's up again

[19:26] *** smg joined
[19:33] *** araujo joined
[19:46] <pugs_svn> r23105 | jnthn++ | [t/spec] Just compute the first 10 values of the boy or man test; it's enough to see it works and avoids hitting Parrot's default 1000 recursion levels limit.

[19:48] <pugs_svn> r23106 | moritz++ | [t/spec] more comments to man-or-boy.t

[19:49] *** pbuetow joined
[19:50] <rakudo_svn> r33233 | jonathan++ | [rakudo] A crack at getting is copy to do the right thing. We may need to revisit this again later, as I've still not convinced myself it's going to do the right thing in every case (but didn't work out one where it won't yet). It passes all spectests that already passed and

[19:50] <rakudo_svn> ..makes the man or boy example's use of is copy work, though.

[19:50] <rakudo_svn> r33234 | jonathan++ | [rakudo] Add the man or boy test to spectest.

[19:52] *** mncharity joined
[19:54] <pmichaud> TimToady (and others):   where do we want the synopsis documents to live in pugs/  ?

[19:56] *** pbuetow left
[20:07] *** PZt left
[20:09] *** PZt joined
[20:12] <moritz_> what's wrong with the current location, docs/Perl6/Spec/ ?

[20:21] <pmichaud> nothing, just making sure that's where we want them.

[20:22] <moritz_> some brave soul needs to fix smartlinks.pl after that ;)

[20:23] <TimToady> we probably want to move to names like S16-io.pod or some such

[20:23] <pmichaud> I'll get the S##.pod files into docs/Perl6/Spec

[20:23] <pmichaud> then they can be easily renamed from there.

[20:23] <pmichaud> (or moved to other directories)

[20:23] <TimToady> thanks

[20:25] <pugs_svn> r23107 | putter++ | [misc/elfish/STD_blue] Continued adaptation to current STD.pm/gimme5.

[20:25] <pugs_svn> r23107 | putter++ | Tweaks for: some hash literal support; foofix:<x> names; slurpy params; classname literals; empty multisigs.  One more elf source file works.

[20:27] <pmichaud> ...temporarily disabling pugs-commit mailing list so we don't end up with 100+ commit messages

[20:28] <pugs_svn> r23108 | jnthn++ | [t/spec] Couple of tests for lexicals with & sigil.

[20:29] <mncharity> TimToady: It looks like I'm getting down to two issues.  (a) ./viv ../../misc/elf/elf_h_src/PrimitivesP5.pm burns >3GB on the 150 line file before I have to kill it.  (b) The previously mentioned $.m(3) arguments showing up in an unexpected place.  (b) I can work around, though it would be nifty if it "just worked".  (a) is more painful.  Any thoughts?

[20:29] *** Exodist left
[20:30] <mncharity> bbiab

[20:30] *** a-lex joined
[20:30] *** a-lex left
[20:32] <pugs_svn> r23109 | pmichaud++ | Creating dirs for synopsis load from perl.org

[20:33] <pmichaud> prepare for possible flood of pugs_svn commits

[20:33] <pmichaud> unless someone knows how to turn it off briefly

[20:33] <moritz_> there's nothing wrong with a brief flood ,)

[20:34] <jnthn> Provided we get a nice rainbow afterwards. ;-)

[20:34] *** [particle] joined
[20:34] * pmichaud crosses fingers, hope he doesn't screw this up.

[20:35] <pugs_svn> r23115 | allison++ | Adding the first two retroactive synopses.

[20:35] <pugs_svn> r23116 | allison++ | draft of syntax synopsis, after review by p6l

[20:35] <pugs_svn> r23117 | larry++ | 2004 edition of rules.  :-)

[20:35] <pugs_svn> r23118 | larry++ | utf8ified, random cleanup

[20:35] <pugs_svn> r23119 | larry++ | Structure is good.

[20:35] <pugs_svn> r23120 | larry++ | Added precedence table, random cleanup.

[20:35] <pugs_svn> r23121 | larry++ | Forgot utf8ification.

[20:35] <pugs_svn> r23122 | larry++ | Utf8ified.

[20:35] <pugs_svn> r23123 | larry++ | Random cleanup.

[20:35] <pugs_svn> r23124 | larry++ | Documented "=" package.

[20:35] <pugs_svn> r23125 | larry++ | Added notes about optimizing closures to mere blocks.

[20:35] <pugs_svn> r23126 | larry++ | Incomplete utf8ification of E<> forms.

[20:35] <pugs_svn> r23127 | larry++ | Utf8ification.

[20:35] <pugs_svn> r23128 | luqui++ | Added the =~ to ~~ operator renaming.

[20:35] <pugs_svn> r23129 | larry++ | Changed $=line et al. to $?line.

[20:35] <pugs_svn> r23130 | larry++ | Uppercased the compiler variables.

[20:35] <pugs_svn> r23131 | larry++ | Added examples of $? variables.

[20:35] <pugs_svn> r23132 | larry++ | Recent tweaks to &?SUB and such.

[20:35] <pugs_svn> r23133 | larry++ | Forgot to change date and version.

[20:35] <pugs_svn> r23134 | larry++ | Clarified whitespace proscription following sigils.

[20:35] <pugs_svn> r23135 | larry++ | Changed symref syntax back to ::($str) to not be ambiguous with %foo::{$key}.

[20:35] <pugs_svn> r23136 | larry++ | Added ::?CLASS and ::?ROLE forms.

[20:35] <pugs_svn> r23137 | larry++ | Changed main default to strict.

[20:35] <pugs_svn> r23138 | larry++ | Simplified operator quoting rules by unification with hash subscript syntax.

[20:35] *** pugs_svn left
[20:36] <moritz_> ok, enough flood for now ;)

[20:36] <literal> aww

[20:36] <pmichaud> yes, I'm up to revision 23500 on the import already

[20:36] <pmichaud> so we would've been here a while.

[20:36] <TimToady> yowser

[20:37] <pmichaud> I really hope I disabled the mail send properly.  :-)

[20:37] * pmichaud checks

[20:38] <pmichaud> looks like "yes."

[20:39] <pmichaud> we're now up to 24057.

[20:39] <literal> hm, what's the difference between doc/trunk/design/syn/S*.pod and vim docs/Perl6/Spec/*.pod ?

[20:39] <pmichaud> do we just want them in Spec/, or should we have a special dir for the synopses?

[20:39] <pmichaud> literal: doc/trunk/design/syn/S* is where they were in the original repository

[20:39] <pmichaud> literal: I'll just move them now to their new location.

[20:40] <literal> I see

[20:40] <pmichaud> and then drop doc/trunk/design/syn

[20:42] <pmichaud> okay to restart pugs_svn 

[20:43] *** pugs_svn joined
[20:43] <pugs_svn> r24058 | pmichaud++ | Move synopses to their new home.

[20:44] <pugs_svn> r24059 | pmichaud++ | remove obsolete doc/* dirs from synopsis migration.

[20:46] <pmichaud> restored email to pugs-commits

[20:46] <pmichaud> TimToady: do you want me to re-apply the updates since last Wednesday for you...?

[20:46] <TimToady> if you've got 'em handy

[20:46] <moritz_> pmichaud: are all synopsis in the pugs repo now?

[20:46] <pmichaud> I can get them handy.  :-)

[20:46] <pmichaud> moritz:  yes.

[20:48] <literal> where were they before?

[20:48] * ruoso entering annoying mode...

[20:48] <ruoso> TimToady, have you seen my earlier question?

[20:48] <moritz_> literal: in the svn.perl.org repository

[20:49] <literal> ok

[20:49] <TimToady> ruoso: yes, I think there are 4 or 5 levels of laziness/eagerness we need to look at supporting

[20:50] <ruoso> looks complicated

[20:50] <TimToady> on one end there's strictly eager that returns you the entire list

[20:50] <pmichaud> TimToady: okay if they go in as one commit instead of three?

[20:50] <TimToady> at the other is strictly lazy that only does the minimal work to return 1 value

[20:50] <TimToady> pmichaud: sure

[20:51] <TimToady> but we also want to support mostly-eager, that does everything not known to be infinite

[20:52] <TimToady> and mostly-lazy, that returns a list of what we know right now without doing any more (significant) work

[20:52] <TimToady> where 'significant' might also have more than one meaning

[20:52] <pugs_svn> r24060 | pmichaud++ | (re-)apply larry++ commits since repository was archived.

[20:52] <TimToady> my assumption is mostly-lazy will be more efficient than strictly lazy

[20:53] <pmichaud> okay, the synopses are migrated.

[20:54] <TimToady> in any case, we need an item context iterate, and more than one list-context iterate

[20:54] <TimToady> which might be a single function with a laziness knob

[20:55] *** masak joined
[20:55] <TimToady> beyond that, I suspect which approaches are most efficient and dwimmy may be platform dependent

[20:55] <TimToady> so I'm inclined to bind to mostly lazy and mostly eager by default, with pragmatic control in a lexical scope for other defaults

[20:56] <TimToady> but I'm also interested in seeing the various platforms participate in the design of this, which is another reason the new S7 is out in the pugs repo

[20:57] *** araujo left
[20:58] <pmichaud> excellent, hadn't seen that yet.

[20:58] <ruoso> TimToady, so I think we do need an Iterator type

[20:58] <TimToady> oh, and there's hyper in there somewhere as well

[20:58] <pmichaud> ...where is the S7?

[20:58] <TimToady> ain't one yet

[20:58] *** araujo joined
[20:58] <pmichaud> ohhhhhh

[20:58] <TimToady> it's one of the numbers I stole on the spreadsheet the other day

[20:59] <pmichaud> I misunderstood "is out in the pugs repo"

[20:59] <pmichaud> we should put an index into Spec/

[20:59] <pmichaud> call it S00.pod   :-P

[21:00] <TimToady> copy from http://spreadsheets.google.com/ccc?key=p8pKFfWF0Bj2rv7Fsq9u4eA maybe

[21:00] <pmichaud> commits to the synopses will now go to pugs-commits list.  Should commits to docs/Perl6/Spec/  also go to p6l ?

[21:00] <moritz_> pmichaud: yes, IMHO

[21:01] <TimToady> yes, IMNSHO

[21:01] <pmichaud> 1+infinity == the 'ayes' have it.

[21:01] <ruoso> TimToady, what do you think about the approach in http://www.perlfoundation.org/perl6/index.cgi?smop_map_operator

[21:01] <TimToady> it's surreal...

[21:01] <lambdabot> Title: SMOP map operator / Perl 6

[21:01] <TimToady> so we need a surreal iterator as well, that goes beyond infinity

[21:02] <ruoso> TimToady, I'm mostly trying to figure out how that is represented in terms of an API

[21:03] <ruoso> considering I'd expect it to be easily re-implemented by the user

[21:03] *** alech joined
[21:05] <TimToady> looks relatively sane to have different actual types that depend on the context; at bind time you could call the iterator factory to make the right subtype

[21:06] <ruoso> right... that was my plan

[21:06] <ruoso> so we have two parts on that issue

[21:06] <ruoso> 1) the iterator api

[21:06] <ruoso> which is always lazy

[21:06] <ruoso> 2) the eagerness triggers

[21:06] <TimToady> if we have list iterators that can return multiple values, then for might prefer an iterator that returns N values without having to call item = multiple times

[21:07] <ruoso> we do have list iterators that can return multiple values, aka, map

[21:07] <TimToady> how you structure it will depend on how efficient/inefficient the lazy item = is

[21:08] <TimToady> I think defining everything in terms of item = is likely to be a performance mistake

[21:08] <TimToady> but maybe not

[21:08] <ruoso> I'm considering that optimizations can be done

[21:08] <ruoso> if you know then actual implementation type

[21:08] <TimToady> okay, as long as the API is rich enough

[21:09] <pmichaud> at the same time, rich api should not be too constraining

[21:09] <TimToady> we can probably afford a fairly rich API since most of this is hidden from the user

[21:09] <ruoso> hidden from "most" users

[21:09] <ruoso> but available to some

[21:09] <ruoso> that's my point

[21:09] <ruoso> and in SMOP, it will be implemented in terms of the API at start...

[21:10] <ruoso> only optimizers will get it faster, later...

[21:10] <TimToady> sure, but even the API might have some implementation dependencies...

[21:10] <TimToady> unless we're sure everything can be expressed in terms of everything else.

[21:11] <TimToady> well, probably too early to worry about that

[21:11] <ruoso> that's an assumption I'm making

[21:11] <ruoso> SMOP actually needs it

[21:11] <ruoso> because that's how SMOP is bootstrapping its type system

[21:11] <pmichaud> I think "everything can be expressed in terms of everything else" might limit implementations a bit.  But I'll wait for a spec.

[21:11] <TimToady> other platforms will provide other primitives, likely

[21:11] <ruoso> pmichaud, if the interpreter know all the participants, it can optimize away the API use

[21:12] <TimToady> and if a platform doesn't provide a particular degree of laziness, it's just have to collapse one or more levels

[21:12] <pmichaud> "interpreter knows all the participants"  I find to be unrealistic in many cases.

[21:12] <pmichaud> for on, it sounds like we're assuming an interpreter.  :-)

[21:12] <pmichaud> *one

[21:12] <ruoso> s/interpreter/runtime/

[21:13] <ruoso> pmichaud, the thing is that, in Perl 6, you can't really know from start if the type is the type

[21:13] <ruoso> you only know that at very late run time

[21:13] <pmichaud> ruoso: I agree.

[21:13] <ruoso> and that applies to very basic language operations

[21:13] <ruoso> because there are no basic language operations...

[21:13] <ruoso> everything is dispatched as high-level

[21:14] <ruoso> so foreign objects will be potentially used by otherwise low-level operators

[21:14] <ruoso> but most of the time,

[21:14] <ruoso> you'll be dealing with native types

[21:14] <ruoso> er...

[21:14] <ruoso> native meaning things in your code base

[21:14] <ruoso> i.e. p6opaque

[21:15] <pmichaud> as I said, I'll wait for a spec and comment then.

[21:15] <ruoso> or a compact int array

[21:15] <pmichaud> okay, pugs commits to docs/Perl6/Spec are now being sent to p6l.

[21:15] <TimToady> I think the best way to develop this api is by bouncing a straw man back and forth a few times

[21:16] <ruoso> the thing is that in SMOP, I start assuming everything is foreign

[21:16] <pmichaud> Someone probably needs to subscribe or otherwise whitelist messages coming from [email@hidden.address]
[21:16] <pmichaud> I'm not sure how to do that.

[21:16] <ruoso> so I can have dumb types in SMOP that play the role of high-level types

[21:16] <ruoso> i.e. "constant identifiers"

[21:17] <pmichaud> I'll bbl.

[21:17] <ruoso> that's why an API is so important to me

[21:17] <ruoso> so I can replace the dumb implementations with the complete ones as the runtime evolves

[21:18] <ruoso> TimToady, but anyway... is it ok to assume that List assignment should replace its internal storage, leaving the references to the old storage valid?

[21:20] *** PtZ joined
[21:20] <ruoso> that question basically means: Is list assignment implemented by the lvalue list itself? or does the runtime replaces the array?

[21:21] * ruoso have to leave now...

[21:21] * ruoso will backlog

[21:22] *** ruoso left
[21:24] <TimToady> the goal for assignment in general is for it to work as much as possible like Perl 5 does it, within reason

[21:25] <TimToady> there isn't really a "list assignment" exactly.  There's assignment to an array, and assignment to a slice.

[21:26] <TimToady> a slice assignment just sends as many values (copy semantics) to each element that wants them, left to right

[21:26] <TimToady> if any element of the slice is an entire array or hash, then the rest of the list is treated as a array/hash assignment

[21:26] <TimToady> with array/hash assignment, the container empties itself, then copies everything in

[21:28] <pmichaud> back (finished putting thanksgiving groceries away)

[21:28] *** PZt left
[21:29] <pmichaud> TimToady: what you describe sounds like the way rakudo is going.

[21:29] <pmichaud> (or, perhaps I should say that my plans for rakudo match what you just said.)

[21:31] <TimToady> note that p5 goes to extra lengths to make sure that ($a,$b) = ($b,$a) works without clobbering the rhs value of $a

[21:34] *** schmalbe left
[21:37] <TimToady> and, in fact, a strictly lazy implementation cannot do ($a,$b) = ($b,$a) properly at all

[21:37] <pmichaud> on this topic, S02-literals/autoref.t has stuff like:

[21:37] <pmichaud>     @other[1] = @array;

[21:37] <TimToady> so I think the moslty-eager is the right default for assignment

[21:37] <pmichaud> where it expects @array to become an arrayref.  I think that's a list assignment.

[21:38] <TimToady> yeah

[21:38] <pmichaud> to do the arrayref, would   @other[1] = $@array;    work?

[21:38] <TimToady> or item @array

[21:38] <pmichaud> okay

[21:38] <TimToady> or [@array], of course

[21:38] <pmichaud> I'll change the tests, then.

[21:39] <pmichaud> that answers one of my (as yet unanswered) questions on p6l

[21:39] <TimToady> hmm, don't recall seeing that one

[21:39] <pmichaud> I think you might've been shouldering other issues then.

[21:40] *** hercynium left
[21:41] <pmichaud> original at http://groups.google.com/group/perl.perl6.language/msg/98b5281381d4a2b1

[21:41] <TimToady> always seem to get ADD when I don't need it, and vice versa...

[21:41] <lambdabot> Title: More about arrayref/hashref in spectest suite - perl.perl6.language | Google Gro ..., http://tinyurl.com/6cmvb9

[21:43] <moritz_> rakudo: say [].min

[21:43] <p6eval> rakudo 33241: OUTPUT[Use of uninitialized value␤␤]

[21:44] <masak> bug? :)

[21:44] *** Lorn left
[21:44] <pmichaud> min of an empty list should be...?

[21:44] <masak> Inf?

[21:45] <TimToady> +Inf

[21:45] <moritz_> NaN? undef? FATAL_WARNING?

[21:45] * masak files rakudobug

[21:45] <TimToady> according to S03, if you consider it equiv to [min]()

[21:46] <pmichaud> undef is what it returns now.

[21:46] <pmichaud> and .min isn't constrained to be numeric, is it?

[21:47] <TimToady> no, but +Inf isn't constrained to be numeric either, necessarily

[21:47] <pmichaud> ah.  :-)

[21:47] <Tene> p6eval: [].min

[21:48] <pmichaud> Tene: try 'rakudo' or 'perl6'

[21:48] <literal> perl6: [].min

[21:48] <p6eval> pugs: No output (you need to produce output to STDOUT)

[21:48] <p6eval> ..elf 24060: RESULT[undef␤]

[21:48] <p6eval> ..rakudo 33243: RESULT[undef]

[21:48] <moritz_> pugs is broken in p6eval atm

[21:49] <pmichaud> it might be nice if p6eval responded to "p6eval:"

[21:51] <moritz_> pmichaud: with a usage message? or with the same as 'perl6:'?

[21:52] <pmichaud> I was thinking same as 'perl6'

[21:52] *** smg left
[21:52] <pmichaud> but usage message could work.

[21:52] *** pbuetow joined
[21:56] <pugs_svn> r24061 | moritz++ | [evalbot] implement usage message as suggested by pmichaud++

[21:57] *** p6eval left
[21:57] *** p6eval joined
[21:57] <moritz_> p6eval: say "hi"

[21:58] <moritz_> rakudo: say "alive"

[21:58] <p6eval> rakudo 33243: OUTPUT[alive␤]

[22:05] * moritz_ wonders why it didn't work...

[22:07] <mncharity> back

[22:09] <mncharity> TimToady: where are we at?

[22:12] <TimToady> mncharity: re (a), currently STD generates a new lexer for every macro, which seems to chew up memory quickly

[22:12] <TimToady> I need to find some way of cutting down unnecessary lexer generation

[22:14] <mncharity> macro?  you mean   multi infix:<blah>  decls?

[22:15] <moritz_> if there'a already a proto for that another multi shouldn't require a new lexer.

[22:18] *** Bzek left
[22:18] <mncharity> there are 50 multis.  but little overlap - almost all are distinct... (don't know what our vocabulary is)... names.

[22:18] <wayland76> Are macros generally better than eval?

[22:18] <moritz_> is fish better than bycicles? ;-)

[22:19] <masak> yes!

[22:19] <masak> (at least in water)

[22:19] <mncharity> So 50 lexers at 3GB is order 100MB per lexer... does that sound plausible?

[22:19] <wayland76> And certainly tastier :)

[22:21] <wayland76> Maybe a different question; do macros have less chance of causing runtime errors?

[22:21] *** adc_penner left
[22:23] <moritz_> do fishes contain more plutonium than bycicles? ;-)

[22:24] <moritz_> wayland76: a randomly written macro will likely cause as many errors as feeding random data to eval

[22:24] <mncharity> wayland76: re fish riding bicycles, fish get compiled away at compile time.  So you can have abstractions which don't have a runtime performance cost.  The compiler can see and optimize.

[22:25] <masak> moritz_: as far as I know, fishes contain no bicycles at all...

[22:26] <moritz_> masak: at least not the small fishes ;)

[22:26] <masak> and the large ones are mammals :)

[22:29] <pugs_svn> r24062 | lwall++ | [Spec] get started on the renaming

[22:29] *** dukeleto joined
[22:29] <wayland76> Well, I think that pretty much covers everything.  Thanks :)

[22:30] <wayland76> Incidentally, on the topic of Iterators, I had a go at implementing tree iterators for Perl6 using the SMOP map interface

[22:31] <mncharity> TimToady: ok, thanks.  regards (b), any guidance on whether I should expect to see it fixed in current weeks, or should proceed with working around it?

[22:31] <pugs_svn> r24063 | lwall++ | [Spec] more name stuff

[22:31] <wayland76> Apart from the fact that I needed to pass in a bunch of parameters to determine the iterator type (self-or-descendant, child, following, whatever), it was sufficient to the task

[22:32] <mncharity> fyi, with the 51 multis pruned to 25, it looks like memory usage tops off at 2GB.

[22:33] <pugs_svn> r24064 | lwall++ | [Spec] bleah, svn getting confused, and so am I

[22:34] <TimToady> mncharity: re (b), .() is parsed as any other postfix, so notionaly is a wrapper around the "name

[22:34] <TimToady> "

[22:38] <masak> TimToady: can I assign the value *-4 to a variable?

[22:39] <masak> (I'm trying to figure out how magical Whatever stars in indexes really are)

[22:39] <mncharity> And 12 multis is 1.2GB.   So two datapoints and an inequality suggest ~100MB per lexer.  so 100MB per 'multi foofix:blah (...){...}'.  ah well.  I can split the file in half as a temporary hack.

[22:39] <pugs_svn> r24065 | lwall++ | [Spec] more twiddling

[22:44] <pugs_svn> r24066 | lwall++ | [Spec] more renaming

[22:47] *** masak left
[22:49] *** mncharity1 joined
[22:50] <mncharity1> sorry about that.  non-graceful system go boom.  backlogging.

[22:51] <TimToady> basically I need to figure out when it's okay to clobber the current grammar in place instead of deriving a new one

[22:51] <TimToady> or find a way of doing lightweight derived languages

[22:51] *** Psyche^ joined
[22:54] *** ruoso joined
[22:55] <ruoso> Hello!

[22:55] <mncharity1> TimToady: re lexers, it looks like I'm all set.  For elf bootstrap work, I can get by with a halved prelude.

[22:55] <TimToady> okay, though that doesn't help with the (lack of) speed

[22:56] <mncharity1> hi ruoso :)

[22:56] <ruoso> hi mncharity1 

[22:56] <ruoso> TimToady, so is it sane to think that @a = @b implies creating a third list that is then stored in VAR(@a) ?

[22:57] <mncharity1> TimToady: re speed, for elf bootstrap work, I can cache.  hmm, though...  can viv parse STD.pm itself?  That's my next step.  And it has a bunch of foofix:bar decls I think... checking...

[22:57] <TimToady> p5 only creates the 3rd list if there is a shared name, but in the abstract, yes

[22:57] <TimToady> sure, viv parses STD

[22:57] *** Patterner left
[22:57] *** Psyche^ is now known as Patterner

[22:58] <TimToady> and caches lex/STD.pm.store for everything else to use

[22:59] <TimToady> mncharity1: no, it has foofix:sym<> declarations really, which are a lot cheaper

[22:59] <TimToady> because they don't modify the current grammar on the fly

[22:59] <mncharity1> mncharity1: re (b) and "parsed as any other postfix", so is  token variable's #= methcall branch, with its postcircumfix field, now unused?

[22:59] <ruoso> TimToady, considering how deep the lazyness can go, I'd say it's pretty hard to figure out if you can avoid creating a third list (unless it's the only assignment to that list)

[23:00] <TimToady> but assignment is now defined as eager, I believe

[23:00] <TimToady> or mostly-eager

[23:00] <ruoso> sure...

[23:01] <TimToady> but yes, you'd still have to glare at it pretty hard to determine non-overlap

[23:01] <mncharity1> re foofix:sym<> are a lot cheaper...  foofix:sym<xx>  is different than  foofix:<xx>  ?

[23:01] <TimToady> yes

[23:01] <TimToady> we use different names for talking about the rules that parse an operator than the name of the operator itself

[23:02] <TimToady> so grammars can distinguish their own operators from what they're parsing

[23:02] <TimToady> a grammar can parse prefix:sym<++> without changing the meaning of its own prefix:<++>

[23:03] *** Psyche^ joined
[23:03] <TimToady> and the foofix:bar shortcut is probably a bit confusing that way, since it's really short for foofix:sym<bar>

[23:03] *** mncharity left
[23:04] <ruoso> TimToady, so it is sane to think that all the eagerness is evaluated by the interpreter? not by the list object itself and its fellow iterators...

[23:04] <ruoso> (by "interpreter" here I refer to all the infra-structure that is external to the object)

[23:05] <TimToady> I think it's too sane

[23:05] <ruoso> is that bad?

[23:05] <mncharity1> hmm....   so it sounds like  http://svn.pugscode.org/pugs/misc/elf/elf_h_src/PrimitivesP5.pm 's  multi prefix:<++> (...) etc can and should be prefix:sym<++> instead, and that will make the performance problem go away?

[23:05] <TimToady> I don't think it will perform well if iterators don't know how to return a "batch" when that's appropriate

[23:06] <ruoso> TimToady, again... I assume that's a job for the optimizers

[23:06] <TimToady> mncharity1: only if you write it as a grammar rather than a prelude

[23:06] <TimToady> and then you'd have to run it through gimme5 currently

[23:07] <TimToady> if the prelude wants to discuss its own operators then it needs to use the non-:sym form

[23:08] <TimToady> now, it's certainly *possible* to express a lot of prelude in grammar, after all, half of what's in STD should be in the prelude, conceptually

[23:08] <mncharity1> re "only if you write it as a grammar"... ah.  hmm.  or I simply declare it a temporary fudge.  gimme5 isn't even being given the elf preludes, it's just getting by on its own.

[23:10] <mncharity1> ok, so that leaves (b).  is  token variable's methcall branch depreciated?

[23:11] <ruoso> TimToady, but is it sane to assume that the iterators should provide at least the full-blown API? while it's implementation-dependent when that API is actually used?

[23:13] <TimToady> no, I think it's probably just broken

[23:13] <TimToady> there should probably be a .[0] in there since $<twigil> is optional

[23:14] <TimToady> and probably a .text too

[23:15] <TimToady> ruoso: I don't know which one you mean by "full-blown"

[23:15] <ruoso> TimToady, the API that won't probably perform well...

[23:15] <TimToady> I'd call that one the minimal one, not the full-blown one...

[23:16] <ruoso> ok... agreed..

[23:16] <mncharity1> ok.  my thanks.  I'm all set.  I'll kludge (a), and deal with (b) as a temporary workaround if I confront it before it gets fixed.

[23:16] <ruoso> TimToady, and the runtime should use the minimal API with every custom iterator

[23:16] <TimToady> certainly if item context is pulling items out one by one, you have to have some mechanism for storing the rest of any that you already know

[23:17] <ruoso> that's what I've been calling "iterator in item context"

[23:17] *** Patterner left
[23:17] *** Psyche^ is now known as Patterner

[23:18] <ruoso> it would store the capture and iterate in its items, as well as consume several times while an empty capture is returned

[23:22] *** smg joined
[23:23] <ruoso> that's how map { }, grep { }, map { } can work

[23:23] *** pbuetow left
[23:23] <TimToady> assuming an empty capture is distinguishable from out-of-data

[23:24] <ruoso> sure... out-of-data is an exception, as you said other day

[23:27] <TimToady> now considering what happens when someone wants to generate a list of exceptions...

[23:27] <ruoso> TimToady, a list of exceptions is still returned inside a capture

[23:29] <TimToady> trew nuff

[23:29] *** bacek_ joined
[23:29] <TimToady> it's a good thing one of us is smart

[23:30] <TimToady> mncharity1: I believe I have a fix for $.m(), testing...

[23:30] *** dukeleto left
[23:32] <pugs_svn> r24067 | lwall++ | [STD] fix parsing of $.meth() to attach postcircumfix as special form

[23:32] *** iblechbot left
[23:33] <ruoso> TimToady, so I'll proceed with the API in the wiki

[23:36] <mncharity1> TimToady: oh, yay!  hmm... now just how late can I be for dinner...

[23:39] <TimToady> ruoso: feel free to transcribe that into S07-iterators.pod if you like too

[23:41] <TimToady> and if you're feeling particularly energetic you can write S08-captures.pod while you're there too  :)

[23:47] <meppl> good night

[23:49] *** meppl left
[23:51] <wayland76> S07++ and S08++ :)

[23:54] *** hercynium joined
[23:54] *** vixey left
[23:54] <pugs_svn> r24068 | jnthn++ | [t/spec] Unfudge a couple of array passing tests for Rakudo.

[23:57] <mncharity1> almost there...

[23:57] <mncharity1> good night all! &

[23:57] <pugs_svn> r24069 | putter++ | [STD_blue] $.meth() works.  TimToady++

[23:57] <pugs_svn> r24069 | putter++ | 3 more elf source files work.

[23:57] *** mncharity1 left
