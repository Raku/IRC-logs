[00:01] *** SamB joined
[00:24] *** hercynium joined
[00:28] *** alester joined
[00:34] *** ruoso joined
[00:37] <ruoso> Arathorn, re thread: the basic idea is that a thread is a high-level entity and that you wouldn't be executing code from one "continuation (even if using different runtimes)" from different threads

[00:39] <ruoso> Arathorn, if you're in one thread and you swith over the execution to another runtime interpreter, that continuation must still be in the same thread

[00:39] <ruoso> Arathorn, but in fact... the threading model wasn't very much stressed beyound the use of pthreads...

[00:40] <ruoso> Arathorn, if you're interested, you could start sketching conceptual exercises so we can stress this issue...

[00:44] *** bacek joined
[00:48] * Arathorn tries to wrap his head 'round that

[00:50] <ruoso> Arathorn, think of threads as "continuations" instead of os threads... the relationship between them may or may not be 1..1

[00:51] <Arathorn> right, i think I get that

[00:53] <Arathorn> does that mean that the smop runloop itself is always single threaded, then - relying on the native runtimes to marshal/unmarshal object invocations/messages to the right thread?

[00:54] <Arathorn> or you just swap between the continuations which relate to the current native-runtime threads of execution within the main smop runloop

[00:54] <Arathorn> which again makes it sound as if everything gets flattened down to single-threadedness

[00:54] <ruoso> Arathorn, kind of... yes...

[00:54] *** sail0r left
[00:55] <ruoso> but eventually the runtime can decide that this "group of threads" will be handled by a different process

[00:55] <ruoso> the basic idea is something I steal from Erlang and IO (a language called IO, yes)...

[00:55] <ruoso> which is to hide the concept of a OS thread from the user

[00:56] <ruoso> letting the runtime decide when to open a new os thread or not...

[00:56] * Arathorn nods

[00:56] <ruoso> most of the time you don't really need a thread

[00:56] <Arathorn> right - so smop would essentially be providing a pthreads implementation for the runtimes running on it, which is implemented by continuations (which may in turn be shared between concurrent smop runloops)?

[00:56] <ruoso> exactly

[00:56] <Arathorn> interesting, and rather cool :)

[00:56] <ruoso> like bringing POE to the runloop

[00:57] * Arathorn nods

[00:57] <ruoso> except that it can be preemptive... because p6 supports continuations, while p5 doesn't

[00:59] <Arathorn> in terms of how you'd program it from p6, i guess so

[00:59] * Arathorn gets confused about the fact that whilst p5 doesn't support continuations, one could still snapshot the stack of its runtime in order to run it within the smop event loop

[01:01] *** MeGaMiC joined
[01:01] <ruoso> Arathorn, it could be done if p5 was completely stackless.. but unfortunally that's not the case

[01:01] <ruoso> nothingmuch was planning to work on making p5 stackless, which would make it even easier to integrate smop and p5

[01:02] * Arathorn nods

[01:03] <ruoso> that's actually one step in the secret plan of including smop as part of p5 ;)

[01:03] <ruoso> like adding smop dispatch as one of the p5 ops

[01:03] <ruoso> but that's for the future, and only a supposition at this moment...

[01:04] * ruoso sleep & 

[01:04] * ruoso will backlog, as usual...

[01:05] <Arathorn> night :)

[01:05] <ruoso> ;)

[01:05] <Arathorn> and thanks for the clarification

[01:05] * Arathorn reads up on stackless VMs

[01:05] <ruoso> Arathorn, the stackless python project was a very interesting reading

[01:05] <ruoso> #stackless at this network

[01:06] <ruoso> but the python people don't think continuations are a good feature, so the patches never made into the official python

[01:06] <Arathorn> that's what i'm reading :)

[01:06] * ruoso really sleep &

[01:06] <Arathorn> (well, the ML thread on it from 2002)

[01:37] *** sri_work left
[01:49] *** seanstickle joined
[01:58] *** seanstickle left
[02:11] *** penk joined
[02:17] *** wknight8111 left
[02:22] *** broquaint joined
[02:24] <awwaiid> in the meantime, Coro seems to work for doing cooroutines, aka "one could still snapshot the stack of its runtime..." (Aratorn)

[02:24] <awwaiid> er, Arathorn

[02:29] *** MeGaMiC left
[02:39] <Arathorn> mm

[02:39] * Arathorn looks into Coro

[02:43] <Arathorn> hm, i don't understand whether that's implementing coroutines on top of the p5 vm, or somehow messing with p5-internals to swap stacks around

[02:43] <Arathorn> ...probably because it's getting on for 4am

[02:44] * Arathorn sleep & # thanks for the pointer :)

[02:53] *** penk left
[02:57] *** Chillance left
[03:01] <awwaiid> messing with p5-internals

[03:02] <awwaiid> and all sorts of horrbile things

[03:02] <Arathorn> yeah

[03:02] * Arathorn was just rummaging in its XS

[03:02] <awwaiid> but it works! sometimes

[03:02] <Arathorn> really sleep, anyway

[03:02] *** Arathorn left
[03:02] <awwaiid> cya :)

[03:19] *** kanru left
[03:37] *** fridim_ joined
[03:49] *** kanru joined
[04:19] *** bacek_ joined
[04:28] *** bacek left
[04:32] *** AzureStone_ joined
[04:34] *** Alias__ left
[04:49] *** AzureStone joined
[04:49] *** AzureStone_ left
[05:23] *** hercynium left
[05:30] *** fridim__ joined
[05:31] *** xinming joined
[05:41] *** c1sung joined
[05:42] *** Psyche^ joined
[05:43] *** fridim_ left
[05:44] *** fridim_ joined
[05:52] *** fridim__ left
[05:59] *** Psyche^ is now known as Patterner

[06:18] *** allbery_b joined
[06:22] <pugs_svn> r21758 | pmichaud++ | S29-str/substr.t:  mark a #?rakudo skip for substr as lvalue

[06:28] *** ilogger2 joined
[06:34] *** ashizawa joined
[06:55] *** Lunchy_ joined
[06:55] *** Lunchy left
[06:56] *** masak joined
[06:58] *** MeGaMiC joined
[07:32] *** luqui joined
[07:45] <pugs_svn> r21759 | moritz++ | [t/spec] unfudge and s/skip/todo/ some tests for rakudo

[07:45] *** justatheory joined
[07:51] <masak> moritz_: welcome back :)

[07:52] <moritz_> masak: I just went to parents to get some internet access.... real vacations start von wednesday ;)

[07:52] <moritz_> masak: btw I identified the weird failures that I had with tools/test_summary.pl

[07:53] <moritz_> masak: it was my PERL6LIB env variable which pointed to pugs' Test.pm

[08:02] <masak> ah.

[08:02] <masak> moritz_: are you coming to YAPC::EU?

[08:02] <moritz_> so now I filed a bug report to report the file name in which the syntax error occured

[08:02] <moritz_> masak: no :(

[08:03] <masak> moritz_: good about the bug report, too bad about YAPC::EU

[08:03] <moritz_> yes, indeed

[08:03] <masak> looking forward to meeting you someday.

[08:06] <moritz_> me too

[08:16] *** pmurias joined
[08:18] <pmurias> masak: i'm assuming you will be at YAPC::Europe 

[08:18] <masak> pmurias: aye

[08:19] <masak> ...with the main goal of being as helpful to rakudo/Perl 6 as possible while I'm there

[08:28] <pugs_svn> r21760 | audreyt++ | * Add dependencies from hackage for offline install.

[08:31] <pugs_svn> r21761 | audreyt++ | * Update cabal-install to our severely hacked version that should hopefully

[08:31] <pugs_svn> r21761 | audreyt++ |   be merged with cabal-install 0.5.3.

[08:31] *** zamanfou joined
[08:32] <pugs_svn> r21762 | audreyt++ | * Add local repos cabal-install support.

[08:39] <pugs_svn> r21763 | lwall++ | s/q:code/quasi/ plus various t/ buglets

[08:43] <pugs_svn> r21764 | audreyt++ | * Add 00-index.tar that only includes Pugs dependencies.

[08:58] <pugs_svn> r21765 | audreyt++ | * Add the missing InstallSymlink.hs

[09:00] <pugs_svn> r21766 | moritz++ | [t/spec] a few passing tests for rakudo in S03-operators/assign.t

[09:00] <pmurias> the perl6 wiki link on pugscode.org is broken

[09:01] <moritz_> should it point to http://www.perlfoundation.org/perl6/index.cgi ?

[09:01] <lambdabot> Title: Perl 6 / Perl 6

[09:04] <pugs_svn> r21767 | audreyt++ | * directory cleanup

[09:10] <pmurias> moritz_: guess so

[09:26] <pugs_svn> r21768 | moritz++ | [docs/feather] fixed wiki link on homepage, pmurias++

[09:28] <pugs_svn> r21769 | moritz++ | [STD] new make target testt for running all of t/, not just t/spec/

[09:30] <pugs_svn> r21770 | audreyt++ | * Makefile.PL: Install prerequisites automatically without connecting to hackage.haskell.org.

[09:30] <moritz_> (that was probably not the link pmurias meant... dammit)

[09:33] <pugs_svn> r21771 | moritz++ | [t] fixed test in builtins/math/complex_powers.t

[09:33] * moritz_ wanders off...

[09:36] <pugs_svn> r21772 | audreyt++ | * Offline installation completed; it now works on a vanilla GHC 6.8.

[09:41] <pmurias> moritz_: i meant the Perl6 Wiki one

[09:44] <pmurias> masak: i can show you how smop works at the yapc

[09:44] <masak> pmurias: that'd be much appreciated

[09:45] <masak> so far I've only read a wiki page on it

[09:46] * zamanfou is now away: In the rain my tears are forever lost.

[09:47] <pugs_svn> r21773 | audreyt++ | * Explicitly add stm to depends

[09:50] <masak> zamanfou: your tears are forever lost in the rain quite often on this channel, methinks

[09:56] *** smtms joined
[09:57] *** elmex joined
[10:02] *** ashizawa_ joined
[10:02] *** ashizawa_ left
[10:03] *** ashizawa left
[10:10] *** fridim__ joined
[10:21] * ruoso later &

[10:34] *** fridim__ left
[10:45] *** wknight8111 joined
[11:10] *** ruoso joined
[11:11] *** icwiener joined
[11:22] *** pmurias left
[11:22] *** pmurias joined
[11:23] <ruoso> hi pmurias!

[11:25] *** pmurias_ joined
[11:25] *** pmurias_ left
[11:26] *** pmurias left
[11:26] *** pmurias joined
[11:26] <pmurias> ruoso: hi!

[11:27] * ruoso eat something &

[11:27] <ruoso> pmurias, Mold is very cool... I'm looking forward to see it replacing slime asap

[11:27] * ruoso brb &

[11:41] *** wknight8111 left
[11:43] <masak> pmurias: you could start now by explaining how smop fits into the big Perl 6 picture

[11:45] <pmurias> smop is a runtime for Perl 6 to run on

[11:48] <pmurias> it's similiar to parrot in it's part in the picture but makes very different choices for most things

[11:48] <pmurias> s/most/some/

[11:50] <ruoso> pmurias, we could talk with the organizers of yapc::eu for you to replace me in the smop talk... 

[11:50] <ruoso> what do you think?

[11:51] <pmurias> i could try to give it

[11:51] <ruoso> you can change the slides if you want ot

[11:51] <ruoso> s/ot/to

[11:52] <ruoso> and they are out-of-date atm...

[11:53] <ruoso> pmurias, do you want the original openoffice file for the slides?

[11:54] *** BinGOs joined
[11:56] <pmurias> ruoso: i think so, editing a pdf might be hard

[11:56] <ruoso> heh

[11:57] <Grrrr> ruoso, pmurias: shall I change the "owner" of the talk now?

[11:58] <ruoso> Grrrr, that's fine by me...

[11:59] <Grrrr> pmurias?

[11:59] <pmurias> yes

[12:00] <ruoso> pmurias, the slides are on the way to your inbox

[12:00] <masak> pmurias: what can I do in smop today? what makes it attractive to hack on rather than, say, rakudo?

[12:00] <ruoso> masak, take a look at test/22

[12:00] <audreyt> pmurias: are there some sample inputs to .m0ld?

[12:01] <ruoso> masak, that's an example of one of the cool things we're doing already

[12:01] <pmurias> audreyt: the code on the wiki is what i use for testing the parser

[12:01] <audreyt> pmurias: except it doesn't yet parse?

[12:01] <Grrrr> pmurias: ok, now if you login to Act you should be able to see it as your talk and edit it as you see fit;  do you want a refund for your registration?

[12:01] <masak> ruoso: where? the pugs repo contains neither a 22 nor a 22.t file

[12:02] <ruoso> masak, v6/smop/test/

[12:02] <audreyt> masak: v6/smop/test/22_smop_s1p_attribute.sm0p

[12:02] <masak> ah, thx

[12:02] <pmurias> audreyt: wait

[12:03] <audreyt> seems it doesn't handle string constants

[12:03] <audreyt> k

[12:03] <ruoso> masak, we have a somewhat clear roadmap in the wiki page

[12:03] <pugs_svn> r21774 | pmurias++ | [m0ld] codes and arguments

[12:03] <masak> ruoso: URL?

[12:03] <ruoso> http://www.perlfoundation.org/perl6/index.cgi?smop

[12:03] <lambdabot> Title: SMOP / Perl 6

[12:03] <masak> ruoso: thank-you

[12:04] <pmurias> audreyt: Mold/m0ld is under development, i hoped to finish in a few days and show it to you for review ;)

[12:04] <audreyt> pmurias: ok, meaning I better not hack on it prematurely :)

[12:04] <audreyt> because it's trivial to take Pugs.CodeGen and make it generate m0ld, you know :)

[12:05] <ruoso> trivial is good :)

[12:07] <pmurias> i'll get back to hacking on it as soon as i get my wifi working

[12:07] <ruoso> pmurias, on files that use m0ld blocks (when they replace sm0p), we need an initialization placeholder, right? so the Mold can be initialized....

[12:07] * zamanfou is now away: In the rain my tears are forever lost.

[12:07] <ruoso> zamanfou please remove this f** away message

[12:07] *** luqui left
[12:08] <masak> @slap zamanfou 

[12:08] <lambdabot> why on earth would I slap zamanfou ?

[12:08] <masak> true, he being away and all... :/

[12:08] <masak> s/he/him/

[12:10] *** MeGaMiC left
[12:10] <audreyt> sorry for the very basic question, but how should one go about adding inheritance to smop?

[12:10] *** Jedai joined
[12:11] <pmurias> ruoso: m0ld dosn't emitting anything yet

[12:11] <pmurias> but Mold shouldn't need much initalization just create a Mold and make Mold__Frames using it

[12:12] <pmurias> wifi and wifi using mobile phone installation&

[12:12] <ruoso> yes... and we want to create the mold during smop_init, don't we?

[12:12] <ruoso> for the objects that are initialized in that phase, of course...

[12:13] <ruoso> audreyt, we need a metaclass 

[12:13] <pmurias> ruoso: it's already done

[12:13] <ruoso> audreyt, p6opaque currently delegates all calls to .^dispatch

[12:13] <ruoso> audreyt, that's already working... we just need a metaclass that implements the inheritance

[12:14] <ruoso> pmurias, sorry... I got confused, what is already done?

[12:14] <ruoso> audreyt, take a look at test/14

[12:15] <audreyt> ok

[12:16] <audreyt> I was looking at v6/smop/src-s1p/P6Meta.pm

[12:16] <ruoso> that's the start of it, yes... but we still need the dispatch code

[12:16] <ruoso> and we also need to compile that to C+m0ld

[12:17] <ruoso> (this compiler being the thing I've been calling s1p)

[12:17] <ruoso> and obviously, we need all the operators we use in that code...

[12:17] <audreyt> by "the dispatch code" you mean the code that does delegation to parent classes

[12:17] <audreyt> right?

[12:18] <ruoso> not only that... but the entire dispatch... including multi and stuff

[12:18] <ruoso> p6opaque delegates all calls (except for REPR calls) to the metaclass instance

[12:18] <audreyt> why is that? does src-s1p uses multis?

[12:19] <ruoso> audreyt, http://www.perlfoundation.org/perl6/index.cgi?smop_oo_api

[12:19] <lambdabot> Title: SMOP OO API / Perl 6

[12:19] <ruoso> audreyt, no... I mean... the thing that will support multis when someone uses it is the metaclass instance

[12:19] <audreyt> oh. that makes more sense. thanks

[12:20] <audreyt> (and yes I've read through the available docs :))

[12:20] <ruoso> :) 

[12:20] <ruoso> audreyt, you're actually one of the qualified people to write the dispatcher :)

[12:21] * ruoso doesn't consider itself one

[12:21] <audreyt> that what I'm pondering doing, yes.

[12:21] <audreyt> that, or the s1p compiler

[12:21] <ruoso> s/itself/himself/

[12:21] <ruoso> audreyt, you could take both ;) ;) ;)

[12:21] <ruoso> considering you'll need the compiler to test the metaclass

[12:21] <ruoso> ;)

[12:22] <audreyt> fair point

[12:24] <pugs_svn> r21775 | moritz++ | [t] some updates to README, and fixed all but one smartlink in t/spec/

[12:27] *** pmurias left
[12:32] * ruoso wonders if yapc::eu will have video records of the talks for people who can't go there...

[12:34] <ruoso> audreyt, but... from what you've seen in src-s1p/P6Meta.pm... do you think it's sane?

[12:36] <Juerd> Who's going to yapc::copenhagen?

[12:36] * ruoso 's not going :(

[12:37] <BinGOs> Juerd: I am.

[12:37] <Juerd> BinGOs: Yay

[12:37] * Juerd is too

[12:37] <BinGOs> I am giving a talk!

[12:37] <masak> I'm going.

[12:38] * moritz_ envies all yapc::eu visitors ;)

[12:42] *** cmarcelo joined
[12:46] <masak> aye, visiting YAPC::EU is the new black.

[12:48] <Patterner> Juerd: would you hold it against me if I say "yes"?

[12:48] <Patterner> Blue is the new pink.

[12:49] *** nipotan is now known as nipotaway

[12:50] <Juerd> :)

[12:57] *** BinGOs left
[12:57] *** BinGOs joined
[13:00] *** timbunce joined
[13:00] *** timbunce left
[13:07] <audreyt> ruoso: can we have sm0p5.pm committed inside svn

[13:07] <audreyt> ruoso: for poor people who do not have convenient access to a linux box with ruby 1.9 and perl 5.10? :)

[13:08] <ruoso> that could be a good idea...

[13:08] *** gaal joined
[13:08] <moritz_> .oO( feather? )

[13:09] <pugs_svn> r21776 | ruoso++ | [smop] adding sm0p5.pm for audreyt++

[13:09] <audreyt> moritz_: I do have access to such a box :)

[13:10] <moritz_> ok, I underestimated the "convenient" ;)

[13:25] <audreyt> oh.

[13:25] <audreyt> avar: ping!

[13:28] * moritz_ tries to build pugs on the server that hosts p6eval

[13:29] <moritz_> is a normal 'perl Makefile.PL && make' build an optimized one?

[13:31] <moritz_> I'm getting a few warnings during the build, but so far no errors

[13:31] <audreyt> moritz_: it's fairly optimized

[13:31] <audreyt> not fully optimized, but the diff should be small (<10%)

[13:31] <audreyt> (it's -O1 not -O2)

[13:32] <moritz_> audreyt: ok, thanks

[13:35] <audreyt> avar: OBJECTS in Makefile.PL, instead of LDDLFLAGS, is your friend :)

[13:36] <audreyt> @tell avar http://community.haskell.org/~audreyt/re-engine-TRE-0.05.tar.gz # should build everywhere

[13:36] <lambdabot> Consider it noted.

[13:38] <moritz_> Could not find module `Text.Regex.PCRE': Perhaps you haven't installed the profiling libraries for package regex-pcre-builtin-0.94.1.0.7.7?

[13:38] <moritz_> is this talking about a cabal package?

[13:39] <audreyt> yes. hm.

[13:39] <audreyt> the easiest way out is to say

[13:39] <audreyt> ghc-pkg unregister --user regex-pcre-builtin

[13:39] <audreyt> and then makefile.pl again

[13:40] <audreyt> you may need to do that for each of the complained module

[13:40] <audreyt> Makefile.PL should detect this condition

[13:40] <audreyt> but it will only happen once, and will only happen if you had previously "cabal install Pugs"

[13:41] *** pugs_svn left
[13:44] *** Arathorn joined
[13:45] * moritz_ wonders if it's faster to just rm -rf ~/.cabal/

[13:46] <audreyt> then you need to rm -rf ~/.ghc

[13:46] <audreyt> that is another way yes.

[13:46] <moritz_> otoh that would leave p6eval without pugs, and I don#t know if I'll be around long enough to build a new one

[13:47] <audreyt> it'll take about 15mins.

[13:48] <moritz_> ok, I moved ~/.cabal and ~/.ghc6 to a backup dir

[13:48] <moritz_> pugs: say "hi"

[13:48] <p6eval> pugs: OUTPUT[sh: /home/evalenv/.cabal/bin/pugs: No such file or directory‚ê§]

[13:49] <moritz_> I guess 'make' will put the pugs binary just in root of the repo?

[13:49] <audreyt> correct

[13:49] <Arathorn> is there any intention for smop to allow invocation of p6 code from within one of the other native runtimes, btw? or is the polymorphic eval only good for invoking methods from p6 on any other runtimes within the runloop?

[13:50] <moritz_> evalbot control restart

[13:50] *** p6eval joined
[13:51] <moritz_> rakudo: say "back again"

[13:51] <p6eval> rakudo 29834: OUTPUT[back again‚ê§]

[13:52] * moritz_ is pleased to see that cabal requires even less interaction than cpan

[13:53] <ruoso> Arathorn, I'm not sure I understand your question

[13:53] <moritz_> I think the question is "can I call perl 6 code from python code with smoop?"

[13:54] <Arathorn> exactly

[13:54] <Arathorn> sorry for being unclear

[13:54] <ruoso> as long as we integrate the runloop of the other runtime, yes...

[13:54] <ruoso> that's the planned, actually

[13:54] <Arathorn> right

[13:54] <ruoso> for p5 it seems very much feasible

[13:55] <ruoso> stackless python also seems like a good candidate

[13:55] <pasteling> "moritz" at 91.8.218.102 pasted "pugs build failure - do I need a "make clean" or something?" (7 lines, 485B) at http://sial.org/pbot/31792

[13:56] <audreyt> moritz_: rm -rf dist

[13:56] <audreyt> then make

[13:56] <moritz_> ruoso: I think the differences between standard and stackless python are pretty small

[13:56] <audreyt> that should do it

[13:56] <moritz_> audreyt: thanks, I'll try

[13:56] <audreyt> it'll be only <10min from now

[13:56] <audreyt> maye <5min :)

[13:56] <moritz_> ;)

[13:57] <ruoso> moritz_, the differences are indeed smal... and I can't really understand why the stackless patch wasn't accepted

[13:57] <moritz_> ruoso: propably politics

[13:57] <ruoso> very much possible

[13:57] <moritz_> "then we have to educate our programmers what 'stackless' means..."

[13:58] <ruoso> is that really a quote?>

[13:58] <moritz_> no

[13:58] <[particle]> ruoso: if it were a real quote, you probably would have gotten it emailed to you directly ;)

[13:59] <ruoso> heh

[14:01] * Arathorn is a little confused as to why stackless python is actually called stackless - in that presumably when you resume a continuation of the python runtime, you do so by pointing its frame pointer at a stack (which happens to be a continuation)?

[14:01] <moritz_> Arathorn: because it doesn't use the C level stack to recurse into python subroutines/methods

[14:01] <ruoso> moritz_++ bullseye

[14:02] <Arathorn> how does that help being able to resume the runtime using continuations, though?

[14:02] *** pmurias joined
[14:02] <moritz_> pugs: say "back, audreyt++"

[14:02] <p6eval> pugs: OUTPUT[sh: /home/evalenv/.cabal/bin/pugs: No such file or directory‚ê§]

[14:03] <gaal> is the smokeserver still at smoke.pugscode.org? I can't view recent smokes.

[14:03] *** p6eval left
[14:03] <ruoso> Arathorn, because you can just take the interpreter state as the continuation... if you use the C stack you have to deal with both the interpreter stack *and* the C stack... which makes it quite harder

[14:03] *** p6eval joined
[14:03] <Arathorn> AH! right

[14:03] <ruoso> and eventually impossible, depending on how weird your code is

[14:03] <moritz_> pugs: say "another attempt"

[14:03] <p6eval> pugs: OUTPUT[another attempt‚ê§]

[14:03] <moritz_> pugs: say "audreyt++"

[14:04] <p6eval> pugs: OUTPUT[audreyt++‚ê§]

[14:04] <[particle]> perl6: say 'p6eval++'

[14:04] <p6eval> elf 21778, pugs, rakudo 29834: OUTPUT[p6eval++‚ê§]

[14:04] <[particle]> time to add revision number to pugs again?

[14:04] <gaal> perl6: "why say when you can display"

[14:05] <moritz_> gaal: because it takes longer ;)

[14:05] <p6eval> pugs, rakudo 29834: RESULT["why say when you can display"]

[14:05] <p6eval> ..elf 21778: RESULT["why\ say\ when\ you\ can\ display"‚ê§]

[14:05] <gaal> hahaha

[14:05] <Arathorn> what is involved in actually "dealing" with the stack in question, though? surely a snapshot of a stack + the heap is all you need to be able to resume an app

[14:05] <pmurias> Arathorn: how do you plan to do it with pure C?

[14:06] <ruoso> Arathorn, you mean, in SMOP?

[14:06] <Arathorn> no, in general

[14:06] <pmurias> it being taking a snapshot of the stack

[14:06] <ruoso> it depends too much on each implementation

[14:06] <Arathorn> pmurias: with difficulty, if it were to not be platform-specific hack

[14:07] <ruoso> Arathorn, I think longjmp is part of C99...

[14:07] <Arathorn> oh, right

[14:07] <pmurias> C89

[14:08] <pmurias> according to the man pages

[14:08] <ruoso> yeah... exactly...

[14:08] <Arathorn> so the kind of things you have to do are to ensure that you really do have a single stack frame to copy in the first place, and then find a cross-platform way of manually pointing the frame pointer to an alternative stack

[14:08] <ruoso> or... implement a stackless runloop and you have a single instance with the "current continuation"

[14:08] <ruoso> and that's it

[14:09] <Arathorn> i still don't entirely see why it matters whether some of the stack frames happen to be for interpreted code rather than C

[14:10] <Arathorn> shame the stackless docs concentrate on threadlets and the other cool features it provides python, rather than explaining what the patch does under the hood

[14:10] <ruoso> imagine the following call stack: perl5 => smop => perl5 => python => smop

[14:10] <Arathorn> right

[14:11] <ruoso> handling each interpreter + the c stack is very hard... and may be impossible

[14:11] <pmurias> Arathorn: instead of calling a function the stackless python set's a variable with a function pointer,returns and calls the function in the variable

[14:11] <ruoso> if you're stackless... you can use CPS to hand over the entire execution to the other interpreter, that will then hand back to that interpreter

[14:13] <pmurias> ruoso: i think stackless python is not integrated into the mainline because the mainstream python developers don't care much about the features it provides

[14:14] <pmurias> and it's a nasty hack

[14:14] <ruoso> pmurias, it looks like so

[14:15] <Arathorn> surprising, given the large-scale concurrency it gives looks pretty cool to me

[14:16] <gaal> pmurias: got a test case for m0ld? I want to send in some golf but am not familiar with the language

[14:17] * Arathorn still doesn't entirely understand what "handling each [interpreter's] stack" entails, but i'll try reading the stackless python impl for clarification

[14:19] *** sri_work joined
[14:20] <ruoso> Arathorn, implemeting gather/take with intepreter stack + c stack when you have a call stack of python => perl5 => smop => perl5 => python looks very hard to me

[14:21] *** pmurias left
[14:21] * zamanfou is now away: In the rain my tears are forever lost.

[14:21] *** TJCRI joined
[14:21] <moritz_> it looks very hard for me either way ;-)

[14:22] <moritz_> but it might be just me being not a good C hacker ;)

[14:22] <ruoso> if it is stackless, it is much simpler...

[14:22] <ruoso> because it's simple to create a closure with the current continuation

[14:22] *** pmurias joined
[14:22] <Arathorn> right

[14:23] <ruoso> and make other calls to the interpreter where you hold a continuation to

[14:23] <ruoso> remember...

[14:23] <ruoso> you have a p5 continuation saved, and you're still using the p5 interpreter for other calls

[14:23] <ruoso> the same interpreter

[14:23] <gaal> pmurias: should v6/smop/sm0p/test_file parse with m0ld?

[14:24] <Arathorn> <ruoso> you have a p5 continuation saved, and you're still using the p5 interpreter for other calls

[14:24] <Arathorn> ^ for other continuations?

[14:24] <ruoso> yes

[14:24] <Arathorn> ah ha :D

[14:24] * Arathorn has his lightbulb moment

[14:25] <ruoso> :P

[14:25] <Arathorn> sorry for being thick, and for the explanation

[14:25] <ruoso> it's always a good exercise to go through this concepts again...

[14:25] * Arathorn hopes others may google this in years to come and find similar lightbulbs

[14:25] * Arathorn nods

[14:26] * moritz_ tries to keep the IRC logs up as long as possible

[14:28] <ruoso> Arathorn, you could sketch up a little more in the smop wiki abou thtat

[14:31] *** TJCRI left
[14:32] <moritz_> [particle]: re adding revision numbers to pugs in p6eval, will do after my vacations

[14:34] <Arathorn> ruoso: will try to document once i've read up a bit more on it

[14:39] <gaal> Hmmm. I think Time::Out is not enough as it is used in yaml_harness. When a test times out, all the ones following it time out too. Unless I killall pugs in another shell...

[14:40] *** masak left
[14:41] *** kanru joined
[14:48] <pmurias> gaal: sm0p and m0ld are totally different thinks

[14:48] <pmurias> * things

[14:55] <pmurias> audreyt: having sm0p5.pm in the repo is pointless as it compiles fast and perl5.10 is both required to run and compile it, (ruby1.9 on the other hand is required for STD5_red which is used by elf which is used for compiling p6 to sm0p)

[14:56] <Arathorn> is there any semantic difference between sm0p and smop, btw?

[14:56] *** jerrylee joined
[14:57] <pmurias> sm0p is the DSL used by SLIME the lame interpreter implementation for smop

[14:57] <pmurias> the difference is like pir vs parrot

[15:00] * pmurias don't think clearly or respond swiftly as usual when doing system administration related tasks...

[15:00] <pmurias> * dosn't

[15:01] <gaal> pmurias: okay, then where can i get a demo m0ld file? :)

[15:04] <pmurias> gaal: i'll check in the example from the wiki ;)

[15:08] *** Exodist joined
[15:09] *** TJCRI joined
[15:15] <pmurias> gaal: there was a typo in the example

[15:16] <pmurias> gaal: m0ld is two days old, so it's not working yet

[15:16] *** pmurias left
[15:16] <gaal> does it at least construct an ast i can compare against?

[15:23] *** alester joined
[15:36] *** Alias_ joined
[15:37] *** frobnitz joined
[15:41] <audreyt> @tell pmurias ok, then an alternative is bake brew into Makefile.

[15:41] <lambdabot> Consider it noted.

[15:41] <audreyt> gaal: http://www.perlfoundation.org/perl6/index.cgi?smop_mold

[15:41] <lambdabot> Title: SMOP Mold / Perl 6

[15:52] *** hercynium joined
[15:53] *** fridim_ joined
[15:56] *** Lorn joined
[15:58] *** wknight8111 joined
[16:02] *** nothingmuch joined
[16:05] *** fridim_ left
[16:05] *** fridim_ joined
[16:05] *** jerrylee left
[16:17] *** iblechbot joined
[16:28] *** icwiener left
[16:31] *** cjfields joined
[16:45] *** cjfields_ joined
[16:48] *** toddr joined
[16:49] *** iblechbot left
[17:01] *** rindolf joined
[17:02] *** cjfields left
[17:04] *** toddr left
[17:15] <TimToady> svnbot seems to be mum

[17:15] *** pugs_svn joined
[17:15] <pugs_svn> r21782 | audreyt++ | * Configure.PL: Probe for GHC's -threaded flag.

[17:15] <pugs_svn> r21783 | lwall++ | [STD] implement quasi correctly

[17:15] <pugs_svn> r21784 | lwall++ | [STD] support .parse and .parsefile methods, emit filenames on errors

[17:15] <pugs_svn> r21785 | lwall++ | [STD5_dump_match] use new parsefile method

[17:15] <moritz_> better? ;-)

[17:17] <moritz_> if some of the bots go missing during the next one or two weeks, poke Auzon (when he's back) or pmurias, they have access to the server

[17:17] <moritz_> if not... either wait for my return, or start a copy on feather3

[17:21] *** cathyal joined
[17:35] <TimToady> or hack into your server... :)

[17:42] *** gaal_ joined
[17:43] *** gaal is now known as Guest79729

[17:44] *** cjfields_ is now known as cjfields

[17:44] *** gaal_ is now known as gaal

[17:45] *** Guest79729 left
[17:54] <pugs_svn> r21786 | gaal++ | * m0ld: minor cosmetic cleanup

[17:55] *** gaal left
[17:58] *** cmarcelo left
[17:59] *** cmarcelo joined
[18:02] <rindolf> Hi TimToady , moritz_ 

[18:02] <rindolf> How were your weekends?

[18:12] <Arathorn> DSL == domain specific language?

[18:12] <ruoso> Arathorn, yes

[18:17] <rindolf> Arathorn: yes.

[18:23] *** rindolf left
[18:36] <pugs_svn> r21787 | ruoso++ | [smop] lowlevel method uses a Code object instead of a C callback function!

[18:37] *** jhorwitz joined
[18:40] *** TJCRI left
[18:50] *** pmurias joined
[18:53] <pmurias> audreyt: you mean integrate it into the main Makefile?

[18:53] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[18:53] <ruoso> is there any implementation difference between Sub and Method?

[18:54] <ruoso> both extend Routine, right?

[18:54] <ruoso> the signature binding happens at Routine, I suppose...

[18:55] <pmurias> ruoso: don't know

[18:55] <ruoso> as well as the differentiation between 'leave' and 'return'...

[18:56] <ruoso> I think it's time for lexical variables... methods would bind the capture to the signature resulting in new variables in a lexical scope inside which the code would be executed...

[19:02] <pmurias> ruoso: i'll continue working on m0ld rather than implement lexicals, but i agree that lexicals are much needed

[19:03] *** pbuetow joined
[19:03] <pmurias> shower&

[19:03] <ruoso> pmurias, are you planning to port smop_s1p_code to use mold directly, so that the attribute it keeps is a mold object instead of a frame and creating a frame at run-time

[19:03] <ruoso> ?

[19:03] <ruoso> pmurias++ m0ld++

[19:04] *** cathyal left
[19:15] <pmurias> ruoso: once it's finished, why not?

[19:15] * ruoso actually looking forward to it ;)

[19:15] *** Limbic_Region joined
[19:19] * ruoso confused by the differences between Block, Routine, Sub and Method

[19:19] <ruoso> sometimes it seems that a block doesn't have a signature

[19:19] <ruoso> only a routine does..

[19:19] <ruoso> s/Block/Code/

[19:19] <ruoso> sometimes in the spec it says that every code has a signature...

[19:20] <ruoso> but what about bare blocks? aren't they Code objects also?

[19:20] <ruoso> pugs: say { say "Hello World!" }.WHAT

[19:20] <p6eval> pugs: OUTPUT[<SubBlock(<anon>)>‚ê§]

[19:21] <wknight8111> rakudo: say { say "Hello World!" }.WHAT

[19:21] <p6eval> rakudo 29834: OUTPUT[Block‚ê§]

[19:21] <wknight8111> nice

[19:21] <ruoso> rakudo: say  -> $x { say "Hwllo World!" }.WHAT

[19:21] <p6eval> rakudo 29834: OUTPUT[Statement not terminated properly at line 1, near "-> $x { sa"‚ê§current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)‚ê§]

[19:22] <ruoso> pugs: say  -> $x { say "Hwllo World!" }.WHAT

[19:22] <p6eval> pugs: OUTPUT[<SubPointy(<anon>)>‚ê§]

[19:22] <ruoso> hmm... pugs seems to have two object types for blocks with and without signatures...

[19:22] <TimToady> a bare block is a lambda with an implicit sig of <-> $_ = $OUTER::_ or some such

[19:23] <TimToady> where you can just bind $_ directly to the outer scope if you can prove that it will be called with 0 args

[19:23] <ruoso> that looks... complex...

[19:23] <[particle]> timtoady in the (government computer) news: http://www.gcn.com/online/vol1_no1/46724-1.html

[19:25] <ruoso> does that mean that $_ doesn't work like other variables? that would naturally be found in the outer scope?

[19:27] <ruoso> I was thinking on the binding process as the initialization of variables in the new scope... and that variable lookup would naturally access the outer scope

[19:27] <TimToady> C

[19:27] <TimToady> CALLER:: variables must be declared as context vars

[19:27] <TimToady> $_, $/, and $! are implicitly context vars

[19:28] <ruoso> hmm... outer != caller

[19:29] <TimToady> true, but I guess I don' understand what you're asking

[19:30] <ruoso> a bare block doesn't really have a caller, its caller is the routine's caller, right?

[19:30] <TimToady> mygrep { ... }, 1,2,3

[19:30] <TimToady> mygrep calls the block

[19:30] <TimToady> and passes an arg which gets bound to $_

[19:31] <TimToady> so the default doesn't come into play

[19:31] *** REPLeffect joined
[19:31] <TimToady> however, if mygrep called it without an arg, it would bind to outer rather than caller

[19:31] <TimToady> if mygrep wanted to examine *your* $_, then it would use $CALLER::_

[19:32] * ruoso thinking

[19:32] <ruoso> what about bare blocks as statements?

[19:33] <ruoso> { my $a; { my $b; { my $c; say $c; } say $b; } say $a; }

[19:34] <TimToady> they're in void context, so can simply bind to outer outright

[19:35] * ruoso trying to figure out the better way to implement scopes...

[19:35] <TimToady> but even if the optimizer doesn't see that, a statement-level {...} turns into {...}() anyway

[19:35] <TimToady> so the default binding occurs

[19:37] <ruoso> so which is the actual lookup order?

[19:38] *** fridim_ left
[19:40] <ruoso> it seems that there are two axes in the lookup... one is OUTER, the other is CALLER, but you only look for context variables when traversing the CALLER axis

[19:41] <TimToady> yes, the caller info is normally supplied by the argument, not by CALLER

[19:41] *** jagggy joined
[19:41] <TimToady> but you don't know whether the arg is there till run time

[19:41] <TimToady> hence the default to OUTER

[19:42] <TimToady> again, unless you have knowledge of the context sufficient to prove that no arg will be passed, and then you can simplify

[19:42] <ruoso> so, signature binding affects the OUTER (like if you had an implicit scope before the scope of the actual code, containing the signature variables)

[19:42] <TimToady> I wouldn't say that

[19:42] <TimToady> sig params are just "my" vars to the inside scope

[19:43] <ruoso> yeah yeah... you don't need two scopes... you can populate the direct scope of the code about to be run

[19:44] <ruoso> I still didn't get how $_ would switch from OUTER to CALLER...

[19:45] <ruoso> if the default lookup is in OUTER... 

[19:45] <ruoso> for @x { mygrep { ... }, 1,2,3 }

[19:46] <TimToady> it doesn't have to switch to CALLER

[19:46] <ruoso> how will it find the correct $_/

[19:46] <ruoso> ?

[19:46] <TimToady> you didn't reference $_ provided by the for

[19:46] <TimToady> mygrep will pass 1, then 2, then 3 to the block

[19:47] <TimToady> just as a normal arg

[19:47] <ruoso> that would be slurped into @_?

[19:47] <TimToady> mygrep sees the list in its @_, yes

[19:48] <TimToady> and probably says for @_ { &block($_) } or some such

[19:49] <ruoso> so for mygrep to declare a new $_ it would have to declare a new signature explicitly?

[19:51] <TimToady> why would mygrep need to declare a new $_?

[19:51] <TimToady> it's already a sub, and therefore has its own $_ automatically

[19:51] <TimToady> which is unused in this case

[19:52] <TimToady> since the for inside mygrep also is a sub with its own $_

[19:52] <ruoso> right...

[19:52] <ruoso> but the OUTER for the block being passed as an argument to mygrep is the scope of 'for @x'

[19:53] <ruoso> the CALLER is mygrep

[19:53] <ruoso> so if I go looking in the OUTER axis before the CALLER axis I'll find the wrong $_

[19:54] <TimToady> well, that doesn't happen because OUTER is just a default if mygrep doesn't pass the arg, which it does

[19:55] <ruoso> so that block have an implicit signature that declares $_ for that scope?

[19:55] <ruoso> and mygrep sends that as the argument which is then bound to the inner scope...

[19:55] <pmurias> yes

[19:56] <ruoso> where that signature comes from?

[19:57] <TimToady> a fairy D[D[D[D[D[D[D[D[D[Dgodmother

[19:57] <TimToady> yow

[19:58] <TimToady> that's just what a bare block compiles into by default

[19:58] <ruoso> alright... so a bare block is actually the same as  -> $_? {...}

[19:58] <TimToady> unless it can be proven that you don't need the argument

[19:59] <TimToady> <-> $_ = OUTER::<$_> {...}

[19:59] <TimToady> iow, -> $_ is rw = OUTER::<$_> {...}

[20:00] <ruoso> alright... now I got it...

[20:00] <ruoso> so... no blocks without signatures at all..

[20:00] <TimToady> unless it can be proven that you don't need the argument

[20:00] <TimToady> unless it can be proven that you don't need the argument

[20:00] <TimToady> unless it can be proven that you don't need the argument

[20:00] <ruoso> pugs: { say $_ }.("Hello World!");

[20:00] <p6eval> pugs: OUTPUT[Hello World!‚ê§]

[20:00] <TimToady> I could say it a few more times if you like :)

[20:00] <ruoso> but that as an optimization I think...

[20:01] <ruoso> I'm trying to deal only with concepts at this point

[20:01] <TimToady> blocks are just lambdas with (potentially) a single argument

[20:02] <TimToady> note, however, that a block with $^a has an explicit argument

[20:02] <ruoso> sure... that's just a syntatic sugar for -> $^a { ... }

[20:02] <TimToady> and is equivalent to -> $a {...}

[20:02] *** wknight8111 left
[20:02] <TimToady> give or take a ^

[20:03] <TimToady> we don't actually allow $^a in a sig

[20:03] * ruoso got one level lower

[20:03] <TimToady> you win :)

[20:04] * [particle] looks for turtles

[20:04] <ruoso> pugs: { say $^a; say $a }.("Hello World!");

[20:04] <p6eval> pugs: OUTPUT[Hello World!‚ê§Hello World!‚ê§]

[20:04] <TimToady> taking the better-is-better approach to dazzling new depths

[20:04] <ruoso> is that expected?

[20:04] <TimToady> I think it is, which is why I wrote -> $a

[20:05] <TimToady> the ^ is thrown away after the parameter is generated

[20:05] <ruoso> alright... which means that it's completely invisible for the runtime...

[20:05] <[particle]> pugs: { say $a; say $^a }.("Hello World!");

[20:05] <TimToady> if we do it that way.

[20:05] <p6eval> pugs: OUTPUT[*** ‚ê§    Unexpected ";"‚ê§    expecting "::"‚ê§    Variable "$a" requires predeclaration or explicit package name‚ê§    at /tmp/MklO6z3RJg line 1, column 9‚ê§]

[20:05] <TimToady> I could argue it the other way too...

[20:06] <[particle]> pugs: { my $a = 'foo'; say $a; say $^a, say $a }.("Hello World!");

[20:06] <p6eval> pugs: OUTPUT[*** Can't modify constant item: VStr "Hello World!"‚ê§    at /tmp/jIKyvpVZsd line 1, column 3-16‚ê§]

[20:06] <ruoso> me too... but I don't think it really matters..

[20:06] <[particle]> pugs: { my $a = 'foo'; say $a; say $^a; say $a }.("Hello World!");

[20:06] <p6eval> pugs: OUTPUT[*** Can't modify constant item: VStr "Hello World!"‚ê§    at /tmp/E8jCIkralN line 1, column 3-16‚ê§]

[20:06] <TimToady> you're basically trying to declare $a two different ways

[20:07] <[particle]> yep, i'm trying to break the law

[20:07] <TimToady> the ^ means, declare this above...

[20:07] <[particle]> that should be a compile-time error

[20:07] <ruoso> yeah... please leave all this magic in the compiler

[20:07] <[particle]> even though multiple 'my's are not

[20:08] <TimToady> arguably, my $a should be the same $a as the one in -> $a

[20:08] <TimToady> by the "my $a; my $a;" rule

[20:08] <[particle]> right

[20:08] <[particle]> but when does it bind?

[20:08] <[particle]> and what's the value of $a in the block?

[20:08] <ruoso> at invocation time?

[20:08] <TimToady> parameters are just the first my variables bound in the body, really

[20:09] <[particle]> that's how rakudo does it

[20:09] <TimToady> yes, at invocation time, which is why they're formal parameters, after all

[20:10] <ruoso> that brings me to the first question... which is the implementation difference between a method and a code object?

[20:10] <ruoso> it seems to me that they just have different names

[20:10] <[particle]> that would mean my example is equivalent to "my $x = 'Hello, world!'; my $x = 'foo';" and would print "foo\nfoo\nfoo\n"

[20:10] <TimToady> biab &

[20:11] *** cathyal joined
[20:11] <[particle]> a tricky way of overriding parameters

[20:12] <ruoso> [particle], that would generate a warning...

[20:12] <[particle]> with the double my? yes

[20:15] <TimToady> a method is a code object that expects an invocant as its first argument, and the single-dispatch dispatcher can see it because it's marked as a method (subs are ignored by that dispatcher)

[20:16] <TimToady> however, once you take a reference to a method, it's just a sub

[20:16] <TimToady> though you still have to pass the invocant

[20:16] <TimToady> that's basically how a dispatcher calls a method

[20:17] <[particle]> just a sub, but the single-dispatch dispatcher sees it

[20:18] <ruoso> so it is a regular code with a different name that checks for a mandatory invocant

[20:18] <TimToady> well, not just a sub, in the sense that if you pass a capture to it without an invocant, it might not like it.

[20:18] <TimToady> right

[20:19] <TimToady> and it doesn't have a different name

[20:19] <ruoso> name as in type name

[20:19] <TimToady> you don't know whether &foo is a method or a sub

[20:19] <ruoso> not as in method naem

[20:19] <ruoso> pugs: class Foo { method bar { say &bar.WHAT } }; Foo.bar;

[20:19] <p6eval> pugs: OUTPUT[*** ‚ê§    Unexpected "."‚ê§    expecting "::" or signature value‚ê§    Variable "&bar" requires predeclaration or explicit package name‚ê§    at /tmp/kNSW1Samri line 1, column 34‚ê§]

[20:19] <ruoso> pugs: class Foo { method bar { say &bar.WHAT; }; }; Foo.bar;

[20:19] <p6eval> pugs: OUTPUT[*** ‚ê§    Unexpected "."‚ê§    expecting "::" or signature value‚ê§    Variable "&bar" requires predeclaration or explicit package name‚ê§    at /tmp/fglPB9EFWL line 1, column 34‚ê§]

[20:20] <ruoso> TimToady, actually... &foo; looks up in the Package, and the method is not even there..

[20:21] <ruoso> the method is in the prototype/class

[20:21] <ruoso> a method is not visible as a sub...

[20:21] <ruoso> (at least that's how I've been seeing that for a while now)

[20:21] <TimToady> "method bar" is not introducing the symbol to the symbol table early enough there

[20:21] *** Limbic_Region left
[20:22] <TimToady> a method must be visible as a sub

[20:22] <ruoso> hmmm... does it?

[20:22] <ruoso> really?

[20:22] <pmurias> so it's both in the class *and* the namespace?

[20:22] <TimToady> yes

[20:22] <TimToady> (if there is a namespace, which there is for named classes)

[20:23] <ruoso> pugs: class Foo { method bar { }; }; say &Foo::bar;

[20:23] <p6eval> pugs: OUTPUT[<SubMethod(&bar)>‚ê§]

[20:23] <ruoso> hmm... ok.. not too bad... it can be aliased in the package

[20:24] <ruoso> btw... are subs/methods stored as package variables?

[20:24] <pmurias> ruoso: you gave the Perl6 is just a SMOP talk before?

[20:24] <ruoso> pmurias, yes... in PPW in may

[20:24] <TimToady> depends on how they're declared, but the default declarator is "our"

[20:25] <ruoso> alright... so I can have a single storage for subs, methods and variables

[20:25] <TimToady> that's the plan

[20:25] <pmurias> ruoso: any comments/observations based on that?

[20:25] <[particle]> just don't call it a glob

[20:26] <ruoso> pmurias, yes... the initial jokes are annoying... you can clean that up...

[20:26] <ruoso> pmurias, at least it didn't work well for me

[20:26] <ruoso> [particle], although it's a perfect analogy

[20:27] <TimToady> it seems okay to me for methods and subs to share a sigil

[20:27] <[particle]> so it seems. but there's baggage.

[20:27] <pmurias> don't we just store them in namespaces/lexical pads with the sigil as part of the key?

[20:28] <TimToady> yes, which is why we don't need typeglobs any more

[20:28] <TimToady> you can think of Captures as anonymous globs if it makes you happy  :)

[20:28] <ruoso> so CANDO needs to add '&' to the string before doing the actual lookup

[20:29] <TimToady> maybe we should rename them Globs  :)

[20:29] <TimToady> ruoso: presumably

[20:30] <TimToady> or another blind hellenic 8th century poet of the same name...

[20:32] *** wknight8111 joined
[20:34] * ruoso moving '0.4.0 - Lexical Scope / Namespaces.' to the top of the ROADMAP

[20:35] <TimToady> lunch &

[20:36] <ruoso> pmurias, would it be too hard to implement (|$captureobject) in 'use v6' blocks?

[20:37] <pmurias> ruoso: withought any fancy capture merging not very

[20:37] <ruoso> yeah yeah... allowing a single capture object being passed....

[20:38] <ruoso> pmurias, oh... forget it... I'm confusing things...

[20:38] <ruoso> I  don't really need it

[20:38] <ruoso> postcircumfix:<()> have ($code: $actualcapture) as the signature...

[20:39] <pmurias> * has

[20:42] * ruoso placing Signature on top of the roadmap, since that Code has it as an attribute...

[20:42] <ruoso> s/that//

[20:45] *** simcop2387 joined
[20:45] <pmurias> (possibly bad idea) we can have Signatures as a compile-time only object at first

[20:46] *** Jedai left
[20:46] <ruoso> you mean generating my $foo = $capture[0] in the top of the block?

[20:47] *** Jedai joined
[20:50] <ruoso> might be acceptable... but maybe writing Signature is not that much of a trouble

[20:54] * ruoso home &

[20:54] *** ruoso left
[21:03] <pugs_svn> r21788 | pmurias++ | [m0ld]

[21:03] <pugs_svn> r21788 | pmurias++ | maps names of registers with initial value to ints

[21:03] <pugs_svn> r21788 | pmurias++ | counts the number of those withough

[21:08] <pmurias> very little done today and i still haven't finished the **** wi-fi stuff :(

[21:08] *** pmurias left
[21:15] *** jhorwitz left
[21:16] *** pmichaud left
[21:16] *** jfredett left
[21:16] *** araujo joined
[21:16] *** pjcj joined
[21:16] *** jfredett joined
[21:16] *** pmichaud joined
[21:17] *** araujo left
[21:18] *** pmichaud left
[21:18] *** pmichaud joined
[21:19] *** araujo joined
[21:19] *** pmurias joined
[21:24] <pmurias> @tell gaal as you might have noticed from the coding style m0ld is my first haskell program, so feel to change it as you deem fit, you can diff the output on the hello world example when refactoring as a half-measure

[21:24] <lambdabot> Consider it noted.

[21:24] *** pmurias left
[21:26] *** pjcj left
[21:26] *** jfredett left
[21:28] *** pjcj joined
[21:31] *** cjfields left
[21:32] *** alester is now known as AndyAway

[21:33] *** eternaleye joined
[21:34] *** Lorn left
[21:42] *** jfredett joined
[21:45] *** Blasi joined
[21:47] *** Limbic_Region joined
[21:53] *** hercynium left
[21:55] *** Blasi left
[21:56] <pasteling> "rhr" at 65.94.11.172 pasted "pugs build failure r21788" (44 lines, 2.3K) at http://sial.org/pbot/31801

[22:07] *** jferrero joined
[22:17] *** Blasi joined
[22:25] *** ruoso joined
[22:27] *** jagggy left
[22:34] *** Blasi left
[22:41] *** aindilis joined
[22:42] <ruoso> is there any prior work on a Signature object?

[22:44] <ruoso> @tell pmurias I think some other registers are worth being pre-set for mold frames, like the "back" continuation, the "outer" lexical scope...

[22:44] <lambdabot> Consider it noted.

[22:45] <ruoso> @tell actually not the "outer", but the "current" lexical scope

[22:45] <lambdabot> Consider it noted.

[22:46] <ruoso> @tell pmurias actually not the "outer", but the "current" lexical scope

[22:46] <lambdabot> Consider it noted.

[22:47] <ruoso> heh... when someone named "actually" comes in a unexpected message will appea

[22:47] <s1n> moritz_: thanks for checking out my patch

[22:47] <s1n> moritz_: btw, is there anything that tracks those karma points?

[23:02] <ruoso> pugs: sub bar { say $foo }; my $foo is context; $foo = 'Hello!'; bar();

[23:02] <p6eval> pugs: OUTPUT[*** ‚ê§    Unexpected " };"‚ê§    expecting "::"‚ê§    Variable "$foo" requires predeclaration or explicit package name‚ê§    at /tmp/86sB6rI5f2 line 1, column 19‚ê§]

[23:02] *** rakudo_svn left
[23:05] <ruoso> does that mean that $!, $_ and $/ are special cases of context lookup?

[23:06] <ruoso> that seems reasonable, actually... since p6 is strict... 

[23:09] *** pbuetow left
[23:14] *** hercynium joined
[23:17] <ruoso> http://www.perlfoundation.org/perl6/index.cgi?smop_lexical_scope_implementation

[23:17] <lambdabot> Title: SMOP Lexical Scope Implementation / Perl 6, http://tinyurl.com/5ebhte

[23:31] *** cognominal_ joined
[23:42] *** Jedai left
