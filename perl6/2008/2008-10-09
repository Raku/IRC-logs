[00:36] *** Alias_ joined
[00:43] *** justatheory left
[00:49] *** jferrero left
[00:50] *** silug joined
[00:56] *** benzo left
[01:08] *** eternaleye joined
[01:08] <pugs_svn> r22549 | lwall++ | [assign.t] missing semicolons

[01:11] *** alester left
[01:24] <pugs_svn> r22550 | lwall++ | [STD] there is no infix:<is> (was hiding missing semicolons in assign.t)

[01:24] <pugs_svn> r22550 | lwall++ | [viv] much improved typology of EXPR asts (and doesn't lose nested ops)

[01:30] *** alanhaggai joined
[01:32] *** BinGOs left
[01:37] *** PZt left
[01:37] *** BinGOs joined
[01:41] *** ab5tract left
[01:49] *** hercynium_ joined
[01:52] *** PZt joined
[02:05] *** alester joined
[02:08] *** felipe left
[02:09] *** zostay_ is now known as zostay

[02:15] *** eternaleye left
[02:17] *** Limbic_Region left
[02:23] *** eternaleye joined
[02:49] *** agentzh left
[02:49] *** agentzh joined
[02:50] <pugs_svn> r22551 | lwall++ | [basic.t] default expression must come after traits

[02:52] <pugs_svn> r22552 | lwall++ | [viv] autogenerate VAST packages as needed

[03:10] *** ab5tract joined
[03:11] *** jhorwitz left
[03:32] *** felipe joined
[03:32] *** alanhaggai left
[03:35] *** jfredett left
[03:44] *** agentzh left
[03:44] *** agentzh joined
[04:17] <pugs_svn> r22553 | lwall++ | [viv] can now reconstruct the p6 from the ast for simple expressions

[04:56] *** masak joined
[05:05] *** Patterner left
[05:08] *** Psyche^ joined
[05:08] *** Psyche^ is now known as Patterner

[05:14] *** |Jedai| joined
[05:21] *** Bzek joined
[05:28] *** |Jedai| left
[05:29] *** |Jedai| joined
[06:09] *** BinGOs_ joined
[06:11] *** agentzh left
[06:11] *** agentzh joined
[06:22] *** BinGOs left
[06:30] *** ashizawa joined
[06:44] *** alester left
[06:47] *** BinGOs_ is now known as BinGOs

[06:49] *** alester joined
[06:49] *** alester left
[06:59] *** iblechbot joined
[07:00] *** alester joined
[07:05] *** penk joined
[07:09] *** agentzh left
[07:09] *** agentzh joined
[07:12] *** sri_work joined
[07:13] *** agentzh left
[07:16] *** alester left
[07:17] *** agentzh joined
[07:23] *** viklund joined
[07:29] *** masak left
[07:36] *** ab5tract left
[07:46] *** Alias_ left
[07:57] *** zamolxes left
[08:04] *** cosimo joined
[08:07] *** BinGOs_ joined
[08:09] *** BinGOs_ left
[08:15] *** elmex joined
[08:21] *** BinGOs left
[08:27] *** jferrero joined
[08:54] *** BinGOs joined
[09:17] *** renormalist joined
[09:37] *** tomyan joined
[09:45] <moritz_> std: class A { sub :foo { say bar }; };

[09:45] <lambdabot> moritz_: You have 1 new message. '/msg lambdabot @messages' to read it.

[09:45] <p6eval> std 22553: OUTPUT[Unknown routines:␤     bar called at 1 ␤parsed␤]

[09:45] <moritz_> @massages

[09:45] <lambdabot> azawawi said 11h 46m 54s ago: any-list.pir p5chop and p5chomp is running all tests now. Patches are on RT. Thanks.

[09:55] *** meppl joined
[10:06] *** Bzek left
[10:18] *** Bzek joined
[10:21] *** ruoso left
[10:30] *** xinming_ joined
[10:31] *** xinming left
[10:33] *** kanru left
[10:38] *** xinming joined
[10:38] *** Ontolog joined
[10:39] *** xinming_ left
[10:47] *** xinming_ joined
[10:47] *** xinming_ left
[10:48] *** dmq joined
[10:48] *** dmq left
[11:00] *** [particle] joined
[11:00] *** ruoso joined
[11:03] *** Ontolog left
[11:03] *** xinming left
[11:04] *** xinming joined
[11:06] <moritz_> @tell azawawi thanks for the patch. However (as the others that modify self) I'll wait wih applying until the lexical issues are sorted out

[11:06] <lambdabot> Consider it noted.

[11:07] *** penk left
[11:12] *** [particle-split] left
[11:14] *** xinming left
[11:14] *** xinming joined
[11:30] <pugs_svn> r22554 | ruoso++ | [smop] small bugfix in native bool was causing unexpected behavior

[11:31] <ruoso> er... actually it wasn't the bugfix that was causing the unexpcted behavior... *sigh*

[11:36] *** alanhaggai joined
[11:48] *** kanru joined
[11:58] *** meppl left
[12:01] *** xinming left
[12:06] *** bjakb joined
[12:09] <bjakb> hello?

[12:09] <moritz_> hi

[12:10] *** xinming joined
[12:12] <bjakb> I have a problem with the Pugs installation, can somebody might help me?

[12:12] <moritz_> I can try

[12:12] <moritz_> but only if I know what your problem is

[12:14] *** bjakb2 joined
[12:14] <bjakb> sorry I have a problem with my irc client could you please repeat your answer?

[12:15] <moritz_> the logs are at irc.pugscode.org

[12:15] <moritz_> in short "I can try"

[12:17] *** bjakb left
[12:19] <bjakb2> OK, I'm following the installation instructions of pugs

[12:19] *** kanru left
[12:19] <moritz_> which instructions?

[12:19] <bjakb2> that is the best to install it with cabal

[12:19] <bjakb2> 'cabal update'

[12:19] <bjakb2> 'cabal install Pugs'

[12:19] *** kanru joined
[12:20] <moritz_> ok

[12:20] <bjakb2> to be able to do that you have to install a few haskell packages - which i did install

[12:20] *** Bzek left
[12:21] <bjakb2> I was also able to run the two mentioned cabal commands

[12:21] <bjakb2> the installation went through without any errors

[12:21] <bjakb2> But, at the end, I cannot run pugs

[12:22] <bjakb2> I can also not find any pugs binary

[12:23] <moritz_> the binary will be in ~/.cabal/ somewhere

[12:23] <moritz_> probably ~/.cabal/Pugs/bin/pugs or something along these lines

[12:23] <moritz_> which OS are you on?

[12:26] *** Ontolog joined
[12:28] <bjakb2> say 'hello' :-)

[12:29] *** ashizawa left
[12:29] <bjakb2> moritz: the binary was indeed in the ~/.cabal directory - thanks

[12:30] <moritz_> bjakb2: you're welcome

[12:32] *** bjakbh joined
[12:34] <bjakb2> the next thing I want to try is to compile perl6 code into perl5 - that sounds interesting

[12:35] <moritz_> I don't think that's properly implemented in pugs

[12:35] <moritz_> elf does it, though

[12:35] <ruoso> pugs: module Foo { sub bar { baz() } }; &Foo::baz := sub { say 1 }; Foo::bar()

[12:35] <p6eval> pugs: OUTPUT[1␤]

[12:36] <bjakbh> elf? - never heard of that

[12:36] <moritz_> elf: say "hi";

[12:36] <p6eval> elf 22554: OUTPUT[hi␤]

[12:36] *** bjakb2 left
[12:37] <moritz_> see also http://perl.net.au/wiki/Elf

[12:37] <lambdabot> Title: Elf - PerlNet

[12:38] <ruoso> pugs: module Foo { sub bar { our $foo = 1; }; sub baz { say $foo } }; Foo::bar(); Foo::baz();

[12:38] <p6eval> pugs: OUTPUT[*** ␤    Unexpected " }"␤    expecting "::"␤    Variable "$foo" requires predeclaration or explicit package name␤    at /tmp/Bwbo2aprAs line 1, column 59␤]

[12:39] <ruoso> pugs: module Foo { sub bar { our &foo := sub { say 1 } }; sub baz { say foo() } }; Foo::bar(); Foo::baz();

[12:39] <p6eval> pugs: OUTPUT[*** Cannot use Undef as a Code object␤    at /tmp/vScVoZWa3S line 1, column 67-73␤]

[12:43] <ruoso> pugs: module Foo { sub bar { our sub foo { say 1 } }; sub baz { foo() } }; Foo::baz();

[12:43] <p6eval> pugs: OUTPUT[1␤]

[12:43] *** bjakbh left
[12:44] <ruoso> that means one of two things: 

[12:44] <ruoso> 1) The package variables are visible as if they were declared as "our" even if there isn't such a declaration...

[12:45] <ruoso> 2) sub dispatch sees if the current package CANDO that after looking in the lexical scope

[12:46] <moritz_> ruoso: 'our sub' is the same as 'sub'

[12:46] <ruoso> but the local name is installed inside that scope only... 

[12:48] *** bjak joined
[12:48] <moritz_> hurm

[12:49] <ruoso> which probably means that the option 2 is the correct one

[12:49] *** alester joined
[12:49] <ruoso> sub dispatch is 'no strict'

[12:50] <ruoso> it falls back to global lookup (by global meaning looking up in the package, and not only on the lexical scope)

[12:51] <ruoso> pugs: $Foo::bar = 1; module Foo { sub foo { say $bar } }; Foo::foo();

[12:51] <p6eval> pugs: OUTPUT[*** ␤    Unexpected " }"␤    expecting "::"␤    Variable "$bar" requires predeclaration or explicit package name␤    at /tmp/uEICR3JQar line 1, column 47␤]

[12:51] <ruoso> pugs: &Foo::bar = sub { 1 }; module Foo { sub foo { say bar() } }; Foo::foo();

[12:51] <p6eval> pugs: OUTPUT[*** Can't modify constant item: VStr "MkCode {isMulti = True, subName = \"&\", subType = SubPrim, subOuterPads = [], subInnerPad = MkPad (padToList []), subPackage = , subAssoc = AIrrelevantToParsing, subParams = [], subBindings = [], subSlurpLimit = [], subReturns = (mkType \"An...

[12:51] <ruoso> pugs: &Foo::bar := sub { 1 }; module Foo { sub foo { say bar() } }; Foo::foo();

[12:51] <p6eval> pugs: OUTPUT[1␤]

[12:52] <moritz_> ruoso: re sub lookup is 'no strict', that's my feeling as well

[12:53] <ruoso> pugs: &Foo::bar := sub { 1 }; module Foo { sub foo { say &bar.() } }; Foo::foo();

[12:54] <p6eval> pugs: OUTPUT[*** ␤    Unexpected ".()"␤    expecting "::" or signature value␤    Variable "&bar" requires predeclaration or explicit package name␤    at /tmp/pstwoiEGm4 line 1, column 56␤]

[12:54] <ruoso> indeed... it looks like so...

[12:55] *** bjak left
[12:56] <ruoso> alright... so it looks that sub dispatch does:

[12:56] <ruoso> 1) looks for all variants from the lexical scope and from package CANDO

[12:56] *** bjakb joined
[12:56] <ruoso> (it traverses itself the lexical scope, so a inner declaration doesn't mask the outer declaration)

[12:57] <ruoso> greps for the ACCEPTS

[12:57] <moritz_> (CANDO sounds like a reactor from a nuclear power plant; but I probably confuse that with CANDU)

[12:57] *** alester left
[12:57] <ruoso> sorts using a "pluggable disambiguation code"

[12:57] <ruoso> and invoke the first

[12:58] <ruoso> and we leave a cache of all variants in the innermost declaration as the room for optimizations

[12:58] <moritz_> sounds sane

[12:59] *** Alias_ joined
[13:01] *** Alias__ joined
[13:02] *** z80ASM joined
[13:02] *** xinming left
[13:06] *** Alias_ left
[13:22] *** z80ASM left
[13:27] *** pmurias joined
[13:28] *** BinGOs left
[13:28] *** iblechbot left
[13:30] *** jferrero left
[13:31] *** pmurias_ joined
[13:31] *** pmurias_ left
[13:31] <pmurias> is it possible to add multi variants at runtime?

[13:31] <moritz_> yes

[13:33] <pmurias> how? ;)

[13:33] <moritz_> proto foo; eval 'sub foo($x) { $x*2 }'; say foo(2);

[13:35] <pmurias> perl6: multi foo(1) {say 3};foo(1);

[13:35] <p6eval> pugs: OUTPUT[*** ␤    Unexpected "1"␤    expecting formal parameter or ")"␤    at /tmp/yOHlPNDb3K line 1, column 11␤]

[13:35] <p6eval> ..elf 22554: OUTPUT[No viable candidate for call to multimethod foo(#) at (eval 121) line 4␤ at ./elf_f line 3861␤]

[13:35] <p6eval> ..rakudo 31827: OUTPUT[Statement not terminated properly at line 1, near "{say 3};fo"␤␤current instr.: 'parrot;PGE::Util;die' pc 119 (runtime/parrot/library/PGE/Util.pir:82)␤]

[13:36] <pmurias> perl6: multi foo(Int $a) {say 3};foo(1);

[13:36] <p6eval> elf 22554, pugs, rakudo 31827: OUTPUT[3␤]

[13:36] *** BinGOs joined
[13:37] <moritz_> perl6: multi foo(Int $x) { say "Int" }; eval 'multi foo(Str $x) { say "Str" }'; foo(1); foo("bar");

[13:37] <p6eval> elf 22554, rakudo 31827: OUTPUT[Int␤Str␤]

[13:37] <p6eval> ..pugs: OUTPUT[Int␤Int␤]

[13:37] <moritz_> elf++

[13:37] <moritz_> rakudo++

[13:37] <pmurias> is it possible to close multis?

[13:37] <pmurias> like use multi :closed?

[13:37] <moritz_> dunno

[13:38] <moritz_> don't think it makes much sense

[13:38] <pmurias> why?

[13:39] <moritz_> because multis are one of teh central mechanism to get extensibility into Perl 6

[13:39] <ruoso> http://www.perlfoundation.org/perl6/index.cgi?smop_multi_sub_dispatch

[13:39] <lambdabot> Title: SMOP Multi Sub Dispatch / Perl 6, http://tinyurl.com/43fhyt

[13:39] *** Lorn joined
[13:40] <pmurias> ruoso: hi

[13:40] <ruoso> hi pmurias 

[13:42] <pmurias> ruoso: withought variant disambiguation multis wouldn't be more powerfull then normal methods

[13:43] <ruoso> indeed

[13:43] *** BinGOs left
[13:43] <ruoso> pmurias, refresh the wiki page ;)

[13:43] *** renormalist left
[13:44] *** BinGOs joined
[13:45] <pmurias> we also need to check for ambiguity

[13:45] <pmurias> that is there need to be 1 topmost item

[13:46] <ruoso> pmurias, I think the disambiguation code would 'fail' in that case

[13:47] <pmurias> ok

[13:49] *** xinming joined
[13:50] <pmurias> ruoso: can i remove the nasty adjective

[13:50] <pmurias> ?

[13:50] *** abra joined
[13:50] <ruoso> yeah... :)

[13:50] <moritz_> ;)

[13:54] <pmurias> got to run to eat something and catch a train

[13:54] <pmurias> &

[13:54] *** pmurias left
[13:58] *** alester joined
[14:01] *** kanru left
[14:01] *** xinming left
[14:02] *** viklund left
[14:09] *** [particle]1 joined
[14:14] *** iblechbot joined
[14:27] *** [particle] left
[14:32] *** eternaleye left
[14:37] *** sscaffidi joined
[14:37] *** coke joined
[15:02] *** z80ASM joined
[15:07] <rakudo_svn> r31829 | pmichaud++ | [rakudo]:  spectest-progress.csv update: 205 files, 4366 passing, 11 failing

[15:11] *** sscaffidi left
[15:12] *** hercynium_ left
[15:16] *** justatheory joined
[15:20] *** mj41_ left
[15:21] *** ab5tract joined
[15:22] *** z80ASM left
[15:26] *** mj41 joined
[15:27] *** alanhaggai left
[15:29] *** z80ASM joined
[15:32] *** lisppaste3 left
[15:38] *** xinming_ joined
[15:42] <ruoso> TimToady, if you have some time, could you please take a look at http://www.perlfoundation.org/perl6/index.cgi?smop_multi_sub_dispatch

[15:42] <lambdabot> Title: SMOP Multi Sub Dispatch / Perl 6, http://tinyurl.com/43fhyt

[15:43] *** Exodist joined
[15:46] *** lisppaste3 joined
[15:47] <TimToady> I never have some time :)

[15:47] <TimToady> unless you count negative time...

[15:48] <PerlJam> ruoso: I just looked at it and your examples look single-dispatchy 

[15:49] <ruoso> PerlJam, what do you mean?

[15:50] <TimToady> thinking about lexical CANDO now  :)

[15:51] *** kanru joined
[15:52] <TimToady> as someone mentioned earlier, you need to deal with ambiguities too

[15:52] *** jhorwitz joined
[15:55] <TimToady> and there are probably a few other things from S12:876 that will need to be considered eventually

[15:55] <TimToady> though a lot of it can be swept under the carpet of "sorting"

[15:56] <TimToady> but it basically looks sane

[15:56] <ruoso> lexical CANDO?

[15:57] <TimToady> lexical autoloading of some sort or other

[15:57] <TimToady> probably only dynamic response, not install new symbols

[15:57] <ruoso> ah... I see...

[15:58] <ruoso> it seems heavyweight to call CANDO for every lexical scope in the tree

[15:58] <TimToady> but it would be nice to intercept the query on the way outward

[15:58] *** xinming_ left
[15:58] *** xinming_ joined
[15:58] <ruoso> TimToady, probably installing symbols at runtime is better

[15:58] <ruoso> instead of doing the AUTOLOAD way

[15:59] <TimToady> well, the presence of a CANDO in an outer lexical scope would basically pessimize the ability to know what a name means at compile time

[16:00] <TimToady> but that can be known at compile time :)

[16:00] <ruoso> oh... I see... you're actually thinking about CANDO not being in the package at all

[16:00] <TimToady> that's what I mean by "lexical"

[16:00] <coke> has anyone written a rule to english translator?

[16:00] <lambdabot> coke: You have 1 new message. '/msg lambdabot @messages' to read it.

[16:01] <ruoso> I initially read that as "additionally in the lexical scope"

[16:01] <TimToady> but also potentially in the package, as it is currently

[16:02] <ruoso> ok...

[16:02] <ruoso> so it basically means adding another step...

[16:02] <TimToady> anyway, just a thought, doesn't even need a bit in the lexical scope unless you actually find a my CANDO at compile time

[16:03] <ruoso> hmm... I see... the presence of a CANDO would generate a degenerated lexical scope object

[16:03] <TimToady> which would know to treat the CANDO as *

[16:04] <TimToady> it's probably not worth worrying about right now

[16:04] <ruoso> yeah... it looks like something that can be just plugged in

[16:04] <TimToady> can be retrofitted to the compiler if we decide to do it later

[16:04] *** alanhaggai joined
[16:05] *** z80ASM left
[16:07] *** z80ASM joined
[16:08] <diakopte1> moritz_: you pinged

[16:09] *** diakopte1 is now known as diakopter_o

[16:09] *** diakopter_o is now known as diakopter

[16:10] <diakopter> moritz_: you pang

[16:10] <moritz_> diakopter: yes, about the SVN::Web stuff, but Infinioid helped me to sort it out in the mean time

[16:11] <diakopter> that guy is very resourceful

[16:11] <diakopter> what was wrong with it

[16:11] <moritz_> it died on every request :/

[16:11] <diakopter> what caused that symptom

[16:12] <moritz_> assertion failure in some svn libs... changing a path from '/' to '' helped

[16:16] *** exodist_ joined
[16:16] *** Exodist left
[16:16] *** exodist_ is now known as Exodist

[16:17] <pugs_svn> r22555 | moritz++ | [t/spec] unfudge passing tests in split-simple.t

[16:31] *** [particle] joined
[16:34] <pugs_svn> r22556 | moritz++ | [t/spec] more tests for unchanged source string in transliteration tests.

[16:36] *** z80ASM left
[16:43] *** Alias__ left
[16:47] *** [particle]1 left
[16:56] *** cosimo left
[17:07] *** xinming_ left
[17:07] *** xinming joined
[17:13] *** mberends joined
[17:17] *** apeiron left
[17:18] *** jferrero joined
[17:19] *** apeiron joined
[17:20] *** abra left
[17:28] *** raiph joined
[17:28] *** raiph left
[17:30] *** jan_ left
[17:32] *** jan_ joined
[17:32] *** coke left
[17:33] *** meppl joined
[17:42] *** smg left
[17:46] *** sri_work left
[18:06] <rakudo_svn> r31835 | moritz++ | [rakudo] workaround for RT #59730 by cjfields++ (Str.trans with closures)

[18:07] <pugs_svn> r22557 | moritz++ | [t/spec] unfduge passing test, cjfields++

[18:11] *** pyrimidine joined
[18:12] *** Exodist left
[18:15] *** Exodist joined
[18:20] *** abra joined
[18:33] <pugs_svn> r22558 | moritz++ | [t/spec] added a test file for infix:<where>

[18:33] *** abra left
[18:37] <moritz_> I would appreciate it if somebody could take a look at r22558, not sure I fully understood that operator

[18:39] *** Southen_ joined
[18:56] *** Southen left
[18:58] *** ruoso left
[19:02] *** alanhaggai left
[19:03] *** zamolxes joined
[19:03] *** tomyan left
[19:06] *** pyrimidine left
[19:12] *** smg joined
[19:15] *** [particle1 joined
[19:19] *** [particle1 left
[19:36] <TimToady> moritz_: well, I don't know if I'm somebody, but it looks okay to me.

[19:36] <moritz_> TimToady: you're somebody enough to count in this one ;)

[19:37] <TimToady> it's a bit subtle that the closures doing appending are returning true

[19:37] <moritz_> subtle, but intended ;)

[19:37] <TimToady> well, but you could say $x ~= 'b'; True to be explicit

[19:38] <moritz_> right

[19:38] <TimToady> just thinking of the Gentle Reader

[19:39] <TimToady> btw, thanks for all your spectacular work on the test suite

[19:40] <moritz_> my pleasure

[19:40] <TimToady> what's your opinion of changing all the is $a,$b to ok $a eqv $b?

[19:40] <TimToady> or maybe even making the builtin ok an infix?

[19:41] <TimToady> so you could say $a eqv $b ok "message"

[19:41] <moritz_> wait a sec...

[19:41] <TimToady> well, would look better with ok lined up with tabs

[19:42] <moritz_> I like "ok" up front

[19:42] <TimToady> or maybe the builtin tests could be $a eqv $b  OK "message";

[19:42] <TimToady> well I like what you're testing up front :)

[19:43] <TimToady> and I don't like commas

[19:43] <moritz_> why do you want to make them all operators?

[19:43] <TimToady> esp when they can be confused with precedence

[19:43] <moritz_> re all is $a, $b to ok $a eqv $b, I think many comparisons should stay string comparisons

[19:44] <TimToady> well, that's the trouble, people are using them both ways, so ok would make it explicit

[19:44] <moritz_> right

[19:45] <TimToady> anyway, I'm just trying to think of a construct that reads more like "and", except it has to pay attention to the right side all the time

[19:45] <fullermd> "with"?

[19:45] <moritz_> well, the infix:<where> is rather confusing when read as english

[19:45] <TimToady> in fact, ok doesn't work well because it's the wrong valence, and because it disappears too easily in the middle

[19:46] <moritz_> that's why you suggested OK, right?

[19:46] <moritz_> as all caps

[19:46] <TimToady> yes, but also to hide the builtin a little better, since there are other functions too

[19:47] <TimToady> not that anyone is going to want to define infix:<DIES_OK>, but you never know...  :)

[19:47] <moritz_> anyway, I think that explicit comparison semantics are good, but I somehow fear all the work that it will make

[19:47] <TimToady> another reason I want to get rid of "is" is because it's overloaded in Perl 6

[19:47] <moritz_> right

[19:48] <TimToady> but I know how to work around that

[19:48] <TimToady> (though it's ugly)

[19:48] *** [particle]1 joined
[19:48] <TimToady> still, I'd rather not have the cognitive dissonance

[19:48] <TimToady> and the is test is horribly imprecise

[19:49] <TimToady> well, one argument (a weak one) for keeping a verb out front is that you could more easily make macros that way for evalish arguments

[19:50] <TimToady> but of course that's awfully fancy

[19:50] <moritz_> right now I'd rather rewrite all is() tests to ok() than rewriting everything to infix operators; but I don't see how early implementations can give good summaries of failing tests

[19:50] <TimToady> you mean with an infix?

[19:50] <TimToady> don't see a problem with ok()

[19:51] <moritz_> ok $a eq $b would just say "not ok", whereas is() can tell you what's expected and what you got

[19:51] <TimToady> ah

[19:51] <moritz_> so unless you have a very clever macro you loose the information too early

[19:53] <TimToady> I wonder how easy it would be to allow parameter properties that capture the text of the parameter, not because you want to reprocess the text like a macro, but simply for documentation

[19:53] <TimToady> could write assert() using that too

[19:54] <TimToady> as long as the original program is available as a string, and we know where the argument started and stopped, it could be done.

[19:54] <moritz_> but how does that help with error reporting?

[19:55] <TimToady> right, still doesn't give you the two values...drat...

[19:55] <moritz_> an assert($x eq $y) would know '$x eq $y' and true/false

[19:55] *** jferrero left
[19:58] <moritz_> unless it would peek into the AST of its arguments, which is really non-trivial

[19:58] <TimToady> maybe there wants to be a metaoperator, as long as we're dreaming

[19:58] <TimToady> because you can change is to iseq, iseqv, but is== is not good

[19:59] <TimToady> don't really need to deal with AST, I think

[20:00] <moritz_> so would you write '$x iseq $y OK "message";'?

[20:01] <moritz_> that'd be confusing, to say the least

[20:01] <TimToady> something like that, though that's kind of ugly

[20:02] <TimToady> but something that would automatically capture $x, $y, '$x eq $y', and eval '$x eq $y'

[20:02] <TimToady> well, and maybe 'eq'

[20:03] <moritz_> still sounds like too much magic for basic implementations

[20:04] <TimToady> could always hardwire 'ok' into the grammar too

[20:05] <TimToady> as long as we're building in test ops, that would not be terribly difficult

[20:06] <TimToady> after all, all the built-in constructs are essentially macros

[20:06] <TimToady> and the utility of this might well outweigh the futility :)

[20:07] * moritz_ isn't entirely convinced

[20:08] <TimToady> people weren't entirely convinced by fudge either  :)

[20:08] <moritz_> aye ;)

[20:08] <TimToady> anyway, if we set up the syntax such that a stupid ok could work without macroizing, but you just get less info, that's probably cool

[20:09] <TimToady> then if the grammar redirects to a smart ok, we just get more info

[20:10] <moritz_> maybe you could even convince viv to rewrite the tests automatically

[20:11] <TimToady> well, that'd be at the parse tree or ast level, but sure, that's about the right level to recognize the structure of the first argument

[20:12] <TimToady> on the other hand, if it's just a grammar rule, we just pick the right precedence to pick off the two sides of the comparison

[20:12] <TimToady> several equivalent aproaches

[20:14] *** BinGOs left
[20:15] <moritz_> brb

[20:15] *** FurnaceBoy joined
[20:17] <pmichaud> it almost cries out for making it clear that 'ok', 'is', etc. are truly test operators

[20:17] <pmichaud> so maybe  infix:<?is>  infix:<?ok>

[20:18] <pmichaud> where ?is is a ternary.

[20:18] *** [particle]1 left
[20:19] <pmichaud> or, infix:<?is>  keeps its arguments somewhere that ?ok can use in a diagnostic message

[20:19] <pmichaud> $a ?is $b ?ok "variable equivalence"

[20:19] <moritz_> in a contet var, or something?

[20:19] <pmichaud> true ?ok "truth"

[20:20] <pmichaud> I'm just throwing out notions here -- I'm not convinced myself.

[20:20] *** r0bby left
[20:20] <pmichaud> maybe it's another meta prefix

[20:21] <pmichaud> $a ?eqv $b :diag<equivalence of variables>

[20:21] <TimToady> there are obvious infelicities in the current approach, so we might as well fix 'em  all  :)

[20:21] <pmichaud> although ? wouldn't work well as the meta prefix.

[20:21] *** r0bby joined
[20:21] <TimToady> yeah, I was thinking about metaops earlier

[20:21] <pmichaud> oh, I guess it wouldn't be toooooo bad

[20:21] <moritz_> pmichaud: in principle I like the notation, but it looks like more character noise

[20:22] <pmichaud> maybe it's just an adverb to the existing ops?

[20:22] <pmichaud> $a eqv $b :test<items are equivalent>

[20:22] <pmichaud> $a eq $b :test<items are string equivalent>

[20:22] <TimToady> I was thinking if we wrote 'ok' as a macro the extra info would come in as named args

[20:22] <TimToady> so the first two args would still be the boolean and the string

[20:23] <pmichaud> but the advantage of tying it to the comparison operator is that it has the operands immediately available for a diagnostic message

[20:23] <TimToady> hmm, interesting syntax

[20:23] <pmichaud> unless we have "interesting values of boolean"  :-)

[20:23] <TimToady> Test Yourself!

[20:24] <pmichaud> it could even be

[20:24] <pmichaud> $a eq $b :ok<items are string equivalent>

[20:24] <pmichaud> if there's no :ok adverb, then it's not part of the test output.

[20:24] <TimToady> and the operator knows its own identity too

[20:24] <pmichaud> of course, this assumes that we have adverbs, which might be a little difficult in a newish implementation :-|

[20:25] <pmichaud> I'm guessing it's less difficult now that there's a standard grammar, though. 

[20:25] *** zamolxes left
[20:25] <TimToady> which is the advantage of a stupidish ok $a eqv $b, "string"

[20:25] <TimToady> with extra named args containing the pertinent bits of the first arg

[20:25] <TimToady> which a stupid "ok" can ignore

[20:25] *** zamolxes joined
[20:26] <pmichaud> rakudo's lack of adverb support is mostly because it wasn't entirely clear how to get them into the grammar

[20:26] <pmichaud> (whereas it's much clearer now.)

[20:26] <TimToady> but especially with tabs before :ok it could look very clean

[20:26] <pmichaud> yes

[20:26] *** BinGOs joined
[20:26] <pmichaud> ....and....

[20:27] <TimToady> it would also be pretty easy to preprocess into a stupider form

[20:27] <pmichaud> a newbie compiler could just treat :ok as a special syntax

[20:27] <TimToady> assuming one per line

[20:27] <pmichaud> until it has full adverb support

[20:27] <TimToady> that too

[20:27] <moritz_> one per line isn't always realistic

[20:28] <TimToady> now we just have the problem of dispatching to the version of comparisons that supports the :ok parameter... :/

[20:28] <pmichaud> it's also nice because the default   :ok  could give a reasonable message based on the operator type

[20:28] <pmichaud> i.e.,    $a eqv $b            :ok

[20:28] <pmichaud> could give a nicer error message than   ok($a eqv $b)

[20:28] <pmichaud> s/error/diagnostic/

[20:28] <TimToady> "FOO isn't eqv to BAR you #$&*@#$&!"

[20:29] <pmichaud> exactly.

[20:29] <pmichaud> that's much nicer.

[20:29] <pmichaud> how many comparisons would need to support :ok?

[20:29] <pmichaud> most other comparisons could be reduced (in tests) to versions that support :ok, same as we do now

[20:30] <TimToady> I wonder how often we'd have people making the error of trying to interpoalte into :ok<bad $x pardner>

[20:30] <pmichaud> I also wonder what happens with negative comparisons

[20:30] <pmichaud> $a != $b   :ok<not equal>

[20:31] <pmichaud> I guess that actually works.

[20:31] <TimToady> presumably meta-! needs to know about it

[20:31] <pmichaud> anyway, I think I've tossed my popcorn for now.

[20:31] <pmichaud> er, peanuts

[20:31] <TimToady> peanuts hurt more

[20:31] <pmichaud> (I used to go to melodramas where the "peanut gallery" actually threw popcorn at the actors)

[20:32] <TimToady> anyway, I think this could be a new state of the art

[20:32] <moritz_> agreed

[20:32] <TimToady> and it doesn't look terribly hard

[20:32] <pmichaud> the :ok adverb?  really?  I did something good?  ;-)

[20:32] <TimToady> for once :P

[20:33] <moritz_> if it's reasonable to implement (which I can't really judge) I'm all for it

[20:33] <TimToady> well, even if it's unreasonable, wouldn't be the first time I forced it anyway...  :)

[20:33] <pmichaud> THAT'S for sure!  :-P

[20:34] <TimToady> after all, Perl Philosphy is simply to torment the implementors on behalf of the user

[20:34] <pmichaud> aha!  I have a quote for my keynote.

[20:34] <moritz_> lol

[20:34] <pmichaud> and perhaps a theme.

[20:34] <TimToady> wow, I said something good (for once)

[20:36] <FurnaceBoy> eh, you're frequently quotable.

[20:36] <FurnaceBoy> 	<TimToady>	ASCII just doesn't have enough brackets...  I've noticed this before...

[20:37] <pmichaud> that's why we make new ones, like "<< >>"

[20:37] <pmichaud> and #{ ... }

[20:37] <pmichaud> and =begin FOO ... =end FOO

[20:37] <TimToady> there aren't enough quotidian quotes

[20:38] <pmichaud> and even things like  '(' ~ ')' <EXPR>

[20:38] <pmichaud> which is a particularly bizarre form of bracketing construct :-)

[20:38] <TimToady> in which the contents leak out of the brackets  :)

[20:39] <moritz_> so what happens to plan()?

[20:39] <TimToady> why should it change?

[20:39] <moritz_> everything else is an operator now

[20:39] <pmichaud> we still want todo(), plan()

[20:40] *** apeiron left
[20:40] <TimToady> we just want to throw out the "use Test;" part

[20:40] <TimToady> unless you want a different tester

[20:40] <moritz_> so 'use Test::Most' would just overwrite... what?

[20:41] <moritz_> the :ok part, somehow?

[20:41] <TimToady> all those functions that aren't there anymore  :)

[20:41] <pmichaud> :ok becomes the "builtin" form for testing, but other modules can still define their own "is", "ok", "dies_ok", "is_deeply", whatever equivalents

[20:41] <pmichaud> as normal functions

[20:42] <TimToady> I wonder if people are going to be upset by our taking :ok as an adverb

[20:42] <pmichaud> on the operators?

[20:42] <moritz_> so if somebody wants to change the behaviour of :ok, which hooks do they pull?

[20:42] <pmichaud> or in general?

[20:43] <TimToady> write a set of comparisons that have :ok as a named parameter and included in the current lexically scope more tightly than the builtins from the prelude

[20:43] <TimToady> that's all

[20:44] <TimToady> and you only have to redefine the ones you want to change

[20:44] <TimToady> that's why lexically scoped multis interleave with other longnames from other scopes the way they do

[20:45] <TimToady> (used to be the other way till we got smarter)

[20:46] <TimToady> anyway, the :ok call won't dispatch at all to a version that doesn't support :$ok as a parameter

[20:46] <pmichaud> that might result in "spooky at a distance"

[20:47] <TimToady> I presume the proto has :ok in it but the standard operator leaves that out of the sig

[20:47] <TimToady> how so?

[20:47] <pmichaud> $a foo $b    might dispatch differently from   $a foo $b :ok

[20:47] <pmichaud> someone simply adding an :ok  might not recognize the difference.

[20:47] <TimToady> that's true of any multi

[20:47] <pmichaud> true.

[20:48] <moritz_> so there's no magical :ok that turns an infix op into a test, as a fallback?

[20:48] <TimToady> fudge --ok

[20:48] <TimToady> hmm, that is a problem for fudge

[20:49] *** apeiron joined
[20:49] <TimToady> how will it recognize the beginning of a statement if there's no "is/ok" there?

[20:50] <TimToady> another problem: $x eqv $a + $b :ok will apply the :ok to the +

[20:50] <pmichaud> oh well.

[20:51] <pmichaud> it was a nice thought.  :-)

[20:51] <TimToady> they'd have to write $x eqv ($a+$b) :ok

[20:51] <TimToady> but that's just how adverbs work on operators

[20:51] <moritz_> another test suite faq

[20:51] <pmichaud> presumably   $a + $b :ok   would not dispatch?

[20:52] <pmichaud> i.e., there wouldn't be a matching infix:<+>

[20:52] <TimToady> probably not, so at least it's an error

[20:52] <TimToady> albeit at runtime

[20:52] <TimToady> but hey, that's when you run the tests, at runtime :)

[20:53] <TimToady> so it can still fly, I think

[20:53] <TimToady> still have the fudge problem though

[20:53] <TimToady> unless we have an "is" placeholder at the beginning, or some such

[20:54] <TimToady> or change the rules for how fudge recognizes a test

[20:54] <TimToady> split into statements and assume anything containing :ok is a test, maybe

[20:55] <TimToady> where "split into statements" pays attention only to final ; or }

[20:57] <moritz_> and we significantly increase the number of builtin multis

[21:01] <TimToady> but the presence or absence of a named argument is known at compile time, so the candidate list can be optimized even before we know any of the types

[21:01] <pmichaud> ...and one could write the builtins with optional named params

[21:01] <TimToady> that seems like a recipe for slow builtins

[21:02] <moritz_> aye

[21:02] <pmichaud> yes

[21:04] <TimToady> very likely the :ok versions delegate to the non-:ok versions for the actual work

[21:04] <TimToady> and it seems like there's going to be a lot of boilerplate

[21:05] <TimToady> which argues more for a metaoperator

[21:05] <TimToady> maybe :ok is really a metaoperator in disguise

[21:06] <TimToady> it just happens to bind to the same operator as a real adverb

[21:06] *** ab5tract left
[21:08] *** pbuetow joined
[21:08] <TimToady> but always just generates the appropriate underlying operator you need

[21:08] <TimToady> sort of a semantic pass macro

[21:10] <PerlJam> Are you guys talking about adding testing operators to perl 6?

[21:10] <moritz_> yes

[21:10] <PerlJam> awesome!

[21:10] <pmichaud> PerlJam: making test functions part of the builtins, yes.

[21:10] <moritz_> PerlJam: the current approach looks like this:  $x == 2, :ok<$x is really 2>;

[21:10] <TimToady> no comma

[21:10] <moritz_> erm, withotu the comma

[21:10] <moritz_> right

[21:11] <PerlJam> er, how does :ok know not to bind to the 2 ?

[21:11] <pmichaud> adverbs bind to operators

[21:11] <TimToady> it's where an infix is expected

[21:11] <TimToady> same way 1..10:by(2) knows

[21:12] <PerlJam> aye, I just haven't looked at perl6 syntax in a while.

[21:12] <PerlJam> so, all of the comparators grok :ok ? 

[21:12] <PerlJam> (or will)

[21:13] <TimToady> make :ok a crypto-meta-operator that rewrites any operator that returns boolean

[21:13] <PerlJam> so, what happens to  $a == 2 && $b == 3  :ok<fooey>   ?  Do I need parens or something?

[21:14] <moritz_> probably around the second ==

[21:14] <TimToady> that one would silently fail currently

[21:14] <TimToady> I mean, fail to work as expected

[21:14] <TimToady> you'd get a useless use of, maybe

[21:14] <PerlJam> it would silently suceed where it may should have failed  :)

[21:15] <TimToady> it's possible we should reformulate adverbs a bit

[21:16] <TimToady> I wonder if they can be made to apply to the *top* operator visible

[21:16] <TimToady> instead of the last one

[21:16] <TimToady> then this would apply to the && instead of the ==

[21:16] <PerlJam> How far up the parsetree should they look?  :-)

[21:16] <TimToady> but 1..10:by(2) would still work

[21:17] <pmichaud> then of course we have the issue of    ... and 1..10:by(2)

[21:17] <TimToady> only inside the current scalar item, I think

[21:17] <TimToady> so make it slighty tighter than comma

[21:18] <TimToady> pmichaud: that would be fine since :by is tighter than and

[21:18] <TimToady> && would be more of a problem

[21:19] <PerlJam> This is starting to feel like the "regular" syntax version of that weird regex ~ thingie

[21:20] *** mberends left
[21:20] <PerlJam> Use the special <MAGIC HERE> operator for all your testing needs.

[21:21] <pmichaud> I have to go help kids with their homework

[21:21] <pmichaud> bbl

[21:21] *** FurnaceBoy left
[21:22] <PerlJam> So ... what was wrong with  ok($test,$str)  ?  Or, why do we need another form?

[21:22] *** tewk_ joined
[21:25] <TimToady> we talked about that eariler, doesn't provide anything beyond a boolean unles ok is a macro

[21:25] <moritz_> PerlJam: one of the problems is that is() isn't very verbose about its comparison semantics

[21:26] <moritz_> PerlJam: and changing that to ok($a eqv $b) doesn't give any useful diagnostic output

[21:26] <TimToady> backlog about the last 2 hours...

[21:27] <PerlJam> okay.

[21:28] <PerlJam> so, an adverb that attaches to the highest precedence operator in the previous expression   ?  And  all adverbs or just special ones with nice syntactic markers?

[21:29] <TimToady> highest within , precedence

[21:29] <TimToady> so basically loose unary precedence like "not", but a postfix

[21:30] *** kulp joined
[21:30] *** azawawi joined
[21:31] <TimToady> but unlike current formulation, can see within (), so $a and ($b and $c) :foo applies to the second and, because it's the top operator in the expression governed by the :foo

[21:31] <TimToady> assuming you'd never want to apply an adverb to (), which we already assume

[21:31] *** iblechbot left
[21:32] <PerlJam> Those seem like really special adverbs.  Could we make them look lik ^:foo or something?

[21:33] <PerlJam> s/lik/like/

[21:33] <TimToady> but since tigher than comma, works in the middle of a list: 1,2,3..10:by(2), 4,5

[21:33] <TimToady> the only thing special is that it would write the code for you instead of dispatching to a multi with an :ok parameter

[21:33] <PerlJam> or maybe I'm just really uncomfortable with all adverbs behaving this way.

[21:34] <TimToady> the syntax is independent of the behavior

[21:34] <TimToady> if you mean the meta-op semantics

[21:34] *** tewk left
[21:34] <PerlJam> sure, but I'd like the former to give me some clue about the latter

[21:34] <TimToady> do you care that !eq is writing code for you?

[21:35] <TimToady> or += for that matter

[21:36] <TimToady> the only difference is whether you have to implement :ok explicitly or not, and the user doesn't really care

[21:37] <PerlJam> !eq, += and :ok all occupy separate conceptual boxes in my head.  Mayhap they shouldn't.

[21:37] <TimToady> maybe the current metaoperators all have :foo forms too, and maybe that's their native form

[21:37] <TimToady> $a + $b :assignop

[21:37] <TimToady> doesn't really fly though

[21:38] *** apeiron left
[21:38] <TimToady> since you can't write === @x :reduce

[21:39] <TimToady> not that [===] is exactly normal either  :)

[21:39] <PerlJam> [===] feels more natural to me though

[21:39] <TimToady> well, I guess it means "are all of these the same object"

[21:39] <TimToady> well, you've been programmed to think of lists when you see []

[21:39] <PerlJam> true

[21:40] <TimToady> which is why I picked it, after all :)

[21:40] *** jogla joined
[21:40] *** BinGOs left
[21:42] <PerlJam> What you need is an implementation  :)  They always seem to bring design flaws out (if there are any)

[21:42] <TimToady> anyway, I don't see much problem with treating some adverbs as semantic macros; this is not important for the user to track, only the implementor of :ok, who would otherwise have to duplicate all the builtins

[21:42] *** alester left
[21:42] <TimToady> the policy of which operator to apply an adverb to is a different matter

[21:42] *** Limbic_Region joined
[21:43] <moritz_> in rx.t we have tests like this:

[21:43] <moritz_> ok ('bazaar' ~~ /a*: a/) ~~ Match where matchcheck($_, q/:a/), 'basic';

[21:43] <TimToady> gee, who wrote that mess :)

[21:43] <moritz_> would that become ('bazaar' ~~ /a*: a/) ~~ Match where matchcheck($_, q/:a/) :ok<basic>;

[21:43] <PerlJam> the principle of least surprise is a strong attractor.  you just have to pick the right least surprise  :)

[21:45] <TimToady> so that would apply :ok to the second ~~ if we went with the precedence solution, which is correct, I guess

[21:45] <moritz_> aye

[21:45] <TimToady> since that's the top operator

[21:45] <moritz_> but for longer expressions I'm a bit worried that the :ok is too far on the right

[21:46] *** apeiron joined
[21:46] <PerlJam> yeah, there's a bit of distance between there

[21:46] <moritz_> and it changes the expression from "useless expression in void context" to "run a test"

[21:46] <moritz_> which somehow violates the principile of end weight

[21:47] <TimToady> well, write a longer message :)

[21:47] <PerlJam> heh

[21:48] <TimToady> but it's kinda cool that brainos turn into "useless use"

[21:49] <TimToady> it'll even tell you *which* operator leaked

[21:49] <TimToady> well, one of 'em, anyway

[21:51] <TimToady> and it better justifies the existence of "loose unary" precedence :)

[21:51] <PerlJam> I guess part of my conceptual difficulty is that I don't think of tests in an adverbial way.  I think of them as nouns that you feed stuff to.  Maybe I'm just insane.

[21:51] <TimToady> well, they're predicates, really, or assertions

[21:52] <TimToady> if there weren't a history of ! meaning factorial we'd say  $a == $b! when we really mean it

[21:53] <PerlJam> they're the teacher and we're the students handing in our assignments to find out if we pass or fail.  :)

[21:53] <azawawi> hi

[21:53] <lambdabot> azawawi: You have 1 new message. '/msg lambdabot @messages' to read it.

[21:53] <moritz_> the difference between a test and an assertion is that you (have to) actively run a test, whereas assertions are verified along the way of a normal executioing

[21:54] <TimToady> yes, and you don't really want to blow execution out of the water on the first failed test :)

[21:54] <moritz_> (that's what the Eiffel people generally get wrong; they say "we don't need tests, we have our design by contract" - but as long as the code is not executed, these contracts aren't checked)

[21:55] <TimToady> you will soon have us all converted to Haskell :)

[21:55] *** BinGOs joined
[21:55] <moritz_> TimToady: so should :ok'ed operators catch exceptions?

[21:56] <moritz_> not before I convert myself to Haskell ;)

[21:56] <TimToady> well, why not?  the one think it can't do it catch parsefails...

[21:56] <TimToady> *thing

[21:58] <moritz_> nice

[21:59] <TimToady> although a parser could resync a statement if it sees an :ok coming up, I suppose, the way some parsers resync on semicolons

[21:59] <moritz_> what will '1 :ok<1 is a true value>' work out to?

[21:59] <moritz_> ie when there's no operator to bind to?

[22:00] <PerlJam> "operator expected"  :)

[22:00] <moritz_> well, these things must be tested somehow

[22:00] <PerlJam> unless there's a null operator it can bind to for other possibilities

[22:00] <moritz_> simple truthness, dies_ok, eval_dies_ok needs to be addressed

[22:01] <TimToady> currently it says 'No previous operator visible to adverbial pair

[22:01] <moritz_> sub unfix:<>

[22:01] <moritz_> the null operator

[22:01] <PerlJam> "unfix"?  :)

[22:01] <moritz_> neither pre nor post nor infix

[22:01] <TimToady> given that :ok is testing for boolean, presumably it should supply a true()

[22:01] <moritz_> unfix

[22:02] <PerlJam> What's your fixity?  I have none.

[22:03] <Limbic_Region> salutations all

[22:03] <moritz_> hello Limbic_Region ;)

[22:04] <moritz_> where did you leave your ~ ? ;-)

[22:05] <Limbic_Region> on use.perl it is a space

[22:05] <TimToady> the final frontier...

[22:06] <moritz_> unendliche weiten...

[22:06] <moritz_> ELANG

[22:09] *** kulp left
[22:12] *** pbuetow left
[22:21] *** hercynium left
[22:23] *** Exodist left
[22:24] *** YMas joined
[22:25] <azawawi> moritz_: any interesting RTs / tasks to work on?

[22:26] <moritz_> depends on your notion of "interesting" ;)

[22:27] <azawawi> moritz_: something that gets committed in the end ;-)

[22:28] <moritz_> azawawi: I'm sure most of your patches will get commited in the end...

[22:28] <moritz_> on the side of the test suite there's still a lot in t/TASKS

[22:28] <moritz_> on the rakudo side - dunno, really

[22:28] <azawawi> im actually looking at it

[22:28] <moritz_> perhaps infix:<where>

[22:28] <azawawi> tests for complex: polar

[22:30] <moritz_> have to go to bed now :(

[22:30] <moritz_> happy hacking ;)

[22:30] <azawawi> me 2 it is 1:29am here

[22:30] <azawawi> good night...

[22:31] *** YMas left
[22:40] *** hercynium joined
[22:41] *** azawawi left
[22:46] *** ab5tract joined
[22:48] *** ingyfoo joined
[22:48] *** ingy left
[22:49] *** ingyfoo left
[22:49] *** ingy joined
[22:50] <pugs_svn> r22559 | azawawi++ | [t] removed unused empty directories

[22:54] *** r0bby left
[23:03] *** kulp joined
[23:04] <pugs_svn> r22560 | putter++ | [elfish/on_sbcl]  Self-compiles.

[23:04] <pugs_svn> r22560 | putter++ | Undef and bool boxing.  Dispatch and misc fixes.  Slower.

[23:04] <pugs_svn> r22560 | putter++ | Doesn't quite compile the p5 version.

[23:04] <pugs_svn> r22560 | putter++ | [STD_red] Improved --format=cl string and nil dumping.

[23:04] <pugs_svn> r22560 | putter++ | [elf_h] Yet more missing argument fixes.

[23:12] *** r0bby joined
[23:21] *** Lorn left
[23:22] *** elmex left
[23:29] *** kulp left
[23:41] <speckbot> r14591 | larry++ | Make operator adverbs parse sanely based on precedence.  They are now treated

[23:41] <speckbot> r14591 | larry++ | as "loose unaries" (albeit still in a trailing position), and no longer require

[23:41] <speckbot> r14591 | larry++ | the parser to track "previous operator".  The benefits are construed to

[23:41] <speckbot> r14591 | larry++ | outweigh the problems.

[23:41] <speckbot> r14591 | larry++ | 

[23:41] <speckbot> r14591 | larry++ | Note also that existence and deletion are now simply adverbs on subscript

[23:41] <speckbot> r14591 | larry++ | operators.

[23:53] *** hercynium left
[23:56] *** kulp joined
[23:59] *** drbean left
[23:59] *** alester joined
