[00:25] *** felipe left
[00:35] *** meppl joined
[00:43] *** hercynium left
[00:47] *** nipotaway is now known as nipotan

[00:47] *** larsen_ left
[00:50] *** alester left
[00:52] *** bacek joined
[01:31] <pugs_svn> r21975 | lwall++ | [STD] rudimentary global symbol table to detect routine definitions

[01:34] *** felipe joined
[01:36] <meppl> good night

[01:38] *** meppl left
[01:40] *** eternaleye left
[01:46] *** kanru left
[01:54] *** cookys left
[01:54] *** Guest16015 left
[01:54] *** nipotan left
[01:54] *** integral left
[01:54] *** hcchien left
[01:54] *** Tene left
[01:54] *** r0bby left
[01:54] *** Guest16015 joined
[01:54] *** hcchien joined
[01:54] *** integral joined
[01:58] *** r0bby joined
[01:59] *** r0bby left
[01:59] *** r0bby joined
[01:59] *** Tene joined
[02:00] *** hercynium joined
[02:22] *** Limbic_Region left
[02:26] *** xinming_ joined
[02:27] *** kanru joined
[02:39] *** xinming left
[02:49] *** rlb3 joined
[02:52] *** alester joined
[02:56] *** Schwern left
[03:00] *** wknight8111 left
[03:02] *** elmex_ joined
[03:07] *** eternaleye joined
[03:08] *** eternaleye left
[03:09] *** eternaleye joined
[03:11] *** rlb3 left
[03:16] *** elmex left
[03:16] *** elmex_ is now known as elmex

[03:22] *** Schwern joined
[03:24] *** hercynium left
[03:52] <s1n> if i find a parsefail but i'm not sure if it's parrot crashing or rakudo causing it, where do i file it?

[03:53] <Auzon> You can nopaste it to #parrot and ask them what they think. Alternately, just file it under Rakudo, and note your observation. (Unless someone else has a better idea?)

[03:53] <s1n> well, i think it's a bug in rakudo that causes a segfault on parrot

[03:54] <Auzon> hm. I'd say rakudobug then

[04:01] *** bacek left
[04:03] <s1n> heh

[04:03] <s1n> pmc_ext = 0xdeadbeef

[04:23] *** bacek joined
[05:16] *** justatheory left
[05:17] *** xinming_ left
[05:18] *** elmex left
[05:23] *** alester left
[05:24] *** xinming_ joined
[05:33] *** Psyche^ joined
[05:50] *** Patterner left
[05:50] *** Psyche^ is now known as Patterner

[05:58] *** sri_work_ left
[06:04] *** ashizawa joined
[06:05] *** thestarslookdown joined
[06:12] *** drbean left
[06:16] *** thestarslookdown left
[06:28] *** pmurias joined
[06:31] <pmurias> TimToady: what sort of trouble - explain please, only falling back on &postcircumfix:( ) comes to mind

[06:33] <pmurias> i have always assumed foo(42) would translate to &foo.postcircumfix:<( )>(42)

[06:34] <pmurias> re primitive construct you mean on the language layer or in the VM?

[06:45] *** masak joined
[06:52] <TimToady> how do you then define the () on the end of that call?  you get  &foo.postcircumfix:<( )>.postcircumfix:<( )>(42)

[06:52] <TimToady> and then &foo.postcircumfix:<( )>.postcircumfix:<( )>.postcircumfix:<( )>(42)

[06:58] * masak senses postcircumfix:<( )> all the way down...

[06:59] <moritz_> perhaps we just have to make the () -> .postcircumfix:<( )> expansion just lazyly, thus avoiding looping... ;-)

[07:06] <pmurias> TimToady: it's a primitive construct in that sense in SMOP the lowlevel Code object just does the invocation instead of calling .postcircumfix:<( )> on itself

[07:08] <pmurias> TimToady: to rephrase the question, if I put a custom object into &foo, what does it have to define in order for foo() to work?

[07:14] <TimToady> see S13:156

[07:15] <moritz_> TimToady: STD.pm doesn't seem to parse anonymous enums

[07:16] <moritz_>  t/spec/S02-builtin_data_types/enum.t says lives_ok { %hash = enum «:Sun(1) Mon Tue Wed Thu Fri Sat»; }, 'french quotes work...', :todo<feature>;

[07:16] <moritz_> and STD.pm

[07:16] <moritz_> Unknown routines: enum called at 27 35 43 51 59 67 85 

[07:16] <moritz_> (that was line 27)

[07:17] <viklund> will smart-match between a string and an array of regexes try to match the string against each of the regexes?

[07:17] <moritz_> I think you need $str ~~ any(@list) for that

[07:17] <viklund> (it didn't in Perl 5.010, which supprised me)

[07:17] <viklund> moritz_: ahh, thx

[07:17] <moritz_> or $str ~~ all(@list)

[07:17] <moritz_> or whatever your desired semantics are

[07:17] <TimToady> array doesn't imply any() in p6 even where it does in p5

[07:18] <viklund> ahh, ok

[07:18] <TimToady> well, that's why I put in the undefined sub code, to find out where it wasn't parsing right :)

[07:19] <moritz_> ;)

[07:19] <moritz_> and it doesn't seem to know the pair listop

[07:21] <TimToady> does in my copy :)

[07:22] <TimToady> and pretty much everything else from Functions.pod...

[07:23] <pugs_svn> r21976 | moritz++ | [STD] updated list of test functions

[07:23] <moritz_> ohh, too late

[07:23] <moritz_> if our changes conflict, feel free to disregard mine

[07:24] <moritz_> is try{...} ok, or does it need disambiguating whitespaces?

[07:25] <pugs_svn> r21977 | lwall++ | Lots of library function calls

[07:26] <TimToady> must have whitespace, and it's got a special rule

[07:26] <pugs_svn> r21978 | moritz++ | [t/spec] system() is called run() now.

[07:26] <TimToady> there is no try function

[07:26] <TimToady> be sure that you have the boolean test right on run

[07:26] <TimToady> run returns true on success

[07:27] <pugs_svn> r21979 | moritz++ | [t/spec] a few disambiguating whitespaces

[07:27] <moritz_> that test used system() in void context ;)

[07:28] <TimToady> which means it should probably throw an exception on failure.  :)

[07:28] <TimToady> now to figure out why it's not seeing "my &foo" as defining a sub...

[07:29] <moritz_> In this case the test harness will find the failure, I hoope

[07:29] <pugs_svn> r21980 | moritz++ | [t/spec] another s/system/run/

[07:31] <pugs_svn> r21981 | moritz++ | [t/spec] some disambiguationg whitespaces

[07:33] <pugs_svn> r21982 | lwall++ | [STD] helps to spell desiglname correctly...

[07:33] *** thestarslookdown joined
[07:34] <pugs_svn> r21983 | moritz++ | [t/spec] more disambiguation whitespaces (and parenthesis)

[07:37] <pugs_svn> r21984 | moritz++ | [t/spec] cleanups in reduce-metaop.t

[07:38] *** drbean joined
[07:40] <pugs_svn> r21985 | lwall++ | [STD] rescue a few more names from gimme5's clutches

[07:41] *** barney joined
[07:42] <pugs_svn> r21986 | moritz++ | [STD] update list of Test.pm functions

[07:43] *** araujo left
[07:52] <moritz_> "$stuff{a}" will call sub a, right?

[07:53] *** drbean left
[07:53] <TimToady> correct

[07:53] <moritz_> and it's parsed as a subscript, not as two separate interpolations?

[07:54] <moritz_> and it's the same in regex? (ie m/$stuff{a}/ )

[07:55] <moritz_> t/spec/S05-metasyntax/litvar.t seems a bit b0rked

[07:55] <moritz_> lines 38 to 47

[07:56] *** drbean joined
[07:57] <TimToady> yeah, either need to be .<a> or .{'a'}

[07:57] <TimToady> or both...

[08:00] <pugs_svn> r21987 | moritz++ | [t/spec] correct subscript in regex interpolation in litvar.t

[08:01] <masak> moritz_++ # test suite pumpking

[08:02] <TimToady> several places need to have min and max become [min] and [max]

[08:03] <TimToady> looks like STD doesn't parse '=begin END' without a corresponding =end END

[08:03] <pugs_svn> r21988 | moritz++ | [t/spec] brought a bit sanity to wrapping.t. Needs more.

[08:04] <moritz_> TimToady: sounds like it backtracks too much

[08:04] <TimToady> it does less than it used to. :)

[08:05] <TimToady> getting the scope of a failure just right is tricky

[08:06] <pugs_svn> r21989 | moritz++ | [t] mentioned wrapping.t in TASKS

[08:07] *** jferrero joined
[08:08] <TimToady> still not sure if there should be a 'multi new (Any where not .defined)' to catch all the new Foo calls, or whether we should force everyone to say "new Foo:"

[08:10] <moritz_> I think 'new Foo' is cute, and many beginners (and Perl 5 programmers) will be disappointed if it doesn't work

[08:10] <TimToady> in any case, the indirect form is currently parsed as a listop, so probably will give bogus undefined errors

[08:11] <TimToady> yes, and then they'll be entirely confused when "new Foo()" doesn't do at all what they expect

[08:12] <moritz_> ;)

[08:16] <pmurias> indirect object notation withough arguments is ugly

[08:21] <TimToady> but it is not at all clear that translating "foo $bar" to $bar.foo is a good idea in general

[08:25] <moritz_> IMHO it's clear that translating 'foo $bar' to '$bar.foo' is in general a bad idea ;)

[08:35] <pugs_svn> r21990 | moritz++ | [t/spec] s/break/last/

[08:35] *** pmurias left
[08:38] <TimToady> moritz_: break is a valid verb inside a when

[08:38] <moritz_> d'oh

[08:39] <masak> a no-op?

[08:39] <masak> I mean, a no-op when it's last in a when?

[08:40] <pugs_svn> r21991 | moritz++ | [t/spec] revert r21990, TimToady++ moritz--

[08:42] <TimToady> yes, there is an implicit break at the end of the when

[08:42] <TimToady> not sure what to do about does and is

[08:42] <TimToady> does can be a declarator like trusts, but is is going to conflict with Test

[08:43] <masak> can I put a while loop inside a given? what does a break do inside a when then?

[08:43] *** bacek left
[08:44] <TimToady> see S04:710

[08:45] *** larsen_ joined
[08:46] <pugs_svn> r21992 | lwall++ | [STD] add does, break, continue

[08:48] <masak> ok, so it doesn't necessarily break out of the given.

[08:49] <TimToady> (oh, and eager/hyper too)

[08:49] *** zamolxes left
[08:50] <TimToady> hmm, looks like FOO.break() is equivalent to Foo.leave()...

[08:51] <TimToady> *FOO rather

[08:52] <TimToady> well, can't keep my eyelids propped open anymore, so night all

[08:52] <TimToady> have the appropriate amount of fun & # thunk

[08:52] <moritz_> good night TimToady ;)

[08:54] <masak> god natt, TimToady

[08:54] *** thestarslookdown left
[08:59] *** kanru left
[09:12] *** kanru joined
[09:12] *** charsba__ joined
[09:15] *** zamolxes joined
[09:31] *** charsbar_ left
[09:38] <pugs_svn> r21993 | moritz++ | [t/spec] some more try { ... } rewrites in S12-attributes/delegation.t

[09:43] *** aindilis` joined
[09:48] *** iblechbot joined
[09:52] *** charsbar joined
[09:56] *** aindilis left
[10:01] *** charsba__ left
[10:06] <moritz_> rakudo: say 4.WHAT.WHAT

[10:06] <p6eval> rakudo 29834: OUTPUT[Int␤]

[10:06] <moritz_> rakudo: if 4.WHAT eq "Int" { say "yes" }

[10:06] <p6eval> rakudo 29834: OUTPUT[yes␤]

[10:07] <pugs_svn> r21994 | moritz++ | [t/spec] quote a type name

[10:11] *** iblechbot_ joined
[10:20] *** iblechbot left
[10:29] *** iblechbot joined
[10:35] *** wknight8111 joined
[10:43] *** iblechbot_ left
[10:53] *** elmex joined
[11:33] *** meppl joined
[11:45] *** BinGOs left
[11:58] <moritz_> I started with a bunch of blog posts for perl 5 programmers

[11:58] *** BinGOs joined
[11:58] <moritz_> it's a mixture of "learn perl 6" and "show off cool perl 6 features"

[11:58] <moritz_> http://perlgeek.de/blog-en/perl-5-to-6/

[11:58] <lambdabot> Title: blog | Perlgeek.de Blog

[11:58] <moritz_> feedback is welcome ;)

[11:59] <masak> first off, moritz_++ for the idea itself :)

[11:59] <masak> second, I'll get back to you when I've actually read it

[11:59] <moritz_> ;)

[11:59] <masak> in a week or so, due to my surfing habits

[12:00] <moritz_> I hope that in a week or so it'll actually 7 posts or so

[12:00] <masak> moritz_: btw, some november is running on feather now

[12:00] <masak> and it's 17 times faster than yesterday :)

[12:00] <moritz_> some are already written, and I plan to finish & publish one perl day

[12:00] <masak> viklund++

[12:00] <moritz_> that's great news ;)

[12:00] <masak> yes :)

[12:00] <moritz_> s/perl/per/

[12:01] <masak> next step: a proper domain name

[12:01] <masak> any suggestions?

[12:01] <moritz_> perl6-november.org

[12:01] * moritz_ is always bad with names

[12:01] <moritz_> november-wiki.org

[12:01] * masak likes that

[12:04] *** BinGOs left
[12:04] *** BinGOs joined
[12:04] <viklund> yes, november-wiki.org seems right

[12:05] <viklund> now all I need to fix is parsing the POST-strings correctly, and then we have a minimal working wiki :)

[12:10] <masak> just like last week :)

[12:14] <moritz_> so how did you achieve these speedups? precompiling?

[12:15] *** ruoso joined
[12:15] <viklund> moritz_: yes

[12:16] <viklund> --target=pir

[12:16] <moritz_> then it's also pmichaud++ ;-)

[12:17] <viklund> yep

[12:17] <ruoso> TimToady: if postcircumfix:<( )> has (|$capture) as the signature, the invocant of that capture will always be the code itself... once that Method isa Code, this is going to be problematic... it would be better if the call to postcircumfix:<( )> had the actual capture as the first positional argument of that call... so we can have a capture that has an invocant of other type...

[12:18] <viklund> pmichaud++ # An extra one

[12:20] <masak> karma target

[12:21] <masak> @karma target

[12:21] <lambdabot> target has a karma of 0

[12:21] <ruoso> TimToady: this is important to SMOP because it's bootstrapping its type system, and the invocant is actually used since a very low-level of the runtime, and it needs to be compatible with the higher-level runtime, so we can use low-level and high-level objects interchangeably

[12:21] <ruoso> which is, IMHO, the most important feature of Perl 6

[12:22] <ruoso> er... of the SMOP implementation of Perl 6

[12:23] *** zamolxes_ joined
[12:28] <ruoso> moritz++ the perl6-to-6 posts are awesome

[12:29] <moritz_> ruoso: thanks

[12:35] *** Alias_ joined
[12:41] <moritz_> published the next one, on types

[12:42] *** wknight8111 left
[12:44] *** zamolxes left
[12:48] <moritz_> S03:1700

[12:48] <moritz_> (just need the link, and the logs convert that for me ;)

[12:48] <masak> (the logs)++

[12:52] <ruoso> moritz_: ~~ when comparing with an undefined value always call .^does... which is not just the "recommended" way of checking types, but is actually the "only sane way" of doing it... The only other thing I could think of is $foo.WHAT === $bar.WHAT... but that might result in (1.WHAT === 123.WHAT) beingg false (considering the runtime might have a special type to represent the most common int values...

[12:52] <ruoso> .WHAT returns the actual prototype for that value, which might be some lowlevel optimized version of that type

[12:54] <ruoso> for instance... 1 might be a constant value that allows pointer identity tests (just like constant identifiers do in SMOP)

[12:54] <ruoso> and this objects return a  different WHAT

[12:54] <moritz_> ruoso: maybe I should emphasize that point more strongly...

[12:55] <moritz_> ruoso: but otoh it's a tutorial for those who are *not* familiar with all that stuff already, and I don't want to confuse them with too many details

[13:00] *** ashizawa left
[13:01] *** Alias__ joined
[13:01] *** Alias_ left
[13:02] *** ruoso_ joined
[13:02] * ruoso_ hate unstable connections in free software events...

[13:03] <moritz_> ruoso: would you like to contribute a short article about meta OO programming to that blog?

[13:03] <moritz_> ruoso: I don't feel qualified for that ;)

[13:03] <ruoso_> moritz_: anyway... I was trying to say (before my connection died)... that I would argue that .WHAT should not be mentioned as a way to check types... .WHAT is usefull to get a new object of the same type and other prototype things...

[13:05] <ruoso_> moritz_: I'm not sure that's something that should be part of an introdutory document... it will probably scare people away ;)

[13:05] <moritz_> ruoso_: it's not only introduction, it's also a feature show-off

[13:05] <moritz_> ruoso_: and .WHAT is useful if you don't know the type names

[13:05] <moritz_> rakudo: say 1.WHAT

[13:05] <p6eval> rakudo 29834: OUTPUT[Int␤]

[13:06] <moritz_> if you don't know if that thing is called Int or Integer, you call .WHAT on one

[13:06] <ruoso_> moritz_: but that could return SomeLowLevelTypeThatYouThinkIsAnInt

[13:06] <ruoso_> and that is not even registered in the global namespace

[13:07] <ruoso_> for instance... in SMOP... say 'new'.WHAT will return 'SMOP Constant Identifier'

[13:07] <moritz_> ruoso_: no. We had that discussion on p6l, and TimToady said that the canonical type should be returned

[13:08] <moritz_> and if it's an optimization, you have to cheat

[13:08] <ruoso_> hm... I have to backlog p6l (I not keeping up with the list)...

[13:09] <moritz_> I think it was in the "Rakudo test miscallenae" thread

[13:09] <ruoso_> but I should warn that I might disagree with that ;)

[13:11] <moritz_> then how would you proceed to obtain the user-visible direct type of an object?

[13:12] <ruoso_> moritz_: .WHAT

[13:13] <ruoso_> but the question is why you want the "canonical" type

[13:13] <ruoso_> instead of checking with ~~

[13:13] <moritz_> introspection

[13:13] <moritz_> for example writing a debugger

[13:14] <moritz_> which has the 'dump' command

[13:14] <ruoso_> er... that's why you have .perl

[13:14] <moritz_> which gives you the .perl output, the reference address (don't know if that's a good idea) and the type

[13:14] <moritz_> [1].perl won't tell you that it's an Array

[13:14] <moritz_> you have to *know* that

[13:15] *** cmarcelo joined
[13:15] <moritz_> and you can't assume that a newbie will, for stuff like Captures and Signatures and the like

[13:15] <ruoso_> but what's the problem of using whatever returned by WHAT?

[13:15] <ruoso_> I mean...

[13:15] <ruoso_> why does it need to be the "canonical" type?

[13:15] <moritz_> nothing, if that is always something that appears in the official type hierarchy

[13:16] <moritz_> it's pretty useless if it's something implementation specific

[13:16] <moritz_> implementation specific stuff should be hidden from the user

[13:17] <moritz_> and since something that matches \d+ is defined to be an Int, it may not return ImplementationSpecificTinyInt

[13:17] <ruoso_> I could agree that SomeLowlevelInt should stringify to 'Int'

[13:17] <ruoso_> but the return of the .WHAT need to be the actual type being used by that value...

[13:18] <moritz_> and if SomeLowlevelInt is limited to one byte, can you do my $var_of_same_type = 3.WHAT.new(257) ?

[13:18] <moritz_> if you can, I'm happy with that ;)

[13:18] <ruoso_> moritz_: if new($newvalue) is part of the Int API... yes, you can,...

[13:19] <moritz_> ok

[13:19] <moritz_> then I have no objections whatsoever

[13:20] <ruoso_> does TimToady have?

[13:22] *** ruoso left
[13:22] <moritz_> well, if the things returned from .WHAT *behaves* like the canonical thing, you don't see any difference, right?

[13:22] <ruoso_> btw.... (3.WHAT.new(257).WHAT === 3.WHAT) might return false

[13:24] <moritz_> as long as 3.WHAT.new(257).WHAT eqv 3.WHAT is true...

[13:24] <ruoso_> hmm...

[13:24] <ruoso_> that is not true...

[13:24] <ruoso_> ah.. wait

[13:24] <ruoso_> hmm...

[13:26] *** wolv joined
[13:26] *** wolv left
[13:26] *** Alias__ left
[13:26] <ruoso_> moritz_: that's a very hard question...

[13:27] <ruoso_> because you have two different types that "does" the same canonical type

[13:27] <moritz_> I'll retract my question ;)

[13:27] <ruoso_> moritz_: do you mean that it doesn't matter? 

[13:28] <moritz_> ruoso_: not for me at the moment

[13:28] <ruoso_> you still agree even if 3.WHAT.new(257).WHAT eqv 3.WHAT is false?

[13:28] <ruoso_> pugs: say Num ~~ Int

[13:28] <moritz_> if there's a sane way to compare the proto objects

[13:28] <p6eval> pugs: OUTPUT[␤]

[13:29] <ruoso_> moritz_: you should compare the.m against the canonical types..

[13:29] <ruoso_> and I think the 'eqv' is not the operator you want...

[13:30] <ruoso_> pugs: say Int ~~ Num

[13:30] <p6eval> pugs: OUTPUT[1␤]

[13:30] <ruoso_> pugs: say Int eqv Num

[13:30] <p6eval> pugs: OUTPUT[␤]

[13:32] <ruoso_> but one way or another... the limitations on the type instrospection of Perl 6 is a very important feature...

[13:33] <ruoso_> "Something is what it says it is"

[13:33] <ruoso_> and you check if that something is something by using .^does

[13:34] <moritz_> but what the user somtimes want to know is "do these two objects have the exact same interface?"

[13:34] <moritz_> the OO system should be able to answer that question, IMHO

[13:34] <ruoso_> alright... in that case... eqv on the prototype should do it

[13:34] <ruoso_> but it will return false on more cases then expected...

[13:35] <ruoso_> since it's too easy to do mixins and other things...

[13:35] <moritz_> yes, if stuff are 'but Tainted' or so

[13:36] <ruoso_> and I don't really see the point of asking if they have the "exact same interface"....

[13:36] <ruoso_> the question is "does it have *that* interface"?

[13:38] *** barney left
[13:38] <moritz_> the question is relevant when you want to know "if I can throw $x into that sub, can I also throw $y into it)? if the type declaration on $x isn't strict enough, comparing the interface/type might be the only way to answer that question

[13:40] <ruoso_> well... one could argue if the declaration isn't strict enough... you can't really do much inference...

[13:41] <ruoso_> but yes, eqv on the prototypes could compare the API

[13:41] <ruoso_> we could even have...

[13:42] <ruoso_> $x.WHAT > $y.WHAT, to see if $y has everything $x has...

[13:42] *** jferrero left
[13:42] <ruoso_> (> implies int, I know... but you see what I mean, right?)

[13:42] * moritz_ runs away screaming

[13:43] <moritz_> isn't that $y.WHAT ~~ $x.WHAT ?

[13:43] <ruoso_> no...

[13:43] <ruoso_> because ~~ will ask .^does

[13:43] <ruoso_> and if the type declaration isn't strict enough...

[13:43] <ruoso_> it won't

[13:44] <moritz_> so Type1 ~~ Type2  isn't generic "type conformance"?

[13:44] <ruoso_> yes, it is... but "type conformance" presumes "type declaration"

[13:45] <ruoso_> if the types are not declared... there isn't much you can do...

[13:46] <ruoso_> we could have a variant of .^can that receives a prototype and checks for the API instead of the type

[13:48] * ruoso_ just realises that there isn't a way to ask for a prototype in the signature...

[13:48] <moritz_> prototype in a signature? (/me is confused)

[13:49] <ruoso_> multi method can (Object $object, Undefined Object $prototype) { ... }

[13:49] <ruoso_> multi method can (Object $object, String $methodname) { ... }

[13:50] <ruoso_> multi method can (Object $object, Object $methodname) { (forces string context on the defined object) }

[13:50] <moritz_> if all else fails you can use subset types with where { ... }, which allows arbitrary comparisons

[13:51] <ruoso_> oh...

[13:51] <ruoso_> right

[13:51] <ruoso_> multi method can (Object $object, Object $methodname where { ! $methodname.defined } ) { ... }

[13:52] <ruoso_> multi method can (Object $object, Object $proto where { ! $proto.defined } ) { ... }

[13:52] <ruoso_> multi method can (Object $object, Object $methodname where { $methodname.defined } ) { ... }

[13:52] <ruoso_> the last two...

[13:52] <moritz_> or simply where !.defined

[13:53] <ruoso_> right... I think it's even an error to use the name inside, isn't it?

[13:53] <ruoso_> since that's a closure that receives the value on $_

[13:53] <moritz_> I think it's a closure with arity one

[13:54] <moritz_> so you could say stuff like where -> $a { $a.defined }

[13:54] <moritz_> or where { $^a.defined }

[13:54] <moritz_> but I'm not sure

[13:54] <ruoso_> it makes sense

[13:55] <ruoso_> TimToady: what do you think about having a .^can variant that receives a protoobject and compares if the current object implements all methods present in that protoobject?

[13:56] <ruoso_> that way, we would simply have... if $y.^can($x.WHAT)

[13:58] *** ruoso joined
[13:58] * ruoso back using irc over ssh... and closing the web irc client...

[13:59] *** ruoso_ left
[14:01] <ruoso> moritz_: are you happy with the $y.^can($x.WHAT) idea?

[14:02] <moritz_> dunno really, but no objects atm

[14:02] <moritz_> masak++ viklund++ "Christmas never felt that close"

[14:02] <masak> :)

[14:02] <masak> that's the feeling you get when developing november

[14:03] <ruoso> TimToady: is it ok for .WHAT to return something that stringifies to the canonical type but might be some other type?

[14:04] * ruoso being a very noisy guy today..

[14:07] *** kanru left
[14:10] * ruoso actually blocked by the postcircumfix:<( )> question... ;(

[14:25] *** Lorn joined
[14:32] *** ggoebel left
[14:34] *** kanru joined
[14:39] *** pmurias joined
[14:40] <ruoso> pmurias: hi

[14:40] <pmurias> ruoso: i seem to recall the invocant to methods is passed as the first positionals when methods are exposed as subroutines

[14:40] <pmurias> ruoso: hi

[14:40] <pmurias> ruoso: how was the hackathon?

[14:40] <ruoso> i'm on it yet...

[14:40] *** rdice joined
[14:40] <ruoso> until saturday

[14:40] <viklund> Juerd: I have now redirected wwww.november-wiki.org to 193.200.132.135, what's the next step?

[14:41] <moritz_> I guess you need a virtual host for that

[14:42] <pmurias> you mean you're still on it?

[14:42] <ruoso> pmurias: yes...

[14:43] <pmurias> is anyone interested in SMOP? or is it an general Perl 6 one?

[14:44] <ruoso> it's a general Perl 6 hackathon... but so far there isn't much qualified atendees, so it's basically me, myself, and the code ;)

[14:45] <masak> best kind of hackathon, really :)

[14:45] <moritz_> not really :/

[14:45] <masak> actually, it very much depends.

[14:46] <ruoso> I'd be happy to introduce the code to new people...

[14:47] <ruoso> pmurias: btw... aout the invocant... do you see what I mwan about the problems of having the capture to postcircumfix:<( )> as the actual capture to the code?

[14:47] <ruoso> s/aout/about/

[14:47] <ruoso> s/mwan/mean/

[14:48] <ruoso> and why it would be important to have it as the first positional argument instadd?

[14:50] <pmurias> i see, but i think postcircumfix:<( )> should stay the way it is methods may implement a call method or something

[14:54] <ruoso> but Method isa Code

[14:54] <ruoso> and in the end, it needs to get the correct capture

[14:55] <ruoso> and it needs to call .()

[14:56] <ruoso> unless method.call re-implements what's currently implemented in COde

[14:56] <ruoso> and that would be a shame

[14:57] <ruoso> although it will probably need to override it anyway to provide "self" closure...

[14:59] <pmurias> i can't find it in the log but i think methods take the none-Method invocant as their first positional if used as subroutines

[15:00] <ruoso> btw... I'm planning to implement self as a closure that returns the invocant and is declared in the scope of the method...

[15:00] <pmurias> $method.($invocant,$pos1,$pos2,....)

[15:00] <ruoso> pmurias: yes... but that's not the case here...

[15:01] <ruoso> pmurias: actually... you're confusing...

[15:01] <ruoso> it was the method dispatch fallback to subroutines that did that

[15:01] <ruoso> when you were calling a subroutine as a method it would do it

[15:01] <[particle]> which no longer happens

[15:01] <ruoso> exacly

[15:02] <ruoso> but anyway... the .() call needs to receive the method as the invocant... so we need to hide the actual capture as a positional argument of that capture

[15:02] <pmurias> [particle]: S12:1039

[15:02] <ruoso> so the invocant of the actual call can have a different type

[15:03] <ruoso> pmurias: I think that's just something that wasn't updated yet...

[15:03] <[particle]> yep, that should be updated. specbug

[15:03] <ruoso> but the whole "moving things to Any" was supposed to get rid of the sub fallback

[15:04] <ruoso> but anyway... 

[15:04] <ruoso> the thing is...

[15:05] *** zamolxes_ left
[15:05] <ruoso> the signature for .() should be ($code: $actualcapture)

[15:05] <ruoso> instaed of (|$capture)

[15:05] <ruoso> so the actualcapture can have another invocant defined

[15:05] <ruoso> which , in method, will be the actual object 

[15:06] <ruoso> since the Metaclass will need to call .() on the method after it finds which method to call

[15:07] <pmurias> &foo(42) would be really &foo.postcircumfix:<( )>(:(42))?

[15:08] <masak> pmurias: how would that help you?

[15:08] <ruoso>  &foo.postcircumfix:<( )>(\(42)) actually

[15:08] <masak> then you just have another pair of unexpanded parentheses

[15:08] *** viklund left
[15:09] <ruoso> and $foo.bar(42), in the end will mean &bar.postcircumfix:<( )>(\($foo: 42))

[15:10] <pmurias> masak: we need a way to pass an invocant to a method and ruoso proposes that postcircumfix:<( )> should take a capture as the only positional

[15:10] <ruoso> pmurias: I think masak was referring to your use of : instead of \ to create the inner capture

[15:11] <masak> pmurias: ok, so you actually don't run into infinite regress?

[15:11] <ruoso> masak: no, because we have low-level objects that cut the loop

[15:11] <ruoso> but they behave like highl-level objects

[15:11] <masak> ruoso: no, I was referring to the fact that one pair of parentheses was expanded to a postcircumfix and another pair

[15:11] <masak> ruoso: ah, ok

[15:13] <ruoso> pmurias: in fact, I don't think it's actually possible to do it other way

[15:13] <pmurias> ruoso: we can pass the real invocant (that is $foo in $foo.bar(42)) as a positional

[15:14] <ruoso> but then we need to modify the capture... encapsulating it is easier...

[15:14] <ruoso> we actually would need to modifiy the capture twice

[15:14] *** sri_work joined
[15:16] <ruoso> in SMOP, the capture is even readonly

[15:16] <ruoso> lunch &

[15:17] <pmurias> why are you oposed to having the capture as first positional variant as CALL?

[15:17] <ruoso> well... because Method isa Code

[15:18] <ruoso> it is supposed to use the same api

[15:18] *** ggoebel joined
[15:19] <ruoso> and even subroutines may declare a signature with an invocant

[15:19] <pmurias> no they can't

[15:20] *** Exodist joined
[15:20] <ruoso> pugs: sub a ( $foo: $bar) { say $foo }; my $c = \("a", 1); a(|$c);

[15:20] <p6eval> pugs: OUTPUT[*** Missing invocant parameters in '&a': 0 received, 1 missing␤    at /tmp/xBCulDQXs5 line 1, column 54-60␤]

[15:20] <ruoso> pugs: sub a ( $foo: $bar) { say $foo }; my $c = \("a": 1); a(|$c);

[15:20] <p6eval> pugs: OUTPUT[*** No compatible multi variant found: "&a"␤    at /tmp/xT3i7d2JFt line 1, column 54-60␤]

[15:21] * ruoso really lunch &

[15:21] *** jhorwitz joined
[15:28] *** kolibrie left
[15:30] *** hercynium joined
[15:39] *** ruoso left
[15:44] *** jan__ left
[16:04] *** zamolxes joined
[16:06] *** ruoso joined
[16:08] *** jan__ joined
[16:11] <ruoso> pmurias: re: invocant in subroutine signatures -- is it actually in the spec? or is it just reasonable thinking

[16:11] *** sri_work_ joined
[16:12] *** sri_work left
[16:13] <pmurias> ruoso: it's (vague) irc recollection

[16:17] *** eternaleye_ joined
[16:22] *** eternaleye left
[16:36] <ruoso> alright... I'll implement a method CALL on both Code and Method that receives the capture as the positional argument

[16:36] <ruoso> then we decide if postcircumfix:<( )> is changed to be the same as this

[16:39] *** eternaleye_ left
[16:40] *** eternaleye_ joined
[16:41] <ruoso> or maybe I should change postcircumfix as an exercise

[16:41] <ruoso> of the concept

[16:43] <ruoso> pmurias: is there support for the capture construct in m0ld already?

[16:43] *** xinming joined
[16:55] *** xinming_ left
[17:10] *** zamolxes left
[17:22] <pmurias> ruoso: sorry was afk

[17:22] <pmurias> ruoso: you can call Capture.new

[17:23] <ruoso> Capture.new returns an empty capyture

[17:23] <ruoso> but I used the SMOP__S1P__Capturize... that returns the capture it receives

[17:24] <ruoso> it can't be used with captures that have an invocant set

[17:24] <ruoso> since the invocant is the Capturize RI

[17:24] <moritz_> an empty Capture is pretty useless, since Captures are immutable

[17:24] <moritz_> so you always only get \() with that

[17:25] <ruoso> \() is not that unusual

[17:25] <pmurias> ruoso: we can have a different constructor Capture.other_constructor($invocant,...)

[17:25] <ruoso> pmurias: I was talking about the current capture.new in smop

[17:26] <ruoso> capture.new could be implemented...

[17:26] *** masak left
[17:27] * ruoso just realised that his new connection has a transparent proxy that doesn't work wiht svn

[17:27] <pmurias> i hesitate to extend m0ld with things that are not strictly nessesary

[17:29] <pmurias> ruoso: any way to circumvent the proxy?

[17:31] <ruoso> not that I'm aware of...

[17:32] *** fridim_ joined
[17:34] * ruoso trying to get the event organizers to remove the proxy

[17:36] *** pmurias left
[17:41] *** justatheory joined
[17:44] *** justatheory left
[17:44] *** justatheory joined
[17:51] <pugs_svn> r21995 | ruoso++ | [smop] experimenting the alternative signature for postcircumfix:<( )>

[17:52] *** aindilis` left
[17:52] *** aindilis` joined
[17:55] *** sitaram joined
[18:13] * TimToady aims his eyeballs at the puddles of brane on the floor, but there's nothing left to think about the puddles with...

[18:13] *** zamolxes joined
[18:14] *** sitaram left
[18:15] *** pmurias joined
[18:16] <pmurias> TimToady: how do you think should the problem of passing the invocant to Methods be solved?

[18:17] *** ruoso left
[18:18] * TimToady stares at puddles of brane

[18:19] *** ruoso_ joined
[18:19] <TimToady> the migraine doesn't help

[18:19] <ruoso_> gah... other connection issue... back to web chat

[18:22] * ruoso_ wonders if that means that it's not a good day to pester TimToady with boring questions...

[18:23] *** [particle] left
[18:23] * TimToady is fine with boring questions, except to the extent that ruoso thinks brain pretzels are boring...

[18:24] <ruoso_> heh

[18:27] *** ruoso_ left
[18:28] <pmurias> TimToady: do we still have method to subroutine fallback?

[18:29] <TimToady> no

[18:29] <TimToady> we're trying to keep the two dispatchers very distinct these days

[18:30] <TimToady> subject to pragmatic control, as always

[18:30] <TimToady> but $foo.bar means something rather different from bar($foo)

[18:31] <TimToady> if $foo contains a "foreign" object, it call .bar in foreign land

[18:31] <TimToady> but bar() dispatches to bar in Perl land

[18:32] <TimToady> this is why infix:<eq> is a multi, not a method

[18:32] <pugs_svn> r21996 | moritz++ | [t] more s/system/run/

[18:32] <TimToady> otherwise we can't rely on coercive semantics for eq, ==, etc

[18:33] <TimToady> and to the extend we wish to use the same definition for both a method and a multi, we encourage use of "is export"

[18:33] <TimToady> which basically just deletes the : from the signature

[18:34] <TimToady> but that implies that methods know how to receive their invocant as the first parameter if invoked as a sub

[18:35] <TimToady> unless we use some kind of wrapper, which would suck

[18:36] <TimToady> so probably there's some way to construct a Capture where the invocant is really the first positional parameter

[18:36] <pugs_svn> r21997 | moritz++ | [t] more rewrite of try { ... }; ok($!) to dies_ok

[18:37] *** [particle] joined
[18:38] <TimToady> but if smop demonstrates another way to think about it, I'll try to think about it

[18:40] <TimToady> in any case, once you've got a ref to a Routine, there has to be a consistent way to call it, and that's probably the same way that the single-dispatcher calls individual methods as if they were subs

[18:40] <TimToady> shower &

[18:41] *** araujo joined
[18:42] <pugs_svn> r21998 | moritz++ | [t/examples] some more fixes caught by STD.pm

[18:44] <pugs_svn> r21999 | moritz++ | [t/examples] s/system/run/

[18:47] <pugs_svn> r22000 | moritz++ | [t] more try{...} fixes

[18:47] *** luqui joined
[18:51] <pugs_svn> r22001 | moritz++ | [t/oo] more s/system/run/ and try{...} fixes

[18:51] *** StephenPollei left
[19:09] *** apeiron joined
[19:12] *** Claud joined
[19:13] *** rdice left
[19:14] *** Claud left
[19:15] *** [particle] left
[19:15] *** [particle] joined
[19:28] <pmurias> TimToady: i think S12:1030 needs the fallback edited out then

[19:30] <pugs_svn> r22002 | moritz++ | [STD] added builtins exists and delete

[19:34] *** eternaleye joined
[19:39] <pugs_svn> r22003 | moritz++ | [t/spec] remove usage of try as a function

[19:45] <pugs_svn> r22004 | moritz++ | [t/spec] remove bogus tests

[19:47] *** eternaleye_ left
[19:57] *** lisppaste3 left
[19:58] *** lisppaste3 joined
[19:58] <speckbot> r14576 | larry++ | remove failover from methods to subs

[20:03] *** larsen_ left
[20:12] <pmurias> TimToady: is $a.infix:<*>($b) equivalent to $a * $b

[20:12] <moritz_> I don't think you can have infix operators as methods

[20:13] <pmurias> S12:321

[20:13] <pmurias> S12:327 actually

[20:13] * wolverian screams something about multimethods and breaks down

[20:14] <moritz_> that looks... hairy

[20:14] * pmurias is trying to clarify possible speckbugs before we implement them

[20:15] *** luqui left
[20:18] *** rindolf joined
[20:19] *** wknight8111 joined
[20:20] *** dolmen joined
[20:21] <TimToady> it's possible that explicit use of syntactic categories forces use of the appropriate dispatcher

[20:21] *** StephenPollei joined
[20:21] *** tulcod joined
[20:21] <tulcod> hey. when can i possibly expect perl 6 to be released? will it take a month, 6 months, a year, two years or four years?

[20:22] <[particle]> tulcod: yes.

[20:22] <tulcod> :)

[20:22] <moritz_> ;-)

[20:22] <moritz_> my expectation is about 2 years

[20:22] <tulcod> no but seriously. how far are the guys?

[20:22] <[particle]> we're done with the first 80%, and well into the second 80%.

[20:22] <moritz_> [particle]: I wanted to quote that too

[20:22] <Auzon> Is there a third 80%?

[20:23] <[particle]> we hope not, auzon.

[20:23] <moritz_> [particle]: you're too fast ;)

[20:23] <tulcod> okay then. and i guess the implementations will be ready by then too?

[20:23] <moritz_> I don't think it's realistic to expect the specs to be finished without an implementation

[20:23] <[particle]> tulcod: there are several implementations that are useable for trivial things, and some that are useable for less trivial things

[20:24] <tulcod> moritz_, [particle]: heh, okay :)

[20:24] <[particle]> recently there has been a wiki written in rakudo (a perl 6 implementation running on parrot)

[20:24] <tulcod> [particle]: yeah, i heard about rakudo. a wiki sounds crazy

[20:25] <tulcod> proof of concept, "look guys, our perl interpreter really does work!"

[20:25] <tulcod> ?

[20:25] <moritz_> yes

[20:25] <tulcod> overkill :P

[20:25] <moritz_> and "optimized for fun" ;)

[20:25] <[particle]> just yesterday rakudo's test suite was sped up tremendously

[20:25] <moritz_> why overkill?

[20:25] <[particle]> from 8m to 2m40s

[20:26] <tulcod> moritz_: for me, hello world would have sufficed to show that their interpreter works... but i guess that's just my fault then ;)

[20:26] <moritz_> rakudo: say "hello, world"

[20:26] <p6eval> rakudo 29834: OUTPUT[hello, world␤]

[20:26] <[particle]> tulcod: rakudo passes 2200 tests from the official perl 6 test suite

[20:26] <[particle]> pugs passes thousands more

[20:26] <moritz_> tulcod: hello world is too trivial to impress anybody

[20:26] <tulcod> [particle]: ALL 2200 tests? or are there more?

[20:26] <moritz_> there are about 20k tests

[20:27] <tulcod> haha

[20:27] <moritz_> and more to be written

[20:27] <[particle]> there are currently ~20,000...this time moritz is too fast :)

[20:27] <tulcod> well, still not bad, for a language which doesn't even have a real definition yet :P

[20:27] <Auzon> tulcod: http://rakudo.de has a nice graph of the test passing progress

[20:27] <lambdabot> Title: Rakudo - A Perl 6 Compiler

[20:27] <tulcod> Auzon: cool, thx

[20:28] <tulcod> hm. parrot is a well-defined and "standardized" language rgiht now?

[20:28] <TimToady> the definition is most certainly real.  It's just that it's also incomplete, and wrong.  :)

[20:28] <moritz_> so far I haven't found a good other use for that domain ;)

[20:28] <moritz_> tulcod: parrot is a virtual machine, not a language

[20:28] <[particle]> tulcod: http://spec.pugscode.org/ has the perl 6 "definition", such as it is

[20:28] <lambdabot> Title: Official Perl 6 Documentation

[20:28] <tulcod> moritz_: a virtual machine based on a parrot language, right?

[20:29] <tulcod> moritz_: like, it's not just an x86 vm

[20:29] <moritz_> tulcod: no, a platform independent vm

[20:29] <[particle]> parrot's written in c89

[20:29] <tulcod> moritz_: yes, but the stuff that runs ON it is written in, or at least compiled to, "parrot" language right?

[20:30] <[particle]> the language is called pir

[20:30] <moritz_> tulcod: parrot runs a byte code, called PBC. There are also two assembler languages that parrot understands

[20:30] <tulcod> exactly :)

[20:30] <moritz_> tulcod: so there's not "one" parrot language, but more of them

[20:30] <tulcod> okay then

[20:30] <[particle]> the other language is pasm, which is human-readable bytecode

[20:30] <tulcod> spasm?

[20:31] <Auzon> Parrot Assembler, correct?

[20:31] <moritz_> parrot assembler

[20:32] <tulcod> so... do those languages have a complete definition now, then?

[20:32] <tulcod> or are they still WIP too?

[20:32] <moritz_> they are work in progress, but still very usable

[20:32] <[particle]> they are basically complete

[20:32] <[particle]> parrot 0.7.0 was released tuesday

[20:36] <pmurias> is the instruction set finalised?

[20:36] <moritz_> no

[20:37] <[particle]> mainly finalized

[20:37] <[particle]> all the design documents are done

[20:38] <[particle]> but the implementation of some is still incomplete

[20:38] <[particle]> implementation may drive design changes, of course

[20:39] <[particle]> all the *funded* design documents, which includes the nine major subsystems

[20:39] <speckbot> r14577 | larry++ | Clarification that categories change the choice of dispatcher on method names

[20:39] * moritz_ counts 10 design documents in docs/pdds/draft/

[20:41] <[particle]> looks like only the nci document might impact the instruction set

[20:41] <TimToady> tulcod: Google has demonstraed via its "eternal beta" approach that being a WIP and being useful are not mutually exclusive  :)

[20:41] <tulcod> TimToady: that was not what i was doubting, but thanks for your attention :)

[20:42] <[particle]> already parts of perl 6 are written in perl 6

[20:44] <TimToady> okay, but I just get the feeling that the definition of these things may never be "complete" in the sense that you're asking it...what do you mean by "complete"?

[20:44] *** eternaleye left
[20:45] <TimToady> a language designed to evolve can never in a sense be complete

[20:45] <TimToady> it can only be "good enough for now"

[20:46] <TimToady> and we freely admit that Perl 6 ain't good enough for now  :)

[20:47] <TimToady> (sorry for the rant--I'm just allergic to either/or thinking these days...:)

[20:47] <tulcod> TimToady: as am i. but at some point, developers must be able to stabilize stuff

[20:48] <tulcod> TimToady: and you can only make an app stable if you have a definition of what it should do. and if that definition changes daily....

[20:48] <[particle]> the definition of perl 6 changes infrequently as of late

[20:48] <[particle]> however, it's in a state of continuous refinement

[20:48] <[particle]> and this will never stop

[20:49] <TimToady> most apps would never hit the corner cases where we're doing the simplifications these days

[20:49] <TimToady> and most of the changes are driven by the desires of implementors

[20:50] *** eternaleye joined
[20:53] <TimToady> commuting &

[21:06] <pmurias> tulcod: you have to implement an app to see what it does ;)

[21:06] <tulcod> pmurias: ah, tricky ;)

[21:07] <tulcod> where's the program which generates a program which behaves exactly as defined in a human-readable language definition?

[21:07] <tulcod> metaprogramming level 2

[21:07] <Auzon> I think some of them are connected to this room via IRC.

[21:07] <jhorwitz> did he just describe PCT?  ;-)

[21:08] <moritz_> an accurate human language description would be much longer than the implementation in any sany programming (unless for a few mathematical problems and the like)

[21:08] <[particle]> sany := sane + zany

[21:08] <[particle]> or in perl 6, sane|zany

[21:09] <tulcod> hehe

[21:09] <moritz_> no, sane&zany

[21:09] <tulcod> there is more than one way to do it ;)

[21:22] *** eternaleye left
[21:24] *** donaldh joined
[21:35] *** tulcod left
[21:39] *** pmurias left
[21:51] *** Limbic_Region joined
[21:52] *** hercynium left
[22:33] *** jhorwitz left
[22:42] *** BinGOs left
[22:47] *** armagad joined
[22:47] *** armagad left
[22:57] <japhb> TimToady: ping

[22:58] <japhb> Or heck, I'll just ask the question: Has the license of Perl 5 ever changed since the first Perl 5 release?  Are you currently planning to keep the Perl 5 license unchanged for the rest of its days?

[23:03] *** donaldh left
[23:09] *** cmarcelo left
[23:09] *** eternaleye joined
[23:11] *** Lorn left
[23:20] <Limbic_Region> japhb - presumably you have read http://perlbuzz.com/2008/04/the-problem-with-same-terms-as-perl-licensing.html which points to http://use.perl.org/~Shlomi+Fish/journal/36050 ?

[23:20] <lambdabot> Title: The problem with "same terms as Perl" licensing - Perl Buzz, http://tinyurl.com/5hdojz

[23:22] *** krunen left
[23:22] *** Exodist left
[23:22] *** kanru left
[23:22] *** drbean left
[23:22] *** Guest16015 left
[23:22] *** kane_ left
[23:22] *** idemal left
[23:22] *** yves left
[23:22] *** broquaint left
[23:22] *** cls_bsd left
[23:22] *** wknight8111 left
[23:22] *** elmex left
[23:22] *** r0bby left
[23:22] *** felipe left
[23:22] *** agentzh left
[23:22] *** yath_ left
[23:22] *** bloonix left
[23:22] *** pengrate_ left
[23:22] *** Gothmog_ left
[23:22] *** Juerd left
[23:22] *** frobnitz left
[23:22] *** japhb left
[23:22] *** perlbot left
[23:22] *** jrockway left
[23:22] *** ingy left
[23:22] *** pochi left
[23:22] *** funktio left
[23:22] *** wknight8111 joined
[23:22] *** Exodist joined
[23:22] *** kanru joined
[23:22] *** elmex joined
[23:22] *** drbean joined
[23:22] *** r0bby joined
[23:22] *** Guest16015 joined
[23:22] *** felipe joined
[23:22] *** agentzh joined
[23:22] *** krunen joined
[23:22] *** ingy joined
[23:22] *** broquaint joined
[23:22] *** yves joined
[23:22] *** funktio joined
[23:22] *** pochi joined
[23:22] *** idemal joined
[23:22] *** cls_bsd joined
[23:22] *** kane_ joined
[23:22] *** Gothmog_ joined
[23:22] *** frobnitz joined
[23:22] *** jrockway joined
[23:22] *** japhb joined
[23:22] *** pengrate_ joined
[23:22] *** perlbot joined
[23:22] *** bloonix joined
[23:22] *** Juerd joined
[23:22] *** yath_ joined
[23:23] <Limbic_Region> hrm - lost half the world

[23:23] * Limbic_Region will repeat himself just in case

[23:23] <Limbic_Region> japhb - presumably you have read http://perlbuzz.com/2008/04/the-problem-with-same-terms-as-perl-licensing.html which points to http://use.perl.org/~Shlomi+Fish/journal/36050 ?

[23:23] <lambdabot> Title: The problem with "same terms as Perl" licensing - Perl Buzz, http://tinyurl.com/5hdojz

[23:23] *** aindilis` is now known as aindilis

[23:29] <japhb> Limbic_Region: yes, some time ago.  I don't entirely agree with his analysis, but in any case, I specifically wanted to know about Perl *5*'s past and future.

[23:29] *** cotto_w0rk is now known as cotto_work

[23:30] <japhb> When people complain about ambiguity, there's "real ambiguity" and then there's "theoretical ambiguity".

[23:34] *** Exodist left
[23:38] *** rindolf left
[23:54] *** Jedai left
[23:56] *** [particle]1 joined
