[00:21] *** scrottie joined
[00:23] *** xuser joined
[01:07] *** cathyal left
[01:15] *** explorer__ left
[01:29] *** gnuvince_ joined
[01:29] <gnuvince_> Does anybody know what audreyt++ used to make the Imaginary Perl 6 Timeline?

[01:31] <TimToady> borrowed the idea from Haskell culture; don't know what tool though

[01:32] <gnuvince_> I want to make a fake graph, and OpenOffice.org gives a "meh" result

[01:32] <ruoso> gnuvince_, inkscape is handy to do that kind of stuff

[01:33] <gnuvince_> ruoso: thank you, I'll download it and check it out.

[01:33] * ruoso zZzZzZ &

[01:42] *** sri_work_ joined
[01:47] *** wknight8111 left
[01:49] *** sri_work left
[02:01] *** jrockway left
[02:01] *** jrockway joined
[02:04] *** justatheory left
[02:07] *** sri_work_ left
[02:12] *** alanhaggai joined
[02:26] *** kst``` left
[02:26] *** kst``` joined
[02:34] *** xiaoyafeng joined
[02:57] *** [particle] joined
[03:02] *** elmex_ joined
[03:04] *** wayland76 joined
[03:06] *** jrockway left
[03:07] *** jrockway joined
[03:08] *** rdice left
[03:14] *** [particle]1 left
[03:17] *** gnuvince_ left
[03:18] *** elmex left
[03:18] *** elmex_ is now known as elmex

[04:00] *** alanhaggai_ joined
[04:00] *** alanhaggai left
[04:36] *** Bzek joined
[04:48] *** alanhaggai_ left
[04:50] *** eternaleye joined
[05:08] *** alanhaggai joined
[05:08] *** kst``` left
[05:09] *** kst``` joined
[05:24] *** meppl joined
[05:25] <meppl> good morning

[05:33] *** alanhaggai_ joined
[05:33] *** alanhaggai left
[05:45] *** alanhaggai_ is now known as alanhaggai

[05:59] *** Psyche^ joined
[06:12] *** Patterner left
[06:12] *** Psyche^ is now known as Patterner

[06:29] *** ashizawa joined
[06:51] *** jferrero joined
[06:53] *** baest_ left
[07:14] *** iblechbot joined
[07:14] <pugs_svn> r22616 | particle++ | [t] unfudge two more passing 'is export()' tests for rakudo now that taglists are supported

[07:15] *** cosimo joined
[07:16] * moritz_ wonders why autounfudge didn't catch this one

[07:19] *** viklund joined
[07:20] <[particle]> i just added support to rakudo for it

[07:20] <[particle]> looks like rakudo commit bot isn't worknig

[07:23] <moritz_> time to fix that.

[07:23] *** rakudo_svn left
[07:23] <pugs_svn> r22617 | particle++ | [rakudo] add 9 more 'is export()' tests for custom tagsets

[07:23] <moritz_> svn: OPTIONS of 'https://svn.perl.org/parrot/trunk/languages/perl6': could not connect to server (https://svn.perl.org)

[07:23] *** rakudo_svn joined
[07:24] <[particle]> i'm fabulously happy 'is export()' works now

[07:24] *** speckbot left
[07:24] <moritz_> indeed

[07:24] <moritz_> [particle]++

[07:24] <[particle]> now i can move on to importing!

[07:24] *** speckbot joined
[07:25] <[particle]> those tests could use better smartlinks

[07:26] <[particle]> otherwise, i think they're good... oh, no, i still need to support :MANDATORY

[07:26] <[particle]> i'll do that tomorrow, as i start work in < 6 hours

[07:26] <[particle]> bed &

[07:26] <moritz_> good night

[07:30] *** zamolxes left
[07:31] <moritz_> the rakudo_svn bot is a having a network problem, no connection to svn.perl.org

[07:33] *** eternaleye left
[07:36] <pugs_svn> r22618 | moritz++ | [t/spec] unfudge three passing TODO tests

[07:39] *** xiaoyafeng left
[07:58] *** PZt left
[08:01] *** kst``` left
[08:02] *** kst``` joined
[08:14] *** pjcj left
[08:15] *** pjcj joined
[08:16] *** schmalbe joined
[08:28] *** meppl left
[08:30] *** smtms left
[08:35] <abz_> hi all

[08:43] *** pjcj left
[08:47] *** bacek joined
[08:53] *** tomyan joined
[08:56] *** pmurias joined
[09:11] <pmurias> ruoso: what's wrong with the previous way of calculating the new array size?

[09:12] *** donaldh joined
[09:17] *** icwiener joined
[09:19] <pugs_svn> r22619 | pmurias++ | [smop] added Array.push

[09:24] <ruoso> pmurias, it was mixing number of elements with size in bytes.... 

[09:24] <ruoso> pmurias, then I just made the dumb fix... but I left the code there so someone smarter could have it correctly fixed ;)

[09:30] <pmurias> ruoso: array size is in elements

[09:37] *** agentzh left
[09:40] *** schmalbe left
[09:41] *** agentzh joined
[09:42] <pmurias> ruoso: any other blockage other than push?

[09:42] <pugs_svn> r22620 | pmurias++ | [smop] added test for unshift, switched back to amortized allocation (fixed a bug in it)

[09:43] *** agentzh left
[09:46] *** PZt joined
[09:47] *** agentzh joined
[10:02] *** Maghnus left
[10:03] *** Maghnus joined
[10:15] *** ejs_ joined
[10:17] *** ruoso left
[10:17] *** pedrob joined
[10:34] *** bacek left
[10:54] *** spx2 left
[10:57] *** kst``` left
[10:58] *** kst``` joined
[11:00] *** spx2 joined
[11:10] *** pedrob left
[11:16] <pugs_svn> r22621 | pmurias++ | [mildew] generates syntacticly correct m0ld for t/pure_prototype_how.p6, lacks runtime support to run it

[11:16] *** pmurias left
[11:29] *** xiaoyafeng joined
[11:37] *** sri_work joined
[11:39] *** alester joined
[11:43] *** sri_work left
[11:43] *** speckbot left
[11:43] *** rakudo_svn left
[11:43] *** abz_ left
[11:43] *** spinclad left
[11:43] *** bjorn` left
[11:43] *** jfredett left
[11:43] *** idemal left
[11:43] *** integral left
[11:43] *** Tene left
[11:43] *** cj left
[11:43] *** SamB left
[11:43] *** tcliou left
[11:43] *** xiaoyafeng left
[11:43] *** Patterner left
[11:43] *** Bzek left
[11:43] *** xuser left
[11:43] *** pmurias_ left
[11:43] *** REPLeffect left
[11:43] *** jjore left
[11:43] *** mtve left
[11:43] *** PerlJam left
[11:43] *** alester left
[11:43] *** PZt left
[11:43] *** viklund left
[11:43] *** iblechbot left
[11:43] *** scrottie left
[11:43] *** jhorwitz left
[11:43] *** araujo left
[11:43] *** TimToady left
[11:43] *** Guest16015 left
[11:43] *** kolibrie left
[11:43] *** TreyHarris left
[11:43] *** moritz_ left
[11:43] *** meteorja1 left
[11:43] *** hcchien left
[11:43] *** orafu left
[11:43] *** ilbot2 left
[11:43] *** preflex left
[11:43] *** buubot left
[11:43] *** sirhc left
[11:43] *** falesca left
[11:43] *** IRSeekBot left
[11:43] *** mj41 left
[11:43] *** drbean left
[11:43] *** TimToady joined
[11:43] *** alester joined
[11:43] *** sri_work joined
[11:43] *** xiaoyafeng joined
[11:43] *** PZt joined
[11:43] *** speckbot joined
[11:43] *** rakudo_svn joined
[11:43] *** viklund joined
[11:43] *** iblechbot joined
[11:43] *** Patterner joined
[11:43] *** Bzek joined
[11:43] *** xuser joined
[11:43] *** scrottie joined
[11:43] *** abz_ joined
[11:43] *** pmurias_ joined
[11:43] *** jhorwitz joined
[11:43] *** araujo joined
[11:43] *** orafu joined
[11:43] *** tcliou joined
[11:43] *** bjorn` joined
[11:43] *** jfredett joined
[11:43] *** sirhc joined
[11:43] *** TreyHarris joined
[11:43] *** drbean joined
[11:43] *** mj41 joined
[11:43] *** REPLeffect joined
[11:43] *** PerlJam joined
[11:43] *** idemal joined
[11:43] *** Guest16015 joined
[11:43] *** spinclad joined
[11:43] *** meteorja1 joined
[11:43] *** moritz_ joined
[11:43] *** Tene joined
[11:43] *** cj joined
[11:43] *** ilbot2 joined
[11:43] *** IRSeekBot joined
[11:43] *** buubot joined
[11:43] *** falesca joined
[11:43] *** kolibrie joined
[11:43] *** preflex joined
[11:43] *** hcchien joined
[11:43] *** mtve joined
[11:43] *** SamB joined
[11:43] *** integral joined
[11:43] *** jjore joined
[11:43] *** irc.freenode.net sets mode: +o TimToady

[11:46] *** wayland76 left
[11:54] *** iblechbot left
[11:55] *** icwiener left
[12:00] *** Maghnus left
[12:00] *** tomyan left
[12:00] *** ashizawa left
[12:00] *** alanhaggai left
[12:00] *** [particle] left
[12:00] *** kanru left
[12:00] *** ting left
[12:00] *** clkao left
[12:00] *** smg left
[12:00] *** diakopter left
[12:00] *** allbery_b left
[12:00] *** lisppaste3 left
[12:00] *** kst``` left
[12:00] *** literal left
[12:00] *** Torment left
[12:00] *** _Jedai_ left
[12:00] *** cxreg left
[12:00] *** bennymack left
[12:00] *** gantrixx left
[12:00] *** avar left
[12:00] *** jiing_ left
[12:00] *** c1sung left
[12:00] *** donaldh left
[12:01] *** Guest70230 left
[12:01] *** japhb left
[12:01] *** yves left
[12:01] *** Caelum left
[12:01] *** simcop2387 left
[12:01] *** cookys left
[12:01] *** audreyt left
[12:01] *** jiing left
[12:01] *** pasteling left
[12:01] *** c9s left
[12:01] *** kst``` joined
[12:01] *** Maghnus joined
[12:01] *** donaldh joined
[12:01] *** tomyan joined
[12:01] *** ashizawa joined
[12:01] *** alanhaggai joined
[12:01] *** [particle] joined
[12:01] *** literal joined
[12:01] *** Torment joined
[12:01] *** _Jedai_ joined
[12:01] *** kanru joined
[12:01] *** cookys joined
[12:01] *** simcop2387 joined
[12:01] *** gantrixx joined
[12:01] *** smg joined
[12:01] *** lisppaste3 joined
[12:01] *** c9s joined
[12:01] *** Caelum joined
[12:01] *** c1sung joined
[12:01] *** diakopter joined
[12:01] *** cxreg joined
[12:01] *** jiing_ joined
[12:01] *** avar joined
[12:01] *** allbery_b joined
[12:01] *** ting joined
[12:01] *** bennymack joined
[12:01] *** clkao joined
[12:01] *** audreyt joined
[12:01] *** yves joined
[12:01] *** japhb joined
[12:01] *** jiing joined
[12:01] *** Guest70230 joined
[12:01] *** pasteling joined
[12:09] *** alester left
[12:22] *** smtms joined
[12:38] *** iblechbot joined
[12:43] *** alester joined
[12:46] *** kst``` left
[12:47] *** ashizawa left
[12:58] *** alester left
[12:59] *** zamolxes joined
[13:02] * jferrero is away: Ocupado... ahora vuelvo...

[13:13] *** ejs_ left
[13:20] *** donaldh left
[13:38] *** kst``` joined
[13:59] *** pedrob joined
[14:04] *** adc_Penner joined
[14:04] <[particle]> TimToady: the :MANDATORY tagset is mentioned only once in S11, in an example. are routines marked with :MANDATORY also injected into :DEFAULT? i suspect so, and am coding that in now, but it's a bit ambiguous since there's no other mention.

[14:05] *** TJCRI joined
[14:05] <[particle]> and there's nothing about how :MANDATORY should be respected during importation.

[14:07] <[particle]> sorry, i suspect *not*. that is, :MANDATORY ends up in :ALL but not :DEFAULT.

[14:09] <pugs_svn> r22622 | particle++ | [t] add tests for :MANDATORY tagset

[14:09] <TimToady> the lists are independent, so where you put which names depends on the algorithm

[14:10] <TimToady> if you always just shove :MANDATORY at the front of the import tags, then whatever is there need not be anywhere else

[14:10] <[particle]> the lists are dependent except for :ALL i assume

[14:11] *** spx2 left
[14:11] *** spx2 joined
[14:11] <TimToady> so even if they import :ALL, if :MANDATORY is before that, those don't have to be in :ALL

[14:11] <TimToady> that being said

[14:11] <TimToady> it would be good for :ALL to actually document that it has all of them

[14:11] <[particle]> yes, that's the way i've implemented it

[14:12] <TimToady> so in the case of :ALL you don't need to do :MANDATORY stuffing

[14:12] <TimToady> doubtless there are various fancy ways to do set theory and avoid trying to make duplicate links

[14:13] <TimToady> but brute force is probably not terribly slow

[14:13] <[particle]> my take is everything ends up in :ALL and the other tagsets you specified, if any

[14:13] <TimToady> plus :MANDATORY stuffing if you don

[14:13] <TimToady> don't say :ALL

[14:14] <TimToady> or are you putting those everywhere

[14:14] <TimToady> ?

[14:14] <TimToady> that works too, I guess

[14:14] <[particle]> :MANDATORY only goes into ::MANDATORY and ::ALL

[14:14] <[particle]> s/only//

[14:15] <TimToady> then when you say :FOO how does :MANDATORY come in?

[14:15] <[particle]> it doesn't

[14:15] <TimToady> it's supposed to

[14:15] <TimToady> that's why it's :MANDATORY

[14:15] <[particle]> sub baz is export(:MANDATORY)       {...}  #  (always exported) 

[14:15] <[particle]> that's the only mention

[14:16] <TimToady> which means it has to get linked alwasy, even if they say use Module :FOO

[14:16] *** Khisanth left
[14:16] <[particle]> yes, but that's import, not export.

[14:16] <[particle]> and that's where i have questions.

[14:16] <[particle]> use Foo; imports ::MANDATORY and ::DEFAULT

[14:17] <TimToady> to the first approximation, it just picks the subpackage and binds all the names it finds there

[14:17] <TimToady> yes

[14:17] <[particle]> the question is, can import be overridden

[14:17] <TimToady> by whom?

[14:18] <[particle]> the user, by specifying an IMPORT sub/method

[14:18] <TimToady> as in Perl 5, just write your own bindings

[14:19] <TimToady> only with := instead of typeglobs

[14:19] <TimToady> but then you probably don't want to say "use"

[14:19] <[particle]> just wondering if custom import routines need to respect :MANDATORY exporting

[14:19] <[particle]> or if that's builtin to use/require

[14:19] <[particle]> seems like it's builtin, and that works fine for me

[14:20] <TimToady> custom routines can do whatever they like

[14:20] <[particle]> okie, fine. time to update use/require!

[14:20] <[particle]> thanks.

[14:20] <TimToady> but the reason for using mandatory is probably that it's a language-bending module, and if you don't import the macro, you don't get to access it except as a sub

[14:22] <[particle]> right. that's fine for now, and we're a while away from macro support so i don't need to worry about it

[14:22] <[particle]> (yet).

[14:23] <[particle]> from my read on exporting, any routine is assumed to be exported unless it's marked 'only' or 'my'.

[14:23] <[particle]> is that correct?

[14:23] <[particle]> Any proto declaration that is not declared "my" is exported by default. Any multi that depends on an exported proto is also automatically exported. When there is no proto for a multi, the autogenerated proto is assumed to be exportable.

[14:24] <TimToady> that seems about right

[14:25] <TimToady> multis try to be everywhere, other things try to stay private

[14:25] <[particle]> gotcha.

[14:25] *** xinming_ left
[14:25] <TimToady> in most languages with multimethods they're just automatically global

[14:26] <TimToady> but globals are evil so we're trying to finess it via the export system

[14:26] <TimToady> *finesse

[14:26] <TimToady> language changes are lexically scope in P6

[14:26] <TimToady> *scoped, can't type this morning

[14:26] *** Khisanth joined
[14:27] <TimToady> that's because my coffee isn't done yet

[14:27] <TimToady> well, age-related brain rot couldn't have anything to do with it...  :)

[14:27] <pmichaud> 14:23 <[particle]> from my read on exporting, any routine is assumed to be exported unless it's marked 'only' or 'my'.

[14:27] <pmichaud> I didn't read it that way.

[14:28] <[particle]> s/routine/multi/

[14:28] <pmichaud> okay, that I can agree with.

[14:28] <[particle]> timtoady read it right, even though i typed it wrong

[14:30] <TimToady> bleah, the problem with making coffee without having made coffee first is you aren't awake enough to make coffee correctly...

[14:30] * TimToady forgot to turn on the coffee pot :(

[14:31] <TimToady> NOW EVERYTHING I SAY WILL HAVE BEEN WRONG!!!  :)

[14:32] <TimToady> including that...

[14:32] <PerlJam> Is that Rule 0?  All rules subject to the appropriate amount of coffee.

[14:33] *** bennett joined
[14:33] * [particle] doesn't know if TimToady forgot the period after the ellipsis, or if he misspelled it

[14:33] <TimToady> I don't believe in 4-dot ellipses.

[14:34] <TimToady> if there's a space after it, it's the end.

[14:34] <TimToady> well, a whitespace...

[14:36] <TimToady> the real problem is that, while you can use em-dash for pause in the middle of a sentence, it looks strange at the end of a sentence.

[14:36] <TimToady> So end-of-sentence pause ends up usurping ... when it doeesn't quite mean "something was removed here"

[14:36] <TimToady> it means more like "and there are further implications I'll let you work out for yourself"

[14:37] *** agentzh left
[14:38] <TimToady> PerlJam: I don't know if the coffee series has a neutral value.  :)

[14:38] <[particle]> following that, it seems a leading emdash should mean "it is obvious that", but that's not common usage yet.

[14:41] <TimToady> what I like is the Japanese usage a thought bubble with ... in it to mean "unspoken cogitation/confusion happens here"

[14:41] <TimToady> usage of

[14:41] <PerlJam> .oO(...)

[14:41] <PerlJam> (A bit much to type perhaps  :)

[14:42] <TimToady> ...

[14:42] <TimToady> ...___...

[14:43] <[particle]> save our ship?

[14:43] <[particle]> or is that russian for bear?

[14:45] *** pedrob left
[14:46] *** pedrob joined
[14:47] *** Lorn left
[14:47] <TimToady> maybe that's how the infix:<...> operator is pronounced. "one, two, three ssss whatever"

[14:48] *** alc joined
[14:50] <[particle]> dit dit dit vs yadda yadda yadda

[14:51] *** alester joined
[14:51] * jferrero is back (gone 01:49:29)

[14:52] *** zamolxes left
[14:53] *** agentzh joined
[14:58] <TimToady> you're so...ditzy...

[14:59] <[particle]> *rimshot*

[15:07] *** bennett left
[15:08] *** Lorn joined
[15:09] *** pedrob_ joined
[15:10] *** viklund left
[15:21] *** hercynium joined
[15:26] *** pedrob left
[15:32] *** speckbot left
[15:32] *** rakudo_svn left
[15:39] *** cosimo left
[15:39] *** Exodist joined
[15:45] *** spx2 left
[15:45] *** spx2 joined
[15:46] *** tomyan left
[15:53] *** xiaoyafeng left
[16:01] *** xuser left
[16:04] *** meppl joined
[16:05] <meppl> good evening

[16:06] *** xuser joined
[16:06] *** spx2 left
[16:07] <moritz_> hi

[16:08] *** alanhaggai left
[16:11] *** orafu left
[16:12] *** ZuLuuuuuu joined
[16:18] *** pedrob_ left
[16:19] *** alc left
[16:19] *** justatheory joined
[16:21] <pugs_svn> r22623 | lwall++ | [t/] no more unpacking hash parameters, s/ceil/ceiling/

[16:23] *** rdice joined
[16:29] *** kst``` left
[16:29] *** kst```` joined
[16:32] *** alanhaggai joined
[16:35] *** pjcj joined
[16:41] *** mncharity joined
[16:41] *** alanhaggai_ joined
[16:41] *** alanhaggai left
[16:42] *** orafu joined
[16:45] *** alanhaggai_ is now known as alanhaggai

[16:48] *** ZuLuuuuuu left
[17:17] <mncharity> ok, let's see...

[17:17] <mncharity> svn up'ing and rebuilding src/perl6 is like christmas, unwrapping presents. :)

[17:17] *** Bzek left
[17:17] <moritz_> developrs-only christmas ;)

[17:18] <mncharity> lol

[17:19] <mncharity> good concept.  I've always worried the p6 xmas model was two binary - someday, it's suddenly done.

[17:19] <moritz_> well, in real life christmas comes all suddenly as well

[17:19] <mncharity> a staged xmas - xmas for compiler devs, xmas for prelude work, xmas for non-production coding, xmas for production, etc, has appeal

[17:20] <moritz_> indeed

[17:23] *** jferrero left
[17:26] <TimToady> "two binary" is an interesting freudian slip

[17:33] <mncharity> lol

[17:34] *** demq joined
[17:41] *** sri_work left
[17:41] <[particle]> looks like nested packages aren't far from working in rakudo, that's good news.

[17:51] *** ruoso joined
[17:53] <mncharity> indeed

[17:56] <ruoso> Hello!

[17:57] <mncharity> hi ruoso :)

[17:57] <ruoso> hi mncharity 

[17:57] <[particle]> hola

[17:57] *** alester left
[17:58] *** _Jedai_ left
[17:58] <ruoso> [particle], have you seen the latest developments on the lexical multi thing?

[17:58] <ruoso> [particle], it should be relevant to parrot's implementation...

[17:58] *** Jedai joined
[17:59] <[particle]> no, i haven't paid much attention to scrollback here, just the ml

[18:00] <[particle]> if it's discussion from yesterday, i was more-than-half distracted by a phone call

[18:00] <ruoso> [particle], ok... try to take a look at yesterday's log... but basically, the idea is that a Multi object needs to hold a reference to the scope at which it is declared, as well as storing a name

[18:00] <ruoso> because when you .() at a multi, it needs to do full dispatch

[18:00] <ruoso> including variants not declared in the same level of the current multi object

[18:00] <[particle]> unless it's my, i suppose

[18:01] <ruoso> [particle], even then...

[18:01] <ruoso> it still sees the outer declaration

[18:01] <TimToady> calling these things Multi is confusing things

[18:01] <moritz_> I think the usual attitude is "I'll care about it when I implement" ;)

[18:01] <TimToady> a Multi is not a multi

[18:01] <[particle]> ah. capitalization will be the death of me

[18:01] <TimToady> it's a ShortName, really

[18:01] <ruoso> right... Multi is not even a type in Perl 6...

[18:02] <moritz_> [particle]: no, Capitalization ;)

[18:02] *** explorer joined
[18:02] <[particle]> *stab* *stab* *stab*

[18:02] <mncharity> capitulation

[18:02] <ruoso> maybe SubCandidateContainer

[18:02] <TimToady> it's what the compiler knows about &foo at the point of the call

[18:02] <ruoso> MultiContainer

[18:03] <TimToady> Ballot

[18:03] <TimToady> vote for one

[18:03] <ruoso> Ballot is cute, but too generic

[18:03] <[particle]> SpecificBallot

[18:03] <TimToady> I don't care, as long as whatever you call it doesn't confuse poor [particle]

[18:03] <[particle]> :P

[18:04] <ruoso> ohkay

[18:04] <ruoso> I'll call it MultiContainer then

[18:04] <ruoso> because it's what it is (sort of)

[18:04] <ruoso> so...

[18:04] <ruoso> every lexical declaration creates a new MultiContainer object

[18:04] <[particle]> it's a dispatch table

[18:04] <ruoso> [particle], not really... and that's the poitn

[18:04] <TimToady> it's a candidate list, which is why it's a Ballot

[18:05] <ruoso> it's more than a dispatch table

[18:05] <ruoso> because it needs to traverse the lexical scope to find additional candidates

[18:05] *** AzureStone left
[18:05] <ruoso> it stores just some candidates (unless counting cache, which I see as optimization)

[18:05] <[particle]> it's the thing against which you match the current sig

[18:05] <ruoso> [particle], no... that's each candidate sig

[18:06] <[particle]> ok, right, it's the thing that holds the things against which...

[18:06] <TimToady> you have to have signatures to put something on the ballot  :)

[18:07] <[particle]> how many parties are on the ballot? is this a one-party system?

[18:07] <ruoso> the innermost MultiContainer only holds the innermost declaration

[18:07] <TimToady> if you did match a signature against one of these things, you 'd end up with a shorter candidate list

[18:08] <TimToady> how many parties there are is controlled geographically in Perl 6

[18:08] <TimToady> aka lexically

[18:08] <ruoso> geez... even I am confused now...

[18:08] <ruoso> let me try to re-state

[18:09] <[particle]> is the ballot traversed by candidate, then by party?

[18:09] <ruoso> MultiContainer is the thing that hold each multi candidate 

[18:09] <mncharity> lol #re geez :)

[18:09] <[particle]> s/each/every/

[18:09] <TimToady> [particle], forget parties

[18:10] <[particle]> s/party/lexical scope/

[18:10] <ruoso> It doesn't hold *all* multi candidates

[18:10] <ruoso> only the candidates declared at the same lexical scope

[18:10] <[particle]> ah, ok.

[18:10] <[particle]> gotcha.

[18:10] <ruoso> that's why it needs to keep a reference to the outer scope, and it also needs to know its name

[18:10] <TimToady> er, it can hold all from locked down scopes

[18:11] <TimToady> it really only has to treat packages as dynamic, once CHECK is done

[18:11] <ruoso> TimToady, I'm trying to leave that to optimization...

[18:11] <TimToady> I'm trying to leave wiggle room for the optimizer :)

[18:12] <TimToady> but yes, in theory this can all be done at run time

[18:12] <ruoso> and when you $multicontainer.() it does a full lookup in the lexical scope to find *all* candidates, before matching the signature

[18:12] <[particle]> package Foo { multi baz(Int $x) {...}; package Bar { multi baz(Int $x) { ... }; multi baz(Set $x) {...} } }

[18:13] <ruoso> that's an error or at least a warning

[18:13] <ruoso> but I'd guess it's an error

[18:13] <[particle]> where did i go wrong?

[18:13] <ruoso> because you're redefining multi baz(Int $x)

[18:13] <TimToady> in an inner scope

[18:13] <[particle]> in a subpackage

[18:13] <TimToady> so it's okay

[18:14] <TimToady> it just hides the outer one

[18:14] <ruoso> is it ok because it's an inner scope? or because it's a inner package?

[18:14] <[particle]> ok. great, that's the answer  i was looking for.

[18:15] <TimToady> scope

[18:15] <ruoso> package Foo { multi baz(Int $x) {...}; package Bar { multi baz(Set $x) {...} } }

[18:15] <TimToady> however, being a package it's subject to redefinition on the fly

[18:15] <ruoso> [particle], the example above exposes the exact issue I'm pointing at

[18:16] <[particle]> package Foo { multi baz(Int $x) {...}; { multi baz(Int $x) { ... } #{hides outer multi} } }

[18:16] <TimToady> you can't be in package Foo simultaneously with backage Bar

[18:16] <TimToady> *package

[18:16] <TimToady> when the candidate list is being constructed, only the current package is consulted in the list I gave yesterday

[18:17] <ruoso> right... but it's still in an outer scope

[18:17] <ruoso> which makes it visible

[18:17] *** greatflamingfoo joined
[18:17] <TimToady> by virtue of "our"ness

[18:17] <ruoso> yes

[18:17] <TimToady> but not by virtue of being in the package

[18:17] <ruoso> yes

[18:19] <TimToady> if the candidate search stops short of the package, then it degenerates to the "my" situation

[18:20] <TimToady> otherwise an our multi is actually visible two different ways

[18:20] <TimToady> in the lexical scope, and in the package

[18:20] <ruoso> yes...

[18:20] <TimToady> so it hides itself in that case :)

[18:20] <ruoso> it seems so...

[18:20] *** icwiener joined
[18:21] <TimToady> anyway, I think we understand the thing on a procedural level

[18:21] <ruoso> it looks like you start harvesting candidates from the Package,

[18:21] <ruoso> then scopes

[18:21] <ruoso> putting on a hash

[18:21] <TimToady> ....

[18:21] <ruoso> in a way that newer candidates that share the same signature are overwritten by the innermost candidate

[18:22] <TimToady> well, assuming it's keyed on longname

[18:22] <ruoso> yes

[18:22] <TimToady> but you could also go the other direction and avoid putting it in if it's already there

[18:22] <ruoso> right... 

[18:23] <TimToady> just depends on which kind of treewalk you want to think of it as

[18:23] <ruoso> it actually makes more sense to go from inside to outside...

[18:23] <ruoso> to stop when you find a proto

[18:24] <TimToady> and there could be other non-idempotencies that would "encourage" harvesting the info as soon as possible

[18:24] <ruoso> by pre-caching, you mean?

[18:25] <TimToady> well, if you hit a perfect match for the signature, you can just stop and call it, I think

[18:25] <TimToady> s/signature/capture

[18:26] <pmichaud> at present rakudo cheats by storing everything in terms of its shortnames

[18:26] <ruoso> is there a way to know that it is a perfect match?

[18:26] <TimToady> assuming the initial "can match" decision is made at the same time, which is not clear

[18:26] <pmichaud> when we get to seriously considering multies, that will change.  Then the shortnames will keep track of multiness (where appropriate) and the subs will be held by their longnames

[18:27] <pmichaud> *multis

[18:27] <TimToady> once we start optmizing, there is probably a hashed type profile that can be compared to determine that we already know exactly how to dispatch this Capture

[18:28] <TimToady> so a capture containing (Int,Int) has a particular identity that can match a sig (Int,Int) in one numeric comparions

[18:28] <TimToady> s/ons/son/

[18:28] <pmichaud> I kinda like "comparions"

[18:28] <pmichaud> that's what we'll call the hashed type profile :-P

[18:29] <pmichaud> "it's a hash of comparions"

[18:29] <TimToady> yes, the Dan design was to just call an "only" sub of the shortname that emulates multi for you

[18:30] <ruoso> that's kinda what we're getting at now

[18:31] <TimToady> the interesting question to me is how this is gonna show up on platforms that don't treat functions as first-class objects, like P5

[18:32] <ruoso> as something opaque that produces the expected result?

[18:33] <TimToady> Makes it hard to ask: "Don't do it, but if I were to ask you this, what would be your result?"

[18:33] <ruoso> er... that isn't really possible in P5 anyway, is it?  

[18:34] <TimToady> kinda like "Look up this subscript, but not really, just tell me if the last operation would succeed"

[18:34] <TimToady> well, there are hacks...

[18:34] <ruoso> like... looking at the optree?

[18:34] <ruoso> well these hacks wouldn't work...

[18:35] <ruoso> as they don't work with XS subs

[18:35] <TimToady> but it'd be nice not abstract everything into real P5 objects when the overhead is unnecessary

[18:35] <ruoso> TimToady, I don't think it will be necesssary

[18:35] <ruoso> nothingmuch and mst have been experimenting some cool things in P5

[18:35] <TimToady> well, the whole gimme5 notion is to keep it all as close to the P5-metal as possible

[18:35] <TimToady> (which is not very close, in the case of regexen, sigh)

[18:36] <TimToady> I figure on implementing as much on top of P5 as is practical, then seeing what hacks would make it easier to do the rest

[18:36] <TimToady> like lazy lists maybe

[18:37] <ruoso> I really think it will be possible to transparently interoperate SMOP objects inside perl5 at some point...

[18:37] <TimToady> but I kinda doubt P5 as a platform will ever support all of P6

[18:38] <TimToady> hopefully

[18:38] <TimToady> keep peddling hard :)

[18:38] <ruoso> actually it would be more like the other way around...

[18:38] <ruoso> but it would be two-ways interoperating

[18:39] <ruoso> it wouldn't be the actual p5 interpreter, but a modified interpreter running on top of SMOP

[18:39] <TimToady> real continuations in P5 would make laziness easier

[18:39] <ruoso> yes... making p5 trully-stackless is a reason for having a modified p5 interpreter inside smop

[18:39] <TimToady> but I basically already know how to write a regex engine in P5 now  :)

[18:40] <ruoso> I still need to figure out a way to distinguish a SMOP__Object* from a SV*

[18:40] <ruoso> so it can decide what to do in the runloop

[18:41] <TimToady> steal the 1 bit?

[18:41] <ruoso> 1 bit?

[18:42] <TimToady> the 1 bit is always 0 in pointers to aligned data

[18:42] <TimToady> or, if SV is aligned on 64, and yours on 32, you can steal the 32 bit and just make sure you allocate on odd 32-bit boundaries :)

[18:43] <TimToady> or vice versa

[18:43] <mncharity> did a parrot+ruby hybrid using that :)  (low-bits, not, shudder, the 32 bit)

[18:43] <TimToady> or if they're both 64-bit, then use two different allocators that do even or odd boundaries

[18:44] <TimToady> you only have to waste half an entry at the beginning of a block

[18:44] <TimToady> the real question is *how* do you want to distinguish them

[18:45] <TimToady> using an "if" is different from just dispatching differently...

[18:46] <TimToady> so maybe you just add a vtable to SVs :)

[18:46] <ruoso> well... in fact I could add a RI to the SVs

[18:46] <ruoso> considering every module would need to be recompiled

[18:46] <mncharity> TimToady: fyi, given the STD graph for 3.a.b ,  if you walk the 'arg' spine, you get ((3 .a) .b), but if you walk the 'dotty' spine you get ((3 .b) .a).  so viv says the right thing, but the nodes have invalid dotty's.

[18:46] <ruoso> I could have a different SV structure

[18:47] <TimToady> yeah, there's something duped in there, but better too much than too little, eh?  :)

[18:48] <ruoso> then the SMOP interpreter would just use the objects without seeing a difference

[18:48] <TimToady> meanwhile I'm cogitating heavily about how to return tokens in token order, and how that impacts the meaning of $/[0] vs $<0>, and splits vs combs, and how the heck signatures can match all named parameters as positionals...

[18:48] <ruoso> and the p5-modified-interpreter would have two dispatching mechanisms

[18:48] <ruoso> or maybe not...

[18:49] <TimToady> just rewrite all the cute macros that P5 uses, and you're done  :)

[18:49] <ruoso> TimToady, aren't the macros dependent on the SV struct declaration? 

[18:49] * TimToady waves his hands vaguely

[18:50] <TimToady> obviously you might also have to rewrite some of the missing macros that aren't there yet.  :)

[18:50] <ruoso> anyway... I'm pretty confident we'll find a way when it's time...

[18:50] <ruoso> ;)

[18:51] <TimToady> macros are the solution to just about everything that's wrong with C, except for the problem of C macros

[18:51] <[particle]> that can be solved by abstracting the c under a virtual machine :)

[18:52] <TimToady> don't let me slow you down :)

[18:52] <ruoso> the biggest problem will be the C code that recurses back into the interpreter

[18:52] <ruoso> (it wouldn't be a problem under a vm, yeah...)

[18:52] *** pedrob joined
[18:53] <TimToady> just need to bribe Intel to install a few CPU hooks...

[18:53] <TimToady> hardware support for continuations, yum

[18:54] <ruoso> but this recursions always are represented in terms of C macros in XS, iirc

[18:54] <ruoso> which leaves room for weird setjmp hacks

[18:55] <TimToady> well, that was the ponie theory...

[18:55] * justatheory neighs

[18:55] <TimToady> unfortunately this ponie nays

[18:57] <TimToady> anyway, the abstract problem I'm trying to solve is that when a Match is returned, you want to be able to ask for particular named fields as well as the fields in order, but that doesn't map well to current signature binding semantics

[18:57] <ruoso> indeed

[18:57] <justatheory> heh

[18:58] <ruoso> named are not ordered

[18:58] <justatheory> That ponie don't hunt.

[18:58] <TimToady> so I think there's something fundamental that needs to be figured out about captures and signatures

[18:58] <TimToady> but when you ask for the tokens in order, you don't just want it to leave gaps where the names were

[18:58] <moritz_> aye

[18:59] <TimToady> that's more or less what current sigs give us

[18:59] <ruoso> hm?

[18:59] *** icwiener left
[18:59] <moritz_> so if we had some raw, ordered captures, that would also remove the specialness of list()

[19:00] <TimToady> it's like you want to be able to pull named args out of the raw list "with replacement" or without

[19:00] <TimToady> something going on about the invocant in here as head of the list, also

[19:00] <ruoso> isn't that you have the named elements also listed as positional elements/

[19:00] <ruoso> ?

[19:00] <TimToady> but not sure how this relates to "make"

[19:01] <ruoso> like.... duplicated...

[19:01] <TimToady> it's not the pugs model

[19:01] *** icwiener joined
[19:01] <TimToady> which separates out the nameds at an early stage

[19:01] <TimToady> but I think that's a problem

[19:01] <ruoso> you think it's a problem to separate? or to not separate?

[19:02] <ruoso> SMOP separates at a very low-level early basic stage

[19:02] <TimToady> to separate out the nameds and lose ordering info on the original args

[19:03] <ruoso> can we just assume that named are not positional?

[19:03] *** kst````` joined
[19:03] <TimToady> for "please tokenize this" you need to be able to at least reconstruct the original order of intermixed nameds and positionals

[19:03] <TimToady> and it would be even nicer if it were efficient

[19:04] <ruoso> in the cases it named should be positional, I could argue that they would be at the same time named *and* positional...

[19:04] *** alanhaggai left
[19:04] <ruoso> meaning double entries...

[19:04] <ruoso> but that's not the nature of every capture

[19:05] <ruoso> only a very few captures (and sigs) need this kind of semantics (I guess)

[19:05] <ruoso> so duplicating the entry so it appears both as named and as positional could solve it

[19:05] <moritz_> it's not that simple for matches

[19:06] <pmichaud> as another way of looking at things, PHP keeps the ordering of its "named" and "positional" values in its arrays

[19:06] *** Lorn_ joined
[19:06] <ruoso> pmichaud, but that's because it converts everything to strings...

[19:06] <moritz_> because multiple named matches of the same name appear in the list, but can accessed as one list

[19:06] <TimToady> I'd like to be able to write /.../ ~~ my (...) and have the Match bound as a Capture, but I don't know how to write the my so that it gets tokens

[19:06] <pmichaud> there are many things broken about that particular model, but it does manage to work.  Essentially it's an ordered hash that understands numeric keys

[19:07] <pmichaud> (i.e., the order of keys is preserved.)

[19:08] *** adc_Penner left
[19:08] <ruoso> pmichaud, there's little magic in it... it does a numeric compare of strings...

[19:08] *** adc_Penner joined
[19:08] <pmichaud> I'm not advocating PHP's implementation, just pointing out that there's something that kinda works.

[19:09] <TimToady> thing is, when I ask a match for its tokens, I *don't* want $0, $1, $2, etc

[19:09] <pmichaud> (and that I've taken advantage of from time to time)

[19:09] <TimToady> those are just names that happen to be numeric

[19:10] <avar> pmichaud: php doesn't have hashes but rather key-value pair arrays, array_key_exists() is O(n) because of that

[19:10] *** Lorn__ joined
[19:11] *** pmurias joined
[19:11] <TimToady> I don't really care how PHP does numeric indices.  my point is that the parsing mindset fundamentally wants left-to-right, don't-throw-anything-away semantics, while the "extraction" mindset wants to throw all the dross out

[19:11] <TimToady> and they can't both have list context :)

[19:11] <[particle]> perl 6 should be allowed to have slow lookups if you want to preserve order

[19:12] <moritz_> TimToady: what's wrong with doing it with composition?

[19:12] <[particle]> at least, slow lookups for order-preserved values

[19:12] <moritz_> TimToady: $/.splits being the left-to-right, everything else unchanged?

[19:12] *** Jedai left
[19:13] <pmichaud> actually, somehow the "left-to-right" mindset feels a lot like   $/.pairs

[19:13] <TimToady> well, that's one possible approach, but it doesn't solve the underlying problem (if there is one) with signatures

[19:13] *** Jedai joined
[19:13] <ruoso> TimToady, well... unless I'm missing something... I'd still argue to duplicate the named as positional...

[19:13] <ruoso> in the cases you want that approach

[19:13] <pmichaud> where $/.pairs could be different from %($/).pairs

[19:14] <pmurias> when i wanted order for STD5_dump_match i just sorted the named fields of the Match

[19:14] <TimToady> and rightly called it a mess

[19:14] <moritz_> pmurias: that code is neither nice nor efficient, I think ;)

[19:15] <pmurias> moritz_: you mean the sorting part or the whole of STD5_dump_match?

[19:15] <PerlJam> TimToady: what's the problem with signatures?  mapping positional params with $0,$1, etc?

[19:16] <moritz_> pmurias: dunno. I didn't quite figure out how to separate the two

[19:16] <TimToady> how do I write a signature to bind to a Match that gives me the tokens in order that they appeared?  even *@_ doesn't give me the named args currently

[19:16] *** adc_Penner left
[19:16] <ruoso> TimToady, make the match return the named as if they were positionals also

[19:17] <ruoso> then *@_ would contain everyone

[19:17] <pmichaud> I'm curious by what we mean exactly by "give the tokens in the order that they appeared"

[19:17] <TimToady> then does $0 contain the first parenthesized value or the matched string before it?

[19:17] <TimToady> or is $0 the parens but $/[0] the string

[19:17] <pmurias> moritz_:  just assume that named are not positional?

[19:17] <pmurias>         

[19:17] <pmurias> 19:03

[19:17] <pmurias> 	TimToady

[19:17] <pmurias>  just assume that named are not positional?

[19:17] <pmurias>         

[19:17] <pmurias> 19:03

[19:17] <pmurias> 	TimToady

[19:18] <pmurias> sorry

[19:18] <pmurias> touchpad--

[19:18] <TimToady> I like to see my name in print, but... :)

[19:18] <ruoso> TimToady, i'd argue '$0 the parens but $/[0] the string'

[19:19] <pmichaud> for example, with    / [ (foo)  baz <bar>? ]+ /   what does "tokens in order appeared" mean?

[19:19] <PerlJam> TimToady: I'd continue to go with historical precedent and have $0 and friends always contain parenthesized values.

[19:19] <moritz_> pmurias: in order in which they appeared in the source string

[19:19] <moritz_> erm, pmichaud, sorry

[19:19] <pmichaud> moritz_: so, we lose the "bar" label?

[19:19] <moritz_> pmichaud: we don't lose. We can still do $<bar>.

[19:19] <TimToady> okay, now how do you get at the 3rd paren of a submatch without using the array subscripting form?

[19:19] <pmichaud> you'd expect essentially   [ 'foo', 'bar', 'foo', 'bar' ]?

[19:20] <TimToady> well, I guess you use .<2> instead

[19:20] <TimToady> I think you'd get Str objects for the "interstices"

[19:20] <TimToady> that aren't bound to $0 or $<foo>

[19:20] <moritz_> TimToady: why not?

[19:20] *** adc_Penner joined
[19:20] <pmichaud> so  [ match of (foo), 'baz', match of <bar>, match of (foo), 'baz', match of (foo), 'baz', match of <bar> ]

[19:21] <pmichaud> (assuming original string was "foo baz bar foo baz foo baz bar")

[19:21] <moritz_> pmichaud: yes, that's my vision

[19:21] <TimToady> yes, where presumably each list element is sufficiently typed to tell what matched it

[19:21] <moritz_> pmichaud: (perhaps even with the whitespaces as ' ' in between)

[19:21] <pmichaud> I'm thinking

[19:21] <ruoso> TimToady, but why do you need the match to return the strings that were not captured?

[19:22] <TimToady> certainly including the whitespace--I want them for my --p6 option to viv :)

[19:22] *** xinming joined
[19:22] <pmichaud> [ 0 => match of (foo), 'baz', bar => match of <bar>, 0 => match of (foo), 'baz', 0 => match of (foo), 'baz', bar => match of <bar> ]

[19:22] *** Lorn left
[19:24] <TimToady> ruoso: because I have a fundamental mistrust of algorithms that lose information and are hence not reversible

[19:24] <TimToady> learned in the school of MAD

[19:24] <ruoso> TimToady, right... but that could be a different method...

[19:24] <pmichaud> either that, or the match objects need to know what they were matched as (which gets back to mncharity and allison requests for the same)

[19:24] <ruoso> $/.tokenize

[19:25] <ruoso> it doesn't need to be exposed in the $/.[0] syntax

[19:25] <PerlJam> ruoso: or,  $/.captures  $/.tokens  $/.etc  :)

[19:25] <PerlJam> ruoso: you lose in optimization I think though.

[19:26] <ruoso> well... if you need to store *all* the tokens... you loose anyway...

[19:27] <PerlJam> ruoso: the trick is determining when that's needed or not.  static scan for a particular method?  Maybe the "keep all tokens" is a pragma that modifies the behavior of regex (and thus $/.tokens is only available when that pragma is there)

[19:27] <ruoso> that looks sane

[19:28] *** aindilis left
[19:30] <TimToady> pragmas are usually insane

[19:31] <ruoso> storing all tokens looks even more insane ;)

[19:32] <ruoso> TimToady, but one way or another, the tokens doesn't need to be in $/.[0], but maybe only in $/.tokens[0]

[19:33] *** aindilis joined
[19:34] <PerlJam> TimToady: I could be insane too, but this discussion seems more "hard things easy" than "hard things possible" in some respects.

[19:35] *** kst```` left
[19:35] <moritz_> PerlJam: only because things are hard with current semantics doesn't mean they have to stay hard

[19:36] <PerlJam> moritz_: okay, how about more "hard things easy" than "hard things easier" then ?

[19:37] <moritz_> how about "simple things easier"? ;)

[19:37] <TimToady> actually, I'm more worried about fundamental things broken

[19:37] <PerlJam> I don't know ... keeping track of how every bit of text is parsed seems more "hard" than "simple" to me  :)

[19:38] *** Jedai left
[19:38] *** Jedai joined
[19:38] <moritz_> from the implementor's point of view, yes

[19:38] <ruoso> TimToady, right... as long as you don't say that we need to rewrite how capture works... ;)

[19:39] <moritz_> from the user's POV it's just walking a list, getting things in order - doesn't look too hard

[19:39] <TimToady> it actually also ties into some of the things Morrie Siegel and I discuss every year at YAPC with regard to how P6 regexes aren't as good as SNOBOL  :)

[19:40] <TimToady> which is why I'm very interested in how matches bind to signatures

[19:40] <pmichaud> TimToady: why isn't it a "normal" bind?

[19:40] <pmichaud> (naive question.)

[19:41] <ruoso> by "normal", meaning: "named" as "named" and "positional" as "positional"

[19:41] <TimToady> because I think it should be easier to deal with the tokens in order

[19:41] <pmichaud> meaning:   same as what we get if we do   (...) := foo()

[19:41] <PerlJam> Does prefix:<=> work on $/  ?    =$/  ---> iterate the matched text in order

[19:41] <ruoso> $/.tokens ?

[19:41] <pmichaud> can dealing with tokens in order be done with a method (or iterator) on the match object?

[19:42] <TimToady> this would be a more natural replacement for prefix binding, but would likely be postfix instead

[19:42] <TimToady> something like / [ match some stuff] -> :(your bindings here) / give or take some syntax

[19:43] <ruoso> I think it would more natural that the bindings reflected the captures...

[19:43] <pmichaud> oh, I get it.  You really are looking at Morrie's stuff :-)

[19:43] <TimToady> which should presumably work similarly to doing the binding outside as well

[19:44] <TimToady> yes, and I just don't want to make a bad decision right now that would make that difficult in the long run if it turns out pretty

[19:44] <ruoso> Morrie?

[19:44] <pmichaud> would "inorder" method on Match object be a bad decision that would make things difficult in long run?

[19:45] <TimToady> it would force all such sigs to use some kind of unpacking-tree-nodes syntax, at worst, I suppose

[19:45] <TimToady> but that could get pretty tiresome

[19:46] <PerlJam> TimToady: there are still plenty of Unicode operators :)

[19:47] <TimToady> Morris Siegel is a very smart fellow who wrote his dissertation on Snobol, and regularly (yearly) chats with Patrick and me about the philosophy of pattern matching.

[19:47] <PerlJam> You know what I can never get used to?  Almost all the interesting discussions here are just at the edge of my understanding :)

[19:48] *** alester joined
[19:48] <pmichaud> PerlJam: the same is true for me, and my understanding increases all of the time.  I think that's what is meant by "bleeding edge".

[19:48] <TimToady> he has a good eye for the discontinuities in our current design

[19:49] <pmichaud> I'm not able to evaluate his proposals as well as TimToady, but a lot of them to me seem like replacing the current discontinuities with different ones.  :-) :-)

[19:49] <moritz_> in the end, not everything is continuous

[19:49] <TimToady> you have to filter what he says, sure, but his viewpoint is very different, and useful for that reason

[19:49] <pmichaud> but they are indeed very useful, interesting, and sometimes lively chats

[19:50] <PerlJam> In fact, I think most physicists believe the universe to be discrete  :)

[19:50] <moritz_> (in physics actually the discontinuities are very interesting, and some of the are called "phase transitions")

[19:50] *** bacek joined
[19:50] * PerlJam bears witness to Perl's phase transition.

[19:50] <TimToady> the universe will be deflating in about 10 minutes

[19:51] *** aindilis left
[19:52] <PerlJam> Let me quote Mr. Siegel for a second:  "selecting just the right assertion format sometimes is highly non-trivial and requires careful analysis, since the choice has a fundamental influence on the final logic"

[19:52] <PerlJam> we're firmly in non-trivial territory  :)

[19:52] <TimToady> anyway, the whole point of captures is to delay context determination till binding time, and if tokenizing is context-driven, we have to think about whether it's binding driven

[19:53] *** insert_c1ins left
[19:53] <ruoso> $/.token can be context-driven

[19:53] *** aindilis joined
[19:53] <ruoso> and can even be 'bvalue context'

[19:54] <ruoso> $/.:tokens to make it look like other special bvalue methods...

[19:55] <ruoso> and then you can bind it just as you would do with the match itself... but you keep the match safe from returning all the tokens directly

[19:55] *** explorer left
[19:55] <TimToady> well, if demand through $/ is what is actually driving the lazy match...

[19:56] *** aindilis left
[19:56] <TimToady> but I'm not sure we've reached that level of enlightenment yet

[19:56] *** aindilis joined
[19:56] <ruoso> it means that if you want all the tokens, you need to use $/.:tokens before consuming the match

[19:57] <TimToady> what if someone passes you a signature that might or might not want to bind all the tokens?

[19:57] <pmurias> don't we have :keepall for getting all the tokens?

[19:57] <ruoso> TimToady, it seems to me that you want to add a third dimension in the capture...

[19:57] <ruoso> a fourth, actully... considering we already have invocant, named and positional

[19:58] <TimToady> maybe we should call them Elephants

[19:58] <ruoso> or turtles

[19:59] <TimToady> I keep trying to simplify them into lists with tagged elements

[20:00] * ruoso .oO( if that is simplifying... I just fear what it is to make more complex )

[20:00] <TimToady> phone # the universe is contracting now

[20:06] <PerlJam> It seems to me that we have Signatures, Matches, and Captures.  If you throw away the tokenizing info of a Match, that's much like a Capture.   And Signatures and Captures are like mirror images of each other.  Why would a Signature care about tokens at all?

[20:06] <PerlJam> (assuming you think of a Match has holding everything there is to know about what matched)

[20:06] *** speckbot joined
[20:06] <PerlJam> s/has/as/

[20:07] <pugs_svn> r22624 | pmurias++ | [mildew] fixed bug in sub {...}

[20:07] *** alester left
[20:07] <pmurias> ruoso: do you think mildew compiles t/pure_prototype_how.p6 correctly?

[20:08] <ruoso> pmurias, almost...

[20:08] <ruoso> postcircumfix:<( )> receives a capture object as first argument... and not the arguments directly

[20:08] *** icwiener left
[20:09] *** explorer joined
[20:09] <ruoso> pmurias, and you're removing the "\n" of "1..1\n" for some reason

[20:09] <ruoso> it wasn't supposed to be removed

[20:10] <pugs_svn> r22625 | particle++ | [t] add three tests for import, currently failing in rakudo

[20:11] <pmurias> how should Captures for postcircumfix:<( )> be created?

[20:11] *** icwiener joined
[20:12] <pmurias> $scope.lookup("Capture").FETCH.new(positional=>[...],named=>[...],invocant=>[...])?

[20:13] <pmurias> hmm, the Capture.new could just take the capture it receives and replace the invocant with a shift()ed positional

[20:14] <ruoso> pmurias, there's SMOP__S1P__Capturize which is a preliminar implementation of that

[20:20] * ruoso later &

[20:21] *** pmurias left
[20:22] *** din joined
[20:25] *** ab5tract joined
[20:29] *** |Jedai| joined
[20:39] *** ruoso left
[20:46] *** Jedai left
[20:47] <pugs_svn> r22626 | pmurias++ | [mildew]

[20:47] <pugs_svn> r22626 | pmurias++ | plan in t/pure_prototype_how.p6 shouldn't have double newline

[20:47] <pugs_svn> r22626 | pmurias++ | postcircumfix:<( )> receives a Capture.new_without_invocant(...) (found by ruoso++)

[20:49] *** jferrero joined
[20:50] *** explorer left
[20:51] *** Lorn__ left
[21:03] *** wknight8111 joined
[21:07] *** adc_Penner left
[21:08] *** rdice left
[21:11] *** mncharity1 joined
[21:12] *** ab5tract left
[21:12] *** mncharity left
[21:13] *** |Jedai| left
[21:13] *** Jedai joined
[21:20] *** jhorwitz left
[21:21] <pasteling> "mncharity" at 98.216.110.149 pasted "isn't parsed by viv" (15 lines, 592B) at http://sial.org/pbot/32647

[21:24] <mncharity1> TimToady: the above code isn't parsed.  a great many changes are sufficient to let it parse.  so attempting to distil it down further wasn't making progress.  it's a puzzle.  if you'd like me to try harder, I will.

[21:31] *** ryanc joined
[21:34] *** icwiener left
[21:38] *** xinming left
[21:43] *** TJCRI left
[21:50] *** xinming joined
[21:53] *** iblechbot left
[21:58] *** kst````` left
[21:58] *** kst`````` joined
[22:03] *** Jedai left
[22:03] *** Jedai joined
[22:04] *** Exodist left
[22:05] <mncharity1> btw, that was merely an fyi.  I expect I can find some cheat to make it not a blocker, perhaps quite easily.

[22:10] *** donaldh joined
[22:12] *** donaldh left
[22:20] *** hercynium_ joined
[22:29] *** [particle]1 joined
[22:35] *** mncharity1 left
[22:48] *** ruoso joined
[22:50] *** dduncan joined
[23:00] *** AzureStone joined
[23:11] *** pedrob left
[23:23] <TimToady> heh: Can't create postfix:sym<i>: Identifier too long at (eval 498) line 1

[23:23] *** hercynium_ left
[23:26] <TimToady> I know what the problem is, and I have a workaround, but not a fix.

[23:26] *** explorer joined
[23:27] <TimToady> if you put each macro into its own block, then it won't keep adding to the previous language when it does mixins

[23:27] <TimToady> the basic problem being that P5 doesn't support anonymous packages, so we generate new packages based on the old one

[23:27] *** jferrero left
[23:30] <TimToady> if you look at the directory tree under lex you'll see names like:

[23:30] <TimToady> lex/STD/_prefix__S_500Bang/_prefix__S_501Plus/_prefix__S_502Plus/_prefix__S_503Plus/_prefix__S_504Tilde/_prefix__S_505Tilde/_prefix__S_506Minus/_prefix__S_507PlusPlus/_prefix__S_508MinusMinus

[23:34] <TimToady> a mostly-good-enough fix would be to figure out which languages aren't used before they're extended, and coalesce

[23:34] <TimToady> however, if there were an eval betweeen each of your definitions, it would have to remember all the intermediate languages so it would know what language to start with for the eval.

[23:35] <TimToady> another partial fix would be to divorce the package name from the language pedigree

[23:35] <TimToady> but then we still have to track the relationship, and the lex directories become more opaque

[23:37] <TimToady> 'course, there's a tremendous amount of duplicated info in lex/ right now, and compacting that down is probably my next trick after viv

[23:37] *** jferrero joined
[23:37] <TimToady> @tell mncharity see backlog for answer to your question

[23:37] <lambdabot> Consider it noted.

[23:38] *** Jedai left
[23:39] *** Jedai joined
[23:39] <TimToady> @tell mncharity starting at http://irclog.perlgeek.de/perl6/2008-10-15#i_623942

[23:39] <lambdabot> Consider it noted.

[23:43] *** PZt left
[23:43] <TimToady> btw, generating all those new languages is why it parses so slow.  It would also speed up if we suppress the intermediate language generation where it's unneeded

[23:44] <TimToady> but correctness before performance

[23:44] <TimToady> there's still oodles and gobs of room for optimization

[23:49] <TimToady> maybe we really just want a syntax that defers language generation till later.  much like we use prefix:sym<++> to name the rule that will later produce prefix:<++>

[23:51] <TimToady> that would also let you use the current language's definition of prefix:<++> in the body

[23:51] <TimToady> maybe prefix:export<++>

[23:51] <TimToady> doesn't take effect till imported

[23:52] <TimToady> and since a bunch of 'em are imported at once, need not generate a bunch of unused intermediate languages

[23:53] *** explorer left
[23:53] <TimToady> and the new language is named by a pedigree of uses, not a pedigree of macros

[23:55] <TimToady> alternately, establish a rule that macros are only ever introduced at the end of the current block

[23:56] <TimToady> then establish the convention of putting all your macro defs into a block at the top

