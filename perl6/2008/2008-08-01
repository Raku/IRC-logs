[00:13] *** penk joined
[00:21] *** vixey joined
[00:23] *** viklund` left
[00:26] <meppl> good night

[00:29] *** meppl left
[00:32] <ruoso> @tell pmurias, when I implemented new in smop_s1p_scalar other tests started failing. Then I realised that was because we were assuming that Scalar would delegate all calls to its cell. but how do we call Scalar.new? I think we need the opposite, every item supports .FETCH(), which means that everytime you want to operate with a value, you need to do the fetching...

[00:32] <lambdabot> Consider it noted.

[00:35] <ruoso> @tell pmurias, I think the '.' operator implies a FETCH()... $*OUT.print would translate to what today is $*OUT.FETCH.print

[00:35] <lambdabot> Consider it noted.

[00:38] <ruoso> @tell pmurias, I'm commiting it with a ___UNKNOWN_METHOD___ instead of the delegation in smop_s1p_scalar... it causes breakage, but the delegation is too much fragile... we should avoid it and force the "value context" where appropriate

[00:38] <lambdabot> Consider it noted.

[00:40] *** justatheory left
[00:40] <ruoso> TimToady, is it sane to consider the existence of a "value context"?

[00:40] <pugs_svn> r21662 | ruoso++ | [smop] attribute mostly implemented, tests still failing, but the code is there.

[00:40] <pugs_svn> r21662 | ruoso++ | Scalar no longer delegates the calls to its cell, there should be an implicit fetch in "value context"

[00:40] <ruoso> TimToady, as opposed to "container context"

[00:43] <ruoso> @tell pmurias, in the end, that will mean that we will not see any explicit FETCH/STORE in the code, they would always be implicit depending on the context ('=' is probably the only STORE case, for the lvalue, but the rvalue still have a implicit FETCH in that case)

[00:43] <lambdabot> Consider it noted.

[00:48] <ruoso> I think we reached a very p5-like model... there isn't much sense in a value without a container, considering the features Perl 6 has... What we have different now is that we have the clear distinction of the container and the value, 

[00:49] <ruoso> but pragmatically, you always have a container, even if it's a read-only scalar container that have itself as the value

[00:51] *** Lorn_ left
[00:53] *** nipotaway is now known as nipotan

[00:58] * ruoso sleep &

[01:04] *** penk left
[01:05] *** penk joined
[01:27] *** explorer left
[01:30] *** elmex left
[01:32] *** avar joined
[01:40] *** kanru left
[01:45] *** drbean left
[01:58] *** penk left
[01:59] *** penk joined
[02:02] *** Limbic_Region left
[02:06] *** bacek_ left
[02:08] *** bacek joined
[02:10] *** luqui joined
[02:15] *** wknight8111_ left
[02:17] *** Lorn joined
[02:27] *** simcop2387 left
[02:31] *** penk left
[02:31] *** justatheory joined
[02:35] *** penk joined
[02:43] *** justatheory left
[03:11] *** pen1 joined
[03:11] *** penk left
[03:26] *** kanru joined
[03:29] *** alester joined
[03:30] *** coumbes joined
[03:33] *** pen1 left
[03:34] *** penk joined
[03:48] *** vixey left
[03:48] *** vixey joined
[03:49] *** luqui left
[04:01] *** penk left
[04:34] *** coumbes left
[04:45] *** simcop2387 joined
[05:18] *** Southen_ left
[05:19] *** silug left
[05:21] *** justatheory joined
[05:24] *** luqui joined
[05:27] *** justatheory left
[05:40] *** frobnitz left
[05:41] *** kanru left
[05:48] *** iblechbot joined
[05:56] *** Psyche^ joined
[06:10] *** Patterner left
[06:10] *** Psyche^ is now known as Patterner

[06:16] *** kanru joined
[06:17] *** Schwern left
[06:44] *** ashizawa joined
[07:00] *** jan left
[07:04] *** jan joined
[07:07] *** vixey left
[07:10] *** silug joined
[07:22] *** alanhaggai joined
[07:22] * zamanfou is now away: In the rain my tears are forever lost.

[07:26] *** alester left
[07:33] *** pmurias joined
[07:34] <pmurias> ruoso: hi

[07:40] <pmurias> the problem with non-delegation is that we will have a lot more method calls

[07:46] <pmurias> it should be possible to have the scalar delegate everything, with a VAR() needed to call methods directly on it

[07:46] *** cosimo joined
[07:54] *** bacek left
[07:56] *** bacek joined
[07:58] *** explorer joined
[08:09] *** zamolxes joined
[08:14] *** masak joined
[08:15] *** bacek left
[08:37] *** zamolxes left
[08:44] <pugs_svn> r21663 | fglock++ | [v6.pm] 0.032

[08:46] *** kanru left
[09:02] *** meteorjay left
[09:02] *** meteorjay joined
[09:06] *** fridim_ joined
[09:11] *** explorer left
[09:30] <ruoso> pmurias, I know it requires additional method calls... but VAR() only makes sense in a higher level, creating an additional container to allow you calling methods on the variable, because '.' would have an implicit fetch

[09:32] <ruoso> pmurias, VAR() doesn't make sense when we are in the level "use v6 blocks" are

[09:32] <ruoso> except we have it making all the implicit FETCH calls

[09:32] * ruoso waking up &

[09:33] *** agentzh left
[09:33] *** agentz1 joined
[09:34] *** iblechbot left
[09:43] <pmurias> "use v6 blocks" are in the top-most level

[09:43] *** barney joined
[09:43] <pmurias> their content is normal p6

[09:45] <pmurias> (with the exception of the lexical scope faling back on the C lexical scope)

[09:53] *** elmex joined
[10:01] *** barney left
[10:08] *** Jedai joined
[10:14] <ruoso> pmurias, so in "use v6" blocks you need to add implicit FETCH on the '.' operator and other operators that imply "value context"

[10:14] * ruoso going to work &

[10:14] * ruoso later &

[10:14] *** ruoso left
[10:21] *** nipotan is now known as nipotaway

[10:29] *** meppl joined
[10:45] *** luqui left
[10:45] *** meteorjay left
[10:53] *** lleksah joined
[10:57] *** smtms left
[11:03] *** smtms joined
[11:08] *** alanhaggai_ joined
[11:22] *** ashizawa left
[11:22] *** bacek joined
[11:24] *** alanhaggai left
[11:27] <pmurias> @tell ruoso what are your objections to the redispatching scheme? We could do it differently, a Scalar would be wrapped in an object which would just redispatch *everything* on the scalars .FETCH and the actual scalar could be retrived using VAR()

[11:27] <lambdabot> Consider it noted.

[11:27] <pugs_svn> r21664 | fglock++ | [v6.pm] more tests  # 6500

[11:29] <pmurias> @tell ruso VAR() could either call an internal method (if we can reserve one) or know the Scalar's RI

[11:29] <lambdabot> Consider it noted.

[11:32] <pmurias> @tell ruoso VAR() could either call an internal method (if we can reserve one) or know the Scalar's RI

[11:32] <lambdabot> Consider it noted.

[11:32] *** buubot left
[11:37] <pmurias> lunch&

[11:37] *** pmurias left
[11:40] *** Alias_ joined
[11:40] *** bacek left
[11:41] *** buubot joined
[11:49] <pugs_svn> r21665 | audreyt++ | * Remove unused third-party modules.

[11:52] <pugs_svn> r21666 | audreyt++ | * Add Cabal, HTTP, zlib and cabal-install to third-party.

[11:52] *** lleksah left
[11:53] <pugs_svn> r21667 | audreyt++ | * Also add Parse::Yapp as a prereq of PCR.

[11:54] <pugs_svn> r21668 | audreyt++ | * Rename Makefile.PL to Makefile.PL.old in preparation of

[11:54] <pugs_svn> r21668 | audreyt++ |   the new Makefile.PL overhaul.

[11:54] <pugs_svn> r21669 | audreyt++ | * Replace the Pugs.cabal.in with a standalone Pugs.cabal.

[11:58] <pugs_svn> r21670 | audreyt++ | * A new Makefile.PL based on cabal-install.

[11:59] <pugs_svn> r21671 | audreyt++ | * Add precompile Prelude.pm and Test.pm to src/cbits/.

[11:59] <pugs_svn> r21672 | audreyt++ | * src/: Delete pretty much everything factored out from Pugs proper.

[12:02] <pugs_svn> r21673 | audreyt++ | * Import Pugs 6.2.13.11 from Hackage into our source tree.

[12:02] <pugs_svn> r21673 | audreyt++ | * Highlights:

[12:02] <pugs_svn> r21673 | audreyt++ |     - Much faster startup time

[12:02] <pugs_svn> r21673 | audreyt++ |     - Slightly faster compilation time

[12:02] <pugs_svn> r21673 | audreyt++ |       (mostly due to refactored Pugs.AST.Internals)

[12:02] <pugs_svn> r21673 | audreyt++ |     - Portable-to-Win32 readline thanks to Haskeline

[12:08] *** sri_work joined
[12:16] <pugs_svn> r21674 | fglock++ | [v6.pm] more tests  # 6600

[12:17] <pugs_svn> r21675 | audreyt++ | * Delete everything we're not actively using from src/.

[12:22] <moritz_> perl Makefile.PL says:

[12:22] <moritz_> [Pugs Dependencies]

[12:22] <moritz_> Can't exec "/bin/cabal": No such file or directory at Makefile.PL line 52.

[12:23] *** ruoso joined
[12:23] <moritz_> ah well, lets see which debian package offers cabal..

[12:24] <moritz_> none, on stable

[12:24] <pugs_svn> r21676 | audreyt++ | * Add back Pugs.Embed.Parrot without .hsc

[12:24] <moritz_> well, I'll just build on testing then...

[12:24] <audreyt> moritz_: that message should follow by something that installs cabal for you

[12:24] <audreyt> does it not?

[12:25] <ruoso> good to see you around audreyt  ;)

[12:25] <lambdabot> ruoso: You have 2 new messages. '/msg lambdabot @messages' to read them.

[12:25] <moritz_> audreyt: http://nopaste.snit.ch/13713

[12:26] <pugs_svn> r21677 | audreyt++ | * Reflect data-dir changes.

[12:26] <audreyt> moritz_: just a sec

[12:27] <audreyt> moritz_: try

[12:27] <audreyt> ./Setup -d

[12:27] <audreyt> what does it say?

[12:27] <moritz_> Setup: No command given (try --help)

[12:28] <audreyt> moritz_: that doesn't sound correct

[12:29] <audreyt> try

[12:29] <audreyt> rm Setup ; rm Setup.hi ; rm Setup.o

[12:29] <audreyt> ghc --make -O0 -o Setup Setup.lhs

[12:29] <audreyt> ./Setup -d

[12:29] <ruoso> @tell pmurias, the problem is that the containers are regular objects that might implement any method they want... but in fact, that brings again the "value context" × "container context"... we don't have much option except for always calling fetch...

[12:29] <lambdabot> Consider it noted.

[12:30] <moritz_> /home/moritz/.cabal

[12:30] <moritz_> and there's /home/moritz/.cabal/bin/cabal

[12:30] <audreyt> moritz_: so now perl Makefile.PL would succed.

[12:30] <masak> svn says "Failed to add file 'X': object of the same name already exists" sometimes. how can it not recognize one of its own files?

[12:30] <ruoso> @tell pmurias, my $a = foo(); # in that case, foo() may or may not return a scalar... the only thing we can do is *always* call FETCH when using it as a value, and make values readonly self-containers

[12:31] <lambdabot> Consider it noted.

[12:31] <ruoso> @tell pmurias, then we have "container context operators", like ':='

[12:31] <lambdabot> Consider it noted.

[12:32] <pugs_svn> r21678 | audreyt++ | * Makefile.PL: More robust ~/.cabal detectino thanks to moritz++

[12:32] <ruoso> so every operator that uses "value context" implies a FETCH()

[12:32] <masak> so, if I already have Pugs installed via Cabal, what do I do to install it in this new way?

[12:32] <ruoso> $a.b() actually means LexPad.<$a>.FETCH().b();

[12:33] <moritz_> audreyt++

[12:33] <audreyt> masak: the new way is just automating the steps you do.

[12:33] <audreyt> masak: so "perl Makefile.PL ; make ; sudo make install" still works

[12:33] <audreyt> but so should simply "cabal install" from pugs dir

[12:33] <audreyt> the difference is the first also installs the docs/ stuff and copies pugs to /usr/local/bin/pugs.

[12:34] <masak> audreyt: ok, cool

[12:34] <moritz_> http://nopaste.snit.ch/13714

[12:36] <audreyt> moritz_: r21679.

[12:36] <pugs_svn> r21679 | audreyt++ | * Makefile.PL: configure before build.

[12:38] <masak> http://nopaste.snit.ch/13715

[12:40] <audreyt> masak: you may need a "cabal update".

[12:40] <pasteling> "moritz_" at 89.13.240.3 pasted "'make' output for audreyt++ (again ;)" (22 lines, 494B) at http://sial.org/pbot/31747

[12:40] <masak> audreyt: gotcha.

[12:41] <pugs_svn> r21680 | audreyt++ | * Insist on a local cabal-install even if we have a global one.

[12:42] <audreyt> moritz_: rerun Makefile.PL?

[12:42] <pugs_svn> r21681 | audreyt++ | * Add Prelude.hs.

[12:42] <audreyt> moritz_: if it doesn't install all deps for you

[12:43] <audreyt> trace line 59 of Makefile.PL and see if it actually runs.

[12:43] <moritz_> Resolving dependencies...

[12:43] <moritz_> cabal: cannot configure regex-pcre-builtin-0.94.2.0.7.7. It requires base

[12:43] <moritz_> >=3.0

[12:43] <moritz_> There is no available version of base that satisfies >=3.0

[12:44] <audreyt> uhm

[12:44] <audreyt> what's your ghc version.

[12:44] <moritz_> 6.6.1-2

[12:45] <moritz_> probabyl too old?

[12:45] <audreyt> not exactly unworkable

[12:45] <audreyt> but too messy at the point.

[12:45] <audreyt> s/the/this/

[12:45] <audreyt> I'll up the req to 6.8 in inc/.

[12:45] <moritz_> ok

[12:46] <audreyt> done.

[12:46] <pugs_svn> r21682 | audreyt++ | * Module::Install::Pugs: We now want GHC 6.8.

[12:47] <pugs_svn> r21683 | audreyt++ | * It is okay if the user had no ~/.cabal/.

[12:54] <pugs_svn> r21684 | audreyt++ | * Refer to LICENSE/MIT.

[12:56] <masak> 'cabal update' doesn't seems to actually do anything.

[12:56] <masak> it downloads the package list and then exits silently

[12:58] *** alanhaggai_ is now known as alanhaggai

[12:58] <audreyt> yes, but then the next "caal install" would resolve using new module list

[12:59] <pugs_svn> r21685 | audreyt++ | * Write Pugs.Config.

[12:59] <pugs_svn> r21686 | audreyt++ | * Oops, add a missing "cabal update".

[13:01] <pugs_svn> r21687 | audreyt++ | * Add PIR Prelude.

[13:02] <audreyt> Ok, a fresh checkout of Pugs just built correctly on a random linux box

[13:02] <moritz_> holiday &

[13:02] <audreyt> the next step (awaiting dcoutts++ and the cabal-install team)

[13:02] <masak> audreyt: I still get 'setup: At least the following dependencies are missing: FindBin -any, haskeline >=0.2.1, pugs-compat >=0.0.5', though

[13:02] <audreyt> is to wait for their equivalent of CPAN::Inject / CPAN::Mini

[13:02] <audreyt> masak: does "cabal install FindBin haskeline pugs-compat" resolve things for you?

[13:02] <audreyt> masak: the weird thing is that "perl Makefile.PL" is supposed to do that for you

[13:03] <audreyt> ah, that's because you just did "cabal install" on pugs home dir.

[13:03] <kolibrie> audreyt: perl Makefile.PL says: Setup.lhs:11:31: Not in scope: `autoconfUserHooks' Can't exec "./Setup": No such file or directory at Makefile.PL line 23

[13:03] <kolibrie> do I need to rm Setup ; rm Setup.hi ; rm Setup.o

[13:03] <kolibrie> etc

[13:04] <audreyt> kolibrie: aha. a sec.

[13:04] <pugs_svn> r21688 | audreyt++ | * Oops, we need to bootstrap cabal. try again.

[13:05] <kolibrie> audreyt: Linking ./Setup ...

[13:05] <kolibrie> audreyt++

[13:05] <audreyt> kolibrie: r21689 should fix it.

[13:06] <xinming> audreyt: this time, It works

[13:06] <pugs_svn> r21689 | audreyt++ | * Allow for bootstrapping cabal.

[13:07] <pugs_svn> r21690 | audreyt++ | * Final checkin for this batch - Pugs installation should now work

[13:07] <pugs_svn> r21690 | audreyt++ |   from scratch checkout with network connection.

[13:07] <pugs_svn> r21690 | audreyt++ |   Next step: offline.

[13:08] <pugs_svn> r21691 | fglock++ | [v6.pm] more tests   # 6900

[13:08] <kolibrie> Setup: At least the following dependencies are missing: network -any

[13:08] <kolibrie> that will be in a ghc package?

[13:09] <audreyt> oh. hm.

[13:09] <audreyt> it normally is

[13:09] <audreyt> but it is part of the "extra" package

[13:09] <audreyt> I guess it doesn't hurt to require installation of it

[13:10] <audreyt> (this is like finding CGI.pm not installed with perl.)

[13:11] <kolibrie> audreyt: perhaps I should install libghc6-network-dev?

[13:11] <pugs_svn> r21692 | audreyt++ | * Also require the "core" libraries to be installed.

[13:11] <audreyt> kolibrie: that will do, or r21692 Makefile.PL does that for you

[13:11] <audreyt> probably try r21692 Makefile.PL first.

[13:11] <kolibrie> pulling

[13:12] <kolibrie> no go

[13:13] <pasteling> "kolibrie" at 66.239.158.3 pasted "network -any dependency" (15 lines, 611B) at http://sial.org/pbot/31748

[13:13] <pugs_svn> r21693 | audreyt++ | * Add back "make smoke" and "make upload-smoke" targets.

[13:13] <audreyt> oh. hm.

[13:13] <audreyt> you need network to install HTTP

[13:13] <audreyt> which you need to install cabal-install

[13:13] <audreyt> which you need to install network.

[13:13] <audreyt> a sec.

[13:14] <audreyt> that means we need to add network, filepath, parsec to third-party.

[13:14] <audreyt> oh, just network and parsec.

[13:14] <audreyt> ok we do that.

[13:16] <xinming> Global symbol "$pugs" requires explicit package name at Makefile.PL line 141.

[13:16] <xinming> :-D

[13:16] <audreyt> xinming: sa sec

[13:17] *** Lorn left
[13:17] <xinming> I think I can fix it. :-)'

[13:18] <audreyt> then do that :)

[13:18] <pugs_svn> r21694 | audreyt++ | * Add network and parsec to third-party.

[13:18] *** cmarcelo joined
[13:19] <audreyt> cmarcelo: hi! I did your work for you :)

[13:19] <audreyt> xinming: going to commit soon?

[13:19] <pugs_svn> r21695 | yiyihu++ | Fixed

[13:19] <pugs_svn> r21695 | yiyihu++ |  Global symbol "$pugs" requires explicit package name at Makefile.PL line 141.

[13:19] <pugs_svn> r21695 | yiyihu++ | in Makefile.PL

[13:19] <audreyt> cool!

[13:19] <xinming> audreyt: yes, I think It's fixed, But I am not sure. >_<

[13:19] <kolibrie> xinming: that worked for me

[13:20] <kolibrie> audreyt: but I still get the network dependency

[13:20] <audreyt> kolibrie: you need r21696 and perl Makefile.PL

[13:20] <cmarcelo> audreyt: hello, how's going? I saw the blog :o)

[13:20] <pugs_svn> r21696 | audreyt++ | * Solve the problem reported by kolibrie++ of lacking network and parsec.

[13:20] <audreyt> cmarcelo: svn up and "perl Makefile.PL ; make ; make install" should work.

[13:21] <kolibrie> audreyt: ok, looks better now

[13:21] <audreyt> cmarcelo: I havn't yet committed the dependenies like MetaObject and HsSyck in

[13:21] <audreyt> cmarcelo: that'll wait a couple days until the cabal-install people figure out how to make local hackage mirrors work

[13:21] <audreyt> but otherwise pugs should install fine if you have a working network connection.

[13:21] <cmarcelo> great! :-)

[13:24] <kolibrie> audreyt: now when I make I get: make: /home/kolibrie/.cabal/bin/cabal: Command not found

[13:24] <audreyt> kolibrie: hm.

[13:25] <kolibrie> I see ~/.cabal/

[13:25] <kolibrie> but it only has lib and share in it

[13:25] <audreyt> that means cabal-install installation somehow failed.

[13:25] <audreyt> try this

[13:25] <audreyt> cd third-party/cabal-install

[13:25] <audreyt> ./Setup configure --user

[13:25] <audreyt> ./Setup build

[13:25] <audreyt> and see what happens?

[13:25] <audreyt> (and ./Setup install --user)

[13:26] <kolibrie> there is no Setup there, jest Setup.hs

[13:26] <audreyt> well then

[13:26] <audreyt> ghc --make -O0 Setup.hs

[13:26] <audreyt> first

[13:26] <masak> now I get 'gcc-4.0: -E, -S, -save-temps and -M options are not allowed with multiple -arch flags'

[13:27] <audreyt> masak: during "make"? nopaste your Pugs.buildinfo?

[13:27] <kolibrie> Setup: At least the following dependencies are missing: zlib >=0.4

[13:27] <masak> audreyt: ok, hold on

[13:27] <audreyt> kolibrie: that means zlib has failed

[13:27] <audreyt> do the same for third-party/zlib ?

[13:27] <kolibrie> :)

[13:28] <pasteling> "masak" at 130.238.45.242 pasted "my Pugs.buildinfo" (6 lines, 1.3K) at http://sial.org/pbot/31750

[13:28] <masak> audreyt++

[13:29] <audreyt> oy, Universal.

[13:30] *** pmurias joined
[13:30] <audreyt> masak: r21697

[13:30] <masak> :)

[13:30] <pugs_svn> r21697 | audreyt++ | * Configure.PL: We really can't build universal binaries.

[13:30] <pugs_svn> r21697 | audreyt++ |   Reported by masak++

[13:31] <masak> audreyt: same error... :/

[13:32] <masak> oops, hold on

[13:32] <masak> incomplete svn up

[13:32] <audreyt> ok

[13:32] <masak> svn is very sensitive to files that already exist in the working copy

[13:32] <audreyt> yes, you need to manually rm them

[13:33] <masak> why is that?

[13:33] <audreyt> bad design?

[13:33] <masak> suppose so

[13:33] * masak has a good mind to report it as a bug to the svn people

[13:33] <audreyt> well it's a concious design

[13:33] <masak> ...with high severity

[13:33] <audreyt> lest other people's file overwrites your precious not-yet-committed-but-same-named file

[13:34] <audreyt> it could instead just report it as a conflict and offer to resolve interactively, I suppose.

[13:34] <masak> hm

[13:34] <masak> does it still complain if the files are identical>

[13:34] <masak> ?

[13:35] <audreyt> no idea

[13:35] <masak> now it seems to build, anyway

[13:35] *** TJCRI joined
[13:35] <masak> audreyt++

[13:35] *** jhorwitz joined
[13:36] <kolibrie> audreyt: after installing zlib and cabal-install, I had to perl Makefile.PL, which pulled down the other dependencies.  Now it is making

[13:37] <pugs_svn> r21698 | audreyt++ | * Seeing how "svn up" on Pugs.Embed.Parrot causes "identical local file"

[13:37] <pugs_svn> r21698 | audreyt++ |   errors, and that Pugs.Embed.Parrot has bitrotten anyway, delete it.

[13:38] <pugs_svn> r21699 | audreyt++ | * The logical consequence of r21698.

[13:39] <pmurias> ruoso: the basic difference between your and my ways of handling containers is IMHO that you propose adding a lowlevel FETCH method call, and i assume all lowlevel method calls assume a FETCH 

[13:39] <pugs_svn> r21700 | audreyt++ | * More logical consequences.

[13:39] <masak> FYI, src/Pugs/CodeGen/PIR, src/Pugs/Prelude.hs, amd Pugs.cabal also caused svn problems

[13:40] <pmurias> i rm -fr them, is it ok?

[13:40] <masak> yes

[13:40] <masak> that's what you have to do.

[13:40] <masak> svn-- # design decision

[13:40] <pmurias> no big problem there, I was worried something more sinister happend

[13:41] <pmurias> masak: is there a better way of handling this?

[13:41] <masak> pmurias: git? :)

[13:41] <ruoso> pmurias, which is basically the same thing... ;) "use v6" blocks would make the implicit FETCH calls directly

[13:42] <ruoso> but Scalar would not delegate the calls

[13:43] <ruoso> the operators would do the FETCH when needed

[13:43] <pmurias> a ScalarWrapper

[13:43] <pugs_svn> r21701 | audreyt++ | * Actually Pugs.cabal is still better named Pugs.cabal.in.

[13:43] <pugs_svn> r21701 | audreyt++ |   (To accomodate for e.g. svn versions)

[13:46] <pmurias> i'm proposing $foo would be a delegating scalar wrapper, and VAR($foo) would be the actual Scalar

[13:47] <masak> audreyt: now I get the multiple -arch error later during make

[13:47] <kolibrie> audreyt++ # my pugs works!

[13:47] <masak> namely, after [65 of 89] Compiling Pugs.Run.Perl5

[13:48] <audreyt> masak: aw.

[13:48] <audreyt> masak: nopaste the "make" log?

[13:48] *** AndyAway is now known as Alester

[13:48] <masak> audreyt: oki

[13:48] <pmurias> my $a = foo() would be VAR(LexPad.<$a>).STORE(VAR(foo()).FETCH)

[13:49] <pmurias> but $a.b would be just LexPad.<$a>.b()

[13:49] <pugs_svn> r21702 | audreyt++ | * Add bytestring to third-party as well.

[13:49] <pasteling> "masak" at 130.238.45.242 pasted "make log" (82 lines, 5.5K) at http://sial.org/pbot/31751

[13:50] <pmurias> ruoso: it is slightly more complex but should be faster

[13:51] <ruoso> pmurias, which one is more complex?

[13:51] <ruoso> oh wait...

[13:51] <pmurias> my proposal

[13:52] * ruoso re-readin

[13:52] * pmurias re-reading to

[13:52] <pmurias> o

[13:52] <ruoso> pmurias, the problem is that you have foo().bar().baz() where foo, bar and baz might return scalars

[13:52] <ruoso> so you always have to force "value context"

[13:52] <ruoso> which means an implicit FETCH anyway

[13:54] <pmurias> they would return WrappedScalars which are indistinguishable from their content

[13:54] *** hercynium joined
[13:55] <pmurias> so foo().bar().baz() would work regardless if scalars or values would be returned

[13:56] <pmurias> ruoso: i can implement it as i might be describing it wrongly

[13:57] <ruoso> but how do you call a method in the WrappedScalar?>

[13:57] <ruoso> (in the low-level)

[13:58] <pmurias> you mean a method on the Scalar itself or on the value?

[13:59] <pmurias> $foo.foo would be just $foo.foo in the low-level

[13:59] <ruoso> in the scalar itself

[13:59] <ruoso> on the low-level

[13:59] <ruoso> if you delegate all calls? how do you do an actual call

[13:59] <rhr> audreyt: I got the missing zlib and HTTP when I ran Makefile.PL from r21702.  repeatedly re-runnung perl Makefile.PL seems to have solved it.

[13:59] <ruoso> the thing is that a higher level language

[14:00] <ruoso> have implicit FETCH/STORE defined by the syntax

[14:00] <pmurias> it turn it into the Scalar first with VAR, VAR.postcircumfix:<( )>($scalar).scalar_method

[14:00] <ruoso> $a = $b; implies "container context" in the lvalue and "value context" in the rvalue

[14:00] <ruoso> pmurias, but in the low-level?

[14:01] <ruoso> in the low-level you have just two objects... the scalar and the value

[14:01] <pmurias> three in my scheme

[14:01] <ruoso> hmmm.... that looks strange...

[14:02] <pmurias> it is a bit strange

[14:02] <pmurias> ;0

[14:02] <pmurias> ;)

[14:02] <pmurias> s/;0//

[14:02] <ruoso> I think the idea of having ro-self-containers for values is cleaner

[14:02] <ruoso> which means that every object implements FETCH, even if it returns itself

[14:02] <ruoso> and every operator that uses "value context" makes an implicit FETCH

[14:02] <ruoso> and that's all

[14:03] <pmurias> it would be impossible to read sm0p with FETCH's

[14:03] <ruoso> we're no longer writing sm0p

[14:03] <ruoso> we're writing "use v6" blocks

[14:03] <ruoso> and "use v6" might make that implicit fetch calls

[14:04] <ruoso> like...

[14:04] <pmurias> i have to read sm0p when debugging elf's smop backend :(

[14:04] <ruoso> heh

[14:05] <ruoso> $a = $b means in low-level LexPad<$a>.STORE(LexPad<$b>.FETCH())

[14:05] <pmurias> i could try writing everything on paper to reduce debugging

[14:05] <pmurias> ;)

[14:05] <ruoso> hehe

[14:05] *** Alester left
[14:09] <ruoso> pmurias, so... do we agree?

[14:10] <pugs_svn> r21703 | rhr++ | [INSTALL] howto build Lenny's ghc on Etch: give up

[14:11] *** alester joined
[14:11] *** barney joined
[14:13] <pmurias> ruoso: i'm not really sure, i understand how to implement both schemes

[14:13] <ruoso> pmurias, I think delegating is fragile...

[14:14] <pmurias> do you have a example where it fails

[14:14] <ruoso> when you want to call the scalar itself

[14:14] <pmurias> VAR($foo)

[14:14] <ruoso> this is high-level

[14:14] <pmurias> we can have a low-level VAR

[14:15] <pmurias> VAR.($foo)

[14:15] <ruoso> why?

[14:15] <ruoso> we don't need it

[14:15] <ruoso> we can have the container and the valeu

[14:15] <ruoso> value

[14:15] <ruoso> and that's all

[14:15] <pmurias> foo().bar() being foo().FETCH().bar() just feels wrong

[14:16] <pmurias> it will hinder language interoperability

[14:16] <ruoso> you're confusing high-level and low-level

[14:17] <ruoso> about language interoperability... I'm not really sure that is possible as it's currently expected...

[14:18] *** Lorn joined
[14:18] <pmurias> ruoso: why?

[14:20] <pmurias> ruoso: i'll look how the parrot guys are doing the Scalars

[14:20] <ruoso> pmurias, Perl 6 Object will never be the same as a Java Object

[14:20] <pugs_svn> r21704 | audreyt++ | * Pugs.Prelude should no longer be committed in.

[14:21] *** macroron joined
[14:23] <pugs_svn> r21705 | audreyt++ | * Makefile.PL: Solve the need-repeat-run-to-install-deps problem

[14:24] <pugs_svn> r21706 | audreyt++ | * Pugs.Run.Perl5: Do without -cpp

[14:25] <ruoso> pmurias, I've asked that question several times... but noone came to me with a clear solution

[14:25] <pugs_svn> r21707 | audreyt++ | * avoid warnings.

[14:26] <ruoso> I really think this supposed language interoperability is a major misguiding principle of the Perl 6 development

[14:26] <pugs_svn> r21708 | audreyt++ | * Run "cabal update".

[14:26] <ruoso> the important to me is runtime-interopeability

[14:26] <ruoso> and in that case, SMOP has a better support than parrot

[14:29] <pmurias> ruoso: what part of language interoperability do you think is infeasible?

[14:30] <ruoso> the transparent integration of java Vector and Perl 6 list

[14:30] <ruoso> there will be always a type-mapping layer

[14:30] <[particle]> i don't see this transparency specced. is it?

[14:30] <masak> ruoso: Java's Vector is superceded by ArrayList nowadays, btw

[14:32] <pmurias> ruoso: a java Vector and a Perl 6 list can be the same thing

[14:32] <[particle]> if a java Vector exposed in a perl 6 program says it does Int, i expect it to

[14:32] <[particle]> ok, Int was a bad example for Vector

[14:32] <ruoso> masak, you still have several List implementations and Set implementations

[14:33] <[particle]> Serializable or whatever

[14:33] <pugs_svn> r21709 | audreyt++ | * Sorry. bytestring does not belong in third-party.

[14:33] <ruoso> [particle], it's not specced, but it's the general expectation

[14:33] <masak> ruoso: yes, definitely.

[14:33] <[particle]> stick to the spec :)

[14:34] <[particle]> it's expected from parrot

[14:34] <pugs_svn> r21710 | audreyt++ | * A better gen_prelude.pl that takes the FFI-based inclusion into account.

[14:34] <ruoso> One thing I decided to neglect was this interoperability, and favor runtime-interoperability instead

[14:34] <[particle]> that sounds proper to me

[14:34] <pmurias> [particle]: how do you do Scalars in parrot?

[14:34] <ruoso> which means... I won't have the Perl 6 list to be the same as a Java List... but I will access the JVM objects instead

[14:35] <ruoso> and allow easier type-mapping implementation than XS

[14:35] <ruoso> simply by translating APIs

[14:35] <[particle]> pmurias: at what level? PAST::Var() contains PAST::Val() or some other object

[14:36] <pmurias> [particle]: i mean like STORE and FETCH

[14:36] <ruoso> [particle], do Scalar delegate the calls to the item? or in "value context" the operators make an implicit FETCH calls?

[14:36] <[particle]> ruoso: yes, but there are devils in the details

[14:36] <[particle]> in perl 6, as i understad, Scalars delegate to the item unless you specify the container, with VAR()

[14:36] <ruoso> [particle], yes.. .but that in high level

[14:37] <ruoso> in the low level you have two objects, the container and the value, right?

[14:37] <[particle]> well... i'm not sure it's done this way in parrot atm

[14:37] <ruoso> in the low-level, do you implicitly FETCH()? or you call the method in the scalar and it delegates?

[14:37] <[particle]> lemme check the latest

[14:38] <ruoso> [particle], about devils in the details... one way I'm trying to exorcise them is by support interoperating runloops with other interpreters....

[14:40] <[particle]> ruoso, still, you need to translate the api, and there are different interpretations of that mapping

[14:40] <ruoso> oh yeah... that mapping won't be automatic...

[14:40] <pmurias> ruoso: isn't it more like summoning than exorcising?

[14:42] <ruoso> pmurias, heh... maybe...

[14:43] <ruoso> [particle], I just want it to be easier to work with then XS...

[14:43] <ruoso> [particle], as it looks now, It will probably be possible to be done in a higher language...

[14:43] <ruoso> [particle], just like you can do with Java::Import

[14:44] *** cathya left
[14:44] *** jdv79 left
[14:44] *** jdv79 joined
[14:46] <[particle]> yes, well' parrot's nci is much easier than xs, too

[14:46] <[particle]> so it's definitely possible

[14:47] <ruoso> exactly... I think that's where we can get... I don't think HLL transparent interoperation is actually possible

[14:47] <pmurias> ruoso: isn't the problem with interlanguage interoperability that your application get horrible bloated when you have 10 runtimes?

[14:48] <ruoso> well... I don't work with 10 runtimes today even without integration... I don't think I would have a need to integrate that many runtimes

[14:49] <ruoso> smop, perl5, python, java, C, C++, any one more?

[14:49] <pmurias> haskell?

[14:49] <audreyt> to interop with haskell is to interop with C, basically.

[14:50] <ruoso> maybe ruby, but there isn't many libraries implemented in ruby...

[14:50] <pmurias> audreyt: doesn't haskell have a gc?

[14:50] <audreyt> there's this swig philosophy that says everybody just interop at the C level... and then there's this lua philosophy that says if you want to interop with someone, get embedded in that someone's runtime...

[14:51] <[particle]> lisp

[14:51] <ruoso> and there's the Perl 6 dream of interoperating them in high level...

[14:51] <audreyt> and there's also this pugs philosophy that says if you want to interop with someone, emit code targetting that someone's runtime...

[14:52] <ruoso> audreyt, that's ok for small languages like lua or javascripts

[14:52] <pmurias> n

[14:52] <pmurias> sorry

[14:52] *** TJCRI left
[14:52] <audreyt> pmurias: yes it does. why?

[14:52] <ruoso> but it doesn't work out when you have languages with native extensions... like perl5 or python...

[14:53] <ruoso> or with enormous API, like Java

[14:53] <audreyt> there is gcj though.

[14:53] <pmurias> audreyt: it has to be taken care of when interoperating so it's not just like with plain c

[14:54] <ruoso> audreyt, that looks like "get embedded in that someone's runtime"

[14:54] <audreyt> ruoso: right.

[14:54] <ruoso> which is what Java::Import does, actually

[14:55] <ruoso> one could port java to parrot... it would make the integration easier... but you would still need type mapping

[14:56] <audreyt> pmurias: point taken, though it's largely handled by the typesystem/FFI code and transparent to embedders.

[14:57] <pmurias> audreyt: is there any support for using CPAN from haskell?

[14:57] <audreyt> pmurias: why yes.

[14:57] <audreyt> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HsPerl5

[14:57] <lambdabot> Title: HackageDB: HsPerl5-0.0.6, http://tinyurl.com/5dnzm9

[14:58] <ruoso> anyway... we haven't had our answer for the Scalar issue yet... ;)

[14:58] * ruoso lunch &

[14:58] <pmurias> is there a cabal package for debian lenny?

[14:58] <[particle]> what i'd like to see is a perl 6 statement that exposes the precise question you're asking.

[14:59] <[particle]> (re scalar)

[14:59] <pmurias> [particle]: it's mostly an implementation detail

[14:59] <[particle]> looks to me like rakudo's src/classes/Scalar.pir answers the question to 'my Scalar $x = 3';

[15:00] <[particle]> .namespace ['Perl6Scalar']

[15:00] <[particle]> .sub 'infix:=' :method

[15:00] <[particle]>     .param pmc source

[15:00] <[particle]>     $P0 = source.'item'()

[15:00] <[particle]>     assign self, $P0

[15:00] <[particle]>     .return (self)

[15:00] <[particle]> .end

[15:00] <audreyt> it does an implicit FETCH call (except under the name 'item') to its rvalue.

[15:03] <pugs_svn> r21711 | fglock++ | [v6.pm] INSTALL update

[15:07] *** alanhaggai left
[15:07] <[particle]> (back from phoneland) .'item'() gets the item context

[15:07] <[particle]> it's a fetch, yes

[15:07] <pmurias> :/

[15:07] <[particle]> but it's not a container vs value thing

[15:08] <pmurias> so i assume delegation is done in parrot

[15:08] <pmurias> it's the faster choice

[15:09] <[particle]> yes

[15:10] <audreyt> pmurias: by delegation you mean $foo.meth gets emitted as $foo.item().meth by the compiler?

[15:10] *** allbery_b left
[15:10] <[particle]> The MutableVAR PMC provides access to the container type of a scalar. This is

[15:10] <[particle]> needed as scalar containers forward to their contents.

[15:11] *** Chillance joined
[15:11] <[particle]> src/pmc/mutablevar.pmc

[15:11] <audreyt> ah, so in parrot the delegation is done by the runtime (PMC) instead of by the compiler.

[15:11] <pmurias> audreyt: by delegation i meant that $foo.foo.bar is emitted as $foo.foo.bar instead as $foo.FETCH.foo.FETCH.bar

[15:13] <pmurias> audreyt: do you think it's better if it's done by the compiler?

[15:13] <audreyt> pmurias: ok, then yes, I think parrot does exactly that, and VAR($foo) gets emitted as something else that involves a MutableVAR wrapper.

[15:14] <audreyt> MutableVAR.new($foo).meth, abstractly, in parrot.

[15:15] <audreyt> pmurias: pugs-the-runtime handles context propagation automatically, so it knows when to make a fetch call and when not

[15:15] <audreyt> that's another alternative.

[15:15] <audreyt> (the bonus here is you get want() for free)

[15:17] <audreyt> pmurias: but I suppose the sanest way is to handle it in the compiler as much as you can, then yield to runtime (via either delegation or a runtime "context" pointer) for cases where you cannot decide

[15:17] *** allbery_b joined
[15:17] <pmurias> so it knows when to turn $foo.bar.baz into $foo.bar.FETCH.baz?

[15:18] <audreyt> currently in pugs it knows that (SOMETHING).baz must be in rvalue item context for that something

[15:18] <audreyt> so in runtime when evaluating the invocant it does an implicit fetch

[15:18] *** Exodist joined
[15:19] <audreyt> which is like what perl5 is doing

[15:20] <audreyt> the pp_method_* opcodes first call a

[15:20] <audreyt>     SvGETMAGIC(sv);

[15:20] <audreyt> on the invocant

[15:20] <audreyt> which is akin to calling an implicit fetch.

[15:20] <pmurias> thanks, that seems a saner way to do it

[15:21] <audreyt> I'd still say that the only really sane way is compile time analysis :)

[15:21] <pmurias> the context propagation that is

[15:21] <audreyt> but runtime rich context propagation is something unavoidable with perl

[15:22] <audreyt> esp. when you have things like (want.arity > 2)

[15:22] <audreyt> so maintaining a cheap context pointer somewhere in the main runtime is probably a sane thing to do anyway.

[15:22] *** rhr_ joined
[15:23] <pmurias> it should be possible to maintaing multiple copies of a method and just call the one compiled for the right context?

[15:23] <audreyt> (cxstack in perl5, envContext in pugs)

[15:24] <audreyt> sure, for the major contexts

[15:24] <audreyt> that'd be a wise choice

[15:24] <audreyt> (void, item, list)

[15:25] <audreyt> but you can always do

[15:25] <audreyt> ($x, $y, $z, $w) := your_sub();

[15:25] <audreyt> ($x, *@y) := your_sub();

[15:26] <audreyt> but optimizing for the common contexts seems like a win.

[15:33] <audreyt> (or you can always choose to wrap the return value into a Capture structure)

[15:33] *** rhr left
[15:34] <audreyt> and do a calling-Signature-vs-returning-Capture packing/unpacking at the end of a call

[15:34] <audreyt> but that assumes a very lightweight Capture/Signature/matching implementation.

[15:35] <[particle]> good luck with that :)

[15:36] <audreyt> indeed. not saying it's particularly easy or attractive. 

[15:37] *** alanhaggai joined
[15:37] *** rhr_ is now known as rhr

[15:40] *** barney left
[15:40] *** wknight8111 joined
[15:43] <avar> audreyt: welcome back!

[15:45] <audreyt> thanks :)

[15:45] <audreyt> (but I really should go offline to write my résumé and prepare for $interview.)

[15:47] <audreyt> laters &

[15:53] *** Jedai left
[15:53] *** Jedai joined
[16:03] <masak> audreyt: best wishes

[16:09] <masak> shell

[16:09] <masak> oops, sry

[16:11] *** justatheory joined
[16:23] *** iblechbot joined
[16:39] *** jan left
[16:45] <pmurias> ruoso: do you know how will we implement contexts?

[16:46] *** rafl joined
[16:55] *** iblechbot left
[16:58] *** jan joined
[17:00] *** sri_work left
[17:07] *** kanru joined
[17:34] *** sri_work joined
[17:36] *** masak left
[17:39] *** apeiron left
[17:41] *** jhorwitz left
[17:48] *** miketinte joined
[17:48] <miketinte> who Tene

[17:48] *** miketinte left
[18:02] *** cotto-work joined
[18:09] <ruoso> pmurias, re contexts: I'm not sure how to do that except by having implicit method calls depending on the expected context 

[18:09] <ruoso> with special casing optimizable situations

[18:13] <ruoso> eventually we might have a context stack as an optimization...

[18:14] <ruoso> for instance...

[18:14] <ruoso> if (foo()) asks for boolean context... the lazy way of doing it is having foo().bool()

[18:15] <ruoso> and a smart way would be having information on the calling of foo() about the desired context and foo() returning a boolean value in advance...

[18:17] <pmurias> s/on/during/

[18:17] <pmurias> ?

[18:18] <ruoso> one could argue that this information could be added to the capture

[18:18] <ruoso> (in that case, on the calling)

[18:18] <pmurias> ruoso: it has to be avalible somehow

[18:19] <ruoso> in slime, I thought it to have a "context" property

[18:19] <ruoso> for each node

[18:19] <ruoso> in the end I think I missed it

[18:19] *** meppl left
[18:19] <ruoso> but it really makes sense for it to be a part of the capture

[18:20] <ruoso> just like the signature contains the return type

[18:20] <ruoso> but most importantly...

[18:20] <pmurias> ruoso: you read how audreyt thinks our Scalar problem can be solved?

[18:20] <ruoso> as I read, the two alternatives are viable...

[18:21] <ruoso> but it looks she agrees with me ;)

[18:21] *** Schwern joined
[18:21] <ruoso> having the implicit calls defined by the compiler

[18:21] <ruoso> and trying to optimize it with run-time context information

[18:22] <pmurias> falling back on run-time context information

[18:23] *** meppl joined
[18:23] <ruoso> but that still doesn't seem entirely related to value × container

[18:23] <ruoso> but for different value types... i.e.: int in bool context

[18:24] <ruoso> it seems to me that container × value is entirely syntatical

[18:24] <ruoso> $a = $b × $a := $b

[18:25] <ruoso> and completely possible to delegate to the compiler

[18:25] <pmurias> the unicode x being vs.?

[18:25] <ruoso> yes

[18:25] <ruoso> ;)

[18:26] <ruoso> and remember that every variable is a container that have a container of a specific type that have a value

[18:26] <pmurias> what exactly is entirely syntactical?

[18:26] <ruoso> when to .FETCH()

[18:27] <pmurias> s/have/has

[18:27] *** peeps[work] joined
[18:27] <pmurias> yes, but in $foo.foo.bar it is compiled as $foo.FETCH.foo.bar

[18:27] <ruoso> actually $foo.FETCH.foo.FETCH.bar, because the '.' operator implies 'container context\

[18:28] <ruoso> 'value context'

[18:28] <ruoso> s/'container context//

[18:28] <pmurias> you just made this up ;)

[18:29] <ruoso> heh... maybe... but that's what I've been saying for a while...

[18:29] *** macroron left
[18:29] <ruoso> as welll as '=' implies container context on the lvalue and value context on the rvalue

[18:31] <ruoso> it might not be the most optimized option... but it does fit on every case I could think of

[18:33] <ruoso> but we also have to remember that $foo is actually LexPad.<$foo>.FETCH ... so ... $foo = $bar = LexPad.<$foo>.FETCH.STORE(LexPad.<$bar>.FETCH)

[18:33] <ruoso> hmpf..

[18:33] <ruoso> $foo = $bar  means     LexPad.<$foo>.FETCH.STORE(LexPad.<$bar>.FETCH)

[18:33] <pmurias> '.' should imply item context

[18:33] <ruoso> oh yeah... osrry

[18:33] <ruoso> $foo = $bar  means     LexPad.<$foo>.FETCH.STORE(LexPad.<$bar>.FETCH.FETCH)

[18:34] <ruoso> pmurias, in the case here the code on the right is in a lower level

[18:34] <ruoso> (that doesn't have contexts)

[18:34] <ruoso> $foo := $bar  means     LexPad.<$foo>.STORE(LexPad.<$bar>.FETCH)

[18:35] <pmurias> is %foo<key> := 1 allowed?

[18:35] <ruoso> why not?

[18:35] <ruoso> pugs: my %foo; %foo<key> := 1;

[18:35] <p6eval> pugs: RESULT[{obj:<Scalar::Const:0xb7b6e751>}]

[18:36] <ruoso> pugs: my %foo; %foo<key> := 1; %foo<key> = 'bar'; # should brake because it is readonly now

[18:36] <p6eval> pugs: OUTPUT[*** Can't modify constant item: VInt 1␤    at /tmp/XIBYhZnWFW line 1, column 26-43␤]

[18:36] *** BinGOs left
[18:36] <pmurias> my $foo;my %foo;%foo<key> := 7;say $foo;

[18:36] <ruoso> pugs: my $foo;my %foo;%foo<key> := 7;say $foo;

[18:36] <p6eval> pugs: OUTPUT[␤]

[18:37] <pmurias> pugs: my $foo;my %foo;%foo<key> := $foo;%foo<key> = 7;say $foo;

[18:37] <p6eval> pugs: OUTPUT[7␤]

[18:37] <pmurias> re why not, efficiency

[18:38] *** BinGOs joined
[18:38] <pmurias> why isn't $foo = $bar just LexPad<$foo>.STORE(LexPad<$foo>.FETCH)

[18:39] <pmurias> and $foo := $bar just LexPad<$foo> := LexPad<$bar>

[18:40] <pmurias> not sure what %foo<key> := 1 compiles to in the low-level

[18:40] <ruoso> pmurias, you're confusing low-level and high-level

[18:41] <ruoso> := doesn't exist in low-level

[18:43] <audreyt> ruoso: are you aware that lexpad may have immutable (non-rebindable) entries as well?

[18:43] <pmurias> i'm just using high level syntax because i don't know how := will be implemented

[18:43] <ruoso> audreyt, that means LexPad<$foo>.STORE will fail

[18:43] <audreyt> pugs: constant $pi = 3; $pi := 3.14;

[18:43] <p6eval> pugs: OUTPUT[*** Cannot rebind constant: PEConstant {pe_type = (mkType "Scalar::Const"), pe_proto = <Scalar::Const:0xb752a3b1>, pe_flags = MkEntryFlags {ef_isContext = False}}␤    at /tmp/F6XatDR3Jx line 1, column 19-30␤]

[18:43] <audreyt> ruoso: yes, just checking.

[18:44] <pmurias>  ruoso how are we going to implent %foo<key> := 1?

[18:44] *** Limbic_Region joined
[18:44] <ruoso> LexPad<%foo>.STORE(1)

[18:44] <ruoso> (you can save 1.FETCH here, because it would return itself anyway)

[18:45] <ruoso> ops

[18:45] <ruoso> soty

[18:45] <ruoso> sorry

[18:45] <ruoso> LexPad<%foo>.FETCH.<key>.STORE(1)

[18:45] <audreyt> something like that, yes.

[18:46] <ruoso> it's important to realise that print %foo<key> means

[18:46] <pmurias> and %foo<key> = 1 would be LexPad<%foo>.FETCH.<key>.FETCH.STORE(1)?

[18:47] <ruoso> yes 

[18:48] <ruoso> that double-boxing is also important for autovivification of arrays and hashes

[18:49] *** gaal joined
[18:50] <pmurias> you can do array and hash autovivification withought double boxing

[18:50] <ruoso> it is harder to do it  without it (including WHENCE support)

[18:51] <pmurias> so Array now needs to store a Scalar for every cell :(

[18:51] <ruoso> not really

[18:51] <ruoso> oh

[18:51] <ruoso> yes...

[18:51] <ruoso> yes..

[18:51] <ruoso> in fact..

[18:51] <ruoso> that's true...

[18:51] <pmurias> lok

[18:52] <pmurias> * lol

[18:52] * gaal mooses

[18:52] <ruoso> but I mean

[18:52] <ruoso> you don't need to actually have Array knowing about it

[18:52] <ruoso> Array just store *things*

[18:52] <ruoso> in the low-level

[18:53] <ruoso> you might return a lazy object that will, in the end, if needed, make the actual lookup

[18:53] <ruoso> in the low-level the Array doens't need to store a scalar for each cell

[18:53] <ruoso> but in the high-level it will end up doing so

[18:54] <pmurias> does anyone actually need @foo[1] := $foo?

[18:55] <ruoso> I think it's a requirement for $foo := @foo[1]

[18:56] <pmurias> no you just bind the proxy

[18:57] <audreyt> gaal: *hugs*

[18:57] <ruoso> pmurias, not really... bind forces autovivification... you need to "realise" the proxy in that case

[18:57] <audreyt> actually I think the spec says for shaped arrays you really don't need to support :=

[18:57] <audreyt> that is you can assume non-individual-bindability if you have a vector-ish array

[18:58] <audreyt> but the default Array should support arbitrary rebinding yes.

[18:58] <ruoso> yeah... shaped arrays are special cased...

[18:59] <audreyt> pmurias: storing a (potentially lazily instantiaed) Scalar per array cell is exactly what perl5 does.

[18:59] <audreyt> to wit:

[18:59] <audreyt> my @x; tie $x[0], 'main'; sub TIESCALAR {bless \@_}

[19:00] <audreyt> does exactly that.

[19:00] <ruoso> audreyt, it's important to realize that p5 doesn't really have a difference between container and value

[19:00] <audreyt> (and it ends up calling STORE if you do $x[0] = 9, but not for $x[1] = 9)

[19:00] <ruoso> you only have containers...

[19:01] <audreyt> ruoso: they share the same structure, that's true

[19:01] <audreyt> but SvREADONLY things are like values, and things with SvMG for set/get are like containers

[19:01] <audreyt> or rather, conceptually there are differences, they are just implemented in a tangly fashion for speed.

[19:02] <ruoso> in the end, that's the format we're reaching for Perl 6

[19:02] <ruoso> everything is potentially a container

[19:02] <ruoso> even if a readonly-self-container value

[19:03] <audreyt> that's one way to think about it.

[19:03] <ruoso> which pragmatically means that every value should support .FETCH()

[19:03] <ruoso> even if it returns itself

[19:03] <audreyt> well, I had it split at .ITEM and .LIST because list-context return is also a common enough case

[19:03] <audreyt> but the idea is the same, yes.

[19:05] <ruoso> maybe fetch is a wrong name anyway....

[19:05] <ruoso> it's just because the specs cite it while talking about rw subs

[19:06] <ruoso> and list context is actually .[]

[19:06] <ruoso> actually that's not what I meant

[19:06] <audreyt> yes, abstractly that is the case.

[19:06] <ruoso> but a list is only a list when calling list methods

[19:06] <gaal> audreyt! mooooose :)

[19:06] <ruoso> elsewhere it's just a value

[19:06] * gaal is pulling >1000 revisions

[19:08] <ruoso> audreyt, which basically means that a list in scalar context returns itself...

[19:08] <ruoso> as any other value

[19:08] <audreyt> ruoso: yes.

[19:10] <kolibrie> gaal: that's about how many it was for me, too

[19:10] <gaal> hey :)

[19:10] <ruoso> so the basic difference between p5 and p6 for that matter is that in p5 containers and values share a structure, in p6 they share an API

[19:11] <audreyt> ...the p5 structure also implies an api of sorts...

[19:11] <audreyt> but yes.

[19:12] <gaal> anyone seen this error? Name does not refer to a filesystem directory: Failure opening '/mirror/pugs/misc/perlhints/data/perl-6.en.dat': '/mirror/pugs/misc/perlhints/data' is not a directory in filesystem '/home/gaal/.svk/local/db

[19:13] <audreyt> no idea...

[19:13] <ruoso> audreyt, btw... what do you think about having the context as part of the capture?

[19:13] <kolibrie> nope.  svk error?

[19:13] <audreyt> gaal: svk sy -s 21644 

[19:13] <audreyt> perhaps

[19:14] <audreyt> ruoso: the calling side's capture?

[19:14] <ruoso> yes

[19:14] <pmurias> why does cabal's Setup build tell me to run Setup configure first instead of doing it?

[19:14] <ruoso> the one that is sent in the invocation

[19:14] <audreyt> ruoso: and how are you going to access your caller's context?

[19:14] <gaal> oh, another "svk pull" seems to've worked.

[19:15] <ruoso> you mean the context in which your caller was invoked

[19:15] <ruoso> ?

[19:15] <audreyt> pmurias: because it wants you to think about what flags to pass to configure...

[19:15] <audreyt> ruoso: yes

[19:15] <ruoso> hmm... good question ;)

[19:15] <clkao> oh, i did have the bootstrap dump url prop committed for pugs. you can now do svk mirror PUGSURL //mirror/pugs --bootstrap=auto

[19:15] <audreyt> ruoso: in pugs it's implicitly stored in a caller chain

[19:16] <audreyt> ruoso: but smop is stack-free?

[19:16] <pmurias> yes

[19:16] <ruoso> audreyt, yes

[19:16] <audreyt> then maybe store cxt as part of frame

[19:16] <ruoso> that's one of the most hard requirements I set

[19:16] <audreyt> and then pass the pointer to your calling frame

[19:16] <audreyt> so you still get a linked list of callers

[19:16] <audreyt> but you don't get a stack

[19:16] <ruoso> yeah... I have a "back" attribute in the frame

[19:17] <audreyt> so just store it in the frame

[19:17] <ruoso> which should point to the outer frame

[19:17] <audreyt> each frame have a context for which it was invoked

[19:18] <audreyt> wow, amazingly enough pugs builds with Parsec 3.

[19:18] <audreyt> that means no unsafePerformIO calls anywhere inside the parser.

[19:19] * audreyt benchmarks a bit

[19:22] <pmurias> ruoso: should we revert you no delegation in scalars commit so context support can be added?

[19:22] <pmurias> * your

[19:22] *** kanru left
[19:23] <ruoso> pmurias, but the contextual thing maintains that change

[19:23] <audreyt> right. having a proper context pointer means your scalar need not to be delegating.

[19:24] <ruoso> it means that eventually the runtime can figure out when NOT to fetch

[19:24] <audreyt> yup.

[19:25] <pmurias>  ruoso i just wanted the test suit to pass ;)

[19:25] <ruoso> heh... fix it then ;););)

[19:26] <ruoso> you actually just need to fix 'use v6 blocks' to make the implicit FETCH calls

[19:26] <cmarcelo> gaal: (not important, but you may want to take a look at git-svn, you can have similar functionality as svk)

[19:26] <ruoso> git-svn++ much simpler

[19:28] <pmurias> i suppose we han have unnecessary FETCH's for now

[19:28] <pmurias> s/han/can

[19:28] <ruoso> yes...

[19:29] <ruoso> that's why every value is a container (even if a readonly-self-contained-value)

[19:29] <audreyt> "all evil is premature optimization squared"

[19:29] <ruoso> heheaheaheah

[19:30] * ruoso actually took 10 seconds to understand the joke

[19:31] <gaal> even imaginary evil?

[19:31] <audreyt> negative evil leads to imaginary optimizations

[19:32] <ruoso> hehehe

[19:32] <audreyt> so for your optimizations to be real, you need to be _positively_ evil

[19:32] <audreyt> </pun>

[19:32] <gaal> I thought real evil leads to complex optimizations

[19:32] <audreyt> that too

[19:33] <audreyt> I think we all agree complex optimizations are really evil.

[19:33] <gaal> Me and my imaginary friend here do!

[19:34] <gaal> so, make worked without pulling anything from the network.. or was it a silent pull-from-the-network that Just Worked?

[19:34] <audreyt> it worked because you previously installed pugs from hackage?

[19:35] <audreyt> a pretty recent one at that?

[19:35] <gaal> no :)

[19:35] <audreyt> you got really lucky?

[19:35] <audreyt> hm.

[19:35] <audreyt> that doesn't seem like likely

[19:35] <gaal> hey, maybe i got a version of pugs from the future!

[19:35] <audreyt> did you see a lot of compilation for a lot of different modules?

[19:36] <audreyt> like "1 of 6" "1 of 25" "1 of 83"

[19:36] <gaal> ran out of scrollbuffer -- started the tests on the same window

[19:36] <audreyt> if so then it succeeded rather silently

[19:36] <gaal> Version: 6.2.13.11, fwiw

[19:36] <audreyt> k

[19:36] <audreyt> then it's not from future

[19:36] <audreyt> rather, cabal-install Just Worked

[19:37] <gaal> woot

[19:37] <gaal> and I'm not root

[19:37] <audreyt> yes

[19:37] <gaal> so it worked real well

[19:37] <audreyt> had to wait 1.5 years for it

[19:37] <gaal> someone++

[19:37] <audreyt> worth the wait though ;)

[19:37] <gaal> :)

[19:37] <audreyt> (it only worked that well since, oh, last month.)

[19:38] <gaal> so I take it MO and some other stuff is not being compiled from the pugs tree right now?

[19:38] <audreyt> correct

[19:38] <audreyt> they are from hackage.

[19:41] <pugs_svn> r21712 | pmurias++ | [smop] surplus FETCH's

[19:41] <pmurias> pugs compiled for me ;)

[19:41] *** apeiron joined
[19:43] <gaal> I think examples/algorithms/lambda-calculus.pl is looping

[19:45] <ruoso> pmurias, but I think that additional FETCHs should be done by elf smop compiler, shouldn't it?

[19:46] <pugs_svn> r21713 | ruoso++ | [smop] test/22 complete... it hangs the compiler...

[19:46] <ruoso> pmurias, could you please take a look at test/22... it hangs the compiler here...

[19:47] <audreyt> gaal: good thing that there's Time::Out support in smoke runner

[19:47] <audreyt> gaal: except you're not making smoke! fail

[19:47] <audreyt> maybe add Time::Out support to make test too?

[19:47] <audreyt> while you're at it, add T::O to Task::Smoke? :D

[19:47] <gaal> oh, my, I forgot smoke !~~ test :(

[19:48] <gaal> Yes, those are two excellent suggestions

[19:48] <gaal> Also, I'd add a big "O HAI PLS USE MEK SMOK K THX" message to "make test" :)

[19:49] * audreyt meanwhile nukes all unsafePerform* from Pugs.Parser.*

[19:50] <gaal> reminds me of old bofh .cshrc jokes, "alias nice='echo nice? you must mean kill...; kill $*'

[19:51] <gaal> and alias kill='kill -9 ; kill -9 ; kill -9'

[19:51] <gaal> except you're more like, "unsafePerformIO? Surely you mean safely perform this wonderfully pure operation!"

[19:52] <audreyt> well no, unsafePerformIO is now just liftIO

[19:52] <audreyt> parsec3, you see, is a monad transformer

[19:57] <pmurias> ruoso: the surplus ones should not be done at all

[19:57] <gaal> I should read up on it!

[19:57] <pmurias> the Var's yes...

[19:57] <ruoso> hm?

[19:57] <ruoso> what do you mean?

[19:57] * gaal would love for a ByteString Parsec

[19:58] <audreyt> attoparsec.

[19:58] *** jhorwitz joined
[19:58] <audreyt> also parsec3 is polymorphic to bytestring.

[19:58] <audreyt> also the new "binary" parsers are good as well.

[19:58] <audreyt> lots of choices

[19:58] <pmurias> ruoso: FETCH's shouldn't be done for method calls in item context

[19:59] <audreyt> gaal: but if performance is of concern and you'd like to maintain parsec api compat, attoparsec makes it ~trivial to part

[19:59] <audreyt> *port

[20:00] <pmurias> ruoso: re sm0p hanging, i could rewrite sm0p using Parsec

[20:00] *** hercynium left
[20:00] <ruoso> pmurias, the implicit FETCH should be made by the compiler...

[20:00] <ruoso> I just added it explicitly because it seems that it's not being done yet...

[20:01] <ruoso> pmurias, well... you're the author of the sm0p compiler now ;) feel free to rewrite it if you think that's needed ;)

[20:01] <pmurias> sm0p--

[20:01] <pmurias> slime--

[20:01] <audreyt> where is code to mold btw?

[20:02] <gaal> interesting! though I think it's possibly more pressing to do the precompilation cache

[20:02] <audreyt> as in http://www.perlfoundation.org/perl6/index.cgi?smop_mold

[20:02] <lambdabot> Title: SMOP Mold / Perl 6

[20:02] <audreyt> gaal: also we don't use yaml now, we use Data.Binar

[20:02] <audreyt> y

[20:02] <audreyt> which is like storable

[20:02] <gaal> yes

[20:02] <audreyt> which makes startup like 2x-3x faster

[20:02] <gaal> <3

[20:02] <audreyt> also we can freely use dons's sqlite3 package

[20:03] <audreyt> to maintain precompilation cache

[20:03] <audreyt> that might be overkill

[20:03] <audreyt> but might not

[20:03] <Limbic_Region> audreyt are you sleeping now?

[20:03] <audreyt> at least there's a reliable place to put the cache now

[20:03] <pmurias> audreyt: mold is not yet implemented

[20:04] <pmurias> :(

[20:04] <audreyt> cache <- getDataFileName "cache"

[20:04] <audreyt> Limbic_Region: yes, why?

[20:04] <gaal> wow, lots of new stuff in haskelland

[20:05] <gaal> hoogle doesn't know about that though :(

[20:05] <audreyt> getDataFileName?

[20:05] <audreyt> it's part of Cabal

[20:05] <audreyt> http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html

[20:05] <ruoso> audreyt, what there's currently is SLIME

[20:05] <lambdabot> Title: Neil Mitchell's Haskell Blog: Adding data files using Cabal, http://tinyurl.com/364awx

[20:05] <gaal> oh

[20:05] <Limbic_Region> audreyt - no reason other than it will take a while to get used to the productive audreyt of sleepland versus the productive audreyt of active hacking land

[20:05] <pmurias> audreyt: i was waiting for the metamodel bootstrap to have the classes in perl6, btw. why do you ask?

[20:05] <ruoso> audreyt, the Smop Lame Interpreter iMplEmentation

[20:05] <audreyt> it's like File::ShareDir.

[20:06] *** Chillance left
[20:06] <audreyt> pmurias: just reading up on it... I really like what I'm seeing so far on v6/smop/ and so am wondering the logical next interpreter

[20:07] <audreyt> how will it turn out to be, etc.

[20:07] <audreyt> (bbiab)

[20:07] <ruoso> pmurias, but do you have any idea on how to make test/22 to compile?

[20:07] <ruoso> what's interesting is that it hangs without consuming any CPU or additional memory...

[20:09] <pmurias> undefined reference to `__stginit_parseczm2zi1zi0zi0_TextziParserCombinatorsziParsec_'

[20:09] <ruoso> ouch

[20:09] <pmurias> parsec.o: In function `smW_info':

[20:10] <pmurias> ruoso: re test/22 moving code around can solve it ;)

[20:10] <ruoso> what do you mean?

[20:11] <pmurias> i have completly no idead why and when it happens, but i encoutered it before and it went away when i rewrote the p6 block

[20:12] <audreyt> pmurias: is my checkout broken or is v6/smop/src/smop_lowlevel.c really truncated?

[20:12] <ruoso> audreyt, that file is compiled from smop_lowlevel.sm0p

[20:12] <ruoso> just touch src/smop_lowlevel.sm0p

[20:12] <audreyt> I see.

[20:13] <ruoso> sometimes it stays around... but I don't see why...

[20:13] <audreyt> ah. that reminds me. mac still cannot run ::TRE.

[20:14] <Limbic_Region> audreyt - avar hangs out on #perl on this network

[20:14] <audreyt> avar is here actually.

[20:15] <Limbic_Region> oh, heh

[20:15] <Limbic_Region> well, I stopped hanging out here regularly (and #parrot and perlmonks) and most everywhere else when Alyssa was born

[20:21] <Limbic_Region> unrefutable proof that having children reduces "free time" - http://use.perl.org/~Limbic+Region/journal/36996

[20:21] <lambdabot> Title: Journal of Limbic Region (3985)

[20:24] <pugs_svn> r21714 | ruoso++ | [smop] uses ___UNKNOWN_METHOD___; in bool.

[20:24] <pugs_svn> r21714 | ruoso++ | move_responder set "false" when the result was NULL (we need a failure object).

[20:24] <pugs_svn> r21714 | ruoso++ | test/22 compiles with four lines commented out... I am testing the attribute create_container call, and that is the most important one.

[20:25] <pugs_svn> r21715 | audreyt++ | * Path_Pugs: Point to our shared directory even before installing,

[20:25] <pugs_svn> r21715 | audreyt++ |   to get consistent ghci/ghc behaviours.

[20:26] <audreyt> parsec3 means double the smoke time. not worth the peace-of-mind of ditching unsafePerformIO. sigh

[20:26] * audreyt scraps that patch and calls it a day &

[20:28] <pugs_svn> r21716 | ruoso++ | [smop] mark the commented out lines as todo in the test result

[20:29] *** Limbic_Region left
[20:31] <pmurias> ruoso: do you think doing m0ld in haskell is a sane idea?

[20:31] <ruoso> you mean the runtime itself?

[20:32] <pmurias> just the language, emitting only a c file

[20:33] <pmurias> language being the sm0p equivalent

[20:33] <pmurias> maybe even a bytecode file 

[20:33] *** wknight8111 left
[20:33] <pmurias> that is emitting a bytecode file

[20:34] <kolibrie> audreyt: thanks for all the work you did today

[20:34] <kolibrie> &

[20:34] <ruoso> pmurias, so you mean the compiler in haskell...

[20:34] <ruoso> not the runtime support

[20:35] *** Lorn left
[20:35] <ruoso> I think for this helper compilers, we should use the tools that helps us most with absolutely no restrictions...

[20:35] <ruoso> for the runtime itself, it would be cool if we could have something that doesn't include a complete different runtime

[20:36] <pmurias> different from smop?

[20:36] <pmurias> i would omit the runtime Mold frame creation/introspection

[20:36] <pmurias> i meant different from slime

[20:37] <ruoso> different from slime is ok...

[20:37] <ruoso> but it would be nice if we stay in plain C

[20:37] <ruoso> instead of adding another runtime infraestructure

[20:37] <ruoso> i.e. haskell

[20:37] <ruoso> but that restriction doesn't apply for the compiler...

[20:37] <pmurias> i'm not proficient enough with haskell use it as a runtime

[20:38] <ruoso> btw... the problem with freezing sm0p is the blocking IO

[20:40] <ruoso> I need to re-implement sub preprocess with non-blocking IO... it's blocking waiting for some output of ../../src/perl6

[20:41] * ruoso home &

[20:41] * ruoso will backlog, as usual...

[20:41] *** ruoso left
[20:42] <pmurias> the parsec error turned up to be my haskell noobines

[20:42] <pmurias> i have to add a --make flag to ghc

[20:47] <pugs_svn> r21717 | fglock++ | [v6.pm] more tests;

[20:47] <pugs_svn> r21717 | fglock++ | - added script: util/clear_cache.pl - empty the precompilation cache for both v6 and PCR;

[20:47] <pugs_svn> r21717 | fglock++ | - svn properties

[21:03] *** wknight8111 joined
[21:11] *** TJCRI joined
[21:48] *** simcop2387 left
[21:54] *** jferrero joined
[21:57] *** TJCRI left
[22:03] *** simcop2387 joined
[22:06] *** pmurias left
[22:17] <pugs_svn> r21718 | Auzon++ | [evalbot] I think I finally fixed evalbot's STD.pm.

[22:20] *** jdv79 left
[22:20] *** jdv79 joined
[22:25] *** alester left
[22:27] *** p6eval left
[22:27] *** p6eval joined
[22:38] *** rafl_ joined
[22:44] *** peeps[work] left
[22:46] *** simcop2387 left
[22:51] *** rafl left
[22:54] <TimToady> std: $a->foo();

[22:54] <p6eval> std 21665: OUTPUT[parse ok]

[22:54] *** alester joined
[22:55] <TimToady> hmm, should complain: Obsolete use of -> to call a method; in Perl 6 please use . instead at line 1:

[22:57] *** Sebastian_Knapp joined
[22:58] <TimToady> std: $foo $bar

[22:58] <p6eval> std 21665: OUTPUT[parse ok]

[23:04] <TimToady> std: do {

[23:04] <p6eval> std 21665: OUTPUT[parse ok]

[23:04] <TimToady> std seems very accepting these days...

[23:09] <avar> audreyt: do you get this error on re::engine::TRE: http://www.nntp.perl.org/group/perl.cpan.testers/2008/06/msg1750616.html ?

[23:09] <lambdabot> Title: FAIL re-engine-TRE-0.04 darwin-thread-multi-64int-2level 8.10.0 - nntp.perl.org, http://tinyurl.com/5bfehs

[23:13] *** jferrero left
[23:14] <TimToady> I hope to abandon TRE soonish, since it is rather resource intensive on large numbers of alternatives

[23:15] *** jferrero joined
[23:17] *** alester left
[23:17] *** alester joined
[23:18] *** alester left
[23:20] <TimToady> I'm now running STD on all of t/ to see how well it does

[23:20] *** luqui joined
[23:26] <TimToady> at first blush looks like there's a lot of old pod5 in there...

[23:26] <TimToady> I need to catch that and report it as obsolete, I suppose...

[23:29] *** Exodist left
[23:35] *** drbean joined
[23:35] *** BinGOs_ joined
[23:35] *** Limbic_Region joined
[23:37] *** jfredett_ is now known as jfredett

[23:43] *** fridim_ left
[23:43] *** simcop2387 joined
[23:49] *** BinGOs left
