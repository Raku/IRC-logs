[00:02] *** jferrero joined
[00:05] *** p6quester left
[00:05] *** p6quester_ joined
[00:07] *** theorb joined
[00:15] *** p6quester_ left
[00:15] *** __Ace__ joined
[00:16] *** p6quester joined
[00:19] *** theorbtwo left
[00:21] *** thoughtpolice left
[00:22] *** p6quester left
[00:22] *** explorer__ joined
[00:23] *** p6quester__ joined
[00:26] *** explorer__ left
[00:26] *** explorer__ joined
[00:27] <pugs_svn> r19300 | lwall++ | Clarification of substr requested by Gothmog++ and pmurias++

[00:28] <Limbic_Region> TimToady ping

[00:28] <TimToady> pong

[00:29] <Limbic_Region> I have been working my way through the synopses very slowly

[00:29] <Limbic_Region> I have come to a conclusion - perhaps one you already recognized

[00:29] <Limbic_Region> they are too dense for anyone to learn perl 6 from

[00:29] <TimToady> they're not tutorials, fershure

[00:30] <Tene> Limbic_Region: I learned Perl 6 from them.

[00:30] <Limbic_Region> Tene - I assure you, I am talking objectively for the majority and not subjectively for a few

[00:30] <Tene> Well, I already knew Perl 5.

[00:30] <Tene> Limbic_Region: Okay.

[00:31] <Limbic_Region> TimToady - so, is there a specific project to make the documentation more accessible or is the idea to wait for Learning Perl 6?

[00:32] <TimToady> It's certainly something that needs doing one way or another.

[00:32] <TimToady> The synopses aren't even in any kind of rational order internally; the only one that has actually ever been reorganized is S03

[00:33] <Limbic_Region> well, I have some ideas but it really requires a collaborative effort

[00:34] *** p6quester__ left
[00:35] <Limbic_Region> TimToady - in a nutshell, I think almost every new non-perl 5 concept requires a mini-tutorial

[00:36] *** p6quester joined
[00:36] <Limbic_Region> traits, roles, mixins, the advanced type system, etc

[00:39] <TimToady> (sorry, watching Rose Bowl...)

[00:39] <Limbic_Region> no worries - I am not into college football, but being from Maine - I was very much interested in the Patriots this past Saturday

[00:39] *** jferrero left
[00:42] <Limbic_Region> TimToady - in any event, as I work through these synopses I want to write code to assimilate it.  I am having a hard time doing this because the code snippets are far too concise.

[00:43] <Limbic_Region> TimToady - once the code is written, I think it would be a nice contribution to a tutorialish type doc project

[00:43] <Limbic_Region> TimToady - but I am going to need a really in the know resource to help me as I stumble through

[00:44] * Limbic_Region AFK but will be back in a bit

[00:44] *** r0bby joined
[00:47] <wolverian> Limbic_Region, Learning Perl 6?

[00:59] *** p6quester left
[01:01] *** p6quester joined
[01:04] *** seablue100 joined
[01:04] *** _sprocket_ joined
[01:08] *** seagreen100 joined
[01:09] *** p6quester left
[01:09] <meppuru> good night

[01:10] *** kanru left
[01:14] *** meppuru left
[01:15] *** chris2 left
[01:17] <[particle1> pugs: :8<0.0>

[01:17] <exp_evalbot> RESULT[0/1]

[01:17] *** [particle1 is now known as [particle]

[01:18] *** cnhackTNT joined
[01:18] <[particle]> pugs: say :8<0.1**2>

[01:18] <exp_evalbot> OUTPUT[0.15625␤]

[01:23] <[particle]> pugs: say :8<0.1*2**2>

[01:23] <exp_evalbot> OUTPUT[0.16015625␤]

[01:24] *** seablue100 left
[01:26] <TimToady> doesn't look right to me

[01:26] <[particle]> me neither

[01:26] <[particle]> not terribly surprising, given the lack of tests

[01:26] <TimToady> and the first form is illegal syntax

[01:26] <[particle]> however, i think STD is wrong, too

[01:26] <[particle]> yes, that's what i see in STD, the first form is illegal

[01:26] *** thoughtpolice joined
[01:26] <[particle]> $<radfrac> = [ '.' <[ 0..9 a..z A..Z ]>+ ]? ] # one too many ']' ??

[01:27] <[particle]> (in token rad_number)

[01:27] *** _sprocket_ left
[01:28] <pugs_svn> r19301 | lwall++ | Extra right bracket noticed by [particle]]++

[01:29] <[particle]> ha! also, having an alias called 'radint' as well as a rule called 'radint' is potentially confusing

[01:29] <TimToady> prolly

[01:34] *** han_ joined
[01:36] <pugs_svn> r19302 | lwall++ | [STD] "radint" ambiguity pointed out by [particle]++

[01:38] *** JarJarBinks left
[01:39] <[particle]> is $<fracpart> an array, and is '.' captured?

[01:40] *** justatheory joined
[01:50] *** alester joined
[01:52] <TimToady> no, [...] just captures a string

[01:52] *** seablue100 joined
[01:53] <pugs_svn> r19303 | lwall++ | Another spurious bracket

[01:53] <[particle]> hrmm, i'll need to come up with a perl6 replacement  for radint, since we don't have <?{...}> yet

[01:53] <[particle]> i'll hardcode the bits of rad_number that matter

[02:01] <[particle]> TimToady: how's this look? http://rafb.net/p/eOSFla31.html

[02:02] *** devogon left
[02:08] <TimToady> seems pretty okay

[02:09] *** seagreen100 left
[02:09] <pugs_svn> r19304 | lwall++ | Previous radint change was incomplete.

[02:13] <TimToady> in fact, I might end up refactoring STD that way

[02:15] *** jjore-m joined
[02:32] <[particle]> it's likely a *very* minor optimization

[02:34] <Limbic_Region> TimToady - was the outcome of the Rose Bowl what you wanted?

[02:35] <[particle]> damned you, georgia!

[02:35] *** explorer__ left
[02:35] *** jisom joined
[02:36] <[particle]> l_r: my team came awful close to kicking your team's butt

[02:36] <[particle]> ...saturday.

[02:38] <Limbic_Region> [particle] - um, came close to winning perhaps - butt kicking, I think not

[02:38] <[particle]> TimToady: my refactor of radint allows my grammar action for radint to be *very* simple: method radint($/, $key) { make $( $/{$key} ); }

[02:50] <[particle]> TimToady: :8<0b1110> doesn't seem to be a valid rad_number... you need [...] or (...) in order to parse it. is that intended?

[02:50] <TimToady> yes

[02:51] <[particle]> ok, then t/syntax/numbers/octal.t is wrong

[02:52] <[particle]> ...and likely some other t/syntax/numbers tests

[02:52] <[particle]> */ tests

[02:53] <[particle]> ack. window transparency fooled me into thinking i had mistated myself

[02:53] <TimToady> actually, :8<0b1110> should parse but fail in radcalc with an invalid digit, I think

[02:54] <TimToady> I can see the argument for allowing it though

[02:54] <[particle]> in perl6 it fails to parse, with Statement not terminated properly at line 43, near "(:8<0b1110"

[02:54] <[particle]> that's the expected error for a failed statement

[02:54] <TimToady> nevertheless, :16<0b1110> is certainly a hex number

[02:55] <[particle]> in any case, the tests are wrong, because the smart link points to # L<S02/Literals/"Think of these as setting the default radix">

[02:55] <TimToady> well, you can't have separate rules for every radix

[02:55] <[particle]> but it's talking about :8($x) not :8<$x>

[02:56] <TimToady> yes, the question is whether the same calculation is done by radcalc, and how does it know that the 8 in that case is just a default radix?

[02:57] <TimToady> if radcalc is used for both purposes, all it can do is guess based on the suggested radix, since 0b is illegal octal and decimal, but valid hex

[02:58] <TimToady> alternately, radcalc needs a flag to tell it whether to guess based on the string prefix

[02:58] <[particle]> radcalc has enough args to justify named args imo

[02:58] <TimToady> in which case the default should be to not guess, I guess

[02:58] <[particle]> agreed

[02:59] <TimToady> but I'd really like to allow people to say 0xdeadbeef where a decimal is expected on input

[02:59] <TimToady> it's just the literal forms that don't make sense with :10<0xdeadbeef>

[03:00] <TimToady> that's just perverse

[03:00] <[particle]> please! you've got to keep *some* of perl's perversity!

[03:01] <TimToady> I think that'll happen by accident in any case. :)

[03:01] <[particle]> ha! no doubt.

[03:01] <[particle]> perl6 doesn't seem to parse :8(0b1), which i find odd

[03:04] <[particle]> since integer is a number is a value is a noun is a term

[03:05] <[particle]> i suppose :8(<0xdeadbeef>) is workable

[03:08] <[particle]> token integer in STD doesn't mesh with S02. i don't see where \0 is defined

[03:10] <[particle]> from S02:2046

[03:13] *** han_ left
[03:19] *** _sprocket_ joined
[03:20] *** jjore-m left
[03:22] <pugs_svn> r19305 | lwall++ | [STD] qq_backslash for \0 missing, [particle]++

[03:24] *** lampus_ joined
[03:31] *** _sprocket__ joined
[03:37] *** _sprocket_ left
[03:42] *** _sprocket_ joined
[03:42] *** lampus left
[03:44] *** _sprocket___ joined
[03:50] *** awwaiid left
[03:50] *** awwaiid joined
[03:50] *** _sprocket__ left
[03:53] *** kanru joined
[03:59] *** _sprocket_ left
[04:00] *** _sprocket___ left
[04:03] *** lampus joined
[04:20] *** lampus_ left
[04:26] *** lampus_ joined
[04:26] *** lampus_ left
[04:37] *** markstos left
[04:38] *** lampus left
[04:39] <wolverian> is adriano ferreira here? 

[04:40] <wolverian> we were talking about http://www.oreillynet.com/onlamp/blog/2007/12/yap6_operator_reduce_operators_1.html on an unnamed #perl, and were wondering if <!after '/'> makes sense in the context, and if the = in =[\~] is really needed

[04:45] <TimToady> the = is unnecessary there

[04:46] <TimToady> [\X] always produces a list

[04:49] <wolverian> that's what I thought

[04:49] <wolverian> how about the <!after '/'>? seems it should be just <after />?

[04:50] <Tene> pugs: split /<!after '/'>/, 'foo/bar/baz'

[04:50] <exp_evalbot> OUTPUT[*** ␤    Unexpected "'>/,"␤    expecting term postfix, operator, ":" or ","␤    at /tmp/i30GNfTlBQ line 1, column 18␤]

[04:50] <Tene> pugs: split /<!after '\/'>/, 'foo/bar/baz'

[04:50] <exp_evalbot> OUTPUT[*** Cannot parse regex: <!after '\/'>␤*** Error: Error: Undefined subroutine &Pugs::Emitter::Rule::Perl5::after called at /home/evalenv/pugs/perl5/Pugs-Compiler-Rule/lib/Pugs/Emitter/Rule/Perl5.pm line 124.␤␤]

[04:53] <TimToady> well, these days <?after /> would be more like it

[04:53] <wolverian> ah, okay.

[04:54] <wolverian> there's one <after in S05

[04:58] <TimToady> <after is okay, but captures to $<after> by default

[05:03] *** lorn joined
[05:11] <wolverian> righto, should have read. thanks again :)

[05:11] <wolverian> now, sleep

[05:13] *** Daveman joined
[05:15] <Limbic_Region> TimToady - does your local church make audio of weekly sermons available online?

[05:18] <Limbic_Region> nevermind - I followed the link from your website and apparently the answer is yes

[05:20] *** nothingmuch left
[05:20] *** jisom left
[05:21] <TimToady> reminds me, I have a .wav I need to turn into a .mp3 at some point for 12/16

[05:29] *** nothingmuch joined
[05:39] *** p6quester joined
[05:41] *** thoughtp1lice joined
[05:53] *** theorb left
[05:53] *** thoughtpolice left
[06:00] *** Limbic_Region left
[06:01] <seablue100> in STD.pm, what is unsp and unv?

[06:14] *** seablue100 left
[06:23] *** thoughtp1lice is now known as thoughtpolice

[06:31] *** alc joined
[06:53] *** dduncan joined
[06:55] *** cnhackTNT left
[06:55] *** cnhackTNT joined
[07:04] *** xinming left
[07:07] *** Auzon left
[07:08] *** dduncan left
[07:12] *** mattz left
[07:18] *** alester left
[07:18] *** alester joined
[07:24] *** iblechbot joined
[07:31] <pugs_svn> r19306 | pmichaud++ | Some initial test refactors and cleanups for basic operators.

[07:34] <pugs_svn> r19307 | pmichaud++ | add some comments to existing tests about refactoring targets.

[07:43] *** drrho joined
[07:48] *** Aankhen`` joined
[07:56] *** lyokato_ joined
[07:59] *** BinGOs left
[08:05] *** han_ joined
[08:05] *** BinGOs joined
[08:08] *** alester left
[08:11] *** BinGOs left
[08:17] *** BinGOs joined
[08:24] *** chacha_chaudhry joined
[08:24] *** idiotmax joined
[08:38] *** iblechbot left
[08:38] *** meppuru joined
[08:46] *** IllvilJa joined
[09:10] *** H0LE joined
[09:20] *** devogon joined
[09:23] *** ruoso joined
[09:38] *** penk joined
[09:39] *** drrho left
[09:55] *** elmex joined
[10:07] *** cnhackTNT left
[10:07] *** H0LE left
[10:13] *** jferrero joined
[10:29] *** theorbtwo joined
[10:35] *** p6quester left
[11:04] *** meppuru left
[11:24] *** chris2 joined
[11:40] *** polettix left
[11:41] *** polettix joined
[11:56] *** IllvilJa left
[11:57] *** jiing left
[12:14] *** fglock_ joined
[12:14] *** fglock_ is now known as fglock

[12:32] *** alc left
[12:33] *** han_ left
[12:46] *** Daveman left
[12:49] *** iblechbot joined
[12:59] *** __Ace__ left
[13:02] *** pmurias joined
[13:02] <pmurias> fglock: hi

[13:03] <fglock> pmurias: hi

[13:03] <pmurias> fglock: have you seen the Perl5V6 backend?

[13:03] <fglock> not yet - I saw the commits

[13:04] *** elmex left
[13:06] <pmurias> the thing i'm not sure how should be done is the calling convention

[13:08] <pmurias> should i remove Perl5Cached and TokenC?

[13:09] *** cmarcelo joined
[13:16] <fglock> you mean, you need to know how the v6.pm calling convention works?

[13:16] *** jferrero left
[13:17] <pmurias> fglock: i'm not sure if using the v6.pm calling convention is the right thing

[13:18] <pmurias> i haven't looked into Data::Bind internals but read the (scant) docs and looked at he test suit,so it's no a problem

[13:19] *** lyokato_ left
[13:20] <pmurias> i wrote a primitive benchmark misc/calling_convention_benchmark.pl, and i'm not sure if it won't be a big performance hit

[13:21] <fglock> yes, you could keep most of the current kp6-perl5, and replace the object system and binding only

[13:21] <fglock> I'm not sure what problems you will find ahead

[13:21] <fglock> but it's worth trying

[13:23] <pmurias> fglock: does anything problematic come to your mind?

[13:23] <pmurias> (besides concurency)

[13:23] <pmurias> what parts do you think we could keep?

[13:24] <fglock> hmm - there is the BEGIN problem, which we fixed by using the "modified" flag

[13:24] <pugs_svn> r19308 | pmurias++ | [kp6] removed KindaPerl6::Visitor::Emit::Perl5Cached

[13:25] <fglock> re keep, kp6-perl5 parameter passing is better than v6.pm

[13:25] <pmurias> fglock: the way i plan to keep it for now is to use the orginal Perl5 backend for begin blocks

[13:25] <fglock> yes, but it will break when it bootstraps

[13:26] <fglock> the Parrot backend has the same problem

[13:26] <fglock> weird, the Parrot backend has more problems than the Perl5 backend

[13:26] <pmurias> fglock: we can keep it for a bit after the bootstrap, and switch to saving the env later

[13:28] <pmurias> the Perl5V6 was going pretty smooth 

[13:29] <pmurias> s/was/is

[13:29] <fglock> :)

[13:30] <fglock> you could emit the "modified" flags - the first versions of kp6 used to work like that

[13:31] <fglock> or you could just ignore it for now, just leave some comments in the code

[13:31] *** thoughtpolice left
[13:31] *** pmccann_ joined
[13:31] <pmurias> fglock: i would strongly prefare the later

[13:31] <fglock> ok

[13:32] <fglock> that's how "perl6" works

[13:34] <fglock> hmm - I wonder if the Coro module could give us enough introspection to make a dump of the compile-time environment

[13:40] <fglock> doesn't seem so

[13:40] <pmurias> fglock: it think the contrary

[13:41] <pmurias> Coro::State::call

[13:43] *** lichtkind joined
[13:43] <pmurias> Pad::eval_ast seems to use Emit::Perl5V6 is it possible?

[13:43] <fglock> $state->eval looks useful - I liked the comments too

[13:44] <lichtkind> is it true that array munging operators were especially inspired my haskell or similiar languages?

[13:45] <fglock> pmurias: $visitor_emit_perl5 is hardcoded in Pad.pm

[13:45] <pmurias> yes

[13:45] <pmurias> try script/kp6 -Bperl5v6 t/kp6/06-begin.t

[13:47] <fglock> one sec

[13:49] <fglock> pmurias: do you get this error? Can't use string ("2") as a HASH ref while "strict refs" ... Perl5/Pad.pm line 422

[13:49] <pmurias> yes

[13:54] *** chruck left
[13:56] <pmurias> fglock: why do we need to use Coro, isn't PadWalker enough?

[13:57] <fglock> PadWalker needs to be executed from inside the closure, I thought Coro could give some other options

[14:00] <pmurias> ah

[14:01] <pmurias> $stuff but other&

[14:07] <fglock> pmurias: re emit_perl5 x emit_perl5v6, "class Lit::Code" is redefining several methods

[14:10] *** alester joined
[14:13] *** pmccann_ left
[14:14] <pmurias> fglock: thanks, fixing

[14:14] <fglock> pmurias: I'm fixing here

[14:14] <fglock> didn't work - please go on :P

[14:15] <fglock> ok, got it

[14:15] <pugs_svn> r19309 | fglock++ | [kp6-v6] fixed method name collision

[14:16] *** chacha_chaudhry left
[14:18] *** jhorwitz joined
[14:19] <pmurias> 3 tests more pass :)

[14:24] *** alester left
[14:35] *** overlast1 joined
[14:37] *** chris2_ joined
[14:43] *** chris2 left
[14:45] <avar> why make it run on v6 isn't that pre-mp6?

[14:46] *** pjcj left
[14:47] <pmurias> avar: the name is misleading

[14:47] <pmurias> Perl5V6 emits perl5

[14:47] *** han_ joined
[14:48] <pmurias> but does it in a style similiar to v6, maping directly to perl5 instead of creating a layer between

[14:49] <pmurias> avar: if you can think up a better name, suggest it ;)

[14:49] <avar> I thought it was using v6.pm

[14:49] <fglock> avar: it is using v6.pm "runtime"

[14:50] <pmurias> Data::Bind that is

[14:50] <fglock> that is, Moose and Data::Bind

[14:51] <pmurias> by the way help on it is welcome ;)

[14:52] <avar> can you paste some generated code for this and the normal perl5 backend? It would be interesting to see what p5-directly looks like

[14:52] <pmurias> s/on/with/

[14:52] <pmurias> avar: use can use script/kp6 -Cperl5v6

[14:53] <pmurias> avar: or do you want be to nopaste some code?

[14:55] <pasteling> Someone at 81.168.228.98 pasted "../../t/01-sanity/01-tap.t #kp6 -Cperl5v6" (32 lines, 890B) at http://sial.org/pbot/29541

[14:56] <pasteling> Someone at 81.168.228.98 pasted "../../t/01-sanity/01-tap.t #kp6 -Cperl5" (50 lines, 3.1K) at http://sial.org/pbot/29542

[14:57] <pmurias> pasted 01-sanity/01-tap.t

[14:58] <avar> interesting

[15:14] *** _sprocket_ joined
[15:21] <ruoso> fglock, did you get to any conclusion on my capture's question?

[15:27] <fglock> ruoso: no

[15:28] *** ebassi joined
[15:30] <fglock> brb

[15:31] *** mncharity joined
[15:36] *** han_ left
[15:38] *** kanru left
[15:39] *** |Jedai| joined
[15:44] <fglock> mncharity: hi

[15:45] <ruoso> TimToady, could you please ellaborate more on captures in the specs? I'm having a hard time getting how they should behave...

[15:47] *** pjcj joined
[15:49] *** acmoore left
[15:52] *** thoughtpolice joined
[15:57] *** TJCRI joined
[15:58] *** jedai left
[16:03] *** _sprocket_ left
[16:18] *** alester joined
[16:24] *** rindolf joined
[16:29] *** rindolf left
[16:30] <PerlJam> ruoso: captures are an unruly bunch. They don't behave.

[16:31] *** Psyche^ joined
[16:31] <TimToady> I seem to have missed the question

[16:32] <TimToady> and do you mean captures or Captures?

[16:32] <mncharity> hi fglock! :)

[16:38] *** barney joined
[16:46] *** Patterner left
[16:46] *** Psyche^ is now known as Patterner

[16:48] <ruoso> TimToady, Captures

[16:49] <ruoso> TimToady, as in $a = \(1,2,3); or in $a := %a<b><c>

[16:51] <TimToady> what would you like elaborated?

[16:53] <ruoso> how does \%a<b><c> affects %a<b><c>

[16:53] <ruoso> is one of the things

[16:53] <ruoso> should capture creation be understood as a "context", as would be scalar?

[16:53] <PerlJam> ruoso: taking the Capture doesn't do anything to the underlying data structure AFAIK if that's what you're asking.

[16:54] <ruoso> PerlJam, you see, that's the point where I get confused...

[16:54] <ruoso> how then \%a<b><c> autovivifies the hash, while just %a<b><c> doesn't

[16:55] <TimToady> it should not autovivify unless bound to something rw

[16:55] <ruoso> hmmm...

[16:55] * ruoso looking again

[16:55] <TimToady> just as foo(%a<b><c>) doesn't autovivify unless its first parameter is rw

[16:56] <ruoso> my $a = \%a<b><c> autovivifies

[16:56] <TimToady> a Capture is just a snapshot of an unbound argument list

[16:56] <TimToady> "my $a" defines a rw variable

[16:56] <TimToady> so yes

[16:57] <ruoso> ok... how should a Capture object look like/

[16:57] <ruoso> ?

[16:57] <ruoso> thinking about data structures

[16:57] <TimToady> that's an implementation detail  :P

[16:57] <ruoso> ok... I need some help with that...

[16:57] <ruoso> :)

[16:58] <PerlJam> ruoso: I think TimToady is only good for suppositional implementations these days  :)

[16:58] <ruoso> I still can't figure out how the capture binding can trigger the autovivification

[16:58] <ruoso> be it to a variable or to a signature

[16:59] <ruoso> PerlJam, a supositional would be enough for me now...

[16:59] <ruoso> :)

[16:59] <PerlJam> ruoso: okay, suppose you have a spherical cow of uniform density ...

[17:00] *** penk left
[17:00] <TimToady> and suppose that cow can contain a Failure that knows how to autovivify something in order to "unfail"

[17:00] *** rindolf joined
[17:00] <ruoso> ok

[17:01] <TimToady> and suppose an rw binding looks at the cow, and calls the autovivify method on it

[17:01] <TimToady> only without the cow

[17:01] <ruoso> ok, so the binding process should explicitly call the autovivification?

[17:01] <ruoso> hmmm

[17:01] <ruoso> I was counting on that being part of the logic of the array and hash types

[17:02] <TimToady> if it needs an rw binding

[17:02] <rindolf> Hi all.

[17:02] <rindolf> Hi TimToady , ruoso 

[17:02] <ruoso> hi rindolf 

[17:02] <rindolf> Happy new year.

[17:02] <TimToady> hi rindolf, happy solar new year

[17:02] <TimToady> or at least, civic...

[17:03] <ruoso> so, a Capture is just a container object that doesn't enforce any context, is it?

[17:03] <TimToady> basically. context is enforced lazily by binding

[17:03] <rindolf> TimToady: thanks.

[17:03] <rindolf> TimToady: what's up?

[17:03] <TimToady> that's how we get out of most of the nasty Perl 5 traps

[17:04] <TimToady> and why signatures work much better than prototypes

[17:04] <TimToady> and can work on methods as well as functions

[17:04] <PerlJam> TimToady: more evidence of Laziness as a virtue.

[17:04] <ruoso> ok... If i let the autovivification to be a feature of the interpreter in itself, instead of a feature of the array type

[17:04] <ruoso> or the hash type

[17:04] <ruoso> I mean

[17:04] <ruoso> instead of the array and hash autovivify by themselves,

[17:04] <ruoso> the binding code would do it

[17:05] <TimToady> well, the binding code just knows how to tell the "nonexistence" Failure object to undo itself

[17:05] <TimToady> and that object knows how to tell the hash or array to create the required value

[17:06] <TimToady> but the hash or array still has to participate

[17:06] <ruoso> Ok...

[17:06] <ruoso> that clarifies a lot

[17:07] <TimToady> most of the time, in rvalue context, a Failure just looks like "undef" to a Perl 5 programmer, but that's just because in real rvalue context it's never going to be bound to something rw

[17:08] <TimToady> and, of course, if the compiler can detect that, it can maybe optimize away some of the autoviv apparatus, if it's heavy

[17:08] <TimToady> but maybe it isn't.

[17:08] <ruoso> but... wasn't Failure supposed to raise an exception?

[17:09] <ruoso> or is this just yet another undef type and not exactly a failure

[17:09] <TimToady> Failure throws an exception only if 1) you've said "use fatal" or 2) you try to use the actual value from it.

[17:10] <TimToady> it's possible that most Failure objects are actually typed correctly for the return value expected, so they're really protoobjects that know they're also Failures

[17:11] <ruoso> hmmm... I understood that the "use fatal" would make them to raise the exception in-time instead of lazy

[17:11] <TimToady> so if you have a hash that you know returns Dog, you really get an undefined Dog out of it, and that Dog knows how to autoviv itself to a real dog object

[17:11] <TimToady> er, that's what I just said under 1)

[17:12] <TimToady> use fatal makes it throw and exception immediately

[17:12] <ruoso> ah... ok...

[17:12] <ruoso> So, if you just ignore the return is the same as catching the failure

[17:12] <TimToady> so, I guess you don't get any autoviv under "use fatal" either...

[17:12] <ruoso> that's odd

[17:13] <TimToady> maybe the return protoobjects aren't considered failures then, unless you "use fataler"

[17:13] * ruoso remembers reading that the failure would raise when getting out of the scope... isn't ignoring return a way of getting the value out of scope?

[17:15] <TimToady> hmm, yeah, I recall something like that too...

[17:15] <ruoso> anyway...

[17:15] <ruoso> wouldn't Unintialized a better definition of the non-existant?

[17:16] <TimToady> that's what a protoobject means

[17:16] <ruoso> so, uninitialized is not a failure, is it?

[17:16] <TimToady> correct

[17:16] <ruoso> ok..

[17:17] <TimToady> so if autovivifyers return protoobjects instead of failures, that would allow autoviv under fatal

[17:17] <ruoso> so the autovivification triggering belongs to the Uninitialized object

[17:17] <TimToady> which seems right

[17:17] <TimToady> lemme think about it in the shower

[17:17] <fglock> (that's "ValueProxy" in kp6)

[17:17] <TimToady> we may have just generalized that to Dog :)

[17:18] <ruoso> so, the thing that triggers it is the binding process, right?

[17:18] <ruoso> the binding would call Autovivify in the Uninitialized object...

[17:18] <TimToady> yes, something like that

[17:18] <ruoso> no matter if binding to a variable or to a signature

[17:19] <ruoso> one other thing..

[17:19] <TimToady> a variable is just a degenerate signature

[17:19] * [particle] hums "officer krupkie"

[17:19] <ruoso> my $a := %a<b><c>; my $b := %a<b><c>; $a = 1;

[17:20] <ruoso> this is an interesting case,

[17:20] <TimToady> $a and $b should be the same container

[17:20] <ruoso> so, a capture for %a<b><c> is not for the value of %a<b><c>,

[17:21] <ruoso> but for %a<b><c> in itself

[17:21] <TimToady> correct, captures have to be able to do container aliasing

[17:21] <ruoso> but, if %a<b><c> wasn't autovivified yet

[17:21] <ruoso> what does $a points to

[17:21] <TimToady> an abstraction

[17:22] <TimToady> that's what the "a" is for, after all  :)

[17:22] <ruoso> so, the unintialized object captured in %a<b><c> would have to keep a reference to "%a<b> looking up for <c>"

[17:23] <ruoso> which, in fact would be

[17:23] <ruoso> (looking for <c> in (looking for <b> in %a))

[17:23] <TimToady> when you autovivify, you have to create any missing elements, and also make sure to reuse and elements that were already created by someone else

[17:23] <TimToady> (in the meanwhile)

[17:23] <TimToady> yes

[17:24] <TimToady> when nested arrays are referenced, they pass protoobjects down that get wrapped up by the lower down array in another protoobject, I think

[17:24] * ruoso feels like programming functional, and for the first time, really understands it

[17:24] <TimToady> cool

[17:26] <TimToady> shower &

[17:27] <fglock> ruoso: kp6 implements it that way

[17:28] <ruoso> fglock, ok... I need to adjust how yap6 does it

[17:28] <fglock> except that binding autovivifies, I think

[17:28] <fglock> re binding, I think I read it somewhere in the spec

[17:28] <ruoso> the difference is that I was returning a scalar from the list and the hash

[17:29] <ruoso> and I should be returning captures

[17:29] <ruoso> or not

[17:30] <ruoso> should a lookup in an array return 1) a scalar 2) a value or 3) a capture?

[17:30] *** penk joined
[17:30] <fglock> I think Parrot doesn't do hash/array laziness either

[17:30] <ruoso> scalar is probably out of the case, because that would pre-enforce scalar context

[17:31] <ruoso> which is not the case

[17:31] *** Psyche^ joined
[17:31] <ruoso> I think it's between value or capture

[17:31] <ruoso> as there's \%a<b><c>, it probably should return a value

[17:33] <fglock> ruoso: it depends on the hash current content

[17:33] <ruoso> for the uninitialized, i mean

[17:33] <ruoso> actually, for the API, i mean

[17:33] <fglock> kp6 returns a special case of scalar

[17:34] *** TJCRI left
[17:34] <ruoso> yeah... but then you're forcing scalar context

[17:34] <ruoso> which may not be the case

[17:34] <fglock> it's called "ContainerProxy"

[17:34] <fglock> it's not a scalar

[17:34] <fglock> it can be Hash, Array, or Scalar

[17:35] <ruoso> ContainerProxy is what the Capture would be, isn't it?

[17:35] <fglock> it depends on how you use it later

[17:35] <ruoso> so it's the capture

[17:35] <fglock> no

[17:35] <ruoso> fglock, no?

[17:36] <fglock> Capture is a collection

[17:36] <fglock> ContainerProxy is a single thing

[17:36] <ruoso> \%a<b><c> is a capture

[17:36] <fglock> but you can make a Capture with a single ContainerProxy

[17:36] <fglock> yes

[17:37] <ruoso> which is the same as \(%a<b><c>)

[17:37] <ruoso> which makes sense with what you're saying

[17:41] <fglock> kp6: my %a; my $b = \(%a{1}); say $b.perl 

[17:41] <exp_evalbot> r19309: OUTPUT[\( undef,  )␤]

[17:41] <fglock> that doesn't help - .perl simplifies the output

[17:42] <ruoso> kp6: my %b; my $a = %b<c><d>; say $a.perl;

[17:42] <exp_evalbot> r19309: OUTPUT[syntax error at position 22, line 1 column 22:␤my %b; my $a = %b<c><d>; say $a.perl␤                      ^ HERE␤]

[17:42] <ruoso> kp6: my %b; my $a := %b<c><d>; say $a.perl;

[17:42] <exp_evalbot> r19309: OUTPUT[syntax error at position 23, line 1 column 23:␤my %b; my $a := %b<c><d>; say $a.perl␤                       ^ HERE␤]

[17:42] *** thoughtpolice left
[17:42] <ruoso> kp6: my %b; my $a := %b{'c'}{'d'}; say $a.perl;

[17:42] <exp_evalbot> r19309: OUTPUT[undef␤]

[17:42] <ruoso> kp6: my %b; my $a := %b{'c'}{'d'}; say %b.perl;

[17:42] <exp_evalbot> r19309: OUTPUT[{  }␤]

[17:42] <ruoso> kp6: my %b; my $a := %b{'c'}{'d'}; say %b.elems;

[17:43] <exp_evalbot> r19309: OUTPUT[0␤]

[17:43] <ruoso> ops

[17:43] <ruoso> kp6: my %b; my $a = \(%b{'c'}{'d'}); say %b.elems;

[17:43] <exp_evalbot> r19309: OUTPUT[syntax error at position 13, line 1 column 13:␤my %b; my $a = \(%b{'c'}{'d'}); say %b.elems␤             ^ HERE␤]

[17:43] *** dlocaus joined
[17:43] <dlocaus> yikes, reading 2 weeks of perl6 logs...

[17:44] <dlocaus> Hello!

[17:46] *** allbery_b is now known as eviltwin_b

[17:47] <fglock> dlocaus: welcome back

[17:47] <dlocaus> thank you, I had a nice X'mas.

[17:47] <dlocaus> Did you have a nice New year?

[17:47] *** Patterner left
[17:47] *** Psyche^ is now known as Patterner

[17:48] <fglock> yes, thanks :)

[17:48] <dlocaus> fglock: I'm catching up (reading IRC logs on perlgeek.de) is there anything you need done? Before you head on home?

[17:50] <fglock> dlocaus: there is lots to do, but I could not update the project plan yet

[17:50] <dlocaus> ok.

[17:50] <dlocaus> I'll check around then, when I am done reading the IRC logs.

[17:51] *** eviltwin_b is now known as allbery_b

[17:51] <fglock> we are currently working on supporting Parrot, Perl5+Moose+Data::Bind, and C

[17:51] <fglock> we are blocked in several places

[17:52] <dlocaus> ok

[17:52] <fglock> which is the reason you deon't see many commits lately

[17:52] <fglock> don't

[17:52] <dlocaus> Data::Bind as the one by Chia-liang Kao?

[17:52] <fglock> yes

[17:53] <pmurias> dlocaus: hi

[17:53] <dlocaus> pmurias: hello!

[17:54] <pmurias> Perl5+Moose+Data::Bind is mostly blocked by my lack of time

[17:55] <dlocaus> I wonder if the the Perl6::* packages will have perl6 done before anyone else?

[17:55] <fglock> dlocaus: see v6.pm 

[17:58] <pmurias> the Perl5+Moose+Data::Bind is avalible with -{C,B}perl5v6

[17:59] *** TJCRI joined
[18:03] <dlocaus> http://en.wikipedia.org/wiki/Transactional_memory : Interesting (I found it when looking at an IRC link)

[18:03] <dlocaus> /found/looked it up/

[18:14] *** rindolf left
[18:15] *** meppuru joined
[18:16] *** Daveman joined
[18:18] *** bwisti joined
[18:19] <ruoso> so.... a capture object has the members: invocant, positional and named

[18:19] <ruoso> it doesn't enforce any context

[18:21] *** meppuru left
[18:22] *** meppuru joined
[18:22] <fglock> actually, kp6 captures now only have positional members - "named" is a special case of positional

[18:23] <fglock> but that's an implementation detail, probably

[18:23] <ruoso> fglock, not sure... 

[18:23] <ruoso> i was reviewing s06

[18:23] <ruoso> and it seems that the capture composition defines if it's named or positional

[18:24] *** _sprocket_ joined
[18:24] <fglock> yes, but you need to keep the ordering, for matching captures to signatures

[18:25] <ruoso> I think (1,2,3,:a<b>,4) have 1,2,3,4 as positional and a<b> as named

[18:25] <ruoso> I don't think a<b> counts as positional

[18:26] <fglock> that's right,

[18:26] <fglock> but you need to record the position of "a"

[18:26] <fglock> you may need it later

[18:26] <pmurias> fglock: when?

[18:27] <fglock> it depends on the signature that the capture will match to

[18:28] <fglock> see the algorithm at Emit::Perl5, it needs to scan the capture in order

[18:28] <TimToady> order matters if you have two :a

[18:28] <ruoso> you shouldn't be able to fetch named as positional, if that's what you mean, fglock 

[18:29] <ruoso> TimToady, but that's at capture composition, isn't it?

[18:29] <fglock> ruoso: no, I mean matching captures to signatures

[18:29] <TimToady> question is, if you bind to |$capture, can you reconstruct the original call order and do something else

[18:30] <fglock> this was implemented after a discussion here, about 2 months ago I think

[18:30] <ruoso> fglock, why would you need the order for named there? (except for several of the same name?)

[18:30] <TimToady> I tend to agree with the opinion of not forgetting anything that might be useful later

[18:30] <TimToady> even if that later use is unconventional

[18:30] <fglock> ruoso: I don't remember - looking

[18:31] *** Jamtech joined
[18:32] <TimToady> also, if the only thing you bind is a perl 5 style *@_, arguably that should contain the named args

[18:32] <ruoso> TimToady, at some place in the synopsis, it says that the capture coerced to array should return the positional args

[18:33] <TimToady> well, likely, but there needs to be some way to get at the original arguments in pristine form

[18:33] <ruoso> *@_, *%_

[18:34] <TimToady> that throws away position info on *%_

[18:34] <TimToady> what if you're writing a macro that does something different to its args?

[18:35] <TimToady> maybe it's just "bind to |$capture and then call $capture.originalargs" or some such

[18:35] <ruoso> TimToady, that's much more sane

[18:35] <TimToady> or possibly it's the default binding of @_ when there's no sig

[18:35] <ruoso> if you wish to use the args as a capture

[18:35] <ruoso> you can just declare your signature accordingly

[18:36] <TimToady> but maybe it's more useful if the no-sig case automatically sets *%_ as well

[18:36] <ruoso> I would expect so

[18:36] <ruoso> whereas @_ has only the positional and %_ only the named

[18:37] <TimToady> however, that makes it a little harder to translate p5 to p6

[18:37] <ruoso> list to hash coercion in Perl 6 won't do what p5 does already

[18:37] <TimToady> it's pretty close

[18:38] <TimToady> a => 'b' still does the same thing

[18:38] <TimToady> just via Pair object

[18:38] <TimToady> (assuming the original P5 code didn't get out of sync)

[18:38] <TimToady> I suppose the p5-to-p6 translation must really turn => into ,

[18:38] <ruoso> a => b does, but 'a', 'b' doesnt

[18:38] <TimToady> yes, which is why it has to remove => and replace with ,

[18:39] <TimToady> because p5 intermixes them freely

[18:39] <TimToady> and you can't undo the %args = @_ idioms in the sub

[18:39] <TimToady> maybe we need a p5-ish => equivalent

[18:40] <ruoso> I, personally, wouldn't care too much with p5->p6 translations

[18:40] <ruoso> the language is already too different

[18:40] <TimToady> it's just one factor to bear in mind, but we don't want to make people miserable unnecessarily

[18:41] <TimToady> we're already going to have various p5ish variants of some of the builtin functions

[18:41] <ruoso> in Perl 6, when you have a list coercion to hash, you pair two by two?

[18:41] <TimToady> so maybe a p5=> isn't so farfetched

[18:41] <TimToady> unless the next arg is a Pair or a Hash

[18:42] <ruoso> ok

[18:42] <TimToady> so %foo = a => 1, 'b', 2; does the Right Thing

[18:42] <ruoso> but anyway...

[18:43] <ruoso> having @_ to return the named arguments seems a little bad

[18:43] <TimToady> I think I like the p5=> solution.  it means comma, but is really ugly and easy to search for when you want to convert to real =>

[18:43] <TimToady> p5=> would suppress that

[18:43] <TimToady> since it's just a comma

[18:44] <TimToady> it would come in as @_

[18:44] <ruoso> hmmm

[18:44] <ruoso> I see

[18:44] <TimToady> when you switch to real => it comes in as %_

[18:44] <TimToady> but you have to change the sub at the same time

[18:44] <ruoso> sure

[18:44] <TimToady> and we've already got p5foo emulator functions elsewhere, so it's not like a new meme

[18:45] <ruoso> ok... so the default sig is to get all positional to @_ and all named to %_

[18:45] <fglock> ok, I reviewed the kp6 code - Capture does have separate named/positionals, 

[18:46] <fglock> (the Capture is created from a plain list of named+positionals)

[18:52] <ruoso> thinking in the low level

[18:54] *** ebassi left
[18:55] <ruoso> \%a<b><c> is really something like: "capture capture( %a: 'b' ): 'c' ", while plain %a<b><c> is something like "fetch capture(%a: 'b'): 'c' "

[18:57] <ruoso> or even deeper... fetch(capture(capture(MY: 'a'): 'b'): 'c')

[18:59] <ruoso> actually... fetch(capture(capture(MY: '%a'): 'b'): 'c'), as the sigil is part of the name

[19:00] <ruoso> so... capture is a "method" of hash

[19:01] <ruoso> that, just as fetch, receives the key name

[19:01] *** Jamtech left
[19:01] <ruoso> actually the key object

[19:01] <ruoso> and the hash as the invocant

[19:02] <ruoso> but I'm still missing the context...

[19:02] <ruoso> maybe...

[19:03] <fglock> ruoso: captures and lookups are different things

[19:04] <ruoso> fetch(hash(capture(hash(capture(MY: '%a'):):): 'b'):): 'c')

[19:04] <ruoso> fglock, but both are methods of the containers

[19:05] <ruoso> and the values also, actually

[19:05] <ruoso> you can do \3

[19:09] <fglock> kp6: say \(3).perl

[19:09] <exp_evalbot> r19309: OUTPUT[\( 3,  )␤]

[19:09] <fglock> but this is Capture.new( positionals => [ 3 ] )  

[19:11] <ruoso> what is just what I would mean in the pseudocode I written above as a call to capture without invocant

[19:12] <ruoso> the thing is that a capture of %a<b><c> must relate to %a<b>: 'c'  and not to %a<b><c> directly

[19:12] <ruoso> because

[19:13] <ruoso> my %a; my $b := %a<b><c>; my $c := %a<b><c>; $c = 1;

[19:13] <fglock> I've got to leave  &   # will backlog

[19:14] <ruoso> $c and $b are bound to the lookup of c in the lookup of b in %a

[19:15] <ruoso> hmmm

[19:15] <ruoso> but that's why capture autovivifies

[19:15] <ruoso> but...

[19:16] <ruoso> what happens when 

[19:16] <ruoso> my %a; my $b := %a<b><c>; %a<b> = { c => 1 };

[19:17] <ruoso> TimToady, what should happen in the above code? should $b equals 1?

[19:17] <dlocaus> moritz: http://irclog.perlgeek.de/perl6/2007-12-28 (next day doesn't link to 2007-12-29... (next day link is missing) fyi.

[19:17] <ruoso> if not? what should $b point to?

[19:18] <PerlJam> ruoso: $b should be 1 but that has nothing to do with Captures.

[19:18] <ruoso> PerlJam, how so?

[19:19] <ruoso> dlocaus, that was when the logger was out

[19:20] <dlocaus> humm

[19:23] <PerlJam> ruoso: caveat lector as I'm just a humble reader of synopses, but I don't think captures have replaced references quite like you think.  %a<b><c> will lazily auto-vivify a hash (or two) as needed.  There are no Captures there.

[19:25] <ruoso> PerlJam, as I understood so far, binding is really Signature := Capture

[19:25] <PerlJam> perhaps.  I haven't read this stuff in a while so I'm just working from memory.

[19:25] <ruoso> TimToady just said... "a variable is just a degenerate signature"

[19:26] *** Limbic_Region joined
[19:26] <PerlJam> What you're saying doesn't jibe with my memory. So one or the other is off :)

[19:26] <PerlJam> (or both)

[19:27] <ruoso> PerlJam, S02 # immutable types

[19:27] <ruoso> Capture (right side of a binding)

[19:27] <ruoso> Signature (left side of a binding)

[19:28] * ruoso going home

[19:28] * ruoso probably gets online later today

[19:28] * ruoso will backlog

[19:28] <PerlJam> ruoso: sure, but since you have a $scalar on the left side, I think what happens is that the Capture is optimized away into just its scalar component

[19:29] <ruoso> hmmm... isn't that what the assignement would do?

[19:30] <ruoso> I think the regular use of the variable will imply scalar context

[19:30] <ruoso> but the container is still whatever it is

[19:30] <ruoso> it may be a hash

[19:30] <PerlJam> It's best to let people of TimToady proportions have a go at explanation. :-)

[19:31] <ruoso> heh

[19:31] * ruoso really got to go

[19:31] <ruoso> brb&

[19:31] *** ruoso left
[19:31] <PerlJam> yeah, I've got to get to work too

[19:31] * PerlJam work &

[19:33] *** fglock left
[19:35] <TimToady> I dunno, my proportions are rather skinny...

[19:39] *** jisom joined
[19:39] <Limbic_Region> My proportions are quite large these days.  "Success goes to your head, but happiness goes to your hips" - Tye McQueen

[19:47] <dlocaus> break &

[19:56] *** jferrero joined
[19:57] *** TJCRI left
[20:04] *** TJCRI joined
[20:06] *** rindolf joined
[20:07] *** lorn left
[20:09] *** lorn joined
[20:10] <rindolf> Hi all.

[20:11] *** Coke joined
[20:11] *** TJCRI left
[20:12] *** Coke left
[20:13] *** jisom left
[20:22] *** ruoso joined
[20:22] *** lorn left
[20:23] * ruoso back

[20:24] <ruoso> sub foo (|$capture) { say $capture[0] }; foo(bar());

[20:24] <ruoso> is bar() execution lazy?

[20:25] <ruoso> better put... my $a := bar();

[20:25] <ruoso> does it execute bar?

[20:25] <ruoso> or will it only execute when $a is used?

[20:27] <ruoso> if the rlvalue of the binding is a capture, I would expect bar() to be executed during the binding only if I had

[20:27] <ruoso> my $a := |bar()

[20:28] <ruoso> so the binding would be a truly functional thing

[20:29] <ruoso> otoh, this would mean that my $a := %a<b><c> wouldn't need to autovivify (except by being specced that way)

[20:30] <ruoso> am I insane? or does it make any sense?

[20:33] <ruoso> TimToady, what do you think # and sorry for being so picky today ;) I'm trying to realize how to proceed on yap6

[20:44] *** justatheory left
[20:51] *** justatheory joined
[20:51] *** rdice joined
[21:00] *** rindolf left
[21:05] <TimToady> we are not that lazy.  bar() is invoked immediately, but may return its value lazily.

[21:06] <TimToady> bbl &

[21:11] *** barney left
[21:14] *** jjore-w joined
[21:14] *** jjore-w left
[21:18] <[particle]> @tell fglock jonathan++ implemented set_outer on Sub for parrot in r24453. have at it!

[21:20] *** IllvilJa joined
[21:34] *** tobeya joined
[21:40] <ruoso> kp6: my %a; my $b = %a<b><c>; %a<b> = { 'c' => 1 }; say $b;

[21:40] <exp_evalbot> r19309: OUTPUT[syntax error at position 22, line 1 column 22:␤my %a; my $b = %a<b><c>; %a<b> = { 'c' => 1 }; say $b␤                      ^ HERE␤]

[21:40] <ruoso> kp6: my %a; my $b = %a{'b'}{'c'}; %a{'b'} = { 'c' => 1 }; say $b;

[21:40] <exp_evalbot> r19309: OUTPUT[␤]

[21:40] <ruoso> kp6: my %a; my $b := %a{'b'}{'c'}; %a{'b'} = { 'c' => 1 }; say $b;

[21:40] <exp_evalbot> r19309: OUTPUT[␤]

[21:41] <ruoso> pugs: my %a; my $b := %a{'b'}{'c'}; %a{'b'} = { 'c' => 1 }; say $b;

[21:41] <exp_evalbot> OUTPUT[␤]

[21:42] *** Aankhen`` left
[21:42] <ruoso> pugs: my %a; my $b := %a{'b'}{'c'}; %a{'b'} = { 'c' => 1 }; say $b; say %a{'b'}{'c'};

[21:42] <exp_evalbot> OUTPUT[␤1␤]

[21:43] <ruoso> pugs: my %a; my $b := %a{'b'}{'c'};$b = 2; say $b; %a{'b'} = { 'c' => 1 }; say $b; say %a{'b'}{'c'};

[21:43] <exp_evalbot> OUTPUT[2␤2␤1␤]

[21:44] <ruoso> is this correct?

[21:45] <ruoso> pugs: my %a; my $b := %a{'b'}{'c'};$b = 2; say $b;say %a{'b'}{'c'}; %a{'b'} = { 'c' => 1 }; say $b; say %a{'b'}{'c'};

[21:45] <exp_evalbot> OUTPUT[2␤2␤2␤1␤]

[21:54] *** Pengwn joined
[21:57] *** Pengwn left
[22:13] *** _sprocket_ left
[22:13] *** rdice left
[22:20] *** Schwern joined
[22:22] *** cmarcelo left
[22:27] <ruoso> I think I got it...

[22:27] <ruoso> if all the container value-fetching returns Captures, we can postpone the context coercion and use the values directly in case of bind

[22:28] <ruoso> for instance

[22:29] <ruoso> %a<b><c> would mean a lookup for b in %a which would return a capture. this capture would be coerced to hash and then subject to another lookup, now for 'c', but at this time, the resulting capture will feed the call to bind

[22:29] <ruoso> which would then check for uninitialized and call autovivify on it, if that's the case, which would end building the hash recursively

[22:30] <ruoso> if the target container is rw

[22:31] <ruoso> the difference for a assignment would be in the last step,

[22:32] <ruoso> where the assign code would coerce to the proper context and copy the value.

[22:33] <ruoso> the thing in all the container operations returning captures is that they can be coerced to any context afterwards... 

[22:33] <ruoso> like my %a = %a<b>

[22:33] <ruoso> this would coerce to hash after the lookup

[22:35] <ruoso> or even

[22:35] <ruoso> in sub/method call 

[22:36] <ruoso> sub foo ($a, %b) { ... }; foo( %c<d><e>, %c<d><f> );

[22:36] <ruoso> %c<d><e> returns a capture, that in bind-time is coerced to scalar

[22:36] <ruoso> %c<d><f> returns another capture, that in bind-time is coerced to hash

[22:41] *** ebassi joined
[22:42] <ruoso> maybe not...

[22:43] <ruoso> the return for the container value-fetching return objects that behave like scalars

[22:43] *** pmurias left
[22:44] *** justatheory left
[22:44] *** justatheory joined
[22:46] <ruoso> I think the way I was thinking was right at the first place

[22:47] *** TreyHarris joined
[22:48] *** ispy_ joined
[22:49] <TreyHarris> anybody have an example offhand of where paren-less control constructs wouldn't work in the Perl 5 grammar?

[22:56] <TreyHarris> oh, i got it.  "if $var { foo }", is it "$var<foo>", or is it "if ($var) { foo() }"?

[23:07] <pugs_svn> r19310 | ruoso++ | [yap6] getting closer to something rational in the autovivification and capture issue. see NOTES_AUTOVIVIFY.txt

[23:11] * ruoso trying to get the ideas in order...

[23:11] * ruoso giving up for today

[23:26] *** DaGo joined
[23:31] *** BinGOs left
[23:38] *** alester is now known as AndyAway

[23:39] *** BinGOs joined
[23:49] *** iblechbot left
[23:55] *** felipe left
[23:57] *** lichtkind left
[23:59] *** han_ joined
