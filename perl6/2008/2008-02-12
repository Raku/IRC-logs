[00:00] *** dalek joined
[00:00] *** pugs_svnbot joined
[00:02] *** Juerd joined
[00:04] *** chris2 left
[00:04] *** pugs_svnbot left
[00:04] *** dalek left
[00:04] *** Juerd left
[00:05] *** dalek joined
[00:05] *** IllvilJa left
[00:05] *** pugs_svnbot joined
[00:06] *** Juerd joined
[00:06] <Juerd> One more reboot to come

[00:14] *** jjore-w left
[00:17] *** eternaleye joined
[00:22] *** Daveman joined
[00:27] *** eternaleye_ joined
[00:35] *** justatheory_ joined
[00:36] <Juerd> printk: 1211297 messages suppressed.

[00:37] <Juerd> Per few seconds :)

[00:37] <meppl> good night

[00:37] <Juerd> Good night

[00:37] <meppl> ;)

[00:38] *** justatheory__ joined
[00:40] *** eternaleye left
[00:44] *** wknight-away is now known as wknight8111

[00:49] *** meppl left
[00:49] *** justatheory left
[00:52] <TimToady> avar: I've got some tweaks to re::engine::TRE that make it more useful for a longest-token lexer

[00:54] <avar> Excellent, want comaint or should I go through the upload moves?:)

[00:55] <TimToady> lemme just paste the patch for you to see

[00:56] *** njbartlett left
[00:56] *** justatheory_ left
[00:56] <avar> TRE has a lot of neat stuff I meant to use, like the $file_handle =~ $regex stuff

[00:57] <TimToady> heh, I can't get at pbot from work :( hang on

[00:58] <TimToady> http://wall.org/~larry/tre.patch

[00:58] <TimToady> does two things

[00:59] <TimToady> one, when you use /gc it makes fields undef properly instead of pointing to current pos - 1

[00:59] <avar> Yes I see, this is a screwup I fixed in ::PCRE but didn't port to ::TRE

[00:59] <TimToady> (I was starting to search at position 4 and it reports 3)

[00:59] <TimToady> the other is setting lastparen usefully

[01:00] <TimToady> to be the number of the last right paren we matched

[01:00] <TimToady> which means I can use the length of @- to find that number without scanning again

[01:01] <TimToady> which means all my alternatives in the lexer can each end with (foo) and I can tell which leaf of the search tree it ended on

[01:01] <TimToady> which maps directly to a "fate" navigation down the recursive matcher

[01:02] <TimToady> so the recursive descent engine doesn't have to rescan the token

[01:02] <TimToady> it just knows it has to drop down into <expect_token>/<noun>/<variable> or whatever and continue parsing

[01:03] <TimToady> anyway, I have a version called TREx that I'm fiddling with, so no rush

[01:04] <avar> I actually do rx->nparens = rx->lastparen = rx->lastcloseparen = nparens; at /compile time/ in PCRE. But this semantic sounds nicer

[01:05] <TimToady> I just have to be careful because I think TRE won't report a match on a final () null match, so I have to be sure and (...) where ... is the final bit of the token

[01:05] *** Lunchy joined
[01:06] <TimToady> actually, I wish I could just directly access the tre tags, and install a 'you are here' tag at the end of each token

[01:06] <TimToady> but this is good enough, and scanning the matches in C is a lot faster than doing it in Perl

[01:07] <TimToady> but expect_term's lexer can have 150 different tokens or more

[01:07] <TimToady> and I need to know *which* one matched

[01:07] <TimToady> I almost don't care what the matched string is...

[01:08] <TimToady> unless it was an identifier or something

[01:08] <TimToady> in any case, it's the eventual reduction that cares mostly

[01:09] <TimToady> but given that token 42 matched, I can know what that $33 gets bound to $<foo>, for instance

[01:10] *** zamolxes joined
[01:11] <TimToady> but this means I can implement the longest-token matcher in Perl 5 now, yay

[01:11] <TimToady> avar++

[01:13] *** Lunchy left
[01:15] *** Zygo joined
[01:16] <TimToady> and since p5 can be called from pugs, I can use tre there, too, if I like

[01:17] *** wknight8111 is now known as wknight-away

[01:19] <avar> </releng>

[01:20] <avar> http://pause.perl.org/incoming/re-engine-TRE-0.02.tar.gz

[01:20] <TimToady> avar += 42

[01:21] <avar> I'll try to parse the rest of your comments when it's not almost 2am:)

[01:30] <avar> 01:29:08  * CPAN2 upload: re-engine-TRE-0.02 by AVAR

[01:30] <avar> whee:)

[01:31] *** Lunchy joined
[01:32] <TimToady> thanks!

[01:34] *** sunnavy left
[01:34] *** sunnavy joined
[01:40] *** devogon left
[01:44] <diakopter> buchetc: for posterity, the S17 link you gave above is out of date; http://svn.pugscode.org/pugs/docs/Perl6/Spec/Concurrency.pod is the current link

[01:45] *** eternaleye__ joined
[01:45] *** eternaleye_ left
[01:46] *** eternaleye__ is now known as eternaleye

[01:46] <TimToady> decommuting &

[01:47] *** Lorn_ left
[01:48] *** Jedai joined
[01:52] *** stevan_ left
[01:53] *** stevan_ joined
[02:13] *** zakame joined
[02:20] *** drbean joined
[02:30] *** Andy_ joined
[02:39] *** mncharity joined
[02:40] *** japhb joined
[02:45] *** fridim_ left
[03:11] *** jjore joined
[03:13] *** Jedai left
[03:26] *** eternaleye_ joined
[03:31] <mncharity> given  token foo:a { 'a' }  and   rule foo:b { 'b' }    how does %foo know that it has to do <.ws> before key on one, but not the other?  or...?

[03:35] *** eternaleye left
[03:39] *** Limbic_Region left
[03:40] *** justatheory__ left
[03:42] <mncharity> feather seems to be down.  do we have a name yet for the {regex,rule,token} concept yet?  ie, calling a  'regex foo //' a rule, or calling a 'rule foo //' a regex, are both confusing (though both true in different senses).  ah, well.  "thingies".

[03:45] <pugs_svnbot> r19891 | putter++ | [misc/red_STD] more grammar "thingies".  start of a first top-down pass, doing rough transliterations and issue discovery (and getting a feel for task size).  new productions are mostly "quick and sloppy" and untested, some unimplemented, and all generally lacking Match creation.  That's a second pass.

[03:45] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19891

[03:45] <lambdabot> Title: Changeset 19891 - Pugs - Trac

[03:45] <pugs_svn> r19891 | putter++ | [misc/red_STD] more grammar "thingies".  start of a first top-down pass, doing rough transliterations and issue discovery (and getting a feel for task size).  new productions are mostly "quick and sloppy" and untested, some unimplemented, and all generally lacking Match

[03:45] <pugs_svn> ..creation.  That's a second pass.

[03:46] <Auzon> Wow. Bots and bots and bots!

[03:46] <mncharity> though this time an interesting difference in bot output

[03:47] <Auzon> Why do we have two pugs_svn(bots)?

[03:48] <TimToady> mncharity: we've been calling them all "rules" for now

[03:48] <TimToady> as for the "key", that's looked up explicitly with <sym>

[03:49] <TimToady> and the rule would not, in fact, have a longest token, since it starts with ws

[03:49] <TimToady> or rather, its longest token is ''

[03:49] <mncharity> btw, I'm not opposed to there being some unit tests... they would be nifty to have for regression testing.  Volunteers encouraged. :)  It's just that working code isn't a necessary objective for this first long slog through STD.pm, because I suspect most issues can be discovered without that last costly step.  But they would be great to have.

[03:49] <TimToady> it's good that you're feeding back changes into STD

[03:50] <TimToady> now that I know how to use TRE for a longest token matcher, I'm of two minds whether to continue in pugs calling into p5, or just write STD in p5 like you're doing in ruby

[03:51] *** jjore left
[03:56] <mncharity> re key, head scratch, so for say %statement_control, there are a bunch of rules, all with sym, and all with the same key ""?  if the value of an interpolated hash is an array, it tries all the elements?

[03:56] <mncharity> feather is back

[03:57] <mncharity> re good feeding back, :)

[03:58] <mncharity> re two minds, the advantages of pugs calling into p5 are...?

[03:59] <TimToady> there is no hash anymore

[03:59] <TimToady> pugs knows perl 6, so I don't have to rewrite the closures  :)

[04:00] <mncharity> re "there is no hash anymore", sigh.  another virtual memo missed.

[04:00] <TimToady> I don't think S05 even talks about hashes these days

[04:01] <TimToady> everything like that is done with multiple dispatch now

[04:01] <mncharity> http://feather.perl6.nl/syn/S05.html#Variable_(non-)interpolation

[04:01] <lambdabot> Title: S05

[04:01] <TimToady> well, I guess it does, but we don't use it in STD

[04:02] <TimToady> in any case, it's something that doesn't really have to be in 6.0.0

[04:03] <TimToady> basically all the infix:<*> rules are considered | alternatives when you call the abstract <infix> rule

[04:04] <TimToady> cheat already rewrites all those to an explicit infix rule with |

[04:04] *** dduncan joined
[04:04] <mncharity> so the multiple dispatch story is...  value types like /\G<.ws> <sym>/ ?

[04:05] <TimToady> the cheat rewrite is still assuming that | does longest token selection

[04:06] <mncharity> right

[04:06] <TimToady> but for a first approximation they'll work as ordered alternatives in cheat's output

[04:06] <mncharity> another story possibility might be  parallel dispatch to all foo methods?

[04:07] <TimToady> if you run cheat on STD.pm you'll see all the autogenerated <infix> et al. rules

[04:07] <TimToady> at the end

[04:07] <TimToady> yes, if you can capture control before any of the methods does something with side effects

[04:07] <mncharity> ok.  so it sounds like I should feel free to implement categories ad hoc, rather than aiming for something hashy.

[04:08] <TimToady> and keep them in lockstep to you can find out the longest token

[04:08] <TimToady> but it's likely to be high overhead compared to running DFA first

[04:08] <TimToady> just do it like cheat does

[04:08] <mncharity> I guess I'm still unclear on the "categories are mmd" story.

[04:09] <mncharity> but ad hoc == easier, so no worries

[04:10] <TimToady> well, I need to wander off again, so later &

[04:10] <mncharity> np.  thanks.

[04:36] *** lyokato joined
[04:44] *** thoughtpolice left
[04:58] <Juerd> mncharity: feather was down, but not when you said it seemed to be :)

[04:58] <Juerd> mncharity: 'cause I couldn't have seen you say that if it'd been down :)

[04:59] *** avar joined
[05:02] *** Schwern left
[05:10] *** wknight-away left
[05:35] *** justatheory joined
[05:37] *** Andy_ left
[05:42] *** monomorph joined
[05:51] *** japhb left
[05:51] *** japhb joined
[05:52] *** justatheory left
[06:05] *** pbuetow joined
[06:30] *** pbuetow left
[06:33] *** silug left
[06:39] *** devogon joined
[06:42] *** drbean left
[06:46] *** Psyche^ joined
[07:03] *** Patterner left
[07:03] *** Psyche^ is now known as Patterner

[07:11] *** cxreg joined
[07:14] <mncharity>  Juerd: :) &

[07:14] *** mncharity left
[07:35] *** psapo left
[07:35] *** psapo joined
[07:36] *** iblechbot joined
[07:49] *** masak joined
[08:06] *** monomorph left
[08:11] *** BinGOs_ joined
[08:11] *** BinGOs_ is now known as BinGOs

[08:26] *** wolverian joined
[08:29] *** pravus joined
[08:31] *** silug joined
[08:43] *** dduncan left
[08:47] *** zamolxes left
[09:09] *** zakame left
[09:11] *** hareldvd joined
[09:13] *** jrockway joined
[09:34] *** sri_work joined
[09:36] *** lay1 joined
[09:36] *** lyokato left
[09:37] *** lay1 is now known as la1

[09:37] *** la1 is now known as lay1

[09:41] *** lay1 left
[09:42] *** kst left
[09:43] *** laye joined
[10:02] *** ebassi joined
[10:23] *** chris2 joined
[10:24] *** ruz joined
[10:38] *** andara joined
[10:46] *** masak left
[10:52] <ruoso> pugs: class A { method b --> Bool { False } }; say A.b()

[10:52] <exp_evalbot> OUTPUT[*** ␤    Unexpected "-->"␤    expecting "handles", "is", bare trait, subroutine parameters, trait or block␤    at /tmp/miyJV4PSTj line 1, column 20␤]

[10:52] <ruoso> pugs: class A { method b() --> Bool { False } }; say A.b()

[10:52] <exp_evalbot> OUTPUT[*** ␤    Unexpected "-->"␤    expecting bare trait, trait or block␤    at /tmp/PegXz4iUnW line 1, column 22␤]

[10:53] <ruoso> pugs: class A { method b(a --> Bool) { a } }; say A.b()

[10:53] <exp_evalbot> OUTPUT[*** ␤    Unexpected "a"␤    expecting "|", ":", "*", parameter name or ")"␤    at /tmp/6PPfnSVlAy line 1, column 20␤]

[10:53] <ruoso> pugs: class A { method b($a --> Bool) { $a } }; say A.b()

[10:53] <exp_evalbot> OUTPUT[*** No such method in class A: "&b"␤    at /tmp/sded0Ktf7I line 1, column 47 - line 2, column 1␤]

[10:53] <ruoso> pugs: class A { method b($a --> Bool) { $a } }; say A.b(True)

[10:53] <exp_evalbot> OUTPUT[1␤]

[10:53] <ruoso> so... --> is only valid to type the attriute, not the method return type...

[11:03] *** hareldvd left
[11:10] *** zamolxes joined
[11:16] *** andara left
[11:33] *** pbuetow joined
[11:38] <ruoso> TimToady, I've been updating the SMOP OO API after our conversation yesterday... could you please take a look at it?

[11:38] *** Jedai joined
[11:43] *** pbuetow left
[11:56] *** iblechbot left
[12:12] *** masak joined
[12:15] *** pbuetow joined
[12:22] *** Lorn__ left
[12:25] <moritz_> it seems we have two svnbots again, I'll withdraw mine

[12:25] *** drbean joined
[12:28] *** chris2 left
[12:31] *** ebassi is now known as ebassi|lunch

[12:31] *** ebassi|lunch left
[12:31] *** ebassi joined
[12:32] *** cognominal_ joined
[12:36] *** kanru left
[12:42] *** iblechbot joined
[12:48] *** wknight-away joined
[12:55] *** masak left
[12:57] *** kanru joined
[12:59] *** dalecooper joined
[13:07] *** cmarcelo joined
[13:12] *** pbuetow left
[13:13] *** stevan_ left
[13:13] *** stevan_ joined
[13:14] *** devogon left
[13:15] *** devogon joined
[13:17] *** monomorph joined
[13:17] *** wknight-away left
[13:19] *** masak joined
[13:27] *** IllvilJa joined
[13:50] *** laye left
[13:54] *** penk joined
[13:55] *** drbean left
[14:03] *** Andy_ joined
[14:10] *** fridim_ joined
[14:11] *** wknight-away joined
[14:18] *** Andy_ left
[14:32] *** Lorn joined
[14:38] *** eternaleye_ left
[14:47] <cognominal_> is there a syntax to express two consecutive elements in a list, now that the => separator means a pair,  say for passing parameters to a perl5 routine

[14:47] <[particle]> comma?

[14:47] *** Auzon left
[14:47] <allbery_b> p5=> ?

[14:48] <allbery_b> (g*d knows how you'll get pugs to parse that one properly...)

[14:48] <[particle]> p5=> is meant only to be used by translators, never by humans

[14:48] <[particle]> it's ugly for a reason

[14:48] <allbery_b> meant to, yes, but I can see the p5-sub case too

[14:49] <cognominal_> ok

[14:54] *** jhorwitz joined
[14:54] *** pmurias joined
[14:54] <pmurias> allbery_b: you can always use a normal ','

[14:57] *** rdice joined
[14:57] <allbery_b> sure, but (virtual) pairs have semantic (or, hm.  connotative? since it's not semantic to p6) value

[15:01] *** Zygo left
[15:01] *** ZYgo joined
[15:02] *** ZYgo is now known as Zygo

[15:10] <cj> morning folks

[15:12] *** penk left
[15:13] *** penk joined
[15:13] *** krumms joined
[15:14] <masak> cj: good afternoon

[15:14] <krumms> is it okay to ask parrot-related questions here?

[15:15] <[particle]> if it's about perl 6 and parrot, it's okay

[15:15] <[particle]> otherwise it's better to head over to irc.perl.org#parrot

[15:15] <krumms> ah, cheers

[15:31] *** gbacon joined
[15:32] *** pbuetow joined
[15:32] *** pbuetow left
[15:34] *** pbuetow joined
[15:36] *** gbacon left
[15:38] *** meltingwax joined
[15:39] *** gbacon joined
[15:49] *** gbacon left
[15:50] *** gbacon joined
[15:57] <alester> http://perlbuzz.com/2008/02/tell-us-how-to-do-it-andi.html

[15:57] <lambdabot> Title: Tell us how to do it, Andi! - Perl Buzz

[15:59] *** thepler left
[16:03] *** masak left
[16:13] <pugs_svnbot> r19892 | ruoso++ | [smop] src-s1p/Object.pm -- Updated to reflect the new REPR API.

[16:13] <pugs_svnbot> r19892 | ruoso++ | Using P6 POD now.

[16:13] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19892

[16:13] <lambdabot> Title: Changeset 19892 - Pugs - Trac

[16:17] *** Jedai left
[16:21] *** krumms left
[16:21] <ruoso> pugs: say Submethod.isa(Sub)

[16:21] <exp_evalbot> OUTPUT[1␤]

[16:22] *** krumms joined
[16:22] <ruoso> pugs: say Hash.isa(Scalar)

[16:22] <exp_evalbot> OUTPUT[␤]

[16:22] <ruoso> pugs: say Hash.isa(Container)

[16:22] <exp_evalbot> OUTPUT[*** No such subroutine: "&Container"␤    at /tmp/PNnlemA93Y line 1, column 14-23␤]

[16:26] *** dalecooper left
[16:27] *** manfred joined
[16:36] *** meltingwax left
[16:38] <TimToady> ruoso> so... --> is only valid to type the attriute, not the method return type...

[16:38] <TimToady> pugs merely parses the --> and ignores it, but it does specify the return type of the method

[16:39] <TimToady> I don't know what you mean by "type the attribute" since there is no attribute

[16:39] <TimToady> the type of $a is not influenced by anything after the -->

[16:39] <TimToady> if you meant parameter

[16:40] <TimToady> the reason the previous example failed is because you didn't pass a parameter to a 1-ary method

[16:42] <TimToady> s/parameter/argument

[16:42] <TimToady> EPRECAFFIENE

[16:42] <ruoso> TimToady, so: our method foo(a) --> List of Method

[16:42] <ruoso> is valid?

[16:42] <TimToady> --> goes inside the ()

[16:43] <ruoso> hmmm

[16:43] <ruoso> I was thinking that --> inside the () was defining the type of the argument

[16:43] <TimToady> s/argument/parameter/ but no

[16:43] <TimToady> it doesn't

[16:43] <ruoso> our method foo(Int a --> List of Method)

[16:43] <TimToady> that would be a method that returns a list of methods

[16:44] <ruoso> our method foo(Int $a --> List of Method) I mean

[16:44] <ruoso> ok...

[16:44] *** riffraff joined
[16:44] <ruoso> so, is "our method foo( --> List of Method)" valid?

[16:45] <TimToady> could also be written our List of Method foo (Int $a) but that gets awkward

[16:45] <TimToady> yes, but pugs doesn't parse it right yet

[16:45] <ruoso> ok...

[16:45] *** pmichaud joined
[16:45] <ruoso> did you see the last changes in the smop oo api?

[16:46] <TimToady> not yet; brewing coffee

[16:46] <TimToady> very thick coffee...

[16:46] <ruoso> heh

[16:49] *** PerlJam joined
[16:51] <TimToady> first I was wondering if the bool/Bool distinction buys anything here

[16:51] <TimToady> then I was wondering whether there's a native object to go with Object  :)

[16:51] <ruoso> when I access this methods from low-level, I can be sure to be the native one

[16:51] <ruoso> it makes it easier

[16:52] <TimToady> since a native object can't change its repr

[16:52] <ruoso> ye

[16:52] <ruoso> specially since the native bool type is actually a pair of constants

[16:52] <TimToady> 'course, from a Perl point of view there will be times where it's useful to say class Object is also...

[16:53] <ruoso> I don't think Object needs a native, because the point of Object is exactly being representation-independent

[16:53] *** zamolxes left
[16:54] <TimToady> was just a thought

[16:54] <ruoso> althought as long as the p6opaque responder interface can be identified, it can be treated as native whenever possible

[16:54] <ruoso> for optimization matters

[16:57] <TimToady> now I'm wondering how easy it will be for someone to accidentally say .BUILDALL on Object and define undef...  :/

[16:57] <TimToady> we might need to prevent that explicitly

[16:58] <ruoso> hmm... in fact..

[16:58] <TimToady> maybe that's a good argument for Object's BUILD method to fail

[16:58] <ruoso> like if (Object === $object) fail

[16:59] <ruoso> but in fact, that applies to every class

[17:00] <ruoso> well... maybe we need to define a rule that no instance may have definitions and that no class may be instantianted

[17:00] <ruoso> s/instantiated/target to BUILDALL/

[17:01] <ruoso> which is as simple as, you can only add private storage to objects that have a single isa, no role and no other definition

[17:01] <ruoso> This way any $prototype.BUILDALL() will fail

[17:01] <allbery_b> class variables?

[17:01] <ruoso> that's class storage

[17:01] <ruoso> it's treated differently

[17:01] <allbery_b> ok

[17:02] <ruoso> so "(0 but True).new()" will always fail

[17:02] <ruoso> or not

[17:03] <TimToady> I don't see why it should fail offhand

[17:03] <ruoso> actually "(0 but True).new()" will always mean that both the objects share the same anon superclass

[17:03] <ruoso> and never the "defined object as superclass" as I was thinking possible before

[17:04] <TimToady> yes, it's not prototyping in that sense

[17:04] <TimToady> that we'd think of more as delegation

[17:05] <ruoso> ok... in fact I have to admit it was a very exotic feature

[17:05] <TimToady> has $.ancestor handles *;

[17:05] <allbery_b> hm.  I

[17:05] <allbery_b> 'm a little worried about things like "single isa"

[17:06] *** marmic left
[17:06] <ruoso> allbery_b, that only means that it is an instance of some prototype

[17:06] <ruoso> but the prototype still can have MI

[17:06] <allbery_b> maybe a .PROTO which is True initially; .new on such a thing rolls an inmstance (which automatically has .PROTO False), .BUILDALL fails if .PROTO

[17:06] *** pmurias left
[17:07] <ruoso> allbery_b, take a look at pugs/v6/smop/src-s1p/Object.pm

[17:07] <ruoso> that's what new, bless, CREATE and BUILDALL are supposed to do

[17:08] *** marmic joined
[17:09] <TimToady> I'm not sure .WHAT should ever return something defined

[17:09] <ruoso> TimToady, that won't be the case anymore

[17:09] <ruoso> considering this last restriction

[17:10] <ruoso> you won't be able to have a defined object as a prototype

[17:10] <pugs_svnbot> r19893 | ruoso++ | [smop] "fail if not $object.^!instance;" in Objects BUILDALL

[17:10] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19893

[17:10] <lambdabot> Title: Changeset 19893 - Pugs - Trac

[17:13] <ruoso> TimToady, I've just updated the wiki to reflect that

[17:13] <TimToady> typo: Array or Role

[17:14] *** Psyche^ joined
[17:14] <ruoso> fixed, thanks

[17:16] <TimToady> we're assuming here that an object can only have one package, which is probably reasonable, even though one could alias additional names

[17:16] <ruoso> TimToady, that's the class package, not the instance

[17:16] *** riffraff left
[17:16] <ruoso> I'm not sure package of a instance makes sense

[17:17] <TimToady> well, p5 has that, but that's because the package *is* the class in p5

[17:18] <ruoso> in fact, I was considering it as one of the "definitions" that a defined object is forbidden to have

[17:19] <ruoso> I mean... 

[17:19] <ruoso> $foo.WHO is always $foo.WHAT.WHO

[17:19] <ruoso> if $foo is defined

[17:21] <TimToady> almost seems like we're trying to discuss policy that should be determined by .HOW

[17:21] <TimToady> .HOW should be deciding how proto/class-based we are

[17:22] <TimToady> I'm inclined to leave out any arbitrary restrictions that can be decided later

[17:22] <TimToady> unless it can be shown to impact performance badly

[17:22] <ruoso> well, in fact Object defines the default HOW behaviour

[17:23] *** gbacon left
[17:23] <TimToady> I think .HOW is intrinsic to each object

[17:23] <ruoso> sure...

[17:23] *** gbacon joined
[17:23] <TimToady> you never inherit .HOW from Object

[17:23] <TimToady> except maybe by cloning

[17:23] <ruoso> but the built-in types will have a standard behaviour... that's what I mean

[17:24] <TimToady> *nod*

[17:24] *** aindilis joined
[17:24] <ruoso> we'll have to decide that at some point

[17:24] *** zamolxes joined
[17:24] <TimToady> at that level we are certainly class-based, not proto-based

[17:25] <ruoso> which seems to be consistent to what we reached now...

[17:26] <TimToady> in any case, native types *must* be class-based, for reasons that I hope are obvious

[17:27] <ruoso> sure...

[17:27] *** Patterner left
[17:27] *** Psyche^ is now known as Patterner

[17:27] <ruoso> the int prototype even have a different representation than an int object...

[17:28] <TimToady> built-in types that prefer to be class-based might be able to pretend proto-based to some extent

[17:28] <TimToady> we'll have to see how it goes, and what the common failure modes are

[17:29] <TimToady> there's a delicate balance between letting people do what they want, and letting them do what they don't want...

[17:29] *** luqui joined
[17:29] <TimToady> and we can even give them a knob to turn

[17:30] <TimToady> with a setting on one end that says "Let me do whatever I want to Object"

[17:30] <TimToady> and Num, and Str, etc

[17:30] <ruoso> including making Undef defined?

[17:30] <TimToady> indeed

[17:31] <TimToady> default is not, probably

[17:32] *** meppl joined
[17:32] <TimToady> have to run and save a matron in distress... &

[17:49] <pugs_svnbot> r19894 | ruoso++ | [smop] the foo( --> rettype) syntax is prettier than our rettype method foo()

[17:49] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19894

[17:49] <lambdabot> Title: Changeset 19894 - Pugs - Trac

[18:09] <ruoso> Object refers both to the package and to the class... does that means that there are two namespace resolutions?

[18:11] *** meppel-san joined
[18:15] *** blindfish joined
[18:20] *** pmurias joined
[18:21] <pmurias> one declares private methods with 'my method foo {...}' instead of 'my method !foo' ?

[18:23] <[particle]> the calling syntax is $obj!foo instead of $obj.foo

[18:23] <[particle]> declaration is without ! iirc

[18:23] *** njbartlett joined
[18:24] *** ebassi left
[18:27] *** meppl left
[18:30] <pmurias> fixing

[18:34] <pugs_svnbot> r19895 | pmurias++ | [smop] fixed minor syntax issue, private methods are declared with my method foo {...}

[18:34] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19895

[18:34] <lambdabot> Title: Changeset 19895 - Pugs - Trac

[18:37] *** rintaro joined
[18:39] *** wknight-away left
[18:39] <ruoso> pmurias, [particle], I'm not sure... S12 seems to imply that my method !foo is the way of declaring a private method

[18:40] <ruoso> ah... ok... 

[18:40] <ruoso> there's a spot in S12 referring to that syntax

[18:40] <ruoso> but the correct seems to be my method foo

[18:41] <ruoso> S12 says my method !foo for private methods of a Role

[18:41] <ruoso> but I think that's probably wrong

[18:41] <ruoso> I can't really see a reason for private methods to be declared differently in Classes and Roles

[18:41] <pmurias> me neither

[18:42] <[particle]> no, me neither. i think the spec is wrong there.

[18:45] *** rdice_ joined
[18:45] *** rdice left
[18:46] <ruoso> Ok... I think I'll consider starting to implement p6opaque

[18:46] <ruoso> If anyone have any comment on the smop oo api or in the p6opaque structure

[18:46] <ruoso> please do it *now*

[18:47] *** jjore-w joined
[18:48] <pmurias> ruoso: does it make sense to keep the metadata in the object

[18:48] <pmurias> ?

[18:49] <ruoso> the idea is to have the same representation to the undefined and defined values

[18:49] <ruoso> that is important to enable autovivificatoin

[18:50] <ruoso> Dog{ name => fido } is my $a = Dog.clone; $a.^!whence = sub { name => fido };

[18:50] <ruoso> actually not quite that

[18:51] <ruoso> Dog{ name => fido } is my $a = Dog.CREATE(); $a.^!isa.push(Dog); $a.^!whence = sub { name => fido };

[18:51] <ruoso> changing the representation of an object is not really doable, because it might involve realloc

[18:52] *** luqui left
[18:53] <pmurias> swimming&

[19:01] *** buchetc joined
[19:03] *** justatheory joined
[19:03] *** buchetc left
[19:04] <ruoso> TimToady, at S12, in "Construction and Initialization", it's implied that BUILD might receive positional arguments... But the positional arguments to BUILDALL are already the protoobjects from which the new object will be initialized... is that just a misleading example?

[19:05] <ruoso> in theory, BUILD will always receive named arguments... BUILDALL is supposed to take the whence closures and send it as parameters when the type match

[19:07] *** r0bby joined
[19:11] <ruoso> hmmm...

[19:11] <ruoso> if a whence closure returns positional arguments, BUILD might receive positional arguments

[19:12] <ruoso> it makes sense now...

[19:15] *** buchetc joined
[19:19] *** TJCRI joined
[19:22] <pugs_svnbot> r19896 | buchetc++ | [async.t] numer-/stringify more perl6ish

[19:22] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19896

[19:22] <lambdabot> Title: Changeset 19896 - Pugs - Trac

[19:25] *** meppel-san is now known as meppl

[19:28] *** rindolf joined
[19:30] <ruoso> about Undef, one could argue that Undef is the immediate result of CREATE(), which was not yet blessed, therefore isn't really an Object yet...

[19:31] <ruoso> and that won't even have an isa

[19:31] <ruoso> it's simply Undef

[19:31] <ruoso> pugs: say Undef ~~ Object

[19:31] <exp_evalbot> OUTPUT[*** No such subroutine: "&Undef"␤    at /tmp/KAOTAZeuU3 line 1, column 5 - line 2, column 1␤]

[19:31] <ruoso> pugs: say undef ~~ Object

[19:31] <exp_evalbot> OUTPUT[1␤]

[19:33] <ruoso> it actually makes sense... you can't call any methods in Undef

[19:34] <ruoso> it's not even a class yet

[19:34] <ruoso> it becomes a class in the moment Object is added to its isa

[19:35] <TimToady> there is no Undef type, period

[19:35] <TimToady> I just wrote it out of the synopses

[19:36] <ruoso> pugs: say Object.CREATE().WHAT

[19:36] <exp_evalbot> OUTPUT[*** No such method in class Object: "&CREATE"␤    at /tmp/jIDOmcbYc1 line 1, column 5 - line 2, column 1␤]

[19:36] <pugs_svnbot> r19897 | buchetc++ | [async.t] numer-/stringify more perl6ish

[19:36] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19897

[19:36] <lambdabot> Title: Changeset 19897 - Pugs - Trac

[19:37] <ruoso> the value returned from CREATE is not yet blessed... how do you define it?

[19:37] <ruoso> it's not an Object yet

[19:37] <ruoso> it's not even an undefined Object

[19:38] <ruoso> s/how do you define it/how do you name it/

[19:39] <ruoso> or should CREATE always return something that is already an Object

[19:41] <TimToady> "Everything is an object"

[19:42] <ruoso> but it doesn't need to inherit from Object to be an object

[19:42] <ruoso> even the native types are objects

[19:42] <ruoso> (at least in smop)

[19:43] <TimToady> think of CREATE as more like .clone

[19:43] <TimToady> it changes the identity, but does not define it

[19:43] <TimToady> .bless defines it, but does not change its identity

[19:44] <pmichaud> question on #parrot:   what does 'undef' return?

[19:44] <TimToady> Object

[19:44] <pmichaud> okay, thanks.  I can't find it in the synopses... but perhaps I'm just reading it wrong

[19:44] <TimToady> actually, no

[19:45] <TimToady> I just specced it to return Failure

[19:45] <TimToady> it's just the most generic failure

[19:45] <pmichaud> okay

[19:45] <TimToady> we don't want to confuse bad undef with good undef  :)

[19:46] <pmichaud> an unhandled or handled failure?

[19:46] <TimToady> probably handled, but that's just a guess

[19:47] <TimToady> if you want an unhandled you should probably use fail anyway

[19:47] <ruoso> and what about use fatal?

[19:47] <TimToady> but I could argue it the other way too

[19:47] <pmichaud> agreed

[19:47] *** kst joined
[19:47] <ruoso> if undef returns a failure, it would fail immediatly in use fatal

[19:47] <ruoso> s/fail/die/

[19:48] <TimToady> I imagine some people would like that...

[19:48] <cognominal_> TimToady, what is the type of a mere undef,  Object or Failure?

[19:48] <TimToady> the type is Failure

[19:48] <ruoso> I wouldn't expect a mere undef to die under use fatal

[19:49] <TimToady> then use Object instead of undef

[19:49] <ruoso> hmm...

[19:49] * ruoso feeling unconfortable with that

[19:50] <TimToady> actually, I don't think it would die

[19:50] <cognominal_> S04.pod talks about failure but not of a mere undef.

[19:50] <TimToady> fail is what looks at its context to see if it should die

[19:50] <TimToady> you can return a Failure of any sort without dying under 'use fatal'

[19:50] <cognominal_> ho yes, my bad

[19:51] <TimToady> so I think it's okay for undef to be the most general kind of Failure object

[19:51] <TimToady> and marking it handled is also the most benign thing to do

[19:51] <cognominal_> I guess it would be good to say it explicitely in  S04 =head1 Exception

[19:51] <TimToady> but can still complain if you try to take a value from it

[19:52] <cognominal_> one can infer it, but thick headed people like me don't get it.

[19:52] <TimToady> prolly, there's never enough spec to go 'round...

[19:52] <cognominal_> :)

[19:53] <cognominal_> I must say they have improved much lately even if it need more to read.

[19:53] <ruoso> I was really thinking that Failure would look for "use fatal" in it's constructor...

[19:55] <TimToady> makes it really hard to deal with Failure objects as mere objects when you need to

[19:55] <pugs_svnbot> r19898 | buchetc++ | [async.t] revert to last version (unforced check in)

[19:55] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19898

[19:55] <lambdabot> Title: Changeset 19898 - Pugs - Trac

[19:55] <TimToady> so I think that behavior should probably be attached to the verb, not the noun

[19:56] <cognominal_> hum, prolly is not in Macbook dictionnary, I had to google for it :)

[19:56] <ruoso> so return Failure would never die immediatly

[19:57] <TimToady> I believe that's the correct approach

[19:57] <ruoso> but would still die when it goes out of scope

[19:57] <TimToady> only if it's been installed into $!

[19:57] <pugs_svnbot> r19899 | cosimo++ | [t/spec] Refactored want.t tests under t/spec/S06.

[19:57] <pugs_svnbot> r19899 | cosimo++ | Fudge-ified tests marked as todo.

[19:57] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19899

[19:57] <lambdabot> Title: Changeset 19899 - Pugs - Trac

[19:58] <ruoso> ahmmm... ok...

[19:58] <ruoso> so it's the block who should look for $!

[19:58] <TimToady> and see if it contains any unhandled failures

[19:58] *** cosimo_ joined
[19:59] <TimToady> (we try not to throw away exception information in case there are cascading exceptions)

[19:59] <ruoso> but doing that for every block exit may look like too much overhead

[19:59] <pugs_svnbot> r19900 | cosimo++ | [t] Fudge-ified tests marked as todo. Pod syntax fixed.

[19:59] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19900

[19:59] <lambdabot> Title: Changeset 19900 - Pugs - Trac

[19:59] *** ebassi joined
[20:00] <TimToady> if you can prove that all calls are tested by // then you can skip the test

[20:01] *** rindolf left
[20:01] <ruoso> which is much unlikely

[20:01] <ruoso> considering we're talking about *every* method call

[20:02] <TimToady> it's still only a test of a single lexical

[20:02] <TimToady> don't see how that can be very high overhead

[20:02] <TimToady> most of the smarts are in the fail() function

[20:02] *** cosimo joined
[20:02] <TimToady> and it's why we mark $! as context var, so that fail can get at it

[20:02] <cosimo> hi

[20:03] <TimToady> howdy

[20:04] <ruoso> it just freak me out the idea of having to do that in absolutely every block exit (including loops, closures etc)

[20:04] <TimToady> the mechanism is intentionally designed to force most of the calculations into fail() so we don't have to set up try {...} everywhere, which would much heavier than testing $! at the end

[20:07] <TimToady> and in the absence of an exception of some sort, it's a simple boolean test

[20:07] <pugs_svnbot> r19901 | buchetc++ | [async.t] revert to last version (unforced check in)

[20:07] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19901

[20:07] <lambdabot> Title: Changeset 19901 - Pugs - Trac

[20:08] <ruoso> ok... I'm still unconfortable with it... but... if that's the way it is... 

[20:09] * ruoso home &

[20:09] <TimToady> think of it as one of the prices you pay for disruptive technology :)

[20:10] <ruoso> heh

[20:14] *** manfred left
[20:16] *** fridim_ left
[20:18] *** cosimo_ left
[20:18] <pugs_svnbot> r19902 | buchetc++ | [async.t] unforced checkin once again (beg for pardon)

[20:18] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19902

[20:18] <lambdabot> Title: Changeset 19902 - Pugs - Trac

[20:19] *** Psyche^ joined
[20:35] *** lisppaste3 left
[20:35] *** Patterner left
[20:35] *** Psyche^ is now known as Patterner

[20:39] *** Psyche^ joined
[20:39] *** Patterner left
[20:39] *** Psyche^ is now known as Patterner

[20:40] *** njbartlett_ joined
[20:40] <cosimo> thttp://satsrv03.ud.satelgroup.net/src/view/projects/csc/slim/cgi-bin/ws/lego.diff?r1=1.1&r2=1.2

[20:40] <lambdabot> http://tinyurl.com/ytfyqj

[20:40] <cosimo> sorry, wrong window :-|

[20:43] <pmurias> TimToady: is there a description of a tagged DFS anywhere?

[20:43] <pmurias> * DFA

[20:45] *** thoughtpolice joined
[20:46] <TimToady> http://laurikari.net/ville/spire2000-tnfa.pdf

[20:48] <wolverian> dammit, of course it's again some dude from the *other* university in town..

[20:48] <wolverian> damn them and their useful results :)

[20:53] *** ilogger2 joined
[20:54] <TimToady> also see the discussion at http://lambda-the-ultimate.org/node/2064

[20:54] <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast | Lambda the Ultimate

[20:54] <pugs_svnbot> r19903 | cosimo++ | [t/spec] Refactored builtins/strings/trans.t tests into S05-transliteration.

[20:54] <pugs_svnbot> r19903 | cosimo++ | Fixed pod and :todo tests.

[20:54] <pugs_svnbot> diff: http://dev.pugscode.org/changeset/19903

[20:54] <lambdabot> Title: Changeset 19903 - Pugs - Trac

[22:13] *** Jamtech joined
[22:15] <buchetc> pugs: say Thread.HOW.name

[22:15] <exp_evalbot> OUTPUT[Thread␤]

[22:16] <buchetc> Exists a Thread.pm in perl6?

[22:16] *** peeps[work] joined
[22:16] <TimToady> not really correct

[22:16] <TimToady> not specced

[22:17] <TimToady> but apparently pugs believes in the name

[22:17] <TimToady> the part that's not correct is that .HOW should lead to the metaclass instance, whose stringification isn't Thread

[22:18] <buchetc> pugs: IO.HOW.name

[22:18] <exp_evalbot> RESULT["IO"]

[22:18] <buchetc> also not correct?

[22:19] <TimToady> should probably say ^IO

[22:20] <buchetc> ok, now I'm with you

[22:20] <TimToady> but pugs never got MO quite...

[22:21] <TimToady> commuting &

[22:29] <buchetc> I'm looking for construct like async { say self.tid; }

[22:31] <buchetc> pugs: say +async { }

[22:31] <exp_evalbot> OUTPUT[*** ␤    Unexpected end of input␤    Closing hash curly may not terminate a line;␤    please add a comma or a semicolon to disambiguate␤    at /tmp/2KE0LD2JKi line 2, column 1␤]

[22:32] <buchetc> pugs: say +async{};

[22:32] <exp_evalbot> OUTPUT[*** No compatible multi variant found: "&async"␤    at /tmp/sC3xdd0IKn line 1, column 5-13␤]

[22:33] <buchetc> pugs: say ~async{ };

[22:33] <exp_evalbot> OUTPUT[*** No compatible multi variant found: "&async"␤    at /tmp/YrAnAQNn4O line 1, column 5-14␤]

[22:34] <buchetc> pugs: $thr = async{ }; say ~$thr;

[22:34] <exp_evalbot> OUTPUT[*** ␤    Unexpected " ="␤    expecting "::"␤    Variable "$thr" requires predeclaration or explicit package name␤    at /tmp/kNjtPdeIEu line 1, column 5␤]

[22:35] <[particle]> seems to me there is no async.

[22:35] <[particle]> search the tests to be sure.

[22:37] <buchetc> same call works in my environment; also  t/spec/S17-async/async.t  works at the smoke server

[22:39] <[particle]> maybe it's not safe.

[22:40] <buchetc> yes, that's what I think too 

[22:40] <buchetc> but original question is about the class 'Thread'. I'm looking for doc about it

[22:41] <[particle]> (14:16:22) TimToady: not really correct

[22:41] <[particle]> (14:16:50) TimToady: not specced

[22:42] *** wknight8111 joined
[22:50] *** alester joined
[22:54] <TimToady> all there is at this point is whatever is down in docs/Perl6/Spec/Concurrency.pod

[22:54] <TimToady> but it's a big mess

[22:58] <TimToady> unfortunately, it's probably going to take a designer to clean it up

[23:01] <buchetc> My attempt was to describe what's already working in S17.

[23:02] <buchetc> Perhaps then cleaning up is more easy 

[23:08] <buchetc> bed &

[23:10] *** peeps[work] left
[23:11] *** apple-gunkies joined
[23:22] *** Jamtech left
[23:23] *** alester is now known as AndyAway

[23:26] *** justatheory_ joined
[23:27] *** justatheory_ left
[23:49] <meppl> good night

