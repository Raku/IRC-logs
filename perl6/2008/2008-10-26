[00:01] *** sri_kraih left
[00:01] *** sri_kraih joined
[00:02] *** jan__ left
[00:02] *** sri_kraih left
[00:03] *** sri_kraih joined
[00:05] *** jan_ joined
[00:16] *** pedrob left
[00:24] *** eternaleye left
[00:24] *** smg joined
[00:31] *** eternaleye joined
[00:39] *** ispy_ left
[00:40] *** sri_kraih left
[00:41] *** sri_kraih joined
[00:57] *** alester joined
[00:58] *** cookys_ left
[01:08] *** explorer left
[01:21] *** eternaleye left
[01:25] *** ai369_ joined
[01:33] *** ai369_ left
[01:54] *** eternaleye joined
[02:03] *** alester left
[02:28] *** justatheory left
[02:30] *** r0bby joined
[02:33] *** eternaleye left
[02:34] *** alester joined
[02:45] *** azawawi joined
[02:57] <pugs_svn> r22770 | azawawi++ | [STD_syntax_highlight] updated SYNOPSIS for --simple

[03:00] *** hercynium joined
[03:00] *** Psyche^ joined
[03:01] *** Patterner left
[03:01] *** Psyche^ is now known as Patterner

[03:02] *** elmex_ joined
[03:11] <pugs_svn> r22771 | azawawi++ | [STD_syntax_highlight] added --help

[03:11] <pugs_svn> r22771 | azawawi++ | [STD_syntax_highlight] the filename is checked now before passing it to STD

[03:12] *** Ral_ joined
[03:12] *** Ral_ left
[03:17] *** elmex left
[03:17] *** elmex_ is now known as elmex

[03:19] *** awwaiid joined
[03:22] *** jamtech joined
[03:36] *** eternaleye joined
[03:43] <pugs_svn> r22772 | azawawi++ | [STD_syntax_highlight] ignore #elem "color" css in --simple mode

[03:49] *** jamtech left
[04:03] *** elmex_ joined
[04:04] *** Psyche^ joined
[04:14] *** elmex left
[04:14] *** elmex_ is now known as elmex

[04:16] *** Patterner left
[04:16] *** Psyche^ is now known as Patterner

[04:17] *** hercynium left
[04:19] <pugs_svn> r22773 | azawawi++ | [STD_syntax_highlight] support #-comments in --simple mode

[04:20] *** jauaor left
[04:21] *** cognominal left
[04:21] *** araujo left
[04:54] *** cognominal joined
[05:00] <azawawi> @tell moritz_ im getting nouns for =begin pod comments from STD_syntax_highlight, is that the right behavior?

[05:00] <lambdabot> Consider it noted.

[05:00] <azawawi> @tell lambdabot Hi5

[05:00] <lambdabot> Nice try ;)

[05:01] *** azawawi left
[05:22] *** eternaleye left
[05:22] *** eternaleye joined
[05:27] *** abra joined
[05:42] *** abra left
[06:05] *** alester left
[06:15] *** jfredett left
[06:20] *** abra joined
[06:20] *** abra left
[06:20] *** abra joined
[07:28] *** abra left
[07:51] *** eternaleye left
[07:53] *** PZt left
[08:03] *** iblechbot joined
[08:13] *** alanhaggai joined
[08:15] *** pbuetow joined
[08:29] *** eternaleye joined
[08:31] *** iblechbot left
[08:34] <moritz_> good morning

[08:34] <lambdabot> moritz_: You have 1 new message. '/msg lambdabot @messages' to read it.

[08:36] *** pbuetow left
[08:36] *** pbuetow joined
[08:46] *** kanru left
[08:47] *** kanru joined
[08:58] *** schmalbe joined
[09:05] *** mberends joined
[09:16] *** araujo joined
[09:17] *** bacek joined
[09:17] <bacek> pugs: say (Bool::True|Bool::False).perl

[09:17] <p6eval> pugs: OUTPUT[(Bool::False | Bool::True)␤]

[09:17] <bacek> pugs: say (Bool::True|Bool::False | Bool::False).perl

[09:17] <p6eval> pugs: OUTPUT[*** No compatible multi variant found: "&Bool::False"␤    at /tmp/h5YgqYh5Yb line 1, column 6-42␤]

[09:17] <bacek> pugs: say (Bool::True|Bool::False|Bool::False).perl

[09:17] <p6eval> pugs: OUTPUT[(Bool::False | Bool::True)␤]

[09:18] <bacek> pugs: say (1|2|3).perl

[09:18] <p6eval> pugs: OUTPUT[(1 | 2 | 3)␤]

[09:18] <bacek> pugs: say (1|2|3|2|1).perl

[09:18] <p6eval> pugs: OUTPUT[(1 | 2 | 3)␤]

[09:18] <bacek> pugs: say (1|2|3|2|1|Bool::False).perl

[09:18] <p6eval> pugs: OUTPUT[(Bool::False | 1 | 2 | 3)␤]

[09:19] <bacek> pugs: say (1|2|3|2|1|Bool::False|"foo"|"foo"|"bar").perl

[09:19] <p6eval> pugs: OUTPUT[(Bool::False | 1 | 2 | 3 | "bar" | "foo")␤]

[09:19] <bacek> rakudo: say (1|2|3|2|1|Bool::False|"foo"|"foo"|"bar").perl

[09:19] <p6eval> rakudo 31963: OUTPUT[any(1, 2, 3, 2, 1, Bool::False, "foo", "foo", "bar")␤]

[09:20] <bacek> perl6: say uniq(<1 2 3 2 1 Bool::False "foo" "foo" "bar">

[09:20] <p6eval> elf 22773: OUTPUT[Parse error in: /tmp/5VDlzXFreK␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say uniq(<1 2 3 2 1 Bool::Fals␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[09:20] <p6eval> ..STD_r...

[09:20] <p6eval> ..pugs: OUTPUT[*** ␤    Unexpected end of input␤    expecting operator, ":" or ")"␤    at /tmp/CaLmrNGjzr line 2, column 1␤]

[09:20] <p6eval> ..rakudo 31963: OUTPUT[Statement not terminated properly at line 1, near "(<1 2 3 2 "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[09:21] <bacek> perl6: say <1 2 3 2 1 Bool::False "foo" "foo" "bar">.uniq

[09:21] <p6eval> elf 22773: OUTPUT[Can't call method "uniq" on unblessed reference at (eval 117) line 3.␤ at ./elf_f line 3861␤]

[09:21] <p6eval> ..pugs, rakudo 31963: OUTPUT[123Bool::False"foo""bar"␤]

[09:30] <bacek> pugs: say ((1|2|3) < 2).perl

[09:30] <p6eval> pugs: OUTPUT[(Bool::False | Bool::True)␤]

[09:30] <bacek> rakudo: say ((1|2|3) < 2).perl

[09:30] <p6eval> rakudo 31963: OUTPUT[Bool::True␤]

[09:48] *** mberends left
[09:51] *** mberends joined
[10:02] *** z80ASM joined
[10:05] *** adc_Penner joined
[10:12] *** z80ASM left
[10:16] *** z80ASM joined
[10:18] *** bacek_ joined
[10:18] *** bacek left
[10:41] *** iblechbot joined
[10:41] <wayland76> rakudo: say what?

[10:41] <p6eval> rakudo 31963: OUTPUT[Statement not terminated properly at line 1, near "?"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[10:41] <wayland76> rakudo: eh what?

[10:41] <p6eval> rakudo 31963: OUTPUT[Statement not terminated properly at line 1, near "?"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[10:44] *** ihrd joined
[11:00] *** Alias_ joined
[11:02] *** alanhaggai left
[11:13] *** kanru left
[11:13] *** kanru joined
[11:24] *** pedrob joined
[11:28] *** kanru left
[11:29] *** pedrob left
[11:30] *** fronty joined
[11:30] *** kanru joined
[11:37] <bacek_> perl6: say int((1||2))

[11:37] <p6eval> elf 22773: OUTPUT[Undefined subroutine &GLOBAL::circumfix_i_32_41 called at (eval 119) line 3.␤ at ./elf_f line 3861␤]

[11:37] <p6eval> ..pugs, rakudo 31963: OUTPUT[1␤]

[11:37] <bacek_> perl6: say int((1|2))

[11:37] <p6eval> elf 22773: OUTPUT[Undefined subroutine &GLOBAL::circumfix_i_32_41 called at (eval 121) line 3.␤ at ./elf_f line 3861␤]

[11:37] <p6eval> ..rakudo 31963: OUTPUT[Method 'truncate' not found for invocant of class 'Junction'␤current instr.: 'parrot;Any;int' pc 10245 (src/gen_builtins.pir:6438)␤]

[11:37] <p6eval> ..pugs: OUTPUT[any(VInt 1,VInt 2)␤]

[11:38] <moritz_> int(1|2) should return (1|2)

[11:39] <bacek_> moritz_: agreed... I'm trying to fix rakudo's Junction to be proper junctions...

[11:40] <moritz_> bacek_: and change the dispatcher to do autothreading?

[11:40] *** meppl joined
[11:40] <ihrd> intresting, what should return int (1.1|2)? (1|2)?

[11:40] <bacek_> moritz_: yes. But I'm failing all the time

[11:41] <moritz_> ihrd: right

[11:41] <bacek_> rakudo: say list(1|2, 2|3).uniq.perl

[11:41] <p6eval> rakudo 31963: OUTPUT[Multiple Dispatch: No suitable candidate found for 'is_equal', with signature 'PP->I'␤current instr.: 'parrot;List;uniq' pc 3324 (src/gen_builtins.pir:2212)␤]

[11:41] <bacek_> moritz_: it's one of examples...

[11:41] <moritz_> bacek_: I guess it's non-trivial, which is why no implementation does it right atm

[11:41] *** fronty left
[11:41] <moritz_> rakudo: say (1, 2, 3).uniq

[11:41] <p6eval> rakudo 31963: OUTPUT[123␤]

[11:41] <bacek_> moritz_: pugs is very close to.

[11:42] <moritz_> we have List.uniq? even though it's not clear in the spec? /me is surprised

[11:42] <moritz_> pugs: say 1|2

[11:42] <p6eval> pugs: OUTPUT[any(VInt 1,VInt 2)␤]

[11:42] <moritz_> that should print either 1\n2\n or 2\n1\n

[11:43] <bacek_> moritz_: yes, List.uniq is unspecced

[11:46] <bacek_> rakudo: say list(1|2) eq list(2|3)

[11:46] <p6eval> rakudo 31963: OUTPUT[get_string() not implemented in class 'Junction'␤current instr.: 'parrot;List;get_string' pc 2430 (src/gen_builtins.pir:1717)␤]

[11:46] <bacek_> rakudo: say (list(1|2) eq list(2|3)).perl

[11:46] <p6eval> rakudo 31963: OUTPUT[get_string() not implemented in class 'Junction'␤current instr.: 'parrot;List;get_string' pc 2430 (src/gen_builtins.pir:1717)␤]

[11:46] <bacek_> crap...

[11:53] *** araujo left
[11:59] *** araujo joined
[12:12] *** schmalbe left
[12:18] <bacek_> perl6: say ((1|2)+1).perl

[12:18] <p6eval> rakudo 31963: OUTPUT[any("2", "3")␤]

[12:18] <p6eval> ..pugs: OUTPUT[(2 | 3)␤]

[12:18] <p6eval> ..elf 22773: OUTPUT[4␤]

[12:19] <bacek_> rakudo's hashes always stringifies keys...

[12:20] <bacek_> s/rakudo/parrot/

[12:21] *** lumi left
[12:21] *** zamolxes left
[12:21] *** z80ASM left
[12:26] *** abra joined
[12:39] <moritz_> bacek_: in Perl 6 that'ds a feature

[12:41] *** pedrob joined
[12:45] <bacek_> moritz_: which one?

[12:47] <bacek_> perl: my %h = (Bool::True => 1); say %h.keys

[12:48] <bacek_> perl6: my %h = (Bool::True => 1); say %h.keys

[12:48] <p6eval> elf 22773: OUTPUT[Bool::True␤]

[12:48] <p6eval> ..rakudo 31963: OUTPUT[1␤]

[12:48] <p6eval> ..pugs: OUTPUT[*** ␤    Unexpected "%h"␤    expecting "=", context, ":" or "("␤    at /tmp/C0vRNtIdY2 line 1, column 4␤]

[12:51] <bacek_> perl6: my %h; %h<Bool::True> = 1; say %h.keys

[12:51] <p6eval> elf 22773, pugs, rakudo 31963: OUTPUT[Bool::True␤]

[12:59] <moritz_> bacek_: hash keys are strings.

[13:11] <bacek_> moritz_: how you can explain mine last example?

[13:11] <bacek_> perl6: my %h; %h<Bool::True> = 1; %h<1>=2; say %h.keys

[13:11] <p6eval> elf 22773: OUTPUT[1Bool::True␤]

[13:11] <p6eval> ..pugs, rakudo 31963: OUTPUT[Bool::True1␤]

[13:12] <bacek_> perl6: my %h = {Bool::True => 1}; say %h.keys

[13:12] <p6eval> elf 22773: OUTPUT[Bool::True␤]

[13:12] <p6eval> ..pugs: OUTPUT[*** ␤    Unexpected "%h"␤    expecting "=", context, ":" or "("␤    at /tmp/MwC8BIMA0A line 1, column 4␤]

[13:12] <p6eval> ..rakudo 31963: OUTPUT[1␤]

[13:12] <bacek_> it's... weird

[13:13] <moritz_> uhm, %h<...> expects a string literal in place of the ...

[13:13] <moritz_> that explains 13:51 < bacek_> perl6: my %h; %h<Bool::True> = 1; say %h.keys

[13:16] <bacek_> moritz_: but result is not string...

[13:17] <moritz_> rakudo: my %h; %h<Bool::True> = 1; %h<1>=2; say %h.keys.[0].WHAT

[13:17] <p6eval> rakudo 31963: OUTPUT[Str␤]

[13:17] <moritz_> that looks like a string to me.

[13:18] <bacek_> perl6: my %h; %h<Bool::True> = 1; %h<"Bool::True">=2; say %h.keys

[13:18] <p6eval> pugs, rakudo 31963: OUTPUT[Bool::True"Bool::True"␤]

[13:18] <p6eval> ..elf 22773: OUTPUT["Bool::True"Bool::True␤]

[13:19] <moritz_> sure, if you write %h<"> the " will be part of the hash key.

[13:22] *** simcop2387 left
[13:23] *** simcop2387 joined
[13:25] <bacek_> perl6: my %h; %h<Bool::True> = 1; my $a="<Bool::True>"; %h<$a>=2; say %h.keys

[13:25] <p6eval> elf 22773, pugs, rakudo 31963: OUTPUT[Bool::True$a␤]

[13:25] <bacek_> perl6: my %h; %h<Bool::True> = 1; my $a="<Bool::True>"; %h{$a}=2; say %h.keys

[13:25] <p6eval> rakudo 31963: OUTPUT[Bool::True<Bool::True>␤]

[13:25] <p6eval> ..elf 22773, pugs: OUTPUT[<Bool::True>Bool::True␤]

[13:26] <bacek_> perl6: my %h; %h{Bool::True} = 1; my $a="<Bool::True>"; %h{$a}=2; say %h.keys

[13:26] <p6eval> rakudo 31963: OUTPUT[1<Bool::True>␤]

[13:26] <p6eval> ..pugs: OUTPUT[<Bool::True>1␤]

[13:26] <p6eval> ..elf 22773: OUTPUT[<Bool::True>Bool::True␤]

[13:26] *** meppl left
[13:27] <bacek_> perl6: my %h; %h{Bool::True} = 1; my $a=Bool::True; %h{$a}=2; say %h.keys

[13:27] <p6eval> elf 22773: OUTPUT[Bool::True␤]

[13:27] <p6eval> ..pugs, rakudo 31963: OUTPUT[1␤]

[13:28] <bacek_> hmm...

[13:29] *** mberends left
[13:29] <bacek_> perl6: my %h; %h{Bool::True} = 1; my $a=Bool::True; %h{$a}=2; say %h.keys.[0].WHAT

[13:29] <p6eval> elf 22773, pugs, rakudo 31963: OUTPUT[Str␤]

[13:31] <bacek_> perl6: say (1|"1 + 2).perl

[13:31] <p6eval> pugs: OUTPUT[*** ␤    Unexpected end of input␤    expecting block, "\\", variable name or "\""␤    at /tmp/Yaq296kC9g line 2, column 1␤]

[13:31] <p6eval> ..elf 22773: OUTPUT[Parse error in: /tmp/G8TxiCxQnx␤panic at line 1 column 8 (pos 8): Error in quotesnabber␤WHERE: say (1|"1 + 2).perl␤WHERE:        /\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:1298:in `quotesnabber'␤  (eval):1:in `__quote_6321039'␤  STD_red/prelude.rb:406:in

[13:31] <p6eval> ..`bloc...

[13:31] <p6eval> ..rakudo 31963: OUTPUT[Statement not terminated properly at line 1, near "|\"1 + 2).p"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[13:31] <bacek_> perl6: say (1|"1" + 2).perl

[13:31] <p6eval> elf 22773: OUTPUT[3␤]

[13:31] <p6eval> ..rakudo 31963: OUTPUT[any(1, 3)␤]

[13:31] <p6eval> ..pugs: OUTPUT[(1 | 3.0)␤]

[13:31] <bacek_> perl6: say (1|"3" + 2).perl

[13:31] <p6eval> rakudo 31963: OUTPUT[any(1, 5)␤]

[13:31] <p6eval> ..pugs: OUTPUT[(1 | 5.0)␤]

[13:31] <p6eval> ..elf 22773: OUTPUT[5␤]

[13:32] <bacek_> perl6: say (1|"3" x 2).perl

[13:32] <p6eval> rakudo 31963: OUTPUT[any(1, "33")␤]

[13:32] <p6eval> ..pugs: OUTPUT[(1 | "33")␤]

[13:32] <p6eval> ..elf 22773: OUTPUT[33␤]

[13:35] *** mberends joined
[13:35] <bacek_> perl6: (say(1|2)>0).WHAT

[13:35] <p6eval> elf 22773: OUTPUT[3␤]

[13:35] <p6eval> ..rakudo 31963: OUTPUT[get_string() not implemented in class 'Junction'␤current instr.: 'print' pc 14650 (src/gen_builtins.pir:9033)␤]

[13:35] <p6eval> ..pugs: OUTPUT[any(VInt 1,VInt 2)␤]

[13:35] <bacek_> perl6: say ((1|2)>0).WHAT

[13:35] <p6eval> rakudo 31963: OUTPUT[Bool␤]

[13:35] <p6eval> ..pugs: OUTPUT[Junction␤]

[13:35] <p6eval> ..elf 22773: OUTPUT[Num␤]

[13:36] <bacek_> perl6: say (((1|2)>0)).WHAT

[13:36] <p6eval> rakudo 31963: OUTPUT[Bool␤]

[13:36] <p6eval> ..pugs: OUTPUT[Junction␤]

[13:36] <p6eval> ..elf 22773: OUTPUT[Num␤]

[13:36] <bacek_> perl6: say (?((1|2)>0)).WHAT

[13:36] <p6eval> rakudo 31963: OUTPUT[Bool␤]

[13:36] <p6eval> ..pugs: OUTPUT[Junction␤]

[13:36] <p6eval> ..elf 22773: OUTPUT[Int␤]

[13:48] *** pedrob left
[13:48] *** pedrob joined
[13:50] <bacek_> perl6. say 1|2

[13:50] <bacek_> perl6: say 1|2

[13:50] <p6eval> elf 22773: OUTPUT[3␤]

[13:50] <p6eval> ..rakudo 31963: OUTPUT[get_string() not implemented in class 'Junction'␤current instr.: 'print' pc 14650 (src/gen_builtins.pir:9033)␤]

[13:50] <p6eval> ..pugs: OUTPUT[any(VInt 1,VInt 2)␤]

[13:51] *** abra left
[13:53] *** abra joined
[14:03] *** alanhaggai joined
[14:06] *** abra left
[14:07] *** abra joined
[14:11] *** tjc001 joined
[14:12] *** pmurias joined
[14:12] <pmurias> bacek_: hash keys are string unless you specify otherwise

[14:14] *** ZuLuuuuuu joined
[14:20] *** tjc001 left
[14:28] *** hercynium joined
[14:32] *** ruoso joined
[14:34] *** ihrd left
[14:34] *** hercynium left
[14:35] *** ihrd joined
[14:35] <ihrd> rakudo: my $e = [1,2,3]; "YAY".say for $e;

[14:35] <p6eval> rakudo 31963: OUTPUT[YAY␤]

[14:36] <ihrd> rakudo: my $e = [1,2,3];  say $e.elems; "YAY".say for $e;

[14:36] <p6eval> rakudo 31963: OUTPUT[3␤YAY␤]

[14:37] <ruoso> pmurias, Hi!

[14:37] <ihrd> rakudo: my $e = [1,2,3]; my @a := $e; "YAY".say for @a;

[14:37] <p6eval> rakudo 31963: OUTPUT[YAY␤]

[14:37] <ihrd> argh

[14:38] *** alanhaggai_ joined
[14:38] *** alanhaggai left
[14:38] *** alanhaggai_ is now known as alanhaggai

[14:39] <ihrd> rakudo: my $e = [1,2,3]; say $e.WHAT; my @a := $e; say @a.WHAT; "YAY".say for @a;

[14:39] <p6eval> rakudo 31963: OUTPUT[Array␤Array␤YAY␤]

[14:39] <pmurias> ruoso: hi

[14:39] <ihrd> hi

[14:40] <ihrd> oh, soory

[14:40] <pmurias> ihrd: hi

[14:40] <ihrd> i just hope it works in trunk

[14:41] *** [particle] joined
[14:41] <ruoso> pmurias, I was thinking about add_method... maybe it shouldn't be that specific

[14:41] <ruoso> but something more generic, linked to the AST

[14:42] <ruoso> so new types of packages can handle new definitions

[14:42] <ruoso> in an easier way

[14:44] <pmurias> handling new definitions shouldn't be hard

[14:44] <pmurias> $?CLASS.add_action(...)

[14:46] <ruoso> you mean using that in the method name?

[14:46] <ruoso> s/that/the thing being defined/

[14:46] <pmurias> yes

[14:47] <ruoso> so, add_is ?

[14:47] <ruoso> add_does ?

[14:47] <ruoso> add_has ?

[14:47] <pmurias> add_parent

[14:47] <pmurias> add_attribute

[14:47] <pmurias> compose_role

[14:47] <ruoso> right... that was my point...

[14:47] <ruoso> I was thinking it would be nice to require less logic...

[14:48] <ruoso> making it more AST-related

[14:48] <pmurias> new_definition("has",....)

[14:48] <ruoso> yeah... something like that

[14:48] <pmurias> it seems to duplicate the method dispatch

[14:48] <ruoso> hm?

[14:49] <ruoso> this is in declaration time...

[14:49] <ruoso> not in runtime

[14:49] <pmurias> what i mean the new_definition will just redispatch new_definition to a different method call

[14:49] <ruoso> is routine_declarator a multi-token ? (is it multi-token the name?)

[14:50] <pmurias> it's a multi-token

[14:50] <pmurias> see STD.pm

[14:52] <pmurias> re AST-related have in mind our IR (in mildew) desugars everything to method calls

[14:53] <ruoso> exactly... so it could follow this logic indepedently of which type of declaration

[14:53] <ruoso> maybe make it specific to each of the STD multi-tokens...

[14:53] <ruoso> like routine_declarator

[14:53] <ruoso> scope_declarator

[14:54] <ruoso> trait_auxiliary

[14:54] <ruoso> trait_verb etc

[14:55] <ruoso> then the user just need to associate the package_declarator keyword with the metaclass

[14:55] <ruoso> and add the tokens

[14:55] <ruoso> and that's all

[14:59] <pmurias> this logic = ?

[15:00] <ruoso> I mean that it could be blind to what the actual keywords are

[15:00] <ruoso> it would just call a method based on each STD multi-token was matched

[15:00] <ruoso> then you wouldn't need an exception in the compiler to allow a different keyword

[15:00] <ruoso> you just need to associate a package_declarator keyword with a metaclass

[15:01] <ruoso> that knows how to handles that keywords

[15:03] <pmurias> well yes

[15:17] *** [particle]1 joined
[15:20] *** alester joined
[15:24] <ruoso> pmurias, then I think the methods would be something like register_routine_declarator(...)

[15:24] <ruoso> but I'm still unsure on what the parameters would be

[15:25] *** ihrd left
[15:29] <pmurias> ruoso: i would rather go for manual specifing what a given grammar rule means

[15:30] *** ruoso left
[15:30] <pmurias> as the MOP will be used manually or from a grammar not inheriting from perl6

[15:33] *** [particle] left
[15:41] *** [particle]1 left
[15:46] *** mberends left
[15:54] *** justatheory joined
[15:58] *** justatheory left
[16:05] *** alanhaggai_ joined
[16:05] *** alanhaggai left
[16:05] *** alanhaggai_ is now known as alanhaggai

[16:13] *** ZuLuuuuuu left
[16:16] *** jhorwitz joined
[16:18] *** rindolf joined
[16:27] *** pedrob left
[16:29] *** dalek left
[16:30] *** dalek joined
[17:03] *** abra left
[17:05] *** zamolxes joined
[17:18] *** sidewinder128 joined
[17:21] <sidewinder128> Hello, anyone have an estimated when Perl6 will be released?

[17:23] <zamolxes> a new version is released every month..

[17:23] <zamolxes> (i'm talking about the parrot implementation, rakudo)

[17:24] *** apeiron left
[17:28] *** apeiron joined
[17:30] *** alester left
[17:35] <moritz_> sidewinder128: christmas.

[17:36] <moritz_> we just don't say which christams

[17:38] <sidewinder128> if is this one Awesome!

[17:38] <moritz_> that's rather unlikely.

[17:39] <sidewinder128> rakudo is getting stable to use?

[17:40] <moritz_> it's getting there, but slowly :/

[17:40] <moritz_> rakudo: say "hi to sidewinder128"

[17:40] <p6eval> rakudo 31963: OUTPUT[hi to sidewinder128␤]

[17:41] <moritz_> it passes nearly 4500 spec tests, if you want a number.

[17:41] <sidewinder128> oh nice

[17:42] <moritz_> there's a progress graph on http://rakudo.de/

[17:42] <lambdabot> Title: Rakudo - A Perl 6 Compiler

[17:42] <sidewinder128> I see

[17:43] <sidewinder128> ok thanks guys

[17:45] *** azawawi joined
[17:45] <azawawi> good evening

[17:47] <azawawi> moritz_: ping

[17:48] <moritz_> azawawi: pong

[17:48] <azawawi> moritz_: how r u?

[17:48] *** ZuLuuuuuu joined
[17:48] <moritz_> stressed

[17:48] <moritz_> have to work through a paper and diagonalize a matrix until tomorrow :/

[17:49] * azawawi finished a foosball tournament an hour ago ;-)

[17:49] *** smtms left
[17:50] *** [particle] joined
[17:50] <azawawi> i tried to work around =pod comments but STD prints out <span class="noun">

[17:51] <azawawi> any ideas?

[17:51] <moritz_> you could color noun in blue, and give all possible submatches of noun a different color

[17:52] <azawawi> i did a _comment for #-comments

[17:52] <moritz_> by re-parsing?

[17:52] <azawawi> s{}{}...

[17:57] * azawawi is generating a sample for moritz

[17:58] <azawawi> http://feather.perl6.nl/~azawawi/simple_test/array.t.simple.html

[17:59] <lambdabot> Title: ./STD_syntax_highlight ../../t/spec/S02-builtin_data_types/array.t

[17:59] *** sidewinder128 left
[18:03] <azawawi> moritz_: should STD_syntax_highlight read from STDIN?

[18:03] <moritz_> nice

[18:03] <moritz_> azawawi: perhaps if the file name is '-'

[18:04] *** alanhaggai left
[18:05] <azawawi> moritz_: im thinking how to generate 375 tests in a reasonable time [cron] while generating --simple and normal modes

[18:05] <moritz_> azawawi: I guess the most time is spent in STD.pm while parsing the file...

[18:06] <moritz_> azawawi: so re-use the parse tree to generate both output files

[18:07] <azawawi> moritz_: ./STD_syntax_highlight [filename|-] [rule] [--simple-output=filename1.html] [--full-output=filename2.html] ?

[18:07] <moritz_> azawawi: something like that, yes

[18:08] * azawawi is gonna watch spiderman 2 now... no university ;-)

[18:09] *** smtms joined
[18:23] *** [particle] left
[18:50] *** rindolf left
[18:52] <pugs_svn> r22774 | azawawi++ | [STD_syntax_highlight] --simple is now --simple-html=filename|-

[18:52] <pugs_svn> r22774 | azawawi++ | [STD_syntax_highlight] default full mode is now --full-html=filename|-

[18:52] <pugs_svn> r22774 | azawawi++ | [STD_syntax_highlight] not compatible atm with ETOOMUCHTIME

[19:07] *** ZuLuuuuuu left
[19:08] <pugs_svn> r22775 | azawawi++ | [STD_syntax_highlight] added file generation timestamp html comment

[19:12] *** abra joined
[19:19] *** masak joined
[19:22] *** abra left
[19:27] <pugs_svn> r22776 | azawawi++ | [STD_syntax_highlight] ETOOMUCHTIME now generates simple and full html in one run.

[19:27] <pugs_svn> r22776 | azawawi++ | [STD_syntax_highlight] fixed the wallclock benchmarking to nop instead of noc

[19:29] *** abra joined
[19:30] <azawawi> moritz_: ?

[19:31] <azawawi> moritz_: im trying to execute 'at now' to run ETOOMUCHTIME script but atd seems to be off

[19:31] <moritz_> azawawi: maybe connected the DST change today?

[19:32] <azawawi> moritz_: Can't open /var/run/atd.pid to signal atd. No atd running?

[19:33] <moritz_> azawawi: and is an atd running?

[19:34] <azawawi> moritz_: nop

[19:34] <moritz_> are you root on feather1?

[19:34] <azawawi> nop ;-)

[19:35] <moritz_> azawawi: try again please

[19:35] <azawawi> moritz_: perfect... i already had one queued ;-)

[19:36] <azawawi> moritz_: simple and full htmls in one run; within 3 hours we're gonna have some interesting stuff

[19:37] <moritz_> azawawi: pleae 'use POSIX qw(nice); nice(19)' at the very beginning... ;)

[19:38] <azawawi> moritz_: will do it right now

[19:39] <azawawi> moritz_: should i put it in ETOOMUCHTIME or STD_syntax_highlight?

[19:39] <moritz_> in ETOOMUCHTIME

[19:40] <azawawi> and all system() follow the nice 19 afterwards?

[19:40] <moritz_> yes

[19:41] <moritz_> all sub processes inherit the parent's nice value

[19:45] <pugs_svn> r22777 | azawawi++ | [STD_syntax_highlight] ETOOMUCHTIME says "let us play 'nice' with others"

[19:45] <moritz_> nice commit message ;)

[19:45] <azawawi> moritz_++

[19:45] <azawawi> i was aware that you renice things from Perl... that's way too cool.

[19:46] *** justatheory joined
[19:55] *** justatheory left
[19:59] *** [particle] joined
[20:03] *** slavik joined
[20:06] *** [particle] left
[20:10] *** [particle] joined
[20:15] *** pedrob joined
[20:20] *** Ringo47 joined
[20:20] *** Ringo47 left
[20:26] *** bjorn` is now known as MrElendig

[20:26] *** MrElendig is now known as Guest73769

[20:29] *** Guest73769 is now known as bjorn`

[20:35] <azawawi> moritz_: ping

[20:35] <moritz_> azawawi: pong

[20:35] <azawawi> moritz_: check out this updated version: http://feather.perl6.nl/~azawawi/syn/S02.html

[20:35] <lambdabot> Title: S02

[20:36] <azawawi> moritz_: s/^c/please c/ ;-)

[20:37] <moritz_> http://feather.perl6.nl/~azawawi/html/S02-whitespace_and_comments/unspace.t.simple.html doesn't show any colors

[20:37] <lambdabot> Title: ../../t/spec/S02-whitespace_and_comments/unspace.t, http://tinyurl.com/692fcy

[20:37] <moritz_> wrong CSS URL?

[20:37] <azawawi> oh

[20:37] <azawawi> stupid caching proxy on my side

[20:38] <azawawi> try it now... i hate ISP proxies

[20:38] <moritz_> why do the "simple" and "full" option use different colors?

[20:38] <azawawi> really?

[20:39] <moritz_> simple uses bold green for comments, full uses blue

[20:39] <azawawi> oh ;-)

[20:40] * azawawi forgot to add simple comment support to full ;-)

[20:40] <azawawi> so simple > full ;-)

[20:41] <azawawi> i will refactor it once things into one sub once i iron out all the small bugs here & there

[20:42] <azawawi> i just dont understand why ISP likes to cache things... it is really stupid...

[20:43] <azawawi> i guess small version can be loaded through an iframe

[20:44] <moritz_> are you sure it's the ISP that does the caching, and not your browser?

[20:44] <azawawi> but they should be on the same domain... although i didnt test that

[20:44] <azawawi> im 100% sure ;-)

[20:44] <moritz_> when I suspect caching issues I always use wget to circumvent browser cache

[20:44] <azawawi> i use CTRL-R- CTRL-F5 different browsers all the time

[20:45] <moritz_> ah, but firefox caches redirects even if you say Ctrl+r :(

[20:45] <azawawi> chrome then ff3 for firebug

[20:45] <azawawi> chrome caches things the first time you CTRL-R and then the next time it wakes up ;-)

[20:46] <azawawi> perlcabal.org = feather.perl6.nl... hmmm cool

[20:46] <azawawi> iframe will work then

[20:47] <slavik> I finally got grammars to semi-work, but it seems that any tokens/regex/rules that I define in a grammar become global ... what is the syntax to match a string against a grammer? (I use pugs, but have rakudo installed)

[20:47] <moritz_> rakudo has much better grammar support IMHO

[20:48] <slavik> I see

[20:48] <moritz_> currently $string ~~ MyGrammar causes MyGrammar::TOP to match

[20:48] <slavik> moritz_: ty

[20:48] <slavik> going to try it

[20:48] <moritz_> that will change, though (it's going to be a type check, but we haven't settled on a new syntax yet)

[20:49] <slavik> what does TOP have to be? a rule or a token?

[20:50] <slavik> I also found that one of the keywords parses spaces between the braces and the actual regex

[20:50] <slavik> slavik@slavik-desktop:~/code/perl6$ perl6 grammar.pl

[20:50] <slavik> too few arguments passed (1) - 2 params expected

[20:51] <slavik> This is Rakudo Perl 6, revision 31356 built on parrot 0.7.1-devel

[20:51] <slavik> weird ...

[20:51] <moritz_> slavik: rule or token or regex

[20:51] <moritz_> toke = regex :ratchet

[20:52] <moritz_> rule = regex :ratchet :sigspace

[20:52] <moritz_> rakudo: grammar Foo { token TOP { ^ ab }; }; if "abc" ~~ Foo { say $/ }

[20:52] <p6eval> rakudo 31963: RESULT[0]

[20:52] <moritz_> ouch.

[20:53] <moritz_> rakudo: grammar Foo { token TOP { ^ ab }; }; if "abc" ~~ &Foo::TOP { say $/ }

[20:53] <p6eval> rakudo 31963: OUTPUT[ab␤]

[20:53] <moritz_> that's not nice, but it seems to work :/

[20:53] <slavik> hmm

[20:53] <moritz_> rakudo's idea is that a regex is a code object, which isn't entirely wrong...

[20:55] *** abra left
[20:55] *** abra joined
[20:56] <slavik> hmm, any idea how I would get pugs to match against a grammar?

[20:56] <slavik> also, how would I force a token to match more than once in a string?

[20:58] <slavik> like if a string is "123 456" and I want a token nums { \d+ } to return "123" and "456"

[20:58] <moritz_> [<nums> \s+]+

[20:58] <moritz_> or use a rule in the first place...

[20:58] <slavik> that would go where?

[20:59] <slavik> s/token/rule/ ?

[20:59] <moritz_> rakudo: rule nums { \d+ }; if "123 456" ~~ m/<nums>+/ { say $/[1] }

[20:59] <p6eval> rakudo 31963: OUTPUT[Use of uninitialized value␤␤]

[20:59] <moritz_> rakudo: rule nums { \d+ }; if "123 456" ~~ m/<nums>+/ { say $<nums>[0] }

[20:59] <p6eval> rakudo 31963: OUTPUT[123 ␤]

[20:59] <moritz_> rakudo: rule nums { \d+ }; if "123 456" ~~ m/<nums>+/ { say $<nums>[1] }

[20:59] <p6eval> rakudo 31963: OUTPUT[456␤]

[21:00] <moritz_> rakudo: token nums { \d+ }; if "123 456" ~~ m/[<nums> \s+]+/ { say $<nums>[1] }

[21:00] <p6eval> rakudo 31963: OUTPUT[456␤]

[21:00] <moritz_> there's more than one way to do it ;)

[21:02] <slavik> hmm, pugs doesn't want to cooperate :(

[21:03] <slavik> moritz_: does rakudo do bignum when needed?

[21:04] <moritz_> rakudo: say 2**65

[21:04] <p6eval> rakudo 31963: OUTPUT[3.68934881474191e+19␤]

[21:04] <slavik> is there a pugs bot here?

[21:04] <moritz_> sure.

[21:04] <moritz_> pugs: say 2**65

[21:04] <p6eval> pugs: OUTPUT[36893488147419103232␤]

[21:05] <slavik> ahh, nice

[21:08] <slavik> moritz_: how would I get rakudo to print the whole number the way pugs does it?

[21:09] <slavik> moritz_: any predictions on when a RC perl6 interpreter might be available?

[21:09] <moritz_> slavik: whole number... dunno, you could try printf

[21:10] <moritz_> slavik: RC... perhaps in year. Or one and a half. Dunno

[21:10] *** charsbar left
[21:10] <slavik> ty

[21:11] <slavik> moritz_: at this point, would you recommend rakudo or pugs for playing around?

[21:12] <moritz_> slavik: I mostly play with rakudo because it's actively developed

[21:13] * slavik likes the idea of Perl6 + Haskell ...

[21:13] <slavik> Although I am sure there will be a Haskell on Parrot version ...

[21:13] <moritz_> well, audreyt has announced that she'll continue pugs development once ghc 6.10.1 is out

[21:14] <slavik> I see

[21:16] <slavik> moritz_: another question ... has the parallelization for "for all" loops been tried yet?

[21:17] <moritz_> slavik: pugs had parallelized hyper ops at some point

[21:23] *** masak` joined
[21:23] *** masak left
[21:24] *** masak` is now known as masak

[21:25] <pmurias> slavik: parrot doesn't seems to be a good target for haskell

[21:25] <slavik> :(

[21:26] <slavik> pmurias: I have to ask ... why?

[21:26] <pmurias> it has a very sophisticated runtime of it's own

[21:26] <slavik> I see

[21:27] <pmurias> and it compiles to machine code so compiling to parrot bytecode would be pointless

[21:28] *** explorer joined
[21:28] <moritz_> unless you want interaction with other languages that parrot might provide one day

[21:29] <pmurias> well you could use the FFI

[21:29] <pmurias> it actually a NCI in parrot

[21:29] <pasteling> "slavik" at 67.100.227.140 pasted "Statement not terminated properly at line 7, near "token nums"" (11 lines, 178B) at http://sial.org/pbot/32880

[21:30] <slavik> what am I doing wrong there?

[21:31] <moritz_> in rakudo you need a ; after each token/regex :(

[21:31] <moritz_> one of these small annoying details

[21:31] <slavik> ahh

[21:31] <slavik> that's fine

[21:31] <pugs_svn> r22778 | azawawi++ | [smartlinks] Added simple and full version hyperlinks.

[21:31] <pugs_svn> r22778 | azawawi++ | [smartlinks] If the simple version is clicked, an iframe loads the 

[21:31] <pugs_svn> r22778 | azawawi++ | [smartlinks] highlighted p6 test file within the same page.

[21:31] <pugs_svn> r22778 | azawawi++ | [smartlinks] If the full version is clicked, a new browser tab is opened 

[21:31] <pugs_svn> r22778 | azawawi++ | [smartlinks] containing the highlighted p6 code with the full parse tree viewer.

[21:31] <moritz_> oh, and never name a regex "text", rakudo doesn't like it

[21:31] <masak> slavik: you must separate rule definitions with semicolons at present

[21:31] <masak> there's an rt ticket about that

[21:32] <slavik> ok

[21:32] <slavik> no problem

[21:32] <masak> in fact, don't name it anything that's already used by the PGE internals...

[21:32] <slavik> so, perl6 is like C++ now? :P

[21:32] *** abra left
[21:32] <masak> slavik: no, much more fun :)

[21:33] <slavik> hmm, seems like rakudo is crashing ...

[21:33] <slavik> Multiple Dispatch: No suitable candidate found for 'concatenate', with signature 'PPP->P'

[21:33] <slavik> same code as in the paste, but with the ; added after token defs

[21:33] * masak tries

[21:34] <slavik> I have rakudo based on parrot 0.8

[21:34] *** jhorwitz left
[21:34] <masak> it's the last line.

[21:34] <slavik> ?

[21:34] <masak> it segfaults here, too

[21:34] <masak> slavik: comment out the last line, and the problem goes away

[21:35] <masak> I think /<nums>/ is illegal

[21:35] <masak> it doesn't refer to the URL grammar in any way

[21:35] <slavik> I see

[21:35] <masak> you probably meant URL::nums

[21:35] <slavik> yes

[21:35] <slavik> that is what works in pugs though ...

[21:35] <slavik> heh

[21:36] <azawawi> moritz_: inlined highlighted p6 code http://feather.perl6.nl/~azawawi/syn/S02.html ;-)

[21:36] <lambdabot> Title: S02

[21:36] <masak> slavik: you also don't need the parentheses

[21:36] <slavik> masak: habit from perl5 :P

[21:36] *** meppl joined
[21:36] <slavik> also, how come it doesn't match against URL, should I be doing URL::TOP?

[21:37] <slavik> doesn't URL imply URL::TOP?

[21:37] <masak> slavik: you don't need them in that place in Perl 5 either

[21:37] <masak> slavik: right now it does, yes

[21:37] * slavik did not know that

[21:37] <masak> slavik: perldoc perlsyn :)

[21:37] <slavik> it doesn't match URL, but does match URL::TOP ...

[21:38] <moritz_> azawawi: very nice... I just think that you shouldn't repeat the test name, it's one line of visual clutter

[21:38] <moritz_> (in the not-expanded view, that is)

[21:39] <slavik> ok, awesome, we're in business ... :D

[21:39] <moritz_> perhaps just one line with 'Highlighted: <a ...>small</a> | <a ...>full</a<

[21:39] <azawawi> hmmm cool

[21:40] * moritz_ wonders why the !#%@²" hell the non-ASCII won't work.

[21:41] <moritz_> last time I tried, it would even parse STD.pm on feather1

[21:41] <slavik> masak: if (condition); {} ... wtf?! there has to be a semi-colon after the condition???

[21:42] <moritz_> not at all

[21:42] <moritz_> slavik: but you need a whitespace after the 'if', otherwise it's a sub call

[21:42] <masak> slavik: no, where'd you get that from.

[21:42] <moritz_> rakudo: if (3 < 5) { say "yes" }

[21:42] <p6eval> rakudo 31963: OUTPUT[yes␤]

[21:42] <moritz_> rakudo: if(3 < 5) { say "yes" } # that should fail

[21:42] <p6eval> rakudo 31963: OUTPUT[yes␤]

[21:43] <masak> moritz_: another bug report :)

[21:43] * masak reports

[21:43] <moritz_> masak: I just wanted to suggest just that ;)

[21:43] <masak> :)

[21:43] *** bacek_ left
[21:43] <moritz_> std: if(3 < 5) { say "yes" } # that should fail

[21:43] <pasteling> "slavik" at 67.100.227.140 pasted "Statement not terminated properly at line 11, near "{\n\tsay \"Fu"" (15 lines, 258B) at http://sial.org/pbot/32881

[21:43] <p6eval> std 22778: OUTPUT[parse failure␤]

[21:44] <slavik> put a semi-colon after the condition and it works as expected ...

[21:45] <moritz_> slavik: but a ; after the grammar { ... } and it works.

[21:45] <slavik> ahh

[21:47] *** ruoso joined
[21:47] <slavik> moritz_: that's only for the time being, afaik there shouldn't be a need for ; after {} ... am I correct?

[21:48] <masak> slavik: yes.

[21:48] *** iblechbot left
[21:48] <masak> as long as there's a line break after the '}'

[21:48] <moritz_> right, every }\n implies a ; (except where inapproprate)

[21:48] <pmurias> ruoso: rehi

[21:48] <slavik> hmm, but I have }\n ...

[21:48] <ruoso> pmurias, hi

[21:48] <moritz_> I was talking about Perl 6, not about rakudo ;)

[21:49] <slavik> :(

[21:49] <masak> slavik: it's a bug in Rakudo.

[21:49] <ruoso> pmurias, my intent is to make the compiler use the MOP too

[21:49] <slavik> masak: unfinished parser?

[21:49] <masak> it, too, has been reported already

[21:49] <masak> slavik: certainly.

[21:49] <masak> unfinished most things.

[21:49] <pmurias> ruoso: of course the compiler should use the MOP

[21:49] <masak> slavik: not Christmas yet.

[21:50] <pugs_svn> r22779 | azawawi++ | [smartlinks] format is now "Highlighted: <a>small</a>|<a>full</a>"

[21:50] <moritz_> but it's going to be November soon ;)

[21:50] <masak> indeed.

[21:50] <azawawi> moritz_: done... it looks cool. thx

[21:50] <slavik> masak: it's cool :) it's still lots of fun playing with things that are broken ^^

[21:51] <pmurias> ruoso: but i don't think the grammar rule names should be used as method names what if TimToady changes them?

[21:51] <slavik> feels like I am living on the bleeding edge ...

[21:51] <masak> slavik: tell me about it :)

[21:51] <ruoso> pmurias, well STD needs to stabilize someda

[21:51] <ruoso> *someday

[21:51] <slavik> although pugs is faster :(

[21:52] *** pbuetow left
[21:52] <slavik> and rakudo has a broken bignum :(

[21:52] <ruoso> pmurias, and I think TimToady means the multi-token as the way to extend the language

[21:52] <ruoso> so the names themselves are very much important

[21:52] <masak> slavik: aye.

[21:52] <azawawi> pmurias: coming soon... --simple and --full modes in synopsis ;-) im waiting for the cron job to pick up the changes...

[21:53] <masak> slavik: anything in particular you want to do with bignums?

[21:53] <slavik> rakudo: my $factorial =1; for 2..22 { $factorial *= $_; } say $factorial;

[21:53] <p6eval> rakudo 31963: OUTPUT[Statement not terminated properly at line 1, near "say $facto"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[21:53] <slavik> rakudo: my $factorial =1; for 2..22 { $factorial *= $_; }; say $factorial;

[21:53] <p6eval> rakudo 31963: OUTPUT[86461594444431360000␤]

[21:53] <slavik> err

[21:53] <masak> seems to work fine.

[21:53] <azawawi> @tell lambdabot Hi5 ;-)

[21:53] <lambdabot> Nice try ;)

[21:53] <slavik> that's a wrong answer ...

[21:54] <slavik> rakudo: my $factorial =1; for 2..10 { $factorial *= $_; }; say $factorial;

[21:54] <p6eval> rakudo 31963: OUTPUT[3628800␤]

[21:54] <slavik> ok, that's correct

[21:54] <moritz_> rakudo: my $factorial =1; for 2..30 { $factorial *= $_; }; say $factorial

[21:54] <slavik> pugs: my $factorial =1; for 2..22 { $factorial *= $_; }; say $factorial;

[21:54] <p6eval> rakudo 31963: OUTPUT[20404066139399312202792960000000␤]

[21:54] <p6eval> pugs: OUTPUT[1124000727777607680000␤]

[21:54] <pmurias> azawawi: i watched spiderman 2 

[21:54] <pmurias> too 

[21:54] <moritz_> it seems that only infix:<**> promotes to num

[21:54] <slavik> compare pugs and rakudo outputs ...

[21:55] <masak> slavik: that wrong answer is possibly something you should report to rakudobug

[21:55] <slavik> where is that?

[21:55] <masak> rakudobug?

[21:55] <pmurias> azawawi: no, it was actuall spider man 3 ;)

[21:55] <slavik> yes

[21:55] * azawawi is watching "Pirates of the caribbean: curse of the black pearl" now ;-)

[21:55] <masak> oops, wrong channel

[21:55] <moritz_> [email@hidden.address] 

[21:55] <slavik> ahh, ok

[21:56] <masak> moritz_++ is faster on the trigger :)

[21:56] <moritz_> perl6: my $f = 1; $f *= $_ for 2..25; say $f;

[21:56] <p6eval> rakudo 31963: OUTPUT[1193170003333152768000000␤]

[21:56] <p6eval> ..elf 22779: OUTPUT[Unknown rule: infix_postfix_meta_operator:=␤It needs to be added to ast_handlers.␤ at ./elf_f line 1918␤]

[21:56] <p6eval> ..pugs: OUTPUT[15511210043330985984000000␤]

[21:57] <moritz_> perl 5 agrees with pugs.

[21:57] <masak> pugs has a much saner grip on numbers in general

[21:57] <masak> ...compared to rakudo

[21:58] <pmurias> azawawi: i watched that before

[21:58] <moritz_> masak: the only unusual thing with pugs maths is that it clings to fractions much longer than needed

[21:58] <pmurias> azawawi: no, actually it was the 3 part too ;)

[21:58] <moritz_> masak: and that it even takes decimal fractions as "real" fractions

[21:58] <ruoso> pmurias, I was actually about to ask TimToady to leave 'routine_declarator:method' in viv's output

[21:59] <azawawi> pmurias: lol

[22:00] *** masak left
[22:00] <pmurias> ruoso: yes the standard grammar should stabilise, but i think the method names should be seperated from the grammar

[22:01] <ruoso> why?

[22:01] <pmurias> as method names generally state name an action, and rule names are declarative

[22:01] *** ispy_ joined
[22:01] <ruoso> hm?

[22:01] <moritz_> pugs: say 2**65

[22:01] <p6eval> pugs: OUTPUT[36893488147419103232␤]

[22:01] <pmurias> has vs add_attribute

[22:01] *** smg left
[22:02] <pmurias> no, thats a different thing

[22:02] <ruoso> exactly...

[22:02] <ruoso> we have actually few "categories" of tokens

[22:02] <ruoso> that are extensible in STD

[22:03] <ruoso> I think to allow this same extensibility from STD in the runtime itself, we need to pass through this categories to the metaclass

[22:03] <pmurias> is something like marco routine_declarator:foo {...} legal?

[22:03] <ruoso> yes

[22:03] <ruoso> so as defining this token....

[22:04] <azawawi> moritz_: agentzh seems to have docs/feather/script/update-syn on an hourly cron... it is up2date now ;-)

[22:05] <pmurias> ruoso: if someone wrote a non-STD base grammar for p6 wouldn't it be a bit silly to map MOP calls to STD names

[22:05] *** [particle] left
[22:06] <ruoso> pmurias, hm? how do you mean?

[22:06] * azawawi announces the new STD syntax-highlighted synopsis: http://perlcabal.org/syn/S02.html... Click "small" or "Full"

[22:06] <slavik> seems like rakudo's variable interpretation is off, too ... "$/<blah>" will output $/ ~ "blah" ...

[22:06] <ruoso> pmurias, my point is for people that want to extend STD, not use a different base

[22:07] <pmurias> but is specifing that routine_declarator:method maps to add_method hard?

[22:07] <moritz_> rakudo: token foo { 'bar' }; 'bar' ~~ m/<foo>/; say $/<foo>;

[22:07] <p6eval> rakudo 31963: OUTPUT[bar␤]

[22:07] <moritz_> slavik: looks fine for me

[22:08] <ruoso> pmurias, that will require the compiler to know every possible keyword for routine_declarator

[22:08] <ruoso> my point is that it only needs to know that it need to add something...

[22:09] <ruoso> something of the routine_declarator "category"

[22:09] <slavik> rakudo: token foo { 'bar' }; 'bar' ~~ m/<foo>/; say "blah: $/<foo>";

[22:09] <p6eval> rakudo 31963: OUTPUT[blah: bar<foo>␤]

[22:09] <slavik> that

[22:09] <pmurias> when you add a new keyword you specifiy what metaclass method it maps to

[22:09] <pmurias> * specify

[22:10] <ruoso> pmurias, that is only needed for the package_declarator 'category'

[22:10] <ruoso> everything else can follow an uniform api

[22:11] <pmurias> token routine_declarator:thingy    { <sym> {make quasi {$?CLASS.add_thingy} }}

[22:12] <ruoso> pmurias, but that is not how STD works... I wanted to make it uniform, being in STD, or being an extension

[22:14] <pmurias> i'm not really aware how STD will work as it currently doesn't allow mapping the matched text to what it compiles too

[22:14] <ruoso> hm? what do you mean?

[22:14] <pmurias> but i understand that when you add something to the grammar you will have to specify what it will compile to

[22:15] <pmurias> ruoso: if you add something a new token to a category it has no meaning

[22:15] <ruoso> right... that's the point... I want to delay that meaning to the metaclass

[22:16] <pmurias> so there must be a way to specify what it is equivalent too

[22:16] <ruoso> I mean that the compiler should not be aware of that meaning

[22:16] <ruoso> and delegate that to the metaclass

[22:16] <pmurias> the metaclass should not be aware of the parser

[22:17] <ruoso> but it can be aware of the AST

[22:17] <ruoso> maybe

[22:17] <ruoso> or some higher-level representation...

[22:17] <pugs_svn> r22780 | moritz++ | [t/spec] added two bigint tests, slavik++

[22:17] *** bsb joined
[22:17] <slavik> ^^

[22:17] <ruoso> or maybe even the method signature in the metaclass would be bound to the AST somehow

[22:17] <slavik> do I get a brownie point?

[22:18] <pmurias> it's not very clear what the AST is

[22:18] <moritz_> perlbot: karma slavik

[22:18] <perlbot> Karma for slavik: 1

[22:18] <slavik> awesome

[22:18] <ruoso> pmurias, not yet... it will need to become clear sometime

[22:19] * slavik has trouble building pugs from svn ...

[22:19] <ruoso> pmurias, and stabilize just as STD needs to

[22:19] <slavik> I have to use cabal ...

[22:19] <moritz_> slavik: the cabal route worked fine for me, and I've even got success reports from win Xp

[22:20] <slavik> well, the only problem I have with cabal is that it doesn't have the latest svn of pugs

[22:20] <pmurias> ruoso: it might but it might also have multiple represantations which can translate to each other on demand

[22:20] <moritz_> slavik: does 'perl Makefile.PL; make' not work for you?

[22:21] <ruoso> pmurias, which means that binding to a signature is not very far from real

[22:21] <slavik> moritz_: going to try again ... but it was something related to ghc on my system

[22:21] <pmurias> ruoso: ?

[22:22] <ruoso> pmurias, thinking on the Catalyst::Controller example... let's suppose we want to support the following syntax:

[22:22] <slavik> moritz_: I would get an error about something Boolean and it told me to "report this bug" or something of the sort

[22:23] <ruoso> controller Foo { action bar does Authentication('realm') does Authorization('role') ($foo){ ... } }

[22:23] <ruoso> then the metaclass for the controller could have the method

[22:23] *** bennymac1 left
[22:24] <moritz_> slavik: what's your svn revision?

[22:24] <ruoso> pmurias, it would then have a method in the metaclass that would look something like: register_routine_declarator:action ($:trait, $:signature, $:block) {}

[22:24] <moritz_> azawawi: all the 'small' links in S29 are 404s for me... are they just not yet generated, or borked paths?

[22:24] <slavik> moritz_: I am updating it now

[22:25] <pmurias> ruoso: how would the grammar modifing part look?

[22:25] <slavik> moritz_: I wasn't too concerned with getting svn pugs to build after I found that cabal worked fine and I could mess around with perl6

[22:25] <moritz_> slavik: and is your repo URL http://svn.pugscode.org/pugs ? if not, you are on an old mirror

[22:25] <lambdabot> Title: pugs - Revision 22780: /

[22:25] <ruoso> pmurias, it can be identical to routine_declarator:method

[22:26] <slavik> hmm

[22:26] <ruoso> with just the "method" part being different

[22:26] <ruoso> pmurias, because that syntax is already supported by method

[22:26] <ruoso> std: class Foo { method bar ($:trait, $:signature, $:block)  does Authentication('realm') does Authorization('role') {...} }

[22:26] <p6eval> std 22780: OUTPUT[parsed␤]

[22:27] <ruoso> pmurias, my previous example had the traits in the wrong place

[22:27] <slavik> Updated to revision 22780.

[22:27] <slavik> :)

[22:27] <ruoso> it just changes the keyword... and thus changing the meaning of the traits

[22:28] <ruoso> and the meaning of the signature also

[22:28] <pmurias> ruoso: i understand what you are aiming for but i would rather directly specify that routine_declarator:action maps to add_action

[22:28] <ruoso> pmurias, in the compiler?

[22:29] <azawawi> moritz_: still generating... i think we should postpone the generation of big files like rx.t to the last of work queue

[22:29] <pmurias> ruoso: in the grammar

[22:30] <ruoso> pmurias, the problem with that is not being uniform in how this things work

[22:30] * moritz_ has the feeling that S29 takes endlessly to display

[22:30] <slavik> make[1]: *** No rule to make target `/usr/lib/perl/5.8/Config.pm', needed by `Makefile'.  Stop.

[22:30] <slavik> my system uses 5.10

[22:31] <ruoso> pmurias, I want to take the extensibility STD opens to the compiler itself

[22:31] <ruoso> delaying the semantics of that to the metaclasses

[22:31] <ruoso> for every declarator

[22:31] <ruoso> including the ones defined by STD

[22:31] <moritz_> slavik: did you do a 'make realclean'

[22:31] <slavik> no, will do it now

[22:32] <slavik> no such target ... maybe I should refetch it?

[22:32] <pmurias> ruoso: you are aware that it's possible to replace the grammar for perl6

[22:32] <slavik> wait, wrong dir ...

[22:32] <azawawi> moritz_: btw, chrome's webkit engine shows what html elements get ignored by the parser (via the inspector)...

[22:32] <ruoso> pmurias, yes, I am... but I'd like to make it less needed...

[22:33] <ruoso> pmurias, for instance... just declaring a token that is identical to one already existing

[22:33] <ruoso> pmurias, but with a different keyword

[22:33] <ruoso> pmurias, then I could register in the compiler that the metaclass Foo takes care of the package_declarator foo

[22:34] <pmurias> ruoso: i think we should ask TimToady what he thinks of it

[22:34] <ruoso> last time he said "I don't really care" :P

[22:35] <pmurias> but i think the degree with which we entangle the metamodel and the grammar is important

[22:35] <pmurias> i belive that they should be completly seperated but i understand your aproach

[22:36] <ruoso> I just want to make sure it's very easy to create things like this Catalyst::Controller example

[22:38] *** meppl left
[22:38] <pmurias> class Controller is keyword("controller") { method add_action is declarator("action") {...} }

[22:38] <pmurias> if you're doing something fancy use a module ;)

[22:39] <ruoso> well.. I'm not really sure how the above code would fit... but I suppose there could be a module that would help doing extensions...

[22:39] <ruoso> but my point is that we can make the compiler aware of that extensibility

[22:39] <pmurias> use Metaclass;

[22:39] <ruoso> and it will be much easier to do things like that then

[22:40] <pmurias> ruoso: when you add something to a grammar you can make the compile aware what it should compile to with make

[22:40] <pmurias> STD is compiler agnostic so it doesn't have such rules

[22:40] <ruoso> my point is that it the extensions can also be compiler agnostic

[22:41] <pmurias> what you really want by your proposal is for them to be builtin

[22:42] <ruoso> for them to be able to "pretend" to be built-in

[22:42] *** slavik left
[22:42] <ruoso> tes

[22:42] <ruoso> yes

[22:42] <ruoso> that's the point... allowing extensions to work just like the built-ins do

[22:43] <pmurias> s/allowing/forcing

[22:43] <pmurias> or at least encouragin

[22:43] <ruoso> hmmm... I really see "working as a built-in" as an advantage

[22:43] <ruoso> and something to be pursued...

[22:44] <pmurias> generally yes

[22:44] <ruoso> and I understand that is the intention in the way STD is designed

[22:44] <ruoso> I just want to take this vision to the compiler also

[22:44] <pmurias> but it also frees you to change stuff to whatever you want

[22:45] <pmurias> what i want to prevent is the grammar creeping into other parts of the compiler

[22:45] <ruoso> I'm not talking about defining a new language...

[22:45] <ruoso> it's just a new keyword in a given specific multi-token

[22:45] <ruoso> which STD already was designed to support extensibility

[22:46] <ruoso> I'm accepting the structure of STD

[22:46] <ruoso> and the compiler would work on top of that structure

[22:47] <pmurias> the MOP in this case

[22:47] <ruoso> the MOP is already tied to that in a way

[22:47] <ruoso> because add_method will need to receive everything that is in the method_def token

[22:48] <ruoso> and it won't expect to receive things that are not there..

[22:48] <ruoso> I just want to make that tie explicit, and extensible

[22:48] <pmurias> add method will receive the method name and a method

[22:49] <pmurias> ruoso: don't make add_method receive a Match, please

[22:50] <ruoso> hmmm.... ok... I wasn't realizing the compiler was already instantiating the Method object before...

[22:50] <ruoso> fine... that means we need two hooks instead of one

[22:51] <ruoso> I still argue to make the MOP API oriented to the way STD define the multi-tokens

[22:51] <ruoso> but it can receive an object that was initialized by the compiler

[22:52] <ruoso> and that way the compiler needs to support hooks that will receive Match (or AST) and return a new object

[22:52] <pmurias> but does Foo.HOW.register_routine_declarator:method('foo',sub {say "foo"}) seems sensible to you

[22:52] <pmurias> ruoso: the grammar can have such hooks

[22:52] <pmurias> s/seems/see

[22:52] <pmurias> m

[22:53] <ruoso> not really... if we go that way... we need to have... Foo.HOW.register_routine_declarator:method($fully_initialized_method_object)

[22:53] <ruoso> and Method has $.name

[22:54] <ruoso> pmurias, the grammar already has the hooks... it's just the compiler that needs to support new variants for each of the multi-tokens

[22:54] <pmurias> that's just plainly ugly

[22:55] <pmurias> register_routine_declarator:method is not an acceptable method name

[22:55] <pmurias> with a stange parameter too

[22:55] <ruoso> well, we can work out a better name

[22:56] <ruoso> but I do think it needs to be related to the STD multi-tokens

[22:56] <ruoso> so that the compiler can call the method without knowing what it means

[22:57] <pmurias> why?

[22:57] <pmurias> the grammar specifies what a given bit of text is

[22:57] <ruoso> because new keywords would not require a change in the compiler

[22:57] <pmurias> they do, the grammar is a part of the compiler

[22:58] <pmurias> it can even be viewed as the compiler itself

[22:58] <ruoso> well... compilers are usually splitted in two parts

[22:58] <ruoso> the parsing and the emitting

[22:59] <ruoso> my point is that if the "emitting" part supports the multi-tokens, it won't need to change when the "parsing" part changes

[23:01] <pmurias> but you can't have a good method name with routine_declarator:method in it

[23:02] <ruoso> we can have it just as "add_routine_declarator", and receive ($keyword, $object) as arguments...

[23:02] <ruoso> anyway... 

[23:02] * ruoso later &

[23:02] <pmurias> it's even worse

[23:02] <ruoso> let's mature this more...

[23:03] <pmurias> ruoso: you mean talk about it later? ;)

[23:09] *** elmex left
[23:10] *** explorer left
[23:20] *** pmurias left
[23:24] *** sri_kraih_ joined
[23:31] *** smg joined
[23:32] *** sri_kraih left
[23:41] *** zamolxes left
[23:43] *** pedrob left
[23:48] *** meppl joined
[23:50] *** ispy_ left
