[00:00] *** chris2 left
[00:04] <Auzon> rakudo: class Foo does Bar {}

[00:04] <p6eval> rakudo r28205 No output (you need to produce output to STDOUT)

[00:14] *** bacek joined
[00:15] *** bsb joined
[00:19] *** [particle]1 joined
[00:26] *** silug left
[00:28] *** [particle] left
[00:29] *** cmarcelo left
[00:30] *** silug joined
[00:42] *** Eevee joined
[00:48] *** [particle]1 left
[00:55] *** japhb joined
[01:03] *** mncharity joined
[01:10] <Auzon> perl6: say 0 but Bool::True

[01:10] *** p6eval left
[01:10] <Auzon> boom. heh.

[01:10] *** p6eval joined
[01:15] <mncharity> more tests needed :)

[01:17] * Auzon wonders which one failed

[01:18] <Auzon> Parrot, it seems

[01:18] <pmichaud> rakudo:  say 0 but Bool::True   # probably parse error.

[01:18] <p6eval> rakudo r28205 No output (you need to produce output to STDOUT)

[01:18] <Auzon> pugs: say 0 but Bool::True

[01:18] <p6eval> OUTPUT[*** Cannot cast from VBool True to Pugs.AST.Internals.VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤]

[01:18] <Auzon> elf: say 0 but Bool::True

[01:18] *** p6eval left
[01:18] <pmichaud> :-)

[01:18] <Auzon> The question is why elf is blowing it up

[01:18] *** p6eval joined
[01:19] <mncharity>  * (defun ☺ () "SBCL rocks!")  * (☺)   #=> "SBCL rocks!"

[01:19] *** Limbic_Region left
[01:19] <mncharity> I just love SBCL.  It's great when unicode support is real.

[01:20] <mncharity> re elf, let's see...

[01:21] <Auzon> I'm curious why any eval can crash the bot

[01:21] <Auzon> Because it runs it in a system call

[01:21] <mncharity> elf: )

[01:21] <p6eval> OUTPUT[Parse error in: /tmp/LThPhNwuxD␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: )␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤  STD_red/std.rb:210:in `_UNIT'␤ 

[01:21] <p6eval> .../../STD_red/STD_red_run:108:in `main'␤  ./../STD_red/STD_red_...

[01:22] <Auzon> maybe it's something with BSD::Resource or some such

[01:22] <Auzon> evalbot control restart

[01:22] *** p6eval left
[01:22] <Auzon> elf: say 0 but Bool::True

[01:22] *** p6eval joined
[01:22] <mncharity> elf: $x

[01:22] <p6eval> OUTPUT[Global symbol "$x" requires explicit package name at (eval 14) line 3.␤ at ./elf_f_faster line 4492␤]

[01:22] <Auzon> elf: say 0 but Bool::True

[01:22] *** p6eval left
[01:22] <Auzon> hm, nope

[01:22] <mncharity> So it's not the exit() code.

[01:22] *** p6eval joined
[01:23] <Auzon> evalbot control restart # to be sure

[01:23] *** p6eval left
[01:23] *** p6eval joined
[01:23] <Auzon> oh

[01:23] <Auzon> I didn't edit that on the server, I edited it locally

[01:23] * Auzon is apparently braindead

[01:24] <mncharity> seems unlikely ;)

[01:24] <Auzon> I'll be back later when I have a better idea

[01:27] <mncharity> Any folks around who do CL?

[01:28] <mncharity> am sooo tempted to start a SBCL backend...

[01:29] *** Ched- joined
[01:30] <mncharity> which would raise the question of "kludge straight to bootstrap", or something more principled.

[01:30] <mncharity> or both :)

[01:32] *** cjfields joined
[01:33] <diakopter> mncharity: I'm interested to learn it.

[01:35] <diakopter> though I'm not sure that helps you much :)

[01:36] *** cjfields left
[01:37] *** cjfields joined
[01:37] *** xinming_ left
[01:38] <mncharity> tamarin would be nifty, but doesn't seem quite ready for primetime...  and might have to tweak JavaScript::SpiderMonkey to work iwth it... but js 1.7 or 1.8 could be fun, though not a speedup... :/

[01:39] <mncharity> ﻿diakopter: does :)  indicates presence of interest...

[01:40] <mncharity> doesn't seem plausible to attempt anything statically typed at this point...

[01:41] <mncharity> at least for bootstrap.  might perhaps compile down "lots of function calling", eg, parser, to Inline::C...

[01:44] <mncharity> Yay!  Someone has done a tcc module.  http://search.cpan.org/~hamano/C-TCC-0.03/lib/C/TCC.pm   :) !   Wait enough years, and thigns decay off your todo list. 

[01:44] <lambdabot> Title: C::TCC - An interface to the TCC(Tiny C Compiler) - search.cpan.org

[01:45] <mncharity> Aside from fast compile, is it lets you compile and link C code _without touching disk_.

[01:47] <mncharity> http://research.sun.com/projects/lively/  squeak's morphic in js :)

[01:47] <lambdabot> Title: Sun Labs Lively Kernel

[01:49] <mncharity> http://hotruby.accelart.jp/  anyone want to implement some p5 vm instructions in js?  :)

[01:49] <lambdabot> Title: HotRuby - Ruby on JavaScript & Flash

[01:58] <mncharity> ﻿Auzon: re "﻿So it's not the exit() code.", err, no.  I tested the wrong thing.  Forgot that evalbot wraps the code.  So I've no data.

[01:58] *** xinming joined
[01:58] *** SCalimlim left
[02:00] <diakopter> anyone here going to YAPC::NA this year?

[02:06] *** [particle] joined
[02:06] <pmichaud> <- going to yapc::na.

[02:13] *** drbean joined
[02:21] *** [particle]1 joined
[02:26] *** cjfields left
[02:30] *** [particle] left
[02:34] *** [particle]1 left
[02:35] *** cjfields joined
[02:35] *** cjfields left
[02:35] *** cjfields joined
[02:48] *** [particle] joined
[02:50] <pugs_svnbot> r20735 | putter++ | [elf] Permit non-perl5 backends.

[02:51] *** cjfields left
[02:53] *** cjfields joined
[02:57] <pugs_svnbot> r20736 | putter++ | [elfish/on_sbcl] Start of an SBCL elf backend.

[03:02] *** kanru joined
[03:11] <mncharity> perl6: :a<b c d>

[03:11] <p6eval> kp6 r20736: OUTPUT[syntax error at position 0, line 1 column 0:␤:a<b c d␤^ HERE␤]

[03:11] <p6eval> ..pugs: RESULT[("a" => ("b", "c", "d"))]

[03:11] <p6eval> ..rakudo r28205: No output (you need to produce output to STDOUT)

[03:11] <p6eval> ..elf r20736: OUTPUT[Unquoted string "d" may clash with future reserved word at (eval 14) line 3.␤Can't locate object method "b" via package "c" (perhaps you forgot to load "c"?) at (eval 14) line 3.␤ at ./elf_f_faster line 4496␤]

[03:12] <mncharity> pugs: :a<<a b c>>

[03:12] <p6eval> RESULT[("a" => ("a", "b", "c"))]

[03:12] <mncharity> pugs: :a'a b c'

[03:12] <p6eval> OUTPUT[*** ␤    Unexpected "'"␤    expecting word character, dot, block construct, "(", "[", "<<", "<", "\171", term postfix or operator␤    at /tmp/OAJAhUpBv9 line 1, column 3␤]

[03:12] <mncharity> pugs: :a<'a b c'>

[03:12] <p6eval> RESULT[("a" => ("\'a", "b", "c\'"))]

[03:18] <spinclad> mncharity: have done maclisp, T, and scheme, and paid some attention to CL beginnings; it's at least not a foreign tongue.  (way behind on reading LtUltimate.)

[03:19] <spinclad> svn up...

[03:23] <rakudo_svn> r28221 | pmichaud++ | [rakudo]:

[03:23] <rakudo_svn> r28221 | pmichaud++ | * Add 'return'.  Only works for single-element values at the moment --

[03:23] <rakudo_svn> r28221 | pmichaud++ |   returning lists and named elements will be available shortly.

[03:23] <rakudo_svn> r28221 | pmichaud++ |   

[03:28] *** cognominal_ left
[03:34] *** eternaleye joined
[03:36] <diakopter> erm

[03:44] <TimToady> svn bot seems down though...

[03:45] <pugs_svnbot> r20737 | lwall++ | [STD5] EXPR finally unbroken again after refactorot

[03:45] <TimToady> er, nevermind...

[03:51] <diakopter> TimToady: so apparently I need to memoize coderefs in order to convert this rd parser from geometric time to linear time...

[03:51] <pugs_svnbot> r20738 | putter++ | [elfish/on_poly] Created.  A "bulk creation of backends" thought experiment.  A placeholder - little here yet.

[03:51] * diakopter foresees symbol table hackage

[03:52] <mncharity> ﻿spinclad: :)

[03:54] <pugs_svnbot> r20739 | cjfields++ | Set up trans.t for rakudo testing

[03:55] <mncharity> re 'svn up'... doesn't do much yet.  just hacked it to take  'sub f($x){say $x+3} f(4)' and print 7.  Mostly just getting the setup in place.

[03:58] *** alc joined
[04:03] <mncharity> ﻿spinclad: re scheme, on my todo list after 'full bootstrap with STD_red translated into p6 and absorbed into elf, and elf running on at least two backends', is to start pushing on frontends.  First a js, but then a scheme.  Thinking of bigloo, just because it has a regexp-like reader design.

[04:04] <mncharity> but if someone was interested in pursuing it, we could start sooner, even now.

[04:06] <mncharity> re T, shudder.  Worked on overhauling the T manual years ago.  Became a "if the client asks for something insane, push back or leave" life lesson.

[04:12] <mncharity> re '﻿er, nevermind...', :)

[04:12] *** cjfields left
[04:13] <mncharity> end of day.  good night all &

[04:13] *** mncharity left
[04:14] *** alanhaggai joined
[04:15] <pugs_svnbot> r20740 | lwall++ | [STD] radix numbers should allow embedded underscores

[04:17] *** kst joined
[04:19] *** alanhaggai left
[04:24] <spinclad> re T, an interesting dialect in its day.  enjoyed looking around its innards; strange and different and interesting.

[04:25] <spinclad> its compiler reminded me a lot of GLS's Rabbit.

[04:34] *** rafl left
[04:34] *** rafl joined
[04:45] <spinclad> @message cjfields re r20739, did you check in a fudged version?  please just add #?rakudo comments...

[04:45] <lambdabot> Maybe you meant: messages messages?

[04:45] <spinclad> @tell cjfields re r20739, did you check in a fudged version?  please just add #?rakudo comments...

[04:45] <lambdabot> Consider it noted.

[05:04] *** nipotan is now known as nipotaway

[05:21] *** wknight8111 left
[05:29] *** eternaleye left
[05:30] *** cognominal_ joined
[05:38] *** meppl joined
[05:51] *** bacek_ joined
[05:52] *** nipotaway is now known as nipotan

[05:59] *** bnjmn-- joined
[06:08] *** bacek left
[06:21] *** alc left
[06:23] *** iblechbot joined
[06:24] *** Psyche^ joined
[06:35] *** Patterner left
[06:35] *** Psyche^ is now known as Patterner

[06:55] *** rindolf joined
[06:59] <diakopter> anyone around?

[06:59] <rindolf> Hi diakopter 

[06:59] <moritz_> diakopter: no ;)

[06:59] <pugs_svnbot> r20741 | diakopter++ | [yap6]

[06:59] <pugs_svnbot> r20741 | diakopter++ | - Added new non-terminal parser constructors:

[07:00] *** pugs_svnbot joined
[07:00] <diakopter> drat.  I just wanted to show off my last commit - http://dev.pugscode.org/changeset/20741

[07:01] <lambdabot> Title: Changeset 20741 - Pugs - Trac

[07:01] <diakopter> again, commit msg too long :[[[

[07:01] <moritz_> uhm, maybe pugs_svnbot stops at empty lines

[07:01] <diakopter> there wasn't an empty line

[07:02] <moritz_> or whitespace-only lines

[07:02] <diakopter> see http://perlcabal.org/svn/pugs/revision/?rev=20741

[07:02] <lambdabot> Title: revision: /pugs (Rev: 20741, via SVN::Web)

[07:02] *** iblechbot left
[07:02] <diakopter> there wasn't a whitespace-only line

[07:02] <moritz_> well, http://dev.pugscode.org/changeset/20741 shows empty lines

[07:02] <lambdabot> Title: Changeset 20741 - Pugs - Trac

[07:03] <diakopter> no it doesn't; it's blockquoting the indented areas

[07:04] <moritz_> ok

[07:04] <diakopter> anyway, the nthru operator overloads symbol "..."

[07:05] <diakopter> oh, and match() will take qr// patterns and match them against input

[07:06] <diakopter> which will offer very easy shortcut creation for helping one() rule out branches quickly

[07:06] <diakopter> where one() is the old alternate()

[07:06] *** justatheory left
[07:09] <diakopter> btw, I realized that backtracking recursive descent parsers like this one already do LTM, as long as you write your grammar correctly.  the branch that matches the entire input wins.  you just have to make all your recursive nonterminals right-recursive instead of left.  Though tonight I will think about how to write a parser constructor to help you with that.

[07:09] <pugs_svnbot> r20742 | lwall++ | [STD5] can now parse radix.t

[07:09] <moritz_> can parse radix.t - is that a good or a bad sign? ;-)

[07:09] <diakopter> also you have to specify as greedy things that should be greedy.

[07:09] <moritz_> (given the current shape of our test suite, that is ;)

[07:10] <diakopter> oh, and, the memoizing is essentially constructing a DFA as it goes...

[07:10] <TimToady> it's more than STD5 was ever able to parse before, so I think it's good

[07:10] <moritz_> diakopter: why are you non-greedy by default?

[07:10] <moritz_> ok TimToady++

[07:11] <diakopter> moritz_: b/c you can't be greedy by default...? I mean, what if a repeated pattern signifies the start of a new pattern

[07:11] <moritz_> diakopter: example?

[07:12] <diakopter> well, in writing the grammar you're specifying legal input as well as writing parsing instructions.

[07:13] <diakopter> so you don't want to allow repeated patterns where the language doesn't allow them.. like } at the end of a block - you don't want to have it accept an unbalanced extra }

[07:14] <diakopter> oh, sorry; I meant a different greedy

[07:14] <moritz_> in which case you wouldn't use a quantifier at all, which makes the distinction between "greedy" and "non-greedy" useless

[07:14] <moritz_> ah ok

[07:16] <diakopter> to restate, I meant to say that where a pattern can be recursive, the other things inside it should be as greedy as possible, to prevent non-LTM

[07:16] <diakopter> in other words, make sure the grammar covers all possible legal syntax :D

[07:17] <diakopter> in other words, write a correct grammar

[07:17] <diakopter> heh

[07:17] <moritz_> ;)

[07:18] <diakopter> bed->()

[07:19] <diakopter> er, couch->()

[07:41] *** cookys left
[07:42] *** Ched- left
[07:45] *** elmex joined
[07:50] *** jiing_ joined
[07:50] *** Jedai joined
[07:53] *** masak joined
[07:59] *** rindolf left
[08:04] *** IllvilJa left
[08:30] *** iblechbot joined
[08:32] *** IllvilJa joined
[08:39] *** cookys joined
[08:43] <moritz_> Auzon, pmichaud, [particle]: I won't be able to attend our meeting tomorrow, so I pre-typed my report: http://irclog.perlgeek.de/perl6-soc/2008-06-10#i_339985

[08:43] <lambdabot> Title: IRC log for #perl6-soc, 2008-06-10

[08:45] *** alanhaggai joined
[08:45] *** pmurias joined
[08:52] *** meppl left
[08:57] *** Jedai left
[08:57] *** Jedai joined
[09:04] *** bacek_ left
[09:18] *** jiing_ left
[09:25] *** chris2 joined
[09:40] *** Chillance joined
[09:44] *** alanhaggai left
[09:52] *** drbean left
[09:52] *** drbean joined
[09:52] *** Lorn_ left
[09:56] *** alanhaggai joined
[09:58] *** nipotan is now known as nipotaway

[09:59] *** IllvilJa left
[10:04] *** Jedai left
[10:08] *** [particle] left
[10:17] <masak> is it `say $a;` or `say $a:;`?

[10:18] <masak> ah, the former, probably, because 'say' is a sub

[10:18] *** alanhaggai_ joined
[10:20] <masak> could I call a private method with `self.mthd()`?

[10:20] * masak is re-reading S12

[10:20] <audreyt> no, you need to use self!

[10:20] <audreyt> S12:348

[10:21] <audreyt> er, I mean, `self!`.

[10:31] *** alanhaggai left
[10:38] *** bacek joined
[10:43] *** alanhaggai_ is now known as alanhaggai

[10:43] *** jan_ left
[10:44] *** jan_ joined
[10:45] *** jan__ joined
[10:52] *** jan_ left
[11:13] <bacek> rakudo: say 'hello'

[11:13] <p6eval> rakudo r28205 No output (you need to produce output to STDOUT)

[11:14] * bacek requesting make realclean for evalbot :)

[11:14] * moritz_ charges bacek 10 EUR for his request

[11:17] <moritz_> realclean is fast, it's the parrot rebuild that takes its time

[11:17] <pmichaud> good morning, all

[11:17] <moritz_> if most of it was used by gcc I'd consider iinstalling ccache on that machine, but it seems much of the time is used by perl scripts

[11:18] <moritz_> good localtime pmichaud ;)

[11:25] <bacek> good evening, pmichaud 

[11:26] *** Jedai joined
[11:26] * moritz_ is offline for a few days. TTFN, I expect christmas on my return ;)

[11:27] <bacek> moritz_, how is your yesterday exam? 6 month in jail for cheating?

[11:27] <pmichaud> I just gave a return a few hours ago :-)

[11:28] <bacek> pmichaud, yes, it's all your fault :)

[11:28] <moritz_> bacek: I got an A (when translated to english/american grades)

[11:29] <bacek> moritz_, do you use 1-5 and you've got 5?

[11:29] <pmurias> the use 5-1

[11:29] <moritz_> bacek: 1 to 6, and got 1

[11:29] <pmurias> * they use 6-1

[11:29] <moritz_> but 5 and 6 are both failed so it doesn't really matter

[11:30] <bacek> moritz_, :) Congratulations anyway 

[11:30] <moritz_> bacek: thanks

[11:30] * bacek got last exam about 10 year ago...

[11:32] *** alc joined
[11:39] *** IllvilJa joined
[11:40] <bacek> rakudo: my $pi = 3.141592653589793238; say cis(3*$pi / 2);

[11:40] <p6eval> rakudo r28225 OUTPUT[-1.83691e-16-1i␤]

[11:40] <bacek> rakudo: say 1i;

[11:40] <p6eval> rakudo r28225 OUTPUT[0+1i␤]

[11:42] <bacek> rakudo: my $pi = 3.141592653589793238; say abs(cis(3*$pi / 2) - 1i);

[11:42] <p6eval> rakudo r28225 OUTPUT[2␤]

[11:48] <bacek> rakudo: say 4.unpolar(0)

[11:48] <p6eval> rakudo r28225 OUTPUT[Method 'unpolar' not found for invocant of class 'Int'␤current instr.: '_block11' pc 38 (EVAL_12:19)␤

[11:55] *** chris2 left
[12:04] *** wknight8111 joined
[12:08] <bacek> rakudo: say 4.0.unpolar

[12:08] <p6eval> rakudo r28226 OUTPUT[too few arguments passed (1) - 2 params expected␤current instr.: 'parrot;Num;unpolar' pc 1313 (src/gen_builtins.pir:991)␤

[12:08] <bacek> rakudo: say 4.0.unpolar(0)

[12:08] <p6eval> rakudo r28226 OUTPUT[4+0i␤]

[12:13] <bacek> perl6: say unpolar(4.0, 0)

[12:13] <p6eval> kp6 r20742: OUTPUT[syntax error at position 11, line 1 column 11:␤say unpolar(4.0, 0␤           ^ HERE␤]

[12:13] <p6eval> ..pugs: OUTPUT[*** No such subroutine: "&unpolar"␤    at /tmp/CjfuV9yE3a line 1, column 5 - line 2, column 1␤]

[12:13] <p6eval> ..rakudo r28226: OUTPUT[4+0i␤]

[12:13] <p6eval> ..elf r20742: OUTPUT[Undefined subroutine &GLOBAL::unpolar called at (eval 14) line 3.␤ at ./elf_f_faster line 4496␤]

[12:13] <bacek> perl6: say unpolar(4, 0)

[12:14] <p6eval> kp6 r20742: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    

[12:14] <p6eval> ..pugs: OUTPUT[*** No such subroutine: "&unpolar"␤    at /tmp/ZFgUNOEYE4 line 1, column 5 - line 2, column 1␤]

[12:14] <p6eval> ..rakudo r28226: OUTPUT[4+0i␤]

[12:14] <p6eval> ..elf r20742: OUTPUT[Undefined subroutine &GLOBAL::unpolar called at (eval 14) line 3.␤ at ./elf_f_faster line 4496␤]

[12:17] *** Lorn_ joined
[12:25] <bacek> perl6: my $a = '2 is my favorite number'; say +$a.isa(Num)

[12:25] <p6eval> kp6 r20742: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    

[12:25] <p6eval> ..pugs: OUTPUT[0␤]

[12:25] <p6eval> ..rakudo r28226: OUTPUT[0␤]

[12:25] <p6eval> ..elf r20742: OUTPUT[1␤]

[12:26] <bacek> perl6: my $a = '2 is my favorite number'; say (+$a).isa(Num)

[12:26] <p6eval> kp6 r20742: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    

[12:26] <p6eval> ..pugs: OUTPUT[1␤]

[12:26] <p6eval> ..rakudo r28226: OUTPUT[1␤]

[12:26] <p6eval> ..elf r20742: OUTPUT[1␤]

[12:27] <bacek> perl6: my $a = 2; say (+$a).isa(Num)

[12:27] <p6eval> kp6 r20742: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    

[12:27] <p6eval> ..pugs: OUTPUT[1␤]

[12:27] <p6eval> ..rakudo r28226: OUTPUT[0␤]

[12:27] <p6eval> ..elf r20742: OUTPUT[1␤]

[12:29] *** cjfields joined
[12:34] <diakopter> pmichaud: have you read about the "packrat parser"?  sorry if this is a dumb question

[12:34] <pugs_svnbot> r20743 | diakopter++ | [yap6] found a way to memoize all the generated parsers

[12:34] <pugs_svnbot> r20743 | diakopter++ | yap6 is now packrat-ified.  so that means its degenerate

[12:34] <pugs_svnbot> r20743 | diakopter++ | grammar now enters infinite recursions in linear time :D

[12:34] <pugs_svnbot> r20743 | diakopter++ | seriously though, I still need to convert the left

[12:34] <pugs_svnbot> r20743 | diakopter++ | recursions in STD_hand to right recursions.

[12:35] *** Lorn_ left
[12:35] *** sri_work joined
[12:36] *** cjfields_ joined
[12:36] *** cjfields left
[12:36] <diakopter> commutativity &

[12:37] <bacek> perl6: say Byte.WHAT

[12:38] <p6eval> kp6 r20743: OUTPUT[DISPATCH: calling WHAT on invalid object:$VAR1 = undef;␤␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 128␤        main::DISPATCH('undef', 'WHAT') called at - line 11␤]

[12:38] <p6eval> ..pugs: OUTPUT[*** No such subroutine: "&Byte"␤    at /tmp/Xi7RmNlha5 line 1, column 5 - line 2, column 1␤]

[12:38] <p6eval> ..rakudo r28226: OUTPUT[Failure␤]

[12:38] <p6eval> ..elf r20743: OUTPUT[STRING␤]

[12:38] <bacek> perl6: say Byte.isa(Num)

[12:38] <p6eval> kp6 r20743: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    

[12:38] <p6eval> ..pugs: OUTPUT[*** No such subroutine: "&Byte"␤    at /tmp/dHXW19n9da line 1, column 5 - line 2, column 1␤]

[12:38] <p6eval> ..rakudo r28226: OUTPUT[0␤]

[12:38] <p6eval> ..elf r20743: OUTPUT[␤]

[12:39] <bacek> rakudo: my Byte $a; say $a.isa(Num)

[12:39] <p6eval> rakudo r28226 OUTPUT[0␤]

[12:53] *** xinming left
[12:54] *** xinming joined
[12:56] *** [particle] joined
[12:57] <pmichaud> diakopter: I read something about it a bit, but not in great detail.

[12:58] <bacek> perl6: say (1+1.0).WHAT

[12:58] <p6eval> kp6 r20743: OUTPUT[syntax error at position 4, line 1 column 4:␤say (1+1.0).WHA␤    ^ HERE␤]

[12:58] <p6eval> ..pugs: OUTPUT[Rat␤]

[12:58] <p6eval> ..rakudo r28226: OUTPUT[Num␤]

[12:58] <p6eval> ..elf r20743: OUTPUT[Int␤]

[12:59] <bacek> ouch...

[13:04] <bacek> pugs: say Int <: Num

[13:04] <p6eval> OUTPUT[*** ␤    Unexpected ": Num"␤    expecting "::"␤    at /tmp/2Tkl3la8vC line 1, column 10␤]

[13:10] *** iblechbot left
[13:20] *** donaldh joined
[13:23] *** cjfields_ left
[13:26] *** TJCRI joined
[13:35] *** cmarcelo joined
[13:41] <pugs_svnbot> r20744 | diakopter++ | [yap6] removed completed items from TODO

[13:41] <pugs_svnbot> r20744 | diakopter++ | added a comment to the Trace.pm source filter

[13:41] <pugs_svnbot> r20744 | diakopter++ | added another parameter to perl6.bat

[13:41] *** eternaleye joined
[13:44] *** osfameron left
[13:44] *** osfamero1 joined
[13:51] *** jhorwitz joined
[13:52] <diakopter> a few more things to be fully packrat-ified: get rid of the 3 remaining character classes; finish the match() parser generator to accept p5 REs so character classes are a lot easier; add an explicit normalizer function parameter to memoize() to ensure $input is keyed correctly in the memo tables.

[13:53] <diakopter> oh and, rip out the lexer component entirely so that it's a lot simpler.  also requires changes to the two terminals hit() and eoi()

[13:54] <diakopter> there's no need to use nested arrayref tuples when a single arrayref will do...

[14:01] *** Khisanth joined
[14:04] *** eternaleye left
[14:06] *** iblechbot joined
[14:09] *** cjfields joined
[14:10] *** [particle]1 joined
[14:18] *** Ashizawa joined
[14:20] <pugs_svnbot> r20745 | diakopter++ | [yap6] initial cut at the match() constructor

[14:27] *** [particle] left
[14:33] *** Ashizawa left
[14:43] *** cognominal_ left
[14:53] *** sscaffidi joined
[15:04] *** jhorwitz left
[15:04] *** Jedai left
[15:06] *** osfamero1 is now known as osfameron

[15:07] *** jhorwitz joined
[15:07] *** Jedai joined
[15:07] *** nothingmuch joined
[15:07] *** agentzh joined
[15:12] *** jan joined
[15:15] *** masak left
[15:17] *** stevan_ left
[15:24] *** elmex left
[15:27] *** rdice joined
[15:33] *** pbuetow joined
[15:45] *** Unix joined
[15:50] *** stevan_ joined
[15:53] <Auzon> rakudo: class Foo {my method !bar {say 42}; method tryit {self!bar}} Foo.new.tryit;

[15:53] <p6eval> rakudo r28227 OUTPUT[Statement not terminated properly at line 1, near "Foo.new.tr"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[15:53] <Auzon> rakudo: class Foo {my method !bar {say 42}; method tryit {self!bar}}; Foo.new.tryit;

[15:53] <p6eval> rakudo r28227 OUTPUT[Could not find non-existent sub bar␤current instr.: 'parrot;Foo;_block22' pc 85 (EVAL_11:43)␤

[15:53] <Auzon> rakudo: class Foo {my method bar {say 42}; method tryit {self!bar}}; Foo.new.tryit;

[15:53] <p6eval> rakudo r28227 OUTPUT[42␤]

[15:55] *** alanhaggai left
[16:04] *** alanhaggai joined
[16:07] *** justatheory joined
[16:09] *** agentzh left
[16:09] *** ting left
[16:22] *** wknight8111 left
[16:25] *** ting joined
[16:28] *** [particle] joined
[16:33] *** agentzh joined
[16:35] <Auzon> rakudo: class Foo {my method bar {say 42}; method tryit {self!bar}}; Foo.new."tryit";

[16:35] <p6eval> rakudo r28227 OUTPUT[42␤]

[16:36] <Auzon> rakudo: class Foo {my method bar {say 42}; method tryit {self!bar}}; my $name = "tryit"; Foo.new.$name;

[16:36] <p6eval> rakudo r28227 OUTPUT[invoke() not implemented in class 'Perl6Str'␤current instr.: '_block11' pc 70 (EVAL_12:29)␤

[16:36] <Auzon> rakudo: class Foo {my method bar {say 42}; method tryit {self!bar}}; my $name = "tryit"; Foo.new.'$name';

[16:36] <p6eval> rakudo r28227 OUTPUT[Method '$name' not found for invocant of class 'Foo'␤current instr.: '_block11' pc 64 (EVAL_13:28)␤

[16:36] <Auzon> rakudo: class Foo {my method bar {say 42}; method tryit {self!bar}}; my $name = "tryit"; Foo.new."$name"

[16:36] <p6eval> rakudo r28227 OUTPUT[42␤]

[16:39] <Auzon> rakudo: class Foo {my method bar {say 42}; method tryit {self!bar}}; Foo.new.'tryit';

[16:39] <p6eval> rakudo r28227 OUTPUT[42␤]

[16:41] <[particle]> 's nice seeing tests passing

[16:42] <Auzon> Yep. I don't see any tests like this, so those are my next additions.

[16:42] <Auzon> They'll be in S12-methods. 

[16:43] *** [particle]1 left
[16:43] <Auzon> Is there a term for calling a method using a variable or quoted string like this?

[16:44] <[particle]> interpolated?

[16:44] <[particle]> there is a term... i'm trying to remember it

[16:44] <[particle]> gotta look at the ::(...) op i think

[16:44] <Auzon> The spec mentions something like indirect

[16:44] <[particle]> ah, right

[16:44] <[particle]> indirect method call

[16:45] *** nipotaway is now known as nipotan

[16:45] <Auzon> but that's confusing with the indirect syntax, e.g. bar $foo: 1,2,3

[16:45] <TimToady> that's the "indirect object" syntax

[16:45] <Auzon> Ah, ok.

[16:45] <[particle]> ut oh

[16:46] <[particle]> $bar $foo: 1,2,3

[16:46] <TimToady> not allowed

[16:46] <[particle]> stated in spec?

[16:46] <TimToady> that's two terms in a row

[16:46] <[particle]> ok, that should be tested

[16:46] <Auzon> I'll add it.

[16:46] <[particle]> auzon++

[16:49] <pmurias> TimToady: ~/localperl/bin/perl STD5_run statementlist ~/p6/t/spec/S02-literals/radix.t is the right way to run radix.t?

[16:49] <pugs_svnbot> r20746 | pmurias++ | STD5_run dosn't fail silently if the wrong rule is specified

[16:49] *** eternaleye joined
[16:50] *** IllvilJa left
[16:51] <pasteling> "TimToady" at 71.139.14.242 pasted "what I was running radix.t with (actually an old copy in try.t)" (13 lines, 270B) at http://sial.org/pbot/31266

[16:55] <TimToady> takes about 15 seconds to spit out 37 megabytes of log :)

[16:57] <diakopter> hey, that's similar to yap6 on trace level 6

[16:58] <pmurias> took 16sec here with debugging switched off

[16:59] <pmurias> on radix.t

[16:59] <TimToady> 4 seconds here

[16:59] <TimToady> but some of that is dumping the result

[16:59] <pmurias> but works and that's important ;)

[17:00] <TimToady> important points: it's doing true LTM and true language switching

[17:00] <TimToady> true LTM modulo bugs like aa|a

[17:02] <TimToady> but that's really only an issue under non-ratchet

[17:02] <TimToady> so I'm not worrying about it until we get better laziness

[17:02] <TimToady> not sure what to do next

[17:02] <TimToady> get regexes parsing maybe

[17:03] <TimToady> or work on lazy list semantics in p5 so I don't have to care about things like .* generating a list for the whole rest of the string

[17:03] <TimToady> (and presumably fix the aa|a bug at the same time)

[17:04] <TimToady> but I think regex parsing is more applicable to getting STD to parse STD at this point

[17:05] <TimToady> since, for some reason, STD seems to use a lot of regexen...

[17:05] *** rdice left
[17:06] <TimToady> also don't want to break it all for my talk next week, so now is not the time for a major refactor...

[17:06] <Auzon> bah. 'perldoc Test.pm' can silently reference the system-wide Test module if the one in the current directory has no documentation

[17:09] <Auzon> rakudo: class Foo {my method bar {say 42}; method tryit {self!bar}}; Foo.new.'tryit'();

[17:09] <p6eval> rakudo r28227 OUTPUT[42␤]

[17:09] <Auzon> rakudo: class Foo {my method bar {say 42}; method tryit {self!bar}}; say(Foo.new.'tryit'());

[17:09] <p6eval> rakudo r28227 OUTPUT[42␤1␤]

[17:09] <Auzon> rakudo: class Foo {my method bar {say 42}; method tryit {self!bar}}; say(Foo.new.'tryit'(), 1, 2);

[17:09] <p6eval> rakudo r28227 OUTPUT[42␤112␤]

[17:10] *** nipotan is now known as nipotaway

[17:10] <Auzon> hm. Turns out that it's me being wrong, not Rakudo :)

[17:11] <Auzon> rakudo: class Foo {method tryit {'it works'}}; say Foo.new.tryit

[17:11] <p6eval> rakudo r28227 OUTPUT[it works␤]

[17:11] <Auzon> rakudo: class Foo {method tryit {'it works'}}; my $o = Foo.new; tryit $o:

[17:11] <p6eval> rakudo r28227 OUTPUT[Statement not terminated properly at line 1, near ":"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[17:13] *** eternaleye_ joined
[17:14] *** nipotaway is now known as nipotan

[17:14] <pugs_svnbot> r20747 | Auzon++ | [gsoc_spectest] indirect method call tests. (added 7 tests)

[17:15] <pmurias> TimToady: i could try to fake lazy lists in perl5

[17:15] *** eternaleye left
[17:19] <TimToady> how 'bout hacking real lazy lists into P5  :)

[17:20] <smtms> w/in 3

[17:20] <pmurias> i would have to learn perl5 guts, but if you can wait ;)

[17:27] *** Unix left
[17:36] *** tobeya joined
[17:40] *** barney joined
[17:41] *** wknight8111 joined
[17:47] <pugs_svnbot> r20748 | diakopter++ | [yap6] stable grammar checkpoint.. I think.  hopefully p6eval will work now :)

[17:47] <Auzon> rakudo: class Foo {} my $code = sub {@_.perl.say}; Foo.new.$code;

[17:47] <p6eval> rakudo r28227 OUTPUT[Statement not terminated properly at line 1, near "my $code ="␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[17:50] *** lambdabot left
[17:50] <pugs_svnbot> r20749 | diakopter++ | [yap6] slight fix to match()

[17:50] *** lambdabot joined
[17:51] <Auzon> yap6: class Foo {}; say "ok"

[17:51] <p6eval> yap6 r20748 OUTPUT[syntax error near "Foo {}; say \"ok\""␤]

[17:51] <Auzon> yap6: sub Foo {}; say "ok"

[17:51] <p6eval> yap6 r20748 OUTPUT[syntax error near "Foo {}; say \"ok\""␤]

[17:52] <diakopter> it still doesn't know quotes

[17:57] *** wknight8111 left
[17:57] *** wknight8111 joined
[17:59] <pugs_svnbot> r20750 | diakopter++ | [yap6] when p6eval updates yap6 from svn, this will work:

[17:59] <pugs_svnbot> r20750 | diakopter++ | sub Foo { $a; } say $ok;

[18:01] *** donaldh left
[18:02] *** donaldh joined
[18:08] <kolibrie> TimToady: if I had a grammar to parse a conference schedule, I could compile that into perl 5 with gimme5.  Is there a way to run it against an input file?

[18:10] * kolibrie is thinking about starting to prepare to update his talk for next week: http://feather.perl6.nl/~kolibrie/extraction.xul

[18:13] * kolibrie wants to be able to field questions regarding how to use: pugs, PCR, kp6, STD, elf, rakudo, (and what about smop and yap6)

[18:23] <pmurias> smop and elf don't support much perl6 rules yet

[18:24] <TimToady> kolibrie: see my recent nopaste

[18:25] <kolibrie> TimToady: I was trying to figure out how to use that for this scenario, but my brain did not wrap far enough

[18:26] <TimToady> you're basically talking about using something else where that program uses STD5

[18:27] <TimToady> but if you want to feed something directly to gimme5, you'll need to make sure it is in a form that it can handle

[18:27] <TimToady> because it's not actually doing a real parse on its input

[18:28] <TimToady> so the } at the end of a grammar must be marked with # end grammar, for instance

[18:28] <kolibrie> I got what appears to be perl 5 code at the top with a data structure at the bottom

[18:28] <TimToady> it does do a real parse on the rules

[18:29] <TimToady> the data structure is the parse of those rules

[18:29] <TimToady> mostly used by the LTM to determine the longest token

[18:29] <kolibrie> so if I only have rules, it should parse fine

[18:29] <TimToady> what happens when you run it

[18:29] <TimToady> ?

[18:30] <TimToady> well, you'll probably need to write something that uses it like the nopast

[18:30] <kolibrie> right, so that is the next step

[18:30] <kolibrie> I think that 'comp_unit' becomes whatever my toplevel rule is

[18:30] <kolibrie> and 'try.t' becomes my input file

[18:30] <TimToady> yes, and change Perl-> to whatever your grammar name is

[18:31] <kolibrie> aha - I was trying to figure out where that came from

[18:32] <TimToady> eventually we'll probably have one more step there where you have to say Perl->new->parse() so that we have a mutable grammar object, but for now, that's the incantation

[18:33] <kolibrie> thank you so much.  I'll play with this for a bit and get back to you (I have to play with real $work a bit too)

[18:33] <TimToady> it's quite likely to blow up

[18:33] <kolibrie> I'll stand a few feet away

[18:34] <pmurias> @tell mncharity elf breaks with the newest autobox

[18:34] <lambdabot> Consider it noted.

[18:36] <pmurias> TimToady: gimme5 hardcodes grammar Perl

[18:36] <kolibrie> pmurias: oh, that is perhaps why I could not get elf running.  will try an older version of autobox unless elf gets fixed first

[18:37] <kolibrie> pmurias: not in my grammar - no mention of 'Perl' at all - it says: package main::bogus

[18:39] *** pbuetow_ joined
[18:39] <TimToady> I can probably patch that, as long as you start your file grammar Foo

[18:39] <TimToady> hang on

[18:44] <Auzon> rakudo: class Foo {my method bar {say 42}; method tryit {$!bar}}; Foo.new.'tryit'();

[18:44] <p6eval> rakudo r28227 OUTPUT[Scope  not found for PAST::Var '$!bar'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[18:47] <pugs_svnbot> r20751 | lwall++ | [gimme5] unhardwire Perl as top grammar

[18:49] <TimToady> 'k, now you should be able to start your file with "grammar Bogus;"

[18:49] <Auzon> perl6: class Foo {my method bar {say 42}; method tryit {$!bar}}; Foo.new.tryit();

[18:49] <p6eval> kp6 r20751: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    

[18:49] <p6eval> ..pugs: RESULT[\undef]

[18:49] <p6eval> ..rakudo r28227: OUTPUT[Scope  not found for PAST::Var '$!bar'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[18:49] <p6eval> ..elf r20751: OUTPUT[Parse error in: /tmp/ZiVqFOIEXt␤panic at line 1 column 49 (pos 49): Missing right brace␤WHERE: d bar {say 42}; method tryit {$!bar}}; Foo.new.tryit();␤WHERE:                              /\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:255:in `_block_rest'␤ 

[18:49] <p6eval> ..STD_red/std.rb:242:in `block in block'␤  STD_red/prelude.rb:51:in `...

[18:49] <Auzon> and it all goes boom

[18:51] <TimToady> mad bomber Auzon++

[18:54] *** pbuetow left
[18:57] <Auzon> TimToady: In S12, should the $!doit be mentioned around the "Dot notation can omit the invocant if it's in $_" part?

[18:58] <TimToady> you mean, as in !doit doesn't do what you think if you think it means $_!doit ?

[18:59] <Auzon> Oh. Never mind, I forgot that .doit was for $_ and not self

[19:00] <Auzon> I saw the self!doit(1,2,3) line below and thought .doit was self.doit

[19:02] <TimToady> the fact that it's not self.doit is a Very Long Discussion back in the dark ages

[19:02] <Auzon> Yeah, I read that two weeks ago

[19:05] *** sscaffidi left
[19:05] <Auzon> perl6: class Foo {method bar {say 42}; method tryit {$.bar}}; Foo.new.tryit();

[19:05] <p6eval> kp6 r20751: OUTPUT[42␤]

[19:05] <p6eval> ..pugs: OUTPUT[42␤]

[19:05] <p6eval> ..rakudo r28227: OUTPUT[42␤]

[19:05] <p6eval> ..elf r20751: OUTPUT[42␤]

[19:05] <diakopter> yap6: sub foo { $a; }; say $ok;

[19:05] <p6eval> yap6 r20751 OUTPUT[parse successful␤]

[19:06] *** sscaffidi joined
[19:06] <Auzon> That's a scary global, diakopter ;)

[19:06] *** cognominal_ joined
[19:07] <diakopter> yap6: class Foo {method bar {say 42}; method tryit {$bar};}; 

[19:07] <p6eval> yap6 r20751 OUTPUT[parse successful␤]

[19:08] <Auzon> do you mean "method tryit {$.bar}"?

[19:08] <diakopter> Auzon: where it says parse successful, read that as "hierarchical tokenization successful"

[19:09] <diakopter> Auzon: no, b/c yap6 doesn't know about "." yet

[19:09] <diakopter> let alone method calls

[19:09] <Auzon> Ok, so it parsed, even though the execution wouldn't be valid since $bar isn't declared there.

[19:10] <diakopter> right, it tokenized so that it can be *really* syntax checked on the next pass

[19:10] <diakopter> or squished into this pass.

[19:11] <diakopter> at lunch I thought of a hint() parser combinator/constructor

[19:12] <diakopter> hint(match(qr|some pattern|),anotherRule)

[19:14] <diakopter> where hint results in both(iff(match(qr|some pattern|)),anotherRule(),'.')

[19:14] <pugs_svnbot> r20752 | Auzon++ | [gsoc_spectest] adding smartlink for tests of $!method syntax

[19:14] <diakopter> iff means lookahead and continue if successful

[19:14] <diakopter> but don't eat input

[19:14] <diakopter> get it?  if and *only* if; haha

[19:14] <TimToady> how is it different from <?before ...>

[19:15] <diakopter> I don't know; what does <?before ...> do... point me to a SXX:nnnn?

[19:17] <diakopter> I'm afraid I'm only cursorily familiar with the SXX

[19:17] <Auzon> rakudo: class Foo {method doit {say "works"}} my $class = "Foo"; "$class".new.doit

[19:17] <p6eval> rakudo r28227 OUTPUT[Statement not terminated properly at line 1, near "my $class "␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[19:17] <Auzon> rakudo: class Foo {method doit {say "works"}}; my $class = "Foo"; "$class".new.doit

[19:17] <p6eval> rakudo r28227 OUTPUT[works␤]

[19:17] <Auzon> rakudo: class Foo {method doit {say "works"}}; my $class = "Foo"; $class.new.doit

[19:17] <p6eval> rakudo r28227 OUTPUT[works␤]

[19:17] <TimToady> oh S05:1362 and thereabouts

[19:18] <Auzon> rakudo: class Foo {method doit {say "works"}}; my $class = "Foo"; $class.doit

[19:18] <p6eval> rakudo r28227 OUTPUT[Method 'doit' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 52 (EVAL_12:24)␤

[19:18] <Auzon> rakudo: class Foo {method doit {say "works"}}; my $class = "Foo"; "$class".doit

[19:18] <p6eval> rakudo r28227 OUTPUT[Method 'doit' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 52 (EVAL_12:24)␤

[19:20] *** alc left
[19:21] <diakopter> TimToady: it's identical to <?before ...> I think

[19:21] <diakopter> which means <!before <something>> and <!something> can be translated to it

[19:21] <diakopter> but not the capturing one...

[19:22] <diakopter> actually, the capturing one can be done too

[19:23] <diakopter> the combinated parser would just create/publish its own new parser coderef under some keyed name

[19:24] <diakopter> and then send it on through to the continuation using eval

[19:26] <diakopter> hmm; lookbehind... currently it's constructing the AST only on the way back from the EOI, but I guess it can construct it on its way there too/instead, so that lookbehind could work.

[19:27] <diakopter> but the RE hints, esp in the nbexpr (non-block expression) rule, would really help efficiency I think.

[19:28] <TimToady> EOI?

[19:29] <TimToady> the way the LTM works, it uses the contents of <?before> as the token and ignores what follows

[19:29] <diakopter> end of input

[19:29] <TimToady> while <!before> is just the opposite

[19:30] <diakopter> oh ok

[19:30] <TimToady> I don't understand what constructing the AST has to do with lookbehind

[19:30] <TimToady> it's just matching backwards

[19:32] <TimToady> see all the *rev methods in Cursor5 for its implementation of <after>

[19:32] <diakopter> well currently the input is stored as nested arrayrefs/characters which are chewed up destructively as a heretofore successful path is taken, so that would need redone to support lookbehind (since right now there's nothing to look for backwards)

[19:33] <TimToady> ah, Cursor5 just uses pos on an immutable input string

[19:33] *** barney left
[19:33] <TimToady> actually, the real pos is passed around via the continuations

[19:33] <diakopter> ok. that's what I'll choose as well then

[19:34] <diakopter> it's not like someone is going to give us a 512MB input string

[19:34] <diakopter> well, STD5.pm is close

[19:34] <TimToady> I suspect I'll eventually need to move to scalar contexts and iterators instead of list contexts

[19:35] *** TJCRI left
[19:35] <TimToady> unless I can figure out an easy way for p5 to support lazy lists outside of tied arrays

[19:36] <TimToady> most of the time you can get away with p5's eager lists under ratchet mode

[19:36] <TimToady> since you're always just throwing away all but the first value of the list

[19:36] <diakopter> is an <?after > literally applied in reverse? as if the whole content string is inverted? or are ^ and $ effectively swapped

[19:37] <TimToady> but as I mentioned earlier, .* would be a problem, since it would eagerly generate all the continuations from here to the end of the input

[19:37] <TimToady> nothing changes meaning, but the pattern is matched from the back end

[19:37] <TimToady> some patterns are not reversible

[19:37] <diakopter> there are algorithms to convert left recursion to right recursion... I though?

[19:37] <diakopter> thought

[19:38] <TimToady> well, anything is better than p5's limitation of literal strings only

[19:38] <TimToady> and it's completely impractical to try to rescan in the forward direction

[19:39] <TimToady> so I guess at some point the implementations will have to come to some rough agreement on what is reversible and what isn't

[19:39] <TimToady> STD5's implementation is a good first approximation though

[19:40] <TimToady> if you say <?after ^^ .* $$> it will match the $$, then the .* backwards till it finds a ^^

[19:41] <TimToady> well, modulo the .* problem I mentioned.  You'd probably want to write \N* there for now

[19:41] <TimToady> or .*?

[19:42] <TimToady> though that will try to generate all the possibilities under eager lists

[19:42] <diakopter> well currently I put a self-recursion depth limitation (depth charge) on every parser for every input position

[19:43] <TimToady> originally gimme5/metholate targeted pugs with gather/take, which is (in theory) lazy

[19:43] <diakopter> and it's set to 2

[19:44] <diakopter> so if the exact same parser (rule) is called on the exact same input more than twice, it fails that branch

[19:44] <diakopter> ... at least I think we're talking about the same thing.

[19:46] *** rindolf joined
[19:46] <TimToady> if your LTM is really working right it should detect recursion without progress most of the time

[19:47] <TimToady> as long as your longest token is non-zero length, you make progress, pretty much guaranteed

[19:47] *** Gothmog_ left
[19:48] <diakopter> well that's the method $cdepth->{$magical_eta_conversion_parser_self_reference}->{$input arrayref, though it should be changed to flattened string} ++ for each new depth

[19:48] <diakopter> where cdepth used to mean concatenation depth before I renamed concatenation to all(), which recurses down to both()

[19:50] <diakopter> yeah; as long as it escapes infinite recursion (and the grammar is encoded correctly), it will eventually match the entire input correctly or fail at some point b/c the input doesn't fit the grammar's language

[19:51] <diakopter> and I think I've implemented the memoization correctly so that it can act in linear time instead of exponential like most top-down/rd parsers

[19:51] *** Gothmog_ joined
[19:53] <diakopter> at least according to the paper on packrat parsing

[19:53] <diakopter> TimToady: your parser would fall into the predictive category, right?

[19:54] <TimToady> by and large

[19:57] <diakopter> pugs: say 3 if { "trailing conditional block" }

[19:57] <p6eval> OUTPUT[3␤]

[19:57] <diakopter> pugs: say 3 if ({ "trailing conditional block" })

[19:57] <p6eval> OUTPUT[3␤]

[19:57] <diakopter> pugs: say 3 if ({ "trailing conditional block"; return 0 })

[19:57] <p6eval> OUTPUT[3␤]

[19:58] <Auzon> pugs: say 3 if 0

[19:58] <p6eval> RESULT[undef]

[19:58] <diakopter> pugs: say 3 if { "trailing conditional block"; return 0; }

[19:58] <p6eval> OUTPUT[3␤]

[19:58] <TimToady> it's not counting that as a bare statement

[19:59] <TimToady> bare statements inside () are really post-pugs

[19:59] <diakopter> pugs: say 3 if &{ "trailing conditional block"; return 0; }

[19:59] <p6eval> OUTPUT[*** ␤    Unexpected "{"␤    expecting "::"␤    at /tmp/Arbi2xBWqM line 1, column 11␤]

[19:59] <TimToady> pugs say 3 if { "trailing conditional block"; return 0; }()

[19:59] <TimToady> pugs: say 3 if { "trailing conditional block"; return 0; }()

[19:59] <p6eval> No output (you need to produce output to STDOUT)

[20:00] <TimToady> pugs: say 3 if do { "trailing conditional block"; return 0; }

[20:00] <p6eval> OUTPUT[*** Cannot use this control structure outside a 'routine' structure␤    at /tmp/vYMbW2ephW line 1, column 45-53␤]

[20:00] <TimToady> actually, return is illegal there

[20:00] <diakopter> pugs: say 3 if do { "trailing conditional block"; return 1 }

[20:00] <p6eval> OUTPUT[*** Cannot use this control structure outside a 'routine' structure␤    at /tmp/2m7xyQYRo3 line 1, column 45-54␤]

[20:00] <TimToady> should be illegal in the bare block too

[20:00] <diakopter> pugs: say 3 if do { "trailing conditional block"; 1; }

[20:00] <p6eval> OUTPUT[3␤]

[20:00] <TimToady> pugs: say 3 if do { "trailing conditional block"; leave(1) }

[20:00] <p6eval> OUTPUT[3␤]

[20:01] <diakopter> say 3 if do { "trailing conditional block";

[20:01] <diakopter> pugs: say 3 if do { "trailing conditional block"; leave 1; 0; }

[20:01] <p6eval> RESULT[undef]

[20:01] <diakopter> pugs: say 3 if do { "trailing conditional block"; leave(1); 0; }

[20:01] <p6eval> RESULT[undef]

[20:02] <TimToady> looks busted

[20:02] <diakopter> pugs: say 3 if do { "trailing conditional block"; leave(1); $_; }

[20:02] <p6eval> RESULT[undef]

[20:02] <TimToady> pugs: say 3 if do { "trailing conditional block"; leave(0) }

[20:02] <p6eval> OUTPUT[3␤]

[20:03] <TimToady> looks like leave is return a true value :/

[20:03] <TimToady> *returning

[20:03] *** rindolf left
[20:03] <diakopter> pugs: say leave(undef)

[20:03] <p6eval> OUTPUT[␤]

[20:03] <diakopter> pugs: say leave(0)

[20:03] <p6eval> OUTPUT[0␤]

[20:04] <TimToady> that *should* be bypassing the say

[20:05] <diakopter> pugs: say do { do { leave('hi') } }

[20:05] <p6eval> OUTPUT[hi␤]

[20:09] <TimToady> bbl &

[20:10] *** chris2 joined
[20:11] <diakopter> yap6: say do { do { say 78 }; };

[20:11] <p6eval> yap6 r20752 OUTPUT[parse successful␤]

[20:12] <diakopter> yap6: say do { do; { say 78 };;};

[20:12] <p6eval> yap6 r20752 OUTPUT[syntax error near "; { say 78 };;};"␤]

[20:12] <diakopter> yap6: say do { do { say 78 };;};

[20:12] <p6eval> yap6 r20752 OUTPUT[parse successful␤]

[20:12] <Auzon> yap6: ;;

[20:12] <p6eval> yap6 r20752 OUTPUT[parse successful␤]

[20:13] <diakopter> yap6: { { }; };

[20:13] <p6eval> yap6 r20752 OUTPUT[parse successful␤]

[20:13] *** pugpuppy joined
[20:13] <Auzon> yap6: class Foo {}

[20:14] <p6eval> yap6 r20752 OUTPUT[syntax error near "}"␤]

[20:14] <Auzon> yap6: class Foo {};

[20:14] <p6eval> yap6 r20752 OUTPUT[parse successful␤]

[20:14] <diakopter> yap6: classs Foo {};

[20:14] <p6eval> yap6 r20752 OUTPUT[syntax error near "Foo {};"␤]

[20:14] <pugpuppy> any ideas on how to start contributing on PERL6, found the directions quite confusing

[20:14] <diakopter> that's b/c it parsed "classs" as a type/classname

[20:15] <diakopter> pugpuppy: what do you like to do?

[20:15] * diakopter looks around for PERL6

[20:15] <pugpuppy> well I have been working on PERL, pretty much all my bread and butter depends on it. So therefore thought well let me start some farming

[20:16] <pugpuppy> I am from a development background, so anything on development will be just great

[20:16] <pugpuppy> just dont know where to get started and how

[20:16] <Auzon> moritz++ did a writeup of the current status of Perl 6 implementations at http://perlmonks.org/?node_id=690945

[20:16] <lambdabot> Title: Getting Involved with Perl 6 - an Update

[20:16] <diakopter> if I were you, I'd check out that page and the perlfoundation.org/perl6 wiki

[20:17] *** Gothmog_ left
[20:18] <pugpuppy> thanks for that but PERL6 wiki is voluminious and I get to sleep just enough to know that I had a break from my comp

[20:19] <pugpuppy> great thanks for the article

[20:19] <Auzon> pugpuppy: You can also play around with the various Perl 6 implementations here in a limited form.

[20:19] <Auzon> rakudo: say "hi"

[20:19] <p6eval> rakudo r28227 OUTPUT[hi␤]

[20:19] <pugpuppy> how do I do that 

[20:20] <Auzon> Prefix some code with rakudo:, pugs:, kp6:, elf:, yap6:, or nqp:, depending on which one to try

[20:20] <Auzon> you can also call the 4 most complete with perl6:

[20:21] <Auzon> perl6: say [*] 1 .. 5

[20:21] <p6eval> kp6 r20752: OUTPUT[syntax error at position 4, line 1 column 4:␤say [*] 1 .. ␤    ^ HERE␤]

[20:21] <p6eval> ..pugs: OUTPUT[120␤]

[20:21] <p6eval> ..rakudo r28227: OUTPUT[Statement not terminated properly at line 1, near "1 .. 5"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[20:21] <p6eval> ..elf r20752: OUTPUT[Parse error in: /tmp/r4Yedl3yQv␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say [*] 1 .. 5␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[20:21] <p6eval> ..STD_red/std.rb:210:in `_UNIT'␤  ./../STD_red/STD_red_run:108:in `main'␤  ./../STD...

[20:21] <pugpuppy> mind blowing

[20:21] <Auzon> That one can be a bit noisy when things fail, though

[20:22] <Auzon> Do you know any of the new syntax?

[20:22] <pugpuppy> but will it not be disturbing for other uesrs

[20:23] <pugpuppy> nopes I have actually not started on learning the new syntaxes

[20:23] <pugpuppy> was going through this article though sometime back and also installed PERL6 in my system

[20:23] *** cjfields left
[20:24] * diakopter thought of another combinator: of(3..5,rulename) hits only if there are between 3 and 5 repititions of rulename, inclusively

[20:24] <pugpuppy> http://www.wellho.net/solutions/perl-parrot-perl-s-new-virtual-machine.html

[20:24] <lambdabot> Title: Parrot - Perl&#039;s new Virtual Machine, http://tinyurl.com/57gmhh

[20:24] <diakopter> not sure how helpful that will be though

[20:24] <pugpuppy> so any ideas on which materials to refer to

[20:25] <Auzon> What are you hoping to do?

[20:25] <pugpuppy> well contributing to PERL6 development

[20:26] <Auzon> What languages do you know?

[20:26] <pugpuppy> this will be first time that I will actually be contributing to any community so you can really imagine me as a real puppy (though a very enthusiastic one and wagging tail and all that )

[20:26] <pugpuppy> PERL, C, VBA, PHP

[20:27] <pugpuppy> learning bits and pieces of JAVA as well 

[20:27] <pugs_svnbot> r20753 | diakopter++ | [yap6] fixed semicolon-less trailing statements in statement lists (including inside blocks)

[20:29] <Auzon> I'm personally working on the Perl 6 test suite. The only skills needed for that are Perl 6, the ability to read the specs, and some general testing knowledge.

[20:29] <diakopter> pugpuppy: probably you should read the Synopses... the specification for the Perl 6 language: http://perlcabal.org/syn/

[20:29] <lambdabot> Title: Official Perl 6 Documentation

[20:30] <[particle]> pugpuppy: yikes, that's an old link

[20:30] <[particle]> parrot's assemble.pl went away long ago

[20:31] <pugpuppy> can you get me the new/ fresh link

[20:32] <diakopter> yap6: class Foo {{{{}}}}

[20:32] <p6eval> yap6 r20753 OUTPUT[parse successful␤]

[20:33] *** icwiener joined
[20:36] <[particle]> pugpuppy: see for example http://www.parrotblog.org/ or http://parrotcode.org/

[20:36] <lambdabot> Title: Parrot

[20:36] <Auzon> There was a NQP (or was it PIR?) tutorial a while back that could help with hacking on Rakudo. The barrier to entry there is a bit higher than things in the Pugs repository, however

[20:37] <pugpuppy> okay, I had a look at the second one. Its two am out here and I will catch up with you tomorrow

[20:37] <pugpuppy> thanks a lot for your help

[20:37] <Auzon> See you.

[20:37] <[particle]> welcome!

[20:41] <Auzon> perl6: class Foo {}; say Foo.new.?test;

[20:41] <p6eval> kp6 r20753: OUTPUT[syntax error at position 26, line 1 column 26:␤class Foo {}; say Foo.new.?test␤                          ^ HERE␤]

[20:41] <p6eval> ..pugs: OUTPUT[␤]

[20:41] <p6eval> ..rakudo r28227: OUTPUT[Failure␤]

[20:41] <p6eval> ..elf r20753: OUTPUT[Unknown rule: dotty:.?␤It needs to be added to ast_handlers.␤ at ./elf_f_faster line 2676␤]

[20:41] <Auzon> perl6: class Foo {}; say Foo.new.test;

[20:41] <p6eval> kp6 r20753: OUTPUT[no method 'test' in Class 'Foo'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤       

[20:41] <p6eval> ..pugs: OUTPUT[*** No such method in class Foo: "&test"␤    at /tmp/o4m8A6O6JM line 1, column 19-31␤]

[20:41] <p6eval> ..rakudo r28227: OUTPUT[Method 'test' not found for invocant of class 'Foo'␤current instr.: '_block11' pc 43 (EVAL_10:20)␤

[20:41] <p6eval> ..elf r20753: OUTPUT[Can't locate object method "test" via package "Foo" at (eval 14) line 8.␤ at ./elf_f_faster line 4496␤]

[20:42] *** pugpuppy left
[20:42] <pugs_svnbot> r20754 | diakopter++ | [yap6] set toodeep to 0; in theory this should be ok

[20:44] *** icwiener left
[20:44] *** Gothmog_ joined
[20:45] <diakopter> yap6: class Foo {{{{{{{{{{{{{{}}}}}}}}}}}}}}

[20:45] *** barney joined
[20:45] <p6eval> yap6 r20754 OUTPUT[parse successful␤]

[20:46] <pmurias> yap6: say 4

[20:46] <p6eval> yap6 r20754 OUTPUT[syntax error near 4␤]

[20:46] <pmurias> yap6: 4

[20:46] <p6eval> yap6 r20754 OUTPUT[parse successful␤]

[20:46] <pmurias> yap6: say(4)

[20:46] <p6eval> yap6 r20754 OUTPUT[syntax error near "(4)"␤]

[20:47] <pmurias> yap6: 1+2+3

[20:47] <p6eval> yap6 r20754 OUTPUT[parse successful␤]

[20:47] <pmurias> yap6: say(123);

[20:47] <p6eval> yap6 r20754 OUTPUT[syntax error near "(123);"␤]

[20:47] <Auzon> I think that's a bug. ^_^'

[20:47] *** barney left
[20:48] <pmurias> Auzon: maybe it's an missing feature ;)

[20:48] <Auzon> It used to work, so it's a regression :)

[20:48] *** pjcj_ left
[20:55] <pmurias> yap6: class Foo {{{{{{{{{{{{{{}}}}}}}}}}}}}}

[20:55] <p6eval> yap6 r20754 OUTPUT[parse successful␤]

[20:56] <pmurias> yap6: class Foo {}

[20:56] <p6eval> yap6 r20754 OUTPUT[parse successful␤]

[20:56] <pmurias> yap6: class Foo {{}}

[20:56] <p6eval> yap6 r20754 OUTPUT[parse successful␤]

[20:57] <diakopter> pmurias: are you doing some execution time tests? :P

[20:57] <Auzon> pugs: say "rakudo: say 'hi'"

[20:57] <p6eval> OUTPUT[rakudo: say 'hi'␤]

[20:57] <Auzon> oh

[20:57] <Auzon> not beginning of line, so I can't make it cascade

[20:57] <diakopter> 7 seconds for 14 nested expressions; 1 second for 2 nested expressions

[20:57] <Auzon> dang. :P

[20:58] <diakopter> heh

[20:58] <pmurias> diakopter: just checking if yap6 works at all

[20:58] <pmurias> diakopter: how should i run src/sbin/perl6?

[20:59] <Auzon> I think it runs with Perl 5

[21:00] *** alanhaggai left
[21:00] <pmurias> it gives me syntax errors on everything

[21:01] <pmurias> i use perl -I src/lib/ src/sbin/perl6 file

[21:04] <pmurias> yap6: class Foo {}

[21:04] <p6eval> yap6 r20754 OUTPUT[parse successful␤]

[21:04] <pmurias> i'll try later;sleep&

[21:04] *** pmurias left
[21:09] <diakopter> pmurias: the syntax errors are pre-source filter I think :D

[21:09] <diakopter> the source filter actually doesn't do that much

[21:10] <Auzon> What Perl are you using, diakopter?

[21:10] <diakopter> just takes the rule name and makes the rule rulename {}; block a my $rulename = parser {}; declaration

[21:11] <diakopter> strawberry 5.10.0.latest on win32 daytime and 5.10.0 on x86 darwin at nighttime

[21:11] <diakopter> but I think p6eval uses 5.8...?

[21:11] <Auzon> Right.

[21:11] <diakopter> b/c it didn't like it when I used //=

[21:11] <Auzon> elf: say $?VERSION

[21:11] <p6eval> OUTPUT[Global symbol "$VERSION" requires explicit package name at (eval 14) line 3.␤ at ./elf_f_faster line 4496␤]

[21:11] <Auzon> elf: say $*VERSION

[21:11] <p6eval> OUTPUT[Can't call method "Str" on an undefined value at ./elf_f_faster line 619.␤ at ./elf_f_faster line 4496␤]

[21:12] <Auzon> What's that variable...?

[21:12] <diakopter> elf: eval "system('perl -v')"

[21:12] <p6eval> OUTPUT[␤This is perl, v5.8.8 built for i486-linux-gnu-thread-multi␤␤Copyright 1987-2006, Larry Wall␤␤Perl may be copied only under the terms of either the Artistic License or the␤GNU General Public License, which may be found in the Perl 5 source kit.␤␤Complete documentation for Perl, including FAQ

[21:12] <p6eval> ..lists, should be found on␤this system using "ma...

[21:12] <Auzon> You shouldn't need to eval it

[21:13] <diakopter> oh yeah

[21:13] <Auzon> elf: say $?PERLVER; say $*PERLVER

[21:13] <p6eval> OUTPUT[Can't call method "Str" on an undefined value at ./elf_f_faster line 619.␤ at ./elf_f_faster line 4496␤elf / perl 5.8.8 / EmitFasterP5␤]

[21:13] <Auzon> there. It's $*PERLVER.

[21:14] <Auzon> elf: say $*OSVER

[21:14] <p6eval> OUTPUT[Can't call method "Str" on an undefined value at ./elf_f_faster line 619.␤ at ./elf_f_faster line 4496␤]

[21:14] <Auzon> elf: say $*PERLVER

[21:14] <p6eval> OUTPUT[Can't call method "Str" on an undefined value at ./elf_f_faster line 619.␤ at ./elf_f_faster line 4496␤]

[21:14] <Auzon> or, it's $?PERLVER

[21:14] <Auzon> OK, just wondering if Perl 5.10 had issues with yap6 that 5.8.8 didn't

[21:17] <diakopter> *wow* I haven't implemented the memoization correctly... it could be even faster.

[21:18] *** jhorwitz left
[21:19] <diakopter> hm; yap6 is hitting p6eval's memory limit on 21 nested expressions

[21:19] <diakopter> surely there aren't that many in STD.pm ;)

[21:20] <Auzon> So 21 brackets deep?

[21:21] <diakopter> yeah

[21:21] <diakopter> or ()

[21:23] <Auzon> perl6: my $foo = "hello"; $foo ~= ' world'; say $foo

[21:23] <p6eval> kp6 r20754: OUTPUT[syntax error at position 24, line 1 column 24:␤my $foo = "hello"; $foo ~= ' world'; say $fo␤                        ^ HERE␤]

[21:23] <p6eval> ..pugs: OUTPUT[hello world␤]

[21:23] <p6eval> ..rakudo r28227: OUTPUT[hello world␤]

[21:23] <p6eval> ..elf r20754: OUTPUT[Unknown rule: infix_postfix_meta_operator:=␤It needs to be added to ast_handlers.␤ at ./elf_f_faster line 2676␤]

[21:23] <Auzon> ok, good enough.

[21:24] <Auzon> perl6: my @foo = <a b c d>; say @foo.perl

[21:24] <p6eval> kp6 r20754: OUTPUT[[ 'a', 'b', 'c', 'd' ]␤]

[21:24] <p6eval> ..pugs: OUTPUT[["a", "b", "c", "d"]␤]

[21:24] <p6eval> ..rakudo r28227: OUTPUT[["a", "b", "c", "d"]␤]

[21:24] <p6eval> ..elf r20754: OUTPUT[["a","b","c","d"]␤]

[21:29] <Auzon> rakudo: class Foo {method doit(Int $num) {say  $num + 1}} Foo.new.doit

[21:29] <p6eval> rakudo r28227 OUTPUT[Statement not terminated properly at line 1, near "Foo.new.do"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[21:29] <Auzon> rakudo: class Foo {method doit(Int $num) {say  $num + 1}}; Foo.new.doit(5)

[21:29] <p6eval> rakudo r28227 OUTPUT[6␤]

[21:29] <Auzon> rakudo: class Foo {method doit(Int $num) {say  $num + 1}}; Foo.new.doit()

[21:29] <p6eval> rakudo r28227 OUTPUT[too few arguments passed (1) - 2 params expected␤current instr.: 'parrot;Foo;doit' pc 86 (EVAL_13:48)␤

[21:29] <Auzon> rakudo: class Foo {method doit(Int $num) {say  $num + 1}; method doit {say 'nothing'}}; Foo.new.doit()

[21:29] <p6eval> rakudo r28227 OUTPUT[too few arguments passed (1) - 2 params expected␤current instr.: 'parrot;Foo;doit' pc 156 (EVAL_13:78)␤

[21:29] <Auzon> rakudo: class Foo {multi method doit(Int $num) {say  $num + 1}; multi method doit {say 'nothing'}}; Foo.new.doit()

[21:29] <p6eval> rakudo r28227 OUTPUT[No applicable methods.␤current instr.: '_block11' pc 43 (EVAL_13:20)␤

[21:29] <Auzon> rakudo: class Foo {multi method doit(Int $num) {say  $num + 1}; multi method doit {say 'nothing'}}; Foo.new.doit

[21:30] <p6eval> rakudo r28227 OUTPUT[No applicable methods.␤current instr.: '_block11' pc 43 (EVAL_13:20)␤

[21:41] *** rindolf joined
[21:59] *** sscaffidi_ joined
[22:01] *** IllvilJa joined
[22:02] *** Limbic_Region joined
[22:02] *** sscaffidi left
[22:12] *** rindolf left
[22:13] *** khisanth_ joined
[22:19] <Auzon> rakudo: class Foo {method doit(Int $num) {say  $num + 1}} Foo.new.doit(5)

[22:19] <p6eval> rakudo r28227 OUTPUT[Statement not terminated properly at line 1, near "Foo.new.do"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[22:20] <Auzon> rakudo: class Foo {method doit(Int $num) {say  $num + 1}}; Foo.new.doit(5)

[22:20] <p6eval> rakudo r28227 OUTPUT[6␤]

[22:20] *** Khisanth left
[22:21] *** khisanth_ is now known as Khisanth

[22:24] *** sscaffidi_ is now known as sscaffidi

[22:25] *** sscaffidi left
[22:30] <bacek> rakudo: say 1 ~~ Perl6Scalar

[22:30] <p6eval> rakudo r28227 No output (you need to produce output to STDOUT)

[22:30] <bacek> oops

[22:31] *** wknight8111 is now known as wknight-away

[22:33] *** iblechbot left
[22:41] *** cjfields joined
[22:41] <pugs_svnbot> r20755 | diakopter++ | [yap6] committing changes so I can work another place

[22:42] *** cjfields left
[22:42] *** jan__ left
[22:42] <Auzon> Heh. I know that feeling

[22:43] *** eternaleye_ left
[22:44] <pugs_svnbot> r20756 | Auzon++ | [gsoc_spectest] Fixed typo in S13 test. Added new defer_call and defer_next tests to test the callsame, callwith, nextsame, and nextwith functions (S12). Added 18 tests.

[22:48] *** eternaleye_ joined
[23:03] *** apeiron left
[23:11] *** Eevee_ joined
[23:16] *** apeiron joined
[23:19] *** chris2 left
[23:24] *** Eevee left
[23:29] *** vixey joined
[23:36] *** Eevee__ joined
[23:36] *** Eevee_ left
[23:38] *** wknight-away left
[23:40] <pugs_svnbot> r20757 | Auzon++ | [gsoc_spectest] more entries for t/TASKS

[23:49] *** cmarcelo left
[23:58] *** Eevee_ joined
