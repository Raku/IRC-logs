[00:05] *** thoughtpolice left
[00:06] *** thoughtpolice joined
[00:32] <meppl> good night

[00:33] *** meppl left
[00:38] *** polettix left
[00:40] *** wknight8111 joined
[00:41] <wknight8111> Is Rakudo development still in the Parrot SVN at languages/perl6?

[00:43] <obra> I believe so

[00:43] <Tene> wknight8111: yes.

[00:46] <wknight8111> I've been having a lot of problems when testing Rakudo. Simple things like declaring and using variables fail

[00:46] <wknight8111> and I have the most recent version from the SVN, which is why I asked if it was the current development version

[00:48] <Khisanth> svn log :)

[00:49] *** justatheory left
[00:52] *** justatheory joined
[00:54] <wknight8111> For instance, the following code fails: my $x = 5; say $x;

[00:55] <wknight8111> I'll either get an error that the second statement wasn't terminated correctly, or that there was specified scope for $x

[00:55] <wknight8111> no specified scope *

[00:56] <wknight8111> "No scope found for PAST::Var '$x'"

[01:03] *** Lorn joined
[01:14] <ruoso> rakudo: my $x = 5; say $x;

[01:14] <exp_evalbot> OUTPUT[5␤]

[01:15] <ruoso> wknight8111, are you sure you have it built right?

[01:15] <ruoso> perl6: my $x=5; say $x;

[01:15] <exp_evalbot> kp6: OUTPUT[5␤]

[01:15] <exp_evalbot> ..pugs: OUTPUT[5␤]

[01:15] <exp_evalbot> ..rakudo: OUTPUT[5␤]

[01:18] *** devogon left
[01:23] <nothingmuch> @tell ruoso precisely.. it must be extened because you can't have every method call be implemented in terms of about 3 other method calls, it has to be faked at the lowest level, that's why it must be extended and not replaced

[01:23] <lambdabot> Consider it noted.

[01:24] <wknight8111> ruoso, I'm pretty sure I have it built right

[01:24] <wknight8111> i ran the makefile, no errors popped up

[01:24] <wknight8111> although I am on Windows, so who knows what is considered "right" anymore

[01:33] <nothingmuch> wknight8111: he's not in chan

[01:34] <nothingmuch> dunno if he backlogs, but I'd use lambdabot

[01:42] *** sunnavy joined
[01:46] *** achermov joined
[01:49] <achermov> Is there a module that'll let me embed Perl code into web pages, PHP style?

[01:54] *** adu joined
[01:57] <wknight8111> achermov, perl6 or perl5?

[01:57] <achermov> irrelevant now. I got an answer elsewhere. Thanks though.

[01:57] <wknight8111> no problem

[01:58] *** achermov left
[02:02] *** zakame joined
[02:04] *** eternaleye_ joined
[02:04] *** eternaleye left
[02:04] *** eternaleye_ is now known as eternaleye

[02:21] *** adu left
[02:23] *** lambdabot left
[02:24] *** lambdabot joined
[02:25] *** Jedai left
[02:43] *** zakame_ joined
[02:43] *** zakame left
[02:44] *** zakame_ is now known as zakame

[03:04] *** zakame_ joined
[03:05] *** zakame left
[03:05] *** zakame_ is now known as zakame

[03:11] *** Auzon joined
[03:22] <pugs_svn> r19884 | putter++ | [misc/red_STD] started circumfix support.  "(2+3)*4" now barely works.

[03:25] <mncharity> fyi, it runs with off-the-shelf ruby (1.8, rather than the new 1.9).   ruby std.rb  will hand you a read-eval-print-loop to play with.  currently parses almost nothing of course.

[03:26] <Auzon> What's red_STD?

[03:28] <mncharity> # A ruby transliteration of src/perl6/STD.pm

[03:28] <Auzon> Neat :)

[03:32] <mncharity> basically, STD.pm currently runs by being highly massaged into p6 which runs on pugs.  so you spend a great deal of time trying to work around pugs bugs, and the development process is slow.  objective of red_STD is to be fully runable within a person week or two.  to help shake down STD.pm, and perhaps be a front-end for something.

[03:33] *** Andy_ joined
[03:35] <mncharity> re Neat, :)  yeah, could be.

[03:45] *** zakame_ joined
[03:46] *** alester left
[03:51] *** zakame left
[03:51] *** zakame_ is now known as zakame

[03:53] *** drbean joined
[03:58] *** wknight8111 is now known as wknight-away

[04:02] *** zakame_ joined
[04:06] *** zakame left
[04:19] *** zakame_ is now known as zakame

[04:24] *** wknight-away left
[04:27] *** eternaleye left
[04:36] *** adu joined
[04:39] *** chacha_chaudhry joined
[04:41] *** chacha_chaudhry left
[04:51] <pugs_svn> r19885 | putter++ | src/perl6/STD.pm: in UNIT, fixed typo in rule name.

[04:52] *** thoughtpolice left
[04:56] *** nerog left
[05:14] *** drbean left
[05:15] <pugs_svn> r19886 | putter++ | [misc/red_STD] can parse "3" from _TOP.  also "3;4".  tweaked eat_terminator.

[05:19] *** zakame left
[05:23] *** zakame joined
[05:24] *** justatheory left
[05:34] *** monomorph joined
[05:36] *** mncharity left
[05:52] *** monomorph left
[05:57] *** zakame_ joined
[05:59] *** zakame left
[06:00] *** DarkWolf84 left
[06:52] *** zakame__ joined
[06:53] *** zakame__ is now known as zakame

[06:59] *** devogon joined
[07:02] *** eternaleye joined
[07:03] *** zakame_ left
[07:34] *** psapo joined
[07:53] *** Aankhen`` joined
[07:53] *** iblechbot joined
[07:57] *** drbean joined
[08:00] *** polettix joined
[08:01] *** zakame left
[08:01] *** zakame joined
[08:15] *** polettix left
[08:24] *** adu left
[08:27] <moritz_> @tell wknight8111 if you test rakudo, don't use the REPL loop for now, it causes rakudo to segfault on some variable declarations (known bug)

[08:27] <lambdabot> Consider it noted.

[08:42] *** meppl joined
[08:45] *** blindfish joined
[09:00] *** viklund joined
[09:00] *** zakame_ joined
[09:04] *** zakame_ left
[09:05] *** zakame_ joined
[09:15] *** zakame left
[09:21] *** zakame_ left
[09:24] *** zakame joined
[09:26] *** baest left
[09:32] *** zakame_ joined
[09:38] *** thepler_ joined
[09:49] *** baest joined
[09:50] *** zakame left
[09:54] *** baest left
[10:01] *** baest joined
[10:07] *** IllvilJa joined
[10:10] *** tooo joined
[10:13] <wolverian> kp6: state $foo = 2; 

[10:13] <exp_evalbot> r19886: OUTPUT[syntax error at - line 12, near ") ␤;"␤syntax error at - line 18, near ","␤  (Might be a runaway multi-line '' string starting on line 16)␤syntax error at - line 21, near "1 }"␤Execution of - aborted due to compilation errors.␤]

[10:13] <wolverian> hmm 

[10:13] <wolverian> rakudo: state $foo = 2

[10:13] <exp_evalbot> OUTPUT[scope declarator 'state' not implemented at line 1, near "= 2"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤called from Sub 'parrot;Perl6;Grammar;Actions;_block1295' pc 81842 (src/gen_actions.pir:2778)␤called from Sub

[10:13] <exp_evalbot> ..'parrot;Perl6;Grammar;Actions;_block1278' pc 80777 (src/gen_actions.pir:2358)␤ca...

[10:13] <wolverian> does anything implement state yet? :(

[10:13] <wolverian> http://scsys.co.uk:8001/12729 I'm wondering whether this is what perl6 would do as well 

[10:14] <wolverian> (jrockway noticed it) 

[10:18] *** pbuetow joined
[10:20] *** ebassi joined
[10:24] *** ruoso joined
[10:30] <moritz_> wolverian: perl 5.10 does ;9

[10:31] <moritz_> pugs: state $foo = 3

[10:31] <exp_evalbot> RESULT[\3]

[10:33] *** zakame__ joined
[10:33] <wolverian> moritz_, see the paste. I wanted to compare perl5 and perl6 in this respect

[10:34] *** zakame__ is now known as zakame

[10:35] <moritz_> did you try pugs?

[10:40] *** zakame_ left
[10:53] *** zamolxes joined
[10:54] <ruoso> hi

[10:54] <moritz_> hi ruoso ;)

[10:54] <obra> morning

[10:55] <ruoso> well... it's monday... so...

[10:55] <moritz_> ruoso: I see you found more followers ;)

[10:55] <moritz_> erm, commiters ;)

[10:55] <ruoso> heh...

[10:55] <ruoso> I'm very happy by the fact that smop is getting into Perl 6 radar

[10:56] <ruoso> and specially happy to see #p5p people interested in it...

[10:56] <obra> I'm happy about it too :)

[10:58] <ruoso> @tell nothingmuch I'm not pretty sure I'm getting what you mean... :) 

[10:58] <lambdabot> Consider it noted.

[11:00] *** zamolxes_ joined
[11:02] *** zamolxes left
[11:07] *** zamolxes joined
[11:07] <ruoso> is there any documentation on what the API for Array and Hash must be? or are the implementations supposed to figure that out?

[11:09] *** zamolxes_ left
[11:10] *** funktio joined
[11:15] *** zamolxes_ joined
[11:17] *** zamolxes left
[11:19] *** lisppaste3 joined
[11:22] *** zamolxes joined
[11:24] <cognominal_> is there a    for  @argv ->  $_, $i  {}     sometimes one wants to iterate but have a counter too

[11:24] <moritz_> ruoso: in S29 there is an overview about available methods

[11:25] <cognominal_> arf, may be that means I get inti @arfv two by two

[11:25] <moritz_> cognominal_: you'd use for @arv zip 0..* -> $a, $counter {...}

[11:25] *** zamolxes_ left
[11:25] <cognominal_> nice

[11:26] <cognominal_> I don't think about zip even if I learnt some haskell

[11:26] <moritz_> it will be a FAQ, trust me ;)

[11:28] <cognominal_> I read the synopses but not enough code, my perl6 is passive so far

[11:28] <cognominal_> STD.pm is good reading

[11:29] <moritz_> it's a harsh introduction, either way

[11:29] *** zamolxes_ joined
[11:29] <cognominal_> but STD.pm a very good followup to the synopses

[11:31] <cognominal_> I am trying to translate  Getopt/Obj.pir in a perl6 grokable by rakudo

[11:32] *** zamolxes left
[11:32] <moritz_> cognominal_: there is also ext/Getopt-{Long,Process,Std} in the pugs repo

[11:33] <cognominal_> but none of them is an exact translation of  Getopt/Obj.pir ?

[11:36] *** zamolxes joined
[11:39] *** zamolxes_ left
[11:42] *** meppl left
[11:44] *** zamolxes_ joined
[11:46] *** zamolxes left
[11:48] <moritz_> I'd guess they're all hand coded

[11:51] *** zamolxes joined
[11:53] *** zamolxes_ left
[11:54] <ruoso> moritz_, thanks

[11:56] *** mj41 joined
[11:58] *** zamolxes_ joined
[11:58] <moritz_> ruoso: I'll be at the German Perl Workshop this week... maybe I can ask some people if they are interested in smop, and where to get funding

[11:59] <ruoso> moritz_, that would be great

[11:59] <moritz_> does thrading work atm?

[12:00] *** zamolxes left
[12:02] <ruoso> in theory, yes...

[12:02] <ruoso> I need to create a new test that deals with it,

[12:02] <ruoso> but all the code is supposed to be thread-safe

[12:03] <ruoso> that means you can have two threads running different interpreter instances

[12:03] <ruoso> and they can even call methods in objects they share

[12:03] <moritz_> ok, thanks

[12:05] *** zamolxes joined
[12:08] *** zamolxes_ left
[12:12] *** zamolxes_ joined
[12:15] *** zamolxes left
[12:20] *** zamolxes joined
[12:22] *** kcwu joined
[12:23] *** zamolxes_ left
[12:23] *** xinming joined
[12:28] *** zamolxes_ joined
[12:30] *** zamolxes left
[12:35] *** zamolxes joined
[12:36] <ruoso> I made a review in the REPR API, considering the realisation that "an Array is anything that identifies itself as one" -- http://www.perlfoundation.org/perl6/index.cgi?smop_oo_api -- as usual, any review is appreciated

[12:36] <lambdabot> Title: SMOP OO API / Perl 6

[12:38] *** zamolxes_ left
[12:41] *** cmarcelo joined
[12:42] *** zamolxes_ joined
[12:43] *** zamolxes left
[12:47] *** ebassi left
[12:49] *** zamolxes joined
[12:50] *** ebassi joined
[12:51] *** zamolxes_ left
[12:54] *** zamolxes_ joined
[12:54] *** zamolxes_ left
[12:58] *** zamolxes left
[13:00] <pugs_svn> r19887 | ruoso++ | [smop] threading test added. And yes, it works :)

[13:00] <ruoso> moritz_, ^

[13:00] *** lidden joined
[13:01] *** zamolxes joined
[13:06] <pugs_svn> r19888 | ruoso++ | [smop] now 09_threads.t have two rw threads and one ro thread... added a usleep also to make its more concurrent...

[13:11] *** zamolxes_ joined
[13:13] *** zamolxes left
[13:13] *** njbartlett left
[13:15] *** njbartlett joined
[13:17] *** zamolxes joined
[13:21] *** zamolxes_ left
[13:27] *** zamolxes left
[13:32] *** Psyche^ joined
[13:32] *** Psyche^ is now known as Patterner

[13:38] *** njbartlett left
[13:43] *** renormalist joined
[13:49] *** Zygo joined
[13:56] *** andara joined
[13:57] *** Lorn left
[13:57] *** Lorn_ joined
[14:01] *** Andy_ left
[14:01] *** drbean left
[14:04] *** monomorph joined
[14:12] *** renormalist left
[14:14] *** Jedai joined
[14:26] *** stevan_ joined
[14:56] *** ebassi is now known as ebassi|afk

[14:58] *** alester joined
[14:58] *** andara left
[14:59] *** jhorwitz joined
[15:01] *** zamolxes joined
[15:03] *** manfred joined
[15:05] *** jferrero joined
[15:12] *** chris2 joined
[15:21] *** zamolxes left
[15:24] *** viklund left
[15:26] *** test left
[15:26] *** viklund joined
[15:33] *** PerlJam joined
[15:38] <pugs_svn> r19889 | ruoso++ | [smop] added the interpreter %p in the 09_threads.t test output to show that the code is being run by different threads.

[15:41] *** rdice joined
[15:46] *** zamolxes joined
[15:54] *** ilbot2 joined
[15:56] *** Auzon left
[15:56] *** moritz joined
[15:56] *** moritz is now known as moritz_

[15:57] <ruoso> moritz_, did you see the new test?

[15:57] <moritz_> ruoso: no, sorry, disconnect and all :/

[15:57] <ruoso> test/09_threads.t

[16:03] *** ebassi|afk is now known as ebassi

[16:05] <ruoso> TimToady, I think I've reached a sane API for the SMOP OO... Could you please take a look at http://www.perlfoundation.org/perl6/index.cgi?smop_oo_api when you have some time?

[16:05] <lambdabot> Title: SMOP OO API / Perl 6

[16:07] <ruoso> If that's really sane, I should start implementing p6opaque

[16:10] *** sri_work joined
[16:11] *** pmurias joined
[16:12] <pmurias> ruoso: what will the identifier part of a message call be in real smop code

[16:12] <pmurias> ?

[16:13] <ruoso> pmurias, hm?

[16:13] <ruoso> it's an Object

[16:14] <ruoso> the only difference is that the constant identifiers can be used to optimize the dispatch

[16:14] <pmurias> ruoso: is it intended to be a string in no-optimized code?

[16:14] <ruoso> yes

[16:15] <ruoso> as string reads "anything that complies to the string api"

[16:22] <pmurias> ruoso: won't it be hard to call objects which take constant identifiers from "high-level" code

[16:22] <pmurias> ?

[16:22] <ruoso> in theory, the compiler *should* use the constant identifiers from the high-level code

[16:22] <ruoso> whenever it can, of course

[16:23] <ruoso> this constant identifiers are Objects just like String

[16:23] <ruoso> they just have a different representation

[16:23] <ruoso> a different responder interface

[16:24] <pmurias> ruoso: it could be possible to make the objects to accepts string also

[16:24] <pmurias> ruoso: the idconst identifiers implement the String API?

[16:25] <ruoso> they will

[16:25] <ruoso> they don't do it yet

[16:25] <ruoso> but they must do it

[16:25] <pmurias> are they a big speedup?

[16:25] <ruoso> certainly

[16:25] <ruoso> if it is a constant identifier I can simply compare the pointers

[16:26] <ruoso> and avoid any string comparision at all

[16:27] <ruoso> in the lowlevel it can be translated to: if (identifier == SMOP__ID__new)

[16:27] <ruoso> while String will require a cast to a native type

[16:27] <ruoso> and then a comparision of the native type afterwards

[16:28] *** zamolxes left
[16:28] <ruoso> if they have the same type

[16:28] <ruoso> it is possible to have a direct cmp

[16:29] <ruoso> but even then, I think casting to native and comparing is probably faster than comparing in non-native

[16:32] <pmurias> i get the picture

[16:44] *** meppl joined
[16:49] <pmurias> ruoso: if a class we inherit from changes it's ancestors we have to update our composition pile?

[16:50] <pmurias> (under C3)

[16:50] <moritz_> a class can change its anchestors? scary...

[16:50] <pmurias> moritz_: is it forbiden?

[16:51] <moritz_> pmurias: I think you can add anchestors, but can you delete them?

[16:51] <ruoso> pmurias, the composition pile only  refers to *this class* ancestors

[16:51] <moritz_> $class is also { is Other::Anchestor }

[16:51] <ruoso> not recursively

[16:52] <ruoso> the MRO is recursive

[16:52] <pmurias> ok

[16:52] <ruoso> cache must be external

[16:53] <ruoso> as it needs to be invalidated globally whenever some class is changed

[17:07] <pmurias> s1p code is translated into C?

[17:07] <pmurias> or sm0p?

[17:07] <ruoso> s1p code is translated to C + sm0p

[17:07] <ruoso> with the code that builds that class

[17:08] *** rindolf joined
[17:10] <ruoso> with probably two C functions

[17:10] <ruoso> SMOP__S1P__Object__BUILD

[17:10] <ruoso> and 

[17:11] <ruoso> SMOP__S1P__Object__DESTROY

[17:11] <ruoso> to initialize and destroy the prototype

[17:13] *** TJCRI joined
[17:14] <pmurias> the c will be used for setting up and sm0p for the method bodies?

[17:18] <pmurias> i guess not, based on http://www.perlfoundation.org/perl6/index.cgi?smop_s1p_language

[17:18] <lambdabot> Title: SMOP s1p Language / Perl 6

[17:20] *** tooo left
[17:23] *** kst joined
[17:24] *** justatheory joined
[17:24] *** Psyche^ joined
[17:35] *** smtms joined
[17:40] *** Patterner left
[17:40] *** Psyche^ is now known as Patterner

[17:55] *** Lorn__ joined
[18:02] *** zakame left
[18:05] *** rindolf left
[18:06] <ruoso> pmurias, yes... the s1p method bodies will be translated to a set of sm0p blocks each

[18:07] <ruoso> the C code will be the code sorrounding this blocks to build them

[18:09] <TimToady> ruoso: okay, looked at it

[18:09] <TimToady> basically sane, though I have some quibbles and questions

[18:10] *** meppel-san joined
[18:10] <TimToady> Object's BUILD/DESTROY I envisioned as being methods that attempt to do something useful if the actual object doesn't define the submethod

[18:10] <TimToady> some reprs could autogen a BUILD on demand, for instance

[18:10] <TimToady> but at minimum it could complain about there being no BUILD submethod for the class

[18:11] <TimToady> maybe that's not how it should be, but it's how I was picturing it

[18:11] <TimToady> lessee...

[18:11] <TimToady> you don't need any of those trailing semicolons

[18:11] <TimToady> a final } on a line always implies ;

[18:12] <TimToady> I don't think there's a WALK type as a return value, it's just a List of Routine or some such

[18:12] <TimToady> speaking of which, it would be nice if all your return types said what they're Lists or Hashes "of"

[18:12] <TimToady> might want to use --> List of Foo notation in that case

[18:13] <TimToady> rather than the front type

[18:13] *** justatheory left
[18:13] *** justatheory joined
[18:13] <TimToady> it seems strange to think of an attribute as RO

[18:14] <TimToady> but maybe it's just an attribute descriptor?

[18:16] <TimToady> the arguments for "can"-like calls should really be considered to be taking something more general than just a name, since we have to be able to qualify by argument types as well

[18:17] *** tobeya joined
[18:18] <TimToady> things like $object.can(&foo:(Int,Str,*)) and such

[18:18] <TimToady> so it's a little odd to call it $identifier

[18:20] *** meppl left
[18:20] <TimToady> most of the .^ methods were also envisioned to have a corresponding method in Object

[18:20] *** meppel-san is now known as meppl

[18:20] <TimToady> so by default $object.can calls $object.^can, and .does calls .^does, etc

[18:21] <TimToady> but that was just for convenience

[18:21] <TimToady> it's possible we could enforce the ^

[18:21] *** TJCRI left
[18:21] <TimToady> in fact, the way to enforce the ^ is to put methods into Object that *refuse* to delegate to .HOW  :)

[18:22] <TimToady> but maybe we just delegate, and then that gives users of Object the right to override .can and .does in subclasses, and maybe that's a good thing

[18:23] <TimToady> well, that's enough to start with.  :)

[18:27] *** TJCRI joined
[18:30] *** jjore-w joined
[18:34] *** njbartlett joined
[18:37] *** rindolf joined
[18:51] *** njbartlett left
[18:52] *** fridim_ joined
[18:57] *** manfred left
[18:59] *** stevan_ left
[19:04] *** rindolf left
[19:05] *** stevan_ joined
[19:06] <cognominal_> what is the ref equivalent in Perl 6

[19:07] <cognominal_> how to get the class name of an object?

[19:09] <Tene> $obj.WHAT iirc

[19:10] <Tene> pugs: my $s = 'foo'; say $s.WHAT

[19:10] <exp_evalbot> OUTPUT[Str␤]

[19:12] *** Aankhen`` left
[19:12] <TimToady> .WHAT gives you the protoobject, which stringifies to the class name if there is one

[19:12] <TimToady> but there doesn't have to be...

[19:13] <TimToady> and a normal class declaration basically does Foo::Bar ::= $anonclass.WHAT to attach it to a package name

[19:14] <ruoso> TimToady, but... can we have both a submethod and a method of the same name?

[19:14] <ruoso> I mean...

[19:14] <ruoso> I'm trying to figure out what to do about BUILD

[19:15] <ruoso> because Object's BUILD do something

[19:15] <cognominal_> thx Tene

[19:15] <cognominal_> and TimToady

[19:15] <ruoso> it sets all the public attributes of the object that are in the *%initialize argument

[19:16] <TimToady> submethods are essentially subs that just think they are methods

[19:16] <TimToady> and expect to be called with an invocant

[19:16] <TimToady> but their names live in sub space really

[19:16] <ruoso> and also, if there's a BUILD method, the same BUILD will be called for every class in the hierarchy

[19:16] <ruoso> while a submethod will only be invoked for one specific class

[19:16] <ruoso> (unless I got it wrong...)

[19:17] <TimToady> when a dispatcher calls them, they're really called as subs, not as methods

[19:17] <TimToady> only Object defines a BUILD method generally, and mostly just to make sure the dispatch is handled well by default

[19:18] <TimToady> I guess it can be a submethod in Object and still work that way though

[19:18] <ruoso> my guess was that the call to BUILD is $class->?BUILD() instead of ->BUILD

[19:19] <ruoso> which means that it is ok if a class don't define a custom BUILD

[19:19] <ruoso> but...

[19:19] <ruoso> there's the capture manipulation

[19:20] <ruoso> BUILD can "consume" elements from the capture...

[19:20] <TimToady> sorry, distracted cooking lunch...

[19:20] <ruoso> (if I got it right)

[19:20] <cognominal_> what should print  ./parrot languages/perl6/perl6.pbc -e 'print undef.WHAT'

[19:20] <ruoso> rakudo: print undef.WHAT

[19:20] <exp_evalbot> OUTPUT[Statement not terminated properly at line 1, near ".WHAT"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤called from Sub 'parrot;Perl6::Grammar;statementlist' pc 14911 (src/gen_grammar.pir:2402)␤called from Sub 'parrot;Perl6::Grammar;statement_block'

[19:20] <exp_evalbot> ..pc 12098 (src/gen_grammar.pir:1396)␤called from S...

[19:20] <ruoso> rakudo: print undef.WHAT();

[19:20] <exp_evalbot> OUTPUT[Statement not terminated properly at line 1, near ".WHAT();"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤called from Sub 'parrot;Perl6::Grammar;statementlist' pc 14911 (src/gen_grammar.pir:2402)␤called from Sub

[19:20] <exp_evalbot> ..'parrot;Perl6::Grammar;statement_block' pc 12098 (src/gen_grammar.pir:1396)␤called fro...

[19:21] <cognominal_> it dies on me

[19:21] <ruoso> rakudo: print undef().WHAT();

[19:21] <exp_evalbot> OUTPUT[Undef]

[19:21] <cognominal_> hum

[19:22] <cognominal_> why I should pos-parenthesize the undef?

[19:23] <cognominal_> rakudo: print undef().WHAT

[19:23] <exp_evalbot> OUTPUT[Undef]

[19:23] <TimToady> if you want a default BUILD submethod, where's the right place to store that?

[19:23] <ruoso> Object

[19:23] *** rindolf joined
[19:23] *** funktio left
[19:23] <ruoso> but that's not actually "default"

[19:23] <ruoso> that will always be called

[19:24] <ruoso> (which I thought to be the pourpose on submethods after all

[19:24] <TimToady> seems like it's repr dependent

[19:24] <ruoso> not exactly...

[19:24] <ruoso> if I'm right, it'll use the REPR API

[19:24] <ruoso> which makes it repr independant

[19:24] <ruoso> as long as all repr implement the API

[19:25] <TimToady> true

[19:25] <ruoso> (and I really think the REPR API could be considered standard Perl 6... I really don't know if it can be done without it)

[19:25] <TimToady> I guess whether you think of Object::BUILD as a method or as a submethod depends on whether you think of the BUILD calls as method calls or a sub calls

[19:26] <ruoso> but isn't hiding it the point of submethods?

[19:26] <TimToady> I was thinking of normal dispatch as @candidates = WALK; for @candidates { $_.() }

[19:27] <ruoso> the only difference is that you would need to call

[19:27] <ruoso> $class->BUILD($object: )

[19:27] <ruoso> which would end up being

[19:27] <TimToady> where as soon as you take a ref to a method, it basically turns into a sub as far as dereferencing goes

[19:27] <ruoso> $class->can("BUILD")->call( \($object: ) )

[19:28] <cognominal_> rakudo: say (undef).WHAT

[19:28] <exp_evalbot> OUTPUT[Undef␤]

[19:28] <ruoso> $object->BUILD would probably never dispatch anything... 

[19:28] <TimToady> but that's basically a double call of can, if each submethod is also dispatched as a method

[19:29] <ruoso> you mean, to check for methods and for submethods...

[19:30] <ruoso> so falling back to package::BUILD($object) would be natural

[19:30] <ruoso> as every failed method dispatch failover to sub dispatch

[19:30] <ruoso> so, there's no much point in submethds at all

[19:31] <ruoso> they could simply be regular subs

[19:31] <TimToady> they're submethods so that we allow ($obj:) in the sig

[19:32] <TimToady> actually, I recently added the $object.*@candidates(@args); syntax

[19:33] <TimToady> but that's also essentially treating @candidates as a list of sub refs, not names

[19:33] <ruoso> so, during BUILDALL, it would invoke each BUILD by package with sub invocation, not by method of the object

[19:33] *** rindolf left
[19:33] <TimToady> note also that the call order is determined entirely by the WALK, and BUILD and DESTROY and normal dispatch are three different WALK orders

[19:34] <TimToady> $object.*@candidates(@args); is really sub invocations, I'm saying

[19:34] <TimToady> assuming @candidates doesn't contain method names

[19:34] <TimToady> with names they'd be redispatched

[19:35] <TimToady> $object.?$candidate(@args) is also a sub call if $candidate is a Routine

[19:35] <TimToady> no real dispatch involved, except to make the call optional

[19:35] <ruoso> I thought that it would always be a sub call in the $object.$anyhting... unless explicit $object."$anything" used...

[19:36] <TimToady> er, yeah, what you said.  :)

[19:36] <ruoso> I was thinking it was deterministic by syntax

[19:36] <TimToady> so never mind about that redispatch  :)

[19:36] <ruoso> ok

[19:36] <TimToady> if you want that you have to do your own walk

[19:37] <TimToady> I can't keep track of my own darn language, how will I expect other people to... :)

[19:37] <ruoso> that makes me think... isn't an Iterator type missing?

[19:37] <TimToady> List is the iterator type

[19:37] <ruoso> List have index-based access

[19:37] <TimToady> see "lazy"

[19:37] <ruoso> Iterator must be able of not having index-based lookups

[19:38] * ruoso thinking of a BDB Btree without recno

[19:38] <TimToady> a List will consist of a number of determined elements followed by a number of undetermined elements

[19:38] <ruoso> TimToady, that's the point

[19:38] <TimToady> if you use .[] it just moves some of them from undetermined to determined

[19:39] <ruoso> and what if you have a circular list

[19:39] <ruoso> you can't tell where it start

[19:39] <ruoso> or a lookup in a bdb db

[19:39] <ruoso> where you don't know how many elements there are before the one you got

[19:40] <TimToady> prefix:<=> is the destructive way to read a list

[19:40] <TimToady> or := to Array and use shift

[19:40] <ruoso> but that implies index-based lookup

[19:40] <TimToady> what of it?

[19:41] <ruoso> sometimes I can't have index-based lookups

[19:41] <TimToady> then you don't have an ordered type

[19:41] <ruoso> you have

[19:41] <ruoso> but you just don't know its cardinal position

[19:41] <ruoso> it is ordered

[19:41] <ruoso> you just can't count them

[19:41] <TimToady> you don't have a well-ordered type

[19:41] <TimToady> it's not transitive

[19:42] <ruoso> you must navigate using .has_next, .next, .has_previous, .previous

[19:42] <TimToady> fine, but Perl doesn't care about your circular linked list enough to implement it

[19:43] <TimToady> and if you know what .next is, you can index from that position anyway

[19:43] <ruoso> not in a berkeley db btree without recno

[19:43] <TimToady> it's just a turing machine tape

[19:44] <TimToady> Lists have a beginning in Perl

[19:44] <TimToady> even if that's just notiationally the current position

[19:44] <TimToady> *notionally

[19:44] <ruoso> I see... and that's why I was arguing... a pure Iterator type have several interesting use cases...

[19:45] <TimToady> .[3] do .next 3 times, peek, do .previous 3 times to get back (in the worst case)

[19:45] <TimToady> fine, but that's what =$iterator is for

[19:45] <TimToady> it's a scalar as far as Perl is concerned

[19:45] <ruoso> sure...

[19:46] <ruoso> It's just a matter of what's in the built-in api

[19:46] <ruoso> for multi dispatch matters

[19:47] <TimToady> note that @candidates can be as lazy as it likes

[19:47] <TimToady> it doesn't have to go out to the end unless you ask it to do that

[19:48] *** pmurias left
[19:48] <TimToady> if one of the candidates says whatever "last METHOD" has turned into these days

[19:48] <TimToady> it doesn't need to calculate the rest of the candidates

[19:48] <TimToady> lastcall it is now

[19:49] <[particle]> .onewhiskey()

[19:50] <TimToady> maybe it's the last altar call  :)

[19:51] *** jferrero left
[19:52] * ruoso still think it's easier to implement MRO in terms of Iterator than in terms of List...

[19:52] <TimToady> the main difference between List and Array is not their access interface; the main difference is that List presents an immutable interface to the order of the values, while an Array allows you to change out any elements you like

[19:53] * ruoso . o O ( Iterator is just a cursor to a List or an Array or whatever... )

[19:53] <TimToady> @candidates := WALK gives you the iterator

[19:53] <lambdabot> Unknown command, try @list

[19:54] * ruoso thinking about self->NEXT::foo(), for instance...

[19:55] <TimToady> that's spelled nextsame() these days

[19:55] <ruoso> anyway...

[19:55] <TimToady> and it has to work for mmd as well as single dispatch

[19:57] <TimToady> anyway, making @candidates an object with potentially non-destructive readout allows you to cache the list

[19:57] <TimToady> an iterator with destructive readout would force you to re-walk

[19:58] <ruoso> an iterator usually is read-only

[19:58] <ruoso> rw iterators are an exception

[19:58] <TimToady> an iterator evaporates once you've used it in my lingo

[19:58] <ruoso> not if it can forward and rewind

[19:59] <ruoso> like a db cursor

[19:59] <TimToady> but it's certainly not ro in the sense that nothing changes when you read it

[20:00] <ruoso> it's an RO access to the list

[20:00] <ruoso> the iterator itself is rw

[20:00] <ruoso> but an iterator usually don't write to the list

[20:02] <TimToady> look, whether you spell it "for @candidates" or ".*@candidates", there's an iterator there somewhere, but the user doesn't have to keep track of it

[20:02] <ruoso> sure...

[20:02] <ruoso> but again... I'm in a much lower level right now

[20:02] <ruoso> I don't even have a parser atm

[20:03] <TimToady> working on that... :)

[20:03] <ruoso> :)

[20:03] <ruoso> what I was arguing is that having Iterator as a built-in type

[20:03] <ruoso> makes some things easier in the low-level

[20:04] <[particle]> how 'bout a Role?

[20:04] <ruoso> by type I really mean something that can be ~~'d to

[20:09] <ruoso> but the point is that if getting an Iterator from a List is part of the List API

[20:09] <TimToady> well, you have to implement laziness somehow; I don't much care how much the implementation of List shows through to the user

[20:09] <ruoso> but it needs to be part of the standard API

[20:10] <ruoso> so I can actually get an Iterator from a List

[20:10] <TimToady> sure, but we actually try to hide the List api behind other apis in Perl, as far as mere mortals are concerned

[20:10] <ruoso> we can't

[20:10] <TimToady> "try to"

[20:11] <ruoso> because anything can implement a list

[20:11] <ruoso> we must have a very clear notion of what makes a List

[20:11] <TimToady> we do, but the user doesn't  :)

[20:11] <ruoso> it must, if the user can implement a List on its pown

[20:11] <PerlJam> Anything used in a List context is a List  ;)

[20:11] <ruoso> s/pown/own/

[20:12] <TimToady> then that user is not a mere mortal

[20:12] <ruoso> ah... ok...

[20:12] * ruoso realises that the problem is defining when a user is or not a highlander

[20:12] <TimToady> indeed, that's what Perl is all about.  but yes, certainly you have to be able to iterate a list on some level

[20:13] <ruoso> that's what I call the List API

[20:13] <TimToady> and in fact, it'll be very easy to generator iterators with ==> my $iter

[20:13] <[particle]> maybe make it list rather than List?

[20:13] <ruoso> [particle], that's not the point

[20:14] <ruoso> the point is really being able to deal with unknown types

[20:15] <ruoso> as long as they comply to some defined APIs

[20:15] <TimToady> an iterator must store its state somewhere external to the list, because a list must support multiple iterators simultaneously

[20:16] <TimToady> ruoso is saying he doesn't want to access the list from the iterator using .[], and that's fine

[20:16] <ruoso> yep

[20:16] <[particle]> don't we have closures?

[20:16] <TimToady> what mean "we", white man?

[20:16] <[particle]> does smop have closures at this level

[20:18] <ruoso> smop doesn't have lexical scopes yet

[20:18] <TimToady> closures are useful for generating more of the underlying list, but I don't see how that applies to iterators...

[20:18] <ruoso> indeed....

[20:18] *** Helios_ joined
[20:18] <ruoso> an iterator to a regular list would hold a simple int pointing to some point of the list

[20:18] <TimToady> but then you're assuming a .[] api again

[20:19] <TimToady> or a .next.next.next.prev.prev.prev api  :)

[20:19] *** sri_work left
[20:19] <ruoso> which is what I would like to use in the low-level

[20:20] <ruoso> ops... I've just understood what you said...

[20:20] <TimToady> well, the really low-level api just uses scalar refs that point to subs, and doesn't care how it gets fed those...

[20:20] <ruoso> the thing is that most of the time I won't have a regular list

[20:21] <ruoso> most of the time I'll use the list API to opaque data structures

[20:21] <ruoso> in the low-level

[20:21] <TimToady> there's no list at all in $object.?$subref()

[20:22] <TimToady> so you're really talking about the not-quite-lowest level

[20:22] <[particle]> ? meaning submethod? /me rechecks s12

[20:23] <ruoso> but $obj.^!isa returns a non-regular list

[20:23] <TimToady> meaning call $subref($object: ) optionally

[20:23] <[particle]> ah, gotcha.

[20:23] <TimToady> calling through a reference erases the distinction between subs and methods

[20:23] <ruoso> by non-regular list I mean a opaque object that implements the list api

[20:24] <ruoso> that would probably return a non-regular-list-iterator when asked for an iterator

[20:25] <ruoso> and navigating with next and previous is probably more efficient than resolving the index of each lookup

[20:25] <ruoso> for that opaque object

[20:25] <ruoso> or it certainly is if the access is always sequential

[20:25] <[particle]> btw i was thinking of generators when i mentioned closures, you're right, doesn't apply

[20:25] <ruoso> like during MRO 

[20:26] <TimToady> sure, and when the user writes his own dispatcher with $object.*@candidates, the .* dispatcher will be iterating through the array/list/whatever

[20:26] <ruoso> exactly...

[20:27] <ruoso> can I get my pony^Witerator type now?

[20:27] <TimToady> in fact, I suppose $object.*$iterator also falls out of that, which is what you're trying to get me to understand

[20:27] <TimToady> never said you couldn't :)

[20:28] <ruoso> one important thing that I think is not yet clear...

[20:28] <ruoso> is that what we call Perl 6 will also be defined by what the built-in APIs are

[20:29] <ruoso> and i think these should be considered specifications

[20:29] <ruoso> for instance... 

[20:29] <ruoso> I'm considering that there is a native capture type

[20:30] <ruoso> now there are two options... or the native capture becomes part of the spec, or I have to forget about it... otherwise the SMOP Perl 6 won't be compatible with the Rakudo Perl 6

[20:30] <TimToady> to the extent that those apis are the only reasonably way to do things, we can certainly consider speccing them.  but that's more something for various implementations to negotiate

[20:30] <TimToady> I try not to design too far out ahead of my own understanding.

[20:31] <[particle]> ok, that's scary.

[20:31] <[particle]> you already understand *a lot* :)

[20:31] <ruoso> my point is... if we agree on an Iterator type... it must get to the specs

[20:31] <ruoso> as to make sure code from different implementations can interoperate

[20:32] <[particle]> parrot's Iterator PMC doesn't have a 'previous' (most iterator implementations i know don't.)

[20:32] <TimToady> what, you don't back up lines with >STDIN<  ???

[20:32] * ruoso still wonders if the .^!foo api shouldn't get to the spec also...

[20:33] <ruoso> [particle], Iterator is really just an API... as every non-native built-in type

[20:33] <ruoso> we could consider that Iterator can only go forward

[20:33] <TimToady> that would be the base role

[20:33] <TimToady> a two-way iterator would add in .previous

[20:34] <ruoso> exactly

[20:34] <ruoso> and a rw iterator would include .add, .remove and .update

[20:35] *** hanekomu joined
[20:35] <ruoso> one important realisation I had in SMOP is that the only objects you actually know are the native ones... everything else is just Design by Contract... even for the built-in types...

[20:36] <ruoso> an Int is anything that says true to .does(Int)

[20:36] <ruoso> it can even have a different representation

[20:36] <TimToady> I don't think that's the standard definition of DbC, but whatever

[20:37] <ruoso> [particle], btw... how do you plan to support alternative representations in rakudo?

[20:37] <[particle]> i haven't really considered it yet.

[20:37] <ruoso> hmmm... 

[20:37] *** DarkWolf84 joined
[20:37] <ruoso> I'd suggest you considering it early...

[20:37] <[particle]> :)

[20:37] <TimToady> PMCs are parrot's God Object  :P

[20:38] <[particle]> right, we can always create another pmc.

[20:38] <[particle]> but, i'm sure there are some better than others,

[20:38] <[particle]> and parrot's pmc model is under refactoring atm

[20:38] <[particle]> soon we'll have role-composition for pmcs.

[20:39] <[particle]> i have a feeling that will impact rakudo's model. so, i wait.

[20:39] <ruoso> I mean... can you have a simple reference to a Glib object in a PMC? and delegate the object representation management to Glib?

[20:39] <[particle]> pmc's encapsulate behavior behind the VTABLE api

[20:40] <[particle]> so, yes.

[20:40] <ruoso> ok... so you probably won't have much trouble

[20:42] <ruoso> but one thing you must remember is that you must be able to do:

[20:42] <ruoso> my $foo = Int.CREATE(:repr<Glib>); my $bar = Int.bless($foo);

[20:43] <ruoso> so the object initialization code must not depend on a single representation

[20:43] <ruoso> that's exactly the point I'm stressing in the last week (what I'm calling the SMOP OO API)

[20:44] *** Psyche^ joined
[20:44] <ruoso> and that probably means that the repr api should be standard

[20:44] <[particle]> well, we're not quite there yet, but that's partially because there's no way (in the spec) to query the object's representation afaik

[20:44] <ruoso> and that would make a single core lib implementation that could be shared by rakudo and smop

[20:44] <[particle]> ...that's why you have .^!

[20:45] *** zamolxes joined
[20:45] <ruoso> yep... and the only thing that makes it SMOP specific right now is the fact that it's not in spec

[20:46] <[particle]> it's okay to be ahead of the spec.

[20:46] <[particle]> TimToady always catches up :)

[20:46] <[particle]> note that '{*}' and '#= foo' still isn't specced

[20:47] <ruoso> it would be amazing if smop and rakudo shared the built-in lib

[20:47] <PerlJam> Conventions shouldn't be specced so much  :)

[20:50] <ruoso> [particle], did you see smop/src-s1p/Object.pm

[20:50] * ruoso home &

[20:50] <[particle]> looking now

[20:51] *** buchetc joined
[20:51] <ruoso> it's outdated considering the last changes I made to the REPR api

[20:51] <ruoso> but the point is that it should probably be the same code that rakudo is supposed to run...

[20:52] <[particle]> ah, yes, looking at this reminded me that i need to add flattening to rakudo

[20:52] <ruoso> anyway... 

[20:52] <ruoso> home &

[20:52] <ruoso> seeya

[20:53] *** silug joined
[20:55] *** njbartlett joined
[20:55] <pugs_svn> r19890 | buchetc++ | use contend to avoid race condition

[20:59] *** Patterner left
[20:59] *** Psyche^ is now known as Patterner

[21:01] *** blindfish left
[21:01] *** thoughtpolice joined
[21:21] *** ludan joined
[21:22] <ludan> hi

[21:22] <TimToady> howdy

[21:23] *** Helios_ is now known as Helios

[21:40] *** sleskey joined
[21:49] <cognominal_> S4 mentions C<contend> but I can't see anywere else. What is it?

[21:51] *** pbuetow left
[21:51] <cognominal_> I see it in the rakudo grammar.pg too

[21:55] *** hanekomu left
[21:55] *** thepler_ left
[21:55] <buchetc> cognominal_: Formely it was called 'atomically', I think. I currently understand it as a kind of locking mechanism

[21:56] *** thepler joined
[21:58] <cognominal_> ok, makes sense

[21:58] <cognominal_> ho macosx 10.5.2 update and still no ps preview :(

[22:01] <allbery_b> not surprising, word I hear is 10.5.2 is all about Time Machine / Time Capsule

[22:01] <buchetc> cognominal_: contend should be documented in S17. 

[22:02] <cognominal_> ha, I searched in http://dev.perl.org/perl6/doc/, no S17 there

[22:02] <lambdabot> Title: Perl6 Architecture - perl6

[22:02] *** ruoso left
[22:02] *** jhorwitz left
[22:03] *** Jamtech joined
[22:04] <buchetc> try http://svn.openfoundry.org/pugs/docs/Perl6/Spec/Concurrency.pod; I don't know why it's hidden

[22:06] <cognominal_> well, in fact, right now, I have no special interest in it. Just surprised to see mentionned only once in the synopses

[22:10] *** jferrero joined
[22:12] *** iblechbot left
[22:14] *** psapo left
[22:15] *** psapo joined
[22:16] *** sleskey left
[22:19] *** monomorph left
[22:29] *** Auzon joined
[22:32] *** peeps[work] joined
[22:34] *** justatheory left
[22:35] *** justatheory joined
[22:36] *** Zygo left
[22:37] *** Zygo joined
[22:37] *** Limbic_Region joined
[22:39] *** Zygo left
[22:40] *** Zygo joined
[22:42] *** buchetc left
[22:47] *** cmarcelo left
[22:53] *** TJCRI left
[22:55] *** Limbic_Region left
[22:59] *** Jamtech left
[23:06] *** ruoso joined
[23:07] *** wknight-away joined
[23:07] *** peeps[work] left
[23:10] *** rdice left
[23:21] *** Zygo left
[23:21] *** Zygo joined
[23:22] *** Limbic_Region joined
[23:33] *** ebassi left
[23:36] *** ludan left
[23:38] *** jferrero left
[23:40] *** Jedai left
[23:40] *** ruoso left
[23:47] *** ruoso joined
[23:48] *** eternaleye left
[23:48] *** zamolxes left
[23:55] *** Zygo left
[23:56] *** Zygo joined
[23:58] *** Schwern joined
[23:59] *** PerlJam left
[23:59] *** Zygo left
