[00:02] *** araujo left
[00:12] <pugs_svn> r24640 | mberends++ | first commit, add self to AUTHORS

[00:18] *** araujo joined
[00:21] *** Limbic_Region left
[00:39] *** DemoFreak left
[01:04] *** jhorwitz left
[01:04] <pugs_svn> r24641 | ruoso++ | [smop] ControlExceptionReturn provides a helper method for the implicit CONTROL bblock of routines.

[01:04] <pugs_svn> r24641 | ruoso++ | [mildew] support twigil in &?ROUTINE

[01:04] <pugs_svn> r24641 | ruoso++ | [mildew] implement implicit CONTROL in Routines...

[01:06] *** stephens left
[01:20] *** mberends_ left
[01:24] *** kisu_ is now known as kisu

[01:48] <pugs_svn> r24642 | ruoso++ | [smop] fetches the routine from the scalar in handle_return

[01:48] <pugs_svn> r24642 | ruoso++ | [mildew] fix missing goto in the implicit CONTROL block of routines.

[01:48] <pugs_svn> r24642 | ruoso++ | [mildew] That means YAY! mildew implements the seantics of return control exception

[01:51] <ruoso> for those who are curious, look at v6/mildew/t/control_exception_routine.t

[01:52] * ruoso sleep ^

[01:52] <ruoso> er...

[01:52] * ruoso sleep &

[02:06] *** Limbic_Region joined
[02:12] *** Limbic_Region left
[02:18] *** nomas joined
[02:19] *** nomas left
[02:34] *** aindilis` is now known as aindilis

[02:45] *** dwhipp joined
[02:46] *** Whiteknight joined
[02:46] <dwhipp> pugs: 10 < 5|25 < 20

[02:46] <p6eval> pugs: RESULT«(Bool::False)»

[02:47] <dwhipp> rakudo: 10 < 5|25 < 20

[02:47] <p6eval> rakudo 34401: RESULT«any(Bool::True, Bool::False)»

[02:47] <dwhipp> rakudo: say "true" if 10 < 5|25 < 20

[02:47] <p6eval> rakudo 34401: OUTPUT«true␤»

[02:47] <dwhipp> rakudo: say "false" unless 10 < 5|25 < 20

[02:47] <p6eval> rakudo 34401: RESULT«any(Bool::True, Bool::False)»

[03:11] *** apeiron left
[03:16] <dwhipp> rakudo: sub infix:<%%> { ... }

[03:16] <p6eval> rakudo 34401: OUTPUT«Statement not terminated properly at line 1, near ":<%%> { .."␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[03:16] <dwhipp> pugs: sub infix:<%%> { ... }

[03:16] <p6eval> pugs: RESULT«\sub :(@_) "$_" := "Scalar" #<Scalar:0xb7a500b5>␤          "@_" := "Array" #<Array:0xb7a500bd>␤          "&?ROUTINE" := "Sub" #<Sub:0xb7184961>␤          "&?BLOCK" := "Sub" #<Sub:0xb7184961> {"&infix:%%" := "Sub" #<Sub:0xb653965d>, "$_" := "Scalar" #<Scalar:0xb7a6fb25>␤          ...

[03:17] *** alanhaggai_ joined
[03:31] *** alanhaggai left
[03:36] *** meppuru joined
[03:40] *** Vejeta joined
[03:52] *** meppl left
[03:57] *** azawawi joined
[03:58] *** apeiron joined
[03:59] *** alanhaggai_ is now known as alanhaggai

[04:01] *** elmex_ joined
[04:09] *** azawawi_ left
[04:17] *** elmex left
[04:17] *** elmex_ is now known as elmex

[04:23] *** dwhipp left
[04:26] *** Whiteknight left
[04:27] *** alc joined
[04:29] *** abebae joined
[04:30] *** alester joined
[04:32] *** ChrisDavaz joined
[04:48] *** alc left
[04:53] *** drbean_ joined
[05:05] *** drbean left
[05:10] <meppuru> good night

[05:12] *** meppuru left
[05:18] *** cspencer joined
[06:14] *** abebae left
[06:26] *** cspencer left
[07:28] <slavik> anyone around?

[07:30] <slavik> does Perl6 have SysV IPC?

[07:37] <mberends> There's a new IO subsystem in the pipeline that will also do sockets etc. Timescale unknown.

[07:37] <mberends> pun not intended

[07:38] <slavik> mberends: I am also interested in msq, shm and such

[07:38] <slavik> not just sockets

[07:40] *** tuxdna joined
[07:40] <slavik> I was thinking of using mod_perl as a wrapper for perl6 code and then using fifos to communicate between the two for whatever perl6 needed. like DB connections and such

[07:40] <mberends> I like playing with IPC too. SysV is probably a longer way away. First Parrot needs to get there, then Rakudo.

[07:41] <slavik> mberends: but what about NCI bindings?

[07:42] <slavik> can't parrot langs just use NCI bindings to the C library for IPC and such?

[07:43] <mberends> recently I read something here about NCI being tricky.

[07:43] <slavik> oh ...

[07:43] <mberends> sorry

[07:44] <slavik> hmm, there is no threading in perl6, is there?

[07:44] <mberends> the November wiki engine has a CGI style interface to a webserver

[07:45] <mberends> no I don't think threading is available either

[07:46] <slavik> I am waiting for mod_parrot/mod_perl6 ...

[07:46] <mberends> cool, it will be great to run Perl 6 based web servers

[07:47] <slavik> it's being worked on, but so far, apache fails to load it due to null PMC access or something like that

[07:48] <mberends> null PMC access can mean any of hundreds of possible problems

[07:48] <slavik> so I've been told

[07:48] <slavik> :(

[07:49] <mberends> did you ever try Perl 5 HTTP::Daemon?

[07:49] <mberends> it should be possible to emulate that in Rakudo with the help of netcat (nc)

[07:50] <mberends> also what November does, but with netcat as a primitive webserver

[07:51] <slavik> mberends: the biggest issue is not running perl6 code, because then, you could have a simple perl5/php wrapper to just run the specified perl6 code through rakudo and make it look like perl6 code with mod-rewrite

[07:51] <mberends> yes, you really want tighter integration

[07:52] <mberends> me, I'm happy if Perl 6 is doing the application work, regardless of the plumbing

[07:53] <slavik> so that when /index.p6 is requested, the actual page to load will be: /index.php?file=index.p6 and index.php will simply be something like <? print `perl6 $DocumentRoot/index.p6` ?> or something like that

[07:53] <slavik> right

[07:53] <slavik> mberends: is there a DBI in Perl6?

[07:54] <mberends> there is only a MySQL driver, but it does SELECT, INSERT etc

[07:54] <slavik> does it do update?

[07:55] <slavik> mberends: I am not looking for advanced things for DB, just simple stuff that a web site might need

[07:55] <slavik> I want to build a wordpress that does not suck

[07:55] <slavik> in perl6

[07:55] <mberends> it's probably workable, but I never looked closely enough

[08:06] <slavik> hmm, I only see postgre pbc/pir ...

[08:06] <slavik> that's ok, too I guess

[08:06] *** araujo left
[08:09] <mberends> see parrot/examples/nci/mysqltest.p6 and parrot/ext/SQLite3/DBDI/Driver/SQLite3.pm

[08:10] <slavik> neat, ty

[08:11] <mberends> the MySQL code looks less complete than the SQLite stuff

[08:11] <slavik> k

[08:12] <slavik> it will probably be good by the time mod_perl6 is ready ;)

[08:12] <mberends> definitely

[08:16] *** vixey joined
[08:32] <slavik> someone just tried to use re to parse Xorgconf ... naturally, I unleassed a P6 grammar on them

[08:32] <slavik> unleashed*

[08:36] *** dukeleto joined
[08:42] <slavik> http://opensource.nokia.com/projects/symbian-perl/index.html

[08:45] <mberends> interesting, I use a 9300i Communicator. The Development Perl is 5.9 though...

[08:46] *** dukeleto_ left
[08:46] <slavik> 5.9 is good enough ...

[08:46] <slavik> wow 9300i, that's old

[08:47] <slavik> I got the e90 :D

[08:47] <slavik> http://opensource.nokia.com/projects/PAMP

[08:47] <slavik> WOAH!!!

[08:48] <slavik> apache, mysql and php on the communicator

[08:48] *** azawawi_ joined
[08:49] <slavik> bitchin' :)

[08:49] * mberends impressed

[08:50] *** barney joined
[08:56] *** dukeleto left
[08:58] *** justatheory joined
[08:58] *** dukeleto joined
[09:01] *** azawawi left
[09:01] *** azawawi_ is now known as azawawi

[09:06] *** iblechbot left
[09:15] *** slavik left
[09:21] *** dukeleto_ joined
[09:33] *** dukeleto left
[09:37] *** dukeleto joined
[09:42] *** dukeleto left
[09:48] *** dukeleto joined
[09:48] *** dukeleto_ left
[10:09] *** azawawi left
[10:10] *** dukeleto_ joined
[10:10] *** dukeleto left
[10:20] *** justatheory left
[10:26] *** masak joined
[10:35] *** dukeleto joined
[10:42] <masak> @tell TimToady in case I understood you correctly and prefix:<*> is a fossil, and you're thinking of removing it, I've found occurences at S02:780, S03:259 and S13:50

[10:42] <lambdabot> Consider it noted.

[10:43] <masak> @ask TimToady do Rats have introspection methods? do rules and grammars?

[10:43] <lambdabot> Consider it noted.

[10:44] <masak> @ask S02:1885 says `system "greet";` -- shouldn't that be `run "greet";`?

[10:44] <lambdabot> Consider it noted.

[10:44] *** Grrrr joined
[10:45] *** dukeleto_ left
[10:47] <literal> I hope you're not expecting lambdabot to deliver a message to S02:1885 :)

[10:47] <masak> literal: S02:1885 is a very old friend of mine.

[10:48] <masak> @ask TimToady S02:1885 says `system "greet";` -- shouldn't that be `run "greet";`?

[10:48] <lambdabot> Consider it noted.

[10:48] <masak> literal: thanks. :P

[10:50] *** ilogger2 joined
[10:52] <masak> I read through all the synopses tonight, looking for omissions in S29.

[10:52] <masak> now I have a long list.

[10:52] <masak> should I (1) nopaste it here so that people can comment on it, (2) ask the questions one by one, or (3) blog about it?

[10:52] <masak> &

[10:56] *** alanhaggai_ joined
[10:57] *** Grrrr joined
[10:59] *** iblechbot joined
[11:26] *** alanhaggai_ left
[11:37] *** alanhaggai joined
[11:53] <pugs_svn> r24643 | ruoso++ | [mildew] support for CALLER pseudo-package using a "flattened lexical scope" that turns postcircumfix:{ } into lookup (Implementing MY:: should be dead-easy now).

[11:53] <pugs_svn> r24643 | ruoso++ | [smop] mold frame now has .lexical that stores the lexical scope for that frame.

[11:53] <pugs_svn> r24643 | ruoso++ | [smop] s1p_code sets the lexical scope in the frame.

[11:53] <pugs_svn> r24643 | ruoso++ | [smop] s1p_flattenedscope implements postcircumfix:{ } by calling lookup in the proxied scope

[11:58] <pugs_svn> r24644 | ruoso++ | [mildew] return_function.t shows how the "return" function willbe implemented, and it is implemented in Perl 6 ;).

[11:58] <pugs_svn> r24644 | ruoso++ | [mildew] add a test for CALLER::<> and MY::<>

[11:58] <pugs_svn> r24644 | ruoso++ | [mildew] support MY::<>

[11:59] <ruoso> the return function almost works in mildew, it is getting out of the correct routine, it is not yet setting the return value correctly...

[12:00] <ruoso> look into v6/mildew/t/return_function.t 

[12:03] *** pmurias joined
[12:03] <ruoso> hi pmurias 

[12:05] <pmurias> ruoso: hi

[12:05] <ruoso> good news, we have a return function ;)

[12:05] <ruoso> it's almost working

[12:06] *** azawawi joined
[12:06] *** alanhaggai_ joined
[12:06] <azawawi> hi

[12:06] <ruoso> hi azawawi 

[12:07] <pmurias> ruoso: is return a function?

[12:07] <ruoso> a sub, actually

[12:07] <ruoso> but I think it is the same thing

[12:10] *** alanhaggai left
[12:10] <pmurias> perl6: say &return

[12:10] <p6eval> elf 24644: OUTPUT«/home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.rb:141:in `block in to_dump0': undefined method `to_dump0' for true:TrueClass (NoMethodError)␤     from /home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.rb:140:in `each'␤        from

[12:10] <p6eval> ../home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.r...

[12:10] <p6eval> ..rakudo 34420: OUTPUT«return␤»

[12:10] <p6eval> ..pugs: OUTPUT«<SubPrim(return)>␤»

[12:10] <pmurias> perl6: say &say

[12:10] <p6eval> elf 24644: OUTPUT«/home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.rb:141:in `block in to_dump0': undefined method `to_dump0' for true:TrueClass (NoMethodError)␤     from /home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.rb:140:in `each'␤        from

[12:10] <p6eval> ../home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.r...

[12:10] <p6eval> ..rakudo 34420: OUTPUT«say␤»

[12:10] <p6eval> ..pugs: OUTPUT«<SubPrim(say)>␤»

[12:10] <pmurias> perl6: say &no_such

[12:10] <p6eval> elf 24644: OUTPUT«/home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.rb:141:in `block in to_dump0': undefined method `to_dump0' for true:TrueClass (NoMethodError)␤     from /home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.rb:140:in `each'␤        from

[12:10] <p6eval> ../home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.r...

[12:10] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected end of input␤    expecting "::" or signature value␤    Variable "&no_such" requires predeclaration or explicit package name␤    at /tmp/MoMrARxOKr line 1, column 13␤»

[12:10] <p6eval> ..rakudo 34420: OUTPUT«␤»

[12:11] <azawawi> quick question, what's a good module name that converts Arabic to Arabish (i.e. sms chat arabic)?

[12:12] <ruoso> now we have another hard issue to solve...

[12:13] <pmurias> yes...

[12:13] <ruoso> I think the spec says a capture in item context returns the invocant

[12:14] <ruoso> but that doesn't fit very well with the return function...

[12:14] <pmurias> $$capture?

[12:14] <ruoso> yes\

[12:14] *** jiing_ joined
[12:14] <ruoso> rakudo: sub foo { return 1 }; my @a = foo; say @a.perl;

[12:14] <p6eval> rakudo 34420: OUTPUT«[1]␤»

[12:15] <ruoso> rakudo: sub foo { return 1,2 }; my @a = foo; say @a.perl;

[12:15] <p6eval> rakudo 34420: OUTPUT«too many arguments passed (2) - at most 1 params expected␤current instr.: 'return' pc 14386 (src/builtins/control.pir:29)␤»

[12:15] <ruoso> pugs: sub foo { return 1,2 }; my @a = foo; say @a.perl;

[12:15] <p6eval> pugs: OUTPUT«\(1, 2)␤»

[12:16] <ruoso> it seems that both pugs and rakudo doesn't have that well solved also

[12:17] <ruoso> pugs: sub foo { return 1,2 }; my $a = foo; say $a.perl;

[12:17] <p6eval> pugs: OUTPUT«\\(1, 2)␤»

[12:17] <pmurias> ruoso: the capture can't change in item context otherwise you wouldn't be able to store it easily

[12:18] <ruoso> actually, if we don't BIND it, there's no problem

[12:18] <ruoso> because it will be safe inside a scalar

[12:18] <pmurias> $foo = \(1,2,3); # the capture it's in item context here

[12:18] <ruoso> hmm... indeed

[12:18] <ruoso> maybe the \ operator already jails it inside a scalar?

[12:19] <ruoso> and the | operator takes it out

[12:27] <pmurias> maybe

[12:29] <ruoso> is there some spec on how this should be made?

[12:29] <ruoso> I mean

[12:29] <ruoso> my $a = sub { return 1,2 }.()

[12:29] <ruoso> my @a = sub { return 1,2 }.()

[12:29] <ruoso> my @a = sub { return 1 }.()

[12:29] <ruoso> my $a = sub { return 1 }.()

[12:31] <pmurias> i'm in p5 interop mode today so the fine points of p6 escape me ;)

[12:32] <ruoso> TimToady, what should the above result?

[12:33] <vixey> perl6: ().()

[12:33] <p6eval> rakudo 34420: OUTPUT«invoke() not implemented in class 'ResizablePMCArray'␤current instr.: '_block14' pc 61 (EVAL_15:37)␤»

[12:33] <p6eval> ..elf 24644: OUTPUT«Use of uninitialized value in subroutine entry at (eval 115) line 3.␤Can't use string ("") as a subroutine ref while "strict refs" in use at (eval 115) line 3.␤ at ./elf_f line 3861␤»

[12:33] <p6eval> ..pugs: OUTPUT«*** Cannot cast from VList [] to Pugs.AST.Types.VCode (VCode)␤    at /tmp/QXdF09T87O line 1, column 1 - line 2, column 1␤»

[12:36] *** icwiener joined
[12:36] <pmurias> lunch with grandparents&

[12:36] *** pmurias left
[12:47] *** azawawi left
[12:49] *** lichtkind joined
[12:58] *** dukeleto_ joined
[12:59] *** ejs joined
[12:59] *** c9s joined
[13:05] *** alanhaggai_ is now known as alanhaggai

[13:20] * ruoso just sent a mail to p6-language about the return issue

[13:24] *** dukeleto_ left
[13:26] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; while ($word ~~ /<$letter>/) { $guess[$/.start] = $letter}; say $guess;

[13:26] <p6eval> rakudo 34420: OUTPUT«Statement not terminated properly at line 1, near "~~ /<$lett"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[13:27] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; while ($word ~~ /<$letter>/) { $guess[$/.start] = $letter}; say $guess;

[13:27] <p6eval> rakudo 34420: OUTPUT«Statement not terminated properly at line 1, near "~~ /<$lett"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[13:27] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; while ($word ~~ /$letter/) { $guess[$/.start] = $letter}; say $guess;

[13:27] <p6eval> rakudo 34420: OUTPUT«Null PMC access in get_string()␤current instr.: '' pc 342 (EVAL_13:139)␤»

[13:27] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; while ($word ~~ /$letter/) { $guess.substr($/.start) = $letter}; say $guess;

[13:27] <p6eval> rakudo 34420: OUTPUT«Null PMC access in get_string()␤current instr.: '' pc 342 (EVAL_13:139)␤»

[13:28] <ruoso> pugs: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; while ($word ~~ /$letter/) { $guess.substr($/.start) = $letter}; say $guess;

[13:28] <p6eval> pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/evalenv/pugs/perl5/Pugs-Compiler-Rule/lib';␤    unshift @INC, '/home/evalenv/pugs/third-party/Parse-Yapp/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runti...

[13:28] <ruoso> pugs: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; while ($word ~~ /<$letter>/) { $guess.substr($/.start) = $letter}; say $guess;

[13:28] <p6eval> pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/evalenv/pugs/perl5/Pugs-Compiler-Rule/lib';␤    unshift @INC, '/home/evalenv/pugs/third-party/Parse-Yapp/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runti...

[13:28] <ruoso> hmpf

[13:28] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; while ($word ~~ /a/) { $guess.substr($/.start) = $letter}; say $guess;

[13:28] <p6eval> rakudo 34420: OUTPUT«Method 'start' not found for invocant of class 'Match'␤current instr.: '_block30' pc 387 (EVAL_13:161)␤»

[13:28] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; while ($word ~~ /a/) { $guess.substr($/.pos) = $letter}; say $guess;

[13:28] <p6eval> rakudo 34420: OUTPUT«Method 'pos' not found for invocant of class 'Match'␤current instr.: '_block30' pc 387 (EVAL_13:161)␤»

[13:29] *** dukeleto joined
[13:30] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; while ($word ~~ /a/) { $guess.substr($/.from) = $letter}; say $guess;

[13:30] <p6eval> rakudo 34422: No output (you need to produce output to STDOUT)

[13:31] <ruoso> I guess using the match in the while still doesn't provide the desired outcome

[13:31] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; $word ~~ /a/; $guess.substr($/.from) = $letter; say $guess;

[13:31] <p6eval> rakudo 34422: OUTPUT«??????␤»

[13:31] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; $word ~~ /a/; $guess[$/.from] = $letter; say $guess;

[13:31] <p6eval> rakudo 34422: OUTPUT«Method 'postcircumfix:[ ]' not found for invocant of class 'Str'␤current instr.: 'postcircumfix:[ ]' pc 1600 (src/classes/Positional.pir:85)␤»

[13:31] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; $word ~~ /a/; $guess.substr($/.from, 1, $letter); say $guess;

[13:31] <p6eval> rakudo 34422: OUTPUT«too many arguments passed (4) - at most 3 params expected␤current instr.: 'parrot;Any;substr' pc 11730 (src/builtins/any-str.pir:534)␤»

[13:32] <ruoso> rakudo: my $word = 'banana'; my $guess = '??????'; my $letter = 'a'; $word ~~ /a/; $guess.substr($/.from, $letter); say $guess;

[13:32] <p6eval> rakudo 34422: OUTPUT«??????␤»

[13:32] <ruoso> rakudo: my $word = 'banana'; my @guess = <? ? ? ? ? ?>; my $letter = 'a'; $word ~~ /a/; @guess[$/.from] = $letter; say $guess;

[13:32] <p6eval> rakudo 34422: OUTPUT«Scope not found for PAST::Var '$guess'␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[13:32] <ruoso> rakudo: my $word = 'banana'; my @guess = <? ? ? ? ? ?>; my $letter = 'a'; $word ~~ /a/; @guess[$/.from] = $letter; say @guess;

[13:32] <p6eval> rakudo 34422: OUTPUT«?a????␤»

[13:33] *** alanhaggai_ joined
[13:35] <ruoso> rakudo: my $word = 'banana'; my $guess = <? ? ? ? ? ?>; my $letter = 'a'; while ($word ~~ /a/ :global) { $guess.substr($/.from) = $letter}; say $guess;

[13:35] <p6eval> rakudo 34422: OUTPUT«Statement not terminated properly at line 1, near ":global) {"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[13:36] <ruoso> rakudo: my $word = 'banana'; my $guess = <? ? ? ? ? ?>; my $letter = 'a'; while ($word ~~ m:g/a/) { $guess.substr($/.from) = $letter}; say $guess;

[13:36] <p6eval> rakudo 34422: OUTPUT«Statement not terminated properly at line 1, near "a/) { $gue"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[13:36] *** alanhaggai left
[13:36] *** alanhaggai_ is now known as alanhaggai

[13:36] *** cookys joined
[13:37] *** kisu_ joined
[13:39] <ruoso> does rakudo support regex modifiers?

[13:40] *** dukeleto_ joined
[13:48] *** dukeleto left
[13:56] *** aindilis joined
[13:57] *** DemoFreak joined
[14:02] *** meppl joined
[14:04] *** jan_ joined
[14:06] <masak> rakudo: my $a = 'abc'; substr($a, 1, 1) = 'x'; say $a

[14:06] <p6eval> rakudo 34422: OUTPUT«abc␤»

[14:08] *** justatheory joined
[14:13] *** mberends joined
[14:14] *** Grrrr left
[14:19] <pugs_svn> r24645 | ruoso++ | [smop][mildew] return is taking only the first positional argument at the moment.

[14:22] <mberends> masak, that last substr was pure GWBASIC - how dare you speak that here!

[14:22] <masak> mberends: S29 and some spectests are on my side on that one, I'm afraid.

[14:22] <masak> but Rakudo doesn't implement it yet.

[14:22] <masak> pugs: my $a = 'abc'; substr($a, 1, 1) = 'x'; say $a

[14:22] <p6eval> pugs: OUTPUT«axc␤»

[14:22] <masak> Pugs does.

[14:23] <mberends> ;-)

[14:24] <mberends> btw, it made me cackle to read your script that began 'sub merge'

[14:24] <masak> I've been cackling at that too.

[14:24] <masak> though it was quite unintentional, I swear.

[14:25] <masak> mberends: did you experience any segfaults when you ran the program?

[14:25] *** pmurias joined
[14:26] <mberends> yes, you mean just ^D to an input prompt?

[14:26] *** alanhaggai left
[14:26] <masak> for example, yes.

[14:26] <masak> actually finishing a game sets it off too.

[14:26] <mberends> I think exit() is broken. I hit that problem elsewhere.

[14:27] <masak> yes, I have an RT ticket about that somewhere.

[14:27] <mberends> try perl6 -e'exit(0)'

[14:27] <masak> works fine.

[14:28] <pugs_svn> r24646 | ruoso++ | [mildew] support (|$capture) in a signature, this means return is now returning a capture, so we are depending on the issue posted on p6-language to proceed 

[14:29] <masak> ah, #57330

[14:29] <mberends> exit() has segfaulted here on Debian amd64 for quite some time

[14:30] <masak> mberends: have you reported it to rakudobug?

[14:31] <mberends> sorry, no

[14:32] <masak> please do. :) the devs love to hear about segfaults.

[14:32] *** ejs left
[14:33] <mberends> ok, later today, when full attention span available

[14:33] *** ejs joined
[14:33] <masak> mberends: sure, no rush.

[14:34] <mberends> later will also be able to try druid game a few more times

[14:35] <masak> \o/

[14:36] <masak> I should work on that P2P feature, then :)

[14:36] <mberends> really? with UDP or TCP?

[14:37] <masak> a bit more lo-tek than that. my current plan is to imitate git's SHA1 hashes, where a druid game state corresponds to a git commit

[14:38] <mberends> heh

[14:38] <masak> all the player's ongoing games would reside in a ~/.druid file

[14:38] <masak> I don't know if it's such a good idea, but I thought I'd try ;)

[14:39] <mberends> nice, when you have neurons and hertz to burn..

[14:40] <masak> well, it is Christmas, after all ;)

[14:40] <mberends> therefore calories to burn as well..

[14:48] *** riffraff joined
[14:56] *** abebae joined
[14:56] *** Grrrr joined
[15:00] <pugs_svn> r24647 | ruoso++ | [mildew] signature still BIND values for now...

[15:00] <pugs_svn> r24647 | ruoso++ | [smop] mold debug prints the pointer of the frame, so we know when it is recursing...

[15:00] <pugs_svn> r24647 | ruoso++ | [smop] native capture implements (partially) the coercion to item context as in the p6-language post

[15:03] *** c9s left
[15:03] *** c9s joined
[15:03] *** c9s left
[15:03] *** c9s joined
[15:03] *** c9s left
[15:03] *** c9s joined
[15:05] *** alanhaggai joined
[15:17] <pugs_svn> r24648 | pmurias++ | [smop] calling arbitary methods on SV* works, added SV*.int

[15:17] <pmurias> moritz_: ping

[15:20] *** rff joined
[15:23] <pmurias> @tell moritz_ i changed smop to use cmake instead of scons, and so we need scons in the chroot for the smop evalbot to work

[15:23] <lambdabot> Consider it noted.

[15:28] <barney> did you mean:  scons instead of cmake ?

[15:30] *** abebae left
[15:31] *** riffraff left
[15:32] <pmurias> barney: yes

[15:32] *** dukeleto_ left
[15:33] *** dukeleto joined
[15:35] <pmurias> mildew: $OUT.print("hi")

[15:35] <p6eval> mildew: OUTPUT«Use of uninitialized value $output in concatenation (.) or string at mildew line 628.␤output= too many arguments --exec --file /tmp/5Lf3TQu3LD at mildew line 628.␤»

[15:39] <pugs_svn> r24649 | pmurias++ | [evalbot] update the way mildew is invoked

[15:40] <pmurias> evalbot control restart

[15:40] <pmurias> mildew: $OUT.print("hi")

[15:40] *** p6eval joined
[15:40] <pmurias> mildew: $OUT.print("hi")

[15:40] <p6eval> mildew: No output (you need to produce output to STDOUT)

[15:41] *** dukeleto left
[15:41] <pmurias> mildew: $OUT.print("hi")

[15:41] <p6eval> mildew: No output (you need to produce output to STDOUT)

[15:43] <pmurias> mildew: $OUT.print("hi")

[15:43] <p6eval> mildew: No output (you need to produce output to STDOUT)

[15:44] *** dukeleto joined
[15:58] <masak> @ask TimToady is .as still a part of Perl 6, or is the usage at S02:707 a fossil?

[15:58] <lambdabot> Consider it noted.

[16:00] *** jhorwitz joined
[16:03] <pmurias> pmichaud: what happend to the "This week in Perl 6" revival plan?

[16:03] <pmichaud> i got sidetracked :-(

[16:03] <pmichaud> I still need to be doing it, though.

[16:04] <pmichaud> so far I've been more successful at writing code than writing prose

[16:04] <pmichaud> on the whole I prefer that for now.

[16:05] <pmichaud> of course, I'd be very happy if someone else decided to pick it up... :-)

[16:09] *** c9s left
[16:09] *** c9s joined
[16:15] *** alanhaggai_ joined
[16:19] *** cspencer joined
[16:23] *** alanhaggai left
[16:23] *** alanhaggai_ is now known as alanhaggai

[16:30] <pmurias> ruoso: when i load SMOP.pm from P5Interpreter.eval i get:

[16:30] <pmurias> Can't load module SMOP, dynamic loading not available in this perl. (You may need to build a new perl executable which either supports dynamic loading or has the SMOP module statically linked into it.)

[16:31] <ruoso> pmurias, you need to initialize the Dynaloader

[16:31] <ruoso> pmurias, see perldoc perlembed

[16:40] <rakudo_svn> r34428 | pmichaud++ | [rakudo]: spectest-progress.csv update: 264 files, 5905 passing, 0 failing

[16:42] *** alanhaggai_ joined
[16:43] *** rff left
[16:44] *** alanhaggai left
[16:51] <masak> pmichaud: greetings. I've combed through the specs and found omissions in S29. now I have a bigger list than before I lost my laptop. :)

[16:52] <masak> pmurias: but I recall having something on the list that you said about the functions needing to be reorganized the same way as Rakudo's builtins. what was that, more exactly?

[16:53] <masak> sorry, that should be pmurias, no pmurias.

[16:53] <masak> &

[16:57] <pmichaud> masak: (reorganized)  most of the builtins are now methods on Any, instead of methods on List, Str, Num, etc.

[16:58] <pmichaud> as far as where to send the list, my first thought is p6l, but perhaps it would be better to clean them up first.  Discussions on p6l sometimes take odd tangents that don't lead to resolution.

[17:03] *** araujo joined
[17:04] *** alanhaggai_ is now known as alanhaggai

[17:06] *** icwiener left
[17:06] <masak> pmichaud: I've almost cleaned the list up so that I can nopaste it here. I'll do that first, and maybe some things will get resolved immediately.

[17:06] <pmichaud> okay.  I expect to be distracted over the next day or so, as I'm working on a major refactor of Rakudo's parameter and variable handling

[17:07] <masak> basically, I have two types of question: 'should X be in S29' and, 'is this right?'

[17:07] <masak> pmichaud++

[17:07] <masak> pmichaud: good luck with that. looking forward to the result.

[17:07] <pmichaud> yes.  We've been needing the refactor for about seven months, and more crufty code keeps being layered on top of the existing code.

[17:08] <masak> I like the fact that you care about code purity.

[17:08] <pmichaud> if we don't, then it becomes a house of cards that becomes unmaintainable.  See also:  Parrot.

[17:08] <masak> makes it less likely that Rakudo will paint itself into a corner somehow.

[17:08] <masak> aye.

[17:16] <masak> one example of an 'is this right?' question, is: 'Does everything have .print and .say methods? Where is this documented?'

[17:17] <cspencer> pmichaud: for Ranges created as in: 1..100:by(2), will the :by(2) Pair eventually be passed into the range creation operators as an optional parameter?

[17:18] *** Matt-W joined
[17:19] <pmichaud> yes.

[17:19] <pmichaud> masak: I think .print and .say are also defined on Any.  Perhaps Object.

[17:19] <cspencer> i'm just updating one of the range patches i'd submitted earlier, can i stub the :by semantics in as well?

[17:20] <pmichaud> sure.

[17:20] <cspencer> ok

[17:20] <cspencer> thanks!

[17:20] <Matt-W> I've been experimenting with Rakudo the last few days. Generally quite impressed with how much works.

[17:21] <Matt-W> So well done

[17:21] <pmichaud> thanks!

[17:21] <masak> pmichaud: about most things moving to Any: how does that affect S29? the methods in src/builtins/ are still divided according to the class they are most commonly associated with; it's easier to find things that way. this indicates that the sections (List/Hash/Str etc) in S29 should perhaps remain as they are. but maybe signatures need changing?

[17:21] <Matt-W> It is doing some frustrating things though

[17:22] <pmichaud> masak: I agree with keeping things in sections -- that's how Rakudo organizes the source also.  We have  src/builtins/any-{list|num|str}.pir   for the various methods.

[17:22] <masak> pmichaud: exactly. that's what I was referring to.

[17:23] <cspencer> matt-w: what kind of frustrating things have you noticed? :)

[17:24] <Matt-W> cspencer: sometimes when I try and call a method of an object, or access an attribute from within one of its methods, it starts complaining that it's not defined for invocants of type X, where X has so far been Failure and PGE::Match, neither of which make any sense

[17:24] <masak> are 'use' and 'require' keywords (as opposed to builtin functions)? do they belong in S29?

[17:24] <pmichaud> they're keywords.

[17:25] <pmichaud> at least, statement_control:use and package_declarator:require

[17:25] <masak> ok.

[17:25] <masak> I'll leave them out for now.

[17:26] <pmichaud> Matt-W: "Failure" usually indicates an uninitialized object of some sort.

[17:26] *** DemoFreak left
[17:26] <pmichaud> Matt-W: "PGE::Match" means that we haven't completely mapped match objects into Rakudo yet.  Although I thought I took care of most of them a couple of days ago.

[17:26] *** DemoFreak joined
[17:26] <Matt-W> I just did an svn update, building it to see if it makes any difference

[17:26] <pmichaud> Best way to get them fixed is to report them as bugs:  [email@hidden.address]  :-)

[17:26] <masak> it'd be a nice thing to have a script that extracted things from S29 à la 'perldoc -f' -- hence my question. 'perldoc -f use' does give a summary.

[17:27] <Matt-W> What I should do is boil it down to a shorter bit of code that exhibits the problem

[17:27] <Matt-W> Because I can't see how what I'm doing is wrong, so I do think it is a bug

[17:27] <pmichaud> masak: hopefully we can do that when we get a little closer to Prelude.  That's one of the driving reasons for me doing today's variable refactor.

[17:27] <pmichaud> Matt-W: you can also nopaste it here

[17:27] <masak> pmichaud: ah, goodie.

[17:29] <masak> already now I feel the need to visualise S29 somehow, to get an overview of what it actually contains. if I find the inspiration to write a script that summarizes S29, I might drop it in util/ in the Pugs repo.

[17:29] <cspencer> will :by($x) always assume that $x is going to be a integral step (or numeric even)?  

[17:29] <pmichaud> cspencer: I don't know.

[17:29] <cspencer> ie) is ('A'..'Z'):by('A') illegal?

[17:29] <cspencer> hmm

[17:29] <cspencer> ok

[17:29] <pmichaud> cspencer: in general it's a little dangerous to assume things are integers in Perl 6.  :-)

[17:29] <cspencer> heh

[17:29] <masak> another question: do junction objects have a .values method? where is this specced? do they have other methods?

[17:30] <pmichaud> masak: this has been a point of discussion recently.

[17:30] <masak> cspencer: I'd say it's illegal :)

[17:30] <masak> pmichaud: I guessed as much.

[17:30] <cspencer> perhaps i'll just stub them in as Num's then

[17:31] <masak> pmichaud: I wouldn't be surprised if they turned out to have all of .values, .keys, and .kv -- that'd at least be consistent.

[17:31] <pmichaud> masak: that would surprise me very much for Junction.

[17:31] <masak> pmichaud: that is, they're a kind of collection.

[17:31] <pmichaud> but they're not.

[17:31] <Matt-W> I'm not sure .keys means anything for a junction

[17:31] <Matt-W> they just have values in them don't they?

[17:31] <masak> Matt-W: hm, that's true. they're not ordered.

[17:31] <pmichaud> my $a = any( \@a, \@b );   $a.values   # should be a junction of the values of @a and @b

[17:32] <masak> does Set have all of .keys, .values and .kv?

[17:32] <pmichaud> in general, methods autothread over the values within the Junction.  So I'd expect .keys, .kv, etc to do the same.

[17:32] <masak> but not .values?

[17:32] <pmichaud> and .values, too.

[17:32] <pmichaud> (more)

[17:33] <masak> ok

[17:33] <Matt-W> Can I specify how to stringify my own classes in Rakudo yet?

[17:33] <masak> Matt-W: yes. just provide a Str method.

[17:33] <pmichaud> The latest proposal among the design team was that Junctions have a .eigenstates method to return the components of the Junction as a list

[17:33] <Matt-W> masak: excellent. Thanks.

[17:33] <masak> pmichaud: oh, that's what the .eigenmumble thing was all about.

[17:34] <pmichaud> right.

[17:34] <pmichaud> so, this is what Rakudo implements at themoment.

[17:34] <pmichaud> but as yet I haven't seen any "official" declaration of it at the moment.  I do know that in general treating Junctions like lists is incorrect.

[17:34] *** Grrrr left
[17:35] *** Grrrr joined
[17:35] <masak> this is what makes S29 work hard. :) things need to be condensed from traces of discussions and hints.

[17:35] <ruoso> rakudo: sub foo { return 1,2 }; my $a = foo(); say $a.perl

[17:35] <p6eval> rakudo 34430: OUTPUT«too many arguments passed (2) - at most 1 params expected␤current instr.: 'return' pc 14386 (src/builtins/control.pir:29)␤»

[17:35] <pmichaud> rakudo doesn't support returning lists yet.

[17:36] <ruoso> do you plan already how to make it work?

[17:36] <pmichaud> it'll just package up the arguments into a capture and return that.

[17:36] <ruoso> right... 

[17:37] <ruoso> pmichaud, could you please take a look at a message I've sent today to p6-language about return

[17:37] <ruoso> ?

[17:37] <pmichaud> ruoso: I looked at the message, but I don't have a response.

[17:37] <pmichaud> ruoso: and today is a bad day for me to anything but answer very short questions not requiring design 

[17:38] <Matt-W> oh maybe this is the problem. Are negative array indices implemented yet?

[17:38] <pmichaud> Matt-W: yes,  as  @a[*-1]

[17:38] <ruoso> ok... I think I'll just implement as I think it should be and refactor later if that's not the case...

[17:38] <ruoso> pmichaud, thanks anyway

[17:38] <Matt-W> pmichaud: oh the * is new then. I didn't know about that.

[17:38] <masak> Matt-W: the negative array indices mean something else. see S09.

[17:38] <pmichaud> ruoso: the question you gave in your message are the same questions I've had about captures.

[17:39] <Matt-W> aww now it says null PMC access. Hmm.

[17:39] <Matt-W> masak: I shall go look

[17:39] <ruoso> pmichaud, that's a comforting thought... it's always good to know you're doing the same questions other people is doing...

[17:39] <Matt-W> masak: at one time I knew what was going on in Perl 6 inside out, but I lost track of a lot of it since

[17:40] <masak> Matt-W: know the feeling. :)

[17:41] <Matt-W> aaah so that's what negative indices do now

[17:41] <Matt-W> yes that makes sense

[17:41] <TimToady> Matt-W: do you need a commit bit?

[17:41] <lambdabot> TimToady: You have 10 new messages. '/msg lambdabot @messages' to read them.

[17:43] <pmichaud> TimToady: is there a logical ordering to the rules and tokens in STD.pm ?

[17:43] <Matt-W> TimToady: Perhaps if I identify a problem caused by a bug or a missing feature rather than my lacking knowledge of Perl 6

[17:43] <pmichaud> (or a general principle that it follows?)

[17:43] <TimToady> heh, <lambdabot> Plugin `tell' failed with: thread killed

[17:43] <cspencer> timtoady: on the subject of commit bits, i got a pugs svn bit the other day, but my svn username was entered as 'cspenSer' as opposed to 'cspenCer'.  is that easily fixable?

[17:44] <TimToady> hmm

[17:45] <TimToady> pmichaud: not really, other than similar things go close, and ops are in prec order

[17:46] <pmichaud> TimToady: okay, thanks.

[17:47] <masak> TimToady: I had a few spec questions. did they get lost in the threadkill?

[17:47] <ruoso> hi TimToady, I have more hard questions for you ;)

[17:48] <masak> rule #3 in language design: everybody wants Larry.

[17:48] <TimToady> cspencer: not sure.  can try issuing commitbit under other name and see what it says, or maybe there some way you can fix it

[17:49] <Matt-W> pmichaud: I get null PMC every time I try to use [*-1] on an array which is an attribute of an object. Is this expected?

[17:49] *** alester joined
[17:49] <cspencer> timtoady: i've looked through all the web interface options provided to me, but haven't seen anything i can do.  a reissue might be the easiest way, when you get a chance :)

[17:49] *** alanhaggai_ joined
[17:49] <pmichaud> Matt-W: it wouldn't surprise me -- I don't know how well object attributes support arrays yet.

[17:50] <TimToady> I've tried a reissue, but it didn't show up in the list as pending, so I dunno...

[17:50] <pmichaud> Matt-W: object attributes are mostly jnthn++'s doing

[17:50] <cspencer> timtoady: got it, thank you!

[17:50] <TimToady> masak: I backlog

[17:50] <masak> rakudo: class A { has @.foo is rw }; my $a = A.new; $a.foo = 1,2,3; say $a.foo[*-1]

[17:50] <masak> TimToady++

[17:50] <p6eval> rakudo 34432: OUTPUT«3␤»

[17:50] <Matt-W> pmichaud: I might see if I can make sense of any of the code for it, I've not got anything else much to do this evening

[17:50] <masak> Matt-W: worksforme.

[17:50] <Matt-W> masak: hmm

[17:51] <jnthn> Matt-W: What doesn't work?

[17:51] <Matt-W> I've got a test case, I'll put it up...

[17:51] <jnthn> It's possible it is something that didn't work in the first place, or something that came up in postcircumfix changes and we didn't have tests to identify...

[17:53] <pasteling> "Matt-W" at 81.101.136.8 pasted "Object attribute arrays and negative indices" (15 lines, 276B) at http://sial.org/pbot/34079

[17:53] *** alanhaggai left
[17:53] <Matt-W> I'm using a Rakudo I updated from svn about half an hour ago

[17:54] <masak> Matt-W: should be recent enough :)

[17:54] *** DemoFreak left
[17:54] <Matt-W> It works, by the way, when the array is not part of an object

[17:54] *** DemoFreak joined
[17:54] <masak> rakudo: class A { has @.foo; method bar { @.foo[0] = "Hey" } }; A.new.bar

[17:54] <p6eval> rakudo 34432: RESULT«"Hey"»

[17:55] <masak> rakudo: class A { has @.foo; method bar { @.foo[0] = "Hey"; say @.foo[*-1] } }; A.new.bar

[17:55] <p6eval> rakudo 34432: OUTPUT«Null PMC access in find_method()␤current instr.: 'parrot;A;_block40' pc 446 (EVAL_13:170)␤»

[17:55] <masak> there it is.

[17:55] <Matt-W> yup

[17:55] <Matt-W> that's exactly it

[17:55] <masak> Matt-W: will you submit to rakudobug, or shall I?

[17:56] * pmichaud guesses there's an issue with the @.foo accessor.

[17:56] <Matt-W> If someone can point me at some guidelines for a suitable submission I'll do it

[17:56] <masak> Matt-W: just paste the past minute's discussion to [email@hidden.address]
[17:56] <masak> &

[17:58] <Matt-W> &...?

[17:58] <ruoso> Matt-W, that usually means that he is putting itself into background

[17:58] <ruoso> s/itself/himself/

[17:59] <Matt-W> ah of course, I assumed it was some further instruction from his previous comment

[17:59] <pugs_svn> r24650 | ruoso++ | [smop] native capture returns an array in item context if it 0 or more than one positional arguments... It returns the first positional argument

[17:59] <Matt-W> I should have guessed

[17:59] <ruoso> oh wow... now that was a bad commit message

[18:00] <ruoso> that's what happen when you get up in the middle of the sentence

[18:00] <Matt-W> it's not the best way to stunning sentences...

[18:02] <ruoso> now I just need to figure out why that capture is empty...

[18:25] *** ejs left
[18:28] *** Whiteknight joined
[18:28] *** Psyche^ joined
[18:29] *** alanhaggai__ joined
[18:31] <cspencer> rakudo: min(2, 10).say

[18:31] <p6eval> rakudo 34434: OUTPUT«2␤»

[18:32] <cspencer> rakudo: min(10,2).say

[18:32] <p6eval> rakudo 34434: OUTPUT«2␤»

[18:36] *** ejs joined
[18:44] *** alanhaggai_ left
[18:45] *** Psyche^ is now known as Patterner

[18:48] <cspencer> how can one call the ?? ... !! construct as a function from PIR code?

[18:49] *** meteorjay joined
[18:51] *** araujo left
[18:52] *** alanhaggai joined
[18:55] <cspencer> rakudo: (1..10).reverse.WHAT.say

[18:55] <p6eval> rakudo 34434: OUTPUT«List␤»

[18:56] *** alanhaggai__ left
[18:59] *** aindilis left
[18:59] *** aindilis joined
[19:00] <pugs_svn> r24651 | ruoso++ | [smop] creates the array correctly when coercing capture to item.

[19:00] <pugs_svn> r24651 | ruoso++ | [smop] s1p_array.shift

[19:00] <pugs_svn> r24651 | ruoso++ | [mildew] tests returning one or several items

[19:01] *** DemoFreak left
[19:04] *** ejs left
[19:11] <ruoso> pmurias, now return officially works ;)

[19:12] <pugs_svn> r24652 | ruoso++ | [smop/src-s1p] Return is promoted as part of the src-s1p

[19:14] <ruoso> TimToady, I implemented capture coercion to item as explained in the message I sent today to p6-language. The visible outcome can be seen in v6/mildew/t/return_function.t. When you have some time, could you please take a look at it?

[19:17] *** simcop2387 joined
[19:27] *** vixey joined
[19:32] *** ejs joined
[19:32] *** icwiener joined
[19:38] *** jhorwitz left
[19:43] *** lambdabot joined
[19:46] *** alanhaggai_ joined
[19:47] *** masak joined
[19:50] *** alester left
[19:55] <masak> http://use.perl.org/~masak/journal/38170

[19:59] <cspencer> masak: that looks like a good list

[19:59] <masak> cspencer: thank you. I'm posting it to p6l as we speak.

[19:59] <cspencer> i had a questions about a couple of those items myself, it's nice to have something up and out there though :)

[19:59] <masak> aye.

[19:59] <masak> I'm sure I missed a few things, too.

[20:01] *** alanhaggai left
[20:01] <cspencer> masak: do you know if it's possible to invoke the (...) ?? ... !! operator in PIR?

[20:02] <cspencer> i'm trying to do a "if (cond) return x else return y" without a bunch of goto's

[20:02] <masak> cspencer: interesting question. :) seems to me it ought to be possible.

[20:02] <masak> but I'm no authority on PIR.

[20:02] <cspencer> ah ok :)

[20:02] <cspencer> no prob then, thanks :)

[20:02] <masak> cspencer: try generating some PIR code with `perl6 --target=PIR` and see what you get.

[20:02] <cspencer> i'll help you knock out a couple of the items on your list in the next while too

[20:02] <cspencer> hey, good call, thanks

[20:03] <masak> cspencer++ # help with S29, yay!

[20:07] <cspencer> looks like it gets expanded into an if statement with goto's

[20:07] <masak> perhaps not so surprising. :)

[20:08] <cspencer> not so much, i suppose! :)

[20:08] <cspencer> i'd though there was a shortcut that i'd seen for that a couple month ago, but i was likely imagining things again :)

[20:09] <masak> perl6: my @a = <OH HAI>; say @a[False]; say @a[True]

[20:09] <p6eval> pugs, rakudo 34439: OUTPUT«OH␤HAI␤»

[20:09] <p6eval> ..elf 24652: OUTPUT«Argument "\x{46}\x{61}..." isn't numeric in array element at (eval 119) line 4.␤Argument "\x{54}\x{72}..." isn't numeric in array element at (eval 119) line 5.␤OH␤OH␤»

[20:10] <masak> cspencer: you could always index over a two-element array :)

[20:10] <masak> not that I'd recommend such a thing... but it has the advantage of having no gotos.

[20:11] <cspencer> true enough.  i think in this case, it would probably have more steps to create and initialize the array though :)

[20:11] <cspencer> i'll try to figure something out, this way doesn't seem quite right

[20:12] *** rhr_ joined
[20:14] <pugs_svn> r24653 | ruoso++ | [mildew] the tests for return already cover what the tests in ROADMAP planned;

[20:18] *** ejs left
[20:22] <cspencer> rakudo: ('A' + 1).say

[20:22] <p6eval> rakudo 34441: OUTPUT«1␤»

[20:22] <masak> because 'A' numifies to 0.

[20:22] <cspencer> yep, that's what i figured

[20:23] <cspencer> i'm just working on the Range :by($x)  stuff and i'm wondering about valid increment values

[20:24] <cspencer> ie) 1..100:by(2) makes sense as does 1..100:by(0.5)

[20:24] <masak> cspencer: I've never heard about anyone talk about something other than numbers.

[20:24] <cspencer> but i'm wondering what to do in cases of 'A'..'Z':by(1.5)

[20:24] <cspencer> ok

[20:24] <masak> cspencer: in that latter case, I'd throw a domain exception, or even better, die at compile time.

[20:25] <cspencer> so for non-numeric ranges, force integral increment values?

[20:25] <TimToady> $a..$b:by($c)

[20:27] <cspencer> timtoady: it's safe to assume the $c is going to be numeric?

[20:28] <TimToady> yes, but I could see possible uses for fractional values if we treat 'A'..'Z' as a list to be indexed into by the current numeric value

[20:28] <TimToady> 'A'..'Z':by(.5) ==> AABBCCDDEE...

[20:28] <cspencer> ah ok

[20:29] <cspencer> so we'd use the floor of the increment in that case

[20:29] <TimToady> though I'd not go out of my way to support that

[20:29] <TimToady> since it could be considered Born Obfuscated

[20:29] <cspencer> heh

[20:29] <TimToady> but if it has no other meaning and falls out of the semantics

[20:30] <TimToady> so 'A'..'Z':by(2) would be ACEG...

[20:30] <cspencer> right

[20:30] <TimToady> 'A','C','E'...*   ;)

[20:31] <cspencer> alright, for a non-numeric ranges i'll implement the increments like that for the time being

[20:31] <cspencer> thanks for the clarification :)

[20:31] <TimToady> did the new commitbit help at all?

[20:31] <cspencer> i'll be testing it out shortly when i commit some new tests for ranges :)

[20:32] <TimToady> re $a..$b:by($c), it actually parses wrong, since identifiers can be extended by adverbs

[20:32] <TimToady> so it parses as $a .. ($b:by($c))

[20:32] <TimToady> one would have to say $a..$b :by($c)

[20:33] <cspencer> ah ok, i think i may have seen it referenced as the former somewhere in the docs

[20:33] <cspencer> or i might have misread that, i'll go re-check

[20:34] <cspencer> are all decreasing ranges (ie. 10..1) considered to be null ranges?

[20:34] <TimToady> it works find as long as the final value of the range doesn't end with an identifier

[20:34] <TimToady> yes

[20:34] <TimToady> just as in P5

[20:34] <cspencer> but it's still possible to iterate over a null range?

[20:34] <TimToady> sure, but nothing happens :)

[20:34] <cspencer> ok

[20:35] <cspencer> ah ok

[20:35] <TimToady> you have to have a null range possible from $a..$b and you can't if it autoreverses

[20:36] <cspencer> alright, gotcha, thank you :)

[20:40] <cspencer> is there a test for null ranges?  ie) are they considered defined?  or is there a $r.null method?

[20:40] *** bsdperl joined
[20:43] *** apeiron joined
[20:49] *** aindilis` joined
[20:50] *** aindilis left
[20:50] *** DemoFreak joined
[20:55] *** justatheory_ joined
[20:55] *** justatheory left
[20:58] *** icwiener left
[20:58] *** DemoFreak left
[21:00] *** simcop2387 left
[21:00] <moritz_> pmurias: ii  scons          1.0.0-1        A replacement for Make

[21:01] *** simcop2387 joined
[21:02] *** icwiener joined
[21:07] <pugs_svn> r24654 | moritz++ | [t/spec] some small test additions and unfudges

[21:08] *** DemoFreak joined
[21:14] <ruoso> is simply a smartmatch sufficient to mark an exception as handled

[21:14] <ruoso> ?

[21:24] *** bsdperl left
[21:24] *** bsdperl joined
[21:26] <pmichaud> cspencer: I'm sure a null range is still defined.

[21:27] <cspencer> how would one test for nullness?

[21:27] <cspencer> aside from iterating over it

[21:27] <pmichaud> don't know off the top of my head.  .elems might be a somewhat imprecise guess.

[21:27] <cspencer> it might not even been an issue, i suppose, i was just wondering :)

[21:44] *** Ehtyar joined
[21:44] *** Tobi joined
[21:47] *** aindilis` left
[21:47] *** aindilis` joined
[21:51] *** perl7 joined
[21:51] *** Tobi left
[21:55] *** justatheory_ left
[22:02] *** dwhipp joined
[22:09] *** mogaal joined
[22:10] *** perl7 left
[22:13] *** alester joined
[22:22] <cspencer> is there a test for number-ness in p6?  ie) such that i can tell if the value in variable $x is an Int/Num/Ratio/Complex etc?

[22:22] *** kisu__ joined
[22:23] <cspencer> or do they share a common parent class?

[22:23] *** eternaleye joined
[22:24] *** vixey left
[22:27] *** kisu_ left
[22:30] <pmichaud> if this is for :by($x), I'd just use whatever numeric value $x happens to give.

[22:30] <pmichaud> I wouldn't try to test it for number-ness.

[22:30] <rakudo_svn> r34453 | pmichaud++ | [rakudo]:  Update grammar to use goal matching syntax.

[22:30] *** pina joined
[22:30] <cspencer> mmm...no i was testing for numeric ranges vs non-numeric ranges, whose :by increments have to be handled differently 

[22:31] <pmichaud> then instead of testing for numberness, I'd check for the non-numeric types.

[22:31] <pmichaud> e.g., Str.

[22:32] <cspencer> is it alright if i create a private !numeric method for the moment and we'll work out the finer details later?

[22:33] <pmichaud> I'd prefer not to do that.

[22:33] <cspencer> ok

[22:33] <cspencer> may i ask why?

[22:33] <pmichaud> again, I'd check for the special case (Str) instead of checking for the normal case (numeric)

[22:33] <cspencer> there could be other special cases, no?

[22:33] <cspencer> such as enums

[22:33] <wolverian> surely this is a generic facility

[22:33] <wolverian> like haskell's Enum type 

[22:33] <wolverian> s,type,typeclass,

[22:34] <pmichaud> enums are just Int or int in the normal case

[22:34] <cspencer> oh ok

[22:34] <wolverian> I'd certainly like to be able to implement ranges for my own types

[22:34] <pmichaud> wolverian: and you certainly can do that.  I'm saying the default shouldn't be doing explicit checks for the default.

[22:35] <wolverian> shouldn't it just be a multimethod, anyway.

[22:35] <pmichaud> yes, probably.

[22:35] <cspencer> i have a feeling i'm complicating things unnecessarily :)

[22:35] <wolverian> then we're in violent agreemet, I think. :)

[22:35] <wolverian> s,met,ment,

[22:35] <pmichaud> and "doing checks for 'is this numeric'" goes against a multimethod approach

[22:36] <pmurias> moritz_: ls

[22:36] <pmurias> ln

[22:36] <pmurias> suck my dick

[22:36] <pmichaud> (violent agreement)  Yes.

[22:37] <pmurias> cs

[22:37] <pmurias> klnhjdslhds

[22:37] <pmurias> sknasoia

[22:37] <pmurias> exit

[22:37] <pmurias> logout

[22:37] <pmurias> '/cvx;l kjldcbjbgvkldf'

[22:37] <pmurias> b ds'

[22:37] <pmurias> bnl

[22:37] <pmurias> bnldfs'a/n\ zd8b. /in

[22:37] <wolverian> uh.

[22:37] <cspencer> i second that uh

[22:38] <wolverian> pmurias needs to lock his session when leaving the computer, I think

[22:39] <wolverian> pmurias, actually, I'm not sure if a multimethod is the best approach. a Range role (or just Enumerable) might be cleaner. I haven't thought about multimethods much yet, so I don't know which one is better architecture.

[22:39] <wolverian> (in this context)

[22:40] <pmichaud> right.  In the meantime, I vote for "simplest implementation that works."  :-)

[22:40] <cspencer> hah, ok, i'll work on that then :)

[22:41] <masak> cspencer: I think I read about ranges and how to check them for emptiness last night. let me check.

[22:42] <masak> cspencer: ah. S03:2818.

[22:43] <cspencer> where 2818 is the line number?

[22:43] <masak> rakudo: my $r = 10..2; say $r.to < $r.from

[22:43] <p6eval> rakudo 34450: OUTPUT«1␤»

[22:43] <masak> cspencer: yes. most of us have the Pugs repo checked out, and refer to the synopses by POD file and line number.

[22:44] <cspencer> great, thanks :)

[22:44] <masak> np :)

[22:44] <masak> rakudo: my $r = 10..2; say .to < .from given $r

[22:44] <p6eval> rakudo 34450: OUTPUT«1␤»

[22:44] * masak loves Perl 6

[22:44] <pmichaud> that assumes a positive :by, yes?

[22:44] <masak> um. yes.

[22:44] <masak> rakudo: my $r = 10..2; say $r.by

[22:44] <p6eval> rakudo 34450: OUTPUT«Method 'by' not found for invocant of class 'Range'␤current instr.: '_block14' pc 99 (EVAL_15:48)␤»

[22:45] <pmichaud> (:by not implemented in Rakudo yet -- that's what cspencer is working on :-)

[22:45] <masak> I don't know how to introspect that on Ranges.

[22:45] <pmichaud> I suspect it will indeed be .by

[22:45] <masak> not specced, if I'm not mistaken.

[22:45] <cspencer> i suppose the issue i'm working around is more dealing with fractional :by increments

[22:45] <cspencer> where fractional increments make sense for numeric types

[22:46] <masak> cspencer: are there tests for this?

[22:46] <cspencer> masak: not yet, no

[22:46] <masak> cspencer: want me to write some for you while you implement? :)

[22:47] <cspencer> but for non-numeric types, the :by uses a floor method (or something similar) for determining the correct element to return

[22:47] <cspencer> masak: that would be great!

[22:47] <cspencer> ie)

[22:47] <cspencer> 'A'..'Z' :by(0.5) would return 'AABBCCDD' as its iterated over

[22:48] <cspencer> hmm...i'll go back and think about this some more

[22:48] <pmichaud> how about 'AA'..'ZZ' :by(0.75) ?

[22:49] <pmichaud> 'AA', 'AA', 'AB', 'AC', 'AD', 'AD', 'AE', ... ?

[22:49] <masak> looks right to me.

[22:49] <cspencer> that looks about right, i think

[22:50] <cspencer> (this is according to TimToady earlier in the day)

[22:50] <pmichaud> so, 'Z'..'A' :by(-0.5) would be  'Z', 'Y', 'Y', 'X', ... , 'B', 'B', 'A', 'A' ?

[22:51] <cspencer> can you iterate like that on null ranges?

[22:51] <pmichaud> ...is that a null range?

[22:51] <cspencer> maybe i'm unclear on the definition of a null range

[22:51] <masak> cspencer: note the negative :by

[22:51] <cspencer> ah

[22:51] <cspencer> gotcha

[22:52] <cspencer> sorry

[22:52] <cspencer> perhaps 'Z', 'Z', 'Y', 'Y'...'Z', 'Z' would be appropriate for that

[22:52] <masak> I've found http://svn.pugscode.org/pugs/t/operators/adverbial_modifiers.t

[22:53] <masak> cspencer: why two 'Z's?

[22:53] <masak> (at the beginning)

[22:54] <masak> I just unconsciously assumed that the chars behaved like truncated integers.

[22:54] <cspencer> one for 'Z' and one for ('Z' - 0.5), no?

[22:54] <masak> cspencer: sure, but to me, 'Z' - 0.5 is 'Y' :)

[22:54] <masak> see 'truncated integers' above.

[22:54] <pmichaud> just like floor(10-0.5) is 9

[22:55] <cspencer> ah, i'm getting all mixed up with negatives and floors and ceil's now

[22:55] <pmichaud> there's also a very interesting issue with ranges, in that I wonder if \x00 .. \xff  does what most people would expect.

[22:55] <cspencer> :)

[22:55] <masak> I'm having trouble seeing anyone using this feature, ever. :P

[22:55] <pmichaud> er.

[22:55] <pmichaud> wait

[22:55] <cspencer> hmmm

[22:55] <pmichaud> '\x00'..'\xff'

[22:56] <masak> pmichaud: that's interesting. non-interpolated string...

[22:56] <pmichaud> oh, I meant interpolating

[22:56] <pmichaud> (too much parrot)

[22:56] <masak> oh.

[22:56] <masak> heh.

[22:56] <pmichaud> although I suspect it might not do what is expected in the non-interpolating case either :-)

[22:56] <pmichaud> "\x00".."\xff"

[22:57] <masak> certainly not. :)

[22:57] <pmichaud> in particular, the successor of "\x39" is not "\x3a"

[22:58] * masak is so happy -- by email, he was just electronically selected on linte to receive the sum of 720,000$ US Dollars through a till-now unheard-of foundation

[22:58] <masak> strangers are so kind.

[22:59] <pmichaud> this comes up to some degree in regexes, too...   <[ \x00 .. \xff ]>

[22:59] <masak> pmichaud: ah, yes. what does \x do again?

[22:59] <pmichaud> well, "\x41"  == 'A'

[22:59] <pmichaud> "\x42" == 'B'

[22:59] <pmichaud> etc.

[23:00] <masak> pmichaud: then wouldn't that interpolation happen first, and the range after?

[23:00] <pmichaud> masak: sure, it would.

[23:00] <masak> then I don't see the problem.

[23:00] <pmichaud> but I'm not sure that the range from codepoint 0 to codepoint 255 includes all of the intermediate codepoints

[23:00] <masak> depends on which result the user expects, of course.

[23:00] *** mberends left
[23:00] <pmichaud> if we define range in terms of succ

[23:00] <masak> pmichaud: why wouldn't it?

[23:00] <pmichaud> for example:

[23:01] <pmichaud> rakudo:  say "\x4a".succ

[23:01] <p6eval> rakudo 34454: OUTPUT«K␤»

[23:01] <pmichaud> er, wrong codepoint

[23:01] <pmichaud> rakudo:  say "\x5a".succ

[23:01] <p6eval> rakudo 34454: OUTPUT«AA␤»

[23:01] <masak> oh!

[23:01] <masak> er.

[23:01] <pmichaud> rakudo:  say "\x5a", ' ', "\x5a".succ

[23:01] <masak> yes, that's a case of "too much magick"

[23:01] <p6eval> rakudo 34454: OUTPUT«Z AA␤»

[23:02] <masak> so "\x00".."\xff" might stop at Z and not go further?

[23:02] <pmichaud> might stop at '9' 

[23:02] <pmichaud> rakudo:  say "\x39".succ

[23:02] <p6eval> rakudo 34454: OUTPUT«10␤»

[23:02] <masak> yes, was going to say that :)

[23:04] <cspencer> sorry, was away from the computer for a bit

[23:05] <cspencer> rakudo: say "\x5a"

[23:05] <p6eval> rakudo 34454: OUTPUT«Z␤»

[23:06] <masak> adverbial_modifiers.t is a bit double-edged... it contains some :by tests, but it also contains a lot of other stuff. seems heavily Pugs-aligned. I'm thinking of adding a new test file in t/spec/ instead.

[23:07] <pmichaud> I'd add :by tests to something dealing with ranges, or a new  range-by.t

[23:07] <cspencer> masak: we also don't have the :by(..) adverbial modifier quite yet, i don't think

[23:07] <masak> cspencer: noted.

[23:07] <masak> pmichaud: I'll check what's appropriate.

[23:08] <pmichaud> I suspect that  Range.new( :from(0), :to:(10), :by(2) )   ought to work at some point.

[23:08] *** dduncan joined
[23:08] <pmichaud> (if it doesn't already.)

[23:08] <masak> ooh.

[23:08] <masak> another test.

[23:08] <cspencer> ah ok, i'll check that, hadn't tried creating it like that

[23:08] *** dduncan left
[23:08] <masak> rakudo: Range.new( :from(0), :to:(10), :by(2) )

[23:08] <pmichaud> rakudo:  say Range.new( :from(0), :to(10), :by(2) );

[23:08] <p6eval> rakudo 34454: OUTPUT«Statement not terminated properly at line 1, near "( :from(0)"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[23:08] <p6eval> rakudo 34454: OUTPUT«You passed an initialization parameter that does not have a matching attribute.␤current instr.: 'die' pc 14740 (src/builtins/control.pir:204)␤»

[23:09] <cspencer> that's probably choking on the :by

[23:09] <masak> though it doesn't say. :)

[23:09] <pmichaud> rakudo:  say Range.new( :from(0), :to(10) );

[23:09] <p6eval> rakudo 34454: OUTPUT«012345678910␤»

[23:09] <pmichaud> good call, cspencer

[23:09] <pmichaud> in which case adding 'by' isn't hard :-)

[23:09] <cspencer> heh, no it's not, i've got that in my version here :)

[23:09] <cspencer> sorry, pointed out the obvious there :)

[23:09] <cspencer> hahah

[23:11] <cspencer> i'm going to leave it as integral :by args for the moment

[23:11] <ruoso> hi pmurias 

[23:12] <masak> cspencer: Merry Christmas! in case I haven't said it already. it's nice to have you with us.

[23:12] <cspencer> masak: thank you!

[23:13] <cspencer> masak: i feel like i've got quite the uphill learning curve to get past, but it's been fun thus far :)

[23:13] <masak> perl6: $str =~ m/bar/ # apparently, there's a 'braino test' in the Pugs test suite

[23:13] <p6eval> pugs: OUTPUT«*** ␤    Unexpected " =~"␤    expecting "::"␤    Variable "$str" requires predeclaration or explicit package name␤    at /tmp/qTlFJdqPqi line 1, column 5␤»

[23:13] <p6eval> ..elf 24654: OUTPUT«Global symbol "$str" requires explicit package name at (eval 115) line 3.␤ at ./elf_f line 3861␤»

[23:13] <p6eval> ..rakudo 34454: OUTPUT«Scope not found for PAST::Var '$str'␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[23:13] <masak> perl6: my $str; $str =~ m/bar/

[23:13] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "m"␤    There is no =~ operator in Perl 6 -- did you mean ~~ (match) or ~= (concat-assign)?␤    at /tmp/E5W1UZyCtB line 1, column 18␤»

[23:13] <p6eval> ..rakudo 34454: RESULT«"_block28"»

[23:13] <p6eval> ..elf 24654: OUTPUT«Use of uninitialized value $str in pattern match (m//) at (eval 115) line 4.␤»

[23:13] <masak> cspencer: I had the same feeling through all of 2005.

[23:14] <masak> cspencer: but then Haskell was involved, so it was even more uphill. :)

[23:14] *** dwhipp left
[23:14] <masak> (never really grokked Haskell, either.)

[23:14] <cspencer> masak: actually, i remember touching on haskell back around that time myself, quite the different mindset involved :)

[23:14] <masak> indeed.

[23:15] *** icwiener left
[23:15] <masak> I like it, mind you.

[23:15] <masak> monads are great.

[23:15] <masak> but they're also alien algebra from a future fourth dimension.

[23:15] <cspencer> masak: are you one of the pugs developers too, then?

[23:16] <masak> cspencer: what's the criterion? :)

[23:16] <masak> I've made a commit or two to Pugs, yes.

[23:16] <cspencer> masak: hahah, i'll leave that up to you :)

[23:16] <cspencer> nice

[23:18] <masak> yeah, those were fun times.

[23:21] <ruoso> rakudo: class MyFailure is Failure {}; sub foo { MyFailure.new().throw(); }; sub bar { foo(); CATCH { when MyFailure { say 1 }; }; bar();

[23:21] <p6eval> rakudo 34454: OUTPUT«Unable to parse block; couldn't find final '}' at line 1, near ""␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[23:22] <ruoso> rakudo: class MyFailure is Failure {}; sub foo { MyFailure.new().throw(); }; sub bar { foo(); CATCH { when MyFailure { say 1 }; }; }; bar();

[23:22] <p6eval> rakudo 34454: OUTPUT«Method 'throw' not found for invocant of class 'MyFailure'␤current instr.: 'bar' pc 349 (EVAL_12:155)␤»

[23:22] <ruoso> rakudo: class MyFailure is Failure {}; sub foo { fail MyFailure; }; sub bar { foo(); CATCH { when MyFailure { say 1 }; }; }; bar();

[23:22] <p6eval> rakudo 34454: RESULT«Null PMC access in find_method()␤current instr.: '_block14' pc 64 (EVAL_13:39)␤»

[23:22] <ruoso> pugs: class MyFailure is Failure {}; sub foo { fail MyFailure; }; sub bar { foo(); CATCH { when MyFailure { say 1 }; }; }; bar();

[23:22] <p6eval> pugs: RESULT«*** Failed␤    at /tmp/rMroet2UC8 line 1, column 127-132␤       /tmp/rMroet2UC8 line 1, column 80-85␤       /tmp/rMroet2UC8 line 1, column 51-65␤»

[23:22] <pmichaud> we don't have any form of "custom failure" types yet.

[23:22] <masak> we have enough of the regular ones :P

[23:23] * masak ducks

[23:23] <ruoso> rakudo: sub foo { Failure.new().throw(); }; sub bar { foo(); CATCH { when Failure { say 1 }; }; }; bar();

[23:23] <p6eval> rakudo 34454: OUTPUT«Method 'throw' not found for invocant of class 'Failure'␤current instr.: 'bar' pc 253 (EVAL_12:117)␤»

[23:23] <cspencer> pugs: .say for 0..10 :by(2)

[23:23] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ":by"␤    expecting operator␤    at /tmp/pPCzpgf7cO line 1, column 16␤»

[23:23] <ruoso> rakudo: sub foo { fail Failure }; sub bar { foo(); CATCH { when Failure { say 1 }; }; }; bar();

[23:23] <p6eval> rakudo 34454: RESULT«Null PMC access in find_method()␤current instr.: '_block14' pc 64 (EVAL_13:39)␤»

[23:23] <cspencer> ugs: .say for 0..10:by(2)

[23:23] <ruoso> pugs: sub foo { fail Failure }; sub bar { foo(); CATCH { when Failure { say 1 }; }; }; bar();

[23:23] <p6eval> pugs: OUTPUT«*** No such subroutine: "&Failure"␤    at /tmp/IvbBgEwTqZ line 1, column 11-24␤»

[23:23] <cspencer> pugs: .say for 0..10 :by(2)

[23:23] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ":by"␤    expecting operator␤    at /tmp/3vseueca7P line 1, column 16␤»

[23:23] <ruoso> meh

[23:23] <pmichaud> ruoso: I doubt rakudo is going to shed any light on Failure types or exception handling at the moment.

[23:24] <cspencer> pugs: .say for 0..10:by(2)

[23:24] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ":by"␤    expecting "_", fraction, exponent, term postfix or operator␤    at /tmp/3pFf4tcZEj line 1, column 15␤»

[23:24] <ruoso> my question is actually simple

[23:24] <ruoso> does the smartmatch realized by "when" suffices to mark the exception as handled?

[23:25] <ruoso> (that was a badly written sentence...)

[23:25] * ruoso will try again

[23:25] <masak> ruoso: I understood you.

[23:25] <ruoso> ah, at least

[23:25] <ruoso> :0

[23:25] <ruoso> ;)

[23:25] <pmichaud> I think that "when" by itself doesn't handle the exception.

[23:25] <pmichaud> (or its smart match)

[23:26] <pmichaud> although 'default' appears to be, according to S04

[23:27] <masak> sounds a bit inconsistent.

[23:27] <ruoso> so we need to 

[23:27] <pmichaud> let's phrase it differently.

[23:27] <ruoso> .handle = 1

[23:27] <ruoso> to mark as handled

[23:27] <pmichaud> reading S04, there's an implicit   die $!   at the end of a CATCH block that re-throws any exception that makes it to that point.

[23:28] <pmichaud> This implies that any when blocks prior to that will avoid that implicit die $!, thus the exception is not re-thrown.

[23:28] <pmichaud> this is regardless of whether the exception is marked as "handled"

[23:29] <ruoso> hmmm...

[23:30] <pmichaud> (I'm not claiming it makes sense -- I'm just reading/interpreting what S04 says.)

[23:30] <ruoso> sure sure...

[23:30] <masak> so even handled exceptions are re-thrown if the end of the 'when' block is reached?

[23:31] <pmichaud> I would think they're rethrown only if the when block explicitly rethrows them

[23:31] <pmichaud> i.e., a CATCH block looks like

[23:31] <pmichaud> CATCH {

[23:31] <pmichaud>    when ExceptionTypeA { ... }

[23:31] <pmichaud>    when ExceptionTypeB { ... }

[23:31] <pmichaud>    (implicit) die $!

[23:31] <pmichaud> }

[23:32] <pmichaud> so if any of the when blocks are activated, we never reach the die

[23:32] <pmichaud> and thus the exception is not rethrown unless the when block does so explicitly

[23:32] <masak> rakudo: 'AA'.pred.say

[23:32] <p6eval> rakudo 34454: OUTPUT«AA␤»

[23:33] <masak> pmichaud: ah. now I see what you mean.

[23:34] <ruoso> pmichaud, ok... I supppose I misunderstand 'when'

[23:37] <ruoso> but I didn't think that having a "when" block would make the other parts of the block unreachable

[23:37] <pmichaud> sure

[23:37] <pmichaud>    when XYZ { ... }   automatically breaks out of the block that sets $_

[23:37] <pmichaud> (which in this case is the CATCH block itself.)

[23:38] <ruoso> hmmm... is that spec?

[23:38] <pmichaud> one has to explicitly say "continue" inside the when block to make it check subsequent 'when' conditions

[23:38] <pmichaud> the "automatic breakout" is the think that makes 'when' significantly different from 'if'

[23:38] <pmichaud> *thing

[23:39] <pmichaud> (yes, it's spec for 'when' -- see S04 description of given/when)

[23:39] <ruoso> that makes it easier...

[23:40] *** iblechbot left
[23:40] <ruoso> but makes CONTROL and CATCH considerably inconsistent

[23:40] <ruoso> (at least I think so)

[23:40] <masak> tricky question: would ('a'..'h' :by(1.6)) generate 'a b d e g' or 'a b d e g h'?

[23:40] <masak> I'm leaning towards the former.

[23:40] <pmichaud> I'm leaning towards the latter.

[23:40] <masak> let's make it the latter, then.

[23:41] <pmichaud> because 'h' is still in the range.

[23:41] <masak> a better example would perhaps be 'a'..'f' :by(1.6)

[23:42] <pmichaud> 'a', 'b', 'd', 'e'

[23:43] <masak> agreed.

[23:43] <masak> what about 'a'..'c' :by(-.5)?

[23:43] <pmichaud> realizing of course that this means we're explicitly defining range to _not_ be in terms of succ.  I think that's probably a wise move somehow.

[23:43] <cspencer> rakudo: my $r = 1^..^10; say $r.perl ~ " - " ~ $i while (my $i = $r.shift);

[23:43] <p6eval> rakudo 34454: OUTPUT«2^..^10 - 2␤3^..^10 - 3␤4^..^10 - 4␤5^..^10 - 5␤6^..^10 - 6␤7^..^10 - 7␤8^..^10 - 8␤9^..^10 - 9␤»

[23:43] <masak> sorry, 'c'..'a' :by(-.5)

[23:43] <masak> one 'a' or two at the end?

[23:44] <ruoso> hmmm... this 'implicit $!' thing in CATCH is incredibly weird

[23:44] <pmichaud> 'c'..'a' :by(-0.5)  ==>   'c', 'b', 'b', 'a', 'a'

[23:44] <masak> pmichaud: good. agreed.

[23:45] <ruoso> implicit 'die $!', I mean

[23:45] <ruoso> because as the stack is not unwinded while the exception is not handled

[23:46] <ruoso> the idea of the exception being re-thrown doesn't look very right 

[23:46] <cspencer> if i create a range such as "1^..^10", and then shift a value off it, it should print out via a perl method as "2..^10", no?

[23:46] <cspencer> and not "2^..^10" as it currently is

[23:46] <ruoso> the natural would be to check if the exception was handled, and, if not, continue traversing backwards in the stack looking for CATCH blocks

[23:47] <cspencer> make that ".perl method" in the first

[23:47] <masak> cspencer: 2^..^10 looks good to me.

[23:47] <cspencer> doesn't that mean we'd be excluding 2 from the range?  it was originally defined as "1^..^10"

[23:47] <pugs_svn> r24655 | masak++ | [t/spec/S03-operators] added range-by.t with tests for ranges modified with the

[23:47] <pugs_svn> r24655 | masak++ | :by adverb

[23:48] <masak> cspencer: yes. I'm not sure I see what you see.

[23:48] <cspencer> rakudo: my $r = 1^..^10; say $r.perl ~ " - " ~ $i while (my $i = $r.shift);

[23:48] <masak> cspencer: specify what bothers you about the 2 being excluded.

[23:48] <p6eval> rakudo 34454: OUTPUT«2^..^10 - 2␤3^..^10 - 3␤4^..^10 - 4␤5^..^10 - 5␤6^..^10 - 6␤7^..^10 - 7␤8^..^10 - 8␤9^..^10 - 9␤»

[23:49] <cspencer> just wondering if the current implementation of Range.perl needs fixing

[23:49] <masak> that last 9 is slightly worrying, though.

[23:49] <cspencer> rakudo: my $r = 1^..^10; say $r.perl while (my $i = $r.shift);

[23:49] <p6eval> rakudo 34454: OUTPUT«2^..^10␤3^..^10␤4^..^10␤5^..^10␤6^..^10␤7^..^10␤8^..^10␤9^..^10␤»

[23:49] <masak> rakudo: say (9^..^10).shift

[23:49] <p6eval> rakudo 34454: OUTPUT«Undefined value shifted from empty range␤␤»

[23:50] <masak> that's more like it :)

[23:50] <pmichaud> the current implementation of Range is likely correct w.r.t. the current spec.

[23:50] <pmichaud> if I start with   $r = 1^..^10

[23:50] <pmichaud> and then shift a value from $r

[23:50] <cspencer> yes

[23:50] <masak> cspencer: added some tests for you in range-by.t

[23:50] <pmichaud> $r needs to be 2^..^10

[23:51] <pmichaud> _otherwise_, we end up with this:

[23:51] <cspencer> doesn't that imply that the 2 should be excluded from the range?

[23:51] <masak> cspencer: yes, it does.

[23:51] <pmichaud> my $r = 1^..^10;  my $a = $r.shift;  my $b = $r.shift;  say "$a $b"

[23:51] <pmichaud> we want to make sure that $b is _not_ 2

[23:51] <pmichaud> changing the range to become 2..^10 would mess that up

[23:52] <cspencer> alrighty :)

[23:52] <cspencer> bbl, dinner making time

[23:52] <masak> pmichaud++ # for explaining. I couldn't even see what the problem was. :)

[23:52] <masak> time to sleep, here

[23:52] <masak> good night, people.

[23:52] *** masak left
[23:53] <ruoso> pmichaud, do you have that implicit 'die $!' in CATCH implemented now?

[23:54] *** apeiron left
[23:55] <ruoso> I'm really uncomfortable with it...

[23:55] <pmichaud> ruoso: no, we haven't really worked too hard on CATCH blocks yet.

[23:55] <pmichaud> ruoso: they haven't been a critical feature for implementation.

[23:56] <pmichaud> (also Parrot exceptions have had their own issues, which Tene++ is clearing up.)

[23:56] <ruoso> right...

[23:57] *** lichtkind left
[23:57] *** apeiron joined
[23:57] <ruoso> but one thing that really looks bad in the 'rethrowing' is that the context information of the exception points to the place where it was thrown 

[23:58] <ruoso> I'm afraid we would have a lot of effort to keep the original context information after the rethrow

[23:58] <pmichaud> well, I think we have to make a distinction between "original throw" and "rethrow"

[23:59] *** kisu_ joined
[23:59] *** alester left
[23:59] <pmichaud> at least, that's the conclusion we've been coming to in Parrot (although it's still up in the air)

[23:59] <ruoso> I'd be more confortable with an implicit:

