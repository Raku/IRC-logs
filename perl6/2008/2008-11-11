[00:02] <wayland76> perlbot karma wayland76 

[00:02] <perlbot> wayland76 doesn't have any karma

[00:11] <meppl> good night

[00:11] <wayland76> good night

[00:11] <meppl> ;)

[00:12] *** meppl left
[00:15] *** Alias_ joined
[00:19] <japhb> jnthn: is it possible to set sub params as rw in Rakudo, and have it work?

[00:19] <jnthn> Yes.

[00:19] <jnthn> Though it's on my list of things that may not have good spectest coverage

[00:19] <japhb> k

[00:20] <japhb> just sub foo($param is rw)?

[00:20] <jnthn> But I did review this just a few days back when pm and I were doing the container refactors.

[00:20] <jnthn> Yes.

[00:20] <japhb> cool beans, thx

[00:20] <jnthn> rakudo: sub foo($x is rw) { $x = 42 }; my $a = 2; foo($a); say $a;

[00:20] <p6eval> rakudo 32502: OUTPUT[42␤]

[00:20] <jnthn> Yes, works.

[00:26] <wayland76> Are there any windowing toolkits that cat be used from Parrot yet?

[00:26] <wayland76> s/cat/can/

[00:28] <jnthn> wayland76: I know there's SDL but I don't know that this counts as windowing toolkit.

[00:28] <japhb> wayland76: and there's GLUT.  Same problem.

[00:29] <japhb> Although it does create windows and menus ... :-P

[00:29] <wayland76> Well, maybe SDL will do what I want :)

[00:30] * jnthn doesn't know much about it

[00:30] <wayland76> At the moment, I'm mainly after something that makes canvases easy :)

[00:30] <wayland76> Anyway, now that I know what the options are, I can investigate them :)

[00:31] <wayland76> Thanks :)

[00:31] <jnthn> Welcome, have fun. :)

[00:33] <pugs_svn> r22970 | ruoso++ | [mildew] one test showing that if you define "knowhow ClassHOW", you can then use "class Foo". The relationship about each metaclass handles each keyword is hard-coded in the compiler.

[00:36] *** jan_ left
[00:36] <ruoso> @tell pmurias take a  look at mildew/t/classhow_add_method.t

[00:36] <lambdabot> Consider it noted.

[00:37] *** penk joined
[00:38] *** jan_ joined
[00:38] * ruoso sleep &

[00:45] *** kanru joined
[00:51] <pugs_svn> r22971 | lwall++ | [Cursor] isolate symbols in a NOTBEFORE to fix mncharity++'s last; problem

[00:51] <pugs_svn> r22971 | lwall++ | [Cursor] stub in a trie-engine as down payment on a real dfa

[00:51] *** Lorn joined
[00:52] <japhb> rakudo: my $a = 2; my $b = 4; say "foo: {$a / $b}"

[00:52] <p6eval> rakudo 32503: OUTPUT[foo: 0.5␤]

[00:52] <japhb> *excellent*

[00:55] <TimToady> what the heck was that?

[00:55] <TimToady> why did it include foo:?

[00:55] <TimToady> it should have been parsed as a label

[00:55] <jnthn> TimToady: What?

[00:56] <jnthn> Labels inside double quotes?

[00:56] <TimToady> ah

[00:56] <TimToady> missed those

[00:56] * jnthn breathes a sigh of relief

[00:56] <TimToady> I misread a question on my SAT like that too--kept me from getting an 800 on the math section...

[00:59] <jnthn> TimToady: Am I right in thinking that if you declare a class, then write a BEGIN block after it, you can use that class, instantiate it etc in the BEGIN block?

[00:59] <TimToady> yes, declarations happen at compile time

[01:00] <jnthn> OK.

[01:00] <TimToady> otherwise there wouldn't be much point in 'em

[01:00] <jnthn> OK, that was the answer that I was expecting.

[01:00] <jnthn> Follow up.

[01:00] <jnthn> my $x is foo; # where foo is some trait we've defined

[01:01] <jnthn> If we have that inside a sub, we would apply the trait each time the sub is invoked?

[01:01] <jnthn> As in, create a container and apply the trait?

[01:01] <jnthn> Or is that somehow a one-shot thing at compile time too?

[01:02] <TimToady> there's an abstract $x that is shared by all invocations...at least in the abstract :)

[01:02] <ruoso> meaning that the runtime can clone in each passage?

[01:03] <ruoso> s/passage/invocation/

[01:03] <TimToady> it seems like you'd want to factor out common operations to one spot though, to the extent that your VM allows it

[01:04] <jnthn> OK, so if the trait kept track of how many times it was applied (or, OK, the trait_auxilliary:is multi for that trait did), and we only ever wrote "my $x is foo" once in a subroutine, then called that sub 100 times, the counter would only get incremented once?

[01:04] <TimToady> but if a VM cannot support something declaratively then it has to be emulated, of course

[01:04] * jnthn hopes his question made sense - I can put it in code too if not!

[01:04] <Limbic_Region> TimToady - the SATs were restructured in 2005.  I scored a 1200 my sophmore year and never took them again

[01:05] <TimToady> the trait is applied at compile time, in the abstract, not at run time

[01:05] <ruoso> TimToady, on another issue, would you consider who's job to move bare statements in a package to INIT? viv? STD? or the actual compiler?

[01:06] <jnthn> TimToady: OK, thanks. I'll probably now spend my flight on Thursday working out exactly what the fallout of this is. :-)

[01:07] <TimToady> ruoso: I don't really understand your question

[01:08] <ruoso> TimToady, viv currently sees the list of statements as plain

[01:08] <ruoso> independently if it is a method_def or something else

[01:08] <TimToady> well, it's certainly not peanut

[01:09] <ruoso> it's my understanding that method_def, as well as other declarations happen at BEGIN

[01:09] <ruoso> and other statements are only executed at INIT

[01:09] <TimToady> after INIT, but go on

[01:10] <ruoso> who do you think is the responsible for sorting out what should be in BEGIN and what shouldn't?

[01:10] <ruoso> STD?

[01:10] <ruoso> viv?

[01:10] <ruoso> or the compiler itself?

[01:11] <TimToady> I guess I don't know what you mean by "the compiler itself"

[01:11] <ruoso> well... in our current setup...

[01:11] <ruoso> mildew

[01:11] <diakopter> out of band call to #perl6?

[01:11] <TimToady> and I don't why you mention viv, when that's the vi-to-v translator :)

[01:12] * jnthn suddenly gets what viv stands for

[01:12] <TimToady> anyway, every construct needs to know whether it executes itself as part of its own reduction

[01:13] <TimToady> and declarations may or may not return extra stuff to run at run time

[01:13] <TimToady> my $x = 42; still hast to do the = at run time

[01:13] <TimToady> but it doesn't have to do the "my" part, except insofar as the variable storage needs setting up at entry

[01:14] *** hercynium joined
[01:14] <ruoso> ok...

[01:14] <ruoso> in mildew we have...

[01:14] <ruoso> STD -> viv -> mildew -> m0ld

[01:15] <TimToady> it was intended that viv be copied, not used :)

[01:15] <ruoso> I'm not sure at which extent it is "used"...

[01:16] <ruoso> but wasn't viv the one that turned the match tree into something more AST-like?

[01:16] <TimToady> I suspect it's just the callback engine, which is pretty small

[01:16] <TimToady> sure, but that's like one routine, and you don't want the rest of viv

[01:16] <TimToady> if we want to abstract out that routine, fine

[01:17] <TimToady> anyway, not what you're asking about

[01:17] <ruoso> right... but it doesn't really matter to the question...

[01:17] <jnthn> TimToady: You write "except insofar as the variable storage needs setting up at entry" - if you're doing a trait like is dim(2,3,4) or something, then this sized/shaped array needs creating at entry.

[01:17] <jnthn> TimToady: Does this mean that really the trait should be supply the AST to Do That at runtime?

[01:17] <jnthn> And it gets shoved into what we compile?

[01:18] <jnthn> Rather than the trait being invoked at runtime to do that...

[01:18] <jnthn> ...which I guess doesn't fit with what you said earlier. :-)

[01:18] <TimToady> well, declarations can have all kinds of consequences, and certainly some of the consequences are at run time

[01:18] <jnthn> Sure.

[01:18] <jnthn> I'm just trying to work out how traits will look

[01:19] <jnthn> I mean, in Rakudo we identify a bunch of them hard coded in the actions.

[01:19] <jnthn> But, well, I don't think that's really what we want.

[01:19] *** Lorn left
[01:19] <ruoso> trying to put in an example...

[01:19] <ruoso> class Foo { say 1; method bar {...} say 2; };

[01:19] <ruoso> mildew currently sees the three statements in a flat list

[01:20] <TimToady> well, assuming a newline in there

[01:20] <ruoso> yes yes

[01:21] <ruoso> but "method bar {...}" declaration will get executed much sooner than "say 1" and "say 2"

[01:21] <TimToady> yes, in the sense that the method bar declaration executes even before say 2 is parsed

[01:22] <jnthn> Wow.

[01:22] <jnthn> That's even earlier than I expected.

[01:22] <ruoso> who is the one who decides which statements are executed when?

[01:22] <TimToady> the reduction of a BEGIN block must trigger its execution

[01:22] <TimToady> just generalize from there

[01:23] <ruoso> but who defines which one is a BEGIN and which isn't?

[01:23] <TimToady> there needs to be a method to run a block that is accessible to the reduction action

[01:24] <TimToady> alternately, some way for such reductions to signal their surrounding scope to execute them immediately

[01:25] <ruoso> so, STD has a hook for everything, and the runtime then decides what should be BEGIN and what shouldn't...

[01:26] * ruoso really looking at concrete code right now

[01:26] <ruoso> not thinking abstract at all

[01:26] <TimToady> another way of looking at it is that FOO {...} routines install themselves into various queues, and different queues are executed at different times

[01:27] * ruoso doesn't really understand what that means relating to the question

[01:27] <TimToady> declarations just happen to have an abstract container object that can be modified when such a beginnish routine is called by a trait

[01:28] <ruoso> right... but who puts the container?

[01:28] <ruoso> STD?

[01:28] <TimToady> different declarators create different containers

[01:28] <diakopter> TimToady: may a BEGIN block redefine the parsing of a BEGIN block [including itself]?

[01:29] <TimToady> STD is just syntax, until you add actions

[01:29] <ruoso> mhmm... 

[01:29] <diakopter> I mean, it couldn't define away the BEGIN's }, could it

[01:29] <TimToady> diakopter: no, it's already parsed

[01:29] <TimToady> the BEGIN reduction doesn't happen till after the } is parsed

[01:29] <diakopter> oh

[01:29] * ruoso feels too asleep to figure out entirely what all that means...

[01:30] * ruoso sleep &

[01:30] *** japhb left
[01:30] <TimToady> nite

[01:30] <jnthn> TimToady: While we're on the evil... :-)

[01:30] <jnthn> class Foo { method x { }; BEGIN { Foo.x }; }

[01:31] <jnthn> Would we expect that to actually invoke x, or is it too early to instantiate Foo before it's definition is over?

[01:31] <diakopter> jnthn: those noops are detected and eliminated :P

[01:32] <diakopter> (kidding)

[01:33] <TimToady> I think that's probably too early--it knows the name, but not the implementation

[01:33] <jnthn> OK, sounds good.

[01:34] <TimToady> so it would compile the BEGIN fine, but fail in the dispatch to Foo

[01:35] <TimToady> groceries &

[01:35] <jnthn> ooh...2:30am...sleep &

[01:36] <pmurias> ruoso: m0ld is dynamic linking now

[01:36] <lambdabot> pmurias: You have 4 new messages. '/msg lambdabot @messages' to read them.

[01:36] <pmurias> shower&

[01:38] *** spx2 left
[01:38] *** spx2 joined
[01:40] *** bcornett left
[01:46] *** justatheory left
[01:55] *** japhb joined
[02:11] *** Limbic_Region left
[02:16] *** nacho_ joined
[02:18] *** pmurias left
[02:19] *** hercynium left
[02:23] *** bacek left
[02:27] * wayland76 has not quit :)

[02:27] *** penk left
[02:30] *** penk joined
[02:39] *** penk left
[02:39] *** nacho_ left
[02:42] *** wayland76 left
[02:44] *** alester left
[02:57] *** elmex left
[03:00] *** wknight8111 left
[03:00] *** s1n joined
[03:01] <s1n> pmichaud: finally back online

[03:05] *** Tene joined
[03:15] *** sri_kraih_ joined
[03:18] *** justatheory joined
[03:22] *** sri_kraih left
[03:25] *** stephenos left
[03:27] *** alester joined
[03:35] <japhb> rakudo hackers about?

[03:37] <Alias_> Probably mostly the wrong timezone

[03:37] <s1n> only 0930 here

[03:38] <Alias_> Very late in the US, very early in Europe. Just us mere Australasians online right now

[03:38] <japhb> rakudo: my $a = 2; sub foo { say "foo: $a"; bar(); }; sub bar { say "bar: $a"; }; foo();

[03:38] <p6eval> rakudo 32504: OUTPUT[foo: 2␤bar: ␤]

[03:38] <japhb> That's breaking things for me right now, just wanted to know if it's a known issue

[03:39] <s1n> not very late in the US, i meant to say 2130, not 0930 :)

[03:47] *** ab5tract joined
[04:03] *** kanru left
[04:03] *** Patterner1 joined
[04:05] *** kanru joined
[04:06] *** jfredett joined
[04:15] *** Patterner left
[04:15] *** Patterner1 is now known as Patterner

[04:19] *** s1n left
[04:33] *** Jedai joined
[04:41] *** jauaor left
[04:42] *** hercynium joined
[04:49] *** araujo left
[04:49] *** [particle] left
[04:52] *** |Jedai| left
[04:58] *** justatheory left
[05:01] *** araujo joined
[05:14] <pmichaud> japhb: lexicals are still having issues in Parrot/rakudo, yes.

[05:16] *** ab5tract left
[05:18] *** alc joined
[05:22] *** agentzh left
[05:26] *** jauaor joined
[05:45] *** agentzh joined
[05:50] <rakudo_svn> r32510 | coke++ | [rakudo] RT #58974 - use of .return as a synonym for .tailcall is [DEPRECATED]

[05:56] *** TimToady left
[05:56] *** diakopter left
[05:56] *** cpfr left
[05:57] *** TimToady joined
[05:57] *** diakopter joined
[06:03] *** zamolxes left
[06:15] *** araujo left
[06:15] *** tewk_ left
[06:15] *** jiing left
[06:15] *** idemal left
[06:15] *** nothingmuch left
[06:15] *** broquaint left
[06:15] *** fullermd left
[06:15] *** Guest70230 left
[06:15] *** literal left
[06:15] *** c1sung left
[06:15] *** c1sung joined
[06:16] *** tewk joined
[06:16] *** nothingmuch joined
[06:16] *** broquaint joined
[06:21] *** fullermd joined
[06:22] <japhb> pmichaud: OK, thanks for letting me know, I'll try to work around it.

[06:22] *** jiing joined
[06:24] <lizsac> no prob

[06:29] *** araujo joined
[06:29] *** literal joined
[06:29] *** idemal joined
[06:30] *** broquaint left
[06:30] *** broquain1 joined
[06:30] *** broquaint joined
[06:30] *** broquaint left
[06:31] *** [particle] joined
[06:36] <japhb> How do I produce a Parrot ManagedStruct/UnManagedStruct from Rakudo?  Or alternately, is the Perl 6 syntax for packed native data working?

[06:39] *** alc left
[06:42] *** spx2 left
[06:48] *** cpfr joined
[06:54] *** Bzek joined
[06:59] *** bacek_ joined
[07:00] *** bacek__ left
[07:06] *** zamolxes joined
[07:10] *** DemoFreak joined
[07:13] <moritz_> ruoso: it should be recompiled by know - could you please check?

[07:21] *** adc_Penner joined
[07:22] *** xunxi1 joined
[07:23] *** xunxi1 left
[07:24] *** pbuetow joined
[07:27] *** smg left
[07:29] *** jauaor left
[07:37] *** pbuetow left
[07:49] *** ZuLuuuuuu joined
[07:50] <ZuLuuuuuu> hello I guess perl 6 doesn't have a cgi or database module yet right?

[07:58] *** alc joined
[08:04] <lizsac> use the force

[08:07] *** stephenos joined
[08:09] *** ZuLuuuuuu left
[08:10] <moritz_> it has a basic CGI module.

[08:17] *** alester left
[08:18] *** Guest70230 joined
[08:21] *** jiing_ joined
[08:22] *** jiing left
[08:48] *** DemoFreak left
[08:57] *** smg joined
[09:10] *** ashizawa joined
[09:13] *** iblechbot joined
[09:14] <ruoso> mildew: knowhow Foo { method bar { $OUT.print("Hello World!\n") } }; Foo.bar;

[09:14] <p6eval> mildew: No output (you need to produce output to STDOUT)

[09:16] <moritz_> Can't chdir to 'umask 002; ../../v6/mildew': No such file or directory at lib/EvalbotExecuter.pm line 136

[09:16] <moritz_> oh dang, that looks broken.

[09:17] *** p6eval left
[09:17] *** p6eval joined
[09:17] <moritz_> mildew: knowhow Foo { method bar { $OUT.print("Hello World!\n") } }; Foo.bar;

[09:17] <p6eval> mildew: OUTPUT[Can't locate object method "term__S_387identifier" via package "STD" at ../../src/perl6/STD.pm line 1041.␤]

[09:18] <moritz_> that might be a permission problem

[09:19] *** p6eval left
[09:20] *** p6eval joined
[09:20] <moritz_> mildew: knowhow Foo { method bar { $OUT.print("Hello World!\n") } }; Foo.bar;

[09:20] <p6eval> mildew: OUTPUT[Can't locate object method "term__S_387identifier" via package "STD" at ../../src/perl6/STD.pm line 1041.␤]

[09:25] *** ashizawa_ joined
[09:26] *** ashizawa left
[09:28] *** ejs joined
[09:29] *** adc_Penner left
[09:30] *** Alias_ is now known as adamkennedy

[09:31] *** pmurias joined
[09:31] <pmurias> moritz_: that's an old lex/ problem

[09:31] <moritz_> pmurias: feel free to clean it up

[09:36] <pmurias> moritz_: i always forget the get into the chroot incantation

[09:37] *** elmex joined
[09:37] <moritz_> chroot /chroot iirc

[09:41] *** alc left
[09:44] *** pnu left
[09:46] *** pnu joined
[09:49] *** meppl joined
[09:50] <jnthn> japhb: The packed native data stuff isn't done in Rakudo yet - not sure about how you can use the ManagedStruct / UnManagedStruct stuff from their either...need to think that one over a bit.

[09:50] *** apeiron_ joined
[09:57] *** apeiron left
[09:58] <pmurias> milew: $OUT.print("Hello world\n");

[09:58] <pmurias> mildew: $OUT.print("Hello world\n");

[09:58] <p6eval> mildew: OUTPUT[unknown method "new" at bool_message line 33 file /home/evalenv/pugs/v6/smop/src/native_bool.c␤]

[10:02] *** stephenos left
[10:13] <ruoso> pmurias, hi

[10:18] *** bacek__ joined
[10:19] <pmurias> ruoso: hi

[10:19] <ruoso> pmurias, have you seen the new code in mildew?

[10:20] <pmurias> i'm slowly getting up an fixing the mildew in the evalbot now

[10:21] <pmurias> mildew: $OUT.print("Hello World\n")

[10:22] <p6eval> mildew: OUTPUT[Hello World␤]

[10:22] <pmurias> looking now...

[10:22] <ruoso> mildew: knowhow Foo { method bar { $OUT.print("Hello World!\n") } }; Foo.bar;

[10:22] <p6eval> mildew: OUTPUT[unimplemented:  at mildew line 22␤        Mildew::XXX() called at mildew line 100␤ VAST::noun::emit_m0ld('VAST::noun=HASH(0xa0ab3f0)') called at mildew line 129␤    VAST::Terminator::emit_m0ld('VAST::Terminator=HASH(0xa1b6d70)') called at mildew line 319␤       

[10:22] <p6eval> ..VAST::statement::emit_m0ld('VAST::...

[10:23] *** cosimo joined
[10:23] <ruoso> pmurias, I think mildew evalbot is still not up-to-date

[10:24] <pmurias> moritz_: mildew doesn't automatically update it self

[10:24] <pugs_svn> r22972 | jnthn++ | [spectest] Fudge isalso/is instead tests, so we only run is also for Rakudo and don't try to parse/compile the is instead.

[10:24] <pmurias> mildew: knowhow Foo { method bar { $OUT.print("Hello World!\n") } }; Foo.bar;

[10:24] <p6eval> mildew: OUTPUT[Hello World!␤]

[10:24] <moritz_> pmurias: feel free to install a cron job as user 'evalenv' (in the chroot)

[10:24] <ruoso> hmm.. much better

[10:25] <moritz_> I thought I installed one, but it seems I missed it, or messed it up or something.

[10:25] <pmurias> ruoso: we need &say as $OUT.print($var.FETCH) is nonspec and ugly

[10:26] <ruoso> pmurias, I think we could install something like...

[10:26] <ruoso> er...

[10:26] <ruoso> we can't

[10:26] <ruoso> we need signatures

[10:27] <pmurias> yes

[10:27] <pmurias> :)

[10:27] <ruoso> I'm not sure it's a good idea to create yet another lowlevel just to see it pretty ;)

[10:29] <ruoso> pmurias, but did you notice that method installs itself by calling $?CLASS.^add_method(...)?

[10:29] <pugs_svn> r22973 | pmurias++ | [mildew] Makefile for make test - i forget to add it :(

[10:29] *** tomyan joined
[10:31] *** bacek_ left
[10:31] <pmurias> ruoso: cool

[10:36] <pmurias> ruoso: we pass 19 of our own tests now ;)

[10:38] <pmurias> ruoso: why did you add AST::MetaCall?

[10:39] <pugs_svn> r22974 | pmurias++ | [mildew] removed AST::List

[10:40] *** ruoso_ joined
[10:40] *** ruoso left
[10:41] *** ruoso_ left
[10:41] *** ruoso joined
[10:42] <ruoso> pmurias, take a look on how the MetaCall is emitted

[10:43] <ruoso> by doing that way I can re-use the invocant register 

[10:43] <ruoso> otherwise something().^add_method would result in two calls to "something()"

[10:44] <pugs_svn> r22975 | ruoso++ | [mildew] added test_ target for different prove version

[10:45] <ruoso> pmurias, is it really needed to rm -rf lex everytime you run make test?

[10:45] <ruoso> it makes it incredibly slower...

[10:48] <pmurias> ruoso: no

[10:48] <pugs_svn> r22976 | ruoso++ | [mildew] refactoring the Makefile... now you have make prove which does not make clean...

[10:48] *** cookys joined
[10:50] <rakudo_svn> r32525 | jonathan++ | [rakudo] Add tests for is also to spectest_regression.

[10:50] <ruoso> pmurias, what does prove --version outputs for you?

[10:52] <pmurias> TAP::Harness v3.14 and Perl v5.10.0

[11:00] <rakudo_svn> r32526 | moritz++ | [rakudo] add autovivification tests to spectest.data

[11:03] <pmurias> ruoso: we could generalise MetaCall to a evaluate this use the result in that AST node

[11:03] <ruoso> pmurias, maybe... but MetaCall is something special anyway...

[11:05] <pmurias> expand please...

[11:06] <ruoso> the way it expands $a.^b($c) to $a.^!how.b($a,$c) is very m0ld specific

[11:06] *** meppl left
[11:06] <pmurias> shouldn't it be HOW?

[11:06] *** Lorn joined
[11:06] <pmurias> $a.HOW.b($a,$c)?

[11:07] <Lorn> pmurias: obfuscated in perl6? japh6? :P

[11:08] <pmurias> Lorn: hm?

[11:08] <ruoso> pmurias, except that $a.HOW is a macro

[11:08] <ruoso> HOW is not really a method

[11:09] <ruoso> $a.HOW should be translated to $a.^!how

[11:09] *** apeiron_ is now known as apeiron

[11:10] <pugs_svn> r22977 | ruoso++ | [mildew] find out which version of prove you have and wich command switch to use

[11:10] <ruoso> pmurias, please test the new Makefile

[11:11] <pmurias> why is HOW a macro?

[11:11] <ruoso> because the spec says so

[11:11] <pmurias> works?

[11:11] <pmurias> s/?//

[11:11] <pmurias> ruoso: meant more why does the spec say so

[11:12] <ruoso> because it's implementation specific

[11:12] <ruoso> in SMOP it turns out to be a REPR method

[11:12] <ruoso> which p6opque intercepts

[11:12] <ruoso> and p6opaque only intercepts REPR methods

[11:12] <ruoso> and all REPR methods have the '^!' prefix

[11:13] *** alc joined
[11:15] <pmurias> makes a bit of sense if we view $foo.bar as $foo.HOW.dispatch(...)

[11:16] <ruoso> except that we don't need to see it that way, because p6opaque already does that delegation

[11:18] *** rindolf joined
[11:18] <pmurias> that

[11:18] <pmurias> 's true

[11:19] <pmurias> ruoso: re elf and mildew tests what i meant i intended to have all of the p6 in the smop tests suit migrated to the mildew test suit and the elf dependency dropped

[11:19] <ruoso> oh... ok

[11:20] <ruoso> anyway... have to go now... 

[11:20] <ruoso> pmurias, if you have some time, please consider working on compiling signatures to AdhocSignature

[11:20] <pmurias> ok

[11:20] <ruoso> that's the thing missing so we can run ClassHOW.add_method

[11:20] <pugs_svn> r22978 | pmurias++ | [smop] removed test 26 as we don't target pugs anymore

[11:21] * ruoso later &

[11:46] *** iblechbot left
[11:50] <rakudo_svn> r32527 | jonathan++ | [rakudo] Fix a couple of bugs in candidate sorting for MMD. One was an off-by-one error. The other was more subtle; we mustn't remove edges from the graph per iteration of the topological sort, otherwise we end up not identifying one candidate as narrower than another,

[11:50] <rakudo_svn> ..depending on the order they appear in the code.

[11:50] <rakudo_svn> r32528 | jonathan++ | [rakudo] Make the Num type also accept Int values.

[12:00] *** rindolf left
[12:07] *** SamB left
[12:12] *** Ontolog joined
[12:14] *** Ontolog is now known as ChrisDavaz

[12:17] *** ludan joined
[12:23] *** broquain1 is now known as broquaint

[12:30] <rakudo_svn> r32530 | jonathan++ | [rakudo] Must create subset types earlier (in the end at compile time, but for now moving them to $?INIT, the same time as we do classes, makes things work much better).

[12:42] <pugs_svn> r22979 | jnthn++ | [spectest] Fix a bug in the spectest, and fudge one test that Rakudo can't pass yet, for subset types in multiple dispatch.

[12:42] <pugs_svn> r22980 | jnthn++ | [spectest] Add an explicit test that Num accepts Ints on assignment - couldn't find one that did this.

[12:44] *** SamB joined
[12:50] <rakudo_svn> r32532 | jonathan++ | [rakudo] Add multi dispatch based on subset types test.

[12:56] *** perlbot left
[12:59] <pmurias> jnthn: you are jonathan?

[13:02] <jnthn> pmurias: I'm jonathan on #parrot :-)

[13:02] <jnthn> But that was taken here.

[13:02] <jnthn> Well, on this server.

[13:02] <jnthn> So I'm jnthn here.

[13:18] *** z80ASM joined
[13:33] *** iblechbot joined
[13:34] <pmurias> ruoso: i'm adding an call method_name => $invocant,[@positionals],[@named] AST creation helper to mildew, does it seem sane?

[13:40] *** abra joined
[13:40] *** abra left
[13:40] *** abra_ joined
[13:40] *** abra_ left
[13:41] *** schmalbe joined
[13:42] *** abra joined
[13:58] *** DemoFreak joined
[14:13] *** pedrob joined
[14:17] *** masak joined
[14:18] *** z80ASM left
[14:23] *** pedrob left
[14:24] <masak> rakudo: say True ?? 1 !! False ?? 2 !! 3;

[14:24] <p6eval> rakudo 32537: OUTPUT[2␤]

[14:24] <masak> I can see how it might (mistakenly) say 2, as it does. I _don't_ see how it should say 1.

[14:24] <masak> I could see how it'd say 0.

[14:25] <masak> um. nvm. of course it should say 1.

[14:25] * masak needs more coffee

[14:33] <pmichaud> rakudo is parsing that incorrectly as  (True ?? 1 || False) ?? 2 !! 3;

[14:34] <pugs_svn> r22981 | pmurias++ | [mildew] &call helper

[14:34] <masak> yes, I gathered.

[14:35] <masak> seems I was parsing it incorrectly, too :)

[14:46] *** jauaor joined
[14:54] *** schmalbe left
[14:56] *** Exodist joined
[14:58] *** jhorwitz joined
[14:58] *** hercynium_ joined
[14:59] *** kanru left
[15:00] *** abra left
[15:04] *** ejs left
[15:04] *** ejs_ joined
[15:20] <rakudo_svn> r32541 | pmichaud++ | [rakudo]: spectest-progress.csv update: 212 files, 4199 passing, 473 failing

[15:20] <pugs_svn> r22982 | moritz++ | [t/spec] some unfudges for rakudo

[15:40] <rakudo_svn> r32542 | jonathan++ | [rakudo] A while back, some changes were done that set $?CLASS when a grammar was created. But since we checked $?PACKAGE =:= $?GRAMMAR second after checking $?PACKAGE =:= $?CLASS, we stopped creating grammars properly, meaning they started inheriting from Any instead of some

[15:40] <rakudo_svn> ..grammar rules. This switches around the ordering. Also re-fixes the bug originally fixed before this change where $?NS wasn't cleared.

[15:51] *** DemoPhreak joined
[15:54] *** ruoso left
[15:54] *** smg left
[16:00] <rakudo_svn> r32543 | pmichaud++ | [rakudo]:  Revise r32528 so that Num::ACCEPTS (re)uses existing .ACCEPTS

[16:03] *** aindilis` joined
[16:05] *** DemoFreak left
[16:09] *** stephenos joined
[16:13] <masak> 's there any way to write /aa+/ without repeating 'a'?

[16:14] <jnthn> a**{2...} maybe?

[16:14] <jnthn> erm, a**2...

[16:14] <jnthn> ...maybe... :-)

[16:14] <masak> doesn't currently work, anyway.

[16:14] <jnthn> Whether it's allowed and whether it's implemented may be two different things mind.

[16:15] <masak> ya.

[16:15] <jnthn> I think it's what you'd want in the long run.

[16:15] <jnthn> Could always file a ticket asking for it. :-)

[16:15] <PerlJam> three dots == infinity?  I thought you had to put a whatever-* there

[16:15] <PerlJam> a**2..*

[16:15] <PerlJam> (or something)

[16:15] <jnthn> Oh, maybe

[16:15] <jnthn> I forget exactly.

[16:15] <PerlJam> me too :)

[16:16] <jnthn> There is some infinite range style syntax that does that kinda thingy anyway.

[16:16] <jnthn> :-)

[16:16] <masak> PerlJam: 2..* looks much better.

[16:16] <masak> and it works!

[16:16] <masak> PerlJam++

[16:17] <PerlJam> Continued affirmation that my memory works better than I expect :)

[16:17] * masak will try to remember that :)

[16:19] *** ejs_ left
[16:21] *** ejs_ joined
[16:24] *** adamkennedy left
[16:25] *** bacek_ joined
[16:26] *** aindilis` left
[16:26] *** bacek__ left
[16:27] *** rindolf joined
[16:27] *** aindilis left
[16:28] *** justatheory joined
[16:30] <rakudo_svn> r32545 | jonathan++ | [rakudo] Make C compiler shut up with its warnings. Spotted by masak++.

[16:30] <masak> rakudo: for "foo\nbar\nbaz".split( /\n ** 2..*/ ) { .say }

[16:30] <p6eval> rakudo 32543: OUTPUT[foo␤bar␤baz␤]

[16:30] <masak> um, bad example. :)

[16:31] <moritz_> but done right ;)

[16:32] <masak> rakudo: for "foo\nbar\nbaz".split( /\n ** 2..*/ ) { .say; say }

[16:32] <p6eval> rakudo 32543: OUTPUT[foo␤bar␤baz␤␤]

[16:32] <masak> hah!

[16:32] <masak> izzat a bug I see?

[16:32] <masak> no, wait.

[16:32] <moritz_> where do you see a bug?

[16:32] <masak> that's right too.

[16:32] <pmichaud> hah!

[16:32] * jnthn is struggling to see it.

[16:33] <masak> I'm too trigger happy today...

[16:33] <moritz_> cought the ticket before it left masak's head ;)

[16:35] <masak> ...but now I've found something. seriously!

[16:35] <masak> rakudo: say "foo\nbar\nbaz".trans([ /\s+/ => " " ])

[16:36] <p6eval> rakudo 32543: OUTPUT[foo bar baz␤]

[16:36] <masak> all good, yes?

[16:36] <masak> now look:

[16:36] <masak> rakudo: for "foo\nbar\nbaz".split( /\n ** 2..*/ ) { say .trans([ /\s+/ => " " ]) }

[16:36] <p6eval> rakudo 32543: OUTPUT[too few arguments passed (2) - 3 params expected␤current instr.: '_block25' pc -342568903 ((unknown file):-1)␤]

[16:36] <masak> HAH!

[16:36] * masak files ticket

[16:37] * jnthn tries to work out what on earth could have wanted 3 params..

[16:38] <masak> jnthn: the .trans

[16:38] <pmurias> jnthn: what arguments does postcircumfix:<( )> take in rakudo?

[16:39] <pmichaud> rakudo:   say "foo\nbar\nbaz".split( /\n ** 2..*/ ).WHAT;

[16:39] <p6eval> rakudo 32543: OUTPUT[List␤]

[16:40] <pmichaud> rakudo:   say "foo\nbar\nbaz".split( /\n ** 2..*/ ).elems;

[16:40] <p6eval> rakudo 32543: OUTPUT[1␤]

[16:40] <masak> as should be.

[16:40] <pmichaud> rakudo:   for "foo".split( /\n ** 2..*/ ) { .say }

[16:40] <p6eval> rakudo 32543: OUTPUT[foo␤]

[16:40] <pmurias> jnthn: does it receive a capture or are the arguments passed as parts of the capture

[16:41] <pmichaud> rakudo:   for "foo".split( /\n ** 2..*/ ) { $_.trans( [ /o/ => ' ' ] ) }

[16:41] <p6eval> rakudo 32543: OUTPUT[too few arguments passed (2) - 3 params expected␤current instr.: '_block25' pc -342600339 ((unknown file):-1)␤]

[16:41] <moritz_> pmurias: rakudo doesn't have any postcircumfix methods or subs yet that are actually user visible

[16:41] <pmichaud> rakudo:   for "foo".split( /\n ** 2..*/ ) { $_.trans( [ 'o' => ' ' ] ) }

[16:41] <p6eval> rakudo 32543: OUTPUT[too few arguments passed (2) - 3 params expected␤current instr.: '_block25' pc -342566453 ((unknown file):-1)␤]

[16:41] <pmichaud> rakudo:   for "foo".split( /\n ** 2..*/ ) { .say.WHAT }

[16:41] <p6eval> rakudo 32543: OUTPUT[foo␤]

[16:41] <pmichaud> rakudo:   for "foo".split( /\n ** 2..*/ ) { say $_.WHAT }

[16:41] <p6eval> rakudo 32543: OUTPUT[Str␤]

[16:41] <jnthn> pmurias: What moritz said. But calls boil down to the invoke VTABLE method.

[16:42] <moritz_> rakudo:   for "foo".split( /\n ** 2..*/ ) { say $_.trans( [ 'o' => ' ' ] ) }

[16:42] <p6eval> rakudo 32543: OUTPUT[too few arguments passed (2) - 3 params expected␤current instr.: '_block25' pc -342579023 ((unknown file):-1)␤]

[16:43] <pmichaud> rakudo:  "foo".split( /\n ** 2..*/ )[0].trans( [ 'o' => ' ' ]);

[16:43] <p6eval> rakudo 32543: OUTPUT[too few arguments passed (2) - 3 params expected␤current instr.: '_block11' pc -342477533 ((unknown file):-1)␤]

[16:43] <pmichaud> rakudo:  "foo".split( /\n ** 2..*/ ).[0].trans( [ 'o' => ' ' ]);

[16:43] <p6eval> rakudo 32543: OUTPUT[too few arguments passed (2) - 3 params expected␤current instr.: '_block11' pc -342450071 ((unknown file):-1)␤]

[16:43] <jnthn> I think that you'd be able to make postcircumfix:<( )> take things into a capture, though.

[16:43] <pmichaud> oh, I see the issu

[16:43] <pmichaud> issue

[16:43] <jnthn> pmurias: We don't explicitly construct a capture right now.

[16:43] <pmichaud> the strings that come back from PGE aren't Perl6Str

[16:44] <jnthn> Ah.

[16:44] <pmichaud> so it's calling the .trans method in (Parrot) String instead of (Perl 6) Str

[16:44] <jnthn> The Parrot string has a trans method?

[16:44] * jnthn didn't know that

[16:44] <jnthn> Makes sense though.

[16:44] <pmichaud>     METHOD trans(STRING *src, PMC *table) {

[16:45] <masak> pmichaud: is it easy to fix?

[16:45] <pmichaud> masak: not at the moment.

[16:46] <jnthn> Needs HLL. :-(

[16:46] <pmichaud> we need to get HLL type mapping in place.

[16:46] <masak> oh well.

[16:46] <pmichaud> and then PGE will have to become smart enough to do that mapping.

[16:46] <jnthn> pmichaud: I forgot what that blocked on? Or is it just tuits?

[16:46] * masak will try to work around it somehow

[16:46] <pmichaud> tuits, I think

[16:46] <pmichaud> masak: try prefix:<~>

[16:47] <masak> pmichaud: I will, thx

[16:47] *** cosimo left
[16:47] <pmurias> jnthn: postcircumfix:<( )> takes a capture in smop and spec currently

[16:47] <pmichaud> rakudo:   for "foo".split( /\n ** 2..*/ ) { (~$_).trans( [ 'o' => ' ' ] ) }

[16:47] <p6eval> rakudo 32545: OUTPUT[too few arguments passed (2) - 3 params expected␤current instr.: '_block25' pc -342619037 ((unknown file):-1)␤]

[16:47] <pmichaud> we may need to fix prefix:<~> to always return Perl6Str

[16:48] <pmichaud> (won't be necessary after HLL mapping, though.)

[16:48] <jnthn> pmurias: Sure, that makes sense.

[16:48] <japhb> jnthn: oh bother (re: packed data and (Un)ManagedStruct difficulties) ... that's going to make life ... interesting.  Hmmm, is there a Perl 6 pack()/unpack() pair yet?  I could go from that angle.

[16:49] <jnthn> No, I think not.

[16:50] <pmichaud> we can certainly write a pack()/unpack() or other helper function for it.

[16:50] <rakudo_svn> r32546 | jonathan++ | [rakudo] Make grammars in namespaces work correctly. Patch courtesy of Chris Dolan.

[16:50] <rakudo_svn> r32547 | jonathan++ | [rakudo] Add a namespace/grammar related spectest file.

[16:50] <rakudo_svn> r32548 | pmichaud++ | [rakudo]:  fix trailing space

[16:51] * jnthn looks at what doing the managedstruct stuff the real way from Perl 6 would take.

[16:52] <jnthn> Ouch.

[16:53] <jnthn> japhb: Actually implemetning what's under the heading Compact Structs in S09 is a bit of work.

[16:54] <jnthn> There's a bunch of stufff I've not really thought about so much yet.

[16:54] <japhb> jnthn: I believe it.

[16:54] <japhb> pmichaud: how much work would it be to do the pack()/unpack()?

[16:54] <pmichaud> japhb: I don't know how well pack/unpack are defined for Perl 6 yet (more)

[16:55] <pmurias> jnthn: it was a thing we were unsure about for a bit, and i was having doubts again for a moment about it while implementing .() ;)

[16:55] *** pmurias left
[16:55] <pmichaud> japhb: however, in this particular case you might look at writing a custom pair of functions to do it and importing those

[16:55] <pmichaud> japhb: I'm not completely familiar with ManagedStruct under Parrot (nevr had a use or need for it)

[16:56] <jnthn> pmichaud: It lets you construct a C-level struct, dynamically.

[16:56] *** alester joined
[16:56] <japhb> OR array, or combination of the two

[16:56] <pmichaud> jnthn: sure, I've just never used it.

[16:56] <jnthn> It'll probably be somewhat involved when we do compact structs in Rakudo.

[16:57] <jnthn> Really we don't have any of the native types exposed at Rakudo level at all yet though.

[16:57] <japhb> It basically shows a normal keyed interface as if it wasn't packed, but marshals magically through NCI to/from the packed equivalents.

[16:57] <jnthn> Which is really a pre-req.

[16:58] <japhb> Parrot will need to finally admit its native type system is lacking when you have to do the Perl version.  Unless you just tell Parrot it's a buffer of bytes and back the heck off, thankyouverymuch.

[16:58] *** zamolxes left
[17:03] *** ejs_ left
[17:04] *** ejs_ joined
[17:05] *** ashizawa_ left
[17:07] *** abra joined
[17:07] *** schmalbe joined
[17:15] *** masak left
[17:16] *** zamolxes joined
[17:20] *** ludan left
[17:24] *** smg joined
[17:30] *** apeiron left
[17:31] *** apeiron joined
[17:40] *** ejs_ left
[17:45] *** tomyan left
[17:48] *** pbuetow joined
[17:50] *** meppl joined
[17:51] <meppl> good evening

[18:04] <japhb> jnthn, pmichaud: Is there a way to specify constants in a separate module in Rakudo, and after 'use FooConstants;' have them participate in any optimizations that literal constants would have?

[18:05] *** abra left
[18:09] <japhb> jnthn: what signature are you planning for the simplified MAIN?

[18:12] <jnthn> japhb: Not that I know of - we don't have "is constat" implemented yet, either, though...

[18:12] <japhb> Fair enough.

[18:13] <TimToady> there is no "is constant" that I know of...

[18:13] <jnthn> Simplified MAIN will just pass the command line args along. If you've written a MAIN that takes that many positional arguments, you'll get that one (of course declare multi if you're doing that to write many)

[18:13] <TimToady> there's a constant declarator though

[18:13] <jnthn> That's all I'm doing for now - this is really Jerry's turf. :-)

[18:13] <japhb> TimToady: Either you read everything that goes by here, or you've got a very fine sixth sense ....

[18:14] <TimToady> the two are not mutually exclusive  :)

[18:14] <japhb> True.

[18:14] <japhb> But I meant that in the math 'or' sense, not the English bastardization.

[18:15] <PerlJam> TimToady: Tell the truth.  You didn't really get *ordinary* corneas, did you?  You're really a cyborg now.

[18:15] <TimToady> will that MAIN break badly when named args get mapped to *% params?

[18:15] <japhb> jnthn: So if I want to ignore all, can I declare 'sub MAIN { ... }', and to catch all just do 'sub MAIN (*@args) {...}'

[18:16] <TimToady> I don't know who my (one) cornea came from, but both my lenses are plastic, though different from each other

[18:16] <jnthn> Yes, that should work, apart from slurpy may be broken at the moment.

[18:16] <TimToady> with slightly different transmission of near UV

[18:16] <japhb> jnthn: oh.

[18:16] <TimToady> so my black lights look violeter in one eye than the other

[18:16] <japhb> Will @*ARGS still be visible, at least, if slurpy args are broken?

[18:16] <jnthn> japhb: Yes.

[18:16] <japhb> TimToady: freaky.  and cool.

[18:17] <PerlJam> TimToady: ah ... only one cornea, eh?  So the other eye has the device that links you directly to the internet?  :)

[18:17] <japhb> jnthn: great, thanks.

[18:17] <jnthn> TimToady: It's not meeting the spec for sure. :-)

[18:17] <TimToady> maybe it should be called NOTMAIN or something :)

[18:17] <jnthn> TimToady: particle's grant covers doing that, I'm just getting japhb something simple to work with for now.

[18:17] <japhb> Somebody is getting paid well to make it correct ....

[18:17] <jnthn> Right.

[18:21] *** justatheory left
[18:24] <jnthn> I'm sure particle is going to be happy to find we already have introspectable signatures when he gets to doing it. :)

[18:24] *** justatheory joined
[18:26] *** adc_Penner joined
[18:34] *** Bzek left
[18:37] *** rindolf left
[18:38] *** rindolf joined
[18:40] *** bacek_ left
[18:40] *** bacek joined
[18:42] *** ZuLuuuuuu joined
[18:47] *** px_ joined
[18:56] *** apeiron left
[18:57] *** pbuetow left
[19:00] <pugs_svn> r22983 | moritz++ | [t/spec] test for rakudo regression (Num += Int)

[19:02] *** DemoPhreak is now known as DemoFreak

[19:20] *** bacek left
[19:29] *** alexn_org joined
[19:30] <rakudo_svn> r32551 | chromatic++ | [Rakudo] Tidied some code in Perl6MultiSub PMC.  No functional changes.

[19:30] <rakudo_svn> r32552 | chromatic++ | [Rakudo] Added sub name to multidispatch failure message in Perl6MultiSub PMC.

[19:34] *** jfredett left
[19:39] *** schmalbe left
[19:45] *** xinming_ joined
[19:45] *** xinming left
[19:50] <rakudo_svn> r32554 | jonathan++ | [rakudo] Some very basic support for MAIN entry point sub. Just passes all command line arguments as positionals.

[19:50] <rakudo_svn> r32555 | pmichaud++ | [rakudo]:  Don't do tailcalls for methods called from C. (jonathan++)

[19:56] *** apeiron joined
[20:03] *** Lorn left
[20:25] *** lisppaste3 left
[20:26] *** lisppaste3 joined
[20:29] *** masak joined
[20:30] *** alc left
[20:43] *** pedrob joined
[20:49] *** solar_Ant joined
[21:12] *** rindolf left
[21:19] *** ruoso joined
[21:21] *** ab5tract joined
[21:22] <ruoso> Hello!

[21:24] <masak> ruoso: y0

[21:27] *** Limbic_Region joined
[21:31] *** rdice joined
[21:35] *** masak left
[21:40] *** rdice left
[21:40] *** rdice joined
[21:50] *** jhorwitz left
[21:58] *** alexn_org left
[22:01] *** ruoso left
[22:15] *** rdice left
[22:17] *** ruoso joined
[22:19] *** smg left
[22:19] *** ab5tract left
[22:32] *** nacho_ joined
[22:34] *** adc_Penner left
[22:40] <rakudo_svn> r32567 | jonathan++ | [rakudo] Set scope to $?FOO type variables to be lexical, and set up $?PACKAGE. Gives wrong stringification for root namespace for now (should be Main), but should be correct otherwise.

[22:57] *** pedrob left
[23:05] <ruoso> @tell pmurias we have some leaks in smop again

[23:05] <lambdabot> Consider it noted.

[23:11] *** solar_Ant left
[23:16] *** iblechbot left
[23:22] *** wknight8111 joined
[23:26] <pugs_svn> r22984 | ruoso++ | [smop] now we have s1p_package...

[23:26] <pugs_svn> r22984 | ruoso++ | [mildew] a package declarator defines $?PACKAGE as well..

[23:27] *** bacek joined
[23:32] *** ChrisDavaz left
[23:37] *** DemoFreak left
[23:37] <ruoso> perl6: class Foo { method bar { say $?PACKAGE{"&bar"} }; Foo.bar;

[23:37] <p6eval> rakudo 32567: OUTPUT[Missing '}' at line 1, near ""␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[23:37] <p6eval> ..pugs: OUTPUT[*** ␤    Unexpected end of input␤    expecting ";" or "}"␤    at /tmp/0OFp7ei77f line 2, column 1␤]

[23:37] <p6eval> ..elf 22847: OUTPUT[Parse error in: /tmp/z1VU4wxGBT␤panic at line 1 column 58 (pos 58): Missing right brace␤WHERE:  $?PACKAGE{"&bar"} }; Foo.bar;␤WHERE:                              /\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:255:in `_block_rest'␤  STD_red/std.rb:242:in `block in

[23:37] <p6eval> .....

[23:37] <ruoso> pugs: class Foo { method bar { say $?PACKAGE.{"&bar"} }; Foo.bar;

[23:37] <p6eval> pugs: OUTPUT[*** ␤    Unexpected end of input␤    expecting ";" or "}"␤    at /tmp/8ysX0Fyl6p line 2, column 1␤]

[23:37] <pugs_svn> r22985 | lwall++ | [Cursor] revert last; fix because it breaks !~~ and friends

[23:38] <ruoso> pugs: class Foo { method bar { say $?PACKAGE }; Foo.bar;

[23:38] <p6eval> pugs: OUTPUT[*** ␤    Unexpected end of input␤    expecting ";" or "}"␤    at /tmp/XmMlwHsOOi line 2, column 1␤]

[23:38] <ruoso> pugs: class Foo { method bar { say $?PACKAGE.{"&bar"} }}; Foo.bar;

[23:38] <p6eval> pugs: OUTPUT[*** Class prototype occured where its instance object expected: Foo␤    at /tmp/1h650RWtpl line 1, column 30-49␤       /tmp/1h650RWtpl line 1, column 30-49␤]

[23:38] <ruoso> pugs: class Foo { method bar { say $?PACKAGE.{"&bar"} }}; Foo.new.bar;

[23:38] <p6eval> pugs: OUTPUT[*** Class prototype occured where its instance object expected: Foo␤    at /tmp/Vxzh3iqQFt line 1, column 30-49␤       /tmp/Vxzh3iqQFt line 1, column 30-49␤]

[23:38] <ruoso> pugs: class Foo { method bar { say $?PACKAGE<&bar> }}; Foo.new.bar;

[23:38] <p6eval> pugs: OUTPUT[*** Class prototype occured where its instance object expected: Foo␤    at /tmp/EA7OWfTrjn line 1, column 30-46␤       /tmp/EA7OWfTrjn line 1, column 30-46␤]

[23:38] <ruoso> er

[23:39] <ruoso> are methods registered in the package as well as in the class?

[23:39] <ruoso> pugs: class Foo { method bar { say $?PACKAGE }}; Foo.new.bar;

[23:39] <p6eval> pugs: OUTPUT[Foo␤]

[23:39] <ruoso> pugs: class Foo { method bar { say $?PACKAGE.new }}; Foo.new.bar;

[23:39] <p6eval> pugs: OUTPUT[<obj:Foo>␤]

[23:40] <TimToady> depends on whether they're our or my methods

[23:40] <TimToady> our is the default

[23:40] <ruoso> right... but I was considering if they would only be in the class

[23:42] <TimToady> it is possible that some declarations that currently default to our should default to my instead

[23:43] <ruoso> I wonder what is the use for methods being stored in package

[23:43] <ruoso> *packages

[23:45] *** rhr left
[23:46] <ruoso> TimToady, I understand the generalization of every routine being stored in the package, but does that really applies to methods?

[23:47] *** alester left
[23:48] *** aindilis joined
[23:49] *** smg joined
[23:53] *** ZuLuuuuuu left
