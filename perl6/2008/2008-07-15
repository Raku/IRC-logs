[00:18] *** wknight8111 left
[00:18] *** wknight8111 joined
[00:23] *** icwiener left
[00:31] *** jferrero left
[00:38] *** elmex left
[00:42] *** araujo left
[00:44] *** |jedai| is now known as Jedai

[00:57] *** d4l3k_ joined
[00:57] *** dalek left
[00:57] *** d4l3k_ is now known as dalek

[01:33] *** Limbic_Region left
[01:41] *** meppl left
[01:43] *** meppl joined
[01:45] <meppl> good night

[01:52] *** meppl left
[01:55] *** kanru joined
[02:17] *** nipotan is now known as nipotaway

[02:22] *** scrottie joined
[02:24] *** alester joined
[03:02] *** araujo joined
[03:24] *** agentzh joined
[03:42] *** pbuetow_ joined
[03:53] *** pbuetow left
[04:39] *** Jedai left
[04:58] *** alester left
[05:22] *** Psyche^ joined
[05:25] *** justatheory left
[05:38] *** Patterner left
[05:38] *** Psyche^ is now known as Patterner

[06:15] *** vadim joined
[06:28] *** lambdabot joined
[06:32] *** ashizawa joined
[07:03] *** bacek left
[07:18] *** bacek joined
[07:18] *** masak joined
[07:22] *** barney joined
[07:29] *** xinming_ joined
[07:33] *** bacek left
[07:41] *** dblick joined
[07:41] <dblick> Hi guys. Is there a one liner, somewhat like, `perl -MExtUtils::Embed -e ccopts`, that I can use to get the directory I should install a shared object extension library into?

[07:46] *** rindolf joined
[07:54] *** penk joined
[08:02] *** iblechbot joined
[08:04] *** pmurias joined
[08:07] *** tuxdna joined
[08:21] <pmurias> ingy: searching the log I accidently found out that you inquired about pixie

[08:33] *** bacek joined
[08:47] *** bacek left
[08:50] *** bacek joined
[08:56] *** jferrero joined
[08:57] *** tuxdna left
[08:57] *** tuxdna joined
[08:59] *** bacek left
[08:59] *** elmex joined
[08:59] *** tuxdna left
[09:07] <moritz_> rakudo: sub f(::T $x) { my T $y = 2 * $x; return $y }; say f(2)

[09:07] <p6eval> rakudo 29471: OUTPUT[Type check failed␤current instr.: 'f' pc 224 (EVAL_15:85)␤]

[09:08] <moritz_> rakudo: sub f(::T $x) { my T $y = 2 * $x; say $y.WHAT; return $y }; say f(2)

[09:08] <p6eval> rakudo 29471: OUTPUT[Type check failed␤current instr.: 'f' pc 252 (EVAL_15:91)␤]

[09:08] <moritz_> meh

[09:12] <pmurias> moritz_: i endend implemention you q:identifier[...] suggestion

[09:12] *** Southen_ joined
[09:17] <moritz_> now perhaps we'll find out if it was a good idea ;-)

[09:17] *** tuxdna joined
[09:18] *** tuxdna left
[09:18] *** tuxdna joined
[09:19] *** rindolf left
[09:29] * pmurias has doubt about smop using a refcounting scheme instead of a gc

[09:29] <pmurias> s/doubt/doubts/

[09:36] <moritz_> I'm sure ruoso would welcome a GC, but isn't motivated to write one himself ;-)

[09:37] <moritz_> I don't know how closely you follow parrot development, but the GC is causing troubles over and over again

[09:37] <moritz_> it's just not a trivial piece of software

[09:40] <pmurias> reference counting is causing trouble even as we speak

[09:44] <tuxdna> Hi

[09:44] <moritz_> hi

[09:44] <tuxdna> What is parrot/runtime/parrot/library/STM.pir meant for?

[09:45] <moritz_> from the name I'd guess for software transactional memory

[09:45] <moritz_> but I guess the folks in #parrot on irc.perl.org know bettter ;-)

[09:46] *** bacek joined
[09:46] <pmurias> moritz_: you are right

[09:47] <tuxdna> moritz_: on #parrot there is only me now :-)

[09:47] <pmurias> irc.perl.org

[09:47] <moritz_> tuxdna: on irc.perl.org?

[09:48] <tuxdna> oh i see

[09:48] <tuxdna> thanks

[09:48] <pmurias> moritz_: i hope most development on smop will move to perl6 soon, so memory managment will become less of an issue

[09:49] <moritz_> pmurias: I hope that too. I can try to help with stuff that's written in p6 ;-)

[09:50] *** tuxdna left
[09:52] <pmurias> don't like c much?

[09:53] <moritz_> I avoid it wherever possible

[09:53] *** tuxdna joined
[09:53] <moritz_> it feels so web 1.0 to manage your memory manually, and write beyond array boundaries

[09:54] <pmurias> c support gc with the bohem garbadge collectors

[09:55] <pmurias> * garbage

[09:55] <pugs_svn> r21335 | pmurias++ | [smop]

[09:55] <pugs_svn> r21335 | pmurias++ | added q:identifier[...] to sm0p

[09:55] <pugs_svn> r21335 | pmurias++ | arbitary method names are supported in method calls in s1p

[09:55] <pugs_svn> r21335 | pmurias++ | 15_hash moved to perl6

[09:55] <moritz_> and the guy is called "boehm"

[09:55] <moritz_> ;-)

[09:58] <pmurias> i think i'll have to revive pixie soon to get decent AST

[10:00] <pmurias> raukdo uses PAST?

[10:02] <moritz_> yes

[10:02] <moritz_> plus a bit of inline PIR, iirc

[10:03] <moritz_> ../../parrot perl6.pbc --target=parse $file for a parse tree

[10:03] <pmurias> PAST is too parrot specific iirc, and influenced heavily by pir

[10:04] <moritz_> and ../../parrot perl6.pbc --target=PAST $file for PAST

[10:04] <pmurias> s/influcened/poisoned/

[10:04] <moritz_> pmurias: PAST is on the "create a lexical var, call a method, create a block" level

[10:08] <pmurias> running all parrot languages has it's appeal

[10:09] <pmurias> ls

[10:10] <moritz_> no such file or directory

[10:13] <pmurias> re parse tree i can get a very good one from STD

[10:15] <moritz_> probably better than rakudo's

[10:18] <pmurias> in a greatly better format for sure

[10:29] <pmurias> moritz_: re try to to help, would you be will to help with filling in the {*} blocks in STD to creat elf AST?

[10:30] <moritz_> pmurias: yes

[10:30] *** iblechbot left
[10:30] *** tuxdna left
[10:31] *** tuxdna joined
[10:32] <pmurias> just so nobody is alarmed, no STD's are harmed in the process as the actions are extracted to a seperate file after editing (mechanicly)

[10:33] <moritz_> pmurias: maybe write a short HOWTO that describes which tools to run, how the AST should look like and how to test it?

[10:33] <pmurias> moritz_: i'll fix the toolchain today/tomorrow, so perl6 is used instead of perl5 in the blocks

[10:33] *** bacek left
[10:33] <pmurias> moritz_: ok

[10:33] <pmurias> cycling&

[10:33] *** pmurias left
[10:33] <moritz_> pmurias: ok, no hurry, plenty of other stuff to do for me - just tell me when you're done, and I'll give it a shot

[11:03] *** iblechbot joined
[11:04] *** ruoso joined
[11:35] *** kattana_ joined
[11:39] *** chris2 joined
[11:50] *** alanhaggai joined
[12:02] *** meppl joined
[12:06] *** kattana_ left
[12:21] <planofish> anyone knows about characters and symbols well

[12:21] <planofish> ಮಾದೇಶ􏿽xE0􏿽xB3?ವರರಗೆ ಶರಣ􏿽xE0􏿽xB3? ಮಾದೇಶ􏿽xE0􏿽xB3?ವರಾ what is that?

[12:21] <planofish> it'; supposed to be lil rectangles

[12:22] * moritz_ doesn't see the connection to Perl 6

[12:22] <planofish> isnt

[12:23] <moritz_> then I don't see the connection to #perl6 either

[12:24] <planofish> sheesh

[12:24] <planofish> i just told you it isn't

[12:24] <planofish> god you can nag

[12:24] <masak> planofish: hello. be nice to people.

[12:24] <moritz_> planofish: more polite that straight out telling you that you're off topic, and thus in the wrong place

[12:25] <moritz_> s/that/than/

[12:25] *** mj41_ left
[12:31] *** mj41 joined
[12:37] *** iblechbot left
[12:56] *** vadim left
[12:56] *** cggoebel joined
[13:06] *** ggoebel left
[13:09] *** Chillance joined
[13:17] <rakudo_svn> r29481 | moritz++ | [rakudo] add Complex log() and re-arranged any-num.pir, bacek++

[13:17] <rakudo_svn> r29481 | moritz++ | Patch Curtesy of Vasily Chekalkin <back at bacek.com>

[13:18] <pugs_svn> r21336 | moritz++ | [spec] partially unfudged S29-num/log.t. Still some failures with complex log,

[13:18] <pugs_svn> r21336 | moritz++ | have to investigate more

[13:20] <pmichaud> PAST is not intended to be parrot specific.  yes, there are some Parrot items that leak through, but we're slowly removing those as we evolve the AST

[13:22] *** alanhaggai left
[13:27] <pugs_svn> r21337 | moritz++ | [spec] fixed some Complex.log tests, and unfudged a bit. 

[13:27] <pugs_svn> r21337 | moritz++ | Rakudo fails one test because the result is on a different complex plain that

[13:27] <pugs_svn> r21337 | moritz++ | what is expected

[13:28] *** cmarcelo joined
[13:29] *** pbuetow_ left
[13:32] *** pmurias joined
[13:35] *** ashizawa left
[13:46] *** icwiener joined
[13:52] <pmurias> pmichaud: do you have PAST::Op.pasttype instead of having subclasses?

[13:53] <pmichaud> pmurias: yes.  It's easier to change an attribute than to rebless into a different class.

[13:53] <pmurias> forgot a why :(

[13:54] <pmurias> pmichaud: why would you want to do it?

[13:55] <masak> how would I do if I wanted the proceed-to-next-element effect of a `next`, but not the leave-this-block effect?

[13:56] <moritz_> masak: example?

[13:56] <moritz_> ah I think I know what you mean... dunno if there's an easy syntax for that

[13:56] <pmichaud> change an attribute?  It makes it easy to parse certain operators to always become PAST::Op nodes, and then change the pasttype

[13:56] <pmichaud> for example, infix:<&&>   is implemented as PAST::Op with a pasttype of 'if'

[13:56] <masak> moritz_: let's say I'm parsing a parameter list, and find a flag which takes one argument

[13:57] <masak> moritz_: is there a painstakingly difficult syntax, then?

[13:57] <pmurias> pmichaud: i see

[13:57] <moritz_> masak: iterated over the indexes, and ++ it?

[13:58] <masak> :/

[13:58] <masak> well, I suppose...

[13:58] *** jferrero left
[13:58] <masak> it just seems so primitive to count indices...

[13:58] <moritz_> hehe ;-)

[13:58] <masak> no, really. there are many ways to fail.

[13:58] <moritz_> well, after ++ing the index you also have to check if you exhausted the list

[13:59] <masak> exactly.

[13:59] <moritz_> the canonical answer the questions like this is "refactor your code, and make it so simple that you don't need $Feature" ;-)

[14:00] <masak> in the parameter list case, I think I'd want to raise an error if I exhausted the list

[14:00] <pmurias> masak: you want to do it in a for?

[14:00] *** Alias_ left
[14:00] <masak> moritz_: in this case, I'm just imagining use cases, not needing them

[14:00] *** Alias__ joined
[14:00] <masak> pmurias: yes.

[14:00] <masak> or a while, I suppose

[14:01] *** jhorwitz joined
[14:01] <pmurias> you have to do error checking in your case

[14:02] <pmichaud> parsing argument lists sounds like something where a while makes a bit more sense than a for

[14:03] <pmurias> elf does it like while (@params.elems) { my $flag = @params.shift;if $flag eq '-e' {@params.shift // die } else {...} }

[14:04] <masak> yes, that's a nice extant way to do it

[14:04] <pmichaud> why not just    while (@params) { ... }   ?

[14:04] <pmurias> elf bugs ;)

[14:04] <pmichaud> yes, I can understand that.  :-)

[14:04] <pmichaud> (we find ourselves doing similar things in rakudo :-)

[14:05] <pmurias> it's while ($args.elems) {...} actually

[14:05] <masak> there could profitably be a wiki page about that, I guess: "current workarounds in rakudo"

[14:06] <pmurias> pmichaud: do you think it would make sense to use PAST for elf?

[14:06] <rakudo_svn> r29482 | pmichaud++ | [rakudo]: spectest-progress.csv update, 95 files, 1695 passing tests

[14:06] * [particle] would like to see ast convergence very much

[14:06] *** Alias_ joined
[14:06] *** Alias__ left
[14:07] <pmichaud> pmurias: I don't know.  I'd be very happy if we can converge to something like PAST (saves me reimplementation), but I don't have a lot of experience with ASTs

[14:07] <pmichaud> so I can't say how well it'd work for other environments.  I have tried to keep it as non-Parrot as much as possible

[14:07] <pmichaud> but yes, there are parrotisms that leak through until we get a bit more infrastructure in place

[14:11] <pmurias> pmichaud: is there an easy way to load/dump PAST from/into parrot

[14:11] <pmichaud> pmurias: not yet.

[14:12] <pmurias> that closes the issuse for now ;)

[14:15] <pmurias> the gen_ files in perl6/src are autogenerated?

[14:17] <moritz_> pmurias: yes

[14:17] <pmurias> from?

[14:18] <moritz_> all the others ;-)

[14:18] <moritz_> for example src/gen_builtins.pir is generated from src/{classes,builtins}/*.pir iirc

[14:18] <pmurias> why don't the have a warnings?

[14:19] <pmurias> * warning

[14:19] <moritz_> dunno

[14:24] <pmurias> @seen diakopter

[14:24] <lambdabot> I haven't seen diakopter.

[14:24] <pmichaud> ....warning?

[14:24] <pmurias> # this file is autogenerated

[14:25] <pmichaud> oh.  I suppose I could get PAST and others to add that to the output.

[14:25] <pmichaud> I've been thinking that they belong in a separate gen/ subdirectory, but that got frowned upon by others

[14:26] <pmurias> why?

[14:26] <pmichaud> I don't know.  I think they were hoping that the gen_* files would always be produced by a Makefile rule

[14:27] <pmichaud> (an implicit rule)

[14:28] <pmurias> if you use gnu make extensions the implicit rule could still do it

[14:28] <pmichaud> well, we can't rely on gnu make

[14:29] <pmichaud> anyway, adding a note about being a generated file is a good idea, so I'll do that.

[14:33] *** cognominal_ joined
[14:34] *** iblechbot joined
[14:34] *** icwiener left
[14:34] *** icwiener joined
[14:34] *** icwiener left
[14:34] *** icwiener joined
[14:43] *** tuxdna left
[14:50] <masak> pmichaud: re your mail "S04-related closure question", I can see no other (sensible) alternative than "a: 1\nb: 1\nc: 1\n" and "1\n2\n3\n". if, however, $a() were to be called before the 'my $x = 1;' line was run, I'm not sure what would happen.

[14:55] <pmichaud> masak:  so, you're saying that in the first example that $x is the same in all cases?

[14:55] <masak> yes.

[14:55] <pmichaud> then why not in the second case?

[14:56] <masak> because $x always has the value 1 when the closures are called.

[14:57] <pmichaud> note that the first case doesn't really change if we do    for 1..1 -> $x { ... }    instead of    { my $x = 1; ... }

[14:57] <pmichaud> or I could even do    if 1 -> $x { ... }    instead of   { my $x = 1; ... }

[14:58] <masak> sure.

[14:58] <masak> I still don't really see the difficulty.

[14:58] <masak> maybe I misunderstood something

[14:58] <pmichaud> in both cases, $x is local to the block

[14:58] *** icwiener_ joined
[14:58] <masak> yes.

[14:58] <pmichaud> (in both cases in the original message, $x is local to the block)

[14:58] <masak> right

[14:59] <pmichaud> the get_x() sub is the same in both cases

[14:59] <masak> but in your second code snippet, $x changes.

[14:59] <pmichaud> it's always a different $x

[14:59] <masak> huh?

[15:00] <pmichaud> -> $x { ... }    means that $x is local to the block

[15:00] <masak> yes, sure

[15:00] <masak> but the block in the first example is only run once, right?

[15:00] <pmichaud> in for 1..1 -> $x { ... }    the block is only run once

[15:00] <masak> $x in the block in the first example only exists in one copy, and is only assigned once

[15:01] <pmichaud> just a sec, I'll give a slightly different example

[15:01] <masak> it is not garbage collected, because $b (declared outside) refers to foo which refers to get_x which refers to $x

[15:01] <pmichaud> nopaste?

[15:02] <pmichaud> what's the common nopaste for this chan?

[15:02] <Tene> http://sial.org/pbot/perl6

[15:02] <lambdabot> Title: sial.org Pastebot - pasteling

[15:02] <moritz_> see /topic ;-)

[15:02] <pmichaud> I never see the topic

[15:04] <pasteling> "pmichaud" at 76.183.97.54 pasted "another example" (15 lines, 276B) at http://sial.org/pbot/31589

[15:04] <masak> yes, _that_ looks problematic :)

[15:05] <masak> how can we even declare a function inside the body of a for loop?

[15:05] <masak> that can't be sane... :)

[15:05] <moritz_> unless it's a 'my sub'

[15:05] <pmichaud> okay, how about this one?

[15:06] <masak> seems to me there must be either exactly one foo(), in which case it's anyone's guess what it'll return, or exactly three foo(), returning 1, 2 and 3 respectively

[15:06] <moritz_> I thought a bit more about this, and IMHO the only solution that will DTRT is to forbid named closures :/

[15:07] *** cmarcelo left
[15:07] <pasteling> "pmichaud" at 76.183.97.54 pasted "another example" (18 lines, 330B) at http://sial.org/pbot/31590

[15:07] <pmichaud> there, I got rid of the loop.

[15:08] <masak> pmichaud: so let me get this straight. foo() is defined inside bar($x), but you can still call it from the outside?

[15:08] <moritz_> can't we just say that 'sub foo ...' is the same as '&foo = sub {...}', and then define default scoping rules for &foo?

[15:09] <pmichaud> that would be &foo := sub { ... }

[15:09] <Tene> Yeah, why is "sub foo() {...}" available in the outer scope?

[15:09] <pmichaud> sub foo() { ... }   is equivalent to   "our sub foo() { ... }"

[15:09] <Tene> Hmm.

[15:10] <masak> I gotta go. backlog later. this seems a very vital discussion.

[15:10] *** donaldh joined
[15:11] *** icwiener left
[15:11] <pmichaud> masak: (for backlog)   if we claim that { sub foo() { ... } }  defines a foo that is callable from the outside, then the same should hold true for   sub bar($x) { sub foo() { ... } }

[15:11] <pmichaud> there's no real difference between them.

[15:13] *** cmarcelo joined
[15:21] *** gugod left
[15:22] *** pbuetow_ joined
[15:23] *** smg left
[15:23] *** smg joined
[15:30] *** penk left
[15:31] *** alanhaggai joined
[15:34] <Lorn> cmarcelo: hey

[15:34] <cmarcelo> Lorn: hello

[15:35] <Lorn> cmarcelo: are you working with pugs/haskell yet?

[15:36] *** hercynium joined
[15:37] <pugs_svn> r21338 | pmurias++ | STD5_dump_match uses --vertical as default, accepts --horizontal

[15:37] <pugs_svn> r21338 | pmurias++ | added a hack to DumpMatch to survive self referencial matches

[15:37] <pmurias> Lorn: pugs isn't actively developed now

[15:37] <cmarcelo> not much right now... I was planning to update our svn repo to reflect the package split audreyt did to push packages to Hackage (haskell's cpan).. but didn't have time yet... :-(

[15:38] *** cognominal_ left
[15:38] <cmarcelo> Lorn: ^

[15:38] <Lorn> audreyt is missing yet? :P

[15:38] <masak> pmichaud: what about 'if $not_likely { sub foo() { ... } }'?

[15:39] <moritz_> s/missing/not very active/

[15:41] <cmarcelo> Lorn: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Pugs

[15:41] <lambdabot> Title: HackageDB: packages by category, http://tinyurl.com/yqov7f

[15:41] <pmurias> s/yet/still/

[15:43] <pmurias> TimToady: nextsame is used only by ws?

[15:43] *** cognominal_ joined
[15:44] *** Exodist joined
[15:45] <pmichaud> masak:  (if $notlikely)    still no different

[15:45] <pmichaud> as I understand it, sub foo() exists regardless of the status of $not_likely

[15:46] <pmichaud> because the binding is made at compile time

[15:49] <masak> ok

[15:50] *** Jamtech joined
[15:50] <masak> but if the binding is made at compile time, how can 'for 1..3 -> $x { sub get_x() { return $x; } }' refer to the three different values of $x? is that the kernel of the problem?

[15:52] <pmichaud> perhaps

[15:52] <moritz_> masak: binding to a sub name doesn't have to happen at the same time as binding to the lexical pad

[15:52] <pmichaud> that's what my question to p6l was essentially about

[15:52] <pmichaud> note that this doesn't only occur in loops -- it also happens with recursion

[15:53] <pmichaud> so if    sub bar($x) {   sub get_x() { return $x; } }   works, then the for loop can use the same principle.

[15:53] *** planofish left
[15:54] <masak> this is all very interesting, but very subtle... at least to me, since I haven't really thought about it much

[15:57] <pmichaud> right.  Unfortunately I need a few more clues so that we can get Parrot's lexical model working right.

[15:57] <pmichaud> where "right" means "supporting Perl 6 semantics"

[15:57] <pmichaud> gotta run errands -- bbiaw

[15:59] <masak> seems what we want to do is identify the use cases

[15:59] <masak> and then deduce the semantics from there :)

[15:59] *** cggoebel left
[15:59] <moritz_> a current use case is to avoid circular references in closures in p5

[16:00] <moritz_> but our cool garbage collection should eliminate that

[16:01] *** ggoebel joined
[16:02] <masak> moritz_: you mentioned that IYHO named closures had to go. what did you mean?

[16:03] <moritz_> masak: defining a named sub (and thus one that is globally visible) that depends on the lexical pad should be forbidden, because there are no obivous right semantics (like the many examples we dicussed here)

[16:04] <masak> right.

[16:04] <masak> and a 'lexical pad' is... the environment inside a sub?

[16:06] <moritz_> inside any block

[16:07] <masak> ok

[16:07] <moritz_> other options include (1) making the sub local by default (like 'my sub foo')

[16:07] <moritz_> (2) making the name only available after the definition was first executed at runtime

[16:08] <moritz_> and (3) code in C instead ;-)

[16:08] <masak> :)

[16:08] <moritz_> $ perl -wcle 'sub foo { my $x = shift; sub bar { $x }}'

[16:08] <moritz_> Variable "$x" will not stay shared at -e line 1.

[16:08] <masak> so, to repeat, according to you a closure should not all of (1) have a name, (2) be global, (3) use the lexical pad

[16:09] <moritz_> a closure *has* to use the lexical pad to be a closure

[16:09] <masak> ah, so Perl 5 is already aware of these problems

[16:09] <masak> ah, ok

[16:09] <moritz_> it's aware, yes

[16:09] <moritz_> but I don't know if the "solution" is p6-compatible

[16:09] <masak> so it's really the conflict between a closure having a name and being globally visible

[16:10] <masak> no, that can't be it

[16:10] <TimToady> the basic problem is that you're storing the ref to the closure in a place that is "too global"

[16:10] <masak> _because_ a named closure is globally visible, the resulting access to its lexical pad creates strange problems

[16:11] <moritz_> actually having a name makes it globally visible *at compile time* 

[16:11] <masak> ah, yes.

[16:11] <TimToady> we could fix *some* of the problems by reinstalling the global ref whenever the def is "executed"

[16:11] <masak> does that make a difference? we won't bu calling it till runtime anyway

[16:12] <masak> ^ to moritz_ 

[16:12] <moritz_> TimToady: what does that mean in the if 0 -> { my $x = 3; sub foo { return $x }}; case?

[16:12] *** armagad joined
[16:13] <TimToady> but it might well be the sort of thing where a well-placed prohibition prevents certain types of accidental spaghetti

[16:13] <moritz_> masak: it makes a difference, becase it can be called at run time before its lexical pad is initialized with values

[16:13] <masak> moritz_: exactly.

[16:13] <masak> like $a()

[16:14] <masak> TimToady: what does your reinstalling solution do for $a()?

[16:14] <moritz_> TimToady: so outright forbid calling foo() in my example unless the surrounding scope has been executed at least once?

[16:14] <TimToady> it's a double bind, first ::= then each subsequent time with :=

[16:15] <masak> a double bind :) that's how I feel about this topic

[16:15] <TimToady> it's hard to know what the user expects or should expect here

[16:15] <TimToady> I do know that it hurts my brane, so it must hurt other people's branes too...

[16:15] <moritz_> TimToady: it certainly hurts mine and pmichaud's ;-)

[16:16] <TimToady> the thing about an anon sub is that it is executed right there, and we know when the clone is supposed to happen

[16:17] <TimToady> I think users will expect the same clone for a named sub, but will also expect the preclone done by the compiler to work

[16:17] <TimToady> hence both ::= and :=

[16:17] *** rlb3 joined
[16:18] <TimToady> actually, the ::= clone is likely to be the proto-clone generated by the compiler

[16:18] <TimToady> since it has to do lexical lookups at compile time to figger out what's what anyway

[16:19] <TimToady> so maybe there's no explicit ::= and we only need to add in the := semantics when the execution point passes the definition

[16:19] <TimToady> (btw, I think the verbiage about "when taking a reference" is probably bogus)

[16:20] <TimToady> trying to clone the closure at the point of the ref is madness, probably

[16:20] <TimToady> and not what users will expect in any case

[16:22] <moritz_> what do users inspect in such mad cases?

[16:23] *** chris2 left
[16:23] <TimToady> they expect the computer to guess right :)

[16:23] <moritz_> ;-)

[16:23] <moritz_> so we should make it a stochastical process

[16:24] <TimToady> generally speaking, computers should be forbidden from guessing unless told to do so explicitly.  maybe that's the 4th law of robotics...

[16:25] <masak> moritz_: I know you're kidding, but I just have to point out that even the deterministic version of this problem hurts my brain

[16:26] <moritz_> masak: we have to accept that somtimes only a non-deterministic solution exists (at least in quantum mechanics ;-)

[16:27] <masak> moritz_: sure. or at least, the projected data available to us empirically looks non-deterministic

[16:27] <masak> which is the same thing in a materialistic world view.

[16:27] <masak> gotta go again

[16:27] <TimToady> it seems to me that when audreyt was grilling me about pugs semantics, we ended up moving all the := clonings up to the front of the lexical scope in question so that forward refs would work right

[16:27] <masak> good luck with the closure semantics!

[16:28] *** masak left
[16:28] <moritz_> welcome to #perl-philosphy

[16:32] *** ingy left
[16:34] *** alanhaggai_ joined
[16:34] <moritz_> should we allow interpolation of junctions into regexes?

[16:35] <moritz_> I mean junction semantics could be mapped fairly well to regexes

[16:36] *** ggoebel left
[16:38] <TimToady> alternatives are already | junctions, basically

[16:38] <moritz_> yes

[16:38] <moritz_> and there are & delimted lists also

[16:38] <TimToady> on the other hand, $foo is not terribly self documenting

[16:39] <moritz_> aye

[16:39] *** hercynium left
[16:39] <TimToady> so I'd probably stuff the alternatives into @foo at least

[16:39] <TimToady> another thing is that | in regex is not really non-deterministic

[16:40] <TimToady> whereas junctions are supposed to be

[16:40] <TimToady> (in the sense that you shouldn't rely on the ordering)

[16:40] <TimToady> regex alternation is required to do LTM and tie-breaking by original order

[16:42] *** cjfields joined
[16:42] <TimToady> I wonder if @$junction will work and also provide documentation of plurality...

[16:44] <TimToady> probably can't work for & case, if cast to @ is just pulling out values...

[16:44] <TimToady> ah well, at some point they just have to name their variables right

[16:45] <moritz_> well, if you don't think it's useful I won't feel too bad ;)

[16:45] *** kanru left
[16:45] <TimToady> hmm, and I think it'll probably autothread correctly, given an underlying mech like STD uses

[16:45] <TimToady> since $foo turns into $C->_EXACT($foo) more or less

[16:46] <moritz_> interpolation autothreads? so my $x = 2 | 3; ("a$x").perl will give me 'a2' | 'a3' ?

[16:46] <TimToady> well, maybe not in P5  :)

[16:46] <TimToady> interpolation is just concatenation

[16:47] <moritz_> ok, makes sense

[16:47] <TimToady> pugs: my $x = 2 | 3; ("a$x").perl

[16:47] <p6eval> pugs: RESULT["(\"a2\" | \"a3\")"]

[16:47] <TimToady> there you have it

[16:47] <moritz_> wow, it even works ;)

[16:47] <moritz_> I should check if there are tests for that

[16:48] *** alanhaggai left
[16:48] <cjfields> perl6: say / \s+/.WHAT

[16:48] <p6eval> elf 21338: OUTPUT[Regexp␤]

[16:48] <p6eval> ..pugs: OUTPUT[Regex␤]

[16:48] <p6eval> ..rakudo 29485: OUTPUT[Block␤]

[16:49] *** alanhaggai_ is now known as alanhaggai

[16:49] <moritz_> rakudo++ for creativity ;)

[16:50] <cjfields> elf is off (should be Regex, not Regexp)

[16:50] <Auzon> That's because P5's ref uses Regexp, I think.

[16:50] <moritz_> cjfields: my guess is that elf uses p5 internally and just frobs the output of `ref $obj'

[16:51] <cjfields> I think rakudo's response is b/c regexes haven't been fully implemented yet.

[16:51] <cjfields> Auzon: ok

[16:51] <moritz_> cjfields: is your current patch for Str.trans in the RT?

[16:51] <moritz_> cjfields: and should it be applied?

[16:52] *** nipotaway is now known as nipotan

[16:52] <cjfields> yes, and yes

[16:52] <cjfields> Though it doesn't fully implement acc. to S05 

[16:53] <moritz_> most builtins don't work fully according to the specs ;-)

[16:53] <cjfields> Need to allow regexes, closures still, but everything else works

[16:53] *** icwiener_ is now known as icwiener-_-

[16:54] *** icwiener-_- is now known as icwiener

[16:55] <moritz_> cjfields: I'll look for obvious insanities, fix trailing spaces, make spectest_regression and then commit

[16:55] <cjfields> okay.  

[16:56] * cjfields just recently found the magic of svn diff

[16:56] <cjfields> help to read the docs

[16:57] <moritz_> which magic do you mean?

[16:58] <cjfields> as in not using regular diff as I've always used it, just run 'svn diff -c'

[16:58] <cjfields> 'tis nice

[16:59] <cjfields> BTW, depending on the commit we may need to add S05-transliteration/trans.t to spectest_regression

[16:59] <moritz_> cjfields: I'll do that in one commit

[17:01] *** hercynium joined
[17:08] <rakudo_svn> r29490 | moritz++ | [rakudo] add and test Str.trans, cjfields++

[17:08] <rakudo_svn> r29490 | moritz++ | Patch courtesy of Chris Fields <cjfields at uiuc.edu>

[17:08] <rakudo_svn> r29490 | moritz++ | Adds one file to spectest_regression, +37 passing tests

[17:08] <cjfields> thanks

[17:09] <moritz_> thank *you*

[17:09] <cjfields> I'll probably work on that a bit more to get it closer, but I'll add that as a separate patch

[17:10] <moritz_> I'm going to resolve that ticket

[17:10] <cjfields> ok

[17:12] *** rindolf joined
[17:17] *** cjfields_ joined
[17:18] <cjfields_> perl6: say " <>&".trans( [ / \h /,   '<',    '>',    '&'    ] =>  [ { }, { }, '&gt;', '&amp;' ]);

[17:18] <p6eval> elf 21338: OUTPUT[Can't call method "trans" without a package or object reference at (eval 117) line 3.␤ at ./elf_f line 3861␤]

[17:18] <p6eval> ..pugs: OUTPUT[ &gt;&amp;␤]

[17:18] <p6eval> ..rakudo 29490: OUTPUT[ _block29&gt;&amp;␤]

[17:19] <cjfields_> perl6: say " <>&".trans( ([' ',      '<',    '>',    '&'    ] => ['&nbsp;', '&lt;', '&gt;', '&amp;' ]));

[17:19] <p6eval> elf 21338: OUTPUT[Can't call method "trans" without a package or object reference at (eval 117) line 3.␤ at ./elf_f line 3861␤]

[17:19] <p6eval> ..pugs: OUTPUT[&nbsp;&lt;&gt;&amp;␤]

[17:19] <p6eval> ..rakudo 29491: RESULT[&nbsp;&lt;&gt;&amp;␤1]

[17:20] <moritz_> can you even .trans on a string literal?

[17:20] <moritz_> I thought they are immutable

[17:20] <cjfields_> .trans doesn't work in-place

[17:21] <cjfields_> you have to use .=trans to get in-place transliteration (which I would assume fails for immutables)

[17:21] <moritz_> ok

[17:22] <moritz_> rakudo: print  <>&".trans( ([' ',      '<',    '>',    '&'  => ['&nbsp;', '&lt;', '&gt;', '&amp;' ]));

[17:22] <p6eval> rakudo 29491: OUTPUT[Statement not terminated properly at line 1, near "&\".trans( "␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[17:22] <cjfields_> I don't think in-place works

[17:22] <moritz_> rakudo: print  <>&".trans( ([' ',      '<',    '>',    '&'  => ['&nbsp;', '&lt;', '&gt;', '&amp;' ]);

[17:22] <p6eval> rakudo 29491: OUTPUT[Statement not terminated properly at line 1, near "&\".trans( "␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[17:22] <moritz_> cjfields: ok, I was just confused

[17:22] <cjfields_> rakudo: print "<>&".trans( ([' ',      '<',    '>',    '&'  => ['&nbsp;', '&lt;', '&gt;', '&amp;' ]);

[17:22] <p6eval> rakudo 29491: OUTPUT[Statement not terminated properly at line 1, near "( ([' ',  "␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[17:23] <cjfields_> rakudo: print "<>&".trans( ([' ',      '<',    '>',    '&'  => ['&nbsp;', '&lt;', '&gt;', '&amp;' ]));

[17:23] <p6eval> rakudo 29491: OUTPUT[Statement not terminated properly at line 1, near "( ([' ',  "␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[17:23] <moritz_> rakudo: print  "<>&".trans( [' ',      '<',    '>',    '&'  => ['&nbsp;', '&lt;', '&gt;', '&amp;' ]);

[17:23] <p6eval> rakudo 29491: OUTPUT[Statement not terminated properly at line 1, near "( [' ',   "␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[17:23] <moritz_> ah, missing ]

[17:23] <moritz_> rakudo: print  "<>&".trans( [' ',      '<',    '>',    '&']  => ['&nbsp;', '&lt;', '&gt;', '&amp;' ]);

[17:23] <p6eval> rakudo 29491: OUTPUT[&lt;&gt;&amp;]

[17:23] <moritz_> YaY

[17:23] <moritz_> cjfields++

[17:24] <cjfields_> thanks

[17:24] <cjfields_> say 'ABCDEFG'.trans('A..Z' => 'a..z');

[17:24] <cjfields_> rakudo: say 'ABCDEFG'.trans('A..Z' => 'a..z');

[17:24] <p6eval> rakudo 29491: OUTPUT[abcdefg␤]

[17:25] *** justatheory joined
[17:26] <cjfields_> rakudo: say 'ABCDDDDEFG'.trans(:s, 'A..Z' => 'a..z');

[17:26] <p6eval> rakudo 29491: OUTPUT[abcdefg␤]

[17:27] <Auzon> rakudo: say '&lt;&gt;&amp;'.trans(['&lt;', '&gt;', '&amp;'], ['<', '>', '&']);

[17:27] <p6eval> rakudo 29491: OUTPUT[Must pass a List of Pairs for transliteration␤current instr.: 'parrot;Any;trans' pc 10268 (src/gen_builtins.pir:6556)␤]

[17:27] <moritz_> Auzon: s/,/=>/

[17:27] <Auzon> rakudo: say '&lt;&gt;&amp;'.trans(['&lt;', '&gt;', '&amp;'] => ['<', '>', '&']);

[17:27] <p6eval> rakudo 29491: OUTPUT[<>&␤]

[17:27] <Auzon> yeah, I saw that :)

[17:27] <moritz_> p5 vs p6

[17:27] <moritz_> p6 wins ;)

[17:27] <Auzon> Nah, I just misread the original statement

[17:28] *** iblechbot left
[17:28] <Auzon> but the error message is helpful indeed :)

[17:29] <cjfields_> yes, made sense to me to add that in

[17:29] <moritz_> if we just relied on MMD it would have said "no applicable method found" or "Type mismatch in MMD"

[17:30] <Auzon> Though, isn't it a Pair of Lists instead of a List of Pairs?

[17:30] <cjfields_> Recent changes to S05 will require me to change a few things (spaces are always important, for instance), but it works for now

[17:31] <cjfields_> No, you can use a List of Pairs

[17:32] <pmichaud> (moving all := clonings to front of lexical scope) -- that's essentially the solution we were coming up with in Parrot -- i.e., have all of the lexical bindings take place at the beginning of the enclosing block

[17:32] <cjfields_> rakudo: say "ABC".trans( ('A'=>'a'), ('B'=>'b'), ('C'=>'c') )

[17:32] <p6eval> rakudo 29491: OUTPUT[abc␤]

[17:32] <pugs_svn> r21339 | Auzon++ | [gsoc_spectest] simple smartlink cleanup

[17:32] <Auzon> cjfields_++

[17:32] <ruoso> pmurias, hi... 

[17:32] <lambdabot> ruoso: You have 3 new messages. '/msg lambdabot @messages' to read them.

[17:33] <Auzon> rakudo: say 'abc'.trans('a' => 'b', 'b' => 'c', 'c' => 'a');

[17:33] <p6eval> rakudo 29491: OUTPUT[bca␤]

[17:33] <Auzon> I like that both ways are possible :)

[17:33] *** cjfields left
[17:34] <cjfields_> it's fairly nice.  TimToady made a few clarifications which I am working on which will be nice

[17:34] <cjfields_> so you can do something like:

[17:35] <cjfields_> $str.=trans( / \s+ / => ' ' );  # squash all whitespace to one space

[17:35] <cjfields_> or have the left side of the pair be a closure

[17:36] <cjfields_> (just not yet)

[17:37] <Auzon> rakudo: my %hash = <a b b c c a>; say 'abc'.trans(%hash.keys => %hash.values)

[17:37] <p6eval> rakudo 29492: OUTPUT[bca␤]

[17:37] <pmichaud> rakudo:  my %hash = <a b b c c a>; say 'abc'.trans(%hash.pairs);

[17:37] <p6eval> rakudo 29492: OUTPUT[Method 'pairs' not found for invocant of class 'Perl6Hash'␤current instr.: '_block11' pc 94 (EVAL_11:33)␤]

[17:37] <pmichaud> we should fix that.

[17:38] <pmichaud> rakudo:  my %hash = <a b b c c a>; say 'abc'.trans(%hash.list);

[17:38] <p6eval> rakudo 29492: OUTPUT[Must pass a List of Pairs for transliteration␤current instr.: 'parrot;Any;trans' pc 10268 (src/gen_builtins.pir:6556)␤]

[17:38] <Auzon> perl6: my %hash = <a b b c c a>; %hash.pairs.say

[17:38] <p6eval> elf 21339: OUTPUT[Pair=HASH(0x86cd2a0)Pair=HASH(0x881ad38)Pair=HASH(0x881bf68)Pair=HASH(0x881bfa8)Pair=HASH(0x881bfd8)Pair=HASH(0x881bf98)␤]

[17:38] <p6eval> ..pugs: OUTPUT[c ab ca b␤]

[17:38] <p6eval> ..rakudo 29492: OUTPUT[Method 'pairs' not found for invocant of class 'Perl6Hash'␤current instr.: '_block11' pc 88 (EVAL_12:31)␤]

[17:38] <cjfields_> interesting...

[17:38] <pmichaud> rakudo:  my %hash = <a b b c c a>; say 'abc'.trans(list(%hash));

[17:38] <p6eval> rakudo 29492: OUTPUT[Must pass a List of Pairs for transliteration␤current instr.: 'parrot;Any;trans' pc 10268 (src/gen_builtins.pir:6556)␤]

[17:38] <pmichaud> rakudo:  my %hash = <a b b c c a>; say (%hash,).perl;

[17:38] <p6eval> rakudo 29492: OUTPUT[[{"a" => "b", "b" => "c", "c" => "a"}]␤]

[17:39] <pmichaud> Hash probably need a little work -- hasn't been updated since the List/Array changes.

[17:40] <ruoso> /usr/bin/env: ruby: No such file or directory  (oops)

[17:40] <ruoso> heh...

[17:42] <ruoso> ../../../misc/elfish/elfX//../../STD_red/STD_red_run:93: syntax error, unexpected '>'

[17:43] <ruoso> pmurias, ^ any idea on what can I do to fix that?

[17:43] *** alanhaggai_ joined
[17:53] <Auzon> rakudo: my @arr = <1 3 2 5 4 7 6>; say @arr.sort({$^a <=> $^b});

[17:53] <p6eval> rakudo 29493: OUTPUT[1234567␤]

[17:53] <Auzon> rakudo: my @arr = <1 3 2 5 4 7 6>; say @arr.sort(-> $x, $y {$x <=> $y});

[17:53] <p6eval> rakudo 29493: OUTPUT[Statement not terminated properly at line 1, near "(-> $x, $y"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[17:53] <Auzon> rakudo: my @arr = <1 3 2 5 4 7 6>; my $sort = -> $x, $y {$x <=> $y}; say @arr.sort($func);

[17:53] <p6eval> rakudo 29493: OUTPUT[Statement not terminated properly at line 1, near "= -> $x, $"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[17:54] <Auzon> rakudo: my @arr = <1 3 2 5 4 7 6>; my $sort = sub {$^a <=> $^b}; say @arr.sort($func);

[17:54] <p6eval> rakudo 29493: OUTPUT[Scope not found for PAST::Var '$func'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤]

[17:54] <Auzon> rakudo: my @arr = <1 3 2 5 4 7 6>; my $sort = sub {$^a <=> $^b}; say @arr.sort($sort);

[17:54] <p6eval> rakudo 29493: OUTPUT[[oops; continuation 0xb64df0b4 of type 19 is trying to jump from runloop 863 to runloop 110]␤[oops; continuation 0xb64dee68 of type 19 is trying to jump from runloop 864 to runloop 110]␤[oops; continuation 0xb64ded34 of type 19 is trying to jump from runloop 865 to runloop

[17:54] <p6eval> ..110]␤[...

[17:54] <Auzon> rakudo: my @arr = <1 3 2 5 4 7 6>; my $sort = {$^a <=> $^b}; say @arr.sort($sort);

[17:54] <p6eval> rakudo 29493: OUTPUT[1234567␤]

[17:55] <Auzon> rakudo: sub foo {say $^b}; foo(1,2,3)

[17:55] <p6eval> rakudo 29493: OUTPUT[too many arguments passed (3) - 1 params expected␤current instr.: 'foo' pc 44 (EVAL_13:23)␤]

[17:55] <Auzon> hm.

[17:56] <TimToady> rakudo: sub foo { @_; say $^b}; foo(1,2,3)

[17:57] <p6eval> rakudo 29493: OUTPUT[1␤]

[17:57] *** alanhaggai left
[18:01] *** alanhaggai_ is now known as alanhaggai

[18:01] *** zamolxes joined
[18:03] <pmurias> ruoso: hi

[18:04] <pmurias> do you have ruby 1.9?

[18:04] *** donaldh left
[18:04] *** donaldh joined
[18:14] <pmurias> ruoso: it looks like some -> {} syntax has crept into STD_red, and it now requires ruby 1.9

[18:18] *** apeiron left
[18:31] <pmurias> ruoso: i got my ruby 1.9 from debian and it works

[19:12] <ruoso> pmurias, ok... I have ruby 1.8... I'll try with 1.9

[19:12] *** r0bby left
[19:13] *** r0bby joined
[19:20] <ruoso> pmurias, it worked...

[19:25] <pmurias> ruoso: good

[19:26] <ruoso> pmurias, I was just looking at test/15...

[19:26] <ruoso> it looks awesome...

[19:26] <ruoso> but where does the values come from?

[19:26] <pmurias> you mean $io,$hash?

[19:26] <pmurias> they are still mapped to c, and include in the boilerplate

[19:26] <pmurias> :(

[19:27] <ruoso> oh... ok

[19:27] <ruoso> you could probably name them after their actual P6 names... couldn't you?

[19:27] <pmurias> you mean $*IN?

[19:28] <ruoso> yes

[19:28] <pmurias> it would be better to fetch them from a namespace

[19:29] <pugs_svn> r21340 | ruoso++ | [smop] test/15 was not really failing... the test count was wrong... SMOP_SLIME_DEBUG compile option can be set to show all the methods called in slime eval...

[19:30] <ruoso> pmurias, do we know if the namespace is a plain hash already?

[19:30] <ruoso> if it is, please... feel free to add it...

[19:30] <ruoso> although we could probably implement it as one

[19:30] <ruoso> and replace it later if that is not the case 

[19:31] <ruoso> use a dumb namespace for boostrap is probably a sane idea

[19:32] <pmurias> do you now how things like if will be implemented?

[19:32] <ruoso> we have two options...

[19:33] <ruoso> the first is to make an assembler like conditional-jump

[19:33] <ruoso> the second is to implement a "if" type that have a "then" and an "else" attributes

[19:33] <ruoso> that would be callable code

[19:33] <ruoso> actually three code attributes

[19:33] <ruoso> "condition", "then" and "else"

[19:34] <ruoso> or even

[19:34] <ruoso> a list of pairs consisting of "condition" => "then" codes and a "else" code

[19:35] <pmurias> the jump would be simpler

[19:36] <ruoso> and maybe more efficient...

[19:37] <ruoso> pmurias, btw... I was thinking about that "exposing the frame as an array of nodes" thing you were talking about...

[19:38] <pmurias> and?

[19:38] <ruoso> and I just realized that we could have sm0p generating new nodes on the fly

[19:38] <ruoso> instead of building a complete frame from the beggining

[19:38] <pmurias> you mean lazily?

[19:38] <ruoso> yes

[19:39] <pmurias> any use for this

[19:39] <pmurias> ?

[19:39] *** Alias_ left
[19:39] *** Alias__ joined
[19:39] <ruoso> I don't know yet...

[19:39] <ruoso> it just crossed my mind

[19:39] <ruoso> ;)

[19:39] <ruoso> but...

[19:39] <ruoso> "if" could feed one of the streams

[19:40] <ruoso> instead of doing a jump

[19:40] <ruoso> but as I said... it was just something that crossed my mind..

[19:42] <ruoso> it could be building the sm0p nodes and throwing away the past nodes by traversing the AST

[19:43] <ruoso> a high-level JIT

[19:44] <pmurias> a low-level JIT would help more

[19:44] * ruoso just brainstorming

[19:45] <ruoso> but it could choose a more direct invocation schema depending on the actual types of the objects

[19:45] <ruoso> that would be helpful already

[19:45] *** justatheory left
[19:46] <pmurias> i'm actually thinking of switching to a register based calls only interpreter implementation

[19:46] <ruoso> like llvm?

[19:47] <pmurias> translatable to llvm

[19:47] <pmurias> ruoso: are you familiar with llvm/

[19:47] <pmurias> s{/}{?}

[19:47] <ruoso> not really

[19:48] <ruoso> nothingmuch is

[19:48] <pmurias> i only read the tutorial

[19:48] <ruoso> so did I...

[19:48] *** cjfields_ left
[19:49] <ruoso> but I'm trying to ignore lower-level details right now and trying to move to writing actual P6 code ASAP... 

[19:49] <ruoso> I'm not very good at such low-level stuff...

[19:50] <pmurias> we need to smop to run benchmarks before we can optimise it ;)

[19:50] <ruoso> I'm hoping someone with actual skills in low-level stuff to help with that later...

[19:51] <pmurias> ruoso: do you have experience with parsing headers?

[19:51] <ruoso> I think the biggest challenge was to come up with something that allows this low-level to be replaced later..

[19:51] <ruoso> C headers? not really... but the spec is quite simple, AFAIK

[19:52] <pmurias> compared to perl6 ;)

[19:55] <pmurias> so what's the next thing to be done?

[19:57] <ruoso> I think you can move on implementing stuff that would be done to have usefull code compiled to sm0p

[19:57] *** ingy joined
[19:57] <ruoso> I'm moving with p6opaque that will allow us to have real p6 objects...

[19:58] <ruoso> btw... take a try with the SMOP_SLIME_DEBUG compile option (you need to recompile smop_slime_node.c for it to take effect)

[19:58] <ruoso> it should help debugging the darn memory leaks

[20:01] <pmurias> they are created when slime is used wrongly?

[20:03] <pmurias> how do i get a social-text login?

[20:03] <ruoso> sometimes the bug is in slime

[20:07] <pmurias> ruoso: how do i get a social text account, openid dosn't work for me

[20:07] <pmurias> ?

[20:07] <ruoso> pmurias, I don't remember how I got one...

[20:08] <ruoso> http://www.perlfoundation.org/nlw/register.html

[20:08] <lambdabot> Title: Register

[20:08] <ruoso> doesn't that help?

[20:09] <pmurias> i can't register as i'm registered with openid--

[20:10] <ruoso> weird

[20:10] <pmurias> openid worked

[20:12] <ruoso> cool

[20:14] <pmurias> SMOP_SLIME_DEBUG dosn't help much

[20:15] <pmurias> it should be possible to create a leak using sm0p

[20:16] <ruoso> pmurias, it shouldn't be possible, you mean ;)

[20:16] <pmurias> yes

[20:18] <ruoso> pmurias, where is the sm0p boilerplate defined?

[20:19] <pmurias> in elf/sm0p_boilerplate_*

[20:19] <pmurias> you can look at Makefile.am

[20:19] <pmurias> * test/Makefile.am

[20:21] *** barney left
[20:21] <pmurias> re shouldn't be possible, i meant in theory ;)

[20:21] <ruoso> when I change the boilerplate? do I need to do something else for it to take effect?

[20:22] <pmurias> just recompile the tests

[20:25] <ruoso> I think the leak is in somehow in move_responder 

[20:26] <ruoso> test/14 have a very similar memory leak

[20:27] <pugs_svn> r21341 | Auzon++ | [gsoc_spectest] move constant.t in spec

[20:27] <ruoso> pmurias, btw... you could have an additional preprocessor to use the "p6" blocks instead of "sm0p" blocks...

[20:27] <ruoso> they would simply inject the sm0p code inside the C source instead of adding the boilerplate

[20:29] <pmurias> you could extend sm0p.pl

[20:30] <ruoso> yes... that would be ok also...

[20:32] *** iblechbot joined
[20:32] <ruoso> but I can only think about it after I succesfully hunt down the memory leak in test/14

[20:32] <pmurias> ruoso: i can fight the leak, if you want to move on

[20:32] <ruoso> we both could ;)

[20:34] <ruoso> pmurias, this leak is a very important one... we could both focus on getting rid of it...

[20:36] <pmurias> got gobby? ;)

[20:37] <pmurias> the boilerplate itself is leaky

[20:37] *** justatheory joined
[20:38] <ruoso> there's one thing, yes... I was about to commit it

[20:38] <ruoso> but that doesn't solve the problem entirely

[20:38] <pugs_svn> r21342 | ruoso++ | [elfish/smop] releases must happen before loop

[20:40] <pmurias> it should be possible to automaticly determin which object holds the leaking one

[20:41] <pmurias> sorry, none of them hold it, it's not gc

[20:43] <pmurias> debugging gc would be easier ;)

[20:43] *** iblechbot left
[20:44] <ruoso> (trace gc, you mean...)

[20:46] <pmurias> yes

[20:47] <ruoso> pmurias, I didn't use it somply because it seemed too hard to implement...

[20:47] <ruoso> but it shouldn't be too hard to replace it...

[20:48] <pmurias> don't we need ref counting for perl5?

[20:51] <ruoso> pmurias, we would still need to support SMOP_RELEASE and SMOP_REFERENCE

[20:51] <ruoso> but they can do nothing in the case of trace gc

[20:52] <pmurias> tracing gc can only collect things with a zero reference counter

[20:53] <pmurias> i have to think/sketch it out...

[20:56] *** dblick left
[20:59] <pmurias> ruoso: thought it out, objects which are tracked by the trace gc have a reference counter set to 1 initialy and it is decremented when they are unreachable

[20:59] <ruoso> pmurias, it doesn't even need to do that

[20:59] <ruoso> pmurias, the reference and release codes can be a noop

[21:00] <ruoso> there's no such thing as *the* smop gc... but each object can choose to use whatever it wants

[21:00] <ruoso> SMOP_RELEASE and SMOP_REFERENCES are calls made to the object's responder interface... 

[21:00] <ruoso> some objects in smop are not subject to gc at all

[21:00] <ruoso> because they are singletons that are initialized in smop_init()

[21:00] <ruoso> and only destroyed in smop_destr

[21:00] <pmurias> do you want to search all the memory for the adress of the object?

[21:01] <pmurias> if so RELEASE is a noop

[21:03] <ruoso> the problem is that the object that caused the leak might be destroyed already

[21:03] <ruoso> that's why I was only successfull by going each eval step and watching how many reference and release calls are made

[21:03] <ruoso> and detecting when some was missing

[21:05] <pmurias> ruoso: i meant in you gc scheme

[21:05] <ruoso> yes...

[21:05] <ruoso> exactl

[21:05] <ruoso> because if some code some where misses a SMOP_RELEASE call

[21:06] <ruoso> you might not have a trace of it anymor

[21:06] <ruoso> so you can't introspect the memory to find out where it was

[21:07] <pmurias> ruoso: you are refering to the way you are debugging the memory leak or how the gc would work in smop if it was implemented?

[21:07] <ruoso> the way I'm debugging now

[21:07] *** Sartak joined
[21:08] <spinclad> so gc'd objects can ignore refcounts, but still all objects must support gc reference tracing...

[21:08] <ruoso> spinclad, the pointer to a function must exist... but that's all that is required

[21:08] <pmurias> spinclad: gc'd objects can't ignore refcounts

[21:08] * ruoso home & (will connect later)

[21:09] <ingy> hai

[21:09] *** rindolf left
[21:09] <pmurias> ingy: hi

[21:09] <ingy> hi pmurias 

[21:10] <pmurias> ingy: you inquired about pixie a long time ago ;)

[21:11] <ingy> what's that again?

[21:11] <pmurias> a set of STD.pm hooks to make it emit elf AST

[21:11] <pmurias> pixie: say 44;

[21:12] <p6eval> pixie: No output (you need to produce output to STDOUT)

[21:12] <ingy> pmurias: is pixie your thing that uses TimToady's parser?

[21:12] *** jfredett_ is now known as jfredett

[21:13] <pmurias> ingy: one of my two things

[21:13] <pugs_svn> r21343 | pmurias++ | [pixie] fix pixie after STD5.pm -> STD.pmc

[21:13] <ingy> what is the other and where do they live?

[21:13] <pugs_svn> r21344 | Auzon++ | [gsoc_spectest] moved state.t into spec/ and cleaned a smartlink

[21:13] <pmurias> STD5_dump_match in src/perl6

[21:13] <ingy> I've seen that...

[21:14] <pmurias> and pixie in misc/pixie

[21:14] <ingy> ok

[21:14] <ingy> can I install all of elf from pugs repo?

[21:15] <Auzon> You need also Ruby 1.9

[21:15] <Auzon> *also need

[21:15] <ingy> for elf?

[21:15] <pugs_svn> r21345 | pmurias++ | [pixie] added edit a sh script i use for editing actions

[21:15] <pmurias> ingy: for elf STD_red parser

[21:16] <pmurias> LS

[21:16] <pmurias> (caps-lock)--

[21:17] <ingy> is there an elf wiki or somesuch online README?

[21:18] <pmurias> misc/elf/README

[21:18] <pmurias> and you can ask me questions ;)

[21:18] <ingy> pmurias: you meant (CAPS_LOCK)__

[21:18] <ingy> :)

[21:18] <TimToady> pugs-as-a-wiki...

[21:19] <ingy> pmurias: ok. I'll have a play later

[21:20] <pmurias> i'll have to get round to converting pixie actions to p6 soon...

[21:21] <ingy> pmurias: I'm only interested in copying stuff for my new language :)

[21:21] *** jhorwitz left
[21:22] <pmurias> ingy: what's your new language?

[21:22] <ingy> C'Dent

[21:22] <ingy> long story. there's some old misinformation at cdent.org.

[21:23] <ingy> I need a quick nap. bbl&

[21:25] <pmurias> if you want to integrate with elf,warp it or anything feel free

[21:25] <pmurias> you can use my branch /misc/elfish/elfX or copy your own

[21:27] *** ruoso left
[21:33] *** pmurias left
[21:36] *** hercynium left
[21:38] *** cjfields joined
[21:45] <armagad>  /j #silconslotcanyon

[21:50] *** cjfields left
[21:54] *** perlbot left
[22:02] *** LordBr4in joined
[22:15] *** pbuetow_ left
[22:17] *** Chillance left
[22:44] *** Limbic_Region joined
[22:48] *** Jamtech left
[22:52] <meppl> good night

[22:57] *** meppl left
[23:16] *** Psyche^ joined
[23:20] *** ruoso joined
[23:28] *** Patterner left
[23:29] *** Psyche^ is now known as Patterner

[23:29] *** Exodist left
[23:32] *** rindolf joined
[23:49] *** cmarcelo left
[23:51] <rindolf> Hi all.

[23:51] <rindolf> TimToady: here?

[23:51] <rindolf> TimToady: do you know Spanish?

[23:53] <Patterner> Oui.

[23:55] <rindolf> Patterner: isn't "Oui" French?

[23:55] <rindolf> Si is Spanish.

[23:55] <Patterner> darn

[23:55] <rindolf> Well, there's also "Si" in French.

[23:56] <rindolf> For answerin positively to a "Don't you know Spanish?"

[23:57] *** bacek joined
