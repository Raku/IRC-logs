[00:01] *** wknight8111 joined
[00:07] *** alester left
[00:11] *** BinGOs_ left
[00:11] *** BinGOs joined
[00:17] *** BinGOs left
[00:27] *** BinGOs_ joined
[00:30] *** ab5tract left
[00:32] *** BinGOs__ joined
[00:46] *** BinGOs_ left
[00:47] *** elmex left
[01:16] *** Limbic_Region left
[01:16] <rakudo_svn> r31139 | tene++ | [rakudo]

[01:16] <rakudo_svn> r31139 | tene++ | Replace another instance of :inline with :pirop('newclosure').

[01:20] *** Ehtyar joined
[01:27] *** kanru joined
[01:55] *** charsbar joined
[01:55] *** charsbar_ left
[02:00] *** ab5tract joined
[02:06] *** wknight8111 is now known as wknight-away

[02:33] *** wknight-away left
[02:36] *** alester joined
[02:45] *** Auzon1 joined
[02:45] *** Auzon left
[02:47] *** meppuru joined
[02:47] *** xiaoyafeng left
[03:03] *** xiaoyafeng joined
[03:04] *** meppl left
[03:11] <meppuru> good night

[03:14] *** meppuru left
[03:22] *** xuser left
[03:34] *** |jedai| joined
[03:36] *** Jedai left
[03:38] *** xuser joined
[03:43] *** kst` joined
[03:44] *** sail0r joined
[03:44] *** sail0r left
[03:48] *** sri_work left
[04:16] *** Bzek joined
[04:18] *** xiaoyafeng left
[04:24] <s1n> @tell pmichaud i have something i need help testing, i have monday night free to finish this patch

[04:24] <lambdabot> Consider it noted.

[04:31] *** charsbar_ joined
[04:31] *** charsbar left
[04:40] *** kst` left
[04:40] *** kst`` joined
[04:59] *** ashizawa joined
[05:07] *** BinGOs joined
[05:11] *** BinGOs__ left
[05:16] *** Psyche^ joined
[05:18] *** Psyche^ is now known as Patterner

[05:32] *** luqui joined
[05:44] *** _jedai_ joined
[05:46] *** |jedai| left
[06:15] *** luqui left
[06:31] *** ab5tract left
[06:33] *** jferrero joined
[07:00] *** mberends joined
[07:10] *** alester left
[07:11] *** missingthepoint joined
[07:12] *** pmurias joined
[07:15] *** cosimo joined
[07:16] <pmurias> ruoso: is there anything you are blocking on that i should work on or is the direction i'm pushing smop in ok?

[07:18] *** Myoma left
[07:31] *** iblechbot joined
[07:35] *** charsbar_ left
[07:35] *** charsbar joined
[07:52] *** cosimo left
[07:54] *** Myoma joined
[08:03] *** pmurias_ joined
[08:03] *** pmurias_ left
[08:04] *** pmurias_ joined
[08:04] *** pmurias_ left
[08:04] *** pmurias left
[08:04] *** pmurias_ joined
[08:05] <pmurias_> ruoso: i'm switching to method postcircumfix:<( )> (|$capture) {...} as method postcircumfix:<( )> ($capture) {...} leads to an awkward emitter/emitted code and is spec contradicting

[08:11] *** charsbar left
[08:11] *** charsbar_ joined
[08:21] *** hanekomu joined
[08:24] *** charsbar_ left
[08:24] *** charsbar joined
[08:26] *** agentzh joined
[08:29] *** drbean joined
[08:32] *** kane_ joined
[08:35] *** schmalbe joined
[08:37] <pugs_svn> r22250 | bpetering++ | Test commit bit: add self to AUTHORS

[08:37] <moritz_> missingthepoint++ # first commit

[08:39] <missingthepoint> :)

[08:41] <missingthepoint> moritz_: what's the state of IO in pugs and parrot?

[08:41] <missingthepoint> i want a way to compare the C and perl6 versions of the code

[08:41] <moritz_> missingthepoint: both support reading of files and from STDIN, with various degrees for brokenness

[08:41] <missingthepoint> was thinking of creating of file of rand() output

[08:42] <moritz_> in rakudo slurp($filename) works

[08:43] <missingthepoint> should new tests be targeted to parrot?

[08:43] <missingthepoint> err, s/parrot/rakudo/

[08:43] <pmurias_> there should be targeted at a Perl 6 implementation in general

[08:43] <moritz_> they should be implementation independant

[08:44] <moritz_> but it doesn't hurt to make them as simple as possible, so that many implementations can run them

[08:44] <moritz_> slurp($filename) works in both pugs and rakudo

[08:44] <pmurias_> and elf

[08:44] <missingthepoint> ah, cool :)

[08:45] <missingthepoint> i'll play around with that then

[08:45] <missingthepoint> cheer, pmurias

[08:45] <missingthepoint> *cheers

[08:45] <missingthepoint> (can't type, need caffeine)

[08:46] <pmurias_> missingthepoint: cheers

[08:52] <missingthepoint> moritz_: well, i have it compiling

[08:52] <missingthepoint> i think i'll test against the C code before i commit...

[08:53] <missingthepoint> but once it's committed, would you mind having a glance and pointing out any ways the perl6 could be written better?

[08:53] <moritz_> sure

[08:54] <moritz_> will do

[08:54] * moritz_ monitors nearly all commits to t/ anyway

[08:55] <missingthepoint> thanks heaps, moritz

[08:55] <missingthepoint> you've made it a lot easier to get started

[08:56] * moritz_ plans to publish an article in "The Perl Review" about getting involved with the test suite 

[08:56] <moritz_> hope that it brings us some more volunteers

[08:59] <pugs_svn> r22251 | pmurias++ | [smop/pugs]

[08:59] <pugs_svn> r22251 | pmurias++ | switched to method postcircumfix:<( )> (|$capture) {...}

[08:59] <pugs_svn> r22251 | pmurias++ | interpreter dies on an unknown method

[08:59] <pugs_svn> r22251 | pmurias++ | pugs emits correct m0ld for $*OUT.print("1..1\nok 1\n")

[08:59] *** drbean left
[09:00] <pmurias_> moritz_: the test suit seems easiest for new people to get involved in

[09:00] *** drbean joined
[09:00] <missingthepoint> moritz_: soon, like the Fall 2008 issue?

[09:00] <moritz_> pmurias_: Aye, you don't need to know about compiler construction

[09:00] <moritz_> missingthepoint: I hope so

[09:02] <missingthepoint> moritz_: cool... if you have a draft i could give you feedback from a newbie's perspective :)

[09:03] <moritz_> missingthepoint: It will be based on http://www.perlmonks.org/?node_id=690945 and on t/HOWTO

[09:03] <lambdabot> Title: Getting Involved with Perl 6 - an Update

[09:03] <pmurias_> moritz_: i don't think you need to know much about compiler construction for any other Perl 6 stuff

[09:03] <moritz_> missingthepoint: and I'll give you a draft as soon as it's in a readable state

[09:03] <moritz_> pmurias_: probably not, but hacking on a *compiler* is a scary thought for many people

[09:04] <missingthepoint> i second that, the test suite is a lot less intimidating from where i'm standing

[09:04] <moritz_> because a compiler is a huge, complex beast, and you have to be a computer scientist to understand it etc </FUD>

[09:05] <pugs_svn> r22252 | pmurias++ | [smop] added missing file

[09:06] <missingthepoint> i know :)

[09:07] <missingthepoint> (that that's FUD)

[09:07] <missingthepoint> but the test suite seemed like a logical place to start for me

[09:08] <moritz_> another point is that for most compiler hacking you need to know a few more languages, not just Perl 6

[09:08] <missingthepoint> yep

[09:08] <pmurias_> moritz_: you can learn them as you go ;)

[09:09] <moritz_> pmurias_: sure you can, but it's easier if you don't have to ;)

[09:09] <missingthepoint> moritz_: i'm happy to give feedback, if that would be helpful

[09:09] <missingthepoint> moritz_: i actually ++'d that node today :)

[09:10] <moritz_> missingthepoint: it would. I just need a few hours to come up with the draft (and do other $stuff for real life)

[09:11] *** Ontolog joined
[09:11] <Ontolog> my $inFile = shift or die $usage; doesn't evaluate in perl 6?

[09:11] <Ontolog> what is the idiom now?

[09:12] <moritz_> @*ARGS.shift

[09:12] <lambdabot> Unknown command, try @list

[09:12] <moritz_> shift doesn't default to @ARGV/@_ anymore

[09:12] <pmurias_> \/\/ die

[09:12] <pmurias_>  // die

[09:12] <moritz_> aye

[09:13] <pmurias_> moritz_: although on the fly learning works better with haskell than C because you remain reasonable productive instead of cursing segfaults and memeory leaks

[09:13] <moritz_> pmurias_: instead you just curse failed type checks ;)

[09:15] <pmurias_> most of the failed type checks error messages don't make any sense at all they are just you have a bug indicators

[09:16] <Ontolog> what doe shift default to now?

[09:16] <moritz_> yes, but they are still frustrating when you try to get something to run

[09:16] <moritz_> Ontolog: there's now default

[09:16] <moritz_> s/now/no/

[09:16] <moritz_> a bare shift; never does something useful in Perl 6

[09:17] <Ontolog> why?

[09:17] <Ontolog> did they take away default for everything or only shift?

[09:18] <moritz_> everything

[09:18] <moritz_> most perl 5 builtins default to $_

[09:18] <moritz_> which you can now obtain with a leading dot

[09:18] <moritz_> so .say is the same as $_.say

[09:18] <Ontolog> i see...

[09:18] <Ontolog> and .shift?

[09:18] <Ontolog> is @_.shift?

[09:18] <Ontolog> or @ARGS.shift?

[09:18] <moritz_> $_.shift

[09:18] <Ontolog> and what is the * ?

[09:19] <moritz_> it means "global variable"

[09:19] <Ontolog> i see

[09:19] <moritz_> http://perlgeek.de/blog-en/perl-5-to-6/15-twigils.html

[09:19] <lambdabot> Title: blog | Perlgeek.de Blog :: Twigils

[09:19] <pmurias_> walk&

[09:25] <Ontolog> ....twigils

[09:25] <Ontolog> sillyness!!

[09:31] <pugs_svn> r22253 | moritz++ | [t/TASKS] we need to test the builtins from S29 with named arguments

[09:37] <Ontolog> is there a list of primitive functions anywhere?

[09:38] *** zamolxes joined
[09:38] <moritz_> S29 comes closest: http://perlcabal.org/syn/S29.htmh

[09:38] <moritz_> erm, http://perlcabal.org/syn/S29.html

[09:38] <lambdabot> Title: S29

[09:40] <Ontolog> like, is there an "open" function anywhere?

[09:41] <Ontolog> I want to open a file and start reading from it

[09:41] <moritz_> Ontolog: yes, there's open($filename)

[09:41] <moritz_> Ontolog: it should be documented in S16

[09:41] <Ontolog> i see thanks

[09:42] <moritz_> (btw if you go at irc.pugscode.org all these S16 and stuff is turned into links)

[09:47] <Ontolog> thanks

[09:47] <Ontolog> Why does while $in.readline { say $_; } not work?

[09:47] <Ontolog> I mean, why is $_ not set?

[09:48] <Ontolog> if I do $in.readline -> $line it works

[09:48] <Ontolog> but the default doesn't

[09:49] <moritz_> that's not the Perl 6 way of doing it

[09:49] <moritz_> there's not implicit assignment to $_ anymore

[09:49] <Ontolog> oh not at all??

[09:49] <Ontolog> jeez

[09:49] <moritz_> you'd use for =$in { .say }

[09:49] <Ontolog> i see.. :P

[09:56] *** braceta joined
[10:06] <moritz_> std: .say for =$in unless $foo;

[10:06] <p6eval> std 22253: OUTPUT[cp: cannot create regular file `lex/STD/EXPR': Permission denied␤parse failure␤]

[10:06] <moritz_> ouch

[10:07] <moritz_> std: .say for =$in unless $foo;

[10:08] <p6eval> std 22253: OUTPUT[Unknown routines:␤     unless called at 1 ␤parsed␤]

[10:15] *** kst`` left
[10:15] *** kst``` joined
[10:15] *** ashizawa left
[10:32] *** wknight8111 joined
[10:39] *** elmex joined
[10:54] *** meppl joined
[10:57] <moritz_> pugs: my %h=(a=>1, b=>2); my :($a,$b) := %h; say $a

[10:57] <p6eval> pugs: OUTPUT[*** Wrong number of binding parameters: 1 actual, 2 expected␤    at /tmp/m1oHE3oAp4 line 1, column 21-38␤]

[10:57] <moritz_> pugs: my %h=(a=>1, b=>2); my :($a,$b) := |%h; say $a

[10:57] <p6eval> pugs: OUTPUT[*** Wrong number of binding parameters: 1 actual, 2 expected␤    at /tmp/avbBs0o5aN line 1, column 21-39␤]

[10:57] <moritz_> pugs: my %h=(a=>1, b=>2); my (:$a,:$b) := %h; say $a

[10:57] <p6eval> pugs: OUTPUT[*** Wrong number of binding parameters: 1 actual, 2 expected␤    at /tmp/EqEMz1YA6h line 1, column 21-39␤]

[10:58] <moritz_> pugs: my %h=(a=>1, b=>2); my (:$a,:$b) := |%h; say $a

[10:58] <p6eval> pugs: OUTPUT[*** Wrong number of binding parameters: 1 actual, 2 expected␤    at /tmp/IihjUCbMHW line 1, column 21-40␤]

[10:58] <moritz_> pugs: my %h=(a=>1, b=>2); my :(:$a,:$b) := |%h; say $a

[10:58] <p6eval> pugs: OUTPUT[*** Wrong number of binding parameters: 1 actual, 2 expected␤    at /tmp/QJrK9K2RkJ line 1, column 21-41␤]

[10:58] <moritz_> pugs: my %h=(a=>1, b=>2); my :(:$a,:$b) := %h; say $a

[10:58] <p6eval> pugs: OUTPUT[*** Wrong number of binding parameters: 1 actual, 2 expected␤    at /tmp/LI8CH0XliY line 1, column 21-40␤]

[11:07] *** ashizawa joined
[11:11] *** smg joined
[11:45] <Ontolog> moritz_: so is $_ used at all in Perl 6?

[11:45] <Ontolog> can I start defining it myself? like for =$in -> $_ { mysub $_ }

[11:46] *** BinGOs left
[11:46] *** BinGOs joined
[11:47] <moritz_> oh sorry, 'for' sets it by default

[11:47] <moritz_> as does 'given'

[11:47] <moritz_> but not 'while'

[11:47] <moritz_> rakudo: .say for 1..3;

[11:47] <p6eval> rakudo 31145: OUTPUT[1␤2␤3␤]

[11:47] <Ontolog> i see, the . syntax, can I do that with my own subs? .mysub?

[11:48] <Ontolog> it doesn't seem to work

[11:50] <moritz_> let's try

[11:50] <moritz_> rakudo: class A { sub foo { say "yes" }; }; given A.new { .foo };

[11:50] <p6eval> rakudo 31145: OUTPUT[Method 'foo' not found for invocant of class 'A'␤current instr.: '_block35' pc 286 (EVAL_12:118)␤]

[11:51] <moritz_> rakudo: class A { method foo { say "yes" }; }; given A.new { .foo };

[11:51] <p6eval> rakudo 31145: OUTPUT[yes␤]

[11:51] <moritz_> Ontolog: it works, if you do it right

[11:51] <moritz_> Ontolog: just remember that it's actually a method call, not a sub call

[11:52] <Ontolog> so you can't do it with subs?

[11:52] <Ontolog> does perl even have normal subroutines?

[11:52] <Ontolog> *perl6

[11:52] <Myoma> normal ?

[11:52] *** BinGOs left
[11:52] <moritz_> yes, it has

[11:52] <moritz_> and no, you can't

[11:52] <Ontolog> i see

[11:52] <moritz_> rakudo: sub foo { say "it's a sub" }; foo()

[11:52] <p6eval> rakudo 31145: OUTPUT[it's a sub␤]

[11:56] *** kst``` left
[11:56] *** kst``` joined
[12:10] *** _jedai_ left
[12:10] *** _jedai_ joined
[12:11] <Ontolog> is larry wall working on any of the implementations?

[12:12] <moritz_> Ontolog: he's working on STD.pm, the Perl 6 grammmar

[12:14] <Ontolog> i see, where can I get this STD.pm and how do I use it?

[12:14] <Ontolog> i saw your mention of it on the mailing list there

[12:15] <Ontolog> if I have pugs or rakudo do I already have it?

[12:15] <moritz_> it's in the pugs repository in src/perl6/

[12:15] <Ontolog> i see

[12:15] <moritz_> you need a perl 5.10.0 or later installed in /usr/local/bin/perl ;/

[12:15] <moritz_> then you can type 'make'

[12:15] <moritz_> to build it

[12:15] <moritz_> and perl5.10.0 STD5_dump_match $file

[12:16] <Ontolog> i see; already have perl 5.10 under /usr/local

[12:16] <Ontolog> i'll try to build it

[12:16] <Ontolog> what is the 5 for?

[12:16] <Ontolog> STD5??

[12:16] <Ontolog> shouldn't it be 6? ;)

[12:16] <moritz_> it refers to the Perl 5 translation of STD.pm

[12:17] <Ontolog> i see so STD.pm is written in Perl 5?

[12:18] <Ontolog> hmm i see it's not

[12:20] <moritz_> no, it's written in Perl 6

[12:20] <moritz_> and can automatically be translated to Perl 5

[12:20] <moritz_> which is what gimmme5 does

[12:20] <Ontolog> ahh cool

[12:21] *** BinGOs joined
[12:21] <Ontolog> hey man why didn't you major in cs instead of physics?

[12:21] <moritz_> funny, my girlfriend keeps asking the same ;)

[12:22] <Ontolog> haha maybe you can do something with both of them (cs and physics)

[12:22] <moritz_> basically I didn't want to limit my scope to computers and the world of abstract thoughts

[12:22] <Ontolog> i see

[12:22] <moritz_> Ontolog: indeed, in Germany we have to take a second subject, and I took CS

[12:22] <Ontolog> would you say your first love is CS or Physics?

[12:23] <moritz_> Ontolog: and starting from mid October I'll be teaching a bit of theoretical physics for beginners

[12:23] <moritz_> hard to say... my first love was Lego, then came electronics, then programming

[12:23] <Ontolog> haha mine was legos too 

[12:23] <moritz_> so probably physics

[12:23] <Ontolog> so funny

[12:24] <Ontolog> when i was real young i loved legos

[12:24] *** zamolxes left
[12:24] * moritz_ build weird stuff with Lego, like combination locks and a machine that winds inductor coils

[12:25] <Ontolog> that's cool, never did anything like that

[12:26] <moritz_> that was when I was not-so-young-anymore

[12:26] <moritz_> perhaps 12 or 13

[12:26] <Ontolog> i didn't know you could do that stuff with legos, were they special kits?

[12:27] <moritz_> the combination lock was pure lego

[12:27] <moritz_> for the coil winder I used some non-lego stuff as well

[12:28] *** Lorn joined
[12:29] *** wknight8111 left
[12:30] <pasteling> "Ontolog" at 121.15.103.0 pasted "make bombs" (8 lines, 286B) at http://sial.org/pbot/32160

[12:31] <Ontolog>     48	    require "STD.pmc";

[12:31] <moritz_> Ontolog: look at try5.out

[12:31] <moritz_> Ontolog: it should contain some debugging information

[12:31] <Ontolog> empty

[12:33] * moritz_ runs out of ideas

[12:33] <moritz_> you could try to add a line '1;' at the end of STD.pmc

[12:35] <Ontolog> haha i noticed STD.pmc is also empty

[12:35] <Ontolog> what the biff

[12:36] <moritz_> try ./gimme5 STD.pm > STD.pmc

[12:36] <moritz_> that should fill STD.pmc

[12:42] <Ontolog> that seems to get stuck in an infinite loop

[12:46] *** meppl left
[12:46] *** schmalbe left
[12:46] *** agentzh left
[12:46] *** Patterner left
[12:46] *** xuser left
[12:47] *** Psyche^ joined
[12:47] *** Psyche^ is now known as Patterner

[12:47] *** Guest16015 joined
[12:50] *** meppl joined
[12:50] *** schmalbe joined
[12:50] *** agentzh joined
[12:50] *** xuser joined
[12:50] *** Maghnus joined
[12:50] *** cotto_home joined
[12:50] *** jiing joined
[12:50] *** s1n joined
[12:50] *** bennymack-work joined
[12:54] *** r0bby joined
[13:02] *** ispy_ joined
[13:04] *** jferrero left
[13:17] *** zamolxes joined
[13:19] *** braceta left
[13:21] *** apeiron_ joined
[13:21] *** masak joined
[13:23] *** Lorn_ joined
[13:29] *** apeiron left
[13:36] *** braceta joined
[13:41] <pmurias_> re

[13:42] *** Lorn left
[13:47] *** Auzon1 left
[13:52] *** clintongormley joined
[13:53] *** kst``` left
[13:53] *** kst``` joined
[13:59] *** justatheory joined
[14:02] *** pmurias_ is now known as pmurias

[14:04] <rakudo_svn> r31152 | moritz++ | [rakudo] Mapping.values shouldn't coerce to string, bacek++

[14:04] <rakudo_svn> r31152 | moritz++ | Patch courtesy by Vasily Chekalkin, <bacek at bacek.com>

[14:10] <masak> how do I refer to a method on an object in Perl 6? (without calling it)

[14:10] <moritz_> how would you in perl 5?

[14:10] <moritz_> either as a string (the method name)...

[14:10] <moritz_> or a closure 

[14:11] <moritz_> I guess that's what you'd use in Perl 6 as well

[14:11] <masak> I was thinking along the lines of &($obj.method)

[14:11] *** alester joined
[14:11] <moritz_> I thought the same ;)

[14:11] <moritz_> but I guess it wouldn't work

[14:11] *** [1]Maghnus joined
[14:12] <masak> the string variant would be what, &"\$obj.method" ?

[14:12] <moritz_> my $x = uc; say "abc".$x() ?

[14:12] <moritz_> pugs: my $x = uc; say "abc".$x()

[14:12] <p6eval> pugs: OUTPUT[*** ␤    Unexpected "$x"␤    expecting "=", context, ":" or "("␤    at /tmp/mloepR1hRh line 1, column 4␤]

[14:13] <moritz_> uhm

[14:13] <moritz_> of course you can say my $x = Classname::method; $x($obj:)

[14:14] <masak> rakudo: class A { method x($n) { say $n; say self.WHAT } }; sub y($x) { $x() }; my $a = A.new; y( { $a.x(5) } )

[14:14] <p6eval> rakudo 31152: OUTPUT[5␤A␤]

[14:14] <masak> this is enough for my purposes, I think

[14:14] <masak> rakudo++

[14:14] <moritz_> erm &Classname::method I menat

[14:14] <moritz_> *meant

[14:17] <masak> rakudo: { nothing }() # :)

[14:17] <p6eval> rakudo 31152: RESULT[Null PMC access in find_method()␤current instr.: '_block11' pc 25 (EVAL_13:12)␤]

[14:17] *** sri_work joined
[14:18] <moritz_> masak: I don't think that nothing() is specced anymore

[14:18] <masak> oh. it Works on My Machine

[14:18] <masak> my working copy must be old

[14:18] <masak> moritz_: how does one write an empty block nowadays?

[14:19] <masak> rakudo: if 5 {} else { say "Will this work?" }

[14:19] <p6eval> rakudo 31152: RESULT[Null PMC access in find_method()␤current instr.: '_block11' pc 25 (EVAL_13:12)␤]

[14:19] <moritz_> masak: dunno, I just seem to recall that TimToady removed nothing

[14:19] <masak> I remember him removing nothing too

[14:19] <masak> but I think nothing remained in rakudo after that

[14:19] <moritz_> rakudo: unless 5 { say "Will this work?" }

[14:19] <p6eval> rakudo 31152: RESULT[5]

[14:20] <masak> moritz_: of course one can use unless instead

[14:20] <masak> but I was thinking more like someone adding and removing lines of code from a block

[14:20] <masak> and suddenly ending up with an empty one

[14:21] <masak> (will a block only containing comments be interpreted as an empty hash, even when it's in the position of an if block?)

[14:21] <moritz_> masak: the grammer explicitly looks for a block after 'if', so it will not be interpreted as a hash

[14:26] <pmurias> rakudo if 5 {;}

[14:26] <pmurias> rakudo: if 5 {;}

[14:26] <p6eval> rakudo 31153: RESULT[Null PMC access in find_method()␤current instr.: '_block11' pc 25 (EVAL_13:12)␤]

[14:27] <moritz_> rakudo: if 5 {;}; say "still there"

[14:27] <p6eval> rakudo 31153: OUTPUT[still there␤]

[14:27] <moritz_> that's p6eval's oddity to try to squeeze out a value if nothing is printed to stdout

[14:28] *** Maghnus left
[14:28] *** [1]Maghnus is now known as Maghnus

[14:30] <pmurias> how should i emit ¢ from Pugs?

[14:31] <pmurias> if i specifi it in a haskell literal it gets mangled

[14:31] <moritz_> $cent?

[14:31] <moritz_> 7~

[14:31] <moritz_> oops

[14:32] *** missingthepoint left
[14:34] <masak> moritz_: it worries me that p6eval produces errors that aren't really there

[14:36] <moritz_> masak: hm, we could do some magic...

[14:36] <masak> possibly.

[14:36] <moritz_> masak: right now if it doesn't produce any output, it is wrapped in ((...).perl).print or some such

[14:36] <masak> not sure I think that's needed.

[14:36] <masak> better to be consistent.

[14:37] <moritz_> masak: what we could do is it seperate STDOUT and STDERR for that program, and if there's no result on STDOUT then simply say "no output"

[14:37] <moritz_> masak: but it's convenient

[14:37] <moritz_> ;)

[14:37] <masak> sure, it's convenient.

[14:38] <masak> I'm not going to oppose a feature that people like just because it produces errors I don't like :)

[14:38] <masak> your idea with separating STDOUT and STDERR sounds intriguing.

[14:38] <masak> if it works, I want it :)

[14:40] <moritz_> if you implement it, it works ;)

[14:40] <masak> speaking of work...

[14:41] * masak is suddenly reminded of his real $work

[14:41] <moritz_> if not, you have to wait for the undefined future until someone (.oO( who could that be...?)) does it, perhaps

[14:43] *** wknight8111 joined
[15:02] <pugs_svn> r22254 | pmurias++ | [smop][pugs]

[15:02] <pugs_svn> r22254 | pmurias++ | pugs generates working m0ld

[15:02] <pugs_svn> r22254 | pmurias++ | added a very simple test for that

[15:02] <pugs_svn> r22254 | pmurias++ | m0ld also accepts ? as an ascii replacement for Â¢

[15:03] * masak waits for the undefined future

[15:03] <pmurias> moritz_: you want to evalbot to just die quietly if there are errors in the code

[15:13] <moritz_> pmurias: I don't think that's a good idea

[15:14] <pmurias> moritz_: what was you idea for STDOUT and STDERR about?

[15:16] <moritz_> pmurias: if the code produces no output, wrap it in ((...).perl).print (as is now), but on that second run only check STDOUT (currently both are checked)

[15:17] <moritz_> pmurias: some statements generate errors in some implementations if used as expressions

[15:17] *** jferrero joined
[15:17] <pmurias> i understand, thanks

[15:17] <pmurias> perl6: do {say 4}

[15:17] <p6eval> elf 22254, pugs, rakudo 31155: OUTPUT[4␤]

[15:18] <pmurias> perl6: do {1}

[15:18] <p6eval> pugs, rakudo 31155: RESULT[1]

[15:18] <p6eval> ..elf 22254: RESULT[1␤]

[15:18] <pmurias> moritz_: a "do {...}" might prevent some errors

[15:20] <moritz_> $program = '( ( do { ' . $program . "\n} ).perl ).print";

[15:20] <moritz_> that's what I use now

[15:20] *** wknight8111 left
[15:22] <moritz_> shouldn't be hard to do, just need 10 minutes of straight thinking

[15:22] <meppl> what does the perl()-method do?

[15:23] <moritz_> meppl: roughly the same as Data::Dumper in perl 5, ie it gives you a piece of perl code that constructs the object

[15:24] <meppl> i see

[15:24] <moritz_> perl6: print [1, 2].perl

[15:24] <p6eval> elf 22254: OUTPUT[[1,2]]

[15:24] <p6eval> ..pugs: OUTPUT[\(1, 2)]

[15:24] <p6eval> ..rakudo 31156: OUTPUT[[1, 2]]

[15:29] *** [particle] joined
[15:29] *** charsbar left
[15:37] *** Exodist joined
[15:39] <pmurias> pmichaud: what's the state of the "This Week in Perl 6" attempt? 

[15:39] *** charsbar joined
[15:39] <pmichaud> It didn't happen last night, so probably tonight.

[15:39] <lambdabot> pmichaud: You have 1 new message. '/msg lambdabot @messages' to read it.

[15:39] <pmichaud> @messages

[15:39] <lambdabot> s1n said 11h 15m 11s ago: i have something i need help testing, i have monday night free to finish this patch

[15:43] *** smg left
[15:43] <pmurias> pmichaud: re raports/news how would you like to receive them?

[15:47] <pmichaud> email is probably best, but I'll take them however

[15:48] <pmichaud> [email@hidden.address]
[15:49] <pugs_svn> r22255 | moritz++ | [t/spec] unfudged a test that bacek++ made work in rakudo

[15:50] *** hanekomu_ joined
[15:52] *** kst``` left
[15:52] *** kst``` joined
[15:53] <moritz_> pmichaud: do you want/need any reports on test suite progress?

[16:07] *** hanekomu left
[16:08] *** Myoma left
[16:10] *** Myoma joined
[16:13] *** hercynium joined
[16:16] *** kst``` left
[16:16] *** kst``` joined
[16:22] *** Ehtyar left
[16:27] *** masak left
[16:27] <pmichaud> moritz_: all reports are welcome :-)

[16:28] *** pht joined
[16:28] <pht> quick question - how to declare a constant? i recall it was something like my $foo is constant, but that works not

[16:29] <moritz_> constant $foo = 3; # iirc

[16:29] <moritz_> pugs: constant $x = 3; say $x;

[16:29] <p6eval> pugs: OUTPUT[3␤]

[16:29] <moritz_> pugs: constant x = 3; say x;

[16:29] <p6eval> pugs: OUTPUT[*** ␤    Unexpected "="␤    expecting ":" or "("␤    at /tmp/WYUW3ENQvo line 1, column 12␤]

[16:29] <moritz_> pugs: constant x := 3; say x;

[16:29] <p6eval> pugs: OUTPUT[*** ␤    Unexpected "="␤    expecting "("␤    at /tmp/jGXL8YvBwf line 1, column 13␤]

[16:29] <moritz_> I think that it should also work, but not sure

[16:30] <pht> > constant $str = 'foo';

[16:30] <pht> Null PMC access in type()

[16:30] <lambdabot>   mueval: Prelude.read: no parse

[16:30] <moritz_> pht: I didn't say that rakudo implemented it ;)

[16:30] <pht> okay so basically it's not implemented

[16:31] <pht> (in rakudo)

[16:31] <pht> another q:

[16:31] <moritz_> rakudo: constant $x = 2; say $x;

[16:31] <p6eval> rakudo 31156: OUTPUT[scope declarator 'constant' not implemented at line 1, near "= 2; say $"␤␤current instr.: 'parrot;Perl6;Grammar;Actions;scope_declarator' pc 121995 (src/gen_actions.pir:8516)␤]

[16:31] <moritz_> there you go, it even says nicely that it's not implemented ;)

[16:31] <pht> > sub a ($x is rw) { say "$x"; }

[16:31] <lambdabot>   mueval: Prelude.read: no parse

[16:32] <pht> > a('sth');

[16:32] <lambdabot>       lexical error in string/character literal at character 't'

[16:32] <pht> shouldnt this throw some error ?

[16:32] <moritz_> rakudo: sub a ($x is rw) { say "$x"; }; a('sth');

[16:32] <p6eval> rakudo 31156: OUTPUT[sth␤]

[16:32] <moritz_> pht: why?

[16:32] *** kanru2 joined
[16:32] <pht> because i'm feeding a constant into what should be rw

[16:32] <moritz_> but that's only an error if you actually try to modify it

[16:33] <pht> > sub a ($x is rw) { $x ~= 'bah'; say "$x"; }

[16:33] <lambdabot>   mueval: Prelude.read: no parse

[16:33] <pht> works too

[16:33] <moritz_> rakudo: sub a ($x is rw) { $x ~= 'bah'; say "$x"; }; a('sth');

[16:33] <p6eval> rakudo 31156: OUTPUT[sthbah␤]

[16:34] <moritz_> I guess that's an error

[16:34] <pht> but maybe my first q explains it

[16:34] <pht> (constants not implemented)

[16:34] *** jferrero left
[16:34] <moritz_> no, I think that's a value/container distinction thing

[16:35] <pht> shall i submit somewhere?

[16:35] <moritz_> rakudo: sub a ($x) { $x = 3; say $x}; a(4)

[16:35] <p6eval> rakudo 31156: OUTPUT[Cannot assign to readonly variable␤current instr.: 'a' pc 166 (EVAL_15:71)␤]

[16:35] <moritz_> pht: please do, to [email@hidden.address]
[16:35] <pht> can you try it with pugs: (or can I?)

[16:36] <moritz_> you can

[16:37] *** kst``` left
[16:37] *** kst```` joined
[16:37] <pht> pugs: sub a ($x is rw) { $x ~= 'bah'; say "$x"; }; a('sth');

[16:37] <p6eval> pugs: OUTPUT[*** Can't modify constant item: VStr "sth"␤    at /tmp/i7WG8BtOn0 line 1, column 20-31␤]

[16:37] <pht> pugs: sub a ($x is rw) { say "$x"; }; a('sth');

[16:37] <p6eval> pugs: OUTPUT[sth␤]

[16:38] <pht> still, it seems weird, because 'is rw' should specifically ban constants. or not?

[16:38] <moritz_> I think it "claims the variable for writing", which doesn't have to fail

[16:39] <pht> rakudo: sub a ($x is rw) { $x += 3; say $x}; a(4);

[16:39] <p6eval> rakudo 31156: OUTPUT[7␤]

[16:39] <pmichaud> rakudo doesn't yet treat constant values as read-only

[16:39] <moritz_> rakudo autovivifies a container here it seems

[16:40] <pmichaud> well, $x is still a container, yes.

[16:40] <pht> pugs: my $str is Str = 'foo';

[16:40] <p6eval> pugs: RESULT[\"foo"]

[16:40] <pht> rakudo: my $str is Str = 'foo';

[16:40] <p6eval> rakudo 31156: RESULT["foo"]

[16:41] <pht> seems i have older version ... 'PAST::Compiler can't compile node of type Perl6::Grammar'

[16:41] <pugs_svn> r22256 | moritz++ | [t/spec] removed some obsolete usages of 'is $stuff, undef'

[16:46] <moritz_> pmichaud: mail sent

[16:46] <pmichaud> thanks!

[16:47] *** eternaleye_ joined
[16:50] *** kanru left
[16:50] *** kanru2 is now known as kanru

[16:55] *** eternaleye left
[17:05] *** _jedai_ left
[17:05] *** _jedai_ joined
[17:09] *** eternaleye_ left
[17:13] *** smg joined
[17:22] *** schmalbe left
[17:28] *** [particle] left
[17:29] *** iblechbot left
[17:32] *** wknight-work joined
[17:32] <wknight-work> I would like to get a pugs commit bit, to do some work on the Perl 6 book

[17:33] *** hanekomu joined
[17:34] *** ruoso joined
[17:35] <TimToady> msg me your email and preferred user name

[17:35] <TimToady> wknight-work: and I can give you a commit bit

[17:36] <ruoso> Hello!

[17:37] <wknight-work> sent

[17:38] *** zamolxes left
[17:39] <ruoso> TimToady, could you please clarify for me how "my @a = @b" at the same time copies the array and preserves lazyness?

[17:40] <TimToady> it's possible that we'll define assignment to be eager by default

[17:41] <TimToady> either that

[17:41] <ruoso> so my @a = map { ... }, @b would be eager...

[17:41] <TimToady> or we'll define some kind of crossover where it switches from eager to lazy

[17:41] <TimToady> much like regexes switch from pure dfa-able to nfa-ish

[17:42] <TimToady> if we go the eager assignment route, then we'd probably make push lazy :)

[17:43] <TimToady> but maybe not

[17:43] <ruoso> lazy push is something I doesn't really understand...

[17:43] <pugs_svn> r22257 | Whiteknight++ | first edit, adding myself to AUTHORS

[17:44] <wknight-work> done!

[17:44] <wknight-work> Thanks TimToady!

[17:45] <TimToady> we have to have some way of adding lazy iterators to the "specs" of an array, if we want lazy arrays

[17:46] <TimToady> even if some of the array is already evaluated

[17:47] <TimToady> but at the moment I'm actually leaning toward defining some eager/lazy compromise, where we can guarantee that easy things get done eagerly and hard things get done lazily

[17:47] <TimToady> for some definition or other

[17:47] <ruoso> I was considering that lazy lists are always read only

[17:48] <TimToady> p6 arrays have always been lazily extensible

[17:48] <TimToady> and arrays are read-write

[17:49] <ruoso> I can't think of a use case for lazy write on the array...

[17:50] <ruoso> I could think of a composite array that has some fixed values and a lazy iterator as a backend for the other values

[17:50] <pmurias> ruoso: hi

[17:50] <ruoso> hi pmurias 

[17:50] <TimToady> well, what if you want to add another iterator to an existing array?

[17:50] *** hanekomu_ left
[17:51] <ruoso> hmmm... I see... like if you could access the iterators of the list individually

[17:52] <ruoso> something working on the line of slice context, for instance, that gives you another view on the array

[17:53] <ruoso> but one could argue that adding another iterator is

[17:53] <ruoso> my @c = (@a, @b)

[17:53] <ruoso> I was thinking on implementing that in terms of iterators too

[17:53] <TimToady> the basic question to me is how push should behave

[17:54] <ruoso> it depends on the backend of each list

[17:54] <ruoso> some simply doesn't support it

[17:54] <ruoso> like 'feed's

[17:55] <ruoso> other can store the value directly, like plain arrays

[17:56] <pmurias> the list is already a wrapper around the iterator so i don't see why it can't support push (not sure if it should)

[17:56] <ruoso> pmurias, it depends...

[17:56] <TimToady> maybe if you could tell an iterator what its successor is...

[17:57] <ruoso> sometimes it's the iterator that is a wrapper

[17:57] <ruoso> sometimes it's the list

[17:57] <ruoso> the relationship between the list and the iterator is up to them

[17:57] *** braceta left
[17:58] <ruoso> for instance...

[17:58] <ruoso> a plain array contains the actual values... an iterator to that array will be a simple wrappre

[17:58] <pmurias> i understand

[17:59] *** sri_work_ joined
[18:02] <pmurias> ruoso: i got pugs to compile $*OUT.print("...") to m0ld, but i need to handle scalar/value destinction to push it farther

[18:04] * pmichaud eagerly awaits assignment/interpolation clarifications :-)

[18:04] <pmurias> i could either add a FETCH to *everything* now (not nice), or add context to the method call opcode (don't know how to push it into the SMOP_DISPATCH)

[18:05] <pmurias> pmichaud: you are supposed to be planning a new way of doing context in rakudo?

[18:05] <pmichaud> pmurias: I am?  or perhaps I don't understand the question.

[18:06] <pmurias> pmichaud: jonathan told me so

[18:06] <pmichaud> I'd need to know the context of the comment, I guess.  :-)

[18:06] * pmurias is searching the irc log

[18:07] <pmurias> http://irclog.perlgeek.de/parrot/2008-09-13#i_566007

[18:07] <lambdabot> Title: IRC log for #parrot, 2008-09-13

[18:08] <pmichaud> oh, &want

[18:08] <pmichaud> I'm waiting to see how Parrot's calling conventions evolve before I worry too much about &want

[18:08] <ruoso> pmurias, FETCH to *everything* is how I planned to do... forward context propagation should avoid unecessary calls

[18:09] <ruoso> but as an optimization

[18:09] *** rindolf joined
[18:10] <pmichaud> in Parrot a called subroutine can already do some (limited) introspection to figure out what the caller is expecting back, but that interface is undergoing some changes right now in a branch as part of the pdd27mmd branch that allison is working on

[18:10] <pmichaud> in particular, I think that Parrot's calling conventions are moving almost entirely to a Perl 6-like capture model

[18:10] <pmurias> ruoso: what i don't like about FETCHing *everything* is that *everything* needs to be FETCHable

[18:10] <ruoso> yes... that's the part of "every value is a scalar of itself"

[18:11] <ruoso> and "every value is a list with one element that contains itself"

[18:11] <pmichaud> and since the same conventions are used for returning values as for calling a sub, we may end up with significant support built-in to Parrot for key features of want

[18:12] <ruoso> I'm trying to avoid "forward context propagation" at this moment, because it would make SMOP much more complex than it is at the moment...

[18:12] <ruoso> "late context propagation" makes things much simpler...

[18:13] <ruoso> every method call can simply return the value, and that's all..

[18:13] <pmurias> ruoso: why would it make SMOP that much more complex

[18:13] *** _jedai_ left
[18:13] <ruoso> because you would have a lot of "if context == foo, then ..., else ..." 

[18:13] <pmurias> ?

[18:14] *** eternaleye_ joined
[18:14] *** _jedai_ joined
[18:14] <pmurias> but now you would have loads of FETCH,postcircumfix:<[ ]>,push,shift.... in every class

[18:14] <pmurias> s/class/RI

[18:14] <ruoso> pmurias, only in the RIs that need to be used in item context...

[18:15] <ruoso> or in list context...

[18:15] <ruoso> and a value might return a read-only list in list context...

[18:15] <ruoso> which means, no push, no shift...

[18:16] *** sri_work left
[18:16] <ruoso> the basic difference is that SMOP will probably fail with "Can't locate object method push" instead of "Can't push in read-only list"

[18:16] <pmurias> and map and grep...

[18:17] <pmurias> ;)

[18:17] <ruoso> map is no longer a method of list

[18:17] <ruoso> ;)

[18:17] <pmichaud> map and grep are methods of Any

[18:17] <pmurias> RI's don't do inheritence, maybe they could if they were generated

[18:18] <pmurias> instead of hand (written|copy-and-pasted)

[18:18] <ruoso> pmurias, now you gave me a very good reason for your RI DSL

[18:18] <pmurias> ruoso: the if context == stuff would be only in a few context sensitive places

[18:19] <pmurias> is there a way of putting context in SMOP_DISPATCH?

[18:20] <ruoso> I was thinking about putting context in the capture

[18:21] <ruoso> which would allow us to support multi-resolving-based-on-context on the future

[18:21] <pmurias> visit from a friend&

[18:21] <ruoso> but I really would like to stick with 'late context propagation' for now...

[18:22] *** iblechbot joined
[18:25] *** hanekomu left
[18:25] <pmichaud> TimToady:  STD.pm currently defines all of the terminator:sym<whatever> tokens with   <?before 'whatever' » >

[18:25] <pmichaud> but all of the calls to <terminator> as a subrule are (thus far) also embedded in <?before ...>

[18:26] <pmichaud> seems like we should be able to get rid of one or the other <?before ...> calls

[18:26] <pmichaud> (my preference would be to see token terminator:sym<foo> defined without the <?before ...> )

[18:26] <pmichaud> although I understand why it makes more sense to have <?before ...> there.

[18:44] *** lisppaste3 joined
[18:51] *** REPLeffect joined
[18:53] <TimToady> pmichaud: testing...

[18:54] <rakudo_svn> r31158 | pmichaud++ | [rakudo]: spectest-progress.csv update: 162 files, 3361 passing tests

[18:55] <pmichaud> I can argue it either way, so I definitely defer to your intuition/judgement on that one.  it just looked a bit funny to me at first.

[18:58] <pugs_svn> r22258 | lwall++ | [STD] remove redundant befores from terminators per pmichaud++

[18:59] *** _jedai_ left
[19:00] *** _jedai_ joined
[19:00] *** wknight-work left
[19:09] <cognominal> perl6:   say m/.../.WHAT

[19:09] <p6eval> pugs: OUTPUT[Regex␤]

[19:09] <p6eval> ..elf 22258: OUTPUT[Regexp␤]

[19:09] <p6eval> ..rakudo 31158: OUTPUT[Block␤]

[19:26] <TimToady> none of those are actually correct, since m/.../ is supposed to run immediately and return a Match object

[19:26] <pmichaud> right -- we were discussing it on #parrot

[19:27] <pmichaud> rakudo doesn't do the immediate match semantics yet

[19:27] <pmichaud> however, it did bring up a question in my mind, that   $x ~~ m/.../   can get a bit tricky on the implementation side

[19:27] <pmichaud> because we want to match against the pattern, and not against the immediate match result

[19:27] *** larsen_ joined
[19:28] *** eternaleye_ left
[19:28] <TimToady> okay, I'll think about that some

[19:28] *** ashizawa left
[19:29] <pmichaud> but it also begs the question of how one would do  $x ~~ s/foo/bar/;    to do a substitution on something other than $_

[19:29] <pmichaud> (they're effectively related.)

[19:29] <pmichaud> for now I'm sweeping it under the rug of "smart match sometimes has to be really smart (and ugly)"

[19:30] <TimToady> well, we've always said that ~~ has some macro characteristics

[19:30] <pmichaud> correct

[19:30] <TimToady> maybe that's just part of it

[19:30] <pmichaud> yes, that's the rug I'm using right now :-)

[19:30] <pmichaud> gotta pick up kids, back in 35

[19:31] *** zamanfou joined
[19:35] *** zamolxes joined
[19:38] *** japhb joined
[19:46] *** clintongormley left
[19:49] <pugs_svn> r22259 | lwall++ | [t/spec] two simple syntax errors found by STD

[19:52] *** sri_work_ left
[19:56] *** ispy_1 joined
[19:56] *** ispy_1 left
[19:56] *** xuser left
[19:57] *** xuser joined
[19:57] *** pht left
[19:58] <pmurias> TimToady: does putting the context in the capture contractic the spec in any serious way?

[19:59] *** justatheory_ joined
[19:59] *** justatheory left
[20:09] <TimToady> pmurias: I don't believe so, but I could be wrong.  :)

[20:11] *** ispy_ left
[20:13] *** hanekomu joined
[20:14] *** zamanfou left
[20:23] *** rindolf left
[20:32] *** wknight8111 joined
[20:32] *** ab5tract joined
[20:35] *** zamolxes left
[20:40] *** AzureStone joined
[20:43] <rakudo_svn> r31160 | pmichaud++ | [rakudo]:  Fix <?before <terminator>> to be <?terminator>.

[20:45] *** hercynium left
[20:46] *** eternaleye_ joined
[20:50] *** hanekomu_ joined
[20:52] <pmichaud> std:  $ if 1;

[20:52] <p6eval> std 22259: OUTPUT[parsed␤]

[20:55] *** jan_ left
[20:58] * ruoso later &

[20:58] *** ruoso left
[21:01] *** jan_ joined
[21:09] *** hanekomu left
[21:10] *** justatheory_ is now known as justatheory

[21:11] *** AzureStone_ joined
[21:11] <rakudo_svn> r31163 | pmichaud++ | [rakudo]: Fix statement modifier after listops (RT #57352, #57334, #57076)

[21:14] *** mberends left
[21:16] *** AzureStone__ joined
[21:25] *** _jedai_ left
[21:26] *** _jedai_ joined
[21:26] *** cognominal left
[21:27] *** AzureStone left
[21:28] *** alester left
[21:30] *** cotto_w0rk joined
[21:39] *** cognominal joined
[21:40] *** pmurias left
[21:41] *** Bzek left
[21:55] *** Limbic_Region joined
[21:55] <pugs_svn> r22260 | moritz++ | [t/spec] fixed pick.t, and fudged for rakudo

[22:01] <rakudo_svn> r31165 | moritz++ | [rakudo] add newly fudged pick.t to spectest_regression

[22:11] *** alester joined
[22:20] *** BinGOs_ joined
[22:29] *** moritz_ joined
[22:29] *** _jedai_ left
[22:30] *** _jedai_ joined
[22:39] *** larsen_ left
[22:40] *** BinGOs left
[22:44] *** dduncan joined
[22:48] *** cotto_w3rk joined
[23:04] *** cotto_w0rk left
[23:12] *** hanekomu_ left
[23:20] *** smtms left
[23:35] *** Exodist left
[23:49] *** eternaleye_ left
[23:55] *** Ontolog left
