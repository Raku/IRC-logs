[00:01] <ruoso> @tell pmurias, although I now understand what TimToady said about "if two packages want to share a global variable, they need a third package that doesn't change version so often". This means that the global name of the package includes the version and author, as I first suspected... package Foo {...} creates a lexical bind to the package that is stored as *Foo:ver<x.u>:auth<foo>

[00:01] <lambdabot> Consider it noted.

[00:02] <ruoso> @tell pmurias, but this obviously only happen when the module is actually versioned (I think)... which means that global unique resources might be stored in a non-versioned package (although it does make sense to use the versioning even so)

[00:02] <lambdabot> Consider it noted.

[00:05] *** cjfields left
[00:08] <ruoso> @tell pmurias, but I think a different type of package in which the 'use' actually binds to a clone is indeed usefull and provides a more concurrency-friendly environment... we just need a keyword for it ;)

[00:08] <lambdabot> Consider it noted.

[00:14] *** Aisling joined
[00:17] *** hercynium_ joined
[00:17] <ruoso> it actually doesn't need to be a type of package... just a trait of a package..

[00:31] <ruoso> std: my module Foo is export { sub bar {...} }

[00:31] <p6eval> std 22358: OUTPUT[parsed␤]

[00:32] <ruoso> std: my module Foo is export, closed { sub bar {...} }

[00:32] <p6eval> std 22358: OUTPUT[parse failure␤]

[00:32] <ruoso> std: my module Foo is export is closed { sub bar {...} }

[00:32] <p6eval> std 22358: OUTPUT[parsed␤]

[00:33] <ruoso> std: my module Foo is export is closed is cloned { sub bar {...} }

[00:33] <p6eval> std 22358: OUTPUT[parsed␤]

[00:34] <ruoso> heh.... I think that three traits could express the concept pmurias wants... better find a keyword :)

[00:45] *** Alias_ joined
[00:46] *** jferrero left
[00:53] *** eternaleye joined
[01:03] *** araujo joined
[01:14] *** Jedai left
[01:16] *** hercynium_ left
[01:18] *** Jedai joined
[01:32] *** ruoso left
[01:44] *** l_a_m_p joined
[02:12] *** Ontolog joined
[02:12] <Ontolog> hi

[02:26] *** wknight8111 left
[02:29] *** dduncan joined
[02:32] *** meppuru joined
[02:34] <mncharity> @tell pmurias Sorry I'm late.  Short-form is there were pugs backends years ago, passing >50% of t/.  Everything since, p5 rx engines, redsix, mp6, kp6, winter_jig, elf, others, is all because pil doesn't have oo.  There've been workarounds, and attempts to hack it in.  Maybe you can manage.  Or motivate audrey.  But... with STD.pm and elf at this point, I'm not sure the payoff is there anymore.[...]

[02:34] <lambdabot> Consider it noted.

[02:38] <mncharity> @tell pmurias [...] Easy enough to add alternate IR's.  IRx1 was optimized for low project risk, not beauty.  Easy enough to generate a pil-ish IRx2 off of it.  That's the plan anyway.  Added a note to http://perl.net.au/wiki/Elf about that yesterday(?).  Anyway, questions welcome.  Having attempted pil workarounds, I'd also be happy to discuss them if you really want to go that route.

[02:38] <lambdabot> Consider it noted.

[02:40] *** Torment joined
[02:48] *** meppl left
[02:59] *** Jedai left
[03:04] <pugs_svn> r22359 | putter++ | [elf] Moved backend-specific code out of Parser.pm.

[03:05] <mncharity> 40k spams in one day.  sigh.  'night all.

[03:11] *** mncharity joined
[03:15] <mncharity> @tell pmurias re using elf vs pugs as a frontend: [...] but if pugs is working for you for now, great.  If it isn't easy to switch over later, then elf isn't what it's supposed to be.  Not having current users does have the upside of allowing focus on the bootstrap.  I'd just suggest hesitancy about burning too much time attempting pil workarounds.

[03:15] <lambdabot> Consider it noted.

[03:15] *** mncharity left
[05:15] <Ontolog> what is the difference between Rakudo's grammar and actions.pm and STD.pm?

[05:17] <Ontolog> if they accomplish the same thing, parsing Perl 6, why are they both being developed independently? After all, Rakudo's grammer and actions are a subset of Perl 6

[05:20] <dduncan> its about coming to the goal from different directions

[05:21] <dduncan> STD.pm represents a goal state, when bootstrapping exists that you can write a Perl 6 parser in itself, and writing it also helps test corner cases in the Perl 6 design

[05:22] <dduncan> Rakudo's grammar is something that already works right now for what subset of Perl 6 it supports, doesn't itself depend on Perl 6, and is working up to supporting STD.pm

[05:22] <dduncan> I haven't heard of actions.pm before

[05:24] <[particle]> rakudo's grammar is src/parser/grammar.pg

[05:24] <[particle]> it's rakudo's approximation of STD.pm

[05:25] <[particle]> after rakudo has longest-token matching and protoregex support, it will be converted to run STD.pm directly

[05:25] <[particle]> src/parser/actions.pm turns the pars tree (output of matching STD.pm grammar) into the abstract syntax tree

[05:25] <[particle]> *parse

[05:27] <dduncan> how long do you figure that longest-token match etc support will take?

[05:28] <dduncan> eg how soon do you figure Rakudo will be running STD.pm?

[05:29] <[particle]> ltm and protoregexes should take ~2mo

[05:29] *** justatheory joined
[05:29] <[particle]> std shortly after, within a month

[05:30] *** xinming joined
[05:33] <Ontolog> 3 months?

[05:33] <Ontolog> 啊哟

[05:36] <Ontolog> since we got that big donation to the perl foundation, shouldn't things be going faster now?

[05:36] <Ontolog> are we able to hire full-time people?

[05:36] *** ahmadz_ left
[05:42] <dduncan> 3 months sounds fine to me ... once that's done I'll start trying to use Rakudo for some serious work

[05:45] <[particle]> 3 months is how long we expect it to take, with funding

[05:45] <[particle]> yes, we expect rakudo to be ready for "serious work" by end of this year

[05:48] *** Psyche^ joined
[05:56] <Ontolog> i want to do "serious work".. which part can I hack on to get it closer to the "serious work" phase?

[05:57] <[particle]> well, there are three main drivers for rakudo development

[05:58] <[particle]> 1) languages/perl6/ROADMAP - this is what we need to do to get to the finish line, roughly in order and roughly broken down by hours

[05:59] <[particle]> 2) build an application that exercises rakudo - November developers have had a lot of input as to what gets done to meet their needs

[06:00] <[particle]> 3) convert tests to spectests and fudge them for rakudo - this lets us know what's broken, and we can look for things that can be easily added to make rakudo pass more spectests

[06:00] <Ontolog> i know there are lots of things in different areas, i'm asking specifically to get to the bootstrapping goal

[06:01] *** Patterner left
[06:01] *** Psyche^ is now known as Patterner

[06:01] <[particle]> bootstrapping isn't a near-term rakudo goal

[06:01] <[particle]> functionality is.

[06:02] <[particle]> if you mean writing more of rakudo in perl 6, like the runtime library, then we need namespace exporting implemented

[06:02] <[particle]> just like it's specified in S04 (i think)

[06:03] <Ontolog> which parts of rakudo are already written in perl6?

[06:03] <[particle]> the parser, and ast converter

[06:03] <[particle]> the builtins are written largely in pir

[06:03] <Ontolog> that's the grammar.pg and actions.pm right?

[06:03] <[particle]> yep

[06:04] <Ontolog> i see

[06:04] <Ontolog> thanks for your answers

[06:04] <[particle]> np

[06:08] *** justatheory left
[06:13] <xinming> Ontolog: IIRC, the bootstrap won't happen until we have a stable Grammar engine.

[06:14] <Ontolog> the grammar engine is unstable?

[06:14] <xinming> No implementation.

[06:14] *** justatheory joined
[06:15] <xinming> Most of implementation in my understanding, Is kinda like Pugs rewrite within other language. :-D

[06:15] <xinming> well, might be wrong.

[06:16] <Ontolog> well the grammar engine is actually part of Parrot itself

[06:16] <Ontolog> and I think it's pretty stable, as it has been worked on since the beginning of Parrot (afaik)

[06:17] *** meppuru left
[06:17] <[particle]> not since the beginning of parrot, but for a long time, and it's stabe

[06:17] <[particle]> *stable

[06:17] <[particle]> but, that's where protoregex and ltm changes will be

[06:17] <[particle]> the api shouldn't change (much)

[06:18] <[particle]> but the internals will be seriously reworked

[06:21] <xinming> I might be wrong, perl6's original plan is write a mini-perl with grammar engine support, and compile perl6 source to parrot byte code. If grammar engine is stable, Why people won't work directly on writing that /mini-perl/?

[06:23] <xinming> Or, after the plan is changed, Perl 6 tries to support multiple dynamic language as virtual machine?

[06:27] *** sri_work joined
[06:30] *** zamolxes left
[06:39] *** pmurias joined
[06:45] *** ashizawa joined
[06:55] *** Bzek joined
[06:56] *** dalek left
[06:57] *** dalek joined
[07:02] <rafl> do you know of any p5 parsers for perl6(ish?) signatures other than Perl6::Signature?

[07:07] <rafl> also i wonder how well the current implementations handle them

[07:08] *** Bzek left
[07:08] *** Guest70230 left
[07:08] *** yves left
[07:08] <moritz_> STD.pm parses them very well (but does nothing else with them)

[07:09] <moritz_> pugs and rakudo both parse basic positional, named, slurpy and default arguments and type constraints

[07:09] <moritz_> don't know of any perl 5 implementations, though

[07:10] *** hcchien joined
[07:11] *** kanru2 joined
[07:15] *** ashizawa left
[07:17] *** ashizawa joined
[07:18] <rafl> i can't find where parameter unpacking is handled. is that done yet? if so, where exactly is the relevant code?

[07:19] <moritz_> in which implementation?

[07:19] <rafl> STD.pm

[07:20] <moritz_> STD.pm does *only* parsing

[07:20] <rafl> that's what i'm after

[07:20] <moritz_> wait a sec...

[07:21] <pmurias> perl STD5_dump_match <<< ':($a,$b)'

[07:21] <lambdabot> pmurias: You have 3 new messages. '/msg lambdabot @messages' to read them.

[07:22] *** iblechbot joined
[07:23] <moritz_> rafl: take a look at 'token signature'

[07:23] <pmurias> @tell ruoso is closed is not a thing i'm arguing should be the default, if some has his own lexical copy of a module he can change it all he wants, it's just that if he wants to change my copy he should explicitly state that

[07:23] <lambdabot> Consider it noted.

[07:31] *** rakudo_svn joined
[07:31] *** Bzek joined
[07:31] *** Guest70230 joined
[07:31] *** kane_ joined
[07:31] *** yves joined
[07:31] *** charsbar joined
[07:31] *** gbacon joined
[07:31] *** pasteling joined
[07:32] <rafl> moritz_: did so already. seen nothing that looked like parameter unpacking to me. <?before <[ \< \( \[ \{ ]> > in token param_var might be part of array and hash unpacking, but i don't see how that works in detail or how unpacking single list arguments is done.

[07:33] <moritz_> rafl: what do you mean by "unpacking"?

[07:34] * moritz_ is confused about that term

[07:34] <moritz_> rafl: would a parse tree from STD.pm be some help to you?

[07:35] <rafl> http://perlcabal.org/syn/S06.html#Unpacking_array_parameters

[07:35] <rafl> i guess it would

[07:35] <lambdabot> Title: S06

[07:37] <pasteling> "moritz_" at 89.13.241.113 pasted "parse tree for rafl" (96 lines, 2.1K) at http://sial.org/pbot/32334

[07:37] *** ashizawa left
[07:37] <moritz_> rafl: in that parse tree, every line that does not end with a : represents a literal

[07:38] <moritz_> in the terminal it's colored and a bit nicer to read

[07:40] *** ashizawa joined
[07:40] *** cosimo joined
[07:44] <rafl> $gimme5 =~ s{/usr/local/bin/}{/usr/bin/env }; # kthx

[07:47] <pmurias> there is also ugly yaml output if you want it

[07:57] <rafl> seems like unpacking array and hash parameters isn't parsed yet

[08:04] <moritz_> write a test, and probably TimToady will take care of it

[08:05] <rafl> will do after getting some sleep. guess i still have a commit bit.

[08:05] <rafl> any objections to the above substitution in gimme5 and try5?

[08:06] <moritz_> it will break 'make' on Debian stable

[08:07] <rafl> why is that?

[08:08] <moritz_> because /usr/bin/env perl will usually invoke the system perl, which is 5.8.8 and thus too old

[08:08] <moritz_> if you make it an explicit perl5.10.0 that might work

[08:08] <rafl> i'm fairly sure that latest stable doesn't have a 5.10 installed into /usr/local/bin by default, so it's broken anyway

[08:09] <moritz_> rafl: not by default, but it can easily be added

[08:09] <rafl> just like PATH can be easily modified.

[08:09] <moritz_> rafl: whereas changing $PATH to point to a user perl is a much larger change, IMHO

[08:09] <rafl> anyway, bedtime.

[08:09] * rafl &

[08:16] *** elmex joined
[08:16] *** elmex left
[08:17] *** elmex joined
[08:17] *** elmex left
[08:17] *** elmex joined
[08:21] *** mj41 joined
[08:30] *** xinming_ joined
[08:33] *** clintongormley joined
[08:33] *** clintongormley left
[08:40] *** xinming left
[08:45] *** Alias_ left
[09:00] *** barney joined
[09:19] *** zamolxes joined
[09:21] *** ting joined
[09:30] *** wknight8111 joined
[09:39] <moritz_> smop: "test".print

[09:39] <p6eval> smop: OUTPUT[unknown method "print" at idconst_message line 71 file /home/evalenv/pugs/v6/smop/src/idconst.c␤]

[09:52] *** ruoso joined
[09:53] <pmurias> ruoso: hi

[09:53] <ruoso> hi pmurias...

[09:53] <lambdabot> ruoso: You have 1 new message. '/msg lambdabot @messages' to read it.

[09:53] <ruoso> pmurias, but do you agree with my reasoning on how the default works?

[09:54] * ruoso have to run...

[09:54] <pmurias> if you mean packages yes

[09:54] <ruoso> cool...

[09:54] * ruoso later &

[09:54] <pmurias> but i wait for TimToady to change his mind

[10:01] *** dduncan left
[10:18] *** l_a_m_p left
[10:30] *** wknight8111 left
[10:33] *** ruoso left
[10:35] *** Ontolog left
[10:41] *** zamolxes left
[11:00] *** wknight8111 joined
[11:09] *** iblechbot left
[11:14] *** kanru2 left
[11:15] *** barney left
[11:23] *** zamolxes joined
[11:27] *** araujo left
[11:30] *** araujo joined
[11:30] *** araujo left
[11:30] *** araujo joined
[12:20] *** pmurias left
[12:23] *** abra joined
[12:26] *** sirhc joined
[12:26] *** novaalpha joined
[12:26] <novaalpha> what is the name of "official" perl6 implementation?

[12:26] <novaalpha> rakudo? pugs? something else ?

[12:27] * novaalpha is a bit confused

[12:27] *** smg joined
[12:27] <moritz_> there's not one official implementation

[12:27] <moritz_> in the end everything that passes the test suite may call itself "Perl 6"

[12:28] <novaalpha> this is .. interesting.

[12:28] <novaalpha> to say the least.

[12:28] <moritz_> this is very usual

[12:28] <moritz_> just like ther's not one C compiler

[12:28] <novaalpha> you mean there is something else than gcc ?

[12:28] <moritz_> popular examples where it is handled like this are C, C++, Java, Fortran, Lisp

[12:29] <novaalpha> you're kidding, right?

[12:29] <novaalpha> :>

[12:29] * moritz_ is not a kid... oh, wait ;)

[12:29] <novaalpha> ko

[12:29] <novaalpha> ok

[12:29] <novaalpha> i got it

[12:29] <novaalpha> thx

[12:47] *** kanru joined
[12:55] *** pmurias joined
[12:58] *** ahmadz joined
[13:03] *** DJ-DONGDOT joined
[13:03] *** pjcj left
[13:10] *** zostay joined
[13:10] *** masak joined
[13:11] *** DJ-DONGDOT2 joined
[13:20] *** Lorn joined
[13:22] *** novaalpha left
[13:24] *** DJ-DONGDOT left
[13:26] *** azawawi joined
[13:27] *** DJ-DONGDOT2 left
[13:28] *** ahmadz left
[13:31] *** Ontolog joined
[13:32] *** ashizawa left
[13:34] *** DJ-DONGDOT joined
[13:37] *** iblechbot joined
[13:37] <pugs_svn> r22360 | putter++ | [elfish/on_sbcl] Variables fleshed out.  More prelude.

[13:37] <pugs_svn> r22360 | putter++ | Almost ready to run elf's Parser.pm.

[13:39] *** eternaleye left
[13:40] *** DJ-DONGDOT left
[13:40] *** eternaleye joined
[14:02] *** mncharity joined
[14:04] <mncharity> pmurias: re PIL backends, you might be able to use ideas or even code from: http://svn.pugscode.org/pugs/perl5/PIL2JS/  http://svn.pugscode.org/pugs/misc/old_pugs_perl5_backend/PIL-Run/  http://svn.pugscode.org/pugs/misc/old_pugs_perl5_backend/pilrun2-leftovers/ .

[14:05] <lambdabot> Title: Revision 22360: /perl5/PIL2JS

[14:05] *** jhorwitz joined
[14:05] <rakudo_svn> r31409 | pmichaud++ | [rakudo]: spectest-progress.csv update: 179 files, 3815 passing tests

[14:06] <mncharity> and it looks like it has indeed been 3 years since pugs got stuck.  2005-10 p5 backend development ceased.

[14:07] <mncharity> so it had to have been before then.  though for a while it looked like pil would be fixed "rsn".

[14:08] <mncharity> for context, PIL2JS was up around 80%(?) t/ passing.  basically as much as PIL permitted.  PIL-RUN was down around 50%.

[14:08] <mncharity> cheers. &

[14:08] *** mncharity left
[14:12] *** donaldh joined
[14:26] *** eternaleye left
[14:30] *** abra left
[14:31] *** pmurias left
[14:37] *** clintongormley joined
[14:41] *** Torment left
[14:50] *** jferrero joined
[14:51] *** kanru left
[15:08] *** clintongormley left
[15:12] *** Exodist joined
[15:26] *** pjcj joined
[15:26] *** TJCRI joined
[15:27] *** donaldh left
[15:27] *** donaldh joined
[15:50] *** masak left
[15:52] *** zamolxes left
[15:53] *** justatheory left
[15:54] *** justatheory joined
[15:57] <pugs_svn> r22361 | moritz++ | [t] move list_quote_whitespace.t to spec/, some fudge tweaking

[16:05] *** gbacon left
[16:06] <pugs_svn> r22362 | moritz++ | [t/spec] fudged listquote-whitespace.t for rakudo

[16:11] <rakudo_svn> r31414 | moritz++ | [rakudo] added list quoting test to spectest_regression

[16:12] *** gbacon joined
[16:14] *** eternaleye joined
[16:15] <pugs_svn> r22363 | moritz++ | [t] merged single_quoted_strings.t into quoting.t

[16:21] *** mach joined
[16:25] <pugs_svn> r22364 | moritz++ | [t] merged syntax/numbers/misc.t iinto radix.t, deleted duplicate tests

[16:31] <mach> When is Perl6 going to be released?

[16:34] <moritz_> when it's done

[16:34] *** pmurias joined
[16:35] <moritz_> or "as soon as possible"

[16:35] <moritz_> or "by christmas"

[16:35] <moritz_> pick whatever you like ;)

[16:36] *** neel_ joined
[16:37] *** eternaleye left
[16:37] <mach> moritz_: that was said in 1999.

[16:37] <moritz_> mach: and it's still true ;)

[16:38] <mach> moritz_: christmas of what year?

[16:38] <moritz_> but contrary to 1999 we know have a mostly-complete spec, a mostly-complete parser, parrot-0.7.1, pugs

[16:38] <moritz_> mach: dunno. Not this.

[16:41] <mach> now*

[16:41] <mach> well, i'll take your word for it.

[16:41] <pmurias> mach: by release you mean the 6.0.0 stable one

[16:45] *** [particle]1 joined
[16:54] <mach> pmurias: hopefully.

[16:54] *** donaldh left
[16:55] <pmurias> mach: most of the implementations had some releases by now

[16:57] <[particle]1> mach: you can help us. donate your time, or your money.

[16:57] <pmurias> i don't think people would be interested in switching to Perl 6 unless it was substantially better then Perl 5 so cutting corners and declaring it done prematurly isn't an option

[16:57] *** jferrero left
[16:58] <mach> [particle]1: i'm not very good with sharing my money.

[17:00] <[particle]1> then what you give is what you get ;)

[17:01] *** [particle]1 is now known as [particle]

[17:02] *** abra joined
[17:03] *** Jedai joined
[17:10] *** zamolxes joined
[17:13] * Khisanth suspects even 6.0.0 will not meet the 'substantially better than Perl 5' criteria

[17:14] <moritz_> Khisanth: depends on what you're looking at

[17:15] <moritz_> Khisanth: for parsing stuff with grammars it'll certainly be miles better

[17:23] <pmurias> NULL-- # it's pointless as sql still thinks it's NULL

[17:27] *** mach left
[17:46] *** mach joined
[18:05] *** Bzek left
[18:15] *** ruoso joined
[18:15] <pmurias> ruoso: rehi

[18:17] *** zostay left
[18:18] <pmurias> ruoso: i came to the conclusion that whether the starting package is * or some sort of a lexical one, and if the module is cloned or globally shared should be "use" semantics

[18:24] * ruoso bbiab &

[18:29] <ruoso> hi pmurias 

[18:30] <azawawi> hi

[18:30] <pmurias> azawawi: hi

[18:30] <azawawi> pmurias: how r u?

[18:30] <ruoso> pmurias, that's a very sane way of looking at it...

[18:31] <moritz_> azawawi: are you trying to bring run.pugscode.org back to life?

[18:31] <pmurias> azawawi: fine, finished ajaxy stuff for today will hack on smop now

[18:32] <moritz_> if not I'll remove the links to it

[18:32] <azawawi> moritz_: why not? ;-)

[18:33] *** meppl joined
[18:33] <azawawi> moritz_: im fixing POD errors at the moment in docs/Perl6/Spec

[18:33] <moritz_> not a bad idea either

[18:33] <pmurias> azawawi: what was your involment in run.pugscode.org?

[18:33] <azawawi> moritz_: then i will do smart links

[18:34] <azawawi> pmurias: finished the new ajax UI for it... and added tutorial+examples section.

[18:34] <pugs_svn> r22365 | azawawi++ | fix POD warnings in Spec/Concurrency.pod

[18:37] <pmurias> ruoso: our next objective for smop is bootstraping the oo metamodel?

[18:43] <pmurias> i think we could do it by using a RI.new(MESSAGE=>sub(...) {...},REFERENCE=>sub(...) {},RELEASE=>sub(...) {}) to create a responder interface for the first metaclass

[18:45] <ruoso> pmurias, there's already the PurePrototypeHow

[18:45] <ruoso> pmurias, that can be used together with p6opaque

[18:46] <ruoso> our major milestone is to finish writing src-s1p/P6Meta.pm and compiling it down

[18:46] <ruoso> then having it "use"d in the prelude scope

[18:49] <pmurias> so it's possible to create a class using only method calls now?

[18:52] <pmurias> seen test 28, it's always nice that more stuff is implemented than expected ;)

[18:56] *** wknight8111 left
[19:02] <ruoso> :)

[19:05] <pmurias> @tell mncharity thanks for the pointers pil1 has methods and class declarations, it seems to lack subclasses (haven't look how hard it would be to hack them in)

[19:05] <lambdabot> Consider it noted.

[19:08] <pmurias> ruoso: pugs seems to lack anonymous methods

[19:09] <ruoso> do we need it for something in the short-term?>

[19:11] <pugs_svn> r22366 | azawawi++ | Fixed pod warnings/errors in Spec/IO.pod

[19:17] <pugs_svn> r22367 | azawawi++ | Fix pod warnings in Spec/Functions.pod

[19:20] *** masak joined
[19:36] *** abra left
[19:37] <pmurias> ruoso: we can have methods created with method foo {}

[19:38] <ruoso> pmurias, I'm not sure I see what you mean...

[19:39] <pmurias> on the syntactic layer we can use method foo {} and have it desugar into $?CLASS.HOW().add_method("foo",method {...})

[19:42] <pmurias> smop: sub {$OUT.print("hello\n")}.()

[19:42] <p6eval> smop: OUTPUT[no variable $*OUT in the current scope␤]

[19:42] <pmurias> smop: sub {$*OUT.print("hello\n")}.()

[19:42] <p6eval> smop: OUTPUT[no variable $*OUT in the current scope␤]

[19:42] *** neel_ left
[19:42] *** neel_ joined
[19:43] <pmurias> moritz_: the pugs in the evalbot seems to be older than the smop

[19:48] <ruoso> pmurias, that might be related to the static linking...

[19:49] <pmurias> how? it work in my local copy

[19:49] <pmurias> * works

[19:49] <ruoso> I mean... the rebuilding process might not be rebuilding everything...

[19:49] <pmurias> ruoso: how doe $foo<key> := 123 work?

[19:49] <pmurias> * does

[19:50] <ruoso> $foo.postcircumfix:{ }("key").STORE(123)

[19:51] <pmurias> hmm

[19:55] <masak> wow, that notation really has explanatory power!

[19:55] <masak> but shouldn't it be postcircumfix:<{ }> ?

[19:57] <pmurias> yes

[19:57] <pmurias> it is postcircumfix:{ } internally because <> is used for quoting special chars here

[19:59] <masak> ah.

[19:59] <pmurias> ruoso: what i don't like is that $foo.postcircumfix:<{ }>($key) and $foo{$key} are not equivalent

[20:00] <ruoso> smop: my %a; %a{1};

[20:00] <p6eval> smop: OUTPUT[unknown method "postcircumfix:{}" at smop_s1p_scalar_message line 81 file /home/evalenv/pugs/v6/smop/src/smop_s1p_scalar.c␤]

[20:02] <ruoso> pmurias, are not?

[20:03] <ruoso> pmurias, why?

[20:06] <pmurias> $foo{$key} does an extra FETCH if used as an lvalue

[20:12] <pmurias> &

[20:14] <ruoso> hm?

[20:14] <ruoso> as an rvalue you mean...

[20:14] <ruoso> oh... wait...

[20:14] <ruoso> you mean $foo{$key} = 123?

[20:15] * ruoso is confused now...

[20:15] <ruoso> I know all this was already sorted out... It's just blurred on my mind now...

[20:21] <masak> pmurias: you mean there's an unnecessary FETCH when $foo{key} is assigned to? won't the parser detect that it's an lvalue?

[20:22] <ruoso> masak, the question is about the difference between ':=' and '='

[20:22] <masak> ah.

[20:22] <masak> but don't both these have lvalue context?

[20:27] *** jferrero joined
[20:27] *** mach left
[20:29] <ruoso> the question is that '$foo<abc> := 123' sets 123 as the container itself, while '$foo<abc> = 123' store the value inside the container...

[20:29] <ruoso> otoh, that seems to contradict other lvalue uses...

[20:29] <ruoso> like 'method foo is rw {...}'

[20:29] <ruoso> $obj.foo = 123

[20:29] <ruoso> this last line should be equivalent to

[20:29] <ruoso> $obj.foo.STORE(123);

[20:30] <masak> ruoso: I've always seen := as defaulting to = when the rvalue is a literal

[20:30] <ruoso> masak, it doesn't.... i.e:

[20:30] <ruoso> pugs: my $a := 1; $a = 2;

[20:30] <p6eval> pugs: OUTPUT[*** Can't modify constant item: VInt 1␤    at /tmp/5TL3sB6wMr line 1, column 13-19␤]

[20:30] <masak> ruoso: ah.

[20:31] <masak> I stand corrected :)

[20:31] *** sri_work left
[20:32] *** wknight8111 joined
[20:32] *** donaldh joined
[20:34] <ruoso> $a := 123 is easy...

[20:34] <ruoso> hmmm...

[20:34] <ruoso> actually... it's the same case

[20:34] <ruoso> I always thought on a double-boxing for variables...

[20:35] <ruoso> '$a := 123' woud be '___scope___<$a>.STORE(123)', while '$a = 123' would be '___scope___<$a>.FETCH.STORE(123)'

[20:47] <ruoso> pugs: my $a; sub foo is rw { $a }; foo() = 123; say $a;

[20:47] <p6eval> pugs: OUTPUT[123␤]

[20:47] <ruoso> maybe that means that every assignment implies the context *first*

[20:47] <ruoso> and '$obj.foo = 3' is compiled to '$obj.foo.FETCH.STORE(3)' while 'say $obj.foo' is compiled to 'say($obj.foo.FETCH.FETCH)

[20:47] <ruoso> maybe because $obj.foo = 3 implies item context...

[20:47] <ruoso> while $obj.foo = (1,2,3) implies list context...

[20:47] <ruoso> that way '$obj.foo = (1,2,3)' would be compiled to '$obj.foo.List.STORE(1,2,3)'

[20:47] * ruoso still confused...

[20:52] *** donaldh left
[20:53] *** zamolxes left
[21:02] <pmurias> ruoso: don't *2* FETCH'es for a .foo seem like too much

[21:02] <pmurias> ?

[21:03] <pmurias> btw $a := 123 is :($a).BIND(\(123))

[21:03] *** jhorwitz left
[21:05] *** eternaleye joined
[21:06] *** justatheory left
[21:07] <pmurias> maybe we have 3 contexts item,item's container,item's container container

[21:16] *** justatheory joined
[21:17] <masak> pmurias: oh my! what's the last one needed for?

[21:18] <pmurias> masak: binding

[21:18] * masak chews on that answer

[21:18] <pmurias> imagine what happens when you do $obj.foo := $bar

[21:21] <masak> yes... something in $obj called 'foo' will now be bound to $bar

[21:22] <masak> hm, something called '!foo', rather

[21:22] <masak> is that something a container?

[21:22] <pmurias> it's likely a pointer but we should expose it as a container

[21:23] <masak> mm

[21:24] <masak> so you're saying that because $bar is also a container,

[21:24] <masak> we get a container (!foo) of a container ($bar) of an item

[21:25] <masak> that sounds like faulty reasoning to me. what's to prevent the bindings from continuing from there? isn't it better to have both !foo and $bar point to the same item, and just be done with it? no containers of containers.

[21:36] <pmurias> stating something in more general terms doesn't solve the issue

[21:38] <pmurias> just making them point to the same thing doesn't work think about a := b;a := c;a = 3;

[21:38] <pmurias> b is not changed at all as := doesn't work at all

[21:42] <masak> pmurias: I fail to see your point. b is not changed, because you've made the container denoted 'a' point to the contents of 'c'

[21:42] <masak> I don't see how my world view fails to handle that case.

[21:43] <pmurias> fixing bug&

[21:45] <masak> talking to pmurias and ruoso often makes me feel one step behind in the reasoning :) still, I hope to learn a thing or two. keep up the good work, guys.

[21:49] <moritz_> masak: same here. I attribute that to fact that they have spent much more time thinking about meta object programming then we ;)

[21:49] <masak> most likely.

[21:49] <masak> come to think of it, I had the same feeling of left-behind-in-the-dust-ness when stevan frequented this channel

[21:50] <masak> I guess there's something about metamodels that makes people seem really smart :P

[21:52] <moritz_> does smartmatch usually force boolean context?

[21:53] <moritz_> if not, these tests are wrong:

[21:53] <moritz_> ok ($str ~~ any <foo bar baz>);

[21:53] *** ruoso left
[21:54] <masak> moritz_: that looks right to me

[21:54] <moritz_> because it will autothread on the smart match, return a junction of three booleans...

[21:54] <masak> ah.

[21:54] <moritz_> and continues to autothread through ok()

[21:54] <moritz_> and thus calls ok() three times

[21:54] <masak> that feels wrong, somehow :)

[21:55] <masak> basically, I expect _any_ boolean evaluation to evaluate to either True or False

[21:55] <masak> but I also see how ok() is different from if

[21:55] <moritz_> the question is, is ~~ a boolean evaluation?

[21:56] <moritz_> at least when matching regexes it returns a match object

[21:57] <moritz_> all other smart matches seem fairly boolean to me

[21:57] <masak> aye

[21:57] <masak> and even match objects boolify if needed

[21:57] <pmurias> moritz_: Some contexts, such as boolean contexts, have special rules for dealing

[21:57] <pmurias> with junctions.

[21:57] <moritz_> pmurias: I know that boolean context collapses them

[21:58] <moritz_> it's like a measurement in quantum mechanics ;)

[21:58] <pmurias> and i would guess ok forces bools context

[21:58] <masak> pmurias: explicitly?

[21:58] <masak> (as in 'sub ok( Bool $test )')

[21:59] <moritz_> I guess that won't work

[21:59] <pmurias> context aren't very clearly defined

[21:59] <pmurias> * contexts

[21:59] <moritz_> that would still autothread on junctions

[21:59] <masak> mm

[21:59] <moritz_> what one could do is 'sub ok( Object $test) '

[22:00] <moritz_> and then calling ?$test or !$test

[22:00] <masak> write and kvetch on p6l! :)

[22:00] * moritz_ feels like he's over-strainling p6l these days anyway

[22:01] <masak> no such thing :)

[22:02] <masak> if p6l gets too overstrained, we'll simply have to invite more people that can respond to your questions

[22:02] <moritz_> more people don't mean better decisions

[22:02] <masak> no, I know

[22:02] <moritz_> "9 women can't make a baby in one month"

[22:03] <masak> but it means better coverage, and possibly more total time for discussion

[22:03] <masak> seems to me people often block on not having enough time in the Perl 6 world

[22:03] <masak> (except for TSa, who seems to have a lot of time)

[22:04] <moritz_> masak: many beginners have enough time, but not enough understanding to seriously participate in the language design

[22:04] <pmurias> does he hack on anything?

[22:04] <moritz_> (I fear I'm one of them)

[22:04] <moritz_> not that I know of

[22:04] <masak> pmurias: no, but he knows a thing or two about type theory

[22:04] <moritz_> which might explain why he has so much time ;)

[22:05] <masak> moritz_: because his programs run correctly on the first go? :)

[22:05] <moritz_> masak: no, because he's not hacking on Perl 6

[22:05] <masak> ah.

[22:05] <moritz_> ;)

[22:06] <masak> no, I meant that I get the feeling that many people block on not having enough time for tinkering with Perl 6

[22:07] <masak> I know a handful who are doing it full-time: Larry, pmichaud...

[22:07] <moritz_> masak: Larry is not doing it full time

[22:07] <masak> ok, so pmichaud then.

[22:07] <pmichaud> I'm not full time either -- at least, I wasn't until a week or so ago :-)

[22:08] <pmichaud> I had non-perl full-time employment through the end of August.

[22:08] <moritz_> which leaves... none?

[22:08] <masak> pmichaud: good. that proves my point even more.

[22:08] <masak> Perl 6 is not something people do full-time right now

[22:09] <masak> (ooooh, I look forward to my first full-time Perl 6 employment)

[22:09] <pmichaud> Well, the Ian Hague grants should help with that a bit.  I know they help a bunch in my case.

[22:09] <pmichaud> Starting next week I should be 75% time on Perl 6.

[22:09] <moritz_> (Ian Hague)++

[22:09] <pmichaud> (possibly a bit more -- my 25% time job actually takes a bit less than 25% of my time, at least in the past)

[22:10] <masak> actually, in such a situation (where people have to juggle their time) answering emails might actually get in the way of hacking. no wonder things get warnocked at times

[22:10] <masak> the productive people might want to avoid email to remain productive

[22:12] *** PZt joined
[22:13] <pugs_svn> r22368 | moritz++ | [t] merged syntax/lf_in_list.t into listquote.t

[22:13] <moritz_> Donald Knuth is famous for not using email

[22:14] <pmichaud> I liked Larry Lessig's declaration of "declaring email bankruptcy"

[22:14] *** neel_ left
[22:14] <pmichaud> i.e., when the mail backlog gets too full, simply declare bankruptcy and get absolution from having to respond to your credi..., er, senders :-)

[22:15] * pmichaud wonders if he can get a $700B bailout to help deal with over-leveraged email accounts.

[22:16] <moritz_> heh

[22:16] <moritz_> I'd backlog for half of that ;)

[22:16] <masak> is a B the same as a gigabuck?

[22:17] <moritz_> b = billion = giga, yes

[22:17] <pmurias> masak: "point to the same item" what do you mean by that it can be interpreted as either assignment or !foo and $bar being the places where the container are stored and would imply containers knowing where they are stored

[22:18] <masak> pmurias: Eliza, is that you? :)

[22:18] <masak> sorry, reading again.

[22:18] <masak> pmurias: nope. I really don't understand that. sorry.

[22:19] <moritz_> std: 1< 2

[22:19] <p6eval> std 22368: OUTPUT[parse failure␤]

[22:19] <pmurias> i should use the comma more ;)

[22:19] <masak> pmurias: yes, please

[22:19] <moritz_> rakudo: say 1< 3

[22:19] <p6eval> rakudo 31421: OUTPUT[1␤]

[22:20] * moritz_ shakes his head about Perl 6 weirdnesses

[22:20] <moritz_> how will we ever be able to read that language?

[22:21] <masak> moritz_: just use whitespace between things that don't go together. "duh". :)

[22:21] <moritz_> masak: "duh" is a very good summary, yes

[22:21] <moritz_> this is getting pyhonesque dimensions

[22:21] <masak> we crossed that line ages ago

[22:21] <pmurias> masak: what do you mean by "have !foo and $bar point to the same item"

[22:21] <pmurias> ?

[22:22] <pmurias> rakudo: say 1 < 3

[22:22] <p6eval> rakudo 31421: OUTPUT[1␤]

[22:23] <masak> pmurias: I'm thinking of it the way I'm thinking about references in Java. Dog fido = new Dog(); Dog spot = fido; // one object, two "containers" pointing to it

[22:25] <pugs_svn> r22369 | moritz++ | [t] merge syntax/force_context.t into spec/S03-operators/context-forcers.t

[22:26] <pmurias> fido = Dog();spot = fido; #the python example is much clearer

[22:26] <masak> pmurias: fair enough.

[22:26] <masak> I don't do much python, but I can read it without a problem

[22:26] <pmurias> but that's only assignment

[22:27] <masak> yes, but it works like a kind of binding, because of the references

[22:27] <pmurias> it's possible to imagine a := in Java

[22:27] *** Lorn_ joined
[22:28] <masak> sure, but that's not my point

[22:28] <masak> my point is that you already have the semantics of := in Java because of the way assignment works on variables containing objects

[22:28] <masak> it doesn't clone the object, it just makes the other variable point to the same object

[22:28] <masak> that's binding to me.

[22:28] *** iblechbot left
[22:29] <pmurias> assignment works the same in Perl 6

[22:29] <masak> oh, ok

[22:29] <pmurias> my $fido = Dog.new;my $spot = $fido;

[22:29] <masak> I think this whole discussion shows that I have a very weak understanding of what binding really does in Perl 6

[22:29] <pugs_svn> r22370 | moritz++ | [t/spec] fudged context-forcers.t for rakudo

[22:30] <moritz_> I think that binding aliases containers

[22:30] <moritz_> $a := $b # whatever you do to $a also happens to $b, and vice versa

[22:31] <moritz_> it's what references are in C++

[22:31] <moritz_> easy to understand. Assignment is the tricky part ;)

[22:31] <pmurias> references in C++ are syntax sugar around pointer

[22:31] <pmurias> *pointers

[22:32] <masak> moritz_: ok, if that's true, then I understand pmurias' earlier point about $a, $b and $c

[22:32] <moritz_> pmurias: syntactic sugar that allows no way of un-aliasing

[22:33] <pmurias> yes

[22:33] <moritz_> is that the same in perl 6? or can we break binding?

[22:34] <moritz_> ("can we escape bondage?")

[22:34] * pmurias is confused

[22:34] <pmurias> btw it's possible to do binding with perl5 with Data::Bind

[22:35] <moritz_> I tried to not raise confusing topics yet ;)

[22:35] <pmurias> what do you mean by un-aliasing?

[22:36] <moritz_> pmurias: when I do $a := $b, everything that happens to $a also happens to $b. Is there a way to break that connection later on?

[22:36] <masak> 1. $a := $b; 2. ??? 3. $a !=:= $b

[22:37] <moritz_> masak: =:= is a comparison op, so $a !=:= $b is the same as !($a =:= $b)

[22:37] <pmurias> 1. $a := $b; 2. $a := $c

[22:37] <masak> moritz_: yes. that's what I intended

[22:38] <moritz_> pmurias: but if you do $a := $b; $a := $c, aren't then all three $a, $b and $c bound together?

[22:38] <pmurias> no

[22:38] <masak> pmurias: I thought you just said that all three will be the same in that case

[22:38] *** Jedai left
[22:38] <moritz_> masak: ah, I thought you wanted to answer, not to illustrate the question

[22:38] <moritz_> pmurias: is that specced? and tested?

[22:38] <masak> I want both :)

[22:39] <pmurias> masak: re "just said" where

[22:39] <moritz_> rakudo: my ($a, $b, $c); $a := $b; $a := $c; $b = 3; say $a

[22:39] <p6eval> rakudo 31421: OUTPUT[␤]

[22:40] <moritz_> rakudo agrees with pmurias, and leaves me puzzled behind

[22:40] *** Lorn left
[22:40] <moritz_> perl6: my ($a, $b, $c); $a := $b; $a := $c; $b = 3; say $a

[22:40] <p6eval> pugs, rakudo 31421: OUTPUT[␤]

[22:40] <p6eval> ..elf 22370: OUTPUT[syntax error at (eval 117) line 5, near "$a :"␤syntax error at (eval 117) line 6, near "$a :"␤ at ./elf_f line 3861␤]

[22:40] <pmurias> kp6:  my ($a, $b, $c); $a := $b; $a := $c; $b = 3; say $a

[22:40] <masak> pmurias: at 23:38 you said <pmurias> just making them point to the same thing doesn't work think about a := b;a := c;a = 3;

[22:40] <p6eval> kp6 22370: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤     ]

[22:40] <moritz_> but why doesn't rakudo warn about an uninitialized value? 

[22:40] <eternaleye> But what if you want to unbind it totally - you don't want it bound to something new, you want it back to being a normal variable?

[22:41] <moritz_> eternaleye: you can create an anonymous lexical to qhich you bind it

[22:41] <moritz_> eternaleye: $a := do { my $x }

[22:41] <eternaleye> Ah

[22:41] <pmurias> $a := Scalar.new;

[22:41] *** Jedai joined
[22:43] <pmurias> although moritz_'s way is more specced

[22:45] <masak> ok, I'm confused again. so moritz' description "whatever you do to $a also happens to $b, and vice versa" is not entirely correct, because you can make $a point to $c with $a := $c, which doesn't affect $b at all

[22:45] <masak> moritz_: maybe you meant "whatever you do (until the next rebinding of $a)"

[22:46] *** TJCRI left
[22:46] *** armagad joined
[22:47] <moritz_> masak: it seems that I have to updated my understanding of binding like this, yes

[22:48] <moritz_> uhm, could it be that "slurpy" used to be "splatty"?

[22:48] * masak thinks so

[22:49] <masak> it rings faraway bells

[22:49] <moritz_> uhm

[22:49] <moritz_> now I examined a file which I svn rm'ed before

[22:50] <moritz_> it was still on my disk, but not in the repo

[22:50] * moritz_ runs  rm -rf t/; svn up

[22:50] <moritz_> hope that won't happen again

[22:53] <moritz_> pugs: say (-> { 1; }).WHAT

[22:53] <p6eval> pugs: OUTPUT[Block␤]

[22:53] <moritz_> pugs: say Block ~~ Sub

[22:53] <p6eval> pugs: OUTPUT[␤]

[22:53] <masak> moritz_: I can attest to that. a Block ain't a Sub

[22:53] <moritz_> then why does t/blocks/code_blocks_as_sub_args.t pass in pugs?

[22:54] <moritz_> that seems like black magic (and wrong too)

[22:54] <masak> aye

[22:54] <moritz_> masak: I know it shouldn't

[22:54] <masak> you can return from a Sub, but not from a Block

[22:54] <moritz_> aye

[22:54] <masak> I found that out the hard way :)

[22:54] <moritz_> this whole test file seems so wrong

[22:54] <masak> delete it!

[22:55] <moritz_> so tempting

[22:55] <moritz_> must.

[22:55] <moritz_> resist.

[22:55] <masak> you can do it locally, at least

[22:55] <moritz_> :/

[22:57] <eternaleye> perl6: Sub ~~ Block # Either Pugs or Rakudo seems to be wrong

[22:57] <p6eval> elf 22370: RESULT[undef␤]

[22:57] <p6eval> ..rakudo 31421: RESULT[1]

[22:57] <p6eval> ..pugs: RESULT[Bool::False]

[22:58] *** armagad left
[22:58] <moritz_> you can't leave a sub with leave()

[22:58] <moritz_> so rakudo is wrong

[22:58] <moritz_> which isn't surprising, since it uses only one type internally for all code objects

[22:59] <masak> why can't you leave a sub with leave()?

[22:59] <moritz_> subs, regexes, blocks - all of parrot type 'Block'

[22:59] <moritz_> masak: because it's resevered for Blocks, I think

[22:59] <moritz_> masak: but I'm not sure, my S06 study is a bit outdate

[23:00] <masak> moritz_: does that mean that neither of Sub and Block is a subtype of the other?

[23:00] <moritz_> masak: yes (if true)

[23:00] <masak> then, what are they both subtypes of? Code?

[23:00] <moritz_> masak: both are of type Code

[23:00] <masak> oki

[23:02] <pugs_svn> r22371 | moritz++ | [t] (kinda) fix code_blocks_as_sub_args.t

[23:03] <[particle]> Routine iirc

[23:04] <masak> even clearer

[23:04] <masak> is Routine what distinguishes Block and Sub from e.g. Regex?

[23:05] <moritz_> probably

[23:05] *** Exodist left
[23:06] * masak opens up S06

[23:07] <masak> which means I get to read it in two weeks :)

[23:07] <moritz_> ;)

[23:07] <masak> well, g'night all

[23:07] <moritz_> unless you declare browser tab bankruptcy ;)

[23:08] <moritz_> good night masak & rest ;)

[23:08] <masak> moritz_: never!

[23:08] *** masak left
[23:13] *** pmurias left
[23:16] <moritz_> rakudo: say :2<2>

[23:16] <p6eval> rakudo 31422: OUTPUT[2␤]

[23:16] <pugs_svn> r22372 | moritz++ | [t/spec] fudged radix.t for rakudo

[23:28] *** Lorn_ left
[23:58] *** jferrero left
