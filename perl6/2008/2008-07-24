[00:10] *** timbunce left
[00:10] *** timbunce joined
[00:12] *** justatheory left
[00:14] *** Exodist left
[00:16] <ruoso> which is the opposite of a "multi" declaration? meaning... when you want a method to explicitly have only one signature...

[00:16] <lambdabot> ruoso: You have 1 new message. '/msg lambdabot @messages' to read it.

[00:17] <b_jonas> ruoso: dunno, I think that's the default

[00:17] <ruoso> but there's a specific name for that, isn't it?

[00:18] <b_jonas> maybe there's some equivalent to 'multi sub foo (signature)' like 'sub foo (signature) is multi' that you can negate with something like "isn't"

[00:18] <b_jonas> is there an "isn't" and "doesn't" btw?

[00:18] <b_jonas> possibly "is not" and "does not" and "has no"

[00:18] <b_jonas> because the apostrophes would be strange

[00:18] <ruoso> the keyword "only" 

[00:19] <b_jonas> ruoso: does that negate multi?

[00:19] <ruoso> yes

[00:19] <b_jonas> ah yeah, indeed

[00:20] <b_jonas> that's what S06 says

[00:20] <ruoso> I think I'll add different storage support for "multi methods" and "only methods"

[00:20] <ruoso> (in p6opaque, I mean)

[00:21] <b_jonas> which S documents the "is" and "does" and "has" modifiers?

[00:21] <ruoso> where one is Hash of Hash of Method and the other is a plain Hash of Method

[00:21] <ruoso> b_jonas, S12 documents OO mostly

[00:25] <b_jonas> "but not" might also make sense

[00:26] <ruoso> what does that mean?

[00:26] <ruoso> pugs: my $a = 1 but False; if (! $a) { say 1 };

[00:27] <p6eval> pugs: OUTPUT[*** Cannot cast from VBool False to Pugs.AST.Internals.VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤]

[00:27] <ruoso> pugs: my $a = 0 but True; if ($a) { say 1 };

[00:27] <p6eval> pugs: OUTPUT[*** Cannot cast from VBool True to Pugs.AST.Internals.VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤]

[00:29] <b_jonas> ruoso: it would undo a but

[00:29] <b_jonas> like

[00:29] <b_jonas> (1 but False) but not False

[00:30] <b_jonas> obviosuly you wouldn't write that like that but in a separate expression

[00:30] <pugs_svn> r21472 | lwall++ | more buglets

[00:31] <ruoso> b_jonas, (1 but False) but True ?

[00:31] <ruoso> rakudo: say (1 but False) but True

[00:31] <b_jonas> ruoso: that might work in the case of False

[00:31] <p6eval> rakudo 29712: OUTPUT[The but operator can only be used with a role or enum value on the right hand side␤current instr.: 'die' pc 11105 (src/gen_builtins.pir:7110)␤]

[00:31] <b_jonas> but you won't have such a negated role for most roles

[00:32] <b_jonas> though actually

[00:32] <b_jonas> it might have to be

[00:32] <b_jonas> (1 but False) but not Bool

[00:33] <b_jonas> because False is an enum, and so but not Bool would strip all the enum roles from the value

[00:33] <b_jonas> or at least I think False is an enum, maybe it isn't?

[00:33] *** elmex left
[00:33] <ruoso> it would probably make more sense (1 but False) doesnt Bool

[00:33] <b_jonas> yeah, it is an enum, says S12

[00:34] <b_jonas> "does not"? why?

[00:34] <b_jonas> I thought "does" was for classes

[00:34] <b_jonas> that is, applying a role to a class

[00:34] <ruoso> because "but True" actually means "does Bool, .bool = True"

[00:34] *** alester joined
[00:35] <b_jonas> is that the syntax?

[00:35] <ruoso> no... just a concept mock up

[00:35] <b_jonas> not "but Bool :bool<true>" or something else with "but"

[00:37] <b_jonas> wait, maybe there's both "but" and "does" with the only difference being that "but" creates a copy while "does" works in place?

[00:38] <ruoso> b_jonas, see the end of the "Roles" section in S12

[00:39] *** alester left
[00:39] <b_jonas> ruoso: yeah, so I think that's the only difference between but and does

[00:40] <b_jonas> also, the Enums section say that the syntax is this:

[00:41] <b_jonas> either of the following:

[00:41] <b_jonas>     $x = "Today" but Tue;

[00:41] <b_jonas>     $x = "Today" but day::Tue;

[00:41] <b_jonas>     $x = "Today" but day<Tue>;

[00:41] *** s1n left
[00:41] <b_jonas>     $x = "Today" but day(Tue);

[00:41] <b_jonas>     $x = "Today" but day(3);

[00:42] <b_jonas> the last two also work for any properties as defined in the Roles section, and enums are always properties as well

[00:42] *** japhb joined
[00:42] <b_jonas> it seems to imply that both Tue and day are roles in this case

[00:43] <b_jonas> (namely not just with the creation syntax but also by saying $x.does(Tue) and $x.does(day) are true for such an enum value)

[00:43] <b_jonas> so I'd think both "but not True" and "but not Bool" should work

[00:44] <b_jonas> and the same with "does not" instead of "but not" with the difference being mutate vs copy

[00:44] <b_jonas> p6 does not define "does not" or "but not" anywhere though

[00:45] <ruoso> @tell pmurias, I've had a great idea... to simplify p6opaque implementation (and metaclass implementation) I've separated the storage of "only methods" from the storage of "multi methods"

[00:45] <lambdabot> Consider it noted.

[00:46] <ruoso> @tell pmurias I've updated http://www.perlfoundation.org/perl6/index.cgi?smop_oo_api ... take a look ...

[00:46] <lambdabot> Consider it noted.

[00:47] *** apeiron joined
[00:50] *** bacek joined
[00:51] *** cognominal_ left
[00:51] *** cognominal_ joined
[00:52] <pugs_svn> r21473 | ruoso++ | [smop] reworking p6opaque.sm0p with the new definitions... as a refactoring on the way, tests are broken again

[00:54] * ruoso later &

[00:55] *** ruoso left
[00:55] *** apeiron_ left
[00:56] *** b_jonas left
[01:02] *** [particle1 left
[01:07] *** wknight8111 left
[01:08] *** nipotaway is now known as nipotan

[01:10] *** meppl left
[01:12] *** meppl joined
[01:16] *** icwiener joined
[01:16] *** timbunce left
[01:52] *** xinming joined
[01:55] *** felipe left
[01:58] *** xinming__ joined
[02:00] *** alester joined
[02:01] * zamanfou is now away: In the rain my tears are forever lost.

[02:04] *** Limbic_Region left
[02:04] *** xinming_ left
[02:04] *** alester left
[02:05] *** xinming__ left
[02:07] *** xinming_ joined
[02:11] *** xinming left
[02:18] *** xinming joined
[02:18] *** xinming_ left
[02:25] *** xinming left
[02:27] *** xinming joined
[02:43] <meppl> good night

[02:46] *** meppl left
[02:49] *** charsbar_ joined
[02:50] *** xinming_ joined
[02:58] *** xinming left
[02:59] *** charsbar left
[02:59] *** [particle1 joined
[03:06] *** Psyche^ joined
[03:11] *** ikeda joined
[03:15] *** justatheory joined
[03:18] *** Patterner left
[03:18] *** Psyche^ is now known as Patterner

[03:22] *** kanru left
[03:24] *** rhr_ joined
[03:34] *** [particle1 left
[03:35] *** xinming joined
[03:37] *** rhr left
[03:40] *** pbuetow_ joined
[03:40] *** justatheory left
[03:41] *** xinming_ left
[03:42] *** rhr_ is now known as rhr

[03:43] *** ikeda_ joined
[03:49] *** felipe joined
[03:53] *** xinming left
[03:54] *** xinming joined
[03:55] *** pbuetow left
[03:59] *** ikeda left
[04:03] *** kanru joined
[04:09] *** justatheory joined
[04:15] *** ikeda_ left
[04:15] *** ikeda joined
[04:18] *** arguile left
[04:19] *** xinming_ joined
[04:21] *** arguile joined
[04:31] *** xinming__ joined
[04:32] *** xinming left
[04:32] *** ikeda_ joined
[04:36] *** ikeda left
[04:37] *** ikeda_ left
[04:45] *** xinming_ left
[04:52] *** c1sung left
[04:58] *** xinming joined
[05:10] *** xinming__ left
[05:11] *** xinming_ joined
[05:12] *** masak joined
[05:18] *** xinming left
[05:19] *** bacek_ joined
[05:21] *** xinming joined
[05:22] *** justatheory left
[05:23] *** icwiener left
[05:25] *** Psyche^ joined
[05:27] *** xinming left
[05:29] *** bacek left
[05:29] *** jfredett joined
[05:31] *** xinming_ left
[05:33] *** jfredett_ left
[05:38] *** Patterner left
[05:38] *** Psyche^ is now known as Patterner

[05:57] *** xinming joined
[06:19] *** c1sung joined
[06:44] *** Alias_ joined
[06:47] *** Alias_ left
[06:47] *** Alias__ joined
[06:53] *** luqui joined
[07:07] *** iblechbot joined
[07:12] *** bacek joined
[07:13] *** bacek__ joined
[07:22] *** pmichaud left
[07:22] *** moritz_ left
[07:22] *** frobnitz left
[07:22] *** apple-gunkies left
[07:22] *** Arathorn left
[07:22] *** breinbaas left
[07:22] *** felipe left
[07:22] *** mofino left
[07:22] *** yath_ left
[07:22] *** meteorjay left
[07:22] *** pl0d left
[07:22] *** gbacon left
[07:22] *** bloonix left
[07:22] *** Juerd left
[07:22] *** lisppaste3 left
[07:22] *** funktio left
[07:22] *** BinGOs left
[07:22] *** josh- is now known as josh

[07:22] *** felipe joined
[07:22] *** mofino joined
[07:22] *** BinGOs joined
[07:22] *** pl0d joined
[07:22] *** lisppaste3 joined
[07:22] *** bloonix joined
[07:22] *** gbacon joined
[07:22] *** meteorjay joined
[07:22] *** Juerd joined
[07:22] *** yath_ joined
[07:22] *** funktio joined
[07:23] *** josh left
[07:23] *** Arathorn joined
[07:23] *** apple-gunkies joined
[07:23] *** frobnitz joined
[07:23] *** breinbaas joined
[07:23] *** pmichaud joined
[07:23] *** moritz_ joined
[07:23] *** josh- joined
[07:29] *** bacek_ left
[07:31] *** bacek left
[07:41] *** timbunce joined
[07:41] *** _timbunce joined
[08:01] *** timbunce left
[08:15] *** _timbunce left
[08:30] *** luqui left
[08:31] *** elmex joined
[08:37] *** xinming left
[08:44] *** xinming joined
[09:17] *** pmurias joined
[09:19] *** jferrero joined
[09:19] *** bacek__ left
[09:27] *** chris2 joined
[09:32] <pmurias> TimToady: why did you reduce the number of {*} hooks in STD.pm? it should be done with wrapping where there is only one?

[09:32] <lambdabot> pmurias: You have 2 new messages. '/msg lambdabot @messages' to read them.

[09:36] <moritz_> do {*} hooks affect LTM?

[09:37] *** donaldh joined
[09:38] <pmurias> likely

[09:45] *** ashizawa joined
[09:49] *** renormalist joined
[09:56] *** jferrero left
[09:56] *** jferrero joined
[10:35] *** pmurias left
[10:36] *** pmurias joined
[10:49] *** iblechbot left
[10:51] *** meppl joined
[10:53] *** agentzh left
[10:56] *** agentzh joined
[11:03] *** ruoso joined
[11:08] <ruoso> pmurias, hi

[11:08] *** nipotan is now known as nipotaway

[11:15] *** pbuetow_ left
[11:15] *** m0py joined
[11:16] <pmurias> ruoso: hi

[11:16] *** pbuetow joined
[11:16] *** Patterner left
[11:16] <ruoso> pmurias, have you seen that I take the multi methods to another member of the proto_storage?

[11:16] <pmurias> ruoso: yes

[11:16] <ruoso> it should make it easier to implement the first objects...

[11:17] <pmurias> but i don't know what to think of it

[11:18] <pmurias> do Scalars redispatch methods they don't understand?

[11:18] <ruoso> pmurias, I think so

[11:19] <ruoso> actually.. not...

[11:19] <ruoso> let me see

[11:19] <ruoso> pugs: class Foo { method bar { 2 } }; my $a = Foo.new(); say VAR($a).bar();

[11:19] <p6eval> pugs: OUTPUT[2␤]

[11:19] <ruoso> pugs does it

[11:20] <ruoso> pugs: class Foo { method bar { 2 } }; my $a = Foo.new(); say VAR($a).FETCH().bar();

[11:20] <p6eval> pugs: OUTPUT[*** No such method in class Foo: "&FETCH"␤    at /tmp/5uDnuk6S3M line 1, column 56-77␤]

[11:20] <ruoso> pugs: class Foo { method bar { 2 } }; my $a = Foo.new(); say VAR($a).WHAT;

[11:20] *** Psyche^ joined
[11:20] <p6eval> pugs: OUTPUT[Foo␤]

[11:20] *** Psyche^ is now known as Patterner

[11:20] <ruoso> hmmm... it actually doesn't implement VAR correctly

[11:23] <ruoso> pugs: my $a = Scalar.new(); class Foo { method bar {2} }; $a.STORE(Foo.new); say $a.bar;

[11:23] <p6eval> pugs: OUTPUT[*** No such method in class Scalar: "&STORE"␤    at /tmp/XixGgLUixC line 1, column 53-70␤]

[11:23] <ruoso> hmpf

[11:23] <ruoso> kp6: class Foo { method bar { 2 } }; my $a = Foo.new(); say VAR($a).bar();

[11:23] <p6eval> kp6 21473: OUTPUT[no method 'bar' in Class 'Scalar'␤]

[11:23] <ruoso> kp6 refuses it

[11:24] <pmurias> maybe $foo is traslated to CurrentLexicalPad<$foo>.FETCH()?

[11:26] <ruoso> $foo?

[11:26] <pmurias> any sort of lexical variable

[11:26] <ruoso> oh.. yeah... that's for sure...

[11:27] <ruoso> $foo actually means lexpad.{'$foo'}.FETCH()

[11:27] *** ashizawa left
[11:27] * ruoso just noticed that was exactly what you've written before ;)

[11:29] <pmurias> ruoso: i wouldn't be so sure of this

[11:29] *** meppl left
[11:29] <pmurias> %hash<hash key>.method()?

[11:30] * ruoso now sees the meaning of your first question...

[11:31] <ruoso> but returning a scalar is the only way to implement 

[11:31] <ruoso> my $a := %hash<hash key>;

[11:32] <ruoso> maybe the . operator is the one that makes the FETCH

[11:33] <ruoso> which actually makes sense

[11:33] <ruoso> as well as the = operator

[11:34] <pmurias> either that or if a method is called on a scalar it calls it on it's value

[11:34] <ruoso> but how do you call FETCH then?

[11:35] <pmurias> FETCH would be special cased

[11:35] <ruoso> hmmm... so you can't have a method FETCH on a value that is stored inside a scalar?

[11:36] <pmurias> hmm or you would have to call VAR($foo).FETCH

[11:38] <ruoso> VAR($foo) returns a scalar with the $foo scalar as the value of this scalar

[11:39] <ruoso> so VAR($foo).FETCH() would be the same as $foo

[11:39] <ruoso> hmmm

[11:39] <ruoso> wait

[11:40] <ruoso> if the '.' operator implies a FETCH

[11:42] <ruoso> VAR($foo) needs a double-box for VAR($foo).FETCH() === $foo

[11:43] <ruoso> so VAR() creates a scalar containing the scalar returned by the lexpad lookup

[11:44] <ruoso> so, in VAR($foo).FETCH(), '.' accesses the scalar returned by the lexpad lookup because of the implied FETCH, and the explicit FETCH is being called on that scalar

[11:45] <ruoso> kp6: my $a = 1; say VAR($a).FETCH() === $a;

[11:45] <p6eval> kp6 21473: OUTPUT[syntax error at position 31, line 1 column 31:␤my $a = 1; say VAR($a).FETCH() === $a␤                               ^ HERE␤]

[11:45] <ruoso> kp6: my $a = 1; say (VAR($a)).FETCH() === $a;

[11:45] <p6eval> kp6 21473: OUTPUT[syntax error at position 33, line 1 column 33:␤my $a = 1; say (VAR($a)).FETCH() === $a␤                                 ^ HERE␤]

[11:45] <ruoso> kp6: my $a = 1; say (VAR($a)).FETCH() == $a;

[11:45] <p6eval> kp6 21473: OUTPUT[1␤]

[11:45] <ruoso> kp6: my $a = 123; say (VAR($a)).FETCH() == $a;

[11:45] <p6eval> kp6 21473: OUTPUT[1␤]

[11:45] *** lumi left
[11:46] <ruoso> pmurias, does it make sense?

[11:46] <pmurias> yes

[11:46] <pmurias> but i has some issues

[11:47] <pmurias> it would hinder language interoperability

[11:47] <pmurias> and force more method call the nessesary

[11:48] <ruoso> yeah... but... any other idea?

[11:50] <pmurias> scalars forwarding method calls to their values and VAR() creating a special object which calls their real methods

[11:51] <pmurias> we could somehow generalize the .^ and .^! syntax

[11:53] <ruoso> that makes me think... how visible to the user is FETCH() and STORE()?

[11:53] <pmurias> the have to use the VAR macro

[11:53] <ruoso> the only reference of FETCH in the specs is in a Proxy object that would behave as the Scalar

[11:54] <ruoso> maybe the effective FETCH could have a protected name...

[11:55] <pmurias> we need multi part identifiers

[11:55] <ruoso> and then we wouldn't have any problem by hiding any value method because it collides with the Scalar methods...

[11:55] <ruoso> 'multi part identifiers'?

[11:56] <pmurias> things like $foo.^foo $foo.^!foo would translate to (haven't thought about the syntax) $foo.HOW::foo $foo.REPR::foo

[11:57] <pmurias> in other words we need namespaces for method name

[11:57] <pmurias> s

[11:58] <ruoso> I'm not so sure... $foo.^bar() is actually going to be rewritten as $foo.HOW.bar($foo)

[11:58] <ruoso> now it's just a syntatic convenience

[11:59] <pmurias> and .^!?

[12:00] <ruoso> and the REPR calls are somewhat specific...

[12:00] <ruoso> it's just a protected name

[12:00] *** pmichaud left
[12:00] *** apple-gunkies left
[12:00] *** Arathorn left
[12:00] *** breinbaas left
[12:00] *** moritz_ left
[12:00] *** frobnitz left
[12:00] <pmurias> .^ is handled on the syntax level?

[12:00] <ruoso> yes...

[12:01] <ruoso> at least it's a reasonable way of doing it, since the actual method doesn't have the ^

[12:02] <pmurias> qualified methods would be also a way for language interoperability, an object could have a different interface from python and from perl

[12:02] *** lumi joined
[12:02] *** Arathorn joined
[12:02] *** apple-gunkies joined
[12:02] *** frobnitz joined
[12:02] *** breinbaas joined
[12:02] *** pmichaud joined
[12:02] *** moritz_ joined
[12:04] <ruoso> pmurias, that's the beauty of representation polymorphism... we can have that feature later... it doesn't need to be a part of the standard p6opaque object

[12:08] <pmurias> ruoso: do you have any usefull metaclass example which aren't done by represenation objects in smop?

[12:09] <ruoso> not really... in fact I think the REPR api is a fundamental feature for you to have usefull interchangeable metaclasses

[12:10] *** lumi left
[12:10] <pmurias> * examples

[12:10] *** lumi joined
[12:11] <pmurias> ruoso: what i meant what sort of (custom) metaclasses can we expect to be built on the REPR api

[12:12] <ruoso> different MRO

[12:12] <ruoso> for instance

[12:12] <ruoso> pure-prototype × prototype by delegation × class-based 

[12:12] *** a-jing joined
[12:12] *** a-jing left
[12:15] <ruoso> pmurias, and also some more exotic metaclasses that fetch the methods elsewhere

[12:15] <ruoso> and store only metainformation on how to do that fetching in the class_storage

[12:18] <ruoso> pmurias, one very usefull one would be a P5Dispatch metaclass... that uses .^!who to determine the name of the p5 package where to dispatch the methods

[12:24] <pmurias> isn't that the job of a REPR?

[12:25] <ruoso> may be or may be not

[12:25] <ruoso> it depends on what you want to acomplish

[12:25] <ruoso> for instance... 

[12:25] <ruoso> if we manage to integrate smop with p5 the way I plan to do

[12:26] <ruoso> we may have a smop object being used as is from inside p5

[12:26] <ruoso> and then you might want to have a protoobject for a p5 module

[12:27] <pugs_svn> r21474 | fglock++ | [v6.pm] version 0.25; marked cpan-tester failures as TODO (though I can't reproduce the problem)

[12:29] *** iblechbot joined
[12:29] *** Psyche^ joined
[12:30] <ruoso> pmurias, of course that to access a p5 object, you need a different repr

[12:30] *** Patterner left
[12:30] *** Psyche^ is now known as Patterner

[12:32] <ruoso> pmurias, but one important feature of Perl 6 is that a subclass doesn't need to be of the same repr of a superclass... or even have the same metaclass

[12:32] <ruoso> as well as an instance might have a different representation of its protoobject

[12:36] <pugs_svn> r21475 | ruoso++ | [smop] bringing back some features that were already implemented in the old p6opaque.

[12:36] <pugs_svn> r21476 | fglock++ | [v6.pm] Changelog update

[12:37] * ruoso wonders what keeps fglock away from IRC...

[12:38] *** josh- is now known as josh

[12:47] *** jan__ left
[12:52] <pugs_svn> r21477 | ruoso++ | [smop] bringing back test/12... still failing...

[12:52] <pmurias> ruoso: it would be good to have a perl6 version of the sm0p fragments on top

[12:53] <ruoso> yes, it would...

[12:55] <pmurias> re IRC, don't you get distracted by IRC from coding?

[12:56] * pmurias gets very distracted

[12:56] <ruoso> not really... 

[12:57] *** Jedai joined
[12:58] <ruoso> usually when I have to code something else I neglect IRC...

[12:58] <ruoso> and only take a look from now and then...

[13:04] <pugs_svn> r21478 | ruoso++ | [smop] some more advances in test/12 it now is just warning the non-implemented methods.

[13:09] *** jferrero left
[13:10] *** cmarcelo joined
[13:12] <pmurias> maybe fglock works in a non-irc place now

[13:12] <pmurias> * no-irc

[13:20] <pmurias> shouldn't non-implemented methods kill smop instead of printing a warning message

[13:21] <ruoso> pmurias, I'm not sure at this level... we still don't have an exception mechanism implementd

[13:23] <pmurias> we could have a placeholder SMOP_THROW()

[13:23] <pmurias> or better SMOP_FAIL?

[13:23] <moritz_> pmurias: fail() in perl 6 doesn't throw an exception by default

[13:24] <pmurias> SMOP_DIE

[13:25] <pmurias> at least sliently returnig false on unkown methods should be eliminated

[13:26] <ruoso> pmurias, I'm trying to add the warning for now

[13:26] <ruoso> for p6opaque the failure will be handled by the metaclass

[13:26] <ruoso> that should return a failure  if the method is not found

[13:28] <pugs_svn> r21479 | ruoso++ | [smop] delegation in p6opaque works again... there is a leak of the how scalar somewhere

[13:31] <pugs_svn> r21480 | pmurias++ | [smop] tiny progess on Array

[13:31] <pmurias> library and cycling&

[13:33] <ruoso> pmurias, you forgot to add test/19

[13:51] *** cognominal__ joined
[13:51] <pugs_svn> r21481 | ruoso++ | [smop] YAY! test/12 passes again, delegation to the metaclass works again

[13:58] <pugs_svn> r21482 | pmurias++ | [smop] forgot to add test 19

[13:59] <pmurias> i'm using {0} instead of [0] as s1p needs to be fixed

[13:59] <pmurias> got to go will fix on a fresher brain&

[13:59] <ruoso> alright...

[13:59] *** pmurias left
[13:59] *** cognominal_ left
[14:01] *** kanru left
[14:06] *** iblechbot left
[14:06] *** timbunce joined
[14:09] *** jan_ joined
[14:09] <ruoso> @tell pmurias I can't compile test/19... I'm removing it from the compilation for now

[14:09] <lambdabot> Consider it noted.

[14:13] <ruoso> @tell pmurias I can't compile any sm0p block... 

[14:13] <lambdabot> Consider it noted.

[14:15] *** cognominal_ joined
[14:16] *** pbuetow left
[14:16] *** TJCRI joined
[14:16] *** pbuetow joined
[14:19] <ruoso> @tell pmurias Can't call method "item" on an undefined value at ../sm0p/sm0p_with_actions line 58. 

[14:19] <lambdabot> Consider it noted.

[14:20] *** cognominal_ left
[14:23] *** cognominal__ left
[14:27] * ruoso have to wait for the sm0p fix

[14:27] *** kanru joined
[14:28] <pugs_svn> r21483 | ruoso++ | [smop] moving test/14 back. It was still failing with a segfault, but I could not debug further because of the sm0p bug that is not compiling anything.

[14:32] *** cognominal_ joined
[14:42] *** orafu left
[14:57] *** meppl joined
[15:09] *** renormalist left
[15:19] *** timbunce left
[15:25] *** masak left
[15:25] *** masak joined
[15:46] *** Lorn joined
[15:51] <pugs_svn> r21484 | lwall++ | [STD] various bugs

[15:51] <pugs_svn> r21484 | lwall++ | [t/spec] various bugs

[15:51] <pugs_svn> r21484 | lwall++ | Now parses 95% (cheating on postfix:<!>)

[15:52] <moritz_> TimToady++

[15:52] * moritz_ is thorougly impressed

[15:52] *** timbunce joined
[15:52] <moritz_> of course we shouldn't forget that tricky stuff like hyper ops isn't jet migrated to spec/

[15:56] *** pbuetow left
[15:56] *** pbuetow joined
[15:57] *** Exodist joined
[15:58] *** justatheory joined
[15:59] <pugs_svn> r21485 | moritz++ | test target for STD.pm Makefile

[16:02] *** timbunce left
[16:03] *** timbunce joined
[16:12] *** pmurias joined
[16:12] <pmurias> ruoso: looking into it

[16:12] <lambdabot> pmurias: You have 3 new messages. '/msg lambdabot @messages' to read them.

[16:13] <pmurias> ruoso: you maybe be a victim of lex/ poisioning

[16:13] <pmurias> remove lex/* test/lex/*

[16:18] <pugs_svn> r21486 | lwall++ | require STD.pm to parse as first test

[16:22] *** iblechbot joined
[16:28] <pugs_svn> r21487 | moritz++ | [STD.pm] Makefile: test depends on all

[16:29] <pugs_svn> r21488 | moritz++ | [spec] S04-statements/for.t it's neither '=~' nor '~~', it's '~='

[16:31] <pmurias> ruoso: has removing lex fixed your problem

[16:31] <pmurias> ?

[16:32] <TimToady> heh, I wonder if I can get the parser to figure out which mistake they made...

[16:33] <moritz_> ;-)

[16:33] <pmurias> TimToady: should i add a lex/ less option?

[16:33] <moritz_> btw what's wrong with ".$*PID" ?

[16:35] *** donaldh left
[16:36] <TimToady> $*PID."method"

[16:36] <pugs_svn> r21489 | lwall++ | [STD] parse as types

[16:36] <pugs_svn> r21489 | lwall++ | [type.t] of and as must come after signature

[16:37] <TimToady> in theory, should backtrack on failure to find brackets, but currently just fails

[16:37] <justatheory> TimToady: Sounds painful.

[16:45] *** hercynium joined
[16:45] <TimToady> it should probably figure out that a method name containing a newline is unlikely :)

[16:48] *** chris2 left
[16:55] <pmurias> how can i check if something is a typeglob in p5 as not only those seem to live in the symbol table?

[16:59] <pmurias> =~ /^\*/ proved to be enough

[17:09] *** cjfields joined
[17:14] <ruoso> pmurias, yes...removing lex fixed it (as it looks)

[17:14] *** alester joined
[17:17] *** justatheory left
[17:18] *** alester left
[17:19] <pugs_svn> r21490 | ruoso++ | [smop] re-adding test/19 which now compiles (but still fails)

[17:20] <ruoso> TimToady, if you have some time, please take a look on the Scalar × Value discussion we had earlier...

[17:20] *** timbunce left
[17:21] *** timbunce joined
[17:24] <ruoso> pmurias, I think we should start checking if the invocant has the correct RI before executing anything...

[17:24] <ruoso> pmurias, most of the time a segfault arises that is the cause

[17:26] <pmurias> hm

[17:26] <pmurias> we need to check if the capture is a native one too

[17:27] <ruoso> yes... that too...

[17:27] <pmurias> and convert a string identifier into a constant one

[17:27] <ruoso> that too ;)

[17:27] *** timbunce left
[17:28] <ruoso> but the later is not that important because it won't generate a segfault...

[17:28] <ruoso> we can explicitly say we don't support non-constant identifiers for now

[17:28] <pmurias> silent failures are worse than segfaults

[17:29] <ruoso> we should add also the warning about "unknown methods"

[17:30] <ruoso> some of the objects have it alreaddy

[17:31] <pmurias> we can either add it with a custom preprocessor or the c preprocessor

[17:31] <ruoso> we could have a C macro that does this checking

[17:31] <ruoso> something like

[17:32] <ruoso> ___NATIVE_CAPTURE_ONLY___("p6opaque");

[17:32] <ruoso> ___CORRECT_INVOCANT___(SMOP__p6opaque__RI, "p6opaque");

[17:33] <ruoso> and even...

[17:33] <ruoso> ___CONST_IDENTIFIER_ONLY___("p6opaque")

[17:36] <pmurias> isn't it possible to get the correct name from the responder

[17:37] *** alester joined
[17:37] <ruoso> pmurias, in fact... it is

[17:37] * ruoso writing the macros

[17:38] <ruoso> I think I'll make it as an assert

[17:38] <ruoso> it will make a failure exit

[17:40] *** timbunce joined
[17:40] <pmurias> ruoso: what do you use for debugging segfaults?

[17:41] <ruoso> pmurias, to check the invocant I need to extract it from the capture... would it be ok for the macro to declare SMOP__Object* invocant;?

[17:41] <ruoso> pmurias, valgrind

[17:44] <pmurias> ruoso: you could add a new block and make it a lexical

[17:44] <ruoso> pmurias, but usually the invocant will be used later...

[17:45] <ruoso> so making the macro define it would avoid a second call to capture_invocant

[17:45] <pmurias> ok

[17:46] <pugs_svn> r21491 | ruoso++ | [smop] three macros that can be used to do some sanity checks that can save us from segfaults

[17:47] *** meppl left
[17:51] <pugs_svn> r21492 | ruoso++ | [smop] uses the macros in p6opaque_proto_storage

[17:57] <pmurias> ruoso: i used to catch segfaults with something like valgrind --db-attach=yes --db-command="cgdb %f %p" '

[17:57] *** cognominal__ joined
[17:57] <ruoso> pmurias, usually valgrind already gives me the output I need

[17:57] <ruoso> pmurias, have you seen the SMOP Debugging wiki page?

[17:58] <pmurias> yes

[18:00] <pmurias> cgdb is IMHO nicer than gdb

[18:01] <pmurias> ruoso: shouldn't the -q option be on the valgrind command on that page?

[18:02] <ruoso> -q?

[18:02] <ruoso> if you like to add it...

[18:02] <ruoso> I usually like the valgrind report

[18:03] <pmurias> i don't like the valgrind header

[18:04] *** Jedai left
[18:05] <pugs_svn> r21493 | ruoso++ | [smop] p6opaque_proto_storage completed! It delegates everything to hashes, arrays and scalars

[18:09] *** meppl joined
[18:11] *** cognominal_ left
[18:16] <pugs_svn> r21494 | pmurias++ | [STD] a script to show changed globals after an STD use

[18:23] *** justatheory joined
[18:23] *** Alias__ left
[18:29] <pugs_svn> r21495 | ruoso++ | [smop] p6opaque has the accessors for all its members...

[18:29] <pugs_svn> r21496 | moritz++ | [t] removed redundant test file general/basic.t

[18:32] *** alester left
[18:32] *** justatheory left
[18:33] <moritz_> t/oo/can.t looks so wrong to me

[18:34] <pugs_svn> r21497 | ruoso++ | [smop] p6opaque p6 protocode with "is rw" for all the members

[18:35] <pmurias> ruoso: should i add __UNKNOWN__METHOD__?

[18:35] <ruoso> pmurias, yes... that's a good one too...

[18:37] *** justatheory joined
[18:37] <pmurias> should i die too?

[18:37] <ruoso> I think so...

[18:38] <ruoso> the assert interrupts the program too

[18:38] <ruoso> you can even make an assert("message") that will always die

[18:38] *** timbunce left
[18:38] <ruoso> and it even shows the message

[18:39] <pmurias> assert is supposed to be used for debugging only

[18:39] <ruoso> is it?

[18:39] <moritz_> yes

[18:39] <pugs_svn> r21498 | moritz++ | [spec] unfudged two tests for rakudo in for.t

[18:39] <moritz_> with the appropriate compiler options it's optimized away

[18:41] <ruoso> hmm... maybe it's a good thing

[18:41] <ruoso> because as the lowlevel consolidates, that checkings could be optimized away...

[18:42] <pmurias> it's in NDEBUG

[18:42] <pugs_svn> r21499 | moritz++ | [INSTALL] link to instructions on building pugs on cygwin, rurban++

[18:42] <pmurias> if NDEBUG in set the get deleted

[18:43] <ruoso> pmurias, how is the support for the q:s1p (or however it's called) inside C files?

[18:43] <pmurias> it's use v6

[18:43] <ruoso> use v6; and then it ends with the block? 

[18:43] <pmurias> yes

[18:43] *** justatheory left
[18:43] <pmurias> it uses indentation

[18:44] <ruoso> does it include any boilerplate? like the goto, setr and stuff

[18:44] <pmurias> not yet

[18:44] <pmurias> didn't know what to add

[18:44] <ruoso> I think a plain CPS with setr should be ok

[18:44] <ruoso> like the ones in p6opaque.sm0p...

[18:45] <ruoso> actually... like the one in p6opaque DISPATCH

[18:45] *** justatheory joined
[18:45] <ruoso> pmurias, p6opaque_message_DISPATCH in p6opaque.sm0p is a good example

[18:45] <pmurias> is it ok to use __func__?

[18:46] *** timbunce joined
[18:46] <ruoso> where? what for?

[18:46] <pmurias> error messages

[18:46] <pmurias> it is c99 and a gnu extension

[18:46] <ruoso> that's fine by m

[18:46] <ruoso> e

[18:47] *** iblechbot left
[18:48] <pugs_svn> r21500 | moritz++ | [spec] moved oo/inheritance.t to spec/, and updated it a bit

[18:48] * ruoso can't stand sm0p blocks any more... 

[18:48] <moritz_> that's intentional, right? ;-)

[18:49] <ruoso> pmurias, how hard would it be for you to add inline "use v6;" support for the boilerplate in p6opaque_message_DISPATCH?

[18:49] <ruoso> so I can rewrite test/14 with v6 instead of sm0p

[18:50] <pugs_svn> r21501 | lwall++ | [STD] improve parsing of reduceops

[18:50] <pugs_svn> r21501 | lwall++ | [Cursor] correct character class parse in canmatch

[18:50] <pugs_svn> r21501 | lwall++ | [reduce-metaop] no such thing as [.{}]

[18:52] <pmurias> ruoso: not very hard i think

[18:54] <pmurias> ruoso: is it constant?

[18:54] <ruoso> the boilerplate?

[18:54] <pmurias> yes

[18:54] <ruoso> I'd say so

[18:55] <ruoso> I mean... that's not the only possible pattern... but it's a valid one

[18:56] <pmurias> i could either add it to s1p or add a __SM0P__("inline code")?

[18:57] <ruoso> moritz_, I wish I could stand it a little more, because if we make this preprocessor too good, the pressure for real p6 will be smaller

[18:57] <ruoso> pmurias, I think you ca nadd it to s1p

[18:58] <pmurias> we don't always have a $continuation in the enclosing c code

[18:59] *** justatheory left
[18:59] <ruoso> if we don't, the interpreter have something for which you are going to send it back

[18:59] <ruoso> the pattern is, interrupt the current execution, execute something, set the value into the old continuation and get back to it

[19:00] <ruoso> the interpreter always have something...

[19:00] <ruoso> pmurias, btw... the last 5 sm0p statements are part of the boilerplate

[19:01] <ruoso> and they should fetch the result from the last executed statement

[19:01] <ruoso> (which means 1 statement before the boilerplate starts)

[19:02] <pmurias> should it be return $expr in p6?

[19:02] <ruoso> hmm...

[19:02] <ruoso> having explicit return instead of implict might be usefull, because with no explicit return, you would be a plain CPS with no return value...

[19:02] <ruoso> pmurias++

[19:03] <ruoso> that's a better approach

[19:03] <ruoso> turn the "return $expr" call into the setr thing

[19:03] <ruoso> then the boilerplate is simply the last two statements

[19:04] <pmurias> moritz_: the sm0p's design goal is to represent the nodes it's constructing accuratly not to be a programming language

[19:06] <pugs_svn> r21502 | moritz++ | [spec] S12-class/inheritance.t: fudged for rakudo

[19:06] <pugs_svn> r21502 | moritz++ | also removed newlines in order not to confuse fudge

[19:16] * ruoso wonders if he should wait for the "use v6" trick to work on test/14 or if he should handle sm0p blocks one more time...

[19:16] <pmurias> wait please

[19:17] <rakudo_svn> r29727 | moritz++ | [rakudo] add S12-class/ineheritance.t to spectest_regression

[19:17] <rakudo_svn> r29727 | moritz++ |  +10 pass, +7 todo, +15 skip - still much work for jonathan ;-)

[19:17] * pmurias dosn't want to read any more sm0p blocks

[19:17] <cjfields> moritz++

[19:18] <moritz_> cjfields: for anything particular, or just for being me? ;-)

[19:18] <cjfields> for the test commits, of course

[19:18] <moritz_> well, one never knows ;-)

[19:19] <cjfields> does jonathan have a rakudo day this week?

[19:19] <moritz_> friday (aka tomorrow)

[19:20] <moritz_> but I have no idea what he'll be working on

[19:20] <ruoso> sm0p was usefull but I think I underestimated the limits of our patience...

[19:20] <ruoso> s/under/over/

[19:21] <pugs_svn> r21503 | lwall++ | [STD] infrastructure for grammar-modifying operator definitions

[19:22] *** m0py left
[19:24] <pugs_svn> r21504 | pmurias++ | [s1p] return support

[19:25] <pmurias> now, how to test it

[19:26] <ruoso> test/14

[19:26] <ruoso> we have to replace the two sm0p blocks

[19:27] <pmurias> put the perl6 in a comment i'll try to make it work

[19:28] <ruoso> alriht

[19:29] *** timbunce left
[19:30] <pugs_svn> r21505 | moritz++ | [spec] moved oo/roles/basic.t to spec/, heavily reworked and many eval()s

[19:30] <pugs_svn> r21505 | moritz++ | removed

[19:30] <pugs_svn> r21506 | ruoso++ | [smop] fix the order in fprintf for ___UNKNOWN_METHOD___

[19:31] <pugs_svn> r21507 | moritz++ | [spec] S12-role/basic.t: fixed POD

[19:31] <ruoso> pmurias, does "use v6" support variables?

[19:32] <pmurias> c variables

[19:32] <pmurias> $*global.STORE(123) should work

[19:32] <ruoso> $*global being in the global namespace

[19:33] <ruoso> but if I need the return of an expression as the argument of another, I need to do it inline, right?

[19:33] *** timbunce joined
[19:34] <pmurias> yes

[19:34] <pmurias> we don't have lexical pads yet

[19:36] <pugs_svn> r21508 | moritz++ | [spec] S12-role/basic.t: use defined() to test for objects of empty classes

[19:38] <pmurias> ruoso: the problem with declaring invocant in INVOCANT_RI_SHOULD_MATCH is that usually i want a more specific type than SMOP__Object* (if i know it)

[19:38] <pugs_svn> r21509 | ruoso++ | [smop] add v6 blocks for pmurias++ to make it work :) 

[19:38] <ruoso> pmurias, then you can cast it without doing an additional call to the capture

[19:39] <pugs_svn> r21510 | moritz++ | [spec] moved var/is_copy.t to spec/

[19:41] *** timbunce left
[19:41] <ruoso> pmurias, are the blocks sane?

[19:42] <pugs_svn> r21511 | moritz++ | [spec] moved var/is_rw.t to spec/

[19:46] <pugs_svn> r21512 | moritz++ | [spec] S06-traits/is-rw.t: added smartlink, fudged for rakudo

[19:47] <pmurias> ruoso: looking

[19:48] <pugs_svn> r21513 | ruoso++ | [smop] making it compile (use v6 is commented out)

[19:54] * pmurias gives on extending STD_red and hacks around

[19:57] <rakudo_svn> r29728 | moritz++ | [rakudo] two more S06 tests for spectest_regression

[19:57] <rakudo_svn> r29728 | moritz++ |  +6 pass, +3 skip

[20:06] *** cjfields left
[20:17] *** pmurias left
[20:18] *** pmurias joined
[20:18] <pmurias> ruoso: test 14 is supposed to fail?

[20:18] <ruoso> pmurias, depends on the failure

[20:18] <ruoso> (it actually depends how much of hash is implemented already)

[20:19] <ruoso> pmurias, you can commit it even broken...

[20:19] <ruoso> so I can help fixing ;)

[20:19] <pmurias> ok

[20:20] <pugs_svn> r21514 | pmurias++ | .^! added to elfX and STD_red

[20:21] <pmurias> we could have a hackathon at yapc europe ;)

[20:21] * ruoso not going :(

[20:21] <pmurias> :(

[20:21] * ruoso can take part of the hackathon remotely

[20:21] <ruoso> ;)

[20:23] <pmurias> ruoso: so your talk will be canceled?

[20:23] <ruoso> unless someone is willing to pay for my travel tickets... 

[20:24] <ruoso> pmurias, does it compile for you?

[20:24] *** iblechbot joined
[20:24] <pmurias> ruoso: no

[20:25] <pmurias> a continuation is needed

[20:25] <ruoso> oh.. ok...

[20:25] <ruoso> I'll add the boilerplate around it then

[20:26] <pmurias> it could be added to sm0p.pl if it's constant

[20:27] <ruoso> pmurias, maybe it's ok to make it outside...

[20:27] <pmurias> speaking of boilerplate, i added a perl example to the wikipedia boilerplate page

[20:27] <ruoso> which is the perl boilerplate?

[20:27] <pmurias> #!/usr/bin/perl

[20:27] <pmurias> use strict;

[20:27] <pmurias> use warnings;

[20:28] <ruoso> ah.. :)

[20:28] *** REPLeffect left
[20:29] <pugs_svn> r21515 | ruoso++ | [smop] add the continuation boilerplate in test/14;

[20:29] <ruoso> now we have a bad invocant somewhere

[20:32] <pugs_svn> r21516 | ruoso++ | [smop] add a help message in p6opaque

[20:32] *** Alias_ joined
[20:32] <ruoso> pmurias, .^!how is being invoked with the responder interface as the invocant

[20:33] *** sri_work joined
[20:33] *** timbunce joined
[20:33] <pmurias> ruoso: i get a FETCH is not implemented in bool error at the top

[20:34] <ruoso> isn't that just after [smop p6opaque] REPR method called with p6opaque RI (^!how)

[20:34] <ruoso> because the .^!how method is failing...

[20:36] <pugs_svn> r21517 | ruoso++ | [smop] added a "abort()" call to make the error more explicit

[20:36] <ruoso> pmurias, what I don't get is what is the difference between the .^!methods call and the .^!how call

[20:36] <ruoso> in the "use v6" block

[20:39] <ruoso> oh...

[20:39] <ruoso> the error is deeper inside

[20:41] *** donaldh joined
[20:41] <pmurias> if it's not in s1p i'll just &

[20:50] *** REPLeffect joined
[20:57] <ruoso> pmurias, .^!CREATE is taking the '.' as part of the identifier

[20:57] <ruoso> it should only be '^!CREATE', not '.^!CREATE'

[20:57] *** jferrero joined
[20:59] <pmurias> ruoso: fixing

[21:01] <pugs_svn> r21518 | ruoso++ | [smop] some fixes in p6opaque

[21:02] *** Alias_ left
[21:05] *** icwiener joined
[21:05] *** wknight8111 joined
[21:06] <pmurias> fixed

[21:06] <pugs_svn> r21519 | pmurias++ | [s1p] fixed .^!

[21:10] <pmurias> ruoso: anything else you think is a s1p problem?

[21:10] <ruoso> pmurias, I don't think so...

[21:10] <ruoso> I'm actually very near of having test/14 passing

[21:11] <ruoso> pmurias, do you have the forget call in the boilerplate?

[21:13] <pmurias> yes

[21:14] <pmurias> if you uncomment a line in sm0p.pl you can see the sm0p code

[21:14] *** nothingmuch left
[21:14] <pugs_svn> r21520 | ruoso++ | [smop] test/14 almost passing... for some reason the frame is being destroyed too late...

[21:15] <ruoso> the last thing to figure out now is why 'ok 7' is being printed before it should...

[21:16] <ruoso> pmurias, I have to go... 

[21:16] <pmurias>  np, i should be going to sleep ASAP ;)

[21:17] * ruoso eating crabs &

[21:17] *** ruoso left
[21:18] <pugs_svn> r21521 | lwall++ | remove accidental non-breakable spaces

[21:19] *** pmurias left
[21:19] *** nothingmuch joined
[21:23] *** TJCRI left
[21:29] *** justatheory joined
[21:35] *** timbunce left
[21:36] *** iblechbot left
[21:39] *** justatheory left
[21:42] *** cjfields joined
[21:43] *** justatheory joined
[21:51] *** timbunce joined
[22:00] <pugs_svn> r21522 | moritz++ | updated SLAVES

[22:04] *** bacek joined
[22:07] *** Limbic_Region joined
[22:07] *** cjfields left
[22:10] *** masak left
[22:12] *** cmarcelo left
[22:14] *** cmarcelo joined
[22:15] *** Alias_ joined
[22:21] *** _timbunce joined
[22:23] *** _timbunce left
[22:24] *** _timbunce joined
[22:26] *** justatheory left
[22:29] *** timbunce left
[22:34] *** Alias__ joined
[22:34] *** Alias_ left
[22:40] *** donaldh left
[22:47] *** _timbunce left
[22:48] *** _timbunce joined
[22:52] *** bacek left
[22:56] *** icwiener_ joined
[22:58] *** meppl left
[23:01] *** meppl joined
[23:10] *** icwiener left
[23:12] *** _timbunce left
[23:12] *** Exodist left
[23:25] *** justatheory joined
[23:36] *** justatheory left
[23:36] *** cmarcelo left
[23:36] *** bacek joined
[23:40] *** alester joined
[23:41] *** timbunce joined
[23:59] *** justatheory joined
