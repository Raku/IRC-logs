[00:05] *** iblechbot left
[00:19] *** vixey left
[00:20] <cspencer> pugs: .say for (1^..^10 :by(2))

[00:20] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ":by"␤    expecting operator or ")"␤    at /tmp/Lv2bhPsOjt line 1, column 19␤»

[00:20] <cspencer> pugs: .say for (1^..^10:by(2))

[00:20] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ":by"␤    expecting "_", fraction, exponent, term postfix, operator or ")"␤    at /tmp/7BYxTJBpCD line 1, column 18␤»

[00:21] <cspencer> pugs: .say for (1..10 :by(2))

[00:21] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ":by"␤    expecting operator or ")"␤    at /tmp/7tZQyyP09Z line 1, column 17␤»

[00:22] <cspencer> pugs: say 1..10:by(2)

[00:22] <p6eval> pugs: OUTPUT«*** Named argument found where no matched parameter expected: (by,Ann (Pos (MkPos "/tmp/7E9TTPfhlF" 1 14 1 15)) (Val (VInt 2)))␤    at /tmp/7E9TTPfhlF line 1, column 1 - line 2, column 1␤»

[01:18] *** cspencer left
[01:19] *** alc joined
[01:26] *** alanhaggai joined
[01:32] *** dukeleto joined
[01:43] *** dukeleto_ joined
[01:43] *** dukeleto left
[01:48] *** nacho_ left
[01:50] *** xinming left
[02:00] *** dmpk2k joined
[02:12] *** xinming joined
[02:14] *** dukeleto joined
[02:22] *** dukeleto_ left
[02:45] *** alanhaggai_ joined
[02:52] *** DemoFreak left
[02:54] *** PZt joined
[02:54] <pugs_svn> r24671 | tjp++ | Fixed typos/grammar in S02-S06.

[02:57] *** alanhaggai left
[02:59] *** alanhaggai_ is now known as alanhaggai

[03:05] *** jhorwitz_ left
[03:08] *** eternaleye_ left
[03:12] *** eternaleye_ joined
[03:13] *** zostay joined
[03:28] *** cspencer joined
[03:30] *** dukeleto left
[03:31] *** dukeleto joined
[03:33] *** meppuru joined
[03:35] *** meppl left
[03:35] *** cspencer left
[03:40] *** meppuru is now known as meppl

[03:42] *** dukeleto_ joined
[03:53] *** dukeleto left
[04:00] *** kisu joined
[04:01] *** elmex_ joined
[04:17] *** kisu_ left
[04:17] *** elmex left
[04:17] *** elmex_ is now known as elmex

[04:21] <meppl> good night

[04:23] *** meppl left
[05:13] *** dukeleto joined
[05:24] *** dukeleto_ left
[05:25] *** alc left
[05:33] *** alc joined
[05:44] *** alanhaggai left
[05:45] *** cspencer joined
[05:46] *** alester joined
[05:59] *** tuxdna joined
[06:35] *** cspencer left
[06:40] *** araujo left
[06:40] *** brunoV left
[06:45] *** justatheory joined
[06:56] <pugs_svn> r24672 | pmichaud++ | [t/spec]:  Remove some duplicate my declarations in hash.t .

[07:15] *** maerzhase joined
[07:23] *** maerzhase left
[07:26] *** azawawi joined
[07:26] <azawawi> hi

[07:27] *** alester left
[08:04] <pugs_svn> r24673 | azawawi++ | [Syntax::Highlight::Perl6] Added a test case for the re-use of STD bug

[08:07] <pugs_svn> r24674 | azawawi++ | [Syntax::Highlight::Perl6] reverted to a working STD.pm release

[08:07] <pugs_svn> r24674 | azawawi++ | [Syntax::Highlight::Perl6] Fixed the $DELIM warning bug caused by gimme5

[08:07] <pugs_svn> r24674 | azawawi++ | [Syntax::Highlight::Perl6] reverted BUGS and SYNPOSIS and tests to use STD in main::

[08:07] <pugs_svn> r24674 | azawawi++ | [Syntax::Highlight::Perl6] Updated Changes... Releasing to 0.0926 to CPAN

[08:07] *** vixey joined
[08:10] *** iblechbot joined
[08:10] <pugs_svn> r24675 | azawawi++ | [Syntax::Highlight::Perl6] Added back the use STD in main::

[08:13] *** meppl joined
[08:30] *** dukeleto_ joined
[08:39] *** dukeleto left
[08:45] *** Hell_Kaiser joined
[09:24] <pugs_svn> r24676 | azawawi++ | [Syntax::Highlight::Perl6] Bumped version to 0.02961

[09:24] <pugs_svn> r24676 | azawawi++ | [Syntax::Highlight::Perl6] Skipped t/02-hilitep6.t on win32 since it hanged

[09:24] <pugs_svn> r24676 | azawawi++ | [Syntax::Highlight::Perl6] added bar.pl and Foo.pm to MANIFEST.SKIP

[09:24] <pugs_svn> r24676 | azawawi++ | [Syntax::Highlight::Perl6] Updated changes and released to CPAN

[09:36] *** tomyan joined
[09:38] *** alc left
[09:41] *** c9s_ is now known as c9s

[09:54] *** DemoFreak joined
[10:16] *** ejs joined
[10:29] *** dukeleto_ left
[10:32] *** masak joined
[10:33] *** azawawi_ joined
[10:41] <moritz_> masak: pong

[10:41] *** kisu left
[10:41] <masak> moritz_: you mentioned the need for restructuring of S29. I'm about to do a lot of editing of S29 now. could you elaborate on what needs to be restructured?

[10:41] *** ejs1 joined
[10:42] *** kisu joined
[10:43] <moritz_> masak: I was mainly referring to the fact that most builtins work with an invocant of Any right now, even though S29 says they only work on Str, List or $other_type

[10:43] <masak> moritz_: aye, that's true.

[10:43] <masak> so it's mainly the signatures that need to be reviewed?

[10:44] <masak> print and say are two good examples. it says in S16 that they work on Str.

[10:44] <moritz_> masak: yes, and we need a sentence explaining why its done....

[10:44] <masak> but I have the impression that they work on most anything.

[10:45] <moritz_> masak: and for example for Any.reverse we need clarification if it's the list or the string reverse

[10:45] *** azawawi left
[10:46] *** azawawi joined
[10:46] <moritz_> well, say and print coerce to Str, they don't just work on Strs

[10:46] <masak> moritz_: it feels a bit of a shame however. even though those parameter types are too strict, they do convey relevant information.

[10:46] <masak> moritz_: yes, they coerce. and that goes for most other general functions.

[10:47] <moritz_> masak: then you can write things like sub say(*@args as Str) to be clear

[10:47] <masak> moritz_: that's a good idea.

[10:48] <masak> I'll need to do that all over S29, but at least it doesn't delete extant information.

[10:50] <moritz_> masak++ # spec grunt work

[10:50] <masak> well, I consider S29 one of the most important resources to newcomers.

[10:51] <masak> it's also one of the few places where I feel I can make a difference.

[10:51] <moritz_> aye

[10:52] <masak> moritz_: btw, Druid detects winners now. and it's on its way to be able to handle arbritary board sizes.

[10:52] <moritz_> that's also the motivation for my spectest work - I feel I can make a much bigger difference there than if I tried to work my way into the parrot internals

[10:52] <masak> moritz_: aye, same here.

[10:52] *** ejs left
[10:53] <moritz_> re Druid, cool!

[10:53] <masak> I'm pondering whether to make a blog post about how generality can destroy the beauty in simplicity. http://github.com/masak/druid/commit/18ebc4b3378049ad86c7c52253e7caa2e31c2544

[10:53] <masak> if nothing else, to get responses from the good Perl programmers on how to improve that code :)

[10:54] <wolverian> the haskeller in me wants to ask why use strings where you could use your own type to model the domain better :)

[10:54] <masak> (oops, that NB comment is a fossil. removing)

[10:54] <masak> wolverian: see? immediately someone springs forward! :)

[10:55] <masak> wolverian: please elaborate.

[10:55] *** azawawi_ left
[10:56] *** justatheory left
[10:56] <wolverian> hm, nevermind. I thought you were doing strange string magic elsewhere in the app, but you're just using a 2D array there, which makes sense.

[10:56] *** ruoso left
[10:58] <wolverian> hm, would [~] be nicer than join ''?

[10:59] <masak> wolverian: it would. changing.

[10:59] <masak> wolverian++

[11:00] <wolverian> though I wonder what the default array stringification is 

[11:00] <masak> rakudo: say [~] 1..5

[11:00] <moritz_> with spaces inbetween

[11:00] <p6eval> rakudo 34563: OUTPUT«12345␤»

[11:00] <masak> O RLY?

[11:01] <wolverian> pugs and rakudo differ.

[11:01] <moritz_> rakudo: say ~<1 2 3>

[11:01] <p6eval> rakudo 34563: OUTPUT«1 2 3␤»

[11:01] <wolverian> er, no they don't.

[11:01] <wolverian> 1~2~3~4~5 != ~[1..5] :)

[11:01] * wolverian is slow 

[11:01] <wolverian> okay, time to sleep.

[11:01] <masak> wolverian: g'night.

[11:01] *** alech joined
[11:20] *** alech left
[11:45] <avar> rakudo: [~] 1 .. 5

[11:45] <p6eval> rakudo 34566: RESULT«"12345"»

[11:45] <avar> rakudo: [~] 1 .. 5 eq 1~2~3~4~5

[11:45] <p6eval> rakudo 34566: RESULT«Bool::False»

[11:45] <avar> rakudo: 1~2~3~4~5

[11:45] <p6eval> rakudo 34566: RESULT«"12345"»

[11:46] <avar> rakudo: ([~] 1 .. 5) eq (1~2~3~4~5)

[11:46] <p6eval> rakudo 34566: RESULT«Bool::True»

[11:50] *** ruoso joined
[11:50] *** apeiron left
[11:52] <ruoso> Hello!

[11:58] <Matt-W> Hello

[11:59] *** araujo joined
[12:00] *** ihrd joined
[12:03] <ihrd> hi there

[12:04] *** pmurias joined
[12:04] <pmurias> hi

[12:04] <ihrd> rakudo: sub foo (%h?) { { a => 1, %h }.perl.say; }; foo( { b => 2 } )

[12:04] <p6eval> rakudo 34566: OUTPUT«{"a" => 1, "b" => 2}␤»

[12:05] <ihrd> rakudo: sub foo (%h?) { { a => 1, %h }.perl.say; }; foo({});

[12:05] <p6eval> rakudo 34566: OUTPUT«{"a" => 1}␤»

[12:05] <ruoso> hi pmurias 

[12:05] <ihrd> rakudo: sub foo (%h?) { { a => 1, %h }.perl.say; }; foo();

[12:05] <p6eval> rakudo 34566: OUTPUT«Odd number of elements found where hash expected␤current instr.: 'parrot;Perl6Hash;!STORE' pc 5676 (src/classes/Hash.pir:154)␤»

[12:05] <ihrd> hi pmurias

[12:06] <ihrd> so that look like bug for my, but mb it is not

[12:06] <ruoso> ihrd, that looks like a parrot bug...

[12:06] <ruoso> er...

[12:07] <ruoso> a rakudobug

[12:07] <ihrd> look like hash do not init right

[12:07] <ruoso> post it to [email@hidden.address]
[12:07] <ihrd> ok, I am submiting it 

[12:10] <ihrd> hm, I just thinking, mb it is not bug?

[12:10] <ihrd> rakudo: say {a => 1, undef }.perl.say

[12:10] <p6eval> rakudo 34566: OUTPUT«Odd number of elements found where hash expected␤current instr.: 'parrot;Perl6Hash;!STORE' pc 5676 (src/classes/Hash.pir:154)␤»

[12:11] <ihrd> %h really is undef

[12:11] <ruoso> the question is whether an undefined hash shouldn't behave as an empty hash

[12:11] <avar> rakuo: sub foo (%h?) { return { %h } }; foo();

[12:11] <avar> rakudo: sub foo (%h?) { return { %h } }; foo();

[12:11] <p6eval> rakudo 34566: RESULT«{ ... }»

[12:12] <avar> I think an empty has is the empty list in that context, not undef

[12:12] <avar> anyway, anything else would be silly

[12:12] <ihrd> avar: Rakudo do not understand you right

[12:12] <ruoso> avar, I think it thought on { %h } as a code object

[12:13] <avar> ah

[12:13] <ruoso> rakudo: sub foo (%h?) { return %h.kv }; say foo().perl

[12:13] <ihrd> rakudo:  my %h; { %h }.WHAT.say;

[12:13] <p6eval> rakudo 34566: OUTPUT«[0, undef]␤»

[12:13] <p6eval> rakudo 34566: OUTPUT«Block␤»

[12:13] <avar> rakudo: sub foo (%h?) { my $hashref = { %h }; $hashref }; foo();

[12:13] <pmurias> ruoso: you know having mildew output a shared library wouldn't require changing m0ld at all

[12:13] <p6eval> rakudo 34566: RESULT«{ ... }»

[12:13] <avar> I screwed it up again:)

[12:13] <ruoso> pmurias, you mean mildew compiling to a "plugin"?

[12:14] <pmurias> yes

[12:14] <ruoso> except changing the m0ld output ;)

[12:15] <avar> how is the elf CL backend going?

[12:15] <ruoso> avar, stalled AFAIK

[12:16] <pmurias> ruoso: m0ld compiles a block of m0ld code to a C expression

[12:16] <ruoso> ah.. it doesn't include the boilerplate...

[12:16] <ruoso> the boilerplate is external.. right

[12:17] <avar> how about elf itself (or other non-rakudo stuff)

[12:17] <pmurias> it is kept in m0ld_boilerplate_{front,back}

[12:17] <ruoso> avar, elf receives some attention by mncharity, ocasionally

[12:17] <ruoso> avar, but mildew is progressing really fast 

[12:17] <avar> isn't there some page with test runs for all the implementations?

[12:17] <avar> oh so yet another compiler now?:)

[12:17] <ruoso> avar, and the first compiler which is a STD backend

[12:18] <ruoso> (ok, maybe not the first)

[12:18] <avar> ah, nice

[12:18] <pmurias> pixie was first

[12:18] <avar> is it written in p5?

[12:18] <pmurias> mildew is written in p5

[12:18] <ruoso> but the first targetting a p6 runtime

[12:18] <ruoso> avar, it's written in p5, but targets SMOP

[12:19] <ruoso> so it can have the proper semantics

[12:19] <ruoso> avar, take a look at v6/mildew/t in the pugs repo

[12:19] <ruoso> you'll see what it can do already

[12:19] <ruoso> I've just implemented exception handling this weekend

[12:20] <avar> ah, isn't that a fairly advanced thing to implement?

[12:20] <pmurias> our feature set expands strangely

[12:21] <ruoso> avar, we advance by concept, not by feature ;)

[12:21] <ruoso> we have very few features

[12:21] <ruoso> but support a lot of concepts ;)

[12:22] *** rindolf joined
[12:23] <ruoso> avar, for instance, mildew already implements "return" as spec 

[12:23] <pmurias> but we don't have say ;)

[12:23] <ruoso> and, surprisingly, it is the first to do it

[12:24] <pmurias> but you'll be able to use the say from Perl6::Say soon

[12:24] <ruoso> heh

[12:25] <ruoso> pmurias, I think I reached a complicated point with captures

[12:25] <ruoso> hmm... maybe not

[12:25] <ruoso> the problem is actually in the way we're implementing the signatuer

[12:26] <ruoso> signatures

[12:27] <pmurias> yes

[12:27] <pmurias> go on ;)

[12:27] <ruoso> better yet, the problem is that p6opaque is not enclosing the capture in a scalar before sending as parameter to dispatch

[12:29] <ruoso> and we're probably not doing it on Code also

[12:29] *** azawawi left
[12:29] *** Hell_Kaiser left
[12:30] <pmurias> constructing a Scalar of Capture on every postcircumfix:<( )> doesn't seem very nice

[12:32] <ruoso> maybe the correct way would be to have a signature that doesn't enforce any context

[12:32] *** azawawi joined
[12:32] <ruoso> sub foo(\$capture)

[12:33] <ruoso> std: sub foo(\$capture)

[12:33] <p6eval> std 24676: OUTPUT«Unknown routines:␤     sub called at 0 ␤00:05 88m␤»

[12:33] <ruoso> std: sub foo(\$capture) {...}

[12:33] <p6eval> std 24676: OUTPUT«############# PARSE FAILED #############␤Syntax error at /tmp/NAD5nCVgXl line 1:␤------> [32msub foo(\$capture) [31m{...}[0m␤    expecting any of:␤       infix or meta-infix␤      infix stopper␤    standard stopper␤ statement modifier loop␤  terminator␤00:05 88m␤»

[12:35] <ruoso> I think I'll post that to p6-language

[12:57] *** azawawi_ joined
[13:01] <ruoso> pmurias, actually... the problem is that the dotty operator presumes item context

[13:01] <ruoso> at the moment...

[13:01] <ruoso> and it's actually correct

[13:02] <ruoso> the question is then "how do you call a method of a capture object"?

[13:06] <pmurias> you put it in a scalar

[13:06] <pmurias> and call a method on the scalar

[13:06] <ruoso> right...

[13:06] <ruoso> that's what the "\" operator does

[13:06] *** azawawi left
[13:08] <pmurias> object's which don't return themself in item context seem very tricky to handle properly

[13:08] <ruoso> but then you need to dereference a capture when sending it in a call

[13:08] <ruoso> pmurias, yes... but that's also what makes capture so powerfull

[13:09] <ruoso> the problem is that the syntax foo(|$bar) means replacing the actual capture

[13:09] *** masak left
[13:10] <ruoso> VAR($bar).FETCH would do the trick

[13:10] <ruoso> aha...

[13:11] <ruoso> if foo( (a => 1) ); turns the pair into a positional argument

[13:11] <ruoso>  foo( (|$capture) ); turns the capture into a positional argument

[13:11] <ruoso> sounds sane?

[13:12] <ruoso> pmurias, what do you think?

[13:14] <ruoso> I even think STD already parse this as a positional argument as well

[13:14] <ruoso> at least at first look, it seems like

[13:16] <pmurias> captures don't seem very sane to me atm, so it's hard for me to say

[13:18] <pmurias> ruoso: you are aware that there are a lot of leaks in the mildew test suit?

[13:18] <ruoso> yeah... 

[13:19] <ruoso> it's my new-years-promess

[13:19] <ruoso> "fix all leaks in SMOP"

[13:19] * pmurias laughts

[13:19] *** apeiron joined
[13:20] <ruoso> I think this could be a work for a grant

[13:21] <ruoso> pmurias, you could submit a grant proposal on that...

[13:21] <ruoso> since you're the memory czar now ;)

[13:22] * ruoso just sent another lenghty mail to p6-language

[13:25] <pmurias> shopping&

[13:25] <ruoso> @tell TimToady if you have some time, could you please take a look at the two capture-related messages I sent to p6-language

[13:25] <lambdabot> Consider it noted.

[13:27] *** eternaleye joined
[13:28] *** ihrd left
[13:30] *** masak joined
[13:31] *** justatheory joined
[13:36] <pugs_svn> r24677 | ruoso++ | [smop] fix p6opaque calling of HOW.dispatch.

[13:36] <pugs_svn> r24677 | ruoso++ | [smop] fix error message when OutOfItemsException is not caught

[13:36] <pugs_svn> r24677 | ruoso++ | [mildew] uses the correct signature in dispatch

[13:39] *** ejs1 left
[13:41] *** eternaleye_ left
[13:48] <pugs_svn> r24678 | pmurias++ | [smop] non-recursive method call on SMOP__Object* works (needs integration with PCL)

[13:53] *** apeiron left
[13:54] <ruoso> pmurias++ # cool

[13:54] *** alester joined
[13:55] *** apeiron joined
[13:56] <ruoso> pmurias, the integration with p5 in the way you're working is not supposed to be done by using PCL

[13:57] <ruoso> the PCL is a later stage to make XS stackless

[13:57] *** alester left
[13:57] <ruoso> the idea is to merge the SMOP interpreter with the p5 interpreter into a single runloop

[14:00] <pmurias> ruoso: why shouldn't i use PCL?

[14:00] <ruoso> pmurias, well.. you can

[14:01] <ruoso> but it won't provide the semantics we expect

[14:01] <ruoso> because if you have a stack made of: p5 -> mold -> p5 -> mold -> p5

[14:01] <ruoso> you'll need to have several perl interpreters

[14:02] * pmurias thinks

[14:03] *** apeiron left
[14:04] *** apeiron joined
[14:04] <ruoso> in order to support that kind of recursion...

[14:04] <ruoso> we need to merge p5 runloop and SMOP runloop 

[14:04] *** lichtkind joined
[14:08] <pmurias> so the problem is that if i'm in a p5 sub and it calls smop it can't call p5 again because the p5 interpreter is already executing that previous sub right?

[14:09] <ruoso> yes.... 

[14:09] <ruoso> if we merge the runloops

[14:09] <ruoso> we can save the "current continuation" in p5 using Coro

[14:09] <ruoso> execute the smop code

[14:09] <ruoso> enter a new Coro

[14:10] <ruoso> and switch back to the outer Coro when you unwind the stack

[14:12] <pmurias> so the next thing i'm doing is to steal the "save the current continuation" part from Coro?

[14:12] <ruoso> Well... 

[14:13] <ruoso> I think you need to compatibilize p5 and SMOP 

[14:13] <ruoso> that means creating a modified p5 interpreter

[14:13] <ruoso> where every p5 value is a SMOP__Object*

[14:15] *** kisu_ joined
[14:15] <ruoso> so you can use the Coro object in a $interpreter.goto($coro) call

[14:17] <pmurias> why do i need to compatibilize p5 and SMOP?

[14:17] <ruoso> because when you pass a SMOP__Object* as an argument to a p5 sub

[14:18] <pmurias> isn't it mostly a performance thing

[14:18] <ruoso> I'm not sure...

[14:18] <pmurias> i'm currently wrapping the objects when doing interchange

[14:19] <ruoso> then if you send a smop object to a p5 sub that re-sends that smop object to a smop code

[14:19] <ruoso> you'll have a SMOP__Object* wrapping a SV* that wraps a SMOP__Object*

[14:20] <pmurias> i have an if statement which avoids double wrapping

[14:21] <pmurias> so it either wrapps or unwrapps an object when it needs conversion

[14:21] <ruoso> hmm... ok...

[14:21] <ruoso> doing the SMOP-P5 merge is the *real thing*...

[14:22] <pmurias> it's part 3 on my C project plan

[14:22] <ruoso> but I suppose you can start by simply doing this wrapping and supporting Coro

[14:23] <pmurias> the problem with the SMOP-P5 merge is that will require a custom perl5

[14:23] <ruoso> it's not really a problem

[14:23] <ruoso> considering we're already embedding p5 in SMOP

[14:24] *** azawawi joined
[14:24] <ruoso> and also, a custom perl 5.10 feature might be integrated into the standard perl 5.12 ;)

[14:24] <pmurias> i doubt it

[14:25] <pmurias> as adding a RI would add a performace hit

[14:25] <ruoso> not really, since p5 already checks for tie

[14:26] <ruoso> checking if this is an SV or not is no performance hit

[14:26] <ruoso> and #p5p people seemed surprisingly receptive to this idea

[14:27] <ruoso> and everybody loves the phrase "perl 5.12 might support Perl 6"

[14:30] *** azawawi left
[14:31] <ruoso> pmurias, in fact, adding a RI might even make tie and overload simpler

[14:31] *** azawawi_ left
[14:32] *** kisu left
[14:33] *** azawawi joined
[14:34] <pmurias> i could try doing it

[14:34] <ruoso> pmurias, have you seen the SMOPP5 wiki page?

[14:35] <pmurias> yes, multiple times

[14:35] <ruoso> :)

[14:35] <pmurias> not having data* as a part of SMOP__Object would help

[14:36] <ruoso> I'd like to get rid of it, actually

[14:36] <ruoso> the sad part is that we would need to have special treatment for RIs in smop_lowlevel

[14:36] <ruoso> (but maybe that's not that bad)

[14:39] <pmurias> you mean in lowlevel.sm0p

[14:39] <ruoso> yes

[14:39] <ruoso> because the refcounting information is in *data

[14:39] <pmurias> we would have a SMOP__Object_refcounted or a better named equivalent

[14:40] <ruoso> pmurias, yes... probably declared in smop_lowlevel.h

[14:40] <ruoso> but we would need to have

[14:40] <ruoso> SMOP__Object_refcounted *and* SMOP__ResponderInterface_refcounted

[14:40] <pmurias> and RI's and other object which use lowlevel would be subclasses of it

[14:40] <ruoso> the problem is that moving data* out of SMOP__Object*

[14:41] <ruoso> places the function callbacks of SMOP__ResponderInterface* in the address of the refcounting information of SMOP__Object_refcounted

[14:41] <ruoso> thus SMOP__Object_refcounted is *not* binary compatible with SMOP__ResponderInterface_refcounted

[14:41] <pmurias> yes

[14:42] <ruoso> but SMOP__ResponderInterface is still binary compatible with SMOP__Object

[14:42] <ruoso> so it's not a big deal

[14:42] <ruoso> it's just a lot of work

[14:42] <ruoso> to refactor

[14:42] <ruoso> but it would be really nice

[14:43] <pmurias> plus we might get rid of the data pointer altogether

[14:43] <ruoso> yes yes

[14:43] <ruoso> that's the cool part

[14:43] <ruoso> the header of a SMOP__Object is simply one single pointer

[14:43] <ruoso> it can't get any more opaque than that

[14:44] <pmurias> what i meant that even SMOP__Object_refcounted wouldn't have it

[14:44] <ruoso> it would have something else in its place

[14:45] <ruoso> the SMOP_LOWLEVEL_INTERNAL struct 

[14:45] <ruoso> or a pointer to it

[14:45] <ruoso> actually, it's cool that the members of the SMOP_LOWLEVEL_INTERNAL can be part of the "Default SMOP Object implementation"

[14:45] <ruoso> and then we avoid an additional malloc

[14:46] <ruoso> then we need to refactor almost everything

[14:47] <ruoso> to replace SMOP__Object__BASE for SMOP__Object__RefCounted__BASE

[14:47] <ruoso> on every object that is subject to lowlevel.sm0p refcounting

[14:48] <pmurias> that's a simple s///

[14:48] <pmurias> ;)

[14:49] <masak> moritz_: yay! I won the Druid match against the inventor!

[14:49] <ruoso> are you willing to take that refactor?

[14:50] <pmurias> after i finish my p5 integration project

[14:59] *** azawawi left
[15:02] *** rindolf left
[15:08] <pmurias> ruoso: did you update smopp5 to reflect the mainline, i don't really know how do it?

[15:09] *** Grrrr left
[15:09] *** Grrrr joined
[15:09] *** araujo left
[15:09] *** azawawi joined
[15:10] <ruoso> pmurias, no, I didn't

[15:10] <ruoso> mildew: $OUT.print("Hello from mildew!");

[15:10] <p6eval> mildew: No output (you need to produce output to STDOUT)

[15:15] *** araujo joined
[15:20] <pmurias> don't know why it doesn't work

[15:20] <pmurias> smop is properly compiled in the evalbot

[15:21] <pmurias> ruoso: my git config looks like

[15:21] <pmurias> [remote "blead"] url = git://perl5.git.perl.org/perl.git fetch = +refs/heads/*:refs/remotes/blead/*

[15:22] <ruoso> what happens when you git pull blead?

[15:24] *** Exodist joined
[15:25] <pmurias> doing it now

[15:33] <pmurias> it told me i didn't specifiy a branch

[15:33] <pmurias> and it downloaded a lot of stuff

[15:39] <pmurias> ruoso: if i git pull blead blead i get merge conflicts :(

[15:41] <pmurias> now lots of stuff needs merging and i don't know how to undo the git pull blead blead

[15:43] *** alester joined
[15:43] <pmurias> git reset --hard HEAD worked

[15:46] <pmichaud> what's the standard mechanism to get STD to produce a parse tree dump?

[15:48] *** ejs joined
[15:49] *** azawawi left
[15:50] <rakudo_svn> r34579 | pmichaud++ | [rakudo]: spectest-progress.csv update: 264 files, 5802 passing, 141 failing

[15:50] <rakudo_svn> r34579 | pmichaud++ | Failure summary:

[15:50] <rakudo_svn> r34579 | pmichaud++ |     S16-filehandles/io.rakudo aborted 57 test(s)

[15:50] <rakudo_svn> r34579 | pmichaud++ |     S16-filehandles/io_in_for_loops.rakudo aborted 49 test(s)

[15:50] <rakudo_svn> r34579 | pmichaud++ |     S16-filehandles/io_in_while_loops.t aborted 13 test(s)

[15:50] <rakudo_svn> r34579 | pmichaud++ |     S16-io/basic-open.t aborted 9 test(s)

[15:50] <rakudo_svn> r34579 | pmichaud++ |     S16-unfiled/slurp.rakudo aborted 9 test(s)

[15:50] <rakudo_svn> r34579 | pmichaud++ |     integration/say-crash.t aborted 4 test(s)

[15:51] *** hercynium joined
[15:57] *** barney joined
[16:11] *** stephens joined
[16:12] *** eric256 joined
[16:14] * eric256 waves good morning

[16:14] <masak> \o

[16:15] <eric256> man its hard trying to get back in gear

[16:15] <masak> nod.

[16:18] *** azawawi joined
[16:20] *** vixey left
[16:31] *** jhorwitz joined
[16:32] <pugs_svn> r24679 | pmichaud++ | [t/spec]:  Eliminate some "Redeclared variable" warnings in tests

[16:33] <TimToady> pmichaud: to get a plain parse tree dump the output of STD->parsefile($file)

[16:33] <lambdabot> TimToady: You have 2 new messages. '/msg lambdabot @messages' to read them.

[16:33] <TimToady> to get something more ASTish, use viv, which autoloads action routines for reductions

[16:34] <TimToady> decommuting from socal soon...

[16:38] <pmichaud> TimToady: STD.pm shows two ways of parsing   @( ... )    -- as a variable and as circumfix:sigil

[16:38] * ruoso points to two messages at p6-language ;)

[16:38] <pmichaud> it seems to choose  the circumfix:sigil form.  When might it choose the variable one?

[16:39] <TimToady> pmichaud: well, probably never...

[16:39] *** vixey joined
[16:40] <TimToady> ruoso: seems okay, though I guess I don't have enough caffiene to understand why we can't just make captures work that way by default

[16:42] <ruoso> because they are in a $scalar

[16:45] * TimToady is think about *|$capture

[16:45] <TimToady> ing

[16:47] <pmurias> ruoso: doesn't a Scalar in item context return itself?

[16:47] <ruoso> yes,

[16:48] <ruoso> the problem is that when you have a signature binding, you force a context

[16:48] <pmurias> ruoso: does it really?

[16:48] <ruoso> yes, 

[16:48] <ruoso> foo(bar());

[16:48] <pmurias> if i have a $capture $$capture returns the invocant

[16:52] <ruoso> yes, that's the other isseue

[16:59] <moritz_> masak: congratulations! (re druid :-)

[16:59] *** alanhaggai joined
[16:59] <pmurias> moritz_: any idea's why the mildew evalbot doesn't work?

[16:59] <pmurias> why can't the capture just return itself in item context?

[17:00] <lichtkind> azawawi: hello had you took look at translation?

[17:00] <ruoso> pmurias, because then "return" can't work as expected

[17:00] <moritz_> mildew: $*OUT.print("hi")

[17:00] <p6eval> mildew: No output (you need to produce output to STDOUT)

[17:01] *** azawawi_ joined
[17:02] <pmurias> ruoso: example please

[17:03] *** p6eval left
[17:03] <ruoso> pmurias, the message i sent has an example

[17:03] *** p6eval joined
[17:04] <moritz_> mildew: $*OUT.print("hi")

[17:04] <p6eval> mildew: No output (you need to produce output to STDOUT)

[17:04] <moritz_> pmurias: I get a huge backtrace for each mildew command

[17:05] <moritz_> pmurias: starting with Can't chdir to 'umas 002; ../../v6/mildew': No such file or directory

[17:07] <moritz_> pmurias: moving the umask from line 55 to 56 should help, but I can't commit from the PC that I'm currently on

[17:07] *** tuxdna left
[17:07] *** p6eval left
[17:07] <moritz_> mildew: $*OUT.print("hi")

[17:07] *** p6eval joined
[17:08] <moritz_> perl6: say 'sanity';

[17:08] <p6eval> elf 24679, pugs, rakudo 34583: OUTPUT«sanity␤»

[17:08] <masak> sanity++

[17:08] <pmurias> sanity is overrated ;)

[17:08] <masak> karma sanity

[17:08] <masak> @karma sanity

[17:08] <lambdabot> sanity has a karma of 1

[17:08] <moritz_> ok, I changed that on the server, and now I don't get a bactrace anymore

[17:08] <moritz_> perlbot, karma sanity

[17:08] <perlbot> Karma for sanity: 6

[17:08] <masak> pmurias: I wouldn't say so, no :)

[17:08] <pmurias> moritz_: you mean from build-smop.sh?

[17:09] <moritz_> pmurias: no, from the evalbot

[17:09] <moritz_> pmurias: on the terminal in which p6eval runs

[17:09] <moritz_> afk &

[17:10] <pmurias> build-smop.sh is outdated

[17:12] <pmurias> @tell p6eval $OUT.print("hi")

[17:12] <lambdabot> Consider it noted.

[17:14] *** azawawi left
[17:14] <pmurias> mildew: $OUT.print("hello world\n")

[17:14] <p6eval> mildew: OUTPUT«hello world␤»

[17:14] <lambdabot> p6eval: You have 1 new message. '/msg lambdabot @messages' to read it.

[17:15] <eric256> p6eval: $OUT.say("hi");

[17:16] <pugs_svn> r24680 | lwall++ | [S02] derivatives of * are Code, not Whatever

[17:16] *** kisu_ is now known as kisu

[17:16] <eric256> perl6: $OUT.say("hi")

[17:16] <p6eval> rakudo 34584: OUTPUT«Scope not found for PAST::Var '$OUT'␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[17:16] <p6eval> ..elf 24679: OUTPUT«Global symbol "$OUT" requires explicit package name at (eval 115) line 3.␤ at ./elf_f line 3861␤»

[17:16] <p6eval> ..pugs: OUTPUT«hi␤»

[17:17] <pmurias> eric256: $OUT.say is a hack a smop doesn't have multi methods yet so we don't have say

[17:17] *** tomyan left
[17:17] <eric256> ohhh i was confused ;) lol i thought we might have $OUT and $IN ;)

[17:18] *** tomyan joined
[17:21] *** maerzhase joined
[17:23] <jnthn> I think $*OUT.say should work, mind. :-)

[17:23] *** cspencer joined
[17:24] * masak submits rakudobug

[17:25] *** tomyan left
[17:29] *** mberends joined
[17:33] <eric256> masak: re; http://github.com/masak/druid/commit/18ebc4b3378049ad86c7c52253e7caa2e31c2544 i like your original implementation better ;) 

[17:33] <cspencer> good morning!

[17:34] <eric256> though i do wonder why you don't have a 2d array and a draw board function, then draw board would take the array and print it out

[17:34] <eric256> why do you "take my $line =" instead of just "take join ..." ?

[17:34] <masak> eric256: you are aware that the "board" is 3-dimensional, right? :)

[17:34] <masak> eric256: because I use the value twice.

[17:35] *** azawawi joined
[17:35] <eric256> ohh i hmm... so how does storing it in a string solve the diminsion issue? i think i need to go read the whole source agian

[17:35] <eric256> lol

[17:35] <masak> eric256: I like my original implementation better too :) but I'm looking to generalize to arbritary board sizes

[17:35] <masak> eric256: I'm starting from an empty board, and "rendering" pieces on top of it

[17:36] <pmurias> jnthn: having globals in mildew would also solve the issue, but globals are rather a low priority for me

[17:37] <eric256> masak: i'm gonna go reread your source ;)

[17:37] <ruoso> jnthn, specially because I'm working to convince people we don't need globals ;)

[17:37] <ruoso> we can use $+OUT instead ;)

[17:40] *** azawawi_ left
[17:41] <ruoso> I should implement $+OUT lookup soon

[17:41] *** dukeleto joined
[17:42] <pmurias> implementing module loading and some sort of a Prelude would be nice

[17:43] <ruoso> we're close to that, actually

[17:43] <pmurias> what do we need?

[17:44] <ruoso> we need the module loader per se

[17:45] <pmurias> i can do it

[17:45] <pmurias> and?

[17:46] <ruoso> Package.EXPORTALL

[17:50] <pmurias> is Package.EXPORTALL hard?

[17:51] <pmurias> ruoso: if there is a unused bit in sv_flags we could it to mark if there is a RI* pointer on the SV*

[17:52] <pmurias> no that's a broken idea

[17:52] <ruoso> pmurias, we don't need to.. the p5 interpreter can check if the SV is one of its own

[17:53] <ruoso> the p5 interpreter can "know" a lot of internal RIs

[17:54] *** rindolf joined
[17:55] <eric256> masak: on a side note i think merge can be greatly simplified ;) playing with something for that right now

[17:55] <masak> eric256: cool.

[17:56] <eric256> is there a way to alias array elements in a for loop so they are editable? i.e for @A Z @B -> $a, $b { $a = $b }; ?

[17:57] <masak> eric256: <->

[17:57] <masak> dunno if Rakudo has 'em yet

[18:00] <masak> perl6: my @a = 1..3; for @a <-> $a { ++$a }; say @a.perl

[18:00] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ">"␤    at /tmp/yPaQBZr3GL line 1, column 24␤»

[18:00] <p6eval> ..rakudo 34586: OUTPUT«[2, 3, 4]␤»

[18:00] <p6eval> ..elf 24680: OUTPUT«Can't call method "flatten" without a package or object reference at (eval 123) line 4.␤ at ./elf_f line 3861␤»

[18:00] <eric256> oh wow

[18:00] <masak> Rakudo++

[18:00] <eric256> even easier then

[18:00] *** meteorjay left
[18:02] <masak> eric256: are you planning to fork me on github? I'd very much like to be forked :)

[18:03] <eric256> rakudo: my @in = <ABCD>; my @new = "1#3 4"; for @in Z @new <-> $old, $new { given $new { when ' ' {$new = $old} } }; say @new;

[18:03] <p6eval> rakudo 34586: OUTPUT«1#3 4␤»

[18:04] <masak> eric256: nice.

[18:04] <eric256> rakudo: my @in = < A B C D E>; my @new = ( '1', ' ',3, '#', '5'); for @in Z @new <-> $old, $new { given $new { when ' ' {$new = $old} } }; say @new;

[18:04] <p6eval> rakudo 34586: OUTPUT«Cannot assign to readonly variable.␤current instr.: 'die' pc 14740 (src/builtins/control.pir:204)␤»

[18:04] <eric256> hmmm its in there somewhere

[18:04] <eric256> but you can see how much simpler

[18:04] <eric256> i'll forkk and get it worked out

[18:05] <masak> eric256++

[18:05] <ruoso> TimToady, what does *|$capture mean?

[18:06] <ruoso> as I understand, |$capture means taking the entire capture that was sent to this invocation

[18:07] <ruoso> what I proposed in the message to p6-l was \$capture in order to take that specific positional argument as a capture

[18:07] <ruoso> so you can have several arguments, and one of them being a capture

[18:08] <ruoso> as in 

[18:08] <ruoso> method dispatch($object, $identifier, \$capture)

[18:08] <ruoso> or

[18:08] <ruoso> method postcircumfix:<( )>(\$capture, :$cc)

[18:11] <ruoso> unless I misunderstood |$capture

[18:12] <cspencer> does the p6 metaobject provide a method of doing 'can' based on method signature?  ie)  $obj.^can("foo(Int, Str)")

[18:12] <eric256> given apparently makes it read only

[18:13] <eric256> or not. its something deeper

[18:13] <eric256> rakudo: my @a = <1 2 3 4 5 6>; my @b = (10..16); for @a Z @b <-> $a,$b { $a++  }; say @a;

[18:13] <p6eval> rakudo 34586: OUTPUT«234567␤»

[18:13] <eric256> rakudo: my @a = <1 2 3 4 5 6>; my @b = (10..16); for @a Z @b <-> $a,$b { $a = $a +1 }; say @a;

[18:13] <p6eval> rakudo 34586: OUTPUT«Cannot assign to readonly variable.␤current instr.: 'die' pc 14740 (src/builtins/control.pir:204)␤»

[18:13] *** alanhaggai_ joined
[18:13] <eric256> rakudo: my @a = <1 2 3 4 5 6>; my @b = (10..16); for @a Z @b -> $a,$b { $a++ }; say @a;

[18:13] <p6eval> rakudo 34586: OUTPUT«234567␤»

[18:13] <eric256> yea ++ is working regardless of anything else ;) how odd

[18:14] * masak submits rakudobug

[18:14] <ruoso> cspencer, up to this point it is something like $obj.^can($identifier, $capture)

[18:14] <ruoso> actually...

[18:14] <ruoso> cspencer, up to this point it is something like $obj.^can($identifier, $capture?)

[18:14] <cspencer> ruoso: is the capture object used to specifiy the signature?

[18:15] <ruoso> no, it's a capture that you're trying to call the method with

[18:16] <cspencer> is that detailed in the specs?

[18:16] <ruoso> no... 

[18:16] <ruoso> there's no spec in the meta api yet

[18:16] <cspencer> ah ok :)

[18:16] <ruoso> except for some bits in S12

[18:16] <cspencer> i'll fiddle around with it then, thank you :)

[18:19] *** Ileg joined
[18:19] <Ileg> hi

[18:20] <Ileg> is there still support for cgi::irc?

[18:20] <literal> try #perl, this channel is about the Perl 6 language

[18:20] *** Ileg left
[18:21] <masak> the fact that people often miss the '6' at the end of '#perl6' is promising for the eventual Perl 6 deployment.

[18:26] *** Psyche^ joined
[18:31] *** alanhaggai left
[18:35] <ruoso> TimToady, taking an example from S06

[18:36] <ruoso> sub foo(\$args) {...}

[18:36] <ruoso> foo(1,2,3,:mice<blind>) {...}

[18:36] <ruoso> would fail

[18:36] <ruoso> because there are too many arguments

[18:36] <ruoso> but otoh

[18:37] <ruoso> sub foo(\$args, $other, $arg) {...}

[18:37] <ruoso> foo(bar(),$other,$arg)

[18:37] <ruoso> would delay the coercion on the return of bar()

[18:38] <ruoso> or, if you want to pass a capture as-is 

[18:38] <ruoso> my $capture = \(1,2,3);

[18:38] <ruoso> foo( (|$capture), $other, $arg);

[18:39] <ruoso> or even

[18:39] <ruoso> foo( (|(\(1,2,3)), $other, $arg);

[18:39] <ruoso> but it's fairly pointless to use such a construct

[18:40] <ruoso> using a plain list should work...

[18:40] <ruoso> foo( (1,2,3), $other, $arg)

[18:41] <ruoso> one very important side-effect

[18:41] <ruoso> is that

[18:42] <ruoso> foo( @x.grep{...}, 1,2,3)

[18:42] <ruoso> can delay the context where [email@hidden.address] ... }' is used

[18:42] <ruoso> and decide only later if it will be used as a list or as a slice

[18:42] <eric256> rakudo: ("abcdefg").split

[18:42] <p6eval> rakudo 34587: OUTPUT«No applicable methods.␤␤current instr.: '_block14' pc 58 (EVAL_13:38)␤»

[18:43] <eric256> rakudo: ("abcdefg").split()

[18:43] <p6eval> rakudo 34587: OUTPUT«No applicable methods.␤␤current instr.: '_block14' pc 58 (EVAL_13:38)␤»

[18:43] <eric256> rakudo: ("abcdefg").split('')

[18:43] <p6eval> rakudo 34587: RESULT«["a", "b", "c", "d", "e", "f", "g"]»

[18:43] *** Patterner left
[18:43] *** Psyche^ is now known as Patterner

[18:44] <masak> jnthn: why does ("abcdefgh").split say no applicable methods? is it looking for a method, and if so, which one?

[18:44] <ruoso> masak, it's looking for a candidate in multi split

[18:44] <ruoso> but there's no candidate with 0 args

[18:45] <masak> ruoso: ah, ok.

[18:50] <ruoso> TimToady, the reasoning behind this is that if you send a capture to be bound to a signature like :($capture), it already implies item context... so the '\' operator works by enclosing the capture into a scalar, while the '|' operator removes the enclosing scalar

[18:54] *** dwhipp joined
[19:07] <cspencer> rakudo: say "A"--

[19:07] <p6eval> rakudo 34587: OUTPUT«Unable to set lvalue on PAST::Val node␤current instr.: 'parrot;PAST;Val;lvalue' pc 556 (src/PAST/Node.pir:161)␤»

[19:07] <cspencer> rakudo: my $x = 'A'; $x--; say $x

[19:07] <p6eval> rakudo 34587: OUTPUT«A␤»

[19:08] <masak> cspencer: greetings.

[19:09] <cspencer> masak: hey, how's it going?

[19:09] *** dwhipp left
[19:09] <masak> cspencer: very well, thank you. how's the :by() work going?

[19:09] <cspencer> masak: probably done-ish today or tomorrow, i think?

[19:10] <masak> nice. have you run it against my tests yet?

[19:11] <cspencer> nope, the :by($n) syntax (as in 1..10:by(2)) hasn't been added in yet

[19:11] <masak> oh, right.

[19:11] <cspencer> i've just been creating the ranges as Range.new(:by(2), ...)

[19:11] <masak> maybe I should make a crack at adding the syntax.

[19:11] <cspencer> that would be great

[19:11] <cspencer> i've not fiddled much with the parser and the grammar, and wouldn't quite know where to start

[19:12] <masak> I'm a wee bit busy, but might be able to squeeze some in grammar hacking somewhere. we'll see.

[19:12] <cspencer> great, let me know how it turns out if you find time :)

[19:13] <masak> cspencer: I should put together a small tutorial on how to add syntax to Rakudo :) might be good for others as well.

[19:13] <cspencer> i would definitely appreciate that :)

[19:14] <masak> anyway, looking forward to the Range.new(:by(2)) patch.

[19:14] *** smtms joined
[19:14] <cspencer> thanks, i'll keep you posted :)

[19:15] <masak> excellent.

[19:15] *** ejs left
[19:24] *** cspencer left
[19:24] <pmurias> ruoso: how would adding an RI* pointer to SV* help with integrating the runloops?

[19:24] <ruoso> because to SMOP, everything will just be a SMOP__Object*

[19:25] <ruoso> and that's all

[19:28] *** alanhaggai__ joined
[19:36] *** Jedai joined
[19:37] *** cspencer joined
[19:39] *** sri_kraih joined
[19:39] *** pmurias left
[19:43] *** alanhaggai_ left
[19:43] *** barney left
[19:53] *** sri_kraih left
[19:57] *** tomyan joined
[19:57] <eric256> masak i sent you a pull request for druid ;)

[19:57] <eric256> first of many hopefully

[19:58] <eric256> later i plan on working on some of those scripting games problems and getting them in perl6-examples

[19:58] *** tomyan left
[19:59] <masak> eric256: reviewing.

[19:59] <masak> wow! new merge sub looks much sexier.

[20:00] <azawawi> eric256: what kind of game problems r u going to work on? ;-)

[20:01] *** Ehtyar left
[20:05] <masak> eric256: applied, thanks!

[20:06] *** aindilis` left
[20:07] * Matt-W idly pokes through the bug tracker looking for something suitable to try and fix

[20:15] *** mtkatwork joined
[20:15] <masak> Matt-W: #58524, p'haps.

[20:16] *** justatheory left
[20:16] <masak> #60234 might be fun too.

[20:17] <masak> possibly #60636, though that might be jnthn's turf.

[20:19] <masak> #61070.

[20:26] *** alanhaggai__ left
[20:28] * ruoso later &

[20:28] *** ruoso left
[20:30] <rakudo_svn> r34591 | chromatic++ | [Rakudo] Fixed IO open modes; all spectests pass again.

[20:34] <cspencer> so if i've got a range like: 'Z'..'A':by(-1) and i'm iterating over it down towards 'A'

[20:34] <cspencer> eventually i'll end up with the range 'A'..'A':by(-1)

[20:35] <masak> sounds reasonable.

[20:35] <cspencer> but since 'A'-- is also 'A', that range will never terminate

[20:35] <masak> I disagree.

[20:35] <cspencer> ok

[20:35] <masak> since the start and end points are the same, it's trivially one element.

[20:35] <cspencer> that's true

[20:36] <masak> so we're saved.

[20:36] <masak> however, in the case ('AA'..'Z'):by(1), we're screwed

[20:36] <masak> oops, :by(-1)

[20:37] <cspencer> because things aren't supposed to wrap to a string of a different length?

[20:38] <masak> cspencer: because 'Z'++ eq 'AA', but 'AA'-- eq 'AA'

[20:38] <cspencer> right.

[20:38] <cspencer> so what to do in that case, i wonder?

[20:38] * masak wonders if it'd possible to write a compiler heuristic that emitted a warning for ranges which do not look infinite, but are.

[20:39] <masak> cspencer: well, Perl 6 _does_ support infinite ranges...

[20:39] <cspencer> it's true, it does :)

[20:39] <masak> cspencer: so I suggest you just keep iterating forever.

[20:39] <cspencer> that sounds easy enough to this guy

[20:40] <cspencer> back in a bit, lunch time

[20:56] *** rindolf left
[21:00] <cspencer> back

[21:02] <cspencer> ok, so if i've got a range like: 1..1:by(-1)

[21:02] <masak> rakudo: say (1..1).elems

[21:02] <p6eval> rakudo 34591: OUTPUT«1␤»

[21:02] <cspencer> the first iteration will return 1, and the range will be updated to 0..1:by(-1)

[21:02] <masak> rakudo: for 1..1 { say "OH HAI" }

[21:02] <p6eval> rakudo 34591: OUTPUT«sh: ./parrot: Permission denied␤»

[21:02] <cspencer> and the iteration will stop, on account of no further elements

[21:02] <masak> cspencer: right.

[21:03] <cspencer> so on a similar note, after you've done an iteration on 'A'..'A':by(-1), what would the range look like afterwards?

[21:03] <pmichaud> ...iteration does not modify the range.

[21:04] <pmichaud> rakudo;  my $r = 1..1;  for $r { say $_ };  say $r.perl;

[21:04] <pmichaud> rakudo:  my $r = 1..5;  for $r { say $_ };  say $r.perl;

[21:04] <p6eval> rakudo 34591: OUTPUT«1␤2␤3␤4␤5␤1..5␤»

[21:05] <pmichaud> (arguably this is wrong -- perhaps it should be  for =$r { ... } )

[21:05] <pmichaud> still, the point remains that iterating a range doesn't modify it.

[21:06] <cspencer> so the from and to aren't modified then

[21:07] <masak> pmichaud: I disagree. `for =$r` would iterate over one element.

[21:07] <cspencer> a 1..5 range is always a 1..5 range?

[21:07] <masak> cspencer: well, unless you shift or pop it :)

[21:07] <pmichaud> masak:  I think that `for $r` should iterate over one element.

[21:07] <Matt-W> masak: thanks for the suggestions. I'm not sure which would be easiest, but I'll have a poke around and see if I can come up with some idea how to tackle them

[21:07] <masak> pmichaud: well, maybe that too.

[21:07] <pmichaud> same as:  my $r = (1,2,3);  for $r { ... }    would iterate over one element

[21:07] <masak> Matt-W: best of luck.

[21:07] <cspencer> ah, ok, i was actually shifting in my case, so yes :)

[21:08] <masak> pmichaud: aye.

[21:08] <Matt-W> masak: it is my ambition to actually *need* a commit bit :)

[21:08] <masak> Matt-W: :)

[21:08] <masak> Matt-W: people often prove their worth by sending useful patches. just a tip. :)

[21:09] <cspencer> i've got my terminology all mixed up here

[21:09] <Matt-W> masak: Well give me a while and I might manage to write one :)

[21:09] <cspencer> what about: $r = 'A'..'A'; $r.shift; $r.perl.say

[21:09] <masak> perl6: $r = 'A'..'A'; $r.shift; $r.perl.say

[21:09] <p6eval> rakudo 34591: OUTPUT«Scope not found for PAST::Var '$r'␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (src/PCT/HLLCompiler.pir:102)␤»

[21:09] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected " ="␤    expecting "::"␤    Variable "$r" requires predeclaration or explicit package name␤    at /tmp/MLvO8GG0fu line 1, column 3␤»

[21:09] <p6eval> ..elf 24680: OUTPUT«Global symbol "$r" requires explicit package name at (eval 117) line 3.␤Global symbol "$r" requires explicit package name at (eval 117) line 4.␤Global symbol "$r" requires explicit package name at (eval 117) line 5.␤ at ./elf_f line 3861␤»

[21:10] <masak> perl6: my $r = 'A'..'A'; $r.shift; $r.perl.say

[21:10] <p6eval> pugs: OUTPUT«\\()␤»

[21:10] <p6eval> ..rakudo 34591: OUTPUT«"B".."A"␤»

[21:10] <p6eval> ..elf 24680: OUTPUT«Can't call method "shift" without a package or object reference at (eval 117) line 4.␤ at ./elf_f line 3861␤»

[21:10] <masak> I'd guess that behavior might be unspecced.

[21:10] <cspencer> what's elf, out of curiosity? 

[21:11] <masak> cspencer: an implementation of Perl 6 in Perl 6.

[21:11] <cspencer> ah, ok

[21:11] <Matt-W> That must be fun

[21:11] <masak> http://perl.net.au/wiki/Elf

[21:11] <masak> it seems to be a lot of fun, actually.

[21:11] <masak> you should check out the source code.

[21:12] <masak> I'm positively amazed that a Perl 6 compiler of that magnitude already exists, without receiving more attention, even within the Perl 6 community.

[21:12] <Matt-W> I should, I've been trying to write something that uses rules so I suspect it might have interesting things for me to look at

[21:12] *** lisppaste3 joined
[21:13] <masak> Matt-W: http://svn.pugscode.org/pugs/misc/elf/

[21:13] *** lichtkind left
[21:22] <cspencer> for the behavior of .shift on the 'A'..'A' range, is that something worth posting to p6-lang?

[21:22] * masak thinks so

[21:25] <pmichaud> I think the existing spec is quite clear on that point, though.

[21:25] <cspencer> ok

[21:25] <pmichaud> .shift on 'A'..'A'  causes the range to become 'B'..'A'

[21:25] <cspencer> and for a shift on 'A'..'A':by(-1) ?

[21:26] <masak> 'A'..'B', presumably

[21:26] <cspencer> which would be a null range

[21:27] <pmichaud> that would be correct.

[21:27] <cspencer> ok, that makes sense

[21:27] <pmichaud> (null range)

[21:27] <pmichaud> because 'A'..'A' has one element in it, and after shifting it should be null.

[21:27] <cspencer> right, ok, that makes perfect sense

[21:27] <cspencer> thanks for letting me talk out loud here :)

[21:28] <cspencer> or maybe that's think out loud

[21:28] <masak> both :)

[21:32] * pmichaud was thinking "write out loud", but that's a Sharpie(TM) service mark :-)

[21:33] *** icwiener joined
[21:34] <masak> time to pretend to sleep.

[21:34] <masak> g'night, people.

[21:34] *** masak left
[21:35] <cspencer> masak: good night!

[21:35] <Matt-W> I'm very confused now

[21:37] <Matt-W> infix:~~ calls a method called 'ACCEPTS' on one of its arguments, giving the other as a parameter. Bool's 'ACCEPTS' seems to just return self, which is doing my head in.

[21:39] <pmichaud> $x ~~ True    is always true

[21:39] <pmichaud> $x ~~ False   is always false

[21:39] <pmichaud> from S03:

[21:40] <pmichaud>     $_        X         Type of Match Implied   Match if (given $_)

[21:40] <pmichaud>     ======    =====     =====================   ===================

[21:40] <pmichaud>     Any       Bool      simple truth            X

[21:41] <pmichaud> to smart match on $x being true or false, one would use   .true, I think.

[21:42] <pugs_svn> r24681 | schwarzer++ | [docs/Perl6/Spec] typo: use lower case letters

[21:42] *** Matt-W_ joined
[21:43] <pugs_svn> r24682 | schwarzer++ | [docs/Perl6/Spec] typos and minor style changes

[21:47] *** Matt-W_ left
[21:47] *** smtms left
[21:47] *** p6eval left
[21:47] *** vixey left
[21:47] *** jhorwitz left
[21:47] *** Exodist left
[21:47] *** simcop2387 left
[21:47] *** dmpk2k left
[21:47] *** Matt-W left
[21:47] *** cspencer left
[21:48] *** iblechbot left
[21:48] *** elmex left
[21:48] *** charsbar_ left
[21:48] *** eric256 left
[21:48] *** araujo left
[21:48] *** Grrrr left
[21:48] *** DemoFreak left
[21:48] *** xuser_ left
[21:48] *** lambdabot left
[21:48] *** apeiron left
[21:48] *** eternaleye left
[21:48] *** meppl left
[21:48] *** rhr_ left
[21:48] *** lisppaste3 left
[21:48] *** dukeleto left
[21:48] *** stephens left
[21:48] *** xinming left
[21:48] *** hercynium left
[21:48] *** bsdperl left
[21:48] *** kisu left
[21:48] *** szbalint left
[21:48] *** jnthn left
[21:48] *** nnunley left
[21:48] *** hcchien left
[21:48] *** broquaint left
[21:48] *** SamB left
[21:48] *** dalek left
[21:49] *** Tene joined
[21:49] *** Matt-W joined
[21:49] *** lisppaste3 joined
[21:49] *** cspencer joined
[21:49] *** smtms joined
[21:49] *** dukeleto joined
[21:49] *** p6eval joined
[21:49] *** vixey joined
[21:49] *** jhorwitz joined
[21:49] *** eric256 joined
[21:49] *** stephens joined
[21:49] *** hercynium joined
[21:49] *** Exodist joined
[21:49] *** araujo joined
[21:49] *** Grrrr joined
[21:49] *** apeiron joined
[21:49] *** eternaleye joined
[21:49] *** DemoFreak joined
[21:49] *** meppl joined
[21:49] *** iblechbot joined
[21:49] *** elmex joined
[21:49] *** xinming joined
[21:49] *** dmpk2k joined
[21:49] *** charsbar_ joined
[21:49] *** xuser_ joined
[21:49] *** bsdperl joined
[21:49] *** simcop2387 joined
[21:49] *** rhr_ joined
[21:49] *** lambdabot joined
[21:49] *** drbean_ joined
[21:49] *** yahooooo joined
[21:49] *** Khisanth joined
[21:49] *** zev joined
[21:49] *** r0bby joined
[21:49] *** pasteling joined
[21:49] *** literal joined
[21:49] *** c1sung joined
[21:49] *** edenc joined
[21:49] *** nothingmuch joined
[21:49] *** Eevee joined
[21:49] *** StephenPollei joined
[21:49] *** ilbot2 joined
[21:49] *** Trey joined
[21:49] *** allbery_b joined
[21:49] *** mj41 joined
[21:49] *** go|dfish joined
[21:49] *** awwaiid joined
[21:49] *** irc.freenode.net sets mode: +o Tene

[21:49] *** japhb joined
[21:49] *** kidd joined
[21:49] *** kcwu joined
[21:49] *** cls_bsd joined
[21:49] *** wolverian joined
[21:49] *** Lunchy joined
[21:49] *** buubot joined
[21:49] *** Guest16015 joined
[21:49] *** baest joined
[21:49] *** silug joined
[21:49] *** IRSeekBot joined
[21:49] *** ingy joined
[21:49] *** spinclad joined
[21:49] *** jjore joined
[21:49] *** szabgab joined
[21:49] *** sunnavy joined
[21:49] *** mtve joined
[21:49] *** integral joined
[21:50] *** jnthn joined
[21:50] *** kisu joined
[21:50] *** dalek joined
[21:50] *** SamB joined
[21:50] *** broquaint joined
[21:50] *** hcchien joined
[21:50] *** nnunley joined
[21:50] *** szbalint joined
[21:50] *** irc.freenode.net sets mode: +o jnthn

[21:51] *** mtkatwork left
[21:51] *** AzureStone joined
[22:03] *** Whiteknight joined
[22:06] *** knewt_ joined
[22:06] *** azawawi left
[22:10] *** knewt_ is now known as knewt

[22:12] *** azawawi joined
[22:14] <Matt-W> [matthew@asymptote perl6]$ pwd

[22:14] <Matt-W> /home/matthew/Compiling/parrot/languages/perl6

[22:14] <Matt-W> [matthew@asymptote perl6]$ ./perl6 -e "open 'perl6.pir'"

[22:14] <Matt-W> Invalid mode for file open

[22:14] <Matt-W> ^ not good

[22:25] <pmichaud> Matt-W: try svn up -- a fix was just added a short while ago.

[22:26] <Matt-W> shall do

[22:30] <Matt-W> pmichaud: excellent ,seems to be working now

[22:35] *** vixey left
[22:38] *** revdiablo joined
[22:40] <revdiablo> Is there any documentation about 'yield' and 'produce' besides the draft S17?

[22:47] *** alexi5 joined
[22:47] <alexi5> hello

[22:54] *** knewt left
[22:55] <eric256> if (A..A).shift = (B..A) then would (A..A).pop = (A..B)??

[22:55] <eric256> rakudo: my $r = ('A'..'A'); $r.perl.say; $r.pop; $r.perl.say;

[22:55] <p6eval> rakudo 34594: OUTPUT«"A".."A"␤"A".."A"␤»

[22:55] <eric256> rakudo: my $r = ('A'..'A'); $r.perl.say; $r.shift; $r.perl.say;

[22:55] <p6eval> rakudo 34594: OUTPUT«"A".."A"␤"B".."A"␤»

[22:56] <eric256> definitly not intuitive if thats the speced behaviour

[22:56] <eric256> rakudo: my $r = ('A'..'A'); $r.perl.say; $r.shift; $r.perl.say; $r.pop; $r.perl.say

[22:56] <p6eval> rakudo 34594: OUTPUT«"A".."A"␤"B".."A"␤"B".."A"␤»

[22:58] *** hercynium left
[23:17] *** icwiener left
[23:18] <revdiablo> From my reading of S17, C<produce> sounds like it does the same thing as C<yield>, but I have a feeling I'm just misunderstanding the description... anybody further details I can read about?

[23:21] *** mberends left
[23:22] *** ruoso joined
[23:23] <ruoso> Hello!

[23:29] *** Limbic_Region joined
[23:29] *** lambdabot left
[23:30] <revdiablo> Limbic_Region: Hey, long time no see

[23:30] <Limbic_Region> salutations

[23:32] *** lambdabot joined
[23:33] *** iblechbot left
[23:33] <revdiablo> Limbic_Region: You wouldn't happen to know about yield and produce, would ya? =)

[23:34] <Limbic_Region> yield from coroutines?

[23:34] <Limbic_Region> or from a gather/take?

[23:34] <revdiablo> From coroutines.  I know what yield normally does, but S17 makes it sound like produce does the same thing, hence my confusion.

[23:35] <Limbic_Region> I haven't been keeping up with the synopses - let me go read

[23:35] *** cognominal joined
[23:35] <Limbic_Region> revdiablo: um, S17 is not on dev.perl.org/perl6

[23:36] <revdiablo> It's still a draft, so really rough.  It's probably a tragic combination of rough docs and my comic misunderstanding.

[23:36] <revdiablo> http://feather.perl6.nl/syn/

[23:37] <Limbic_Region> yeah, should ping TimToady about the draft Ss in the pugs repository since I am pretty sure that is now their current "official" home

[23:39] *** cognominal left
[23:39] *** cognominal joined
[23:39] <revdiablo> A friend of mine asked how Perl 6 will do coroutines, and I tried to quote relevant docs.  Instead I got confused and scared

[23:40] <Limbic_Region> revdiablo: every time I have brought up coroutines to TimToady - he has said that gather/take is more powerful and the way to go

[23:41] <Limbic_Region> revdiablo: that synopsis really needs some clearing up if it is to be "approved"

[23:42] <revdiablo> The gather/take docs left me a little confused, too

[23:42] <revdiablo> I feel like I haven't been paying enough attention for the past 2 years

[23:43] <Limbic_Region> at least that long for me too

[23:45] <revdiablo> I should pick an arbtirary time and start using rakudo instead of perl.

[23:45] <Limbic_Region> revdiablo: I am asking pmichaud over on #parrot about the synopses

[23:48] <pmichaud> here.

[23:48] <Limbic_Region> oh

[23:48] <pmichaud> many of the documents in the repo are still draft and not really "official"

[23:48] <pmichaud> S17 is one of those.

[23:48] <revdiablo> I wonder how much trouble it would be to change my nick after all these years

[23:49] <pmichaud> but yes, gather/take is really the Perl 6 answer at the moment

[23:49] <Limbic_Region> pmichaud: well, if you scroll up - you can see why re-organizing the Synopses like the test suite could be a good idea for curious onlookers

[23:49] <Limbic_Region> revdiablo tried to explain something and got all confused

[23:50] <revdiablo> Sadly, that happens more and more these days ;)

[23:50] <pmichaud> L-R:  that's a very interesting idea

[23:50] <Limbic_Region> and it would be nice if one of the gather/take examples were a translation of typical coroutine for those trying to figure out how it is an improvement

[23:51] <pmichaud> perhaps an easier approach is to take a typical coroutine and express it with gather/take

[23:51] <revdiablo> I remember how gather/take works, but it seems a little clunky as a replacement for the simple uses of yield

[23:51] <Limbic_Region> pmichaud - that's what I meant

[23:51] <pmichaud> revdiablo: actually, I find it a bit more elegant.

[23:52] <pmichaud> revdiablo: if you can point me to a (relatively simple) yield example, I think I can come up with the gather/take equivalent.

[23:53] * Limbic_Region can do that

[23:53] <revdiablo> I can translate/simplify an example from some python code I wrote the other day

[23:53] <Limbic_Region> http://www.sidhe.org/~dan/blog/archives/000178.html

[23:54] <pmichaud> python code would be fine, too.

[23:55] <revdiablo> Here's one in perl5ish syntax: sub files { my $self = shift; for my $row ($self->{sth}->fetchall_arrayref) { yield $row->[0]; } }

[23:55] <pmichaud> okay, I'll get a little close, then.

[23:55] <Limbic_Region> right - in p5 speak you would create an iterator using a closure

[23:56] <Limbic_Region> yield makes that easier

[23:56] <revdiablo> Yeah, it's really convenient for the simple case

[23:56] <pmichaud> my $a = gather { for =$sth -> $row { take $row[0]; } };

[23:57] <pmichaud> where =$sth is whatever you're wanting to iterate over

[23:57] <revdiablo> pmichaud: Then the consumer can iterate on $a?

[23:57] <pmichaud> revdiablo: yes.

[23:58] <revdiablo> Ok, that works. =)

[23:58] <pmichaud> of course, it can also be

[23:58] <pmichaud> my $a = gather { for =$sth -> $row { sub_that_invokes_take($row); } };

[23:59] <pmichaud> i.e., 'take' doesn't have to be lexically in the gather block

[23:59] <pmichaud> it can be in some other sub that is dynamically called from gather

