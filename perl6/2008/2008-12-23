[00:02] *** duke_leto left
[00:06] <literal> without using :to, which string delimiters are valid? all bracketing characters except (), plus // ?

[00:06] <literal> and except <>, I presume

[00:08] *** eternaleye_ joined
[00:09] <literal> ah hm, never mind

[00:10] *** maerzhase1 left
[00:13] *** eternaleye left
[00:14] <zev> If I'm adding additional tests which pass under a patch I just submitted (but don't without the patch), should I mark the tests todo?

[00:16] *** ruoso joined
[00:21] <ruoso> btw... pmurias++ # plumbing

[00:25] <cspencer> rakudo: say *.perl

[00:25] *** gbacon joined
[00:25] <p6eval> rakudo 34262: OUTPUT«Statement not terminated properly at line 1, near ".perl"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[00:25] *** eternaleye joined
[00:25] <cspencer> rakudo: say (*).perl

[00:25] <p6eval> rakudo 34262: OUTPUT«*␤»

[00:40] <pugs_svn> r24569 | zev++ | additional substitution tests

[00:40] *** eternaleye_ left
[00:47] <pmichaud> zev:  yes, mark the tests as 'skip' or 'todo' until the patch has been applied.

[00:48] <zev> done

[00:48] <pmichaud> literal: all bracketing characters are valid delimiters

[00:50] *** hudnix_ joined
[00:51] <pugs_svn> r24570 | pmichaud++ | [t/spec]:  Adjust plan for test added to reduce.t in r24567.

[01:00] <rakudo_svn> r34263 | pmichaud++ | [rakudo]:  refactor more "list methods" from Mapping into Any

[01:04] *** stephens left
[01:05] *** hudnix_ left
[01:11] *** ewilhelm_ joined
[01:11] *** cspencer left
[01:12] <pmichaud> are 'next', 'last', and 'NEXT', 'LAST', etc. honored in map and grep?

[01:14] *** Limbic_Region left
[01:15] <zev> I'm looking at #58524, which references S04.  S04 says that "=<>" is equivilent to "=$*ARGS".  should that be "@*ARGS"?

[01:16] <pmichaud> no, it's $*ARGS

[01:16] <pmichaud> @*ARGS is an array

[01:16] <lambdabot> Unknown command, try @list

[01:16] <pmichaud> $*ARGS is a magic filehandle iterator

[01:17] <zev> I ask because misc.pir has the '=<>' sub calling 'prefix:=' with "get_hll_global '@ARGS'" as its argument

[01:18] <pmichaud> yes, it's wrong.

[01:18] <pmichaud> (misc.pir, that is.)

[01:18] <zev> then it should be get_hll_global '$*ARGS' ?

[01:19] <pmichaud> it can be, if someone would write the code for '$*ARGS'  :-)

[01:19] <pmichaud> (rakudo doesn't implement $*ARGS yet.)

[01:19] *** hudnix_ joined
[01:23] *** alc joined
[01:24] *** ruoso left
[01:25] <zev> so, it's supposed to be an iterator that iterates over either the command line arguments or standard in?

[01:25] <pmichaud> over the files given by the command line arguments, yes.

[01:26] <zev> what is the $*ARGS capture then?

[01:26] <pmichaud> I don't understand.

[01:26] <zev> (I'm looking at the table in S06 under 'Declaring a MAIN subroutine')

[01:27] <wolverian> http://www.itu.dk/people/mir/typesafepatterns.pdf reminds me of some aspects of given/when

[01:27] *** kisu_ joined
[01:28] <pmichaud> $*ARGS as a capture (as described in S06) would be the command line arguments after they've been processed for option switches

[01:29] <pmichaud> I'm not sure that's intended to be the same $*ARGS described in S02/S04

[01:29] <pmichaud> so perhaps one or the other is a typo

[01:30] <pmichaud> if they are intended to be the same, then iterating over $*ARGS is what produces the successive opens of any filenames given in @*ARGS

[01:30] *** alanhaggai left
[01:30] <zev> how would it be different if they weren't the same $*ARGS?

[01:31] *** kisu left
[01:31] <pmichaud> I don't know.

[01:31] <pmichaud> we probably need a clarification from p6l

[01:31] <zev> ok.  I'll send mail

[01:41] <zev> anyway, so $*ARGS should iterate over all the files specified on the command line followed by stdin

[01:42] <zev> in terms of implementation, does it make sense for it to be an instance of a subclass of IOIterator?

[01:43] *** alexn_org joined
[01:44] <zev> or perhaps this is something that would be better implemented in Perl6 itself (to get anonymous subclasses)

[01:44] <zev> s/itself//

[01:47] <TimToady> rakudo: Whatever.perl

[01:47] <lambdabot> TimToady: You have 6 new messages. '/msg lambdabot @messages' to read them.

[01:47] <p6eval> rakudo 34263: RESULT«"Whatever"»

[01:47] <TimToady> rakudo: *.defined

[01:47] <p6eval> rakudo 34263: OUTPUT«Statement not terminated properly at line 1, near ".defined"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[01:47] <TimToady> o_O

[01:48] <literal> so, "" is q:q:qq ?

[01:48] <literal> er, Q:q:qq

[01:48] <TimToady> just Q:qq

[01:48] <literal> does :qq imply :q ?

[01:49] <TimToady> they are different animals

[01:49] <TimToady> rakudo: defined(*)

[01:49] <p6eval> rakudo 34263: RESULT«1»

[01:49] <TimToady> rakudo: defined(Whatever)

[01:49] <p6eval> rakudo 34263: RESULT«0»

[01:49] <TimToady> rakudo: **.perl

[01:49] <literal> if "" is just Q:qq which doesn't imply :q, then it shouldn't interpolate \", \\ ... right?

[01:49] <p6eval> rakudo 34263: OUTPUT«Null PMC access in get_number()␤current instr.: 'parrot;Whatever;' pc 8525 (src/classes/Whatever.pir:41)␤»

[01:50] <TimToady> qq and q have independent backslashing rules

[01:51] <literal> hm, I just noticed that :qq implies :b which says "Interpolate \n, \t, etc. (implies :q at least)"

[01:51] <TimToady> for instance, the default is different for things that didn't need backslashing

[01:52] *** azawawi_ joined
[01:53] <TimToady> :b is the qq semantics, not sure what the parenthetical remark means

[01:53] <literal> so q{\s\d\k} == '\f\b\g', while qq{\s\d\k} == 'fbg' ?

[01:54] <literal> assuming \s, \d, \k are meaningless espace sequences

[01:54] <literal> er, that was supposed to be sdk there, not fbg

[01:55] <TimToady> yes

[02:01] *** azawawi left
[02:02] <zev> is there something wrong with the perl.org mail system?  Email I've sent to perl6-language hasn't been delivered to me.  Or has p6l become moderated?

[02:03] <meppl> good night

[02:04] *** meppl left
[02:06] *** DemoFreak left
[02:24] <pmichaud> zev: email on perl.org is sometimes slow.  

[02:24] *** Whiteknight left
[02:24] <pmichaud> zev: also, I've noticed that sometimes individual accounts get moderated if they haven't posted for a while.  (This happens to me sometimes.)

[02:24] *** apeiron left
[02:25] *** apeiron joined
[02:25] <pmichaud> TimToady: when we say that 'map' and 'for' are isomorphic, does that extend to things like NEXT/LAST/REDO closure traits?

[02:26] <TimToady> seems reasonable

[02:26] <pmichaud> is 'next' lexical like 'return' is lexical?

[02:27] *** alexn_org left
[02:27] <pmichaud> i.e., if I have   for @list {   ... my @b = map { next if ... }, @something }

[02:27] <pmichaud> then the "next" applies to the lexical for loop, and not the 'map' ?

[02:28] <TimToady> why shouldn't it apply to the map?

[02:29] <pmichaud> it certainly _can_, but afaik 'map' isn't a statement construct just yet

[02:29] <TimToady> lemme stew about it over dinner.

[02:29] <pmichaud> okay.

[02:30] * pmichaud had stew for dinner last night.

[03:18] <Khisanth> so next won't be an alternate way to spell goto anymore? :P

[03:19] *** hercynium joined
[03:20] *** alanhaggai joined
[03:21] <TimToady> how do you suppose goto works?

[03:25] <TimToady> the implementation of goto LABEL in perl 5 is over 100 lines long.  Perl's goto was never C's goto. :)

[03:37] *** cspencer joined
[03:38] *** hercynium left
[03:40] <pugs_svn> r24571 | pmichaud++ | [t/spec]:  Unfudge some more rakudo tests.

[03:42] *** Minthe joined
[03:44] *** Minthe left
[03:45] *** aindilis` joined
[03:50] *** pdcawley left
[04:00] *** aindilis left
[04:02] *** elmex_ joined
[04:10] *** pdcawley joined
[04:17] *** elmex left
[04:17] *** elmex_ is now known as elmex

[04:22] *** ChrisDavaz joined
[04:34] *** pdcawley left
[04:42] <azawawi_> good morning

[04:57] *** Minthe joined
[04:58] *** kisu_ left
[04:58] *** kisu joined
[05:03] <azawawi_> Hello

[05:04] *** azawawi_ is now known as azawawi

[05:08] <cspencer> good evening!

[05:09] <azawawi> not bad... 3 mins response time ;-)

[05:09] *** masak joined
[05:09] <azawawi> 5 min to be exact

[05:09] <cspencer> hah, yeah there was some serious lag time in that response :)

[05:09] *** alester_ joined
[05:10] <azawawi> lol

[05:10] * azawawi Padre::Plugin::Perl6 - Syntax highlighting + checking while you type Perl 6 code

[05:17] <cspencer> azawai: what's padre?

[05:18] <azawawi> an Perl IDE based on scintilla...

[05:18] <cspencer> ah ok

[05:18] <azawawi> http://padre.perlide.org/

[05:18] <cspencer> i've not heard of that one before

[05:19] <azawawi> basically you have two Perl IDEs Padre and Kephra atm

[05:20] <cspencer> alright.  i've not heard of the other one either, i suppose i don't very far from emacs all that often :)

[05:21] <azawawi> Padre has a Vi-plugin but i suppose that you wont like it

[05:21] <cspencer> probably wouldn't switch to vi for it, no :)

[05:27] *** Minthe left
[05:30] <cspencer> i'm out for the night, good night :)

[05:30] *** cspencer left
[05:34] <masak> azawawi++ # making the Perl 6 world more colorful

[05:35] <azawawi> masak: did u try it? ;-)

[05:35] <masak> not yet, no.

[05:35] <masak> I'm also an entrenched Emacs user.

[05:35] <azawawi> next step Perl6 snippets and autocompletion ;-)

[05:35] <masak> ooh, autocompletion!

[05:36] <azawawi> why do u think i used STD.pm ? ;-)

[05:36] <azawawi> btw, STD.pm error information is now available in Padre

[05:43] *** sail0r joined
[05:43] *** ChrisDavaz left
[05:44] <masak> cool.

[05:45] <azawawi> the cool thing is to have the tree node information while you type

[05:46] <azawawi> along with wizards for Perl6 code

[05:46] <azawawi> you sometimes have to create wizards to create wizards ;-)

[05:47] <masak> meta-wizards.

[05:49] <literal> azawawi: you said something about porting perl6.vim to Perl regexes. If you meant Perl 5, then there's a big problem because Perl 5 only support constant-length lookbehind

[05:49] <literal> perl6.vim uses variable-length lookbehind/lookahead *a lot* :P

[05:53] *** ChrisDavaz joined
[06:03] *** sail0r left
[06:04] <azawawi> literal: oh well; i havent started on it yet. thx for the information.

[06:07] *** xuser left
[06:10] *** alc left
[06:10] *** azawawi left
[06:21] *** xuser joined
[06:28] *** alanhaggai_ joined
[06:41] *** alech joined
[06:44] *** alanhaggai left
[06:50] <pugs_svn> r24572 | hinrik++ | [util/perl6.vim] prevent non-function/method keywords from highlighting when followed by parens, fix nesting of multiline comments with long delimiters, some interpolation fixes, support Q//, q//, qq//, etc (no heredocs yet)

[06:53] *** alanhaggai_ left
[06:59] *** justatheory joined
[06:59] <pugs_svn> r24573 | hinrik++ | [util/perl6.vim] fix for escaped closing delimiters in some strings

[07:07] *** masak left
[07:09] *** adc_penner joined
[07:09] *** alc joined
[07:15] <pugs_svn> r24574 | hinrik++ | [util/perl6.vim] compress the list of routines into fewer lines

[07:17] *** redicaps1 joined
[07:23] <pugs_svn> r24575 | hinrik++ | [util/perl6.vim] add missing comma, oops

[07:24] <pugs_svn> r24576 | hinrik++ | [util/perl6.vim] add another keyword

[07:29] *** justatheory left
[07:33] *** bacek__ left
[07:37] *** justatheory joined
[07:52] *** alester_ left
[08:00] <pugs_svn> r24577 | zev++ | typo in test description

[08:04] *** iblechbot joined
[08:06] *** redicaps1 left
[08:10] <pugs_svn> r24578 | hinrik++ | [util/perl6.vim] correct a wrongly escaped double quote

[08:12] <pugs_svn> r24579 | hinrik++ | [util/perl6.vim] allow pipe a string delimiter

[08:13] <literal> rakudo: my $str = q$a test$; $str.perl

[08:13] <p6eval> rakudo 34268: RESULT«"\"a test\""»

[08:16] *** maerzhase joined
[08:24] *** alech left
[08:28] *** alexn_org joined
[08:31] *** DemoFreak joined
[08:35] *** alexn_org left
[08:55] *** barney joined
[09:09] *** c9s_ is now known as c9s

[09:12] *** alech joined
[09:17] *** adc_penner left
[09:23] *** sail0r_ joined
[09:23] *** alc left
[09:27] *** ChrisDavaz left
[09:42] *** donaldh joined
[09:43] *** rgrau joined
[09:53] *** alech_ joined
[09:54] *** alech left
[10:01] *** clintongormley joined
[10:09] *** clintongormley left
[10:10] *** maerzhase left
[10:12] *** alech_ left
[10:13] *** alech joined
[10:17] *** clintongormley joined
[10:33] *** alech left
[10:33] *** alech joined
[10:34] *** maerzhase joined
[10:35] *** ejs joined
[10:51] *** alech left
[10:51] *** alech joined
[11:03] *** justatheory left
[11:13] *** alech_ joined
[11:14] *** ruoso joined
[11:15] *** pmurias joined
[11:17] *** alech left
[11:17] *** alech_ left
[11:20] <pugs_svn> r24580 | pmurias++ | [smop] added p5interpreterer.ri which is exposed in the lexical prelude as P5Interpreter which currently can only eval p5 code as strings

[11:20] <pugs_svn> r24580 | pmurias++ | the build system does nastyish stuff to link in libperl

[11:21] <pmurias> ruoso: hi

[11:21] <ruoso> hi pugs_svn 

[11:21] <ruoso> oops

[11:21] <pmurias> heh

[11:21] <ruoso> hi pmurias 

[11:22] <ruoso> it seems you're doing a lot of work :)

[11:22] <pmurias> the output from eval_pv disappears when stdin is redirected to a file

[11:22] <pmurias> any ideas what causes this

[11:22] <pmurias> ?

[11:24] <ruoso> you mean stdin fed from a file

[11:24] <ruoso> or stdout redirected to a file

[11:24] <ruoso> ?

[11:24] <pmurias> sorry stdout

[11:24] <ruoso> it's probably because of buffering

[11:25] <pmurias> ruoso: it's ok that i change the build system to scons?

[11:25] <ruoso> conceptually, yes... 

[11:26] <ruoso> but i'm not being able to build it

[11:26] <pmurias> that not good

[11:26] <ruoso> it tries to find libsmop while building smop

[11:26] <ruoso> when it runs X

[11:27] <ruoso> (wth is X?)

[11:27] <pmurias> m0ld_exe

[11:27] * pmurias changes the name

[11:27] <ruoso> oh right...

[11:27] <ruoso> call it just m0ld

[11:28] <ruoso> (ok, there's a directory with that name...

[11:34] *** maerzhase left
[11:41] *** Lorn joined
[11:44] <pmurias> a ./Setup configure when typed from the shell works, when scons calls it doesn't :(

[11:45] <ruoso> hmm

[11:45] <ruoso> pmurias, you missed smop_p5.h

[11:47] <pugs_svn> r24581 | pmurias++ | [smop] added missing file

[11:53] *** maerzhase joined
[11:55] *** kisu_ joined
[11:57] <pugs_svn> r24582 | pmurias++ | [smop] fixed the build system

[11:57] <pugs_svn> r24582 | pmurias++ | m0ld is built by the Makefile as scons conflicts with ./Setup configure (why?)

[12:00] *** kisu left
[12:03] <pugs_svn> r24583 | ruoso++ | [smop] small fix in makefile

[12:03] <ruoso> valgrind and pcl don't get together nicely

[12:05] <ruoso> pmurias, btw... where was the leak?

[12:07] <pugs_svn> r24584 | pmurias++ | [smop] make also creats a m0ld_exe with a linked in SMOP for mildew

[12:07] <pugs_svn> r24584 | pmurias++ | [mildew] added (failing) t/p5.t

[12:07] <pugs_svn> r24585 | ruoso++ | [smop] fix test/04... it was returning null from SMOP_MESSAGE...;

[12:07] <pmurias> ruoso: 2 in not releasing molds

[12:08] <pmurias> the third one was in the native capture

[12:08] <ruoso> the last one surprised me

[12:10] *** alexn_org joined
[12:10] <ruoso> pmurias, I think I'm going to work on sanitizing the interpreter usage according to lowdoc/03

[12:10] <ruoso> actually, 02

[12:11] <ruoso> so we can implement exception handling

[12:12] <pmurias> doesn't 02 describe the current state?

[12:16] <pmurias> btw it might make sense to merge has_next/next/eval into eval

[12:35] <ruoso> pmurias, it describe how we already think it should be

[12:35] <ruoso> but not every continuation has .back being set all the time

[12:35] <ruoso> and none of them has .control and .catch

[12:36] <pmurias> continuations should have a .clone method if we want to support continuations

[12:36] <ruoso> that would be cool

[12:36] <pmurias> the continuations we currently have are really coroutines

[12:37] <ruoso> well... the definition for "continuation" is not that strict

[12:37] <ruoso> but I see what you mean

[12:37] <ruoso> it is still a continuation, even if it can only be invoked once

[12:38] <ruoso> but at least mold can be cloned easily

[12:41] <pmurias> got any solutions for making pcl valgrind clean?

[12:44] *** ChrisDavaz joined
[12:53] <ruoso> pmurias, I don't think it can be

[12:53] <ruoso> it messes with the things valgrind is trying to take account of

[13:09] *** donaldh left
[13:10] *** alester_ joined
[13:24] *** sail0r joined
[13:25] *** alester_ left
[13:33] *** sail0r_ left
[13:34] <pugs_svn> r24586 | pmurias++ | [mildew] t/p5.t sets autoput outflush

[13:41] *** bacek left
[13:42] <pmurias> ruoso: i'll move test 37 to TODO

[13:50] *** alester_ joined
[13:52] *** justatheory joined
[13:55] *** meppl joined
[13:57] *** ejs1 joined
[13:59] *** alester_ left
[14:02] <ruoso> pmurias, ok

[14:04] <ruoso> mildew: ::P5Interpreter.new().eval("$|=1; print qq(pmurias++\n) for 1..5");

[14:04] <p6eval> mildew: OUTPUT«--exec use ./Setup configure --user --flags=SMOP␤»

[14:05] <ruoso> meh

[14:05] <ruoso> pmurias, how hard you think it would be to make a m0ld compiler in p5 and using SMOP XS?

[14:05] *** alexn_org left
[14:07] <pmurias> ruoso: you want to drop the haskell dependency?

[14:07] *** ejs left
[14:07] <ruoso> well, we already depend on p5, if it's not too hard, it would be nice...

[14:08] <ruoso> and it would have the advantage that it could only "require SMOP" when trying to exec

[14:09] <ruoso> and thus avoiding the circularity between m0ld and libsmop

[14:12] <ruoso> pmurias, we could even write the m0ld  grammar in Perl 6 ;)

[14:12] <pmurias> ruoso: how do you intend to run the Perl 6 grammar

[14:12] <pmurias> ?

[14:14] <ruoso> the same way STD runs

[14:14] <pmurias> it's a bit frail

[14:15] <pmurias> i went that way with sm0p and it broke a couple of times

[14:15] <ruoso> but I think Parse::RecDescent would be enough to parse m0ld

[14:16] <pugs_svn> r24587 | pmurias++ | [smop]

[14:16] <pugs_svn> r24587 | pmurias++ | moved old tests to test/old

[14:16] <pugs_svn> r24587 | pmurias++ | test 37 to test/TODO

[14:16] <pugs_svn> r24587 | pmurias++ | tests to be compiled are specified using a glob instead of a hardcoded list

[14:19] *** vixey joined
[14:22] <pmurias> the circularity could be avoided even without a rewrite of the m0ld compiler

[14:25] <pmurias> rewritting something in a uglier way is not very fun so i think it's only worth trying to get rid of the dependency if it's a problem for people 

[14:25] <pmurias> ruoso: btw the new Makefile automaticly creates a --flags=SMOP m0ld

[14:26] <pmurias> mildew: $OUT.print("Hello")

[14:26] <p6eval> mildew: OUTPUT«--exec use ./Setup configure --user --flags=SMOP␤»

[14:26] <pmurias> moritz_: ping

[14:28] *** neenaoffline joined
[14:29] *** donaldh joined
[14:30] <zev> ... 8 hours is quite a delay for mail delivery

[14:36] <neenaoffline> can I report a bug in parrot here?

[14:37] <neenaoffline> cause the parrotcode trac doesn't let new users create new tickets, and #parrot has 3 users

[14:37] <ruoso> neenaoffline, a parrot bug or a rakudo bug?

[14:37] <ruoso> neenaoffline, try #parrot@irc.perl.org

[14:37] <PerlJam> neenaoffline: try #parrot on irc.perl.org

[14:38] <PerlJam> neenaoffline: What's the bug?

[14:45] *** jhorwitz joined
[14:45] *** spx2 joined
[14:46] <pmurias> my_perl is assumed by perl5 macros to store the perl interpreter?

[14:50] <pmurias> ruoso: why do we use a _struct suffix instead of not defining a typedef?

[14:50] <ruoso> we do define typedefs

[14:55] <neenaoffline> PerlJam: it's kinda old, not sure if it still exists, but 

[14:56] <neenaoffline> and I don't think it's SCOK

[14:57] <neenaoffline> "This is parrot version 0.8.0 built for i386-linux. "

[14:57] <neenaoffline> so, I am guessing it's fixed.

[14:57] <PerlJam> maybe

[14:57] <PerlJam> run against parrot 0.8.2

[14:57] *** alester is now known as jayswife

[14:58] *** jayswife is now known as alester

[14:58] *** alech joined
[14:58] <neenaoffline> I'm not running anything, I was just poking around the .pasm / .pir files when I found that

[15:06] *** alc joined
[15:08] *** alech_ joined
[15:08] *** alech left
[15:09] *** sail0r left
[15:11] *** alanhaggai joined
[15:13] *** eric256 joined
[15:23] <eric256> rakudo:  6 710

[15:23] <p6eval> rakudo 34275: OUTPUT«Statement not terminated properly at line 1, near "710"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[15:23] *** alech_ left
[15:23] *** alanhaggai left
[15:23] <eric256> rakudo: (<1 2 3> X~X <a b c>).say

[15:23] <p6eval> rakudo 34275: OUTPUT«1a1b1c2a2b2c3a3b3c␤»

[15:23] <eric256> helps to get the right clip board ;)

[15:23] <eric256> rakudo: (<1 2 3> X~X <a b c>).join.say

[15:23] <p6eval> rakudo 34275: OUTPUT«1a 1b 1c 2a 2b 2c 3a 3b 3c␤»

[15:29] *** ejs1 left
[15:30] <rakudo_svn> r34276 | pmichaud++ | [rakudo]: spectest-progress.csv update: 264 files, 5833 passing, 0 failing

[15:33] <pugs_svn> r24588 | pmurias++ | [smop]

[15:33] <pugs_svn> r24588 | pmurias++ | P5Interpreter.eval returns a wrapped SV*

[15:33] <pugs_svn> r24588 | pmurias++ | .Str on a wrapped SV* returns a idconst

[15:35] <ruoso> pmurias++ # this p5 interation is awesome

[15:35] *** spx2 left
[15:37] *** donaldh left
[15:37] *** kisu_ left
[15:38] <clkao> 不是應該超過 4100 才空?

[15:39] *** kisu_ joined
[15:40] <pmurias> clkao: ?

[15:45] <eric256> Interation?

[15:46] <ruoso> er... bad translation from portuguese

[15:46] <eric256> ohhh lol i thought it was some new thing ;)

[15:47] <ruoso> the correct word would be interaction

[15:47] *** alanhaggai joined
[15:50] <clkao> sorry, must be weird irssi history or mispaste

[15:51] * eric256 tries to figure out how he has no writing utencils at his work desk

[16:06] *** kisu_ is now known as kisu

[16:14] *** masak joined
[16:17] *** donaldh joined
[16:22] <ruoso> eric256, don't you have a keyboard?

[16:22] <masak> keyboards are notoriously bad at leaving writing marks on paper, however.

[16:23] <BinGOs> 'writing', yes. leaving marks, depends how hard you hit the paper with the keyboard.

[16:23] *** alc left
[16:24] <masak> I wouldn't call that modus operandi optimal.

[16:24] <BinGOs> >>:)

[16:25] *** alanhaggai_ joined
[16:26] <ruoso> masak, he didn't say the media where he wanted to write on...

[16:27] *** pdcawley joined
[16:30] *** alech joined
[16:31] <eric256> yea i do mostly IM and email so i often have a hard time finding pens

[16:31] <eric256> now if i could just get a scanner that worked with linux i could get rid of all this frakin paper ;)

[16:32] <hudnix_> get a digital camera.

[16:32] * ruoso has been using digital cameras as scanners for some time already...

[16:33] <ruoso> eric256, most HP scanners work on linux

[16:36] *** alech left
[16:36] *** maerzhase left
[16:39] <eric256> ruoso: yea i found one that worked, but it was huge. one of these days

[16:40] <masak> bad pen day.

[16:41] <masak> rakudo: +*

[16:41] <p6eval> rakudo 34276: OUTPUT«Null PMC access in get_number()␤current instr.: 'parrot;Whatever;' pc 8525 (src/classes/Whatever.pir:41)␤»

[16:41] * masak cackles evilly

[16:41] * masak submits rakudobug

[16:42] *** alanhaggai left
[16:45] *** alanhaggai__ joined
[16:55] *** mberends joined
[16:58] <masak> I don't think I've ever submitted a rakudobug using a two-char program before.

[16:59] <ruoso> (rakudobug golf)++

[16:59] <ruoso> ;)

[16:59] <masak> :D

[17:00] <eric256> you are insane masak

[17:00] * eric256 things the compile should be programmed to reply "Bad masak" whenever that code is executed

[17:01] <masak> eric256: thanks to my insanity, Rakudo is a lot more stable today than it would otherwise have been.

[17:02] <eric256> i do'nt doubt that

[17:02] <masak> every day I try to think of new ways to bring Rakudo to its knees.

[17:02] <masak> (but only because I care, of course)

[17:03] *** alanhaggai_ left
[17:04] <masak> rakudo: say 'foo' ~ (0..999).pick

[17:04] <p6eval> rakudo 34276: OUTPUT«foo148␤»

[17:05] <masak> rakudo: say ('foo' ~ (0..999).pick).()

[17:05] <p6eval> rakudo 34276: OUTPUT«invoke() not implemented in class 'String'␤current instr.: '_block14' pc 102 (EVAL_15:45)␤»

[17:05] <masak> hm.

[17:06] <masak> I was planning on creating 1000 subroutines named "foo$n" using eval and a for loop, and then executing one of them randomly.

[17:06] <masak> but it seems that I cannot call methods that way.

[17:06] <masak> rakudo: eval 'foo' ~ (0..999).pick ~ '()'

[17:06] * eric256 thanks the perl6 gods

[17:06] <p6eval> rakudo 34276: RESULT«Null PMC access in find_method()␤current instr.: '_block14' pc 64 (EVAL_15:39)␤»

[17:07] <masak> that shouldn't happen.

[17:07] <masak> rakudo: foo148()

[17:07] <p6eval> rakudo 34276: OUTPUT«Could not find non-existent sub foo148␤current instr.: '_block14' pc 48 (EVAL_13:36)␤»

[17:07] <eric256> rakudo: sub foo1 { say "hello" }; eval 'foo' ~ (1).pick ~ '()';

[17:07] <p6eval> rakudo 34276: OUTPUT«hello␤»

[17:07] <eric256> rakudo: sub foo1 { say "hello" }; eval 'foo' ~ (1,2).pick ~ '()';

[17:07] <p6eval> rakudo 34276: OUTPUT«hello␤»

[17:07] <eric256> rakudo: sub foo1 { say "hello" }; eval 'foo' ~ (1,2).pick ~ '()';

[17:07] <p6eval> rakudo 34276: RESULT«Null PMC access in find_method()␤current instr.: '_block14' pc 64 (EVAL_13:39)␤»

[17:08] <eric256> rakudo: eval 'foo()';

[17:08] <p6eval> rakudo 34276: RESULT«Null PMC access in find_method()␤current instr.: '_block14' pc 64 (EVAL_13:39)␤»

[17:09] <masak> rakudo: eval 'sub foo'~$_~' { say "OH HAI" }' for 0..999; eval 'foo' ~ (0..999).pick ~ '()'

[17:09] <masak> here we go.

[17:09] <p6eval> rakudo 34276: No output (you need to produce output to STDOUT)

[17:09] <masak> bah. timeout.

[17:09] <masak> rakudo: eval 'sub foo'~$_~' { say "OH HAI" }' for 0..99; eval 'foo' ~ (0..99).pick ~ '()'

[17:10] <eric256> rakudo: eval "sub foo$_ { say 'OH HAI $_' }" for 0..9; eval 'foo' ~ (0..9).pick ~ '()'

[17:10] <eric256> opps

[17:10] <masak> :)

[17:10] <p6eval> rakudo 34276: No output (you need to produce output to STDOUT)

[17:10] <p6eval> rakudo 34276: OUTPUT«OH HAI $_␤OH HAI $_␤OH HAI $_␤OH HAI $_␤OH HAI $_␤OH HAI $_␤OH HAI $_␤OH HAI $_␤OH HAI $_␤OH HAI $_␤»

[17:10] <eric256> well that was...unexpected

[17:10] <masak> eric256: you just made the same mistake I made yesterday in a bug report :)

[17:10] <eric256> oh?

[17:10] <masak> eric256: no, actually not.

[17:11] <masak> as TimToady++ explained.

[17:11] <eric256> oh wait the { } interpolated it huh

[17:11] <eric256> rakudo: eval "sub foo$_ \{ say 'OH HAI $_' \}" for 0..9; eval 'foo' ~ (0..9).pick ~ '()'

[17:11] <p6eval> rakudo 34276: OUTPUT«OH HAI 7␤»

[17:11] <masak> a block in a double-quoted string is executed immediately -- yes.

[17:11] <ruoso> rakudo: MY::{"foo$_ "} := { say "OH $_" } for 0..99; MY::{"foo"~(0..99).pick}.(); 

[17:11] <p6eval> rakudo 34276: OUTPUT«Statement not terminated properly at line 1, near "::{\"foo$_ "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[17:11] <ruoso> std: MY::{"foo$_ "} := { say "OH $_" } for 0..99; MY::{"foo"~(0..99).pick}.(); 

[17:11] <PerlJam> That seems like it's going to catch alot of people initially.

[17:11] <p6eval> std 24588: OUTPUT«00:07 86m␤»

[17:12] <masak> PerlJam: maybe one could have a warning for {} in "" in eval args.

[17:12] <eric256> PerlJam: i dunno, maybe, but mostly people doing stuff like generating functions. it was fairly obvious after a few seconds thought...just so un perl5 

[17:12] <ruoso> rakudo: module Foo; Foo::{"foo$_ "} := { say "OH $_" } for 0..99; Foo::{"foo"~(0..99).pick}.(); 

[17:12] <p6eval> rakudo 34276: OUTPUT«Statement not terminated properly at line 1, near "::{\"foo$_ "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[17:12] <ruoso> std: module Foo; Foo::{"foo$_ "} := { say "OH $_" } for 0..99; Foo::{"foo"~(0..99).pick}.(); 

[17:12] <p6eval> std 24588: OUTPUT«00:07 86m␤»

[17:13] <PerlJam> eric256: sure ... many things are "obvious" once you're in the proper mindframe  :)

[17:13] <ruoso> std: module Foo; Foo::{"&foo$_ "} := { say "OH $_" } for 0..99; Foo::{"&foo"~(0..99).pick}.(); 

[17:13] <eric256> what kind of output was that?

[17:13] <p6eval> std 24588: OUTPUT«00:07 87m␤»

[17:13] <ruoso> but that might interpolate, I think...

[17:14] <ruoso> std: module Foo; Foo::{'&foo'~$_} := { say "OH $_" } for 0..99; Foo::{'&foo'~(0..99).pick}.(); 

[17:14] <p6eval> std 24588: OUTPUT«00:07 87m␤»

[17:14] <ruoso> pugs: module Foo; Foo::{'&foo'~$_} := { say "OH $_" } for 0..99; Foo::{'&foo'~(0..99).pick}.(); 

[17:14] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "Foo"␤    expecting ";", Doc block, block declaration, declaration, construct or expression␤    at /tmp/PFdxOxvMYK line 1, column 13␤»

[17:14] <eric256> PerlJam: true

[17:14] *** alanhaggai__ left
[17:14] *** alanhaggai__ joined
[17:14] <ruoso> masak, btw... rakudo doesn't yet support package lookup, it seems... but the code above was supposed to do what you mean

[17:15] <ruoso> pugs: MY::{'&foo'~$_} := { say "OH $_" } for 0..99; MY::{'&foo'~(0..99).pick}.(); 

[17:15] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "MY"␤    expecting program␤    at /tmp/hE7XyV5LMr line 1, column 1␤»

[17:15] <masak> ruoso: aye.

[17:16] <masak> arguably in a purer way than mine.

[17:16] * eric256 rolls out jabber IM to his company and crosses his fingers

[17:16] <ruoso> masak, I don't know how far in the rakudo ROADMAP is package lookup 

[17:17] <ruoso> but it might deserve a request...

[17:18] <masak> it might deserve a TODO rakudobug

[17:18] <ruoso> even if not for the MY:: pseudo-package

[17:18] <ruoso> doing normal package lookup is already an interesting feature

[17:19] *** adc_penner joined
[17:31] *** Chillance joined
[17:31] *** azawawi joined
[17:32] <azawawi> hi

[17:32] <pmurias> ruoso: adding stuff to a lexical scope at runtime is not allowed

[17:32] <pmurias> azawawi: hi

[17:32] <masak> azawawi: hi

[17:32] *** rgrau left
[17:32] *** masak left
[17:33] <pmurias> mildew: say "hi"

[17:33] <p6eval> mildew: OUTPUT«--exec use ./Setup configure --user --flags=SMOP␤»

[17:33] * azawawi thinks about Padre::Plugin::Mildew ;-)

[17:41] <pmurias> that would be nice

[17:41] <pmurias> i would have to fix Padre::Plugin::Vi to make padre a decent editor than ;)

[17:43] *** xinming joined
[17:47] <ruoso> pmurias, is it really forbidden?

[17:48] <azawawi> pmurias: maybe i could help with the Padre Vi plugin support

[17:49] <azawawi> pmurias: and btw i tested --snippet-html mode and it works in various blogging websites that allow you to put HTML.

[17:51] <pmurias> ruoso: S11:175

[17:52] <pmichaud> also S02:1821

[17:53] *** rserrano2009 joined
[17:54] <ruoso> right... but the non-pseudo-package lookup still works 

[17:54] <ruoso> (and I do think a pragma could allow modifying MY::)

[17:55] *** alech joined
[17:55] <ruoso> ah... you're allowed to modify MY::

[17:55] <ruoso> you just can't ADD a new symbol

[17:55] <ruoso> that makes more sense

[17:56] <pmurias> azawawi: the Padre::Plugin::Vi has hardcode vi commands like 'dw' instead of understanding the general command + object form, it's not a hard thing to fix, it's just that padre doesn't have enough cool features for me to get round to switching to it

[17:57] * ruoso is always tempted to try Padre, but never have the time to actually doing it

[17:57] *** xinming_ left
[17:57] *** pmurias left
[17:59] <PerlJam> ruoso: I tried one of the earlier versions and it shows great promise.

[17:59] <rserrano2009> hi, speak spanish channel about perl ??

[17:59] *** dwhipp joined
[18:00] <rserrano2009> sorry but my inglish is very bad

[18:00] <PerlJam> rserrano2009: This channel is about perl 6.  You likely want #perl or #perlhelp

[18:00] <rserrano2009> thank you PerlJam

[18:00] *** neenaoffline left
[18:01] *** rserrano2009 left
[18:03] *** Whiteknight joined
[18:03] <dwhipp> what happenned to implicit $_? I tried "say for @x" (on rakudo) and got +@n blank lines -- looking at the spec, it says it should be a compiler error.

[18:06] *** alech left
[18:06] *** alech joined
[18:06] <mberends> rakudo: my @x=<P E R L>; .say for @x;

[18:06] <p6eval> rakudo 34276: OUTPUT«P␤E␤R␤L␤»

[18:07] *** jferrero joined
[18:07] *** alanhaggai joined
[18:08] <ruoso> dwhipp, the implicit $_ is still there, it's say that no longer tries to look at it

[18:08] <dwhipp> OK so the latest rakudo looks good -- I'll make sure I'm up to date.

[18:08] <ruoso> you have some alternatives...

[18:08] <ruoso> the first is what mberends tried above

[18:08] <ruoso> but you still have:

[18:09] <ruoso> rakudo: my @x = <P e r l 6>; { $^a.say } for @x

[18:09] <p6eval> rakudo 34276: OUTPUT«P␤e␤r␤l␤6␤»

[18:09] <dwhipp> ah! missed the "dot" -- need to use method calls to use implicit $_

[18:10] <ruoso> rakudo: my @x = <P e r l 6>; $^a.say for @x; # I'm not sure you're allowed to do that without the block

[18:10] <p6eval> rakudo 34276: OUTPUT«too few arguments passed (0) - 1 params expected␤current instr.: '_block14' pc 35 (EVAL_11:26)␤»

[18:10] <ruoso> rakudo: my @x = <P e r l 6>; -> $it { $it.say } for @x

[18:10] <p6eval> rakudo 34276: OUTPUT«Syntax error at line 1, near "-> $it { $"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[18:10] <ruoso> rakudo: my @x = <P e r l 6>;  for @x -> $it { $it.say }

[18:10] <p6eval> rakudo 34276: OUTPUT«P␤e␤r␤l␤6␤»

[18:11] *** alech left
[18:13] *** alech joined
[18:13] <ruoso> is it sane to assume that ReturnControlException is a prototype that is closed and final?

[18:14] <ruoso> meaning that you can't subclass it, nor compose roles into it...

[18:14] <ruoso> this would be important because it would mean we can make it as a native type in SMOP

[18:15] <ruoso> (that is, allows pointer comparison of the ResponderInterface

[18:19] <ruoso> @tell pmurias do you think we could have a "leave" operator in mold? This operator would call setr on the back with the given register and goto the back frame...

[18:19] <lambdabot> Consider it noted.

[18:19] *** dmq left
[18:19] *** BinGOs left
[18:19] *** BinGOs joined
[18:22] *** alanhaggai__ left
[18:24] <ruoso> is there any glance on what is the name of the function that raises control exceptions?

[18:24] <ruoso> I presume fail() is only going to raise failures

[18:24] <ruoso> i was thinking that raise() is a good name

[18:33] <TimToady> might want to dehuffmanize it a bit more than that, if users rarely see it

[18:34] *** apeiron left
[18:35] *** apeiron joined
[18:37] *** gbacon left
[18:38] <azawawi> TimToady: 206 lines/sec for STD.pm parsing speed so far ;-)

[18:38] *** Psyche^ joined
[18:38] <TimToady> we'll get it going faster eventually...

[18:38] <TimToady> biab &

[18:39] <eric256> do you raise an exception object?  i.e.  Exception::ReadOnly.raise("This file is read only.")

[18:39] * eric256 looks for a synopsis on exceptions

[18:39] * azawawi Padre 0.22 coming soon...

[18:40] <dwhipp> rakudo: my @a = <7 5 7 7 13>; say ((( @a X-X @a ).grep: { $_ == 0 }).elems - @a.elems)/2

[18:40] <p6eval> rakudo 34277: OUTPUT«3␤»

[18:40] <pmichaud> dwhipp: that scares me.

[18:40] <dwhipp> That's an answer to the first "winter scipting games" challenge

[18:41] <eric256> indeed it is

[18:41] <dwhipp> problem is, "X-X" does the full cross-product, not justhte diagonal halves

[18:41] <pmichaud> please please please post (and explain) it somewhere.  :-)

[18:42] <eric256> i was going to use a cross but couldn't decide what to do about matching itself, yours is good, albeit scary

[18:42] <dwhipp> explaination -- "@x X-X @x " is zero for all elems that are pairs

[18:42] <dwhipp> then I count them

[18:42] *** gbacon joined
[18:42] <eric256> i think he meant somwhere else ;)

[18:42] <dwhipp> but I need to adjust the count to remove the diagonal and the repeats

[18:43] <eric256> hence the /2 right?

[18:43] <eric256> oh wait i get it, /2 is for both halves of the pair, -@.elems is for the pairs that are themselves

[18:43] <dwhipp> - @a.elems gets rid of the diagonal

[18:43] <pmichaud> yes, I meant post and explain somewhere else.  So others can see the awesome beauty and power that is Perl 6.  :-)

[18:44] <dwhipp> Perhaps "beauty", yes. But to my mind it shows that the cross operator is too limited for true elegance

[18:44] <eric256> is there anyway to get all the elements in an array that arn't the current one? hmm  @a(*..^$i^..*) ?

[18:44] <clintongormley> heh pmichaud, you're sounding like the genie in Aladdin

[18:45] <clintongormley> AWESOME POWER

[18:45] <clintongormley> itty-bitty living space

[18:45] <eric256> dwhipp: when its done you'll be able to make your own infix opperators etc, so you could make a special cross product

[18:45] <pmichaud> clintongormley: yes, I was channeling the genie when I wrote that.

[18:45] <pmichaud> "AWESOME POWER of Perl 6, in itty bitty pieces of code!"

[18:46] <clintongormley> :D

[18:46] <clintongormley> and more power to you

[18:46] <pmichaud> and yes, it might show that the cross operator is too limited, or that we might find a nicer idiom for this

[18:46] <ruoso> dwhipp, I couldn't find the proposed challenge, have a link?

[18:47] <dwhipp> http://www.microsoft.com/technet/scriptcenter/funzone/games/games08/bevent1.mspx

[18:50] *** maerzhase joined
[18:50] *** Patterner left
[18:50] *** Psyche^ is now known as Patterner

[18:51] <dwhipp> If X,X is the full cross product, then what would be the diagonal cross ... Y,Y or  Z,Z perhaps

[18:52] <dwhipp> I'm trying to figure out, specwise. how to express/define such a metaoperator in pure P6

[18:53] <ruoso> isn't there a math symbol for that?

[18:56] <pugs_svn> r24589 | azawawi++ | [Syntax::Highlight::Perl6] Updating to the latest perl6.vim

[18:57] <ruoso> is X,X slice-aware?

[18:57] *** alech left
[18:57] <ruoso> my @a = (7 5 7 7 13); my @@b = @a X-X @a; say @@b[0;0];

[19:00] <ruoso> pugs: my @a = (7 5 7 7 13); my @@b = @a X-X @a; say @@b[0;0];

[19:00] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "@a"␤    expecting "=", operator, ")", context, ":" or "("␤    at /tmp/u6up7eCeCS line 1, column 4␤»

[19:00] <ruoso> pugs: my @a = (7, 5, 7, 7, 13); my @@b = @a X-X @a; say @@b[0;0];

[19:00] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ";"␤    expecting "x", octal digit, "o", "b", fraction, exponent, term postfix, operator or "]"␤    at /tmp/BiqEhg7BBR line 1, column 56␤»

[19:00] <ruoso> meh...

[19:03] <ruoso> I just wish someone had implemented slices...

[19:04] <ruoso> rakudo: my @a = (7, 5, 7, 7, 13); my @@b = @a X-X @a; say @@b[0;0];

[19:04] <p6eval> rakudo 34281: OUTPUT«Statement not terminated properly at line 1, near "@@b = @a X"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[19:04] <pmichaud> rakudo doesn't do slices yet, but we're closing in on it.

[19:04] <eric256> rakudo: my @a = (1..5); say @a[0..^0];

[19:04] <p6eval> rakudo 34281: OUTPUT«12345␤»

[19:05] <pugs_svn> r24590 | azawawi++ | [Syntax::Highlight::Perl6] Updated changes and ignoring generated files

[19:06] <pmichaud> eric256 found a rakudobug

[19:07] <eric256> i was trying to get the slice of everything but my element ;( lol

[19:11] <ruoso> eric256, you should be able to do...

[19:11] <ruoso> rakudo: my @a = (1..5); say @a[0..$^a,$^a..^@a] for (1..5);

[19:11] <p6eval> rakudo 34281: OUTPUT«too few arguments passed (0) - 1 params expected␤current instr.: '_block14' pc 35 (EVAL_14:26)␤»

[19:12] <ruoso> rakudo: my @a = (1..5); { say @a[0..$^a,$^a..^@a] } for (1..5);

[19:12] <p6eval> rakudo 34281: OUTPUT«122345␤123345␤123445␤123455␤12345Use of uninitialized value␤␤»

[19:12] <eric256> rakudo: my @a = (1..5); { say @a[0..^$^a,$^a^..^@a] } for (1..5);

[19:12] <p6eval> rakudo 34281: OUTPUT«1345␤1245␤1235␤1234␤12345␤»

[19:12] <eric256> its close

[19:12] <eric256> lol

[19:12] <ruoso>  rakudo: my @a = (1..5); { say @a[0..^$^a,$^a^..^@a] } for (0..4);

[19:12] <p6eval> rakudo 34281: OUTPUT«2345␤1345␤1245␤1235␤1234␤»

[19:13] <eric256> what? hey

[19:13] <eric256> lol

[19:13] <ruoso>  rakudo: my @a = (1..5); @a.map { say @a[0..^$^a,$^a^..^@a] };

[19:13] <p6eval> rakudo 34281: OUTPUT«Statement not terminated properly at line 1, near "{ say @a[0"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[19:13] <ruoso>  rakudo: my @a = (1..5); map @a, { say @a[0..^$^a,$^a^..^@a] };

[19:13] <p6eval> rakudo 34281: OUTPUT«No applicable methods.␤␤current instr.: '_block14' pc 108 (EVAL_14:50)␤»

[19:13] <eric256> rakudo: my @a = (1..5); my $i = 0; say @a[0..^$i];

[19:13] <p6eval> rakudo 34281: OUTPUT«12345␤»

[19:14] <eric256> i don't understand why that doesn't work, but your does

[19:14] <eric256> they seem the same (for element 0)

[19:14] <ruoso> that is a bug

[19:14] <eric256> okay so its treating $^a right and $i wrong

[19:15] *** aindilis` left
[19:15] <ruoso> rakudo: say 0..0

[19:15] <p6eval> rakudo 34281: OUTPUT«0␤»

[19:15] <ruoso> rakudo: say 0..^0

[19:15] <p6eval> rakudo 34281: OUTPUT«␤»

[19:15] <ruoso> rakudo: my $i = 0; say 0..^$1

[19:15] <ruoso> rakudo: my $i = 0; say 0..^$i

[19:15] <p6eval> rakudo 34281: OUTPUT«Use of uninitialized value␤␤»

[19:15] <p6eval> rakudo 34281: OUTPUT«␤»

[19:16] <ruoso> eric256, the thing is that @a[] returns all elements currently in rakudo (which I presume to be a bug)

[19:17] <pmichaud> @a[] returning all elements is correct.

[19:17] <lambdabot> Maybe you meant: arr ask

[19:17] <ruoso> ok then

[19:17] <pmichaud> @a[@b] returning all elements when @b is empty is a bug.

[19:17] <lambdabot> Unknown command, try @list

[19:17] <ruoso> ah.. ok

[19:17] <ruoso> sounds better

[19:17] <pmichaud> so, since 0..^0  produces an empty list, we're tickling the rakudobug.

[19:17] <pmichaud> in which it's returning all elements.

[19:21] <ruoso> rakudo: my @a = 7, 5, 7, 7, 13; say @a.grep({ $^a ~~ @a[0..$^a,$^a^..^@a] }).elems;

[19:21] <p6eval> rakudo 34283: OUTPUT«Non-dwimmy hyperoperator cannot be used on arrays of different sizes or dimensions.␤current instr.: 'die' pc 14760 (src/builtins/control.pir:188)␤»

[19:21] <ruoso> uh?

[19:21] <ruoso> rakudo: my @a = 7, 5, 7, 7, 13; say @a.grep({ $^a == any @a[0..$^a,$^a^..^@a] }).elems;

[19:21] <p6eval> rakudo 34283: OUTPUT«Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of

[19:21] <p6eval> ..uni...

[19:23] <TimToady> why are you comparing the index to array *values*?

[19:23] <ruoso> am I?

[19:24] <ruoso> ahhh

[19:24] <TimToady> @a[] does a lookup # shutup lambdabot

[19:24] <lambdabot> Maybe you meant: arr ask

[19:25] <ruoso> rakudo: my @a = 7, 5, 7, 7, 13; (0..^@a).map({ @a[$^a] == any @a[0..$^a,$^a^..^@a] }).elems;

[19:25] <p6eval> rakudo 34283: RESULT«5»

[19:25] <TimToady> oh, wait, you're feeding $^a with values too, nevermind

[19:25] <TimToady> but seems like you want to be working with indices, not values

[19:26] <ruoso> rakudo: say 1 == any (2,3,4)

[19:26] <p6eval> rakudo 34283: OUTPUT«Junction<0xb5f6a8ac>␤»

[19:26] <ruoso> rakudo: say (1 == any (2,3,4)).true

[19:26] <p6eval> rakudo 34283: OUTPUT«0␤»

[19:26] <zev> rakudo: say 1 ~~ any(2, 3, 4)

[19:26] <p6eval> rakudo 34283: OUTPUT«0␤»

[19:27] <TimToady> rakudo: say 1 ~~ any 2,3,4

[19:27] <p6eval> rakudo 34283: OUTPUT«0␤»

[19:27] <ruoso> rakudo: my @a = 7, 5, 7, 7, 13; (0..^@a).grep({ @a[$^a] == any @a[0..$^a,$^a^..^@a] }).elems;

[19:27] <p6eval> rakudo 34283: RESULT«5»

[19:28] <ruoso> rakudo: my @a = 7, 5, 7, 7, 13; (0..^@a).grep({ say @a[0..$^a,$^a^..^@a] }).elems;

[19:28] <p6eval> rakudo 34283: OUTPUT«757713␤757713␤757713␤757713␤757713␤»

[19:28] <TimToady> $_ is a 33% shorter than $^a

[19:28] <ruoso> rakudo: my @a = 7, 5, 7, 7, 13; (0..^@a).grep({ @a[$^a] == any @a[0..^$^a,$^a^..^@a] }).elems;

[19:29] <p6eval> rakudo 34283: RESULT«3»

[19:29] *** Aisling left
[19:29] <ruoso> rakudo: my @a = 7, 5, 7, 7, 13; (0..^@a).grep({ @a[$_] == any @a[0..^$_,$_^..^@a] }).elems;

[19:29] <p6eval> rakudo 34283: RESULT«3»

[19:29] <ruoso> dwhipp, ^

[19:31] *** clintongormley left
[19:39] <ruoso> it's interesting that two features make all the difference in the above code

[19:39] <ruoso> the first being junctions, which make the comparison much cleaner

[19:39] <ruoso> and the second is the new range constructor syntax

[19:40] <ruoso> besides that, the code isn't that different from what I would do in p5

[19:43] <ruoso> rakudo: say 1 ~~ (1,2,3)

[19:43] <p6eval> rakudo 34283: OUTPUT«Non-dwimmy hyperoperator cannot be used on arrays of different sizes or dimensions.␤current instr.: 'die' pc 14760 (src/builtins/control.pir:188)␤»

[19:43] <ruoso> pugs: say 1 ~~ (1,2,3)

[19:43] <p6eval> pugs: OUTPUT«␤»

[19:44] <dwhipp> I like the junctions approach, but I just know that "people" will complain about the line-noise with all those range constructors.

[19:44] <ruoso> just put spaces around it ;)

[19:44] <dwhipp> I've been playing a little, and I think I'd like to be able to code it as: "say ((@x %==% @x).grep: { $^same }).elems"

[19:44] <ruoso> rakudo: my @a = 7, 5, 7, 7, 13; (0..^@a).grep({ @a[$_] == any @a[  0 ..^ $_  ,   $_  ^..^  @a] }).elems;

[19:45] <p6eval> rakudo 34283: RESULT«3»

[19:45] <dwhipp> Also, I did a quick writeup at http://use.perl.org/~dpuu/journal/

[19:48] *** simcop2387 left
[19:50] <pmichaud> dwhipp ++

[19:50] <pmichaud> dwhipp++

[19:51] <pmichaud> (get that postfix in the right spot :-)

[19:51] <TimToady> $_ if $_ != $^x for 0..^@a

[19:51] <szabgab> Padre now supports Perl6 highlighting  using STD thanks to azawawi 

[19:53] <ruoso> TimToady, rakudo currently only support $^x if you put a explicit block 

[19:53] <ruoso> and it really makes sense, because where would $x be declared otherwise?

[19:53] <dwhipp> I think the junctional version is doing too much work: it's comparing the current element againt both halves of the diagonal:

[19:54] <ruoso> is it?

[19:54] <dwhipp> rakud: my @a = < 7 5 7 7 13 >; (^@a).grep({ @a[$_] == any @a[  $_ ^..^ @a] }).elems;

[19:54] <dwhipp> rakudo: my @a = < 7 5 7 7 13 >; (^@a).grep({ @a[$_] == any @a[  $_ ^..^ @a] }).elems;

[19:54] <p6eval> rakudo 34283: RESULT«3»

[19:54] <ruoso> ah... I see what you mean

[19:54] <ruoso> that's even better

[19:55] <dwhipp> rakudo: my @a = < 1 2 2 3 4 4 5 >; (^@a).grep({ @a[$_] == any @a[  $_ ^..^ @a] }).elems;

[19:55] <p6eval> rakudo 34283: RESULT«3»

[19:55] <dwhipp> but that's the wrong answer :-(

[19:55] <ruoso> rakudo: my @a = 1, 2, 2, 3, 4, 4, 5; (0..^@a).grep({ @a[$_] == any @a[  0 ..^ $_  ,   $_  ^..^  @a] }).elems;

[19:55] <p6eval> rakudo 34283: RESULT«4»

[19:56] <dwhipp> correct answer is 2!

[19:57] <ruoso> is it?

[19:58] <dwhipp> I see only two pairs!

[19:58] <dwhipp> and if we need to divide by two, then the earlier answer would become wrong

[19:58] <ruoso> well, in that case I see only 2 pairs in <7 5 7 7 13>  too

[19:58] <ruoso> it's counting the number of cards that have a pair

[20:00] <ruoso> hmm...

[20:00] <ruoso> ok... 

[20:00] <ruoso> dwhipp, you're right...

[20:00] <dwhipp> re-reading the original challenge, it suggests not

[20:01] <dwhipp> (my reply was to your original, not to you're statement that I was correct :-) )

[20:03] <ruoso> so it really requires a cross operation

[20:09] *** pmurias joined
[20:10] <dwhipp> my @a = < 1 2 2 3 4 4 4 5  >; say (0 .. @a-2).grep({ @a[$_] == any @a[  $_+1 .. @a-1] }).elems

[20:10] <dwhipp> rakudo: my @a = < 1 2 2 3 4 4 4 5  >; say (0 .. @a-2).grep({ @a[$_] == any @a[  $_+1 .. @a-1] }).elems

[20:10] <p6eval> rakudo 34283: OUTPUT«3␤»

[20:11] <dwhipp> this gives the correct result for hte "count number of cards that have subsequent partners" question

[20:12] <dwhipp> but we need the overall range to be "0 .. @a-2", not "0..@a-1"

[20:12] <dwhipp> so ^@a doesn't work as a range in this context

[20:12] <ruoso> maybe  0 ..^ @a.last makes it clearer

[20:13] <ruoso> 0 ..^ @a.end actually

[20:13] <dwhipp> is this an edge-case bug with junctional behavior -- or just a gotcha?

[20:13] <ruoso> what do you mean?

[20:14] <dwhipp> rakudo: 3 == any()

[20:14] <p6eval> rakudo 34283: RESULT«any()»

[20:14] <dwhipp> rakudo: ?(3 == any())

[20:14] <p6eval> rakudo 34283: RESULT«Bool::False»

[20:15] *** alanhaggai_ joined
[20:15] <ruoso> ah... but if you have @a[$x..$x], you're hitting the rakudobug

[20:15] <ruoso> because it was supposed to return an empty list, but it's returning the entire lits

[20:17] <dwhipp> OK, so once that's fixed the "(^@a).grep: {...}" should work. No need to figure out the exact range expression @a.end-1

[20:17] <eric256> could you just get the indexs that are not the current index? 

[20:17] <eric256> rakudo: say ( any(1..5) != 4)

[20:17] <p6eval> rakudo 34283: OUTPUT«Junction<0xb5f76bec>␤»

[20:17] <eric256> rakudo: say ( any(1..5) != 4).perl

[20:17] <p6eval> rakudo 34283: OUTPUT«any(Bool::True, Bool::False)␤»

[20:18] <eric256> rakudo: say ( any(1..5) != 4).values

[20:18] <p6eval> rakudo 34283: OUTPUT«Method 'values' not found for invocant of class 'Junction'␤current instr.: '_block14' pc 105 (EVAL_15:46)␤»

[20:18] *** dwhipp left
[20:18] <eric256> (1..5).map {$_ != 5};

[20:18] <eric256> rakudo: (1..5).map {$_ != 5};

[20:18] <p6eval> rakudo 34283: OUTPUT«Statement not terminated properly at line 1, near "{$_ != 5};"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[20:19] <eric256> rakudo: (1..5).map {$_ != 5;};

[20:19] <p6eval> rakudo 34283: OUTPUT«Statement not terminated properly at line 1, near "{$_ != 5;}"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[20:19] <eric256> rakudo: say( list(1..5).map {$_  <> 5 });

[20:19] <p6eval> rakudo 34283: OUTPUT«Statement not terminated properly at line 1, near "( list(1.."␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[20:19] <ruoso> rakudo: my @a = < 1 2 2 3 4 4 4 5  >; say (0 ..^ @a.end).grep({ @a[$_] == any @a[  $_ ^..^ @a] }).elems

[20:19] <p6eval> rakudo 34283: OUTPUT«3␤»

[20:19] <eric256> correct answer is 4 ;)

[20:20] <rakudo_svn> r34284 | coke++ | Eliminate [DEPRECATED] runtime/parrot/library/Parrot/Capture_PIR.pir

[20:20] <rakudo_svn> r34284 | coke++ | 

[20:20] <rakudo_svn> r34284 | coke++ | was only referenced by one language, but it wasn't being used.

[20:20] <eric256> the any doesn't match cause its returning 1 if there is 1 or more matches

[20:21] <eric256> you actualy want to count all the occurences of the same value after this one

[20:22] <ruoso> TimToady, I'm about to implement the raise of control exceptions, do you have any suggestion for the name of the function that will raise a control exception? since raise() looks too short for such low usage...

[20:26] <eric256> throw_the_freakin_exception_please() ;)

[20:29] *** barney left
[20:31] <eric256> rakudo:  my @cards = (1,2,2,3,4,4,4,5); my $pairs = 0; for @cards.kv -> $i, $v { say "$i -> $v: { @cards }"; say @cards[$i..5];}; 

[20:31] <p6eval> rakudo 34284: OUTPUT«0 -> 1: 1 2 2 3 4 4 4 5␤Undefined value shifted from empty range␤444441␤1 -> 2: 1 2 2 3 4 4 4 5␤Undefined value shifted from empty range␤44441␤2 -> 2: 1 2 2 3 4 4 4 5␤Undefined value shifted from empty range␤4441␤3 -> 3: 1 2 2 3 4 4 4 5␤Undefined value shifted from empty

[20:31] <p6eval> ..range␤44...

[20:31] <eric256> i don't understand why i keep getting the undefined values?  if i replace $i with a hard coded value it works fine

[20:33] *** alanhaggai left
[20:34] *** Aisling joined
[20:36] *** adc_penner left
[20:36] <TimToady> seems a little strange not to use throw when we're using CATCH...but that's the same length

[20:37] *** alech joined
[20:40] <TimToady> on the other hand, throw is not the opposite of CONTROL

[20:40] *** Aisling left
[20:40] <TimToady> obviously we should use KAOS

[20:41] *** unobe joined
[20:41] *** alech left
[20:43] *** alech joined
[20:44] <unobe> rakudo: my @x = <7 5 7 7 13>; (([+] (@x X==X @x)) - @x.elems)/2; 

[20:44] <p6eval> rakudo 34284: RESULT«3»

[20:44] <unobe> rakudo: my @x = <1 2 2 3 4 4 4 5>; (([+] (@x X==X @x)) - @x.elems)/2; 

[20:44] <p6eval> rakudo 34284: RESULT«4»

[20:44] <pmurias> propably kaos rather than KASO to keep the symmetry

[20:44] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[20:45] <pmurias> ruoso: re msg, we discussed it before, interpreter.return(...) would be enough

[20:46] *** pdcawley left
[20:47] <eric256> unobe: very nice

[20:48] <unobe> eric256: i noticed above tho' that the output dwhipp was expecting was 3.

[20:48] <unobe> I count three pairs between the 4's and a pair of 2's

[20:49] <unobe> I'm looking at the microsoft page right now

[20:50] *** alech_ joined
[20:50] *** alech left
[20:50] <unobe> rakudo: my @x = <1 2 2 3 4 4 4 5>; (([+] (@x XeqX @x)) - @x.elems)/2; 

[20:50] <p6eval> rakudo 34284: RESULT«4»

[20:50] <unobe> rakudo: my @x = <1 2 2 3 4 K 4 4 5 K Q J>; (([+] (@x XeqX @x)) - @x.elems)/2; 

[20:51] <p6eval> rakudo 34284: RESULT«5»

[20:51] <unobe> rakudo: my @x = <6 5 6 6 K>; (([+] (@x XeqX @x)) - @x.elems)/2; 

[20:51] <p6eval> rakudo 34284: RESULT«3»

[20:51] <eric256> your results all look right

[20:52] *** jan_ left
[20:52] <unobe> yay :-)

[20:53] <eric256> rakduo: my @cards = <1 2 2 3 4 4 4 5>; my $p = 0; for (0..@cards-2){ my $i = $_; $p += (@cards[$i..^@cards].grep: { $_ == @cards[$i]}).elems-1;};$p.say();

[20:53] <eric256> okay that works localy! ;)

[20:53] <eric256> a little wordy cause of a bug with $_ it seems

[20:53] <TimToady> it shouldn't work

[20:54] <TimToady> for (){} should be a hash subscript

[20:54] <eric256> rakduo: my @cards = <1 2 2 3 4 4 4 5>; my $p = 0; for (0..@cards-2) { my $i = $_; $p += (@cards[$i..^@cards].grep: { $_ == @cards[$i]}).elems-1;};$p.say();

[20:54] <unobe> *rakudo

[20:55] <eric256> rakudo: my @cards = <1 2 2 3 4 4 4 5>; my $p = 0; for (0..@cards-2) { my $i = $_; $p += (@cards[$i..^@cards].grep: { $_ == @cards[$i]}).elems-1;};$p.say();

[20:55] <eric256> details detail

[20:55] <p6eval> rakudo 34284: OUTPUT«4␤»

[20:55] <eric256> ;)

[20:55] <unobe> :-)

[20:55] <eric256> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for (0..@cards-2) { my $i = $_; $p += (@cards[$i..^@cards].grep: { $_ == @cards[$i]}).elems-1;};$p.say();

[20:55] <p6eval> rakudo 34284: OUTPUT«3␤»

[20:56] <eric256> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for (0..@cards-2) -> $i { $p += (@cards[$i..^@cards].grep: { $_ == @cards[$i]}).elems-1;};$p.say();

[20:56] <p6eval> rakudo 34284: OUTPUT«Undefined value shifted from empty range␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized

[20:56] <p6eval> ..va...

[20:56] <eric256> yea it doesn't like that for some reason

[20:56] <unobe> remove the parens?

[20:56] <unobe> around 0..@cards-2?

[20:56] <eric256> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for 0..@cards-2 -> $i { $p += (@cards[$i..^@cards].grep: { $_ == @cards[$i]}).elems-1;};$p.say();

[20:56] <p6eval> rakudo 34284: OUTPUT«Undefined value shifted from empty range␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized

[20:56] <p6eval> ..va...

[20:57] <unobe> hmm

[20:57] <eric256> yea i don't know what that deal is

[20:58] <unobe> Does 0..@cards work?

[20:58] <unobe> (not to get the correct answer, but for syntax)

[20:59] <unobe> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for 0..@cards -> $i { $p += (@cards[$i..^@cards].grep: {  $_ == @cards[$i]}).elems-1;};$p.say();

[20:59] <p6eval> rakudo 34284: OUTPUT«Undefined value shifted from empty range␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized

[20:59] <p6eval> ..va...

[20:59] <unobe> guess not

[20:59] *** Whiteknight left
[20:59] <eric256> no i'm not realy sure what i'm doing wrong there

[20:59] <unobe> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for 0..2 -> $i { $p += (@cards[$i..^@cards].grep: {  $_ == @cards[$i]}).elems-1;};$p.say();

[20:59] <p6eval> rakudo 34284: OUTPUT«Undefined value shifted from empty range␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized

[20:59] <p6eval> ..va...

[21:00] <unobe> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for 1..2 -> $i { $p += (@cards[$i..^@cards].grep: {  $_ == @cards[$i]}).elems-1;};$p.say();

[21:00] <p6eval> rakudo 34284: OUTPUT«Undefined value shifted from empty range␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Undefined value shifted from empty range␤Use of

[21:00] <p6eval> ..un...

[21:00] * unobe lost

[21:01] *** ejs joined
[21:01] *** Lorn left
[21:01] *** alech_ left
[21:02] *** alech joined
[21:03] *** jan_ joined
[21:03] <unobe> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for 0..@cards-2 -> $i { .say };

[21:03] <p6eval> rakudo 34284: OUTPUT«Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤»

[21:03] <unobe> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for 0..@cards-2 -> $i { $i.say };

[21:03] <p6eval> rakudo 34284: OUTPUT«./parrot: error while loading shared libraries: /home/evalenv/parrot/blib/lib/libparrot.so.0.8.2: file too short␤»

[21:04] <unobe> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for 0..@cards-2 -> $i { $i.say };

[21:04] <p6eval> rakudo 34284: OUTPUT«0␤1␤2␤3␤»

[21:04] <unobe> hmm

[21:04] <unobe> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for 1..2 -> $i { $p += (@cards[$i..^@cards].grep: {  $i == @cards[$i]}).elems-1;};$p.say();

[21:04] <p6eval> rakudo 34284: OUTPUT«Undefined value shifted from empty range␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Undefined value shifted from empty range␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of

[21:04] <p6eval> ..un...

[21:04] <eric256> try +$i in the range

[21:04] <eric256> i think $i isn't realy an int

[21:04] <unobe> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for 1..2 -> $i { $p += (@cards[+$i..^@cards].grep: {  $i == @cards[$i]}).elems-1;};$p.say();

[21:04] <p6eval> rakudo 34284: OUTPUT«-2␤»

[21:05] <eric256> tada

[21:05] <unobe> rakudo: my @cards = <6 5 6 6 K>; my $p = 0; for 0..@cards-2 -> $i { $p += (@cards[+$i..^@cards].grep: {  $i == @cards[$i]}).elems-1;};$p.say();

[21:05] <p6eval> rakudo 34284: OUTPUT«-4␤»

[21:05] <unobe> eric256++

[21:05] <eric256> my @cards = <1 2 2 3 4 4 4 5 5>; my $p = 0; for @cards[0..@cards-2].kv -> $k, $v { $p += (@cards[$k+0..^@cards].grep: {$_ == $v}).elems -1 }; say $p;

[21:05] <eric256> rakudo: my @cards = <1 2 2 3 4 4 4 5 5>; my $p = 0; for @cards[0..@cards-2].kv -> $k, $v { $p += (@cards[$k+0..^@cards].grep: {$_ == $v}).elems -1 }; say $p;

[21:05] <p6eval> rakudo 34284: OUTPUT«5␤»

[21:05] <eric256> still fugly though

[21:05] *** alanhaggai__ joined
[21:06] <unobe> so is that a rakudobug?

[21:06] <eric256> i think so yes

[21:06] <eric256> thats two for me ;)

[21:07] <unobe> is $_ the same as $k?

[21:07] <unobe> ah, no

[21:11] <eric256> .kv on an array returns the index and then the value so i put those in $k and $v

[21:12] <unobe> right, and since $_ is in grep, it's not $k

[21:13] <unobe> I like the .kv usage

[21:13] <unobe> it's just the p += 

[21:13] <unobe> it's just the $p += part

[21:15] <eric256> yea i dunno what to do with that. could push them onto an array and sum it, but i'm not sure thats much of a win

[21:16] *** cspencer joined
[21:20] *** alanhaggai_ left
[21:23] *** dwhipp joined
[21:24] <dwhipp> rakudo: my @a = < 1 2 3 >; for @a -> $x, $y { say $x, $y // "-" }

[21:25] <p6eval> rakudo 34288: OUTPUT«12␤StopIteration␤current instr.: '_block14' pc 143 (EVAL_14:61)␤»

[21:25] <dwhipp> rakudo: my @a = < 1 2 3 >; for @a -> $x, $y? { say $x, $y // "-" }

[21:25] <p6eval> rakudo 34288: OUTPUT«12␤StopIteration␤current instr.: '_block14' pc 143 (EVAL_14:61)␤»

[21:25] <dwhipp> rakudo: my @a = < 1 2 3 >, undef; for @a -> $x, $y? { say $x, $y // "-" }

[21:25] <p6eval> rakudo 34288: OUTPUT«12␤3-␤»

[21:25] <dwhipp> rakudo: my @a = < 1 2 3 >; for @a -> $x, $y? { say $x, $y // "-" }

[21:26] <p6eval> rakudo 34288: OUTPUT«12␤StopIteration␤current instr.: '_block14' pc 143 (EVAL_14:61)␤»

[21:26] <dwhipp> rakudo: my @a = < 1 2 3 >; for @a -> $x, *@rest { say $x, @rest }

[21:26] <p6eval> rakudo 34288: OUTPUT«12␤StopIteration␤current instr.: '_block14' pc 143 (EVAL_14:61)␤»

[21:27] <dwhipp> rakudo: my @a = < 1 2 3 >; for @a -> $x ;; *@rest { say $x, @rest }

[21:27] <p6eval> rakudo 34288: OUTPUT«12␤StopIteration␤current instr.: '_block14' pc 143 (EVAL_14:61)␤»

[21:28] *** jferrero left
[21:29] <dwhipp> rakudo: my @a = < 1 2 3 4>; for @a -> $x ;; *@rest { say $x, @rest }

[21:29] <p6eval> rakudo 34288: OUTPUT«12␤34␤»

[21:29] <dwhipp> rakudo: my @a = < 1 2 3 4>; for @a -> $x ;; |@rest { say $x, @rest }

[21:29] <p6eval> rakudo 34288: OUTPUT«Statement not terminated properly at line 1, near "-> $x ;; |"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[21:30] *** cspencer left
[21:33] *** Aisling joined
[21:34] *** alanhaggai joined
[21:35] *** aindilis joined
[21:38] <eric256> that kind of syntax would make things sweet, having a non consuming param after -> 

[21:39] *** alanhaggai__ left
[21:49] *** justatheory left
[21:51] *** rindolf joined
[21:52] *** stephens joined
[21:54] *** alech left
[21:54] *** cspencer joined
[21:54] *** alech joined
[21:59] *** aindilis` joined
[22:01] *** kisu_ joined
[22:02] *** Whiteknight joined
[22:04] *** eternaleye_ joined
[22:05] *** eternaleye left
[22:05] *** eric256 left
[22:06] *** ruoso left
[22:08] *** alech left
[22:09] *** kisu left
[22:09] *** kidd joined
[22:13] *** aindilis left
[22:16] *** jferrero joined
[22:24] <cspencer> rakudo: cmp(10, 1).say

[22:25] <p6eval> rakudo 34295: OUTPUT«Could not find non-existent sub cmp␤current instr.: '_block14' pc 62 (EVAL_13:40)␤»

[22:25] <cspencer> rakudo: infix:cmp(10, 1).say

[22:25] <p6eval> rakudo 34295: OUTPUT«Statement not terminated properly at line 1, near ":cmp(10, 1"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤»

[22:25] <cspencer> (10 cmp 1).say

[22:25] <cspencer> rakudo: (10 cmp 1).say

[22:25] <p6eval> rakudo 34295: OUTPUT«1␤»

[22:28] *** ejs left
[22:29] <cspencer> does the infix 'cmp' force stringification of its arguments before comparison? 

[22:31] *** lichtkind joined
[22:34] *** alech joined
[22:40] *** rindolf left
[22:46] *** alanhaggai_ joined
[22:49] *** alanhaggai left
[22:50] *** km2 joined
[22:50] *** alanhaggai__ joined
[22:59] *** alech_ joined
[23:01] *** alester left
[23:05] *** alanhaggai_ left
[23:10] *** alech left
[23:11] *** bacek__ joined
[23:11] *** alanhaggai__ left
[23:12] *** alanhaggai__ joined
[23:13] *** pmurias left
[23:16] *** aindilis` left
[23:18] *** awwaiid joined
[23:25] *** lichtkind_ joined
[23:25] *** alanhaggai joined
[23:25] *** alech_ left
[23:25] *** lichtkind_ left
[23:26] *** maerzhase left
[23:28] *** justatheory joined
[23:38] *** justatheory left
[23:39] *** iblechbot left
[23:41] *** unobe is now known as unobe_away

[23:41] *** alanhaggai__ left
[23:44] *** lichtkind left
[23:45] *** cspencer left
[23:48] <TimToady> @tell cspencer no, cmp is generic.  leg is the new spelling of the string-forcing comparison

[23:48] <lambdabot> Consider it noted.

[23:52] *** donaldh left
[23:54] *** DemoFreak left
[23:54] *** unobe_away is now known as unobe

[23:55] *** DemoFreak joined
[23:58] *** unobe left
[23:59] <pugs_svn> r24591 | hinrik++ | [util/perl6.vim] add more delimiters for Q//, fix glitch with contextualizers in strings, refactor some loops, add some missing escaped string delimiters, require a colon before full-name Q adverbs

