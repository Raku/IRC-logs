[00:00] <TimToady> note that even in P5, __DIE__ and __WARN__ are not really special tokens, just special keys to %SIG

[00:00] <TimToady> also note that in P6, every warn is, in essence, already wrapped by all the handlers in the dynamic scope that might examine it

[00:01] <TimToady> you only need to wrap warn() if you want to capture control before any of those handlers do.

[00:02] <TimToady> but if you merely want to override the default warn handler, that's just the one in the outermost dynamic scope

[00:02] <TimToady> so any dynamic scope inside that can override the outer handler

[00:12] *** eternaleye joined
[00:14] *** polettix left
[00:19] *** mj41_ left
[00:19] *** armagad left
[00:36] *** alc joined
[00:40] *** Guest39177 left
[00:48] *** japhb left
[01:05] *** cornelius_ joined
[01:06] *** cornelius_ left
[01:06] *** cornelius_ joined
[01:07] *** cornelius_ is now known as c9s

[01:09] *** japhb joined
[01:12] <Auzon> pugs: my @a = 1 .. 10; my %h = @a; say %h.perl

[01:12] <exp_evalbot> OUTPUT[{("1" => 2), ("3" => 4), ("5" => 6), ("7" => 8), ("9" => 10)}␤]

[01:26] *** Ched- left
[01:26] *** Ched- joined
[01:40] <Maghnus> pugs: my @a = 1 .. 9; my %h = @a; say %h.perl

[01:40] <exp_evalbot> OUTPUT[*** Odd number of elements found where hash expected: VList [VInt 1,VInt 2,VInt 3,VInt 4,VInt 5,VInt 6,VInt 7,VInt 8,VInt 9]␤    at /tmp/OQq3SCWurd line 1, column 17-27␤]

[01:47] *** alanhaggai joined
[02:18] *** sri_work left
[02:18] *** sri_work joined
[02:24] *** bacek_ joined
[02:25] *** sri_work left
[02:53] <Auzon> perl6: my $x = 1; $x ++; say $x

[02:53] <exp_evalbot> kp6 r20630: OUTPUT[syntax error at position 14, line 1 column 14:␤my $x = 1; $x ++; say $␤              ^ HERE␤]

[02:53] <exp_evalbot> ..pugs: OUTPUT[2␤]

[02:53] <exp_evalbot> ..rakudo r28040: OUTPUT[2␤]

[02:53] <exp_evalbot> ..elf r20630: OUTPUT[Parse error in: /tmp/sImoTprkeu␤panic at line 1 column 11 (pos 11): Can't understand next input--giving up␤WHERE: my $x = 1; $x ++; say $x␤WHERE:           /\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in

[02:53] <exp_evalbot> ..`comp_unit'␤  STD_red/std.rb:210:in `_UNIT'␤  ./../STD_red/STD_red_run:1...

[02:54] *** c1sung left
[02:55] <Auzon> pugs: sub infix:<++> ($a, $b) {2*($a + $b)}; my $a = 1; my $b = 2; say $a ++ $b;

[02:55] <exp_evalbot> OUTPUT[*** ␤    Unexpected "$b"␤    expecting operator, ":" or ","␤    at /tmp/o0jwpFzpxu line 1, column 72␤]

[02:55] <Auzon> pugs: sub infix:<++> ($a, $b) {2*($a + $b)}; my $a = 1; my $b = 2; say $a ++, $b;

[02:55] <exp_evalbot> OUTPUT[12␤]

[02:55] <Auzon> tsk.

[02:55] *** c1sung joined
[03:10] <Auzon> perl6: »*« 1..6

[03:10] *** exp_evalbot left
[03:10] <Auzon> Oops

[03:10] *** exp_evalbot joined
[03:10] <bacek_> Auzon: its all your fault :)

[03:10] <Auzon> Indeed. I should investigate why that happens.

[03:18] *** Limbic_Region left
[03:37] *** bacek left
[03:49] *** cjfields joined
[03:50] *** cjfields left
[04:05] *** alc left
[04:28] *** wknight8111 left
[04:30] *** nipotan is now known as nipotaway

[04:49] *** FurnaceBoy left
[04:58] *** alc joined
[05:03] *** Maghnus left
[05:05] *** Maghnus_ joined
[05:05] *** Maghnus_ is now known as Maghnus

[05:14] *** stevan_ left
[05:22] <bacek_> perl6: say reduce { $^a + $^b }: 100, (1..6)

[05:23] <exp_evalbot> kp6 r20630: OUTPUT[syntax error at position 24, line 1 column 24:␤say reduce { $^a + $^b }: 100, (1..6␤                        ^ HERE␤]

[05:23] <exp_evalbot> ..pugs: OUTPUT[121␤]

[05:23] <exp_evalbot> ..rakudo r28042: OUTPUT[Statement not terminated properly at line 1, near ": 100, (1."␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[05:23] <exp_evalbot> ..elf r20630: OUTPUT[syntax error at (eval 14) line 3, near ") :"␤ at ./elf_f_faster line 4492␤]

[05:24] <bacek_> rakudo: say reduce { $^a + $^b }, 100, @array

[05:24] <exp_evalbot> rakudo r28042 OUTPUT[Scope  not found for PAST::Var '@array'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[05:24] <bacek_> rakudo: say reduce { $^a + $^b }, 100, (1..6)

[05:24] <exp_evalbot> rakudo r28042 OUTPUT[No applicable methods.␤current instr.: '_block11' pc 73 (EVAL_13:27)␤

[05:29] *** halner left
[05:46] *** pochi left
[05:54] <moritz_> good morning

[05:54] <Auzon> good evening moritz_ :)

[05:55] *** jan______ left
[05:55] <Auzon> Do you have any ideas why evalbot occasionally segfaults?

[05:55] <moritz_> no :(

[05:56] <Auzon> Did it happen before I added elf support?

[05:56] <Auzon> I don't remember it happening before, and I see it mostly happen when people use 'perl6'

[05:56] <moritz_> yes, it happened before

[05:58] *** redicaps joined
[06:00] <Auzon> OK. Well, I think I can easily adjust the 'perl6' usage to process and return the output for one implementation at a time. That way, we can at least see which one dies.

[06:01] <Auzon> Plus, it'd be nice for the output to not hang on all of them.

[06:03] <moritz_> aye

[06:11] *** alanhaggai left
[06:14] <bacek_> pugs: say reduce { }, (1..5);

[06:14] <exp_evalbot> OUTPUT[*** Cannot cast from VList [VInt 1,VInt 2,VInt 3,VInt 4,VInt 5] to Pugs.AST.Internals.VCode (VCode)␤    at /tmp/0s34iW4H9r line 1, column 5-23␤]

[06:14] <bacek_> pugs: say reduce { -1 }, (1..6);

[06:14] <exp_evalbot> OUTPUT[*** Cannot reduce() using a unary or nullary function.␤    at /tmp/Y4UdIUNjjl line 1, column 5-26␤]

[06:15] <Auzon> moritz_: I took a look at doing that for evalbot, but I'll need to review the docs for Bot::Basicbot. I'll handle that in the morning. night &

[06:16] <moritz_> Auzon: good night

[06:21] *** fullermd left
[06:30] *** BinGOs joined
[06:34] *** luqui joined
[06:37] *** justatheory left
[06:44] *** meppl joined
[07:08] *** masak joined
[07:21] *** mj41 joined
[07:22] *** mj41 left
[07:29] *** fullermd joined
[07:32] *** redicaps left
[07:37] *** mj41_ joined
[07:43] *** mj41_ is now known as mj41

[07:44] *** mj41 left
[07:45] *** mj41 joined
[08:01] *** Torment joined
[08:10] *** lg left
[08:11] <masak> does prefix ++ in perl 6 return an lvalue?

[08:12] <moritz_> dunno. Why would anyone want to assign to it?

[08:12] <masak> just wondering if `++$var++` is allowed syntax :)

[08:12] <moritz_> if you want to assign to it, there's no point in incrementing it

[08:13] <moritz_> masak: don't think so

[08:13] <masak> there is in the above case

[08:13] <masak> (not advocating it, just curious)

[08:18] <moritz_> I can find no evidence in the specs, but I think that it's forbiddne, much like in C and perl 5

[08:18] *** Jedai left
[08:22] <masak> if the specs are silent, it's likely the same as in perl 5, yes

[08:22] *** elmex joined
[08:23] <bacek_> pugs: my $x=1; say ++$x++;

[08:23] <exp_evalbot> OUTPUT[*** Can't modify constant item: VInt 2␤    at /tmp/dhBKWga9Ub line 1, column 14-20␤]

[08:23] *** pmurias joined
[08:24] <bacek_> perl6: say my $x=1; say (++$x)++;

[08:24] <exp_evalbot> kp6 r20630: OUTPUT[syntax error at position 23, line 1 column 23:␤say my $x=1; say (++$x)++␤                       ^ HERE␤]

[08:24] <exp_evalbot> ..pugs: OUTPUT[1␤*** Can't modify constant item: VInt 2␤    at /tmp/nRyP7H6vTZ line 1, column 18-26␤]

[08:24] <exp_evalbot> ..rakudo r28044: OUTPUT[Method 'lvalue' not found for invocant of class 'PAST::Stmts'␤current instr.: 'parrot;PAST::Compiler;as_post' pc 2554 (src/PAST/Compiler.pir:684)␤

[08:24] <exp_evalbot> ..elf r20630: OUTPUT[Can't modify preincrement (++) in postincrement (++) at (eval 14) line 4, near ")++"␤ at ./elf_f_faster line 4492␤]

[08:24] <bacek_> elf++

[08:24] <bacek_> :)

[08:25] <moritz_> bacek_: that seems like an error message from perl 5

[08:44] *** bacek_ left
[09:20] *** zamolxes joined
[09:42] <moritz_> pugs: say $?PUGS_VERSION

[09:42] <exp_evalbot> OUTPUT[Perl6 User's Golfing System, version 6.2.13, October 17, 2006 (r18093)␤]

[09:48] *** chris2 joined
[09:49] *** b_jonas joined
[09:49] *** ruoso joined
[09:50] *** c9s left
[09:59] *** bacek joined
[10:09] <ruoso> :) SMOP grant was approved :) for those who didn't see the news :)

[10:10] <moritz_> ruoso: congratulations

[10:10] <moritz_> (I did see it, but I didn't see you on IRC ;)

[10:10] <ruoso> I was on vacations in amsterdam

[10:10] <ruoso> 4 days offline ;)

[10:12] *** masak left
[10:12] <moritz_> a nice city with quite some perl mongers ;)

[10:13] <ruoso> yeah... few friends of mine work at booking...

[10:40] *** alc left
[10:43] <pmurias> ruoso: when will the grant start?

[10:43] <ruoso> I will need a couple weeks before starting...

[10:44] <bacek> rakudo: say (1+undef).WHAT;

[10:44] <exp_evalbot> rakudo r28046 OUTPUT[Failure␤]

[10:44] <bacek> rakudo: my $a = 1 + undef; say $a; say $a.WHAT;

[10:44] <exp_evalbot> rakudo r28046 OUTPUT[1␤Failure␤]

[10:44] <ruoso> pmurias, but the grant manager wasn't assigned yet

[10:44] <pmurias> will you use kp6 or elf?

[10:44] <bacek> Ho! Gotcha!

[10:45] <bacek> rakudo: my $a = 1 * undef; say $a; say $a.WHAT;

[10:45] <exp_evalbot> rakudo r28046 OUTPUT[0␤Int␤]

[10:46] <pmurias> bacek: that behaviour is correct

[10:46] <moritz_> maybe infix:<+> is just missing a multi?

[10:46] <pmurias> bacek: the second one that is ;)

[10:48] <ruoso> pmurias, I should get to creating the Ast object types...

[10:48] <ruoso> which means that something might generate C code that will be initialized as the ast tree itself

[10:48] <ruoso> maybe that will already be something runnable

[10:49] <ruoso> which would mean that it wouldn't really be AST, but more higher-level SLIME nodes

[10:50] <ruoso> my priority is getting p6opaque done

[10:50] <ruoso> because that is really the most important milestone

[10:50] <ruoso> after that, we can have the s1p compiler to write other classes...

[10:50] <ruoso> and I think we'll then advance in a faster pace...

[10:52] <ruoso> and maybe even port kp6 or elf to bootstrap in SMOP

[11:00] <pmurias> is the option to have multiple -e's and input files in elf usefull?

[11:00] <moritz_> pmurias: usually everything after the input file or the first -e is used for  @*ARGV

[11:01] <moritz_> pmurias: how would you distinguish these two cases?

[11:01] *** pjcj left
[11:01] <pmurias> the current elf design uses "--"

[11:02] <pmurias> kp6 only allowes multiple -e's

[11:14] *** hanekomu joined
[11:14] <ruoso> pmurias, moritz_, I've just uploaded a new version of the "Perl 6 is just a SMOP" talk slides... would you like to take a look and comment ;) ?

[11:15] <ruoso> http://people.debian.org/~ruoso/SMOP.pdf

[11:15] <moritz_> ruoso: looking...

[11:16] *** luqui left
[11:18] *** IllvilJa left
[11:19] <moritz_> ruoso: in Perl 6 you'd say "Int $a = something()"

[11:19] <moritz_> not Integer

[11:19] <ruoso> ops...

[11:20] <ruoso> moritz_++, thanks

[11:24] * ruoso replacing "KP6 backend" by "kp6/elf backend" in the "things to come" slide...

[11:25] <moritz_> ruoso: how long is the talk?

[11:25] <ruoso> 40 minutes

[11:25] <ruoso> I realise I'll have to skip some parts

[11:25] <moritz_> don't think so

[11:26] <moritz_> 2 slides per minute on average

[11:26] <moritz_> that's fast, but most slides contain only a few words

[11:26] <ruoso> some of these slides are entirely entertaining...

[11:26] <moritz_> yes

[11:26] <moritz_> like mOOOOse

[11:26] <ruoso> yeah...

[11:28] <ruoso> one thing I'd like to see in the near future (as soon as I finish p6opaque) would be SMOP::P6Opaque as a Moose metainstance...

[11:30] <moritz_> does that mean you have to interact with perl 5 on the C level?

[11:30] <b_jonas> wow, 

[11:30] <ruoso> only to implement SMOP::P6Opaque...

[11:30] <ruoso> after that, it would be only in Moose level

[11:31] <b_jonas> you mean a uniform p6 interface to any p5 moose object?

[11:31] <ruoso> b_jonas, my point is that this is what P6 is all about...

[11:31] <b_jonas> or the reverse, a p5 moose interface for any p6 object?

[11:31] <ruoso> I think both scenarios are very likely

[11:32] <ruoso> both perl5 embeded in SMOP

[11:32] <ruoso> as SMOP embeded in perl5

[11:32] <b_jonas> rouso: yeah, but uniform interfaces are the part of parrot and p6 are what I least believe in

[11:32] <ruoso> b_jonas, not really... 

[11:32] <b_jonas> I don't like automatic uniform interfaces between languages

[11:32] <ruoso> parrot intends to uniform them in the syntax level

[11:32] <b_jonas> as such, I don't like the Inline:: p5 modules

[11:32] <ruoso> all of them would be compiled targeting parrot

[11:33] <b_jonas> really, there are two things I don't like

[11:33] <ruoso> this is different from interfacing with another language's runtime

[11:33] <b_jonas> one is _transparent_ interfaces between two language's objects

[11:33] <ruoso> which is how I think it should be done...

[11:33] <ruoso> there's no "transparent" interface... this is something that I still couldn't find to be doable...

[11:34] <ruoso> you have an "abstraction layer"

[11:34] <ruoso> just like XS

[11:34] <SamB> what is "transparent"?

[11:34] <ruoso> but less ugly

[11:34] <b_jonas> that is, I dislike an interface that wants to fool you that the foreign object has the interface similar to native objects 

[11:34] <ruoso> SamB, transparent means "without typemap"

[11:34] <moritz_> or "hidden"

[11:34] <b_jonas> rouso: no, without typemap is the second thing I dislike

[11:34] <b_jonas> that I call automatic interfaces

[11:35] <b_jonas> like when they promise you'll be able to call any C function from perl6 without any wrapper writing

[11:35] <ruoso> b_jonas, the thing is... if you get your protocol to a lower level (meta-object-protocol) you're not hiding...

[11:35] <ruoso> you're simply communication in a lower level

[11:35] <SamB> b_jonas: ludicrous

[11:35] <b_jonas> SamB: yeah, they said it a bit differently

[11:35] <b_jonas> and for parrot handling it actually

[11:37] <b_jonas> on the same conference where Leo later answered to my question -- if I remember correctly -- that blocking c extension functions for parrot will have to be stackless because they don't want all the setcontext magic ruby does for threads

[11:37] <ruoso> b_jonas, once you have typing (which you don't in p5), you can have type coercion, then you can coerce Perl 6 Int to C int in the runtime...

[11:37] <ruoso> only using the MOP

[11:39] <SamB> how C int can implement MOP?

[11:39] <ruoso> it's not C int that implements it

[11:39] <ruoso> but the invocation code that calls the C function

[11:39] <ruoso> just like XS

[11:40] <SamB> why does "XS" make me think of the deathstar?

[11:40] <ruoso> but you can use the runtime's type coercion to always receive Perl 6 native int

[11:40] <ruoso> and avoid dealing with all the perl magic

[11:40] <b_jonas> ruoso: yes, the haskell c interface for example does a quite good job with it

[11:40] <b_jonas> but that doesn't mean you can use any c function

[11:40] <ruoso> and that's the big difference from XS

[11:40] <b_jonas> there are still lots of requirements a c function you want to call from haskell can do

[11:41] <pmurias> it should be possible to use any c function from smop withought writing any wrappers

[11:41] <SamB> lots?

[11:41] <b_jonas> (not surprising, since just a 'c function' can do _anything_)

[11:41] <SamB> the main restriction is that you need to know the types of the arguments

[11:41] <b_jonas> SamB: there's more than that

[11:42] <ruoso> SamB, not really... there are IO issues and all other sort of hidden traps

[11:42] <SamB> the second one is that it can't deal in structs...

[11:42] <pmurias> SamB: lots refered to?

[11:42] <b_jonas> I guess you'll probably still easily be able to wrap _lots_ of c functions

[11:42] <SamB> well, that is, it can't deal in directly-passed-or-returned structs

[11:42] <b_jonas> like most from libgsl

[11:43] <b_jonas> I think libgsl still doesn't have a full wrapper in _any_ language because it has lots of functions

[11:43] <b_jonas> even the haskell interface wraps just some of them

[11:43] <b_jonas> it's huge like lapack

[11:43] <b_jonas> anyway, ttl

[11:43] <b_jonas> bye

[11:44] <ruoso> SamB, one big difference in P6 is that this struct can be the value itself... not a SV* with an int that happens to be the pointer address of that struct...

[11:44] *** b_jonas left
[11:44] <ruoso> and if the library implements some kind of OO-like API... you can actually map it directly...

[11:45] <ruoso> instead of fake-ing everything in p5land to dispatch the methods...

[11:45] <SamB> so you have gtk bindings?

[11:45] <ruoso> yes...

[11:45] <ruoso> you can actually have that today in p5

[11:46] <SamB> that use this principle of operation?

[11:46] <ruoso> but only thanks to a whole set of dark magic implemented by the perl-gtk guys

[11:46] <ruoso> SamB, perl-gtk uses a lot of tricks to make it work...

[11:46] <ruoso> it would be natural in P6 to have different object systems co-existing

[11:47] <ruoso> like...

[11:47] <ruoso> instead of the p5 interpreter dispatching the method call

[11:47] <ruoso> to a fake method in p5 land that dispatches the real method in the gtk land

[11:47] <bacek> pugs: my $a = 1 + undef; say $a; say $a.WHAT;

[11:47] <exp_evalbot> OUTPUT[1␤Int␤]

[11:48] <moritz_> ruoso: re slides, the "only exceptions are native types" lacks a bit context

[11:49] <ruoso> moritz_, ok... I'll work on it... maybe I don't even need to mention it, as it's a technical detail...

[11:54] <pmurias> ruoso: it's possible to encapsulation with other types too, it's just not socially accepted ;)

[11:54] <pmurias> * break encapsulation

[11:54] <SamB> you don't have anything like __getattr__ in p5?

[11:55] <ruoso> pmurias, sorry... I missed the context...

[11:55] <ruoso> SamB, __getattr__?

[11:56] *** chris2 left
[11:56] <SamB> Python thing...

[11:56] <ruoso> SamB, you mean, from python?

[11:56] <ruoso> no... actually you can't

[11:56] <SamB> p5 hasn't got anything like that?

[11:57] <ruoso> because in p6 the interpreter can't assume to know the internal format of the object

[11:57] <ruoso> except for the native types

[11:58] <pmurias> ruoso: it's possible to break the encapsulation (assume internals knowledge) with non-native types, hoping nothing bad happens

[11:58] <ruoso> it's a gray-area

[11:58] <ruoso> because SMOP actually uses it for its benefit...

[11:58] <SamB> eh?

[11:59] <ruoso> but it only does that after checking for a known responder interface

[11:59] <ruoso> for bootstrapping reasons

[11:59] <SamB> __getattr__ is implemented by the object...

[11:59] <ruoso> SamB, oh sorry... I misunderstood it

[11:59] <SamB> you must be thinking of getattr()

[11:59] <SamB> ;-P

[12:00] <SamB> if you think those look kinda similar, you'd be right ... they are quite closely related

[12:00] <ruoso> but the "get attr by name" thing might not be doable in p6

[12:00] <SamB> hmm. what did you mean by "fake method"?

[12:00] <ruoso> because there are no "public attributes" in p6

[12:01] <ruoso> SamB, a method that simply proxies to the real method

[12:01] <SamB> where do they come from?

[12:01] <ruoso> SamB, the fake methods? they are declared somewhere in gtk initialization...

[12:02] <ruoso> but I'm not really sure...

[12:02] <SamB> ah, so they aren't transient?

[12:03] <ruoso> transient?

[12:04] <SamB> eh, I should read up on perl objects...

[12:04] <bacek> perl6: say (1..4).map({$^a+$^b+$^c})

[12:04] <exp_evalbot> kp6 r20630: OUTPUT[syntax error at position 4, line 1 column 4:␤say (1..4).map({$^a+$^b+$^c}␤    ^ HERE␤]

[12:04] <exp_evalbot> ..pugs: OUTPUT[64␤]

[12:04] <exp_evalbot> ..rakudo r28046: OUTPUT[64␤]

[12:04] <exp_evalbot> ..elf r20630: OUTPUT[Global symbol "$c" requires explicit package name at (eval 14) line 3.␤ at ./elf_f_faster line 4492␤]

[12:04] <SamB> what was the manpage for that again?

[12:04] <moritz_> S12 (for Perl 6)

[12:07] *** pbuetow joined
[12:08] <ruoso> moritz_, you think I could remove the "native types" part of the presentation/

[12:08] <ruoso> ?

[12:08] <moritz_> ruoso: yes

[12:08] <ruoso> nice

[12:14] *** Simor joined
[12:14] * ruoso updated the slides...

[12:15] *** wknight8111 joined
[12:16] <bacek> rakudo: say (1+undef)+undef

[12:16] <exp_evalbot> rakudo r28046 OUTPUT[MMD function __add not found for types (102, 102)␤current instr.: 'infix:+' pc 9730 (src/gen_builtins.pir:6757)␤

[12:16] <SamB> that's really ugly

[12:17] <SamB> why does it say types 102,102

[12:17] <ruoso> SamB, that's probably the id of the type...

[12:17] <bacek> pugs: say (1+undef)+undef

[12:17] <exp_evalbot> OUTPUT[1␤]

[12:17] <SamB> well it's a stupid-looking sort of id

[12:18] <moritz_> SamB: I agree, but what would you do about anonym types?

[12:19] <SamB> hmm.

[12:19] <SamB> not sure...

[12:19] <SamB> avoid having them?

[12:20] <ruoso> SamB, that's absolutely impossible

[12:20] <moritz_> SamB: no way

[12:20] <moritz_> SamB: $variable but $role; creates an anynyom type

[12:20] <ruoso> there's no way to bootstrap a type system without anonymous types

[12:20] <SamB> hehehe

[12:21] <SamB> I have not seen a single anonymous type in Haskell or Coq or Agda 2...

[12:21] <moritz_> SamB: usually that's the point of them, you don't see them at all ;-)

[12:21] <ruoso> ok... which type does the namespace have?

[12:22] <SamB> namespace?

[12:22] <ruoso> I mean... the namespace implementation

[12:22] <ruoso> you need an anonymous type to implement namespace

[12:22] * SamB points out that none of those systems is object oriented

[12:22] <ruoso> that's not the point...

[12:23] <ruoso> they are not bootstrapped type systems

[12:23] <ruoso> that's the point

[12:23] <SamB> oh

[12:23] <SamB> not familiar with that terminology

[12:23] <bacek> rakudo: say  ~(1,2,3,4).map({ $^a+$^b+$^c+$^d+$^e })

[12:23] <exp_evalbot> rakudo r28047 OUTPUT[10␤]

[12:23] <ruoso> in SMOP, for instance, everything is SMOP__Object*

[12:23] <ruoso> even the interpreter

[12:23] <bacek> rakudo: say  ~(1,2).map({ $^a+$^b+$^c+$^d+$^e })

[12:23] <exp_evalbot> rakudo r28047 OUTPUT[MMD function __add not found for types (102, 102)␤current instr.: 'infix:+' pc 9730 (src/gen_builtins.pir:6757)␤

[12:25] <ruoso> SamB, that means that even the SMOP Object is implemented using SMOP Object...

[12:25] <ruoso> that's a bootstrapped type system

[12:26] <pmurias> isn't it a bootstrapped object system?

[12:26] <ruoso> and all of those types are anonymous so far, as SMOP doesn't have namespaces yet

[12:26] <ruoso> pmurias, I can't really tell the difference between type system and object system...

[12:26] <SamB> oh, a bit like Agda with type-in-type? apparantly that admits a form of russel's paradox...

[12:27] <SamB> i.e. it gives an inconsistant logic

[12:27] <ruoso> that's the precise reason of why it's named "bootstrap"

[12:28] <SamB> so, I hope you weren't planning on using Perl 6's typesystem as a formal logic

[12:28] <SamB> ;-P

[12:30] <bacek> perl6: say undef + 1 + undef

[12:30] <exp_evalbot> kp6 r20630: OUTPUT[1␤]

[12:30] <exp_evalbot> ..pugs: OUTPUT[1␤]

[12:30] <exp_evalbot> ..rakudo r28047: OUTPUT[MMD function __add not found for types (102, 91)␤current instr.: 'infix:+' pc 9730 (src/gen_builtins.pir:6757)␤

[12:30] <exp_evalbot> ..elf r20630: OUTPUT[Use of uninitialized value in addition (+) at (eval 14) line 3.␤Can't call method "Str" on an undefined value at ./elf_f_faster line 617.␤ at ./elf_f_faster line 4492␤]

[12:31] *** cjfields joined
[12:32] *** cjfields left
[12:50] *** vixey joined
[12:58] <ruoso> one interesting thing to do (that anyone could try) would be to implement the default HOW of Perl 6 in Perl 6

[12:59] <ruoso> http://www.perlfoundation.org/perl6/index.cgi?smop_oo_api describes the API it should implement...

[12:59] <lambdabot> Title: SMOP OO API / Perl 6

[13:00] <ruoso> http://svn.pugscode.org/pugs/v6/smop/src-s1p/Object.pm is an example of how that code could look like

[13:00] <ruoso> maybe the .^! calls in Object.pm should be turned into .^ calls

[13:01] <ruoso> or maybe even the code that call those .^! methods should reside into the HOW implementation

[13:01] <bacek> perl6: say undef - 1

[13:01] <exp_evalbot> kp6 r20630: OUTPUT[-1␤]

[13:01] <exp_evalbot> ..pugs: OUTPUT[-1␤]

[13:01] <exp_evalbot> ..rakudo r28047: OUTPUT[MMD function __subtract not found for types (102, 91)␤current instr.: 'infix:-' pc 9743 (src/gen_builtins.pir:6765)␤

[13:01] <exp_evalbot> ..elf r20630: OUTPUT[Can't call method "Str" on an undefined value at ./elf_f_faster line 617.␤ at ./elf_f_faster line 4492␤]

[13:03] <bacek> pugs: say undef - "123"

[13:03] <exp_evalbot> OUTPUT[-123␤]

[13:04] *** alanhaggai joined
[13:14] *** FurnaceBoy joined
[13:16] *** meppl left
[13:20] <pugs_svnbot> r20631 | ron++ | just a subversion test

[13:20] <pugs_svnbot> r20632 | ron++ | just a subversion test

[13:33] *** eternaleye left
[13:43] *** rdice joined
[13:46] <rakudo_svn> r28049 | pmichaud++ | [perl6]:

[13:46] <rakudo_svn> r28049 | pmichaud++ | * Fix a number of operators to do proper casting.

[13:46] <pugs_svnbot> r20633 | diakopter++ | [yap6] reverting to earlier MJD system; using CPS instead...

[13:46] <diakopter> ruoso: congrats

[13:46] <ruoso> diakopter, thanks

[13:46] <pmichaud> yes, ruoso, congrats

[13:46] <pmichaud> I'm glad to see it funded

[13:47] <ruoso> :)

[13:48] <ruoso> did you two see the slides I'm preparing...

[13:48] <ruoso> for the portuguese perl workshop

[13:49] <ruoso> pmichaud, diakopter, http://people.debian.org/~ruoso/SMOP.pdf

[13:55] <moritz_> pugs: say {$^a**2}.reduce: 1, 2, 3, 4

[13:55] <exp_evalbot> OUTPUT[<SubBlock(<anon>)>␤*** Cannot cast from VList [VInt 1,VInt 2,VInt 3,VInt 4] to Pugs.AST.Internals.VCode (VCode)␤    at /tmp/LLg4znQI5A line 1, column 1 - line 2, column 1␤]

[13:58] <ruoso> moritz_, the ":" indicates the invocant...

[13:59] <ruoso> are you sure that was your intention?

[13:59] <bacek> pugs: say (1..2).reduce({$^a})

[13:59] <exp_evalbot> OUTPUT[*** Cannot reduce() using a unary or nullary function.␤    at /tmp/8sPcrFY8Qz line 1, column 5 - line 2, column 1␤]

[13:59] <moritz_> ruoso: I know, I just didn't look up in which class the reduce() was defined

[13:59] <moritz_> but List makes much more sense than Code

[14:00] <bacek> pugs: say 'for pmichaud :)'; say (1..2).reduce({$^a})

[14:00] <exp_evalbot> OUTPUT[for pmichaud :)␤*** Cannot reduce() using a unary or nullary function.␤    at /tmp/L24ZyG9TBV line 1, column 28 - line 2, column 1␤]

[14:00] *** Simor left
[14:01] *** Lorn joined
[14:03] *** cmarcelo joined
[14:04] <ruoso> pugs: sub foo (*@args) { @args.join(',') }; (1..5).reduce(&foo)

[14:04] <exp_evalbot> OUTPUT[*** Cannot reduce() using a unary or nullary function.␤    at /tmp/OORfmYsbKK line 1, column 39 - line 2, column 1␤]

[14:05] <ruoso> pugs: sub foo (*@args --> String) { @args.join(',') }; say (1..5).reduce(&foo)

[14:05] <exp_evalbot> OUTPUT[*** Cannot reduce() using a unary or nullary function.␤    at /tmp/VSwh18zPrI line 1, column 54 - line 2, column 1␤]

[14:05] <ruoso> what does "unary or nullary function" means here?

[14:06] <moritz_> pugs: say $*PROGRAM_NAME

[14:06] <exp_evalbot> OUTPUT[␤]

[14:07] <ruoso> perl6: sub foo (*@args --> String) { @args.join(',') }; say (1..5).reduce(&foo)

[14:07] <diakopter> ruoso: I hope you don't mind I stole smop's former name (yapc)

[14:07] <pugs_svnbot> r20634 | diakopter++ | [yapc] removing calculator POC

[14:07] *** exp_evalbot left
[14:07] <diakopter> yap6

[14:07] <ruoso> diakopter, of course I don't...

[14:07] *** exp_evalbot joined
[14:07] <diakopter> ok thanks

[14:07] <ruoso> what are you using it for?

[14:07] <diakopter> a continuation-passing-style recursive-descent parser for Perl 6 in Perl 5

[14:07] <ruoso> cool

[14:07] <diakopter> based on MJD's code in Higher Order Perl

[14:07] *** meppl joined
[14:08] *** iblechbot joined
[14:08] <diakopter> exp_evalbot: come back

[14:08] <diakopter> oh, it's back

[14:09] <pmichaud> pugs:  multi sub foo() { 0; }    multi sub foo($a, $b) { $a + $b };   say (1..10).reduce(&foo);

[14:09] <exp_evalbot> OUTPUT[55␤]

[14:09] * moritz_ is glad he started evalbot in a 'while true; do $start_evalbot; done' loop

[14:09] <pmichaud> pugs:  multi sub foo() { 0; };   say (1..10).reduce(&foo);

[14:09] <exp_evalbot> OUTPUT[*** Cannot reduce() using a unary or nullary function.␤    at /tmp/ZvRPKwxZSt line 1, column 31-51␤]

[14:10] <pmichaud> pugs:  multi sub foo($a, $b) { $a + $b; };  multi sub foo() { 0; };   say (1..10).reduce(&foo);

[14:10] <exp_evalbot> OUTPUT[55␤]

[14:13] <ruoso> pugs: multi sub foo (*@args --> String) { @args.join(',') }; say (1..5).reduce(&foo)

[14:13] <exp_evalbot> OUTPUT[*** Cannot reduce() using a unary or nullary function.␤    at /tmp/GSMNAjBLcf line 1, column 60 - line 2, column 1␤]

[14:13] <ruoso> pugs: multi sub foo ($a, $b --> String) { @args.join(',') }; say (1..5).reduce(&foo)

[14:13] <exp_evalbot> OUTPUT[*** ␤    Unexpected "."␤    expecting "::"␤    Variable "@args" requires predeclaration or explicit package name␤    at /tmp/48Pu6zAtl2 line 1, column 42␤]

[14:13] <ruoso> pugs: multi sub foo ($a, $b --> String) { ($a,$b).join(',') }; say (1..5).reduce(&foo)

[14:13] <exp_evalbot> OUTPUT[1,2,3,4,5␤]

[14:13] <ruoso> weird...

[14:14] <ruoso> pugs: multi sub foo ($a, $b, $c --> String) { ($a,$b,$c).join(',') }; say (1..5).reduce(&foo)

[14:14] <exp_evalbot> OUTPUT[1,2,3,4,5␤]

[14:14] <ruoso> pugs: multi sub foo ($a, $b, $c --> String) { ($a,$b).join(',') }; say (1..5).reduce(&foo)

[14:14] <exp_evalbot> OUTPUT[1,2,4␤]

[14:14] <ruoso> weird...

[14:14] <moritz_> ruoso: why is that weird?

[14:14] <ruoso> the *@args version was supposed to wok

[14:14] <ruoso> work

[14:14] <moritz_> at least the first seems very intuitive to me

[14:14] <ruoso> or is that a known bug?

[14:15] <ruoso> pugs: multi sub foo (*@args --> String) { @args.join(',') }; say (1..5).reduce(&foo)

[14:15] <exp_evalbot> OUTPUT[*** Cannot reduce() using a unary or nullary function.␤    at /tmp/9qeKf8xSJy line 1, column 60 - line 2, column 1␤]

[14:15] <ruoso> this is not a unary function

[14:16] <moritz_> ruoso: probably .arity doesn't return the right thing for slurpy signatures

[14:16] <ruoso> pugs: multi sub foo (*@args --> String) { @args.join(',') }; say &foo.arity

[14:16] <exp_evalbot> OUTPUT[1␤]

[14:17] <ruoso> pugs: multi sub foo ($a, $b --> String) {  }; say &foo.arity

[14:17] <exp_evalbot> OUTPUT[2␤]

[14:17] <ruoso> hmm

[14:17] <moritz_> it should probably return Whatever for a slurpy sig

[14:17] <ruoso> actually Infinity

[14:17] <moritz_> or better, a range

[14:17] <moritz_> ruoso: no, it doesn't accept infinitely many arguments

[14:17] <ruoso> moritz_, actually it does

[14:18] <ruoso> my $capture = some_funky_sub(); foo(|$capture)

[14:18] <moritz_> a range can describe things like sub foo($a, *@rest_args) more accurately than a simple Infinite

[14:18] <ruoso> but you can't figure out what the end of the range is..

[14:19] <moritz_> the end of the range is Infinity, sure

[14:19] <ruoso> oh...

[14:19] <ruoso> ok... I see.

[14:19] <ruoso> but :(*@args) is still just Inifinity

[14:20] <ruoso> but :($something, *@args) is then 1 .. Infinity

[14:20] <moritz_> why? it won't fail if you pass 1 arg

[14:20] <moritz_> and 1 != Infinity

[14:21] <ruoso> but you can actually pass 0 arguments as well...

[14:21] <ruoso> but it's just semantics, actually

[14:21] *** FurnaceBoy is now known as FurnaceBoyAway

[14:21] <ruoso> returning a range kinda implies the ($some, $foo, *@args) scenario...

[14:22] <moritz_> ruoso: the specs are a bit more explicit in the case of the 'want' builtint...

[14:22] <moritz_> Their difference is that C<.arity> considers only mandatory parts,

[14:22] <moritz_> while C<.count> considers also optional ones, including C<*$>:

[14:22] <ruoso> as well as for ($some, $foo?, $bar?)

[14:22] <ruoso> ah...

[14:22] <ruoso> ok

[14:22] <ruoso> that would make the arity for *@args to 0

[14:23] <moritz_> and .count to Infinity

[14:23] <ruoso> pugs: multi sub foo (*@args --> String) {  }; say &foo.count

[14:23] <exp_evalbot> OUTPUT[*** No such method in class Sub: "&count"␤    at /tmp/52l5Q1Iqin line 1, column 45 - line 2, column 1␤]

[14:24] <ruoso> so reduce should use .count instead of .arity

[14:24] <moritz_> if (

[14:24] <moritz_> urks

[14:24] <moritz_> ruoso: yes

[14:27] *** zamolxes left
[14:27] *** cmarcelo left
[14:31] *** elmex left
[14:48] *** polettix joined
[14:49] *** froh-doh joined
[14:50] *** polettix left
[14:50] *** froh-doh is now known as polettix

[15:12] *** TJCRI joined
[15:13] *** hanekomu left
[15:17] *** Psyche^ joined
[15:25] *** Ched- left
[15:33] *** Patterner left
[15:33] *** Psyche^ is now known as Patterner

[15:46] *** jhorwitz joined
[15:48] *** IllvilJa joined
[15:52] <pugs_svnbot> r20635 | moritz++ | [spec] cleared old pugs specific environment variable

[15:54] *** justatheory joined
[15:55] <pugs_svnbot> r20636 | moritz++ | [spec] removed superfluous TODO marking from radix.t

[15:57] <pmurias> reduce with a 3 argument sub only works on odd number of elements?

[15:59] <ruoso> pmurias, multipliers of 3, maybe....

[15:59] <pmurias> ?

[16:00] <pmurias> how would you reduce 6 elements?

[16:01] <moritz_> actually S29 says the function has to work with two items at a time

[16:02] <pmurias> just seen it

[16:02] <pmurias> ;)

[16:02] *** alanhaggai left
[16:02] <pmurias> but it's possible to write a reduce version for a sub which takes $n elements

[16:03] <pmurias> the problem is would it be usefull?

[16:03] <moritz_> $res = &$expression($res, $cur);

[16:03] <moritz_> is the '&' mandatory here?

[16:03] <pmichaud> no.

[16:03] <moritz_> good

[16:03] <pmichaud> my $foo = sub { ... }; .....  $foo();

[16:05] <ruoso> moritz_, S03 'Reduction operators' seems to imply that it might receive as many arguments as it wants

[16:06] <ruoso> it might actually receive the entire list

[16:06] <moritz_> ruoso: actually reduction operators don't rely on reduce() at all

[16:06] <ruoso> sure sure...

[16:06] <moritz_> ruoso: for example they take associativity into account

[16:07] <ruoso> but it says that, 1 foo 2 foo 3, can be written as [foo] 1, 2, 3 -- wich seems to imply that 1,2,3 are arguments to foo

[16:08] <moritz_> I don't understand that conclusion

[16:08] *** TJCRI left
[16:08] <pmurias> infix operators take 2 arguments

[16:09] <pmichaud> infix:,  has list associativity, and thus may take more than 2 arguments

[16:11] <pugs_svnbot> r20637 | pmurias++ | [elf] -I's are .push'ed instead of being .unshift'ed and reversed

[16:11] <pmurias> pmichaud: infix list operators take all the argments

[16:12] <pmurias> * arguments

[16:12] <pmichaud> i was simply pointing out that some infix: operators don't have 2 arguments.

[16:12] <pmichaud> or 

[16:12] <pmichaud> that there exist some infix: operators that work with more or less than 2 arguments.

[16:12] <pmurias> pmichaud: how can they work with less arguments?

[16:13] <pmurias> s/less arguments/1 argument/

[16:13] <pmichaud> if they're invoked directly, as in   &infix:<,>($x)

[16:13] <pmichaud> or consider the case of  (1,)

[16:14] <pmurias> are ones which take exactly 3 allowed?

[16:14] <pmichaud> I don't know about that.  Doesn't seem like it.

[16:14] <ruoso> but...

[16:15] <ruoso> it wouldn't be that nice to have that kind of instrospection for every infix operation...

[16:16] <ruoso> maybe do something at bind-time

[16:16] <ruoso> to realise how many arguments were bound

[16:16] <pmichaud> afk (errands, lunch)

[16:17] <ruoso> and "consume" the items of the list to the next call

[16:17] *** FurnaceBoyAway is now known as FurnaceBoy

[16:17] <ruoso> that actually might work very nicely

[16:18] <clkao> win 53

[16:18] <moritz_> win 53, loose 52 - that's life.

[16:19] <ruoso> the capture sent to the operator would keep the state of which arguments were already subject to bind

[16:19] <ruoso> and the capture would then be reused in the next call

[16:19] <moritz_> sounds kinda tricky ;)

[16:20] <ruoso> sounds the kind of tricks that will make Perl 6 cool ;) ;) ;)

[16:21] <moritz_> hehe

[16:21] <ruoso> it's even performance-friendly

[16:21] <ruoso> as it would keep using the same capture as argument

[16:21] <ruoso> instead of creating a new capture everytime

[16:21] <moritz_> but not very parrot-friendly

[16:21] <moritz_> because it doesn't use explict captures for all sub/method/op calls

[16:22] <ruoso> capture doesn't support foreign captures?

[16:22] <ruoso> like... a capture that is actually bound to a C int array?

[16:22] <moritz_> actually I don't know

[16:23] <moritz_> perhaps there is a way to reuse captures in parrot, and I don't know about it

[16:24] <ruoso> the question is... is the invocation in parrot static?

[16:24] <ruoso> if so, rakudo will have to implement an abstraction layer on top of it

[16:24] <ruoso> to support different invocations...

[16:25] * moritz_ only hopes that parrot supports powerful incantations

[16:36] <Auzon> ruoso: congrats on your grant :)

[16:36] <ruoso> Auzon, thanks

[16:36] <ruoso> :)

[16:37] <spinclad> ruoso: 'What is in the way?':  do you mean 'What is blocking the way', or 'What is on the way, coming' ?

[16:37] <ruoso> what is on the way, coming...

[16:38] <ruoso> would "What is on the way?" be more correct?

[16:38] <spinclad> a case of english's 'in/on' distinction... yes, 'on the way'

[16:39] <ruoso> thanks... 

[16:39] * ruoso fixing...

[16:39] <spinclad> 'in the way': sitting in the road; 'on the way': moving down the road

[16:41] <ruoso> spinclad++, thanks... I've just uploaded a new version with that fix...

[16:41] *** Psyche^ joined
[16:41] <Auzon> pugs: say log 0

[16:41] <exp_evalbot> OUTPUT[-Inf␤]

[16:44] <spinclad> 'i was on my way till this cow got in my way'

[16:46] <pmurias> ruoso: new version of what?

[16:46] <ruoso> pmurias, the slides... 

[16:53] <Auzon> pugs: say ('A' .. 'Z').elems

[16:53] <exp_evalbot> OUTPUT[26␤]

[16:53] <Auzon> pugs: say elems('A' .. 'Z')

[16:53] <exp_evalbot> OUTPUT[26␤]

[16:56] *** nipotaway is now known as nipotan

[16:57] *** Patterner left
[16:57] *** Psyche^ is now known as Patterner

[17:09] *** justatheory left
[17:11] *** apeiron left
[17:12] *** jhorwitz left
[17:16] *** Lorn left
[17:18] *** stevan_ joined
[17:26] *** justatheory joined
[17:27] *** sri_work joined
[17:46] *** Jedai joined
[17:49] <moritz_> pugs_svnbot: you're late

[17:49] <pugs_svnbot> r20638 | moritz++ | [irclog] #parrotsketch should link to its logs

[17:49] <moritz_> pugs_svnbot: thank you

[17:55] *** justatheory_ joined
[18:01] *** Torment left
[18:04] *** justatheory left
[18:05] <meppl> good night

[18:08] *** sscaffidi left
[18:08] *** sscaffidi joined
[18:08] *** sscaffidi left
[18:08] *** sscaffidi joined
[18:10] *** meppl left
[18:10] *** pmurias left
[18:11] *** b_jonas joined
[18:17] *** sscaffidi left
[18:17] *** sscaffidi joined
[18:18] *** jhorwitz joined
[18:20] *** sri_work_ joined
[18:31] * ruoso home &

[18:31] *** ruoso left
[18:32] *** wknight8111_ joined
[18:33] *** wknight8111_ left
[18:36] *** sri_work left
[18:40] *** justatheory_ left
[18:43] *** justatheory joined
[18:47] *** andy123 joined
[19:02] <pugs_svnbot> r20639 | diakopter++ | [yap6]

[19:02] <pugs_svnbot> r20639 | diakopter++ | Nested error handling (and reporting!) working; the parser author

[19:02] <pugs_svnbot> r20639 | diakopter++ | can define helpful syntax error messages.  Also, trace output

[19:02] <pugs_svnbot> r20639 | diakopter++ | considerably improved.

[19:02] *** sscaffidi left
[19:03] *** andy123 left
[19:07] *** sscaffidi joined
[19:13] *** cjfields joined
[19:17] *** jhorwitz_ joined
[19:28] *** alester joined
[19:29] *** sscaffidi left
[19:30] *** kcwu left
[19:32] *** jhorwitz left
[19:40] *** sscaffidi joined
[19:46] *** pmurias joined
[19:52] <avar> $ ../../parrot perl6.pbc -h

[19:52] <avar> perl6.pbc

[19:52] <avar> Usage: perl6 [switches] [--] [programfile] [arguments]

[19:52] *** ruoso joined
[19:52] <avar> Is this rakudo still?:)

[19:54] *** Ched- joined
[19:56] <moritz_> avar: what else could it be? ;-)

[19:59] <avar> nothing really, I just checked out with git-svn and figured I might be getting something ancient:)

[19:59] <avar> I thought they'd updated -h to say rakudo even if the directory was still called perl6

[20:01] <moritz_> avar: I think it's mostly the standard HLL compiler template thingy

[20:03] <[particle]> no, i modified it for rakudo i think, but when you build rakudo, it makes an executable called 'perl6'

[20:03] <[particle]> not called 'rakudo'

[20:05] <avar> Oh the humanity!

[20:15] <pmurias> avar: do you think the kp6 CLI could be improved?

[20:15] <avar> No wai man, it's PERFECT

[20:15] <avar> >:)

[20:15] <vixey> What's CLI?

[20:15] <pmurias> command line interface

[20:16] <pmurias> avar: ;)

[20:16] <pmurias> elf's CLI sucks, so i thought it might be a good idea to steal kp6's

[20:17] <avar> yeah it was pretty neat

[20:17] <avar> I remember cleaning it up, could still use some more cleanup:)

[20:17] <avar> stole most of it from pugs's

[20:19] *** mncharity joined
[20:20] <pmurias> mncharity: hi ;)

[20:20] <pmurias> s/;)/:)/

[20:20] <mncharity> hi ﻿pmurias.  just stopping by briefly to ping stevan_.

[20:20] <mncharity> :)

[20:21] <pmurias> avar: you mean cleaning up internals or implementation?

[20:21] <avar> the command line switches

[20:21] <avar> e.g. -B ad -C

[20:22] <pmurias> mncharity: i'm replacing the CLI is elf's abilitity to load multiple files at once ./elf file1 file2 usefull?

[20:26] <diakopter> use no warnings 'recursion'; # finally found it

[20:27] <diakopter> no warnings 'recursion'; # I mean

[20:29] *** sscaffidi left
[20:32] <Auzon> Is printf() dead?

[20:32] <Auzon> rakudo: say sprintf('%%');

[20:32] <exp_evalbot> rakudo r28052 OUTPUT[Could not find non-existent sub sprintf␤current instr.: '_block11' pc 28 (EVAL_10:17)␤

[20:33] <Auzon> hm.

[20:34] <pmurias> Auzon: printf lives :(

[20:34] *** jferrero joined
[20:35] <Auzon> It's not in S29.

[20:35] <Auzon> Why the sad face though?

[20:35] <Auzon> It's easy enough to implement in P6, I think.

[20:35] *** chris2 joined
[20:35] <pmurias> it's in S29

[20:35] <pmurias> it's in IO.pod

[20:36] <pmurias> Auzon: it's trival with sprinf

[20:36] <Auzon> Yeah.

[20:36] <Auzon> doh. I don't have a local S29.

[20:37] <moritz_> http://svn.pugscode.org/pugs/docs/Perl6/Spec/Functions.pod

[20:38] <pugs_svnbot> r20640 | diakopter++ | [yap6]

[20:38] <pugs_svnbot> r20640 | diakopter++ | Still further improved error handling/reporting.

[20:38] <pugs_svnbot> r20640 | diakopter++ | Non-trace-mode source filter speeds up execution by lots%

[20:38] <pugs_svnbot> r20640 | diakopter++ | no warnings 'recursion'; # eliminates that parse-time warning.

[20:38] <pugs_svnbot> r20640 | diakopter++ | Next task: produce an AST instead of evaluating arithmetic expressions

[20:38] <pugs_svnbot> r20640 | diakopter++ | synchronously.

[20:38] <Auzon> Ah. It's in Pugs, not whatever syn repo I'm using

[20:38] <mncharity> ﻿pmurias: re CLI, my impression of what's about to happen is elf/ is going to get very conservative, moving towards having a release process, and most elf-ish development is going to move into a new elfish/on_perl5/ .

[20:39] <pmurias> we can do a release at any point 

[20:39] <mncharity> more specifically, re is useful, yes, definitely.

[20:39] <diakopter> mncharity: where can I find a specification/description of the AST format that elf expects

[20:40] <mncharity> ﻿pmurias: but one of the objectives of the split is to allow folks to do arbitrary changes without the worry of "is it the right thing" and "will it break every one who is using elf".

[20:41] <mncharity> so we avoid the longstanding pugs issue of "you want to refactor aggressively, and exploratorily, but there are other people (including yourself when you are working on other things) who depending on stability, so refactoring/exploration is badly impaired".

[20:42] <pmurias> it think just creating a stable branch would be sufficent

[20:42] <pmurias> mncharity: i'm not sure which calling convention should i implement

[20:43] <mncharity> a single unitary unstable branch requires intensive communication and commonality of vision among all the developers.  part of the reason git is displacing svn is that is expensive and hard to come by.

[20:43] <pmurias> CAPTURE($capture), NAMED([...],{...}) and FAST($arg1,$arg2,$arg3,[@slurpy])?

[20:44] <mncharity> ﻿diakopter: re "﻿AST format that elf expects", one problem is divergence of what parrot and elf call an ast.  the Match tree resulting from parsing

[20:46] <mncharity> is generated by STD_red's std.rb, based on STD.pm (old, with exceptions noted by NONSPEC flag comments), and consumed by IRx1_FromAST_create.pl.  No other spec/desc.   The IR nodes are

[20:48] <mncharity> described in IRx1_nodes_create, with some additional (and soon to grow) methods in IRx1_Analysis.  Semantics are implicit in IRx1_Analysis and EmitSimpleP5, and somewhat in flux (ie, undef vs empty array for missing or non-applicable list-of-something fields).  No other spec/desc.

[20:48] <diakopter> mncharity: thanks! :)

[20:49] <mncharity> IRx1_FromAST_create has a couple of code massage regexps at bottom.

[20:50] <mncharity> s/﻿Semantics are implicit in(.*)/IRx1_FromAST, $1/

[20:50] <pmurias> mncharity: POSITIONALS_ONLY() would be propably usefull to for p5 compat

[20:51] *** Blasi left
[20:53] <mncharity> ﻿pmurias: re calling convention, there are a couple of possibilities.  but it may be better to defer named arguments for some days, as my impression is Emit is about to be gutted, with much of it moved into IRx1_Analysis.

[20:57] <mncharity> or, a different answer, might be to set up an elfish/on_perl5 now (a makefile like showcode's can be used) and start experimenting...

[20:58] <pmurias> mncharity: i'm thinking of add a different backend

[20:59] <mncharity> me too.  :)

[21:00] <moritz_> parrot? smop? lisp? javascript?

[21:00] <mncharity> which is the main motivation for moving anything p6-ir-and-semantics-related out of Emit.

[21:00] <pmurias> it thought a p5 with named arguments ;)

[21:01] <pmurias> but any of the ones moritz wants are fine

[21:01] <pmurias> smop is a bit too young

[21:01] <Patterner> CamelFish is the JavaScript in Parrot, right?

[21:02] <spinclad> ecmascript methinks

[21:02] <moritz_> Patterner: there's 'eclectus' and 'ecmascript' in languaes/ in parrot trunk

[21:02] <pmurias> mncharity: re javascript oo, it's crapy so i wouldn't bet on it maping to anything cleanly

[21:04] <mncharity> re "﻿p5 with named arguments", neat.  elfish/on_perl5_wna/  :)   I don't currently expect to do much IR change, so simply copying Emit and modifying it should work.

[21:04] <mncharity> elfish/on_perl5_named/

[21:05] <mncharity> eh

[21:05] <pmurias> mncharity: why keep it in a seperate directory?

[21:07] <Auzon> elf: 31 -12

[21:07] <exp_evalbot> RESULT[19␤]

[21:08] <pugs_svnbot> r20641 | pmurias++ | [elf] a new incomplete command line iterface

[21:08] <pugs_svnbot> r20641 | pmurias++ | (checking it in so i don't accidently screw up anything ;)

[21:09] <mncharity> elf/ is the production compiler.  it just happens to be one folks can easily make derivatives of.  such derivative projects go elsewhere, just as pugs derivatives have gone elsewhere than src/pugs/.  the elf/ compiler will draw changes from the various derivatives, in a git like manner, but can be depended upon to always work, unlike, obviously, the derivatives.

[21:09] <Auzon> pugs: say sprintf('%u', -42);

[21:09] <exp_evalbot> OUTPUT[*** Ix{Integer}.index: Index (-42) out of range ((0,15))␤    at /tmp/xAH0EbFQBA line 1, column 1-23␤]

[21:09] <Auzon> kp6: say sprintf('%u', -42);

[21:09] <exp_evalbot> kp6 r20640: OUTPUT[syntax error at position 11, line 1 column 11:␤say sprintf('%u', -42)␤           ^ HERE␤]

[21:09] <Auzon> elf: say sprintf('%u', -42);

[21:09] <exp_evalbot> OUTPUT[4294967254␤]

[21:10] <Auzon> elf: say sprintf('%04u', -42);

[21:10] <exp_evalbot> OUTPUT[4294967254␤]

[21:10] <mncharity> the other question is why misc/elfish/on_foo/  rather than  misc/whatever_foo.  and that's to simplify collective regression testing and such.

[21:10] <Auzon> Evalbot must run on a 32 bit computer...

[21:11] <mncharity> i'm out.  back... probably tomorrowish.  last questions?

[21:12] <spinclad> mncharity: having fun?

[21:12] <mncharity> :/

[21:12] <spinclad> :\

[21:12] <mncharity> ﻿moritz_: re langauges, not sure yet.

[21:13] <mncharity> cheers &

[21:13] *** mncharity left
[21:21] *** rdice left
[21:22] *** jhorwitz_ left
[21:24] <pmurias> moritz_: re languages, any you're willing to help with? ;)

[21:27] *** Torment joined
[21:31] *** b_jonas left
[21:33] <moritz_> pmurias: good question. I have to admit that I know nearly no language besides perl 5 good enough

[21:33] <moritz_> there are a few rather unpopular (like Eiffel) that don't seem to fit at all

[21:35] <moritz_> and currently I'm selling my soul to the test suite and rakudo, so there's just a little tiime slice left - not enough to really influence the choice of a backend language

[21:36] *** cjfields left
[21:43] *** Jedai left
[21:47] *** stevan_ left
[21:50] *** iblechbot left
[21:55] *** chris2 left
[22:50] *** jferrero left
[22:54] *** Limbic_Region joined
[22:59] *** polettix left
[23:07] *** polettix joined
[23:20] *** drbean_ left
[23:25] *** pmurias left
[23:25] *** poletti joined
[23:31] *** cjfields joined
[23:34] *** polettix left
