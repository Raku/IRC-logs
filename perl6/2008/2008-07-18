[00:05] *** armagad left
[00:06] *** Chillance left
[00:32] *** elmex left
[00:36] <meppl> good night

[00:48] *** meppl left
[01:59] *** c1sung joined
[02:17] *** kanru joined
[02:21] <s1n> pugs: 1..^5

[02:21] <p6eval> pugs: RESULT[(1, 2, 3, 4)]

[02:25] *** justatheory left
[02:30] <s1n> pugs: 5..1

[02:30] <p6eval> pugs: RESULT[()]

[02:31] <s1n> Auzon: what do i do with tests that should work but are currently failing?

[02:32] <s1n> mark them as rakudo skip tests?

[02:33] <SamB> s1n: why would you want to do that?

[02:34] <s1n> SamB: do what, mark them rakudo skip? the test is currently in spectest_regression.dat, so i assumed we didn't want anything in those tests failing

[02:35] *** jhorwitz left
[02:38] <SamB> oh, sure, I guess it doesn't qualify as a regression if it never worked in rakudo...

[02:39] <s1n> SamB: are you suggesting it should be skipped then?

[02:41] * SamB dunno

[02:43] *** nipotan is now known as nipotaway

[02:48] <s1n> pugs: 'd'..'a'

[02:48] <p6eval> pugs: RESULT[()]

[02:48] <s1n> pugs 'a'..'d'

[02:48] <s1n> pugs: 'a'..'d'

[02:48] <p6eval> pugs: RESULT[("a", "b", "c", "d")]

[02:51] <s1n> pugs: 1..1

[02:51] <p6eval> pugs: RESULT[(1,)]

[02:57] *** PZt left
[02:57] *** PZt joined
[02:59] <s1n> if a spectest is failing but shouldn't be, and it's in the spectest_regression.dat, should it be marked as SKIP?

[03:01] *** alanhaggai left
[03:10] *** Schwern joined
[03:14] *** virbyte joined
[03:14] *** wknight8111 left
[03:15] *** dduncan joined
[03:18] *** dduncan_ joined
[03:18] *** dduncan_ left
[03:19] *** dduncan_ joined
[03:19] *** pbuetow joined
[03:22] <bacek> pugs: say 5..1;

[03:22] <p6eval> pugs: OUTPUT[␤]

[03:22] <s1n> see

[03:22] <s1n> pugs: 'a'..'d'

[03:22] <p6eval> pugs: RESULT[("a", "b", "c", "d")]

[03:22] <s1n> pugs: 'd'..'a'

[03:22] <p6eval> pugs: RESULT[()]

[03:22] <s1n> it's a fail, but probably shouldn't be

[03:23] <bacek> rakudo: 'a'..'d'

[03:23] <p6eval> rakudo 29575: RESULT["a".."d"]

[03:23] <bacek> rakudo: 'd'..'a'

[03:23] <p6eval> rakudo 29575: RESULT["d".."a"]

[03:23] <bacek> rakudo: ('a'..'d').WHAT

[03:23] <p6eval> rakudo 29575: OUTPUT[Null PMC access in get_bool()␤current instr.: 'parrot;Range;true' pc 4722 (src/gen_builtins.pir:3203)␤]

[03:23] <s1n> rakudo: 'd'^..'a'

[03:23] <p6eval> rakudo 29575: RESULT["d"^.."a"]

[03:23] <bacek> rakudo: say ('a'..'d').WHAT

[03:23] <p6eval> rakudo 29575: OUTPUT[Range␤]

[03:24] <s1n> hmm, lemme check my tests again

[03:24] <bacek> s1n: rakudo's output looks sane for me

[03:24] <s1n> rakudo: 1..1

[03:24] <TimToady> pugs doesn't implement Range objects yet

[03:24] <p6eval> rakudo 29575: RESULT[1..1]

[03:25] <s1n> rakudo (1..1).WHAT

[03:26] <s1n> TimToady: there's some partial work there, i went through the tests yesterday, i think there were 64 passing with a handful being fudged

[03:26] <s1n> rakudo: (1..1).WHAT

[03:26] <p6eval> rakudo 29575: OUTPUT[Null PMC access in get_bool()␤current instr.: 'parrot;Range;true' pc 4722 (src/gen_builtins.pir:3203)␤]

[03:26] <bacek> rakudo: say (1..1).WHAT

[03:26] <p6eval> rakudo 29575: OUTPUT[Range␤]

[03:27] <bacek> rakudo: say ~('a'..'d')

[03:27] <p6eval> rakudo 29575: OUTPUT[a b c d␤]

[03:27] <bacek> rakudo: say ('a'..'d')

[03:27] <p6eval> rakudo 29575: OUTPUT[abcd␤]

[03:27] <s1n> rakudo: say ~('d'..'a')

[03:27] <p6eval> rakudo 29575: OUTPUT[␤]

[03:27] <s1n> hmmm

[03:27] <s1n> rakudo say ~(5..1)

[03:27] <s1n> damnit

[03:27] <bacek> s1n: stringified empty list.

[03:27] <s1n> rakudo: say ~(5..1)

[03:27] <p6eval> rakudo 29575: OUTPUT[␤]

[03:28] <s1n> bacek: wouldn't an empty list be wrong in this case?

[03:28] <bacek> no. Why?

[03:29] <s1n> so you can't create decreasing ranges?

[03:29] <bacek> rakudo: say reverse(1..5)

[03:29] <p6eval> rakudo 29575: OUTPUT[54321␤]

[03:29] <s1n> yeah but if i can do increasing ranges, why can't i do increasing ranges without using reverse?

[03:29] <s1n> err decreasing ranges w/o reverse

[03:29] <bacek> s1n: just because you can't.

[03:29] <s1n> heh

[03:30] <bacek> Range is increasing only.

[03:30] <s1n> monotonically increasing ranges only?

[03:30] <s1n> is that in the spec?

[03:31] <s1n> hmm, i never tried that in perl5 but it does that in perl5, if it's in the spec to keep it as-is, then that's fine

[03:33] *** dduncan left
[03:33] <bacek> s1n: perl5 doesn't have 'decresing ranges'...

[03:35] <bacek> Probably S02 should be clarified about Ranges.

[03:36] <s1n> yeah, i noticed

[03:36] <s1n> how about i mark them as skip and unspecced

[03:37] <s1n> i don't really see anything in the spec that clarifies this

[03:37] <bacek> s1n: sounds good for me.

[03:38] <s1n> bacek: okay

[03:39] *** baest joined
[03:46] *** pbuetow_ joined
[03:48] <s1n> rakudo: say ~(1..1)

[03:48] <p6eval> rakudo 29575: OUTPUT[1␤]

[03:52] <s1n> moritz_: should unspecced tests be fudged? i talked it over with Auzon and he said go ahead and unfudge them

[03:52] <s1n> moritz_: i'm adding a few more things that test .perl so if they should be fudged, let me know

[03:53] <s1n> moritz_: they pass, but if they're supposed to be fudged, that's fine (i.e. (1..5).perl acually gives '1..5')

[03:54] *** pbuetow left
[03:57] *** dduncan_ left
[03:58] <bacek> rakudo: say (1..5).perl

[03:58] <p6eval> rakudo 29575: OUTPUT[1..5␤]

[03:58] <bacek> rakudo: say (1..'a').perl

[03:58] <p6eval> rakudo 29575: OUTPUT[1.."a"␤]

[03:58] <bacek> rakudo: say (1..'a')

[03:58] <p6eval> rakudo 29575: OUTPUT[␤]

[03:59] <bacek> pugs: say (1..'a')

[03:59] <p6eval> pugs: OUTPUT[␤]

[04:03] <Auzon> s1n: If it's a parsefail, mark it as skip. But if it parses and gives the wrong result, 'todo' is the proper one

[04:04] <Auzon> Some parsefails might require some more creativity if fudge doesn't remove the correct line. This happens if the parsefail is on the line above the test and fudge doesn't get both lines.

[04:04] <Auzon> The solution here is to skip the test and use something like #?rakudo emit #

[04:09] *** s1n left
[04:17] <TimToady> sigh, it *is* specced...  see S03:2641

[04:23] *** s1n joined
[04:32] *** Jamtech joined
[04:51] *** pbuetow_ left
[05:11] *** araujo left
[05:14] *** Jamtech left
[05:14] *** hcchien left
[05:14] *** agentzh left
[05:14] *** Khisanth left
[05:14] *** virbyte left
[05:16] *** virbyte joined
[05:16] *** hcchien joined
[05:17] *** Jamtech joined
[05:17] *** agentzh joined
[05:17] *** Khisanth joined
[05:17] *** kcwu joined
[05:17] *** kcwu left
[05:17] *** kcwu_ joined
[05:17] *** Khisanth left
[05:17] *** Jamtech_ joined
[05:22] <ingy> hola

[05:25] * TimToady chirps like crickets

[05:28] *** Khisanth joined
[05:29] *** Lorn left
[05:30] *** Jamtech left
[05:34] <TimToady> heh, STD found a bug in t/spec/S02-whitespace_and_comments/unspace.t

[05:39] <pugs_svn> r21369 | lwall++ | [STD] now handles @foo non-interpolation

[05:39] <pugs_svn> r21369 | lwall++ | [unspace.t] accidentally tried to use #() comments at beginning of line

[05:53] *** Psyche^ joined
[06:04] <bacek> pugs: say (1|2|3) < 2;

[06:04] <p6eval> pugs: OUTPUT[any(VBool False,VBool True)␤]

[06:05] <bacek> pugs: say (1&2&3) < 2;

[06:05] <p6eval> pugs: OUTPUT[all(VBool False,VBool True)␤]

[06:05] <bacek> hmm..

[06:06] *** Patterner left
[06:06] *** Psyche^ is now known as Patterner

[06:11] <bacek> pugs: say (1&2&3) < 5;

[06:11] <p6eval> pugs: OUTPUT[all(VBool True)␤]

[06:12] *** tuxdna joined
[06:13] *** alanhaggai joined
[06:18] *** ashizawa joined
[06:43] *** Psyche^ joined
[06:46] *** pmurias joined
[06:47] <pmurias> wouldn't it be possible to just have the parser skip things it doesn't understand rather than fudging parsefail?

[06:49] <moritz_> pmurias: bad idea, I think

[06:49] <moritz_> I can't see how it could reliably resume after an unknown construct

[06:49] <moritz_> plus, sometimes the test files are wrong - it's nice to get a syntax error then

[06:51] *** iblechbot joined
[06:52] <pmurias> if you add todo markers, adding parse failure markers is similiar i guess

[06:53] <moritz_> I can't really imagine how that could work

[06:55] <pmurias> skip a line and try again

[06:55] <pmurias> and the statement level

[06:56] <moritz_> so you basically want to merge fudge and the grammar

[06:59] *** Patterner left
[06:59] *** Psyche^ is now known as Patterner

[06:59] <pmurias> moritz_: i would to it for STD.pm, but it tends to parse things

[07:00] <pmurias> s/to/do

[07:01] <moritz_> well, for the tests you'd have to do a bit more, for example note the number of skipped tests

[07:01] <moritz_> so you have to put it into the AST somehow as well

[07:01] <moritz_> I don't think it's worth the trouble

[07:01] *** barney joined
[07:04] <pmurias> moritz_: they would be failed tests really

[07:04] <moritz_> and how could you skip/todo them?

[07:05] <pmurias> with fudge ;)

[07:05] <moritz_> ;-)

[07:10] <pmurias> moritz_: do you know what the general test numbering policy is?

[07:10] <moritz_> what do you mean?

[07:12] <pmurias> should the test numbers in a test suit reflect the order of test creation, the order how they depend on each other or something else?

[07:13] <moritz_> I generally don't number my tests, except the very basic ones to run first

[07:14] <moritz_> smop seems to number in order of creation

[07:14] <pugs_svn> r21370 | lwall++ | [STD] handle \@foo and other fiddly issues

[07:15] <pmurias> and how should i do test removal?, leave gaps

[07:16] <moritz_> I'd leave the gaps, but I wouldn't have numbered them in the first place ;-)

[07:25] *** kanru left
[07:35] <pugs_svn> r21371 | lwall++ | [STD] handle Q forms

[07:35] <pugs_svn> r21371 | lwall++ | [quoting.t] change q:q and q:qq to Q:q and Q:qq

[07:37] *** meppl joined
[07:42] *** jan___ joined
[07:45] <pmurias> @tell where should i put the root namespace creation ruoso and destruction, as SMOP_DISPATCH and SMOP_RELEASE take an interpreter as a parameter

[07:45] <lambdabot> Consider it noted.

[07:47] <moritz_> pmurias: wrong target person ;-)

[07:50] *** jan_ left
[07:59] <rakudo_svn> r29576 | moritz++ | [rakudo] added S04-statements/do.t to spectest_regression, Auzon++

[07:59] <rakudo_svn> r29576 | moritz++ |  +14 pass, +9 todo/skip tests

[08:02] *** masak joined
[08:06] <pmurias> @tell ruoso where should i put the root namespace creation ruoso and destruction, as SMOP_DISPATCH and SMOP_RELEASE take an interpreter as a parameter

[08:06] <lambdabot> Consider it noted.

[08:10] <masak> speaking of cascaded subscripts, will we be seeing any compile-time checks for array index that are out of bounds in Perl 6?

[08:10] <moritz_> I don't think it'll be specced to happen at compile time

[08:11] <masak> but theoretically it could, right?

[08:11] <masak> I mean, some of the checks, constants and stuff

[08:11] <moritz_> partially, yes

[08:11] <masak> my @a[10]; say @a[15] # BAM

[08:12] <moritz_> there are so many checks that could actually made at compile time... I think we won't see very much of this in an initial release, but the compiler will improve for quite some time after the release

[08:12] <moritz_> like compile-time checking for read-only variables

[08:12] <masak> that's fine by me.

[08:12] <masak> just wondering if it was on the table at all

[08:13] <masak> by me, if it can be done at compile time, it should

[08:13] <masak> but I realize it might not be prio before christmas

[08:13] <moritz_> I agree, "fail early" is important

[08:13] <moritz_> just like "use strict;"

[08:15] <moritz_> perl5 doesn't do some checks at compile time because the code might not be reachable

[08:15] <masak> ACK

[08:16] <moritz_> perl5.8.8 -ce ' if (0) { 1/ 0}'

[08:16] <moritz_> Illegal division by zero at -e line 1.

[08:16] <moritz_> perl5.10.0 -ce ' if (0) { 1/ 0}'

[08:16] <moritz_> -e syntax OK

[08:17] *** rindolf joined
[08:17] <moritz_> I haven't made up my mind yet if that's a good thing or not

[08:18] <moritz_> I mean in the case of literal constants it's not a good thing

[08:18] <moritz_> but it allows you to write stuff like 'our $debug = 0; ... if ($debug) { my $ratio = 1 / $debug; ... }

[08:20] <pmurias> masak: the problem with such checks is that there would be false positives

[08:20] <pmurias> with things like eval which can changed everything

[08:26] *** isop joined
[08:26] <pmurias> Perl 6 offers much more dynamism by default than healthy/nessesary but a pragma could be used to force it to compile time

[08:27] *** isop left
[08:28] *** isop joined
[08:28] *** isop left
[08:28] *** isop joined
[08:35] *** barney left
[08:39] *** elmex joined
[08:40] *** fullermd left
[08:54] *** Jamtech_ left
[09:09] *** Alias__ left
[09:12] *** bacek left
[09:14] *** Nebster joined
[09:15] *** rindolf left
[09:20] *** jfredett_ joined
[09:26] *** jfredett1 joined
[09:35] *** jfredett left
[09:38] *** jfredett_ left
[10:07] *** tuxdna left
[10:07] *** tuxdna joined
[10:11] *** pmurias left
[10:12] *** iblechbot left
[10:14] *** [particle] left
[10:16] *** araujo joined
[10:17] *** jfredett1 is now known as jfredett

[10:21] *** hcchien_ joined
[10:23] *** hcchien left
[10:33] *** fullermd joined
[10:33] *** ashizawa left
[10:42] *** kanru2 joined
[10:53] *** Nebster left
[10:53] *** ashizawa joined
[10:55] *** ruoso joined
[11:01] *** wknight8111 joined
[11:01] *** alanhaggai left
[11:22] *** chris2 joined
[12:11] *** iblechbot joined
[12:12] *** pmurias joined
[12:12] <pmurias> ruoso: hi

[12:14] <pmurias> ruoso: where should namespace creation/destruction live?

[12:16] <pmurias> i can't put it in the init/destroy sequence as it needs a interpreter

[12:26] <pugs_svn> r21372 | jnthn++ | [spectest] Tests for anonymous classes.

[12:27] <rakudo_svn> r29580 | jonathan++ | [rakudo] Implement anonymous classes.

[12:38] <masak> TimToady: can there be anon grammars?

[12:41] <pmurias> masak: why not?

[12:41] <masak> pmurias: I also don't see why not, but the spec is silent on that point

[12:41] <masak> same with modules, but in that case my intuition says there shouldn't be anon modules

[12:42] <masak> also, this is not a case where spec-doesn't-say-so-same-as-p5 applies

[12:42] <pmichaud> why shouldn't we have anonymous modules?

[12:43] <masak> I don't know... because modules are containers, and if you can't refer to the container by name, it's pretty useless?

[12:43] <masak> I might be wildly wrong, though

[12:44] <pmurias> masak: they would parse at least if it weren't for a bug in STD/gimme5

[12:45] <masak> pmurias: could one imagine a use case for them?

[12:45] <pmurias> masak: for anon grammars?

[12:45] <masak> modules

[12:45] <pmurias> mixing them in

[12:46] <masak> hm

[12:47] <pmurias> mixing them in refered to grammars

[12:47] <pmurias> masak: you can use anon modules the same as normal ones

[12:47] <pmurias> i guess

[12:47] <masak> but you cannot refer to them

[12:47] <masak> or can you?

[12:47] <pmurias> if you have them in a scalar, why not?

[12:48] <masak> ah

[12:48] <masak> right.

[12:48] <masak> so anon grammars/modules are ok, then

[13:01] <pmurias> ruoso: should the root namespace be global or per interpreter?

[13:06] *** cmarcelo joined
[13:13] *** Arathorn joined
[13:13] <Arathorn> hi all - don't suppose anyone knows if anyone's already expressed the RFC822 address syntax as perl6 rules?

[13:18] <pmurias> Arathorn: hi, want to try?

[13:20] <Arathorn> hehe

[13:20] <Arathorn> guess I could - was more wondering whether there was prior art

[13:21] <ruoso> pmurias, we could start a prelude interpreter

[13:21] <lambdabot> ruoso: You have 2 new messages. '/msg lambdabot @messages' to read them.

[13:23] <ruoso> pmurias, the global namespace needs to be present as C symbol... for boostrap reasons

[13:24] <pmurias> prelude interpreter - explain please

[13:25] <pmurias> ruoso: i can create the global namespace withough a interpreter, but i need one to destroy it

[13:25] <pmurias> * withought

[13:27] <ruoso> the point is that at some point, we are going to need a interpreter available to continue the boostrap

[13:27] <ruoso> and even to start another intepreter, eventually

[13:27] <ruoso> so starting a interpreter would be part of the prelude, the same way the global namespace would

[13:27] <pmurias> so there will be a global interpreter

[13:27] <pmurias> ?

[13:28] <pmurias> s/global/main

[13:28] <ruoso> not really main in the sense that everything would depend on it...

[13:28] <ruoso> but that it would be avialable for everyone to use it

[13:28] <ruoso> I mena...

[13:28] <ruoso> mean

[13:29] <ruoso> native types doesn't need an interpreter... 

[13:29] <ruoso> but initializing Object will require

[13:29] <ruoso> that's where the "prelude intepreter" comes in... it can be used by anyone that needs some interpreter 

[13:30] <ruoso> but it doesn't mean that it will be the interpreter used for everything....

[13:30] <ruoso> one could switch interpreters and probably no one would notice

[13:31] <ruoso> but we're probably going to stick with it for now, 

[13:31] <ruoso> at least untill the bootstrap is finished...

[13:31] *** [particle] joined
[13:32] <ruoso> pmurias, does it make sense now?

[13:35] <pmurias> yes

[13:36] <ruoso> the point is... after loading the prelude, the "prelude interpreter" could be used, or some other interpreter could be used instead...

[13:37] <pmurias> wouldn't the "bootstrap interpreter" be a better name?

[13:38] <ruoso> yeah... probably... ;) 

[13:38] * ruoso not really good at naming things...

[13:40] <pmurias> in what variable should the stored, and where should it be created?

[13:49] <ruoso> SMOP__GlobalNamespace?

[13:50] <ruoso> smop_s1p.h?

[13:50] <ruoso> and then it would be created during smop_init()

[13:50] <ruoso> and destroyed during smop_destr()

[13:51] *** isop left
[13:52] *** jiing left
[13:52] <rakudo_svn> r29582 | jonathan++ | [rakudo] role_name goes away, since we want to parse a signature in a role definition, and an expression when it's used with does. This should somewhat simplify things when we implement parametric roles. Note role_name is also gone in STD.pm (though getting to what it has now

[13:52] <rakudo_svn> ..would take a larger refactor).

[13:57] <pmurias> ruoso: i'll implement it

[13:57] <ruoso> pmurias++ cool

[13:59] * ruoso from one workplace to another &

[13:59] *** ruoso left
[14:02] *** rindolf joined
[14:02] *** nothingmuch joined
[14:04] *** ingy left
[14:05] *** pjcj joined
[14:09] *** kane_ left
[14:09] *** hcchien_ is now known as hcchien

[14:09] *** kane_ joined
[14:19] *** alester joined
[14:22] *** wknight8111 left
[14:25] *** cmarcelo left
[14:25] *** cmarcelo joined
[14:28] *** pmurias left
[14:31] <rakudo_svn> r29585 | jonathan++ | [rakudo] Implement .^ (call on metaclass) syntax, with passing the invocant in as a first argument to the metaclass method, as specified in S12.

[14:48] *** eternaleye left
[14:55] *** virbyte left
[14:57] *** hcchien left
[14:58] *** Jamtech joined
[14:59] *** tuxdna left
[15:06] *** ruoso joined
[15:08] *** ashizawa left
[15:10] *** elmex left
[15:12] *** meppl left
[15:14] *** meppl joined
[15:23] *** hercynium joined
[15:28] *** rindolf left
[15:30] *** hcchien joined
[15:35] *** cmarcelo left
[15:37] <masak> perl6: my $var = 0; nothing while $var++ < 3; say "et voilà!"

[15:37] <p6eval> elf 21372: OUTPUT[Undefined subroutine &GLOBAL::nothing called at (eval 119) line 5.␤ at ./elf_f line 3861␤]

[15:37] <p6eval> ..pugs: OUTPUT[et voilà!␤]

[15:37] <p6eval> ..rakudo 29585: OUTPUT[Could not find non-existent sub while␤current instr.: '_block11' pc 71 (EVAL_13:26)␤]

[15:39] *** ludan joined
[15:39] <TimToady> kinda sad that rakudo doesn't tell you the name of the missing sub...

[15:39] <TimToady> also kinda sad that pugs doesn't fail  :)

[15:40] <masak> TimToady: rakudo does tell me the name: 'while'

[15:40] <masak> only it's not supposed to be a missing sub

[15:41] *** |jedai| left
[15:41] *** Exodist joined
[15:41] <rakudo_svn> r29586 | jonathan++ | [rakudo] Move WHENCE related things that were in P6Object.pir into the Rakudo source tree (Object.pir).

[15:41] <masak> and I don't think it's sad that Pugs doesn't fail :)

[15:44] <TimToady> er, you want non-existent subs to silently just do nothing?

[15:46] <pmichaud> rakudo is thinking that 'while' is an undeclared sub

[15:46] <pmichaud> and it's trying to evaluate 'while' so that it can pass the result to 'nothing'

[15:47] <pmichaud> (which is also an undeclared sub, but rakudo hasn't figured that out yet.)

[15:48] *** Gothmog_ left
[15:48] <TimToady> nothing should be taken as a listop, but "while" should terminate its list

[15:48] <masak> pmichaud: but 'nothing' is declared, I found it in the rakudo source

[15:49] <masak> TimToady: I just assumed that Pugs eval-ed it correctly

[15:49] <pmichaud> TimToady: I agree that rakudo probably isn't parsing 'while' correctly.

[15:50] <pmichaud> masak: nothing is declared in the rakudo source? where?

[15:50] <pmichaud> (I don't disagree -- I'm just unaware of it)

[15:50] <masak> pmichaud: src/builtins/control.pir

[15:50] <TimToady> there's nothing in the spec, and who's on first

[15:50] <masak> line 91

[15:51] <masak> TimToady: :)

[15:51] <masak> use/mention

[15:51] <pmichaud> ah, nothing is in S29.  It probably needs to be defined as a named 0-ary, perhaps?

[15:52] <TimToady> interesting--thanks for nothing...

[15:52] <masak> pmichaud: if you point me to something else that is defined as a named 0-ary, I can try to fix it

[15:52] <TimToady> I wonder who put it there

[15:52] <masak> ...and send a patch

[15:52] <pmichaud> masak:  rand

[15:52] <masak> TimToady: probably nobody :)

[15:52] <masak> pmichaud: oki, thanks

[15:52] <pmichaud> masak:  it's in grammar.pg, under  "named_0ary"

[15:52] <masak> goodie

[15:53] <pmichaud> we probably need to revise S29 to use the correct syntax for the named 0-aries

[15:54] <TimToady> and I'm not entirely sure I believe in "nothing" yet

[15:54] <[particle]> consult satre

[15:54] <TimToady> he doesn't exist

[15:55] <[particle]> perhaps godot will drop by

[15:55] <TimToady> I think it has something to do with free will...

[15:56] <[particle]> will is free to leave anytime. heck, sanity has already left.

[15:57] <pmichaud> TimToady: in     "listop while 1;"    --- what in STD.pm causes 'while' to not be treated as a post-declared listop

[15:57] <pmichaud> ?

[16:00] <TimToady> well, if correctly coded, the fact that we have terminator:sym<while> defined

[16:00] <TimToady> but it's possible the listop parser isn't checking correctly since we took the terminator check out of expect_term

[16:01] <pmichaud> right

[16:01] <pmichaud> that's what I was just following

[16:01] <pmichaud> I get listop -> arglist -> EXPR -> expect_term -> noun -> term:name    (or something like that)

[16:02] <pmichaud> I could be missing a step that takes care of it, though.

[16:02] <TimToady> it needs a <!stdstopper> before parsing arglist I think

[16:02] <pmichaud> ah, that would work nicely.

[16:02] *** peeps[work] joined
[16:03] <TimToady> well, probably needs to go into arglist

[16:03] <pmichaud> even better.

[16:03] <TimToady> after .ws

[16:04] <pugs_svn> r21373 | lwall++ | [STD] parse nothing while correctly

[16:04] <TimToady> now to test it  :)

[16:05] <rakudo_svn> r29588 | jonathan++ | [rakudo] Make multi-methods vaguely work (in as far as subs work, anyway).

[16:06] <TimToady> well, STD still parses itself

[16:12] <rakudo_svn> r29589 | jonathan++ | [rakudo] Fix nothing. Patch courtesy of Carl Masak [email@hidden.address] masak++

[16:16] *** justatheory joined
[16:17] *** masak left
[16:19] *** armagad joined
[16:28] *** kanru2 left
[16:39] *** Schwern left
[16:43] *** kanru joined
[16:45] *** GarulfoUnix joined
[16:51] <rakudo_svn> r29590 | jonathan++ | [rakudo] [p6object] Make isa and can in the metaclass take the object to test as a first parameter, as specified in recent-ish S12 updates.

[16:51] *** rindolf joined
[16:53] <pugs_svn> r21374 | lwall++ | [STD] restore missing precedence limiter in arglist

[16:55] *** pmurias joined
[16:56] <pmurias> doesn't do {} fill the role of &nothing?

[16:56] <TimToady> sure, so does ()

[16:56] <TimToady> so does 0, unless you get a "useless use" warning...

[16:56] <[particle]> what about *;

[16:57] <TimToady> that would work, but kinda implies "do whatever", which is more like anything than nothing

[16:57] <pmurias> so why do we need nothing?

[16:57] <TimToady> we don't

[16:57] <pmurias> should i remove it then? ;)

[16:58] <TimToady> it's good for making much ado about :)

[16:58] <TimToady> who put it there in the first place?

[16:58] <[particle]> nobody

[16:58] <[particle]> or was it not me?

[16:59] <TimToady> mugwump, it would appear

[17:00] *** silug joined
[17:00] <[particle]> the villain from down under

[17:01] <pmurias> TimToady: based on svn blame?

[17:01] <pmurias> svn log -r 3270 Functions.pod

[17:01] <TimToady> pmurias: *nod*

[17:01] <pmurias> Hand-over version from Rod Adams

[17:02] <TimToady> well, I think we probably have lots of ways to indicate a noop without it

[17:03] <TimToady> and likely * will turn out to be the canonical way, though maybe not

[17:03] <TimToady> * still counts as something outside of a void context

[17:03] <TimToady> so maybe () is better

[17:04] <TimToady> particularly in a list context that thinks it's collecting all the iteration results

[17:04] <pmurias> 1 while something(); is the perl5 idiom isn't it?

[17:04] <TimToady> which I always though should be 0 while something() instead...

[17:04] <[particle]> i really want to see foo while 1 replaced by foo while true in perl 6 code

[17:04] <TimToady> but 0 is also something in list context, and () isn't

[17:04] <[particle]> (magic numbers)--

[17:05] <[particle]> is false something in list context?

[17:05] <TimToady> yes, any scalar value will be something in list context

[17:06] *** cmarcelo joined
[17:07] *** cosimo left
[17:07] <TimToady> "while true" isn't going to fly

[17:08] <TimToady> true is a unary

[17:09] <rhr> is 'foo loop' allowed?

[17:09] <TimToady> no

[17:09] <Exodist> I am about to write some tests for subroutines, I want to verify the following syntax:

[17:10] <TimToady> rhr: logically it would make sense, but the use cases are rare enough that it would leave lots of people scratching their heads

[17:10] <Exodist> sub hi { say "hi" }

[17:10] <rhr> nod

[17:10] <Exodist> &hi.wrap({ callsame; say "there" })

[17:10] <rakudo_svn> r29591 | jonathan++ | [rakudo] Implement .WHERE.

[17:11] <TimToady> perl6: say *.true

[17:11] <p6eval> elf 21374: OUTPUT[Undefined subroutine &GLOBAL::whatever called at (eval 119) line 3.␤ at ./elf_f line 3861␤]

[17:11] <p6eval> ..pugs: OUTPUT[1␤]

[17:11] <p6eval> ..rakudo 29590: OUTPUT[Statement not terminated properly at line 1, near ".true"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[17:11] <TimToady> pugs has it right there, I think

[17:12] <TimToady> so "while *" works

[17:12] <TimToady> and indicates similar semantics to 'xx *'

[17:13] <[particle]> while * and while () instead of 1 and 0, then

[17:13] *** eternaleye joined
[17:13] <[particle]> it's not any prettier

[17:13] <TimToady> while 0 isn't terribly useful anyway

[17:14] <[particle]> it's used in debugging

[17:14] <TimToady> how is it different from if 0

[17:14] <TimToady> and why not use for ()

[17:14] <[particle]> it's not, but if you want to remove a while statement instead of an if statement...

[17:15] <[particle]> while (0) { #foo < bar) {

[17:15] <TimToady> s/#/#(

[17:16] <[particle]>  /

[17:16] <TimToady> :P

[17:18] <Exodist> perl6: sub hi { say "hi" }; &hi.wrap({ callsame; say "there" }); hi

[17:18] <p6eval> elf 21374: OUTPUT[/home/evalenv/pugs/misc/STD_red/match.rb:141:in `block in to_dump0': undefined method `to_dump0' for true:TrueClass (NoMethodError)␤   from /home/evalenv/pugs/misc/STD_red/match.rb:140:in `each'␤     from /home/evalenv/pugs/misc/STD_red/match.rb:140:in `map'␤       from

[17:18] <p6eval> ../home/evalenv/pugs/mi...

[17:18] <p6eval> ..pugs: OUTPUT[*** No such method in class Sub: "&wrap"␤    at /tmp/VM8YvJ7Dbq line 1, column 22-57␤]

[17:18] <p6eval> ..rakudo 29591: OUTPUT[Method 'wrap' not found for invocant of class 'Closure'␤current instr.: '_block11' pc 27 (EVAL_13:16)␤]

[17:19] <Exodist> now, my question is did I do it wrong, or is it not yet implimented?

[17:20] <TimToady> looks okay to me

[17:20] <Exodist> ty.

[17:21] <TimToady> but what do I know...

[17:24] *** dylanc joined
[17:24] *** dylanc left
[17:24] *** dylanc joined
[17:29] <pugs_svn> r21375 | lwall++ | [Functions.pod] nothing isn't sacred, just use () which is less than nothing

[17:30] *** dylanc is now known as hour[10]

[17:33] *** jhorwitz joined
[17:35] <pugs_svn> r21376 | lwall++ | [nothing.t] nothing here, move along

[17:40] *** araujo left
[17:48] *** kanru left
[17:54] *** REPLeffect joined
[17:55] *** ludan left
[17:58] <Exodist> perl6: sub hi { "Hi" }; ok try { &hi.wrap({ callsame _ " there" }) }; is( hi, "Hi there" )

[17:58] <p6eval> elf 21376: OUTPUT[/home/evalenv/pugs/misc/STD_red/match.rb:141:in `block in to_dump0': undefined method `to_dump0' for true:TrueClass (NoMethodError)␤   from /home/evalenv/pugs/misc/STD_red/match.rb:140:in `each'␤     from /home/evalenv/pugs/misc/STD_red/match.rb:140:in `map'␤       from

[17:58] <p6eval> ../home/evalenv/pugs/mi...

[17:58] <p6eval> ..pugs: OUTPUT[*** No such subroutine: "&ok"␤    at /tmp/eWgbvaRMXS line 1, column 18-62␤]

[17:58] <p6eval> ..rakudo 29591: OUTPUT[Could not find non-existent sub ok␤current instr.: '_block11' pc 40 (EVAL_13:21)␤]

[17:58] *** alanhaggai_ joined
[17:59] <Exodist> perl6: sub hi { "Hi" }; try { &hi.wrap({ callsame _ " there" }) }; say $@; hi;

[17:59] <p6eval> elf 21376: OUTPUT[Parse error in: /tmp/jRDtK8SSv8␤panic at line 1 column 60 (pos 60): Can't understand next input--giving up␤WHERE: p({ callsame _ " there" }) }; say $@; hi;␤WHERE:                              /\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in

[17:59] <p6eval> ..`scan_unitstopper'␤...

[17:59] <p6eval> ..pugs: OUTPUT[*** ␤    Unexpected "@;"␤    expecting "::"␤    at /tmp/GbeCDqe8Lf line 1, column 66␤]

[17:59] <p6eval> ..rakudo 29591: OUTPUT[Statement not terminated properly at line 1, near "$@; hi;"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[17:59] <Exodist> perl6: sub hi { "Hi" }; try { &hi.wrap({ callsame _ " there" }) }; hi;

[17:59] <p6eval> elf 21376: OUTPUT[/home/evalenv/pugs/misc/STD_red/match.rb:141:in `block in to_dump0': undefined method `to_dump0' for true:TrueClass (NoMethodError)␤   from /home/evalenv/pugs/misc/STD_red/match.rb:140:in `each'␤     from /home/evalenv/pugs/misc/STD_red/match.rb:140:in `map'␤       from

[17:59] <p6eval> ../home/evalenv/pugs/mi...

[17:59] <p6eval> ..pugs: RESULT["Hi"]

[17:59] <p6eval> ..rakudo 29591: RESULT["Hi"]

[18:01] *** alanhaggai_ is now known as alanhaggai

[18:03] <Exodist> perl6: say "hi" ~ " there";

[18:03] <p6eval> elf 21376: OUTPUT[hi there␤]

[18:03] <p6eval> ..pugs: OUTPUT[hi there␤]

[18:03] <p6eval> ..rakudo 29591: OUTPUT[hi there␤]

[18:04] <Exodist> perl6: say "hi" _ " there";

[18:04] <p6eval> elf 21376: OUTPUT[Parse error in: /tmp/mn9q5hjWhA␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say "hi" _ " there";␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[18:04] <p6eval> ..STD_red/std.rb:...

[18:04] <p6eval> ..pugs: OUTPUT[*** ␤    Unexpected "_"␤    expecting operator, ":" or ","␤    at /tmp/DrqHZnUtPX line 1, column 10␤]

[18:04] <p6eval> ..rakudo 29591: OUTPUT[Statement not terminated properly at line 1, near "_ \" there\""␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[18:04] *** kanru joined
[18:04] <TimToady> wow, ancient history...

[18:04] <Exodist> is there a way to use the eval there w/o flooding the channel?

[18:04] <TimToady> maybe with /mst

[18:04] <TimToady> er, /msg

[18:05] <Exodist> TimToady: Yeah, I am just starting on perl 6, today is my first time tryint o write any.

[18:05] <TimToady> cool.  do you have a pugs commit bit yet?

[18:05] <Exodist> yes, I got it last week.

[18:05] <Exodist> My company is giving me 4 hours a week to work on perl6.

[18:06] <TimToady> sugoi

[18:06] <Exodist> I plan to write tests since my C is probably not up to working on rakudo.

[18:06] <Exodist> perl is my lang of choice for a few years now.

[18:06] <TimToady> how's your Haskell ;)

[18:06] <Exodist> nonexistant.

[18:06] <Exodist> :-/

[18:07] <TimToady> Haskell is easy to learn--I've done it several times now

[18:07] <TimToady> I just have a personality conflict with its compiler...

[18:07] *** alanhaggai_ joined
[18:08] <Exodist> I had a hard time getting the compiler installed, on gentoo (my distro of choice) or ubuntu (work distro)

[18:08] <TimToady> anyway, we certainly need more tests

[18:08] *** alanhaggai left
[18:08] <TimToady> I got the cabal version installed on ubuntu this week

[18:08] <Exodist> I spent 2 weeks trying to get pugs going before giving up and making rakudo work in an hour.

[18:08] <Exodist> *2 weeks off and on.

[18:09] <TimToady> I had to make one tweak to get zlib to use the provided version rather than the system version, and then cabal works okay

[18:10] <Exodist> hmm, I may give it another try at some point here. but for now I am trying to figure out how these spec tests work... all my attempts at any kind of eval or try are giving me errors about unterminated lines.

[18:10] <Exodist> but others I did not write are giving me the same... is this a rakudo thing?

[18:10] <TimToady> that tends to be the default error message

[18:11] <Exodist> it seems that it does not finish parsing the line before bailing.

[18:11] <Exodist> t/spec/S06-advanced_subroutine_features/wrapping.t....Statement not terminated properly at line 9, near "try({ &hi."

[18:11] <TimToady> the way the parser works, if something fails but doesn't give an immediate error, it backs off and then stalls out in the middle of the statement, yielding that error

[18:11] <Exodist>   9 try({ &hi.wrap({ callsame ~ " there" }) });

[18:11] <TimToady> STD has the same difficulty

[18:11] <Exodist> hmm.

[18:11] *** r0bby left
[18:12] <TimToady> with STD I look at the log to see what the high-water mark was, but we'll have to get better control of reporting what was expected and not found

[18:12] <Exodist> 'the log'?

[18:13] <TimToady> when you parse with STD.pm you can get it to spit out a debugging log, but it's about 10 times slower that way

[18:14] <Exodist> hmm, is this documented somewhere? I could use a good doc on test procedures and such.

[18:14] * Exodist feels like a newb.

[18:14] <TimToady> STD.pm is independent of rakudo

[18:14] *** cjfields joined
[18:14] <TimToady> (so far)

[18:14] <TimToady> except that rakudo's grammar is converging on STD, more or less

[18:15] <TimToady> so don't worry about that part, if you're concentrating on parrot

[18:15] <Exodist> ok.

[18:16] <TimToady> I'll need to think about how to get better errors in STD, and then that will probably get into rakudo at some point

[18:18] <Exodist> perl6: sub hi { "Hi" }; try{ &hi.wrap({ callsame ~ " there" }) };

[18:18] <p6eval> elf 21376: OUTPUT[/home/evalenv/pugs/misc/STD_red/match.rb:141:in `block in to_dump0': undefined method `to_dump0' for true:TrueClass (NoMethodError)␤   from /home/evalenv/pugs/misc/STD_red/match.rb:140:in `each'␤     from /home/evalenv/pugs/misc/STD_red/match.rb:140:in `map'␤       from

[18:18] <p6eval> ../home/evalenv/pugs/mi...

[18:18] <p6eval> ..pugs: RESULT[undef]

[18:18] <p6eval> ..rakudo 29591: RESULT[Null PMC access in find_method()␤current instr.: '_block11' pc 25 (EVAL_13:12)␤]

[18:18] <Exodist> perl6: sub hi { "Hi" }; try{ &hi.wrap({ callsame ~ " there" }) }; hi;

[18:18] <p6eval> elf 21376: OUTPUT[/home/evalenv/pugs/misc/STD_red/match.rb:141:in `block in to_dump0': undefined method `to_dump0' for true:TrueClass (NoMethodError)␤   from /home/evalenv/pugs/misc/STD_red/match.rb:140:in `each'␤     from /home/evalenv/pugs/misc/STD_red/match.rb:140:in `map'␤       from

[18:18] <p6eval> ../home/evalenv/pugs/mi...

[18:18] <p6eval> ..pugs: RESULT["Hi"]

[18:18] <p6eval> ..rakudo 29591: RESULT["Hi"]

[18:19] *** zostay joined
[18:21] * Exodist hits himself hard... he forgot a semiclon on the previous line... been a long time since I had this much trouble from something that simple.

[18:21] <Exodist> it also explains why it worked in here...

[18:30] <pmurias> Exodist: re rakudo, C-fu is not really a topmost priority when working on rakudo

[18:30] <Exodist> pmurias: I am listening.

[18:31] <pmurias> a high-pir tolerance and an ability to read the synopsis should be enough

[18:31] <Exodist> high-pir?

[18:31] <pmurias> a high pir tolerance, sorry ;)

[18:31] <Exodist> pir?

[18:31] <pmurias> pir is parrot assembler

[18:31] * Exodist pulls up google+wikipedia

[18:32] <Exodist> ah, ok.

[18:33] <Exodist> hmm, I will read this tutorial and see if I can get into Rakudo coding.

[18:34] <Exodist> oh, this tutorial: http://www.perlfoundation.org/parrot/index.cgi?pir_tutorial_and_faq

[18:34] <lambdabot> Title: PIR Tutorial and FAQ / Parrot, http://tinyurl.com/5mhdqv

[18:34] <Exodist> unless you have a better reference.

[18:34] <pmurias> i'm not a parrot guy

[18:35] <pmurias>  i hate pir ;)

[18:36] <Exodist> so what do you normally work on?

[18:36] <pmurias> smop now

[18:37] <pmurias> it's a sort of parrot alternative

[18:38] <Exodist> reading this: http://www.perlfoundation.org/perl6/index.cgi?smop

[18:38] <lambdabot> Title: SMOP / Perl 6

[18:38] <pmurias> and did some work on elf previously which is a partialy bootstraped perl6 implementation

[18:40] <Exodist> hmm, maybe I should ask this: "I am a perl guy, my other languages have been neglected greatly, and my skillsets in them were probably not all that high to begin with. I want to work on and contribute to perl 6, what is the best place for me?"

[18:40] <pmurias> either rakudo or elf

[18:42] <Exodist> have a link for 'elf'?

[18:42] <pmurias> misc/elf in the pugs repo

[18:44] <pmurias> you could hack on elf only coding in perl5 and perl6, but rakudo has more monumentum

[18:46] * Exodist is reading the elf README... scary.

[18:47] <pmurias> a bit skimpy

[18:48] <pmurias> Exodist: re scary, an questions?

[18:49] <Exodist> no, I just had a hard tiem reading it for some reason, probably long week + no sleep + info overload + full moon.

[18:51] <Tene> Exodist: probably rakudo.

[18:51] *** chris2 left
[18:52] <Exodist> yeah, I am reading the PIR tutorial again, I am probably gonna stick to tests for a bit, but I took an assembly class forever ago, I might be able to dive in again.

[18:53] <pmurias> pir isn't really a traditional assembler, it dosn't have all the memory manipulation

[18:55] <Exodist> thats ok, I never got into assembly enough to have anything in memory to get int he way.

[18:56] <Tene> Exodist: you should be able to pick it up pretty quick by looking at a few examples.  It's a pretty simple language.

[18:56] <pmurias> s/simple/silly/ ;)

[18:57] <[particle]> it's a low-class language, for sure

[18:57] <[particle]> look in examples/tutorial/

[18:58] <pmurias> i prefer it to sm0p however

[18:58] *** alanhaggai_ left
[18:58] *** alanhaggai_ joined
[19:02] <pmurias> but sm0p is a DSL only

[19:04] *** alanhaggai_ is now known as alanhaggai

[19:07] <Exodist> thanks for all the suggestions guys.

[19:12] *** wknight8111 joined
[19:14] <pugs_svn> r21377 | pmurias++ | [smop]

[19:14] <pugs_svn> r21377 | pmurias++ | root namespace

[19:14] <pugs_svn> r21377 | pmurias++ | global interpreter (causes horrible leakage, when i try to destroy it spits out segfaults)

[19:14] <pugs_svn> r21377 | pmurias++ | some work on p6opauque

[19:15] <pmurias> ruoso: i get a segfault when it RELEASE the global interpreter

[19:20] <ruoso> pmurias, /me checking

[19:21] <pmurias> thanks

[19:22] *** armagad left
[19:26] <ruoso> pmurias, test/12 is still valid?

[19:27] <ruoso> pmurias, the same for test/14

[19:27] <ruoso> it seems you removed the .sm0p, but kept the test...

[19:28] <pmurias> i move tests 12 and 14 to misc

[19:28] <ruoso> alright...

[19:28] <ruoso> I removed the compiled tests 12 and 14 and have no more segfaults

[19:28] <ruoso> they were using the old version of p6opaque

[19:29] <ruoso> (but that was there only by a missing make clean on my part)

[19:29] <pmurias> ruoso: i commented the segfault causing part

[19:29] <pmurias> in smop.c

[19:29] <pmurias> sorry

[19:30] <ruoso> oh... ok

[19:31] <pmurias> as i considered memory leaks less serious

[19:38] *** hercynium left
[19:39] *** destiney joined
[19:41] <Exodist> using Rakudo perl6, hwo would one run the tests verbosely? liek the -v flag for prove?

[19:43] <Tene> easiest is just parrot perl6.pbc t/the/test.pl

[19:46] <ruoso> pmurias, the main issue is that the global interpreter still holds a reference to the last frame at that time

[19:47] <pmurias> looking

[19:47] *** wknight8111 left
[19:47] <Exodist> Tene: thank you.

[19:47] *** cjfields is now known as perl6

[19:48] *** perl6 is now known as cjfields

[19:49] <pmurias> ruoso: how can we fix it?

[19:49] <ruoso> pmurias, I'm experimenting one thing

[19:49] <ruoso> there's a shutdown sequence issue

[19:52] <ruoso> there's something that depends on hash that is being held until after the hash RI is destroyed.

[19:53] <ruoso> I think we need to make an extra boot phase

[19:55] <pmurias> loads RIs and then setup objects

[19:56] * ruoso have an almost working version

[19:58] <pugs_svn> r21378 | ruoso++ | [smop] define yet another boot phase in smop, one that can count on a interpreter...

[19:59] <ruoso> pmurias, take a look now...

[19:59] <ruoso> now there's a single s1p hash leaking

[20:01] <pmurias> ruoso: looking/fixing

[20:01] <ruoso> pmurias, I've just changed a bit the indentation in root_namespace.c

[20:01] <pugs_svn> r21379 | ruoso++ | [smop] a little more indentation in root_namespace.c

[20:02] <ruoso> pmurias, you should only RELEASE the object *after* using it...

[20:02] <ruoso> you might get your object destroyed before you want to...

[20:03] <pmurias> i can't RELEASE a brand new object?

[20:03] *** r0bby joined
[20:04] <pmurias> (if i don't use it)

[20:04] <ruoso> if you don't... yes...

[20:05] * ruoso referring to the RELEASE call on the top of the hash message

[20:05] <ruoso> pmurias, btw... you're not using locks

[20:06] <pmurias> oops

[20:07] <ruoso> pmurias, is there anyone using the global namespace already?

[20:08] <pmurias> a test

[20:08] <ruoso> hmm

[20:08] <pmurias> * a lame test

[20:08] <ruoso> then it doesn't make sense for it to be leaking in every test

[20:08] <ruoso> weid

[20:08] <ruoso> wird

[20:08] <ruoso> weird

[20:08] <pmurias> ruoso: RELEASE's have to be before the loop?

[20:08] <ruoso> gah

[20:08] *** araujo joined
[20:08] <ruoso> yes

[20:08] <pmurias> it's released after

[20:09] <ruoso> cool

[20:09] <ruoso> that's it

[20:09] <pmurias> how should the new destruction pass be names

[20:09] <pmurias> * named

[20:10] <pmurias> ?

[20:10] <pugs_svn> r21380 | ruoso++ | [smop] the interpreter loops through the rest of the continuations before finishing the GlobalInterpreter

[20:10] <ruoso> I called it  SMOP_BOOTSTRAP_INIT_SEQUENCE

[20:10] <ruoso> they're defined in smop.c and smop_internal.

[20:10] <ruoso> h

[20:11] <ruoso> YAY! no more leaks

[20:11] * ruoso turning into a good plumber

[20:14] <pmurias> ruoso++ 

[20:15] <pmurias> do you too see [bool] "has_next" is not implemented in bool.?

[20:17] <ruoso> pmurias, yes...

[20:17] <ruoso> there are some places setting a bool as the continuation...

[20:17] <ruoso> we need a "empty continuation"

[20:17] <ruoso> that simply returns false to "has_next"

[20:17] <ruoso> it can be constant...

[20:22] <pmurias> a continuation isa a Frame currently?

[20:22] <ruoso> continuation isa anything... ;)

[20:23] <ruoso> "Polymorphic Eval"

[20:23] * ruoso adding a trick to make goto false as goto nowhere...

[20:24] <pugs_svn> r21381 | ruoso++ | [smop] goto(bool) means release the current continuation

[20:24] <pmurias> ruoso: assuming we use our only runloop slime

[20:25] <ruoso> pmurias, what do you mean?

[20:25] <ruoso> wow... all tests passing, no warnings...

[20:25] <ruoso> I haven't seen this outcome in "make test" for a long time ;) ;)

[20:26] *** alanhaggai_ joined
[20:28] <ruoso> pmurias, how hard you think it would be to bring .^!how back to p6opaque?

[20:28] <pmurias> ruoso: i meant what does SLIME use as it's continuations, Frames

[20:28] <ruoso> yes... SLIME uses Frames

[20:28] <pmurias> $obj.^!how = $foo;

[20:28] <ruoso> but it should not assume the continuations to be frames...

[20:29] <ruoso> pmurias, yes...

[20:29] <pmurias> the assignment itself would be trivial

[20:29] <ruoso> pmurias, so we can take back the metaclass delegation for method dispatch

[20:30] <ruoso> see misc/p6opaque.sm0p:176

[20:33] <pugs_svn> r21382 | pmurias++ | [smop] p6opaque.how

[20:36] <pugs_svn> r21383 | ruoso++ | [smop] SMOP_REFERENCE how before returning

[20:36] <ruoso> pmurias, have you seen how to use the locking?

[20:36] <ruoso> it's simple as three functions in the API

[20:36] *** alanhaggai_ left
[20:36] <pmurias> reading...

[20:36] *** alanhaggai left
[20:36] <ruoso> smop_lowlevel_rdlock(value), smop_lowlevel_wrlock(value) and smop_lowlevel_unlock(value)

[20:36] *** alanhaggai_ joined
[20:37] <ruoso> it's a simple interface to the pthread rwlock

[20:37] <pugs_svn> r21384 | fglock++ | moved local tests to t/v6-pm/; added t/spec/, etc  # 408 tests pass

[20:37] * ruoso knows STM is cooler, but is not that smart...

[20:39] <pmurias> STM is more complicated for sure

[20:39] *** Alias_ joined
[20:40] <pmurias> fglock has revived v6.pm?

[20:42] <ruoso> pmurias, you're creating both the metadata and instance for every p6opaque

[20:42] <ruoso> you don't need to

[20:42] <ruoso> you just need to create it as it is needed...

[20:42] <ruoso> because instance values are not going to have metadata (usually)

[20:43] <ruoso> as well as protoobjects are not going to have instance data...

[20:44] <ruoso> pmurias, I've added a few items that were missing in p6opaque structure

[20:44] <pugs_svn> r21385 | ruoso++ | [smop] completing p6opaque structure definition...

[20:45] <pmurias> ruoso: wouldn't just sharing the metadata pointer be better for class based objects?

[20:46] <ruoso> pmurias, maybe, but that's not what Perl 6 spec says...

[20:47] <pmurias> got the precise quote?

[20:48] <ruoso> all the HOW and WHAT thing...

[20:48] <ruoso> if we make the metadata as HOW, we make prototype-based OO impossible with p6opaque

[20:49] <ruoso> HOW is just one of the metadata items p6opaque hs

[20:49] <pmurias> p6opaque is for class oo only

[20:49] <ruoso> not really...

[20:49] <ruoso> that's not up to p6opaque to define

[20:50] <ruoso> p6opaque should support both

[20:50] <ruoso> (and in fact, the current design in smop does)

[20:51] <pmurias> re p6opaque is ..., maybe is misrembered it's lateish

[20:52] <pugs_svn> r21386 | exodist++ |  * Initial tests for function wrapping.

[20:52] <ruoso> pmurias, actually I'm not sure the spec defines that... 

[20:52] <ruoso> pmurias, but I would be really sad on forcing only class-based OO in p6opaque

[20:52] <Exodist> woohoo, my first commit to perl6 :-)

[20:52] <ruoso> Exodist++

[20:52] * ruoso home &

[20:52] * ruoso 'll try to log in later... but he certainly need some beers...

[20:53] <pmurias> ruoso: instanceof is an Array?

[20:53] <ruoso> pmurias, nope... 

[20:53] <ruoso> it points to a direct protoobject

[20:53] <pmurias> you have multiple of those in prototype-oo

[20:53] <pmurias> otherwise it's just poor man's class based oo

[20:54] <pmurias> like in javascript

[20:54] <ruoso> pmurias, yes yes... and that's why you have isa and does

[20:54] <ruoso> you can do it pure prototype

[20:54] <ruoso> but when it's prototype by delegatoin

[20:54] *** donaldh joined
[20:54] <ruoso> you can say that this object delegates entirely to *that* prototype

[20:55] <pmurias> il think about it tommorow

[20:55] * ruoso have people waiting for him...

[20:55] <pmurias> * i'll

[20:55] * ruoso later &

[20:55] *** ruoso left
[20:56] *** pmurias left
[20:59] *** Alias__ joined
[20:59] *** Alias_ left
[21:02] *** jhorwitz left
[21:10] *** Jamtech left
[21:11] <rakudo_svn> r29594 | chromatic++ | [Rakudo] Fixed a POD error in Object.

[21:13] <pugs_svn> r21387 | exodist++ |  * Added temporization test on wrapping.

[21:13] <pugs_svn> r21387 | exodist++ |  * Added tests for unwrapping a sandwitched wrapper.

[21:13] *** alester left
[21:17] *** iblechbot left
[21:19] *** rindolf left
[21:22] *** Kattana_ joined
[21:22] *** Kattana_ left
[21:25] *** wknight8111 joined
[21:52] *** ingy joined
[21:57] *** GarulfoUnix left
[21:59] <rakudo_svn> r29598 | jonathan++ | [rakudo] Implement WHICH in object. We now need to override it in the various value types, and then we can implement ===.

[22:00] *** destiney left
[22:02] *** eternaleye left
[22:04] *** cjfields left
[22:07] *** Limbic_Region joined
[22:12] *** jferrero joined
[22:21] *** REPLeffect left
[22:22] *** REPLeffect joined
[22:23] *** donaldh left
[22:32] *** eternaleye_ joined
[22:39] <pugs_svn> r21388 | fglock++ | [v6.pm] fixed block interpolation in string

[22:40] *** peeps[work] left
[22:44] *** mncharity joined
[22:44] <pugs_svn> r21389 | putter++ | [misc/elfish/rx_on_re] No longer segfaults.

[22:44] <pugs_svn> r21389 | putter++ | The bootstrap grammar for p5 re modifiers uses a (?{helper($^N)}),

[22:44] <pugs_svn> r21389 | putter++ | which then called a split().  split() within regexps is a known

[22:44] <pugs_svn> r21389 | putter++ | locus of corruption.  As now.  Thankful kudos to moritz_++ TimToady++.

[22:46] <mncharity> I would have thought rx_on_re was (?{}) (??{}) free.  Turned out the grammar for p5 regexps used a (?{}) helper sub.  Which then lived dangerously with a split().

[22:46] <lambdabot> mncharity: You have 1 new message. '/msg lambdabot @messages' to read it.

[22:46] <mncharity> Thanks all.

[22:46] *** jferrero left
[22:47] *** mncharity left
[22:56] *** ikeda joined
[23:03] *** Exodist left
[23:08] *** smtms left
[23:11] *** eternaleye_ left
[23:11] *** eternaleye_ joined
[23:17] *** cmarcelo left
[23:21] *** hour[10] left
[23:31] <s1n> moritz_: should I skip and/or not add any tests using .perl, even if they pass?

[23:31] <s1n> Auzon: same question for you

[23:32] <s1n> .perl isn't specced, but in many cases it works

[23:32] *** peeps[work] joined
[23:33] <s1n> that is, this will pass: is (1..5).perl, '1..5', ".perl ..";

[23:47] *** icwiener joined
