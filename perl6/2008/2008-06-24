[01:03] *** ilogger2 joined
[01:09] <Tene> pugs: @a = gather { for 1..10 { take $_ * 2 } }; say @a;

[01:09] <p6eval> OUTPUT[*** ‚ê§    Unexpected " ="‚ê§    expecting "::"‚ê§    Variable "@a" requires predeclaration or explicit package name‚ê§    at /tmp/dkcGvfLLXY line 1, column 3‚ê§]

[01:09] <Tene> pugs: my @a = gather { for 1..10 { take $_ * 2 } }; say @a;

[01:09] <p6eval> OUTPUT[2468101214161820‚ê§]

[01:15] <pugs_svnbot> r20981 | diakopter++ | [yap6] fixes from 'use diagnostics'

[01:15] <pugs_svnbot> r20982 | diakopter++ | [yap6]

[01:15] <pugs_svnbot> r20982 | diakopter++ | * bin/test doesn't need 'use diagnostics' committed...

[01:25] * diakopter read today about scattered context grammars (for context-sensitive languages) and how they enable semantic analysis (and type checking) specified directly in the grammar to be performed at parse time.  interesting stuff.

[01:34] *** alester joined
[01:36] <scrottie> hey, alester, why did you delete  http://www.flickr.com/photos/petdance/2588945466/ ?

[01:36] <lambdabot> Title: Flickr: Image

[01:36] <scrottie> Am I really that ugly?

[01:36] <alester> what was it?

[01:36] <scrottie> me!

[01:36] <scrottie> you deleted me, you bastard!

[01:36] <alester> I did?

[01:37] <alester> I'm sorry, I had to prune down to 200 total

[01:37] <alester> where were you?

[01:37] * scrottie vanishes in a puff of filesystem block reallocation.

[01:37] <alester> pool table?

[01:37] <scrottie> bowling, probably

[01:37] <lichtkind> wknight8111: sorry i ment leave

[01:37] <lichtkind> do have leave an impact to gather too?

[01:38] <alester> Black shirt, glasses?

[01:38] <alester> 10 pound blue ball?

[01:38] <scrottie> yeah.  red hair, lots of forehead.

[01:38] <alester> what's yr email

[01:38] <scrottie> my god... you know, I picked out two blue balls just so I could make jokes about it.  but I think I've used them all up.

[01:38] <scrottie> [email@hidden.address]
[01:39] <scrottie> if you're going to take lots of good pics (of my good side) at YAPC, I think we could chip in for a paid flickr account.  assuming that's the reason you had to prune.

[01:39] <alester> Flickr only lets me have 200 photos in all

[01:39] <alester> yes, that's why

[01:39] <scrottie> even if you give them money?

[01:39] <scrottie> taking photos is a public service and should be encouraged.

[01:39] <alester> No, I just didn't hve a pro account

[01:39] <alester> Next time I'll put 'em on Picasa.

[01:40] <scrottie> I'll try to remember to mention this again come next year.

[01:40] <scrottie> or that =)

[01:43] <alester> OK, exporting 113 photos to Picasa.

[01:49] <pugs_svnbot> r20983 | Auzon++ | [gsoc_spectest] fixed eager_hyper.t to use gather/take as suggested by moritz++ (removed 2 tests; only 6 tests in this file now)

[01:49] <scrottie> thanks for the copy of the pic.  and that's not just any black shirt... that's my SNOBOL 4 shirt!

[02:05] <alester> scrottie: http://picasaweb.google.com/petdance/YAPCNA2008TheRawFeed

[02:05] <lambdabot> Title: Picasa Web Albums - Andy - YAPC::NA 2008...

[02:09] *** jjore joined
[02:14] * diakopter fiddles with Devel::Pointer::PP

[02:23] <diakopter> ... and is delighted to discover [the technique in] Sub::Become

[02:56] *** jjore left
[02:59] <alester> http://perlbuzz.com/2008/06/yapcna-2008-photo-wrapup.html

[02:59] <lambdabot> Title: YAPC::NA 2008 photo wrap-up - Perl Buzz

[02:59] <alester> hey!

[02:59] <alester> diakopter!

[02:59] <alester> I don't remember what you look like!

[02:59] <alester> But I DO remember you sat to my right at lunch!

[03:00] <alester> Isn't it funny how my brane works?

[03:05] *** Alias_ joined
[03:06] <SamB> alester: but do you remember what he ate?

[03:06] <alester> I think it was a sandwich on some sort of white hearty bread.

[03:12] <ingy> scrottie: hola

[03:13] <Alias_> o/

[03:13] <ingy> hi Alias_ 

[03:16] <s1n> diakopter: where's the smoke tests in the pugs repo?

[03:17] <ingy> &

[03:19] <Auzon> s1n: pugs/t contains the Perl 6 test suite if that's what you mean

[03:19] <s1n> Auzon: that's what i thought, it just wasn't really documented as such

[03:19] <diakopter> s1n: and there are quite a few ways to smoke the test suite... each implementation does it uniquely

[03:20] <diakopter> meaning Test.pm

[03:20] <Auzon> Note that we're trying to move most of pugs/t to pugs/t/spec

[03:20] *** apeiron joined
[03:20] <diakopter> alester: yeah

[03:20] <s1n> okay, well i just want to get a devenv setup tonight

[03:21] <s1n> i checked out the pugs code, i have parrot building, what's the most advisable way of testing / modifying / adding a test to the suite?

[03:23] <s1n> since i did a make spectest in the rakudo directory, it checked out the tests, i should be able to make changes / commits in the "t/spec" folder, right?

[03:24] <diakopter> s1n: yes.  Try to follow the existing pattern of tagging with a region of the relevant synopsis.  if you make an error in your commit, I'm sure someone will notice and correct it :)

[03:24] <s1n> well, i may pastebot a patch or two until i get the hang of it

[03:25] <s1n> every company and project has their way of developing, so i'd rather just get a feel for it first :)

[03:25] <diakopter> s1n: but also make sure to get familiar with the t/everything-but-spec so that you don't duplicate what's waiting-to-be-migrated-to-spec

[03:26] <s1n> diakopter: gotcha

[03:26] *** BinGOs joined
[03:26] <diakopter> Auzon: any comments/corrections to what I said?

[03:26] <Auzon> s1n: sure you can pastebot, but we're very forgiving in pugs/

[03:27] <Auzon> Um... get and use 'ack'

[03:27] <s1n> diakopter: again, since i'm new to this codebase, i'll take my time learning it's ins and outs, so i'll try not to commit anything without someone checking it over for a few commits

[03:27] <s1n> i'm a perfectionist, i'd rather do it right or not do it at all

[03:27] <Auzon> I guess you can use egrep if you know its patterns better than the Perl ones

[03:28] <s1n> Auzon: i won't waste my time grepping through things, i'll see if i can get some useful ctags built

[03:28] <diakopter> s1n: that's a little difficult when the line between perfect and pluperfect is pretty fuzzy (around here)

[03:28] <Auzon> ctags?

[03:28] <s1n> Auzon: google it, it can save you time :)

[03:29] <s1n> i don't write any typed language code without it, scripting is a little different (have to kinda nudge it along)

[03:30] <s1n> diakopter: well, yeah i realize i won't be perfect, but i want what i do first to seem that way, until i improve and what i did yesterday suddenly looks like crap :)

[03:30] <diakopter> s/pluperfect/something else/

[03:31] <DietCoke> parrot has tags targets.

[03:32] <s1n> DietCoke: yeah but does perl6 / rakudo?

[03:32] <s1n> parrot is more strongly typed

[03:32] <diakopter> heh

[03:33] <s1n> Ôªøalright guys, since i'm ready to start playing with it, ima call it a night. i'll dink with some of the tests and see if i can get ctags built

[03:33] <diakopter> good luck

[03:34] * diakopter declares #perl6,p6l,@Larry to be autopoietic

[03:38] <diakopter> alester: where's that mailing list you mentioned

[03:39] <alester> rethinking-cpan

[03:39] <alester> gogole it

[03:40] <diakopter> good thing gogole goes to google

[03:40] *** a-jing joined
[03:40] *** a-jing left
[03:42] <diakopter> alester: is it intentional that perl101 is perl5 to binary

[03:42] <alester> ?

[03:42] <diakopter> perl101.org

[03:42] <diakopter> never mind

[03:43] <alester> I don't understand what you mean "perl5 to binary"

[03:44] <Auzon> 5 in binary is 101

[03:48] <alester> ah

[03:48] <diakopter> someone should make Acme::Godel, a source filter that gives you the Godel number of the source code (or maybe even the bytecode) of the script that uses it.  just gets the nth prime where n is the number represented by the program's something-endian source/bytecode representation.  okay, so probably it would never terminate on most inputs....

[03:48] <Auzon> s1n: I don't see how ctags would help me figure out, for instance, if ^..^ was tested. Where running "ack '^\.\.^' t/" would locate them if they exist

[03:48] <alester> because they're prefound, Auzon.

[03:48] <alester> And you can then do stuff like "vim -t tag"

[03:49] <SamB> diakopter: what does a prime number have to do with it?

[03:49] <diakopter> SamB: isn't that how Godel represented the symbols in the formal languages he was analyzing?

[03:50] <SamB> diakopter: there was no prime number

[03:50] <Auzon> alester: I ran ctags on one of my Perl 5 projects, and it just found the subroutine names and package names. Did I miss something?

[03:50] <diakopter> I can't type the o with dots

[03:50] <diakopter> SamB: oh

[03:50] <alester> Look at how ack or WWW-Mechanize do it.

[03:50] <alester> I have a "make tags" target in most of my projects.

[03:50] <SamB> diakopter: just interpret the source file as a little-endian number ...

[03:54] <diakopter> actually it probably would terminate if you split it at bytes... you'd only need up through the 256th prime (1619). (multiply all the primes together to get the Godel number)

[03:54] <diakopter> of course

[03:54] <diakopter> that's wrong, b/c it doesn't preserve order of the bytes

[03:55] <SamB> yeah -- just interpreting it as a radix-256 little-endian number is the thing to do

[03:55] <SamB> or ... well, something like that

[03:56] <SamB> need to indicate termination somehow I guess

[03:56] <SamB> well, that's easy if your programming language doesn't use NULs in source ;-)

[03:58] *** Alias_ left
[03:58] *** Alias_ joined
[04:04] <diakopter> TimToady: SamB requests token nullator:sym<ÔøΩ> { <sym> <?before <sym>> }

[04:05] <SamB> what???

[04:05] <diakopter> ;)

[04:05] <SamB> that isn't a NUL!

[04:06] <diakopter> oh :/

[04:06] <SamB> that's a U+FFFD

[04:06] <diakopter> silly irssi

[04:06] <diakopter> irc probably can't receive it anyway

[04:06] <SamB> probably it would be misinterpreted as a CTCP request

[05:09] <scrottie> Auzon, I seem to recall a "perl tags" package on CPAN.  It outputs files in the ctags format but is a bit smarter about parsing Perl.  Hrm.  PPI... hmm.

[05:13] *** Psyche^ joined
[05:25] *** Psyche^ is now known as Patterner

[05:44] *** eternaleye joined
[05:52] *** jfredett_ joined
[05:53] *** jfredett_ is now known as jfredett

[05:55] <Alias_> Alas, PPI is too slow for most purposes

[05:57] <Alias_> Or at least, too slow for time-critical purposes

[05:57] <scrottie> well, building the tags database is an off-line type activity

[05:57] <scrottie> I guess ctags in general was made for a generally static codebase, not this agile crap the kids are smoking.

[06:10] <Alias_> yup

[06:18] *** luqui joined
[06:21] *** Alias__ joined
[06:23] *** Alias_ left
[06:47] *** alester left
[06:51] *** alester joined
[06:51] *** alester left
[06:59] *** iblechbot joined
[07:06] *** Maghnus joined
[07:08] *** xinming joined
[07:09] *** Maghnus left
[07:12] *** Jedai joined
[07:12] *** Maghnus joined
[07:16] *** masak joined
[07:17] *** Helios` left
[07:17] *** Maghnus left
[07:17] *** Helios` joined
[07:20] *** Maghnus joined
[07:34] *** Alias__ left
[07:48] *** xinming left
[07:49] *** Jedai left
[07:50] *** sri_work joined
[08:02] *** Maghnus left
[08:05] *** Maghnus joined
[08:32] *** IRSeekBot joined
[08:32] *** xinming joined
[08:36] *** elmex joined
[08:46] *** lichtkind joined
[08:53] *** meppl joined
[08:58] *** penk joined
[09:08] *** vixey` joined
[09:09] *** apeiron left
[09:10] *** vixey` is now known as vixey

[09:23] *** bacek joined
[09:30] <pugs_svnbot> r20984 | moritz++ | [spec] fixed eager_hyper.t - $counter++; needs to go before take $_; to get

[09:30] <pugs_svnbot> r20984 | moritz++ | the expected results

[09:33] <pugs_svnbot> r20985 | moritz++ | [t] re-formulated rand() tasks in TASKS

[09:46] *** chris2 joined
[09:46] <moritz_> is Complex intended to be an immutable value?

[09:47] <moritz_> ah, yes. Found the answer

[09:51] <moritz_> is anybody eager to discuss S29?

[09:51] <moritz_>     our Seq multi method polar (Complex: $nim) is export

[09:51] <moritz_> shouldn't that be ... polar (Complex $nim:) ?

[10:00] *** penk left
[10:01] * scrottie slams a mug of mead and then proceeds to look incredulous.

[10:02] *** meppl left
[10:05] *** elmex left
[10:05] <pugs_svnbot> r20986 | moritz++ | [util/perl6.vim] updated builtin types to closer match S02

[10:07] *** elmex joined
[10:11] *** bacek left
[10:11] *** bacek joined
[10:32] <moritz_> rakudo: say pi / 2

[10:33] <p6eval> rakudo r28673 OUTPUT[1.5708‚ê§]

[10:44] *** Jedai joined
[10:51] *** a-jing joined
[10:51] *** a-jing left
[10:54] <moritz_> in @a[*-1], how is *-1 passed to postcircumfix:<[ ]> ?

[10:55] *** luqui left
[11:05] <spinclad> moritz_: re polar (Complex: $nim), i second you.

[11:07] <moritz_> spinclad: thanks for backlogging and answering

[11:07] <pugs_svnbot> r20987 | moritz++ | [S29] fixed signatur for polar()

[11:07] <spinclad> re *-1, as ... an Int? 'whatever less one': the day before Forever

[11:08] <moritz_> that doesn't make sense

[11:08] <moritz_> so I somehow think it should be passed as a pair (Whatever, -1) or some such

[11:09] <spinclad> (ie, as another special value of Int, like Int or (for Num) Inf or Nan)

[11:09] <moritz_> -1 but Whatever?

[11:10] <spinclad> but i'm not thrilled about multiplying entities in a basic class like Int

[11:10] <moritz_> yes, that smells

[11:11] <spinclad> if it were explicitly algebraic, so you could have 'x + 2', then saying it's simply '* - 1' would make sense to me

[11:12] <spinclad> is (*-1) + 1 == * ?

[11:13] <spinclad> so i dunno

[11:13] <moritz_> I don't think you can do meaningful arithmetic with *

[11:13] <moritz_> just like you can't with Inf

[11:14] <spinclad> oh, (Inf - 1) + 1 == Inf, it's just that Inf - 1 == Inf too :)

[11:15] <spinclad> and Inf - Inf should be NaN

[11:15] <moritz_> standard mathematical notation doesn't even allow you to write Inf + 1 in an expression

[11:16] <spinclad> perhaps because it simplifies?

[11:16] <spinclad> omega + 1, otoh, is quite standard

[11:16] <spinclad> (omega: first ordinal infinity)

[11:17] <moritz_> yes

[11:17] <moritz_> but people who know about omega usually know the common mistakes with Inf ;)

[11:18] <moritz_> btw it's so nice to chat with people who have a bit of mathematical background

[11:18] <moritz_> it doesn't make me feel I'm an isolated √ºber-geek ;)

[11:18] <spinclad> here too

[11:18] <spinclad> well, not isolated at least; and sometimes it's the right tool for the thinking

[11:20] <moritz_> (although I admit that (being a physicist) my approach to mathematics is sometimes overly pgramatic - "how cares if this integral is defined, as long as Mathematica can calculate its result" ;-)

[11:20] <moritz_> s/how/who/

[11:21] <moritz_> anyway, to return to the initial question, I think that pairs aren't a bad idea - I just haven't found it in the specs

[11:22] <moritz_> or is *-1 just frobbed into *, -1 ?

[11:24] <spinclad> (i suspect mine may be overly abstract-nonsense - who cares about particular values, they're just maps from 1 to a target category)

[11:27] <spinclad> looking at *-1 algebraicly, representing it as Poly(*, [1,-1]) suggests itself; Pair(*,-1) could work too.  but i don't see a deciding thought here.

[11:28] *** mjk joined
[11:30] <spinclad> i guess: an implementation chooses a canonical rep.  could be C<  { infix:<->(*, 1) }  > (a closure node) if it likes...

[11:30] <spinclad> anyway, back to bed... got up after half a night to meditate and backlog &

[11:32] <moritz_> closures are no good idea IMHO because they are harder to introspect than ordinary data structures

[11:32] <moritz_> sleep well

[11:33] *** zamolxes joined
[11:33] <SamB> moritz_: eh?

[11:33] <SamB> harder to introspect?

[11:34] <moritz_> SamB: in this context, if you have a closure $c, how do you determine if it's { infix:<->(*,1) } or { infix:<->(*,2) } ?

[11:35] <SamB> hmm.

[11:35] <SamB> well, I don't know what either of those are... so I dunno.

[11:35] <spinclad> (represent them as lambda-expressions, as combinator apply-trees; canonicalize by left-most, innermost reduction (iirc))

[11:36] <SamB> spinclad: innermost?

[11:36] <SamB> I was under the impression that you repeatedly reduced the left-most redex

[11:37] <SamB> which might have redexes as sub-expressions

[11:37] <SamB> and would not be the subexpression of any other redex

[11:38] <SamB> since I'd be measuring from the beginning

[11:38] <SamB> going for the inner-most is STRICT evaluation...

[11:38] <spinclad> sounds right... leftmost, lazymost reduction

[11:38] <SamB> and normalizes less strongly

[11:39] <spinclad> innermost may evaluate something unneeded, which may not halt...

[11:39] <SamB> you know what's really hard to introspect?

[11:40] <spinclad> so half a thought gives a better answer

[11:41] <spinclad> all right, what?  # 'yo mama!'

[11:41] <SamB> ... a value who's type you are polymorphic in

[11:43] <spinclad> though if the type is constrained with a 'does Introspect' interface...

[11:43] <spinclad> but if not, yeah

[12:01] *** chris2 left
[12:17] *** wilx joined
[12:29] * diakopter ponders call-by-need as applied to the top-level (statement list) and "rollup" activities necessary when the grammar is adapted/swapped.

[12:30] <diakopter> if each statement is viewed as an argument to a call of the program function...

[12:32] <diakopter> then 'program' evaluates its arguments successively, feeding the state changes left-to-right, so one of the arguments to each successive statment is the resulting state from the prior statement

[12:33] <diakopter> ... unless statements are to be lazily evaluated as well...!

[12:34] <diakopter> any thoughts from anyone?

[12:34] *** alanhaggai joined
[12:39] <diakopter> so if the 'program' is to be compiled, the parser/interpreter (as well as the original grammar's source!) itself would need to be embedded in the program if any argument's state-flow dependencies is non-deterministic input.

[12:42] <diakopter> continuing along those lines, when parsing, the evaluation plan can be built by recursive calls to the parser with the input and the parser-set itself as the arguments to the parser.

[12:42] <masak> rakudo: sub say { } say "is this printed?"

[12:42] <p6eval> rakudo r28673 OUTPUT[Statement not terminated properly at line 1, near "say \"is th"‚ê§current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)‚ê§

[12:42] <masak> rakudo: sub say { }; say "is this printed?"

[12:42] <p6eval> rakudo r28673 RESULT[Null PMC access in find_method()‚ê§current instr.: '_block11' pc 38 (EVAL_13:18)‚ê§

[12:43] <diakopter> that would push parsing into call-by-need as well.

[12:47] <diakopter> rakudo: sub say { sub say1 { 3.say; $_.say; }; say1(4); }; 5.say;

[12:47] <p6eval> rakudo r28673 OUTPUT[maximum recursion depth exceeded‚ê§current instr.: 'say' pc 100 (EVAL_11:48)‚ê§

[12:51] <diakopter> moritz_: I appear to have sent a non-terminating program to rakudo with an infinite recursion it couldn't detect:  ... can you kill it?

[12:51] <diakopter> Auzon: or you

[12:51] <moritz_> diakopter: sure

[12:51] <moritz_> evalbot control restart

[12:51] <moritz_> # just a different try

[12:52] <diakopter> heh

[12:52] <diakopter> apparently it's not listening

[12:52] <moritz_> sh: line 1:  6311 CPU time limit exceeded PUGS_SAFEMODE=true ./pugs /tmp/uOyoSWT3xI >>/tmp/7pc2xEY7Ax 2>&1

[12:52] <moritz_> why doesn't that work for rakudo?

[12:52] <diakopter> moritz_: :) not sure

[12:52] *** p6eval joined
[12:53] <moritz_> BSD::Resource only checks CPU time, not run time

[12:53] <moritz_> maybe I should also limit runtime

[12:53] <diakopter> apparently rakudo can detect *direct* infinite recursion, but not indirect.

[12:54] <diakopter> badrakudo: sub say2 { sub say1 { 3.say2; }; say1(4); }; 5.say2;

[12:55] <diakopter> pugs: sub say2 { sub say1 { 3.say2; }; say1(4); }; 5.say2;

[12:55] *** wknight8111 joined
[12:55] <diakopter> hm.  I guess pugs doesn't detect it either

[12:55] <p6eval> No output (you need to produce output to STDOUT)

[12:56] <diakopter> well pugs eventually hits some kind of limit :)

[12:56] <diakopter> kp6: sub say2 { sub say1 { 3.say2; }; say1(4); }; 5.say2;

[12:56] <p6eval> kp6 r20987: OUTPUT[no method 'say2' in Class 'Int'‚ê§ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345‚ê§       

[12:57] <diakopter> elf: sub say2 { sub say1 { 3.say2; }; say1(4); }; 5.say2;

[12:57] <p6eval> OUTPUT[Can't call method "say2" without a package or object reference at (eval 119) line 5.‚ê§ at ./elf_f line 3854‚ê§]

[12:57] <moritz_> those two don't implement method fallback

[12:57] <diakopter> oh

[12:58] <diakopter> kp6: sub say2 { sub say1 { say2; }; say1; }; say2;

[12:58] <p6eval> kp6 r20987: No output (you need to produce output to STDOUT)

[12:59] <diakopter> oh wait

[13:00] <diakopter> the earlier non-terminating input - I sent it to perl6:, not just rakudo:  oops.  I guess I should try just rakudo

[13:01] <diakopter> rakudo: sub say2 { sub say1 { say2; }; say1; }; say2;

[13:01] <p6eval> rakudo r28673 OUTPUT[maximum recursion depth exceeded‚ê§current instr.: 'say2' pc 88 (EVAL_11:44)‚ê§

[13:01] <moritz_> no stale perl 6 procoess whatsoever on $server

[13:01] <diakopter> moritz_: yeah; it was only pugs that froze earlier

[13:01] <diakopter> er, boiled.

[13:03] <moritz_> $state_change ;)

[13:03] <diakopter> sublimated

[13:03] <diakopter> plasmified

[13:03] <moritz_> $change_of_state_of_aggregation

[13:04] <diakopter> fissioned

[13:04] <moritz_> cold fissioned? ;)

[13:05] <diakopter> I guess there should be a way to tell rakudo what its recursion depth limit should be, when you want it to be quite deep.

[13:05] <diakopter> and preferably not at rakudo-compile-time

[13:06] <moritz_> yes, but IMHO that's none of the iimportant features to implement atm

[13:06] <diakopter> but if the recursion limit is less than a hundred...

[13:06] <moritz_> is it?

[13:06] <diakopter> I don't know

[13:07] <moritz_> then don't worry until you hit that barrier

[13:07] <diakopter> commute&

[13:08] <pugs_svnbot> r20988 | diakopter++ | [yap6] disregard; work-in-progress.

[13:25] <pmichaud> (*-1 from backscroll):   iirc, then *-1 becomes a special value of "whatever" that gets passed to postcircumfix:<[ ]>

[13:25] <pmichaud> it was described around a year ago on p6l

[13:25] <pmichaud> but it's still just a single argument -- it just happens to be an "interesting" value of whatever  (similar to how we can have "interesting" values of undef :-)

[13:36] *** ludan joined
[13:40] *** rdice joined
[13:41] *** Lorn joined
[13:50] <diakopter> reconfigured yap6's parser builders to call-by-need

[13:51] <diakopter> along the way found a non-working memoization, and fixed it, yielding who-knows-how-much efficiency improvement

[13:52] <diakopter> when inside several layers of nested closures, calls to memoize() aren't as reliable...

[13:52] <diakopter> inlining my own memoization works a lot better :)

[13:52] * moritz_ can't find the thread, searching again

[13:56] *** iblechbot left
[13:59] *** aindilis joined
[14:01] *** wknight8111 left
[14:03] *** pbuetow joined
[14:05] *** GeJ joined
[14:07] *** GeJ left
[14:08] *** GeJ joined
[14:10] *** stevan_ joined
[14:10] *** aindilis left
[14:18] *** laurent_88 joined
[14:26] *** stevan_ left
[14:28] *** mjk left
[14:28] <moritz_> http://techfaux.com/2008/06/17/peta-targets-computer-programmers-with-string-of-bizarre-protests/ # OMFG

[14:29] <lambdabot> Title: TechFaux.com - Beta ª Blog Archive ª PETA Targets Computer Programmers With Stri ..., http://tinyurl.com/6klbg2

[14:31] *** stevan_ joined
[14:31] <pugs_svnbot> r20989 | rhr++ | Add docs/p6types - a description of specced p6 roles, classes, and methods from the synopses

[14:31] <pugs_svnbot> r20989 | rhr++ |     it's meant to be sort of a roadmap for p6 library/Prelude development

[14:31] <pugs_svnbot> r20989 | rhr++ |     currently covers S02 and S03 (I ran out of time and tuits), please add more!

[14:34] *** alanhaggai left
[14:34] <pmichaud> I can't find the p6l thread about whatever * either (other than the one that introduced the concept), so maybe I'm misremembering.

[14:34] <moritz_> ok, I'll compose a mail to the list later

[14:35] <pmichaud> I do recall hearing from @Larry that *-2 was passed as "whatever with an offset"

[14:35] <pmichaud> and that it's then evaluated in context

[14:36] <diakopter> pmichaud: http://tinyurl.com/4hcbsk

[14:36] <lambdabot> Title: Question on your last change to S02 - perl.perl6.language | Google Groups

[14:37] <pmichaud> diakopter++  # thanks, found it

[14:38] *** jhorwitz joined
[14:38] <moritz_> diakopter++ indeed

[14:42] *** redicaps joined
[14:52] *** laurent_88 left
[14:52] <moritz_> pugs: my @a = 1, 2, 3; if @a -> $b { say $b.perl }

[14:52] <p6eval> OUTPUT[*** Cannot bind to non-existing variable: "$b"‚ê§    at /tmp/99rBB5Nnqx line 1, column 1‚ê§]

[14:52] <moritz_> rakudo: my @a = 1, 2, 3; if @a -> $b { say $b.perl }

[14:52] <p6eval> rakudo r28675 OUTPUT[Statement not terminated properly at line 1, near "-> $b { sa"‚ê§current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)‚ê§

[14:55] *** hercynium joined
[14:56] <rakudo_svn> r28676 | pmichaud++ | [rakudo]:

[14:56] <rakudo_svn> r28676 | pmichaud++ | * Update spectest-progress.csv

[14:56] <rakudo_svn> r28676 | pmichaud++ | * 66 files, 849 passing tests

[14:57] *** TJCRI joined
[15:05] *** alanhaggai joined
[15:07] *** redicaps left
[15:10] *** Alias__ joined
[15:19] *** ludan left
[15:19] <pugs_svnbot> r20990 | rhr++ | [spec] S29-str/uc.t - ?\195?\159 -> SS is correct by Unicode 5.1.0

[15:27] *** clintongormley joined
[15:28] <TimToady> well, it's possible that the semantic type of * is "Equation with scalar unknown", while the type of ** is "Equation with list unknown"

[15:28] <TimToady> or maybe slice unknown

[15:28] <masak> TimToady: what should happen if I did `sub say { ... }` in my code?

[15:29] <TimToady> an only sub should hide the built-in

[15:29] <masak> ok

[15:29] <TimToady> well, if it's "my sub"

[15:29] <masak> and otherwise?

[15:29] <TimToady> not clear for a package sub

[15:29] <TimToady> but I think that it should also probably hide

[15:29] <masak> so why the 'my'?

[15:30] <TimToady> hides in a tighter scope

[15:30] *** Khisanth joined
[15:30] <TimToady> well, might be tighter or looser

[15:30] <TimToady> packages being independent of lexical scopes

[15:31] <TimToady> but subs defined in current package should probably be considered a scope between prelude scope and file scope

[15:31] <TimToady> if "prelude" scope is considered a lexical scope outside file scope

[15:32] <TimToady> that is, when searching for sub "foo", look outward in lexical scopes through file scope, then package scope, then prelude scope

[15:35] <TimToady> on *-1, my feeling is that it should probably be a separate type for multi dispatch purposes, neither Int nor Whatever

[15:36] <TimToady> so if there's a Relative or Unknown or Equation type, then a sig based on Whatever can reject it based on type

[15:36] <pmichaud> that makes sense

[15:36] <TimToady> so you get a mismatch if you say "foo" x *-1

[15:36] <pmichaud> I was also wondering about things like   */2

[15:37] <pmichaud> which aren't simply linear offsets

[15:37] <TimToady> that would be legal under an equational view

[15:37] <pmichaud> agreed.

[15:37] <TimToady> I believe Range objects are required to perform similar transformations

[15:38] <TimToady> so (1..10) + 5 is 6..15, etc

[15:38] *** zamolxes left
[15:39] <TimToady> but Ranges don't usually have to do it lazily, as far as I can tell

[15:40] <TimToady> it's also not clear how to handle range tests when the range goes non-linear

[15:40] <vixey> pugs: (-2..2) ** 2

[15:40] <p6eval> RESULT[25/1]

[15:40] <TimToady> pugs doesn't know ranges

[15:40] <TimToady> pugs: (-2,-1,0,1,2)**2

[15:40] <p6eval> RESULT[25/1]

[15:40] <TimToady> pugs: 5**2

[15:40] <p6eval> RESULT[25/1]

[15:40] <vixey> would maybe (-2..2) ** 2 = (0..2) & (0..2) ?

[15:41] <TimToady> I don't do higher math :)

[15:42] <moritz_> I hope you don't rely on the method dispatcher to solve algebraic equations ;)

[15:43] <TimToady> no, but the method dispatcher can hopefully detect the *need* for algebraic reasoning

[15:43] *** jjore joined
[15:44] <TimToady> and some of these constructs could be viewed as parametric types, I suppose

[15:45] <TimToady> but I don't plan to solve the (-2..2)**2 problem for 6.0.0

[15:45] <moritz_> I don't see an intuitie solution for it

[15:46] <moritz_> (perhaps other than constructing a two-dimensional range, against which you can match lists of two items)

[15:46] <TimToady> though a Whatever that transforms Fahrenheit to Celsius is probably workable :)

[15:46] *** justatheory joined
[15:47] <TimToady> there's doubtless some deep connection with coercions in here too

[15:48] <TimToady> and maybe with dimensional analysis

[15:51] <moritz_> "dimensional analysis" sounds scary ;)

[15:51] <moritz_> but actually it's quite nice they way it's used in physics

[15:52] <TimToady> indeed

[15:53] <moritz_> one of our teachers finished early with what he had to teach us, and then spent two hours teaching us d.a.

[15:53] <moritz_> it's amazing what you can derive with it

[15:58] <rhr> if you allow arithmetic with * and **, how do you parse ******** or * ** * * ** ** * ** ** * * ?

[16:01] <TimToady> at some point you should use real functions :)

[16:01] <rhr> no doubt :)

[16:01] <TimToady> * is just the "what it is" function  :)

[16:02] <TimToady> and ** is the "what they are" function

[16:02] <TimToady> or maybe I should say the "whatever it is" function

[16:02] *** clintongormley left
[16:03] *** meppl joined
[16:04] *** kanru joined
[16:06] <TimToady> so maybe the type of * is really Code[:($)] or some such, and ** is Code[:(*@@)]

[16:07] <TimToady> and the value of * is really sub ($x) { $x }, the identity function

[16:07] <TimToady> or -> $x { $x } in lambda-ese

[16:08] <pmichaud> rhr:  parsing * ** * * ** ** * ** ** * *  is just { say "Whatever!" }   :-P

[16:08] <pmichaud> or perhaps that should be  { .panic("Whatever!") }  

[16:08] <TimToady> actually, that fails very early with "two terms in a row"

[16:10] *** kanru left
[16:10] <TimToady> but if that is the type of *, then we ought to be able to write "foo" x -> $x { $x } to mean the same thing, and I'm not sure that's a good idea

[16:10] *** kanru joined
[16:11] <TimToady> so I think I still would like Whatever to be the identity function, and the other functions be a type that is easily dispatched elsewhere

[16:11] <TimToady> since we know that there's not much point in calling the function when it's the identity function

[16:13] *** armagad joined
[16:13] <TimToady> so maybe Whatever is a subtype of Transform that happens to be identity

[16:14] <rhr> Transform is Code[:($ --> $)] or some such?

[16:15] *** meppl left
[16:19] <TimToady> nodnod

[16:20] *** iblechbot joined
[16:38] *** Lorn left
[16:40] *** a-jing joined
[16:40] *** a-jing left
[16:43] *** Lorn joined
[16:46] *** araujo joined
[16:47] *** Alias__ left
[16:52] *** [particle] joined
[16:59] *** armagad left
[17:16] *** cognominal_ joined
[17:17] *** Jedai left
[17:21] *** barney joined
[17:23] *** meppl joined
[17:29] <pugs_svnbot> r20991 | Auzon++ | [gsoc_spectest] Added more tests to eager_hyper.t to check that counting the elements in the iterator completes it. (added 2 tests).

[17:48] <Auzon> perl6: say "{}"

[17:48] <p6eval> kp6 r20991: OUTPUT[{}‚ê§]

[17:48] <p6eval> ..pugs: OUTPUT[‚ê§]

[17:48] <p6eval> ..rakudo r28677: OUTPUT[Null PMC access in get_string()‚ê§current instr.: 'print' pc 9875 (src/gen_builtins.pir:6483)‚ê§

[17:48] <p6eval> ..elf r20991: OUTPUT[{}‚ê§]

[17:50] <DietCoke> elf?

[17:54] *** Jedai joined
[17:57] *** wknight8111 joined
[17:58] <Auzon> elf!

[17:59] <Auzon> It's primarily mncharity's project to write a P6 compiler written in P6 that runs on P5 and does AST things using STD_red.

[17:59] <DietCoke> elf is primarily mncharity's project to write a P6 compiler written in P6 that runs on P5 and does AST things using STD_red.

[18:00] <DietCoke> (danke, feeding the bot if there's one)

[18:00] <TimToady> no purl here

[18:00] *** masak left
[18:00] <DietCoke> elf?

[18:00] <Auzon> perlbot: help

[18:00] <DietCoke> not even a stupidbot. ah well.

[18:00] <perlbot> (fact) : tell (who) about (what) : (what) > (who) : learn (what) as (info) : relearn (fact) as (info) : phone (phone #) : shorten (url) : shorten it : search (keyword) : cpan (mod) : docs (mod) : perldoc -f (func) : jargon (term) : math (expr): fortune : flip : host (type) (record) : rot13 (text) : roll (die) : tempconv (temp) : scramble (foo) : 8ball (question) : slap (who) : diss (who) : top/bottom (num) karma : geoip (ip)

[18:01] <TimToady> diss TimToady

[18:01] <TimToady> perlbot: diss TimToady

[18:01] <perlbot> TimToady is my little bitch.

[18:01] <pmichaud> pugs:  sub foo() { };  say foo().WHAT;

[18:01] <p6eval> OUTPUT[Scalar‚ê§]

[18:02] <pmichaud> hrm.

[18:02] <Auzon> perlbot: slap perlbot

[18:02] * perlbot slaps perlbot around a bit with a large trout

[18:02] <Auzon> How useful

[18:02] <diakopter> perlbot: 8ball Xmas?

[18:02] <perlbot> Magic 8ball says: Yes

[18:02] <TimToady> should probably be returning Object, or something equally undeffigeneric

[18:03] <pmichaud> Object?  Failure?  Whatever?

[18:03] <TimToady> not Whatever, that's only for users to use

[18:03] <pmichaud> I can have it return Object.

[18:03] <TimToady> in Soviet Perl, Whatever asks *you* to dwim

[18:04] <diakopter> perlbot: diss perlbot

[18:04] <perlbot> OMG perlbot sucks.

[18:04] <TimToady> well, Object is generic undef

[18:04] <TimToady> pugs: say undef.WHAT

[18:04] <p6eval> OUTPUT[Scalar‚ê§]

[18:05] <pmichaud> by Object do you mean the protoobject for Object ?

[18:05] <TimToady> Scalar is not quite right, since undef shouldn't be considered a container

[18:05] <pmichaud> or an instance of Object (besides the protoobject)?

[18:05] <TimToady> the protoobject

[18:05] <pmichaud> okay

[18:05] <pmichaud> works very well for me

[18:05] <TimToady> an instance of it wouldn't be undefined, presumably

[18:06] <TimToady> though Object may well refuse to instantiate...

[18:06] <TimToady> on the other hand, Object.new could just be the empty defined object

[18:07] <TimToady> pugs: say Object.defined

[18:07] <p6eval> OUTPUT[‚ê§]

[18:07] <pmichaud> should Object be the return value for any routine that doesn't explicitly provide one somehow?

[18:07] <TimToady> pugs: say Object.new.defined

[18:07] <p6eval> OUTPUT[1‚ê§]

[18:07] <TimToady> heh

[18:08] <TimToady> hmm, well, bare return returns () or some such, so maybe item () returns Object

[18:08] <TimToady> seems a bit harsh to call it a Failure

[18:09] <pmichaud> S02:3175 sez:  Note that if you could

[18:09] <pmichaud> instantiate an C<Object> it would be considered defined, and thus true.

[18:09] <pmichaud> (It is not clear that this is allowed, however.)

[18:09] <TimToady> clear specs++  :)

[18:09] <pmichaud> currently in rakudo   item() is returning an empty Array.

[18:09] <pmichaud> (just worked out that way -- I can change it to whatever else.)

[18:09] <pmichaud> having item() return Object makes sense, though.

[18:10] <TimToady> well, something to be said for that view too, except you wouldn't expect item() to be defined, really

[18:11] <TimToady> and I think expecting Void context and returning nothing should result in something undefined if you're not really in Void context

[18:11] <pmichaud> agreed.

[18:12] <TimToady> but I'd also like to have a variety of undef that interpolates () into list context, and Object doesn't quite seem to be it

[18:13] <pmichaud> could Object.list() return an empty list if the invocant is undefined?

[18:13] <TimToady> so possibly item() is just (), in a Capturely way rather than an Arrayly way

[18:14] <TimToady> we could make @(Object) return a null list

[18:14] <TimToady> not sure what the ramifications of that would be, though

[18:15] <pmichaud> otoh, if I have   sub foo() { return; }   and then   my $x = foo();    perhaps $x should be some sort of Failure object?

[18:15] <TimToady> return is already defined to return a Capture, so maybe item(Capture) returns Capture if the item slot is missing? <scratches head>

[18:16] <pmichaud> which would be different from having   return ();

[18:17] <TimToady> maybe, if a Capture naturally, er, captures that info.  wouldn't want to force it too much though for efficiency reasons

[18:17] <TimToady> I guess () has to be there in the Capture, or you couldn

[18:17] <TimToady> couldn't bind it to a scalar param correctly

[18:19] <TimToady> my ($a,$b) := ( (), () ); probably needs to do something rational

[18:19] * pmichaud boggles

[18:19] <TimToady> as does: my ($a,$b) := ( a(), b() );

[18:20] <Auzon> rakudo: say #{{ }} 'ok';

[18:20] <p6eval> rakudo r28678 OUTPUT[‚ê§]

[18:21] <TimToady> pugs: my ($a, $b) := ( list(1,2,3), list(4,5,6) ); say $b

[18:21] <p6eval> OUTPUT[456‚ê§]

[18:21] <TimToady> that looks correct

[18:21] *** cjfields joined
[18:22] <TimToady> though probably because pugs is generating a List object rather than a Capture object, but a list of Captures should behave similarly

[18:22] <TimToady> (when bound to a sequence of scalar params)

[18:23] <pmichaud> pugs: my $b = list(4,5,6);  say $b

[18:23] <p6eval> OUTPUT[4 5 6‚ê§]

[18:24] <pmichaud> pugs: my $b := list(4,5,6);  say $b

[18:24] <p6eval> OUTPUT[456‚ê§]

[18:24] <pmichaud> okay.

[18:24] <TimToady> pugs: my $b = list(4,5,6);  say $b.WHAT

[18:24] <p6eval> OUTPUT[Array‚ê§]

[18:24] <TimToady> pugs: my $b := list(4,5,6);  say $b.WHAT

[18:24] <p6eval> OUTPUT[Array::Const‚ê§]

[18:24] <TimToady> heh

[18:25] <cjfields> TimToady: wanted to ask yesterday, but with methods versions of trans(), substr(), match(), are we allowing modifiers?

[18:25] <TimToady> sure, they're just named args

[18:26] <cjfields> ok

[18:26] <TimToady> they're even spelled the same way: :g

[18:26] <TimToady> you just pass 'em as args instead of keeping them out front

[18:27] <TimToady> and the replacement in subst can be a closure to do the s[foo] ~= 'bar' kind of stuff

[18:28] <cjfields> Do we want to keep :c for trans()?  I'm thinking of the many-to-one issue.

[18:29] <cjfields> that would be 'complement' for those who got the emoticon

[18:30] <TimToady> we could have it if it were defined carefully as "any character that does not match one of these", where "one of these" can be of variable length

[18:31] <TimToady> it's really the same as <-[a..z]> processing in regular pattern matching

[18:31] <TimToady> that means skip '.' unless the class matches

[18:31] <TimToady> there's no requirement that '.' match the same length as all the elements in the class

[18:32] <TimToady> though with our default of graphemes, it generally will be the same in terms of grapheme count

[18:32] <TimToady> (since graphemes include any combining characters as part of the "character")

[18:33] <cjfields> okay, thanks, that helps.

[18:33] <TimToady> I think being grapheme-centric rather than codepoint-centric will be one of the ways in which p6 will be a disruptive technology

[18:34] <TimToady> the user shouldn't have to worry about various Unicode representations, by default

[18:35] <cjfields> The use of modifiers for methods, and what the modifiers mean in the context of p6 isn't indicated in S05

[18:35] <cjfields> Don't know if it should be clarified or not

[18:36] <cjfields> but if might help as we start implementing more and more in Rakudo

[18:36] <TimToady> I we clarify everything everywhere, we get a combinatoric explosion :)

[18:36] <TimToady> *If

[18:36] <cjfields> heh, true

[18:36] <TimToady> but that could be a valid candidate

[18:37] <cjfields> main reason I'm working on this is for a revised bioperl (which is a mess)

[18:37] <cjfields> so I'll be putting the grammars to good use at some point

[18:38] * cjfields doesn't think {*} works with rakudo grammars yet

[18:38] <pmichaud> do you mean actual closures, or the {*} token?

[18:39] <cjfields> closures

[18:39] <pmichaud> correct, we don't have that in rakudo yet.  The hooks are there, though -- just need filling in.

[18:40] <cjfields> though I haven't toyed around with them enough

[18:40] <cjfields> ok

[18:43] *** ispy_ joined
[18:47] *** Maghnus left
[18:49] <TimToady> they kinda work in STD5 if you are careful to write in the subset of Perl 6 that gimme5 can fake into Perl 5

[18:51] <Tene> hmm.  closures in rakudo might be fun to work on.

[18:51] *** aindilis joined
[18:55] *** Alias_ joined
[19:03] <cjfields> Tene: agreed

[19:10] *** cognominal__ joined
[19:11] *** cognominal_ left
[19:20] *** Chillance joined
[19:22] <Auzon> (diff -w)++

[19:25] <pmichaud> rakudo already supports closures (sorta, see :outer/lexicals discussion elsewhere)... PGE just doesn't recognize them in regexes yet.

[19:27] *** cognominal__ left
[19:34] *** hercynium left
[19:40] *** cognominal_ joined
[19:50] *** armagad joined
[19:59] *** gbarr joined
[19:59] *** gbarr left
[20:13] *** LowBass joined
[20:16] *** pmurias joined
[20:20] *** barney left
[20:32] <Auzon> pugs: say +^1

[20:32] <p6eval> OUTPUT[-2‚ê§]

[20:32] <Auzon> pugs: say +^1.WHAT

[20:32] <p6eval> OUTPUT[-1‚ê§]

[20:32] <Auzon> pugs: say (+^1).WHAT

[20:32] <p6eval> OUTPUT[Int‚ê§]

[20:33] <moritz_> prefix:<+> on a listy thingy should always return an Int I think

[20:33] <pugs_svnbot> r20992 | pmurias++ | [STD]

[20:33] <pugs_svnbot> r20992 | pmurias++ | added a {*} to arglist

[20:33] <pugs_svnbot> r20992 | pmurias++ | [pixie]

[20:33] <pugs_svnbot> r20992 | pmurias++ | initial commit on pixie - it's a STD frontend to elf

[20:33] <pugs_svnbot> r20992 | pmurias++ | mostly hello world works now

[20:33] <pugs_svnbot> r20992 | pmurias++ | the closures will be translated to p6 soon, pixie_actions contains the not yet used p6

[20:33] <pmurias> TimToady: elfish closures will be supported externaly in STD soon

[20:33] *** sri_work left
[20:34] <moritz_> pixie++

[20:34] <pmurias> it's a hack now

[20:34] <pmurias> but it would be nice to have it in evalbot soon

[20:35] <moritz_> sure, how is it called?

[20:35] <pmurias> perl pixie --quiet < code_file

[20:36] <moritz_> ok, will do

[20:36] <moritz_> no compilation required on evalbot side, right?

[20:36] <moritz_> btw evalbot needs refactoring - too much duplicated code

[20:36] <pmurias> moritz_: you should run brew to compile pixie

[20:37] <moritz_> just `sh brew'?

[20:37] *** Jedai left
[20:38] *** p6eval left
[20:39] *** p6eval joined
[20:39] <pmurias> moritz_: yes

[20:39] <pmurias> as described in the readme

[20:39] <pmurias> README

[20:40] <pmurias> what's the best way to get the result from a array of match objects?

[20:40] * moritz_ sees no readme in misc/pixie/

[20:41] *** b_jonas joined
[20:41] <moritz_> pmurias: what do you mean?

[20:41] <pmurias> sorry, forgot to svn add it

[20:41] <pmurias> moritz_: @array_of_match_object.map({$$_})

[20:42] <pugs_svnbot> r20993 | pmurias++ | [pixie] added README

[20:42] <diakopter> psixie with a silent p?

[20:43] <pmurias> diakopter: if you like it that way

[20:43] <pmurias> diakopter: hi

[20:43] <diakopter> pmurias: hi

[20:44] <diakopter> almost done with the match object tree generation for yap6

[20:44] <moritz_> evalbot control restart

[20:44] *** p6eval left
[20:44] <pugs_svnbot> r20994 | moritz++ | [evalbot] added pixie (but not yet included in perl6: target)

[20:44] *** aindilis left
[20:44] *** p6eval joined
[20:45] <moritz_> pixie: say "hi";

[20:45] <p6eval> OUTPUT[sh: ./pixie: Permission denied‚ê§]

[20:45] * moritz_ is dump

[20:45] <moritz_> dumb even ;)

[20:46] <moritz_> evalbot control restart

[20:46] *** p6eval left
[20:46] <pugs_svnbot> r20995 | moritz++ | [evalbot] use perl to execute pixie ;)

[20:46] *** p6eval joined
[20:47] <moritz_> pixie: say "hi";

[20:47] <p6eval> OUTPUT[sh: ./pixie: Permission denied‚ê§]

[20:47] *** p6eval left
[20:47] <moritz_> it might help to svn up before restarting

[20:47] *** p6eval joined
[20:47] <moritz_> pixie: say "hi";

[20:47] <p6eval> OUTPUT[Can't locate STD5.pm in @INC (@INC contains: ../../src/perl6 /etc/perl /usr/local/lib/perl/5.8.8 /usr/local/share/perl/5.8.8 /usr/lib/perl5 /usr/share/perl5 /usr/lib/perl/5.8 /usr/share/perl/5.8 /usr/local/lib/site_perl .) at pixie line 4.‚ê§BEGIN failed--compilation aborted at pix...

[20:48] <diakopter> gotta run gimme5..?

[20:48] <pmurias> yes

[20:48] <pmurias> diakopter: what is the intended advantage of yap6 over STD5?

[20:48] <diakopter> you better hope moritz_'s server runs linux :D

[20:48] <Auzon> It runs Debian

[20:48] <moritz_> which in turn needs perl 5.10 to run

[20:48] <moritz_> sigh

[20:49] <moritz_> I can just as well upgrade evalbot's chroot to lenny

[20:49] <Auzon> Does Debian stable ship 5.10 yet?

[20:49] <moritz_> Auzon: no, only testing

[20:49] <diakopter> advantage? for me to learn to write a parser [engine] (and maybe a compiler [engine]).

[20:49] <moritz_> Auzon: stable doesn't do version updates at all

[20:49] <Auzon> I could compile us 5.10 if you'd prefer not to upgrade everything...

[20:49] <Auzon> My 5.10 that I compiled on F8 was nice and fast

[20:49] * diakopter recommends building specially..

[20:50] <moritz_> Auzon: I do prefer upgrading everything ;)

[20:50] <Auzon> Faster than 5.10 that F9 shipped...

[20:50] <diakopter> Auzon: w/ threads?

[20:50] <moritz_> Auzon: it has to be done anyway, and then we can get rid of the self-compiled ruby as well

[20:50] <moritz_> it'll just take some work

[20:51] <moritz_> doing a backup first

[20:51] <Auzon> diakopter: Uhhh, yeah. My F8 5.10 was 32-bit defaults; my F9 is 64-bit from distro (which includes threading). So that's probably it.

[20:52] <diakopter> pmurias: you saw my answer to whither yap6?

[20:56] <moritz_> IO is a bit slow on the server :/

[20:57] <Auzon> moritz_: Perhaps we could eliminate the need for files to be written for evalbot if they accept input via STDIN?

[20:57] <pmurias> diakopter: yes

[20:58] <moritz_> Auzon: it's not *that* slow. I just noticed it when copying the whole chroot

[20:58] <Auzon> oh. :P

[20:58] <moritz_> Auzon: I decided against that because I didn't know if all implementations would support it

[20:59] <moritz_> anyway, the plan is to 1) copy the whole chroot to /new_chroot/ (currently named old_chroot, I'm going to change that... )

[20:59] <moritz_> 2) in /new_chroot/, upgrade to testing aka lenny

[20:59] <moritz_> 3) re-install all needed perl modules

[20:59] <moritz_> 4) test the implementations there

[20:59] <moritz_> 5) switch to it

[21:00] <pmurias> diakopter: re compiler [engine] part, starting a yet another one perl6 *compiler* wouldn't be a good idea

[21:01] <pmurias> how do i type the unicode << in vim?

[21:01] <pmurias> or the cent?

[21:02] <TimToady> ^K<<

[21:02] <TimToady> ^KCt

[21:02] <moritz_> its AltGr+y for me ;)

[21:02] <TimToady> or (for me) right-menu << or c/

[21:03] <pmurias> TimToady: thanks

[21:03] <TimToady> when in doubt, say :digraphs

[21:03] <pmurias> i prefere not too use the mouse for coding unless i'm forced

[21:04] <TimToady> :dig for short

[21:04] <TimToady> somewhere I've got a program to grep through Linux's compose key database too, but I always forget where I put it

[21:05] <b_jonas> I've put those few funny unicode characters that I need to caps-lock plus numbers in my keyboard

[21:05] <b_jonas> so ¬´ is capslock-shift-6 now

[21:06] <TimToady> which is just as many keystrokes as AltGr < <

[21:06] <moritz_> and  one more than AltGr y ;-)

[21:06] <b_jonas> well, I rarely need those

[21:06] <TimToady> and the << is fast because it's a repeat

[21:06] <b_jonas> I don't write perl6 code where I'd actually need ¬´

[21:06] <TimToady> my favorite is AltGr oo for ¬∞

[21:07] <TimToady> but I wish I could install the vim bindings under AltGr

[21:07] <TimToady> never figgered out how to do that...

[21:07] <pmurias> $<<array_of_match_objects is legal?

[21:07] <b_jonas> and in the few cases when I actually need to write natural languages correctly, I write in LaTeX anyway so I just use commands which are ascii

[21:07] <moritz_> TimToady: probably not handled at viim level

[21:08] <TimToady> moritz_: huh?

[21:08] <b_jonas> I only put them there because I already had caps-lock as a modifier key for hungarian letters 

[21:08] <moritz_> TimToady: probably it's done on the X layer, and vim only sees what X forwards to it

[21:08] <b_jonas> so it was easy to set up

[21:08] <moritz_> TimToady: or even in kernel space

[21:08] <TimToady> er, I meant pmurias: huh?

[21:09] <pmurias> TimToady: a hyper op version of applying $ to match objects

[21:09] <TimToady> moritz_: I meant, to take the vim format of digraphs and just translate it to whatever X uses

[21:10] <TimToady> wasn't intending to use a real vim to do it

[21:10] <moritz_> TimToady: ah, that's a different thing

[21:10] <TimToady> since $ is a listop, it requires space, so $¬´ would also require a following space, I suspect

[21:10] <TimToady> but I haven't thought much about hyperizing listops

[21:11] <pmurias> $¬´ @foo?

[21:12] <b_jonas> I think you could set up the X keyboard layout to compose whatever keystrokes you want to unused function keysyms, and then bind those keysyms to something in vim

[21:12] <TimToady> presumably that could be made to work, though currently the token is considered $\s

[21:12] <b_jonas> depends on your configuration

[21:12] <TimToady> b_jonas: don't wanna think that hard, just want vim bindings at the shell prompt :)

[21:13] <TimToady> the readline vi bindings aren't that smart, I suspect

[21:13] <b_jonas> TimToady: do you actually want to bind compose and two keys?

[21:13] <b_jonas> to a command/

[21:13] <TimToady> there's a database of all the sequences that you can compose, I just want to add the vim sequences

[21:13] <b_jonas> ah, I see

[21:14] <b_jonas> that's different

[21:14] <b_jonas> I've no idea actually

[21:14] <TimToady> so that, for instance AltGr Ct would do what AltGr c/ does

[21:14] <b_jonas> I don't have composes in X so I don't know how it works

[21:14] <TimToady> (not that I'd use that one...)

[21:14] <TimToady> I kinda like c/

[21:14] <Juerd> TimToady: It's in a file called Compose

[21:14] <TimToady> yes, but that has to be compiled somewhere somehow

[21:14] <b_jonas> last time I've seen composes was when I edited linux console keymaps

[21:14] <b_jonas> and I didn't use them at that time either

[21:14] <TimToady> and that's the part I've never figgered

[21:14] <Juerd> TimToady: NAFAIK

[21:14] <b_jonas> I juse seen them in the same original file as the rest of the keymap way

[21:14] <b_jonas> was

[21:15] <Juerd> I recall having changed Compose and being able to use it after restarting xdm

[21:15] <TimToady> well, I edit the file I think it uses, and it ignores me, but maybe it's different now

[21:15] <TimToady> haven't tried in a while

[21:15] <Juerd> TimToady: There might be multiple Compose files. One per locale I believe.

[21:15] <b_jonas> what?

[21:15] <b_jonas> one per locale?

[21:15] <Juerd> Or was it one per keyboard. I'm not sure.

[21:15] <TimToady> I'm sure there's a way to do it, but I've been notably unsuccessful so far, is all

[21:16] <b_jonas> how can it depend on the locale if it's handled by X itself?

[21:16] <b_jonas> oh, one per keyboard layout

[21:16] <b_jonas> makes more sense that way

[21:16] <TimToady> do locate Compose on linux and you'll see 'em all

[21:17] <TimToady> FSVO linux and locate

[21:17] <pugs_svnbot> r20996 | Auzon++ | [gsoc_spectest] fixed test cases repeatedly assigning 'my $a' in the same scope. Also added one test for two's completement on Integers. (added 1 test)

[21:17] * Auzon is thinking about moving t/data_types somehow.

[21:19] <moritz_> S02-types/builtin-types.t or something?

[21:19] *** TJCRI left
[21:20] <moritz_> btw some tests seem to overlap with S02-liters/radix.t

[21:20] <moritz_> but IIRC radix.t doesn't check WHAT

[21:20] *** pmurias left
[21:22] <moritz_> is($a, 36893488147419103232, "we have bignums, not weeny floats"); 

[21:22] <moritz_> I like that ;)

[21:23] <Auzon> Heh. Yeah, I wish I could take credit for amusing things like that

[21:23] <Auzon> So is there any opposition to me moving t/data_types/* to t/spec/S02-builtin_data_types ?

[21:23] <moritz_> what other files would you add to that directory?

[21:24] * moritz_ likes the idea of a S02-types/ dir better, and can imagine other tests might fit there

[21:24] <Auzon> There's a bunch of tests there, such as ones for arrays, bools, enums, hashs, lists, nums, pairs, blocks, and subtypes

[21:24] <moritz_> ok, then it's fine

[21:24] <Auzon> S02-builtin_data_types is mostly empty

[21:25] <moritz_> I didn't see it alredy existed, sorry for the noise

[21:25] <Auzon> It's ok. :)

[21:26] <diakopter> perhaps Prelude tests should be marked/organized as such?

[21:26] <moritz_> I had nearly the same idea

[21:27] <moritz_> at some point it might be worth trying to separate prelude tests from language tests

[21:27] <moritz_> but sometimes it's hard for me to figure out what exactly is prelude, and what not

[21:27] <Auzon> Presumably, prelude tests should belong in its implementation's test directory

[21:28] <b_jonas> how would language tests even work without a prelude?

[21:28] <moritz_> no, because they are specced, and thus part of the language

[21:28] <b_jonas> they work with iniperl6 or something/

[21:28] *** wknight8111 left
[21:28] <diakopter> I wonder if multiple Prelude interpretations are permitted

[21:28] <diakopter> implementations, I mean

[21:28] *** armagad left
[21:29] <diakopter> I mean, other than the obvious yes

[21:30] <diakopter> pmurias: what's wrong with wanting to learn how to write a compiler [engine]?

[21:32] *** cjfields left
[21:32] * moritz_ hopes he's upgrading the debian in the right chroot (or even in the chroot at all)

[21:33] *** rdice left
[21:34] <b_jonas> diakopter: how would they coexist? same parrot space, or just different ones?

[21:34] <pugs_svnbot> r20997 | Auzon++ | [gsoc_spectest] t/data_types/* -> t/spec/S02-builtin_data_types/

[21:35] <b_jonas> in the second case I'd say surely yes, in the first case you'd have to take a bit of care so they don't clash (even if they're two copies of the same code)

[21:36] * moritz_ runs one of his magic tools to see if some of the newly moved tests pass on rakudo

[21:38] <diakopter> b_jonas: what do you mean

[21:38] <diakopter> oh, Preludes

[21:38] <diakopter> I meant each implementation having its own

[21:38] <b_jonas> diakopter: oh sure in that case

[21:38] <b_jonas> they'd probably need to have separate preludes

[21:38] <diakopter> but why'd you mention parrot

[21:39] <b_jonas> because some parts of the prelude would depend on internals of that implementations

[21:39] <b_jonas> parrot's not important

[21:39] <b_jonas> just whether it's in the same runtime space

[21:39] <b_jonas> like, whether some parts of the program could e.g. see an Array defined by one prelude and expecting an Array defined by the other prelude

[21:39] <b_jonas> or some other problem like that

[21:40] <b_jonas> probably that exact thing won't be the problem because of roles and stuff

[21:40] <b_jonas> (no-one actually wants an Array anyway)

[21:40] <b_jonas> but something like that

[21:40] <diakopter> BADArray

[21:40] <b_jonas> like

[21:40] <b_jonas> I don't know

[21:40] <moritz_> b_jonas: you could define a scheme that an implementation may provide parts of the prelude, and the rest is then loaded, which defines plain *everything*, and all definitions that are already there are ignored

[21:41] <moritz_> so if you can implement foo() in terms of bar() and the other way round, your prelude just includes both

[21:41] <b_jonas> moritz_: yeah

[21:41] <moritz_> and the implementation has provide at least one of them

[21:41] <b_jonas> actually it might be good if the prelude is coded so it's idempotent

[21:41] <b_jonas> like plain.tex is

[21:42] * diakopter looks up that word for the 3rd time this week

[21:44] <moritz_> my English <-> German translator says: English: idempotent. German: idempotent.

[21:44] *** jfredett_ joined
[21:45] <b_jonas> idempotent here means that you could load it a second time after it's already loaded and the second instance changes nothing

[21:45] <moritz_> ah, f(f(x)) = f(x) for all x

[21:45] <moritz_> b_jonas: that would be automatically true in the scheme I described above

[21:48] <TimToady> on the other hand, loading something only to override it is wasted computation on every invocation, unless you can freeze a checkpoint or something

[21:48] <TimToady> (which you probably want anyway)

[21:48] <diakopter>  .pmc

[21:49] <b_jonas> moritz_: I'm not completely familiar in what tasks are delegated to the perl6 prelude

[21:49] <b_jonas> but it can probably be solved that way

[21:49] *** jfredett left
[21:49] *** jfredett_ is now known as jfredett

[21:51] <TimToady> from the user's point of view it should not matter at all whether something is defined by the parser or by the prelude.  most of the operators in STD.pm could move to the prelude, which is why I put STD into the same directory in the first place

[22:00] <moritz_> t/spec/S02-builtin_data_types/num.t looks dubious to me

[22:00] <moritz_> ok(1i ~~ Num,    'Complex Numbers are Nums');

[22:01] <moritz_> is that test correct? don't think so

[22:01] <pugs_svnbot> r20998 | moritz++ | [spec] fudged num.t

[22:02] *** b_jonas left
[22:04] <Auzon> moritz_: What's the problem with it? :-/

[22:05] <moritz_> Auzon: that it allows to pass a complex number to everything that declares a "Num" interface

[22:05] <moritz_> rakudo: say 1i ~~ Num

[22:05] <p6eval> rakudo r28688 OUTPUT[0‚ê§]

[22:11] *** Limbic_Region joined
[22:15] <rhr> Complex isnota Num (Nums are Ordered)

[22:18] <moritz_> good point

[22:21] *** wknight8111 joined
[22:25] <pugs_svnbot> r20999 | rhr++ | [docs/p6types] All the synopses are done except S16+29

[22:28] * Auzon is tempted to just change the '1i ~~ Num' test and snag r21000, but won't.

[22:28] <moritz_> Auzon: why not? just remove it

[22:30] <Auzon> ok, I did.

[22:30] <pugs_svnbot> r21000 | Auzon++ | [gsoc_spectest] removing bad test for Complex matching Num found by moritz++.

[22:31] <moritz_> rakudo: say 54 + 1 + 12

[22:31] <p6eval> rakudo r28688 OUTPUT[67‚ê§]

[22:31] * moritz_ can't find 3 or 4 tests :(

[22:32] <Auzon> where?

[22:32] <moritz_> in the array.t i'm fudging right now

[22:37] *** Lorn left
[22:38] <rakudo_svn> r28689 | moritz++ | [rakudo] add passing test num.t to spectest_regression

[22:38] <pugs_svnbot> r21001 | moritz++ | [spec] start to fudge array.t, still needs much tweaking

[22:41] <diakopter>  .pmc

[22:42] *** lichtkind_ joined
[22:45] <pugs_svnbot> r21002 | moritz++ | [spec] S02-builtin_data_types/* 

[22:45] <pugs_svnbot> r21002 | moritz++ |    removed/replaced old kwid POD.

[22:45] <pugs_svnbot> r21002 | moritz++ |    Many of these tests still need smartlinks

[22:48] <rhr> here's a completely silly attempt to diagram the p6 role/class heirarchy: http://airen.bcm.umontreal.ca/p6types.png

[22:49] <rhr> green==is red==does

[22:49] <moritz_> that does look scary ;)

[22:50] <rhr> I left out all the 'is Any' connections

[23:00] *** lichtkind left
[23:01] *** edpratomo joined
[23:05] <meppl> good night

[23:06] *** meteorja1 joined
[23:07] *** meppl left
[23:09] *** Alias_ left
[23:10] <rakudo_svn> r28691 | moritz++ | [rakudo] more tests for spectest_regression

[23:11] <pmichaud> moritz++

[23:12] <moritz_> and Auzon++ for moving these tests (although they weren't all sanity-checked)

[23:13] <moritz_> somebody with tuits could convert Ovid++'s test on p6i into a test script

[23:14] * moritz_ had to go to bed right now :(

[23:15] *** audreyt_ joined
[23:39] *** japhb joined
[23:41] *** lichtkind_ left
[23:49] *** Jedai joined
[23:49] *** edpratomo left
[23:49] *** dolmen joined
