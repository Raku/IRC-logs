[00:00] <rakudo_svn> r33245 | jonathan++ | [rakudo] We need to be a bit careful to differentiate between Perl6Scalar (which just wraps up an argument) and ObjectRef (which we have when something is actually a reference type). Modify list() to know about this. Resolves RT#60404.

[00:14] *** stephens left
[00:21] <pugs_svn> r24070 | jnthn++ | [t/spec] Another test for passing with lists/scalar interaction that Rakudo currently gets wrong, pointed out by pmichaud++.

[00:21] <ruoso> TimToady, I'd be glad to help with S07, but I would need some help with the general document structure...

[00:27] *** bacek left
[00:39] <wayland76> ruoso: Have you considered structuring it like S29?

[00:40] <wayland76> committers++ :)

[00:41] *** hercynium left
[00:47] <wayland76> ruoso: I'd also suggest the following types of headings: a) The Iterator Role b) default implementation 1 c) default implementation 2...

[00:47] *** elmex left
[00:49] <ruoso> wayland76, wouldn't you like to start the document?

[00:49] <jnthn> TimToady,ruoso: It'd be nice if things like knowhow would make it into S12.

[00:49] <jnthn> Is there a document that explains this somewhere?

[00:50] <ruoso> jnthn, not really... but basically a knowhow is a Pure Prototype 

[00:50] <jnthn> What's the relationship between Class and ClassHOW?

[00:51] <jnthn> And how does it map to the class keyword?

[00:51] <ruoso> the idea is that every package declarator keyword relates to a metainstance (aka HOW)

[00:51] <ruoso> the mapping is done explicitly in the compiler (at least in mildew)

[00:52] <ruoso> in mildew, knowhow relates to the PurePrototypeHOW metainstance

[00:52] <ruoso> and class relates to ClassHOW metainstance

[00:52] <jnthn> OK, that makes sense, and we have something along those lines in Rakudo too. But more concretely, if you wanted to write your own custom metaclass (I guess that's the right word), say knowhow MyAwesomeThingyHOW { ... }, how would you introduce a keyword or something that means we can declare a class using that metaclass?

[00:53] <ruoso> jnthn, I'd be glad to have a standard way of doing that

[00:53] <jnthn> Aha, that hasn't been picked yet.

[00:53] <ruoso> kind of

[00:53] <ruoso> it actually have

[00:53] <ruoso> you need a custom grammar

[00:53] <ruoso> the custom grammar extends STD

[00:54] <ruoso> provides an additional package declarator multi token

[00:54] <ruoso> with the action that uses the given metainstance

[00:54] <jnthn> OK

[00:54] <jnthn> That much I guessed - it's what you'd write in that action.

[00:55] *** alc joined
[00:55] <ruoso> that's something that will probably be standard once the compiler bootstraps STD

[00:55] <jnthn> Sure, we don't need to know now I guess.

[00:55] <ruoso> yeah... mildew can just hard-code it for now

[00:55] <ruoso> I presume rakudo can also

[00:55] <jnthn> Yes, we already are.

[00:56] <ruoso> the pretty part about knowhow

[00:56] <ruoso> is that we can have the default metaclass instance for Perl 6 written in Perl 6

[00:56] *** DemoFreak left
[00:56] <ruoso> jnthn, have you ever seen the src-s1p code?

[00:56] <jnthn> The nice thing about Parrot is that it doesn't matter which language we wrote it in. ;-)

[00:56] <jnthn> URL?

[00:57] <ruoso> svn.pugscode.org/v6/smop/src-s1p/

[00:57] <ruoso> er

[00:57] <ruoso> almost that

[00:57] <ruoso> svn.pugscode.org/pugs/v6/smop/src-s1p/

[01:00] <jnthn> Are you running ClassHOW yet?

[01:00] <jnthn> Or is it prototype?

[01:01] <jnthn> (as in, what you expect it to look like)

[01:01] <ruoso> I'm working towards having it running

[01:01] <jnthn> Nice.

[01:01] <wayland76> ruoso: No commit bit; could I create it, and then e-mail it to you?

[01:01] <ruoso> feature-by-feature

[01:02] <ruoso> wayland76, that's cool

[01:02] <jnthn> Is p6opaque something that you define in your "guts" as it were?

[01:02] <ruoso> jnthn, yes... p6opaque is something "like" a native type

[01:02] <jnthn> OK

[01:02] <ruoso> that's why it's called p6"opaque" 

[01:02] <jnthn> Sure

[01:02] <ruoso> (and it's spec)

[01:02] <jnthn> Yes, I know.

[01:03] <jnthn> Likely maps to the Class PMC in Parrot.

[01:03] <ruoso> I'm actually pretty sure we could say p6opaque is a native type

[01:03] <ruoso> except it isn't really a type

[01:03] <jnthn> *nod*

[01:03] <ruoso> jnthn, but it doesn't implement any dispatch logic

[01:03] <jnthn> I guess how p6opaque is implemented kinda doesn't matter.

[01:03] <ruoso> except the logic to call the dispatch logic

[01:04] <jnthn> To dispatch the dispatch? ;-)

[01:04] <ruoso> yeah...

[01:04] <jnthn> lol

[01:05] <ruoso> that's where the REPR api comes in

[01:05] <ruoso> the p6opaque intercepts all REPR methods

[01:05] <ruoso> and call dispatch on it's HOW on everything else

[01:05] *** lichtkind joined
[01:05] <jnthn> I guess we need to work out what is standard API (that a Perl 6 programmar can expect to use standardly across implementations) and what isn't.

[01:05] <lichtkind> TimToady: at birth of perl you worked for unisys that was contracted by NSA for blacker project?

[01:06] <lichtkind> jnthn: hello

[01:06] <ruoso> yeah... the REPR API is not standard (at least not yet)... and that's why its use is limited to ClassHOW

[01:06] <jnthn> For example, I expect that the list of methods inside knowHOW

[01:06] <jnthn> Right.

[01:06] <ruoso> Object.pm (in that same directory) only use the HOW API (which is spec)

[01:06] <jnthn> oops, knowhow

[01:06] <jnthn> *nod*

[01:07] <ruoso> but I'd be very happy if we could share metaclass implementations

[01:07] <jnthn> Sure, we should work towards that.

[01:07] <ruoso> jnthn, do you see how the .^! methods in ClassHOW could be mapped in rakudo?

[01:07] <ruoso> s/methods/method calls/

[01:08] <jnthn> We already do have something called P6MetaClass that we do call, when building a class, things like add_method on already.

[01:08] <ruoso> right... that's the HOW API

[01:08] <jnthn> Right.

[01:08] <ruoso> http://www.perlfoundation.org/perl6/index.cgi?smop_oo_api

[01:08] <lambdabot> Title: SMOP OO API / Perl 6

[01:08] <ruoso> jnthn, ^

[01:08] *** IRSeekBot joined
[01:08] <jnthn> It's encouraging we've converged on something vaguely similarish.

[01:09] <ruoso> yeah...

[01:09] <jnthn> OK, so the HOW API we expect to be shared.

[01:09] <jnthn> As in, all implementations provide that.

[01:10] <jnthn> Which other ones?

[01:10] <ruoso> Method, Attribute etc

[01:10] <ruoso> which are built-in types

[01:10] <jnthn> Declaration API looks to me almost like I'd expect it to be part of the HOW API?

[01:10] <jnthn> That's listed in the knowhow too, right?

[01:10] <ruoso> that's how mildew works

[01:11] <ruoso> ClassHOW has add_method

[01:11] <ruoso> add_attribute and so on

[01:12] <ruoso> jnthn, pugs/v6/mildew$ perl mildew --file t/classhow_add_method_real.t --desugar

[01:12] <ruoso> it might look a little cryptic, but it's a pseudo-p6 output that represents how the code will run

[01:12] <ruoso> including the declaration of the class 

[01:12] <ruoso> and the knohow

[01:12] <ruoso> *knowhow

[01:13] <jnthn> I don't have a checkout of that handy, but will take a look at some point.

[01:13] <jnthn> Anyway, the API there looks pretty sane.

[01:13] <jnthn> For the HOW stuff.

[01:13] <ruoso> jnthn, let me paste it then

[01:14] <pasteling> "ruoso" at 201.9.45.79 pasted "perl mildew --file t/classhow_add_method_real.t --desugar" (86 lines, 4.6K) at http://sial.org/pbot/33382

[01:14] <jnthn> so everything below REPR API on that page is, for now, smop specific?

[01:14] <ruoso> looking at svn.pugscode.org/pugs/v6/mildew/t/classhow_add_method_real.t helps

[01:15] <ruoso> jnthn, yes

[01:15] <ruoso> but it would be really nice of you if you could see if that concepts could be mapped in rakudo

[01:15] <ruoso> so we could converge on that too

[01:15] <jnthn> ruoso: OK, it looks sane.

[01:15] <jnthn> (The parts above the REPR API)

[01:16] <jnthn> create/destroy/clone map almost exactly to Parrot PMC vtable methods.

[01:17] <ruoso> jnthn, btw... the title fonts are not very clear... but Declaration API is a subtopic of HOW API

[01:17] <jnthn> Ah, OK

[01:17] <jnthn> That's fine. :-)

[01:19] <jnthn> So basically, what comes inside knowhow ClassHOW is free to be implementation-specific? But the interface that is implemented inside the knowhow (e.g. the list of methods), we standardize on?

[01:19] <jnthn> Or we're aiming for our knowhow ClassHOW { ... } to look the same too?

[01:20] <ruoso> as the spec is today, having the same ClassHOW API is expected

[01:20] <ruoso> but I'd be very happy if we could share the knowhow ;)

[01:20] <jnthn> OK, but we can do what we need to do inside it.

[01:20] <jnthn> OK. And to do that we need to standardize on what additional things?

[01:21] <ruoso> the REPR api

[01:21] <jnthn> Aha.

[01:21] <jnthn> OK, let's set meeting what's in the spec in terms of the API happen first.

[01:22] <ruoso> cool

[01:22] <jnthn> I'd need to think a bit more about the representation API.

[01:22] <ruoso> jnthn, that's actually related to an old conversation we had on #parrot

[01:22] <jnthn> I'm very happy to see that the syntax for declaring other metaclasses has been fleshed out.

[01:23] <ruoso> that you need to be able to instantiate a Object using a different representatoin

[01:23] <ruoso> (that's spec)

[01:23] <ruoso> like, creating a Perl 6 Object instance with a p5Moose object

[01:24] <ruoso> that's how I got to the REPR api

[01:24] <jnthn> OK. But to me, since a PMC is essentially defining how a bunch of data is stored and has a common set of vtable methods...

[01:24] <ruoso> maybe it's just syntax

[01:24] <jnthn> I think that PMCs in reality are our representation.

[01:24] <ruoso> they are

[01:24] <jnthn> OK.

[01:25] <jnthn> So maybe Parrot isn't doomed to epic fail implementing Perl 6. ;-)

[01:25] <literal> I think I've asked this before without getting an answer. In the same way that Perl needs to figure out if you're feeding Perl 6 or Perl 5 code (e.g. check for a class declaration), how are Pod tools supposed to distinguish between Perl 6 .pod files and Perl 5 .pod files?

[01:26] <jnthn> Parrot already has PMCs for dealing with CStructs.

[01:26] <ruoso> jnthn, I had a conversation later with pmichaud or [particle] about the repr issue...

[01:26] <ruoso> and they explained to me that it would work that way

[01:26] <ruoso> (by "they" read "one of them", as I don't remember who it was)

[01:26] <jnthn> Aha.

[01:27] <ruoso> the big difference between SMOP and Parrot in that sense

[01:27] <ruoso> is that SMOP embraces foreign objects naturally

[01:27] <ruoso> because of the ResponderInterface thingy

[01:27] <ruoso> while Parrot will need a p5-like strategy to handle foreign objects

[01:27] <jnthn> In what sense?

[01:28] <ruoso> storing a pointer to the object and implement a mapping of the method dispatch

[01:28] <jnthn> OK, and SMOP instead does?

[01:28] <ruoso> SMOP doesn't have a public vtable

[01:29] <ruoso> then the dispatch is always delegated to the responder interface

[01:29] <ruoso> which means that everyone in smop only looks to the first int of any objec

[01:29] <ruoso> which holds a pointer to its RI

[01:29] <jnthn> A bit like a PMC holds a pointer to its vtable?

[01:30] <ruoso> this will allow us to have p5 SV* and SMOP__Object* coexisting peacefully

[01:30] <ruoso> (a slightly modified SV*)

[01:30] <ruoso> jnthn, afaiu, parrot access the vtable directly

[01:30] <jnthn> Aha, so it's between having to modify the thingy you want a representation of, or having a pointer to the thingy.

[01:31] <ruoso> actually about the hability of doing that morph

[01:31] <jnthn> morph?

[01:31] <ruoso> because for Gtk, for instance, I won't expect having a modified version

[01:31] <jnthn> OK, so how will that be handled?

[01:32] <ruoso> the same way p5 does, and the same way parrot does

[01:32] <ruoso> but the thing is that I don't have *a* PMC

[01:32] <ruoso> I have as many as I'd like

[01:32] <jnthn> Sounds like a slightly slighter-weight version of PObjs.

[01:32] <ruoso> including having two concurrent garbage collectors

[01:33] <jnthn> (Both PMCs and STRINGs in Parrot are forms of PObj)

[01:33] <ruoso> can you call arbitrary methods on PObj?

[01:34] <jnthn> No

[01:34] <ruoso> that's the difference

[01:34] <ruoso> as there's no public vtable

[01:34] <ruoso> every object is really an object

[01:34] <ruoso> where you can call an arbitrary method

[01:35] <ruoso> and its up to its responder interface to decide how to handle that

[01:35] <ruoso> in fact

[01:35] <ruoso> the only thing you can do

[01:35] <ruoso> is calling an arbitrary method

[01:35] <ruoso> there's nothing else

[01:35] <jnthn> Dynamic. :-)

[01:36] *** stephens joined
[01:36] <jnthn> It's an interesting design.

[01:36] <ruoso> I got there after some zen trainning with nothingmuch 

[01:36] <ruoso> and it brought me enormous benefits

[01:37] <ruoso> including being able to replace the interpreter implementation

[01:37] <ruoso> and have both interpreters running at the same time

[01:37] <jnthn> What do you mean by interpreter?

[01:37] <ruoso> the thing that holds a bytecode and evals it)

[01:37] <jnthn> Ah.

[01:37] <jnthn> Parrot has multiple runloop types too. :-)

[01:38] <jnthn> ...more than we really need in any one build, generally...

[01:38] * jnthn thinks we really don't need to compile every one of them in

[01:38] <jnthn> But that's a topic for #parrot. :-)

[01:39] <jnthn> Anyway, thanks for explaining the knowhow and the API

[01:39] <ruoso> the polymorphism in smop got to a point

[01:39] <jnthn> Would be great to get that into S12.

[01:39] <ruoso> that you don't even need to know the interpreter you're sending the execution to

[01:39] <ruoso> and it doesn't need to be built-in

[01:39] <jnthn> Pluggable. :-)

[01:39] <ruoso> that's how we're going to intergrate SMOP and P5

[01:40] <ruoso> using Coro

[01:40] <ruoso> SMOP will receive a Coro and just use it as if it was an interpreter frame

[01:40] <ruoso> because everything is an object,

[01:40] <jnthn> Sounds scary, but feasible.

[01:40] <ruoso> including the interpreter

[01:40] <ruoso> and everything is dispatched the same way

[01:40] <ruoso> all you need is a standard interpreter API

[01:41] <ruoso> our next adventure is a "C Coroutine Interpreter"

[01:41] <ruoso> so we can call C code and callback to SMOP still being stackless

[01:41] <jnthn> Yes, I saw the links to the C coroutine implementations earlier.

[01:42] <ruoso> that's how XS is going to work in SMOPP5

[01:43] <ruoso> about getting knowhow to S12... I think if TimToady sees that we're converging on that, he'll be very happy to spec it

[01:43] <jnthn> I'm happy enough with it; I may come up with things when implementing it.

[01:44] <jnthn> I wonder if we could add a trait...

[01:44] <jnthn> class Thingy is knowhow(Worrea) { ... }

[01:44] <jnthn> To make it trivial to create a class based upon a different metaclass without having to do grammar stuff to introduce your own keywords, if you don't want to.

[01:45] <jnthn> And it defaults to is knowhow(ClassHOW)

[01:45] <ruoso> jnthn, TimToady explained that he expects that to be using a different keyword

[01:45] <ruoso> it would be more like

[01:45] <ruoso> knowhow ClassHOW handles_package_declarator_keyword class  {}

[01:46] <jnthn> That still implies grammar changes, but makes it easier.

[01:46] <jnthn> oh

[01:46] <jnthn> in fact maybe

[01:47] <jnthn> package_declarator is the standard words plus a | <typename> <?{ is_know_howed($<typename>) }>

[01:47] <jnthn> Style thing.

[01:48] <ruoso> jnthn, hmm... interesting

[01:48] <jnthn> Where is_know_howed would return true if that name appears on after a handles_package_declarator_keyword

[01:48] <ruoso> that really could work

[01:49] <ruoso> jnthn, but notice that it doesn't need to be a knowhow to be a metaclass

[01:49] <ruoso> that's just the choice I made in smop/mildew

[01:49] <jnthn> It can be anything that implements the interface, right?

[01:50] <ruoso> right

[01:50] <jnthn> That's fine. We don't need to provide an easy way for everything. Just the common things. :-)

[01:50] <ruoso> but that actually makes it easier

[01:50] <ruoso> because you can have any type being used as a package declarator

[01:51] <ruoso> *package declarator handler

[01:51] <jnthn> ...ouch...

[01:51] <jnthn> I don't think we can quite get away with that. :-)

[01:51] <jnthn> Well

[01:51] <ruoso> why not?

[01:51] <jnthn> We can if you have to *register* your type as expecting to be one.

[01:51] <ruoso> sure sure

[01:51] <jnthn> OK, with that proviso, it works.

[01:51] <jnthn> Heck, we could just say you write 

[01:52] <jnthn> knowhow what_the_declarator_will_be_called { ... }

[01:52] <pugs_svn> r24071 | hinrik++ | [util/perl6.vim] highlight nested =end correctly

[01:52] <ruoso> you mean...

[01:52] <ruoso> typename typename { } ?

[01:52] <ruoso> typename1 typename2 { } ?

[01:52] <jnthn> No, I mean the knowhow keyword followed by the name of the declarator we want to introduce

[01:53] <ruoso> would make the declaration of typename2 to be handled by typename

[01:53] <ruoso> 1

[01:53] <jnthn> knowhow wob { ... }

[01:53] <jnthn> wob Foo { ... }

[01:53] <ruoso> jnthn, knowhow is not really package_declarator specific

[01:53] <ruoso> it's just a Pure Prototype implementation

[01:53] <jnthn> True. We maybe don't want to tie the two that closely.

[01:53] <jnthn> I'm just throwing out some ideas. :-)

[01:53] <ruoso> sure sure...

[01:54] <ruoso> it's just because I have some uses for knowhows in my mind

[01:54] <TimToady> knowhow package_declarator:<wob> maybe

[01:54] <ruoso> hmm

[01:54] <jnthn> Could work.

[01:55] <ruoso> indeed

[01:55] <jnthn> I quite like that.

[01:55] <ruoso> knowhow package_declarator:<class> { }

[01:55] <ruoso> class package_declarator:<foo> { }

[01:56] <ruoso> foo package_declarator:<bar> { }

[01:56] <ruoso> and you get haunted by circularity

[01:56] <ruoso> ;)

[01:56] <jnthn> Looks more like recursion to me... ;)

[01:57] <TimToady> not unless you do foo package_declarator:<knowhow>

[01:57] <jnthn> No no no...we were at something that sounded nice and implementable 30 seconds ago! :-P

[01:57] <ruoso> but that's ok

[01:57] <jnthn> knowhow package_declarator:<wob> seems nice to me.

[01:57] <ruoso> you would simply be hiding the old package_declarator:<knowhow>

[01:58] <ruoso> that sounds like bootstrap

[01:58] <jnthn> only with 'is instead' ;-)

[01:59] <jnthn> knowhow package_declarator:<class> is instead { ... } # well, all's fair if you predeclare...

[01:59] *** PtZ is now known as PZt

[01:59] <ruoso> class package_declarator:<controller> { } # and I have my custom catalyst controller

[02:00] <ruoso> and I only miss

[02:00] <jnthn> Not knowhow ...

[02:00] <jnthn> ?

[02:00] <ruoso> it can be any type, remember?

[02:00] <jnthn> I didn't say I thougth *that* part was a good idea... :-)

[02:00] <ruoso> too late ;)

[02:00] * jnthn tries to work out what it'd mean

[02:00] <ruoso> nothing special, really

[02:01] <jnthn> The thing is, that at the end of the day, knowhow has to have something that knows how to interpret the keywords inside it.

[02:01] <ruoso> only that the meta calls on the objects created by that keyword would be handled by that type

[02:01] <TimToady> kinda like sub infix:<XYZ> is not terribly special, other than the infixness

[02:01] <jnthn> I guess you'd just be declaring a knowhow but with the keywords in *it* defined by how the keywords in class are defined

[02:01] <ruoso> I wonder if we can extend that to other multi tokens

[02:01] <jnthn> And so on down the chain.

[02:02] <ruoso> like...

[02:02] <jnthn> knowhow routine_declarator:<mysub> { ... }

[02:02] <ruoso> class routine_declarator:<action> { } # and now I have my catalyst action

[02:02] <jnthn> This is sick and wonderful.

[02:02] <TimToady> .oO(make the bad voices go away!!!)

[02:03] <jnthn> The problem is that then anything we see could be a something declarator. I'm not sure how much that hurts our ability to parse efficiently. Maybe not at all.

[02:03] <jnthn> Well, not anything we see, but any type name we see.

[02:03] <TimToady> .oO(they're telling me to use the /electrocute_remotely irc command)

[02:03] <jnthn> ...we out-eviled TimToady?!

[02:04] <jnthn> Anyway, there's some nice ideas in here.

[02:04] <jnthn> So long as we don't do anything that will be an epic pain to implement and that will actually be useful to someone...

[02:05] <ruoso> we also need to consider how hard would it be to have the controller and action keywords without that

[02:05] <ruoso> to see if its worth the trouble

[02:05] <ruoso> maybe it's not that hard already

[02:05] <jnthn> macros.

[02:05] <ruoso> or extended grammar

[02:05] <jnthn> Yeah

[02:05] <ruoso> with customized actoins

[02:05] <jnthn> TMTOWTDI already.

[02:05] <jnthn> It just depends how easy we want to make it to do such things.

[02:06] <jnthn> I mean, writing customized actions to me is a bit hairy.

[02:06] <jnthn> (Well, of course, not really, I do it all day, but from the point of view of the folks using this stuff...)

[02:06] <ruoso> yeah... having a different routine_declarator keyword requires a different HOW api

[02:06] <jnthn> Yes.

[02:06] <ruoso> or a more abstract HOW api

[02:06] <jnthn> Personally, I'd rather restrict this to knowhow and package declarators.

[02:07] <jnthn> For Perl 6.0.0.

[02:07] <ruoso> I'm fine with that, but for me it doesn't matter if they are knowhows or whatever... 

[02:07] <ruoso> I'm only concerned that having a custom package_declarator doesn't change the HOW api

[02:07] <ruoso> it only change where to call the methods

[02:08] <jnthn> That would be my expectation.

[02:08] <ruoso> so that's fine

[02:08] <ruoso> having custom routine_declarators is a completely different story

[02:08] <jnthn> Yes

[02:08] <jnthn> I'm not so interested in that.

[02:09] <ruoso> I might be very much interested, but macros and custom grammars already solve it

[02:09] <jnthn> Yes.

[02:09] <jnthn> I can go with the "we can write class package_declarator:<foo> { ... } too

[02:10] <jnthn> As in, one metaclass defined according to the rules of another.

[02:10] <jnthn> That's not hard to implement.

[02:11] <jnthn> OK, so I think we agree on enough. :-)

[02:12] <ruoso> ok...

[02:12] <jnthn> I'll look at getting knowhow into Rakudo.

[02:12] <ruoso> :P

[02:13] <jnthn> I spent the day doing bug fixes, I'll be up for some feature implementation again soon. :-)

[02:14] <jnthn> I've landed the "fun task" of getting HLL debug info sorted out too, so we can report the right line numbers etc.

[02:14] <ruoso> nice... I'm pretty far from that point ;)

[02:15] <jnthn> I'm at the point where I've got a spec that I wrote and hoped someobdy else would implement. ;-)

[02:16] * jnthn doesn't really blame anyone for not wanting to do it...that part of Parrot is..."fun"

[02:18] <jnthn> ruoso: OK, was great to talk...I really should sleep now.

[02:18] * ruoso too

[02:18] <jnthn> If you're in Portugal, it's an hour later here than where you are. :-)

[02:19] <ruoso> nah...

[02:19] <ruoso> I'm back in brasil

[02:19] <jnthn> ...the fact that I'm still concious is thus a very bad thing. :-)

[02:19] <ruoso> and my son has born last week

[02:19] <jnthn> Ah, congrats! :-)

[02:19] <ruoso> which thanks

[02:19] <jnthn> That will cost sleep.

[02:19] <ruoso> yeah

[02:19] <ruoso> so... I should be sleeping already...

[02:19] <ruoso> for some time

[02:20] <jnthn> Same. Such is hacking. ;-)

[02:20] <wayland76> ruoso: How much of the http://www.perlfoundation.org/perl6/index.cgi?smop_map_operator did TimToady bless?

[02:20] <lambdabot> Title: SMOP map operator / Perl 6

[02:20] <wayland76> all of it, or just some?

[02:20] <wayland76> Or none?

[02:20] <ruoso> wayland76, I kinda understood that it's the starting point

[02:20] <ruoso> we would evolve from that

[02:20] <wayland76> Ok, so structure the document so it includes all that info

[02:20] <wayland76> can do :)

[02:21] <wayland76> I'll probably e-mail a few followup questions overnight

[02:21] <wayland76> (over your night)

[02:22] <wayland76> What's an ItemIterator again?

[02:22] <wayland76> (what's its purpose?)

[02:23] <ruoso> to provide a one-by-one view of the iteration

[02:23] <ruoso> even if the input is a grep

[02:23] <wayland76> (oh, and congrats on the son)

[02:23] <ruoso> (thanks)

[02:23] <ruoso> or a map

[02:24] <ruoso> which in slice context are completely different from list context

[02:24] <wayland76> Hmm.  Ok.  I'll have to think about that answer for a while, but I'm sure I'll get it :)

[02:24] <wayland76> Thanks!

[02:25] <wayland76> So ItemIterator is just a wrapper around Iterator?

[02:26] <wayland76> Or wait; is ItermIterator the user-facing mechanism

[02:26] <wayland76> ...and Iterator is what someone who wants to write their own iterator inherits from?

[02:26] <ruoso> ItemIterator is an iterator in item context

[02:26] <wayland76> (btw, feel free to go to bed; I can always e-mail these)

[02:27] * ruoso just realized he has to read some meeting minutes (for some meetings he missed)

[02:27] <jnthn> OH AWESOME the London Perl Workshop pre-workshop-meetup pub is walking distance to my hotel

[02:27] <ruoso> so feel free to ask

[02:28] <wayland76> jnthn: That's closer to a Perl Mongers meeting than I've ever been

[02:28] <wayland76> (Melbourne-PM is more than an hour from here, but I'm on their mailing list)

[02:28] <wayland76> ruoso: Ok, will do.

[02:29] <jnthn> wayland76: I'm really lucky since I moved to Slovakia.

[02:29] <jnthn> I've got Bratislava.pm right here in my city

[02:29] <jnthn> And Vienna.pm an hour away by train

[02:29] <wayland76> Cool :)

[02:29] <jnthn> Yeah.

[02:29] * jnthn loves Bratislava/Slovakia.

[02:30] <wayland76> Does eagerness go in S07-iterators?

[02:30] <ruoso> I think so

[02:30] <wayland76> I love souvlakia too :)

[02:30] <ruoso> TimToady has a spreadsheet in google docs somewhere

[02:30] <wayland76> especially a nice lamb souvlaki :)

[02:30] <ruoso> that lists S07 as iterators and lazyness/eagerness

[02:31] <wayland76> Ok, cool

[02:31] <wayland76> I can do that too then

[02:31] <jnthn> wayland76: You made me think I'd done a 3:30am typo then :-P

[02:31] <wayland76> Nah, just me.  I deserve PUNisment or something :)

[02:32] * jnthn groans

[02:32] * ruoso just finished reading the minutes.... 

[02:32] * ruoso sleep &

[02:32] <wayland76> 'night.  Enjoy :)

[02:32] <jnthn> night

[02:32] <ruoso> cya

[02:33] <jnthn> I guess given the time I should sleep too.

[02:33] * jnthn really needs to fix his body clock at some point

[02:34] <wayland76> Rebbot :)

[02:34] <wayland76> (sorry, reboot :) )

[02:34] <jnthn> :)

[02:34] <jnthn> Well, night @all

[02:34] <TimToady> night

[02:34] <wayland76> Stay up all night one night when you can afford to, and go to bed at 6pm the next day

[02:34] <wayland76> 'night :)

[02:35] <TimToady> decommuting &

[02:35] <wayland76> bye :)

[02:39] <wayland76> Does anyone know if p6l takes attachments?

[02:49] <pugs_svn> r24072 | hinrik++ | [util/perl6.vim] added preliminary syncing hints

[03:01] <lichtkind> timtoa

[03:01] <lichtkind> TimToady: seen my question?

[03:04] <pugs_svn> r24073 | hinrik++ | [util/perl6.vim] behave accordingly on older vim versions

[03:05] <wayland76> He's decommuted now

[03:11] *** lichtkind left
[03:31] *** Psyche^ joined
[03:37] *** slavik joined
[03:43] *** Patterner left
[03:43] *** Psyche^ is now known as Patterner

[03:45] *** hercynium joined
[04:18] *** hercynium left
[04:36] *** dukeleto joined
[04:36] <literal> what is $¢ ?

[04:37] *** sri_kraih__ left
[04:38] <slavik> ...

[04:39] <literal> I see it all over STD.pm

[04:39] <slavik> no idea

[04:39] <slavik> since the second char is missing from my keyboard

[04:39] <literal> altgr+c here

[04:40] <slavik> altgr is where?

[04:40] * slavik has a standard 105key keyboard

[04:40] <literal> it's the right alt key

[04:40] <slavik> or 104, w/e it is

[04:42] <pugs_svn> r24074 | hinrik++ | [util/perl6.vim] reorganization

[04:45] *** aindilis left
[04:46] *** aindilis joined
[04:47] <pugs_svn> r24075 | hinrik++ | [util/perl6.vim] add note about modeline

[04:49] *** dukeleto left
[04:51] <pmichaud> $¢ is the current match state -- see S05

[04:52] *** smallfish joined
[04:54] <literal> I see

[04:56] <literal> I'm curious, are any other non-ascii symbols being used by default? other than ¢ and «»

[04:59] <pmichaud> I think those are the only ones at the moment.

[05:01] *** smallfish left
[05:02] <pugs_svn> r24076 | pmichaud++ | [t/spec]: Unfudge tests for ^@list, correct one test.

[05:02] <pugs_svn> r24077 | pmichaud++ | [t/spec]:  Correct plan in passing-arrays.t .

[05:10] <rakudo_svn> r33257 | pmichaud++ | [rakudo]:  Fix ^@list semantics, RT #60828.

[05:11] <slavik> rakudo: say "hello"

[05:11] <p6eval> rakudo 33256: OUTPUT[hello␤]

[05:19] <pmichaud> rakudo:  my @list = <a b c>;  say ^@list;

[05:19] <p6eval> rakudo 33257: OUTPUT[012␤]

[05:19] <pmichaud> yay.

[05:32] <wayland76> rakudo:  my @list = <a b c>;  say @list;

[05:32] <p6eval> rakudo 33257: OUTPUT[abc␤]

[05:32] <wayland76> (just testing :) )

[05:37] <literal> rakudo say ^<a b c>

[05:37] <literal> rakudo: say ^<a b c>

[05:37] <p6eval> rakudo 33257: OUTPUT[012␤]

[05:55] *** iblechbot joined
[05:56] *** Entonian joined
[06:06] <pugs_svn> r24078 | putter++ | [elf_h] Parenthesized a not(), correcting precedence: (not(...)) && ...

[06:06] <pugs_svn> r24078 | putter++ | STD_red incorrectly treats not() as a function, rather than as a prefix op.

[06:06] <pugs_svn> r24078 | putter++ | In this case, that nested improperly.

[06:06] <pugs_svn> r24078 | putter++ | The "not(...)" idiom (15 cases) seems likely to breed bugs.

[06:14] <pugs_svn> r24079 | putter++ | [STD_blue] Created a STD_blue-specific PrimitivesP5.pm mutant.  Also tweaked multis.

[06:14] <pugs_svn> r24079 | putter++ | gimme5 currently requires too much memory to parse elf_h's PrimitivesP5.pm.  So now there's a modified copy which works around the problem.

[06:14] *** mncharity joined
[06:18] <mncharity> @tell TimToady It looks like viv is having trouble with unicode french quotes.  eg,  multi infix:sym«<»  ($a,$b) {33}  has mangled text in the tree.

[06:18] <lambdabot> Consider it noted.

[06:19] <mncharity> looks like I'll need to teach elf about infix:['<'] or some such.

[06:20] <mncharity> another day.

[06:20] <mncharity> happy holiday all &

[06:20] <mncharity> (for whom it's a holiday;)

[06:20] *** mncharity left
[06:22] *** DemoFreak joined
[06:45] *** ashizawa joined
[06:53] *** iblechbot left
[07:18] *** sri_kraih joined
[07:21] <pugs_svn> r24080 | lwall++ | [STD] not() etc. is a function call

[07:21] <pugs_svn> r24080 | lwall++ | [S03] prefix:<^> no longer tries to get fancy with lists

[07:28] *** Entonian left
[07:33] <pugs_svn> r24081 | hinrik++ | [util/perl6.vim] pick pattern delimiters consistently

[07:36] <pugs_svn> r24082 | bacek++ | [spec] Added todoed test for assing-is-not-binding

[07:40] <rakudo_svn> r33258 | chromatic++ | [Rakudo] Added vtable delegate for get_pmc_keyed_int to Perl6MultiSub, as

[07:40] <rakudo_svn> r33258 | chromatic++ | r33253 now allows subclasses of MultiSub to store multis in a NameSpace PMC.

[07:40] <rakudo_svn> r33258 | chromatic++ | Bacek reported that this broke t/spec/S03-operators/assign-is-not-binding.t.

[07:46] <pugs_svn> r24083 | lwall++ | [Spec] undelete some accidentally deleted history

[07:48] <pugs_svn> r24084 | lwall++ | [Spec] delete de-historied files

[07:49] <pugs_svn> r24085 | lwall++ | [Spec] put historied versions back to long names

[07:53] <TimToady> @tell mncharity the « problem is probably just the typical non-dealing of yaml with unicode

[07:53] <lambdabot> Consider it noted.

[07:55] *** aindilis left
[07:56] *** aindilis joined
[08:06] *** pbuetow joined
[08:24] *** bacek_ left
[08:30] <rakudo_svn> r33262 | chromatic++ | [Rakudo] Removed debugging code accidentally committed in r32992.

[08:30] <pugs_svn> r24086 | hinrik++ | [util/perl6.vim] map Perl 6 syntax groups more closely to vim's

[08:31] *** DemoPhreak joined
[08:33] *** ejs joined
[08:33] *** slavik left
[08:35] <pugs_svn> r24087 | hinrik++ | [util/perl6.vim] add todo item for a perl_string_as_statement feature

[08:35] *** pbuetow left
[08:35] *** justatheory joined
[08:36] *** smg left
[08:38] *** iblechbot joined
[08:47] *** DemoFreak left
[08:49] *** adc_penner joined
[08:54] *** jferrero joined
[09:06] *** kanru left
[09:07] *** smallfish joined
[09:07] *** kanru joined
[09:08] *** Bzek joined
[09:17] *** alc left
[09:18] *** bacek joined
[09:20] *** adc_penner left
[09:29] *** smallfish left
[09:45] *** elmex joined
[09:46] *** renormalist joined
[09:54] *** alech_ joined
[09:54] *** alech left
[10:03] *** iblechbot left
[10:06] *** jferrero left
[10:06] *** smg joined
[10:10] *** DemoPhreak left
[10:16] *** justatheory left
[10:23] *** ruoso left
[10:28] <moritz_> wayland76: re "no commit bit", you can easily get one

[10:28] *** vixey joined
[10:28] <moritz_> wayland76: just /msg me your email address and desired nick

[10:35] *** smg left
[10:41] *** jferrero joined
[10:53] *** Southen joined
[11:12] *** Southen_ left
[12:05] *** smg joined
[12:35] *** ruoso joined
[12:36] <ruoso> wayland76, hi

[12:37] <ruoso> the idea of different types for the iterator in each context, is that the behavior depends on the context in which the operator is

[12:37] <ruoso> for instance...

[12:37] <ruoso> my $a = @list.Iterator();

[12:37] <ruoso> that gets you an "Iterator in Item context"

[12:37] <ruoso> which basically means that every time you do =$a

[12:37] <ruoso> you will always get one element, and only one element

[12:38] <ruoso> until the iterator is over

[12:38] <ruoso> my @a = @list.Iterator();

[12:38] <ruoso> gets you a Lazy List

[12:38] <ruoso> that will traverse the iterator as needed

[12:38] <ruoso> but flattening the results of the iterator in the process

[12:38] <ruoso> but if you do

[12:39] <ruoso> my @@a = @list.Iterator();

[12:39] <ruoso> then you have a Lazy Slice

[12:39] <ruoso> where the first dimension is the number of actual iterations

[12:39] <ruoso> and the second is the elements of each iteration

[12:40] <ruoso> (btw... the code above is illustrative...

[12:40] <ruoso> you won't be calling .Iterator(), most of the time

[12:40] <ruoso> that's up to the runtime)

[12:41] <ruoso> the most important problem this solves

[12:42] <ruoso> is how to get slices working properly with map

[12:42] <ruoso> which is one of the most complicated examples, I think

[12:42] <ruoso> the interesting point about having different types for each context

[12:43] <ruoso> is that the non-context-aware Iterator type always return a capture

[12:43] <ruoso> and the item iterator, the lazy list and the lazy slice can be generic

[12:43] <ruoso> we can have a GenericItemIterator

[12:43] <ruoso> a GenericLazyList

[12:43] <ruoso> and a GenericLazySlice

[12:44] <ruoso> where they hold a pointer to the input iterator

[12:44] <ruoso> and implement the specifics of turning the "one capture per iteration" into the desired behavior of each context

[12:45] <ruoso> one point I'm not sure now

[12:45] <ruoso> is if this contextualization should happen directly

[12:45] <ruoso> or if the runtime should explicitly create the generic iterator tyhpes

[12:46] <ruoso> and just use the plain Iterator

[12:46] *** iblechbot joined
[12:46] <ruoso> after we realized that the lazyness-eagerness control doesn't belong to the List or Iterator object itself,

[12:46] <ruoso> but to the runtime

[12:47] <ruoso> it's fairly reasonable to assume that the Iterator type always return one-capture-per-iteration

[12:47] <ruoso> and the runtime should then create the generic-lazy-list or whatever to consume that

[12:49] <ruoso> TimToady, I think the above reasoning clears it up a little bit... 

[13:03] *** justatheory joined
[13:05] *** lichtkind joined
[13:13] <wayland76> ruoso: I see why that gives us different iterator classes, but why do we need different roles?

[13:14] <ruoso> wayland76, maybe ItemIterator can be a class

[13:14] <ruoso> Iterator is certainly a role

[13:14] <ruoso> because the iterator returned by each list is private to that list

[13:15] <wayland76> ok, that makes sense, and I think it lines up with the document that I sent you

[13:16] <ruoso> wayland76, I'm already working on it

[13:16] <ruoso> I'm expanding the first section a little bit

[13:16] *** vixey left
[13:17] <wayland76> oh, ok :).  My plan was to get feedback from you, and update it myself, but it's bedtime for me soon, so if you want to do it, wonderful :)

[13:18] <wayland76> Hmm, I just ran it through pod2man from perl5; not all formatted nicely :).  I didn't actually test the POD yet (I was expecting to do more hacking on it)

[13:18] <moritz_> both of you, feel free to put it into the pugs repo, then more eyes can see it

[13:19] <wayland76> Yeah, that's the plan, it's just I probably wrote some things that are downright wrong :), so I sent it to ruoso for review first.  

[13:20] <wayland76> ruoso: I attached the laziness, etc, to the Iterator, but the runtime could set the default, as it were.

[13:20] <wayland76> But no doubt that's wrong too :)

[13:20] <pugs_svn> r24088 | ruoso++ | [spec] Adding the first sketches on S07, thanks to wayland76++

[13:21] <wayland76> Ooh, I have a karma of one!  Excitement plus :).

[13:21] <moritz_> perlbot: karma wayland76

[13:21] <perlbot> Karma for wayland76: 2

[13:21] <ruoso> take a look at the first part, I already expanded it a little

[13:25] <moritz_> ruoso: my @a <== grep { ... } <== map { ... } <== grep { ... }, 1, 2, 3

[13:25] <moritz_> is completely lazy, even if 1,2,3 is a fairly small known compact list.

[13:25] <moritz_> ruoso: notice that the first grep (ie the last in the line) is not strictly lazs

[13:25] *** [particle]1 joined
[13:25] <moritz_> *lazy

[13:25] <ruoso> moritz_, oh... I meant a feed there too

[13:26] <wayland76> (btw, thanks to whoever gave me the extra karma :) )

[13:30] <wayland76> ruoso: The improved S07 is good :).  Is there a way the laziness can be user-adjustable?

[13:30] <ruoso> wayland76, the syntax indicates the level

[13:31] *** justatheory left
[13:32] <wayland76> Ok; would I be right in saying that the choice (made by the runtime) is decided on by a combination of the operators (or whatever) and the iterators?

[13:32] *** justatheory joined
[13:32] <ruoso> yes

[13:33] <ruoso> actually

[13:33] <ruoso> not

[13:33] <wayland76> great :)

[13:33] <ruoso> the first part yes

[13:33] <ruoso> the second part not

[13:33] *** justatheory left
[13:33] <wayland76> ok :)

[13:33] <ruoso> it's external to the objects

[13:33] <wayland76> Also, you say "But it's important to notice that eagerness takes precedence over lazyness" -- does that mean that mostly-lazy takes precedence over strictly-lazy?

[13:34] <wayland76> Ah, the iterators are entirely unrelated to the *decision* about the laziness, and merely feel the *effects*

[13:34] <ruoso> exactly

[13:35] <wayland76> (exactly precedence, or exactly decision/effects?)

[13:35] <ruoso> decision/effects

[13:35] <ruoso> mostly-lazy wouldn't make a strictly-lazy less lazy, because the lazyness of the input is when the mosltly-lazy stops

[13:36] <wayland76> Ok.  I just think we should clarify it either way :)

[13:36] <ruoso> but mostly-lazy is not more eager than strictly lazy

[13:36] <ruoso> it's less lazy

[13:36] <ruoso> but it's still not eager

[13:39] <wayland76> Yup :).  But because of the use of a "precedence table" in the Operators page, I thought the list of lazinesses could lull people into thinking the other way :)

[13:39] *** spx2 left
[13:40] *** spx2 joined
[13:41] *** ejs left
[13:42] <wayland76> I think I finally see the advantage of an ItemIterator role; someone creating a new iterator need only create an ItermIterator, and the others will be auto-created for him, right?

[13:42] <ruoso> the opposite

[13:42] <ruoso> it only needs to create the Iterator

[13:42] <ruoso> the use in the other contexts will be available 

[13:43] <ruoso> but again, the runtime is the one instantiating this generic objects most of the time

[13:44] <wayland76> I'm thinking from the point of view of someone who wants to write some tree iterators :)

[13:44] <ruoso> you only need to provide a .Iterator() method in your tree

[13:45] <ruoso> and return a private object that does Iterator

[13:45] <ruoso> the runtime can then use the generic item iterator with your iterator as input

[13:45] <ruoso> or the generic lazy slice

[13:45] <ruoso> which probably makes more sense to a tree

[13:45] <wayland76> That sounds reasonable :)

[13:46] <wayland76> is that .Iterator method documented anywhere?

[13:47] <ruoso> S07 ;)

[13:47] <wayland76> I have more questions, but I'll await the rest of your S07 revisions

[13:47] *** [particle] left
[13:47] <wayland76> Time for sleep now :)

[13:47] <wayland76> although it is only 12:46am :)

[13:47] <wayland76> 'night all :)

[13:48] <moritz_> good night wayland76 :)

[13:48] <wayland76> sleep &

[13:49] <pugs_svn> r24089 | ruoso++ | [spec] general S07 cleanup, I think that can be considered the first version.

[13:49] <pugs_svn> r24089 | ruoso++ | Most of the cleanup is related to accepting that it is runtime s responsability to instantiate the GenericLazyList when needed, and not the Iterator itself

[13:49] <ruoso> wayland76, ^

[13:53] <wayland76> (just remembered one last thing before bed, so I'm back for just a mo)

[13:53] <wayland76> ruoso: Yeah, I see that :).  Will review tomorrow, I hope.  

[13:53] <wayland76> @karma everyone

[13:53] <lambdabot> everyone has a karma of 0

[13:53] <wayland76> everyone++

[13:54] <wayland76> good-night again :)

[13:57] <pugs_svn> r24090 | ruoso++ | [spec] Small text revisions on S07

[13:58] *** [particle]1 left
[14:00] *** ejs joined
[14:03] *** [particle] joined
[14:07] <pugs_svn> r24091 | ruoso++ | [spec] small code examples on how to get the generic item iterator, lazy slice and lazy list

[14:14] <ruoso> moritz_, so... do you think this initial sketch is sane?

[14:15] *** zamolxes joined
[14:15] <ruoso> TimToady, should feed operators be strictly lazy or just mostly lazy?

[14:16] *** ejs left
[14:16] *** ejs joined
[14:27] *** Limbic_Region joined
[14:31] *** LimbicRegion joined
[14:31] *** Limbic_Region left
[14:31] *** LimbicRegion is now known as Limbic_Region

[14:33] *** ashizawa left
[14:47] *** jferrero left
[14:50] *** rindolf joined
[14:51] *** masak joined
[14:58] <pugs_svn> r24092 | ruoso++ | [spec] lazyness applies to every object 

[15:32] <pmichaud> Happy U.S. Thanksgiving Day, all.

[15:58] <moritz_> ruoso: I'm not really involved in the iterator business, but I've found nothing insane in S07

[15:59] <ruoso> moritz_, thanks

[16:01] *** zamolxes left
[16:02] * ruoso just sent an aggressive-approach message in the "Files, Directories, Resources, Operating Systems" thread...

[16:05] *** zamolxes joined
[16:08] *** schmalbe joined
[16:09] * masak just read ruoso's mail

[16:10] <masak> ruoso: your mail essentially means that you have to compile the program on the same type of box as you run it, no?

[16:10] <masak> at least if you're doing file stuff

[16:10] <ruoso> not at all..

[16:11] <ruoso> hmm....

[16:11] <masak> then please explain what you mean by "have the POSIX module imported (where chmod would be in the default exports) by the prelude when in a posix machine"

[16:11] <ruoso> the prelude is loaded in every runtime

[16:11] <masak> ah.

[16:11] <masak> ok, then that's not a problem.

[16:12] <ruoso> but if you call chmod in a Win32 machine

[16:12] <ruoso> it would probably break...

[16:12] <ruoso> but I think that'd be expected

[16:15] <masak> aye

[16:15] <masak> still feels a little unnerving to have this done automatically behind-the-scenes

[16:15] <masak> will lead to all kinds of "interesting" FAQs

[16:16] <ruoso> well.. it would basically mean that you wouldn't call "perldoc -f open" but "perldoc POSIX" to see how to open a file

[16:17] <ruoso> or "perldoc Win32" if you're programming for windows

[16:17] *** iblechbot_ joined
[16:18] <ruoso> but as I said in the email, that doesn't stop anyone from implementing a File class 

[16:18] <masak> I mean, a non-portable script written for POSIX will stop working on Windows.

[16:19] <ruoso> that implements File.open() in a more abstract way

[16:19] <ruoso> masak, hmm... I think that's the definition of non-portable

[16:19] <masak> aye

[16:19] *** Limbic_Region left
[16:19] <masak> except that here it's not predeclared through a pragma, just assumed

[16:19] <masak> that's the unnerving part, not the fact that it's non-portable

[16:20] <ruoso> yeah....

[16:20] <ruoso> but one could have a Win32::POSIX emulator

[16:20] <ruoso> and just invoke this same script with -MWin32::POSIX

[16:20] <masak> I see.

[16:21] <ruoso> but I really don't think it needs to be there by default

[16:21] <ruoso> in summary... "open" is no longer a "core built-in operator", it's just a "sub loaded by a module"

[16:22] <masak> that part I like.

[16:26] <ruoso> but considering the ration between perl unix/win32 programmers

[16:26] <ruoso> I think it probably makes sense to have the Win32::POSIX module loaded by default in Win32 machines

[16:27] * ruoso .oO( we have our own cygwin )

[16:27] *** justatheory joined
[16:29] *** sri_kraih_ joined
[16:30] *** iblechbot left
[16:33] *** IRSeekBot left
[16:44] *** sri_kraih left
[17:08] *** jhorwitz_ joined
[17:25] *** zamolxes left
[17:25] *** jhorwitz left
[17:36] *** justatheory left
[17:42] *** justatheory joined
[17:46] * ruoso later &

[17:46] *** ruoso left
[17:47] *** slavik joined
[17:49] *** meppl joined
[17:52] <pugs_svn> r24093 | moritz++ | [t] split oo/meths/multi.t into t/spec/S12-methods/multi2.t and

[17:52] <pugs_svn> r24093 | moritz++ | t/unspecced/yaml-eval.t

[17:56] <pugs_svn> r24094 | moritz++ | [t/spec] unfudge a test for rakudo

[18:02] *** lichtkind_ joined
[18:02] *** lichtkind_ left
[18:06] <pugs_svn> r24095 | moritz++ | [t/spec] ouch, multi2.t contained roughly the same tests as multi.t.

[18:06] <pugs_svn> r24095 | moritz++ | Deleting..

[18:08] *** lichtkind_ joined
[18:13] *** [particle]1 joined
[18:20] *** lichtkind left
[18:20] *** aindilis left
[18:25] <pugs_svn> r24096 | hinrik++ | [util/perl6.vim] keep contains= at the end of region definitions

[18:27] *** [particle] left
[18:34] <pugs_svn> r24097 | hinrik++ | [util/perl6.vim] fix typo in keyword

[18:35] *** ejs left
[18:38] *** adc_penner joined
[18:45] *** vixey joined
[18:47] *** Limbic_Region joined
[18:47] *** ejs joined
[18:50] *** DemoFreak joined
[18:51] *** Limbic_Region left
[18:52] *** Limbic_Region joined
[18:53] *** pbuetow joined
[18:55] *** LimbicRegion joined
[18:56] *** LimbicRegion left
[19:13] *** Limbic_Region left
[19:19] *** mncharity joined
[19:20] <mncharity> TimToady: unicode issue now resolved.  fyi.  thanks.

[19:20] <lambdabot> mncharity: You have 1 new message. '/msg lambdabot @messages' to read it.

[19:20] *** mncharity left
[19:22] *** justatheory left
[19:35] *** Bzek left
[19:48] *** masak is now known as ca

[19:49] *** adc_penner left
[19:49] *** spx2 left
[19:49] *** drbean_ left
[19:49] *** lambdabot left
[19:50] *** clkao joined
[19:50] *** pasteling joined
[19:50] *** nothingmuch joined
[19:50] *** allbery_b joined
[19:50] *** ewilhelm joined
[19:50] *** rhr_ joined
[19:50] *** lizsac joined
[19:50] *** lambdabot joined
[19:50] *** drbean_ joined
[19:50] *** spx2 joined
[19:50] *** adc_penner joined
[19:53] <slavik> is there a site with Perl6 sample code?

[19:54] <moritz_> slavik: http://github.com/viklund/november/ is a working wiki in Perl 6

[19:54] <slavik> no, I mean, something that shows sample usage of various features

[19:54] <slavik> like some code that shows how to create a class and such

[19:54] <slavik> but something that works ... heh

[19:55] <moritz_> ;)

[19:55] <moritz_> anyway, I've also written http://perlgeek.de/blog-en/perl-5-to-6/ which contains lots of micro-examples

[19:55] <lambdabot> Title: blog | Perlgeek.de Blog :: Category Perl-5-to-6

[19:56] *** lichtkind_ left
[19:56] <slavik> yes, many of which don't work :P

[19:57] <slavik> like the grammar example

[19:57] <slavik> since assertions aren't implemented yet

[19:57] <slavik> at least in rakudo

[19:58] <moritz_> right

[19:59] *** justatheory joined
[19:59] <moritz_> the test suite contains much Perl 6 code, and you can find out very easily if it works or not ;-)

[19:59] <slavik> my test suite is rakudo ;)

[20:00] <slavik> revision 33172 at the moment

[20:04] <slavik> moritz_: any wiki software you can recommend?

[20:04] <moritz_> slavik: I haven't set up any

[20:04] <slavik> k

[20:05] <moritz_> I just know one that you shouldn't use: socialtext

[20:05] <slavik> how come?

[20:05] * slavik is actually looking at it right now

[20:06] <moritz_> I used the instance at http://www.perlfoundation.org/perl6/index.cgi?perl_6 ...

[20:07] <lambdabot> Title: Perl 6 / Perl 6

[20:07] <moritz_> first of all the pages don't display correctly without javascript

[20:07] <moritz_> then take a look at the "diffs" between revisions - so much text and so little information...

[20:08] <moritz_> its approach to editing conflicts is "the article has changed in the mean time, go figure it out yourself"

[20:08] <slavik> I see

[20:08] <slavik> what does wikipedia use?

[20:08] <slavik> I notice that lots of other wikis use it

[20:08] <moritz_> it's called wikimedia

[20:09] <moritz_> and it's a PHP thing written for wikipedia

[20:10] <slavik> maybe I'll just isntall a CMS ...

[20:10] <slavik> like e107

[20:10] <slavik> or something

[20:23] *** ZuLuuuuuu joined
[20:35] *** rindolf left
[20:43] <ca> moritz_: actually, "MediaWiki".

[20:43] <slavik> ca: ty

[20:44] <moritz_> ca: ah, right

[20:44] <ca> WikiMedia is something else.

[20:44] <moritz_> yes, the organization

[20:44] <slavik> wikimedia is the company

[20:44] *** schmalbe left
[20:54] *** pbuetow left
[21:15] *** pbuetow joined
[21:18] *** pmurias joined
[21:18] *** justatheory left
[21:27] <pmurias> the synopsis live in the pugs repo now?

[21:27] <lambdabot> pmurias: You have 4 new messages. '/msg lambdabot @messages' to read them.

[21:27] <moritz_> aye

[21:28] <pmurias> moritz_: why the move?

[21:30] <moritz_> pmurias: TimToady wanted them to be easier hackable for others

[21:31] *** pbuetow left
[21:43] *** ZuLuuuuuu left
[21:49] <wayland76> ...and it's worked.  We now have S07 :)

[21:51] *** ca is now known as masak

[21:53] <moritz_> let's say we have a draft of S07 - but still great ;-)

[22:03] <wayland76> Yeah, sorry; agreed :)

[22:03] <masak> so the correct behaviour of @a Z @b is to stop as soon as one of the arrays run out, yah?

[22:04] *** apeiron left
[22:06] *** pbuetow joined
[22:06] <wayland76> Btw, whoever was wanting to write S00, I use http://perlcabal.org/syn/ which isn't as up-to-date as TimToady's spreadsheet, but it loads quicker and has other stuff :)

[22:06] <lambdabot> Title: Official Perl 6 Documentation

[22:06] <masak> perl6: say undef ~~ Undef

[22:06] <p6eval> pugs: No output (you need to produce output to STDOUT)

[22:06] <p6eval> ..rakudo 33276: OUTPUT[Method 'ACCEPTS' not found for invocant of class 'Undef'␤current instr.: 'infix:~~' pc 14285 (src/gen_builtins.pir:8666)␤]

[22:06] <p6eval> ..elf 24097: OUTPUT[Can't call method "Str" on an undefined value at ./elf_f line 649.␤ at ./elf_f line 3861␤]

[22:07] * masak reports rakudobug

[22:07] <moritz_> where is Undef specced?

[22:07] <masak> nowhere, it seems

[22:07] <masak> S02 talks about Undefined types, that's all

[22:07] <moritz_> right

[22:08] <masak> ok, the bug is with me

[22:08] <moritz_> an undefined type is one where the object's .defined method returns false

[22:08] <masak> rakudo: say undef.WHAT

[22:08] <p6eval> rakudo 33276: OUTPUT[Failure␤]

[22:08] <masak> rakudo: say undef ~~ Failute

[22:08] <p6eval> rakudo 33276: OUTPUT[1␤]

[22:08] <wayland76> masak: re: @a Z @b -- yes, documented in S29

[22:08] <masak> rakudo: say undef ~~ Failure

[22:08] <p6eval> rakudo 33276: OUTPUT[1␤]

[22:08] *** pjcj joined
[22:08] <wayland76> (as "zip")

[22:08] <moritz_> it could just as well be Object

[22:08] <masak> wayland76: thanks

[22:09] <masak> moritz_: hm.

[22:09] <masak> moritz_: I'm writing an is_deeply function, post-#58392

[22:09] <masak> moritz_: when I have two undefs in the respective places in the data structures, I want to return True

[22:09] <masak> but how do I detect that something is undef?

[22:10] <masak> do I do !$x.defined ?

[22:10] <moritz_> two undefined objects aren't always the same

[22:10] <moritz_> rakudo: say undef === undef

[22:10] <p6eval> rakudo 33276: OUTPUT[0␤]

[22:10] <masak> moritz_: let's just say I want to treat them as 'equivalent' in this particular case.

[22:11] <moritz_> masak: I'd say $a ~~ undef && $b ~~ undef && $a.WHAT eq $b.WHAT

[22:11] <masak> or is there a strong reason I shouldn't?

[22:11] <masak> moritz_: yes, that's good. thanks.

[22:11] <masak> any reason not to say $a & $b ~~ undef ?

[22:11] <moritz_> that'l treat 'my $x' and 'my Int $x' differently - don't know if you want that

[22:11] <moritz_> masak: no, a junction is fine there

[22:11] <masak> only time will tell.

[22:12] <masak> goodie.

[22:12] *** apeiron joined
[22:14] <masak> rakudo: say undef ~~ undef; say undef & undef ~~ undef

[22:14] <p6eval> rakudo 33276: OUTPUT[1␤0␤]

[22:14] <masak> what's going on there?

[22:15] <moritz_> rakudobug!

[22:15] <masak> finally :)

[22:15] <wayland76> Sure?

[22:15] <moritz_> rakudo: say undef ~~ undef; say ?(undef & undef ~~ undef)

[22:16] <p6eval> rakudo 33276: OUTPUT[1␤0␤]

[22:16] <masak> sent.

[22:16] <moritz_> wayland76: sure.

[22:16] <wayland76> I would've assumed that any undef & whatever would always come up 0

[22:16] <masak> probably the junction as a whole is tested against the undef

[22:16] <masak> wayland76: why?

[22:16] <moritz_> undef & undef ~~ undef dispatches to (undef ~~ undef & undef ~~ undef)

[22:16] <moritz_> which again yields (True & True)

[22:16] <masak> moritz_: well, two && in the second case

[22:17] <moritz_> masak: only in boolean context

[22:17] <masak> ah, yes.

[22:17] <wayland76> Well, I guess I don't understand junctions properly yet :)

[22:17] <masak> wayland76: join the club :)

[22:17] <masak> all tests pass!

[22:17] <masak> \o/

[22:18] *** apeiron left
[22:18] <moritz_> if you understand subcall(junction), all the operators with junctions fall out easily

[22:18] <wayland76> Question: are (1 & (2 ~~ 3) and (1 & 2 ~~ 3) equivalent?

[22:18] <masak> no.

[22:18] <wayland76> moritz_: where do I read about that?

[22:19] <moritz_> wayland76: S03 or S06, I think

[22:19] <wayland76> [That first one was supposed to be (1 & (2 ~~ 3))  ]

[22:19] <wayland76> Ok, I'll have a look :)

[22:19] <moritz_> basically foo(a|b|c) is viewed as foo(a)|foo(b)|foo(c)

[22:20] <moritz_> 1 & (2 ~~ 3) is 1 & True

[22:20] <moritz_> erm, 1 & False

[22:20] <moritz_> sorry

[22:21] <moritz_> and (1 & 2) ~~ 3 is (1 ~~ 3 & 2 ~~ 3), which is (False & False)

[22:21] <moritz_> in boolean context both yield False

[22:22] <wayland76> Ah, guess I do understand junctions, and made invalid precedence assumptions :)

[22:22] <wayland76> sorry :)

[22:24] *** mtrimpe joined
[22:25] <wayland76> (well, maybe "understand junction basics" would be better :) )

[22:29] * jnthn will get rakudo doing subcall(junction) and then we'll likely rip out much of the special case code

[22:29] *** apeiron joined
[22:33] *** apeiron left
[22:39] *** cognominal left
[22:40] <pugs_svn> r24098 | wayland++ | Cleaned up text a little bit, hopefully clarified things.  

[22:40] <wayland76> There we go; now we know my commit bit works :)

[22:41] <wayland76> (unfortunately, I left out the [S07]; sorry :)

[22:48] *** cognominal joined
[22:51] *** cognominal left
[22:55] *** cognominal joined
[22:59] *** adc_penner left
[23:00] <wayland76> Unfortunately I'll probably be dropping out of the perl6 community for a week or so; now that Fedora 10 is out, the time has come to reinstall my desktop :)

[23:00] <masak> :)

[23:00] <wayland76> But I'll catch up when that's done :)

[23:01] <masak> you can IRC from the command line, you know :)

[23:01] <wayland76> There is that; maybe I should do that

[23:01] <wayland76> What client?

[23:01] <masak> Emacs ERC.

[23:01] <wayland76> That would do it; how do I do that? :)

[23:02] <masak> as far as I know, it comes with Emacs

[23:02] <masak> just google for it to learn how to get it running

[23:02] <wayland76> Good point :)

[23:02] <moritz_> wayland76: I use irssi from the command line; very good stuff ;)

[23:02] *** apeiron joined
[23:02] <masak> yes, I hear that's a good one too

[23:06] *** pmurias left
[23:17] *** bacek_ joined
[23:17] *** bacek left
[23:18] *** wayland joined
[23:19] *** wayland left
[23:20] <rakudo_svn> r33278 | masak++ | [rakudo] added is_deeply sub to Test.pm, from the November project

[23:21] *** wayland joined
[23:22] <wayland76> Hmm.  Maybe I have to quit XChat first :)

[23:22] *** wayland76 left
[23:23] *** wayland left
[23:23] *** wayland joined
[23:23] *** bacek__ joined
[23:24] *** iblechbot_ left
[23:26] *** mtrimpe left
[23:27] *** elmex left
[23:27] *** mtrimpe joined
[23:30] *** mbtrimpe joined
[23:30] *** mtrimpe left
[23:30] *** wayland left
[23:31] *** wayland joined
[23:32] *** wayland left
[23:34] *** masak left
[23:45] *** mbtrimpe left
[23:51] *** DemoFreak left
[23:52] *** bacek_ left
[23:56] *** vixey left
