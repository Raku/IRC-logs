[00:00] <pmichaud> and earlier today I couldn't find any examples of .join on a list.

[00:00] <TimToady> pugs: say list('foo').join('')

[00:00] <exp_evalbot> OUTPUT[␤]

[00:00] <pmichaud> (in the synopses)

[00:00] <TimToady> pugs: say list('foo',).join('')

[00:00] <exp_evalbot> OUTPUT[␤]

[00:00] <TimToady> pugs: say ('foo','bar').join('')

[00:00] <Auzon> pmichaud: S29 does define join on in the List section, down a few pages.

[00:00] <exp_evalbot> OUTPUT[foobar␤]

[00:01] <TimToady> definitely something bogus going on there...

[00:01] <Auzon> pugs: say ('foo').join(',');

[00:01] <exp_evalbot> OUTPUT[,␤]

[00:01] <Auzon> pugs: say ('foo',).join(',');

[00:01] <exp_evalbot> OUTPUT[foo␤]

[00:01] <bacek_> pugs: say sort

[00:01] <pmichaud> Auzon:  what line number?

[00:01] <exp_evalbot> OUTPUT[*** No compatible multi variant found: "&sort"␤    at /tmp/jEeIhA8Dm9 line 1, column 5 - line 2, column 1␤]

[00:02] <Auzon> pmichaud: Not sure, since I don't know where S29 actually lives as a POD

[00:02] <pmichaud> the only 'join' I could find as a method is

[00:02] <pmichaud>  our Str multi method join ( $separator: @values )

[00:02] <bacek_> pmichaud: 'sort' shouldnt work without arguments :)

[00:02] <pmichaud> and if $separator is the invocant, I'm pretty sure it's not a List.

[00:02] <Auzon> pmichaud: That's in the List section. So you're right. :)

[00:03] <Auzon> Err, rather, that's the one I was referring to

[00:03] <Auzon> But I didn't look at the type.

[00:03] <pmichaud> I didn't look at the section.  :-)

[00:03] <TimToady> pugs: class Object is also { method join ($x) { (self,).join($x) } }; say 'foo'.join(',')

[00:03] <exp_evalbot> OUTPUT[*** ␤    Circular class inheritance detected for class 'Object'␤    at /tmp/o3eBxcnZxM line 1, column 23␤]

[00:03] <TimToady> pugs: class Object is also { method join ($x) { [self].join($x) } }; say 'foo'.join(',')

[00:03] <exp_evalbot> OUTPUT[*** ␤    Circular class inheritance detected for class 'Object'␤    at /tmp/aOYFbjBNRc line 1, column 23␤]

[00:04] <TimToady> pugs: class Any is also { method join ($x) { [self].join($x) } }; say 'foo'.join(',')

[00:04] <TimToady> yipee!!

[00:05] <Auzon> Where is S29.pod live as a POD? I don't see it in the Pugs repo or the other syn one I checked out

[00:05] <pmichaud> it's not S29.pod

[00:05] <pmichaud> docs/Perl6/Spec/Functions.pod in the pugs repo

[00:05] <TimToady> it's Functions.pd

[00:05] <TimToady> *pod

[00:05] <Auzon> Alright.

[00:06] <TimToady> pugs: say 42

[00:06] <pmichaud> TimToady: I think you infinite looped pugs.

[00:06] <Auzon> sheesh, you broke it

[00:06] <TimToady> maybe I took NL off the power grid by redefining Any...

[00:07] <pmichaud> I think that [self].join($x)  might look self-referential.

[00:07] <pmichaud> er, recursive, even.

[00:07] <TimToady> should just end up calling Array.join

[00:07] <Auzon> pugs: say 42

[00:07] <TimToady> I think I took down the power grid...

[00:08] <Auzon> I'm logged into the server, so nothing too bad happened... ;)

[00:08] <TimToady> probably running on an emergency generator :)

[00:09] <Auzon> evalbot hung, I think.

[00:09] *** exp_evalbot left
[00:10] *** exp_evalbot joined
[00:10] <Auzon> pugs: say 42;

[00:10] <exp_evalbot> OUTPUT[42␤]

[00:10] *** Southen_ left
[00:11] <Auzon> Well, it appears to be working again.

[00:12] *** snooper left
[00:12] *** sscaffidi joined
[00:18] <TimToady> why would tormenting pugs hang the evalbot?

[00:27] <rakudo_svn> r28079 | pmichaud++ | [rakudo]:

[00:27] <rakudo_svn> r28079 | pmichaud++ | * Further "fix" to List class to get spectest_regression passing again.

[00:27] <rakudo_svn> r28079 | pmichaud++ |   The real fix will have to wait for improvements to Parrot's MMD.

[00:30] *** cmarcelo left
[00:36] *** alester left
[00:45] *** felipe left
[00:48] *** nipotan is now known as nipotaway

[00:49] *** Limbic_Region joined
[01:12] *** wknight8111 left
[01:13] *** wknight8111 joined
[01:14] <stevan_> TimToady: re: parameterized roles

[01:14] <stevan_> we have faked them a little before

[01:15] <stevan_> MooseX::Storage does it with the Storage function which takes some args and returns a list of roles

[01:15] <stevan_> so you can do 

[01:15] <stevan_> with Storage(io => 'AtomicFile', format => 'JSON');

[01:15] <stevan_> that uses the MooseX::Storage::Format::JSON and MooseX::Storage::IO::AtomicFile, etcetc

[01:16] <stevan_> there is no hooks available yet for the role application process though, so its limited in what it can do

[01:17] <stevan_> people have asked for hooks, but no one has a real use case yet so I am currently punting

[01:17] <stevan_> so if you have a more specific use case then i am all ears :)

[01:18] <stevan_> I think really I need to define the limits of parameterized roles then I can work out how it could be implemented

[01:18] <stevan_> full generics would be ... tricky

[01:19] <stevan_> but something close to that could be doable I think

[01:23] *** mj41__ joined
[01:23] *** mj41__ is now known as mj41

[01:29] *** Alias_ joined
[01:35] *** felipe joined
[01:40] *** mj41_ left
[01:41] *** alanhaggai joined
[01:41] *** pen1 left
[01:42] *** penk joined
[01:47] *** bnjmn- left
[01:57] *** lichtkind left
[01:58] <Auzon> pugs: say join(':', 'foo'); # yes, this again.

[01:58] <exp_evalbot> OUTPUT[foo␤]

[02:01] <Auzon> pugs: say join(':', 'foo',); # yes, this again.

[02:01] <exp_evalbot> OUTPUT[foo␤]

[02:02] *** lichtkind joined
[02:02] <lichtkind> $hashref = % 1..3 Z 'a'..'c';

[02:02] <lichtkind> pugs: $hashref = % 1..3 Z 'a'..'c';

[02:02] <exp_evalbot> OUTPUT[*** ␤    Unexpected " ="␤    expecting "::"␤    Variable "$hashref" requires predeclaration or explicit package name␤    at /tmp/xagIRxhmYu line 1, column 9␤]

[02:03] <lichtkind> pugs: $hashref = % (1..3) Z ( 'a'..'c');

[02:03] <exp_evalbot> OUTPUT[*** ␤    Unexpected " ="␤    expecting "::"␤    Variable "$hashref" requires predeclaration or explicit package name␤    at /tmp/IRVquNCEt5 line 1, column 9␤]

[02:03] <lichtkind> pugs: my $hashref = % (1..3) Z ( 'a'..'c');

[02:03] <exp_evalbot> OUTPUT[*** ␤    Unexpected "$hashref"␤    expecting "=", "::", context, ":" or "("␤    at /tmp/oAHk0hCQm9 line 1, column 4␤]

[02:03] <lichtkind> pugs: my $hashref = %( (1..3) Z ( 'a'..'c') );

[02:03] <Auzon> I don't think that was ever implemented.

[02:03] <exp_evalbot> RESULT[{("1" => "a"), ("2" => "b"), ("3" => "c")}]

[02:04] <Auzon> and it proves me wrong. :-/

[02:04] <lichtkind> :)

[02:04] <lichtkind> goo night

[02:04] <lichtkind> pugs: my $hashref = %( 1..3  Z  'a'..'c' );

[02:04] <exp_evalbot> RESULT[{("1" => "a"), ("2" => "b"), ("3" => "c")}]

[02:06] <lichtkind> Auzon: i mean i really go sleep now :)

[02:06] *** lichtkind left
[02:10] *** wknight8111 left
[02:10] *** stevan_ left
[02:10] *** Auzon left
[02:10] *** agentzh left
[02:10] *** wolverian left
[02:10] *** thepler left
[02:10] *** xdg left
[02:10] *** pugs_svnbot left
[02:10] *** audreyt left
[02:10] *** buu left
[02:10] *** lambdabot left
[02:10] *** hcchien left
[02:10] *** Eevee left
[02:10] *** SamB left
[02:10] *** cookys left
[02:10] *** charsbar_ left
[02:11] *** penk left
[02:11] *** alanhaggai left
[02:11] *** mj41 left
[02:11] *** sscaffidi left
[02:11] *** exp_evalbot left
[02:11] *** bacek left
[02:11] *** nekobaka left
[02:11] *** vixey left
[02:11] *** ting_ left
[02:11] *** rakudo_svn left
[02:11] *** cognominal_ left
[02:11] *** bacek_ left
[02:11] *** rhr left
[02:11] *** c1sung left
[02:11] *** fullermd left
[02:11] *** silug left
[02:11] *** allbery_b left
[02:11] *** Caelum left
[02:11] *** arguile left
[02:11] *** kane_ left
[02:11] *** erikh left
[02:11] *** osfameron left
[02:11] *** Maddingue left
[02:11] *** [particle]1 left
[02:11] *** ruoso left
[02:11] *** justatheory left
[02:11] *** japhb left
[02:11] *** acmoore left
[02:11] *** Jedai left
[02:11] *** kst left
[02:11] *** rafl left
[02:11] *** IllvilJa left
[02:11] *** xinming left
[02:11] *** tcliou_ left
[02:11] *** r0bby left
[02:11] *** avar left
[02:11] *** jiing left
[02:11] *** gbacon left
[02:11] *** mtve left
[02:11] *** Tene left
[02:11] *** cj left
[02:11] *** buubot left
[02:11] *** araujo left
[02:11] *** cosimo left
[02:11] *** moritz_ left
[02:11] *** TreyHarris left
[02:11] *** speckbot left
[02:11] *** integral left
[02:11] *** obra left
[02:11] *** jrockway left
[02:11] *** nipotaway left
[02:11] *** clkao left
[02:11] *** IRSeekBot left
[02:11] *** LCamel left
[02:11] *** SubStack left
[02:11] *** Alias_ left
[02:11] *** sri_work left
[02:11] *** kaether left
[02:11] *** orafu left
[02:11] *** ilbot2 left
[02:11] *** pasteling left
[02:11] *** pmichaud left
[02:11] *** shachaf left
[02:11] *** yves left
[02:11] *** spinclad left
[02:11] *** awwaiid left
[02:11] *** joejaxx left
[02:11] *** simcop2387 left
[02:11] *** yahooooo left
[02:11] *** cls_bsd left
[02:11] *** dalek left
[02:11] *** zev left
[02:11] *** viklund left
[02:11] *** Khisanth left
[02:11] *** nothingmuch left
[02:11] *** ingy left
[02:11] *** zostay left
[02:11] *** Limbic_Region left
[02:11] *** crats left
[02:11] *** broquaint left
[02:11] *** kolibrie left
[02:11] *** mofino left
[02:11] *** qmole left
[02:11] *** meteorjay left
[02:11] *** gugod left
[02:11] *** PerlJam left
[02:11] *** bbkr_ left
[02:11] *** diakopter left
[02:11] *** TimToady left
[02:11] *** perlbot left
[02:11] *** felipe left
[02:11] *** Patterner left
[02:11] *** BinGOs left
[02:11] *** yath left
[02:11] *** drbean left
[02:11] *** lisppaste3 left
[02:11] *** nnunley left
[02:11] *** Juerd left
[02:11] *** jjore left
[02:11] *** Gothmog_ left
[02:11] *** Grrrr left
[02:11] *** dmq left
[02:12] *** TimToady joined
[02:12] *** penk joined
[02:12] *** alanhaggai joined
[02:12] *** felipe joined
[02:12] *** Alias_ joined
[02:12] *** mj41 joined
[02:12] *** wknight8111 joined
[02:12] *** Limbic_Region joined
[02:12] *** sscaffidi joined
[02:12] *** exp_evalbot joined
[02:12] *** bacek_ joined
[02:12] *** IllvilJa joined
[02:12] *** simcop2387 joined
[02:12] *** sri_work joined
[02:12] *** xinming joined
[02:12] *** rhr joined
[02:12] *** tcliou_ joined
[02:12] *** [particle]1 joined
[02:12] *** kaether joined
[02:12] *** ruoso joined
[02:12] *** crats joined
[02:12] *** araujo joined
[02:12] *** lambdabot joined
[02:12] *** Patterner joined
[02:12] *** orafu joined
[02:12] *** r0bby joined
[02:12] *** broquaint joined
[02:12] *** acmoore joined
[02:12] *** bacek joined
[02:12] *** justatheory joined
[02:12] *** hcchien joined
[02:12] *** BinGOs joined
[02:12] *** kolibrie joined
[02:12] *** stevan_ joined
[02:12] *** erikh joined
[02:12] *** yath joined
[02:12] *** nekobaka joined
[02:12] *** c1sung joined
[02:12] *** drbean joined
[02:12] *** japhb joined
[02:12] *** Jedai joined
[02:12] *** vixey joined
[02:12] *** fullermd joined
[02:12] *** kst joined
[02:12] *** lisppaste3 joined
[02:12] *** Auzon joined
[02:12] *** mofino joined
[02:12] *** irc.freenode.net sets mode: +o TimToady

[02:12] *** avar joined
[02:12] *** jiing joined
[02:12] *** yahooooo joined
[02:12] *** cosimo joined
[02:12] *** ting_ joined
[02:12] *** rakudo_svn joined
[02:12] *** agentzh joined
[02:12] *** wolverian joined
[02:12] *** cognominal_ joined
[02:12] *** moritz_ joined
[02:12] *** ilbot2 joined
[02:12] *** nnunley joined
[02:12] *** qmole joined
[02:12] *** silug joined
[02:12] *** SamB joined
[02:12] *** Eevee joined
[02:12] *** cookys joined
[02:12] *** charsbar_ joined
[02:12] *** meteorjay joined
[02:12] *** allbery_b joined
[02:12] *** pasteling joined
[02:12] *** thepler joined
[02:12] *** audreyt joined
[02:12] *** pugs_svnbot joined
[02:12] *** xdg joined
[02:12] *** buu joined
[02:12] *** TreyHarris joined
[02:12] *** gugod joined
[02:12] *** gbacon joined
[02:12] *** pmichaud joined
[02:12] *** cls_bsd joined
[02:12] *** Caelum joined
[02:12] *** shachaf joined
[02:12] *** dalek joined
[02:12] *** osfameron joined
[02:12] *** clkao joined
[02:12] *** Juerd joined
[02:12] *** PerlJam joined
[02:12] *** jjore joined
[02:12] *** yves joined
[02:12] *** dmq joined
[02:12] *** Gothmog_ joined
[02:12] *** Grrrr joined
[02:12] *** nothingmuch joined
[02:12] *** jrockway joined
[02:12] *** arguile joined
[02:12] *** Maddingue joined
[02:12] *** kane_ joined
[02:12] *** Khisanth joined
[02:12] *** awwaiid joined
[02:12] *** LCamel joined
[02:12] *** viklund joined
[02:12] *** IRSeekBot joined
[02:12] *** integral joined
[02:12] *** bbkr_ joined
[02:12] *** rafl joined
[02:12] *** nipotaway joined
[02:12] *** Tene joined
[02:12] *** ingy joined
[02:12] *** zostay joined
[02:12] *** diakopter joined
[02:12] *** speckbot joined
[02:12] *** joejaxx joined
[02:12] *** buubot joined
[02:12] *** perlbot joined
[02:12] *** zev joined
[02:12] *** spinclad joined
[02:12] *** mtve joined
[02:12] *** SubStack joined
[02:12] *** cj joined
[02:12] *** obra joined
[02:13] *** araujo left
[02:19] <pugs_svnbot> r20660 | Auzon++ | [gsoc_spectest] Changed tests for "foo".join() to make more sense. Also tested the default separator. (added 2 tests, changed 1)

[02:22] *** lichtkind joined
[02:24] <lichtkind> pugs: %buch = %( 1..3 Z 'a'..'c' );

[02:24] <exp_evalbot> OUTPUT[*** ␤    Unexpected " ="␤    expecting "::"␤    Variable "%buch" requires predeclaration or explicit package name␤    at /tmp/bPml1xsyMj line 1, column 6␤]

[02:25] *** Limbic_Region left
[02:27] <pmichaud> Auzon: so, are the tests following what S29 says, or do we need to update S29 to match the tests, or ... ?

[02:29] <Auzon> The best thing would be to clarify the behavior of "foo".join, as well as the type given in the code example

[02:30] <Auzon> TimToady++ agreed that "foo".join(':') shouldn't be any different from join(':', "foo"), and ("foo").join(':') shouldn't be different than ("foo",).join(':')

[02:30] <pmichaud> what about   'foo'.join(@array)  ?

[02:31] <TimToady> probably fails from too many arguments

[02:31] <pmichaud> okay.  So S29 is probably wrong there.

[02:32] <pmichaud> our Str multi method join ( $separator: @values )    should be    our Str multi method join ( @values : $separator = ' ' )

[02:33] <pmichaud> are we still doing the "liberal edit" policy to S29?

[02:33] <TimToady> yes

[02:33] <pmichaud> does anyone review the edits?  more to the point, is there a way to get svn diffs via email the way that parrot's svn does?

[02:35] <TimToady> what is this "email" thing of which you speak? :)

[02:35] <pmichaud> it's a very handy mechanism for reviewing svn diffs.  Almost as good as Atom or RSS feeds :-)

[02:36] <pmichaud> Okay, I'll start taking liberties with S29 then :-)

[02:37] <Auzon> perl6: "foo".map({$_ ~ $_})

[02:37] <exp_evalbot> kp6 r20660: OUTPUT[no method 'map' in Class 'Str'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤        KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x8e4d93c)', 'map', 'HASH(0x8e51f4c)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤    

[02:37] <exp_evalbot> ..main::DISPATCH('HASH(0x8e4d93c)', 'map', 'HASH(0x8e51f4c)') called at ...

[02:37] <exp_evalbot> ..pugs: RESULT[("foofoo",)]

[02:37] <exp_evalbot> ..rakudo r28079: OUTPUT[Method 'map' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 45 (EVAL_11:22)␤

[02:37] <exp_evalbot> ..elf r20660: OUTPUT[Use of uninitialized value in concatenation (.) or string at (eval 14) line 3.␤Use of uninitialized value in concatenation (.) or string at (eval 14) line 3.␤Can't locate object method "map" via package "foo" (perhaps you forgot to load "foo"?) at (eval 14) line 3.␤ at

[02:37] <exp_evalbot> .../elf_f_faster line 4492␤]

[02:38] <TimToady> perl6: "foo".map: {$_ ~ $_}

[02:38] <exp_evalbot> kp6 r20660: OUTPUT[no method 'map' in Class 'Str'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤        KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x8e4d93c)', 'map', 'HASH(0x8e51f4c)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤    

[02:38] <exp_evalbot> ..main::DISPATCH('HASH(0x8e4d93c)', 'map', 'HASH(0x8e51f4c)') called at ...

[02:38] <exp_evalbot> ..pugs: RESULT[("foofoo",)]

[02:38] <exp_evalbot> ..rakudo r28079: OUTPUT[Method 'map' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 45 (EVAL_12:22)␤

[02:38] <exp_evalbot> ..elf r20660: OUTPUT[Can't locate object method "map" via package "foo" (perhaps you forgot to load "foo"?) at (eval 14) line 3.␤ at ./elf_f_faster line 4492␤]

[02:38] <pmichaud> so, we're doing map/join/grep/etc.  on non-list values?

[02:39] <TimToady> some of them seem to coerce to list/array, and some don't

[02:39] <pmichaud> which do, which don't?  ;-)

[02:39] <TimToady> what I was saying earlier is that we should be more consistent

[02:39] <TimToady> and make Object do the "default" coercion

[02:39] <pmichaud> I'd agree with that.  Feels slippery-slope-ish though.

[02:39] <TimToady> much like default + coerces

[02:40] <pmichaud> for example,   'foo'.sort   ?

[02:40] <TimToady> as long as the defaults are out in Object or Any or some such, any subclass can override

[02:42] <TimToady> so just as the default is infix:<+> (Any $x, Any $y) { Num($x) + Num($y) } or some such

[02:42] <Auzon> Can we easily coerce from a Str or Num to a List?

[02:42] <TimToady> likewise method join etc in Object can just coerce to list/array or whatever, depending on what people will expect

[02:43] <TimToady> @("foo")

[02:43] <lambdabot> Unknown command, try @list

[02:43] <pmichaud> okay.  it sounds a little like "arbitrary list", though.

[02:43] <pmichaud> i.e., join coerces, but some other method might not

[02:45] <TimToady> it really depends on whether the language as a whole is "claiming" the name for a consistent meaning

[02:45] <TimToady> just as it has claimed + for numeric additoin

[02:45] <TimToady> join should combine pieces, and any individual piece should consider itself a degenerate case

[02:46] <TimToady> sorting one element is not very interesting either :)

[02:46] <pmichaud> how about .kv, .keys, .values, .pairs?

[02:48] <TimToady> $x means 0 => $x as a key/value pair, maybe

[02:48] <Auzon> or $x => 1?

[02:48] <Auzon> or $x => undef

[02:48] <TimToady> assuming $x-as-a-list means [$x] or some such

[02:49] <TimToady> Auzon: your view would be more useful for hash coercions, where sets are considered keys of hashes

[02:50] <Auzon> hm, but if we do that, then odd-element lists to a hash would be legal. Right?

[02:51] <TimToady> only if we automatically coerce each element in the list, which I don't think we are

[02:52] <Auzon> perl6: hash($x)

[02:52] <rakudo_svn> r28082 | pmichaud++ | [rakudo]:

[02:52] <rakudo_svn> r28082 | pmichaud++ | * In List.pir. change C<iter = new 'Iterator', self> to

[02:52] <rakudo_svn> r28082 | pmichaud++ |   C<iter = self.'iterator'()>

[02:52] <rakudo_svn> r28082 | pmichaud++ | * bacek++

[02:52] <exp_evalbot> kp6 r20660: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824bd4c)', 'APPLY', 'HASH(0x8e520ac)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤  

[02:52] <exp_evalbot> ..main::DISPATCH('HASH(0x824bd4c)', 'APPLY', 'HASH(0x8e520ac)') ca...

[02:52] <exp_evalbot> ..pugs: OUTPUT[*** ␤    Unexpected ")"␤    expecting "::"␤    Variable "$x" requires predeclaration or explicit package name␤    at /tmp/BX08TQpM3u line 1, column 8␤]

[02:52] <exp_evalbot> ..rakudo r28081: OUTPUT[Scope  not found for PAST::Var '$x'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[02:52] <exp_evalbot> ..elf r20660: OUTPUT[Global symbol "$x" requires explicit package name at (eval 14) line 3.␤ at ./elf_f_faster line 4492␤]

[02:52] <Auzon> oops. That wasn't useful at all.

[02:52] <Auzon> perl6: my $x = 1; say hash($x).perl;

[02:52] <exp_evalbot> kp6 r20660: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824be5c)', 'APPLY', 'HASH(0x8e4ee20)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤  

[02:52] <exp_evalbot> ..main::DISPATCH('HASH(0x824be5c)', 'APPLY', 'HASH(0x8e4ee20)') ca...

[02:52] <exp_evalbot> ..pugs: OUTPUT[*** Odd number of elements found where hash expected: VList [VInt 1]␤    at /tmp/I2UehCfPlC line 1, column 16-29␤]

[02:52] <exp_evalbot> ..rakudo r28081: OUTPUT[{"1" => {}}␤]

[02:52] <exp_evalbot> ..elf r20660: OUTPUT[Undefined subroutine &GLOBAL::hash called at (eval 14) line 4.␤ at ./elf_f_faster line 4492␤]

[02:53] <pmichaud> hrm, what happened with rakudo there?

[02:54] <Auzon> :-/ It's hard to tell where to say that "this is a one element list" and "this is a scalar"

[02:54] <Auzon> e.g. $x versus ($x) versus ($x,)

[02:55] <TimToady> only the last is a list by nature

[02:55] <pmichaud> $x and ($x) are the same.

[02:56] <Auzon> It also seems like the function calls are more forgiving of this distinction than the OO versus

[02:56] <Auzon> s:last/versus/version/

[02:58] *** Maghnus joined
[02:59] *** sri_work left
[03:18] *** ting joined
[03:19] *** eternaleye joined
[03:34] *** araujo joined
[03:43] *** lichtkind left
[03:46] *** ting_ left
[04:07] *** sscaffidi left
[04:35] <Khisanth> it's been said that everything in Perl was stolen from some other language, so where did it steal contexts from? :)

[04:35] <araujo> Haskell

[04:35] * araujo hides

[04:36] <Khisanth> I would imagine Perl would be a lot different if it had been stealing stuff from Haskell for that long :)

[04:48] <Auzon> pugs: my $foo = <abc>; say $foo.WHAT

[04:48] <exp_evalbot> OUTPUT[Str␤]

[04:48] <Auzon> pugs: my $foo = <abc def>; say $foo.WHAT

[04:48] <exp_evalbot> OUTPUT[Array␤]

[04:49] <Auzon> I was afraid of that

[04:52] <Auzon> pugs: my @foo = <abc>; my @bar = <abc def>; say @foo.WHAT; say @bar.WHAT;

[04:52] <exp_evalbot> OUTPUT[Array␤Array␤]

[05:14] *** wknight8111 left
[05:27] *** drbean left
[05:29] *** hcchien left
[05:40] *** alanhaggai left
[05:44] *** drbean joined
[05:45] *** alanhaggai joined
[05:46] *** alc joined
[05:55] *** hcchien joined
[05:59] *** alanhaggai left
[05:59] *** alanhaggai joined
[06:09] *** meppl joined
[06:14] *** alanhaggai_ joined
[06:28] *** alanhaggai left
[06:32] *** alanhaggai_ left
[06:40] *** justatheory left
[06:49] *** alanhaggai joined
[07:10] *** elmex joined
[07:16] *** ruoso left
[07:18] *** jan_ joined
[07:32] *** sri_work joined
[07:47] *** masak joined
[07:47] *** Alias_ left
[07:52] *** Ched- joined
[07:57] *** iblechbot joined
[08:04] *** alanhaggai left
[08:06] *** IngoLover joined
[08:09] *** cosimo left
[08:12] *** meppl left
[08:14] *** IngoLover left
[08:15] *** IngoLieber joined
[08:17] *** IngoLieber left
[08:17] *** IngoLieber joined
[08:19] *** IngoLiebe joined
[08:19] *** IngoLiebe left
[08:20] *** Benni` joined
[08:20] *** IngoLieber left
[08:20] *** IngoLieber joined
[08:21] *** Benni` left
[08:22] *** cosimo joined
[08:23] *** IngoLieber left
[08:25] *** bacek_ left
[08:25] *** clli joined
[08:25] *** clli left
[08:29] *** ruoso joined
[08:33] *** Minthe joined
[08:36] <Minthe> How do you do?

[08:37] <Minthe> Excuse me, but do you mind if I ask a question about Pugs?

[08:38] <moritz_> we don't mind, unless it's about building current pugs

[08:38] <moritz_> which is known not to work

[08:38] <Minthe> Oh

[08:38] <Minthe> Ah...

[08:38] <moritz_> pugs: say $?PUGS_VERSION

[08:38] <exp_evalbot> OUTPUT[Perl6 User's Golfing System, version 6.2.13, October 17, 2006 (r18093)␤]

[08:39] <masak> actually, we don't _mind_ those questions either :)

[08:39] <Minthe> So until today I was searching how to fix Invalid grammatical category: "Bool"

[08:39] <masak> yes

[08:39] <masak> best is to revert to a known working version, I think

[08:39] <moritz_> that's about the last version that's known to build with ghc 6.6.1

[08:39] <Minthe> Today I found this site: http://www.nntp.perl.org/group/perl.perl6.compiler/2008/06/msg1876.html

[08:39] <lambdabot> Title: building pugs under Fedora 9 doesn't work - nntp.perl.org, http://tinyurl.com/5oj5mp

[08:39] <Minthe> I'm using Debian ghc 6.8.2-5

[08:40] <Minthe> But I think the issue is the same...

[08:40] <moritz_> yes

[08:40] <Minthe> So could you tell me what is the latest working revision?

[08:40] <moritz_> around r18093, with ghc 6.6.1

[08:40] <moritz_> http://moritz.faui2k3.org/debian/pugs/ # debian packages

[08:40] <lambdabot> Title: Index of /debian/pugs

[08:41] <moritz_> not very good, but they work for me

[08:41] <ruoso> pmichaud, for 'foo'.join(';') to work, join must be: our Str multi sub join ($string, @elements) is export {...}

[08:41] <ruoso> because join won't be found in Str, then it will fallback to sub-dispatch

[08:41] <Minthe> I successfully compiled cpan stable, but it is too old.

[08:41] *** pmurias joined
[08:43] <ruoso> pmichaud, I don't think Str will ever be the invocant of "join", unless of course we add the method 'join' on Str instead of Array

[08:44] <ruoso> which might make sense, but it probably doesn't... falling back to sub-dispatch solves the problem just fine...

[08:45] <Minthe> Excuse me, but why http://moritz.faui2k3.org/debian/pugs/r19915/ is 6.2.12? CPAN stable version shows 6.2.13...

[08:45] <lambdabot> Title: Index of /debian/pugs/r19915

[08:45] <moritz_> Minthe: probably because I used the wrong version string

[08:46] <moritz_> Minthe: it was one of the first debian packages I built, and I'm not very good at it ;)

[08:46] <Minthe> So if I install pugs_6.2.12-2_i386.deb, pugs -v will show 6.2.13?

[08:48] <moritz_> I think it does for me, yes

[08:48] <ruoso> now an interesting question... if some method is multi, is it possible to have 'sub' alternatives?

[08:48] <Minthe> Moritz: Thank you. Then I'll install it...

[08:50] <ruoso> perl6: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Foo $c, Int $a) { say '2'}}; Foo.new.bar('a'); Foo.new.bar(1);

[08:50] <pugs_svnbot> r20661 | moritz++ | bumped version in debian/changelog, Minthe++ for reporting

[08:50] <exp_evalbot> kp6 r20660: OUTPUT[no method 'add_variant' in Class ''␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤   KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x8e549e8)', 'add_variant', 'HASH(0x8e57508)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line

[08:50] <exp_evalbot> ..169␤     main::DISPATCH('HASH(0x8e549e8)', 'add_variant', 'HASH(0x...

[08:50] <exp_evalbot> ..pugs: OUTPUT[2␤2␤]

[08:50] <exp_evalbot> ..rakudo r28084: OUTPUT[Could not find non-existent sub our␤current instr.: 'parrot;Foo;_block22' pc 125 (EVAL_12:53)␤

[08:50] <exp_evalbot> ..elf r20660: OUTPUT[1␤2␤]

[08:51] <ruoso> wow... elf gets it right :)

[08:51] <moritz_> and rakudo parses 'our' as a sub - ouch

[08:53] *** bacek left
[08:54] <ruoso> elf: class Foo { our method method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new; $b.bar('a'); 'a'.bar($b);

[08:54] <exp_evalbot> OUTPUT[syntax error at (eval 14) line 5, near "(sub bar"␤syntax error at (eval 14) line 6, near "))"␤syntax error at (eval 14) line 9, near "})␤"␤ at ./elf_f_faster line 4492␤]

[08:54] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new; $b.bar('a'); 'a'.bar($b);

[08:54] <exp_evalbot> OUTPUT[Can't locate object method "bar" via package "a" (perhaps you forgot to load "a"?) at (eval 14) line 13.␤ at ./elf_f_faster line 4492␤1␤]

[08:54] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new; $b.bar('a'); "a".bar($b);

[08:54] <exp_evalbot> OUTPUT[Can't locate object method "bar" via package "a" (perhaps you forgot to load "a"?) at (eval 14) line 13.␤ at ./elf_f_faster line 4492␤1␤]

[08:54] <ruoso> uh?

[08:55] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new; my $c = 'a'; $b.bar($c); $c.bar($b);

[08:55] <exp_evalbot> OUTPUT[Can't locate object method "bar" via package "a" (perhaps you forgot to load "a"?) at (eval 14) line 14.␤ at ./elf_f_faster line 4492␤1␤]

[08:55] <moritz_> it tires to treat 'a' as a package?

[08:55] <moritz_> *tries

[08:55] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new; my $c = Str.new("abc"); $b.bar($c); $c.bar($b);

[08:55] <exp_evalbot> OUTPUT[Odd number of elements in anonymous hash at ./elf_f_faster line 19.␤No viable candidate for call to multimethod bar(Foo,Str) at (eval 14) line 13␤ at ./elf_f_faster line 4492␤]

[08:55] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar is export (Str $a, Foo $b) { say '2'}}; my $b = Foo.new; my $c = Str.new("abc"); $b.bar($c); $c.bar($b);

[08:55] <exp_evalbot> OUTPUT[Parse error in: /tmp/EsU7LFUFXo␤panic at line 1 column 55 (pos 55): Missing right brace␤WHERE: hod bar (Str $a) { say '1' }; our multi sub bar is export (S␤WHERE:                              /\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:255:in `_block_rest'␤ 

[08:55] <exp_evalbot> ..STD_red/std.rb:242:in `block in block'␤  STD_red/prelude.rb:51...

[08:56] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new; my $c = Str.new("abc"); $b.bar($c); $c.bar($b);

[08:56] <exp_evalbot> OUTPUT[Odd number of elements in anonymous hash at ./elf_f_faster line 19.␤No viable candidate for call to multimethod bar(Foo,Str) at (eval 14) line 13␤ at ./elf_f_faster line 4492␤]

[08:56] <ruoso> uh?

[08:56] <ruoso> pugs: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new; my $c = Str.new("abc"); $b.bar($c); $c.bar($b);

[08:56] <exp_evalbot> OUTPUT[*** Must only use named arguments to new() constructor␤    Be sure to use bareword keys.␤    at /tmp/PEEdbMZrbA line 1, column 134-153␤]

[08:57] <ruoso> pugs: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new(); my $c = Str.new("abc"); $b.bar($c); $c.bar($b);

[08:57] <exp_evalbot> OUTPUT[*** Must only use named arguments to new() constructor␤    Be sure to use bareword keys.␤    at /tmp/ShVoZIJNGy line 1, column 136-155␤]

[08:57] <ruoso> pugs: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new(); my $c = "abc"; $b.bar($c); $c.bar($b);

[08:57] <exp_evalbot> OUTPUT[2␤*** No such method in class Str: "&bar"␤    at /tmp/YZf6UrWncX line 1, column 160-170␤]

[08:57] <Minthe> Ah..

[08:57] <ruoso> pugs: class Foo { our multi method bar (Str $a) { say '1' }; };our multi sub bar (Str $a, Foo $b) is export { say '2'}; my $b = Foo.new(); my $c = "abc"; $b.bar($c); $c.bar($b);

[08:57] <exp_evalbot> OUTPUT[1␤2␤]

[08:57] <ruoso> pugs doesn't implement the 'is export' correctly.. but it does the dispatching...

[08:58] <moritz_> you could try it with multi method *bar

[08:58] <pugs_svnbot> r20662 | moritz++ | util/perl6.vim: add subset type declarator

[08:58] <moritz_> or something like that

[08:59] <ruoso> pugs: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub *bar (Str $a, Foo $b) { say '2'}}; my $b = Foo.new; my $c = "abc"; $b.bar($c); $c.bar($b);

[08:59] <exp_evalbot> OUTPUT[1␤2␤]

[08:59] <ruoso> coo

[08:59] <ruoso> l

[08:59] <Minthe> Excuse me, but I have an issue.

[08:59] <Minthe> I have perl 5.10, not 5.8

[09:00] <moritz_> debian testing or unstable ;)

[09:00] <Minthe> So moritz version cannot be used...

[09:00] <Minthe> But I can use self-compiled cpan stable...

[09:00] <moritz_> Minthe: then your best bet is to install ghc 6.6.1, check out an older version of pugs, and compile it

[09:01] <Minthe> maybe r19915...

[09:01] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub *bar (Str $a, Foo $b) { say '2'}}; my $b = Foo.new; my $c = "abc"; $b.bar($c); $c.bar($b);

[09:01] <exp_evalbot> OUTPUT[Parse error in: /tmp/pkpp4bDUVE␤panic at line 1 column 55 (pos 55): Missing right brace␤WHERE: hod bar (Str $a) { say '1' }; our multi sub *bar (Str $a, Fo␤WHERE:                              /\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:255:in `_block_rest'␤ 

[09:01] <exp_evalbot> ..STD_red/std.rb:242:in `block in block'␤  STD_red/prelude.rb:51...

[09:01] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new; my $c = "abc"; $b.bar($c); $c.bar($b);

[09:01] <exp_evalbot> OUTPUT[Can't locate object method "bar" via package "abc" (perhaps you forgot to load "abc"?) at (eval 14) line 14.␤ at ./elf_f_faster line 4492␤1␤]

[09:01] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new; my $c = Str.new(); $b.bar($c); $c.bar($b);

[09:01] <exp_evalbot> OUTPUT[No viable candidate for call to multimethod bar(Foo,Str) at (eval 14) line 13␤ at ./elf_f_faster line 4492␤]

[09:02] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; our multi sub bar (Str $a, Foo $b) is export { say '2'}}; my $b = Foo.new; my $c = Str.new(); $c.bar($b);

[09:02] <exp_evalbot> OUTPUT[Can't locate object method "bar" via package "Str" at (eval 14) line 13.␤ at ./elf_f_faster line 4492␤]

[09:02] <ruoso> elf: class Foo { our multi method bar (Str $a) { say '1' }; }; our multi sub bar (Str $a, Foo $b)  { say '2'}; my $b = Foo.new; my $c = Str.new(); $c.bar($b);

[09:02] <exp_evalbot> OUTPUT[Can't locate object method "bar" via package "Str" at (eval 14) line 13.␤ at ./elf_f_faster line 4492␤]

[09:03] *** Jedai left
[09:05] <ruoso> elf: class Foo {  }; our multi sub bar (Str $a, Foo $b)  { say '2'}; my $b = Foo.new; my $c = Str.new(); $c.bar($b);

[09:05] <exp_evalbot> OUTPUT[Can't locate object method "bar" via package "Str" at (eval 14) line 12.␤ at ./elf_f_faster line 4492␤]

[09:06] <ruoso> elf: class Foo {  }; our multi sub bar (Int $a, Foo $b)  { say '2'}; my $b = Foo.new; my $c = 1; $c.bar($b);

[09:06] <exp_evalbot> OUTPUT[Can't call method "bar" without a package or object reference at (eval 14) line 12.␤ at ./elf_f_faster line 4492␤]

[09:06] <ruoso> ok... I don't see why the first one was working...

[09:08] <ruoso> elf: class Foo {  }; class Bar { }; our multi sub baz (Bar $a, Foo $b)  { say '2'}; my $b = Foo.new; my $c = Bar.new; $c.bar($b);

[09:08] <exp_evalbot> OUTPUT[Can't locate object method "bar" via package "Bar" at (eval 14) line 17.␤ at ./elf_f_faster line 4492␤]

[09:08] <ruoso> elf: class Foo {  }; class Bar { }; our multi sub baz (Bar $a, Foo $b)  { say '2'}; my $b = Foo.new; my $c = Bar.new; $c.baz($b);

[09:08] <exp_evalbot> OUTPUT[Can't locate object method "baz" via package "Bar" at (eval 14) line 17.␤ at ./elf_f_faster line 4492␤]

[09:08] <ruoso> elf: class Foo { our multi sub baz (Bar $a, Foo $b) is export { say '2'}; }; class Bar { };  my $b = Foo.new; my $c = Bar.new; $c.baz($b);

[09:08] <exp_evalbot> OUTPUT[Can't locate object method "baz" via package "Bar" at (eval 14) line 16.␤ at ./elf_f_faster line 4492␤]

[09:09] <ruoso> gah.. forget it

[09:10] <ruoso> so it seems that I can actually have methods and subs with the same name...

[09:11] <ruoso> this leads me back to the Namespace entry has Package, Namespace entry has Class

[09:11] *** broquaint left
[09:12] <ruoso> and Class has Package

[09:12] <ruoso> to make the fallback from method-dispatch to sub-dispatch to work...

[09:26] *** luqui joined
[09:26] <Minthe> How can I get r19961?

[09:27] <moritz_> svn up -r 19961

[09:28] <Minthe> I used svn co -r 19961 http://svn.pugscode.org/pugs

[09:28] <lambdabot> Title: Revision 20662: /

[09:28] <Minthe> But I got: Setup: pugs-HsSyck.cabal:14: 'Executable' stanza starting with field 'license'

[09:28] <moritz_> which ghc version?

[09:29] <Minthe> ghc 6.6.1-2

[09:29] <moritz_> that's weird

[09:29] <moritz_> did you do 'make realclean' first?

[09:30] <Minthe> I did: rm -rf pugs

[09:30] <Minthe> Is this wrong?

[09:31] <moritz_> uhm wait, a fresh checkout should work

[09:31] <moritz_> could you nopaste the full output please?

[09:34] <Minthe> And may I ask which is later, cpan 6.2.13(Oct 2006) or r19961 6.2.12-1?

[09:36] <moritz_> http://dev.pugscode.org/changeset/19961 is 02/20/08 18:55:35

[09:36] <lambdabot> Title: Changeset 19961 - Pugs - Trac

[09:36] * moritz_ doesn't really have clue

[09:37] <Minthe> Oops, I found that cpan 6.2.13 is r14402 in ChangeLog, but why debian/changelog is still 6.2.12-2 in r19961...

[09:37] <Minthe> 6.2.12-1

[09:39] <moritz_> rakudo: my Int $x = -1; say $x

[09:39] <exp_evalbot> rakudo r28084 OUTPUT[Type mismatch in assignment.␤current instr.: 'parrot;Perl6Object;infix:=' pc 65 (src/gen_builtins.pir:51)␤

[09:40] *** penk left
[09:42] *** retoy joined
[09:45] *** retoy left
[09:45] *** jkvd joined
[09:50] <rakudo_svn> r28085 | jonathan++ | [rakudo] prefix:+ and prefix:- should preserve integer type when done on an integer.

[09:51] <pmurias> ruoso: i don't think elf is the reference implementation for sub/method destinction

[09:52] <moritz_> rakudo: my Int $x = -2

[09:52] <exp_evalbot> rakudo r28085 RESULT[-2]

[09:53] <moritz_> jonathan++

[09:55] *** alc left
[09:55] <pmurias> ruoso: and i guess namespace entry has a protoobject, and metaobject has a Package 

[09:58] *** alc joined
[10:03] *** luqui left
[10:04] <Minthe> Moritz: I'm trying building r19955, which is supported by cabal in ghc6_6.6.1-2

[10:08] <pugs_svnbot> r20663 | moritz++ | [spec] S29-num/int.t

[10:08] <pugs_svnbot> r20663 | moritz++ |  * removed ridculous -0s

[10:08] <pugs_svnbot> r20663 | moritz++ |  * tests that int($something).WHAT is 'Int'

[10:10] <ruoso> pmurias, so Foo::bar() would involve finding the class, asking which package it is in, and then looking up for the sub bar?

[10:11] <ruoso> if the namespace entry has both the package and the class, Foo::bar() would have direct access to the package...

[10:14] <rakudo_svn> r28086 | jonathan++ | [rakudo] Make return value of truncate match that in the specification/comment above.

[10:19] <pmurias> ruoso: the namespace entry can have the package also

[10:24] <ruoso> pmurias, but do you agree on the sub/method thing I said?

[10:24] <ruoso> that there can be subs and methods with the same name

[10:24] <ruoso> and subs are registered in the package

[10:25] <ruoso> therefore it will only be invoked as it fallsback to sub-dispatch

[10:25] <ruoso> and what about submethods? do they live in the package? or in the class?

[10:26] <ruoso> the specs seem to imply that they are just subroutines that might have an invocant....

[10:28] <ruoso> but what happens when someons calls a submethod without an invocant?

[10:28] <ruoso> if they live in the class that wouldn't be possible...

[10:29] <ruoso> but it would require yet another storage facility in the protoobject

[10:50] <pmurias> ruoso: submethods are non-inheritable methods

[10:51] <pmurias> so they should be stored in the metaobject

[10:54] <pmurias> not much should live in the protoobject

[10:55] <ruoso> pmurias, that actually depends on the implementation.. but you think it should not live in the package...

[10:57] <pmurias> it is?

[10:57] <pmurias> what do you mean by it

[10:57] <pmurias> ?

[10:58] <ruoso> pmurias, in SMOP, for instance, the HOW won't have a storage itself...

[10:58] <ruoso> the storage will be in the protoobjects...

[10:58] <ruoso> because it's a prototype-based OO

[10:58] <ruoso> not Class-based OO

[10:59] <ruoso> (for the default implementaitons, I must say)

[10:59] <ruoso> but the definition of it is in the package or not is more important...

[10:59] <ruoso> because it then would moving the submethods out of the class/prototypes

[11:00] <ruoso> and registering then as subroutines in the packages

[11:00] <ruoso> that's a more important distinction

[11:00] <pmurias> is metadata a pointer?

[11:00] <ruoso> in SMOP p6opaque?

[11:00] <rakudo_svn> r28088 | jonathan++ | [rakudo] Make .. construct a Range object. Currently we don't have lazy lists implemented, so we eagerly flatten it into a list whenever it is used in list context (easily possible thanks to recent lists changes), however just using it as an iterator will give the lazy

[11:00] <rakudo_svn> ..semantics. All tests that passed before this change in sanity and spectest_regression still pass.

[11:00] <pmurias> yes

[11:01] <pmurias> i'm looking at http://www.perlfoundation.org/perl6/index.cgi?smop_p6opaque_implementation

[11:01] <lambdabot> Title: SMOP p6opaque Implementation / Perl 6, http://tinyurl.com/2z5spt

[11:01] <ruoso> a ponter to a p6opaque-specific structure... it's not another objcet

[11:01] <ruoso> how is another object, otoh

[11:01] <ruoso> so HOW implements the dispatching logic (inheritance, for intance)

[11:02] <ruoso> but everything is stored in the protoobjectts

[11:02] <ruoso> then HOW could, for instance, be SMOP::C3

[11:02] <ruoso> for most objects

[11:03] <ruoso> perl6: say 1.HOW

[11:03] <exp_evalbot> kp6 r20663: OUTPUT[Int␤]

[11:03] <exp_evalbot> ..pugs: OUTPUT[^Int␤]

[11:03] <exp_evalbot> ..rakudo r28088: OUTPUT[get_string() not implemented in class 'P6metaclass'␤current instr.: 'print' pc 8279 (src/gen_builtins.pir:5635)␤

[11:03] <exp_evalbot> ..elf r20663: OUTPUT[Can't call method "HOW" without a package or object reference at (eval 14) line 3.␤ at ./elf_f_faster line 4492␤]

[11:04] <ruoso> rakudo seems to implement something like SMOP will, while pugs and kp6 have a more Class based approach...

[11:04] <pmurias> ruoso: why are you optimising for prototype oo?

[11:04] <ruoso> I'm not... that's just the default implementation

[11:05] <ruoso> prototype oo  seems more natural in SMOP

[11:06] <ruoso> but it's important to remind that the REPR API is SMOP-specific

[11:06] <ruoso> not that I don't want to promote it to a standard ;0

[11:06] <ruoso> ;)

[11:06] <ruoso> http://www.perlfoundation.org/perl6/index.cgi?smop_oo_api

[11:06] <lambdabot> Title: SMOP OO API / Perl 6

[11:07] <pmurias> got to by a blootooth dongle&

[11:09] <ruoso> pmichaud, that's something I'm very curious about parrot/rakudo... how are you planning to interoperate different object representations? like ... my $o = Object.CREATE(:repr<Glib>);

[11:09] <ruoso> in SMOP I stablished a REPR(esentation) API

[11:16] *** broquaint joined
[11:18] <rakudo_svn> r28089 | jonathan++ | [rakudo] Implement smart-matching for Range objects.

[11:18] *** jan_ left
[11:28] <pmurias> s/by/buy/

[11:30] *** alanhaggai joined
[11:48] *** iblechbot left
[11:55] <rakudo_svn> r28090 | jonathan++ | [rakudo] Make where without a block work. This gets us passing the subset-range test.

[11:55] <ruoso> one other question? Who is the responsible of the fallback to sub-dispatching? the HOW? or the interpreter?

[11:56] <pugs_svnbot> r20664 | jnthn++ | [spectest] Un-todo a test that now passes in Rakudo.

[11:57] *** Alias_ joined
[12:00] *** wknight8111 joined
[12:01] *** xinming_ joined
[12:01] *** alc left
[12:18] *** xinming left
[12:27] *** ispy_ joined
[12:28] <pmurias> ruoso: i would guess it's implementation dependend

[12:28] <pmurias> ;)

[12:29] <ruoso> pmurias, that could be problematic...

[12:29] <ruoso> because the behaviour could be too much different

[12:32] <pmurias> i would put it in the interpreter

[12:33] <pmurias> as otherwise the metaobject(.HOW) would need to now about lexical pads and such

[12:33] <ruoso> in fact...

[12:35] <pmurias> can i remove v6/yap6, my svk dosn't like it

[12:36] <ruoso> is it still just the placeholder sayint "it's not yap6 anymore"?

[12:36] <pmurias> yes

[12:36] <moritz_> pmurias: it seems more intuitive to fix svk ;)

[12:36] <rakudo_svn> r28092 | pmichaud++ | [rakudo]:

[12:36] <rakudo_svn> r28092 | pmichaud++ | * Change some :multi(Int) to :multi(Integer), just in case any Parrot

[12:36] <rakudo_svn> r28092 | pmichaud++ |   types leak into our code.

[12:37] <pmurias> moritz_: i hate all things intuitive ;)

[12:37] <moritz_> pmurias: which is why you code in java instead of perl ;-)

[12:37] <moritz_> oh, wait ;)

[12:39] <pmurias> moritz_: how did you now about the java? ;)

[12:39] <ruoso> is "our multi name {..}" the same as "our multi sub name {...}"?

[12:39] <pmurias> * know

[12:39] <moritz_> ruoso: yes

[12:39] <ruoso> hmm... I wasn't aware of that...

[12:46] <pmurias> ruoso: if you have a proto name {...}, our sub name {...} is also equivalent

[12:46] <rakudo_svn> r28093 | jonathan++ | [rakudo] Switch us over to using Mutable for scalars. Passes all sanity and spec tests.

[12:51] *** iblechbot joined
[12:52] <ruoso> I was thinking about the 'foo'.join(', ') thing

[12:53] <ruoso> if we solve it by adding an additional signature to 'our multi join'

[12:53] <ruoso> we will have to do it to almost every method in array

[12:54] <ruoso> and that doesn't seem very nice...

[12:54] <pmurias> ruoso: what does 'foo'.join(', ') do?

[12:54] <rakudo_svn> r28094 | pmichaud++ | [rakudo]:

[12:54] <rakudo_svn> r28094 | pmichaud++ | * Fix hash() so that it again correctly reports "Odd number of

[12:54] <rakudo_svn> r28094 | pmichaud++ |   elements found where hash expected."

[12:55] <pmichaud> ruoso: that was my concern as well (and the focus of my comments with TimToady)

[12:55] <ruoso> 'foo'.join(',') is the simplification of what ('foo').join(',') means

[12:56] <pmichaud> er,  ['foo'].join(',')

[12:56] <moritz_> ruoso: 'foo' and ('foo') are the same thing

[12:56] <pmichaud> since ('foo')  is still a Str

[12:56] <ruoso> but (1,2,3).join(',') is valid

[12:56] <ruoso> right?

[12:56] <pmichaud> yes, because (1,2,3) is a List

[12:56] <pmurias> so 'foo.join(',') is 'foo'?

[12:57] *** renormalist joined
[12:57] <pmurias> so 'foo'.join(',') is 'foo'?

[12:57] <ruoso> so it's expected that (1).join(',') works

[12:57] <pmichaud> pmurias: according to yesterday's discussion, 'foo'.join(',')   is indeed 'foo'

[12:57] <pmichaud> i.e., 'foo' is treated as a 1-element list

[12:57] <pmichaud> same as  'foo'.elems  returns 1

[12:58] <ruoso> yes... 

[12:58] <moritz_> should that work with any $foo, or only with strings?

[12:58] <ruoso> and if to do that we start adding signature variations on the array and hash methods

[12:58] <ruoso> it will be a ugly hack..

[12:58] <ruoso> moritz_, any foo

[12:58] <moritz_> urgh, that's really ugly

[12:59] <moritz_> probably DWIM, but still ugly

[12:59] <pmichaud> (it's also coded this way in the test suite.)

[12:59] <ruoso> there should be some cleaner way of solving this...

[12:59] <ruoso> some syntax hint, eventually...

[13:00] <moritz_> perl6: say <foo>.WHAT

[13:00] <exp_evalbot> kp6 r20664: OUTPUT[Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of

[13:00] <exp_evalbot> ..memory!␤Out of memory!␤Out of memory!␤Out of memory!␤Out of mem...

[13:00] <exp_evalbot> ..pugs: OUTPUT[Str␤]

[13:00] <exp_evalbot> ..rakudo r28094: OUTPUT[Str␤]

[13:00] <exp_evalbot> ..elf r20664: OUTPUT[Array␤]

[13:01] <moritz_> wtf? ;-)

[13:01] <ruoso> kp6++ that was really funny

[13:01] <moritz_> indeed ;)

[13:02] <ruoso> maybe there could be an additional fall-back on the method invocation

[13:03] <ruoso> which would be to create a single-element list and call the method there

[13:03] <moritz_> which then again has a fallback to sub call

[13:04] <ruoso> yes

[13:04] <ruoso> it sounds fat

[13:04] <ruoso> but prettier than dozens signature variations

[13:05] <moritz_> I think we should avoid allowing "foo".join('bla'), and just be consistent about what returns a list

[13:05] <ruoso> the problem is that ($foo) is not a list initializer

[13:05] <ruoso> ($foo,) is

[13:06] <moritz_> that'w hat @(foo) and [$foo] and ($foo,) are there for

[13:06] <moritz_> do we really need yet another?

[13:06] <Juerd> As long as it's not pythonesque "separator".join(list), anything works for me :)

[13:07] <ruoso> yeah... in fact... that would only happen by explicit list initialization of one element using ($foo)

[13:07] <Juerd> moritz_: IIRC [$foo] is not correct here. That would still be a single element list, only now an array.

[13:07] <moritz_> pugs: say ["foo"].join(',');

[13:07] <exp_evalbot> OUTPUT[foo␤]

[13:08] <moritz_> Juerd: but you can calll methods on arrays ;)

[13:08] <ruoso> moritz_, the point is that ["foo"] is rw

[13:08] <ruoso> while (1,2,3) is ro

[13:08] <ruoso> pugs: my @a; @a := (1,2,3); @a.push(4); say @a;

[13:08] <exp_evalbot> OUTPUT[*** Can't modify constant item: VUndef␤    at /tmp/a0e7IMRuz3 line 1, column 23-33␤]

[13:08] <moritz_> ruoso: ok, so there's still @("foo") and ("foo",) remaining

[13:08] <pugs_svnbot> r20665 | diakopter++ | [yap6]

[13:08] <pugs_svnbot> r20665 | diakopter++ | arithmetic evaluation broken;

[13:08] <pugs_svnbot> r20665 | diakopter++ | more syntax recognized; parser output cleaned up

[13:08] <pugs_svnbot> r20665 | diakopter++ | syntax error output still not working.

[13:09] <Juerd> moritz_: Oh, like that.

[13:09] <Juerd> moritz_: For some reason I was back at old join($sep, list) in my mind...

[13:10] * diakopter commutes

[13:10] <ruoso> ('foo') could be parsed as 'foo' but ('foo',)

[13:11] <ruoso> pugs: say 'foo' but ('foo',)

[13:11] <exp_evalbot> OUTPUT[*** Cannot cast from VList [VStr "foo"] to Pugs.AST.Internals.VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤]

[13:11] <moritz_> ruoso: that's quite evil, because it carries a large overhead for ()

[13:11] <moritz_> ruoso: which are just syntactic elements atm

[13:11] <ruoso> but that would only happen when explicitly ($foo) format is used

[13:12] <ruoso> everything else would not be ambiguos

[13:12] <moritz_> ruoso: I think you're too much in perl 5 land atm where () create lists ;)

[13:13] <ruoso> moritz_, () create lists in p6 too

[13:13] <ruoso> (1,2,3) is a list

[13:13] <moritz_> ruoso: no, infix:, creates the list

[13:13] <ruoso> yeah yeah... that's how it's implemented

[13:13] <moritz_> that's how it's specced

[13:14] <ruoso> but for those reading the code... '(1,2,3)' creates a list

[13:14] <ruoso> so (1) would create a list with one item

[13:14] <moritz_> in Perl 6 I'd write my @list = 1, 2, 3;

[13:14] <moritz_> without parenthesis

[13:15] <ruoso> TIMTOWTDI

[13:15] <ruoso> can you 1,.join(',')

[13:15] <ruoso> ?

[13:15] <ruoso> pugs: 1,.join(',')

[13:15] <moritz_> but you don't need infinetly many ways to do it ;)

[13:15] <exp_evalbot> RESULT[(1, ",")]

[13:15] <ruoso> wow

[13:15] <moritz_> why would you want to call join on a one-element list?

[13:15] <rakudo_svn> r28095 | jonathan++ | [rakudo] Get is ro, is rw and is copy, with ro being the default, working on parameters to subs. This time, we get just one failure in spectest_regression (on Win32), which is a result of a Parrot GC bug.

[13:15] <ruoso> my $a = (1); $a.join(',')

[13:16] <moritz_> you'd only do that if the list wasn't literal, but rather the result of some calculation

[13:16] <ruoso> my $a = $something ?? (1) !! (2,3,4) ;

[13:16] <pmurias> my $a = $something ?? 1 !! (2,3,4) ;

[13:17] <moritz_> my @a = $something ?? 1 || 2, 3, 4;

[13:17] <ruoso> but I mean my $a = $something ?? (1,) !! (2,3,4) ;

[13:17] <moritz_> hey, sigils exsit for a reason

[13:17] <pmurias> is (1,) illegal?

[13:18] <ruoso> no... but it would be strange for it to be mandatory

[13:18] <moritz_> pmurias: no

[13:18] <moritz_> ruoso: not mandatory, only handy if you want to avoid ugly looking stuff

[13:18] *** jan_ joined
[13:19] <ruoso> moritz_, I understand your point... but I thing DWIM in this case is very much important, since we use lists all the time

[13:19] <ruoso> s/thing/think/

[13:20] <pmurias> but we use ($foo+$bar) * $baz more often

[13:20] <pmurias> one can always use arrays

[13:20] <ruoso> pmurias, that case is not ambiguous

[13:21] <ruoso> you're implying scalar context by using *

[13:21] <moritz_> ruoso: I still haven't seen a good, pratical example of when we need $foo.list_method, where $foo is actually a literal

[13:21] <ruoso> not $foo, but ($foo)

[13:22] <ruoso> I don't think $foo.list_method to be a good idea also

[13:22] <moritz_> ok, then give a good example for ($foo).list_method

[13:22] <pmurias> what i meant is that we use () work grouping parts of expressions

[13:22] <ruoso> my $a = $something ?? (1) !! (2,3,4); $a.join(', ');

[13:23] <moritz_> ruoso: use @a instead

[13:23] <moritz_> ruoso: that's why I meant

[13:23] <moritz_> if you want something to hold a list, use that @ sigil

[13:24] <moritz_> then it will DWYM

[13:24] <ruoso> ok... fair enough...

[13:25] <pmichaud> we don't want (1) to mean "list" because we don't want   ($a + 1) to mean "list".

[13:25] <ruoso> but..

[13:26] <ruoso> pugs: my $a = 'foo'; mt @b = $a;

[13:26] <exp_evalbot> OUTPUT[*** ␤    Unexpected " ="␤    expecting "::"␤    Variable "@b" requires predeclaration or explicit package name␤    at /tmp/fAMjIrnglg line 1, column 21␤]

[13:26] <ruoso> pugs: my $a = 'foo'; my @b = $a;

[13:26] <exp_evalbot> RESULT[["foo",]]

[13:26] <ruoso> ok

[13:32] <ruoso> pugs: say ('foo',).join(',')

[13:32] <exp_evalbot> OUTPUT[foo␤]

[13:32] *** alanhaggai left
[13:36] *** jhorwitz joined
[13:36] *** eternaleye left
[13:37] <ruoso> pugs: say (1,2,3).WHAT

[13:37] <exp_evalbot> OUTPUT[Array␤]

[13:38] <ruoso> if it implemented that as a optimized compact storage, would it still return Array on (1,2,3).WHAT?

[13:38] <ruoso> rakudo: say (1,2,3).WHAT

[13:38] <exp_evalbot> rakudo r28095 OUTPUT[List␤]

[13:38] <ruoso> rakudo: say (1,2,3).^does(Array)

[13:38] <exp_evalbot> rakudo r28095 OUTPUT[MMD function __concatenate not found for types (151, -98)␤current instr.: 'parrot;Perl6;Grammar;Actions;_block1538' pc 118951 (src/gen_actions.pir:7304)␤

[13:38] <rakudo_svn> r28096 | pmichaud++ | [rakudo]:

[13:38] <rakudo_svn> r28096 | pmichaud++ | * Remove trailing spaces in Range.pir .

[13:39] <ruoso> pugs: say (1,2,3).^does(Array)

[13:39] <exp_evalbot> OUTPUT[1␤]

[13:39] <moritz_> ruoso: optimizations may not be visible to the user, and .WHAT is visisble

[13:39] <ruoso> kp6: say (1,2,3).^does(Array)

[13:39] <exp_evalbot> kp6 r20665: OUTPUT[no method 'APPLY' in Class 'List'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤     KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x8e522a8)', 'APPLY') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤     

[13:39] <exp_evalbot> ..main::DISPATCH('HASH(0x8e522a8)', 'APPLY') called at - line 11␤]

[13:41] <ruoso> moritz_, you mean it should always return Array?

[13:41] <ruoso> or you mean 'whatever'

[13:41] <ruoso> ?

[13:42] <moritz_> ruoso: it should return 'List', independently of any internal optimizations

[13:42] <ruoso> hmmm... maybe it should stringify to 'List'...

[13:42] <ruoso> I mean...

[13:43] <ruoso> (1,2,3).WHAT === (1,'asfsd').WHAT should return false

[13:43] <rakudo_svn> r28097 | jonathan++ | [rakudo] ro trait is actually called readonly.

[13:43] <diakopter> moritz_: is the evalbot ulimit'ed

[13:44] <diakopter> yap6 is using 1GB ram currently.  I think there's an unending loop somewhere :)

[13:44] <diakopter> either that or the grammar is degenerate

[13:44] *** hcchien_ joined
[13:44] <moritz_> diakopter: it is ulimited

[13:44] <pmichaud> seems to me that (1,2,3).WHAT and (1,'asfsd').WHAT return the protoobject for List

[13:45] *** hcchien left
[13:45] <ruoso> pmichaud, but (1,2,3) can be optimized for a compact storage, whereas (1,'absf') can't

[13:45] <ruoso> when it's optimized, does it still returns the same WHAT?

[13:46] <pmichaud> depends on whether that optimization is to be user-space visible or not.

[13:46] <ruoso> heh.. that's my question, actually ;)

[13:46] <pmichaud> I would probably say "not"

[13:46] <moritz_> I don't think it's allowed to be user visible

[13:47] <ruoso> that will make many things much harde

[13:48] <ruoso> or not...

[13:48] <ruoso> but if it's hidden, how can it be introspected (at some level it needs to be)

[13:49] <ruoso> WHAT is supposed to be the entry point for that introspection...

[13:50] <pmichaud> actually, HOW is for introspection.

[13:50] <ruoso> of the metaclass

[13:50] <ruoso> not the prototype

[13:50] <ruoso> they are different thigns

[13:51] <pmichaud> what kind of introspection are you referring to?

[13:51] *** ispy_ left
[13:52] <ruoso> I want the find what the object really is

[13:52] <pmichaud> I think that's HOW.

[13:54] <ruoso> for class-based OO

[13:54] <ruoso> not for prototype-based OO

[13:54] <pmurias> can't prototype oo have unique per object HOW's?

[13:55] <ruoso> that's the actual difference between them

[13:55] <ruoso> the HOW on a prototype OO will be probably be something like Class::C3

[13:56] <ruoso> while the prototypes are the things holding the actual definitions

[13:56] <pmichaud> ...the things holding the actual definitions?

[13:56] <PerlJam> ruoso: btw, congrats on the grant

[13:56] <ruoso> PerlJam, thanks ;)

[13:57] <ruoso> pmichaud, yeah... the method object will be stored in the Foo prototype

[13:57] <ruoso> not in the metaclass

[13:58] <pmurias> ruoso: i'm not sure you use the definition correctly

[13:59] <cj> ruoso: are you yas' grantee this year?

[13:59] <pmurias> http://en.wikipedia.org/wiki/Prototype_based_programming

[13:59] <ruoso> cj, yas?

[13:59] <pmichaud> from S12:  

[14:00] <pmichaud>     MyClass.methods()           # call MyClass's .methods method (error?)

[14:00] <pmichaud>     MyClass.HOW.methods()       # get the method list of MyClass

[14:00] <ruoso> "Which of these items are actually part of the .HOW object and which are delegated back to the package and prototype objects is up to the MOP."

[14:00] <pmichaud> note that the list of methods is part of the metaclass, not the protoobject

[14:00] <pmurias> pmichaud: metaobject not metaclass

[14:01] <pmichaud> from S12:

[14:01] <pmichaud> Every class has a HOW function/method that lets you get at the class's metaobject, which lets you get at all the metadata properties for the class (or other metaobject protocol) implementing the objects of the class:

[14:01] <pmichaud> MyClass.methods()           # call MyClass's .methods method (error?) MyClass.HOW.methods()       # get the method list of MyClass

[14:01] <pmichaud> note "or other metaobject protocol"

[14:02] <ruoso> but .HOW does not stablish identity

[14:02] <ruoso> while .WHAT seems to serve for this sole purpose

[14:02] <pmichaud> .WHICH is identity

[14:03] <ruoso> pmichaud, of the object, not of what it is

[14:05] <pmichaud> well, I can see things going either way.  I'll leave the rest up to the language designers.  :-)

[14:05] *** pmurias left
[14:05] *** alester joined
[14:06] *** alanhaggai joined
[14:06] <ruoso> where did pmurias go? :)

[14:12] <ruoso> @tell pmurias why do you think I'm not using the idea of prototype oo correctly? By reviewing some texts about it, I can fit with pretty much confidence with prototype oo by delegation (which is actually a key to get the repr thing working)

[14:12] <lambdabot> Consider it noted.

[14:13] <ruoso> although It explicitly forbids a defined object to have extra definitions just to avoid that someone accidentally turn Undef into defined

[14:13] <ruoso> but that is basically the only reason

[14:37] <ruoso> hmm... maybe I could make that forbiden just one-way

[14:37] <ruoso> which would be to define a object that have definitions

[14:37] *** pmurias joined
[14:37] <ruoso> but still allows adding definitions to a defined object

[14:38] <pmurias> ruoso: re where i was, i was rebuilding the kernel

[14:38] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[14:38] <ruoso> ah... you're not nija enough to replace the kernel without rebooting...  ;) ;)

[14:39] <ruoso> s/nija/ninja/

[14:39] <ruoso> heh

[14:43] <pmurias> re why are you using the definition incorrectly: prototype oo is commonly a language feature not a way of implemenation

[14:44] <pmurias> you don't have classes in prototype oo, and as such the protobject dosn't make sense at all

[14:47] <ruoso> uh?

[14:47] <ruoso> you lost me.... the protoobject doesn't make sense in prototype oo?

[14:48] <pmurias> yes

[14:48] <ruoso> why so? as I said, I'm implementing delegation...

[14:49] <pmurias> the protoobject is a undefined object used to call methods from the class it belongs to, right?

[14:49] <ruoso> the protoobject is the undefined version of this object

[14:50] <ruoso> you can do a lot of things with it, including cloning

[14:50] <[particle]1> (01:50:08) moritz_: and rakudo parses 'our' as a sub - ouch

[14:50] <[particle]1> no, that's a parrot error

[14:50] <moritz_> ok

[14:50] <pmurias> ruoso: protoobjects make sense in prototype oo as a way of briding between class-base oo and prototype oo

[14:51] <ruoso> pmurias, they make sense when you work with delegation...

[14:51] *** [particle]1 is now known as [particle]

[14:52] <ruoso> we only made a restriction to avoid a user from defining undef...

[14:52] <ruoso> but otherwise, you would be able to say Object.BUILD

[14:52] <ruoso> and Object would be defined

[14:54] <pmurias> but with prototype oo i could build my object like my $object = $foo.clone();$object.HOW().methods.push(...)

[14:55] <ruoso> and you will be able to do that with SMOP

[14:55] <ruoso> we had set a restriction on that only to avoid defining undef...

[14:55] <ruoso> but I think I'll limit that restriction to defining objects with definitions

[14:55] <ruoso> and not the other way around

[14:56] <ruoso> or maybe even removing that restriction entirely

[14:56] <pmurias> &

[14:57] <ruoso> and let the user shoot a bazooca in his feet by doing Object.BUILD

[15:00] <rakudo_svn> r28101 | jonathan++ | [rakudo] Stub in MutableVAR PMC.

[15:12] *** peepsalot joined
[15:20] *** Minthe left
[15:36] *** simcop2387 left
[15:47] *** sscaffidi joined
[15:48] *** drbean left
[15:49] *** drbean joined
[15:54] *** chris2 joined
[16:05] *** smtms joined
[16:11] *** meppl joined
[16:22] *** masak left
[16:25] <ruoso> pugs: Num ~~ Int

[16:25] <exp_evalbot> RESULT[Bool::False]

[16:25] <ruoso> pugs: 3 ~~ Num

[16:25] <exp_evalbot> RESULT[Bool::True]

[16:25] <ruoso> pugs: 3 ~~ Int

[16:25] <exp_evalbot> RESULT[Bool::True]

[16:25] <ruoso> pugs: Int ~~ Num

[16:25] <exp_evalbot> RESULT[Bool::True]

[16:26] *** ChanServ sets mode: +o diakopter

[16:26] *** apeiron joined
[16:26] <ruoso> pugs: Num.ACCEPTS(3)

[16:26] <exp_evalbot> OUTPUT[*** No such method in class Num: "&ACCEPTS"␤    at /tmp/YjONsSXSDW line 1, column 1 - line 2, column 1␤]

[16:27] <ruoso> pugs: Num.ACCEPT(3)

[16:27] <exp_evalbot> OUTPUT[*** No such method in class Num: "&ACCEPT"␤    at /tmp/LgJiwAVcDo line 1, column 1 - line 2, column 1␤]

[16:27] *** TJCRI joined
[16:27] <ruoso> rakudo: Num.ACCEPTS(3)

[16:27] <exp_evalbot> rakudo r28101 RESULT[0]

[16:27] <ruoso> kp6: Num.ACCEPTS(3)

[16:27] <exp_evalbot> kp6 r20665: OUTPUT[no method 'ACCEPTS' in Class 'Num'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824b40c)', 'ACCEPTS', 'HASH(0x8e4b988)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤

[16:27] <exp_evalbot> ..main::DISPATCH('HASH(0x824b40c)', 'ACCEPTS', 'HASH(0x8e4b988)'...

[16:27] <moritz_> is ACCEPTS a class method?

[16:28] <moritz_> rakudo: my Num $x; say $x.ACCEPTS(3)

[16:28] <exp_evalbot> rakudo r28101 OUTPUT[0␤]

[16:28] <ruoso> weird

[16:29] <ruoso> rakudo: sub a (Num $a) { 1 }; say a(3);

[16:29] <exp_evalbot> rakudo r28101 OUTPUT[Parameter type check failed␤current instr.: 'die' pc 7955 (src/gen_builtins.pir:5309)␤

[16:29] <ruoso> hmm

[16:29] <ruoso> pugs: sub a (Num $a) { 1 }; say a(3);

[16:29] <exp_evalbot> OUTPUT[1␤]

[16:30] <ruoso> rakudo: 3 ~~ Num

[16:30] <exp_evalbot> rakudo r28101 RESULT[0]

[16:31] <ruoso> rakudo: 3 ~~ Int

[16:31] <exp_evalbot> rakudo r28101 RESULT[1]

[16:31] <ruoso> rakudo: Int ~~ Num

[16:31] <exp_evalbot> rakudo r28101 RESULT[0]

[16:31] <moritz_> ouch

[16:31] <moritz_> rakudo: Num ~~ Int

[16:31] <exp_evalbot> rakudo r28101 RESULT[0]

[16:31] <Auzon> pugs: my $str = 'abc'; my $vals = $str.split(//); say $vals.perl;

[16:31] <exp_evalbot> OUTPUT[*** Null patterns are invalid; use <?null> or an empty string instead␤    at /tmp/ekCvETyCUj line 1, column 40-42␤]

[16:31] <Auzon> pugs: my $str = 'abc'; my $vals = $str.split(/<?null>/); say $vals.perl;

[16:31] <ruoso> Num is not an Int, that's acceptable

[16:31] <exp_evalbot> OUTPUT[["a", "b", "c"]␤]

[16:31] <Auzon> pugs: my $str = 'a'; my $vals = $str.split(/<?null>/); say $vals.perl;

[16:31] <exp_evalbot> OUTPUT[["a",]␤]

[16:31] <Auzon> pugs: my $str = 'a'; my $vals = $str.split(/<?null>/); say $vals.WHAT;

[16:31] <moritz_> ruoso: no, actually not IMHO ;)

[16:31] <exp_evalbot> OUTPUT[Array␤]

[16:32] <ruoso> moritz_, Num is a superclass of Int...

[16:32] <ruoso> or, better put, Int is a subset of Num

[16:33] <moritz_> rakudo: subset X of Int where ^10; say X ~~ Int

[16:33] <exp_evalbot> rakudo r28101 OUTPUT[0␤]

[16:33] <moritz_> ruoso: but it's very ugly if you can't test $x ~~ Num :/

[16:34] <moritz_> rakudo: subset X of Int where ^10; say  Int ~~ X

[16:34] <exp_evalbot> rakudo r28101 No output (you need to produce output to STDOUT)

[16:34] <ruoso> moritz_, you don't need to 'say'... it outputs the last value

[16:34] <moritz_> why doesn't it produce an output? it has a 'say' in it

[16:34] <moritz_> ruoso: I know, I wrote evalbot ;)

[16:35] <ruoso> heh

[16:35] <ruoso> I forget about most things I write... ;)

[16:35] <ruoso> rakudo: subset X of Int where ^10; Int ~~ X

[16:35] <exp_evalbot> rakudo r28101 No output (you need to produce output to STDOUT)

[16:35] <moritz_> ruoso: but it executes the string twice, the second time wrapped in (do { ($stuff)}).perl.print or so

[16:36] <moritz_> so it's actually faster if you do the say() in the first place

[16:36] <ruoso> hmm... a subset cannot be instantiated... it's a bad example...

[16:37] <moritz_> if speed doesn't matter, without say()  is just fine

[16:37] <moritz_> rakudo: my Int $x = Int.new(); say $x;

[16:37] <exp_evalbot> rakudo r28101 OUTPUT[␤]

[16:37] <moritz_> rakudo: my Int $x = Int.new(); say $x.perl;

[16:37] <exp_evalbot> rakudo r28101 OUTPUT[␤]

[16:37] <moritz_> rakudo: my Int $x = Int.new(); say 4.perl;

[16:37] <exp_evalbot> rakudo r28101 OUTPUT[4␤]

[16:37] <moritz_> rakudo: my Int $x = Int.new(4); say $x.perl;

[16:37] <exp_evalbot> rakudo r28101 OUTPUT[␤]

[16:38] <[particle]> rakudo: my Int $x .= new() say $x.perl;

[16:38] <exp_evalbot> rakudo r28101 OUTPUT[Statement not terminated properly at line 1, near "say $x.per"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[16:38] <[particle]> oops

[16:38] <[particle]> rakudo: my Int $x .= new(); say $x.perl;

[16:38] <exp_evalbot> rakudo r28101 OUTPUT[␤]

[16:38] <[particle]> rakudo: my Int $x .= new(); $x = 4; say $x.perl;

[16:38] <exp_evalbot> rakudo r28101 OUTPUT[4␤]

[16:38] *** Psyche^ joined
[16:39] <[particle]> rakudo: my Int $x .= new(4); say $x.perl;

[16:39] <exp_evalbot> rakudo r28101 OUTPUT[␤]

[16:39] <[particle]> maybe new is doing build but not init

[16:39] <moritz_> shouldn't .perl at least carry the type information?

[16:42] *** schmalbe joined
[16:44] *** jkvd left
[16:44] *** b_jonas joined
[16:46] <rakudo_svn> r28102 | jonathan++ | [rakudo] Add readonly method to Mutable PMC.

[16:46] <[particle]> rakudo doesn't have many .perl methods complete yet

[16:47] *** hanekomu joined
[16:48] <rakudo_svn> r28103 | jonathan++ | [rakudo] Fill out MutableVAR a bit more, and add a few (passing) tests for it.

[16:48] <diakopter> someone please correct me (where I'm wrong)... I don't see a distinction between a statement and an expression.... both set $_, both can be followed by a ';', both can be included inside another expression/statement...

[16:48] *** diakopter sets mode: -o diakopter

[16:49] *** eternaleye joined
[16:49] *** chris2 left
[16:50] <ruoso> diakopter, can you have a ; in an expression? my $a = (1 + 1;) + (2+2;);

[16:51] <diakopter> no, but you can't have one *in* a statement, either.  consider    { block }\n  - the \n is the terminator for the statement that declares the block.  also   statementEOF (it's still treated as a statement)

[16:52] <ruoso> well.. you might omit the ';' in a statement... 

[16:52] <ruoso> but you can't use one in an expression

[16:53] <TimToady> you can if it's inside a bracketing construct

[16:53] <diakopter> that's what I mean... I don't see a distinction between statement (minus optional trailing semicolon) and expression.

[16:53] <ruoso> TimToady, doesn't a bracketing construct contain statements?

[16:53] <TimToady> it's parsed that way

[16:53] *** Patterner left
[16:53] *** Psyche^ is now known as Patterner

[16:54] <ruoso> yeah... that's what I mean... an expression doesn't have ';'... never...

[16:54] <TimToady> but some places reduce via semilist rather than statelist

[16:54] <diakopter> pugs: say(say 3;);

[16:54] <exp_evalbot> OUTPUT[3␤1␤]

[16:54] <diakopter> pugs: say say 3;;

[16:54] <exp_evalbot> OUTPUT[3␤1␤]

[16:54] <ruoso> ouch... is that correct?

[16:54] <diakopter> pugs: say say(3;);

[16:54] <exp_evalbot> OUTPUT[3␤1␤]

[16:55] <ruoso> elf: say(3;);

[16:55] <exp_evalbot> OUTPUT[3␤]

[16:55] <TimToady> pugs's parser should not be trusted completely

[16:55] <ruoso> that is wrong, isn't it?

[16:55] <TimToady> which is wrong?

[16:55] <diakopter> I'd like to know which is/are wrong

[16:56] <ruoso> oh...

[16:56] <ruoso> it's parsing as another thing

[16:56] *** nipotaway is now known as nipotan

[16:56] *** justatheory joined
[16:56] <ruoso> elf: say(3;2);

[16:56] <exp_evalbot> OUTPUT[3␤2␤]

[16:56] <ruoso> elf: say(3,3;2,2);

[16:56] <exp_evalbot> OUTPUT[3␤3␤2␤2␤]

[16:56] <TimToady> in list context ; turns into ,

[16:57] <TimToady> in slice context ; turns into List of Capture

[16:57] <ruoso> yes... but it's not a 'trailing ; in the expression'

[16:57] <ruoso> as I think diakopter was implying

[16:58] <TimToady> re: say say 3;; the "say say 3;

[16:58] <diakopter> no, I wasn't saying semicolon always signifies a statement terminator following an expression

[16:58] <TimToady> is parsed as the first statement

[16:58] <TimToady> and the second ; is a bare ;

[16:58] <ruoso> sure sure.... I was talking about say(3;)

[16:58] <TimToady> by list context turns into say(3,)

[16:58] <diakopter> and say(say 3;);

[16:59] <ruoso> you're finishing the statement

[16:59] <ruoso> with the ;

[16:59] <ruoso> the last one, of course

[16:59] <TimToady> what's the question?

[16:59] <diakopter> say (say 3; say 4; 5; 6)

[17:00] <diakopter> pugs: say (say 3; say 4; 5; 6)

[17:00] <exp_evalbot> OUTPUT[*** ␤    Unexpected ";"␤    expecting "_", fraction, exponent, term postfix, operator, ":", "," or ")"␤    at /tmp/qe1VIpzr6E line 1, column 11␤]

[17:00] <ruoso> TimToady, the difference between expression and statement

[17:00] <diakopter> pugs: say (say 3; say 4; 5, 6)

[17:00] <exp_evalbot> OUTPUT[*** ␤    Unexpected ";"␤    expecting "_", fraction, exponent, term postfix, operator, ":", "," or ")"␤    at /tmp/nZKAuc5NU8 line 1, column 11␤]

[17:01] <diakopter> pugs: say (say 3, say 4, 5, 6)

[17:01] <exp_evalbot> OUTPUT[456␤31␤1␤]

[17:01] <diakopter> interesting, the last say slurped 4,5,6

[17:01] <ruoso> but that is not actually wrong... it was supposed to be parseable

[17:01] <diakopter> pugs: say (say 3, say 4; 5, 6)

[17:01] <exp_evalbot> OUTPUT[*** ␤    Unexpected ";"␤    expecting "_", fraction, exponent, term postfix, operator, ":", "," or ")"␤    at /tmp/gGyErMla49 line 1, column 18␤]

[17:02] <diakopter> pugs: say ((say 3, say 4) 5, 6)

[17:02] <exp_evalbot> OUTPUT[*** ␤    Unexpected "5"␤    expecting operator or ")"␤    at /tmp/bZfTJBL2r1 line 1, column 21␤]

[17:02] <diakopter> pugs: say ((say 3, say 4), 5, 6)

[17:02] <exp_evalbot> OUTPUT[4␤31␤156␤]

[17:02] <diakopter> weird

[17:02] <ruoso> the newline is misplaced...

[17:03] <[particle]> what's weird there?

[17:03] <ruoso> where did that 1 come from?

[17:03] <diakopter> I don't know where the second 1 comes from

[17:03] <[particle]> say 4 prints 4nl

[17:03] <ruoso> the first one actually

[17:03] <diakopter> oh

[17:03] <diakopter> yeah

[17:03] <ruoso> oh

[17:03] <[particle]> say 3, 1

[17:03] <ruoso> yeah

[17:03] <ruoso> heh

[17:03] <diakopter> pugs: say ((say 3; say 4), 5, 6)

[17:03] <exp_evalbot> OUTPUT[*** ␤    Unexpected ";"␤    expecting "_", fraction, exponent, term postfix, operator, ":", "," or ")"␤    at /tmp/A83Xjxxw3p line 1, column 12␤]

[17:03] <ruoso> it was being parsed as say(4,say(4))

[17:04] <b_jonas> the second one is from that (say 3, say 4) is evaled in list context so you get the 1 from both

[17:04] <ruoso>  say(3,say(4))

[17:04] <b_jonas> I think

[17:04] <diakopter> pugs: say ((say 3, say 4;), 5, 6)

[17:04] <exp_evalbot> OUTPUT[*** ␤    Unexpected ";),"␤    expecting "_", fraction, exponent, term postfix, operator, ":", "," or ")"␤    at /tmp/wCPCzM3SJf line 1, column 19␤]

[17:04] <b_jonas> no wait, I'm wrong

[17:04] <ruoso>  say(say(3,say(4)),5,6)

[17:04] <ruoso> that's how it's being parsed

[17:04] <b_jonas> it's from that say 3, say 4 prints the 1 that say 4 returns

[17:04] <b_jonas> and the outer say returns the 1 that say 3, say 4 returns

[17:04] <diakopter> pugs: say(say(3,say(4)),5,6)

[17:04] <exp_evalbot> OUTPUT[4␤31␤156␤]

[17:04] <diakopter> yep you're right ruoso 

[17:04] <ruoso> it evaluates the parameters from RTL

[17:05] <ruoso> that's why the 4 is before

[17:05] <TimToady> no

[17:05] * diakopter laughs

[17:05] <b_jonas> buubot, eval: say(say(3,say(4)),5,6)

[17:05] <TimToady> it's inside to out

[17:05] <buubot> b_jonas:  undefERROR: 15056: Undefined subroutine &main::say called at (eval 1590481) line 1.

[17:05] <b_jonas> buubot, eval: use 5.010; say(say(3,say(4)),5,6)

[17:05] <buubot> b_jonas:  4311561

[17:05] <ruoso> TimToady, yeah... but when it was say(say 3, say 4)

[17:06] <b_jonas> buubot, eval: use 5.010; $\ = ":"; print(print(3,print(4)),5,6)

[17:06] <buubot> b_jonas:  4:31:156:1

[17:06] <ruoso> it took say 4 as an argument to say

[17:06] <TimToady> it is evaluating the parameters to the inside say before the parameters to the outside say

[17:06] <b_jonas> you get the same in perl5, see?

[17:06] <ruoso> sure...

[17:06] <diakopter> buubot, eval: use 5.010; $\ = ":"; print(print 3,print 4,5,6)

[17:06] <buubot> diakopter:  456:31:1:1

[17:07] <diakopter> buubot, eval: use 5.010; $\ = ":"; print((print 3,print 4),5,6)

[17:07] <buubot> diakopter:  4:31:156:1

[17:07] <diakopter> buubot, eval: use 5.010; $\ = ":"; print((print 3;print 4);5;6)

[17:07] <buubot> diakopter:  undefERROR: syntax error at (eval 1590834) line 1, at EOFsyntax error at (eval 1590834) line 1, near "4)"syntax error at (eval 1590834) line 2, near "6)"

[17:08] *** schmalbe left
[17:08] <ruoso> pugs: say(say(3),say(4)),5,6)

[17:08] <exp_evalbot> OUTPUT[*** ␤    Unexpected ")"␤    expecting "_", fraction, exponent, term postfix or operator␤    at /tmp/2vRGcS029v line 1, column 23␤]

[17:08] <ruoso> pugs: say(say(3),say(4),5,6)

[17:08] <exp_evalbot> OUTPUT[3␤4␤1156␤]

[17:10] <diakopter> I still want to know whence that 2nd 1

[17:10] <ruoso> there are two say calls

[17:10] <TimToady> in the most recent, the return of say(4)

[17:10] <ruoso> say returns 1

[17:11] <diakopter> pugs: say((say(3),say(4)),5,6)

[17:11] <exp_evalbot> OUTPUT[3␤4␤1156␤]

[17:11] <diakopter> oh, it flattens

[17:11] <diakopter> pugs: say(say(say(3),say(4)),5,6)

[17:11] <exp_evalbot> OUTPUT[3␤4␤11␤156␤]

[17:11] <TimToady> yes, () is invisible in list context

[17:11] <ruoso> pugs: say(say 3 && say 4, 5, 6); # :)

[17:11] <exp_evalbot> OUTPUT[456␤1␤1␤]

[17:11] <diakopter> pugs: say(1,1)

[17:11] <exp_evalbot> OUTPUT[11␤]

[17:11] <ruoso> pugs: say((say 3 && say 4), 5, 6); # :)

[17:11] <exp_evalbot> OUTPUT[4␤1␤156␤]

[17:12] <TimToady> pugs: say((say 3 and say 4), 5, 6); # :)

[17:12] <exp_evalbot> OUTPUT[3␤4␤156␤]

[17:12] <diakopter> so again, what about 

[17:12] <diakopter> pugs: say(say 3;)

[17:12] <exp_evalbot> OUTPUT[3␤1␤]

[17:13] <TimToady> pugs: say(say 3,)

[17:13] <exp_evalbot> OUTPUT[3␤1␤]

[17:13] <diakopter> right, but

[17:13] <ruoso> (3;2) creates a multidimensional list

[17:13] <ruoso> not two expressions

[17:13] <TimToady> only in subscripts

[17:13] <diakopter> pugs: say(say 3; say 4)

[17:13] <exp_evalbot> OUTPUT[3␤4␤11␤]

[17:13] <ruoso> "say 4" is an expression

[17:13] <TimToady> (3;2) creates a multidim list only in *slice* context

[17:13] <diakopter> ok

[17:14] <ruoso> what is a proper name to call it?

[17:14] <TimToady> and the decision may actually be delayed to binding time

[17:14] <b_jonas> pugs: $ (3;2)

[17:14] <exp_evalbot> OUTPUT[*** ␤    Unexpected " ("␤    expecting "::"␤    at /tmp/n3GfO8WjCn line 1, column 2␤]

[17:14] <b_jonas> pugs: + (3;2)

[17:14] <exp_evalbot> OUTPUT[*** ␤    Unexpected ";"␤    expecting "_", fraction, exponent, term postfix, operator or ")"␤    at /tmp/w6n5KZUDFu line 1, column 5␤]

[17:14] <b_jonas> good

[17:15] <diakopter> pugs: /(3;2)

[17:15] <exp_evalbot> OUTPUT[*** ␤    Unexpected end of input␤    expecting "\\", variable name or "/"␤    at /tmp/LlAXlCZRJf line 2, column 1␤]

[17:16] <ruoso> pugs: sub a (@a, @b) { say @a; say @b }; a(1,2,3;4,5,6)

[17:16] <exp_evalbot> OUTPUT[*** No compatible multi variant found: "&a"␤    at /tmp/gobYLgoC5w line 1, column 36 - line 2, column 1␤]

[17:16] <diakopter> TimToady: can you clarify what you said about ; being inside some bracketing constructs (which are themselves statements, I think you to mean)

[17:16] <ruoso> pugs: sub a (@a, @b) { say @a; say @b }; a((1,2,3);(4,5,6))

[17:16] <exp_evalbot> OUTPUT[123␤456␤]

[17:16] <ruoso> pugs: sub a (@a, @b) { say @a; say @b }; a((1,2,3),(4,5,6))

[17:16] <exp_evalbot> OUTPUT[123␤456␤]

[17:16] <ruoso> pugs: sub a (@a, @b) { say @a; say @b }; a \(1,2,3;4,5,6)

[17:16] <TimToady> everything inside brackets is parsed with <semilist>, and the interpretation of that depends on context

[17:16] <exp_evalbot> OUTPUT[*** ␤    Unexpected "\\("␤    expecting bare or pointy block construct, ":", identifier or operator␤    at /tmp/fJBJIXPw7F line 1, column 38␤]

[17:17] <ruoso> pugs: sub a (@a, @b) { say @a; say @b }; my $a \(1,2,3;4,5,6); 

[17:17] <exp_evalbot> OUTPUT[*** ␤    Unexpected "\\("␤    expecting "?", "!", trait, "=", infix assignment or operator␤    at /tmp/ALH5MtNOey line 1, column 42␤]

[17:17] <ruoso> pugs: sub a (@a, @b) { say @a; say @b }; my $a = \(1,2,3;4,5,6); a(|$a)

[17:17] <exp_evalbot> OUTPUT[*** ␤    Unexpected "$a"␤    expecting "=", context, ":" or "("␤    at /tmp/FysvV44LAG line 1, column 39␤]

[17:17] <TimToady> subscripts are allowed to assume at compile time that they will be bound to a slice context

[17:17] <TimToady> so the optimizer can work with it

[17:18] * diakopter reads about semilist in STD

[17:18] <TimToady> otherwise all you can do with a semilist is turn it into List of Capture and defer the decision whether to flatten or not

[17:18] <ruoso> TimToady, but is the (1,2,3 ; 4,5,6) format valid?

[17:18] <TimToady> depending on binding

[17:18] <ruoso> for :(@a, @b)

[17:18] *** sscaffidi left
[17:19] <b_jonas> basically, (2; 3) has to be an error in most contexts I think

[17:19] <TimToady> it's not

[17:19] <diakopter> pugs: sub a (@a, @b) { (say @a; say @b) }; my $a = \(1,2,3;4,5,6); a(|$a)

[17:19] <exp_evalbot> OUTPUT[*** ␤    Unexpected ";"␤    expecting "::", term postfix, operator, ":", "," or ")"␤    at /tmp/DLsr7Tjl83 line 1, column 25␤]

[17:19] <TimToady> please note that pugs has never implemented slice context

[17:20] <diakopter> pugs: sub a (@a, @b) { (say @a; say @b) }; a((1,2,3),(4,5,6))

[17:20] <exp_evalbot> OUTPUT[*** ␤    Unexpected ";"␤    expecting "::", term postfix, operator, ":", "," or ")"␤    at /tmp/YqFKBShfkg line 1, column 25␤]

[17:20] <ruoso> in fact... I think a((1,2,3),(4,5,6)) was supposed to be the same as (1,2,3,4,5,6) isnt'it?

[17:20] <TimToady> not necessarily

[17:20] <b_jonas> hmm

[17:20] <TimToady> again, it depends on the binding

[17:20] <diakopter> eek

[17:20] <ruoso> that seems very hard to implement ;)

[17:21] <TimToady> you did read the synopses, didn't you?  :)

[17:21] <pmichaud> a((1,2,3),(4,5,6))   will act as (1,2,3,4,5,6)  if bound to a slurpy array

[17:21] * diakopter adds a few more passes to the ROADMAP

[17:21] <TimToady> but if the sig is ($,$) you get two lists

[17:21] <pmichaud> you also get two lists with (@,@)

[17:21] <TimToady> indeed

[17:21] <b_jonas> S03: The context determines how the expressions terminated by semicolon are interpreted. At statement level they are statements. Within a bracketing construct they are interpreted as lists of Captures, which in slice context will be treated as the multiple dimensions of a multidimensional slice. (Other contexts may have other interpretations or disallow semicolons entirely.)

[17:22] <diakopter> ah ok; that answers my original question.

[17:22] <b_jonas> lists of Captures? wierd

[17:22] <b_jonas> I like the parenthetical remark

[17:22] <ruoso> pugs: multi sub a (@a) { 1}; multi sub a (@a, @b) { 2}; say a((1,2,3),(4,5,6))

[17:22] <exp_evalbot> OUTPUT[2␤]

[17:23] <b_jonas> basically I think semicolons should be "usually" an error inside parenthesis so you can easily catch unpaired open parenthesis in expressions

[17:23] <TimToady> it would be a good place for a "suppose" point, if the parse does fail later

[17:24] <TimToady> in which case it will still tell you exactly what went wrong, most likely

[17:24] <diakopter> pugs: multi sub a (@a) { 1}; multi sub a (@a, @b) { 2}; say a((('flatten','me',3),(4,5,6)))

[17:24] <exp_evalbot> OUTPUT[1␤]

[17:25] <diakopter> nifty.

[17:25] <TimToady> but as you see with (say 3; say 4), it has the use of terminating the first say's argument list and then continuing the outer list

[17:25] <b_jonas> TimToady: yeah, especially if it also watches indentation for suppose points

[17:25] <b_jonas> hmm

[17:25] <diakopter> pugs: multi sub a (@a) { 1}; multi sub a (@a, @b) { 2}; say a((('flatten','me',3);(4,5,6);))

[17:25] <exp_evalbot> OUTPUT[*** ␤    Unexpected ";("␤    expecting term postfix, operator or ")"␤    at /tmp/RK2foxEXVy line 1, column 76␤]

[17:25] <diakopter> pugs: multi sub a (@a) { 1}; multi sub a (@a, @b) { 2}; say a((('flatten','me',3);(4,5,6)))

[17:25] <TimToady> you can apply any amount of AI to error message determination, as long as you make the user fix the program

[17:25] <exp_evalbot> OUTPUT[*** ␤    Unexpected ";("␤    expecting term postfix, operator or ")"␤    at /tmp/pvdxYmz58V line 1, column 76␤]

[17:25] <b_jonas> where is that (say 3; say 4) defined in the synopsis?

[17:26] <b_jonas> what I quoted is I think all it says about the semicolon

[17:26] <pmichaud> b_jonas: S04:  Note though that the first expression within parens or brackets is parsed as a statement, so you can say:

[17:26] <pmichaud> @x = 41, (42 if $answer), 43;

[17:26] <lambdabot> Maybe you meant: . ? @ v

[17:26] <pmichaud> and that is equivalent to:

[17:26] <pmichaud> @x = 41, ($answer ?? 42 !! ()), 43

[17:26] <lambdabot> Maybe you meant: . ? @ v

[17:26] <b_jonas> oh no

[17:26] <b_jonas> that's exactly what makes error catching hard

[17:27] <TimToady> so you suppose

[17:27] <diakopter> suppose harder

[17:27] <pmichaud> also:  A do is assumed immediately after any opening bracket,

[17:27] <pmichaud> ...

[17:27] <b_jonas> (though it's even worse in ruby where newlines are converted to an implicit semicolon in lots of places)

[17:28] <diakopter> {bareblock}\n  <- statement

[17:28] <diakopter> ?

[17:28] <b_jonas> brace is ok

[17:28] <b_jonas> let me check

[17:29] <b_jonas> S04 says: In Perl 6, the bare block is not a do-once. Instead do {...} is the do-once loop (which is another reason you can't put a statement modifier on it; use repeat for a test-at-the-end loop).

[17:29] <rakudo_svn> r28105 | particle++ | #55346: [PATCH] tool for checking if '# pure' files still contain fudging

[17:29] <b_jonas> so I think no

[17:29] <rakudo_svn> r28105 | particle++ | ~ applied with minor formatting corrections and enhancements

[17:29] <rakudo_svn> r28105 | particle++ | Courtesy of Moritz Lenz (moritz++)

[17:29] *** Alias_ left
[17:29] *** Alias_ joined
[17:29] <diakopter> pugs: say(eval("{ my $a=3; say $a+4;}\n"))

[17:29] <exp_evalbot> OUTPUT[7␤1␤]

[17:30] <TimToady> it does it once, it's just not a loop

[17:30] <diakopter> pugs: say({ my $a=3; say $a+4;}\n)

[17:30] <exp_evalbot> OUTPUT[*** ␤    Unexpected "n"␤    expecting "(" or "."␤    at /tmp/0pBQqPfFOC line 1, column 27␤]

[17:30] <diakopter> pugs: say({ my $a=3; say $a+4;})

[17:30] <exp_evalbot> OUTPUT[<SubBlock(<anon>)>␤]

[17:30] <b_jonas> hmm

[17:30] <diakopter> the block was declared only?

[17:30] <pmichaud> that's not a bare block.

[17:31] <pmichaud> a bare block is a block that occurs at statement level.

[17:31] <b_jonas> so a brace can be a do-once, a subroutine, or a hash?

[17:31] <pmichaud> inside of parens, it's a closure.

[17:31] <b_jonas> fun

[17:31] <diakopter> oh...

[17:31] <pmichaud> I should say.... inside of an argument list, it's a closure

[17:31] <[particle]> braces are always a closure

[17:32] <b_jonas> I don't get it then

[17:32] <b_jonas> so a bare block is never a do-once, right?

[17:32] <pmichaud> { my $a = 3;  say $a; }     # bare block, executes immediately

[17:32] <TimToady> it works as in Perl 5, except for the fact that it's not a loop

[17:33] <ruoso> a bare block is a block in void context?

[17:33] <b_jonas> ah yeah

[17:33] <b_jonas> found it

[17:33] <b_jonas> Although a bare block occuring as a single statement is no longer a do-once loop, it still executes immediately as in Perl 5, as if it were immediately dereferenced with a .() postfix, so within such a block CALLER:: refers to the scope surrounding the block.

[17:33] <b_jonas> in S04

[17:33] <pmichaud> b_jonas: correct.

[17:33] <b_jonas> hmm

[17:33] <ruoso> so a block in void context is executed immediatly...

[17:33] <TimToady> it's not the void context

[17:34] <ruoso> it's syntatic only?

[17:34] <TimToady> it's being part of <statelist> rather than <semilist>

[17:34] <pmichaud> it's the bare block as a single statement

[17:34] <b_jonas> pmichaud: but wouldn't that conflict with the above thing you said that "the first expression within parens or brackets is parsed as a statement"

[17:34] <b_jonas> ?

[17:34] *** hcchien_ is now known as hcchien

[17:34] <TimToady> that's a semilist

[17:34] <pmichaud> say({ ... })     isn't inside "parens".

[17:34] <pmichaud> here the parens are part of the argument list.

[17:34] <b_jonas> oh, so "inside parens" doesn't apply to argument lists

[17:34] <b_jonas> I see

[17:34] <b_jonas> that's just like ruby

[17:34] *** dalek left
[17:35] <b_jonas> (probably stolen from there as well)

[17:35] <TimToady> nope

[17:35] <TimToady> I've never actually looked at how ruby parses

[17:35] <pmichaud> and the "inside parens" doesn't say anything about when the block is executed -- just how it's parsed.

[17:35] *** dalek joined
[17:35] <b_jonas> but then

[17:35] <b_jonas> what does "or brackets" mean in that?

[17:35] <b_jonas> what kind of brackets?

[17:36] <pmichaud> [{ ... }]

[17:36] <b_jonas> but meaning what?

[17:36] <b_jonas> array constructor?

[17:36] <pmichaud> sure.

[17:36] <TimToady> it's a semilist, not a statelist

[17:36] <b_jonas> that doesn't seem to make sense to me

[17:36] <b_jonas> why array constructor in particular?

[17:37] <b_jonas> how's that different from any ordinary function call arglist or circumfix operator?

[17:37] <b_jonas> bare parens special, I get that

[17:37] <b_jonas> but array constructor?

[17:37] <TimToady> bare [...] is always an array composer

[17:38] <pmichaud> example:   @x = 41, [42 if $answer], 43;

[17:38] <b_jonas> strange

[17:38] <TimToady> that's either 41, [42], 43 or 41, [], 43

[17:39] <b_jonas> I don't get what that's good for

[17:39] <TimToady> modifiers inside brackets are good for various forms of list comprehensions

[17:40] <ruoso> but the difference from p5 here is in accepting "if" there, not the array construct itself, right?

[17:40] *** sscaffidi joined
[17:40] <b_jonas> list comprehensions... hmm... maybe

[17:40] <TimToady> and redefining the return value of a false "if" to be ()

[17:41] <b_jonas> buubot, eval: [do { 3 if 0 }]

[17:41] <buubot> b_jonas:  [0]

[17:41] <diakopter> pugs: say(3,my $bar = sub { my $closure = say(4); { die "5"; }  },$bar())

[17:41] <exp_evalbot> OUTPUT[4␤*** 5␤    at /tmp/c7Y81fmEmW line 1, column 61-67␤       /tmp/c7Y81fmEmW line 1, column 47-54␤]

[17:41] <ruoso> pugs: sub a ($a) { say $a }; a(5 if 1)

[17:41] <exp_evalbot> OUTPUT[*** ␤    Unexpected "if"␤    expecting operator, ":" or ")"␤    at /tmp/QdEKRSKf8R line 1, column 28␤]

[17:41] <b_jonas> buubot, eval: $a = 0; [do { 3 if $a }]

[17:41] <buubot> b_jonas:  [0]

[17:41] <b_jonas> yeah, it returns the condition in p5

[17:42] <ruoso> buubot, eval: $a = "0 but true"; [do { 3 unless $a }]

[17:42] <buubot> ruoso:  ["0 but true"]

[17:43] <diakopter> I'm getting the feeling the type checker will need to employ brute force.

[17:43] <ruoso> TimToady, but is a(5 if $foo) valid also? or is that specific for the array constructor?

[17:43] <pmichaud> the thing in the parens is a semilist

[17:44] <pmichaud> so yes.

[17:44] <ruoso> ah... ok... for one second I understood it was something specific...

[17:44] <TimToady> there are very few specifics in Perl 6  :)

[17:44] <pmichaud> in STD.pm:  token postcircumfix:sym<( )> ( --> Methodcall) { '(' <semilist> ')' {*} }

[17:45] <diakopter> that's like God saying the Bible has very few specifics.

[17:45] <ruoso> hehe

[17:45] <[particle]> it's <semispecific>

[17:46] <TimToady> it's just that everyone ignores the specifics that *are* there...  :)

[17:46] <ruoso> diakopter, it's not that it is specific... it's you that didn't reach the nirvana to get the abstraction yet ;)

[17:46] <diakopter> exactly.  my Bible-parser isn't yet single-pass.

[17:47] <ruoso> TimToady, while you're around...

[17:47] <ruoso> does submethods belong to the package or to the class?

[17:47] <diakopter> tuit alert

[17:49] <ruoso> that meaning... is it possible to invoke a submethod as a subroutine, passing the invocant explicitly (or not)?

[17:49] <pugs_svnbot> r20666 | moritz++ | [spec] unfudged one passing test in exp.t

[17:49] <ruoso> and if so, what happens when no invocant is given?

[17:49] <TimToady> it's possible to invoke *any* method as a subroutine, if you turn it into a Code ref first

[17:49] <TimToady> that's how dispatchers work

[17:50] <ruoso> no... I mean directly by name

[17:50] <TimToady> the magic of submethods is in the dispatcher

[17:50] <ruoso> from that I would presume it belongs to the class, and that it would be part of the dispatch before falling back to sub dispatch

[17:50] <TimToady> offhand, I don't think so

[17:51] <TimToady> and I'm not sure we even need fallback from single dispatch to multiple dispatch, now that we have "is export"

[17:52] <TimToady> (thought that's kind of intended for the opposite case...)

[17:52] <ruoso> I didn't ever thought on having it separated... heh... I always thought it would behave as multi always, it would only stop looking it it knew that there were no variants

[17:53] <TimToady> foo($x) is always a request for multiple dispatch, and $x.foo() is always a request for single dispatch

[17:54] <TimToady> and cases like close($fh) vs $fh.close are now handled by "is export"

[17:54] *** orafu left
[17:54] <b_jonas> oh, so the one-argument named function exception is now gone?

[17:54] <b_jonas> lemme check

[17:55] <TimToady> long time now

[17:55] <b_jonas> ok, it would be difficult to check anyway for I've no idea which S to look

[17:55] <TimToady> that's one of those durn specifics we got rid of

[17:55] <b_jonas> 6 or 12 or 13

[17:55] <moritz_> b_jonas: exactly, one of these ;)

[17:56] <diakopter> moritz_: how about making evalbot commands (and responses?) appear as C<> on the irc log :D

[17:56] <diakopter> or just bold or something

[17:56] <moritz_> diakopter: do you mean enclosed in C<...>? or type writer?

[17:57] <moritz_> it's all monospace at them moment

[17:57] <diakopter> I don't know.  just something to distinguish it as computer-readable as well as human-readable.

[17:58] <moritz_> diakopter: it's computer readable in the sense that everything from exp_evalbot is output from an eval command

[17:58] <moritz_> are you planning anything special with the stuff?

[17:58] <TimToady> afk &  # シャワー

[17:59] <diakopter> no, I just think it would be nice to be able to look at the irclog as a REPL log

[17:59] <moritz_> diakopter: maybe it's easier if I make evalbot log its in- and output somewhere?

[17:59] *** renormalist left
[17:59] <diakopter> but it's ok; I can write a greasemonkey script or something

[17:59] <diakopter> moritz_: yeah, if it logged, it would be easier to convert them to test cases

[18:00] <pugs_svnbot> r20667 | moritz++ | [spec] fixed previous commit

[18:01] <moritz_> diakopter: ok, I'll see if I can find some tuits tonight for implementing that

[18:01] <diakopter> I'm sure Auzon would love that... a hundred new test cases a day to sort into t/spec/

[18:02] <diakopter> "hmm, what's this supposed to test?"

[18:02] <moritz_> but you can't automate it, and formatting is crappy

[18:03] <Auzon> It'd be neat to harness evalbot that way. But it'd be hard to get useful stuff from just trying to get a syntax working

[18:03] <Auzon> And I use evalbot as a calculator sometimes, so that'd throw it off too :P

[18:04] *** rdice joined
[18:04] <b_jonas> I use my bot as a calculator

[18:04] <b_jonas> becuase j is the best language for that kind of usage

[18:06] <moritz_> well, that's not what evalbot was designed for ;)

[18:06] <moritz_> you don't need forking and resource limits for simple arithmetics

[18:11] <b_jonas> sure you do

[18:11] <b_jonas> for the kind of calculations I do

[18:11] <b_jonas> :)

[18:11] <b_jonas> pugs: [+] ^1000000

[18:11] <rakudo_svn> r28106 | pmichaud++ | [rakudo]:

[18:11] <rakudo_svn> r28106 | pmichaud++ | * Avoid losing precision in floating point constants.

[18:12] *** hanekomu left
[18:12] <exp_evalbot> No output (you need to produce output to STDOUT)

[18:12] <ruoso> I think the eval bot gone for a ride...

[18:12] <b_jonas> you surely always need resource limits

[18:12] <b_jonas> you can do without forking if that's easier

[18:12] *** ruoso left
[18:13] <b_jonas> but usually it's easier to write the bot with forking

[18:13] <pmichaud> b_jonas: you're correct that S06 incorrectly lists the one-argument named function exception (still)

[18:13] <pmichaud> I noticed that this morning.

[18:13] <pmichaud> wasn't quite sure how to rewrite it.

[18:14] <b_jonas> oh

[18:14] *** elmex_ joined
[18:14] <pmichaud> the comments about unary named in S03 are newer, though.

[18:14] *** elmex left
[18:15] *** elmex_ is now known as elmex

[18:21] <pugs_svnbot> r20668 | moritz++ | [spec] unfudged one more test in S29-num/exp.t, pmichaud++ for fixing it

[18:21] *** sri_work left
[18:22] <pmichaud> TimToady: if we write    sub prefix:<xyz> ($x) { ... }    does that automatically create a sub named 'xyz' ?   I.e., could we access the sub using both &xyz and &prefix:<xyz>  ?

[18:25] <avar> I think sub FOO specifies the full name of the sub but prefix: is magic, but I don't know

[18:25] <avar> i.e. you couldn't do &xyz

[18:32] *** elmex left
[18:33] *** Alias_ left
[18:34] *** vixey left
[18:34] *** vixey joined
[18:38] <pasteling> "diakopter" at 209.9.237.164 pasted "yap6 trace output for: use v6; my $a = 3;" (1252 lines, 73.5K) at http://sial.org/pbot/31210

[18:41] <TimToady> pmichaud: I think we probably need both names so that xyz() works as a function call, though I can think of ways to fudge it in the compiler.  but if it's going to hide sub xyz anyway, why not clobber the name?

[18:42] <TimToady> but I don't feel very strongly about it one way or the other

[18:42] <PerlJam> what happens when xyz is a multi?

[18:43] <diakopter> TimToady: the above trace output is with stmt merged into expr

[18:43] <TimToady> I think multiness is orthogonal to how it's parsed

[18:44] <TimToady> the only real difference is how you parse xyz 1,2

[18:45] <TimToady> on the other hand, I think I see what you're asking

[18:45] <TimToady> are prefix:<xyz> and sub xyz multis intermixed?

[18:45] <pmichaud> partially.

[18:45] <pmichaud> I'm thinking of  prefix:<abs>    and   $foo.abs

[18:46] <pmichaud> but yes, the question of multis is also there.

[18:46] <PerlJam> In my head prefix: subs and "regular" subs live in different places because their long names are different.

[18:47] <PerlJam> Kind of like $foo and @foo (because the sigil is part of the long name)

[18:47] <TimToady> but defining both prefix:<xyz> and xyz seems like asking for trouble anyway

[18:47] *** Ched- left
[18:47] <TimToady> because verbs are used without sigils, typically

[18:47] <pugs_svnbot> r20669 | diakopter++ | [yap6] prefixing evalbot input to yap6 with 'use v6;'

[18:47] <pugs_svnbot> r20669 | diakopter++ | to match the other evaluators, since yap6 enforces it.

[18:48] <TimToady> well, gotta go get passport pix took...

[18:48] <pmurias> TimToady: is there a way to check if STD5.pm is more broken the it was before a change?

[18:48] *** Ched- joined
[18:48] *** fser joined
[18:48] <pmichaud> I'm not worried about xyz() as a function call, because it's already a named unary

[18:48] <fser> Hello

[18:48] <pmurias> fser: hi

[18:49] <pmichaud> (unless there's a multi 'xyz' that isn't unary)

[18:49] <fser> will perl6 include a kind of shell, a little like python does ?

[18:49] <PerlJam> fser: you mean an interactive mode?

[18:49] <fser> yes

[18:49] <moritz_> fser: I guess that's implementation dependant

[18:49] <moritz_> fser: pugs had it, rakudo has a basic one

[18:49] <b_jonas> yeah, I think that's not under the scope of the specs

[18:49] <b_jonas> nor is the debugger 

[18:49] <pmichaud> fser: it's not (yet?) part of the spec, but some implementations are providing one.

[18:49] <moritz_> but it's generally considered good practice to provide one, and very handy as well

[18:50] <fser> wow I guess I'm not aware enough about perl 6, you're speaking about multiple implementations ..

[18:50] <fser> (or is it perl in general I ignore ?)

[18:50] <pmichaud> Perl 6 is a language specification, not tied to a specific implementation.

[18:50] <pmichaud> this is a bit different from previous Perls, yes.

[18:51] *** ps_2 joined
[18:51] <fser> ok, thanks

[18:51] <b_jonas> but I guess even with perl6 it might turn out that there's a default implementatoin in the future

[18:52] <PerlJam> b_jonas: rakudo!  :)

[18:52] <moritz_> there are about 2 to 5 implementations, depending on what you count, and in various degrees of usefulness

[18:52] <b_jonas> like there is with ruby and python even though it has other implementations

[18:52] <b_jonas> or even java

[18:52] <b_jonas> or haskell 

[18:52] <PerlJam> moritz_: 5? which are you counting there ... rakudo, pugs, elf, kp6, .. ?  nqp?

[18:52] <TimToady> the xyz() syntax is always a function call, regardless of keyword status; c.f.  if() to call the interface function

[18:53] <TimToady> really &

[18:53] <moritz_> PerlJam: yap6

[18:53] <pmichaud> okay.

[18:53] <moritz_> PerlJam: not really far, but being actively worked on

[18:53] <moritz_> (as opposed to pugs)

[18:53] <pmichaud> ( xyz() syntax... duh, I think I knew that already.  )

[18:53] <Auzon> Or maybe smop?

[18:53] <pmurias> moritz: and kp6

[18:53] <pmichaud> ( guess I zoned out for a bit )

[18:54] <pmurias> Auzon: smop is not a perl6 implementation

[18:54] <Auzon> Hm. Makes sense.

[18:54] <[particle]> don't forget SMOP!

[18:54] <moritz_> pmurias: PerlJam already mentioned that ;)

[18:54] <[particle]> ah, hadn't gotten to auzon's comment yet

[18:54] <pmurias> moritz_: i meant it's not actively worked on

[18:55] <[particle]> pmurias: it is actively worked on again

[18:55] <[particle]> ruoso just got a grant from tpf

[18:55] <moritz_> pmurias: yes, but I haven't given up hope for kp6 completely

[18:55] <[particle]> oh, oops i'm getting crossed conversations

[18:55] <[particle]> don't mind me

[18:55] <pmurias> [particle]: the grant is mostly for smop

[18:59] <pmurias> [particle]: would the grant count if elf was used instead of kp6?

[19:00] <[particle]> i don't remember the specifics of his application

[19:01] *** thestarslookdown joined
[19:01] <rakudo_svn> r28107 | pmichaud++ | [rakudo]:

[19:01] <rakudo_svn> r28107 | pmichaud++ | * 'make coretest' now runs tests in t/00-parrot, t/01-sanity

[19:01] <rakudo_svn> r28107 | pmichaud++ | * 'make codetest' runs Parrot's coding standards tests

[19:01] <rakudo_svn> r28107 | pmichaud++ | * 'make test'     runs coretest and codetest

[19:01] <rakudo_svn> r28107 | pmichaud++ | * 'make fulltest' runs coretest, spectest_regression, and codetest

[19:01] <rakudo_svn> r28108 | pmichaud++ | [rakudo]:

[19:02] <rakudo_svn> r28108 | pmichaud++ | * Fix properties, trailing spaces, c file coda on src/pmc/mutablevar.pmc

[19:02] <pmurias> [particle]: ruoso mentioned kp6 repeatedly

[19:03] <PerlJam> http://news.perlfoundation.org/2008/05/2008q2_grant_proposal_smop_sim.html

[19:03] <lambdabot> Title: 2008Q2 Grant Proposal - SMOP: Simple Meta Object Programming - The Perl Foundati ..., http://tinyurl.com/5u94mu

[19:03] <PerlJam> go forth and read

[19:03] <moritz_> how is Forth related to reading? and to smop? ;-)

[19:08] <rakudo_svn> r28110 | pmichaud++ | [rakudo]:

[19:08] <rakudo_svn> r28110 | pmichaud++ | * Fix properties on perl6/t/pmc/mutablevar.t (moritz++)

[19:10] *** ron joined
[19:14] <diakopter> for anyone who's interested, here's an example of the current yap6 grammar syntax:  rule comma { ',' };  rule blkBare { w("{}",stmtList) };

[19:21] *** chris2 joined
[19:23] <pmurias> PerlJam: i read the grant proposal, was wandering what degree of strictness is applied to the grant completion interpretation

[19:25] *** dominiko joined
[19:26] <moritz_> pmurias: I think that if there's consensus that an elf backend would make more sense, the grant comitte could be convinced to accept the change

[19:27] <pmurias> diakopter: use still don't use strict ;)

[19:28] *** ruoso joined
[19:30] <rakudo_svn> r28112 | particle++ | [rakudo] improve some error messages, and improve maintainability a bit

[19:31] <pmurias> diakopter: why do you use w instead of concatenate('{',stmtList,'}') ?

[19:31] <diakopter> pmurias: oh, I haven't checked it in yet.

[19:31] <diakopter> that's what w does

[19:31] <diakopter> b/c it's shorter

[19:36] <pugs_svnbot> r20670 | diakopter++ | [yap6]

[19:36] <pugs_svnbot> r20670 | diakopter++ | Augmented the source filter so that rule syntax is much

[19:36] <pugs_svnbot> r20670 | diakopter++ | more abbreviated.  Still working on fixing the syntax

[19:36] <pugs_svnbot> r20670 | diakopter++ | error reporting.

[19:43] <ruoso> pmurias, the grant is oriented to SMOP roadmap... so if the RODMAP changes, I think it's natural for the grant to change...

[19:47] <pmurias> that's convenient ;)

[19:49] <rakudo_svn> r28114 | jonathan++ | [rakudo] Implement VAR($x) and .VAR macros.

[19:50] *** cjfields joined
[19:52] <diakopter> pmurias: it's also no warnings qw{ reserved closure recursion }; :D

[19:58] <rakudo_svn> r28115 | jonathan++ | [rakudo] Make readonly return false when not set - scalars are normally rw - and implement rw defined in terms of ro.

[19:58] <[particle]> what happened to the svnbot diff links?

[19:59] <moritz_> did rakudo_svn ever have any?

[19:59] * moritz_ just relies on the links in the irc logs

[20:06] <pugs_svnbot> r20671 | diakopter++ | [yap6]

[20:06] <pugs_svnbot> r20671 | diakopter++ | Removed arithmetic evaluation; it was getting in the way

[20:06] <pugs_svnbot> r20671 | diakopter++ | of enabling successful parses.  the remaining syntax

[20:06] <pugs_svnbot> r20671 | diakopter++ | features in STD.pm are next..

[20:07] <diakopter> where, by remaining, I mean the vast majority of the total to implement.

[20:08] <rakudo_svn> r28116 | jonathan++ | [rakudo] Make VAR and .VAR just give what was given to them, unless it's a scalar, per S12.

[20:08] <moritz_> ;)

[20:12] *** cjfields_ joined
[20:12] *** cjfields left
[20:17] *** alanhaggai left
[20:20] *** thestarslookdown left
[20:27] <pmurias> ls

[20:27] <Auzon> No such file or directory.

[20:27] <pmurias> sorry, muscle memory ;)

[20:31] *** cjfields_ is now known as cjfields

[20:31] *** dduncan joined
[20:31] <diakopter> moritz_: I made a change to evalbot.pl; would you kick it

[20:32] <moritz_> diakopter: just a sec

[20:33] *** exp_evalbot left
[20:33] <diakopter> evalbot could have a "suicide" command so it can be restarted from IRC :D

[20:33] *** exp_evalbot joined
[20:33] <moritz_> actually that's not a bad idea

[20:33] *** cjfields left
[20:33] <diakopter> 15:30:18 < moritz_> actually that's not a bad idea

[20:33] <diakopter> oops

[20:34] <moritz_> perl6: say "still works"

[20:34] <exp_evalbot> kp6 r20671: OUTPUT[still works␤]

[20:34] <exp_evalbot> ..pugs: OUTPUT[still works␤]

[20:34] <exp_evalbot> ..rakudo r28117: OUTPUT[still works␤]

[20:34] <exp_evalbot> ..elf r20671: OUTPUT[still works␤]

[20:34] <diakopter> yap6: say(3,my $bar = sub { my $closure = say(4); { die "5"; }  },$bar())

[20:34] <exp_evalbot> OUTPUT[  Syntax Error near: "say"]

[20:35] <diakopter> yap6: say (3;my $bar = sub { my $closure = say(4); { say "5"; } })

[20:35] <exp_evalbot> OUTPUT[  Syntax Error near: "say"]

[20:36] <diakopter> yap6: say ( 3; my $bar = sub { my $closure = say(4); })

[20:36] <exp_evalbot> OUTPUT[  Syntax Error near: "say"]

[20:36] <diakopter> yap6: say ( 3; my $bar = sub { my $closure = say ( 4 ); })

[20:36] <exp_evalbot> OUTPUT[  Syntax Error near: "say"]

[20:36] <diakopter> yap6: say ( 3; my $bar = sub { my $closure; })

[20:36] <exp_evalbot> OUTPUT[  Syntax Error near: "say"]

[20:37] <diakopter> argh; I thought I was privmsg evalbot; sorry folks

[20:40] <pmurias> TimToady: ping

[20:40] *** Chillance joined
[20:52] *** dominiko left
[20:54] *** japhb left
[21:01] <pmichaud> moritz++  # fixing my messups on p6c

[21:02] <Auzon> perl6: say atan(1,1) / 3.14 * 180;

[21:02] <exp_evalbot> kp6 r20671: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824c0dc)', 'APPLY', 'HASH(0x8e5237c)', 'HASH(0x8e52424)') called at

[21:02] <exp_evalbot> ..compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤        main::DISPATCH('HASH(0x824c0dc)', 'APPLY', 'H...

[21:02] <exp_evalbot> ..pugs: OUTPUT[45.022824653356906␤]

[21:02] <exp_evalbot> ..rakudo r28117: OUTPUT[too many arguments passed (2) - 1 params expected␤current instr.: 'atan' pc 9143 (src/gen_builtins.pir:6295)␤

[21:02] <exp_evalbot> ..elf r20671: OUTPUT[Undefined subroutine &GLOBAL::atan called at (eval 14) line 3.␤ at ./elf_f_faster line 4492␤]

[21:03] *** pmurias left
[21:04] <Auzon> pugs: sub test{.say for @_} test(<hello world>)

[21:04] <exp_evalbot> OUTPUT[hello␤world␤]

[21:05] <Auzon> pugs: say ord(﻿'␤')

[21:05] <exp_evalbot> OUTPUT[*** ␤    Unexpected "\65279'\9252')"␤    expecting ":", identifier or ")"␤    at /tmp/LbQdi7Ybs8 line 1, column 9␤]

[21:05] <Auzon> pugs: say ord('␤')

[21:05] <exp_evalbot> OUTPUT[9252␤]

[21:07] <pmichaud> Auzon: S29 doesn't have an 'atan' ?

[21:07] <Auzon> "where func is one of: sin, cos, tan, asin, acos, atan, sec, cosec, cotan, asec, acosec, acotan, sinh, cosh, tanh, asinh, acosh, atanh, sech, cosech, cotanh, asech, acosech, acotanh."

[21:07] <moritz_> Auzon: don't rely on evalbot's UTF8 handling, it's mostly b0rked

[21:07] <rakudo_svn> r28118 | jonathan++ | [rakudo] Make us able to use role names as type constraints again. We may have to revisit whether we want to register a Role proto at some point in the future; this gets things fixed for now.

[21:07] <pmichaud> Auzon: I don't see that statement in S29

[21:08] <pmichaud> is it somewhere else?

[21:08] * Auzon acks

[21:08] <Auzon> 371:sin, cos, tan, asin, acos, atan, sec, cosec, cotan, asec, acosec,

[21:08] <Auzon> in Pugs/blib/lib/Perl6/Spec/Functions.pod

[21:09] <pmichaud> okay, got it.  Thanks.

[21:09] <pmichaud> Don't know why my search didn't uncover it before.

[21:09] <Auzon> No problem.

[21:09] <Auzon> It appears that the test mistakenly puts atan instead of atan2 in some cases

[21:14] <Auzon> I assume that we're keeping atan2 instead of having a 2-arg form of atan to handle the atan2 functionality, right?

[21:17] <moritz_> Functions.pod

[21:17] <moritz_> 393:=item atan2

[21:17] <pmichaud> I can't tell for sure what's intend.  I'm guessing that the "where func is one of: ..., atan, ..."  might have intended to use atan2 instead

[21:17] <moritz_> ack (or grep) is your friend ;)

[21:17] <pmichaud> since atan2 isn't in that list.

[21:17] <moritz_> pmichaud: it's an extra item in S29

[21:18] <pmichaud> oh, okay. 

[21:18] <pmichaud> so we have both atan and atan2

[21:18] <pmichaud> atan takes one argument like sin, cos, tan, asin, etc.

[21:18] *** cjfields joined
[21:18] <moritz_> I think I asked that once already

[21:19] <moritz_> atan2 has a default value for its second argument

[21:19] <moritz_> so atan($x) isn't always the same as atan2($x)

[21:19] <Auzon> Oh. OK

[21:19] <Auzon> I missed that :)

[21:19] <moritz_> Auzon: that was more than a year ago

[21:19] *** TJCRI left
[21:19] <Auzon> I meant that difference in the spec

[21:20] <moritz_> (I don't know if my memory is correct, though)

[21:20] <pmichaud> but is there a 2-argument form of C<atan>   as in atan(1, 1)   ?

[21:20] <pmichaud> (where the 2nd argument isn't supposed to be $base)

[21:21] *** japhb joined
[21:21] <Auzon> Not that I can see, pmichaud

[21:22] <moritz_> http://irclog.perlgeek.de/perl6/2007-02-06#i_-54243

[21:22] <lambdabot> Title: IRC log for #perl6, 2007-02-06

[21:23] <moritz_> < TimToady> atan2 is still atan2

[21:23] <pmichaud> excellent.

[21:24] <Auzon> I'll fix up those tests and add some more for the one-arg version of atan2().

[21:25] <rakudo_svn> r28119 | pmichaud++ | [rakudo]:

[21:25] <rakudo_svn> r28119 | pmichaud++ | * Bring the grammar a bit closer to STD.pm by using <.eat_terminator>

[21:25] *** dduncan left
[21:34] *** kaether_ joined
[21:34] <meppl> good night

[21:35] <moritz_> good night meppl

[21:35] <meppl> ;)

[21:35] <pugs_svnbot> r20672 | moritz++ | [evalbot] two control features

[21:35] *** rdice left
[21:36] *** exp_evalbot left
[21:36] *** exp_evalbot joined
[21:36] <moritz_> evalbot control version

[21:36] <exp_evalbot> This is evalbot revision 20672

[21:37] *** meppl left
[21:37] *** kaether left
[21:38] <pugs_svnbot> r20673 | moritz++ | [evalbot] hoepfully fixed "Wide character in print" warning

[21:38] <moritz_> evalbot control restart

[21:38] *** exp_evalbot left
[21:38] *** kaether_ is now known as kaether

[21:39] *** exp_evalbot joined
[21:39] <pugs_svnbot> r20674 | moritz++ | [evalbot] fixed previous commit

[21:39] <moritz_> evalbot control version

[21:39] <exp_evalbot> This is evalbot revision 20674

[21:43] *** sscaffidi left
[21:44] <rakudo_svn> r28120 | jonathan++ | [rakudo] We should only initialize scalars with protoobjects; if it has a type that is a role or a constraint, it's just a Failure object.

[21:51] *** Limbic_Region joined
[21:55] *** jferrero joined
[21:57] <pugs_svnbot> r20675 | Auzon++ | [gsoc_spectest] Fixed tests for atan2, and added single argument tests for atan2. (2 tests added, 12 changed)

[22:01] *** iblechbot left
[22:02] <moritz_> Auzon: I think calling is_approx like this: is_approx(($first, $second), $msg) is illegal

[22:02] <moritz_> Auzon: many of the test still use that

[22:03] * Auzon looks at Test.pm

[22:03] *** cjfields left
[22:03] <moritz_> because ($first, $second) is actually a list, that tries to bind to a single item in the signature

[22:04] <moritz_> sub is_approx(Num $got, Num $expected, Str $desc?, :$todo, :$depends) returns Bool is export {

[22:04] <moritz_> in pugs

[22:04] <moritz_> multi sub is_approx($got, $expected, $desc) in parrot

[22:06] <rakudo_svn> r28122 | jonathan++ | [rakudo] Tidy up use of isa thanks to adding isa as a known pirop in PCT.

[22:08] <moritz_> actually I think I'm responsible for some of these screw-ups

[22:08] <pmichaud> I blame moritz_ .  :-)

[22:08] <moritz_> pmichaud: moritz, not moritz_ ;-)

[22:09] <pmichaud> I just tab-completed your nick.  :-)

[22:09] <pmichaud> besides, I'll credit "moritz" and blame "moritz_" and you'll be much better off.

[22:09] <moritz_> lol

[22:10] <pmichaud> when I was actively teaching courses, at the end of the semester we had "faculty evaluations" by the students.  (more)

[22:10] <pmichaud> These were always done on scantron forms, where the student would bubble in things on a 1-5 scale.  (more)

[22:11] <rakudo_svn> r28124 | particle++ | [rakudo] improve eval_lives_ok and eval_dies_ok, courtesy of Ronald Schmidt <ronaldxs@software-path.com>

[22:11] <pmichaud> I would always tell the studens to use ink for bad review and pencil for good ones, because I knew that our scantron reader didn't process ink properly, and they just discarded any evaluations that the scanner couldn't read.

[22:11] *** jferrero left
[22:11] <moritz_> hehe, nice hack ;)

[22:12] <pugs_svnbot> r20676 | moritz++ | [spec] S29-num/log.t fixed some ivalid calls to is_approx.

[22:12] <pmichaud> (but then I would tell the students why ink and pencil made a difference, which pretty much invalidated it.)

[22:13] <pmichaud> besides, I never got bad reviews.  (Although this past year may have changed that.)

[22:15] <pugs_svnbot> r20677 | moritz++ | [spec] complex.t: invalid uses of is_approx()

[22:18] <pugs_svnbot> r20678 | moritz++ | [spec] two more files cleared of illegal usage if is_approx()

[22:18] <Auzon> Did you get the one I just committed?

[22:19] <moritz_> Auzon: the trig.t?

[22:19] <Auzon> Yes

[22:19] <moritz_> no

[22:19] <moritz_> I just looked in S29-num

[22:19] <moritz_> but I can do that too

[22:23] *** IllvilJa left
[22:23] <pugs_svnbot> r20679 | moritz++ | [spec] S29-trig/trig.t fixed illegal calls to is_approx

[22:24] <Auzon> oh. I was going to get it. But I wasn't fast enough ;)

[22:24] <moritz_> sorry, didn't mean to get in your way

[22:24] <Auzon> No, it's OK, I was away

[22:25] <moritz_> is pi() exported by default?

[22:25] <moritz_> trig.t tests for it without importing it first

[22:26] *** cjfields joined
[22:26] <[particle]> iirc yes

[22:26] <[particle]> s29 i think?

[22:26] *** cjfields left
[22:26] <moritz_> Num provides a number of constants in addition to the basic mathematical functions. To get these constants, you must request them:

[22:26] <moritz_> use Num :constants;

[22:27] <moritz_> or use the full name, e.g. Num::pi.

[22:27] <[particle]> ok, that has changed

[22:27] *** cjfields joined
[22:27] <moritz_> just found it

[22:27] <b_jonas> what? 

[22:27] * moritz_ goes to bed, too tired for useful hacking

[22:27] <b_jonas> is there even an S that specifies _that_?

[22:27] * b_jonas checks out S29

[22:27] *** cjfields_ joined
[22:28] <b_jonas> ah, it's S29 indeed

[22:28] <Auzon> see you, moritz_. I won't be around much if at all tomorrow

[22:28] <moritz_> ok, bye

[22:28] <[particle]> pmichaud: should we stick things like pi in src/classes/Num.pir?

[22:29] *** chris2 left
[22:31] *** b_jonas left
[22:36] *** cjfields_ left
[22:38] *** cjfields_ joined
[22:38] *** cjfields_ left
[22:39] *** cjfields left
[22:39] <pmichaud> pasteling: there's already a 'pi' in src/builtins/math.pir

[22:39] <pmichaud> but yes, if it's part of Num, it should go in Num.pir

[22:39] <pmichaud> and then it can be !EXPORT

[22:41] *** eternaleye left
[22:43] *** IllvilJa joined
[22:45] *** eternaleye joined
[22:51] *** peepsalot left
[23:06] *** eternaleye left
[23:06] <[particle]> right

[23:06] <[particle]> i'd like to mark it 'is export' but i haven't put that in yet

[23:11] * diakopter hears the tornado sirens. [OT]

[23:42] *** xinming joined
[23:44] *** luqui joined
[23:51] *** bacek joined
[23:58] *** xinming_ left
