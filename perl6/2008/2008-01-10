[00:07] *** __pao__ left
[00:22] *** silug joined
[00:39] *** thoughtpolice left
[00:40] *** jferrero left
[00:40] *** silug left
[00:49] *** thoughtpolice joined
[00:55] *** nipotaway is now known as nipotan

[01:13] *** cnhackTNT joined
[01:15] <meppuru> good night

[01:20] *** meppuru left
[01:23] *** lyokato_ joined
[01:24] *** dalek left
[01:24] *** devogon left
[01:26] *** jhorwitz left
[01:26] *** dalek joined
[01:26] <Tene> [particle]: looking at dopplr... interesting...

[01:29] *** araujo joined
[01:49] <japhb> doc/ops:  This is your brain over easy with a side of hashbrowns ...

[01:59] *** jjore left
[02:06] <mncharity> it looks like perl5rx is a plugin for rx only, rather than being an alternative to the perl5 backend.

[02:09] *** pbuetow left
[02:10] *** pbuetow joined
[02:15] *** turrepurre left
[02:27] *** drbean_ joined
[02:32] *** drbean left
[02:34] *** drbean_ left
[02:34] *** drbean joined
[02:49] <pugs_svn> r19401 | rhr++ | [Unicode.pm] canonical composition

[02:56] *** drbean_ joined
[03:12] *** drbean left
[03:13] *** felipe left
[03:17] *** kanru left
[03:21] *** arxc joined
[03:27] *** jjore joined
[03:36] *** arxc_ left
[03:39] *** overdrive joined
[03:39] *** thoughtpolice left
[03:41] *** buubot left
[03:42] *** buubot joined
[03:43] *** buubot left
[03:44] *** buubot joined
[03:47] *** cognominal_ left
[03:51] *** alc joined
[03:59] *** felipe joined
[04:24] *** fridim_ joined
[04:25] *** overdrive left
[05:06] *** mncharity left
[05:22] *** Limbic_Region left
[05:36] *** matisse_enzer joined
[05:45] <matisse_enzer> Hi folks - I recently set up a buildbot  (see http://buildbot.eigenstate.net:8040/) to poll the perl6 SVN repo and build parrot when changes are committed, and I'm wondering if anyone here s a committer and could commit some trivial change to https://svn.perl.org/parrot/trunk and/or https://svn.perl.org/parrot/branches/pdd17pmc

[05:56] <TimToady> most of the parrot committers hang out on #parrot at irc.perl.org

[05:57] <TimToady> here are mostly pugs committers

[06:00] *** Andy_ joined
[06:01] <matisse_enzer> thanks - I will (and did) check #parrot - only two souls there :)

[06:01] <matisse_enzer> I will try again another time.

[06:02] *** meppuru joined
[06:02] <Auzon> Try #parrot on irc.perl.org

[06:02] <Auzon> That's where it's supposed to be

[06:02] <matisse_enzer> ahh, I forgot - someone told me that and  forgot. Thanks.

[06:02] <Auzon> No problem

[06:04] *** matisse_enzer left
[06:09] *** meppuru left
[06:23] *** Auzon left
[06:44] *** devogon joined
[07:00] *** Andy_ left
[07:57] *** Aankhen`` joined
[08:12] *** iblechbot joined
[08:16] *** asprillia joined
[08:31] *** fridim_ left
[08:34] *** jferrero joined
[08:47] *** asprillia left
[08:49] *** asprillia joined
[09:03] *** njbartlett_ left
[09:31] *** jferrero left
[09:38] *** jferrero joined
[09:41] *** Alias_ left
[09:42] *** jferrero left
[09:53] *** jferrero joined
[09:54] *** IllvilJa left
[09:59] *** jjore left
[10:01] *** alc left
[10:02] *** jisom joined
[10:04] *** arxc_ joined
[10:04] *** njbartlett_ joined
[10:15] <ruoso> @tell mncharity re why yap6 instead of per5v6: One of the more important performance killers in kp6 is the fact that it builds a heavy runtime in top of the perl5 runtime which is not lightweight also. YAP6 tries to implement a Perl 6 compatible runtime directly in C, so no overhead is needed. The idea is that yap6 can implement directly all the semantics of Perl 6

[10:15] <lambdabot> Consider it noted.

[10:17] <ruoso> TimToady, I've been thinking, and I realised that bare $obj.HOW(); returning a proxy object is not a good idea. Because sometimes you need to use the metaclass in its own context, considering its a generic one

[10:17] <ruoso> and in the proxy case, I can never get the metaclass object as it really is

[10:18] <ruoso> I mean, $obj.^can() puts $obj as the invocant,

[10:18] <ruoso> it makes sense to be able to call my $a = $obj.HOW(); $a.foo(); where the invocant for foo is the generic metaclass

[10:19] <ruoso> so perhaps it is a better idea to force the invocant declaration when using HOW instead of ^ to represent object-related metacalls

[10:19] <ruoso> like 

[10:19] *** arxc left
[10:20] <ruoso> $obj.^methods(); should be the same as $obj.HOW.methods($obj: );

[10:20] <ruoso> because, if the metaclass is an object by itself also, It may have other methods...

[10:22] <ruoso> for instance, if the metaclas is also the responder interface (in nothingmuch's terms)

[10:22] <ruoso> which is the case in YAP6

[10:23] *** iblechbot left
[10:24] *** ebassi joined
[10:24] *** drrho joined
[10:29] *** jferrero left
[10:31] *** masak joined
[10:38] *** njbartlett_ left
[10:40] *** njbartlett_ joined
[10:45] <nothingmuch> ruoso++ # i feel appreciated =)

[10:45] *** njbartlett_ left
[10:46] <ruoso> nothingmuch, btw... did you take a look in yap6?

[10:46] <ruoso> I would really appreciate your review in the design I'm implementing...

[10:47] <ruoso> the NOTES_* files and the include/*.h files are already related to this latest revamp

[10:48] <nothingmuch> i'll have a look when I finish my crazy work load

[10:48] <nothingmuch> if I don't respond by like monday or something feel free to /msg or email or something and bitchslap me about it =)

[10:48] <ruoso> nothingmuch, noprob... I'm still working in the .h files

[10:49] <ruoso> and I'll probably not finish it until the weekend anyway

[10:49] <ruoso> and I'll only get to the C code itself, when I finish the public .h files (the ones in include)

[10:49] <nothingmuch> if you wanna braindump a short spiel on how it's not like $something_else_i_should_know_about that might take less time

[10:50] <ruoso> Well, the braindump is the NOTES_BOOTSTRAP.txt file

[10:50] <ruoso> it's a quite short note

[10:50] <ruoso> http://svn.pugscode.org/pugs/v6/yap6/NOTES_BOOTSTRAP.txt

[10:50] <ruoso> in the case you don't have it checked out

[10:51] <nothingmuch> ah, ok

[10:51] <nothingmuch> i'll read that now

[10:51] <nothingmuch> i have it checked out (pugs) but I haven't ran svk up -s in like... months. maybe years =P

[10:51] <ruoso> heh

[10:52] <nothingmuch> so this is like an OO VM in C?

[10:52] <ruoso> btw, where you see dispatcher, you should read prototype

[10:52] <ruoso> nothingmuch, yes

[10:52] <ruoso> not quite VM

[10:52] <ruoso> but runtime library

[10:52] <ruoso> actually

[10:52] <ruoso> after I started to play with the stack

[10:52] <ruoso> I should call it vm anyway

[10:52] <nothingmuch> read up on scheme -> C

[10:52] <nothingmuch> there are many many interesting things those guys did

[10:53] <ruoso> ok, I'll search for it

[10:53] <nothingmuch> those lambda heads are smart cookies

[10:53] <ruoso> any special url?

[10:53] <nothingmuch> i'll find something specific for you in a sec

[10:55] <nothingmuch> fwiw, metaclass should be polymorphic

[10:56] <nothingmuch> and it should almost always be completely masked by a responder interface

[10:56] <nothingmuch> which in turn can be a very simple vtable of c funcs and a pointer to some data

[10:56] <nothingmuch> much like perl's mg structure, but without the linked list stuff

[10:56] <ruoso> http://svn.pugscode.org/pugs/v6/yap6/include/yap6_base.h

[10:57] <ruoso> I kinda mixed the metaclass and the responder interface

[10:57] <ruoso> the metaclass is the reponder interface in YAP6

[10:57] <nothingmuch> how come?

[10:58] <ruoso> when I get to the C level,

[10:58] <ruoso> the MetaClass is a special kind of object

[10:58] <nothingmuch> let me rephrase

[10:58] <ruoso> that also have a struct member named MESSAGE

[10:58] <ruoso> which handles the request

[10:59] <nothingmuch> it's essentially an RI

[10:59] <nothingmuch> MESSAGE == dispatch

[10:59] <ruoso> yep, but it also plays the role of the metaclass

[10:59] <ruoso> in the Perl 6 land

[10:59] <nothingmuch> that's an abstract object of it's own though

[10:59] <nothingmuch> with it's own responder interface

[10:59] <ruoso> sure

[10:59] <ruoso> which may be itself

[11:00] <ruoso> I mean

[11:00] <ruoso> some metaclass can be the responder interface for itself

[11:00] <nothingmuch> well, i don't see the difference, except that you renamed RI to metaclass ;-)

[11:00] <ruoso> heh

[11:00] <nothingmuch> oh, of course

[11:00] <nothingmuch> but the instance slot is different

[11:00] <ruoso> in theory the metaclass is the RI and the Object Layout at the same time

[11:01] <nothingmuch> how is that possible?

[11:01] <ruoso> it knows how the objects it handles are laid out

[11:01] <ruoso> in the C level

[11:01] <nothingmuch> unless you are making prototype based derived metaclass instances

[11:01] <ruoso> it's kinda recursive, yes

[11:02] <nothingmuch> object layout should be encapsulated in a low level constructor method, there is no need for the VM opcode dispatcher guy to ever know anything about that

[11:02] <nothingmuch> (void *)

[11:02] <ruoso> nothingmuch, yes... that's why it's delegated to the metaclass

[11:02] <nothingmuch> errm, again, all of this is defined as the responder interface stuff =)

[11:02] <nothingmuch> the metaclass is simply what is boiled down to the responder interface

[11:03] <nothingmuch> it's an object that knows how to make responder interface objects

[11:03] <nothingmuch> there are a few core responder interface types

[11:03] <nothingmuch> that can be used to implement other, more arbitrary responder interfaces

[11:04] *** cnhackTNT left
[11:04] <nothingmuch> by telling your compiler what C code to generate for a specific RI you can, of course, extend these "core" types for performance

[11:04] <nothingmuch> but a metaclass object should have nothing to do with runtime (except for reflection)

[11:04] <nothingmuch> unless it just so happens to be conveinent, but that's on a case-by-case implementation detail

[11:04] <ruoso> hmmm

[11:04] <nothingmuch> i don't see the practical benefit of joining these two types

[11:04] * ruoso trying to parse that

[11:05] <nothingmuch> a little more exemplifying:

[11:05] <nothingmuch> a core responder interface is the flat, by name method table

[11:05] <nothingmuch> there are C functions for a hash or a trie or something

[11:05] <nothingmuch> that maintain pointers to the code objects of the class this is implementing

[11:05] <ruoso> ok...

[11:06] <nothingmuch> the dispatch method (also written in C) will search by name, and then open a new stack frame and goto the code object

[11:06] <nothingmuch> I'll use perl5 terms to illustrate for clarity

[11:06] <ruoso> that's what I plan to do for the native types

[11:06] <ruoso> for instance

[11:06] <nothingmuch> so basically it's a table of CVs indexed by name

[11:06] <nothingmuch> and the responder interface table has a pointer to the C function ri_named_method_table_dispatch ( SV* invocant, SV* invocation );

[11:07] <nothingmuch> that returns the thunk object

[11:07] <nothingmuch> which the interpreter can evaluate

[11:07] <ruoso> yes, that's what I'm doing for the native and lowlevel types

[11:07] <nothingmuch> anyway, in the event that you want to implement a custom responder interface

[11:07] <nothingmuch> then that responder interface is an object

[11:07] <nothingmuch> whose responder interface is this low level type

[11:08] <ruoso> yes... ok... so my metaclass is the RI

[11:08] <nothingmuch> (Fwiw there can be a number of low level RIs, like indexed vtables which don't use strings at all, or ones that use a more dynamic structure, for example)

[11:08] <nothingmuch> the metaclass is a highlevel object

[11:08] <nothingmuch> that is instantiated by the compiler

[11:08] <ruoso> I mean, the metaclass in yap6_base.h

[11:08] <nothingmuch> the syntax of the class is converted into method calls on this metaclass

[11:09] <nothingmuch> and when it's time to dump everthing to disk the metaclass creates any number of responder interfaces, and saves them in the current compilation unit, 

[11:09] <ruoso> what I did was that the responder interface type is *also* a high-level object

[11:09] <nothingmuch> the compiler will dumb down the known "core" responder interfaces

[11:09] <nothingmuch> yes, of course it is =)

[11:09] <nothingmuch> that is, if the metaclass created a MethodTable->new( methods => { %methods } ) responder interfaces

[11:09] <nothingmuch> the compler will know how to take apart the abstract responder interface

[11:09] <nothingmuch> and dumb it down into it's low level C counterpart

[11:10] <nothingmuch> that's how the bootstrapping was designed to happen in MO

[11:10] <nothingmuch> there is a registry of known responder interfaces

[11:10] <nothingmuch> and routines to dumb them do

[11:10] <nothingmuch> wn

[11:10] <nothingmuch> that are intimately involved with the VM

[11:10] <ruoso> well... in fact...

[11:10] <ruoso> YAP6 metaclass *is* MO responder interface

[11:10] <nothingmuch> but responder interface from perl 6's pov are impelmentation independant, they are jsut datatype conventions

[11:10] <nothingmuch> OK, so that's what I thought =)

[11:10] <ruoso> :)

[11:11] <ruoso> ok... but now looking to the Perl 6 level

[11:11] <ruoso> $obj.^methods() is a call to the responder interface, right?

[11:11] <nothingmuch> right, so from the perl 6 level, the compiler also knows how to proxy methods back into perl space

[11:11] <nothingmuch> the mapping from the abstract MethodTable object to the low level C object is bidi

[11:12] <nothingmuch> (prolly the core types are readonly to simplify this, and the original object is just cached as well)

[11:12] <ruoso> exactly... the Stack type for instance (yap6_stack.h) defines itself as closed and final

[11:12] <ruoso> so it can have a custom RI that handles it in the C level

[11:13] <nothingmuch> right

[11:13] <nothingmuch> it appears to me like you have it nailed

[11:13] <ruoso> :) good to hear that from you ;)

[11:13] <nothingmuch> the whole poitn of MO was that language support entails implementing a very simple set of responder interfaces

[11:13] *** polettix left
[11:13] <nothingmuch> please make this easily addable to perl5  too ;-)

[11:14] <ruoso> well.. I know that adding perl5 to this is easy

[11:14] <ruoso> the other way I'm not sure

[11:14] <nothingmuch> with all the optree rewriting we've been doing in moose land, if i can make a custom method dispatch delegate to this rI object in perl 5 maybe we can get "real" OO

[11:14] <nothingmuch> what do you mean by the other way?

[11:14] <ruoso> I can get a SV YAP6 metaclass

[11:14] <ruoso> but I'm not sure how I could get a YAP6 ri inside perl5

[11:15] <nothingmuch> ah

[11:15] <nothingmuch> as long as Object can encapsulate an SV *

[11:15] <nothingmuch> then that should be enough

[11:15] <nothingmuch> lemme dig something up

[11:15] <nothingmuch> http://use.perl.org/~jjore/journal/34643

[11:15] <lambdabot> Title: Journal of jjore (6662)

[11:16] <nothingmuch> using josh's trickery you can replace the method call opcode's implementation for specific objects

[11:16] <ruoso> cool

[11:16] <nothingmuch> and make it delegate to an RI instead of use perl's builtin mechanism

[11:16] <nothingmuch> granted, we only get one type of Invocation object (by name, with a list of args)

[11:16] <nothingmuch> but that's still pretty cool

[11:16] *** arxc_ left
[11:16] <nothingmuch> the opcode would call sdispatch

[11:16] <nothingmuch> and the thunk type would be just a CV *

[11:17] <ruoso> That is *REALLY* cool

[11:17] <nothingmuch> since we can assume things about the invocation

[11:17] <nothingmuch> which means native MO for perl 5

[11:17] <nothingmuch> without having to use AUTOLOAD

[11:17] <nothingmuch> for custom RIs

[11:17] <ruoso> and transparent integration between libyap6 and libperl5

[11:17] <nothingmuch> *nod*

[11:17] <ruoso> in both ways

[11:17] <nothingmuch> bidi is just a matter of wrapping SV's in the perl5-native responder interface

[11:18] <nothingmuch> which delegates back to the original method call code in perl

[11:18] * ruoso very happy to see the pieces getting together

[11:18] <nothingmuch> =)

[11:19] <nothingmuch> so one nit: for clarity consider renaming MetaClass to ResponderInterface ;-)

[11:20] <ruoso> Ok...

[11:20] <nothingmuch> oh

[11:20] <nothingmuch> one more thing

[11:20] <nothingmuch> in the core please make sure that you can cheat certain objects out of their box

[11:20] <nothingmuch> that is, it should be trivial to autobox an INT type lazily

[11:20] <nothingmuch> pointing to a global, shared responder interface

[11:20] <ruoso> This is something I'm trying to figure out 

[11:21] <ruoso> in yap6_native.h

[11:21] <nothingmuch> this requires static analysis

[11:21] <nothingmuch> where you compile different variants

[11:21] <nothingmuch> so that no type info has to be carried around anymore

[11:21] <ruoso> I'm considering having a "native" method in the responder interface (a high-level method, I mean)

[11:21] <nothingmuch> what do you mean?

[11:22] <ruoso> well...

[11:22] <ruoso> Perl 6 defines that native types are closed and final

[11:22] <ruoso> and that their representation can't be changed

[11:22] <nothingmuch> yeah

[11:22] <ruoso> so, I can know that if it's a native int, I can use a low-level C structure that I defined for it

[11:23] <nothingmuch> exactly

[11:23] <ruoso> but the thing is,

[11:23] <nothingmuch> this is much simpler than it sounds from what you have to do

[11:23] <ruoso> but

[11:23] <nothingmuch> it's the compiler writers problem

[11:23] <ruoso> Int means anything that does Int

[11:23] <nothingmuch> just make it easy to skip the Object type

[11:23] <nothingmuch> you're forgetting that the compiler is allowed to cheat =)

[11:24] <nothingmuch> when it knows that ref($x) eq Int, nto that $x->isa("Int"), then it can do that

[11:24] <ruoso> that's why I'm planning a "native" method that must return the YAP6 native type

[11:24] <nothingmuch> it has two RIs that pretend to be the same RI

[11:24] <ruoso> yes... sure... but that's optimization

[11:24] <nothingmuch> the compiler just has to make sure that instead of doing obj->responder_interface->dispatch( obj ) it does native_responder_interfaces[type]->dispatch(  obj );

[11:25] <nothingmuch> err

[11:25] <ruoso> I mean

[11:25] <nothingmuch> instead of obj in the last one it should be low level int

[11:25] <ruoso> yes yes..

[11:26] <ruoso> if I can know, in the C level, that this object is handled by a known responder interface

[11:26] <ruoso> I can cheat

[11:26] <ruoso> but what I mean, is that the design must allow the responder interface to be something you don't know

[11:27] <ruoso> that's why I'm saying it's optimization... 

[11:27] <nothingmuch> erm, no, it's simpler =)

[11:27] <nothingmuch> just make sure the C typing is such that you can push around void *

[11:27] <nothingmuch> again, it's the compiler writer's problem to codegen the right code

[11:27] <ruoso> yes yes...

[11:28] <ruoso> YAP6 design today is loosely typed

[11:28] <nothingmuch> for example, imagine the function sum { $^x + $^y }

[11:28] <nothingmuch> that would codegen to an optree

[11:28] <nothingmuch> with an inlined method call optree

[11:28] <nothingmuch> that points to a function with an alt type

[11:29] <nothingmuch> there is an easy way to reason about this not needing to be complicated

[11:29] *** Alias_ joined
[11:29] <nothingmuch> like, for example, if your Int type is infinite

[11:29] <nothingmuch> you can still codegen a naive, native int using version

[11:29] <nothingmuch> do you know the psyco project?

[11:30] <ruoso> psyco? I don't think so

[11:30] <nothingmuch> the basic idea is that you have mmd based type specialization

[11:30] <nothingmuch> for clarity i'll use hs type notation

[11:30] <nothingmuch> factorial :: Int -> Int -> Int

[11:30] <nothingmuch> Factorial int -> Int -> Int

[11:30] <nothingmuch> factorial int -> int -> Int

[11:30] <nothingmuch> factorial Int -> int -> Int

[11:30] <nothingmuch> factorial int -> int -> int

[11:30] <nothingmuch> ad nauseum

[11:30] <nothingmuch> the "root" factorial is a multimethod that jumps to these variations

[11:31] <nothingmuch> which are compiled lazily based on the arguments

[11:31] <ruoso> ah yeah... sure...

[11:31] <nothingmuch> if the types in the call site are statically known at the time of the call

[11:31] <nothingmuch> then the specialized version can be used instead

[11:31] <nothingmuch> so Int -> Int -> Int is a slow, OO based version

[11:31] <nothingmuch> wheras int -> int -> int is just the native C impl f a factoriaal function with the native int type

[11:32] <nothingmuch> it will be used when the return value type cannot handle the overflow anyway

[11:32] <ruoso> considering every Perl 6 op is mmd

[11:32] <ruoso> this is a mandatory design requirement

[11:32] <nothingmuch> any factorial function that returns an Int must check for overflows, too

[11:32] <ruoso> I'm already with my eye on it...

[11:32] <nothingmuch> and might eventually point to Int -> Int -> Int

[11:33] <ruoso> I still didn't actually plan how the mmd will work...

[11:33] <ruoso> but I think it fits in the RI

[11:33] <nothingmuch> anyway, it hink this is the best optimization approach for inlining/etc

[11:33] <nothingmuch> that's TBD

[11:33] <nothingmuch> the core RIs don't even need to support RI in yap6

[11:33] <ruoso> TBD?

[11:33] <nothingmuch> to be decided

[11:33] <ruoso> ah

[11:33] <nothingmuch> MO's core inspiration was that new cool stuff was invented every week

[11:33] <nothingmuch> if we design semantics for MMD

[11:33] <nothingmuch> and in 5 years they turn out to be problematic

[11:33] <nothingmuch> it's trivial to natively support a new type very cleanly

[11:34] <nothingmuch> and 'use 6.1' will enable that by default, lexically

[11:34] <nothingmuch> the Invocation and the ResponderInterface just have to agree amongst themselves

[11:35] <nothingmuch> ditto for what I dubbed "concepts" in MO -- roles, class features, etc

[11:35] <nothingmuch> did you look at how AGs were done?

[11:35] *** nipotan is now known as nipotaway

[11:35] <nothingmuch> there's no hack level at all, except for optimization's sake

[11:35] <ruoso> for now, every responsability is let to the RI in YAP6

[11:36] <ruoso> I think MMD will be also RI responsability

[11:36] <nothingmuch> exactly =)

[11:36] *** nipotaway is now known as nipotan

[11:36] <ruoso> AG?

[11:36] <nothingmuch> since the method call is a higher order object (or at least there's the possibility of that), you can extend

[11:36] <nothingmuch> attribute grammars

[11:36] <ruoso> ah... 

[11:36] <nothingmuch> http://nothingmuch.woobling.org/browse_code?r=MO;a=headblob;f=/t/ag.t

[11:36] <lambdabot> Title: darcs - MO, http://tinyurl.com/225b69

[11:37] *** pbuetow left
[11:37] <nothingmuch> this doesn't have to know anything about the runtime to Just Work, it's the other benefit of the two staged approach

[11:37] <nothingmuch> the same AttributeGrammar metaclass (or meta role or whatever) can be mixed in to your metaclasses

[11:37] <nothingmuch> the same implementation that is

[11:38] <nothingmuch> and it'll work regardless of the VM

[11:38] <nothingmuch> if you're dilligent enough to support AGs natively in the VM it can be faster

[11:38] <nothingmuch> but that is totally optional

[11:39] * ruoso parsing...

[11:40] <nothingmuch> bottom line: the less you define in the VM core (eg. libyap6) the more extensible it is

[11:40] <nothingmuch> that was the point i was trying to illustrate

[11:41] *** nipotan is now known as nipotaway

[11:41] <ruoso> well..

[11:41] <nothingmuch> MO::Run is all about finding the minimum usable prototype meta OO system thingy that is:

[11:41] <ruoso> besides the native types

[11:41] <nothingmuch> a. extensible

[11:41] <nothingmuch> b. possibly fast

[11:41] <ruoso> everything is design by contract

[11:41] <ruoso> and I don't even have declared C types for that

[11:41] <ruoso> that will be implementation specific

[11:42] <ruoso> and that's why I'm focusing in the public/*.h files

[11:42] <nothingmuch> *nod*

[11:42] <nothingmuch> i think you have it in the right direction

[11:42] <ruoso> if you take a look in includes/yap6_stack.h

[11:42] <nothingmuch> just note that $responder_interface->dispatch doesn't actually dispatch

[11:42] <nothingmuch> it returns a thunk object

[11:42] <nothingmuch> that can be evaluated or not

[11:43] <nothingmuch> this is important because it makes a generic ->can much easier to implement

[11:43] <nothingmuch> in retrospect I should have made the thunk not close over the invocation, but instead get it as an argument

[11:43] <nothingmuch> that would make it easier to do in C too

[11:43] <nothingmuch> but it's a minor change

[11:43] <ruoso> I was thinking about that in the way to here today...

[11:43] <nothingmuch> one sec

[11:43] <nothingmuch> let me svk up 

[11:44] <ruoso> if there will be a $ri->call or a $ri->resolve->call

[11:44] <nothingmuch> $ri->dispatch($object, $invocation)->($object, $invocation) # conceptually

[11:44] <nothingmuch> it doesn't really matter how

[11:44] <nothingmuch> ->call or whatever

[11:45] <nothingmuch> in perl 5 terms, the method call operator will be kinda like $obj->can($method)->( $obj, @args) every single time

[11:46] <nothingmuch> if the thunk type is low level and known (e.g. it's a simple pointer to a CV) then the runtime can easily do interesting things with it

[11:46] <nothingmuch> without breaking responder interface encapsulation

[11:46] <ruoso> yehah..

[11:46] <ruoso> I think everything fits...

[11:46] <nothingmuch> if ( $thunk->is_static && $responder_interface->metaclass->is_clopsed_and_final_and_everything_is_fine ) { $self->inline_into_current_optree($thunk) }

[11:46] <ruoso> but please take a look at the include/*.h files

[11:47] <nothingmuch> svk up still running =)

[11:47] *** pbuetow joined
[11:47] <ruoso> :)

[11:47] <nothingmuch> i think that yap6 is a too perl 6 specific named for this, fwiw

[11:47] <nothingmuch> this is really much more general then that

[11:48] <ruoso> nothingmuch, well.. there's the stack thing

[11:48] <nothingmuch> reading right now

[11:48] <ruoso> that makes it more perl 6 specifc

[11:48] <nothingmuch> hmm

[11:48] <nothingmuch> that's not mandatory though

[11:48] <nothingmuch> it's just "a" stack, not "the" stack, right?

[11:49] <nothingmuch> this is a library for building OO virtual machines more than anything IMHO

[11:49] <ruoso> yes, although the Stack prototype is closed and final

[11:49] <ruoso> even if you can have several stacks

[11:50] <ruoso> they all must be of the same type

[11:50] <nothingmuch> huhmm

[11:50] <nothingmuch> interesting

[11:50] <ruoso> hmmm

[11:50] <ruoso> wait

[11:50] <nothingmuch> well, you don't have to use this particular stack at all, if it doesn't work for you

[11:50] <ruoso> in fact, no, they don't

[11:50] <nothingmuch> that's all I'm saying ;-)

[11:50] <ruoso> The stack is already a high-level type

[11:51] <ruoso> and as it's design by contract

[11:51] <nothingmuch> i like stack_eval's polymorphism

[11:51] <nothingmuch> it's in effect a polymorphic run loop

[11:51] <nothingmuch> you can plug in several virtual machines as long as they can eventually give back control at some point

[11:51] *** pbuetow left
[11:51] *** lyokato_ left
[11:52] <nothingmuch> and you can proxy values back and forth as long as the vms' respective object boxes are useful enough

[11:52] <ruoso> hmm... I didn't think about interfacing the perl 5 stack directly

[11:52] <ruoso> but it is possible

[11:52] <nothingmuch> (like, for instance, if they use yap6 ;-)

[11:52] <nothingmuch> no, nto that far

[11:52] <nothingmuch> i meant something less ambitious

[11:52] <nothingmuch> just have a stack nodes with heteroegenous opcodes

[11:53] <nothingmuch> though you could theoretically make the stack object a proxy that merges several other stacks or something

[11:53] <nothingmuch> too many details involved in this though

[11:53] <nothingmuch> to really know in advance

[11:54] <ruoso> it obviously depends on the embedding hability of the other vm

[11:54] <nothingmuch> yeah

[11:54] <ruoso> but it's possible by yap6 side

[11:54] *** pbuetow joined
[11:55] * ruoso needs a coffee, in despair

[11:57] * nothingmuch is on the phone to

[12:00] *** pmurias joined
[12:00] <pmurias> ruoso: what do you mean by a generic metaclass?

[12:00] <lambdabot> pmurias: You have 1 new message. '/msg lambdabot @messages' to read it.

[12:02] *** njbartlett_ joined
[12:03] *** jferrero joined
[12:07] <nothingmuch> ruoso: i have to work some

[12:07] <nothingmuch> it looks like a very good general direction

[12:07] *** pmurias left
[12:07] <nothingmuch> just recite a minimalism mantra in your head whenever you seem confused =)

[12:07] *** pmurias joined
[12:08] *** pmurias left
[12:08] *** pmurias joined
[12:12] <pmurias> @tell mncharity it should pararelise ok, you have to get used to mp6 (i.e. not make syntax errors as it's a slow compiler) and you can only bootstrap once you finish the backend

[12:12] <lambdabot> Consider it noted.

[12:12] *** jisom left
[12:14] *** IllvilJa joined
[12:17] *** masak left
[12:17] *** riffraff joined
[12:22] <ruoso> nothingmuch, I need to compose a mantra then... I'm getting confused too often

[12:22] <ruoso> :)

[12:22] <nothingmuch> "less is more" =)

[12:22] <ruoso> heh

[12:22] <nothingmuch> in OO especially

[12:22] <nothingmuch> the less you define the more polymorphism you get

[12:22] <nothingmuch> of course, you might eventually end up with nothing if you go too far ;-)

[12:23] <ruoso> hehe

[12:23] <moritz_> .oO( my OO system is undef )

[12:23] <ruoso> hehehehe

[12:24] *** masak joined
[12:24] <ruoso> pmurias, re generic metaclass: if a metaclass handles more than one class

[12:24] <pmurias> i thought $foo.HOW() is distinct for each class

[12:25] <ruoso> well, it is in the spec, but what I was saying is that it is not a good idea

[12:25] <ruoso> although in the call you enforce the proper context

[12:25] <ruoso> that's what $dog.^methods does

[12:25] <ruoso> it calls methods in the metaclass, but enforces $dog as the invocant

[12:25] <ruoso> as I was saying

[12:26] <ruoso> $dog.^methods should be the same as $dog.HOW.methods($dog: )

[12:26] <ruoso> and not juts $dog.HOW.methods()

[12:26] <nothingmuch> .HOW can appear to be distinct even if it really isn't using a simple ref

[12:26] <nothingmuch> i'm pretty sure that's the original intent

[12:26] <ruoso> yeah... but the problem

[12:26] <nothingmuch> "can be" != "always is"

[12:26] <ruoso> what can I do when I want to use the metaclass in its own context

[12:27] <nothingmuch> sometimes "always is" is really just "can be" with a little masquerading

[12:27] <ruoso> instead of some object class context

[12:27] <nothingmuch> expl?

[12:27] *** meppuru joined
[12:27] <nothingmuch> wait, no

[12:27] <nothingmuch> don't explain

[12:27] <ruoso> for instance...

[12:27] <nothingmuch> i have to work ;-)

[12:27] <ruoso> ok

[12:27] <ruoso> you can backlog later

[12:27] <nothingmuch> explain to pmurias ^_^

[12:27] <ruoso> I'll post it here

[12:27] * nothingmuch has a very very busy next few days ahead of him

[12:27] <nothingmuch> i doubt I will get to it

[12:27] <nothingmuch> but I can check on the results

[12:28] <nothingmuch> or /msg me if you have some conclusive link or reference

[12:28] <ruoso> everything is design by contract... so your metaclass may be something you know to do something more than the standard meta api

[12:28] <ruoso> if the metaclass is an object in itself...

[12:28] <ruoso> how do you call a method in the context of that object

[12:28] <ruoso> ?

[12:29] <ruoso> if $dog.HOW returns a proxy that keeps the reference to $dog, as to pass it as the invocant

[12:29] <pmurias> ruoso: in the context means?

[12:29] <pmurias> ruoso: i don't suggest $dog.HOW returns a proxy

[12:29] <ruoso> suppose $dog.HOW retuns an object that I know to have another method

[12:29] <pmurias> $dog.HOW.another_method

[12:30] *** py77 joined
[12:30] <ruoso> ok, now... consider the metaclass can be generic

[12:31] <ruoso> how can you do my $a = $dog.HOW;  $a.methods

[12:31] <ruoso> if $a don't have a reference to $dog

[12:31] <ruoso> $a.methods should be $a.methods($dog: )

[12:31] <ruoso> explicitly

[12:31] <ruoso> to implement it in the way it is in the spec, 

[12:31] <pmurias> ruoso: only if you have per object methods

[12:32] <ruoso> pmurias, per-prototype

[12:32] <ruoso> remember that $dog can be a prototype

[12:32] <pmurias> prototypes are undefined objects

[12:32] <ruoso> or class, if you name it that way

[12:32] <ruoso> no... a class is a prototype object

[12:32] <pmurias> ruoso: i view it diffrently

[12:33] * ruoso getting the piece of spec that states it

[12:35] <ruoso> take the beggining of the "class" section in s12

[12:36] <pmurias> ruoso: use line numbers please

[12:36] <ruoso> it's the first section

[12:36] <ruoso> I'm seeing it in the browser

[12:36] <ruoso> no line numbers (at least in my browser)

[12:37] <ruoso> the thing is,

[12:37] <ruoso> even if some mop uses a metaclass per class

[12:37] <ruoso> this doesn't means that every mop should do it

[12:38] <pmurias> the standard one uses a metaobject per class

[12:38] <ruoso> 'A "class" object is just considered an "empty" instance in Perl 6, more properly called a "prototype" object, or just "protoobject"."'

[12:39] <pmurias> The actual class object is the metaclass object pointed to by the

[12:39] <pmurias> C<HOW> syntax.

[12:39] <pmurias> ;)

[12:39] <ruoso> in a class-based mop

[12:40] <ruoso> but prototype-based mop is also supported

[12:40] <pmurias> than there is a diffrent HOW per object

[12:41] <pmurias> * different

[12:41] * pmurias always spell diffrent differently ;)

[12:42] *** jferrero left
[12:44] *** ebassi is now known as ebassi|lunch

[12:49] <ruoso> pmurias, "(For a prototype system (a non-class-based object system), all objects are merely managed by the same meta object.)" in s02

[12:50] <ruoso> in the definition of the HOW function

[12:51] *** cmarcelo joined
[12:55] <pmurias> ruoso: the metaclass should take object as a parameter than

[12:55] <pmurias> * metaobject

[12:58] <pmurias> why do you call the metaobject the metaclass

[12:58] <pmurias> ?

[12:59] <ruoso> I don't know... bad habits ;)

[12:59] <ruoso> I argue that the object (or prototype) is the invocant for the metacalls

[13:00] <ruoso> as $dog.^methods() is the same as $dog.HOW.methods($dog: )

[13:00] *** thoughtpolice joined
[13:00] <pmurias> you need to invocants then

[13:00] <pmurias> s/to/2/

[13:00] <ruoso> pmurias, not exactly

[13:00] <ruoso> what I have is a two phase dispatch

[13:00] <ruoso> I get the method from the $dog.HOW object,

[13:00] <ruoso> and execute it passing $dog as the invocant

[13:01] <pmurias> it's curring

[13:01] <ruoso> the thing is that all methods are already dispatched by the metaclass

[13:02] <ruoso> the metaclass doesn't need to be in the arguments

[13:02] <pmurias> * metaobject

[13:02] <ruoso> heh... yeah... metaobjecgt

[13:03] <ruoso> $dog.HOW.methods is really $dog.HOW.can("methods").call($dog: )

[13:03] <ruoso> while $dog.^methods is simpler...

[13:04] <ruoso> if I keep it that way, I can call things in the metaobject without the object's context

[13:04] <ruoso> like...

[13:04] <ruoso> my $a = $dog.HOW(); $a.foo; places $a as the invocant to foo

[13:05] <ruoso> and $a.methods() would probably return the same as $a.^methods()

[13:06] <pmurias> there are also bootstraped metaobjects

[13:06] <pmurias> got to work&

[13:06] *** pmurias left
[13:06] <ruoso> lunch&

[13:09] *** polettix joined
[13:27] *** ispy_ joined
[13:27] *** Patterner left
[13:28] *** chruck left
[13:35] *** Psyche^ joined
[13:35] *** Psyche^ is now known as Patterner

[13:36] *** polettix left
[13:47] *** thoughtpolice left
[13:51] *** drrho left
[13:54] *** njbartlett_ left
[13:55] *** drrho joined
[14:06] *** ebassi|lunch is now known as ebassi

[14:18] *** iblechbot joined
[14:20] *** braceta joined
[14:21] *** braceta left
[14:22] *** braceta joined
[14:22] *** pbuetow left
[14:22] *** pbuetow joined
[14:32] *** jhorwitz joined
[14:37] *** masak left
[14:37] *** masak joined
[14:46] *** alc joined
[15:09] *** ircuser joined
[15:10] <ircuser> Hi all, is there some perl6 book available?

[15:10] <Alias_> A couple, they might be out of date a bit though

[15:10] <moritz_> Perl6 and Parrot Essentials was open-sourced the other day

[15:10] <ircuser> Because the syntax change too much?

[15:11] <moritz_> not only syntax ;)

[15:11] <moritz_> well, depends on what you call "syntax", actually

[15:11] <moritz_> ircuser: what do you want that book for? Perl 6 design philosphy? or learning Perl 6?

[15:11] *** lorn joined
[15:12] <ircuser> moritz_ good question the 2th

[15:12] *** njbartlett_ joined
[15:12] <ircuser> but if perl6 need to be changed a lot i will wait for a "final book"

[15:12] <ruoso> HAH! Now I had an important breakthrough

[15:13] <ruoso> the problem I facing is that what I've been calling metaclass (which is actually the responder interface),

[15:13] <ruoso> is not the metaobject and not the prototype

[15:13] <ruoso> there's one of that methods missing, we need a WHO

[15:13] <ruoso> which returns the responder interface

[15:13] <moritz_> ircuser: even p5 doesn't have a "final book"

[15:14] <ruoso> and the responder interface is an object that is a C structure that is always binary compatible with a fundamental type

[15:15] <ruoso> That way I don't even need to have a prototype lowlovel structure

[15:16] <ruoso> the lowlevel C structure always have HOW member in the top of the struct

[15:17] <ircuser> moritz_ anyway i think we can use perl5 with the perl6 interpreter

[15:18] <moritz_> it's in the specs, yes

[15:19] *** chris2 joined
[15:24] <ruoso> I think I agree with nothingmuch that yap6 is not a Perl 6 runtime, but a generic OO runtime. 

[15:24] <ruoso> I think I'll rename it

[15:24] <ruoso> I thought on the name OZOO

[15:24] <nothingmuch> VROOM!!!!!!!!

[15:24] <ruoso> which stands for Object Zoo, or Oz Object Orientation

[15:25] <nothingmuch> ViRtual Object Oriented Machine

[15:25] <nothingmuch> ;-)

[15:25] <ruoso> heh

[15:25] <ruoso> btw... take a look in what I've just said before

[15:25] <nothingmuch> not right now... in an hour or so i might have some time

[15:25] <ruoso> ok

[15:26] <ruoso> VROOM++

[15:27] <pugs_svn> r19402 | ruoso++ | [yap6] last commit before rename

[15:27] *** rdice joined
[15:29] *** TJCRI joined
[15:29] <pugs_svn> r19403 | ruoso++ | [vroom] VROOM is the new name of YAP6 after realizing that it is not Perl 6 specific

[15:30] *** ircuser left
[15:32] <moritz_> should I rename some constructs from yap6 to vroom?

[15:32] <ruoso> moritz_, I'm starting doing that,

[15:32] <ruoso> if you want to take some files to hepl

[15:32] <ruoso> please...

[15:32] <ruoso> but wait

[15:32] * moritz_ pokes const.c

[15:33] <ruoso> moritz_, they are already not working

[15:33] <ruoso> so they are not that important

[15:33] <ruoso> because the structures were already different on them

[15:34] <ruoso> but you can express it in terms of VROOM__Object* already

[15:34] <ruoso> instead of YAP6__CORE__Value*

[15:34] <pugs_svn> r19404 | ruoso++ | [vroom] renamed include/*.h files

[15:35] * ruoso changing vroom_base.h

[15:37] <pugs_svn> r19405 | moritz++ | [vroom] src/: changed some file names, s/yap6/vroom/g

[15:44] *** TJCRI left
[15:44] *** TJCRI joined
[15:50] <pugs_svn> r19406 | ruoso++ | [vroom] include/vroom_base.h rewritten

[15:50] * ruoso taking vroom_stack.h

[15:53] <moritz_> In file included from const.c:3:

[15:53] <moritz_> ../include/vroom.h:4:24: error: vroom_base.h: No such file or directory

[15:54] <moritz_> but there is a ./include/vroom_base.h

[15:54] <moritz_> wtf?

[15:55] *** masak left
[15:57] <ruoso> moritz_, at this point, I don't expect anything to work...

[15:57] <ruoso> the C code is now based on yap6 before this revamping I'm doing

[15:57] <moritz_> ruoso: neither do I, but I just don't understand why the include file isn't found

[16:00] <pugs_svn> r19407 | ruoso++ | [vroom] include/vroom_stack.h rewritten

[16:00] * ruoso taking vroom_native.h

[16:00] * moritz_ yawns

[16:00] <moritz_> ETOLITTLEO2

[16:04] <pugs_svn> r19408 | ruoso++ | [vroom] include/vroom_native.h rewritten

[16:04] * ruoso taking vroom_builtin.h

[16:05] *** TJCRI left
[16:05] <pugs_svn> r19409 | ruoso++ | [vroom] include/vroom_builtin.h rewritten

[16:08] *** dmas1 joined
[16:09] *** rdice left
[16:09] *** lichtkind joined
[16:12] <pugs_svn> r19410 | ruoso++ | [vroom] some other renamings...

[16:16] <pugs_svn> r19411 | ruoso++ | [yap6] cleaning up yap6 dir, leaving a goodbye note.

[16:18] *** drrho left
[16:18] <pugs_svn> r19412 | ruoso++ | [vroom] VROOM_DISPATCH must receive a responder interface

[16:19] *** cognominal_ joined
[16:20] *** arxc joined
[16:22] *** drrho joined
[16:27] *** zamolxes left
[16:28] *** Psyche^ joined
[16:41] *** Patterner left
[16:41] *** Psyche^ is now known as Patterner

[16:45] <moritz_> ruoso: should vroom compile again?

[16:52] *** pmurias joined
[16:54] <pmurias> ruoso: WHO is already taken, not all implementations will use a responder interface (i suppose perl5v6 will use a perl5 class serving as a method cache)

[16:57] *** jhorwitz_ joined
[16:57] *** jhorwitz left
[16:58] *** jhorwitz_ is now known as jhorwitz

[17:04] *** asprillia left
[17:06] *** manfred joined
[17:09] *** rdice joined
[17:14] *** meppuru left
[17:19] *** barney joined
[17:23] *** aindilis left
[17:23] *** aindilis joined
[17:30] <ruoso> pmurias, ops... I overlooked that...

[17:30] <ruoso> i need another name

[17:33] <ruoso> moritz_, not yet... I need to port the code from YAP6__CORE__Value to VROOM__Object

[17:33] <ruoso> but it should be very simple

[17:36] <ruoso> moritz_, porting that is, actually, the first item in the ROADMAP

[17:36] <pugs_svn> r19413 | ruoso++ | [vroom] WHO was already taken, my bad overlooking that, pmurias++ for noticing. The Responder Interface is get with YAP6_RI instead, and the member is called RI

[17:36] <ruoso> oops...

[17:36] <ruoso> s/YAP6_RI/VROOM_RI/

[17:39] <pugs_svn> r19414 | ruoso++ | [vroom] one other s/yap6/vroom/

[17:44] <ruoso> named arguments are optional by default, right?

[17:45] <moritz_> I don't think so

[17:45] <moritz_> only when they have a default value

[17:46] <[particle]> named are optional by default in perl 6

[17:46] <[particle]> unnamed are required by default

[17:46] <ruoso> yep, i found it.... needs a sufix ! to make them required...

[17:46] <[particle]> yep

[17:46] * moritz_ rereads the spec

[17:46] <[particle]> ruoso: wanna see arg processing in nqp?

[17:47] <[particle]> ...or perl6 for that matter? it's a short routine to determine optional/named/slurpy/required

[17:47] <ruoso> is it implemented already?

[17:48] * ruoso wondre

[17:48] * ruoso wonders if that looks like a Signature ~~ Capture

[17:50] <TimToady> http://www.vroomsite.com/

[17:50] <lambdabot> Title: Vroom&reg; -The Web System for Business&trade; - Home

[17:51] <ruoso> TimToady, vroomcode.org seems free ;)

[17:53] <TimToady> I'm more worried about a trademark suit.

[17:55] <ruoso> well, we may argue that it's an reference to http://www.perlmonks.org/?node=vroom

[17:55] <lambdabot> Title: vroom

[17:55] <ruoso> ;)

[17:56] *** drrho left
[17:58] *** aindilis left
[17:58] *** alc left
[18:00] <ruoso> TimToady, btw... in the end I found my way out of the HOW/WHAT confusion... nothingmuch made me realise that what I was calling metaclass was really the responder interface... and not the prototype or metaobject...

[18:01] <ruoso> so HOW and WHAT can do whatever decided in the RI implementation

[18:01] <nothingmuch> it's supposed to be VROOM!!!!!!! not Vroom

[18:01] <ruoso> re suit: and I can always blame nothingmuch ;)

[18:02] <nothingmuch> aah no i have enough bureaucracy to deal with as it is, thank you very much

[18:02] <TimToady> if gaal were here he'd suggest ESOOM

[18:03] <ruoso> I thought about OZOO

[18:03] *** manfred left
[18:03] <ruoso> Object ZOO

[18:03] <ruoso> or Oz Object Orientation

[18:03] <ruoso> heh

[18:03] <TimToady> ZOOF sound like something going by fast

[18:03] <nothingmuch> libozoo has no hits on google

[18:03] <nothingmuch> neither does libzoof

[18:03] <allbery_b> zoof sounds to me lik someone got punched in the stomach

[18:03] <ruoso> hehe

[18:04] <[particle]> OZONE - developed by free software radicals

[18:04] <moritz_> rofl

[18:04] <moritz_> [particle]++

[18:04] <TimToady> You are entering... the O Zone...

[18:04] <ruoso> hehe

[18:04] <ruoso> OZONE++

[18:04] <ruoso> [particle], ++

[18:04] <TimToady> WHOOPS

[18:04] <ruoso> oops... bad completion

[18:05] <TimToady> SHROOM

[18:05] <TimToady> CROON

[18:05] <TimToady> SPOON

[18:05] <[particle]> swoon?

[18:06] <allbery_b> gubru?  "zooooon..."

[18:06] <TimToady> JOOS pronounced "juice"

[18:07] <ruoso> SOOM -> Stacked OO machine

[18:07] <ruoso> YAA -> Yet Another Animal

[18:07] <TimToady> barsoom

[18:08] <[particle]> gezundheit

[18:08] *** Auzon joined
[18:08] <moritz_> ;)

[18:08] <moritz_> s/z/s/ though

[18:08] <TimToady> barzoom

[18:08] <[particle]> we americans put 'z' everywhere you don't expect it :)

[18:08] <moritz_> I noticed, yes

[18:09] <allbery_b> zomg!

[18:09] <TimToady> TROO STROO THROO etc

[18:10] <[particle]> I HAD A OO BUT I EATED IT

[18:10] <TimToady> name it LOL and confuse #parrot

[18:10] <ruoso> hehe

[18:10] <[particle]> SHOOHORN

[18:11] <moritz_> but lolcode.org is already taken

[18:11] <ruoso> EOO

[18:11] <ruoso> Empty Object Orientation

[18:11] <[particle]> COOL

[18:11] <ruoso> Cool Object Orientation Library ?

[18:11] <[particle]> self-naming

[18:12] <moritz_> VOOT (Virtual OO Transmogrifier)

[18:12] <TimToady> KOOL is a possibility, if you don't mind the tobacco association

[18:13] <TimToady> doesn't seem to be any computery interference

[18:13] <TimToady> at least, not on wikipedia

[18:13] <[particle]> DROOL # plays well with Moose

[18:13] <TimToady> MOOSTANG

[18:14] <Auzon> TROOL

[18:14] <pbuetow> for what are you looking a name for?

[18:14] <ruoso> TROOL++

[18:14] <Auzon> Apparently with "OO"

[18:14] <TimToady> yap6

[18:14] <moritz_> for VROOM, formerly yap6

[18:14] <TimToady> KROOD

[18:14] <pbuetow> hm ok

[18:14] <Auzon> TRue Object Orientated Language?

[18:14] <TimToady> DOODZ

[18:15] <Auzon> Or maybe TOOL

[18:15] <TimToady> TOOTSY

[18:15] <ruoso> DOS -> Damaged Object System

[18:16] <TimToady> got ROOT?

[18:16] <ruoso> root would be cool

[18:16] <moritz_> but that's too hard to search for

[18:17] <moritz_> Results 1 - 10 of about 166,000,000 for root 

[18:17] <TimToady> skoot

[18:17] <Auzon> I like skoot

[18:18] *** pstuifzand joined
[18:18] <ruoso> PMOS -> Post-Modern Object System

[18:18] <moritz_> PMOS++

[18:19] <allbery_b> that sounds like something the folks downstairs from me (chip designers) would be playing with

[18:19] <ruoso> PMORE -> PostModern Object Runtime Environment

[18:19] *** Auzon left
[18:20] *** Auzon joined
[18:20] <Auzon> oops. wrong window.

[18:20] <[particle]> MIPE: Modularity, Inheritance, Polymorphism, Encapsulation

[18:20] <TimToady> pmoose

[18:21] <[particle]> poogs

[18:21] <ruoso> poogs++

[18:21] <ruoso> hehehe

[18:21] <Auzon> Muskox

[18:21] <lichtkind> TimToady: thanks for the answer

[18:21] <lichtkind> TimToady++

[18:22] <ruoso> postmodern moose?

[18:22] <lichtkind> TimToady: max is also list infix ?

[18:25] <ruoso> from all the options, I like most: OZONE, COOL, KOOL, and SPOON

[18:26] <Auzon> All common words, but not in combination with Perl. That's good.

[18:26] <ruoso> ozone is already taken

[18:27] <ruoso> spoon also, by a cpan module

[18:28] <ruoso> cool don't identify much

[18:29] <ruoso> kool is a cigarret brand

[18:29] *** ebassi left
[18:36] <ruoso> LisMOS <- "Less is More" Object System

[18:36] <moritz_> not bad

[18:45] *** DarkWolf84 joined
[18:47] <ruoso> MEEOW - MEta Object Orientation System

[18:48] <moritz_> where's the W?

[18:48] <ruoso> the cat ate

[18:48] <Auzon> Where's the second E?

[18:48] <[particle]> it doesn't *have* to be an acronym

[18:48] <Auzon> :P

[18:49] <ruoso> ok... let's find an acronym for MEEOW

[18:49] <ruoso> (having two E's make it easier to search for

[18:50] <[particle]> ooh! WOOF

[18:51] <[particle]> work-in-progress oo frobulator

[18:53] <[particle]> ROOBY

[18:53] <Auzon> hahah

[18:54] <Auzon> I dunno, some people may not like that

[18:54] <[particle]> NOOBIE

[18:55] <TimToady> lichtkind: max is just scalar infix

[18:55] <TimToady> btw, I don't the the multiple dispatch RI belongs in any of the argument objects

[18:56] <TimToady> it probably goes in the proto sub

[18:56] *** TechSkilled joined
[18:56] <TimToady> pugs went as far as to generate one if you didn't supply one

[18:56] <ruoso> NOOL

[18:56] <TimToady> s/the the/think the/

[18:56] <lichtkind> TimToady: so you write @array.max instead of [max] @array?

[18:57] <TimToady> whether there's a method on @array is independent of whether there's an operator

[18:57] <TimToady> but using infix we can say $biggest max= $current

[18:58] <TimToady> admittedly that's side effectful

[18:58] <TimToady> but we also get [max] @array

[18:58] <TimToady> I don't see any problem with also having @array.max

[18:59] <TimToady> so you could even write "max @array:"

[18:59] <TimToady> tmtowtdi

[19:00] <lichtkind> thanks

[19:00] <Auzon> ++

[19:02] <TimToady> smop

[19:03] <TimToady> though that's also been suggested as a name for parrot's perl6 impl

[19:03] <[particle]> LOON

[19:03] <moritz_> what happened to the name "Onion"?

[19:03] <ruoso> SMOP++

[19:03] <ruoso> http://en.wikipedia.org/wiki/Small_matter_of_programming

[19:03] <ruoso> the description fits perfectly

[19:04] <Auzon> Indeed. SMOP++

[19:04] <Auzon> @karma SMOP

[19:04] <lambdabot> SMOP has a karma of 2

[19:04] <Auzon> Heheh

[19:04] <[particle]> karma SMOP++

[19:04] <[particle]> @karma SMOP++

[19:04] <lambdabot> SMOP++ has a karma of 0

[19:04] <Auzon> :O

[19:05] <[particle]> heh

[19:05] <Auzon> Oh

[19:05] <Auzon> I getit

[19:05] <TimToady> Simple Meta Object Programming

[19:06] <ruoso> Simplistic ...

[19:06] <TimToady> Super ...

[19:06] <ruoso> but Small Matter Of Programming is also just fine

[19:06] <moritz_> small...

[19:06] <TimToady> is there an S word for extenSible?

[19:06] <araujo> Sensible

[19:06] <araujo> :-P

[19:06] <TimToady> Smart

[19:06] <Auzon> Supported?

[19:07] <ruoso> inSane

[19:07] <Auzon> Sufficient?

[19:07] <moritz_> superior!

[19:07] <araujo> Sensible Meta Object Programming

[19:07] *** drrho joined
[19:07] <araujo> :-P

[19:08] <TimToady> SMOP Meta Object Programming

[19:08] <araujo> :-D

[19:09] <ruoso> Ok... no more arguments... SMOP Rules

[19:10] <pugs_svn> r19415 | ruoso++ | [vroom] documenting the node methods... btw... this is the last commit as vroom

[19:11] <pugs_svn> r19416 | ruoso++ | [smop] hey... vroom is now smop

[19:12] <pugs_svn> r19417 | ruoso++ | [yap6] updating yap6 goodbye note.

[19:12] <TimToady> there's a smop.org, but it doesn't appear to be the name of computer code

[19:13] <ruoso> yeah.. seems like an outdated blog

[19:14] <ruoso> one thing I miss in regex is a feature of emacs search and replace...

[19:14] <ruoso> s/vroom/smop/g 

[19:14] <ruoso> but keep the original case

[19:16] <pugs_svn> r19418 | ruoso++ | [smop] renaming include/* files.

[19:18] <avar> ruoso: miss in what?

[19:19] <pugs_svn> r19419 | ruoso++ | [smop] s/vroom/smop/g(emacs ignore-but-keep-case-feature)

[19:19] <ruoso> consider you have "SMOP Smop smop" and you want to substitute by "BLOP Blop blop"

[19:19] <ruoso> if you just do s/smop/blop/gi

[19:19] <ruoso> you'll end with "blop blop blop"

[19:20] <ruoso> emacs search and replace is smart enough to keep the original case

[19:20] <moritz_> cool

[19:21] *** Southen joined
[19:23] <pugs_svn> r19420 | ruoso++ | perl -pi -e '[smop/src] s/VROOM/SMOP/g' *.c *.h ; perl -pi -e 's/vroom/smop/g' *.c *.h;

[19:26] <avar> FOO Foo FoO foo will also be BAR Bar Bar bar

[19:26] <avar> emacs++

[19:27] <ruoso> TimToady, do we still have a slot for a regex modifier?

[19:27] <ruoso> :)

[19:27] <moritz_> in p5 or p6?

[19:28] <ruoso> in p6...

[19:28] <moritz_> :smartcase

[19:29] <pasteling> "avar" at 208.78.101.240 pasted "emacss replace-match" (454 lines, 12.4K) at http://sial.org/pbot/29749

[19:29] *** drrho left
[19:29] <avar> it's called fixedcase in emacs

[19:30] <ruoso> :fixedcase makes sense

[19:31] <avar> (also C-h f replace-match RET

[19:34] <TimToady> might want to be something more like {lc ...}

[19:35] <TimToady> s:i/foo/{.samecase bar}/

[19:35] <TimToady> but if you have to have :i anyway...

[19:35] <ruoso> sure

[19:36] <TimToady> maybe s:same/foo/bar/ is just shorthand for that

[19:36] <TimToady> or whatever the switch turns out to be

[19:37] <[particle]> :sc # samecase

[19:37] <TimToady> unfortunately :s is taken

[19:37] <Auzon> :c ?

[19:38] <moritz_> is taken as well

[19:38] <TimToady> also taken

[19:38] <ruoso> :f?

[19:38] <Auzon> What would that stand for?

[19:38] <ruoso> fixed case

[19:38] <ruoso> as emacs calls

[19:38] <Auzon> ah..., fixed

[19:39] *** TechSkilled left
[19:39] <TimToady> or maybe :ii

[19:39] <moritz_> like :uglii

[19:39] <ruoso> hehehe

[19:40] <TimToady> :i2

[19:41] <ruoso> ii is funny because it looks like ignore the case in the both sides

[19:41] *** Southen_ left
[19:41] <TimToady> which, in a sense, it does

[19:41] <ruoso> yeah...

[19:41] <TimToady> I'll go with :ii for now

[19:42] *** jisom joined
[19:42] <[particle]> aye aye

[19:42] <TimToady> I wonder if there's something equivalent for :bb (basechar)

[19:42] <Auzon> @karma lambdabot

[19:42] <lambdabot> lambdabot has a karma of 53

[19:43] <ruoso> hmmm

[19:43] <ruoso> maybe

[19:43] <TimToady> s:bb/a/o/ changes ä to ö

[19:43] <ruoso>  s:bb/a/e/ would turn "á" into "é"

[19:44] <TimToady> it's a little dicier if the two strings are of unequal length

[19:44] <wolverian> I hope that only happens in locales where it makes sense :)

[19:44] <ruoso> well, the longest dictates the case

[19:45] <ruoso> unicode isn't locale dependant, is it?

[19:45] <TimToady> probably just limit it to same character position

[19:45] <TimToady> not unless you say "use Locale" or some such

[19:46] <TimToady> otherwise graphemes are considered language indepenent

[19:46] <Auzon> Is everything Unicode in Perl 6?

[19:46] <ruoso> Auzon, yep

[19:46] <wolverian> TimToady, ah, thanks.

[19:46] <Auzon> great :)

[19:46] <TimToady> well, you can have other types if you like

[19:46] <TimToady> but string types are distinguished from buffer types, and the string types are all unicode

[19:46] <wolverian> I'm having a hard time imagining where s:bb/a/o/ would make sense in an locale-independent way, _or_ locale-dependent! 

[19:46] <TimToady> the standard string types, that is

[19:47] <TimToady> well, it's just an interesting thought, doesn't have a huge use case

[19:47] <TimToady> no pun intended

[19:47] <wolverian> heh. true enough

[19:47] <TimToady> just noticed :basechar right under :ignorecase is all

[19:47] <TimToady> and realized they were similar

[19:48] <wolverian> I wouldn't have noticed it

[19:48] <wolverian> so, please keep noticing and ignore me 

[19:48] <pugs_svn> r19421 | ruoso++ | [smop] A small note on a important stack design issue: The node pushed is never evaluated by the interpreter loop, it should be used to pass information to the new frame.

[19:54] <avar> 1/w 26

[19:58] *** arxc left
[20:00] *** arxc joined
[20:02] <pugs_svn> r19422 | pmurias++ | points to the right directory

[20:03] <moritz_> TimToady++ # r14484

[20:03] <TimToady> ruoso++

[20:03] <moritz_> TimToady: what happens if a titlecase letter is substituted by a letter that doesn't have a titlecase equivalent?

[20:03] <moritz_> is it mapped to upper case?

[20:04] <TimToady> good Q

[20:04] <TimToady> hang on

[20:05] <TimToady> I guess the question I have is whether you want to substitute titlecase into the middle of a camelcase identifier

[20:06] <moritz_> that's not my question

[20:06] <moritz_> I think the greek letter sigma has three cases: upper case, lower case and title case

[20:06] <TimToady> I'm assuming that if there is a direct mapping, it works

[20:06] <TimToady> uh, no, you're confusing the ending sigma, which is different

[20:06] <moritz_> ok

[20:07] <TimToady> I think if there is a titlecase to titlecase mapping, or upper to upper, that is automatically used.

[20:07] *** pmurias left
[20:08] <TimToady> there are no titlecase without a corresponding upper

[20:08] <TimToady> (I don't think)

[20:08] <TimToady> so all that remains is if there is no corresponding titlecase, it goes to upper

[20:09] <TimToady> on the other hand, arguably it should choose titlecase or uppercase depending on whether there's a letter to the left of it in the result

[20:09] <TimToady> but camelcase might be wrong then

[20:10] <TimToady> if you're substituting in the middle of a longer identifier

[20:10] <TimToady> I don't think there's a right answer

[20:10] <moritz_> my $s = "ABc" ~~ s:bb/.../ßbc/; # is that SSBc? or SSbc?

[20:10] <TimToady> or rather, the right answer changes depending on whether you're doing computer programming or natural language processing

[20:11] <moritz_> I think it should be SSBc

[20:12] <moritz_> I don't think the problem shows up unless you process natural language

[20:12] <TimToady> my brane hurtz

[20:12] *** chris2 left
[20:12] <TimToady> if you're doing NLP then you've probably said "use Deutsch"

[20:12] <moritz_> ;)

[20:13] <TimToady> on the other hand, I don't think many other languages *care* what happens to ß :)

[20:13] <moritz_> aye

[20:13] <TimToady> so it's language independent in that sense

[20:14] <moritz_> are there other chars that produce multiple graphemes when lc'ing or uc'ing?

[20:14] <TimToady> dunno, could be

[20:15] <lichtkind> TimToady: does $a=(1,2,(a,b)); and  @a=(1,2,(a,b)); the same? (array ref to an flat array?)

[20:15] <lichtkind> use Deutsch;++

[20:15] <DarkWolf84> r there refs in p6

[20:15] <DarkWolf84> ?

[20:16] <moritz_> perhaps use lang::Deutsch;

[20:16] <lichtkind> of course

[20:16] <moritz_> DarkWolf84: there are captures

[20:16] <lichtkind> they are spelled captures

[20:16] <DarkWolf84> lake in grammar?

[20:16] <lichtkind> like a signature

[20:16] <TimToady> the @a= case puts the right side into list context, and parens are ignored in list context, so you get @a=1,2,a,b

[20:17] <TimToady> the $a= puts the right side into scalar context, but the commas make their own list context (I suspect), so you end up with $a = [1,2,a,b]

[20:17] *** jisom left
[20:19] <TimToady> note that $a=\(1,2,(a,b)) is a different matter, since those commas are in capture context

[20:19] <TimToady> are are the commas in foo(1,2,(a,b))

[20:20] <TimToady> in capture context the list/scalar distinction is lazy until binding time

[20:20] *** lorn left
[20:21] <lichtkind> makes sense

[20:21] <lichtkind> thank you vary much 

[20:21] <lichtkind> very :)

[20:24] *** buubot left
[20:25] *** buubot joined
[20:28] <spinclad> in finnish, 'ö' ~~ s:bb/o/u/ should arguably give 'y', since 'y' is their 'ü'

[20:29] <moritz_> outch

[20:29] <moritz_> all those language dependent cases are going to hurt

[20:30] <spinclad> but even in finnish, unicode has a 'ü'...

[20:31] <spinclad> er... 

[20:33] *** silug joined
[20:33] *** thoughtpolice joined
[20:39] <spinclad> all right, now i want an umlautable metalinguistic 'V', so i could say  'ieaou' ~~ s:g:bb/V/V\"/ => 'ieäöu'

[20:40] <moritz_> so \" is COMBINING DIARESIS?

[20:40] *** stephang joined
[20:40] <spinclad> *'ieäöy', dammit!

[20:41] <spinclad> moritz_: that's what i mean, even if i can't say it.

[20:41] <spinclad> \"V, even, TeXwise.

[20:44] <lichtkind> ju ich hab 20%

[20:47] *** TJCRI joined
[20:51] <moritz_> lichtkind: wrong channel ;)

[20:52] <lichtkind> moritz_: stimmt

[20:57] *** ispy_ left
[21:06] *** Aankhen`` left
[21:09] <TimToady> why not just <V>

[21:10] <spinclad> sure.  how do i do \"<V> on the rhs?

[21:12] <spinclad> s/<V>/\"($<V>)/

[21:12] <TimToady> $<V>\x[0308]/ presumably

[21:12] <spinclad> overfix:<">

[21:13] <spinclad> superfix, rather

[21:14] <spinclad> +front($<V>)

[21:14] *** braceta left
[21:14] <TimToady> or s/<V>/$<V>\c[COMBINING DIAERESIS]/

[21:15] <TimToady> assuming the right side is smart about recombining graphemes when it needs to

[21:16] <TimToady> otherwise might need a codepoint declaration around it

[21:18] <spinclad> i guess if i used the actual character in /$<V>\c[...]/, it would try to the '>', which would be Bad.

[21:19] <TimToady> indeed

[21:19] <spinclad> *try to apply to

[21:19] <TimToady> metacharacters have to good for something... :)

[21:20] <TimToady> s/to/to be/

[21:20] *** zamolxes joined
[21:22] *** JarJarBinks left
[21:25] <spinclad> (otoh, that would give 'ïëäöü', which is completely unfinnish, but then i shouldn't be trying to solve that at a unicode level.)

[21:29] *** rdice left
[21:32] *** barney left
[21:40] *** pstuifzand left
[21:47] *** jferrero joined
[21:49] *** iblechbot left
[21:56] *** meltingwax joined
[21:56] <meltingwax> i'm getting this error when i try to compile:     Could not find module `Data.Array':

[21:57] <meltingwax> it is a member of package array-0.1.0.0, which is hidden

[21:57] <moritz_> meltingwax: which version of ghc are you using?

[21:57] <moritz_> if you have >= 6.8, apply the patch pugs-ghc681.diff 

[21:57] <meltingwax> 6.8.2

[21:57] <meltingwax> ok

[21:59] <meltingwax> how do i do that :x

[21:59] <moritz_> I guess 'patch < pus-ghc681.diff'

[22:02] *** luqui joined
[22:02] *** jhorwitz left
[22:15] <meltingwax> moritz_: thanks

[22:16] <moritz_> meltingwax: so it works?

[22:16] <meltingwax> the patch did (when i added -p0)

[22:16] <meltingwax> its compiling now

[22:17] <meltingwax> Setup: error reading dist/setup-config; run "setup configure" command?

[22:17] <meltingwax> Build failed for '/usr/src/pugs/dist/build/libHSPugs-6.2.13.a': 256 at util/build_pugs.pl line 372.

[22:17] <meltingwax> make: *** [pugs] Error 2

[22:19] * moritz_ never saw that error

[22:19] <moritz_> did you run Makefile.PL after applying the patch?

[22:24] *** cmarcelo left
[22:25] *** jferrero left
[22:26] <meltingwax> yes

[22:30] * moritz_ has no idea what's wron

[22:30] <moritz_> g

[22:32] <moritz_> TimToady: if I query Str.bytes, which encoding is used to determine the byte size?

[22:33] *** jjore-w left
[22:34] *** jjore-w joined
[22:43] *** jferrero joined
[22:58] *** TJCRI left
[23:00] *** Alias_ left
[23:06] *** meltingwax left
[23:07] *** polettix joined
[23:18] *** charsbar_ joined
[23:19] *** charsbar left
[23:26] *** stephang left
[23:37] *** alester left
[23:45] *** zgh left
[23:48] *** polettix left
[23:49] *** riffraff left
