[00:00] *** aindilis left
[00:01] *** aindilis joined
[00:06] *** fridim_ joined
[00:08] *** rhizo_ is now known as rhizo

[00:16] *** araujo left
[00:20] *** Limbic_Region joined
[00:22] *** bsb joined
[00:27] *** justatheory joined
[00:36] *** justatheory left
[00:49] *** Auzon left
[00:59] *** fridim_ left
[01:05] *** braceta left
[01:05] *** braceta joined
[01:09] *** kanru left
[01:09] *** IRSeekBot left
[01:25] *** Ched- left
[01:26] *** Ched- joined
[01:26] *** Limbic_Region left
[01:28] *** aindilis left
[01:33] *** Auzon joined
[02:12] *** melg left
[02:14] *** bacek joined
[02:14] <bacek> hi there

[02:21] *** alexe joined
[02:24] *** bsb left
[02:38] *** bsb joined
[02:57] *** Alias_ left
[02:59] *** bacek left
[03:03] *** bacek joined
[03:04] *** bacek left
[03:04] *** bsb left
[03:10] *** eternaleye left
[03:11] *** penk joined
[03:31] *** bacek joined
[03:36] *** bacek left
[03:45] <Auzon> perl6: module Foo {sub test is export {say "hi"}}; test();

[03:45] <exp_evalbot> kp6: OUTPUT[<is> not implemented at compiled/perl5-kp6-mp6/lib/KindaPerl6/Grammar/Term.pm line 1818, <> line 1.␤]

[03:45] <exp_evalbot> ..pugs: OUTPUT[*** No such subroutine: "&test"␤    at /tmp/vlX40ZWhgR line 1, column 45-51␤]

[03:45] <exp_evalbot> ..rakudo: OUTPUT[Could not invoke non-existent sub test␤current instr.: '_block11' pc 21 (EVAL_11:15)␤called from Sub 'parrot;PCT::HLLCompiler;eval' pc 783 (src/PCT/HLLCompiler.pir:458)␤called from Sub 'parrot;PCT::HLLCompiler;evalfiles' pc 1065 (src/PCT/HLLCompiler.pir:587)␤called from Sub

[03:45] <exp_evalbot> ..'parrot;PCT::HLLCompiler;command_line' pc 1244 (src/PCT/HLLCompil...

[03:46] <exp_evalbot> ..elf: OUTPUT[Undefined subroutine &GLOBAL::test called at (eval 15) line 9.␤ at ./elf_f_faster line 4600␤]

[03:46] <Auzon> perl6: module Foo {sub test is export {say "hi"}}; use Foo; test();

[03:46] <exp_evalbot> kp6: OUTPUT[<is> not implemented at compiled/perl5-kp6-mp6/lib/KindaPerl6/Grammar/Term.pm line 1818, <> line 1.␤]

[03:46] <exp_evalbot> ..pugs: OUTPUT[pugs: *** Unsafe function 'use' called under safe mode␤    at /tmp/uU39c7WiZl line 1, column 1␤]

[03:46] <exp_evalbot> ..rakudo: OUTPUT[Error: file cannot be read: Foo.pm␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤called from Sub 'require' pc 7614 (src/gen_builtins.pir:5348)␤called from Sub 'use' pc 7580 (src/gen_builtins.pir:5329)␤called from Sub '_block11' pc 27

[03:46] <exp_evalbot> ..(EVAL_11:15)␤called from Sub 'parrot;PCT::HLLCompiler;eval' pc 783 ...

[03:46] <exp_evalbot> ..elf: OUTPUT[Cant locate Foo in ( . ).␤]

[04:17] *** eternaleye joined
[04:18] *** alexe left
[04:20] *** alexe_ joined
[04:20] *** alexe_ is now known as alexe

[05:01] *** aindilis joined
[05:11] *** bsb joined
[05:12] *** braceta left
[05:16] *** rindolf joined
[05:32] *** alanhaggai joined
[05:33] *** rhizo left
[05:35] *** alc joined
[05:37] *** alanhaggai left
[05:48] *** meppl joined
[05:48] <pugs_svnbot> r20537 | bacek++ | Add 'emit pop @pop' for rakudo for skipped test

[05:51] <pugs_svnbot> r20538 | bacek++ | Add skipping for rakudo

[05:55] *** schmalbe joined
[05:59] <vixey> what's the difference between elf_f and elf_f_faster?

[06:00] <vixey> is it only the stuff in EmitFasterP5?

[06:00] *** schmalbe left
[06:02] <Auzon> Yes. See elf_f_src/Elf.pm and elf_f_src/Elf_Faster.pm

[06:04] <vixey> why was elf_f_faster created?

[06:04] <Auzon> elf_f usually takes 3-5 seconds to do anything

[06:04] <Auzon> elf_f_faster takes .25s

[06:05] <Auzon> the faster variant is available in the evalbot here.

[06:05] <Auzon> elf: say "hi"

[06:05] <exp_evalbot> OUTPUT[hi␤]

[06:05] <vixey> so why are there two?

[06:05] <vixey> rather than just make elf_f faster

[06:05] <Auzon> since _faster is mostly the same, it can churn though the tests quicker

[06:05] <Auzon> It's not equivalent in all cases

[06:06] <Auzon> and _faster was made after the regular one. At the time, they didn't know how much faster it would be.

[06:06] <vixey> I see

[06:08] *** polettix joined
[06:08] <spinclad> and elf_f uses Moose, which may turn out to be a good object system to build on (being a good match to perl 6 semantics)

[06:09] <Auzon> right. The main change in the faster variant is the removal of Moose.

[06:10] *** polettix left
[06:17] *** IRSeekBot joined
[06:18] *** alanhaggai joined
[06:30] *** aindilis left
[06:56] *** polettix joined
[06:56] *** polettix left
[07:12] *** iblechbot joined
[07:16] *** luqui joined
[07:21] *** IllvilJa left
[07:29] *** alanhaggai left
[07:36] *** IllvilJa joined
[07:58] <vixey> perl6: my $x = 3; is $x, 3, '?'

[07:58] <exp_evalbot> kp6: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤   KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824be54)', 'APPLY', 'HASH(0x8e4df30)', 'HASH(0x8e524f8)', 'HASH(0x8e525dc)') called at

[07:58] <exp_evalbot> ..compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤     main::DISPATCH('HASH(0x824...

[07:58] <exp_evalbot> ..pugs: OUTPUT[*** No such subroutine: "&is"␤    at /tmp/CcDqwjKNJn line 1, column 12 - line 2, column 1␤]

[07:58] <exp_evalbot> ..rakudo: OUTPUT[Could not invoke non-existent sub is␤current instr.: '_block11' pc 57 (EVAL_11:28)␤called from Sub 'parrot;PCT::HLLCompiler;eval' pc 783 (src/PCT/HLLCompiler.pir:458)␤called from Sub 'parrot;PCT::HLLCompiler;evalfiles' pc 1065 (src/PCT/HLLCompiler.pir:587)␤called from Sub

[07:58] <exp_evalbot> ..'parrot;PCT::HLLCompiler;command_line' pc 1244 (src/PCT/HLLCompiler...

[07:58] <exp_evalbot> ..elf: OUTPUT[Undefined subroutine &GLOBAL::is called at (eval 15) line 4.␤ at ./elf_f_faster line 4600␤]

[07:59] <vixey> perl6: use Test; my $x = 3; is $x, 3, '?'

[07:59] <exp_evalbot> kp6: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤   KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824be4c)', 'APPLY', 'HASH(0x8e516d0)', 'HASH(0x8e57f18)', 'HASH(0x8e57ffc)') called at

[07:59] <exp_evalbot> ..compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤     main::DISPATCH('HASH(0x824...

[07:59] <exp_evalbot> ..pugs: OUTPUT[pugs: *** Unsafe function 'use' called under safe mode␤    at /tmp/fZntVt3Wel line 1, column 1␤]

[07:59] <exp_evalbot> ..rakudo: OUTPUT[Error: file cannot be read: Test.pm␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤called from Sub 'require' pc 7614 (src/gen_builtins.pir:5348)␤called from Sub 'use' pc 7580 (src/gen_builtins.pir:5329)␤called from Sub '_block11' pc 27

[07:59] *** alanhaggai joined
[07:59] <exp_evalbot> ..(EVAL_11:15)␤called from Sub 'parrot;PCT::HLLCompiler;eval' pc 783...

[07:59] <exp_evalbot> ..elf: OUTPUT[Cant locate Test in ( . ).␤]

[08:00] <moritz_> rakudo: 1

[08:01] <exp_evalbot> RESULT[1]

[08:02] <vixey> sub func( $a, $b, $c ) { $var }; seems fine

[08:02] <vixey> but in elf_f my sub func( $a, $b, $c ) { $var }; breaks

[08:04] <moritz_> elf: $x = 1; say $x;

[08:04] <exp_evalbot> OUTPUT[Global symbol "$x" requires explicit package name at (eval 14) line 3.␤Global symbol "$x" requires explicit package name at (eval 14) line 4.␤ at ./elf_f_faster line 4600␤]

[08:04] <moritz_> ah, elf is strict

[08:10] <vixey> elf: my sub foo {}

[08:10] <exp_evalbot> OUTPUT[Use of uninitialized value in concatenation (.) or string at ./elf_f_faster line 3458.␤Use of uninitialized value in concatenation (.) or string at ./elf_f_faster line 3458.␤Can't call method "sigil" on unblessed reference at ./elf_f_faster line 4037.␤]

[08:13] *** araujo joined
[08:13] <moritz_> vixey: if you don't produce output, the expression will be wrapped in ((do { ... }).perl).print (or something along these lines)

[08:14] <vixey> putting my before sub means that elf wont even compile it

[08:15] *** cosimo joined
[08:16] <vixey> (do{if((($n->var()->sigil() eq '@'))) {

[08:19] <vixey> perl6: my sub foo {}

[08:19] <exp_evalbot> kp6: RESULT[{ ... }]

[08:19] <exp_evalbot> ..pugs: RESULT[\sub :(@_) "$_" := "Scalar" #<Scalar:0xb71c881c>␤          "@_" := "Array" #<Array:0xb71c7494>␤          "&?ROUTINE" := "Sub" #<Sub:0xb6604cec>␤          "&?BLOCK" := "Sub" #<Sub:0xb6604cec> {"&foo" := "Sub" #<Sub:0xb712ee64>, "$_" := "Scalar" #<Scalar:0xb71d2d00>␤                   

[08:19] <exp_evalbot> ..                                                       ...

[08:19] <exp_evalbot> ..rakudo: OUTPUT[Lexically scoped subs not yet implemented. at line 1, near ""␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤called from Sub 'parrot;Perl6;Grammar;Actions;_block2332' pc 112036 (src/gen_actions.pir:5258)␤called from Sub

[08:19] <exp_evalbot> ..'parrot;Perl6;Grammar;Actions;_block2315' pc 111941 (src/gen_actions.pir:5220)␤c...

[08:19] <exp_evalbot> ..elf: OUTPUT[Use of uninitialized value in concatenation (.) or string at ./elf_f_faster line 3458.␤Use of uninitialized value in concatenation (.) or string at ./elf_f_faster line 3458.␤Can't call method "sigil" on unblessed reference at ./elf_f_faster line 4037.␤]

[08:25] *** alc left
[08:27] *** Lunchy left
[08:39] <vixey> ../elf_f -v -e 'my sub foo {}'

[08:39] <vixey> it prints out

[08:39] <vixey> CompUnit([VarDecl(my,undef,undef,undef,undef,undef,=,undef)],undef)

[08:39] <vixey> CompUnit(statements=>[VarDecl(scope=>'my',typenames=>undef,plurality=>undef,var=>undef,postcircumfix=>undef,traits=>undef,default_op=>'=',default_expr=>undef)],filename=>undef)

[08:40] <vixey> so I guess that the IRx1 nodes need to be added to, to get that parsed properly, is that true?

[08:43] *** pbuetow joined
[08:47] *** smtms left
[09:14] *** viklund joined
[09:26] *** alc joined
[09:30] *** chris2_ joined
[09:32] *** chris2_ is now known as chris2

[09:33] *** pbuetow left
[09:37] *** iblechbot left
[10:09] *** Lunchy joined
[10:11] *** alexe left
[10:35] *** alc left
[10:37] *** Chillance joined
[10:48] *** luqui left
[10:54] *** viklund left
[10:55] *** viklund joined
[11:12] *** ruoso joined
[11:22] *** penk left
[11:30] *** alanhaggai_ joined
[11:39] *** braceta joined
[11:43] *** braceta left
[11:44] *** alanhaggai left
[11:47] *** chris2 left
[11:52] *** iblechbot joined
[12:11] *** braceta joined
[12:17] *** alanhaggai_ left
[12:18] *** smtms joined
[12:25] *** FurnaceBoy joined
[12:33] *** pmurias joined
[12:34] <pmurias> vixey: if you install Perl::Tidy you'll have the output of -v with indentation

[12:36] <pmurias> making elf_f faster would require playing with Moose internals

[12:37] <bacek_> perl6: say +map { undef }, <1 3 5 7>;

[12:37] <exp_evalbot> kp6: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤   KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824be94)', 'APPLY', 'HASH(0x824be94)', 'HASH(0x8e565dc)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm

[12:37] <exp_evalbot> ..line 169␤        main::DISPATCH('HASH(0x824be94)', 'APPLY', 'H...

[12:37] <exp_evalbot> ..pugs: OUTPUT[4␤]

[12:37] <exp_evalbot> ..rakudo: OUTPUT[Could not invoke non-existent sub map␤current instr.: '_block11' pc 74 (EVAL_11:29)␤called from Sub 'parrot;PCT::HLLCompiler;eval' pc 783 (src/PCT/HLLCompiler.pir:458)␤called from Sub 'parrot;PCT::HLLCompiler;evalfiles' pc 1065 (src/PCT/HLLCompiler.pir:587)␤called from Sub

[12:37] <exp_evalbot> ..'parrot;PCT::HLLCompiler;command_line' pc 1244 (src/PCT/HLLCompile...

[12:37] <exp_evalbot> ..elf: OUTPUT[Undefined subroutine &GLOBAL::map called at (eval 14) line 3.␤ at ./elf_f_faster line 4600␤]

[12:37] <bacek_> perl6: say +map { () }, <1 3 5 7>;

[12:37] <exp_evalbot> kp6: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤   KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824becc)', 'APPLY', 'HASH(0x8e52470)', 'HASH(0x8e569c4)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm

[12:37] <exp_evalbot> ..line 169␤        main::DISPATCH('HASH(0x824becc)', 'APPLY', 'H...

[12:37] <exp_evalbot> ..pugs: OUTPUT[0␤]

[12:37] <exp_evalbot> ..rakudo: OUTPUT[Could not invoke non-existent sub map␤current instr.: '_block11' pc 74 (EVAL_11:29)␤called from Sub 'parrot;PCT::HLLCompiler;eval' pc 783 (src/PCT/HLLCompiler.pir:458)␤called from Sub 'parrot;PCT::HLLCompiler;evalfiles' pc 1065 (src/PCT/HLLCompiler.pir:587)␤called from Sub

[12:37] <exp_evalbot> ..'parrot;PCT::HLLCompiler;command_line' pc 1244 (src/PCT/HLLCompile...

[12:37] <exp_evalbot> ..elf: OUTPUT[Undefined subroutine &GLOBAL::map called at (eval 14) line 3.␤ at ./elf_f_faster line 4600␤]

[12:38] <bacek_> why it is '4' in first sample and '0' in second?

[12:38] <moritz_> bacek_: undef is one time

[12:39] <moritz_> s/time/item/

[12:39] <moritz_> bacek_: so the list you get is (undef, undef, undef, undef)

[12:39] <moritz_> which has four items

[12:39] <pmurias> pugs say+map { undef },<1 3 5 7>

[12:39] <pmurias> pugs: say map { undef },<1 3 5 7>

[12:39] <exp_evalbot> OUTPUT[␤]

[12:40] <pmurias> pugs: say [map { undef },<1 3 5 7>]

[12:40] <exp_evalbot> OUTPUT[   ␤]

[12:40] <pmurias> pugs: say (map { undef },<1 3 5 7>).join(';')

[12:40] <exp_evalbot> OUTPUT[;;;␤]

[12:41] <moritz_> pugs: say perl map { undef}, 1..4

[12:41] <exp_evalbot> OUTPUT[(undef, undef, undef, undef)␤]

[12:41] <bacek_> pugs: my @l = (1..2); say +@l; @l.push((),); say +@l;

[12:41] <exp_evalbot> OUTPUT[2␤2␤]

[12:41] *** araujo left
[12:41] <bacek_> rakudo: my @l = (1..2); say +@l; @l.push((),); say +@l;

[12:41] <exp_evalbot> OUTPUT[2␤2␤]

[12:43] <pmurias> () is an empty list not undef

[12:44] <bacek_> pmurias, rakudo generates .return() for {()}.

[12:45] <pmurias> and?

[12:46] <bacek_> pmurias, will it be 'caught' "unless defined res goto done" ?

[12:46] <pmurias> i'm not a parrot user/developer

[12:47] <pmurias> i can try to look at it but i don't know much about parrot/rakudo

[12:50] *** pbuetow joined
[12:51] <bacek_> pmurias, not nessary. I just try to find out correct behaviour for my map implementation.

[12:51] <pmurias> i guess the pugs one is correct

[12:52] <moritz_> indeed

[12:52] <pmurias> pugs: (1,3,5,7).map({$_,$_+1}).join(';')

[12:53] <exp_evalbot> RESULT["1;2;3;4;5;6;7;8"]

[12:53] <rindolf> pmurias: ah cool.

[12:53] <rindolf> pmurias: I blogged about something like that.

[12:54] <pmurias> url? ;)

[12:54] <rindolf> pmurias: trying to get use.perl.org

[12:55] *** FurnaceBoy left
[12:55] <rindolf> pmurias: http://209.85.129.104/search?q=cache:i9D0dcI37sUJ:use.perl.org/~Shlomi%2BFish/journal/36493+shlomi+fish+ruby+perl&hl=en&ct=clnk&cd=1&client=firefox-a

[12:55] <lambdabot> http://tinyurl.com/6lpxkg

[12:55] <bacek_> $ ../../parrot perl6.pbc 

[12:55] <bacek_> > say  (1,3,5,7).map({$_,$_+1}).join(';')

[12:55] <bacek_> 1 2;3 4;5 6;7 8

[12:55] <lambdabot>  Parse error at "{$_,$..." (column 20)

[12:55] <bacek_> hmm...

[12:56] <bacek_> why it 'flatten' in pugs? 

[12:57] <moritz_> bacek_: because it should, unless in slice context

[12:57] <moritz_> rindolf: %hash{@array} = (1) x @array; is the cleanest and shortest way in perl

[12:57] <moritz_> sorry, @hash{@array} = ...

[12:58] <moritz_> gotta go

[13:29] *** iblechbot left
[13:33] *** alanhaggai joined
[13:39] *** meppel-san joined
[13:51] *** rdice joined
[13:57] *** meppl left
[14:09] *** aindilis joined
[14:10] *** rindolf left
[14:28] *** cmarcelo joined
[15:01] *** alanhaggai left
[15:01] *** alanhaggai joined
[15:13] *** cjfields joined
[15:14] <cjfields> pugs: my $str = 'Foo'; my $str2 = $str.split('').join(''); say $str.chars; say $str2.chars;

[15:14] <exp_evalbot> OUTPUT[3␤3␤]

[15:14] <cjfields> rakudo: my $str = 'Foo'; my $str2 = $str.split('').join(''); say $str.chars; say $str2.chars;

[15:14] <exp_evalbot> OUTPUT[3␤Method 'chars' not found for invocant of class 'String'␤current instr.: '_block11' pc 121 (EVAL_10:43)␤

[15:15] <cjfields> perl6: my $str = 'Foo'; my $str2 = $str.split('').join(''); say $str.chars; say $str2.chars;

[15:15] <exp_evalbot> kp6: OUTPUT[syntax error at position 42, line 1 column 42:␤my $str = 'Foo'; my $str2 = $str.split('').join(''); say $str.chars; say $str2.chars␤                                          ^ HERE␤]

[15:15] <exp_evalbot> ..pugs: OUTPUT[3␤3␤]

[15:15] <exp_evalbot> ..rakudo: OUTPUT[3␤Method 'chars' not found for invocant of class 'String'␤current instr.: '_block11' pc 121 (EVAL_10:43)␤called from Sub 'parrot;PCT::HLLCompiler;eval' pc 783 (src/PCT/HLLCompiler.pir:458)␤called from Sub 'parrot;PCT::HLLCompiler;evalfiles' pc 1065

[15:15] <exp_evalbot> ..(src/PCT/HLLCompiler.pir:587)␤called from Sub 'parrot;PCT::HLLCompiler;command_line' pc 124...

[15:15] <exp_evalbot> ..elf: OUTPUT[Can't locate object method "chars" via package "Foo" (perhaps you forgot to load "Foo"?) at (eval 17) line 5.␤ at ./elf_f_faster line 4600␤]

[15:17] <cjfields> perl6: my $str = 'Foo'; my @chars = $str.split(''); my $str2 = @chars.join(''); say $str.chars; say $str2.chars;

[15:17] <exp_evalbot> kp6: OUTPUT[no method 'split' in Class 'Str'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤     KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x8e527d8)', 'split', 'HASH(0x8e52898)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤  

[15:17] <exp_evalbot> ..main::DISPATCH('HASH(0x8e527d8)', 'split', 'HASH(0x8e52898)') call...

[15:17] <exp_evalbot> ..pugs: OUTPUT[3␤3␤]

[15:17] <exp_evalbot> ..rakudo: OUTPUT[3␤Method 'chars' not found for invocant of class 'String'␤current instr.: '_block11' pc 136 (EVAL_10:50)␤called from Sub 'parrot;PCT::HLLCompiler;eval' pc 783 (src/PCT/HLLCompiler.pir:458)␤called from Sub 'parrot;PCT::HLLCompiler;evalfiles' pc 1065

[15:17] <exp_evalbot> ..(src/PCT/HLLCompiler.pir:587)␤called from Sub 'parrot;PCT::HLLCompiler;command_line' pc 124...

[15:17] <exp_evalbot> ..elf: OUTPUT[Can't locate object method "chars" via package "Foo" (perhaps you forgot to load "Foo"?) at (eval 17) line 6.␤ at ./elf_f_faster line 4600␤]

[15:18] *** cjfields left
[15:20] *** exp_evalbot left
[15:20] <pugs_svnbot> r20539 | moritz++ | [evalbot] filter rakudo's stack traces also in 'perl6:' mode

[15:20] *** exp_evalbot joined
[15:21] <moritz_> perl6: ()

[15:21] <exp_evalbot> kp6: RESULT[(  )]

[15:21] <exp_evalbot> ..pugs: RESULT[()]

[15:21] <exp_evalbot> ..rakudo: RESULT[Null PMC access in find_method()␤current instr.: '_block11' pc 38 (EVAL_11:18)␤

[15:21] <exp_evalbot> ..elf: RESULT[Undef.new(!!!)␤]

[15:26] *** Ingmar left
[15:28] *** elmex joined
[15:32] *** FurnaceBoy joined
[15:33] *** Psyche^ joined
[15:42] *** justatheory joined
[15:44] *** Patterner left
[15:44] *** Psyche^ is now known as Patterner

[15:51] *** justatheory left
[15:56] *** iblechbot joined
[16:01] *** alanhaggai left
[16:38] *** alanhaggai joined
[16:46] *** lisppaste3 left
[16:51] *** cmarcelo left
[16:56] *** Psyche^ joined
[16:58] *** ludan joined
[17:01] *** lisppaste3 joined
[17:05] *** ludan left
[17:07] *** Patterner left
[17:07] *** Psyche^ is now known as Patterner

[17:10] *** kanru joined
[17:31] *** meteorjay joined
[18:07] *** braceta_ joined
[18:07] *** armagad joined
[18:17] *** braceta__ joined
[18:18] <rakudo_svn> r27816 | pmichaud++ | [rakudo]:

[18:18] <rakudo_svn> r27816 | pmichaud++ | * Fix codingstds and metadata on rakudo files.

[18:18] *** ruoso left
[18:19] <rakudo_svn> r27818 | pmichaud++ | [rakudo]:

[18:19] <rakudo_svn> r27818 | pmichaud++ | * Improve the mapping of Parrot's built-in types to Rakudo types.

[18:19] <rakudo_svn> r27818 | pmichaud++ | * Resolves RT#54796.

[18:24] *** braceta left
[18:26] *** braceta_ left
[18:28] <pmichaud> rakudo: sub foo(:$w=4){say $w};foo('w'=>3);foo(w=>3);

[18:28] <exp_evalbot> OUTPUT[3␤3␤]

[18:29] <pmichaud> evalbot has an older version of rakudo.

[18:32] <Auzon> pmichaud:  It should be rebuilt every 5 minutes

[18:32] <Auzon> and Parrot should be built hourly

[18:32] <pmichaud> just a sec.

[18:32] *** armagad left
[18:32] <pmichaud> where are #perl6 logs kept?

[18:33] <pmichaud> or, let's put it this way.

[18:33] <pmichaud> rakudo: sub foo(:$w=4){say $w};foo('w'=>3);foo(w=>3);

[18:33] <exp_evalbot> OUTPUT[3␤3␤]

[18:33] <pmichaud> but my version of rakudo gives

[18:33] <pmichaud> $ ./parrot perl6.pbc

[18:33] <pmichaud> sub foo(:$w=4){say $w};foo('w'=>3);foo(w=>3);

[18:33] <pmichaud> w       3

[18:33] <pmichaud> 3

[18:33] <pmichaud> ergo, the evalbot version of rakudo is out of date.

[18:34] <Auzon> I'll look into it.

[18:34] <pmichaud> but most of diakopter's rt tickets were using an outdated version of rakudo.

[18:34] <Auzon> Is there a way to check parrot's version?

[18:34] <pmichaud> (I'm not saying rakudo's output is correct in my case -- it's not -- I'm just saying that using evalbot to report bugs isn't very helpful.)

[18:35] <pmichaud> not down to a svn revision level, now.

[18:35] <pmichaud> s/now/no.

[18:35] <pmichaud> i.e., this is parrot 0.6.2

[18:35] <Auzon> oh.

[18:36] <pmichaud> where are the #perl6 logs?

[18:36] <Auzon> http://irc.pugscode.org/

[18:36] <lambdabot> Title: IRC log for #perl6, 2008-05-26

[18:36] <pmichaud> thanks.

[18:37] <Auzon> Try your command again, now. I accidentally broke Rakudo's updater for evalbot, and it should be fixed now

[18:37] <pmichaud> rakudo: sub foo(:$w=4){say $w};foo('w'=>3);foo(w=>3);

[18:37] <exp_evalbot> OUTPUT[w        3␤3␤]

[18:37] <pmichaud> better.

[18:38] <pmichaud> but I'm still not happy that evalbot was being used to report bugs.

[18:38] <Auzon>  Sorry about evalbot being out of date.

[18:38] <pmichaud> at least not until we're sure that it's keeping up-to-date with trunk.

[18:39] <Auzon> I'll keep an eye on it.

[18:43] <pmurias> evalbot should mention the rakudo revision used

[18:43] <pmichaud> that would be very nice.

[18:43] <pmichaud> I'd be more willing to accept rakudobugs from eval if they included the correct svn revision number.

[18:43] <pugs_svnbot> r20540 | pmurias++ | [elf] added a TODO section to README

[18:46] <pmurias> pmichaud: how does one report bugs from the evalbot?

[18:47] <pmichaud> ...how do you mean?

[18:47] <Auzon> Having the svn revision visible wouldn't've caught this problem, but I can see about patching it

[18:47] <pmichaud> it might have caught the problem.

[18:48] <pmichaud> but even if it didn't, it would've saved me time trying to figure out why evalbot's version was so out of whack from stuff I had done the day before.

[18:48] <pmurias> pmichaud: using evalbot to report bugs meant using evalbot to find the bug?

[18:48] *** araujo joined
[18:48] <Auzon> svn was being updated correctly, but the directory wasn't being built after one of my changes. :-/

[18:49] <pmichaud> pmurias:  correct.  If I can be guaranteed that evalbot is up-to-date w.r.t. rakudo head, then it's okay.

[18:49] <pmichaud> but since evalbot appears to have been using an out-of-date version of rakudo, we ended up with 4 or 5 "false" RT tickets in rakudo's queue.

[18:50] <pmichaud> it would've been nice for someone to at least gotten a copy of rakudo trunk and verified it before reporting all of these things as "bugs"

[18:54] <pmichaud> pugs: sub foo(:$w=4){say $w};foo('w'=>3);foo(w=>3);

[18:54] <exp_evalbot> OUTPUT[4␤3␤]

[18:55] <pmurias> is there an accepted way for dumping Match objects?

[18:55] <pmichaud> not that I'm aware of.  I've been using a slightly modified form of Data::Dumper

[18:55] <pmurias> s/dumping/viewing/

[19:03] *** mncharity joined
[19:11] <pmurias> mncharity: hi

[19:12] <mncharity> vixey: re 'my sub f(){}', it gets broken in the FromAST to IR conversion.  elf started out "just enough p6 coverage to be able to happily write in p6".  That's now mission creep'ed to "pass t/", in an effort to attract developers.  but coverage of all the possible AST trees has never been systematically expanded, and is thus spotty.

[19:12] <vixey> ah ok, thanks

[19:12] <mncharity> for writing p6, rather than passing t/, you can use  my $f = sub(){};

[19:12] <vixey> I was wondering how to implement perl 6 grammars in perl 6

[19:13] <mncharity> that one is easy...

[19:13] <mncharity> "with great difficulty"

[19:13] <mncharity> ;)

[19:13] <vixey> haha

[19:13] <vixey> I read STD.pm and some docs .. it does seem tricky

[19:14] <vixey> there's currently no p6 program that will parse p6 and let you play with the AST?

[19:14] <mncharity> no

[19:14] <vixey> ok

[19:14] <mncharity> the best hope of that near term seems to be a translation of STD_red into p6.

[19:15] <mncharity> which should be straightforward, but given the size of STD (600? rules), is a bit of effort.

[19:15] <vixey> I wonder if compling STD.pm into (Perl 6 - grammars) is straght forward?

[19:15] <mncharity> no

[19:16] <pmurias> vixey: what do you mean by playing with the AST?

[19:16] <mncharity> STD.pm is... a rather flakey work in progress.  STD_red only works by variously extending it.

[19:16] <vixey> pmurias: well print it out as perl5, lisp.. and so on

[19:16] <vixey> or anything

[19:16] <mncharity> rakudo is coming at it from the other side, starting with a real set of rules, and slowly moving towards STD coverage.

[19:17] <mncharity> and pugs has the best, albeit not actively developed, coverage of all.  but is like STD_red in being a non-rules hack.

[19:17] <pmurias> vixey: by AST you mean the match tree

[19:17] <pmurias> or the IRx1

[19:17] <pmurias> ?

[19:17] <mncharity> re ﻿non-rules hack, though one which was designed to be converted at some point.  just never happened.

[19:18] <vixey> I guess the match tree

[19:18] *** wknight8111 joined
[19:18] <vixey> why is implementing rules hard?

[19:19] <pmichaud> ever implemented a regex engine?  ;-)

[19:19] <mncharity> there's a scraper for the rakudo Match tree dump format in elf_on_rakudo.  Unfortunately the Match's aren't (weren't annotated with the rule which generated them, so actually doing anything with the tree is problematic).

[19:19] <vixey> pmichaud: well never with efficiency in mind

[19:19] <mncharity> s/﻿(weren't/﻿(weren't)/

[19:21] <pmurias> pmichaud: you did it in pir, so you had an extra challenge ;)

[19:21] <pmichaud> pir was easier than C.

[19:21] <pmichaud> which is why I did it in PIR.

[19:21] <mncharity> I started to move the p5 yet_another_regex_engine into elf, more to provide regex support than to help with STD, but it turned out to not run on 32-bit machines (!:( ), so it got backburnered.

[19:22] <pmurias> pmichaud: did you do much assembler before?

[19:22] <pmichaud> yes.  But PIR really isn't an assembler.

[19:23] <pmichaud> it's an assembly language only if you ignore the fact that it supports objects, classes, method calls, named params, positional params, slurpy params, etc.

[19:23] <pmurias> it lacks proper structural programming support

[19:24] <pmichaud> just because PIR doesn't have structured programming constructs doesn't mean that one can't write structured programs with it :-)

[19:24] <mncharity> misc/pX/Common/yet_another_regex_engine/  misc/elf/elf_e_src/EmitRegexYare.pm

[19:29] <pmurias> mncharity: it might make sense to do a regex engine which does things the way gimme5 does

[19:30] <vixey> I look at the grammar and see Prolog

[19:30] <vixey> : is ! .. etc

[19:33] <pmurias> vixey: on hard thing about grammer is the longest token matching which forces you to write a DFA-with-frills to do efficiently

[19:34] <vixey> where is longest token matching described?

[19:36] <pmurias> S05

[19:40] <mncharity> hi ﻿pmurias

[19:40] <pugs_svnbot> r20541 | putter++ | [elf] Fleshed out <scoped> AST->IR.  'my sub f(){}' now reaches IR.  vixey++.

[19:40] <pugs_svnbot> r20541 | putter++ | undef.perl is now "undef".  -e 'say $?PACKAGE;' now "Main".  Added (commented out) assorted speculative IR node definitions for regex.

[19:42] <mncharity> re gimme5, my understanding is gimme5 is still a research project in progress.  with hand spot checking rather than any test suite.  and thus not ready for implementation in p6.  I could be wrong though.

[19:44] <mncharity> re see Prolog, there is *also* a combined p6/p5 regex/regexp engine written in prolog.  misc/Grammars/snapshot_of_prolog_engine.pl .  but that's unrelated abandonware.

[19:44] <mncharity> ;)

[19:45] <mncharity> hi ﻿pmurias

[19:45] <pmurias> rehi ;)

[19:46] <pmurias> would better match dumping be usefull?

[19:47] <pmurias> in a clearer and terser format?

[19:49] <pmurias> (that sounded like really lame advertising) ;)

[19:49] <mncharity> lol

[19:50] <mncharity> perhaps...   could add default handling to EmitFaster instead... P)

[19:51] <mncharity> * :)

[19:52] <mncharity> ﻿vixey: the main difference between elf_f_faster and elf_f (soon to be renamed elf_f_somethingorother) is object attributes don't work yet in faster, so, eg,  has @.a;  won't actually be an empty array.

[19:52] <Auzon> Is there a general way to check the traits of something? (variables, packages, modules, subroutines, etc)

[19:52] <mncharity> ooo, good question.  dunno.

[19:53] <Auzon> The specs say a lot about setting them, but I don't see anything at all about checking them

[19:54] <Auzon> perl6: my $foo is bar;

[19:54] <exp_evalbot> kp6: OUTPUT[<is> not implemented at compiled/perl5-kp6-mp6/lib/KindaPerl6/Grammar/Term.pm line 1818, <> line 1.␤]

[19:54] <exp_evalbot> ..pugs: RESULT[\undef]

[19:54] <exp_evalbot> ..rakudo: OUTPUT[PAST::Compiler can't compile node of type Perl6::Grammar␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[19:54] <exp_evalbot> ..elf: RESULT[undef␤]

[19:54] <Auzon> pugs: my $foo is bar; say $foo.is('bar');

[19:54] <exp_evalbot> OUTPUT[*** No such method in class Scalar: "&is"␤    at /tmp/RoEJqiUji5 line 1, column 21-35␤]

[19:54] <pmurias> mncharity: i'll add the default handling first than (to stop people being misguided in using elf_f_slower) ;)

[19:55] <Auzon> pugs: my $foo is bar; say $foo.IS('bar');

[19:55] <exp_evalbot> OUTPUT[*** No such method in class Scalar: "&IS"␤    at /tmp/wwq3Yn8qtJ line 1, column 21-35␤]

[19:55] <Auzon> pugs: my $foo is bar; say $foo.ISA('bar');

[19:55] <exp_evalbot> OUTPUT[*** No such method in class Scalar: "&ISA"␤    at /tmp/OCIti596Uc line 1, column 21-36␤]

[19:55] <pmurias> mncharity: why does HASH inherit from Hash?

[19:56] <mncharity> LOL

[19:56] <mncharity> re  _slower

[19:56] <mncharity> re Hash,

[19:57] <mncharity> elf: class Hash { method zog(){42} }; say {}.zog;

[19:57] <pmurias> s/in/into

[19:57] <exp_evalbot> OUTPUT[Parse error in: /tmp/BlTjajZZQr␤panic at line 1 column 39 (pos 39): Statement not terminated properly␤WHERE: h { method zog(){42} }; say {}.zog;␤WHERE:                              /\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:355:in `eat_terminator'␤  STD_red/std.rb:269:in

[19:57] <exp_evalbot> ..`block in statementlist'␤  STD_red/prelude.rb:15...

[19:57] <mncharity> drat

[19:57] <Auzon> pugs: my $foo is bar; say $foo.TRAITS; # This would be nice.

[19:57] <exp_evalbot> OUTPUT[*** No such method in class Scalar: "&TRAITS"␤    at /tmp/Rqt69pEQVU line 1, column 21-32␤]

[19:57] <mncharity> elf: class Hash { method zog(){42} }; say ({}).zog;

[19:57] <exp_evalbot> OUTPUT[42␤]

[19:57] <pmurias> why do we use HASH then?

[19:57] <mncharity> something is broken about STD_red's parsing of method call following close brace.

[19:58] <pmurias> instead of telling autobox to use Hash?

[19:59] *** rindolf joined
[19:59] <mncharity> because HASH is just an unboxed raw hash.  Hash is a regular Moose-or-p5 object.  it's not yet clear how to handle the autoboxed forms once we start doing things which manipulate "extra" info attached to objects.  Perhaps the "inside out object" idiom.

[19:59] <rindolf> Hi all.

[20:00] <vixey> hey rindolf

[20:00] <rindolf> Hi vixey 

[20:00] <mncharity> Hash.new, actually, any X.new other than Pair.new, is as yet unimplemented.

[20:00] <mncharity> err, for X ne HASH, ARRAY, etc.

[20:01] <mncharity> currently Hash, Array, etc, are just places to dump methods.

[20:01] <mncharity> there's something for the todo list... go through S29/whatever dumping in methods.

[20:02] <mncharity> Hash will probably get a  has %.primitive; or some such to contain the actual data.

[20:06] <pmurias> perl6: my @a = 1;@a[1] = 2;

[20:06] <exp_evalbot> kp6: RESULT[2]

[20:06] <exp_evalbot> ..pugs: RESULT[\2]

[20:06] <exp_evalbot> ..rakudo: OUTPUT[get_pmc_keyed() not implemented in class 'Integer'␤current instr.: '_block11' pc 49 (EVAL_10:27)␤

[20:06] <exp_evalbot> ..elf: OUTPUT[Can't use string ("1") as an ARRAY ref while "strict refs" in use at (eval 14) line 4.␤ at ./elf_f_faster line 4616␤]

[20:06] <Auzon> pmurias: You'd probably get better results if you explicitly generate output.

[20:07] <mncharity> another item for the todo list... understand how p6 Lists are supposed to work, and make elf do something closer to the right thing.

[20:08] <pmurias> Auzon: i was trying to generate errors ;)

[20:08] <Auzon> Ah.

[20:08] <pmurias> perl6: my @a =1;say @a[1];

[20:08] <exp_evalbot> kp6: OUTPUT[␤]

[20:08] <exp_evalbot> ..pugs: OUTPUT[␤]

[20:08] <exp_evalbot> ..rakudo: OUTPUT[get_pmc_keyed() not implemented in class 'Integer'␤current instr.: '_block11' pc 46 (EVAL_10:26)␤

[20:08] <exp_evalbot> ..elf: OUTPUT[Can't use string ("1") as an ARRAY ref while "strict refs" in use at (eval 14) line 4.␤ at ./elf_f_faster line 4616␤]

[20:10] *** rindolf left
[20:12] <cognominal_> perl6:  my @a; say @.WHAT

[20:12] <pugs_svnbot> r20542 | putter++ | [STD_red] Improved <scoped> tree.  This change was intended to be part of r20541.

[20:12] *** exp_evalbot left
[20:12] *** exp_evalbot joined
[20:12] <pmurias> mncharity: do you have a test for the defaults?

[20:12] <cognominal_> perl6:  my @a; say @.WHAT

[20:12] *** exp_evalbot left
[20:12] *** exp_evalbot joined
[20:13] <cognominal_> oops, I am killing the bot

[20:13] <Auzon> It seems so ;)

[20:13] <cognominal_> pugs: my @a; say @a.WHAT

[20:13] <exp_evalbot> OUTPUT[Array␤]

[20:13] <Auzon> Though, I wonder which implementation is killing it

[20:14] <cognominal_> I want a exemple to paste on a slide but the bots don't want to cooperate

[20:14] <cognominal_> perl6: say "Hi!"

[20:14] <exp_evalbot> kp6: OUTPUT[Hi!␤]

[20:14] <exp_evalbot> ..pugs: OUTPUT[Hi!␤]

[20:14] <exp_evalbot> ..rakudo: OUTPUT[Hi!␤]

[20:14] <exp_evalbot> ..elf: OUTPUT[Hi!␤]

[20:14] <cognominal_> what is elf?

[20:14] <mncharity> ﻿pmurias: t/ ?  ;)  no.

[20:17] <Auzon> elf is Perl6 written in Perl6 running on Perl5. mncharity is the primary programmer on it. It's being fairly rapidly developed, and if I recall correctly, it's designed to provide enough of Perl6 to be useful in writing a Perl6 compiler.

[20:17] <spinclad> elf_f:  elf_f_mooser  :)

[20:18] <spinclad> (mooser: one who catches meese)

[20:21] <mncharity> lol :)

[20:22] <mncharity> re elf, ﻿pmurias has done a bunch of work on it too.

[20:25] <pmurias> not much (yet) ;)

[20:26] <mncharity> elf is a p6 implementation with a STD-based external parser written in ruby, and a bootstrapped p6 to p5 compiler written in p6.  Currently parsing ~70% of t/, and passing ~8% of files and ~4% of tests.  Though perhaps more usable than that would seem to suggest.  ~p5 native speed.

[20:27] <mncharity> ﻿Auzon: which was the test file you thought might start passing once 'package Roo;' was supported?

[20:28] <Auzon> mncharity: t/spec/S11/module_file.t for "module Foo;".

[20:28] <Auzon> errr. S11-modules maybe? I'll check

[20:28] *** alanhaggai left
[20:29] <Auzon> t/spec/S11-modules/module-file.t is for "module Foo;"

[20:29] <mncharity> ah, ok.  thanks :)

[20:29] <Auzon> I haven't touched any "package Foo;" stuff yet, but I'll let you know when I see some

[20:31] *** chris2 joined
[20:33] <moritz_> re

[20:37] <cognominal_> STD?

[20:37] <cognominal_> this one I know, but I am after the acronym

[20:38] <pmurias> STD means standard

[20:38] <moritz_> not "sexually transmitted decease"

[20:38] <moritz_> ;-)

[20:42] <mncharity> re STD, src/perl6/STD.pm, TimToady's p6 grammar.

[20:42] <pmurias> mncharity: is it ok if new in faster only supports the Foo.new('key','value'), and not Foo.new({key=>'value'})?

[20:44] <mncharity> whatever is easiest.  we're officially not supporting named args yet, either for internal or external use.

[20:44] <mncharity> even though, of course, the Moose-based elf necessarily uses them slightly.

[20:45] *** perl7 joined
[20:45] <fullermd> moritz_: Hey there.  Finally got a little time to read that thing more carefully.

[20:46] <moritz_> fullermd: ok, any comments?

[20:46] *** meppel-san left
[20:46] <moritz_> most of all: does it make sense? ;-)

[20:46] <fullermd> moritz_: I understand it a bit better, I think.  It all seems to make sense.

[20:47] <moritz_> I have to admit I'm not too sure of the stuff that I wrote in this one

[20:47] <fullermd> The proto regex section took a run or two to get it figured out.  The multiple 'sym's on the lines took a little puzzling to unravel.  Maybe it could be clearer earlier what each means/applies to?

[20:47] <fullermd> Also ran across another typo or two at the end.

[20:47] <fullermd> "shouldn't have to now all this stuff"

[20:47] <mncharity> I've been puzzling over how to add named args without completely trashing our performance.  I'm thinking something like 3 apis, normal pure positionals, a two arg marker+Capture full sig/capture support, and something in between to do named but not horrendous performance.  perhaps  marker,positional args...,hash-o-named-args.

[20:48] <fullermd> moritz_: Also, factorial would be [*], not [+]   :)

[20:48] *** meppel-san joined
[20:48] <moritz_> good catch, thanks

[20:49] <fullermd> moritz_: Some places sprinkled through it, the wording seems a little odd as a native English speaker, but it was always perfectly understandable.

[20:50] <moritz_> fullermd: well, I'm not a native English speaker, but I try my best... I'll got through it again when I'm more awake than now, maybe I fix a bit

[20:50] <fullermd> moritz_: A little blurb on "now that I've defined this grammar {}, how do I use it in my program" would be a nice finale.  Maybe showing defining and using that factorial.

[20:51] <fullermd> (chosen because it's small and obvious)

[20:51] <moritz_> fullermd: ok

[20:52] <fullermd> But aside from that nitpicking, it's a good read, and makes good sense   :)

[20:52] <diakopter> Auzon or moritz_ or anyone: would someone like to add the current-built svn revision to each implementation's output?  perhaps a wrapper calling script (custom for each implementation) that prepends the revision number to the output?  Also I guess the wrapper calling script could catch failures?

[20:52] *** Limbic_Region joined
[20:54] <diakopter> (the old pugs_svnbot had the revision number in its nick)

[20:55] *** dolmen joined
[20:55] <moritz_> kp6: say "whoami"

[20:55] <exp_evalbot> r20542: OUTPUT[whoami␤]

[20:55] <diakopter> oh

[20:56] <mncharity> perl6: say "whoami"

[20:56] <moritz_> the easiest solution would be for each executable to have an option that prints its revision

[20:56] <exp_evalbot> kp6: OUTPUT[whoami␤]

[20:56] <exp_evalbot> ..pugs: OUTPUT[whoami␤]

[20:56] <exp_evalbot> ..rakudo: OUTPUT[whoami␤]

[20:56] <exp_evalbot> ..elf: OUTPUT[whoami␤]

[20:56] <mncharity> elf: say "whoami"

[20:56] <exp_evalbot> OUTPUT[whoami␤]

[20:56] <moritz_> needs enhancements, though

[20:56] <mncharity> rakudo: say "whoami"

[20:56] <exp_evalbot> OUTPUT[whoami␤]

[20:56] <pmichaud> it's not always easy for the executables to catch the revision number

[20:57] <moritz_> I'll try to find tuits tomorrow

[20:57] <diakopter> rakudo: die; #just testing

[20:57] <exp_evalbot> OUTPUT[Died␤current instr.: 'die' pc 7505 (src/gen_builtins.pir:5124)␤

[20:57] <pmichaud> for example, how would I capture the revision number in source?

[20:57] <dolmen> rakudo.org is quite slow...

[20:57] <dolmen> slashdoted?

[20:58] <diakopter> perhaps the svnup/rebuild script could generate a wrapper script for each implementation that has the revision-number-as-built

[20:59] <diakopter> (so it doesn't have to look it up each invocation)

[21:00] <diakopter> rakudo: exit 3; #testing again

[21:00] <exp_evalbot> No output (you need to produce output to STDOUT)

[21:00] <Auzon> Could we have the Makefile do this magic?

[21:00] * fullermd has always just done it with a keyword in a source file.

[21:01] <pmichaud> We can't assume that everyone is building rakudo from an svn checkout.

[21:02] <dolmen> rakudo: say (1..10) + 3

[21:02] <exp_evalbot> OUTPUT[MMD function __add not found for types (97, 94)␤current instr.: 'infix:+' pc 9334 (src/gen_builtins.pir:6496)␤

[21:02] <Auzon> Maybe just include it if it is being built from SVN?

[21:03] <dolmen> rakudo: say (1..10) + (1..5)

[21:03] <exp_evalbot> OUTPUT[MMD function __add not found for types (97, 97)␤current instr.: 'infix:+' pc 9334 (src/gen_builtins.pir:6496)␤

[21:03] <dolmen> rakudo: say (1) + (1)

[21:03] <exp_evalbot> OUTPUT[2␤]

[21:03] <pmichaud> looks like parrot's "add" doesn't know how to numify lists.

[21:03] <fullermd> If you stuck it in a keyword, it would just be expanded or not (though I dunno how you'd get "not" without trying; it has to come out of SVN somewhere along the path)

[21:03] <dolmen> rakudo: say (1..2) + (1..2)

[21:03] <pmichaud> iiuc, keywords are the svn revision number of the file

[21:03] <exp_evalbot> OUTPUT[MMD function __add not found for types (97, 97)␤current instr.: 'infix:+' pc 9334 (src/gen_builtins.pir:6496)␤

[21:04] <dolmen> rakudo: say (1..2)

[21:04] <exp_evalbot> OUTPUT[12␤]

[21:04] <Auzon> SVN doesn't support such keywords that I'm aware of.

[21:04] <fullermd> It is?  I thought it had the tree number.

[21:04] * fullermd continues to fail to regret not using svn...

[21:04] <dolmen> rakudo: say (1|2)

[21:04] <Auzon> Maybe with a checkout script

[21:04] <exp_evalbot> OUTPUT[get_string() not implemented in class 'Junction'␤current instr.: 'print' pc 7719 (src/gen_builtins.pir:5337)␤

[21:04] <Auzon> What do you use, fullermd?

[21:04] <pmichaud> (tree number)  wouldn't that mean that every "svn up" would have to modify the files to update the number, then?

[21:05] <fullermd> Oh, I jumped from CVS to bzr.  But that's waaay ---->OT.

[21:05] <diakopter> pmichaud: yesterday TimToady said that foo(,,) sends at least two empty positional arguments... I don't think that's in the spec though

[21:05] <fullermd> Well, whatever files you had it set in, yah.

[21:05] <diakopter> (currently rakudo combines multiple commas to one)

[21:05] <pmichaud> diakopter: yes, I saw that.  I'll have to figure out how to add that to PGE's operator precedence parser.

[21:06] <pmichaud> that's likely to be pretty low on my list right now, though.  :-)

[21:10] <Auzon> pugs: say $?PUGS_VERSION

[21:10] <exp_evalbot> OUTPUT[Perl6 User's Golfing System, version 6.2.13, October 17, 2006 (r18093)␤]

[21:10] <pugs_svnbot> r20543 | putter++ | [elf] Support 'package Foo;'.

[21:11] *** iblechbot left
[21:11] <Auzon> perl6: say $*PERLVER

[21:11] <exp_evalbot> kp6: OUTPUT[␤]

[21:11] <exp_evalbot> ..pugs: OUTPUT[␤]

[21:11] <exp_evalbot> ..rakudo: OUTPUT[␤]

[21:11] <exp_evalbot> ..elf: OUTPUT[Can't call method "Str" on an undefined value at ./elf_f_faster line 625.␤ at ./elf_f_faster line 4454␤]

[21:11] <Auzon> perl6: say $?PERLVER

[21:11] <exp_evalbot> kp6: OUTPUT[syntax error at position 4, line 1 column 4:␤say $?PERLVE␤    ^ HERE␤]

[21:11] <exp_evalbot> ..pugs: OUTPUT[*** Undeclared variable: ("$?PERLVER",MkPad (padToList [("$_",PELexical {pe_type = (mkType "Scalar"), pe_proto = <Scalar:0xb689bdc0>, pe_flags = MkEntryFlags {ef_isContext = True}, pe_store = <ref:0xb68a5a88>}),("@_",PELexical {pe_type = (mkType "Array"), pe_proto =

[21:11] <exp_evalbot> ..<Array:0xb689b25c>, pe_flags = MkEntryFlags {ef_isContext = False}, pe_st...

[21:11] <exp_evalbot> ..rakudo: OUTPUT[Scope  not found for PAST::Var '$PERLVER'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[21:11] <exp_evalbot> ..elf: OUTPUT[Global symbol "$PERLVER" requires explicit package name at (eval 14) line 3.␤ at ./elf_f_faster line 4454␤]

[21:12] *** rdice left
[21:12] <Auzon> Wow. I thought at least one implementation would handle that.

[21:12] <mncharity> pugs predated it.

[21:14] <Auzon> perl6: say $?FILE

[21:14] <exp_evalbot> kp6: OUTPUT[syntax error at position 4, line 1 column 4:␤say $?FIL␤    ^ HERE␤]

[21:14] <exp_evalbot> ..pugs: OUTPUT[/tmp/HLVgYtRirD␤]

[21:14] <exp_evalbot> ..rakudo: OUTPUT[Scope  not found for PAST::Var '$FILE'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[21:14] <exp_evalbot> ..elf: OUTPUT[/tmp/rbUdtldN56␤]

[21:14] *** FurnaceBoy left
[21:15] <moritz_> pugs++ elf++

[21:15] *** ruoso joined
[21:15] <Auzon> Indeed. It's tested some, as well.

[21:16] <diakopter> perl6: die "dead";

[21:16] *** exp_evalbot left
[21:17] <diakopter> oops :/

[21:17] *** exp_evalbot joined
[21:17] <dolmen> efficient ;)

[21:17] <dolmen> perl6: die "alive";

[21:17] *** exp_evalbot left
[21:18] *** exp_evalbot joined
[21:18] <diakopter> perl6: exit 4;

[21:18] <exp_evalbot> kp6: No output (you need to produce output to STDOUT)

[21:18] <exp_evalbot> ..pugs: OUTPUT[*** Unsafe function 'exit' called under safe mode␤    at /tmp/NPZRV6VHa2 line 1, column 1-7␤]

[21:18] <exp_evalbot> ..rakudo: No output (you need to produce output to STDOUT)

[21:18] <exp_evalbot> ..elf: No output (you need to produce output to STDOUT)

[21:18] <Auzon> That's not supposed to be possible...

[21:19] <diakopter> perl6: doing the impossible.

[21:19] <exp_evalbot> kp6: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤   KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824bddc)', 'APPLY') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤     

[21:19] <exp_evalbot> ..main::DISPATCH('HASH(0x824bddc)', 'APPLY') called at compiled/perl5-kp6-mp6/lib/Kin...

[21:19] <exp_evalbot> ..pugs: OUTPUT[*** ␤    Unexpected end of input␤    expecting ".", "\187", ">>", "=", "^", operator name, qualified identifier, variable name, "...", "--", "++", "i", array subscript, hash subscript or code subscript␤    at /tmp/9uU6vgFs0a line 1, column 22␤]

[21:19] <exp_evalbot> ..rakudo: OUTPUT[Statement not terminated properly at line 1, near "."␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[21:19] <Auzon> Heh.

[21:19] <exp_evalbot> ..elf: OUTPUT[Parse error in: /tmp/UCrb2Mg01q␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: doing the impossible.␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[21:19] <exp_evalbot> ..STD_red/std.rb:210:in `_UNIT'␤  ./../STD_red/STD_red_run:108:in `main'␤  ....

[21:20] <Auzon> No Poetry Mode? :-/

[21:25] *** exp_evalbot left
[21:25] <pugs_svnbot> r20544 | putter++ | [elf] Added $?PERLVER.  Auzon++

[21:25] *** exp_evalbot joined
[21:26] *** wknight8111 left
[21:26] *** wknight8111_ joined
[21:27] <diakopter> perl6: 1; say $_;

[21:27] <exp_evalbot> kp6: OUTPUT[␤]

[21:27] <exp_evalbot> ..pugs: OUTPUT[␤]

[21:27] <exp_evalbot> ..rakudo: OUTPUT[too few arguments passed (0) - 1 params expected␤current instr.: '_block11' pc 0 (EVAL_10:3)␤

[21:27] <exp_evalbot> ..elf: OUTPUT[Can't call method "Str" on an undefined value at ./elf_f_faster line 625.␤ at ./elf_f_faster line 4456␤]

[21:28] <diakopter> perl6: use v6; say 0.WHAT;

[21:28] <exp_evalbot> kp6: OUTPUT[Int␤]

[21:28] <exp_evalbot> ..pugs: OUTPUT[Int␤]

[21:28] <exp_evalbot> ..rakudo: OUTPUT[Int␤]

[21:28] <exp_evalbot> ..elf: OUTPUT[Int␤]

[21:28] <Auzon> We're trying to reorganize stuff from t/* to t/spec/*, correct?

[21:29] <diakopter> affirmative

[21:29] <Auzon> I propose that I move t/magicals to t/spec/S02-magicals, and check the tests that rely on the filename.

[21:29] <moritz_> Auzon: yes

[21:30] <Auzon> and then I want to add tests checking the existence of $?PERLVER and friends

[21:30] <spinclad> mncharity: perhaps for middle api, recognized named args (same name in arg and param list, no slurpies) could be mapped to underlying positionals?  assumes signature available at call site (how often not?)...  should work well for any known underlayer, p5, parrot, cl, ...

[21:30] * dolmen is building rakudo:

[21:30] <dolmen> ./perl6scalar.c: Dans la fonction «Parrot_Perl6Scalar_class_init» :

[21:30] <dolmen> ./perl6scalar.c:565: attention : initialization from incompatible pointer type

[21:30] <dolmen> ./perl6scalar.c:728: attention : initialization from incompatible pointer type

[21:30] <moritz_> Auzon: but first check that the tests are still in sync with the synopsis

[21:31] <diakopter> elf: system('pwd');

[21:31] <Auzon> OK, yeah.

[21:31] <exp_evalbot> OUTPUT[/home/evalenv/pugs/misc/elf␤]

[21:31] <spinclad> perl6: system('pwd');

[21:31] <exp_evalbot> kp6: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤   KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824bd1c)', 'APPLY', 'HASH(0x8e4db7c)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤  

[21:31] <exp_evalbot> ..main::DISPATCH('HASH(0x824bd1c)', 'APPLY', 'HASH(0x8e4db7c)') ca...

[21:31] <exp_evalbot> ..pugs: OUTPUT[*** Unsafe function 'system' called under safe mode␤    at /tmp/GHVfjtmYJu line 1, column 1-14␤]

[21:31] <exp_evalbot> ..rakudo: OUTPUT[Could not invoke non-existent sub system␤current instr.: '_block11' pc 28 (EVAL_7:17)␤

[21:31] <exp_evalbot> ..elf: OUTPUT[/home/evalenv/pugs/misc/elf␤]

[21:32] <moritz_> elf: print system('uptime')

[21:32] <exp_evalbot> OUTPUT[256]

[21:32] <pugs_svnbot> r20545 | putter++ | [elf] Add emitter classname to $?PERLVER.

[21:34] <Auzon> System gives the output and the return status?

[21:35] <mncharity> elf: $?PERLVER

[21:35] <exp_evalbot> RESULT['elf / perl 5.8.8'␤]

[21:35] <pmichaud> isn't it "run" instead of "system" now?

[21:35] <moritz_> yes

[21:36] *** exp_evalbot left
[21:36] *** exp_evalbot joined
[21:37] <mncharity> ﻿spinclad: ﻿re 'signature available at call site (how often not?)', I was aiming for something which didn't require whole program analysis, which elf isn't currently set up for (I keep on deferring it).

[21:37] *** exp_evalbot left
[21:37] <mncharity> but interesting idea

[21:37] *** exp_evalbot joined
[21:37] <mncharity> spec pointer on run()?

[21:37] <moritz_> S29

[21:37] <Auzon> mncharity: You might want $?PERLVAR to mention elf_f/elf_f_faster, but I'm not certain how you'd implement that easily

[21:38] <mncharity> elf: $?PERLVER

[21:38] <exp_evalbot> RESULT['elf / perl 5.8.8 / EmitFasterP5'␤]

[21:38] <dolmen> perl6: say 'abc' x 3

[21:38] <exp_evalbot> kp6: OUTPUT[abcabcabc␤]

[21:38] <exp_evalbot> ..pugs: OUTPUT[abcabcabc␤]

[21:38] <exp_evalbot> ..rakudo: OUTPUT[abcabcabc␤]

[21:38] <exp_evalbot> ..elf: OUTPUT[abcabcabc␤]

[21:38] <dolmen> perl6: say 'abc' xx 3

[21:38] *** exp_evalbot left
[21:38] <mncharity> :)

[21:38] <Auzon> Cool.

[21:38] *** exp_evalbot joined
[21:38] <moritz_> istr that xx is reserved for lists

[21:38] <Auzon> Which implementation is killing evalbot?

[21:39] <Auzon> pugs: say 'abc' xx 3

[21:39] <exp_evalbot> OUTPUT[abcabcabc␤]

[21:39] <Auzon> rakudo: say 'abc' xx 3

[21:39] <exp_evalbot> OUTPUT[Could not invoke non-existent sub x␤current instr.: '_block11' pc 34 (EVAL_11:19)␤

[21:39] <mncharity> also have to add a runtime variant.  compiled to and running on javascript, it would have the same $?PERLVER. 

[21:39] <Auzon> kp6: say 'abc' xx 3

[21:39] <exp_evalbot> r20545: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤        KindaPerl6::Runtime::Perl5::MOP::__ANON__('HASH(0x824be0c)', 'APPLY', 'HASH(0x8e4de68)') called at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 169␤  

[21:39] <exp_evalbot> ..main::DISPATCH('HASH(0x824be0c)', 'APPLY', 'HASH(0x8e4de68)') ca...

[21:39] <Auzon> elf: say 'abc' xx 3

[21:39] *** exp_evalbot left
[21:39] <Auzon> sorry about the spam...

[21:39] *** exp_evalbot joined
[21:39] <moritz_> but why the f*ck does it segfault so often?

[21:40] <dolmen> in rakudo op.pir I see that arg0 to infix:++ is a string arg1 is an int

[21:40] <pmichaud> ...infix:++ ?

[21:40] <mncharity> hmm, can "evalbot" be run as a command line program?  that could be nifty.

[21:40] <dolmen> infix:xx

[21:40] <dolmen> :)

[21:41] <moritz_> mncharity: that shouldn't be too much work

[21:41] <Auzon> mncharity: re mentioning "Javascript" or similar in $?PERLVER, I think you'd want to change $*OS for that.

[21:42] <Auzon> ok. brb &

[21:42] *** Auzon left
[21:43] <mncharity> not in $?PERLVER, but in $*PERLVER.  Unless of course the js version was used to compile it.

[21:43] <pmichaud> (infix:xx)  I suspect someone copied infix:x and didn't bother to test it.

[21:43] <moritz_> whoever is currently regression-testing evalbot's mechanisms of running external programs: please don't break it

[21:43] <dolmen> what is the difference between infix:x and infix:xx

[21:43] <dolmen> ?

[21:44] <pmichaud> infix:<x>, string/buffer replication 

[21:44] <pmichaud> infix:<xx>, list replication 

[21:44] <diakopter> perl6: use v6;

[21:44] <dolmen> in rakudo op.pir :

[21:44] <exp_evalbot> kp6: RESULT[DISPATCH: calling  on invalid object:$VAR1 = 'perl';␤␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 128␤  main::DISPATCH('perl') called at - line 11␤]

[21:44] <exp_evalbot> ..pugs: RESULT[undef]

[21:44] <exp_evalbot> ..rakudo: RESULT[Null PMC access in find_method()␤current instr.: '_block11' pc 38 (EVAL_11:18)␤

[21:44] <exp_evalbot> ..elf: RESULT[undef␤]

[21:44] <dolmen> .sub 'infix:xx' :multi(_,_)

[21:44] <dolmen>     .param string a

[21:44] <dolmen>     .param int b

[21:45] *** Auzon joined
[21:45] <pmichaud> rakudo is obviously wrong there.  :-)

[21:45] <moritz_> dolmen: [ ] send patch!

[21:46] * dolmen is a rakudo newbie

[21:46] <pmurias> mncharity: shouldn't the code which elf runs be run in a seperate package?

[21:46] <pmichaud> a lot of things got added to rakudo during my "absence" that I haven't had a chance to check yet.

[21:46] * dolmen is a parrot newbie

[21:46] <pmichaud> infix:xx would be another of those :-)

[21:46] <diakopter> is there a way to quit REPL ./perl6 (rakudo) other than Ctrl-C?

[21:47] <pmichaud> ctrl-D ?

[21:47] <moritz_> did you try Ctrl+D?

[21:47] <mncharity> ﻿pmurias: '﻿the code which elf runs', huh?

[21:47] <pmurias> elf_f_faste -e 'say 3', compile 'say 3' and runs it

[21:47] <diakopter> ... other than Ctrl-.

[21:48] <pmurias> exit()?

[21:48] <mncharity> runs it in Main, per spec, no?

[21:48] <moritz_> yes

[21:49] <pmurias> but the compiler package hierarchy is different from the compiled code package hierarchy

[21:49] <diakopter> exit does the same as pressing enter on a blank line; seemingly nothing.

[21:49] <Auzon> die "get me out of here!"; # maybe?

[21:49] <moritz_> doesn't exit the REPL

[21:50] <Auzon> Oh. Right, because of the Eval.

[21:50] <pmurias> defining a sub in the compiler namespace shouldn't change the compiler

[21:50] <pmurias> * redefining

[21:50] <moritz_> but as long as variables aren't persistent over multiple exuctions I won't use the REPL very much

[21:51] <mncharity> elf should at some point allow you to specify the p5 root (perhaps p6 root?) of the package tree.  so instead of taking over the p5 interpreter, and fighting with any other p6 implementation using it simulatneously, one could instead say 'use p5; package Foo; use Elf; Foo::eval('say $?PACKAGE'); #=> "Main", but really "Foo::Main".

[21:51] <moritz_> not even 'our' vars, so it's not scope issue

[21:52] <mncharity> ﻿pmurias: 'defining a sub in the compiler namespace shouldn't change the compiler', if it's a compile time definition, eg, inside a BEGIN{}, then yes, it should.

[21:53] <rakudo_svn> r27825 | pmichaud++ | [rakudo]:

[21:53] <rakudo_svn> r27825 | pmichaud++ | * Add dies_ok and lives_ok to Test.pm

[21:53] <rakudo_svn> r27825 | pmichaud++ | * Patch courtesy Vasily Chekalkin <bacek at bacek.com>

[21:53] <rakudo_svn> r27825 | pmichaud++ | * Resolves RT#54826 (bacek++)

[21:54] <mncharity> re redefining, oh, as for  elf_f_faster EmitSimpleP5.pm -e 'say 3',

[21:55] <pmurias> yes

[21:55] <pmurias> i'm sure that is not legal

[21:55] <mncharity> just because ﻿elf_f_faster was previously compiled, doesn't mean it's own version of ﻿EmitSimpleP5.pm is off invisible somewhere.  the compiler is just normal code.

[21:57] <pmurias> i'll have to search the spec/irc log to challange it

[21:57] <pmurias> moritz_: is there a way to search the log for non-alphanumerics?

[21:57] <mncharity> you could hypothetically compile a program which didn't use eval() into an executable which didn't include the compiler.  but () that's not implemented, and () then ﻿EmitSimpleP5 wouldn't run at all because it would be missing the rest of the compiler.  you'd have to say  ﻿elf_f_stripped Elf.pm -e 'say 3'

[21:58] *** justatheory joined
[21:58] <moritz_> pmurias: if you give me a mysql query I'll run it

[21:59] <moritz_> pmurias: but otherwise no, don't think so

[21:59] <pmurias> why?

[21:59] <pmurias> why does the search ignore non-alphanumerics?

[22:00] <pmurias> mncharity: what i imagine is that the compiled code lives in CURRENTLY_COMPILED_CODE_PACKAGE::

[22:01] <moritz_> pmurias: it's the way mysql fulltext indexes work. :/

[22:01] <pmurias> mysql--

[22:01] <Auzon> karma mysql

[22:01] <Auzon> @karma mysql

[22:01] <lambdabot> mysql has a karma of -1

[22:02] <pmurias> and it cannot harass the compiler because EmitSimpleP5 is translated into SOMETHING::EmitSimpleP5

[22:03] <mncharity> ﻿pmurias: and is *eval()  GLOBAL::eval or ﻿CURRENTLY_COMPILED_CODE_PACKAGE::GLOBAL::eval?  and does it take a String or a ﻿CURRENTLY_COMPILED_CODE_PACKAGE::String?  and return a Code or a ﻿﻿﻿... etc.

[22:05] <mncharity> re Code, oh, I mean, eva(3) returns Int or CCCP::Int

[22:05] *** perl7 left
[22:06] <mncharity> "p6, the Compile Time lives"

[22:07] <pmurias> i suppose it's all CCCP::thing

[22:07] * moritz_ heads off to bed

[22:07] <Auzon> Good night moritz_.

[22:09] <pmurias> mncharity: eval(3) returns CCCP::Int

[22:09] *** cognominal_ left
[22:10] <pmurias> if it didn't it would be possible to modifi 3.HOW() and stop the compilation process

[22:11] *** wknight8111_ is now known as wknight8111

[22:16] <mncharity> let's see... so the idea is  elf EmitSimpleP5.pm -e 'say 3' should return an error (eg, because ESP assumes a $*compiler0 has been defined, when it hasn't).

[22:17] <mncharity> btw, it can't be CCCP::Int, or at least, on the p6 level, there must be no way to distinguish a CCCP::Int from an Int, including comparing Int and eval("Int") class objects.

[22:18] <dolmen> rakudo: 3 x 4

[22:18] <exp_evalbot> RESULT["3333"]

[22:18] <dolmen> rakudo: 3 xx 4

[22:18] <exp_evalbot> OUTPUT[Could not invoke non-existent sub x␤current instr.: '_block11' pc 34 (EVAL_11:19)␤

[22:18] <dolmen> rakudo: 3 xy 4

[22:18] <exp_evalbot> OUTPUT[Could not invoke non-existent sub y␤current instr.: '_block11' pc 34 (EVAL_11:19)␤

[22:19] <dolmen> looks like the grammar doen't recognize infix:xx

[22:19] <pmichaud> looks to me as though rakudo doesn't recognize 'xx' as an operator.

[22:19] <dolmen> where should I look at?

[22:19] <pmichaud> src/parser/grammar-oper

[22:19] <pmichaud> src/parser/grammar-oper.pg

[22:19] <pmichaud> infix:<x> is there, but infix:<xx> isn't.

[22:19] <Auzon> perl6: try {die 'qwerty}

[22:20] <Auzon> doh

[22:20] <Auzon> perl6: try {die 'qwerty'}; say $!;

[22:20] <exp_evalbot> kp6: No output (you need to produce output to STDOUT)

[22:20] <exp_evalbot> ..pugs: OUTPUT[*** ␤    Unexpected end of input␤    expecting "\\", variable name or "'"␤    at /tmp/hvHaMIljIX line 2, column 1␤]

[22:20] <exp_evalbot> ..rakudo: OUTPUT[Statement not terminated properly at line 1, near "'qwerty}"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[22:20] <exp_evalbot> ..elf: OUTPUT[Parse error in: /tmp/FClm1BAZ7O␤panic at line 1 column 10 (pos 10): Error in quotesnabber␤WHERE: try {die 'qwerty}␤WHERE:          /\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:1286:in `quotesnabber'␤  (eval):1:in `__quote_8146019'␤  STD_red/prelude.rb:404:in `block

[22:20] <exp_evalbot> ..in longest_token_match'␤  STD_red/prelude.rb:400:in `eac...

[22:20] <exp_evalbot> kp6: OUTPUT[syntax error at position 24, line 1 column 24:␤try {die 'qwerty'}; say $!␤                        ^ HERE␤]

[22:20] <exp_evalbot> ..pugs: OUTPUT[qwerty␤]

[22:20] <exp_evalbot> ..rakudo: OUTPUT[qwerty␤]

[22:20] <exp_evalbot> ..elf: OUTPUT[Bad file descriptor␤]

[22:21] <Auzon> aha. $! is specced in S04, not S02

[22:21] *** wknight8111 left
[22:22] *** wknight8111 joined
[22:23] * mncharity ponders ﻿3.HOW()...

[22:24] <pmurias> implementing it?

[22:24] *** cognominal_ joined
[22:24] <pmurias> -x is broken

[22:25] <pmurias> perl elf_f_faster -x test.p6 > out;perl out produces an error

[22:25] <pmurias> while perl elf_f_faster test.p6 is ok

[22:26] *** Chillance left
[22:28] *** cognominal_ left
[22:28] <mncharity> re  ﻿﻿﻿elf_f_faster -x test.p6 > out, it sounds like you want an ﻿﻿ elf_f_faster -o out test.p6 , which include the prelude and such in addition to test.p6.   ﻿﻿﻿but which doesn't exist yet.

[22:29] <pmurias> with test.p6 being class Foo { };my $foo = Foo.new();

[22:30] <mncharity> one could say  elf -x -o out Prelude.pm PrimitivesP5.pm test.p6... it might even work?

[22:30] <rakudo_svn> r27827 | pmichaud++ | [rakudo]:

[22:30] <rakudo_svn> r27827 | pmichaud++ | * Fix [] subscripts to use keyed_int.

[22:31] <Auzon> In pugs/t/, what is the consensus on indenting? Tabs don't seem to show up in the smartlinks in the synopses.

[22:32] <pmurias> mncharity: i'll go to sleep as my productivity is extremly low now

[22:32] * pmurias yaws

[22:32] <mncharity> good god, no tabs.   any tabs, not-explicitly there as tabs for testing, should be removed on sight.

[22:32] <mncharity> lol

[22:32] <mncharity> good night ﻿pmurias :)

[22:32] <pmurias> good night

[22:32] *** pmurias left
[22:33] <Auzon> eek. OK, ok, no tabs

[22:34] <mncharity> *chuckle*

[22:36] <Auzon> I'll keep them in my own projects. ;)

[22:36] <mncharity> basically the convention is the pugs repo is a tab-free-environment. :)

[22:36] *** justatheory left
[22:37] <mncharity> oh, modulo Makefiles of course, where they are semantically significant. :/

[22:38] <mncharity> 'we realized it was a mistake, but we had 20 users by then, so we couldn't change it'...

[22:38] <Auzon> Yep. I read that.

[22:38] <mncharity> (paraphrase)

[22:39] *** cognominal_ joined
[22:40] <SamB> mncharity: at the time that might have been a reasonable statement

[22:42] <mncharity> I don't disagree... but would be unsurprised to find that has cost a person life worth of time in the years since.

[22:43] <mncharity> *it has

[22:44] <mncharity> i'm off.  have fun all &

[22:45] <Auzon> See you, mncharity

[22:45] *** mncharity left
[22:45] <Auzon> pugs: try {die 'qwerty'} say $!

[22:45] <exp_evalbot> OUTPUT[*** ␤    Unexpected "say"␤    expecting operator␤    at /tmp/xZuvRDRI7B line 1, column 20␤]

[22:45] <Auzon> pugs: try {die 'qwerty'}; say $!

[22:45] <exp_evalbot> OUTPUT[qwerty␤]

[22:45] <Auzon> pugs: try {die 'qwerty'}; say $! ~~ /qwerty/;

[22:45] <exp_evalbot> OUTPUT[␤]

[22:46] <Auzon> pugs: try {die 'qwerty'}; say ~$! ~~ /qwerty/;

[22:46] <exp_evalbot> OUTPUT[␤]

[22:46] *** meppel-san is now known as meppl

[22:46] <Auzon> pugs: try {die 'qwerty'}; say ~$! ~~ /q/;

[22:46] <exp_evalbot> OUTPUT[␤]

[22:47] <Auzon> pugs: try {die 'qwerty'}; say $!.match(/q/);

[22:47] <exp_evalbot> OUTPUT[␤]

[22:47] <Auzon> rakudo: try {die 'qwerty'}; say $!.match(/q/);

[22:47] <exp_evalbot> OUTPUT[Method 'match' not found for invocant of class 'Exception'␤current instr.: '_block11' pc 72 (EVAL_12:33)␤

[22:49] <dolmen> how can I print a list, formatted

[22:49] <dolmen> with somlething like join in raduko?

[22:50] <Auzon> rakudo: say (1 .. 10).join(', ');

[22:50] <exp_evalbot> OUTPUT[1, 2, 3, 4, 5, 6, 7, 8, 9, 10␤]

[22:50] <Auzon> Like that?

[22:50] <dolmen> yes

[22:51] <Auzon> rakudo: (1 .. 10).join(', ').say; # pure OO?

[22:51] <exp_evalbot> OUTPUT[1, 2, 3, 4, 5, 6, 7, 8, 9, 10␤]

[22:53] <dolmen> do you have a map example?

[22:54] <Auzon> rakudo: (1 .. 10).map({$_ + 5}).join(', ').say;

[22:54] <exp_evalbot> OUTPUT[Method 'map' not found for invocant of class 'List'␤current instr.: '_block11' pc 63 (EVAL_11:25)␤

[22:54] <dolmen> :(

[22:54] <Auzon> rakudo: my @a = 1 .. 10; @a.map({$_ + 5}).join(', ').say;

[22:54] <exp_evalbot> OUTPUT[Method 'map' not found for invocant of class 'List'␤current instr.: '_block11' pc 78 (EVAL_11:32)␤

[22:54] <Auzon> hum.

[22:55] <dolmen> well... how can I check that a value I get is a list of lists?

[22:56] <dolmen> rakudo: ((1..2) X (3..4)).join(', ').say

[22:56] <exp_evalbot> OUTPUT[1 3, 1 4, 2 3, 2 4␤]

[22:57] <dolmen> is there something like a typeof operator?

[22:57] <Auzon> rakudo: my @a = (1..2) X (3..4); for (@a) {say $_.WHAT}

[22:57] <exp_evalbot> OUTPUT[Num␤Num␤]

[22:57] <dolmen> cool

[22:57] <Auzon> rakudo: my @a = ((1..2) X (3..4)); for (@a) {say $_.WHAT}

[22:57] <exp_evalbot> OUTPUT[Num␤Num␤Num␤Num␤Num␤Num␤Num␤Num␤]

[22:58] <Auzon> rakudo: my @a = [1,2], [3,4]; for (@a) {say $_.WHAT}

[22:58] <exp_evalbot> OUTPUT[Int␤Int␤]

[22:58] <Auzon> rakudo: my @a = [1,2], [3,4]; for (@a) {say .WHAT}

[22:58] <exp_evalbot> OUTPUT[No result object␤current instr.: 'parrot;PCT::Grammar;item' pc 48 (src/PCT/Grammar.pir:64)␤

[22:58] <Tene> Yeah, that's NYI, I guess.

[22:58] <Tene> I can look at it tomorrow evening if you remind me.

[22:59] <Auzon> rakudo: say ([1,2], [3,4]).perl

[22:59] <exp_evalbot> OUTPUT[[1, 2, 3, 4]␤]

[22:59] <Auzon> mhm. I think that's wrong.

[22:59] <Tene> It is.  pmichaud++ still has work on list context queued.

[23:00] <pmichaud> anything involving arrays or hashes is suspect in rakudo at the moment.

[23:00] <dolmen> how do I submit a patch?

[23:00] <pmichaud> until we get list context resolved.

[23:00] <pmichaud> dolmen: for rakudo?  see README

[23:01] <dolmen> sorry, rtfm ;)

[23:03] <dolmen> rakudo: when does mean "assoc(list)" in grammar-oper.pg

[23:03] <exp_evalbot> OUTPUT[Statement not terminated properly at line 1, near "in grammar"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[23:03] <dolmen> humans: when does mean "assoc(list)" in grammar-oper.pg ?

[23:03] <dolmen> s/when/what/

[23:03] <pmichaud> it means an operator has "list" associativity.  See S03.

[23:04] <pmichaud> also described in S06, under "is assoc".

[23:08] <Auzon> Is it possible to get an Exception's text? I want to be able to match it with a regex.

[23:08] <pmichaud> isn't that just ~$!  ?

[23:08] <Auzon> perl6: try {die "qwerty"}; say (~$!).WHAT;

[23:09] <exp_evalbot> kp6: OUTPUT[syntax error at position 24, line 1 column 24:␤try {die "qwerty"}; say (~$!).WHAT␤                        ^ HERE␤]

[23:09] <exp_evalbot> ..pugs: OUTPUT[Str␤]

[23:09] <exp_evalbot> ..rakudo: OUTPUT[Str␤]

[23:09] <exp_evalbot> ..elf: OUTPUT[Int␤]

[23:09] <Auzon> perl6: try {die "qwerty"}; say (~$!) ~~ /q/;

[23:09] <exp_evalbot> kp6: OUTPUT[syntax error at position 24, line 1 column 24:␤try {die "qwerty"}; say (~$!) ~~ /q/␤                        ^ HERE␤]

[23:09] <exp_evalbot> ..pugs: OUTPUT[␤]

[23:09] <exp_evalbot> ..rakudo: OUTPUT[q␤]

[23:09] <exp_evalbot> ..elf: OUTPUT[syntax error at (eval 15) line 4, near ") ~"␤ at ./elf_f_faster line 4456␤]

[23:09] <Auzon> That ought to work

[23:11] <meppl> good night

[23:11] <Auzon> Night, meppl

[23:12] <meppl> ;)

[23:13] *** meppl left
[23:15] <Auzon> pugs: use Test;

[23:15] <exp_evalbot> OUTPUT[pugs: *** Unsafe function 'use' called under safe mode␤    at /tmp/tFPdq2kj94 line 1, column 1␤]

[23:15] <Auzon> rakudo: use Test;

[23:15] <exp_evalbot> OUTPUT[Error: file cannot be read: Test.pm␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[23:16] <dolmen> what is the Perl6 length operator/function for a list?

[23:16] <Auzon> .elems

[23:16] <Auzon> rakudo: (1..10).elems

[23:16] <exp_evalbot> RESULT[10]

[23:16] <wolverian> or Num context

[23:16] <Auzon> rakudo: +(1..10)

[23:16] <exp_evalbot> RESULT[10]

[23:16] <wolverian> rakudo: +("a".."c")

[23:16] <dolmen> perl6: my @a = (1,2) xx 4; say @a.elems;

[23:17] *** exp_evalbot left
[23:17] <wolverian> whoops...

[23:17] *** exp_evalbot joined
[23:17] <Auzon> xx is broken somewhere.

[23:17] <wolverian> 1..10 is a bad test, since the last element equals the count of elems

[23:17] <dolmen> I'm working on it

[23:17] <wolverian> that's confusing for a perl5 coder

[23:17] <Auzon> True, wolverian.

[23:17] <Auzon> rakudo: (5 .. ^10).elems

[23:17] <exp_evalbot> RESULT[6]

[23:17] * dolmen will submit his first Perl6/rakudo patch in a few minutes...

[23:17] <Auzon> rakudo: (5 .. ^10)

[23:18] <exp_evalbot> RESULT[[5, 6, 7, 8, 9, 10]]

[23:18] <Auzon> That's wrong.

[23:18] <Auzon> pugs: (5 .. ^10)

[23:18] <exp_evalbot> RESULT[(5, 6, 7, 8, 9, 10)]

[23:18] <dolmen> pugs: my @a = (1,2) xx 4; say @a.elems;

[23:18] <exp_evalbot> OUTPUT[8␤]

[23:18] <Auzon> That's wrong, too, I think... :-/

[23:18] <dolmen> pugs: my @a = (1,2,'a') xx 4; say @a.elems;

[23:18] <exp_evalbot> OUTPUT[12␤]

[23:19] <Auzon> pugs: ^4

[23:19] <exp_evalbot> RESULT[(0.0, 1.0, 2.0, 3.0)]

[23:19] <dolmen> pugs: my @a = 'a' xx 4; say @a.elems;

[23:19] <exp_evalbot> OUTPUT[4␤]

[23:19] <Auzon> pugs: 1 .. ^4

[23:19] <exp_evalbot> RESULT[(1, 2, 3, 4)]

[23:19] <Auzon> Ah. ^ isn't working properly there

[23:20] <Auzon> but on its own, it's fine

[23:21] <dolmen> pugs: my @a = 'a' x 4; say @a.elems;

[23:21] <exp_evalbot> OUTPUT[1␤]

[23:21] *** chris2 left
[23:21] <dolmen> pugs: my $a = 'a' x 4; say @a.elems;

[23:21] <exp_evalbot> OUTPUT[*** ␤    Unexpected "."␤    expecting "::"␤    Variable "@a" requires predeclaration or explicit package name␤    at /tmp/itbWWYCMm7 line 1, column 24␤]

[23:21] <dolmen> pugs: my $a = 'a' x 4; say $a.elems;

[23:21] <exp_evalbot> OUTPUT[1␤]

[23:21] <dolmen> pugs: my @a = 1,2 xx 4; say @a.elems;

[23:21] <exp_evalbot> OUTPUT[5␤]

[23:21] <dolmen> pugs: my @a = (1,2) xx 4; say @a.elems;

[23:21] <exp_evalbot> OUTPUT[8␤]

[23:22] <dolmen> pugs: my @a = ((1,2)) xx 4; say @a.elems;

[23:22] <exp_evalbot> OUTPUT[8␤]

[23:22] <Auzon> pugs: "abcd".elems.say

[23:22] <exp_evalbot> OUTPUT[1␤]

[23:22] <pmichaud> pugs: my @a = (1,2) xx 4; say @@a.elems;

[23:22] <exp_evalbot> OUTPUT[*** ␤    Unexpected "."␤    expecting "::"␤    Variable "@@a" requires predeclaration or explicit package name␤    at /tmp/1xZiG7ZsUR line 1, column 28␤]

[23:22] <pmichaud> pugs: my @a = [1,2] xx 4; say @a.elems;

[23:22] <exp_evalbot> OUTPUT[8␤]

[23:23] <pmichaud> hmmm.

[23:23] <dolmen> how can/(should I be able to) get a list of lists?

[23:23] <pmichaud> I would think that [1,2] xx 4;  would do it

[23:23] <Auzon> in Rakudo, you may not be able to.

[23:23] <Auzon> Pugs... who knows.

[23:23] <pmichaud> rakudo doesn't know list context very well yet.

[23:23] <dolmen> Auzon: I trying to fix it in rakudo

[23:23] <Auzon> I think that [1,2] xx 4 should as well.

[23:24] <Auzon> Because there's no flattening there, correct?

[23:24] <pmichaud> pugs:  my $a = [1,2];   say ($a xx 4).elems

[23:24] <exp_evalbot> OUTPUT[8␤]

[23:25] <dolmen> Is it right or wrong?

[23:25] <Auzon> pugs: my $a = [1,2]; ($a xx 4).perl

[23:25] <exp_evalbot> RESULT["(1, 2, 1, 2, 1, 2, 1, 2)"]

[23:25] <Auzon> That's wrong. It should be grouped somehow.

[23:25] <Auzon> hm

[23:26] <Auzon> not sure. I'll have to check the specs when I can

[23:26] <pmichaud> I think pugs is broken there.  I'm pretty sure rakudo will have difficulty with list flattening for a little while longer.

[23:27] <dolmen> I'm at the point where I can get the same wrong result as Pugs for xx...

[23:27] *** alester left
[23:28] <Auzon> I'll mark testing this on my list of things to do.

[23:28] <Auzon> Right now, I have some reorganization that I want to get done before I lose my place

[23:29] *** meteorjay left
[23:29] *** pbuetow left
[23:30] <dolmen> in PIR, how can I push a list in a list without ti to be flattened ?

[23:31] <Auzon> dolmen: Are you in #parrot on irc.perl.org? They know PIR better.

[23:31] <dolmen> ok

[23:31] <Auzon> We can still help with general perl6 stuff, and there's some overlap

[23:33] *** BinGOs left
[23:36] <pugs_svnbot> r20546 | Auzon++ | dollar_underscore.t -> dollar_bang.t since the test is really about $! and not $_. also added two new test cases.

[23:36] <dolmen> S03 says about xx: If the operator is being evaluated in ordinary list context, the operator returns a flattened list.

[23:36] <dolmen> So pugs seems right.

[23:37] <dolmen> No?

[23:37] <dolmen> pugs: my @a = ((1,2)) xx 0; say @a.elems;

[23:37] <exp_evalbot> OUTPUT[0␤]

[23:37] <dolmen> pugs: my @a = ((1,2)) xx 0; say @a.perl;

[23:37] <exp_evalbot> OUTPUT[[]␤]

[23:38] <wolverian> pugs: @@ (1,2) xx 3

[23:38] <exp_evalbot> OUTPUT[*** ␤    Unexpected " ("␤    expecting "::"␤    at /tmp/b0llIyVnfX line 1, column 3␤]

[23:38] <dolmen> pugs: my @a = [1,2] xx 0; say @a.perl;

[23:38] <exp_evalbot> OUTPUT[[]␤]

[23:38] <wolverian> where's my chunks :)

[23:38] <dolmen> pugs: my @a = @@ [1,2] xx 0; say @a.perl;

[23:38] <exp_evalbot> OUTPUT[*** ␤    Unexpected "@a"␤    expecting "=", "::", context, ":" or "("␤    at /tmp/nkN8RhU1nf line 1, column 4␤]

[23:39] <dolmen> pugs: my @a = @@ ([1,2] xx 0); say @a.perl;

[23:39] <exp_evalbot> OUTPUT[*** ␤    Unexpected "@a"␤    expecting "=", "::", context, ":" or "("␤    at /tmp/P6dfj0Ei1D line 1, column 4␤]

[23:39] <dolmen> pugs: my @a = @([1,2] xx 0); say @a.perl;

[23:39] <exp_evalbot> OUTPUT[[]␤]

[23:39] <dolmen> pugs: my @a = @@([1,2] xx 0); say @a.perl;

[23:39] <exp_evalbot> OUTPUT[*** Unknown syntactic construct: Syn "@@{}" [Ann (Pos (MkPos "/tmp/GVjbGDzrAQ" 1 12 1 22)) (App (Var "&infix:xx") Nothing [Syn "\\[]" [Ann (Pos (MkPos "/tmp/GVjbGDzrAQ" 1 13 1 16)) (Syn "," [Val (VInt 1),Val (VInt 2)])],Val (VInt 0)])]␤    at /tmp/GVjbGDzrAQ line 1, column 9-23␤]

[23:40] <dolmen> rakudo: my @a = @@([1,2] xx 0); say @a.perl;

[23:40] <exp_evalbot> OUTPUT[Statement not terminated properly at line 1, near "= @@([1,2]"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[23:45] <dolmen> pmichaud, rakudo patch sent : infix:<xx>

[23:50] <pmichaud> rakudo doesn't understand @@ yet.

[23:50] <pmichaud> I don't know if pugs understands @@ yet.

[23:51] <pmichaud> pugs:  my @a = ([1, 2], [1, 2]);  say @a.elems;

[23:51] <exp_evalbot> OUTPUT[2␤]

[23:51] <pmichaud> pugs:  my @a = ([1, 2], [1, 2]);  say (@a, ()).elems;

[23:51] <exp_evalbot> OUTPUT[2␤]

[23:52] <pmichaud> I would expect   say ([1,2] x 2, ()).elems to return the same result

[23:52] <pmichaud> pugs:  say([1,2] xx 2, ()).elems

[23:52] <exp_evalbot> OUTPUT[1212␤]

[23:52] <pmichaud> oops

[23:52] <pmichaud> pugs:  say ([1,2] xx 2, ()).elems

[23:52] <exp_evalbot> OUTPUT[4␤]

[23:53] <pmichaud> so I think pugs is not quite right there.  [1,2] isn't a list, it's an array.

[23:58] <dolmen> perl6: [1, 2].perl

[23:58] <exp_evalbot> kp6: RESULT['[ 1, 2 ]']

[23:58] <exp_evalbot> ..pugs: RESULT["[1, 2]"]

[23:58] <exp_evalbot> ..rakudo: RESULT["[1, 2]"]

[23:58] <exp_evalbot> ..elf: RESULT['[1,2]'␤]

[23:58] <dolmen> perl6: (1, 2).perl

[23:58] <exp_evalbot> kp6: RESULT['( 1, 2 )']

[23:58] <exp_evalbot> ..pugs: RESULT["(1, 2)"]

[23:58] <exp_evalbot> ..rakudo: RESULT["[1, 2]"]

[23:58] <exp_evalbot> ..elf: RESULT['2'␤]

[23:59] <pmichaud> pugs: say (1..3) xx -4;

[23:59] <exp_evalbot> OUTPUT[␤]

