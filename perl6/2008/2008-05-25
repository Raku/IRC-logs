[00:02] *** Limbic_Region joined
[00:03] *** jisom left
[00:11] *** braceta joined
[00:41] *** elmex left
[00:58] <meppl> good night

[01:04] <pugs_svnbot> r20524 | putter++ | [STD_red] Extend the plurality_declarator STD.pm bug workaround.

[01:04] <mncharity> good night meppl

[01:05] <meppl> ;)

[01:05] *** meppl left
[01:05] <vixey> hey mncharity :)

[01:06] <mncharity> hi vixey.  how goes?

[01:06] <vixey> good ty, how about you?

[01:06] <mncharity> eh.  wishing p5 had a more usable multimethods module. :/

[01:07] <vixey> Lisp has a good multimethods..

[01:09] <mncharity> yeah, but I was waiting to write my CL to p5 converter until after I had p6 sort of working.

[01:09] <mncharity> ;)

[01:11] <vixey> :o

[01:11] <mncharity> moritz_: what language is  $program = '( ( do { ' . $program . "\n} ).perl ).print";   in?  It has .methods but also . string concat.  ??

[01:12] * mncharity goes to look at evalbot while regressions run...

[01:16] <TimToady> btw, for @foo -> { $^a, $^b } is actually semantically illegal; you're not supposed to mix real sigs with placeholders, and the -> introduces a sig of ()

[01:16] <mncharity> oohhhhh.  the issue isn't that evalbot is adding a wrapper, but that elf -e '3' doesn't produce any output...

[01:17] * mncharity checks placeholders.t ...

[01:18] <mncharity> or better yet, Auzon: ^^^ todo ;)

[01:18] * TimToady goes to dinner with a gaggle of teen quizzers... &

[01:18] <mncharity> no, that's not fair.  checking placeholders...

[01:19] <mncharity> ﻿/me has trouble parsing "gaggle of teen quizzers".  say that ten times fast.

[01:26] *** Ched- joined
[01:31] <pugs_svnbot> r20525 | putter++ | t/blocks/pointy.t: -> { $^a, $^b } is illegal.

[01:35] <rakudo_svn> r27792 | pmichaud++ | [rakudo]:

[01:35] <rakudo_svn> r27792 | pmichaud++ | * Add Any.can().

[01:35] <pugs_svnbot> r20526 | putter++ | [elf_f] Added multi subs.  Allow greater use of multi methods (using Class::Multimethods).

[01:38] <mncharity> perl6: 34

[01:38] <pugs_svnbot> r20527 | putter++ | [elf] Update run-tests.result_faster.

[01:38] <exp_evalbot> kp6: RESULT[34]

[01:38] <exp_evalbot> ..pugs: RESULT[34]

[01:38] <exp_evalbot> ..rakudo: RESULT[34]

[01:38] <exp_evalbot> ..elf: RESULT[syntax error at (eval 15) line 3, near "GLOBAL::statement_prefix:"␤ at ./elf_f_faster line 4495␤]

[01:42] <mncharity> ﻿moritz_: nm, sorry, got it.

[01:43] *** Limbic_Region left
[02:01] *** jhorwitz left
[02:05] <mncharity> perl6: [3,4,5].Str

[02:05] <exp_evalbot> kp6: RESULT['3 4 5']

[02:05] <exp_evalbot> ..pugs: OUTPUT[*** No such method in class Array: "&Str"␤    at /tmp/E6O3iEPOBR line 1, column 1 - line 2, column 1␤]

[02:05] <exp_evalbot> ..rakudo: OUTPUT[Method 'Str' not found for invocant of class 'List'␤current instr.: '_block11' pc 56 (EVAL_11:22)␤called from Sub 'parrot;PCT::HLLCompiler;eval' pc 783 (src/PCT/HLLCompiler.pir:458)␤called from Sub 'parrot;PCT::HLLCompiler;evalfiles' pc 1065 (src/PCT/HLLCompiler.pir:587)␤called

[02:05] <exp_evalbot> ..from Sub 'parrot;PCT::HLLCompiler;command_line' pc 1244 (src/...

[02:06] <exp_evalbot> ..elf: OUTPUT[Can't call method "Str" on unblessed reference at (eval 15) line 3.␤ at ./elf_f_faster line 4533␤]

[02:06] <mncharity> ﻿kp6: say [3,4,5]

[02:06] <mncharity> kp6: say [3,4,5]

[02:06] <exp_evalbot> r20527: OUTPUT[3 4 5␤]

[02:08] <mncharity> rakudo: :a<3>

[02:08] <exp_evalbot> OUTPUT[Null PMC access in type()␤current instr.: 'parrot;PAST::Compiler;keyed' pc 6062 (src/PAST/Compiler.pir:1694)␤

[02:08] <mncharity> pugs: :a<3>

[02:08] <exp_evalbot> RESULT[("a" => "3")]

[02:14] <pugs_svnbot> r20528 | putter++ | [elf] Handle do{} and try{}.  Added .print().  In support of evalbot.

[02:18] <mncharity> kp6: undef.Str

[02:18] <exp_evalbot> r20528: OUTPUT[DISPATCH: calling Str on invalid object:$VAR1 = undef;␤␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 128␤     main::DISPATCH('undef', 'Str') called at - line 11␤]

[02:22] <mncharity> elf: 3

[02:22] <exp_evalbot> RESULT[3␤]

[02:22] <mncharity> woho

[02:22] <mncharity> err,woo hoo

[02:23] *** bacek joined
[02:26] <pugs_svnbot> r20529 | putter++ | [elf] Added .Str().  say() rewritten using it.

[02:26] <mncharity> perl6: say(undef)

[02:27] *** Psyche^ joined
[02:27] <exp_evalbot> kp6: OUTPUT[Undef␤]

[02:27] <exp_evalbot> ..pugs: OUTPUT[␤]

[02:27] <exp_evalbot> ..rakudo: OUTPUT[␤]

[02:27] <exp_evalbot> ..elf: OUTPUT[␤]

[02:27] * mncharity wonders if say(undef) should be "" or an error

[02:32] <bacek> perl6: my $x=sub { say $_; }; $x('hello');

[02:32] <exp_evalbot> kp6: RESULT[error in Block at compiled/perl5-kp6-mp6/lib/KindaPerl6/Grammar/Sub.pm line 753, <> line 1.␤*** Syntax Error in Block: missing closing curly bracket  ␤]

[02:32] <exp_evalbot> ..pugs: OUTPUT[hello␤]

[02:32] <exp_evalbot> ..rakudo: OUTPUT[hello␤]

[02:32] <exp_evalbot> ..elf: OUTPUT[Can't call method "Str" on an undefined value at ./elf_f_faster line 665.␤ at ./elf_f_faster line 4577␤]

[02:40] *** Patterner left
[02:40] *** Psyche^ is now known as Patterner

[03:00] <mncharity> rakudo: Object.isa(Any)

[03:00] <exp_evalbot> No output (you need to produce output to STDOUT)

[03:00] <mncharity> rakudo: say Object.isa(Any)

[03:00] <exp_evalbot> No output (you need to produce output to STDOUT)

[03:00] <mncharity> rakudo: say 3

[03:00] <exp_evalbot> OUTPUT[3␤]

[03:01] <mncharity> rakudo: say Object.isa("Any")

[03:01] <exp_evalbot> No output (you need to produce output to STDOUT)

[03:01] <spinclad> rakudo: say Object

[03:01] <exp_evalbot> OUTPUT[Object␤]

[03:02] <Eevee> rakudo: say (Object.isa("Any") ?? 1 !! 0)

[03:02] <exp_evalbot> OUTPUT[Statement not terminated properly at line 1, near "?? 1 !! 0)"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[03:02] <Eevee> rakudo: say (Object.isa("Any") || 42)

[03:02] <exp_evalbot> No output (you need to produce output to STDOUT)

[03:02] <mncharity> I'm trying to figure out the relationship between Object and Any.

[03:02] <Eevee> uh

[03:03] <Eevee> rakudo: say (Object.isa("Any") && 42)

[03:03] <exp_evalbot> No output (you need to produce output to STDOUT)

[03:03] <Eevee> wtf

[03:03] <Eevee> that doesn't make any sense

[03:03] <Eevee> apparently between Object and Any is a black hole that consumes all output

[03:03] <mncharity> actually, nm.  Object is an Any or Junction.  snn

[03:03] <mncharity> re hole, :)

[03:04] <mncharity> err, sigh.  "Any         Perl 6 object (default parameter type, excludes Junction)",     "Object      Perl 6 object (either Any or Junction)".

[03:05] <mncharity> so is Any an Object, or no?  seems no, but called a "﻿Perl 6 object".  maybe little-o object.

[03:06] <Eevee> sounds like it

[03:06] <Eevee> Object is absolutely anything

[03:06] <mncharity> but then can Any.can() ?

[03:07] <Eevee> Any is any deterministic value

[03:07] <Eevee> which is an odd distinction to make

[03:07] <Eevee> especially since that means the object hierarchy has two roots..

[03:07] <Eevee> s/object/class

[03:08] <mncharity> sigh, no, Object has to be the base, rather than Any.  Else Junction isn't rooted.  Too late in the day for prelude type topology puzzles. :/

[03:09] <Eevee> that would certainly make more sense

[03:09] <mncharity> which leaves me back wondering where I created a Moose::Object type loop... weeee...

[03:09] <Eevee> but what is the compelling need to prevent Junctions being passed to functions with typeless parameters?

[03:17] <pmichaud> Any isa Object

[03:17] <pmichaud> the '.can' method is defined for Any objects

[03:17] <pmichaud> (S12)

[03:19] <pmichaud> for some reason, Object.isa() is causing a segfault in Parrot.

[03:19] <pmichaud> it should be "Method isa not found"

[03:20] <pmichaud> sorry, Object.can() is returning a segfault in parrot -- should be Method 'can' not found.

[03:22] <pmichaud> a-ha.  found it.

[03:23] <mncharity> :)

[03:23] <pmichaud> helps if we actually register the Object class as "Object"  :-)

[03:23] <mncharity> rakudo: class A {}; say A.new.Str

[03:23] <exp_evalbot> OUTPUT[Method 'Str' not found for invocant of class 'A'␤current instr.: '_block11' pc 37 (EVAL_11:17)␤

[03:23] <mncharity> kp6: class A{}; say A.new.Str

[03:23] <exp_evalbot> r20529: OUTPUT[A␤]

[03:24] <mncharity> choices, choices

[03:24] <pmichaud> haven't done overloading yet

[03:24] <pmichaud> that's later on our roadmap :-)

[03:24] <pmichaud> (unless we need it sooner)

[03:25] <mncharity> ah, so A.new.Str #=> "A" seems non-bogus?  ok...

[03:26] <pmichaud> well, I'm not sure what kp6 is doing is correct either

[03:26] <pmichaud> doesn't seem like it to me -- not sure that coercing A to a string should automatically become "A"

[03:27] <mncharity> :)  and the decision goes to... already running regression tests, so stays undefined. :)

[03:29] *** alc joined
[03:36] <rakudo_svn> r27793 | pmichaud++ | [rakudo]:

[03:36] <rakudo_svn> r27793 | pmichaud++ | * Forget to set the Perl6Object => Object mapping.

[03:36] <rakudo_svn> r27793 | pmichaud++ | * mncharity++ Eevee++ spinclad++

[03:37] <Eevee> my interpretation was completely wrong but thanks anyway  :P

[03:37] <pmichaud> your interpretation helped me figure out what was wrong, though :-)

[03:42] <pugs_svnbot> r20530 | putter++ | [elf] Adjust runtime inheritance to match spec.  Prelude Any methods are now inherited and available.

[03:42] <pugs_svnbot> r20530 | putter++ | [STD_red] Adjust the nonspec tweak on is_type to accept single-letter typenames.

[03:43] <mncharity> is it just me, or does  Object = {Junction, Any (root of objectness)} seem like it would be better as  Any = {Junction, Object (root of objectness)} ?

[03:47] <mncharity> while it's traditional to call your root "Object", with Junctions around, most of the things one associates with "Object" are not actually Object, but Any.  Where Any is subset of Object.  Which just seems really counter-expectation.

[03:47] <rakudo_svn> r27794 | pmichaud++ | [rakudo]:

[03:47] <rakudo_svn> r27794 | pmichaud++ | * Fix bug with $x(1) introduced by r27778

[03:47] <rakudo_svn> r27794 | pmichaud++ | * Reported by bacek++

[03:48] <mncharity> Though a great source of "Who's on first?  No Who is on second" style commedy.

[03:48] <pmichaud> huffmanization probably biases towards "Any"

[03:48] <Eevee> any() does not really help this matter

[03:49] <Eevee> 'Any' sounds a bit more all-encompassing than 'Object' too

[03:49] <mncharity> ".can is defined for any object?  Yes, Any.  So why isn't the definition in Object?  Because it's not defined on Object.  ..."

[03:49] <Eevee> maybe Any just needs a better name

[03:49] <Eevee> any better name

[03:49] <Eevee> oh ho ho

[03:50] <mncharity> oy

[03:50] <pmichaud> i.e., since "anything but junction" is what we expect to write most often, we would tend to use "Any" over "Object" for that purpose because it's shorter.

[03:50] <spinclad> C< Any = Object|Junction > makes more sense to me than C< Object = Any|Junction >  (despite "everything's an object, including junctions")

[03:51] <mncharity> s/Object/Base/ ?

[03:51] <pmichaud> fortunately I've taken myself out of holding strong positions on such issues.  :-)

[03:51] <Eevee> NotJunction

[03:52] <mncharity> It's easier to think of Any not including Junctions, then to also worry about objects not being Objects, but Any's.

[03:52] <mncharity> s/Object/Bottom/

[03:52] <spinclad> Root

[03:52] <Eevee> CollapsedWaveform..

[03:53] <spinclad> QuantumSuperposition ... oh, wait, that's taken

[03:53] <Eevee> imo the root should stay Object (tradition, common sense, etc..) but "Any" should be less ambiguous

[03:53] <Eevee> aha, but Any is anything BUT a QuantumSuperposition

[03:53] <Eevee> so

[03:54] <Eevee> the opposite of that is

[03:54] <Eevee> QuantumSubposition

[03:54] <spinclad> ClassicalObject

[03:54] <spinclad> Supposition

[03:54] <mncharity> So "Any is nice an short" seems plausible.  I don't understand the current state of Junctions to know whether excluding them should be the normal thing or no.  But Objects and objects being misassiciated seems a difficulty.

[03:54] <Eevee> Single?  eh then it doesn't sound like arrays etc are included

[03:55] <mncharity> re difficulty, at least, it managed to confuse me this evening.  again.  and I've been here, confused, several times before. :)

[03:56] *** rindolf joined
[03:57] <mncharity> elf: class A { }; A.new.perl

[03:57] <exp_evalbot> RESULT['A.new(!!!)'␤]

[03:58] <spinclad> re repeatedly confusing, that's well worth noting as a 'design smell'

[03:59] <mncharity> elf: class A { multi method f(Int $x){'i'~$x}; multi method f(Str $x){'s'~$x} }; my $a = A.new; say $a.f(3), $a.f("x");'

[03:59] <exp_evalbot> OUTPUT[Parse error in: /tmp/IV003o3trf␤panic at line 1 column 115 (pos 115): Error in quotesnabber␤WHERE: .new; say $a.f(3), $a.f("x");'␤WHERE:                              /\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:1277:in `quotesnabber'␤  (eval):1:in `__quote_7980768'␤ 

[03:59] <exp_evalbot> ..STD_red/prelude.rb:404:in `block in longest_token_matc...

[03:59] <spinclad> and i hereby let the issue go

[03:59] <mncharity> :)

[04:00] <mncharity> elf: class A { multi method f(Int $x){"i"~$x}; multi method f(Str $x){"s"~$x} }; my $a = A.new; say $a.f(3), $a.f("x");

[04:00] <exp_evalbot> OUTPUT[Possible attempt to put comments in qw() list at (eval 17) line 6.␤i3␤sx␤]

[04:01] <mncharity> ah, ok.

[04:03] <spinclad> (re huffman:  'Ob'?)

[04:04] <mncharity> Obj

[04:05] <spinclad> yes, fits tradition

[04:05] <spinclad> Int, Str, Num

[04:16] *** alester_ joined
[04:21] <rakudo_svn> r27795 | pmichaud++ | [rakudo]:

[04:21] <rakudo_svn> r27795 | pmichaud++ | * Set svn:ignore property for src/pmc/mutable.pmc .

[04:29] *** thestarslookdown joined
[04:29] <pugs_svnbot> r20531 | putter++ | [elf] Avoid multi's with Num args generating a silly p5 warning.

[04:30] <mncharity> good night all &

[04:30] <Auzon> good night mncharity

[04:31] <Auzon> Multimethods look neat :)

[04:31] <mncharity> :)

[04:31] <Auzon> and fast too. mncharity++

[04:31] <pugs_svnbot> r20532 | putter++ | [elf] $?PACKAGE $?MODULE $?CLASS $?FILE $?LINE now exist.  $?LINE value is 0.

[04:33] <mncharity> regrettably isn't dispatching on classes like Int for which an autobox-based class is being used.  And Class::Multimethods has no concept of ';' and non-dispatch-determining args, and is fixed arity, and ... etc.  Have to grab our own copy and tweak it.

[04:33] *** kanru left
[04:33] <Auzon> Sounds like fun. Maybe make it into Perl6::Multimethods or some such, a la Perl6::Say

[04:34] <pmichaud> pugs:  my @a = 1..5; my @b = 6..10; sub f($x, $y, *@z) { say $x, $y; };  f(@a, @b);

[04:34] <exp_evalbot> OUTPUT[12345678910␤]

[04:34] <pmichaud> pugs:  my @a = 1..5; my @b = 6..10; sub f($x, $y, *@z) { say $x, $y; };  f((@a, @b), 15);

[04:34] <exp_evalbot> OUTPUT[1 2 3 4 56 7 8 9 1015␤]

[04:34] <mncharity> one of the nice things about writing a compiler is you don't have to make it pretty or convenient for humans using p5.  so it will probably end up just some internal runtime code.

[04:35] <Auzon> That's usually easier :)

[04:35] <mncharity> *"it" being the emitted p5

[04:35] *** justatheory_ joined
[04:35] <pmichaud> pugs:  my @a = 1..5; my @b = 6..10; sub f($x, $y, *@z) { say $x, $y; };  f((@a, @b), 15, 20);

[04:35] <exp_evalbot> OUTPUT[1 2 3 4 56 7 8 9 1015␤]

[04:35] <Auzon> elf: say $?PACKAGE

[04:35] <exp_evalbot> OUTPUT[Global symbol "$PACKAGE" requires explicit package name at (eval 14) line 3.␤ at ./elf_f_faster line 4586␤]

[04:35] <pmichaud> pugs:  my @a = 1..5; my @b = 6..10; sub f($x, $y, *@z) { say $x, $y; };  f((@a, 0, @b), 15, 20);

[04:35] <exp_evalbot> OUTPUT[1 2 3 4 506 7 8 9 1015␤]

[04:36] <pmichaud> pugs:  my @a = 1..5; my @b = 6..10; sub f($x, $y, *@z) { say $x, $y; };  f((1..5, 0, 6..10), 15, 20);

[04:36] <exp_evalbot> OUTPUT[12345067891015␤]

[04:36] <mncharity> elf: package IForgotToHandleMain { say $?PACKAGE; }

[04:36] <exp_evalbot> OUTPUT[Global symbol "$PACKAGE" requires explicit package name at (eval 14) line 6.␤ at ./elf_f_faster line 4586␤]

[04:36] <mncharity> hmm,maybe not synced yet.

[04:36] <Auzon> Nope

[04:36] <Auzon> svn.pugscode.org is being unreliable for me.

[04:36] <Auzon> also on evalbot's server

[04:37] <Auzon> elf: say $?PACKAGE

[04:37] <exp_evalbot> OUTPUT[␤]

[04:37] <pmichaud> same here.

[04:37] <Auzon> I just manually synced elf

[04:37] <pmichaud> (unreliable svn.pugscode.org tonight)

[04:37] <Auzon> because I can :)

[04:38] <mncharity> lol

[04:38] <Auzon> elf: package Test {say $?PACKAGE;}

[04:38] <exp_evalbot> OUTPUT[Test␤]

[04:38] <Auzon> elf: package Test; say $?PACKAGE;

[04:38] <exp_evalbot> OUTPUT[Parse error in: /tmp/GVtlxUXO5X␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: package Test; say $?PACKAGE;␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[04:38] <exp_evalbot> ..STD_red/std.rb:210:in `_UNIT'␤  ./../STD_red/STD_red_run:108:in `ma...

[04:39] <pmichaud> pugs:  my @a = 1..5; my @b = 6..10; sub f($x, $y, *@z) { say $x, $y; };  f(list(@a, 0, @b), 15, 20);

[04:39] <exp_evalbot> OUTPUT[1 2 3 4 506 7 8 9 1015␤]

[04:39] <pmichaud> that looks odd to me.  oh well.

[04:40] <pmichaud> pugs:  say (1..5).elems

[04:40] <exp_evalbot> OUTPUT[5␤]

[04:40] <pmichaud> pugs:  say (1..5, 6..10).elems

[04:40] <exp_evalbot> OUTPUT[10␤]

[04:40] <pmichaud> pugs:  say (1..5, 0, 6..10).elems

[04:40] <exp_evalbot> OUTPUT[11␤]

[04:41] <pmichaud> pugs:  my @a = 1..4;   say @a.elems

[04:41] <exp_evalbot> OUTPUT[4␤]

[04:41] <pmichaud> pugs:  my @a = 1..4;   say (@a).elems

[04:41] <exp_evalbot> OUTPUT[4␤]

[04:41] <pmichaud> pugs:  my @a = 1..4;   say (@a,5).elems

[04:41] <exp_evalbot> OUTPUT[5␤]

[04:41] <pmichaud> pugs:  my @a = 1..4;   say (@a,5,1..7).elems

[04:41] <exp_evalbot> OUTPUT[12␤]

[04:43] *** braceta left
[04:44] <pmichaud> pugs: say (:a<3>);

[04:44] <exp_evalbot> OUTPUT[a        3␤]

[04:45] <Auzon> That seems very wrong. :-/

[04:45] <Auzon> Oops, I was scrolled up

[04:45] <pmichaud> pugs: say (~(:a<3>)).chars;

[04:45] <exp_evalbot> OUTPUT[3␤]

[04:49] *** justatheory left
[04:53] *** cmarcelo joined
[04:54] <mncharity> TimToady: (n+1) In 'package P; ...' package_def eats the ';' which is needed by its callees.

[04:54] <Auzon> elf: package Test;; say $?PACKAGE;

[04:54] <exp_evalbot> OUTPUT[Use of uninitialized value in concatenation (.) or string at ./elf_f_faster line 4457.␤␤]

[04:54] <Auzon> elf: say 5;;

[04:54] <exp_evalbot> OUTPUT[Use of uninitialized value in join or string at ./elf_f_faster line 156.␤5␤]

[04:55] <Auzon> oh well. ;; is silly.

[04:55] *** cmarcelo left
[04:56] *** mmorrow joined
[04:57] <mncharity> :)

[04:57] <pugs_svnbot> r20533 | putter++ | [STD_red] Parse 'package Foo;'.  Auzon++

[04:58] <mncharity> parser fixed.  will teach the emitter about it another day.

[04:58] <Auzon> You'll probably pass the S11 tests then (which I just added recently)

[04:59] <mncharity> nontrivial because have to know when to invoke Moose immutability.  but I fuzzily recall p6 prohibits 'package P1; ... package P2; ...', thus simplifying.

[05:00] <mncharity> re S11, :)

[05:00] <Auzon> My tests didn't smartlink for some reason. I'll look into it tomorrow or Monday, and probably add more tests.

[05:00] <mncharity> re ;; , yeah, have to do something about that.  first need to learn what the spec behavior is.

[05:01] <mncharity> tests++

[05:01] <mncharity> past end of day.  g'night ﻿Auzon &

[05:01] *** mncharity left
[05:02] <Auzon> end of day indeed. &

[05:19] <rakudo_svn> r27797 | pmichaud++ | [rakudo]:

[05:19] <rakudo_svn> r27797 | pmichaud++ | * Fix :a<3> Pair notation.  (mncharity++ for noticing this.)

[05:19] <rakudo_svn> r27797 | pmichaud++ | * Add stringification for Pairs (possibly incorrect -- needs

[05:19] <rakudo_svn> r27797 | pmichaud++ |   spec clarification).

[05:47] *** thestarslookdown left
[05:55] <bacek> perl6: my @pop = (1..3); say(pop @pop, 3, 'test');

[05:55] <exp_evalbot> kp6: OUTPUT[syntax error at position 8, line 1 column 8:␤my @pop = (1..3); say(pop @pop, 3, 'test')␤        ^ HERE␤]

[05:55] <exp_evalbot> ..pugs: OUTPUT[33test␤]

[05:55] <exp_evalbot> ..rakudo: OUTPUT[Could not invoke non-existent sub pop␤current instr.: '_block11' pc 75 (EVAL_13:31)␤called from Sub 'parrot;PCT::HLLCompiler;eval' pc 783 (src/PCT/HLLCompiler.pir:458)␤called from Sub 'parrot;PCT::HLLCompiler;evalfiles' pc 1065 (src/PCT/HLLCompiler.pir:587)␤called from Sub

[05:55] <exp_evalbot> ..'parrot;PCT::HLLCompiler;command_line' pc 1244 (src/PCT/HLLCompile...

[05:55] <exp_evalbot> ..elf: OUTPUT[Undefined subroutine &GLOBAL::pop called at (eval 15) line 4.␤ at ./elf_f_faster line 4600␤]

[05:56] <bacek> my I ask stupid question: why it treated as say((pop..., 3, '')) not as say((pop ..), 3, '')?

[05:57] *** rindolf left
[05:58] <TimToady> I believe pop is now defined with an extra arg that says how many to pop, so it should probably be not finding an appropriate multi

[05:59] <bacek>  our Scalar multi method pop ( @array: ) is export

[06:00] <TimToady> hmm, will S29 is still in a "formative" stage :)

[06:00] <bacek> TimToady, :)

[06:00] <TimToady> *well

[06:01] <TimToady> on the other hand, there's always splice for that

[06:01] <bacek> so, if I have 2 multi subs: Array a(), Array a(@l) and b(@l), b(@,@) how b(a @l1, @l2) should be parsed?

[06:02] <bacek> fix: 'a' is (@) and (@,@) s well.

[06:03] <bacek> and, AFAIK, functions signatures not available during parsing phase...

[06:03] <TimToady> in scalar context the return of a is considered a scalar, even if it produced a list

[06:04] <TimToady> that is, it returns a single Capture containing the returned values, and scalar context turns it into an array

[06:05] <bacek> ok. What about second argument? Should all statement handled as b(a(@,@)) or b(a(@), @)?

[06:06] <bacek> and how parser can distinguish this variants if method's signatures not available?

[06:07] <TimToady> list operators will always parse the whole list

[06:07] <TimToady> there's no mechanism for picking off N args like in some languages

[06:08] <TimToady> which is why "for" binding has to be a special case

[06:10] <bacek> TimToady, does it mean that t/spec/S29-array/pop.t must must be fixed? (And many other tests as well)

[06:11] <TimToady> depends on whether we define prefix:<pop> as a unary operator

[06:11] <TimToady> I think at the time the export was written we were just assuming a sig with a single arg was sufficient

[06:11] <TimToady> but lately we're requiring prefix:<x> for that

[06:12] <TimToady> so I dunno if export can be made to do that

[06:12] <TimToady> unless we extend it to have some kind of "export as" syntax

[06:13] <TimToady> certainly p5 folx will expect pop @x to be unary

[06:14] <TimToady> have to think about what would be a good export syntax for that

[06:14] <bacek> sorry, have to go.

[06:14] <TimToady> or maybe it's just a special enough case that we write one in terms of the other

[06:14] <TimToady> k bye

[06:16] *** ting_ joined
[06:16] *** agentzh joined
[06:34] *** agentz1 left
[06:34] *** ting left
[06:43] *** smtms left
[06:43] *** alester_ left
[06:47] *** jiing joined
[07:12] *** pmurias joined
[07:17] *** IllvilJa joined
[07:33] *** meppl joined
[07:34] *** alc left
[07:52] <pugs_svnbot> r20534 | moritz++ | t/blocks/pointy.t when compilation of an eval() fails, rely on $!, 

[07:52] <pugs_svnbot> r20534 | moritz++ | not on the return value of eval().

[07:53] *** alc joined
[08:00] *** smtms joined
[08:41] *** iblechbot joined
[08:44] <meppl> good morning

[08:45] <moritz_> good morning meppl ;)

[08:48] <meppl> good morning, moritz

[08:54] *** schmalbe joined
[09:07] *** lisppaste3 left
[09:13] *** alc left
[09:26] <pugs_svnbot> r20535 | moritz++ | [pugs/debian] a few small, ugly changes to debian/ that makes

[09:26] <pugs_svnbot> r20535 | moritz++ | debian packages build if pugs built is fixed ;-)

[09:26] <pugs_svnbot> r20535 | moritz++ | (Still depends on ghc 6.6.1, which is that last ghc version that

[09:26] <pugs_svnbot> r20535 | moritz++ | worked for me)

[09:36] *** chris2 joined
[09:41] *** schmalbe left
[09:57] *** chris2 left
[09:59] *** lisppaste3 joined
[10:21] *** rindolf joined
[11:08] *** vixey left
[11:22] *** polettix joined
[11:23] <moritz_> what should [*] (); return?

[11:24] <moritz_> pugs: say [*] ();

[11:24] <exp_evalbot> OUTPUT[1␤]

[11:25] <moritz_> so how does the reduce meta op [...] knows what the neutral element for multiplication is?

[12:11] *** chris2 joined
[12:21] *** kane_ left
[12:21] *** ruoso left
[12:21] *** Caelum left
[12:21] *** r0bby left
[12:21] *** kolibrie left
[12:21] *** Auzon left
[12:21] *** jjore left
[12:21] *** arguile left
[12:21] *** allbery_b left
[12:21] *** Maddingue left
[12:23] <moritz_> is there a particular reasons for feed operators to be discussed in S06? are they somewhat closely related to subs?

[12:23] *** kane_ joined
[12:23] *** ruoso joined
[12:23] *** Caelum joined
[12:23] *** jjore joined
[12:23] *** Auzon joined
[12:23] *** Maddingue joined
[12:23] *** kolibrie joined
[12:23] *** arguile joined
[12:23] *** allbery_b joined
[12:24] *** FurnaceBoy joined
[12:24] *** elmex joined
[12:30] *** alc joined
[13:07] *** Alias_ joined
[13:10] <moritz_> rakudo: sub foo(:$x, $y){ say "$x|$y"}; say 1;

[13:10] <exp_evalbot> OUTPUT[1␤]

[13:10] <moritz_> rakudo: sub foo(:$x, :$y){ say "$x|$y"}; say 1;

[13:10] <exp_evalbot> OUTPUT[1␤]

[13:11] <moritz_> rakudo: sub foo(:$x, :$y){ say "$x|$y"}; foo(:x<a>, :y<b>);

[13:11] <exp_evalbot> OUTPUT[Null PMC access in type()␤current instr.: 'parrot;PAST::Compiler;keyed' pc 6130 (src/PAST/Compiler.pir:1703)␤

[13:11] <moritz_> rakudo: sub foo(:$x, :$y){ say "$x|$y"}; foo(x => 'a', y => 'b')

[13:11] <exp_evalbot> OUTPUT[a|b␤]

[13:12] *** FurnaceBoy left
[13:13] *** iblechbot left
[13:20] *** alc left
[13:34] <pmurias> moritz_: feed operators are a way of invoking a subroutine

[13:49] *** Ched- left
[13:49] *** Ched- joined
[13:52] *** kaether_ joined
[13:54] *** jhorwitz joined
[13:56] *** kaether left
[13:56] *** kaether_ is now known as kaether

[14:29] *** FurnaceBoy joined
[14:47] *** ruoso left
[15:05] *** alester_ joined
[15:10] *** cmarcelo joined
[15:15] *** BinGOs_ joined
[15:18] *** BinGOs left
[15:20] *** alester_ left
[15:21] *** polettix left
[15:26] *** alanhaggai joined
[15:32] *** FurnaceBoy left
[15:33] *** kaether_ joined
[15:35] *** BinGOs_ is now known as BinGOs

[15:38] *** kaether left
[15:38] *** kaether_ is now known as kaether

[15:44] *** FurnaceBoy joined
[15:52] *** masak joined
[15:56] *** iblechbot joined
[16:00] *** kanru joined
[16:07] *** FurnaceBoy is now known as FornalhoGaroto

[16:24] *** melg joined
[16:28] *** FornalhoGaroto is now known as FurnaceBoy

[16:32] *** alanhaggai left
[16:35] *** ChanServ sets mode: +o diakopter

[16:35] *** diakopter sets mode: +o TimToady

[16:35] *** diakopter sets mode: -o diakopter

[16:35] <diakopter> rakudo: sub foo(:$x, :$y){ say "$x|$y"}; foo(x => 'a')

[16:35] <exp_evalbot> OUTPUT[a|␤]

[16:36] <diakopter> rakudo: sub foo(:$x, :$y){ say "$x|$y"}; foo(y => 'b')

[16:36] <exp_evalbot> OUTPUT[MMD function __concatenate not found for types (79, 80)␤current instr.: 'foo' pc 101 (EVAL_12:55)␤

[16:36] * diakopter thinks.

[16:36] <moritz_> rakudo is lacking robustness

[16:37] <diakopter> is there a "required named parameter" marker in the sub declaration?

[16:37] * moritz_ rechecks S06

[16:38] <rindolf> diakopter: what is :$x in subroutine args?

[16:38] <moritz_> Required parameters may optionally be declared with a trailing !, though that's already the default for positional parameters:

[16:38] <moritz_> rindolf: named parameter

[16:38] <rindolf> moritz_: ah.

[16:38] <masak> moritz_: pugs was also lacking in robustness at rakudo's age :)

[16:38] <lambdabot> masak: You have 1 new message. '/msg lambdabot @messages' to read it.

[16:38] <masak> ooh, a message!

[16:38] <diakopter> rakudo: sub foo(:$x, :$y!){ say "$x|$y"}; foo(y => 'b')

[16:38] <exp_evalbot> OUTPUT[MMD function __concatenate not found for types (79, 80)␤current instr.: 'foo' pc 91 (EVAL_12:50)␤

[16:39] <diakopter> rakudo: sub foo(:$x!, :$y){ say "$x|$y"}; foo(y => 'b')

[16:39] <exp_evalbot> OUTPUT[too few arguments passed - missing required named arg 'x'␤current instr.: 'foo' pc 41 (EVAL_12:23)␤

[16:39] <moritz_> masak: I know ;)

[16:39] <masak> moritz_: oka. will read and get back to you.

[16:39] <masak> kudos for writing stuff, that's a way to get people enthusiastic (me included)

[16:40] *** Psyche^ joined
[16:41] <diakopter> rakudo: sub foo(:$x, :$y){ say "$x"~"|"~"$y"}; foo(y => 'b')

[16:41] <exp_evalbot> OUTPUT[|b␤]

[16:41] <diakopter> well that worked

[16:42] <moritz_> maybe it can't concatenate Undef or Failure

[16:42] <moritz_> rakudo: my $x = Failure.new; print "x$x";

[16:42] <exp_evalbot> OUTPUT[x]

[16:42] <moritz_> rakudo: my $x = Undef; print "x$x";

[16:42] <exp_evalbot> OUTPUT[xFailure]

[16:42] <moritz_> lol

[16:42] * diakopter giggles

[16:43] <diakopter> pugs: my $x=Failure.new;print "x$x";

[16:43] <exp_evalbot> OUTPUT[*** No such subroutine: "&Failure"␤    at /tmp/Z5oV61gm0O line 1, column 3-18␤]

[16:43] <moritz_> barewords that aren't types are parsed as subs

[16:48] <diakopter> rakudo: sub foo(:$x, :$y){ say "$x"~"|"~"$y"}; foo('y' => 'b')

[16:48] <exp_evalbot> OUTPUT[|b␤]

[16:51] <moritz_> rakudo: sub foo(:$x, :$y){ say "$x"~"|"~"$y"}; foo(:x(1), :y(2));

[16:51] <exp_evalbot> OUTPUT[1|2␤]

[16:51] <moritz_> rakudo: sub foo(:$x, :$y(2)){ say "$x"~"|"~"$y"}; foo(:x(1));

[16:51] <exp_evalbot> OUTPUT[Scope  not found for PAST::Var '$x'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[16:51] <moritz_> rakudo: sub foo(:$x, :$y = 2){ say "$x"~"|"~"$y"}; foo(:x(1));

[16:51] <exp_evalbot> OUTPUT[1|2␤]

[16:53] <diakopter> rakudo: sub foo(:$x, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(1));

[16:53] <exp_evalbot> OUTPUT[|1␤]

[16:53] <diakopter> rakudo: sub foo(:$x, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(Undef));

[16:53] <exp_evalbot> OUTPUT[|Failure␤]

[16:53] <diakopter> rakudo: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3));

[16:53] <exp_evalbot> OUTPUT[|␤]

[16:54] <diakopter> interesting

[16:54] <moritz_> buggy ;)

[16:55] <moritz_> we really need a point-n-click mechanism for making test cases out of IRC logs ;)

[16:55] <diakopter> x is an optional positional parameter; y is a defaulted but overridden named parameter

[16:55] <moritz_> except that named paramenters are optional by default

[16:55] <diakopter> rakudo: sub foo($x?, :$y? = 2){ say "$x"~"|"~"$y"}; foo(:y(3));

[16:55] <exp_evalbot> OUTPUT[|␤]

[16:56] <diakopter> duh; defaulted parameters are optional; silly me

[16:57] <diakopter> rakudo: sub foo(:$y = 2, $x?){ say "$x"~"|"~"$y"}; foo(:y(3));

[16:57] <exp_evalbot> OUTPUT[|␤]

[16:57] *** Patterner left
[16:57] *** Psyche^ is now known as Patterner

[16:57] <diakopter> pugs: sub foo(:$y = 2, $x?){ say "$x"~"|"~"$y"}; foo(:y(3));

[16:57] <exp_evalbot> OUTPUT[|3␤]

[16:58] <diakopter> pugs: sub foo(:$y = 2, $x){ say "$x"~"|"~"$y"}; foo(:y(3));

[16:58] <exp_evalbot> OUTPUT[*** Missing required parameters: $x␤    at /tmp/rn1EXKNr5w line 1, column 43-53␤]

[16:58] <diakopter> pugs: sub foo($x, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3));

[16:58] <exp_evalbot> OUTPUT[*** Missing required parameters: $x␤    at /tmp/dNpxvaDr1p line 1, column 43-53␤]

[16:58] <diakopter> pugs: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3));

[16:58] <exp_evalbot> OUTPUT[|3␤]

[16:58] <diakopter> ok; pugs does what my understanding expects

[16:59] <diakopter> pugs: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3), 1);

[16:59] <exp_evalbot> OUTPUT[1|3␤]

[16:59] <diakopter> oooo interesting

[17:00] <moritz_> and correct IMHO

[17:00] *** alanhaggai joined
[17:00] <diakopter> so, optional positional parameters and named parameters can be interspersed in both the declaration and invocation, but are treated as two separate parameter lists.

[17:01] <diakopter> (for the purposes of ordering the positional parameters)

[17:01] <moritz_> aye

[17:02] <diakopter> rakudo: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3), 1);

[17:02] <exp_evalbot> OUTPUT[1|3␤]

[17:02] <diakopter> but rakudo got that one.

[17:04] <diakopter> so, rakudo is currently ignoring named arguments if there is an optional positional argument missing.

[17:06] <diakopter> rakudo: sub foo(:$y = 2, $x?){ say "$x"~"|"~"$y"}; foo(:y(3), 1);

[17:06] <exp_evalbot> OUTPUT[1|3␤]

[17:07] <diakopter> rakudo: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3), 1);

[17:07] <exp_evalbot> OUTPUT[1|3␤]

[17:07] <diakopter> rakudo: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(1, :y(3));

[17:07] <exp_evalbot> OUTPUT[1|3␤]

[17:07] <diakopter> rakudo: sub foo(:$y = 2, $x?){ say "$x"~"|"~"$y"}; foo(1, :y(3));

[17:07] <exp_evalbot> OUTPUT[1|3␤]

[17:07] <diakopter> yep; that's it.

[17:07] *** justatheory_ left
[17:07] <diakopter> rakudo: sub foo($x?, :$y = 2){ say "$x"~"|"~"$y"}; foo(:y(3));

[17:07] <exp_evalbot> OUTPUT[|␤]

[17:10] <diakopter> in fact, it's not even using the default value of y

[17:11] <diakopter> rakudo: sub foo($x, $y?, :$z = 2){ say $x~"|"~$y~"|"~$z}; foo(1,:y(3),4);

[17:11] <exp_evalbot> OUTPUT[too many named arguments - 'y' not expected␤current instr.: 'foo' pc 55 (EVAL_12:27)␤

[17:11] <diakopter> rakudo: sub foo($x, $y?, :$z = 2){ say $x~"|"~$y~"|"~$z}; foo(1,:z(3),4);

[17:11] <exp_evalbot> OUTPUT[1|4|3␤]

[17:14] <diakopter> rakudo: sub foo($x, $y?, :$z = 2){ say $x~"|"~$y~"|"~$z}; foo(1,:z(3)); #should say: 1||3

[17:14] <exp_evalbot> OUTPUT[1||␤]

[17:15] <diakopter> rakudo: sub foo($w, $x?, $y?, :$z = 2){ say $w~"|"~$x~"|"~$y~"|"~$z}; foo(1,,,:z(3)); #should say: 1|||3

[17:15] <exp_evalbot> OUTPUT[1|||␤]

[17:16] <diakopter> rakudo: sub foo($w, $x?, $y?, :$z = 2){ say $w~"|"~$x~"|"~$y~"|"~$z}; foo(1,Undef,Undef,:z(3)); #should say: 1|||3

[17:16] <exp_evalbot> OUTPUT[1|Failure|Failure|3␤]

[17:16] <diakopter> that's closer

[17:16] <moritz_> actually I don't think that Undef is forced to stringify to ''

[17:16] <diakopter> oh?

[17:17] <moritz_> after all it's a proto object, which should stringify to its class name

[17:17] <diakopter> what should foo(1,,,:z(3)) have said

[17:17] <moritz_> dunno

[17:18] <moritz_> rakudo: my Int $x; say $x

[17:18] <exp_evalbot> OUTPUT[Int␤]

[17:18] <diakopter> pugs: sub foo($w, $x?, $y?, :$z = 2){ say $w~"|"~$x~"|"~$y~"|"~$z}; foo(1,,,:z(3)); #should say??: 1|||3  #asking pugs for help

[17:18] <exp_evalbot> OUTPUT[*** ␤    Unexpected ",,:"␤    expecting ":", identifier or ")"␤    at /tmp/LP94cgcgwN line 1, column 69␤]

[17:19] <diakopter> rakudo doesn't mind empty arguments, but pugs does.

[17:19] *** braceta joined
[17:21] <diakopter> pugs: sub foo($w, $x?, $y?, :$z = 2){ say $w~"|"~$x~"|"~$y~"|"~$z}; foo(1,undef,undef,:z(3)); #asking pugs for help

[17:21] <exp_evalbot> OUTPUT[1|||3␤]

[17:21] <diakopter> pugs: sub foo($w, $x?, $y?, :$z = 2){ say $w~"|"~$x~"|"~$y~"|"~$z}; foo(1,undef,undef,'something_extra',:z(3));

[17:21] <exp_evalbot> OUTPUT[*** No compatible multi variant found: "&foo"␤    at /tmp/BwplDZyBLJ line 1, column 63-105␤]

[17:22] <diakopter> interesting it gives that error when there are too many arguments, but "too few arguments" error when there are too few arguments.

[17:23] <diakopter> rakudo: sub foo($w, $x?, $y?, :$z = 2){ say $w~"|"~$x~"|"~$y~"|"~$z}; foo(1,Undef,Undef,'something_extra',:z(3));

[17:24] <exp_evalbot> OUTPUT[1|Failure|Failure|something_extra␤]

[17:24] <diakopter> wow; that's utter failure

[17:25] * diakopter tries to imagine what would cause that

[17:32] *** cmarcelo left
[17:39] <diakopter> rakudo: sub foo($w, $x?, $y?, :$z = 4){ say $w~"|"~$x~"|"~$y~"|"~$z}; foo(1,,3,:z(5)); #should say: 1||3|5

[17:39] <exp_evalbot> OUTPUT[1|3||␤]

[17:40] <diakopter> ok; rakudo treats a double comma as a single comma

[17:41] <diakopter> rakudo: sub foo($v, $w?, $x?, $y?, :$z = 5){ say $v~"|"~$w~"|"~$x~"|"~$y~"|"~$z}; foo(1,,3,,:z(6)); #should say: 1||3||6

[17:41] <exp_evalbot> OUTPUT[1|3|||␤]

[17:43] <diakopter> TimToady: is ,, legal in an argument list?

[17:44] <diakopter> pugs seems to think not; rakudo treats multiple commas as 1 comma

[18:03] *** masak left
[18:17] *** chris2 left
[18:19] *** jhorwitz left
[18:39] <diakopter> rakudo: sub foo($w=4){say $w.perl}; foo w => 3;   # $w is a positional parameter, but w is passed as a named argument, so this should fail with "not enough (positional) arguments"

[18:39] <exp_evalbot> OUTPUT[:w(3)␤]

[18:40] <diakopter> rakudo: sub foo(:$w=4){say $w.perl}; foo w => 3;  # $w is a named parameter ($w should be 3), but produces a Pair (":w(3)")

[18:40] <exp_evalbot> OUTPUT[:w(3)␤]

[18:40] <moritz_> rakudo: sub foo(:$w=4){say $w.perl}; foo :w(3)

[18:41] <exp_evalbot> OUTPUT[:w(3)␤]

[18:41] <moritz_> b0rked

[18:48] <diakopter> rakudo: sub foo($w){say $w.perl}; foo('w'=>3); # $w should be a Pair, not a named argument

[18:48] <exp_evalbot> OUTPUT[too many named arguments - 'w' not expected␤current instr.: 'foo' pc 41 (EVAL_12:23)␤

[18:49] <moritz_> rakudo: sub foo { say %_.perl }; foo('w' => 3)

[18:49] <exp_evalbot> OUTPUT[Method 'perl' not found for invocant of class 'Hash'␤current instr.: 'foo' pc 78 (EVAL_11:41)␤

[18:50] <moritz_> rakudo: sub foo { say %_l }; foo('w' => 3)

[18:50] <exp_evalbot> OUTPUT[Scope  not found for PAST::Var '%_l'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[18:50] <diakopter> rakudo: sub foo(:$w){say $w.perl}; foo |('w'=>3); # $w should be a named argument

[18:50] <exp_evalbot> OUTPUT[Method 'perl' not found for invocant of class 'Undef'␤current instr.: 'foo' pc 121 (EVAL_12:51)␤

[18:51] <diakopter> er, what?

[18:52] *** ggoebel joined
[18:53] *** ggoebel left
[18:55] <diakopter> rakudo: sub foo(:$w=:w(:z(4))){say $w.perl}; my %h=(x=>3);foo(%h); # $w should be a named argument, not a Pair

[18:55] <exp_evalbot> OUTPUT[:x(3)␤]

[18:57] <moritz_> diakopter: actually foo(%h) shouldn't work at all

[18:57] <moritz_> diakopter: because foo expects a named arg

[18:57] <moritz_> diakopter: and receives only a positional

[18:58] <diakopter> right, that's what my comment says

[18:59] <diakopter> $w should be a named argument (scalar), not a (positionally interpreted) Pair

[19:01] <diakopter> although, S06 implies that named arguments are optional by default (when it specifies that positional arguments are required by default)

[19:02] <diakopter> parameters, I mean

[19:02] <moritz_> so?

[19:02] *** rindolf left
[19:03] <moritz_> you'r still not allowed to call a sub with an optional named argument with a positional one

[19:03] <diakopter> so, foo(%h) should run, just with :$w not defined

[19:05] <diakopter> ok, you're right; so, it should give a fatal error, "too many [positional] arguments", or in pugs' case, "mmd method not found"

[19:06] <moritz_> a sub without a "multi" or a "proto" is implicitly an "only" sub, so the correct message is "wrong argument list" and not "no multi sub found"

[19:06] <diakopter> ah, ok.  i was assuming pugs was correct. :)

[19:10] <diakopter> this is interesting:

[19:10] <diakopter> rakudo: sub foo(:$w=4){say $w.perl}; my $w=5; foo(:$w); my %w=6; foo(%w);

[19:10] <exp_evalbot> OUTPUT[5␤6␤]

[19:11] <moritz_> rakudo: my %w = 6; say %w

[19:11] <exp_evalbot> OUTPUT[6␤]

[19:12] <moritz_> not type checks yet on containers

[19:13] <diakopter> this is also wrong:

[19:13] <diakopter> rakudo: sub foo(:$w=4){say $w.perl}; my %w=:x(7); foo(%w);

[19:13] <exp_evalbot> OUTPUT[:x(7)␤]

[19:15] <diakopter> rakudo: sub foo(:$w=4){say $w.perl}; my %z=:x(7); foo(%z); # I guess named arguments fall back to being positional ones...?

[19:15] <exp_evalbot> OUTPUT[:x(7)␤]

[19:16] <moritz_> actually it should be the other way round

[19:27] *** vixey joined
[19:30] *** icwiener joined
[19:46] <pmurias> vixey: hi

[19:46] <vixey> hiya

[19:49] <meppl> good night

[19:51] *** icwiener left
[19:52] *** meppl left
[20:09] *** rhizo joined
[20:16] *** FurnaceBoy left
[20:50] *** mmorrow left
[21:14] *** jferrero joined
[21:24] <TimToady> moritz_: S03:3510 discusses identity values for reduce operators

[21:25] <TimToady> feed operators are syntactically statement separators like ;

[21:26] <moritz_> *reading*

[21:26] <TimToady> so they don't really fit well anywhere.  maybe they belong in S04 more than S06...

[21:28] <moritz_> or maybe in their own synopsis - the existing ones are large enough, a bit more modularisation wouldn't hurt

[21:32] <TimToady> it is incorrect to put any positional parameter after any named-only parameter

[21:38] <TimToady> I think ,, should probably be legal, given a trailing , is legal

[21:42] <TimToady> And missing args are considered to be equivalent to (), so 1,2,,3, is really 1,2,(),3,()

[21:42] *** pmurias left
[21:44] <TimToady> (well, that's the p5 view; maybe it should not autogenerate a null list when bound to a scalar though)

[21:44] <moritz_> should STD5_run work atm? I tried it today and it chokes (iirc it can't localize %_ or some such)

[21:44] <TimToady> running under 5.10?

[21:45] <moritz_> aye

[21:45] <moritz_> at least I think so, I'll try again now

[21:45] <TimToady> could be broken at the moment--I'm in the middle of a quoting refactor

[21:46] <TimToady> might well be broken on some input and not other input

[21:46] <moritz_> perl5.10.0 STD5_run noun -e 42

[21:46] <moritz_> Can't use global %_ in "my" at STD5.pm line 7256, near "my %_"

[21:47] <moritz_> the line is my %_ = @_;

[21:51] <pugs_svnbot> r20536 | Auzon++ | Smartlink fixes with help from moritz++

[21:51] <TimToady> that's very odd; I've never seen that error.  unfortunately I'm not in a runnable state at the momet to try it

[21:51] <TimToady> *moment

[21:52] <moritz_> TimToady: don't worry, I'll try again in a week

[21:58] *** FurnaceBoy joined
[22:11] *** bacek_ joined
[22:13] *** bacek left
[22:36] *** iblechbot left
[22:37] *** r0bby joined
[23:03] *** FurnaceBoy left
[23:05] *** rhizo_ joined
[23:07] *** alanhaggai left
[23:16] *** jferrero left
[23:19] *** elmex left
[23:21] *** justatheory joined
[23:24] *** braceta left
[23:26] *** rhizo left
[23:49] *** justatheory left
[23:56] *** braceta joined
