[00:00] *** jfredett left
[00:02] *** pbuetow joined
[00:03] *** meppl left
[00:18] *** pbuetow left
[00:21] *** Alias_ joined
[00:34] *** eternaleye left
[00:38] *** felipe left
[00:46] *** PZt left
[00:50] *** Khisanth left
[00:50] *** Khisanth joined
[00:51] *** PZt joined
[00:54] *** zamanfou is now known as zamanf

[00:56] <pugs_svn> r21356 | ruoso++ | [smop] $p6opaque.^!methods.push($method) actually calls $p6opaque.^!methods.register($identifier, $signature, $method)

[01:00] <s1n> moritz_: where is the testfile actually executed by the harness?

[01:01] <s1n> that is, after it figures out which ones to run from the input file, figures out which ones need fudging, where does it actually run the individual .t files (plans)

[01:03] <bacek> s1n: Makefile target spectest or spectest_regression

[01:04] <s1n> baest: yeah, but where deep down in the harness code is that performed

[01:06] <s1n> the makefile will just call harness, but from there, where is the .t file actually executed (I'm assuming against languages/perl6/Test.pm)

[01:07] <bacek> lib/Parrot/Test/Harness.pm in parrot dir

[01:08] <s1n> bacek: aha, thanks

[01:09] <s1n> there's the call to runtests

[01:09] <bacek> s1n: anyway, you probably don't need it. Just put S??/some-test.t into t/localtest.data and run 'make localtest'

[01:09] <bacek> (In rakudo dir)

[01:19] *** jferrero left
[01:37] *** dduncan left
[01:43] *** ashleyb left
[02:05] *** Limbic_Region left
[02:08] *** agentzh left
[02:18] *** cathyal joined
[02:21] *** alanhaggai_ joined
[02:24] *** felipe joined
[02:25] *** alanhaggai_ is now known as alanhaggai

[02:33] *** kanru left
[02:41] *** fullermd joined
[02:41] *** nipotan is now known as nipotaway

[02:44] *** agentzh joined
[02:50] *** wknight8111 left
[03:03] <s1n> it seems i still have commitbit access but my authentication is failing, can someone reset my password?

[03:06] *** kanru joined
[03:08] <Auzon> s1n: I'm not sure how to reset passwords, but are you sure you put your name and password in correctly? (case matters and it bit me the first time)

[03:10] <s1n> Auzon: yeah, i think i did anyways, i can't remember who set it up, but there's no "reset my password" feature

[03:10] <s1n> I tried logging on through the web interface and it's not taking anything

[03:12] <Auzon> I don't see anywhere in the web interface for a reset password feature :-/

[03:12] <s1n> there's gotta be an admin in here that can do this...

[03:25] <s1n> bleh, anyone? i'd really like to start committing changes to the test suite

[03:26] <Auzon> pmichaud or [particle] or another admin maybe?

[03:32] <s1n> gaal: you're an admin as well, think you could help?

[03:39] <s1n> okay, well, it's getting late. any pugscode admins see this later, reset the username: s1n, email: [email@hidden.address] for me, i'd greatly appreciate it

[03:39] <Auzon> see you, s1n.

[03:39] <s1n> thanks Auzon

[03:41] <s1n> Auzon: by the way, now that I have gotten the hang of running the test suite, i'm just going to start going through it all, unskip the passing tests, and add missing tests, then i'll eventually start filling in the pieces later (PIR looks like it has a learning curve)

[03:41] *** icwiener_ joined
[03:41] <Auzon> Sounds great :)

[03:41] <Auzon> Glad to have you helping.

[03:42] <s1n> anything to move perl6 along :)

[03:54] *** alester joined
[03:57] *** icwiener left
[03:57] *** icwiener_ is now known as icwiener

[04:01] *** dduncan joined
[04:23] *** alanhaggai_ joined
[04:23] <TimToady> s1n: re-invite sent

[04:24] *** alanhaggai left
[04:31] <Auzon> What does a "StopIteration" mean in Rakudo?

[04:31] <Auzon> I've never gotten that error message before :)

[05:25] *** agentzh left
[05:25] *** agentzh joined
[05:53] *** Psyche^ joined
[05:54] *** alester left
[05:59] *** agentzh left
[05:59] *** alanhaggai_ is now known as alanhaggai

[06:04] *** agentzh joined
[06:06] *** Patterner left
[06:06] *** Psyche^ is now known as Patterner

[06:13] *** xinming joined
[06:18] *** ashizawa joined
[06:24] <pugs_svn> r21357 | lwall++ | [STD] various tweaks suggested once upon a time by mncharity++

[06:26] *** xinming_ left
[06:30] <speckbot> r14565 | larry++ | clarification suggested by Bob Rogers++

[06:32] <moritz_> TimToady: any thoughts re http://www.nntp.perl.org/group/perl.perl6.language/2008/05/msg29206.html ?

[06:32] <lambdabot> Title: make POST blocks more usable - nntp.perl.org, http://tinyurl.com/68vers

[06:33] <moritz_> afk

[06:43] <TimToady> I think I'd rather have the value come in as the topic, like with CATCH blocks, but it would presumably be a Capture, and we need to be careful not to have side effects on it en passant.

[06:44] *** masak joined
[06:44] <moritz_> I don't really care how it's done, as long as it's somehow available in POST

[06:48] *** justatheory left
[06:57] <speckbot> r14566 | larry++ | suggestion from moritz++ that POST blocks be allowed to see the return value

[06:57] <moritz_> TimToady++

[06:58] *** cathyal left
[07:09] <masak> re that, will I also be able to do 'POST -> $retval { ... }' ?

[07:09] <moritz_> no

[07:09] <moritz_> you could do that if it were a formal parameter to the block

[07:10] <masak> I see.

[07:11] <masak> it just seems to me that sometimes I want to name my return value, and right now I would have to do it with an explicit 'my $retval = $_;' at the top of the block

[07:13] <moritz_> me too, but I guess there are reasons

[07:13] <moritz_> for example consider sub { return 2 * $^a; POST { # what is $^a here? }}

[07:14] <moritz_> if the return value were a formal parameter of the POST block, $^a inside the block would bind to it, not to the outer $^a

[07:14] <moritz_> which might be rather confusing, because a possibly present $^b would still refer to the one from the outer scope

[07:16] <masak> you're right

[07:16] * moritz_ heads off to $uni

[07:23] *** pmurias joined
[07:26] *** Helios- left
[07:26] *** Helios- joined
[07:26] *** icwiener left
[07:30] <pmurias> ruoso: how should the perl6 be embedded in sm0p files?

[07:31] *** Helios- left
[07:32] *** Helios- joined
[07:32] <pmurias> and what is the perl6 version of $SMOP__SLIME__CurrentFrame.forget();$interpreter.goto(|$continuation);?

[07:37] *** penk joined
[07:38] *** pmurias left
[07:39] *** pmurias joined
[07:43] *** iblechbot joined
[07:54] *** elmex joined
[07:58] *** [particle] joined
[08:41] *** barney joined
[08:54] *** wknight8111 joined
[08:59] <pugs_svn> r21358 | pmurias++ | [pixie] t/01-sanity/1-4 pass now

[09:01] *** bacek left
[09:02] <pugs_svn> r21359 | pmurias++ | [smop]

[09:02] <pugs_svn> r21359 | pmurias++ | removed useless test

[09:02] <pugs_svn> r21359 | pmurias++ | possible p6 version of 2 sm0p blocks in comments

[09:15] *** meppl joined
[09:16] *** rindolf joined
[09:20] <pmurias> (vanishing source code)--

[09:25] <ruoso> pmurias, re perl6 embedded... it could be q:perl6 or something like that...

[09:25] <ruoso> pmurias, we probably need different block types

[09:25] <ruoso> one for CPS with no return value

[09:25] <ruoso> other with return value

[09:26] * ruoso food &

[09:39] *** hcchien left
[09:40] <pmurias> ruoso: hi

[09:46] *** jferrero joined
[09:53] *** alanhaggai_ joined
[09:58] *** Jedai joined
[10:10] *** alanhaggai left
[10:14] *** tuxdna joined
[10:15] *** iblechbot left
[10:18] *** chris2 joined
[10:22] <pmurias> pugs: sub foo($foo|$bar) {say "hi"}

[10:22] <p6eval> pugs: OUTPUT[*** ␤    Unexpected "|$"␤    expecting word character, "?", "!", trait, "=", default value, "-->" or ")"␤    at /tmp/YXr5t38ImR line 1, column 13␤]

[10:24] <pmurias> is it possible to have a sub with multiple signatures?

[10:25] *** wknight8111 left
[10:26] * ruoso off to work &

[10:26] *** ruoso left
[10:28] <moritz_> pmurias: yes, see S06

[10:30] *** pbuetow_ joined
[10:30] <moritz_> or was it S13?

[10:32] *** dduncan left
[10:32] <moritz_> multi sub infix:<+> (Us $us, Them $them) | (Them $them, Us $us) { myadd($us,$them) }

[10:40] *** PZt left
[10:42] *** PZt joined
[10:51] *** barney left
[11:04] *** ruoso joined
[11:13] *** wknight8111 joined
[11:18] *** iblechbot joined
[11:21] *** s1n left
[11:21] *** s1n joined
[11:21] <pugs_svn> r21360 | s1n++ | [pugs_s02] some tests are passing that were skipped, some being 

[11:21] <pugs_svn> r21360 | s1n++ | unspecced

[11:23] <moritz_> s1n: please don't remove "unspecced" fudging marks unless you understand why it's there, and have a good reason to remove it

[11:24] <moritz_> s1n: in this case $range.perl can return *anything* that evaluates to the same object as $range - it doesn't have to be '1..5' here

[11:24] <moritz_> oh, and fudging should never affect the plan

[11:25] <moritz_> (don't let it discourage you, that's just a beginner's mistake)

[11:25] <moritz_> forget that last one, you did add tests

[11:36] *** amorette joined
[11:37] *** amorette left
[11:50] <pmurias> ruoso: wouldn't it simplify things significantly if the optimal_* part of p6opaque was droped?

[11:58] *** Southen_ left
[12:07] *** wknight8111 left
[12:21] *** tuxdna left
[12:23] <ruoso> pmurias, the optimal part is for constant-identifiers that can be checked by simple pointer identity

[12:24] <ruoso> I don't even need to look inside the keys for that matter

[12:24] <ruoso> initially, I'm planning to support only constant identifiers...

[12:24] <ruoso> then the normal Str support can be added later... 

[12:24] <pmurias> so it's a bootstrap/hack optimalisation ;)

[12:25] <pmurias> * bootstrap hack/optimalisation

[12:25] <ruoso> yes... most importantly, a bootstrap hack

[12:26] <ruoso> that's the reason... I'm not really worried about performance atm

[12:26] <ruoso> s/performance/optimization/

[12:26] <pmurias> the memory leaking trick i used in s1p.Hash was to turn Str's into constant identifiers

[12:26] <ruoso> pmurias, I saw it...

[12:30] <pmurias> you fixed it ;)

[12:31] *** meppl left
[12:32] <pmurias> (but it still leaks memory as constant identifiers are not collected)

[12:33] *** meppl joined
[12:34] <pmurias> [bool] "has_next" is not implemented in bool. # is it normal?

[12:35] <ruoso> pmurias, all constant identifiers are destroyed at smop_destr time

[12:35] <ruoso> they are not subject to GC

[12:35] <ruoso> that's why they are "constant"

[12:35] <ruoso> not just because they values are constant, but because the pointers are constant also

[12:36] <pmurias> the have to be done that way

[12:37] <ruoso> that's how we can use simple pointer identity inside MESSAGE

[12:37] <pmurias> but using them as normal strings is not a good idea

[12:38] <ruoso> but for things that are hard-coded in the source file...

[12:38] <ruoso> the string is going to live for all the program anyway

[12:38] <ruoso> because it will be in the AST

[12:38] <pmurias> i understand ;)

[12:39] *** jiing joined
[12:39] <ruoso> every string literal could be created as a constant identifier afaik

[12:41] <pmurias> how does is an attribute lookup handled?

[12:41] <pmurias> s/does//

[12:42] <pmurias> like $foo.bar = 3; in terms of method calls

[12:42] <pmurias> i'm lookig at OO API on the wiki and can't find it

[12:42] <ruoso> $foo.bar => method bar is rw { $!bar }

[12:42] <pmurias> in the default p6opaque case

[12:43] <pmurias> and $!bar => ?

[12:44] <ruoso> $!bar =>  $obj.^!has('$!bar')

[12:45] <ruoso> sorry

[12:45] <ruoso> $!bar =>  $obj.^!has($package, '$!bar')

[12:45] <ruoso> this returns the container itself

[12:45] <ruoso> in the end...

[12:45] <ruoso> $foo.bar = 3;

[12:46] <ruoso> is a method call and a container STORE

[12:46] <ruoso> the container returned (for the default accessor) is the attribute container itself

[12:48] <ruoso> what I don't remember is if class Foo { has $.a; $!a = 1 } is valid

[12:49] <ruoso> pugs: class Foo { has $.a; method b { $!a = 1 } }; my $a = Foo.new; $a.b; say $a.a;

[12:49] <p6eval> pugs: OUTPUT[1␤]

[12:49] <moritz_> $.a automatically generates a $!a alias

[12:49] *** ashizawa left
[12:49] <ruoso> in SMOP... $.a never exist as an attribute

[12:49] <ruoso> it is a syntax expansion of " has $!a; method a { $!a } "

[12:49] <ruoso> sory

[12:49] <ruoso> it is a syntax expansion of " has $!a; method a is rw { $!a } "

[12:49] <moritz_> so the access control is done on the compiler level, not on SMOP level?

[12:50] <ruoso> not the access control actually...

[12:50] <ruoso> it's just that "has $.a" is a syntax convenience only...

[12:50] <ruoso> because there are no really public attributes

[12:50] <ruoso> you have default accessors created for some attributes based on the syntatic format

[12:51] <ruoso> and that's it

[12:51] <moritz_> rakudo: my @a = 1, 2; push @a, eval(@a.perl); say @a.perl

[12:51] <p6eval> rakudo 29553: OUTPUT[[1, 2, [1, 2]]␤]

[12:52] <moritz_> rakudo: my @a = 1, 2; push @a, @a; say @a.perl

[12:52] <p6eval> rakudo 29553: OUTPUT[[1, 2, 1, 2]␤]

[12:52] *** alanhaggai__ joined
[12:53] *** alanhaggai__ is now known as alanhaggai

[12:55] <ruoso> pmurias, does it make sense to you?

[12:57] *** alanhaggai_ left
[12:57] <ruoso> pugs: class Foo { has $.a }; my $a = Foo.new(); my $b := $a.a; $b = 2; say $a.a;

[12:57] <p6eval> pugs: OUTPUT[2␤]

[12:57] <ruoso> hmm

[12:57] <ruoso> interesting...

[12:58] <moritz_> looks correct to me

[12:58] <ruoso> was everyone aware to this side effect?

[12:58] <pmurias> ruoso: your description makes sense

[12:58] <moritz_> from a programmer's point of view an attribute is the same as any other item in a data structure

[12:59] <pmurias> ruoso: what's wrong with that?

[13:00] <ruoso> maybe it's ok... it looks like breaking encapsulation... but only as far as the returned container is the actual attribute container... but that can always be overriden... so it's not breaking the encapsulation...

[13:01] <pmurias> ruoso: re syntax convenience only, aren't public attributes specialy marked for introspection?

[13:01] *** cmarcelo joined
[13:01] <ruoso> pmurias, yes. But that's why you have both the attribute descriptions in the "metadata" section and the instance storage

[13:02] <ruoso> the introspection goes trhough the metadata section... the access go through the "instance storage" section

[13:02] <ruoso> the attribute then has both a "private_name" and a "name"

[13:03] <ruoso> where the private name is the effective name... and "name" is the declared name

[13:04] <ruoso> pmurias, btw... I was wrong on which method $!a maps to...

[13:04] <ruoso> it's not $foo.^!has... but $foo.^!private_storage($package, 'bar')

[13:04] <ruoso> actually...

[13:05] <ruoso>  $foo.^!private_storage($package).LOOKUP('bar')

[13:05] <pmurias> $foo.^!private_storage($package).{'bar'}

[13:05] <ruoso> yes... that's more precise...

[13:05] <pmurias> LOOKUP seems a kp6'ism

[13:06] *** alanhaggai left
[13:06] <ruoso> so $!a = 3; in the end will mean $foo.^!private_storage($package).{'bar'}.STORE(3)

[13:11] <pmurias> we could ue as hash for private_storage?

[13:11] <pmurias> * use

[13:16] *** barney joined
[13:18] <ruoso> you mean $foo.^!private_storage.{$package}{'bar'}?

[13:22] <pmurias> yes

[13:22] <pmurias> at least internally

[13:23] <ruoso> well.. if you look at p6opaque.h... that's kinda how I'm doing it

[13:23] <ruoso> it's just a matter of how the API is exposed...

[13:23] <ruoso> since everything is already made in terms of method calls

[13:31] <pugs_svn> r21361 | pmurias++ | [smop/misc] how i think the p6opaque structure is in p6 syntax

[13:33] <pmurias> we could just use Hashes and Arrays instead of reimplementing them

[13:33] *** orafu joined
[13:36] <pmurias> and throw away the LOWL_{PoH,A,H,HoH...}

[13:40] <ruoso> pmurias, yes... that's a possibility... I initially thought it would be easier doing that way...

[13:40] <ruoso> (the LOWL* way)

[13:40] <ruoso> but maybe I'm just wrong...

[13:41] *** alanhaggai joined
[13:41] *** bloonix joined
[13:41] <pmurias> if the methods are going to me in sm0p/p6 and you seem to be doing it that way the LOWL_* will be a nuisance

[13:41] <bloonix> hello

[13:42] <ruoso> pmurias, they don't need to be (in the constant-identifiers case)

[13:42] <ruoso> they can be implemented in plain C

[13:43] <pmurias> bloonix: hi

[13:44] <pmurias> ruoso: but in the non-constant case they have too?

[13:44] <ruoso> yes...

[13:45] <ruoso> because the calls to Str might need to recurse

[13:45] <ruoso> for instance

[13:45] <ruoso> but if you have a Hash implementation in place

[13:45] <ruoso> we could probably just use it instead

[13:46] <pmurias> the Hash is not a hash yet (i can change it) but it can be used

[13:48] <pmurias> ruoso: it would be good if you/we started thinking how everything will look on the sm0p side

[13:48] <ruoso> right...

[13:48] <ruoso> you mean, when composing the class?

[13:49] <ruoso> or which part?

[13:49] *** jferrero left
[13:49] <pmurias> yes

[13:50] <pmurias> class creation

[13:50] <pmurias> and loops and stuff

[13:53] <pmurias> i could try to get the p6opaque stuff finished, but i would need to know how it will be used

[14:00] *** penk left
[14:04] <ruoso> pmurias, my idea is that the p6 code will be translated to a single C function that would initialize the class by creating a new p6opaque object, pushing all the metadata  (using the REPR api) and save the class (or in the global namespace, or in a C symbol)

[14:04] <ruoso> this "bootstrap" function would be called by smop_init at some point...

[14:05] <ruoso> we could make it hard-coded by generating a file the same way I generate the constant identifier initialization

[14:05] <ruoso> or we could make a plugin thing that would call this function on all .so files in a specific runtime directory

[14:06] <ruoso> but one way or another, the p6 code would be compiled to the C+sm0p code that initializes the entire p6opaque

[14:07] <ruoso> creating the methods, creating the attributes, setting the metaclass, pushing the methods and attributes to the metadata ($p6opaque.^!methods.push($method))

[14:07] *** jhorwitz joined
[14:08] <ruoso> the last step would be to save this p6opaque into the namespace

[14:08] <ruoso> and the package object would also be saved into the namespace

[14:10] * ruoso thinks the plugin idea would be cool... /usr/lib/smop/Object.so

[14:12] <ruoso> we would need to have a runlevel thing, to have declared dependencies...

[14:13] <ruoso> /usr/lib/smop/000_Object.so /usr/lib/smop/001_Scalar.so

[14:14] <ruoso> maybe it's better to have a difference between autoloading this libraries or not...

[14:14] <ruoso> /usr/lib/smop/boot/000_Object.so /usr/lib/smop/FooBar.so

[14:16] *** alester joined
[14:17] <ruoso> pmurias, does it make sense to you?

[14:51] *** rindolf left
[14:52] *** Exodist joined
[15:06] <TimToady> pugs: class Foo { has $.a }; my $a = Foo.new(); my $b := $a.a; $b = 2; say $a.a;

[15:06] <p6eval> pugs: OUTPUT[2␤]

[15:07] <TimToady> that should really fail somewhere unless you have "has $.a is rw"

[15:07] <TimToady> but it appears that we're confusing lvalues with rvalues somewhere

[15:07] <moritz_> pugs: class Foo { has $.a }; my $a = Foo.new; $a.a = 3; say $a.a

[15:07] <p6eval> pugs: OUTPUT[3␤]

[15:07] <moritz_> pugs doesn't do any access control

[15:08] *** sail0r joined
[15:08] <TimToady> but it's like the method is returning the container instead of the value, or something

[15:09] <TimToady> pugs: class Foo { has $.a = 42 }; my $a = Foo.new; $a.a = 3; say $a.a

[15:09] <p6eval> pugs: OUTPUT[3␤]

[15:09] <TimToady> it's not because it's uninit

[15:10] <moritz_> TimToady: but should binding to an rw attribute work?

[15:11] <TimToady> I dunno--it's too early in the morning to think

[15:12] <TimToady> but it'll be kinda sad if all value returns have to be wrapped in a readonly proxy

[15:13] <TimToady> it really ought to fall out of ordinary lvalue/rvalue distinction, it seems

[15:13] <TimToady> but maybe I'm thinking of it wrong ETOOEARLY

[15:15] *** barney left
[15:18] *** sail0r left
[15:32] *** hercynium left
[15:41] *** zamanf is now known as zamanfou

[15:53] *** jan_ left
[16:00] *** braceta joined
[16:00] *** braceta left
[16:02] *** |jedai| joined
[16:03] *** Jedai left
[16:07] *** alanhaggai left
[16:23] *** alester left
[16:31] *** justatheory joined
[16:31] *** alanhaggai joined
[16:33] *** masak left
[16:59] <pmurias> ruoso: don't we use the HOW api for class building?

[17:03] * pmurias forgot his key, so couldn't get inside his flat for two hours :(

[17:04] *** nipotaway is now known as nipotan

[17:04] <pmurias> TimToady: is .methods rw?

[17:05] <pmurias> Foo.HOW.methods

[17:08] <pmurias> &

[17:08] *** PZt left
[17:09] *** hcchien joined
[17:12] *** meppl left
[17:13] <ruoso> pmurias, partly yes... but if we know it's a p6opaque we can call the REPR api directly and set the metaclas

[17:16] <[particle]> http://spec.pugscode.org down?

[17:17] *** jan_ joined
[17:20] *** hercynium joined
[17:26] <pmurias> ruoso: for normal object or during meta-model bootstrap?

[17:26] <ruoso> pmurias, during meta-model bootstrap

[17:26] <ruoso> afterwards, the object build must be done using HOW

[17:27] <pmurias> do we use anything which dosn't compile under g++ on purpose?

[17:28] <ruoso> not that I'm aware 

[17:29] *** simcop2387-vnc joined
[17:29] *** simcop2387 left
[17:29] *** simcop2387-vnc is now known as simcop2387

[17:30] *** cjfields joined
[17:33] <pmurias> \

[17:34] *** iblechbot left
[17:38] <TimToady> pmurias: I wouldn't think .methods should be rw.  there should probably be .add_method and .delete_method instead so that some degree of readonly-ness is possible for encapsulation

[17:38] *** hercynium left
[17:38] <TimToady> more generally, methods should be added by composition

[17:39] <TimToady> (plus subsequent mixin, where applicable)

[17:39] *** Nebster joined
[17:40] *** alester joined
[17:41] <TimToady> Nebster: welcome to #perl6 from #parrot  :)

[17:42] *** cjfields left
[17:44] <Auzon> Ah, I found out what a StopIteration error is :)

[17:44] <ruoso> TimToady, we could tie the openness of some class to the rw'ness of .methods 

[17:48] <pmurias> classes can only be closed by a compile time pragma

[17:52] *** Lorn joined
[17:54] *** hercynium joined
[17:55] <TimToady> no, I think openness should be determined by .add_method, and .methods should always be ro

[17:57] <pmurias> ruoso: g++ dosn't like complex

[17:58] <ruoso> pmurias, I'm not even sure "complex" is implemented

[17:58] <ruoso> you could comment it out for now, and let someone implement it later...

[17:58] <pmurias> ok

[17:58] <pmurias> ruoso: do you now how to make autotools use llvm?

[17:59] *** kanru left
[17:59] <ruoso> pmurias, nope... but I think there's something in llvm docs about it

[18:00] <pmurias> lowlevel methods will take a slime frame as a argument?

[18:00] *** alester left
[18:02] <pmurias> &

[18:02] <speckbot> r14567 | larry++ | Equivalence of cascaded and semicolon subscript forms suggested by nick++

[18:02] *** Chillance joined
[18:06] *** rindolf joined
[18:07] *** justatheory left
[18:09] *** DietCoke joined
[18:09] <DietCoke> TimToady: that syn update you just committed, reads 

[18:09] <Auzon> rakudo: my %hash_v = ( a => 1, b => 2, c => 3 ); for %hash_v.values -> $val is rw { $val++ }; say %hash_v.perl # I swore this used to work

[18:09] <p6eval> rakudo 29562: OUTPUT[increment() not implemented in class 'String'␤current instr.: 'postfix:++' pc 13272 (src/gen_builtins.pir:8538)␤]

[18:09] <DietCoke> types are expected succeed ... should be "expected to succeed"

[18:10] *** Alias_ left
[18:10] <DietCoke> @tell timtoday that syn update you just committed, reads "types are expected succeed" ... should be "expected to succeed"

[18:10] <lambdabot> Consider it noted.

[18:10] <speckbot> r14568 | larry++ | typo from DietCoke++

[18:11] <DietCoke> ... or I could just be impatient. =-)

[18:11] *** cjfields joined
[18:11] <pmurias> b

[18:11] *** DietCoke left
[18:12] *** meppl joined
[18:15] *** lisppaste3 left
[18:16] *** lisppaste3 joined
[18:18] <rindolf> Hi all.

[18:19] <pmurias> rindolf: hi

[18:19] *** iblechbot joined
[18:21] <pmurias> ruoso: shouldn't it be $obj.^!how = $obj instead of $obj.^!how($obj)?

[18:23] <ruoso> pmurias, I tried to simplify it a little... because doing that would require returning a container that would be able to receive a STORE call

[18:24] *** kanru joined
[18:28] <ruoso> pmurias, but maybe it's a bad idea

[18:28] <ruoso> pmurias, or maybe that should be just an signature option, complementary with method ^!how is rw

[18:29] <pmurias> either one or the other

[18:29] <ruoso> you mean it's either a bad idea or it should be a signature option?

[18:30] <pmurias> either a $obj.^!how($obj) or $obj.^!how = $obj;

[18:30] <ruoso> yeah... that's probably ok

[18:30] <ruoso> because you need a huge overhead to support the is rw thing

[18:32] <pmurias> what do you mean by a signature option?

[18:33] <ruoso> mmd

[18:34] <ruoso> but that mmd would be implemented in low-level 

[18:34] <ruoso> because the REPR methods are intercepted by the RI

[18:34] <pmurias> having fast mmd is hard but would be tremenously help full

[18:34] <pmurias> having both interfaces dosn't make sense

[18:36] <ruoso> pmurias, if you'd like to change it, feel free...

[18:36] <ruoso> this inconsistency probably a bad idea

[18:39] <Nebster> TimToady: Hi, had to go out, :P

[18:39] <Nebster> What has $| changed to for disabling buffering?

[18:40] <Nebster> I've got: select((select($Client), $| = 1)[0]); # Disable Buffering

[18:40] <ruoso> Nebster, I'd guess to something like the OO api provided by IO::Handle

[18:41] <ruoso> $*OUT.autoflush = 1;

[18:41] <Nebster> OO api?

[18:43] <ruoso> Nebster, when you "use IO::Handle", you can STDOUT->autoflush(1)

[18:43] <ruoso> then you don't need the "select, select" trick

[18:44] <TimToady> but none of the implementations are very far along in terms of I/O yet

[18:48] <TimToady> and, in fact, autoflush is missing from the draft IO spec, so it's probably on of those things that's just assumed to be the same as in Perl 5, at least until we change our mind...

[18:48] <Nebster> Ok, thanks

[18:49] <ruoso> TimToady, you think there should be some native support for concurrent non-threaded IO using continuations? 

[18:49] <ruoso> TimToady, (I think it was you that posted me a link about how that is made in haskell)

[18:51] <moritz_> concurrent, non-threading? like STM?

[18:51] <ruoso> moritz_, not really... more like Any::Event

[18:51] <TimToady> don't think it was me

[18:51] <ruoso> sorry... AnyEvent

[18:52] *** chris2 left
[18:52] <ruoso> but the idea is to allow writing non-event-based programs that behave like event-based programs

[18:53] <Nebster> Does anyone know what this means: Method 'lvalue' not found for invocant of class 'PAST::Stmts'

[18:55] <ruoso> TimToady, moritz_, the based idea is that instead of blocking on IO, the continuation would be yelded to the interpreter that would only continue it when the IO is ready to be read/writen

[18:56] <moritz_> Nebster: it means that you are trying to do a list assign that's not yet implemented

[18:56] <moritz_> Nebster: something like my ($a, $b) = 1, 2;

[18:57] <ruoso> TimToady, moritz_, the interpreter could then wait for events related to several continuations... 

[18:57] <Nebster> So this would cause it: ($DestHost, $DestPort) = split(":", $1);

[18:58] <moritz_> yes

[18:58] <moritz_> sadly :/

[18:59] <Nebster> is this all implement in PIR?

[18:59] <Nebster> I might just convert to that

[18:59] <Nebster> Since I want to stay up-to-date with Parrot but with this simple script working

[18:59] <Nebster> Well, it's really just a proxy

[19:02] <TimToady> okay, you're referring to http://www.seas.upenn.edu/~lipeng/homepage/unify.html

[19:02] <lambdabot> Title: Unifying events and threads

[19:02] <ruoso> TimToady, exactly

[19:03] <moritz_> Nebster: if you want to get something working, perl5 is the much faster road atm :/

[19:03] <Nebster> I know, but I like parrot :P

[19:03] <Nebster> Does the "use perl5" statement work?

[19:03] <Nebster> I remember reading about it somewhere

[19:03] *** jfredett_ is now known as jfredett

[19:04] <moritz_> no

[19:04] <pmurias> it's use v5;

[19:04] <pmurias> it dosn't work on parrot

[19:04] <Nebster> ok

[19:04] <pmurias> pugs: use v5;print "p5\n";

[19:04] <p6eval> pugs: OUTPUT[pugs: Prelude.last: empty list␤]

[19:04] <Nebster> And how would I go about converting .Net to PIR?

[19:05] <moritz_> I think #parrot is the better place to ask this

[19:05] <Nebster> Ok

[19:05] <Nebster> Thanks for all the help :)

[19:06] <moritz_> you're welcome

[19:11] <pmurias> ruoso: if you want to try to implement p6opaque using Array's and Hash's were should my attempt live?

[19:11] <pmurias> s/you/i

[19:11] <ruoso> pmurias, you can take p6opaque over

[19:11] <ruoso> if you start it, I'll collaborate with you

[19:12] <pmurias> good ;)

[19:15] <ruoso> pmurias, p6opaque is the major milestone we have ahead... once we have it, a lot of good things will come...

[19:17] *** rlb3 left
[19:18] <pmurias> does the current implementation do much?

[19:19] *** stevan_ joined
[19:19] <ruoso> pmurias, I've only implemented .^!how and .^!methods, where .^!methods return a proxy object that introspect the internals of p6opaque

[19:20] *** rindolf left
[19:23] <ruoso> pmurias, just remember one thing... the methods must support more then one instance per name...

[19:24] *** justatheory joined
[19:24] <pmurias> that was the part i meant to ask about

[19:24] <ruoso> pmurias, it just mean that you need a Hash of Arrays, not a Hash of Methods

[19:24] <pmurias> why do we need a bunch of methods for names, multis

[19:25] <pmurias> a Hash of Arrays of Methods

[19:25] <pmurias> a Hash of Arrays of Method

[19:25] <ruoso> yes...

[19:25] <pmurias> don't the multis merge magicly into a single method?

[19:26] <ruoso> pmurias, I'm not sure how that relates to multi inheritance...

[19:27] *** rlb3 joined
[19:27] <ruoso> I don't think it's possible to merge them into a single method

[19:28] <ruoso> (maybe as a optimization, later, but conceptually... I don't think so)

[19:28] <pmurias> multi method performace is very important

[19:29] <pmurias> in the long run that is

[19:29] <pmurias> ;)

[19:29] <ruoso> pmurias, I mean... you can only merge it as a cache implementation

[19:29] <ruoso> that must be invalidated accordingly

[19:31] <pmurias> yes

[19:32] *** rindolf joined
[19:33] <pmurias> ^!methods is speced on the wiki  to returnn an Array of Methods...

[19:35] <ruoso> pmurias, this is confused because $foo.^methods returns a list

[19:35] <ruoso> but we could make the REPR api more storage-friendl

[19:35] <ruoso> and make it return a Hash of Array of Method

[19:36] <moritz_> rakudo: say uc "ä"

[19:36] <p6eval> rakudo 29563: OUTPUT[\xC4

[19:39] <pmurias> the metadata pointer can be shared?

[19:40] <ruoso> pmurias, you mean by being accessed inside the proxy objects (like the methods hash?)

[19:40] <ruoso> or by being used as the metadata for several p6opaques?

[19:41] <pmurias> like being used for several p6opaues

[19:42] <ruoso> I don't think so...

[19:42] <ruoso> that's the reason for "instanceof"

[19:42] <pmurias> it doesn't contain anything object specific in class based .HOWs

[19:43] <pmurias> what does the instanceof point to?

[19:43] <ruoso> to the prototype

[19:43] <pmurias> can the metadata be NULL?

[19:44] <ruoso> on objects that have a instanceof, yes... that's the plan

[19:45] <pmurias> we could make metadata a SMOP_Object* and just share it for class based oo

[19:46] <ruoso> hmm

[19:47] <pmurias> we would need an to make instanceof an array for real prototype oo (not some punny javascript oo)

[19:48] <pmurias> s/punny/crapy/

[19:48] <pmurias> s/crapy/puny/

[19:50] *** PZt joined
[19:51] <ruoso> pmurias, in class-based OO the HOW is a p6opaque also

[19:51] <ruoso> where the metadata is defined

[19:51] <ruoso> the protoobject contains the "how" reference in the metadata

[19:52] <ruoso> and the instance "instanceof" the protoobject

[19:53] <ruoso> different from prototype-based OO

[19:53] <ruoso> where the prototype has the metadata

[19:54] <ruoso> and a reference to the HOW

[19:54] <ruoso> that simply knows how to traverse the protoobject metadata

[19:58] *** alester joined
[19:59] <pmurias> ruoso: the HOW dosn't have to be a p6opaque

[20:00] <ruoso> pmurias, yeah... right... sometimes I forget how polymorphic smop is ;)

[20:01] <pmurias> i'll just make metadata a SMOP_Object*, it might help later ;)

[20:02] <ruoso> pmurias, I'm not sure about it

[20:02] <ruoso> because it was supposed to be part of the p6opaque storage

[20:04] <pmurias> it's stored in p6opaque, just as a SMOP_Object*

[20:08] <Auzon> Is pugscode.org down?

[20:11] <moritz_> at least apache is down

[20:14] <moritz_> [Thu Jul 17 22:09:53 2008] [crit] (28)No space left on device: mod_rewrite: could not create rewrite_log_lock

[20:14] <moritz_> Configuration Failed

[20:16] <moritz_> ok, back up and running

[20:19] <Auzon> :)

[20:20] <pmurias> ruoso: any idea what can undefined reference to `SMOP__p6opaque(int0_t &) be?

[20:22] <pmurias> ack does find a mention of it, and i don't know if autotools can cause anything like that

[20:24] <pmurias> gcc -Wall -D_GNU_SOURCE -I../include -g -O2 -o .libs/01_smop_lowlevel.t 01_smop_lowlevel.o  -L/home/pawel/p6/v6/smop/src /home/pawel/p6/v6/smop/src/.libs/libsmop.so -lpthread

[20:24] <pmurias> /home/pawel/p6/v6/smop/src/.libs/libsmop.so: undefined reference to `SMOP__p6opaque(int0_t &)'

[20:27] <pmurias> shower&

[20:29] *** cjfields_ joined
[20:30] <ruoso> pmurias, I have no idea... it's something svn diff will show you

[20:30] <ruoso> since I'm not experiencing this issue

[20:30] * ruoso home &

[20:31] <pugs_svn> r21362 | Auzon++ | [gsoc_spectest] added tests to for.t and fudged it for rakudo. (added 3 tests)

[20:32] <Auzon> S04-statements/for.t should be good to add to spectest_regression

[20:32] * moritz_ checks

[20:34] <moritz_> ah, the "implicit invocant" fudge messages aren't correct

[20:34] <moritz_> (I guess they are my fault)

[20:34] <Auzon> I didn't mess with the existing messages :-/

[20:34] <moritz_> the tests are wrong, because you can't call a sub as method

[20:35] <moritz_> Auzon: no worries, I'm going to fix them some day [tm]

[20:35] <moritz_> when we have 'class Int is also {...}' we can just put them as methods in Int ;-)

[20:38] <moritz_> rakudo: 42 - 19

[20:38] <p6eval> rakudo 29563: RESULT[23]

[20:40] <rakudo_svn> r29564 | moritz++ | [rakudo] added S04-statements/for.t to spectest_regression, Auzon++

[20:40] <rakudo_svn> r29564 | moritz++ |  +23 pass, +19 todo/skip tests

[20:41] *** jferrero joined
[20:41] <moritz_> perlbot: karma Auzon 

[20:41] <perlbot> Karma for Auzon: 129

[20:42] *** wknight8111 joined
[20:46] *** cjfields left
[20:48] *** pmurias left
[20:48] <pugs_svn> r21363 | putter++ | [misc/elfish/rx_on_re]  Setting up for development; hit a perlbug.

[20:48] <pugs_svn> r21363 | putter++ | The Regexp_ModuleA.pm tests now run.  Created a elf_f+Regexp_ModuleA hybrid.

[20:48] <pugs_svn> r21363 | putter++ | make check  partially runs.

[20:48] <pugs_svn> r21363 | putter++ | But perl 5.10 then malloc panics and segfaults.  Notes in README.

[20:48] <pugs_svn> r21363 | putter++ | Absent someone interested in debugging perlguts, this may be a showstopping

[20:48] <pugs_svn> r21363 | putter++ | blocker on this development path (towards a fast rx/re engine written in p6).

[20:48] *** ruoso left
[20:50] *** pmurias joined
[20:52] *** justatheory left
[20:53] <moritz_> @tell mncharity re r21363, fglock saw similar perl bugs in regexes which contained some code assertions. Moving them into subs and out of the blocks (only call them from the blocks) helped

[20:53] <lambdabot> Consider it noted.

[20:55] *** rindolf left
[20:55] <pugs_svn> r21364 | putter++ | elf/README: Mention the ELF_STD_RED_RUN configuration env var.

[20:55] <pugs_svn> r21364 | putter++ | Which permits arbitrarily moving/installing copies of elf.

[21:06] <pmurias> @tell ruoso it turned out gcc was just printing a wrong error message

[21:06] <lambdabot> Consider it noted.

[21:07] *** rlb3 left
[21:08] *** iblechbot left
[21:14] *** justatheory joined
[21:16] <pugs_svn> r21365 | pmurias++ | [smop] moved the old p6opaque attempt to misc, started a new more SMOP__Objecty one

[21:16] <pmurias> moritz_: that way backtracking is lost

[21:18] *** rlb3 joined
[21:18] <moritz_> pmurias: why?

[21:18] <Auzon> perl6: my $x; $x++; say $x;

[21:18] <p6eval> elf 21364: OUTPUT[1␤]

[21:18] <p6eval> ..pugs: OUTPUT[1␤]

[21:18] <p6eval> ..rakudo 29564: OUTPUT[increment() not implemented in class 'Undef'␤current instr.: 'postfix:++' pc 13272 (src/gen_builtins.pir:8538)␤]

[21:19] <pmurias> moritz_: wait...

[21:20] <moritz_> instead of m/(??{ $stuff_here })/ just do sub stuff_1 { $stuff_here }; m/(??{ stuff_1() })/

[21:20] <moritz_> for a bit more complex $stuff_here that solves a lot of problems

[21:27] *** donaldh joined
[21:27] <pmurias> kp6 ended up giving up on ??{} blocks

[21:36] *** japhb left
[21:40] *** pbuetow_ left
[21:44] *** rindolf joined
[21:48] *** Limbic_Region joined
[21:53] *** pmurias left
[22:01] *** rindolf left
[22:04] *** bacek joined
[22:13] *** cjfields_ left
[22:17] *** hercynium left
[22:18] *** japhb joined
[22:22] *** eternaleye joined
[22:26] <pugs_svn> r21366 | lwall++ | [STD] unspace tweaks

[22:28] *** donaldh left
[22:30] <TimToady> yes, until p5's regex runs in the same runloop as ordinary code, it's pretty much hopeless to get closures and recursion correct with interwoven regex and code, I suspect

[22:30] <TimToady> you'll note that STD.pmc uses only the most basic of P5 regexen

[22:31] <TimToady> because I wanted it to work right, and fast can come later

[22:38] *** alester left
[22:38] *** jferrero left
[22:41] *** kanru left
[22:41] *** cmarcelo left
[22:55] <Auzon> perl6: my $foo = 42; if $foo -> $x {say $x}

[22:55] <p6eval> elf 21366: RESULT[CODE.new(!!!)␤]

[22:55] <p6eval> ..pugs: OUTPUT[*** Cannot bind to non-existing variable: "$x"␤    at /tmp/o6qbx4IeYu line 1, column 1␤]

[22:55] <p6eval> ..rakudo 29569: OUTPUT[Statement not terminated properly at line 1, near "-> $x {say"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[22:55] <Auzon> That should say 42, correct?

[22:58] *** Lunchy left
[22:59] *** Alias_ joined
[23:02] *** bacek_ joined
[23:03] *** |jedai| left
[23:04] *** Lunchy joined
[23:04] *** |jedai| joined
[23:08] <bacek_> pugs: my $j = 1|2|3; say $j < 2;

[23:08] <p6eval> pugs: OUTPUT[any(VBool False,VBool True)␤]

[23:09] <bacek_> rakudo: my $j = 1|2|3; say $j < 2;

[23:09] <p6eval> rakudo 29569: OUTPUT[1␤]

[23:10] *** Exodist left
[23:10] <bacek_> pugs: my $j = 1|2|3; say $j.perl;

[23:10] <p6eval> pugs: OUTPUT[\(1 | 2 | 3)␤]

[23:12] <bacek_> rakudo: my $j = 1|2|3; say $j.perl;

[23:12] <p6eval> rakudo 29569: OUTPUT[any(1, 2, 3)␤]

[23:14] <pugs_svn> r21367 | lwall++ | [Cursor] fix _PATTERN to set endpoint correctly so we can optimize multiple

[23:14] <pugs_svn> r21367 | lwall++ | matching nodes to single P5 regexes where appropriate

[23:15] <pugs_svn> r21368 | Auzon++ | [gsoc_spectest] moved do.t into spec, added tests, fudged for rakudo. (added 3 tests)

[23:15] <Auzon> t/spec/S04-statements/do.t should be ready for spectest_regression

[23:15] <bacek_> pugs: my $j = 1|2|3; say ($j < 2).perl;

[23:15] <p6eval> pugs: OUTPUT[(Bool::False | Bool::True)␤]

[23:16] *** Alias__ joined
[23:17] *** Alias_ left
[23:18] <Limbic_Region> TimToady - how much of STD.pm does STD.pm parse now?

[23:19] *** bacek left
[23:26] *** pjcj left
[23:26] *** Nebster left
[23:27] *** bacek_ left
[23:32] *** bacek joined
[23:34] <bacek> pugs: my $j = 1|2|3; say ?$j;

[23:34] <p6eval> pugs: OUTPUT[any(VBool True)␤]

[23:36] <bacek> pugs: my $j = 0|0|0; say ?$j;

[23:36] <p6eval> pugs: OUTPUT[any(VBool False)␤]

[23:43] *** Limbic_Region left
