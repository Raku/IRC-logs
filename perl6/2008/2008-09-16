[00:02] *** eternaleye_ joined
[00:17] *** iblechbot left
[00:32] *** charsbar left
[00:32] *** charsbar_ joined
[00:47] *** eternaleye_ left
[00:55] *** ab5tract left
[01:14] *** elmex left
[01:20] *** BinGOs_ left
[01:27] *** BinGOs joined
[02:08] *** ab5tract joined
[02:21] <rakudo_svn> r31169 | jkeenan++ | Make file conform to no trailing whitespace coding standard.

[02:22] *** Limbic_Region left
[02:28] <meppl> good night

[02:30] *** meppl left
[02:55] *** AzureStone_ left
[02:56] *** kanru left
[02:59] *** AzureStone__ left
[02:59] *** ispy_ joined
[02:59] *** AzureStone joined
[03:01] *** kanru joined
[03:08] *** wknight8111 left
[03:11] *** sail0r joined
[03:12] *** sail0r left
[03:13] *** eternaleye_ joined
[03:14] *** _jedai_ left
[03:14] *** Ontolog joined
[03:14] *** _jedai_ joined
[03:29] *** Alias_ joined
[03:32] <Ontolog> does Perl6 have some sort of "in" operator ala SQL?

[03:34] <xinming> Ontolog: What do you mean?

[03:34] <xinming> example is better. ;-)

[03:34] <s1n> he means is a value contained in a list/hash...

[03:34] <Ontolog> yes

[03:35] <Ontolog> $a in @array is true if @array contains a value $a

[03:35] <xinming> isany

[03:35] <literal> $a ~~ @array

[03:35] <xinming> it does

[03:35] <Ontolog> i see

[03:35] <Ontolog> ~~ does a lot of things?

[03:35] <literal> yes

[03:35] <Ontolog> I saw ~~ also checks the type

[03:35] <literal> it is the "smart match operator"

[03:35] <Ontolog> ah

[03:36] <literal> one of those Do What I Mean things :)

[03:36] <Ontolog> i am disappointed that subroutine arguments are not copy per default but read-only

[03:37] <Ontolog> i would think people expect copy

[03:38] <xinming> Ontolog: this is the sane default, If you really want copy, is copy can do that.

[03:38] <Juerd> What you expect depends on what you're used to 

[03:39] <Juerd> Copying makes awfully little sense to me, but I grew up with Visual Basic where I was taught to use ByRef as much as possible for performance reasons (not to actually change the values), and Perl 5 where pass-by-reference is the default

[03:40] <Juerd> Perl 6 will add write protection, to save your gut.

[03:40] <s1n> i cannot conceive a good reason to use pass-by-value on anything other than the case when you want it unmodified

[03:40] <s1n> but even then, there's usually write protection available in most languages

[03:41] <Juerd> One reason is the contrived idea of compatibility with my ($foo, $bar) = @_;

[03:41] <Juerd> Downright silly IMO

[03:42] <Juerd> But I'm off to get some sleep; it's 541 am here.

[03:42] <Juerd> Highlight of the day: waiting 10 minutes in front of a red traffic light, calling the police and ignoring the light with permission :)

[03:43] <Juerd> Yes, I had an extremely boring day.

[03:43] <Juerd> Good localtime

[03:43] <Juerd> afk

[03:44] <Ontolog> you actually called them and got permission??

[03:45] <Ontolog> you should have just ran it silly man!!!

[03:46] *** mncharity joined
[03:49] *** dragon3 joined
[03:50] <mncharity> moritz_: ok, a thrice+ repeated hint suffices. :)  http://perl.net.au/wiki/Elf   Questions, comments, etc, welcome all.  moritz++

[03:50] <lambdabot> Title: Elf - PerlNet

[03:50] <Ontolog> do I still have to do 'use strict;' and 'use warnings;'?

[03:50] <Ontolog> or is that default now?

[03:51] <s1n> currently, use strict is sort of enforced

[03:52] <Ontolog> are there new suggested filename extensions for scripts and object modules?

[03:52] <Ontolog> or is it still .pl and .pm?

[03:52] *** mncharity left
[03:54] *** ispy_ left
[03:56] <literal> still .pl and .pm as far as I know

[03:56] <Ontolog> anyone have a vim syntax file for Perl 6?

[03:57] <literal> here's one: http://svn.openfoundry.org/pugs/util/perl6.vim

[03:57] <literal> don't know how much it covers though

[03:59] <Ontolog> awesome, thanks!

[04:07] <Ontolog> do we still have __DATA__ sections?

[04:08] <PerlJam> Ontolog: no, they've been subsumed into POD

[04:08] <Ontolog> not sure I understand

[04:09] <PerlJam> Ontolog: something like =begin DATA  ... =end DATA   and you get a filehandle to access it.  So now you can have more than one "__DATA__" section

[04:09] <Ontolog> that's cool, where is this documented?

[04:10] <literal> probably in the Synopsis on Pod

[04:10] <PerlJam> S02 I think

[04:11] <PerlJam> yep, that's it.

[04:11] <PerlJam> __DATA__   becomes =begin DATA and the filehandle is $=DATA

[04:14] <Ontolog> so you can have more than one __DATA__ section but actually they are all aggregated into one "file" accessed via $=DATA, is that correct?

[04:14] <literal> no

[04:14] <literal> you can have =begin WHATEVER_YOU_WANT

[04:14] <Ontolog> ohhh haha i get it

[04:15] <Ontolog> so =begin FARTS will let me get data from $=FARTS?

[04:15] <literal> yes

[04:15] <Ontolog> i see that's cool

[04:15] <literal> http://dev.perl.org/perl6/doc/design/syn/S02.html

[04:16] <lambdabot> Title: Synopsis 2: Bits and Pieces - perl6

[04:18] *** justatheory left
[04:19] <Ontolog> yeah I've been looking at that document

[04:19] <Ontolog> So if I want some code to run when a class is loaded (I want to initialize some class attributes), where do I put that code?

[04:20] <PerlJam> "when a class is loaded"?  What does that mean?

[04:23] <literal> you mean when an object is instantiated? e.g. a constructor?

[04:23] <s1n> Ontolog: you mean like the BEGIN blocks?

[04:24] <s1n> is that even in perl6?

[04:25] <PerlJam> s1n: aye

[04:25] <literal> S02 has something to say about BEGIN blocks

[04:25] <Ontolog> i mean exactly, when a class is loaded

[04:25] <Ontolog> if Perl 6 decides that happens when the first object is instantiated that is fine i don't care

[04:26] <Ontolog> actually, even before the first class method invocation

[04:27] <PerlJam> Ontolog: I still don't understand what you mean by "when a class is loaded".  What does it mean to "load" a class?  Classes can be defined and put in files and those files can be "loaded".  But these things are orthogonal.

[04:27] <literal> Ontolog: an example would help

[04:28] <pmichaud> when defining a class, the statements inside the class definition are executed when it's loaded, as if it were a BEGIN block.

[04:28] <pmichaud> class Foo { say 'hello'; ... }

[04:28] <Ontolog> i see

[04:28] <Ontolog> so that should work for me

[04:52] <Ontolog> defining class attributes?

[04:52] <Ontolog> 'has' is only for object attributes yes?

[04:53] *** rindolf joined
[04:55] <literal> our?

[05:00] <Ontolog> i don't know, i'm asking you

[05:00] <literal> I don't know either :)

[05:09] *** pht joined
[05:19] *** Psyche^ joined
[05:20] <pmichaud> our defines package-scoped variables

[05:21] <Ontolog> a package is the same as a class yes?

[05:21] <pmichaud> which act like class attributes in this case.  See S12, the line that starts "Class attributes are declared with either my or our"

[05:21] <Ontolog> yes i saw that

[05:22] <Ontolog> so what's the different between my and our

[05:22] <pmichaud> my is a lexically scoped variable, our is package scoped

[05:23] <Ontolog> so my can only be used to declare private class attributes?

[05:23] <pmichaud> see S12 :-)

[05:23] <literal> hm, http://perlcabal.org/syn/Differences.html <-- this says that Pod will be replaced with Kwid, yet S26 says nothing about Kwid

[05:23] <Ontolog> yeah i have it open and i'm reading it

[05:23] <lambdabot> Title: Perl6::Perl5::Differences

[05:23] <pmichaud> literal: I think that document was written prior to S26

[05:24] <literal> ah, ok

[05:24] <literal> so Pod's not going anywhere?

[05:24] <pmichaud> literal: well, perl 6 pod is different from perl 5 pod

[05:24] <literal> of course

[05:24] <pmichaud> so it went "somewhere" :-)

[05:24] <literal> not too far I hope

[05:25] <literal> that Kwid thing didn't look good

[05:25] <Ontolog> so I still use the 'use' keyword for importing class definitions?

[05:26] <pmichaud> Ontolog: yes

[05:33] *** Patterner left
[05:33] *** Psyche^ is now known as Patterner

[05:37] <pasteling> "Ontolog" at 59.37.36.178 pasted "Cast error" (7 lines, 245B) at http://sial.org/pbot/32180

[05:37] <Ontolog> I get a casting error, it sucks

[05:38] <pmichaud> you probably want   for =$=DATA instead

[05:39] <pmichaud> it looks to me as though =$=DATA is being evaluated in list context for the 'while' modifier.

[05:39] <Ontolog> i see, i'll give it a shot

[05:39] <Ontolog> so while evaluates things in list context?

[05:39] <Ontolog> does perl5 work that way?

[05:40] <pmichaud> I don't know that pugs is correct here.

[05:40] <Ontolog> same error with for

[05:40] <pmichaud> i.e., for any of the perl6 implementations, it's not entirely safe to assume that because the implementation does something a certain way that that's the way that perl 6 defines it

[05:40] <pmichaud> i.e., the implementations are still catching up with the spec

[05:40] <Ontolog> yes i know

[05:42] <pmichaud> how about   for =$=DATA { %validPinyin{$_} = chomp $_ }

[05:43] <Ontolog> same result

[05:44] *** dragon3 left
[05:47] <Ontolog> no matter what I do with that $=DATA object I get this error

[05:48] <pmichaud> maybe pugs doesn't do iterators on this yet

[05:48] <pmichaud> I don't know.

[05:48] <pmichaud> sorry.

[05:48] <Ontolog> i'm gonna try with rakudo

[05:48] <pmichaud> I'm certain rakudo doesn't handle POD data yet.  

[05:49] <Ontolog> shit

[05:49] <Ontolog> maybe i should wait another couple years before trying out perl6

[05:49] *** _jedai_ left
[05:56] *** charsbar_ left
[05:56] *** charsbar joined
[05:57] *** mberends joined
[05:57] *** Ontolog left
[06:01] *** agentzh left
[06:04] *** eternaleye_ left
[06:06] *** eternaleye joined
[06:09] *** cognominal left
[06:10] *** ashizawa joined
[06:12] *** cognominal joined
[06:40] *** jferrero joined
[06:56] *** agentzh joined
[06:56] *** iblechbot joined
[07:08] *** Ontolog joined
[07:18] *** ab5tract left
[07:23] *** kanru left
[07:35] <dduncan> opinion question - which sounds like a better name for a generic data type that represents a single point in time at an arbitrary precision: 'instant' or 'moment' or something else?

[07:37] <moritz_> "something else" is certainly too long ;)

[07:37] *** Myoma left
[07:38] <dduncan> yes

[07:38] <dduncan> personally I'm thinking 'instant' is the better of the two, since 'moment' seems to have more unrelated meanings, in physics

[07:39] <moritz_> aye

[07:41] *** kanru joined
[07:42] <pht> you should also know that there is no such thing as single point in time in physics

[07:42] <pht> but i would go with something simple like Time, because that is also what normal time() is

[07:43] <pht> or TimePoint ...

[07:43] <pht> 'instant' has confusing associations

[07:48] <dduncan> sure

[07:51] <dduncan> however, the data type I was talking about is a base type, and has subtypes [DateTime, Date, Time] which is what people would typically be using, and that would probably reduce confusion ... the main times one would use Instant directly (and one reason it exists distinctly) is if they want to express a different precision than YMDHIS or YMD or HIS; eg, if they just want to specify a year-month or hour-minute

[07:51] <mberends> sometimes 'when' reads easily, but given its new keyword meaning, it's a non starter

[07:52] <dduncan> yes, I thought of 'when' too but dismissed it as sounding too much like a non-noun

[07:52] <dduncan> I do tend to name my date/time containing variables $when_this and $when_that though

[07:53] <dduncan> or attributes etc

[07:54] <dduncan> thank you

[08:02] <pht> how about 'wink' then ;-)

[08:03] <dduncan> cute, but not so professional

[08:04] <dduncan> for now I'm sticking with "Instant" barring a better idea coming along

[08:07] <moritz_> Ontolog: no need to chomp() at all, file handles automatically chomp by default

[08:08] <Ontolog> ah that's cool but maybe it won't make my problem go away

[08:08] <Ontolog> yes same problem

[08:12] *** smg left
[08:19] <dduncan> good night

[08:19] *** dduncan left
[08:28] *** Bzek joined
[08:32] *** braceta joined
[08:33] *** barney joined
[08:40] *** _jedai_ joined
[09:04] <moritz_> @tell mncharity re feedback for the elf homepage: very nice. Just one small nit, you don't explain if STD_blue is going to be in ruby as well

[09:04] <lambdabot> Consider it noted.

[09:08] *** kanru left
[09:14] *** ispy_ joined
[09:42] *** smg joined
[09:45] *** Lunchy joined
[09:52] *** iblechbot left
[10:00] *** iblechbot joined
[10:03] *** _jedai_ left
[10:07] *** Alias_ is now known as adamkennedy

[10:09] *** Ontolog left
[10:14] *** elmex joined
[10:28] *** smtms joined
[10:44] *** kanru joined
[10:53] *** hanekomu joined
[10:53] *** barney left
[11:09] *** wknight8111 joined
[11:09] <mberends> rakudo: class Dog { has $.name is rw; method bark() { say "$.name says Woof!"; } } class Pug is Dog { method set_name($n) { $.name=$n } } my $pot = Pug.new(); $pot.set_name( 'Spot' ); $pot.bark();

[11:09] <p6eval> rakudo 31177: OUTPUT[Statement not terminated properly at line 1, near "class Pug "␤␤current instr.: 'parrot;PGE::Util;die' pc 119 (runtime/parrot/library/PGE/Util.pir:82)␤]

[11:09] *** rindolf left
[11:11] <mberends> rakudo: class Dog { has $.name is rw; method bark() { say "$.name says Woof!"; } }; class Pug is Dog { method set_name($n) { $.name=$n } }; my $pot = Pug.new(); $pot.set_name( 'Spot' ); $pot.bark();

[11:11] <p6eval> rakudo 31178: OUTPUT[Spot says Woof!␤]

[11:11] *** adamkennedy left
[11:12] <moritz_> mberends: in general you can only omit the ';' after a '}' if it's followed by a newline

[11:12] <mberends> your eyesight is phenomenal

[11:13] <moritz_> rather my experience with rakudo ;)

[11:14] <mberends> my real question is, why does it fail when class Dog is relocated to Dog.pm?

[11:17] <moritz_> because inheritance is done at compile time, and use happens (errornously) at run time

[11:17] <moritz_> BEGIN { use Dog; }; should help

[11:18] <mberends> thanks, i'll try that. does (erroneously) mean Watch This Space for changes?

[11:20] <moritz_> it means "file a bug report" ;)

[11:20] <moritz_> or I can do that if you'd prefer that

[11:22] <literal> or even better, you can fix it! :P

[11:22] *** Ontolog joined
[11:22] *** pmurias joined
[11:27] *** braceta left
[11:28] <Ontolog> shit shit

[11:28] <Ontolog> why don't DATA sections work yet?

[11:28] <Ontolog> fooey

[11:28] <mberends> mortiz_: S11 suggests 'use' is for compile time and 'require' is for run time. I'm new here, this will be my first bug report - exciting!

[11:29] <moritz_> mberends: well, go ahead then

[11:29] <moritz_> Ontolog: because nobody implemented them yet. Patches welcome

[11:30] <Ontolog> moritz_: i have no idea where to start implementing such a thing

[11:31] <pmurias> Ontolog: they are just a convieniece, they are not really need for anything so nobody implemented them

[11:33] <Ontolog> a huge convenience

[11:33] <Ontolog> if i can't have my data section i have to put my data in another file

[11:33] <Ontolog> this makes distributions more of a pita

[11:33] <Ontolog> where do I install this data file?

[11:34] <Ontolog> .keys and .values don't work on hashes?

[11:34] <pmurias> Ontolog: you can have your data in a string literal

[11:36] <mberends> Ontolog: I have similar frustrations at times. But it's documented, so it will come. Your hinting might it bump it up the priority queue. A multiline string is a reasonable workaround

[11:38] <mberends> the other day I tried a heredoc and failed, but maybe that was between chair and keyboard

[11:40] <moritz_> heredocs are NYI in rakudo

[11:40] <mberends> that'll be why I moved on

[11:53] <mberends> another NYI seems to be $*PID

[11:54] <moritz_> another bug report?

[11:54] *** DJ-Dongdot joined
[11:56] <mberends> that seems like nagging. there are probably more important jobs right now

[11:57] <mberends> more constructively, it would help to write a test that currently fails. I'll look into that

[11:59] <moritz_> spec/S02-magicals/pid.t

[11:59] <moritz_> mberends: a ticket with [TODO] marker is fine. pmichaud wants all TODO items in RT

[12:03] *** pmurias left
[12:03] *** pmurias joined
[12:03] <mberends> ok, then you'll hear more from me. it must be quite a job linking multiple reports of the same problem

[12:05] <moritz_> it's manageable. I go through the RT from time to time (ever 2 months or so) and look what problems are solved in the mean time

[12:06] *** masak joined
[12:06] <moritz_> so when a ticket is closed of which unmarked duplicates exist, the duplicates will later be closed anyway

[12:07] <moritz_> bbl

[12:08] <mberends> That's quite a clerical job. As a consolation, that's how Einstein started

[12:10] *** ashizawa left
[12:12] *** xinming joined
[12:23] <masak> what's the status of Kwid these days?

[12:23] <masak> what I remember of it, I really liked

[12:24] <masak> but it's hard to find information on it

[12:24] <masak> it's sort of half-bitrotted away from the face of the Web

[12:26] *** braceta joined
[12:33] *** meppl joined
[12:36] <pmurias> where does the new Pod spec live?

[12:36] <masak> @tell mncharity you mention STD_blue on the page, but don't say what it is. also, I certainly get motivated by the quote "Elf is currently (2008-09-15) the only implementation which can handle a p6 program as large as itself." (although I think you meant "...as large as Elf")

[12:36] <lambdabot> Consider it noted.

[12:38] <masak> it can be argued that an empty p6 program can handle a p6 program as large as itself :P

[12:38] <literal> I believe I read about a C Obfuscation Contest entry for a compiler that could compile itself that was just that

[12:39] <literal> the next year they changed the rules and didn't allow empty submissions :)

[12:40] <pmurias> literal: wouldn't you get a missing main error?

[12:40] <masak> "tricks you can only pull once"

[12:42] <literal> ah, I think the task was "shortest program that can output its own source code"

[12:43] *** DJ-Dongdot left
[12:43] <literal> trying to find it..

[12:43] *** sri_work joined
[12:44] <mberends> pmurias: http://perlcabal.org/syn/S26.html

[12:44] <lambdabot> Title: S26

[12:46] <mberends> pmurias: POD6 is nice. I hope we migrate over to it ASAP

[12:46] <pugs_svn> r22261 | pmurias++ | [smop] added a unfinished RI DSL

[12:49] <literal> Worst abuse of the rules. In several years, an entry was submitted that was so patently absurd that it required a new definition of some of the rules for the next year.  This is regarded as a high honor. An example is the world's shortest self-reproducing program. The entry was a program zero bytes in length that if run printed zero bytes to the screen (this requires some creative use of the makefile to get it right).

[12:49] <literal> that one

[12:49] <masak> literal: URL?

[12:49] <literal> http://www.ioccc.org/1994/smr.hint

[12:50] <literal> the pasted text is from http://en.wikipedia.org/wiki/International_Obfuscated_C_Code_Contes

[12:50] <masak> nice :)

[13:00] *** ispy_ left
[13:00] <pasteling> "Ontolog" at 207.192.69.61 pasted "Hash is empty?" (16 lines, 364B) at http://sial.org/pbot/32185

[13:01] <Ontolog> oh my god what am i doing wrong?

[13:04] *** jferrero left
[13:04] *** ruoso joined
[13:05] *** lolo92 joined
[13:05] <ruoso> Hello!

[13:09] <mberends> good localtime(), idufghasudyhi!

[13:12] *** sri_work left
[13:12] *** cognominal left
[13:12] *** bennymack-work left
[13:12] *** s1n left
[13:12] *** cotto_home left
[13:12] *** jiing left
[13:12] <masak> Ontolog: well, for starters, I'd use the %! form all the way with %!validPinyin

[13:13] *** sri_work joined
[13:13] *** cognominal joined
[13:13] *** cotto_home joined
[13:13] *** jiing joined
[13:13] *** s1n joined
[13:13] *** bennymack-work joined
[13:13] <masak> ...and with $!pydata

[13:13] <masak> I don't know if twigils are required -- I think they are -- but it's certainly clearer to use them all the time

[13:14] <Ontolog> i thought that it's only for declaration purposes

[13:15] <Ontolog> also, i tried adding them and it causes an error

[13:15] <masak> Ontolog: oh?

[13:15] <masak> no, they're not just for declaration

[13:15] <masak> usually, you use them all the way through the whole class

[13:16] <masak> Ontolog: another thing that surprises me is that you do assignments outside of methods (and after declarations) in your class

[13:16] <Ontolog> why?

[13:16] <masak> while it's probably not disallowed, I've just never seen it before

[13:16] <Ontolog> i need to initialize class data

[13:16] <Ontolog> how else should I be doing that?

[13:16] <masak> I'd put such things in a BUILD method or something (and make the class non-singleton)

[13:17] <Ontolog> make a BUILD method?

[13:17] <masak> alternatively, do the assignments with the declarations

[13:17] <masak> um, a BUILD submethod

[13:17] <masak> Ontolog: have you seen S12?

[13:18] *** demerphq joined
[13:19] <ruoso> pmurias, the ri dsl looks nice... do you plan to have the prototype registered only on the namespace? or as a C symbol also?

[13:19] *** sunnavy joined
[13:21] <pmurias> it's only optionaly registered as a C symbol

[13:22] <pmurias> visit to the occulist&

[13:22] <masak> o_O

[13:22] * masak read "occultist"

[13:22] <masak> I fall for that one every time! don't know why...

[13:26] <Ontolog> how do people start hacking on rakudo?

[13:26] *** riffraff joined
[13:27] <masak> Ontolog: they find something they want, read the source, make the change, and send a patch

[13:27] <masak> usually they hang out on #parrot at irc.perl.org too

[13:27] <Ontolog> i see they just read the source?

[13:28] <Ontolog> are there any development docs?

[13:28] <masak> a few, yes

[13:29] <Ontolog> where?

[13:29] <masak> looking

[13:30] <masak> http://www.parrotcode.org/docs/submissions.html

[13:30] <lambdabot> Title: Parrot Submissions Instructions - parrotcode

[13:30] <masak> that's for sending patches to Parrot in general

[13:30] <masak> (Rakudo is currently a part of the Parrot source tree)

[13:31] <Ontolog> nothing documenting how the source code is layed out, what the different pieces do

[13:31] <Ontolog> some kind of architecture?

[13:31] <masak> http://svn.perl.org/parrot/trunk/languages/perl6/ROADMAP

[13:31] <masak> that one documents where Rakudo is, and where it's going

[13:32] <masak> http://svn.perl.org/parrot/trunk/languages/perl6/docs/compiler_overview.pod

[13:32] <lambdabot> http://tinyurl.com/5pfb2n

[13:32] <masak> http://svn.perl.org/parrot/trunk/languages/perl6/docs/glossary.pod

[13:32] <lambdabot> http://tinyurl.com/54s3va

[13:33] <masak> http://svn.perl.org/parrot/trunk/languages/perl6/t/spectest_regression.data

[13:33] <lambdabot> http://tinyurl.com/5e4g64

[13:33] <masak> these three are all good pointers to Rakudo internals.

[13:33] <masak> the last one is a list of test files which should all pass, modulo fudging

[13:34] <masak> gives a good overview of what is expected to work at present

[13:34] *** charsbar_ joined
[13:34] *** charsbar left
[13:35] <masak> also, http://svn.perl.org/parrot/trunk/languages/perl6/src/parser/grammar.pg and http://svn.perl.org/parrot/trunk/languages/perl6/src/parser/actions.pm

[13:35] <lambdabot> http://tinyurl.com/5jh29s

[13:35] <masak> these two are in some sense the "core", in that changes often affect these two files

[13:35] <[particle]1> ...and then there's the list of rt tickets...

[13:35] *** [particle]1 is now known as [particle]

[13:35] <masak> aye.

[13:36] <[particle]> ontolog: i'm giving a talk on rakudo tonight in seattle

[13:36] <[particle]> you're welcome to join us ;)

[13:37] <Ontolog> its webcast?

[13:38] *** braceta left
[13:38] <Ontolog> i'de like to help get perl 6 working, and i'm curious how i can do that. however i have never had any experience writing compilers, interpreters, or anything of the such

[13:38] <Ontolog> so i really don't know how to just jump in and tack on a feature

[13:39] <Ontolog> for example, the POD stuff

[13:39] <Ontolog> I would like to read from __DATA__ sections

[13:39] <Ontolog> using the new POD syntax =begin DATA .... =end DATA

[13:39] <masak> Ontolog: FWIW, I feel I've helped Perl 6 along just by using it, and sending rakudobug emails :)

[13:40] <masak> we need developers of all kinds: users, testers, patchers and developers

[13:40] <Ontolog> yes i'm also just trying to use Perl 6, but i keep coming across things that don't work and it irks me and makes me want to implement it

[13:40] <masak> just be the most creative you can on your level of expertise :)

[13:40] <Ontolog> i'm sure if there were some kind of high level design docks it would help a lot

[13:40] *** yves joined
[13:40] <masak> (not meant to put you down, by the way)

[13:41] <masak> if you feel like patching Rakudo, go for it!

[13:41] <Ontolog> haha no it's ok i'm no Turing Award candidate

[13:41] <masak> just saying that a well-written rakudobug ticket is worth a lot

[13:42] <masak> engage people with your need for this =begin DATA feature, and people will have compassion and implement it for you

[13:42] <masak> happened to me quite a few times, actually

[13:42] <masak> if you really suffer from the lack of internals documentation, though, I suggest you send a rakudobug for that too

[13:43] <masak> (but do read the ones I sent you first, so you know what to complain about)

[13:46] <mberends> studying the perl6 RT queue at http://rt.perl.org/rt3/Public gives a very good idea of hacks required

[13:46] <lambdabot> Title: Public Perl Bug Tracker

[13:47] *** pht left
[13:48] <Ontolog> anyone have parrot vim syntax file?

[13:49] <masak> Ontolog: http://svn.pugscode.org/pugs/util/perl6.vim

[13:50] <Ontolog> i have that one

[13:50] <Ontolog> i'm talking about parrot

[13:50] <Ontolog> or pir syntax

[13:50] <[particle]> no, it's not webcast :(

[13:51] <[particle]> ontolog: what do you mean by "if there were some high-level design docs"?

[13:51] <[particle]> have you not seen http://spec.pugscode.org?

[13:51] <lambdabot> Title: Official Perl 6 Documentation

[13:51] <[particle]> it even has test coverage metrics built in

[13:52] <masak> Ontolog: http://svn.perl.org/parrot/trunk/editor/

[13:52] <lambdabot> Title: Revision 31178: /trunk/editor

[13:52] <[particle]> yep, make vim-install in the editor dir

[13:53] *** cosimo joined
[13:53] <Ontolog> [particle]: yes there is the perl 6 design spec but i'm talking about the rakudo design spec

[13:54] <[particle]> no such thing

[13:54] <Ontolog> rakudo implements perl 6, but how does it do it

[13:54] <Ontolog> i see

[13:54] <masak> Ontolog: there's those links I sent you

[13:54] <Ontolog> yeah i am looking at all the links you guys send

[13:54] <Ontolog> and the bug reports and all of that

[13:54] <Ontolog> and the source code itself

[13:54] <masak> Ontolog: might also be worthwhile to peruse the use.perl journals of jonathan++ and pmichaud++

[13:54] <Ontolog> anyway just looking at the source code, it seems 90% of it is parrot code

[13:55] <[particle]> masak: i suggest rakudo.org

[13:55] <masak> [particle]: yes, even better

[13:55] <[particle]> ontolog: yes, much is pir code, but that will be changing soon

[13:55] <Ontolog> changing to..?

[13:55] <[particle]> much of the pir code (not all) will be replaced by perl 6 code

[13:55] <Ontolog> that's cool

[13:55] <[particle]> 'use' has recently been implemented well enough to do that

[13:55] <Ontolog> that's what I would like to do

[13:56] <[particle]> (and a few necessary things)

[13:56] <Ontolog> is write perl 6

[13:56] <[particle]> you can write perl 6 today

[13:56] <[particle]> masak++ and viklund++ have written a wiki engine in rakudo

[13:56] <Ontolog> i mean perl 6 that will help the perl 6 project

[13:56] <[particle]> http://november-wiki.org/

[13:56] <[particle]> yes, i understand

[13:56] <masak> (gotta do something about that main page...)

[13:57] <[particle]> by writing a small app in perl 6, you will help explore the edges of rakudo

[13:57] <[particle]> masak: give me an id :)

[13:57] <masak> [particle]: hold on...

[13:58] <mberends> Ontolog: I would be delighted if you could implement socket(), connect(), listen() etc

[13:58] <Ontolog> that's the thing, there are quite a few edges :p

[13:59] <Ontolog> the perl native functions?

[13:59] <mberends> yes

[13:59] <Ontolog> in pir or in perl 6?

[14:00] <mberends> I don't know. I'd just like to be able to write TCP/IP servers and clients on Rakudo

[14:00] <pmichaud> $ cat src/*/*.p[gm] | wc -l

[14:00] <pmichaud> 4335

[14:00] <pmichaud> $ cat src/*/*.pir | wc -l

[14:00] <pmichaud> 10879

[14:00] <pmichaud> looks to me like only 72% of the code is written in PIR :-)

[14:01] <Ontolog> hey my guess wasn't so off! :p

[14:01] <Ontolog> my point was a large majority

[14:01] <Ontolog> anyway, i'll look into socket connect and listen, seems like an interesting thing to work on

[14:03] <mberends> great!

[14:05] <[particle]> pmichaud: how much c?

[14:05] *** charsbar_ left
[14:05] *** charsbar joined
[14:06] *** demerphq left
[14:08] *** rindolf joined
[14:09] *** demerphq joined
[14:10] *** zamolxes joined
[14:13] *** abra joined
[14:16] *** sri_work left
[14:20] <pmichaud> particle:  I don't know -- there are some unused C files lying about

[14:21] <[particle]> ontolog: rakudo sockets has been waiting on an improved parrot i/o impl

[14:21] <[particle]> ontolog: which is scheduled to happen after the mmd branch is merged with trunk (probably next week)

[14:21] <Ontolog> cool

[14:21] <[particle]> so, better sockets in 2-3 weeks

[14:21] <Ontolog> right now i'm reading (the ancient) Perl 6 and Parrot book

[14:22] <Ontolog> trying to get my mind around Parrot first

[14:22] <[particle]> ontolog: there's an updated version of the parrot chapters in the parrot repo

[14:22] <[particle]> docs/book iirc

[14:22] *** hercynium joined
[14:23] *** iblechbot left
[14:24] *** xiaoyafeng joined
[14:26] *** sri_work joined
[14:26] *** demq joined
[14:26] <mberends> ontolog, particle: as sockets are done, how about implementing $*PID etc?

[14:29] <pmichaud> $*PID shouldn't be too difficult, if Parrot has that information available

[14:29] <[particle]> yes, it does, i just can't remember where atm

[14:31] <mberends> I do worry about some of these requests distracting from the roadmap sequence

[14:33] <pmichaud> If a specific (and easily implemented) feature helps someone do programming, I'm not too worried about it affecting the roadmap

[14:33] <pmichaud> if it's difficult to implement, then yes, it's a concern :-)

[14:36] <pmurias> Ontolog: the general procedure i use on non-rakudo compilers is make the feature you need be parsed, emitted right and write the runtime support

[14:38] <ruoso> pmichaud, I was about to reply to the value types thread... but it's probably better to just say here...

[14:38] <ruoso> aren't "value types" supposed to be read only?

[14:38] *** demerphq left
[14:39] <ruoso> I mean... the reason value types are values is that they cannot be changed and that it doesn't make any difference copying a reference or a clone...

[14:39] <pmichaud> Range is listed as a value type... although that might be a mistake

[14:39] <pmichaud> or it may have some other oddities I'm not aware of

[14:39] <ruoso> Range might be a value type, and most of the "changes" made to Range objects might be simply compositions on top of it

[14:40] <ruoso> I mean... 1..3.push(4) doesn't seem very sane

[14:40] <ruoso> pugs: say 1..3.push(4);

[14:40] <p6eval> pugs: OUTPUT[*** Can't modify constant item: VUndef␤    at /tmp/8xOO2Ow4t2 line 1, column 5-17␤]

[14:40] <pmichaud> no, but $range = 1..5;  $range.pop;   is already defined by the spec

[14:41] <ruoso> because a range in scalar context return a lazy iterator?

[14:41] <ruoso> :)

[14:41] <pmichaud> no, the value of $range itself is changed

[14:41] <[particle]> right

[14:41] <pmichaud> $range = 1..5;  $range.pop;   say $range.perl;    #   1..4

[14:42] <ruoso> ok... Range in scalar context returns a MutableRange?

[14:42] <ruoso> which is then an object, and no longer a value?

[14:42] <pmichaud> that's one possibility, yes

[14:43] <pmichaud> although I suspect that   $range.WHAT should still return 'Range'

[14:43] <ruoso> .WHAT for identity is something I really dislike

[14:43] <moritz_> ruoso: but it's specced

[14:43] <ruoso> because (1,2,3).WHAT eventually might return something different then (3,2,1).WHAT

[14:44] <pmichaud> anyway, I already replied in the thread that I can agree with the "value is readonly" model, or at least try it out with Rakudo

[14:44] <pmichaud> it just poses some difficulties with Parrot's container model (or rather, it's lack of one)

[14:45] <ruoso> pmichaud, SMOP also lacks a "container" model... the containers are simply plain objects that hold other objects

[14:45] <ruoso> and the syntax is translated to something in that level...

[14:45] <pmichaud> ruoso:   so, is   @a[1]   a container?

[14:45] <pmurias> es

[14:45] <ruoso> yes

[14:45] <pmurias> yes

[14:45] <pmichaud> that's what Parrot lacks.

[14:45] <ruoso> but that's not up to parrot

[14:45] <ruoso> it's up to the implementation of the value stored in @a

[14:46] <ruoso> in SMOP 

[14:46] <ruoso> @a[1] should translate to Pad<@a>.FETCH.postcircumfix:<[ ]>(1)

[14:46] <lambdabot> Unknown command, try @list

[14:46] <pmichaud> In Parrot it means that @a is a PMC that contains an array of container PMCs, and each container PMCs then holds a reference to the associated value PMC

[14:47] <pmichaud> i.e., an array of size n ends up with 2n+1 gc-able elements

[14:47] <pmurias> PMC are equivalent to smop objects

[14:47] <ruoso> but it looks like the variable is something more intrinsic to parrot than it is in smop

[14:48] <ruoso> in SMOP the lexical pad is an object itself

[14:48] <ruoso> and that might be the fundamental difference

[14:48] <pmichaud> the lexical pad is an object itself also, but that's really irrelevant to what I'm describing (I think)

[14:48] <pmichaud> I mean, I could be referring to an Array that isn't in the lexical base

[14:48] <pmichaud> i.e., an anonymous Array

[14:48] <pmurias> @a[1] = 3 stores 3 in the scalar stored in the element with index 1 in @a

[14:48] <lambdabot> Unknown command, try @list

[14:49] <masak> lambdabot, learn Perl 6!

[14:49] <pmichaud> so, does that mean there are three smop objects?

[14:49] <ruoso> maybe more ;)

[14:49] <pmichaud> one for the array, one for the scalar, one for the 3?

[14:49] <pmurias> yes

[14:49] <pmichaud> okay, that's the same as Parrot then

[14:49] <pmichaud> I was hoping to avoid all of those extra scalar PMCs

[14:49] <pmurias> consider @a[1] = $foo;@a[1] = 7;say $foo;

[14:49] <ruoso> of course the scalar might be just a proxy, depending on the array implementation

[14:50] <pmurias> consider @a[1] := $foo;@a[1] = 7;say $foo;

[14:50] <pmichaud> oh, I could already do that without @a[1] having to be a scalar PMC

[14:50] <pmichaud> I could just bind @a[1] directly to $foo

[14:51] <ruoso> the array *must return* a scalar on .[]

[14:51] <ruoso> but it doesn't need to *store* the actual scalar

[14:51] <moritz_> so you want to autovivify containers as needed?

[14:52] <pmichaud> well, that's what Parrot will end up doing, yes.

[14:52] <ruoso> so, that's the model we're using in SMOP

[14:53] <ruoso> of course it's easier to implement it storing the scalars at first...

[14:53] <ruoso> and that's what pmurias did on smop iirc

[14:53] <pmurias> so it actually should be 4 values the array, the scalar, the proxy and the 3

[14:53] <pmurias> ruoso: yes

[14:53] *** jferrero joined
[14:53] <pmurias> we can layer the proxy object in Perl 6

[14:53] <ruoso> pmurias, if you have the proxy, you don't need the scalar...

[14:54] <ruoso> and we also need to note that taking this easy path means not supporting autovivification as specced

[14:54] <ruoso> which means that the real array type for Perl 6 will not be SMOP__S1P__Array

[14:54] <pmurias> but i if i bind $foo to a @a[1] i need to store $foo somewhere

[14:54] <ruoso> $foo is stored in the lexical pad

[14:55] <ruoso> it just needs to contain a reference to the array and the index

[14:55] <ruoso> and it also need to access additional methods that are not part of the array api

[14:55] <ruoso> which means that the relationship between the proxy and the array is implementation dependent

[14:56] <pmurias> you mean change $foo instead of @a in @a[1] := $foo?

[14:56] <ruoso> oh... right... I see it now... I was thinking in the opposite direction...

[14:56] * ruoso thinking...

[14:56] <moritz_> remember that you can also do @a[0] := @b[1]

[14:57] <ruoso> remember that @a[1] := $foo might fail also...

[14:57] <ruoso> if the array doesn't support it

[14:58] <ruoso> pugs: my $foo; my @a := (1,2,3); @a[1] := $foo; $foo = 1; say @a;

[14:58] <p6eval> pugs: OUTPUT[*** Can't modify constant item: VUndef␤    at /tmp/vD5KlX0xYj line 1, column 28-41␤]

[14:58] <ruoso> pugs: my $foo; my @a := (1,2,3); @a[1] := $foo; say @a;

[14:58] <p6eval> pugs: OUTPUT[*** Can't modify constant item: VUndef␤    at /tmp/iWajnsVUGI line 1, column 28-41␤]

[14:58] <moritz_> rakudo: my $foo; my @a := (1,2,3); @a[1] := $foo; $foo = 1; say @a;

[14:58] <p6eval> rakudo 31178: OUTPUT[113␤]

[14:58] <ruoso> that is supposed to fail

[14:58] <ruoso> since (1,2,3) is read only 

[14:59] <moritz_> but @a isn't

[14:59] <ruoso> but you bound @a to a readonly list

[14:59] <ruoso> it *is* read-only

[14:59] <moritz_> uhm

[14:59] <moritz_> right

[14:59] <moritz_> if I assigned it instead it should work, right?

[14:59] <ruoso> yes...

[15:00] <masak> rakudo: my @a = (1,2,3,4,5); @a[3] := @a; say @a.perl'

[15:00] *** rindolf left
[15:00] <p6eval> rakudo 31178: OUTPUT[Statement not terminated properly at line 1, near "'"␤␤current instr.: 'parrot;PGE::Util;die' pc 119 (runtime/parrot/library/PGE/Util.pir:82)␤]

[15:00] <masak> oops

[15:00] <masak> rakudo: my @a = (1,2,3,4,5); @a[3] := @a; say @a.perl

[15:00] <p6eval> rakudo 31178: RESULT[[1, 2, 3, 1, 2, 3, 1, 2, 5]␤1]

[15:00] <moritz_> masak: you're evil

[15:00] <ruoso> that's the part TimToady was starting to think that assignment implies eager evaluation ...

[15:00] <masak> interesting answer :)

[15:00] <masak> moritz_: don't worry, I Tried It At Home first

[15:00] <moritz_> lol

[15:00] <masak> just wanted to show it's broken

[15:01] <masak> as is much other nested array handling right now

[15:01] * ruoso lunch &

[15:02] <masak> rakudo: my @a = (1); @a[0] := @a; say @a.perl # this seems to work, however

[15:02] <moritz_> masak: what should binding of an array to an array element give?

[15:02] <masak> ok, I _am_ evil

[15:03] <masak> moritz_: what it should, I guess. an array containing itself as an element

[15:03] <moritz_> sh: line 1: 14678 CPU time limit exceeded

[15:03] <p6eval> rakudo 31178: No output (you need to produce output to STDOUT)

[15:03] <masak> question is rather, should .perl hang on printing such an array

[15:03] <masak> p6eval++

[15:04] <moritz_> masak: I thankt that's what @a[0] = @a should give you

[15:04] <masak> you mean that = should have binding semantics in this case?

[15:04] <moritz_> s/thankt/think/

[15:04] <moritz_> hrm

[15:04] <masak> I'd expect that to flatten and expand as elements, actually

[15:04] * moritz_ thinks nothing anymore

[15:05] <masak> so @a = (1,2,3); @a[0] = @a; # now it has 5 elements

[15:05] <masak> 1,2,3,2,3

[15:05] <moritz_> allright

[15:05] <masak> but maybe that's just me

[15:05] * moritz_ though more of @a[0] = @a to create a self-referential data structure

[15:06] <pmurias> is it possible to create a header from a c file automaticly?

[15:06] <masak> I'd use @a[0] := @a for that

[15:06] <moritz_> masak: binding a list container to a scalar container just feels wrong, IMHO

[15:06] <masak> moritz_: please explain why

[15:08] <moritz_> because a scalar is a not a list, and vice versa

[15:08] <moritz_> just like $x := 3 makes no sense to me

[15:09] <masak> is that allowed Perl 6?

[15:09] <moritz_> dunno

[15:09] <pmichaud> @a = (1,2,3);   @a[0] = @a;   causes @a to still have only 3 elements, and gives an "unused values" warning

[15:09] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v

[15:09] <moritz_> perl6: my $x := 3; say $x

[15:09] <p6eval> elf 22261, pugs, rakudo 31178: OUTPUT[3␤]

[15:09] <pmichaud> @a[0] = @a is a list assignment

[15:09] <lambdabot> Unknown command, try @list

[15:10] <masak> pmichaud: ah. makes sense.

[15:10] <masak> pmichaud: what about @a[0] := @a ?

[15:10] <pmichaud> masak:  I don't know about that one.  :-)

[15:10] *** riffraff left
[15:10] <masak> :)

[15:10] <pmurias> moritz_: under the mp6/kp6 interpretation it is valid

[15:10] <pmichaud> part of me thinks that ends up with a self-referential structure

[15:10] <masak> I hope so

[15:11] <masak> that seems to be what's happening in at least one case in Rakudo right now

[15:11] <masak> question is, should .perl be able to handle that, and if so, how?

[15:11] <moritz_> masak: it should

[15:12] <moritz_> perhaps it should emit something like 'do { my @x = (...); @x[0] := @x; @x }'

[15:12] * masak submits rakudobug

[15:12] <ruoso> moritz_, $x := 3 is absolutely reasonable

[15:13] <ruoso> pugs: $x := 3; say $x; 

[15:13] <p6eval> pugs: OUTPUT[*** ␤    Unexpected " :="␤    expecting "::"␤    Variable "$x" requires predeclaration or explicit package name␤    at /tmp/IOTZWg1i9c line 1, column 3␤]

[15:13] <ruoso> pugs: my $x := 3; say $x; 

[15:13] <p6eval> pugs: OUTPUT[3␤]

[15:13] <ruoso> pugs: my $x := 3; $x = 1; 

[15:13] <moritz_> masak: it was on the older form of the rakudo roadmap

[15:13] <p6eval> pugs: OUTPUT[*** Can't modify constant item: VInt 3␤    at /tmp/jgEpj2qod8 line 1, column 13-19␤]

[15:13] <moritz_> ruoso: I don't understand why. '3' doesn't have a container.

[15:13] <masak> moritz_: oki

[15:13] <moritz_> (that doesn't mean that a bug report is out of place, though)

[15:14] <ruoso> moritz_, because it seems that every value is a container of itself...

[15:14] <ruoso> as well as every values is a list that contains itself

[15:14] * moritz_ wonders if he will have lost all faith in Perl 6 by the time it's finished

[15:15] <moritz_> that sounds pretty polymorphic

[15:15] <ruoso> heh...

[15:15] <ruoso> indeed... Perl 6 requires the most polymorphic runtime I've ever seen

[15:17] *** riffraff joined
[15:17] * ruoso really lunch &

[15:18] <masak> moritz_: I won't have lost faith in Perl 6. I simply won't use the parts I'll have lost faith in. :)

[15:19] <moritz_> masak: like, list assignment and binding? ;/

[15:19] <masak> probably not, I still have faith in those :)

[15:20] <masak> at least one by one.

[15:21] <moritz_> anyway, at some point I'll just keep a watchful eye over the testsuite, apply patches for obvious bugs, and let tze Zen flow through me in a hope that I'll eventually understand all that weird stuff

[15:21] <masak> sounds wonderful

[15:22] <moritz_> (which is roughly what I'm doing now, with small variations)

[15:24] <masak> Ontolog: also, http://search.cpan.org/~rgrjr/parrot-0.7.0/docs/art/pp001-intro.pod which I just re-found

[15:24] <lambdabot> Title: Writing PIR - search.cpan.org, http://tinyurl.com/5w54zh

[15:25] *** z80ASM joined
[15:25] <moritz_> the latest p6l posting by Mark J Reed has a nice analogy for assignment and binding ;)

[15:25] <z80ASM> timtowtdi ;P

[15:25] <moritz_> aye ;)

[15:26] <masak> I really liked that analogy too

[15:26] <z80ASM> yap yap

[15:27] <masak> z80ASM: arf arf!

[15:34] <PerlJam> moritz_: not only a nice analogy, but a good explanation too.

[15:35] <cognominal> perl6: my $a = Int.new; $a=666; say "$a, {$a.WHAT}"; my %a; %a{$a}= $a ; %a<i> = '0'; say "{+%a} keys";  say $_ ~ ' ' ~  .WHAT for keys %a;  say "{%a.keys}, {%a{$a}}"; 

[15:35] <p6eval> rakudo 31178: OUTPUT[666, Int␤2 keys␤0 Int␤MMD function __concatenate not found for types (97, 80)␤current instr.: '_block11' pc 319 (EVAL_11:97)␤]

[15:35] <p6eval> ..pugs: OUTPUT[666, Int␤2 keys␤i Str␤666 Str␤i 666, 666␤]

[15:35] <p6eval> ..elf 22261: OUTPUT[Use of uninitialized value in concatenation (.) or string at ./elf_f line 3408.␤syntax error at (eval 125) line 11, near ". ->WHAT"␤ at ./elf_f line 3861␤]

[15:37] <masak> rakudo: say "{;}" # hee hee

[15:37] <p6eval> rakudo 31178: OUTPUT[Null PMC access in get_string()␤current instr.: 'print' pc 13909 (src/gen_builtins.pir:8713)␤]

[15:37] <masak> what should that print? :)

[15:38] <masak> rakudo: say "{nothing}" # hee hee

[15:38] <p6eval> rakudo 31178: OUTPUT[Null PMC access in get_string()␤current instr.: 'print' pc 13909 (src/gen_builtins.pir:8713)␤]

[15:39] <cognominal> rakudo: say "{rand}"

[15:39] <p6eval> rakudo 31178: OUTPUT[0.400301␤]

[15:40] <moritz_> masak: probably some stringfication of some value of undef, which the empty block returns

[15:40] <moritz_> masak: but since bare returns don't work yet, I'm not surprised that {;} doesn't work either

[15:40] <masak> rakudo: say "{sub a { say "OH HAI" }; a}"

[15:40] <p6eval> rakudo 31178: OUTPUT[OH HAI␤1␤]

[15:40] <masak> rakudo++ # awesome

[15:40] <masak> moritz_: bare returns don't work?

[15:40] <masak> they used to...

[15:41] *** obra_work joined
[15:42] <pmichaud> ...bare return doesn't work?  rt #?

[15:42] <moritz_> rakudo: sub a { return }; say a ~~ undef

[15:42] <p6eval> rakudo 31178: OUTPUT[Use of uninitialized value␤␤]

[15:42] <moritz_> rakudo: sub a { return }; say defined(a)

[15:42] <p6eval> rakudo 31178: OUTPUT[1␤]

[15:43] <moritz_> why in the seven hells did the first one print a warning?

[15:43] <masak>  

[15:43] <masak> ERC> 

[15:43] <masak> ERC> rakudo: sub a { return }; say a.WHAT

[15:43] <moritz_> rakudo: sub a { return }; say a.WHAT

[15:43] <p6eval> rakudo 31178: OUTPUT[List␤]

[15:43] <masak> moritz_: that's why.

[15:43] <masak> it's probably a List with an Undef value in it

[15:43] <moritz_> yes, and I don't think that's right

[15:44] *** hanekomu left
[15:44] <pmichaud> rakudo:  say () ~~ undef;

[15:44] <p6eval> rakudo 31178: OUTPUT[0␤]

[15:44] <moritz_> RT #58770, for reference

[15:44] <moritz_> pmichaud: do you know why the first one gave a warning?

[15:44] <cognominal> perl6:  my %a; %a<i> = 't'; say $_ for keys %a ; say %a<i>

[15:44] <p6eval> rakudo 31178: OUTPUT[0␤t␤]

[15:44] <p6eval> ..pugs: OUTPUT[i␤t␤]

[15:44] <p6eval> ..elf 22261: OUTPUT[Undefined subroutine &GLOBAL::keys called at (eval 121) line 5.␤ at ./elf_f line 3861␤]

[15:45] <moritz_> rakudo: my %a; %a<i> = 't'; .say for keys %a ; say %a<i>

[15:45] <p6eval> rakudo 31178: OUTPUT[0␤t␤]

[15:45] <pmichaud> I'm suspicious that the 'for' statement modifier isn't working properly.

[15:45] <moritz_> aye

[15:45] <pmichaud> moritz_: no, I don't know why we got a warning in the first one.

[15:46] *** pmurias left
[15:46] <moritz_> rakudo: my %a; %a<i> = 't'; for keys %a { .say }; say %a<i>

[15:46] <p6eval> rakudo 31178: OUTPUT[0␤t␤]

[15:46] <moritz_> pmichaud: bogus warnings would explain why the test suite warns that much ;)

[15:47] <pmichaud> rakudo: sub a { return }; say a.defined;

[15:47] <p6eval> rakudo 31178: OUTPUT[1␤]

[15:47] <pmichaud> rakudo: sub a { return }; say a ~~ undef;

[15:47] <p6eval> rakudo 31178: OUTPUT[Use of uninitialized value␤␤]

[15:47] <pmichaud> rakudo: sub a { return }; say a() ~~ undef;

[15:47] <p6eval> rakudo 31178: OUTPUT[0␤]

[15:47] <moritz_> the difference between the last two is really weird

[15:48] <pmichaud> oh, I get it :-)

[15:48] <pmichaud> it's parsing as   prefix:<~>  prefix:<~>

[15:48] <masak> ouch

[15:48] *** sunnavy left
[15:48] <pmichaud> rakudo:  say ~~undef;

[15:48] <p6eval> rakudo 31178: OUTPUT[Use of uninitialized value␤␤]

[15:48] <masak> there we have it

[15:49] <pmichaud> there ya go.  :-)

[15:49] <moritz_> that's what you get for not using LTM!

[15:49] <pmichaud> I don't know that LTM solves that particular problem.

[15:49] <pmichaud> a is a listop

[15:49] <pmichaud> so it expects a term after that

[15:49] <masak> :(

[15:49] <masak> I don't.

[15:49] <pmichaud> it's the same issue as if we do     say a + 3

[15:49] <pmichaud> that becomes    say(a(+3)) and not say(a() + 3)

[15:50] <moritz_> uhm, even STD.pm mis-parses a ~~ undef

[15:51] <moritz_> for some value of mis-parsing

[15:51] <pmichaud> I'm saying it's not a mis-parse

[15:51] <pmichaud> I'm saying that's what the spec says. :-)

[15:51] <cognominal> I am puzzled by the 'i' becoming a 0 in the for loop

[15:51] *** riffraff left
[15:51] <moritz_> cognominal: that's very weird, and worth a bug report IMHO

[15:51] <pmichaud> rakudo:  my %a;  %a<i> = 't';  say %a.keys.perl;

[15:51] <cognominal> I file one

[15:51] <p6eval> rakudo 31178: OUTPUT[["i"]␤]

[15:52] <pmichaud> rakudo:  my %a;  %a<i> = 't';  for %a.keys { .say }

[15:52] <p6eval> rakudo 31178: OUTPUT[i␤]

[15:52] <pmichaud> rakudo:  my %a;  %a<i> = 't';  for keys %s { .say }

[15:52] <p6eval> rakudo 31178: OUTPUT[Scope not found for PAST::Var '%s'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤]

[15:52] <moritz_> pmichaud: ok. That's a bit unexpected to me

[15:52] <pmichaud> rakudo:  my %a;  %a<i> = 't';  for keys %a { .say }

[15:52] <p6eval> rakudo 31178: OUTPUT[0␤]

[15:52] <pmichaud> looks like   keys as a function call isn't working.

[15:52] <pmichaud> probably an improper export.

[15:53] <pmichaud> I also wonder if keys is really a named unary

[15:53] <moritz_> but that wouldn't be that first time that I expected too much magic

[15:53] <cognominal> pmichaud, I file the bug or it is a no-brainer for you to fix it?

[15:54] <masak> I think, if ' ~~ ' is ever parsed as prefix:<~> prefix:<~>, then it's not the user who's at fault, it's the language

[15:54] <pmichaud> go ahead and file the bug.  it's not nearly as simple as it might look at first

[15:54] <cognominal> ok

[15:54] <pmichaud> I'm guessing keys is probably not a named unary

[15:54] *** pmurias joined
[15:55] <pmichaud> at any rate, it's in the same category as   values, keys, pairs, and kv

[15:55] <moritz_> multi Int|List keys ( %hash ; Matcher *@keytests )

[15:55] <pmichaud> rakudo:  my %a;  %a<i> = 't';  for keys(%a) { .say }

[15:55] <p6eval> rakudo 31178: OUTPUT[0␤]

[15:55] <moritz_> heck, it's not even defined as a method in S29

[15:56] <moritz_> which certainly looks wrong to me

[15:59] <masak> S29 needs lots of love

[16:00] <moritz_> indeed

[16:00] <moritz_> and IMHO it needs that love real soon

[16:00] <masak> it has needed that love real soon for quite a while now

[16:01] <moritz_> from a language design (and even implementation) point of view that's not urgent, but for somebody who uses the language it's essential

[16:01] <PerlJam> moritz_: so ... are you volunteering?  :)

[16:01] <[particle]> people *use* this language!?!?! ;)

[16:01] <masak> [particle]: aye.

[16:01] <masak> that's always a possible side effect creating one.

[16:01] <masak> s/effect/effect of/

[16:02] <moritz_> PerlJam: I tried, and quickly noticed that I lack some important knowledge to do it

[16:03] <PerlJam> moritz_: like what?

[16:03] <moritz_> PerlJam: OO, signatures, type hierarchy, knowledge of what is immutable and what not

[16:04] *** Exodist joined
[16:04] *** z80ASM left
[16:04] <pmichaud> oh, I just love this headline from CNN:   "Bush lands in Texas; residents urged to leave"

[16:05] <moritz_> *lol*

[16:05] <PerlJam> pm: :-) yeah, I saw that earlier  :)

[16:05] <pmichaud> who says there's no media bias?  ;-)

[16:05] <PerlJam> moritz_: the last 3 items are documented in the synopses.

[16:06] <moritz_> PerlJam: type hierarchy not really

[16:06] <moritz_> PerlJam: or if so, where can I find it?

[16:07] <pmurias> the casual user parts of OO are documented in S12 too

[16:07] *** justatheory joined
[16:07] <moritz_> aye

[16:07] <moritz_> but I have to actually understand and internalize them to be able to modify the synopsis in any meaningful way

[16:10] <pmichaud> afk, lunch and errands

[16:13] *** obra_work left
[16:13] *** obra_work joined
[16:13] *** obra_work is now known as obra

[16:15] *** hercynium_ joined
[16:17] *** hercynium left
[16:21] *** justatheory left
[16:22] *** zamolxes left
[16:24] *** sri_work left
[16:25] *** sri_work joined
[16:25] *** iblechbot joined
[16:28] *** apeiron_ is now known as apeiron

[16:32] *** justatheory joined
[16:33] *** cosimo left
[16:37] *** barney joined
[16:45] *** jferrero left
[16:47] *** wilx joined
[16:51] *** masak left
[16:52] *** justatheory left
[16:54] *** sri_work left
[16:54] *** sri_work joined
[16:55] *** kanru left
[16:58] *** kanru joined
[16:58] *** clintongormley joined
[17:06] *** wknight8111 left
[17:17] <ruoso> pmichaud, about "values are read-only"... I've just realized I don't know how to implement $a++ in that schema...

[17:17] *** justatheory joined
[17:18] <moritz_> uhm, you take the value from $a, calculate the incremented value, store it in $a

[17:20] <ruoso> right... so it's a macro?

[17:20] <moritz_> it doesn't have to

[17:20] <moritz_> sub postfix:<++>($x is rw) { ... }

[17:21] <ruoso> hmm... ok... I was considering it as a method call, not as a sub

[17:22] <moritz_> I think that all operators except postcircumfix are actually sub (multi) calls

[17:23] <ruoso> hmm... that would solve it...

[17:27] <rakudo_svn> r31179 | moritz++ | [rakudo] first shot at Str.comb

[17:32] *** rindolf joined
[17:37] *** Chillance joined
[17:39] <pmichaud> in fact, S03 even says that ++$a is explicitly equivalent to $a.=succ

[17:39] *** jhorwitz joined
[17:39] <pmichaud> (but optimizers are allowed to assume that this is not overridden for integers)

[17:41] *** obra left
[17:42] <pmichaud> also, I would expect that $x would be passed 'is ref' instead of 'is rw', so that we don't end up promoting constants to lvalues

[17:43] <moritz_> and of them is allowed to autovivify, iirc

[17:46] <pugs_svn> r22262 | moritz++ | [t/spec] simplified comb.t, and fudged for rakudo

[18:14] *** hercynium_ left
[18:17] *** clintongormley left
[18:17] <rakudo_svn> r31181 | moritz++ | [rakudo] added comment about string coercion to Str.comb

[18:19] *** hanekomu joined
[18:25] <rakudo_svn> r31182 | pmichaud++ | [rakudo]: spectest-progress.csv update: 163 files, 3370 passing tests

[18:26] *** BinGOs left
[18:27] <rakudo_svn> r31183 | moritz++ | [rakudo] add tests for Str.comb to spectest_regression

[18:28] *** BinGOs joined
[18:34] *** wilx left
[19:05] *** TJCRI joined
[19:06] *** charsbar left
[19:07] *** charsbar joined
[19:07] *** clintongormley joined
[19:11] <pmurias> pmichaud: got the exact line in the spec?

[19:11] *** charsbar left
[19:11] *** charsbar joined
[19:12] <moritz_> S03:517 I guess

[19:12] <moritz_> ack++

[19:12] <pmurias> pmichaud: (for the optimizers are free to assume)

[19:15] <pmurias> ruoso: if i implement the forward context propagation and prove it's not too complex would you have any other issues with it

[19:21] <pugs_svn> r22263 | pmurias++ | [smop] added stub item and item is rw contexts

[19:24] *** zamolxes joined
[19:26] *** xinming left
[19:33] <pugs_svn> r22264 | pmurias++ | [smop] removed spec contradicting context RI's

[19:36] *** loomis53 joined
[19:38] *** loomis53 left
[19:40] *** Psyche^ joined
[19:41] <alester> yay ack!

[19:42] *** abra left
[19:43] <rindolf> Hi alester 

[19:43] *** barney left
[19:44] <rindolf> alester: turns out Google Code no longer has vendor lock-in in regards to its svn repositories.

[19:44] <rindolf> One can create svnsync copies and then dump the copies.

[19:44] <alester> Why are you telling me this?

[19:44] <alester> I'm not seeing a connection to me.

[19:45] <rindolf> alester: ah.

[19:45] <rindolf> alester: well, you're hosting some projects on Google code.

[19:45] <alester> right, but I'm not concerned about "vendor lock-in"

[19:45] <moritz_> rindolf: that was never really a problem, because git-svn could already create a 99.95% accurate copy with normal http/svn access

[19:46] <pmurias> ruoso: i'm considering a one step transition to add context to the capture

[19:48] *** Lorn_ left
[19:49] <ruoso> pmurias, I really think it's saner to have it represented in terms of late context propagation

[19:49] <ruoso> conceptually, it looks more consistent

[19:51] <ruoso> specially for things like viewing (1,2,3,(1,2,3,(1,2,3))) in slice context

[19:52] <ruoso> or my @a = [1,2,3] so that @a contains a single element with the array [1,2,3] in it

[19:52] <ruoso> and my $a = \foo(); bar(|$a);

[19:52] *** Patterner left
[19:52] <ruoso> all that seems much consistent with late context propagation...

[19:52] *** Psyche^ is now known as Patterner

[19:53] <ruoso> note however, that I don't deny implementing forward context propagation... but I think that should be a later addition to the model, most of the time working to provide optimizations

[19:54] <ruoso> late context propagation can provide all the needed semantics...

[19:54] <ruoso> it might be not that efficient, but there's room for optimization

[19:56] *** Lorn joined
[19:58] <rakudo_svn> r31185 | moritz++ | [rakudo] implement and test Str.match, cjfields++

[19:58] <ruoso> pmurias, I do think we will benefit from forward context propagation at the moment we have multi's implemented

[19:58] <rakudo_svn> r31185 | moritz++ | Patch courtesy by Chris Fields. Also added him to CREDITS

[19:58] <ruoso> and that we start to implement multi resolution depending on the context... that's why I thought on the context to be stored in the capture

[19:59] <ruoso> and then add JIT to that, and you have a huge benefit...

[19:59] <pugs_svn> r22265 | moritz++ | [t/spec] added some references to RT tickets (rakudo), and unfudged a test

[20:03] *** lisppaste3 left
[20:09] *** mberends left
[20:11] *** larsen_ joined
[20:12] <pmurias> ruoso: i agree that the late contex propagation is more consitent but i think i'm afraid it would lead to differences from Perl 6

[20:13] <ruoso> actually, akaics, it will lead us to a more Perl-6-friendly model

[20:13] <ruoso> s/akaics/afaics/

[20:14] <ruoso> pmurias, which specific differences you think it'll produce?

[20:14] <pmurias> thinking...

[20:15] *** rindolf left
[20:15] *** eternaleye left
[20:16] <pmurias> ruoso: want is the main thing

[20:16] <ruoso> pmurias, want can be implemented by introspection, at first...

[20:17] <ruoso> but it can also wait until we have 'forward context propagation' as well

[20:18] <pmurias> introspection - how?

[20:19] <ruoso> by looking at the frames

[20:19] <pmurias> that would be a truly horrible hack

[20:20] <ruoso> yeah... I know ;)

[20:20] <ruoso> but I do think "want" can wait until we have the 'forward context propagation' implemented

[20:20] <ruoso> the thing I'm trying to avoid is the use of want at this early stages of development

[20:21] <ruoso> the truth is that I see want as a 'horrible hack' ;)

[20:22] <ruoso> that way I think it should be implemented only as a feature that is in the specs to be supported, not as something we'll be using in the type system bootstrap

[20:23] <moritz_> std: "abc".:d

[20:23] <p6eval> std 22265: OUTPUT[parsed␤]

[20:26] <ruoso> pmurias, is there any other worry besides want?

[20:27] <pmurias> lazy context propagation leads to ugly m0ld code

[20:27] <ruoso> pmurias, that's why we need s1p :)

[20:27] <ruoso> that will generate the ugly m0ld code :)

[20:28] <pmurias> which i'll read while debugging s1p :(

[20:30] *** justatheory left
[20:30] <ruoso> I see... but I really honestly think the ugly m0ld code will buy us a much better runtime

[20:31] <pmurias> i think there are no other worries because the builtin stuff doesn't return unrelated stuff in different contexts as that just confuses people

[20:31] *** justatheory joined
[20:32] <pmurias> ruoso: what are actually the arguments in favor of 'lazy context propagation'?

[20:33] <rakudo_svn> r31188 | moritz++ | [rakudo] revert parts of r31185, it broke smart matching against "normal" code

[20:33] <rakudo_svn> r31188 | moritz++ | objects (ie not regexes)

[20:34] <ruoso> the problem is that you don't actually have much control over the object you're calling, because of how much P6 supports polymorphism... that way.. you wouldn't have a way to know if some value returned by some method is context-wise or not

[20:35] <ruoso> and more importantly...

[20:35] <ruoso> most of the time, the methods will return a simple plain value

[20:35] <ruoso> and that value, will be context-wise

[20:35] <ruoso> that way... only very few value types actually need to be context-wise

[20:36] <ruoso> on the other hand, if we go for forward context propagation... every single method will need to be context-wise

[20:37] <pmurias> with the "forward context propagation" most of the values will just pass the context on

[20:37] <ruoso> pmurias, the bigger problem with that is the bootstrap smop does in the method calls

[20:38] <ruoso> because there's no difference between low-level method call and high-level method call

[20:38] <ruoso> so every method implemented by every RI will need to be context-wise

[20:38] *** wknight8111 joined
[20:38] <ruoso> including the low-level ones

[20:40] <pmurias> it seems a bit of work to convert everything now (i can do it), but just a tiny bit of work for every future RI

[20:40] <ruoso> the problem is not how much work it means

[20:41] <ruoso> but how fragile the model becomes

[20:41] <pmurias> example please

[20:42] <ruoso> map implementation (see the wiki page) with forward context propagation

[20:43] <ruoso> becomes much more fragile, because it presumes too much from what other method calls will do

[20:44] <pmurias> i think we will need a hybrid approach, as even an evil Perl 6 method can return the wrong thing in the wrong context

[20:45] <ruoso> that's my point... 'forward context propagation' is an optimization for smop

[20:45] <ruoso> because it depends too much on the foreign object...

[20:45] <ruoso> and you can only count on it when the other object is really known by you

[20:45] <pugs_svn> r22266 | moritz++ | [t/spec] add smart match tests for unary sub truth

[20:45] <ruoso> which might happen most of the time...

[20:45] <ruoso> and that's where optimizers comes in...

[20:46] <ruoso> the optimizer would generate a prettier m0ld code

[20:47] <ruoso> jit-compile it to a multi with the context in the signature

[20:47] <ruoso> and the multi dispatch would use it depending on the context presented in the capture

[20:48] <ruoso> (that's one way to implement that optimization... some more evil alternatives are also possible)

[20:49] <pmurias> ruoso: the map implementation actually seems easier with forward context propagation

[20:50] <ruoso> it seems easier when you know all the participants

[20:51] <ruoso> but when the participants are unknown (that's where the polymorphism comes in)

[20:51] <ruoso> and potentially lazy

[20:51] <ruoso> it looks a lot harder

[20:51] * ruoso later & 

[20:51] * ruoso have to run &

[20:52] *** ruoso left
[20:52] *** larsen__ joined
[20:53] *** justatheory left
[20:54] *** lisppaste3 joined
[20:55] *** larsen_ left
[21:00] *** lisppaste3 left
[21:01] *** lisppaste3 joined
[21:06] *** charsbar_ joined
[21:07] *** charsbar left
[21:07] *** c9s joined
[21:07] *** ptman joined
[21:07] *** Helios- left
[21:07] *** jiing left
[21:08] *** jiing joined
[21:08] <pugs_svn> r22267 | moritz++ | [t/spec] if I formulate these smartmatch tests correctly, they might actually

[21:08] <pugs_svn> r22267 | moritz++ | work. Also unfudged for rakudo.

[21:08] *** Helios- joined
[21:11] *** hercynium joined
[21:22] *** armagad joined
[21:23] *** justatheory joined
[21:25] *** armagad left
[21:25] *** eternaleye joined
[21:28] <moritz_> @tell mberends I made the subject of RT #58936 a bit more verbose, thanks for reporting!

[21:28] <lambdabot> Consider it noted.

[21:29] *** TJCRI left
[21:31] *** armagad joined
[21:34] *** armagad left
[21:36] *** larsen__ left
[21:44] *** Khisanth joined
[21:50] *** eternaleye left
[21:51] *** eternaleye joined
[21:54] *** lisppaste3 left
[21:57] *** obra joined
[22:05] *** Khisanth left
[22:05] *** hercynium left
[22:13] *** lisppaste3 joined
[22:17] *** lisppaste3 left
[22:18] *** lisppaste3 joined
[22:20] *** Chillance left
[22:20] *** lisppaste3 left
[22:21] *** lisppaste3 joined
[22:26] *** lisppaste3 left
[22:27] *** lisppaste3 joined
[22:34] <lisppaste3> Apologies for the trouble today. The bot should stop bouncing in and out of your channel now.

[22:35] *** xuser left
[22:36] *** alester left
[22:38] *** Limbic_Region joined
[22:38] *** pmurias left
[22:41] *** xuser joined
[22:46] *** hanekomu left
[22:51] *** iblechbot left
[22:52] *** clintongormley left
[22:57] *** Khisanth joined
[23:23] *** sri_work left
[23:53] *** ruoso joined
