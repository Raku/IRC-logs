[00:03] *** ryanc left
[00:09] *** [particle]2 joined
[00:11] *** bacek joined
[00:13] *** dolmen left
[00:13] *** [particle] left
[00:14] <TimToady> japhb: no, it hasn't changed, as far as I know.  I would not mind switching the next version of p5 over to Artistic 2, but that would require community buy-in that would perhaps be difficult to achieve

[00:16] <TimToady> or we could go further with the junctional licensing: "may be copied under the terms of either the Artistic 2 or (the Artistic 1 or the GPL)"

[00:16] *** Juerd_test joined
[00:16] <Juerd_test> (Testing some webchat thingy at mibbit.com)

[00:16] <Juerd_test> (Looks nice)

[00:17] <TimToady> the main point is that Artistic 2 doesn't need the dual licensing with GPL in order to be GPL compatible

[00:17] *** Juerd_test left
[00:18] <TimToady> that might possibly upset some folks who are violently anti-GPL, I suppose

[00:19] <TimToady> anyway, I'm not too worried about it one way or the other, given that A1 has held up in court now

[00:19] <TimToady> always assuming the SC doesn't overturn that decision...

[00:20] <TimToady> I'm just very glad I used the terms "conditions" and "provided that"

[00:25] *** [particle]1 left
[00:25] *** Limbic_Region left
[00:26] *** Limbic_Region joined
[00:41] *** [particle] joined
[00:42] *** Limbic_Region left
[00:48] *** sri_work_ left
[00:48] *** sri_work joined
[00:56] *** [particle]2 left
[01:02] *** scrottie joined
[01:19] *** iblechbot left
[01:25] *** [particle]1 joined
[01:36] *** xinming left
[01:37] *** xinming joined
[01:41] <meppl> good night

[01:44] *** [particle] left
[01:53] *** justatheory left
[01:54] *** meppl left
[02:15] *** alester joined
[02:22] *** wknight8111 left
[02:23] *** fridim_ left
[02:28] *** [particle]1 left
[02:28] *** [particle] joined
[02:29] *** elmex left
[02:46] *** Schwern left
[02:52] *** Schwern joined
[02:53] *** Schwern left
[03:15] <japhb> TimToady: ah, thank you for the license info.  And belated congratulations on the A1 court win! (I'd seen that earlier this week, but forgot to pop in and say something.)

[03:28] *** sitaram joined
[03:32] *** lambdabot left
[03:44] *** lambdabot joined
[03:58] *** agentzh left
[04:00] *** hercynium joined
[04:11] *** _00z joined
[04:23] *** ggoebel left
[04:25] *** alester left
[04:32] *** alester joined
[04:42] *** Bzek joined
[04:44] *** overdrive3000 joined
[04:46] *** hercynium left
[04:55] *** Bzek left
[04:56] *** agentzh joined
[05:15] *** kanru left
[05:37] *** Psyche^ joined
[05:45] *** alester left
[05:45] *** Schwern joined
[05:45] *** Schwern left
[05:46] *** kanru joined
[05:48] *** Schwern joined
[05:49] *** Patterner left
[05:49] *** Psyche^ is now known as Patterner

[05:54] *** masak joined
[05:55] *** overdrive3000 left
[06:13] *** ashizawa joined
[06:15] *** _00z left
[06:19] *** drbean left
[06:52] *** penk joined
[07:01] *** apeiron left
[07:02] *** BinGOs joined
[07:02] *** viklund joined
[07:11] *** apeiron joined
[07:13] *** kane_ left
[07:14] <masak> one of the most common mistakes I make when programming Perl 6 is forgetting to put "self." in front of calls to methods on the invocant

[07:15] <masak> and to some extent, the "self." doesn't _feel_ necessary, so instead of feeling regret, I feel irritation each time I forget it

[07:15] <masak> is there a nifty shorthand I'm unaware of?

[07:16] <moritz_> use $s as self ,)

[07:16] <moritz_> then it's only $s.stuff

[07:16] <moritz_> but I don't think you can really avoid it

[07:16] <moritz_> because methods *are* different than subs

[07:16] <masak> true

[07:17] <masak> it's just... as a Java programmer, I think I expect to be able to leave off the "self."

[07:17] *** sri_work left
[07:17] <masak> I guess I could shroud all my methods in given self { ... }

[07:17] <masak> :)

[07:17] <masak> and then use .method

[07:17] <moritz_> well, why not ;)

[07:18] <masak> or maybe just call the invocant $_

[07:18] <moritz_> note that $_ scopes differntly than "ordinary" variables

[07:19] <masak> noted.

[07:19] <masak> ...which doesn't work to my advantage here, I guess :/

[07:19] <moritz_> does it even matter for you?

[07:20] <masak> couldn't $_ be changed in one of the method calls in my method?

[07:21] <masak> and then it wouldn't contain my invocant any more

[07:22] <moritz_> my $_ is ro = self; or soemthing perhaps?

[07:24] <masak> 'ro' affects the container, right? not the value inside?

[07:24] <moritz_> right

[07:25] <masak> a few months back, I had an email discussion with someone on perl6-lang about 'is ro' and optimizations

[07:26] <masak> if the 'ro' trait sticks to the container, not much can be said about the mutability of the value inside

[07:27] <masak> and hence, not many optimizations can safely be made

[07:27] <moritz_> except for immutable types

[07:27] <moritz_> like Str and most numeric types

[07:34] *** drbean joined
[07:40] <masak> can the same container be flagged as 'is ro' in one block and 'is rw' in another?

[07:49] <moritz_> no

[07:49] <masak> why not?

[07:49] <moritz_> but a container of the same name can be declared in a nested scope

[07:49] <masak> but then it's another container

[07:50] <moritz_> wouldn't make much sense, would it?

[07:52] <TimToady> you can call a method with $.stuff even if there's no such attribute

[07:53] <TimToady> or @.stuff, %.stuff, whatever is good documentation

[07:53] <masak> TimToady: that's good news

[07:54] <TimToady> well, on the other hand, I think when you're not using it as a variable, self.stuff reads better

[07:54] <TimToady> and you can simply declare the invocant as $_, as in method foo ($_: $a,$b,$c)

[07:55] <TimToady> (but be prepared for inner constructs to hide it)

[07:55] <TimToady> ((which is why it's not the default))

[07:55] <masak> I think my expectations are skewed from Java

[07:55] <TimToady> and "self" itself is just a token rule, which you can override if you like

[07:56] <TimToady> I prefer to know whether I'm invoking the single dispatcer or the multiple dispatcher

[07:56] <TimToady> so I think it's important to maintain the visual distinction

[07:57] <TimToady> since the dispatchers have *very* different philosophies

[07:57] <TimToady> of a "who's to be master, that's all" variety

[07:59] <TimToady> as for transitive ro-ness, it seems easier to add it where we need it than to remove it where we don't

[07:59] <masak> yes

[07:59] <masak> all I'm curious about is, could an ro container ever be mutated, theoretically?

[08:00] <TimToady> and the one-level approach we currently have prevents needless autoviv, which is the main point

[08:01] <TimToady> everything the mathematicians haven't nailed down precisely can be mutated theoretically :)

[08:01] <masak> :)

[08:02] *** pjenvey_ joined
[08:03] <TimToady> and, since the default parameter trait could be determined lexically, a pragma could set all default sigs to "is frozen" or some such without getting into C++-ish const-ipation

[08:05] <TimToady> I think half the weight of a typical C++ program must be in "const" declarations

[08:06] <TimToady> moritz_: btw, there is no exists or delete at the moment, but I'm thinking about whether to re-introduce them

[08:06] <moritz_> TimToady: S29 lists them as "is export"

[08:07] <TimToady> it's currently supposed to be %hash.:exists<foo>

[08:07] <moritz_> TimToady: doesn't that make them available as a sub?

[08:07] <TimToady> well, S29 might be wrong there, but in any case, export would turn them into exists(%hash, 'foo')

[08:07] <TimToady> it wouldn't support the p5 usage

[08:08] <moritz_> right

[08:09] <moritz_> to support the perl 5 useage, do they have to be macros?

[08:09] <TimToady> kinda

[08:10] <TimToady> given the current way EXPR has to look at the precedence of prefix and postfix ops to see if it needs to interleave them

[08:10] <TimToady> it wouldn't be too difficult to interpose an operation just before the final subscript

[08:11] <TimToady> so exists %foo<bar> turns into something like %foo.exists.<bar>

[08:11] <TimToady> except that it can then just change the meaning of the final subscript

[08:12] <moritz_> sounds scary, in the general case

[08:12] <TimToady> but after staring at various forms of my usage in STD, I think the P5 form is actually important to maintain

[08:13] <moritz_> yes

[08:13] <TimToady> because of the way people chunk it

[08:13] <TimToady> currently it would have to be written self.<_>[self.pos].:exists<ws>

[08:13] <TimToady> (since I've been using gimme5, I just cheat and use the p5 form there)

[08:14] <moritz_> can't %hash<nonexistantkey> just return something that 'exists' recognizes as non-existant?

[08:14] <TimToady> but it really wants to be either "exists self.<_>[self.pos]<ws>"

[08:14] <TimToady> or "self.<_>[self.pos]<ws> :exists"

[08:14] <moritz_> some kind of "special undef", like we do it all the time?

[08:15] <TimToady> yes, that works for exists, but not so well for delete

[08:15] <moritz_> uhm, right

[08:15] <TimToady> you'd have to mark every value with a backref to its container

[08:16] <moritz_> which is (at least) equally scary

[08:16] <TimToady> the main problem with the interleaving macro approach is, what if the user defines their own delete multi

[08:17] <moritz_> multi macro?

[08:17] <TimToady> thinking normal function

[08:18] <TimToady> but it might not have the right scoping with respect to the builtin macro

[08:18] <TimToady> well, maybe it would

[08:18] <moritz_> maybe we can have some kind of non-evaluation context

[08:18] <moritz_> so that sub foo :noneval (...) { .. } receives and AST of its argument capture

[08:19] <moritz_> s/and/an/

[08:19] <TimToady> might be more useful to be able to pop off the last operation and have the rest automatically compiled

[08:19] <TimToady> at least, that would be more useful for exists/delete

[08:20] <TimToady> but any macro can theoritically get the AST and play with it

[08:20] <moritz_> the Perl6is approach is to offer both ;)

[08:20] <moritz_> but a macro can't participate in multi dispatch, right?

[08:20] <TimToady> correct

[08:20] <moritz_> well, I guess it's hard to do multi dispatches on ASTs too

[08:21] <TimToady> well, it can do multi dispatch, but only at compile time, not run time

[08:23] <moritz_> the TCL approach is to move the parsing to run time ;)

[08:23] <TimToady> fine, if you have the One True Syntax

[08:24] <moritz_> (I don't think it's practical for Perl 6 in any way ;)

[08:24] <TimToady> so anyway, that's the problem with macros, and why we ended up with the .:exists<foo> form

[08:24] *** pjenvey_ left
[08:25] <TimToady> since we already had methods like $filehandle.:r

[08:26] *** iblechbot joined
[08:29] <TimToady> but the point of monkeying with EXPR is that we could rewrite exists %foo<bar> into exists(%foo,<bar>) as a real function call that could be multied in with other multies

[08:30] <TimToady> sort of a self-modifying macro, as it were

[08:31] <TimToady> but still thinking about it.  meanwhile, I don't think exists exists

[08:32] <araujo> There is no spoon

[08:35] *** Myoma left
[08:35] <moritz_> should I remove them from STD?

[08:36] <TimToady> already gone in my copy, but thinking how to fix my own calls :)

[08:36] <TimToady> the .:exists<foo> form is actually kinda hard for gimme5 to translate generally

[08:38] <TimToady> ('course, that's the other nice thing about that form is that you can use the implicit $_ form while preserving the appearance of a subscript

[08:39] <TimToady> so maybe we'll stick with the adverb-as-method syntax, and install something in the undefined warner to tell you what to use instead of exists and delete

[08:41] <TimToady> well, can't really think straight at 1:40 in the morning...

[08:41] <TimToady> (not that I can think straight at any time of day...)

[08:41] <TimToady> so, night night.

[08:41] <moritz_> fractal thinking is preferred over straight thinking anyway ;)

[08:41] <moritz_> good night ;)

[08:42] <TimToady> zzz &

[08:43] *** jferrero joined
[08:50] *** zamolxes left
[09:04] *** bacek left
[09:08] *** meppl joined
[09:08] <pugs_svn> r22005 | lwall++ | [STD] remove p5ish usages of exists/delete

[09:08] <pugs_svn> r22005 | lwall++ | [gimme5] translate .:exists and .:delete forms to p5

[09:08] <pugs_svn> r22005 | lwall++ | [S29] remove "is export" from exists/delete methods

[09:10] * TimToady is too old to do sleep-hacking # zzz really

[09:16] <pugs_svn> r22006 | lwall++ | [STD] somehow missed adding min and max infixes

[09:17] <TimToady> zzz really really...

[09:27] *** larsen_ joined
[09:32] <scrottie> that should fix that one.

[09:32] <moritz_> now somebody brave should fix the test suite ...

[09:33] <scrottie> erm, pardon.  lost control of x2x.

[09:33] <scrottie> or MENU

[09:33] * scrottie kills x2x... dammit

[09:39] *** pmurias joined
[09:39] *** pmurias left
[09:51] *** zamolxes joined
[09:52] *** zamolxes left
[09:53] *** zamolxes joined
[10:25] *** cotto_w0rk joined
[10:29] *** kane_ joined
[10:42] *** cotto_work left
[10:50] *** pmurias joined
[10:51] *** sitaram left
[11:11] *** wknight8111 joined
[11:16] *** elmex joined
[11:20] *** zamolxes left
[11:22] <pmurias> is there any use of being able to use an embedded smop from haskell? (i want to play with the haskell FFI, and i'll do it if it's not pure yak shaving)

[11:23] *** zamolxes joined
[11:41] *** penk left
[11:43] *** BinGOs left
[12:07] <audreyt> pmurias: sure, it'll provide an alternate eval() path for pugs without going through GCC at runtime...

[12:09] <pmurias> audreyt: going through GCC is hack until smop can load bytecode

[12:09] <pmurias> * a hack

[12:10] <moritz_> I thought SMOP was designed to be a run time library, not a VM? (that's what ruoso keeps telling me...)

[12:10] <audreyt> also it will make it easier to expose callback primitives

[12:10] <audreyt> so you can get e.g. STM stuff as additional objects

[12:11] <audreyt> to the smop runtime

[12:11] *** ashizawa left
[12:12] <audreyt> moritz_: there is very little difference... if perl5's ByteLoader isn't broken then it's arguably a VM (though a particularly platform-dependent one) as well :)

[12:12] <audreyt> pmurias: embedded smop would be there's no need to write extensive "foreign export" wrapper stuff to expose haskell-land objects (or perl5-land objects) into smop

[12:13] <moritz_> audreyt: I guess that's exactly what the difference is: byte code loading 

[12:14] <audreyt> pmurias: so if you got smop embedding going in ffi, then we can have

[12:14] <audreyt> smop_s1p_root_namespace_insert :: Interpreter -> Name -> Object -> IO ()

[12:14] <pmurias> i started working on a m0ld Pugs backend so the smop haskell, but can switch to the smop embedding if you think it's more important

[12:16] <audreyt> I think both are pretty important but FFI sounds like fun

[12:16] <audreyt> sorry, bbiab, my <1mo old macbook disk is rapidly failing :/

[12:18] <pmurias> s/so the smop haskell/

[12:18] <pmurias> \/

[12:19] <audreyt> having smop_s1p_root_namespace_insert in hsland means randomly inserting new classes available thru the runtime, for example a parser class or even a &*::eval 

[12:19] <audreyt> er I mean &*eval.

[12:20] *** clintongormley joined
[12:23] <pmurias> PIL1 seems to reinvent [] is some places

[12:24] <pmurias> s/is/in/

[12:24] * audreyt goes finding replacement to completely failing HD. :( 

[12:24] <audreyt> bbl

[12:33] *** IRSeekBot left
[12:37] <pmurias> audreyt: what's the prefered way to reading AST for a given bit of code, -Cpil1 doesn't add enough whitespace

[12:37] *** ruoso joined
[12:38] <ruoso> Hello!

[12:38] <audreyt> pmurias: then it could be fixed -- for human inspection I usually use pugs -CParse-Pretty

[12:39] *** diakopter joined
[12:40] <ruoso> moritz_, about to be or not to be a vm... the VM concept barriers are pretty much debatable.... I now tend to say... If you think p5 as a VM, then smop is a VM...

[12:41] <pmurias> ruoso: hi

[12:41] <ruoso> what I do think is that there's a big difference in the fact that SMOP doesn't need a Native Call Interface, because it doesn't abstract to that level...

[12:42] <ruoso> pmurias, hi

[12:42] <diakopter> pmurias: hi

[12:43] <ruoso> TimToady, one thing I'm not really sure is about exposing methods as subs (unless when explicit "is export")... I don't really see the use for that...

[12:43] <pmurias> diakopter: hi

[12:44] <pmurias> ruoso: OTOH smop would benefit from a NCI

[12:44] <ruoso> It can have several NCI implementations... they will be tools to integrate things...

[12:44] <ruoso> but they are far from being *the* NCI that allows getting out of the "vm"

[12:45] <ruoso> because there isn't such a sandbox in smop

[12:45] <ruoso> even when smop has a bytecode, in the end that bytecode could be represented as a set of C calls

[12:46] <ruoso> and the bytecode usage is limited to the scope of that specific code 

[12:46] <ruoso> it's not really like an assembler...

[12:47] <ruoso> we just use that to make it easier to write stackless code

[12:47] <ruoso> we could, in theory, survive writing only C code...

[12:48] <ruoso> but we're too lazy to do that

[12:49] <pmurias> ruoso: the discussion is a bit pointless, but we do not differ from parrot much in that regard

[12:49] <ruoso> TimToady, is there a specific use case you have in mind for having all methods visible as subs in the Package?

[12:49] <moritz_> is that even the case?

[12:49] *** Alias_ joined
[12:49] <moritz_> if so, where is that specced?

[12:49] <ruoso> pmurias, indeed... it's bit pointless... 

[12:50] <ruoso> moritz_, TimToady told me at some point in the irc

[12:53] <moritz_> it seems very weird. Method dispatch is handled by the object, and sub calls by something completely differnt

[12:54] <moritz_> might have been a misunderstanding of some kind

[12:54] <ruoso> it's not the dispatch that is the same... but the methods that are *also* exposed as subs in the package...

[12:55] <ruoso> like aliases

[12:55] <ruoso> so you can refer to the method object going through the package

[12:55] <ruoso> but I think the sane way to do that would be through the meta

[12:56] <ruoso> so I don't see the use case for having the aliases for the methods in the package

[12:56] *** BinGOs joined
[12:56] <moritz_> but it would also imply weird stuff: class { has $.time; # here time() refers to self.time }

[12:57] *** BinGOs left
[12:57] *** BinGOs joined
[12:57] <pmurias> ruoso: re qualified attendees, what's the biggest barrier to hacking on smop now?

[12:57] <ruoso> pmurias, the exotic nature of SMOP?

[12:58] *** simcop2387 left
[12:59] *** simcop2387 joined
[13:00] <ruoso> I think that barrier should lower once that s1p is in place...

[13:00] <ruoso> but at this point, a lot of faith in the future is needed to hack on smop ;)

[13:02] <ruoso> audreyt, pmurias, btw... embedding smop in pugs should be a very interesting way to implement s1p... it should even allow us to have a evalbot ;) since pugs could be creating mold frames at runtime and executing them...

[13:03] <ruoso> instead of having to go through gcc to compile the code...

[13:04] <ruoso> and I even think smop already has enough features to support some oneliners

[13:04] <pmurias> food&

[13:08] *** jferrero left
[13:12] *** alester joined
[13:18] *** jan__ left
[13:22] *** alester left
[13:27] * ruoso leaving to an interview about free software in a local radio... 

[13:27] * ruoso later &

[13:27] *** ruoso left
[13:33] *** rdice joined
[13:46] *** IRSeekBot joined
[13:49] *** ggoebel joined
[13:53] *** Bzek joined
[13:59] <clintongormley> rakudo: @a=<1 2 3>; say @a;

[13:59] <p6eval> rakudo 29834: OUTPUT[Scope not found for PAST::Var '@a'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤]

[13:59] <clintongormley> rakudo: my @a=<1 2 3>; say @a;

[13:59] <p6eval> rakudo 29834: OUTPUT[123␤]

[13:59] <clintongormley> rakudo: @a=<1 2 3>; say "@a";

[14:00] <p6eval> rakudo 29834: OUTPUT[Scope not found for PAST::Var '@a'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤]

[14:00] <clintongormley> rakudo: my @a=<1 2 3>; say @a;

[14:00] <p6eval> rakudo 29834: OUTPUT[123␤]

[14:00] <clintongormley> blast

[14:00] <moritz_> rakudo: my @a=<1 2 3>; say @a.perl;

[14:00] <clintongormley> rakudo: my @a=<1 2 3>; say "@a";

[14:00] <clintongormley> that got it foxed :)

[14:00] <p6eval> rakudo 29834: RESULT[["1", "2", "3"]␤1]

[14:00] <p6eval> rakudo 29834: OUTPUT[@a␤]

[14:01] <clintongormley> rakudo: my @a=<1 2 3>; say "@a[]";

[14:01] <p6eval> rakudo 29834: OUTPUT[@a[]␤]

[14:01] <clintongormley> huh?

[14:01] <clintongormley> moritz - reading your blog

[14:01] <clintongormley> about interpolation

[14:01] <masak> indeed, huh?

[14:01] <moritz_> that's weird

[14:01] <clintongormley> glad it's not just me :)

[14:01] <masak> clintongormley: perhaps not implemented yet

[14:01] <moritz_> I knew it worked some time ago

[14:01] <masak> clintongormley: care to submit a bug to rakudobug? :)

[14:01] <moritz_> (or I think I knew)

[14:02] <clintongormley> pugs: my @a=<1 2 3>; say "@a";

[14:02] <p6eval> pugs: OUTPUT[@a␤]

[14:02] <clintongormley> pugs: my @a=<1 2 3>; say "@a[]";

[14:02] <p6eval> pugs: OUTPUT[1 2 3␤]

[14:02] <clintongormley> ok masak

[14:02] <clintongormley> hmm - url?

[14:02] <moritz_> [email@hidden.address]
[14:03] <clintongormley> ah - just an email

[14:03] <clintongormley> ok

[14:03] <clintongormley> any particular format for subject, body etc?

[14:03] <moritz_> nothing really

[14:03] <clintongormley> can i get a rakudo version number from the bot?

[14:04] <moritz_> 16:00 < p6eval> rakudo 29834: OUTPUT[@a#]

[14:04] <moritz_> the 29834 is the revision number

[14:04] <clintongormley> ah right - thanks

[14:04] <clintongormley> moritz++ for the blog

[14:04] <clintongormley> keep it up

[14:05] <moritz_> clintongormley: I wrote about 5 more posts already...

[14:05] <clintongormley> out of interest, why would "@a" not work?

[14:05] <moritz_> clintongormley: but since I know that I'll slow down, I publish them only one per day

[14:05] <clintongormley> :D

[14:05] <moritz_> I think it's because of email addresses

[14:05] <moritz_> but I'm not sure

[14:05] <clintongormley> ah ok

[14:07] <moritz_> it seems array interpolation is undertested

[14:07] <moritz_> r15926 | pmichaud | ... * Understands basic interpolation schemes, including interpolation  of arrays and other constructs into "..." and <<...>> .

[14:08] <moritz_> so it's clearly a regression, not a TODO thing

[14:12] *** Exodist joined
[14:13] <masak> moritz_: yes, it's because of email addresses

[14:14] <clintongormley> moritz: "Finally you should know that both [..] and {...} are just method calls with a special syntax, not something tied to arrays and hashes. That means that they are also not tied to a particular sigil.  "

[14:14] <clintongormley> ??

[14:14] <clintongormley> you give as your example:

[14:14] <clintongormley>     my $a = [1, 2, 3];     say $a[2];          # 3

[14:14] <clintongormley> so does that actually mean $a contains an array ref?

[14:16] *** pmurias left
[14:16] <moritz_> clintongormley: yes

[14:17] <moritz_> clintongormley: or "an Array object", since everything is a reference, so otalking about references is mostly meaningless

[14:17] <clintongormley> but if you were to say, eg my %a={ 'a'=> 1, 'b' => 2}; print %a[1]

[14:17] <pugs_svn> r22007 | moritz++ | [t] some fixes for try as a function

[14:17] <clintongormley> what would that do?

[14:18] <clintongormley> fail? :)

[14:18] <moritz_> no, you can use { ... } to construct hashes, IIRC

[14:18] <pugs_svn> r22008 | moritz++ | [t] move interpolation tests to spec/, add a few.  clintongormley++.

[14:18] <moritz_> rakudo: my %a={ 'a'=> 1, 'b' => 2};; say %a.perl; say %a<b>

[14:18] <p6eval> rakudo 29834: OUTPUT[Odd number of elements found where hash expected␤current instr.: 'parrot;List;hash' pc 2739 (src/gen_builtins.pir:1883)␤]

[14:19] <moritz_> ... or perhaps not. /me is unsure ;)

[14:19] <moritz_> pugs: my %a={ 'a'=> 1, 'b' => 2};; say %a.perl; say %a<b>

[14:19] <p6eval> pugs: OUTPUT[\(\("a", 1), \("b", 2))␤2␤]

[14:20] <clintongormley> sorry, my question was about how [] and {} are methods, not specifically tied to arrays/hashes

[14:20] <masak> IIUC, things like my @a = [1,2,3]; create am array with one element, namely the Array object with the three elements 1, 2 and 3.

[14:20] <masak> that still surprises me sometimes.

[14:21] <moritz_> clintongormley: just a sec, I'll write something for you..

[14:21] <clintongormley> but if you were to try to use [] on a hash... presumably that would be 'unknown method' or something similar

[14:21] <[particle]> pugs: my %h = { 'a' => 1 }; %h['a'];

[14:21] <p6eval> pugs: RESULT[\\("a", 1)]

[14:22] <[particle]> urk

[14:22] <[particle]> rakudo: my %h = { 'a' => 1 }; %h['a'];

[14:22] <p6eval> rakudo 29834: OUTPUT[Odd number of elements found where hash expected␤current instr.: 'parrot;List;hash' pc 2739 (src/gen_builtins.pir:1883)␤]

[14:22] <pasteling> "moritz_" at 89.13.255.83 pasted ".[] as a method, for clinton" (6 lines, 138B) at http://sial.org/pbot/31970

[14:22] <[particle]> rakudo: my %h = ( 'a' => 1 ); %h['a'];

[14:22] <p6eval> rakudo 29834: RESULT[undef]

[14:22] <[particle]> rakudo: my %h = ( 'a' => 1 ); %h{'a'};

[14:22] <p6eval> rakudo 29834: RESULT[1]

[14:23] <moritz_> clintongormley: does the example in the paste make it more clear?

[14:23] <[particle]> looks like t/spec/ needs some tests wrt %h[...] and @a{...}

[14:23] <clintongormley> yeah - i get that you can define those symbols as a method 

[14:24] <moritz_> [particle]: I just moved some array interpolation tests there, and currenly fudging them

[14:24] <clintongormley> the way you wrote it in that tutorial, my first thought was that sigils are syntactic sugar, and not really necessary to determine array/hash etc

[14:25] <clintongormley> as opposed to "actually these are just implemented as methods of array and hash objects respectively"

[14:25] <masak> moritz_: nitpick: you defined postcircumfix:<{ }> but used []

[14:25] <moritz_> masak: uhm, yes. /me dumb ;)

[14:25] <masak> not at all, it's just Friday :)

[14:29] <pugs_svn> r22009 | moritz++ | [spec] fudged array-interpolation.t for rakudo. 

[14:29] <pugs_svn> r22009 | moritz++ | Sadly I also had to join some lines, because fudge doesn't work with multi

[14:29] <pugs_svn> r22009 | moritz++ | line test statements

[14:29] <masak> it doesn't? :/

[14:29] <[particle]> hrmm, that can be fixed

[14:29] <masak> fudge is less magical than I supposed...

[14:29] <moritz_> [particle]: go right ahead

[14:30] <[particle]> yeah, not today, unfortunately

[14:30] *** Alias_ left
[14:30] <[particle]> work for 3.5hrs, then dentist, then weekend with in-laws

[14:31] <moritz_> sounds like no fun :(

[14:32] <pugs_svn> r22010 | moritz++ | [t] moved hash interpolation test to spec/

[14:35] <pugs_svn> r22011 | moritz++ | [spec] fudged hash-interpolation.t for rakudo

[14:35] <masak> at least he doesn't have to work _at_ the dentist's office, while his in-laws watch

[14:36] <[particle]> :)

[14:36] <masak> things can always be less fun than they actually are.

[14:36] <[particle]> -O"less fun than it actually is"

[14:36] <masak> haha

[14:40] <[particle]> i'd like to say that parrot has impressed me.

[14:40] <[particle]> seems it doesn't matter what platform regression spectests are added on, they work on all platforms

[14:41] <[particle]> portability++ parrot++

[14:41] <moritz_> except for a few small GC issues, or libicu unavailability

[14:42] <masak> I'm impressed too. but I do get segfaults on every other runtime error, due to some unresolved GC issue.

[14:42] <[particle]> gc is *hard*

[14:43] <[particle]> but we're addressing that now.

[14:43] *** pmurias joined
[14:43] <[particle]> first mmd, then io, with ongoing gc.

[14:43] <masak> [particle]++

[14:45] <pmurias> audreyt: why doesn't PIL1 derive Data?

[14:46] <audreyt> pmurias: GADTs can't currently derive data automagically

[14:46] <audreyt> pmurias: though we can arrange for it to happen

[14:46] <audreyt> using the derive package

[14:47] *** scrottie left
[14:50] <pmurias> audreyt: are there any GADTs in PIL1?

[14:50] <pugs_svn> r22012 | moritz++ | [t/spec] add RT number to todo message

[14:51] <audreyt> oh right

[14:51] <audreyt> there is none atm :) it was factored out

[14:51] *** rakudo_svn joined
[14:52] <rakudo_svn> r30447 | moritz++ | [rakudo] added array interpolation tests to spectest_regression

[14:52] <rakudo_svn> r30449 | moritz++ | [rakudo] add hash interpolation tests to spectest_regression

[14:52] <audreyt> you'd need to derive Data for everything else it uses, though

[14:53] <[particle]> hrmm, rakudo_svn bot used to be faster than #parrot's dalek at reporting svn ci

[14:53] <audreyt> including Val, which has the VRef case

[14:53] <audreyt> which which uses IVar

[14:53] <audreyt> which is GADT

[14:53] * audreyt finally recalled the chain

[14:54] <audreyt> pmurias: but you can experiment with standalone deriving

[14:57] *** turrepurre joined
[15:04] *** cathyal joined
[15:05] *** alester joined
[15:08] *** viklund left
[15:11] *** justatheory joined
[15:14] *** hercynium joined
[15:16] *** meppl left
[15:17] *** meppl joined
[15:22] *** bennymack-work joined
[15:23] *** mofino joined
[15:24] <bennymack-work> is there something to read about the rakudo REPL? I get these PAST/Var errors when attempting to acces "my" variables

[15:24] *** zamolxes left
[15:26] <moritz_> bennymack-work: can you paste an example script?

[15:27] <moritz_> list assignment is not implemented, so ($a, $b) = ... won't work

[15:28] *** rindolf joined
[15:28] *** Exodist left
[15:30] *** meppl left
[15:31] <clintongormley> moritz_ please add p6 regexes to your tutorial list

[15:31] <clintongormley> or are they Rules?

[15:31] *** jhorwitz joined
[15:31] <moritz_> clintongormley: they are Rules

[15:31] <clintongormley> ah ok

[15:31] *** meppl joined
[15:32] <pasteling> "bennymack" at 24.75.15.14 pasted "REPL issues." (6 lines, 93B) at http://sial.org/pbot/31972

[15:32] <clintongormley> and what's that .perl method i see you use?

[15:32] <clintongormley> a deparser?

[15:32] <moritz_> clintongormley: it's the built in Data::Dumper equivalent

[15:32] <clintongormley> ok

[15:32] <clintongormley> ta

[15:32] <moritz_> bennymack-work: the rakudo REPL puts a block around each line :(

[15:32] <clintongormley> laters all

[15:33] <bennymack-work> hrm

[15:33] <moritz_> bennymack-work: so to use variables in the repl, you have to define them on the same line

[15:33] <bennymack-work> ok

[15:33] <moritz_> rakudo: my $x = 1; say $x.WHAT

[15:33] <p6eval> rakudo 29834: OUTPUT[Int␤]

[15:33] <moritz_> I love my evalbot ;)

[15:34] * [particle] too

[15:34] <bennymack-work> would using an our variable fix that somehow?

[15:34] *** meteorjay left
[15:35] <moritz_> no

[15:38] <masak> bennymack-work: I never use the Rakudo REPL. it sucks.

[15:38] <masak> I write command-line one-liners instead :)

[15:39] <moritz_> that's a bit ugly when you want to test quoting 

[15:39] <moritz_> because one kind of quote is always used up as the delimiter of the program

[15:40] <masak> yes.

[15:40] <masak> in those cases, I cat to a file and run the file

[15:42] *** justatheory left
[15:45] *** Exodist joined
[15:50] *** ruoso_ joined
[15:51] <[particle]> masak: file a bug, if you think it sucks

[15:51] *** justatheory joined
[15:52] <masak> [particle]: good idea.

[15:54] *** fronty joined
[15:54] *** pmurias left
[16:00] <jhorwitz> masak: ping

[16:01] <masak> jhorwitz: pong

[16:02] <jhorwitz> working on getting november running under mod_perl6

[16:02] <masak> cool!

[16:02] <masak> how's it going?

[16:02] <jhorwitz> lots of registry support missing for cgi-emulation, but that shouldn't be too hard to fix

[16:02] <[particle]> jhorwitz++ masak++

[16:03] <jhorwitz> but initial tests show a 10x speedup once the script is loaded the first time

[16:03] <masak> jhorwitz: compared to running from source?

[16:03] <masak> because nowadays we run from PIR, with a 17-fold speedup :)

[16:03] <jhorwitz> compared to running from pure cgi

[16:03] <jhorwitz> ah nice!

[16:03] <jhorwitz> we can run that too.  :)

[16:04] <masak> ah, nice

[16:04] <masak> 17 x 10 = 170 :)

[16:04] <jhorwitz> mod_perl6 is using the pure-perl6 source

[16:04] <[particle]> ummm, wow.

[16:05] <moritz_> but it compiles only for the first request (or the startup), right?

[16:05] <moritz_> so I guess you can't get both speedups 

[16:05] <jhorwitz> correct (for each apache process), then it uses the cached version

[16:05] <jhorwitz> right

[16:05] *** exodist_ joined
[16:05] <jhorwitz> so we're probably seeing the same speedup

[16:06] *** Exodist left
[16:06] <jhorwitz> but it's helping me move ModPerl6::Registry along, so that's good too.  :)

[16:09] *** zamolxes joined
[16:09] <masak> indeed.

[16:10] *** kanru left
[16:12] <masak> what _would_ help performance for november, however, is caching of pages for logged-out users

[16:12] <masak> that 17-fold speedup does make november usable, but caching on top of that is just good sense

[16:13] <masak> but I know nothing about such things, so I don't know how difficult it is to set up

[16:14] <jhorwitz> you can do that with mod_perl6 by keeping a global (per-process) cache

[16:15] <masak> sounds good

[16:15] <masak> how do I flag pages likely to change as such?

[16:16] <masak> or rather, will that caching mechanism be able to discriminate between logged-in and not-logged-in users>

[16:16] <masak> s/>/?/

[16:16] *** Jedai joined
[16:16] <jhorwitz> just declare a hash: "our %CACHED_PAGES" in wiki and keep the parsed pages and metadata in there.  it's up to you to determine when to use it.

[16:17] <TimToady> p6 is supposed to have a PROCESS namespace outside of GLOBAL for such things

[16:17] <TimToady> presuming mod_perl6 uses separate interpreters

[16:18] <jhorwitz> it does, for each apache worker/process

[16:18] <TimToady> then it should probably be %PROCESS::CACHED_PAGES eventually

[16:18] <masak> jhorwitz: looking forward to future collaboration

[16:18] <jhorwitz> threaded environments have pools of interpreters per-process

[16:18] <masak> gotta go eat sushi in the rain now.

[16:18] <jhorwitz> mmmm

[16:18] <masak> yes :)

[16:19] <jhorwitz> enjoy.  :)

[16:19] <masak> I will, thanks :)

[16:19] *** masak left
[16:19] <jhorwitz> particle: can i get $r.method() to work w/o rakudo parsing "method" as a keyword?

[16:21] <TimToady> rakudo: class Hi { method method { say 'hi' }}; Hi.method()

[16:21] <p6eval> rakudo 29834: OUTPUT[hi␤]

[16:21] <TimToady> looks like it works to me

[16:21] <jhorwitz> hm

[16:22] <TimToady> rakudo: class Hi { method method { say 'hi' }}; my $x = Hi; $x.method()

[16:22] <p6eval> rakudo 29834: OUTPUT[hi␤]

[16:23] <jhorwitz> then there's probably some error in my "method" method, cuz i get this: invoke() not implemented in class 'Undef'

[16:23] * jhorwitz investigates

[16:24] *** rindolf left
[16:26] <bennymack-work> is map implemented yet? I can't seem to get it to work.

[16:27] <bennymack-work> rakudo: < foostra􏿽xDFe barstra􏿽xDFe fakestra􏿽xDFe >.map:{ ucfirst $^stra􏿽xDFenname }

[16:27] <p6eval> rakudo 29834: OUTPUT[Statement not terminated properly at line 1, near ":{ ucfirst"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[16:27] <Auzon> rakudo: my @a = <1 2 3 4 5>; @a.map({$_ + 1}).say

[16:27] <p6eval> rakudo 29834: OUTPUT[23456␤]

[16:27] <bennymack-work> rakudo: < foostra􏿽xDFe barstra􏿽xDFe fakestra􏿽xDFe >.map({ ucfirst $^stra􏿽xDFenname }).say

[16:27] <p6eval> rakudo 29834: OUTPUT[Statement not terminated properly at line 1, near "\ufffdenname })"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[16:27] <Auzon> Unicode support on the bot isn't terrific

[16:28] <TimToady> fffd is the "unicode replacement character" iirc

[16:28] <bennymack-work> rakudo: < foo bar fake >.map({ ucfirst $^baz }).say

[16:28] <p6eval> rakudo 29834: OUTPUT[FooBarFake␤]

[16:28] <[particle]> it's probably the colon sytax that's not working

[16:29] <TimToady> rakudo: < foostraße barstraße fakestraße >.map: { ucfirst $^straßenname }

[16:29] <p6eval> rakudo 29834: OUTPUT[error:imcc:syntax error, unexpected USTRINGC, expecting STRINGC ('unicode:"$^stra\x{df}enname"')␤   in file 'EVAL_14' line 27␤Lexical '$^straßenname' not found␤current instr.: '_block19' pc 93 (EVAL_14:34)␤]

[16:30] <TimToady> rakudo: < foostraße barstraße fakestraße >.map :{ ucfirst $^straßenname }

[16:30] <p6eval> rakudo 29834: OUTPUT[Statement not terminated properly at line 1, near ":{ ucfirst"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[16:30] *** meteorjay joined
[16:31] <moritz_> the bot does a double decode or encode somewhere

[16:31] <TimToady> rakudo: < foostrasse barstrasse fakestrasse >.map :{ ucfirst $^strassenname }

[16:31] <p6eval> rakudo 29834: OUTPUT[Statement not terminated properly at line 1, near ":{ ucfirst"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤]

[16:31] <TimToady> rakudo: < foostrasse barstrasse fakestrasse >.map: { ucfirst $^strassenname }

[16:31] <p6eval> rakudo 29834: RESULT[["Foostrasse", "Barstrasse", "Fakestrasse"]]

[16:31] <moritz_> rakudo: say 'ö'

[16:31] <p6eval> rakudo 29834: OUTPUT[ö␤]

[16:31] <moritz_> rakudo: say 'ö'.bytes

[16:31] <p6eval> rakudo 29834: OUTPUT[Method 'bytes' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 21 (EVAL_13:13)␤]

[16:32] <TimToady> well, you have to know the encoding before you can know the bytes

[16:32] *** larsen_ left
[16:32] <TimToady> rakudo: say 'ö'.chars

[16:32] <p6eval> rakudo 29834: OUTPUT[1␤]

[16:33] <TimToady> rakudo: say 'ö'.codes

[16:33] <p6eval> rakudo 29834: OUTPUT[Method 'codes' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 21 (EVAL_13:13)␤]

[16:33] <TimToady> rakudo: say 'ö'.codepoints

[16:33] <p6eval> rakudo 29834: OUTPUT[Method 'codepoints' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 21 (EVAL_13:13)␤]

[16:33] <[particle]> you're not going to get much support from rakudo for those layers yet

[16:34] <moritz_> TimToady: isn't that 'codes'?

[16:34] <moritz_> ah, right

[16:34] <moritz_> well, current .chars is actually .codes

[16:34] <moritz_> I tested that a while ago

[16:35] <jhorwitz> TimToady: "method" problem solved.  it helps to install mod_parrot after recompiling.  ;-)

[16:37] *** pjenvey_ joined
[16:37] *** scrottie joined
[16:38] *** jferrero joined
[16:38] <[particle]> silly programmer

[16:38] <jhorwitz> definitely a PEBKAC moment

[16:43] *** kanru joined
[16:46] <rakudo_svn> r30455 | moritz++ | [rakudo] various small updates to tools/*.pl

[16:46] <rakudo_svn> r30455 | moritz++ |  * progress-graph.pl: configurable output size, less x ticks

[16:46] <rakudo_svn> r30455 | moritz++ |  * test_summary.pl: we don't have #pure markers any more

[16:46] <rakudo_svn> r30455 | moritz++ |  * autounfudge: usage() used to throw a bogus warning. Fixed

[16:49] *** cotto_w0rk is now known as cotto_work

[16:53] *** rhr left
[17:07] *** fronty left
[17:22] *** pmurias joined
[17:22] <pmurias> ruoso_: do we have a TODO?

[17:27] <ruoso_> pmurias: yes... we need to make a draft output of what s1p would generate

[17:28] <ruoso_> basically, initializing a p6opaque object, putting it into the global namespace and adding methods to it...

[17:29] <ruoso_> and we also need the default metaclass instance..

[17:30] *** fronty joined
[17:30] *** fronty is now known as Front_slash

[17:32] *** Myoma joined
[17:33] <ruoso_> I think maybe the first step would be to implement a pure prototype metaclass instance

[17:33] <ruoso_> then the default Perl 6 metaclass could be implemented in s1p using the pure prototype metaclass

[17:42] *** armagad joined
[17:42] *** armagad left
[17:49] *** clintongormley left
[17:54] <pmurias> i think a metaclass which would take the dispatch method as a closure, and did nothing else should be enough to bootstrap the metamodel

[17:54] <pmurias> ruoso_: i thought more of a TODO file

[18:01] *** rindolf joined
[18:01] *** hercynium left
[18:07] <ruoso_> pmurias: that should be the ROADMAP in the wiki

[18:09] <ruoso_> which should be updated...

[18:15] <pugs_svn> r22013 | lwall++ | [Cursor] more speed tweaks

[18:19] <pugs_svn> r22014 | lwall++ | [Cursor] another speed tweak.  Now compiles STD.pm in <30sec if cache is precomputed

[18:21] <ruoso_> pmurias: I tried to update the ROADMAP in the wiki... it now looks like what I think that should happen in the near future...

[18:31] *** Front_slash left
[18:36] *** larsen_ joined
[18:40] *** rhr joined
[18:40] *** luqui joined
[18:48] *** scrottie left
[19:02] *** Auzon left
[19:02] *** Auzon joined
[19:13] <TimToady> ruoso_: methods that are part of a public interface need to have names that are not operationally defined, so that the user can name the appropriate documentation without running the program, among other things.

[19:14] <TimToady> so all declarations default to "our"; you can always say "my method" if you don't want to advertise the name

[19:16] *** ruoso_ left
[19:16] *** ruoso_ joined
[19:18] *** pjenvey_ left
[19:18] <ruoso_> TimToady: so method time would need to be declared as my?

[19:18] <ruoso_> because time is a global routine...

[19:18] <ruoso_> but my method makes it really private

[19:18] <ruoso_> in the OO sense... not just in the lexical scope sense... doesn't it?

[19:19] <ruoso_> so... how do I have a public method time that doesn't clash with the global time sub?

[19:20] <ruoso_> and, most importantly... which use cases is this provisioning?

[19:20] <TimToady> there's no conflict, because the sub dispatcher will never call any method

[19:21] <ruoso_> but if the method is exposed as a sub in that package?

[19:21] <TimToady> time() always means the sub, not the method

[19:21] <TimToady> it's still just a method

[19:21] <TimToady> and the dispatcher knows that

[19:22] <TimToady> the only way to call method time as a sub is to say &time()

[19:22] <ruoso_> hm... so it basically is aliased in the package for the dispatcher to ignore it?

[19:22] <ruoso_> hmm..

[19:22] <TimToady> which is what the method dispatcher does to call methods without calling the dispatcher recursively

[19:23] <ruoso_> hmmm

[19:23] <ruoso_> alright... I think that's the point...

[19:23] <ruoso_> the method dispatcher doesn't need to look into the Package to find the methods

[19:23] <ruoso_> the methods are stored in the prototype...

[19:24] *** sri_work joined
[19:24] <TimToady> the package names are just convenient aliases for talking about the methods globally

[19:25] <ruoso_> hm...

[19:25] <ruoso_> I was really thinking on Packages and Classes as completely different things

[19:25] <ruoso_> a Class happens to be declared in a Package

[19:25] <TimToady> but $routine() doesn't care whether the code ref was generated via &name or $obj->getmethod

[19:25] <ruoso_> but it might even have parts declared in different packages

[19:26] <ruoso_> yes... but why do you need to find a method as a sub?

[19:27] <ruoso_> considering the method won't ever be used as a sub

[19:27] <ruoso_> and that the sub dispatcher will have to ignore it

[19:27] <ruoso_> and also considering the HOW is supposed to get you that same routine object

[19:28] <TimToady> the sub dispatcher knows the scope of its names at compile time, and a scope that contains method foo cannot contain sub foo

[19:28] <TimToady> the dispatcher uses the method as a sub

[19:29] <ruoso_> "a scope that contains method foo cannot contain sub foo"... any particular reason? considering sub and method dispatch are very much unrelated?

[19:29] <TimToady> the method dispatcher use the method as a sub

[19:29] <TimToady> *uses

[19:29] <ruoso_> isn't the HOW supposed to decide that?

[19:29] <TimToady> yes, to avoid confusion, and to unify the Code namespace for documentation purposes

[19:30] <ruoso_> I mean.. it doesn't need to look for the method as a sub in the package

[19:30] <ruoso_> it can use the HOW to look in the class

[19:30] <ruoso_> and then call .() later

[19:30] <TimToady> I just said that .() doesn't care whether you look the method up in the package or not

[19:31] <TimToady> a code ref is a code ref

[19:31] <ruoso_> sure sure... I'm not arguing on that point

[19:31] <ruoso_> my point is about having the method aliased in the Package

[19:31] <TimToady> and that point is?

[19:32] <ruoso_> the method can be stored in the prototype or metaclass instance.. (depending if it is prototype or class based)

[19:32] <TimToady> certainly

[19:34] <ruoso_> adding an alias in the Package only to make the sub dispatcher to ignore it seems strange

[19:34] <ruoso_> that was my first question, actually

[19:34] <ruoso_> what is the use case for that alias?

[19:34] <ruoso_> considering you can search it using the HOW

[19:34] <ruoso_> considering that's actually the expected way for you to find it

[19:34] <TimToady> ruoso_: methods that are part of a public interface need to have names that are not operationally defined, so that the user can name the appropriate documentation without running the program, among other things.

[19:35] <TimToady> so all declarations default to "our"; you can always say "my method" if you don't want to advertise the name

[19:35] <ruoso_> alright... but that's another issue.. 

[19:36] <TimToady> "another issue" is the reason for the alias

[19:36] <TimToady> and I already explained that the sub dispatcher can ignore it at compile time

[19:36] <TimToady> it's never in the list of candidates

[19:37] <ruoso_> I don't get it...

[19:38] <TimToady> something has to generate the list of multi candidates; that something knows at compile time which scopes might produce candidates and which can't

[19:38] <ruoso_> I don't get it...

[19:38] <ruoso_> I mean... we can have the checking to avoid "operationally defined" names in methods without aliases in the packages

[19:41] *** sri_work left
[19:41] *** sri_work joined
[19:41] <ruoso_> alright... I still don't get why it need to be aliased in the Package... but if 'method time' doesn't generate clashing, it means that it should be ok to ignore it for now...

[19:43] <TimToady> lunch &

[20:02] <gaal> audreyt: so, what's needed to finally switch over to newVal?

[20:05] <gaal> TimToady: do gimme5 and friends need to use /usr/local/bin/perl instead of /usr/bin/perl?

[20:05] *** jhorwitz left
[20:05] <moritz_> gaal: many people don't have a perl 5.10 in /usr/bin/perl

[20:05] <moritz_> gaal: I just created a symlink to the normal perl

[20:06] <ruoso_> pmurias: m0ld is not accepting "^!methods" as an identifier...

[20:06] * ruoso_ trying to see if he can fix it... but with no much hope...

[20:13] * ruoso_ should have more hope in the future.. considering he was able to actually fix it ;)

[20:13] <gaal> parsec is fun

[20:14] <pugs_svn> r22015 | ruoso++ | [smop] SMOP__S1P__PurePrototypeHow implements a dispatch that .^!methods.{name}.($actualcapture)

[20:14] <gaal> moritz_: d'oh

[20:16] <ruoso_> interesting that as we get at a higher level in smop (using more and more m0ld code), it's starting to be very easy to implement things... and almost no segfaults are produced...

[20:18] *** larsen_ left
[20:19] <gaal> what are valid twigils in mold?

[20:20] <ruoso_> gaal: I don't think you have many... if any...

[20:20] <ruoso_> even $*OUT is being fetched manually in some tests...

[20:20] <pmurias> gaal: there is no point in having twigil in mold

[20:20] <pmurias> * twigils

[20:21] <pmurias> as there are no variables only registers

[20:21] <gaal> you just added ^ because it was one, no?

[20:21] <pmurias> ruoso_: why did you need ^ as part of identifiers?

[20:21] <ruoso_> .^!methods

[20:21] <ruoso_> gaal: it's not a twigil... it's part of the identifiers...

[20:22] <pmurias> it's ."^!method"

[20:22] <pmurias> the identifier rule is only used for registers and labels

[20:22] <ruoso_> yes yes... that's how it is in the code

[20:23] <gaal> are identifiers really required to be longer than one character?

[20:23] <ruoso_> but it was failing before I modify the rule

[20:24] <gaal> pmurias: can you remind me how to run the unittest please?

[20:25] <ruoso_> pmurias: I think a m0ld "return" operator would be usefull... there's a small chunck of m0ld code that is starting to appear everywhere...

[20:25] <ruoso_> pmurias: take a look at the last lines of the m0ld block in smop_s1p_pureprototypehow.sm0p

[20:26] <pmurias> gaal: make test, but it requires having ruby1.9 

[20:26] <ruoso_> the good news is that the next point in the ROADMAP is actually producing the draft s1p output...

[20:28] <ruoso_> pmurias: actually, both a return and a leave operator, since mold doesn't automatically falls back to the "back"

[20:29] <pmurias> ruoso_: we could have an $interpreter return method

[20:30] <ruoso_> but the $interpreter is not the one that holds the other continuation

[20:30] <ruoso_> it's the current $frame

[20:30] <ruoso_> oh...

[20:30] <ruoso_> right

[20:30] <ruoso_> the $interpreter would use the "back" method to fetch it... d'oh

[20:31] <gaal> um, why is make test depending on a very new version of yet another build tool, that isn't in the latest ubuntu?

[20:31] <pmurias> gaal: or do you want to just run test/24_mold

[20:32] <gaal> well, the latter for now

[20:32] * ruoso_ packing stuff... should be back later...

[20:32] <pmurias> gaal: you can change the version number in CMakeLists to the one you have and if make test runs commit it

[20:33] <pmurias> what's the version of cmake that you have

[20:33] *** ruoso_ left
[20:34] <gaal> pmurias: 2.4.6

[20:34] <gaal> and I get errors like

[20:34] <gaal> CMake Error: The end of a CMakeLists file was reached with a FOREACH statement that was not closed properly. Within the directory: /home/gaal/src/pugs/v6/smop

[20:34] <pmurias> make;./build/test/24_m0ld.t

[20:36] <pmurias> gaal: after decrementing the version check at the top?

[20:36] <gaal> yes

[20:39] <pmurias> found something which make cause it in cmake changelog

[20:41] <pugs_svn> r22016 | pmurias++ | [mold] reverted ruoso's change to identifier, might have made the CMakeLists work with preivous versions of cmake

[20:41] <gaal> so: does m0ld reject single-letter identifiers on purpose?

[20:41] <pmurias> no

[20:43] <pmurias> gaal: does cmake work now?

[20:43] <pmurias> how do i install an old version of a package in debian?

[20:44] <gaal> pmurias: trying to resolve conflicts, sec

[20:44] <gaal> re: old version, don't remember, think it's something like pkg=the_old_version

[20:45] <pmurias> version 2.4.6 wasn't found in testing

[20:46] *** rdice left
[20:47] <gaal> something fishy is going on in the tree, svk pull is showing lots of conflicts where there are none

[20:48] <pugs_svn> r22017 | gaal++ |  r7317@gaal-lap (orig r19402):  ruoso | 2008-01-10 17:25:23 +0200

[20:48] <pugs_svn> r22017 | gaal++ |  [yap6] last commit before rename

[20:48] <pugs_svn> r22017 | gaal++ |  r7326@gaal-lap (orig r19411):  ruoso | 2008-01-10 18:13:53 +0200

[20:48] <pugs_svn> r22017 | gaal++ |  [yap6] cleaning up yap6 dir, leaving a goodbye note.

[20:48] <pugs_svn> r22017 | gaal++ |  r7332@gaal-lap (orig r19417):  ruoso | 2008-01-10 21:09:40 +0200

[20:48] <pugs_svn> r22017 | gaal++ |  [yap6] updating yap6 goodbye note.

[20:48] <pugs_svn> r22017 | gaal++ |  r7337@gaal-lap (orig r19422):  pmurias | 2008-01-10 21:59:33 +0200

[20:48] <pugs_svn> r22017 | gaal++ |  points to the right directory

[20:48] <gaal> uh what

[20:48] <pmurias> encountered it myself before

[20:49] <pugs_svn> r22018 | pmurias++ | removed the v6/yap6 dir

[20:49] <pmurias> maybe this will help

[20:49] *** donaldh joined
[20:49] <gaal> how did r22017 happen, I didn't commit anything

[20:50] <pmurias> svk bugs

[20:51] <pmurias> had exactly the same problem when i used svk

[20:54] <gaal> somehow my svk replayed some old commits, and broke the tree. I can't pull the last r.

[20:56] <pmurias> it can be circumvented somehow, don't remember how i did it, but my svk kept reporting fake conficts

[20:57] <gaal> well, I know how to skip an r in svk, but my client's still broken now :/

[20:57] <gaal> svk sy -s r22017

[20:57] <gaal> or rather, r22018

[20:59] <gaal> argh, enough computers for today!

[21:01] *** elmex left
[21:03] *** thepler left
[21:04] *** meppl left
[21:05] <pmurias> shower&

[21:08] *** exodist_ left
[21:40] *** rindolf left
[21:43] *** larsen_ joined
[22:01] *** pmurias left
[22:33] *** meppl joined
[22:35] <pugs_svn> r22019 | moritz++ | [t/spec] add basic tests for slurpy parameters

[22:38] *** explorer__ joined
[22:38] *** jferrero left
[22:38] *** explorer__ is now known as jferrero

[22:41] *** preflex left
[22:43] *** preflex joined
[22:56] *** preflex left
[22:58] *** meppl left
[22:59] *** meppl joined
[23:01] *** donaldh left
[23:03] *** BinGOs left
[23:08] *** preflex joined
[23:08] *** BinGOs_ joined
[23:27] *** preflex left
[23:28] *** preflex joined
[23:44] *** BinGOs joined
[23:47] *** BinGOs_ left
[23:49] *** alester left
[23:49] *** Schwern left
[23:49] *** sri_work left
[23:49] *** IRSeekBot left
[23:49] *** lisppaste3 left
[23:49] *** PerlJam left
[23:49] *** szbalint left
[23:49] *** nnunley left
[23:49] *** Arathorn left
[23:49] *** beppu left
[23:49] *** yahooooo left
[23:49] *** clkao left
[23:49] *** revdiablo left
[23:49] *** sunnavy left
[23:49] *** silug left
[23:49] *** obra left
[23:49] *** rakudo_svn left
[23:49] *** simcop2387 left
[23:49] *** [particle] left
[23:49] *** hcchien left
[23:49] *** c1sung_ left
[23:49] *** stef_ left
[23:49] *** Lunchy left
[23:49] *** bbkr left
[23:49] *** pjcj_ left
[23:49] *** pugs_svn left
[23:49] *** lumi left
[23:49] *** baest left
[23:49] *** buubot left
[23:49] *** sri_work joined
[23:49] *** alester joined
[23:49] *** rakudo_svn joined
[23:49] *** IRSeekBot joined
[23:49] *** simcop2387 joined
[23:49] *** Schwern joined
[23:49] *** [particle] joined
[23:49] *** lisppaste3 joined
[23:49] *** hcchien joined
[23:49] *** c1sung_ joined
[23:49] *** stef_ joined
[23:49] *** pugs_svn joined
[23:49] *** pjcj_ joined
[23:49] *** Arathorn joined
[23:49] *** revdiablo joined
[23:49] *** baest joined
[23:49] *** obra joined
[23:49] *** clkao joined
[23:49] *** sunnavy joined
[23:49] *** bbkr joined
[23:49] *** buubot joined
[23:49] *** Lunchy joined
[23:49] *** lumi joined
[23:49] *** beppu joined
[23:49] *** silug joined
[23:49] *** yahooooo joined
[23:49] *** PerlJam joined
[23:49] *** szbalint joined
[23:49] *** nnunley joined
[23:50] *** Schwern left
[23:50] *** alester left
[23:50] *** szbalint left
[23:50] *** revdiablo left
[23:50] *** Arathorn left
[23:50] *** yahooooo left
[23:50] *** PerlJam left
[23:50] *** beppu left
[23:50] *** nnunley left
[23:50] *** sunnavy left
[23:50] *** clkao left
[23:50] *** silug left
[23:50] *** obra left
[23:50] *** lisppaste3 left
[23:50] *** IRSeekBot left
[23:50] *** sri_work left
[23:50] *** lumi left
[23:50] *** bbkr left
[23:50] *** baest left
[23:50] *** pugs_svn left
[23:50] *** [particle] left
[23:50] *** rakudo_svn left
[23:50] *** pjcj_ left
[23:50] *** c1sung_ left
[23:50] *** stef_ left
[23:50] *** hcchien left
[23:50] *** Lunchy left
[23:51] *** buubot left
[23:51] *** simcop2387 left
[23:51] *** [particle]1 joined
[23:51] *** sri_work joined
[23:51] *** alester joined
[23:51] *** rakudo_svn joined
[23:51] *** IRSeekBot joined
[23:51] *** simcop2387 joined
[23:51] *** Schwern joined
[23:51] *** lisppaste3 joined
[23:51] *** hcchien joined
[23:51] *** c1sung_ joined
[23:51] *** stef_ joined
[23:51] *** pugs_svn joined
[23:51] *** pjcj_ joined
[23:51] *** Arathorn joined
[23:51] *** revdiablo joined
[23:51] *** baest joined
[23:51] *** obra joined
[23:51] *** clkao joined
[23:51] *** sunnavy joined
[23:51] *** bbkr joined
[23:51] *** buubot joined
[23:51] *** Lunchy joined
[23:51] *** lumi joined
[23:51] *** beppu joined
[23:51] *** silug joined
[23:51] *** yahooooo joined
[23:51] *** PerlJam joined
[23:51] *** szbalint joined
[23:51] *** nnunley joined
[23:51] *** orafu left
[23:52] *** OuLouFu joined
[23:55] *** smtms left
[23:55] *** smtms joined
