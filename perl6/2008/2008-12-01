[00:00] *** dduncan left
[00:07] <pugs_svn> r24123 | hinrik++ | [util/perl6.vim] more types and functions, and a few operator fixes

[00:07] *** ruoso joined
[00:09] *** Khisanth left
[00:11] *** dr_df0 left
[00:11] *** cdavaz left
[00:19] <literal> is there a name for keywords like is, but, does, trusts, of, returns ?

[00:20] <literal> constraints, maybe

[00:23] <masak> literal: very difficult to ack the specs for an answer to that question. :)

[00:41] *** Khisanth joined
[00:50] *** alc joined
[00:50] *** kst````` left
[00:51] *** kst````` joined
[00:52] <masak> literal: you might want to check what they're called in STD

[00:52] <literal> maybe

[00:56] *** xuser joined
[00:56] <masak> literal: at least 'is', 'does', and 'will' are called "trait auxiliary" in STD

[00:58] <literal> hm yeah, but that's narrower than what I was looking for, since it doesn't cover the other stuff like "but", "returns"

[00:58] <literal> the name isn't crucial, I'm just wondering what I should call them in perl6.vim

[00:59] <literal> TypeConstraint or something will do

[00:59] <masak> literal: ok.

[00:59] <thei0s> literal: are you doing a perl6 vim colouring plugin?

[00:59] <masak> returns is called a "trait verb", and "but" is an infix operator.

[01:00] <literal> thei0s: I'm editing the one that's in the pugs repository (util/perl6.vim)

[01:00] <thei0s> good to know it exists :)

[01:01] <literal> masak: yeah, but one might argue that they all place constraints on something, and vim's syntax groups aren't very broad so that definition is narrow enough

[01:01] <literal> er, aren't very narrow, I meant to say

[01:04] *** mncharity joined
[01:11] *** Limbic_Region left
[01:20] *** FurnaceBoy joined
[01:25] *** FurnaceBoy left
[01:27] *** ChrisDavaz joined
[01:40] *** apeiron left
[01:40] *** apeiron joined
[01:45] *** alester joined
[01:52] <literal> perl6: my @l = <asdf\>asdf>; print @l.perl

[01:52] <p6eval> elf 24123: OUTPUT[Parse error in: /tmp/OpBx7GOITs␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: my @l = <asdf\>asdf>; print @l␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[01:52] <p6eval> ..STD_r...

[01:52] <p6eval> ..pugs: OUTPUT[\("asdf>asdf",)]

[01:52] <p6eval> ..rakudo 33391: OUTPUT[["asdf>asdf"]]

[01:54] *** apeiron left
[01:55] <literal> perl6: my @l = <<asdf>asdf>>; print @l.perl

[01:55] <p6eval> pugs: OUTPUT[\("asdf>asdf",)]

[01:55] <p6eval> ..rakudo 33391: OUTPUT[["asdf>asdf"]]

[01:55] <p6eval> ..elf 24123: OUTPUT[["a"]]

[01:55] <literal> perl6: my @l = <<asdf>\>asdf>>; print @l.perl

[01:55] <p6eval> rakudo 33391: OUTPUT[["asdf>>asdf"]]

[01:55] <p6eval> ..pugs: OUTPUT[\("asdf>>asdf",)]

[01:55] <p6eval> ..elf 24123: OUTPUT[["a"]]

[01:55] <mncharity> I repeatedly manage to forget what a bleeping monster STD.pm is.  It's comparable in size to the rest of elf combined.  Boy this is going to be a lot of work.

[02:02] *** ChrisDavaz left
[02:02] *** apeiron joined
[02:12] <masak> mncharity++

[02:13] <thei0s> can somebody tell me if this example http://svn.perl.org/perl6/pugs/trunk/examples/functional/unique.pl is correct according to the newest specification? because I needed to modify it to get it working with pugs 6.2.13 (modification: all function calls with array as parameters should be: |@xs, I also replaced in all parameters *$ with just $ (I don't get it what is the point of having multiple variadic/slurpy arguments??))

[02:13] <lambdabot> http://tinyurl.com/5jlp5s

[02:15] <mncharity>  /me++ ?

[02:15] <pugs_svn> r24124 | putter++ | STD_blue now parses and dumps STD.pm.

[02:15] <pugs_svn> r24124 | putter++ | [STD_blue] sym bugfix.

[02:15] <pugs_svn> r24124 | putter++ | [STD_green] Simplify STD.pm parse caching.

[02:15] <mncharity> for being daunted?  I'm daunted by things all the time... ;)

[02:15] <masak> mncharity: for doing what you're doing with Elf.

[02:15] <mncharity> :)

[02:16] <mncharity> sigh

[02:16] *** ChrisDavaz joined
[02:16] <mncharity> thei0s: sorry, for myself, I'm way behind on what's valid and not.

[02:17] <masak> thei0s: I'm stumped too. looks right, though.

[02:17] <mncharity> thei0s: actually, there's a bug in the question,

[02:18] <mncharity> "correct according to the newest specification" and "get it working with pugs" are likely to be mutually exclusive.  pugs stopped tracking the spec some years ago.

[02:18] <masak> nod.

[02:30] *** ChrisDavaz left
[02:34] *** ChrisDavaz joined
[02:43] *** kst````` left
[02:43] *** kst`````` joined
[02:45] <mncharity> ok, end of day.

[02:46] *** apeiron left
[02:47] *** apeiron joined
[02:48] *** justatheory joined
[02:57] <pugs_svn> r24125 | hinrik++ | [util/perl6.vim] highlight block labels and =<>, fix multiline <>, add more keywords, and plenty of other improvements

[03:00] <mncharity> good night all &

[03:00] <pugs_svn> r24126 | putter++ | [elf_h] Flesh out RegexDef node somewhat.

[03:00] <rakudo_svn> r33396 | pmichaud++ | [rakudo]: !OUTER doesn't work for bare closures, so refactor implicit lexicals to avoid it.

[03:00] *** mncharity left
[03:05] <literal> perl6: say "asdf { 1 + \} 1 }"

[03:05] <p6eval> elf 24126: OUTPUT[asdf { 1 + \} 1 }␤]

[03:05] <p6eval> ..pugs: OUTPUT[*** ␤    Unexpected "}"␤    at /tmp/TKj8vcO4eC line 1, column 18␤]

[03:05] <p6eval> ..rakudo 33395: OUTPUT[Statement not terminated properly at line 1, near "+ \\} 1 }\""␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[03:05] <literal> perl6: say "asdf { 1 + 1 }"

[03:06] <p6eval> pugs, rakudo 33395: OUTPUT[asdf 2␤]

[03:06] <p6eval> ..elf 24126: OUTPUT[asdf { 1 + 1 }␤]

[03:07] <literal> perl6: sub hi { 'ho' }; say "asdf &hi"

[03:07] <p6eval> elf 24126, pugs, rakudo 33395: OUTPUT[asdf &hi␤]

[03:08] <masak> rakudo: say "{ "1 + } 1" }"

[03:08] <p6eval> rakudo 33395: OUTPUT[1 + } 1␤]

[03:09] <masak> rakudo: say "{ "{ "{ 1 }" }" }"

[03:09] <p6eval> rakudo 33395: OUTPUT[1␤]

[03:19] <pugs_svn> r24127 | putter++ | [STD_blue] 'token x { a }' -> IR.

[03:21] *** Psyche^ joined
[03:22] *** ChrisDavaz left
[03:23] *** Patterner left
[03:23] *** Psyche^ is now known as Patterner

[03:37] *** justatheory left
[03:41] *** [particle]1 joined
[03:50] <rakudo_svn> r33397 | pmichaud++ | [rakudo]:  Clean up handling of implicit lexicals a bit.

[03:50] <rakudo_svn> r33398 | pmichaud++ | [rakudo]: Add :g(lobal) flag to .subst( $regex, $repl )

[03:54] *** [particle] left
[03:57] *** alester left
[03:59] <pugs_svn> r24128 | hinrik++ | [util/perl6.vim] highlight escaped delimiters in certain single-quoted strings

[04:18] *** alester joined
[04:20] <rakudo_svn> r33399 | pmichaud++ | [rakudo]:  Add :g(lobal) flag to .subst($str, $repl)

[04:22] *** stephens left
[04:28] *** masak left
[04:38] *** slavik`lap joined
[04:40] <rakudo_svn> r33400 | pmichaud++ | [rakudo]:  Oops!  Fix :global on .subst( $regex, $str )

[04:57] *** kst`````` left
[04:58] *** kst`````` joined
[05:01] *** kst`````` left
[05:45] <slavik`lap> rakudo: my @list = 1..inf;

[05:45] <p6eval> rakudo 33408: OUTPUT[Could not find non-existent sub inf␤current instr.: '_block11' pc 22 (EVAL_14:17)␤]

[05:46] <slavik`lap> rakudo: my @list = 1..inf; @list[5]=42; for 1..10 { say @list[$_]; }

[05:46] <p6eval> rakudo 33408: OUTPUT[Could not find non-existent sub inf␤current instr.: '_block11' pc 22 (EVAL_15:17)␤]

[05:46] <slavik`lap> no lazy list?

[05:48] <slavik`lap> pugs: my @list = 1..inf; @list[5]=42; for 1..10 { say @list[$_]; }

[05:48] <p6eval> pugs: OUTPUT[*** No such subroutine: "&inf"␤    at /tmp/K7SYFT2uCI line 1, column 12-18␤]

[05:48] <thei0s> shouldn't inf be written as Inf ?

[05:48] <slavik`lap> rakudo: my @list = 1..Inf; @list[5]=42; for 1..10 { say @list[$_]; }

[05:48] <p6eval> rakudo 33408: OUTPUT[Use of uninitialized value␤Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤42␤Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized value␤␤Use of uninitialized

[05:48] <p6eval> ..value␤␤]

[05:48] *** ChrisDavaz joined
[05:48] <slavik`lap> heh

[05:50] <slavik`lap> rakudo: my @list = 1..Inf; @list[2]=42; for 0..4 { say @list[$_]; }

[05:50] <p6eval> rakudo 33408: OUTPUT[Use of uninitialized value␤Use of uninitialized value␤␤Use of uninitialized value␤␤42␤Use of uninitialized value␤␤Use of uninitialized value␤␤]

[05:50] <slavik`lap> pugs: my @list = 1..Inf; @list[2]=42; for 0..4 { say @list[$_]; }

[05:51] <slavik`lap> hmm

[05:51] <slavik`lap> pugs: say "hello"

[05:51] <p6eval> pugs: No output (you need to produce output to STDOUT)

[05:51] <p6eval> pugs: OUTPUT[hello␤]

[05:51] <slavik`lap> pugs: my @list = 1..Inf; @list[2]=42; for 0..4 -> $a { say @list[$a]; }

[05:52] <slavik`lap> rakudo: my @list = 1..Inf; @list[2]=42; for 0..4 -> $a { say @list[$a]; }

[05:52] <p6eval> pugs: No output (you need to produce output to STDOUT)

[05:52] <p6eval> rakudo 33408: OUTPUT[Use of uninitialized value␤Use of uninitialized value␤␤Use of uninitialized value␤␤42␤Use of uninitialized value␤␤Use of uninitialized value␤␤]

[05:52] <slavik`lap> interesting

[05:53] *** iblechbot joined
[06:03] *** kane_ joined
[06:14] *** iblechbot left
[06:32] *** masak joined
[06:35] *** ashizawa joined
[06:49] *** slavik`lap left
[06:55] *** alester left
[07:01] *** sri_kraih_ left
[07:09] *** DemoFreak joined
[07:19] *** IRSeekBot joined
[07:26] *** elmex joined
[07:31] *** adc_penner joined
[07:36] *** jferrero joined
[07:51] *** justatheory joined
[07:58] *** apeiron_ joined
[08:01] *** apeiron left
[08:02] *** apeiron_ is now known as apeiron

[08:11] *** pbuetow joined
[08:14] *** justatheory left
[08:21] *** adc_penner2 joined
[08:24] *** adc_penner left
[08:25] *** iblechbot joined
[08:36] *** adc_penner2 left
[08:37] *** jjore left
[08:37] *** pbuetow left
[08:42] *** mtrimpe left
[08:43] *** mtrimpe joined
[08:44] *** smg left
[09:00] <thei0s> I was wondering if something like "my $file = open 'largefile.txt', :r; for =$file -> $line { say $line; }" would use more and more memory as the file gets read or will it discard previously read lines from memory? (imagine largefile.txt with size >1GB) (if yes, would it then be better to use sth like: while(!$file.eof) { $_= =$file; ... } ?)

[09:02] <masak> thei0s: assuming you don't store away old lines, they should go out of scope and be garbage collected.

[09:03] <masak> (regardless of the actual looping construct)

[09:08] <thei0s> ql

[09:08] <thei0s> is it possible to have classes in classes? or classes in blocks?

[09:08] <thei0s> (just curious)

[09:08] <masak> thei0s: possible, but right not more useful than having them outside.

[09:09] <thei0s> nice

[09:09] <masak> one of those less specced things.

[09:09] <masak> s/right not/right now no/

[09:10] *** yahooooo left
[09:12] *** justatheory joined
[09:31] *** ejs joined
[09:35] *** salmonix joined
[09:35] <salmonix> Hi there, curious about Perl6 what should I try? Pugs or Rakudo/Parrot?

[09:36] *** jjore joined
[09:36] <masak> salmonix: I'd say Rakudo, since Pugs development has been stalled for a year or so.

[09:36] <masak> whereas Rakudo is progressing by leaps and bounds.

[09:39] <salmonix> masak: Yes, it was behind my question. Ok., I go for it. One more thing:

[09:40] <salmonix> Do I have to build Parrot AND then build perl6 or perl6 in Languages is enough?

[09:40] <masak> Parrot and then Rakudo.

[09:41] <masak> cd parrot; perl Makefile.PL; make; cd languages/perl6; make perl6

[09:43] <salmonix> masak: Ok. I'm on it. 

[09:43] <masak> best of luck.

[09:44] <salmonix> salmonix: (keeping them Xed.) Thanx.

[09:50] <thei0s> am, I don't know if Rakudo is already the right answer for this, because many things don't work (I tried 5 examples from pugs and nothing worked)

[09:51] <moritz_> rakudo doesn't implement as many features yet as pugs does.

[09:51] <masak> though in some cases it's actually more feature-complete.

[09:51] <masak> moritz_: good morning.

[09:55] <masak> I'd prefer Rakudo over Pugs as a development platform today, because the things Rakudo does implement, it implements closer to the spec of today, and it's being actively developed, so one can talk to the developers about the time frame for upcoming features

[10:00] <masak> audreyt did a fantastic job with Pugs a few years ago, and she has hinted that she'll be coming back to Pugs development. but that hasn't happened yet.

[10:08] *** kane__ joined
[10:08] *** kane_ left
[10:14] *** smg joined
[10:26] *** justatheory left
[10:28] *** riffraff joined
[10:31] <riffraff> hi

[10:32] <moritz_> hi riffraff 

[10:39] *** ruoso left
[10:39] *** yahooooo joined
[10:54] *** ChrisDavaz left
[10:55] *** masak left
[11:16] *** kane_ joined
[11:17] *** kane__ left
[11:23] *** smg left
[11:26] *** alc left
[11:41] *** salmonix left
[11:43] *** vixey joined
[12:01] *** Lorn joined
[12:02] *** DemoFreak left
[12:19] *** pnu left
[12:31] *** rff joined
[12:46] *** riffraff left
[12:49] *** ashizawa left
[12:51] <thei0s> hm, there is just one thing left that I am wondering about from the beginning a couple of days ago when I started learning perl6: why does perl6 use so many new words/keywords/way things are called (some pretty unusual, so it looks there will be need for a dictionary soon) for things that already exist with an established name in other languages or that could be called different so that they would be easily memorizable (eg. command 't

[12:51] <thei0s> (or also in the language itself 'rule' is just 'token' with whitespaces, so why not just 'tokenws' or sth that is easy to remember (also rules from language theory have nothing to do with whitespaces), why classes introduce new keywords like 'has' and 'method' if they are quite similar to 'my'/'our'(with addition to having accessors) and 'sub', I also think that the keyword 'multi' is not needed (the compiler can be smart enough to fi

[12:51] <thei0s> for me all this looks just like a way to confuse people who want to learn perl6 and to make it harder for those who already know perl6 to use something else! in addition these different hard to remember names serve the sustaining of imho bad situation that Larry described somewhere: "When I look at the present situation, what I see is the various scripting communities behaving a lot like neighboring tribes in the jungle, sometimes tra

[12:53] *** smg joined
[12:53] <rff> thei0s, maybe because the thing in perl6 that resembles things in other languages are not exactly like those.. and so having them called the same way would introduce more subtle problems?

[12:53] <moritz_> thei0s: usually all Perl keywords are also English words. 'tokenws' isn't, 'rule' is

[12:54] <moritz_> likewise 'say' is much shorter and better to read than 'println'

[12:54] <thei0s> tokenws -- tokenwhitespace

[12:54] <moritz_> that violates the principle of huffman coding

[12:54] <thei0s> say in good, not criticizing it :)

[12:54] <thei0s> s/in/is/

[12:55] <moritz_> thei0s: btw some of your lines are truncated, see http://irclog.perlgeek.de/perl6/today for what we see

[12:55] <thei0s> but the features are almost same as elsewhere, so why shouldn't they be called similar?

[12:55] <lambdabot> Title: IRC log for #perl6, 2008-12-01

[12:55] <thei0s> (at least similar if not same)

[12:56] <moritz_> if you look at STD.pm you'll see that the use cases for rule ws. token are not that similar, and it makes sense to distinguish these two (IMHO)

[12:57] <thei0s> all lines are truncated, ahh.. I tought freenode had longer lines allowed.. so here is the continuation of the "first line":

[12:58] <thei0s>  (eg. command 'taken' is called 'yield' in python (why the new name?), 'role' is in java just an interface with some implemented methods, @array.elems is usually retrieved with a length method (even in perl5 it is called length(@array)), slurpy arguments are usually called variadic,

[12:58] <thei0s> 'given'/'when' are really a little more than 'switch'/'case' from elsewhere, but imho there is not such a change that would satisfy to force everyone in learning new words, signatures in subroutines are usually called just parameter lists...)

[12:58] <thei0s>  (or also in the language itself 'rule' is just 'token' with whitespaces, so why not just 'tokenws' or sth that is easy to remember (also rules from language theory have nothing to do with whitespaces), why classes introduce new keywords like 'has' and 'method' if

[12:58] <thei0s> they are quite similar to 'my'/'our'(with addition to having accessors) and 'sub', I also think that the keyword 'multi' is not needed (the compiler can be smart enough to figure it out by itself), and many many more... (also a couple of artifact words/ways of calling things from perl5))...

[12:58] <thei0s>  for me all this looks just like a way to confuse people who want to learn perl6 and to make it harder for those who already know perl6 to use something else! in addition these different hard to remember names serve the sustaining of imho bad situation that Larry described somewhere:

[12:58] <thei0s> "When I look at the present situation, what I see is the various scripting communities behaving a lot like neighboring tribes in the jungle, sometimes trading, sometimes warring, but by and large just keeping out of each other's way in complacent isolation."

[12:58] <moritz_> thei0s: gather/take is quite different from yield...

[12:59] <moritz_> thei0s: for one gather/take is dynamically scoped, which yield isn't...

[12:59] <moritz_> thei0s: and gather/take's workflow is determined by the laziness level of the list, whereas yield is strictly lazy

[13:00] <moritz_> the thing with given/when is that, unlike switch/case in other languages, they are not tied together, you can used them separately (where 'switch/case' doesn't make sense, from a linguistic point of view)

[13:01] <thei0s> but does does this really affect the programmer? if he wants to know the details he could check them and see that all "perl-yields" are such and such... but a novince would not distinguish them

[13:02] <moritz_> it does affect the programmer

[13:02] <moritz_> just like 'die' and 'return' are different

[13:02] <thei0s> why not.. you could have case ... just in the middle of the code and know that this is doing ~~ $_ ..

[13:02] <moritz_> (return() unwinds one call stack, die() as many as needed before a try block is found)

[13:06] <moritz_> anyway, I think that it's more confusing if you have multiple concepts of the same name (even if they are similar) than having a separate name of separate things

[13:07] <moritz_> but that's up for personal taste, of course

[13:09] <thei0s> yeah, but this are the toughts that came to my mind when I started learning perl6... new words for similar concepts mean more time to remember them

[13:10] <moritz_> when reading the code? or writing?

[13:11] <thei0s> when reading tutorials, documentation and code

[13:11] <thei0s> :)

[13:11] <moritz_> I do see the downsides of a rich syntax, which is why I started working on a tool that explains syntax that you feed into it

[13:26] *** Lorn_ joined
[13:30] <rakudo_svn> r33419 | pmichaud++ | [rakudo]: spectest-progress.csv update: 227 files, 4689 passing, 10 failing

[13:30] <rakudo_svn> r33419 | pmichaud++ | * 10 failures in S12-methods/multi.t

[13:31] *** Lorn__ joined
[13:33] <moritz_> pugs: say "test"

[13:33] <p6eval> pugs: OUTPUT[test␤]

[13:33] <moritz_> I don't know who unbroke pugs on evalbot, but I praise him/her/it

[13:38] *** Lorn left
[13:39] <pmichaud> thei0s: in each of the cases you cite, there's actually a distinction that is being made that means we can't use the old keyword

[13:39] <pmichaud> thei0s: for example,   'has' isn't at all the same as 'my/our'.

[13:40] <pmichaud> thei0s: given/when isn't the same as switch/case (because 'when' can be used inside of any block, not just 'given/switch', and has different semantics from 'case')

[13:40] <thei0s> yes, but it is similar... a user would know in which context he is and therefore know how it is going to behave

[13:41] <pmichaud> ...which is similar?

[13:41] <thei0s> has and my/our :)

[13:41] <pmichaud> no, they're different.   has is a per-instance variable,  my/our are for the class.

[13:42] <pmichaud> 'has'  means  "every instance has its own attribute like this",   'my/our' are just lexically scoped to the class/package.

[13:44] *** apeiron left
[13:44] <thei0s> so you yre telling me it is possible to do: class A { my $shared; method x($s) { $shared =$s; } method y { return $s } } and then use: my $aa =A.new; my $bb=A.new; $aa.x(10); say $bb.y; -- would print 10? (like a class variable, shared among all instances of this class?)

[13:44] <moritz_> yes, that would work.

[13:45] <pmichaud> I think you meant "return $shared" in method y, but yes -- 'my' declares a class variable.

[13:45] <thei0s> ok, good then

[13:45] <thei0s> i tought my/our can not be used, therefore having a 'has' is just adding complexity

[13:46] <pmichaud> for 'rule' versus 'tokenws' -- this actually goes against what you're advocating;  people writing grammars have long been used to the term "rule", while "tokenws" would be introducing an unfamiliar new word into the lexicon.

[13:46] <pmichaud> my/our in a class definition are really just package variables -- i.e., shared among all methods of the package.

[13:46] <pmichaud> they just define a couple of helpful accessor methods as well.

[13:47] <thei0s> what if token would be replaced by something that contains word rule :)

[13:47] <pmichaud> 'token' is also the standard rule that grammar authors are used to.

[13:47] <moritz_> then it would probably be longer

[13:47] <pmichaud> sorry, standard term

[13:47] <pmichaud> people who write grammars, parsers, and lexers have often used the term 'token' and 'rule' -- these are naturally familiar to them (and so they get used).

[13:48] *** Lorn_ left
[13:49] <thei0s> ok, afaik those who just theoretically write grammars don't distinguish any whitespace sensitive or not sensitive variants of rules..

[13:51] <moritz_> usually a token is a minimal subrule in a lexer, and what it matches is handed to the parser

[13:51] *** alester joined
[13:51] *** iblechbot left
[13:52] <pmichaud> I think one of the things we discovered while creating Perl 6 was that the distinguishing characteristic between what we call "token" and "rule" is their handling of inter-token whitespace.

[13:52] *** alester left
[13:52] <pmichaud> and I mean that in a grammar-author sense, not just a Perl 6 sense

[13:54] <pmichaud> if you ask a (non-Perl 6) grammar author "What is the difference between a 'token' and a 'rule'", the answer would tend to come down to the notion that a 'token' is taken as a unit and we look carefully at each token, while a rule is a sequence of tokens where we expect to allow whitespace

[13:54] <pmichaud> it turns out to be _very_ natural in practice

[13:59] <thei0s> :)

[14:04] *** meppl joined
[14:18] *** justatheory joined
[14:47] *** rindolf joined
[14:47] *** PZt joined
[14:51] *** ruoso joined
[14:53] *** masak joined
[15:00] *** rff left
[15:00] *** ruoso left
[15:05] *** justatheory left
[15:07] *** apeiron joined
[15:10] *** iblechbot joined
[15:11] *** justatheory joined
[15:13] *** eternaleye left
[15:20] *** slavik joined
[15:20] *** pnu joined
[15:30] *** dmq joined
[15:30] *** riffraff joined
[15:31] <riffraff> hi everyone

[15:31] <moritz_> @seen everyone

[15:31] <lambdabot> I haven't seen everyone.

[15:32] <riffraff> eh

[15:32] <riffraff> I was wondering what is the best way to define a type with partial order

[15:32] <moritz_> what's "partial order"?

[15:32] <moritz_> just that there's a < defined somehow?

[15:33] <riffraff> yes

[15:33] <riffraff> but

[15:33] <riffraff> consider the problem of defining a new Color class

[15:33] <riffraff> with only three possiblt instances red, green, blue

[15:34] <moritz_> there's always a "but" :-)

[15:34] <riffraff> shall I define the <=> relation 9 times ?

[15:34] <slavik> riffraff: had that nickname for long?

[15:34] <riffraff> slavik, coupld of years, yes

[15:35] <riffraff> do I remember you someone else? :)

[15:35] <slavik> riffraff: do you work in the IT sector by chance? perhaps in an IT support position?

[15:35] <slavik> riffraff: probably not

[15:35] <moritz_> riffraff: well, in the general case yes. In other cases you can re-used other ops, or exploit symmetries

[15:36] <riffraff> IT support? no, sorry. I am a free lance developer so I think I qualify in the IT sector, though  

[15:36] <moritz_> riffraff: with an enum Color <Red Green Blue>; you inherit infix:<< <=> >>(Int, Int)

[15:36] <riffraff> moritz_, I see thanks

[15:36] <slavik> hmm, nvm then :(

[15:37] <riffraff> ah, I didn't know about this cool enum :)

[15:37] <moritz_> it's buried deep down in S12 I think

[15:38] <riffraff> I will check, thanks

[15:38] *** sri_kraih joined
[15:42] *** ruoso joined
[15:48] *** REPLeffect joined
[16:02] *** Lorn__ is now known as Lorn

[16:05] *** smg left
[16:12] *** spx2 left
[16:13] *** spx2 joined
[16:15] *** jhorwitz joined
[16:21] *** stephens joined
[16:27] *** riffraff left
[16:33] *** sri_kraih_ joined
[16:37] *** Coleoid left
[16:40] *** rindolf left
[16:42] *** rdice joined
[16:46] *** ejs1 joined
[16:48] *** sri_kraih left
[16:49] *** ejs1 left
[16:56] *** ejs left
[17:04] *** alester joined
[17:05] *** ruoso left
[17:16] *** hercynium joined
[17:16] *** Exodist joined
[17:19] *** masak left
[17:23] *** Exodist left
[17:29] *** Exodist joined
[17:36] *** smg joined
[17:37] *** xinming joined
[17:39] *** jferrero left
[18:04] *** alech left
[18:04] *** Lorn_ joined
[18:05] *** ejs joined
[18:22] *** Lorn left
[18:25] *** kane__ joined
[18:25] *** kane_ left
[18:28] *** kane__ left
[18:32] *** Lorn_ is now known as Lorn

[18:37] *** lizsac left
[18:38] *** pbuetow joined
[18:39] *** adc_penner joined
[18:40] *** cognominal left
[18:41] *** lizsac joined
[18:56] *** cognominal joined
[19:00] <rakudo_svn> r33426 | particle++ | [rakudo] convert some PAST::Val(...) calls to constants

[19:00] *** gbacon joined
[19:03] *** alech joined
[19:09] *** Ehtyar joined
[19:10] <rakudo_svn> r33427 | infinoid++ | [CAGE] Remove trailing whitespace.

[19:26] *** pbuetow left
[19:27] *** exodist_ joined
[19:27] *** Exodist left
[19:30] *** Gothmog_ joined
[19:34] *** DemoFreak joined
[19:36] *** FurnaceBoy joined
[19:39] *** pbuetow joined
[19:43] *** OuLouFu joined
[19:44] *** smg left
[19:45] *** smg joined
[19:46] *** araujo left
[20:04] *** alech left
[20:08] *** araujo joined
[20:27] *** justatheory left
[20:31] *** dmq left
[20:36] *** FurnaceBoy left
[20:38] *** lizsac_ joined
[20:38] *** lizsac left
[20:39] *** Gothmog__ joined
[20:39] *** Gothmog_ left
[20:50] <rakudo_svn> r33429 | particle++ | [rakudo] take advantage of parrot's config to make rebase tool more portable

[21:01] *** rdice left
[21:05] *** riffraff joined
[21:07] <riffraff> I think I found a bug in rakudo and I may have a mini patch

[21:07] <riffraff> wrt subset declarations

[21:08] <riffraff> yet, the tests pass, mone pass too, but if I run spectests some of them seem to fail 

[21:08] <riffraff> or maybe not, I cannot understand the output :)

[21:08] <[particle]1> there are some expected failures in spectest for rakudo atm

[21:08] *** [particle]1 is now known as [particle]

[21:09] <riffraff> I see

[21:10] <[particle]> i'm not sure the failures are the same on every platform, though, so i can't tell you precisely which are expected

[21:12] <riffraff> I'm just rerunning the test suite without my patches and I'll compare the outputs

[21:12] <riffraff> at first I did not notice that spectes was a separate target

[21:13] <[particle]> 'make test' runs sanity tests in parrot repo

[21:13] <[particle]> 'make spectest' runs the official test suite from pugs repo

[21:13] <[particle]> only spectest has expected failures

[21:14] <riffraff> yep, I found out now thanks

[21:14] <slavik> failure is not an option!!!

[21:14] <slavik> :)

[21:14] *** Lorn left
[21:16] <riffraff> by the way, how do I handle this? the bug appears when using as a subset guard clause a regex literal

[21:16] <riffraff> apparently rakudo treats it as a block but then the internal machinery fails because a regex is.. mh.. not a block enough

[21:17] <riffraff> now, I haveth fix and my tests, but shall they go in the rakudo tests or in the pugs codebase? 

[21:17] <riffraff> the official spec miss these because they just check for non-regex literals in that position

[21:17] <riffraff> but the failure is most probably impèlementation specific

[21:18] * riffraff feels extremely incompetent

[21:18] <[particle]> submit patch and tests in a message to [email@hidden.address]
[21:19] <[particle]> we'll help you sort it out from there

[21:21] <riffraff> with [PATCH] header?

[21:24] *** alech joined
[21:24] *** Gothmog__ is now known as Gothmog_

[21:25] <[particle]> yes, please

[21:44] *** smg left
[21:46] <pugs_svn> r24129 | hinrik++ | [util/perl6.vim] more comments

[21:47] *** ejs left
[21:52] <riffraff> done

[21:52] <moritz_> rakudo: sub evil(@a is copy) { @a[0] = 8 }; my @b = (1, 2); evil(@b); say @b[0]

[21:52] <p6eval> rakudo 33429: OUTPUT[8␤]

[21:52] <moritz_> bug, or feature?

[21:57] <avar> Bug? the @a param obviously isn't being copied

[21:58] <moritz_> I don't know how deep the copy should go

[21:58] <pmichaud> I don't think is copy is implemented

[21:58] <pmichaud> I know that we still have issues with array parameters.

[21:58] <moritz_> rakudo: sub a($b is copy) { $b = 4 }; my $x = 5; a($x); say $x

[21:58] <p6eval> rakudo 33429: OUTPUT[5␤]

[21:58] <moritz_> it is, for scalars ;-)

[21:59] <pmichaud> well, there ya go.  It's the array parameter problem.

[21:59] <pmichaud> I'm working on arrays now, actually.  :-)

[21:59] <[particle]> hrmm. i've got a grammar problem

[21:59] <moritz_> and I'm turning the test in RT #60976 into a spectest

[22:00] <[particle]> i need to parse '--' as an option terminator for arguments

[22:00] <[particle]> rule arguments { <options>* [ '--' <?before ws> ]? <resources>* }

[22:00] <pmichaud> note that  <?before ws>   is the same as   <?before 'ws'>

[22:00] <[particle]> that's not working as i expect, it doesn't recognize "-- foo" properly

[22:01] <[particle]> ah, i need <?before <ws>> then

[22:01] <pmichaud> ....and it won't find it, because the "rule" will have already eaten any ws.

[22:02] <pmichaud> but why need the <?before at all?

[22:02] <[particle]> --h # invalid option

[22:02] <pmichaud> rule arguments { <options>*  '--'? <resources>* }

[22:02] <[particle]> -- h # end of options, 'h' is a resource

[22:02] <pmichaud> here I'm assuming that '--' doesn't parse as a valid option.

[22:02] <[particle]> correct

[22:03] <pmichaud> rule arguments { <options>*  '--'? <resources>* }    # should work.

[22:03] <[particle]> the only valid options for now are: '-' [ 'h' || '-help' ] 

[22:04] <[particle]> --h parses 'h' as a valid resource

[22:04] <pmichaud> the <options>* doesn't report that as an invalid option?

[22:04] <[particle]> no

[22:04] <pmichaud> ...why not?

[22:05] <[particle]> http://nopaste.snit.ch/14773

[22:06] <pugs_svn> r24130 | moritz++ | [t/spec] test for subset type with `where /regex/', RT #60976

[22:06] *** donaldh joined
[22:06] <pmichaud> shouldn't anything beginning with hyphen be considered an option (if it occurs before any '--')?

[22:08] *** apeiron left
[22:08] *** apeiron joined
[22:09] <moritz_> do you need predictive parsing for the command line options?

[22:10] <pmichaud> there are a couple of issues to be considered

[22:10] <[particle]> i need to differentiate invalid options from valid options

[22:10] <moritz_> you could do that more easily in a second pass

[22:11] <pmichaud> thinking of "command line arguments" as being analogous to "perl 6 arguments", is it possible for positional arguments to be intermixed with named (option) arguments?

[22:11] <pmichaud> myprog.pl a b c --option=foo    # valid ?

[22:11] <[particle]> options can take arguments

[22:11] <pmichaud> or do we say that options _always_ have to precede the non-option arguments?

[22:12] <moritz_> pmichaud: that works for the MAIN sub, I think

[22:12] <[particle]> options always precede non-options in my view

[22:12] <pmichaud> oddly, that's backwards from the way Perl 6 does it.  :-)

[22:12] <pmichaud> where non-options tend to precede options.

[22:12] <moritz_> pmichaud: for 'perl6 --opt1 script --opt2' you'd expect --opt2 to be an optioin to the script, not to the compiler

[22:13] <[particle]> we need to make sure the zones are well defined... what moritz said

[22:13] <pmichaud> moritz_: ...and I don't have an issue with that.  But I'm not sure I agree with the idea that options always precede non-options.

[22:13] <pmichaud> That's certainly not the case for many existing unix commands.

[22:13] <[particle]> sure, ack included

[22:13] <[particle]> it is the case for perl 5

[22:14] <[particle]> and python, java, etc

[22:14] <moritz_> pmichaud: right, it's not enforced unless there's a good reason for it

[22:14] <pmichaud> so I'm not sure that Perl 6 option syntax should enforce it :-)

[22:14] <moritz_> am I too impatient, or is 'make spectest' really slow again?

[22:14] <moritz_> 344 wallclock secs - I'm impatient ;)

[22:14] <pmichaud> moritz_: yes, it's slow.  I'm looking for ways to speed it up again.

[22:15] <pmichaud> I'm looking for "quick to do" ways to speed it up again.

[22:15] <[particle]> my working assumption is: rule arguments { <options>* '--'? <resources>* <rest> }

[22:16] <pmichaud> I'm thinking that --h should fail to parse because it's an invalid option, not because it's an invalid resource.

[22:16] <[particle]> where <rest> is handed off to the resources to deal with

[22:16] <pmichaud> the '--' is just a marker to say "whatever comes after this isn't an option, even if it looks like one".

[22:16] <[particle]> did you see the error?

[22:16] <[particle]> it matches '--'

[22:16] <[particle]> then matches 'h', without a preceding space

[22:17] <pmichaud> you missed my point.

[22:17] <pmichaud> inside of 'options' it should detect that we have something that begins with '-' but isn't '--' nor a valid option.

[22:17] <pmichaud> or, the other way to do this is to have options parse everything beginning with hyphens, but stop when it gets  '--' \s

[22:18] <pmichaud> i.e., it's the <options> rule that should detect that we have an invalid option, not the <resources> rule.

[22:18] <pmichaud> because we say that "--h" is an invalid option, not that it's an invalid resource.

[22:19] <pmichaud> just a sec

[22:20] <[particle]> ok, so that means i need to move '--' parsing inside of options

[22:21] <moritz_> I think you need an assertion somewhere, so that parsing of an invalid option is an error

[22:22] <moritz_> otherwise --foo will allways be parsed as <--><foo>

[22:22] <pmichaud> http://nopaste.snit.ch/14774

[22:22] <pmichaud> another way of looking at it:

[22:23] <pmichaud> http://nopaste.snit.ch/14775

[22:23] <pmichaud> and here we use the {*} to decide if the option we just received is a valid one or not (and panic if it isn't)

[22:23] <pmichaud> that way the options aren't build directly into the grammar

[22:23] <pmichaud> *built

[22:25] <[particle]> pmichaud: agreed, i'll use actions to determine validity

[22:26] <[particle]> i'll extend your examples to include --name options

[22:26] <[particle]> should i be using | rather than || ?

[22:27] <pmichaud> more (incomplete) ideas and thoughts:   http://nopaste.snit.ch/14776

[22:27] <pmichaud> || implies ordering, | implies any order will do.

[22:27] <pmichaud> for this it shouldn't really matter.

[22:28] <pmichaud> However, I'm a wee bit interested to see how this would work in a unix environment, where the arguments are already broken up into parts already.

[22:28] <[particle]> i'm working on the grammar for documentation's sake, not to use in the real world

[22:28] <pmichaud> ah.

[22:29] <[particle]> the way i see it, perl 6 will offer 'services' or 'modes' (more)

[22:29] <[particle]> like, -h, --help, -v --version, will call the 'usage' service/mode

[22:30] <[particle]> these services can be overridden

[22:30] <[particle]> but perl 6 offers a reasonable default

[22:30] <[particle]> so, they'll live in a particular namespace, and have well-defined signatures

[22:31] <pmichaud> will this work with the notion of Perl 6's handling of usage already documented in S06 

[22:31] <pmichaud> ?

[22:32] <[particle]> it should, indeed

[22:32] <pmichaud> okay, was just curious.

[22:32] <[particle]> i may not call it 'usage', as not to get it confused with 'USAGE'

[22:35] *** ruoso joined
[22:35] <[particle]> so, i wanted to key off the service name in the grammar

[22:36] <[particle]> -h {*} #= usage

[22:36] <[particle]> but, i won't do that.

[22:37] <pmichaud> well, if it's primarily for documentation purposes, it might be okay to put the options into the grammar directly.  From an implementation perspective I suspect it'll have to be treated a little differently.

[22:37] <[particle]> i do want this document to compile, so i can test it

[22:38] <[particle]> i'll push the semantic analysis down to actions.pm

[22:38] <ruoso> Hello!

[22:38] <[particle]> hi ruoso

[22:39] <ruoso> [particle], have you seen the proposed S07

[22:39] <ruoso> ?

[22:40] *** donaldh left
[22:40] <[particle]> ruoso: no, i haven't

[22:41] <[particle]> you do mean formats, right?

[22:41] <ruoso> [particle], please consider taking a look... I still haven't started implementing it (besides the concept Perl 6 code I posted to p6-language)

[22:41] <ruoso> [particle], no... S07 has been reassigned to "Iterators and Laziness"

[22:41] *** mncharity joined
[22:41] <[particle]> ah, spec.pugscode.org needs a major update

[22:42] <[particle]> i bet smartlinks.pl needs to be updated as well

[22:42] *** riffraff left
[22:42] <[particle]> maybe even some cron job(s)

[22:42] <ruoso> yeah... it seems to be completely outdated

[22:43] <[particle]> come to think of it, i haven't updated my pugs wc in a while either...

[22:44] <mncharity> http://perlcabal.org/syn/S05.html says it was generated today from r24129...

[22:44] <lambdabot> Title: S05

[22:46] <moritz_> mncharity: is that wrong?

[22:46] <mncharity> != "completely outdated" ...?

[22:46] <moritz_> mncharity: no, "brand new"

[22:46] <moritz_> mncharity: S05 now lives in the pugs repo

[22:47] <moritz_> as do all specs

[22:47] * moritz_ should blog about that one daz

[22:47] <moritz_> s/daz/day/

[22:47] <slavik> hmm, moritz_the link on my blog, outdated?

[22:47] <mncharity>  /me confused, but no matter.  just drive-by-ing a conversation enroute to the office...

[22:47] <ruoso> moritz_, any change spec.pugscode.org to list S07 anytime soon?

[22:47] <mncharity> re blog, neat idea

[22:48] <moritz_> ruoso: you're welcome to hack util/smartlinks.pl ;-)

[22:49] <ruoso> moritz_, ok... if no one does it, I should take it as soon as I have my computer completely set up again

[22:50] <moritz_> ruoso: I took a quick look, but I have now idea where the S07 line in the index comes from

[22:50] <ruoso> well, it's not only the index

[22:51] <moritz_> is docs/feather/syn_index.html a generated file?

[22:51] <ruoso> S07.html is not there as well

[22:58] <meppl> good night

[23:00] *** meppl left
[23:01] <mncharity> g'night meppl

[23:01] <mncharity> hey, STD.pm now has p5 re.  yay.

[23:02] <vixey> p5 re. ?

[23:02] <vixey> what's that

[23:02] *** iblechbot left
[23:02] <moritz_> p5 regular expressions

[23:02] <mncharity> perl5 regexp's (for a while it could only parse p6 regex)

[23:03] <vixey> ahh ok great

[23:04] <pugs_svn> r24131 | moritz++ | [docs] update locations and filenames of S\d\d in syn_index.html

[23:05] <moritz_> please don't tell me that this file isn't actually used... ;)

[23:05] <mncharity> sorry, didn't mean to be obscure.  it just turns out to make my "what's the next step?" choice easier.

[23:07] <mncharity> Does anyone know if gimme5 has been run against any general regex tests in t/ ?

[23:08] *** adc_penner2 joined
[23:08] <mncharity> I'm wondering if it's been tested out as a general engine, vs one which is only known to run STD.pm.

[23:09] <mncharity> TimToady: ^^

[23:11] *** jfredett_ joined
[23:14] *** jfredett left
[23:14] *** smg joined
[23:16] <mncharity> moritz_: was it actually used?

[23:17] <moritz_> mncharity: dunno, we'll find out on next update

[23:17] *** pbuetow left
[23:18] <mncharity> ah, ok.

[23:23] *** adc_penner left
[23:23] <ruoso> moritz_, and when does that take place

[23:23] <ruoso> ?

[23:23] <moritz_> hourly, I think

[23:24] <moritz_> but that doesn't solve the problem that S07.html isn't generated

[23:25] <ruoso> hmm..

[23:31] <pugs_svn> r24132 | moritz++ | [util/smartlinks.pl] add some debugging code

[23:31] *** smg left
[23:32] <mncharity>  /me goes looking for the current syntax for embedding p5 re's in p6 rx's...

[23:34] <mncharity> hmm.  S05 says m:P5// .  but my fuzzy recollection is of being told that had gone away?

[23:34] <mncharity> confuzed.  ah well, proceeding.

[23:34] * moritz_ doesn't recall anything like that

[23:34] <mncharity> danke

[23:34] *** DemoFreak left
[23:34] <moritz_> is there an advantage in saying 'map glob, $path' over just 'glob $path'?

[23:36] <pugs_svn> r24133 | moritz++ | [util/smartlinks.pl] a bit of cleanup

[23:41] <mncharity> dunno

[23:41] *** adc_penner2 left
[23:42] *** IRSeekBot left
[23:42] <moritz_> ruoso: S07.html isn't being created because there's no smartlink to it. D'uh.

[23:43] <ruoso> hmm

[23:44] <pugs_svn> r24134 | moritz++ | [util/smartlinks.pl] workaround: generated S07 although there's no smartlink

[23:44] <pugs_svn> r24134 | moritz++ | for it.

[23:44] *** slavik left
[23:45] *** Limbic_Region joined
[23:46] <moritz_> ruoso: now S07.html exists. Feel free to add it syn_index.html, I'm going to bed now

[23:47] <ruoso> Cool

[23:47] <ruoso> moritz_+=

[23:47] <ruoso> oops

[23:47] <ruoso> moritz_++

[23:50] <ruoso> [particle], you can see S07 now ;)

[23:57] <mncharity> @tell TimToady fyi, m:P5/a/ doesn't have an atom node (unlike m/a/ and m/:P5 a/).  m/:P5(1)a/ and m/:P5()a/ also look odd.  those are just fyi.  More of a problem, m/:P5 a b/ looks like it's parsed as p5 /a b/x rather than /a b/.  m/:P5 a ?b/  too.  Not a blocker, but I'm hoping to pour the p5 re.t through STD_blue at some point.

[23:57] <lambdabot> Consider it noted.

[23:58] <mncharity> irc is making fun of m:P5//  :-P

