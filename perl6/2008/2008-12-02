[00:16] *** vixey left
[00:16] *** Lunchy left
[00:21] *** Lunchy joined
[01:02] *** smg joined
[01:06] *** justatheory joined
[01:19] <pugs_svn> r24135 | putter++ | [elfish/rx_on_re] Setting up to run rx_on_re/t/ through STD_blue.  It doesn't yet run, as elfblue can't yet compile the rx_on_re source files (unlike elf_h).

[01:19] <pugs_svn> r24135 | putter++ | [elfish/STD_blue] elfblue now uses STD_blue for eval(), and is still compiled in a single fast (STD_red-based) step.

[01:23] *** alester_ joined
[01:28] *** mncharity left
[01:46] *** exodist_ left
[02:00] *** justatheory left
[02:12] *** Limbic_Region left
[02:30] *** stephens left
[02:55] *** johnjohn101 joined
[02:55] *** rhr left
[03:00] *** rhr joined
[03:12] *** alc joined
[03:20] *** Psyche^ joined
[03:22] *** Patterner left
[03:22] *** Psyche^ is now known as Patterner

[03:28] *** drbean_ joined
[03:28] *** eternaleye joined
[03:36] *** araujo left
[03:39] *** drbean left
[03:58] *** drbean joined
[04:02] *** araujo joined
[04:02] *** elmex_ joined
[04:05] *** drbean_ left
[04:17] *** elmex left
[04:17] *** elmex_ is now known as elmex

[04:56] *** adc_penner joined
[04:59] *** araujo left
[05:02] *** elmex left
[05:19] *** adc_penner left
[05:28] *** drbean left
[05:32] *** drbean joined
[05:37] *** drbean_ joined
[05:43] *** drbean left
[05:59] *** drbean joined
[06:07] *** drbean_ left
[06:09] *** johnjohn101 left
[06:23] *** justatheory joined
[06:24] <TimToady> @tell mncharity at the moment gimme5's goal is only to support (a) bootstrap and (b) making sure everything in t/ parses somehow; viv was intended to go beyond that

[06:24] <lambdabot> Consider it noted.

[06:33] *** drbean_ joined
[06:34] *** alech left
[06:34] *** alech joined
[06:35] *** alester_ left
[06:46] *** drbean left
[06:56] *** ashizawa joined
[07:12] *** ejs joined
[07:43] *** justatheory left
[07:50] *** ejs left
[07:53] *** mtrimpe left
[07:55] *** pbuetow joined
[07:56] *** masak joined
[08:06] *** iblechbot joined
[08:31] *** ejs joined
[08:33] *** DemoFreak joined
[08:33] *** smallfish joined
[08:34] *** DemoFreak left
[08:36] *** DemoFreak joined
[08:37] *** pbuetow left
[08:42] *** ejs1 joined
[08:42] *** kane_ joined
[08:43] *** [particle] left
[08:51] *** ejs left
[08:54] *** masak left
[09:05] *** vixey joined
[09:18] *** ChrisDavaz joined
[09:19] *** smallfish left
[09:24] *** alc left
[09:29] *** ChrisDavaz left
[09:29] *** ChrisDavaz joined
[10:05] *** [particle] joined
[10:21] *** ruoso left
[10:25] *** ruoso joined
[10:35] *** elmex joined
[10:41] *** justatheory joined
[10:53] *** justatheory left
[11:12] *** donaldh joined
[11:21] *** ChrisDavaz left
[11:32] *** ashizawa left
[11:37] *** iblechbot left
[12:02] *** iblechbot joined
[12:12] *** Lorn joined
[12:30] *** drbean_ left
[12:51] *** DemoFreak left
[13:22] *** smg left
[13:35] *** aindilis left
[13:35] *** aindilis joined
[13:36] *** zamolxes joined
[13:41] *** ruoso left
[14:04] *** masak joined
[14:09] <masak> re Darren Duncan's question on p6l: I don't anticipate that Blob creation through literals will become such a common thing to do, and thus it will not require its own quoting construct or the like. I think a conversion of some sort will do just fine.

[14:10] <masak> couldn't &pack create Blobs, given the right params, for example?

[14:11] *** sjwalters joined
[14:17] *** ruoso joined
[14:17] *** adc_penner joined
[14:17] <PerlJam> masak: well, *humans* certainly won't do it.  But we may write programs that do so, in which case, conversion functions are just fine.

[14:18] <masak> yes.

[14:18] <masak> I'm writing a reply to that effect now.

[14:18] <PerlJam> masak++

[14:18] <ruoso> Hello!

[14:19] <masak> ruoso: saluton!

[14:19] <PerlJam> I remember reading something a while back about the interaction between :nth() and :x(), but I can't find it in S05.  Right now i'm of the opinion that :nth(), :x(), and :global should be mutually exclusive.

[14:19] <PerlJam> any comments?

[14:19] <PerlJam> (or pointers)

[14:19] * masak doesn't think that :nth and :x should be mutually exclusive

[14:21] <PerlJam> masak: so, what should m:nth(3):x(5)/foo/  match?

[14:21] <PerlJam> or, how can you simultaneously match the 3rd thing and 5 times?

[14:22] <masak> the 3rd, 6th, 9th, 12th and 15th foo in a string.

[14:23] <PerlJam> okay,  that's actually what I thought I read in S05 at some point, but I don't see it.

[14:23] <masak> I'm not looking for it, but ISTR I read it too at some point.

[14:32] *** gbacon left
[14:35] *** adc_penner left
[14:36] *** adc_penner joined
[14:37] <ruoso> masak, I've just sent a message to p6-l about the "literal values for types" issue...  basically saying "you won't need that" ;)

[14:38] <masak> good. I agree.

[14:38] *** adc_penner left
[14:39] *** adc_penner joined
[14:40] <rakudo_svn> r33441 | pmichaud++ | [rakudo]: spectest-progress.csv update: 227 files, 4689 passing, 10 failing

[14:40] <rakudo_svn> r33441 | pmichaud++ | Failure summary:

[14:40] <rakudo_svn> r33441 | pmichaud++ |     S12-methods/default-trait.t aborted 6 test(s)

[14:40] <rakudo_svn> r33441 | pmichaud++ |     S12-methods/multi.t aborted 4 test(s)

[14:42] <masak> rakudo: class A { method WHAT { "B" } }; A.new.WHAT.say

[14:42] <p6eval> rakudo 33440: OUTPUT[B‚ê§]

[14:42] * masak cackles evilly

[14:43] <pmichaud> we don't handle .WHAT properly yet.

[14:43] <masak> pmichaud: but that is correct! :)

[14:43] <pmichaud> (p6l literals):  I don't agree with dduncan's premise that there have to be clean/terse mechanisms for every fundamental type.

[14:43] <pmichaud> masak: no, it's actually wrong.

[14:43] <pmichaud> A.new.WHAT.say   # 'A'

[14:43] <masak> pmichaud: re literals: nod

[14:43] <pmichaud> A.new.'WHAT'.say   # 'B'

[14:43] <masak> pmichaud: re WHAT: WHAT? :)

[14:44] <masak> pmichaud: I just redefined .WHAT, shouldn't Perl 6 let me do that?

[14:44] <ruoso> masak, .WHAT is a macro

[14:44] <pmichaud> yes, but to access that method you have to use ."WHAT"

[14:44] <masak> aha.

[14:44] <pmichaud> because... what ruoso said.

[14:45] * masak had forgotten that

[14:45] * masak files rakudobug, then

[14:45] <pmichaud> rakudo currently cheats and treats .WHAT as a normal method call, but that will go away at some point.

[14:45] <pmichaud> I think there's already a rakudobug?

[14:45] <masak> oh.

[14:45] * masak checks

[14:45] <ruoso> pmichaud, are you confortable with the idea of .WHAT returning a canonical type even when the object is implemented by a lowlevel type?

[14:46] <pmichaud> I don't understand "canonical" versus "lowlevel"

[14:46] <ruoso> meaning...

[14:46] <ruoso> [1,2,3].WHAT being "Array" even if it's implemented by LowLevelCompatIntArray

[14:47] <ruoso> *LowLevelCompactIntArray

[14:47] <ruoso> or when that is a really common case...

[14:47] <ruoso> LowLevel123CompactIntArray

[14:47] <ruoso> which is a constatn

[14:47] <pmichaud> as a P6 programmer, I would expect   [1,2,3].WHAT =:=  <1 2 3>.WHAT

[14:47] <ruoso> constant

[14:47] <pmichaud> if that's not true, then it's confusing.

[14:47] <ruoso> pmichaud, wouldn't you prefer to do that test as

[14:48] <ruoso> [1,2,3].WHAT ~~ <1 2 3>.WHAT

[14:48] <pmichaud> or, I should say:   [1,2,3].WHAT =:= [<1 2 3>].WHAT     (since <1 2 3> is actually a List)

[14:48] <pmichaud> I expect two simple arrays to give me the same protoobject in response to .WHAT .

[14:49] <masak> no, there's no such ticket AFAICS

[14:49] <pmichaud> masak: you're correct, no such ticket.

[14:49] * masak files

[14:49] <pmichaud> masak: it's hard for me to remember what's been discussed as an issue versus what's filed as a ticket.  :-)

[14:49] <pmichaud> I knew that there had been some .WHAT tickets filed :-)

[14:49] <masak> that's why we should always file everything.

[14:49] <pmichaud> masak: agreed.  :-)

[14:49] <masak> makes it easier.

[14:50] *** gbacon joined
[14:51] <masak> pmichaud: btw, is there a time frame for user-defined operators in Rakudo?

[14:51] <pmichaud> masak: could be very quick, actually.

[14:51] <masak> neat!

[14:51] <pmichaud> we have most of the pieces in place.

[14:52] <pmichaud> there would be some caveats -- they'd all end up being global.

[14:52] <pmichaud> (until we have full-fledged LTM parsing)

[14:52] *** smg joined
[14:53] <ruoso> pmichaud, in which cases do you expect to do identity check on the return of the .WHAT of different objects?

[14:54] <ruoso> and why isn't '~~' sufficient?

[14:58] <pmichaud> ruoso: I'm simply saying that a Perl 6 programmer expects an Array to be an Array unless we've specifically declared it to be something else.

[14:58] <pmichaud> an implementation can choose to optimize underneath, but to the programmar it should look the same.

[14:58] <pmichaud> *programmer

[14:59] <ruoso> but my point is that while Perl 6 supports strong typing, it's much more abstract than other languages...

[14:59] <ruoso> that meaning that identity type on the return of .WHAT is something that doesn't fit well into the picture

[15:00] <pmichaud> it fits fine in my worldview.

[15:01] *** Exodist joined
[15:01] <pmichaud> I haven't seen anything on p6l or in the spec that contradicts the notion that   .WHAT on any array gives me back the Array protoobject.

[15:01] <pmichaud> I haven't see anything that contradicts what you're saying either, which is why I fall back to "what I expect as a Perl 6 programmer".

[15:01] *** mncharity joined
[15:02] <pmichaud> when/if the spec changes, I'll update my worldview accordingly.

[15:02] <masak> as do we all.

[15:03] <masak> (unless the rare cases when the change is a cause for hitting the streets and rallying against it, of course)

[15:03] <masak> s/unless/except for/

[15:11] <mncharity> TimToady: fyi, STD appears to not parse p5's (?-x)  .   (?i-xi) works, but yuck.

[15:11] <lambdabot> mncharity: You have 2 new messages. '/msg lambdabot @messages' to read them.

[15:13] <mncharity> re gimme5 goal, thanks.

[15:13] *** alester left
[15:14] <pmichaud> here's an example where I would be surprised by .WHAT not preserving identity

[15:14] <pmichaud> sub foo(::T $x, T $y) { ... }

[15:14] <pmichaud> foo([1,2,3], [<1,2,3>])

[15:15] <mncharity> TimToady: err, rephrasing, STD appears to not parse p5's (?-x)  .   (?i-xi) parses, but m/:P5 (?i-xi)a ?b/ still reports the quantifier to a, not space.

[15:17] <pmichaud> sorry:   foo([1,2,3], [<1 2 3>])

[15:17] *** alester joined
[15:19] <pmichaud> afk for a bit

[15:21] <ruoso> pmichaud, (Note that ::T is not required to contain Dog, only a type that is compatible with Dog.)

[15:26] <mncharity> sigh.  system bio talk or hack?   sooo need mobile computes.  it should be talk _and_ hack. :)

[15:30] <mncharity> masak: re third person, now definitely STD bugfixing.

[15:30] <masak> ÂìàÂìà

[15:31] <mncharity> (question was, given a third person, what would I ask them to work on)

[15:31] <masak> nod

[15:31] <mncharity> new question is what is Âìà :)

[15:31] * mncharity googles...

[15:31] <masak> it's Chinese fore "haha"

[15:31] <masak> s/fore/for/

[15:31] <mncharity> ahhhh

[15:31] <masak> I think, if I use it often enough, it will catch on in the western world :)

[15:32] <mncharity> ÂìàÂìà

[15:32] <mncharity> it's like lol, but harder to type. :)

[15:32] <masak> there's something immediately right about using hanzi for onomatopoetic things

[15:33] <masak> mncharity: not that hard to type :) I just write "haha" over here.

[15:33] <mncharity> shudder.  CPAN is going to become a very scary place...

[15:33] <masak> Emacs++

[15:33] <masak> mncharity: how so?

[15:35] <mncharity> re emacs, what input method?  re how so, all the, err, lack of taste in choice and use of language features, will have a new unicode dimension to expand in.

[15:36] <masak> mncharity: the input method (in LEIM) is called chinese-py-punct

[15:36] <masak> mncharity: re lack of taste: as long as people goof off in Acme::, it's fine with me :)

[15:37] <masak> s/in Acme/chiefly in Acme/

[15:37] *** adc_penner left
[15:39] <mncharity> re chinese-py-punct, oooh, that's nifty.

[15:41] <masak> mncharity: indeed. not as nifty as I would like, though.

[15:42] <masak> I'm still on the lookout for the perfect input method, and I already know that a Pinyin-based one isn't it

[15:42] <masak> it doesn't allow me to type hanzi that I don't know how to pronounce

[15:43] <masak> and frankly, that's most of them.

[15:44] *** IRSeekBot joined
[15:48] *** kanru left
[15:51] <pmichaud> ruoso:  how about....?

[15:51] <pmichaud> my $x = [1,2,3];

[15:51] <pmichaud> my $y = [<1 2 3>];

[15:51] <pmichaud> say $y ~~ $x.WHAT;    # do $x and $y have the same type?

[15:52] <ruoso> they have types that are "compatible"

[15:52] <ruoso> so $y ~~ $x.WHAT is true

[15:52] *** kanru joined
[15:53] *** ejs1 left
[15:53] <ruoso> that's why I argue about using '~~' in type checking, and not =:=

[15:53] <pmichaud> so,  Array ~~ LowLevelCompactIntArray, then ?

[15:53] <pmichaud> we do use ~~ in type checking.

[15:54] <pmichaud> your original question then was simply about how protoobjects stringify?

[15:54] <ruoso> the stringification is a side issue

[15:55] <pmichaud> so, Array ~~ LowLevelCompactIntArray, then ?

[15:55] <ruoso> hmm... no..

[15:55] <pmichaud> then $y ~~ $x.WHAT  wouldn't be true, would it?

[15:55] <pmichaud> how about $y.WHAT ~~ $x.WHAT  ?

[15:56] <ruoso> hmm... ok... 

[15:57] <ruoso> it wouldn't be true

[15:58] <ruoso> but...

[15:58] <ruoso> it depends on what you're trying to do with: $y.WHAT ~~ $x.WHAT

[15:58] <ruoso> I mean

[15:59] <ruoso> it sounds wrong if we understand that .WHAT should return "the canonical type"

[15:59] <ruoso> but it sounds right if we understand that .WHAT should return "the actual type"

[15:59] <pmichaud> except there's nothing that tells me that   [1,2,3]   is anything but an Array.

[16:00] <pmichaud> i.e., I expect the type of [...] to be an Array.

[16:00] <ruoso> There's nothing telling it is

[16:00] *** eternaleye left
[16:00] <pmichaud> well, there's lot of stuff that says it's an array

[16:00] <pmichaud> there's nothing that says "there are special types of array"

[16:00] <pmichaud> unlike Hash, where we do have special types of hashes explicitly mentioned

[16:00] <ruoso> pmichaud, er... actually there is...

[16:01] *** adc_penner2 joined
[16:01] <ruoso> http://perlcabal.org/syn/S09.html#Compact_arrays

[16:02] <lambdabot> Title: S09

[16:02] <pmichaud> none of those are using circumfix:<[ ]>

[16:02] <pmichaud> in each of those cases (as far as I can tell) the programmar has explicitly said "I want an array of this type."

[16:02] <pmichaud> so yes, I _would_ expect their types to be different.

[16:02] *** adc_penner2 left
[16:03] <pmichaud> *programmer   # been working on too many grammars lately :-(

[16:03] <pmichaud> so far we've been talking about the case of   [1,2,3], which I see as being the same as  Array(1,2,3)

[16:04] <PerlJam> how does one get a list of available "types" from within perl 6?

[16:05] <ruoso> but... is Array really a class? or is it a Role?

[16:06] *** rindolf joined
[16:06] <moritz_> yes :-) (one of those)

[16:06] <sjwalters> heh

[16:06] <moritz_> ruoso: since roles are auto-generated from classes and vice versa, is that really so important?

[16:06] *** stephens joined
[16:07] <ruoso> it is in the sense that if it's a class it provides an implementation, if it's a role, there's a chance it only documents an API

[16:07] <pmichaud> either way, I expect   [<1 2 3>].WHAT to give me a protoobject

[16:07] <pmichaud> and if I do:

[16:08] <pmichaud> sub foo(::T $x, T $y) {  say  $x.WHAT ~~ $y.WHAT }

[16:08] <pmichaud> foo([1,2,3], [<1 2 3>])

[16:08] <pmichaud> sorry -- got that backwards.

[16:08] <pmichaud> trying again:

[16:09] <pmichaud> sub foo(::T $x, T $y) {  say  $y.WHAT ~~ $x.WHAT }

[16:09] <mncharity> masak:  re pinyin, nod

[16:09] <pmichaud> foo([1,2,3], [<1 2 3>])

[16:09] <pmichaud> I expect to always see "true", because the type constraints have already guaranteed me that $x and $y are of the same "type"

[16:09] <ruoso> pmichaud, of "compatible" types

[16:09] <ruoso> not the same

[16:10] <ruoso> which means that dending on the order you make the ~~

[16:10] <ruoso> it might return true or false

[16:10] <PerlJam> I'm going to guess that there is no way to know what "types" perl6 knows about.

[16:10] <pmichaud> in this case I'm constrained that $y is a "compatible type" with $x.

[16:10] <ruoso> PerlJam, that's a pretty fair assumption

[16:10] <moritz_> ruoso: TimToady answered that question on p6l (with respect to numbers, I think), and his answer was roughly "the implementor may cheat, but the cheat shouldn't be exposed via .WHAT or .HOW", at least not for built-in types

[16:11] <moritz_> I think the thread title was "rakudo test miscellania" 

[16:11] <pugs_svn> r24136 | putter++ | [rx_on_re] Move ast nodes into package IRx1.

[16:13] <pmichaud> how about:

[16:13] <pmichaud> sub foo(::T $x, $y) {   say $y ~~ T; }

[16:13] <PerlJam> ruoso: but wouldn't that be a useful thing?  any(@types) ~~ $thing.WHAT  --> junction of "types" that are "type compatible" with $thing.

[16:13] <pmichaud> foo([1,2,3], <[1 2 3]>);

[16:14] <pmichaud> or even

[16:15] <pmichaud> sub foo(::T $x, $y) {  given ($y) { when T { ... }; ... } }

[16:16] <pmichaud> grrrr.

[16:16] <pmichaud> foo([1,2,3], [<1 2 3>]);

[16:16] <pmichaud> (I'll get this right yet :-)

[16:17] <ruoso> well... if you consider you're not typing ::T, you'll get whatever type $x has

[16:18] <pmichaud> ...not typing ::T ?

[16:18] <ruoso> as in ... (Array ::T $x, $y)

[16:18] <pmichaud> ::T *is* a type.

[16:18] <pmichaud> it's the type of $x

[16:19] <moritz_> speaking of which... since subroutine params are read-only, will sub foo($x) { say $x.WHAT }; foo(<a b c>) print 'List' instead of 'Array'?

[16:19] <ruoso> exactly, the signature is not typing it... $x is

[16:19] <masak> though `Array ::T $x` should be legal syntactically

[16:19] <moritz_> I mean if it's bound read-only, it doesn't have to be autopromoted from List to Array

[16:19] <ruoso> masak, that's an example from the spec

[16:19] <ruoso> except TimToady like Dogs

[16:20] <masak> :)

[16:20] <pmichaud> right, the ::T is declaring  'T' to be a lexical corresponding to the type of $x

[16:20] <ruoso> so the question is whether '$y ~~ $x.WHAT' 

[16:20] <ruoso> or back to

[16:21] <pmichaud> I'm not constraining the type of $x -- I'm just declaring that "whatever type $x is, call that T"

[16:21] <ruoso> [<1 2 3>] ~~ [1,2,3].WHAT

[16:23] <ruoso> and if the signature was

[16:23] <ruoso> :(Array ::T $x, $y)

[16:23] <ruoso> it would only constraint the type of $x to be an Array...

[16:23] <ruoso> but T would still contain the specific type of $x

[16:23] <pmichaud> no

[16:23] <pmichaud> oh, yes.

[16:24] <pmichaud> what you have is correct -- T is the specific type of $x

[16:24] <ruoso> (to be in the sense of $x ~~ Array)

[16:24] <pmichaud> and $x is constrained to be an Array.

[16:24] <pmichaud> and with   :(Array ::T $x, T $y)

[16:24] <pmichaud> $x has to be an Array

[16:24] <pmichaud> $y has to be ~~ T

[16:24] <ruoso> $x has to .^does(Array)

[16:24] <ruoso> and $y has to .^does(T)

[16:25] <pmichaud> yes, that's a good way of saying it.

[16:25] <pmichaud> In Rakudo we do everything in terms of smart match, so

[16:25] <pmichaud> $x ~~ Array

[16:25] <pmichaud> $y ~~ T

[16:25] <pmichaud> where T is the type of $x   (we use $x.WHAT)

[16:25] <ruoso> but you can't say that Array ~~ $x.WHAT

[16:26] <ruoso> you can only say that $x.WHAT ~~ Array

[16:26] <pmichaud> correct.  $x could be a subclass of Array.

[16:26] <ruoso> exactly,

[16:26] <pmichaud> it's not clear to me that   [1,2,3]   should be an instance of a subclass of Array

[16:26] <pmichaud> most p6 programmers would not expect that.

[16:26] <ruoso> that's my point... 

[16:27] <ruoso> and the question whether Array is a class or a Role

[16:27] <pmichaud> we know that Array is a class.

[16:27] <pmichaud> because we can have instances of Array.

[16:28] *** yves joined
[16:28] <pmichaud> but I think the class/role distinction isn't significant in the examples we're looking at.

[16:29] <ruoso> in this specific examples not...

[16:29] <ruoso> and probably the Array type is less subject to such specificics

[16:29] <ruoso> *specifics

[16:29] <ruoso> the List type probably provides us better examples

[16:29] <ruoso> since it's read-only

[16:30] <ruoso> and since it's a value

[16:30] <ruoso> does (1,2,3).WHAT ~~ <1 2 3>.WHAT ?

[16:30] <ruoso> I think it doesn't

[16:31] <ruoso> at least I think it would be sane if it didn't

[16:31] <pmichaud> but very few p6 programmers would expect it to be false.

[16:31] <pmichaud> at least based on current reading of the spec.

[16:31] <pmichaud> how about:

[16:32] <pmichaud> my $x = 1;   ($x, 2, 3).WHAT ~~ <1 2 3>.WHAT  ?

[16:32] <ruoso> the point I'm trying to make is not about the types themselves...

[16:33] <ruoso> but on the assumption about the use of $x.WHAT in type checking

[16:33] <pmichaud> ...this isn't type checking?

[16:34] <ruoso> it is...

[16:35] <ruoso> but what does it mean to ask if: $x.WHAT ~~ $y.WHAT 

[16:35] <ruoso> ?

[16:36] <pmichaud> we're asking if the type of $x does the type of $y

[16:36] <ruoso> so if we assume that (1,2,3) can be of a different type than <1 2 3>

[16:36] <ruoso> which is a pretty fair assumption

[16:37] <pmichaud> I'm saying that's not an assumption a typical p6 programmer would make

[16:37] <ruoso> where both ~~ List

[16:37] <pmichaud> there's _nothing_ in the spec that indicates that (1,2,3) and <1 2 3> produce different types of List.

[16:38] <pmichaud> or that (1,2,3) is a different sort of List from  ("1", "2", "3")

[16:38] <ruoso> I'm aware of that, the spec currently assumes .WHAT should return the canonical type

[16:38] <pmichaud> even without respect to .WHAT

[16:38] <pmichaud> a p6 programmer tends to expect (1,2,3) and ("1", "2", "3")  to return the same kind of List.

[16:39] <pmichaud> such that   ("1", "2", "3") ~~ (1,2,3).WHAT

[16:39] <[particle]> so how do you get the actual implementation type?

[16:39] <moritz_> rakudo: say try { 1 + undef }

[16:39] <p6eval> rakudo 33441: OUTPUT[Use of uninitialized value‚ê§1‚ê§]

[16:40] <[particle]> as opposed to the programmer-friendly type?

[16:40] <ruoso> [particle], there isn't one

[16:40] <ruoso> *way of getting it, I mean

[16:40] <[particle]> yet.

[16:40] <ruoso> in SMOP we have .^!instanceof

[16:40] <ruoso> which returns the actual implementation typye

[16:40] <ruoso> whch might be the object itself

[16:41] <pmichaud> anyway, I have to run some errands.

[16:41] <ruoso> I think it would be very nice if we could relax the spec in the sense to allow the implementation to have specific implementations

[16:41] <pmichaud> you understand my point that the notion of "lowlevel types" being exposed to the programmer leads to some counter-intuitive results for the typical p6 programmer.

[16:41] <ruoso> in a way that

[16:41] <PerlJam> I would expect (1,2,3) to produce a different type of List than 1..3

[16:41] <pmichaud> 1..3 is a Range.

[16:42] <pmichaud> 1..3 is not a List.

[16:42] <ruoso> pmichaud, 1..3 .^does(List) indeed

[16:42] <[particle]> .WHATSWHAT

[16:42] *** sri_kraih joined
[16:42] <PerlJam> let me repharse then  :)

[16:43] <PerlJam> I would expect (1,2,3) to produce a different type of List than  (1,2,=$foo)

[16:43] <pmichaud> 1..3 does List?  are you sure?

[16:43] <[particle]> no, it's Range

[16:43] <ruoso> I think you can do

[16:43] <ruoso> @a = 1..3;

[16:43] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v

[16:43] <ruoso> or even

[16:43] <pmichaud> ruoso: that's 1..3 in list context

[16:43] <pmichaud> @a = 1..3    is the same as   @a = list(1..3)

[16:43] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v

[16:43] <ruoso> List $a = 1..3;

[16:44] <ruoso> but one way or another

[16:45] <moritz_> @shutup :-)

[16:45] <lambdabot> Unknown command, try @list

[16:45] <ruoso> I think it would be nice if the spec was relaxed to allow that (1,2,3).WHAT to be different than <1 2 3>.WHAT

[16:45] <pmichaud> I leave that for TimToady to decide.  Would ($x,2,3).WHAT be different from (1,2,3).WHAT also?

[16:46] <ruoso> probably, since (1,2,3) can be represented as a compact int list

[16:46] <PerlJam> ruoso: Earlier when I was asking about what types that perl6 knows about, I was thinking that you were asking the wrong question :)

[16:46] <PerlJam> ruoso: (1,2,3).WHAT shoudl be the same as <1 2 3>.WHAT, but there should be a way to know all of the "compatible types"

[16:48] <PerlJam> How do we notate "array of string" or "array of int" ?

[16:48] <PerlJam> is that a function of .WHAT?

[16:48] <PerlJam> or something else?

[16:48] <pmichaud> I don't think Range ~~ List.

[16:49] <[particle]> maybe .WHAT returns a capture

[16:49] <ruoso> perl6: my $a = 1..3; say $a[0];

[16:49] <p6eval> elf 24136: OUTPUT[Can't use string ("1E0") as an ARRAY ref while "strict refs" in use at (eval 119) line 4.‚ê§ at ./elf_f line 3861‚ê§]

[16:49] <p6eval> ..rakudo 33442: OUTPUT[get_pmc_keyed() not implemented in class 'Range'‚ê§current instr.: '_block11' pc 67 (EVAL_14:28)‚ê§]

[16:49] <p6eval> ..pugs: OUTPUT[1‚ê§]

[16:49] <moritz_> PerlJam: `my Int @a is Array' says that the container type is Array, and the elements are Ints

[16:49] <[particle]> programmer-friendly name in the scalar slot, array of all compatible types in array and hash slots

[16:49] <pmichaud> pugs is wrong there.

[16:49] <pmichaud> Ranges cannot be subscripted.

[16:49] <[particle]> ah, crap. dentist &

[16:50] <ruoso> pmichaud, they can't?

[16:50] <PerlJam> moritz_: I know that, but how do you ask the object that?

[16:50] <moritz_> PerlJam: sorry, misread your question... dunno

[16:50] <ruoso> moritz_, indeed 'my Int @a is Array' is a type constraint...

[16:50] <pmichaud> S03:1799:  Note that, unlike assignment, binding replaces the container,

[16:50] <pmichaud> so the following fails because a range object cannot be subscripted:

[16:50] <pmichaud> @natural := 0..*;     # bind a Range object @natural[42] = "Life, the Universe, and Everything";  # FAILS

[16:50] <lambdabot> Unknown command, try @list

[16:50] <ruoso> pmichaud, ok... you were trying to write to it

[16:50] *** sri_kraih_ left
[16:51] <ruoso> that should fail

[16:51] <ruoso> since it's not an Array

[16:51] <pmichaud> no, that's not what the spec says.

[16:51] <PerlJam> pm: no, I think it fails because a Range generates immutables. :)

[16:51] <pmichaud> "a range object cannot be subscribed"

[16:51] <pmichaud> "a range object cannot be subscripted"

[16:51] <pmichaud> it's explicitly there that it fails because of subscripting the range object, not because range objects are immutable.

[16:51] <PerlJam> @x may be bound to an object of the Array class, but it may also be bound to any object that does the Positional role, such as a List, Seq, Range, Buf, or Capture. The Positional role implies the ability to support postcircumfix:<[ ]>.

[16:51] <lambdabot> Maybe you meant: . ? @ v

[16:51] <pmichaud> also, I don't think Range objects are immutable, because we can .pop a Range

[16:52] <PerlJam> (straight from S02)

[16:52] <pmichaud> PerlJam: yes, the spec is inconsistent.

[16:52] <PerlJam> pm: no, the Range object isn't mutable, but things it generates are.

[16:52] <PerlJam> er, isn't immutable

[16:52] <ruoso> "Lists are lazy in Perl 6, and the slice lists are no exception. In particular, things like range objects are not flattened until they need to be"

[16:52] <pmichaud> PerlJam:   doing .pop on a Range changes the range.

[16:53] <PerlJam> pm: sure, that just changes what it generates

[16:53] <pmichaud> no, it actually changes the .to value

[16:54] <pmichaud> it would also change the output of .perl

[16:54] *** araujo joined
[16:54] <pmichaud> either that, or this is some strange definition of 'immutable'

[16:55] <PerlJam> Hmm.  Now I think we're saying the same thing.  you can change a Range, but once it has been iterated, you can't change the values that the Range generated because they are immutable.

[16:55] <pmichaud> no, that's not what I'm saying.

[16:55] <pmichaud> See S03:2867

[16:55] * PerlJam looks

[16:55] <pmichaud>     $range = 1..^42.5;

[16:55] <pmichaud>     $front = $range.shift;      # $front = 1, $range = 2..^42.5

[16:55] <pmichaud>     $back = $range.pop;      # $back = 41.5, $range = 2..^41.5

[16:55] <pmichaud> I'm not talking about $range inside of a lazy list

[16:55] <pmichaud> I'm talking about the range itself.

[16:56] *** justatheory joined
[16:57] *** mncharity left
[16:57] <ruoso> pmichaud, I think the "a range object cannot be subscripted" is over-generalized

[16:58] <pmichaud> ruoso: I think you may be correct there.

[16:58] <pmichaud> ruoso: I just know what I read in the spec.  :-)

[16:58] <ruoso> in that specific case, It seems to mean that a Range is not an Array

[16:58] <ruoso> meaning that it can't store individual item

[16:59] <ruoso> but I don't think it means that you can't use $range[42] as an rvalue

[16:59] <pmichaud> fair enough.  I'm willing to grant that this particular part of the spec is incorrect.  That doesn't imply that a Range does List, though -- it just implies that Range does Positional

[17:00] <ruoso> hmm... 

[17:00] <ruoso> what does List implements that Positional doesn't?

[17:01] <pmichaud> I don't know.

[17:01] <pmichaud> and I'm fairly sure that Range will end up being mutalbe

[17:01] <pmichaud> er, mutable.

[17:02] <PerlJam> the spec is sparse on Positional

[17:02] <ruoso> hmm...

[17:02] <ruoso> ok... Positional defines only postcircumfix:<[ ]>

[17:02] <ruoso> while List also defines .Iterator()

[17:03] <moritz_> ruoso: no .elems in Positional?

[17:03] <ruoso> moritz_, S02 seems to imply that

[17:04] <PerlJam> maybe I'm being a pedant right now, but the spec only says that Positional implies postcircumfix<[ ]>, it doesn't say that that's the *only* thing it implies.

[17:04] <ruoso> well, I'm assuming it has an API that is smaller than List's

[17:04] <pmichaud> why?

[17:04] *** xuser left
[17:04] <moritz_> ruoso: perhaps, but I think not *that* small

[17:05] <ruoso> pmichaud, why would we need it otherwise?

[17:05] <pmichaud> because we might have objects that does Positional but aren't List

[17:05] <pmichaud> 'List' is the "generic list of things"

[17:05] <moritz_> ruoso: the @ sigil implies Positional, and the average user wants to call .map on anything with that sigil

[17:06] <pmichaud> .map is on Any :-)

[17:06] * ruoso was assuming List is a Role

[17:06] <moritz_> pmichaud: yes, but .map on non-Positional types only does one execution of the closure

[17:06] <ruoso> moritz_, not really

[17:06] <pmichaud> I would think that .map is totally unrelated to Positional.

[17:07] <ruoso> .map is related on how it implements .Iterator()

[17:07] <pmichaud> ...what ruoso just said.

[17:08] <moritz_> and you mean it's the same for .join, .chars, .grep etc.?

[17:08] <pmichaud> yes.

[17:08] <ruoso> certainly

[17:08] <pmichaud> I just got through fixing some of the code in Rakudo that was trying to do things via positionals instead of iterators.

[17:08] <pmichaud> Unfortunately there's a fair bit more.

[17:09] <pmichaud> http://use.perl.org/~pmichaud/journal/37967

[17:09] <lambdabot> Title: Journal of pmichaud (6013)

[17:10] <ruoso> pmichaud, I presume you've seen S07 already

[17:10] <pmichaud> ruoso: not completely, no.

[17:10] <pmichaud> ruoso: I'm waiting for TimToady to comment on it.  I really tend to stay out of the "what should be" conversations and focus on the "what is" stuff.

[17:10] <PerlJam> Wait ... I thought the reference to S07 was a typo.  What's S07 now?  Just the iterator spec?

[17:11] <pmichaud> S07:  iterators and laziness

[17:11] <masak> PerlJam: I was as confused as you a couple days ago.

[17:11] <pmichaud> I do wish we'd be consistent about ".Iterator" versus ".iterator", though.

[17:11] <masak> apparently, @Larry are re-using S-numbers.

[17:11] <pmichaud> same for ".List" and ".list"

[17:12] <pmichaud> although changing ".list" now is going to cause a fair number of headaches in Rakudo and PCT

[17:12] *** donaldh left
[17:12] <pmichaud> (because a lot of code depends on it.)

[17:12] <ruoso> pmichaud, I'm assuming .Iterator falls into the same category as .Str

[17:12] <ruoso> as I would expect on .List

[17:12] <pmichaud> ruoso: yes, I see the parallel.

[17:13] <pmichaud> ruoso: but that's not the way the spec was written originally, and there's a lot of code now expecting ".list", ".item", and ".hash"

[17:13] <ruoso> hmm... but it's already accepted that it should be .List now

[17:13] <pmichaud> it is?

[17:13] <pmichaud> was that announced/placed into the spec somewhere?

[17:13] <pmichaud> is there an irc conversation for it?

[17:14] <ruoso> I'm not sure... I've just been assuming that for a while

[17:14] <moritz_> pmichaud: S13 says that coercion to a type is done by calling .Type, iirc

[17:14] <pmichaud> moritz_: I agree, that's what it says.

[17:14] <pmichaud> moritz_: I also know that there are still instances of ".list" in the specs

[17:14] <ruoso> I'd consider that as specbug

[17:14] <moritz_> pmichaud: I think there are multiple such aliases, like .true for .Bool

[17:15] <pmichaud> moritz_: and that I explicitly heard from TimToady that the method forms of "list( )", "item( )", and "hash( )"  were  .list, .item, and .hash

[17:15] <pmichaud> it's possible that there is both ".list" and ".List"

[17:15] <pmichaud> but I'd like to see this mentioned explicitly somewhere.

[17:15] *** ejs joined
[17:16] <PerlJam> ruoso: I've been under that same assumption for a while too (I thought timtoady said so on p6l or here)

[17:16] <pmichaud> even STD.pm uses ".item"

[17:16] <ruoso> hmm

[17:16] <ruoso> well.. 

[17:16] <ruoso> that requires clarification from TimToady indeed

[17:16] <moritz_> is there even an 'Item' type?

[17:17] <pmichaud> there was at one point.

[17:17] <pmichaud> S10 mentions one.

[17:17] <pmichaud> as does S12.

[17:18] <pmichaud> I don't mind if we go ahead and treat .list/.hash/.item as coercions (and switch them to the uppercase forms), but let's please get it documented somewhere or otherwise "blessed" as official.

[17:18] <ruoso> I just hope TimToady can backlog all this discussion

[17:19] <pmichaud> because there's a boatload of code that was built on the previous versions that has to be deprecated, and sooner would be better.

[17:20] <pmichaud> it also begs the question of whether there's a difference between  list(...)  and List(...)

[17:20] <ruoso> indeed... for some reason I'm using an even different nomenclature for item 

[17:20] <ruoso> which is .FETCH() and .STORE()

[17:21] <ruoso> I think I took that from an lvalue example in S12

[17:23] <ruoso> and I think that was related to .BIND() as well

[17:24] * ruoso lunch &

[17:24] <pmichaud> same here -- errands and lunch.

[17:24] <moritz_> it's more like supper time here

[17:25] <moritz_> supper &

[17:28] *** meppl joined
[17:36] *** masak left
[17:42] *** _smg joined
[17:42] *** lizsac joined
[17:42] *** smg left
[17:42] *** _smg is now known as smg

[17:43] *** lizsac_ left
[17:44] *** pbuetow joined
[17:57] *** lizsac left
[17:57] *** bsdperl left
[18:00] *** schmalbe joined
[18:00] *** lizsac joined
[18:02] *** bsdperl joined
[18:09] *** pbuetow left
[18:17] *** jrockway_ joined
[18:18] *** jrockway left
[18:24] <pugs_svn> r24137 | putter++ | [STD_blue] Prune untagged Match tree nodes.  Switched the /a?/ IR style from elf_h's to rx_on_re's (to be unified later).

[18:24] <pugs_svn> r24137 | putter++ | [rx_on_re] New elf with STD_blue and rx_on_re.  rx_on_re/t/ can be run against it.  /abc/ is reaching IR.

[18:24] *** rindolf left
[19:06] <thei0s> am I correct that this http://perlgeek.de/blog-en/perl-5-to-6/23-quoting-and-parsing.html#Parsing is outdated and perl6 should also allow if(..) and for(..) (without whitespace)? as far as I can see both rakudo and pugs interpret it right

[19:07] <lambdabot> Title: blog | Perlgeek.de Blog :: Quoting and Parsing, http://tinyurl.com/59bax4

[19:12] <thei0s> rakudo: my @l=1..Inf;

[19:12] <p6eval> rakudo 33443: OUTPUT[Use of uninitialized value‚ê§]

[19:12] <thei0s> rakudo: my @l=1..*;

[19:12] <p6eval> rakudo 33443: OUTPUT[get_integer() not implemented in class 'Whatever'‚ê§current instr.: 'parrot;Range;!to_test' pc -2040733 ((unknown file):-1)‚ê§]

[19:15] *** mtrimpe joined
[19:15] *** justatheory left
[19:18] *** armagad joined
[19:25] *** DemoFreak joined
[19:28] *** Lorn_ joined
[19:29] *** Lorn left
[19:33] *** schmalbe left
[19:35] *** DemoFreak left
[19:38] *** mj41_ joined
[19:38] *** DemoFreak joined
[19:53] *** mj41 left
[20:03] *** Lorn_ left
[20:07] *** ejs left
[20:09] *** donaldh joined
[20:10] *** apeiron left
[20:11] *** apeiron joined
[20:11] *** zamolxes left
[20:27] <pugs_svn> r24138 | hinrik++ | [util/perl6.vim] don't need whitespace before <=>

[20:31] *** kane_ left
[20:34] *** LearningPerl joined
[20:34] <LearningPerl> hi

[20:34] <LearningPerl> I keep getting

[20:34] <LearningPerl> CGI Error

[20:34] <LearningPerl> The specified CGI application misbehaved by not returning a complete set of HTTP headers.

[20:34] <LearningPerl> Some help please

[20:34] *** adc_penner2 joined
[20:34] <moritz_> LearningPerl: this is the Perl 6 developer's channel, not the place for getting Perl help

[20:34] <LearningPerl> I keep getting

[20:35] <moritz_> LearningPerl: perlmonks.org might help you

[20:35] <LearningPerl> Thanks, already on there IRC channel

[20:35] <LearningPerl> Any others you recommend?

[20:35] <moritz_> #perlde on irc.perl.org if you happen to speak German ;)

[20:36] <LearningPerl> lol

[20:37] <LearningPerl> Can't speak German

[20:37] <LearningPerl> Except through google translate

[20:37] <moritz_> well, perlmonks.org (the website) is really good if you invest some time in asking the question properly

[20:41] *** adc_penner2 left
[20:42] <LearningPerl> moritz

[20:42] <LearningPerl> Would you mind helping me out?

[20:42] <LearningPerl> (if you're not to busy)

[20:43] *** adc_penner2 joined
[20:44] <moritz_> LearningPerl: on perlmonks.org, sure

[20:44] <thei0s> you probably forgot to print "Content-type: text/html\n\n"

[20:45] <thei0s> or your application segfaults

[20:45] <moritz_> or one of 100 other possible reasons, for which there are many appropriate channels to discuss

[20:45] <thei0s> yes :)

[20:46] <LearningPerl> moritz and thei0s: Here is my file: http://paste.viaweb.biz/p/14

[20:46] <LearningPerl> (with Perl syntax highlighting)

[20:46] <LearningPerl> (and line numbers)

[20:47] <LearningPerl> Please tell me where I went wrong and how to fix it.

[20:47] <LearningPerl> Thanks in advanc

[20:47] <LearningPerl> e

[20:49] <thei0s> LearningPerl: as far as I can see this is not even perl6 code.. so ignoring the fact that this is a development channel, this has lost nothing on #perl6.. go to #perl on any other irc network or sth...

[20:51] <LearningPerl> ok

[20:51] <LearningPerl> (got it to work just now BTW)

[20:58] *** zamolxes joined
[20:59] <LearningPerl> Do you need to do the my thing for arrays as well as scalars?

[21:01] <ruoso> LearningPerl, in Perl 6 you do, by default

[21:01] <LearningPerl> and in Perl5?

[21:01] <thei0s> this is the development channel for a new programming language called Perl6, not help channel for Perl5

[21:01] <LearningPerl> Can you please just answer my question with a 'yes' or a 'no'

[21:02] <LearningPerl> (sorry if I sound rude, have been up for to long studying perl)

[21:02] <thei0s> did they ban you from #perl or what?

[21:02] <ruoso> LearningPerl, sorry if we sound rude, but this is not the topic on this channel

[21:02] <moritz_> there's not always a single yes-or-no answer that's also correct

[21:03] <pugs_svn> r24139 | hinrik++ | [util/perl6.vim] conditionals need whitespace to the right

[21:03] <LearningPerl> thei0s: Unfortunately, yes, they did

[21:04] <moritz_> then you can still ask on perlmonks.org

[21:04] <moritz_> we're not '#perl in not-banned'

[21:04] <ruoso> and there's also #perlhelp iirc

[21:04] <moritz_> and irc.perl.org, with lots of helpful channels

[21:10] <LearningPerl> #perlhelp iirc

[21:10] <LearningPerl> ???

[21:12] * ruoso later &

[21:12] *** ruoso left
[21:13] <LearningPerl> Well if there's anyone left here that's willing to help

[21:13] <LearningPerl> http://paste.viaweb.biz/p/15

[21:13] <LearningPerl> it's a .cgi file

[21:17] *** xuser joined
[21:18] *** Jedai left
[21:18] *** Jedai joined
[21:26] <buu> Oh god.

[21:28] *** smg left
[21:38] <thei0s> is or will in Perl6 be a build-in function that does the same as Perl5 Data::Dumper module? it comes handy when debugging things

[21:38] <moritz_> thei0s: .perl

[21:38] <moritz_> rakudo: say [2, 3, '3'].perl

[21:39] <p6eval> rakudo 33448: OUTPUT[[2, 3, "3"]‚ê§]

[21:39] <thei0s> nice, 10x

[21:40] <literal> rakudo: .perl

[21:40] <p6eval> rakudo 33448: RESULT["undef"]

[21:40] *** LearningPerl left
[21:43] *** masak joined
[21:51] *** alexi5 joined
[21:52] <thei0s> rakudo: "abcd" ~~ m/(bc)/; say $/.perl;

[21:52] <p6eval> rakudo 33448: OUTPUT[{}‚ê§]

[21:53] *** iblechbot left
[21:53] <thei0s> is there a way that something like this would print out what it matches?

[21:55] <thei0s> pugs: "abcd" ~~ m/(bc)/; say $/.perl;

[21:55] <p6eval> pugs: OUTPUT[Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/evalenv/pugs/perl5/Pugs-Compiler-Rule/lib';‚ê§    unshift @INC, '/home/evalenv/pugs/third-party/Parse-Yapp/lib';‚ê§    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;‚ê§}‚ê§'Pugs::Runti...

[21:56] <PerlJam> thei0s: that looks buggy to me.

[21:56] <moritz_> thei0s: it's one of the rakudo limitations. there's a PIR thing for matching the match, though

[21:58] *** zamolxes left
[21:59] *** zamolxes joined
[21:59] *** alexi5 left
[22:18] *** adc_penner2 left
[22:18] <literal> rakudo: say $?ROUTINE

[22:19] <p6eval> rakudo 33448: OUTPUT[Lexical '$?ROUTINE' not found‚ê§current instr.: '_block11' pc 11 (EVAL_13:13)‚ê§]

[22:20] <moritz_> buu: our buubot in #perlde doesn't respond anymore... are you the person to talk to?

[22:20] <buu> Yes.

[22:20] <buu> moritz_: Which network?

[22:20] <moritz_> so consider yourself being talked to ;-)

[22:21] <moritz_> buu: irc.perl.org

[22:22] *** buubot joined
[22:22] *** japhb left
[22:25] *** japhb joined
[22:26] <masak> what's buubot supposed to do, anyway?

[22:26] <pmichaud> rakudo doesn't understand .perl on Match objects yet.

[22:26] <pmichaud> (conclusion from earlier .list versus .List conversation, etc.)

[22:26] <moritz_> masak: for example eval perl 5 code

[22:26] <masak> ooh

[22:26] <moritz_> buubot: eval: scalar localtime

[22:26] <buubot> moritz_:  "Tue Dec  2 22:32:09 2008"

[22:27] <pmichaud> I've decided for the time being that .list, .hash, .item are the method forms of list context, "hash" context, item context, while .List and .Hash really mean "coerce to a List/Hash".  In many cases they're equivalent, but the lower-case forms focus on context, while the uppercase forms focus on coercion.

[22:28] <moritz_> that sounds sane.

[22:28] <pmichaud> for .iterator/.Iterator, one could argue it either way.

[22:29] <pmichaud> $foo.Iterator really isn't "coerce to an iterator" as much as it is "build an iterator for $foo".  However, that's somewhat consistent with the way we think of .Str as meaning "construct a Str representation of the invocant".

[22:29] <[particle]> is there an Iterator type now?

[22:30] <pmichaud> ruoso and S07 wants there to be one; I suspect there is one, or an Iterator role that has lots of iterator types.

[22:31] <pmichaud> beyond that I can't say until some piece of the design gets TimToady's blessing.  :-)

[22:33] <pugs_svn> r24140 | moritz++ | [docs] S07 is now Iterators. Fixed in syn_index.html.

[22:35] *** hercynium left
[22:45] <pugs_svn> r24141 | moritz++ | [docs] fix typo in syn_index.html

[22:45] *** ryanc joined
[22:49] *** ruoso joined
[22:52] <ruoso> [particle], pmichaud, Iterator is a Role, no doubt of it, and each List can provide its own private and specific implementation

[22:53] <[particle]> ruoso, then $foo.Iterator looks wrong to me

[22:54] <[particle]> i'd expect $foo.get_iterator or something, as a method named 'Iterator' in a role named 'Iterator' is confusing

[22:54] <ruoso> it still fits in the same category as .Str IMHO

[22:54] <ruoso> [particle], the Iterator role doesn't have a .Iterator method

[22:55] <ruoso> List does

[22:55] <moritz_> [particle]: it returns something that fits to the type Iterator, I think that's close enough

[22:58] *** smg joined
[23:00] <pmichaud> if it helps, think of  prefix:<~> and Str being analogous to prefix:<=> and Iterator

[23:01] <pmichaud> however,  @(...)  corresponds to .list, not .List

[23:02] <pmichaud> so, perhaps it doesn't quite work out there.

[23:02] <ruoso> that surprised me today... I really expected that to be .List

[23:02] <pmichaud> it's been .list for a very long time.

[23:04] <ruoso> so I was told...

[23:04] <pmichaud> anyway, time to take kids to a basketball game.... bbl

[23:13] <ruoso> pmichaud, [particle], btw... http://svn.pugscode.org/pugs/v6/mildew/Map.pm is a sketch of some ideas about S07

[23:19] *** masak left
[23:19] *** DemoFreak left
[23:21] *** donaldh left
[23:22] *** thei0s left
[23:32] <pugs_svn> r24142 | putter++ | [elfish/rx_on_re] Preparing for the switch to emitting code instead of subs.

[23:32] <pugs_svn> r24142 | putter++ | [elf_h] Readd a special function to inline p5.  Use is strongly discouraged.

[23:36] *** Exodist left
[23:38] *** SamB joined
[23:43] <pugs_svn> r24143 | lwall++ | [t/spec] comments.t missing opening {

[23:45] *** zamolxes left
[23:55] *** bsdperl left
[23:57] *** pnu left
[23:57] *** pnu joined
[23:59] *** aindilis left
[23:59] *** aindilis joined
[23:59] *** bsdperl joined
