[00:00] *** pbuetow left
[00:01] *** KidShenck left
[00:01] *** ZuLuuuuuu left
[00:02] *** pedrob joined
[00:09] *** Limbic_Region joined
[00:13] *** fleebailey3 is now known as fleebailey33

[00:16] *** fleebailey33 left
[00:25] *** Exodist left
[00:33] *** hercynium left
[00:35] *** eternaleye joined
[00:39] *** pedrob left
[01:03] *** smg joined
[01:10] *** eternaleye left
[01:28] *** nacho_ joined
[01:46] *** jiing left
[01:53] *** justatheory left
[02:08] <pugs_svn> r22890 | lwall++ | [STD] fix ws nodewrapping bug

[02:08] <pugs_svn> r22890 | lwall++ | [Cursor] more refactoring

[02:08] <TimToady> @tell ruoso you can pull out your ws workaround code now, I think

[02:08] <lambdabot> Consider it noted.

[02:11] *** cathyal joined
[02:19] *** hercynium joined
[02:22] *** felipe left
[02:39] *** eternaleye joined
[03:00] *** wknight8111 left
[03:06] *** alc joined
[03:17] *** eternaleye left
[03:36] <pugs_svn> r22891 | lwall++ | [gimme5] more lexer call refactoring to avoid duplication

[03:47] *** Psyche^ joined
[03:48] *** Patterner left
[03:48] *** Psyche^ is now known as Patterner

[03:48] *** Limbic_Region left
[03:52] *** |Jedai| left
[03:52] *** Jedai joined
[03:53] *** Ontolog joined
[03:54] *** japhb__ left
[04:00] *** cathyal left
[04:06] *** jauaor joined
[04:08] *** japhb__ joined
[04:10] *** z80ASM joined
[04:27] *** araujo left
[04:28] *** eternaleye joined
[04:32] *** araujo joined
[04:33] *** felipe joined
[04:42] *** d4l3k_ joined
[04:42] *** alc left
[04:42] *** nothingmuch left
[04:42] *** dalek left
[04:43] *** d4l3k_ is now known as dalek

[04:46] *** nothingmuch joined
[04:54] *** hercynium left
[04:58] *** alc joined
[05:12] <pugs_svn> r22892 | pmichaud++ | [spec]:  Fudge some tests for rakudo in S03-junctions/boolean-context.t

[05:15] <pugs_svn> r22893 | pmichaud++ | [spec]: Fudge a .pick test on arrays for rakudo.

[05:16] <pugs_svn> r22894 | lwall++ | [Cursor] couple more micro-optimizations to help procrastinate the big one

[05:18] <bacek_> rakudo: my $a='a'; my $b='b'; my $c='c'; say ?(('a' | 'b' | 'c') eq ($a & $b & $c));

[05:18] <p6eval> rakudo 32372: OUTPUT[0␤]

[05:19] <bacek_> pugs: my $a='a'; my $b='b'; my $c='c'; say ?(('a' | 'b' | 'c') eq ($a & $b & $c));

[05:19] <p6eval> pugs: OUTPUT[all(VJunc any(VBool False,VBool True))␤]

[05:20] <literal> what does that V in VBool/VJunc mean?

[05:22] *** z80ASM left
[05:23] <TimToady> value perhaps

[05:42] *** nacho_ left
[05:45] *** sail0r joined
[05:47] *** Alias_ joined
[05:50] <pugs_svn> r22895 | pmichaud++ | [spec]:  Revert some incorrect unfudging in r22788.

[05:51] *** sail0r left
[06:06] *** sri_kraih left
[06:13] *** ab5tract joined
[06:18] <pugs_svn> r22896 | lwall++ | [Cursor] Heh, if we bypass TRE to just immediately revert to the stupid old

[06:18] <pugs_svn> r22896 | lwall++ | backoff LTM matcher, STD (precached) can parse itself in half the time!  Yow!

[06:32] *** ab5tract left
[06:57] *** ashizawa joined
[07:08] *** adc_Penner joined
[07:52] *** bacek left
[07:58] *** pbuetow joined
[07:58] *** iblechbot joined
[08:04] *** bacek joined
[08:05] *** tomyan joined
[08:13] *** bacek_ left
[08:19] *** alester left
[08:22] *** simcop2387 left
[08:23] *** elmex joined
[08:24] *** simcop2387 joined
[08:26] *** stephenos left
[08:30] *** pbuetow left
[08:47] *** japhb joined
[08:47] *** Bzek joined
[08:59] *** japhb__ left
[09:04] *** cosimo joined
[09:14] *** zamolxes joined
[09:19] *** smg left
[09:24] *** Ontolog left
[09:25] *** adc_Penner left
[09:34] *** cpfr left
[09:48] *** jauaor left
[09:53] *** ejs joined
[10:41] *** zamolxes_ joined
[10:41] *** zamolxes_ left
[10:41] *** zamolxes_ joined
[10:42] *** zamolxes left
[10:48] *** zamolxes_ is now known as zamolxes

[10:51] *** smg joined
[11:04] *** alc left
[11:05] *** cpfr joined
[11:22] <pugs_svn> r22897 | jnthn++ | [spectest] Unskip some inheritance tests that Rakudo now passes.

[11:31] <pugs_svn> r22898 | jnthn++ | [spectest] Correct a test that got indirect method invocation syntax wrong, and un-todo it for Rakudo. Also un-todo a test that pended on object stringification.

[11:56] *** TheFluff_ left
[12:44] *** schmalbe joined
[12:44] *** z80ASM joined
[12:50] *** renormalist joined
[13:12] *** zamolxes left
[13:32] *** meppl joined
[13:46] *** ashizawa left
[13:48] *** sri_kraih joined
[14:06] *** pedrob joined
[14:08] *** beppu__ joined
[14:20] *** beppu left
[14:32] *** |Jedai| joined
[14:46] *** ejs_ joined
[14:46] *** Alias_ left
[14:47] *** ejs left
[14:48] *** jauaor joined
[14:49] *** Jedai left
[14:54] *** zamolxes joined
[14:54] *** zamolxes left
[14:55] *** __felix__ joined
[14:57] *** zamolxes joined
[14:57] *** __felix__ left
[15:03] *** pedrob left
[15:04] *** pedrob joined
[15:05] *** rdice joined
[15:07] *** ludan joined
[15:09] *** alc joined
[15:14] *** ejs_ left
[15:24] *** jhorwitz joined
[15:37] *** jan_ left
[15:44] *** alester joined
[15:49] *** z80ASM left
[15:52] *** hercynium joined
[16:02] *** stephenos joined
[16:06] *** stephenos left
[16:09] *** stephenos joined
[16:09] *** eternaleye left
[16:24] *** alc left
[16:25] <pugs_svn> r22899 | lwall++ | [Cursor] plug some syntax errors misdiagnosed by new LTM

[16:25] <pugs_svn> r22899 | lwall++ | [tryfile] restore ability to report failures via exit status

[16:25] *** zamolxes_ joined
[16:32] *** Exodist joined
[16:32] *** eternaleye joined
[16:40] *** zamolxes left
[16:45] *** jan_ joined
[16:47] *** ab5tract joined
[17:01] *** masak joined
[17:03] *** pedrob left
[17:04] *** cosimo left
[17:13] *** z80ASM joined
[17:21] *** TJCRI joined
[17:22] *** renormalist left
[17:23] <pugs_svn> r22900 | lwall++ | [Cursor] extirpate TRE

[17:23] *** TJCRI left
[17:25] *** eternaleye left
[17:25] *** justatheory joined
[17:27] <TimToady> @tell azawawi you should find your parsers running somewhat faster now, given that STD now parses itself twice as fast as it did yesterday (given a preloaded cache)

[17:27] <lambdabot> Consider it noted.

[17:27] *** zamolxes_ is now known as zamolxes

[17:27] <kolibrie> TimToady++ # faster STD

[17:28] <[particle]> nice

[17:29] <TimToady> you don't get quite 2x gain on random tests because it still takes a second or so to parse all the p5 code involved, so shorter files parse in about 3/4 the time they used to

[17:30] <TimToady> don't know what the relative memory usage is though

[17:31] <TimToady> and I still haven't actually implemented a decent trie/dfa-ish lexer, so the cache is still 400MB or so after parsing all the tests

[17:32] <[particle]> where's dmq and avar when you need them?

[17:32] <TimToady> but now that TRE is out of the way, I'm running out of excuses :)

[17:32] *** ruoso joined
[17:33] <avar> mmmm

[17:34] <avar> TimToady: tre out of the way? yay!

[17:34] *** pbuetow joined
[17:35] <ruoso> Hello!

[17:35] <lambdabot> ruoso: You have 1 new message. '/msg lambdabot @messages' to read it.

[17:35] <TimToady> basically, instead of using TRE and then doing my own ltm backoff, I just started with my stupid ltm backoff at the beginning, and surprised myself when it ran faster

[17:35] <avar> nice

[17:35] <TimToady> it's probably more efficient because of all the digraph caching, so it doesn't actually have to run over all that many patterns typically

[17:37] <TimToady> and we no longer have TRE for a dependency either, which has something to be said for it

[17:38] <moritz_> you mean it might now work on other systems than linux? ;-)

[17:40] <TimToady> some of our programs still use cat

[17:40] <moritz_> I guess there's a /bin/cat on solaris, for example

[17:44] <[particle]> windows has 'type'

[17:44] <[particle]> EU::C has a 'cat' you can use iirc

[17:44] <moritz_> or 'cp $file con' iirc

[17:44] <moritz_> and Perl has open() ;)

[17:45] * ruoso wonders if there's a dog around to chase this cat

[17:45] * ruoso hides...

[17:49] *** Aisling left
[17:51] <pugs_svn> r22901 | lwall++ | [Cursor] use of cat deemed less than useful

[17:52] <ruoso> TimToady++ # ws issue solved

[17:53] *** Psyche^ joined
[17:53] *** fleebailey33 joined
[17:55] *** Patterner left
[17:55] *** Psyche^ is now known as Patterner

[17:57] *** beppu__ is now known as beppu

[18:03] *** z80ASM left
[18:04] * jauaor wonders if somebody is on mac here

[18:06] <pugs_svn> r22902 | moritz++ | [t/spec] don't rely on a lexicals working in eval() when testing ro-ness of

[18:06] <pugs_svn> r22902 | moritz++ | subroutine arguments. Also TODO the now failing test for rakudo.

[18:07] *** adc_Penner joined
[18:11] <ruoso> in the following code:

[18:11] <ruoso> my @a = grep { ... } @b;

[18:11] <ruoso> from what I understand of the spec, 

[18:11] <ruoso> @a is a lazy array

[18:11] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v

[18:11] <ruoso> but...

[18:12] <ruoso> if someone does...

[18:12] <ruoso> my @c = @a;

[18:12] <ruoso> that kinda looks like implying copying the values from @a to @c

[18:12] <ruoso> which would mean eager evaluation...

[18:13] <ruoso> wouldn't it be sane that list assignement always imply eager evaluation?

[18:13] <ruoso> leaving list binding for lazy lists?

[18:13] <ruoso> like...

[18:13] <ruoso> my @a := grep { ... } @b;

[18:13] <ruoso> my @c := @a;

[18:13] <ruoso> this would keep the lazyness in all arrays...

[18:15] <ruoso> on the same issue, I would think that if you do '@a = @b' and later use @a in slice context, it would be already flattened...

[18:15] <ruoso> since list assignment implies list context

[18:16] <TimToady> I basically agree, since assignment should try to behave as much like p5 assignment as possible

[18:17] <ruoso> cool... the same for hashes, i presume...

[18:17] <TimToady> however, I think eager context may recognize iterators that are known to be infinite, and flip to lazy at that point

[18:17] <TimToady> so @a = 1..* would still work

[18:18] <ruoso> wouldn't it be better if we assume one would have to use @a := 1..*?

[18:18] <pmichaud> TimToady: jonathan++ and I had a(nother) question about .true earlier today -- do we really need it?  Wouldn't it be sufficient to simply use .Bool instead?

[18:18] <TimToady> well, the problem is that the failure mode of not detecting infinite lists is rather harsh in any case

[18:18] <pmichaud> (this question can wait until the current thread has ended)

[18:19] <ruoso> pmichaud, .Bool is not native... .true is native

[18:19] <ruoso> TimToady, yes... but using infinite lists is something the user should know how to use...

[18:19] <ruoso> the user can live its entire life without using infinite lists

[18:19] <TimToady> it could warn

[18:19] <ruoso> in fact...

[18:20] <ruoso> list assignment needs to ask the length of the lsit

[18:20] <ruoso> list

[18:20] <ruoso> this can trigger the check

[18:20] <ruoso> it could even fail

[18:21] <ruoso> my @a = 1..*; would raise a "Trying to assign an infinite list" error

[18:21] <TimToady> I think gratuitous failure is antisocial.  :)

[18:22] <ruoso> I could argue semantic inconsistency is even more antisocial ;)

[18:22] <TimToady> I'm fine with a warning, but it should DTRT anyway

[18:22] <TimToady> Perl is more about DTRT than consistency

[18:22] <ruoso> TimToady, in @a = 1..*; is @a readwrite?

[18:23] <TimToady> certainly; the initializer is just an initializer

[18:23] <ruoso> and what @a.push(1) would do?

[18:24] <TimToady> it's how you reify unreal values, but if an element is reified already, it is just an ordinary array element

[18:24] *** ludan left
[18:24] <TimToady> a push would of course fail

[18:24] <TimToady> well, maybe not

[18:24] <TimToady> it could just add another initializer on the end

[18:24] <pmichaud> I would just think it'.... right.

[18:24] <TimToady> surreal lists

[18:25] <jnthn> pmichaud: That was what I thought too.

[18:25] <ruoso> so... what is the border line in "to be or not to be eager"

[18:26] <ruoso> does that gets us back to the idea of a three-state iterator?

[18:27] <ruoso> 1..* would be coerced to an iterator, which would then have "prefix:<=>" called

[18:28] <ruoso> which would return a 'ExpensiveOperation' failure

[18:28] <ruoso> which would cause the list assignment code to create a new lazy list that uses that iterator?

[18:28] <ruoso> hmm...

[18:28] <ruoso> but...

[18:29] <ruoso> prefix:<=> is not expensive..

[18:29] <TimToady> it is in list context :)

[18:29] <TimToady> well, might be

[18:29] <ruoso> we need something else besides prefix:<=>

[18:29] <ruoso> to do that checking

[18:29] <jnthn> ruoso: 1..* _is_ an iterator by the Perl 6 spec.

[18:30] <TimToady> sure, but we're haggling of the api in any case :)

[18:30] <ruoso> jnthn, yes... sort of... since Perl 6 spec doesn't really specs an Iterator type

[18:30] <TimToady> *over

[18:31] <jnthn> I meant conceptually, not type wise. :-)

[18:31] <ruoso> the problem is that i'm getting in very concrete land now

[18:31] <ruoso> meaning the APIs 

[18:32] <ruoso> maybe a method to say 'hey, what do you think of going through all your elements'?

[18:32] <ruoso> that could return 'no way man!\

[18:32] <ruoso> or 'it might take a while'

[18:32] <ruoso> or 'just do it'

[18:33] <TimToady> or just "give me a reasonable length to eagerify over"

[18:33] <TimToady> so I know how big to make the real part of my array

[18:33] <ruoso> TimToady, but it's not just about length

[18:33] <ruoso> it might require IO

[18:34] <ruoso> like... a network stream

[18:34] <TimToady> sure, as would any eager evaluation

[18:34] <ruoso> sure... but we're discussing when plain '@a = @b' is eager or not

[18:35] <ruoso> the user is not saying "I want lazy" nor "I want eager"

[18:35] <ruoso> it's simply saying DWIM

[18:35] <TimToady> I think that one should just assume real stays real and spec stays spec

[18:36] <ruoso> that means 'my @a = grep { ... }, @b; my @c = @a' stays lazy?

[18:37] <ruoso> or does that depend on what @b is?

[18:37] <pugs_svn> r22903 | moritz++ | [t/spec] another test for ro-ness of arguments.

[18:37] <TimToady> I'd think it depends on @b

[18:37] *** pedrob joined
[18:38] <TimToady> it's fine if @b has a finite spec for @a to end up with that eager, but mostly specs in arrays will be infinite, I suspect

[18:39] <TimToady> the specs probably have to be cloned, since the two arrays are reading independently

[18:39] <TimToady> which is a good argument for treating IO as finite

[18:39] *** schmalbe left
[18:40] <TimToady> I think eagerness only becomes lazy on things that are provably infinite

[18:40] <pmichaud> to my ears, that makes things sound like eagerness is the default

[18:40] <pmichaud> *eyes

[18:40] <pmichaud> whatever.

[18:40] <TimToady> on assignment, yes

[18:41] *** jhorwitz left
[18:41] <TimToady> that's the notion we're discussion

[18:41] <TimToady> *discussing

[18:41] <TimToady> since assignment has copy semantics

[18:41] <TimToady> it is naturally eager-ish

[18:41] <TimToady> we talked about this a couple weeks ago too

[18:41] <jnthn> You could always go for copying any unevaluated iterators too.

[18:41] <pmichaud> yes, it's been a long-standing discussion :-)

[18:42] <pmichaud> I'm just trying to make sure I'm understanding what is being implied.

[18:42] <TimToady> it's no problem to copy iterators that are conceptually immutable

[18:42] <ruoso> yeah... the problem is with mutable stuff

[18:42] <TimToady> but copying a file handle is trouble

[18:43] <TimToady> 1..* is conceptually immutable, but iterable

[18:43] <TimToady> so it doesn't matter if you clone it

[18:44] <TimToady> it's also fine if you clone a mutable iterator derived from it, since you presumably already cloned the earlier values too

[18:44] <TimToady> it's that pure-in-the-Haskell-sense that makes it okay

[18:45] <TimToady> but in the absence of that purity, I think making eager the default for assignment is sane

[18:45] <TimToady> and what a p5 programmer is expecting in any case

[18:46] <TimToady> I think I need to hack the spec a bit though...

[18:46] <ruoso> but I'm still a little confused by what the border-line is...

[18:47] <TimToady> if an iterator doesn't know if it's infinite or not, assume it's not

[18:48] <ruoso> that means everything but 1..* (and similar) are eager...

[18:48] <TimToady> worst case is no worse than p5 now

[18:48] *** hanekomu joined
[18:48] <ruoso> ok... if that's the border line, it simply means that the assignment tries to fetch the size of the list

[18:49] <TimToady> I think we can assume that 1,2,4...{mumble} is infinite

[18:49] <ruoso> in infinite lists, it will return infinite

[18:49] <ruoso> otherwise, returning the number of elements will require eager evaluation

[18:51] <TimToady> we can probably also assume an explicit lazy list is to be treated as "infinite": @a = 1,2,3, lazy 4,5,6;

[18:52] <ruoso> hmm...

[18:52] <TimToady> or something like that

[18:52] <ruoso> that gets us back to the beggining

[18:53] <TimToady> I guess we currently only have lazy { 4,5,6 } syntax

[18:57] <ruoso> TimToady, I think it's saner if it's required to use 'my @a := 1,2,3,lazy {4,5,6}' to get lazy behaviour

[18:58] *** armagad joined
[18:59] *** mberends joined
[18:59] <ruoso> if we take the bind thing sanely...

[18:59] <ruoso> my @a := 1,2,3,lazy {4,5,6}

[18:59] <ruoso> is really something like

[19:00] <ruoso> :(*@a) := \(1,2,3,lazy {4,5,6})

[19:00] <ruoso> so it does make sense if the lazyness is preserved only on bind

[19:01] <ruoso> actually... the signature would be a bit different

[19:01] <ruoso> :(*@a is rw) := \(1,2,3,lazy {4,5,6})

[19:01] <ruoso> hmm...

[19:01] <ruoso> are slurpy arrays readonly or readwrite in signatures?

[19:04] <TimToady> depends on where the signature is

[19:04] <TimToady> in any case, it's not really what you want

[19:05] <TimToady> if you want to bind an actual Array object with Array semantics

[19:05] <TimToady> that lets you modify values that were initialized with immutables

[19:05] <TimToady> more like *@a is copy

[19:05] *** armagad left
[19:06] <ruoso> right... that makes even more sense

[19:06] <ruoso> :(*@a is copy) := \(1,2,3,lazy {4,5,6})

[19:06] <TimToady> perl6: my @a := 1..10; @a[1] = 42;

[19:06] <p6eval> rakudo 32398: OUTPUT[Null PMC access in find_method()␤current instr.: 'onload' pc 14 (src/gen_builtins.pir:31)␤]

[19:06] <p6eval> ..pugs: OUTPUT[*** Can't modify constant item: VInt 2␤    at /tmp/s7v7OXyZua line 1, column 17-27␤]

[19:06] <p6eval> ..elf 22847: OUTPUT[syntax error at (eval 117) line 3, at EOF␤ at ./elf_f line 3861␤]

[19:06] <TimToady> should fail

[19:07] <ruoso> hmm...

[19:07] <TimToady> my @a := Array(1..10); @a[1] = 42;

[19:07] *** hanekomu left
[19:07] <ruoso> I think you meant:

[19:07] <ruoso> perl6: my @a := Array(1..10); @a[1] = 42;

[19:07] <p6eval> rakudo 32398: OUTPUT[Null PMC access in find_method()␤current instr.: 'onload' pc 14 (src/gen_builtins.pir:31)␤]

[19:07] <p6eval> ..pugs: OUTPUT[*** No such subroutine: "&Array"␤    at /tmp/MLol4AjUuc line 1, column 1-22␤]

[19:07] <p6eval> ..elf 22847: OUTPUT[syntax error at (eval 119) line 3, at EOF␤ at ./elf_f line 3861␤]

[19:07] <TimToady> perl6: my @a := item(1..10); @a[1] = 42;

[19:07] <p6eval> rakudo 32398: OUTPUT[Null PMC access in find_method()␤current instr.: 'onload' pc 14 (src/gen_builtins.pir:31)␤]

[19:07] <p6eval> ..elf 22847: OUTPUT[syntax error at (eval 119) line 3, at EOF␤ at ./elf_f line 3861␤]

[19:07] <p6eval> ..pugs: OUTPUT[*** Can't modify constant item: VInt 2␤    at /tmp/VJdnOTXYEM line 1, column 23-33␤]

[19:08] <ruoso> what about...

[19:08] <ruoso> my @a <== 1..10

[19:08] <TimToady> perl6: my @a := [1..10]; @a[1] = 42;

[19:08] <ruoso> that expresses the desired lazyness

[19:08] <p6eval> rakudo 32398: OUTPUT[Null PMC access in find_method()␤current instr.: 'onload' pc 14 (src/gen_builtins.pir:31)␤]

[19:08] <p6eval> ..pugs: OUTPUT[*** Can't modify constant item: VUndef␤    at /tmp/cUSVU6Btym line 1, column 19-29␤]

[19:08] <p6eval> ..elf 22847: OUTPUT[syntax error at (eval 117) line 3, at EOF␤ at ./elf_f line 3861␤]

[19:08] <TimToady> that shoulda worked, I think

[19:09] <TimToady> pugs: [1..10].WHAT

[19:09] <p6eval> pugs: RESULT[::Array]

[19:09] *** pedrob left
[19:10] <TimToady> my @a := [1..10]; @a.WHAT

[19:10] <TimToady> pugs: my @a := [1..10]; @a.WHAT

[19:10] <p6eval> pugs: RESULT[::Array::Const]

[19:10] <ruoso> that's a bug, for sure

[19:10] <TimToady> grr

[19:10] <ruoso> TimToady, anyway... 

[19:10] <ruoso> what do you think about '@a <== 1..10' ?

[19:10] <ruoso> that expresses the desired lazyness and rw-ness

[19:11] <TimToady> feed operators are considered bindings rather than assignments, I think

[19:11] <ruoso> it's a special type of binding

[19:11] <ruoso> iirc, the return of feeds are not readonly

[19:11] <TimToady> perhaps it's just the syntax for adding a spec to an array

[19:12] <TimToady> @a <<== 1..10 adds a spec

[19:12] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v

[19:12] <TimToady> @a <== 1..10 replaces

[19:12] <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v

[19:12] <TimToady> maybe I didn't

[19:13] <ruoso> I think that's ok

[19:13] <ruoso> then list assignment is always eager, unless infinite

[19:13] *** Exodist left
[19:13] <TimToady> in any case, I think feeds should try to be lazy

[19:13] <ruoso> and feeds always try to be lazy...

[19:14] <TimToady> we're in violent agreement

[19:14] <ruoso> ok... so we agree that the boder-line to non-eager evaluation in list assignment is only if the rvalue is infinite 

[19:15] <TimToady> I think that's sanestest

[19:15] <ruoso> and lazy-aware people should use feeds instead

[19:16] <TimToady> and everyone is dwimically pleased, we hope

[19:16] <TimToady> I need to go dwim some lunch &

[19:17] *** iktome left
[19:21] <ruoso> TimToady, please consider spec'ing a little bit about Iterator... there are a lot of things counting on an iterator API it seems...

[19:22] *** explorer joined
[19:27] *** fleebailey33 left
[19:28] *** Exodist joined
[19:28] *** Exodist left
[19:29] *** Exodist joined
[19:29] *** Exodist left
[19:30] *** Exodist joined
[19:49] *** pedrob joined
[19:53] <pmichaud> TimToady: any thoughts about .Bool versus .true ?

[19:53] <TimToady> what they said

[19:56] <pmichaud> so, if I want to change the way a class booleans, do I define a .Bool method or a .true method?

[19:56] <pmichaud> i.e., a class' notion of truth is defined by what method?

[19:57] *** pedrob left
[19:57] <pmichaud> jnthn was of the opinion (I concur from what little I've thought about it) that if we use .Bool to define a notion of truth, then we don't have to do anything special to get  $x but True    to work properly.

[19:57] <pmichaud> i.e., Bool can be an enum.

[19:58] <pmichaud> it also seems odd that we use a .Str method for stringification but not .Bool for boolification

[19:59] <pmichaud> and, we could potentially eliminate .true altogether, which might avoid some confusion with prefix:<true>

[20:00] *** pedrob joined
[20:13] <ruoso> pmichaud, my major concern on that issue is that Bool is not a native type

[20:14] <ruoso> which means that you cannot assume to know how it's implemented

[20:14] <pmichaud> I'm simply saying it's an enum.

[20:14] <pmichaud> and that the way someone defines "booleaness" for a class is to define a method called .Bool

[20:15] <ruoso> I agree having both a native and a non-native bool is weird

[20:16] <pmichaud> currently S02 says that we use ".true" to do this, but that seems inconsistent with the notion of using ".Str" to define stringification on a class.

[20:16] <ruoso> and I wonder what is the use of an non-native bool?

[20:16] <ruoso> actually... ".true" is inconsistent even with the native type

[20:18] <ruoso> I was actually blindly using ".bool" in SMOP

[20:18] <PerlJam> didn't it used to be called .bit ?

[20:18] <ruoso> PerlJam, there's bit *and* bool

[20:18] <ruoso> iirc

[20:18] <ruoso> yes... I do rc

[20:18] <PerlJam> oh, perhaps.  My memory is fuzzy

[20:19] <ruoso> the only use I can think of for non-native bool is allowing a undefined Bool

[20:20] <PerlJam> there may be other "interesting" Bools

[20:21] *** smg left
[20:24] *** renormalist joined
[20:25] <ruoso> pmichaud, I think the point is that you don't need to boolify anything... because every Object supports natively responding as a bool

[20:25] <ruoso> no need to "coerce" to boolean

[20:25] <pmichaud> ruoso: obviously there is _some_ method that people can define to change an object's notion of booleanness

[20:25] <pmichaud> ruoso: currently the spec says that method is .true

[20:26] <ruoso> yes...

[20:26] <ruoso> and it's not inconsistent, because it's not a coercion

[20:26] *** rindolf joined
[20:26] <ruoso> you use .Str() because that's how that object is "coerced" to string

[20:26] <ruoso> there's no coercion to bool

[20:26] <ruoso> nor Bool

[20:26] <pmichaud> I don't understand the difference

[20:27] <ruoso> it's an attribute of every object to be either true or false

[20:27] <ruoso> you don't need to coerce the object to a different type 

[20:28] <ruoso> to find out it's boolean value

[20:28] <ruoso> s/it's/its'

[20:28] <pmichaud> so, how do you envision prefix:<?> as being implemented?

[20:29] <pmichaud> or, put another way, how can a .true method override an object's true/false attribute?

[20:29] <ruoso> er...

[20:29] <ruoso> there are no public attributes in Perl 6... that was just way of speaking..

[20:29] <ruoso> it's always a method

[20:30] <pmichaud> so, when you said "it's an attribute ..." above, did you mean "it's a method ..."?

[20:30] <rindolf> So does @$array_ref works in Rakudo already?

[20:30] <ruoso> pmichaud, yes... 

[20:30] <pmichaud> rindolf: not yet, we're working on it right now.

[20:30] <rindolf> How about ones (@$m, @$n)

[20:30] <ruoso> pmichaud, the spec says "attribute"

[20:30] <rindolf> pmichaud: ah, cool.

[20:31] <ruoso> pmichaud, but there are no real public attributes in Perl 6

[20:31] <rindolf> pmichaud: I'm glad to be your catalyst.

[20:31] <ruoso> it's *always* through methods

[20:31] <pmichaud> I'm simply saying that the method should be .Bool instead of .true, then.

[20:32] <ruoso> but that would return a non-native type

[20:32] <ruoso> I could agree with .bool

[20:32] *** hanekomu joined
[20:32] <pmichaud> I don't mind if .Bool delegates to .bool

[20:33] <pmichaud> however, note that .true already defaults to .defined in Object

[20:35] <pmichaud> anyway, I think I have my answer for now, thanks.

[20:35] <ruoso> pmichaud, the thing is whether "if" uses ".bool" or ".Bool"

[20:35] <ruoso> it's sane that it uses the native-type

[20:35] <ruoso> otherwise it would need to re-coerce to .bool

[20:35] <ruoso> because it can only assume to know the native bool

[20:35] <pmichaud> as long as the "native type" has some way of delegating to the user-defined methods, that's no problem.

[20:35] <ruoso> ?

[20:36] <ruoso> the problem is about the return of the methdo

[20:36] <pmichaud> if $x { ... }   needs to ultimately use the .true method of $x if the user has defined one.

[20:36] <ruoso> not the method itself

[20:36] <ruoso> it will *always* call $x.true

[20:36] <ruoso> there's no other option

[20:36] <ruoso> (unless $x is a native type, of course)

[20:37] <ruoso> and $x.true should *always* return a native bool

[20:38] <pmichaud> so, if I defined     class Foo { method true() { return 'yes'; } }      

[20:38] *** eternaleye joined
[20:38] <pmichaud> that would be an error?

[20:39] <ruoso> method true has a more compete signature

[20:39] <ruoso> that describes the return type

[20:39] <ruoso> the value passed to "return" can be coerced inside the method

[20:39] <ruoso> and not by the one calling it

[20:40] <pmichaud> so, the above would be an error?

[20:40] <ruoso> I presume it would at least give a warning and force a coercion...

[20:40] <ruoso> er... not coercion...

[20:40] <pmichaud> :-{

[20:40] <ruoso> but calling .true in the given object

[20:41] <ruoso> maybe it could recursively call .true until it finally gets a native bool

[20:41] <pmichaud> that all sounds very implementation-ish and not spec-ish.

[20:41] *** charsbar left
[20:42] *** charsbar joined
[20:42] *** zamolxes left
[20:42] <ruoso> the spec part is: method .true should return a native bool

[20:42] <pmichaud> is that specced somewhere now?

[20:43] <ruoso> er... I think I just presumed that...

[20:43] <ruoso> since the interpreter needs a native bool to be able to compare

[20:43] <pmichaud> at any rate, "coerce to native bool" sounds a lot more straightforward to me than "force return of native bool"

[20:44] <ruoso> agreed...

[20:44] <pmichaud> indeed, "recursively call .true" sounds like a coercion to me

[20:44] <ruoso> but you see why it needs to get a native bool in the end...

[20:44] <pmichaud> in Parrot our notion of "native bool" is being handled through the get_bool vtable function -- each PMC can define its own notion of get_bool

[20:45] <pmichaud> for the base Object class, we're just delegating to another method that can be overridden (currently .true)

[20:45] <masak> the recursive calls to .true might not bottom out...

[20:45] <ruoso> ok... and this delegation could do the coercion

[20:45] <pmichaud> it just feels more natural to say "delegate to .Bool"

[20:46] <ruoso> but you need a native bool in the end...

[20:46] <ruoso> having a non-native bool will just require yet another ste

[20:46] <ruoso> step

[20:46] <pmichaud> where .Bool returns something that can be coerced to a native bool according to its own rules

[20:46] <ruoso> that doesn't apply only to Bool

[20:46] <ruoso> but to every object

[20:46] <ruoso> every object can be coerced to a native bool according to its own rules

[20:47] <ruoso> that's why I tried to avoid the term "coercion"

[20:47] *** explorer left
[20:47] <pmichaud> I tend to think of it as "asked for its boolean value" instead of "coercion"

[20:47] <ruoso> right... 

[20:47] <pmichaud> but they're essentially the same.  The way we get an object's string value is through its .Str method

[20:48] <ruoso> but usually coercions doesn't return such a small set of possible values

[20:48] <ruoso> but that doesn't really matter

[20:49] <jnthn> Depends how many values you can represent in the type being coerced to ;-)

[20:49] <ruoso> what does matter is that you need a native bool at some point

[20:49] <pmichaud> anyway, I have another task to work on now -- I'll read scrollback later in case anything else comes up.

[20:49] <ruoso> jnthn, that's the point... a non-native Bool can have several instances

[20:50] <jnthn> Yes.

[20:50] <ruoso> a non-native Bool can be simply something that says true to .^does(Bool)

[20:50] <ruoso> it might not even be an instance of Bool at all

[20:51] <jnthn> Sure, I prefer to talk of it in that case as something that does the Bool role.

[20:51] <ruoso> I still don't see what the Bool role does....

[20:51] <ruoso> but that's another issue

[20:51] <jnthn> But yes, I get your point. At some point we need to have something - at a low level - that is something we can say "is it 0 = false or otherwise"

[20:52] <ruoso> yes... I was even thinking that instead of recursing into .true calls

[20:52] <[particle]> the Bool role defines the .Bool method

[20:52] <jnthn> As well as the .True and .False methods, since it's an enum, but yes.

[20:52] <jnthn> It doesn't define any storage.

[20:52] <[particle]> ayep

[20:53] <ruoso> it might be simpler to assume that anything not "native false" is true in the return of .true

[20:53] <jnthn> I kinda assumed we'd go that way, yes.

[20:54] <ruoso> that means method true { 0 } means true

[20:54] <jnthn> Erm?

[20:54] <ruoso> since 0 is not a native bool

[20:54] <jnthn> 0 is native false?

[20:54] <ruoso> 0 is a native int

[20:54] <jnthn> Ah...

[20:55] <ruoso> maybe it could handle native types specially..

[20:55] <ruoso> and have exceptions for, say, 0

[20:55] <jnthn> I think that we'd want to have something like method true as bool { 0 }

[20:55] <jnthn> So we coerce to a native bool

[20:56] <ruoso> but what if the user doesn't define the return of the method?

[20:56] <ruoso> are we going to special case the 'method true'?

[20:56] <ruoso> (that wouldn't be that weird)

[20:56] <ruoso> (since it's such an important method)

[20:57] <jnthn> We could perhaps do that...

[20:57] <jnthn> I generally don't like special cases...but nothing better comes to mind.

[20:57] <jnthn> I think that if we discourage people from implementing .true themselves we'd make it less of an issue anyway.

[20:58] <ruoso> but how many use cases you see for people re-implementing true?

[20:58] <ruoso> 0 but True 

[20:58] <ruoso> already solves most of that cases

[20:58] <jnthn> That is, follow my suggestion of .true is implemented by calling .Bool and then coercing it to a bool and returning it.

[20:58] <ruoso> but that doesn't solve the issue

[20:59] <ruoso> because one might still re-implement .true

[20:59] <jnthn> Object does the Bool role and defines it in terms of definedness, as I believe is already spec'd.

[20:59] <ruoso> it implements a true method, yes

[20:59] <jnthn> And then we direct people to implement a Bool method.

[20:59] <ruoso> that can be overriden

[20:59] <jnthn> Well, I was kinda hoping we could perhaps get back to Bool really being just an enum.

[20:59] <ruoso> I don't see much difference in telling people to write .Bool instead of .true

[20:59] <[particle]> the true method is not defined by the Bool role

[20:59] <ruoso> it's defined by Object

[21:00] <jnthn> From a language design point of view, it's nicer to say "to state how to represent yourself as a certain type you write a method by that name"

[21:00] <ruoso> I still don't see the use for the non-native Bool

[21:01] <ruoso> but that will require additional coercions by definition

[21:01] <[particle]> in my language, Bool autopromotes to Int after you prefix:++ twice

[21:01] <jnthn> ...

[21:01] <[particle]> in my friend's language, it gives an overflow error

[21:01] *** cpfr left
[21:01] <[particle]> in Perl 6, it throws an exception

[21:02] <jnthn> Oh?

[21:02] <jnthn> I thought it just stayed at 1.

[21:02] <jnthn> erm, true

[21:02] <jnthn> :-)

[21:02] <pmichaud> incrementing a Bool in Perl 6 always leaves it at "true"

[21:02] <jnthn> ruoso: I think the problem is that we want to say things like 0 but True, so we need an enum.

[21:02] <[particle]> actually, yes, it stays at True

[21:02] <jnthn> Or a role.

[21:03] <ruoso> jnthn, it could be a role that re-implements true

[21:03] <ruoso> .true I mean

[21:03] <jnthn> Yes, fur sure.

[21:03] <jnthn> It's just if we go that way, it's not a real enum.

[21:03] <ruoso> well... 

[21:03] <jnthn> Which is fine, but the spec should also stop claiming it is.

[21:03] <ruoso> Bool can be an enum

[21:04] <ruoso> that has True and False roles as possible values

[21:04] <ruoso> the prototypes

[21:04] <jnthn> We can make it look like and feel like an enum

[21:04] <[particle]> i'm sitting here next to Bool, and it's *begging* me to be an enum

[21:04] <jnthn> But if we really in the prelude wanted to just write enum Bool <True False>;

[21:04] <[particle]> that's all i'm saying.

[21:05] <jnthn> And nothing else

[21:05] <ruoso> but in Perl 6, if it looks like something, it is something

[21:05] <jnthn> Then that isn't going to provide the .ture method

[21:05] <jnthn> Sure, we can make it an enum-ish thing that's just a bit more special.

[21:06] <ruoso> can't an enum hold two prototypes of the roles?

[21:06] <ruoso> where Bool is an enum, and the values of it are the role True prototype and the role False prototype

[21:07] <jnthn> Are role prototypes actually mentioned in S12?

[21:07] <jnthn> But anyway, that's basically what it boils down to, if we are both thinking the smae thing when we're saying "role prototype" :-)

[21:09] <ruoso> well... there must be something stored in the namespace

[21:09] <jnthn> An enum as I have it, is kinda a role that introduces a storage location and methods of the name of the enum and the names of the values.

[21:09] <ruoso> I call it prototype

[21:09] <ruoso> l)

[21:09] <ruoso> ;)

[21:09] <jnthn> Ah, OK. Works for me.

[21:10] <jnthn> And the storage location can hold the current value.

[21:10] <ruoso> and the current value is the role "prototype" ;)

[21:10] <jnthn> Yes.

[21:10] <jnthn> Which are also in the namespace, as you sya.

[21:10] <jnthn> *say

[21:10] <ruoso> so, no .Bool...

[21:10] <ruoso> right?

[21:11] <jnthn> Well, if you declare an enum Bool, then when you "but True" then you get a method Bool.

[21:11] <ruoso> right... but nobody actually uses it

[21:11] <jnthn> You'd get a .Bool, .True and .False

[21:12] <jnthn> Well, to me it seems we need to pick what people are going to use.

[21:12] <ruoso> but the True role re-defines .true

[21:12] <ruoso> as well as the False role

[21:12] <ruoso> the "if" statement_control calls .true

[21:12] <ruoso> and anyone can override .true

[21:12] <jnthn> Yes.

[21:13] <jnthn> So maybe we'll be better off saying True and False are roles that override .true, and there is no Bool enum?

[21:13] <jnthn> And no .Bool?

[21:13] <ruoso> well... maybe Bool is a subset

[21:14] <jnthn> subset Bool where True|False; # ?

[21:14] *** rindolf left
[21:14] <ruoso> yeah... something like that

[21:14] <moritz_> well, Bool is specced as an enum ;)

[21:14] <masak> am I right in thinking that the .fmt method should be added under the headings Scalar, Array and Hash in S29? (and not, say, all three variants under Any)

[21:14] <jnthn> moritz_: Oh no, don't start the whole circle again!

[21:15] <masak> (.fmt is defined at S02:1349)

[21:15] <moritz_> circles++ ;-)

[21:15] * ruoso home &

[21:15] * ruoso later &

[21:15] <masak> in this discussion, even the circles are going in circles!

[21:15] <masak> :P

[21:15] *** ruoso left
[21:17] *** zamolxes joined
[21:25] <masak> should the delete and exists methods on Array, and the :delete and exists methods on Hash in S29 be removed?

[21:26] <moritz_> I think TimToady removed them from the spec tests and from STD.pm

[21:27] <masak> I'll take that as a yes.

[21:27] <masak> though I wouldn't want to remove them without thinking about remaking them into something else first

[21:27] <masak> right now, I'm adding .fmt to S29 (see my question above)

[21:28] <masak> it's going pretty well

[21:28] <masak> S29 needs a lot of love(tm)

[21:30] <masak> do the second arguments in the Array and Hash versions of .fmt have defaults? for that matter, do the first?

[21:30] <masak> is .fmt tested somewhere?

[21:31] <moritz_> t/syntax/interpolation/fmt.t

[21:31] <moritz_> t/spec/S02-names_and_variables/fmt.t

[21:32] <masak> moritz_++

[21:32] <masak> cool! I'll check them out immediately.

[21:36] <masak> hm. I would go so far as to say that the first one doesn't really exercise the full potential of fmt. it does a lot of other seemingly important things, though.

[21:37] <moritz_> aye

[21:38] <masak> hm again, seems I'd be better off putting the list version of .fmt under the List heading, not Array. I don't agree that the scalar version should be under Str, though.

[21:38] *** Aisling joined
[21:38] <masak> anyway, the second test file pretty much rocks.

[21:39] <masak> it talks about .fmt for Pair -- is there any inheritence relation between Hash and Pair in Perl 6?

[21:40] <jnthn> I'm not aware of one.

[21:40] <masak> so, one more method needed in S29.

[21:42] *** rdice_ joined
[21:45] <masak> what about Array/List? an Array isa List?

[21:48] *** eternaleye left
[21:48] <jnthn> masak: In Rakudo, at the moemnt, yes.

[21:48] <pmichaud> pugs:  say Array ~~ List;

[21:48] *** rdice left
[21:48] <p6eval> pugs: OUTPUT[1␤]

[21:48] <pmichaud> pugs:  say List ~~ Array;

[21:48] <p6eval> pugs: OUTPUT[␤]

[21:49] <pmichaud> pugs:  say [1] ~~ List;

[21:49] <p6eval> pugs: OUTPUT[1␤]

[21:49] <masak> jnthn: I'm working at the S29 level right now, so that answer is only partly helpful :)

[21:49] <pmichaud> pugs:  say <a b> ~~ Array;

[21:49] <p6eval> pugs: OUTPUT[1␤]

[21:49] <pmichaud> pugs:  say (1,2) ~~ Array;

[21:49] <p6eval> pugs: OUTPUT[1␤]

[21:49] <pmichaud> that looks odd.

[21:49] <jnthn> I'd expect those to be a list, but not an Array.

[21:50] <pmichaud> agreed.

[21:51] *** smg joined
[21:52] <masak> S29 doesn't even have a heading 'Pair'

[21:52] <masak> creating one...

[21:54] <masak> what default sigil does a Pair object have? '%'?

[21:55] <moritz_> $

[21:56] <jnthn> masak: Having the various roles like Positional and stuff in there would be good too.

[21:56] <masak> jnthn: I'll put it on my list which I just made.

[21:57] <moritz_> masak: and when you are at it... many methods now actually live in Any, not in Str|List|Complex|$Whatever...

[21:59] <masak> moritz_: yes, that's true. that goes on the list too.

[21:59] <masak> the problematic thing with S29 is that it's vital, but almost no-one has the final answers.

[21:59] <masak> so you'll all have to help me.

[21:59] <moritz_> masak.list.elems++ ;-)

[21:59] <masak> just putting my money where my mouth is.

[22:00] <masak> the 'S29 needs love(tm)' campaign is sponsored by the November 'good deed every day(tm)' drive. :)

[22:01] <masak> ok, review appreciated: http://nopaste.snit.ch/14497

[22:02] <moritz_> uhm, is .fmt really a wrapper around sprintf? I thought it was somethiing different...

[22:03] <moritz_> but I suspect you have done more in-dpeth research than me ;)

[22:03] <masak> S02:1349

[22:03] <masak> "To get a formatted representation of any scalar value, use the C<.fmt('%03d')> method to do an implicit C<sprintf> on the value."

[22:04] <moritz_> masak: other methods in S29 that are defined in multiple classes are listed in just one

[22:04] <moritz_> * in just one block

[22:04] <masak> moritz_: hence my question earlier which no-one answered :)

[22:04] <masak> I can put it in one block. where?

[22:04] <moritz_> sorry ;)

[22:06] <moritz_> dunno, perhaps Str

[22:06] <masak> because that's the return value? ok.

[22:06] <moritz_> the common denominator

[22:07] <masak> aye.

[22:09] <masak> I'll put it after sprintf. people standing on higher shoulders can refactor later if need be.

[22:14] <masak> new attempt: http://nopaste.snit.ch/14498

[22:14] <masak> I'm not sure if C<> thingies can be line-broken like that, but I assume they can.

[22:15] <masak> I hope the descriptions are not exceedingly implementation-y

[22:17] <masak> no new comments? ok, good, I'll commit then.

[22:18] *** xinming_ left
[22:18] <pugs_svn> r22904 | masak++ | [Spec/Functions.pod] added .fmt

[22:18] <moritz_> masak++

[22:19] <masak> S29++

[22:19] <masak> given enough love, S29 will start loving people back :)

[22:19] <masak> that's what we want.

[22:20] <SamB> yes, but ++ only indicates like

[22:20] <SamB> not love

[22:21] <masak> SamB: aye. I meant S29.chars++, in which it only indicates size. :)

[22:24] *** rdice_ left
[22:24] *** zamolxes left
[22:26] *** ilbot2 left
[22:27] <masak> oh. the second test file actually tests for ',' as a default second arg to the array version of .fmt

[22:27] <masak> I guess that actually is a good default.

[22:27] <masak> adding.

[22:28] *** pedrob left
[22:37] *** adc_Penner left
[22:42] *** hanekomu left
[22:45] *** pbuetow left
[23:05] <pugs_svn> r22905 | masak++ | [Spec/Functions.pod] various changes to .fmt commit:

[23:05] <pugs_svn> r22905 | masak++ | * C<> no longer line-broken

[23:05] <pugs_svn> r22905 | masak++ | * fixed some %p and %h which should be $p

[23:05] <pugs_svn> r22905 | masak++ | * added defaults for the $separator param in the List and Hash versions

[23:05] <pugs_svn> r22906 | masak++ | [Spec/Functions.pod] s/array/list/ in .fmt description

[23:08] <masak> the first pancace never looks quite right :)

[23:08] <masak> s/cace/cake/

[23:13] <masak> any opinions on what the default $separator should be for the List .fmt? suggestions are ' ' (from the test file), ',' (what I wrote in S29) and ', ' (example from S02)

[23:15] *** elmex left
[23:17] *** pmurias joined
[23:18] * masak defaults to ' ' in the meantime, claiming p5 as prior art

[23:19] <masak> although its default is '', come to think of it

[23:19] <masak> :/

[23:19] *** ab5tract left
[23:23] *** eternaleye joined
[23:29] *** bacek_ joined
[23:31] *** pmurias left
[23:33] *** xinming joined
[23:33] *** hercynium left
[23:37] *** dalek left
[23:38] <buu> buubot: eval: my @x = 1,2,3,4; "@x"

[23:38] <buubot> buu:  1

[23:38] <buu> =[

[23:38] *** dalek joined
[23:38] <buu> buubot: eval: my @x = (1,2,3,4); "@x"

[23:38] <buubot> buu:  "1 2 3 4"

[23:39] <masak> buu: ah, look at that.

[23:39] * masak makes the appropriate change.

[23:40] <masak> buu: thanks.

[23:43] *** d4l3k_ joined
[23:43] *** pmichaud_ joined
[23:43] *** pmichaud left
[23:44] *** jnthn left
[23:44] <pugs_svn> r22907 | masak++ | [Spec/Functions.pod] made default $separator on List::fmt ' ', with

[23:44] <pugs_svn> r22907 | masak++ | Perl 5 and t/spec/S02-names_and_variables/fmt.t as prior art

[23:47] *** Alias_ joined
[23:49] *** PerlJam left
[23:49] *** pmichaud joined
[23:50] *** d4l3k_ left
[23:50] *** pmichaud_ left
[23:51] *** wolverian left
[23:52] *** pedrob joined
[23:53] *** d4l3k_ joined
[23:55] *** dalek left
[23:55] *** pmichaud left
[23:57] *** bacek_ left
[23:57] *** Exodist left
[23:57] *** bacek left
[23:57] *** nothingmuch left
[23:57] *** yahooooo3 left
[23:57] *** Maddingue left
[23:57] *** lambdabot left
[23:57] *** d4l3k_ left
[23:58] *** bacek_ joined
[23:58] *** Exodist joined
[23:58] *** bacek joined
[23:58] *** nothingmuch joined
[23:58] *** lambdabot joined
[23:58] *** yahooooo3 joined
[23:58] *** Maddingue joined
[23:58] *** jnthn joined
[23:59] *** dalek joined
