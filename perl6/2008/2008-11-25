[00:01] *** bacek__ joined
[00:04] <masak> what's the best-looking way to emulate for @array.kv -> $ix, $elem { ... } in Perl 5?

[00:05] *** Jedai joined
[00:05] *** bacek joined
[00:05] *** bacek_ left
[00:07] *** bacek__ is now known as bacek_

[00:10] <bacek_> masak: my @array; my $kv = sub { my @s = @array; my $index = 0; my @res; push @res, $index++; push @res, shift @array; @res }; while(my ($k,$v) = $kv->()) { ...}

[00:11] <masak> bacek_: aye.

[00:11] <masak> that works.

[00:11] <Limbic_Region> masak - with or without modules?

[00:11] <masak> Limbic_Region: give me all you've got. :)

[00:11] <bacek_> masak: probably. I wrote it without checking :)

[00:12] <Limbic_Region> I think mapcar from Algorithm Loops does what you want more naturally

[00:12] <Limbic_Region> combine that with n_at_a_time from List::MoreUtils and you are done

[00:12] <Limbic_Region> oh wait

[00:13] <Limbic_Region> List::MoreUtils has zip and natatime

[00:13] <masak> Limbic_Region++

[00:13] <masak> I should learn List::MoreUtils better

[00:16] <Limbic_Region> my $it = natatime(2, zip @keys, @vals); while (my $k, $val = $it->()) { ... } # something like that

[00:16] <masak> natatime :) I like.

[00:16] <bacek_> natatime(2, zip 0..$#array, @array)

[00:18] * Limbic_Region rolls his own iterators so is not overly familiar with List::MoreUtils other than a good memory for where such functions might be found

[00:19] <Limbic_Region> mapcar from Algorithm::Loops is far more powerful btw than List::Util's zip but you just need the simple zip anyway

[00:22] <masak> mm

[00:22] <masak> Iäll look into Algo::Loops as well.

[00:22] <masak> s/ä/'/ # juggling keyboard layouts

[00:24] *** mtrimpe joined
[00:25] <Limbic_Region> that was more FYI than anything else - it is unnecessary for this task

[00:25] <Limbic_Region> but if you are interested in arbitrarily nested loops - Algorithm::Loops freaking rawks

[00:26] <Limbic_Region> and you might be interested in an article I wrote about it - http://perlmonks.org/?node=arbitrarily+nested+loops

[00:26] <lambdabot> Title: Arbitrarily Nested Loops

[00:26] *** cognominal joined
[00:28] <masak> I am. thank you.

[00:34] *** jhorwitz left
[00:40] *** mtrimpe left
[00:48] <masak> I like what Mark J. Reed is saying in the thread 'sign() always returns 1 when $x ~~ Complex'. (he's saying that sqrt(-1) should return i, because that'd be DWIMmiest.) is there a way to make complex functions DWIM and still retain some kind of type system sanity?

[00:50] <Limbic_Region> masak - I am pretty sure there is a complex number module on CPAN for perl 5.  Not sure what you are trying to accomplish but I don't think returning a literal 'i' is the right thing

[00:50] <masak> I'm back at talking about the design of Perl 6.

[00:50] <Limbic_Region> returning a complex number object that happens to have the value of i is better IMO

[00:50] <Limbic_Region> ah

[00:51] <masak> just thinking about what would be a good combination of user-nice and type-nice

[00:51] <Limbic_Region> well, unless the type system supports complex numbers natively than sqrt(-1) should throw an exception or return undef but not 'i'

[00:51] <masak> the type system does support complex numbers natively.

[00:52] <masak> RTFS :)

[00:52] * Limbic_Region stopped keeping up with the Ss when audreyt had to take her sabattical and pugs when stagnant

[00:52] <Limbic_Region> I am lucky to follow #perl6 and #parrot more than twice a week

[00:53] <masak> Limbic_Region: you're not at all enthused by Rakudo?

[00:53] <masak> (I am.)

[00:54] <Limbic_Region> oh, very much so

[00:54] <Limbic_Region> but in the interim, I has a 2nd daughter

[00:55] <Limbic_Region> and a promotion (more responsibility)

[00:55] <Limbic_Region> my wife is learning to drive and applying for her citizenship

[00:55] <Limbic_Region> etc, etc, etc

[00:55] <masak> OIC

[00:55] <Limbic_Region> you know the saying - you need to pick your battles

[00:56] <Limbic_Region> in my case, you need to pick your time syncs

[00:56] <Limbic_Region> sinks

[00:56] <masak> aye

[00:56] <masak> speaking of time sinks, time to go home and sleep

[00:56] <Limbic_Region> I still build parrot and rakudo regularly since there aren't many Win32/MinGW or Win32/Cygwin folks

[00:56] <Limbic_Region> sleep well

[00:56] <masak> thank you

[00:56] <masak> see you around!

[00:56] *** masak left
[00:57] *** mbtrimpe joined
[01:02] *** slavik joined
[01:02] <slavik> for rakudo, where can I setup the defaul library path?

[01:02] <Limbic_Region> slavik - best to ask on #parrot on irc.perl.org

[01:03] <Limbic_Region> though a lot of folks hang out in both places

[01:03] <jnthn> slavik: PERL6LIB

[01:03] <jnthn> (Environment variable)

[01:03] <jnthn> IIRC

[01:04] * jnthn wonders if slavik is Slavic. :-)

[01:05] <slavik> jnthn: yes and is there a config for it or some such?

[01:06] *** mbtrimpe left
[01:06] <jnthn> slavik: As in, a command line option, or some default config file we load it from?

[01:06] <slavik> the latter

[01:06] <slavik> also, where can I read about adding binds to a C module into Perl6?

[01:07] <slavik> bindings*

[01:07] <slavik> or does rakudo have to be built with bindings?

[01:08] <jnthn> slavik: Looking at the code at the moment, we don't load any default yet.

[01:08] <jnthn> Or that's how it looks to me...

[01:09] <slavik> so PERL6LIB?

[01:09] <jnthn> Yes, just set that

[01:09] <slavik> k

[01:09] <jnthn> Separate paths with :

[01:09] <jnthn> On bindings

[01:09] <slavik> same as all other PATH/LIB vars

[01:09] <slavik> heh

[01:09] <jnthn> We don't have a way to directly do this from Perl 6 yet.

[01:09] <slavik> p00p

[01:09] <jnthn> However, you don't need to compile them in or write any C either.

[01:10] <slavik> err?

[01:10] <jnthn> You can write them in PIR, or at lesat some thin layer.

[01:10] <slavik> where can I read about that?

[01:10] <jnthn> And then call those from Perl 6 code.

[01:10] <Limbic_Region> PIR = parrot intermediate representation

[01:10] <slavik> I should prolly look at the OpenGL pir code, right?

[01:10] <Limbic_Region> it is one step above PASM = Parrot assembly language

[01:10] <jnthn> slavik: Yes, that is exactly what I was going to point you to. :-)

[01:11] <Limbic_Region> but don't let that scare you - it is pretty easy to read

[01:11] <jnthn> That is known to be usable from Perl 6 too.

[01:11] <slavik> hmm

[01:11] <slavik> is PIR to PASM like C is to ASM?

[01:11] <jnthn> See for more on NCI examples/nci in Parrot

[01:11] <slavik> or am I off?

[01:12] <jnthn> PIR is an intermediate language, a bit like the .Net CLR's IL

[01:12] <slavik> haven't seen that either

[01:13] *** IRSeekBot joined
[01:13] <jnthn> It is a bit higher level than the assembly. You don't have to worry about register allocation. You can write function calls quite easily, and it generates the several instructions that are actually needed to make the call.

[01:13] <jnthn> So it's a tad more pleasant than assembly.

[01:13] <jnthn> I hope that we'll find a way soonish to be able to do NCI directly from Perl 6.

[01:16] <slavik> hmm

[01:16] <slavik> pir doesn't look all that pleasent ... looks like it is stack based or something

[01:16] <slavik> set arguments, then call function

[01:16] <jnthn> slavik: No, it's register based.

[01:17] <jnthn> slavik: You don't need to write a lot of it to make a basic interface around a C library that you can then call from Perl 6.

[01:17] <slavik> .begin_call .set_arg 1 ,set_arg 2 .nci_call funcname .end_call 

[01:17] <jnthn> eww

[01:17] <jnthn> Yes, OK, there is *that* syntax. :-)

[01:17] <slavik> jnthn: that's what I see in an sdl pir example

[01:17] <slavik> jnthn: is there a write up?

[01:18] <slavik> like a how to or something?

[01:18] <jnthn> Yeah, see e.g. win32api.pir for something nicer

[01:18] <slavik> loadlib does the dynamic loading?

[01:18] <jnthn> Yes

[01:18] <slavik> hmm, I think pir so far looks way better than XS ;)

[01:18] <jnthn> dlfunc looks up a symbol

[01:18] <jnthn> there is http://www.parrotcode.org/docs/pdd/pdd16_native_call.html

[01:18] <lambdabot> Title: NCI conventions and definitions - parrotcode

[01:19] <jnthn> Yes, you don't have to write any C. ;-)

[01:19] <slavik> I don't mind C ...

[01:19] <slavik> I like C, but not for text processing ;)

[01:19] *** thestarslookdown joined
[01:19] <jnthn> Oh, I don't mind writing C. But when it comes to wanting to ship bindings, not requiring the end user to have a C compiler to install it is nice.

[01:20] <slavik> hmm, would it be possible to generate a pir given a .so file

[01:20] <jnthn> Not from that, but I think from a .h file there is a tool

[01:20] <slavik> jnthn: I am of the opinion that linux without a C compiler is like a car on 3 wheels ... doable, but why?

[01:20] <slavik> jnthn: by tool, you mean Perl6? :P

[01:21] *** km3 left
[01:21] <jnthn> I think it actually parses the headers using a Perl 6 grammar... ;-)

[01:21] <slavik> figures

[01:21] <jnthn> I honestly don't know much about it, I'm afraid - ask in #parrot, especially tewk...

[01:21] <slavik> Perl6 building Perl6 bindings ... kind of scary

[01:21] <jnthn> It's fairly new, and I didn't play with it just yet.

[01:21] <slavik> what if it becomes self-sentient or something

[01:22] <jnthn> We sit and pray for a segfault.

[01:22] <jnthn> :-)

[01:22] <slavik> jnthn: I had an idea to have a header which included all other headers in the library and then pipe it through the CPP to get a nice flat file and process that

[01:22] <slavik> jnthn: ^^

[01:23] <jnthn> Cunning trick!

[01:23] <jnthn> :-)

[01:23] <slavik> jnthn: so, pir can be thought of as describing to parrot what the functions are?

[01:23] <jnthn> Yes, pretty much.

[01:23] <slavik> because by that extent, you could have parrot load ANY library without any bindings

[01:24] <slavik> it could then process the .h if available and bam, done

[01:24] <jnthn> That's the dream. :-)

[01:24] <slavik> also, what about types and such? they are converted automatically?

[01:24] <slavik> because Perl5 bindings have glVertex() no glVertex2f() and the others

[01:25] <jnthn> I believe that the type conversions are handled, yes.

[01:27] *** sri_kraih_ left
[01:31] <slavik> what if I want to combine multiple versions of the same basic function that have different number of arguments?

[01:31] <slavik> do I have to rely on some default/generic value?

[01:32] <jnthn> Where do you mean? When writing PIR?

[01:32] <jnthn> You can use :optional

[01:32] <jnthn> To mark a parameter as optional

[01:32] <jnthn> And you can also declare multi subs

[01:34] *** km2 joined
[01:35] * jnthn -> sleep

[01:39] <slavik> ty, night

[02:04] *** thestarslookdown left
[02:04] <pugs_svn> r23069 | lwall++ | [gimme5] make sure STD.pmc ends with 1;

[02:04] <pugs_svn> r23069 | lwall++ | [STD] add substr to list of recognized methods following .=

[02:04] *** [particle]1 left
[02:06] *** spx2 left
[02:06] *** spx2 joined
[02:12] *** stephens left
[02:13] <TimToady> though arguably, substr produces strings, which might be indicative of an attempt to do concatenation, but the test suite uses $x .= substr($pos)

[02:15] <slavik> TimToady: has anyone measured the overhead of calling C libraries from rakudo?

[02:16] <wayland76> slavik: The script for generating C bindings is called nci_gen.pl

[02:16] <slavik> wayland76: ty

[02:16] <slavik> wayland76: it's not a fool proof method, though, is it?

[02:17] <wayland76> At the moment, it may not be, but I believe they're intending it to be

[02:17] <slavik> k

[02:17] <wayland76> I looked at it once, but it was broken when I tried it and, though it's fixed now, I never got back to it :)

[02:18] <wayland76> parrot/compilers/ncigen/nci_gen.pl

[02:18] <slavik> will take a look

[02:20] <slavik> HA! fuck that, there's already SDL there ^^

[02:21] <slavik> err, there's an SDL pir :)

[02:28] <slavik> ha, there IS data dumper :)

[02:31] *** elmex left
[02:32] *** alc joined
[02:38] *** slavik left
[03:04] *** eternaleye left
[03:09] *** hercynium joined
[03:30] *** hercynium left
[03:34] *** hercynium joined
[03:37] *** alester_ joined
[03:39] *** dalek left
[03:40] *** dalek joined
[03:42] *** Psyche^ joined
[03:45] *** jnthn joined
[03:47] *** wolverian joined
[03:53] *** wolverian left
[03:53] *** wolverian joined
[03:54] *** dalek left
[03:55] *** dalek joined
[03:57] *** pmichaud joined
[03:57] *** pugs_svn joined
[03:58] *** Patterner left
[03:58] *** Psyche^ is now known as Patterner

[03:58] *** d4l3k_ joined
[03:58] *** wolverian left
[03:58] *** wolverian joined
[04:06] *** d4l3k_ left
[04:06] *** pmichaud left
[04:07] *** PerlPilot joined
[04:07] *** PerlPilot left
[04:08] *** Southen_ joined
[04:10] *** d4l3k_ joined
[04:10] *** pmichaud joined
[04:15] *** pmichaud left
[04:15] *** Southen left
[04:17] *** pugs_svn left
[04:17] *** pugs_svn joined
[04:18] *** Limbic_Region left
[04:22] *** PerlJam joined
[04:22] *** dalek left
[04:23] *** d4l3k_ is now known as dalek

[04:24] *** pmichaud joined
[04:30] *** Entonian joined
[04:36] *** km2 left
[04:38] *** km2 joined
[04:48] *** [particle]1 joined
[04:48] *** [particle]1 left
[05:04] *** bacek left
[05:09] *** bacek joined
[05:26] *** Entonian left
[05:48] *** jjore joined
[06:03] *** hercynium left
[06:41] *** DemoFreak joined
[06:58] *** ashizawa joined
[07:26] *** alester_ left
[07:27] *** Bzek joined
[07:38] *** jferrero joined
[07:38] *** sri_kraih joined
[07:39] *** adc_penner joined
[08:20] *** pbuetow joined
[08:23] *** smallfish joined
[08:35] *** bacek_ left
[08:38] *** pbuetow left
[08:46] *** km2 left
[08:52] *** iblechbot joined
[08:54] *** Jedai left
[09:07] *** elmex joined
[09:08] *** ejs joined
[09:12] *** Jedai joined
[09:24] *** DemoFreak left
[09:26] *** adc_penner left
[09:43] *** agentzh left
[09:46] *** agentzh joined
[09:49] *** jimmy__ joined
[09:51] *** jimmy__ left
[09:58] *** renormalist joined
[09:59] *** smallfish left
[10:21] <pugs_svn> r23070 | hinrik++ | First stab at Pod highlighting

[10:22] <literal> test, please :)

[10:26] *** smg joined
[10:35] *** alc left
[10:36] *** iblechbot left
[10:57] * moritz_ writes tests nearly every day

[10:59] <moritz_> but that's not what you meant, no? :-)

[11:00] <moritz_> tested on STD.pm, it doesn't seem to do very much, but doesn't cause troubles either

[11:18] *** pmichaud left
[11:18] *** pmichaud joined
[11:18] *** pnu joined
[11:18] *** yahooooo joined
[11:18] *** diakopter joined
[11:32] *** wayland76 left
[11:58] *** iblechbot joined
[11:58] *** jferrero left
[12:10] *** c9s left
[12:16] *** c9s joined
[12:20] *** ejs_ joined
[12:20] *** ejs left
[12:53] *** sri_kraih_ joined
[13:06] *** mtrimpe joined
[13:07] *** sri_kraih left
[13:40] *** ashizawa left
[13:56] *** pugs_svn left
[13:56] *** pugs_svn joined
[14:02] *** masak joined
[14:11] *** apeiron left
[14:17] *** smg left
[14:20] *** apeiron joined
[14:31] *** ejs_ left
[14:31] *** ejs_ joined
[14:33] <masak> std: my $a = *-4; say $a

[14:33] <p6eval> std 23070: OUTPUT[STD.pm did not return a true value at tryfile line 3.␤BEGIN failed--compilation aborted at tryfile line 3.␤]

[14:36] <moritz_> installing YAML::Syck on timtowtdi.org...

[14:37] <moritz_> std: my $a = *-4;

[14:37] <p6eval> std 23070: OUTPUT[can't create lex/STD/nofun_01.store: Permission denied at Cursor.pm line 521␤00:05 77m␤]

[14:38] <moritz_> oh my, why can't it just work?

[14:38] * moritz_ thinks about giving up the distinction between users 'evalenv' and 'evalbot'

[14:40] <masak> why is the distinction there in the first place?

[14:43] <moritz_> for security reasons

[14:44] <PerlJam> I feel more secure.  :)

[14:45] <masak> 'you are not authorized to receive this answer'

[14:45] <moritz_> std: my $a = *-4;

[14:45] <p6eval> std 23070: OUTPUT[00:05 82m␤]

[14:46] <moritz_> IMHO it's quite a good idea that a process doesn't have write permissions to its executable :)

[14:46] <moritz_> uhm, not quite the answer you're interested in, I guess

[14:46] <moritz_> it just calls tryfile

[14:46] <masak> I don't really understand the answer

[14:47] <moritz_> it needed 5 seconds and 83 MB RAM :)

[14:47] <masak> that's a lot of RAM

[14:48] <moritz_> std: 3 * (

[14:48] <p6eval> std 23070: OUTPUT[############# PARSE FAILED #############␤(Possible runaway string from line 1 to line 1)␤Can't understand next input--giving up at /tmp/UE4PtSghjf line 0:␤------> [32m[31m[0m␤    expecting semicolon list␤00:05 80m␤]

[14:49] <moritz_> masak: so if you see just the run time + mem usage it means "parsed OK"

[14:49] <masak> moritz_: I'd prefer a simple 'yes' or 'no' from IRC STD

[14:50] <masak> is that too much to ask? :P

[14:50] <moritz_> masak: feel free to hack evalbot.pl :)

[14:50] <masak> urgh

[14:50] <masak> anyone else have a tuit to spare?

[14:51] <moritz_> masak: I made the mistake earlier of using a modified version of tryfile, which then caused a conflict in svn, so I decided it wasn't a good idea, but didn't implement a better idea either

[14:51] <masak> oic

[14:57] <masak> back instead to the topic at hand: I'm thinking *-4 is evaluated inside the brackets of an array index, and that the result will be a Whatever object with some offset attribute set to -4

[14:57] <masak> does that sound sane?

[14:58] <jnthn> Ouch...maybe...

[14:58] * jnthn hadn't thought about this one so much

[14:58] <moritz_> masak: I think that's the case, yes

[14:59] <masak> if it doesn't throw off any other plans, I could have a go at implementing it today.

[14:59] * moritz_ wonders if the Whatever star is actually a backdoor to get symbolic calculations done in Perl 6 :-)

[15:00] <rakudo_svn> r33191 | jonathan++ | [rakudo] Eliminate a now-unrequired global.

[15:00] <masak> moritz_: all is fair if you predeclare. :)

[15:01] <moritz_> or maybe * ist just a hidden closure, so that if you say 'my $x = *-4; $x(0)' you get -4

[15:03] <masak> interesting idead

[15:03] <masak> *idea

[15:04] <masak> and array indices would then be called with $ix(@a.elems)

[15:07] <moritz_> however there needs to be some kind of introspection still for infinite ranges

[15:10] *** renormalist left
[15:12] *** renormalist joined
[15:13] *** renormalist left
[15:14] *** schmalbe joined
[15:14] *** renormalist joined
[15:14] *** renormalist left
[15:15] *** renormalist joined
[15:16] *** alester left
[15:16] <masak> moritz_: I'd say my idea wins over yours in terms of simplicity :)

[15:17] <moritz_> masak: right :)

[15:17] <moritz_> masak: but mine wins in terms of creativity :)

[15:17] <masak> definitely.

[15:18] *** rindolf joined
[15:31] *** cognominal left
[15:32] *** alester joined
[15:35] *** Lorn joined
[15:39] *** mncharity joined
[15:41] *** Abraham joined
[15:46] *** ZuLuuuuuu joined
[15:47] *** smg joined
[15:58] *** stephens joined
[16:02] <mncharity> thanks TimToady :)  (re nesting)

[16:03] *** lrcg joined
[16:08] *** Exodist joined
[16:09] *** Exodist left
[16:09] *** Exodist joined
[16:15] *** ZuLuuuuuu left
[16:16] *** mtrimpe left
[16:16] *** mtrimpe joined
[16:26] *** hercynium joined
[16:28] *** lrcg left
[16:36] *** jhorwitz joined
[16:37] *** dukeleto_ joined
[16:37] *** ejs_ left
[16:39] *** ejs_ joined
[16:49] *** riffraff joined
[16:51] *** justatheory joined
[17:00] <rakudo_svn> r33192 | jonathan++ | [rakudo] Recognize ;; parameter separator; set invocant and multi_invocant fields in the signature.

[17:00] *** Abraham left
[17:02] *** mtrimpe left
[17:05] *** mtrimpe joined
[17:07] *** ruoso joined
[17:15] *** ejs_ left
[17:20] <rakudo_svn> r33193 | pmichaud++ | Merge lexicals branch into trunk.  "make realclean" required (new opcodes).

[17:21] <ruoso> Hello!

[17:21] *** dukeleto_ left
[17:21] *** riffraff left
[17:22] *** riffraff joined
[17:32] <ruoso> rakudo: class Foo { }; say &Foo()

[17:32] <p6eval> rakudo 33193: OUTPUT[invoke() not implemented in class 'Foo'␤current instr.: '_block11' pc 25 (EVAL_12:17)␤]

[17:32] <ruoso> rakudo: class Foo { }; say &Foo;

[17:32] <p6eval> rakudo 33193: OUTPUT[Foo␤]

[17:32] <ruoso> that's strange...

[17:32] <ruoso> &Foo was supposed to be a sub that returns the class Foo, wasn't it?

[17:33] <jnthn> Oh?

[17:33] <moritz_> that seems NYI

[17:33] <jnthn> I hadn't seen that spec'd.

[17:33] <jnthn> I'd have expected an error.

[17:33] <jnthn> OTOH, type name handling is kinda funky in Rakudo at the moment...

[17:34] <ruoso> jnthn, at least that's how STD parses it

[17:34] <ruoso> std parses Foo.bar as &Foo().bar()

[17:34] <moritz_> not sure that's intended that way

[17:35] <ruoso> moritz_, it is, already confirmed by TimToady 

[17:35] <jnthn> Me either.

[17:35] <jnthn> OK, I can believe it parses that way.

[17:35] <ruoso> it kinda makes sense, since there are no bare words

[17:35] <jnthn> I'm not so sure on the whole "class definition introduces a sub of the same name" thing.

[17:36] <jnthn> I guess you can just implement invoke on a proto to return itself though. So it's no hassle if that's what's supposed to happen.

[17:36] <jnthn> But I'd like to see it in a spec before I make it work.

[17:37] * ruoso wonders if that's related to something I saw a long time ago... 

[17:37] <ruoso> rakudo: class foo { }; say foo;

[17:37] <p6eval> rakudo 33193: OUTPUT[invoke() not implemented in class 'foo'␤current instr.: '_block11' pc 19 (EVAL_11:13)␤]

[17:37] <ruoso> ok... that was a long time ago

[17:37] <jnthn> Yes, now you've found the "can't have a class with a lowercase name" thingy in Rakudo. :-)_

[17:38] <masak> is there a ticket for that?

[17:38] <jnthn> (We aren't registering stuff in the namespace as we go yet, so we use "does it start with an uppercase letter" as a heuristic)

[17:38] <jnthn> masak: I dunno, but there's a grant proposal for it. ;-)

[17:38] * masak makes a ticket, Justin Case

[17:39] <moritz_> I think we already have one, but I'm not sure

[17:40] * jnthn hopes to get that issue resolved in December

[17:40] <masak> what's December, another wiki project?

[17:40] <masak> :P

[17:42] <jnthn> Yeah! It's my secret one, implemented in Perl 7!

[17:42] <ruoso> ah... ok... so it's related to that bug...

[17:42] <ruoso> well... I think that's why Foo.bar is parsed as &Foo().bar()

[17:42] <ruoso> to solve that problem

[17:43] <jnthn> Huh? But at parse name we'd know Foo is a type name...

[17:43] <masak> jnthn: dang! I shouldn't have let you take that vacation.

[17:43] * [particle] thinks December is a good codename for a perl 6 DBI project

[17:44] * masak would like a Perl 6 DBI project

[17:44] <jnthn> *at parse time

[17:45] <PerlJam> What ever happened to Tim Bunce's DBI 2 or whatever project?

[17:45] <pugs_svn> r23071 | moritz++ | [t/spec] unfudge passing rakudo test after lex branch merge (in for.t)

[17:45] <[particle]> pj: it's in the Design Before Implementing state

[17:45] <ruoso> jnthn, knowing that Foo is a type name is an optimization

[17:46] <PerlJam> hasn't it been that way for like 3 or 4 years now?  (yes, I know, I know ... don't say it)

[17:47] <jnthn> ruoso: I think otherwise - token typename does an assertion in there to see if we have a valid type name.

[17:47] <jnthn> Thus affecting the match.

[17:48] <jnthn> If I understand the grammar correctly, anyways.

[17:48] * ruoso checking STD

[17:48] <moritz_> http://nopaste.snit.ch/14722 # is that my error, or the next rakudo fuckup?

[17:49] <jnthn> moritz_: I think there's a ticket about calling lexical subs not being quite right already

[17:49] <ruoso> jnthn, the token typename is used on places that only typenames are allowed

[17:49] <ruoso> jnthn, but Foo.bar is not one of those places

[17:49] <jnthn> Ah.

[17:49] <ruoso> it's a regular statement

[17:50] <jnthn> ruoso: Doesn't it parse as term:name?

[17:51] <jnthn> In this case?

[17:51] <ruoso> hmmm... I think it parses as an EXPR

[17:51] * ruoso checking

[17:52] <jnthn> It'd seem strange to always interpreter it as a sub call when we can know at compile time what it is.

[17:52] <jnthn> *iterpret

[17:54] <ruoso> jnthn, that's why I said it's an optimization 

[17:54] <ruoso> to know it is a type name, I mean

[17:55] <jnthn> I prefer the view that we know what it is at parse time.

[17:55] <TimToady> they're combined in STD to simplify the lexer, but it certainly knows the difference even then, or it wouldn't be calling is_type

[17:55] *** adc_penner joined
[17:55] <jnthn> TimToady: So should &Foo() actually work?

[17:55] <jnthn> If you've declared, say, class Foo { }

[17:56] <TimToady> well, we certainly know that Foo($bar) is a function

[17:56] <jnthn> Yes, that's clear

[17:56] <jnthn> What about Foo.bar?

[17:56] <TimToady> Foo() is just the coercion that happens to return the protoobject

[17:56] <jnthn> OK, so if you invoke a proto-object, it returns itself?

[17:57] <TimToady> yes, which can be optimizized away

[17:57] *** Bzek left
[17:57] <jnthn> OK.

[17:57] <TimToady> as long as there are no args

[17:57] <jnthn> Sure

[17:57] <ruoso> hmm...

[17:57] <ruoso> so Foo should point to the package

[17:58] <ruoso> and Foo() coerces to the protoobject

[17:58] <ruoso> is it?

[17:58] <jnthn> Foo is the proto-object.

[17:58] <pugs_svn> r23072 | moritz++ | [t/spec] add integration test by Donald Knuth, "Man or Boy" 

[17:58] <pugs_svn> r23072 | moritz++ | (for stress-testing lexical variables and subs). pugs++ passes them.

[17:58] <TimToady> we use package and proto-object more or less interchangably except in contexts that care

[17:58] <jnthn> It refers to the package in, say, Foo::bar style things though.

[17:58] <TimToady> which is mostly just hash subscripting

[17:58] <ruoso> is that defined by syntax?

[17:59] <TimToady> Foo{} is reserved, while Foo::{} subscripts the package

[17:59] <jnthn> *nod*

[18:00] <TimToady> it's all valid syntax, so it has to be distinguished in semantic analysis

[18:00] <ruoso> and if I want the package object?

[18:00] <ruoso> Foo.WHO

[18:00] <ruoso> jnthn, anyway... in Foo.bar, Foo is a term, you were right

[18:00] *** riffraff left
[18:00] <TimToady> $x = Foo:: should return that

[18:01] <jnthn> $x = Foo::; # valid? :-)

[18:01] <TimToady> yes, valid

[18:01] <jnthn> OK

[18:01] <ruoso> although ugl

[18:01] <ruoso> ugly

[18:01] <jnthn> Yes.

[18:01] <TimToady> indeed

[18:01] <jnthn> But I don't think you'd want to do it much.

[18:02] <jnthn> Foo.WHO is much clearer.

[18:02] <TimToady> ugliness is a form of dehuffmanization

[18:02] <TimToady> not really

[18:02] <jnthn> Or allowance of obsfucation.

[18:02] *** spx2 left
[18:02] <TimToady> it's only clearer because you already know what WHO does. :)

[18:03] <pugs_svn> r23073 | moritz++ | [t/spec] set svn props for man-or-boy.t

[18:03] <ruoso> nah... WHO is intuitive

[18:03] <TimToady> sez WHO!?!

[18:03] <[particle]> WHO is just sugar for Foo:: :)

[18:03] *** spx2 joined
[18:03] <jnthn> It's probably a tad easier to go look up.

[18:03] <jnthn> 'cus it looks like a method call...which it isn't. :-)

[18:03] <TimToady> WHO'd a thunk it?

[18:03] <ruoso> [particle], considering you don't support changing the class package in runtime ;)

[18:04] <PerlJam> Woo.WHO

[18:05] <TimToady> we need a Foo.HUH?

[18:07] <moritz_> http://rt.perl.org/rt3/Ticket/Display.html?id=60404 should the number of iterations be 4, 1 and 3?

[18:07] <lambdabot> Title: #60404: Array becomes string in subroutine or method calls

[18:08] <[particle]> Foo.SAYWHA calls MetaData::Dumper

[18:09] *** justatheory left
[18:13] <masak> TimToady: yes, please add a .HUH metamethod! :P

[18:13] <masak> Uh.HUH

[18:13] <masak> (maybe we should rename Nil to Uh)

[18:17] *** cognominal joined
[18:18] *** pbuetow joined
[18:18] <[particle]> Uh is a Failure that gets confused about what context it should return in

[18:20] *** rindolf left
[18:20] <PerlJam> Then Nil is really more like an Idunno

[18:22] <masak> or BuggerAll

[18:26] *** vixey joined
[18:29] <pugs_svn> r23074 | moritz++ | [t/spec] add tests for RT #60404

[18:29] <pugs_svn> r23075 | moritz++ | [t/spec] svn props for passing-arrays.t

[18:32] <pugs_svn> r23076 | moritz++ | [t/spec] various unfudges for rakudo

[18:50] <rakudo_svn> r33194 | moritz++ | [rakudo] add tests for [perl #60404] to t/spectest.data

[18:51] *** DemoFreak joined
[18:55] <mncharity> TimToady: fyi, the Match tree for  $.m(3)  has an empty postcircumfix array in the variable.  The postcircumfix:( ) instead shows up as a surrounding postop.  Intended?  I should be able to work with it, though I'm still exploring.

[18:55] *** DemoFreak left
[18:56] <vixey> oo do you have STD.pm running now?

[18:56] <masak> vixey: oh yes.

[18:56] <vixey> great!

[18:56] <masak> it is.

[18:56] <masak> feels like living in the future.

[18:56] <vixey> I missed when this happened :(

[18:57] <masak> I think it was running already in August

[18:57] <pugs_svn> r23077 | hinrik++ | Commented some of the Pod stuff in perl6.vim

[19:03] <literal> @tell azawawi perl6.vim can do Pod now, you might want to try it

[19:03] <lambdabot> Consider it noted.

[19:04] *** DemoFreak joined
[19:04] <mncharity> vixey: elf has been self-compiling on a hand-implemented STD.pm derivative since end of March.  :)  misc/elfish/STD_blue is the/my current effort to improve elf, STD.pm, and gimme5 to the point elf can self-compile on gimme5 running the current STD.pm.  

[19:04] <mncharity> exercise after that will be teaching elf to itself run STD.pm directly.

[19:05] <vixey> yeah I was hacking elf a little bit when it was using the ruby STD

[19:05] <vixey> so is there a post about when STD started to run? :)

[19:05] <literal> @tell TimToady STD.pm has stuff like "=begin comment overview" which doesn't make sense according to S26 (shouldn't it rather be "=begin Overview"?)

[19:05] <lambdabot> Consider it noted.

[19:07] <mncharity> "STD started to run"?  depends what you mean.

[19:07] *** apeiron left
[19:08] <mncharity> elf is still using the ruby STD_red.  though a couple of the elf source files can now be compiled with STD_blue.

[19:14] *** apeiron joined
[19:15] <masak> rakudo: my $a = 5; $a = [ $a, 6 ]; say $a

[19:16] <p6eval> rakudo 33193: OUTPUT[maximum recursion depth exceeded␤current instr.: 'parrot;List;get_string' pc 2808 (src/gen_builtins.pir:1885)␤]

[19:16] <masak> jnthn: I think you should see this.

[19:18] <pugs_svn> r23078 | putter++ | [elf_h] Fixed incorrectly escaped string literals.  Tolerate undefs in statementlist arrays, for STD_blue development.

[19:27] <pugs_svn> r23079 | putter++ | [STD_blue] Improved AST gen for temp() and strings.  Working on $.e(3) variable method calls.

[19:27] <pugs_svn> r23079 | putter++ | Compiler.pm and CommandLine.pm now emit identically.  Pursuing EmitSimpleP5.pm.

[19:30] *** mtrimpe left
[19:38] <mncharity> arg.  will a "channel operator" please /topic The topic for #perl6 is: http://pugscode.org/ http://planetsix.perl.org/ | nopaste: http://sial.org/pbot/perl6 | pugs: [~] <m oo se> (or rakudo:, kp6:, elf: etc.) (or perl6: for all) | irclog: http://irc.pugscode.org/

[19:38] <mncharity> thus adding planet.

[19:38] <mncharity> since when does #perl6 have a locked topic???

[19:39] <mncharity> vixey: re post, I think it went by on the design meeting summaries at some point.  planetsix is now unbroken, and accepting feed additions, so there's an opportunity to blog...

[19:41] *** TimToady changes topic to: The topic for #perl6 is: http://pugscode.org/ http://planetsix.perl.org/ | nopaste: http://sial.org/pbot/perl6 | pugs: [~] <m oo se> (or rakudo:, kp6:, elf: etc.) (or perl6: for all) | irclog: http://irc.pugscode.org/

[19:42] <mncharity> danke

[19:42] <mncharity> happy turkeying all.  &

[19:43] *** mncharity left
[19:50] *** sri_kraih_ left
[19:58] *** jferrero joined
[20:01] *** smg left
[20:04] *** sri_kraih joined
[20:04] *** schmalbe left
[20:24] *** masak left
[20:24] *** masak joined
[20:32] <jnthn> masak: File rakudobug...

[20:32] <masak> jnthn: aye aye!

[20:32] * jnthn is having Rakudo day tomorrow - will spend some time on the RT queue.

[20:32] <jnthn> Continue the ticket filing/resolving tug of war with masak, which he is epicly winning...

[20:33] <masak> muhahaha

[20:33] <masak> the dark side always wins.

[20:34] <jnthn> It's only so dark because you're so far north up there. :-P

[20:36] <masak> jnthn: I woke late today. almost missed sunset. it's true!

[20:36] <masak> but it does perhaps tell more about my sleeping habits...

[20:38] *** km3 joined
[20:41] <jnthn> Oh, since I came back from Parrot Summit, my sleep has been *way* messed up.

[20:42] <jnthn> I work from home though, so nobody much cares.

[20:42] <jnthn> Well, I cared when I realized I had to get up at 8:30am on Sunday, but...

[20:50] <masak> heh

[20:51] *** Lorn left
[21:00] <rakudo_svn> r33203 | pmichaud++ | [rakudo]:  Remove gather workaround introduced in r31116 (RT #58854, Tene++)

[21:06] *** masak left
[21:07] *** ruoso left
[21:08] <literal> I'm using Pugs, how do I install the modules in ext/ ?

[21:09] <literal> a "perl Makefile.PL && make install" doesn't seem to do the trick

[21:11] *** Limbic_Region joined
[21:18] *** donaldh joined
[21:30] <pugs_svn> r23080 | hinrik++ | Some cleanup in perl6.vim

[21:30] <pugs_svn> r23081 | moritz++ | [t/spec] move subtypes.t to S12 section, don't know what it did in S02

[21:32] *** smg joined
[21:34] <moritz_> literal: dunno, your best bet is to copy them somewhere and set the PERL6LIB accordingly

[21:35] <literal> ok

[21:39] <pugs_svn> r23082 | moritz++ | [t/spec] more subtype tests

[21:40] <rakudo_svn> r33206 | moritz++ | [rakudo] follow a moved test in spectest.data

[21:41] <literal> is this [] thing just a convention or is there some tool that inserts it for you?

[21:42] <pugs_svn> r23083 | moritz++ | [t/spec] merge subset-code.t and subset-range.t into a single subset.t

[21:42] <literal> in the svn commit messages

[21:42] <moritz_> literal: it's a convention to track which part of the repo changed, and it also makes it easier to filter commit message mails by automated rules

[21:43] *** simcop2387 joined
[21:43] <literal> ok, so you type it manually. Just the path name?

[21:44] <moritz_> depends. I use [t] or [t/spec] for all test commits, but others use the project name of their sub project

[21:44] <literal> ok

[21:44] <moritz_> for example smop commits have [smop] instead of [v6/smop], TimToady uses [STD.pm] for must stuff under src/perl6/...

[21:46] <jnthn> moritz_: Ah. I should probably use that instead of [spectest]. :-)

[21:47] *** iblechbot left
[21:47] <moritz_> jnthn: yes, but I know what's meant with [spectest] as well ;-)

[21:47] <moritz_> (but [t/spec] is shorter to type ;-)

[21:50] <moritz_> rakudo: my $x; subset MyInt of Int where { $^num % x == 0}; say 'alive';

[21:50] <p6eval> rakudo 33206: OUTPUT[alive␤]

[21:50] <rakudo_svn> r33207 | moritz++ | [rakudo] track merge test files in spectest.data

[21:50] <moritz_> rakudo: my $x; subset MyInt of Int where { $^num % x == 0}; $x = 5; my MyInt $a = 10; say $a;

[21:50] <p6eval> rakudo 33206: OUTPUT[get_iter() not implemented in class 'Integer'␤current instr.: 'prefix:=' pc 14946 (src/gen_builtins.pir:9263)␤]

[21:51] <moritz_> rakudo: my $x; subset MyInt of Int where { $^num % $x == 0}; $x = 5; my MyInt $a = 10; say $a;

[21:51] <p6eval> rakudo 33206: OUTPUT[Type mismatch in assignment.␤current instr.: 'die' pc 12219 (src/gen_builtins.pir:7463)␤]

[21:51] <moritz_> rakudo: my $x = 5; subset MyInt of Int where { $^num % $x == 0}; $x = 5; my MyInt $a = 10; say $a;

[21:51] <p6eval> rakudo 33206: OUTPUT[Type mismatch in assignment.␤current instr.: 'die' pc 12219 (src/gen_builtins.pir:7463)␤]

[21:51] <moritz_> rakudo: my $x = 5; subset MyInt of Int where { $^num % $x == 0};  my MyInt $a = 10; say $a;

[21:51] <p6eval> rakudo 33206: OUTPUT[Type mismatch in assignment.␤current instr.: 'die' pc 12219 (src/gen_builtins.pir:7463)␤]

[21:51] * moritz_ smells another rakudo bug

[21:52] <moritz_> rakudo: my $x = 5; subset MyInt of Int where { $^num % $x == 0};  my  $a = 10; say $a;

[21:52] <p6eval> rakudo 33206: OUTPUT[10␤]

[21:52] <moritz_> rakudo: my $x = 5; subset MyInt of Int where { $^num % $x == 0};  my  $a = 10; say $a ~~ MyInt;

[21:52] <p6eval> rakudo 33206: OUTPUT[0␤]

[21:54] <jnthn> moritz_: Yes, I'm aware of the subsets and lexicals issue.

[21:54] <jnthn> There's a spectest currently fudged because of that.

[21:55] <moritz_> jnthn: I'm writing a ticket right now, and reviewing the test as well (which is a bit confusing right now=

[21:55] <jnthn> Sure.

[21:55] <jnthn> I may not fix that until the :subid changes are in place properly.

[21:56] <moritz_> no hurry from my side

[21:58] <pugs_svn> r23084 | moritz++ | [t/spec] make subtypes.t a bit more intuitive

[22:03] <pugs_svn> r23085 | hinrik++ | [util/perl6.vim] remove some old Pod stuff, fix issue with abbreviated blocks

[22:07] *** km3 is now known as km2

[22:08] <pugs_svn> r23086 | hinrik++ | [examples/euler] Correct Pod and add vim modeline to all files

[22:11] *** adc_penner left
[22:13] *** alester left
[22:15] *** wayland76 joined
[22:16] <wayland76> Saw lexicals.  pmichaud++ :)

[22:20] <rakudo_svn> r33209 | pmichaud++ | [rakudo]:  Add quote with multiple bracket characters, and texas quotes.

[22:20] <rakudo_svn> r33209 | pmichaud++ | * Partially fixes RT #60670.

[22:21] <pugs_svn> r23087 | moritz++ | [t/spec] unfudge quoting.t, pmichaud++

[22:26] <pmichaud> rakudo:  say << foo >>.perl;

[22:26] <p6eval> rakudo 33208: OUTPUT[1␤]

[22:26] *** spx2 left
[22:26] <pmichaud> (still not updated yet -- can't show off.)

[22:26] *** TomDLux joined
[22:27] <moritz_> rakudo:  say << foo bar >>.perl;

[22:27] <p6eval> rakudo 33208: OUTPUT[["foo", "bar"]␤]

[22:27] <moritz_> (the revision number isn't updated, but the binary is)

[22:28] *** mtrimpe joined
[22:28] <TimToady> rakudo: say join ':', << foo bar >>;

[22:28] <lambdabot> TimToady: You have 1 new message. '/msg lambdabot @messages' to read it.

[22:28] <p6eval> rakudo 33208: OUTPUT[foo:bar␤]

[22:30] *** spx2 joined
[22:30] *** TomDLux left
[22:31] <pmichaud> I haven't quite figured out what to do with something like:

[22:31] <pmichaud> my $a = 'foo bar';  my $b = 'baz';   say << $a$b >>.perl;

[22:32] <pmichaud> or

[22:32] <pmichaud> my $a = 'foo bar';  my $b = 'baz';   say << xyz$a$b/2 >>.perl;

[22:32] <moritz_> I'd say first interpolate, then .comb(/\S+/)

[22:32] <TimToady> I think the close to what a shell would do, the happier people will be

[22:33] <TimToady> *closer

[22:33] <moritz_> so the first would give ('foo', 'barbaz')

[22:33] <moritz_> and the second ('xzyfoo', 'bar/2')

[22:33] <moritz_> right?

[22:34] <pmichaud> my $a = 'foo bar';   say << $a"baz" >>;   # also ('foo', 'barbaz') ?

[22:34] <TimToady> but << "$a$b" >> would give one string

[22:34] <pmichaud> right.

[22:34] <pmichaud> that's what makes it a little tricky

[22:34] <moritz_> why have double quotes a special meaning <<...>?

[22:34] <pmichaud> we have to know what to concatenate and what to split.

[22:35] <pmichaud> rakudo: my $a = 'foo bar';    say << xyz "$a" abc >>.perl;

[22:35] <p6eval> rakudo 33209: OUTPUT[["xyz", "foo bar", "abc"]␤]

[22:35] <literal> TimToady: I have a question (see lambdabot)

[22:35] <pmichaud> rakudo: my $a = 'foo bar';    say << xyz '$a' abc >>.perl;

[22:35] <p6eval> rakudo 33209: OUTPUT[["xyz", "\$a", "abc"]␤]

[22:35] <pmichaud> rakudo knows those already.

[22:36] <pmichaud> it's just the concatention+split that gets a bit tricky.  :-)

[22:36] <TimToady> literal: the pod syntax is still being revised, so who knows what TheDamian will end up with

[22:36] * moritz_ wouldn't expect so much magic in texas quotes

[22:36] <pmichaud> *concatenation

[22:36] <pmichaud> moritz_: they're essentially "shell quoting"

[22:36] <literal> I see

[22:36] <moritz_> pmichaud: I see, that's new to me :)

[22:37] <literal> for ^($n -1) { ... }  <-- what does the ^ there mean?

[22:37] <moritz_> literal: ^$x is 0..($x-1)

[22:37] <jnthn> literal: 1..$n-1

[22:37] <TimToady> short for 0..^($n-1)

[22:37] <jnthn> erm, 0.. :-)

[22:37] <literal> ok

[22:38] <TimToady> in other words, 0..($n-2)

[22:38] <moritz_> rakudo: say ^4

[22:38] <p6eval> rakudo 33209: OUTPUT[0123␤]

[22:38] <pmichaud> rakudo:  say ^4.perl;

[22:38] <p6eval> rakudo 33209: OUTPUT[0123␤]

[22:38] <moritz_> TimToady: I always thought it went to $n-1, inclusive... is that new?

[22:38] <pmichaud> rakudo:  say (^4).perl;

[22:38] <p6eval> rakudo 33209: OUTPUT[0..^4␤]

[22:38] <TimToady> which is wrong

[22:39] <pmichaud> ...which one is wrong?

[22:39] <moritz_> wasn't ^@array intended to be the range of indices?

[22:39] <TimToady> well, ^4.perl isn't doing what you think

[22:39] <pmichaud> 4.perl returns "4", and then ^"4" is ... ?

[22:39] <TimToady> presumably

[22:40] <TimToady> rakudo: ^4.say

[22:40] <p6eval> rakudo 33209: OUTPUT[4␤]

[22:40] <TimToady> rakudo: (^4).say

[22:40] <p6eval> rakudo 33209: OUTPUT[0123␤]

[22:41] <pmichaud> rakudo is fun sometimes.  :-)

[22:41] <TimToady> moritz_: +@array is off the end

[22:42] <TimToady> so ^@array goes to @array-1

[22:42] <TimToady> same as 0 ..^ @array

[22:42] * jnthn wonders if Rakudo got the order of precedence right in ^4.say

[22:42] <moritz_> TimToady: ah, I missed the ($n-1) in the original question

[22:42] <pmichaud> jnthn: method calls are tighter than prefix, I think.

[22:42] <TimToady> yes, it's behaving as specced

[22:42] <jnthn> I thought so too

[22:43] <pmichaud> (whew!)

[22:43] <TimToady> it just doesn't DWIM :/

[22:43] *** araujo left
[22:44] <moritz_> I think it's good enough ;-)

[22:44] <pmichaud> rakudo:  my @a = <jan feb mar apr may jun jul aug sep oct nov dec>;  say ^@a;  # this one goes to 11.

[22:44] <p6eval> rakudo 33209:

[22:44] <p6eval> ..OUTPUT[0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849...

[22:44] <pmichaud> ...or maybe not.

[22:45] <pmichaud> I'll figure that one out later, or wait for masak++ to file it as a bug.  :-)

[22:45] <moritz_> well, I can do that too

[22:45] <pmichaud> that works also.  right now I'm only solving easy bugs.

[22:46] <TimToady> rakudo:  my @a = <jan feb mar apr may jun jul aug sep oct nov dec>;  say +@a;

[22:46] <p6eval> rakudo 33209: OUTPUT[12␤]

[22:46] <TimToady> rakudo:  my @a = <jan feb mar apr may jun jul aug sep oct nov dec>;  say ^+@a;

[22:46] <p6eval> rakudo 33209: OUTPUT[01234567891011␤]

[22:46] <pmichaud> I think prefix:^ isn't properly contexting its argument.

[22:46] <pmichaud> sorry, wrong channel.  prefix:<^>

[22:47] <TimToady> :)

[22:47] *** donaldh left
[22:48] <moritz_> rakudo: my @a = 'janu';  say (^@a).elems

[22:48] <p6eval> rakudo 33209: OUTPUT[1000␤]

[22:48] <moritz_> rakudo: my @a = 'janua';  say (^@a).elems

[22:48] <p6eval> rakudo 33209: OUTPUT[10000␤]

[22:48] <moritz_> rakudo: my @a = 'januar';  say (^@a).elems

[22:48] <p6eval> rakudo 33209: OUTPUT[100000␤]

[22:48] <TimToady> rakudo:  it's doing string incr

[22:48] <pmichaud> in that case I *know* it's not properly assigning @a

[22:48] <p6eval> rakudo 33209: OUTPUT[Could not find non-existent sub incr␤current instr.: '_block11' pc 13 (EVAL_13:13)␤]

[22:48] <pmichaud> my @a = 'janu';  say @a.elems;

[22:49] <pmichaud> rakudo: my @a = 'janu';  say @a.elems;

[22:49] <p6eval> rakudo 33209: OUTPUT[1␤]

[22:49] <pmichaud> oh, maybe it is.

[22:49] <pmichaud> hrm.

[22:49] <TimToady> rakudo: say ^'a'

[22:49] <p6eval> rakudo 33209: OUTPUT[␤]

[22:49] <moritz_> rakduo: say ^'ab'

[22:49] <pmichaud> anyway, should be easy to fix.... but later.

[22:49] <TimToady> commuting &

[22:50] <pugs_svn> r23088 | hinrik++ | [util/perl6.vim] adjust indenting options slightly

[22:51] * moritz_ can find only one test with ^@something in t/spec/

[22:57] <moritz_> rakudo: say 3 ~~ ^10

[22:57] <p6eval> rakudo 33209: OUTPUT[1␤]

[22:57] <moritz_> rakudo: say 3.5 ~~ ^10

[22:57] <p6eval> rakudo 33209: OUTPUT[1␤]

[22:57] <moritz_> rakudo: say 9.9 ~~ ^10

[22:57] <p6eval> rakudo 33209: OUTPUT[1␤]

[22:58] <moritz_> that's correct, I hope?

[22:58] <jnthn> Believe so.

[22:59] <pmichaud> rakudo:  say 10 ~~ ^10;

[22:59] <p6eval> rakudo 33209: OUTPUT[0␤]

[22:59] <jnthn> moritz_: It seems we don't have much in the way of tests for multimehtods, or am I missing them?

[22:59] <jnthn> I know there's the is default one, but I don't see much beyond that.

[22:59] <moritz_> jnthn: maybe also look in t/ (not t/spec), there many not-yet-moved OO tests there

[23:00] <jnthn> moritz_: Ah, OK

[23:00] <jnthn> http://svn.pugscode.org/pugs/t/ # failed to connect?

[23:00] <lambdabot> Title: pugs - Revision 23088: /t

[23:00] <jnthn> heh

[23:01] <jnthn> So why's it not work for me...

[23:01] <moritz_> perhaps the hourly apache restart?

[23:01] <moritz_> works here, try again please

[23:02] <jnthn> Still not. :-(

[23:02] <jnthn> The connection was refused when attempting to contact svn.pugscode.org.

[23:04] *** ZuLuuuuuu joined
[23:04] *** luqui joined
[23:04] <pugs_svn> r23089 | moritz++ | [t/spec] tests for prefix:<^>

[23:04] <jnthn> moritz_: But strangely svn works... :-|

[23:04] <jnthn> so odd

[23:05] <jnthn> ah, owrks now

[23:05] <jnthn> :-S

[23:05] <pugs_svn> r23090 | moritz++ | [t/spec] test that ^(something) actually returns a Range

[23:06] *** luqui left
[23:07] <moritz_> rakudo: my @a = <foo bar>; say (^@a).WHAT

[23:07] <p6eval> rakudo 33209: OUTPUT[List␤]

[23:08] <TimToady> moritz_: 3 .. ^10 is incorrect

[23:08] <TimToady> the operator is ..^

[23:09] <TimToady> 3 .. ^10 means 3 .. (0..9)

[23:09] <moritz_> TimToady: where did you see 3 .. ^10?

[23:09] <TimToady> sorry, misread

[23:09] <TimToady> 3 ~~ ^10 is fine

[23:09] <TimToady> what I get for bling t ofast

[23:10] *** hercynium left
[23:10] <TimToady> typing to ofast t oo

[23:10] <moritz_> ;)

[23:11] <TimToady> and yes 9.9 ~~ ^10 is True

[23:11] <jnthn> TimToady: multi method bar(Array @array) { actually would test that that we got passed an @array where every element was an Array, right?

[23:11] <TimToady> which rakudo confuses with 1 :)

[23:11] <moritz_> good, then the tests are right (and so is rakudo)

[23:12] <TimToady> jnthn: correct

[23:12] <pmichaud> True stringifies to...?

[23:12] <jnthn> TimToady: And similarly, multi method bar(Hash %hash) { makes sure that the values are all hashes...

[23:12] <jnthn> OK, good.

[23:13] <moritz_> so if you want to say that in 'my @Array' @Array should be an Array, not just a Positional, one would say that as 'my @Arrray of Array', or how?

[23:13] <pmichaud> my @array is Array, I think.

[23:13] <TimToady> pmichaud: certainly it should numify to 1, and .perlify to True, but stringify on enums is debatable

[23:13] <jnthn> Probably not of.

[23:14] <pmichaud> TimToady: yes, I'm wondering/waiting for a decision on stringified enums.  :-)

[23:14] <pmichaud> and it .perlifies to "True" and not "Bool::True"?

[23:14] <jnthn> pmichaud: is works on declarations like that, I'm not sure that will fly for type checks on parameters.

[23:14] <TimToady> depends on use cases, which never occur to me offhand :)

[23:14] <jnthn> pmichaud: Since is applies a trait...

[23:14] <jnthn> TimToady: Any answers? :-)

[23:15] <pmichaud>  ( @array where { @array ~~ Array ) )     ?

[23:15] <jnthn> That'd *work* I'm sure. :-)

[23:15] <jnthn> It's not so pretty though I guess.

[23:15] <pmichaud> s/')'/}/

[23:16] <TimToady> my @array is Array requires @array to be an Array

[23:16] <pmichaud> not everything is pretty.  :-P

[23:16] <TimToady> my @array does Array requires @array to do Array

[23:16] <moritz_> ok 'is', not 'of'.

[23:16] <TimToady> as does @array ~~ Array

[23:16] <TimToady> which is defined as does, not is

[23:16] <jnthn> TimToady: Array is a role?

[23:17] <pmichaud> afk, dinner.

[23:17] <jnthn> role Array[::of] { ... } ?

[23:17] <TimToady> maybe, doesn't matter, since ~~ degrades to is if there isn't a role

[23:17] <TimToady> but most of the built-in types are probably punned role/classes

[23:17] <jnthn> TimToady: I'm trying to get the relationship between writing "of" and parametric roles straight in my head.

[23:18] <jnthn> my @array of Int;

[23:18] *** ZuLuuuuuu left
[23:18] <moritz_> seems pretty useless ;)

[23:18] <TimToady> yes that's Array[:of(Int)] or some such

[23:19] *** Auzon joined
[23:19] <jnthn> OK, and we can instantiate it because the role implies the existence of a class Array too?

[23:19] <TimToady> yes, Array of Bool is much more useful

[23:19] <jnthn> Or put another way, if I wanted to instantiate a typed array, just as you can create a new anything by doing Thingy.new, how does this look?

[23:20] <jnthn> Array[:of(Int)].new

[23:20] <jnthn> ?

[23:20] <TimToady> if role Array can be punned into class Array it probably means that the of parameter has a default of Object or some such

[23:21] <jnthn> OK, so declare role Array[::of = Object] { ... }

[23:21] <jnthn> *declared

[23:21] <TimToady> the .new looks okay to me

[23:21] <jnthn> Will that parse OK?

[23:21] <TimToady> but S09 has more opinions about arrays. :)

[23:22] <jnthn> I'm not so much expecting you'd write it like that, so much as working out what it boils down to under the hood. :-)

[23:22] <TimToady> STD likes it

[23:22] <jnthn> OK, great.

[23:22] <TimToady> desugaring, we usually say here

[23:23] <jnthn> my Int @array; # it's SO sweet!

[23:23] <jnthn> OK, so for hashes

[23:23] <jnthn> my Int %hash; # hash has values of type Int

[23:23] <jnthn> Presumably this looks a bit like

[23:23] <TimToady> correct

[23:24] <jnthn> role Hash[::of = Object, ::key = Object] { ... }

[23:24] <TimToady> my Int %hash{Str} is default

[23:24] <TimToady> object keys must be explicitly declared

[23:25] <jnthn> Ah, OK

[23:25] <TimToady> so probably role Hash[::of = Object, ::key = Str] { ... }

[23:25] <jnthn> OK, and we coerce to string on storage?

[23:25] <pugs_svn> r23091 | moritz++ | [t/TASKS] jnthn++ needs multi method tests

[23:25] <TimToady> assuming string is immutable, yes

[23:26] <jnthn> How does that look?

[23:26] <TimToady> Str is immutable, in theory

[23:26] <TimToady> a Str variable tries to be smart about it though

[23:27] <jnthn> method postcircumfix:<{}>(key $k, of $value) { ... }

[23:27] <TimToady> not sure our story is entirely straight there...

[23:27] <jnthn> erm, multi method...

[23:27] <jnthn> Right, because this would imply in the signature "we require a key that's already a string"

[23:27] <TimToady> need a space between {} too

[23:27] <jnthn> Ah, yes.

[23:28] <TimToady> and your named parameter syntax leaves something to be desired.

[23:28] <moritz_> perhaps more like multi method postcircumfix:<{ }>($key as key, of $value) ?

[23:28] <moritz_> (assuming that 'key' and 'of' are types=

[23:28] <jnthn> So would it be more like multi method postcircumfix:<{ }>($k, of $value) { $k .= Str }

[23:28] <TimToady> ah

[23:28] <jnthn> What named parameter syntax?

[23:28] <jnthn> Yes, key and of are the types we bound in the role.

[23:30] <TimToady> not sure why you're feed values to a postcircumfix...

[23:30] <rakudo_svn> r33211 | jonathan++ | [rakudo] Some final bits to get multi methods working.

[23:31] * moritz_ goes to bed and whishes the busy hackers and speccors the appropriate amount of fun

[23:31] <TimToady> more like: multi method postcircumfix:<{ }> (*@@key as key --> of)

[23:31] <jnthn> TimToady: Ah, duh. :-)

[23:31] <jnthn> OK, so "as" does the coercion.

[23:31] <jnthn> I'd forgot that was allowed on a parameter in a signature.

[23:31] <jnthn> OK, that makes sense.

[23:33] <jnthn> Is my X $foo{Y,Z} is C a general syntax we'd desugar to something like $foo := C[:of(X),Y,Z].new

[23:33] *** bacek_ joined
[23:33] <jnthn> Or are the hash and array syntaxes a special case?

[23:34] <jnthn> erm, the hash one

[23:34] <TimToady> they may well be special; and in any case you shouldn't pass positionals after a named :P

[23:34] <jnthn> :P

[23:34] <jnthn> I should really try learning Perl 6 some day...

[23:35] <jnthn> I'm asking this 'cus I'm planning to implement the parametric roles stuff in the not too distant future. :-)

[23:35] <TimToady> you *may* pass positionals after named, but note that Y will be bound to ::of, leaving your :of arg bereft

[23:36] <jnthn> Oh, I had one other question, then I'll leave you alone. :-) Where is the .mixin method you use in STD.pm defined?

[23:36] <TimToady> Cursor.pmc

[23:36] <jnthn> Aha, OK, so it's a method on cursor objects.

[23:37] <TimToady> everything is a method on cursor objects, pret' near

[23:37] <jnthn> The use of parametric roles in STD.pm is pretty cool. :-)

[23:38] <TimToady> yeah, well, I may have to cheat on the starters and stoppers for speed, but for now it does it "right"

[23:38] <TimToady> but each time I do it right I use up another 80meg or so of disk cache :)

[23:39] <TimToady> I'm hopeful that once my lexers get out of strings and into real data structures the means for compressing common patterns will be obvious.

[23:40] <TimToady> but it's a lot easier to understand in string form...

[23:40] <jnthn> Well, make it work, then make it fast/compact.

[23:40] <TimToady> also, the parameters on roles are rather limited at the moment

[23:41] <jnthn> You don't get the full power of signatures there?

[23:41] * jnthn was planning to implement it so you did...

[23:41] <TimToady> since they have to be faked by RE_var::longest

[23:42] <TimToady> well, p5 doesn't really have roles, so all mixins are basically some variant of eval

[23:43] <jnthn> Ah, OK.

[23:44] <TimToady> the RE_var::longest code has to be cognizant that certain variables can be treated as constants wrt LTM

[23:44] <TimToady> they're only variable across different packages

[23:44] * jnthn tries to wrap his head around this

[23:45] <jnthn> So in 

[23:45] <jnthn> role startstop[$start,$stop] {

[23:45] <jnthn>     token starter { $start }

[23:46] <TimToady> $start has to be treated as part of the longest token

[23:46] <jnthn> OK

[23:46] <TimToady> and that is what the last method in Cursor, RE::var::longest, is doing.

[23:47] <TimToady> arguably those methods can go in a different file these days though, since they aren't actually Cursor methods

[23:47] <jnthn> So when you do self.mixin( ::startstop[$start,$stop] ) then it needs to compile a specific version of the token with what's passed as $start and $stop constant from that point on?

[23:48] <TimToady> yes, mixin generates a new package, moosed to be derived from the original, and evals the code in that package

[23:49] <TimToady> it does not attempt to in-line $start and $stop though

[23:49] <TimToady> which is why it's faked in the longest

[23:49] *** Auzon left
[23:49] <TimToady> in fact, it doesn't rewrite the generic routines at all

[23:49] <TimToady> just uses the derivation of the original

[23:50] <TimToady> but longest knows which vars are to be treated as generic

[23:50] <TimToady> and the actual matcher doesn't care, since it just matches the runtime string

[23:51] <jnthn> OK

[23:51] <TimToady> but it is currently limited to strings, really

[23:51] <jnthn> I'll have to take a look at the code.

[23:51] <jnthn> And see what it's doing.

[23:51] <TimToady> so p5 can use it for types, but only to the extent that p5 treats types as strings.

[23:52] <jnthn> OK, but an implementation where roles were available first class wouldn't have that limitation?

[23:53] <TimToady> presumably.  STD is only meant to bootstrap the compiler on p5

[23:54] <TimToady> it doesn't try for a perfect p5 implementation of p6

[23:54] <TimToady> which would be very slow

[23:55] <TimToady> on the other hand, it's trying to do things correctly from the p6 perspective at least

[23:55] <pugs_svn> r23092 | jnthn++ | [t/spec] Un-fudge a multi method test for 'is default' and add a few more multi method tests. More welcome and encouraged.

[23:55] <TimToady> so p6 thinks it's a real mixin, even if p5 sees it as an eval that happens to fake up a mixin

[23:56] <jnthn> OK.

[23:56] * jnthn thinks his brain is going to be kept busy for the coming months

[23:56] <TimToady> so we really are relying on derivation for derived grammars, even if all the apparatus has to be faked up around it

[23:57] <jnthn> *nod*

[23:57] <jnthn> In theory, if I can get this right for roles and classes, I'd hope that roles with grammars would mostly fall out naturally.

[23:58] <TimToady> and we really do go out and interrogate methods for their longest token sets, even though Cursor has a lot of excess familiarity with the innards

[23:58] <TimToady> yes

[23:58] <jnthn> OK.

[23:58] <TimToady> and p5 doesn't really let you treat a method as an object, so we fake that too

[23:59] * jnthn will try and get it right

[23:59] <TimToady> wit the *_PEEK routines

[23:59] <jnthn> Aha.

[23:59] <TimToady> though we could conceivably do something with p5's sub attributes

