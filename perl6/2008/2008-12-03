[00:15] *** vixey left
[00:16] *** zamolxes joined
[00:20] <meppl> good night

[00:24] *** meppl left
[00:44] *** ryanc left
[00:49] *** Moudmen joined
[00:49] <Moudmen> is this the correct use :

[00:49] <Moudmen> my $smtpconnexion = Net::SMTP->new("$mailhost", Debug=>($debug ? 1 : 0));

[00:49] <Moudmen> $smtpconnexion->auth("$mysmtpu", "$mysmtpp");

[00:49] <Moudmen> ?

[00:49] *** [particle]1 joined
[01:06] *** Moudmen left
[01:06] *** [particle] left
[01:12] *** Limbic_Region joined
[01:26] *** hercynium joined
[01:35] *** alc joined
[01:40] *** ChrisDavaz joined
[01:51] *** mtrimpe left
[02:11] *** diakopter left
[02:13] *** alester left
[02:15] *** ChrisDavaz left
[02:17] *** ChrisDavaz joined
[02:21] *** Limbic_Region left
[02:27] *** eternaleye joined
[02:33] *** hercynium_ joined
[02:41] *** hercynium left
[02:56] *** REPLeffect left
[03:09] *** mncharity joined
[03:11] *** ChrisDavaz left
[03:19] *** stephens left
[03:19] *** Psyche^ joined
[03:20] *** Patterner left
[03:20] *** Psyche^ is now known as Patterner

[03:34] *** leo_ joined
[03:37] <pugs_svn> r24144 | putter++ | [elfish/rx_on_re] Additional prep for changing emitter output.

[03:40] *** bacek joined
[03:41] <mncharity> try flipping the switch tomorrow.  will hopefully then end up with rx_on_re AST's emitted to p5 code which can be dropped in elf compiled output (p5 runtime only - p6 emitting is a later exercise).

[03:41] <mncharity> good night all &

[03:41] *** mncharity left
[03:43] <bacek> perl6: grammar Foo { rule comment { '(:' .* ':)' }; rule ws { \s+ | <comment>+ };  rule literal { '"' \w+ '"' };  rule TOP { <literal>+}; }; say '"foo"' ~~ Foo;

[03:43] <p6eval> rakudo 33449: OUTPUT[maximum recursion depth exceeded␤current instr.: 'parrot;PGE;Match;new' pc 25 (compilers/pge/PGE/Match.pir:54)␤]

[03:43] <p6eval> ..pugs: OUTPUT[␤]

[03:43] <p6eval> ..elf 24144: OUTPUT[Can't locate object method "cb__RegexDef" via package "EmitSimpleP5" at ./elf_f line 1612.␤]

[03:43] <bacek> perl6: grammar Foo { rule comment { '(:' .* ':)' }; rule ws { \s+ | <comment>+ };  rule literal { '"' \w+ '"' };  rule TOP { <literal>+}; }; say '"foo"' ~~ Foo::TOP;

[03:43] <p6eval> rakudo 33449: OUTPUT["foo"␤]

[03:43] <p6eval> ..pugs: OUTPUT[*** No compatible multi variant found: "&Foo::TOP"␤    at /tmp/lkGZCtuWpv line 1, column 139-158␤]

[03:43] <p6eval> ..elf 24144: OUTPUT[Can't locate object method "cb__RegexDef" via package "EmitSimpleP5" at ./elf_f line 1612.␤]

[03:44] <bacek> perl6: grammar Foo { rule comment { '(:' .* ':)' }; rule ws { \s+ | <comment>+ };  rule literal { '"' \w+ '"' };  rule TOP { <literal>+}; }; say '  "foo"  ' ~~ Foo::TOP;

[03:44] <p6eval> pugs: OUTPUT[*** No compatible multi variant found: "&Foo::TOP"␤    at /tmp/5uLJmmUYBl line 1, column 139-162␤]

[03:44] <p6eval> ..rakudo 33449: OUTPUT[  "foo"  ␤]

[03:44] <p6eval> ..elf 24144: OUTPUT[Can't locate object method "cb__RegexDef" via package "EmitSimpleP5" at ./elf_f line 1612.␤]

[03:44] <bacek> perl6: grammar Foo { rule comment { '(:' .* ':)' }; rule ws { \s+ | <comment>+ };  rule literal { '"' \w+ '"' };  rule TOP { <literal>+}; }; say '  "foo"  ' ~~ Foo;

[03:44] <p6eval> rakudo 33449: OUTPUT[maximum recursion depth exceeded␤current instr.: 'parrot;PGE;Match;new' pc 25 (compilers/pge/PGE/Match.pir:54)␤]

[03:44] <p6eval> ..pugs: OUTPUT[␤]

[03:44] <p6eval> ..elf 24144: OUTPUT[Can't locate object method "cb__RegexDef" via package "EmitSimpleP5" at ./elf_f line 1612.␤]

[03:44] <bacek> perl6: grammar Foo { rule comment { '(:' .* ':)' }; rule ws { \s+ | <comment>+ };  rule literal { '"' \w+ '"' };  rule TOP { <literal>+}; }; say ' (: blah :) "foo"  ' ~~ Foo::TOP;

[03:44] <p6eval> pugs: OUTPUT[*** No compatible multi variant found: "&Foo::TOP"␤    at /tmp/aXmrW6h6M4 line 1, column 139-172␤]

[03:44] <p6eval> ..rakudo 33449: OUTPUT[ "foo"  ␤]

[03:44] <p6eval> ..elf 24144: OUTPUT[Can't locate object method "cb__RegexDef" via package "EmitSimpleP5" at ./elf_f line 1612.␤]

[04:01] *** armagad left
[04:02] *** elmex_ joined
[04:17] *** leo_ left
[04:17] *** elmex left
[04:17] *** elmex_ is now known as elmex

[04:33] *** ChrisDavaz joined
[04:37] *** alester joined
[04:49] *** jrockway_ is now known as jrockway

[05:03] *** jfredett_ is now known as jfredett

[05:09] *** Chaosmagi joined
[05:10] <Chaosmagi>  Do u feel like your life is stuck in a rut, just going around in circles. Do u feel Spirituality left out then all u have to do is !!!!TAKE BACK REALITY!!!! www.ellis69.webs.com

[05:10] *** Chaosmagi left
[05:11] *** eternaleye left
[06:06] *** drbean joined
[06:19] *** smallfish joined
[06:23] *** xinming_ joined
[06:31] *** DemoFreak joined
[06:38] *** bacek left
[06:42] *** xinming left
[06:45] *** sri_kraih left
[06:47] *** sri_kraih joined
[06:52] *** Southen_ is now known as Southen

[06:53] *** alester left
[06:56] *** smallfish left
[07:02] *** smg left
[07:12] *** thei0s joined
[07:27] *** spinclad left
[07:34] *** agentzh left
[07:35] *** agentzh joined
[07:38] <thei0s> hm, am I right that it is not possible to do indent sensitive parsing (imagine python code) without writting any executable code?

[07:43] <moritz_> if you don't care about space/tab translatioin, it might be possible with pure grammars

[08:10] *** ashizawa joined
[08:33] *** smg joined
[08:37] *** ChrisDavaz left
[08:45] *** zamolxes left
[09:10] *** iblechbot joined
[09:28] *** yves left
[09:32] *** kane_ joined
[09:33] *** zamolxes joined
[09:47] *** alc left
[10:03] *** ejs joined
[10:03] *** kane__ joined
[10:03] *** kane_ left
[10:08] *** rindolf joined
[10:12] *** Southen_ joined
[10:14] *** spinclad joined
[10:29] *** Southen left
[10:29] *** kane__ left
[10:29] *** kane_ joined
[10:44] *** explorer joined
[10:59] *** yves joined
[11:00] *** rindolf left
[11:09] *** kane_ left
[11:13] *** riffraff joined
[11:13] *** kane_ joined
[11:16] *** ashizawa left
[11:18] <riffraff> hello

[11:43] *** riffraff left
[11:50] *** Psyche^ joined
[11:51] *** Patterner left
[11:51] *** Psyche^ is now known as Patterner

[11:54] *** kane__ joined
[11:54] *** kane_ left
[11:57] *** [particle] joined
[11:59] *** smg left
[12:00] *** smg joined
[12:01] *** smg left
[12:04] *** smg joined
[12:05] *** kane_ joined
[12:15] *** [particle]1 left
[12:16] *** kane__ left
[12:18] *** iblechbot left
[12:21] *** kane_ left
[12:26] *** kane_ joined
[12:50] <broquaint> perl6: $_=q[(foo)]; print; s«\( (.*) \)»«()»x; print

[12:50] <p6eval> elf 24144: OUTPUT[/home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.rb:117:in `block in to_dump0': undefined method `to_dump0' for nil:NilClass (NoMethodError)␤       from /home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.rb:117:in `map'␤        from

[12:50] <p6eval> ../home/evalenv/pugs/misc/elf/elf_f_src/STD_red/match.rb:1...

[12:50] <p6eval> ..rakudo 33453: OUTPUT[Statement not terminated properly at line 1, near "\x{ab}\\( (.*) \\"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[12:50] <p6eval> ..pugs: OUTPUT[*** s{...}{...} is deprecated; write s{...}='...' instead.␤    at /tmp/WgNGekzCKn line 1, column 35␤*** ␤    Unexpected " print"␤    expecting "="␤    at /tmp/WgNGekzCKn line 1, column 40␤]

[12:54] <broquaint> perl6: $_='(foo)'; s«\( (.*) \)» = '()'; say $_;

[12:54] <p6eval> rakudo 33453: OUTPUT[Statement not terminated properly at line 1, near "\x{ab}\\( (.*) \\"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[12:54] <p6eval> ..elf 24144: OUTPUT[Unrecognized character \xC2 in column 229 at (eval 119) line 4.␤ at ./elf_f line 3861␤]

[12:54] <p6eval> ..pugs: OUTPUT[Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/evalenv/pugs/perl5/Pugs-Compiler-Rule/lib';␤    unshift @INC, '/home/evalenv/pugs/third-party/Parse-Yapp/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runti...

[12:54] <broquaint> Dang.

[12:59] *** smg left
[13:18] *** iblechbot joined
[13:20] *** ruoso left
[13:32] *** kane_ left
[13:34] *** kane_ joined
[13:49] *** DemoFreak left
[14:11] <thei0s> perl6: token TOP { (<ab>) <a>*? <$/[0]<ab>> }; token a { 'a' }; token ab { 'abc' }; if 'abcaaaabca' ~~ TOP {say "match " ~ $/.perl;} else {say "no match";}

[14:11] <p6eval> elf 24144: OUTPUT[/home/evalenv/pugs/misc/elf/elf_f_src/STD_red/std.rb:1948:in `block in _EXPR': wrong number of arguments (2 for 1) (ArgumentError)␤    from /home/evalenv/pugs/misc/elf/elf_f_src/STD_red/prelude.rb:52:in `call'␤      from

[14:11] <p6eval> ../home/evalenv/pugs/misc/elf/elf_f_src/STD_red/prelude.rb:52:in `let...

[14:11] <p6eval> ..pugs: OUTPUT[*** No compatible multi variant found: "&TOP"␤    at /tmp/B80qaVQkS3 line 1, column 81-101␤]

[14:11] <p6eval> ..rakudo 33455: OUTPUT[Statement not terminated properly at line 1, near "$/[0]<ab>>"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[14:12] *** bacek joined
[14:13] *** ruoso joined
[14:13] <thei0s> rakudo: token test { (<ab>) 'a'*? $/[0]<ab> }; token ab { 'abc' }; if 'abcaaaabca' ~~ test {say "match ";} else {say "no match";}

[14:13] <p6eval> rakudo 33455: OUTPUT[Statement not terminated properly at line 1, near "[0]<ab> };"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[14:13] <thei0s> rakudo: token test { (<ab>) 'a'*? ${/[0]<ab>} }; token ab { 'abc' }; if 'abcaaaabca' ~~ test {say "match ";} else {say "no match";}

[14:13] <p6eval> rakudo 33455: OUTPUT[Syntax error at line 1, near "} }; token"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[14:14] <thei0s> rakudo: token test { (<ab>) 'a'*? $0<ab>} }; token ab { 'abc' }; if 'abcaaaabca' ~~ test {say "match ";} else {say "no match";}

[14:14] <p6eval> rakudo 33455: OUTPUT[Syntax error at line 1, near "}; token a"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[14:24] <thei0s> perl6: token test { (<cd=ab>) 'a'*? $0<cd> }; token ab { 'abc' }; if 'abcaaaabca' ~~ test {say "match ";} else {say "no match";}

[14:24] <p6eval> rakudo 33455: OUTPUT[Statement not terminated properly at line 1, near "else {say "␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[14:24] <p6eval> ..pugs: OUTPUT[*** No compatible multi variant found: "&test"␤    at /tmp/JZl6POIMRk line 1, column 63-84␤]

[14:24] <p6eval> ..elf 24144: OUTPUT[FAKING b for ["(eval):5:in `__regex_metachar_2591082'"]␤/home/evalenv/pugs/misc/elf/elf_f_src/STD_red/prelude.rb:65:in `[]': can't convert false into Integer (TypeError)␤      from /home/evalenv/pugs/misc/elf/elf_f_src/STD_red/prelude.rb:65:in `_match_from'␤        from

[14:24] <p6eval> ..(eval):5:in `__regex_...

[14:25] <thei0s> something like this should work or not?

[14:26] <moritz_> I think it should, but right now I don't have enought leisure to think it through

[14:26] <moritz_> (btw you can also /msg p6eval if you want to experiment)

[14:29] <thei0s> in synopsis 5 there is an example for something else, but it says:    $_ = "foodbard"    

[14:29] <thei0s>         / ( foo | bar ) d $0 /      # fails; doesn't match "foo" literally

[14:29] <thei0s>      / ( foo | bar ) d <$0> /    # fails; doesn't match /foo/ as subrule

[14:29] <thei0s>      / ( foo | bar ) d <~~0> /   # matches using rule associated with $0

[14:29] <thei0s> so <$0<ab>> should work...

[14:29] <thei0s> rakudo: token test { (<ab>) 'a'*? <$0<ab>> }; token ab { 'abc' }; if 'abcaaaabca' ~~ test {say "match ";} else {say "no match";}

[14:29] <p6eval> rakudo 33455: OUTPUT[Statement not terminated properly at line 1, near "$0<ab>> };"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[14:29] <moritz_> $0<cd> should work, right?

[14:30] *** smg joined
[14:30] <moritz_> but <$0<cd>> is soemthing different

[14:32] <thei0s> am, yes :) but both should work in this example and none does atm... using only $0 (or other numbers) works fine

[14:33] <moritz_> feel free to write a bug report (and perhaps even a test case)

[14:35] *** vixey joined
[14:37] *** kane__ joined
[14:37] *** kane_ left
[15:02] *** riffraff joined
[15:03] *** rafl_ joined
[15:03] *** _smg joined
[15:04] *** _smg left
[15:05] *** smg left
[15:05] *** rafl left
[15:05] *** broquaint left
[15:07] *** broquaint joined
[15:22] *** rindolf joined
[15:23] *** zamolxes left
[15:36] *** dr_df0 joined
[15:36] <dr_df0> perl6: { my @a=<the brown fox jumps over the lazy dog>; say @a[0 .. 2]; }

[15:36] <p6eval> pugs: OUTPUT[thebrownfox␤]

[15:36] <p6eval> ..elf 24144: OUTPUT[Argument "" isn't numeric in array element at (eval 119) line 4.␤the␤]

[15:36] <p6eval> ..rakudo 33456: OUTPUT[jumps␤]

[15:41] <jnthn> dr_df0: Rakudo doesn't do slices yet, FYI. :-)

[15:43] <moritz_> it evaluates the range in integer context, and returns @a[3] right now

[15:45] <ruoso> slice context is still the feature that haunts a lot of people...

[15:46] <ruoso> pugs: my @@a = map { $_ == 2 ?? (1, 2, 3) !! () }, 1, 2, 3; say @@a.perl;

[15:46] <p6eval> pugs: OUTPUT[\(1, 2, 3)␤]

[15:46] <ruoso> pugs: my @@a = map { $_ == 2 ?? (1, 2, 3) !! () }, 1, 2, 3; say @@a[0];

[15:46] <p6eval> pugs: OUTPUT[1␤]

[15:46] <ruoso> pugs: my @@a = map { $_ == 2 ?? (1, 2, 3) !! () }, 1, 2, 3; say @@a[1;0];

[15:46] <p6eval> pugs: OUTPUT[*** ␤    Unexpected ";"␤    expecting "_", fraction, exponent, term postfix, operator or "]"␤    at /tmp/a6dEvRZU77 line 1, column 64␤]

[15:46] <moritz_> it would help even if simple, one-dimensional eager slices where implemented

[15:47] <moritz_> ruoso: I think that the current concept of slice context was invented after pugs developmented had stalled

[15:47] <ruoso> hmm... ok

[15:47] <ruoso> anyway... there's one specific line in the specs that freaks me out

[15:48] <ruoso> the one that says that @a and @@a are actually the same variable

[15:49] <ruoso> because that means that

[15:49] <ruoso> my @a <== grep { ... }, ...

[15:49] <ruoso> say @a[0]; say @@a[0];

[15:50] <ruoso> will at first say the first item returned (regardless of empty captures in each grep iteration)

[15:50] <ruoso> and at second say the capture of the first iteration

[15:51] <ruoso> is the second '@' in '@@a[0]' a twigil? or is that parsed as @(@a)[0] ?

[15:52] <dr_df0> jnthn: I figured it out, on my SVN checked out version, but I wanted to check how pugs is handling this syntax

[15:52] <moritz_> ruoso: it's not a twigil

[15:52] <moritz_> ruoso: I'm pretty sure that @@ is syntactically a sigil

[15:53] <ruoso> gah

[15:53] <ruoso> that's even weirder

[15:53] <moritz_> why?

[15:54] <moritz_> token sigil:sym<@@> { <sym> }

[15:54] <ruoso> is that part of STD?

[15:54] <moritz_> aye

[15:55] <moritz_> there's no need why a sigil needs to be just one char long

[15:55] <[particle]> yes, @@ is a sigil, just like :: used to be

[15:59] <ruoso> so @@a and @a are different variables,

[15:59] <ruoso> since the variable name includes the sigil

[15:59] <moritz_> I think that's an exception here

[16:00] <moritz_> @@a is a different view of variable @a

[16:00] *** stephens joined
[16:00] <ruoso> that's the part that freaks me out

[16:00] <ruoso> what does that mean, for every @a, the lexical scope also holds a reference to @@a?

[16:01] <ruoso> s/to @@a/as @@a/

[16:01] <moritz_> no, it's really the same variable

[16:01] <moritz_> but @@a on the lhs implies slice context

[16:01] <moritz_> while @a on the lhs implies list context

[16:01] <ruoso> so, slice context is only possible on lists that are stored in variables with the @ sigil?

[16:02] <moritz_> you can still say my $a = @@( EXPR )

[16:02] <moritz_> as far as I understand, @@a = ... is just shorthand for @a = @@( ... )

[16:05] <pmichaud> btw, @a[0..2]   is the case that starts to make me think that perhaps Range ~~ List

[16:05] <pmichaud> I thought about that one last night.

[16:06] <ruoso> moritz_, @a = @@(...) implies list context over the rvalue slice, which should flatten the list

[16:06] <ruoso> pmichaud, I think the confusion is about the "Positional" role

[16:06] <pmichaud> ruoso: there's confusion about that also.

[16:06] <ruoso> I think what I've been calling List is probably "Positional"

[16:06] <ruoso> but I don't see much of a point in having both List and Positional

[16:07] <pmichaud> I think of them as separate issues

[16:08] <ruoso> maybe List is the only one that supports Slice context...

[16:08] <ruoso> while positional doesn't

[16:08] <ruoso> but...

[16:08] <ruoso> (1..9)[3..4] should work

[16:09] <pmichaud> otoh, since subscripts are always evaluated in list context, it probably doesn't matter if Range ~~ List

[16:09] <ruoso> at least a Range can be coerced to a Lazy Lis

[16:09] <ruoso> Lazy List

[16:09] <pmichaud> correct.

[16:09] <ruoso> so maybe .Iterator() is not a method of List

[16:09] <dr_df0> perl6: { my @a=<1 2 3 4>; say @a[]}

[16:09] <p6eval> elf 24144: OUTPUT[syntax error at (eval 117) line 4, near "[]"␤ at ./elf_f line 3861␤]

[16:09] <p6eval> ..rakudo 33456: OUTPUT[1␤]

[16:09] <p6eval> ..pugs: OUTPUT[1234␤]

[16:10] <ruoso> but a method of Iterable

[16:10] <ruoso> where both List and Range are Iterable

[16:10] <dr_df0> what should @a[] return?

[16:10] <pmichaud> all of @a

[16:10] <dr_df0> so it's a bug in rakudo

[16:11] <pmichaud> rakudo currently thinks of @a[] as being @a[0], I suspect.

[16:11] <pmichaud> slices are still unimpl in rakudo

[16:11] <pmichaud> (although I'm looking at that now)

[16:11] <pmichaud> rakudo:  my @a = <a b c d>;  say @a[];

[16:11] <p6eval> rakudo 33456: OUTPUT[a␤]

[16:11] <ruoso> and maybe certain operators expect an Iterable

[16:12] <ruoso> like feed

[16:12] <dr_df0> you're right that's also special case of slice

[16:12] <pmichaud> I think I may be able to get rvalue slices to work fairly quickly.  lvalue slices might take a bit more work (either that or we just cheat and vivify everything in the slice even if it's not lvalue)

[16:13] <ruoso> anyway... got to go...

[16:13] * ruoso commuting &

[16:13] *** ruoso left
[16:14] *** simcop2387 left
[16:14] *** dr_df0 left
[16:14] *** bacek left
[16:14] *** apeiron left
[16:14] *** lizsac left
[16:14] *** p6eval left
[16:14] *** masak joined
[16:16] *** dr_df0 joined
[16:16] *** bacek joined
[16:16] *** apeiron joined
[16:16] *** lizsac joined
[16:16] *** simcop2387 joined
[16:16] *** p6eval joined
[16:16] *** tcliou|Away joined
[16:16] *** zostay joined
[16:19] <dr_df0> pugs: my @a=<1 2 3 4>; for @a { say }

[16:19] <p6eval> pugs: OUTPUT[␤␤␤␤]

[16:20] <masak> pugs: my @a=<1 2 3 4>; for @a { .say }

[16:20] <p6eval> pugs: OUTPUT[1␤2␤3␤4␤]

[16:21] <masak> dr_df0: $_ doesn't quite work the same as in Perl 5

[16:21] *** tewk left
[16:21] <masak> it's not an implicit variable in print functions, for example.

[16:21] <dr_df0> masak: got it

[16:22] *** dr_df0 left
[16:23] *** adc_penner joined
[16:24] *** tewk joined
[16:26] <masak> s/variable/argument/

[16:28] *** eternaleye joined
[16:34] *** sri_kraih_ joined
[16:34] *** lambdabot left
[16:35] *** smg joined
[16:36] *** Lorn joined
[16:37] *** lambdabot joined
[16:47] *** vixey left
[16:49] *** armagad joined
[16:51] *** sri_kraih left
[16:52] <riffraff> pugs: 1 <=> 2

[16:52] <p6eval> pugs: RESULT[-1]

[16:52] <riffraff> rakudo: 1 <=> 2

[16:53] <p6eval> rakudo 33458: RESULT[Order::Increase]

[16:56] <riffraff> mh

[16:57] <riffraff> ah, <=> is numeric semantics, right?

[16:58] <masak> aye

[17:00] <moritz_> not only, it's generalized

[17:00] <moritz_> perl 5 <=> is called 'leg' in Perl 6

[17:00] <moritz_> (less, equal, greater)

[17:01] <moritz_> no, I confused that with cmp

[17:01] <moritz_> forget what I said

[17:01] <riffraff> I found leg, yeah it seems to be string comparison and cmp is the general one 

[17:02] <moritz_> right

[17:02] <moritz_> and <=> is still numeric-only

[17:02] <moritz_> sorry for the confusion

[17:02] <riffraff> no worries :)

[17:03] <riffraff> is there something to swap to elements of an array?

[17:03] <riffraff> dunno, a magic @ary.swap(0,1)

[17:03] *** vixey joined
[17:04] <pmichaud> doesn't exist yet, but eventually:    @ary[0,1] = @ary[1,0]

[17:04] <pmichaud> (doesn't exist yet == not implemented yet)

[17:04] <riffraff> ok, thanks

[17:09] <masak> (@ary[0,1] = @ary[1,0])++

[17:09] *** ejs left
[17:09] <moritz_> slices++

[17:10] <masak> re Aristotle's p6l mail, I like the idea, but would expect such a solution to be an extension to normal Perl 6.

[17:11] *** meppl joined
[17:12] <riffraff> oh, I crashed rakudo, with backtrace, shall I submit a PR ?

[17:13] <moritz_> if it's not a known (aka reported) bug, yes.

[17:13] <moritz_> or just submit it, and I can merge it if there's a duplicate

[17:17] <masak> riffraff++ # yes, submit rakudobug early and often

[17:19] <riffraff> rakudo: say [1].size

[17:19] <p6eval> rakudo 33458: OUTPUT[Method 'size' not found for invocant of class 'Perl6Array'␤current instr.: '_block11' pc 34 (EVAL_13:16)␤]

[17:19] <moritz_> rakudo: say [1].elems

[17:19] <p6eval> rakudo 33458: OUTPUT[1␤]

[17:19] <moritz_> "size' is just as evil as "length', because it doesn't imply units

[17:20] <riffraff> yes, but the point is that after that I get

[17:20] <moritz_> rakudo: say <ab cd>.chars

[17:20] <p6eval> rakudo 33458: OUTPUT[5␤]

[17:20] <riffraff> *** glibc detected *** ./perl6: double free or corruption (!prev): 0x08356858 ***

[17:20] <riffraff> "double free or corruption"

[17:20] <moritz_> I'm pretty sure that's wrong

[17:20] <moritz_> riffraff: that's worth reporting, yes

[17:22] <moritz_> afk

[17:25] <masak> riffraff: you run the ./perl6 executable, right?

[17:26] <masak> that's when you run into that, because it calls Parrot with some "die on double free accidents" flag.

[17:27] <riffraff> yes

[17:27] <riffraff> in fact I was not updating evrything and I was gpoing to try running it with parrot perl.pbc

[17:27] <riffraff> s/not/now/

[17:27] <masak> doing that, you will probably not see the double free error.

[17:28] <masak> (that doesn't mean it isn't wrong, or not worth reporting, of course)

[17:29] <riffraff> yep

[17:33] *** eternaleye left
[17:36] *** ruoso joined
[18:01] *** explorer left
[18:07] *** dr_df0 joined
[18:09] <ruoso> pugs: sub a($x) { say $x }; a(:a<b>);

[18:09] <p6eval> pugs: OUTPUT[*** Named argument found where no matched parameter expected: (a,Val (VStr "b"))␤    at /tmp/DzNDazT81q line 1, column 23-31␤]

[18:09] <ruoso> pugs: sub a(Pair $x) { say $x }; a(:a<b>);

[18:09] <p6eval> pugs: OUTPUT[*** Named argument found where no matched parameter expected: (a,Val (VStr "b"))␤    at /tmp/2z9krAUvUq line 1, column 28-36␤]

[18:09] <ruoso> rakud: sub a(Pair $x) { say $x }; a(:a<b>);

[18:09] <ruoso> rakudo: sub a(Pair $x) { say $x }; a(:a<b>);

[18:09] <p6eval> rakudo 33458: OUTPUT[too many named arguments - 'a' not expected␤current instr.: 'a' pc 70 (EVAL_13:38)␤]

[18:09] <moritz_> pugs: sub a(Pair $x) { say $x }; a((:a<b>));

[18:09] <p6eval> pugs: OUTPUT[a  b␤]

[18:09] <moritz_> rakudo: sub a(Pair $x) { say $x }; a((:a<b>));

[18:09] <p6eval> rakudo 33458: OUTPUT[a  b␤]

[18:10] <moritz_> perl6: sub a(Pair $x) { say $x }; a((:a<b>));

[18:10] <p6eval> elf 24144: OUTPUT[Unquoted string "b" may clash with future reserved word at (eval 121) line 5.␤a b␤]

[18:10] <p6eval> ..pugs, rakudo 33458: OUTPUT[a    b␤]

[18:10] <ruoso> ok... the spec says that...

[18:10] <ruoso> or is that just the way pugs and rakudo are working now?

[18:10] <moritz_> what's wrong with what they do?

[18:10] <moritz_> looks fine to me.

[18:11] <ruoso> it's not wrong...

[18:11] * moritz_ is relieved ;-)

[18:11] <ruoso> I was wondering if the capture would need to traverse inner lists to find named arguments

[18:11] *** alester joined
[18:11] *** eternaleye joined
[18:12] *** rindolf left
[18:12] <ruoso> but it seems that named arguments must be explicitly in the "first level" in the capture 

[18:12] <ruoso> which makes things much easier

[18:12] <ruoso> moritz_, but is that in the spec?

[18:12] <moritz_> I'm pretty sure it is.

[18:12] <moritz_> at least by example

[18:13] <ruoso> yes... it is

[18:13] <ruoso> S06 makes it very clear

[18:14] * ruoso *phew*

[18:14] <PerlJam> anyone know off hand what Juerd uses to accomplish the virtual feathers?

[18:15] <moritz_> istr xen, but not sure

[18:15] <masak> an imaginary henhouse, perhaps?

[18:15] * masak ducks

[18:15] *** gbacon left
[18:16] <moritz_> moritz@feather3:~$ uname -a

[18:16] <moritz_> Linux feather3 2.6.18-6-xen-686 #1 SMP Sun Feb 10 22:43:13 UTC 2008 i686 GNU/Linux

[18:16] <moritz_> that looks very much like a xen guest kernel to me

[18:16] <ruoso> PerlJam, setting up xen with debian is piece-of-cake

[18:16] <ruoso> there's a tutorial in the debian wiki about it

[18:16] <masak> how duz I flush output in Rakudo?

[18:18] <moritz_> masak: 1) spec it 2) implement it 3) do it ;-)

[18:18] <masak> arrgh!

[18:18] <ruoso> masak, but I'd probably guess $io.flush

[18:18] <ruoso> namely

[18:18] <ruoso> $*OUT.flush

[18:18] * masak tries

[18:19] <masak> "Method 'flush' not found for invocant of class 'IO'"

[18:19] * masak hits the source code

[18:19] <ruoso> but the name would not be flush, I guess...

[18:19] <masak> ENOSUCHMETHOD

[18:19] * ruoso perldoc IO::Handle

[18:19] <masak> time to badger pmichaud about it on #parrot

[18:20] <ruoso> hmm... the name would be flush indeed... considering IO::Handle provides it

[18:22] *** eternaleye left
[18:24] *** justatheory joined
[18:24] *** gbacon joined
[18:28] <PerlJam> moritz_: you're so smart :)

[18:28] <moritz_> PerlJam: hm?

[18:29] <PerlJam> moritz_: uname

[18:29] <PerlJam> anyway, xen does look easy and good, so I'm going with it  :)

[18:31] <ruoso> xen++

[18:37] *** ryanc joined
[18:37] *** explorer joined
[18:45] *** araujo left
[19:00] <rakudo_svn> r33459 | pmichaud++ | [rakudo]: spectest-progress.csv update: 227 files, 4689 passing, 10 failing

[19:00] <rakudo_svn> r33459 | pmichaud++ | Failure summary:

[19:00] <rakudo_svn> r33459 | pmichaud++ |     S12-methods/default-trait.t aborted 6 test(s)

[19:00] <rakudo_svn> r33459 | pmichaud++ |     S12-methods/multi.t aborted 4 test(s)

[19:06] *** dr_df0 left
[19:07] *** adc_penner left
[19:09] *** adc_penner joined
[19:18] *** araujo joined
[19:27] *** armagad left
[19:30] *** rindolf joined
[19:40] *** kane__ left
[19:42] *** zamolxes joined
[20:05] <masak> rakudo: say ([0 xx 4] xx 4).perl

[20:05] <p6eval> rakudo 33459: OUTPUT[[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]␤]

[20:05] <masak> xx++

[20:06] <moritz_> pugs: say ([0 xx 4] xx 4).perl

[20:06] <p6eval> pugs: OUTPUT[(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)␤]

[20:06] *** alester_ joined
[20:06] <moritz_> anyway, I think that the LHS of xx should only be evaluated once, so it should actually return 4 refs to the same array

[20:07] <masak> and if I actually want four different arrays...?

[20:07] <moritz_> then use map.

[20:07] <masak> :/

[20:07] <masak> no adverbs to the rescue?

[20:07] <moritz_> you might re-check the specs, though

[20:07] <masak> I'm in programming mode right now. later p'haps.

[20:10] <masak> rakudo: say (map { [0 xx 4] }, ^4).perl

[20:10] <p6eval> rakudo 33459: OUTPUT[[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]␤]

[20:14] *** IRSeekBot left
[20:17] *** alester_ left
[20:21] <masak> easiest way to loop through all values of an enum?

[20:22] <masak> rakudo: enum A <a b c>; say A.values

[20:22] <p6eval> rakudo 33459: OUTPUT[Method 'values' not found for invocant of class 'Role'␤current instr.: '_block18' pc 26 (EVAL_16:17)␤]

[20:23] <masak> :(

[20:25] *** explorer left
[20:38] *** rafl_ is now known as rafl

[20:39] <masak> I just inadvertently typed `loop { ... } until ...` instead of `repeat { ... } until ...`. I think the former construction should be forbidden by spec.

[20:40] <masak> (normally I wouldn't care, but 'loop' and 'repeat' are very easy to confuse, at least in my mind)

[20:44] <masak> ok, add to my queue of questions the question "How do I get the index of an enum item?"

[20:45] <moritz_> if it's a simple integer enum, no problem ;-)

[20:46] <masak> eh? you mean like `enum A <1 2 3>`?

[20:46] <masak> (yes, I noticed the smiley)

[20:46] <moritz_> rakudo: enum A <foo bar baz>; say A::baz

[20:47] <p6eval> rakudo 33460: OUTPUT[2␤]

[20:47] <moritz_> masak: like this ;-)

[20:47] <masak> ooh

[20:47] <masak> simpler than I guessed. :)

[20:47] <moritz_> but integer values are only the default, arbitrary objects are also possible

[20:48] <moritz_> rakudo: enum A :foo<bar>, :bla<blubb>; say A::bla

[20:48] <p6eval> rakudo 33460: OUTPUT[Statement not terminated properly at line 1, near ":foo<bar>,"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[20:48] <masak> then I guess my question is instead, given A::baz, how do I get the string 'baz'?

[20:48] <moritz_> rakudo: enum A <foo bar baz>; say A::baz.WHAT

[20:48] <p6eval> rakudo 33460: OUTPUT[␤]

[20:48] * masak chuckles

[20:48] <moritz_> hrmpf

[20:49] <masak> thank you for playing :)

[20:49] <moritz_> probably A::baz.WTF ;-)

[20:49] <masak> aye ;)

[20:50] * moritz_ is just installing an amd64 Debian Lenny

[20:51] * masak is writing a board game in Perl 6

[20:51] <moritz_> and since this is the 21st century, it worked from usb stick, no need to burn a disk

[20:51] <masak> (21st century)++

[20:52] <moritz_> indeed

[20:53] <moritz_> but the intertubes are still too weak...

[20:53] <moritz_> 40min for the netinstaller to download all those nice packages

[20:53] <jnthn> I don't know that .WHAT on an enum element is spec'd.

[20:53] <moritz_> and that's just the default install

[20:53] <masak> jnthn: so there's no way to get 'baz' from A::baz?

[20:54] <moritz_> jnthn: since an enum item is also a type, and .WHAT returns the short name of a type, i'd say you have an answer ;-)

[20:54] <jnthn> masak: It may turn out that's what A::baz.WHAT is meant to do.

[20:54] <masak> the sooner it turns out that way, the better :)

[20:54] <jnthn> moritz_: Aye, it could be argued that the individual values are just instances of the role A and it should say A, or it could be argued that the values are actually Ints by default so it should say Int...

[20:55] <masak> perl6: my @a = 0 xx 4; @a[0] = 42; say @a.perl

[20:55] <p6eval> rakudo 33460: OUTPUT[[42, 42, 42, 42]␤]

[20:55] <p6eval> ..pugs: OUTPUT[\(42, 0, 0, 0)␤]

[20:55] <p6eval> ..elf 24144: OUTPUT[[42,0,0,0]␤]

[20:55] <moritz_> jnthn: right

[20:55] <jnthn> masak: Oooh, that's a good one!

[20:56] <masak> who's right, elf/pugs or rakudo?

[20:56] <jnthn> I vote elf.

[20:56] * masak files rakudobug

[20:56] <jnthn> Oh, Pugs isn't so wrong either.

[20:56] <masak> nothing beats actually using the language!

[20:56] <jnthn> Rakudo is massive fail.

[20:57] <masak> :)

[20:57] <moritz_> aye ;-)

[20:57] <pmichaud> I suspect infix:<xx> is miswritten.

[20:57] <jnthn> pmichaud: Yup, I suspect the same.

[20:57] <pmichaud> I bet it just puts the same PMC in the list multiple times.

[20:57] <jnthn> It's just sticking the...yes.

[20:57] <jnthn> :-)

[20:57] <pmichaud> oh, actually....

[20:57] <jnthn> Well, should be easy rakudobug to fix.

[20:58] <pmichaud> I think infix:<xx> is okay in that sense, and assignment is broken.

[20:58] <moritz_> speaking of easy fixes, would somebody please review #60976?

[20:58] <pmichaud> I already know that list->array conversion isn't right -- I was working on that.

[20:58] <jnthn> I think the problem is that array elements are containers and need to be initialized as such.

[20:59] <pmichaud> I looked at the patch for 60976, and while it "feels wrong" I couldn't come up with a better answer for now.

[20:59] <pmichaud> it's okay with me if someone applies it.

[20:59] <jnthn> (Which does fit with list->array conversion wanting a fixup)

[20:59] *** thepler joined
[20:59] <moritz_> pmichaud: ok, will do then

[20:59] <pmichaud> jnthn: it's part of my whole "I want to redo assignment again" brain branch

[21:00] <pmichaud> it's not a major redo, just some of the details.

[21:00] <jnthn> At least it only takes an afternoon each time you decide that. ;-)

[21:00] <pmichaud> the basics remain the same, just some of the individual operations change

[21:00] <jnthn> OK

[21:01] <pmichaud> jnthn: which would you take as a better use of my time today/tomorrow:  parameter refactor, or assignment & slices ?

[21:01] <jnthn> BTW, do you have postcircumfix:[ ] and postcircumfix:{ } on the "things you'd rather do yourself" list, or can I take a crack at those?

[21:01] <pmichaud> the postcircumfixes are definitely part of assignment and slices

[21:02] <jnthn> OK. Are you going to do list assignment within that?

[21:02] <pmichaud> at least a first cut, yes.

[21:02] <jnthn> OK, I'd say go for that.

[21:02] <jnthn> We need to do both of course.

[21:02] <pmichaud> yes, I'm thinking the same.

[21:03] <jnthn> OK.

[21:04] <jnthn> Is there anything you want me to look at, aside from the Perl6MultiSub stuff that is currently broken?

[21:04] <pmichaud> that would be my priority at the moment.

[21:04] <pugs_svn> r24145 | moritz++ | [t/spec] unfudge passing test for rakuo (subtypes.t)

[21:04] <jnthn> OK.

[21:06] <pmichaud> out of curiosity, is there a way that we can do mmd on ObjectRef ?

[21:06] *** riffraff left
[21:06] <jnthn> Trouble is that it appears fairly transparent to the dispatch.

[21:06] <pmichaud> yes, I know.

[21:07] <pmichaud> if not, it's okay -- I was just curious.

[21:07] <jnthn> It responds do isa.

[21:07] <jnthn> As in, if you do isa it hijacks it and knows it's an ObjectRef.

[21:07] <pmichaud> right, I use that already.

[21:07] <pmichaud> I was just wondering if it could be that way in the :multi() as well.  But I was guessing it'd be problematic, for the reason you cite.

[21:08] <pmichaud> I'm thinking I'll likely hijack the assign opcode.

[21:08] <jnthn> Perl6MultiSub would check that, I think, while I don't know that Parrot's MMD does that. You maybe, if you can create a ProtoObject for ObjectRef, can make it work.

[21:08] <jnthn> But it'd have to be using Perl6MultiSub and have a signature. :-)

[21:08] <pmichaud> oh, I'm thinking replacing our use of 'copy' with 'assign'

[21:09] <pmichaud> and fix 'assign' to dtrt

[21:09] <jnthn> As in, change the actual Parrot op?

[21:09] <pmichaud> for Perl 6 types, yes.

[21:09] <pmichaud> since I don't expect to ever have a non-Perl 6 type as a container.

[21:09] <jnthn> If we're doing something Perl 6 specific, should we not be creating our own assign op?

[21:09] <jnthn> (dynop)

[21:10] <pmichaud> yes, but previously Rakudo would sometimes get Integer or String or Float or ResizablePMCArray as containers

[21:10] <rakudo_svn> r33463 | moritz++ | [rakudo] make 'where /regex/' subset types work. riffraff++. Closes RT #60976

[21:10] <rakudo_svn> r33463 | moritz++ | Patch courtesy by Gabriele Renzi <rff.rff at gmail.com>

[21:10] <pmichaud> (long ago)

[21:10] <pmichaud> then we moved to Perl6Scalar, but we went with infix:= as a method because there were still cases where array elements were non-rakudo types

[21:10] * jnthn isn't following

[21:10] <jnthn> Can you give me a little more specifics?

[21:11] <pmichaud> before we had Perl6Scalar, variables could be bound to Parrot types

[21:11] <pmichaud> thus my $a = 3 * 4;  would end up with $a as an Integer PMC and not an Int

[21:11] <jnthn> Ah, yes.

[21:11] <pugs_svn> r24146 | moritz++ | [t/spec] tests for RT #61026: infix:<xx> should return independant copies of

[21:11] <pugs_svn> r24146 | moritz++ | value types

[21:11] <pmichaud> obviously I can't change the assign vtable for Integer

[21:12] <jnthn> No.

[21:12] <pmichaud> then we went to Perl6Scalar, where $a held a reference to its value

[21:12] <pmichaud> that worked for my $a = 3 * 4;   but didn't help with   @a[4] = 3 * 4;

[21:12] <pmichaud> because @a[4] wasn't itself a Perl6Scalar PMC

[21:12] <pmichaud> i.e., it would still end up being an Integer PMC

[21:13] <pmichaud> so, the alternative was to have arrays be arrays of Perl6Scalar PMCs (bad), or come up with a way of marking PMCs as containers

[21:14] <pmichaud> my position at the moment is that all of our containers will be a rakudo-specific type, or at least act like one (ignoring HLL interop and binding for the moment)

[21:14] <pmichaud> so, while we can't override assign vtable on Integer PMC, we definitely *can* override it for Int.

[21:14] <jnthn> Yes, true.

[21:15] <pmichaud> so we just make sure that everything that goes into a container is something that's a subclass of Object

[21:15] <pmichaud> or an ObjectRef

[21:15] <pmichaud> or some other type that we "control"

[21:15] <pmichaud> and if not then it's coerced to one.

[21:15] <jnthn> OK, e.g. by wrapping it up in an ObjectRef.

[21:15] <pmichaud> This is what I'm doing now to automatically coerce Parrot String PMC into Str objects.

[21:16] <pmichaud> anyway, it should all "just work".  Even better, we can be a lot more efficient than 'copy'

[21:16] <pmichaud> .

[21:16] <pugs_svn> r24147 | moritz++ | [t/spec] another two tests for RT #61026

[21:16] <jnthn> Yes.

[21:16] <pmichaud> by not creating unneeded clones.

[21:16] <jnthn> (Also note that we can tell if our caller is from a different HLL very cheaply, once .HLL is in place.)

[21:17] <jnthn> (So we only need to do the coercion path in a signature to handle interop if it's needed.)

[21:17] <jnthn> Erm, when bidning to a signature.

[21:17] <jnthn> But let's get it right for calls within Perl 6 first.

[21:17] <pmichaud> when binding to a result that isn't a rakudo object.

[21:17] <pmichaud> exactly

[21:18] <pmichaud> I'll handle the p6 case now, an interop a bit later.

[21:18] <pmichaud> *and

[21:18] <jnthn> Well, if we handle it when binding a signature...

[21:18] <jnthn> Since HLL interop is pretty much at the sub level.

[21:18] <pmichaud> yes, it could happen then.  Depends on how well other-HLL subs play with our calling conventions.

[21:18] <jnthn> But yes, p6 case now.

[21:18] <pmichaud> okay, I'll work on assign+list assign+slicing today

[21:19] <pmichaud> (and a few pct updates for subid)

[21:19] <jnthn> Great. :-)

[21:19] <jnthn> I've been handling $other_stuff today.

[21:19] <pmichaud> I may want to add roles to P6object, too :-)

[21:19] *** rindolf left
[21:20] <pmichaud> at least make it easier to attach roles to newly created classes.

[21:20] <jnthn> Yay roles! :-)

[21:20] <pmichaud> oooh

[21:20] <pmichaud> I wonder if 'parent'=> ...   should really be 'does'=> ...   in P6object

[21:21] <jnthn> It'd be nice if future additions to P6Object could match the HOW API in http://www.perlfoundation.org/perl6/index.cgi?smop_oo_api

[21:22] <jnthn> (The Declaration API section is relevant here)

[21:22] <jnthn> parent can handle it too, since that's not in the API.

[21:23] <jnthn> (That is, if the methods on P6Object are a superset of those in the HOW API, we make life easy for ourselves... :-))

[21:23] <pmichaud> well, those methods are really on P6metaclass

[21:23] <jnthn> Yes.

[21:23] <pmichaud> it's been my intent to do something like that with P6metaclass, although I hadn't been following this section precisely

[21:24] <jnthn> OK. I think what's under HOW API and Declaration API is likely to become spec.

[21:24] <pmichaud> but we now have an 'add_method' method under P6metaclass, for example.

[21:24] <jnthn> (As in, the stuff you need to implement to make your own metaclass)

[21:24] <jnthn> Yes. And I think it matches this API already. :-)

[21:25] <pmichaud> if not it's pretty close.

[21:26] <jnthn> Curiously, the API appears to be missing an add_parent

[21:26] <pmichaud> indeed, I was just noticing that.

[21:26] <pmichaud> maybe bless...?

[21:26] <pmichaud> the *@protoobjects argument...?

[21:27] <jnthn> No, those are the things with the WHENCE closures attached for auto-viv.

[21:28] <pmichaud> compose_role, then?

[21:28] <jnthn> Composition is a fundementally different operation to inheritance.

[21:28] <pmichaud> true.

[21:28] <jnthn> I really don't think the two should be conflated.

[21:28] <jnthn> Especially as every class implies the existence of a role of the same name...

[21:29] <pmichaud> anyway, it's a good target to work with for now.

[21:29] <jnthn> Yes.

[21:29] <jnthn> @help

[21:29] <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands

[21:29] <jnthn> @list

[21:30] <lambdabot> http://code.haskell.org/lambdabot/COMMANDS

[21:30] <jnthn> @tell ruoso Is the HOW API not missing an add_parent?

[21:30] <lambdabot> Consider it noted.

[21:30] <masak> report from the front: game programming in Perl 6 is fun!

[21:31] <pmichaud> anyway, the advantage of assign vtable is that we get our "automatic dispatch based on assignment type"

[21:31] <jnthn> Yes.

[21:31] <moritz_> masak: do you find different bugs than during wiki programming? ;-)

[21:31] <pmichaud> without having to do a lot of 'isa' tests.

[21:31] <ruoso> jnthn, it probably is

[21:31] <lambdabot> ruoso: You have 1 new message. '/msg lambdabot @messages' to read it.

[21:31] <jnthn> And probably rather cheaply too.

[21:31] <masak> moritz_: I do indeed.

[21:31] <jnthn> ruoso: Ah, you're on the channel! :-)

[21:32] <ruoso> jnthn, :)

[21:32] <jnthn> ruoso: In method dispatch($how: $object, $responder, $identifier, $capture --> Any) {...}

[21:32] <jnthn> What is $responder?

[21:32] <pmichaud> I'd really like to see us get masak's use.perl postings into the planet perlsix feed.

[21:33] <pmichaud> who can make that happen?

[21:34] <ruoso> jnthn, well... it's the responder interface for that object... but I presume we can drop that

[21:34] <moritz_> pmichaud: mailto:webmaster@perl.org

[21:34] <pmichaud> moritz_: thanks.

[21:34] <moritz_> it's a perl.org site after all ;-)

[21:34] * pmichaud composes mail.

[21:35] <jnthn> ruoso: OK, I'm not sure what the Rakudo equivalent would be there.

[21:35] <ruoso> and it doesn't really matters to such high-level

[21:35] <masak> if a set of game rules are copyrighted, what restrictions apply to an implementation of a game implementing those rules?

[21:36] <ruoso> jnthn, but, at least in smop, it would return the representation

[21:36] <ruoso> most of the time, p6opaque

[21:36] <moritz_> masak: I don't think there's an universal answer for every country

[21:36] <jnthn> ruoso: OK.

[21:37] <jnthn> If we can drop it, that clears up one of my questions about getting Rakudo to match this API. :-)

[21:37] <masak> moritz_: I see. my main concern right now is whether I dare commit the source to this game I'm working on to the Pugs repo.

[21:37] * jnthn afk for a bit

[21:38] <ruoso> jnthn, yeah... we can drop it... if one needs the responder for the object it still can ask for that directly on the invocant

[21:38] <jnthn> ruoso: OK, great. :-)

[21:38] <ruoso> jnthn, but note that $object in the dispatch is not the invocant

[21:39] <ruoso> jnthn, I should probably rename that in the signature to $proto 

[21:39] <jnthn> Oh?

[21:39] <ruoso> wait a sec... let me check something and I'll rephrase that

[21:39] <jnthn> It's the proto-object instead?

[21:40] *** bacek left
[21:40] <pmichaud> it's the "class" that you're manipulating

[21:40] <pmichaud> the invocant is just the metaobject

[21:41] <pmichaud> (so yes, it's the protoobject.)

[21:41] <pmichaud> s/metaobject/metaclass object/

[21:41] *** Lorn left
[21:41] <ruoso> yeah... I think so...

[21:42] <jnthn> ruoso: But isn't this the thing to dispatch a call?

[21:42] <pmichaud> oh, sorry, I was thinking of something else.

[21:42] <pmichaud> yes, in dispatch I would expect it to be $object

[21:42] <jnthn> Me too.

[21:42] <jnthn> It's the thing on the LHS of the . operator.

[21:43] <jnthn> Which may be a proto.

[21:43] <jnthn> But may not be too.

[21:43] <pmichaud> right, but doesn't have to be.

[21:43] <ruoso> right... I was confused by the fact that p6opaque is currently not implementing what is on the wiki

[21:44] <masak> moritz_: I just emailed you the source code so far. I need to show someone, but I don't dare upload it. :)

[21:45] <pmichaud> afk for a bit -- need a short break

[21:45] <ruoso> jnthn, $object.^dispatch("methodname", \($capture)) is a syntax sugar for $object.HOW.dispatch($object, "methodname", \($capture))

[21:45] <ruoso> so yes, $object is the same as the invocant

[21:45] <jnthn> Yes. Good. :-)

[21:45] <jnthn> You had me wondering there... :_)

[21:45] <jnthn> OK, I'm afk too - need to do my Slovak homework before the lesson tomorrow

[21:46] <ruoso> which means that you can have a different invocant in the capture you send to dispatch

[21:46] <ruoso> jnthn, beware of $object.^dispatch("methodname",\($otherobject: $as, $invocant))

[21:46] <masak> perl6: enum A <foo bar baz>; say A::baz eq "baz"

[21:46] <p6eval> pugs: OUTPUT[*** No such subroutine: "&enum"␤    at /tmp/YpsCoI2Mrh line 1, column 1-21␤]

[21:46] <p6eval> ..elf 24147: OUTPUT[Use of uninitialized value $r in concatenation (.) or string at ./elf_f line 3451.␤syntax error at (eval 125) line 3, near "> )"␤ at ./elf_f line 3861␤]

[21:46] <p6eval> ..rakudo 33464: OUTPUT[0␤]

[21:47] <masak> ...different degrees of fail...

[21:47] <pmichaud> is it specified how enums stringify yet?

[21:47] <masak> dunno.

[21:47] <moritz_> masak: I think rakudo is correct

[21:47] <pmichaud> I've been waiting for an answer for that for  Bool::True, etc and Order::Increase

[21:47] <masak> oki

[21:47] <moritz_> since A::baz is 2

[21:48] <masak> moritz_: I thought maybe it could stringify to 'baz'

[21:48] <pmichaud> I haven't seen an official answer yet.

[21:48] <pmichaud> perl6:  say 'a' leg 'b';

[21:48] <p6eval> elf 24147: OUTPUT[Undefined subroutine &GLOBAL::infix_leg called at (eval 119) line 3.␤ at ./elf_f line 3861␤]

[21:48] <p6eval> ..pugs, rakudo 33464: OUTPUT[-1␤]

[21:48] <masak> we should make a list somewhere of questions awaiting official answers.

[21:49] <pmichaud> I propose RT

[21:49] <masak> Pugs and Rakudo have a leg up on Elf :P

[21:49] <pmichaud> there's nothing that says the perl6 queue has to be strictly rakudo, and it's hosted on perl.org

[21:49] <masak> true.

[21:49] <pmichaud> TimToady has asked that outstanding questions be posted to p6l, but we still end up with questions being lost

[21:50] <pmichaud> so I'm guessing a dual-pronged approach.

[21:50] <masak> so I'll just email random unanswered questions to rakudobug, then?

[21:50] <pmichaud> yes, and I think perl6-bug works as well.

[21:50] <masak> perl6-bug @ .WHAT ?

[21:50] <pmichaud> perl.org

[21:50] <masak> oki

[21:50] <pmichaud> we might want to create a separate 'rakudo' queue on RT at some point.

[21:51] <pmichaud> in the meantime, let's just queue them on RT

[21:52] <masak> aye

[21:52] <masak> mail sent.

[21:55] <thei0s> moritz_: could you tell me then where would be a good place to such send bug report with a short example of not working code?

[21:55] <thei0s> hm

[21:55] <thei0s> lol

[21:56] <thei0s> (didn't read what whas the discussion about atm) :D

[21:56] <moritz_> [email@hidden.address]
[21:57] <moritz_> masak: nice thing, though I haven't read through all of the rules yet

[21:57] <masak> it only does the sarsen thing so far.

[21:57] <buu> w21

[21:58] <masak> moritz_: I bought a custom LEGO set in order to play this game. it's fascinatingly complex.

[22:02] *** dr_df0 joined
[22:05] *** sri_kraih_ left
[22:16] *** justatheory left
[22:32] <pmichaud> ...lego?

[22:32] <pmichaud> details, please!

[22:33] <pmichaud> http://picasaweb.google.com/patrick.michaud/Lego

[22:33] <lambdabot> Title: Picasa Web Albums - Pm - lego

[22:33] <pmichaud> (I need to put up more lego pics)

[22:36] <moritz_> the last thing I built with lego was a combination lock ;-)

[22:37] <masak> pmichaud: http://www.gamerz.net/pbmserv/druid.html

[22:37] <lambdabot> Title: Help For the Game Of Druid

[22:37] <pmichaud> we just finished the death star a couple of weeks ago

[22:38] <masak> pmichaud: if you have enough 2x2 and 2x6, you should definitely try the game. it's a blast.

[22:38] <masak> soon coming to a Perl 6 implementation near you!

[22:38] <pmichaud> given that we have several dozen lego sets here, I imagine I have plenty of 2x2 and 2x6 bricks lying about :-)

[22:39] <masak> the game is surprizingly deep. I still haven't really grokked it.

[22:40] <masak> unlike Hex, you can grab already-taken territory from your opponent. that's kinda freaky.

[22:49] <thei0s> rakudo: token Test1 { (<ab>) }; token ab { 'ab' }; "abaaab" ~~ Test1; say "before $/[0]<ab> after";

[22:49] <p6eval> rakudo 33466: OUTPUT[before ab[0]<ab> after␤]

[22:50] <thei0s> is it possible to make this work, without going out from the escaped string and using string concatenation?

[22:55] <masak> rakudo: token Test1 { (<ab>) }; token ab { 'ab' }; "abaaab" ~~ Test1; say "before {$/[0]<ab>} after";

[22:55] <p6eval> rakudo 33466: OUTPUT[before ab after␤]

[22:55] <masak> thei0s: there you go.

[22:55] <masak> thei0s: interpolation of indexed things is not implemented yet -- but interpolation of closures is.

[22:56] <jnthn> masak: Did you file a ticket for that one yet? ;-)

[22:56] <masak> jnthn: I think so. :)

[22:56] * masak checks

[22:56] *** jhorwitz left
[22:56] <thei0s> masak: 10x

[22:57] <masak> jnthn: http://rt.perl.org/rt3/Ticket/Display.html?id=60936

[22:57] <lambdabot> Title: #60936: [TODO] implement method calls in interpolating strings

[22:57] <masak> ...but I see it's not really general enough to cover this case.

[22:57] <masak> changing name.

[22:58] <pmichaud> we just have to make sure there's a postcircumfix at the end.

[22:59] <masak> pmichaud: what'll happen if someone defines a new postcircumfix operator? will the semantics of strings change?

[23:00] <pmichaud> I suppose they could, if there are any strings that have those postcircumfixes in them.

[23:00] <pmichaud> I'd have to look more closely at STD.pm to see.

[23:00] <masak> cool.

[23:02] *** Limbic_Region joined
[23:02] <pmichaud> of course, I think it would only affect strings in the same scope as where the new postcircumfix operator is defined.

[23:03] *** iblechbot left
[23:03] <masak> that is reasonable.

[23:03] <masak> no, actually that's a must :)

[23:04] <thei0s> rakudo: token Test2 { .* { say "foo"; } }; say ( "abaaab" ~~ Test1 ) ?? "ok" !! "not ok";

[23:04] <p6eval> rakudo 33466: OUTPUT[Statement not terminated properly at line 1, near "say \"foo\";"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[23:04] <pmichaud> closures not implemented in regexes.

[23:04] <thei0s> i see :)

[23:04] <pmichaud> Perl 6 closures, that is.

[23:04] <pmichaud> I can probably modify pge's grammar to report that as an error.

[23:05] <jnthn> rakudo: token Test2 { .* {{ say "foo" }} }; say ( "abaaab" ~~ Test1 ) ?? "ok" !! "not ok";

[23:05] <p6eval> rakudo 33466: OUTPUT[not ok␤]

[23:05] <jnthn> Ah

[23:05] <pmichaud> I'm also _very_ tempted to throw an error on the   ~~ Test1   meme.

[23:05] <jnthn> token Test1 { .* {{ say "foo" }} }; say ( "abaaab" ~~ Test1 ) ?? "ok" !! "not ok";

[23:05] <masak> pmichaud: do it!

[23:05] <jnthn> rakudo: token Test1 { .* {{ say "foo" }} }; say ( "abaaab" ~~ Test1 ) ?? "ok" !! "not ok";

[23:05] <p6eval> rakudo 33466: OUTPUT[foo␤ok␤]

[23:05] <jnthn> Yes.

[23:05] <jnthn> We should.

[23:06] <jnthn> See, it works. ;-)

[23:06] <thei0s> ups :D

[23:06] <masak> jnthn: you are evil :)

[23:06] <jnthn> thei0s: I'm being cruel, because say "foo" is valid PIR, as well as Perl 6. :-)

[23:06] <jnthn> And what is between the {{ and }} is interpreted as PIR.

[23:07] <jnthn> pmichaud: If I were to do a Rakudo day on Friday, how would that be?

[23:07] <pmichaud> jnthn: that would be _excellent_

[23:07] *** adc_penner2 joined
[23:07] <jnthn> OK, good.

[23:07] <masak> +1

[23:07] <jnthn> Tomorrow would be less good for me.

[23:07] <pmichaud> same here

[23:07] <jnthn> Great. :-)

[23:07] <pmichaud> while on my break I got asked to be the "emergency presenter" at tomorrow's unix meeting.

[23:08] <pmichaud> because their other presenter cancelled out

[23:08] <pmichaud> so I should come up with a presentation, I guess.  :-)

[23:08] <jnthn> Nice!

[23:08] <pmichaud> (I'll just recycle an existing one.)

[23:08] <jnthn> I've got no more talks this year.

[23:08] <pmichaud> I thought I was done for the year.... but apparently not.  

[23:08] <jnthn> I'm now onto pondering what to talk about at next year's European Perl workshops.

[23:08] <pmichaud> it does look as though I'm headed to Frozen Perl, though.  :-)

[23:09] <jnthn> Nice.

[23:09] <jnthn> You still pondering Oslo?

[23:09] <pmichaud> yes.

[23:09] <jnthn> They're hosting a Perl 6 hackathon, dates are set.

[23:09] <jnthn> If you didn't already know that.

[23:09] <pmichaud> I didn't know that, that makes it more likely (depending on the dates)

[23:10] <jnthn> Workshop April 16th to 17th

[23:10] <jnthn> Hackathon April 18-19

[23:10] <pmichaud> I think Paula wants to make a trip to Europe sometime in 2009 -- we're just trying to figure out when.

[23:10] <jnthn> http://www.perlworkshop.no/npw2009/

[23:10] <lambdabot> Title: Nordic Perl Workshop 2009

[23:10] <jnthn> Spring is nice. ;-)

[23:12] <pmichaud> I should submit a talk or two.

[23:13] <jnthn> Aye.

[23:14] * pmichaud adds the feed to his reader.

[23:15] <jnthn> So far I'm probably going to be at the Nordic, Ukrainian, Belgian and one more as-yet unannounced-that-it's-happening workshop.

[23:16] <pmichaud> I'm thinking Oslo might be a good time for us to meet and plan next phases

[23:16] <jnthn> Yes, I agree.

[23:16] <jnthn> And the fact they're hosting a Perl 6 hackathon is a bonus.

[23:16] <pmichaud> indeed.

[23:18] <jnthn> Hey, by then we might have LTM, parametric roles and all kinds of exciting stuff. :-)

[23:18] <thei0s> jnthn: hm, I can't find how (if possible?) is it to access from PIR code a previously captured match (eg $0)... any suggestion where to look or how it should be done?

[23:18] <pmichaud> the current match object is 'match'

[23:18] <jnthn> $P0 = match[0]

[23:18] <thei0s> 10x both

[23:18] <pmichaud> token foo { (xyz) {{ $P0 = match[0]; say $P0 }} }

[23:19] <pmichaud> (I _think_ the semicolons get converted into newlines.)

[23:19] <masak> thei0s: it's possible to make Rakudo generate PIR code for you by passing the --target=PIR flag to ./perl6

[23:19] <pmichaud> no, they don't.

[23:20] <masak> it sounds like a good idea, though.

[23:20] <pmichaud> the problem is if there are any semicolons in string constants.

[23:20] <pmichaud> or things where they shouldn't be treated as newlines.

[23:20] <masak> aye.

[23:21] <masak> a problem generally known as 'parsing' :)

[23:21] <pmichaud> if only we had a tool that made it easier to do parsing...  :)

[23:21] <jnthn> Hey, we have something for that... ;-)

[23:21] <masak> quit stealing my lines! :)

[23:22] *** adc_penner left
[23:24] *** [particle]1 joined
[23:26] *** alester_ joined
[23:28] <masak> rakudo: my @a = 1,2,3; say sprintf "%d %d %d", @a

[23:28] <p6eval> rakudo 33467: OUTPUT[1 2 3␤]

[23:28] <masak> what is it that does the flattening in this case?

[23:28] <[particle]1> what's the sprintf signature?

[23:29] <moritz_> I guess it's sprintf($format, *@args)

[23:29] <masak> aye

[23:29] <masak> our Str multi method sprintf ( Str $format: *@args ) is export

[23:29] <moritz_> then the slurpy would do the flattening

[23:29] <masak> so it's that splatty star there?

[23:29] <masak> I see.

[23:29] <masak> goodie.

[23:29] <moritz_> "slurpy" now, "splatty" is the old name

[23:30] * masak feels old

[23:30] <masak> :)

[23:31] <[particle]1> i'm older than perl. you?

[23:31] <jnthn> [particle]1: Yeah, but so am I. ;-)

[23:31] <masak> yes, me too

[23:33] *** adc_penner2 left
[23:33] <[particle]1> jnthn: barely :)

[23:34] * moritz_ is roughly 4 years older than perl

[23:34] * jnthn is roughly 2 years older than Perl

[23:35] * masak 6 years

[23:35] *** zamolxes_ joined
[23:36] *** zamolxes_ left
[23:36] <[particle]1> 14

[23:36] <[particle]1> i beat you all together :)

[23:39] <pmichaud> 23.

[23:39] <pmichaud> I beat you all together, including particle.

[23:39] <pmichaud> oh, wait is it december already?  22 then.

[23:39] <masak> heh

[23:40] <[particle]1> december 18, innit?

[23:40] <pmichaud> perl becomes "legal" this month :-)

[23:40] <masak> only in the US

[23:40] <[particle]1> well, perl can drink then.

[23:40] <pmichaud> I'll drink to that!  :-)

[23:40] <[particle]1> "legal" happened almost three years ago

[23:41] <[particle]1> "perl gone wild!"

[23:41] <pmichaud> sounds like another lightning talk.  :-P

[23:41] *** vixey left
[23:42] * jnthn leaves pmichaud to submit that one

[23:43] <masak> I've written some wild Perl 6 tonight.

[23:44] <masak> indexing an array of closures, for example. poor man's switch statement :)

[23:44] <masak> (actually, come to think of it, I probably should have used a switch statement)

[23:44] * masak reviews his wild code

[23:46] <[particle]1> hee

[23:48] <masak> rakudo: my $a = given 5 {}; say $a

[23:48] <p6eval> rakudo 33468: OUTPUT[Statement not terminated properly at line 1, near "{}; say $a"␤␤current instr.: 'parrot;PGE;Util;die' pc 129 (runtime/parrot/library/PGE/Util.pir:83)␤]

[23:48] <masak> hm, 'given' cannot be used where an expression is expected? 

[23:48] <masak> rakudo: my $a = do given 5 {}; say $a

[23:48] <p6eval> rakudo 33468: OUTPUT[Null PMC access in isa()␤current instr.: 'infix:=' pc 11153 (src/gen_builtins.pir:6873)␤]

[23:48] <masak> yes! :)

[23:49] <masak> what did I just do? :)

[23:49] <thei0s> iii... my first working PIR workaround (unfortunately because of newlines not IRC-bot compatible) -- implements matching to already captured subrule $/[0]<ab>

[23:49] <thei0s> token Test1 { (<ab>'a') .*? {{

[23:49] <thei0s>  $P0 = match[0]

[23:49] <thei0s>  $P0 = $P0["ab"]

[23:49] <thei0s>  .return($P0) }} }; token ab { 'ab' }; say ( "abaaab" ~~ Test1 ) ?? "ok" !! "not ok";

[23:50] <pmichaud> .return does weird things in regex closures.

[23:50] <pmichaud> it almost certainly doesn't do what you expect.

[23:50] <masak> thei0s: when submitting longer pieces of code (and preferable also shorter), consider using nopaste.

[23:50] <pmichaud> (because it's based on an old spec)

[23:51] <[particle]1> pmichaud: thei0s pir is on topic for #parrot, not #perl6

[23:51] <[particle]1> ah, i see you're not there right now...

[23:51] <thei0s> hm, true

[23:52] <[particle]1> oh, nm

[23:52] <[particle]1> it's fine, that's actually perl 6 with inline pir

[23:52] * [particle]1 is a bit behind, sorry

[23:54] *** alester_ left
[23:54] <masak> that was today's strange bug!

[23:54] <masak> time to go to bed...

[23:54] <moritz_> bed is a good idea

[23:55] <masak> bed++

[23:55] *** masak left
[23:55] <[particle]1> pmichaud: is there a way to call 'make' from pir embedded in p6rules? would that work better than 'return'?

[23:56] <pmichaud> [particle]: match.'result_object'($P0)

[23:56] <[particle]1> ah, right! excellent.

[23:57] <thei0s> I have one more question for now: in synopsis 5 there is a test (capture.t, line ~69): ok(eval(' "bookkeeper" ~~ m/<single> ($/<single>)/ '), 'Named backref', :todo<feature>);

[23:58] <thei0s> imho matching for $/<single> is problematic, because the parser can not know if you mean $/ followed by <single> or $/<single>

[23:59] <thei0s> a rewrite of this to $<single> would solve this problem, but would not solve a situation where we have $/<single><sth>

[23:59] *** dr_df0 left
[23:59] * [particle]1 wonders how STD.pm parses that...

[23:59] <[particle]1> $/.<single> also disambiguates

