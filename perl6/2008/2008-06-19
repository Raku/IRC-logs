[00:15] *** sri_work_ left
[00:18] *** felipe joined
[00:19] *** Chillance left
[00:22] *** nipotan is now known as nipotaway

[00:29] *** cookys left
[00:31] *** elmex left
[00:31] <Auzon> perl6: my $foo = 'a'; my $bar = 'b'; say <<$foo $bar>>

[00:31] <p6eval> kp6 r20874: OUTPUT[syntax error at position 46, line 1 column 46:␤my $foo = 'a'; my $bar = 'b'; say <<$foo $bar>␤                                              ^ HERE␤]

[00:31] <p6eval> ..pugs: OUTPUT[ab␤]

[00:31] <p6eval> ..rakudo r28528: OUTPUT[Statement not terminated properly at line 1, near ">"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[00:31] <p6eval> ..elf r20874: OUTPUT[$␤]

[00:32] <Auzon> elf gets points for creativity.

[00:32] *** mncharity joined
[00:50] *** jan_____ left
[00:54] *** jan__ joined
[00:54] *** ruoso joined
[00:58] <meppl> good night

[00:59] *** meppl left
[01:12] *** pbuetow left
[01:13] <pugs_svnbot> r20875 | putter++ | [STD_red] Improve operator name handling.  Unbreaks elf.

[01:16] <pugs_svnbot> r20876 | putter++ | [elf] Cleaning up elf_f_src/ .  Moved run-tests to elfish/run-tests/ .  Pugs t/ svn revision added to output.

[01:24] *** lichtkind joined
[01:24] <lichtkind> perl6: $a = do { 3; leave; 5; }

[01:24] <p6eval> kp6 r20876: OUTPUT[Can't locate object method "new" via package "Leave" (perhaps you forgot to load "Leave"?) at compiled/perl5-kp6-mp6/lib/KindaPerl6/Grammar/Control.pm line 843, <> line 1.␤]

[01:24] <p6eval> ..pugs: OUTPUT[*** ␤    Unexpected " ="␤    expecting "::"␤    Variable "$a" requires predeclaration or explicit package name␤    at /tmp/tbe8P2Mzgb line 1, column 3␤]

[01:24] <p6eval> ..rakudo r28528: OUTPUT[Scope  not found for PAST::Var '$a'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[01:24] <p6eval> ..elf r20876: OUTPUT[Useless use of a constant in void context at (eval 113) line 3.␤Undefined subroutine &GLOBAL::leave called at (eval 113) line 4.␤ at ./elf_f_faster line 4656␤]

[01:31] <pugs_svnbot> r20877 | putter++ | [elf] Cleaning up elf_f_src/ .  Moved some experimental files to a new elfish/elf_f_work/, and added README guidance on using them from there.

[01:52] *** DietCoke left
[01:54] *** SamB left
[01:55] *** SamB joined
[02:04] <lichtkind> i thought bare blocks dont execute in perl 6?

[02:13] *** saladsn left
[02:17] <Coleoid> .

[02:23] <Coleoid> rakudo: my $simple = 'begin'; say;

[02:23] <p6eval> rakudo r28528 OUTPUT[␤]

[02:23] <Coleoid> rakudo: .= 'begin'; say;

[02:23] <p6eval> rakudo r28528 OUTPUT[Syntax error at line 1, near ".= 'begin'"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[02:23] <Coleoid> rakudo: $_ = 'begin'; say;

[02:23] <p6eval> rakudo r28528 OUTPUT[too few arguments passed (0) - 1 params expected␤current instr.: '_block11' pc 0 (EVAL_10:3)␤

[02:23] <Coleoid> Er,

[02:25] <Coleoid> rakudo: say 'begin'

[02:25] <p6eval> rakudo r28528 OUTPUT[begin␤]

[02:25] <Coleoid> rakudo: $_ = 'begin'; say $_

[02:25] <p6eval> rakudo r28528 OUTPUT[too few arguments passed (0) - 1 params expected␤current instr.: '_block11' pc 0 (EVAL_12:3)␤

[02:25] <Coleoid> rakudo: $_ = 'begin'; say $_;  #perhaps a missing semicolon?

[02:25] <p6eval> rakudo r28528 OUTPUT[too few arguments passed (0) - 1 params expected␤current instr.: '_block11' pc 0 (EVAL_10:3)␤

[02:26] <Coleoid> ...

[02:32] <Coleoid> Okay, I'm getting interested in Rakudo given current news, yet this failure is pretty rudimentary.

[02:33] <Coleoid> And I don't know how to get from here, to seeing if there's a test for something like this already in the spectests...

[02:34] <Coleoid> ...or something like this already in the bug tracking for Rakudo, which is RT?  At some URL?

[02:35] <Coleoid> So I'm glad for any pointers I can get from the folks here.

[02:38] <Coleoid> Meantime, I'm searching for the pointers.  Perhaps my difficulties are characteristic of multiple folks, and somehow this gap I'm yurking around in can be narrowed?

[02:39] <Coleoid> rakudo: say "Until later, thanks for the improvements!";

[02:39] <p6eval> rakudo r28528 OUTPUT[Until later, thanks for the improvements!␤]

[02:42] <bacek> rakudo: my $a = 'hello'; say $a;

[02:42] <p6eval> rakudo r28528 OUTPUT[hello␤]

[02:43] <bacek> rakud: sub hello { say 'hello, ' ~ $_ }; hello('world')

[02:43] <bacek> rakudo: sub hello { say 'hello, ' ~ $_ }; hello('world')

[02:43] <p6eval> rakudo r28528 OUTPUT[hello, world␤]

[02:44] <bacek> Coleoid: there is no $_ at top-level module (yet)

[02:44] <Coleoid> bacek:  Thanks!  Top-level module of Rakudo as a whole?

[02:45] <bacek> Coleoid: hmm... I didn't quite understand your question...

[02:46] <Coleoid> rakudo:  sub inner { $_ = 'inner'; say }; inner();

[02:46] <p6eval> rakudo r28528 OUTPUT[too few arguments passed (0) - 1 params expected␤current instr.: 'inner' pc 33 (EVAL_11:21)␤

[02:46] <Coleoid> I'm not sure what you mean by 'top-level'.

[02:46] <bacek> rakudo:  sub inner { $_ = 'inner'; say $_; }; inner();

[02:46] <p6eval> rakudo r28528 OUTPUT[too few arguments passed (0) - 1 params expected␤current instr.: 'inner' pc 33 (EVAL_10:21)␤

[02:47] <Coleoid> rakudo:  sub inner { $a = 'inner'; say $a }; inner();

[02:47] <p6eval> rakudo r28529 OUTPUT[Scope  not found for PAST::Var '$a'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[02:47] <Coleoid> rakudo:  sub inner { my $a = 'inner'; say $a }; inner();

[02:47] <p6eval> rakudo r28529 OUTPUT[inner␤]

[02:48] <Coleoid> rakudo:  sub inner { my $_ = 'inner'; say }; inner();

[02:48] <p6eval> rakudo r28529 OUTPUT[too few arguments passed (0) - 1 params expected␤current instr.: 'inner' pc 33 (EVAL_11:21)␤

[02:49] <bacek> Coleoid: support for $_ is still rudimentary in rakudo.

[02:49] <Coleoid> Well.

[02:52] <bacek> rakudo: say <1..10>:sort { $^b <=> $a }

[02:52] <p6eval> rakudo r28529 OUTPUT[Statement not terminated properly at line 1, near ":sort { $^"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[02:53] <bacek> rakudo: say <1..10>.sort { $^b <=> $a }

[02:53] <p6eval> rakudo r28529 OUTPUT[Statement not terminated properly at line 1, near "{ $^b <=> "␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[02:53] <Coleoid> rakudo: say <1..10>.sort { $b <=> $a }

[02:53] <p6eval> rakudo r28529 OUTPUT[Statement not terminated properly at line 1, near "{ $b <=> $"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[02:53] <bacek> rakudo: say <1..10>.sort({ $^b <=> $a })

[02:53] <p6eval> rakudo r28529 OUTPUT[Scope  not found for PAST::Var '$a'␤current instr.: 'parrot;PCT::HLLCompiler;panic' pc 156 (src/PCT/HLLCompiler.pir:103)␤

[02:54] <bacek> rakudo: say <1..10>.sort({ $^b <=> $^a })

[02:54] <p6eval> rakudo r28529 OUTPUT[Method 'sort' not found for invocant of class 'Perl6Str'␤current instr.: '_block11' pc 45 (EVAL_12:22)␤

[02:54] <bacek> what???

[02:54] <bacek> rakudo: say (1..10).sort({ $^b <=> $^a })

[02:54] <p6eval> rakudo r28529 OUTPUT[Method 'sort' not found for invocant of class 'Range'␤current instr.: '_block11' pc 63 (EVAL_14:25)␤

[02:54] <Coleoid> Saner!

[02:54] <bacek> someone broke it...

[02:55] <bacek> rakudo sya sort { $^b <=> $^a }, 1..10;

[02:55] <bacek> rakudo: say sort { $^b <=> $^a }, 1..10;

[02:55] <p6eval> rakudo r28529 OUTPUT[10987654321␤]

[02:55] <bacek> rakudo: say ~sort { $^b <=> $^a }, 1..10;

[02:55] <p6eval> rakudo r28529 OUTPUT[10 9 8 7 6 5 4 3 2 1␤]

[02:56] <bacek> rakudo: say  ~grep { $_ %2 }, sort { $^b <=> $^a }, 1..10;

[02:56] <p6eval> rakudo r28529 OUTPUT[9 7 5 3 1␤]

[02:56] <Coleoid> Here's a working '$_'...

[02:57] *** Limbic_Region joined
[02:57] <bacek> rakudo: say  ~grep { $^yak % 2 }, sort { $^b <=> $^a }, 1..10;

[02:57] <p6eval> rakudo r28529 OUTPUT[9 7 5 3 1␤]

[02:58] <Coleoid> ...which works the same auto-named as a parameter.

[02:58] <bacek> rakudo: say  (grep { $^yak % 2 }, sort { $^b <=> $^a }, 1..10).reduce { $^a+$^b }

[02:58] <p6eval> rakudo r28529 OUTPUT[Statement not terminated properly at line 1, near "{ $^a+$^b "␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[02:58] <bacek> pugs: say  (grep { $^yak % 2 }, sort { $^b <=> $^a }, 1..10).reduce { $^a+$^b }

[02:59] <p6eval> OUTPUT[*** ␤    Unexpected "{"␤    expecting operator, ":" or ","␤    at /tmp/H608OSTsWT line 1, column 63␤]

[02:59] <bacek> rakudo: say  (grep { $^yak % 2 }, sort { $^b <=> $^a }, 1..10).reduce{ $^a+$^b }

[02:59] <p6eval> rakudo r28529 OUTPUT[too few arguments passed (0) - 2 params expected␤current instr.: '_block11' pc 0 (EVAL_14:3)␤

[02:59] <bacek> rakudo: say  reduce {$^a+$^b }, grep { $^yak % 2 }, sort { $^b <=> $^a }, 1..10

[02:59] <p6eval> rakudo r28529 OUTPUT[25␤]

[03:00] <bacek> pugs: say  (grep { $^yak % 2 }, sort { $^b <=> $^a }, 1..10).reduce{ $^a+$^b }

[03:00] <p6eval> OUTPUT[*** Cannot cast from VList [] to Pugs.AST.Internals.VCode (VCode)␤    at /tmp/XFMRn0YyIp line 1, column 6 - line 2, column 1␤]

[03:19] <diakopter> woo hoo! I got the recursive-descent parser (* that can handle left recursive non-terminals, both direct and indirect) working!  :D :D

[03:19] *** meteorjay left
[03:20] <diakopter> so now grammars can have left associate operators specified in the exact same syntax as right-associative ones.

[03:20] <diakopter> without transforming

[03:20] <diakopter> oh, and the packrat/memoization comes with that.

[03:25] <mncharity> Auzon, et al: Is there an up-to-date set of regex tests?

[03:25] <pugs_svnbot> r20878 | putter++ | [elf] Elf has had two variants, only very slightly different.  The default one used Moose, the faster one not.  The two have been merged, with the default one now not.  elf_f_faster no longer exists - use the similar elf_f.

[03:25] <pugs_svnbot> r20878 | putter++ | Motivation - the low startup latency is nice, and with a dearth of development resources, the time when Moose would most help is now distant, so supporting both doesn't currently seem worth the complexity cost.

[03:27] <mncharity> ﻿diakopter: could you remind me... are you working on something which is strictly a p6 parser, or a general regex engine?

[03:29] <diakopter> mncharity: well, it's turned into a general regex engine

[03:29] <mncharity> have a test suite?

[03:29] <diakopter> since that's what's needed to translate STD.pm into a readable Perl6in5::Grammar

[03:29] <diakopter> mncharity: ha

[03:30] <diakopter> I only *just* got the memoizing working

[03:30] <diakopter> and the output format (ast and actions and such) has yet to be formulated fully

[03:30] <diakopter> so in other words, there still would be nothing to test against, so no. :)

[03:30] <diakopter> it's still untestable.

[03:31] <mncharity> I find it very hard to tell how real, and the related - how usable(ie, fast), regex engine implementations are, without seeing some kind of test suite results.

[03:31] <mncharity> re ﻿still untestable, ah, ok.

[03:31] <diakopter> yeah...

[03:32] <mncharity> packrat++

[03:32] <diakopter> well, my first guess about its speed is that it will be slower than most for most things, but faster than most on a few things... namely situations where naturally left recursive constructs are usually translated into a bottom-up parser system, or right-recursive equivalents

[03:32] <mncharity> have you considered targeting p6 rather than p5?  :)

[03:33] <diakopter> mncharity: no, but I don't see where you're going with that :) 

[03:34] <mncharity> long term, it would be nice to have a grammar compiler which analyzed the grammar, and perhaps even path stats, and assembled an optimized implementation tuned for that specific grammar.

[03:34] <diakopter> but that's only a slightly special case of standard compiler optimization steps....

[03:35] * diakopter thinks a bit on "path stats"

[03:35] <diakopter> oh

[03:37] <diakopter> I think what you mean by that is a profile of how interdependent various rules are... and which ones are used all the time.

[03:37] <mncharity> re only slightly special, I suspect not.  It's a rather specialized domain, and thus likely to have domain-specific optimizations possible.

[03:37] <diakopter> for instance, the unspace rule has to run at nearly every character position :)

[03:37] <mncharity> yes

[03:38] <diakopter> mncharity: ok, I haven't read about those... urls?

[03:38] <diakopter> or keyphrases?

[03:39] <mncharity> for some grammars, just compiling to C, or Inline::C, could be a dramatic win.  who needs yacc...

[03:42] <mncharity> re urls, hmm, there's a very good question I don't have an answer for.  Are there any wizzy survey papers on the current state of parsing??  Dunno.   My fuzzy impression is aside from localized activity, eg, around packrat, or "attribute grammars" (some meanings), and functional programming folks, the field as a whole is off in book land.

[03:42] <mncharity> ie, dead

[03:42] <diakopter> heh

[03:43] <diakopter> my next task is to figure out how to make operator precedence easier to declare in this grammar system

[03:44] <diakopter> I think that should come before the tree generation/manipulation

[03:44] <mncharity> on my not-short list of "things I hope p6 will accomplish" is shake up parsing land.  there's really no excuse for not having good General Parsers readily available.  but the pragmatics of getting adoption and support community has killed the attempts I've seen over the years.

[03:44] <diakopter> mostly b/c TimToady kept challenging me on that

[03:45] <diakopter> TimToady: thanks for challenging me so much

[03:45] <mncharity> with concequences like ruby making language design decisions based on what bison can deal with.  which pragmatically makes sense... but is an unfortunate place for us as a field to be.

[03:46] <mncharity> re challenge, :)

[03:46] <diakopter> also, he challenged me to table tennis

[03:46] <mncharity> just to see "yet another way to do it", you might look at the redsix opp if you haven't already.

[03:47] <mncharity> My fuzzy recollection is it could backtrack through the opp, and have n-part tokens (ala smalltalk), which might contribute interesting ideas.

[03:48] <mncharity> re n-part, ie, rather than just  x ?? x !! x , you could have arbitrary   x A x B x C x D x ...  with assorted precedences.

[03:49] *** Limbic_Region left
[03:49] <diakopter> mncharity: ah

[03:49] <Auzon> mncharity: I'm not certain about the status of the regex tests

[03:49] * mncharity tries to remember how to restart the evalbot...

[03:49] <Auzon> Most tests so far have been up to date

[03:49] <mncharity> elf: say 3

[03:49] <p6eval> OUTPUT[sh: ./elf_f_faster: No such file or directory␤]

[03:49] <Auzon> evalbot control restart

[03:49] *** p6eval left
[03:49] <mncharity> ﻿evalbot control restart

[03:49] *** p6eval joined
[03:50] <mncharity> ﻿elf: say 3

[03:50] <diakopter> patrick explained to yapc how he implemented ??!! in pge

[03:50] <mncharity> elf: say 3

[03:50] <p6eval> OUTPUT[3␤]

[03:50] <mncharity> *nod*

[03:50] <mncharity> ﻿Auzon: tnx :)

[03:51] <diakopter> combination of unless and if)

[03:51] <diakopter> but for detection, yeah, that's interesting.

[03:51] <mncharity> ﻿Auzon: re tests, hmm, ok.  so old  |  have been changed to || and | tests added?

[03:52] * Auzon looks

[03:52] <diakopter> mncharity: ha, so you're saying A,B,C,D... could each have its own precedence.. :P  or individually be optional... or be optional in weird groupings...

[03:53] *** DietCoke joined
[03:53] * diakopter looks at DietCoke

[03:54] <mncharity> :)  at least for redsix, no optionality or weirdness.  just n sub-tokens, each with their own left and right precedences, and some other tweakable constraints which seemed needed given the fuzzy understanding of how to parse p6 which existed at the time.

[03:54] <mncharity> ie, whitespace sensitivity.

[03:54] <diakopter> ah ok

[03:55] <diakopter> so basically, all issues that a recursive descent parser (with whitespace sensitivity) understands

[03:56] <lichtkind> perl6: my @a = gather { take 5; leave 5; take 3  }

[03:56] <mncharity> err... only if you encode precedences in the tree.  rd can't do opp otherwise, no?

[03:56] <p6eval> kp6 r20878: OUTPUT[Can't locate object method "new" via package "Leave" (perhaps you forgot to load "Leave"?) at compiled/perl5-kp6-mp6/lib/KindaPerl6/Grammar/Control.pm line 843, <> line 1.␤]

[03:56] <p6eval> ..pugs: RESULT[[5, 3]]

[03:56] <p6eval> ..rakudo r28535: OUTPUT[Null PMC access in type()␤current instr.: 'parrot;Perl6;Grammar;Actions;statement_prefix' pc 115190 (src/gen_actions.pir:10907)␤

[03:56] <p6eval> ..elf r20878: OUTPUT[Type of arg 1 to Private::gather must be block or sub {} (not null operation) at (eval 117) line 5, near "})"␤ at ./elf_f line 3826␤]

[03:56] <diakopter> mncharity: btw, I guess I didn't tell you, the grammar syntax for Perl6in5 (yap6) has whitespace-ness built into the pattern definitions... so you don't need a distinction betweeen rule/token

[03:56] <lichtkind> seemes very wrong to me

[03:56] <lichtkind> i mean  the result of pugs

[03:57] <diakopter> lichtkind: 'leave' is known to be pugsbug

[03:57] <diakopter> Auzon: are there many tests on 'leave'?

[03:57] <Auzon> Yes.

[03:57] <lichtkind> so result should be [5] oder [5,5] ?

[03:58] <Auzon> see t/builtins/control_flow/leave.t

[03:58] <diakopter> mncharity: yes, I meant handled by explicit encoding like that, yeah

[03:59] <diakopter> I think it should still be handled that way, except without having to specify the extra "fall-through" rule at each layer.

[03:59] <diakopter> in other words, nest the rules in an "opp()" parser generator, which does all the fall-throughs automatically.

[04:00] <mncharity> with packrat to pick up the pieces... hmm...

[04:00] <diakopter> that way, opp() can also generate the flexibility needed to support interlayer insertion

[04:00] <Auzon> What's packrat?

[04:01] <diakopter> packrat refers to a memoization technique of recursive descent parsers, by which they can achieve linear parse times on general input.   except left-recursive stuff.  except now it can.

[04:01] <diakopter> thanks to those researchers who wrote the paper from which I implemented that algorithm

[04:02] <Auzon> Oh, I thought it was some regex library or something.

[04:02] <mncharity> a "packrat parser" basically remembers what happened when rule x was applied at position p... so when some other part of the grammar asks about it for the nth time, you don't have to recompute it for the nth time.

[04:02] <Auzon> I remember you talking about such reductions in the past, but I'm not far enough in my CS studies to have seen it

[04:03] <mncharity> figuring out how that interacts with a p6 grammar, where rules may be passing dynamically scoped information between themselves... may require a large set of grammars to yield a "I

[04:03] <mncharity> 'm sorry, don't know how to compile that for my rat"./

[04:04] <diakopter> I did some informal tests.... for chains of nested left-associate rules (things handled by left-recusive rules), parse times still increase more quickly than linear... but rarely will you have 90 nested left associative things (where I started noticing the time increase)

[04:04] *** lichtkind left
[04:05] <mncharity> hmm... could still memoize everything which didn't play games, inside the framework of a parser which didn't depend on being able to memoize everywhere.

[04:05] <diakopter> mncharity: but a grammar's generation can't be dependent on input

[04:05] <diakopter> a modification to an existing grammar could...

[04:05] <diakopter> but not the initial one

[04:06] <diakopter> otherwise, please explain...

[04:07] <diakopter> mncharity: there is a don't-memoize-me version of parser() called parser2()

[04:07] <mncharity> if  rule foo { <{let($x)=$global_mumble++;}> }  then foo isn't idempotent, and can't be memoized.

[04:08] <mncharity> or whatever the syntax for embedded code is.  i'm fuzzy.

[04:08] <diakopter> but that introduces what TimToady calls an immediate stopper

[04:08] <diakopter> essentially ends the compilation unit

[04:08] <mncharity> you mean for '|' "longest token match"?

[04:09] <diakopter> <{}>

[04:09] *** zhangsoft joined
[04:09] <mncharity> ah, I didn't realize you were only going for linear on |, but not || (backtracking).

[04:09] <diakopter> I'm still not clear on ||

[04:10] <mncharity> p6 || is the p5 |

[04:10] *** zhangsoft left
[04:10] <diakopter> right, so, standard recursive descent, right?

[04:10] <mncharity> it got renamed :/

[04:10] <diakopter> standard alternation, I mean

[04:10] <diakopter> ?

[04:11] <mncharity> re standard rd, modulo that it's past midnight and I'm increasingly fuzzy, I believe so.

[04:11] <mncharity> yes

[04:11] <diakopter> but | is now what?

[04:11] <mncharity> re ﻿standard alternation.

[04:12] <mncharity> re ﻿| ...  I'm less than entirely clear.

[04:12] <diakopter> I mean... standard alternate chooses "first match"

[04:12] <mncharity> yes

[04:12] <diakopter> || chooses "hungriest match"

[04:13] <mncharity> err, no.

[04:13] <diakopter> I mean

[04:13] <mncharity> s/yes//

[04:13] <diakopter> least hungry match

[04:13] * diakopter backtracks

[04:13] <diakopter> er, backpedals

[04:13] <mncharity> err, yes.  saw your "I"(eye) as an '|' vertical bar.  very end-of-dayish just now.

[04:14] <diakopter> ok :D

[04:14] <diakopter> ok... currently | in Perl6in5 does longest-match

[04:14] <mncharity> "I mean" !=  "| ... <rest is definition of |>"    sigh

[04:15] <diakopter> in fact, so do '.' and '-'

[04:15] <diakopter> there's also "first-match"

[04:16] <diakopter> I guess there needs to be a symbol for that (since I obviously can't overload ||)

[04:16] <Auzon> mncharity: I won't be handling regexes until the end of July. I can move it up on my schedule if you question the regex tests.

[04:16] <mncharity> so to handwave fuzzily, yes, rx || is standard regular expression | alternation.  and rx | is longest match... for some fuction "longest match" defined on rx primitives, which I'm quite fuzzy on.

[04:16] <mncharity> *function

[04:17] <diakopter> actually I just realized, without the left-recursive ability, the LTM function wasn't yet complete

[04:17] <diakopter> but now it is

[04:18] <mncharity> ﻿Auzon: re move it up, no need for me.  optimize your own productivity.  TimToady may need a test suite at some point, but I'm fuzzy on how general/complete his engine is supposed to be, or what the timeframe is.

[04:18] <mncharity> Might be "would help now", or might be "unneeded".  dunno.

[04:19] <diakopter> but I can overload '|='  :P

[04:20] <mncharity> ﻿Auzon: re move up, might check with TimToady and pm if that didn't already happen.

[04:20] *** zhangsoft joined
[04:20] <diakopter> oh! there is a postfix + that's overloadable... I wonder how overload returns its arguments to distinguish it from unary prefix...

[04:20] <mncharity> s/pm/pmichaud/

[04:20] *** nekobaka left
[04:20] <Auzon> mncharity: I can easily swap S03 and S05 (so S05 would be in 1 week and S03 would be towards the end). I gave S0[2345] 1.5 weeks each because they're more detailed.

[04:22] <diakopter> heh

[04:22] <diakopter> I'd give S05 around 20 weeks

[04:22] <mncharity> beware that rx's are their own language, of daunting complexity.  I always underestimate it, even after applying several levels of "correct for always underestimating it" corrections.

[04:22] <Auzon> diakopter: I guess, but I only have 12 weeks total.

[04:23] <diakopter> Auzon: :P surely you won't leave us to go back to *school* :P

[04:23] <mncharity> the pugs regex tests are by far the largest group of tests in the suite... and they are woefully incomplete.

[04:24] <Auzon> diakopter: It seems that I will ;) but I'll still be around and helping. Just not for 20+ hours a week

[04:24] <mncharity> end of day for me.

[04:24] <mncharity> good night and have fun :)

[04:24] <Auzon> good night, mncharity.

[04:25] *** mncharity left
[04:25] *** meteorjay joined
[04:25] <diakopter> mncharity: oh, I thought longest match would just be longest number of characters....

[04:25] <diakopter> heh

[04:26] <diakopter> I guess it could be "# of terminals"

[04:26] <diakopter> actually

[04:27] <diakopter> it has to be, highest number of characters eaten, with *fewest* number of terminals breaking ties.

[04:28] *** lichtkind joined
[04:28] <diakopter> TimToady: correct me where wrong, plz

[04:28] <lichtkind> pugs: print if $_ % 2 for 1..10;

[04:28] <p6eval> OUTPUT[*** ␤    Unexpected "for"␤    expecting operator␤    at /tmp/Te0HBAwUAv line 1, column 17␤]

[04:31] <diakopter> audreyt: are you around to clarify LTM

[04:36] * diakopter ->(bed=>1)

[04:38] *** lichtkind left
[04:39] *** alester joined
[05:04] *** Eevee left
[05:04] *** Eevee joined
[05:13] *** stevan_ joined
[05:15] *** iblechbot joined
[05:31] *** alester left
[05:51] *** barney joined
[05:52] *** barney left
[06:07] *** DietCoke left
[06:25] *** iblechbot left
[06:29] *** wknight8111 left
[06:50] *** Psyche^ joined
[06:58] *** mncharity joined
[06:59] *** _Maghnus joined
[07:00] <mncharity> a very quick note.  I was way too negative about the | to || rename.  p5 re was a vast improvement over the diverse crud which went before, setting a new and better standard, and no doubt p6 rx will do it again.  I look forward to working with them.

[07:00] <mncharity> &

[07:00] *** mncharity left
[07:05] *** Patterner left
[07:05] *** Psyche^ is now known as Patterner

[07:10] *** stevan_ left
[07:10] *** Maghnus left
[07:10] *** _Maghnus is now known as Maghnus

[07:17] *** snail joined
[07:19] *** snail left
[07:41] *** alanhaggai left
[07:52] *** penk joined
[07:56] *** luqui joined
[08:01] *** elmex joined
[08:06] *** alc joined
[08:33] *** sri_work joined
[08:34] *** sri_work left
[08:34] *** sri_work joined
[08:37] <moritz_> perl6: say 'x' x 5

[08:37] <p6eval> kp6 r20878: OUTPUT[xxxxx␤]

[08:37] <p6eval> ..pugs: OUTPUT[xxxxx␤]

[08:37] <p6eval> ..rakudo r28536: OUTPUT[xxxxx␤]

[08:37] <p6eval> ..elf r20878: OUTPUT[Undefined subroutine &GLOBAL::infix_x called at (eval 115) line 3.␤ at ./elf_f line 3826␤]

[08:40] <moritz_> elf: say 'x' x 5

[08:40] <p6eval> OUTPUT[Undefined subroutine &GLOBAL::infix_x called at (eval 115) line 3.␤ at ./elf_f line 3826␤]

[08:40] <pugs_svnbot> r20879 | moritz++ | [elf] added infix:<x>

[08:41] <moritz_> elf: say 'x' x 5

[08:41] <p6eval> OUTPUT[Undefined subroutine &GLOBAL::infix_x called at (eval 115) line 3.␤ at ./elf_f line 3826␤]

[08:41] <moritz_> do I have to recompile elf_f?

[08:42] * moritz_ tries 'make bootstrap'

[08:42] *** pmurias joined
[08:43] *** pmurias left
[08:46] <moritz_> elf: say 'x' x 5

[08:46] <p6eval> OUTPUT[xxxxx␤]

[08:46] <pugs_svnbot> r20880 | moritz++ | [elf] recompiled after implementing infix:<x>

[08:46] <moritz_> YaY, first successful elf contribution

[08:50] *** luqui left
[08:50] *** meppl joined
[08:52] <pugs_svnbot> r20881 | moritz++ | [spec] start adding a few regex tests. This first one tests that longest

[08:52] <pugs_svnbot> r20881 | moritz++ | alternatives wins

[09:01] <pugs_svnbot> r20882 | moritz++ | [spec] more tests for longest alternatives in regexes

[09:06] *** Auzon left
[09:13] *** bacek left
[09:26] <rakudo_svn> r28537 | jonathan++ | [rakudo] Start refactoring 'does' to be more in line with STD.pm. This gets rid of trait_or_does, making does just be a trait_auxiliary.

[09:40] <pugs_svnbot> r20883 | moritz++ | [spec] tests for single quotes (from from_perl6_rules)

[09:43] *** Lorn left
[09:47] *** pmurias joined
[09:48] <pmurias> moritz_: re contribiution, where there any previous unsuccesfull ones? ;)

[09:49] <moritz_> pmurias: no, just unsucessful tries to build/run it (but mncharity++ was very helpful)

[09:49] <moritz_> perl6: say [('a') xx 2].perl

[09:49] <p6eval> kp6 r20883: OUTPUT[no method 'APPLY' in Class 'Undef'␤ at compiled/perl5-kp6-mp6/lib/KindaPerl6/Runtime/Perl5/MOP.pm line 345␤    

[09:49] <p6eval> ..pugs: OUTPUT[["a", "a"]␤]

[09:49] <p6eval> ..rakudo r28537: OUTPUT[["a", "a"]␤]

[09:49] <p6eval> ..elf r20883: OUTPUT[Undefined subroutine &GLOBAL::infix_xx called at (eval 117) line 3.␤ at ./elf_f line 3828␤]

[09:50] <pmurias> found your text task? ;)

[09:52] <moritz_> pmurias: perhaps ;) but I don't know if I can add multi infix:<xx> (@a, $b) is p5, because you can't pass an array as first arg in p5

[09:54] <pmurias> moritz_: shouldn't xx be written in p6?

[09:55] <moritz_> multi sub infix:<xx>(@a, Int $b) { return gather { take @a for ^$b }}

[09:56] <moritz_> that would even be lazy as soon as gather...take is implemented correctly

[09:58] <pmurias> yes

[09:58] <pmurias> you wrote a perl5 gather,take module if i recall correctly ;)

[09:59] <moritz_> pmurias: yes. Perl6::GatherTake

[10:00] <moritz_> the only lazy one on CPAN - the others are all just syntactic sugar

[10:12] <pmurias> infix:<x> couldn't have been implemented in perl6 too

[10:13] <pmurias> it would be less efficient likely

[10:13] <moritz_> ENOSENSE

[10:14] <moritz_> I think you have a superfluous negation in that sentence ;)

[10:14] <pmurias> moritz_: yes

[10:14] <moritz_> ok, then I know what you mean ;)

[10:16] <moritz_> pmurias: should stuff like that go into Prelude.pm?

[10:17] <pmurias> yes

[10:17] * moritz_ tries that

[10:20] <moritz_> elf: say 2, 3

[10:20] <p6eval> OUTPUT[2␤3␤]

[10:20] *** rindolf joined
[10:21] <moritz_> that's wrong, actually ;)

[10:21] <moritz_> perl6: say 2, 3

[10:21] <p6eval> kp6 r20883: OUTPUT[23␤]

[10:21] <p6eval> ..pugs: OUTPUT[23␤]

[10:21] <p6eval> ..rakudo r28537: OUTPUT[23␤]

[10:21] <p6eval> ..elf r20883: OUTPUT[2␤3␤]

[10:23] <moritz_> bootstrapping...

[10:25] <pmurias> moritz_: do you set STD_RED_CACHEDIR?

[10:26] *** ruoso left
[10:26] <pugs_svnbot> r20884 | moritz++ | [elf]

[10:26] <pugs_svnbot> r20884 | moritz++ |  * implemented infix:<xx> in Perl 6

[10:26] <pugs_svnbot> r20884 | moritz++ |  * fixed say. It should print just one newline, not one after each arg.

[10:26] <pugs_svnbot> r20884 | moritz++ |    Could probably be simplified even more

[10:29] <moritz_> elf: say (1, 2) xx 2

[10:30] <p6eval> OUTPUT[Undefined subroutine &GLOBAL::push called at ./elf_f line 638.␤ at ./elf_f line 3835␤]

[10:30] <moritz_> ouch

[10:30] <moritz_> maybe I should use the method form instead

[10:30] *** wknight8111 joined
[10:31] <pmurias> yes

[10:34] *** Jedai joined
[10:38] <pugs_svnbot> r20885 | moritz++ | [elf] use method form for push() in the Prelude

[10:40] <moritz_> elf: say (1, 2) xx 2

[10:40] <p6eval> OUTPUT[Undefined subroutine &GLOBAL::push called at ./elf_f line 638.␤ at ./elf_f line 3835␤]

[10:40] *** Ara4n joined
[10:40] *** Ara5n left
[10:41] <moritz_> perl6: say 1, 2;

[10:41] <p6eval> kp6 r20885: OUTPUT[12␤]

[10:41] <p6eval> ..pugs: OUTPUT[12␤]

[10:41] <p6eval> ..rakudo r28537: OUTPUT[12␤]

[10:41] <p6eval> ..elf r20885: OUTPUT[12␤]

[10:41] <moritz_> at least that's fixed

[10:41] <moritz_> don't know why it doesn't like my push method, though

[10:41] <moritz_> elf: say (1, 2) xx 2

[10:41] <p6eval> OUTPUT[Undefined subroutine &GLOBAL::push called at ./elf_f line 638.␤ at ./elf_f line 3835␤]

[10:42] <moritz_> pmurias: any idea?

[10:46] *** zhangsoft left
[10:52] *** Auzon joined
[10:57] <pmurias> moritz_: was afk

[10:58] *** LCamel left
[10:58] *** LCamel joined
[10:59] <pmurias> moritz_: looks like elf_f was missing from commit

[11:00] <moritz_> pmurias: thanks, I forgot to make if_bootstrap_scceeded

[11:00] <pugs_svnbot> r20886 | moritz++ | [elf] update elf_f

[11:00] <moritz_> elf: say (1, 2) xx 2

[11:00] <p6eval> OUTPUT[1␤]

[11:01] <moritz_> elf: ((1, 2) xx 2).perl.say

[11:01] <p6eval> OUTPUT[1␤]

[11:01] * moritz_ is stupid

[11:02] <moritz_> still, even with my stupidity the result should bei 1,2 not 1

[11:03] <pmurias> elf: ([1,2] xx 2).perl.say

[11:03] <p6eval> OUTPUT[[1,2]␤]

[11:03] <pmurias> elf: say ([1,2] xx 3)

[11:03] <p6eval> OUTPUT[12␤]

[11:03] <moritz_> Maghnus: I'm about to fix that

[11:03] <moritz_> sorry, pmurias 

[11:03] <moritz_> where did my tab-key go?

[11:04] *** wknight8111 left
[11:04] <pmurias> np

[11:04] <pmurias> elmex: say 1 xx 6

[11:05] <pmurias> sorry

[11:05] <elmex> pmurias: 1

[11:05] <pmurias> elf: say 1 xx 6

[11:05] <p6eval> OUTPUT[1␤]

[11:05] <elmex> elf: say sex

[11:05] <pmurias> pugs: say 1 xx 6

[11:05] <p6eval> OUTPUT[Undefined subroutine &GLOBAL::sex called at (eval 117) line 3.␤ at ./elf_f line 3835␤]

[11:05] <p6eval> OUTPUT[111111␤]

[11:06] <moritz_> elf: [1,2] xx 2

[11:06] <pugs_svnbot> r20887 | moritz++ | [elf] infix:<xx>: return multiplied list, not the original one ;)

[11:06] <p6eval> RESULT[[[1,2],[1,2]]␤]

[11:06] <moritz_> elf: (1,2( xx 2

[11:06] <p6eval> OUTPUT[Parse error in: /tmp/Po58p0JI2y␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: (1,2( xx 2␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤  STD_red/std.rb:210:in `_U...

[11:06] <moritz_> elf: (1,2 xx 2

[11:06] <p6eval> OUTPUT[Parse error in: /tmp/emnPBexGX2␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: (1,2 xx 2␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:98:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤  STD_red/std.rb:210:in `_UN...

[11:06] <moritz_> d'oh

[11:06] <moritz_> elf: (1,2) xx 2

[11:06] <p6eval> RESULT[[1,1]␤]

[11:06] <pmurias> elmex: elmex [1,2] xx 3

[11:07] <pmurias> ef: [1,2] xx 3

[11:07] <pmurias> elf: [1,2] xx 3

[11:07] <p6eval> RESULT[[[1,2],[1,2],[1,2]]␤]

[11:07] <moritz_> I'm not the only one with either broken self or keyword ;)

[11:07] <pmurias> keyword?

[11:08] <moritz_> s/word/board/ ;-)

[11:08] <moritz_> omg

[11:08] <moritz_> I should really just shut up for today, and avoid IRC like hell

[11:08] *** donaldh joined
[11:09] <pmurias> perltidy++ #making generated code readable

[11:09] <rakudo_svn> r28538 | jonathan++ | [rakudo] Big refactor of package declration code. This brings us closer to STD.pm and also breaks one enormous method down into several smaller ones, which should make the code easier to extend and maintain.

[11:14] *** alc left
[11:15] *** mjk joined
[11:19] *** jan__ left
[11:22] *** tcliou_ left
[11:22] *** penk left
[11:23] *** c1sung left
[11:23] *** tcliou joined
[11:23] *** LCamel_ joined
[11:24] *** LCamel left
[11:26] *** meppl left
[11:37] *** iblechbot joined
[11:44] *** a-jing joined
[11:44] *** a-jing left
[11:44] *** chris2 joined
[11:49] *** DietCoke joined
[11:57] *** Psyche^ joined
[12:01] *** redicaps joined
[12:14] *** Patterner left
[12:16] *** Psyche^ is now known as Patterner

[12:20] *** pbuetow joined
[12:21] <pugs_svnbot> r20888 | pmurias++ | [sm0p] actions work

[12:24] <pugs_svnbot> r20889 | diakopter++ | [yap6] another interim checkin; I should've done this in a branch...

[12:26] <pmurias> TimToady: would it be wise to overload operators on the matches (Cursors realy) returned from STD5?

[12:26] *** kanru left
[12:29] *** kanru joined
[12:29] * diakopter ponders n-ary operator rule constructors

[12:47] *** |Jedai| joined
[12:47] <rakudo_svn> r28540 | jonathan++ | [rakudo] Get !keyword_does to take a role PMC rather than a name, making it re-usable. Also switch from ident to name in a couple of places, which will help us get namespace things right later on.

[12:50] *** lichtkind joined
[12:50] <lichtkind> is an bare block executed?

[12:51] <lichtkind> syn says yes but a larry talk once said no

[12:51] <moritz_> lichtkind: it is context dependent

[12:57] *** Lorn joined
[13:05] *** Jedai left
[13:16] *** lichtkind left
[13:26] *** b_jonas joined
[13:37] *** jan__ joined
[13:39] <pmurias> ls

[13:39] <pmurias> sorry

[13:43] *** alanhaggai joined
[13:50] *** wknight8111 joined
[13:54] *** wolv joined
[13:54] *** mjk left
[14:05] *** wolverian left
[14:05] *** wolv is now known as wolverian

[14:08] *** chris2 left
[14:14] <pmichaud> Auzon: (S05 tests) -- note that we have a fair number of tests in the parrot repo already (derived from the ones from Pugs)

[14:14] <pmichaud> the ones in the parrot repo are up-to-date.

[14:15] <pmichaud> at any rate, I'm not in any hurry for S05 tests -- I'd much rather have S03 tests earlier

[14:16] *** alanhaggai left
[14:25] * DietCoke ~~ to pmichaud.

[14:25] * DietCoke found a picture on his phone of you, me and allison.

[14:25] * DietCoke guesses it was Kennedy.

[14:26] <pmichaud> heh

[14:26] <pmichaud> must've been

[14:27] <DietCoke> perljam?

[14:28] <pmichaud> I doubt it.

[14:28] *** r0bby left
[14:28] <DietCoke> was looking for his email addy.

[14:28] <pmichaud> oh

[14:28] <pmichaud> [email@hidden.address]
[14:29] <b_jonas> take care with mail addresses, this channel has a public log on the web

[14:29] <rindolf> b_jonas: so?

[14:29] <pmichaud> yes, I know, but I also know his addr is public already :-)

[14:29] <DietCoke> spam filters ho!

[14:29] <rindolf> b_jonas: spammers also install malware to harvest addresses.

[14:29] <rindolf> b_jonas: I already got 11 spam messages to my new GMail account.

[14:29] <b_jonas> rindolf: oh sure, but it might still increase the volume

[14:29] <b_jonas> it's not like a yes or no thing

[14:30] <rindolf> b_jonas: and they subscribe to mailing lists to harvest the addresses from there.

[14:30] <rindolf> b_jonas: yes.

[14:30] <b_jonas> sure, I use spam filters and stuff too 

[14:30] <b_jonas> and still get spam

[14:30] <b_jonas> not surprisingly

[14:30] <rindolf> b_jonas: I have a mailto:shlomif@iglu.org.il address on many places, and I can handle my spam using spam assassin.

[14:31] <rindolf> http://p3m.org/pfn/1561 - what horrible code.

[14:31] <lambdabot> Title: p3m.org/pfn paste from "udinesh5" at 122.166.34.242...

[14:31] <rakudo_svn> r28546 | jonathan++ | [rakudo] Implement basic use of does operator for mixing in a role to an existing object at runtime. This was most neatly done with a dynop, so this check-in also adds a dynops file for Rakudo. make makefile will be required to build after this check-in.

[14:31] <b_jonas> rindolf: sure, but you can't really know that about nother person

[14:31] <rindolf> b_jonas: OK.

[14:31] <rindolf> I think GMail's spam filter has many false positives.

[14:32] <rindolf> Many ham messages are marked as spam there.

[14:32] <rindolf> http://www.shlomifish.org/philosophy/philosophy/closed-books-are-so-19th-century/ - I made this accessible from the rest of the site today.

[14:32] <lambdabot> Title: Why Closed Books are So 19th-Century, http://tinyurl.com/5gvmdl

[14:33] <b_jonas> rindolf: probably yes

[14:33] <b_jonas> it's diffult to tell how many because I don't check all of the mails marked as spam

[14:33] <rindolf> b_jonas: yes, neither do I.

[14:33] *** |Jedai| left
[14:35] *** cornelius_ joined
[14:36] *** cornelius_ is now known as c9s

[14:42] <diakopter> pmichaud: I'm wondering how much of S05:Longest Token Matching are implementation detail suggestions as opposed to specifications...

[14:42] <pmichaud> I haven't looked at it that closely yet.  But to me they have the feel of "specifications"

[14:43] <DietCoke> S05?

[14:43] <DietCoke> ... wrong bot.

[14:43] <pmichaud> s/yet/lately.

[14:43] <diakopter> http://www.perlcabal.org/syn/S05.html#Longest-token_matching

[14:43] <lambdabot> Title: S05

[14:45] <moritz_> b_jonas: at least the logger that I maintain obfuscate email addresses

[14:45] <b_jonas> moritz_: ah, I didn't know that

[14:45] <b_jonas> nice

[14:45] <b_jonas> I hope it doesn't have much false positives

[14:45] <moritz_> the @ is replaced an @ image

[14:45] <pugs_svnbot> r20890 | jnthn++ | [spectest] Some tests for mixing in roles with 'does'.

[14:45] <b_jonas> ah, I see

[14:46] <moritz_> if it's iin something that looks like an email address

[14:46] <moritz_> nobody complained about false positives for now

[14:46] <diakopter> well, I'm starting to get a clear(er) picture of the goal for which the author is striving, but it seems that much of the description has to do with "how to ensure we don't leave anything hanging on the right side when parsing, when using a predictive parser backed by NFA..."

[14:46] <b_jonas> there's a mailing list where I've once sent a shell script, lost the email, and can't get it back because the archives webpage removes something in it irreversibly that's not actually an email address but it thinks it is

[14:48] <diakopter> pmichaud: plz see above. in other words, it seems to me that much of the logic/constructs described in this section aren't necessary when using a recursive descent parser.

[14:48] *** revdiablo joined
[14:48] <diakopter> that is, the specified behaviors can be provided in other (probably simpler) ways

[14:49] <pmichaud> except I think the point of the description is to say "here's where regexes aren't doing recursive descent"

[14:49] <moritz_> b_jonas: don't think I fell into that trap. If somebody needs to have large excerpts from the logs and copy & paste doesn't help, I can just spit out some SQL for them ;)

[14:49] <rakudo_svn> r28547 | jonathan++ | [rakudo] Add (passing) mixins test to Rakudo passing list.

[14:49] <diakopter> pmichaud: thanks; I'll think on that and re-read with that perspective

[14:50] <pmichaud> recursive descent isn't prohibited, it's just that one uses || instead of | when one wants the traditional rec-descent way of looking at things

[14:50] <pmichaud> but to get DFA longest-token matching semantics, one uses |

[14:51] <pmichaud> and in particular, I think that STD.pm relies on longest-token matching semantics to work properly.

[14:51] <b_jonas> moritz_: good

[14:53] <diakopter> pmichaud: but currently in yap6, | checks all the alternatives and returns the one that matches the most characters...?

[14:54] <diakopter> pmichaud: though of course there can be another alternator that does first-match

[14:55] <pmichaud> how would yap6 handle   "if(2+3)"  ?

[14:55] <diakopter> pmichaud: I guess my point is, recursive descent doesn't necessarily imply first-match

[14:55] *** toddr joined
[14:55] <pmichaud> (doesn't imply first match)  I agree.

[14:55] <diakopter> pmichaud: it doesn't know about "if", but it does parse  "say say 3" correctly.

[14:56] <diakopter> (as say(say(3)))

[14:56] <pmichaud> right... but I'm curious how one would distinguish "if(2)" from "if (2)"

[14:56] <diakopter> oh

[14:57] <diakopter> I've built into the alternation/concatenation operators knowledge about mandatory/disallowed/optional whitespace

[14:58] <diakopter> so you just have to encode the rule correctly.  is "if(2)" not allowed (must there be a space between if and ()?

[14:58] <pmichaud> yes, but "if(2)" is an expression while  "if (2)" is a statement.

[14:59] <pmichaud> i.e., "if(2)" gets parsed by the <EXPR> rule, and "if (2) ..."  is statement_control:if

[14:59] <moritz_> oh my.

[14:59] <diakopter> what's the behavior of if(2) - I mean, what does that do?

[14:59] <pmichaud> calls a function called 'if'.

[14:59] <diakopter> ohhh, ok, now I see what you're asking

[14:59] <pmichaud> perl6 doesn't have reserved words.

[15:00] <pmichaud> anyway, I haven't studied it in detail, so "if" might be not an example of what I'm trying to describe.

[15:00] <rakudo_svn> r28548 | jonathan++ | [rakudo] Fix to make $foo does (R1, R2) working.

[15:00] <pmichaud> But I do know tha TimToady mentioned at one point that he could simplify STD.pm because of having LTM implemented.

[15:01] <diakopter> pmichaud: no, you have a good point.  I'll think on it a bit and reply here.

[15:01] <diakopter> moritz_: oh my?

[15:02] <moritz_> diakopter: that will become a FAQ

[15:04] <diakopter> pmichaud: oh.  this is simpler than I first imagined... Perl6in5's equivalent (before grammar-bootstrapping) statement control rule would require the whitespace, and token {<function_name_equiv> '(' etc..}  would be the start of one of the options of function invocation pattern

[15:06] <pmurias> rindolf: do you receive much critisism for your essays?

[15:06] <pugs_svnbot> r20891 | moritz++ | [spec] added test for sequential alternations (||) in regexes

[15:06] <diakopter> (where I'm using "token" as Perl6in5's equivalent to don't-allow-whitespace

[15:06] <diakopter> )

[15:06] <rindolf> pmurias: a lot of people comment on them.

[15:09] <diakopter> pugs: say;

[15:09] <p6eval> OUTPUT[␤]

[15:10] <diakopter> hrm, that's going to be tricky

[15:11] <diakopter> pugs: say say;

[15:11] <p6eval> OUTPUT[␤1␤]

[15:11] <pugs_svnbot> r20892 | moritz++ | [spec] tests for interpolated sequential alternations ( ||@list )

[15:13] <diakopter> pugs: sub if { say 3; }; if() if if();

[15:13] <p6eval> OUTPUT[*** ␤    Unexpected "if"␤    expecting operator or bare or pointy block construct␤    at /tmp/fcE6kcl6g0 line 1, column 25␤]

[15:14] *** pmurias left
[15:14] <diakopter> pugs: sub if { say 3; }; if 1 { if() };

[15:14] <p6eval> OUTPUT[*** ␤    Unexpected "};"␤    expecting operator or bare or pointy block construct␤    at /tmp/F23g9OK4sk line 1, column 32␤]

[15:14] <diakopter> pugs: sub if { say 3; }; if 1 { if() }

[15:14] <p6eval> OUTPUT[*** ␤    Unexpected "}"␤    expecting operator or bare or pointy block construct␤    at /tmp/zKjOME5hS2 line 1, column 32␤]

[15:15] <diakopter> pmichaud: pugs doesn't like a declaration of a sub named 'if'

[15:15] <pugs_svnbot> r20893 | moritz++ | [spec] test for longest alternation match with interpolation in regex

[15:21] <pmichaud> "Dear IIT.  Your wireless access sucks."

[15:21] *** TJCRI joined
[15:22] <pmichaud> pugs is likely out of date on "if()"  But I know it's a sub call -- TimToady even mentioned it in his keynote.

[15:23] <pmichaud> It's even in S03.

[15:23] <diakopter> pmichaud: ok

[15:23] <pmichaud>     if $a == 1 { say "yes" }            # preferred syntax

[15:23] <pmichaud>     if ($a == 1) { say "yes" }          # P5-ish if construct

[15:23] <pmichaud>     if($a,$b,$c)                        # if function call

[15:24] <diakopter> pugs: if say { say 3 } { say 4 }

[15:24] <p6eval> OUTPUT[␤3␤4␤]

[15:24] *** udinesh5 joined
[15:24] <udinesh5> will i get help to know where i am going wrong in a perl script ?

[15:24] <udinesh5> i am newbie

[15:24] <diakopter> pugs: if !say { say 3 }

[15:24] <p6eval> OUTPUT[␤]

[15:24] <moritz_> udinesh5: only if your script is written in Perl 6

[15:25] <moritz_> udinesh5: if it's perl 5 (most likely), try #perl or #perlhelp or http://www.perlmonks.org/

[15:25] <lambdabot> Title: PerlMonks - The Monastery Gates

[15:26] *** TJCRI left
[15:27] *** b_jonas left
[15:27] <diakopter> pugs: say 4 if !say { say 3 }

[15:27] <p6eval> OUTPUT[<SubBlock(<anon>)>␤]

[15:28] <diakopter> pmichaud: :) see pugs above... I think this is an ambiguity in the grammar...

[15:29] <diakopter> it should've said "3" then <SubBlock(<anon>)>... 

[15:29] <diakopter> pugs: say { say 3 }

[15:29] <p6eval> OUTPUT[<SubBlock(<anon>)>␤]

[15:29] <diakopter> pugs: { say 3 }

[15:29] <p6eval> OUTPUT[3␤]

[15:30] <diakopter> moritz_: (anyone), shouldn't it say 3 then 1 (2 evals above)

[15:31] <moritz_> diakopter: no, don't think - blocks aren't evaluated if they are in the argument list of a sub

[15:31] <moritz_> diakopter: otherwise you couldn't get a map {$code}, @stuff working

[15:32] <diakopter> moritz_: oh. thanks :)

[15:32] *** udinesh5 left
[15:33] <TimToady> that's one of the reasons we distinguish statements from expressions

[15:35] <TimToady> but note that we can't really add the implicit .() to a bare block until we see how it ends, since {...}.() is an expression

[15:36] <diakopter> ok.  so bare blocks are executed inline only in a statement list

[15:37] <diakopter> TimToady: (& pmichaud & moritz_) thanks for the clarifications/corrections

[15:37] <diakopter> (& pugs)

[15:38] <moritz_> diakopter: you're welcome ;)

[15:38] <TimToady> you too :)

[15:40] *** cjfields joined
[15:41] <rakudo_svn> r28549 | jonathan++ | [rakudo] Get initialization of one-attribute roles working ($thingy does Answer(42)).

[15:42] <pugs_svnbot> r20894 | jnthn++ | [spectest] A couple more mixin tests, for does (R1, R2) and does Answer(42) usage.

[15:43] <diakopter> pugs: say { say 4; }.()

[15:43] <p6eval> OUTPUT[<SubBlock(<anon>)>␤*** Cannot cast from VBool True to Pugs.AST.Internals.VCode (VCode)␤    at /tmp/nLpAEV8hW3 line 1, column 1 - line 2, column 1␤]

[15:43] <diakopter> pugs: say ({ say 4; }.())

[15:43] <p6eval> OUTPUT[4␤1␤]

[15:43] <diakopter> that precedence isn't right...?

[15:44] <moritz_> why not?

[15:44] <diakopter> shouldn't the one without the parens have the same output as the last one?

[15:44] <moritz_> uhm, yes

[15:45] <moritz_> (I thought you were referring to the last eval)

[15:45] <diakopter> right, so the precedence inference is wrong on the first one

[15:45] <diakopter> ok

[15:46] <diakopter> pugs: say ({ say 4; }.({ say 3 }.({ say 2 })))

[15:46] <p6eval> OUTPUT[4␤1␤]

[15:46] <diakopter> that's not right either, I think..? it should've said '3' first

[15:47] <diakopter> or do anonymous sub executions not take arguments?

[15:49] <moritz_> diakopter: only if you declare them (-> $args, {...}), or if they use $_ or $^a or some such

[15:49] <pmichaud> 50% packet loss and train to airport is here

[15:49] <pmichaud> bbl

[15:50] <diakopter> but in that case, I would think they would at least be evaluated before it decides whether to use them as arguments...?

[15:50] <diakopter> if not, that's some magic...

[15:50] *** r0bby joined
[15:51] <moritz_> why evaluated? the arity of a block is determined at compile time, I think

[15:51] *** donaldh left
[15:53] <diakopter> pugs: say ({ say 2; $_ }.({ say 3; $_ }.({ say 4 }).()))

[15:53] <p6eval> OUTPUT[3␤4␤2␤1␤]

[15:54] <diakopter> that's pretty darn lazy...

[15:54] <diakopter> not evaluating the argument before it's accessed

[15:55] <diakopter> (for the deepest nesting.  it does do the first nesting before "say 2")  curiouser ** and

[15:56] * diakopter waits for another rebuke :D

[15:57] *** alanhaggai joined
[15:58] <diakopter> TimToady: any clue about pugs' last?  or is it a pugsbug?

[15:59] <moritz_> diakopter: lists are lazy by default

[15:59] <moritz_> diakopter: and argument lists are lists, aren't they?

[16:01] <moritz_> elf: say 1 xx 4

[16:01] <p6eval> OUTPUT[1111␤]

[16:01] <moritz_> elf: say 2,3 xx 4

[16:01] <p6eval> OUTPUT[23333␤]

[16:08] *** scrottie joined
[16:31] *** shlomif joined
[16:32] *** rindolf left
[16:32] *** shlomif is now known as rindolf

[16:36] *** alester joined
[16:37] <diakopter> moritz_: ok, but my 2nd point... it should've printed 2341.

[16:37] <rakudo_svn> r28551 | jonathan++ | [rakudo] Get lookup of subs with & sigil working again, so we can do &foo.arity. Do this in a way that should work once we add lexical subs.

[16:41] *** araujo left
[16:43] *** alanhaggai left
[16:52] *** cspencer joined
[16:54] *** alanhaggai joined
[16:55] *** shlomif joined
[16:59] *** rindolf left
[16:59] *** shlomif is now known as rindolf

[17:03] *** Jedai joined
[17:07] <rakudo_svn> r28552 | jonathan++ | [rakudo] Allow declaration of type variables with the :: sigil; Now 'my ::Foo = Int; my Foo $x; say $x.WHAT' gives Int.

[17:10] <diakopter> pmichaud: to more fully answer your question from earlier, because 'if (<cond>)' will always be longer (by the one character) than 'if(<cond>)', it will win the alternation between the function call and the conditional pattern...

[17:45] *** REPLeffect_ joined
[18:10] *** lichtkind joined
[18:13] *** Lorn_ joined
[18:18] *** sri_work_ joined
[18:19] *** ruoso joined
[18:19] <pugs_svnbot> r20895 | diakopter++ | [yap6] added short-circuiting alternation as a special case of longest match alternation. Used the only other overloadable Perl operator with the same precedence as '|'.

[18:21] * ruoso in Brasil already

[18:24] *** valkyr0 joined
[18:27] *** sri_work left
[18:28] *** pmurias joined
[18:29] <pmurias> ruoso: the sm0p grammar works (returns the c code), i haven't plugged it in yet

[18:29] <ruoso> cool

[18:29] <ruoso> is it faster?

[18:30] <pmurias> haven't benchmarked yet

[18:31] <Khisanth> o_O you can write subs named if,while,until,... ?

[18:31] <moritz_> Khisanth: yes

[18:31] <pmurias> ruoso: but it would be hard for it to be  slower

[18:32] <ruoso> heh

[18:32] <ruoso> if it takes less than 5 seconds for the blocks in the tests, then it's faster ;)

[18:33] <ruoso> (for each one, actually)

[18:34] <pmurias> ruoso: do you have 5.10?

[18:34] <ruoso> not yet... but I have to do the transition today on my machine

[18:34] <Khisanth> sounds like it will make debugging a PITA

[18:34] <ruoso> (which means a lot of modules to recompile)

[18:35] <pmurias> Khisanth: why?

[18:36] <Khisanth> assuming someone decides to be that foolish :)

[18:37] *** Lorn left
[18:37] <diakopter> pmurias: I'm coining 'lrule' as "lambda rule"...

[18:38] <diakopter> (another top-level type declaration in this grammar syntax)

[18:38] <pmurias> diakopter: example please

[18:40] *** REPLeffect_ left
[18:40] *** lichtkind_ joined
[18:40] *** cspencer left
[18:40] *** REPLeffect_ joined
[18:41] <diakopter> pmurias: lrule commalist { -( plus( ',' ) ) - opt( $_[1], $_[0] ) };

[18:42] <diakopter> rule blkPrmsList { opt( prmDecl ) };

[18:42] <diakopter> oops

[18:42] <pmurias> ruoso: i should have used KP6sm0p.p6 not KP6Grammar.pm?

[18:42] <diakopter> rule blkPrmsList { opt( commalist( prmDecl ) ) };

[18:43] <diakopter> ...this just might work!

[18:44] <ruoso> pmurias, the KP6 version was changed to make it work... it isn't the ideal implementation

[18:44] <diakopter> in that example, $p (the self-referent for each rule) gets unshifted into @_

[18:45] <diakopter> oops, I mean self-reference

[18:45] <diakopter> which makes lrule capable of generating both left- and right-recursive parsers

[18:46] <rakudo_svn> r28555 | jonathan++ | [rakudo] Implement generic subs/methods. You can now collect the type of a parameter by writing a signature like 'sub foo(::T $x) { ... }', and then use T within that method to refer to that type.

[18:46] <diakopter> ... this will clean up Parser.pm a lot...

[18:49] <Auzon> backticks are dead, correct?

[18:49] <Eevee> think so, hope so, not positive

[18:50] <Auzon> Larry wrote to the list that they are reserved for user-defined stuff

[18:52] <pugs_svnbot> r20896 | pmurias++ | [sm0p] sm0p_with_actions does dump the match object unless --horizontal or --vertical options are given

[18:53] <pmurias> ruoso: is KP6Grammar.pm enough?

[18:53] <pmurias> ruoso: it's misc/sm0p/sm0p_with_actions if you want to plug it in

[18:54] <diakopter> is there a term for self-currying?

[18:54] <ruoso> KP6sm0p is the one that is used....

[18:54] <ruoso> the others shouldn't be that different...

[18:54] <pmurias> diakopter: what does self-reference have to do with lambdas?

[18:54] <ruoso> but they might have some small things that were only fixed/implemented in the version being used

[18:55] <pmurias> fix is used for recursion in the lambda calculus

[18:56] *** lichtkind left
[18:58] <pmurias> diakopter: got confused with the typed lambda calculus

[19:01] *** tuxdna joined
[19:01] <ruoso> pmurias, btw... I'm still finishing that project...

[19:02] <ruoso> It should end in late june

[19:02] <ruoso> and I'll be able to get back to smop in the start of july

[19:04] <pmurias> ruoso: what are you creating?

[19:05] <ruoso> it's a SOAP+XMPP application with web interfaces for public service scheduling

[19:05] *** REPLeffect_ is now known as REPLeffect

[19:06] <ruoso> that places where you get a numbered ticket that is later called on a video screen 

[19:06] <ruoso> it's a system to handle all that

[19:07] *** Limbic_Region joined
[19:14] <diakopter> pmurias: wait 'till you see sub lrule

[19:25] *** FurnaceBoy joined
[19:27] *** Auzon left
[19:30] *** cookys joined
[19:32] *** FurnaceBoy left
[19:47] <TimToady> hi, guys, you're on the screen at Google-Chi, (though no one's here yet...)

[19:47] <diakopter> lrule is a parser generator generator

[19:47] <diakopter> ohai

[19:47] <PerlJam> What's Google-Chi?  Sounds ominous. :)

[19:48] <fullermd> It's a calming exercise done by groups of people in the park every morning, where they all slowly and serenely search websites.

[19:50] <PerlJam> fullermd: hmm.  I was pronouncing it as google-ki rather than google-chee.  That might have something to do with it.

[19:50] <TimToady> (the tech-talk here is in 15 minutes)

[19:52] <diakopter> information overload warm-up

[19:55] <yath> what tech talk?

[19:57] <TimToady> a google-tech-talk-kinda thing

[19:57] <Khisanth> google expanding into martial arts? :)

[19:57] <TimToady> of course, I'll be talking about the part that isn't googletech

[19:57] <TimToady> (yet)

[19:57] <scrottie> hi Google =)

[19:57] <yath> TimToady: hmm, what exactly is the topic? ;)

[19:57] <scrottie> btw, thanks for sending us Vint Cerf to Google Phoenix.  Most enjoyable!

[19:58] <TimToady> I kinda thought I might talk about Perl 6 today

[19:58] <TimToady> (for a change)

[19:58] <yath> ah, how surprising :)

[19:58] <diakopter> as opposed to talking about it yesterday?

[19:58] <scrottie> Can you stream video?  I couldn't take notes fast enough the first time.

[19:58] <TimToady> it's a shorter talk, so I took out all the Japanese

[19:59] <scrottie> That means less time to write.

[19:59] <scrottie> I'm fighting with SWIG... I'm tryin' to make this go.

[20:00] *** zaphar_ps joined
[20:01] <zaphar_ps> lol sitting waiting for Larry to talk at google

[20:01] * DietCoke ~~ at TimToady.

[20:01] *** Auzon joined
[20:01] <wolverian> what's the talk about? is it stupid to ask? :)

[20:01] <scrottie> you're laughing and the jokes haven't even started yet?

[20:02] <zaphar_ps> well you know

[20:02] <scrottie> good to have an audiance in a good mood!

[20:02] <TimToady> you guys should be running cool snippets for the folks coming in

[20:02] *** Alias_ joined
[20:02] <zaphar_ps> I had to miss YAPC so I had to come to this one :-(

[20:03] <zaphar_ps> family vacation came at the wrong time

[20:03] <TimToady> we all have our faults

[20:03] <DietCoke> perl6: 'Hi, google'.say

[20:03] <p6eval> kp6 r20896: OUTPUT[Hi, google␤]

[20:03] <p6eval> ..pugs: OUTPUT[Hi, google␤]

[20:03] <p6eval> ..rakudo r28560: OUTPUT[Hi, google␤]

[20:03] <p6eval> ..elf r20896: OUTPUT[Hi, google␤]

[20:03] * DietCoke supposes he should learn some perl6. =-)

[20:04] <Auzon> pugs: multi postfix:<!> (Int $a) {[*] 1 .. $a}; say 6!; # One of my favorite P6 snippets

[20:04] <p6eval> OUTPUT[720␤]

[20:05] <pmurias> TimToady: what did you talk about previously?

[20:05] <TimToady> okay, talk starting, bye

[20:05] <Auzon> Bye TimToady

[20:05] <pmurias> good luck ;)

[20:06] <Auzon> perl6: say [~] <m oo se>

[20:06] *** p6eval left
[20:06] <Auzon> oh cool.

[20:06] *** p6eval joined
[20:07] <rhr_> pugs: -> $X { -> $proc { $X.( -> $arg { $proc.($proc).($arg) } ) }.( -> $proc { $X.( -> $arg { $proc.($proc).($arg) } ) }) }.(-> $func { -> $n { $n==0 ?? 1 !! $n*$func.($n-1) } }).(5).say

[20:07] <p6eval> OUTPUT[120␤]

[20:09] <rakudo_svn> r28563 | jonathan++ | [rakudo] Improvements/optimizations to rebless_subclass op from chromatic++.

[20:10] *** Alias_ left
[20:13] <Auzon> pugs: say :60[1,0,0]

[20:13] <p6eval> OUTPUT[3600␤]

[20:13] <Auzon> pugs: say :60[1,1,1]

[20:13] <p6eval> OUTPUT[3661␤]

[20:13] <Auzon> perl6: say :60[1,1,1]

[20:14] <p6eval> kp6 r20896: OUTPUT[syntax error at position 4, line 1 column 4:␤say :60[1,1,1␤    ^ HERE␤]

[20:14] <p6eval> ..pugs: OUTPUT[3661␤]

[20:14] <p6eval> ..rakudo r28563: OUTPUT[Method 'pasttype' not found for invocant of class 'PAST::Var'␤current instr.: 'parrot;Perl6;Grammar;Actions;rad_number' pc 99622 (src/gen_actions.pir:3506)␤

[20:14] <p6eval> ..elf r20896: OUTPUT[Unknown rule: rad_number␤It needs to be added to ast_handlers.␤ at ./elf_f line 1900␤]

[20:15] <Auzon> perl6: say <<<a> <b>>>

[20:15] <p6eval> kp6 r20896: OUTPUT[syntax error at position 12, line 1 column 12:␤say <<<a> <b>>␤            ^ HERE␤]

[20:15] <p6eval> ..pugs: OUTPUT[*** ␤    Unexpected end of input␤    at /tmp/oyMXBG64q1 line 2, column 1␤]

[20:15] <p6eval> ..rakudo r28563: OUTPUT[Statement not terminated properly at line 1, near ">>>"␤current instr.: 'parrot;PGE::Util;die' pc 120 (runtime/parrot/library/PGE/Util.pir:82)␤

[20:15] <p6eval> ..elf r20896: OUTPUT[Use of uninitialized value in concatenation (.) or string at ./elf_f line 3425.␤syntax error at (eval 115) line 3, near "> )"␤ at ./elf_f line 3835␤]

[20:17] <mofino> is it ready?  can I convert my whole being to perl6 yet?

[20:17] <mofino> (no)

[20:18] <DietCoke> you go ahead and try, we could use the bug reports.

[20:20] *** stevan_ joined
[20:24] * diakopter hopes we're still on the screen

[20:24] <pugs_svnbot> r20897 | diakopter++ | [yap6] added a function that generates functions that generate

[20:24] <pugs_svnbot> r20897 | diakopter++ | parser generators that curry themselves.  8]

[20:31] *** pmurias left
[20:45] <rakudo_svn> r28564 | jonathan++ | [rakudo] Add ops to CLEANUP.

[20:48] *** sri_work_ left
[20:58] *** ruoso left
[20:59] *** zaphar_ps left
[21:07] *** FurnaceBoy joined
[21:08] <pugs_svnbot> r20898 | Auzon++ | Vim syntax highlighting: Removed backticks. Attempted to add attribute support to qq and q (qq:!s"" and such)

[21:14] *** FurnaceBoy left
[21:20] *** jferrero joined
[21:24] *** valkyr0 left
[21:27] *** bacek_ left
[21:31] *** donaldh joined
[21:32] *** pmurias joined
[21:35] <pmurias> diakopter: why did you add an unused tmp variable?

[21:38] <diakopter> pmurias: same reason as all through Parser.pm ... b/c the things I read said that it's necessary to hold the reference before calling weaken()

[21:38] <diakopter> I'm updating heavily currently; last rev was way broken (of course)

[21:39] <pmurias> yes but i's held in stub

[21:40] <pmurias> * it's

[21:40] *** lichtkind_ left
[21:40] <diakopter> oh

[21:41] <diakopter> pmurias: you're up late

[21:41] <pmurias> diakopter: yes

[21:41] <pmurias> 20 to 12

[21:41] <pmurias> 23:41

[21:42] <pmurias> diakopter: you mean i'm talking nonsense ;)

[21:43] <diakopter> pmurias: no

[21:43] *** valkyr0 joined
[21:43] <diakopter> I've nearly got this.. probably 10 minutes

[21:44] <pmurias> can't sleep, don't have to get up early too

[21:44] <diakopter> pmurias: question

[21:44] <pmurias> go on

[21:45] <diakopter> where in Grammar.pm did you have rule() defining what each_rule_name()

[21:45] <diakopter> I mean, the sub entry should be defined somewhere, right?

[21:46] <pmurias> $Perl6in5::Grammar::{$name} = sub() {$stub};

[21:46] <diakopter> ok.

[21:46] <diakopter> the source filter causes it to be predeclared.. ah ok.

[21:46] <diakopter> ahh, I see where I messed up

[21:46] *** iblechbot left
[21:47] <pmurias> the lrules have a different prototype

[21:47] <pmurias> * should have

[21:49] <diakopter> yep :) I had just realized that

[21:52] *** araujo joined
[21:53] <pmurias> diakopter: why do you weaken $stub?

[21:53] <pmurias> what other reference keeps it alive?

[21:56] <pmurias> it = the sub points to

[21:57] <pmurias> s/sub/$stub/

[21:57] <diakopter> I was reading the mailing list archives for MJD's HOP book, and someone there recommended it

[21:58] <diakopter> and if I remember correctly, said they weren't sure why it worked, but that it did.

[21:58] <diakopter> b/c of a bug in perl GC when anonymous subs are used recursively

[21:58] <diakopter> allegedly

[21:59] <rakudo_svn> r28567 | jonathan++ | [rakudo] First cut at implementing anonymous enums.

[21:59] <pmurias> diakopter: i would just throw it out

[21:59] *** rindolf left
[22:00] <moritz_> and use perl 5.10.0, which hopefully fixed it ;)

[22:01] <pmurias> diakopter: yap6 is broken now?

[22:02] *** valkyr0 left
[22:02] <diakopter> pmurias: yeah, like always ;)

[22:03] <diakopter> pmurias: what prototype do lrules need if they need to accept a "subroutine entry"

[22:03] <pmurias> none

[22:05] <pmurias> prototypes are used for achieving stange parsing

[22:06] <pmurias> * strange

[22:06] <diakopter> committed

[22:06] <pugs_svnbot> r20899 | diakopter++ | [yap6] some progress on lrule()

[22:07] <pmurias> should yap6 work?

[22:07] <diakopter> no... lrule() is still slightly broken.

[22:07] <diakopter> but a lot less so.

[22:07] <pmurias> is lrule essential?

[22:08] <diakopter> I was going to use it to convert a lot of the constructors in Parser.pm to grammar rules, since they really belong in the grammar section, not the parser.

[22:09] <diakopter> and also so that recursive parser generators can be auto-generated

[22:09] <diakopter> with an eye toward eventually being able to generate any grammar...

[22:09] <diakopter> at runtime.

[22:09] <pmurias> diakopter: you should definitly remove weaken,as it's gets you nothing and is really just looking for trouble

[22:10] <diakopter> I removed one of them in the last commit

[22:11] <pmurias> it might be cleaner to have a this parser combinator (right terminology) instead of passing the currently defined rule as the first parameter

[22:12] <diakopter> oh, I found my error

[22:14] <diakopter> pmurias: can you restate your last

[22:15] <pmurias> wait

[22:16] <pmurias> lrule commalist { -( plus( ',' ) ) - opt( $_[1], this )

[22:17] <pmurias> };

[22:18] <diakopter> this?

[22:18] <diakopter> ok, I see what you were saying, but I can't imagine how to construct this()

[22:19] <pmurias> i'm sleeping now, will do it tomorrow if you have yap6&lrule in a working state

[22:19] <pmurias> g'night

[22:19] *** pmurias left
[22:21] <diakopter> pmurias: thanks

[22:29] <diakopter> decommutation

[22:33] *** Auzon left
[22:33] *** Auzon joined
[22:35] *** Auzon left
[22:46] *** cjfields left
[22:46] *** donaldh left
[22:54] *** valkyr0 joined
[23:02] *** rindolf joined
[23:04] *** rindolf left
[23:17] *** nipotaway is now known as nipotan

[23:19] <pugs_svnbot> r20900 | diakopter++ | [yap6] incremental progress on lrule().  I *think* the only blocking problem now is a discontinuity in the grammar.

[23:20] *** meppl joined
[23:31] *** toddr left
[23:51] *** jferrero left
[23:54] *** bacek joined
