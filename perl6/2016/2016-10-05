[00:00] <shin_> persisting, as to have a library of transformations, like "crack-the-egg.pl"  in this example

[00:01] *** devmikey left
[00:03] <shin_> i think, maybe naively, just to create a hash with the attribute as the key and a code as the value. But i'm not sure if that would be the right way.

[00:03] *** geraud left
[00:03] <lucasb_> about the transformation part, an idea is to do this: have a subroutine which receives 2 hashes. it returns the first hash, after iterating the second hash and changing the first accordingly

[00:03] <lucasb_> if the values in the second hash are not Callable objects, then just substitute the value in the first hash

[00:04] <lucasb_> if the value in the second hash is a Callable object, then call it with the value from the first hash

[00:05] *** bjz joined
[00:07] <shin_> I didnt thought of discriminating between Callable and not, thanks lucasb_ :)

[00:09] <SmokeMachine____> shin_: something like this?

[00:09] <SmokeMachine____> m: my %a = :shell, :1weight, :origin<animal>; my %t = :shell({False}), :weigth(* * .95); say do for %a.kv -> $key, $value { $key => %t{$key}:exists ?? %t{$key}($value) !! $value }

[00:09] <camelia> rakudo-moar d8309d: OUTPUT«(shell => False origin => animal weight => 1)␤»

[00:09] <skids> (news on the GOP website thing just hit the mainstream shows, much chuckling)

[00:11] *** pierre_ joined
[00:12] <SmokeMachine____> m: my %a = :shell, :1weight, :origin<animal>; my %t = :shell({False}), :weight(* * .95); say do for %a.kv -> $key, $value { $key => %t{$key}:exists ?? %t{$key}($value) !! $value }

[00:12] <camelia> rakudo-moar d8309d: OUTPUT«(shell => False origin => animal weight => 0.95)␤»

[00:14] <SmokeMachine____> m: my %a = :shell, :1weight, :origin<animal>; my %t = :shell(False), :weight(* * .95); say do for %a.kv -> $key, $value { $key => %t{$key}:exists ?? %t{$key} ~~ Callable ?? %t{$key}($value) !! %t{$key} !! $value }

[00:14] <camelia> rakudo-moar d8309d: OUTPUT«(shell => False origin => animal weight => 0.95)␤»

[00:15] <shin_> " :1weight " that's a weird syntax... i mean, i understand it but it looks strange :). Yes SmokeMachine____ , that is exactly what i was looking for!!

[00:16] <shin_> i feel for the poor soul having to write a syntax highlighter for perl6 :)

[00:17] <Xliff> m: use NativeCall; my CArray[int32] @a = Bool.roll(100); say @a.elems

[00:17] <camelia> rakudo-moar d8309d: OUTPUT«Type check failed in assignment to @a; expected NativeCall::Types::CArray[int32] but got Bool (Bool::True)␤  in block <unit> at <tmp> line 1␤␤»

[00:17] <Xliff> m: use NativeCall; my CArray[int32] @a = (^1000).roll(100); say @a.elems

[00:17] <camelia> rakudo-moar d8309d: OUTPUT«Type check failed in assignment to @a; expected NativeCall::Types::CArray[int32] but got Int (837)␤  in block <unit> at <tmp> line 1␤␤»

[00:17] *** bjz left
[00:17] <SmokeMachine____> shin_: I'm not sure... but probably it wouldn't be difficult  once there are the STD grammar... (I guess)

[00:17] <Xliff> I've written a STORE method for CArray, but it looks like it's not getting called there.

[00:18] <Xliff> Is there something else I need to do to get it to work?

[00:20] <MasterDuke> i was just trying to clarify the error message for a definedness constraint on an optional parameter (that was being discussed earlier)

[00:20] <MasterDuke> but if i add a check for "$flags +& $SIG_ELEM_IS_OPTIONAL" here: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Metamodel/BOOTSTRAP.nqp#L332

[00:20] <MasterDuke> it doesn't pass. any idea why that flag would be lost or get unset?

[00:41] <seatek> Oh my gosh, I'm starting to make only stupid mistakes now intead of insane ones. 

[00:42] *** profan left
[00:43] *** perlawhirl joined
[00:44] *** profan joined
[00:45] *** vytas left
[00:55] *** itaipu left
[00:57] *** sammers left
[00:58] *** Ben_Goldberg joined
[00:59] *** BenGoldberg left
[00:59] *** Ben_Goldberg is now known as BenGoldberg

[00:59] *** vytas joined
[01:00] *** Spot__ left
[01:01] *** timeless left
[01:02] *** sammers joined
[01:03] *** tbrowder left
[01:07] *** Spot__ joined
[01:07] *** timeless joined
[01:12] *** mcmillhj joined
[01:15] *** tbrowder joined
[01:17] *** mcmillhj left
[01:17] *** AndyBotwin joined
[01:18] *** AndyBotwin left
[01:19] *** AndyBotwin joined
[01:23] <grondilu> m: given rand { say abs($_ - [/] .Rat.nude) < $*TOLERANCE }

[01:23] <camelia> rakudo-moar d8309d: OUTPUT«False␤»

[01:23] <grondilu> m: given rand { say abs($_ - [/] .Rat.nude) }

[01:23] <camelia> rakudo-moar d8309d: OUTPUT«2.83315068627665e-08␤»

[01:25] *** mcmillhj joined
[01:29] *** zakharyas joined
[01:30] *** mcmillhj left
[01:33] <BenGoldberg> m: given rand { my $r = int($_ * 2**64) / 2**64; ($r - .Rat).abs.say }

[01:33] <camelia> rakudo-moar d8309d: OUTPUT«Cannot invoke this object (REPR: P6int; int)␤  in block <unit> at <tmp> line 1␤␤»

[01:33] <BenGoldberg> m: given rand { my $r = int($_ * 2**64) / 2**64  }

[01:33] <camelia> rakudo-moar d8309d: OUTPUT«Cannot invoke this object (REPR: P6int; int)␤  in block <unit> at <tmp> line 1␤␤»

[01:33] <BenGoldberg> m: my $r = int(rand * 2**64) / 2**64;

[01:33] <camelia> rakudo-moar d8309d: OUTPUT«Cannot invoke this object (REPR: P6int; int)␤  in block <unit> at <tmp> line 1␤␤»

[01:34] * BenGoldberg d'ohs.

[01:34] <BenGoldberg> m: my $r = (rand * 2**64).Int / 2**64;

[01:34] <camelia> rakudo-moar d8309d: ( no output )

[01:34] <BenGoldberg> m: given rand { my $r = ($_ * 2**64).Int / 2**64; ($r - .Rat).abs.say }

[01:34] <camelia> rakudo-moar d8309d: OUTPUT«0.00000019810372627905␤»

[01:35] <BenGoldberg> m: given rand { my $r = ($_ * 2**64).Int / **64; ($r - .Rat).abs.say; ($r - .Num).abs.say }

[01:35] <camelia> rakudo-moar d8309d: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3ven rand { my $r = ($_ * 2**64).Int / **7⏏0564; ($r - .Rat).abs.say; ($r - .Num).abs␤    expecting any of:␤        infix␤        infix stopper␤       …»

[01:35] <BenGoldberg> m: given rand { my $r = ($_ * 2**64).Int / **64; ($r - .Rat).abs.say; ($r - .Num).abs.say; }

[01:35] <camelia> rakudo-moar d8309d: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3ven rand { my $r = ($_ * 2**64).Int / **7⏏0564; ($r - .Rat).abs.say; ($r - .Num).abs␤    expecting any of:␤        infix␤        infix stopper␤       …»

[01:35] <BenGoldberg> m: given rand { my $r = ($_ * 2**64).Int / **64; ($r - .Rat).abs.say; say ($r - .Num).abs; }

[01:35] <camelia> rakudo-moar d8309d: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3ven rand { my $r = ($_ * 2**64).Int / **7⏏0564; ($r - .Rat).abs.say; say ($r - .Num)␤    expecting any of:␤        infix␤        infix stopper␤       …»

[01:35] <BenGoldberg> m: given rand { my $r = ($_ * 2**64).Int / **64; ($r - .Rat).abs.say; say '?'; }

[01:35] <camelia> rakudo-moar d8309d: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3ven rand { my $r = ($_ * 2**64).Int / **7⏏0564; ($r - .Rat).abs.say; say '?'; }␤    expecting any of:␤        infix␤        infix stopper␤        post…»

[01:35] <BenGoldberg> m: given rand { my $r = ($_ * 2**64).Int / **64; ($r - .Rat).abs.say; }

[01:35] <camelia> rakudo-moar d8309d: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3ven rand { my $r = ($_ * 2**64).Int / **7⏏0564; ($r - .Rat).abs.say; }␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤   …»

[01:35] <BenGoldberg> m: given rand { my $r = ($_ * 2**64).Int / 2**64; ($r - .Rat).abs.say }

[01:35] <camelia> rakudo-moar d8309d: OUTPUT«0.0000004221103526471␤»

[01:36] <BenGoldberg> m: given rand { my $r = ($_ * 2**64).Int / 2**64; ($r - .Rat).abs.say; ($r - .Num).abs.say }

[01:36] <camelia> rakudo-moar d8309d: OUTPUT«0.00000011332294994922␤0␤»

[01:36] <BenGoldberg> m: given rand { my $r = ($_ * 2**64).Int / 2**64; $r.nude.say; ($r - .Rat).abs.say; ($r - .Num).abs.say }

[01:36] <camelia> rakudo-moar d8309d: OUTPUT«(7201356454038487 36028797018963968)␤0.000000042983915584652␤0␤»

[01:39] <BenGoldberg> considering that it's not hard to create a Rat which is numerically equal to a given Num, why does .Rat on a Num *not* create such a Rat, and instead make a coarse approximation?

[01:41] <geekosaur> because given any chance at all, the denominator of a Rat will become arbitrarily large

[01:42] <geekosaur> clamping their sizes early and keeping them small keeps Rats usable

[01:43] <geekosaur> otherwise you're going to have "simple" operations that take unexpectedly long

[01:43] <geekosaur> (iirc the coarse approximation was specifically added because this was happening)

[01:50] *** mcmillhj joined
[01:54] *** cpage__ left
[01:54] <shin_> m: my %a = ('shell',True , 'weight',2 , 'origin','animal'); my %t = ('shell',{False}, 'weight',(* * .95)); say do for %a.kv -> $key, $value { $key => %t{$key}:exists ?? %t{$key}($value) !! $value }

[01:54] <camelia> rakudo-moar d8309d: OUTPUT«(shell => False origin => animal weight => 1.9)␤»

[01:55] *** mcmillhj left
[01:55] <shin_> hi.... a question about syntax: (* * 0.95); The first *, what does exactly represents? Can i assign it to a variable inside the code block?

[01:56] <lucasb_> * is Whatever, a special object

[01:56] <lucasb_> in this context, * creates WhateverCode's

[01:56] <lucasb_> (* + 10) is shorthand for -> $x { $x * 10 }

[01:56] <shin_> m: my %a = ('shell',True , 'weight',2 , 'origin','animal'); my %t = ('shell',{False}, 'weight',(my $x = *; return $x * .95)); say do for %a.kv -> $key, $value { $key => %t{$key}:exists ?? %t{$key}($value) !! $value }

[01:56] <camelia> rakudo-moar d8309d: OUTPUT«Cannot resolve caller Numeric(Whatever: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[01:58] *** cdg joined
[01:58] <shin_> let's say i need to process this * value in a loop.... how can i do it without having it contained in a variable?

[02:00] <lucasb_> forget about "*" for a while. design a simple subroutine that receives one argument

[02:00] *** cyphase left
[02:01] <lucasb_> "*" is just syntatic sugar. you can translate your subroutine to use "*" later

[02:01] *** cdg left
[02:01] <skids> * is really for shorter bits than you're trying.

[02:01] *** cdg joined
[02:02] *** cyphase joined
[02:03] <shin_> m: my %a = ('shell',True , 'weight',2 , 'origin','animal'); my %t = ('shell',{False}, 'weight',{$_ * .95}); say do for %a.kv -> $key, $value { $key => %t{$key}:exists ?? %t{$key}($value) !! $value }

[02:03] <camelia> rakudo-moar d8309d: OUTPUT«(shell => False origin => animal weight => 1.9)␤»

[02:03] <shin_> i see... thanks!

[02:05] *** BenGoldberg left
[02:09] <ShimmerFairy> Is there a way I can ask a routine what routines it can call? Specifically it'd be nice to have a tool that analyzed a grammar and told me where I could perhaps eliminate single-use subrules, for instance.

[02:09] *** nadim_ left
[02:10] <ShimmerFairy> In my mind, something like  my token foo { <&a> <&b> };  say &foo.subrules; # gives back a list with the &a and &b routines

[02:10] *** rgrinberg left
[02:10] <MasterDuke> i don't know about for tokes/rules, but in the general case doesn't that require solving the halting problem?

[02:11] <ShimmerFairy> MasterDuke: yeah, the only reason I asked for the general case is because 'token's are just a kind of Routine :)

[02:12] <ShimmerFairy> I could always write an NQP-level tool that ~somehow~ hooks into the P6 AST and pulls out the subrule calls, I just wonder if there are any hooks for that...

[02:13] <skids> Maybe profile callgraphs?

[02:14] *** eliasr left
[02:14] <MasterDuke> kind of the inverse of callframe

[02:14] <ShimmerFairy> skids: the only issue is that I don't want to run the grammar a bunch to see what happens. In my case I'm taking someone else's grammar written in a LTA grammar syntax (a BNF-ish thing), and it'd be nice to get a better picture of how to fix it up the P6 way :)

[02:15] *** rgrinberg joined
[02:16] *** lucasb_ left
[02:22] *** cdg left
[02:43] *** grondilu left
[02:43] *** AndyBotwin left
[02:45] *** pierre_ left
[02:47] *** pierre_ joined
[02:54] <seatek> If I have a class attributed named $.id -- I would like to assign a value to that from a method using a variable representing its name: like $var='id'; $!$var = 4 (where $!$var would be the $.id attribute)

[02:54] <seatek> I can't seem to figure this one out, or I'm getting rummy

[02:54] *** bjz joined
[02:54] <seatek> I thought that $!<<$var>> might do it

[02:57] *** noganex joined
[02:57] *** dj_goku left
[02:58] *** mcmillhj joined
[02:59] <seatek> m: class Cl { has Int $.id; method foo($key) { $!$key = 4; return $!id }} ; say Cl.foo('id');

[02:59] <camelia> rakudo-moar d8309d: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3Cl { has Int $.id; method foo($key) { $!7⏏5$key = 4; return $!id }} ; say Cl.foo('i␤    expecting any of:␤        infix␤        infix stopper␤        …»

[02:59] *** noganex_ left
[03:01] <seatek> m: class Cm { has Int $.id; method foo($key) { $!<<$key>> = 4; return $!id }} ; say Cl.foo('id');

[03:01] <camelia> rakudo-moar d8309d: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    Cl used at line 1␤␤»

[03:01] <seatek> m: class Cm { has Int $.id; method foo($key) { $!<<$key>> = 4; return $!id }} ; say Cm.foo('id');

[03:01] <camelia> rakudo-moar d8309d: OUTPUT«Cannot modify an immutable Nil␤  in method foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[03:01] *** zakharyas left
[03:01] *** zakharyas joined
[03:03] *** mcmillhj left
[03:04] <seatek> oh and self.$var also doesn't work

[03:05] *** pierre_ left
[03:06] *** pierre_ joined
[03:06] *** zacts left
[03:06] *** zakharyas left
[03:06] <llfourn> seatek: if the attribute is rw you can do self."$var"() = "whatever"

[03:06] <llfourn> if it's not rw there may be a way to do it by an indirect lookup

[03:08] <llfourn> (but I've been trying and can't seem to figure out one)

[03:08] <seatek> i suppose i could create a "factory" to map column names to accessors from outside the object. I thought for sure there must be an easy way. I'll try the "rw" for now ! :) thanks llfourn

[03:09] *** kaare_ joined
[03:10] <llfourn> m: class Foo { has $.a is rw; method foo { self."a"() = "foo" }}; my $f = Foo.new; $f.foo; $f.a.say # for reference

[03:10] <camelia> rakudo-moar d8309d: OUTPUT«foo␤»

[03:11] <llfourn> you can also ask the class for it's attributes with .^attributes and set them using the MOP.

[03:12] <seatek> wow... the self."$key"() = $whatever works

[03:12] <llfourn> I'm not sure what you're up to. If you're doing a ORM or something using the MOP might be the solution.

[03:13] <seatek> that's exactly what it is

[03:13] <llfourn> unfortunetly the docs on that are a bit sparse

[03:13] <seatek> sigh. i dont' know anything about the MOP, though I remember hearing about it over and over when I used to have to look up stuff with Moose

[03:14] <llfourn> but if I were to do an ORM I would use EXPORTHOW to create a custom declarator. Intead of 'class { ... }' I would have 'table { ... }' etc

[03:15] <llfourn> then has Int $.id is related(SomeOtherTable.field)

[03:15] <seatek> Well, I'm not doing an exact map to the database and keeping things pure and separated. I honestly really dont' like ORMs ;)

[03:16] *** pierre_ left
[03:16] <llfourn> me too :)

[03:16] <llfourn> I don't like ORMs but if I did one I'd use the MOP :)

[03:16] <seatek> yeah I feel like it's really wasting horsepower

[03:17] <seatek> it's so strange that this works: self."$key"() = $val   but this doesn't: self.$key = $val

[03:18] <seatek> and this doesn't even work: self."$key" = $val

[03:18] <seatek> i'm not the only one who's insane

[03:18] <llfourn> yeah I'm sure there's a good reason why. I just don't know what it is.

[03:19] <llfourn> seatek: no. If you look for long enough in irc logs you will find me asking the same question here about a year ago.

[03:19] <seatek> llfourn, well i'll just have to feel in good company then :)

[03:19] *** zengargoyle joined
[03:20] <seatek> did you stick with the verbose self."$key"() solution for what you needed?

[03:20] <llfourn> yep as far as I remember

[03:20] <seatek> k

[03:22] *** BenGoldberg joined
[03:22] <llfourn> seatek: btw the self."$var"() is for methods generally, not just attributes.

[03:22] <geekosaur> the problem is that there is no direct syntax for accessing a "has" variable based on self. you can access methods, which is why the "name"() works, and accessor methods are autogenerated for "has" variables

[03:22] <llfourn> when you set 'is rw' on the $.a variable it makes the public accessor method return a writ...yeah ^^

[03:23] <seatek> ah ok that makes sense now

[03:23] *** zengargoyle left
[03:24] <seatek> geekosaur, is there some way to do a $!$var to access an attribute?

[03:24] <geekosaur> otherwise it would be self!foo to access a thing defined `has $.foo'. I don't know offhand if there's an indirect syntax for that

[03:24] *** pierre_ joined
[03:24] <geekosaur> (also a sigil in that somewhere but I don't recall where. $self!foo I think?)

[03:25] <llfourn> self!foo is for private methods only I think

[03:26] <llfourn> there isn't a way of getting $!attr-name at runtime other than through the MOP

[03:26] <geekosaur> no, there is something like that --- consider that you can write your own accessors, and therefore need *some* way to access the actual private variable other than the accessor

[03:26] <llfourn> $!attr is the way?

[03:26] <geekosaur> I thought there was a self-type one (but restricted in use)

[03:26] <geekosaur> but, maybe

[03:26] <geekosaur> thing is, this is perl. "restricted" is not usually a hard restriction

[03:27] <llfourn> maybe I'm not 100% sure.

[03:27] <geekosaur> "you shouldn't do this (so we made it harder)" is preferred to "you can't do this"

[03:27] *** zengargoyle joined
[03:27] <seatek> well, self!$key gives Cannot use this form of method call with a private method

[03:27] <geekosaur> ok, so I guess that is always methods.

[03:28] <seatek> and self.$key gives No such method 'CALL-ME' for invocant of type 'Str'

[03:28] <llfourn> yeah I'm pretty sure $!attr is the only way and that is just compile time sugar

[03:28] <llfourn> so you can't do ::('$!attr') etc

[03:29] *** pierre_ left
[03:30] <seatek> you can use variable names from outside the scope of the object though yes? like $myClass.$myAttribute = 4

[03:31] <geekosaur> not as variable names, no; that's what accessor methods are for (including the rw version)

[03:31] <llfourn> seatek: not really. just $myClass.myAttributeWithisrw = 4

[03:32] <seatek> but what if I need to call attribute assignements, or method names, based on an array of names for those methods or attributes

[03:33] <geekosaur> the $foo."$dynmethod"() syntax is for that

[03:33] <seatek> like @methods = ('methodName1', 'methodName2')

[03:34] <llfourn> for @methods { $object."$_"() } # example

[03:34] *** mcmillhj joined
[03:34] <seatek> bah back that :)

[03:34] <llfourn> yes it's consistent ;)

[03:34] <seatek> it's crazy! but i'll take it :)

[03:36] <seatek> yeah no benefit to using a factory to make them from the outside then

[03:36] <seatek> llfourn++

[03:37] <seatek> geekosaur++

[03:39] *** mcmillhj left
[04:04] *** mcmillhj joined
[04:06] *** khw left
[04:07] *** zacts joined
[04:09] *** mcmillhj left
[04:10] *** Alikzus left
[04:10] *** dj_goku joined
[04:10] *** Actualeyes left
[04:10] *** Actualeyes joined
[04:14] *** pierre_ joined
[04:18] *** bjz left
[04:19] *** BenGoldberg left
[04:24] *** Alikzus joined
[04:26] *** Actualeyes left
[04:30] *** mcmillhj joined
[04:35] *** mcmillhj left
[04:38] *** wamba joined
[04:40] *** shin_ left
[04:45] *** Actualeyes joined
[04:53] *** Cabanossi left
[04:56] *** Cabanossi joined
[04:56] *** AlexDaniel left
[04:58] *** mcmillhj joined
[04:58] *** skids left
[05:01] *** pierre_ left
[05:03] *** mcmillhj left
[05:08] *** pierre_ joined
[05:09] *** mcmillhj joined
[05:12] *** pierre_ left
[05:14] *** mcmillhj left
[05:40] *** amalia_ left
[05:41] *** bjz joined
[05:45] *** neuraload joined
[05:45] *** amalia_ joined
[05:50] *** mcmillhj joined
[05:51] *** wamba left
[05:54] *** domidumont joined
[05:55] *** mcmillhj left
[05:59] *** domidumont left
[06:00] *** domidumont joined
[06:08] *** rgrinberg left
[06:09] *** mcmillhj joined
[06:09] *** pierre_ joined
[06:13] *** mcmillhj left
[06:14] *** pierre_ left
[06:21] *** pierre_ joined
[06:26] *** b2gills left
[06:27] *** b2gills joined
[06:35] *** abraxxa joined
[06:36] *** cpage__ joined
[06:39] *** mcmillhj joined
[06:39] *** perlawhirl left
[06:43] *** mcmillhj left
[06:51] *** seatek left
[06:58] *** mcmillhj joined
[06:58] *** brrt joined
[07:02] *** wamba joined
[07:02] *** mcmillhj left
[07:04] *** zakharyas joined
[07:08] *** mcmillhj joined
[07:09] *** mr-foobar joined
[07:12] *** mcmillhj left
[07:16] *** bjz_ joined
[07:17] *** bjz left
[07:26] *** rindolf joined
[07:28] *** mcmillhj joined
[07:28] <dalek> doc: a9f837c | (Sterling Hanenkamp)++ | doc/Type/List.pod6:

[07:28] <dalek> doc: Fix #382: Add docs for cross and X

[07:28] <dalek> doc: 

[07:28] <dalek> doc: Also documents the :&with parameter to zip.

[07:28] <dalek> doc: review: https://github.com/perl6/doc/commit/a9f837c2e0

[07:29] <dalek> doc: f29d2a8 | RabidGravy++ | doc/Type/List.pod6:

[07:29] <dalek> doc: Merge pull request #940 from zostay/cross

[07:29] <dalek> doc: 

[07:29] <dalek> doc: Fix #382: Add docs for cross and X

[07:29] <dalek> doc: review: https://github.com/perl6/doc/commit/f29d2a8e3e

[07:31] *** pmurias joined
[07:32] <dalek> doc: 8b788ba | (Sterling Hanenkamp)++ | doc/Type/Signature.pod6:

[07:32] <dalek> doc: Fix #914: An attempt to clarify slurpy conventions

[07:32] <dalek> doc: review: https://github.com/perl6/doc/commit/8b788ba376

[07:32] <dalek> doc: 904bcb8 | RabidGravy++ | doc/Type/Signature.pod6:

[07:32] <dalek> doc: Merge pull request #939 from zostay/better-slurpiness

[07:32] <dalek> doc: 

[07:32] <dalek> doc: Fix #914: An attempt to clarify slurpy conventions

[07:32] <dalek> doc: review: https://github.com/perl6/doc/commit/904bcb8734

[07:32] *** mcmillhj left
[07:33] *** RabidGravy joined
[07:34] <dalek> doc: e55b772 | (Sterling Hanenkamp)++ | doc/Language/classtut.pod6:

[07:34] <dalek> doc: Fix #889: Nix "previous chapters" sentence

[07:34] <dalek> doc: 

[07:34] <dalek> doc: Looked to see if "chapter" occurred anywhere else too. It did not.

[07:34] <dalek> doc: review: https://github.com/perl6/doc/commit/e55b77247a

[07:34] <dalek> doc: b074734 | RabidGravy++ | doc/Language/classtut.pod6:

[07:34] <dalek> doc: Merge pull request #938 from zostay/nix-previous-chapters

[07:34] <dalek> doc: 

[07:34] <dalek> doc: Fix #889: Nix "previous chapters" sentence

[07:34] <dalek> doc: review: https://github.com/perl6/doc/commit/b074734183

[07:36] <dalek> doc: e94ccc8 | (Sterling Hanenkamp)++ | doc/Type/Proc.pod6:

[07:36] <dalek> doc: Fix #913: Add documentation for shell and command

[07:36] <dalek> doc: 

[07:36] <dalek> doc: Also correct a few other tidbits.

[07:36] <dalek> doc: review: https://github.com/perl6/doc/commit/e94ccc8d09

[07:36] <dalek> doc: b7cdcfe | RabidGravy++ | doc/Type/Proc.pod6:

[07:36] <dalek> doc: Merge pull request #937 from zostay/proc-command

[07:36] <dalek> doc: 

[07:36] <dalek> doc: Fix #913: Add documentation for shell and command

[07:36] <dalek> doc: review: https://github.com/perl6/doc/commit/b7cdcfe6fa

[07:42] *** _slade_ left
[07:45] *** wamba left
[07:48] *** dogbert17 left
[07:50] *** wamba joined
[07:56] *** mcmillhj joined
[07:59] *** sftp left
[07:59] *** sftp joined
[08:00] *** ocbtec joined
[08:01] *** mcmillhj left
[08:01] *** jonas1 joined
[08:05] *** rindolf left
[08:11] *** wamba left
[08:19] *** dakkar joined
[08:31] *** mcmillhj joined
[08:34] <brrt> perl6 at least is useful for teaching encryption: https://www.promptworks.com/blog/public-keys-in-perl-6

[08:36] *** mcmillhj left
[08:43] *** nadim_ joined
[08:44] *** eliasr joined
[08:45] *** woolfy joined
[08:47] *** mcmillhj joined
[08:53] *** mcmillhj left
[08:57] *** wamba joined
[09:04] *** rindolf joined
[09:06] *** mcmillhj joined
[09:06] *** canopus left
[09:11] *** mcmillhj left
[09:13] *** canopus joined
[09:15] *** g4 joined
[09:15] *** g4 left
[09:15] *** g4 joined
[09:22] *** inokenty left
[09:22] <dalek> doc: b101e5e | gfldex++ | doc/Type/List.pod6:

[09:22] <dalek> doc: remove doc for sub cross because ENOSPEC (issue #165 on roast)

[09:22] <dalek> doc: review: https://github.com/perl6/doc/commit/b101e5e439

[09:37] *** inokenty joined
[09:37] *** MorayJ joined
[09:39] <dalek> doc: 6e53106 | gfldex++ | doc/Type/Proc.pod6:

[09:39] <dalek> doc: fix typo

[09:39] <dalek> doc: review: https://github.com/perl6/doc/commit/6e53106305

[09:42] <tatata> can a function take a phaser as an argument?

[09:43] <gfldex> no, phasers are not objects you can get a hold of.

[09:43] <tatata> or any other synthactical elements

[09:43] <psch> labels can be arguments

[09:44] <tatata> I was wandering if it could be with some hackery, due to perl parsing himself

[09:45] <brrt> (let's reify phasers :-P)

[09:46] <timotimo> well, actually ...

[09:46] <gfldex> m: sub f(&p){ say 'foo'; ENTER = &p }; f({say 'bar'});

[09:46] <camelia> rakudo-moar d8309d: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Preceding context expects a term, but found infix = instead␤at <tmp>:1␤------> 3sub f(&p){ say 'foo'; ENTER =7⏏5 &p }; f({say 'bar'});␤»

[09:47] <gfldex> m: sub f(&p){ say 'foo'; ENTER &p }; f({say 'bar'});

[09:47] <camelia> rakudo-moar d8309d: OUTPUT«foo␤»

[09:47] <timotimo> a phaser is really just a little callable that gets installed in a specific slot

[09:47] <timotimo> that gives it the phasery meaning

[09:47] <gfldex> m: sub f(&p){ say 'foo'; ENTER p }; f({say 'bar'});

[09:47] <camelia> rakudo-moar d8309d: OUTPUT«bar␤foo␤»

[09:47] <timotimo> i think you can get the phasers out. you can't get phasers in after the fact, though

[09:47] <gfldex> m: sub f(&p){ dd ENTER p }; f({say 'bar'});

[09:47] <camelia> rakudo-moar d8309d: OUTPUT«bar␤Bool::True␤»

[09:48] <tatata> I am having some fan, so I was wondering if it was possible to implement something like:  for bla, bla, bla { when ("foo" or gotta LAST) { } }

[09:48] <gfldex> well, I think you can get them in but I would not wonder if there are odd bugs, because nobody did that before.

[09:48] <psch> m: sub f { }; BEGIN &f.add_phaser('ENTER', { say "hi" }); f() 

[09:48] <camelia> rakudo-moar d8309d: ( no output )

[09:49] <tatata> it should be possible with a macro, because i can when ("foo" or LAST {say "ciao";} )

[09:49] <psch> BEGIN is already to late or something

[09:49] <tatata> whell maybe no

[09:49] <psch> or maybe you need a nqp-levle codeobj, i'm not sure

[09:49] <timotimo> tatata: you can .rotor with :partial and then check if the tuple has only one argument; in that case you're on the last iteration

[09:49] <gfldex> ENTER and LEAVE can be emulated with .wrap

[09:49] <timotimo> thing is, you have to consume an additional value from the iterator to know if you've reached the end yet

[09:49] <timotimo> rotor does that for you

[09:50] <tatata> timotimo: yeah, true

[09:50] <tatata> cannot time travel with when

[09:52] <timotimo> rotor is one of the more amazing built-ins

[09:53] <tatata> agreed

[09:53] <tatata> but it fits a different paradigm, I think, from the phasers "comefrom" aura

[09:54] <tatata> like I would see it fit perfectly in the R programming language

[09:54] <tatata> when I do perl I like to program in "natural language mood"

[09:55] *** zakharyas left
[09:56] <timotimo> you could call it "comefrom aura", or you could be fancy and say "aspect oriented programming" :)

[10:08] *** pierre_ left
[10:09] *** pierre_ joined
[10:09] <tatata> comefrom is a funny name :)

[10:12] *** pierre_ left
[10:12] *** MorayJ left
[10:13] *** perlawhirl joined
[10:13] *** pierre_ joined
[10:14] <tatata> when macro will be implemented, will them be able to analyze the synthactic context where they are called? (thinking of AI driven AST generation)

[10:14] *** MorayJ joined
[10:14] <tatata> (sorry for my english)

[10:15] <timotimo> one use case for macros is checking "stuff", so it's probably a thing that'll be possible somehow

[10:17] *** pierre_ left
[10:25] *** aries_liuxueyang left
[10:26] *** aries_liuxueyang joined
[10:28] <firefish5000> I found most (I hope), of the lists I need to explicitly flatten now. Script now has run-time errors but debug output is a lot closer to the original. 

[10:30] <firefish5000> Calling it a night. Hopefully tomorrow my p6 instincts will kick in and I will get the last few kinks out of my code. Good night!

[10:30] <timotimo> gnite :)

[10:30] <RabidGravy> jnthn, did you ever get anywhere with that STOMP client you were making a while back?

[10:30] <RabidGravy> it's for a thing ;-)

[10:30] *** firefish5000 left
[10:33] <jnthn> RabidGravy: Haven't had chance to work on it for ages. But the client got to the point of being able to subscribe to queues, and it could send messages too

[10:33] <jnthn> Didn't really get anywhere far with the server

[10:33] <jnthn> https://github.com/jnthn/p6-stomp

[10:35] <RabidGravy> :) I'll take a look later, it seems to be what most people are using with ActiveMQ which is having a resurgence in popularity

[10:38] <RabidGravy> but it would be cool to make a message broker in Perl 6

[10:40] *** wamba left
[10:40] <jnthn> Yeah, that was kinda where I was going with the STOMP::Server :)

[10:41] <jnthn> But ended up too tired to work on it for a while, then got distracted doing Docker::File and HTTP::HPACK :)

[10:44] <stmuk_> "convo down the pub" type evidence has usually been anti-ActiveMQ

[10:45] <brrt> what is against it?

[10:45] <RabidGravy> yeah, I've never heard anyone say nice about it, but it's mostly a vague dislike rather than anything specific

[10:46] <brrt> oh okay

[10:46] *** pierre_ joined
[10:46] <stmuk_> I've just heard moans about it not working (just anecdotal) maybe it's been broken in the past or its just hard to config

[10:47] <RabidGravy> I think it's probably the first-generation opensource MQ broker thing, it's a bit "enterprisey" for some people :)

[10:47] <stmuk_> I'm sure its explained in the "white paper" or "webinar" :)

[10:48] <RabidGravy> I was also thinking about Tibco this morning for some reason, I must be sickening for something

[10:48] *** wamba joined
[10:49] <stmuk_> that's a name I've not heard this century

[10:50] <RabidGravy> I've worked with it twice this century

[10:50] *** labster left
[10:50] <stmuk_> wikipedia thinks its bacteria

[10:51] *** pierre_ left
[10:54] <RabidGravy> infact a Tibco management thingy was what got me into DB in the first place

[10:56] <stmuk_> maybe its use is affecting their share price :)

[10:56] *** ocbtec left
[10:58] *** ocbtec joined
[11:07] <DrForr> Ohhh, TIBCO. Fun times.

[11:08] <timotimo> .o( isn't that what emacs used to be built on ... :P )

[11:10] <stmuk_> haha

[11:10] <timotimo> that'd be teco, right?

[11:14] *** rindolf left
[11:20] *** rindolf joined
[11:23] *** brrt left
[11:26] *** brrt joined
[11:28] *** raoulvdberge joined
[11:30] *** user9 left
[11:30] *** user9 joined
[11:32] *** brrt left
[11:35] *** brrt joined
[11:43] *** rgrinberg joined
[12:04] *** itaipu joined
[12:18] *** Actualeyes1 joined
[12:18] *** Actualeyes left
[12:22] <masak> when I was on FreeDOS long ago, I was using an Emacs that ran on TECO or one of its variants.

[12:30] * timotimo watches the nixie tube manufacturing process video

[12:31] <pmurias> masak: what's the reason for using FreeDOS?

[12:32] <masak> long ago? curiosity, and some sort of fierce independence from commercial operating systems on the PC platform.

[12:42] <RabidGravy> yeah, I used to use FreeDOS too

[12:45] *** aries_liuxueyang left
[12:46] *** aries_liuxueyang joined
[12:46] <jonadab> I didn't know FreeDOS was that old.  I only found out about it years after switching to Linux, in the context of running DOS in an emulator to use old software.

[12:47] <jonadab> Must've been 2000 or later before I knew FreeDOS existed.

[12:48] <timotimo> i ... i've used dosbox in the past! ...

[12:49] <masak> dosbox is nice

[12:51] *** itaipu left
[12:51] *** wamba left
[12:54] *** lucasb_ joined
[12:57] <gfldex> m: sub bench(&c){ LEAVE now - (ENTER now); c }

[12:57] <camelia> rakudo-moar 7a50c3: OUTPUT«WARNINGS for <tmp>:␤Useless use of "-" in expression "now - (ENTER now)" in sink context (line 1)␤===SORRY!===␤Cannot reference undeclared local 'enter_result__1'␤»

[12:57] <gfldex> m: sub bench(&c){ LEAVE say now - (ENTER now); c }

[12:57] <camelia> rakudo-moar 7a50c3: OUTPUT«===SORRY!===␤Cannot reference undeclared local 'enter_result__1'␤»

[12:57] <gfldex> LTA or bug?

[12:57] <moritz> bug

[12:58] <lizmat> and already reported, afaik

[12:58] *** mcmillhj joined
[13:01] <lucasb_> RT 129801

[13:02] <gfldex> thanks to all of you :)

[13:02] * gfldex .oO( How many Perl 6-devs does it take to name a bug. )

[13:03] <timotimo> naming is one of the fundamental hard problems in compsci

[13:03] <RabidGravy> hmm there doesn't appear to be a module that wraps 'sendmail', I think that needs to be remedied

[13:03] <lizmat> .oO( what were they thinking calling it compsci :-)

[13:04] <RabidGravy> rjbs, fancy helping make an Email::Sender for P6?

[13:04] * masak .oO( what were they thinking calling it "naming"? )

[13:04] <RabidGravy> ... (WHAT?)

[13:05] <rjbs> RabidGravy: In theory, but I don't think I can responsibly make any time for it any time soon :(

[13:05] <rjbs> but I can at least answer any specific questions that might help

[13:07] <RabidGravy> please feel free to jump in on https://github.com/perl6/perl6-most-wanted/pull/34 :)

[13:09] <gfldex> m: my \l = gather loop { my $value = (42, "answer").roll; try { take $value.Int } }; my $start = now; say [+] l[^1000]; say now - $start;

[13:09] <camelia> rakudo-moar 7a50c3: OUTPUT«42000␤0.4023808␤»

[13:09] <gfldex> m: my \l = gather loop { my $value = (42, "answer").roll; take $value.Int if $value ~~ /^\d+$/ }; my $start = now; say [+] l[^1000]; say now - $start;

[13:09] <camelia> rakudo-moar 7a50c3: OUTPUT«42000␤0.0857317␤»

[13:09] <gfldex> m: my \l = gather loop { my $value = (42, 42, 42, 42, 42, "answer").roll; try { take $value.Int } }; my $start = now; say [+] l[^1000]; say now - $start;

[13:09] <camelia> rakudo-moar 7a50c3: OUTPUT«42000␤0.1372147␤»

[13:09] <gfldex> m: my \l = gather loop { my $value = (42, 42, 42, 42, 42, 42, 42, 42, 42, 42, "answer").roll; try { take $value.Int } }; my $start = now; say [+] l[^1000]; say now - $start;

[13:09] <camelia> rakudo-moar 7a50c3: OUTPUT«42000␤0.08890797␤»

[13:10] <gfldex> if it's very likely that .Int works, try { .Int } is much faster then the match. 

[13:11] <hackedNODE> .oO( premature optimization is the root of all evil )

[13:11] <gfldex> maybe promoting Range.is-int to Cool.is-int may provide a speed up in quite a few programs

[13:12] <lucasb_> I just run into this ticket about reduce with a single argument

[13:12] <timotimo> but is-int is only about "is this a range of ints"

[13:12] <timotimo> not "is this thing an int"

[13:12] <lucasb_> RT 128757 and 128758

[13:13] <lucasb_> I'm not sure I fully agree

[13:13] <psch> #128757 #128758

[13:13] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128757

[13:13] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128758

[13:13] <hackedNODE> psch++

[13:14] <lucasb_> when I say "[+] 'hi'", does reduce knows that the operator can be called as a unary?

[13:14] <lucasb_> I think this goes against the convention in other languages. but if it's perlish, then ok

[13:14] <brrt> no, reduce is always binary

[13:14] <psch> m: [&( $^a ~ $^b )] 'hello'

[13:14] <camelia> rakudo-moar 4e12d1: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Cannot use placeholder parameter $^a in the mainline␤at <tmp>:1␤------> 3[&( $^a7⏏5 ~ $^b )] 'hello'␤»

[13:15] <moritz> brrt: no

[13:15] <psch> m: [&({ $^a ~ $^b })] 'hello'

[13:15] <camelia> rakudo-moar 4e12d1: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3[&({ $^a ~ $^b })]7⏏5 'hello'␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        s…»

[13:15] <brrt> what

[13:15] <perlpilot> lucasb_: are you asking because ...

[13:15] <perlpilot> m: say [+] 5;

[13:15] <camelia> rakudo-moar 4e12d1: OUTPUT«5␤»

[13:15] <perlpilot> ?

[13:15] <brrt> (moritz: i'm curious)

[13:15] <moritz> m: say ([+]), ([*])

[13:15] <camelia> rakudo-moar 4e12d1: OUTPUT«01␤»

[13:15] <psch> eugh, forgot that syntax again :l

[13:15] <brrt> m: say [+] 5,6;

[13:15] <camelia> rakudo-moar 4e12d1: OUTPUT«11␤»

[13:15] <moritz> brrt: first of all it uses the nullary argument for default element

[13:15] <brrt> uhuh….

[13:16] <moritz> brrt: and then I think it doesn't call anything for the unary case

[13:16] <lucasb_> for example, in common lisp: (reduce #'+ '("hello"))  ;=> "hello"

[13:16] <moritz> that's useful for autovification

[13:16] <lucasb_> it doesn't raise an error, because there's only one argument

[13:16] <perlpilot> m: say [~] "hello";

[13:16] <camelia> rakudo-moar 4e12d1: OUTPUT«hello␤»

[13:16] <moritz> m: my %h; %h<a> *= 42; say %h

[13:16] <camelia> rakudo-moar 4e12d1: OUTPUT«{a => 42}␤»

[13:16] <moritz> m: my %h; %h<a> += 42; say %h

[13:16] <camelia> rakudo-moar 4e12d1: OUTPUT«{a => 42}␤»

[13:17] <lucasb_> "+" means { $^a + $^b }, but it also has its unary multi

[13:17] <moritz> how does it know that the default value for + is 0, and for * it's 1? by calling infix:<+>() and infix:<*>()

[13:17] <lucasb_> m: say reduce { $^a + $^b }, 'oh'

[13:17] <camelia> rakudo-moar 4e12d1: OUTPUT«oh␤»

[13:17] <brrt> okay, but I may have misparsed lucasb_'s question, which I thought was 'can the reduce op use unary +'

[13:17] <psch> m: say reduce { $^a + $^b }, ('oh',)

[13:17] <camelia> rakudo-moar 4e12d1: OUTPUT«oh␤»

[13:17] <moritz> reduce on a one-element list is a no-op

[13:17] <brrt> m: +'foo';

[13:17] <camelia> rakudo-moar 4e12d1: OUTPUT«WARNINGS for <tmp>:␤Useless use of "+" in expression "+'foo'" in sink context (line 1)␤Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5foo' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actu…»

[13:17] <brrt> m: say +'foo';

[13:17] <camelia> rakudo-moar 4e12d1: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5foo' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[13:18] <brrt> m: say +'42';

[13:18] <camelia> rakudo-moar 4e12d1: OUTPUT«42␤»

[13:18] <lucasb_> moritz: I wish it was a no-op, but it's not! it calls the unary multi

[13:18] <lucasb_> [+] 'hi'  # this raises an error

[13:18] <brrt> … and that, I find really surprising

[13:19] <moritz> lucasb_: I was takling about &reduce, not []

[13:19] *** gregf_ joined
[13:19] <moritz> m: say [+] 'foo'

[13:19] <camelia> rakudo-moar 4e12d1: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5foo' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[13:19] <lucasb_> moritz: I thought reduce and [+] meant the same thing

[13:19] <moritz> lucasb_: the don't

[13:20] <moritz> lucasb_: for example, [] is smarter about associativity

[13:20] <lucasb_> m: say reduce &infix:<+>, 'oh'

[13:20] <camelia> rakudo-moar 4e12d1: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5oh' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[13:20] <moritz> m: say [**] 2, 3, 3

[13:20] <camelia> rakudo-moar 4e12d1: OUTPUT«134217728␤»

[13:20] <moritz> m: say reduce &infix:<**>, 2, 3, 3

[13:20] <camelia> rakudo-moar 4e12d1: OUTPUT«134217728␤»

[13:20] <moritz> hrmpf

[13:20] <moritz> m: say [**] 2, 3, 4; say reduce &infix:<**>, 2, 3, 4

[13:20] <camelia> rakudo-moar 4e12d1: OUTPUT«2417851639229258349412352␤2417851639229258349412352␤»

[13:21] <moritz> ... or maybe I'm wrong

[13:21] <moritz> m: say (2**3)**4

[13:21] <camelia> rakudo-moar 4e12d1: OUTPUT«4096␤»

[13:21] <moritz> m: say 2**(3**4)

[13:21] <camelia> rakudo-moar 4e12d1: OUTPUT«2417851639229258349412352␤»

[13:21] <moritz> m: say reduce &infix:<+>, 'foo'

[13:21] <camelia> rakudo-moar 4e12d1: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5foo' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[13:22] <moritz> ok, they seem to be the same thing, and I was wrong all along

[13:23] <perlawhirl> moritz: it appears that reduce with a block does no-op on one-elem lists tho

[13:23] <perlawhirl> m: say ("hellow").reduce({ $^a + $^b })

[13:23] <camelia> rakudo-moar 4e12d1: OUTPUT«hellow␤»

[13:24] <psch> m: say ("foo",).reduce({ die $^a ~ $^b })

[13:24] <camelia> rakudo-moar 4e12d1: OUTPUT«foo␤»

[13:24] <psch> m: say ("foo",).reduce({ die $^a })

[13:24] <camelia> rakudo-moar 4e12d1: OUTPUT«foo␤  in block <unit> at <tmp> line 1␤␤»

[13:24] <moritz> m: say &infix:<+>('foo')

[13:24] <camelia> rakudo-moar 4e12d1: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5foo' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[13:24] <psch> well, at least it does an arity check

[13:24] <moritz> oh, that might be it

[13:25] <moritz> it might check if it can call the block with all the elements

[13:25] <psch> m: say ("foo",).reduce( -> $, $? { die })ell, 

[13:25] <camelia> rakudo-moar 4e12d1: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say ("foo",).reduce( -> $, $? { die })7⏏5ell,␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤    …»

[13:25] <moritz> and if yes, it does that

[13:25] <psch> m: say ("foo",).reduce( -> $, $? { die })

[13:25] <camelia> rakudo-moar 4e12d1: OUTPUT«Died␤  in block <unit> at <tmp> line 1␤␤»

[13:25] <lucasb_> my understanding is that P6 tries to be "smarter" about knowing when to call the 1-arg or 2-args multis

[13:25] *** skids joined
[13:25] <perlpilot> psch++ nice, clear examples

[13:25] <lucasb_> that was what surprised me

[13:25] <psch> (he said, right before the horribly butchered examples came)

[13:25] <moritz> and if not, it falls back to a 2ary reduce

[13:25] <lucasb_> but I can live with that :)

[13:25] <perlpilot> psch: I can take it back if you like :)

[13:26] <psch> perlpilot: i don't mind either way, honestly :)

[13:26] <perlpilot> psch++ you have the Perl mind  ;)

[13:27] *** seatek joined
[13:28] <lucasb_> soo... the conclusion is that it's intended to be this way, then?

[13:29] <psch> dunno, "reducer has wrong arity for reducee" kind of makes sense as an error, to me at least

[13:30] <psch> m: say <foo bar>.reduce({$^a ~ ": " ~ $^b ~ $^c})

[13:30] <camelia> rakudo-moar 4e12d1: OUTPUT«foo␤»

[13:30] <psch> the current behavior is somewhat weird in other edge cases apparently...

[13:30] <psch> i mean, reducing a 2 elem list with a 3ary function should either complain or give me the whole original list

[13:30] <psch> not just the first element

[13:31] <lucasb_> psch: yes, interesting example yours

[13:31] *** brrt left
[13:31] <pmurias> jnthn: is nqp::attrinited supposed to work on native attributes?

[13:32] *** rgrinberg1 joined
[13:32] *** perlawhirl left
[13:33] *** rgrinberg left
[13:33] <lizmat> pmurias: pretty sure it can't

[13:39] *** gregf_ left
[13:39] <lucasb_> m: https://gist.github.com/anonymous/ac4518ae1d13a9c1306ca6e66d2bfa05

[13:40] <camelia> rakudo-moar 4e12d1: OUTPUT«0␤1␤2␤2␤»

[13:40] <lucasb_> if the concept of reduce was extended to 1-ary operators, maybe it could be extended arbitrarily for N-ary operators. I think that would be the perlish way, maybe

[13:41] <jnthn> pmurias: no

[13:42] <lucasb_> oh, nevermind. maybe it doesn't make any sense :D

[13:43] <lucasb_> thanks everybody for the discussion

[13:44] *** leego joined
[13:47] *** gregf_ joined
[13:50] *** xinming left
[13:51] *** xinming joined
[13:52] *** acrussell joined
[13:56] *** grondilu joined
[13:57] *** gregf_ left
[13:57] <woolfy> Perl got a devroom at FOSEM!!!  I will send out requests for talk proposals in the near future.  Me happy.

[13:57] <grondilu> off-topic:  Latest numberphile video is pretty neat:  https://www.youtube.com/watch?v=4k1jegU4Wb4

[13:58] *** bjz_ left
[13:59] * masak .oO( we found a way to get rid of those pesky Developers! result: FOSEM )

[13:59] <grondilu> m: sub γ($n) { log($n) R- [+] 1 X/ 1..$n }(100).say

[13:59] <camelia> rakudo-moar 4e12d1: OUTPUT«0.582207331651531␤»

[13:59] <grondilu> m: sub γ($n) { log($n) R- [+] 1 X/ 1..$n }(1000).say

[13:59] <camelia> rakudo-moar 4e12d1: OUTPUT«0.577715581568208␤»

[14:00] <hackedNODE> woolfy++

[14:00] <tbrowder> good morning (US CDT) p6 people...

[14:00] <hackedNODE> m: sub { say "good $^time"

[14:00] <camelia> rakudo-moar 4e12d1: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3sub { say "good $^time"7⏏5<EOL>␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        statement modifier loop␤»

[14:01] <hackedNODE> I suck at cute greetings >_<

[14:01] <hackedNODE> m: sub { say "good $^time" }(<morning afternoon evening night prevening>.any)

[14:01] <camelia> rakudo-moar 4e12d1: OUTPUT«good morning␤good afternoon␤good evening␤good night␤good prevening␤»

[14:02] <woolfy> Masak: FOSDEM!  sORRY.

[14:02] <woolfy> Grr CapsLock... 

[14:03] <masak> no, I'm the one who's sorry :P

[14:03] *** mcmillhj left
[14:03] *** mcmillhj joined
[14:03] <masak> woolfy: anyway, excellent news that Perl got a devroom! :D

[14:05] <tbrowder>  i'm trying to clean up a p6 module for release and would like som advice on error handling. at tha moment i am mostly following the p 5 module i base it on and return with no value for most prblems. but i'm looking at our p6 Control::Bail and wonder if that is the way to go for most any problem with input arg errors or other problems with user data.

[14:07] <masak> tbrowder: something like `die "Argument 'floof' cannot be negative" if $floof < 0;` is what I do :)

[14:07] <tbrowder> i have added param constraints on many inputs and they cause an exception with a reasonable msg, but they are not alway appropriate.

[14:07] * hackedNODE uses  fail instead

[14:07] <masak> (though perhaps `unless` rather than `if` in the cases that makes the condition more natural. `unless` has the advantage that the condition gets stated in terms of what you want, not what you reject.)

[14:07] * perlpilot too

[14:08] <perlpilot> masak: why do you use die instead of fail?  

[14:08] <masak> I'm not a big fan of `fail` for some reason. I like early errors.

[14:08] <masak> perhaps because I'm not writing a lot of multithreaded stuff, where failure in one thread messes up the whole thing.

[14:08] <masak> "fail early" is just a thing I like. it helps me.

[14:09] <masak> I find that robust programs tend to be those that went through a lot of early failing until they found a balance in which all they accept is correct inputs.

[14:09] <masak> with `fail`, all I get is a disconnect between where the program started to go wrong and where the failure manifests.

[14:11] <hackedNODE> But where program started to go wrong would usually be some module author XYZ wrote.

[14:11] <hackedNODE> And "died in Some/Code/You/Never/HearOf.pm6" isn't too useful

[14:11] <perlpilot> it's useful for assigning blame :)

[14:11] <tbrowder> any difference to caller between fail and die? how about use of note and warn for advisories?

[14:12] <hackedNODE> m: sub foo { die "wat" }; sub bar { foo }; sub meow { bar }; meow

[14:12] <camelia> rakudo-moar 832764: OUTPUT«wat␤  in sub foo at <tmp> line 1␤  in sub bar at <tmp> line 1␤  in sub meow at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[14:12] <hackedNODE> Well, at least in Perl 6 you get a nice trace

[14:12] <perlpilot> tbrowder: fail is a value you can pass up the call chain, die is immediate program death.

[14:13] <tbrowder> okay, thanks

[14:13] *** khw joined
[14:16] <tbrowder> m: sub f {fail 'wat'}; sub b { f }; sub m {  b}; m

[14:16] <camelia> rakudo-moar 832764: OUTPUT«wat␤  in sub f at <tmp> line 1␤  in sub b at <tmp> line 1␤  in sub m at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[14:16] *** wamba joined
[14:19] <tbrowder> up to now i usually add "FATAL: msg..." to my die statements that i believe highlights the failure

[14:19] <pmurias> jnthn: thanks, nqp::attrinited was accidently working as != 0 on native int attributes on moar and got me confused ;)

[14:20] <hackedNODE> tbrowder: and failure is a value you can defuse

[14:21] <tbrowder> i've always thought the defaults for warn and die should be to prefix the msg with the name of the routine in caps

[14:21] <hackedNODE> m: sub f {fail 'wat'}; sub b { f }; sub m {  b}; m or say "something fishy in 'ere";

[14:21] <camelia> rakudo-moar 832764: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    or used at line 1␤␤»

[14:21] <hackedNODE> m: sub f {fail 'wat'}; sub b { f }; sub m {  b}; m() or say "something fishy in 'ere";

[14:21] <camelia> rakudo-moar 832764: OUTPUT«something fishy in 'ere␤»

[14:21] *** FROGGS joined
[14:22] <tbrowder> m: say 'something fishy'

[14:22] <camelia> rakudo-moar 832764: OUTPUT«something fishy␤»

[14:22] <FROGGS> o/

[14:22] <tbrowder> difference in msg?

[14:23] <hackedNODE> ?

[14:23] <tbrowder> never mind, not reading correctly...

[14:26] <jnthn> pmurias: oops :)

[14:26] *** acrussell left
[14:27] <tbrowder> thanks all, i will experiment a bit more with the view from the caller, but at the moment i think i will use fail.

[14:32] <tbrowder> break, break: i have found over the years my most-used p5 book was the cookbook. i would love to see a start of one on our docs. if the oreilly folks and the authors of the p5 cookbook approved, we could just start essentially a dup of its organization but substitute p6 solutions. one of the difference to me between the cookbook and other presentation is the

[14:32] <tbrowder> excellent organization of the topics and the laser view of typical use cases.

[14:33] <hackedNODE> Well, the best way to have that realized is to start it and see if anyone else joins the effort :)

[14:34] *** gregf__ joined
[14:34] <tbrowder> the problem to me is the license/permissions first before it could be started

[14:34] <tbrowder> otherwise i would start in

[14:34] <perlpilot> tbrowder: the cookbook is tchrist's baby, just ask him

[14:35] <tbrowder> anyone know him personally?

[14:37] <gfldex> i believe there is a Perl 6 cookbook already

[14:37] <tbrowder> where?

[14:37] <gfldex> http://search.cpan.org/~szabgab/Perl6-Cookbook-0.05/lib/Perl6/Cookbook.pm

[14:37] <gfldex> http://examples.perl6.org/categories/cookbook.html

[14:37] <tbrowder> if there

[14:37] <gfldex> http://szabgab.com/perl-6-cookbook.html

[14:38] <gfldex> the examples actually got content :)

[14:38] *** Actualeyes1 left
[14:38] *** ocbtec left
[14:38] *** jonas1 left
[14:38] *** RabidGravy left
[14:38] *** cyphase left
[14:38] *** Spot__ left
[14:38] *** lizmat left
[14:38] *** TimToady left
[14:38] *** stmuk_ left
[14:38] *** Dunearhp left
[14:38] *** dalek left
[14:38] *** Jonis left
[14:38] *** imcsk8 left
[14:38] *** ShimmerFairy left
[14:38] *** dataangel left
[14:38] *** buggable left
[14:38] *** imcsk8 joined
[14:38] *** Jonis joined
[14:39] *** TimToady joined
[14:39] *** jonas1 joined
[14:39] *** ocbtec joined
[14:39] *** hobbs joined
[14:39] *** buggable joined
[14:39] <gfldex> most of the examples are direct translations from Perl 5 and as a result not very 6-ish

[14:39] *** cyphase joined
[14:39] *** RabidGravy joined
[14:39] *** dataangel joined
[14:39] *** lizmat joined
[14:39] <gfldex> m: for dir('not-there') { try { .Int } }

[14:39] <camelia> rakudo-moar 832764: ( no output )

[14:39] *** hobbs left
[14:39] *** hobbs joined
[14:39] *** Actualeyes joined
[14:39] *** ShimmerFairy joined
[14:39] <gfldex> m: for dir('not-there') { .Int }

[14:39] <camelia> rakudo-moar 832764: OUTPUT«Failed to get the directory contents of '/home/camelia/not-there': Failed to open dir: 2␤  in any  at /home/camelia/rakudo-m-inst-1/share/perl6/runtime/CORE.setting.moarvm line 1␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <…»

[14:39] *** stmuk_ joined
[14:39] <gfldex> should the try inside the for block catch the exception thrown by dir?

[14:40] <lizmat> gfldex : I think so, this is one of those small but important differences between Perl 5 and Perl 6

[14:41] <lizmat> then again, I may be utterly wrong  :-)

[14:41] <hackedNODE> m: for dir('not-there') { .^name.say }

[14:41] <camelia> rakudo-moar 832764: OUTPUT«Failure␤»

[14:41] <gfldex> i did not expect it to do that and circumventing it will be rather tricky

[14:41] <tbrowder>  dang, i have seen that!! i'll look into it a bit more. if tcrist and oreilly dont have a problem, i would like it to be but in a more visible spot for ease of access and hopefully more support

[14:42] <hackedNODE> m: for die { try { } }

[14:42] <camelia> rakudo-moar 832764: OUTPUT«5===SORRY!5===␤Function 'die' needs parens to avoid gobbling block␤at <tmp>:1␤------> 3for die { try { } }7⏏5<EOL>␤Missing block (apparently claimed by 'die')␤at <tmp>:1␤------> 3for die { try { } }7⏏5<EOL>␤␤»

[14:42] <hackedNODE> m: for die() { try { } }

[14:42] <camelia> rakudo-moar 832764: OUTPUT«Died␤  in block <unit> at <tmp> line 1␤␤»

[14:42] <hackedNODE> So it's not catching. You get the failure, which explodes only when you call .Int

[14:42] *** Dunearhp joined
[14:43] <hackedNODE> m: for dir('not-there') { .sink; try { .Int } }

[14:43] <camelia> rakudo-moar 832764: OUTPUT«Failed to get the directory contents of '/home/camelia/not-there': Failed to open dir: 2␤  in any  at /home/camelia/rakudo-m-inst-1/share/perl6/runtime/CORE.setting.moarvm line 1␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <…»

[14:43] <lizmat> hmmm... I wonder whether it's some of my optimisations that caused this then

[14:44] <lizmat> perhaps we should disect it

[14:44] <gfldex> m: for dir('not-there') -> IO $_ { try { .Int } }

[14:44] <camelia> rakudo-moar 832764: OUTPUT«Earlier failure:␤ Failed to get the directory contents of '/home/camelia/not-there': Failed to open dir: 2␤  in any  at /home/camelia/rakudo-m-inst-1/share/perl6/runtime/CORE.setting.moarvm line 1␤  in block <unit> at <tmp> line 1␤␤Final error:…»

[14:44] *** erdic joined
[14:44] <hackedNODE> You mean the die() should be captured by try block inside the for block?

[14:44] <lizmat> *bisect

[14:45] <gfldex> lizmat: please poke me when you got a conclusion. I would like to doc that.

[14:47] *** wamba left
[14:48] <RabidGravy> jnthn, well I looked at the STOMP thing and ... https://github.com/jnthn/p6-stomp/pull/1

[14:48] <gfldex> i'm ok with that behaviour now. If a simple type check will catch it, it's easy enough to handle. And we should all type-check more often anyway, right?

[14:48] *** acrussell joined
[14:50] <seatek> Oh my gosh I love the "once" control flow keyword

[14:50] *** Spot__ joined
[14:51] <gfldex> seatek: did we doc what happens when one combines start and once?

[14:51] <seatek> gfldex, not in /language/control you didn't -- under once at least

[14:52] <seatek> gfldex, are there dragons there too?

[14:52] <lizmat> gfldex: would like to hear jnthn's view about this first  :-)

[14:52] <gfldex> i believe so, it should run the statement for the very first hit, not per thread

[14:52] <seatek> but that sounds really hard to do

[14:53] <seatek> but yes, otherwise it's another lie ;)

[14:53] <jnthn> RabidGravy: Commented, but also given you commit access :)

[14:53] *** khw left
[14:54] <jnthn> It doesn't do any concurrency control around the "is this the first hit", so there's a chance of a data race

[14:54] <seatek> it's not documented in /routine/start either

[14:56] *** neuraload left
[14:57] *** sufrostico left
[14:57] <gfldex> seatek: we did doc that already in /language/control

[14:58] *** _4d47 joined
[14:58] <seatek> did you just now put that in? was that there a minute ago?? ;)

[14:58] <RabidGravy> jnthn, :)

[14:59] <gfldex> jnthn: are phasers thread aware?

[15:00] <seatek> once would be incredibly useful being thread-safe. :) but then again, so would a lot of things.

[15:01] <lizmat> seatek: wrt to once, the question is really whether state variables are thread aware

[15:01] <lizmat> once is just sugar for conditionally executing something depending on a (hidden) state variable

[15:02] <seatek> i haven't looked into the multithread stuff at all yet, so i'm clueless

[15:04] <jnthn> gfldex: Every phaser has its own rules around what can trigger it, so it's not evan an applicable question in many cases. In some cases they decidedly are, for example LAST phasers in whenever blocks have the mutual exclusion properly enforced.

[15:04] <jnthn> gfldex: ENTER/LEAVE and related are per invocation record, and so threads don't even come into the question for those

[15:10] *** khw joined
[15:15] *** mcmillhj left
[15:16] *** mcmillhj joined
[15:16] <_4d47> m: [] ~~ Cool

[15:16] <camelia> rakudo-moar a48e7a: ( no output )

[15:17] <_4d47> m: say ([] ~~ Cool)

[15:17] <camelia> rakudo-moar a48e7a: OUTPUT«True␤»

[15:17] * gfldex .oO( Pretty much anything in Perl 6 is Cool )

[15:18] <hackedNODE> m: .say for now ~~ Cool, Date.today ~~ Cool

[15:18] <camelia> rakudo-moar a48e7a: OUTPUT«True␤False␤»

[15:18] <hackedNODE> m: say Perl ~~ Cool

[15:18] <camelia> rakudo-moar a48e7a: OUTPUT«False␤»

[15:18] <_4d47> I thought Cool was the base for numeric and strings but not composites

[15:18] <hackedNODE> haha

[15:18] <hackedNODE> _4d47: it's for stuff that can act as either string or number

[15:18] <_4d47> :-D

[15:20] <gfldex> m: say {} ~~ Cool

[15:20] <camelia> rakudo-moar a48e7a: OUTPUT«True␤»

[15:20] <gfldex> blocks are cool too :)

[15:20] <hackedNODE> That's a hash

[15:20] <hackedNODE> m: say {;} ~~ Cool

[15:20] <camelia> rakudo-moar a48e7a: OUTPUT«False␤»

[15:20] <gfldex> :(

[15:20] <hackedNODE> :)

[15:21] <gfldex> m: say Block ~~ Cool

[15:21] <camelia> rakudo-moar a48e7a: OUTPUT«False␤»

[15:21] <gfldex> m: say Callable ~~ Cool

[15:21] <camelia> rakudo-moar a48e7a: OUTPUT«True␤»

[15:24] <hackedNODE> m: say Callable.^pun ~~ Cool

[15:24] <camelia> rakudo-moar a48e7a: OUTPUT«False␤»

[15:24] <hackedNODE> m: say role {} ~~ Cool

[15:24] <camelia> rakudo-moar a48e7a: OUTPUT«True␤»

[15:24] <hackedNODE> Apparently roles are just that cool :)

[15:25] *** itaipu joined
[15:27] <hackedNODE> m: use MONKEY-GUTS; say nqp::istype(role {}, Cool)

[15:27] <camelia> rakudo-moar a48e7a: OUTPUT«1␤»

[15:27] <hackedNODE> m: use MONKEY-GUTS; say nqp::istype(role {}, Whatever)

[15:27] <camelia> rakudo-moar a48e7a: OUTPUT«0␤»

[15:27] <hackedNODE> inturemesting

[15:32] <_4d47> m: say [1,2] + { foo => 1, bar => 2 }

[15:32] <camelia> rakudo-moar 798c2e: OUTPUT«4␤»

[15:33] <_4d47> m: say [1,2] + { foo => 1, bar => 2 } + Callable

[15:33] <camelia> rakudo-moar 798c2e: OUTPUT«Use of uninitialized value of type Callable in numeric context␤  in block <unit> at <tmp> line 1␤4␤»

[15:36] *** abraxxa left
[15:39] *** donaldh joined
[15:41] *** domidumont left
[15:47] <hackedNODE> timotimo: you around? How to restart dalek?

[15:47] <timotimo> should be possible via systemd

[15:48] <timotimo> did it get stuck? that'd be new

[15:48] <geekosaur> on the wrong end of a netsplit

[15:48] <hackedNODE> I think it may be stuck somewhere in netslit land

[15:49] <timotimo> ah

[15:49] * hackedNODE runs sudo service dalek-irc restart

[15:49] <geekosaur> probably the server is still up but isolated

[15:51] <hackedNODE> doesn't seem to be working :/ even though I see the service go away then reappear

[15:51] <hackedNODE> s: &test

[15:51] <SourceBaby> hackedNODE, Something's wrong: ␤ERR: [31m===[0mSORRY![31m===[0m Error while compiling -e␤Undeclared routine:␤    test used at line 6␤␤

[15:52] <timotimo> does dalek log to journal? maybe you can tell what irc server it's connecting to from the output

[15:52] <timotimo> maybe it's just going onto the same server as before?

[15:53] *** g4 left
[15:55] <hackedNODE> Dunno if it's relevant: "Failed to set cpu.cfs_period_us on /system.slice/dalek-irc.service: Permission denied"

[15:55] <hackedNODE> Oh, I see it connecting now

[15:56] <hackedNODE> .oO( perlwhore.org ?? )

[15:56] <hackedNODE> write_fail: Network freenode lost connection: 'Broken pipe' will reconnect in 30 secs

[15:56] <hackedNODE> There you go. 

[15:56] *** yubimusubi is now known as Possum

[15:56] <seatek> it's all systemd's fault

[15:57] *** dalek joined
[15:57] *** ChanServ sets mode: +v dalek

[15:57] <hackedNODE> \o/

[15:57] <hackedNODE> timotimo++ thanks

[15:57] <timotimo> no problem

[15:58] *** solarbunny joined
[16:00] *** mcmillhj left
[16:03] *** domidumont joined
[16:07] *** khw left
[16:07] *** khw joined
[16:10] *** mcmillhj joined
[16:14] *** mcmillhj left
[16:20] *** ptolemarch joined
[16:24] *** mcmillhj joined
[16:28] *** lucasb_ left
[16:28] *** mcmillhj left
[16:30] <hackedNODE> DBD::mysql security advisory (if anyone uses it; I think our logs do): http://blogs.perl.org/users/mike_b/2016/10/security-release---buffer-overflow-in-dbdmysql-perl-library.html

[16:41] *** mcmillhj joined
[16:44] *** dakkar left
[16:46] *** mcmillhj left
[16:53] *** acrussell left
[17:00] *** sufrostico joined
[17:01] *** mcmillhj joined
[17:06] *** mcmillhj left
[17:06] *** wamba joined
[17:12] <dalek> doc: 1dd3004 | RabidGravy++ | doc/Type/List.pod6:

[17:12] <dalek> doc: Revert "remove doc for sub cross because ENOSPEC (issue #165 on roast)"

[17:12] <dalek> doc: 

[17:12] <dalek> doc: Have supplied some test for 'cross' and closed #165 on roast

[17:12] <dalek> doc: 

[17:12] <dalek> doc: This reverts commit b101e5e439838bda97d8201b340f5f165505ff5e.

[17:12] <dalek> doc: review: https://github.com/perl6/doc/commit/1dd3004d27

[17:12] *** mcmillhj joined
[17:13] *** gregf__ left
[17:17] *** ponbiki left
[17:33] *** hankache joined
[17:34] <seatek> m: say $*PERL.version

[17:34] <camelia> rakudo-moar 9ea23c: OUTPUT«v6.c␤»

[17:34] <seatek> m: say $*PERL.compiler.version

[17:34] <camelia> rakudo-moar 9ea23c: OUTPUT«v2016.09.134.g.9.ea.23.c.9␤»

[17:35] <hackedNODE> m: say $*VM.version

[17:35] <camelia> rakudo-moar 9ea23c: OUTPUT«v2016.09.13.g.34.c.375.a␤»

[17:35] <seatek> does rakudobrew always build thread support in?

[17:35] <hackedNODE> Yes

[17:35] <seatek> k

[17:40] *** donaldh left
[17:41] *** ocbtec left
[17:45] *** robertle joined
[17:47] <El_Che> RT. Submitting a bug breaks my heart

[17:50] <hackedNODE> You could join the efforts to add bug-submitting-ability to perl6.fail :)

[17:51] <hackedNODE> Well. Actually not yet :)

[17:55] <El_Che> while I have open the RT interface, let me open my mailclient, create an identity with a RT known mail, and copy paste everything in it

[17:56] *** _4d47 left
[18:02] *** andrzejku joined
[18:03] *** erdic left
[18:03] *** erdic joined
[18:08] *** itaipu left
[18:10] *** setty2 joined
[18:14] <El_Che> lizmat: sent you a bug ;)

[18:15] *** itaipu joined
[18:16] *** lucasb_ joined
[18:19] <dalek> doc: c2a94c5 | (Zoffix Znet)++ | doc/Language/testing.pod6:

[18:19] <dalek> doc: Clarify is()'s usecases

[18:19] <dalek> doc: review: https://github.com/perl6/doc/commit/c2a94c5c72

[18:23] <hackedNODE> Thinking of it more... `is` shouldn't even be in roast. We're supposed to precisely pin-point what values we expect, while is() is more of a convenience, where you don't care if you get an Int or a Str or an IntStr, for example

[18:24] <hackedNODE> (context: https://github.com/perl6/roast/commit/f9950fa2#commitcomment-19306069 )

[18:25] <hackedNODE> RabidGravy++

[18:26] <moritz> hackedNODE: I think that's quite an extreme stance

[18:26] <moritz> hackedNODE: for example, if the API documentation says a List is returned, any subclass of List is acceptable too, but is-deeply will reject it

[18:26] <psch> &is is fine for what it does, although it's somewhat unobvious that it stringifies

[18:27] <psch> although i guess the docs probably cover that

[18:28] *** Actualeyes left
[18:29] <hackedNODE> moritz: that means ImplementationX can return arrays and code can modify them, but ImplementationY can return Lists and that code will fail to run on that implementation, even though they both pass the spec.

[18:30] <hackedNODE> So the extremeness eliminates imprecisions that would make code interoperate poorly between compilers

[18:30] <hackedNODE> (and yes, this argument would be stronger if we had more than one compiler :P)

[18:32] <psch> m: use Test; is-deeply [1,2,3], (1,2,3)

[18:32] <camelia> rakudo-moar 9ea23c: OUTPUT«not ok 1 - ␤␤# Failed test at <tmp> line 1␤# expected: $(1, 2, 3)␤#      got: $[1, 2, 3]␤»

[18:32] <psch> m: use Test; is [1,2,3], (1,2,3)

[18:32] <camelia> rakudo-moar 9ea23c: OUTPUT«ok 1 - ␤»

[18:32] * psch hmms

[18:32] <timotimo> m: use Test; is [1,2,3], "1 2 3"

[18:32] <camelia> rakudo-moar 9ea23c: OUTPUT«ok 1 - ␤»

[18:32] <hackedNODE> m: use Test; is [1,("2",(3 but False)], (1,2,3)

[18:32] <camelia> rakudo-moar 9ea23c: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in parenthesized expression; couldn't find final ')' ␤at <tmp>:1␤------> 3use Test; is [1,("2",(3 but False)7⏏5], (1,2,3)␤    expecting any of:␤        statement end…»

[18:32] <hackedNODE> m: use Test; is [1,("2",(3 but False))], (1,2,3)

[18:32] <camelia> rakudo-moar 9ea23c: OUTPUT«ok 1 - ␤»

[18:33] *** girafe joined
[18:37] *** sjoshi joined
[18:40] <andrzejku> hey are there something like perl emacs?

[18:40] <timotimo> you mean like emacs but instead of lisp using perl?

[18:42] <lucasb_> https://github.com/hinrik/perl6-mode

[18:42] <lucasb_> if he meant perl6 mode for emacs...

[18:44] *** MilkmanDan left
[18:44] *** hankache left
[18:45] *** itaipu left
[18:46] *** hankache joined
[18:52] <lucasb_> m: say ~$_ given (*+2)

[18:52] <camelia> rakudo-moar 9ea23c: OUTPUT«WhateverCode object coerced to string (please use .gist or .perl to do that)␤  in block  at <tmp> line 1␤␤»

[18:52] <lucasb_> m: say (*+2).Str

[18:52] <camelia> rakudo-moar 9ea23c: OUTPUT«{ ... }␤»

[18:53] <lucasb_> why the message triggers in one case but not the other?

[18:53] <lucasb_> if I say (-> {}).Str or (sub {}).Str, then I get the message, but not with WhateverCode's

[18:54] <hackedNODE> m: put (*+2).Str

[18:54] <camelia> rakudo-moar 9ea23c: OUTPUT«WhateverCode object coerced to string (please use .gist or .perl to do that)␤  in block <unit> at <tmp> line 1␤␤»

[18:54] <hackedNODE> m: (*+2).Str

[18:54] <camelia> rakudo-moar 9ea23c: ( no output )

[18:54] <hackedNODE> m: ~$_ given *+2

[18:54] <camelia> rakudo-moar 9ea23c: OUTPUT«WARNINGS for <tmp>:␤Useless use of "~" in expression "~$_" in sink context (line 1)␤WhateverCode object coerced to string (please use .gist or .perl to do that)␤  in block  at <tmp> line 1␤»

[18:54] <hackedNODE> s: (*+2), 'Str', \()

[18:54] <SourceBaby> hackedNODE, Sauce is at https://github.com/rakudo/rakudo/blob/9ea23c9/src/core/Code.pm#L17

[18:54] <hackedNODE> huh

[18:55] <hackedNODE> m: my $v = *+2; $v.Str

[18:55] <camelia> rakudo-moar 9ea23c: OUTPUT«WhateverCode object coerced to string (please use .gist or .perl to do that)␤  in block <unit> at <tmp> line 1␤»

[18:56] <hackedNODE> Well, $5 it's an optimizer bug

[18:56] * hackedNODE tests

[18:56] <hackedNODE> nope :)

[18:56] <timotimo> do i get the $5?

[18:56] <lucasb_> oh... the ".Str" is part of the whatever code

[18:56] <lucasb_> that's why it doesn't trigger

[18:56] <hackedNODE> hm

[18:57] *** hankache left
[18:57] *** itaipu joined
[18:57] <hackedNODE> m: my $c = (*+2).Str; dd $c(1)

[18:57] <camelia> rakudo-moar 9ea23c: OUTPUT«"3"␤»

[18:57] <hackedNODE> lucasb_++ yup :)

[18:57] * hackedNODE sens lucasb_ a virtual $5

[18:59] <lucasb_> my $x = *+2; $x.Str  # this creates a boundary to test the stringification

[19:03] <lucasb_> m: sub f(--> 42) {}; say f

[19:03] <camelia> rakudo-moar 9ea23c: OUTPUT«42␤»

[19:03] <lucasb_> m: sub f() returns 42 {}; say f

[19:03] <camelia> rakudo-moar 9ea23c: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Malformed trait␤at <tmp>:1␤------> 3sub f() returns7⏏5 42 {}; say f␤»

[19:04] <hackedNODE> :)

[19:05] <lucasb_> idk if returning values this way is supposed to work

[19:05] <lucasb_> I just wanted to point the difference in behaviour

[19:07] <timotimo> it is

[19:07] <timotimo> i mean, it's supposed to work in general

[19:07] <timotimo> not sure about "returns a-value"

[19:13] *** buggable left
[19:13] *** buggable joined
[19:15] <seatek> The multi-line POD comments that attach to declared stuff is REALLY nice. It practically does all your documentation for you!

[19:15] <seatek> You've taken away ALL my excuses

[19:17] <FROGGS> m: sub f(--> 42) {}; say f

[19:17] <camelia> rakudo-moar 9ea23c: OUTPUT«42␤»

[19:18] <FROGGS> if that works, then 'returns 42' should work too, I guess

[19:21] <lucasb_> maybe these places should be limited to type object names only

[19:21] <lucasb_> if I put 42 there, it gives the impression that *any* expression there would work, which is not true

[19:22] <lucasb_> only simple expressions like ints, nums and strings work. anything other than that fails

[19:22] *** rgrinberg1 left
[19:24] *** rgrinberg joined
[19:26] <gfldex> m: sub anythingelse { say 'oi‽' }; subset S of Str where { anythingelse; True }; sub f( --> S) { Str }; f

[19:26] <camelia> rakudo-moar 9ea23c: OUTPUT«oi‽␤»

[19:27] <lucasb_> hehe, that was funny

[19:27] <lucasb_> I take back what I said :)

[19:32] *** mohae_ joined
[19:34] *** mohae left
[19:40] *** lucasb_ left
[19:43] <seatek> OK the automatic POD comment generation from being bound to declarations is a bit... vague

[19:43] *** domidumont left
[19:44] *** sjoshi left
[19:44] <seatek> Still though, wonderful

[19:46] <lizmat> El_Che: will look at the bug

[19:50] *** labster joined
[19:56] <robertle> seatek: sounds interesting, but I don't know what you are talking about. do you have a reference where I can start learning more about his? 

[19:57] <seatek> robertle, here is some stuff http://design.perl6.org/S26.html#Pod

[19:58] <seatek> robertle, you "block quote" with #|{  declarations here } and the p6doc will autgenerate some nice stuff related to the method and its signature

[20:00] *** itaipu left
[20:00] *** itaipu joined
[20:01] <robertle> I see, this could be leveraged for some nice IDE bits as well

[20:01] <seatek> The only reason I came to Perl6 was for block quotes. I can quote whole ranges of my code, and then it NEVER gets errors. It's like an evolution.

[20:01] <seatek> ;)

[20:02] <DrForr> I use them extensively too, in my case I mostly search for ` to find the tests that I've temporarily disabled, then re-enable the one by one.

[20:03] <DrForr> And right now I've come up with an idea for a grammar helper tool, but the margin of time alloted is too small to let me finish it :/

[20:05] <seatek> DrForr, who doles out your time? You need to make some more of that.

[20:07] <DrForr> Crap, Unicode doesn't have a Small Caps block. Otherwise I was going to do a Pratchett ref.

[20:08] <lizmat> DrForr: http://www.righto.com/2016/10/inspired-by-hn-comment-four-half-star.html

[20:09] <DrForr> Small caps are a rendering choice, not a glyph choice; I don't think it'd fly.

[20:10] *** ptolemarch left
[20:11] *** kaare_ left
[20:12] <gfldex> ¿ǝɹns noʎ ǝɹɐ :ɹɹoℲɹ◖

[20:14] *** mcmillhj left
[20:14] *** MilkmanDan joined
[20:15] *** cibs left
[20:15] <DrForr> I think that's meant to be a consequence of directionality, but I don't really have the patience right now to dig into the Unicode spec to look for the interpretation.

[20:16] *** cibs joined
[20:20] *** wtw_ is now known as wtw

[20:20] *** mcmillhj joined
[20:23] <El_Che> thx, lizmat 

[20:25] *** FROGGS left
[20:25] *** robertle left
[20:30] <El_Che> (it's not that I am not happy with the JSON errors :) ) 

[20:32] *** MorayJ left
[20:33] <RabidGravy> ha, https://toggl.com/programming-princess - cheers dha++

[20:38] *** rindolf left
[20:42] *** ponbiki joined
[20:42] *** dha joined
[20:43] *** ponbiki is now known as Guest62166

[20:46] <dalek> doc: 5418b0a | (Francis Grizzly Smit)++ | doc/Type/Int.pod6:

[20:46] <dalek> doc: aligned sub form with method form expmod

[20:46] <dalek> doc: review: https://github.com/perl6/doc/commit/5418b0ab23

[20:55] *** AlexDaniel joined
[20:55] <dalek> doc: e8d7ef7 | gfldex++ | doc/Type/Signature.pod6:

[20:55] <dalek> doc: fix links

[20:55] <dalek> doc: review: https://github.com/perl6/doc/commit/e8d7ef74a9

[21:04] *** skids left
[21:08] *** wamba left
[21:10] *** canopus left
[21:10] *** jcallen left
[21:10] *** dha left
[21:10] *** andrzejku left
[21:11] *** jcallen joined
[21:15] *** canopus joined
[21:16] *** dha joined
[21:33] *** Milan joined
[21:34] *** Milan left
[21:39] *** aries_liuxueyang left
[21:40] *** aries_liuxueyang joined
[21:51] *** cpage__ left
[21:51] *** itaipu left
[21:53] <dalek> doc: 92f7367 | gfldex++ | doc/Programs/00-running.pod6:

[21:53] <dalek> doc: say what -I and `use lib` acutally does

[21:53] <dalek> doc: review: https://github.com/perl6/doc/commit/92f7367f8a

[21:53] <dalek> doc: ed53481 | gfldex++ | doc/Language/modules.pod6:

[21:53] <dalek> doc: put `use lib` into the index

[21:53] <dalek> doc: review: https://github.com/perl6/doc/commit/ed53481329

[21:53] <dalek> doc: d7eaff2 | gfldex++ | doc/Language/faq.pod6:

[21:53] <dalek> doc: add ecosystem to the index

[21:53] <dalek> doc: review: https://github.com/perl6/doc/commit/d7eaff2f86

[21:53] <dalek> doc: 25fb68e | gfldex++ | doc/Language/modules.pod6:

[21:53] <dalek> doc: fix index entry for `use lib`

[21:53] <dalek> doc: review: https://github.com/perl6/doc/commit/25fb68e0e6

[21:59] *** mcmillhj left
[22:02] *** rgrinberg left
[22:04] *** pdcawley left
[22:07] *** pdcawley joined
[22:15] *** dha left
[22:16] *** skids joined
[22:18] *** cpage__ joined
[22:18] *** RabidGravy left
[22:29] *** _slade_ joined
[22:32] <tailgate> Is there a way to force a Seq to an Array?

[22:34] <lizmat> my @a = Seq.list ?

[22:38] <gfldex> m: my @a = list lazy gather for 1..100 { say 'hit'; .take }; say @a[10];

[22:38] <camelia> rakudo-moar 8023df: OUTPUT«hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤11␤»

[22:38] <gfldex> m: my @a = list gather for 1..100 { say 'hit'; .take }; say @a[10];

[22:38] <camelia> rakudo-moar 8023df: OUTPUT«hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit␤hit…»

[22:39] <gfldex> tailgate: please not that you may want to have `lazy` somewhere in the mix

[22:42] <cognominal> m: Buf $b; $b.elems; say $b.WHAT

[22:42] <camelia> rakudo-moar 8023df: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3Buf7⏏5 $b; $b.elems; say $b.WHAT␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤      …»

[22:42] <cognominal> m: my Buf $b; $b.elems; say $b.WHAT

[22:42] <camelia> rakudo-moar 8023df: OUTPUT«(Buf)␤»

[22:42] <cognominal> m: my Buf $b; say $b.elems; say $b.WHAT

[22:42] <camelia> rakudo-moar 8023df: OUTPUT«1␤(Buf)␤»

[22:42] <cognominal> m: my Buf[uint8] $b; say $b.elems; say $b.WHAT

[22:42] <camelia> rakudo-moar 8023df: OUTPUT«1␤Cannot unbox a type object␤  in block <unit> at <tmp> line 1␤␤»

[22:43] <cognominal> I would expect a Buf to start empty

[22:44] <cognominal> why .WHAT does not work for a explicit Buf[uint8]

[22:46] <geekosaur> m: my Buf[uint8] $b; dd $b

[22:46] <camelia> rakudo-moar 8023df: OUTPUT«Buf[uint8] $b = Buf[uint8]␤»

[22:46] *** wtw_ joined
[22:46] <cognominal> m: my Buf[uint8] $b;  say $b.^name

[22:46] <camelia> rakudo-moar 8023df: OUTPUT«Buf[uint8]␤»

[22:47] <geekosaur> Buf is a bit weird, and I am somehow thinking it is operating here at the wrong level (for example .elems saying "this is a scalar, return 1")

[22:47] *** wtw left
[22:47] <cognominal> m: my Buf[uint8] $b = Buf.new;  say +$b

[22:47] <camelia> rakudo-moar 8023df: OUTPUT«Type check failed in assignment to $b; expected Buf[uint8] but got Buf (Buf.new())␤  in block <unit> at <tmp> line 1␤␤»

[22:48] <cognominal> m: my Buf[uint8] $b = Buf[uint8].new;  say +$b

[22:48] <camelia> rakudo-moar 8023df: OUTPUT«0␤»

[22:48] <cognominal> m: my Buf[uint8] $b = Buf[uint8].new;  $b.push: 4; say +$b

[22:48] <camelia> rakudo-moar 8023df: OUTPUT«1␤»

[22:49] <cognominal> m: my Buf[uint8] $b = Buf[uint8].new;  $b.push: 4; say +$b; say $b[0]

[22:49] <camelia> rakudo-moar 8023df: OUTPUT«1␤4␤»

[22:49] *** lucasb_ joined
[22:49] <cognominal> m: my Buf $b = Buf.new;  $b.push: 4; say +$b; say $b[0]

[22:49] <camelia> rakudo-moar 8023df: OUTPUT«1␤4␤»

[22:50] <cognominal> m: my Buf $b; say +$b;  say $b[0]

[22:50] <camelia> rakudo-moar 8023df: OUTPUT«Use of uninitialized value of type Buf in numeric context␤  in block <unit> at <tmp> line 1␤0␤(Any)␤»

[22:50] <cognominal> m: my Buf[uint8] $b; say +$b;  say $b[0]

[22:50] <camelia> rakudo-moar 8023df: OUTPUT«Use of uninitialized value of type Buf[uint8] in numeric context␤  in block <unit> at <tmp> line 1␤0␤(Any)␤»

[22:50] <cognominal> m: my Buf[uint8] $b; say +$b;  

[22:50] <camelia> rakudo-moar 8023df: OUTPUT«Use of uninitialized value of type Buf[uint8] in numeric context␤  in block <unit> at <tmp> line 1␤0␤»

[22:50] <cognominal> m: my Buf $b; say +$b;  

[22:50] <camelia> rakudo-moar 8023df: OUTPUT«Use of uninitialized value of type Buf in numeric context␤  in block <unit> at <tmp> line 1␤0␤»

[22:51] <cognominal> m: my Buf $b; say $b.elems;  

[22:51] <camelia> rakudo-moar 338a70: OUTPUT«1␤»

[22:52] <lucasb_> timotimo: still around? just wanted to say I really liked your answer about multithread and GC on the mailing list! it's awesome to learn stuff from all of you on the P6 community

[22:53] <cognominal> ho, I forgot that Buf $b starts as a Buf:U

[22:53] <cognominal> ... lack of practice

[23:00] *** perlawhirl joined
[23:04] <timotimo> lucasb_: i'm here. you're welcome :)

[23:11] *** girafe left
[23:12] *** pmurias left
[23:17] *** larion left
[23:19] *** larion joined
[23:23] *** breinbaas joined
[23:28] *** DrParis left
[23:32] *** DrParis joined
[23:39] *** breinbaas left
[23:39] *** larion left
[23:40] *** larion joined
[23:44] *** breinbaas joined
[23:53] *** nightfrog joined
