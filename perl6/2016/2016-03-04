[00:00] *** AlexDaniel joined
[00:00] <AlexDaniel> m: say ‘l​̦’.uninames

[00:00] <camelia> rakudo-moar 855de7: OUTPUT«(LATIN SMALL LETTER L ZERO WIDTH SPACE COMBINING COMMA BELOW)␤»

[00:00] *** themonkeybob11 left
[00:00] <AlexDaniel> m: .say for ‘l​̦’.uninames

[00:00] <camelia> rakudo-moar 855de7: OUTPUT«LATIN SMALL LETTER L␤ZERO WIDTH SPACE␤COMBINING COMMA BELOW␤»

[00:01] <AlexDaniel> right, so there is a zero width space, hmm

[00:01] <AlexDaniel> star: .say for ‘l​̦’.uninames

[00:01] <camelia> star-m 2015.09: OUTPUT«LATIN SMALL LETTER L␤ZERO WIDTH SPACE␤»

[00:01] <tweakism> AlexDaniel: plane 1 which you included has some stuff.  plane 2 does too but it's all CJK so irrelevant for me.  3-13 are completely empty.  15 and 16 are PUA, so not interesting if you're looking at e.g. char names.

[00:02] <tweakism> AlexDaniel: so, 0x1ffff was pretty perfect.

[00:02] <AlexDaniel> tweakism: :)

[00:02] <AlexDaniel> tweakism: once perl 6 gets much faster I'm sure there would be no problem grepping through everything :)

[00:02] <tweakism> oh, 14 has the variation selectors :)

[00:03] <AlexDaniel> though it would be much better if somebody made a module that would do proper lookups

[00:03] <tweakism> that does not look like latin small letter l to me

[00:04] <AlexDaniel> tweakism: * is a whatever star

[00:04] <AlexDaniel> tweakism: and .NFD is just a method call on it

[00:05] <AlexDaniel> m: say <2 5 8>.map(* + 2)

[00:05] <camelia> rakudo-moar 855de7: OUTPUT«(4 7 10)␤»

[00:05] <tweakism> heh that is so cool

[00:05] <AlexDaniel> m: say <2 5 8>.map(*.succ)

[00:05] <camelia> rakudo-moar 855de7: OUTPUT«(3 6 9)␤»

[00:05] <AlexDaniel> m: say <2 5 8>.map(*.pred)

[00:05] <camelia> rakudo-moar 855de7: OUTPUT«(1 4 7)␤»

[00:05] <AlexDaniel> you can also write it like this if you want

[00:05] <AlexDaniel> m: say <2 5 8>.map({$_.pred})

[00:05] <camelia> rakudo-moar 855de7: OUTPUT«(1 4 7)␤»

[00:06] <AlexDaniel> m: say <2 5 8>.map({.pred}) # but this is a bit shorter

[00:06] <camelia> rakudo-moar 855de7: OUTPUT«(1 4 7)␤»

[00:06] *** firstdayonthejob left
[00:06] <tweakism> ha, if you call a method on nothing does it use $_ ?

[00:06] <AlexDaniel> m: say <2 5 8>».pred # but this is a bit shorter

[00:06] <camelia> rakudo-moar 855de7: OUTPUT«(1 4 7)␤»

[00:06] <AlexDaniel> tweakism: yeah

[00:07] *** azawawi joined
[00:07] <azawawi> hi

[00:07] <azawawi> good & early morning #perl6 :)

[00:07] <azawawi> sortiz: ping

[00:07] <AlexDaniel> tweakism: it kinda solves the problem of Perl 5 where some functions work on $_ by default (which is great) but most things are doing that inconsistently (which is bad)

[00:08] *** themonkeybob11 joined
[00:08] <tweakism> that's the kind of feature people don't like

[00:08] <tweakism> and it's sad

[00:08] <tweakism> 'cause they can be as explicit as they like in code they want to release

[00:09] <AlexDaniel> tweakism: dot is very explicit :)

[00:09] <tweakism> and still have that available for a one-liner in the shell or editor

[00:09] <AlexDaniel> it is just short

[00:09] <tweakism> but I guess if the syntax exists people will use it, so you have to know it regardless

[00:09] *** spider-mario left
[00:09] *** LGD joined
[00:10] <AlexDaniel> m: .say for <2 5 8>; for <2 5 8> -> $curInt { say $curInt }

[00:10] <camelia> rakudo-moar 855de7: OUTPUT«2␤5␤8␤2␤5␤8␤»

[00:11] <AlexDaniel> If I was going to pick one that is the most readable, hmm… I think that I'd go with the first one :)

[00:11] <tweakism> I was just talking about $_

[00:11] <AlexDaniel> m: $_.say for <2 5 8>; for <2 5 8> -> $curInt { say $curInt }

[00:11] <camelia> rakudo-moar 855de7: OUTPUT«2␤5␤8␤2␤5␤8␤»

[00:13] *** jjido left
[00:14] *** jjido joined
[00:14] *** themonke1bob11 joined
[00:15] *** themonkeybob11 left
[00:18] *** jjido left
[00:23] <azawawi> any better shorter form than `say sprintf("%s", some-str)`... like printf in c but with newline?

[00:23] <timotimo> there's also .fmt which might sometimes help

[00:24] *** themonke1bob11 left
[00:25] <AlexDaniel> azawawi: you mean that including \n in the pattern is too annoying?

[00:25] <azawawi> no i mean say sprintf part is annoying

[00:25] <timotimo> oh, i think he wants a combined say and format-string

[00:25] <azawawi> in Java  for example we can System.out.format(...)

[00:25] <AlexDaniel> azawawi: why not use printf then?

[00:26] <timotimo> m: printf("%s", "heyo")

[00:26] <camelia> rakudo-moar 855de7: OUTPUT«heyo»

[00:26] <timotimo> i didn't even know that %)

[00:26] <AlexDaniel> O_o

[00:27] <azawawi> me too

[00:27] <azawawi> aha!

[00:27] <azawawi> http://doc.perl6.org/routine/sprintf

[00:27] <timotimo> but you didn't even try :)

[00:27] <azawawi> http://doc.perl6.org/routine/printf  # 404!

[00:27] <timotimo> well, i'll be damned

[00:27] <azawawi> timotimo: i read documentation :)

[00:27] <AlexDaniel> azawawi: fair enough

[00:29] <AlexDaniel> azawawi: https://github.com/perl6/doc/issues/407 done, I fixed it.

[00:29] <AlexDaniel> if submitting a bug report counts as a fix :D

[00:30] <AlexDaniel> (it doesn't)

[00:30] <azawawi> hehe

[00:31] * azawawi clones perl6 doc repo :)

[00:32] <AlexDaniel> hmm, it looks like nobody is working on docs consistently

[00:32] <AlexDaniel> that's why it has 68 open issues, I guess

[00:33] * AlexDaniel looks at azawawi

[00:35] <azawawi> AlexDaniel: i just wrote `is memoized`... Maybe `is TODO` is needed :)

[00:35] <AlexDaniel> azawawi: ( ͡° ͜ʖ ͡°)

[00:36] <azawawi> http://doc.perl6.org/routine/is%20pure  # now back to the thing that spawned the sprintf/printf discussion :)

[00:36] <azawawi> i recall yesterday that sortiz was asking whether `is memoized` should mean also `is pure`

[00:37] <azawawi> by default that is

[00:37] <Hotkeys> did the 'is cached' trait change to 'is memoized'?

[00:37] <AlexDaniel> I didn't get it as well

[00:37] <azawawi> fyi, `is memoized` is like `is cached` but with cache size, cache eviction controls

[00:37] <Hotkeys> ah

[00:37] <azawawi> Hotkeys: https://github.com/azawawi/perl6-memoize

[00:38] <AlexDaniel> can't we add that to ｢is cached｣? Hmm…

[00:38] <AlexDaniel> or why would one use ｢is cached｣ when he can use ｢is memoized｣?

[00:38] <azawawi> AlexDaniel: `is cached` is marked as experimental

[00:38] <AlexDaniel> besides one being built-in and another one not

[00:39] <AlexDaniel> it was marked as experimental just because it was a bit buggy

[00:39] <azawawi> i looked at `is pure` and i dont understand "Marks a subroutine as pure, that is, it asserts that for the same input"

[00:40] <Hotkeys> if the subroutine doesn't access anything outside the function it's pure

[00:40] <Hotkeys> essentially

[00:40] <AlexDaniel> azawawi: https://en.wikipedia.org/wiki/Pure_function

[00:40] <azawawi> the assertion part im not seeing so far. Is that intented or am i missing something or do i need morning coffee? :)

[00:41] <AlexDaniel> ah

[00:42] <AlexDaniel> does it even have any effect right now?

[00:42] <AlexDaniel> I've always thought that it is kinda NYI

[00:42] <AlexDaniel> I mean “This is a hint to the compiler” part

[00:42] <azawawi> well im not seeing it so far after trying it... i remember jnthn saying it is not doing that yesterday

[00:43] *** tardisx left
[00:43] <azawawi> http://irclog.perlgeek.de/perl6/2016-03-02#i_12129251

[00:43] <azawawi> "...is pure doesn't actually check anything", jnthn 

[00:43] *** tardisx joined
[00:44] <AlexDaniel> right, because you decide that it is pure

[00:44] <AlexDaniel> … even if it is not :)

[00:44] <azawawi> so if it doesnt check anything... what's the purpose of `is pure`

[00:44] <AlexDaniel> azawawi: faster code

[00:44] <azawawi> explain im not following

[00:44] <Hotkeys> basically

[00:45] <Hotkeys> the compiler can precalculate the function into a constant

[00:45] <Hotkeys> if it has all the arguments at compile time

[00:45] <Hotkeys> is pure tells the compiler that the function only needs its input variables for whatever it's doing

[00:46] <Hotkeys> and the function doesn't have any side effects

[00:46] <AlexDaniel> m: sub foo is pure { $^a + $^b }; say foo(2,10) # replace this

[00:46] <camelia> rakudo-moar 855de7: OUTPUT«12␤»

[00:46] <AlexDaniel> m: say 12 # with this

[00:46] <camelia> rakudo-moar 855de7: OUTPUT«12␤»

[00:48] <azawawi> cool... then where is the assertion part?

[00:48] <AlexDaniel> .oO( in the docs… )

[00:48] <azawawi> "Marks a subroutine as pure, that is, it asserts that for the same input...", http://doc.perl6.org/routine/is%20pure

[00:49] <AlexDaniel> azawawi: feel free to rephrase it

[00:49] <azawawi> so it asserts on the docs, not on compile time and neither runtime? :)

[00:49] <azawawi> doc time :)

[00:49] <tweakism> it's just the dictionary-definition of assert, rather than what a coder thinks when they hear assert()

[00:50] <tweakism> to assert something is to claim it is true

[00:50] <tweakism> to state it as fact

[00:50] <AlexDaniel> tweakism: still it has to be changed :)

[00:50] <AlexDaniel> if one got it wrong then another thousand will do the same

[00:50] <azawawi> it is misleading though

[00:51] *** perlpilot_ joined
[00:51] <tweakism> *shrug*

[00:51] <tweakism> to assert, v., doesn't mean 

[00:51] <tweakism> 'cause to fail if it isn't true'

[00:51] <azawawi> tweakism: because the Perl 6 audience are programmers, so assert = ASSERT :)

[00:52] <AlexDaniel> Hotkeys: I wonder if doing ｢sleep ∞｣ will freeze the compilation process :)

[00:52] <azawawi> tweakism: i have spent like 5 min trying to make it trigger an assertion based on the documentation

[00:52] <Hotkeys> AlexDaniel: *shrug*

[00:53] <AlexDaniel> m: sleep ∞

[00:53] <Hotkeys> When I read 'assert' I read it normally

[00:53] <tweakism> Hotkeys: define normally

[00:53] <camelia> rakudo-moar 855de7: OUTPUT«(timeout)»

[00:53] <Hotkeys> Which is why I didn't understand the confusion

[00:53] <Hotkeys> tweakism: er

[00:53] <AlexDaniel> m: sleep NaN

[00:53] <camelia> rakudo-moar 855de7: ( no output )

[00:53] <Hotkeys> in the non-programming sense

[00:54] <AlexDaniel> m: sleep -∞

[00:54] <camelia> rakudo-moar 855de7: ( no output )

[00:54] *** perlpilot left
[00:54] <azawawi> but it is interesting that i can add an `is memoized(:pure)` for debugging reasons

[00:54] <AlexDaniel> .oO( your definition of “normally” is wrong )

[00:55] <Hotkeys> shh

[00:55] <tweakism> I started to ask, if it occurred to you that the compiler couldn't possibly ever verify "or the same input, it will always produce the same output without any additional side effects", but I suppose it could for some functions.

[00:55] *** Celelibi left
[00:56] <AlexDaniel> tweakism: once we manage to get AI into Perl 6 sure we could do that… :)

[00:56] <azawawi> given im already caching results in `is memoized`, I can disable cache hits to verify a routine's pure-ness to check for unpure routines

[00:57] <Hotkeys> I feel like if you mark a function 'is cached/memoized' you're also implying that it's pure anyway

[00:58] <azawawi> Hotkeys: but im not asserting

[00:58] <azawawi> Hotkeys: or failing on different results given infinite cache limits

[00:58] <AlexDaniel> Hotkeys: *shrug* why are you so sure? :)

[00:59] <Hotkeys> Because if it uses the cached results that's effectively returning the same output for a given input each time

[00:59] <Hotkeys> right?

[01:00] <AlexDaniel> Hotkeys: but does it mean that you can do that in compile time?

[01:00] * azawawi reads https://en.wikipedia.org/wiki/Pure_function#Impure_functions

[01:00] <tweakism> Hotkeys: I dunno, can cached entries be expired ever?

[01:01] <partly_> Found bug in usage generation here https://github.com/rakudo/rakudo/blob/bb2953c9412befbf176071cdb9505ee83a8dec8b/src/core/Main.pm#L73 

[01:01] <partly_> this fails if you have a sub f(\foo) {}

[01:01] <AlexDaniel> tweakism: I think that the idea of “is cached” was that yeah, if e.g. the cache is too large

[01:01] <partly_> it will echo <oo> instead of foo

[01:02] <Hotkeys> Actually I suppose a memoized function can't be a pure function really

[01:02] <Hotkeys> because memoization requires side effects

[01:02] <AlexDaniel> so you shouldn't rely on compiler that it will call it only once

[01:02] *** Celelibi joined
[01:03] <partly_> sorry L79

[01:03] <azawawi> AlexDaniel: `is memoized(:cache_size(10), :strategy("LRU"))` is already implemented but not as efficient as needed on the cache eviction part

[01:03] <tweakism> I probably don't understand the context, but it seems weird to me to give is-memoized as a compiler hint, vs. a directive to the compiler to memoize.

[01:03] *** BenGoldberg joined
[01:04] <Hotkeys> is cached in its basest form is just a wrapper on a function that caches the values

[01:04] <Hotkeys> I assume in practice it's more exciting than that

[01:04] <Hotkeys> but I don't think it's a compiler hint

[01:04] <AlexDaniel> I am pretty sure it was supposed to be a compiler hint

[01:05] <tweakism> Hotkeys: so then, the function can be pure, but the wrapped version is memoized (and impure), right? :)

[01:05] <Hotkeys> seems right

[01:06] <tweakism> and even if memoized can't imply pure, pure should definitely imply memoizable :)

[01:07] <Hotkeys> right

[01:07] <tweakism> but I'll stop now 'cause I'm far out of my league.

[01:07] <BenGoldberg> If the original function was pure, the memoized/wrapped version will *seem* pure, since the only side effect is that the value is stored in a cache, which is an effect which should be mostly invisible.

[01:07] <Hotkeys> mhm

[01:09] <sortiz> Hi

[01:09] <Hotkeys> it doesn't really make sense for the underlying function to be impure though wrt side effects

[01:10] <Hotkeys> because they'd only get called once

[01:10] <AlexDaniel> m: say ‘me’ ZZZ ‘bed’

[01:10] <camelia> rakudo-moar 855de7: OUTPUT«((((me bed))))␤»

[01:10] <Hotkeys> m: use experimental :cached; sub foo is cached { say $^a; return $a*2; }; say foo(3); say foo(3);

[01:10] <camelia> rakudo-moar 855de7: OUTPUT«3␤6␤6␤»

[01:10] <AlexDaniel> o/

[01:10] <Hotkeys> so I guess maybe if you only wanted side effects one time

[01:10] <azawawi> BenGoldberg: true but if we disable cache hits optimization and check cache hits vs real results for f(x), we can verify `is memoized(:pure)` as a debugging aid given no cache limit like `is cached`

[01:12] <azawawi> sortiz: Hi. I am following up on our previous discussion on `is pure`

[01:12] <sortiz> My argument was: 'is pure' is an assertion given _to_ the compiler.

[01:13] *** tardisx left
[01:13] <azawawi> sortiz: an assertion that causes a warning or a failure or nothing?

[01:13] <sortiz> And the implementations of 'is memoized' (and 'is cached' btw) guaranty  (by definition) the 'pureness' of the function.

[01:14] *** themonkeybob11 joined
[01:15] *** AlexDaniel left
[01:15] <azawawi> sortiz: that i would have to disagree with your once a cache eviction strategy is in place with a cache limit in `is memoized`

[01:15] *** jjido joined
[01:15] <sortiz> 'assertion' in this context is only a hint to the compiler that the code can be optimized, for example in-lining as a constant the result of a previous invocation with the same arguments.

[01:15] <azawawi> sortiz: given infinite cache, definitely

[01:16] <azawawi> sortiz: ok cool. got it :)

[01:16] <skids> In other words you can tell Perl 6 that your function is pure.  If you are wrong, you cannot blame Perl 6 for doing strange things with it.

[01:16] <sortiz> Exactly.

[01:18] <sortiz> If you say: sub foo($a) ( rand * $a ) is 'pure'; you are lying!!

[01:19] *** themonkeybob11 left
[01:19] <BenGoldberg> m: sub fibo(Int $n) is 'pure' { return 1 if $n <= 1; return fibo($n-2) + fibo($n-1) }; print fibo(3);

[01:19] <camelia> rakudo-moar 855de7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/RdIk0QuLuF␤Invalid name␤at /tmp/RdIk0QuLuF:1␤------> 3sub fibo(Int $n) is7⏏5 'pure' { return 1 if $n <= 1; return fi␤»

[01:19] <BenGoldberg> m: sub fibo(Int $n) is pure { return 1 if $n <= 1; return fibo($n-2) + fibo($n-1) }; print fibo(3);

[01:19] <camelia> rakudo-moar 855de7: OUTPUT«3»

[01:19] <Hotkeys> m: sub foo is pure { rand * $^a }; say foo(1); sleep 3; say foo(1);

[01:19] <camelia> rakudo-moar 855de7: OUTPUT«0.043510238412021␤0.966698664738955␤»

[01:19] <Hotkeys> smart

[01:19] *** Actualeyes joined
[01:19] <Hotkeys> it knows

[01:20] <BenGoldberg> No, it just doesn't do anything with "is pure", yet.  It's not implemented, except for the fact that it doesn't produce an error.

[01:20] <azawawi> sortiz: please take a look at this http://irclog.perlgeek.de/perl6/2016-03-04#i_12135535

[01:21] <Hotkeys> BenGoldberg: o

[01:23] *** yeahnoob joined
[01:24] *** Timbus left
[01:25] *** Timbus joined
[01:31] <sortiz> Its clear that the compiler can't check (in the general case) the pureness of a function, eventually the compiler can be able to detect _some_ pure functions. 

[01:32] <azawawi> sortiz: e.g. random(), time()... 

[01:32] *** tardisx joined
[01:32] *** grondilu joined
[01:33] <azawawi> sortiz: so basically it is a placeholder atm for future impure function warnings

[01:33] <azawawi> sortiz: s/function/routine/

[01:35] <sortiz> azawawi, yes. And I expect that nobody uses 'is memoize' in functions known to be impure :) Can't make sense.

[01:37] <azawawi> sortiz: so how does one imply that a trait does another trait? :)

[01:38] <TimToady> m: sub foo is pure { rand * $^a }; say foo(1) for 1..5;

[01:38] <camelia> rakudo-moar 855de7: OUTPUT«0.359642720821363␤0.359642720821363␤0.359642720821363␤0.359642720821363␤0.359642720821363␤»

[01:39] * skids missed the distinction between "is memoized" and "is cached"

[01:40] <azawawi> skids: https://github.com/azawawi/perl6-memoize/blob/master/examples/01-hello.pl6#L8

[01:41] <azawawi> skids: cache limits, cache eviction, debugging :)

[01:41] <skids> Ah.  Module space.  OK.

[01:42] <sortiz> I think that your trait can check that the function is already marked with 'is pure' and, if not, apply it.

[01:42] <skids> It would make sense to use an impure function if you are utilizing the caching behavior for side effects.

[01:42] <azawawi> skids: That's the thing I was worried about when I started the discussion. I am sorry for not being clear about the context :)

[01:43] *** tardisx left
[01:43] <TimToady> m: sub foo is pure { rand * $^a }; foo(1)

[01:43] <camelia> rakudo-moar 855de7: OUTPUT«WARNINGS for /tmp/O6l2SrqXJ1:␤Useless use of "foo(1)" in expression "foo(1)" in sink context (line 1)␤»

[01:44] <TimToady> constant folding and warnings are the two primary uses of 'pure' currently

[01:45] <sortiz> skids, Give me an example of side effects caused by the caching. It is the caching that, in the last instance, turns your impure function into a pure one.

[01:46] <tweakism> I think is just meant, the effect of inserting a record into the cache.  which while technically a side-effect, could/should probably be ignored.

[01:46] <TimToady> .o(caching has the side effects of using less electricity but more memory)

[01:47] <tweakism> or, I think what skids meant, is using the caching behavior to ensure that any side effects only happen on the first invocation.

[01:47] <tweakism> which seems like a terrible abuse :)

[01:47] <skids> Assumig a LRU cache eviction strategy was known to be the case, you could use the caching to implement per-value flow control, for example.

[01:49] *** jjido left
[01:49] <skids> tweakism: that or happen less often than the value happens the more common the value is, assuming eviction.

[01:50] <sortiz> Can be, but in the first place the term 'memoize' has already a well defined semantic, outside cache strategies.

[01:50] <azawawi> sortiz: so basically in my module, if `is memoized(:cache_size(Inf))` (i.e. no cache limit) then `is pure` should be added to the given Routine

[01:50] <sortiz> IMO, yes.

[01:51] <azawawi> sortiz: consider it done :)

[01:51] <azawawi> sortiz++

[01:51] <skids> I can see the benefit of not cutting across the grain naming-wise.

[01:52] <skids> (versus dominant industry nomenclature)

[01:52] <skids> But... that strikes me as magical.

[01:53] <skids> Or... which routine is "is pure" being added to, the product or the wrapped?

[01:54] *** maybekoo2 joined
[01:57] <sortiz> In this case, the product, thought.

[01:57] <azawawi> skids: good question. i think the wrapped

[01:59] *** tardisx joined
[02:00] <sortiz> The calls will be to the wrapper, so to be useful, it must be marked.

[02:02] *** cdg left
[02:02] *** molaf_ joined
[02:03] <azawawi> cool, printf is impure given its stdout changes

[02:06] *** molaf left
[02:10] <Hotkeys> but how can the wrapper be pure?

[02:10] <Hotkeys> memoization is inherently impure

[02:13] <BenGoldberg> So what's wrong with a little white lie?

[02:14] <sortiz> Hotkeys, On the contrary, memoization turns a may-be impure function into a pure one.

[02:14] <Hotkeys> right

[02:14] <Hotkeys> but the memoization itself is impure

[02:14] <sortiz> Why?

[02:14] <Hotkeys> side effects

[02:14] <tweakism> (maybe memoized should imply pure-ish, i.e., pure excepting the memoization cache effects, and pure should imply memoizeable, so the norm be to see the wrapper be only memoized, and the inner be only pure.  because especially if you use it the way skids suggests, it's no longer really a mere technicality, memoization does modify global state.)

[02:14] <Hotkeys> it caches the results, no?

[02:15] <Hotkeys> I agree that memoization implies the underlying function is pure(-ish?)

[02:15] <Hotkeys> but the wrapper itself isn't

[02:15] <tweakism> and, does is-memoized forbid side-effects?

[02:15] <BenGoldberg> Technically, memoizing creats an impure function, since that wrapper modifies the cache.

[02:15] <Hotkeys> ++

[02:15] <tweakism> 'cause if not, how can you call a function that has a side-effect the first time it's called, but not the 2nd time it's called with the same arguments, pure?

[02:16] <Hotkeys> a function with side-effects isn't pure anyway

[02:16] <Hotkeys> so you wouldn't :p

[02:16] <timotimo> the cache is hidden inside the wrapper, though. so it's not a side effect

[02:16] <tweakism> oh, fair enough, this only concerns functions already marked pure

[02:16] <timotimo> you can't measure the effect on the cache :P

[02:16] <BenGoldberg> But as long as noone can introspect, and observe that cache, then it behaves similarly enough to an actually pure function, that we can pretend that it is one for all intents and purposes.  Including adding the 'is pure' trait.  Yes, that trait is a little white lie, but it's a harmless/useful lie.

[02:16] <skids> maybe there should be two differently named traits for different semantics.

[02:16] <sortiz> A function with side-effects isn't a "function" in the first place!

[02:17] <geekosaur> .oO { did I wander into #haskell by mistake? }

[02:17] <tweakism> lol, meaning clear from context.

[02:17] <Hotkeys> you're not wrong sortiz but I disapprove :p

[02:18] <Hotkeys> geekosaur: lol

[02:20] <sortiz> The problem is that 'pureness' is only defined for functions, no routines.

[02:21] <Hotkeys> .oO { the solution here is to just have a new 'routine_declarator:<fun>' }

[02:21] *** partly__ joined
[02:22] <timotimo> a function cannot have side-effects, though

[02:22] <timotimo> a function is a mapping from one set of values to another

[02:22] <timotimo> where every entry in the first set has a corresponding value in the other

[02:22] <sortiz> timotimo, thanks.

[02:22] <timotimo> and what value is mapped to is exactly defined by what is on the other side

[02:23] <timotimo> a "function with a side-effect" is just putting the world into the arguments

[02:23] <timotimo> and here we are in haskell land

[02:23] <Hotkeys> lol

[02:23] <timotimo> because that's what they use monads for

[02:23] <BenGoldberg> That's not a bad idea.... a declarator, 'fun', which behaves much like 'sub' but with an automatic 'is pure'

[02:23] <Hotkeys> right

[02:23] <timotimo> but "is pure" does almost nothing at the moment. why are we talking about this?

[02:23] * BenGoldberg shrugs.

[02:24] * Hotkeys shrugs

[02:24] <BenGoldberg> For the 'fun' of it?

[02:24] <Hotkeys> AHAHAHAHAHA

[02:24] <Hotkeys> HAHA

[02:24] <Hotkeys> :)

[02:24] <sortiz> -Ofun

[02:24] <timotimo> i want to be allowed to mark a function "pure" but do as many side-effects as i want in it

[02:24] <timotimo> why should i change up my whole darn program just because i want to log when/how often/in what order/... my "pure" function is called in?

[02:25] <BenGoldberg> Then you'll have to pass in a world object, and return a modified world!

[02:25] <skids> .oO(Programming languages cease to map to mathematics precisely at the border with the real world)

[02:25] <Hotkeys> lol

[02:25] *** partly_ left
[02:25] <timotimo> that's only fine if i'm allowed to have that world object stored in a global variable

[02:25] <timotimo> no f'ing way am i going to change the signature of every darn function upwards of the function on the stack

[02:25] <geekosaur> next stop, unsafePerformIO

[02:26] <timotimo> if you consider a function pure and it does side-effects that somehow break your expectations of the program, that's DIHWIDT to me

[02:26] <timotimo> perl6 isn't in the business of formally proving stuff about whole programs. you'd have to build a slang for that

[02:26] <timotimo> that's my potentially wrong and unpopular opinion on the matter :)

[02:26] <timotimo> s/potentially/probably/

[02:27] <geekosaur> well, in theory 'is pure' could enable a bunch of optimizations that are likely to be extremely brittle in the face of side effects

[02:27] <geekosaur> so we have to not even consider those optimizations now

[02:28] <timotimo> wrong, IMO

[02:28] <timotimo> if you mark something "is pure", you'll get exactly what you ask for

[02:28] <geekosaur> and your logging will likely happen exactly once

[02:29] <timotimo> it's not about "force this to have no side effects", it's about "i don't care about the side-effects it has"

[02:29] <Hotkeys> I think if you decide to put side effects in your pure function that's all on you

[02:29] <Hotkeys> ++

[02:29] <Hotkeys> perhaps if the compiler detected side effects it could warn you

[02:30] <geekosaur> and you're right back where you started because that logging every call you wanted won't work

[02:32] <sortiz> Hotkeys, "pureness" is defined in terms of inputs and outputs only, not side-effects.

[02:32] <timotimo> geekosaur: i'd just drop "is pure"

[02:32] <Hotkeys> "A pure function is a function where the return value is only determined by its input values, without observable side effects."

[02:33] * timotimo goes to bed

[02:33] <sortiz> "observable", no "nonexistent" 

[02:33] <geekosaur> if that is the definiton used then you might get away with it. but optimization opportunities are lost unless you are clever

[02:34] <geekosaur> the reason Haskell's Debug.Trace.trace has to be embedded into an expression the way it is isn't just syntax; the resulting data dependency ensures the compiler doesn't simply remove it since it can't be doing anything

[02:35] *** kid51 left
[02:36] <skids> It isn't necessarily the case that the Perl 6 "is pure" trait follows that definition precisely.  Words mean slightly different things in different languages.

[02:37] <skids> For example, even in the purest functional programs, a pure function is allowed to vary the number of CPU cycles it uses even with the same input.  (true FP must be realtime FP mwhahaha)

[02:39] <sortiz> And the quantum state of electrons involved, sure ;-)

[02:40] *** themonkeybob11 joined
[02:45] *** ilbot3 left
[02:45] *** jjido joined
[02:46] *** themonkeybob11 left
[02:47] *** ilbot3 joined
[02:54] <Hotkeys> pure functions contribute to entropy

[02:54] <Hotkeys> inescapable side effect

[02:55] <skids> Well -- running them does.  It's actually not a silly point though about runtime.  You can't analyze the interaction of two haskell programs over a protocol the same way you can analyze a single haskell program.

[03:02] *** aindilis joined
[03:14] <azawawi> so after looking at https://github.com/perl6/doc/issues/407 , I realized that http://doc.perl6.org/language/5to6-perlfunc is not indexed at all

[03:16] <azawawi> is that intended or was not implemented in the first place?

[03:18] *** telex left
[03:19] *** jjido left
[03:21] <skids> Hrm.  It might deserve special treatment.  e.g. you wouldn't want any P5 functions showing up under the Routines tab.  I don't know what's lumped into "indexed" right now.

[03:22] <azawawi> they should be indexed under here http://doc.perl6.org/routine-sub.html, right?

[03:23] *** telex joined
[03:23] <skids> I would not think so, they aren't "Perl 6 Sub Routines"

[03:25] <azawawi> so a new category for "5to6" ?

[03:26] <skids> Can they be invisible except for search?

[03:27] <azawawi> yeah ofcourse, i will find a way for that :)

[03:27] <skids> Just politics-wise we shouldn't be offering things that will ruin perl 5 doc search engine results.

[03:27] <skids> (on other search engines)

[03:28] <azawawi> politics :)

[03:30] *** telex left
[03:31] <skids> .oO(trump tax refund: form 1099-T enter the number of a bank account to which you have deposited at least $40, we promise we'll wire your refund there.)

[03:33] <ugexe> hmm they never need to ask for my bank account when i dont have a refund

[03:33] <ugexe> they seem to uncover them pretty fast then

[03:35] *** labster left
[03:35] *** labster joined
[03:38] *** maybekoo2 left
[03:38] <BenGoldberg> p56: print STDERR "foo";

[03:38] <camelia> p5-to-p6 : OUTPUT«# Do not edit this file - Generated by Perlito5 9.017␤␤print('foo')␤»

[03:38] <BenGoldberg> p56: STDERR->print("foo");

[03:38] <camelia> p5-to-p6 : OUTPUT«# Do not edit this file - Generated by Perlito5 9.017␤␤STDERR.print('foo')␤»

[03:39] <BenGoldberg> m: say *STDOUT

[03:39] <camelia> rakudo-moar 855de7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/of5YGwK2rB␤Missing infix inside S␤at /tmp/of5YGwK2rB:1␤------> 3say *S7⏏5TDOUT␤    expecting any of:␤        infix␤        infix stopper␤»

[03:39] <BenGoldberg> m: say *OUT

[03:39] <camelia> rakudo-moar 855de7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/UG5OQGWxEH␤Two terms in a row␤at /tmp/UG5OQGWxEH:1␤------> 3say *7⏏5OUT␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement …»

[03:39] <BenGoldberg> m: say $*OUT

[03:39] <camelia> rakudo-moar 855de7: OUTPUT«IO::Handle<<STDOUT>>(opened, at octet 0)␤»

[03:39] <BenGoldberg> m: $*OUT.printf("%s", "foo")

[03:39] <camelia> rakudo-moar 855de7: OUTPUT«Method 'printf' not found for invocant of class 'IO::Handle'␤  in block <unit> at /tmp/HZ0oDuB6oG line 1␤␤»

[03:40] <BenGoldberg> m: printf("%s", "foo")

[03:40] <camelia> rakudo-moar 855de7: OUTPUT«foo»

[03:40] * BenGoldberg wonders why there's a bare 'printf' sub, but no 'printf' io handle method.

[03:47] *** vendethiel joined
[03:48] *** Upasaka left
[03:50] *** noganex joined
[03:52] *** Upasaka joined
[03:54] *** noganex_ left
[03:56] *** telex joined
[03:57] <skids> aybe it would be confusing to have both IO.printf and Str.printf combined with the invocant=first-arg tradition and the fact that the first arg of C's printf is the pattern, and the C function that does have an IO first arg is named fprintf.

[03:58] <skids> Those would be my theories at least.

[04:04] *** cpage__ left
[04:04] *** cpage__ joined
[04:09] *** vendethiel left
[04:10] *** MadcapJake joined
[04:15] *** jjido joined
[04:16] *** BenGoldberg left
[04:21] *** skids left
[04:25] *** ggoebel17 joined
[04:26] *** ggoebel16 left
[04:27] *** mattp_ left
[04:27] *** mattp__ joined
[04:27] *** _perlpilot_ joined
[04:27] *** Cabanossi left
[04:27] *** jferrero_ left
[04:27] *** jferrero joined
[04:28] *** perlpilot_ left
[04:28] *** prammer left
[04:28] *** pdcawley_ joined
[04:28] *** pdcawley left
[04:29] *** bakedb_ joined
[04:29] *** tardisx left
[04:30] *** bakedb left
[04:31] *** Cabanossi joined
[04:32] *** gypsydav15 left
[04:32] *** gypsydave5 joined
[04:35] *** tardisx joined
[04:44] *** ranguard_ left
[04:44] *** ranguard joined
[04:50] *** jjido left
[04:57] *** wamba left
[05:03] *** molaf_ left
[05:05] *** tardisx left
[05:15] *** TreyHarris left
[05:18] *** Sgeo_ joined
[05:20] *** Sgeo left
[05:24] *** Upasaka left
[05:28] *** Upasaka joined
[05:28] *** tardisx joined
[05:32] *** labster left
[05:33] *** adu joined
[05:41] *** Cabanossi left
[05:43] * [Coke] yawns.

[05:44] *** Cabanossi joined
[05:45] *** jjido joined
[05:53] * azawawi yawns

[05:54] * azawawi waits for https://travis-ci.org/perl6/doc/builds/113581791 to finish :)

[05:56] <azawawi> how often is doc.perl6.org built? (i.e. cron job settings)

[06:00] <[Coke]> */5

[06:00] <[Coke]> but it's super slow.

[06:01] * adu <3 Perl6

[06:04] <azawawi> cool thanks

[06:04] <azawawi> [Coke]: what do you think of https://github.com/perl6/doc/pull/408? Feedback is more than welcome :)

[06:05] *** travis-ci joined
[06:05] <azawawi> [Coke]: im waiting for travis CI to OK the PR :)

[06:05] <travis-ci> Doc build passed. Ahmad M. Zawawi 'Add 5to6-perlfunc functions to index under a hidden category. This fixes #407'

[06:05] <travis-ci> https://travis-ci.org/azawawi/doc/builds/113581306 https://github.com/azawawi/doc/compare/997e03d3d571...475a78a2bc4e

[06:05] *** travis-ci left
[06:07] *** travis-ci joined
[06:07] <travis-ci> Doc build passed. Ahmad M. Zawawi 'Ignore .precomp'

[06:07] <travis-ci> https://travis-ci.org/azawawi/doc/builds/113581462 https://github.com/azawawi/doc/compare/475a78a2bc4e...a406f323a33a

[06:07] *** travis-ci left
[06:08] <[Coke]> azawawi: no opinion without seeing it in action.

[06:09] <azawawi> basically it will show p5to6-func items under category "p5to6-func" when using search... no new category was added

[06:10] *** themonkeybob11 joined
[06:12] <dalek> doc: 475a78a | azawawi++ | htmlify.p6:

[06:12] <dalek> doc: Add 5to6-perlfunc functions to index under a hidden category. This fixes #407

[06:12] <dalek> doc: review: https://github.com/perl6/doc/commit/475a78a2bc

[06:12] <dalek> doc: a406f32 | azawawi++ | .gitignore:

[06:12] <dalek> doc: Ignore .precomp

[06:12] <dalek> doc: review: https://github.com/perl6/doc/commit/a406f323a3

[06:12] <dalek> doc: 7b7d42d | azawawi++ | / (2 files):

[06:12] <dalek> doc: Merge pull request #408 from azawawi/master

[06:12] <dalek> doc: 

[06:12] <dalek> doc: Add 5to6-perlfunc functions to search index

[06:12] <dalek> doc: review: https://github.com/perl6/doc/commit/7b7d42dff1

[06:16] *** idiosyncrat_ left
[06:18] *** khw left
[06:19] *** jjido left
[06:24] *** themonkeybob11 left
[06:25] *** themonkeybob11 joined
[06:30] *** themonke1bob11 joined
[06:31] *** bjz joined
[06:31] *** themonkeybob11 left
[06:36] *** themonke1bob11 left
[06:36] <azawawi> [Coke]: it is now working :)

[06:36] <azawawi> [Coke]: refresh :)

[06:37] <azawawi> http://doc.perl6.org/language/5to6-perlfunc.html#printf

[06:38] *** bjz left
[06:42] *** themonkeybob11 joined
[06:50] *** Sgeo__ joined
[06:53] *** Sgeo_ left
[06:54] *** tharkun left
[06:55] *** jjido joined
[06:56] *** bjz joined
[06:58] *** adu left
[07:00] *** tharkun joined
[07:02] *** vendethiel joined
[07:04] *** sjoshi joined
[07:15] *** domidumont joined
[07:18] *** tardisx left
[07:20] *** domidumont left
[07:20] *** domidumont joined
[07:23] *** bjz_ joined
[07:25] *** bjz left
[07:30] *** nakiro joined
[07:35] *** firstdayonthejob joined
[07:39] *** gfldex joined
[07:39] <sortiz> azawawi, Still there?

[07:41] <azawawi> sortiz: yup

[07:43] <sortiz> Thought that the function to mark is, indeed, the wrapper.

[07:44] *** labster joined
[07:45] <azawawi> cool

[07:46] <sortiz> Via your trait is applied at compile time, so any call in the source to the original function, should be compiled instead as a call to your wrapper.

[07:47] <sortiz> s/Via/ie.

[07:48] *** vendethiel left
[07:48] <azawawi> sortiz: to tell you the truth, im surprised of the amount of active #perl6 discussion on `is pure` we had today :)

[07:48] <sortiz> And those calls are the candidates to the possibles optimizations, so, is the wrapper the one to mark.

[07:49] <sortiz> Jeje

[07:49] <dalek> doc: 268bb23 | azawawi++ | htmlify.p6:

[07:49] <dalek> doc: Simplify 5to6-perlfunc url

[07:49] <dalek> doc: review: https://github.com/perl6/doc/commit/268bb236ad

[07:49] <dalek> doc: 8384e5a | azawawi++ | / (2 files):

[07:49] <dalek> doc: Merge LLForn precompilation speedup

[07:49] <dalek> doc: review: https://github.com/perl6/doc/commit/8384e5a58d

[07:49] <dalek> doc: e0099d0 | azawawi++ | / (2 files):

[07:49] <dalek> doc: Merge pull request #409 from azawawi/master

[07:49] <dalek> doc: 

[07:49] <dalek> doc: Fix #334

[07:49] <dalek> doc: review: https://github.com/perl6/doc/commit/e0099d024a

[07:50] <sortiz> I'm surprised also. I thought no one would remember the subject.

[07:52] *** jjido left
[07:55] *** tmch joined
[07:55] <sortiz> Moreover, once wrapped, the original function will be called only by yours trait code, so better leave the original alone.

[07:56] <sortiz> And if originally marked, the better, for your trait semantic safety. :)

[08:02] *** RabidGravy joined
[08:05] <sortiz> I'm leaving, CY.

[08:05] <RabidGravy> toodles

[08:05] <sortiz> o/

[08:05] *** sortiz left
[08:08] *** cpage__ left
[08:08] <RabidGravy> so yesterday you may remember I was worried that somehow a native binding that used sockets couldn't interoperate with perl6 sockets in the same process?

[08:11] *** darutoko joined
[08:12] <RabidGravy> I just looked at the code of libshout and the culprit is actually the sync() function, that does a select(1, NULL, NULL, NULL, &sleeper); which is going to block the whole process every time

[08:12] <RabidGravy> so not at all async friendly

[08:12] *** zakharyas joined
[08:14] *** themonkeybob11 left
[08:14] <nine_> The whole process or the whole thread?

[08:15] *** themonkeybob11 joined
[08:18] *** zpmorgan left
[08:19] *** ely-se joined
[08:20] <RabidGravy> I'm pretty certain the whole process (it pre-dates any notion of threads,) but there's only really one way to find out - FIGHT!!! er, wait, make a test

[08:26] *** aindilis left
[08:30] *** sno left
[08:31] *** firstdayonthejob left
[08:32] *** zhi joined
[08:37] <RabidGravy> Hmm well my, albeit rudimentary test using, select and Supply.interval seems to suggest other than my original assertion

[08:41] *** cpage_ joined
[08:42] <RabidGravy> and the select seems to be waiting *forever*

[08:42] <moritz> RabidGravy: did you wait forever to verify?

[08:43] <RabidGravy> no, I had intended ten seconds

[08:44] *** aindilis joined
[08:45] <RabidGravy> oh wait, select has 5 arguments not four

[08:45] <RabidGravy> and with the correct arguments it does sleep for ten

[08:46] *** jjido joined
[08:47] <partly__> So i want to patch a bug in rakudo. gen-usage does remove sigil the first character in \foo parameter, because it has no sigil. The patch is trivial, but to i also need to extend Roast to check for this case?

[08:48] <moritz> partly__: that would be a very good idea, yes

[08:49] <partly__> in general i caught myself reimplementing the gen-usage function (aka copy/paste) because there is no way to access it or is there?

[08:49] *** fireartist joined
[08:50] <moritz> you can call USAGE()

[08:51] <moritz> m: sub MAIN($x?) { say USAGE() }

[08:51] <camelia> rakudo-moar 855de7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/pq7Cal1vbo␤Undeclared name:␤    USAGE used at line 1␤␤»

[08:51] <moritz> hrmp

[08:51] <partly__> moritz,  I want to call USAGE(My::Module)

[08:51] <moritz> m: sub MAIN($x?) { say $?USAGE }

[08:51] <camelia> rakudo-moar 855de7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/A7wn0vOPCi␤Variable '$?USAGE' is not declared␤at /tmp/A7wn0vOPCi:1␤------> 3sub MAIN($x?) { say 7⏏5$?USAGE }␤»

[08:52] <partly__> My bigest issue with USAGE is that it's hardcoded to the current file and the MAIN methods. 

[08:52] <moritz> heh, from src/core/Main.pm

[08:52] <moritz> # TODO:

[08:52] <moritz> # * $?USAGE

[08:52] <moritz> #   * Create $?USAGE at compile time

[08:52] <moritz> #   * Make $?USAGE available globally

[08:52] *** pdcawley_ left
[08:52] <partly__> also $?USAGE does not exist

[08:52] *** pdcawley joined
[08:52] <moritz> partly__: maybe the better API would be to expose it as &MAIN.usage or so

[08:53] <moritz> partly__: since it doesn't seem to work now, we're not bound to immplement that API that was originally envisioned

[08:53] <DrForr> While we're on the subject of twigiled variables, where are $*FOO variables documented?

[08:53] <partly__> moritz: but I thought the language is specfied, no breaking changes?

[08:53] <DrForr> ('$*' in the search box produced no hits.)

[08:54] *** zhi left
[08:54] <partly__> S28?

[08:54] <DrForr> (Parenthetically, tracking search terms that fail to return might help.)

[08:54] <partly__> S28 -> Named Variables

[08:54] <DrForr> Thanks.

[08:54] <moritz> partly__: the real specification is the test suite

[08:54] <moritz> partly__: the design docs are more guidance and explanation

[08:55] <partly__> moritz: ic

[08:57] <partly__> Is there a build in way to tell rakudo during `make spectest` to use not the upstream Roast repo but a custom one? Or how do the developers use it?

[08:59] <partly__> hmm i could just edit the make file

[09:00] <moritz> or simply check out a different branch in t/spectest

[09:01] <tweakism> ok, I *just* got that the butterfly is named /Camelia/

[09:02] <nine_> :)

[09:03] <jdv79> what is there to get about it?

[09:04] <nine_> the camel reference

[09:05] *** rntz left
[09:07] <partly__> I really would prefer to outsource the whole gen-usage function to an own module, which can be tested separately and just called by rakudo/src/core/Main.pm . Currently the main-usage.t spec is calling a perl6 interpreter and interpreting the string output to Stdout https://github.com/perl6/roast/blob/47943aee1873b030cce3437ce7edecc00b5e414f/S06-other/main-usage.t

[09:07] <partly__> Thats cumbersone.

[09:07] <partly__> Or am I complicating things?

[09:10] <jdv79> there are no refs in p6

[09:12] *** maybekoo2 joined
[09:13] <RabidGravy> DrForr, they should be in language/variables - if that isn't complete then it should be fixed, the s28 has things that don't exist and misses some things

[09:15] <DrForr> Oh, they are there. I just meant mostly that typing '$*' into the search box didn't match anything.

[09:15] <RabidGravy> "dynamic variables"

[09:17] <DrForr> I understand, but people will also come at this from "$*? What the heck is *that*..." and type '$*' into the search box, rather than automatically knowing that it's a dynamic variable.

[09:18] <RabidGravy> anyway having looked at the libshout source code in detail, a) I wish I hadn't and b) it's really simple (modulo some of the insane indirection involved)

[09:19] <DrForr> Incidentally I've solved the handler issues I was working on, I'm going to restore the code to the main app over the weekend so I can make some progress on creating sessions and such.

[09:20] <RabidGravy> I think there is something in the way that the search terms are derived that allows a mapping from '$*' -> 'dynamic variables' or whatever so it would work but that's a web thing and y'know ....

[09:22] <DrForr> And yes, $*SESSION is what I need, looking at the page.

[09:22] *** bartolin joined
[09:22] *** aindilis left
[09:36] *** yeahnoob left
[09:36] <Ulti> pyrimidine: oh thats really great news! There is someone else here at Sanger who is playing with Perl 6, does it have to be a student?

[09:47] *** torbjorn left
[09:49] *** domidumont left
[09:50] *** jjido left
[09:50] *** domidumont joined
[09:51] *** rntz joined
[09:55] *** nakiro left
[09:56] *** zakharyas left
[09:57] *** AlexDaniel joined
[09:57] *** zakharyas joined
[09:58] *** maybekoo2 left
[09:58] *** nakiro joined
[10:04] *** ely-se left
[10:06] <AlexDaniel> azawawi: here?

[10:10] *** ely-se joined
[10:10] *** espadrine joined
[10:12] <AlexDaniel> azawawi: ah okay, I've left a comment on https://github.com/perl6/doc/issues/407

[10:14] *** torbjorn joined
[10:18] *** maybekoo2 joined
[10:22] <partly__> PR to rakudo/rakudo and perl6/roast are out. Enough good deeds for today, now back to working on world domination

[10:25] <moritz> partly__++

[10:28] *** jjido joined
[10:31] *** jjido left
[10:32] *** abraxxa joined
[10:33] *** jjido joined
[10:33] *** jjido left
[10:34] *** jjido joined
[10:34] *** jjido left
[10:35] *** Skarsnik joined
[10:35] <Skarsnik> Hello

[10:35] <RabidGravy> er

[10:35] <RabidGravy> erp

[10:36] *** virtualsue joined
[10:42] *** jjido joined
[10:43] *** RabidGravy left
[10:44] *** jjido left
[10:48] *** rindolf joined
[10:50] *** bioexpress joined
[10:56] *** lizmat joined
[10:57] *** ely-se left
[10:58] <bioexpress> Hi! In the NativeCall-module I've found 'use nqp;'. Does there exist somewhere a 'nqp.pm6' module?

[11:01] <dalek> rakudo/nom: 676ad66 | lizmat++ | src/core/Parameter.pm:

[11:01] <dalek> rakudo/nom: Add (cheap) Parameter.usage-name

[11:01] <dalek> rakudo/nom: 

[11:01] <dalek> rakudo/nom: Inspired by PR #720 by kalkin++

[11:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/676ad669c9

[11:02] <jnthn> bioexpress: No, it's handled specially by the compiler

[11:02] <lizmat> bioexpress: only virtually, internally it only sets a flag to allow you to use nqp:: opts

[11:02] <jnthn> bioexpress: It means that nqp:: ops can be used

[11:02] <jnthn> (Which is the VM abstraction layer)

[11:05] <lizmat> bioexpress: some documentation exists at https://github.com/perl6/nqp/blob/master/docs/ops.markdown

[11:07] <dalek> rakudo/nom: 7bdebae | lizmat++ | src/core/Main.pm:

[11:07] <dalek> rakudo/nom: Alternate fix for PR #720, kalkin++

[11:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7bdebae05e

[11:09] <bioexpress> lizmat: Thx!

[11:09] <bioexpress> jnthn: Thx!

[11:11] *** jjido joined
[11:11] *** bioexpress left
[11:11] <lizmat> partly__++

[11:12] <dalek> roast: 39d9936 | (Bahtiar `kalkin-` Gadimov)++ | S06-other/main-usage.t:

[11:12] <dalek> roast: Auto-generated USAGE handles sigilles parameters

[11:12] <dalek> roast: review: https://github.com/perl6/roast/commit/39d9936078

[11:12] <dalek> roast: 3a1ef78 | lizmat++ | S06-other/main-usage.t:

[11:12] <dalek> roast: Merge pull request #107 from kalkin/usage-sigilles

[11:12] <dalek> roast: 

[11:12] <dalek> roast: Auto-generated USAGE handles sigilles parameters

[11:12] <dalek> roast: review: https://github.com/perl6/roast/commit/3a1ef7800c

[11:20] *** aindilis joined
[11:23] <partly__> So how does this work with the "Perl 6" specs? lizmat just added a Parameter.usage-name() is this Rakudo implementation only, or will it be available to Perl 6d?

[11:23] *** asan13 left
[11:23] <lizmat> partly__: it's an addition to an existing class

[11:23] <lizmat> one that could be considered internal, actually

[11:24] <psch> +1

[11:24] <lizmat> the onus on its usage is with the developer

[11:24] <partly__> lizmat: but what if i want to depend on it? If i'm doing a framework which does introspection magic?

[11:24] *** Relsak joined
[11:25] <lizmat> partly__: please check out jnthn's blog post about it: https://6guts.wordpress.com/2016/02/09/a-few-words-on-perl-6-versioning-and-compatibility/

[11:25] <partly__> lizmat: ok

[11:25] *** azawawi left
[11:26] *** bjz_ left
[11:27] <jnthn> partly__: In summary: you can't officially depend on it (and we're not committed to support it) until it's covered in tests that make up a future Perl 6 release.

[11:28] <partly__> jnthn: so Parameter is not a Part of Perl 6c, it might be a part of 6d if some one bothers to write tests?

[11:28] <partly__> or at least Parameter.usage-name()

[11:29] <DrForr> The Parameter class works, at least what's derived from Signatures.

[11:30] *** Actualeyes left
[11:31] <llfourn> partly__: I think that's roughly a good summary. I wonder if this shouldn't be called "sigiless-name"?

[11:32] <TEttinger> nigel.

[11:33] *** Actualeyes joined
[11:33] <llfourn> ( and add it to variables as well? )

[11:33] *** bjz joined
[11:34] <llfourn> $name.VAR.sigiless-name.say # name

[11:34] <jnthn> partly__: Parameter is in 6.c, just that particular method that was just added isn't part of 6.c

[11:34] <partly__> Hmm i see that S30 is missing and I do not see any Parameter class tests in roast, how far does the spec currently cover the stdlibrary?

[11:35] <jnthn> It's quite possible it's rather under-tested...

[11:35] <jnthn> (Parameter)

[11:35] <jnthn> Otherwise coverage varies; we know it's not as much as it wants to be.

[11:36] <partly__> jnthn: so theoretically if there would exists another VM for Perl6, it would support v6.c but it can be missing the whole Parameter class?

[11:37] *** maybekoo2 left
[11:37] <llfourn> I'm pretty sure parameters are tested somewhere....

[11:37] <partly__> (because 6.c is only what the tests are)

[11:37] <llfourn> I mean at least signature introspecting right..right?

[11:37] <moritz> S06-signature/introspection.t:    ok ?(all(@l >>~~>> Parameter)), 'And all items are Parameters';

[11:37] <DrForr> Prancer uses it.

[11:38] *** virtualsue left
[11:38] <llfourn> >>~~>> # that is quite a conjunction of operators

[11:39] <moritz> and that test file also tests the methods type, rw, copy, raw, slurpy, optional, invocant, named

[11:39] <moritz> named_names and name

[11:39] <moritz> and .perl

[11:39] *** lizmat left
[11:40] *** virtualsue joined
[11:40] <partly__> Ahh thanks moritz

[11:41] <llfourn> so, why not just do all(@l) ~~ Parameter isn't it the same thing?

[11:42] <llfourn> or all(|@l) ?

[11:43] <llfourn> m: my @l = <one two three>; say all(@l) ~~ Str # actually | seems not be needed

[11:43] <camelia> rakudo-moar 7bdeba: OUTPUT«True␤»

[11:44] <llfourn> m: my @l = <one two three>; say ?(all(@ >>~~>> Str))

[11:44] <camelia> rakudo-moar 7bdeba: OUTPUT«True␤»

[11:46] *** kaare__ joined
[11:46] *** jjido left
[11:47] *** jjido joined
[11:47] <llfourn> m: my @l = <one two three>; say [&&] @l >>~~>> Str # in any case the junction there is silly IMO

[11:47] <camelia> rakudo-moar 7bdeba: OUTPUT«True␤»

[11:49] <psch> m: my @l = <one two three>; say all(@l>>.&[~~](Str)) # /o\

[11:49] <camelia> rakudo-moar 7bdeba: OUTPUT«all(True, True, True)␤»

[11:49] <psch> oh, right, that needs the prefix:<?> 

[11:49] <llfourn> psch: you need [&&]

[11:49] <psch> m: my @l = <one two three>; say ?all(@l>>.&[~~](Str)) # /o\

[11:49] <camelia> rakudo-moar 7bdeba: OUTPUT«True␤»

[11:50] <psch> nah, that was my intention :)

[11:50] <psch> llfourn: in any case, you're right.  the test as-is is a bit over the top

[11:50] <llfourn> m: my @l = <one two three>; say ?all(@l>>.&[~~](Int))

[11:50] <camelia> rakudo-moar 7bdeba: OUTPUT«False␤»

[11:50] <llfourn> ah right I see what you did there :)

[11:51] <psch> m: say "1".&[&[&&]] 

[11:51] <camelia> rakudo-moar 7bdeba: OUTPUT«Invocant requires a type object of type Array, but an object instance was passed.  Did you forget a 'multi'?␤  in block <unit> at /tmp/QQdLLwU7IH line 1␤␤»

[11:52] <psch> m: say [1,2,3].&[&[&&]] 

[11:52] <camelia> rakudo-moar 7bdeba: OUTPUT«Invocant requires a type object of type Array, but an object instance was passed.  Did you forget a 'multi'?␤  in block <unit> at /tmp/UYtBRDiUS5 line 1␤␤»

[11:52] *** nowan_ joined
[11:52] * llfourn doesn't know what psch is trying to do or what that error is about

[11:52] <psch> m: say 1 &[&&] 1

[11:52] <camelia> rakudo-moar 7bdeba: OUTPUT«all(1, 1)␤»

[11:52] * psch is just poking things

[11:53] *** tmch left
[11:53] <psch> that's really one of the things about prefixifying infixes (and the other way around) that i get stuck on

[11:53] <psch> m: say 1 &[&&] 1 # this

[11:53] <camelia> rakudo-moar 7bdeba: OUTPUT«all(1, 1)␤»

[11:54] <llfourn> I'm not even sure what that is doing

[11:54] <llfourn> m: say 1 && 1 # is it the same?

[11:54] <camelia> rakudo-moar 7bdeba: OUTPUT«1␤»

[11:54] <psch> & as metaop from infix:<&> which is an and Junction

[11:54] <llfourn> oh

[11:55] <llfourn> now I understand

[11:55] *** labster left
[11:55] <jnthn> I...don't think that meta-ops at all? :)

[11:55] <psch> m: say 1 &[~] 2

[11:55] <camelia> rakudo-moar 7bdeba: OUTPUT«all(1, 2)␤»

[11:55] <llfourn> that's pretty crazy

[11:55] <psch> uh

[11:55] <jnthn> m: say 1 & [~] 2

[11:55] <camelia> rakudo-moar 7bdeba: OUTPUT«all(1, 2)␤»

[11:55] <psch> right, it doesn't metaop...

[11:55] <jnthn> m: say 1 & [~] 2, 3

[11:55] <camelia> rakudo-moar 7bdeba: OUTPUT«all(1, 23)␤»

[11:55] <jnthn> :)

[11:55] <psch> that's just even worse :(

[11:55] *** nowan left
[11:55] <jnthn> It's unsurprising, no?

[11:56] <jnthn> After an infix we look for a term.

[11:56] <jnthn> And [~] 2, 3 is a perfectly fine term.

[11:56] <jnthn> (Reduction with ~)

[11:56] *** ely-se joined
[11:57] <psch> yeah, it's just the bit i get confused about with infixifying and prefixifying

[11:57] <psch> but that helps, i think

[11:58] <psch> as in, "don't put the & outside of the brackets, it's all()" or something

[11:58] <psch> i think i can remember that

[11:58] <psch> hah, "that's all()" probably works better :)

[11:58] <psch> m: say 1 &[&all] 2, 3

[11:58] <camelia> rakudo-moar 7bdeba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/BMxxnOiK02␤Two terms in a row␤at /tmp/BMxxnOiK02:1␤------> 3say 1 &[&all]7⏏5 2, 3␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        …»

[11:58] <llfourn> m: say &[~]("a","b"); say "a" &[~] "b" # totes not the same

[11:58] <camelia> rakudo-moar 7bdeba: OUTPUT«ab␤all(a, b)␤»

[12:00] <jnthn> Nope

[12:04] *** TEttinger left
[12:07] <psch> m: sub f($, $) { "ok" }; say 1 [&[[&f]]] 2 # i'm just a bit sad this doesn't work

[12:07] <camelia> rakudo-moar 7bdeba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/z21XYbnOAX␤Unable to parse expression in bracketed infix; couldn't find final ']' ␤at /tmp/z21XYbnOAX:1␤------> 3sub f($, $) { "ok" }; say 1 [&7⏏5[[&f]]] 2 # i'm just a bit sad this does␤»

[12:07] <psch> but it's silly anyway, so i can deal

[12:07] <psch> hm, i guess it wouldn't really make sense to work anyway, would it

[12:08] <llfourn> wouldn't make sense to me :D

[12:08] <llfourn> (for any definition of work)

[12:08] <psch> m: sub f($,$) { "ok" }; say f 1, 2; say 1 [&f] 2; say [[&f]] 1, 2

[12:08] <camelia> rakudo-moar 7bdeba: OUTPUT«ok␤ok␤ok␤»

[12:09] <psch> but &[[&f]] isn't the infix form of the reduce form

[12:09] <psch> err, [&[[&f]]] i mean

[12:09] <llfourn> [&f] # this makes an infix?

[12:09] <psch> yeah

[12:09] <psch> m: say 1 [&infix:<+>] 2

[12:09] <camelia> rakudo-moar 7bdeba: OUTPUT«3␤»

[12:10] <llfourn> heh cool.

[12:12] <jnthn> m: 'hello' [&say] 'world'

[12:12] <camelia> rakudo-moar 7bdeba: OUTPUT«helloworld␤»

[12:12] <jnthn> :P

[12:12] <psch> m: say infix:<Z+>

[12:12] <camelia> rakudo-moar 7bdeba: OUTPUT«(...)␤»

[12:13] <psch> m: say prefix:<[+]>

[12:13] <camelia> rakudo-moar 7bdeba: OUTPUT«0␤»

[12:13] <psch> m: say &prefix:<[+]>

[12:13] <camelia> rakudo-moar 7bdeba: OUTPUT«sub prefix:<[+]> (| is raw) { #`(Sub|72580688) ... }␤»

[12:13] <llfourn> m: (<hello world).&[~].say

[12:13] <camelia> rakudo-moar 7bdeba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/jwYABM1ukg␤Unable to parse expression in quote words; couldn't find final '>'␤        ␤at /tmp/jwYABM1ukg:1␤------> 3(<hello world).&[~].say7⏏5<EOL>␤    expecting any of:␤        quote words…»

[12:13] <psch> m: say 1 [&prefix:<[+]>] 2

[12:13] <camelia> rakudo-moar 7bdeba: OUTPUT«3␤»

[12:14] <psch> so we do install the reduce form, but can't parse it because... reasons vOv

[12:14] <llfourn> m: <hello world>.&[~].say

[12:14] <camelia> rakudo-moar 7bdeba: OUTPUT«hello world␤»

[12:17] <AlexDaniel> what are you trying to do? :)

[12:17] <psch> AlexDaniel: i was trying to make an infix of a reduce form of an infix form of a sub

[12:18] <AlexDaniel> :o

[12:18] <psch> :P

[12:18] <AlexDaniel> m: :o

[12:18] <camelia> rakudo-moar 7bdeba: OUTPUT«WARNINGS for /tmp/3W7qVe7STP:␤Useless use of ":o" in sink context (line 1)␤»

[12:18] <AlexDaniel> m: :o .say

[12:18] <camelia> rakudo-moar 7bdeba: OUTPUT«o => True␤»

[12:19] <AlexDaniel> m: ∞

[12:19] <camelia> rakudo-moar 7bdeba: ( no output )

[12:19] <AlexDaniel> TimToady: why no warning here? ↑

[12:20] *** kid51 joined
[12:22] <llfourn> you can't sink infinity

[12:22] <llfourn> m: Inf

[12:22] <camelia> rakudo-moar 7bdeba: ( no output )

[12:22] <psch> m: ()

[12:22] <camelia> rakudo-moar 7bdeba: OUTPUT«WARNINGS for /tmp/05UZhSdoyB:␤Useless use of () in sink context (line 1)␤»

[12:22] <psch> m: Nil

[12:22] <camelia> rakudo-moar 7bdeba: ( no output )

[12:27] *** bjz left
[12:28] *** bjz joined
[12:30] <AlexDaniel> m: NaN

[12:30] <camelia> rakudo-moar 7bdeba: ( no output )

[12:30] <AlexDaniel> llfourn: it sinks just fine :)

[12:33] <llfourn> m: 

[12:33] <llfourn> m: ∞.sink

[12:33] <camelia> rakudo-moar 7bdeba: ( no output )

[12:33] <llfourn> you're right

[12:34] <llfourn> maybe it's because ∞ represents the number of turtles holding up the world and turtles are fine when they sink.

[12:41] <sjn> I wonder if those same turtles also float :)

[12:42] <sjn> is that rational thing to wonder about?

[12:42] *** cpage joined
[12:42] <llfourn> sjn: no we don't have float in p6 we call them Num

[12:43] * sjn feels Num thinking about these things

[12:45] *** morgane joined
[12:45] *** kid51 left
[12:46] <morgane> hi all!

[12:47] <morgane> do you know if there is a mailing list for volunteer translators?

[12:47] <llfourn> morgane: there is no mailing list specifically for that

[12:47] <moritz> at least not for Perl 6 translators :-)

[12:47] <moritz> though people tend to be helpful on the general mailing lists

[12:47] <moritz> morgane: or do you want to volunteer translations?

[12:48] <morgane> thanks!

[12:48] *** tmch joined
[12:48] <morgane> yep

[12:48] <llfourn> morgane: what are you looking at translating?

[12:48] <moritz> morgane: which language(s)?

[12:49] <morgane> Im using perl5 and I would like to start with perl6, and as I am a professionnal translator I would love to learn by helping translating the documentation

[12:49] <morgane> French

[12:49] <sjn> nice!

[12:49] <moritz> hm, http://perl6intro.com/ already has a French translation; was that you?

[12:49] <morgane> nope!

[12:50] <llfourn> some parts of docs.perl6.org may not be good enough to translate...yet

[12:50] <moritz> morgane: we tend to be open to translations, we just don't have much infrastructure to support them

[12:53] <morgane> well, I don't know that much about Web translation (I never lead such project by myself to be honest), but I do know how to translate all kind of local files (.chm and stuff), does perl6 comes with some of them?

[12:54] <morgane> or is there only online documentation?

[12:54] <DrForr> morgane: I've done quite a few translation projects myself.

[12:54] <morgane> coz I guess the infrastructure is only an issue for Web files

[12:55] <morgane> Hi DrForr, what did you translate?

[12:55] <DrForr> turnitin.com, moonfruit.com, some of booking.com, ticketmaster.com...

[12:56] *** sufrostico joined
[12:56] *** azawawi joined
[12:56] <azawawi> hi

[12:56] <rudi_s> I want to iterate over all components of a path (e.g. path is "/a/b/c/d" and I want to get "/a", "/a/b", "/a/b/c", "/a/b/c/d"). At the moment I'm using splitdir and then for 1..^@x.elems { catdir(@x[0..$_]) .. } - is there a shorter/better way?

[12:57] <sjn> hey, is there a way to introspect deep into things? (e.g. if I create a constant $c = 42; I can later introspect $c and see that it is actually a constant)

[12:57] <azawawi> how do I find whether a routine is DEPRECATED or not at runtime?

[12:58] <azawawi> that is check for DEPRECATED

[12:59] <sjn> ETOOMANYQUESTIONS

[12:59] <DrForr> m: $c.^WHAT

[12:59] <camelia> rakudo-moar 7bdeba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/mzEsVJkw7U␤Cannot use .^ on a non-identifier method call␤at /tmp/mzEsVJkw7U:1␤------> 3$c.^WHAT7⏏5<EOL>␤    expecting any of:␤        method arguments␤»

[13:00] <DrForr> m: $c.WHAT

[13:00] <camelia> rakudo-moar 7bdeba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/FzRCY0lKqj␤Variable '$c' is not declared␤at /tmp/FzRCY0lKqj:1␤------> 3<BOL>7⏏5$c.WHAT␤»

[13:00] <DrForr> m: constant c = 32; say c.WHAT

[13:00] <camelia> rakudo-moar 7bdeba: OUTPUT«(Int)␤»

[13:02] <llfourn> sjn: you can't really

[13:03] <sjn> :-\

[13:03] <moritz> m: constant $c = 42; say $c.VAR

[13:03] <camelia> rakudo-moar 7bdeba: OUTPUT«42␤»

[13:03] <moritz> m: constant $c = 42; say $c.VAR.readonly

[13:03] <camelia> rakudo-moar 7bdeba: OUTPUT«Method 'readonly' not found for invocant of class 'Int'␤  in block <unit> at /tmp/HB55xja3pZ line 1␤␤»

[13:03] <llfourn> A constant is not really a thing. It's just a variable that is ro and happens to be readonly.

[13:03] <moritz> m: constant $c = 42; say $c.VAR.^methods

[13:03] <camelia> rakudo-moar 7bdeba: OUTPUT«(Int Num Rat FatRat abs Bridge chr sqrt base polymod expmod is-prime floor ceiling round lsb msb narrow Range sign sin tan cotan acosech conj atan2 cosec pred asec acotan cosh acos acosec sech unpolar log10 atanh log exp acosh truncate sinh tanh acotanh Re…»

[13:04] <moritz> m: constant $c = 42; say $c.VAR.^name

[13:04] <camelia> rakudo-moar 7bdeba: OUTPUT«Int␤»

[13:04] <moritz> m: my $c = 42; say $c.VAR.^name

[13:04] <camelia> rakudo-moar 7bdeba: OUTPUT«Scalar␤»

[13:04] <moritz> that's a difference

[13:04] <llfourn> what moritz is showing gives you a good guess though

[13:04] <moritz> for a variable to be writable, it must be container

[13:04] <sjn> eeh

[13:04] <moritz> m: constant $c = 42; $c := 23; say $c

[13:04] <camelia> rakudo-moar 7bdeba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/JBYdPVOqoa␤Cannot use bind operator with this left-hand side␤at /tmp/JBYdPVOqoa:1␤------> 3constant $c = 42; $c := 237⏏5; say $c␤»

[13:05] <llfourn> m: my $a := "derp"; say $a.VAR.^name; # but this looks like a constant too

[13:05] <camelia> rakudo-moar 7bdeba: OUTPUT«Str␤»

[13:05] <moritz> llfourn: the constant part is the absence of Scalar, not the actual type in there

[13:06] <llfourn> moritz: right but the non-constant my $a := has the absence of Scalar?

[13:06] <llfourn> but it is not ro I suppose

[13:07] <llfourn> well it is actually :S

[13:08] <llfourn> but I guess your last one would work with my $a, and not constant

[13:08] <llfourn> m: my $a := "foo"; $a = "bar";

[13:08] <camelia> rakudo-moar 7bdeba: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/AR2pbqGgBg line 1␤␤»

[13:09] <llfourn> m: my $a := "foo"; $a := "bar";

[13:09] <camelia> rakudo-moar 7bdeba: ( no output )

[13:09] <moritz> the only thing you can't easily test if you can re-bind

[13:09] <moritz> well, you can always test if you can re-bind to itself

[13:09] <llfourn> m: constant $a = "foo"; $a := "bar" #yep

[13:09] <camelia> rakudo-moar 7bdeba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/VrzRnPEyuW␤Cannot use bind operator with this left-hand side␤at /tmp/VrzRnPEyuW:1␤------> 3constant $a = "foo"; $a := "bar" #yep7⏏5<EOL>␤»

[13:09] <moritz> try { $a := $a }

[13:09] <moritz> won't work for constants though, because it's caught at compile time

[13:10] <moritz> use EVAL :-)

[13:10] <llfourn> moritz++ # there is a way to test if something is a constant -- it's just not very nice!

[13:10] <psch> m: my &catdir = $*SPEC.^find_method('catdir').assuming($*SPEC); say [\[&catdir]] ($*SPEC.splitdir: "/a/b/c/d/".IO) 

[13:10] <camelia> rakudo-moar 7bdeba: OUTPUT«( /a /a/b /a/b/c /a/b/c/d /a/b/c/d)␤»

[13:10] <psch> well, the catdir/splitdir usage there is rather pretty, but i don't see a way to get that without the .assuming... vOv

[13:10] <psch> rudi_s: ^^^ 

[13:11] <moritz> m: say IO::Spect.catdir('a', 'b')

[13:11] <camelia> rakudo-moar 7bdeba: OUTPUT«Could not find symbol '&Spect'␤  in block <unit> at /tmp/oy4F6E7jmY line 1␤␤Actually thrown at:␤  in block <unit> at /tmp/oy4F6E7jmY line 1␤␤»

[13:11] <moritz> m: say IO::Spec.catdir('a', 'b')

[13:11] <camelia> rakudo-moar 7bdeba: OUTPUT«Method 'catdir' not found for invocant of class 'IO::Spec'␤  in block <unit> at /tmp/PyxYzvSdgj line 1␤␤»

[13:12] <moritz> m: say IO::Spec::Unix.catdir('a', 'b')

[13:12] <camelia> rakudo-moar 7bdeba: OUTPUT«a/b␤»

[13:12] <psch> hm, not sure why it has the last twice, fwiw :/

[13:12] <psch> m: say [\+] 1,2,3

[13:12] <camelia> rakudo-moar 7bdeba: OUTPUT«(1 3 6)␤»

[13:12] <moritz> m: say $*SPEC::Unix.catdir('a', 'b')

[13:12] <camelia> rakudo-moar 7bdeba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/IQ5NoXuLgG␤Dynamic variables cannot have package-like names, like $*SPEC::Unix␤at /tmp/IQ5NoXuLgG:1␤------> 3say $*SPEC::Unix7⏏5.catdir('a', 'b')␤»

[13:13] <moritz> m: say $*SPEC.catdir('a', 'b')

[13:13] <camelia> rakudo-moar 7bdeba: OUTPUT«a/b␤»

[13:13] <moritz> psch: ^^ use $*SPEC as invocant

[13:13] <psch> moritz: well, rudi_s' question was "all subpaths of a given path, e.g. '/a', '/a/b', '/a/b/c'"

[13:13] <partly__> where can i learn more about the perl6 -c error format? I see that rakudo/src/Perl6/Compiler.nqp has a method syntaxcheck(), but its very very short

[13:14] <psch> moritz: and stuffing $*SPEC.catdir into triangle reduce doesn't work

[13:14] <dalek> doc: fb32bd0 | azawawi++ | htmlify.p6:

[13:14] <dalek> doc: Fix #407 again with less duplication

[13:14] <dalek> doc: review: https://github.com/perl6/doc/commit/fb32bd0062

[13:14] <dalek> doc: 9d5c0c7 | azawawi++ | htmlify.p6:

[13:14] <dalek> doc: Merge pull request #410 from azawawi/master

[13:14] <dalek> doc: 

[13:14] <dalek> doc: Fix #407 again with less duplication

[13:14] <dalek> doc: review: https://github.com/perl6/doc/commit/9d5c0c7d82

[13:14] <rudi_s> psch: Thanks. Without the trailing / it only gets returned once.

[13:15] <psch> rudi_s: oh.  right, that makes sense i suppose

[13:17] *** sjoshi left
[13:18] <moritz> psch: you can use the .reduce method on List, no?

[13:18] <azawawi> how do I get the list of traits on a routine?

[13:19] <moritz> m: say <a b c d>.reduce: -> |c { $*SPEC.catdir(|c) }

[13:19] <camelia> rakudo-moar 7bdeba: OUTPUT«a/b/c/d␤»

[13:19] <moritz> m: say <a b c d>.reduce: -> |c { $*SPEC.catdir(|c) }, :triangle

[13:19] <camelia> rakudo-moar 7bdeba: OUTPUT«a/b/c/d␤»

[13:19] <moritz> ... except that it doesn't do triangle... :/

[13:20] <psch> yeah, that's what i grep'd just now

[13:20] <moritz> azawawi: not all, but most traits work by mixing in a role into the routine object

[13:20] <moritz> azawawi: so you can get a list of roles with &routine.^roles and use that for some guess work

[13:20] <moritz> azawawi: but, traits don't even have to leave traces on the routine itself

[13:21] <moritz> you could a   sub foo is url('/foo/:name') { ... } and only use that to register the subroutine in a dispatcher, not modify the sub itself

[13:22] <azawawi> cool

[13:22] *** wamba joined
[13:25] *** virtualsue left
[13:25] <morgane> DrForr: (about translation projets) what kind of process did you follow? was there a request available somewhere?

[13:27] *** tmch left
[13:30] <DrForr> No, these were usually ~6-month projects, not really something you just make a pull request for.

[13:33] <morgane> ok, so you just asked for the web source files? or?

[13:36] <DrForr> It's not that simple.

[13:37] <morgane> what do you mean?

[13:38] <DrForr> Not as simple as tweaking templates.

[13:38] <azawawi> moritz: got it https://github.com/rakudo/rakudo/blob/nom/src/core/traits.pm#L326 ... thanks :)

[13:40] <DrForr> morgane: I was working with 30 languages, including issues with traditional and simplified Chinese, and some Thai issues.

[13:41] *** _perlpilot_ is now known as perlpilot

[13:42] <morgane> wouh yes, for those languages I can imagine, even French accented letters are sometimes hard to insert.

[13:43] *** abraxxa left
[13:43] <AlexDaniel> azawawi: I am still not convinced that printf issue is solved :)

[13:43] <DrForr> And French punctuation rules and...

[13:44] *** RabidGravy joined
[13:44] <azawawi> http://doc.perl6.org/language/5to6-perlfunc#printf

[13:45] <azawawi> AlexDaniel: come on :)

[13:45] <AlexDaniel> azawawi: yeah I see. But are you sure that printf should not have a dedicated page?

[13:45] <azawawi> AlexDaniel: atm not a lot of documentation is in p5to6-func to begin with...

[13:45] <AlexDaniel> http://doc.perl6.org/routine/printf is a scary 404 right now, so…

[13:46] <AlexDaniel> and I don't think that the reader should know or care about perl5 to read the docs about printf

[13:46] <azawawi> AlexDaniel: the reason that i didnt do it is that it is a p5to6 function ... not a routine

[13:47] <azawawi> AlexDaniel: anyway... a page is better than 404s :)

[13:47] <psch> m: say &printf.isa(Routine) 

[13:47] <camelia> rakudo-moar 7bdeba: OUTPUT«True␤»

[13:47] <AlexDaniel> azawawi: what is a “p5to6 function”?

[13:48] <azawawi> AlexDaniel: http://doc.perl6.org/language/5to6-perlfunc#DESCRIPTION

[13:48] <psch> so http://doc.perl6.org/routine/abs should 404 too?

[13:48] <AlexDaniel> “I will not be explaining the functions in detail. This document is an attempt to guide you from the functions in Perl 5's perlfunc document to their equivalents in Perl 6. For full documentation on the Perl 6 functions, please see the Perl 6 documentation.”

[13:49] <AlexDaniel> please see the Perl 6 documentation on printf! Oh wait, there's none

[13:49] <DrForr> Then help fix it?

[13:50] <AlexDaniel> DrForr: I kinda did. By creating an issue :)

[13:51] <azawawi> AlexDaniel: at least printf et al are now documented... not like before :)

[13:51] *** Psyche^ joined
[13:51] <AlexDaniel> azawawi: yea that's good. And it is really cool that 5to6 is now searchable

[13:52] <AlexDaniel> azawawi++

[13:52] <AlexDaniel> but I think that I have to reopen it… :)

[13:52] * azawawi thinks "baby steps" :)

[13:52] <azawawi> AlexDaniel: hehe

[13:55] *** Psyche^_ left
[13:55] <rudi_s> Is there a nicely-formatted output for .perl available like the old Data::Dumper?

[13:56] <AlexDaniel> m: dd [∞, 2², <a b c>]

[13:56] <camelia> rakudo-moar 7bdeba: OUTPUT«[Inf, 4, ("a", "b", "c")]␤»

[13:56] <AlexDaniel> rudi_s: like this?

[13:56] <Juerd> I think rudi_s might mean: with indentation

[13:56] <psch> D::D adds line breaks and indentation, which i don't think we have 

[13:56] <perlpilot> I don't know if I'd call Data::Dumper output "nicely-formatted"  :)

[13:57] <Skarsnik> Data::Dump module x)

[13:57] <rudi_s> AlexDaniel: Yeah, what Juerd  said.

[13:57] <rudi_s> Well, lets call it better readable for more than one line of output.

[13:57] <AlexDaniel> http://modules.perl6.org/#q=data%3A%3Ad

[13:57] <AlexDaniel> with colors! Wooohooo!

[13:57] <rudi_s> Oh, nice.

[13:58] <AlexDaniel> I like how it says “here you go, dude” in readme

[13:59] *** awwaiid joined
[14:00] <perlpilot> I haven't checked, but it would be nice if one of those dumpers did object inspection like P5's Data::Printer

[14:01] <Skarsnik> It does

[14:02] <perlpilot> Ah, Data::Dump++

[14:02] <perlpilot> tony-o++

[14:11] *** TreyHarris joined
[14:15] *** awwaiid left
[14:15] *** cdg_ joined
[14:23] *** telex left
[14:24] *** Amnez777 left
[14:35] *** Relsak left
[14:36] <nine> 12 minute mark and I still have to cover all precompilation issues and available repository implementations...

[14:36] *** morgane left
[14:37] *** molaf joined
[14:39] *** Amnez777 joined
[14:44] *** rntz left
[14:44] *** rntz joined
[14:45] *** skids joined
[14:47] <dalek> rakudo/repl6: 3155d15 | hoelzro++ | src/Perl6/Compiler.nqp:

[14:47] <dalek> rakudo/repl6: REPL6: Allow the REPL to signal multi-line mode via kwargs

[14:47] <dalek> rakudo/repl6: 

[14:47] <dalek> rakudo/repl6: This is seriously LTA, but returning the sentinel value doesn't

[14:47] <dalek> rakudo/repl6: seem to work, probably due to containerization or something.  I

[14:47] <dalek> rakudo/repl6: never really liked the sentinel solution, so I'll be forced to

[14:47] <dalek> rakudo/repl6: think of a better way to do this overall before I merge back into

[14:47] <dalek> rakudo/repl6: nom

[14:47] <dalek> rakudo/repl6: review: https://github.com/rakudo/rakudo/commit/3155d1557f

[14:47] <dalek> rakudo/repl6: dcb9738 | hoelzro++ | src/core/REPL.pm:

[14:47] <dalek> rakudo/repl6: REPL6: Handle exceptions that trigger multi-line mode

[14:47] <dalek> rakudo/repl6: review: https://github.com/rakudo/rakudo/commit/dcb9738e93

[14:47] <dalek> rakudo/repl6: e2187cd | hoelzro++ | src/core/REPL.pm:

[14:47] <dalek> rakudo/repl6: REPL6: Implement RAKUDO_DISABLE_MULTILINE

[14:47] <dalek> rakudo/repl6: review: https://github.com/rakudo/rakudo/commit/e2187cdddd

[14:50] *** tmch joined
[14:56] *** partly__ is now known as kalkin

[14:57] *** kalkin is now known as kalkin-

[15:02] *** kolikov joined
[15:02] <kolikov> Hi perl 6 !

[15:03] <moritz> hello kolikov 

[15:03] <perlpilot> kolikov: greetings!

[15:03] <kolikov> morgane, are you still there ?

[15:04] *** sufrostico left
[15:10] <kolikov> For morgane: I did part of the french translation of perl6intro , Naoum Hankache is the original initiator of the project; the git is here https://github.com/hankache/perl6intro

[15:13] *** sufrostico joined
[15:17] <RabidGravy> my brane is really rusty, took me half an hour to get the bits in the right order to pick the stuff out of an MP3 frame header

[15:18] * moritz has a classical "works in dev" moment

[15:20] <moritz> a web app I'm deploying seems to miss half of its layout in staging, and everything is fine in dev

[15:20] <nine> Forgot to add a file to the repo?

[15:20] *** awwaiid joined
[15:21] <moritz> "git status" seems rather clean

[15:21] <moritz> and the last actions were deleting files and reverting local changes, going back to upstream versions

[15:22] <RabidGravy> if in doubt blame the deployment script

[15:22] <RabidGravy> or cosmic rays

[15:22] <TimToady> AlexDaniel: iirc, ∞ turns too quickly into a special opcode that loses its location information, so I didn't stress about that one

[15:23] <AlexDaniel> TimToady: sad

[15:24] <AlexDaniel> or maybe not? How useful are these warnings anyway?

[15:24] <TimToady> they are very useful when you screw up precedence

[15:24] <TimToady> m: my $x = 1, 2;

[15:24] <camelia> rakudo-moar 7bdeba: OUTPUT«WARNINGS for /tmp/BpqVrz67s8:␤Useless use of constant integer 2 in sink context (lines 1, 1)␤»

[15:25] <AlexDaniel> m: my $x = 1, ∞;

[15:25] <camelia> rakudo-moar 7bdeba: ( no output )

[15:25] <AlexDaniel> right

[15:25] <AlexDaniel> indeed

[15:27] <TimToady> also, correcting most of the internal 'is pure' markings in support of that helped a lot with constant-folding optimization

[15:29] <moritz> m: sub f { my $x = 1, 2; say 42 }; 

[15:29] <camelia> rakudo-moar 7bdeba: OUTPUT«WARNINGS for /tmp/iNQn7_HkC8:␤Useless use of constant integer 2 in sink context (lines 1, 1)␤»

[15:29] <TimToady> and the useless useless use warnings showed where we weren't correctly propagating wanted/unwanted context down the tree

[15:29] <moritz> why (lines 1, 1) ?

[15:30] <TimToady> good question

[15:32] *** fireartist left
[15:33] <TimToady> given it used to not report any sink violations inside subroutines, it's an improvement to report too many :)

[15:34] *** awwaiid left
[15:35] *** awwaiid joined
[15:35] <TimToady> m: sub f { my $x = 1, 2+3; say 42 }

[15:35] <camelia> rakudo-moar 7bdeba: OUTPUT«WARNINGS for /tmp/FPrZL4Ts_P:␤Useless use of "+" in expression "2+3" in sink context (line 1)␤»

[15:36] <TimToady> appears to only be the "constant" code

[15:36] <ilmari> is "sink" context equivalent to perl5's "void"?

[15:36] <TimToady> more or less

[15:37] <AlexDaniel> m: sub f { my $x = 1, "test\n" + 5; say 42 } # mmmm! Escaping!

[15:37] <camelia> rakudo-moar 7bdeba: OUTPUT«WARNINGS for /tmp/Lzs1mC4K72:␤Useless use of "+" in expression "\"test\\n\" + 5" in sink context (line 1)␤»

[15:38] <AlexDaniel> m: sub f { my $x = 1, “test\n” + 5; say 42 } # that's probably the reason why it is the first time I see escaping in error messages

[15:38] <camelia> rakudo-moar 7bdeba: OUTPUT«WARNINGS for /tmp/iRvJ3Vy0JK:␤Useless use of "+" in expression "“test\\n” + 5" in sink context (line 1)␤»

[15:38] <Hotkeys> MARNIN

[15:39] <TimToady> that bit of expression widening/reporting code already existed before I got my mits on it

[15:39] *** awwaiid left
[15:41] * TimToady tends to leave the extra quotes off when the piece of error message is sufficiently different from words that will stand out visually

[15:41] * TimToady removed a lot of quotes from error messages for that reason in Nov and Dec

[15:42] <TimToady> ( but obviously not that one :)

[15:42] <TreyHarris> Where is ∞ discussed? I'm not finding it in perl6/specs or perl6/docs (except in contexts where it seems to mean things other than you're discussing

[15:43] <TimToady> it's just Inf

[15:43] <TimToady> but ∞ is one less keystroke if you count the shift :)

[15:43] <TimToady> m: say ∞ eqv Inf

[15:43] <camelia> rakudo-moar 7bdeba: OUTPUT«True␤»

[15:44] <AlexDaniel> TreyHarris: here: http://doc.perl6.org/language/unicode_texas

[15:47] *** sufrostico left
[15:48] <AlexDaniel> .u 𝑒

[15:48] <yoleaux> U+1D452 MATHEMATICAL ITALIC SMALL E [Ll] (𝑒)

[15:48] <nine> m: say ∞.perl

[15:48] <camelia> rakudo-moar 7bdeba: OUTPUT«Inf␤»

[15:49] <AlexDaniel> m: say ∞⁰

[15:49] <camelia> rakudo-moar 7bdeba: OUTPUT«1␤»

[15:49] *** sufrostico joined
[15:49] <TreyHarris> AlexDaniel: no, I got it, I just didn't understand why my $x = 1, 2 generates a warning but my $x = 1, Inf does not, and that seems to be the crux of the higher-level discussion.

[15:50] <perlpilot> m: say ∞ ** ∞;

[15:50] <camelia> rakudo-moar 7bdeba: OUTPUT«Inf␤»

[15:50] <perlpilot> :-)

[15:50] <TimToady> then you have to look at the higher-level in the conversion to see the reason :)

[15:50] <AlexDaniel> m: say 0_0

[15:50] <camelia> rakudo-moar 7bdeba: OUTPUT«0␤»

[15:51] <TimToady> (meaning about 30 minutes ago up the page)

[15:51] *** awwaiid joined
[15:51] *** sno joined
[15:52] <TreyHarris> TimToady: oh, the Inf losing its location information pretty quick comment? That confused me at the time and I went off looking for some special use of the ∞ symbol. Got it now, thanks.

[15:52] <perlpilot> Why are superscript and subscript not modifiers on existing characters in unicode?  That seems weird to me.

[15:53] <AlexDaniel> m: say    \(0_0)/    1 # more smileys in perl 6 code!

[15:53] <camelia> rakudo-moar 7bdeba: OUTPUT«1␤»

[15:53] <AlexDaniel> perlpilot: well, ¹ and ² existed long before everything else

[15:54] <TreyHarris> perlpilot: because unicode can't do modifiers to change the relative size of characters, so small versions of characters that mean something different from large versions of characters aren't something that's allowed as something you can express in unicode. otherwise we could do small caps directly without tricks

[15:54] <AlexDaniel> .u ¹²³

[15:54] <yoleaux> U+00B2 SUPERSCRIPT TWO [No] (²)

[15:54] <yoleaux> U+00B3 SUPERSCRIPT THREE [No] (³)

[15:54] <yoleaux> U+00B9 SUPERSCRIPT ONE [No] (¹)

[15:54] <AlexDaniel> .u ⁴

[15:54] <yoleaux> U+2074 SUPERSCRIPT FOUR [No] (⁴)

[15:54] <TreyHarris> yes, and also AlexDaniel's historical reasons. The superscript and subscript number block doesn't include those because they were already in the U+00B0 block

[15:54] <AlexDaniel> meh, it is even weirder

[15:55] <timotimo> rudi_s: it didn't seem like anybody answered your question, but i think triangle reduce would be what you want for the individual parts of the path

[15:55] <timotimo> m: say ([\~] <foo bar baz quux>).perl

[15:55] <camelia> rakudo-moar 7bdeba: OUTPUT«("foo", "foobar", "foobarbaz", "foobarbazquux").Seq␤»

[15:56] *** awwaiid left
[15:56] <AlexDaniel> TreyHarris: better question is why the f… some letters are missing

[15:56] <timotimo> oh, it was answered

[15:56] *** awwaiid joined
[15:56] *** notbenh_ joined
[15:57] <AlexDaniel> ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖ WHERE IS Q? ʳˢᵗᵘᵛʷˣʸᶻ

[15:57] <jnthn> Good q...

[15:58] <TreyHarris> AlexDaniel: h, k, l, m, n, p, s and t were ones that were needed for IPA as modifiers to represent various environmental contexts for other main sounds. (like tₕ which you probably can't read but is t with an h superscript, is the t in "thali", like you get at Indian restaurants)

[15:58] <perlpilot> It's in Unicode version N > 8 somewhere ;)

[15:59] <TimToady> the boundary between plaintext and rendering is ill-defined, and many of the existing Unicode characters were envisioned for one use but not for another potentially valid use

[16:00] <AlexDaniel> but in the end it is still ridiculous that there is no q :/

[16:00] <TimToady> we're all ridiculous if we look hard enough :)

[16:00] <AlexDaniel> true

[16:01] <TreyHarris> AlexDaniel: to indicate devoicing with uvularization? I don't think that's physiologically possible ;)

[16:01] <TimToady> well, if languages can have voiceless vowels... :)

[16:02] <TimToady> otoh, I haven't found a language that uses a triple trill, but I can do one :)

[16:02] <hoelzro> I never really understood how voiceless vowels worked

[16:02] <hoelzro> are they just whispered?

[16:02] <AlexDaniel> TreyHarris: to indicate the fullness of one particular alphabet :)

[16:02] *** awwaiid left
[16:02] <hoelzro> also does GoodMorning[:perl6];

[16:03] <timotimo> hey hoelzro 

[16:03] <hoelzro> ahoy timotimo!

[16:03] <TimToady> we just think of them all as 'h' in English, but they really do sound different, compare 'has' with 'hoop'

[16:03] *** jjido left
[16:03] <TreyHarris> TimToady: the unvoiced linguolabial trill is also something anyone can do (and many do do, and even carries semantics!) but is found in no language's phonetics

[16:03] <TimToady> or 'he' with 'hop'

[16:03] <AlexDaniel> after all we have this: 𝐚𝐛𝐜𝐝𝐞𝐟𝐠𝐡𝐢𝐣𝐤𝐥𝐦𝐧𝐨𝐩𝐪𝐫𝐬𝐭𝐮𝐯𝐰𝐱𝐲𝐳

[16:03] <timotimo> hoelzro: i'm really glad you're working on the multi-line stuff :)

[16:04] <TimToady> TreyHarris: I wouldn't be so sure about that

[16:04] <TimToady> considering half the world's languages are still basically unstudied

[16:04] <TreyHarris> TimToady: True, and it does have a symbol r̼̊ just in case, but it's never been attested.

[16:04] <AlexDaniel> m: my $𝐭𝐞𝐬𝐭 = 25; say $𝐭𝐞𝐬𝐭

[16:04] <camelia> rakudo-moar 7bdeba: OUTPUT«25␤»

[16:04] <hoelzro> timotimo: right now it's just porting it to Perl 6, but it feels *so* good

[16:04] <hoelzro> the code feels so much cleaner to me

[16:04] <AlexDaniel> m: my $𝖙𝖊𝖘𝖙 = 25; say $𝖙𝖊𝖘𝖙

[16:04] <camelia> rakudo-moar 7bdeba: OUTPUT«25␤»

[16:05] <TimToady> afk for a while &

[16:05] <timotimo> understandably :)

[16:05] <hoelzro> granted, that might partly be "I did it this way last time, and that was wrong"

[16:05] <hoelzro> I just wish I were working on it more; coursera + language of the month is taking up a lot of time

[16:06] <timotimo> it's fine to prioritize self-improvement a bit :)

[16:08] *** awwaiid joined
[16:10] <hoelzro> =)

[16:10] <hoelzro> on the plus side, I used a *lot* of Perl 6 for this month's language of the month idea

[16:10] * hoelzro .oO( maybe I should just make Perl 6 the language of the month for every month... )

[16:11] *** atweiden joined
[16:11] <atweiden> m: my Bool %aoh-seen{Array}; my @path = 'products'; %aoh-seen{$@path}++; %aoh-seen{$@path}++; say %aoh-seen.perl;

[16:11] <camelia> rakudo-moar 7bdeba: OUTPUT«(my Bool %{Array} = (["products"]) => Bool::True)␤»

[16:11] <atweiden> m: my Bool %aoh-seen{Array}; for 0..1 { my @path = 'products'; %aoh-seen{$@path}++; }; say %aoh-seen.perl;

[16:11] <camelia> rakudo-moar 7bdeba: OUTPUT«(my Bool %{Array} = (["products"]) => Bool::True, (["products"]) => Bool::True)␤»

[16:12] <atweiden> is this a bug?

[16:13] <gtodd1> Inline::R

[16:13] <moritz> atweiden: I don't think so

[16:13] <rudi_s> timotimo: I've noticed that I also need to get the remaining part of the path and adapted my current solution. - But thanks. 

[16:13] <moritz> atweiden: arrays aren't value types

[16:13] <moritz> atweiden: so you need to use the same array twice if you want to access the same slot in the hash twice

[16:14] <moritz> m: say (my @ = 'products') === (my @ = 'products)

[16:14] <camelia> rakudo-moar 7bdeba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/UHr0xuY4z0␤Unable to parse expression in single quotes; couldn't find final "'" ␤at /tmp/UHr0xuY4z0:1␤------> 3y @ = 'products') === (my @ = 'products)7⏏5<EOL>␤    expecting any of:␤        sing…»

[16:14] <moritz> m: say (my @ = 'products') === (my @ = 'products')

[16:14] <camelia> rakudo-moar 7bdeba: OUTPUT«False␤»

[16:15] <ugexe> m: my $x = 1..*; Supply.from-list($x).tap: { once { say $x }; } # seems odd to me that $x.map: {.say} iterates the range but .from-list treats $x as a single Range

[16:15] <camelia> rakudo-moar 7bdeba: OUTPUT«1..Inf␤»

[16:16] <ugexe> oh duh, i need to wake up. i mean `once { say $_; }`

[16:16] <Juerd> "once" is lousy obfuscation. You should use $++//do instead.

[16:17] *** awwaiid left
[16:17] *** awwaiid joined
[16:17] <ugexe> its just to keep it from spitting out a bunch of extra results that arent needed in the chat room

[16:17] *** ely-se left
[16:17] <ugexe> if it worked as i thought it would

[16:17] <atweiden> moritz: is another Positional type easier to use?

[16:17] *** telex joined
[16:18] *** khw joined
[16:19] <Juerd> m: my $x = 1..*; Supply.from-list(flat $x).tap: *.say;

[16:19] <camelia> rakudo-moar 7bdeba: OUTPUT«1..Inf␤»

[16:19] <atweiden> seems grepping with eqv is the only way then to practically use such a hash

[16:19] <Juerd> Hmm

[16:19] <ugexe> you can do @$x, but still

[16:19] <Juerd> m: my $x = 1..*; Supply.from-list(|$x).tap: *.say;

[16:19] <ugexe> that will timeout

[16:19] <Juerd> That takes long enough :)

[16:19] <jnthn> m: my $x = 1..*; for $x { .say }

[16:20] <camelia> rakudo-moar 7bdeba: OUTPUT«(timeout)»

[16:20] <camelia> rakudo-moar 7bdeba: OUTPUT«1..Inf␤»

[16:20] <jnthn> It's consistent with that.

[16:20] <ugexe> because its trying to allocate 1..Inf

[16:20] <jnthn> m: my $x = 1..*; for @$x { .say }

[16:20] *** dwarring left
[16:20] <Juerd> I probably wouldn't run into this because my instincts say that lists go in @, not $

[16:20] <jnthn> And .from-list needing @$x also is

[16:20] <camelia> rakudo-moar 7bdeba: OUTPUT«(timeout)1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤30␤31␤32␤33␤34␤35␤36␤37␤38␤39␤40␤41␤42␤43␤44␤45␤46␤47␤48␤49␤50␤51␤5…»

[16:20] <ugexe> i see. my confusion is just from the map/grep example then

[16:21] <ugexe> $x.map: {.say}

[16:22] <jnthn> Yeah, . is a "dereference" in that sense; you're talking about the thing inside the Scalar container

[16:22] <Juerd> Methods are more likely to coerce types to something more appropriate, in general.

[16:22] <Juerd> Especially with your own types, you can expect more cooperation from (your own) methods than from language features

[16:23] <atweiden> m: my Bool %aoh-seen{Array}; for 0..1 { my @path = 'products'; %aoh-seen{$@path}++; }; say %aoh-seen.perl; say %aoh-seen{$['products']}.perl;

[16:23] <camelia> rakudo-moar 7bdeba: OUTPUT«(my Bool %{Array} = (["products"]) => Bool::True, (["products"]) => Bool::True)␤Bool␤»

[16:25] *** awwaiid left
[16:26] <ugexe> i saw that problem on SO

[16:26] <ugexe> m: my @p = "products"; my $p2 = ["products"]; say @p eqv $p2; say @p === $p2

[16:26] <camelia> rakudo-moar 7bdeba: OUTPUT«True␤False␤»

[16:27] *** jjido joined
[16:37] *** nakiro left
[16:38] <ugexe> is there a name for using the proxy pattern to return aggregated results from all the possible proxy end points? or is it just referred to as a proxy pattern that happens to aggregates?

[16:40] <RabidGravy> could do with something snappier if there isn't

[16:40] <RabidGravy> the "Supermarket Sweep Pattern"

[16:42] *** awwaiid joined
[16:43] <ugexe> and limit myself to only 4 large hams?

[16:44] <RabidGravy> or go down the booze aisle ang guzzle the lot before you get to the checkout

[16:47] <timotimo> is "supermarket sweep pattern" the thing you use to order items on your shopping list properly?

[16:47] <RabidGravy> today I officially hate software, I got sidetracked wondering why libshout wasn't working in the same process as IO::Socket::Async, looked at the source, thought OooOOOOoh that's really easy to implement in Perl6 ....

[16:48] <RabidGravy> ... realised I would need to pick the frame info out of the MP3 stream to get the sync right, and now have wound up worrying what to call what has turned into the resulting module

[16:49] <ugexe> timotimo: there is nothing proper about the shopping that took place on supermarket sweep

[16:49] <ugexe> unless you live off large hams, bags of coffee, and toothpaste

[16:50] *** cpage_ left
[16:51] *** domidumont left
[16:53] *** jjido left
[16:55] *** jjido joined
[16:57] *** jjido left
[17:07] <Skarsnik> RabidGravy, Do you think it came from H::UA error:00000000:lib(0):func(0):reason(0)

[17:07] <Skarsnik> ? It crash on a send request

[17:07] <ugexe> thats openssl

[17:07] <RabidGravy> I'm going with ssl too

[17:09] <Skarsnik> than an useful error x)

[17:09] <ugexe> none of the openssl errors really are

[17:11] <Skarsnik> hm, I have no idea how to prevent this to happen aside with a try x)

[17:11] <ugexe> try deleting your precomp folders/installs

[17:11] <arnsholt> RabidGravy: I suggest Yak::Shave =)

[17:11] <Skarsnik> It crash on a request I do every 2 sec and I already send a thousand of it x)

[17:12] *** awwaiid left
[17:13] <RabidGravy> arnsholt, if I started down that route there would be Yak::Shave::1 .. Yak::Shave::200 by now

[17:14] <ugexe> i just bumped the version of openssl. an interface change was added yesterday without a version change... dunno if it matters

[17:15] *** sufrostico left
[17:15] <ugexe> i seem to hit precomp problems though when things are required at runtime, so always IO::Socket::SSL, using old precomp files

[17:16] <ugexe> deleting all precomp stuff has always fixed it for me

[17:16] *** domidumont joined
[17:17] <Skarsnik> It crash after like 6hours of running

[17:17] <Skarsnik> it's not like it crash on start

[17:17] <ugexe> ah

[17:17] *** sufrostico joined
[17:18] *** zpmorgan joined
[17:18] <RabidGravy> I can't suggest anything other than look in the openssl code to find where it generates the error and begin instrumenting

[17:18] *** zakharyas left
[17:20] <RabidGravy> if the message is what you got verbatim then I would say that it probably is something that should be guarded and isn't (i.e. it isn't an error at all but got to the error handler because it wasn't stopped from doing so, like the socket returned 0 bytes for perfectly sensible reasons)

[17:21] <Skarsnik> Probably need to catch openssl error in h:ua too?

[17:22] <RabidGravy> not really, special handling for different network drivers would lead to madness 

[17:22] *** sevvie joined
[17:22] <Skarsnik> Yes, but it make h::ua crash

[17:23] <Skarsnik> not even throwing an error

[17:23] <Skarsnik> like socket error or something

[17:23] <RabidGravy> but the same thing would happen if IO::Socket threw an exception

[17:24] <RabidGravy> except I think this is a bug in openssl and should be fixed there

[17:25] <Skarsnik> Yes but I mean I kind of want to have a try {} CATCH X::SocketError ( do something like retry)

[17:26] <RabidGravy> so what exception does the OpenSSL throw?

[17:27] <Skarsnik> No idea, h:ua get going and crash because something ended to be Any, instead of data

[17:27] <RabidGravy> and how does that differ from the exceptions that IO::Socket throws

[17:28] <RabidGravy> sorry you're being confusing now, so where did that error you pasted above come from?

[17:28] <RabidGravy> was that just printed and the OpenSSL returns nothing?

[17:28] <RabidGravy> then it's still a bug in OpenSSL which should be fixed

[17:28] <Skarsnik> Yes, just printed

[17:29] <RabidGravy> eugh

[17:29] <Skarsnik> damn, I should not have restarted the script, I lost the trace

[17:29] *** musiKk_ joined
[17:29] *** themonkeybob11 left
[17:32] <Skarsnik> it crashed on http::response (on one of the new method), that was the only bt perl6 give me, It was after the openssl display

[17:35] *** themonkeybob11 joined
[17:36] <Skarsnik> I will take a look later, brb x)

[17:37] <RabidGravy> In that case the recv in get-response is not returning a Blob, which is a bug in OpenSSL

[17:38] *** kolikov left
[17:55] *** tmch left
[18:00] <pyrimidine> Ulti: it has to be a student, but I think anyone can mentor 

[18:01] <pyrimidine> (re: GSoC)

[18:03] <pyrimidine> Ulti: also, not limited to just OBF projects (Bio*).  

[18:05] *** virtualsue joined
[18:06] * perlpilot suddenly wishes Perl5 had a "once" statement prefix

[18:08] <perlpilot> I just edited a subroutine that used a state var with initialization, but the initialization needed to be slightly more complicated, but not enough that I wanted to stick it in its own sub

[18:09] <jnthn> state var calling lexical sub?

[18:09] <perlpilot> (I could still use "do", but it really feels like a "once" situation)

[18:09] <jnthn> With it's init calling, I mean... :)

[18:10] <perlpilot> It's just weird how I'm thinking about Perl 5 code these days.

[18:10] <perlpilot> I used to always grouse about the gyrations that other languages put you through to get things done and now I'm doing the same about Perl 5 because Perl 6 exists :)

[18:16] <SmokeMachine____> Can I create a Jar from a perl6 code?

[18:20] <perlpilot> SmokeMachine____: I have absolutely no knowledge about whether or not you can do this, but my guess would be "no".

[18:21] <arnsholt> Assuming you're one the JVM backend, I think precomp is a JAR

[18:21] <timotimo> yeah, but you can't just java -jar it, i don't think

[18:22] <ugexe> truuu

[18:22] <arnsholt> Yeah, you can't

[18:22] <timotimo> .o( tu tu ru )

[18:23] *** rntz left
[18:24] *** espadrine left
[18:24] *** rntz joined
[18:24] <SmokeMachine____> why not?

[18:25] <arnsholt> It depends on the rest of the NQP and Rakudo code

[18:26] *** lizmat joined
[18:26] <SmokeMachine____> isn't the NQP running on the JVM too?

[18:26] <timotimo> "depends on" not in the traditional sense of dependency. it's actually depending on "being loaded and invoked" by the other code, if i'm not mistaken

[18:26] <arnsholt> I think the code should work if you also load the NQP and Rakudo JARs, but I'm not sure if that'll trigger execution of any mainline code in your precomped stuff

[18:26] <geekosaur> I think the point is it is not a self-contained jar, but requires a bunch of other jars comprising perl6, nqp, etc.

[18:27] <arnsholt> Exactly. The precomped JAR doesn't actually contain the NQP and Rakudo JARs

[18:27] <timotimo> we can build something that'll add a proper entry point that'll run the contained code

[18:27] <SmokeMachine____> but I could create a class on a jar and use it on a java code?

[18:27] <timotimo> you could use it, but that requires a lot of care

[18:27] <timotimo> it wouldn't behave too much like regular java code

[18:31] <SmokeMachine____> assuming that I would use the NQP and Rakudo jars, how could I generate the jar of my class?

[18:32] <timotimo> you don't get a jar per class, you get a jar per compilation unit

[18:33] <SmokeMachine____> my intention is only generate a jar of a custom perl6 code and look at the bitecode...

[18:34] <timotimo> ah

[18:34] <timotimo> well, then. the --target= argument is for you

[18:34] <timotimo> together with a -o for the output filename

[18:34] <SmokeMachine____> --target=jar?

[18:34] <timotimo> --stagestats gives you a list of what targets are available. i don't know exactly which one is right for you

[18:34] <timotimo> it's probably "jar", yeah

[18:34] <timotimo> if you get an error, it's some other stage you need to ask for 

[18:36] *** labster joined
[18:37] <SmokeMachine____> thanks!

[18:40] *** wamba left
[18:41] *** virtualsue left
[18:47] <arnsholt> SmokeMachine____: If you're interested in the bytecode generated, you should probably look at the code that generates the bytecode as well. It's mostly NQP code in the NQP repo, but IIRC Rakudo has some additional custom bits as well

[18:49] *** vendethiel joined
[18:50] *** awwaiid joined
[18:53] *** musiKk_ left
[18:53] *** virtualsue joined
[18:58] *** araujo left
[18:58] *** araujo joined
[18:58] *** cdg_ left
[19:00] <RabidGravy> just a sanity check here, in C assuming "header" is uint32 I have "(header >> 20) & 0x0fff;"  the equivalent in P6 is "($header +> 20) +& 0x0FFF" right?

[19:00] <nine> I'd say yes

[19:01] <nine> or just $header / 2**20

[19:02] <nine> or rather $header div 2**20

[19:04] *** spider-mario joined
[19:06] *** tmtowtdi joined
[19:07] <timotimo> "just"? i think bitwise operations are faster on the cpu than division is

[19:08] *** awwaiid left
[19:08] *** awwaiid joined
[19:08] <RabidGravy> Hmm, either way I'm getting something different that what I expected

[19:11] *** lizmat left
[19:13] <nine> timotimo: I'm sure they are. Question is if in Perl 6 is is the same. It's 2 operators instead of just one after all.

[19:14] <timotimo> huh?

[19:15] <timotimo> you mean the +& is redundant?

[19:15] <nine> It is redundant for a uint32, isn't it?

[19:15] <timotimo> i guess so

[19:15] <geekosaur> it would be redundant if it were 0xFFFF

[19:15] *** vendethiel left
[19:15] <timotimo> thank you for checking :)

[19:18] <geekosaur> hm, technically for 20 bits, yeh

[19:19] * geekosaur tracking a bit slowly today, should not have had to work that out :(

[19:21] <geekosaur> wonder if that was copied from pre-ANSI C where right shift could have undefined behavior wrt sign bit regardless of signed/unsigned (that is a compiler on a platform without built-in logical shift right could use the arithmetic one even on unsigned)

[19:22] <geekosaur> ...more likely just cargo cult

[19:22] *** lizmat joined
[19:23] *** themonkeybob11 left
[19:27] <sjn> \o

[19:27] * sjn found something weird with the now() function

[19:28] <timotimo> m: say &now

[19:28] <camelia> rakudo-moar 7bdeba: OUTPUT«5===SORRY!5=== Error while compiling /tmp/8yPIKGVHHB␤Undeclared routine:␤    now used at line 1. Did you mean 'not', 'HOW'?␤␤»

[19:28] <timotimo> it's not a function :)

[19:28] <timotimo> m: say now

[19:28] <camelia> rakudo-moar 7bdeba: OUTPUT«Instant:1457119725.794821␤»

[19:28] <timotimo> it's a term

[19:28] <sjn> hehe

[19:28] <sjn> fair enough

[19:28] <sjn> date +"0 Instant:%s.%N"; perl6 -e'say "1 " ~ now; INIT say "2 " ~ now; say "3 " ~ now ;'; date +"4 Instant:%s.%N"

[19:28] <sjn> run this in a sell

[19:28] <sjn> shell*

[19:29] <sjn> I've tested it on a few computers, and all of them have a weird 4th timestamp

[19:29] <sjn> it's like stepping back in time

[19:30] *** SCHAAP137 joined
[19:30] *** lizmat left
[19:30] *** vendethiel joined
[19:31] <sjn> anyone else here getting a weird output?

[19:31] <perlpilot> weird how?

[19:31] *** AlexDaniel left
[19:32] <sjn> the output of date is much more different than I'd expect

[19:33] <timotimo> yeah, it has an extra space there

[19:33] <timotimo> here's a tip for you:

[19:33] <timotimo> m: say now - time

[19:33] <camelia> rakudo-moar 7bdeba: OUTPUT«Instant:36.318187␤»

[19:33] <sjn> no, don't think about the space

[19:33] <timotimo> sorry, missing a space i meant :)

[19:34] <sjn> here, the timestamp offered by perl6 is some 36 seconds off

[19:34] <perlpilot> sounds like leap second differences

[19:34] <sjn> really?

[19:34] <timotimo> yes, that's exactly it

[19:35] *** musiKk_ joined
[19:35] <sjn> doesn't perl6 get it's time from the system?

[19:35] <sjn> why would perl6 muck around with that?

[19:36] <timotimo> because Instant is monotonous

[19:36] <moritz> Perl 6 offers both civil time and TAI

[19:36] <timotimo> huggable: Instant

[19:36] <huggable> timotimo, class Instant [Specific moment in time]: http://doc.perl6.org/type/Instant

[19:36] <timotimo> An Instant is a particular moment in time measured in atomic seconds, with fractions. It is not tied to or aware of any epoch.

[19:37] <moritz> the idea is that you use Instant when you need to control intervals

[19:37] <moritz> like, you don't want to run your microwave for 31 instead of 30 seconds if there happens to be a leap second during that duration

[19:37] <sjn> and it doesn't matter if the Instant is 36 seconds out of sync with the real world?

[19:37] <moritz> sjn: it's not out of sync with TAI

[19:38] <moritz> sjn: only with UTC

[19:38] <nine> Bottom line: time is complicated

[19:40] <geekosaur> sjn, there are regular arguments over whether leap seconds should even exist much less when they should be paid attention to

[19:41] <azawawi> https://github.com/azawawi/perl6-memoize/blob/master/t/01-load.t#L53  # Implicit 'is pure' added to 'is memoized'. sortiz++

[19:41] *** themonkeybob11 joined
[19:41] <azawawi> https://github.com/azawawi/perl6-memoize/blob/master/lib/Memoize.pm6#L108  # More documentation of options. Feedback is welcome

[19:44] *** telex left
[19:44] <sjn> oh joy

[19:44] *** telex joined
[19:45] *** lostinfog joined
[19:45] *** lizmat joined
[19:47] <lizmat> m: sub a($a,$b) {}; dd &a.signature.params, :($a,$b).params  # there's a spectest that thinks these are equal

[19:47] <camelia> rakudo-moar 7bdeba: OUTPUT«($a, $b)␤(Mu $a, Mu $b)␤»

[19:48] *** FROGGS joined
[19:49] *** tmch joined
[19:51] * moritz finally put together the landing page for his book project: http://deploybook.com/

[19:51] <moritz> feedback welcome!

[19:51] *** vendethiel left
[19:52] *** lizmat_ joined
[19:52] <gtodd1> does anyone here use "R" for stats ? ... along with PDL of course :-)

[19:52] * azawawi reads it

[19:52] <gtodd1> sometimes the R "repl" (it's not really just a repl) is so ... nice

[19:53] *** gtodd1 is now known as gtodd

[19:53] <hoelzro> gtodd: I use it

[19:53] <hoelzro> its REPL is pretty nice

[19:53] <hoelzro> esp. the ability to save workspace images

[19:53] *** lizmat left
[19:54] *** lizmat_ is now known as lizmat

[19:54] <lizmat> m: sub a($a,$b) {}; dd &a.signature.param[0].type

[19:54] <camelia> rakudo-moar 7bdeba: OUTPUT«Method 'param' not found for invocant of class 'Signature'␤  in block <unit> at /tmp/dzd4NYlLew line 1␤␤»

[19:54] <lizmat> m: sub a($a,$b) {}; dd &a.signature.params[0].type

[19:54] <camelia> rakudo-moar 7bdeba: OUTPUT«Any␤»

[19:54] * sjn reads about TAI, UTC and UT1

[19:54] <gtodd> sometimes I think it's just the saving of work (objects data etc) in .Rdata in per directory per project "images" that I find refreshingly likeable 

[19:55] <hoelzro> yeah, it's super nice

[19:55] <gtodd> hoelzro: hehe yeah that ... "save current workspace?" -> .Rdata images

[19:55] *** virtualsue left
[19:55] <azawawi> moritz: right paragraphs need text justification and text is getting outside of the white box on my firefox browser

[19:55] <hoelzro> when working on R scripts, I'll often "checkpoint" by calling save.image()

[19:55] <hoelzro> so that if something fails shortly thereafter, I can play around with the "bad" idea

[19:56] <gtodd> hoelzro: that seems a common workflow pattern

[19:56] <hoelzro> s/idea/data/

[19:56] *** ashevchuk joined
[19:56] <lizmat> jnthn: sub a($a) 's sig of Any $a whereas :($a) 's sig is Mu $a

[19:56] *** musiKk_ left
[19:56] <lizmat> jnthn: there's a spectest that assumes the sigs are eqv

[19:57] <lizmat> I think either that test is wrong, or building a sig with :($a) is wrongly assuming Mu rather than Any

[19:58] <sjn> useful reading regarding leap seconds, UTC, TAI and UT1 --> http://www.madore.org/~david/computers/unix-leap-seconds.html

[19:58] <TimToady> I would be inclined to think that :($a) would be more like a block signature than a routine signature

[19:58] <lizmat> TimToady: so hence the Mu is correct ?

[19:58] <lizmat> and the test is wrong ?

[19:59] <TimToady> that's my leaning, unless someone can think of a good reason to have it the other way

[19:59] <gtodd> hoelzro: other programming languages (Haskell, perl5?  and I suppose one day perl6) have some variant of Inline::R because sometimes it's nice to "orchestrate" R in some fashion ... *BUT* it's pretty cool how much the built in parts of perl6 allow you to do things with arrays/matrices etc.  (PDL inspired?) out of the box with perl6

[19:59] <lizmat> feels right to me... 

[20:00] <TimToady> the block/routine distinction is in support of junction threading, and I don't see much use for threading :($a) offhand...

[20:00] <hoelzro> gtodd: Inline::R is in my Perl 6 "create me" list

[20:00] <moritz> azawawi: could you please give a screenshot?

[20:00] <hoelzro> along with like 100 others =P

[20:00] <TimToady> gtodd: yes, somewhat inspired by PDL

[20:01] <TimToady> at least wanting to get close enough that we could extend in the PDL direction

[20:01] <lizmat> ok, so I will assume the test is wrong, correct the test, also correct in 6c-errata and mark as todo there

[20:03] <azawawi> moritz: http://pasteboard.co/21nEyeof.png and http://pasteboard.co/21nHxTde.png (Firefox on win7 Pro 64-bit)

[20:03] <TimToady> lunch &

[20:05] <gtodd> TimToady: good plan :-)  ... and if perl6 becomes the master orchestrator of other languages (via Nativecall etc)  all those R libraries can join in harmonious cooptation

[20:06] <gtodd> erm   s/cooptation/cooperation/

[20:10] <moritz> azawawi: thanks, will take a look

[20:11] <dalek> roast/6.c-errata: 43d3db6 | lizmat++ | S02-names-vars/signature.t:

[20:11] <dalek> roast/6.c-errata: :() sigs are more like block sigs than sub sigs

[20:11] <dalek> roast/6.c-errata: 

[20:11] <dalek> roast/6.c-errata: As discussed at http://irclog.perlgeek.de/perl6/2016-03-04#i_12139599

[20:11] <dalek> roast/6.c-errata: review: https://github.com/perl6/roast/commit/43d3db61f5

[20:12] <dalek> roast: 27010e5 | lizmat++ | S02-names-vars/signature.t:

[20:12] <dalek> roast: :() sigs are more like block sigs than sub sigs

[20:12] <dalek> roast: 

[20:12] <dalek> roast: As discussed at http://irclog.perlgeek.de/perl6/2016-03-04#i_12139599

[20:12] <dalek> roast: review: https://github.com/perl6/roast/commit/27010e59df

[20:14] *** darutoko left
[20:17] *** tharkun left
[20:17] *** tharkun joined
[20:19] *** kid51 joined
[20:21] *** kid511 joined
[20:24] *** kid51 left
[20:28] <dalek> roast: 70ed68a | lizmat++ | packages/Test/Idempotence.pm:

[20:28] <dalek> roast: Add some more diagnostics on failure

[20:28] <dalek> roast: review: https://github.com/perl6/roast/commit/70ed68a036

[20:28] *** brrt joined
[20:30] *** azawawi left
[20:37] *** mykhailyk joined
[20:39] *** domidumont left
[20:44] *** Vitrifur left
[20:45] *** vendethiel joined
[20:47] *** cpage_ joined
[20:53] *** bjz left
[20:55] *** sufrostico left
[21:01] *** domidumont joined
[21:05] *** cpage_ left
[21:05] *** cpage_ joined
[21:07] *** bjz joined
[21:12] *** musiKk_ joined
[21:14] *** brrt left
[21:15] <dalek> rakudo/nom: eac1e26 | lizmat++ | src/core/Parameter.pm:

[21:15] <dalek> rakudo/nom: Make Parameter.perl's default more informative

[21:15] <dalek> rakudo/nom: 

[21:15] <dalek> rakudo/nom: :($a = 2) became :($a = { ... }) instead before

[21:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eac1e26d63

[21:16] *** sortiz joined
[21:19] *** cdg joined
[21:20] <sortiz> \o #Perl6

[21:21] *** domidumont left
[21:25] <RabidGravy> harr!

[21:26] <ggoebel17> .seen Tux

[21:26] <yoleaux> I haven't seen Tux around.

[21:26] <moritz> ggoebel17: he's called [Tux] here

[21:26] <RabidGravy> okay on the third new todo stack of the day.  I think stop writing software and make with the beer drinking

[21:26] <lizmat> I think [Tux] is on holiday...

[21:26] <lizmat> .seen [Tux] 

[21:26] <yoleaux> I saw [Tux] 26 Feb 2016 08:31Z in #perl6: <[Tux]> csv-parser      49.385

[21:26] <ggoebel17> .seen [Tux]

[21:26] <yoleaux> I saw [Tux] 26 Feb 2016 08:31Z in #perl6: <[Tux]> csv-parser      49.385

[21:27] <RabidGravy> but I did discover that libshout gets the mp3 from parsing totally wrong

[21:27] <RabidGravy> frame

[21:27] <ggoebel17> okay... I've been looking for his regular test run ever since lizmat++ and jnthn++ have been landing all their performance improvements

[21:28] <lizmat> pretty sure we'll see one on Monday or thereabouts again

[21:28] <lizmat> I can run the test as well, but I get different numbers because of different OS / CPU's and so

[21:29] *** Vitrifur joined
[21:29] *** vendethiel left
[21:31] <sortiz> Anyone know why in DBIish the 'legacy' $sth.fetchrow method, and relatives, returns all data as Str ? # Even p5 DBI returns numeric values as perl numbers

[21:33] <mykhailyk> So, perl6 is more like Python ?

[21:34] <perlpilot> mykhailyk: that's not a very good troll.  You can do better  :)

[21:34] <mykhailyk> lol, i am not really trolling, but i believe it may sound like

[21:36] <Skarsnik> sortiz, probably because mysql always give a char *

[21:36] *** sevvie left
[21:36] *** cpage_ left
[21:36] <perlpilot> perl 6 is more like Perl 5 but with a type system, multiple dispatch, Moose, exceptions, grammars, etc built-in.

[21:37] <Skarsnik> and perl5 has something else that scalar?

[21:38] <perlpilot> And while I can see some minor similarities where Perl 6 and Python would intersect, I wouldn't say it's "like Python" very much  :)

[21:39] <mykhailyk> well, i was looking on some p6 code and my first impression was that

[21:39] <mykhailyk> looks pretty similar

[21:39] <perlpilot> Sure ... Perl6 can be written in many styles.  If you want to forego sigils (for instance), that's possible.

[21:45] *** vendethiel joined
[21:45] <sortiz> Skarsnik, Can be. I'm asking 'cus I would like to change that, the actual distinction between .row and .fetchrow don't have any sense.

[21:45] <Skarsnik> I wanted to remove all the fetch* but moritz wanted to keep them

[21:46] <Skarsnik> You should look at the discusion in the PR

[21:46] <perlpilot> Skarsnik: +1 to removing them IMHO

[21:47] <sortiz> In that respect I agree with Moritz,that facilitates the migration from perl5.

[21:48] <sortiz> s/Moritz/ moritz++

[21:54] <sortiz> Anyway, if preserved, fetch* now isn't compatible with anything.

[21:55] *** skids left
[21:56] <mykhailyk> why perl 5 and perl 6 are on different channels?

[21:57] *** firstdayonthejob joined
[21:57] <mykhailyk> i couldn't imagine python 3.x has #python3 channel and python 2.6 on #python2

[21:57] *** Poroshenko joined
[21:58] <lizmat> I guess Perl 5 and Perl 6 are further apart from each other than Python 2 and Python 3

[21:58] <rudi_s> Hi. Can I make a data structure recursively read-only including objects?

[21:58] <perlpilot> mykhailyk: pretty sure I mentioned why on #perl ... they are different languages.  They share a common ancestry and "spirit", but they are evolving differently.

[21:58] <sortiz> Skarsnik, perl5's scalar isn't a type, as a container is like Scalar, but its values are like our Cool, ie, is auto converted from string to number as needed.

[22:00] <mykhailyk> hum... Python 2 and Python 3 have some significant differences either, they are on the same channel still

[22:00] <mst> python 3 and 2 are incompatible versions of the same language

[22:00] <mst> perl5 and perl6 are substantially different languages

[22:01] <perlpilot> mykhailyk: except that Python 3 tried to remain mostly the same as Python 2 whereas Perl 6 purposefully radically changed from Perl 5.

[22:01] <mst> it's not remotely the same

[22:01] <mst> you're comparing apples to traffic wardens

[22:01] <mst> #perl already explained this to him at length

[22:01] <mst> I'm not sure why he's forcing you to have the same conversation again

[22:01] <mykhailyk> sorry i've missed that

[22:01] <sortiz> mykhailyk, Python 2 and Python 3 are versions the same language, Perl 5 and Perl 6 are different languages.

[22:02] <mst> we said this on #perl :)

[22:02] *** nowan_ left
[22:03] <mykhailyk> okay, but what was the point of giving it the same name ?

[22:04] <sortiz> 'cus "Perl" is more a culture? :-)

[22:05] <mst> basically, an effort to produce an updated version of perl5 was started, called perl6, and then over time it became clear that if we were going to actually improve things a decent amount, the answer was to take the spirit of perl and then design from the ground up

[22:05] <perlpilot> mykhailyk: If you held a page of Perl code at arms length, you would be hard pressed to tell if it was Perl 5 or Perl 6.  It's still "Perl".  Also ... because Larry said so.  :-)

[22:05] <mst> basically, it would originally have been more like python 3 - but as python 3 has demonstrated, it isn't actually enough better to make a lot of people upgrade, and has become a bit of a pain

[22:06] <mst> perl6 OTOH went "stuff it" and made a new language in the perl family; the name speaks to its roots, it's now the sixth perl that Larry's invented

[22:06] <mst> and that's ok :)

[22:06] <jnthn> lizmat, TimToady: fwiw, I agree a sig literal wants to have Mu as its default arg type.

[22:07] <mykhailyk> this is really confusing a bit

[22:07] <perlpilot> mykhailyk: confusing how?

[22:08] <lizmat> jnthn: cool, that means I don't need to revert spectest changes

[22:08] <mst> mykhailyk: we've explained it. we've explained that the origins are basically historical. I'm not sure what else we can do for you.

[22:08] *** atweiden left
[22:08] <ugexe> if only more time had been spent bike shedding the name...

[22:09] *** pdcawley left
[22:10] <mykhailyk> i just can't recognize the logic in having a #perl channel for perl 5, and #perl6 channel for perl 6 on freenode

[22:10] <mykhailyk> there wasn't channel for perl 4 right

[22:10] <mst> perl5 and perl6 are different languages

[22:10] <mst> they have separate communities with a little overlap

[22:10] *** pdcawley joined
[22:10] <mst> therefore they have their own channels

[22:11] <perlpilot> mykhailyk: how about this analogy ... Perl and Ruby are both in the family of dynamic languages, yet we have #perl and #ruby.  #perl and #perl6 make exactly the same amount of sense as that.

[22:11] <RabidGravy> well perl4 and perl5 didn't overlap either

[22:11] <lizmat> mykhailyk: not everything is entirely logic

[22:11] *** FROGGS left
[22:11] <RabidGravy> (though some people persisted in writing perl 4 code in perl 5 well into the 1990s)

[22:12] *** nowan joined
[22:12] <mst> basically, 98% of what's said here isn't of that much interest to the regulars in #perl, and 98% of what's said in #perl isn't of much interest to the regulars in here

[22:12] <perlpilot> RabidGravy: 2000s even.

[22:12] <mst> because they're two different languages

[22:12] <RabidGravy> true

[22:12] <mst> and this is OK

[22:12] <mst> try and avoid imagining extra problems that don't exist - programming is hard enough when you only have to deal with the real ones.

[22:12] <mykhailyk> ok i get it now

[22:12] <RabidGravy> I just wrote a bit mask subroutine because I hate doing bit masks

[22:12] <dalek> rakudo/nom: 259624f | lizmat++ | src/core/Any.pm:

[22:12] <dalek> rakudo/nom: Make dd a little more lenient on bare type objects

[22:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/259624f388

[22:13] <lizmat> RabidGravy: should that need to live in Buf ?

[22:13] <lizmat> or Blob?

[22:16] <dalek> rakudo/nom: 360232a | lizmat++ | src/core/Code.pm:

[22:16] <dalek> rakudo/nom: Make Code.perl a bit more sensical

[22:16] <dalek> rakudo/nom: 

[22:16] <dalek> rakudo/nom: Was "Code.new" before.

[22:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/360232a54f

[22:16] <RabidGravy> I dunno really it's like "make a mask for n bits starting at m in a x size integer" and I guess that I make go extract that as an int

[22:17] *** Poroshenko left
[22:18] <RabidGravy> I do think that blob or buf or some module in the ecosystem could do with exposing the "make a long from these four bytes" that unpack does though

[22:18] <RabidGravy> as I've just copied them for my code currenty

[22:18] <lucs> m: my @a = <a b c>; class Foo { has ｢?｣ for @a; ⋯ } # How to build the class according to some list?

[22:18] <camelia> rakudo-moar eac1e2: OUTPUT«5===SORRY!5=== Error while compiling /tmp/yeozqIoEn2␤Malformed has␤at /tmp/yeozqIoEn2:1␤------> 3my @a = <a b c>; class Foo { has7⏏5 ｢?｣ for @a; ⋯ } # How to build the clas␤»

[22:18] <RabidGravy> lots of "binary" file with bit fields in them

[22:19] <dalek> roast: 4552522 | lizmat++ | integration/advent2009-day20.t:

[22:19] <dalek> roast: Fix Parameter.perl test for defaults

[22:19] <dalek> roast: 

[22:19] <dalek> roast: Before eac1e26d6342d0d65 , it would always be { ... } even if there

[22:19] <dalek> roast: was no code as a default.  The test assumed this.

[22:19] <dalek> roast: review: https://github.com/perl6/roast/commit/4552522a77

[22:21] <RabidGravy> lucs, something like:

[22:21] <RabidGravy> m: my @a = <a b c>; class Foo {}; for @a -> $a { Foo.^add_attribute(Attribute.new(name => $a, type => Str, package => Foo))};

[22:21] <camelia> rakudo-moar eac1e2: ( no output )

[22:22] <lucs> RabidGravy: Aha, thanks, lots of material I can look up in there.

[22:23] <RabidGravy> you could probably do it in the BUILD or something of the class if you want to leave it later, and you'd have to fiddle with the attributes to get accessors and stuff

[22:23] <dalek> roast/6.c-errata: a2ec5a2 | lizmat++ | integration/advent2009-day20.t:

[22:23] <dalek> roast/6.c-errata: Fix Parameter.perl test for defaults

[22:23] <dalek> roast/6.c-errata: 

[22:23] <dalek> roast/6.c-errata: Marked as todo, as this wouldn't be ok in 2015.12

[22:23] <dalek> roast/6.c-errata: review: https://github.com/perl6/roast/commit/a2ec5a2992

[22:25] <lucs> RabidGravy: Yep, gotcha.

[22:26] *** Skarsnik left
[22:27] *** vendethiel left
[22:27] <hoelzro> you can't specify a literal value for a named argument to make a specific multi candidate, can you?

[22:28] <hoelzro> ex. proto factorial(:$n) { * }; multi factorial(:n(1)) { 1 }; multi factorial(:$n) { $n * factorial(:n($n - 1)) }

[22:30] *** cpage_ joined
[22:33] *** TEttinger joined
[22:34] <sortiz> m: multi factorial(:$n where $n == 1 ) { 1 }; multi factorial(:$n) { $n * factorial(:n($n - 1)) }; say factorial :5n

[22:34] <camelia> rakudo-moar 360232: OUTPUT«120␤»

[22:34] <sortiz> hoelzro, ^^^

[22:34] <hoelzro> I figured one could use where

[22:35] <hoelzro> thanks sortiz!

[22:35] <spider-mario> how do I get :sigspace to apply to an interpolated variable?

[22:35] <spider-mario> e.g.:

[22:35] <spider-mario> p6: my $r = 'a b c'; 'a b c' ~~ /:s<$r>/

[22:35] <camelia> rakudo-moar 360232: OUTPUT«Potential difficulties:␤    Space is not significant here; please use quotes or :s (:sigspace) modifier (or, to suppress this warning, omit the space, or otherwise change the spacing)␤    at /home/camelia/EVAL_0:1␤    ------> 3anon regex { a7⏏5 …»

[22:40] *** idiosyncrat_ joined
[22:41] *** jjido joined
[22:44] <sortiz> m: my $r = 'a b c'; say 'a b c' ~~ /:s $r /

[22:44] <camelia> rakudo-moar 360232: OUTPUT«｢a b c｣␤»

[22:44] <sortiz> spider-mario, ^^^

[22:45] <spider-mario> thanks, but what if $r uses regexp syntax?

[22:45] <spider-mario> p6: my $r = 'a .* c'; 'a b c' ~~ /:s $r/

[22:45] <camelia> rakudo-moar 360232: ( no output )

[22:45] <spider-mario> p6: my $r = 'a .* c'; 'a b c' ~~ /:s<$r>/

[22:45] <camelia> rakudo-moar 360232: ( no output )

[22:46] <spider-mario> (why does it say nothing about “potential difficulties” anymore?)

[22:47] <spider-mario> wait, it seems to work in a repl, now

[22:47] <spider-mario> what gives?

[22:47] <sortiz> m: my $r = /a .* c/; 'a b c' ~~ / $r /

[22:47] <camelia> rakudo-moar 360232: ( no output )

[22:47] <sortiz> m: my $r = /a .* c/; say 'a b c' ~~ / $r /

[22:47] <camelia> rakudo-moar 360232: OUTPUT«｢a b c｣␤»

[22:47] <spider-mario> p6: my $r = 'a .* c'; say 'a b c' ~~ /:s<$r>/

[22:47] <camelia> rakudo-moar 360232: OUTPUT«｢a b c｣␤»

[22:48] <spider-mario> okay, there’s something I don’t fully grasp here, I guess

[22:48] <spider-mario> why did it say that space was not significant, in the first example?

[22:48] <spider-mario> p6: my $r = 'a b c'; 'a b c' ~~ /:s<$r>/

[22:48] <camelia> rakudo-moar 360232: OUTPUT«Potential difficulties:␤    Space is not significant here; please use quotes or :s (:sigspace) modifier (or, to suppress this warning, omit the space, or otherwise change the spacing)␤    at /home/camelia/EVAL_0:1␤    ------> 3anon regex { a7⏏5 …»

[22:51] <ugexe> p6: my $r = 'a b c'; 'a b c' ~~ /:s<{say $r}>/

[22:51] <camelia> rakudo-moar 360232: OUTPUT«a b c␤a b c␤a b c␤a b c␤a b c␤a b c␤»

[22:51] <ugexe> p6: my $r = 'a .* c'; say 'a b c' ~~ /:s<{say $r}>/

[22:51] <camelia> rakudo-moar 360232: OUTPUT«a .* c␤a .* c␤a .* c␤a .* c␤a .* c␤a .* c␤Nil␤»

[22:52] <lizmat> m: dd :($ where { ... }) eqv :($ where { ... })  # jnthn TimToady: I would posit that this is wrong: it should be False instead

[22:52] <camelia> rakudo-moar 360232: OUTPUT«Bool::True␤»

[22:52] <lizmat> as one cannot tell what's inside the code object

[22:53] <lizmat> m: dd :($ where { 666 }) eqv :($ where { 42 })  # 

[22:53] <camelia> rakudo-moar 360232: OUTPUT«Bool::True␤»

[22:53] <lizmat> ^^^  wrong  :-)

[22:53] <lizmat> m: dd :($ where * == 666) eqv :($ where * == 42})  # 

[22:53] <camelia> rakudo-moar 360232: OUTPUT«5===SORRY!5=== Error while compiling /tmp/g0dBLrnk7I␤Malformed parameter␤at /tmp/g0dBLrnk7I:1␤------> 3($ where * == 666) eqv :($ where * == 427⏏5})  #␤    expecting any of:␤        constraint␤»

[22:54] <lizmat> m: dd :($ where * == 666) eqv :($ where * == 42)  # 

[22:54] <camelia> rakudo-moar 360232: OUTPUT«Bool::True␤»

[22:54] <lizmat> wrong ^^^

[22:55] <lizmat> there are 4 tests in S06-signature/introspection.t that depend on this behaviour

[22:56] <lizmat> m: dd :(42) eqv :(666)

[22:56] <camelia> rakudo-moar 360232: OUTPUT«Bool::True␤»

[23:00] *** lostinfog left
[23:05] <dalek> rakudo/nom: 8d0af58 | lizmat++ | src/core/Parameter.pm:

[23:05] <dalek> rakudo/nom: Make sure we emit :($ is raw).perl correctly

[23:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8d0af58a48

[23:07] *** sufrostico joined
[23:08] *** rindolf left
[23:12] <dalek> rakudo/nom: 94780d7 | lizmat++ | src/core/Parameter.pm:

[23:12] <dalek> rakudo/nom: Add Parameter:D eqv Parameter:D

[23:12] <dalek> rakudo/nom: 

[23:12] <dalek> rakudo/nom: For faster, non .perl based checking

[23:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/94780d74cc

[23:12] <dalek> rakudo/nom: 2c552d9 | lizmat++ | src/core/Signature.pm:

[23:12] <dalek> rakudo/nom: Rewrite Signature:D eqv Signature:D

[23:12] <dalek> rakudo/nom: 

[23:12] <dalek> rakudo/nom: - no longer uses Parameter.perl, but Parameter:D eqv Parameter:D

[23:12] <dalek> rakudo/nom: - reduces set_multi_sig_comparator to a.signature eqv b.signature

[23:12] <dalek> rakudo/nom: - makes Buf.^pun 300x faster

[23:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2c552d9b34

[23:14] <lizmat> and on that note I wish #perl6 a good night!

[23:14] *** lizmat left
[23:18] *** _nadim joined
[23:18] <_nadim> Good evening all!

[23:19] <_nadim> so, what's a !UNIT_MARKER?

[23:19] *** skids joined
[23:19] *** sufrostico left
[23:21] *** sufrostico joined
[23:30] *** jjido left
[23:31] <RabidGravy> anyway today I learned that it's better to trust a specification than some implementation thereof

[23:31] <RabidGravy> (again)

[23:37] *** Actualeyes left
[23:41] <RabidGravy> the warriors is great movie but I can't be doing with a late night, so toodles peeps

[23:47] <skids> o/

[23:48] *** firstdayonthejob left
[23:50] *** RabidGravy left
[23:52] *** tmch left
[23:52] *** spider-mario left
[23:53] *** SCHAAP137 left
[23:53] *** pdcawley left
[23:55] *** kaare__ left
