[00:01] *** BenGoldberg joined
[00:04] <Zoffix> I'm gonna lose it. 

[00:07] <Zoffix> This was annoying but I fixed it:  (1) I used `leftovers` in the grammar, but `left-overs` in Actions. (2) I had $str ~= $left-overs; when it should've been $str = $left-overs ~ $str;

[00:07] <Zoffix> Time to boot up Assassin's Creed and murder a few hundred people :(

[00:07] *** raiph joined
[00:09] *** IRCBot1465085383 joined
[00:11] *** pierre_ left
[00:14] *** Zoffix left
[00:14] *** Zoffix joined
[00:14] *** spider-mario left
[00:20] <raiph> .ask masak re "when (*, * < 0) { ... }"; does "when (*; * < 0) { ... }" work for your use case?

[00:20] <yoleaux> raiph: I'll pass your message to masak.

[00:25] <TimToady> .ask masak or were you expecting it to do (**, * < 0) instead?

[00:25] <yoleaux> TimToady: I'll pass your message to masak.

[00:27] <TimToady> m: my @a = 1,-2; say "Good" when (*, * < 0) given @a;

[00:27] <camelia> rakudo-moar 986891: OUTPUT«Good␤»

[00:52] *** silug left
[00:59] *** IRCBot1465085383 left
[00:59] *** IRCBot1465088396 joined
[01:01] *** wamba left
[01:05] *** silug joined
[01:05] *** IRCBot1465088396 left
[01:15] *** silug left
[01:20] *** jack_rabbit joined
[01:23] *** kalkin- left
[01:23] *** kalkin-_ joined
[01:26] *** jcallen left
[01:26] *** Zoffix__ joined
[01:26] *** finanalyst joined
[01:27] *** jcallen joined
[01:27] *** Zoffix__ left
[01:30] <gfldex> m: sub returns-different-things () { ((10,"ten"), 10 ).pick }; given returns-different-things() { when :(Int, Str) { say 'It returned a list.' }; when :(Int) { say 'returned a single Int' }; default { say 'This should never happen' } }

[01:30] <camelia> rakudo-moar 986891: OUTPUT«This should never happen␤»

[01:30] <gfldex> m: sub returns-different-things () { ((10,"ten"), 10 ).pick }; given returns-different-things() { when :(Int, Str) { say 'It returned a list.' }; when :(Int) { say 'returned a single Int' }; default { say 'This should never happen' } }

[01:30] <camelia> rakudo-moar 986891: OUTPUT«It returned a list.␤»

[01:30] *** pierre_ joined
[01:30] <gfldex> why is the default block executed?

[01:32] *** pierre_ left
[01:33] <Zoffix> m: sub returns-different-things () { ((10,"ten"), (10), ).pick }; given returns-different-things() { when :(Int, Str) { say 'It returned a list.' }; when :(Int) { say 'returned a single Int' }; default { say 'This should never happen' } }

[01:33] <camelia> rakudo-moar 986891: OUTPUT«This should never happen␤»

[01:34] *** silug joined
[01:34] <Zoffix> gfldex, how come it's an :(Int) and not just Int?

[01:34] <Zoffix> The default is executed, because 10 is not a list with an Int in it

[01:34] <Zoffix> m: sub returns-different-things () { ((10,"ten"), 10.list ).pick }; given returns-different-things() { when :(Int, Str) { say 'It returned a list.' }; when :(Int) { say 'returned a single Int' }; default { say 'This should never happen' } }

[01:34] <camelia> rakudo-moar 986891: OUTPUT«It returned a list.␤»

[01:35] <gfldex> i c

[01:35] <Zoffix> m: sub returns-different-things () { ((10,"ten"), 10.list ).pick }; given returns-different-things() { when :(Int, Str) { say 'It returned a list.' }; when :(Int) { say 'returned a single Int' }; default { say 'This should never happen' } }

[01:35] <camelia> rakudo-moar 986891: OUTPUT«returned a single Int␤»

[01:35] <Zoffix> m: sub returns-different-things () { ((10,"ten"), 10 ).pick }; given returns-different-things() { when :(Int, Str) { say 'It returned a list.' }; when Int { say 'returned a single Int' }; default { say 'This should never happen' } }

[01:35] <camelia> rakudo-moar 986891: OUTPUT«It returned a list.␤»

[01:35] <Zoffix> m: sub returns-different-things () { ((10,"ten"), 10 ).pick }; given returns-different-things() { when :(Int, Str) { say 'It returned a list.' }; when Int { say 'returned a single Int' }; default { say 'This should never happen' } }

[01:35] <camelia> rakudo-moar 986891: OUTPUT«It returned a list.␤»

[01:35] <Zoffix> m: sub returns-different-things () { ((10,"ten"), 10 ).pick }; given returns-different-things() { when :(Int, Str) { say 'It returned a list.' }; when Int { say 'returned a single Int' }; default { say 'This should never happen' } }

[01:35] <camelia> rakudo-moar 986891: OUTPUT«It returned a list.␤»

[01:35] <Zoffix> well.. .it'll work when it's a 10 :)

[01:35] <gfldex> m: say 10 ~~ :(Int);

[01:35] <camelia> rakudo-moar 986891: OUTPUT«False␤»

[01:35] <gfldex> m: say (10) ~~ :(Int);

[01:35] <camelia> rakudo-moar 986891: OUTPUT«False␤»

[01:35] <gfldex> m: say \(10) ~~ :(Int);

[01:35] <camelia> rakudo-moar 986891: OUTPUT«True␤»

[01:36] <gfldex> m: say (10).list ~~ :(Int);

[01:36] <camelia> rakudo-moar 986891: OUTPUT«True␤»

[01:36] <Zoffix> m: say ((10),) ~~ :(Int);

[01:36] <camelia> rakudo-moar 986891: OUTPUT«True␤»

[01:36] <gfldex> m: sub returns-different-things () { \(((10,"ten"), 10 ).pick) }; given returns-different-things() { when :(Int, Str) { say 'It returned a list.' }; when :(Int) { say 'returned a single Int' }; default { say 'This should never happen' } }

[01:36] <camelia> rakudo-moar 986891: OUTPUT«This should never happen␤»

[01:37] <gfldex> m: sub returns-different-things () { ((10,"ten"), \(10) ).pick }; given returns-different-things() { when :(Int, Str) { say 'It returned a list.' }; when :(Int) { say 'returned a single Int' }; default { say 'This should never happen' } }

[01:37] <camelia> rakudo-moar 986891: OUTPUT«returned a single Int␤»

[01:38] <gfldex> m: say 10 ~~ :(Int); # I'm not sure if I should agree with this.

[01:38] <camelia> rakudo-moar 986891: OUTPUT«False␤»

[01:39] <Zoffix> Why are you using :() ?

[01:39] <gfldex> because I want to test against a signature

[01:40] <Zoffix> m: say sub (Int) {}.signature ~~ :(Int)

[01:40] <camelia> rakudo-moar 986891: OUTPUT«True␤»

[01:41] <Zoffix> m: :(Int).WHAT.say

[01:41] <camelia> rakudo-moar 986891: OUTPUT«(Signature)␤»

[01:42] <Zoffix> m: say 10.Capture ~~ :(Int);

[01:42] <camelia> rakudo-moar 986891: OUTPUT«False␤»

[01:43] <gfldex> you can use signature literals in a when test. That is very helpful if a routine returns different types. It would be nice if it would be neatly regular by allowing a test against a single value.

[01:43] <Zoffix> m: say 10.Capture; say [10].Capture

[01:43] <camelia> rakudo-moar 986891: OUTPUT«\()␤\(10)␤»

[01:43] <Zoffix> I wonder if 10.Capture is returning the right thing here...

[01:44] <gfldex> i thínk it doesn't

[01:44] <gfldex> the birds are getting noisy. I may rakudobug tomorrow.

[01:44] <Zoffix> .oO( birds? )

[01:45] <gfldex> there is an outside world. It's where this "sun" thing is.

[01:45] <gfldex> it also got birds

[01:45] <gfldex> good night :)

[01:45] <Zoffix> m: use MONKEY-TYPING; augment class Int { method Capture { \(self) } }; say 10.Capture

[01:45] <camelia> rakudo-moar 986891: OUTPUT«\(10)␤»

[01:45] <Zoffix> m: use MONKEY-TYPING; augment class Int { method Capture { \(self) } }; say 10 ~~ :(Int);

[01:45] <camelia> rakudo-moar 986891: OUTPUT«False␤»

[01:46] *** ilbot3 left
[01:47] <Zoffix> Sun? But I thought they were acquired by Oracle!

[01:47] *** ilbot3 joined
[01:49] <BenGoldberg> m: sub returns-different-things () { ((10,"ten"), \(10) ).pick }; given returns-different-things() { when :(Int $x, Str $y) { say "[two things: $x, $y]" }; when :(Int $z) { say "One thing: $z" }; default { say 'This should never happen' } }

[01:49] <camelia> rakudo-moar 986891: OUTPUT«5===SORRY!5=== Error while compiling /tmp/ipbB5pg6ql␤Variable '$x' is not declared␤at /tmp/ipbB5pg6ql:1␤------> 3n :(Int $x, Str $y) { say "[two things: 7⏏5$x, $y]" }; when :(Int $z) { say "One th␤»

[01:50] <BenGoldberg> m: sub returns-different-things () { ((10,"ten"), \(10) ).pick }; given returns-different-things() { when [Int $x, Str $y] { say "[two things: $x, $y]" }; when [Int $z] { say "One thing: $z" }; default { say 'This should never happen' } }

[01:50] <camelia> rakudo-moar 986891: OUTPUT«5===SORRY!5=== Error while compiling /tmp/QqctzNUBNy␤Two terms in a row␤at /tmp/QqctzNUBNy:1␤------> 3n returns-different-things() { when [Int7⏏5 $x, Str $y] { say "[two things: $x, $y]␤    expecting any of:␤        infix␤        infi…»

[01:52] <BenGoldberg> m: my multi sub foo(Int $x) { "[one $x]" }; my multi sub foo(Int $y, Str $z) { "[two $y, $x]" }; say foo( ((10,"ten"), \(10) ).pick );

[01:52] <camelia> rakudo-moar 986891: OUTPUT«5===SORRY!5=== Error while compiling /tmp/nOS30VmBhA␤Variable '$x' is not declared␤at /tmp/nOS30VmBhA:1␤------> 3lti sub foo(Int $y, Str $z) { "[two $y, 7⏏5$x]" }; say foo( ((10,"ten"), \(10) ).pi␤»

[01:52] <BenGoldberg> m: my multi sub foo(Int $x) { "[one $x]" }; my multi sub foo(Int $y, Str $z) { "[two $y, $z]" }; say foo( ((10,"ten"), \(10) ).pick );

[01:52] <camelia> rakudo-moar 986891: OUTPUT«Cannot call foo(Capture); none of these signatures match:␤    (Int $x)␤    (Int $y, Str $z)␤  in block <unit> at /tmp/iZgdzignp0 line 1␤␤»

[01:52] <BenGoldberg> m: my multi sub foo(Int $x) { "[one $x]" }; my multi sub foo(Int $y, Str $z) { "[two $y, $z]" }; say foo( ((10,"ten"), (10) ).pick );

[01:52] <camelia> rakudo-moar 986891: OUTPUT«[one 10]␤»

[01:53] <BenGoldberg> m: my multi sub foo(Capture $x) { "[one $x]" }; my multi sub foo(Int $y, Str $z) { "[two $y, $z]" }; say foo( ((10,"ten"), \(10) ).pick );

[01:53] <camelia> rakudo-moar 986891: OUTPUT«Cannot call foo(List); none of these signatures match:␤    (Capture $x)␤    (Int $y, Str $z)␤  in block <unit> at /tmp/ThOHkeK6Ap line 1␤␤»

[01:53] <BenGoldberg> m: my multi sub foo(Capture $x) { "[one $x]" }; my multi sub foo(List @y) { "[some @y]" }; say foo( ((10,"ten"), \(10) ).pick );

[01:53] <camelia> rakudo-moar 986891: OUTPUT«[one 10]␤»

[01:56] <BenGoldberg> gfldex, I suspect that using multiple dispatch (with 'my' subs) will be easier to write (and easier to read later!) than given/when.

[02:06] *** kid51 left
[02:06] *** mr-foobar left
[02:07] *** mr-foobar joined
[02:13] *** kid51 joined
[02:13] *** jeek left
[02:13] *** jeek joined
[02:26] *** yqt left
[02:33] *** pierre_ joined
[02:37] *** pierre_ left
[02:38] *** noganex_ joined
[02:41] *** noganex left
[02:52] *** kid51 left
[03:02] *** labster left
[03:25] *** ssotka joined
[03:34] *** pierre_ joined
[03:39] *** nowan left
[03:39] *** mst left
[03:39] *** nowan joined
[03:40] *** pierre_ left
[03:45] *** mst joined
[03:45] <Zoffix> 3m: my @f = foo=> 'bar', meow => 'moo'; for @f -> ($name, $s) { say "[$name]->[$s]" }

[03:45] <Zoffix> m: my @f = foo=> 'bar', meow => 'moo'; for @f -> ($name, $s) { say "[$name]->[$s]" }

[03:45] <camelia> rakudo-moar 986891: OUTPUT«Too few positionals passed; expected 2 arguments but got 0 in sub-signature␤  in block <unit> at /tmp/3pIYvsc9L4 line 1␤␤»

[03:46] <Zoffix> Any way to make this work? I want $name to have the .key and $s the .value of each Pair in @f

[03:46] *** labster joined
[03:48] <ugexe> m: my @f = foo => 'bar', meow => 'moo'; for @f.hash.kv -> $name, $s { say "[$name]->[$s]" }

[03:48] <camelia> rakudo-moar 986891: OUTPUT«[foo]->[bar]␤[meow]->[moo]␤»

[03:49] <ugexe> or %@f.kv if you prefer that

[03:49] <Zoffix> ugexe++ Thanks

[03:51] *** pierre_ joined
[03:52] *** pierre_ left
[03:52] *** pierre_ joined
[04:03] <Zoffix> How come this line doesn't await anything and the script seems to just exit? https://github.com/zoffixznet/perl6-IRC-Client/blob/rewrite/lib/IRC/Client.pm6#L54 The `say` on the previous line produces: (Promise.new(scheduler => ThreadPoolScheduler.new(initial_threads => 0, max_threads => 16, uncaught_handler => Callable), status => PromiseStatus::Planned))

[04:03] <Zoffix> And if I await on this line, then it awaits :/ https://github.com/zoffixznet/perl6-IRC-Client/blob/rewrite/lib/IRC/Client.pm6#L23

[04:05] <Zoffix> Ah, I need to Slip it into await. Laaame.. I expected it to complain

[04:05] *** pierre_ left
[04:07] *** pierre_ joined
[04:09] <Zoffix> Oh.. Doesn't work with two promises :/

[04:12] *** khw left
[04:20] <ugexe> await Promise.allof(...)

[04:22] *** Cabanossi left
[04:26] *** Cabanossi joined
[04:32] *** mr-foobar left
[04:33] *** mr-foobar joined
[04:49] *** mr-foobar left
[04:49] *** mr-foobar joined
[04:53] *** _nadim joined
[04:56] *** nadim left
[05:01] *** pierre_ left
[05:01] *** pierre_ joined
[05:11] *** pierre_ left
[05:15] *** pierre_ joined
[05:25] *** pierre_ left
[05:25] *** slobo left
[05:47] *** rindolf joined
[05:51] *** AlexDaniel left
[05:57] *** ssotka left
[05:58] *** araujo_ left
[06:03] *** pierre_ joined
[06:04] *** BenGoldberg left
[06:06] *** BenGoldberg joined
[06:16] *** wamba joined
[06:18] *** pierre_ left
[06:18] *** buharin joined
[06:24] *** pierre_ joined
[06:29] *** kaare_ joined
[06:37] *** kaare_ left
[06:38] *** kaare_ joined
[06:41] *** bjz joined
[06:42] *** BenGoldberg left
[06:42] *** bjz_ left
[06:52] *** kaare_ left
[06:53] *** kaare_ joined
[07:02] *** rurban joined
[07:05] *** pierre_ left
[07:07] *** pierre_ joined
[07:09] *** pierre_ left
[07:10] *** pierre_ joined
[07:12] *** pierre_ left
[07:13] *** wamba left
[07:15] *** darutoko joined
[07:16] *** buharin left
[07:17] *** wamba joined
[07:21] *** pierre_ joined
[07:22] *** rurban1 joined
[07:23] *** rurban left
[07:28] *** bjz_ joined
[07:29] *** bjz left
[07:30] *** RabidGravy joined
[07:39] *** gnull joined
[07:43] <gfldex> m: dd 10.list, 10.Capture, 0.5.list, 0.5.Capture;

[07:43] <camelia> rakudo-moar 986891: OUTPUT«(10,)␤\()␤(0.5,)␤\(:denominator(2), :numerator(1))␤»

[07:44] <gfldex> m: .WHAT.say for 10.List, 10.Capture;

[07:44] <camelia> rakudo-moar 986891: OUTPUT«(List)␤(Capture)␤»

[07:44] <gfldex> m: .WHAT.say for 10.Capture;

[07:44] <camelia> rakudo-moar 986891: ( no output )

[07:44] <RabidGravy> boom

[07:44] *** labster left
[07:45] *** gnull left
[07:45] *** user9 joined
[07:45] <teatime> welp that is odd

[07:46] <gfldex> m: .&dd for 10.Capture;

[07:46] <camelia> rakudo-moar 986891: ( no output )

[07:46] <gfldex> m: .&dd for 10.Capture, 10.List;

[07:46] <camelia> rakudo-moar 986891: OUTPUT«\()␤(10,)␤»

[07:47] <teatime> I guess the Capture is positional/iterable, and empty?

[07:48] <gfldex> Int.Capture is empty, while many other single value types are not

[07:52] *** gnull joined
[07:57] <gfldex> rakudobuged as #128321

[07:57] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128321

[08:17] <sjn> m: say π.Capture

[08:17] <camelia> rakudo-moar 986891: OUTPUT«\()␤»

[08:18] <gfldex> m: dd "Pie".Capture

[08:18] <camelia> rakudo-moar 986891: OUTPUT«\()␤»

[08:24] *** sortiz joined
[08:25] <sortiz> \o #perl6

[08:25] <yoleaux> 4 Jun 2016 21:04Z <slobo> sortiz: I'm able to correctly access the elements of a list, but then I get random crashes, eg: moar(23669,0x7fff75b7b000) malloc: *** error for object 0x7fe448b70138: incorrect checksum for freed object - object was probably modified after being freed.

[08:25] <teatime> morning sortiz 

[08:28] <sortiz> m: dd Blob.new(1).Capture

[08:28] <camelia> rakudo-moar 986891: OUTPUT«\()␤»

[08:30] <gfldex> https://github.com/rakudo/rakudo/blob/nom/src/core/Mu.pm#L473

[08:30] *** azawawi joined
[08:30] <azawawi> hi

[08:30] <gfldex> as I understand it, the generic .Capture will only work on objects that have attributes

[08:31] <azawawi> RabidGravy: ping

[08:31] <gfldex> m: 10.^attribures.say

[08:31] <RabidGravy> Harr!

[08:31] <camelia> rakudo-moar 986891: OUTPUT«Method 'attribures' not found for invocant of class 'Perl6::Metamodel::ClassHOW'␤  in block <unit> at /tmp/IGWtTepI_z line 1␤␤»

[08:31] <gfldex> m: 10.^attributes.say

[08:31] <camelia> rakudo-moar 986891: OUTPUT«Method 'gist' not found for invocant of class 'BOOTSTRAPATTR'␤  in block <unit> at /tmp/LW1xPuIC5g line 1␤␤»

[08:31] <gfldex> m: dd 10.^attributes

[08:31] <camelia> rakudo-moar 986891: OUTPUT«Method 'perl' not found for invocant of class 'BOOTSTRAPATTR'␤  in block <unit> at /tmp/2MOFnd6IPq line 1␤␤»

[08:32] <gfldex> m: dd 10.^attributes.WHAT

[08:32] <camelia> rakudo-moar 986891: OUTPUT«Cannot look up attributes in a type object␤  in block <unit> at /tmp/418q2vcdCW line 1␤␤»

[08:32] <sortiz> gfldex, so, I say for object with "structure" :-)

[08:32] <azawawi> RabidGravy: hehe.. finally i have a macbook pro to play with from a collegue... installing rakudo :)

[08:32] <RabidGravy> oh dear

[08:33] *** firstdayonthejob joined
[08:33] <azawawi> RabidGravy: installing xcode.... lame 3.8 GB :(

[08:36] *** bjz joined
[08:38] *** bjz_ left
[08:38] <sortiz> .tell slobo With NC, "random crashes" normally means bad assumptions about memory ownership.

[08:38] <yoleaux> sortiz: I'll pass your message to slobo.

[08:42] *** jack_rabbit left
[08:44] <sortiz> m: class Foo { has $.foo }; class Bar { has $!bar }; dd Foo.new.Capture, Bar.new.Capture; # moreover, attributes *with* accessors 

[08:44] <camelia> rakudo-moar 986891: OUTPUT«\(:foo(Any))␤\()␤»

[08:45] *** jack_rabbit joined
[09:06] *** azawawi left
[09:16] <llfourn> is there any method which when called on an undefined will return an Empty but when called on somethiing defined will create a Slip from the value(s)?

[09:16] <llfourn> m: .say for .<foo>' # so this doesn't do any iterations

[09:16] <camelia> rakudo-moar 986891: OUTPUT«5===SORRY!5=== Error while compiling /tmp/GgzIkuw9Kz␤Two terms in a row␤at /tmp/GgzIkuw9Kz:1␤------> 3.say for .<foo>7⏏5' # so this doesn't do any iterations␤    expecting any of:␤        infix␤        infix stopper␤»

[09:16] <llfourn> m: .say for .<foo> # so this doesn't do any iterations

[09:16] <camelia> rakudo-moar 986891: OUTPUT«(Any)␤»

[09:17] <llfourn> m: $_ = { foo => <bar baz> }; .say for .<foo> # but this still works

[09:17] <camelia> rakudo-moar 986891: OUTPUT«(bar baz)␤»

[09:18] <llfourn> m: $_ = { foo => <bar baz> }; .say for |.<foo> # rather

[09:18] <camelia> rakudo-moar 986891: OUTPUT«bar␤baz␤»

[09:18] <llfourn> m: .say for |.<foo> 

[09:18] <camelia> rakudo-moar 986891: OUTPUT«(Any)␤»

[09:19] *** girafe left
[09:19] <llfourn> m: .say for |(.<foo> // Empty) # my best answer

[09:19] <camelia> rakudo-moar 986891: ( no output )

[09:19] *** brrt joined
[09:20] <lizmat> m: my %h = a => |(); dd %h; .say for %h<a>   # llfourn this maybe?

[09:20] <camelia> rakudo-moar 986891: OUTPUT«Hash %h = {:a(slip$())}␤»

[09:21] <llfourn> lizmat: my issue is the case where 'a' doesn't exist at all

[09:21] <llfourn> m: my %h; .say for %h<a> # how do I stop Any being there

[09:21] <camelia> rakudo-moar 986891: OUTPUT«(Any)␤»

[09:22] <RabidGravy> is it possible to decompose a Pair in a signature, something like "foo(Pair $ ( $key, $value))" ?

[09:23] <llfourn> RabidGravy: I think it is

[09:23] <RabidGravy> the above doesn't work BTW

[09:24] <llfourn> I'm sure I've seen it ><

[09:27] <sortiz> m: sub foo( ( :$key, :$value ) ) { say $key,$value }; foo( 'a'=>10 );

[09:27] <camelia> rakudo-moar 986891: OUTPUT«a10␤»

[09:27] <llfourn> ahhhh yes

[09:27] <llfourn> sortiz++

[09:27] *** user9 left
[09:27] <RabidGravy> sortiz++, yeah I thought I'd seen it too :)

[09:28] <llfourn> they have to be named $key, $value is the trick

[09:28] <RabidGravy> my specific thing is that I want a multi on either the key or value of the pair

[09:29] <llfourn> what does that mean?

[09:29] <lizmat> m: my %h is default( slip() ); dd %h; .say for %h<a>   # llfourn

[09:29] <camelia> rakudo-moar 986891: OUTPUT«Hash %h = {}␤»

[09:29] <RabidGravy> something like

[09:29] <llfourn> lizmat: that is awesome!

[09:30] <llfourn> lizmat: though in my specific case I'm using a match object in a grammar :S

[09:30] <llfourn> the current line is: { $*CURPAD.declare($_) for |($<paramlist>.ast // Empty) }

[09:30] <llfourn> wondering if there's something nicer than that

[09:31] <RabidGravy> m: multi sub foo(Pair $p ( :$key, Int :$value ) ) { say "Int $key $value"; }; multi sub foo(Pair $p ( :$key, Str :$value ) ) { say "Str $key $value"; }; foo("foo" => "bar"); foo("foo" => 42);

[09:31] <camelia> rakudo-moar 986891: OUTPUT«Str foo bar␤Int foo 42␤»

[09:32] <RabidGravy> but in reality something more complex

[09:32] <llfourn> ah cool. signatures++

[09:32] <sortiz> m: sub foo( ( :key($k), :value($v) ) ) { say $k,$v }; foo( 'a'=>10 ); # BTW

[09:32] <camelia> rakudo-moar 986891: OUTPUT«a10␤»

[09:33] <RabidGravy> sure :)

[09:34] *** user9 joined
[09:40] *** user9 left
[09:41] *** Ven joined
[09:44] *** user9 joined
[09:51] *** user9 left
[09:52] *** brrt left
[09:53] *** rurban joined
[09:53] *** Ven_ joined
[09:54] *** Ven left
[09:55] *** spider-mario joined
[09:57] *** rurban1 left
[09:58] *** Emeric joined
[09:59] <sortiz> llfourn,  with $<paramlist> { $*CURPAD.declares($_) for .ast }  # nicer?

[10:02] <llfourn> sortiz: yeah I think that's better actually :)

[10:03] <llfourn> I had a problem with 'with' statement sometimes disappearing when used inside grammars

[10:03] <llfourn> but I think that was the statement modifier form

[10:04] <llfourn> (I think the optimizer mistakenly removed them)

[10:06] <sortiz> I hasn't played much with grammars, so never seen that.

[10:08] <sortiz> But I'm in love with 'with' :)

[10:08] <llfourn> yes with is very handy

[10:09] <llfourn> because even if you have an with { } else { }, $_ will be set in the else too

[10:09] <llfourn> so with %h<key> { do_something($_) } else { $_ = "foo" } works

[10:10] <sortiz> Yep, and $_ is a bind

[10:10] <llfourn> yup

[10:12] *** colomon joined
[10:16] *** buharin joined
[10:18] *** TEttinger left
[10:20] *** kaare_ left
[10:22] *** rurban left
[10:26] *** colomon left
[10:26] *** Ven joined
[10:27] *** Ven_ left
[10:32] *** labster joined
[10:37] *** Levine joined
[10:38] *** Levine left
[10:40] *** Ven_ joined
[10:42] *** Ven left
[10:45] *** araujo joined
[10:45] *** araujo left
[10:45] *** araujo joined
[10:45] *** araujo left
[10:54] *** ilogger2 joined
[10:54] *** ChanServ sets mode: +v ilogger2

[10:55] *** M-Illandan joined
[10:56] *** Bucciarati joined
[10:56] *** kmwallio joined
[10:56] *** salv0 joined
[10:58] *** cosarara joined
[10:59] *** jusafing joined
[10:59] *** sunnavy_ joined
[10:59] *** jferrero_ joined
[11:00] *** brrt joined
[11:00] *** Peter_R joined
[11:00] *** felher joined
[11:01] *** silug joined
[11:01] *** k-man joined
[11:02] *** kid51 joined
[11:02] *** domm joined
[11:02] *** teatime joined
[11:03] *** parisba joined
[11:04] *** parisba is now known as Guest690

[11:11] *** BinGOs joined
[11:13] *** pierre_ joined
[11:14] *** pierre_ left
[11:14] *** araujo joined
[11:35] *** |meta joined
[11:40] *** |meta is now known as |sir

[11:43] *** buharin joined
[11:53] *** colomon joined
[11:58] *** colomon left
[11:59] *** brrt left
[12:06] *** Peter_R left
[12:06] *** Peter_R joined
[12:09] *** rurban joined
[12:11] *** buharin left
[12:11] *** Ven joined
[12:16] *** Deep_Thought joined
[12:17] *** rurban1 joined
[12:18] *** rurban2 joined
[12:18] *** rurban2 left
[12:20] *** rurban left
[12:21] *** rurban1 left
[12:25] *** Ven left
[12:27] *** colomon joined
[12:28] *** Ven joined
[12:32] *** buharin joined
[12:35] *** FROGGS joined
[12:35] <RabidGravy> boom

[12:35] <FROGGS> o/

[12:36] <Zoffix> m: await start { sleep 3; say "32" }, start { sleep 2; say 42 };

[12:36] <camelia> rakudo-moar 85682a: OUTPUT«42␤32␤»

[12:36] <Zoffix> ugexe, but how come allof is not needed here ^ ?

[12:38] <Zoffix>  m: my %s; %s<one><p> = start { sleep 3; say "32" }; %s<two><p> = start { sleep 2; say 42 }; await %s.values».<p>

[12:38] <camelia> rakudo-moar 85682a: OUTPUT«42␤32␤»

[12:38] <Zoffix> This is exactly like my thing :/

[12:39] <timotimo> await already takes a list of promises and such, doesn't it?

[12:39] <timotimo> or is the semantics "anyof" by default?

[12:39] <timotimo> because i thought it's "allof"

[12:39] <Zoffix> If it were anyof, only one value would print above

[12:39] <timotimo> yeah

[12:40] *** Ven left
[12:40] *** colomon left
[12:41] <Zoffix> But here it waits for nothing at all. Program exits: https://github.com/zoffixznet/perl6-IRC-Client/blob/rewrite/lib/IRC/Client.pm6#L54

[12:42] <timotimo> huh :o

[12:43] *** bjz_ joined
[12:43] <Zoffix> (works with .allof)

[12:44] <Zoffix> FSVO

[12:44] <timotimo> oh

[12:44] <timotimo> could be list vs argument list?

[12:44] <timotimo> try with a | ?

[12:45] <Zoffix> That fixes the issue... but only when there's just one Promise.

[12:45] <timotimo> huh

[12:45] <Zoffix> But there's also some other error in the code. I can't get the error to show up though. My CATCH { warn .backtrace } print backtraces but no error :S

[12:45] *** Ven joined
[12:45] <Zoffix> bloody annoying

[12:46] <timotimo> yeah, i think the unhandled exception handler we have by default isn't working correctly

[12:49] <pochi> m: class Point { has $.x; has $.y }; "(12,23) (34,45)".split(" ").map( { m/\((\d+)","(\d+)\)/ } ).map( { Point.new( x => $/[0].Int, y => $/[1].Int ) } )

[12:49] <camelia> rakudo-moar 85682a: ( no output )

[12:49] <pochi> is there a more perl6-ish way to write the above? something more succinct?

[12:49] <timotimo> yeah, you can .comb to get the numbers, for instance

[12:50] * pochi looks up comb

[12:50] <timotimo> and .comb will give you strings instead of match objects by default, which will get rid of the $/ dance

[12:50] <pochi> nice

[12:50] <pochi> tries it out

[12:50] <timotimo> m: class Point { has $.x; has $.y }; "(12,23) (34,45)".comb(/ \d+ /).map({ Point.new( x => $^x, y => $^y ) }).say;

[12:50] <camelia> rakudo-moar 85682a: OUTPUT«(Point.new(x => "12", y => "23") Point.new(x => "34", y => "45"))␤»

[12:51] <timotimo> ^- implicit signature for the win

[12:51] <pochi> insane

[12:51] <pochi> :-)

[12:51] <FROGGS> .tell sortiz I you wanna tackle something in XML::LibXML, pick either a still failing test file or grab a new test file from t/to-be-ported and move it to t

[12:51] <yoleaux> FROGGS: I'll pass your message to sortiz.

[12:51] *** colomon joined
[12:51] <Zoffix> m: class Point { has $.x; has $.y }; "(12,23) (34,45)".comb(/\d+/).map( { Point.new( x => +$^a, y => +$^b ) } ).say

[12:51] <camelia> rakudo-moar 85682a: OUTPUT«(Point.new(x => 12, y => 23) Point.new(x => 34, y => 45))␤»

[12:51] * Zoffix is late as usual

[12:51] *** Actualeyes joined
[12:51] <timotimo> ah, yes, it wants to have + in there

[12:52] <timotimo> otherwise it'll put Str into your coordinates

[12:52] <pochi> got it!

[12:54] *** Zoffix joined
[12:56] *** Zero_Dogg joined
[12:56] *** Ven left
[12:57] <jnthn> m: class Point { has $.x; has $.y }; "(12,23) (34,45)".comb(/ \d+ /).map({ Point.new( :$^x, :$^y ) }).say; # another neat trick :)

[12:57] <camelia> rakudo-moar 85682a: OUTPUT«(Point.new(x => "12", y => "23") Point.new(x => "34", y => "45"))␤»

[12:58] <timotimo> indeed it is

[13:00] <pochi> but you'd still need the + infront

[13:00] <timotimo> right, or have the type in your class be Int()

[13:00] <jnthn> or .map(*.Int) first, but yeah :)

[13:00] <timotimo> m: class Point { has Int() $.x; has Int() $.y }; "(12,23) (34,45)".comb(/ \d+ /).map({ Point.new( :$^x, :$^y )}).say;

[13:00] <camelia> rakudo-moar 85682a: OUTPUT«5===SORRY!5===␤Coercion Int(Any) is insufficiently type-like to qualify a variable␤at /tmp/w47gJ3AYB5:1␤------> 3class Point { has Int() $.x7⏏5; has Int() $.y }; "(12,23) (34,45)".com␤Coercion Int(Any) is insufficiently type-like to quali…»

[13:00] <timotimo> oh :\

[13:01] <timotimo> we could support that, i think

[13:01] <timotimo> but only if access to $! remains un-coercion-ish

[13:01] <jnthn> Yeah, that's the tricky thing :)

[13:01] *** Actualeyes left
[13:01] <timotimo> if the users would accept that we do it like that, it's doable

[13:01] <timotimo> otherwise it's not quite as doable ...

[13:02] <pochi> shouldn't it know that comb returns Str?

[13:02] <timotimo> "it"?

[13:02] *** Actualeyes joined
[13:03] <pochi> the compiler :-)

[13:03] *** brrt joined
[13:03] <timotimo> well, comb is a method, so the object is responsible for deciding what it'll do

[13:03] <timotimo> but in this case the string is a literal, so the compiler knows what exact type it'll be

[13:03] *** araujo_ joined
[13:03] <timotimo> but what would the compiler do when it sees that comb returns the list of strings?

[13:03] *** Actualeyes left
[13:04] <pochi> the it woulod be coercion Int(Str) instead of Int(Any)?

[13:04] *** Actualeyes joined
[13:05] *** araujo_ left
[13:05] <pochi> *then *would

[13:05] <timotimo> the problem is we can't have the attribute defined to have a coercion type

[13:05] *** araujo_ joined
[13:05] *** Ven joined
[13:06] *** Actualeyes left
[13:06] <Zoffix> Segmentation fault

[13:06] <Zoffix> Weeee... 

[13:06] *** araujo left
[13:06] *** Actualeyes joined
[13:06] <timotimo> nice

[13:06] *** sammers joined
[13:06] <Zoffix> I think I may give up programming for today and play video games. This is way annoying.

[13:07] *** araujo_ left
[13:07] <brrt> Zoffix: where have you a segv

[13:07] <timotimo> thing is, assigning to a private attribute isn't actually an assignment, it's a bind that'll also check types, but it won't run code to do a coercion

[13:07] <brrt> also, what video games?

[13:08] *** araujo_ joined
[13:08] <brrt> myself i'm keen to finally start playing the wonderful 101

[13:08] <timotimo> oooh

[13:08] <timotimo> that's a fun one

[13:08] <timotimo> i haven't played it, but i've seen it played

[13:08] <sammers> is it possible to use something like this: `use Foo; my $foo = Foo.new("some stuff here") for a `unit module Foo`, without using `unit class Foo`?

[13:08] <pochi> timotimo: sorry, it's way over my head :-)

[13:08] <Zoffix> brrt, I was commenting out lines inside this loop and it segfaulted when I uncommented the CATCH, but when I ran it again, it didn't happen: https://github.com/zoffixznet/perl6-IRC-Client/blob/rewrite/lib/IRC/Client.pm6#L46

[13:09] <timotimo> no worries :)

[13:09] <Zoffix> brrt, and I'm playing the Assassin's Creed series ATM

[13:09] <brrt> ah, IO::Socket::Async

[13:09] <brrt> never done one of those

[13:09] *** araujo_ left
[13:10] *** araujo_ joined
[13:11] <jnthn> sammers: No; a module isn't something you can make an instance of, it's just a bunch of subs

[13:11] *** Actualeyes left
[13:11] *** araujo_ left
[13:12] *** araujo_ joined
[13:12] <pochi> sammers: you can have a Foo class in your Foo module

[13:13] *** Actualeyes joined
[13:14] <sammers> jnthn: ok, thanks, that explains a lot. so `unit module Foo` and `unit class Foo` are the only ways to create a module?

[13:14] *** araujo_ left
[13:15] *** pierre_ joined
[13:15] *** araujo_ joined
[13:15] *** Actualeyes left
[13:15] *** Actualeyes joined
[13:17] *** araujo_ left
[13:17] *** araujo_ joined
[13:19] *** araujo_ left
[13:19] *** araujo_ joined
[13:21] *** pierre_ left
[13:21] *** araujo_ left
[13:21] <Zoffix> Found my issue. 

[13:21] <Zoffix> m: sub ($x) {}(1,2)

[13:21] <camelia> rakudo-moar 85682a: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in sub  at /tmp/ztHlUZTr6k line 1␤  in block <unit> at /tmp/ztHlUZTr6k line 1␤␤»

[13:21] *** araujo_ joined
[13:21] <Zoffix> The error wasn't showing up ~_~

[13:22] *** Actualeyes left
[13:22] <timotimo> right, in Audio::PortMidi there was also errors inside a started thing that weren't showing up

[13:22] <timotimo> that sent me on a wild goosechase, because i thought nativecall was at fault

[13:23] *** Actualeyes joined
[13:23] *** araujo_ left
[13:23] *** araujo_ joined
[13:24] *** wamba joined
[13:24] <Zoffix> m: await start { class {method f ($x){}}.new.f(1, 2) }

[13:24] <camelia> rakudo-moar 85682a: OUTPUT«Too many positionals passed; expected 2 arguments but got 3␤  in block <unit> at /tmp/6uoOlDbxee line 1␤␤»

[13:24] <Zoffix> ¯\_(ツ)_/¯

[13:25] <timotimo> maybe because you're awaiting it?

[13:25] *** araujo_ left
[13:25] <timotimo> so it doesn't have to go through the unhandled exception handler

[13:26] *** araujo_ joined
[13:26] <Zoffix> I'm awaiting it in my code as well...

[13:26] <timotimo> OK, damn :\

[13:27] <Zoffix> I didn't have these issues last December, when I wrote the first version of IRC::Client

[13:27] *** araujo_ left
[13:28] *** araujo_ joined
[13:30] *** araujo_ left
[13:30] *** araujo_ joined
[13:32] *** araujo_ left
[13:32] *** araujo_ joined
[13:34] *** araujo_ left
[13:34] *** araujo_ joined
[13:39] <jnthn> sammers: Or unit role Foo or unit grammar Foo... Any of the package declarators work.

[13:43] *** kaare_ joined
[13:51] <sammers> jnthn: thanks. just trying out different approaches.

[13:55] *** colomon left
[13:56] *** colomon joined
[13:57] <dalek> doc: c962649 | (Jan-Olof Hendig)++ | doc/Type/Nil.pod:

[13:57] <dalek> doc: Fixed small error in code example

[13:57] <dalek> doc: review: https://github.com/perl6/doc/commit/c962649cf4

[13:58] *** colomon left
[13:59] *** colomon joined
[14:00] *** AlexDaniel joined
[14:01] *** colomon left
[14:03] *** colomon joined
[14:10] *** colomon left
[14:10] <jnthn> 'win 3

[14:10] <jnthn> oops ;)

[14:12] *** colomon joined
[14:13] <Zoffix> Damn. Having another baffling issue with my code :S IRC::Client is cursed

[14:14] *** colomon left
[14:16] *** BenGoldberg joined
[14:16] <Zoffix> For some reason, this loop always launches just a single IO::Socket::Async: https://github.com/zoffixznet/perl6-IRC-Client/blob/rewrite/lib/IRC/Client.pm6#L21 And if I comment out one or the other server conf here, both work alone, but just one launches when two are specified :S https://github.com/zoffixznet/perl6-IRC-Client/blob/rewrite/examples/bot.pl6#L18

[14:16] <Zoffix> And the `say` in the loop does print both servers when both are provided in config :S

[14:17] <timotimo> for $events.grep: *.defined -> $e {  -  i'm surprised this works

[14:17] <timotimo> syntax-wise

[14:17] *** pierre_ joined
[14:18] <Zoffix> seems same as `for $x -> $e {` to me

[14:19] *** colomon joined
[14:20] <DrForr> Is supernous on IRC?

[14:20] <DrForr> *novus

[14:20] <timotimo> only rarely

[14:20] <timotimo> !seen supernovus

[14:20] <AlexDaniel> .

[14:20] <timotimo> .seen supernovus

[14:20] <yoleaux> I saw supernovus 22 Apr 2016 23:27Z in #perl6: <supernovus> Well, I'm going to have to run. Have a great day/night everyone. I hope to fix up some of my long neglected libraries at some point when I'm not completely overloaded with work! :-)

[14:21] <DrForr> Okay, cool. I just noticed an awkwardness with Web::Template, going to submit a PR when I'm done.

[14:21] *** khw joined
[14:22] *** pierre_ left
[14:25] <BenGoldberg> Zoffix, This doesn't seem right: https://github.com/zoffixznet/perl6-IRC-Client/blob/rewrite/lib/IRC/Client.pm6#L115 ... it looks like you discard the text which you'd be printing to the log if Terminal::ANSIColor couldn't load.  Surely you only want to discard the color?

[14:25] <Zoffix> BenGoldberg, ah, thanks. It used to be color() but I switched to colored() and that sub needs to be changed.

[14:25] <Zoffix> BenGoldberg++

[14:26] <BenGoldberg> :)

[14:27] <stevieb9> Zoffix: what gaming platform do you play on?

[14:27] <Zoffix> The one with real hardware.

[14:28] <Zoffix> And not something you get out of a cereal box :) PC Master Race!

[14:28] *** colomon left
[14:29] *** colomon joined
[14:29] *** aries_liuxueyang joined
[14:29] <ugexe> jdv79: i missed your comment on zef yesterday. im pretty sure it was due to me removing an old precomp hack (-Ilib/.precomp) for speed purposes. now i suspect its still needed for pre-locatable-precomp rakudo

[14:33] *** colomon left
[14:34] *** colomon joined
[14:35] <Zoffix> My issue was sharing variables across threads. This locked fixed (at least some of) the issues: https://github.com/zoffixznet/perl6-IRC-Client/blob/rewrite/lib/IRC/Client.pm6#L25

[14:38] *** BenGoldberg left
[14:38] *** nowan joined
[14:39] *** colomon left
[14:40] <ugexe> jdv79: can you tell me what rakudo version that happens on? I just tried on 2016.01 and it installed still, so maybe my suspicion is wrong

[14:40] *** colomon joined
[14:42] <ugexe> Zoffix: doesn't seem like you should need to do that, so maybe its something deeper

[14:43] <Zoffix> ugexe, isn't creating new keys in a hash not thread safe?

[14:43] *** BenGoldberg joined
[14:44] <Zoffix> But I also had to take care of this one: https://github.com/zoffixznet/perl6-IRC-Client/blob/rewrite/lib/IRC/Client.pm6#L111 so maybe that was the original problem anyway. I removed the Lock now and everything still works, it seems (I moved state &colored to the top of the file)

[14:44] <ugexe> im not sure how that would happen with what im looking at though

[14:45] *** jaffa4 joined
[14:45] *** colomon left
[14:46] *** colomon joined
[14:51] <Zoffix> each thread creates %.servers<a><socket> and %.servers<b><socket> (<a> and <b> exist already, but <socket>s don't). 

[14:55] <ugexe> oh i see, `<socket> =` is inside the .then

[14:55] <ugexe> so the `for` loop can advance before assignment

[14:56] *** zakharyas joined
[14:56] *** BenGoldberg left
[14:58] <ugexe> are you on osx by chance?

[14:59] *** |sir is now known as |2701

[15:00] <Zoffix> No, Bodhi Linux 

[15:01] *** kurahaupo joined
[15:01] *** molaf joined
[15:01] *** BenGoldberg joined
[15:02] *** colomon left
[15:02] *** colomon joined
[15:04] <ugexe> hmm, well you might try (before the await): `%!server.values.map(*.promise)>>.result`. On osx in the past i've had similar problems where calling a superfluous `.result` was needed to sink the promise and leave the Planned state

[15:08] *** rindolf joined
[15:08] *** colomon left
[15:08] *** hankache joined
[15:09] <hankache> m: { our $var = 'Text'; say $var.WHERE; } { our $var = 123; say $var.WHERE; } say ::('$var').WHERE;

[15:09] <camelia> rakudo-moar 85682a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/JBoVjUQdkL␤Unexpected block in infix position (missing statement control word before the expression?)␤at /tmp/JBoVjUQdkL:1␤------> 3{ our $var = 'Text'; say $var.WHERE; }7⏏5 { our $var = 123; say $va…»

[15:10] <hankache> m: { our $var = 'Text'; say $var.WHERE; }; { our $var = 123; say $var.WHERE; }; say ::('$var').WHERE;

[15:10] <camelia> rakudo-moar 85682a: OUTPUT«140562260749928␤140562260934880␤140562260934880␤»

[15:10] *** brrt left
[15:10] <hankache> should this be allowed ^^

[15:10] <hankache> is it normal?

[15:11] <Zoffix> m: class Foo { has @.foo; }; my %args = foo => [^5]; Foo.new(|%args).foo.elems.say

[15:11] <camelia> rakudo-moar 85682a: OUTPUT«1␤»

[15:12] <Zoffix> Is there a trick to make that return 5? So [^5] results in @.foo = 0, 1, 2, 3, 4 ?

[15:12] <ugexe> has $.foo

[15:12] <Zoffix> Hmr. OK

[15:12] <ugexe> or flatten in a constructor

[15:12] <timotimo> .end isn't what you want, right?

[15:12] <timotimo> oh, now i see what you mean

[15:13] <Zoffix> "Segmentation fault" ahahah 

[15:13] <Zoffix> And it's flappy too... Restarting the script doesn't show it again ~_~

[15:13] <jnthn> Zoffix: Ugh...if you could file the reproduction code for that somewhere, I can take a look at some time when I'm less tired. :)

[15:14] <Zoffix> It's pretty big. My IRC::Client rewrite.... And it's not happening reliably

[15:15] <jnthn> ugexe: btw, that "OSX bug" with promises wasn't OSX specific, and got fixed a few weeks back :)

[15:15] <Zoffix> Well, "reliably" isn't even a word... I restarted it a dozen times now without any issues. It's a ghost bug

[15:16] <jnthn> ugexe: 1ee27e660a8dc

[15:16] *** Actualeyes left
[15:16] <jnthn> Zoffix: Yeah, that's what makes them so hard to hunt, but there's various things I can do to tease them out, so still worth filing flappy stuff.

[15:17] * jnthn afk for a bit

[15:17] <ugexe> jnthn: i'll have to check the gist in this rt when i can access osx again, but the one im talking about was definitely osx specific https://rt.perl.org/Public/Bug/Display.html?id=125758

[15:20] <ugexe> but if it is the same thats an RT that can be closed

[15:23] *** buharin left
[15:23] <Zoffix> jnthn, well, I filed it, though it's big and complex to run, so I doubt how much use there is: https://rt.perl.org/Ticket/Display.html?id=128323

[15:25] <Zoffix> m: await ^5 .map: { IO::Socket::Async.connect( 'irc.freenode.net', 6667).then: { say .result } }

[15:25] <camelia> rakudo-moar 85682a: OUTPUT«IO::Socket::Async.new␤IO::Socket::Async.new␤IO::Socket::Async.new␤IO::Socket::Async.new␤IO::Socket::Async.new␤»

[15:26] <jdv79> ugexe: i was just using latest

[15:29] *** Actualeyes joined
[15:31] *** abruanese joined
[15:36] <ugexe> hmm, its not freezing for me on a build from June 3rd. all i can think of is deleting ~/.zef and ~/.perl6 (or `zef nuke RootDir home`), but i'm not sure why that should fix it even if it does work

[15:37] <jdv79> just a moment

[15:37] <ugexe> if you also run with RAKUDO_MODULE_DEBUG=1 it'll probably make it clear if its a precomp problem at least

[15:37] *** hankache left
[15:39] <jdv79> its a fresh acct and fresh p5 and p6 and well, everything

[15:44] *** wamba left
[15:50] <MadcapJake> can anyone provide some input into what I could do to differentiate between `is` the trait_mod operator and `is` the Test function https://github.com/MadcapJake/language-perl6fe/issues/29

[15:51] *** wamba joined
[15:53] *** _4d47 joined
[15:53] *** IRCBot1465142030 joined
[15:55] *** mohae joined
[15:55] <Zoffix> See if it's preceeded with <[};]>\s* ?

[15:55] <Zoffix> Won't catch everything, but... ¯\_(ツ)_/¯

[15:56] <Zoffix> hm

[15:57] <Zoffix> m: class Foo { has $.foo where { $_ } is rw; }; my $x = Foo.new: :42foo; say $x.foo

[15:57] <camelia> rakudo-moar 85682a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/lKI4uRIxv5␤Strange text after block (missing semicolon or comma?)␤at /tmp/lKI4uRIxv5:1␤------> 3class Foo { has $.foo where { $_ }7⏏5 is rw; }; my $x = Foo.new: :42foo; say ␤    expecting any of:…»

[15:57] <Zoffix> Unsure if there's some case where curly/; preceeds a trait.

[15:58] <Zoffix> say hello

[15:58] <IRCBot1465142030> How about: HELLO

[15:58] <Zoffix> :D Awesome. That bot is currently on three servers, with just a couple of extra words of config. AlexDaniel++ for pointing out the multi-server stuff :D

[16:00] <AlexDaniel> Zoffix: honestly I didn't think that you would listen :)

[16:00] <Zoffix> http://i.imgur.com/FFG853o.png

[16:00] <Zoffix> Bottom lines show stuff from other 2 servers :)

[16:01] <AlexDaniel> Zoffix: but that's a nice feature, I think that many people will appreciate it

[16:03] *** bisectable joined
[16:04] <MadcapJake> Zoffix: The way I see it, `is` is a very common trait and could very easily be "continuated" on another line.  With the current heuristics (yours included) `is` on a new line would be considered the Test function.  I'm not sure I'm happy with that compromise. Thoughts?

[16:04] <stevieb9> are there any docs that are known incomplete or known to need some scrutiny? I've been going through doc-by-doc testing all the code examples to enforce what I'm learning, but perhaps while I'm doing so, I could focus on portions that are known to need some work

[16:05] <AlexDaniel> stevieb9: https://github.com/perl6/doc/issues?q=is%3Aissue+is%3Aopen+label%3A%22needs+writing%22

[16:05] <AlexDaniel> stevieb9: or maybe even see the complete list, not just ｢needs writing｣: https://github.com/perl6/doc/issues

[16:05] <stevieb9> AlexDaniel: thanks a lot!

[16:06] <AlexDaniel> stevieb9: docs need more love. Your help will be appreciated

[16:07] <stevieb9> AlexDaniel: yep, and writing PRs/patches will further help me pick things up, and help everyone in the future.

[16:07] <Zoffix> MadcapJake, I meant mark it as function *only* when it's preceeded by '}' or ';'

[16:08] <MadcapJake> ahh well, then we're still left with the current state: `is` on a new line is considered a trait

[16:08] <Zoffix> MadcapJake, but that ticket really feels more as a won't-fix to me. I mean, it's a function from a module. What if someone names a function `but`? It'd be highlighted as a trait 

[16:09] <Zoffix> Looks the same on my theme anyway: http://i.imgur.com/i6SiZ0u.png

[16:10] <MadcapJake> yeah I'm thinking that too, I can't think of anything that would more fully distinguish `is`

[16:10] *** Sgeo_ joined
[16:10] <MadcapJake> Zoffix: that's cus it's still considered trait_mod operator there

[16:10] *** Ven left
[16:10] <Zoffix> Oh, right.. I'm dumb :D

[16:11] <MadcapJake> I don't have anything in there currently that distinguishes (I could add a simple "^is" for the Test function)

[16:11] <AlexDaniel> OK, *ding ding ding ding*. Last time I introduced bisectable (http://irclog.perlgeek.de/perl6/2016-05-20#i_12514921), but some people pointed out that it is LTA because it does not check if the query makes sense.

[16:11] <AlexDaniel> well, guess what!

[16:11] <AlexDaniel> bisect: exit 42

[16:11] <bisectable> AlexDaniel: (2015-12-25) https://github.com/rakudo/rakudo/commit/07fecb5

[16:12] <AlexDaniel> what

[16:12] * Zoffix giggles

[16:12] <AlexDaniel> sorry, that's the old version

[16:12] *** bisectable left
[16:13] *** bisectable joined
[16:13] <AlexDaniel> bisect: exit 42

[16:13] <AlexDaniel> bisect: exit 42

[16:13] <bisectable> AlexDaniel: on both starting points the exit code is 42 and the output is identical as well

[16:13] <bisectable> AlexDaniel: on both starting points the exit code is 42 and the output is identical as well

[16:13] <AlexDaniel> ah ok

[16:14] <Zoffix> \o/

[16:14] <AlexDaniel> but notice how it talks about the output

[16:14] <AlexDaniel> which means that…

[16:14] <AlexDaniel> well, let's take a look at one example

[16:14] <AlexDaniel> bisect: exit 1 if (^∞).grep({ last })[5] // 0 == 4 # RT 128181

[16:14] <bisectable> AlexDaniel: (2016-03-18) https://github.com/rakudo/rakudo/commit/6d120ca

[16:14] <AlexDaniel> previously I was showing this example

[16:14] <AlexDaniel> but now you can simplify it to this

[16:14] <AlexDaniel> bisect: say (^∞).grep({ last })[5]

[16:14] <bisectable> AlexDaniel: exit code is 0 on both starting points, bisecting by using the output

[16:14] <bisectable> AlexDaniel: (2016-03-18) https://github.com/rakudo/rakudo/commit/6d120ca

[16:14] <Zoffix> :o

[16:15] <AlexDaniel> look! You don't have to CATCH anything, you don't have to care about the exit code!

[16:15] <Zoffix> Sweet. AlexDaniel++

[16:15] <AlexDaniel> even the dumbest person out of all idiots (like me) can now use it!

[16:16] <AlexDaniel> by the way, if anybody is wondering what is going to happen if you accidentally switch good and bad revisions

[16:16] <AlexDaniel> bisect: good=2016.03 bad 2016.02 say (^∞).grep({ last })[5]

[16:16] <bisectable> AlexDaniel: exit code is 0 on both starting points, bisecting by using the output

[16:16] <bisectable> AlexDaniel: “bisect run” failure

[16:17] <AlexDaniel> that's a bit LTA (mainly beacuse git itself has a good error message for this case), but it is still fine

[16:18] <AlexDaniel> bisect: for ‘q b c d’.words -> $a, $b { }

[16:18] <bisectable> AlexDaniel: (2016-06-05) https://github.com/rakudo/rakudo/commit/85682a5

[16:18] <AlexDaniel> … there's still some room for improvement though…

[16:19] *** Guest690 is now known as parisba

[16:21] <_4d47> m: class A { has $.wut = [] }; my $a = A.new; $a.wut = [1,2,3]; $a.wut

[16:21] <camelia> rakudo-moar 85682a: ( no output )

[16:21] <Zoffix> m: class A { has $.wut = [] }; my $a = A.new; $a.wut = [1,2,3]; $a.wut.say

[16:21] <camelia> rakudo-moar 85682a: OUTPUT«[1 2 3]␤»

[16:21] <_4d47> m: class A { has $.wut = [] }; my $a = A.new; $a.wut = [1,2,3]; dd $a.wut

[16:21] <camelia> rakudo-moar 85682a: OUTPUT«[1, 2, 3]␤»

[16:22] <Zoffix> wtf is it writable :S

[16:22] <Zoffix> m: class A { has $.wut }; my $a = A.new; $a.wut = [1,2,3]; dd $a.wut

[16:22] <camelia> rakudo-moar 85682a: OUTPUT«Cannot modify an immutable Any␤  in block <unit> at /tmp/2BHCN8yCLh line 1␤␤»

[16:22] <Zoffix> m: class A { has $.wut = 42 }; my $a = A.new; $a.wut = [1,2,3]; dd $a.wut

[16:22] <camelia> rakudo-moar 85682a: OUTPUT«Cannot modify an immutable Int␤  in block <unit> at /tmp/Ei2grkkbSp line 1␤␤»

[16:23] <_4d47> on classtut doc and was expecting wut to be read-only

[16:24] <Zoffix> bisect: class A { has $.wut = [] }; my $a = A.new; $a.wut = [1,2,3]; $a.wut.say

[16:24] <bisectable> Zoffix: (2016-06-05) https://github.com/rakudo/rakudo/commit/85682a5

[16:25] <Zoffix> _4d47, that looks like a bug to me. You should report it.

[16:25] <Zoffix> Though maybe this is due to container stuff

[16:25] <Zoffix> m: class A { has $.wut = %() }; my $a = A.new; $a.wut = 1,2,3,4; dd $a.wut

[16:25] <camelia> rakudo-moar 85682a: OUTPUT«Hash % = {"1" => 2, "3" => 4}␤»

[16:25] <Zoffix> Yeah, probably.

[16:26] <Zoffix> m: class A { has %.wut }; my $a = A.new; $a.wut = 1,2,3,4; dd $a.wut

[16:26] <camelia> rakudo-moar 85682a: OUTPUT«Hash %!wut = {"1" => 2, "3" => 4}␤»

[16:26] <Zoffix> :S

[16:27] <_4d47> Zoffix: what is = %() ?

[16:27] <Zoffix> empty hash

[16:27] *** parisba left
[16:28] *** parisba joined
[16:30] <BenGoldberg> bisect: Scalar.new = 5

[16:30] <bisectable> BenGoldberg: on both starting points the exit code is 1 and the output is identical as well

[16:30] <BenGoldberg> bisect: m: (^100).pick(*).map: { start { sleep $_; .say } }

[16:30] <bisectable> BenGoldberg: exit code is 0 on both starting points, bisecting by using the output

[16:30] <bisectable> BenGoldberg: (2015-12-27) https://github.com/rakudo/rakudo/commit/1bdb784

[16:31] <_4d47> Zoffix: where  should I report ?

[16:32] <Zoffix> huggable, rakudobug

[16:32] <huggable> Zoffix, [email@hidden.address] or use perl6 query on http://rt.perl.org ; see https://github.com/rakudo/rakudo/#reporting-bugs

[16:32] <Zoffix> _4d47, ^

[16:33] <_4d47> ok great thanks ! 

[16:33] <BenGoldberg> bisect: use nqp; nqp::const::just_a_test;

[16:33] <bisectable> BenGoldberg: on both starting points the exit code is 1 and the output is identical as well

[16:34] *** Ven joined
[16:36] *** Ben_Goldberg joined
[16:36] *** BenGoldberg left
[16:36] *** Ben_Goldberg is now known as BenGoldberg

[16:36] <BenGoldberg> bisect: m: my $x := (my $y := $x); say $x.WHAT;

[16:36] <bisectable> BenGoldberg: exit code is 0 on both starting points, bisecting by using the output

[16:36] <bisectable> BenGoldberg: (2016-04-13) https://github.com/rakudo/rakudo/commit/ae2ae92

[16:38] *** Aliv3 joined
[16:40] *** Ven left
[16:43] *** Ven joined
[16:44] *** mohae left
[16:55] *** Ven left
[16:57] *** mohae joined
[17:01] *** girafe joined
[17:03] *** Ven joined
[17:09] *** Deep_Thought left
[17:10] *** Ven left
[17:11] *** buharin joined
[17:11] <jdv79> ugexe: any ideas about that issue?

[17:11] <jdv79> maybe i should just use an older release

[17:12] <ugexe> gimmie a minute, im writing down what i know

[17:12] *** user9 joined
[17:14] *** IRCBot1465142030 left
[17:16] *** IRCBot1465147004 joined
[17:21] *** vendethiel joined
[17:21] <gfldex> lizmat: if I understand Mu.Capture right, it will only return a non-empty Capture when public accessors are present. That means it will silently drop data. A NYI would be more helpful.

[17:22] *** Ven joined
[17:24] <gfldex> m: say 10.Capture // \(10);

[17:24] <camelia> rakudo-moar 85682a: OUTPUT«\()␤»

[17:25] *** _mg_ joined
[17:25] *** user9 left
[17:25] <gfldex> m: say 10.Capture || \(10);

[17:25] <camelia> rakudo-moar 85682a: OUTPUT«\(10)␤»

[17:26] *** Ven left
[17:26] <jdv79> does travis do a new build if a dep changes?

[17:26] <jdv79> for instance Inline::Perl5 on rakudo changes?  or does it run periodically?

[17:27] <ugexe> no, only on new commits/PRs

[17:27] <jdv79> gah

[17:28] <gfldex> jdv79: see https://github.com/travis-ci/travis-ci/issues/631

[17:29] <jdv79> isn't the C in CI continuous?

[17:29] <jdv79> it'd be super simple to just do _that_ like cpan testers do

[17:30] <jdv79> ugexe: same results with selinux off

[17:31] *** user9 joined
[17:32] <ugexe> damn. i don't have the slightest idea where to even look next

[17:32] <jdv79> nine: how do we fix it?

[17:35] *** Actualeyes left
[17:36] *** Actualeyes joined
[17:42] *** Ven joined
[17:44] <stevieb9> is there a doc for contributing to docs? I'm going to try to tackle https://github.com/perl6/doc/issues/530 to get started, but want a better idea of how the 'Defined as:' sections are generated (or if they're manually created) etc

[17:45] *** Actualeyes left
[17:46] *** brrt joined
[17:46] *** user9 left
[17:49] <jdv79> there's a repo 

[17:50] <jdv79> https://github.com/perl6/doc

[17:50] <jdv79> and there is a CONTRIBUING.md file.  i've just does PRs or commits on that repo in the past.

[17:50] <jdv79> *done

[17:50] *** BenGoldberg left
[17:50] *** Aliv3 left
[17:51] <DrForr> m: "hi [[there]]" ~~ s:g{ '[[' ( .+? ) ']]' } = qq{<a href="$0"/>};

[17:51] <camelia> rakudo-moar 85682a: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at /tmp/7SyIMd2Yg1 line 1␤␤»

[17:52] <DrForr> m: my $x= "hi [[there]]";$x ~~ s:g{ '[[' ( .+? ) ']]' } = qq{<a href="$0"/>}; say $x

[17:52] <camelia> rakudo-moar 85682a: OUTPUT«hi <a href="there"/>␤»

[17:52] <DrForr> m: my $x= "hi [[there]]";$x ~~ s:g{ '[[' ( .+? ) ']]' } = qq{<a href="$0">$0</a>}; say $x

[17:52] <camelia> rakudo-moar 85682a: OUTPUT«Use of Nil in string context  in code  at /tmp/TWw6c70S4Y line 1␤hi <a href="there">␤»

[17:53] *** |2701 left
[17:53] <DrForr> $0 can't be used twice? Or I'm not understanding something?

[17:53] <DrForr> Probably the latter, but I'm confused.

[17:54] *** user9 joined
[17:56] <teatime> DrForr: is $0</a> being interpreted as a hash lookup?

[17:56] <DrForr> Oh, good point.

[17:57] <jdv79> DrForr: i can't even read that.  are you assigning to a subst?  i must be blind.

[17:58] <DrForr> Yeah, that's how it's interpreted. {$0}</a> worked just fine.

[17:58] <DrForr> jdv79: YEs.

[17:58] <DrForr> *Yes

[17:59] <jdv79> what does it mean ?

[18:00] <DrForr> In old-sk00l s{\[\[(.+)\]\]}{<a href="there/$1">$1</a>}g;

[18:00] <jdv79> is that syntax doc'd?  the new i mean?

[18:00] <jdv79> not sure i've ever seen it

[18:01] <DrForr> Well, I did the alternate version, I think someone did the original...

[18:02] <geekosaur> it's in the synopses; may not be in the docs

[18:02] <jdv79> so the second levels docs:)

[18:02] <jdv79> *level

[18:02] <geekosaur> the real docs, not the speculations

[18:02] <geekosaur> :p

[18:03] <jdv79> oh its inte hdocs

[18:03] *** user9 left
[18:03] <jdv79> last part of http://doc.perl6.org/language/operators#Substitution_Operators

[18:04] <DrForr> Hrm, more yak shaving or getting something ready.... I vote the latter.

[18:06] <jdv79> it's be easier to just do s{foo}{bar} no?  like p5 does.

[18:06] <jdv79> *it'd

[18:09] *** _nadim joined
[18:09] <psch> m: $_ = "foo"; s{foo}{bar}; .say

[18:09] <camelia> rakudo-moar 85682a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/45Hs1UNQ2x␤Unsupported use of brackets around replacement; in Perl 6 please use assignment syntax␤at /tmp/45Hs1UNQ2x:1␤------> 3$_ = "foo"; s{foo}7⏏5{bar}; .say␤»

[18:10] <jdv79> its just a wat syntactically for me (the new assigment/replacement part)

[18:10] *** Ven left
[18:11] <psch> jdv79: s/// just doesn't support paired delimiters anymore

[18:12] <psch> well, not without pulling the regex and replacement apart

[18:12] *** brrt left
[18:12] <psch> FSVO "anymore"

[18:12] <psch> i mean, Perl 6 is not a "next version" after all :)

[18:12] *** Ven joined
[18:14] <mst> I'm sure there was a very early revision of perl6 that supported it for at least one commit

[18:14] <mst> and if anybody challenges you, they can go through every commit ever to rakudo and niecza and pugs to prove you wrong, clearly :D

[18:14] <psch> fair point :)

[18:15] *** zakharyas left
[18:18] <geekosaur> am pretty sure that did work in pugs. but it was a PITA to parse sanely so it went away

[18:18] <geekosaur> (pugs iirc cheated)

[18:19] <psch> by tossing one pass parsing i guess?

[18:19] <geekosaur> and yes, it does work in perl5, but perl5's parsing is a mess of special cases

[18:20] <geekosaur> I think pugs got that case to work but lost others instead

[18:20] <geekosaur> and trying to make those others work led to the realization that it wasn't going to ever be sane

[18:22] <geekosaur> pugs went through a lot of that, it's the reason the file tests changed so much before reaching their current form

[18:22] <geekosaur> (they started out being similar to perl5)

[18:26] *** Ven left
[18:30] <DrForr> Well, I'm going to rewrite it properly as a grammar, but I thought a stopgap solution would work for the time being.

[18:32] *** Ven joined
[18:43] *** BenGoldberg joined
[18:45] *** ssotka joined
[18:46] <nine> jdv79: fix what?

[18:46] *** girafe left
[18:49] <stevieb9> nine: I *think* jdv79 meant how to make travis do a full build if a dep is committed to

[18:53] *** setty1 joined
[18:55] <stevieb9> here's a doc that hints that alternate delims were at once available in regex substitution: http://search.cpan.org/~dconway/Perl6-Rules-0.03/Rules.pm#Evaluated_substitutions

[18:56] <psch> m: $_ = "foo"; s!foo!bar!; .say

[18:56] <camelia> rakudo-moar 85682a: OUTPUT«bar␤»

[18:56] <Zoffix> Well, it still works with s{foo} = {bar} or whatever the correct way to spell the form with an equals sign is

[18:56] *** zakharyas joined
[18:56] <stevieb9> sorry... *paired* delimiters, ie. {}

[18:58] <mst> I actually quite like the assignment form

[18:58] <mst> maybe I'm just weird

[18:58] <Zoffix> m: $_ = 'foobar'; s{foo} = 'meow'; .say

[18:58] <camelia> rakudo-moar 85682a: OUTPUT«meowbar␤»

[18:58] <Zoffix> m: $_ = 'foobar'; s{foo} = {}; .say

[18:58] <camelia> rakudo-moar 85682a: OUTPUT«bar␤»

[18:59] <Zoffix> m: $_ = 'foobar'; s{foo} = {meow}; .say

[18:59] <camelia> rakudo-moar 85682a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/Zr66Jk_y_f␤Undeclared routine:␤    meow used at line 1␤␤»

[18:59] <Zoffix> The last example in this section should probably be amended as it implies {} is just a way to write an empty string and you can put any string there: http://docs.perl6.org/language/operators#Substitution_Operators

[18:59] <Zoffix> m: $_ = 'foobar'; s{foo} = q{meow}; .say

[18:59] <camelia> rakudo-moar 85682a: OUTPUT«meowbar␤»

[19:00] <psch> yeah, that example is a bit weird

[19:00] *** colomon joined
[19:00] <psch> i'd rather it just uses an empty Str

[19:01] <psch> m: say {}

[19:01] <camelia> rakudo-moar 85682a: OUTPUT«{}␤»

[19:01] <psch> m: print {}

[19:01] <camelia> rakudo-moar 85682a: ( no output )

[19:01] <psch> m: print ~{}

[19:01] <camelia> rakudo-moar 85682a: ( no output )

[19:02] <psch> m: print Hash.new

[19:02] <camelia> rakudo-moar 85682a: ( no output )

[19:02] <AlexDaniel> m: m: say ‘hello’

[19:02] <camelia> rakudo-moar 85682a: OUTPUT«hello␤»

[19:02] <Zoffix> m: {}.WHAT.say

[19:02] <camelia> rakudo-moar 85682a: OUTPUT«(Hash)␤»

[19:02] <AlexDaniel> is m: a label here? ↑

[19:03] *** abruanese left
[19:03] *** Zero_Dogg left
[19:04] *** Zero_Dogg joined
[19:04] *** colomon left
[19:07] <masak> AlexDaniel: yes

[19:07] <yoleaux> 00:20Z <raiph> masak: re "when (*, * < 0) { ... }"; does "when (*; * < 0) { ... }" work for your use case?

[19:07] <Zoffix> m: m: loop { loop { last m if $++ > 5; say $++ }; say "yup" }

[19:07] <camelia> rakudo-moar 85682a: OUTPUT«0␤1␤2␤3␤4␤5␤»

[19:07] <yoleaux> 00:25Z <TimToady> masak: or were you expecting it to do (**, * < 0) instead?

[19:07] <psch> m: m: while True { last m if $++ > 3; LEAVE { say "\o/" } }

[19:07] <camelia> rakudo-moar 85682a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/sJJ7Si18Pb␤Unrecognized backslash sequence: '\o'␤at /tmp/sJJ7Si18Pb:1␤------> 3True { last m if $++ > 3; LEAVE { say "\7⏏5o/" } }␤    expecting any of:␤        argument list␤        double quo…»

[19:07] <psch> m: m: while True { last m if $++ > 3; LEAVE { say '\o/' } }

[19:07] <camelia> rakudo-moar 85682a: OUTPUT«\o/␤\o/␤\o/␤\o/␤\o/␤»

[19:07] <psch> m: m: while True { last m if $++ > 3; LAST { say '\o/' } }

[19:07] <camelia> rakudo-moar 85682a: OUTPUT«\o/␤»

[19:07] <Zoffix> while True!

[19:07] * Zoffix shakes head.

[19:07] <psch> keep mixing these up :/

[19:07] <Zoffix> How un-Perl-6-like :)

[19:07] *** buharin left
[19:08] <psch> Zoffix: what else? 'while [*]'? :P

[19:08] *** buharin joined
[19:08] <Zoffix> psch, loop { }

[19:08] <psch> oh, right, we have that

[19:08] <Zoffix> :)

[19:10] <masak> m: given (1; -3) { when (*; * < 0) { say "yup, that works" }; default { say "sorry, no" } }

[19:10] <camelia> rakudo-moar 85682a: OUTPUT«yup, that works␤»

[19:11] <masak> raiph: seems that could work :)

[19:11] <grondilu> about loop {}, can't help but:  http://www.perlmonks.org/?node_id=1057242

[19:12] <grondilu> I know it's old, but I keep thinking about it from times to times.

[19:15] *** spider-mario joined
[19:19] *** labster joined
[19:20] *** araujo__ joined
[19:24] *** araujo_ left
[19:26] <buharin> hi guys

[19:28] <AlexDaniel> m: sleep ∞

[19:29] <camelia> rakudo-moar 85682a: OUTPUT«(timeout)»

[19:29] <Zoffix> m: sleep sleep

[19:29] <Zoffix> buharin, just guys? :)

[19:30] <buharin> yep

[19:30] <buharin> no girls here

[19:30] <camelia> rakudo-moar 85682a: OUTPUT«(timeout)»

[19:31] <Zoffix> Man, social media is such a waste of time....

[19:31] * Zoffix leaves to play Assassin's Creed

[19:32] <AlexDaniel> .oO( Perl 6 – free sex change for every IRC user )

[19:33] *** mst joined
[19:33] *** ChanServ sets mode: +q *!*@90-156-117-46.internetia.net.pl

[19:34] <mst> buharin: (1) not true (2) ye gods, are you actually *trying* to make female hackers feel unwelcome in here? (3) as standard for such comments, you are now quieted for 24h while you go away and think about it.

[19:34] <Zoffix> mst++

[19:34] <Zoffix> "chainsaw-wielder"? Nice host lol

[19:36] *** rindolf left
[19:36] * AlexDaniel agrees that it was deserved

[19:38] <AlexDaniel> MasterDuke: are you going to submit another pull request?

[19:44] <MasterDuke> AlexDaniel: yeah, i'm moving the non-duplicative tests to S03-operators/relational.t

[19:44] <AlexDaniel> ok

[19:45] <mst> I strongly suspect that it was largely 'lack of thought' on his part, but that's why I use a standard of '24h tempban' rather than anything heavier

[19:50] <gnull> hello everyone

[19:50] <Zoffix> \o

[19:52] <DrForr> Evenin'.

[19:52] <gnull> I was reading documentation on `race` sub at https://doc.perl6.org/type/Iterable#method_race

[19:52] <gnull> s/sub/method/

[19:52] * geekosaur will preemptively point out that race is known buggy currently

[19:53] <geekosaur> there's a couple of open "where'd my results go?" tickets

[19:53] *** BenGoldberg left
[19:53] <gnull> Hmm, that is why it segfaults))

[19:54] <gnull> A couple of times

[19:54] <Zoffix> likely

[19:54] <Zoffix> gnull, here's my version of a .race-like Promise-using code: https://gist.github.com/zoffixznet/ae7bcf0efc99eba8eaadbd917238ff1a

[19:54] *** BenGoldberg joined
[19:55] <Zoffix> It may have an off-by-one error, unsure.

[19:55] <AlexDaniel> gnull: do you have a golfed down version?

[19:55] <AlexDaniel> gnull: .race does not work, yes, but I've never seen it segfault

[19:56] <mst> geekosaur: ah, it's currently providing WORN storage

[19:57] *** btyler joined
[19:57] <Zoffix> WORN?

[19:58] <jnthn> Write Once, Read Never? :)

[19:58] <gnull> I'm using version from rakudo-star-2016.04.tar.gz downloaded from rakudo.org

[19:58] <Zoffix> heh

[20:00] <mst> what jnthn said :D

[20:01] <gnull> the segfaulting code looks like: for @list1.race(batch => 2, degree => 2) { for @list2 { shell "some-command" } }

[20:01] <btyler> hi folks -- a question about promises/concurrency. is it a reasonable thought that I should be able to use promises similarly to goroutines or erlang processes? that is, potentially long-lived little units of concurrent action, like 'promise per web request' in a web server

[20:01] <geekosaur> hm I bet threading and forking do not mix very well

[20:01] <geekosaur> on posix at least that's a minefield

[20:01] <gnull> excuse me, the previous code doesn't segfault

[20:01] *** yqt joined
[20:01] <btyler> (I'm giving a talk that says _yes_! they should!, but I should ask around so I can tell people if this is a good thing or just a crazy thing)

[20:02] <gnull> changing @list2 to $list2 makes it segfault

[20:03] <gnull> In C if you use clone/fork directly it should be OK

[20:03] <gnull> I mean the case when fork() is followed by exec()

[20:04] <AlexDaniel> gnull: can you provide a full example? I'm having troubles reproducing it

[20:06] <mst> btyler: that's basically how IO::Async based web stuff works

[20:06] <mst> btyler: (in perl5)

[20:08] <Zoffix> btyler, yeah, they run concurrently, [potentially] in a different thread. No idea about goroutines or erlang, but with Promises you have to be careful modifying data that's shared across them.

[20:08] <btyler> mst: can you expand on that? I'm familiar with AnyEvent and the mojo concurrency bits; is IO::Async substantially different? I guess the core property I'm asking about is cooperative vs pre-emptive scheduling. pretty much all async in perl5 is event loop based, so it's cooperative and you need to avoid sleep(5)/blocking queries/etc.

[20:09] <Zoffix> btyler, you can sleep in promises

[20:09] <btyler> promises are cooperative on the function termination, so if your # of concurrent promises tops out the thread pool you block

[20:09] <btyler> Zoffix: until you max out the thread pool, and then no new promises get run while the current batch are sleeping :)

[20:09] <btyler> well, let me upgrade all the things, maybe I'm behind the times

[20:10] <Zoffix> m: await ^10 .map: { start sleep 1; }; say now - INIT now;

[20:10] <camelia> rakudo-moar 85682a: OUTPUT«1.00491933␤»

[20:10] <Zoffix> m: await ^100 .map: { start sleep 1; }; say now - INIT now;

[20:10] <camelia> rakudo-moar 85682a: OUTPUT«Memory allocation failed; could not allocate 15080 bytes␤»

[20:10] <Zoffix> m: await ^20 .map: { start sleep 1; }; say now - INIT now;

[20:10] <camelia> rakudo-moar 85682a: OUTPUT«Memory allocation failed; could not allocate 15072 bytes␤»

[20:10] <AlexDaniel> Zoffix: :P

[20:10] <gnull> AlexDaniel: The program is here https://gist.github.com/gnull/d9fa51cb5b340151d5928a8244152aac. It uses a couple of text files when running, so I uploaded an archive here https://www.dropbox.com/s/9rtu6bwewmuodco/segfault.tar?dl=0.

[20:10] <AlexDaniel> Zoffix: 10 kbytes should be enough for everyone

[20:11] <mst> btyler: IO::Async is all based around Future these days

[20:11] <btyler> mst: sure, but it still runs an event loop under the hood, so we're still talking about cooperative scheduling, yeah?

[20:11] <mst> btyler: AnyEvent is a bag of razorblades and teaches you very little except "don't use AnyEvent for production code"

[20:11] <AlexDaniel> gnull: alright, I'll give it a try here

[20:11] <btyler> e.g. if I sleep(5) in my future, everything stops

[20:11] <btyler> is that right?

[20:11] <mst> btyler: yes. but the one-future-per-request approach still works fine.

[20:11] <btyler> as long as you don't use a blocking DBI call

[20:11] <mst> my point here is that even *without* the multithreading stuff, it's a good pattern

[20:11] <Zoffix> btyler, what's "everything"?

[20:12] <Zoffix> m: await ^10 .map: { start sleep 1; }; say now - INIT now;

[20:12] <camelia> rakudo-moar 85682a: OUTPUT«1.006371␤»

[20:12] <Zoffix> btyler, ^ 10 1-second sleeps finish in 1 second.

[20:12] <gnull> AlexDaniel: core dump appears in a couple of minutes if you are interested.

[20:12] <btyler> Zoffix: in a single threaded event loop (as in pretty much all perl 5 concurrency libs that I know of) sleeping blocks the loop, so nothing happens

[20:12] <mst> btyler: yes, we know

[20:12] <btyler> sorry, that was in regards to perl 5, responding to mst

[20:12] <Zoffix> btyler, this is Perl 6

[20:12] <mst> btyler: please stop stating random obvious things that are nothing to do with what I said

[20:12] <mst> Zoffix: yes, please read what *I* was saying

[20:12] <gnull> I guess I should have compiled perl6 with debugging symbols.

[20:12] * mst grumbles

[20:12] <btyler> mst: sorry! trying to answer two people

[20:13] <mst> btyler: yes, but you're basically lecturing me on co-operative multitsaking 101

[20:13] <mst> it's not actually helpful when I'm trying to make a point

[20:13] <mst> so, starting again

[20:13] <btyler> fair enough, apologies

[20:14] <mst> given that, *even in perl5*, one future per request is a valid and pretty effective pattern

[20:14] <mst> I would suggest that one promise per request in perl6 is merely going to be even better

[20:14] <Zoffix> btyler, well, this is on a 2-core box, the ^number indicates the number of promises started and each sleeps for 1 second. The output indicates the number of seconds the program ran: https://gist.github.com/zoffixznet/1eb5aab322140c928183f9f17f6f0749

[20:14] <mst> Zoffix: hush

[20:14] <Zoffix> btyler, so there isn't an unlimited amount of threads, but I think even that can be increase as well.

[20:14] <btyler> Zoffix: yep, thanks, give me a minute to hash it out with mst

[20:15] <mst> Zoffix: this was a question about one promise per request as a pattern originally

[20:15] <mst> can we complete that before you start talking thread pools?

[20:15] *** Zoffix left
[20:15] <AlexDaniel> gnull: well, it would be nice to have a bug report

[20:15] <mst> btyler: I've tended to find that you end up with two sorts of 'thing', as it were

[20:15] <mst> tasks, whose primary prupose is to fulfill or fail a single promise

[20:16] <mst> and services, which are longer running and I think in perl6 I'd expect to be watching a channel/supply

[20:16] <AlexDaniel> gnull: ok, after several runs it actually segfaulted

[20:16] <mst> btyler: but, yeah, basically, I think you're on the right track

[20:17] <btyler> mst: ok, my apologies, XY'd

[20:17] * mst has code on his dev box to add decent future support to Mojo as well

[20:17] <mst> because I want access to the mojo ecosystem too but after http://p3rl.org/Future and http://p3rl.org/Future::Utils I don't want to deal with callbacks again

[20:17] <btyler> mst: let me back up: with IO::Async using a future-per-request pattern, I assume the same cavaets about blocking DBI calls apply as they would to anyevent/mojo under callbacks

[20:17] <gnull> AlexDaniel: should I create an issue for moarvm or submit it somewhere for rakudo?

[20:18] <mst> btyler: well, yes, of course, it's still one process

[20:18] <btyler> right

[20:18] <mst> btyler: one of the things I wanted access to here was Mojo::Pg

[20:18] <mst> btyler: and, yeah, you have to create a timer future rather than a sleep

[20:18] <mst> remember that async/await can be rewritten into promises

[20:19] <mst> effectively, in perl5, you do that yourself, and in perl6, the language does it for you

[20:19] <AlexDaniel> gnull: actually, your code can be simplified

[20:19] <AlexDaniel> let's see

[20:19] <mst> but, either way, promise-per-request worsk really well

[20:19] <mst> btyler: note that AE's condvars are *almost* like futures except full of sharp edges

[20:19] <mst> so if you think of the times you used condvars and it went *right*, that's also evidence

[20:20] <btyler> those same cavaets _do not_ apply in erlang or go, because the $unit-of-concurrency blocking on a DB query will get shoved off the CPU. I'm trying to clarify if Perl6 Promises should be treated as subject to those blocking cavaets or not

[20:20] <btyler> right now the situation is "you're fine doing blocking stuff...until you exhaust the thread pool"

[20:20] <gnull> AlexDaniel: The interesting thing is that it doesn't segfault (al least for me) if you s/$exploits/@exploits/g

[20:20] <AlexDaniel> gnull: usually such things are mailed to [email@hidden.address]
[20:21] <btyler> DB query is a potentially misleading example, same applies for plain old CPU bound code in erlang/go

[20:21] <AlexDaniel> gnull: that is, all bugs are here: http://rt.perl.org/

[20:21] <mst> btyler: aha, I see. though, I mean, go has MAXPROCS and erlang has schedulers

[20:21] <btyler> yes

[20:21] <btyler> perl6 also has that, after a fashion

[20:21] <mst> I guess it depends on whether rakudo+moarvm does suspend and resume so thread pool is equivalent to that

[20:21] <mst> and, er, that's above my paygrade

[20:21] <btyler> right. right now it does not

[20:21] <btyler> but the current situation seems a bit caught in the middle

[20:21] <mst> I *think* some of the stuff being worked on will?

[20:21] <mst> I mean, I believe that's supposed to happen eventually

[20:22] <btyler> my apologies for letting the conversation evolve into a tangent about perl5 async

[20:22] <mst> in the meantime, I think I'd probably just stick to doing things as async as possible

[20:22] <mst> it was fine, it was just annoying when you started trying to explain what co-operative multitasking was

[20:23] <mst> but evidently I didn't make my "if this is a good pattern under co-op, one should assume it's even better under pre-emptive" thesis sufficiently clear

[20:23] <btyler> ok, fair enough, that makes sense

[20:23] <AlexDaniel> gnull: the problem here is not with just race

[20:24] <jnthn> At the moment, `await` blocks a thread, and TheadPoolScheduler isn't overly smart in the "how many threads" question. Both are certainly up for being addressed.

[20:24] <btyler> although it does strike me as a bit funky to use that under co-op without access to good async DB interaction? but you surely have more experience there, so if you say it works pretty ok, I'll take your word for it

[20:24] <AlexDaniel> gnull: it is some kind of a general async problem

[20:24] <mst> mmm

[20:24] <AlexDaniel> gnull: I've seen that too many times but couldn't figure out how to rakudobug it

[20:24] <mst> of course, if the thread's just sat there being blocked

[20:24] <mst> you can probably afford to have lots of threads

[20:24] <jnthn> (The await one first)

[20:24] <AlexDaniel> gnull: just a second, I'll make your example really short

[20:24] *** zakharyas left
[20:24] <mst> jnthn: occasionally I envy C# its rewrite-to-futures approach to await

[20:25] <jnthn> At the moment you can sorta overcome it by having a high limit for the thread pool.

[20:25] <btyler> jnthn: hi! I suppose - design-wise, is the plan that promises will be preemptively scheduled across thread pool size, or they're meant to always and forever get an entire thread to themselves while executing?

[20:25] <jdv79> nine: can't get IP5 to work

[20:25] <jnthn> mst: Well, yes and no. :) I mean, it's nice, but forces refactoring types all the way down the call chain. We already *have* continuations, so `await` should "just" use that.

[20:26] <mst> jnthn: oh, yes, I said 'occasionally'

[20:26] <jdv79> ugexe says it works for him.  maybe its a fedora or some other env factor?

[20:26] <AlexDaniel> jnthn: by the way, this segfault is really annoying. I'd be happy if you took a look

[20:26] <AlexDaniel> when it is rakudobugged, of course

[20:26] *** rindolf joined
[20:26] <mst> jnthn: usually shortly followed by remembering all the other things you just said ;)

[20:26] *** Ven left
[20:27] *** buharin left
[20:27] <jnthn> btyler: They already are scheduled across threads, it's just that when `await` blocks you gotta be careful how you write things so you don't exhaust said pool of threads. The idea was always that `await` would not work in that way, there simply wasn't time to get it done ahead of the xmas release, or at least not without putting aside other things that'd have been harder to change later. :-)

[20:28] <mst> note: I'm about to head off. if I haven't lifted buharin's +q by about 6pm tomorrow, somebody please remind me

[20:28] <jnthn> AlexDaniel: File it, I'll see if I can look at it during the next week...

[20:29] <jnthn> AlexDaniel: race/hyper are in for attention relatively soon also...as usual, I have far more things I want to be doing than time to do them. :)

[20:29] <AlexDaniel> jnthn: this issue is not about race/hyper specifically

[20:30] <AlexDaniel> although the rakudobugged code will probably include it :)

[20:30] <nine> jdv79: details?

[20:30] <btyler> jnthn: ok, thanks for the clarifying. to make sure I've understood correctly, the plan is for long-running promises to get pre-empted if you have more promises than threads in the thread pool, but it just isn't implemented yet

[20:30] <AlexDaniel> gnull: ok, now I'm starting to remember :)

[20:30] <AlexDaniel> gnull: if you change it even a little bit, it stops segfaulting

[20:31] <gnull> jnthn: Hmm, are you Jonathan Worthington? The guy that made that awesome talk on concurrency/parallelism/asynchrony?

[20:31] <gnull> https://www.youtube.com/watch?v=JpqnNCx7wVY

[20:31] <gnull> This talk i mean

[20:32] <lizmat> gnull: yup, that's the guy

[20:32] <gnull> jnthn: Great Talk! Thank you. It made me love perl more :)

[20:32] <jnthn> btyler: Not *quite*. It's that we'll make `await` be something that yields control, though you won't have to think about it doing so (except in the cases where you do ;))

[20:32] <jnthn> gnull: Glad you enjoyed it :)

[20:33] <AlexDaniel> gnull: ok, I have some progress here

[20:34] <DrForr> seen awwaiid 

[20:34] <DrForr> .seen awwaiid 

[20:34] <yoleaux> I saw awwaiid 31 May 2016 13:40Z in #perl6: <awwaiid> Increasingly Jupyter is wrapping more langs

[20:34] <AlexDaniel> gnull: if I'm not mistaken, last time I had this problem, even adding some comments to the code made the segfault disappear…

[20:34] <literal> m: my %h1 = bar => 3; my %h2 = bla => 4; for %h1.pairs.sort Z %h2.pairs.sort -> ($pair1, $pair2) { say "$pair1 and $pair2" }

[20:34] <camelia> rakudo-moar 85682a: OUTPUT«Too few positionals passed; expected 2 arguments but got 0 in sub-signature␤  in block <unit> at /tmp/LQCDZdxsJM line 1␤␤»

[20:34] <literal> what's the right way to do this?

[20:35] <DrForr> .tell awwaiid It seems that lrepl only lets you invoke one middleware layer at a time, is this by design?

[20:35] <yoleaux> DrForr: I'll pass your message to awwaiid.

[20:35] <btyler> jnthn: ah, ok. thanks, that's clear! I'll make sure to emphasize that any properties associated with preemptive scheduling won't apply entirely to perl6 (with the slight wiggle room about thread pool size)

[20:35] * btyler goes back to talk writing

[20:36] <jnthn> m: my %h1 = bar => 3; my %h2 = bla => 4; for flat %h1.pairs.sort Z %h2.pairs.sort -> $pair1, $pair2 { say "$pair1 and $pair2" }

[20:36] <camelia> rakudo-moar 85682a: OUTPUT«bar  3 and bla       4␤»

[20:36] *** jaffa4 left
[20:38] <AlexDaniel> “Internal error: Unwound entire stack and missed handler” :)

[20:39] <literal> jnthn: I see

[20:40] *** btyler left
[20:40] <jdv79> nine: i can't get through the testing phase of installation.  i can pm you acct details where its happening i you wish.

[20:41] *** TEttinger joined
[20:41] <jdv79> *if

[20:41] <AlexDaniel> gnull: do I get it right that you have to run it multiple times to see a segfault?

[20:42] <AlexDaniel> gnull: or are you getting a segfault every single time?

[20:46] <gnull> AlexDaniel: I've run it 10 times. Got 1 successfull run, 6 segfaults, 2 times 'Cannot invoke this object (REPR: Uninstantiable)' at line 21

[20:46] <gnull> And one got this:

[20:46] <gnull> Can only resume an exception object

[20:46] <gnull>   in any  at /home/gnull/prefix/share/perl6/runtime/CORE.setting.moarvm line 1

[20:46] <gnull>   in sub THROW at /home/gnull/prefix/share/perl6/runtime/CORE.setting.moarvm line 1

[20:46] <gnull>   in block  at ./farm.p6 line 21

[20:46] <gnull> Sorry for long paste

[20:47] <gnull> AlexDaniel: The line 21 is 'say "$exploit $target";'

[20:49] *** kaare_ left
[20:50] *** _nadim left
[20:51] <AlexDaniel> good

[20:57] <BenGoldberg> hoelzro_, I'd like to suggest a possible improvement for multiline repl you figured out: Instead of merely catching X::Syntax::Missing, reading another line from the user, and re-EVAl-ing the lengthened string, what if you use .resume to continue parsing?

[21:04] <jdv79> nine: I imagine this is relevant:  https://gist.github.com/anonymous/028fb20bc9dd66fce13a3ffa281809c2

[21:05] *** rindolf left
[21:05] <ugexe> if you let it run long enough a few other ones pop in for a single line once in a while

[21:06] <AlexDaniel> gnull: ok, try this: https://gist.github.com/AlexDaniel/35252aa967456a31c28aafaf1c612320

[21:06] <AlexDaniel> gnull: e.g. run it in a loop to see all errors: while :; do ./segfault.p6; done

[21:08] <AlexDaniel> gnull: does it produce same errors?

[21:10] <gnull> First time it gave: This Seq has already been iterated, and its values consumed (you might solve this by adding .cache on usages of the Seq, or by assigning the Seq into an array)  in block  at a.pl line 20

[21:11] <gnull> AlexDaniel: Then: Can only resume an exception object  in any  at /home/gnull/prefix/share/perl6/runtime/CORE.setting.moarvm line 1  in sub THROW at /home/gnull/prefix/share/perl6/runtime/CORE.setting.moarvm line 1  in block  at a.pl line 20

[21:11] <gnull> AlexDaniel: One Segfault

[21:12] <gnull> AlexDaniel: Once `*** Error in `/home/gnull/prefix/bin/moar': double free or corruption ` with backtrace

[21:13] <AlexDaniel> awesome.

[21:13] <AlexDaniel> yeah, something goes horribly wrong in this one :)

[21:13] <AlexDaniel> gnull: ok, so please submit rakudobug

[21:14] <AlexDaniel> gnull: either with your archive or with this shortened version, whatever you see fit

[21:14] <gnull> AlexDaniel: backtrace is at https://gist.github.com/gnull/e4570fce92bc692557aa39d15b1a15d2

[21:14] <AlexDaniel> gnull: even more awesome!

[21:15] <gnull> AlexDaniel: Ok, thanks for help.

[21:16] <AlexDaniel> gnull: unless you have an account on rt just write an email to [email@hidden.address]
[21:16] <AlexDaniel> gnull: and it will appear on rt.perl.org

[21:23] *** girafe joined
[21:31] *** _mg__ joined
[21:34] *** _mg_ left
[21:34] *** _mg__ is now known as _mg_

[21:37] *** |2701 joined
[21:39] <gnull> AlexDaniel: done https://rt.perl.org/Ticket/Display.html?id=128325

[21:42] *** gorgonzola joined
[21:44] <AlexDaniel> .tell jnthn Here is the ticket: https://rt.perl.org/Ticket/Display.html?id=128325 (gnull++)

[21:44] <yoleaux> AlexDaniel: I'll pass your message to jnthn.

[21:45] <AlexDaniel> gnull: thank you very much! I'm hoping that this issue is actually broader than it seems, otherwise we'd have to figure out the problem with other similar segfaults :)

[21:46] <AlexDaniel> eh, RT has some problems with UTF-8… RT--

[21:48] <gnull> AlexDaniel: my emacs too :) so I just `wget`ed it and ran

[21:48] <AlexDaniel> heh

[21:49] <AlexDaniel> gnull: well, I'm pretty sure that your emacs handles it just fine. Perhaps it is unable to render some characters (which is about fonts that you have installed), but there should be no encoding problems

[21:50] <literal> is there a way to pass postcircumfix:«[ ]» to the 'handles' trait?

[21:51] <literal> I'm trying to add indexing to a type, and I wondered whether "does Positional" and an appropriate 'handles' directive for an array variable would do...

[21:52] <gnull> AlexDaniel: you are right, emacs works fine. It was github's viewer)

[21:54] <gnull> AlexDaniel: How do you type those characters?

[21:55] <gfldex> we do not doc trait handles

[21:55] <gfldex> literal: IIRC handles requires a method. Operators tend not to be methods.

[21:55] <gnull> AlexDaniel: Are there '｢' on your keyboard or you remeber utf-8 codes for them?

[21:55] *** _4d47 left
[21:55] <AlexDaniel> gnull: ‘’ “” «» ｢｣ – … ? I have them on my customized keyboard layout, so I just press a button…

[21:56] <AlexDaniel> gnull: but I also use compose key for stuff that I do not use every day

[21:57] <AlexDaniel> gnull: see this: http://doc.perl6.org/language/unicode_entry

[21:57] <AlexDaniel> gnull: ↑ it has a lot of useful info

[21:57] <gfldex> literal: postcircumfix operators tend to delegate work to AT-KEY and other such methods. So you may still be able to do what you want.

[21:57] <AlexDaniel> doesn't tell you how to create your own custom layout, but still it's good enough :)

[21:58] <gnull> AlexDaniel: It's fun, thanks for the link

[21:58] <literal> gfldex: I see

[22:03] *** setty1 left
[22:07] <literal> gfldex: ok, so it works if I do "handles <AT-POS>", but I wonder why it doesn't work with "handles *", does it exclude uppercase methods or something?

[22:10] *** TEttinger left
[22:10] <gfldex> literal: did you try `handles **`?

[22:11] <literal> same result as *

[22:12] <literal> is that new? I was testing this on Rakudo 2016.04

[22:14] <gfldex> literal: no

[22:16] *** _nadim joined
[22:16] <psch> literal: what do you want 'handles *' to do?

[22:16] *** wamba left
[22:18] <literal> to delegate to AT-POS et al

[22:19] <gfldex> literal: i can't see any special cases for captial spelled methods in https://github.com/rakudo/rakudo/blob/8cbb1efd1d84fd57298e0e0813b64d8dd37140ba/src/core/traits.pm#L348

[22:20] <gfldex> but i can see that you will have to expect slowness

[22:20] <psch> literal: i assume that's dependent on the sigil of the Attribute?  as in, 'has @.foo handles *' means 'handle all Positional methods', whereas 'has %.foo handles *' means 'handle all Associative methods'?

[22:20] <psch> literal: what would that mean for & or $ sigil then?

[22:22] *** girafe left
[22:22] <literal> m: class Foo { has @.ary handles <AT-POS>; }; my $f = Foo.new(ary => [1, 2]); say $f[1]

[22:22] <camelia> rakudo-moar 85682a: OUTPUT«2␤»

[22:22] <literal> m: class Foo { has @.ary handles *; }; my $f = Foo.new(ary => [1, 2]); say $f[1]

[22:22] <camelia> rakudo-moar 85682a: OUTPUT«Index out of range. Is: 1, should be in 0..0␤  in block <unit> at /tmp/abMhhz1X32 line 1␤␤Actually thrown at:␤  in block <unit> at /tmp/abMhhz1X32 line 1␤␤»

[22:24] <literal> psch: in this case the attribute has a @ sigil, and even if I change it to the $ sigil, "handles <AT-POS>" still works while "handles *" doesn't

[22:24] <psch> literal: yes, i know.  but what would you want it to do?

[22:25] <psch> literal: should it *always* delegate as Positional, or did i guess right?

[22:25] <psch> (both approaches are troublesome and too magic, fwiw)

[22:25] <literal> I don't know, and it doesn't really matter to me. I just want "handles *" to make all methods (like AT-POS) be delegated

[22:26] <psch> yeah, i'm pretty that's not going to happen in CORE

[22:26] <psch> m: multi trait_mod:<handles>(Attribute \A, Whatever \w) { ... } 

[22:26] <camelia> rakudo-moar 85682a: ( no output )

[22:26] <literal> then what does '*' mean, if not "everything" ?

[22:26] <psch> that's your blueprint for implementing it yourself

[22:27] <psch> just replace the stub with whatever way you want to decide which methods it should delegate

[22:27] <psch> literal: * doesn't mean "everything".  in most cases it means "i'll tell you later"

[22:27] <psch> it's only array subscripting where it means "all elements you know"

[22:28] <psch> but that's also not "everything"

[22:28] <psch> although it's probably closest

[22:28] <psch> well, and hash subscripting i guess

[22:29] <psch> http://doc.perl6.org/type/Whatever for reference

[22:30] *** kent\n joined
[22:30] *** kent\n left
[22:30] *** kent\n joined
[22:32] <literal> alright then

[22:33] <literal> different question. Why are expressions like this not allowed?

[22:33] <literal> m: class Foo { has $.bar; method CALL-ME ($b) { self.new(bar => $b) } }; say Foo(Int(3434))

[22:33] <camelia> rakudo-moar 85682a: OUTPUT«5===SORRY!5=== Error while compiling /tmp/YCM13i2rf6␤Unable to parse expression in typename; couldn't find final ')' ␤at /tmp/YCM13i2rf6:1␤------> 3 { self.new(bar => $b) } }; say Foo(Int(7⏏053434))␤»

[22:34] <psch> m: class Foo { has $.bar; method CALL-ME ($b) { self.new(bar => $b) } }; say Foo(3434)

[22:34] <camelia> rakudo-moar 85682a: OUTPUT«Foo.new(bar => 3434)␤»

[22:35] <literal> I can make do with Foo(3434.Int), but if I have a custom type instead of Int, that won't work out of the box 

[22:35] <psch> if you have a custom type you can give it a CALL-ME as well, can't you?

[22:35] <psch> not that i'd advocate for doing that, cause it feels somewhat messy to me... vOv

[22:35] <literal> yes, and Foo(Bar($whatever)) won't work

[22:36] <literal> due to Perl being unable to parse the expression

[22:37] <psch> ah, right

[22:37] <psch> hm, i'd have to build moar and check what exactly it parses there

[22:37] <literal> in my case I'm trying to do something like $type = MyList(MyNum(123), MyString("foo"))

[22:38] <psch> m: class A { method CALL-ME(Mu \a) { a } }; class B { method CALL-ME(Mu \b) { b } }; A($ = B(5))

[22:38] <camelia> rakudo-moar 85682a: ( no output )

[22:38] <psch> just add throwaway containers vOv

[22:39] <psch> m: class A { method CALL-ME(Mu \a) { a } }; class B { method CALL-ME(Mu \b) { b } }; A($(B(5))) 

[22:39] <camelia> rakudo-moar 85682a: ( no output )

[22:39] <psch> ...or Scalar context i suppose

[22:39] <literal> quite ugly :)

[22:39] <psch> yeah, that's what i think about TypeName(arguments)

[22:39] <psch> still, you might want to RT it

[22:40] <psch> i don't see a good reason off-hand why it shouldn't parse, and if it's ticketed it'll either be decided as "should parse" or someone will write down a good reason why it shouldn't parse :)

[22:40] <literal> alright

[22:41] * psch gets some sleep o/

[22:44] *** bjz_ left
[22:45] *** colomon joined
[22:54] *** huggable joined
[23:02] *** kurahaupo left
[23:07] *** bjz joined
[23:07] *** kurahaupo joined
[23:08] *** bjz left
[23:09] *** bjz joined
[23:10] <kalkin-_> how can i speed up the rakudo rebuild?

[23:10] <kalkin-_> i.e if i change somewhere a line and execute make it takes minutes till it's done on my xeon

[23:13] *** Zero_Dogg left
[23:13] *** Zero_Dogg joined
[23:14] <skids> kalkin-_: you are compiling rakudo?  That ued to take tens of minutes :-)

[23:14] <skids> *used

[23:15] <kalkin-_> i must correct myself not minutes around 90seconds, but still :D

[23:15] *** spider-mario left
[23:17] *** bjz left
[23:19] <AlexDaniel> BenGoldberg: honestly, it took me a while to figure out why your .pick(*).map snippet went “wrong”…

[23:20] <AlexDaniel> BenGoldberg: … but yea, trying to use a code snippet that fails *sometimes* is probably not a good idea for git bisect :D

[23:21] *** |2701 left
[23:22] *** sortiz joined
[23:22] <kalkin-_> how can i list all the set variables in the repl?

[23:22] <BenGoldberg> :)

[23:24] *** labster left
[23:30] <AlexDaniel> BenGoldberg: it's also a bit sad that you'd have to bisect nqp yourself, but that's probably ok

[23:30] *** araujo_ joined
[23:31] <AlexDaniel> after all, it is already narrowed down for you :)

[23:32] <skids> kalkin-_: there's nothing special about variables set in the REPL they are just variables

[23:32] <skids> m: my $a = 42; my $b = 43; ::.keys.say # says the names of all variables in the current global scope.

[23:32] <camelia> rakudo-moar 85682a: OUTPUT«($=pod !UNIT_MARKER EXPORT $_ $! $b ::?PACKAGE GLOBALish $¢ $=finish $a $/ $?PACKAGE)␤»

[23:33] <skids> m: my $a = 42; my $b = 43; ::.pairs.say # same, with values

[23:33] <camelia> rakudo-moar 85682a: OUTPUT«($=pod => [] !UNIT_MARKER => (!UNIT_MARKER) EXPORT => (EXPORT) $_ => (Any) $! => Nil $b => 43 ::?PACKAGE => (GLOBAL) GLOBALish => (GLOBAL) $¢ => Nil $=finish => (Mu) $a => 42 $/ => Nil $?PACKAGE => (GLOBAL))␤»

[23:34] *** araujo__ left
[23:37] <kalkin-_> skids: awesome thanks!

[23:40] *** sortiz left
[23:59] <kalkin-_> how can i push a variable to the global scope? Am I blind or does perl6 not have any user defined global variables?

