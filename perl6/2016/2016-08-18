[00:00] <ItayAlmog> m: class T { my $test = 1; method print() { say $test; }; method inc() { $test++ }; }; T.print; T.inc; T.print; T.new.print;

[00:00] <camelia> rakudo-moar e97fb7: OUTPUT«1␤2␤2␤»

[00:00] <unmatched}> dj_goku: it's very likely something in this commit: https://github.com/rakudo/rakudo/commit/be7ce041a800a9b3f4b532b84583ce0c8b42eec0

[00:00] <phifisher> I was see a video about, gabor szabo talking about.. :P

[00:00] <unmatched}> dj_goku: maybe you can fix it :) You get the prize for unblocking the upcoming release :)

[00:00] <unmatched}> phifisher: ahh

[00:02] <dj_goku> unmatched}: well I have to go workout plus I want to try and figure something else out. :D

[00:02] <ItayAlmog> I feel like I am missing something... So when I have a variable inside a class you can changed it when it is not an instance and it will keep this variable's value even when you create a new instance of it ?

[00:02] <phifisher> unmatched}, Even so, thank you!

[00:02] <phifisher> :D

[00:02] <unmatched}> ItayAlmog: yeah, that's a class variable. For attributes you use   has $.test

[00:02] <unmatched}> For class attributes, you use my $.test

[00:03] * unmatched} &

[00:03] <unmatched}> done for the day

[00:03] *** n1lp7r left
[00:04] <ItayAlmog> oh! Well, I think I will have to read alot more about Perl6 before making this compiler :\

[00:06] *** MilkmanDan joined
[00:09] *** mvorg left
[00:12] <vcv> there should be some perl 6 for beginners talks on youtube from yapc::na...

[00:12] <vcv> https://www.youtube.com/watch?v=ySch4xpoPA0 and https://www.youtube.com/watch?v=ycLU424NPUw

[00:15] *** kyclark joined
[00:22] <adu> hey, this is probably really simple, but what's the syntax for negative lookahead assertions in perl6?

[00:23] <unmatched}> adu: <!before ... >   https://docs.perl6.org/language/regexes#Look-around_assertions

[00:25] <adu> unmatched}: thanks

[00:26] <Juerd> adu: Can you guess the positive lookahead, and both negative and positive lookbehind from this single example? :)

[00:26] *** mniip joined
[00:26] * Juerd ♥ p6 regex

[00:28] <b2gills> ItayAlmog: I would say making a native compiler for full Perl 6 is just this side of impossible. If you want to make a native compiler, you could try NQP, it should be **much** easier.

[00:30] <ItayAlmog> Yeah, probably :\ Are there any references about NQP (like lexical structure and typing and such)?

[00:33] <ItayAlmog> But on the other hand, I do want a challenge since I don't have anything to do other than that right now...

[00:33] *** kyclark left
[00:34] <adu> Juerd: <before ..> <!after ..> <after ..>, respectively?

[00:35] <adu> I always get them confused though, because ahead=after, and behind=before in my mind

[00:35] <adu> but in reality lookahead=before and lookbehind=after

[00:35] <adu> I should probably just add look=not to my mental dictionary and be done with it

[00:37] *** BenGoldberg joined
[00:40] <ItayAlmog> class P { say "test" }

[00:40] <ItayAlmog> m: class P { say "test" }

[00:40] <camelia> rakudo-moar e97fb7: OUTPUT«test␤»

[00:42] *** pierre_ joined
[00:49] <vcv> m: use experimental :macros; macro foo($bar) { quasi { say "{ {{{$bar}}} }"; } } foo 1;

[00:49] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3bar) { quasi { say "{ {{{$bar}}} }"; } }7⏏5 foo 1;␤    expecting any of:␤        infix␤        infix stopper␤     …»

[00:49] <vcv> oops

[00:49] <vcv> m: use experimental :macros; macro foo($bar) { quasi { say "{ {{{$bar}}} }"; } }; foo 1;

[00:49] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unknown QAST node type QAST::Unquote␤at <tmp>:1␤»

[00:49] *** rkazak left
[00:50] *** dha left
[00:53] <vcv> Bug or LTA error?

[00:56] <MasterDuke> is anyone else seeing *really* long precomp times with a rakudo built today? compared to a rakudo built yesterday for example

[01:00] *** dataangel left
[01:00] *** adu left
[01:01] *** dataangel joined
[01:04] *** pduh joined
[01:04] *** phifisher left
[01:05] *** canopus left
[01:09] *** rkazak joined
[01:09] *** cyphase left
[01:12] *** canopus joined
[01:14] *** cyphase joined
[01:18] <unmatched}> ItayAlmog: try the nqp docs https://github.com/perl6/nqp/tree/master/docs and the internals course I showed today teaches NQP

[01:18] *** zacts joined
[01:19] <ItayAlmog> ok thanks :)

[01:19] <dataangel> I don't understand this bit from learn X in Y minutes: 'he he' ~~ / <[ h e ' ' ]> /; # Warns "Repeated characters found in characters class"

[01:20] <unmatched}> adu: you're not meant to make some sort of mnemonics. Just read it like English: <after 'a'> 'b' <before 'c'>

[01:20] <dataangel> What character is repeated? The space somehow?

[01:20] <unmatched}> dataangel: the quote

[01:20] <unmatched}> m: 'he he' ~~ / <[ h e ' ' ]> /;

[01:20] <camelia> rakudo-moar e97fb7: OUTPUT«Potential difficulties:␤    Quotes are not metacharacters in character classes␤    at <tmp>:1␤    ------> 3'he he' ~~ / <7⏏5[ h e ' ' ]> /;␤    Repeated character (') unexpectedly found in character class␤    at <tmp>:1␤    ------> 3'he …»

[01:20] <dataangel> oooooh thanks

[01:27] *** canopus left
[01:28] <vcv> This just blew my mind.  I love learning little things every day with Perl 6

[01:28] <vcv> m: my $name = "Matt"; my $age = 33; my %info = :$name, :$age; say %info;

[01:28] <camelia> rakudo-moar e97fb7: OUTPUT«{age => 33, name => Matt}␤»

[01:28] *** kalkin- left
[01:28] *** kalkin-_ joined
[01:30] <unmatched}> :)

[01:31] *** rkazak left
[01:31] <unmatched}> Try this for size:

[01:31] <unmatched}> m: sub foo { "Matt", 33 }; my (:$name, :$age) = foo; dd [ $name, $age ]

[01:31] <camelia> rakudo-moar e97fb7: OUTPUT«["Matt", 33]␤»

[01:32] <unmatched}> oh wait, that's not the mind blowing one

[01:32] *** canopus joined
[01:33] <dataangel> vcv: what is mind blowing about that one? Asking as a newbie

[01:33] <unmatched}> m: sub foo { my %hash = :something<or other>, :name<Matt>, :33age; return %hash }; my (:$name, :$age) = foo;  dd [ $name, $age ]

[01:33] <camelia> rakudo-moar e97fb7: OUTPUT«[:name("Matt"), :something($("or", "other"))]␤»

[01:33] <unmatched}> Eh, well, there's some way to get the hash keys into variables using something like this syntax, but I forget what it is :)

[01:34] <vcv> short-hand for creating a hash, works as expected and consistent with how named parameters are constructed

[01:34] <unmatched}> vcv: same works with signatures and isn't limited to scalars either

[01:35] <vcv> I just love how consistent it all is :)

[01:35] <unmatched}> m: class Foo { $.bar; method do-stuff (:$!bar) {}; }.new.do-stuff(:42bar).bar.say

[01:35] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable $.bar used where no 'self' is available␤at <tmp>:1␤------> 3class Foo { $.bar7⏏5; method do-stuff (:$!bar) {}; }.new.do-␤    expecting any of:␤        term␤»

[01:35] <unmatched}> m: class Foo { has $.bar; method do-stuff (:$!bar) {}; }.new.do-stuff(:42bar).bar.say

[01:35] <camelia> rakudo-moar e97fb7: OUTPUT«Nil␤»

[01:35] <unmatched}> :(

[01:36] <BenGoldberg> m: sub foo { :name<Ben>, :age<MYOB>, :commute("two wheeled") }; my $:age = foo; dd $foo;

[01:36] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Cannot use placeholder parameter $:age in the mainline␤at <tmp>:1␤------> 3OB>, :commute("two wheeled") }; my $:age7⏏5 = foo; dd $foo;␤»

[01:37] <BenGoldberg> m: sub foo { :name<Ben>, :age<MYOB>, :commute("two wheeled") }; my ($:age) = foo; dd $foo;

[01:37] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5===␤In signature parameter, placeholder variables like $:age are illegal␤you probably meant a named parameter: ':$age'␤at <tmp>:1␤------> 3B>, :commute("two wheeled") }; my ($:age7⏏5) = foo; dd $foo;␤Variable '$foo' is not de…»

[01:37] <BenGoldberg> m: sub foo { :name<Ben>, :age<MYOB>, :commute("two wheeled") }; my (:$age) = foo; dd $foo;

[01:37] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '$foo' is not declared. Did you mean '&foo'?␤at <tmp>:1␤------> 3("two wheeled") }; my (:$age) = foo; dd 7⏏5$foo;␤»

[01:37] *** prammer joined
[01:37] <BenGoldberg> m: sub foo { :name<Ben>, :age<MYOB>, :commute("two wheeled") }; my (:$age) = foo; dd $age;

[01:37] <camelia> rakudo-moar e97fb7: OUTPUT«Pair $age = :name("Ben")␤»

[01:37] <vcv> so close

[01:38] <BenGoldberg> m: sub foo { {:name<Ben>, :age<MYOB>, :commute("two wheeled")} }; my (:$age) = foo; dd $age;

[01:38] <camelia> rakudo-moar e97fb7: OUTPUT«Pair $age = :name("Ben")␤»

[01:38] <BenGoldberg> m: sub foo { Hash.new(:name<Ben>, :age<MYOB>, :commute("two wheeled")) }; my (:$age) = foo; dd $age;

[01:38] <camelia> rakudo-moar e97fb7: OUTPUT«Any $age = Any␤»

[01:38] <BenGoldberg> m: sub foo { Hash.new(:name<Ben>, :age<MYOB>, :commute("two wheeled")) }; my (:$age) := foo; dd $age;

[01:38] <camelia> rakudo-moar e97fb7: OUTPUT«Mu␤»

[01:39] * BenGoldberg shrugs

[01:39] <unmatched}> m: sub foo { my %hash = :something<or other>, :name<Matt>, :33age; return %hash }; my (:$name, :$age) := foo;  dd [ $name, $age ]

[01:39] <camelia> rakudo-moar e97fb7: OUTPUT«Unexpected named argument 'something' passed␤  in block <unit> at <tmp> line 1␤␤»

[01:39] <unmatched}> m: my %h = status => 'foo', content => 'bar'; my (:$status, :$content) := %h; say $status; say $content;

[01:39] <camelia> rakudo-moar e97fb7: OUTPUT«foo␤bar␤»

[01:40] <unmatched}> m: my %h = :42bar, tatus => 'foo', content => 'bar'; my (:$status, :$content) := %h; say $status; say $content;

[01:40] <camelia> rakudo-moar e97fb7: OUTPUT«2 unexpected named arguments passed (bar,tatus)␤  in block <unit> at <tmp> line 1␤␤»

[01:40] <unmatched}> I guess you have to use up all the keys

[01:41] *** prammer left
[01:42] *** sufrostico left
[01:43] <vcv> m: macro foo($bar) { quasi { say "{ macro bar($baz) { quasi { {{{$bar}}}; {{{$baz}}} } } }" } }; foo 1;

[01:43] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Use of macros is experimental; please 'use experimental :macros'␤at <tmp>:1␤------> 3macro7⏏5 foo($bar) { quasi { say "{ macro bar($b␤»

[01:44] <vcv> m: use experimental :macros; macro foo($bar) { quasi { say "{ macro bar($baz) { quasi { {{{$bar}}}; {{{$baz}}} } } }" } }; foo 1;

[01:44] <camelia> rakudo-moar e97fb7: OUTPUT«Use of Nil in string context  in any  at <tmp> line 1␤␤»

[01:46] *** canopus left
[01:53] *** canopus joined
[02:02] <vcv> m: macro trip($term) { quasi { 3 * {{{$term}}} } }; say trip 1 + 1;

[02:02] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Use of macros is experimental; please 'use experimental :macros'␤at <tmp>:1␤------> 3macro7⏏5 trip($term) { quasi { 3 * {{{$term}}} }␤»

[02:03] <vcv> m: use experimental :macros; macro trip($term) { quasi { 3 * {{{$term}}} } }; say trip 1 + 1;

[02:03] <camelia> rakudo-moar e97fb7: OUTPUT«6␤»

[02:06] <BenGoldberg> m: use experimental :macros; macro thrice($term) { quasi { {{{$term}}} xx 3 } }; trip say 42;

[02:06] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    trip used at line 1. Did you mean 'trim'?␤␤»

[02:06] <BenGoldberg> m: use experimental :macros; macro thrice($term) { quasi { {{{$term}}} xx 3 } }; thrice say 42;

[02:06] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unknown QAST node type QAST::Unquote␤at <tmp>:1␤»

[02:08] <BenGoldberg> m: use experimental :macros; macro thrice($term) { quasi { ({{{$term}}}) xx 3 } }; thrice say 42;

[02:08] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unknown QAST node type QAST::Unquote␤at <tmp>:1␤»

[02:08] <BenGoldberg> m: use experimental :macros; macro thrice($term) { quasi { do { {{{$term}}} } xx 3 } }; thrice say 42;

[02:08] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unknown QAST node type QAST::Unquote␤at <tmp>:1␤»

[02:08] <BenGoldberg> m: use experimental :macros; macro thrice($term) { quasi { do { {{{$term}}} } xx 3 } }; thrice 42;

[02:08] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unknown QAST node type QAST::Unquote␤at <tmp>:1␤»

[02:09] <dataangel> When should I use a class and when should I use a role? 

[02:09] *** bob777 joined
[02:12] *** MilkmanDan left
[02:12] <BenGoldberg> It's a bit hard to say, especially since perl6 can automatically pun roles into classes.

[02:14] *** bisectable left
[02:14] *** committable left
[02:14] <dataangel> Here's my simple situation porting a python3 program: I have a class called Recipe with a cook method that just throws NotImplementedError, with the intent that you derive from it and fill in that one method. In Perl 6 should that be a class or a role?

[02:14] *** benchable left
[02:15] *** noganex_ joined
[02:15] <skids> probably a role.

[02:15] <dataangel> skids: how do you figure?

[02:16] <skids> m: role A { method f { ... } }; A.new;

[02:16] <camelia> rakudo-moar e97fb7: OUTPUT«Method 'f' must be implemented by A because it is required by a role␤  in any compose_method_table at gen/moar/m-Metamodel.nqp line 2850␤  in any apply at gen/moar/m-Metamodel.nqp line 2860␤  in any compose at gen/moar/m-Metamodel.nqp line 3033␤  i…»

[02:16] <skids> m: role A { method f { ... } }; class B does A { method f { 42 } }; B.new;

[02:16] <camelia> rakudo-moar e97fb7: ( no output )

[02:16] <dataangel> m: class A { method f { ... } }; A.new;

[02:16] <camelia> rakudo-moar e97fb7: ( no output )

[02:17] <skids> m: role A { method f { ... } }; A.new.f();

[02:17] <camelia> rakudo-moar e97fb7: OUTPUT«Method 'f' must be implemented by A because it is required by a role␤  in any compose_method_table at gen/moar/m-Metamodel.nqp line 2850␤  in any apply at gen/moar/m-Metamodel.nqp line 2860␤  in any compose at gen/moar/m-Metamodel.nqp line 3033␤  i…»

[02:17] <skids> m: class A { method f { ... } }; A.new.f();

[02:17] <camelia> rakudo-moar e97fb7: OUTPUT«Stub code executed␤  in method f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[02:17] <skids> so you could do it either way but roles are supposed to be used that way.

[02:17] *** noganex left
[02:18] <skids> (and will do it at compile time)

[02:18] <skids> m: role A { method f { ... } }; A;

[02:18] <camelia> rakudo-moar e97fb7: OUTPUT«WARNINGS for <tmp>:␤Useless use of constant value A in sink context (line 1)␤»

[02:18] <dataangel> How does it know that ... Is not the sequence operator?

[02:18] <skids> m: role A { method f { ... } }; my$f = A;

[02:18] <camelia> rakudo-moar e97fb7: ( no output )

[02:18] <skids> hmm.

[02:18] <skids> { ... } is special cased

[02:19] *** benchable joined
[02:19] <skids> m: role A { method f { ... } }; say A.perl;

[02:19] <camelia> rakudo-moar e97fb7: OUTPUT«A␤»

[02:19] *** committable joined
[02:19] <skids> I guess that does not pun until a new.

[02:19] <skids> m: role A { method f { ... } }; class B does A { };

[02:19] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Method 'f' must be implemented by B because it is required by a role␤at <tmp>:1␤»

[02:19] *** bisectable joined
[02:23] <TimToady> more than that, ... is only a sequence operator where an infix is expected, not where a term is expected

[02:24] <TimToady> just as / is division or regex

[02:24] <TimToady> or % is mod or hash

[02:28] <TEttinger> this reminds me of that "proof" by the halting problem that "showed" that Perl cannot be parsed (Perl 5)

[02:32] <timotimo> sup :)

[02:35] *** ItayAlmog left
[02:35] <TEttinger> hm

[02:35] *** wamba joined
[02:36] <TEttinger> so if perl 5 can't be statically analyzed without ever executing any snippet of perl 5, can perl 6 be statically analyzed without ever executing perl 6?

[02:37] <dataangel> p6: my $result = "hello.o: hello.c" ~~ / .+\: ( \w* ( .+ ) \w* )+ /; say $/[0][0];

[02:37] <camelia> rakudo-moar e97fb7: OUTPUT«｢ hello.c｣␤ 0 => ｢ hello.c｣␤»

[02:37] <konobi> depends how you look at it

[02:37] <dataangel> Why is the space still there?

[02:38] *** prammer joined
[02:38] <TEttinger> m: my $result = "hello.o: hello.c" ~~ / .+\: ( \w* ( .+ ) \w* )+ /; say $/[0][0];

[02:38] <camelia> rakudo-moar e97fb7: OUTPUT«｢ hello.c｣␤ 0 => ｢ hello.c｣␤»

[02:38] <unmatched}> dataangel: you've asked for it

[02:38] <timotimo> TEttinger: all you can do is try something like symbolic or abstract execution instead of actual execution

[02:38] <dataangel> I'm not trying to :p

[02:39] <unmatched}> dataangel: after the ':' you ask for any amount of word characters, then start the capture and take "any" character, which includes the space

[02:39] <TEttinger> m: my $result = "hello.o: hello.c" ~~ / .+\: ( \w*+ ( .+ ) \w*+ )+ /; say $/[0][0];

[02:39] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5===␤Quantifier quantifies nothing␤at <tmp>:1␤------> 3lt = "hello.o: hello.c" ~~ / .+\: ( \w*+7⏏5 ( .+ ) \w*+ )+ /; say $/[0][0];␤Quantifier quantifies nothing␤at <tmp>:1␤------> 3o: hello.c" ~~ / .+\: ( \w*+ ( .+ ) \w*+7…»

[02:39] <timotimo> because traits are compile-time-run code, code in the mainline of imported modules and in their EXPORT subroutine, ...

[02:39] <dataangel> The reason I created an inner capture group was specifically to avoid it

[02:39] <unmatched}> dataangel: did you mean \s* in there instead of \w*?

[02:39] <dataangel> oops yes

[02:39] <unmatched}> p6: my $result = "hello.o: hello.c" ~~ / .+\: ( \s* $<stuff>=( .+ ) \w* )+ /; say $<stuff>

[02:39] <camelia> rakudo-moar e97fb7: OUTPUT«Nil␤»

[02:39] <unmatched}> p6: my $result = "hello.o: hello.c" ~~ / .+\: ( \s* $<stuff>=.+ \w* )+ /; say $<stuff>

[02:39] <camelia> rakudo-moar e97fb7: OUTPUT«Nil␤»

[02:39] <unmatched}> :S

[02:39] <TEttinger> m: my $result = "hello.o: hello.c" ~~ / .+\: ( \w+ ( .+ ) \w* )+ /; say $/[0][0];

[02:39] <camelia> rakudo-moar e97fb7: OUTPUT«Nil␤»

[02:39] * unmatched} is too tired

[02:39] <timotimo> \w*+ doesn't make sense to me

[02:40] <TEttinger> possessive capture, wasn't sure if it was valud

[02:40] <TEttinger> m: my $result = "hello.o: hello.c" ~~ / .+\:\s+ ( \w+ ( .+ ) \w* )+ /; say $/[0][0];

[02:40] <camelia> rakudo-moar e97fb7: OUTPUT«｢hello.c｣␤ 0 => ｢.c｣␤»

[02:40] <timotimo> possessive makes no sense to me either :)

[02:40] <unmatched}> m: "hello.o: hello.c".words[1].say

[02:40] <camelia> rakudo-moar e97fb7: OUTPUT«hello.c␤»

[02:40] <TEttinger> nice

[02:41] *** kyclark joined
[02:41] <TEttinger> timotimo: pretty sure it was either Perl 5 or PCRE that had it first in any language/lib

[02:41] <TEttinger> http://www.regular-expressions.info/possessive.html

[02:41] <unmatched}> p6: "hello.o: hello.c" ~~ / .+ ':' \s* $<stuff>=.+ /; say $<stuff>

[02:41] <camelia> rakudo-moar e97fb7: OUTPUT«｢hello.c｣␤»

[02:42] *** prammer left
[02:42] <TEttinger> p6: "hello.o: hello.c Darude - Sandstorm" ~~ / .+ ':' \s* $<stuff>=.+ /; say $<stuff>

[02:42] <camelia> rakudo-moar e97fb7: OUTPUT«｢hello.c Darude - Sandstorm｣␤»

[02:42] <timotimo> i hadn't heard about it yet

[02:43] <TEttinger> unmatched}: you wanted that extension, right?

[02:44] <dataangel> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+ ) \s* )+ /; say $/[0][0];

[02:44] <dataangel>  

[02:44] <camelia> rakudo-moar e97fb7: OUTPUT«｢ hello.c foobar.c｣␤ 0 => ｢hello.c foobar.c｣␤»

[02:44] <unmatched}> TEttinger: it's dataangel's code. I don't know what their specs are

[02:44] <TEttinger> true

[02:44] <TEttinger> dataangel: do you want all filenames after the colon and whitespace, or an individual filename?

[02:45] <dataangel> How do I get it so that the latter two files are in an array? That's what I thought putting the + on the outside of the capture was going to give me

[02:45] <dataangel> Since I thought captures could give you arrays

[02:45] <TEttinger> I think unmatched} had something very close to it

[02:46] <unmatched}> dataangel: what happens for filenames with spaces in them?

[02:46] <TEttinger> m: "hello.o: hello.c".words[1-].say

[02:46] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Missing required term after infix␤at <tmp>:1␤------> 3"hello.o: hello.c".words[1-7⏏5].say␤    expecting any of:␤        prefix␤        term␤»

[02:46] <TEttinger> m: "hello.o: hello.c".words[1,].say

[02:46] <camelia> rakudo-moar e97fb7: OUTPUT«(hello.c)␤»

[02:46] <TEttinger> m: "hello.o: hello.c foobar.c".words[1,].say

[02:46] <camelia> rakudo-moar e97fb7: OUTPUT«(hello.c)␤»

[02:46] <unmatched}> m: "hello.o: hello.c foobar.c".words[1..*].say

[02:46] <TEttinger> mm. no idea how to do this

[02:46] <camelia> rakudo-moar e97fb7: OUTPUT«(hello.c foobar.c)␤»

[02:46] <TEttinger> thanks!

[02:47] <dataangel> unmatched}: I cry? ;) this is to parse a dependency file generated by GCC for use by make... I assume it escapes spaces not sure

[02:47] <unmatched}> Well, the .words example above is simple enough but it'll break for filenames with spaces in 'em

[02:47] <TEttinger> m: "hello.o: hello.c foobar.c\nhey.o: yo.c bazquux.c".words[1..*].say

[02:47] <camelia> rakudo-moar e97fb7: OUTPUT«(hello.c foobar.c hey.o: yo.c bazquux.c)␤»

[02:47] <dataangel> unmatched}: also for my own education I'd like to understand how to do it with captures

[02:48] <unmatched}> sure sure

[02:48] <TEttinger> how would you adapt it to respect newlines?

[02:48] <unmatched}> m: 'he\ llo.o: hello.c foo\ bar.c'.split(/<!after '\\'> ' '+/).[1..*].say

[02:48] <camelia> rakudo-moar e97fb7: OUTPUT«(hello.c foo\ bar.c)␤»

[02:49] <dataangel> wat?

[02:49] <dataangel> Before we break out fifty more language features, why doesn't my version work? ;p

[02:50] <unmatched}> because it's greedy I'd assume

[02:50] <unmatched}> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( \S+ ) \s* )+ /; say $/[0][0];

[02:50] <camelia> rakudo-moar e97fb7: OUTPUT«｢ hello.c ｣␤ 0 => ｢hello.c｣␤»

[02:51] <timotimo> in what way does it not work?

[02:51] <timotimo> oh

[02:51] <timotimo> i confused the names

[02:51] <dataangel> timotimo: [0][0] gives a single match that has both files rather than an array of matches each with one file 

[02:52] *** MilkmanDan joined
[02:52] <dataangel> unmatched}: ah, so the problem with mine is that .+ matches even the space separating the two filenames? 

[02:54] <unmatched}> dataangel: yes. And + is greedy. You can also fix it with .+?

[02:54] <TEttinger> as it should

[02:54] <unmatched}> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+? ) \s* )+ /; say $/[0][0];

[02:54] <camelia> rakudo-moar e97fb7: OUTPUT«｢ h｣␤ 0 => ｢h｣␤»

[02:54] <unmatched}> oh, wait, you can't :P

[02:54] <unmatched}> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+? ) <before [\s|$]> )+ /; say $/[0][0];

[02:54] <camelia> rakudo-moar e97fb7: OUTPUT«｢ hello.c｣␤ 0 => ｢hello.c｣␤ before => ｢｣␤»

[02:54] <dataangel> Why doesn't that work? \s* matches right away because it zero or more?

[02:54] <TEttinger> looks like it

[02:55] <unmatched}> dataangel: right

[02:55] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+? ) [$|\s]+ )+ /; say $/[0][0];

[02:55] <dataangel> Now you you went and added more magic :p

[02:55] <camelia> rakudo-moar e97fb7: OUTPUT«Memory allocation failed; could not allocate 977305600 bytes␤»

[02:55] <unmatched}> dataangel: I just told it that the stuff .+ matches must be before whitespace or end of string

[02:56] <TEttinger> hahaa what

[02:56] <timotimo> unmatched}: it's not a good idea to match $+

[02:56] <TEttinger> that was me

[02:56] <unmatched}> timotimo: I'm not :)

[02:56] <TEttinger> how on earth...

[02:56] <timotimo> i really need to get the rest of my sleep

[02:57] <TEttinger> why is $+ a regex breaker?

[02:57] <timotimo> because it's zero-width

[02:57] <timotimo> so it matches as often as you want

[02:57] <TEttinger> only at end of file though?

[02:57] <TEttinger> it matches infinite ends of file?

[02:57] <timotimo> yeah, but still more than just once

[02:57] <timotimo> that's right

[02:57] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+? ) \s+|$ )+ /; say $/[0][0];

[02:57] <camelia> rakudo-moar e97fb7: OUTPUT«｢ hello.c ｣␤ 0 => ｢hello.c｣␤»

[02:58] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+? ) \s+|$ )+ /; say $/[0][1];

[02:58] <camelia> rakudo-moar e97fb7: OUTPUT«(Any)␤»

[02:58] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+? ) \s+|$ )+ /; say $/[1][0];

[02:58] <camelia> rakudo-moar e97fb7: OUTPUT«Nil␤»

[02:58] <TEttinger> hm

[02:58] *** kyclark left
[02:58] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+? ) $? )+ /; say $/[1][0];

[02:58] <camelia> rakudo-moar e97fb7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Can only quantify a construct that produces a match␤at <tmp>:1␤------> 3.c foobar.c" ~~ / .+\: ( \s* ( .+? ) $? 7⏏5)+ /; say $/[1][0];␤»

[02:59] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+? ) \b )+ /; say $/[1][0];

[02:59] <camelia> rakudo-moar e97fb7: OUTPUT«Nil␤»

[02:59] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+? ) \b )+ /; say $/[0][0];

[02:59] <camelia> rakudo-moar e97fb7: OUTPUT«Nil␤»

[02:59] <TEttinger> mm.

[02:59] <unmatched}> oh right

[03:00] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+ \b ) )+ /; say $/[0][0];

[03:00] <camelia> rakudo-moar e97fb7: OUTPUT«Nil␤»

[03:00] <TEttinger> is \b boundary between words in perl 6?

[03:00] <unmatched}> No

[03:00] <unmatched}> << and >> are

[03:00] <unmatched}> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( << ( .+ ) >> )+ /; say $/[0][0];

[03:00] <camelia> rakudo-moar e97fb7: OUTPUT«Nil␤»

[03:01] <unmatched}> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( << ( .+ ) >> \s* )+ /; say $/[0][0];

[03:01] <camelia> rakudo-moar e97fb7: OUTPUT«Nil␤»

[03:01] <unmatched}> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* << ( .+ ) >> \s* )+ /; say $/[0][0];

[03:01] <camelia> rakudo-moar e97fb7: OUTPUT«｢ hello.c foobar.c｣␤ 0 => ｢hello.c foobar.c｣␤»

[03:01] <unmatched}> bah

[03:01] <unmatched}> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* «( .+? )» \s* )+ /; say $/[0][0];

[03:01] <camelia> rakudo-moar e97fb7: OUTPUT«｢ hello｣␤ 0 => ｢hello｣␤»

[03:01] <TEttinger> yay

[03:01] <unmatched}> oh right teh dots and things :)

[03:02] <TEttinger> seems like this might need lookahead?

[03:02] <dataangel> How do I return each of the array elements of $/[0] as an array of strings? Basically want to return the files on the right-hand side of the :

[03:03] <unmatched}> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( .+? ) <before [\s|$]> )+ /; say $/[0]».Str;

[03:03] <unmatched}> :/

[03:03] <camelia> rakudo-moar e97fb7: OUTPUT«[ hello.c  foobar.c]␤»

[03:03] <unmatched}> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( \S+ ) \s* )+ /; say $/[0]».Str;

[03:03] <camelia> rakudo-moar e97fb7: OUTPUT«[ hello.c  foobar.c]␤»

[03:03] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: \s* ( .+ ) /; say $/[0].words;

[03:03] <camelia> rakudo-moar e97fb7: OUTPUT«(hello.c foobar.c)␤»

[03:03] <TEttinger> heyyy

[03:03] <dataangel> Why unhappy? Looks decent to me

[03:03] <unmatched}> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: ( \s* ( \S+ ) \s* )+ /; say $/[0].list>>.Str;

[03:03] <camelia> rakudo-moar e97fb7: OUTPUT«[ hello.c  foobar.c]␤»

[03:04] <unmatched}> It got spaces in it

[03:04] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: \s* ( .+ ) /; say $/[0].words[1];

[03:04] <camelia> rakudo-moar e97fb7: OUTPUT«foobar.c␤»

[03:04] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: \s* ( .+ ) /; say $/[0].words[0];

[03:04] <camelia> rakudo-moar e97fb7: OUTPUT«hello.c␤»

[03:04] <TEttinger> yaaaaay

[03:04] <unmatched}> TEttinger: heh... may as well not use the reggex then :P

[03:04] <TEttinger> that's like my first time successfully writing anything in perl6

[03:04] <TEttinger> it uses the regex to get rid of the part before the :\s*

[03:05] <dataangel> unmatched}: why does it still have spaces? Again thought inner capture group was going to take care of that 

[03:07] <TEttinger> p6: my $result = "hello.o: hello.c foobar.c\nsome other line" ~~ / .+\: \s* ( [^\r\n]+ ) .* /; say $/[0].words[0];

[03:07] <camelia> rakudo-moar e97fb7: OUTPUT«Cannot resolve caller words(Nil: ); none of these signatures match:␤    (Cool:D $: |c is raw)␤  in block <unit> at <tmp> line 1␤␤»

[03:08] <TEttinger> that's quite the puzzling error

[03:08] <geekosaur> somehow you have a Nil before the actual items

[03:09] <timotimo> um, are you sure you mean ^\r\n inside a [ ]?

[03:09] <timotimo> because that looks a bit like perl5 regex

[03:09] <geekosaur> so you see [ hello.c  foobar.c] and "why does it have spaces?" it doesn't. it has something that stringifies to the empty string first

[03:09] <geekosaur> [Nil, "hello.c", Nil, "foobar.c"]

[03:10] <TEttinger> timotimo: I was wondering why regular-expressions.info has indepth coverage of most languages but not perl 6, and I suspect it's because a lot of stuff is different

[03:10] <geekosaur> (now, as to why...)

[03:10] <geekosaur> perl 6 regex is less classical regex and more grammar

[03:10] <TEttinger> "how i do make match character class please"

[03:11] <dataangel> geekosaur: that seems like a dangerous string conversion... Why make it convert to empty string? None in python doesn't work that way and it doesn't seem to cause me trouble 

[03:11] <geekosaur> <[ a c x ]> # charclass

[03:11] <TEttinger> and not having spaces in that breaks it?

[03:11] <TEttinger> oh, <[

[03:11] <TEttinger> ...

[03:12] <geekosaur> [ ] is a noncapturing group in perl 6

[03:12] <TEttinger> why did one of the few most common aspects of regex change here?

[03:12] <timotimo> because [ ] is much too valuable to spend on character classes

[03:12] <geekosaur> so charclass moved to <[ ]>. the syntax differs also, because it's mroe flexible than traditional character classes

[03:12] <TEttinger> uh huh

[03:12] <timotimo> and having <...> as the general "special" match syntax fits well with character classes

[03:13] <timotimo> and <-[abc]> is much saner than putting the "negate this char class" inside the [ ]

[03:13] <geekosaur> dataangel, I was not privy to that decision, but it *is* pretty Perl-ish

[03:14] <TEttinger> oh yes, very. I think it's very sane if you didn't have multiple generations of programmers used to the previous version. I can see why we had TRUMP_PENCE join this channel to spam, it's in the contrarian spirit of things :P

[03:15] <geekosaur> perl 5's /x already started changing things...

[03:16] <geekosaur> (not that anyone uses it. sadly, because it's the second best thing ever to happen to regexes (perl 6's reimagining being the best thing!))

[03:16] <TEttinger> what is \x?

[03:16] <timotimo> extended mode

[03:16] <geekosaur> actually I do use /x. with copious comments when the regex is complex, so a future reader will actually understand what's going on

[03:16] <geekosaur> it is /x as in s/pat/repl/x

[03:16] <TEttinger> oh, that's the comment and whitespace modifier?

[03:16] <geekosaur> yes

[03:17] <TEttinger> I mean, I don't think of that as a terribly unusual feature

[03:17] <geekosaur> I can't count the number of times I encounter people who insist on using regex. then insist on using a regex that they explicitly do not understand

[03:17] <geekosaur> ...why...

[03:17] <TEttinger> because it's hardly unique to the perl family

[03:18] <TEttinger> it's been in PCRE for a long time and other languages have it too

[03:18] <dataangel> geekosaur: so why are the Nil elements there? 

[03:18] <geekosaur> [18 03:10] <geekosaur> (now, as to why...)

[03:18] <geekosaur> meaning, I have no idea

[03:18] <dataangel> oh :p

[03:20] <TEttinger> .NET has an extension to their capturing groups that allows capturing into a stack of captures, then popping off elements when other things are captured. it makes their regexes part of a turing-complete class of languages as opposed to the class regular languages are in. it also allows you to parse html with regexes. perl 6 of course has the equally powerful grammars

[03:20] <dataangel> geekosaur: that doesn't make sense though, [0][0] and [0][1] each had the objects I wanted, and the hyper operator should not create new elements, so how would you end up with four things? 

[03:20] <timotimo> i'll try to resume my sleep

[03:21] <geekosaur> TEttinger, that was not a comment on /x itself, it was a comment on why /x is a good thing (that is, given that people use regex all over the place without knowing what they are doing, a facility to allow explanations and break a dense regex into comprehensible chunks is good)

[03:21] <TEttinger> oh

[03:21] <geekosaur> perl 6 started from there and reimagined regex as something less on the impenetrably-dense side to begin with

[03:22] <geekosaur> becuase, frankly, regexes suck

[03:22] <TEttinger> I'll just leave it at "I don't use it, but have fixed implementations of it"

[03:22] <TEttinger> hehe

[03:23] <TEttinger> so this is penetrably dense, then: / .+\: ( \s* ( .+? ) <before [\s|$]> )+ /

[03:23] <TEttinger> the one pasted earlier

[03:23] <geekosaur> it;s at least broken into bite-size chunks. I'd go a bit further toward making it more self-explanatory, but I suspect it will take time for that mindset to penetrate

[03:24] <geekosaur> otoh we're talking about the successor to a language far too many of whose users prided themselves on incomprehensible "clever" code (see: JAPH)

[03:24] <TEttinger> no I mean I understand the rationale, I just don't think it's achieved or possibly achievable

[03:24] <geekosaur> it may well end up that people will continue to write "regex" in perl 6 grammars

[03:25] <geekosaur> it's more achievable if you drop some of the classical stuff and use tokens instead

[03:25] *** raiph joined
[03:26] <TEttinger> so is this a regex or a grammar? I may be misunderstanding something. / .+ /

[03:26] <TEttinger> or somehow both

[03:27] <geekosaur> it is a regex. a grammar is a mechanism for extending regex with named tokens

[03:27] <geekosaur> token any { / .+ / };  ....   / <token> /

[03:27] <geekosaur> er

[03:27] <geekosaur> token any { / .+ / };  ....   / <any> /

[03:28] <TEttinger> that is very powerful

[03:28] <TEttinger> I think that is a much more meaningful addition than a change in syntax

[03:29] <raiph> p6: my $result = "hello.o: hello.c foobar.c" ~~ / .+\: [ \s* ( \S+ ) \s* ]+ /; say $/[0].list>>.Str

[03:29] <camelia> rakudo-moar e97fb7: OUTPUT«[hello.c foobar.c]␤»

[03:29] <yoleaux> 16 Aug 2016 02:17Z <AlexDaniel> raiph: Using readable names for placeholder values (like $^key and $^value) is a footgun, please consider not recommending it publicly

[03:30] <TEttinger> I prefer foodgun myself

[03:30] <dataangel> geekosaur: interestingly using a non- capturing group on the outside gets rid of spaces: / .+\: [ \s* ( \S+ ) \s* ]+ / 

[03:31] <geekosaur> hm. maybe I misunderstood the thing just before I commented on that, which produced a Nil as the first element

[03:31] <geekosaur> which is why I understood it as Nil string Nil string

[03:35] <dataangel> It would be cool if there were built in character classes for unescaped spaces and escaped spaces

[03:36] <geekosaur> anyway, re character classes, S05 might be the best current explanation. one of the extensions is that <[a..c] + digit> is a thing (perl5 spelled that [a-c[:digit:]])

[03:39] *** wamba left
[03:56] <raiph> .tell AlexDaniel Are you saying #perl6 consensus and/or TimToady thinks `for Foo.kv { $^key, $^value }` is poor form? I thought current p6doc advice for placeholder variables ("use short names or ones that can be trivially understood in the correct order") was good.

[03:56] <yoleaux> raiph: I'll pass your message to AlexDaniel.

[04:01] <raiph> .tell AlexDaniel I've edited the comment you saw to use and $^k and $^v instead -- that's what you're suggesting, right?

[04:01] <yoleaux> raiph: I'll pass your message to AlexDaniel.

[04:02] *** raiph left
[04:04] *** skids left
[04:05] *** raiph joined
[04:06] <geekosaur> raiph, the "in the correct order" part is what makes comprehensible names a footgun :(

[04:07] * geekosaur thought those were an interesting idea until he realized what that meant; now has no intention of using them

[04:09] <raiph> geekosaur: is the thinking now that 'key' and 'value' are in less comprehensible order than 'k' and 'v'?

[04:10] <geekosaur> no, the problem is that they're always assigned in lexical order; the thinking is that single letter things don't hint that you can reorder them the way meaningful names do

[04:10] * geekosaur finds that reasoning... dubious

[04:11] <geekosaur> i.e. the real footgun is not the naming, but the concept

[04:11] *** kyclark joined
[04:15] *** kyclark left
[04:15] <raiph> geekosaur: is #perl6 consensus and/or TimToady's thinking now leaning toward deprecation or discouragement of use of placeholder variables?

[04:16] <geekosaur> the above was my personal opinion. consensus still seems to think they're a good thing; I think they need to bake a bit longer

[04:17] <tailgate> If I have an array of arrays of arrays like , how can i flatten it while retaining the orginal i.e. ([0 1] [0 1]) ([0 1] [0 1]) ([0 1] [0 1]) ([0 1] [0 1])) -> ([0 1] [0 1] [0 1] [0 1] [0 1] [0 1] [0 1] [0 1])

[04:17] <tailgate> the lowest level of list

[04:18] <raiph> tailgate: does http://stackoverflow.com/questions/37173023/how-do-i-flatten-a-list-of-lists-in-perl-6 help?

[04:19] <gfldex> tailgate: that depends on what you want to do with that array in the end

[04:19] <tailgate> nice, thanks

[04:19] *** Cabanossi left
[04:19] <tailgate> cross-product all the arrays

[04:21] *** Cabanossi joined
[04:23] *** grondilu left
[04:24] *** cpage_ left
[04:28] *** khw left
[04:34] <BenGoldberg> . o O ( Imho, I think all examples where placeholder variables are used, the names should be a single letter, $^a, or start with a single letter and a dash, $^a-key, $^b-value )

[04:42] *** labster left
[04:42] *** labster1 joined
[04:43] *** labster1 is now known as labster

[04:43] *** labster left
[04:43] *** labster joined
[04:52] *** cpage_ joined
[04:53] *** leego left
[04:57] *** pierre_ left
[04:59] <raiph> my (:$name, :$age, *%) := :something<or other>, :name<Matt>, :33age; dd $age

[05:00] <raiph> ^^ vcv, unmatched}

[05:08] <BenGoldberg> m: sub foo { Hash.new(:name<Ben>, :age<MYOB>, :commute("two wheeled")) }; my (:$age, *%) := foo; dd $age;

[05:08] <camelia> rakudo-moar e97fb7: OUTPUT«Mu␤»

[05:08] <BenGoldberg> m: sub foo { :name<Ben>, :age<MYOB>, :commute("two wheeled") }; my (:$age, *%) := foo; dd $age;

[05:08] <camelia> rakudo-moar e97fb7: OUTPUT«"MYOB"␤»

[05:08] <BenGoldberg> raiph++

[05:09] *** BenGoldberg left
[05:10] *** labster left
[05:10] *** labster joined
[05:19] *** labster left
[05:22] *** canopus left
[05:26] *** mcmillhj joined
[05:27] *** pierre_ joined
[05:31] *** mcmillhj left
[05:31] *** pierre_ left
[05:33] *** canopus joined
[05:33] *** Girafferson joined
[05:37] *** pmurias joined
[05:37] <pmurias> hi

[05:41] *** pduh left
[05:45] <shantanu> Is there a way to get a list of all available namespaces or atleast package names in CompUnit::Repository::Perl5 or CompUnit::Repository::NQP?

[05:46] <shantanu> I am looking at implementing pluggable and I am wondering if its ok to just ignore everything except CompUnit::Repository::Installation

[05:47] <shantanu> m: my $repo = $*REPO;repeat {given $repo.^name {when 'CompUnit::Repository::Installation' {for $repo.installed -> $distribution {for $distribution.meta<provides>.keys -> $provides {say $provides;}}}}} while $repo = $repo.next-repo;

[05:48] <camelia> rakudo-moar e97fb7: OUTPUT«Pod::To::Text␤NativeCall::Compiler::MSVC␤CompUnit::Repository::Staging␤experimental␤newline␤NativeCall::Compiler::GNU␤NativeCall␤NativeCall::Types␤Test␤TAP␤»

[05:50] *** leego joined
[05:50] *** raiph left
[05:53] <shantanu> ditto for CompUnit::Repository::AbsolutePath and CompUnit::Repository::FileSystem. What do you guys think?

[05:58] *** leego left
[06:02] *** jack_rabbit joined
[06:11] *** leego joined
[06:26] *** RabidGravy joined
[06:29] *** firstdayonthejob joined
[06:30] *** rkazak joined
[06:32] *** rkazak left
[06:35] *** rkazak joined
[06:37] *** CIAvash joined
[06:43] *** ufobat joined
[06:45] *** rindolf joined
[06:45] *** rkazak left
[06:46] *** firstdayonthejob left
[06:52] *** TheLemonMan joined
[07:07] *** sno left
[07:12] *** darutoko joined
[07:16] *** rindolf left
[07:26] *** zakharyas joined
[07:41] *** mcmillhj joined
[07:46] *** sno joined
[07:46] *** mcmillhj left
[08:00] *** tokomer joined
[08:04] *** dakkar joined
[08:12] <dalek> ecosystem: d021aba | (Shantanu Bhadoria)++ | META.list:

[08:12] <dalek> ecosystem: Add CompUnit::Search to ecosystem

[08:12] <dalek> ecosystem: 

[08:12] <dalek> ecosystem: See https://github.com/shantanubhadoria/p6-CompUnit-Search

[08:12] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/d021aba885

[08:12] <dalek> ecosystem: f6ee27e | azawawi++ | META.list:

[08:12] <dalek> ecosystem: Merge pull request #236 from shantanubhadoria/master

[08:12] <dalek> ecosystem: 

[08:12] <dalek> ecosystem: Add CompUnit::Search to ecosystem

[08:12] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/f6ee27e5d0

[08:13] *** TEttinger left
[08:21] *** labster joined
[08:26] *** gfldex left
[08:31] *** cibs left
[08:33] *** cibs joined
[08:33] *** lizmat left
[08:35] *** kjs_ joined
[08:39] *** AlexDaniel joined
[08:41] *** tokomer left
[08:44] <TheLemonMan> hmm, is it possible to extract the Signature off a class method ?

[08:44] <TheLemonMan> m: class a { method m($i) {}; }; say a.m.signature;

[08:44] <camelia> rakudo-moar 643c0f: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in method m at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[08:47] <TheLemonMan> m: class a { method m($i) {}; }; say a.^methods[0].signature;

[08:47] <camelia> rakudo-moar 643c0f: OUTPUT«(a $: $i, *%_)␤»

[08:47] <TheLemonMan> gotcha!

[08:49] <DrForr> TheLemonMan: If you want some ideas on what to do with them, https://github.com/drforr/perl6-App-prancer/blob/master/lib/App/Prancer/Routes.pm6

[08:50] *** domidumont joined
[09:01] <gregf_> m: class a { method m($i) {}; }; say a.^lookup("m").signature

[09:01] <camelia> rakudo-moar 643c0f: OUTPUT«(a $: $i, *%_)␤»

[09:02] *** kjs_ left
[09:04] *** domidumont left
[09:05] *** MilkmanDan left
[09:08] *** tx0h joined
[09:09] <tx0h> i got a "Internal error: invalid thread ID 33 in GC work pass" with bailador. server crashed. what could cause this issue?

[09:10] <tx0h> i'm not sure if thread 33 existed at the time or not.

[09:19] *** pierre_ joined
[09:23] <nine> jnthn: ^^^

[09:26] <jnthn> It usually means memory corruption.

[09:26] <timotimo> tx0h: what version of perl6 are you on? we very recently got more stability improvements into git 

[09:26] *** kurahaupo joined
[09:27] *** mvorg joined
[09:35] *** ItayAlmog joined
[09:35] <ItayAlmog> m: class P { my $p; has $p;  }

[09:35] <camelia> rakudo-moar 643c0f: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $p␤    at <tmp>:1␤    ------> 3class P { my $p; has $p7⏏5;  }␤»

[09:35] <ItayAlmog> m: class P { has $p;  }

[09:35] <camelia> rakudo-moar 643c0f: ( no output )

[09:36] *** rindolf joined
[09:37] *** kurahaupo left
[09:46] <TheLemonMan> can anyone confirm that 'class a {method m(:$i) {$i};}; say a.new().m(:i(42));' gives a couple of Oops when compiled with --target=ast ?

[09:48] <timotimo> can someone test GTK::Simple? it seems to be broken on linux because for some reason it tries to copy around an lzma.dll file

[09:48] <timotimo> which is obviously bogus

[09:52] *** Wiertek joined
[09:54] *** bob777 left
[09:56] *** bob777 joined
[09:59] *** ItayAlmog left
[10:02] <tx0h> timotimo: This is Rakudo version 2016.07.1 built on MoarVM version 2016.07

[10:02] <tx0h> timotimo: in other words: debian unstable package

[10:09] *** g4 joined
[10:11] <timotimo> OK, you could try building a latest rakudo from git

[10:16] *** trnh joined
[10:16] *** trnh left
[10:16] *** trnh joined
[10:20] <timotimo> can we still nqp::box_i into a CPointer repr'd class

[10:20] <timotimo> This type cannot box a native integer: P6opaque, Scalar

[10:21] <jnthn> Missing nqp::decont?

[10:22] <timotimo> then i get P6opaque, Mu

[10:22] <timotimo> >_<

[10:23] <timotimo> oh, looks like i can actually nativecast here

[10:23] <timotimo> the code must have been written before nativecast was a thing

[10:25] <timotimo> but nativecast says "failed binding to $source, expected Any but got Mu"

[10:26] *** kjs_ joined
[10:39] *** bjz joined
[10:39] *** labster left
[10:41] *** edehont joined
[10:43] *** edehont left
[11:05] *** xinming_ joined
[11:07] *** bjz left
[11:08] *** xinming left
[11:20] *** varun_ joined
[11:20] *** varun_ left
[11:22] *** bjz joined
[11:29] *** movl left
[11:39] *** movl joined
[11:45] *** ItayAlmog joined
[11:45] <ItayAlmog> m: class P { has $.x = 5; method x() { $.x++; } }; P.new.x

[11:45] <camelia> rakudo-moar 643c0f: OUTPUT«Memory allocation failed; could not allocate 131072 bytes␤»

[11:46] <ItayAlmog> Well, I would guess this is a bug (?)

[11:46] <ilmari> m: class P { has $.x = 5; method x() { $!x++; } }; P.new.x

[11:46] <camelia> rakudo-moar 643c0f: ( no output )

[11:46] <ilmari> ItayAlmog: $.x calls the accessor, which you replaced, leading to infinite recursion

[11:46] <ilmari> m: class P { has $.x = 5; method x() { $!x++; } }; P.new.x.say

[11:46] <camelia> rakudo-moar 643c0f: OUTPUT«5␤»

[11:46] <ItayAlmog> Ops, My mistake :P

[11:47] <ilmari> m: class P { has $.x = 5; method x() { $!x++; } }; given P.new { .x.say; .x.say }

[11:47] <camelia> rakudo-moar 643c0f: OUTPUT«5␤6␤»

[11:47] <ItayAlmog> m: class P { has $.x = 5; method x() { $!x++; } }; class T {}; T.new.x.say

[11:47] <camelia> rakudo-moar 643c0f: OUTPUT«Method 'x' not found for invocant of class 'T'␤  in block <unit> at <tmp> line 1␤␤»

[11:47] <ItayAlmog> m: class P { has $.x = 5; method x() { $!x++; } }; class T is P {}; T.new.x.say

[11:47] <camelia> rakudo-moar 643c0f: OUTPUT«5␤»

[11:52] *** bjz_ joined
[11:52] *** bjz left
[12:01] *** rmmm left
[12:01] *** Wiertek left
[12:01] *** rmmm joined
[12:04] *** Girafferson left
[12:05] *** infina left
[12:06] *** rmmm left
[12:06] *** kjs_ left
[12:06] *** infina joined
[12:07] *** infina left
[12:07] *** infina joined
[12:07] *** heatsink joined
[12:09] *** kjs_ joined
[12:10] <ItayAlmog> m: enum Test <True>; my Bool $test = True;

[12:10] <camelia> rakudo-moar 643c0f: OUTPUT«Type check failed in assignment to $test; expected Bool but got Test (Test::True)␤  in block <unit> at <tmp> line 1␤␤»

[12:12] *** rmmm joined
[12:12] <nine> ItayAlmog: that's the downside of having all builtins lexically scoped. You can override anything but you also have to live with it.

[12:13] <unmatched}> m: sub say { put "You shall not say $^a!" }; sub infix:<+> { $^a - $^b }; say 2 + 2

[12:13] <camelia> rakudo-moar 643c0f: OUTPUT«You shall not say 0!␤»

[12:14] <ItayAlmog> I feel like I am going to have a really really hard time making a compiler for this language :\

[12:15] <nine> ItayAlmog: let's put it this way: a lot of people have been working for ~ 7 years to build rakudo.

[12:15] <nine> And they did not start with nothing

[12:15] <unmatched}> ItayAlmog: well, we've been at it for 15 years and so far I've seen folks tell you doing your way is next to impossible :)

[12:15] <ItayAlmog> Yeah, my dad told me that this language have been under construction for 15 years :)

[12:16] <ItayAlmog> I will prove it is somewhat possible :D

[12:16] <unmatched}> m: sub infix:<♥> { say $^a + $^b }; ๒ ♥ ๙

[12:16] <camelia> rakudo-moar 643c0f: OUTPUT«11␤»

[12:16] <unmatched}> Ah, to be young again :)

[12:17] * unmatched} remembers having the same attitude about perpetual motion drives for a brief period of teenagehood

[12:17] <ItayAlmog> Right now I am not even working on the Parser, I right now have a code generator and AST which currently I build manually.

[12:17] <unmatched}> ItayAlmog: it sounds like we could really use your skills to make Rakudo faster and betterer :)

[12:19] <unmatched}> m: sub infix:<¯\(°_o)/¯> { ($^a, $^b).pick }; say 'Coke' ¯\(°_o)/¯ 'Pepsi';

[12:19] <camelia> rakudo-moar 643c0f: OUTPUT«Pepsi␤»

[12:19] <DrForr> ItayAlmog: You have attraced my attention :)

[12:19] <ItayAlmog> :D

[12:20] <ItayAlmog> I will update as soon I will run it for the first time :) (Right now I have no idea if it works or not)

[12:20] <unmatched}> m: sub prefix:<∑> (*@els) { @els.sum }; say ∑ 1, 2, 3, 4;

[12:20] <camelia> rakudo-moar 643c0f: OUTPUT«1234␤»

[12:20] <unmatched}> ItayAlmog: write a blog post about it!

[12:20] <ItayAlmog> I will consider it :)

[12:20] <unmatched}> m: sub prefix:<∑> (*@els) is looser(&infix:<,>) { @els.sum }; say ∑ 1, 2, 3, 4;

[12:20] <camelia> rakudo-moar 643c0f: OUTPUT«10␤»

[12:21] <nine> ItayAlmog: why not just join the fun and work on rakudo? You'd be part of a team and the results will help a lot of people. And you'll see results a whole lot quicker :)

[12:23] <ItayAlmog> I might go ahead and help on rakudo once I will have more knowledge about Perl 6 NQP :)

[12:24] *** n1lp7r joined
[12:32] <heatsink> speaking of NQP, could somebody point to where the documentation is, the only thing I found was on the parrot wiki

[12:33] <unmatched}> heatsink: there's the Internals Course: http://edumentab.github.io/rakudo-and-nqp-internals-course/ and the docs folder in repo: https://github.com/perl6/nqp/tree/master/docs

[12:34] <heatsink> unmatched}: ah, thanks :)

[12:35] <moritz> if somebody is looking to do something good for the community, please consider going through https://github.com/linuxfoundation/cii-best-practices-badge/blob/master/doc/criteria.md and add missing stuff for Rakudo

[12:37] <unmatched}> huggable: best practices badge :is: https://github.com/linuxfoundation/cii-best-practices-badge/blob/master/doc/criteria.md

[12:37] <huggable> unmatched}, Added best practices badge as https://github.com/linuxfoundation/cii-best-practices-badge/blob/master/doc/criteria.md

[12:38] <unmatched}> dj_goku: FWIW, the REPL bug has been fixed in HEAD

[12:39] <moritz> I plan to go over it once my Internet connection is better again (hopefully Tuesday)

[12:41] *** sufrostico joined
[12:44] *** MilkmanDan joined
[12:45] <moritz> https://bestpractices.coreinfrastructure.org/projects/313

[12:46] *** grondilu joined
[12:50] <El_Che> if I want to send a feature request for rakudo, I go through RT?

[12:50] <nine> zes

[12:50] *** perlawhirl joined
[12:50] <El_Che> you smart people, that a nice filter :)

[12:51] <AlexDaniel> El_Che: filter?

[12:51] <yoleaux> 03:56Z <raiph> AlexDaniel: Are you saying #perl6 consensus and/or TimToady thinks `for Foo.kv { $^key, $^value }` is poor form? I thought current p6doc advice for placeholder variables ("use short names or ones that can be trivially understood in the correct order") was good.

[12:51] <yoleaux> 04:01Z <raiph> AlexDaniel: I've edited the comment you saw to use and $^k and $^v instead -- that's what you're suggesting, right?

[12:51] <ShimmerFairy> moritz: definitely seems like something worth working towards (at the very least, award-grabbing isn't a bad idea :P)

[12:52] <El_Che> AlexDaniel: many people won't bother if it's not something straightforward like github. 

[12:52] <dj_goku> unmatched}: thanks for letting me know!

[12:53] <AlexDaniel> El_Che: ironically, a lot of people think that RT is easier because you don't have to register an account to submit a bug report

[12:53] <El_Che> AlexDaniel: yeah, you know people, we're never happy

[12:53] <AlexDaniel> El_Che: which is somewhat true actually, but harsh reality is that most developers have a GitHub account so RT tends to be harder…

[12:53] <ShimmerFairy> AlexDaniel: for sure, that's something a surprising number of bugtrackers lack (you'd ideally want a low bar for submitting bugs, right?)

[12:54] <AlexDaniel> ShimmerFairy: well, ideally RT should allow people to login with GitHub and that will be it, I guess

[12:54] <El_Che> Im using the RT webinterface now :)

[12:54] <unmatched}> El_Che: and put [RFC] as the first thing in the subject line

[12:55] *** heatsink left
[12:55] <ShimmerFairy> AlexDaniel: I mean in a general sense, having to sign up for a bugtracker just to report one lousy bug seems like too high a price to me. "Wait, spend five minutes registering to report this one tiny bug? How about nah."

[12:55] *** heatsink joined
[12:55] <mst> what I'd really like is 2-way sync between GH issues and RT

[12:56] <mst> and then people can use whichever interface they prefer

[12:56] <mst> however, no, I can't be arsed building it myself

[12:56] <nine> El_Che: you can submit bug reports by sending email to [email@hidden.address]
[12:56] <nine> ShimmerFairy: ^^^

[12:57] <ShimmerFairy> nine: yeah, and having a low barrier like that is something I appreciate :)

[12:58] <El_Che> nine: yeah, I know

[12:58] <AlexDaniel> .tell raiph I don't remember any big discussion on that topic, so I'd say that it is a consensus of a small bunch of people who care about it. However, don't take my word on it and judge yourself, here is how the logic goes:

[12:58] <yoleaux> AlexDaniel: I'll pass your message to raiph.

[13:01] *** xinming_ left
[13:01] *** _4d47 left
[13:01] *** xinming joined
[13:03] <AlexDaniel> .tell raiph while $^onearg and $^otherarg might look very readable, it is pretty hard to tell which one comes first in the signature. Are you sure that readability is worth the extra mental step which requires the reader to sort the variable names alphabetically (…unicodically?) in his mind? If that does not sound very convincing, think about one of those times when variables are renamed during refactoring

[13:03] <yoleaux> AlexDaniel: I'll pass your message to raiph.

[13:05] <ShimmerFairy> I just realized: one way to think about $^a variables is as though they were explicitly labeled Whatevers, with the sorting part to provide some kind of plus over just stars everywhere :)

[13:06] <AlexDaniel> .tell and no, $^k and $^v is not any better than $^key and $^value. Call me stupid, but I don't know which one comes first off the top of my head. I'd say that $^a $^b $^c are better.

[13:06] <yoleaux> AlexDaniel: I'll pass your message to and.

[13:06] <AlexDaniel> .tell raiph and no, $^k and $^v is not any better than $^key and $^value. Call me stupid, but I don't know which one comes first off the top of my head. I'd say that $^a $^b $^c are better.

[13:06] <yoleaux> AlexDaniel: I'll pass your message to raiph.

[13:13] *** kjs_ left
[13:14] *** mcmillhj joined
[13:16] *** wamba joined
[13:18] <AlexDaniel> I think that one of the selling points of $^… was that you can do stuff like this:

[13:18] <AlexDaniel> m: my @foo = ^20; say @foo.sort: { $^b cmp $^a }

[13:18] <camelia> rakudo-moar 643c0f: OUTPUT«(19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0)␤»

[13:18] <AlexDaniel> however it does not look very convincing when you realize that you can do this:

[13:18] <AlexDaniel> m: my @foo = ^20; say @foo.sort: * Rcmp *

[13:18] <camelia> rakudo-moar 643c0f: OUTPUT«(19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0)␤»

[13:18] <unmatched}> :S

[13:18] <unmatched}> Looks pretty convincing to me

[13:19] *** adu joined
[13:19] *** cdg joined
[13:20] <AlexDaniel> unmatched}: okay then :)

[13:20] <AlexDaniel> m: my @foo = ^20; say @foo.sort: { $^two cmp $^one } # what about this? ;)

[13:20] <camelia> rakudo-moar 643c0f: OUTPUT«(19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0)␤»

[13:21] <unmatched}> What about it?

[13:21] <unmatched}> $a and $b is what even Perl 5 uses. $^a and $^b is nearly the same

[13:22] <AlexDaniel> yeah, $^a $^b in perl 6 is perl 5 $a $b done better.

[13:22] <ShimmerFairy> except $^a and $^b aren't magic globals that (presumably) haunt coders' dreams.

[13:22] *** g4 left
[13:22] <unmatched}> I find that whole conversation about $^vars kinda silly... It's like arguing about whether you should name your subroutines by mashing on your keyboard.

[13:23] *** skids joined
[13:23] <unmatched}> Or a more direct analogy: arguing that you should use descriptive subroutine names instead of naming the a() and b(), except with $^a and $^b it's in reverse, but for the same purpose

[13:25] <lucs> AlexDaniel: Are $^two and $^one special cases recognized by the grammar, or is something else going on?

[13:25] <unmatched}> $^a and $^b encode the parameter position in their name so using $^key and $^value is just as silly as naming a sorting subroutine nondescript a()

[13:25] <AlexDaniel> unmatched}: except that $^descriptive-name may look like a great idea, which is what this discussion is about

[13:26] <ShimmerFairy> lucs: it's in alphabetical order, which is why $^b cmp $^a compares things in reverse.

[13:26] <AlexDaniel> m: say ‘one’ le ‘two’

[13:26] <unmatched}> lucs: https://docs.perl6.org/language/variables#index-entry-%24^

[13:26] <camelia> rakudo-moar 643c0f: OUTPUT«True␤»

[13:26] <AlexDaniel> m: say ‘a’ le ‘b’

[13:26] <camelia> rakudo-moar 643c0f: OUTPUT«True␤»

[13:26] *** kyclark joined
[13:26] <AlexDaniel> m: say ‘key’ le ‘value’

[13:26] <camelia> rakudo-moar 643c0f: OUTPUT«True␤»

[13:26] <lucs> ShimmerFairy: Ah, just alpha order, makes sense.,

[13:26] <lucs> s/,$//

[13:27] <lucs> (makes sense, but may be misleading -- I believe I wouldn't use that.)

[13:27] <unmatched}> AlexDaniel: "except that sub a() {} may look like a great idea 'cause it's short to type"

[13:27] <ShimmerFairy> lucs: yeah, but more general sorting for the different kinds of letters you can use :)

[13:27] <AlexDaniel> unmatched}: ok, you win :D

[13:27] <unmatched}> \o/

[13:28] *** Wiertek joined
[13:28] <AlexDaniel> unmatched}: I've never thought about it this way :)

[13:28] <ShimmerFairy> lucs: It's clear and advantageous for single letter variables, otherwise you'd have to do   -> $a, $b { $b cmp $a }    to get the same thing (as one alternative)

[13:29] <lucs> ShimmerFairy: Oh, I totally agree with a/b, etc. it's the one/two I find misleading.

[13:29] <jnthn> I figure code is read a lot more than it's written. The main danger of confusion to me would be if somebody changed the names not realizing the importance of their names on ordering, but (a) that'd hopefully show up as a big enough fail to break tests etc. and (b) comprehension wise, more meaningful names indicating the content of the variable are likely a net win.

[13:30] <jnthn> For sorting though I'd just go with a and b, 'cus the names or the sortees don't really matter much :)

[13:30] <ItayAlmog> m: class P { say "test" }

[13:30] <camelia> rakudo-moar 643c0f: OUTPUT«test␤»

[13:30] <ShimmerFairy> lucs: which is why you shouldn't do it :P . It's a natural consequence of wanting that kind of shorthand implicit ordering, but in a general sense.

[13:30] <jnthn> $^key and $^value make sense to me in calling out what they two things are, though.

[13:31] <AlexDaniel> well, if code is read a lot more than it's written, then perhaps it's worth to type out -> $key, $value { … } ;)

[13:31] <jnthn> $^one and $^two don't in that I don't think I'd ever call a variable $one unless it contained the number one :)

[13:32] <jnthn> AlexDaniel: That isn't an argument in favor of verbosity. :)

[13:32] <lucs> $^first, $^second ;)  (luckily, and just luckily, it works)

[13:32] <jnthn> Indeed, it's surprising how many of them actually work ;)

[13:32] <unmatched}> jnthn: but $^key and $^value work properly nearly by accident. If you translate them to Russian, the order would be different, for example

[13:33] <lucs> $^premier $^deuxieme BZZZT!

[13:33] <unmatched}> m: say <a b c d e>.map: { $^key => $^value }

[13:33] <camelia> rakudo-moar 643c0f: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at <tmp> line 1␤␤»

[13:33] <unmatched}> bah

[13:33] <unmatched}> m: say <a b c d>.map: { $^key => $^value }

[13:33] <camelia> rakudo-moar 643c0f: OUTPUT«(a => b c => d)␤»

[13:33] <jnthn> unmatched}: That's a pretty rare use case :P

[13:33] <unmatched}> m: say <a b c d>.map: { $^ключ => $^стоимость }

[13:33] <camelia> rakudo-moar 643c0f: OUTPUT«(a => b c => d)␤»

[13:34] <unmatched}> :/

[13:34] <AlexDaniel> m: say <a b c d>.map: { $^ключ => $^значение }

[13:34] <camelia> rakudo-moar 643c0f: OUTPUT«(b => a d => c)␤»

[13:34] <unmatched}> right

[13:34] <unmatched}> jnthn: why is it? English isn't even the most common language.

[13:34] <pmurias> variable names in Russian seem like a bad practice

[13:35] <lucs> We'd like to use words for symbols, but before anything else, they're symbols.

[13:35] <ShimmerFairy> only if you're not Russian.

[13:35] <unmatched}> pmurias: not if you're Russian

[13:35] <unmatched}> ...working in Russia... for a Russian code shop

[13:35] <jnthn> unmatched}: Yes, but even then it's rare to write code in one lnaguage and then afterwards translate it to another. :)

[13:35] <AlexDaniel> unmatched}: I'd say that in programming context “стоимость” is either “cost” or “weight”

[13:36] <AlexDaniel> though I've never thought about it

[13:36] <pmurias> unmatched}: I wouldn't name variables in my native language Polish either

[13:36] <jnthn> unmatched}: And if you're authoring the code in Russian in the first place you'd either pick words that naturally work or just use a different language construct. :)

[13:36] <AlexDaniel> haha. That's a nice argument because none of the Russian words work naturally :D

[13:36] <unmatched}> pmurias: that's because you speak English. If all I know is Russian, transliterating Russian into English alphabet seems silly, consiring you can just use Russian

[13:37] <ItayAlmog> m: class P { has $x = 5; say $!x; }

[13:37] <camelia> rakudo-moar 643c0f: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable $!x used where no 'self' is available␤at <tmp>:1␤------> 3class P { has $x = 5; say $!x7⏏5; }␤»

[13:37] <pmurias> unmatched}: do the have a Russian CPAN in Russia?

[13:37] <ItayAlmog> m: class P { my $x = 5; say $x; $x++; say $x }

[13:37] <camelia> rakudo-moar 643c0f: OUTPUT«5␤6␤»

[13:37] <ShimmerFairy> There is something to be said for preferring English where possible/convenient though. Considering you have to look at English words in Perl 6 (by default) already, among the other usual reasons.

[13:38] <unmatched}> pmurias: no idea. They do have translated Perl 5 

[13:39] <jnthn> AlexDaniel: That's unlucky...

[13:39] <pmurias> unmatched}: you mean one with Russian keywords?

[13:39] <unmatched}> jnthn: still, $^a and $^b encode position, which is relevant in $^ twigil, while $^key and $^value encode meaning and inherently place the encoded position information onto the backseat, hence bugs can creep in

[13:40] <unmatched}> pmurias: probably not. But when you don't know English you don't learn of BEGIN/map/sort as words that have some meaning outside of the language, but rather as words that make the language do things.

[13:41] <AlexDaniel> no, there's no Russian CPAN… stop making it sound like Russia is some kind of an isolated island :D

[13:41] <unmatched}> s:g/language/programming language/;

[13:41] <SourceBaby> unmatched}, Ehhh... I'm too scared to run that code.

[13:42] <lucs> unmatched}: Again, it's good to think of them simply as symbols, not words (although as symbol that happens to be a word that one knows has an extremely strong mnemonic value).

[13:42] <unmatched}> SourceBaby: then don't!

[13:42] <lucs> s/as symbol/a symbol/

[13:43] *** CIAvash left
[13:43] <AlexDaniel> .tell raiph also feel free to read this discussion: http://irclog.perlgeek.de/perl6/2016-08-18#i_13046240

[13:43] <yoleaux> AlexDaniel: I'll pass your message to raiph.

[13:43] <jnthn> unmatched}: True. I guess it's about making a value judgement at the time you're writing the code. :)

[13:44] <unmatched}> Yeah :)

[13:44] * unmatched} does use .tap: { $^something-meaningful.print } # forexample

[13:44] <ShimmerFairy> well, when it's one variable, it definitely doesn't matter :)

[13:45] <jnthn> Yeah, then it's pretty nice :)

[13:46] <AlexDaniel> except that on the next line you might have $^a $^b in sorting. I don't care, but I see how some people might find it inconsistent.

[13:48] <ShimmerFairy> By the way, I wonder if anyone ever uses the $:variable syntax, 'cos if not, maybe we could free up that valuable twigil character for future use :)

[13:50] <jnthn> Pretty sure I've seen it in the wild :)

[13:50] <jnthn> It actually came about because somebody wanted to use it and missed it.

[13:50] <jnthn> Rather than being speculated as a maybe nice thing to have. :)

[13:51] <ShimmerFairy> ah. Just wondering because I only ever remember it when I think "oh yeah, that one twigil I never ever need"

[13:51] <unmatched}> m: my &сказать = &say; my &перевести = &map; сказать перевести { $^ключ => $^значение }, <водка подводка пиво красиво>;

[13:51] <camelia> rakudo-moar 643c0f: OUTPUT«(подводка => водка красиво => пиво)␤»

[13:51] <unmatched}> ehehe

[13:52] <jnthn> :D

[13:53] *** adu left
[13:53] *** ptolemarch joined
[13:56] *** kjs_ joined
[13:58] <jnthn> hehe, my wife had never realized подводка contained the word водка until just now :D

[14:00] * jnthn had to look it up...if I'd been put on the spot and made to guess, I'd have said it was probably the водка equivalent of what a bar mat for пиво :P

[14:01] * AlexDaniel thought that подводка is a typo-ed подлодка, until realizing that it is an actual thing that I just happen not to use

[14:02] <jnthn> Now that one I can guess right :)

[14:02] <unmatched}> heh. There's a song that goes something like "if the sea were водка, I'd become подводка; if it were пиво I'd become a dolphin (which I thought had красиво in it, but now I recall it was the dolphin, which is дельфином)

[14:03] *** leedo left
[14:03] <literal> silly question...does Unicode define locale-dependent sort orders for characters, and if so, are they included in Perl 6?

[14:03] *** leedo joined
[14:03] <ShimmerFairy> That would be the CLDR, and I don't think P6 integrates that in core.

[14:04] <jnthn> literal: Yes (TR10 iirc) and not yet

[14:04] <literal> e.g. because in my language 'á' follows 'a' and precedes 'b'

[14:04] <unmatched}> Oh, right, it's подлодка in the song. And TIL подводка is a thing

[14:04] * unmatched} strikes out "Native Russian proficiency" off his resume.

[14:04] <unmatched}> Been too long lol

[14:05] <literal> jnthn: I see

[14:05] <unmatched}> m: say "a" before "á"

[14:05] <camelia> rakudo-moar 643c0f: OUTPUT«True␤»

[14:05] <unmatched}> m: say "b" after "á"

[14:05] <camelia> rakudo-moar 643c0f: OUTPUT«False␤»

[14:06] *** Wiertek left
[14:08] <unmatched}> Oh, it's amusing this conversation about Russian happened, because I just realized I've now spent 3 days of my life longer outside of Russia than in it, despite being born and raised in it :)

[14:11] <jnthn> :)

[14:11] <AlexDaniel> unmatched}: it didn't just “happen”, you started it ;)

[14:12] <jnthn> Still 10 years or so before I'll be able to say the same about the UK. :)

[14:13] *** kyclark left
[14:18] *** _4d47 joined
[14:19] *** khw joined
[14:22] *** kurahaupo joined
[14:24] * [Coke] , in review, lobs out a "MAKE EXPRESSIONS REGULAR AGAIN".

[14:25] <ugexe> m: sub foo(Str:D(Cool) $str) { say $str }; foo: $*CWD; # How does one write `Str:D(Cool)`?

[14:25] <camelia> rakudo-moar 643c0f: ( no output )

[14:28] <unmatched}> What's the foo: do?

[14:28] <unmatched}> m: sub foo(Str:D(Cool) $str) { say $str }; foo $*CWD

[14:28] <camelia> rakudo-moar 643c0f: OUTPUT«Type check failed in binding to $str; expected Str but got IO::Path ("/home/camelia".IO(:S...)␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[14:28] *** finanalyst joined
[14:28] <ugexe> oops yeah thats what i meant

[14:29] <unmatched}> m: say IO::Path ~~ Cool; say IO::Path ~~ Str

[14:29] <camelia> rakudo-moar 643c0f: OUTPUT«False␤False␤»

[14:29] <ugexe> m: sub foo(Str(Cool) $str) { say $str }; foo $*CWD;

[14:29] <camelia> rakudo-moar 643c0f: OUTPUT«/home/camelia␤»

[14:29] <unmatched}> :/

[14:30] <jnthn> [Coke]: But the expressions have never been truly regular, there's always been backreferences and stuff. You're dreaming of an era of academic purity that never was! :P

[14:31] <[Coke]> jnthn: it works on many levels. :P

[14:31] <jnthn> #NeverPumpingLemma

[14:33] <unmatched}> m: say $*CWD ~~ Cool; say $*CWD ~~ Str

[14:33] <camelia> rakudo-moar 643c0f: OUTPUT«True␤False␤»

[14:35] <unmatched}> m: ( Str:D(Cool) ).^target_type.say

[14:35] <camelia> rakudo-moar 643c0f: OUTPUT«Method 'target_type' not found for invocant of class 'Perl6::Metamodel::DefiniteHOW'␤  in block <unit> at <tmp> line 1␤␤»

[14:36] <unmatched}> m: my $v = Str:D(Cool); $v.^target_type.say

[14:36] <camelia> rakudo-moar 643c0f: OUTPUT«Method 'target_type' not found for invocant of class 'Perl6::Metamodel::DefiniteHOW'␤  in block <unit> at <tmp> line 1␤␤»

[14:36] <unmatched}> m: my $v = Str(Cool); $v.^target_type.say

[14:36] <camelia> rakudo-moar 643c0f: OUTPUT«(Str)␤»

[14:42] *** tx0h left
[14:43] <_4d47> m: say [1, 2, 3].VAR ~~ Scalar

[14:43] <camelia> rakudo-moar 643c0f: OUTPUT«False␤»

[14:44] <_4d47> think this doc is wrong https://docs.perl6.org/language/mop#VAR

[14:44] <unmatched}> m: await start { get }

[14:44] <camelia> rakudo-moar 643c0f: ( no output )

[14:45] <unmatched}> I get "Tried to read() on a socket from outside its originating thread" for that in terminal. Is there a way to avoid that?

[14:45] * geekosaur thinks that sounds like libuv being "helpful"

[14:50] *** MilkmanDan left
[14:50] *** jack_rabbit left
[14:57] *** zacts left
[15:03] <ugexe> no

[15:04] <ugexe> that may or may not spawn a new thread which is why it does not always happen

[15:05] *** pierre_ left
[15:05] <unmatched}> I'll try to cook something up with a Channel maybe

[15:05] <ugexe> wont matter

[15:05] <unmatched}> Why? All the reads will happen on the one original thread.

[15:06] <ugexe> dunno. when I tried to work around this no matter what I did the data still acted like it had some flag set saying it was from a different thread

[15:09] <ugexe> i guess it could have been fixed in the mean time, but afaik it was a problem with libuv + scheduler-per-thread

[15:09] *** MilkmanDan joined
[15:10] <TheLemonMan> do I have to submit a testcase too when submitting a nqp fix ?

[15:10] <ugexe> https://github.com/MoarVM/MoarVM/issues/165

[15:15] *** acrussell joined
[15:16] <pmurias> TheLemonMan: you don't have too, but it would be great

[15:16] <pmurias> TheLemonMan: if you really hate writing tests I can write the testcase ;)

[15:19] <ItayAlmog> How can you define methods on enums? Or is it not possible?

[15:21] *** wamba left
[15:23] *** Ariantes_ left
[15:27] <TheLemonMan> pmurias, that'd be nice, the t/ directory is so confusing

[15:27] <unmatched}> m: enum <Foo Bar>; Foo.^mixin: role { method meow { say "meow" } }; Foo.meow

[15:27] <camelia> rakudo-moar 643c0f: OUTPUT«meow␤»

[15:28] <ItayAlmog> interesting

[15:28] <ItayAlmog> thanks :)

[15:35] *** cdg left
[15:37] *** djbkd left
[15:37] *** djbkd joined
[15:42] <_4d47> m: role Catish { method meow { say "meow" } }; enum Cat does Catish <cherise catlee>; catlee.meow;

[15:42] <camelia> rakudo-moar 643c0f: OUTPUT«meow␤»

[15:43] <ItayAlmog> m: sub test { sub test2 {say "test2"}; test2() }

[15:43] <camelia> rakudo-moar 643c0f: ( no output )

[15:44] <ItayAlmog> m: sub test { sub test2 {say "test2"}; test2() }; test();

[15:44] <camelia> rakudo-moar 643c0f: OUTPUT«test2␤»

[15:44] <ItayAlmog> this language doesn't make it easy on me :\

[15:44] <unmatched}> _4d47++

[15:46] <unmatched}> m: sleep 1 for ^4 .hyper: :batch; say "Look ma! Four 1-second sleeps took just {now - INIT now} seconds!";

[15:46] <camelia> rakudo-moar 643c0f: OUTPUT«Look ma! Four 1-second sleeps took just 1.00599812 seconds!␤»

[15:46] <unmatched}> ItayAlmog: ^ just wait until you get to the multi-threaded stuff :P

[15:47] <ItayAlmog> Yay xD :\

[15:48] <ItayAlmog> Right now I am writing a parser to also parse it, I might also have to redo some of the current code :\

[15:49] <ItayAlmog> But hey, I have done it for only one day, you have done it for 15 years so... I can't complain xD

[15:49] <unmatched}> :)

[15:51] <TheLemonMan> touché (?)

[15:54] *** araujo joined
[15:54] *** araujo left
[15:54] *** araujo joined
[16:01] *** perlawhirl left
[16:02] <unmatched}> ugexe: I got a working version, which I think can apply in my particular case. The limitation is you the place where get() happens has to remain in the first thread, so that portion has to block your program somewhere :/ https://gist.github.com/zoffixznet/5488a212d60abce818b7eacbb2ca0306

[16:03] *** sno left
[16:03] *** canopus left
[16:06] *** zacts joined
[16:09] <dalek> doc: e231200 | skids++ | doc/Language/mop.pod6:

[16:09] <dalek> doc: Fix docs for VAR, arrays are not automatically items, _4d47++

[16:09] <dalek> doc: review: https://github.com/perl6/doc/commit/e23120051b

[16:09] *** Actualeyes left
[16:09] *** canopus joined
[16:09] *** Actualeyes joined
[16:15] <moritz> why does https://travis-ci.org/rakudo/rakudo say "This is not an active repository"?

[16:16] <geekosaur> becuase it's looking for master, not nom

[16:17] <geekosaur> (this is probably a travis-ci default that can't be overridden. how many git projects *don't* use master?

[16:17] <geekosaur> )

[16:18] <geekosaur> select "Branches" and it'll show the default branch is "nom" and passing

[16:18] *** finanalyst left
[16:19] <ugexe> https://travis-ci.org/rakudo/rakudo/builds/153202296 # wut

[16:21] *** smls joined
[16:22] *** Actualeyes left
[16:30] *** mcmillhj left
[16:33] *** dakkar left
[16:35] *** Actualeyes joined
[16:35] *** araujo_ joined
[16:37] <harmil_wk> m: say ^1000 .grep: -> $n {([+] ^$n .grep: -> $m {$m and $n %% $m}) == $n } # Perfect numbers?

[16:37] <camelia> rakudo-moar 643c0f: OUTPUT«(signal SEGV)»

[16:37] <harmil_wk> Ahem.

[16:37] <harmil_wk> rakudobugging...

[16:37] *** araujo_ left
[16:37] <geekosaur> numbers too perfect for rakudo?

[16:37] *** mcmillhj joined
[16:38] *** araujo_ joined
[16:38] <unmatched}> harmil_wk: would you put [SEGV] as the first thing in subjectline, please.

[16:38] <harmil_wk> unmatched}: sure

[16:38] <timotimo> huh, it asplodes inside decont

[16:38] <timotimo> how does that happen

[16:39] *** araujo left
[16:39] <harmil_wk> sent

[16:39] <timotimo> bisectable: help

[16:39] <bisectable> timotimo: Like this: bisectable: good=2015.12 bad=HEAD exit 1 if (^∞).grep({ last })[5] // 0 == 4 # RT128181

[16:39] <timotimo> bisectable: good=2015.12 bad=HEAD say ^1000 .grep: -> $n {([+] ^$n .grep: -> $m {$m and $n %% $m}) == $n }

[16:39] *** MilkmanDan left
[16:39] <bisectable> timotimo: Exit code is 0 on both starting points (good=2015.12 bad=643c0f9), bisecting by using the output

[16:39] <bisectable> timotimo: bisect log: https://gist.github.com/190316c15d4f56d320f9160edd8a6a45

[16:39] <bisectable> timotimo: (2016-03-02) https://github.com/rakudo/rakudo/commit/62ed92a

[16:40] <timotimo> why doesn't it use the exit code? it's clearly different

[16:40] <timotimo> AlexDaniel: halp? :)

[16:41] <hoelzro> it might just be looking at the lower byte of the status

[16:41] <hoelzro> hmm, it would still be 11 then, though...

[16:42] <unmatched}> Is it a P6 or P5 version?

[16:42] <harmil_wk> Signals are routinely masked from exit status. It's common that people ignore signals in exit status unless they're thinking about it.

[16:42] <unmatched}> There's a bug in Proc where signals still end up with .exitcode zero: https://rt.perl.org/Ticket/Display.html?id=128805

[16:42] *** mcmillhj left
[16:43] <TheLemonMan> container_spec is unaligned, probably some code goes noots somewhere or a bad cast happens

[16:51] *** mcmillhj joined
[16:55] *** kjs_ left
[16:56] *** mcmillhj left
[16:56] <_4d47> perl6/doc `make html` fails with pod2onepage, `make html-nohighlight` with type-graph-ComplexStr.svg not found

[16:56] *** zakharyas left
[16:58] <unmatched}> If you uninstall IO::Socket::SSL pod2onepage might work

[16:58] <_4d47> `panda install Pod::To::BigPage` with Expected MAST::Frame

[16:59] * _4d47 is not feeling lucky

[16:59] <unmatched}> Right, you need --force for that

[16:59] <unmatched}> And if you have IO::Socket::SSL installed, you have to remove it

[16:59] <unmatched}> (I'm describing a workaround, I'm not saying that this is an expected thing to do :P)

[17:01] <unmatched}> dafuq

[17:01] <unmatched}> oh

[17:01] <_4d47> unmatched} how do you remove IO::Socket::SSL ? i'm not finding with panda

[17:02] <unmatched}> huggable: uninstall

[17:02] <huggable> unmatched}, nothing found

[17:02] <unmatched}> huggable: uninstall module

[17:02] <huggable> unmatched}, nothing found

[17:02] <unmatched}> huggable: uninstall dist

[17:02] <huggable> unmatched}, nothing found

[17:03] <unmatched}> _4d47: here: https://gist.github.com/niner/b39258032f70c083e57b

[17:03] <unmatched}> You can also use zef; it got an uninstall feature

[17:03] <unmatched}> huggable: uninstall :is: Handy few-liner to uninstall a module: https://gist.github.com/niner/b39258032f70c083e57b

[17:03] <huggable> unmatched}, Added uninstall as Handy few-liner to uninstall a module: https://gist.github.com/niner/b39258032f70c083e57b

[17:05] <AlexDaniel> bisect: good=2015.12 bad=HEAD say ^1000 .grep: -> $n {([+] ^$n .grep: -> $m {$m and $n %% $m}) == $n }

[17:05] <bisectable> AlexDaniel: Exit code is 0 on both starting points (good=2015.12 bad=643c0f9), bisecting by using the output

[17:05] <bisectable> AlexDaniel: bisect log: https://gist.github.com/80154f17271c8f036fc5f0923a1a8d67

[17:05] <bisectable> AlexDaniel: (2016-03-02) https://github.com/rakudo/rakudo/commit/62ed92a

[17:05] <AlexDaniel> commit: releases bad=HEAD say ^1000 .grep: -> $n {([+] ^$n .grep: -> $m {$m and $n %% $m}) == $n }

[17:05] <committable> AlexDaniel: https://gist.github.com/67552f3fa9f2e4aac5e14fc26acada06

[17:05] *** pierre_ joined
[17:05] <_4d47> unmatched}: thx i'm trying that out!

[17:05] <unmatched}> I'm tapping a signal inside a promise and I'm hoping to intercept it, but it keeps telling me I got an unhandled exception. What gives? https://gist.github.com/zoffixznet/096ce71e863a62fc2e4c37138ed4779f

[17:05] <AlexDaniel> commit: releases say ^1000 .grep: -> $n {([+] ^$n .grep: -> $m {$m and $n %% $m}) == $n }

[17:06] <AlexDaniel> oops ;)

[17:06] <committable> AlexDaniel: ¦«2015.10,2015.11,2015.12,2016.02,2016.04,2016.05,2016.06,2016.07,HEAD»: (0)␤|«2016.03»:  «exit signal = SEGV (11)»

[17:06] *** mcmillhj joined
[17:07] <AlexDaniel> committable5 is bugged :P

[17:10] *** ItayAlmog left
[17:10] *** pierre_ left
[17:10] *** ItayAlmog joined
[17:10] <unmatched}> I guess the tap is in another thread :/ I'm trying to kill the start {} once the signal is received

[17:11] *** finanalyst joined
[17:11] *** itaipu joined
[17:14] <unmatched}> :'(

[17:17] <unmatched}> It it possible to kill one thread from another if you use the lower-level bits and pieces or does the same limitation apply, that you can't kill that way?

[17:17] *** zacts left
[17:17] <AlexDaniel> timotimo: 1) it did find the right commit, right? Looks so. 2) it's not so much that the exit code is different, it's the segfault that produces a signal… similar, but different :) There is an open issue for that: https://github.com/perl6/whateverable/issues/14

[17:18] <AlexDaniel> committable: die you bugged piece of sh

[17:18] <committable> AlexDaniel: ¦«die»: Cannot find this revision

[17:18] *** committable left
[17:20] *** MilkmanDan joined
[17:20] *** committable6 joined
[17:20] <AlexDaniel> commit: releases say ^1000 .grep: -> $n {([+] ^$n .grep: -> $m {$m and $n %% $m}) == $n }

[17:20] <committable6> AlexDaniel, ¦«2015.10,2015.11,2015.12,2016.02»: (0)␤¦«2016.03,2016.04,2016.05,2016.06,2016.07,HEAD»:  «exit signal = SIGSEGV (11)»

[17:21] <AlexDaniel> commit: 2016.02..2016.03 say ^1000 .grep: -> $n {([+] ^$n .grep: -> $m {$m and $n %% $m}) == $n }

[17:22] <harmil_wk> Another interesting thing about that code:

[17:22] <harmil_wk> m: say ^214 .grep: -> $n {([+] (1..^$n).grep: -> $m {$m and $n %% $m}) == $n }

[17:22] <camelia> rakudo-moar 643c0f: OUTPUT«(0 6 28)␤»

[17:22] <harmil_wk> m: say ^215 .grep: -> $n {([+] (1..^$n).grep: -> $m {$m and $n %% $m}) == $n }

[17:22] <camelia> rakudo-moar 643c0f: OUTPUT«(0 6 28)␤»

[17:22] <harmil_wk> Oh, interesting. On my box, 215 SEGVs.

[17:22] <TheLemonMan> harmil_wk, try disabling the spesh, the segfault will go away

[17:23] <committable6> AlexDaniel, https://gist.github.com/938583ffc4a1971a6bb7de670d750a6b

[17:24] <AlexDaniel> commit: 62ed92a say ^1000 .grep: -> $n {([+] ^$n .grep: -> $m {$m and $n %% $m}) == $n }

[17:24] <committable6> AlexDaniel, ¦«62ed92a»:  «exit signal = SIGSEGV (11)»

[17:24] <AlexDaniel> commit: 50a4df3 say ^1000 .grep: -> $n {([+] ^$n .grep: -> $m {$m and $n %% $m}) == $n }

[17:24] <committable6> AlexDaniel, ¦«50a4df3»: (0)

[17:25] <AlexDaniel> timotimo: anyway, I can't fix that bug so fast, but see this: https://gist.github.com/Whateverable/938583ffc4a1971a6bb7de670d750a6b ;)

[17:26] <harmil_wk> TheLemonMan: yeah, that "fixes" it. Still, odd that it has such specific breakpoints

[17:27] *** MilkmanDan left
[17:28] <ilmari> huh, ' is allowed in symbols, but only between letters, not at the end :(

[17:28] <ilmari> so you can't have $n and $n'

[17:28] <geekosaur> not that odd, actually. spesh has a history of failing that way

[17:29] *** MilkmanDan joined
[17:33] *** zakharyas joined
[17:35] *** trnh left
[17:39] *** cdg joined
[17:39] *** cdg left
[17:40] *** cdg joined
[17:47] *** kjs_ joined
[17:50] <harmil_wk> ilmari: that's because ' in identifiers is a holdover from Perl 4 where it was equivalent to ::

[17:50] *** trnh joined
[17:50] <harmil_wk> That is, before :: was introduced

[17:50] *** kurahaupo left
[17:53] *** kjs_ left
[17:58] *** itaipu left
[17:59] *** itaipu joined
[18:00] *** brrt joined
[18:03] *** gtodd left
[18:03] *** finanalyst left
[18:03] *** mvorg left
[18:03] *** itaipu left
[18:04] *** itaipu joined
[18:05] <mspo> .u U+00BB

[18:05] <yoleaux> U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK [Pf] (»)

[18:07] *** pierre_ joined
[18:07] <ItayAlmog> m: my $test = my $test2;

[18:07] <camelia> rakudo-moar 643c0f: ( no output )

[18:07] <ItayAlmog> m: my $test = my $test2; say $test;

[18:07] <camelia> rakudo-moar 643c0f: OUTPUT«(Any)␤»

[18:07] <unmatched}> m: my ($a, $b, $c); $a = $b = $c = 42; dd [$a, $b, $c ]

[18:07] <camelia> rakudo-moar 643c0f: OUTPUT«[42, 42, 42]␤»

[18:08] <ItayAlmog> m: my $test; say $test;

[18:08] <camelia> rakudo-moar 643c0f: OUTPUT«(Any)␤»

[18:09] <ugexe> m: 1 R= my $a = 3; say $a

[18:09] <camelia> rakudo-moar 643c0f: OUTPUT«1␤»

[18:09] <unmatched}> :D

[18:10] <ItayAlmog> I will not even ask :)

[18:10] *** itaipu left
[18:10] <unmatched}> R is a meta operator that reverses its operator

[18:10] <unmatched}> m: say (1, 2, 3, 4)

[18:10] <camelia> rakudo-moar 643c0f: OUTPUT«(1 2 3 4)␤»

[18:10] <unmatched}> m: say (1 R, 2 R, 3 R, 4)

[18:10] <camelia> rakudo-moar 643c0f: OUTPUT«(4 3 2 1)␤»

[18:10] *** trnh left
[18:11] <ItayAlmog> so it is some kind of a strange defer, interesting

[18:11] <unmatched}> m: say (1 RRRRRR, 2 RRRR, 3 RR, 4)

[18:11] <camelia> rakudo-moar 92d5e7: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Only identical operators may be list associative; since 'RRRRRR,' and 'RRRR,' differ, they are non-associative and you need to clarify with parentheses␤at <tmp>:1␤------> 3say (1 RRRRRR, 2 RRRR7⏏5, …»

[18:11] *** trnh joined
[18:11] <smls> harmil_wk: I don't think ' in Perl 6 variable names has anything to do with how they were used in Perl 4

[18:12] *** pierre_ left
[18:12] <unmatched}> m: say (1 RRRRRR, 2 RRRRRR, 3 RRRRRR, 4)

[18:12] <camelia> rakudo-moar 92d5e7: OUTPUT«(1 2 3 4)␤»

[18:12] <unmatched}> hah

[18:12] <smls> harmil_wk: I think it was just to make more english words (e.g. contractions) possible as variable names

[18:12] <unmatched}> we have doesn't-hang() in our utility roast subs :)

[18:12] <unmatched}> And I'm very disappointed Test.pm6's isnt isn't named isn't

[18:13] <brrt> cant always get what you want

[18:14] <smls> unmatched}: Test.pm's API is pretty Perl 5-ish, overall.

[18:15] <unmatched}> You can if you want it a lot :)

[18:15] * unmatched} doesn't

[18:16] *** labster joined
[18:19] *** zacts joined
[18:19] *** jeek left
[18:23] *** captain-adequate left
[18:23] *** itaipu joined
[18:24] *** smls left
[18:26] *** zakharyas left
[18:27] *** heatsink left
[18:29] *** n1lp7r left
[18:30] *** captain-adequate joined
[18:33] *** jeek joined
[18:39] *** firstdayonthejob joined
[18:39] <harmil_wk> m: class Reals is Range { method iterator() { -Inf, {fail "Reals are uncountable"} ... Inf }; method Numeric { Inf }; method Str { "ℝ" } }; say Reals.new.perl

[18:39] <camelia> rakudo-moar 92d5e7: OUTPUT«Any..Any␤»

[18:39] <harmil_wk> Am I wrong to think that should be -Inf..Inf?

[18:40] *** cdg left
[18:41] *** Actualeyes left
[18:41] <unmatched}> m: Range, "perl", \()

[18:41] <camelia> rakudo-moar 92d5e7: OUTPUT«WARNINGS for <tmp>:␤Useless use of constant string "perl" in sink context (lines 1, 1)␤»

[18:41] <unmatched}> s: Range, "perl", \()

[18:41] <SourceBaby> unmatched}, Sauce is at https://github.com/rakudo/rakudo/blob/92d5e76/src/core/Mu.pm#L509

[18:41] *** wamba joined
[18:41] *** grondilu left
[18:42] <unmatched}> m: Range.HOW, "name", \()

[18:42] <camelia> rakudo-moar 92d5e7: OUTPUT«WARNINGS for <tmp>:␤Useless use of constant string "name" in sink context (lines 1, 1)␤»

[18:42] *** n1lp7r joined
[18:42] <unmatched}> dammit

[18:42] <unmatched}> s: Range.HOW, "name", \()

[18:42] <SourceBaby> unmatched}, Something's wrong: ␤ERR: Method 'map' not found for invocant of class 'NQPRoutine'␤  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 25␤  in block <unit> at -e line 6␤␤

[18:42] <unmatched}> s (1..5), "perl, \()

[18:43] <unmatched}> s: (1..5), "perl, \()

[18:43] <SourceBaby> unmatched}, Something's wrong: ␤ERR: [31m===[0mSORRY![31m===[0m Error while compiling -e␤Unable to parse expression in double quotes; couldn't find final '"' ␤at -e:7␤------> [32m<BOL>[33m⏏[31m<EOL>[0m␤    expecting any of:␤        double quotes␤        term␤

[18:43] <unmatched}> s: (1..5), "perl", \()

[18:43] <SourceBaby> unmatched}, Sauce is at https://github.com/rakudo/rakudo/blob/92d5e76/src/core/Range.pm#L444

[18:43] <unmatched}> harmil_wk: looks like it's constructed from $!min/$!max and I don't think you're setting that

[18:44] <unmatched}> s: &infix:<..>

[18:44] <SourceBaby> unmatched}, Sauce is at https://github.com/rakudo/rakudo/blob/92d5e76/src/core/Range.pm#L661

[18:44] <harmil_wk> I guess expecting it to infer those from the iterator was silly

[18:44] <harmil_wk> the other way would be more natural

[18:44] *** brrt left
[18:46] <harmil_wk> Wait... how do I set $!min in a subclass?

[18:47] <unmatched}> m: class Reals is Range { method new { nextwith :min(-∞), :max(∞) }; method iterator() { -Inf, {fail "Reals are uncountable"} ... Inf }; method Numeric { Inf }; method Str { "ℝ" } }; say Reals.new.perl

[18:47] <camelia> rakudo-moar 92d5e7: OUTPUT«-Inf..Inf␤»

[18:47] <unmatched}> that's one way

[18:47] <harmil_wk> Oh, that's nice.

[18:49] *** sufrostico left
[18:51] <unmatched}> m: Range.^can('perl').say

[18:51] <camelia> rakudo-moar bc0293: OUTPUT«(perl perl)␤»

[18:51] <unmatched}> m: Range:D.^can('perl').say

[18:51] <camelia> rakudo-moar bc0293: OUTPUT«Method 'can' not found for invocant of class 'Perl6::Metamodel::DefiniteHOW'␤  in block <unit> at <tmp> line 1␤␤»

[18:51] <unmatched}> Seems smileys are kinda iffy

[18:52] *** kjs_ joined
[18:58] *** kyclark joined
[19:01] *** kyclark left
[19:01] *** n1lp7r left
[19:02] *** kjs_ left
[19:04] *** itaipu left
[19:07] *** TEttinger joined
[19:09] *** kyclark joined
[19:12] <kyclark> I've made a module in my "t" (test) directory with a couple of subs I'd like to share.  If I "use lib '.'" everything is fine when I'm /in/ the "t" dir, but if I execute one dir up (e.g., "make test") then it fails.  In Perl 5 I might use FindBin $Bin.

[19:12] *** darutoko left
[19:15] <unmatched}> huggable: FindBin

[19:15] <huggable> unmatched}, nothing found

[19:16] <unmatched}> Damn, looks like she lost a load of factoids during upgrade to IRC::Client v3

[19:16] <unmatched}> huggable: FindBin :is: say $*PROGRAM.dirname.IO.parent.child("lib");

[19:16] <huggable> unmatched}, Added FindBin as say $*PROGRAM.dirname.IO.parent.child("lib");

[19:16] *** setty1 joined
[19:17] *** trnh left
[19:17] *** zacts left
[19:18] *** zacts joined
[19:21] *** zacts left
[19:21] <kyclark> Sorry, I'm confused.  I don't seem to be able to "use lib $*PROGRAM.dirname.IO.parent.child("lib");"

[19:24] *** zengargoyle left
[19:26] <unmatched}> kyclark: it works if you add .Str at the end

[19:27] <unmatched}> kyclark: and you'd might want something other than .child('lib'), if you say they're in 't'

[19:31] <unmatched}> huggable: FindBin :is: use lib $*PROGRAM.dirname.IO.parent.child("lib").Str; # finds lib/ for scripts in bin/ or t/

[19:31] <huggable> unmatched}, Added FindBin as use lib $*PROGRAM.dirname.IO.parent.child("lib").Str; # finds lib/ for scripts in bin/ or t/

[19:33] <unmatched}> $*PROGRAM is the test file filename, .dirname is the directory it's in, .IO.parent gives you parent directory and .child('lib') on that gives you 'lib' inside that directory

[19:33] <unmatched}> And .Str just coerces it to something use lib likes

[19:34] <unmatched}> So $*PROGRAM.dirname.Str may be enough for you

[19:35] <kyclark> Yes, perfect!  Thanks.

[19:37] *** kurahaupo joined
[19:38] <unmatched}> m: say $*PROGRAM.dirname.^name

[19:38] <camelia> rakudo-moar bc0293: OUTPUT«Str␤»

[19:38] <unmatched}> Don't even need the .Str at the end for that

[19:39] *** MilkmanDan left
[19:52] *** mcmillhj left
[19:56] *** kyclark_ joined
[19:59] *** mcmillhj joined
[20:07] *** mcmillhj left
[20:13] *** mcmillhj joined
[20:16] *** cdg joined
[20:16] *** rindolf left
[20:17] <pmurias> TheLemonMan: ok, so once your nqp fix is done I'll write the test

[20:18] *** mcmillhj left
[20:19] *** kyclark_ left
[20:20] *** wamba left
[20:21] <TheLemonMan> pmurias, I've already submitted a PR and have attached some possible test vectors in the GH message

[20:27] *** Ven joined
[20:27] *** Ven left
[20:27] *** Ven joined
[20:28] <Ven> .u ⚯͛

[20:28] <yoleaux> U+035B COMBINING ZIGZAG ABOVE [Mn] (◌͛)

[20:28] <yoleaux> U+26AF UNMARRIED PARTNERSHIP SYMBOL [So] (⚯)

[20:28] <Ven> hi, #perl6.

[20:31] *** wamba joined
[20:32] *** djbkd_ joined
[20:34] *** mcmillhj joined
[20:35] *** djbkd left
[20:36] *** zacts joined
[20:36] *** sno joined
[20:36] *** Ven_ joined
[20:37] *** kurahaupo left
[20:37] <TEttinger> Ven: partners with a lightning bolt?

[20:37] <TEttinger> did you unmarry-partner usain bolt?

[20:39] *** mcmillhj left
[20:39] *** zakharyas joined
[20:39] <masak> this is why emoticons are not enough to convey meaning

[20:43] <TEttinger> ȹ ⌚

[20:48] *** mcmillhj joined
[20:49] <masak> did you just say I have a small watch?!

[20:49] <masak> :P

[20:49] *** Wiertek joined
[20:51] <kyclark> I think I asked the other day, but how do I printf to STDERR?

[20:51] *** zakharyas left
[20:53] *** mcmillhj left
[20:54] <kyclark> Oh, "note" got it

[20:56] *** kjs_ joined
[20:59] <Ven> TEttinger: looks like something from harry potter :)

[21:01] *** skids left
[21:03] <TEttinger> masak: hammer time

[21:03] *** mcmillhj joined
[21:04] *** mvorg joined
[21:06] *** kjs_ left
[21:08] *** kyclark left
[21:15] *** wamba left
[21:19] *** acrussell left
[21:20] <pmurias> Ven: hi

[21:20] <pmurias> TheLemonMan: I'll write tests for that tommorow

[21:24] *** mcmillhj left
[21:24] <masak> TEttinger: can't touch this

[21:26] <TheLemonMan> pmurias, ty! anyway, 'nite #perl6

[21:26] <pmurias> TheLemonMan: the pull request looks good

[21:26] *** TheLemonMan left
[21:26] <_4d47> note "Wayne's".fmt("%s World, It's party time")

[21:28] <Ven> hi pmurias 

[21:28] *** kjs_ joined
[21:30] *** trnh joined
[21:31] *** cpage_ left
[21:32] *** kyclark_ joined
[21:34] *** sufrostico joined
[21:39] <timotimo> oh hey Ven 

[21:39] <timotimo> how's you?

[21:40] <Ven> like a tire, but -ed! how about you?

[21:40] *** kyclark_ left
[21:40] *** sufrostico left
[21:42] *** sufrostico joined
[21:45] <timotimo> yeah, also tired

[21:45] <timotimo> i un-bit-rotted my gtk cairo shooter today

[21:45] <_4d47> is it possible to type constraint return for an Array of Int ?

[21:46] <timotimo> _4d47: yes, but a type constraint for "Array of Int" will only work for "an array that's declared to be an Array of Int", not for "An Array that happens to have only Int in it"

[21:48] *** n1lp7r joined
[21:49] <_4d47> timotimo: oh ok thx

[21:52] <pmurias> Ven: re ECMAScript 6, I think we should be able to support old browsers, maybe with a (small) performance penalty. 

[21:52] <Ven> right, there are tools for that

[21:53] *** Ven_ left
[21:53] <pmurias> also getting things working is more important then supporting old stuff atm ;)

[21:54] <Ven> definitely!

[21:56] *** Girafferson joined
[21:57] *** cpage_ joined
[21:59] <pmurias> Ven: I'll merge the cleanup branch tommorow or on saturday, so reading nqp-js commits should be more pleasant with most of the ugly old hack gone ;)

[22:00] *** ItayAlmog left
[22:03] <pmurias> sleep&

[22:03] *** pmurias left
[22:03] *** zacts left
[22:04] *** Wiertek left
[22:08] *** kyclark_ joined
[22:09] *** KotH left
[22:13] *** KotH joined
[22:18] *** cooper left
[22:18] *** kyclark_ left
[22:18] *** mvorg left
[22:19] *** mvorg joined
[22:22] *** lizmat joined
[22:23] *** skids joined
[22:26] *** sftp left
[22:27] *** AlexDaniel left
[22:28] *** sftp joined
[22:34] *** kurahaupo joined
[22:35] *** firstdayonthejob left
[22:36] *** john51 left
[22:36] *** kjs_ left
[22:37] *** RabidGravy left
[22:39] *** Ven left
[22:39] *** john51 joined
[22:43] *** kjs_ joined
[22:52] *** trnh left
[22:53] *** itaipu joined
[23:00] *** kjs_ left
[23:03] <tailgate> I have an interesting problem https://gist.github.com/ahalbert/1b495ad9facc504db0f7aa9fedc3ebe0 basically, I get the correct output from my function with say but testing with the Test 'is' function for the same result fails with a different output

[23:04] *** kalkin-_ left
[23:05] <timotimo> "is" will do string comparison, say will call .gist and output that

[23:05] <timotimo> that could be a reason why things fail

[23:06] <tailgate> interesting. what cases were in mind for making .gist and Str coercion different functions?

[23:07] <timotimo> gist is for human-readable output and will do things like cut off very long lists

[23:07] <geekosaur> Str preserves as much as possible, gist is what its name implies

[23:11] <tailgate> hmm. I guess it's generating a Seq of 'c' after going through the rest of the array.

[23:11] <tailgate> from calling dd

[23:11] *** labster left
[23:12] <timotimo> that's strange

[23:13] *** labster joined
[23:13] <tailgate> I get (["c"], ["c"], ["c"], ["c"], ["c"], ["c"], ["c"], ["c"], ["c"]).Seq

[23:13] <timotimo> why would it get different results the second time around? it does look like it's getting a fresh start?

[23:13] <tailgate> I think it's getting the same results

[23:14] <timotimo> you're not re-using the result from combinations_with_replacement

[23:14] <timotimo> m: https://gist.github.com/ahalbert/1b495ad9facc504db0f7aa9fedc3ebe0

[23:14] <camelia> rakudo-moar 1b898c: OUTPUT«([a a] [a b] [a c] [b a] [b b] [b c] [c a] [c b] [c c])␤not ok 1 - ␤␤# Failed test at <tmp> line 25␤# expected: 'a a a b a c b a b b b c c a c b c c'␤#      got: 'c c c c c c c c c'␤»

[23:15] <timotimo> m: https://gist.github.com/timo/e02e14a338e9358df1ba3b84d4f184b9

[23:15] <camelia> rakudo-moar 1b898c: OUTPUT«([a a] [a b] [a c] [b a] [b b] [b c] [c a] [c b] [c c])␤not ok 1 - ␤␤# Failed test at <tmp> line 25␤# expected: 'a a a b a c b a b b b c c a c b c c'␤#      got: 'c c c c c c c c c'␤»

[23:15] <timotimo> m: https://gist.github.com/timo/e02e14a338e9358df1ba3b84d4f184b9

[23:15] <camelia> rakudo-moar 1b898c: OUTPUT«([a a] [a b] [a c] [b a] [b b] [b c] [c a] [c b] [c c])␤not ok 1 - ␤␤# Failed test at <tmp> line 25␤# expected: 'a a a b a c b a b b b c c a c b c c'␤#      got: 'c c c c c c c c c'␤»

[23:17] <timotimo> i don't think it has something to do with that, but perhaps scalars are getting overshared?

[23:17] <timotimo> m: https://gist.github.com/timo/e02e14a338e9358df1ba3b84d4f184b9

[23:17] <camelia> rakudo-moar 1b898c: OUTPUT«([a a] [a b] [a c] [b a] [b b] [b c] [c a] [c b] [c c])␤not ok 1 - ␤␤# Failed test at <tmp> line 25␤# expected: 'a a a b a c b a b b b c c a c b c c'␤#      got: 'c c c c c c c c c'␤»

[23:17] <timotimo> grmlb

[23:18] <timotimo> oh

[23:18] <timotimo> m: https://gist.github.com/timo/e02e14a338e9358df1ba3b84d4f184b9

[23:18] <camelia> rakudo-moar 1b898c: OUTPUT«([a a] [a b] [a c] [b a] [b b] [b c] [c a] [c b] [c c])␤not ok 1 - ␤␤# Failed test at <tmp> line 25␤# expected: 'a a a b a c b a b b b c c a c b c c'␤#      got: 'c c c c c c c c c'␤»

[23:18] <timotimo> that's also not it, eh?

[23:19] <timotimo> man, i need to get some sleep \:

[23:19] <timotimo> maybe this night there'll actually be some to be had

[23:27] *** MilkmanDan joined
[23:28] *** kalkin- joined
[23:34] *** MilkmanDan left
[23:38] *** jack_rabbit joined
[23:43] *** bjz_ left
[23:54] *** rkazak joined
[23:56] *** AlexDaniel joined
