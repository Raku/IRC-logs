[00:03] *** vendethiel- left
[00:04] *** Woodi left
[00:08] <tweakism> m: " ".chars

[00:08] <camelia> rakudo-moar 0ad8b3: ( no output )

[00:08] <tweakism> m: say " ".chars

[00:08] <camelia> rakudo-moar 0ad8b3: OUTPUT«1␤»

[00:08] *** rindolf left
[00:11] *** Woodi joined
[00:12] *** Ben_Goldberg joined
[00:13] *** AlexDaniel left
[00:14] *** BenGoldberg left
[00:18] *** virtualsue left
[00:20] <timotimo> i have cake and i have momodora; the day is improving

[00:29] *** edehont joined
[00:32] <Hotkeys> m: say 1...3...-2...0...-5

[00:32] <camelia> rakudo-moar 0ad8b3: OUTPUT«(1 2 3 2 1 0 -1 -2 -1 0 -1 -2 -3 -4 -5)␤»

[00:32] <Hotkeys> I didn't realize you could chain like that

[00:33] <partly_> m: role F {} sub MAIN() does F{}

[00:33] <partly_> m: role F {} sub MAIN() does F{ say "Boo" }

[00:33] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/TVfD6WFzdN␤Strange text after block (missing semicolon or comma?)␤at /tmp/TVfD6WFzdN:1␤------> 3role F {}7⏏5 sub MAIN() does F{}␤    expecting any of:␤        infix␤        infix stopper␤   …»

[00:33] <Hotkeys> probably need a semicolon

[00:33] <Hotkeys> after the role

[00:34] <partly_> ahh thanks

[00:34] <dalek> doc: 9cfebc6 | (Eric de Hont)++ | doc/Type/Array.pod:

[00:34] <dalek> doc: Update Array.pod

[00:34] <dalek> doc: 

[00:34] <dalek> doc: Make the difference for the shape method between normal arrays and arrays with fixed dimensions explicit.

[00:34] <dalek> doc: review: https://github.com/perl6/doc/commit/9cfebc6101

[00:34] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/bNLDndgJiw␤Strange text after block (missing semicolon or comma?)␤at /tmp/bNLDndgJiw:1␤------> 3role F {}7⏏5 sub MAIN() does F{ say "Boo" }␤    expecting any of:␤        infix␤        infix st…»

[00:34] <partly_> m: role F {}; sub MAIN() does F{ say "Boo" }

[00:34] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/E27P3oUJmC␤Autovivifying object closures not yet implemented. Sorry. ␤at /tmp/E27P3oUJmC:1␤------> 3ole F {}; sub MAIN() does F{ say "Boo" }7⏏5<EOL>␤»

[00:34] *** Ben_Goldberg is now known as BenGoldberg

[00:34] <Hotkeys> and also F needs to do something

[00:34] <Hotkeys> er

[00:34] <Hotkeys> m: role F {}; sub MAIN() does F { say "Boo" }

[00:35] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/xedkVHSlBq␤Cannot call trait_mod:<does>(Sub, F); none of these signatures match:␤    (Mu:U $doee, Mu:U $role)␤    (Variable:D $v, Mu:U $role)␤at /tmp/xedkVHSlBq:1␤»

[00:35] <Hotkeys> I don't think you can '

[00:35] <Hotkeys> does' a sub

[00:35] <partly_> Yeah that's the error I'm running into

[00:35] <partly_> m: role F[::Sub] {}; sub MAIN() does F{ say "Boo" }

[00:36] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/mlkS9fBWFA␤Autovivifying object closures not yet implemented. Sorry. ␤at /tmp/mlkS9fBWFA:1␤------> 3:Sub] {}; sub MAIN() does F{ say "Boo" }7⏏5<EOL>␤»

[00:36] <Hotkeys> space after F

[00:36] *** tmch left
[00:36] <partly_> m: role F[::Sub] {}; sub MAIN() does F { say "Boo" }

[00:36] <BenGoldberg> p: role F { };

[00:36] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/W_Aeb8hjgH␤Cannot call trait_mod:<does>(Sub, F); none of these signatures match:␤    (Mu:U $doee, Mu:U $role)␤    (Variable:D $v, Mu:U $role)␤at /tmp/W_Aeb8hjgH:1␤»

[00:37] <BenGoldberg> m: role F { };

[00:37] <camelia> rakudo-moar 0ad8b3: ( no output )

[00:37] <BenGoldberg> m: role F { }; sub nosig does F { };

[00:37] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/UieVzeMEVM␤Cannot call trait_mod:<does>(Sub, F); none of these signatures match:␤    (Mu:U $doee, Mu:U $role)␤    (Variable:D $v, Mu:U $role)␤at /tmp/UieVzeMEVM:1␤»

[00:38] <BenGoldberg> m: role F { }; sub nosig is F { };

[00:38] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/BfxNxc9SVv␤Can't use unknown trait 'is ' in a sub declaration.␤at /tmp/BfxNxc9SVv:1␤    expecting any of:␤        rw raw hidden-from-backtrace hidden-from-USAGE␤        pure default DEPRECATED inlinab…»

[00:39] <partly_> http://doc.perl6.org/language/objects#Parameterized_Roles ← Says that You can use parameter with role F[::Type], but this either seems not to work

[00:39] <partly_> m: role F[Sub] {}; sub MAIN() does F { say "Boo" }

[00:39] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/P3ZeGd2TSp␤Cannot call trait_mod:<does>(Sub, F); none of these signatures match:␤    (Mu:U $doee, Mu:U $role)␤    (Variable:D $v, Mu:U $role)␤at /tmp/P3ZeGd2TSp:1␤»

[00:40] *** spider-mario left
[00:43] *** Ben_Goldberg joined
[00:45] *** BenGoldberg left
[00:46] <partly_> I think the documentation tries to hint, that roles can only be used on classes 

[00:46] *** BenGoldberg_ joined
[00:48] *** Ben_Goldberg left
[00:52] <dalek> ecosystem: 5137513 | (Andy Weidenbaum)++ | META.list:

[00:52] <dalek> ecosystem: Add module Crane

[00:52] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/513751365b

[00:52] <dalek> ecosystem: fe05525 | (Andy Weidenbaum)++ | META.list:

[00:52] <dalek> ecosystem: Merge pull request #165 from atweiden/crane

[00:52] <dalek> ecosystem: 

[00:52] <dalek> ecosystem: Add module Crane

[00:52] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/fe05525d76

[00:52] *** kjs_ left
[00:53] *** kjs_ joined
[00:57] <edehont> Great fun adding something to the documentation: http://doc.perl6.org/routine/shape http://doc.perl6.org/type/Array#method_shape

[00:57] <edehont> Please tell me if something is wrong there. I will correct it immediately.

[01:00] *** kjs_ left
[01:02] *** labster joined
[01:03] <edehont> I have a question. When I Start multiple blocks that want to shift from an array at some point, how do I protect the array from being shifted more than once at the same time? Is there a locking mechanism? 

[01:05] *** BenGoldberg_ is now known as BenGoldberg

[01:07] <TimToady> there's a lock for low-level access, but this probably means you want to use something like a channel instead

[01:11] <edehont> Thats what I want indeed, but I couldn't get it to work. I tried taps, but all the processes received all elements of the array at once.

[01:14] *** BenGoldberg left
[01:16] <TimToady> supplies are not exclusive; a channel will hand out exclusive values

[01:19] <edehont> That's where I went wrong. I will have a closer look at the channels and come back when I still can't get it to work.

[01:21] *** BenGoldberg joined
[01:21] <edehont> An example would still be appreciated, however :-)

[01:27] <edehont> My daily reboot is long overdue. CU! o/

[01:33] <timotimo> edenc: you could have used OO::Monitors from the ecosystem for this task

[01:33] <timotimo> but using a Channel instead of an array that you pop from sounds like a better fit

[01:36] <edehont> timotimo: So, a Channel is not something I can use to wrap around an array?

[01:37] *** BenGoldberg left
[01:39] *** BenGoldberg joined
[01:39] *** pmurias left
[01:40] <geekosaur> you could think of a Channel as inter-thread IPC

[01:40] <geekosaur> you would not wrap it around anything. in theory you could pass the array through the Channel, but that's usually not making sensible use of IPC.

[01:41] *** BenGoldberg left
[01:42] *** BenGoldberg joined
[01:44] <edehont> geekosaur: I feel like someone with a hammer, looking for nails. I really have to go to sleep now. (2:43) I will look into the channels tomorrow.

[01:46] <timotimo> gnite :)

[01:46] <edehont> Bye!

[01:47] *** edehont left
[01:47] *** labster left
[01:48] *** themonkeybob11 joined
[01:49] *** mr_ron joined
[01:49] *** cdg left
[01:53] *** themonkeybob11 left
[01:53] <mr_ron> m: my @a; my $b = Buf.new(@a)

[01:54] <camelia> rakudo-moar 0ad8b3: OUTPUT«This type does not support elems␤  in any  at gen/moar/m-Metamodel.nqp line 1723␤  in block <unit> at /tmp/NtgXHRtYbO line 1␤␤»

[01:55] <mr_ron> That's the new Base64 failure

[01:55] <mr_ron> m: my uint8 @a; my $b = Buf.new(@a)

[01:55] <camelia> rakudo-moar 0ad8b3: ( no output )

[01:55] <mr_ron> likely fix ... working on it ...

[01:59] <mr_ron> s/fix/workaround/

[02:13] *** cdg joined
[02:14] <ugexe> m: sub foo(Blob $x) { say "OK"; }; foo("".encode); # s/Blob.new($str.ords)/$str.encode/ seems to work

[02:14] <camelia> rakudo-moar 0ad8b3: OUTPUT«OK␤»

[02:14] *** autogen is now known as aleogen

[02:19] *** partly__ joined
[02:19] <ugexe> oops thats encode, not decode :x

[02:19] <mr_ron> I noticed - failure is on decode ...

[02:20] *** wamba left
[02:20] *** FROGGS left
[02:23] *** partly_ left
[02:24] *** tadzik left
[02:24] <ugexe> ah its MIME::Base64

[02:24] *** M-tadzik joined
[02:34] *** FROGGS joined
[02:37] *** cdg left
[02:37] *** cdg joined
[02:38] *** telex left
[02:40] *** telex joined
[02:40] *** cdg_ joined
[02:42] *** cdg left
[02:45] *** ilbot3 left
[02:47] *** ilbot3 joined
[02:56] *** BenGoldberg left
[02:57] *** BenGoldberg joined
[02:58] *** molaf_ joined
[03:00] *** Ben_Goldberg joined
[03:02] *** BenGoldberg left
[03:02] *** molaf__ left
[03:09] *** cdg_ left
[03:10] <mr_ron> m: my @a = (); my $b = Buf.new(@a);  say $b.perl; my @a1; my $b1 = Buf.new(@a1)

[03:10] <camelia> rakudo-moar 0ad8b3: OUTPUT«Buf.new()␤This type does not support elems␤  in any  at gen/moar/m-Metamodel.nqp line 1723␤  in block <unit> at /tmp/Gl7lWoGswW line 1␤␤»

[03:10] *** kid511 joined
[03:11] *** kid51 left
[03:13] *** idiosyncrat_ left
[03:14] *** Ben_Goldberg left
[03:15] *** Ben_Goldberg joined
[03:21] *** maybekoo2 left
[03:42] *** skids joined
[03:43] *** Ben_Goldberg left
[03:45] *** Ben_Goldberg joined
[03:45] *** Actualeyes left
[03:48] *** noganex joined
[03:50] *** Actualeyes joined
[03:51] <ugexe> m: my @a; my $b = Buf.new(|@a); say $b.perl

[03:51] <camelia> rakudo-moar 0ad8b3: OUTPUT«Buf.new()␤»

[03:51] *** noganex_ left
[03:57] *** kid511 left
[04:07] *** Ben_Goldberg left
[04:08] *** Ben_Goldberg joined
[04:10] *** cdg joined
[04:11] *** Ben_Goldberg left
[04:12] *** Ben_Goldberg joined
[04:15] *** themonkeybob11 joined
[04:17] *** BenGoldberg joined
[04:18] *** cdg left
[04:19] *** Ben_Goldberg left
[04:20] *** themonkeybob11 left
[04:20] *** Ben_Goldberg joined
[04:22] *** BenGoldberg_ joined
[04:23] *** BenGoldberg left
[04:25] *** Ben_Goldberg left
[04:27] *** mr_ron left
[04:28] *** BenGoldberg_ left
[04:29] *** BenGoldberg_ joined
[04:32] *** Ben_Goldberg joined
[04:34] *** BenGoldberg_ left
[04:42] *** Ben_Goldberg left
[04:59] *** khw left
[05:13] *** labster joined
[05:19] *** themonkeybob11 joined
[05:27] *** skids left
[05:27] *** themonkeybob11 left
[05:38] *** Cabanossi left
[05:42] *** Cabanossi joined
[05:44] <dalek> doc: ecba519 | LLFourn++ | doc/Language/5to6-perlvar.pod:

[05:44] <dalek> doc: 5to6: Gave examples of how @INC and %INC in p6

[05:44] <dalek> doc: 

[05:44] <dalek> doc: or the closest p6 equivalent at least.

[05:44] <dalek> doc: review: https://github.com/perl6/doc/commit/ecba519927

[05:45] *** themonkeybob11 joined
[05:51] *** themonkeybob11 left
[05:55] *** themonkeybob11 joined
[05:56] *** vendethiel joined
[06:00] *** themonkeybob11 left
[06:12] *** idiosyncrat_ joined
[06:19] *** vendethiel left
[06:25] *** idiosyncrat_ left
[06:28] *** themonkeybob11 joined
[06:38] *** pierrot left
[06:42] *** vendethiel joined
[06:43] *** darutoko joined
[06:52] *** domidumont joined
[06:52] *** domidumont left
[06:53] *** domidumont joined
[06:58] *** domidumont left
[06:59] *** domidumont joined
[07:03] *** vendethiel left
[07:04] <kaare_> Any NativeCall supermen present?

[07:37] *** cdg joined
[07:38] *** _nadim joined
[07:39] *** CIAvash joined
[07:41] *** grassass joined
[07:42] *** cdg left
[07:52] *** tmch joined
[08:09] *** jjido joined
[08:09] *** CIAvash left
[08:17] *** zpmorgan left
[08:27] *** firstdayonthejob joined
[08:29] *** CIAvash joined
[08:34] *** Laurent_R joined
[08:35] *** domidumont left
[08:46] *** hcit joined
[08:52] *** labster left
[08:54] *** labster joined
[08:56] *** RabidGravy joined
[08:57] <dalek> rakudo/nom: a586b20 | lizmat++ | src/core/Parameter.pm:

[08:57] <dalek> rakudo/nom: Streamline Parameter.ACCEPTS

[08:57] <dalek> rakudo/nom: 

[08:57] <dalek> rakudo/nom: Improves from a few % (for simple :(Int).params[0]) to 50x for

[08:57] <dalek> rakudo/nom: something like :(:a(:b(:c($x))) (Str $f, Str $k)).params[0]

[08:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a586b209d4

[08:58] *** lizmat joined
[08:58] <lizmat> good *, #perl6!

[08:59] <dalek> ecosystem: 28512e7 | okaoka++ | META.list:

[08:59] <dalek> ecosystem: Add Algorithm::KdTree to ecosystem

[08:59] <dalek> ecosystem: 

[08:59] <dalek> ecosystem: See https://github.com/okaoka/p6-Algorithm-KdTree

[08:59] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/28512e7da0

[08:59] <dalek> ecosystem: 672bb20 | RabidGravy++ | META.list:

[08:59] <dalek> ecosystem: Merge pull request #166 from okaoka/add-kdtree

[08:59] <dalek> ecosystem: 

[08:59] <dalek> ecosystem: Add Algorithm::KdTree to ecosystem

[08:59] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/672bb20131

[09:03] <llfourn> my commit to docs seems to have caused a segfault lol

[09:04] <llfourn> https://travis-ci.org/perl6/doc

[09:05] *** lizmat left
[09:07] <llfourn> (trying again now)

[09:18] *** lizmat joined
[09:19] *** lizmat left
[09:23] <_nadim> someone can enlighten me  here?  

[09:23] <_nadim> ===SORRY!=== Error while compiling /home/lab/devel/devel/perl_modules/P6-Data-Dump-Tree/42_type_regexp.t

[09:23] <_nadim> Only identical operators may be list associative; since 'does' and 'does' differ, they are non-associative and you need to clarify with parentheses

[09:23] <llfourn> golf?

[09:23] *** vendethiel joined
[09:25] <_nadim> sure,  my $d = Data::Dump::Tree.new does DDTR::MatchDetails does DDTR::PerlString ;

[09:26] <RabidGravy> no, golf is

[09:26] *** avenj left
[09:27] <RabidGravy> m: class F { };  role G { }; role H { };  my $f = F.new does H does G;

[09:27] *** maybekoo2 joined
[09:28] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/myHncVJ05i␤Only identical operators may be list associative; since 'does' and 'does' differ, they are non-associative and you need to clarify with parentheses␤at /tmp/myHncVJ05i:1␤------> 3G { }; role H …»

[09:28] <llfourn> RabidGravy++ # that's some nice golf

[09:28] <llfourn> m: class F { };  role G { }; role H { };  my $f = (F.new does H) does G;

[09:28] <camelia> rakudo-moar 0ad8b3: ( no output )

[09:29] <llfourn> _nadim: ^^

[09:29] <RabidGravy> yeah

[09:29] <llfourn> m: class F { };  role G { }; role H { };  my $f = (F but H,G).new

[09:29] <_nadim> well putting the parenthesis was prety obvious and listed in the error message, what I asked fr what enlightenment, IE, why.

[09:29] <camelia> rakudo-moar 0ad8b3: ( no output )

[09:30] <llfourn> m: class F { };  role G { }; role H { };  my $f = (F but H,G).new.perl.say

[09:30] <camelia> rakudo-moar 0ad8b3: OUTPUT«()␤»

[09:30] <llfourn> oops :P

[09:30] *** avenj joined
[09:30] <RabidGravy> the does doesn't return the thing so it isn't list associative

[09:30] <RabidGravy> afaik

[09:31] <_nadim> Ah, makes sense, thank you.

[09:31] <llfourn> m: class F { };  role G { }; role H { };  my $f = F but H,G; say $f.^name;

[09:31] <camelia> rakudo-moar 0ad8b3: OUTPUT«F+{H}␤»

[09:31] <llfourn> camelia slow today?

[09:31] <RabidGravy> since yesterday

[09:32] <llfourn> m: class F { };  role G { }; role H { };  my $f = F but H but G; say $f.^name;

[09:32] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/DTfPanXbM9␤Only identical operators may be list associative; since 'but' and 'but' differ, they are non-associative and you need to clarify with parentheses␤at /tmp/DTfPanXbM9:1␤------> 3role G { }; role…»

[09:32] <llfourn> m: class F { };  role G { }; role H { };  my $f = F but (H but G); say $f.^name;

[09:32] <camelia> rakudo-moar 0ad8b3: OUTPUT«Method 'mixin' not found for invocant of class 'Perl6::Metamodel::ParametricRoleGroupHOW'␤  in block <unit> at /tmp/qfdxknjRVy line 1␤␤»

[09:33] <llfourn> m: class F { };  role G { }; role H { };  my $f = (F but H) but G; say $f.^name;

[09:33] <camelia> rakudo-moar 0ad8b3: OUTPUT«F+{H}+{G}␤»

[09:33] <_nadim> I've added a new method that takes a does list. cheating a bit till I understood, well someone explained, why.

[09:34] <llfourn> _nadim: you can just do .^mixin

[09:34] <llfourn> m: class F { };  role G { }; role H { };  my $f = F.^mixin(H,G).new; say $f.^name;

[09:34] <camelia> rakudo-moar 0ad8b3: OUTPUT«F+{H,G}␤»

[09:35] <llfourn> m: class F { };  role G { }; role H { };  my $f = F.new does H,G; say $f.^name;

[09:35] <camelia> rakudo-moar 0ad8b3: OUTPUT«F+{H}␤»

[09:35] <llfourn> m: class F { };  role G { }; role H { };  my $f = F.new does (H,G); say $f.^name;

[09:35] <camelia> rakudo-moar 0ad8b3: OUTPUT«F+{H,G}␤»

[09:35] <_nadim> llfourn: nice!

[09:35] <llfourn> oh and that works, does can take a list

[09:36] <_nadim> even nicer IMO

[09:38] *** lizmat joined
[09:38] *** sortiz joined
[09:39] <sortiz> \o #perl6

[09:40] *** jjido left
[09:40] <lizmat> sortiz o/

[09:41] <dalek> DBIish: 996042f | (Salvador Ortiz)++ | lib/DBDish/ (4 files):

[09:41] <dalek> DBIish: Better Statement execution handling

[09:41] <dalek> DBIish: 

[09:41] <dalek> DBIish: - Add .Executed and .Finished methods

[09:41] <dalek> DBIish: - Cleaner rows affected reporting

[09:41] <dalek> DBIish: - More info on error reports

[09:41] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/996042fa8d

[09:41] <dalek> DBIish: 6df5b22 | (Salvador Ortiz)++ | lib/DBDish/Pg/Native.pm6:

[09:41] <dalek> DBIish: Pg: Export constants, Str (not str) to up level

[09:41] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/6df5b22bff

[09:41] <dalek> DBIish: c1d1ac2 | (Salvador Ortiz)++ | lib/DBDish/StatementHandle.pm6:

[09:41] <dalek> DBIish: Factorize StatementHandle.allrows as multi methods

[09:41] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/c1d1ac22fe

[09:41] <dalek> DBIish: a692de8 | (Salvador Ortiz)++ | / (6 files):

[09:41] <dalek> DBIish: mysql: Reworked internals, now with native methods.

[09:41] <dalek> DBIish: 

[09:41] <dalek> DBIish: Add Bool :Prefetch (default True) to `.prepare` for select data read mode

[09:41] <dalek> DBIish:   This switch between `mysql_store_result` and `mysql_use_result`,

[09:41] <dalek> DBIish:   see the C API for pros and cons.

[09:41] <dalek> DBIish: Now handles columns with Blob (binary data) type. Closes #10, our oldest.

[09:41] <dalek> DBIish:   See `t/26-mysql-blob.t` for usage details.

[09:41] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/a692de805c

[09:41] <dalek> DBIish: 782a899 | (Salvador Ortiz)++ | lib/DBIish/CommonTesting.pm6:

[09:41] <dalek> DBIish: Updated common test suite, testing new features

[09:41] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/782a8990d6

[09:41] *** rindolf joined
[09:42] *** maybekoo2 left
[09:44] <dalek> rakudo/nom: 7fab8e7 | lizmat++ | src/core/Buf.pm:

[09:44] <dalek> rakudo/nom: Fix problem with Buf.new(my @a)

[09:44] <dalek> rakudo/nom: 

[09:44] <dalek> rakudo/nom: Spotted by Ronald Schmidt

[09:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7fab8e7379

[09:45] *** spider-mario joined
[09:49] <dalek> roast: b2ac729 | lizmat++ | S03-operators/buf.t:

[09:49] <dalek> roast: Add tests for Blob|Buf.new(my @a)

[09:49] <dalek> roast: review: https://github.com/perl6/roast/commit/b2ac72964d

[09:49] <lizmat> .oO( we need more tests )

[09:54] <lizmat> .tell jnthn I'm a bit confused as to the meaning of Signature.ACCEPTS

[09:54] <yoleaux> lizmat: I'll pass your message to jnthn.

[09:55] * llfourn is interested in the subject of Signature.ACCEPTS

[09:55] <lizmat> .tell jnthn as it seems to include a check on "returns"

[09:55] <yoleaux> lizmat: I'll pass your message to jnthn.

[09:55] <lizmat> llfourn: how so?

[09:55] <llfourn> lizmat: well we have this feature of role requiring multi methods

[09:55] <lizmat> I'm about to refactor it, but I'm unsure as to what it should exactly do?

[09:56] <llfourn> but it is buggy

[09:56] <lizmat> yeah, but that doesn't use Signature.ACCEPTS (anymore)

[09:56] <llfourn> lizmat: yes but I think it should

[09:56] <lizmat> llfourn: it still is??

[09:56] <lizmat> it's still buggy ???

[09:56] <llfourn> I think that if we get Signature.ACCEPTS right a lot of things could fall into place

[09:56] *** jjido joined
[09:56] <llfourn> yes

[09:56] *** ChoHag_ is now known as ChoHag

[09:56] <lizmat> is there a ticket I should check?

[09:57] <llfourn> https://rt.perl.org/Public/Bug/Display.html?id=127303

[09:57] <llfourn> because it doesn't use ACCEPTS it uses string comparisions which don't work out when comparing signatures

[09:57] * lizmat checks

[09:58] <llfourn> I also think that if a role requires multi foo(Int) { }, you should be able to satisfy that requirement with multi foo (Real) { } etc

[09:58] *** kjs_ joined
[09:59] <llfourn> I haven't thought it out fully but I think if we re-imagined role requiring methods with stubs to check Signature.ACCEPTS to see if it has been implemented in general it could be an amazing feature.

[10:00] <lizmat> ok, that makes sense..  I'll be looking at resolving that ticket now

[10:00] <partly__> So i played around with Exceptions yesterday/today. I added a var RAKUDO_ONLY_ROBOTS which when set will print errors in format %f:%l,%c→%m

[10:01] <llfourn> m: role R { method foo (Int) { ... } }; class A does R { method foo(Str) { } } # IMO this should fail

[10:01] <camelia> rakudo-moar 0ad8b3: ( no output )

[10:01] <llfourn> lizmat: it depends if we want to take role-as-interface specification seriously or not

[10:01] <partly__> Currently only X::Comp::Exceptions are printed out like this, but I though about extending it to all Exceptions, may be with a role. Do you think it's a good idea?

[10:02] <lizmat> partly__: I like the idea, but fail to see how that would easily generalize

[10:03] <llfourn> partly__: an idea, we have augment"

[10:03] <llfourn> partly__: maybe you can make the changes in a module

[10:04] <partly__> lizmat: well the role offer just a proto sub which needed to be implemented by an exception if it wants to have errorformat compatible errors

[10:04] <partly__> s/offer/offers/g

[10:04] <llfourn> do augment Exception { }, and somehow get it all to go into an environment variable and then we can see how well the idea works in practice.

[10:04] <lizmat> ah, ok, like that...  hhmmm...

[10:05] <lizmat> sounds like a plan I guess: not sure what jnthn / TimToady would think about it

[10:05] <RabidGravy> I'm actually failing to find a use case that isn;t already catered for by using specific exception types, but that's me

[10:06] <partly__> RabidGravy: There whole error printing logic is all over the place. Just the ===SORRY

[10:06] <partly__> .. just the ===SORRY!=== stuff is duplicated at least 3 times

[10:07] <partly__> Every exception besides the X::Comp exception have an own logic how to construct the error message (which i think makes the more readable for humans). It's hard do create one method which just reformats the .gist/.message returns

[10:08] <llfourn> m: use MONKEY-TYPING; role R { method do-something { "win".say } }; BEGIN augment class X::AdHoc does R { }; try { die "foo" }; say $!.do-something

[10:08] <partly__> But augment may be a good alternative. 

[10:08] <camelia> rakudo-moar 0ad8b3: OUTPUT«win␤True␤»

[10:09] <llfourn> Though the above doesn't work if you do augment Exception so maybe it's not a good idea.

[10:09] <llfourn> (I think it's a bug)

[10:10] <partly__> m: use MONKEY-TYPING; augment class Exception { method f() { } }; try { die "foo" }; say $!.f();

[10:10] <camelia> rakudo-moar 0ad8b3: OUTPUT«Method 'f' not found for invocant of class 'X::AdHoc'␤  in block <unit> at /tmp/_ymMJfFOZQ line 1␤␤»

[10:10] <llfourn> yeah :\

[10:11] <llfourn> it seems I RT'd something similar RT #127520

[10:11] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127520

[10:11] *** kjs_ left
[10:12] <partly__> Also why is Method not a compile time exception?

[10:13] <llfourn> partly__: because you can add methods at runtime

[10:13] <partly__> Because it's not a descendant of X::Comp it does not have a linenumber and file (which is pretty helpfull)

[10:13] <llfourn> hmm it should still have those I would have though?

[10:13] <partly__> llfourn: → and this methods would not have a line number 

[10:14] <partly__> makes sense

[10:14] <llfourn> or at least when it's thrown you get a line number?

[10:14] <llfourn> anyway I need to learn more about exceptions

[10:14] <llfourn> partly__++ for looking into improving them :)

[10:14] <partly__> llfourn: yeah when thrown, make sense

[10:15] <llfourn> food &

[10:15] <partly__> I kind of trying that, but it's hard to completely understand where what is thrown and initialized.

[10:16] <partly__> Another question. Given that I use rakudobrew and I have a cloned git repository of rakudo I'm working on, how do I command rakudobrew to build the rakudo version in a specified dir and install it?

[10:17] <partly__> Is it even possible to install a custom version with rakudobrew if you do not maintain an official fork?

[10:17] *** araujo_ left
[10:18] <[Tux]> test            22.254

[10:18] <[Tux]> test-t          12.638

[10:18] <[Tux]> csv-parser      52.116

[10:19] *** chienjo joined
[10:20] *** chienjo left
[10:28] <Woodi> hi #perl6 :)

[10:29] <Woodi> more WordPress fun: http://news.softpedia.com/news/popular-wordpress-plugin-comes-with-a-backdoor-steals-site-admin-credentials-501383.shtml

[10:39] <nine> kaare_: what do you need?

[10:46] *** lizmat left
[10:48] *** kjs_ joined
[10:48] *** tochjammer joined
[10:48] *** xiaomiao joined
[10:50] *** labster left
[10:52] *** TEttinger left
[10:52] <partly__> Is there some default short cut for pushing something in an array? I.e: @a ← "foo"

[10:53] <partly__> (besides just push) 

[10:56] <llfourn> partly__: .append

[10:58] <llfourn> oh you want it short. No.

[10:59] <llfourn> m:  my @a = <one two three>; @a[*] = "four"; say @a.perl

[10:59] <camelia> rakudo-moar 0ad8b3: OUTPUT«["four", Mu, Mu]␤»

[10:59] <llfourn> m:  my @a = <one two three>; @a[*+0] = "four"; say @a.perl

[11:00] <camelia> rakudo-moar 0ad8b3: OUTPUT«["one", "two", "three", "four"]␤»

[11:00] <llfourn> m:  my @a = <one two three>; @a[+*] = "four"; say @a.perl

[11:00] <RabidGravy> just what I was going to say

[11:00] <camelia> rakudo-moar 0ad8b3: OUTPUT«["one", "two", "three", "four"]␤»

[11:01] <llfourn> i'd stick with @a.push: "foo", that way is almost as bad as php $a[] = "foo" # if I remember php correctly

[11:03] <llfourn> what is the first one trying to do anyway?

[11:03] <llfourn> m:  my @a = <one two three>; @a[*] = <four five six>; @a.perl.say

[11:03] <camelia> rakudo-moar 0ad8b3: OUTPUT«["four", "five", "six"]␤»

[11:04] <llfourn> m:  my @a = <one two three>; @a[^*] = <four five six>; @a.perl.say

[11:04] <camelia> rakudo-moar 0ad8b3: OUTPUT«["four", "five", "six"]␤»

[11:04] *** RabidGravy left
[11:04] <llfourn> to me it makes more sense that * defaults to .elems rather than doing the same thing as ^*.

[11:05] <CIAvash> m: my @a = <one two three>; "four" ==> @a; say @a.perl

[11:05] *** ssm joined
[11:05] <camelia> rakudo-moar 0ad8b3: OUTPUT«["one", "two", "three", "four"]␤»

[11:05] * llfourn stands corrected

[11:06] <llfourn> m:  my @a = <one two three>; @a <== "four"; say @a.perl;

[11:06] <camelia> rakudo-moar 0ad8b3: OUTPUT«["one", "two", "three", "four"]␤»

[11:06] <llfourn> m: @a ← "foo"

[11:07] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/_tTiSZQyWi␤Variable '@a' is not declared␤at /tmp/_tTiSZQyWi:1␤------> 3<BOL>7⏏5@a ← "foo"␤»

[11:07] <llfourn> m:  my @a = <one two three>; @a ← "four"; say @a.perl;

[11:07] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/5VtNvtzVK9␤Confused␤at /tmp/5VtNvtzVK9:1␤------> 3my @a = <one two three>; @a7⏏5 ← "four"; say @a.perl;␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤  …»

[11:08] *** AlexDaniel joined
[11:08] <AlexDaniel> llfourn: hmm what would be the unicode equivalent of ==> and <== ?

[11:09] <llfourn> AlexDaniel: is ← being used for anything?

[11:09] <AlexDaniel> llfourn: no https://gist.github.com/AlexDaniel/c89bd2786f9b63f31e4c

[11:09] <llfourn> this thing? ⟸

[11:10] <llfourn> AlexDaniel: ooh nice

[11:10] <llfourn> AlexDaniel++

[11:10] <AlexDaniel> llfourn: ⟸ is cool but how is that going to look like in a fixed-width font, hmm…

[11:11] <llfourn> I think you just answered that question :P

[11:11] *** kjs_ left
[11:11] <llfourn> ⇐ # shorter

[11:11] <partly__> llfourn: thanks for the hint with <==

[11:12] <llfourn> that was CIAvash++ but no problem :)

[11:12] <partly__> CIAvash :)

[11:12] <CIAvash> :)

[11:12] <AlexDaniel> llfourn: ⇒ would probably be =>. So ⇐ is probably not good enough

[11:12] <AlexDaniel> ⤆ ⤇ maybe

[11:12] *** kjs_ joined
[11:13] <llfourn> ⬅ bolder?

[11:13] <AlexDaniel> :/

[11:14] <llfourn> :D ⟽   will stop making suggestions

[11:16] <llfourn> I seem to remember there being some conterversy about ==> and <==

[11:16] <partly__> Well if you really want to add a unicode sign for that i would gow with ⇐, because  you can enter it in vim with digraphs

[11:16] <AlexDaniel> partly__: uh, but fat arrow?

[11:16] <AlexDaniel> partly__: =>

[11:16] <AlexDaniel> m: say 42 => 69

[11:16] <camelia> rakudo-moar 0ad8b3: OUTPUT«42 => 69␤»

[11:17] <partly__> ohh right

[11:17] <llfourn> ➧ # fat arrow

[11:18] <partly__> I can't enter  ⟸ with COMPOSE or digraphs afaik. At least I find only the short DOUBLE ARROW

[11:19] <AlexDaniel> partly__: well, just because you can't enter some character doesn't mean that we can't use it :)

[11:19] <AlexDaniel> (go fix your tools!)

[11:20] <partly__> Uhh don't get me started on Xkb and stuff :-O

[11:22] <dalek> Inline-Perl5: 7906dce | (Stefan Seifert)++ | / (5 files):

[11:22] <dalek> Inline-Perl5: Fix calling inherited package methods of Perl 5 packages

[11:22] <dalek> Inline-Perl5: 

[11:22] <dalek> Inline-Perl5: Post-GLR changes broke Perl5Package's FALLBACK which is used when calling

[11:22] <dalek> Inline-Perl5: inherited package methods. Need to use slurpy arguments now.

[11:22] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/7906dce0ff

[11:22] <partly__> There is no difference between ? and so, is there?

[11:22] <llfourn> partly__: they both call .so afaik

[11:22] <partly__> thanks

[11:24] *** jjido left
[11:28] <AlexDaniel> m: say so ?.so

[11:28] <camelia> rakudo-moar 0ad8b3: OUTPUT«False␤»

[11:30] <AlexDaniel> m: say ? ? ? ? .WHAT # WAT? :)

[11:31] <camelia> rakudo-moar 0ad8b3: OUTPUT«False␤»

[11:31] <llfourn> m: say ?!?!?! Cool

[11:31] <camelia> rakudo-moar 0ad8b3: OUTPUT«True␤»

[11:32] <[Tux]> test            22.599

[11:32] <[Tux]> test-t          12.951

[11:32] <[Tux]> csv-parser      54.036

[11:32] <[Tux]> (rebuilt from scratch)

[11:32] <[Tux]> seems to be slower again

[11:33] <AlexDaniel> llfourn: yeah, that's even better

[11:33] <llfourn> .tell lizmat btw RT #127444 is about Signature.ACCEPTS. Wrt to what it's meant to do, I thought that it A.ACCEPTS(B) should return true if B accepts a subset of A's parameters. ie every :(Real $b) ~~ :(Int $a) # True 

[11:33] <yoleaux> llfourn: I'll pass your message to lizmat.

[11:33] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127444

[11:33] <AlexDaniel> m: say +?!~-?+~!?+!+~? Cool

[11:33] <llfourn> |Tux|: nooo getting slower :P

[11:34] <camelia> rakudo-moar 0ad8b3: OUTPUT«0␤»

[11:34] <llfourn> although I don't think that's what's causing camelia to be so slow

[11:36] <AlexDaniel> camelia: stop mining bitcoins!

[11:38] <AlexDaniel> m: my %h; %h <== ‘hi’

[11:38] <camelia> rakudo-moar 0ad8b3: OUTPUT«Trailing item in Hash.append  in block <unit> at /tmp/WVUbzMjWFt line 1␤»

[11:39] <AlexDaniel> m: my $l; $l <== ‘foo’, ‘bar’; say $l

[11:39] <camelia> rakudo-moar 0ad8b3: OUTPUT«[foo bar]␤»

[11:39] *** M-tadzik is now known as tadzik

[11:42] *** jjido joined
[11:43] *** Skarsnik joined
[11:45] *** tochjammer left
[11:47] *** lizmat joined
[11:49] <llfourn> I have a sad panda story

[11:50] <llfourn> I used panda --prefix=~/tmp/somewhere install blah

[11:50] <llfourn> which actually created a dir named ~

[11:50] <llfourn> then I did rm -rf ~ to fix my mistake

[11:50] <vendethiel> yes, that's correct

[11:50] <vendethiel> oh

[11:50] <vendethiel> oops.

[11:50] <llfourn> it's ok because apparently I have so much crap in ~ that nothing I care about got deleted

[11:51] <llfourn> ofc I understand why that happened in retrospect

[11:52] <vendethiel> you'd like panda to warn if $prefix.starts-with('~')?

[11:52] <vendethiel> (and abort)

[11:52] <llfourn> I think that's probably a good idea

[11:53] *** firstdayonthejob left
[11:56] *** firstdayonthejob joined
[11:58] <timotimo> in general, i think it'd be cool if we did the proper thing with paths in env vars that (may?) have variable names in them and the ~

[11:58] *** RabidGravy joined
[11:59] <llfourn> m: say $*HOME

[11:59] <k-man> always prefix things with ./~  to ensure it gets the file not the glob is what I was tought... but would it work in that instance I'm not sure

[11:59] <camelia> rakudo-moar 0ad8b3: OUTPUT«"/home/camelia".IO␤»

[11:59] <kaare_> nine: Oh, I really want to use the select(2) system call.

[11:59] <llfourn> k-man: o/ I certainly agree :)

[12:00] <k-man> :)

[12:00] <kaare_> But it's not in the 5 -> 6 migration path, so I was looking at the POSIX module, trying to see how to implement it.

[12:00] <llfourn> k-man: It would have worked. rm -rf ./~ would have deleted the right thing

[12:00] <k-man> ls: ./~: No such file or directory   so i guess it would work

[12:00] <k-man> yeah

[12:01] <RabidGravy> kaare_, strangely I made a noddy binding to select just the other day to test something, it works

[12:01] <kaare_> RabidGravy: OK, can you share some code?

[12:02] <RabidGravy> depends on what you want to do with it as to whether it's useful to you

[12:03] <kaare_> I would call it. Any other purposes available?

[12:04] <llfourn> ah I seem I *did* delete my rakudobrew and panda installations so at least the culprit was punished.

[12:04] *** wamba joined
[12:04] <RabidGravy> well I was going to share the code until you were sarcastic

[12:04] *** xiaomiao left
[12:04] <RabidGravy> ;-p

[12:05] <kaare_> ok, sorry, sorry!

[12:05] <kaare_> Being sarcastic would be something like "I' like to serve it on a bed of Jerusalem Artichokes" or something ;-)

[12:05] <RabidGravy> I only needed to test for the "no FDs just for the waiting side effect"

[12:06] <RabidGravy> so if you want to use it to wait for the file handles then you will have to implement the making the FD sets yourself

[12:06] <kaare_> No, I know very little Perl 6, almost no c, and absolutely nothing about the system calls. So it's a bit challenging

[12:06] <RabidGravy> https://gist.github.com/jonathanstowe/23a9bb99630fef8c8588

[12:07] <RabidGravy> well, you're stuffed then

[12:07] *** xiaomiao joined
[12:08] <kaare_> Actually, I'm sure I can use that to get some actual play started. Thanks.

[12:09] <RabidGravy> the hard bit is implementing the FD_SET macro

[12:10] <kaare_> Is that what is done with vec() in Perl 5?

[12:11] *** spider-mario left
[12:11] <RabidGravy> er possibly

[12:11] <RabidGravy> think I've used vec once in twenty years

[12:11] *** spider-mario joined
[12:12] *** xiaomiao left
[12:13] <kaare_> OK, thanks anyway. I've used all available time today, so I'll have to stuff it in the play projects drawer again. Hopefully not for too long.

[12:15] <CIAvash> llfourn++ for the require fix # wanted to say this a few weeks ago but ... :)

[12:16] *** SCHAAP137 joined
[12:18] *** Cabanossi left
[12:19] <Skarsnik> damn, I though Discord:ver<0.0.1>:auth<Sylvain Colinet [email@hidden.address] already installed

[12:19] <Skarsnik>  error in panda was solved x)

[12:20] *** xiaomiao joined
[12:20] <llfourn> CIAvash: thanks! # thanks to RabidGravy++ for saving the ecosystem after the require fix broke everything :P

[12:21] <RabidGravy> moi?

[12:21] <llfourn> toi!

[12:21] <timotimo> the error is solved if and only if you --force, or if you up the version number :)

[12:22] <timotimo> at least that's what i seem to recall

[12:22] <kaare_> nine: One more q, though. I wonder why I don't need to include any c headers.

[12:24] <RabidGravy> Skarsnik, with regard to the H::UA thing, in the case where the Response constructor gets no data or where it can't find a valid HTTP response line I propose to just set the code to 500 with some headers indicating that it was set locally and let the upstream decide what to do with that?

[12:25] <Skarsnik> There is a Internal execption already in h::UA

[12:25] <Skarsnik> damn DBIish can't be installed

[12:26] <kaare_> RabidGravy I meant <sigh>

[12:26] <RabidGravy> kaare_, because it "only" dynamically links to the library at run time it doesn't need that, it just needs the name of the function and the library where it is found

[12:26] <nine> kaare_: because NativeCall doesn't compile anything. It accesses the binary libraries directly. You tell NativeCall how the library looks like by giving it the function signatures in Perl 6

[12:26] <RabidGravy> and getting the arguments right helps too if you don't want a segfault

[12:26] <partly__> m: sub f() returns Str { "asd" }; sub f() returns Int { 3 }; my Str $b = f(); say $b;

[12:26] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/dhQGpcR3X5␤Redeclaration of routine f␤at /tmp/dhQGpcR3X5:1␤------> 3Str { "asd" }; sub f() returns Int { 3 }7⏏5; my Str $b = f(); say $b;␤    expecting any of:␤        horizontal whitespace␤  …»

[12:27] <Skarsnik> hm, it's new? t/26-mysql-blob.t

[12:29] <partly__> No idea how to express the above in one line, but basically instead of being "smart" and picking the first variant of the sub it picks the one which returns Int

[12:30] *** pierrot joined
[12:30] *** woolfy joined
[12:30] <woolfy> The monster is alive!

[12:31] *** woolfy left
[12:31] <partly__> Hmm the return type is not a part of the signature so it's the same routine for the parser?

[12:31] <vendethiel> :o

[12:32] <vendethiel> partly__: no overloading on return type :)

[12:32] <RabidGravy> partly__, it also needs to be a "multi" 

[12:33] <partly__> ok

[12:34] *** Laurent_R left
[12:35] <RabidGravy> in principle you could implement your own dispatcher that takes iinto account a declared return type but in the general case it is not possible

[12:35] <kaare_> The thing I don't get is, how does it know what to call. What if I want a 'select' in another c library?

[12:36] <RabidGravy> you would give the native trait the library name

[12:36] <RabidGravy> in the "select" case it is assumed to be in the already loaded C runtime library

[12:37] <timotimo> i don't think a c compiler lets you have two functions called "select" from different libraries

[12:37] <timotimo> except perhaps if you #undefine it in between usages and add the other definition in the middle?

[12:38] <dalek> DBIish: 97d14f1 | (Sylvain Colinet)++ | t/26-mysql-blob.t:

[12:38] <dalek> DBIish: Added test skip in t/26 if mysql fail to connect to not prevent DBIish to be installed

[12:38] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/97d14f1dd3

[12:39] <RabidGravy> C++ has to be good for something ;-)

[12:39] <Skarsnik> timotimo, I think it work with dlopen, since you just pick up symbol on a given file

[12:39] <timotimo> right, there you can have overloading

[12:40] <timotimo> Skarsnik: right. that's why i said "a c compiler" :)

[12:40] <Skarsnik> I am not sure what happened

[12:40] <vendethiel> timotimo: you can't #undefine a function :P

[12:40] <timotimo> vendethiel: why not?

[12:40] <vendethiel> because preprocessor <=> compiler

[12:40] <timotimo> that makes sense

[12:41] <RabidGravy> you probably could hack around it in the preprocessor but I don't want to think about that

[12:42] <Skarsnik> You can do fake overloading

[12:42] <Skarsnik> in C

[12:42] <Skarsnik> with like checking a size of the type given and have macro around that xD

[12:43] <RabidGravy> yeah after all the first C++ implementations were just extensions to the preprocessor, awful and slow but somewhat worky

[12:43] <Skarsnik> like void real_function(data, sizedata) {} #defined function(x) real_function(x, sizeof(x))

[12:44] <RabidGravy> I think SCO shipped one like that until they went boom

[12:51] <vendethiel> you can do overloading in C with C11 :)

[12:51] <vendethiel> #define function(x) _Generic((x), float: ...)

[12:52] <RabidGravy> anyway this isn't getting any code written, lots of stuff to write and not enough time

[13:00] <RabidGravy> and I must not get distracted by doing a binding to getpeername() as I don't need that right now

[13:01] <Skarsnik> x)

[13:03] <Skarsnik> have gptrixie do it for you x)

[13:04] <Skarsnik> damn perl6 now look really faster than 2-3 months ago x)

[13:04] <RabidGravy> no, no, I'm not going to do it at all

[13:07] <lizmat> http://hoelz.ro/blog/finding-most-common-russian-ngrams  hoelzro++

[13:07] <yoleaux> 11:33Z <llfourn> lizmat: btw RT #127444 is about Signature.ACCEPTS. Wrt to what it's meant to do, I thought that it A.ACCEPTS(B) should return true if B accepts a subset of A's parameters. ie every :(Real $b) ~~ :(Int $a) # True

[13:07] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127444

[13:08] <lizmat> .tell hoelzro note that you can do Str.comb(Int $n) for $n chars (which is much faster :-)

[13:08] <yoleaux> lizmat: I'll pass your message to hoelzro.

[13:08] <timotimo> heyo lizmat :)

[13:09] <lizmat> timotimo o/

[13:09] * lizmat just got home

[13:09] *** edehont joined
[13:10] *** edehont left
[13:10] *** jjido left
[13:10] *** edehont joined
[13:11] *** edehont left
[13:13] *** edehont joined
[13:16] *** edehont left
[13:18] *** kid51 joined
[13:23] <llfourn> lizmat: doh that should be the other way around. :(Int $a) ~~ :(Real $b) # True

[13:24] <lizmat> yeah, these things can trip you up  :-)

[13:25] <llfourn> yeP A.ACCEPTS(B) is $B ~~ $A gets me every time :P

[13:25] <dalek> rakudo/nom: 38a2bfe | lizmat++ | src/core/Signature.pm:

[13:25] <dalek> rakudo/nom: Some refinements in Capture eqv Capture

[13:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/38a2bfe549

[13:25] <lizmat> afk again for a few hours&

[13:25] <llfourn> m: say :(Int $a) ~~ :(Real $b)

[13:25] <camelia> rakudo-moar 0ad8b3: OUTPUT«True␤»

[13:26] <llfourn> m: say :(Int $a) ~~ :(Real $b?)

[13:26] <camelia> rakudo-moar 0ad8b3: OUTPUT«True␤»

[13:26] <llfourn> m: say :(Int $a?) ~~ :(Real $b)

[13:26] <camelia> rakudo-moar 0ad8b3: OUTPUT«False␤»

[13:27] <llfourn> m: say :(Int $a?) ~~ :(*@a)

[13:27] <camelia> rakudo-moar 0ad8b3: OUTPUT«True␤»

[13:27] <llfourn> m: say :(Int $a?) ~~ :($a is rw)

[13:28] <camelia> rakudo-moar 0ad8b3: OUTPUT«False␤»

[13:28] <llfourn> m: say :(Int $a) ~~ :($a is rw)

[13:28] <camelia> rakudo-moar 0ad8b3: OUTPUT«True␤»

[13:28] <llfourn> ah ha!

[13:28] <llfourn> I knew I could find a way to trip it up

[13:30] <llfourn> m: say :($a) ~~ ($a is rw)

[13:30] <llfourn> m: say :($a) ~~ :($a is rw)

[13:30] <camelia> rakudo-moar 0ad8b3: OUTPUT«5===SORRY!5=== Error while compiling /tmp/DDPbVQ4Kac␤Variable '$a' is not declared␤at /tmp/DDPbVQ4Kac:1␤------> 3say :($a) ~~ (7⏏5$a is rw)␤»

[13:30] <camelia> rakudo-moar 0ad8b3: OUTPUT«True␤»

[13:31] * masak finally sits down and starts tinkering with his GPW talks

[13:31] <yoleaux> 5 Mar 2016 15:12Z <pmurias> masak: it's not DWIM to me as I wouldn't ever expect that without looking it up

[13:31] <yoleaux> 5 Mar 2016 15:13Z <pmurias> masak: it seems to be something inherited from awk

[13:31] <masak> oh, awk. didn't know that.

[13:31] <masak> I think I agree that it's not all that obvious. though I have a feeling it's rather *convenient*, and we might want to think about not throwing that away.

[13:32] <timotimo> oh hey masak :)

[13:32] <timotimo> what were you talking about there?

[13:32] <timotimo> my first guess is flip-flop operators :)

[13:33] <masak> "" as record separator when doing line-based input

[13:33] <timotimo> oh, for paragraphs?

[13:34] <llfourn> .tell lizmat another possible bug: say :($a) ~~ :($a is rw) # returns True but it should be False IMO, is rw is narrower

[13:34] <yoleaux> llfourn: I'll pass your message to lizmat.

[13:34] <masak> (with the semantics "read paragraph-wise" or "separator is /\n\n+/")

[13:34] <timotimo> yes, rw is narrower

[13:35] <partly__> I'm getting the exception cannot unbox to a native string

[13:36] <FROGGS> masak: ohh you start now? phew, and I thought starting yesterday was a bad idea :o)

[13:36] <masak> partly__: are you able to show a (golfed) piece of code that produces this error?

[13:36] <partly__> i have a line number (i guess it's an int) which i try to concat to a string.

[13:36] <timotimo> huh, that should stringify just fine for you

[13:36] <masak> FROGGS: I tried to start yesterday. but the procrastination is strong with this one.

[13:36] <timotimo> can you golf that?

[13:36] <partly__> timotimo: this is in rakudo/src/core/Exception.pm

[13:39] <FROGGS> currently I've got 120 lines of notes / stubbed slides

[13:39] <FROGGS> I hope that's enough for a 40 minutes talk

[13:40] <FROGGS> though I guess I need less slides per minute anyway, because I'm going to explain much per slide

[13:41] <partly__> timotimo, masak: https://gist.github.com/kalkin/7e3492ac9c47f749fea5#file-exception-pm6-L909

[13:41] <timotimo> ooooh feed syntax

[13:41] <Skarsnik> hm, This page was generated the 2016-03-06 in 26.6092489 seconds with Perl 6.c (rakudo (2015.12.199.g.5.ed.58.f.6)) - This page was generated the 2016-03-06 in 27.96024130 seconds with Perl 6.c (rakudo (2016.2.88.g.7.fab.8.e.7)) for the same page

[13:41] <FROGGS> partly__: you probably want to join the routine names, no?

[13:42] <Skarsnik> weird that it's 2 sec slower

[13:42] <masak> partly__: well, the `nqp::hllize($routine)` stands out as a very likely candidate for your troubles

[13:42] <FROGGS> partly__: so try nqp::hllize($routine).name in the map block

[13:42] <timotimo> Skarsnik: if it's run on our p6c, it can very well be interfered with by other processes and hard drive seeking times/caching etc etc

[13:42] <partly__> FROGGS: actually i want to print %f:%l→ %m

[13:43] <partly__> i wanted to get the linenumbers and copy pasted from sub l()

[13:43] <llfourn> if you scroll up [Tux]'s CSV benchmarks seemed to be slower as well

[13:43] <Skarsnik> I don't know, time was consistent between each day for these

[13:43] <partly__> which is called in L915

[13:43] <partly__> where do i find docs on nqp::hllize?

[13:44] <Skarsnik> it's a lot of DBIish call and Template::Mojo behind

[13:45] <FROGGS> partly__: if it is anywhere it is here: https://github.com/perl6/nqp/blob/master/docs/ops.markdown

[13:46] <llfourn> http://tux.nl/Talks/CSV6/speed4.html # charts putting recent spike in slowness in perspective [Tux]++

[13:46] <[Tux]> thnx

[13:56] <timotimo> :BY<&defoid W W u u u U u U u u>

[13:56] * timotimo is reminded of a spooky ghost

[13:58] <timotimo> WTB: a html-export or app or something to work more easily with QAST dumped output

[14:01] <timotimo> but the current dump format is absolutely horrifying to parse

[14:04] <masak> would a dump format especially developed for the purpose help?

[14:05] <timotimo> yes

[14:05] <timotimo> can even be json

[14:05] <llfourn> I flag to turn on json execption dumps would be nice

[14:06] <llfourn> s/I/a/

[14:09] <partly__> when recompiling rakudo it takes 52 seconds at State parse and 8 at optimize and 17 at mast even if I changed only one line. Is there a way to speed it up at some of the stages?

[14:09] <timotimo> there is not, sadly

[14:10] <timotimo> a theoretical way to make things faster is to have a setting that strips out a few things

[14:10] *** Laurent_R joined
[14:10] <timotimo> Set, Bag, Mix and friends are likely candidates, as well as the sockets and parallelism stuff

[14:13] <partly__> ic, thanks

[14:13] <timotimo> if you're interested, you could try to build that :)

[14:13] <timotimo> not sure how to best go about that

[14:14] <partly__> timotimo: let me add support for VIM errorformat to the exceptions and if I finish it up, then we will see :). 

[14:14] <timotimo> oh, neat

[14:15] <timotimo> btw, with so many exceptions giving pretty good suggestions what to do instead, we could totally have a tool that creates and optionally immediately applies changes to your code

[14:16] <partly__> Btw here is a syntastic perl6 checker which handles some of the exceptions i've seen with the current error format https://github.com/kalkin/syntastic/blob/perl6/syntax_checkers/perl6/perl6.vim

[14:17] <partly__> It's mostly copy/pasta from the perl checker, but it kind of works

[14:17] <timotimo> cool

[14:24] <Skarsnik> gah, did some backtrace disapear again? I get Use of uninitialized value of type Any in string context without line/file

[14:26] *** Cabanossi joined
[14:29] <dalek> doc: c2e3e18 | jjatria++ | doc/Language/5to6-nutshell.pod:

[14:29] <dalek> doc: Fix markup in nutshell headers

[14:29] <dalek> doc: review: https://github.com/perl6/doc/commit/c2e3e187f1

[14:29] <dalek> doc: 1fd720c | sylvarant++ | doc/Language/5to6-nutshell.pod:

[14:29] <dalek> doc: Merge pull request #415 from jjatria/fix-nutshell-headers

[14:29] <dalek> doc: 

[14:29] <dalek> doc: Fix markup in nutshell headers

[14:29] <dalek> doc: review: https://github.com/perl6/doc/commit/1fd720cab1

[14:30] <partly__> m: "asd".^roles ∈ Stringy

[14:30] <camelia> rakudo-moar 0ad8b3: OUTPUT«WARNINGS for /tmp/Yz7SIZa7rG:␤Useless use of "∈" in expression ".^roles ∈ Stringy" in sink context (line 1)␤»

[14:31] <partly__> m: Stringy ∈ "asd".^roles

[14:31] <camelia> rakudo-moar 0ad8b3: OUTPUT«WARNINGS for /tmp/QsvGA_YuqS:␤Useless use of "∈" in expression "Stringy ∈ \"asd\".^roles" in sink context (line 1)␤»

[14:31] <timotimo> how about a "say" in there?

[14:31] *** TimToady left
[14:31] <partly__> m: say(Stringy ∈ "asd".^roles)

[14:31] <camelia> rakudo-moar 0ad8b3: OUTPUT«True␤»

[14:32] <partly__> Ahh nice, thanks

[14:32] <partly__> I it idiomatic enough for a check if given something implements a role?

[14:33] *** TimToady joined
[14:34] <masak> m: say "asd" ~~ Stringy

[14:34] <camelia> rakudo-moar 0ad8b3: OUTPUT«True␤»

[14:34] <masak> partly__: that's idiomatic ;)

[14:36] <partly__> masak: ic. I must learn to embrace ~~ even if it always looks to me like a lot of MAGIC

[14:36] <partly__> :)

[14:36] <masak> it's the right kind of magic

[14:36] <masak> and IMO it's fewer moving parts than ∈ and .^roles

[14:37] <jnthn> It's probably also a dozen times faster :)

[14:37] <yoleaux> 09:54Z <lizmat> jnthn: I'm a bit confused as to the meaning of Signature.ACCEPTS

[14:37] <yoleaux> 09:55Z <lizmat> jnthn: as it seems to include a check on "returns"

[14:37] <partly__> masak: yes of course

[14:39] *** partly__ is now known as kalkin

[14:39] *** kalkin is now known as kalkin-

[15:07] *** Ven joined
[15:08] *** zpmorgan joined
[15:14] *** khw joined
[15:20] *** Ven left
[15:21] *** brrt joined
[15:22] <brrt> hey #perl6. i'm looking for a way to automatically run a TAP test and get a boolean for broken/not broken

[15:23] <timotimo> "prove" should do that for you

[15:23] <llfourn> brrt: by boolean do you mean p6 Bool or shell status?

[15:23] <brrt> hmm, gooid point timotimo

[15:23] <llfourn> either way I guess prove is the answer :P

[15:23] <timotimo> prove it.

[15:24] <brrt> y'all know

[15:24] <brrt> i figured something out, about python, just this week

[15:24] <brrt> it dawned on me that python is not actually a scripting language

[15:25] <timotimo> oh?

[15:25] <timotimo> do enlighten us

[15:25] <brrt> making a script, as in, a small thing that easily wires together a lot of external functionality, as per bash script, javascript, perl, ruby even

[15:25] <brrt> is a *huge* pain in python

[15:25] <timotimo> what, because it forces you to be so correct about things? :P

[15:25] <brrt> what do you think is equivalent to q:x["foo bar"]

[15:26] <llfourn> import herp from derp; herp("foo bar") # or something

[15:26] <timotimo> subprocess.Popen?

[15:26] <brrt> it is; import subprocess; try: output = subprocess.check_output(['foo', 'bar']);str_output = output.decode('utf-8'); except subprocess.Error as e: logging.exception(e) yadyaydayadyadya

[15:27] <brrt> python is about as unfluent in calling out, shelling out, as java might well be

[15:28] <llfourn> but isn't JS pretty similar in that?

[15:28] <llfourn> I mean JS has script in the name so it must be a script

[15:28] <llfourn> but I guess it's not java at all so it may as well not be a script

[15:29] <brrt> good point

[15:29] <geekosaur> brrt, the line between script and language has been at best extremely bluirry for years

[15:29] <brrt> counterpoint: javascript is very much 'scripting' it's native environment, notably, the browser

[15:29] <llfourn> good counterpoint

[15:30] <geekosaur> you can't even use something like "runs from the top" vs. "uses a defined entry point" --- FORTRAN violates that

[15:30] <llfourn> I guess we can synthesize by saying that node is not a scripting language

[15:30] <brrt> agreed on that

[15:31] <brrt> geekosaur: my point on scripting is actually simple: does it exist to leverage the functionality of other systems, or does it exist to build systems of?

[15:31] <llfourn> geekosaur: but what do you think about brrt's definition of easily being able to interact and take effect on the outside environment.

[15:31] <timotimo> C scripts CPUs :P

[15:31] <brrt> extreme example of the former being bash, extreme example of the latter being, well, fortran

[15:32] *** CIAvash left
[15:32] <brrt> my point here is that python is amazingly un-good at being like bash

[15:32] <geekosaur> brrt, I'd say perl itself (in all its forms) messes with your definition :)

[15:32] <brrt> oh, yes

[15:32] <brrt> gloriously :-)

[15:32] <brrt> but perl is better at being like bash, than python is

[15:33] <brrt> at least, that's how i feel when writing it

[15:34] *** zakharyas joined
[15:34] <geekosaur> (I also wonder what you'd think of m4 -i | sh)

[15:34] <geekosaur> (the original V7 manpage's comment on that was glorious)

[15:36] <geekosaur> I'd also note that tcl was designed to be a scripting glue language, and its shellout stuff has always been wonky (only really fixed in very recent versions)

[15:37] <geekosaur> mostly because that points up that you aren't so much talking about scripting, as being a *shell* glue language. python and tcl are glue at the *function* level, not the shell level

[15:37] *** nbrown joined
[15:37] *** tmch left
[15:37] <llfourn> even though python is apparently not a scripting language it is used as the sole delivery mechanism by Ansible in order to configure stuff.

[15:37] <geekosaur> it also elevates the shell in ways that are largely unjustified. the shell is actually a pretty lousy way to do anything other than the most straightforward glue

[15:38] <geekosaur> which is a large part of why Larry created Perl 

[15:38] <brrt> no, now i'm thinking your taking my 'like bash' to literally

[15:38] <geekosaur> actually I'm taking your example in scrollback of running a subprocess in python

[15:39] <geekosaur> yes, it's annoying to do the stuff that's trivial in the shell. my counterpoint is it's easier to do something more complex than that in Python, than it is to do it in a shell

[15:39] <brrt> yes

[15:39] <brrt> but my point was slightly different than that

[15:40] <geekosaur> also the shell makes it easy to ignore error cases, where python forces you to deal with them

[15:40] <brrt> to bash, the environment with which it interacts, is your OS with all its tools and environment

[15:40] <brrt> python makes it dififcult and annoying to deal with its environment in the same way

[15:40] <brrt> you'll be basically be a happier python programmer using only python modules and never calling out to anything

[15:41] <brrt> so python limits - culturally - its environment to the python-world as it were

[15:42] <llfourn> os.environ["FOO"] = .. vs %ENV{FOO} = .. vs FOO=

[15:42] <brrt> as a result, your python program will deal with the world in a pythonic way

[15:42] <brrt> i'm not bashing python, by the way

[15:42] <geekosaur> right, I'm thinking that that is actually quite common in modern languages... and it has good reasons

[15:43] <brrt> yes. but for the purposes of scripting together some behavior, that mostly lives elsewhere, its just not as easy or fluent as perl or even bash would have been

[15:44] <geekosaur> so, while people tend to point to things like the "line noise" aspect of perl 5, I think their real problem is that it requires them to switch mental contexts too much --- some things work like shell, others like other things. most people have trouble doing that kind of context switching

[15:44] <brrt> hmmm

[15:44] <brrt> probably that is true, yes

[15:44] <geekosaur> python and many other languages address that by bringing as much as possible into a single context

[15:45] <brrt> (can i have prove run a single test?)

[15:45] <brrt> yes, that makes it a bit like java

[15:45] <llfourn> (yes you can: prove -e 'perl6 -Ilib' some/test.t)

[15:45] <geekosaur> (this also comes up in Haskell, many FFI interfaces look very much like their original languages instead of like Haskell and there are fairly severe impedance mismatches when combining with Haskell code)

[15:46] <llfourn> (if you mean single test file)

[15:46] <brrt> (that is exactly what i meant :-))

[15:48] <brrt> hmm interesting point geekosaur

[15:49] *** kjs_ left
[15:50] *** tmch joined
[15:52] *** nbrown left
[15:53] <nine> brrt: I see the dividing line between scripting languages and others in if the programs and libraries are delivered primarliy in source or in binary form

[15:53] <brrt> hmmm

[15:53] <brrt> that is also not unreasonable

[15:56] <hoelzro> lizmat: ah, thanks for the tip! I didn't know about that variant of .comb!

[15:56] <yoleaux> 13:08Z <lizmat> hoelzro: note that you can do Str.comb(Int $n) for $n chars (which is much faster :-)

[16:00] <timotimo> how come t/spec/S32-num/power.rakudo.moar passes some TODOs?

[16:05] *** maybekoo2 joined
[16:06] *** zpmorgan left
[16:07] <dalek> rakudo-star-daily: 4fcecc7 | coke++ | log/ (8 files):

[16:07] <dalek> rakudo-star-daily: today (automated commit)

[16:07] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/4fcecc772e

[16:09] *** skids joined
[16:13] *** havenwood left
[16:15] *** havenwood joined
[16:18] <AlexDaniel> timotimo: I think that it's fine. Which ones exactly?

[16:18] <AlexDaniel> timotimo: some of them are “passes on OSX, fails on Linux”

[16:20] <timotimo>   TODO passed:   13-15, 68-70

[16:21] <Skarsnik> hm, how do I know what moar version is installed?

[16:21] <timotimo> moar --version

[16:21] <timotimo> m: say $*VM.version

[16:21] <camelia> rakudo-moar 0ad8b3: OUTPUT«v2016.2.8.ga.329.e.2.d␤»

[16:21] <Skarsnik> Oh yeah moar --version

[16:21] <timotimo> m: say $*VM.perl

[16:21] <AlexDaniel> timotimo: ok 13-15 links to https://rt.perl.org/Ticket/Display.html?id=127500

[16:22] <camelia> rakudo-moar 0ad8b3: OUTPUT«(timeout)»

[16:22] <AlexDaniel> timotimo: which kinda explains it

[16:22] <timotimo> ah, ugh

[16:22] <AlexDaniel> and 68-70 is about the same issue

[16:22] <timotimo> OK, thank you for looking!

[16:23] <AlexDaniel> timotimo: well, I am the one who marked those as todo… :)

[16:23] <Skarsnik> hm, that's weird 1042.226562 Mb /opt/bin/moar how the hell this script take 1GB already

[16:24] *** cognominal left
[16:24] <timotimo> uh oh :)

[16:25] <Skarsnik> If it's stay like that it's alright, but it should be more like < 100Mb xD

[16:31] *** themonkeybob11 left
[16:32] <timotimo> yeah, we hardly ever stay under 100 megabytes for complicated scripts ;(

[16:32] *** themonkeybob11 joined
[16:33] <timotimo> we've got many optimization opportunities ahead of us

[16:35] *** tmch left
[16:35] <brrt> another question....

[16:35] <brrt> is it possible to make 'prove' really, really, really quiet

[16:36] <brrt> or otherwise, to redirect the stdout/stderr of perl5 system() to /dev/null

[16:37] <nine> You can close STDOUT and STDERR before calling system() or use shell redirection in your system() command

[16:38] <Skarsnik> Oh it's growing

[16:38] <Skarsnik> It look like I get back the leak jnthn fixed

[16:40] <Skarsnik> Yep, it's leaking again

[16:43] <hoelzro> re-opening STDOUT/STDERR to /dev/null is recommended; if you close them, an open in the child program could end up with descriptor 1 or 2, and your child program could mess up its output if it tries writing diagnostic messages to STDERR

[16:43] <Skarsnik> https://gist.github.com/Skarsnik/03b970d2a4b827ba1e1d

[16:44] *** wamba left
[16:44] <Skarsnik> timotimo, should I repport this or something?

[16:46] <vendethiel> brrt: just 2>/dev/null when calling the commend?

[16:46] *** cognominal joined
[16:50] *** themonkeybob11 left
[16:55] <ugexe> is there much of a difference between acting on Supply.act vs Channel inside a start { }? other than the all the helpers Supply provides

[16:58] <timotimo> Skarsnik: dunno; can you find out if it's coming from the savecapture thingie?

[17:00] <Skarsnik> hm, I don't really have time to look at that precisly

[17:00] <Skarsnik> I can look at moar commit maybe?

[17:00] <skids> ugexe: Supply blocks on emit, Channel does not block on send.

[17:03] *** CIAvash joined
[17:03] <skids> ugexe: also, Channel only hits one of its multiple receivers for each event.

[17:03] <ugexe> doesn't .act do that for Supply?

[17:03] <Skarsnik> How do I find what version/date is ga329e2d in Moar

[17:04] <ugexe> oh i see what you mean

[17:04] <hoelzro> Skarsnik: Wed Mar 2 18:20:32 2016 +0100

[17:04] <hoelzro> (via git-show)

[17:08] *** zakharyas left
[17:08] <Skarsnik> ok thx

[17:09] <Skarsnik> hm, must be a change in rakudo or nqp then?

[17:09] *** xinming_ is now known as xinming

[17:10] *** kjs_ joined
[17:14] *** Laurent_R left
[17:15] *** Laurent_R joined
[17:15] *** brrt left
[17:18] *** brrt joined
[17:21] *** domidumont joined
[17:28] <jnthn> ugexe: The big difference between supplies and channels is that with supplies, your .act runs on whatever thread does the emit, whereas with channels there's an actual queue there and sending a value does nothing more than putting it into the queue.

[17:29] <jnthn> ugexe: So, rather different computation models.

[17:29] <ugexe> ah i see!

[17:32] *** idiosyncrat_ joined
[17:33] *** wamba joined
[17:37] <mst> jnthn: have we gone over the 'go channels are bad and you should feel bad' article and checked that ours don't have any of those problems?

[17:37] <mst> might make a nice blog post actually comparing and constrasting

[17:37] * ugexe is trying to find hacky ways to use data from a handle (IO::Socket::INET for instance) in another thread

[17:37] <mst> if somebody tried to write said thing up would you be willing to try and review it?

[17:40] <vendethiel> mst: that article itself is ... pretty bad, tbh :v

[17:40] <mst> vendethiel: oh? from what I've read elsewhere the criticisms are all at least somewhat valid

[17:41] *** CIAvash left
[17:42] *** idiosyncrat_ left
[17:43] *** idiosyncrat_ joined
[17:43] <vendethiel> from what I've seen, it's "they're bad when misused"

[17:45] <mst> right, but things like the panicking seems to make it quite easy to misuse them

[17:46] <mst> also, this is the channel for a perl language, making things DWIM when you do the obvious thing as opposed to telling people "the obvious thing is wrong, you should've read the documentation and managed to guess <completely different thing>" is kinda part of the schtick, no?

[17:49] *** firstdayonthejob left
[17:49] *** firstdayonthejob joined
[17:49] *** CIAvash joined
[17:50] <vendethiel> mst: yeah, I've never liked the panic model in go anyway (I don't like go much at all, to be fair, so I guess that's expected, but for simple uses, go channels work well enough)

[17:51] <mst> it seems to me that channels are meant to be "I need to pass stuff around and am probably not CPU bound on the passing stuff around so whatever"

[17:53] *** firstdayonthejob left
[17:54] *** firstdayonthejob joined
[18:01] *** firstdayonthejob left
[18:01] *** firstdayonthejob joined
[18:05] <skids> Perl 6 Channels are not like Go channels.  jnthn actually mentioned once wondering whether they should be renamed to avoid confusion.

[18:06] <skids> For example they already buffer infinitely, and are not syncronization mechanisms between sender/receiver as they do not block on send.

[18:08] <skids> (There is still a problem shutting them down, but we can get runaway senders rather than leaked receiver loops.  And the base class can be built upon to fix that.)

[18:14] *** sjoshi joined
[18:16] *** kjs_ left
[18:17] *** kjs_ joined
[18:22] <RabidGravy> jnthn, you know the change you made to the generation of attribute accessors, it appears that the generate_accessor whilst actually making the rw accessors right, doesn't actually set the rw flag

[18:22] <RabidGravy> so a leetle hack I have in Staticish don't work no more

[18:23] <mst> skids: go channels don't *have* to block on send

[18:23] <mst> skids: infinite buffers are bad though, eventually you need backpressure or to load shedding

[18:32] *** kjs_ left
[18:36] *** kjs_ joined
[18:42] *** Actualeyes left
[18:50] *** kjs_ left
[18:56] *** themonkeybob11 joined
[18:59] *** brrt left
[19:02] *** Ven joined
[19:03] *** Ven left
[19:05] *** firstdayonthejob left
[19:12] *** tmch joined
[19:15] *** zacts left
[19:17] *** zacts joined
[19:19] <stmuk> GPW schedule ist complete!

[19:20] <timotimo> awesome

[19:20] <lizmat> stmuk: thanks for the Durham tip

[19:20] <yoleaux> 13:34Z <llfourn> lizmat: another possible bug: say :($a) ~~ :($a is rw) # returns True but it should be False IMO, is rw is narrower

[19:21] *** CIAvash left
[19:21] <stmuk> lizmat: you visited?

[19:22] <lizmat> yeah, we only had 2 hours before having to make it back to the ferry

[19:22] <lizmat> and lost half an hour looking for a parking space

[19:22] <lizmat> but we walked from the train station to the cathedral, had some tea on the green, and then back to the station again

[19:22] <stmuk> its beautiful .. I spent some time at university there

[19:23] <lizmat> the weather didn't cooperate much (at some point it hailed)

[19:23] <lizmat> but it was nice enough for us to put it on the list of places to revisit at a later time  :-)

[19:23] <stmuk> :)

[19:24] <lizmat> but not early on a Saturday afternoon :)

[19:24] <stmuk> the driving is awful .. 

[19:25] <lizmat> well, we were at a disadvantage driving a van that was too high for any of the parking garages in the center

[19:25] <dalek> ecosystem: b600659 | RabidGravy++ | META.list:

[19:25] <dalek> ecosystem: Update META -> META6.json for Staticish

[19:25] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/b6006594bd

[19:26] <stmuk> the castle is part of the university and it's possible to stay there cheaply and that includes parking in front of the cathedral

[19:26] *** abaugher left
[19:26] <timotimo> there's no way for a num or str to ever not be p6definite, right?

[19:26] *** abaugher joined
[19:26] <timotimo> m: use nqp; my str $a; say nqp::p6definite($a)

[19:27] <camelia> rakudo-moar 0ad8b3: OUTPUT«True␤»

[19:27] <timotimo> hm, do we have a clue why camelia's reacting so slow?

[19:27] <timotimo> m: use nqp; my num $a; say nqp::p6definite($a)

[19:27] <camelia> rakudo-moar 0ad8b3: OUTPUT«True␤»

[19:27] <RabidGravy> another sunday another module needs fixing

[19:30] <lizmat> m: use nqp; my str $a; say nqp::isnull_s($a)

[19:30] <camelia> rakudo-moar 0ad8b3: OUTPUT«(timeout)»

[19:30] <lizmat> what?

[19:30] <lizmat> m: use nqp; my str $a; say nqp::isnull_s($a)

[19:31] <camelia> rakudo-moar 0ad8b3: OUTPUT«0␤»

[19:31] <lizmat> perhaps some rogue processes are eating all of camelia's CPU in thatb VM ?

[19:32] <lizmat> fwiw, I sorta expected that to return 1

[19:33] <timotimo> hm, doesnt need decont, does it?

[19:34] <lizmat> doesn't make a difference, so I would gather it doesn't

[19:34] <timotimo> i just patched Perl6/Optimizer.nqp to not emit an "if p6definite($foo) { $foo } else { &operator() }" for += and friends

[19:34] <timotimo> er

[19:34] <timotimo> only for native variables, of course

[19:36] *** CIAvash joined
[19:37] *** dj_goku left
[19:37] *** dj_goku joined
[19:41] <AlexDaniel> lizmat: yeah. camelia is misbehaving lately

[19:42] *** themonkeybob11 left
[19:42] <timotimo> nine: can you have a quick look at some monitoring or something to see what could be wrong?

[19:42] *** sftp left
[19:51] <dalek> rakudo/nom: 25eef56 | timotimo++ | src/Perl6/Optimizer.nqp:

[19:51] <dalek> rakudo/nom: don't need to check native vars for definite in metaop_assign opt

[19:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/25eef5659e

[19:51] <lizmat> Weeee!  a commit by someone other than me!  wheeee  :-)

[19:51] *** sftp joined
[19:52] <timotimo> sorry about that, liz .. i've had ideas in the recent days, but nothing materialized into code

[19:52] *** sjoshi left
[19:52] <lizmat> I just get depressed if I do a git pull and all it says is "already up to date"  :-(

[19:53] <timotimo> understandable

[19:58] *** CIAvash left
[19:58] <sortiz> Skarsnik++ # mysql availability test.

[20:00] <dalek> DBIish: 98279dc | (Salvador Ortiz)++ | / (2 files):

[20:00] <dalek> DBIish: mysql: Blob columns returns Buf not Blob.

[20:00] <dalek> DBIish: 

[20:00] <dalek> DBIish: Test for return type and NULL.

[20:00] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/98279dcdb4

[20:00] <dalek> DBIish: 3cad692 | (Salvador Ortiz)++ | t/26-mysql-blob.t:

[20:00] <dalek> DBIish: Merge branch 'master' of github.com:perl6/DBIish

[20:00] *** labster joined
[20:00] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/3cad692095

[20:01] *** brrt joined
[20:02] <lizmat> timotimo: and then I won't be able to make it to the GPW this year and see all of the P6 crew  :-(

[20:04] <timotimo> :(

[20:09] *** Cabanossi left
[20:10] <jnthn> lizmat: I won't be there either, fwiw

[20:10] <sortiz> .oO( It will be time to ask for commit bit in rakudo? )

[20:10] <jnthn> RabidGravy: The "not marked is rw" thing sounds worth fixing; could you RT it so I don't forget? :)

[20:10] <jnthn> Will add a test too :)

[20:11] <RabidGravy> okay

[20:11] <jnthn> mst: Would certainly be able to read/comment on such a post.

[20:12] <jnthn> (Also need to read that blog post you linked properly, rather than just skimming it :))

[20:12] *** Cabanossi joined
[20:12] <Skarsnik> jnthn, I don't know if you saw this https://gist.github.com/Skarsnik/03b970d2a4b827ba1e1d the last output is with a today rakudo, the first is when you patched arg.c in more to fix a leak

[20:14] <jnthn> Skarsnik: Curious, and exact same program being run?

[20:14] <Skarsnik> Yes

[20:14] <jnthn> Wonder what's to thank for that... It's a much slower leak than the last one at least 

[20:14] <Skarsnik> The modules involved did not get any change too

[20:15] <jnthn> OK. Valgrind output would be useful again.

[20:16] *** Util left
[20:16] <jnthn> There's been very few patches in Moar in the meantime...odd.

[20:16] *** dalek left
[20:17] *** labster left
[20:17] *** darutoko left
[20:19] <RabidGravy> jnthn, https://rt.perl.org/Ticket/Display.html?id=127665

[20:19] <jnthn> RabidGravy: Thanks! :)

[20:22] <RabidGravy> y'see it turns out my modules are better than roast for determining compatibility issues

[20:23] <RabidGravy> I find one every week ;-)

[20:23] <jnthn> Over time we'll transcribe much that into roast, I hope :)

[20:23] *** SCHAAP137 left
[20:24] <jnthn> Hopefully by us doing converage analysis and spotting gaps proactively, rather than just by continually busting your modules :)

[20:24] <jnthn> *coverage

[20:24] *** domidumont left
[20:25] *** davido joined
[20:26] <skids> mst: yeah backpressure and an eventual failure mode is definitely needed, and the mechanism for that needs both time and queue depth components, and shouldn't happen per-value-passed so it isn't itself a force multiplier.  Lessons learned from networking :-).

[20:26] <mst> skids: yep

[20:27] <mst> skids: I quite like erlang's approach where the more full a process' mailbox, the more reductions you're charged for sending to it

[20:27] <mst> seems like an elegant way to propagate backpressure across the system from overloaded components

[20:27] *** Begi joined
[20:30] *** jjido joined
[20:30] *** labster joined
[20:30] <Skarsnik> and I don't have scrolling in screen, annoying

[20:32] *** musiKk_ joined
[20:33] <skids> Unfortunately the majority of the very clever solutions to queueing problems developed for networking rely on the fact that the network is allowed to drop packets.  Stochasctic fair queueing wouldn't go over well internally in a program :-).

[20:33] *** SCHAAP137 joined
[20:35] <Skarsnik> damn it barely leak in valgrind lol

[20:36] <Skarsnik> jnthn, I added valgring output in https://gist.github.com/Skarsnik/03b970d2a4b827ba1e1d

[20:38] <jnthn> Yowser, something's going rotten in cleanup up at the top there too...but that looks familiar, I thought I'd fixed that...

[20:39] <jnthn> Skarsnik: Anyways, thanks...will dig thorugh that some more in the next couple of days

[20:40] *** wamba left
[20:40] *** virtualsue joined
[20:42] <Skarsnik> I wqs like, yay, no more leak, I can run this bot on this server, after a while it was taking 1Gb of memory... not fun x)

[20:45] * jnthn scribbled a blog post about what he got up to in the last week or so... https://6guts.wordpress.com/2016/03/06/digging-into-the-performancereliability-work/

[20:47] *** geraud joined
[20:47] *** ely-se joined
[20:48] *** brrt left
[20:48] <lizmat> jnthn++

[20:51] <lizmat> argh, dalek awol ?

[20:52] <lizmat> I've just committed 978754607176392f68

[20:52] <lizmat> "Make :($a) ~~ :($a is rw) return False"

[20:52] <lizmat> jnthn: ^^^ was that the one you were going to look at ?

[20:53] <nine> timotimo: several rakudo builds were running in parallel eating all memory

[20:55] *** jjido_ joined
[20:55] <jnthn> lizmat: Hm, yeah, I'd expect if anything :($a is rw) ~~ :($a) might be true in so far as rw is a constraint

[20:55] <jnthn> But not the other way around

[20:55] <lizmat> ok, well that's fixed now  :-)

[20:55] <jnthn> lizmat++

[20:56] <lizmat> I'll be looking at Signature.ACCEPTS again tomorro

[20:56] *** AlexDaniel left
[20:57] *** jjido left
[20:58] <lizmat> jnthn: "The patch doing so it’s quite "   isn't ???

[20:58] *** kaare_ left
[21:00] <lizmat> m: dd :(42) ~~ :(666)   # jnthn, do you agree that this is a bug ?

[21:00] <camelia> rakudo-moar 0ad8b3: OUTPUT«Bool::True␤»

[21:03] <Skarsnik> great openssl that crash again ><

[21:04] <moritz> jnthn: "The patch doing so it’s quite ready for prime-time yet" you probably meant *isn't* quite ready for prime time?

[21:04] *** kjs_ joined
[21:05] <moritz> also, jnthn++

[21:05] <RabidGravy> yeah nice

[21:05] <RabidGravy> jnthn++

[21:07] *** idiosyncrat_ left
[21:13] *** wamba joined
[21:15] *** bjz left
[21:16] <autarch> jnthn: those performance improvements are very exciting!

[21:17] <jnthn> lizmat: Fixed, thanks

[21:17] <jnthn> moritz: Thanks for pointing out also :)

[21:17] <jnthn> lizmat: Yeah, :(42) ~~ :(666) should certainly be False

[21:18] *** maybekoo2 left
[21:19] <autarch> jnthn: I have a module that performs abysmally for no reason I can figure out - it might be a good thing to look at for perf improvements - https://github.com/perl6/Pod-To-HTML/tree/autarch/use-pod-treewalker - https://github.com/autarch/perl6-Pod-TreeWalker

[21:19] <lizmat> jnthn: ok, so how do I handle spectests that implicitely relay on that?

[21:19] <lizmat> jnthn: actually, the problem is more like:

[21:19] <autarch> and the associated Pod-To-HTML branch which uses that module is also very slow - https://github.com/perl6/Pod-To-HTML/tree/autarch/use-pod-treewalker

[21:20] *** davido left
[21:20] <lizmat> m: dd :($a where * == 42) ~~ :($a where * == 42)   # we can't see inside the WhateverCode, so we can only assume mismatch

[21:20] <camelia> rakudo-moar 978754: OUTPUT«Bool::True␤»

[21:20] <lizmat> *rely

[21:23] *** zpmorgan joined
[21:23] *** jjido_ left
[21:25] *** molaf_ left
[21:26] <ugexe> Skarsnik: maybe set up a local SSL MITM proxy to log whats happening :(

[21:27] <jnthn> autarch: Yes, real examples of slow stuff is useful. Will put those on my list of things to analyze; thanks!

[21:27] <jnthn> lizmat: Errata I guess... :)

[21:29] <moritz> does it make sense to return a tri-state thingy?

[21:29] <moritz> True if we know it's a match, False if we know it's not, and Bool if we know that we don't know?

[21:29] *** bjz joined
[21:30] <lizmat> and how would that affect MMD / role composition ?

[21:30] <lizmat> only True will break role composition, no ?

[21:30] <jnthn> moritz: That won't work out so well for smart-matching I guess...

[21:30] <moritz> do we even consider signatures for role composition?

[21:30] *** bjz left
[21:30] <moritz> jnthn: right

[21:31] *** bjz joined
[21:31] <jnthn> lizmat: I guess we'll just have to see what the actual fallout is...

[21:31] *** themonkeybob11 joined
[21:31] <lizmat> okidoki

[21:32] <jnthn> lizmat: Was the best you uncovered actually about roles?

[21:32] <jnthn> lizmat: I did write various tests for role composition and sigatures

[21:32] <jnthn> moritz: Yeah, we do these days...was fairly late-breaking...

[21:32] <jnthn> (As in, not long before 6.c)

[21:32] <lizmat> jnthn: yeah, t/spec/S06-signature/introspection.t tests 118-121

[21:33] <jnthn> That's not about roles though?

[21:34] <lizmat> it's about signatures and is-perl-idempotent

[21:35] <lizmat> and that uses eqv

[21:35] <lizmat> and it's Parameter eqv Parameter that I fixed so that it won't match

[21:36] <lizmat> m: dd :(42) eqv :(666)

[21:36] <camelia> rakudo-moar 978754: OUTPUT«Bool::False␤»

[21:36] <lizmat> m: dd :(42) ~~ :(666)

[21:36] <camelia> rakudo-moar 978754: OUTPUT«Bool::True␤»

[21:36] *** aindilis left
[21:37] <lizmat> m: dd :(42) eqv :(42)

[21:37] <camelia> rakudo-moar 978754: OUTPUT«Bool::True␤»

[21:37] <lizmat> that works, because we don't internally always make that a Callable

[21:37] <lizmat> m: dd :(42).params[0]

[21:37] <camelia> rakudo-moar 978754: OUTPUT«Int $ where { ... }␤»

[21:38] <lizmat> hmmm....ah, yes, Parameter.perl is still stupid

[21:38] <jnthn> lizmat: Yeah...I note that the tests for default values have been written sensitive to this

[21:39] *** themonkeybob11 left
[21:39] *** BenGoldberg joined
[21:40] <lizmat> anyway, I think the tests on lines 211-214 are highly suspect

[21:40] <jnthn> I'd agree

[21:41] <jnthn> Time for me to rest, I think

[21:41] <jnthn> 'night o/

[21:41] <lizmat> gnight, jnthn 

[21:44] *** themonkeybob11 joined
[21:45] *** bjz left
[21:45] *** rindolf left
[21:47] *** Begi left
[21:47] <timotimo> gnite jnthn :)

[21:48] <RabidGravy> toodles

[21:48] <timotimo> tu tu ru

[21:49] *** themonkeybob11 left
[21:54] *** firstdayonthejob joined
[21:55] *** kjs_ left
[21:59] *** kjs_ joined
[22:02] <timotimo> what on earth

[22:02] <timotimo> can someone try a perl6 --output=optimize foobar.p6 | less

[22:02] <timotimo> and not scroll to the bottom

[22:02] <timotimo> and tell me what happens to their cpu usage?

[22:03] <lizmat> any foobar will do ?

[22:04] <lizmat> $ perl6 --output=optimize -e ''

[22:04] <lizmat> Use of Nil in string context

[22:04] <lizmat> ?

[22:04] <moritz> I guess it needs to produce some output

[22:04] <moritz> otherwise scrolling or not doesn't make much sense

[22:05] *** kjs_ left
[22:05] <moritz> timotimo: no specialties in CPU usage here

[22:05] <moritz> $ echo 'say slurp "README.md"' > foobar.p6

[22:05] <moritz> $ ./perl6-m --output=optimize foobar.p6 |less

[22:06] <moritz> perl6-m simply exits, less buffers its output. All is as I'd expect.

[22:06] <moritz> sleep time here&

[22:07] <lizmat> good night, moritz 

[22:07] *** kjs_ joined
[22:08] *** FROGGS left
[22:09] *** brrt joined
[22:09] *** brrt left
[22:12] <rudi_s> Hi. Can I somehow access the variable name which was used to call a function? So a call like foo($x); yields '$x' inside foo.

[22:13] *** themonkeybob11 joined
[22:18] <sjn> rudi_s: could you describe the problem you're trying to solve, that lead to this question?

[22:20] *** wamba left
[22:20] <rudi_s> sjn: I'm thinking about a DSL-like language which allows the setting of certain variables. And I thought it would be nice if something like my $a = 'foo'; my $b = 'bar'; result $a, $b; would work and result could figure out, that $a and $b were set.

[22:21] <rudi_s> I know I could use a hash, or not perl and instead write my own parser and so own. - But I liked the idea and was curious if it's possible.

[22:22] <geekosaur> timotimo/moritz, presumably you need it to produce more than PIPE_BUF amount of output

[22:25] <timotimo> moritz: is say slurp readme.md more than a page ful?

[22:25] <sjn> rudi_s: sounds like you're looking for making a grammar and then some actions that do the right thing with "result $a, $b;"

[22:25] *** RabidGravy left
[22:25] <timotimo> because when i do that, i get a single cpu full of usage

[22:25] <timotimo> 100% kernel according to htop

[22:25] <timotimo> well, not 100%, but nearly so

[22:26] <rudi_s> sjn: When I said DSl-like language I meant perl6 with "nice" operators and the like to still be able to use the full power of perl6 if I want to.

[22:26] *** TEttinger joined
[22:27] <sjn> so you want to extend Perl6 itself?

[22:27] <rudi_s> sjn: Yes.

[22:28] <timotimo> m: sub test(\foo) { say foo.VAR.name }; my $hello; my $rudi; test($hello); test($rudi);

[22:28] <camelia> rakudo-moar 978754: OUTPUT«$hello␤$rudi␤»

[22:28] <timotimo> rudi_s: this is what the dd sub does, too

[22:29] <rudi_s> timotimo: Wow, awesome. - Thank you! Perl6 is really crazy. - Still not sure if this is a good idea but I like that it can be done.

[22:29] *** John[Lisbeth] joined
[22:29] *** SCHAAP137 left
[22:30] *** BenGoldberg left
[22:30] <rudi_s> timotimo: Can this be combined with "slurpy" arguments? So I could get all passed variables in test($hello, $rudi)?

[22:30] <lizmat> rudi_s: only with nqp trickery

[22:30] *** vendethiel left
[22:30] *** BenGoldberg joined
[22:31] <John[Lisbeth]> What is perl 5 from the perspective of perl 6 users?

[22:31] <sjn> hi John[Lisbeth] :)

[22:31] <rudi_s> Hm, that's too bad.

[22:31] <sjn> John[Lisbeth]: they're friends and family :D

[22:32] <John[Lisbeth]> I was talking to the guys in perl 5 and basically they said perl 6 was a different and seperate langauge than perl, but then I saw couple of talks by Larry Wall and he seems to be behind perl 6

[22:32] <John[Lisbeth]> I guess I don't know the difference besides a cleaned up syntax and cleaned up type system

[22:32] <sjn> yes, it is, and yes he is

[22:33] <timotimo> i've never done any perl5, so i only know the parts it does worse than p6

[22:33] <timotimo> so obviously i don't like it

[22:33] <sjn> there are a LOT of differences. in fact, Perl 6 isn't based on Perl 5 at all (no common code), but somewhat inspired by the good bits

[22:33] <timotimo> :P

[22:33] <John[Lisbeth]> can you use perl 5 code in your perl 6 scripts though objects or something?

[22:33] <sjn> we'd like to think the bad bits in perl5 have been significantly improved :D

[22:34] <timotimo> yes, you can

[22:34] <sjn> John[Lisbeth]: use Inline::Perl5;

[22:34] <timotimo> Inline::Perl5 for that direction and Inline::Perl6 for the other direction exist and work well

[22:34] *** musiKk_ left
[22:34] <John[Lisbeth]> Can I get perl 6 from my ubuntu repos?

[22:34] <timotimo> yes, but you'll get a ridiculously outdated version

[22:34] <John[Lisbeth]> it's stable aint it?

[22:34] <sjn> much better to follow instructions on perl6.org

[22:34] <timotimo> it's pre-alpha, the one you'll get

[22:35] <John[Lisbeth]> Maybe there's a ppa

[22:35] <timotimo> it'll be lacking many features, and have many bugs, and also be very slow and use a lot more memory than it would if you got it from perl6.org or somewhere else

[22:35] <sjn> John[Lisbeth]: the one you get from following the instructions on perl6.org is up-to-date and stable

[22:36] <John[Lisbeth]> All I care is to get the most recent stable version of perl 6

[22:36] <timotimo> then you can use what perl6.org recommends. rakudo star tarball, or a docker image, for example

[22:36] <John[Lisbeth]> But muh sudo apt-get update && sudo apt-get ugprade

[22:37] * sjn would love that too

[22:37] <lizmat> m: dd :(&foo:(--> Bool)).params[0]  # timotimo: seems wrong to have a post-constraint here?

[22:37] <camelia> rakudo-moar 978754: OUTPUT«Parameter &foo = &foo where { ... }␤»

[22:37] <sjn> maybe drop by the Ubuntu irc channel and ask for it too? :)

[22:37] <John[Lisbeth]> I am sure I can find it on the google machine

[22:37] <timotimo> uh, no clue about that stuff :S

[22:38] *** _nadim left
[22:38] <sjn> package info for ubuntu's rakudo package says the maintainer is Ubuntu Developers [email@hidden.address]
[22:38] <sjn> and Original-Maintainer: Debian Rakudo Maintainers [email@hidden.address]
[22:38] <lizmat> .tell jnthn dd :(&foo:(--> Bool)).params[0]  # seems wrong to have a post-constraint here?

[22:38] <yoleaux> lizmat: I'll pass your message to jnthn.

[22:42] <John[Lisbeth]> I basically have been studying functional programming for 2 years

[22:42] <timotimo> dinner! \o/

[22:42] <John[Lisbeth]> I saw an old video about unix programming and how you can use pipelines to string little programs together making one big process that data flows through to solve a problem

[22:43] <timotimo> lizmat: maybe that's how we implement subsignatures? :(

[22:43] <John[Lisbeth]> foo | bar | baz turned out to be simliar to baz (bar (foo)) in lisp and that took me a couple years to find out

[22:44] <John[Lisbeth]> and now I suppose I am looing for a language that can do what lisp can do with recursion but that can also do other things too.

[22:46] <sjn> Lisp is really nice, but if you'd like something more multi-paradigm, you can't do much better than Perl 6 atm

[22:48] <sjn> Perl 6 has some really nice functional programming features, plus lots of other neat stuff which you can make use of as you want/need 

[22:48] <John[Lisbeth]> can you program lazily?

[22:48] <John[Lisbeth]> or work with inifnite lists?

[22:48] <sjn> yep

[22:49] <sjn> yep

[22:49] *** tardisx joined
[22:49] <John[Lisbeth]> ok then it pretty much satisfies my need. I have an o'rielly book about awk and sed, and then an o'rielly book about bash, and then I'm gonna take on perl 6

[22:49] <sjn> afaic, the canonical example is Perl6's super-short implementation of the fibionacci sequence

[22:50] <sjn> my @fib := 1, 1, *+* ... *;

[22:50] <lizmat> timotimo: oddly enough, there's a separate sub_signature attribute in Parameter

[22:50] <lizmat> ok, I have no inspiration anymore, so I bid you all a good night!

[22:50] <sjn> m: my @fib := 1, 1, *+* ... *; say @fib[20];

[22:50] <camelia> rakudo-moar 978754: OUTPUT«Type check failed in binding; expected Positional but got Seq (?)␤  in block <unit> at /tmp/2sRDvXc48M line 1␤␤»

[22:51] <sjn> oh noes!

[22:51] <lizmat> m: my @fib = 1, 1, *+* ... *; say @fib[20];

[22:51] <camelia> rakudo-moar 978754: OUTPUT«10946␤»

[22:51] <lizmat> sjn: GLR took care of the need for binding

[22:51] <sjn> aah

[22:52] <lizmat> although admittedly, the error is LTA

[22:52] <sjn> ok, so there are some examples out there that need updating

[22:52] <lizmat> very likely  :-)

[22:52] <lizmat> sleep&

[22:52] <sjn> nn!

[22:53] <sjn> John[Lisbeth]: check out perl6intro.com for a soft introduction (there are more learning resources on perl6.org, so you may want to use that as a starting point for your explorations :)

[22:54] *** jjido joined
[23:01] *** BenGoldberg left
[23:02] *** avenj left
[23:02] *** avenj joined
[23:13] *** salva left
[23:20] <timotimo> sjn: how do you program lazily in perl6?

[23:26] <timotimo> i'm a bit saddened that i get so much METAOP_ASSIGN in my code ...

[23:27] * sjn usually lies in bed when programming lazily :)

[23:27] <timotimo> it's understandable that it wouldn't turn it into the resulting code already in the optimizer, because it kind of doesn't know if it'd turn into a list thing or not, so it refuses to do stuff, as it doesn't know how to handle @ or % sigiled vars either

[23:27] *** kjs_ left
[23:28] <timotimo> sjn: i just mean compared to haskell, perl6 doesn't offer "lazy programming"

[23:28] <sjn> ah, sure. 

[23:28] <sjn> although the comparison was more with Lisp

[23:29] <timotimo> what does lisp offer in terms of lazy programming?

[23:29] *** jolts joined
[23:30] <sjn> isn't infinite lists a feature of that?

[23:31] * sjn googles, and is reminded that it's called "lazy evaluation"

[23:31] <timotimo> that's more like "we have iterators" + "our lists don't have to be created by exhausting an iterator"

[23:32] <sjn> but no, I'm guessing type inference isn't (yet?) a haskell-feature Perl 6 has yet...

[23:33] <sjn> and that's a "lazy programming" feature, iirc

[23:33] <timotimo> no, we don't do type inference

[23:34] <timotimo> i'm not sure that counts as "lazy programming"

[23:34] <timotimo> but i may have no idea what you mean by that

[23:34] <timotimo> i was focusing on lazy evaluation

[23:35] <sjn> type inference = "dear compiler: here are the bits and pieces, you figure out what order to run it in" or someting like that :)

[23:35] <sjn> seems pretty lazy to me :D

[23:36] <timotimo> in haskell it's more like "you better have thought this out up front, dear developer. because if your shit doesn't work right 100%, you'll get an error"

[23:36] <timotimo> that's more a "careful programming" feature

[23:37] <sjn> sounds like the type of lazy you find in the Perl communty (cf. "laziness, hubris and impatience" :)

[23:39] *** Laurent_R left
[23:40] <timotimo> m: my @a = 1, 2, 3; @a ,= 2, 3; say @a.perl

[23:40] <camelia> rakudo-moar 978754: OUTPUT«(my \Array_78888720 = [Array_78888720, (2, 3)])␤»

[23:41] <timotimo> i don't think that's useful :D

[23:41] <timotimo> but what do i know

[23:41] <timotimo> i think it's actually a bug

[23:41] <sjn> hm

[23:41] <sjn> wouldn't you use unshift for that?

[23:42] <timotimo> well, yeah, but this is about optimizing METAOP_ASSIGN in more cases

[23:42] <sjn> ah

[23:42] <timotimo> currently it bails out when it can't tell it doesn't get a regular scalar variable

[23:42] <timotimo> i *think* we used to have something to ensure metaop-assign with list-assignment stuff DTRT

[23:45] *** idiosyncrat_ joined
[23:46] <timotimo> i mean ... i guess i can kick out that check and see what the spec tests think

[23:54] *** spider-mario left
