[00:01] <timotimo> well, you can ask for .keys, sort them, put the resulting list into %foo{@keys} and presto

[00:02] <seatek> yeah i'd have to put it in as an option to the thing generating the strings to do sorting first when generating the strings.

[00:03] <seatek> or i could just let my unit tests fail if the key sorting stuff used internally in perl6 ever changes... ;)

[00:03] <seatek> i'm more inlined to do that

[00:04] <seatek> because... well, apple pie ;)

[00:04] *** pierre_ joined
[00:05] <seatek> i could just regex my tests i suppose :) who cares about performance there

[00:05] <seatek> GRAMMAR my tests!

[00:06] <seatek> i need a kitty to stroke

[00:07] *** pyrimidine left
[00:09] *** skids joined
[00:11] <seatek> so $!attrib variables are lexically scoped to the file, not to class inheritance, yes?

[00:12] <seatek> or is everything beginning to blur together?

[00:14] *** pmurias left
[00:16] *** kyclark_ joined
[00:17] *** Vynce joined
[00:19] *** Tonik left
[00:22] <timotimo> https://twitter.com/loltimo - seatek i posted a few cat pictures on the internets today

[00:24] <seatek> timotimo: hehe. perfect :)

[00:24] <Xliff> Hiyo.

[00:24] <Xliff> How can I get warn to return only the string parameter without the extra backtrace?

[00:25] <Xliff> Or better yet, output directly to STDERR

[00:25] <timotimo> use "note"

[00:25] <Xliff> Thankee!

[00:25] <seatek> ok so it's not that $!attr are lexically scoped to files -- they're scoped to the class they are defined in, and they do not get inherited. so you have to use accessors for those, yeah?

[00:26] <seatek> cuz their accessors seem to get inherited

[00:28] <timotimo> yup

[00:29] * timotimo decommutes

[00:30] *** pyrimidine joined
[00:36] *** labster joined
[00:37] *** pyrimidine left
[00:45] *** kyclark_ left
[00:46] *** pierre_ left
[00:46] *** mls joined
[00:52] *** pyrimidine joined
[00:56] *** pyrimidine left
[00:59] *** telex left
[00:59] *** rindolf left
[01:00] *** telex joined
[01:02] *** felher joined
[01:06] *** Vynce left
[01:08] *** aborazmeh joined
[01:08] *** aborazmeh left
[01:08] *** aborazmeh joined
[01:10] *** wamba left
[01:11] *** pyrimidine joined
[01:15] *** ifim joined
[01:15] <ifim> o/

[01:16] *** pyrimidine left
[01:17] <ifim> Hey guys, what's Perl 6 equivalent of __DATA__ blocks?

[01:21] *** pyrimidine joined
[01:22] <MasterDuke> ifim: good question, i'm not exactly sure

[01:23] <geekosaur> https://design.perl6.org/S26.html#Data_blocks

[01:23] <geekosaur> (note, the official docs point here for POD)

[01:25] *** nowan left
[01:26] *** pyrimidine left
[01:26] *** matt_ left
[01:27] *** nowan joined
[01:27] *** Guest86755 joined
[01:31] *** pyrimidine joined
[01:32] *** AlexDaniel left
[01:35] *** pyrimidine left
[01:39] *** pyrimidine joined
[01:44] *** pyrimidine left
[01:45] *** ifim left
[01:46] *** pierre_ joined
[01:48] *** pyrimidine joined
[01:51] *** pierre_ left
[01:55] *** pyrimidine left
[01:57] *** canopus left
[02:10] *** pyrimidine joined
[02:15] *** pyrimidine left
[02:20] *** pyrimidine joined
[02:25] *** pyrimidine left
[02:27] *** kyclark_ joined
[02:27] *** Rawriful left
[02:28] *** pyrimidine joined
[02:30] <raiph> ifim: http://stackoverflow.com/questions/4269140/does-perl6-support-something-equivalent-to-perl5s-data-and-end-sections

[02:31] *** vendethiel joined
[02:34] *** pyrimidine left
[02:37] *** kurahaupo left
[02:39] *** kyclark_ left
[02:40] *** vendethiel left
[02:42] *** canopus joined
[02:46] *** leego left
[02:46] *** ilbot3 left
[02:47] *** pyrimidine joined
[02:47] *** ilbot3 joined
[02:51] *** leego joined
[02:54] *** pyrimidine left
[02:59] *** pyrimidine joined
[03:00] *** amalia_ left
[03:00] *** pierre_ joined
[03:02] *** amalia_ joined
[03:04] *** pyrimidine left
[03:09] *** pyrimidine joined
[03:14] *** pyrimidine left
[03:19] *** pyrimidine joined
[03:19] *** kyclark_ joined
[03:27] *** kyclark_ left
[03:27] *** labster left
[03:40] *** pierre_ left
[03:44] *** noganex_ joined
[03:47] *** noganex left
[03:52] *** ugexe left
[04:00] *** labster joined
[04:25] *** wisti joined
[04:28] *** bjz left
[04:28] *** bjz joined
[05:05] *** aborazmeh left
[05:23] *** Cabanossi left
[05:27] *** Cabanossi joined
[05:34] <Xliff> raiph: Nice job, but you forgot to illustrate how to retrieve the =qux block.

[05:35] <Xliff> Since you pointed it out, it might be nice to illustrate it.

[05:37] <Xliff> Although I have to admit, that access method is rather clumsy. I thought there was a better method.

[05:39] *** xinming left
[05:42] *** cibs left
[05:43] *** cibs joined
[05:54] *** cooper joined
[05:54] *** cooper left
[05:54] *** cooper joined
[06:00] *** rurban joined
[06:00] *** rurban left
[06:33] *** jnthn left
[06:34] *** jnthn joined
[06:36] *** pyrimidine left
[06:36] *** pyrimidi_ joined
[06:37] *** cognominal joined
[06:44] <seatek> Honestly, I don't need to be told this all the time. I know! "Use of Nil in string context" I just don't want to have to check every object for defined-ness before coercing it into a string.

[06:45] <geekosaur> $foo // ''

[06:45] <seatek> can that work in the middle of hash assignments?

[06:50] <Xliff> "In the middle of" ??

[06:51] <seatek> like { subject => $thing // '', text => $another // '' }

[06:51] <seatek> it doesn't error but it keeps it at Nil

[06:52] <seatek> like { subject => $thing.Str // '', text => $another.Str // '' }

[06:52] <seatek> that' sactually what it is

[06:53] <seatek> and $thing and $another are objects

[06:53] <seatek> so i'm sure it's the coersion that' scomplaining

[06:53] <seatek> well, guessing sure ;)

[06:55] <geekosaur> at a guess, you need parens

[06:55] <geekosaur> m: dd Nil.Str

[06:55] <camelia> rakudo-moar fc6d4f: OUTPUT«Use of Nil in string context␤  in block <unit> at <tmp> line 1␤""␤»

[06:55] <geekosaur> so it's the .Str doing it

[06:56] <seatek> yeah

[06:56] <geekosaur> ($thing // '').Str but yuck

[06:56] <seatek> interesting

[06:59] <seatek> oh that works perfectly - thanks geekosaur++ ! yeah pretty yuck but less yuk that incessant obvious complaining!

[06:59] <seatek> pretty soon this is going to be down from 200 transactions/sec to 10

[07:00] *** CIAvash joined
[07:02] *** skids left
[07:05] *** hchienjo joined
[07:06] *** hchienjo left
[07:21] *** darutoko joined
[07:24] *** lizmat left
[07:25] *** rurban joined
[07:30] *** xinming joined
[07:34] *** wisti left
[08:06] *** toolforger joined
[08:17] *** Alikzus left
[08:18] *** Alikzus joined
[08:21] <Xliff> <geekosaur> ($thing // '').Str but yuck

[08:21] <Xliff> Yeees. I've been forced to adopt this idiom, myself.

[08:21] <Xliff> Match objects are particularly.... interesting.

[08:22] <Xliff> So... $/[0] must become ($/[0] // '').Str

[08:27] <seatek> it's like a disgusting fly that lands in the middle of a beautiful, delicious cheesecake

[08:36] *** canopus left
[08:39] <TimToady> m: dd Empty.Str

[08:39] <camelia> rakudo-moar fc6d4f: OUTPUT«""␤»

[08:40] <TimToady> possibly we could return Empty instead of Nil, but we'd have to think about it

[08:40] *** RabidGravy joined
[08:40] <TimToady> or we could give Match a .Str that doesn't complain, but we'd have to think about that too

[08:40] <TimToady> or we could have some universal postfix operator that means // ''

[08:40] <seatek> i'd be happy either way :) not that i'm miserable now. entierely

[08:41] <seatek> i can't remember any more of those

[08:41] <TimToady> well, // has always been at an uncomfortable precedence level, either too tight or too loose

[08:41] *** espadrine joined
[08:41] <seatek> but a cheatsheet is always nice

[08:41] <seatek> ah ok

[08:42] <TimToady> I suppose any other language would just .default('') or some such, but that's too long :)

[08:43] <TimToady> another option, give regex an option to set an "is default" on match objects

[08:43] *** canopus joined
[08:44] <TimToady> there are usually lots of ways to solve anything, and the first one you think of isn't necessarily the best one

[08:45] <seatek> And there will never be a way to solve all the problems.. like wanting an Int... which can't be Nil... and 0 is different too

[08:46] <seatek> That's why I'm thinking turning off the warnings might be good... I'm not sure what good they do anyway in this case.

[08:46] <TimToady> the problem with returning Empty is that nqp doesn't know about it, and regex is actually implemented at a very low level

[08:46] <TimToady> m: dd Empty.Int

[08:46] <camelia> rakudo-moar fc6d4f: OUTPUT«0␤»

[08:46] <seatek> Oh weird

[08:46] <seatek> ok

[08:47] <seatek> That's a real can of worms... I've been trying to get into habits of dealing with the empties and 0's and Nils for Ints

[08:48] <TimToady> yeah, we don't want to let people get too sloppy there, or the opposite problem starts to crop up, where people get '' or 0 and think it's valid data

[08:48] <TimToady> it's all tradeoffs...

[08:49] <TimToady> but I've not been entirely happy with // for years now

[08:49] <seatek> yeah. my last one was in a grammar... where an int wasn't always going to be there... but the make action which coerced it into Int insisted on having something... so i'm making it a string until it comes out of the grammar

[08:49] <seatek> it is handy!!

[08:52] <TimToady> m: sub _ ($x) { $x // Empty }; say +_ Nil; say ~_ Nil

[08:52] <camelia> rakudo-moar fc6d4f: OUTPUT«0␤␤»

[08:54] <seatek> yeah i dont' want the 0 lie if there was just nothing there ;)

[08:55] <seatek> i'm kinda finding that i'm having less trouble not defining types at all until i need to use them for something

[08:55] <TimToady> so that makes the Empty approach not so good, if you want to differentiate

[08:56] <seatek> yes, all the variations of nothing confuse me

[08:56] *** Tonik joined
[08:56] <seatek> but if i keep the int a string, it's happy being empty

[08:57] <seatek> and then i know it's not a 0 ;)

[08:57] <seatek> but it makes me feel a little... shady

[08:59] <seatek> so Ints can be Nil....

[09:00] <TimToady> no, but Int is undefined

[09:00] <seatek> m: my Int $i = Nil;

[09:00] <camelia> rakudo-moar fc6d4f: ( no output )

[09:01] <TimToady> Nil is treated specially there

[09:01] <seatek> I like it :)

[09:01] <TimToady> that just says "set $i to default"

[09:01] *** girafe joined
[09:01] <seatek> ah 

[09:01] <TimToady> but $i doesn't actually ever contain Nil

[09:02] <TimToady> m: my Int $i is default(42) = Nil; say $i

[09:02] <camelia> rakudo-moar fc6d4f: OUTPUT«42␤»

[09:02] <TimToady> m: my Int $i is default(42); $i = Nil; say $i

[09:02] <camelia> rakudo-moar fc6d4f: OUTPUT«42␤»

[09:02] <TimToady> m: my Int $i is default(42); $i = 41; $i = Nil; say $i

[09:02] <camelia> rakudo-moar fc6d4f: OUTPUT«42␤»

[09:02] <seatek> m: my Int $x = Nil ; my $y = Nil; my $x = $y ; say $x;

[09:02] <camelia> rakudo-moar fc6d4f: OUTPUT«Potential difficulties:␤    Redeclaration of symbol '$x'␤    at <tmp>:1␤    ------> 3my Int $x = Nil ; my $y = Nil; my $x7⏏5 = $y ; say $x;␤(Any)␤»

[09:02] *** firstdayonthejob joined
[09:03] <seatek> m: my Int $x = Nil ; my $y = Nil;  $x = $y ; say $x;

[09:03] <camelia> rakudo-moar fc6d4f: OUTPUT«Type check failed in assignment to $x; expected Int but got Any (Any)␤  in block <unit> at <tmp> line 1␤␤»

[09:03] <TimToady> = Nil on the declaration is really a no-op

[09:03] <seatek> gotcha

[09:04] <TimToady> m: my Int $x; my $y;  $x = $y ; say $x;

[09:04] <camelia> rakudo-moar fc6d4f: OUTPUT«Type check failed in assignment to $x; expected Int but got Any (Any)␤  in block <unit> at <tmp> line 1␤␤»

[09:05] *** FROGGS joined
[09:06] * TimToady is required to go sightseeing

[09:07] <TimToady> literally, in this case, since I'm the only driver on the rental car :)

[09:07] <seatek> you you must be very elsewhere!

[09:07] <TimToady> we're very .pt at the moment

[09:08] <seatek> well, i'll just go back to struggling with my nothings some more

[09:08] <TimToady> Lisbon, in fact, but we're heading to Sintra and such

[09:08] *** ocbtec joined
[09:09] *** pierre_ joined
[09:09] *** pierre_ left
[09:09] *** pierre_ joined
[09:09] <seatek> What would be nice is if someone could make it so that Ints on the left would remain happily empty of value if what's on the right is also empty of value

[09:10] <TimToady> we don't often end up with this problem in real life because we do alternations with protos, which means each alternative gets its own action method that triggers only when that rule matches

[09:10] <seatek> actually that's what i was thinking about doing but it's more work that one big hash!

[09:12] <TimToady> afk really &

[09:12] <seatek> hehe :) have fun! :)

[09:17] *** labster left
[09:17] <toolforger> Anybody got an idea why NQP is being built the way it is?

[09:18] <toolforger> I was surprised that NQP is being used to build the next NQP generation

[09:18] <toolforger> it's a cute trick but can cause various issues

[09:26] *** cibs left
[09:28] *** CIAvash left
[09:28] *** cibs joined
[09:34] <psch> toolforger: afaik we mostly do that because we need Perl 6 to be bootstrapped as well

[09:34] <toolforger> Issue is that you cannot be sure what exactly is in the code: Parts of the semantics might be implicit in whatever NQP does

[09:35] <psch> ...is this about trusting trust

[09:35] <toolforger> Ken Thompson, exactly

[09:35] <seatek> dont' look at me.. i'm still confused about the variations of nothing

[09:36] <toolforger> "Reflections on Trusting Trust"

[09:36] <psch> right, i think there was a discussion on github about that recently

[09:36] <psch> either the rakudo or the nqp repo

[09:36] <toolforger> In the days of secret services trying to subvert encryption standards, that's pretty scary

[09:37] *** girafe left
[09:37] <toolforger> Somebody would have to hand-translate everything and see whether it matches what NQP does

[09:38] <psch> https://github.com/perl6/doc/issues/599 is the discussion i was thinking of

[09:38] <toolforger> i.e. whether it matches the output of compiling NQP with NQP

[09:39] <psch> and no, you don't have to manually compile everything, you just have to write a second compiler according to David Wheeler in that discussion

[09:39] <psch> or david-a-wheeler, as per the actual nick

[09:39] <psch> FSDO "just" :)

[09:40] <toolforger> I see it

[09:40] <toolforger> and yes he's right

[09:40] <toolforger> However, if you have a second compiler that does not use the existing NQP blob, you can use that second compiler and do not need that self-compiling NQP anymore

[09:41] <psch> until that second compiler gets subverted

[09:41] <toolforger> he mentions that

[09:41] <toolforger> Personally, I think that can be worked around by making that second compiler so simple that an undergraduate can check it

[09:41] <psch> he mentions that it's unlike to be subverted *in the same way*

[09:41] <toolforger> it need not be fast, just have the same semantics as the official one

[09:42] <psch> but nqp needs to be fast, so we do need the bootstrapping compiler

[09:42] <toolforger> Unfortunately, Patrick's idea that NQP qualifies as a second compiler is not useful as an independent check because it is self-compiling

[09:42] <psch> that is not what pmichaud said

[09:43] <toolforger> I see

[09:43] <psch> i mean, don't get me wrong, not being able to trust trust is a valid concern

[09:44] <toolforger> NP, see your point that Patrick wasn't actually advertising NQP as a trustful agent

[09:44] <psch> and having someone pour time into writing a minimal NQP compiler that can be easily verified and have its results compared to what nqp-{m,j,js} do is a great idea

[09:44] <toolforger> though he is a bit unclear about what exactly NQP does for the situation

[09:44] *** kurahaupo__ joined
[09:45] <psch> but if anything you can only compare semantics, or you're white-room reversing each of nqp-{m,j,js}

[09:45] <psch> because you cannot compare binaries without compiling to the same vm, which means you need to support that same vm

[09:46] *** setty1 left
[09:46] <toolforger> You can compiler compiler outputs

[09:46] <toolforger> let each compiler compile a compiler, then see whether the resulting compilers produce identical results

[09:46] <psch> what are those results that you're comparing?

[09:46] <toolforger> "you can compiler" -> "you can compare"

[09:47] <toolforger> E.g. let Rakudo compile NQP, see whether the resulting compiler produces bit-identical outputs to what original NQP produces

[09:48] <toolforger> Of course one can still subvert the compilers, but now the agency needs to subvert two of them, and they need to keep that up as the compilers evolve to avoid getting caught

[09:48] *** lizmat joined
[09:49] <toolforger> And the more compilers, the merrier

[09:49] <psch> rakudo cannot compile nqp

[09:49] <psch> nqp compiles rakudo

[09:49] <psch> and "bit-identical output" means you're reimplementing MoarVM *and* the JVM

[09:49] <psch> because you cannot trust either of those either

[09:49] <toolforger> No, just compare the binaries that the compilers produce, not the runtimes

[09:50] <psch> the compilers produce bytecode specific to a given VM

[09:50] <toolforger> and every new platform involved is one platform that needs to be subverted, i.e. more teams to be influenced

[09:50] <psch> which means you need to write a backend for that VM

[09:50] <toolforger> there's only so much an attacker can do

[09:50] <psch> which means you need to reimplement the VM to trust it

[09:50] <toolforger> Use a Chinese, a Russian, and a US JVM :-D

[09:51] <toolforger> But... still, NQP compiling itself makes several of this kind of tests easier to subvert

[09:52] <psch> i'm not disputing that, i'm just trying to tell you what needs to be done to fix it :)

[09:52] <psch> or rather, verify it despite that shortcoming

[09:53] <toolforger> David Wheeler's idea isn't really to reimplement everything from scratch, it is about producing independent implementations and observe them for differences

[09:53] <psch> yes, i understand that

[09:53] <stmuk_> I think it might be possible to reproduce the binary blobs with libfaketime and using the same path structure and OS 

[09:54] <stmuk_> or the windows version of libfaketime

[09:54] <toolforger> Yeah, you'd need a fully deterministic compiler

[09:55] <stmuk_> both debian and FreeBSD have done work on reproducable builds

[09:56] <toolforger> I'd actually recommend not putting in date/time or path info into the compiler; this kind of stuff can go into an accompagnying text file, with a hash code to make its contents verifiable against the compiler that it is supposed to go with

[09:56] <toolforger> erm

[09:56] <toolforger> not "into the compiler" but "into the compilation results", sorry

[09:57] *** pyrimidi_ left
[09:59] *** setty1 joined
[10:00] *** maybekoo2 joined
[10:03] <stmuk_> increased use of relative paths seems to help but its a hard problem I think

[10:03] <stmuk_> https://reproducible-builds.org/

[10:09] <stmuk_> "A typical example is creating an archive from the content of a directory. Most filesystems do not guarantee that listing files in a directory will always result in the same order.

[10:15] <toolforger> Sort files then

[10:16] <toolforger> I.e. not really hard, but you need to spot differences, find their causes, and do something to eliminate the difference from the input

[10:16] <toolforger> essentially just debugging

[10:16] <toolforger> we know how to do that :-)

[10:16] <stmuk_> its a huge amount of work

[10:16] <toolforger> It's easier for compilers than for interactive software

[10:18] <toolforger> None of the bullet points seem really hard or a huge amount of work to me

[10:18] <toolforger> The hardest part seems to be the ability to control the C compiler

[10:19] *** wamba joined
[10:19] <toolforger> new compiler version -> different optimizations -> different output

[10:19] <DrForr> Then dig in and get 'em out of the way so we don't have to worry about it :)

[10:19] <stmuk_> well I look foward to trying to reproduce your reproducable build!

[10:19] <toolforger> Heh. That's a good one.

[10:20] <toolforger> Cannot do that, too little, too many things to do

[10:21] <toolforger> *too little time

[10:21] <toolforger> How much C is in a Perl compiler, anyway?

[10:22] <psch> i think Perl 5 is completely in C, and in Perl 6 i think it's only the backends 

[10:23] <toolforger> so we have a bytecode that isn't necessarily optimized - that's a good representation for estabilishing reproducibility

[10:23] <toolforger> we cannot do reproducibility all the way down anyway, that stops at the CPU level

[10:24] <toolforger> and you can have malware in the CPU - most modern CPUs can have their microcode upgraded

[10:24] <stmuk_> and even have a secret JVM inside 

[10:25] <toolforger> I do not think that microcode can to a JVM, or that it would be useful to an attacker

[10:25] <toolforger> *can do

[10:26] <stmuk_> ?

[10:26] <toolforger> But you can do stuff like "see bit pattern 0xdeadbeefdeadbeefdeadbeefdeadbeef on the data bus -> change a CPU instruction to not do some of the usual protected-mode tests"

[10:26] <toolforger> (I do not think that microcode can do a JVM)

[10:26] <psch> what does "do a JVM" mean?

[10:27] <timotimo> it's like "do the mario"

[10:27] <timotimo> "swing your arms from side to side, come on it's time to go! do the mario!"

[10:32] <stmuk_> there is a processor inside the usual processor - the Intel ME - that has the JVM

[10:32] <toolforger> it cannot *implement* a JVM

[10:32] <toolforger> oh right, I forgot about SME

[10:32] <toolforger> or SMM or whatever the abbreviation of the day is

[10:32] <toolforger> That's not microcode though

[10:32] <stmuk_> noone said it did

[10:32] <toolforger> microcode is more like "if you see THIS bitpattern in the instruction stream, activate THESE processing units and THOSE connections between them"

[10:32] <timotimo> nqp is small enough that you can go through the moarvm bytecode it's written in and verify it's okay

[10:32] <timotimo> if you're really worried about this, go ahead

[10:32] <timotimo> you can probably write a good tool that makes moarvm bytecode files less noisy when it comes to changes, so you can better diff stage0 updates

[10:32] <timotimo> really, moarvm bytecode is so sufficiently high level that it's much easier to spot malicious patterns than it would be in x86 assembly for example

[10:33] <stmuk_> diffoscope looked interesting

[10:34] <toolforger> Anything should be easier than x86 assembly :-)

[10:35] <toolforger> still, it's quite a lot of bytecode

[10:35] <toolforger> 442.5k serialized form in nqp.jar

[10:35] *** pyrimidine joined
[10:36] <timotimo> well, that's jvm bytecode

[10:36] <toolforger> no, the nqp.serialized resource

[10:36] <toolforger> not the .class inside the jar

[10:36] <timotimo> well, the serialized blob isn't as interesting as the bytecode itself

[10:37] <toolforger> Isn't the serialized blob the bytecode?

[10:37] <timotimo> no

[10:37] <toolforger> What is it, then?

[10:37] <timotimo> objects

[10:37] <timotimo> we don't yet have a tool to conveniently dump it. i've written something cute in the past, but it's extremely limited

[10:38] <timotimo> but since you can't jump to an unconstrained point in bytecode from mvm, you can't do something nasty like ROP with existing code

[10:38] <psch> oh that reminds me

[10:38] <toolforger> well ok - nqp.class is 984 k, that's a whole mouthful even if it is a multiple of the original bytecodes

[10:38] <timotimo> you can only jump into the beginning of a frame and it'll pretty much always do argument verification such that you can't call every target from every call

[10:40] <psch> .tell pmurias "nqp bytecode" meant JAST here https://irclog.perlgeek.de/perl6/2016-10-25#i_13463907 which was just a case of me not picking the right words, as an AST clearly isn't bytecode...

[10:40] <yoleaux> psch: I'll pass your message to pmurias.

[10:40] <timotimo> toolforger: hae you tried moar --dump nqp.moarvm > hugefile?

[10:40] *** pyrimidine left
[10:40] <timotimo> it's got only 103k lines on my end

[10:40] <timotimo> ... *cough*

[10:40] <toolforger> @timotimo The attack vector is not that somebody does remote code execution, it is that one of the Perl developers is secretly paid by the NSA and commits a stage0 blob that contains malicious or merely dubious (and later-found-to-be-exploitable) implementation

[10:41] <stmuk_> yes we know

[10:41] <timotimo> of course

[10:41] <timotimo> i'm just saying the analysis needs to be a lot less wary of nasty tricks

[10:41] <toolforger> then why think about ROP techniques? That's not what happens in this scenario

[10:42] <toolforger> I'm pretty sure people will think of other nasty tricks

[10:42] <timotimo> ROP would be a way to make malicious code much harder to find

[10:42] *** pyrimidine joined
[10:42] <toolforger> not necessary

[10:43] <toolforger> One of the OpenSSL compromises was "just sloppy code"

[10:43] <timotimo> it could make malicious code easier to find, i guess?

[10:43] *** lizmat left
[10:43] <toolforger> we don't even know if it was paid sloppiness or just what happens if you do not pay attention to every single detail

[10:43] <timotimo> OK

[10:44] <timotimo> so how about going through history and using the latest version of nqp at that time to try to re-build the stage0 files and seeing what the differences are?

[10:44] <toolforger> that didn't help OpenSSL... and that particular sloppiness I read about was there for years

[10:44] <timotimo> that was more about an earlier thing you wrote

[10:44] <timotimo> but anyway

[10:45] <timotimo> yeah, you may not want to trust any compiled language, or any program written by anybody else

[10:45] <stmuk_> js doesn't have a stage0 .. how does it bootstrap?

[10:45] <timotimo> probably from nqp-moar

[10:46] *** obfusk_ left
[10:46] *** obfusk joined
[10:46] *** firstdayonthejob left
[10:48] <timotimo> what are we going for with this discussion anyway? i missed the beginning

[10:49] <toolforger> I was a bit concerned about NQP reproducing its stage0 directory from stage0

[10:49] <stmuk_>  HLL::Backend::JavaScriptAndMoar 

[10:49] <timotimo> well, nqp reproduces its stage0 through stage2

[10:49] <toolforger> which in turn depends on stage0

[10:50] <timotimo> right

[10:50] <toolforger> such dependency cycles make it impossible to "just read the source to infer the semantics"

[10:50] <timotimo> right. hence, i was telling you about the bytecode stuff

[10:51] <toolforger> is there a way to dump the bytecode to human-readable form?

[10:51] <timotimo> yes, i told you :)

[10:51] <timotimo> moar --dump. you'll need to pipe it to a file because it doesn't bother making stdout blocking before writing

[10:52] <timotimo> so if you don't output directly to a file, you'll lose everything after the first mouthful

[10:52] <toolforger> no problem with that

[10:52] <stmuk_> reproducing stage0 needs paths like c:\consulting\ :)

[10:52] <toolforger> lol

[10:52] <toolforger> runs counter to /usr/bin/independent/verification though

[10:52] *** kurahaupo__ left
[10:53] <toolforger> or at least makes it harder, and less likely to actually happen

[10:53] <toolforger> anyway, I'm not so much after fixing the situation, more after understanding it

[10:55] <toolforger> Is there a complete description & semantics of the AST somewhere? that would be helpful, too

[10:56] *** lizmat joined
[10:56] <toolforger> oh. high-priority RL interrupt. Will be back in a few hours.

[10:57] <timotimo> check nqp/docs/

[10:59] *** rindolf joined
[11:06] *** bjz left
[11:13] *** BenGoldberg joined
[11:14] *** pierre_ left
[11:15] *** kurahaupo__ joined
[11:32] <seatek> wow I went away to do some yoga and everyone goes all X-files here!

[11:33] <timotimo> a friend points out that in order to counter the problem of untrusted stage0 we'd have to have a different nqp compiler that can create the stage0 blob from the original nqp code

[11:35] <seatek> or we could just figure out who the government mole is here

[11:36] *** rurban left
[11:36] <psch> i'm fairly sure it's not me, fwiw

[11:36] <timotimo> i'd love to be funded by NSA money. i'm so barely productive as it is, and nothing gets past jnthn and jimmyz

[11:36] <seatek> i bet it's viki

[11:36] <timotimo> i'd basically suck the NSA dry with no benefit to them, no danger to any users

[11:37] <psch> i'd need to see metrics to support that

[11:37] <psch> like, commit frequency or something

[11:38] <seatek> who's this toolfoger? i bet it's him. he'll show up with some binary to "help" in the next few days

[11:38] <RabidGravy> I have to say my Perl 6 productivity has hit the skids since I got a "proper job"

[11:38] <timotimo> :)

[11:38] <timotimo> poor skids

[11:38] *** pmurias joined
[11:39] <psch> hah, yeah, the "proper job"

[11:39] <psch> i got one too

[11:39] <psch> it's horrible

[11:40] <stmuk_> https://www.staustellbrewery.co.uk/proper-job 

[11:40] <timotimo> so god went ahead and tested Proper Job ...

[11:40] <pmurias> being a NSA mole seems like a "proper job"

[11:40] <yoleaux> 10:40Z <psch> pmurias: "nqp bytecode" meant JAST here https://irclog.perlgeek.de/perl6/2016-10-25#i_13463907 which was just a case of me not picking the right words, as an AST clearly isn't bytecode...

[11:40] <seatek> mmm

[11:42] <psch> i mean, seriously

[11:42] <psch> i do know it's kind of industry standard, but disregarding your trained professionals advice to adopt a given process because you don't understand it is just weird

[11:43] <psch> because testing and specifications are clearly time sinks without any RoI vOv

[11:44] <psch> but yeah, that's apparently normal :l

[11:46] <seatek> it's probably a trust thing

[11:46] <timotimo> testing and specifications are just stuff from the ivory tower

[11:48] <seatek> i've found that if you lead people who don't understand something, in a very simple way, to why they maybe should consider things this way, it often works

[11:48] <seatek> but that's not always easy to do

[11:49] <seatek> they can just turn off if you spew too much at once, or get frustrated with them for being so dim

[11:50] <seatek> i think that have trust in, if you can explain it simply, then maybe you know something about it

[11:51] <seatek> and then you seduce them further, and lock them into contracts! and everyone's happy :)

[11:52] <seatek> i know very little about the Windows world though. they seem to only trust things where you spend the most money

[11:52] *** ggoebel left
[11:52] <seatek> it's weird

[11:59] *** bjz joined
[12:04] *** pierre_ joined
[12:06] *** dogbert17 joined
[12:06] <psch> seatek: well, it's the companys owner that would have to be convinced

[12:06] <psch> seatek: and literally every employed developer already tried at least once

[12:06] *** pierre_ left
[12:07] <dogbert17> o/

[12:07] <timotimo> :o

[12:07] <dogbert17> hi timotimo

[12:07] <dogbert17> .seen moritz

[12:07] <yoleaux> I saw moritz 11 Nov 2016 16:07Z in #perl6: <moritz> Cole_ns: wow, that's a nice short one!

[12:07] <masak> \o

[12:07] <timotimo> o/

[12:08] <dogbert17> star: say 'o/'

[12:08] <camelia> star-m 2016.04: OUTPUT«o/␤»

[12:08] <dogbert17> shouldn't we upgrade this

[12:08] <seatek> psch: sounds like you may have a fool on your hands there. either that or a very insightful one who's willing to stand against the tide

[12:09] <seatek> psch: some kind of extreme at least :)

[12:09] <psch> seatek: to me it seems mostly like the normal amount of change resistance

[12:09] <psch> seatek: the business is some 10+ years old and back then they didn't write tests either and everything was fine

[12:10] *** pierre_ joined
[12:11] <seatek> psch: ah, flying by the seat of the pants. i like that myself. but tests... i've begrudgingly come to really appreciate them. i can practically build a whole system all in just tests. it has too many benefits. surely he'll see that

[12:12] <psch> seatek: i trust the other employees when they say they tried a lot but gave up and don't think i have better chances, honestly.  i'll just run with it until something better comes along i think

[12:14] <masak> seatek, psch: I find a lot of resistance to tests out there. I suspect it's because tests and TDD are difficult to knowledge-transfer.

[12:14] <masak> why that is, I don't know

[12:14] <masak> maybe it's the "eating your vegetables" effect

[12:15] <seatek> yeah i used to look at it like that

[12:15] <seatek> why bother when you can get some real work done!

[12:16] <seatek> kinda surprised me when i found i was getting even more work done by writing tests. and being much more compartmentalized in my coding too

[12:17] <seatek> that's s weird hump for people to get over

[12:17] <seatek> i guess

[12:17] <masak> yes, good point

[12:17] <masak> it's a "local maximum" vs "global maximum" thing

[12:17] <masak> or at least local vs better local :)

[12:18] <seatek> :) yeah. i gives me so much more confidence to make changes too, that i don't know what the side-effects might be

[12:18] <seatek> i can't imagine not doing them any more

[12:18] <seatek> but i used to hate hate hate the thought of them

[12:19] <psch> i do think that's the two big things, yeah

[12:19] <psch> i mean, the "eating your vegetables" effect and "i could do real work instead"

[12:20] <seatek> gawd i even like broccoli now

[12:20] *** CIAvash joined
[12:20] <seatek> what's happened to me?

[12:20] <masak> the testing mentality makes you like broccoli

[12:20] <seatek> and spinach!

[12:22] *** aindilis left
[12:28] <stmuk_> worked for popeye

[12:29] <masak> as a post-testing person, I find it challenging to describe the post-testing world to pre-testing people

[12:29] <masak> I'm guessing the Curse of Knowledge ends up interfering too

[12:31] <seatek> i think i sometimes write too many tests. i get obsessed with fringe cases. 

[12:31] <seatek> i suppose that's the danger

[12:31] <masak> I don't see it that way, to be honest

[12:31] <pmurias> masak: isn't liking broccoli a genetic thing?

[12:31] <masak> that's the "drive" part of TDD

[12:31] <masak> you write tests if and when you want to get somewhere

[12:32] <pmurias> masak: as broccoli used to be really harmfull and some people evolved a distaste for it

[12:32] <seatek> yeah

[12:32] <masak> but I guess the other half of that is, um, "model satisfaction" or whatever

[12:32] <seatek> harmful? lies of the broccoli haters!

[12:33] <masak> I don't stop until I feel I've grokked what I'm implementing

[12:33] <timotimo> i really like eating broccoli

[12:33] <seatek> i dont' stop either. but sometimes i get mad when i have to refactor some code and then go redo tests. anger!

[12:34] <seatek> that was a lot of today for me actually

[12:34] <seatek> i'm cranky now

[12:34] <seatek> stupid tests

[12:34] <seatek> now i have broccoli on the brain too

[12:35] <timotimo> you have "broccoli of the brain"? :)

[12:35] <seatek> it's calling to me

[12:35] <masak> seatek: "I have to re-do my tests when I refactor my code" is seriously a whole chapter in a book I should probably write

[12:35] <seatek> cauliflour

[12:36] <masak> seatek: at least that's a legit concern. but there are also ways to mitigate that, and make tests more future-resilient

[12:36] <seatek> masak: please include stress-relieving practices in that chapter

[12:37] <seatek> i'm relying on perl forever keeping the way it returns .keys the same as it is now in my tests. 

[12:37] <seatek> because i was too lazy to fully implement a foolproof testing way just yet

[12:38] <seatek> hahahaha! it will cause me pain one day soon! ahahahahaha!

[12:38] <seatek> i look forward it!

[12:38] <seatek> but today i am free!

[12:38] <masak> oh, with .keys it's pretty simple

[12:38] <masak> most of the time you want to sort the keys and assert on the result

[12:39] <masak> but as for the future-resilience, probably the most important factor is to get away from asserting on getters and start thinking in terms of asserting on events/consequences

[12:39] <seatek> i'm not completely dim...  but it's generating strings.... from those keys... output of strings. i could sort, but there's never a need to in the code

[12:40] <seatek> yeah... i've been doing that more with database stuff

[12:41] <seatek> i was thinking about using grammars to test these strings

[12:41] <seatek> that are made from keys

[12:41] <seatek> but it feels excessive in tests :)

[12:41] <masak> interestingly enough, writing tests in this way forces one to care a lot about what the API surface should be

[12:41] <masak> which is a good thing

[12:42] <masak> when the tests start to come out well-written, that's usually a good sign for the API as well :)

[12:42] <seatek> yeah i'm trying to trick myself i think. but i'll never say for sure

[12:42] <seatek> that's what i'm loving about grammars actually

[12:43] <seatek> it's turning out to be a really good way for me to clearly document

[12:43] <seatek> I just hate Integers in grammars though

[12:43] <seatek> they seem more friendly to strings

[12:44] <seatek> I wish Integers could be empty

[12:45] <seatek> or if they are on the left, empty, something on the right that's empty would mean that it just stays empty

[12:45] <seatek> it would save so much seemingly pointless checking

[12:45] <jnthn> seatek: Got an example of what you mean?

[12:46] * jnthn isn't sure what "integers in grammars" mean

[12:47] <seatek> like when you're matching... and you go to an action

[12:47] <seatek>  subject-id => $<data>.made[0].Int   

[12:47] <seatek> if made[0] is empty... EVERYTHING DIES

[12:47] <psch> m: my @a; say @a[0].?Int

[12:47] <camelia> rakudo-moar dd7b05: OUTPUT«Nil␤»

[12:48] <psch> warning, that's actually misleading cause it's not about empty or not but about "can you Int" and it could potentially can Int and still die :P

[12:48] <psch> m: my @a = "foo"; say @a[0].?Int

[12:48] <camelia> rakudo-moar dd7b05: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5foo' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[12:48] <psch> m: my @a = "foo"; say $_ with @a[0].Int # probably more sensible there

[12:48] <camelia> rakudo-moar dd7b05: ( no output )

[12:48] <psch> m: my @a = "10"; say $_ with @a[0].Int # probably more sensible there

[12:48] <camelia> rakudo-moar dd7b05: OUTPUT«10␤»

[12:57] <seatek> The best I can do is get it to give me a 0 if nothing was there -- but nothing doesn't mean 0

[12:58] <seatek> i need to test for emptiness first before assigning the key, or else just use a string, and worry about it being an Int later.  ;)

[12:58] <seatek> that's the course i took 

[12:59] <seatek> m: my $a; $a{'b'} = ''; say $a{'b'}.Int

[12:59] <camelia> rakudo-moar dd7b05: OUTPUT«0␤»

[12:59] <seatek> m: my $a; $a{'b'} = Empty; say $a{'b'}.Int

[12:59] <camelia> rakudo-moar dd7b05: OUTPUT«0␤»

[13:00] <seatek> m: my $a; $a{'b'} = Nil; say $a{'b'}.Int

[13:00] <camelia> rakudo-moar dd7b05: OUTPUT«No such method 'Int' for invocant of type 'Any'␤  in block <unit> at <tmp> line 1␤␤»

[13:01] <timotimo> assigning Nil reverts a container to its default value

[13:01] <seatek> m: Int $i = Nil

[13:01] <camelia> rakudo-moar dd7b05: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3Int7⏏5 $i = Nil␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        statement modif…»

[13:01] <seatek> m: my Int $i = Nil

[13:01] <camelia> rakudo-moar dd7b05: ( no output )

[13:01] <seatek> yeah

[13:03] <timotimo> i wonder what performance characteristics a halite.io bot written in perl6 would have

[13:03] <seatek> I mean, is "Empty" 0? Is '' 0 ? I mean really, in reality? ;)

[13:03] <psch> m: grammar G { token TOP { $<a>=\d? { make (my Int $x = +$<a>) } } }; G.parse("").ast.say

[13:03] <camelia> rakudo-moar dd7b05: OUTPUT«0␤»

[13:03] <timotimo> i.e. what kinds of stuff you'd be able to do in the one second you're allowed to spend per turn

[13:03] <timotimo> Empty is an empty list. when you .Int a list, you get the number of its elements

[13:03] <psch> "in reality" is kinda weird there tbh

[13:03] <psch> reality doesn't really have types

[13:04] <seatek> ah! how about an empty string? 

[13:04] <timotimo> m: say +""

[13:04] <camelia> rakudo-moar dd7b05: OUTPUT«0␤»

[13:04] <seatek> reality has so many types!

[13:04] * timotimo BBL

[13:05] <seatek> now, if Empty means list, does '' mean... 0? No strings? Aren't no strings also Empty?

[13:05] <seatek> And how can a string be 0 then?

[13:05] <psch> and empty Str isn't Empty

[13:05] <psch> s/and/an/

[13:05] <seatek> hehe ;)

[13:07] *** pyrimidine left
[13:07] <seatek> m: say so Empty ~~ 0 ; say so 0 ~~ Empty

[13:07] <camelia> rakudo-moar dd7b05: OUTPUT«True␤False␤»

[13:07] <seatek> i'm going to cry

[13:07] <psch> ehh, that comparision is kinda flawed

[13:08] <psch> 'cause the RHS decides how to treat the LHS

[13:08] *** rurban joined
[13:08] *** ggoebel joined
[13:08] <psch> m: say so Empty ~~ { +$_ eqv 0 }; say so Empty ~~ { ~$_ eqv 0 }

[13:08] <camelia> rakudo-moar dd7b05: OUTPUT«True␤False␤»

[13:10] *** pyrimidine joined
[13:10] <seatek> I contend then, that since the right is so smart, Int should be smart enough not to set itself to 0 on ''

[13:11] <seatek> it's like Int can never be anything but an Int... unless you've not touched it yet

[13:11] *** BenGoldberg left
[13:11] <seatek> it's happily an Int when you define the attribute....

[13:11] <seatek> happily empty

[13:11] <seatek> but the minute you touch it or look at it, you can never get it back to that happy, empty state

[13:12] <seatek> oh my gosh i'm so tired i dont' even know if what i'm saying makes any sense.... :)

[13:13] <seatek> i love ints

[13:13] <seatek> i'm going to fall asleeping counting ints

[13:13] <psch> m: say +Int

[13:13] <camelia> rakudo-moar dd7b05: OUTPUT«Use of uninitialized value of type Int in numeric context␤  in block <unit> at <tmp> line 1␤0␤»

[13:13] <seatek> or rats maybe

[13:13] <psch> already 0

[13:13] <psch> just warns

[13:14] <seatek> yeah string does the same warnings when it's not defined and you try to coerce it

[13:15] *** pyrimidine left
[13:15] <seatek> i have test for defined ness like this:

[13:15] <seatek> subject    => ($<subject><sym> // '').Str

[13:15] <seatek> hideous

[13:15] <seatek> but it works!

[13:16] <seatek> i need to just separate out those actions to each element individually instead of trying to assign them all at once into a hash

[13:17] <seatek> i mean those don't kill the script, you just get hundreds of warnings flyuing by

[13:17] <psch> m: no warnings; say ~Str

[13:17] <camelia> rakudo-moar dd7b05: OUTPUT«===SORRY!===␤Don't know how to 'no warnings' just yet␤»

[13:17] <seatek> like, yes, sweety, i know it's undefined...

[13:17] <psch> ah hm

[13:18] <seatek> yeah :)

[13:18] <seatek> i like a helpful program... but it's downright naggy with this one

[13:18] *** pierre_ left
[13:19] <seatek> oh my gosh.. night night. sorry if i'm crazy just now... zzzzzZzzz :) 

[13:19] *** seatek left
[13:25] *** pmurias_ joined
[13:31] *** pyrimidine joined
[13:31] *** aborazmeh joined
[13:31] *** aborazmeh left
[13:31] *** aborazmeh joined
[13:32] *** dogbert17 left
[13:33] *** pyrimidine left
[13:39] *** pyrimidine joined
[13:40] *** dogbert17 joined
[13:44] *** pyrimidine left
[13:49] *** pyrimidine joined
[13:53] *** pyrimidine left
[13:58] *** pyrimidine joined
[13:58] *** AlexDaniel joined
[14:03] *** pyrimidine left
[14:03] *** pecastro joined
[14:04] *** Guest86755 is now known as matt_

[14:06] *** pyrimidine joined
[14:09] <moritz> \o

[14:10] <[ptc]> o/

[14:12] *** pyrimidine left
[14:14] *** aborazmeh left
[14:21] *** kyclark_ joined
[14:22] *** cdg joined
[14:22] *** Rawriful joined
[14:26] *** CIAvash left
[14:30] *** kurahaupo__ is now known as kurahaupo

[14:31] <dogbert17> moritz, are you there?

[14:41] <moritz> dogbert17: which "there" are you talking about? :-)

[14:42] <dogbert17> in Germany :-)

[14:42] *** japhb left
[14:43] <dogbert17> moritz: was just gonna ask if you know who might be able to update Star, it's getting a bit old I think

[14:44] <raiph> .tell Xliff Aiui the only thing that makes a data block in P6 a data block is that it's a pod block called 'data'. So the 'foo' and 'qux' blocks don't count. I'll tighten the SO lang to try make that clearer.

[14:44] <yoleaux> raiph: I'll pass your message to Xliff.

[14:45] *** kyclark_ left
[14:49] *** vendethiel joined
[14:50] *** sufrostico left
[14:51] <moritz> dogbert17: wasn't there a 2016.10 star release already?

[14:52] <dogbert17> moritz: yes, I mean the evalbot

[14:53] <dogbert17> star: say 'hello'

[14:53] <camelia> star-m 2016.04: OUTPUT«hello␤»

[14:55] <moritz> dogbert17: oh.

[14:59] <AlexDaniel> dogbert17: sometimes committable works too

[14:59] <AlexDaniel> (but it does not have all the modules installed)

[14:59] <AlexDaniel> commit: 2016.10 say ‘hello’

[14:59] <committable6> AlexDaniel, ¦«2016.10»: hello

[15:00] <AlexDaniel> committable6: stdin reset

[15:00] <committable6> AlexDaniel, STDIN is reset to the default value

[15:00] <dogbert17> AlexDaniel: good to know, there are so many cool bots hanging around nowadays :)

[15:02] <AlexDaniel> https://github.com/perl6/doc/issues/711#issuecomment-235414744 for the list :)

[15:05] <dogbert17> AlexDaniel: thx for the link

[15:06] <moritz> star: say 42

[15:06] <camelia> star-m : OUTPUT«42␤»

[15:07] *** pyrimidine joined
[15:07] <moritz> star: say 42

[15:07] <camelia> star-m : OUTPUT«42␤»

[15:08] <dogbert17> moritz: oh, is this the latest and greatest?

[15:08] <moritz> dogbert17: yes, it just doesn't know it yet

[15:08] <dogbert17> :-)

[15:08] <dogbert17> moritz++

[15:09] <moritz> star: say 6 * 8

[15:09] <camelia> star-m 2016.10: OUTPUT«48␤»

[15:10] *** rjbs left
[15:10] *** rjbs joined
[15:11] *** pyrimidine left
[15:16] *** pyrimidine joined
[15:18] *** vendethiel left
[15:21] *** pyrimidine left
[15:23] *** rurban left
[15:25] *** sufrostico joined
[15:26] *** pyrimidine joined
[15:31] *** pyrimidine left
[15:36] *** pyrimidine joined
[15:37] *** bjz left
[15:42] *** BenGoldberg joined
[15:43] *** pyrimidine left
[15:44] *** cdg left
[15:52] *** maybekoo2 left
[15:53] *** pyrimidine joined
[16:00] *** pyrimidine left
[16:06] *** pyrimidine joined
[16:09] <dogbert17> doc question: type-graph.txt contains both 'class X::Augment::NoSuchType does X::Comp' and 'class X::Augment::NoSuchType does X::Syntax'. Shouldn't the second one be removed? See https://github.com/rakudo/rakudo/blob/nom/src/core/Exception.pm#L1738

[16:10] <psch> m: say X::Augment::NoSuchType.^roles

[16:10] <camelia> rakudo-moar aa86b9: OUTPUT«((Comp))␤»

[16:10] <psch> m: say X::Comp.^roles

[16:10] <camelia> rakudo-moar aa86b9: OUTPUT«()␤»

[16:10] *** ocbtec left
[16:10] <psch> Augment::NoSuchType doesn't really seem syntax-y to me either, fwiw

[16:10] *** pyrimidine left
[16:10] <psch> just from a "do the names make sense there" perspective, y'know :)

[16:11] <dogbert17> psch++, I will remove it :)

[16:11] <MasterDuke> my class X::Augment::NoSuchType does X::Comp {

[16:11] <MasterDuke> in src/core/Exception.pm

[16:11] <MasterDuke> so yeah, the second one seems wrong

[16:12] <dogbert17> and away it will go :-)

[16:15] <dalek> doc: f0ab29c | (Jan-Olof Hendig)++ | type-graph.txt:

[16:15] <dalek> doc: class X::Augment::NoSuchType does not do X::Syntax. psch++, MasterDuke++

[16:15] <dalek> doc: review: https://github.com/perl6/doc/commit/f0ab29c96b

[16:17] <dalek> doc: a0de2a5 | (Jan-Olof Hendig)++ | type-graph.txt:

[16:17] <dalek> doc: enum Order is Int was listed twice

[16:17] <dalek> doc: review: https://github.com/perl6/doc/commit/a0de2a5288

[16:18] <dogbert17> the second commit should hopefully solve https://github.com/perl6/doc/issues/984

[16:33] *** lizmat left
[16:36] *** cdg joined
[16:36] *** cdg_ joined
[16:40] <AlexDaniel> awww, it is no longer visible how the graph looked in the past!

[16:40] <AlexDaniel> anyway, dogbert17++

[16:40] <timotimo> why didn't anybody tell seatek about "quietly"?

[16:40] *** cdg left
[16:41] <psch> timotimo: i keep forgetting we have that

[16:41] <psch> i tried 'no warnings' though..? :P

[16:42] <geekosaur> I think quietly didn't quiet that last time I tried. things continue to evolve...

[16:42] <AlexDaniel> timotimo: I have not seen the question. Does it sound like a good excuse? :)

[16:43] <psch> m: say quietly +Int

[16:43] <camelia> rakudo-moar aa86b9: OUTPUT«0␤»

[16:43] <psch> m: say quietly ~Int

[16:43] <camelia> rakudo-moar aa86b9: OUTPUT«␤»

[16:43] <timotimo> sounds good to me

[16:44] *** firstdayonthejob joined
[16:45] *** troys joined
[16:45] *** pyrimidine joined
[16:50] *** pyrimidine left
[16:52] <dalek> doc: 213b76c | (Jan-Olof Hendig)++ | type-graph.txt:

[16:52] <dalek> doc: Fixed typo

[16:52] <dalek> doc: review: https://github.com/perl6/doc/commit/213b76c1db

[16:55] *** Actualeyes joined
[17:01] <pmurias_> toolforger: re reproducibility if we verified that all the blobs in the repo where in fact built with nqp versions from the repo wouldn't we be protected against new blob backdoors

[17:01] *** pmurias_ left
[17:04] *** cyphase left
[17:08] *** cyphase joined
[17:10] <toolforger> yes, that's why I have such a dislike against those blobs.

[17:11] <toolforger> They don't have source code

[17:12] <toolforger> no comments that explain what they are, which objects are in and why

[17:12] <toolforger> Maybe these compile-from-yourself problems are really just a special case of uninspectable-binary-blob problems

[17:33] *** rurban joined
[17:34] *** b2gills left
[17:34] <RabidGravy> as a complete change of subject has anyone got any better solutions for multiple version implementations of, say, a protocol in the same module than having multiple roles named for the versions?

[17:35] *** b2gills joined
[17:35] *** b2gills left
[17:35] *** b2gills joined
[17:35] <RabidGravy> I'm almost wanting something like "module Protocol { class Foo:ver<0.1> { }; class Foo:ver<0.2> { } }" to work

[17:36] <psch> you could make Protocol::Foo a factory i guess

[17:36] <psch> not sure we have anything better there

[17:36] <psch> but that kinda syntax might work out with a bit of MOP tweakery for a factory

[17:37] <psch> like, it generates a Protocol::Foo.new(:$ver) and DTRT

[17:37] <RabidGravy> yeah which goes back to the versioned named roles or similar

[17:37] <psch> yeah, it does, just a bit fancy looking with some more startup overhead in the grammar 

[17:37] <psch> or well, precomp overhead i suppose

[17:38] <RabidGravy> or something like long names in the provides section of the META

[17:38] <psch> or do it php-ish, and have Protocol::Foo.do_thing_via_ver1 :P

[17:41] *** troys is now known as troys_

[17:45] <pmurias> toolforger: re uninspectable, even if we had a disassembler nobody would read throught all the generated code

[17:45] <toolforger> that's exactly my point

[17:45] <timotimo> we do have a disassembler, though

[17:45] <toolforger> I am wondering though - how were these blobs generated initially?

[17:45] <timotimo> oh, wait

[17:45] <timotimo> you mean reconstructing the original code

[17:45] <timotimo> gotcha

[17:46] <timotimo> toolforger: the very first version of nqp was written in PIR

[17:46] <toolforger> oh

[17:46] <timotimo> once we had an nqp, we added more features in nqp, then re-built the PIR from the nqp source code

[17:46] <timotimo> more and more code got turned into nqp code and more and more PIR got phased out

[17:46] <timotimo> eventually we got extra backends

[17:46] <timotimo> we then used a cross-compilation setup to build stage0 for new backends

[17:47] <timotimo> i.e. nqp-parrot ran, compiled itself, but spat out jvm or moarvm bytecode

[17:47] <toolforger> wow

[17:47] <toolforger> that's really far from any source code that ever existed

[17:49] * timotimo BBL

[17:49] <pmurias> I guess we could reconstruct something with the readability of the orginal PIR code base from the moarvm bytecode

[17:50] *** sufrostico left
[17:50] <toolforger> which wouldn't be much of readability, right?

[17:50] <timotimo> it'd be a noticable bit better

[17:50] <timotimo> have you already tried moar --dump?

[17:51] <toolforger> no

[17:51] <toolforger> I think I'll have to revisit that doc directory first

[17:51] <timotimo> well, it'll be helpful for this topic if you knew the readability-related properties of moar bytecode

[17:51] <toolforger> true

[17:51] <timotimo> nqp's doc folder, yes?

[17:51] <toolforger> yep

[17:51] <timotimo> ops.markdown is particularly helpful for reading moar bytecode

[17:51] * timotimo BBL for real

[17:52] <toolforger> I think I read that, but could not make much from it

[17:52] <toolforger> maybe it's going to be better on the second time, with more background info

[17:57] <AlexDaniel> Some positive trend here https://github.com/perl6/doc/issues/561

[17:57] <AlexDaniel> dogbert17: perhaps see this ↑

[17:59] <AlexDaniel> who knows, maybe you'll find something fixable

[18:00] * [ptc] just typed `aptitude install perl6` for the first time.  It felt soooo good :-)

[18:00] *** Sgeo_ left
[18:00] <AlexDaniel> [ptc]: and what version did it install? :)

[18:01] <AlexDaniel> … also, don't forget to remind us when ｢aptitude install zef｣ starts working…

[18:01] <[ptc]> AlexDaniel: 2016.10 :-)

[18:01] <geekosaur> if they're on testing then it's fairly recent

[18:02] <[ptc]> the Debian Perl team has been doing a sterling job with keeping the packages up to date

[18:02] <AlexDaniel> for about a year now, yes

[18:02] *** espadrine left
[18:03] *** pyrimidine joined
[18:08] *** rurban left
[18:10] *** pyrimidine left
[18:13] *** sufrostico joined
[18:18] <dogbert17> AlexDaniel: will take a look

[18:24] *** ggoebel left
[18:25] <TimToady> geekosaur: you probably noticed 'quietly' not working on compilation warnings...which it doesn't...

[18:26] <geekosaur> no, it spawned a discussion about what things should be suppressable and what shouldn't

[18:26] *** raiph left
[18:27] <geekosaur> although now that I think back, it may have been about the perl 5-ism warnings, which weren't suppressible at the time

[18:27] <TimToady> those are compiler warnings, not run-time, generally

[18:27] <geekosaur> mm, right, so that wouldn't have been it.

[18:27] <TimToady> quietly is dynamically scoped to run time

[18:27] <geekosaur> ...and would not have been this because I am specifically recalling it being about Nil warnings

[18:27] <geekosaur> which would be runtime

[18:28] <geekosaur> so I don't recall why they weren't being suppressed :/

[18:32] <TimToady> well, if they were constant folded, they could happen at compile time

[18:33] <TimToady> but match objects shouldn't be doing that

[18:38] *** Sgeo_ joined
[18:38] <dalek> doc: 67e6927 | (Jan-Olof Hendig)++ | doc/Type/ (3 files):

[18:38] <dalek> doc: Fixed a few broken links

[18:38] <dalek> doc: review: https://github.com/perl6/doc/commit/67e6927ac8

[18:38] *** pyrimidine joined
[18:39] *** autark joined
[18:48] *** cyphase left
[18:49] *** cdg_ left
[18:49] *** Actualeyes left
[18:50] *** pyrimidine left
[18:50] <AlexDaniel> dogbert17++

[18:53] *** cyphase joined
[19:03] *** pyrimidine joined
[19:07] *** troys_ is now known as troys

[19:08] *** pyrimidine left
[19:08] *** zakharyas joined
[19:15] *** Vynce joined
[19:16] *** darutoko left
[19:17] *** vendethiel joined
[19:19] <timotimo> i'm back, was i missed? :3

[19:20] *** Vynce left
[19:21] <moritz> yes!

[19:21] * moritz hugs timotimo 

[19:28] <dalek> doc: cbbc38a | (Jan-Olof Hendig)++ | doc/Language/classtut.pod6:

[19:28] <dalek> doc: Fixed another broken link

[19:28] <synopsebot6> Link: http://doc.perl6.org/language/classtut

[19:28] <dalek> doc: review: https://github.com/perl6/doc/commit/cbbc38acdf

[19:29] <timotimo> yay

[19:30] *** stmuk joined
[19:32] *** stmuk_ left
[19:38] <cognominal> hi, what is the way you have run a non existing command foo with &run, short of testing 'foo'.r && 'foo'.x to avoid to run it in the first place ?

[19:39] <cognominal> .exitcode does not cut it because the command is not even run.

[19:40] <cognominal> ho, there is a Proc.pid that is Any

[19:41] <cognominal> nope, apparently it is not set or it is reset after the command is run

[19:43] <cognominal> thought one can stack test for IO.

[19:43] <geekosaur> this is a POSIX screw case. the usual convention is that exec failure sets the wait status to signal 0, exit -1/255

[19:44] <cognominal> '/'.IO.d.r  does not cut it

[19:44] <timotimo> right, what you get from .d or something is just a Bool

[19:44] <geekosaur> '/'.IO ~~ :d && :r # or something like that

[19:45] <cognominal> ho, I forgot about that one

[19:45] <timotimo> not quite

[19:45] <cognominal> m: ?'/'.IO 

[19:45] <camelia> rakudo-moar aa86b9: OUTPUT«WARNINGS for <tmp>:␤Useless use of "?" in expression "?'/'.IO" in sink context (line 1)␤»

[19:45] <cognominal> m: say ?'/'.IO 

[19:45] <camelia> rakudo-moar aa86b9: OUTPUT«True␤»

[19:48] <geekosaur> no, I figured that wasn't quite right but I'm not recalling the specific syntax. (my memory wants to use a junction, but I am dubious)

[19:48] <geekosaur> that is, & instead of &&

[19:49] <geekosaur> huh, memory was right

[19:49] <geekosaur> m: say '/'.IO ~~ :d & :r

[19:49] <camelia> rakudo-moar aa86b9: OUTPUT«True␤»

[19:49] <geekosaur> m: say '/'.IO ~~ :d & :w

[19:49] <camelia> rakudo-moar aa86b9: OUTPUT«False␤»

[19:49] *** pyrimidine joined
[19:50] <cognominal> I liked the '/'.IO.d.r # too bad.

[19:50] <geekosaur> not going to get chaining like that without Icon-style failure instead of p6-style, I think

[19:51] <cognominal> geekosaur, can you elaborate ?

[19:51] <geekosaur> (in Icon, there is no False, it fails instead. if it succeeds, the other one is taken. and fail does not throw an exception, it boolifies to False)

[19:52] <cognominal> ho, I get it

[19:52] <geekosaur> (sort of. since there's no False, you test success/fail not true/false)

[19:52] <geekosaur> the main reason not to do things this way is that you end up with an evaluation style that backtracks, which confuses people

[19:54] *** pyrimidine left
[19:56] <cognominal> the problem with '/'.IO.d.r is that .r would be called even if .d returns a false IO

[19:58] <geekosaur> in Icon that's not a problem because almost anything that gets &fail immediately produces &fail without doing anything else

[20:00] *** kyclark_ joined
[20:04] *** kyclark_ left
[20:05] *** ggoebel joined
[20:07] *** labster joined
[20:08] *** ggoebel left
[20:10] *** kyclark_ joined
[20:11] <dalek> doc: b33f95e | (Jan-Olof Hendig)++ | / (2 files):

[20:11] <dalek> doc: Added docs for X::Proc::Unsuccessful

[20:11] <dalek> doc: review: https://github.com/perl6/doc/commit/b33f95e09b

[20:11] *** pyrimidine joined
[20:16] *** pyrimidine left
[20:16] *** kyclark_ left
[20:16] <moritz> m: say ':'.uniname

[20:16] <camelia> rakudo-moar aa86b9: OUTPUT«COLON␤»

[20:18] <moritz> m: say 42.uninmae

[20:18] <camelia> rakudo-moar aa86b9: OUTPUT«No such method 'uninmae' for invocant of type 'Int'␤  in block <unit> at <tmp> line 1␤␤»

[20:18] <moritz> m: say 42.uniname

[20:18] <camelia> rakudo-moar aa86b9: OUTPUT«ASTERISK␤»

[20:18] <moritz> .oO( I expected OBELISK )

[20:19] *** seatek joined
[20:20] *** djbkd joined
[20:21] *** pyrimidine joined
[20:22] <BenGoldberg> m: say 42.chr

[20:22] <camelia> rakudo-moar aa86b9: OUTPUT«*␤»

[20:23] <BenGoldberg> m: say $_.chr for first *.uniname ~~ /OBELISK/, ^0x10ffff;

[20:23] <camelia> rakudo-moar aa86b9: OUTPUT«WhateverCode object coerced to string (please use .gist or .perl to do that)␤  in block <unit> at <tmp> line 1␤Use of Nil in numeric context␤  in block  at <tmp> line 1␤␀␤»

[20:24] <BenGoldberg> m: say *.uniname ~~ /OBELISK/ for 42;

[20:24] <camelia> rakudo-moar aa86b9: OUTPUT«WhateverCode object coerced to string (please use .gist or .perl to do that)␤  in block  at <tmp> line 1␤Nil␤»

[20:24] <BenGoldberg> m: say { .uniname ~~ /OBELISK/ } for 42;

[20:24] <camelia> rakudo-moar aa86b9: OUTPUT«-> ;; $_? is raw { #`(Block|69980304) ... }␤»

[20:24] <BenGoldberg> m: say do { .uniname ~~ /OBELISK/ } for 42;

[20:24] <camelia> rakudo-moar aa86b9: OUTPUT«Nil␤»

[20:24] <BenGoldberg> m: say do { .uniname ~~ /K/ } for 42;

[20:24] <camelia> rakudo-moar aa86b9: OUTPUT«｢K｣␤»

[20:25] <BenGoldberg> m: say first { .uniname ~~ /K/ }, ^256;

[20:25] <camelia> rakudo-moar aa86b9: OUTPUT«6␤»

[20:25] <BenGoldberg> m: say uniname first { .uniname ~~ /K/ }, ^256;

[20:25] <camelia> rakudo-moar aa86b9: OUTPUT«ACKNOWLEDGE␤»

[20:25] <BenGoldberg> m: say uniname first { .uniname ~~ /OBE/ }, ^256;

[20:25] <camelia> rakudo-moar aa86b9: OUTPUT«Cannot resolve caller uniname(Nil); none of these signatures match:␤    (Str:D $str)␤    (Int:D $code)␤  in block <unit> at <tmp> line 1␤␤»

[20:26] *** pyrimidine left
[20:26] <BenGoldberg> m: say uniname first { .uniname ~~ /OBE/ }, ^0x110000;

[20:26] <camelia> rakudo-moar aa86b9: OUTPUT«SYRIAC HARKLEAN OBELUS␤»

[20:27] <TEttinger> BenGoldberg: are you looking for a menhir or standing stone?

[20:27] <BenGoldberg> Whichever one I can put my feet on?

[20:29] <TEttinger> 🚀

[20:29] * BenGoldberg wonders why first, when it fails, returns Nil, instead of, say Mu, or an empty Slip.

[20:29] <BenGoldberg> m: '🚀'.uniname.say;

[20:29] <camelia> rakudo-moar aa86b9: OUTPUT«ROCKET␤»

[20:30] <TEttinger> IIRC an obelisk is an upright pillar-like stone often carved with historically-significant things

[20:30] <toolforger> IIRC an obelus was a coin

[20:30] <TEttinger> menhirs are uh... not as significant, the "men" is exactly what it suggests and what the shapes of the stones are meant to suggest

[20:31] *** pyrimidine joined
[20:31] <AlexDaniel> m: say “$_ → {.uniname}” for (0..0x1FFFF).grep({.uniname ~~ /OBE/})».chr

[20:31] <camelia> rakudo-moar aa86b9: OUTPUT«܋ → SYRIAC HARKLEAN OBELUS␤܌ → SYRIAC HARKLEAN METOBELUS␤⸓ → DOTTED OBELOS␤㋉ → IDEOGRAPHIC TELEGRAPH SYMBOL FOR OCTOBER␤🌍 → EARTH GLOBE EUROPE-AFRICA␤🌎 → EARTH GLOBE AMERICAS␤🌏 → EARTH GLOBE ASIA-AUSTRALIA␤🌐 …»

[20:31] * [ptc] has an Asterix flashback

[20:32] <AlexDaniel> bench: HEAD say “$_ → {.uniname}” for (0..0x1FFFF).grep({.uniname ~~ /OBE/})».chr

[20:32] <benchable6> AlexDaniel, starting to benchmark the 1 given commit

[20:32] <benchable6> AlexDaniel, ¦«HEAD»:0.9683

[20:32] <AlexDaniel> bench: 2015.12 say “$_ → {.uniname}” for (0..0x1FFFF).grep({.uniname ~~ /OBE/})».chr

[20:32] <benchable6> AlexDaniel, starting to benchmark the 1 given commit

[20:33] <benchable6> AlexDaniel, ¦«2015.12»:1.1704

[20:33] <AlexDaniel> hm, does not look like that much of a difference

[20:37] *** kyclark_ joined
[20:37] *** Ben_Goldberg joined
[20:37] *** BenGoldberg left
[20:37] *** Ben_Goldberg is now known as BenGoldberg

[20:37] *** pyrimidine left
[20:38] *** jeek left
[20:38] *** kyclark_ left
[20:39] *** jeek joined
[20:40] *** Tonik left
[20:40] *** canopus left
[20:41] *** pyrimidine joined
[20:43] *** lizmat joined
[20:46] *** pyrimidine left
[20:46] *** canopus joined
[20:51] *** pyrimidine joined
[20:52] *** troys is now known as troys_

[20:55] *** pyrimidine left
[20:57] *** pyrimidine joined
[21:05] *** pyrimidine left
[21:11] *** pyrimidine joined
[21:11] <Louis_> As far as I know, the "men" in "menhir" means "stone," and the "hir" means "long." See 

[21:11] <Louis_> http://www.thefreedictionary.com/menhir

[21:12] <toolforger> Question is: in what language? That of the original builders, that of the various tribes that lived there?

[21:15] <stmuk> French via Middle Breton

[21:15] <TEttinger> the purpose is still a washington monument-esque phallic symbol

[21:15] *** pyrimidine left
[21:16] <TEttinger> they weren't watch towers and served no practical purpose

[21:20] *** leego left
[21:20] *** leego joined
[21:20] *** pyrimidine joined
[21:25] *** pyrimidine left
[21:28] *** leego left
[21:28] *** leego joined
[21:30] *** pyrimidine joined
[21:32] *** setty1 left
[21:35] *** pyrimidine left
[21:41] *** pyrimidine joined
[21:44] <toolforger> The Bretons didn't build them, so...

[21:46] *** bjz joined
[21:48] *** cdg joined
[21:50] *** pyrimidine left
[21:50] *** pyrimidine joined
[21:52] *** letni_deszczyk joined
[21:56] *** leego left
[21:56] *** leego_ joined
[21:56] *** cdg left
[21:59] *** toolforger left
[22:04] <TimToady> my youngest granson is named Asterix, actually...

[22:04] <TimToady> *grand

[22:05] *** kurahaupo left
[22:09] *** RabidGravy left
[22:09] *** pyrimidine left
[22:10] *** pyrimidine joined
[22:11] *** leego_ left
[22:11] *** leego joined
[22:13] *** zakharyas left
[22:19] *** leego left
[22:20] *** leego joined
[22:21] *** atweiden-air joined
[22:23] <atweiden-air> i've come up with a syntax for literate programming

[22:23] <atweiden-air> https://gist.github.com/anonymous/adb4f36e8487761dd617cdf22bb9d8f5

[22:23] <atweiden-air> it's based on markdown, but i want to see a pod6 version of it

[22:23] <atweiden-air> i'm not too familiar with pod, anyone willing to take a crack at it?

[22:23] *** pyrimidine left
[22:24] <atweiden-air> (based on https://github.com/zyedidia/Literate)

[22:26] *** letni_deszczyk left
[22:31] <AlexDaniel> atweiden-air: well, perhaps you can take a look at some pod6 file and try it yourself

[22:31] <AlexDaniel> atweiden-air: for example: https://github.com/perl6/doc/blob/master/doc/Language/grammars.pod6

[22:32] *** aindilis joined
[22:36] *** pyrimidine joined
[22:36] *** Rawriful left
[22:42] *** rindolf left
[22:44] <atweiden-air> hmmm

[22:44] <atweiden-air> https://gist.github.com/anonymous/29a7efa54ed78a6597ff58d32b93cc0d

[22:46] *** pyrimidine left
[22:47] *** pyrimidine joined
[22:47] <atweiden-air> is this viable in pod parsers C<=begin code :spurt('hangman.pl6')>

[22:47] *** girafe joined
[22:48] *** djbkd left
[22:56] <MasterDuke> regex/grammar question. is there a way to match the negation of a capture?

[22:56] <MasterDuke> m: if "a12a3a" ~~ /(<[ab]>) (<-[$0]>+) $0/ { say $/ }

[22:56] <camelia> rakudo-moar aa86b9: OUTPUT«｢a12a3a｣␤ 0 => ｢a｣␤ 1 => ｢12a3｣␤»

[22:56] <MasterDuke> where i want $1 to be ｢12｣

[23:00] <AlexDaniel> m: if "a12a3a" ~~ /(<[ab]>) (.*) <?{ so $0 ne $1.comb.any }> $0/ { say $/ }

[23:00] <camelia> rakudo-moar aa86b9: OUTPUT«｢a12a｣␤ 0 => ｢a｣␤ 1 => ｢12｣␤»

[23:00] <AlexDaniel> MasterDuke: that's not it, but still…

[23:01] <AlexDaniel> I mean, that's probably going to work, but it is very inefficient

[23:02] <grondilu> the default indenting function in Vim does not work very well for Perl 6 IMHO.  What do you guys use?

[23:03] <seatek> I use emacs and a perl6-mode and it works pretty great. except for sometimes... ;)

[23:03] <MasterDuke> AlexDaniel: nice. that'll probably be too inefficient for what i'm doing, but i hadn't even thought of that

[23:03] <AlexDaniel> yea, that's what I've been doing for a long time too

[23:04] <AlexDaniel> and you know, if you like vim style of editing you can try evil or spacemacs or whatever…

[23:05] <seatek> my favorite command is :q!

[23:06] <seatek> or ZZ

[23:06] <seatek> the rest is very stresful

[23:06] <AlexDaniel> hm, the only feature I miss is probably V

[23:06] <AlexDaniel> haven't found any good alternative to that *yet*

[23:07] <seatek> i'm googling

[23:08] <seatek> V doesnt exist

[23:09] <seatek> it's a weird fantasy

[23:09] <seatek> oh! visual mode line-wise

[23:10] <seatek> hmm

[23:10] <AlexDaniel> yeah, I know several ways to do that but no easy one

[23:20] <El_Che> grondilu: I wrote a post my perl6 vim config: https://nxadm.wordpress.com/2016/08/21/vim-as-a-perl-6-editor/

[23:21] *** kyclark_ joined
[23:21] <seatek> i use it sometimes on machines where i don't want to leave "~" strewn about. But I don't know it well enough. It always makes me feel like I'm using a Turing machine.

[23:22] <seatek> I need to spend some time getting comfortable with it.

[23:22] <seatek> But i've been saying that for... oh my gosh... my memory is failing

[23:23] *** girafe left
[23:23] *** pyrimidine left
[23:23] *** pyrimidine joined
[23:23] *** atweiden-air left
[23:24] <geekosaur> bring back tv.exe :p

[23:24] <geekosaur> (tops-20)

[23:25] *** pyrimidine left
[23:25] *** kyclark_ left
[23:26] *** ugexe joined
[23:29] *** bjz left
[23:32] *** bjz joined
[23:33] *** pmurias left
[23:46] *** garu joined
[23:49] <garu> hello! quick question: 'class C { method x (*%args) {} }; my $c = C.new; $c.x(foo => 42, bar => 21);' works as expected, but if I quote the keys, I get "Too many positionals passed; expected 1 argument but got 3"

[23:50] <garu> i.e. 'class C { method x (*%args) {} }; my $c = C.new; $c.x("foo" => 42, "bar" => 21);'

[23:51] <timotimo> aye, pairs with quoted keys will not become named arguments

[23:51] <timotimo> because quotes allow interpolation. for dynamic names of keyword arguments/named arguments, you'll have to use a hash and flattening to use that

[23:54] <garu> timotimo: is this by design? is it documented somewhere? I must be looking at the wrong place, sorry

[23:54] <timotimo> by design. let me see if i find docs that tell about it

[23:55] <timotimo> https://docs.perl6.org/language/functions#Arguments

[23:55] <timotimo> there's a "not a named argument" example there

