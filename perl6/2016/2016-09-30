[00:00] <MasterDuke> tushar: Arrays can have holes

[00:01] <tushar> MasterDuke: Thanks. I just read that in the doc. I don't want hole. How can I achieve that?

[00:01] <MasterDuke> but maybe a hole at the end actually truncates the Array and a hole at the beginning doesn't

[00:01] <MasterDuke> splice

[00:01] <tushar> hmmm.. MasterDuke: thanks.

[00:01] *** mcmillhj left
[00:02] <MasterDuke> it is a little odd the difference between holes at the end and the beginning

[00:03] <MasterDuke> i think lizmat did a bunch of the hole work with Arrays, it would probably be good to ask her if that's expected behavior

[00:03] <geekosaur> I think it's Hard to distinguish the two (without leaking risky internals as perl5 is prone to do), whereas the beginning is fixed

[00:04] *** homes joined
[00:05] <tushar> hmm.. I was so happy when I use :delete on array to remove last element it gave what I expected. I did something without asking here. But when I try to delete the first element, it didn't work. :(

[00:14] <gfldex> m: my @a = [[1..3], [4..6], [7..9]]; @a.shift; dd @a;

[00:14] <camelia> rakudo-moar 58cf9d: OUTPUT«Array @a = [[4, 5, 6], [7, 8, 9]]␤»

[00:15] <gfldex> tushar: :delete is arrayish. .pop and .shift are linked-listish

[00:15] <tushar> hmm..

[00:17] <timotimo> except we implement it as a buffer with a start-offset and length that can wiggle around

[00:17] *** mcmillhj joined
[00:18] <raiph> m: my \array = [[1..3],[4..6],[7..9]]; my \inserts = [[<a b>],Nil,[<c d>]]; say insert array, inserts; sub insert (\array, \inserts) { my \index=$=0; for inserts { $_ and array.splice: index,0,@=$_ and index++; index++ }; array }

[00:18] <camelia> rakudo-moar 58cf9d: OUTPUT«[[a b] [1 2 3] [c d] [4 5 6] [7 8 9]]␤»

[00:20] <raiph> tushar: is ^^ closer?

[00:21] <tushar> ralph: thanks for your help.

[00:22] *** mcmillhj left
[00:26] *** homes left
[00:26] *** mcmillhj joined
[00:27] *** pierre_ joined
[00:31] *** mempko left
[00:35] *** mcmillhj left
[00:50] *** BenGoldberg joined
[00:50] *** aries_liuxueyang left
[00:58] *** tushar left
[00:59] *** mcmillhj joined
[01:04] *** eliasr left
[01:05] *** mcmillhj left
[01:07] *** itaipu left
[01:07] *** aries_liuxueyang joined
[01:12] *** mcmillhj joined
[01:16] *** cdg left
[01:17] *** mcmillhj left
[01:17] *** mcmillhj joined
[01:22] *** mcmillhj left
[01:37] *** kurahaupo left
[01:41] *** kaare_ joined
[01:45] *** ilbot3 left
[01:47] *** ilbot3 joined
[01:49] *** ccakes left
[01:56] *** Actualeyes joined
[01:59] *** Zoffix__ joined
[01:59] *** Zoffix__ is now known as Zoffix

[02:00] <Zoffix> I discovered a new law of nature: if you presentation looks OK in 4 different browsers you tried, but looks broken in 5th, when you're presenting, it'll be broken :)

[02:00] <Zoffix> (wasn't fatal breakage, but ruined the wow effect :)

[02:01] *** khw joined
[02:02] <grondilu> Zoffix: that sounds like a rip of Murphy's law

[02:03] <Zoffix> :)

[02:05] *** noganex joined
[02:05] *** zakharyas joined
[02:07] *** labster left
[02:08] *** noganex_ left
[02:09] *** b2gills left
[02:10] *** b2gills joined
[02:12] *** labster joined
[02:16] <Zoffix> New post: ""Perl 6: What Programming In The Future Is Like?" (Lightning Talk Slides and Video)": http://perl6.party/post/Perl-6-What-Programming-In-The-Future-Is-Like

[02:18] *** mcmillhj joined
[02:21] *** cdg joined
[02:23] *** mcmillhj left
[02:25] <dj_goku> Zoffix: you need a bot that posts all your posts. :D

[02:27] <Zoffix> .oO( I need a bot that makes bots... )

[02:34] *** pierre_ left
[02:38] *** pierre_ joined
[02:45] *** cdg left
[02:58] *** wamba joined
[02:59] <BenGoldberg> m: rand.Str.say;

[02:59] <camelia> rakudo-moar 415461: OUTPUT«0.229272521330113␤»

[03:00] <Zoffix> They're very poor passwords :)

[03:01] <BenGoldberg> Zoffix, I'm looking at the slides of your talk, and the pictures are absolutely hilarious :)

[03:01] <Zoffix> :)

[03:04] *** bjz_ left
[03:05] *** Actualeyes left
[03:06] *** labster left
[03:06] <llfourn> how do you do the grammar equiv of self."$name"(). ie you want to match against a rule whos name is only known at runtime. I tried <$name> but didn't work.

[03:07] *** pierre_ left
[03:08] *** Actualeyes joined
[03:09] <llfourn> <$regex> is apparently for interpolating a variable as a regex anyway

[03:11] <geekosaur> but that would do it presumably, if the regex is just a rule invocation

[03:12] <geekosaur> $foo = '<myrule>'; / <$foo> / # or whatever

[03:13] *** pierre_ joined
[03:15] <llfourn> m: my rule foo { .* }; my $foo = "<foo>"; say "blah" ~~ /<$foo>/

[03:15] <camelia> rakudo-moar 415461: OUTPUT«｢blah｣␤»

[03:15] <llfourn> geekosaur: it works :)

[03:16] <llfourn> but I don't really get why it must be "<foo>" rather than just "foo"

[03:16] <llfourn> oh... it's treating the content of the variable as a regex and then doing the lookup on the content

[03:16] <llfourn> that's clever

[03:17] <llfourn> but I wonder if there isn't a less clever way..

[03:17] *** pierre_ left
[03:17] <geekosaur> maybe 'foo' would work, I'm not having the best of evenings and a bit fuzzy on p6 regex atm :/

[03:17] <llfourn> geekosaur: it doesn't :\

[03:18] <llfourn> no worries you have helped me greatly :)

[03:20] <llfourn> geekosaur: I've found the answer

[03:21] <geekosaur> looks to me like that's just how it works, poking at grammars in rakudo itself

[03:21] <llfourn> m: my rule foo { .* }; my $foo = "foo"; say "blah" ~~ /<::($foo)>/

[03:21] <camelia> rakudo-moar 415461: OUTPUT«No such method 'foo' for invocant of type 'Cursor'␤  in block <unit> at <tmp> line 1␤␤»

[03:21] <llfourn> eh that worked for me in a grammar

[03:22] <llfourn> hmm that's how you do self."$foo"() at least

[03:22] <llfourn> it looks like it doesn't do lexical lookup

[03:22] <llfourn> which is strange because outside of grammars that's what ::(..) is for

[03:27] *** Zoffix left
[03:31] *** pierre_ joined
[03:32] *** Ven_ left
[03:34] *** Ven_ joined
[03:34] *** mohae_ joined
[03:37] *** mohae left
[03:46] *** Ven_ left
[03:49] *** Ven_ joined
[03:53] *** bjz joined
[04:08] *** khw left
[04:13] *** AlexDaniel left
[04:15] *** pierre_ left
[04:19] *** nadim left
[04:20] *** pierre_ joined
[04:22] *** aindilis joined
[04:25] *** pierre_ left
[04:35] *** frankD2 joined
[04:37] *** grondilu left
[04:40] *** BenGoldberg left
[04:44] *** c74d joined
[04:45] *** wamba left
[04:53] *** bjz left
[04:55] *** bjz joined
[04:57] *** Cabanossi left
[04:59] *** skids left
[05:01] *** Cabanossi joined
[05:02] *** cyphase left
[05:06] *** cyphase joined
[05:16] *** xxd joined
[05:16] *** xxd is now known as xdxdxd

[05:16] <xdxdxd> How many total keywords are in perl6?

[05:19] *** pierre_ joined
[05:20] <TimToady> to the first approximation, none :)

[05:21] <TimToady> but it really depends on what you mean by "keyword"

[05:21] <TimToady> there aren't really reserved words, except insofar as the standard grammar happens to have some defaults

[05:21] *** xinming left
[05:22] *** xinming joined
[05:22] <TimToady> m: sub if { say "I'm an interface" }; if;

[05:22] <camelia> rakudo-moar 415461: OUTPUT«I'm an interface␤»

[05:23] <TimToady> to the extent there are keywords, most of 'em require whitespace after them

[05:24] <TimToady> m: while;

[05:24] <camelia> rakudo-moar 415461: OUTPUT«5===SORRY!5===␤Whitespace required after keyword 'while'␤at <tmp>:1␤------> 3while7⏏5;␤Undeclared routine:␤    while used at line 1␤␤␤»

[05:24] <xdxdxd> hm

[05:24] <xdxdxd> instead of defining a keyword as reserved

[05:25] <xdxdxd> I mean just words that are used generally in perl6

[05:25] <xdxdxd> you know what I mean?

[05:25] <TimToady> well, that's a fuzzy set...

[05:25] <xdxdxd> hm

[05:25] <TimToady> but you could get an idea by looking at the Grammar.nqp file

[05:25] <[Coke]> m: say so sink Rat

[05:25] <camelia> rakudo-moar 415461: OUTPUT«WARNINGS for <tmp>:␤Useless use of constant value Rat in sink context (line 1)␤False␤»

[05:26] <xdxdxd> hm

[05:26] <TimToady> any word that's not mentioned in Grammar.nqp is really just part of the setting library

[05:26] <xdxdxd> how many do you think it would be?

[05:27] <TimToady> well, again, depends on how you count

[05:27] <TimToady> do you count the 'where' that can occur inside of a signature parameter, even though it's not generally available in expressions?

[05:28] <TimToady> some words are just internal filler

[05:28] <xdxdxd> I don't understand

[05:31] *** frankD2 left
[05:32] <TimToady> m: subset Positive of Int where * > 0; my Positive $x = 0;

[05:32] <camelia> rakudo-moar 415461: OUTPUT«Type check failed in assignment to $x; expected Positive but got Int (0)␤  in block <unit> at <tmp> line 1␤␤»

[05:32] <TimToady> is "of" or "where" a keyword there?  such noise words can only occur within some other construct, not in general expressions

[05:33] <TimToady> they're just part of the subset construct

[05:33] <TimToady> anyway, if you want an idea of how many words there are, look for things of the form :sym<subset> in Grammar.nqp

[05:34] <TimToady> they'll be in different syntactic categories, so you can decide which ones you want to count

[05:34] <TimToady> some of them are symbolic, and some of them are alphanumeric, but in general Perl 6 doesn't care which ones are really "words"

[05:35] <TimToady> you might say "1 || 2" or you might say "1 or 2" and mean exactly the same thing

[05:35] <TimToady> is "or" a keyword?  Or is it just an operator?

[05:36] <TimToady> it's really just a distinction we don't make, which is why the facetious answer of "none" above :)

[05:39] <TimToady> there are 540 occurrences of :sym in Grammar.nqp, and many of those are "words", but many of them are just non-alpha symbols, and some of them are abstract and represent multiple symbols

[05:43] *** domidumont joined
[05:44] <TimToady> but we don't really reserve words in the way that keywords are often reserved in languages

[05:44] <TimToady> m: my \if = 42; say "cool" if if eq if;

[05:44] <camelia> rakudo-moar 415461: OUTPUT«cool␤»

[05:44] *** rgrinberg left
[05:45] *** Actualeyes left
[05:46] <xdxdxd> thanks for the good response TimToady

[05:46] *** Ven_ left
[05:47] *** domidumont left
[05:47] *** xdxdxd left
[05:48] *** domidumont joined
[05:49] *** itaipu joined
[05:49] *** Ven_ joined
[05:51] *** cyphase left
[05:53] <TEttinger> is the zero-width non-breaking space (which used to be the BOM character) a valid identifier on its own in perl6?

[05:53] <TEttinger> \ufeff

[05:53] <TEttinger> would that be \x{feff} in perl 6?

[05:54] <TimToady> use square brackets

[05:54] <TimToady> m: say "\x[feff]".ord

[05:54] <camelia> rakudo-moar 415461: OUTPUT«65279␤»

[05:54] <TimToady> m: say "\xfeff".ord

[05:54] <camelia> rakudo-moar 415461: OUTPUT«65279␤»

[05:54] <TimToady> well, they're optional

[05:55] <TimToady> m: say "\x1F4A9"

[05:55] <camelia> rakudo-moar 415461: OUTPUT«💩␤»

[05:55] <TimToady> and not arbitrarily limited to 4 hex codes either :)

[05:56] *** cyphase joined
[05:57] <TEttinger> m: say "my \if = 42; say "cool" if if eq if;"

[05:57] <camelia> rakudo-moar 415461: OUTPUT«5===SORRY!5===␤Unrecognized backslash sequence: '\i'␤at <tmp>:1␤------> 3say "my \7⏏5if = 42; say "cool" if if eq if;"␤Two terms in a row␤at <tmp>:1␤------> 3say "my \if = 42; say "7⏏5cool" if if eq if;"␤    expecting any of:…»

[05:57] <TEttinger> m: say "my \\\xfeff = 42; say "cool" if if eq if;"

[05:57] <camelia> rakudo-moar 415461: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say "my \\\xfeff = 42; say "7⏏5cool" if if eq if;"␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end…»

[05:58] <TEttinger> oh ha

[05:58] <TEttinger> m: say "my \\\xfeff = 42; say \"cool\" if if eq if;"

[05:58] <camelia> rakudo-moar 415461: OUTPUT«my \﻿ = 42; say "cool" if if eq if;␤»

[05:58] <TEttinger> m: my \﻿ = 42; say "cool" if if eq if;

[05:58] <camelia> rakudo-moar 415461: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Malformed my␤at <tmp>:1␤------> 3my7⏏5 \﻿ = 42; say "cool" if if eq if;␤»

[05:58] <TEttinger> huh

[05:58] <TEttinger> I guess it isn't?

[05:58] <TEttinger> unless it was stripped in the first print

[05:58] <geekosaur> it's a sigil, not an escape

[06:00] *** cpage_ left
[06:00] *** pierre_ left
[06:01] *** pdcawley left
[06:03] <TEttinger> I was copying this

[06:03] <TEttinger> m: my \if = 42; say "cool" if if eq if;

[06:03] <camelia> rakudo-moar 415461: OUTPUT«cool␤»

[06:03] <TEttinger> but trying to replace if with the unescaped unicode for the character with numeric valud FEFF

[06:03] <TEttinger> *value

[06:08] *** pierre_ joined
[06:08] *** andrzejku joined
[06:09] *** silug_ left
[06:11] *** canopus left
[06:13] *** pierre_ left
[06:15] *** movl joined
[06:17] *** Actualeyes joined
[06:20] *** itaipu left
[06:20] *** canopus joined
[06:21] *** pierre_ joined
[06:22] *** silug_ joined
[06:35] *** andrzejku left
[06:46] *** Ven_ left
[06:51] *** sena_kun joined
[06:51] *** labster joined
[06:55] *** andrzejku joined
[06:55] *** MARTIMM joined
[07:09] *** mohae_ left
[07:14] *** grondilu joined
[07:17] *** wamba joined
[07:26] <grondilu> hello #perl6

[07:30] *** andrzejku left
[07:39] <DrForr> Hello nurse :)

[07:39] *** pierre_ left
[07:40] <grondilu> some thoughts I've had lately (I made it short):

[07:40] <grondilu> https://gist.github.com/grondilu/88f009105383b9c675d5702a489fa6b8

[07:41] <grondilu> (but not short enough to paste it here, thus the gist link)

[07:43] <moritz> I don't understand; do you want a lisp-like language on the lower on the higher level?

[07:43] <moritz> *or on

[07:43] *** pierre_ joined
[07:43] *** andrzejku joined
[07:44] <grondilu> I should not have talked about low/high level, as I'm not sure lisp obeys this classification.

[07:44] <moritz> that doesn't answer my question :-)

[07:44] <moritz> is your goal to write in a more lisp-like language?

[07:44] <grondilu> there would be a chain of transcompilers, and something lisp-like would be at the bottom of it.

[07:45] <moritz> but, machines don't understand lisp-like languages

[07:45] <moritz> so *then* you need a lisp-like compiler to generate machine code

[07:45] <DrForr> With the notable exception of the LispM :)

[07:45] <moritz> so I don't understand the motivation

[07:46] <grondilu> one of the advantage is that it'd make portability easier.

[07:46] <moritz> but what makes lisp-like languages more portable?

[07:46] <grondilu> since at the end your compiler would generate something that is easily written in any language.

[07:46] <grondilu> javascript for instance can do lisp-like languages.  Or rather lambda-calculus like.

[07:47] <grondilu> so your Perl 6 compiler would easily generate javascript code. 

[07:48] <DrForr> IIRC there's already a backend in progress for Javascript.

[07:48] <psch> nqp-js: say("hi")

[07:48] <camelia> nqp-js: OUTPUT«hi␤»

[07:48] <psch> pmurias++

[07:49] <grondilu> DrForr: yeah but let's just say I'm a bit impatient.

[07:49] <DrForr> Seems like that worked above :)

[07:50] <psch> as for the gist, it definitely sounds possible to me

[07:51] <psch> the question seems to be practicality -- we need NQP between perl6 and rakudo for bootstrapping and optimizability increase due to a simpler language.  what would one need more than one layer inbetween for?

[07:51] <psch> well, i guess nqp also helps with portability between backends

[07:52] <psch> (also geez inconsistent capitalization, where's my coffee...)

[07:55] *** andrzejku left
[07:57] <nine> Ok, I give up. How the hell can I return nothing at all?

[07:57] <nine> m: sub take-nothing(|c) { say c }; sub return-nothing() { }; sub return-empty() { return Empty }; sub return-list() { () }; take-nothing(return-nothing); take-nothing(return-empty); take-nothing(return-list)

[07:57] <camelia> rakudo-moar 415461: OUTPUT«\(Nil)␤\(slip())␤\(())␤»

[07:58] <nine> None of these ^^^ give me an empty capture

[08:00] *** RabidGravy joined
[08:00] <psch> nine: i wouldn't even know how you'd invoke &take-nothing to get \() in c

[08:01] <psch> nine: oh, wait, is that just with (), as in empty param list

[08:01] <nine> yes

[08:01] <psch> m: sub take-nothing(|c) { say c }; take-nothing

[08:01] <camelia> rakudo-moar 415461: OUTPUT«\()␤»

[08:01] <psch> yeah i don't think you can do that?

[08:01] <psch> i mean, whenever you have something there it has to be something, even if that something means nothing..? vOv

[08:03] <moritz> psch: are you on a philosophy trip right now? :-)

[08:03] <psch> moritz: i hope not!  i'm waiting on more coffee :)

[08:08] <nine> This inability to return just nothing (like an empty list in Perl 5) is blocking another 6 % improvement to csv-ip5xs.pl :(

[08:10] *** sena_kun left
[08:17] *** frankD2 joined
[08:21] *** frankD2 left
[08:25] <RabidGravy> boom!

[08:27] *** ocbtec joined
[08:58] *** telex left
[09:00] *** telex joined
[09:12] *** wamba left
[09:15] *** zakharyas left
[09:15] *** zakharyas joined
[09:20] *** zakharyas left
[09:23] *** rindolf joined
[09:24] *** labster left
[09:25] *** ItayAlmog joined
[09:45] *** aries_liuxueyang left
[09:47] *** aries_liuxueyang joined
[09:48] <ItayAlmog> What soe

[09:48] *** wamba joined
[09:48] <ItayAlmog> What does nqp::create(self) do?

[09:50] <psch> ItayAlmog: it allocates the object https://github.com/perl6/nqp/blob/master/docs/ops.markdown#create

[09:50] <psch> ItayAlmog: in detail, this means something along the lines of "tell the VM to reserve some memory for the REPR"

[09:52] <ItayAlmog> I know. But what is the self repr? Is it somekind of blank repr?

[09:52] <psch> m: class A { method foo { say self } }; A.foo

[09:52] <camelia> rakudo-moar 83d733: OUTPUT«(A)␤»

[09:52] <psch> ItayAlmog: "self" is the current class.  if there's no 'is repr' on the declarator it's most likely P6Opaque

[09:53] <ItayAlmog> Ok, thanks

[09:53] <psch> m: class A { method foo { say self } }; say A.REPR

[09:53] <camelia> rakudo-moar 83d733: OUTPUT«P6opaque␤»

[09:56] <RabidGravy> I still have this perverse desire for user defined reprs

[09:57] *** AlexDaniel joined
[09:57] <psch> i'm not sure that'd really be useful

[09:57] <dalek> ecosystem: dd925e0 | (Sam Morrison)++ | META.list:

[09:57] <dalek> ecosystem: Add JS::Minify module

[09:57] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/dd925e0566

[09:57] <dalek> ecosystem: 0b79b01 | (Aleks-Daniel Jakimenko-Aleksejev)++ | META.list:

[09:57] <dalek> ecosystem: Merge pull request #256 from scmorrison/master

[09:57] <dalek> ecosystem: 

[09:57] <dalek> ecosystem: Add JS::Minify module

[09:57] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/0b79b01f4e

[09:58] <psch> i mean, either you're doing something C-ish, in which case CStruct or Pointer probably work well enough

[09:58] <psch> or you aren't, and P6opaque does pretty much everything you need

[09:58] *** TEttinger left
[09:58] <psch> although i admit that i maybe am just not seeing the use case :)

[10:00] <RabidGravy> I know, I can't actually think of a sensible use case either :)

[10:01] <RabidGravy> but there are specialised reprs for queues and stuff and it just seems right and proper that for those cases no-one else has thought of yet :)

[10:02] <psch> hm, true.  i struggle to imagine a way for custom reprs that isn't backend code though

[10:04] *** araujo left
[10:05] *** araujo joined
[10:07] *** araujo left
[10:07] *** araujo joined
[10:09] *** user9 joined
[10:11] *** pmurias joined
[10:12] <pmurias> psch: nqp is not a really an intermediate form like grondilu proposed

[10:13] <psch> pmurias: but QAST is, isn't it?

[10:13] <pmurias> QAST is

[10:15] *** itaipu joined
[10:17] <AlexDaniel> buggable: help

[10:17] <buggable> AlexDaniel, tags | tag SOMETAG

[10:17] <AlexDaniel> buggable: tags

[10:17] <buggable> AlexDaniel, Total: 1374; BUG: 936; UNTAGGED: 283; LTA: 119; NYI: 91; JVM: 62; RFC: 58; CONC: 53; SEGV: 38; REGEX: 35; UNI: 30; PERF: 27; @LARRY: 22; POD: 17; TODO: 17; IO: 16; NATIVECALL: 16; BUILD: 11; PRECOMP: 11; TESTCOMMITTED: 10; OO: 9; MATH: 7; STAR: 6; BOOTSTRAP: 5; GLR: 5; OSX: 4; DOCS: 3; REPL: 3; TESTNEEDED: 3; WEIRD: 3; REGRESSION: 2; CONFIGURE: 1; LIBRARY: 1; OPTIMIZER: 1;

[10:17] <AlexDaniel> buggable: tag ✓×｢)…æ‘

[10:17] <buggable> AlexDaniel, There are no tickets tagged with ✓×｢)…Æ‘

[10:25] <RabidGravy> phew

[10:26] *** rudolfochrist joined
[10:34] <AlexDaniel> note how Æ is uppercase

[10:35] <AlexDaniel> ♥🦋

[10:35] *** ItayAlmog2805 joined
[10:36] *** gregf_ left
[10:36] * jnthn has seen that letter too many times to be surprised by its uppercase form :)

[10:38] *** ItayAlmog left
[10:38] <pmurias> grondilu: I guess what you are proposing is called an nanopass compiler

[10:38] *** ItayAlmog joined
[10:42] <AlexDaniel> m: class Foo { has Bar $.x }; class Bar { has Foo $.y }

[10:42] <camelia> rakudo-moar 83d733: OUTPUT«5===SORRY!5===␤Type 'Bar' is not declared. Did you mean 'Bag'?␤at <tmp>:1␤------> 3class Foo { has Bar7⏏5 $.x }; class Bar { has Foo $.y }␤Malformed has␤at <tmp>:1␤------> 3class Foo { has7⏏5 Bar $.x }; class Bar { has Foo $.y }…»

[10:42] *** ItayAlmog2805 left
[10:42] <pmurias> grondilu: I had a initial start of a niecza common lisp backend in the past too

[10:43] <nine> jnthn: is there any way a method can return really nothing at all?

[10:43] <nine> m: sub take-nothing(|c) { say c }; sub return-nothing() { }; sub return-empty() { return Empty }; sub return-list() { () }; take-nothing(return-nothing); take-nothing(return-empty); take-nothing(return-list)

[10:43] <camelia> rakudo-moar 83d733: OUTPUT«\(Nil)␤\(slip())␤\(())␤»

[10:44] <nine> Or put the question in another way: what's the fastest way to get rid of the slip() in my args Capture?

[10:45] <jnthn> Well, Nil is the normal way to say "I don't return a value"

[10:45] <nine> But it ends up being a value anyway?

[10:46] <jnthn> Well, Nil really is a value representing the absence of a value :)

[10:46] <jnthn> What's the problem you're trying to solve?

[10:48] <nine> is($foo.count_args($foo.nothing), 1); # fails because count_args gets 2 parameters, $self an a wrapped Nil. $foo is a Perl 5 object.

[10:49] <nine> It works as long as Inline::Perl5 does a lot of flattening and slurpies which cause the slip() to disappear. But a faster implementation just passes it on until it gets wrapped for Perl 5.

[10:50] *** aries_liuxueyang left
[10:51] *** Zoffix joined
[10:51] <jnthn> What does nothing look like?

[10:52] <Zoffix> .tell TEttinger you need a term:<> to make it work. See http://perl6.party/post/Anguish--Invisible-Programming-Language-and-Invisible-Data-Theft

[10:52] <yoleaux> Zoffix: I'll pass your message to TEttinger.

[10:52] <nine> jnthn: sub nothing { return; }

[10:52] *** cibs joined
[10:52] <nine> jnthn: will in list context return () which Perl 5 interpolates at the very first opportunity.

[10:53] <jnthn> But...we don't have list context in Perl 6...or are you thinking to re-write the Nil into () if it's a boundary call?

[10:56] <nine> I know that nothing() has 0 return values. I just need to be able to pass those 0 values into count_args(). Maybe I can use a multi method invoke(Str $package, Str $function, Nil) to detect that...

[10:59] *** iH2O joined
[11:00] *** rudolfochrist left
[11:02] *** labster joined
[11:02] *** labster left
[11:02] <jnthn> Yeah, using a multi to match on Nil should be fast also

[11:08] *** nadim joined
[11:15] <iH2O> matching Nil should be fast

[11:16] <iH2O> doing nothing should be fast

[11:18] <iH2O> related topic: darkness should be faster than light https://www.youtube.com/watch?v=JTvcpdfGUtQ

[11:18] <iH2O> lol

[11:21] <DrForr> Isn't it actually possible to do that because of group velocity?

[11:23] <iH2O> group velocity is the fastest of all?

[11:24] *** wamba left
[11:24] *** ItayAlmog2805 joined
[11:25] <iH2O> cuz same as parallel processing

[11:27] *** rudolfochrist joined
[11:27] <DrForr> Well, all you really need is an oscilloscope, come to think of it. The electron gun can sweep across the screen in a long ascilloscope tube faster than light, so if you put an obstacle in the way of the sweep you've created a superluminal shadow.

[11:28] *** ItayAlmog left
[11:29] *** ItayAlmog2805 left
[11:31] *** rudolfochrist left
[11:38] *** iH2O left
[11:38] <lizmat> MasterDuke: re holes in Arrays, afaik this is supposed to work like that

[11:41] *** edehont joined
[11:54] *** pierre_ left
[11:56] <RabidGravy> erk, I just broke the CD in my "heritage"  "Using Javascript - special edition"

[11:57] <moritz> RabidGravy: on noez. I hear CDs have real vintage value these days

[11:57] <timotimo> which browser ships with the special edition of javascript?

[11:58] <RabidGravy> it was Netscape Navigator at the time

[11:58] <RabidGravy> Netscape Navigator 2.0 nonetheless 

[11:58] <RabidGravy> the book is 23 years old

[11:58] <timotimo> hehehe

[11:59] <lizmat> RabidGravy: is that an O'Reilly book ?

[11:59] <RabidGravy> no Que - I'm not even sure if they're still going

[12:02] <RabidGravy> http://www.webbasedprogramming.com/Special-Edition-Using-Java-Script/

[12:02] <RabidGravy> I do have the pink camel book on the shelf next to it though

[12:03] <lizmat> RabidGravy: a quick look at our library doesn't reveal that particular book, so I'm afraid I won't be able to clone you a copy of the CD

[12:03] <lizmat> afk&

[12:04] <RabidGravy> haha https://archive.org/details/que-special-edition-using-javascript

[12:05] <RabidGravy> now I'm not sure if I have any CD-Rs around

[12:09] <dalek> doc: 70c0d89 | (Tom Browder)++ | doc/Language/modules.pod6:

[12:09] <dalek> doc: prettify comments

[12:09] <dalek> doc: 

[12:09] <dalek> doc: also show use of tags on module name

[12:09] <dalek> doc: review: https://github.com/perl6/doc/commit/70c0d89e7f

[12:17] *** wamba joined
[12:24] *** rindolf left
[12:32] *** rindolf joined
[12:34] *** domidumont left
[12:36] <stmuk_> I'm a Netscape 2.0 manual somewhere I think, a Pink Camel and a BSDI manual

[12:36] <stmuk_> and a VT220 manual :)

[12:37] *** domidumont joined
[12:37] <timotimo> you're a manual?

[12:37] <stmuk_> errr ^ I've

[12:38] <gfldex> i was about to ask how I RTFM :->

[12:40] *** ptolemarch joined
[12:47] *** AlexDaniel left
[12:47] *** AlexDaniel joined
[12:47] *** wamba left
[12:48] *** rgrinberg joined
[12:52] <jkramer> m: sub foo { state @xs = []; return @xs }; foo() = <foo bar baz>; say foo

[12:52] <camelia> rakudo-moar 83d733: OUTPUT«[foo bar baz]␤»

[12:52] <jkramer> Why is this working with normal return instead of return-rw?

[12:52] <stmuk_> http://blogs.perl.org/users/shadowcat_mdk/2016/09/tpf-at-oscon-london.html

[12:53] <jnthn> Because an Array is a mutable object, and return-rw is just talking about Scalar containers.

[12:53] <gfldex> jkramer: the @-sigil is Array and Array is a container of containers

[12:53] <jkramer> Ah, ok

[12:53] *** gregf_ joined
[12:54] <jkramer> m: sub foo { state $foo = ''; return $foo }; foo() = 'wombat'; say foo

[12:54] <camelia> rakudo-moar 83d733: OUTPUT«Cannot assign to a readonly variable or a value␤  in block <unit> at <tmp> line 1␤␤»

[12:54] <jkramer> m: sub foo { state $foo = ''; return-rw $foo }; foo() = 'wombat'; say foo

[12:54] <camelia> rakudo-moar 83d733: OUTPUT«wombat␤»

[12:54] <jkramer> \o/

[12:54] <hackedNO1> m: sub foo { state $foo = []; return $foo }; foo() = 'wombat'; say foo

[12:54] <camelia> rakudo-moar 83d733: OUTPUT«Cannot assign to a readonly variable or a value␤  in block <unit> at <tmp> line 1␤␤»

[12:55] *** mcmillhj joined
[12:56] <jkramer> So do I get this right, in Perl 6 I can basically forget about the old sigils and just use $ for everything because the other sigils are just some kind of indicator/type constraint?

[12:57] <gfldex> no :)

[12:57] <jkramer> Ok :D

[12:57] <jnthn> You *could*, but it may not be an entirely convenient experience

[12:57] <gfldex> you need them for signatures

[12:57] <jnthn> m: my @a = [1,2,3]; for @a { .say }

[12:57] <camelia> rakudo-moar 83d733: OUTPUT«1␤2␤3␤»

[12:57] <jkramer> Hmm true.

[12:57] <jnthn> m: my $a = [1,2,3]; for $a { .say }

[12:57] <camelia> rakudo-moar 83d733: OUTPUT«[1 2 3]␤»

[12:58] <jnthn> For example :)

[12:58] <gfldex> m: my $a = [1,2,3]; for $a.flat { .say }

[12:58] <camelia> rakudo-moar 83d733: OUTPUT«1␤2␤3␤»

[12:58] <gfldex> you would need plents of .flat everywhere

[12:58] <timotimo> you may not want to .flat, you can also just .list

[12:58] <jkramer> Ah, took me way too long to find the difference in the output :D

[12:58] <hackedNO1> m: my $a = [1,2,3]; for |$a { .say }

[12:58] <camelia> rakudo-moar 83d733: OUTPUT«1␤2␤3␤»

[12:59] <jnthn> If you use .map it works either way, though :)

[12:59] <jkramer> So what exactly is the difference between @x = [] and $x = []?

[12:59] <hackedNO1> m: my @a = 1, 2, 3; dd @a

[12:59] <camelia> rakudo-moar 83d733: OUTPUT«Array @a = [1, 2, 3]␤»

[12:59] <hackedNO1> m: my $a = 1, 2, 3; dd $a

[12:59] <camelia> rakudo-moar 83d733: OUTPUT«WARNINGS for <tmp>:␤Useless use of constant integer 2 in sink context (lines 1, 1)␤Useless use of constant integer 3 in sink context (lines 1, 1)␤Int $a = 1␤»

[13:00] <jkramer> m: my $a = [1,2,3]; dd $a

[13:00] <camelia> rakudo-moar 83d733: OUTPUT«Array $a = $[1, 2, 3]␤»

[13:00] <hackedNO1> m: class { has @.foo }.new: :foo<a>

[13:00] <camelia> rakudo-moar 83d733: ( no output )

[13:01] *** Actualeyes left
[13:01] <gfldex> also you state intent, what can greatly improve readability

[13:01] <hackedNO1> m: sub (@foo) {}(1)

[13:01] <camelia> rakudo-moar 83d733: OUTPUT«Type check failed in binding to @foo; expected Positional but got Int (1)␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[13:01] <jnthn> jkramer: A Scalar is just a reference to something, so you're taking the Array object created by [] and making the Scalr point to it.

[13:01] <hackedNO1> m: sub ($foo) {}(1)

[13:01] <camelia> rakudo-moar 83d733: ( no output )

[13:01] <jnthn> jkramer: In my @a = [1,2,3], @a is an Array object, and assignment into it is a copying operation

[13:03] <jkramer> So that's pretty much like in Perl 5 but more "transparent" in that I don't have to dereferece $a all the time explicitly?

[13:03] <gfldex> m: sub f(){ 1,2,3 }; my @a = f; dd @a; my $a = f; dd $a

[13:03] <camelia> rakudo-moar 83d733: OUTPUT«Array @a = [1, 2, 3]␤List $a = $(1, 2, 3)␤»

[13:03] <gfldex> if you look at the $a = part, you may wonder if more then value was expected

[13:08] *** imcsk8 joined
[13:09] *** Actualeyes joined
[13:13] *** gregf_ left
[13:17] *** sufrostico joined
[13:20] *** sftp left
[13:21] <moritz>         

[13:21] *** bioduds left
[13:22] *** sftp joined
[13:28] *** zakharyas joined
[13:35] *** skids joined
[13:43] *** FROGGS joined
[13:45] *** gregf_ joined
[13:46] <FROGGS> hi, I've got a question even though it is not a question about Perl 6 directly...

[13:46] <FROGGS> say, I have a bunch of timespans, and I want to display these in a calender (on a webpage)

[13:47] <FROGGS> and the data is like:

[13:47] <FROGGS> <---------> <------------->

[13:47] <FROGGS> <----> <-------> <-------->

[13:47] <FROGGS> <---------->       <---->

[13:48] <FROGGS> what's the right algorithm to sort these timespans? I want to minimize the number of rows used for display

[13:48] <jnthn> Hm, isn't that a kind of packing algorithm?

[13:49] <FROGGS> sounds like a good name for it :o)

[13:49] <arnsholt> (Packing problems having a tendency to be NP-complete)

[13:49] <arnsholt> =)

[13:52] <jnthn> Yeah... http://www.aaai.org/Papers/ICAPS/2003/ICAPS03-029.pdf agrees :)

[13:53] *** cdg joined
[13:53] <jnthn> Though it's not quite a traditonal packing problem  'cus the exact horizontal position is constrained

[13:53] <jnthn> So only the vertical is up for choosing

[13:53] <FROGGS> aye

[13:55] *** domidumont left
[13:56] <jnthn> I wonder if it maps more closely to https://en.wikipedia.org/wiki/Knapsack_problem

[13:57] *** domidumont joined
[13:57] <hackedNO1> Sounds like a sudoku solver can figure this out...

[13:57] <hackedNO1> Each line needs to sum up to X, find stuff that matches that, build lines out of it.

[13:58] <hackedNO1> and append leftovers.

[13:58] <FROGGS> well, it does not have to some up

[13:58] <FROGGS> I mean, there might be holes

[14:00] <jnthn> Did you already see how badly some simplistic greedy approach does (e.g. sort them smallest first and then try to place them on the line(s) you currently have, appending an extra line if not?

[14:01] <FROGGS> well, the result is not ideal...

[14:01] <jnthn> *nod*

[14:01] <FROGGS> usally it ends up as:

[14:01] <FROGGS> <------->

[14:01] <FROGGS>       <--------->

[14:01] <FROGGS>                <-------->

[14:01] <timotimo> it may be np-complete or something, but the amount of data you have surely isn't gigantic?

[14:02] <timotimo> like, how much data would you need to have to reach an hour of computation time for this task?

[14:02] <jnthn> Why with what I suggested would it not place the second one on the first line?

[14:02] <FROGGS> no, it is just a bunch of spans, I guess not more than 20 items a day

[14:03] <timotimo> if there's ever spots where no spans overlap at all, you can chop the problem up into smaller pieces

[14:03] <FROGGS> jnthn: no, the second is the longest

[14:03] <timotimo> that'll make a gigantic dent in the complexity

[14:03] <FROGGS> maybe I just just sort them by time, and then loop over the rows and add them if there is space

[14:04] <FROGGS> and open new rows if it does not fit?

[14:04] <FROGGS> s/open/add/

[14:04] <nemo> FROGGS: I personally find it more helpful to not try to pack but instead sort by which timespan starts first

[14:04] <nemo> FROGGS: it makes it a lot easier for me to figure out what began when on a large calendar

[14:05] <FROGGS> yeah

[14:05] <nemo> I'd say that simplifies your algorithm.  Maybe focus on visually fitting them better?

[14:05] <nemo> perhaps make them less tall, maybe they could grow on hover

[14:05] *** woolfy left
[14:05] <FROGGS> nah, you should be able to see how tall the spans are...

[14:05] <nemo> FROGGS: 10y ago they asked me for a calendar for our local IT team.  whipped it up w/ one db table and one query and one dynamic page ☺

[14:06] <nemo> calendars are pretty simple

[14:06] *** woolfy joined
[14:06] <FROGGS> it's a calender, with a red "now"-bar so the start and end times need to be correct

[14:06] *** wamba joined
[14:06] <FROGGS> okay, I think I've got a starting point now...

[14:10] *** zakharyas left
[14:13] <jnthn> FROGGS: fiww, https://gist.github.com/jnthn/ebe9161915c917be62222a707300c974 is what I was thinking of :)

[14:15] <FROGGS> huh, nice

[14:16] <FROGGS> jnthn++

[14:16] <FROGGS> :o)

[14:16] <FROGGS> damn how I love this channel

[14:18] <FROGGS> for a little test the result is better when I sort them longest-first

[14:18] <FROGGS> but that might be coincidence

[14:19] *** donaldh joined
[14:19] <jnthn> Yeah, this is fore sure doing a quick approximation

[14:19] <FROGGS> though, the longest span usually is the most important for the user, so it might make sense to see the longest at the top

[14:19] <jnthn> ah, yes. :)

[14:20] * FROGGS .oO( it is not just about data, it is about users )

[14:20] <jnthn> :)

[14:21] <jnthn> Yeah, making it @spans.sort(-*.trim.chars) makes it a little nicer on the eye in the slightly bigger example I tired it with too :)

[14:22] *** mohae joined
[14:28] *** cdg left
[14:28] *** kurahaupo joined
[14:31] *** FROGGS left
[14:31] <rjbs> [Coke]: Well done, re: SSL!

[14:33] <[Coke]> rjbs: oh, that email alert? I tell you, my calendar alert this morning was VERY confusing. :)

[14:38] <hackedNO1> m: https://gist.github.com/zoffixznet/da7782c0cce54d4e80cb859bbe05ddbd

[14:38] <camelia> rakudo-moar 83d733: OUTPUT«========================================␤<-------------------><-----------><---->␤<--------><--------><-----><-----><---->␤<-----><-----><----><---->␤»

[14:38] *** tokomer joined
[14:42] *** ItayAlmog joined
[14:43] *** wamba left
[14:47] <RabidGravy> what larks

[14:51] *** nadim left
[14:51] *** nadim joined
[14:52] *** ItayAlmog left
[14:52] <jferrero> m: say 4 == (1E12.log10 / 3).truncate

[14:52] <camelia> rakudo-moar 83d733: OUTPUT«False␤»

[14:53] <hackedNO1> :(

[14:53] <jferrero> m: say 5 == (1E15.log10 / 3).truncate

[14:53] <camelia> rakudo-moar 83d733: OUTPUT«False␤»

[14:53] <hackedNO1> the RHS evaluates to 3

[14:53] <hackedNO1> s: (1E15.log10 / 3), 'truncate', \()

[14:53] <SourceBaby> hackedNO1, Ehhh... I'm too scared to run that code.

[14:53] <hackedNO1> really

[14:54] *** ZoffixW joined
[14:54] *** mmlj4 joined
[14:54] <ZoffixW> s: (1E15.log10 / 3), 'truncate', \()

[14:54] <SourceBaby> ZoffixW, Sauce is at https://github.com/rakudo/rakudo/blob/83d733c/src/core/Real.pm#L60

[14:54] <[Coke]> m: say 4 ≅ (1E12.log10 / 3)

[14:54] <camelia> rakudo-moar 83d733: OUTPUT«True␤»

[14:55] <hackedNO1> m: say (1E12.log10 / 3).floor

[14:55] <camelia> rakudo-moar 83d733: OUTPUT«3␤»

[14:55] <hackedNO1> m: say (1E12.log10 / 3)

[14:55] <camelia> rakudo-moar 83d733: OUTPUT«4␤»

[14:55] <hackedNO1> floating point, yada yada :)

[14:56] *** hackedNO1 is now known as hackedNODE2

[14:56] *** ZoffixW left
[14:56] *** hackedNODE2 is now known as hackedNODE

[14:56] *** rgrinberg left
[14:58] *** SourceBaby left
[14:58] *** Undercover left
[14:58] *** SourceBaby joined
[14:58] <hackedNODE> s: (1E15.log10 / 3), 'truncate', \()

[14:58] <SourceBaby> hackedNODE, Sauce is at https://github.com/rakudo/rakudo/blob/83d733c/src/core/Real.pm#L60

[14:58] <hackedNODE> \o/

[14:58] *** cyphase left
[14:58] *** Undercover joined
[15:01] <jferrero> so...

[15:01] <jferrero> m: say 4 == (1E12.log10 / 3).Int

[15:01] <camelia> rakudo-moar 83d733: OUTPUT«False␤»

[15:02] *** itaipu left
[15:02] *** sufrostico left
[15:03] <[Coke]> m: say 4 == (1E12.log10 / 3).Rat

[15:03] <camelia> rakudo-moar 83d733: OUTPUT«True␤»

[15:03] *** cyphase joined
[15:04] *** cyphase left
[15:04] *** cyphase joined
[15:06] <jferrero> m: (1E12.log10 /3).Rat.nude.say

[15:06] <camelia> rakudo-moar 83d733: OUTPUT«(4 1)␤»

[15:08] *** mmlj4 left
[15:10] <grondilu> https://gist.github.com/grondilu/2042abc2d847bcd480f6f9caaf513fac

[15:10] *** nadim left
[15:11] *** nadim joined
[15:13] *** mempko joined
[15:13] <grondilu> example:

[15:13] *** itaipu joined
[15:13] <grondilu> m: grammar { rule TOP { \!<TOP> }.parse: "" # works fine

[15:13] <camelia> rakudo-moar 83d733: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3e TOP { \!<TOP> }.parse: "" # works fine7⏏5<EOL>␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loop␤»

[15:14] <grondilu> m: grammar { rule TOP { \!<TOP> } }.parse: "" # works fine

[15:14] <camelia> rakudo-moar 83d733: ( no output )

[15:14] <grondilu> but:

[15:14] <grondilu> m: grammar { rule TOP { <TOP>\! } }.parse: "" # hangs

[15:14] <camelia> rakudo-moar 83d733: OUTPUT«Memory allocation failed; could not allocate 65712 bytes␤»

[15:14] <perlpilot> grondilu: How is Perl 6 to know if <expression> matches without trying to match it?  And in doing so, it eventually tries to match <application> which tries to match <expression> again, as infinitum

[15:15] <perlpilot> Perl 6 isn't smart enough to tell you that your recursion doesn't have a good terminating condition

[15:15] <grondilu> but a null string can never match expression since expression contains characters.

[15:16] <grondilu> I suppose I could add a code assertion at the beginning, testing that we're dealing with a non-zero string

[15:16] *** pmurias left
[15:17] <perlpilot> that has nothing to do with it really.   It's the same as if you'd done:  sub foo { bar }; sub bar { baz }; sub baz { foo }  and then tried to call foo.  The other stuff in your rules doesn't come into play

[15:17] <grondilu> if you think sequentially, yes.  But logically, it should work.

[15:18] <grondilu> grammar { rule TOP { <TOP>\! } }.parse: "" # should not hang imho

[15:21] <perlpilot> currently you have to give it some hints about why it should not hang.

[15:21] <grondilu> because there is no '!' in ""

[15:22] <perlpilot> So .... should  sub foo { foo; say "never here" }  not hang as well?   

[15:22] <perlpilot> er, when you call foo that is

[15:23] <grondilu> to me that should not be the same.

[15:24] <perlpilot> But it is the same.  Rule matching is directly analogous to calling subs.

[15:24] <kurahaupo> left recursive grammars are not evaluated by recursively calling functions, but rather by state shifting, so they are not analogous

[15:24] <grondilu> I know  TimToady says that grammars are just classes with special syntax, but still, the spirit of what a regex is tells me that an empty string should not match a regex containing a character, *no matter where this character is placed in the regex*

[15:25] <kurahaupo> at least, that is the theory. dunno how our parser engine works to that level of detail

[15:27] <kurahaupo> grondilu: that is true of actual REGULAR expressions, but a lot of pattern matching expressions are is longer actually regular, they're something else

[15:27] <kurahaupo> are *no* longer...

[15:28] <grondilu> grammar { rule TOP { <?{ .chars }> <TOP>\! } }.parse: ""

[15:28] <grondilu> m: grammar { rule TOP { <?{ .chars }> <TOP>\! } }.parse: ""

[15:28] <camelia> rakudo-moar 83d733: OUTPUT«No such method 'chars' for invocant of type 'Any'␤  in regex TOP at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[15:28] <grondilu> m: "foo" ~~ / <?{ say $_ }> /

[15:28] <camelia> rakudo-moar 83d733: OUTPUT«foo␤»

[15:29] <grondilu> m: "foo" ~~ / <?{ say .chars }> /

[15:29] <camelia> rakudo-moar 83d733: OUTPUT«3␤»

[15:29] *** patrickz joined
[15:29] <perlpilot> ~~ topicalizes the LHS

[15:29] <kurahaupo> the term "regex" is extremely badly abused these days, to mean any sort of pattern matching expression, when that most certainly was NOT the original point

[15:29] <perlpilot> Grammar.parse() does no such thing

[15:30] <perlpilot> kurahaupo: you mean the term "regex" has come to mean something more than the mathematical definition of "regular expression"  ;-)

[15:30] <gfldex> m: dd Regex.new # the Regex is a lie!

[15:30] <camelia> rakudo-moar 83d733: OUTPUT«Cannot make a Regex object using .new␤  in block <unit> at <tmp> line 1␤␤»

[15:31] <kurahaupo> perlpilot: yes, to the point where the guarantees offered by true regular expressions -- like linear search time -- are no longer valid

[15:31] <perlpilot> yep ...  that TimToady guy sure messed stuff up!  ;)

[15:32] <TimToady> m: grammar { rule TOP { <!{ say "HERE"; False }><TOP>\! } }.parse: ""

[15:32] <perlpilot> I suppose Henry Spencer may have messed it up before him 

[15:32] <kurahaupo> perlpilot: "more than" is a matter of perspective; they're also "worse performing than"

[15:32] <TimToady> in fact, the LTMer notices left recursion and stops, so it shouldn't be too hard to warn about that

[15:32] *** bstamour joined
[15:32] <camelia> rakudo-moar 83d733: OUTPUT«(timeout)HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HERE␤HE…»

[15:32] *** grondilu is now known as Guest35250

[15:33] <TimToady> you'll note that recurses in the actual matching call, not in the LTM transitivity calculator

[15:33] *** grondilu joined
[15:34] *** Guest35250 left
[15:34] <TimToady> so the \! never gets to be part of LTM

[15:35] <TimToady> and only the longest token is treated as a classical regular expression

[15:36] <grondilu> what about <?{ .chars }>  ?  Why can I not use it in TOP?

[15:36] <psch> because $_ isn't $/ in Grammars

[15:36] <TimToady> correct

[15:36] <grondilu> what does refer to the argument given to the regex?

[15:37] <TimToady> $¢.orig

[15:37] *** tokomer left
[15:38] * grondilu is not sure if TimToady is kidding

[15:38] * TimToady is sure

[15:38] <perlpilot> TimToady: could the LTM happen more "holistically" on each rule?

[15:39] <psch> m: grammar G { rule TOP { <?{ $¢.orig }> <TOP>\! } }; say G.parse: ""; 

[15:39] <camelia> rakudo-moar 83d733: OUTPUT«Nil␤»

[15:39] * grondilu never seen $¢ before

[15:40] <TimToady> perlpilot: no idea what you mean by 'holistically' there...

[15:40] <perlpilot> grondilu: I tend to think of $¢ as the speculative $/ as the regex is matching.

[15:40] <TimToady> in rakudo, $¢ happens to be the same as $/.CURSOR

[15:41] <perlpilot> TimToady: that's okay, I'm not sure either.   I tend to think of LTM happening in a left-to-right fashion.  Is that true or just something crazy that stuck in my head?

[15:41] <TimToady> in STD, $¢ actually was the cursor, and match objects where really cursors in disguise

[15:41] <TimToady> note that you can usually get the original string with just self.orig, which is the entering cursor

[15:42] <TimToady> m: grammar G { rule TOP { <?{ say self.orig.chars }> <TOP>\! } }; G.parse: "";

[15:42] <TimToady> oops

[15:42] <camelia> rakudo-moar 83d733: OUTPUT«(timeout)0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0…»

[15:42] *** cognominal joined
[15:42] <TimToady> m: grammar G { rule TOP { <?{ say self.orig.chars; False }> <TOP>\! } }; G.parse: "";

[15:42] <camelia> rakudo-moar 83d733: OUTPUT«0␤»

[15:43] <TimToady> m: grammar G { rule TOP { <?{ say self.orig.chars; False }> <TOP>\! } }; G.parse: "foo";

[15:43] <camelia> rakudo-moar 83d733: OUTPUT«3␤»

[15:43] *** Celelibi left
[15:45] *** Celelibi joined
[15:45] <TimToady> perlpilot: LTM has to be anchored to the current position, since "longest" in this case implies "measured from a common starting point"

[15:46] <TimToady> it's a little confusing that classical scanning regexes return the "longest" match, but that's something different than LTM

[15:46] <TimToady> LTM is more about leftmost longest

[15:47] <TimToady> because a parser always wants to know the next token that starts "right here"

[15:47] *** dalek left
[15:47] <grondilu> isn't $¢ referring to the string passed to the whole grammar, though?

[15:48] *** dalek joined
[15:48] *** ChanServ sets mode: +v dalek

[15:48] <grondilu> (because that what some attempts of mine suggest)

[15:49] <grondilu> m: grammar { rule TOP { { say $¢ } <foo> <bar> }; token foo { foo }; token bar { bar } }.parse: "foo bar";

[15:49] <camelia> rakudo-moar 83d733: OUTPUT«<anon|51875936>.new␤»

[15:49] <TimToady> $¢ is referring only to the current instantaneous cursor, but every cursor maintains a reference to the unchanging bits, and .orig follows that link to find the original string

[15:49] <patrickz> How would I specify the dimensionality of an array in a signature?

[15:50] <grondilu> m: grammar { rule TOP { { say $¢.orig } <foo> <bar> }; token foo { { say "foo $¢.orig" } foo }; token bar { bar } }.parse: "foo bar";

[15:50] <camelia> rakudo-moar 83d733: OUTPUT«foo bar␤foo <anon|74309888><69307040>.orig␤»

[15:50] <grondilu> m: grammar { rule TOP { { say $¢.orig } <foo> <bar> }; token foo { { say "(foo {$¢.orig})" } foo }; token bar { bar } }.parse: "foo bar";

[15:50] <camelia> rakudo-moar 83d733: OUTPUT«foo bar␤(foo foo bar)␤»

[15:50] <grondilu> m: grammar { rule TOP { { say $¢.orig } <foo> <bar> }; token foo { { say "(foo: {$¢.orig})" } foo }; token bar { { say "(bar: {$¢.orig})" } bar } }.parse: "foo bar";

[15:50] <camelia> rakudo-moar 83d733: OUTPUT«foo bar␤(foo: foo bar)␤(bar: foo bar)␤»

[15:51] <TimToady> .orig isn't gonna change, even when the cursor does

[15:51] <grondilu> so $¢.orig was not what I needed

[15:51] *** wamba joined
[15:51] <TimToady> the cursor represents both of 1) the current language you're parsing, 2) the current parse state, including current position

[15:52] <grondilu> oh

[15:52] <perlpilot> patrickz: you mean you want to say something like  sub foo(@array[2;3]) {...}  to only allow properly dimensioned arrays to be passed to foo?

[15:52] <patrickz> perlpilot: Yes, only without the actual sizes, only the dimension

[15:53] <TimToady> and it can't know what is going to match in the future because that would imply time travel

[15:53] <patrickz> sub foo(Int @array[;;]) {...}

[15:53] <patrickz> but that doesn't seem to work

[15:53] <grondilu> TimToady: I see better now.  Thanks.

[15:53] * grondilu was clearly overlooking stuff

[15:53] <TimToady> the LTM engine does parallel matching, and could in theory do DFA with states that can be in multiple positions at once

[15:53] *** domidumont left
[15:54] <perlpilot> patrickz: I'm not sure it's quite implemented completely, but you could try  sub foo(@a[*;*]) { ... }

[15:54] <TimToady> but once LTM has chosen the rule to run, everything is just one position at a time, matching procedurally

[15:55] <TimToady> though one future optimization is to skip rematching the bits that LTM matched if we don't need to capture anything

[15:56] *** FROGGS joined
[15:56] <TimToady> patrickz: we've reserved the syntax @array[*;*] for such things, but I don't think we know how to bind that yet

[15:56] <patrickz> sub foo(@m[*;*]){...}; foo([[1,2],[2,3]]);

[15:56] <patrickz> m: sub foo(@m[*;*]){...}; foo([[1,2],[2,3]]);

[15:56] <camelia> rakudo-moar 83d733: OUTPUT«Cannot resolve caller postcircumfix:<[; ]>(List); none of these signatures match:␤    (\SELF, @indices)␤    (\SELF, @indices, Mu \assignee)␤    (\SELF, @indices, :$exists!)␤    (\SELF, @indices, :$delete!)␤    (\SELF, @indices, :$BIND!)␤  in su…»

[15:57] <patrickz> yeah

[15:57] <patrickz> I'll just leave it off then.

[15:57] <patrickz> Thanks for the info though. Will continue on my first p6 steps...

[15:58] <TimToady> we do want to get to that point someday relatively soon, but multi-dim arrays were about the last thing added before Christmas, so are still a bit rudimentary in spots

[16:00] <psch> m: sub f(@m where *.shape.elems == 2) { }; my @a[2;2] = (1,2),(3,4); f @a # as a workaround maybe

[16:00] <camelia> rakudo-moar 83d733: ( no output )

[16:00] <psch> at least if i understood the question correctly

[16:00] <patrickz> psch: Cool!

[16:00] <gfldex> m: my @a[2;3]; sub f(@a where .shape eqv (2,3) ){ say 'match' }; f @a;

[16:00] <camelia> rakudo-moar 83d733: OUTPUT«match␤»

[16:00] <patrickz> Could I check the content type also?

[16:01] <gfldex> that would be .of

[16:01] *** rgrinberg joined
[16:02] <FROGGS> ola

[16:10] <skids> Is "slobo" (github) here under a different nick?

[16:10] *** rgrinberg left
[16:11] *** mcmillhj left
[16:19] *** setty1 joined
[16:24] *** mcmillhj joined
[16:25] *** nowan joined
[16:29] *** mcmillhj left
[16:31] *** domidumont joined
[16:34] *** AlexDaniel left
[16:34] *** mcmillhj joined
[16:35] *** eliasr joined
[16:36] *** rgrinberg joined
[16:37] *** rgrinberg left
[16:38] *** rgrinberg joined
[16:39] *** mcmillhj left
[16:47] *** mempko left
[16:51] *** edehont left
[16:52] *** mcmillhj joined
[16:53] *** Actualeyes left
[16:57] *** mcmillhj left
[17:01] *** Guest65191 is now known as ponbiki

[17:06] *** mempko joined
[17:06] *** girafe joined
[17:08] *** mcmillhj joined
[17:12] *** sufrostico joined
[17:18] *** itaipu left
[17:20] *** bstamour left
[17:20] *** djbkd joined
[17:23] *** Actualeyes joined
[17:25] *** itaipu joined
[17:28] *** donaldh left
[17:28] *** donaldh joined
[17:29] *** wamba left
[17:32] *** djbkd_ joined
[17:33] *** ItayAlmog joined
[17:33] *** donaldh left
[17:34] <ItayAlmog> I looked at the NQP sources and i saw there is something called knowhow, what is it?

[17:35] *** djbkd left
[17:35] <hackedNODE> ItayAlmog: a metaclass. Most meta

[17:36] <hackedNODE> ItayAlmog: this PDF has a mention of it: http://edumentab.github.io/rakudo-and-nqp-internals-course/slides-day2.pdf

[17:36] <ItayAlmog> hackedNODE: Thanks

[17:36] <hackedNODE> m: 42.HOW.HOW.HOW.HOW.^name.say

[17:36] <camelia> rakudo-moar 83d733: OUTPUT«KnowHOW␤»

[17:40] <ItayAlmog> Does knowhow also have a REPR? Or is it the base REPR?

[17:41] <ItayAlmog> Oh, nvm, found the answer

[17:41] <psch> m: say 42.HOW.HOW.HOW.HOW.REPR

[17:41] <camelia> rakudo-moar 83d733: OUTPUT«KnowHOWREPR␤»

[17:42] <harmil_wk> m: say (42, *.HOW ... *)[3]

[17:42] <camelia> rakudo-moar 83d733: OUTPUT«No such method 'succ' for invocant of type 'Perl6::Metamodel::ClassHOW'␤  in block <unit> at <tmp> line 1␤␤»

[17:42] <harmil_wk> Why doesn't that work?

[17:42] <timotimo> probably because .HOW is not method-like

[17:42] <timotimo> m: say (42, { .HOW } ... *)[^5]

[17:42] <camelia> rakudo-moar 83d733: OUTPUT«No such method 'take' for invocant of type 'NQPClassHOW'␤  in block <unit> at <tmp> line 1␤␤»

[17:42] <timotimo> hah, whoops

[17:42] <timotimo> that's not cool

[17:43] <psch> ?

[17:43] <timotimo> something's calling .take instead of using routine take

[17:43] *** djbkd_ left
[17:45] <psch> yeah, &SEQUENCE does

[17:45] <psch> apparently exclusively

[17:45] <psch> well, .take is in Mu, so i understand the assumption

[17:46] *** ItayAlmog2805 joined
[17:46] *** ItayAlmog2805 left
[17:47] *** djbkd joined
[17:48] *** cyphase left
[17:49] *** ItayAlmog left
[17:49] <timotimo> oh, it's in Mu

[17:49] <timotimo> that's okay, then

[17:49] <timotimo> and it allows your stuff to change how sequence emits stuff

[17:49] <timotimo> so that's nice, too, i guess?

[17:52] *** donaldh joined
[17:53] *** ocbtec left
[17:53] <hackedNODE> m: say (42, { .HOW } ... *)[^5]

[17:53] <camelia> rakudo-moar 83d733: OUTPUT«No such method 'take' for invocant of type 'NQPClassHOW'␤  in block <unit> at <tmp> line 1␤␤»

[17:53] <hackedNODE> m: say (42, -> $v { class { has $.v; method take { take $!v.HOW } }.new: :$v } ... *)[^10]

[17:53] <camelia> rakudo-moar 83d733: OUTPUT«(42 Perl6::Metamodel::ClassHOW.new Perl6::Metamodel::ClassHOW.new Perl6::Metamodel::ClassHOW.new Perl6::Metamodel::ClassHOW.new Perl6::Metamodel::ClassHOW.new Perl6::Metamodel::ClassHOW.new Perl6::Metamodel::ClassHOW.new Perl6::Metamodel::ClassHOW.new Perl…»

[17:53] <timotimo> :D

[17:53] *** cyphase joined
[17:54] <hackedNODE> m: say (42, -> $v { class { has $.v; method take { take $!v.HOW } }.new: :v($v.HOW) } ... *)[^10]

[17:54] <camelia> rakudo-moar 83d733: OUTPUT«No such method 'gist' for invocant of type 'NQPClassHOW'␤  in block <unit> at <tmp> line 1␤␤»

[17:54] <hackedNODE> m: .^name.say for (42, -> $v { class { has $.v; method take { take $!v.HOW } }.new: :v($v.HOW) } ... *)[^10]

[17:54] <camelia> rakudo-moar 83d733: OUTPUT«Int␤NQPClassHOW␤NQPClassHOW␤NQPClassHOW␤NQPClassHOW␤NQPClassHOW␤NQPClassHOW␤NQPClassHOW␤NQPClassHOW␤NQPClassHOW␤»

[17:54] <timotimo> a decont was missing perhaps?

[17:54] * hackedNODE shrugs

[17:57] *** donaldh_ joined
[17:58] *** djbkd left
[17:59] *** donaldh left
[17:59] *** donaldh_ is now known as donaldh

[18:04] *** djbkd joined
[18:07] *** ItayAlmog joined
[18:08] <ItayAlmog> So NQP is basically knowhow, the nqp:: ops and some basic reprs (like P6int)

[18:09] <timotimo> the reprs live in the backend, so all reprs available to rakudo are available to nqp as well

[18:10] <moritz> ItayAlmog: NQP is much more than that; like a fully-fledged compiler with a grammar engine

[18:11] <timotimo> right, the grammar stuff is also already complete at the nqp "stage"

[18:12] *** canopus left
[18:12] <ItayAlmog> Ok, i think i am ready to start working on the native NQP compiler, it won't contain the Grammar Engine yet

[18:12] *** djbkd left
[18:13] *** domidumont left
[18:14] *** canopus joined
[18:16] *** ItayAlmog2805 joined
[18:16] *** Actualeyes left
[18:16] *** donaldh left
[18:17] *** skids left
[18:19] *** Dunearhp joined
[18:19] *** djbkd joined
[18:20] *** ItayAlmog left
[18:22] *** AlexDaniel joined
[18:26] *** djbkd left
[18:30] *** Actualeyes joined
[18:32] *** djbkd joined
[18:34] *** imcsk8 left
[18:35] *** mempko left
[18:43] *** ItayAlmog2805 left
[18:44] *** djbkd left
[18:48] *** djbkd joined
[18:52] *** domidumont joined
[18:54] *** ItayAlmog2805 joined
[18:56] *** ItayAlmog2805 left
[18:57] *** ItayAlmog2805 joined
[18:58] *** rgrinberg left
[18:58] *** djbkd left
[19:01] *** bstamour joined
[19:03] *** djbkd joined
[19:07] *** mcmillhj left
[19:07] *** mcmillhj joined
[19:13] *** djbkd left
[19:19] *** mempko joined
[19:19] *** djbkd joined
[19:22] *** khw joined
[19:23] *** labster joined
[19:25] <hackedNODE> 𝐈𝐓 𝐈𝐒 𝐒𝐎 𝐐𝐔𝐈𝐄𝐓 𝐈𝐍 𝐇𝐄𝐑𝐄!! 

[19:26] <timotimo> none of these show up in my terminal :D

[19:26] <timotimo> all just little question-mark-diamonds

[19:26] <geekosaur> worked here (for a pleasant surprise)

[19:27] <hackedNODE> timotimo: http://i.imgur.com/kFFzzgT.png

[19:29] <DrForr> It's also evening in Europe...

[19:30] <tailgate> I knew I supported unicode for a reason

[19:33] <hackedNODE> m: (.uc, 6, .flip).join.Int.is-prime.say given 1e14+6

[19:33] <camelia> rakudo-moar 83d733: OUTPUT«True␤»

[19:33] <hackedNODE> :)

[19:33] *** djbkd left
[19:34] <gfldex> Channel.send states it throws X::Channel::SendOnClosed if the channel is already closed. Is that still true? (I can see that exception but it may be swollowed somewhere.)

[19:34] <gfldex> s/can/can't/

[19:34] <hackedNODE> m: .send given Channel.new.close; CATCH { default { .^name.say } }

[19:34] <camelia> rakudo-moar 83d733: ( no output )

[19:34] *** ItayAlmog2805 left
[19:35] <hackedNODE> m: .close, .send: 42 given Channel.new; CATCH { default { .^name.say } }

[19:35] <camelia> rakudo-moar 83d733: OUTPUT«X::Channel::SendOnClosed␤»

[19:35] <gfldex> good, no EFALSEDOC then :)

[19:36] *** djbkd joined
[19:37] <hackedNODE> m: Nil.dasdasdasdasdasdasdas

[19:37] <camelia> rakudo-moar 83d733: ( no output )

[19:37] <hackedNODE> TIL

[19:37] <hackedNODE> s: Nil, 'dasdsdasa'

[19:37] <SourceBaby> hackedNODE, Something's wrong: ␤ERR: Type check failed in binding to &code; expected Callable but got Nil (Nil)␤  in sub do-sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 42␤  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 33␤  in block <unit> at -e line 6␤␤

[19:37] <masak> whoa.

[19:37] *** domidumont left
[19:38] *** rgrinberg joined
[19:38] <dalek> ecosystem: fab4f7c | (Brian Duggan)++ | META.list:

[19:38] <dalek> ecosystem: p6-Crypt-RSA

[19:38] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/fab4f7c2a9

[19:38] <dalek> ecosystem: 4b1f035 | (Zoffix Znet)++ | META.list:

[19:38] <dalek> ecosystem: Merge pull request #257 from bduggan/p6-crypt-rsa

[19:38] <dalek> ecosystem: 

[19:38] <dalek> ecosystem: p6-Crypt-RSA: https://github.com/bduggan/p6-Crypt-RSA

[19:38] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/4b1f0351bd

[19:40] <hackedNODE> It's just a FALLBACK to Nil: https://github.com/rakudo/rakudo/blob/nom/src/core/Nil.pm#L23

[19:41] *** labster left
[19:48] *** djbkd left
[19:48] *** ItayAlmog2805 joined
[19:52] *** djbkd joined
[19:57] *** khw left
[20:01] <Woodi_> hmm, debian package require libjs-angularjs for rakudo... someone know reason maybe ?

[20:02] <Woodi_> blame pmurias++ ? :)

[20:03] *** djbkd left
[20:04] *** pmurias joined
[20:04] <pmurias> Woodi_: not yet

[20:04] <pmurias> Woodi_: rakudo profiler uses angular.js

[20:04] *** ItayAlmog2805 left
[20:07] *** djbkd joined
[20:11] <Woodi_> ah, k, thanx

[20:13] *** seatek joined
[20:16] *** djbkd left
[20:17] *** TEttinger joined
[20:18] <seatek> Hello :) So, wondering if anyone might know - in a parameter signature, if you have a slurpy array (*@thing) -- is there a way to define a default set of values for it, if nothing gets slurped up? 

[20:20] <seatek> like MAIN ( :$firstopt = 'yellow, *@restOfOpts = ('one', 'two') )

[20:20] <seatek> or is that crazy?

[20:23] <gfldex> m: sub f(*@a = (1,2,3)){ dd @a }; f

[20:23] <camelia> rakudo-moar 83d733: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Cannot put default on slurpy parameter @a␤at <tmp>:1␤------> 3sub f(*@a = (1,2,3)7⏏5){ dd @a }; f␤    expecting any of:␤        constraint␤»

[20:25] <seatek> yeah I haven't been able to find a way that does it - but I'm only just now sticking my toes in the water of perl6

[20:25] <seatek> (coming from 5)

[20:25] <gfldex> m: multi f(*@a){ dd @a }; multi f(@a = (1,2,3)){ dd @a }; f 42; f

[20:25] <camelia> rakudo-moar 83d733: OUTPUT«[42]␤(1, 2, 3)␤»

[20:25] * hackedNODE wonders whether that constraint is artificial

[20:25] <gfldex> seatek: ^^^

[20:25] *** FROGGS left
[20:25] <seatek> oo

[20:26] <gfldex> seatek: IIRC the order of multi definitions is relevant in this case

[20:26] *** djbkd joined
[20:28] <Woodi_> damn, panda don't install, zef segfaults...

[20:28] <seatek> i suspected multi's but i wonder how that will work since there are named parameters involved too. i'll try just duplicating it, except for the slurpy bit which will be defined in the second

[20:29] <hackedNODE> seatek, pass the nameds through a capture

[20:29] <hackedNODE> s: 42, 'split'

[20:29] <SourceBaby> hackedNODE, Sauce is at https://github.com/rakudo/rakudo/blob/83d733c/src/core/Cool.pm#L177

[20:29] <hackedNODE> ^ an example

[20:32] <seatek> yeah - i get the old error Cannot put optional positional parameter @slurpyArray after variadic parameters

[20:32] *** mempko left
[20:32] <hackedNODE> What's your sig?

[20:32] <seatek> capture -- ok -- checking that out... remember reading about that earlier ;0

[20:33] *** prammer joined
[20:33] <hackedNODE> Put capture after the args

[20:33] <hackedNODE> *after params

[20:33] *** prammer left
[20:34] <seatek> sub MAIN ( Str :$log-file = 'blah', Bool :$thing = False, *@srcDirs )

[20:34] <hackedNODE> That gives the error? Put slurpy first

[20:35] <seatek> that doesn't give the error

[20:35] <hackedNODE> OK

[20:35] <seatek> it gives the error when i try to assign values to @srcDirs for "default"

[20:35] * hackedNODE doesn't have a computer around to play with this

[20:36] <seatek> sub MAIN ( Str :$log-file = 'blah', Bool :$thing = False, @srcDirs = ('/tmp', '/var/log' ))

[20:36] <seatek> that would give the error

[20:37] <hackedNODE> And if you put positionals first?

[20:37] <seatek> yuppers!

[20:38] *** djbkd left
[20:39] <seatek> that exact sub MAIN code gives:

[20:39] <seatek> Cannot put optional positional parameter @srcDirs after variadic parameters

[20:40] <seatek> ----->  False, @srcDirs = ('/tmp', '/var/log' )⏏)

[20:40] <seatek>     expecting any of:

[20:40] *** pecastro joined
[20:40] <seatek>         constraint

[20:42] *** djbkd joined
[20:43] <seatek> and if you give it the slurpy splat, it's the same error message

[20:43] <seatek> none of the docs i could find mention this -- so I suspect it's something weird

[20:44] <seatek> like not supported ... or maybe meant to be? or some trick..  so I've been hunting... ;)

[20:47] <timotimo> last night while i was trying to fall asleep i was wondering how many things you can make exploded with CATCH { default { .resume } }

[20:48] <harmil_wk> timotimo: just a few more than setting an ignore handler for all catchable signals...

[20:48] <timotimo> you think?

[20:49] <timotimo> like, usually after "die" the code assumes the rest of the routine is dead code

[20:52] *** djbkd left
[20:54] *** mcmillhj left
[20:58] *** bstamour left
[20:58] *** djbkd joined
[21:00] <arnsholt> timotimo: Yeah, I discovered the solution to that problem in the SmallTalk code at work this week: return die Exception.new(...)

[21:00] <arnsholt> (Except in ST, obv)

[21:04] *** MARTIMM left
[21:06] <masak> seatek: I agree that "it's the same error message" is more confusing than it has to be

[21:07] <masak> seatek: what it really should do in the case of the slurpy is to give you the error "Cannot put default on slurpy parameter @srcDirs"

[21:07] <masak> m: sub MAIN (*@srcDirs = ("/tmp", "/var/log" )) {}

[21:07] <camelia> rakudo-moar 83d733: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Cannot put default on slurpy parameter @srcDirs␤at <tmp>:1␤------> 3 MAIN (*@srcDirs = ("/tmp", "/var/log" )7⏏5) {}␤    expecting any of:␤        constraint␤»

[21:07] <masak> ...which it does if you don't put named parameters before it

[21:07] *** djbkd left
[21:10] * masak submits rakudobug

[21:10] *** mcmillhj joined
[21:10] <seatek> masak: yeah, I noticed that too! I guess it's just not supported, which is fine. It would be nice to have that in docs somewhere - can't assign defaults to slurpy stuff! 

[21:11] *** djbkd joined
[21:11] <seatek> masak: It's just a convenience, anyway. I was getting used to defining all my "variable" variables up there in the signature, which was pretty nice and handy.

[21:12] <seatek> masak: but guess for slurpy's, it has to be the old way of testing if anything is there, and then assigning if not

[21:14] *** patrickz left
[21:15] <masak> seatek: yes.

[21:15] *** Zoffix left
[21:16] <masak> seatek: I think as to your original question -- whether it's supported -- the answer is no because you basically can not *not* pass in a set of values to the slurpy parameter.

[21:16] <seatek> masak: yeah, that makes complete sense when you really think about it

[21:17] <mst> oh, yes, of course, because () is a completely reasonable thing

[21:17] <masak> right.

[21:17] <seatek> it's eveywhere

[21:18] <seatek> i'm guessing that it's just not an array yet - it's a thing waiting to happen -- and if you assign before that, it can't cope

[21:19] <masak> m: sub MAIN (:$named, *@srcDirs = ("/tmp", "/var/log" )) {}

[21:19] <camelia> rakudo-moar 83d733: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Cannot put optional positional parameter @srcDirs after variadic parameters␤at <tmp>:1␤------> 3named, *@srcDirs = ("/tmp", "/var/log" )7⏏5) {}␤    expecting any of:␤        constraint␤»

[21:23] <seatek> there's something screwy there I think anyway

[21:24] <masak> mst: the semipredicative question "was a value passed to this parameter?" comes up with some regularity on this channel.

[21:24] *** djbkd left
[21:25] <masak> mst: the problem with the whole thing is that it's not really a question to the *parameter* as such, but to the signature binder.

[21:25] *** ptolemarch left
[21:25] <masak> ...which is not a first-class citizen.

[21:25] *** djbkd joined
[21:25] *** mempko joined
[21:27] *** skids joined
[21:33] *** edehont joined
[21:35] *** djbkd left
[21:35] *** mcmillhj left
[21:40] *** djbkd joined
[21:51] *** mcmillhj joined
[21:52] *** djbkd left
[21:54] *** pmurias left
[21:55] *** labster joined
[21:55] *** mcmillhj left
[21:57] *** djbkd joined
[22:11] *** djbkd left
[22:13] *** Juerd left
[22:13] *** djbkd joined
[22:14] *** itaipu left
[22:16] <dalek> doc: 0f362ee | gfldex++ | doc/Type/Channel.pod6:

[22:16] <dalek> doc: LEAVE a note about Channel.close

[22:16] <dalek> doc: review: https://github.com/perl6/doc/commit/0f362ee198

[22:16] <timotimo> haha :D

[22:18] <seatek> I'm having so much fun with this. Some of the silliest little things just tickle me. Having to make so many new twisty brain paths... This really is wonderfully stitched together

[22:18] <gfldex> :), perl6 -Ofun

[22:19] <seatek> Honestly, I wasn't expecting it :)

[22:21] <seatek> It's strange how you can get so much more built-in stuff, yet still not be constrained. 

[22:22] <seatek> And even with that freedom, there seems to be more inherent order

[22:22] <RabidGravy> I've just spent half an hour looking at Scala and I'm not sure whether it's the way or documented or the language itself, but I'm not feeling the love

[22:25] *** djbkd left
[22:26] <gfldex> m: sub f($v, :&return-type = {.Int}){ $v.&return-type }; dd (f("42"), f("42", return-type => *.Rat))

[22:26] <camelia> rakudo-moar 1f29cb: OUTPUT«(42, 42.0)␤»

[22:26] *** djbkd joined
[22:28] <TEttinger> RabidGravy: what about scala isn't fantastic? perhaps the inheritance hierarchies are too simple? http://nurkiewicz.github.io/talks/2014/scalar/img/list-scala.png

[22:28] <yoleaux> 10:52Z <Zoffix> TEttinger: you need a term:<> to make it work. See http://perl6.party/post/Anguish--Invisible-Programming-Language-and-Invisible-Data-Theft

[22:32] <RabidGravy> TEttinger, it just feels like the mutant love child of python and java to me,  dull and uninspiring, but maybe it's just the documentation

[22:33] <TEttinger> no, that's pretty accurate

[22:33] <RabidGravy> it clearly has its fans though

[22:34] <TEttinger> my main issue with scala is that writing high-performance scala means giving up all the language features that are actually convenient and basically writing more verbose java

[22:35] *** japhb joined
[22:37] <TEttinger> i wrote a sizable chunk of scala for a game, hit all sorts of annoyances, with tooling especially but also core language weirdness

[22:38] *** djbkd left
[22:38] <TEttinger> like for loops always create iterators, which can be heavyweight on the JVM, and the only way to get performance on par with "for(int i=0; i < 10; i++)" is with a while loop

[22:38] <RabidGravy> my curiosity was picqued when I saw someone was using it for a radio station and have seen a couple of people advertising jobs

[22:39] <TEttinger> they may be hopping on the bandwagon because of twitter

[22:39] <TEttinger> I think twitter isn't still using scala heavily, not sure

[22:40] <dalek> doc: 13cecb9 | gfldex++ | doc/Type/IO.pod6:

[22:40] <dalek> doc: IO.close may requite a LEAVE too

[22:40] <dalek> doc: review: https://github.com/perl6/doc/commit/13cecb988c

[22:41] *** kaare_ left
[22:41] *** djbkd joined
[22:44] <TEttinger> they seem to be mixing all sorts of languages, judging by their open source stuff

[22:45] <TEttinger> http://twitter.github.io/

[22:46] *** wamba joined
[22:52] *** djbkd left
[22:52] *** TimToady joined
[22:59] *** djbkd joined
[23:11] *** BenGoldberg joined
[23:11] *** djbkd left
[23:11] <RabidGravy> actually I'm thinking it's the documentation that's turning me off:  " the delta in relationship to the superclass" , really?  This is written for CS students not people who want to learn the language

[23:13] *** djbkd joined
[23:25] *** mcmillhj joined
[23:25] *** djbkd left
[23:30] *** djbkd joined
[23:34] *** captain-adequate left
[23:39] *** edehont left
[23:40] *** djbkd left
[23:41] *** rindolf left
[23:41] *** girafe left
[23:44] *** djbkd joined
[23:49] *** rgrinberg left
[23:54] <dalek> doc: 8a9c656 | skids++ | doc/Type/Channel.pod6:

[23:54] <dalek> doc: enfoce grammar and spelling rules

[23:54] <dalek> doc: review: https://github.com/perl6/doc/commit/8a9c6567eb

[23:58] <RabidGravy> pfft to gramer abd speeling

[23:58] *** djbkd left
