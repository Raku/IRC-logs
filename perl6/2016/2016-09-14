[00:00] *** sufrostico left
[00:04] <Zoffix> tbrowder, don't know

[00:05] *** AndyBotwin joined
[00:06] *** setty1 left
[00:08] *** sufrostico joined
[00:10] *** DoverMo left
[00:11] *** mcmillhj joined
[00:12] *** espadrine left
[00:13] *** aries_liuxueyang left
[00:15] *** aries_liuxueyang joined
[00:16] *** mcmillhj left
[00:20] *** jameslenz joined
[00:22] *** xinming_ joined
[00:24] *** girafe left
[00:25] *** xinming left
[00:25] *** cdg left
[00:30] *** Pierre_ joined
[00:58] *** salva left
[00:59] *** mcmillhj joined
[01:03] *** mcmillhj left
[01:07] *** MasterDuke joined
[01:12] <Zoffix> MasterDuke, what have you done? :)

[01:12] <AlexDaniel> “Shit” – hahaha :D

[01:12] <Zoffix> :)

[01:13] <MasterDuke> ha. that's what happens when i accidentally make a PR from my master, not a branch, and then pull --rebase && push so origin isn't behind rakudo/nom

[01:13] <AlexDaniel> wait, did you rebase it other way around?

[01:14] *** bob777 joined
[01:15] <MasterDuke> my local checkout didn't have my PR commit. so i pulled from origin (my rakudo fork on github which did have that commit) --rebase

[01:15] <AlexDaniel> yeah. You have all other commits on top of your “Fix RT #118223” commit

[01:15] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=118223

[01:15] *** mcmillhj joined
[01:16] <MasterDuke> and then pushed, since my origin was behind

[01:18] <MasterDuke> my local was at rakudo/nom HEAD, my github was at approx rakudo/nom HEAD~100

[01:19] <MasterDuke> of course if you merge that PR i can't make that mistake again...

[01:20] *** mcmillhj left
[01:20] <MasterDuke> or can you, do i need to revert and push --force so it doesn't try to merge those already existing commits again?

[01:20] *** kalkin- left
[01:20] *** kalkin-_ joined
[01:21] <AlexDaniel> MasterDuke: yes, you can --force to update your PR

[01:22] <MasterDuke> revert it back to my commit?

[01:23] <AlexDaniel> well, you can revert all of the “shit” commits and then try again to do it correctly :)

[01:23] *** woolfy left
[01:23] *** woolfy joined
[01:24] <AlexDaniel> basically, in your own fork you can have as much git fun as you want

[01:27] *** Pierre_ left
[01:28] *** labster left
[01:28] *** mcmillhj joined
[01:31] *** Pierre_ joined
[01:32] <MasterDuke> Zoffix: http://irclog.perlgeek.de/perl6-dev/2016-09-12#i_13194500 and jnthn's reply http://irclog.perlgeek.de/perl6-dev/2016-09-12#i_13194709

[01:33] *** mcmillhj left
[01:33] <MasterDuke> how do you feel about merging the PR and closing the ticket, but creating a new ticket for the Positional case?

[01:33] *** Pierre_ left
[01:35] <Zoffix> MasterDuke, merged.

[01:35] <MasterDuke> thanks

[01:38] <MasterDuke> btw, https://github.com/rakudo/rakudo/pull/871, based on my last comment, think i should create some tickets for the differences in errors?

[01:40] <Zoffix> ¯\_(ツ)_/¯

[01:40] <Zoffix> No idea what "BOL" is.

[01:40] *** Pierre_ joined
[01:41] * Zoffix & sleep

[01:42] *** sufrostico left
[01:44] <MasterDuke> i think it means bold

[01:44] *** salva joined
[01:45] *** mcmillhj joined
[01:45] *** Pierre_ left
[01:45] *** ilbot3 left
[01:46] *** bpmedley joined
[01:46] <avuserow> BOL is probably beginning of line, since there's also an EOL nearby

[01:46] *** labster joined
[01:47] *** ilbot3 joined
[01:50] *** mcmillhj left
[01:51] <MasterDuke> avuserow: oh, that makes sense

[01:53] *** setty2 joined
[01:55] *** Pierre_ joined
[01:57] *** itaipu joined
[02:01] <Pierre_> Hola

[02:01] <Pierre_> i'm playing with native call, and i have an issue

[02:02] <Pierre_> i need to create a struct, that contains a ref to a funcitons

[02:02] *** mcmillhj joined
[02:02] *** itaipu left
[02:03] <shadowpaste> "Pierre_" at 217.168.150.38 pasted "Cstruct with a pointer to a function" (6 lines) at http://fpaste.scsys.co.uk/533757

[02:03] <Pierre_> any suggestion for that?

[02:03] *** itaipu joined
[02:05] *** Pierre_ left
[02:07] *** mcmillhj left
[02:07] *** Pierre_ joined
[02:09] *** labster left
[02:10] *** labster joined
[02:22] *** mcmillhj joined
[02:24] *** noganex_ joined
[02:24] *** kaare__ joined
[02:27] *** noganex left
[02:27] *** mcmillhj left
[02:47] *** mcmillhj joined
[02:52] *** mcmillhj left
[02:52] *** Pierre_ left
[02:53] <skids> m: use nqp; class C { has $.s = 41; submethod DESTROY { 42.say }}; my $c = C.new; $c = Nil; nqp::force_gc; sleep 0.1; sleep 0.1;

[02:53] <camelia> rakudo-moar beec02: OUTPUT«42␤»

[02:53] <skids> m: use nqp; class C { has $.s = 41; submethod DESTROY { 42.say }}; my $c = C.new; my $f = +($c.s); $c = Nil; nqp::force_gc; sleep 0.1; sleep 0.1;

[02:53] <camelia> rakudo-moar beec02: ( no output )

[02:53] <skids> Seems just accessing an attribute prevents DESTROY.

[03:00] *** Pierre_ joined
[03:04] *** Pierre_ left
[03:16] *** mcmillhj joined
[03:18] *** Pierre_ joined
[03:21] *** cyphase left
[03:21] *** mcmillhj left
[03:22] *** Pierre_ left
[03:26] *** cyphase joined
[03:27] *** Actualeyes left
[03:29] *** Actualeyes joined
[03:35] *** wamba joined
[03:41] *** Pierre_ joined
[03:43] *** pdcawley left
[03:44] *** pdcawley joined
[03:45] *** itaipu left
[03:46] *** mcmillhj joined
[03:51] *** mcmillhj left
[03:58] *** Pierre_ left
[04:00] <sammers_> hi perl6

[04:01] *** rgrinberg left
[04:02] *** Pierre_ joined
[04:09] <sammers_> is there a way to get the count of items in a Channel without emptying it?

[04:09] *** rgrinberg joined
[04:10] <sammers_> I tried this, "my $ch = Channel.new; $ch.send("Test 1"); $ch.elems;", but it just hangs.

[04:12] *** skids left
[04:13] *** sammers_ is now known as sammers

[04:15] *** cyphase left
[04:16] *** Actualeyes left
[04:19] *** leejo joined
[04:20] *** cyphase joined
[04:26] *** Pierre_ left
[04:29] *** Pierre_ joined
[04:31] *** khw left
[04:35] *** AlexDaniel left
[04:38] *** Actualeyes joined
[04:39] *** Sgeo_ joined
[04:42] *** Sgeo left
[04:44] *** Actualeyes left
[04:45] *** Actualeyes joined
[04:46] *** wamba left
[04:50] *** Pierre_ left
[04:54] *** mcmillhj joined
[04:58] *** Cabanossi left
[04:58] *** Pierre_ joined
[04:58] *** mcmillhj left
[05:01] *** Cabanossi joined
[05:02] *** Pierre_ left
[05:09] *** saaki left
[05:14] *** rgrinberg left
[05:16] *** Pierre_ joined
[05:21] *** Pierre_ left
[05:30] <moritz> sammers: no

[05:30] <moritz> sammers: you can look if there is an element with the .peek method

[05:33] *** domidumont joined
[05:34] *** Pierre_ joined
[05:35] <sammers> moritz, thanks, do you have any links to docs on peek? I can't seem to find it in docs.perl.org

[05:36] *** ufobat joined
[05:37] *** mcmillhj joined
[05:38] <sammers> nevermind, found it. it was marked private

[05:38] <sammers> https://github.com/rakudo/rakudo/commit/c64efea976

[05:39] *** Pierre_ left
[05:39] <sammers> https://github.com/rakudo/rakudo/blob/948aee0f405cbdd50f3fa1a310f56836856d630c/src/core/Channel.pm#L90

[05:41] *** domidumont left
[05:42] *** mcmillhj left
[05:51] *** firstdayonthejob joined
[05:52] *** domidumont joined
[05:52] *** Pierre_ joined
[05:53] <lizmat> sammers: probably the reason it's private, is that it probably is a bad thing to do, as it means you're introducing a race condition

[05:56] *** mcmillhj joined
[05:57] *** Pierre_ left
[06:01] *** mcmillhj left
[06:02] *** Pierre_ joined
[06:04] *** Xliff left
[06:07] *** _slade_ left
[06:09] <sammers> lizmat, thanks. I was looking to use it for auditing the channel draining as part of a test

[06:10] <sammers> the jvm commit message says "Make Channel.peek private, as it is not specced", but couldn't find any further references to it

[06:12] <lizmat> sammers: have you tried ?$channel[0]

[06:13] <sammers> lizmat: I will take a look

[06:15] *** Xliff joined
[06:19] <Pierre_> another "sketchy solution

[06:19] <Pierre_> you could do somethign like that:

[06:20] <Pierre_> m: role Countable { has $!how-many = 0;  method send( | ) { $!how-many++; callsame;}; method receive( | ) { $!how-many--; callsame;}; method count() {$!how-many } }; my $c = Channel.new but Countable; $c.send(1); $c.send(2); say $c.count(); $c.receive(); say $c.count();

[06:20] <camelia> rakudo-moar beec02: OUTPUT«2␤1␤»

[06:21] <Pierre_> how ever, it will have bugs with concurrency

[06:21] <Pierre_> but if you play with the Metamodel, you could probably make it safe

[06:22] <sammers> lizmat, I don't think ?$channel[0] will work...

[06:22] <sammers> m: my $ch = Channel.new; $ch.send("tester"); say ?$ch[0]; say $ch.poll; say ?$ch[0];

[06:22] <camelia> rakudo-moar beec02: OUTPUT«True␤tester␤True␤»

[06:22] <lizmat> hmmm... that's odd

[06:22] <lizmat> m: my $ch = Channel.new; $ch.send("tester"); say ?$ch[0]; say $ch.poll; say $ch[0]

[06:22] <camelia> rakudo-moar beec02: OUTPUT«True␤tester␤Channel.new␤»

[06:22] <sammers> also, acording to the docs we should be able to use .elems on a channel, but it hangs when I try using it.

[06:23] <Pierre_> elems is working

[06:23] <Pierre_> once the channel is closed

[06:23] <lizmat> ah, it's using the Mu.AT-POS and Mu.elems

[06:23] <Pierre_> m: my $ch = Channel.new; $ch.send("tester"); $ch.send("tester"); $ch.close(); say $ch.elems

[06:23] <camelia> rakudo-moar beec02: OUTPUT«2␤»

[06:23] <lizmat> so yeah, that won't work

[06:23] <sammers> ah

[06:23] <sammers> hmm

[06:23] <Pierre_> but it empties the channel

[06:24] <sammers> yeah

[06:24] <Pierre_> anyway, once close, i don't think you can receive anymore

[06:24] <sammers> I like that .peek idea, just want to see a current queue length

[06:24] *** canopus left
[06:24] <Pierre_> m: my $ch = Channel.new; $ch.send("tester"); $ch.send("tester"); $ch.close(); say $ch.receive

[06:24] <camelia> rakudo-moar beec02: OUTPUT«tester␤»

[06:24] <Pierre_> oh, you can

[06:25] <Pierre_> i mean receive on a closed channel

[06:25] <Pierre_> m: my $ch = Channel.new; $ch.send("tester"); $ch.send("tester"); $ch.close(); say $ch.elems; say $ch.receive

[06:25] <camelia> rakudo-moar beec02: OUTPUT«2␤Cannot receive a message on a closed channel␤  in block <unit> at <tmp> line 1␤␤»

[06:25] <sammers> m: my $ch = Channel.new; $ch.send("tester"); $ch.send("tester"); $ch.close(); say $ch.receive; $ch.send("another?"); say $ch.receive;

[06:25] <camelia> rakudo-moar beec02: OUTPUT«tester␤Cannot send a message on a closed channel␤  in block <unit> at <tmp> line 1␤␤»

[06:25] <sammers> hmm

[06:25] <Pierre_> ok, on an empty and closed channel, you can't

[06:25] <sammers> ok

[06:25] <sammers> well, good to know. 

[06:26] <lizmat> perhaps .elems should be non-destructive on a Channel

[06:26] <sammers> it would be nice

[06:26] * lizmat is testing a patch

[06:26] <Pierre_> howver, it is only available when the channel is closed

[06:26] <Pierre_> like list

[06:27] <lizmat> hmmm... patch segfaults

[06:27] <Pierre_> it's using the iterator under the hood i think

[06:28] *** canopus joined
[06:28] *** mcmillhj joined
[06:28] *** darutoko joined
[06:33] *** mcmillhj left
[06:35] <lizmat> Looks like Moar doesn't like you doing nqp::elems on a repr('ConcBlockingQueue')

[06:36] <lizmat> I think .elems on a Channel should be non-destructive

[06:36] <lizmat> so I'm going to let Channel.elems return a Failure

[06:44] *** Upasaka_ left
[06:47] *** firstdayonthejob left
[06:47] <lizmat> https://github.com/rakudo/rakudo/commit/5f2e96b8c0

[06:48] *** brrt joined
[06:51] <lizmat> breakfast&

[06:51] *** mcmillhj joined
[06:53] *** canopus left
[06:56] *** mcmillhj left
[06:56] *** rjt_pl left
[06:57] *** rjt_pl joined
[06:59] *** canopus joined
[07:00] *** ambs left
[07:03] *** notbenh left
[07:05] *** notbenh joined
[07:11] *** ambs joined
[07:12] *** mcmillhj joined
[07:16] *** mcmillhj left
[07:20] *** canopus_ joined
[07:21] *** canopus left
[07:22] *** Xliff left
[07:23] *** mcmillhj joined
[07:26] *** Xliff joined
[07:27] *** mcmillhj left
[07:32] *** wamba joined
[07:34] *** cpage_ left
[07:35] *** Xliff left
[07:35] *** cpage_ joined
[07:37] *** g4 joined
[07:39] *** TEttinger left
[07:41] *** Xliff joined
[07:48] *** zakharyas joined
[07:49] *** cyphase left
[07:51] *** infina left
[07:53] *** infina joined
[07:53] *** CIAvash joined
[07:54] *** cyphase joined
[07:55] *** krakan_ left
[07:55] *** krakan joined
[07:55] *** notostraca joined
[07:57] *** leejo left
[07:58] *** bjz joined
[08:04] *** nadim joined
[08:04] *** jonas1 joined
[08:05] *** notostraca left
[08:05] *** Praise left
[08:05] *** RabidGravy joined
[08:17] *** bjz left
[08:18] *** mohae left
[08:18] *** notostraca joined
[08:23] *** notostraca is now known as TEttinger

[08:25] <Woodi> m: class Sth { method add( $i ) { self.c = $i }; }; my $s = Sth.new; $s.add( 1 );

[08:25] <camelia> rakudo-moar 5f2e96: OUTPUT«Method 'c' not found for invocant of class 'Sth'␤  in method add at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[08:27] <Woodi> that is bad; field $c was used in method definition but not detected until runtime...

[08:27] <Pierre_> m: class Sth { method add( $i ) { $.c = $i }; }; my $s = Sth.new; $s.add( 1 );

[08:27] <camelia> rakudo-moar 5f2e96: OUTPUT«Method 'c' not found for invocant of class 'Sth'␤  in method add at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[08:28] <Pierre_> you should call attribute with $. and keep self for method

[08:28] <Pierre_> m: class Sth { has $.c; method add( $i ) { $.c = $i }; }; my $s = Sth.new; $s.add( 1 );

[08:28] <camelia> rakudo-moar 5f2e96: OUTPUT«Cannot modify an immutable Any␤  in method add at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[08:28] <Pierre_> m: class Sth { has $.c is rw; method add( $i ) { $.c = $i }; }; my $s = Sth.new; $s.add( 1 );

[08:28] <camelia> rakudo-moar 5f2e96: ( no output )

[08:28] <Pierre_> m: class Sth { has $.c; method add( $i ) { $!c = $i }; }; my $s = Sth.new; $s.add( 1 );

[08:28] <camelia> rakudo-moar 5f2e96: ( no output )

[08:28] <Woodi> Pierre_: checking. just lerning P6OO anyway...

[08:29] <Pierre_> with self.c you could create the method in runtime

[08:29] <Pierre_> so it can't tell for sure that it will not be there at runtime

[08:30] <Woodi> Pierre_: ok, then I have problem with metods...

[08:30] <Pierre_> waht problem?

[08:30] <moritz> you create methods at runtime through the MOP

[08:30] <moritz> *can

[08:30] <Woodi> Pierre_: ETOOMUCHDTNAMICITY...

[08:30] <moritz> or by mixing in roles into invidividual objects

[08:31] *** bjz joined
[08:31] <Woodi> moritz: problem is like with mispelled varible names - bad method can be resolved

[08:32] *** mcmillhj joined
[08:34] <masak> good antenoon, #perl6

[08:35] <Woodi> hi masak :)

[08:37] *** mcmillhj left
[08:37] <brrt> hi masak

[08:37] <Pierre_> m: class Sth { method add( $i ) { self.c }; submethod BUILD() { self.^add_method('c', method (Mu:D:) { say 'dynamically created';}) }; }; my $s = Sth.new;  $s.add( 1 );

[08:37] <camelia> rakudo-moar 5f2e96: OUTPUT«dynamically created␤»

[08:38] <Pierre_> exemple of dynamically created method

[08:38] <Pierre_> now if you go crazy and make your method return-rw

[08:38] <Pierre_> you can "affect" somethign to your method

[08:39] <Pierre_> and call self.c = "something" on your method

[08:43] *** Actualeyes left
[08:44] *** mcmillhj joined
[08:49] *** mcmillhj left
[08:50] *** robertle joined
[08:51] *** bjz left
[08:52] *** bjz joined
[08:53] *** leejo joined
[08:54] <Woodi> Pierre_: I was talking just about not detecting things at "compile" time, whateverTime. problems like that ar detected too late, at runtime. for me it's worse then not making, at least, warning about undeclared variable

[08:55] <moritz> note that you should .^compose the class again after .^add_method

[08:55] <moritz> if you don't, you might get inconsistent behavior through the method cache

[08:55] <rightfold> Perl 6 is great

[08:55] *** rindolf joined
[08:56] *** rudolfochrist joined
[08:56] <DrForr> rightfold: No arguments there :)

[08:57] *** Actualeyes joined
[08:58] *** mcmillhj joined
[08:58] <Pierre_> Woodi: i understand you point, the thing here is you are calling a method, and that can be added at runtime, so if it was not compiling due to undeclared method

[08:59] *** bjz_ joined
[08:59] *** bjz left
[08:59] <Pierre_> you would kill the functionality of being able to dynamically add method ;)

[08:59] <Pierre_> if you use a variaable, and not a method call, it is detected at compile time

[09:00] <jnthn> The point of objects is late binding.

[09:00] *** wamba left
[09:01] <Woodi> Pierre_: I know it's about functional niceness, etc.  but didn't have idea it's so 0/1...

[09:02] <Woodi> but there was some notation of telling that class is finished, right ?

[09:02] <jnthn> If you want early binding, use subs. :-)

[09:02] <Woodi> jnthn: in classes and OO ?

[09:03] <jnthn> If you don't want late binding, why do classes and OO? :)

[09:03] <rightfold> use hashes of subs

[09:03] <Woodi> jnthn: you obviously trolling me here :)

[09:03] *** mcmillhj left
[09:05] <rightfold> TIMTOWTDI. One way is to not use classes if you need no state. And if you do need state, use closures!

[09:07] <moritz> you can use (multi) subs; their names at least are resolved at compile time

[09:08] <Woodi> moritz: o, this is good to know

[09:09] <brrt> Woodi: i don't think jnthn is often trolling

[09:09] <Pierre_> also, a more "normal use case"

[09:09] <Pierre_> m: role r { method c() { say "from role" } }; class Sth { method add( $i ) { self.c } }; my $s = Sth.new but r;  $s.add( 1 );

[09:09] <camelia> rakudo-moar 5f2e96: OUTPUT«from role␤»

[09:09] <Woodi> pasting:   use oo :closed :final;  from S12 into script don't work :)

[09:11] <brrt> and, i'm not sure i understand what you are trying to achieve

[09:12] *** darutoko left
[09:12] <Woodi> brrt: problem evolved into: method rot1( "Buu" );  is not detected during compilation

[09:13] <jnthn> Woodi: Not at all. That things interpreted in the current language (subs, multi subs, variables, operators) can be compile-time checked, and that things in an object's language (that is, method calls) are late bound, is one of the basic design principles of Perl 6.

[09:14] *** cibs left
[09:15] <Woodi> jnthn: when someone write his small script he know that he don't use MOPs and evals and just want syntax checking...

[09:15] *** cibs joined
[09:16] <jnthn> This isn't anything to do with syntax, though.

[09:16] <jnthn> If you think it is, you don't undertsand the problem well enough for us to discuss this.

[09:16] <jnthn> Um, that was a tad mean...I slept like crap. :P

[09:16] <Woodi> jnthn: obviously I just looking for some new way around functional inventions :)

[09:17] <jnthn> But really...the original idea of OO was late binding.

[09:17] <jnthn> Or at least, one of them. 

[09:17] <Woodi> jnthn: possibly. will try to check my thinking, don't worry :)

[09:18] <jnthn> http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en is a useful read :)

[09:18] <rightfold> WTB "use Bla:from<PureScript>;"

[09:18] <jnthn> (By Alan Kay, who coined the term OO)

[09:18] <rightfold> PureScript compiler will have a feature to dump JSON of its IR soon so that will be super rad

[09:19] <brrt> Woodi: my understanding is that you have a class that does or does not do some method, and you have a usage of an object of that class, and you'd like the compiler to check if that usage is correct

[09:20] <brrt> and what jnthn is saying is that the perl6 compiler can't do that, because it can't statically determine whether you are using the object correctly, because that is up to the object, and not to the compiler

[09:20] <Woodi> let's just be sure that ideal OO will *not* be security nightmare...

[09:20] <brrt> whereas with subroutines, the compiler /would/ be able to tell you, because subroutines are resolved by the compiler, and hence the compiler can check

[09:21] <brrt> i don't think security is the issue at hand here

[09:21] <Woodi> brrt: see aobve: obviously I just looking for some new way around functional inventions :)

[09:21] <brrt> Woodi: i can't parse 'functional inventions'

[09:21] <brrt> i don't know what you mean by that

[09:21] <moritz> .oO( dysfunctional inventions )

[09:22] <robertle> I think I understand the differend of "push @list, 2, 3;" vs "push @list, (4, 5);", but can I do the same with splice? I can do "splice(@list, 1, 1, (0, 1));" seems to do the same as "splice(@list, 1, 2, 0, 1);"...

[09:22] <Woodi> for me, somehow late-bound is close to functional additions...

[09:22] <huf> but there's no difference

[09:22] <huf> oh damn wrong channel again.

[09:23] <huf> i need to paint that 6 some color.

[09:23] *** cgfbee left
[09:24] <brrt> Woodi: I'm sorry, I really can't make sense of your terminology :-)

[09:24] <brrt> with functional additions, do you mean runtime-created functions?

[09:24] *** bpmedley left
[09:25] <Woodi> brrt: nvm, maybe my talking is not precise but I know I'm right :)

[09:25] *** bpmedley joined
[09:26] <robertle> I guess it's the slurpy that makes this different, but how can I pass an array as-is,non-flattened through a slurpy arg?

[09:27] <jnthn> try $(0, 1)

[09:27] <jnthn> (The $ itemizes it; it's short for (0, 1).item

[09:27] <jnthn> )

[09:28] <Pierre_> here is one idea so, write all your method as subroutine, and use the method call syntax

[09:28] <Pierre_> m: class c { my sub test( $o ) { say $o }; method m() { self.&test } }; my $c = c.new; c.m

[09:28] <camelia> rakudo-moar 5f2e96: OUTPUT«(c)␤»

[09:28] <Pierre_> :D

[09:29] <Pierre_> here, if you have a typo, you will see it

[09:29] <Pierre_> m: class c { my sub test( $o ) { say $o }; method m() { self.&test2 } }

[09:29] <camelia> rakudo-moar 5f2e96: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    test2 used at line 1␤␤»

[09:29] <robertle> eh, I can do "splice(@list, 0, 0, ((0, 1),))" but not "splice(@list, 0, 0, ((0, 1)))"

[09:30] <Woodi> Pierre_: how you like this do not show error ? :

[09:30] <Woodi> m: my $a1; my $3; $a2 = 1;

[09:30] <camelia> rakudo-moar 5f2e96: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Cannot declare a numeric variable␤at <tmp>:1␤------> 3my $a1; my $37⏏5; $a2 = 1;␤»

[09:31] <Pierre_> i see an error there :)

[09:31] <Woodi> problem is in same category, for user. and I know about late binding and all reasons! but it is still a problem

[09:31] *** telex left
[09:32] <Pierre_> i mean, you can't issue error on compile time about stuff that will be added on runtime

[09:32] <Woodi> Pierre_: I know that.

[09:32] *** telex joined
[09:32] <Pierre_> and by the way, my previous exemple was purely troling

[09:34] *** cgfbee joined
[09:34] <Woodi> Pierre_: hackin, trolling, jurnalisting, investigating, all is for humans :)

[09:36] *** darutoko joined
[09:36] <robertle> m: my @list = ($(2, 3)); splice(@list, 0, 0, $(0, 1)); say @list;

[09:36] <camelia> rakudo-moar 5f2e96: OUTPUT«[0 1 (2 3)]␤»

[09:37] <robertle> jnthn: doesn't appear to do it for splice...

[09:41] *** luiz_lha__ joined
[09:42] <Woodi> btw. Smalltalk was GUI and runtime so maybe we just can't copy pasting ideas from there...

[09:44] *** luiz_lha_ left
[09:49] *** literal_ is now known as literal

[09:51] *** cyphase left
[09:56] *** cyphase joined
[09:57] *** rudolfochrist left
[10:01] *** Pierre_ left
[10:04] *** labster left
[10:06] *** Upasaka joined
[10:07] *** infina left
[10:07] *** infina joined
[10:17] *** eliasr joined
[10:18] *** bjz_ left
[10:20] * [Coke] waves

[10:20] *** TEttinger left
[10:21] * DrForr particles.

[10:21] * timotimo plasmas

[10:22] * [Coke] 's coworker bought him a coffee, oh thank goodness.

[10:22] *** bjz joined
[10:22] * DrForr condenses.

[10:23] * timotimo codenses

[10:33] *** CIAvash left
[10:37] *** rudolfochrist joined
[10:40] * brrt crystalizes and proceeds with sublimation

[10:41] * moritz simply explodes

[10:46] <brrt> but, but, but

[10:47] <brrt> there are any number of processes that can cause an explosion

[10:47] *** rindolf left
[10:48] *** wamba joined
[10:48] <moritz> brrt: spontaneous combustion caused by overheating XePtF6, igniting my body fat into explosion. Enough detail? :-)

[10:49] <brrt> well, i'm sceptical of this substance you've mentioned

[10:49] <brrt> :-P

[10:49] <moritz> I don't know if it actually self-ignites, but it does sound unstable enough

[10:49] <brrt> also, you know as well as i do that body fat is never realistically going to be part of an explosion

[10:49] <moritz> https://en.wikipedia.org/wiki/Xenon_hexafluoroplatinate

[10:50] <brrt> oh, Pt is platinum, not plutionium

[10:50] <brrt> bit of a difference

[10:50] <moritz> I do. So what :-)

[10:50] <brrt> nothing… I'm just ehm… 

[10:50] * brrt recedes back into the dark

[10:51] <moritz> another fun igniter (and where I know it works) is this guy here: https://en.wikipedia.org/wiki/Lead%28II%29_azide

[10:52] *** Alikzus joined
[10:52] <brrt> oh, that is evil

[10:52] <moritz> it is :-)

[10:53] *** rudolfochrist left
[11:03] <masak> reminds me of a blog I found once called something like "chemicals I never want to deal with"

[11:06] <ilmari> http://blogs.sciencemag.org/pipeline/archives/category/things-i-wont-work-with

[11:06] <masak> that's the one. ilmari++

[11:10] <timotimo> i think i've heard of that article

[11:10] <timotimo> maybe even read it

[11:15] <DrForr> FOOF is more fun :)

[11:16] <timotimo> the name is the sound it makes when it "activates" :)

[11:16] <DrForr> Yep. One of those chemicals that tend to be hypergolic with brick, ice, steel, and chemical engineers.

[11:18] *** Roamer` left
[11:19] <ilmari> ClF₃ is even more fun

[11:19] <ilmari> m: say ₃₂

[11:19] <camelia> rakudo-moar cc75c8: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Bogus postfix␤at <tmp>:1␤------> 3say ₃7⏏5₂␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier␤        stat…»

[11:20] <ilmari> m: say 3₂

[11:20] <camelia> rakudo-moar cc75c8: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Bogus postfix␤at <tmp>:1␤------> 3say 37⏏5₂␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier␤        statem…»

[11:20] *** CIAvash joined
[11:21] <ilmari> DrForr: ClF₃ is the thing that Ignition! describes as «hypergolic with such things as cloth, wood, and test engineers, not to mention asbestos, sand, and water-with which it reacts explosively»

[11:21] <ilmari> http://blogs.sciencemag.org/pipeline/archives/2008/02/26/sand_wont_save_you_this_time

[11:22] *** wamba left
[11:22] <DrForr> I know, I've read /Ignition!/ :)

[11:33] <robertle> I want to create unique IDs for things in a concurrent setting. I can of course just use an number that I increment and a lock to protect it from concurrent access, but is that the right way? seems heavy...

[11:35] <ilmari> yo could give each thread a dedicated ID range

[11:35] <ilmari> *you

[11:35] *** itaipu joined
[11:37] *** luiz_lha__ left
[11:37] *** CIAvash left
[11:38] <robertle> ok, there are a couple of similar wyas to reduce the contention on the locks, but I was more wondering whether there is something atomic built-in, or a clever high-level trick like some lazy-promise-supply-thing or so

[11:39] *** larion joined
[11:42] <moritz> robertle: it's better have a counter for each thread, and concatenate with the thread ID

[11:51] <masak> robertle: somehow I'm put in mind of Lambert timestamps. but that may be too heavy a solution here, in case moritz' suggestion is enough.

[11:51] <masak> er, Lamport timestamps, of course

[11:53] <robertle> ok, thanks. this is a module used by other code/trheads who should not need to know about the internals, so I would not want to burden them with the ID creation. is there a way to create a per-thread variable? TLS? all of this seems very low-level...

[11:55] *** iH2O joined
[11:56] *** strok017 joined
[11:56] *** rgrinberg joined
[11:57] <strok017> #android

[11:59] *** strok017 left
[12:06] *** wamba joined
[12:11] *** woolfy left
[12:11] <jnthn> robertle: https://github.com/jnthn/p6-concurrent-iterator

[12:12] *** woolfy joined
[12:13] *** itaipu left
[12:15] *** itaipu joined
[12:16] *** iH2O left
[12:17] <lizmat> jnthn: feels to me that should be standard issue ?

[12:18] <jnthn> Maybe some day, or maybe we want something more general.

[12:18] <jnthn> No need to hurry to put stuff in the CORE kitchen sink

[12:19] <lizmat> ok, but somehow I missed the existence of this

[12:19] <brrt> oh, lizmat++, is was impressed by you giving the APW talk in german

[12:20] <lizmat> brrt: yeah, most of the people there were not native english speakers, and since this was about lowering thresholds  :-)

[12:20] <lizmat> and thanks  :-)

[12:24] *** CIAvash joined
[12:28] *** woolfy left
[12:29] *** Pierre_ joined
[12:32] *** wamba left
[12:39] *** user9 left
[12:39] *** fritz_ joined
[12:40] *** user9 joined
[12:41] <fritz_> Hi, we have an inquiry for a training course on Perl6 emphasizing differences between Perl5 and Perl6 (for Perl5 developers). I assume they are looking for a course in German. Who could do something like that?

[12:46] *** pmurias joined
[12:46] <pmurias> jnthn: will localref be used by rakudo in the future?

[12:46] <jnthn> pmurias: Yes, once we get more aggressive at lexical -> local lowering. :)

[12:47] <jnthn> (In fact, it's there to enable it.)

[12:48] <jnthn> (Optimization note: it's a single-procedure analysis to see if a given local might be ref'd.)

[12:49] <jnthn> (So if you need to code-gen them in some different and maybe less optimal way, it's not so hard to do that.)

[12:51] *** sufrostico joined
[12:57] <lizmat> fritz_: I could be persuaded to give such a course

[12:58] <lizmat> I guess FROGGS or moritz or nine could do so as well, if not better, though  :-)

[12:59] <fritz_> lizamt: Could you give it in German (I am not 100% sure, if this is a requirement)? The inquiry is from http://www.helmholtz-berlin.de/, if I have at least one potential volunteer I'd ask them if I should forward their eMail.

[13:00] <brrt> lizmat++ can, in fact :-)

[13:00] <fritz_> I thought so, but wasn't sure.

[13:00] <lizmat> https://www.youtube.com/watch?v=1P0L0sX-CLY

[13:01] <lizmat> :-)

[13:01] * brrt shouldnt speak for others, but still suggest reading it as a vote of confidence

[13:01] *** jkramer joined
[13:01] <jkramer> Ahoy

[13:01] <lizmat> fritz_: to give you an idea  :-)

[13:02] <jkramer> I recently installed rakudo (view rakudobrew) on a new system and now it seems that modules are not recompiled when I run a script but some stuff from .precomp is used.

[13:02] <fritz_> lizmat: I guess I should have gone there after all ... ;-) ...

[13:03] <jkramer> I guess it's smart for production but kinda annoying during development when I have to delete the .precomp directory whenever I change something.

[13:03] <jkramer> Is there a way to turn that off?

[13:03] <moritz> fritz_: feel free to shoot me an email (moritz.lenz@gmail.com) with details

[13:03] <fritz_> I will ask if I can forward their mail.

[13:03] <brrt> fritz_: hemholtz centre is a research institute, correct?

[13:03] <brrt> cool

[13:04] <fritz_> Indeed. And being in Berlin I'd be very interested in going there, but just think it wouldn't be fair there being much more competent people around for giving such a course.

[13:05] <pmurias> jkramer: by change something you mean change the modules source code, or moarvm internals?

[13:05] <jkramer> pmurias: The modules source code

[13:05] *** cdg joined
[13:05] *** cdg left
[13:06] *** cdg joined
[13:07] *** MetaZoffix joined
[13:07] <nine> jkramer: if you need to delete a .precomp directory, that's a bug. What exact rakudo version are you using?

[13:07] <MetaZoffix> jkramer: you're not meant to delete or turn anything off. It'll recompile on change

[13:08] *** mcmillhj joined
[13:09] <MetaZoffix> jkramer: there were a couple of recent commits that had a bug with that, but everything is fixed in HEAD. Ensure your version is at least 2016.08.1-182 or above

[13:10] <jkramer> "This is Rakudo version 2016.08.1-142-g8a66833 built on MoarVM version 2016.08-43-g3d04391"

[13:11] <MetaZoffix> jkramer: yeah, try upgrading.

[13:11] <jkramer> :( That takes forever on that machine. Oh well, thanks :)

[13:11] <MetaZoffix> You might need to delete .precomp once after upgrade, just to ensure the buggy precomp is gone.

[13:12] <RabidGravy> "Is Term::ReadKey thread-safe", "er unlikely, how long have you got?"

[13:12] <MetaZoffix> And after that it'll update automatically on change

[13:13] <nine> MetaZoffix: note that I actually don't know why there seem to be issues on the first run after upgrading to the fixed version. It doesn't make sense as precomp files are bound to the very specific compiler build.

[13:13] *** Sgeo_ left
[13:13] *** rindolf joined
[13:13] <Ulti> jkramer: if you are in production I would use rakudobrew with an actual release version rather than capturing a random HEAD state mid development it's usually quite stable but things like this are much more likely to happen outside of a tagged release

[13:14] <Ulti> rakudobrew defaults to the very latest commit

[13:14] <MetaZoffix> nine: ah. Well, I was just guessing. Didn't want jkramer to think the bug was still there if they upgrade but still don't see changes in the precompiled modules.

[13:16] *** Guest16587 is now known as Possum

[13:19] *** skids joined
[13:29] <sufrostico> sslo

[13:31] *** optikalmouse joined
[13:32] *** brrt left
[13:33] <optikalmouse> cool my article outline was accepted, just a simple article on using perl6 to read/write/parse json :D

[13:34] <moritz> optikalmouse++

[13:35] <moritz> optikalmouse: where did you submit it?

[13:35] <optikalmouse> moritz: you wrote JSON::Tiny right?

[13:35] <moritz> optikalmouse: yes

[13:35] <optikalmouse> moritz: the site is codementor.io, they're accepting some articles and they're a platform for online tutoring

[13:40] *** itaipu left
[13:40] *** itaipu joined
[13:46] *** user9 left
[13:49] *** jonas1 left
[13:52] *** itaipu left
[13:55] *** canopus_ is now known as canopus

[13:57] *** user9 joined
[14:04] *** dLeCamarae joined
[14:09] *** sunnavy left
[14:10] *** sunnavy joined
[14:15] *** Sgeo_ joined
[14:18] *** robertle left
[14:21] *** RabidGravy left
[14:33] *** itaipu joined
[14:35] *** khw joined
[14:36] *** RabidGravy joined
[14:39] *** mohae joined
[14:42] *** autarch left
[14:48] <MetaZoffix> New blog post: "Perl 6 Core Hacking: Wrong Address; Return To Sender": http://perl6.party/post/Perl-6-Core-Hacking-Wrong-Address-Return-To-Sender

[14:49] *** leejo left
[14:52] *** g4 left
[14:52] *** woolfy joined
[14:55] *** sufrostico left
[14:55] *** MetaZoffix left
[14:57] <jkramer> m: class Foo { has Callable $.fn; method run { $.fn(1, 2); } }; Foo.new(fn => -> $x, $y { say $x + $y }).run;

[14:57] <camelia> rakudo-moar 43b4f3: OUTPUT«Too many positionals passed; expected 1 argument but got 3␤  in method run at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[14:57] <jkramer> Any idea what's wrong with this?

[15:00] <[Coke]> m: m: class Foo { has Callable $.fn; method run { $!.fn(1, 2); } }; Foo.new(fn => -> $x, $y { say $x + $y }).run;

[15:00] *** dLeCamarae left
[15:00] <camelia> rakudo-moar 43b4f3: ( no output )

[15:00] <[Coke]> m: m: class Foo { has Callable $.fn; method run { $!.fn(1, 2); } }; Foo.new(fn => -> $x, $y { say $x + $y }).run.say;

[15:00] <camelia> rakudo-moar 43b4f3: OUTPUT«Nil␤»

[15:00] <[Coke]> m: m: class Foo { has Callable $.fn; method run { $!.fn(1, 2); } }; Foo.new(fn => -> $x, $y { say $x + $y }).run;

[15:00] <camelia> rakudo-moar 43b4f3: ( no output )

[15:00] <[Coke]> that outputs 3 here.

[15:00] *** leejo joined
[15:00] <[Coke]> m: class Foo { has Callable $.fn; method run { $!.fn(1, 2); } }; Foo.new(fn => -> $x, $y { say $x + $y }).run;

[15:00] <camelia> rakudo-moar 43b4f3: ( no output )

[15:01] <[Coke]>  m: class Foo { has Callable $.fn; method run { $!fn(1, 2); } }; Foo.new(fn => -> $x, $y { say $x + $y }).run;

[15:01] <camelia> rakudo-moar 43b4f3: OUTPUT«3␤»

[15:01] <[Coke]> (whoops, had extra . in my cut and paste)

[15:01] <[Coke]> you need to directly call the private thing, not call through the accessor that was created to get at it.

[15:01] <jkramer> Ah, ok

[15:01] <jkramer> Thanks!

[15:07] *** leejo left
[15:14] *** CIAvash left
[15:23] *** Pierre_ left
[15:25] *** itaipu left
[15:26] *** itaipu joined
[15:26] *** MetaZoffix joined
[15:34] *** pierrot left
[15:34] *** robertle joined
[15:35] *** CIAvash joined
[15:36] *** domidumont left
[15:40] <Unavowed_> m: class Foo { has Callable $.fn; method run { ($.fn)(1, 2); } }; Foo.new(fn => -> $x, $y { say $x + $y }).run.say;

[15:40] <camelia> rakudo-moar 43b4f3: OUTPUT«3␤True␤»

[15:40] <Unavowed_> wrapping the accessor call in parentheses also works

[15:43] *** itaipu left
[15:43] *** mcmillhj left
[15:44] <MetaZoffix> m: class Foo { has Callable $.fn; method run { $.fn.(1, 2); } }; Foo.new(fn => -> $x, $y { say $x + $y }).run.say;

[15:44] <camelia> rakudo-moar 43b4f3: OUTPUT«3␤True␤»

[15:44] *** itaipu joined
[15:45] *** pierrot joined
[15:46] *** cyphase left
[15:46] *** cdg left
[15:47] *** mcmillhj joined
[15:48] *** optikalmouse left
[15:48] <vcv> is $?SCOPE not yet implemented? or is there something special about it?

[15:50] <jnthn> Where did you find $?SCOPE mentioned?

[15:50] <vcv> https://docs.perl6.org/language/variables#index-entry-%24%3FSCOPE

[15:50] <jnthn> o.O

[15:51] <jnthn> I don't know what it'd even return if it was implemented :)

[15:51] *** pmurias left
[15:51] *** cyphase joined
[15:51] <vcv> me neither, which is why I wanted to try it :)

[15:53] *** MetaZoffix left
[15:54] *** matiaslina joined
[15:59] *** domidumont joined
[16:00] *** jmark joined
[16:01] <TimToady> what purpose would it serve that MY:: doesn't?

[16:03] * jnthn can't think of any

[16:03] <jnthn> Or that $?BLOCK doesn't alternatively serve

[16:05] <nine> .oO(ICBTSMWTDI)

[16:10] <dalek> doc: cd879ef | (Jan-Olof Hendig)++ | doc/Language/variables.pod6:

[16:10] <dalek> doc: Remove references to bogus SCOPE compile time var

[16:10] <dalek> doc: review: https://github.com/perl6/doc/commit/cd879effe4

[16:11] *** poohman joined
[16:11] *** AlexDaniel joined
[16:12] <poohman> Hello all, have a question in Grammars again

[16:12] <b2gills> m: class Foo { has &.fn; method fn (|c){ &!fn.(|c) } }; Foo.new(fn => -> $x, $y { say $x + $y }).fn( 1, 2 );

[16:12] <camelia> rakudo-moar 43b4f3: OUTPUT«3␤»

[16:13] *** wamba joined
[16:13] *** CIAvash left
[16:13] <b2gills> poohman: Don't keep us waiting

[16:13] <Hotkeys> When perl 7 eventually gets made can we get rid of sigils :p

[16:14] <poohman> sorry

[16:14] <b2gills> m: class Foo { has &.fn; method fn (|c){ &!fn.(self,|c) } }; Foo.new(fn => -> \self, $x, $y { say self.^name, ' returns:' say $x + $y }).fn( 1, 2 );

[16:14] <camelia> rakudo-moar 43b4f3: OUTPUT«5===SORRY!5===␤'self' used where no object is available␤at <tmp>:1␤------> 3}; Foo.new(fn => -> \self, $x, $y { say 7⏏5self.^name, ' returns:' say $x + $y }).f␤Two terms in a row␤at <tmp>:1␤------> 3lf, $x, $y { say self.^name, ' ret…»

[16:14] <konobi> Hotkeys: can do that in perl6 if you want

[16:15] <vcv> m: my \nosigils = "Hello"; say nosigils;

[16:15] <camelia> rakudo-moar 43b4f3: OUTPUT«Hello␤»

[16:15] <poohman> it says in the documentation that the match trees we get after parsing are immutable

[16:15] <poohman> is there any way we can modify them in the action class??

[16:16] <b2gills> You don't modify them, you return something else

[16:16] <Hotkeys> I realize you *can* do it

[16:16] <Hotkeys> Using \

[16:17] <Hotkeys> But it isn't entirely the sane

[16:17] <Hotkeys> same

[16:17] <b2gills> Hotkeys: I wasn't even responding to your message, I was thinking out loud about something entirely different

[16:18] <Hotkeys> Not you

[16:18] <Hotkeys> @vcv and konobi

[16:18] <Hotkeys> is what I meant

[16:25] <b2gills> m: say grammar :: { token TOP { [<a>|<b>|<c>]+ }; token a {a}; token b {b}; token c {c} }.parse( 'abc', :actions( class :: { method TOP ($/){make $/.values».made}; method FALLBACK ($,$/){make $/.ord } } )).ast

[16:25] <camelia> rakudo-moar 43b4f3: OUTPUT«(97 99 98)␤»

[16:27] *** awwaiid left
[16:27] *** awwaiid joined
[16:29] *** captain-adequate left
[16:29] *** AndyBotwin left
[16:40] *** pdcawley left
[16:41] *** Ven_ joined
[16:46] <poohman> thanks b2gills, still digesting ur reply

[16:46] <poohman> will experiment a bit and get back

[16:47] <mst> can I figure out which methods are available as subroutines just by iterating CORE ?

[16:47] <mst> https://docs.perl6.org/routine.html is not amazingly readable

[16:47] <mst> (like I want to know what else can work as a sub along with 'map', 'all', etc.)

[16:52] *** mcsnolte joined
[16:53] <b2gills> m: say grep {&CORE::($_) // False}, Any.^methods».name

[16:53] <camelia> rakudo-moar 43b4f3: OUTPUT«(cache list flat hash elems end keys kv values pairs pick roll classify categorize reverse combinations permutations join nodemap duckmap deepmap push append unshift prepend all any one none sum map grep first min max minmax sort reduce produce unique repe…»

[16:53] *** sftp left
[16:55] <b2gills> Note that for some of them the sub form does something different from the method form, like permutations

[16:56] <b2gills> m: #`(You can't iterate CORE because CORE::IterationEnd exists) .say for 1,2,CORE::IterationEnd,3

[16:56] <camelia> rakudo-moar 43b4f3: OUTPUT«1␤2␤»

[17:01] *** robertle left
[17:05] *** sftp joined
[17:08] *** robertle joined
[17:11] *** firstdayonthejob joined
[17:18] *** sufrostico joined
[17:20] *** Ven_ left
[17:36] *** zakharyas left
[17:40] *** djbkd left
[17:48] <tbrowder> MetaZoffix: ref latest perl6 party post: I continue to be amazed at yr prolific and high-quality contributions to p6!  Thank you!

[17:55] *** Ven_ joined
[18:00] *** itaipu left
[18:00] *** spider-mario joined
[18:02] *** itaipu joined
[18:03] *** itaipu left
[18:04] *** itaipu joined
[18:07] *** mcmillhj left
[18:08] *** Ven_ left
[18:09] *** Ven_ joined
[18:10] *** cdg joined
[18:14] *** mcmillhj joined
[18:19] *** mcmillhj left
[18:21] *** awwaiid left
[18:23] *** itaipu left
[18:24] *** matiaslina left
[18:24] *** itaipu joined
[18:24] *** girafe joined
[18:24] *** FROGGS joined
[18:25] *** harmil_wk joined
[18:27] *** mcmillhj joined
[18:27] *** yqt joined
[18:29] *** poohman left
[18:29] *** poohman joined
[18:30] *** Actualeyes left
[18:31] *** mcmillhj left
[18:35] *** Ven_ left
[18:37] *** poohman left
[18:38] *** Actualeyes joined
[18:38] *** Ven_ joined
[18:42] *** darutoko left
[18:43] *** melezhik_ joined
[18:45] *** poohman joined
[18:50] *** mcmillhj joined
[18:52] *** itaipu left
[18:53] *** itaipu joined
[18:53] <melezhik_> HI all!

[18:54] <melezhik_> how I can create a regexp from string? given a string $foo = '\d+' I want to get a regexp /\d/

[18:54] <arnsholt> Iiiiiiii, don't remember, sorry

[18:55] <arnsholt> There's way, I'm just drawing a complete blank ATM =)

[18:55] *** dogbert17 left
[18:55] *** FROGGS left
[18:57] <arnsholt> <{$regex}> I think, from skimming S05

[18:59] *** Praise joined
[18:59] *** Praise left
[18:59] *** Praise joined
[19:01] *** Ven_ left
[19:02] *** wamba left
[19:03] *** dogbert17 joined
[19:04] *** Actualeyes left
[19:06] *** chAptra joined
[19:06] <chAptra> m: $foo = '\d+'; say "foo 42" ~~ /<$foo>/

[19:06] <camelia> rakudo-moar 0cf712: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '$foo' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5$foo = '\d+'; say "foo 42" ~~ /<$foo>/␤»

[19:06] <chAptra> m: my $foo = '\d+'; say "foo 42" ~~ /<$foo>/

[19:06] <camelia> rakudo-moar 0cf712: OUTPUT«｢42｣␤»

[19:08] <chAptra> m: say "foo 42" ~~ /<{'\w**3 " "' ~ 4 ~ '\d'}>/

[19:08] <camelia> rakudo-moar 0cf712: OUTPUT«｢foo 42｣␤»

[19:17] *** itaipu left
[19:17] <chAptra> m: my $user-input = ｢<say>｣; say  "foo 42" ~~ /<$user-input>/

[19:17] <camelia> rakudo-moar 0cf712: OUTPUT«Cursor.new␤P6opaque: no such attribute '$!pos' in type Cursor when trying to get a value␤  in regex  at EVAL_0 line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:18] *** itaipu joined
[19:18] *** labster joined
[19:20] <melezhik_> chAptra: thanks, it works!

[19:20] *** leejo joined
[19:23] *** eliasr left
[19:23] <chAptra> m: my $user-input = ｢<nuke-it>｣; grammar { token TOP { <$user-input> }; token nuke-it { {say "pw0ned"}  }  }.parse: ''

[19:24] <camelia> rakudo-moar 0cf712: OUTPUT«pw0ned␤»

[19:24] *** canopus left
[19:25] *** Actualeyes joined
[19:27] *** pierrot left
[19:27] *** chAptra left
[19:30] *** canopus joined
[19:34] *** domidumont left
[19:36] *** itaipu left
[19:36] *** itaipu joined
[19:37] *** TEttinger joined
[19:40] *** pierrot joined
[19:41] <melezhik_> Another question on regexp captures. How to get all captured data list ?

[19:42] *** rindolf left
[19:43] <melezhik_> '91hello92hello' ~~ m:g'\d(\S)' and I want to have an array of ('hello', 'hello');

[19:43] <melezhik_> sorry I meant a '91hello92hello' ~~ m:g'\d+(\w+)'

[19:46] <jnthn> m: say ('91hello92hello' ~~ m:g'\d(\S)')>>[0]

[19:46] <camelia> rakudo-moar 0cf712: OUTPUT«(｢1｣ ｢2｣)␤»

[19:46] <jnthn> Oh, but you didn't capture hello :)

[19:47] *** spebern joined
[19:47] <jnthn> But something along those lines, anyway

[19:47] <jnthn> m: say ('91hello92hello' ~~ m:g'\d+(\D+)')>>[0]

[19:47] <camelia> rakudo-moar 0cf712: OUTPUT«(｢hello｣ ｢hello｣)␤»

[19:48] <melezhik_> well, I need to have an array of all captured data, meaning all inside  ()

[19:48] <melezhik_> how can I do this?

[19:49] <jnthn> Not sure I understand what you're trying to do. In your original example, hello wasn't captured...

[19:50] <melezhik_> ok forget about my previos example, it is probably not very good

[19:50] <melezhik_> all I need to get an access to all capured data

[19:50] <geekosaur> $/ has all captured data

[19:51] <melezhik_> by captured data I mean only chunks inside () 

[19:51] <geekosaur> (or the result from a smartmatch against a regex has it, if you grab that)

[19:51] <jnthn> Maybe .caps is what you want?

[19:51] <melezhik_> $/ give me all not only these chunks

[19:51] <moritz> so, is it a problem to have more information available?

[19:52] <melezhik_> yes, this is problem

[19:52] <jnthn> m: say ('abc' ~~ /(.)b(.)/).caps

[19:52] <camelia> rakudo-moar 0cf712: OUTPUT«(0 => ｢a｣ 1 => ｢c｣)␤»

[19:52] <melezhik_> I need only a captured data

[19:52] <melezhik_> not matched data

[19:52] <melezhik_> as it works in perl5

[19:52] <melezhik_> I will try caps

[19:53] <jnthn> Failing that, show how it'd be in Perl 5.

[19:54] <melezhik_> in perl5 it would be : my @foo = ('91hello92hello' ~ /\d+(\w+)/g);

[19:55] <melezhik_> say ('91hello92hello' ~~ m:g/\d+(\w+)/).caps

[19:56] <jnthn> m: my @foo = ('91hello92hello' ~~ m:g/\d+(\w+)/)>>[0]; say @foo

[19:56] <camelia> rakudo-moar 0cf712: OUTPUT«[｢hello92hello｣]␤»

[19:56] <melezhik_> gives - Method 'caps' not found for invocant of class 'List'

[19:56] <jnthn> \w+ matches the hello also in Perl 5 though, surely?

[19:56] <jnthn> uh

[19:56] <jnthn> matches the 92 I meant

[19:56] <arnsholt> It's a list of Match objects, each of which can be inspected to find what you want, presumably

[19:56] <jnthn> But yeah, that's why I did >>[0]

[19:56] <jnthn> Though easier might be

[19:56] <jnthn> m: my @foo = ('91hello92hello' ~~ m:g/\d+ <( \w+/); say @foo

[19:56] <camelia> rakudo-moar 0cf712: OUTPUT«[｢hello92hello｣]␤»

[19:57] <jnthn> m: my @foo = ('91hello92hello' ~~ m:g/\d+ <( \D+/); say @foo

[19:57] <camelia> rakudo-moar 0cf712: OUTPUT«[｢hello｣ ｢hello｣]␤»

[19:57] <arnsholt> melezhik_: If you print the match object, it'll print the whole string that matched

[19:57] <arnsholt> *But*, that's just the stringification. The object itself contains *more* information than you have available in Perl 5

[19:57] <melezhik_> my @foo =  ('91hello92hello' ~~ m:g/\d+(\w+)/)>>[0]; say @foo;

[19:58] <melezhik_> gives me a [｢hello92hello｣]

[19:58] <melezhik_> this is not what I need

[19:58] <jnthn> Yes, I said that. 92 is matched by \w

[19:58] <arnsholt> m: my @foo = ('91hello92hello' ~~ m:g/\d+(\w+)/); say @foo[0][0]; say @foo[1][0]

[19:58] <camelia> rakudo-moar 0cf712: OUTPUT«｢hello92hello｣␤(Any)␤»

[19:59] <melezhik_> ok, guys, again I need to get all captured, ( not matched !!! ) data, please give me a code example how to do this ...

[19:59] <arnsholt> Oh it matches wrong

[19:59] <arnsholt> m: my @foo = ('91hello92hello' ~~ m:g/\d+(\D+)/); say @foo[0][0]; say @foo[1][0]

[19:59] <camelia> rakudo-moar 0cf712: OUTPUT«｢hello｣␤｢hello｣␤»

[19:59] <arnsholt> There we go

[19:59] <jnthn> We are, but your example is confused. \w+ matches all the way to the end of the string.

[19:59] <arnsholt> @foo[0] is the match object for the first match (91hello), @foo[1] for the second match (92hello)

[19:59] <jnthn> Because digits are matched by it

[20:00] *** nadim left
[20:00] <jnthn> afk for a bit

[20:01] <melezhik_> my @foo = ('91hello92hello' ~~ m:g/\d+(\D+)/); say @foo[0][0]; say @foo[1][0] works, but look abit uncofmortable for me though ...

[20:02] <melezhik_> you may get any example, in perl5 I just had a calling regexps mathching in a list context and it works

[20:02] <mst> m: my @m = ('91hello92hello' ~~ m:g/\d+(\D+)/).map(*[0]); say @m.join(' ');

[20:02] <camelia> rakudo-moar 0cf712: OUTPUT«hello hello␤»

[20:02] <mst> melezhik_: seems pretty comfortable to me.

[20:02] <melezhik_> I wounder why I get an array of arrays?

[20:03] <mst> you get an array of match objects

[20:03] <arnsholt> The reason it's like this is that the Perl 6 regexes gives you *structured* matches

[20:03] <mst> then applying [0] to a match object gets the first positional capture

[20:03] <spebern> my @foo = '91hello92hello'.comb(/(\D+)/);

[20:03] <mst> hence .map(*[0])

[20:03] <melezhik_> I would like to get a captured data as one demensional array, that is it ... 

[20:03] <mst> melezhik_: which I already demonstrated.

[20:03] <arnsholt> Oh yeah, if you just want something dead simple like "everything that matches this pattern", you probably want comb

[20:04] <arnsholt> spebern++

[20:04] <mst> true

[20:04] <mst> but the .map is not difficult at all

[20:04] <melezhik_> mst: your way seems abit weird for such simple thing too 

[20:04] <mst> melezhik_: that's because you're using the 'complicated thing' API

[20:04] <mst> also, if you find .map weird, you're not enjoying perl6 properly yet ;)

[20:05] <melezhik_> mst: I am ok with map or what ever constuction when they are realy needed, 

[20:06] <mst> melezhik_: so use spebern's approach for simple cases, and mine for not-simple ones

[20:06] <ugexe> m: my @foo = ("91hello92hello" ~~ m:g/\d+(\D+)/)>>.values; say @foo

[20:06] <camelia> rakudo-moar 0cf712: OUTPUT«[(｢hello｣) (｢hello｣)]␤»

[20:07] <melezhik_> mst: I need to have a simple thing - an all captured data, that is it. I would not like to play with additional map constructions to get this , well **if it possiblle** , I would not like

[20:07] <melezhik_> cause for simple things I would expect a simple ways ...

[20:08] <melezhik_> so, probably .comb looks much better for me

[20:09] <mst> melezhik_: yes, which is what we keep telling you to use for this case.

[20:10] <mst> melezhik_: I'm not sure I understand what the problem is?

[20:10] <mst> .comb for simple cases, match objects when you need match objects

[20:11] * mst suspects .comb may be fairly close to the map I showed internally, but sugar exists for a reason :)

[20:11] <mst> melezhik_: also, remember, as soon as you're capturing two things in each match things immediately get more complicated

[20:12] <melezhik_> mst: not sure, but .comb way gives me this:

[20:12] <melezhik_> my @foo = '91hello92hello'.comb(/\d+(hello)/); say @foo;

[20:12] <mst> yes?

[20:12] <melezhik_> [91hello 92hello]

[20:12] <melezhik_> not what I need

[20:12] <mst> that's because you didn't do .comb the way we showed

[20:12] <melezhik_> I need ['hello','hello']

[20:12] <arnsholt> comb extracts everything that matches

[20:13] <mst> melezhik_: your \d+(\D+) example didn't need the \d+

[20:13] <arnsholt> Either use a look-around or use the Match objects

[20:13] <mst> melezhik_: if your real problem is something different

[20:13] <mst> melezhik_: please tell us what the real problem is :(

[20:13] <melezhik_> mst: I have already told you my real problem

[20:13] <mst> .comb(/(\D+)/) would solve the example you gave.

[20:13] <mst> if that doesn't work, then you haven't told us the real problem yet

[20:14] <mst> please tell us the real problem :(

[20:14] <mst> m: my @foo = '91hello92hello'.comb(/(\D+)/); say @foo;

[20:14] <camelia> rakudo-moar 0cf712: OUTPUT«[hello hello]␤»

[20:14] <mst> see, it works fine for the problem you gave us

[20:15] <melezhik_> mst: on my example .comb does not work please see my output

[20:15] <mst> melezhik_: you changed the code and made it less simple.

[20:15] <mst> melezhik_: that broke it.

[20:15] <El_Che> mst: count to 10 :)

[20:15] <arnsholt> Dude. You're clearly parsing something other than what you're showing

[20:15] * skids seeks shelter.

[20:15] <mst> melezhik_: your example can be fixed by deleting the \d+ :)

[20:15] <arnsholt> If you tell us what you're *actually* working on, we may even be able to help

[20:15] <melezhik_> mst: I don't want to delete \d

[20:15] <mst> right. we need a better example of the problem

[20:16] <melezhik_> I need to keep them in my regex

[20:16] <mst> melezhik_: well, that solves the problem you've shown us.

[20:16] <mst> melezhik_: if it doesn't solve your real problem

[20:16] <mst> melezhik_: please tell us what the real problem is

[20:16] <melezhik_> mst: I have already gave you an exmaple

[20:16] <mst> your example is fixable by deleting \d+

[20:16] <mst> that doesn't count

[20:16] <melezhik_> mst: please don't keep ask me this, as I already told you many many times

[20:16] <ugexe> arnsholt | Either use a look-around # this is what you want

[20:16] <perlpilot> m: my @foo = '91hello92hello'.comb(/<after \d+> \D+/);   # here's a random guess at what melezhik_ wants

[20:16] <camelia> rakudo-moar 0cf712: ( no output )

[20:17] <mst> melezhik_: if your data is really '91hello92hello' then we've solved your problem with .comb

[20:17] <perlpilot> m: my @foo = '91hello92hello'.comb(/<after \d+> \D+/); say @foo; # oops

[20:17] <camelia> rakudo-moar 0cf712: OUTPUT«[hello hello]␤»

[20:17] <mst> melezhik_: if it isn't, please show us the real data so we can help

[20:17] <mst> I don't understand why you don't want to let us help you :(

[20:18] <mst> c'mon, all we need is an example where the \d+ or whayever actually matters

[20:20] <melezhik_> guys, again 1) arnsholt way  my @foo = ('91hello92hello' ~~ m:g/\d+(\D+)/); say @foo[0][0]; say @foo[1][0] works fine but I found this abit complicated for such a simple thing as getting all captured data

[20:20] <mst> melezhik_: yes, but .comb(/\D+/) works fine for that.

[20:20] <melezhik_> when I asked alternatives I was told a .comb way which does not work

[20:20] <mst> melezhik_: it does work for that problem

[20:20] <mst> melezhik_: if you have a different problem, we need the different problem

[20:20] <spebern> what about perlpilot's way, still with comb

[20:21] *** ufobat left
[20:22] <melezhik_> mst: please refere to https://docs.perl6.org/language/regexes#Capturing to see what I mean by capturing, I need data inside ()

[20:22] <harmil_wk> Is there a graceful way to override things defined inside of Perl6/Actions.pm? I'd like to wrap wrap_option_n_code, but I can't seem to find it from my code...

[20:22] <mst> melezhik_: the problem you gave doesn't need that at all

[20:22] <mst> melezhik_: that's why I'm asking for a proper problem :(

[20:22] <melezhik_> mst: you misunderstand my problem

[20:22] <mst> melezhik_: well you won't tell me what it is.

[20:23] <mst> melezhik_: the problem you gave does not need capturing

[20:23] <mst> melezhik_: what problem do you have that actually needs capturing?

[20:23] <mst> melezhik_: we can help you solve it if you'll tell us :)

[20:23] <melezhik_> ok , I have a string $foo = '91hello92hello' and I have  a regexps m:g/\d(hello)/

[20:24] <melezhik_> I want to have a way to get all 'hello' captured chunks

[20:24] <melezhik_> mst: does it help?

[20:24] <mst> melezhik_: no

[20:24] <mst> melezhik_: because that problem is better solved by not using that regexp

[20:24] <mst> melezhik_: and instead using .comb(/(hello)/)

[20:24] <mst> melezhik_: that problem does not need captures :(

[20:24] <melezhik_>  (I thought I had already formulate this so many times, but if you want this again, then please take a look )

[20:24] <mst> harmil_wk: hrm, https://github.com/FROGGS/p6-Slang-Tuxic/blob/master/lib/Slang/Tuxic.pm shows overloading other bits

[20:25] <harmil_wk> melezhik_: Does .comb ensure that the prefix digit will be there?

[20:25] <harmil_wk> I think he wants that

[20:25] <perlpilot> melezhik_: Did you try .comb(/<after \d+> \D+/);  ?

[20:25] <melezhik_> mst: this is a input parameters of my task, I can't say what I need

[20:25] <perlpilot> harmil_wk: aye, that was my earlier guess (but he never said it or why)

[20:25] <mst> melezhik_: what?

[20:25] <mst> melezhik_: how can you program if you don't know what problem the program is solving?

[20:26] * mst doesn't understand :(

[20:26] <perlpilot> melezhik_: If you weren't writing Perl 6, I'd be thinking you're asking us to solve some homework for you.

[20:26] <melezhik_> mst: I stated my task, sorry, but I started to get bored of you repetious questions, if you can't help that's ok, I will find other ways

[20:26] <harmil_wk> mst: sorry, I don't understand. Doesn't a slang override parts of the grammar specifically? How do I override specific functions inside of Actions that way?

[20:28] <mst> melezhik_: I can help, if you'll show me a problem that needs captures

[20:28] <mst> why do you, specifically, have to use a regexp with a capture

[20:28] *** ZoffixMobile joined
[20:28] <mst> unlike the .comb + after approach?

[20:29] <mst> harmil_wk: I'm not sure, I was hoping that that might provide some hints where to poke around

[20:29] <arnsholt> harmil_wk: What do you need to override the actions for?

[20:29] <arnsholt> If not because of grammar-related shenanigans?

[20:29] <mst> harmil_wk: thinking that $MAIN-grammar in there might have an actions set that could be used or something

[20:29] <harmil_wk> Actions.pm defines wrap_option_n_code which is the wrapping function for the -n flag. I want to wrap the wrapper

[20:29] <melezhik_> mst: regulars expressions are kind input data , well you can't change them, they get comipled programmatically by given rules, you can't changes these rules, one of possible cases is that one my use () for regular expressions

[20:30] <harmil_wk> mst: Oh, fair point. I'll see if I can introspect that a bit.

[20:30] <melezhik_> this captures are not part of program code 

[20:30] <ZoffixMobile> melezhik, we have am article on comb: http://perl6.party/post/Perl6-Comb-It

[20:30] <melezhik_> does ot make a sence mst?

[20:30] *** cdg left
[20:31] <harmil_wk> arnsholt: Sorry, my comment about Actions.pm was directed at you. I should have said so.

[20:31] <mst> melezhik_: and you can't change the compiler to generate lookahead/lookbehind patterns instead of () ?

[20:31] <melezhik_> Zoffix, I will take a look at comb, thanks

[20:31] <arnsholt> harmil_wk: I figured it out =)

[20:31] <ZoffixMobile> melezhik, it doesn't deal with captures, but with matches. you can use <( after the digit to indicate you don't want it

[20:31] <arnsholt> So basically, you want to make another option like -n which is derived from it?

[20:31] <mst> melezhik_: also, what happens if you have more than one capture?

[20:32] <harmil_wk> arnsholt: frankly, it seems like a strange place to have that. I'm not clear on why it's not in main.nqp...

[20:32] <ZoffixMobile> melezhik, it's one of the areas where Perl 5 method is more concise, because in Perl6 you get a tree of Matcb objects from a regex match, rather than just a basic list of captures

[20:32] <melezhik_> mst: not sure if I understand you last question ...

[20:32] <mst> melezhik_: what if there is more than one () in the generated regex?

[20:33] <arnsholt> harmil_wk: Because it does an AST transformation, probably

[20:33] <melezhik_> ZoffixMobile: I expressed EXACTLY what I try to asy

[20:33] <melezhik_> try to say

[20:33] <mst> melezhik_: please stop shouting at people and keep answering the questions we're asking.

[20:33] <arnsholt> Nothing stopping you from putting it in main.nqp (as far as I can make out, anyways), but since all the rest of the AST stuff is in Actions it makes sense to have it there too

[20:34] <ZoffixMobile> melezhik_, yeah. The answer is you won't get it with a regex match. And

[20:34] <melezhik_> I just needed to know if perl6 has any ( perl5 like way ) concise way to get a captured data

[20:34] <ZoffixMobile> .comb is likely a better solution

[20:34] <melezhik_> that is it ))))))

[20:34] <mst> melezhik_: for the cases where you would use that in perl5, .comb is the answer usually

[20:34] <mst> melezhik_: but, again - do you ever have more than one () in the regenerated regex?

[20:34] <mst> melezhik_: please actually answer the question :(

[20:35] <melezhik_> mst: yes, it does, I may have more then one () in my regexps

[20:35] <mst> melezhik_: right, then ($str ~~ m/.../)>>.values

[20:35] <melezhik_> basicly because this is not me, but external users which DO write such an expressions

[20:35] <mst> melezhik_: as ugexe suggested

[20:35] <mst> melezhik_: will be the right answer.

[20:36] <mst> assuming you want ($first_capture_1, $first_capture_2, $second_capture_1, $second_capture_2)

[20:36] <mst> i.e. flattened

[20:36] <melezhik_> mst: I don't shout at anybody 

[20:36] <ZoffixMobile> Would it really? Will that get nested captures?

[20:37] <melezhik_> mst: please don't blame me at what I have never done 

[20:38] <melezhik_> ZoffixMobile: it was a typo, I meant "YOU expressed EXACTLY what I try to say"

[20:38] <ZoffixMobile> heh :)

[20:38] <mst> my @foo = flat ('91hello92hello' ~~ m:g/\d+(\D)(\D+)/)>>.values;

[20:38] <mst> seems to get a flattened array of captures

[20:39] <mst> or

[20:39] <ZoffixMobile> what if you nest them?

[20:39] <mst> >>.values.flat

[20:39] <ZoffixMobile> the captures

[20:39] <melezhik_> Mst, ZoffixMobile now I see the ways. thanks I will examine them detaily later

[20:39] <timotimo> you'll still get match objects, i guess?

[20:39] <mst> then I ... I don't even understand what's happening

[20:40] <ZoffixMobile> Yeah, my guess too. Maybe deepmap or whatever it is is needed

[20:40] <mst> I've only read the docs end to end once so far

[20:40] <mst> you seem to get a match in $match[0] ?

[20:41] <melezhik_> mst: do you see now what I tried to ask? or you still feel I don't give you a right example or I don't answer you questions?

[20:41] <mst> melezhik_: once you explained the regexps were generated and could have more than one capture, I was able to help

[20:42] <ZoffixMobile> m: dd 'foo' ~~ /(f(o(o)))/

[20:42] <camelia> rakudo-moar 0cf712: OUTPUT«Match.new(ast => Any, list => (Match.new(ast => Any, list => (Match.new(ast => Any, list => (Match.new(ast => Any, list => (), hash => Map.new(()), orig => "foo", to => 3, from => 2),), hash => Map.new(()), orig => "foo", to => 3, from => 1),), hash => Map…»

[20:42] <melezhik_> mst: ok

[20:42] <mst> melezhik_: that was a perfectly fine answer, it's just it would've been quicker if you'd said that the first time I asked :)

[20:43] <ZoffixMobile> Speed is not the name of the game.

[20:44] * ZoffixMobile &

[20:44] *** ZoffixMobile left
[20:44] <melezhik_> ok, I was trying  to reformualte my question , at least I feel so, but you kept sayining that maybe I don't need a captures, that I was confused ... 

[20:46] <mst> melezhik_: because your original problem didn't need any. only when you told me (a) the regex was generated (b) it could have two sets of (), did you give me a problem that did need captures

[20:46] <ugexe> if you're using arbitrarily deep nested unnamed regex matches to create an ordered list you're gonna have a bad time

[20:47] <mst> melezhik_: the outside constraints of your problem are important to finding the best solution. next time please tell us -why- you're doing something, it'll be much easier that way

[20:47] <dj_goku> anyone ever use Proc::Async as a Command Runner for Shell commands? vs a serial copy and paste.

[20:47] <mst> also, it may be we can introduce you to a new part of perl6 that makes the problem go away :)

[20:48] <melezhik_> yeah. mst: but when I gave an example, it was only an example of generic issue, ok I will try to bring more details at the start of my next questions, but in other side sometimes one should not treat an examples as concrete task to solve

[20:48] <mst> the problem was that you gave an example best solved without captures

[20:48] <melezhik_> at least for some cases it's not a good approach to help , IMHO

[20:48] *** kaare__ left
[20:48] <mst> which is why I asked for a better example

[20:49] <mst> I don't mind people using examples of the problem, but they have to be examples of the problem. examples of a much simpler and different problem don't help :)

[20:49] <melezhik_> mst: yeah, I see your point, at least now, we are ok, are not we?

[20:51] <mst> melezhik_: I've always been fine. I just wanted to actually solve your problem :)

[20:51] <melezhik_> mst: I asked just in case :)

[20:51] <harmil_wk> Is there a way to access a sub that's defined within a class from an instance of that class? (not a submethod, but an actual "sub")

[20:52] <melezhik_> I will examine, map, values and comb ways I will let you guys know in case I have further help

[20:52] <melezhik_> thanks!

[20:52] <Zoffix> melezhik_, do you care about named captures as well? $<foobar> ?

[20:52] <mst> harmil_wk: subs aren't actually defined within a class, they're actually defined within a scope - they're lexical

[20:52] <melezhik_> Zoffix: no, I do not need a named captures ...

[20:53] <mst> the block they're in might incidentally be a 'class ... {' block but so far as I can tell it's all the same to the subs

[20:53] <ugexe> m: class Foo { my sub bar { say 666; }; method foo { &bar(); } }; Foo.foo # ?

[20:53] <camelia> rakudo-moar 0cf712: OUTPUT«666␤»

[20:54] <perlpilot> harmil_wk: have a method on that class that's defined within the same scope as that sub  call the sub.  (what ugexe said)

[20:59] *** yqt left
[20:59] *** melezhik_ left
[21:00] *** sufrostico left
[21:02] *** sufrostico joined
[21:02] *** espadrine joined
[21:03] *** MilkmanDan left
[21:04] *** skids left
[21:05] <Zoffix> melezhik, well, I was gonna cook something quick, but I failed :) Not familiar with Match objects. Here's a good list of how NOT to do it tho 😜 https://gist.github.com/zoffixznet/a6f8bd97c94214048d4e36b2ce6fedd6

[21:05] *** Zoffix left
[21:05] *** sufrostico left
[21:05] <mst> Zoffix++ # "lists of how not to do it" are awesome.

[21:06] *** girafe left
[21:06] *** itaipu left
[21:07] *** itaipu joined
[21:18] <harmil_wk> Okay, I think I'm done beating my head against modifying the -n wrapper behavior. Maybe another day.

[21:20] *** mcmillhj left
[21:22] *** jmark left
[21:23] *** TEttinger left
[21:27] *** itaipu left
[21:27] *** nadim joined
[21:27] *** itaipu joined
[21:29] *** leejo left
[21:31] *** mrf left
[21:34] *** cdg joined
[21:45] *** robertle left
[21:49] *** spider-mario left
[21:50] *** mcmillhj joined
[21:55] *** mcmillhj left
[22:04] *** MilkmanDan joined
[22:08] *** mcmillhj joined
[22:11] *** rgrinberg left
[22:13] *** mcmillhj left
[22:15] *** Upasaka left
[22:19] *** _slade_ joined
[22:20] *** spebern left
[22:22] *** itaipu left
[22:23] *** mcmillhj joined
[22:24] *** yqt joined
[22:29] *** mcmillhj left
[22:34] *** zengargoyle left
[22:40] *** mcmillhj joined
[22:42] *** firstdayonthejob left
[22:45] *** mcmillhj left
[22:45] *** Alikzus left
[22:46] *** Alikzus joined
[22:52] *** rmmm left
[22:53] *** rgrinberg joined
[23:05] *** canopus left
[23:05] *** canopus joined
[23:06] *** mcmillhj joined
[23:07] *** cpage_ left
[23:11] *** mcmillhj left
[23:12] *** bjz left
[23:13] *** skids joined
[23:19] *** Upasaka joined
[23:20] *** mcmillhj joined
[23:24] *** mcmillhj left
[23:26] *** jameslenz left
[23:32] *** mcmillhj joined
[23:44] *** cdg left
[23:46] *** MilkmanDan left
[23:48] *** MilkmanDan joined
[23:52] *** TEttinger joined
[23:54] *** BenGoldberg joined
[23:55] *** rmmm joined
[23:56] *** RabidGravy left
