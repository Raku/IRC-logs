[00:00] *** cyphase joined
[00:01] *** [particle] joined
[00:02] <tbrowder>  timotimo: thanks, flat vs '|' is confusing

[00:04] <timotimo> mhm

[00:04] * timotimo goes to bed, or something

[00:04] <timotimo> cya!

[00:06] <raiph> isn't flat vs

[00:06] <raiph> isn

[00:06] <raiph> gah!

[00:08] <raiph> tbrowder: isn't flat vs '|' just a case of a listop vs an unary (one item) prefix op?

[00:09] <raiph> m: say flat (1,2),(3,4); say |(1,2),3,4

[00:09] <camelia> rakudo-moar 5a4963: OUTPUT«(1 2 3 4)␤1234␤»

[00:13] *** [particle] left
[00:20] *** [particle] joined
[00:21] <raiph> tbrowder: Forget my previous comment. Have you read the p6doc pages for `flat` and for prefix (routine) `|`? I just spent a while playing around with them and they worked for me as per the doc.

[00:22] <raiph> Perhaps they do something different in NQP?

[00:22] <timotimo> yes, it's different in nqp, as it doesn't have "flat"

[00:23] <raiph> Ah, well, a mention of `flat` would be confusing then I guess. :)

[00:24] *** daxim left
[00:28] *** [particle] left
[00:28] *** mcsnolte left
[00:30] <raiph> tbrowder: So I guess what jnthn meant on slide 21 is *implicit* flattening

[00:31] <Xliff> ooh! Compiling with debug is USEFUL!

[00:34] <Xliff> Well, now I know what is causing the SEGV, the problem is due to a bad attribute in a tree-like data structure. :(

[00:35] *** torbjorn_ left
[00:36] *** torbjorn joined
[00:40] *** [particle] joined
[00:47] <ZoffixLappy> huggable, higher level async constructs :is: See this talk: http://is.gd/Perl6JW

[00:47] <huggable> ZoffixLappy, Added higher level async constructs as See this talk: http://is.gd/Perl6JW

[00:48] *** bjz joined
[00:50] *** cpage_ left
[00:51] *** cpage_ joined
[00:57] *** dvinciguerra_ left
[01:02] <ZoffixLappy> You can't buy video or slides from Damian 'cause it's his income basically :)

[01:03] *** ZoffixLappy left
[01:03] *** Actualeyes joined
[01:04] *** [particle] left
[01:04] *** Sgeo_ left
[01:06] *** Sgeo joined
[01:08] *** [particle] joined
[01:12] *** sufrostico left
[01:13] *** cdg left
[01:14] *** cdg joined
[01:17] *** [particle] left
[01:18] *** kalkin-_ joined
[01:18] *** kalkin- left
[01:20] *** jellisii joined
[01:20] *** cdg left
[01:21] *** daxim joined
[01:22] *** jellisii left
[01:25] *** [particle] joined
[01:30] <tbrowder> ref flat: Damian described the '|' as approximately an insertion operator which acts to flatten an array...

[01:32] *** addison left
[01:34] *** [particle] left
[01:38] *** [particle] joined
[01:44] <gfldex> m: my @a = 1,2,3,4,5; @a[2] = |<a b>; dd @a; my @b = @a.clone; dd @b;

[01:44] <camelia> rakudo-moar 5a4963: OUTPUT«Array @a = [1, 2, slip("a", "b"), 4, 5]␤Array @b = [1, 2, slip("a", "b"), 4, 5]␤»

[01:44] *** ilbot3 left
[01:45] <gfldex> a slip is a List that is treated differently by a List iterator. If a List iterator encounters a Slip, it will decent into the Slip and return all it's values. It will then continue with the rest of the elements of the outer List.

[01:47] *** ilbot3 joined
[01:50] *** bjz_ joined
[01:52] *** bjz left
[01:52] *** kid511 left
[01:57] *** molaf left
[02:09] *** molaf joined
[02:10] *** Sgeo_ joined
[02:12] *** Sgeo left
[02:12] *** noganex joined
[02:13] *** Sgeo joined
[02:15] *** Sgeo_ left
[02:15] *** [particle] left
[02:15] *** noganex_ left
[02:17] *** Sgeo_ joined
[02:18] *** Sgeo left
[02:19] *** autarch joined
[02:21] *** ssotka left
[02:25] <Zoffix> jnthn, so Damian praised your work a lot during the talk today :) Got any learning materials to recommend? I'm currently half-through https://github.com/edumentab/rakudo-and-nqp-internals-course/  what else would make me better able to hack on rakudo?

[02:25] *** Guest42010 left
[02:26] *** woodruffw joined
[02:26] *** woodruffw left
[02:26] *** woodruffw joined
[02:32] *** rgrinberg joined
[02:40] <Zoffix> We need to get more people from the West coast in here.... (so quiet in the evenings :P)

[02:40] *** ShimmerFairy joined
[02:41] <dalek> doc: d38d74b | (Zoffix Znet)++ | html/.htaccess:

[02:41] <dalek> doc: Force a single subdomain for all server aliases.

[02:41] <dalek> doc: 

[02:41] <dalek> doc: Closes #285

[02:41] <dalek> doc: review: https://github.com/perl6/doc/commit/d38d74b830

[02:42] *** [particle] joined
[02:42] <Xliff> Zoffix: I yam every-coast

[02:43] <Xliff> <- Night owl

[02:46] <dalek> doc: 7e455dc | (Zoffix Znet)++ | / (6 files):

[02:46] <dalek> doc: Normalize docs subdomain used in links

[02:46] <dalek> doc: review: https://github.com/perl6/doc/commit/7e455dc892

[02:48] <Xliff> \o/ # Fixed SEGV

[02:49] <dalek> doc: 81da19c | (Zoffix Znet)++ | CONTRIBUTING.md:

[02:49] <dalek> doc: Make convenience links

[02:49] <dalek> doc: review: https://github.com/perl6/doc/commit/81da19c5b5

[02:51] <dalek> doc: 937d36e | (Zoffix Znet)++ | STYLEGUIDE.md:

[02:51] <dalek> doc: Add styleguide for absolute links to the docs site

[02:51] <dalek> doc: review: https://github.com/perl6/doc/commit/937d36e64f

[02:51] <Zoffix> Xliff++

[02:52] <dalek> doc: f216efe | (Zoffix Znet)++ | STYLEGUIDE.md:

[02:52] <dalek> doc: Fix typo

[02:52] <dalek> doc: review: https://github.com/perl6/doc/commit/f216efe62f

[03:02] <Xliff> Fixed test!! ＼(＾O＾)／

[03:03] <Xliff> Was worried, thar!

[03:14] <Zoffix> Oh, another good item from the talk: Damian said this time next year there may be a Perl 6 book out :)

[03:15] <Xliff> Nice!

[03:15] <Xliff> Aaannd..... I am out of the woods.

[03:15] <Xliff> Until I yam foolish and dive in again.

[03:16] <Xliff> (which will be soon.... yes....)

[03:22] <Zoffix> Pic from Damian's talk. That link supposed to be a good material on concurrency by jnthn++ http://www.meetup.com/Toronto-Perl-Mongers/photos/27079930/451584175/

[03:23] <jdv79> damian went that far north?  why?

[03:23] <Zoffix> He loves us :)

[03:23] <jdv79> it just commonwealth love.  its not real.

[03:23] <Zoffix> :)

[03:24] *** Khisanth left
[03:25] *** yanmc joined
[03:25] *** yanmc left
[03:25] *** yanmc joined
[03:35] *** tadzik left
[03:39] *** Khisanth joined
[03:39] *** huggable left
[03:40] *** huggable joined
[03:41] *** raiph left
[03:41] * Xliff is now playing: A Tribe Called Quest - Scenario

[03:42] <Xliff> Here we go YO! Here we go YO!

[03:42] * Xliff dances

[03:43] <Xliff> \m/...(>.<)…\m/

[03:53] *** bjz_ left
[03:53] <Xliff> m: sub f { fail "Blargh" }; try f; say $! if $!

[03:53] <camelia> rakudo-moar 5a4963: OUTPUT«Blargh␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[03:54] <Xliff> m: sub f { die "Blargh" }; try f; say $! if $!

[03:54] <camelia> rakudo-moar 5a4963: OUTPUT«Blargh␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[03:58] <Xliff> Now just need to figure out why xmlXPathCompile doesn't throw exceptions on bad expressions..... :p

[04:05] *** tadzik joined
[04:21] *** M-matthew joined
[04:21] *** M-Illandan joined
[04:25] *** khw left
[04:30] * Xliff is now playing: Incubus - Make Out Party

[04:32] *** bjz joined
[04:40] *** molaf left
[04:40] *** ssotka joined
[04:45] *** rgrinberg left
[05:01] *** Cabanossi left
[05:02] *** Cabanossi joined
[05:13] *** [particle] left
[05:34] *** bjz left
[05:40] *** skids left
[05:45] *** sortiz joined
[05:49] *** mr-foobar left
[05:50] *** mr-foobar joined
[05:50] *** cpage_ left
[05:51] *** cosimo joined
[06:06] *** jack_rabbit joined
[06:08] *** CIAvash joined
[06:15] *** jjido joined
[06:17] *** araujo joined
[06:19] *** jjido left
[06:19] *** [particle] joined
[06:22] <Xliff> .tell FROGGS 08findnodes.t finished and all tests passing! Expect a PR, soon.

[06:22] <yoleaux> Xliff: I'll pass your message to FROGGS.

[06:22] *** jjido joined
[06:24] *** domidumont joined
[06:25] *** [particle] left
[06:28] *** domidumont left
[06:29] *** domidumont joined
[06:29] <sortiz> \o #perl6

[06:30] *** firstdayonthejob joined
[06:33] *** domidumont1 joined
[06:37] *** domidumont left
[06:42] *** firstdayonthejob left
[06:45] *** _mg_ joined
[07:03] *** ssotka left
[07:03] *** jjido left
[07:04] *** _mg_ left
[07:08] *** domidumont1 left
[07:11] *** abraxxa joined
[07:12] *** zakharyas joined
[07:18] *** telex left
[07:18] *** domidumont joined
[07:20] *** Woodi joined
[07:21] *** telex joined
[07:35] *** [particle] joined
[07:37] *** sftp left
[07:39] *** huggable left
[07:39] *** [particle] left
[07:40] *** huggable joined
[07:42] *** dogbert17 left
[07:44] *** kerframil left
[07:47] *** grassass left
[07:50] *** RabidGravy joined
[07:54] *** grondilu joined
[07:54] <grondilu> junctions on sets are not quite what would be expected IMHO:

[07:54] <grondilu> m: say set(<foo bar>).any

[07:54] <camelia> rakudo-moar 5a4963: OUTPUT«any(foo => True, bar => True)␤»

[07:54] <grondilu> we need to use .keys to do something meaningful

[07:54] <grondilu> m: say set(<foo bar>).keys.any

[07:54] <camelia> rakudo-moar 5a4963: OUTPUT«any(foo, bar)␤»

[07:55] <grondilu> it's a bit LTA, isn't it?

[07:55] *** g4 joined
[08:00] *** dakkar joined
[08:00] *** grassass joined
[08:03] *** araujo_ joined
[08:04] *** sftp joined
[08:05] *** araujo left
[08:05] *** araujo_ left
[08:05] *** araujo_ joined
[08:12] *** sftp left
[08:16] *** pmurias joined
[08:19] *** labster joined
[08:20] *** _mg_ joined
[08:24] *** darutoko joined
[08:26] *** bjz joined
[08:32] *** [particle] joined
[08:32] <llfourn> grondilu: yeah that seems wrong to me

[08:36] <Roamer`> hm, well, to be fair, the documentation does hint at the fact that sets are more like hashes than lists - it mentions "keys" in the very first example and then says that they may be treated as hashes

[08:36] <Roamer`> but, yes, it did throw me for a loop, too, yesterday :)

[08:37] *** [particle] left
[08:42] *** jkramer left
[08:42] <abraxxa> why are there no 2016.05 and 2016.06 release announcements?

[08:44] <sortiz> 'cus only R* releases are public?

[08:47] *** jkramer joined
[08:50] <jkramer> Ahoy again. In method prototypes to prevent the user from calling a method with unknown parameters? Ie I have a "method foo() {...}" but calling $foo.foo(:meh(123)) doesn't throw an error

[08:51] *** araujo_ left
[08:55] *** sftp joined
[08:57] *** [particle] joined
[09:00] <sortiz> jkramer, In Perl6 all methods have in their signature an implicit *%_ for "Interface consistency"

[09:01] <sortiz> So any named argument not explicitly declared ends in %_

[09:03] *** tlvb| joined
[09:05] <sortiz> (Unless the method declares an explicit *%foo)

[09:09] *** mls_ joined
[09:10] <jkramer> sortiz: Alright, thanks :)

[09:16] *** mls_ is now known as mls

[09:17] *** [particle] left
[09:18] <gregf_> m: sub foo(){ ... }; 10.map({ foo(a => $_) }) # throws an exception?

[09:18] <camelia> rakudo-moar 5a4963: OUTPUT«Unexpected named parameter 'a' passed␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[09:18] <gregf_> oh and a map on an int o_O

[09:20] *** Actualeyes left
[09:22] <sortiz> gregf_, What I said applies to methods, not to subroutines.

[09:22] <sortiz> m: class Foo { method foo() {} }; say Foo.^methods[0].signature.perl;

[09:22] <camelia> rakudo-moar 5a4963: OUTPUT«:(Foo $: *%_)␤»

[09:22] <sortiz> m: sub foo() {}; say &foo.signature.perl;

[09:22] <camelia> rakudo-moar 5a4963: OUTPUT«:()␤»

[09:22] *** Actualeyes joined
[09:24] <gregf_> ah - ok; sortiz++

[09:27] *** bjz left
[09:28] *** TEttinger left
[09:33] *** [particle] joined
[09:38] *** labster left
[09:47] *** [particle] left
[09:58] *** fhorck_ left
[09:58] *** sortiz left
[09:59] <jkramer> Is there a nice idiomatic way for finding differences between arrays?

[09:59] <jkramer> I need to find the elements of @a that are not in @b and vice versa. Anything neater than grepping?

[10:00] <gfldex> jkramer: see https://docs.perl6.org/language/setbagmix

[10:00] <timotimo> yeah, constructing sets

[10:00] <jkramer> Perfect, thanks!

[10:01] <gfldex> m: my @a = 1,2,3; my @b = 1,2,3; say so @a >>==<< @b;

[10:01] <camelia> rakudo-moar 5a4963: OUTPUT«True␤»

[10:02] <timotimo> m: my @a = 1, 2, 3, 5; my @b = 1, 2, 3, 4; say @a Zcmp @b

[10:02] <camelia> rakudo-moar 5a4963: OUTPUT«(Same Same Same More)␤»

[10:02] <gfldex> jkramer: depending on your problem hyper operators may be helpful too

[10:02] *** nowan joined
[10:02] <timotimo> oh, with Z, it'll stop at the shorter list

[10:02] <timotimo> whereas >>==<< will throw an exception if the lists aren't equal length

[10:03] <timotimo> stop at == ignore any differences after ...

[10:04] <gregf_> well jkramer wants the intersection i guess

[10:04] <timotimo> right

[10:04] <gregf_> so <1 3 4> intersect <1 2> would return 1

[10:04] <timotimo> well, that or the symmetric difference

[10:05] <timotimo> that'd be (&)

[10:05] <gregf_> m: <1 3 4> & <1 2>

[10:05] <camelia> rakudo-moar 5a4963: OUTPUT«WARNINGS for <tmp>:␤Useless use of "&" in expression "<1 3 4> & <1 2>" in sink context (line 1)␤»

[10:05] <timotimo> that's not (&), that's &

[10:05] <timotimo> m: say <1 3 4> (&) <1 2>

[10:05] <camelia> rakudo-moar 5a4963: OUTPUT«set(1)␤»

[10:05] <gregf_> timotimo++

[10:06] *** pmurias left
[10:06] <gregf_> m: <foo bar test baz>.grep({ <foo quux test hello>.grep(/$_/) }) # ugly and 2 loops :|

[10:06] <camelia> rakudo-moar 5a4963: ( no output )

[10:07] <gregf_> *missed a print*

[10:09] *** [particle] joined
[10:09] *** rindolf joined
[10:11] *** araujo joined
[10:12] *** araujo left
[10:12] *** araujo joined
[10:12] *** araujo left
[10:12] *** araujo joined
[10:13] <jkramer> Hmm, @x (-) @y seems to work, but also seems to return a hash. Am I missing something?

[10:13] *** [particle] left
[10:13] <jkramer> m: for <foo bar baz> (-) <foo bar qux> { say $_ }

[10:13] <camelia> rakudo-moar 5a4963: OUTPUT«baz => True␤»

[10:13] <timotimo> it's not a hash, but iterating over a set behaves just like iterating over a hash

[10:13] <timotimo> it's associative, after all, not positional

[10:14] <gfldex> m: dd <foo bar baz> (-) <foo bar qux>;

[10:14] <camelia> rakudo-moar 5a4963: OUTPUT«set("baz")␤»

[10:14] <timotimo> you can of course iterate over its .keys

[10:14] <gregf_> m:say ( <foo bar baz> (-) <foo bar qux> ).^name

[10:14] <gregf_> m: say ( <foo bar baz> (-) <foo bar qux> ).^name

[10:14] <camelia> rakudo-moar 5a4963: OUTPUT«Set␤»

[10:14] <jkramer> Ah, alright, didn't know that about sets. Yep, .keys it is then. Thanks

[10:14] *** araujo left
[10:15] *** araujo joined
[10:15] *** araujo left
[10:15] *** araujo joined
[10:15] *** araujo left
[10:15] *** [particle] joined
[10:18] *** pmurias joined
[10:21] *** kaare_ joined
[10:23] *** Actualeyes left
[10:25] *** Actualeyes joined
[10:35] <pmurias> jnthn: I didn't have any significant problems implementing nqp::handlelexpayload etc. on the js backend

[10:36] <jnthn> pmurias: Cool \o/

[10:42] *** bjz joined
[10:49] *** Actualeyes left
[10:51] *** Actualeyes joined
[10:53] <jnthn> Zoffix: Phew, glad Damian likes the concurrency stuff. :) Well, doing some of the exercises on that course would help a bit also, but there's not much for it beyond that than digging in to something and asking questions. :)

[10:56] *** [particle] left
[11:00] <Zoffix> cool

[11:02] *** [particle] joined
[11:08] *** yqt joined
[11:10] *** _mg_ left
[11:14] *** kid51 joined
[11:16] *** [particle] left
[11:22] *** [particle] joined
[11:26] *** [particle] left
[11:27] *** _mg_ joined
[11:29] *** brrt joined
[11:32] *** dvinciguerra_ joined
[11:32] *** brrt left
[11:33] *** cognominal joined
[11:33] *** iH2O joined
[11:34] *** [particle] joined
[11:34] *** rindolf left
[11:39] *** huggable left
[11:40] *** huggable joined
[11:43] *** [particle] left
[11:45] <jkramer> How can I turn an even-numbered Seq into a Hash without assigning it to a %hash variable?

[11:45] *** kid51 left
[11:45] *** brrt joined
[11:45] <jkramer> Ah, pairup maybe

[11:46] <jkramer> Hmm no

[11:47] <gregf_> prolly calling .Hash?

[11:47] *** kid51 joined
[11:47] <gregf_> m: say set(<foo bar baz>).Hash #?

[11:47] <camelia> rakudo-moar 5a4963: OUTPUT«{bar => True, baz => True, foo => True}␤»

[11:48] *** kid51 left
[11:48] *** zakharyas left
[11:48] <jkramer> Ha, yeah maybe. That'd be too obvious though

[11:49] <timotimo> iirc pairup takes two elements at a time and returns a pair of the two

[11:49] <jkramer> Works \o/

[11:49] <gregf_> m: say set(<foo bar baz>).keys.map( { $_ => 1 }).^name  #or else

[11:49] <camelia> rakudo-moar 5a4963: OUTPUT«Seq␤»

[11:49] <gregf_> m: say set(<foo bar baz>).keys.map( { $_ => 1 })  #or else

[11:49] <camelia> rakudo-moar 5a4963: OUTPUT«(foo => 1 baz => 1 bar => 1)␤»

[11:50] *** zakharyas joined
[11:50] <timotimo> um, he's asking for a Seq, not a Set :)

[11:50] <gregf_> ah - my bad. *seeing double since morning - blames Java*

[11:53] *** brrt left
[11:55] *** _mg_ left
[11:55] <jkramer> When I have a method that expects some Routine as argument, can I define what the Routine's prototype should look like? Ie. take a Str and return and Int or whatever?

[11:56] <jkramer> Signature is probably the better word

[11:57] <Roamer`> hmm, that's actually a good question, I'd like to know, too :)

[11:58] <Roamer`> I guess one could check the signature of the parameter passed

[11:58] <Roamer`> but that would be after the fact

[12:00] *** domidumont left
[12:02] *** brrt joined
[12:02] *** [particle] joined
[12:03] <BrokenRobot> jkramer: yes, just like you'd have a normal sub:   sub (Str) {...} or you can do pointy blocks:  -> Str { ... }

[12:03] <BrokenRobot> And yes, those are called Signatures

[12:04] *** dakkar left
[12:05] *** Actualeyes left
[12:06] <timotimo> important difference: the default type for a pointy block is Mu rather than Any

[12:06] <jkramer> Nice, thanks

[12:06] *** brrt left
[12:07] *** Actualeyes joined
[12:07] <BrokenRobot> m: -> $x {}(Mu)

[12:07] <camelia> rakudo-moar 5a4963: ( no output )

[12:07] <BrokenRobot> timotimo++ TIL

[12:08] <jkramer> BrokenRobot: Hmm, not sure if that's what I meant. I'd like to define the type of the sub in the signature of the method that expects the sub. Ie. method foo(sub (Str) $my-sub returns Int) or something like that

[12:10] <psch> m: sub f(&g:(Int $, Str $)) { say &g.signature }; f -> Int $, Str $ { }; try f -> Str $, Int $ { }; say $! if $!

[12:10] <camelia> rakudo-moar 5a4963: OUTPUT«(Int, Str)␤Constraint type check failed for parameter '&g'␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[12:10] <BrokenRobot> jkramer: ^ that's how :) psch++

[12:10] <jkramer> Awesome, thanks :)

[12:10] <jkramer> He, could've thought of the & sigil myself actually

[12:11] *** iH2O left
[12:13] *** dakkar joined
[12:15] *** mcsnolte joined
[12:16] <llfourn> m: class A { has @.a; }; my @a = 1..3; my %args = %( :@a ); A.new(|%args).a.perl.say' # how to DWIM here?

[12:16] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3rgs = %( :@a ); A.new(|%args).a.perl.say7⏏5' # how to DWIM here?␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤   …»

[12:16] <llfourn> m: class A { has @.a; }; my @a = 1..3; my %args = %( :@a ); A.new(|%args).a.perl.say # how to DWIM here?

[12:16] <camelia> rakudo-moar 5a4963: OUTPUT«[[1, 2, 3],]␤»

[12:16] <llfourn> (I don't want an array of arrays)

[12:18] <BrokenRobot> m: class A { has $.a; }; my @a = 1..3; my %args = :@a; A.new(|%args).a.perl.say;

[12:18] <camelia> rakudo-moar 5a4963: OUTPUT«[1, 2, 3]␤»

[12:19] <llfourn> hmmm why does that work?

[12:19] <psch> m: class A { has @.a; }; my @a = 1..3; my %args = %( :a(|@a) ); A.new(|%args).a.eager.perl.say 

[12:19] <camelia> rakudo-moar 5a4963: OUTPUT«[slip(1, 2, 3),]␤»

[12:19] <psch> ...well, minus the eager

[12:20] <psch> i think that's somewhat insightful at least.  the array Attribute container doesn't get flattened into 

[12:20] <psch> s/slipped/flattened/

[12:20] <llfourn> m: my @arg = 1..3; my %a = :@arg; my %b = %( :@arg ); say %a.perl,%b.perl;

[12:20] <camelia> rakudo-moar 5a4963: OUTPUT«{:arg($[1, 2, 3])}{:arg($[1, 2, 3])}␤»

[12:21] <BrokenRobot> llfourn: you ask for singular, so the singular (Array) gets assigned to it. If you use @ sigil, you ask for itemS, so the Array becomes a single item in it...

[12:21] <jkramer> psch: Where can I find out more about this &f:(...) syntax? Google fails me :(

[12:21] <BrokenRobot> That's my interpretation of it, at least.

[12:21] <llfourn> (they look the same if im not mistaken)

[12:21] <psch> jkramer: https://docs.perl6.org/syntax/Constraining%20signatures%20of%20Callables

[12:21] <jkramer> Thanks!

[12:22] <psch> jkramer: there really isn't more too it though.  you just attach a signature to a Callable-sigiled Parameter and the arguments' Signature has to match it vOv

[12:22] <psch> (where "attach" means "write next to the Parameter in the Signature" i suppose :) )

[12:22] <llfourn> BrokenRobot: also I did use the @ sigil?

[12:23] <BrokenRobot> llfourn: yes, and I didn't.

[12:23] <BrokenRobot> I'm not sure what you're asking :/

[12:23] <jkramer> psch: Ah yes, I was hoping I could also define the return type, but the documentation suggests I can only constrain the parameter signature

[12:23] <llfourn> BrokenRobot: yes you did?

[12:23] <psch> jkramer: well, return type can be specified in a Signature as normal :)

[12:23] <psch> m: sub f(--> Int) { "foo" }; f()

[12:23] <camelia> rakudo-moar 5a4963: OUTPUT«Type check failed for return value; expected Int but got Str ("foo")␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[12:23] <llfourn> my %args = :@a;

[12:23] <psch> llfourn: BrokenRobot is talking about the Attribute

[12:23] <jkramer> "as normal" - I've never seen this before :D

[12:23] <BrokenRobot> Yes

[12:24] <BrokenRobot> m: sub foo (*%x) { dd %x }; my @arg = 1..3; my %a = :@arg; foo |%a

[12:24] <camelia> rakudo-moar 5a4963: OUTPUT«{:arg($[1, 2, 3])}␤»

[12:24] <llfourn> psch: ah I didn't catch that thanks

[12:25] <jkramer> --> works, thanks a bunch :) Is this also documented somewhere? It seems like I'm always googling the wrong terms for this kind of stuff

[12:25] <BrokenRobot> I was gonna try to explain why the $ works and @ doesn't, but I'm not deciphering this super nested NQP call chain ^_^ https://github.com/rakudo/rakudo/blob/nom/src/core/Mu.pm#L126

[12:26] *** _mg_ joined
[12:26] <BrokenRobot> (it gave us like a 4x speed boost though)

[12:27] <llfourn> m: class A { has @.a; }; my @a = 1..3; my %args = %( :@a ); my \cap-args = \( :@a ); A.new(|%args).a.perl.say; A.new(:@a).a.perl.say; A.new(|cap-args).a.perl.say; # expected these to be the same :S

[12:27] <camelia> rakudo-moar 5a4963: OUTPUT«[[1, 2, 3],]␤[1, 2, 3]␤[1, 2, 3]␤»

[12:27] *** [particle] left
[12:27] <llfourn> so basically passing stuff to a hash itemizes stuff

[12:27] <BrokenRobot> Ah

[12:27] <llfourn> even if you |slip flatten it, it doesn't come out the same

[12:28] <timotimo> --> ought to be documented with the rest of signatures

[12:28] <cognominal> hi, why the REPL is started in strict mode ?

[12:29] <cognominal> how would I impose no strict from the command line

[12:29] <BrokenRobot> What's a strict mode? :/

[12:29] <gregf_> m: foo(Int $x, --> Int, Str $y){ 100; }; foo(1,"bar")

[12:29] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' ␤at <tmp>:1␤------> 3foo(Int7⏏5 $x, --> Int, Str $y){ 100; }; foo(1,"ba␤    expecting any of:␤        infix␤        infix …»

[12:29] *** Amnez777 left
[12:29] <psch> BrokenRobot: normal mode, without 'no strict' :)

[12:30] <BrokenRobot> What's no strict?

[12:30] <psch> m: no strict; $x = 5; say $x

[12:30] <camelia> rakudo-moar 5a4963: OUTPUT«5␤»

[12:30] <BrokenRobot> .oO( why do we even have this.... )

[12:30] <psch> i don't recall if there's more restrictions we lift under 'no strict'

[12:30] *** Actualeyes left
[12:30] <psch> hysterical raisins!

[12:30] <BrokenRobot> :)

[12:30] <cognominal> yea, but no strict is lexical. That does not carry from one line of the REPL to the other

[12:32] <BrokenRobot> cognominal: out of curiosity, why not just use the normal mode?

[12:32] <BrokenRobot> It's like asking for trouble: training yourself in writing deliberately broken code.

[12:32] *** [particle] joined
[12:33] *** FROGGS joined
[12:33] <perlpilot> Perl has always been happy to let users ask for rtouble

[12:34] <cognominal> this is just a convenience. When writing short code, declaring everything is a nuisance.

[12:34] <cognominal> historically, Perl was used for very short programs and not having to declare variable was considered a feature

[12:35] <psch> i guess you'd have to set $*STRICT to something falsey before initializing the hll compiler 

[12:35] <cognominal> this changed overt time when Perl programs got bigger

[12:35] <psch> we don't have an easy way to do that right now i think

[12:35] <psch> shouldn't be too hard to write a cl switch for though

[12:35] <llfourn> m: my @a = 1..3; my \cap = \( :@a ); say (|cap) # so captures are empty when | outside of routine call?

[12:35] <camelia> rakudo-moar 5a4963: OUTPUT«()␤»

[12:35] <cognominal> there is not such this as right or wrong per se . There is context where things are right or wrong.

[12:36] <BrokenRobot> llfourn: say is a routine call

[12:36] <llfourn> BrokenRobot: it's in ( ) so it's not part of it

[12:36] <cognominal> psch: I tried to start with   perl6 -m strict   to no avail

[12:36] <BrokenRobot> llfourn: ah, right

[12:36] <BrokenRobot> m: my @a = 1..3; my \cap = \( :@a ); dd (|cap)

[12:36] <camelia> rakudo-moar 5a4963: OUTPUT«slip()␤»

[12:36] <cognominal> perl6 -M strict works fine though

[12:36] <psch> cognominal: yes, as i said, we don't have anything that does it right now

[12:36] <BrokenRobot> weird

[12:37] <BrokenRobot> m: my @a = 1..3; my \cap = \( :@a ); dd cap

[12:37] <camelia> rakudo-moar 5a4963: OUTPUT«\(:a([1, 2, 3]))␤»

[12:37] <psch> | is prefix for .Slip, which is .list.Slip in Any

[12:38] <psch> m: my @a = 1..3; my \cap = \( @a, :@a ); dd (cap.Slip) 

[12:38] <camelia> rakudo-moar 5a4963: OUTPUT«slip([1, 2, 3],)␤»

[12:38] <psch> not quite sure why that loses the named there, but that's all it loses

[12:38] <llfourn> psch: ah that makes sense I guess, but yeah it I think the pairs should be there

[12:38] *** FROGGS left
[12:39] <psch> m: say \(a => [1,2,3]).list

[12:39] <camelia> rakudo-moar 5a4963: OUTPUT«()␤»

[12:39] <llfourn> m: my @a = 1..3; my \cap = \( :@a ); my $h = %( :@a ); cap.perl.say; %h.perl.say # the $ shows the difference between the two

[12:39] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '%h' is not declared. Did you mean '$h'?␤at <tmp>:1␤------> 3 :@a ); my $h = %( :@a ); cap.perl.say; 7⏏5%h.perl.say # the $ shows the difference␤»

[12:39] <psch> llfourn: actually, well, Capture.list gives you only the positionals

[12:39] <llfourn> m: my @a = 1..3; my \cap = \( :@a ); my %h = %( :@a ); cap.perl.say; %h.perl.say # oops

[12:39] <camelia> rakudo-moar 5a4963: OUTPUT«\(:a([1, 2, 3]))␤{:a($[1, 2, 3])}␤»

[12:40] <llfourn> psch: yeah but I think | should not do .list in this case.

[12:40] <llfourn> because it doesn't do that in routine calls

[12:40] *** [particle] left
[12:40] <psch> llfourn: but | in routine calls doesn't apply to Captures

[12:41] <llfourn> yes but I think they should try to do the same thing

[12:41] <psch> llfourn: i mean, yeah, i can see how slipping a Capture is weird, but i don't agree with the reason

[12:41] <CIAvash> m: class A { has @.a; }; my @a = [1,2,3]; my %args; %args<a> := @a; A.new(|%args).a.perl.say

[12:41] <camelia> rakudo-moar 5a4963: OUTPUT«[1, 2, 3]␤»

[12:41] <llfourn> fair enough

[12:42] <llfourn> CIAvash: interesting, so you can still get the array container inside the hash :)

[12:43] <psch> m: class A { has @.a; submethod BUILD(:@a) { @!a = @a } }; my %args = a => [1,2,3]; dd A.new(|%args)

[12:43] <camelia> rakudo-moar 5a4963: OUTPUT«A.new(a => [1, 2, 3])␤»

[12:43] <psch> or BUILD around it to not force weird stuff on your users :)

[12:44] *** rgrinberg joined
[12:44] <CIAvash> I remember that being mentioned when I asked about a similar thing before.

[12:45] <llfourn> hmm now can you make the default container for a hash an array container...or does that even make sense?

[12:45] <psch> m: my %h of Array; say %h<foo>.VAR

[12:45] <camelia> rakudo-moar 5a4963: OUTPUT«Array␤»

[12:45] *** [particle] joined
[12:46] <psch> m: my %h; say %h<foo>.VAR

[12:46] <camelia> rakudo-moar 5a4963: OUTPUT«Any␤»

[12:46] <llfourn> m: my %h of Array; my @a = 1..3; %h = :@a; say %h.perl

[12:46] <camelia> rakudo-moar 5a4963: OUTPUT«(my Array % = :a($[1, 2, 3]))␤»

[12:46] <llfourn> but still the $ there

[12:47] <psch> well, yes, because it's an item

[12:48] <llfourn> I suppose my question is can you make non-itemized hash values

[12:48] <psch> i think that's conceptually impossible

[12:48] <psch> a Pair is always 1:1

[12:48] <llfourn> but I don't really think I fully grasp wha...yeah :)

[12:49] *** Actualeyes joined
[12:49] <llfourn> m: my @a = 1..3; \( :@a ).perl.say; # but when you put them in captures they don't have the $

[12:49] <camelia> rakudo-moar 5a4963: OUTPUT«\(:a([1, 2, 3]))␤»

[12:50] *** [particle] left
[12:50] <llfourn> (and behave differently when flattened)

[12:50] <psch> m: my @a = 1..3; say \( :@a ).hash<a>.VAR

[12:50] <camelia> rakudo-moar 5a4963: OUTPUT«[1 2 3]␤»

[12:50] <psch> there's no container

[12:50] <llfourn> ah

[12:51] <llfourn> right so can you make a hash where the values are not put into containers?

[12:51] <llfourn> (I mean without constructing each key with := )

[12:52] <moritz> it's called a Map

[12:53] <moritz> a hash is defined by having containerized elements, just like arrays

[12:53] <moritz> to allow assignment

[12:53] <llfourn> moritz: that's handy

[12:54] * llfourn goes back to the original example

[12:55] <llfourn> m: class A { has @.a; }; my @a = 1..3; my %h := Map.new( (:@a) ); A.new(|%h).a.perl.say # yay!

[12:55] <camelia> rakudo-moar 5a4963: OUTPUT«[1, 2, 3]␤»

[12:55] *** mcmillhj joined
[12:55] <moritz> m: say chars [*] 1..100

[12:55] <camelia> rakudo-moar 5a4963: OUTPUT«158␤»

[12:56] *** Actualeyes left
[12:57] *** Actualeyes joined
[13:04] *** [particle] joined
[13:05] <llfourn> is there a junction friendly way of doing .WHAT so ("a"|"b").WHAT yields any(Str,Str)?

[13:06] <psch> "if you care about the values of a Junction you should be using a Set" i think the saying goes

[13:06] *** Actualeyes left
[13:06] <llfourn> psch: I don't care about the values in the junction

[13:06] <moritz> m: sub what($x) { $x.WHAT }; say what('a'|'b')

[13:06] <camelia> rakudo-moar 5a4963: OUTPUT«any((Str), (Str))␤»

[13:07] <llfourn> moritz: why does that work?

[13:08] <moritz> llfourn: because the default type of paramaters is Any, so calling what autothreads over the junction

[13:08] <llfourn> ahhh

[13:08] <llfourn> thanks :)

[13:10] *** tlvb left
[13:10] *** sufrostico joined
[13:11] *** lizmat joined
[13:13] *** zakharyas left
[13:14] *** tlvb joined
[13:15] *** zakharyas joined
[13:15] <timotimo> also, .WHAT isn't a method invocation, but basically an nqp:: op called on the value

[13:19] <BrokenRobot> m: (*.WHAT.say)("a"|"b")

[13:19] <camelia> rakudo-moar 5a4963: OUTPUT«(Whatever)␤No such method 'CALL-ME' for invocant of type 'Bool'␤  in block <unit> at <tmp> line 1␤␤»

[13:19] <BrokenRobot> :/ how come?

[13:19] <BrokenRobot> m: (*.uc.say)("a"|"b")

[13:19] <camelia> rakudo-moar 5a4963: OUTPUT«any(A, B)␤»

[13:19] <BrokenRobot> Ah, what timo said.. basically :)

[13:19] <cognominal> I was wrong about 'no strict' carrying over subsequent lines int the REPL. It does because it is lexical

[13:23] <dalek> doc: de23b7c | (Zoffix Znet)++ | / (6 files):

[13:23] <dalek> doc: Use SASS

[13:23] <dalek> doc: review: https://github.com/perl6/doc/commit/de23b7ca9f

[13:24] *** Actualeyes joined
[13:27] *** sufrostico left
[13:29] *** dj_goku left
[13:30] <dalek> doc: 83f00cf | (Zoffix Znet)++ | / (2 files):

[13:30] <dalek> doc: Make old style sheet sassy

[13:30] <dalek> doc: review: https://github.com/perl6/doc/commit/83f00cf2cf

[13:32] *** dj_goku joined
[13:34] <dalek> doc: 534d9b8 | (Zoffix Znet)++ | app.pl:

[13:34] <dalek> doc: Indicate when we are done processing sass

[13:34] <dalek> doc: review: https://github.com/perl6/doc/commit/534d9b8aac

[13:34] <BrokenRobot> Coding Perl 5 after Perl 6 is a nightmare.

[13:35] <masak> I actually find it's not so bad

[13:35] <masak> maybe you need to up your Perl 5 :P

[13:35] *** rindolf joined
[13:35] <moritz> the transition is hard

[13:35] <BrokenRobot> Well, the transitionary period is a nightmare. 

[13:35] <BrokenRobot> Yeah.

[13:35] <moritz> and giving up on some niceties is grating

[13:36] <moritz> I so miss :$foo for foo => $foo when I do Perl 5

[13:36] <moritz> and expresive signatures

[13:36] <moritz> (i miss :$foo in python as well)

[13:37] <perlpilot> greetings

[13:37] <BrokenRobot> \o

[13:38] <perlpilot> masak: Do you use Moops or other syntactic niceties in Perl 5?

[13:39] <moritz> Moops? Moose?

[13:39] *** g4 left
[13:39] <BrokenRobot> https://metacpan.org/pod/Moops

[13:40] <masak> perlpilot: I do use Moose when I can.

[13:40] <masak> perlpilot: I haven't gone as far as using Moops.

[13:40] <masak> oh, I *miss* things when coding in Perl 5

[13:40] <llfourn> moritz: what does :$foo in python look like?

[13:40] <masak> but I wouldn't call coding in it a nightmare.

[13:41] <masak> llfourn: `foo=foo`, I guess

[13:41] <BrokenRobot> Heh, fair enough. It's just miss-erable :)

[13:41] <llfourn> ah right.

[13:42] <moritz> in python, I miss named-only parameters

[13:42] <moritz> (though I hear they are coming)

[13:42] <perlpilot> masak: yeah, it's more like death by a thousand cuts kinda thing.  It's all those little annoyances that grate on your brain because it's not Perl 6.  :)

[13:42] <mst> moritz: Function::Parameters ?

[13:43] * lizmat waves, Really

[13:43] <mst> Moo + Type::Tiny is sufficient for me for the moment

[13:43] <perlpilot> lizmat: o/

[13:43] <mst> but my current code is going to fatpack back til 5.8

[13:43] <mst> I'll be breaking out the shiny later

[13:44] *** Sgeo_ left
[13:45] *** Amnez777 joined
[13:46] *** [particle] left
[13:46] <moritz> 5.8? teh horror

[13:46] <moritz> no //

[13:47] * BrokenRobot shudders

[13:47] <hoelzro> morning #perl6

[13:47] <BrokenRobot> morning

[13:47] *** [particle] joined
[13:47] <perlpilot> morning hoelzro 

[13:47] <hoelzro> o/ BrokenRobot, perlpilot 

[13:48] <hoelzro> I have a quick question about live vs on-demand supplies, I want to make sure I understand them properly

[13:48] <gregf_> those named args have been made available in ruby > 2.2.*

[13:48] *** Actualeyes left
[13:48] <hoelzro> for live supplies, they generate values, and for each value, they send it to whomever is listening, yes? so if I tap it after an event, that tapper will not receive that event, correct?

[13:49] *** yqt left
[13:49] <hoelzro> for on-demand supplies, it's the exact same, only with the change that the very *first* tapper receives all of the events that have been emitted thus far, right?

[13:49] <perlpilot> hoelzro: I'm no expert, but that sounds correct to me.

[13:49] <hoelzro> because the supply doesn't run until tapped, much like a unix FIFO?

[13:50] <hoelzro> s/unix FIFO/process attached to a unix FIFO/

[13:50] <lizmat> hoelzro: too jetlagged at the moment to give a good answer to that

[13:50] <hoelzro> =)

[13:51] *** Actualeyes joined
[13:51] <gregf_> s/2.2/2.1/

[13:53] <jnthn> hoelzro: A live supply is like a TV broadcast. If you weren't watching stuff, it's gone and you missed it. It's a stateless stream of stuff.

[13:53] <BrokenRobot> hoelzro: I thought on-demand supplies all tappers get all values 

[13:54] <BrokenRobot> m: my $s = supply { emit $_ for ^5 }; $s.tap: *.say; $s.tap: *.say

[13:54] <camelia> rakudo-moar 5a4963: OUTPUT«0␤1␤2␤3␤4␤0␤1␤2␤3␤4␤»

[13:54] <BrokenRobot> m: my $s = supply { emit $_ for ^5 }; $s.tap: *.say; $s.tap: *.say; $s.tap: *.say

[13:54] <camelia> rakudo-moar 5a4963: OUTPUT«0␤1␤2␤3␤4␤0␤1␤2␤3␤4␤0␤1␤2␤3␤4␤»

[13:54] <jnthn> hoelzro: An on-demand supply is like watching a video on Netflix or so. When you start watching it, you start getting frames. If somebody else starts watching it, they get their own stream of the frames. etc.

[13:55] <jnthn> And if you stop watching, that doesn't impact anyone else.

[13:55] <hoelzro> jnthn: so as BrokenRobot suggests, once you tap an on-demand supply, you get the entire history?

[13:55] <jnthn> No.

[13:55] <jnthn> You *start a new history*.

[13:55] <jnthn> Though there is no history in supplies really

[13:55] *** rindolf left
[13:55] <hoelzro> oh, I figured as much

[13:55] <jnthn> There *is* a type of Supplier that buffers.

[13:56] *** [particle] left
[13:56] <BrokenRobot> m: my $s = supply { for ^5 { say "generating $_; emit $_ } }; $s.tap: *.say; $s.tap: *.say; $s.tap: *.say

[13:56] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in double quotes; couldn't find final '"' ␤at <tmp>:1␤------> 3tap: *.say; $s.tap: *.say; $s.tap: *.say7⏏5<EOL>␤    expecting any of:␤        method arguments␤»

[13:56] <BrokenRobot> m: my $s = supply { for ^5 { say "generating $_"; emit $_ } }; $s.tap: *.say; $s.tap: *.say; $s.tap: *.say

[13:56] <camelia> rakudo-moar 5a4963: OUTPUT«generating 0␤0␤generating 1␤1␤generating 2␤2␤generating 3␤3␤generating 4␤4␤generating 0␤0␤generating 1␤1␤generating 2␤2␤generating 3␤3␤generating 4␤4␤generating 0␤0␤generating 1␤1␤generating 2␤2␤generatin…»

[13:56] * BrokenRobot gets it now o/

[13:56] <BrokenRobot> jnthn++

[13:56] <jnthn> m: sub s() { supply { say 'here'; emit rand; } }; s.tap(*.say); s.tap(*.say)

[13:56] <camelia> rakudo-moar 5a4963: OUTPUT«here␤0.533383130413306␤here␤0.177299685829522␤»

[13:56] <BrokenRobot> :o

[13:57] <jnthn> A supply block is run per tapping of an on-demand supply.

[13:57] <jnthn> As illustrated above :)

[13:57] <hoelzro> but those are two separate supplies, yes?

[13:57] <jnthn> ah, maybe more clear then is:

[13:57] <jnthn> m: sub s() { supply { say 'here'; emit rand; } }; my $s = s(); $s.tap(*.say); $s.tap(*.say)

[13:57] <camelia> rakudo-moar 5a4963: OUTPUT«here␤0.076437799520763␤here␤0.164639854251952␤»

[13:57] <jnthn> It's each tapping that starts a new flow of values

[13:58] <jnthn> (With an on-demand supply)

[13:58] <jnthn> So you can think of a supply block as running per tapping, just as Netflix starts streaming a movie per person who starts watching it.

[13:58] <perlpilot> I don't know what's in the docs right now, but that TV/netflix analogy sounds like it might be a good addition

[13:58] <hoelzro> oooh I see

[13:59] <BrokenRobot> +1 really good analogy

[13:59] <hoelzro> so supply { ... } is on-demand, and Supplier.new is live, yes?

[13:59] <jnthn> Yes

[13:59] *** pmurias left
[14:00] <jnthn> And note that things like Supply.interval is on-demand too; you're starting a distinct timer.

[14:01] *** [particle] joined
[14:02] <jnthn> (On each .tap)

[14:03] *** girafe joined
[14:03] <dalek> doc: becddba | (Zoffix Znet)++ | doc/Language/concurrency.pod:

[14:03] <dalek> doc: Include TV broadcast/Netflix analogy for supplies jnthn++

[14:03] <dalek> doc: review: https://github.com/perl6/doc/commit/becddba635

[14:03] <hoelzro> so it's kind of like an async gather/take

[14:03] *** dvinciguerra_ left
[14:04] <dalek> doc: 5f65feb | (Zoffix Znet)++ | doc/Language/concurrency.pod:

[14:04] <dalek> doc: Improve Netflix portion of the analogy

[14:04] <dalek> doc: review: https://github.com/perl6/doc/commit/5f65febfd0

[14:05] * BrokenRobot coins "on-demand supplies and chill" phrase :)

[14:05] <BrokenRobot> tough crowd :P

[14:06] * llfourn coughs

[14:06] <mst> stop humping the VM, dude, just cos it keeps saying 'moar' doesn't mean it's capable of consent

[14:06] * llfourn coughs twice

[14:07] <BrokenRobot> :)

[14:07] *** pmurias joined
[14:07] *** dvinciguerra_ joined
[14:07] <perlpilot> llfourn: you're supposed to turn your head in there somewhere

[14:08] * llfourn turns head

[14:08] *** acrussell joined
[14:08] *** skids joined
[14:10] *** tharkun left
[14:11] *** tharkun joined
[14:13] *** [particle] left
[14:14] *** [particle] joined
[14:14] *** Actualeyes left
[14:18] *** ptolemarch joined
[14:18] *** freezerburnV joined
[14:19] *** tharkun left
[14:19] *** tharkun joined
[14:20] *** Bodger1234 joined
[14:20] *** molaf joined
[14:21] <jkramer> I just wrote a potentially useful thing in P6. Since it's the first thing I've written in P6 that's not a dumb example I'd appreciate feedback regarding optimization/design etc. https://gist.github.com/jkramer/98e9ac48cb04a98410b7b914da847344

[14:23] <jkramer> It's a beanstalk client lib, doesn't support all commands yet and doesn't catch all potential beanstalk errors, but seems to be working.

[14:25] *** freezerburnV left
[14:25] *** vytas left
[14:25] <psch> m: say "265.0.0.1" ~~ /^ (\d ** 1..3)**4 %% '.' <?{ 0 <= all(@0) < 256 }> $ /; 

[14:25] <camelia> rakudo-moar 5a4963: OUTPUT«Nil␤»

[14:26] <psch> m: say "127.0.0.1" ~~ /^ (\d ** 1..3)**4 %% '.' <?{ 0 <= all(@0) < 256 }> $ /; 

[14:26] <camelia> rakudo-moar 5a4963: OUTPUT«｢127.0.0.1｣␤ 0 => ｢127｣␤ 0 => ｢0｣␤ 0 => ｢0｣␤ 0 => ｢1｣␤»

[14:26] <psch> jkramer: i'd probably use something like that as the type for $.host

[14:27] <BrokenRobot> jkramer: you can write :port($.port)) as :$.port

[14:27] <jkramer> psch: It's not necessarily an IP address

[14:28] * pmurias just added a -Ofun option to nqp-js

[14:28] <psch> oh, right

[14:28] <psch> yeah, that makes sense

[14:29] *** [particle] left
[14:29] <jkramer> BrokenRobot: Thanks, didn't know that

[14:29] <psch> m: my $x where .so; 

[14:29] <camelia> rakudo-moar 5a4963: ( no output )

[14:29] <psch> m: my $x where .so; $x = ""

[14:29] <camelia> rakudo-moar 5a4963: OUTPUT«Type check failed in assignment to $x; expected <anon> but got Str ("")␤  in block <unit> at <tmp> line 1␤␤»

[14:29] <BrokenRobot> huh

[14:30] <BrokenRobot> m: my $x where .so; $x = "dasd"

[14:30] <camelia> rakudo-moar 5a4963: ( no output )

[14:30] <BrokenRobot> $_ is available in where even without curlies?

[14:30] <BrokenRobot> jkramer: the rest looks good to me

[14:31] <BrokenRobot> If only too many parentheses :)

[14:31] <jkramer> .so is just like using a Scalar in boolean context in P5?

[14:31] <BrokenRobot> jkramer: yeah, basically

[14:32] <jkramer> What does it stand for? :D

[14:32] <BrokenRobot> "so" is a low-precedence version of the reverse of "not"

[14:32] <BrokenRobot> It's not an acronym. It's a play on "is so" "is not"

[14:32] <jkramer> Ah, ok

[14:33] <BrokenRobot> And in this case, it's a method-call version of it.

[14:33] <jnthn> m: say so not True

[14:33] <camelia> rakudo-moar 5a4963: OUTPUT«False␤»

[14:33] <jnthn> :)

[14:33] *** harmil joined
[14:33] <BrokenRobot> https://docs.perl6.org/routine/so#class_Mu

[14:33] *** Actualeyes joined
[14:34] <jkramer> Is it actually necessary though? I mean if I say 'if $some-string {...', isn't it implicit?

[14:34] <BrokenRobot> jkramer: it's implicit, yes

[14:34] <BrokenRobot> m: my $x where $_; $x = ""

[14:34] <camelia> rakudo-moar 5a4963: ( no output )

[14:34] <BrokenRobot> m: my $x where $_; $x = "ds"

[14:34] <camelia> rakudo-moar 5a4963: ( no output )

[14:34] <BrokenRobot> m: my $x where { $_ }; $x = "ds"

[14:34] <camelia> rakudo-moar 5a4963: ( no output )

[14:34] <CIAvash> BrokenRobot: http://irclog.perlgeek.de/perl6/2016-06-25#i_12734545 :)

[14:34] <BrokenRobot> m: my $x where { $_ }; $x = ""

[14:34] <camelia> rakudo-moar 5a4963: OUTPUT«Type check failed in assignment to $x; expected <anon> but got Str ("")␤  in block <unit> at <tmp> line 1␤␤»

[14:35] <BrokenRobot> CIAvash: it doesn't seem to though ^

[14:35] <BrokenRobot> Rather... it does it partially?

[14:36] <BrokenRobot> m: my $x where $_ eq "ds"; $x = "ds"

[14:36] <camelia> rakudo-moar 5a4963: ( no output )

[14:36] <BrokenRobot> wtf

[14:36] <BrokenRobot> m: my $x where $_ eq "ds"; $x = "dsdsds"

[14:36] <camelia> rakudo-moar 5a4963: OUTPUT«Type check failed in assignment to $x; expected <anon> but got Str ("dsdsds")␤  in block <unit> at <tmp> line 1␤␤»

[14:36] <BrokenRobot> Well, then I've no idea why my $x where $_; $x = "" doesn't complain

[14:38] <BrokenRobot> m: my $x where dd $_; $x = "dsdsds"

[14:38] <camelia> rakudo-moar 5a4963: OUTPUT«Str <element> = "dsdsds"␤Type check failed in assignment to $x; expected <anon> but got Str ("dsdsds")␤  in block <unit> at <tmp> line 1␤␤»

[14:38] <CIAvash> hmm

[14:39] <harmil> @arnsholt or others involved in snake, my https://github.com/harmil/sixstrictor project (pure-Perl Python 2) as mentioned on reddit is about 80% of the way through with the parser. Actions will be a whole other ball of wax. I wonder if I should use your runtime and retro-extend it for Python 2?

[14:41] *** Actualeyes left
[14:41] *** [particle] joined
[14:42] <pmurias> harmil: hi, unifying efforts would be great

[14:42] *** Actualeyes joined
[14:42] <pmurias> harmil: keep in mind that snake is far from complete yet

[14:42] <harmil> I assumed. It seems to have come along further than previous efforts, though.

[14:43] *** kyclark joined
[14:43] <pmurias> harmil: why python 2 instead of 3?

[14:43] *** mcmillhj left
[14:45] <harmil> Because the vast majority of Python code out there is Python 2, and it's not forward-compatible, so I'd like to have a library that parses the largest subset of code. Perl 6, IMHO, is as valid a migration path for Python 2 as Python 3...

[14:45] *** _mg_ left
[14:46] *** kyclark left
[14:47] <CIAvash> m: my $x where ''; $x = '';

[14:47] <camelia> rakudo-moar 5a4963: ( no output )

[14:47] <CIAvash> m: my $x where {''}; $x = '';

[14:47] <camelia> rakudo-moar 5a4963: OUTPUT«Type check failed in assignment to $x; expected <anon> but got Str ("")␤  in block <unit> at <tmp> line 1␤␤»

[14:47] <BrokenRobot> m: my $x where False; $x = '';

[14:47] <camelia> rakudo-moar 5a4963: OUTPUT«Potential difficulties:␤    Smartmatch against False always fails; if you mean to test the topic for truthiness, use :!so or *.not or !* instead␤    at <tmp>:1␤    ------> 3my $x where 7⏏5False; $x = '';␤Type check failed in assignment to $x;…»

[14:47] <BrokenRobot> m: say '' ~~ ''

[14:47] <camelia> rakudo-moar 5a4963: OUTPUT«True␤»

[14:47] <BrokenRobot> m: say '' ~~ 'dasdas'

[14:47] <camelia> rakudo-moar 5a4963: OUTPUT«False␤»

[14:48] <BrokenRobot> Ah, I see. 

[14:48] *** acrussell left
[14:49] <pmurias> harmil: I have to get afk, will be back much later today and tommorow

[14:49] <CIAvash> m: my $x where {''}(); $x = '';

[14:49] <camelia> rakudo-moar 5a4963: ( no output )

[14:49] *** pmurias left
[14:49] <BrokenRobot> m: {''} ~~ ''

[14:49] <camelia> rakudo-moar 5a4963: OUTPUT«Block object coerced to string (please use .gist or .perl to do that)  in block <unit> at <tmp> line 1␤»

[14:51] <BrokenRobot> So basically if it's Code, it calls it and passes the type if the return is true. If not, it smartmatches it and in that situation, $_ works even if it's ''

[14:51] <BrokenRobot> hmmm

[14:51] <BrokenRobot> m: my $x where $_ eq "ds"; $x = "ds"

[14:51] <camelia> rakudo-moar 5a4963: ( no output )

[14:51] <BrokenRobot> m: my $x where $_ eq "dsdsds"; $x = "ds"

[14:51] <camelia> rakudo-moar 5a4963: OUTPUT«Type check failed in assignment to $x; expected <anon> but got Str ("ds")␤  in block <unit> at <tmp> line 1␤␤»

[14:51] <BrokenRobot> And I guess here it magically makes a block?

[14:52] <BrokenRobot> ETOOMAGICAL

[14:52] *** freezerburnV joined
[14:52] <masak> a thunk, not a block

[14:54] <BrokenRobot> "Your search - site:docs.perl6.org thunk - did not match any documents. " :(

[14:55] * perlpilot gets the feeling that we'll eventually settle on being more explicit about the timing of certain things because otherwise you get "ETOOMAGICAL"

[14:55] <perlpilot> BrokenRobot: https://en.wikipedia.org/wiki/Thunk

[14:56] <BrokenRobot> That's actually a word :o

[14:57] <CIAvash> "A thunk is a piece of code that may not execute immediately, ..." https://design.perl6.org/S06.html#Subroutines_and_other_code_objects

[14:58] <BrokenRobot> Well, yeah, that's what I found annoying in Perl 5. You pop open a doc and there's a gazillion pages explaining all of the special cases.

[14:58] <BrokenRobot> Same reason I hate Russian. Every rule has exceptions :)

[14:58] <mst> that's why english is so awesome, we don't really have rules in the first place

[14:59] <mst> you just sort of have to figure it out

[14:59] <BrokenRobot> Yeah :)

[14:59] *** [particle] left
[15:00] <perlpilot> And just when you think you have a handle on "the rules"  ... we make up new ones on the spot and start using them.

[15:02] <harmil> pmurias: I'll be around.

[15:02] <hoelzro> english is weakly typed ;)

[15:02] <mst> english is hopper.jpg typed

[15:03] <harmil> perlpilot: keep in mind that English is as much about hiding information as revealing and illuminating it.

[15:04] <harmil> All natural languages are quickly repurposed to creating hidden channels available only to specific subcultures. It's what we apes do.

[15:05] <perlpilot> harmil: Sure.  And while it's fun to do that consciously, it often happens "en passant" without anyone realizing until afterwards.

[15:06] *** TimToady joined
[15:06] <dalek> doc: ecad048 | (Wenzel P. P. Peppmeyer)++ | doc/Language/typesystem.pod:

[15:06] <dalek> doc: doc :$.attr shortcut in constructor calls

[15:06] <dalek> doc: review: https://github.com/perl6/doc/commit/ecad04820b

[15:07] <perlpilot> huh ... I thought that was already documented, but perhaps I'm still thinking of the synopses as documentation

[15:07] *** Actualeyes left
[15:07] *** [particle] joined
[15:08] <gfldex> perlpilot: a full text search of :$. did not bear fruit

[15:08] <gfldex> Pod::To::BigPage++ :)

[15:09] *** Actualeyes joined
[15:10] *** kyclark joined
[15:12] *** kyclark left
[15:13] *** lichtkind joined
[15:14] *** sdo joined
[15:15] *** sdo left
[15:16] *** ZoffixMobile joined
[15:18] *** freezerburnV left
[15:19] <ZoffixMobile> gfldex, that'll work with $!foo too. And based on what $.foo actually is, I'm guessing it'd work for any method, not just an attribute.

[15:19] * ZoffixMobile wonders about :&foo

[15:19] <gfldex> ZoffixMobile: you know where typesystem.pod is, right? :->

[15:20] <ZoffixMobile> m: sub foo { 'bar' }; my %h = :&foo; say %h

[15:20] <camelia> rakudo-moar 5a4963: OUTPUT«{foo => sub foo () { #`(Sub|63921304) ... }}␤»

[15:20] <ZoffixMobile> gfldex, fair enough :) If I don't forget, I'll doc it :)

[15:21] <ZoffixMobile> m: sub foo { 'bar' }; my %h = :&foo(); say %h

[15:21] <camelia> rakudo-moar 5a4963: OUTPUT«No such method 'CALL-ME' for invocant of type 'Pair'␤  in block <unit> at <tmp> line 1␤␤»

[15:21] <masak> m: my %h = :&say; say %h.perl

[15:21] <camelia> rakudo-moar 5a4963: OUTPUT«{:say(sub say (| is raw) { #`(Sub|48386440) ... })}␤»

[15:23] *** ZoffixMobile left
[15:26] * gfldex .oO( syntaxy-things.pod )

[15:28] *** kurahaupo joined
[15:30] *** _mg_ joined
[15:30] *** [particle] left
[15:31] *** Sgeo_ joined
[15:32] *** freezerburnV joined
[15:32] *** Actualeyes left
[15:34] *** kyclark joined
[15:34] *** Actualeyes joined
[15:36] <kyclark> Can someone help me understand this? http://pastie.org/10893089

[15:37] <gfldex> kyclark: try &even

[15:37] <perlpilot> m: sub even ($x) { $x %% 2 }; say grep &even, [1..4];

[15:37] <camelia> rakudo-moar 5a4963: OUTPUT«(2 4)␤»

[15:37] <kyclark> Ooo, that works!

[15:37] <perlpilot> kyclark: even and even() are calls,  &even is just a mention, which is what grep, map, etc. need

[15:38] <gfldex> m: my $even = -> $x { $x %% 2 }; say grep $even, [1..4];

[15:38] <camelia> rakudo-moar 5a4963: OUTPUT«(2 4)␤»

[15:38] <gfldex> m: my \even = -> $x { $x %% 2 }; say grep even, [1..4];

[15:38] <camelia> rakudo-moar 5a4963: OUTPUT«(2 4)␤»

[15:38] <gfldex> nope :)

[15:39] *** huggable left
[15:40] *** huggable joined
[15:40] <gfldex> m: constant even = -> $x { $x %% 2 }; say grep even, [1..4];

[15:40] <camelia> rakudo-moar 5a4963: OUTPUT«(2 4)␤»

[15:41] <perlpilot> kyclark: Take everything I said in the context of the code you provided.  (since gfldex is being ornery :)

[15:43] <gregf_> m: sub even ($x) { $x %% 2 }; say [1..4].grep(&even), grep &even, [1..4] # prefers the former :|

[15:43] <camelia> rakudo-moar 5a4963: OUTPUT«(2 4)(2 4)␤»

[15:43] *** tharkun left
[15:46] <gregf_> m: class MyInt is Int { method even(){ self %% 2 } }; say [1..4].map({ MyInt.new($_) }).grep({.even})

[15:46] <camelia> rakudo-moar 5a4963: OUTPUT«(2 4)␤»

[15:54] *** abraxxa left
[15:56] <BrokenRobot> m: use MONKEY-TYPING; augment class Array { method evens { self.grep: * %% 2 } }; [1..10].evens.say

[15:56] <camelia> rakudo-moar 5a4963: OUTPUT«(2 4 6 8 10)␤»

[15:58] <kyclark> How can I declare a MAIN sub that will work if given any number of arguments (e.g., 0 or more)?

[15:58] <BrokenRobot> m: ([2..10] but role { method evens { self.grep: * %% 2 } }).evens.say

[15:58] <camelia> rakudo-moar 5a4963: OUTPUT«(2 4 6 8 10)␤»

[15:58] <BrokenRobot> tehe

[15:58] <pmichaud> good morning, #perl6

[15:58] <BrokenRobot> kyclark: make it slurpy:   sub MAIN (*@args) { ... }

[15:59] <gfldex> kyclark: sub MAIN(*@many){}

[15:59] <BrokenRobot> kyclark: make it slurpy:   sub MAIN (*@args, *%named-args) { ... } # if you want to capture --named=args too

[15:59] *** mohae left
[15:59] <BrokenRobot> pmichaud: \o

[15:59] <BrokenRobot> WeeChat-- # automatically changing \o to \o\ for no good reason

[16:00] <pmichaud> it looks like "\o" to me.

[16:01] *** ssotka joined
[16:01] <BrokenRobot> m: &say.wrap: { put @_.grep: * %% 2 }; [2..10].say

[16:01] <camelia> rakudo-moar 5a4963: OUTPUT«2 4 6 8 10␤»

[16:01] <BrokenRobot> pmichaud: yeah, I had to delete the extra "\" :)

[16:02] *** yqt joined
[16:02] <kyclark> Can you tell what I'm trying to do with this? How can I make it work?  ['a'..'z'].classify( /[aeiou]/ )

[16:03] <BrokenRobot> m: ["a".."z"].classify( /[aeiou]/ ).say

[16:03] <camelia> rakudo-moar 5a4963: OUTPUT«Method '!cursor_start' not found for invocant of class 'Str'␤  in block <unit> at <tmp> line 1␤␤»

[16:03] <BrokenRobot> neat...

[16:04] <BrokenRobot> m: ["a".."z"].classify( { /[aeiou]/ ?? 'vowels' !! 'consonants' ).say

[16:04] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3{ /[aeiou]/ ?? 'vowels' !! 'consonants' 7⏏5).say␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loop␤»

[16:05] <BrokenRobot> Ah, wrong regex

[16:05] <BrokenRobot> m: ["a".."z"].classify( { /<[aeiou]>/ ?? "vowels" !! "consonants" }).say

[16:05] <camelia> rakudo-moar 5a4963: OUTPUT«{consonants => [b c d f g h j k l m n p q r s t v w x y z], vowels => [a e i o u]}␤»

[16:05] <BrokenRobot> m: &classify.signature.say

[16:05] <camelia> rakudo-moar 5a4963: OUTPUT«($test, + is raw, *%named)␤»

[16:06] <BrokenRobot> Dunno aout the !cursor error

[16:06] <BrokenRobot> m: ["a".."z"].classify(rx/<[aeiou]>/).say

[16:06] <camelia> rakudo-moar 5a4963: OUTPUT«Method '!cursor_start' not found for invocant of class 'Str'␤  in block <unit> at <tmp> line 1␤␤»

[16:07] <BrokenRobot> I guess it can only take Code

[16:07] <gfldex> m: my %h = ['a'..'z'].classify( { $^a ~~ <a e i o u>.any ?? "v" !! "c" } ); dd %h

[16:07] <camelia> rakudo-moar 5a4963: OUTPUT«Hash %h = {:c($["b", "c", "d", "f", "g", "h", "j", "k", "l", "m", "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z"]), :v($["a", "e", "i", "o", "u"])}␤»

[16:09] <kyclark> What about this (doesn't work)?  [1..10].classify({$_ %% s ?? 'even' !! 'odd'})

[16:09] <BrokenRobot> m: ["a".."z"].classify(* eq <a e i o u>.any).say

[16:09] <camelia> rakudo-moar 5a4963: OUTPUT«P6opaque: no such attribute '$!reified' in type List when trying to get a value␤  in block <unit> at <tmp> line 1␤␤»

[16:09] <BrokenRobot> Damn. classify sure loves to spill the guts

[16:09] <BrokenRobot> kyclark: what's "s"?

[16:09] <kyclark> Oh, that might explain it.

[16:10] <kyclark> m: [1..10].classify({$_ %% 2 ?? 'even' !! 'odd'})

[16:10] <camelia> rakudo-moar 5a4963: ( no output )

[16:10] <BrokenRobot> m: [1..10].classify({$_ %% s ?? 'even' !! 'odd'})

[16:10] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5===␤Null regex not allowed␤at <tmp>:1␤------> 3[1..10].classify({$_ %% s ?7⏏5? 'even' !! 'odd'})␤Malformed replacement part; couldn't find final ?␤at <tmp>:1␤------> 3].classify({$_ %% s ?? 'even' !! 'odd'})7⏏5<EOL>…»

[16:10] <kyclark> m: [1..10].classify({$_ %% 2 ?? 'even' !! 'odd'}).say

[16:10] <camelia> rakudo-moar 5a4963: OUTPUT«{even => [2 4 6 8 10], odd => [1 3 5 7 9]}␤»

[16:10] <kyclark> woo-hoo!

[16:10] <BrokenRobot> m: 'foo' ~~ s ?oo?ar?

[16:10] <camelia> rakudo-moar 5a4963: OUTPUT«Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»

[16:10] <BrokenRobot> m: my $x = 'foo'; $x ~~ s ?oo?ar?; say $x

[16:10] <camelia> rakudo-moar 5a4963: OUTPUT«far␤»

[16:11] <BrokenRobot> ^ that's why the error was bad.

[16:11] <BrokenRobot> m: [1..10].classify(* %% 2).say

[16:11] <camelia> rakudo-moar 5a4963: OUTPUT«{False => [1 3 5 7 9], True => [2 4 6 8 10]}␤»

[16:11] <hoelzro> resuming my supply inquiry from earlier - Channel.Supply creates a live supply, right?

[16:12] <kyclark> BrokenRobot, that is so...bad ass.

[16:12] <BrokenRobot> m: [1..10].classify(* %% 2).grep(*.key)[0].value.flat.say

[16:12] <camelia> rakudo-moar 5a4963: OUTPUT«(2 4 6 8 10)␤»

[16:13] <BrokenRobot> kyclark: it's basically equivalent to { $_ %% 2 }

[16:13] <BrokenRobot> WhateverCode

[16:13] <kyclark> This was where I was trying to get:

[16:13] <kyclark> m: for @args.classify(* %% 2).values -> @n { say join(' + ', @n), ' = ', [+] @n; }

[16:13] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '@args' is not declared␤at <tmp>:1␤------> 3for 7⏏5@args.classify(* %% 2).values -> @n { sa␤»

[16:13] <kyclark> Oh, right, that won't work outside my script.

[16:13] <BrokenRobot> :)

[16:13] <kyclark> m: for [1..10].classify(* %% 2).values -> @n { say join(' + ', @n), ' = ', [+] @n; }

[16:13] <camelia> rakudo-moar 5a4963: OUTPUT«2 + 4 + 6 + 8 + 10 = 30␤1 + 3 + 5 + 7 + 9 = 25␤»

[16:13] <gfldex> m: dd [1..10].classify(* %% 2)

[16:13] <camelia> rakudo-moar 5a4963: OUTPUT«(my Any %{Any} = Bool::False => $[1, 3, 5, 7, 9], Bool::True => $[2, 4, 6, 8, 10])␤»

[16:14] <BrokenRobot> FWIW, camelia can take a URL to a gist

[16:14] <BrokenRobot> m: https://gist.github.com/zoffixznet/9e03fc419ce66ff6cc782aed2c1ebfd3

[16:14] <camelia> rakudo-moar 5a4963: OUTPUT«{False => [1 3 5 7 9], True => [2 4 6 8 10]}␤»

[16:14] <kyclark> Mind. Blown.

[16:14] <BrokenRobot> :D

[16:14] <BrokenRobot> That's what we do... :)

[16:14] <gfldex> m: dd [1..10].classify(* %% 2){True}

[16:14] <camelia> rakudo-moar 5a4963: OUTPUT«Array <element> = $[2, 4, 6, 8, 10]␤»

[16:15] <BrokenRobot> gfldex: neat!

[16:15] *** _mg_ left
[16:15] <jnthn> hoelzro: That's a little more interesting. In the sense that if you tap, then close, then tap again you might miss values in the middle, then yes. But if multiple things tap then they're effectively competing over the values.

[16:16] <jnthn> hoelzro: That is so you can for ^4 { react { whenever $channel -> $value { } } } to have 4 workers that will compete for work from the channel.

[16:16] <jnthn> hoelzro: oops, start react ... :)

[16:16] <hoelzro> yikes

[16:16] <kyclark> gfldex, can you explain that last {True} bit?

[16:16] <BrokenRobot> kyclark: it's a hash key lookup

[16:17] <BrokenRobot> well, Map?

[16:17] <kyclark> Oh, yes.

[16:17] <jnthn> hoelzro: Which is actually rather fitting with channels in general, if you think about it, 'cus you can only receive a value once.

[16:17] <BrokenRobot> m: my Map $x = True => 'blah'; say $x{True}

[16:17] <camelia> rakudo-moar 5a4963: OUTPUT«Type check failed in assignment to $x; expected Map but got Pair (:True("blah"))␤  in block <unit> at <tmp> line 1␤␤»

[16:17] <hoelzro> ok, thanks jnthn; I've been looking into a lockup in integration/advent2013-day14.t, and I think the problem is in the impl of Channel.Supply

[16:17] <hoelzro> mhmm, that makes sense

[16:17] <BrokenRobot> m: my $x = Map.new: True => "blah"; say $x{True}

[16:17] <camelia> rakudo-moar 5a4963: OUTPUT«Nil␤»

[16:17] <jnthn> hoelzro: If you want a live supply from a channel, then obtain the supply precisely once and than .publish to get a live supply that many things can tap

[16:17] <gfldex> kyclark: that's why I use dd to print the values. It also provides type information.

[16:17] * BrokenRobot cues in of a dog in front of the computer

[16:18] <jnthn> hoelzro: Which is how you go from on-demand to live in general, fwiw :)

[16:18] <hoelzro> ah =)

[16:18] <BrokenRobot> m: my %h = True => "blah"; say %h{True}

[16:18] <camelia> rakudo-moar 5a4963: OUTPUT«blah␤»

[16:18] <BrokenRobot> :S

[16:18] <BrokenRobot> m: my %h = True => "blah"; say %h<True>

[16:18] <camelia> rakudo-moar 5a4963: OUTPUT«blah␤»

[16:18] <BrokenRobot> What sorcery is this....

[16:19] <BrokenRobot> m: True.Str.say

[16:19] <camelia> rakudo-moar 5a4963: OUTPUT«True␤»

[16:19] <BrokenRobot> Ahh

[16:19] <jnthn> BrokenRobot: Hashes have string keys and...that :)

[16:19] <BrokenRobot> :)

[16:20] <kyclark> I help teach Perl 5 to a metagenomics class, so I'm going through all my old assignments and trying to write them in Perl 6.  It is simply amazing.

[16:20] <BrokenRobot> \o/

[16:23] <kyclark> Explain to me why both of these do what I want: 

[16:23] <kyclark> m: ['z'...'a'].sort.say

[16:23] <camelia> rakudo-moar 5a4963: OUTPUT«(a b c d e f g h i j k l m n o p q r s t u v w x y z)␤»

[16:23] <kyclark> m: [10...1].sort.say

[16:23] <camelia> rakudo-moar 5a4963: OUTPUT«(1 2 3 4 5 6 7 8 9 10)␤»

[16:23] <kyclark> How does it know to sort numerically?

[16:23] <psch> m: say &infix:<cmp>.signature

[16:23] <camelia> rakudo-moar 5a4963: OUTPUT«(Mu, Mu)␤»

[16:24] <psch> m: say &infix:<cmp>.candidates.signature

[16:24] <camelia> rakudo-moar 5a4963: OUTPUT«Method 'signature' not found for invocant of class 'List'␤  in block <unit> at <tmp> line 1␤␤»

[16:24] <psch> m: say &infix:<cmp>.candidates>>.signature

[16:24] <camelia> rakudo-moar 5a4963: OUTPUT«((\a, \b) (Real:D \a, \b) (\a, Real:D \b) (Real:D \a, Real:D \b) (Int:D \a, Int:D \b) (int $a, int $b) (Num:D \a, Num:D \b) (num $a, num $b) (Blob:D \a, Blob:D \b) (Str:D \a, Str:D \b --> Order:D) (str $a, str $b --> Order:D) (Range:D \a, Range:D \b --> Or…»

[16:24] <BrokenRobot> kyclark: Perl 6 has types basically :)

[16:24] <BrokenRobot> m: 'z'.^name.say; 10.^name.say

[16:24] <camelia> rakudo-moar 5a4963: OUTPUT«Str␤Int␤»

[16:24] <psch> m: say &infix:<cmp>.candidates[4,9]>>.signature

[16:24] <camelia> rakudo-moar 5a4963: OUTPUT«((Int:D \a, Int:D \b) (Str:D \a, Str:D \b --> Order:D))␤»

[16:24] <psch> that's the two important ones here i'd say

[16:24] <BrokenRobot> So if you give cmp two Ints it'll sort numerically

[16:25] <psch> m: say 1 cmp 2; say "a" cmp "b"

[16:25] <camelia> rakudo-moar 5a4963: OUTPUT«Less␤Less␤»

[16:25] <psch> and sort uses cmp by default

[16:25] <kyclark> Yes yes yes!

[16:25] <BrokenRobot> :)

[16:26] <psch> m: say ^10 .sort: { $^a cmp $^b * (-1 * $++ %% 2) } # /o\

[16:26] <camelia> rakudo-moar 5a4963: OUTPUT«(0 7 8 1 9 4 3 6 2 5)␤»

[16:26] <kyclark> If my students read in a bunch of numbers from a text file, though, will this break?

[16:26] <psch> m: say <1>.WHAT

[16:26] <camelia> rakudo-moar 5a4963: OUTPUT«(IntStr)␤»

[16:27] *** dogbert17 joined
[16:27] <pmichaud> jnthn:  /o

[16:27] <pmichaud> er

[16:27] <pmichaud> jnthn:  o/

[16:27] <jnthn> Hi, pmichaud o/

[16:27] <psch> hm, actually i think we don't get allomorphs from IO, do we?

[16:27] <jnthn> pmichaud: Have fun at YAPC? :)

[16:27] <pmichaud> jnthn: Yes, very much so.

[16:27] *** dakkar left
[16:27] <pmichaud> jnthn: looking forward to the next event, whenever it might be. 

[16:27] * perigrin did see pmichaud in the corner of his talk

[16:27] <psch> m: say <1 11 12 20>.sort

[16:27] <camelia> rakudo-moar 5a4963: OUTPUT«(1 11 12 20)␤»

[16:27] <BrokenRobot> kyclark: you'd have to coerce them to Ints or some such

[16:27] <psch> err, that didn't actually help

[16:27] <perigrin> sadly I didn't have much more time to say hi.

[16:28] <kyclark> m: <10 9 1 foo 4>.sort.say

[16:28] <psch> m: say <1 2 11 12 20>.sort

[16:28] <camelia> rakudo-moar 5a4963: OUTPUT«(1 4 9 10 foo)␤»

[16:28] <camelia> rakudo-moar 5a4963: OUTPUT«(1 2 11 12 20)␤»

[16:28] <psch> m: say <1 2 11 12 20>>>.Str.sort

[16:28] <camelia> rakudo-moar 5a4963: OUTPUT«(1 11 12 2 20)␤»

[16:28] <psch> kyclark: looks like "if it uniformly looks like it's Int-y, do it Int-y"

[16:28] <pmichaud> perigrin: yes, that was an enjoyable talk.

[16:29] <perigrin> thank you :)

[16:29] <jnthn> pmichaud: Cool...well, probably not literally cool if it was in Florida, but... :)

[16:29] <BrokenRobot> m: multi pass (Int $x) { say "Int" }; multi pass (Str $x) { say "Str" }; pass val(2, "2")

[16:29] <camelia> rakudo-moar 5a4963: OUTPUT«Value of type Int uselessly passed to val()  in block <unit> at <tmp> line 1␤Cannot resolve caller pass(List); none of these signatures match:␤    (Int $x)␤    (Str $x)␤  in block <unit> at <tmp> line 1␤␤»

[16:29] <kyclark> psch, what did you do there with the >>>?

[16:29] <BrokenRobot> grr

[16:29] <pmichaud> Actually Florida wasn't too bad, temperature wise.  It's hotter here in Dallas right now.

[16:29] * jnthn is finding the Prague summer more than warm enough

[16:29] <psch> kyclark: >> is a hyper method op

[16:29] <perigrin> jnthn: actually the AC here is quite strong, the hotel was a little chilly.

[16:29] <jnthn> perigrin: heh, I'd probably have loved that :)

[16:29] <BrokenRobot> kyclark: calls the given method on each item of the list

[16:29] <psch> kyclark: it calls the method on the RHS on all elements of the list on the LHS (potentially out of sequence, but returns in order)

[16:29] * jnthn is a winter kind of person :)

[16:29] *** dakkar joined
[16:30] <pmichaud> and yes, the hotel had the typical American AC-freezing-interior-in-the-summer thing going on.  :)

[16:30] * perigrin is a summer kind of person, but slightly less summer than Florida in June/July/August typically.

[16:30] *** stevieb9 left
[16:30] <psch> kyclark: it's kind of like .map({$_.$method}), except that it doesn't guarantee in-order execution, only ordered return

[16:30] *** jack_rabbit left
[16:32] <kyclark> You keep stressing the out-of-order possibility, is it because it's possible to parallelize the operation?

[16:32] <psch> exactly.  i'm not sure we do that yet though

[16:33] *** kalkin-_ is now known as kalkin-

[16:33] <kyclark> OK, so what about something like this?

[16:33] <kyclark> m: [1..10] >> { $_ * 2 }.say

[16:33] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of >> to do right shift; in Perl 6 please use +> or ~>␤at <tmp>:1␤------> 3[1..10] >>7⏏5 { $_ * 2 }.say␤»

[16:34] <psch> kyclark: the single >> is a methodop, not an infix

[16:34] <kyclark> I think I've actually asked this here before, but I forget

[16:34] *** dakkar left
[16:34] <psch> m: [1..10]>>.&({ $_ * 2 }).say

[16:34] <camelia> rakudo-moar 5a4963: OUTPUT«[2 4 6 8 10 12 14 16 18 20]␤»

[16:34] <pyrimidine> kyclark: glad to see you back!

[16:35] <kyclark> Thanks, pyrimidine.

[16:35] <kyclark> This is easier, no?

[16:35] <kyclark> m: [1..10].map: * * 2.say

[16:35] <camelia> rakudo-moar 5a4963: OUTPUT«2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤»

[16:35] <kyclark> Oh, hrm.

[16:35] <kyclark> m: [1..10].map: * * 2

[16:35] <camelia> rakudo-moar 5a4963: ( no output )

[16:35] <tbrowder> Zoffix (or anyone): consider this gist <https://gist.github.com/tbrowder/b71479ca1447a957e0664ebbbdba02b2>, is my version of a proper parse for the pod 6 table test correct?

[16:35] <pyrimidine> m: 2.say

[16:35] <camelia> rakudo-moar 5a4963: OUTPUT«2␤»

[16:35] <psch> m: say map 1..10: * * 2 :

[16:35] <kyclark> I get the right answer in my REPL

[16:35] <camelia> rakudo-moar 5a4963: OUTPUT«(2 4 6 8 10 12 14 16 18 20)␤»

[16:36] <kyclark> Yes, that's it.

[16:36] <psch> kyclark: TIMTOWTDI :)

[16:36] <hoelzro> jnthn: does emit() (as in the one that goes in supply { ... }) cause a control exception?

[16:37] <kyclark> BTW, this blows up my REPL:

[16:37] <kyclark> m: [1..10].map: * ** 2.WHAT

[16:37] <camelia> rakudo-moar 5a4963: OUTPUT«Invocant requires an instance of type Int, but a type object was passed.  Did you forget a .new?␤  in block <unit> at <tmp> line 1␤␤»

[16:37] <kyclark> I wanted to do something like this:

[16:37] <kyclark> m: [1..10].map: * ** 2.grep: * < 50

[16:37] <camelia> rakudo-moar 5a4963: ( no output )

[16:38] <psch> m: [1..10].map: * ** (2.grep: * < 50)

[16:38] <camelia> rakudo-moar 5a4963: ( no output )

[16:38] <psch> that's how it parses

[16:38] <kyclark> this works:

[16:38] <kyclark> m: [1..10].grep: * < 5

[16:38] <camelia> rakudo-moar 5a4963: ( no output )

[16:38] <kyclark> m: say [1..10].grep: * < 5

[16:38] <camelia> rakudo-moar 5a4963: OUTPUT«(1 2 3 4)␤»

[16:38] *** [particle] joined
[16:38] <jnthn> hoelzro: Yes

[16:38] <jnthn> hoelzro: done also

[16:39] <kyclark> This works:

[16:39] <kyclark> m: say grep * < 50, [1..10].map: * ** 2

[16:39] <camelia> rakudo-moar 5a4963: OUTPUT«(1 4 9 16 25 36 49)␤»

[16:39] <hoelzro> ok, that may explain why the fix I tried last night didn't work =/

[16:40] <kyclark> And this works:

[16:40] <kyclark> m: say grep * < 50, map * ** 2, [1..10]

[16:40] <camelia> rakudo-moar 5a4963: OUTPUT«(1 4 9 16 25 36 49)␤»

[16:40] <BrokenRobot> m: say grep * < 50, [1..10].map: *²

[16:40] <camelia> rakudo-moar 5a4963: OUTPUT«Cannot resolve caller Numeric(Whatever: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[16:40] <kyclark> I'm intrigued by this idea I think I saw in a talk by Damien:

[16:40] <kyclark> m: say [1..10] ==> * ** 2

[16:40] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Sorry, do not know how to handle this case of a feed operator yet.␤at <tmp>:1␤------> 3say [1..10] ==> * ** 27⏏5<EOL>␤»

[16:40] <BrokenRobot> awwww.. we didn't do superscripts for this case?

[16:41] *** harrison_ joined
[16:41] <psch> m: say &postfix:<²>

[16:41] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    postfix:<²> used at line 1. Did you mean 'postfix:<i>', 'postfix:<ⁿ>', 'postfix:<-->', 'postfix:<++>'?␤␤»

[16:42] <psch> BrokenRobot: i think that's kind of like why .WHAT doesn't Whatever curry

[16:42] <BrokenRobot> It's not an op, it's done in grammer

[16:42] <BrokenRobot> Ah t'bad

[16:42] <japhb> OK, now I want to know what postfix:<ⁿ> does ...

[16:43] <BrokenRobot> japhb: what'd you think? :)

[16:43] <psch> probably nothing, 'cause we don't have it? :)

[16:43] <BrokenRobot> m: say 6²

[16:43] <camelia> rakudo-moar 5a4963: OUTPUT«36␤»

[16:43] <BrokenRobot> m: say 6²²²²

[16:43] <camelia> rakudo-moar 5a4963: OUTPUT«1127400835818465130246515434079544622236496408864545313869983108525695859756300042859793699471701282603490303071099371257462530081270238260169633679684869958563124451130648728041498601762862967958374766976221542376477543005102834131170639418855873012778926…»

[16:43] <psch> m: say &postfix:<ⁿ>

[16:43] <camelia> rakudo-moar 5a4963: OUTPUT«sub postfix:<ⁿ> (Mu $, Mu $) { #`(Sub+{<anon|62317104>}|66693952) ... }␤»

[16:43] <psch> ohh

[16:43] <psch> shows what i know!

[16:43] <psch> m: say 1ⁿ

[16:43] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3say 17⏏5ⁿ␤»

[16:44] <japhb> Hmmm, looking at the grammer, it looks like it's a placeholder for the superscript notation

[16:44] <BrokenRobot> huh

[16:44] <japhb> src/core/Numeric.pm:proto sub postfix:<ⁿ>(Mu $, Mu $) is pure  { * }

[16:44] <japhb> src/core/Numeric.pm:multi sub postfix:<ⁿ>(\a, \b)  { a ** b }

[16:44] <japhb> There it is in the setting

[16:45] <BrokenRobot> It's in Numeric

[16:45] <japhb> yup

[16:45] <psch> m: say (2, 2)ⁿ

[16:45] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say (2, 2)7⏏5ⁿ␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier␤    …»

[16:45] <BrokenRobot> m: postfix<ⁿ>(2, 3).say

[16:45] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    postfix used at line 1␤␤»

[16:45] <BrokenRobot> m: &postfix<ⁿ>(2, 3).say

[16:45] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    postfix used at line 1␤␤»

[16:46] <BrokenRobot> m: postfix:<ⁿ>(2, 3).say

[16:46] <camelia> rakudo-moar 5a4963: OUTPUT«8␤»

[16:46] * BrokenRobot has no idea how to give to args to a postfix op :S

[16:46] <BrokenRobot> Well, other than the above

[16:46] <psch> BrokenRobot++

[16:47] <japhb> Yep, I was right:

[16:47] <japhb> src/Perl6/Actions.nqp:    method postfix:sym<ⁿ>($/) {

[16:47] <japhb> src/Perl6/Actions.nqp:        make QAST::Op.new(:op<call>, :name('&postfix:<ⁿ>'), $*W.add_constant('Int', 'int', $power));

[16:47] <hoelzro> jnthn: is it still the case that $lock.protect({ thing-that-causes-control-exception; }) will not unlock $lock after the control exception is fired?

[16:47] <jnthn> hoelzro: I fear we still have that issues, yes.

[16:47] <BrokenRobot> japhb: ahh

[16:48] *** harrison_ left
[16:48] <hoelzro> ok

[16:49] <BrokenRobot> This has an unfortunate consequence tho:

[16:49] <BrokenRobot> m: say ²²

[16:49] <camelia> rakudo-moar 5a4963: OUTPUT«4␤»

[16:49] <BrokenRobot> m: say ²²²

[16:49] <camelia> rakudo-moar 5a4963: OUTPUT«4194304␤»

[16:49] <BrokenRobot> (it's already rakudobugged)

[16:51] *** [particle] left
[16:53] *** kyclark left
[16:55] *** mohae joined
[16:56] *** [particle] joined
[16:58] *** BrassLantern joined
[16:58] *** BrassLantern left
[16:58] *** BrassLantern joined
[17:04] *** [particle] left
[17:04] *** kyclark joined
[17:06] *** MilkmanDan is now known as MilkmanDan[Han]

[17:09] <nine> jnthn: is the same true for return as that's also a control exception now?

[17:11] <jnthn> nine: It probably was true before if so. The *real* underlying problem is with LEAVE and some general reentrancy issues around phasers.

[17:11] <jnthn> nine: The moment that's fixed, we use LEAVE to implement protoect and we're all sorted

[17:14] *** araujo joined
[17:15] *** araujo left
[17:15] <kyclark> Where are the docs on creating new operators?

[17:16] <gfldex> kyclark: https://docs.perl6.org/language/functions#Defining_Operators

[17:19] <kyclark> Thanks.

[17:19] <kyclark> Is there a concept of "Nothing" in P6?

[17:20] <gfldex> m: dd Nil

[17:20] <camelia> rakudo-moar 5a4963: OUTPUT«Nil␤»

[17:20] <psch> m: my @a := 1, Empty, 2; say @a.perl

[17:20] <camelia> rakudo-moar 5a4963: OUTPUT«(1, 2)␤»

[17:20] * gfldex .oO( undefined-things.pod )

[17:22] *** tlvb left
[17:22] *** tlvb joined
[17:23] <kyclark> How would you rate this?

[17:23] *** fhorck joined
[17:23] <kyclark> http://pastie.org/10893185

[17:23] <kyclark> m: http://pastie.org/10893185

[17:23] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3http:7⏏5//pastie.org/10893185␤    expecting any of:␤        colon pair␤»

[17:25] *** kyclark left
[17:25] * psch ^A^Ks the half-finished response

[17:25] *** kyclark joined
[17:26] <kyclark> Sorry, I blew up my window.  So, I was asking about this: http://pastie.org/10893185

[17:26] * psch is glad about ^Y

[17:26] * [Coke] is in 21C weather right now. brisk but nice

[17:26] <[Coke]> (compared to orlando or dallas. :)

[17:26] <psch> kyclark: somewhat weird.  you are using multis to distinguish between valid values, but you're still using an if in your "main" candidate to distinguish cases that could be solved by a multi

[17:26] *** [particle] joined
[17:27] <kyclark> Can you suggest a Better Way?

[17:27] <kyclark> Dang, have to retrieve kid.  BRB.

[17:28] <psch> m: multi postfix:<!>(1) { 1 }; multi postfix:<!>(Int $x where * > 1) { $x * ($x - 1) }; multi postfix:<!>($) { Nil }; say 5!

[17:28] <camelia> rakudo-moar 5a4963: OUTPUT«20␤»

[17:28] <psch> m: multi postfix:<!>(1) { 1 }; multi postfix:<!>(Int $x where * > 1) { $x * ($x - 1) }; multi postfix:<!>($) { Nil }; say 2!

[17:28] <camelia> rakudo-moar 5a4963: OUTPUT«2␤»

[17:29] *** mohae_ joined
[17:29] <psch> m: multi postfix:<!>(1) { 1 }; multi postfix:<!>(Int $x where * > 1) { $x * ($x - 1) }; multi postfix:<!>($) { Nil }; ($_! // 'Nada').say for 5...0 # to be more faithful i suppose

[17:29] <camelia> rakudo-moar 5a4963: OUTPUT«20␤12␤6␤2␤1␤Nada␤»

[17:30] *** fhorck left
[17:31] *** mohae left
[17:36] <BrokenRobot> docs for custom operators you say? http://perl6.party/post/Anguish--Invisible-Programming-Language-and-Invisible-Data-Theft

[17:36] <BrokenRobot> XD

[17:37] *** kyclark left
[17:39] *** kyclark joined
[17:40] <BrokenRobot> psch: factorial of 0 is 1, isn't it?

[17:40] *** _mg_ joined
[17:40] <psch> BrokenRobot: i don't think kyclark was looking for factorial

[17:41] <psch> BrokenRobot: unless i missed something

[17:41] <BrokenRobot> Oh, never mind then.

[17:41] <kyclark> I was doing factorial, yes.

[17:41] <psch> http://pastie.org/10893185 no ! after the ($x - 1) :)

[17:41] <BrokenRobot> m: sub postfix:<!>{ [*] 1..$^a }; ($_! // "Nada").say for 5...-1

[17:41] <camelia> rakudo-moar 5a4963: OUTPUT«120␤24␤6␤2␤1␤1␤1␤»

[17:41] <psch> yeah, if it had been factorial that'd been my solution

[17:42] <psch> although not with placeholder but with Int >= 0

[17:42] <psch> in a formal Signature

[17:42] <BrokenRobot> m: multi postfix<!> ($ where < 0) { Nil }; multi postfix:<!>{ [*] 1..$^a }; ($_! // "Nada").say for 5...-1

[17:42] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3multi postfix7⏏5<!> ($ where < 0) { Nil }; multi postfix␤    expecting any of:␤        new name to be defined␤»

[17:42] <BrokenRobot> blarg

[17:43] <BrokenRobot> The [*] Empty being 1 is messing up the elegance lol

[17:43] <psch> http://www.wolframalpha.com/input/?i=0!

[17:43] <psch> it doesn't? :P

[17:44] <psch> that we don't have a shorthand for 0^..^* is what's messing up the elegance imo

[17:44] <BrokenRobot> Heh, well that yeah, but messes up for negatives

[17:45] *** yqt left
[17:45] <BrokenRobot> wait a second...

[17:48] *** setty1 joined
[17:50] <BrokenRobot> m: sub postfix:<!> { ({[*] 1..$++} ... *)[$^a] // Nil }; ($_! // "Nada").say for 5...-1

[17:50] <camelia> rakudo-moar 5a4963: OUTPUT«120␤24␤6␤2␤1␤1␤Nada␤»

[17:51] *** kurahaupo left
[17:51] <BrokenRobot> m: sub postfix:<!> {({[*] 1..$++}...*)[$^a]}; ($_! // "Nada").say for 5...-1 

[17:51] <camelia> rakudo-moar 5a4963: OUTPUT«120␤24␤6␤2␤1␤1␤Nada␤»

[17:51] *** kurahaupo joined
[17:51] *** kurahaupo left
[17:51] *** zakharyas left
[17:52] <BrokenRobot> .u ellipses

[17:52] <yoleaux> No characters found

[17:52] *** kurahaupo joined
[17:52] <BrokenRobot> .u ellipsis

[17:52] <yoleaux> U+0EAF LAO ELLIPSIS [Lo] (ຯ)

[17:52] <yoleaux> U+1801 MONGOLIAN ELLIPSIS [Po] (᠁)

[17:52] <yoleaux> U+2026 HORIZONTAL ELLIPSIS [Po] (…)

[17:52] <BrokenRobot> m: sub postfix:<!> {({[*] 1..$++}…*)[$^a]}; ($_! // "Nada").say for 5…-1 

[17:52] <camelia> rakudo-moar 5a4963: OUTPUT«120␤24␤6␤2␤1␤1␤Nada␤»

[17:52] <psch> i don't know if i would advocate for a factorial implementation that's O(n²) :P

[17:52] <BrokenRobot> huggable: factorial :is: m: sub postfix:<!> {({[*] 1..$++}…*)[$^a]}; ($_! // "Nada").say for 5…-1 

[17:52] <huggable> BrokenRobot, Added factorial as m: sub postfix:<!> {({[*] 1..$++}…*)[$^a]}; ($_! // "Nada").say for 5…-1 

[17:53] <BrokenRobot> psch: the answer is always MOAR COARS :D

[17:53] <psch> but that's not even parallelizable /o\

[17:53] * psch ponders a hardware implementation of moarvm

[17:54] <BrokenRobot> Oh right, I meant the answer is FASTAR COARS :D

[17:56] *** _mg_ left
[17:56] *** labster joined
[17:57] <kyclark> OK, so not to sound too Haskelly, but if Nil is basically Nothing, is there a Just (x)?

[17:57] <BrokenRobot> What's (x)?

[17:58] <kyclark> I guess there's Int (x)

[17:58] <psch> that's this weird monad stuff, isn't it?

[17:58] <kyclark> So a sum type (is that right?) where MyType = Nil | Int x

[17:58] *** FROGGS joined
[17:59] <psch> m: subset MaybeInt where Int|Nil; # i guess?

[17:59] <camelia> rakudo-moar 5a4963: ( no output )

[17:59] <kyclark> Maybe I need to think about this on my own some more.

[17:59] <BrokenRobot> kyclark: what is this for? An Int can be undefined

[17:59] <psch> i'm really not good at haskell

[17:59] <psch> also, assigning Nil into a container probably doesn't do quite do what you think

[17:59] <BrokenRobot> m: my $x; say $x:defined ?? "Nope" !! "Nap";

[17:59] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '$x:defined' is not declared. Did you mean any of these?␤    &defined␤    &undefine␤␤at <tmp>:1␤------> 3my $x; say 7⏏5$x:defined ?? "Nope" !! "Nap";␤»

[17:59] <BrokenRobot> *sigh*

[17:59] <BrokenRobot> m: my $x; say $x.defined ?? "Yup" !! "Nap";

[17:59] <camelia> rakudo-moar 5a4963: OUTPUT«Nap␤»

[18:00] <BrokenRobot> m: my $x = 5; $x = Nil; say $x; my $y; say $y;

[18:00] <camelia> rakudo-moar 5a4963: OUTPUT«(Any)␤(Any)␤»

[18:00] <psch> m: my $x is default(pi); $x = 10; $x.say; $x = Nil; $x.say

[18:00] <camelia> rakudo-moar 5a4963: OUTPUT«10␤3.14159265358979␤»

[18:04] <kyclark> http://pastie.org/10893219  I'm not sure where I'm going with this.  Thinking about pattern matching, I guess.

[18:04] <gfldex> kyclark: if you want to indicate failure use Failure see: https://docs.perl6.org/type/Failure

[18:04] <psch> fwiw, Nil only really comes up in failed matches if you're not returning it yourself

[18:05] <psch> or, well, IO too i suppose

[18:07] <gfldex> kyclark: you may want to have a look at http://rosettacode.org/wiki/Sorting_algorithms/Quicksort#Perl_6

[18:08] <gfldex> m: say [].defined;

[18:08] <camelia> rakudo-moar 5a4963: OUTPUT«True␤»

[18:08] <dalek> doc: b655f6f | coke++ | .gitignore:

[18:08] <dalek> doc: ignore generated dir

[18:08] <dalek> doc: review: https://github.com/perl6/doc/commit/b655f6f888

[18:08] <gfldex> matching on undefined values may not get you what you think it would

[18:09] <dalek> doc/coke/pod6: 0890707 | coke++ | / (574 files):

[18:09] <dalek> doc/coke/pod6: Rename .pod files to .pod6

[18:09] <dalek> doc/coke/pod6: review: https://github.com/perl6/doc/commit/0890707148

[18:15] *** rindolf joined
[18:15] <pmichaud> afk # meeting

[18:18] <kyclark> I'm flailing here, but I'm curious to do something like: my %count; <a b b c>.map: $count{*}++  (e.g., count how many times each item in a list occurs)

[18:18] <BrokenRobot> kyclark: use a set

[18:18] <psch> m: my %count = <a b b c>.Bag; say %count.perl

[18:18] <camelia> rakudo-moar 5a4963: OUTPUT«{:a(1), :b(2), :c(1)}␤»

[18:18] <BrokenRobot> or bag

[18:19] <BrokenRobot> yup :)

[18:19] <psch> set always has 1 as value

[18:19] <psch> or True, actually i think?

[18:19] <BrokenRobot> Yeah, I realized the second I said it :)

[18:19] <BrokenRobot> m: my %c = set <a b c c>; say %c

[18:19] <camelia> rakudo-moar 5a4963: OUTPUT«{a => True, b => True, c => True}␤»

[18:19] *** diakopter left
[18:20] <ilmari> m: <a b b c>.Set.perl.say

[18:20] <camelia> rakudo-moar 5a4963: OUTPUT«set("a","c","b")␤»

[18:20] <BrokenRobot> huggable: Bag

[18:20] <huggable> BrokenRobot, Immutable collection of distinct objects with integer weights: https://docs.perl6.org/type/Bag

[18:20] <BrokenRobot> huggable: BagHash

[18:20] <huggable> BrokenRobot, Mutable collection of distinct objects with integer weights: https://docs.perl6.org/type/BagHash

[18:21] <kyclark> m: bag 'ksjdferuiqfdkasdoij'.comb.grep(/<[aeiou]>/)

[18:21] <camelia> rakudo-moar 5a4963: ( no output )

[18:21] <kyclark> m: say bag 'ksjdferuiqfdkasdoij'.comb.grep(/<[aeiou]>/)

[18:21] <camelia> rakudo-moar 5a4963: OUTPUT«bag(a, i(2), e, u, o)␤»

[18:21] <kyclark> So cool, but:

[18:21] <kyclark> m: say 'ksjdferuiqfdkasdoij'.comb.grep(/<[aeiou]>/).bag

[18:21] <camelia> rakudo-moar 5a4963: OUTPUT«Method 'bag' not found for invocant of class 'Seq'␤  in block <unit> at <tmp> line 1␤␤»

[18:21] <BrokenRobot> m: "foobarber".comb.Bag.hash.say

[18:21] <camelia> rakudo-moar 5a4963: OUTPUT«{a => 1, b => 2, e => 1, f => 1, o => 2, r => 2}␤»

[18:21] <BrokenRobot> m: say 'ksjdferuiqfdkasdoij'.comb.grep(/<[aeiou]>/).list.bag

[18:21] <camelia> rakudo-moar 5a4963: OUTPUT«Method 'bag' not found for invocant of class 'List'␤  in block <unit> at <tmp> line 1␤␤»

[18:21] <kyclark> That's exactly what I wanted

[18:21] <BrokenRobot> orly

[18:22] <BrokenRobot> Oh, capital Bag

[18:22] <BrokenRobot> m: say 'ksjdferuiqfdkasdoij'.comb.grep(/<[aeiou]>/).Bag

[18:22] <camelia> rakudo-moar 5a4963: OUTPUT«bag(a, i(2), e, u, o)␤»

[18:22] <kyclark> How can I know when to use Capital or not?

[18:22] <kyclark> Oddly, ".hash" and ".Hash" both work.

[18:22] *** mcmillhj joined
[18:22] <psch> if it's a method named after a type it's probably capitalized

[18:22] <BrokenRobot> kyclark: it's pretty much always capital. I think the're just a few cases where lowercase variants are available

[18:22] <BrokenRobot> And I think capitals always will work

[18:23] <kyclark> Good to know.  Also, ".list" and ".List" are both good

[18:23] <BrokenRobot> .list and .hash are the only two I know OTTOMH

[18:23] <perlpilot> I think .item .hash and .list are the only lower-case variants.

[18:24] <perlpilot> (but I guess there's no Item type so ... what BrokenRobot said :)

[18:24] <hobbs> m: multi foo (Any:U) { say "undefined." }; multi foo (Any:D) { say "defined." }; foo(Any()); my Int $x; foo($x); $x = 42; foo($x)

[18:24] <camelia> rakudo-moar 5a4963: OUTPUT«undefined.␤undefined.␤defined.␤»

[18:24] <hobbs> kyclark: maybe that enlightens you a little on your pattern matching question?

[18:25] <BrokenRobot> hobbs++

[18:25] <kyclark> Wow, gonna take me a bit to soak that in.

[18:25] <kyclark> So it's like "Type:Adjective"?

[18:26] <kyclark> What other ways can that be used?  MOAR EXAMPLES.

[18:26] <BrokenRobot> kyclark: :D :U and :_ (which means either of the first two)

[18:26] <BrokenRobot> They're called Smileys or something

[18:26] <perlpilot> m: sub foo(Int:X) { }

[18:26] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Invalid type smiley 'X' used in type name␤at <tmp>:1␤------> 3sub foo(Int:X7⏏5) { }␤»

[18:27] <hobbs> right, Int contains the potential to be defined or undefined, but Int:D and Int:U restrict to one or the other

[18:27] <hobbs> :D gets more mileage, as you might expect

[18:27] <perlpilot> Though, given the limited number of type smileys, you'd think this would be one of those instances where it could given you some suggestions 

[18:28] <BrokenRobot> That's why it's so happy :)

[18:28] <BrokenRobot> Yeah

[18:28] <BrokenRobot> m: class Foo:version<> {}

[18:28] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5===␤Cannot use adverb version on a type name (only 'ver' and 'auth' are understood)␤at <tmp>:1␤------> 3class Foo:version<>7⏏5 {}␤    expecting any of:␤        generic role␤Other potential difficulties:␤    Pair with <> r…»

[18:28] <BrokenRobot> ^ as in here

[18:34] *** acrussell joined
[18:37] *** daxim left
[18:39] * BrokenRobot just got a raise

[18:39] <BrokenRobot> \o/

[18:39] <kyclark> Does Perl6 have __DATA__?

[18:40] <BrokenRobot> kyclark: don't think so, though I don't know much Perl 6

[18:40] <kyclark> Well, I guess I could try it first.

[18:40] <BrokenRobot> kyclark: oh, I think you could make it with Pod tho

[18:40] <kyclark> Sounds legit.

[18:40] <BrokenRobot> 'cause all the pod is now a proper object and stuff

[18:40] <DrForr_> =finish might be something to look for.

[18:40] <kyclark> OK, so this is just sick:  $file.IO.lines ==> grep * !~~ /^\>/ ==> my @lines;

[18:40] <perlpilot> kyclark: it's =begin data now (it that's implemented)

[18:40] *** daxim joined
[18:40] <kyclark> THAT WORKS!

[18:41] <BrokenRobot> sweet

[18:41] <kyclark> So the next step is I want to "comb" the lines and shove them into a Bag

[18:41] <perlpilot> kyclark: also, here-docs can be as useful as data section

[18:41] <DrForr_> Oh, yeah, =finish is the __END__ equivalent.

[18:41] <kyclark> Something like: $file.IO.lines ==> grep * !~~ /^\>/ ==> map: .comb ==> my Bag %count;

[18:41] <BrokenRobot> do it :D

[18:42] <BrokenRobot> I need to learn the feeds :/  Damian was showing them yesteday and they looked totally mind blowing.

[18:42] <kyclark> It says "Confused"

[18:42] <moritz> feeds are mostly not really implemented

[18:43] <BrokenRobot> moritz: that's too bad

[18:43] <DrForr_> ==> and <== were working somewhat in the demos he was doing at YAPC.

[18:44] <BrokenRobot> I hope when they *are* implemented, there'll be a nice Unicode char for them :) ==> is too many chars

[18:44] <DrForr_> There are plenty of arrows around :)

[18:45] <BrokenRobot> There are plenty of stars too, but we still don't have non-Texas WhateverStar :)

[18:45] <moritz> iirc feeds are supposed to be a potentially concurrent feature

[18:45] <BrokenRobot> Yeah

[18:45] *** pmurias joined
[18:47] <BrokenRobot> m: sub term:<★> { * }; say ^10 .grep: ★ %% 2

[18:47] <camelia> rakudo-moar 5a4963: OUTPUT«Cannot resolve caller Real(Whatever: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[18:47] <BrokenRobot> Well, that was too much to hope for, eh

[18:49] <moritz> somehow I've never internalized HyperWhatever and/or found a good use case for it

[18:49] *** brrt joined
[18:50] <perlpilot> moritz: you and me both

[18:50] <BrokenRobot> me too

[18:50] <kyclark> Can you merge Bags?

[18:51] <kyclark> Combine them?

[18:51] <timotimo> sure

[18:51] <timotimo> with (+) should work

[18:51] <BrokenRobot> m: my $bag1 = <a b c>.Bag; my $bag2 = <z y x>.Bag; say $bag1 (+) $bag2

[18:51] <camelia> rakudo-moar 5a4963: OUTPUT«bag(a, c, b, x, y, z)␤»

[18:51] * moritz would have expected .push, much like Hash.push

[18:51] <BrokenRobot> m: my $bag1 = <a b c>.Bag; my $bag2 = <z y x>.Bag; say $bag1 ⊎ $bag2

[18:51] <camelia> rakudo-moar 5a4963: OUTPUT«bag(a, c, b, x, y, z)␤»

[18:52] <moritz> oh wait, is Bag a value type?

[18:52] <BrokenRobot> m: my $bag1 = <a b c>.Bag; my $bag2 = <z y x>.Bag; say $bag1.puhs: $bag2

[18:52] <camelia> rakudo-moar 5a4963: OUTPUT«Method 'puhs' not found for invocant of class 'Bag'␤  in block <unit> at <tmp> line 1␤␤»

[18:52] <BrokenRobot> m: my $bag1 = <a b c>.Bag; my $bag2 = <z y x>.Bag; say $bag1.push: $bag2

[18:52] <camelia> rakudo-moar 5a4963: OUTPUT«Cannot resolve caller push(Bag: Bag); none of these signatures match:␤    (Any:U \SELF: |values is raw)␤  in block <unit> at <tmp> line 1␤␤»

[18:52] <moritz> m: my $bag1 = <a b c>.Bag; my $bag2 = <z a b>; say $bag1 (+) $bag2

[18:52] <camelia> rakudo-moar 5a4963: OUTPUT«bag(a(2), c, b(2), z)␤»

[18:52] <perlpilot> Bags are immutable

[18:52] <moritz> ok

[18:52] <TimToady> BagHash is mutable

[18:52] <moritz> then the operator is more sensible

[18:53] <BrokenRobot> m: my $bag1 = <a b c>.BagHash; my $bag2 = <z y x>.BagHash; say $bag1.push: $bag2

[18:53] <camelia> rakudo-moar 5a4963: OUTPUT«Cannot resolve caller push(BagHash: BagHash); none of these signatures match:␤    (Any:U \SELF: |values is raw)␤  in block <unit> at <tmp> line 1␤␤»

[18:53] <TimToady> m: my $bag1 = <a b c>.BagHash; $bag1<b>++; say $bag1

[18:53] <camelia> rakudo-moar 5a4963: OUTPUT«BagHash.new(a, c, b(2))␤»

[18:54] *** BrassLantern left
[18:56] <BrokenRobot> m: my $bag1 = <a b c>.BagHash; $bag1<b c>++; say $bag1

[18:56] <camelia> rakudo-moar 5a4963: OUTPUT«Cannot resolve caller postfix:<++>(List); none of these signatures match:␤    (Mu:D $a is rw)␤    (Mu:U $a is rw)␤    (Int:D $a is rw)␤    (int $a is rw)␤    (Bool:U $a is rw)␤    (Bool:D $a is rw)␤    (Num:D $a is rw)␤    (Num:U $a is rw)…»

[18:57] <BrokenRobot> tsk trsk

[18:57] <perlpilot> you needed more >>

[18:57] <BrokenRobot> Needs moar DWIMM

[18:57] <BrokenRobot> m: my $bag1 = <a b c>.BagHash; $bag1<b c>>>.&postfix:<++>; say $bag1

[18:57] <camelia> rakudo-moar 5a4963: OUTPUT«BagHash.new(a, c(2), b(2))␤»

[18:58] <moritz> m: my $bag1 = <a b c>.BagHash; $bag1<b c>>>++; say $bag1

[18:58] <camelia> rakudo-moar 5a4963: OUTPUT«BagHash.new(a, c(2), b(2))␤»

[18:58] <BrokenRobot> :o

[18:59] <perlpilot> Welcome to Perl 6  ;)

[18:59] <BrokenRobot> :)

[18:59] <perlpilot> you can put some . in there if it makes you feel better ...

[18:59] <perlpilot> m: my $bag1 = <a b c>.BagHash; $bag1<b c>.>>++; say $bag1

[18:59] <camelia> rakudo-moar 5a4963: OUTPUT«BagHash.new(a, c(2), b(2))␤»

[18:59] <perlpilot> m: my $bag1 = <a b c>.BagHash; $bag1<b c>.>>.++; say $bag1

[18:59] <camelia> rakudo-moar 5a4963: OUTPUT«BagHash.new(a, c(2), b(2))␤»

[18:59] <moritz> or use the non-texas version of >>

[19:00] * moritz is currently keyboard-challenged (no compose key configured)

[19:00] <BrokenRobot> m: my $bag1 = <a b c>.BagHash; $bag1<b c>»++; say $bag1

[19:00] <camelia> rakudo-moar 5a4963: OUTPUT«BagHash.new(a, c(2), b(2))␤»

[19:01] <kyclark> My particular exercise is for genomics students to count the GC content of a DNA file.  It's easy so far to go line-by-line in a file and get a Bag for each:

[19:01] <moritz> I should patch irssi to accept vim digraphs in the input box

[19:01] <perlpilot> moritz: If you've got vim, you don't need a compose key :)

[19:01] <kyclark> m: say 'CACCAATTATGGTGTATGA'.comb.Bag

[19:01] <camelia> rakudo-moar 5a4963: OUTPUT«bag(C(3), G(4), T(6), A(6))␤»

[19:01] <BrokenRobot> :)

[19:01] <kyclark> But now I want to add that to a counter.  Maybe just a regular hash?

[19:02] <BrokenRobot> kyclark: see examples just above :)

[19:02] <BrokenRobot> m: my $dna = say 'CACCAATTATGGTGTATGA'.comb.Bag; $dna<T> += 2; say $dna

[19:02] <camelia> rakudo-moar 5a4963: OUTPUT«bag(C(3), G(4), T(6), A(6))␤Type Bool does not support associative indexing.␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[19:02] <BrokenRobot> m: my $dna = 'CACCAATTATGGTGTATGA'.comb.BagHash; $dna<T> += 2; say $dna

[19:02] <camelia> rakudo-moar 5a4963: OUTPUT«BagHash.new(C(3), G(4), T(8), A(6))␤»

[19:02] *** jjido joined
[19:03] <moritz> I'm somwhat disappointed that those examples don't involve 'GATTACA'

[19:03] <perlpilot> heh

[19:03] <BrokenRobot>  that's such a good movie ♥

[19:03] <BrokenRobot> Wait.. is that why it's called Gattaca? 

[19:03] <perlpilot> ding!

[19:04] <BrokenRobot> hah :D

[19:04] <moritz> I'm pretty sure it's no coincidence that it's spelled by those four letters :-)

[19:04] * mst cackles

[19:04] <mst> BrokenRobot: took me years to get it too

[19:04] <BrokenRobot> :)

[19:06] <hoelzro> jjj

[19:06] * geekosaur tends to notice that anymore

[19:06] <kyclark> This is the best I can manage so far: http://pastie.org/10893253

[19:07] <kyclark> Sorry, just repasted with example data.  In a FASTA format, the sequence headers are noted with ">" at the beginning of a line

[19:07] <geekosaur> it helps that half the cancer-genome organizations make sure their initials are in that set, so I see them every other day or so while perusing the medical news on sciencedaily...

[19:07] <kyclark> Earlier I'd mentioned that this works: $file.IO.lines ==> grep * !~~ /^\>/ ==> my @lines;

[19:08] <kyclark> I feel like I ought to manage a purely functional one-liner that would screen out headers, ".comb" the lines, and create a Bag

[19:08] <perlpilot> kyclark: Maybe you could write a FASTA parser module for others to use  :)

[19:08] <kyclark> I'd started on that road, but the BioPerl folks already made a P6 parser

[19:09] <kyclark> It's very niiice.

[19:13] <BrokenRobot> kyclark: my take on it: https://gist.github.com/zoffixznet/118ee58ca8279a1790b7c387ffc328ab

[19:14] <kyclark> Yep, that's it.

[19:14] <BrokenRobot> I guess second grep can just be .grep('G'|'C')

[19:14] <kyclark> That new regex is confusing to me.

[19:14] <moritz> you could also do something fancy like:

[19:15] <BrokenRobot> kyclark: {!/^\>/} is a code block that's basically { $_ !~~ /^\>/ }

[19:15] <kyclark> When the feeders completely work, that will be amazing.

[19:15] <moritz> my $bag = [(+)] $file.IO.lines.grep(none(/^'>'/)).map(*.comb.Bag);

[19:16] <BrokenRobot> With the snorgasbord of methods, I still SAGN for negative grep

[19:16] <BrokenRobot> .ngrep: /foo/ <=> .grep: { !/foo/ }

[19:16] <BrokenRobot> Or may be not :)

[19:17] <moritz> m: my $bag = bag(<a b c d a b a c a d a b>); say $b<a b>:p

[19:17] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '$b' is not declared␤at <tmp>:1␤------> 3g = bag(<a b c d a b a c a d a b>); say 7⏏5$b<a b>:p␤»

[19:17] <moritz> m: my $bag = bag(<a b c d a b a c a d a b>); say $bag<a b>:p

[19:17] <camelia> rakudo-moar 5a4963: OUTPUT«(a => 5 b => 3)␤»

[19:17] <kyclark> moritz nailed it too.  Now I need to read up on "none"

[19:18] <moritz> kyclark: hint: it's a Junction

[19:18] <BrokenRobot> huggable: Junction

[19:18] <huggable> BrokenRobot, Logical superposition of values: https://docs.perl6.org/type/Junction

[19:19] <BrokenRobot> I also have slides: http://tpm2016.zoffix.com/#/30 (press Right key for two more)

[19:21] <kyclark> $file.IO.lines.grep({!/^\>/})>>.comb.flat.Bag works too

[19:22] <BrokenRobot> $file.IO.lines.grep({!/^\>/}).joib.comb.Bag

[19:22] <BrokenRobot> *join

[19:22] <kyclark> $file.IO.lines.grep({!/^\>/}).map(*.comb).flat.Bag

[19:22] <BrokenRobot> kyclark: » is autothreaded tho :)

[19:23] <kyclark> Mmmm, parallelization

[19:23] <BrokenRobot> kyclark: yeah.. NIY but will be

[19:23] <kyclark> Map is not, won't be?

[19:23] <BrokenRobot> won't be

[19:23] <awwaiid> .race.map is though :)

[19:23] <BrokenRobot> No point

[19:23] <BrokenRobot> and ».&({ codes })

[19:23] <kyclark> Feeders will be, too, right?

[19:23] <BrokenRobot> Right

[19:23] *** Actualeyes left
[19:24] <BrokenRobot> And Junctions too

[19:24] <awwaiid> you can use .race now, btw

[19:24] <BrokenRobot> FSVO use :)

[19:24] <awwaiid> well. last I knew

[19:24] <BrokenRobot> Tho jnthn++ will be fixing it soon, IIRC

[19:24] <awwaiid> ah. I think I got it to work in some cases

[19:24] <kyclark> What is "race"?  Docs?

[19:24] <kyclark> $file.IO.lines.grep({!/^\>/}).race

[19:24] <kyclark> HyperSeq.new

[19:24] <BrokenRobot> kyclark: search for "race"

[19:25] <BrokenRobot> kyclark: "hyper" is related to it

[19:25] <awwaiid> https://docs.perl6.org/routine/race -- @list.race returns a fancy thing that runs in parallel

[19:25] <BrokenRobot> I also have slides :) http://tpm2016.zoffix.com/#/26

[19:25] <awwaiid> http://jnthn.net/papers/2015-yapcasia-concurrency.pdf

[19:26] <awwaiid> ya

[19:26] <awwaiid> BrokenRobot: oh are you Zoffix now?

[19:26] <BrokenRobot> m: sleep 1 for ^4 .race: :batch; say now - INIT now;

[19:26] <camelia> rakudo-moar 5a4963: OUTPUT«1.00596108␤»

[19:26] <awwaiid> I guess I should just assume everyone is Zoffix going forward

[19:26] <BrokenRobot> kyclark: ^ four 1-second sleeps run in just 1 second

[19:27] <DrForr_> WE ARE ALL ZOFFIX.

[19:27] <kyclark> Uh, OK. I need to read.

[19:28] <awwaiid> because you're supposed to be sleep()/$work?

[19:28] <BrokenRobot> :D

[19:28] <awwaiid> heh

[19:29] <geekosaur> of course now you need a new identity...

[19:29] <DrForr_> n/ick AlanSmithee

[19:29] <BrokenRobot> Haha :)

[19:29] <moritz> nah, his wife thinks he is having an affair, and his affair thinks he is with his wife, and he wants to to keep up the illusion to both :-)

[19:30] *** Bodger1234 left
[19:31] *** wamba left
[19:32] <mst> long standing traditional approach for mathematicians

[19:32] <dogbert17> o/ #perl6

[19:32] <DrForr_> Assume a spherical mistress.

[19:32] <mst> I don't tend to do it that way, it would deprive the two women of the option to go on a date with each other instead and plot against me

[19:32] <BrokenRobot> AlanSmithee? For movies too

[19:32] <BrokenRobot> Oh the wife thing

[19:33] <dogbert17> how many people have installed CSS::Sass? It doesn't work for me :(

[19:33] <BrokenRobot> dogbert17: \o

[19:33] <BrokenRobot> Oh :(

[19:33] <BrokenRobot> dogbert17: what's the error?

[19:33] <BrokenRobot> dogbert17: you *are* talking about the Perl 5 module, right?

[19:33] *** zakharyas joined
[19:33] <dogbert17> BrokenRobot: Error:  Can't load '/root/.cpanm/work/1467139323.24978/CSS-Sass-3.3.4/blib/arch/auto/CSS/Sass/Sass.so' for module CSS::Sass: /root/.cpanm/work/1467139323.24978/CSS-Sass-3.3.4/blib/arch/auto/CSS/Sass/Sass.so: undefined symbol: _ZTVN10__cxxabiv120__si_class_type_infoE at /usr/lib/perl/5.18/DynaLoader.pm line 184.

[19:34] <dogbert17> tried to install with cpanm

[19:34] <BrokenRobot> dogbert17: why is it in /root though :/ Did you install Mojolicious the same way?

[19:35] <dogbert17> BrokenRobot: yes

[19:35] *** addison joined
[19:35] <dogbert17> became desperate :)

[19:35] <BrokenRobot> 1 sec

[19:36] <BrokenRobot> dogbert17: let's move to #perl, 'cause I've no idea why that error exists :)

[19:36] <dogbert17> ok

[19:39] *** vendethiel joined
[19:39] *** huggable left
[19:40] *** huggable joined
[19:40] *** khw joined
[19:40] *** hankache joined
[19:41] *** darutoko left
[19:41] <moritz> seems to be related to using the wrong linker (gcc instead of g++ or something like that)

[19:42] <hankache> hello #perl6

[19:42] <moritz> \o hankache 

[19:42] <hankache> hiya moritz

[19:43] <hankache> moritz: I am trying the vps from OVH

[19:44] <hankache> just did rakudobrew build moar on a fresh ubuntu server and got the following error when lauching the REPL:

[19:44] <hankache> Couldn't load Rakudo REPL.pm: MVMContext representation does not support elems

[19:45] <hankache> any ideas what this is?

[19:46] <hoelzro> hankache: it's a recent breakage

[19:46] <hoelzro> due to 5a4963f

[19:47] <hoelzro> it has something to do with pseudo stashes and a change to iterators, afaict

[19:47] <dalek> doc: 4cca4f5 | (Zoffix Znet)++ | / (2 files):

[19:47] <dalek> doc: Make SASS processor optional to avoid extra deps

[19:47] <dalek> doc: review: https://github.com/perl6/doc/commit/4cca4f5d69

[19:48] <hankache> hoelzro ah no worries then. I feared it has something to do with the config

[19:49] <BrokenRobot> dogbert17: try that ^ 

[19:49] <dogbert17> BrokenRobot: you're fast :)

[19:49] <BrokenRobot> That's what she... oh wait

[19:50] <moritz> hankache: try to build the last release

[19:50] <BrokenRobot> dogbert17: does it work? I need to relocate; just want to make sure you're set before I depart :)

[19:50] <hankache> moritz will do

[19:51] <d^_^b> is it possible to use promises and run/shell? where each run/shell will create a promise and be done independently 

[19:51] <BrokenRobot> d^_^b: I think that's what Proc::Async is for

[19:51] <BrokenRobot> d^_^b: https://docs.perl6.org/type/Proc::Async

[19:51] <dogbert17> BrokenRobot: perhaps I have messed up my system ... but the following shows up

[19:51] <dogbert17> Mojolicious version 6.66 required--this is only version 6.58 at app.pl line 4.

[19:51] *** kyclark left
[19:51] <BrokenRobot> dogbert17: 1 sec

[19:52] <dalek> doc: f5eebe0 | (Zoffix Znet)++ | app.pl:

[19:52] <dalek> doc: Reduce Mojolicious prereq

[19:52] <dalek> doc: review: https://github.com/perl6/doc/commit/f5eebe055b

[19:52] <BrokenRobot> dogbert17: try that

[19:52] <BrokenRobot> cpanm -vn Mojolicious::Plugin::AssetPack

[19:53] <d^_^b> BrokenRobot: good call

[19:53] <BrokenRobot> d^_^b: this is my script that restarts huggable. You'd just make many of them: https://gist.github.com/zoffixznet/01c52010794334a3eaa0b584524ddd3c

[19:53] <BrokenRobot> s/them/Proc::Asyncs/;

[19:54] <BrokenRobot> for all your commands

[19:54] <dogbert17> BrokenRobot: it starts :)

[19:54] <BrokenRobot> great

[19:54] <BrokenRobot> That'll be $150 in support fees plus tax :)

[19:54] <dogbert17> BrokenRobot++

[19:54] * BrokenRobot &

[19:55] <dogbert17> BrokenRobet: what do you think about https://gist.github.com/dogbert17/ad42869f2b0b638932648d022b40d57c

[19:56] *** jjido_ joined
[19:56] <BrokenRobot> dogbert17: no idea about that topic :)

[19:56] *** jjido left
[19:57] *** kyclark joined
[19:57] <dogbert17> BrokenRobot: maybe I should ask sexy-coder-girl instead :)

[19:57] <BrokenRobot> She doesn't know either :)

[19:58] <dogbert17> moritz might know if he's around

[19:59] <dogbert17> btw, have any books ever been released about Mojolicious?

[19:59] <moritz> dogbert17: I don't think app_lifetime => False means that the process exit waits for the stread

[20:00] <moritz> hum

[20:00] <moritz> but that's what it says in the docs for new()

[20:00] <dogbert17> moritz: that's worrying since I more or less stole that text from the Thread.new method 

[20:00] <dogbert17> everyone is so fast on the keyboard :)

[20:00] <moritz> m: Tread.new(code => { sleep 42 }).run()

[20:00] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    Tread used at line 1. Did you mean 'Thread'?␤␤»

[20:00] <moritz> m: Thread.new(code => { sleep 42 }).run()

[20:00] <jnthn> app_lifetime => False should mean the VM doesn't exit until it has joined the thread.

[20:01] *** acrussell left
[20:01] <jnthn> Note that all thread pool threads are app_lifetime => True

[20:01] <camelia> rakudo-moar 5a4963: OUTPUT«(timeout)»

[20:01] <moritz> m: Thread.new(code => { sleep 42 }, :app_lifetime).run()

[20:01] <camelia> rakudo-moar 5a4963: ( no output )

[20:01] <moritz> jnthn: oh, that explains a lot

[20:01] <moritz> dogbert17: ok, then the docs are fine

[20:01] <dogbert17> jnthn: default when creating a Thread seems to be False

[20:02] <moritz> right

[20:02] <moritz> it's just that the thread pool always passes :app_lifetime

[20:02] <jnthn> dogbert17: Yes, matches my recollection of how I did it

[20:03] <dogbert17> moritz and jnthn: thx for the wisdom

[20:03] <dogbert17> I'll commit then

[20:03] <jnthn> The thread pool is a higher level construct used to schedule stuff, and generally something should always be waiting on that stuff (if it cares) to either get its result or at the very least process its errors.

[20:04] <dogbert17> agreed

[20:06] <d^_^b> BrokenRobot: cant look mobile. got it working will check it out later. thanks

[20:06] <dogbert17> while I have your attention, there are two thread methods that seem to do the same thing, i.e. finish and join. Any reason why?

[20:06] *** jjido_ left
[20:06] *** jjido joined
[20:07] <jnthn> dogbert17: Probably because I called it .join because that's what the thing is called everywhere else, and somebody was like "omg I'm SO confused with joining an array!!1!" and so we ended up with finish also.

[20:08] <jnthn> In hindsight I should be less diplomatic about API design sometimes. :P

[20:08] *** dvinciguerra_ left
[20:09] <jnthn> Or less democratic, at least :)

[20:09] <dalek> doc: cd72a4c | (Jan-Olof Hendig)++ | doc/Type/Thread.pod:

[20:09] <dalek> doc: Added docs for Thread.app_lifetime. moritz++ jnthn++ zoffix++

[20:09] <dalek> doc: review: https://github.com/perl6/doc/commit/cd72a4c3cf

[20:10] <dogbert17> jnthn: interesting, maybe I should doc join as well then

[20:10] <jnthn> dogbert17: Yeah, you can. Though `join` is what anyone used to programming with low-level threads will already expect, tbh.

[20:11] <dogbert17> jnthn: the more docs the merrier :)

[20:11] <jnthn> Oh, I'm not saying don't doc it, just that in my mind its existence is more justified than .finish :)

[20:12] <jnthn> (We'll keep both for the long haul, I've no doubt.)

[20:12] <dogbert17> jnthn: I'll add it later tonight :)

[20:15] <jnthn> dogbert17++

[20:19] *** itaipu joined
[20:22] *** ChoHag left
[20:23] *** kyclark left
[20:26] *** grondilu left
[20:26] *** rgrinberg left
[20:30] *** _mg_ joined
[20:30] *** setty1 left
[20:30] *** hankache left
[20:31] *** daxim left
[20:33] *** CIAvash left
[20:33] *** kyclark joined
[20:33] *** pmurias left
[20:34] *** daxim joined
[20:35] *** jjido left
[20:37] *** jjido joined
[20:39] *** yqt joined
[20:40] *** molaf left
[20:43] <Xliff> m: my $a = 1; say qq<a = $a>;

[20:43] <camelia> rakudo-moar 5a4963: OUTPUT«a = 1␤»

[20:43] <kyclark> Is there any better way to do this (sort a list by the lengths of the members)?

[20:43] <kyclark> m: say <the a doggie cat an>.sort({$^a.chars <=> $^b.chars})

[20:43] <camelia> rakudo-moar 5a4963: OUTPUT«(a an the cat doggie)␤»

[20:43] <hoelzro> kyclark: you can do @a.sort(*.chars)

[20:44] <kyclark> Yes, OK -- but why?  :-)

[20:44] <hoelzro> if you give sort a unary function, it applies the function to the elements and uses the results for comparisons

[20:44] <kyclark> "sort" needs a sub, so exactly how is "*.chars" used?

[20:45] <hoelzro> *.chars is a sub

[20:45] <perlpilot> *.chars is a unary sub

[20:45] <hoelzro> Whatever (*) is amazing

[20:45] <kyclark> so it automatically applies that to $^a and $^b?

[20:45] <perlpilot> hoelzro: until it's confusing   ;)

[20:45] <perlpilot> kyclark: something like that.  (There's no $^a and $^b, just a single $_)

[20:46] <hoelzro> *.chars is sort for -> $a { $a.chars }

[20:46] <hoelzro> s/sort/short/

[20:46] <perlpilot> sort(*.chars) is ... what hoelzro said

[20:47] *** itaipu left
[20:48] *** colomon left
[20:48] *** itaipu joined
[20:49] *** zakharyas left
[20:49] <kyclark> Is there a built-in or de facto Pod::Usage-type thingie?

[20:50] <perlpilot> There's not one for Pod that I know of, but rakudo can make a usage from the signature(s) of your MAIN

[20:52] *** brrt left
[20:52] <kyclark> "If &by accepts only one argument, the list elements are sorted according to by($a) cmp by($b) . The return values of &by are cached, so that &by is only called once per list element."

[20:52] <kyclark> Got it!

[20:53] <perlpilot> kyclark: Are you familiar with the Schwartzian Transform?

[20:53] <kyclark> Yes. 

[20:53] <perlpilot> kyclark: another way to think of it is that it automatically does that for you

[20:53] <kyclark> Yes, that's great.  Thanks.

[20:54] <kyclark> As for the MAIN, how could I describe that I want at least two arguments?

[20:54] <kyclark> That is, in the generated usage statement?

[20:54] <kyclark> E.g., for a sorting program.

[20:54] *** jjido left
[20:55] <kyclark> sub MAIN (@args where @args.elems >= 2) {  

[20:55] <FROGGS> m: sub MAIN($foo, $bar) { }

[20:55] <yoleaux> 06:22Z <Xliff> FROGGS: 08findnodes.t finished and all tests passing! Expect a PR, soon.

[20:55] <camelia> rakudo-moar 5a4963: OUTPUT«Usage:␤  <tmp> <foo> <bar> ␤»

[20:56] <FROGGS> m: sub MAIN($a, $b, *@more) { }

[20:56] <camelia> rakudo-moar 5a4963: OUTPUT«Usage:␤  <tmp> <a> <b> [<more> ...] ␤»

[20:56] <FROGGS> <tmp> is the program name here

[20:56] *** jjido joined
[20:57] <kyclark> Yes, sweet.

[20:57] <perlpilot> m: sub MAIN( [$a, $b, *@_] ) { }  # curious

[20:57] <camelia> rakudo-moar 5a4963: OUTPUT«Usage:␤  <tmp> <Positional> ␤»

[20:58] *** TEttinger joined
[20:59] <kyclark> perlpilot, what is it you're describing in the signature?

[21:00] <FROGGS> it unpacks to to the stuff in [ ]

[21:00] <kyclark> How would you access what you described as *@_?

[21:00] <FROGGS> m: sub MAIN(*@more [$foo, $bar, *@_]) { say @_ }; MAIN 1, 2, 3, 4

[21:00] <camelia> rakudo-moar 5a4963: OUTPUT«[3 4]␤Usage:␤  <tmp> [<more> ...] ␤»

[21:01] <FROGGS> m: sub MAIN(*@more [$foo, $bar, *@_]) { say @_ }; MAIN 1

[21:01] <camelia> rakudo-moar 5a4963: OUTPUT«Too few positionals passed; expected at least 2 arguments but got only 1 in sub-signature of parameter @more␤  in sub MAIN at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:01] <FROGGS> the error message explains pretty well what [] is there

[21:01] <FROGGS> I love it :o)

[21:01] <kyclark> Yes!  That rocks.

[21:02] *** _mg_ left
[21:03] <FROGGS> gnight

[21:03] *** FROGGS left
[21:05] <Xliff> First time hes been here in days and I miss him by ----><----- 

[21:06] *** jjido left
[21:06] *** rgrinberg joined
[21:06] *** jjido joined
[21:07] <Xliff> There is definitely an endless loop issue related to type checking in rakudo that might be exposed by NativeCall

[21:07] <Xliff> However for the life of me I can't golf a concise use case. I just run into it when working on p6-XML-LibXML

[21:11] <Xliff> If anyone is interested in seeing it, you can check out https://github.com/Xliff/p6-XML-LibXML.git and switch to the 08elements branch. Then "perl6 -Ilib t/06leements.t"

[21:13] *** jjido left
[21:14] *** kyclark left
[21:15] *** jjido joined
[21:16] *** kyclark joined
[21:16] *** tlvb left
[21:16] *** tlvb joined
[21:17] *** kyclark left
[21:18] *** kyclark joined
[21:20] <Zoffix> moritz, I saw you on the road today: http://i.imgur.com/0x6Hv9l.jpg 

[21:20] <Zoffix> :P

[21:21] <perlpilot> There's a "moritz" car dealership near here.  I see cars with his name on them all the time.

[21:22] *** tlvb left
[21:23] *** tlvb joined
[21:23] *** tlvb left
[21:24] <Xliff> Brickyard Way, Zoffix?

[21:24] *** mcmillhj left
[21:25] <Zoffix> Yeah... it's a way... to um... the brickyard :P

[21:28] <Xliff> It's on the street sign in your photo! :P

[21:28] * Xliff is now playing: Jonny L - Further

[21:29] <Xliff> \m/...(>.<)…\m/

[21:29] <Zoffix> Never heard of 'im :)

[21:30] <Zoffix> And the "revolution will not be televised"... that I "got" last time was because Bernie Sanders supporters use it not because of some song or whatver it was :)

[21:31] <Zoffix> Though it's nice to hear a song with a real solo for a change https://youtu.be/lJuSZ6c1HYg?t=3m47s

[21:31] <Xliff> LOL!

[21:31] <Zoffix> They don't make them like they used to anymore :)

[21:31] <Xliff> I was referring to the latter of course.

[21:31] <Zoffix> :)

[21:31] <Xliff> Nice to know Sanders supporters know enough about history to "lift" from it. 

[21:32] <Zoffix> :)

[21:32] *** ptolemarch left
[21:32] <perlpilot> Zoffix: is this where the picture was taken (roughly) ? https://www.google.com/maps/place/Brickyard+Way,+Brampton,+ON,+Canada/@43.7010824,-79.7805057,3a,34.2y,131.04h,87.1t/data=!3m6!1e1!3m4!1s2aPZegmPrroZJAh6dt4RoQ!2e0!7i13312!8i6656!4m5!3m4!1s0x882b15cdcef6ef7f:0xea19085f11faa145!8m2!3d43.702601!4d-79.7802226

[21:33] <Xliff> Zoffix: In case you wanna hear what I referenced earlier https://www.youtube.com/watch?v=utLprz9vJ90&ab_channel=SpearheadRecords

[21:33] <perlpilot> If so ... I'm having trouble finding that brickyard  ;)

[21:33] *** nic__ joined
[21:33] <nebg>  hello everyone... i'm using vim and gvim as editor for vim... i would like to know if there is some automcompletion feature or what do you use to write perl ? since i installed perl-support as plugin and it's ok but doesn't have autocompletion feature for methods in a package... and i tried perl omnicompletion... but it just doesn't work... can somebody help me or give me some suggestions about it ? 

[21:33] *** nic__ is now known as nicq20

[21:33] <Xliff> ROFLMAP perlpilot.

[21:33] <Xliff> Look at the street sign.

[21:33] <Zoffix> perlpilot, yeah that's the place and no there's no brickyard. A school on one end and retirement home on the other

[21:33] <Xliff> It's like...right in front of you when you open that photo.

[21:34] <Zoffix> perlpilot, dammit! you exposed my lie! :D

[21:34] <Xliff> \m/...(>.<)...\m/

[21:34] <Zoffix> perlpilot, did you find that spot because you knew I lived in Brampton (or Canada) already or using just the pic alone?

[21:34] <perlpilot> nebg: you probably want something like https://github.com/thoughtstream/Damian-Conway-s-Vim-Setup

[21:35] <perlpilot> Zoffix: pic alone and some educated guessing.

[21:35] <nicq20> nbeg: Personally, I use Atom. Has some good Perl6 modules for it.

[21:36] <nicq20> oops.

[21:36] <perlpilot> Zoffix: plus with google maps it took me like 30 seconds to find a vantage point where I could go "yep, that looks like the place"

[21:36] <Xliff> perlpilot: Here... try this one. https://www.google.com/maps/@43.7008734,-79.7802202,3a,75y,134.65h,66.24t/data=!3m6!1e1!3m4!1sx4B8HTJOW0s96ne2iIjNCA!2e0!7i13312!8i6656

[21:36] <Zoffix> :)

[21:36] <Zoffix> scary

[21:36] <nicq20> nebg: Personally, I use Atom. Has some good Perl6 modules for it. https://atom.io

[21:39] *** kid51 joined
[21:40] <perlpilot> Zoffix: what made me even try was I accidentally clicked on the picture and it zoomed in and then I was musing over the mythical "enhance" function you always see in TV and movies and then I thought ... "how hard would it be to find this location using just google maps and what's in the image"

[21:41] <perlpilot> Plus there weren't an onerus number of "Brickyard Way"s in google maps :)

[21:41] <Xliff> LOL!

[21:42] <perlpilot> (of course, I checked the EXIF data first to see if would be that easy ;)

[21:45] <perlpilot> nebg: also, there's this talk from the recent perl conference:  https://www.youtube.com/watch?v=9u6O0dLuqhI

[21:45] <perlpilot> nicq20: maybe you should look at that talk too  :)

[21:45] *** jjido left
[21:46] *** jjido_ joined
[21:46] * perlpilot is totally scatter-brained right now .... must be time to go home

[21:46] <nebg> why people on perl5 channel is so arrogant while here it is so nice ? 

[21:46] <Xliff> Ah EXIF. People tag their photos and assume that such data won't be used against them. :/

[21:46] <nebg> just a joke obviously

[21:47] <perlpilot> nebg: which part?

[21:48] <nebg> the first one :)

[21:48] <nebg> but not too much a joke :)

[21:48] *** firstdayonthejob joined
[21:48] <perlpilot> nebg: well, it's more true than not, so it's hard to tell.

[21:48] <hobbs> in that it's rude and not funny :)

[21:49] <nebg> hobbs, perlpilot yeah it's true... so even you noticed that right  ?

[21:49] <nebg> i was thinking i was the only one

[21:49] <kyclark> Help me understand this:

[21:49] <kyclark> grep 'c', <a b c d c>

[21:49] <kyclark> m: say grep 'c', <a b c d c>

[21:49] <camelia> rakudo-moar 5a4963: OUTPUT«(c c)␤»

[21:49] <kyclark> m: say grep True, (True, False, False)

[21:49] <camelia> rakudo-moar 5a4963: OUTPUT«Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at <tmp>:1␤    ------> 3say grep7⏏5 True, (True, False, False)␤Cannot use Bool as Matcher with…»

[21:49] <kyclark> Actually, my REPL blows up

[21:50] <perlpilot> nebg: you'll note that I (among others) are also on #perl.   I'm not any different on this channel than on the other (at least I don't think I am.  It's hard to self assess sometimes)

[21:50] <kyclark> m: say grep {False}, (True, False)

[21:50] <camelia> rakudo-moar 5a4963: OUTPUT«()␤»

[21:50] <nebg> perlpilot, i don't know that's my impression... 

[21:51] <nebg> they don't take it easy... 

[21:51] <perlpilot> nebg: so you may just be noticing that there's a greater quantity of arrogant people or nice people.  #perl has been around far longer and so has had far more time to collect many different people

[21:51] <perlpilot> nebg: maybe #perl6 just isn't "popular enough" to garner enough arrogant people.  I don't know.

[21:51] <nebg> perlpilot, yeah it my be :) XD

[21:52] <hobbs> or maybe, making that kind of judgment after 2 minutes is an insanely bad idea. :)

[21:52] <perlpilot> nebg: #perl6 does encourage niceness though.   And I like to think that we're biasing the community that way a little bit.  Only time will tell.

[21:52] <geekosaur> perlpilot, if it were just number of people, #haskell wouldn't be one of the nicest channels on freenode

[21:53] <geekosaur> you don't just need people, you need a sense of community and a consensus on how that community should be encouraged to behave

[21:54] <perlpilot> geekosaur: Larry founded the Perl 5 community too.  I don't think he was "more arrogant" or something in the past to cause that community to be harsher than this one.

[21:54] <perlpilot> geekosaur: yes, I know it's not all his fault :)

[21:54] *** jjido_ left
[21:54] *** sufrostico joined
[21:55] <nebg> perlpilot, yes... perl5 anytime i ask something... it's like risking a ban... always people flaming me... and telling me to read the doc... the fact is that i'm a noob and many times i just need a small advice and can't understand the doc... it seems they don't contemple noobs

[21:55] *** jjido joined
[21:56] *** DarthGandalf left
[21:56] <gfldex> kyclark: see https://github.com/rakudo/rakudo/blob/nom/src/core/Any-iterable-methods.pm#L690

[21:57] *** DarthGandalf joined
[21:57] *** rindolf left
[21:58] <perlpilot> geekosaur: I think there's a tendency for people with big brains to lean towards egoism and pedanticism and harshness and it takes real concerted effort to keep things from heading that direction.   Maybe #perl6 has had more effort in that regard.  (#haskell too)

[21:58] *** lichtkind left
[21:59] <gfldex> m: my &m = my method ::(Any:D){ dd %_ }; m(42, a=>1);

[21:59] <camelia> rakudo-moar 5a4963: OUTPUT«{:a(1)}␤»

[21:59] <perlpilot> now I *know* it's time for me to go home.  :-)

[21:59] <gfldex> we don

[21:59] <gfldex> we don't doc %_ :(

[21:59] <kyclark> gfldex, so I can't grep for a Bool?

[21:59] *** skids left
[21:59] <perlpilot> Everybody: have an awesome rest of your day and week!  

[21:59] * perlpilot *poof*

[22:00] *** perlpilot left
[22:00] <gfldex> kyclark: not on the buildin types

[22:02] <kyclark> This doesn't work, either, but is it closer?

[22:02] <kyclark> m: grep * == True, (True, False, False)

[22:02] <camelia> rakudo-moar 5a4963: ( no output )

[22:02] <gfldex> m: sub s { dd @_ }; s(1,2,3);

[22:02] <camelia> rakudo-moar 5a4963: OUTPUT«[1, 2, 3]␤»

[22:02] <gfldex> i don't think we doc that either

[22:02] <gfldex> m: dd( grep * == True, (True, False, False) )

[22:02] <camelia> rakudo-moar 5a4963: OUTPUT«(Bool::True,).Seq␤»

[22:03] <kyclark> Here's what I'm trying.  Given two strings, find the characters that are different.

[22:03] *** RabidGravy left
[22:03] *** firstdayonthejob left
[22:03] <kyclark> m: my $a = "foo"; my $b = "bar"; my @pairs = $a.comb.list Zeq $b.comb.list;

[22:03] <camelia> rakudo-moar 5a4963: ( no output )

[22:03] <kyclark> m: my $a = "foo"; my $b = "bar"; my @pairs = $a.comb.list Zeq $b.comb.list; say @pairs;

[22:03] <camelia> rakudo-moar 5a4963: OUTPUT«[False False False]␤»

[22:04] <kyclark> Sorry...

[22:04] <kyclark> m:  my $a = "foo"; my $b = "boo"; my @pairs = $a.comb.list Zeq $b.comb.list; say @pairs;

[22:04] <camelia> rakudo-moar 5a4963: OUTPUT«[False True True]␤»

[22:04] <gfldex> m: my $s1 = "hello world"; my $s2 = "hello camelia"; dd $s1.comb (-) $s2.comb;

[22:04] <camelia> rakudo-moar 5a4963: OUTPUT«set("r","w","d")␤»

[22:05] <kyclark> In my case, I'm looking to teach students to find SNPs (single nucleotide polymorphisms), so knowing the position is important, not just the number of mismatches.

[22:05] *** firstdayonthejob joined
[22:05] <gfldex> so you are looking for substrings that differ?

[22:05] <Xliff> "Read the docs" is not an polite answer for people who want to learn something, anymore

[22:06] <Xliff> Especially if it is accompanied by fire.

[22:06] <Roamer`> gfldex, no, kyclark is looking for the exact positions where the character in that position in the first string is not the same as the character in that position in the second one

[22:06] <Roamer`> gfldex, so "foo" and "boo" would report differences only in position 0

[22:06] <kyclark> In my @pairs, I can see the positions that mismatch (False). First I'd like to count how many False's there are.

[22:06] <Xliff> Many times the quality, quantity or both of the docs may make specific answers hard to find.

[22:06] <gfldex> so you want the index (as in Integer) where they differ?

[22:07] <kyclark> BTW, "Zeq" is wicked pissa.

[22:07] <kyclark> Knowing the positions of the False values would be perfect.

[22:08] <kyclark> It's common to show alignments of one sequence above another and symbols showing same/diff in between.

[22:09] <kyclark> So first I might ask students to identify how many SNPs are found between two sequences. Then perhaps print seq1, symbols showing matches, and seq2.

[22:09] <kyclark> Hence the idea for "grep False, @pairs

[22:10] <Roamer`> m: my $a = "foo"; my $b = "boo"; my @pairs = $a.comb.list Zeq $b.comb.list; say @pairs; my @pairpairs = @pairs Z ^Inf; say @pairpairs.grep(*[0] == False).map(*[1])

[22:10] <camelia> rakudo-moar 5a4963: OUTPUT«[False True True]␤(0)␤»

[22:10] <Roamer`> oof, okay, sorry

[22:10] <Roamer`> m: my $a = "foo"; my $b = "boo"; my @pairs = $a.comb.list Zeq $b.comb.list; my @pairpairs = @pairs Z ^Inf; say @pairpairs.grep(*[0] == False).map(*[1])

[22:10] <camelia> rakudo-moar 5a4963: OUTPUT«(0)␤»

[22:10] <Roamer`> m: my $a = "foox"; my $b = "feon"; my @pairs = $a.comb.list Zeq $b.comb.list; my @pairpairs = @pairs Z ^Inf; say @pairpairs.grep(*[0] == False).map(*[1])

[22:10] <camelia> rakudo-moar 5a4963: OUTPUT«(1 3)␤»

[22:10] <kyclark> In Haskell, I do this: filter (==True) [True, False,True]

[22:10] <jnthn> kyclark: I'm only half reading, but did yo use grep with :k ?

[22:10] <Roamer`> kyclark, does this work for you?

[22:11] <kyclark> jnthn, what is :k?

[22:11] <jnthn> m: my $a = "foox"; my $b = "feon"; my @pairs = $a.comb Zeq $b.comb; say @pairs.grep(!*[0], :k)

[22:11] <camelia> rakudo-moar 5a4963: OUTPUT«(1 3)␤»

[22:11] *** rgrinberg left
[22:12] <jnthn> kyclark: Short for "keys"

[22:12] <Xliff> jnth++ # Faster than me again

[22:12] <jnthn> m: my $a = "foox"; my $b = "feon"; my @pairs = $a.comb Zeq $b.comb; say @pairs.grep(!*[0], :kv)

[22:12] <camelia> rakudo-moar 5a4963: OUTPUT«(1 False 3 False)␤»

[22:12] <jnthn> m: my $a = "foox"; my $b = "feon"; my @pairs = $a.comb Zeq $b.comb; say @pairs.grep(!*[0], :kp)

[22:12] <camelia> rakudo-moar 5a4963: OUTPUT«Unexpected adverb 'kp' passed to grep on @pairs␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[22:12] <jnthn> m: my $a = "foox"; my $b = "feon"; my @pairs = $a.comb Zeq $b.comb; say @pairs.grep(!*[0], :p)

[22:12] <camelia> rakudo-moar 5a4963: OUTPUT«(1 => False 3 => False)␤»

[22:12] <jnthn> m: my $a = "foox"; my $b = "feon"; my @pairs = $a.comb Zeq $b.comb; say @pairs.grep(!*[0], :v)

[22:12] <camelia> rakudo-moar 5a4963: OUTPUT«(False False)␤»

[22:12] <Xliff> For arrays :k == index

[22:12] <jnthn> :v is the default (give me the matched values)

[22:13] <jnthn> And :k means give me the keys (indices) that matched

[22:13] <jnthn> kv is a list of the two alternating, and p is pairs

[22:13] <jnthn> Note that it's a pun on slice adverbs

[22:13] <gfldex> m: my $s1 = "hello world"; my $s2 = "hello camelia"; my Str $target; for $s1.comb Z, $s2.comb -> [$l, $r] { $target ~= $l eq $r ?? $l !! $l.uc }; say $target

[22:13] <camelia> rakudo-moar 5a4963: OUTPUT«hello WORLD␤»

[22:13] <jnthn> m: my @a = 1..10; my @b = 2, 5, 1; say @a[@b]:p

[22:13] <camelia> rakudo-moar 5a4963: OUTPUT«(2 => 3 5 => 6 1 => 2)␤»

[22:14] <jnthn> For example

[22:17] <Roamer`> I guess it'll take me some *more* time to appreciate all the ways in which Perl 6 extends the idioms I'm so used to in Perl 5 :)

[22:17] <kyclark> jnthn, that's quite interesting.  I've been sitting here thinking.  I can't figure out the first arg to grep !*[0]

[22:18] <gfldex> m: my $s1 = "hello world"; my $s2 = "hello camelia"; my Str $target; for $s1.comb Z, $s2.comb -> [$l, $r] { $target ~= $l eq $r ?? " " !! $r }; say ($s1, $target, $s2).join("\n"),

[22:18] <camelia> rakudo-moar 5a4963: OUTPUT«hello world␤      camel␤hello camelia␤»

[22:18] <kyclark> Roamer`, yours worked, but it's a hella lotta work.  I can't imagine teaching that to beginner biologist hackers.

[22:19] <Roamer`> kyclark, it's the "whatever" thing - anything that accepts a block of code with a single argument (grep, map, sometimes sort), also accepts an expression that has * (pronounced "whatever") where you would otherwise place the argument

[22:19] <gfldex> grep !*[0], same as (nearly) grep({not $_[0]},

[22:19] <Roamer`> kyclark, so grep(!*[0]) is equivalent to my grep(*[0] == False) is equivalent to grep { $_[0] == False }

[22:20] <kyclark> But why treat the "thing" as an array?

[22:21] <Roamer`> ah, now that's a good question :)

[22:21] <Roamer`> m: use v6.c; my $a = "foox"; my $b = "feon"; my @pairs = $a.comb Zeq $b.comb; say @pairs.grep(!*, :k)

[22:21] <camelia> rakudo-moar 5a4963: OUTPUT«(1 3)␤»

[22:21] <Roamer`> just !* also works :)

[22:22] <gfldex> m: my $a = "foox"; my $b = "feon"; my @pairs = $a.comb Zeq $b.comb; say @pairs.grep({dd $_ }, :kv)

[22:22] <camelia> rakudo-moar 5a4963: OUTPUT«Bool @pairs = Bool::True␤Bool @pairs = Bool::False␤Bool @pairs = Bool::True␤Bool @pairs = Bool::False␤()␤»

[22:22] *** itaipu left
[22:23] <Roamer`> so, yeah, the elements of the @pairs array are actually *not* pairs, they are booleans

[22:23] <Roamer`> aka ints

[22:23] <Roamer`> so why does grep(!*[0]) work?

[22:23] <kyclark> Yes, I should have chosen a better name

[22:24] <kyclark> m: my @pairs = (False, True, True); say @pairs.grep(!*)

[22:24] <camelia> rakudo-moar 5a4963: OUTPUT«(False)␤»

[22:24] <kyclark> m: my @pairs = (False, True, True); say grep !*, @pairs

[22:24] <camelia> rakudo-moar 5a4963: OUTPUT«(False)␤»

[22:24] <gfldex> m: say True[0]

[22:24] <camelia> rakudo-moar 5a4963: OUTPUT«True␤»

[22:24] *** itaipu joined
[22:24] <kyclark> Oh, hmm, the 2nd one doesn't work for me at home

[22:24] <gfldex> Bools are not Ints

[22:26] <kyclark> m: True{False}

[22:26] <camelia> rakudo-moar 5a4963: OUTPUT«Type Bool does not support associative indexing.␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[22:26] <gfldex> it's an enum that is declared very early in the settings

[22:26] <kyclark> That blows up my REPL, BTW

[22:27] <gfldex> they implement the role Enumeration (that we don't got doced yet)

[22:27] <Roamer`> yeah, well, I know that bools are enums, so enums are... what... something weird that has a pair aspect?

[22:27] <Roamer`> okay, that's interesting

[22:27] <Roamer`> ...will it stay that way? :) or has it not been documented because it may actually change? :)

[22:29] <gfldex> https://github.com/rakudo/rakudo/blob/nom/src/core/Enumeration.pm

[22:29] <gfldex> i need to check roast

[22:30] <gfldex> there are no spectests for the role, so I wont add them to the docs

[22:30] *** Peter_R joined
[22:31] <Roamer`> nice... so yesterday I was forcibly remined that a set is more like a hash than a list, today I learned that an enum is secretly a pair... it seems that this type system has turtl... err, types all the way down :)

[22:31] <Roamer`> (which is certainly not a bad thing)

[22:31] <Roamer`> gfldex, yeah, keeping it as an implementation detail makes sense

[22:31] <gfldex> to come back to why [0] works on enums. Pretty much all types got Any in their inheritance chain and as such can be turned into a list.

[22:32] <gfldex> actually there should be spec tests

[22:33] <gfldex> if you want to type check if you got an enum you need to match against Enumeration

[22:33] <gfldex> m: say True ~~ Enumeration, Bool ~~ Enumeration

[22:33] <camelia> rakudo-moar 5a4963: OUTPUT«FalseFalse␤»

[22:33] <gfldex> that might actually be a bug

[22:34] <gfldex> m: my enum E <:a(1) b>; say E ~~ Enumeration

[22:34] <camelia> rakudo-moar 5a4963: OUTPUT«False␤»

[22:35] <gfldex> that's an introspection hole (in my eyes)

[22:35] <dalek> doc: 6b34606 | (Jan-Olof Hendig)++ | doc/Type/Thread.pod:

[22:35] <dalek> doc: Added docs for Thread.join

[22:35] <dalek> doc: review: https://github.com/perl6/doc/commit/6b34606062

[22:37] <kyclark> So, this works:

[22:37] <kyclark> m:  my $a = "foo"; my $b = "boo"; my @match = $a.comb Zeq $b.comb; my @bad = grep * == False, @match; say @bad;

[22:37] <camelia> rakudo-moar 5a4963: OUTPUT«[False]␤»

[22:37] <kyclark> How did I miss this before?

[22:39] <Roamer`> kyclark, I thought you were also interested in the positions...

[22:39] <kyclark> That, too

[22:39] <Roamer`> that's why I didn't suggest it back then

[22:39] <Roamer`> (and also I wasn't looking in this window back when you asked camelia about grep True, I rejoined later)

[22:39] <gfldex> m: my $s1 = "hello world"; my $s2 = "hello camelia"; my Str $target; for $s1.comb Z, $s2.comb -> [$l, $r] { $target ~= $l eq $r ?? " " !! $r }; say ($s1, $target, $s2).join("\n");

[22:39] <camelia> rakudo-moar 5a4963: OUTPUT«hello world␤      camel␤hello camelia␤»

[22:40] <gfldex> i'm pretty sure that is what you want

[22:41] <Roamer`> ah, that's nifty

[22:41] *** nicq20 left
[22:43] <kyclark> http://pastie.org/10893466 This basically does what I want.

[22:44] <kyclark> Just repasted with sample in/output

[22:44] *** jjido left
[22:44] *** ZoffixLappy joined
[22:45] * ZoffixLappy waves from the Damian Conway's talk :}

[22:45] <gfldex> you may want to replace `say` with `put`

[22:45] <kyclark> What is the difference?

[22:46] <gfldex> say will truncate long outputs

[22:47] <kyclark> Now why would it do that?

[22:47] *** jjido joined
[22:47] <gfldex> say was cool before dd

[22:47] <ZoffixLappy> <gfldex> 	Bools are not Ints

[22:47] <ZoffixLappy> m: say True ~~ Int # they actually are an Int enum

[22:47] <camelia> rakudo-moar 5a4963: OUTPUT«True␤»

[22:49] <ZoffixLappy> kyclark, say is output for humans to read stuff. For more exact tool use put. say calls "gist" method :)

[22:49] <ZoffixLappy> m: class Foo { method gist { "just brief stuff" }; method Str { "details" } }; say, put given Foo.new

[22:49] <camelia> rakudo-moar 5a4963: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of bare "say"; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument, or use &say to refer to the function as a noun␤at <tmp>:1␤------> 3tuff" }; method Str …»

[22:49] <kyclark> OK, I thought "say" was just "print" + NL

[22:50] <ZoffixLappy> m: class Foo { method gist { "just brief stuff" }; method Str { "details" } }; .say, .put given Foo.new

[22:50] <camelia> rakudo-moar 5a4963: OUTPUT«just brief stuff␤details␤»

[22:50] <gfldex> .say is nice if you don't want log/debug output fill up your harddisk/screen

[22:50] <ZoffixLappy> kyclark, only in Perl 5 :)

[22:50] <Roamer`> kyclark, just for the record, if you only need @bad for the count, you could do something weird like say @matches.grep(* == False).iterator.count-only

[22:50] <ZoffixLappy> welll. and other langs that do that I guess :)

[22:50] <Roamer`> m: my @matches = (True, True, False, True, False); say @matches.grep(!*).iterator.count-only;

[22:50] <camelia> rakudo-moar 5a4963: OUTPUT«Method 'count-only' not found for invocant of class '<anon|158132656>'␤  in block <unit> at <tmp> line 1␤␤»

[22:50] <ZoffixLappy> https://docs.perl6.org/routine/say

[22:51] <Roamer`> m: use v6.c; my @matches = (True, True, False, True, False); say @matches.grep(!*).iterator.count-only;

[22:51] <camelia> rakudo-moar 5a4963: OUTPUT«Method 'count-only' not found for invocant of class '<anon|158132656>'␤  in block <unit> at <tmp> line 1␤␤»

[22:51] <Roamer`> err, what? it works for me here in 2016.06...

[22:51] *** addison left
[22:51] <ZoffixLappy> Roamer`, there were changes with that recently :)

[22:52] <ZoffixLappy> Roamer`, IIRC we're awaiting a change in MoarVM for that to work again

[22:52] <kyclark> Roamer`, that is great to know.  Thanks.

[22:52] <gfldex> there was a bug that made .count-only go away, but may come back soon

[22:55] <kyclark> Thanks for your patience and help!  Laters.

[22:55] *** kyclark left
[22:56] *** kyclark joined
[22:56] *** kyclark left
[22:56] *** jack_rabbit joined
[22:56] <gfldex> m: sub s { dd @_ }; dd &s.signature

[22:56] <camelia> rakudo-moar 5a4963: OUTPUT«:(*@_)␤»

[22:57] <gfldex> m: sub s { dd @_, %_ }; dd &s.signature

[22:57] <camelia> rakudo-moar 5a4963: OUTPUT«:(*@_, *%_)␤»

[22:57] <gfldex> now that's just cheating!

[22:57] <Roamer`> :)

[22:59] <jnthn> gfldex: It's actually been designed that way in S06 for donkeys years, iirc :)

[22:59] <Roamer`> okay, I'm off for the night... thanks for the patience and the insights from me, too!

[22:59] <dalek> doc: 43ac722 | (Zoffix Znet)++ | doc/Language/typesystem.pod:

[22:59] <dalek> doc: Improve :$attr shortcut docs

[22:59] <dalek> doc: review: https://github.com/perl6/doc/commit/43ac7226df

[22:59] <ZoffixLappy> That's it. I've now made a commit to Perl 6 while at a Perl 6 talk :)

[22:59] * ZoffixLappy is hardcore ^_^

[23:00] <gfldex> you are very commited to Perl 6

[23:00] <ZoffixLappy> Well, I'm not playing with the full deck, but not yet committed :P

[23:01] *** jjido left
[23:01] <ZoffixLappy> That commit isn't perfect though. The shortcut works with hashes too. I'm unsure what's the best place to document that stuff.

[23:02] <ZoffixLappy> m: my $foo = 'foo'; my %h = :$foo;

[23:02] <camelia> rakudo-moar 5a4963: ( no output )

[23:02] <ZoffixLappy> m: my $foo = 'foo'; my %h = :$foo; say %h

[23:02] <camelia> rakudo-moar 5a4963: OUTPUT«{foo => foo}␤»

[23:02] *** jjido joined
[23:05] *** sortiz joined
[23:05] <ZoffixLappy> damn. big crowd up in here :)

[23:05] <ZoffixLappy> Yey Perl 6 \o/

[23:06] <sortiz> \o #perl6

[23:06] <ZoffixLappy> \o

[23:06] *** itaipu left
[23:08] <dalek> doc: 5a75e16 | (Wenzel P. P. Peppmeyer)++ | doc/Language/functions.pod:

[23:08] <dalek> doc: doc automatic signatures for @_ and %_

[23:08] <dalek> doc: review: https://github.com/perl6/doc/commit/5a75e167ca

[23:09] *** jjido left
[23:10] *** firstdayonthejob left
[23:10] *** girafe left
[23:10] *** jjido joined
[23:12] *** addison joined
[23:13] *** cdg joined
[23:21] *** labster left
[23:22] *** skids joined
[23:23] <ZoffixLappy> m: sub infix:<😸> { $^a ~ $^b }; say 'foo' 😸 'bar' 😸 'mer'

[23:23] <camelia> rakudo-moar 5a4963: OUTPUT«foobarmer␤»

[23:23] <ZoffixLappy> Damian wanted this to be the concat op :)

[23:27] <timotimo> is that some fancy unicode character? my terminal doesn't how it

[23:28] *** mcsnolte left
[23:28] <ZoffixLappy> .u 😸

[23:28] <yoleaux> U+1F638 GRINNING CAT FACE WITH SMILING EYES [So] (😸)

[23:28] <ZoffixLappy> Well, he just said "cat emoji" so I'm guessing there :P

[23:29] <timotimo> oh!

[23:30] <timotimo> fantastic

[23:33] *** tbrowder left
[23:38] <ZoffixLappy> m: my %h = :foo; sub bar (%h) { say %h; %h<foo> = 42; say %h }; bar %h; say %h

[23:38] <camelia> rakudo-moar 5a4963: OUTPUT«{foo => True}␤{foo => 42}␤{foo => 42}␤»

[23:38] <ZoffixLappy> This is pretty LTA :(

[23:39] <ZoffixLappy> "this" being ability to mutate the contents

[23:39] *** huggable left
[23:40] *** huggable joined
[23:40] *** addison left
[23:40] <ZoffixLappy> m: my @h = :foo; sub bar (@h) { say @h; @h[0] = 42; say @h }; bar @h; say @h

[23:40] <camelia> rakudo-moar 5a4963: OUTPUT«[foo => True]␤[42]␤[42]␤»

[23:40] <gfldex> m: my %h = :foo; sub bar (%h is copy) { say %h; %h<foo> = 42; say %h }; bar %h; say %h

[23:40] <camelia> rakudo-moar 5a4963: OUTPUT«{foo => True}␤{foo => 42}␤{foo => True}␤»

[23:41] <gfldex> m: my %h = :foo; sub bar (%h is readonly) { say %h; %h<foo> = 42; say %h }; bar %h; say %h

[23:41] <camelia> rakudo-moar 5a4963: OUTPUT«{foo => True}␤{foo => 42}␤{foo => 42}␤»

[23:46] <ZoffixLappy> bisect: my @h = :foo; sub bar (@h) { say @h; @h[0] = 42; say @h }; bar @h; say @h

[23:46] <bisectable> ZoffixLappy: on both starting points the exit code is 0 and the output is identical as well

[23:48] <sortiz> Your are passing mutable containers by reference, no?

[23:49] <ZoffixLappy> No idea... Damian just said params are immutable and I recalled they weren't in this way, so I was wondering if it were a bug

[23:49] <gfldex> m: my %h = :foo; sub bar (%h is readonly) { say %h; %h = (); say %h }; bar %h; say %h

[23:49] <camelia> rakudo-moar 5a4963: OUTPUT«{foo => True}␤{}␤{}␤»

[23:50] <gfldex> what exactly is readonly in this example?

[23:50] <ZoffixLappy> no idea

[23:50] <gfldex> so either the trait should complain or the hash should become readonly

[23:53] *** tbrowder joined
[23:54] <tbrowder> please consider rakudo PR: https://github.com/rakudo/rakudo/pull/805 

[23:57] <sortiz> 'is readonly' in a subroutine parameter is a NOP, 'cus is the default, so do not change the container semantic.

