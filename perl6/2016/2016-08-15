[00:00] <ugexe> m: module XXX { sub foo() is export { 42 }; }; import XXX; say foo; my &foo = sub { 43 }; say foo;

[00:00] <camelia> rakudo-moar ee8a25: OUTPUT«Potential difficulties:␤    Redeclaration of symbol &foo␤    at <tmp>:1␤    ------> 3 { 42 }; }; import XXX; say foo; my &foo7⏏5 = sub { 43 }; say foo;␤Cannot invoke this object (REPR: Uninstantiable; Callable)␤  in block <unit> at <tmp> li…»

[00:01] <ugexe> first example returns 43 after a warning. second example blows up when trying to call foo() before the re-declaration 

[00:06] *** labster joined
[00:12] *** ZoffixLappy joined
[00:13] <ZoffixLappy> m: sub Levenshtein {}; Levenshtei();

[00:13] <camelia> rakudo-moar ee8a25: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    Levenshtei used at line 1␤␤»

[00:13] <ZoffixLappy> Didn't Perl 6 make suggestions for mis-typed sub names?

[00:13] <ZoffixLappy> Oh

[00:13] <ZoffixLappy> m: sub levenshtein {}; levenshtei();

[00:13] <camelia> rakudo-moar ee8a25: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    levenshtei used at line 1. Did you mean 'levenshtein'?␤␤»

[00:13] <ZoffixLappy> I wonder how come it didn't work on a caps. It was just off by one letter.

[00:14] *** pierre_ joined
[00:14] <timotimo> you're thinking of it wrong

[00:15] <timotimo> we're not looking through subs when you've typo'd something that looks like a Type (because upper case first letter)

[00:15] <ZoffixLappy> Ahh

[00:15] <ZoffixLappy> Thanks :-0

[00:15] <ZoffixLappy> *:)

[00:18] *** sufrostico left
[00:20] *** canopus left
[00:26] <timotimo> i better be the one to answer to this, as i'm the one who wrote that stuff :)

[00:26] *** rindolf left
[00:27] *** canopus joined
[00:28] <ZoffixLappy> m: my $seq = (1, 1, * + * … * > 100); .say for |$seq.cache; say $_² for |$seq.cache;

[00:28] <camelia> rakudo-moar ee8a25: OUTPUT«1␤1␤2␤3␤5␤8␤13␤21␤34␤55␤89␤144␤1␤1␤4␤9␤25␤64␤169␤441␤1156␤3025␤7921␤20736␤»

[00:28] <ZoffixLappy> huh

[00:28] <ZoffixLappy> Oh... never mind

[00:28] <ZoffixLappy> TIL: editing code in your article is not the same as editing code in the file you're attempting to run %)

[00:28] <timotimo> :)

[00:38] *** mvorg left
[00:43] <ZoffixLappy> m: my $seq = (1, 1, * + * … * > 10); $seq[0..6].join(', ').say; $seq[0..6].map({ $_² }).join(', ').say;

[00:43] <camelia> rakudo-moar ee8a25: OUTPUT«1, 1, 2, 3, 5, 8, 13␤1, 1, 4, 9, 25, 64, 169␤»

[00:43] <ZoffixLappy> m: my $seq = (1, 1, * + * … * > 10); $seq.join(', ').say; $seq.map({ $_² }).join(', ').say;

[00:43] <camelia> rakudo-moar ee8a25: OUTPUT«1, 1, 2, 3, 5, 8, 13␤This Seq has already been iterated, and its values consumed␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»

[00:44] <ZoffixLappy> I'm curious, why doesn't the first version also give an error? Wouldn't taking a slice count as "iterating"? What difference is there between the two examples?

[00:44] <gfldex> m: my $seq = (1, 1, * + * … * > 10); $seq[0..6].^name.say

[00:44] <camelia> rakudo-moar ee8a25: OUTPUT«List␤»

[00:45] <gfldex> it actually creates a new List

[00:45] <ZoffixLappy> Sure, but it has to iterate over a Seq to get that List, doesn't it?

[00:46] <gfldex> it may clone the original Seq first, what I would not count as iteration.

[00:46] <ZoffixLappy> Ah

[00:47] <ZoffixLappy> Ohh

[00:47] <ZoffixLappy> m: my $seq = (1, 1, * + * … * > 10); $seq[0..6].join(', ').say; $seq.map({ $_² }).join(', ').say;

[00:47] <camelia> rakudo-moar ee8a25: OUTPUT«1, 1, 2, 3, 5, 8, 13␤This Seq has already been iterated, and its values consumed␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»

[00:47] <ZoffixLappy> It does iterate over it, it's just the second slice gives me the .cache (or something similar to that reasoning)

[00:48] <timotimo> huh

[00:49] <ZoffixLappy> m: my $seq = (1, 1, * + * … * > 10); $seq.cache.join(', ').say; $seq.cache.map({ $_² }).join(', ').say;

[00:49] <camelia> rakudo-moar ee8a25: OUTPUT«1, 1, 2, 3, 5, 8, 13␤1, 1, 4, 9, 25, 64, 169␤»

[00:49] <ZoffixLappy> m: my $seq = (1, 1, * + * … * > 10); $seq.cache.join(', ').say; $seq.map({ $_² }).join(', ').say;

[00:49] <camelia> rakudo-moar ee8a25: OUTPUT«1, 1, 2, 3, 5, 8, 13␤This Seq has already been iterated, and its values consumed␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»

[00:49] <ZoffixLappy> That's what I imagine it being similar to.

[00:49] *** kurahaupo left
[00:53] *** kurahaupo joined
[00:54] *** mohae joined
[00:54] *** pierre_ left
[00:56] *** rkazak left
[00:56] *** kurahaupo left
[00:57] *** pierre_ joined
[00:58] *** mohae_ left
[01:01] *** rkazak joined
[01:04] <ZoffixLappy> Rakudo got three language braids, right: Perl 6, Regex, and Quote?

[01:05] <timotimo> m: BEGIN say %*LANG.keys

[01:05] <camelia> rakudo-moar ee8a25: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤An exception occurred while evaluating a BEGIN␤at <tmp>:1␤Exception details:␤  5===SORRY!5=== Error while compiling ␤  Cannot find method 'keys': no method cache and no .^find_method␤  at :␤»

[01:05] <timotimo> hm

[01:05] <ZoffixLappy> m: BEGIN say %*LANG

[01:05] <camelia> rakudo-moar ee8a25: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤An exception occurred while evaluating a BEGIN␤at <tmp>:1␤Exception details:␤  5===SORRY!5=== Error while compiling ␤  Method 'WHICH' not found for invocant of class 'Perl6::Grammar'␤  at :␤»

[01:05] <timotimo> hehe.

[01:05] <ZoffixLappy> :D

[01:05] <timotimo> probably need to do nqp ops to it

[01:06] <timotimo> m: BEGIN for %*LANG { say $_ }

[01:06] <camelia> rakudo-moar ee8a25: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤An exception occurred while evaluating a BEGIN␤at <tmp>:1␤Exception details:␤  5===SORRY!5=== Error while compiling ␤  Cannot find method 'map': no method cache and no .^find_method␤  at :␤»

[01:06] <timotimo> *shrug*

[01:06] <ZoffixLappy> Oh well, not overly important.

[01:06] <timotimo> too tired to bother

[01:06] <ZoffixLappy> Go to bed :)

[01:06] <timotimo> i will at some point

[01:08] <gfldex> signatures are another language

[01:08] <ZoffixLappy> :o

[01:08] <timotimo> um ... they are?

[01:08] *** rkazak left
[01:09] <gfldex> i don't know if the grammar is naming them as such but there are enough different rules in sigs to make that distinction valid

[01:09] <timotimo> ah

[01:09] <timotimo> we were wondering about the language braid, though

[01:10] <gfldex> and they show up in 3 different spots that are not so clearly divided by a set of {}

[01:10] <timotimo> in roles' [], in sub's/method's (...) and between -> and {

[01:10] <timotimo> right?

[01:10] <timotimo> well, you can also have a signature literal with :( ... )

[01:11] <gfldex> in :() and my ( Int, ($, @))

[01:11] <timotimo> ah

[01:11] <gfldex> not sure if you can where clauses in destructuring tho

[01:12] <timotimo> we probably parse it, though we may not code-gen it properly

[01:13] <gfldex> m: dd my ($i, ($j, $k where * == 3)) = (1,(2,3));

[01:13] <camelia> rakudo-moar ee8a25: OUTPUT«(1, $(2, 3))␤»

[01:13] <gfldex> m: dd my ($i, ($j, $k where * == 4)) = (1,(2,3));

[01:13] <camelia> rakudo-moar ee8a25: OUTPUT«(1, $(2, 3))␤»

[01:13] <gfldex> m: dd my ($i, ($j, $k where * == 4)) = (1,(2,3)); say $k

[01:13] <camelia> rakudo-moar ee8a25: OUTPUT«(1, $(2, 3))␤(Mu)␤»

[01:13] <gfldex> m: dd my ($i, ($j, $k where * == 4)) = (1,(2,3)); say $i, $j, $k

[01:13] <camelia> rakudo-moar ee8a25: OUTPUT«(1, $(2, 3))␤1(Mu)(Mu)␤»

[01:13] <timotimo> now, should we give an NYI error there?

[01:13] <timotimo> huh

[01:14] <gfldex> at least $j should have a value, better the whole expression should throw up

[01:14] <timotimo> m: my ($i, ($j, $k where * == 4)) = (1,(2,3)); say $i, $j, $k

[01:14] <camelia> rakudo-moar ee8a25: OUTPUT«1(Mu)(Mu)␤»

[01:14] <gfldex> could you rakudo bug this please? my tea is getting cold :(

[01:15] <timotimo> let's see

[01:15] <gfldex> m: dd my ($i, ($j, $k)) = (1,(2,3)); dd $i, $j, $k

[01:15] <camelia> rakudo-moar ee8a25: OUTPUT«(1, $(2, 3))␤Int $i = 1␤Mu␤Mu␤»

[01:15] <timotimo> what mail address do i use for rakudobug ...

[01:15] <gfldex> m: dd my ($i, [$j, $k]) = (1,(2,3)); dd $i, $j, $k

[01:15] <camelia> rakudo-moar ee8a25: OUTPUT«(1, [(2, 3),])␤Int $i = 1␤Mu␤Mu␤»

[01:16] <gfldex> m: dd my ($i, $k where * == 4) = (1,,3); dd $i, $k

[01:16] <camelia> rakudo-moar ee8a25: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Preceding context expects a term, but found infix , instead␤at <tmp>:1␤------> 3dd my ($i, $k where * == 4) = (1,,7⏏053); dd $i, $k␤»

[01:16] <ZoffixLappy> huggable, rakudobug

[01:16] <huggable> ZoffixLappy, [email@hidden.address] or use perl6 query on http://rt.perl.org ; see https://github.com/rakudo/rakudo/#reporting-bugs

[01:16] <ZoffixLappy> timotimo, ^

[01:16] <gfldex> m: dd my ($i, $k where * == 4) = (1,3); dd $i, $k

[01:16] <camelia> rakudo-moar ee8a25: OUTPUT«(1, 3)␤Int $i = 1␤Int $k = 3␤»

[01:16] <timotimo> ZoffixLappy: no i mean, which of *my* email addresses :)

[01:16] <ZoffixLappy> :F

[01:17] <timotimo> what should i tag that, i wonder

[01:18] <gfldex> i wanted to blog about signatures for quite some time now but I can't come up with a nice RL example

[01:18] <gfldex> i think it's a bug because the where clause is simply ignored. It should throw to be useful.

[01:19] <gfldex> m: sub f { 42 }; my $i where * == 2 = f;

[01:19] <camelia> rakudo-moar ee8a25: OUTPUT«Type check failed in assignment to $i; expected <anon> but got Int (42)␤  in block <unit> at <tmp> line 1␤␤»

[01:19] <gfldex> m: sub f { 42 }; my ($i where * == 2) = f;

[01:19] <camelia> rakudo-moar ee8a25: ( no output )

[01:19] <timotimo> i rakudobugged something

[01:20] *** jack_rabbit joined
[01:21] <gfldex> .tell TimToady you may want to spend some attention on m: sub f { 42 }; my ($i where * == 2) = f; (backlog: http://irclog.perlgeek.de/perl6/2016-08-15#i_13023085)

[01:21] <yoleaux> gfldex: I'll pass your message to TimToady.

[01:21] <gfldex> do we host irclogs somewhere under perl6.org ?

[01:22] <timotimo> we have irc.perl6.org that links to our irclog

[01:22] <timotimo> as in redirects

[01:24] <ZoffixLappy> m: class { has $!prefix = 'foo'; method has-prefix ($text) { so $text ~~ /^ $_/ given $!prefix; } }.new.has-prefix('foobar').say;

[01:24] <camelia> rakudo-moar ee8a25: OUTPUT«False␤»

[01:24] <ZoffixLappy> False? :S

[01:24] <ZoffixLappy> Ah... damned smartmatch aliasing things.

[01:25] <ZoffixLappy> Man, I this is not the first time I get burned by that :/

[01:26] <ZoffixLappy> m: class { has $!prefix = 'foo';  method has-prefix ($text) { so /^ $_/.ACCEPTS($text) given $!prefix;  } }.new.has-prefix('foobar').say;

[01:26] <camelia> rakudo-moar ee8a25: OUTPUT«False␤»

[01:26] <ZoffixLappy> :/

[01:27] *** Actualeyes left
[01:28] <ZoffixLappy> m: class { has $!prefix = 'foo'; method has-prefix ($text) { given $!prefix { so $text ~~ /^ $_/ } } }.new.has-prefix('foobar').say;

[01:28] <camelia> rakudo-moar ee8a25: OUTPUT«True␤»

[01:28] <ZoffixLappy> That's weird :/ I don't get it

[01:29] *** rkazak joined
[01:30] *** Actualeyes joined
[01:32] <timotimo> you do know we have starts-with?

[01:32] <ZoffixLappy> I do now :) 

[01:33] <ZoffixLappy> timotimo++

[01:33] <ZoffixLappy> But I still don't get why block form of given works, while postfix form doesn't :/

[01:34] <timotimo> that's above my paygrade to answer for 3:30am :)

[01:34] <gfldex> class { has $!prefix = 'foo';  method has-prefix ($text) { so { /^ $_/.ACCEPTS($text) } given $!prefix;  } }.new.has-prefix('foobar').say;

[01:34] <gfldex> m: class { has $!prefix = 'foo';  method has-prefix ($text) { so { /^ $_/.ACCEPTS($text) } given $!prefix;  } }.new.has-prefix('foobar').say;

[01:34] <camelia> rakudo-moar ee8a25: OUTPUT«True␤»

[01:34] <gfldex> m: class { has $!prefix = 'foo';  method has-prefix ($text) { /^ $_/.ACCEPTS($text) given $!prefix;  } }.new.has-prefix('foobar').say;

[01:34] <camelia> rakudo-moar ee8a25: OUTPUT«Nil␤»

[01:34] <ZoffixLappy> gfldex, but why?

[01:35] <ZoffixLappy> m: .say given 'foo';

[01:35] <camelia> rakudo-moar ee8a25: OUTPUT«foo␤»

[01:35] <gfldex> bug‽

[01:35] <ZoffixLappy> This has $_ correctly

[01:35] <ZoffixLappy> hm

[01:35] <ZoffixLappy> I wonder if the regex get made with the $_ of the block, before it gets a chance to get iterated (or given)

[01:36] *** RabidGravy left
[01:37] *** zacts joined
[01:38] *** wbill joined
[01:39] *** rkazak left
[01:43] <[Coke]> .

[01:44] <ZoffixLappy> :

[01:45] *** cyphase left
[01:45] <ZoffixLappy> I find it interesting that so many people use the dot, when attempting to see if they have messages. Why not "a"? Why not "Δ"? :)

[01:45] *** ilbot3 left
[01:47] <gfldex> maybe they have a point? :->

[01:47] *** ilbot3 joined
[01:47] <ZoffixLappy> gfldex++

[01:50] *** cyphase joined
[01:50] *** rkazak joined
[01:52] <sena_kun> ZoffixLappy, someone saw it and repeated(like me, for example). Then someone else saw how previous person did it and thought "So that's how you do it"... That's how tradition works. (:

[01:55] <ZoffixLappy> I think it has more to do with semantic meaning. "." is kind of a null sentence. If I randomly say "a" people will wonder wtf am I talking about.

[01:56] *** pierre_ left
[01:57] <sena_kun> Yeah, that's another reason I thought of(seems like I postfactum try to act smart, but still). And dot visually takes a very little space so it's easier to flow through the log.

[01:59] <ZoffixLappy> That's a curious point, because the stuff that takes no "space" at all is a space, yet no one is using it:

[01:59] <ZoffixLappy>      

[01:59] <ZoffixLappy> Because it's not a "null sentence" :D 

[01:59] <sena_kun> Ow.

[01:59] <sena_kun>    

[01:59] <sena_kun> Cool.

[01:59] <sena_kun> To be honest, I didn't knew it, lol.

[01:59] <ZoffixLappy> :)

[01:59] <sena_kun> Ah.

[01:59] *** stmuk_ left
[02:00] <sena_kun> My grammar becomes worse when morning come. It's time to sleep then.

[02:01] *** sena_kun left
[02:01] <gfldex> ✉

[02:02] *** TimToady left
[02:03] *** pierre_ joined
[02:04] *** TimToady joined
[02:07] *** stmuk_ joined
[02:08] *** pierre_ left
[02:18] *** noganex joined
[02:21] *** noganex_ left
[02:22] *** pierre_ joined
[02:26] *** ZoffixLappy left
[02:26] *** pierre_ left
[02:30] *** pierre_ joined
[02:35] *** wamba joined
[02:47] *** bob777 joined
[02:48] *** zacts left
[02:50] *** kid51 left
[02:57] *** stmuk joined
[02:59] *** stmuk_ left
[02:59] *** canopus left
[03:02] *** Actualeyes left
[03:06] *** canopus joined
[03:10] <MasterDuke> .tell moritz i commented on an open issue for each of SVG ( https://github.com/moritz/svg/issues/1 ) and SVG::Plot ( https://github.com/moritz/svg-plot/issues/8 ) that seemed to be about the same problems i am having

[03:10] <yoleaux> 14 Aug 2016 20:05Z <moritz> MasterDuke: please open an issue for your SVG::Plot problems; otherwise I'M afraid I'll forget

[03:10] <yoleaux> MasterDuke: I'll pass your message to moritz.

[03:27] *** khw left
[03:32] *** wamba left
[03:54] *** pduh left
[03:58] *** skids left
[04:03] *** mempko joined
[04:20] *** Actualeyes joined
[04:23] *** Cabanossi left
[04:25] *** Cabanossi joined
[04:26] <zostay> m: say 3 %% 2; say 3 !%% 2; say 4 %% 2; say 4 !%% 2;

[04:26] <camelia> rakudo-moar ee8a25: OUTPUT«False␤True␤True␤False␤»

[04:27] <zostay> mind blown

[04:29] *** silug left
[04:32] <zostay> m: class T { has $.foo where *.elems !%% 2 }; T.new(:foo(^3)); T.new(:foo(^4));

[04:32] <camelia> rakudo-moar ee8a25: OUTPUT«Type check failed in assignment to $!foo; expected <anon> but got Range (^4)␤  in block <unit> at <tmp> line 1␤␤»

[04:42] *** rkazak left
[04:44] *** silug joined
[04:52] *** labster left
[04:55] *** mempko left
[04:59] *** pierre_ left
[05:04] *** leego left
[05:04] *** pierre_ joined
[05:08] *** pierre_ left
[05:21] *** zengargoyle joined
[05:22] *** nightfrog left
[05:25] *** CIAvash joined
[05:26] *** mempko joined
[05:29] *** harovali1 left
[05:30] *** harovali joined
[05:37] *** BenGoldberg left
[06:08] *** pierre_ joined
[06:12] *** pierre_ left
[06:25] *** avuserow_ joined
[06:26] *** firstdayonthejob joined
[06:26] *** pierre_ joined
[06:28] *** pierre_ left
[06:28] *** pierre_ joined
[06:29] <avuserow_> hello #perl6-ians. I think I have found myself some utf-16 data of the wrong endianness (big endian I think). Any way I can efficiently transform it? `$data.decode("utf-16le")` doesn't seem to exist

[06:29] *** holyghost left
[06:29] *** holyghost joined
[06:30] <gfldex> avuserow_: please file a bug report

[06:30] *** holyghost left
[06:31] *** redhands joined
[06:39] *** Actualeyes left
[06:41] *** rkazak joined
[06:42] *** andrzejku joined
[06:44] <moritz> MasterDuke: ok, thanks

[06:44] <yoleaux> 03:10Z <MasterDuke> moritz: i commented on an open issue for each of SVG ( https://github.com/moritz/svg/issues/1 ) and SVG::Plot ( https://github.com/moritz/svg-plot/issues/8 ) that seemed to be about the same problems i am having

[06:50] *** firstdayonthejob left
[06:58] *** nightfrog joined
[06:59] *** darutoko joined
[07:03] *** rburkholder joined
[07:04] <zengargoyle> avuserow_: does your data hava a BOM?

[07:11] *** gnull joined
[07:12] *** zakharyas joined
[07:15] *** wbill left
[07:17] <zengargoyle> guess the problem is not having 'utf-16be' / 'utf-16le' / etc. in decode() right?

[07:18] <zengargoyle> decode('UTF-16') handles both BE and LE as long as there is a BOM.

[07:20] *** zakharyas left
[07:22] *** zakharyas joined
[07:25] *** redhands left
[07:33] *** pdcawley joined
[07:34] *** setty1 left
[07:34] *** pierre_ left
[07:37] *** bjz joined
[07:39] *** pierre_ joined
[07:39] *** pdcawley left
[07:40] *** holyghost joined
[07:40] *** pdcawley joined
[07:41] <holyghost> gm, just configured a system

[07:41] <holyghost> next, booze time

[07:42] * zengargoyle clink!

[07:42] <holyghost> lol

[07:42] <zengargoyle> i just put in my '2 week notice' and am way ahead of you. :P

[07:43] <holyghost> lol

[07:44] *** nadim joined
[07:44] *** nightfrog left
[07:45] <holyghost> roflmao

[07:47] * zengargoyle guess i'll have time to hack on perl6 real soon now.

[07:47] <zengargoyle> in a few days depending ...

[07:49] <zengargoyle> on whether they want their two weeks or do the OMG nuke from orbit.

[07:53] *** bjz left
[07:54] *** pierre_ left
[07:55] *** pierre_ joined
[07:57] *** movlex joined
[07:57] <zengargoyle> i'm aiming for a 6m-1y sabbatical doing perl5/perl6 stuff.  i've been trapped in a not so friendly to outside things place for the past 15 years.

[07:58] <holyghost> ok

[08:01] *** rkazak left
[08:04] * zengargoyle clink!

[08:06] *** nadim left
[08:07] *** nadim joined
[08:18] *** bjz joined
[08:18] *** domidumont joined
[08:22] *** domidumont left
[08:23] *** domidumont joined
[08:38] * holyghost clinks

[09:01] <zengargoyle> nqp/MoarVM/src/strings/ops.c MVM_string_find_encoding() has a selection of hard coded encodingings that are supported.  (vs say checking for any sort of known by underlying libraries encoding).  utf8,ascii,latin1,windows1252,utf16,utf8_c8

[09:03] <zengargoyle> avuserow_: ATM you'll need to add appropriate BOM to your data and 'UTF-16' should work.

[09:05] *** Lemy joined
[09:06] <zengargoyle> some google leaves me with the impression that Unicode Consortium may not like utf16le vs utf16be sort of distinction without a BOM.

[09:06] *** pierre_ left
[09:07] *** rburkholder left
[09:09] <zengargoyle> i.e. 'utf-16' encoding works with approptiate BOM (with LE as default) and doing utf-16 otherwise (via 'utf-16-be' without BOM) is not a desired thing.

[09:09] <zengargoyle> but i may be wrong there... :)

[09:11] <zengargoyle> like it's not really UTF-16 unless it's LE or has a BOM and should be handled otherwise.

[09:12] *** Actualeyes joined
[09:13] *** andrzejku left
[09:13] *** pierre_ joined
[09:18] *** pierre_ left
[09:18] *** pierre_ joined
[09:18] *** rburkholder joined
[09:22] *** labster joined
[09:24] *** mempko left
[09:26] <zengargoyle> my guess, the portability layer libuv only supports a few bog standard encodings and anything stranger needs to use a module (iconv or similar) that supportes everything under the sun.

[09:32] * zengargoyle torn between decode() supporing only 6-ish encodings vs supporting everything imaginable.

[09:33] <gfldex> what would a problem solver want to have?

[09:34] <zengargoyle> a problem... :)

[09:35] <zengargoyle> what sort of problem solver?

[09:35] <gfldex> a wise answer but I doubt it will help you with making up your mind if 6-ish or problem solvend

[09:35] *** AlexDaniel joined
[09:36] <gfldex> a programming language can be an exercise in programming languages or a tool for solving problems. A perfect program language is both.

[09:38] <zengargoyle> i'm mostly happy with DIY.  too many encounters with odd/bad data that most corrections need more umph than decode('X')

[09:38] <gfldex> 6-ish encoding doesn't sound like a practical consideration to me

[09:38] <zengargoyle> unless X is simple

[09:38] <zengargoyle> your input data is proper or not.

[09:40] <zengargoyle> working with the non-propper should require heavy (maybe non-portable) modules á la Encode that use like libiconv or something.

[09:40] <zengargoyle> is adding libiconv vs libuv sort of thing to core worth it?

[09:41] <zengargoyle> to also support SHIFT-JIS?

[09:41] <zengargoyle> or WINDOWS-936

[09:41] *** pierre_ left
[09:41] <gfldex> likely not and libiconv can be found on any platform, so a module makes sense

[09:42] <zengargoyle> yeah, iconv is my frienemy

[09:42] <zengargoyle> slap a BOM on BOM-less UTF-16-BE and UTF-16 will handle it.

[09:43] <zengargoyle> otherwise, maybe not really just a matter of weird encoding (re original question)

[09:44] <zengargoyle> hell, pipe through iconv if you need (but even iconv won't put a BOM on UTF-16BE, seemingly per Unicode specs about specifying encodings).

[09:46] * zengargoyle but maybe being convienient and handling le/be swapping for users isn't that bad).

[09:46] <zengargoyle> still no utf32, ... etc.

[09:47] *** pierre_ joined
[09:47] <zengargoyle> and at least doing the Linux/Mac/Windows whatever versions of whatever UTF idea they have is a decent place to be.

[09:51] *** pierre_ left
[09:51] *** pierre_ joined
[09:52] *** rburkholder left
[09:55] * zengargoyle would probably stop with decode() supporting what it does plus any UTF-XXX encodings that can be massaged into into UTF8 and let the rest be module land.

[09:56] * zengargoyle assuming most UTF things are just bit fiddling

[10:00] *** nadim_ joined
[10:04] *** nadim left
[10:13] *** grondilu joined
[10:14] *** labster left
[10:17] *** pmurias joined
[10:35] *** xinming joined
[10:41] *** domidumont left
[10:45] *** pierre_ left
[10:50] *** mvorg joined
[10:51] *** bjz left
[10:51] *** bjz joined
[10:52] <grondilu> Hello.

[10:52] <hahainternet> howdy

[10:52] <grondilu> I can define a variable as a role:  my $role = role {...}

[10:52] <grondilu> but then can I use $role to type parameters?

[10:53] <grondilu> I guess I could use a where clause, but what else?

[10:53] <grondilu> sub ($arg where $arg ~~ $role) {...}

[10:54] <grondilu> since I suppose sub ($role $arg) {...} is just wrong, isn't it?

[10:54] <grondilu> m: my $r = role {}; say (pi but $r) ~~ $r;

[10:54] <camelia> rakudo-moar ee8a25: OUTPUT«True␤»

[10:54] <grondilu> m: my $r = role {}; say (pi but role {}) ~~ $r;

[10:54] <camelia> rakudo-moar ee8a25: OUTPUT«False␤»

[10:54] <gfldex> $role will contain a type object and there is no way to convert a type object into a type capture

[10:55] <gfldex> those 2 anonymous roles are not the same thing

[10:55] <grondilu> is there a performance loss in using a where clause as opposed to a typed parameter?

[10:55] <gfldex> yes

[10:55] <grondilu> that's regrettable.

[10:55] <gfldex> at least for now.

[10:56] <gfldex> it is hard to prove equivalence of two where clauses, so the compiler can cheat less

[10:56] <grondilu> thing is, I'm thinking about a way to generate roles in user-space code.  And then create polymorph subs using these roles.

[10:57] <grondilu> I'd like to avoid using EVAL

[10:57] <gfldex> you either want macros or you may get away with type captures. Depends on what you want to do.

[10:59] <grondilu> not sure what type captures are.

[11:00] <gfldex> my role R[::T, I] { my T $i = I}; my class C does R[Int, 42] {}; dd C.new;

[11:00] <gfldex> m: my role R[::T, I] { my T $i = I}; my class C does R[Int, 42] {}; dd C.new;

[11:00] <camelia> rakudo-moar ee8a25: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Invalid typename 'I' in parameter declaration.␤at <tmp>:1␤------> 3my role R[::T, I7⏏5] { my T $i = I}; my class C does R[Int,␤»

[11:01] <gfldex> m: my role R[::T, $I] { my T $i = $I}; my class C does R[Int, 42] {}; dd C.new;

[11:01] <camelia> rakudo-moar ee8a25: OUTPUT«C.new␤»

[11:01] <gfldex> m: my role R[::T, $I] { my T $i = $I}; my class C does R[Int, 42] {}; dd C.new.i;

[11:01] <camelia> rakudo-moar ee8a25: OUTPUT«Method 'i' not found for invocant of class 'C'␤  in block <unit> at <tmp> line 1␤␤»

[11:01] <gfldex> m: my role R[::T, $I] { has T $i = $I}; my class C does R[Int, 42] {}; dd C.new

[11:01] <camelia> rakudo-moar ee8a25: OUTPUT«C.new␤»

[11:01] <gfldex> m: my role R[::T, $I] { has T $i = $I}; my class C does R[Int, 42] {}; dd C.new.i

[11:01] <camelia> rakudo-moar ee8a25: OUTPUT«Method 'i' not found for invocant of class 'C'␤  in block <unit> at <tmp> line 1␤␤»

[11:02] <gfldex> m: role R[::T, $I] { has T $.i = $I }; class C does R[Int, 42] {}; dd C.new.i

[11:02] <camelia> rakudo-moar ee8a25: OUTPUT«42␤»

[11:03] <hahainternet> ^ that's very cool

[11:04] <grondilu> oh yeah, parametric types.

[11:04] <grondilu> that shoud do.

[11:04] <grondilu> And I bet I can use them as parameter contraints.

[11:05] <grondilu> m: role R[$i] { has $.i = $i }; sub (R[rand] $) {}

[11:05] <camelia> rakudo-moar ee8a25: ( no output )

[11:05] <grondilu> nice

[11:05] <gfldex> there only limitations on type captures are the boundery between modules. And that's a bug.

[11:06] <llfourn> ^ hmmm

[11:08] <llfourn> m: sub wtf { say "ran"; rand }; role R[$i] { }; sub foo(R[wtf] $) { }; try foo(R); try foo(R)

[11:08] <camelia> rakudo-moar ee8a25: OUTPUT«ran␤»

[11:08] <llfourn> I guess it runs at compile time

[11:09] <llfourn> m: sub wtf { say "ran"; rand }; role R[$i] { }; sub foo(R[wtf] $) { }; BEGIN say "compile"; try foo(R); try foo(R) # yes

[11:09] <camelia> rakudo-moar ee8a25: OUTPUT«ran␤compile␤»

[11:09] <gfldex> it should and I should doc that :)

[11:09] <llfourn> gfldex++ # doc-ing

[11:10] *** Actualeyes left
[11:12] <llfourn> m: sub wtf { say "ran"; rand }; role R[$i] { }; say R[wtf] ~~ R[wtf]; BEGIN say "compiling" # this is runtime though

[11:12] <camelia> rakudo-moar ee8a25: OUTPUT«compiling␤ran␤ran␤False␤»

[11:15] *** torbjorn left
[11:20] *** rindolf joined
[11:22] <grondilu> for those curious, it was about translating https://github.com/weshoke/versor.js.   My Clifford module does most of it, but not nearly as optimized.

[11:22] *** pierre_ joined
[11:23] *** kid51 joined
[11:23] *** Actualeyes joined
[11:26] *** pierre_ left
[11:28] *** sftp left
[11:30] *** RabidGravy joined
[11:36] *** pierre_ joined
[12:16] <AlexDaniel> gfldex: by the way, regarding comment editing. I just realized that some time ago I edited your issue (#838) to make it a todo list. Should I refrain from doing so next time?

[12:23] <gfldex> that's no problem

[12:25] <AlexDaniel> ok

[12:27] *** Sgeo_ left
[12:32] *** n1lp7r joined
[12:34] *** wamba joined
[12:47] *** dLeCamarae joined
[12:51] *** prammer joined
[12:52] *** prammer left
[12:55] *** cdg joined
[12:56] * lizmat starts working on the Perl 6 Weekly while she's awake

[12:59] * markk sends hugs to the -hopefully speedily recovering- lizmat 

[12:59] <lizmat> thanks!  :-)

[13:00] <AlexDaniel> shit. Weeks fly by so fast

[13:01] <gfldex> lizmat: docs had mostly housekeeping, noteable are https://docs.perl6.org/language/functions#sub_USAGE_, corrections in https://docs.perl6.org/syntax/gather%20take and addition of https://docs.perl6.org/language/typesystem#Role_Arguments

[13:02] <timotimo> lizmat: scanning for literal strings in an :i regex is now not catastrophically slow and memory-hungry! :)

[13:03] <timotimo> well, for big haystack strings anyway

[13:03] <lizmat> timotimo: and that is news ?

[13:03] <timotimo> in short haystack strings you wouldn't notice anything, i'm sure

[13:03] <timotimo> i *think* that went in last week

[13:03] <timotimo>  let me confirm that

[13:03] <lizmat> ah, *not* memory hungry

[13:03] <lizmat> :-)

[13:03] <lizmat> guess I'm not awake enough yet...

[13:03] <timotimo> yup, tuesday of last week i made that commit

[13:03] *** smls joined
[13:04] <lizmat> .oO( it only hurst when I breathe :-)

[13:04] <lizmat> *hurts

[13:04] <lizmat> *sigh*

[13:04] *** perlpilot joined
[13:04] <timotimo> haha, i just looked over my commit and it said "haystacklc" and i thought "wow, that's a really, really bad typo"

[13:04] <timotimo> turns out that's just how i called the "haystack converted to lower case" variable %)

[13:05] *** mcmillhj joined
[13:11] *** andrzejku joined
[13:14] <gfldex> should .wrap do something reasonable on a sub that returns gather ?

[13:15] <timotimo> i don't see a problem with that

[13:15] <jnthn> Why would .wrap care?

[13:15] *** holyghost left
[13:16] <jnthn> (I'd expect it to be orthogonal to the type of the return value of the wrapped thing)

[13:18] *** cdg left
[13:20] <gfldex> m: sub f(){ gather for ^20 { take .Str } }; &f.wrap(-> |c { say 'oi!'; my $r = callsame; note &c.name ~ " called with " ~ c.perl ~ " returned " ~ $r }); say f()[^10]

[13:20] <camelia> rakudo-moar ee8a25: OUTPUT«oi!␤Use of Nil in string context  in block  at <tmp> line 1␤ called with \() returned 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19␤Index out of range. Is: 1, should be in 0..0␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in b…»

[13:20] <gfldex> m: sub f(){ lazy gather for ^20 { take .Str } }; &f.wrap(-> |c { say 'oi!'; my $r = callsame; note &c.name ~ " called with " ~ c.perl ~ " returned " ~ $r }); say f()[^10]

[13:20] <camelia> rakudo-moar ee8a25: OUTPUT«oi!␤Use of Nil in string context  in block  at <tmp> line 1␤ called with \() returned ...␤Index out of range. Is: 1, should be in 0..0␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[13:23] <gfldex> the Seq is eaten up (no surprise) and the .name is gone.

[13:23] *** cdg joined
[13:24] <gfldex> but I cant reproduce what I wanted to. In my example I get a Seq of Nil. All values are Nil. I will try again later.

[13:24] <jnthn> Hm, eaten up is a bit odd in that a second attempt to iterate a Seq is an explicit exception...

[13:24] <jnthn> (Not just an empty thing)

[13:25] *** cyphase left
[13:25] <jnthn> I wonder if callsame is guilty of doing something bad

[13:25] <timotimo> um, hold on

[13:25] <timotimo> no,you're just returning the result of nome

[13:25] <timotimo> note

[13:25] <gfldex> m: sub f(){ lazy gather for ^20 { take .Str } }; &f.wrap(-> |c { say 'oi!'; my $r = callsame; note &c.name ~ " called with " ~ c.perl ~ " returned " ~ $r; $r }); say f()[^10]

[13:25] <camelia> rakudo-moar ee8a25: OUTPUT«oi!␤Use of Nil in string context  in block  at <tmp> line 1␤ called with \() returned ...␤(0 1 2 3 4 5 6 7 8 9)␤»

[13:25] <timotimo> m: sub f(){ lazy gather for ^20 { take .Str } }; &f.wrap(-> |c { say 'oi!'; my $r = callsame; }; say f()[^10]

[13:25] <camelia> rakudo-moar ee8a25: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' ␤at <tmp>:1␤------> 3'oi!'; my $r = callsame; }; say f()[^10]7⏏5<EOL>␤    expecting any of:␤        postfix␤»

[13:25] <gfldex> indeed

[13:25] <timotimo> m: sub f(){ lazy gather for ^20 { take .Str } }; &f.wrap(-> |c { say 'oi!'; my $r = callsame; }); say f()[^10]

[13:25] <camelia> rakudo-moar ee8a25: OUTPUT«oi!␤(0 1 2 3 4 5 6 7 8 9)␤»

[13:26] *** skids joined
[13:26] *** rindolf left
[13:27] <timotimo> i'm pretty proud that i immediately spotted that :)

[13:27] <jnthn> oh, duh, I missed it :P

[13:27] <gfldex> i made the same mistake in my example but with an if-statement at the end. That was the Nil source.

[13:27] <gfldex> it's all good :)

[13:28] *** cdg left
[13:28] <smls> On the topic of gather/take subs, is there an easier way to use recursion with them than to split it into two subs?

[13:29] <smls> See the second snioppet here, for an example: http://rosettacode.org/wiki/Walk_a_directory/Recursively#Perl_6

[13:29] *** cdg joined
[13:29] <gfldex> but i don't really want to wrap the sub, I want to watch the take. Output debug message for every 20 values.

[13:30] *** cyphase joined
[13:30] <gfldex> smls: see https://github.com/perl6/doc/blob/master/util/list-missing-methods.p6#L54

[13:30] <jnthn> smls: That's not a great example in that it calls dir() twice :)

[13:30] <jnthn> (for the same directory)

[13:30] <jnthn> So hits the filesytem twice

[13:30] <gfldex> it's the &?BLOCK trick

[13:31] <jnthn> Also c is clsoed over so doesn't need taking by the inner sub :)

[13:32] <smls> good points :)

[13:32] *** ChristopherBotto joined
[13:32] <gfldex> we need to show of harder on rosettacode :)

[13:32] *** andrzejku left
[13:33] <ChristopherBotto> gfldex: o/

[13:34] *** rindolf joined
[13:34] *** dLeCamarae left
[13:36] <ChristopherBotto> gfldex: I'm so sorry about editing your posts. I never thought about it being rude, but I can totally see where you're coming from now.

[13:36] <gfldex> don't worry, it's all good

[13:37] <ChristopherBotto> gfldex: Thanks! I really appreciate your work in the community. I have a lot of respect for you.

[13:40] *** wamba left
[13:42] *** prammer joined
[13:46] *** Sgeo_ joined
[13:48] *** ChristopherBotto left
[13:49] *** nightfrog joined
[13:54] *** heatsink left
[13:54] <ugexe> m: my $a := gather for 1..5 -> $i { take $i; &?BLOCK(100); }; say $a # smls

[13:54] <camelia> rakudo-moar ee8a25: OUTPUT«(1 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 1…»

[13:55] <smls> ugexe: Yeah, that was gfldex's solution too

[13:55] *** holyghost joined
[13:56] <smls> But it may require you to go to contortions to avoid having nested blocks inside the gather

[13:56] <ugexe> ah i didn't even notice that was in a gather block heh

[14:00] <gfldex> m: class C { method iterator { IterationEnd } }; for C.new { .say }

[14:00] <camelia> rakudo-moar ee8a25: OUTPUT«X::TypeCheck::Binding exception produced no message␤  in block <unit> at <tmp> line 1␤␤»

[14:00] <timotimo> good golf

[14:02] <unmatched}> m: .say for class { method iterator {IterationEnd} }

[14:02] <camelia> rakudo-moar ee8a25: OUTPUT«X::TypeCheck::Binding exception produced no message␤  in block <unit> at <tmp> line 1␤␤»

[14:02] <timotimo> m: .say for IterationEnd

[14:02] <camelia> rakudo-moar ee8a25: OUTPUT«Method 'map' not found for invocant of class 'Mu'␤  in block <unit> at <tmp> line 1␤␤»

[14:02] <timotimo> enh, fair enough

[14:02] <unmatched}> :D

[14:04] <holyghost> *lol* again, I'll stop with it :-)

[14:08] *** pmurias left
[14:11] <smls> gfldex: For some reason I can't get it to work for the find-files examples...

[14:11] <smls> https://gist.github.com/smls/1637615d59f87c66e3e724c9723d864b

[14:11] *** Possum joined
[14:12] <smls> It hangs on the .&?BLOCK call

[14:13] <gfldex> my @files = .dir; on every iteration?

[14:13] <smls> every iteration has a different directory for $_, doesn't it?

[14:14] <ugexe> smls: have you seen the last example of https://docs.perl6.org/routine/dir? it uses a stack instead of recursion, but maybe that doesnt matter for you?

[14:15] *** leedo is now known as leedo_

[14:16] *** leedo_ is now known as leedo

[14:17] <smls> too imperative :P

[14:18] <ugexe> i agree :), i've been down this same road before and couldn't find a cleaner way though :(

[14:18] <gfldex> ugexe: https://gist.github.com/gfldex/79f54dda830c88b8eb4e7f5553ae6770

[14:19] <ugexe> i end up going with map/grep instead :/ https://github.com/ugexe/Perl6-PathTools/blob/master/lib/PathTools.pm6#L3

[14:19] <smls> I think Python has "yield from" for recursive generators

[14:20] <ugexe> i stopped using &?BLOCK because it didnt work correctly in this case on jvm (but this was before 6.c)

[14:21] <timotimo> yup, yield from was much needed, but sadly came too late since i had already moved on to perl6 when it got put in :P

[14:22] <gfldex> i can't wait for autothreading to see all those ». blow up in our faces :)

[14:22] <smls> gfldex: Recursing for every file (rather than just for each directory) irks me a little, for some reason.

[14:22] <gfldex> it only recurses for dirs

[14:23] *** robinsmidsrod left
[14:23] <smls> Too bad `take |find-files ...` doesn't work like "yield from"

[14:24] <gfldex> would be nice to sort by .f, so it shows all files and then descends deeper

[14:24] *** avenj joined
[14:25] *** robinsmidsrod joined
[14:25] <gfldex> maybe a strategic wrap could yield on every recursion step

[14:25] <ugexe> to add on what gfldex said its also nice because you can reverse that order to get the order needed to delete all files and directories (which need to be empty)

[14:26] <jnthn> smls: does .take for find-files ...; not do it?

[14:26] *** zacts joined
[14:28] <smls> Looks like it does...

[14:29] <smls> https://gist.github.com/smls/c1c0b390fda76b1110ad155f5f4dd038  # seems to work

[14:30] <gfldex> .IO.dir(test => $test).sort({.d})».&?BLOCK when .IO.d

[14:30] <gfldex> that should sort dirs up

[14:30] <gfldex> m: say True <=> False;

[14:30] <camelia> rakudo-moar ee8a25: OUTPUT«More␤»

[14:31] <gfldex> m: say True cmp False;

[14:31] <camelia> rakudo-moar 8f43bb: OUTPUT«More␤»

[14:31] <gfldex> no wrong, since True is more then False and sort is ascending

[14:32] <timotimo> we did have a version of the hyperoperator that mixes up execution order

[14:32] <timotimo> i think it was removed because it was pretty expensive performance-wise?

[14:32] <timotimo> it might be enough to just mix the first and second execution, perhaps

[14:32] <timotimo> and do the rest in sequence

[14:32] <smls> jnthn: Is there much overhead for constructing a new "gather" Seq for each directory?

[14:33] <gfldex> updated: https://gist.github.com/gfldex/79f54dda830c88b8eb4e7f5553ae6770

[14:35] <jnthn> smls: Compared to the cost of the I/O, not really :)

[14:35] <smls> ok

[14:35] *** khw joined
[14:42] *** bob777 left
[14:43] <smls> Hm. Was indexing a Seq with .[^50] always eager?

[14:45] <gfldex> doesn't matter in that case because say is calling .join

[14:46] <smls> `.say for find-files(...)` prints results as they come, but `.say for find-files(...)[^50]` blocks until 50 results are available and the prints them in one go

[14:46] <smls> I thought the postcircumfix used to return a lazy list, but I may be misremembering.

[14:46] <jnthn> Indexing isn't lazy

[14:46] <[Coke]> smls: I would expect it to be eager up to the 50. how else can it satisfy your request?

[14:46] <smls> ok

[14:46] <jnthn> I think .head(50) would be

[14:48] <smls> That works, thanks

[14:50] *** pmurias joined
[14:50] <smls> jnthn: To avoid calling dir() twice, I have to re-implement its :test handing though: https://gist.github.com/smls/e4adead89c3aa8dcefd945725d2cd803

[14:51] <unmatched}> So use fatal makes warnings fatal. Are there any other pragmas similar to it?

[14:51] <smls> Do you think this is better ok to put on rosettacode to replace the old code?

[14:52] <jnthn> unmatched}: makes *failures* fatal, not warnings

[14:52] <unmatched}> jnthn: oh... seems warnings too then:

[14:52] <unmatched}> m: "foo" ~~ S/^//;

[14:52] <camelia> rakudo-moar 8f43bb: OUTPUT«Potential difficulties:␤    Smartmatch with S/// is not useful. You can use given instead: S/// given $foo␤    at <tmp>:1␤    ------> 3"foo" ~~ 7⏏5S/^//;␤»

[14:52] <unmatched}> m: use fatal; "foo" ~~ S/^//;

[14:52] <camelia> rakudo-moar 8f43bb: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Smartmatch with S/// is not useful. You can use given instead: S/// given $foo␤at <tmp>:1␤------> 3use fatal; "foo" ~~ 7⏏5S/^//;␤»

[14:53] *** mohae_ joined
[14:53] <timotimo> unmatched}: IIRC, a try around code will also cause "use fatal" to be in effect

[14:53] <jnthn> unmatched}: o.O 

[14:54] <jnthn> That looks odd 

[14:54] <unmatched}> heh... 

[14:54] *** pierre_ left
[14:55] <unmatched}> m: no worries; "foo" ~~ S/^//; say "Blah blah";

[14:55] <camelia> rakudo-moar 8f43bb: OUTPUT«Potential difficulties:␤    Smartmatch with S/// is not useful. You can use given instead: S/// given $foo␤    at <tmp>:1␤    ------> 3no worries; "foo" ~~ 7⏏5S/^//; say "Blah blah";␤Blah blah␤»

[14:55] *** mohae left
[14:56] <unmatched}>  m: quietly { "foo" ~~ S/^// }; say "Blah blah";

[14:56] <camelia> rakudo-moar 8f43bb: OUTPUT«Potential difficulties:␤    Smartmatch with S/// is not useful. You can use given instead: S/// given $foo␤    at <tmp>:1␤    ------> 3quietly { "foo" ~~ 7⏏5S/^// }; say "Blah blah";␤Blah blah␤»

[14:56] <timotimo> come-quietly-no-screaming { ... }

[14:56] <unmatched}> It's a $/.PRECURSOR.worry(...)

[14:56] <timotimo> dont-alert-the-police { ... }

[15:01] *** canopus left
[15:02] *** mempko joined
[15:04] *** zacts left
[15:10] *** canopus joined
[15:16] *** wamba joined
[15:17] <smls> ugexe: I'm reasonably happy with the updated example I just sumbitted to http://rosettacode.org/wiki/Walk_a_directory/Recursively#Perl_6

[15:17] <smls> Do you think this should also replace the kinda messy @stack munging example in https://docs.perl6.org/routine/dir ?

[15:20] <perlpilot> smls: or ... make dir() have a :recurse option  :)

[15:20] <smls> heh

[15:20] *** zakharyas left
[15:20] *** kurahaupo joined
[15:21] <perlpilot> I started on an implementation once, but got sidetracked on something else and never made it "right"

[15:21] <smls> perlpilot: I think in practice, you'd want such a function to have more control options though, and that might be too much for the built-in dir

[15:21] <unmatched}> The "Actually thrown at" bits seem a bit LTA. There was a case where it was printing it even when the actually thrown at was empty (now fixed), but now I see it's basically repeating the previous content, like here:

[15:21] <unmatched}> m: https://gist.github.com/zoffixznet/54462d18b218598b57a917a305db04be

[15:21] <camelia> rakudo-moar 8f43bb: OUTPUT«Calculating distance traveled by airplane␤Calculating distance traveled by spaceship␤Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5oops' (indicated by ⏏)␤  in sub distance at <tmp> line 1␤  in blo…»

[15:22] <unmatched}> Well, here's easier to see: https://gist.github.com/zoffixznet/94de331daef51df04c0a6d9f3a69c436

[15:22] <smls> perlpilot: e.g. you'd want it to be able to do depth-first if needed, or do a test against the whole path rather than basename, etc.

[15:22] <unmatched}> I'm really loving that subscript/superscript work on that code :D I just wish we could use subscript numerals too

[15:23] <smls> perlpilot:  and all the other countless options that GNU find has... :)

[15:23] <perlpilot> smls: I think if you can reduce all the possible options to just a few, dir() is the right place for them.  (for efficiency's sake if nothing else)

[15:24] <perlpilot> But ... I dream a little  :)

[15:24] <perlpilot> one day, when I have some free time, I'll probably try to implement it again.

[15:25] <ugexe> PathTools (and File::Tree?) do that as well

[15:40] <avuserow_> hey zengargoyle, thanks for the suggestion. I'll give it a try. This data definitely does not have a BOM in each string that I am decoding, but rather one per file. (It's an absurd format.)

[15:44] <unmatched}> I'm having trouble finding something core that returns a failure... any idea?

[15:45] <unmatched}> m: try { say (42 div 0) ~~ Failure; CATCH { default {.^name.say } } }

[15:45] <camelia> rakudo-moar 8f43bb: OUTPUT«X::Numeric::DivideByZero␤»

[15:47] <avuserow_> manually copying in a BOM works. I'm just doing: `Buf.new(@BOM, $data.list).decode("utf-16")`

[15:47] <avuserow_> and wow, zengargoyle++, this is faster than even my wrong and cheating solution of decoding as latin-1 and removing 0-value bytes!

[15:47] <unmatched}> m: sub x { (2+4i).Num }; say x.^name

[15:47] <camelia> rakudo-moar 8f43bb: OUTPUT«Can not convert 2+4i to Num: imaginary part not zero␤  in sub x at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in sub x at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[15:48] <ugexe> m: say ::("XXX").perl

[15:48] <camelia> rakudo-moar 8f43bb: OUTPUT«Failure.new(exception => X::NoSuchSymbol.new(symbol => "XXX"), backtrace => Backtrace.new)␤»

[15:48] <unmatched}> m: sub x { (1...Inf).elems }; say x.^name

[15:48] <camelia> rakudo-moar 8f43bb: OUTPUT«Failure␤»

[15:49] <unmatched}> m: sub x { EVAL "+'foo'" }; say x.^name

[15:49] <camelia> rakudo-moar 8f43bb: OUTPUT«Failure␤»

[15:50] <unmatched}> m: sub x { +'foo' }; say x.^name

[15:50] <camelia> rakudo-moar 8f43bb: OUTPUT«Failure␤»

[15:50] <unmatched}> :S

[15:50] <unmatched}> Oh, ok I think I see what my problem was

[15:51] <unmatched}> m: sub infix:<Δ> { abs $^a − $^b }; say ("foo" Δ 42).^name

[15:51] <camelia> rakudo-moar 8f43bb: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5foo' (indicated by ⏏)␤  in sub infix:<Δ> at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in sub infix:<Δ> at <tmp> line 1…»

[15:58] *** zakharyas joined
[15:58] <avuserow_> are there any tools to make p6 scripts into .exe files? thinking something like PAR or pp for Perl 5, or along the lines of py2exe for Python

[15:58] *** jeek left
[15:58] <timotimo> we don't have something for that yet, but it'll be possible at some point for sure

[15:59] <timotimo> there's been multiple attempts in the past

[15:59] <timotimo> we call it "fakexecutable" or "fakecutable"

[15:59] <harmil_wk> avuserow_: For the JVM background there's a JAR creation process that I've never touched, but I think it has large pieces of what you are asking for...

[16:00] <timotimo> having a jar still requires you to launch it as if you were using a module

[16:00] <timotimo> i.e. ./perl6-j -mMyFancyJar -e ''

[16:01] <timotimo> same with our stuff for moar so far. we might get a single file, but you'll still have to -Mblahblah -e ''

[16:01] <harmil_wk> timotimo: correct. That's what I was saying.

[16:01] <timotimo> oh, you were? OK!

[16:01] <harmil_wk> Yeah, "large pieces of what you want"

[16:01] <timotimo> hehehe.

[16:02] <ugexe> does that work for --target=moar modules?

[16:03] <harmil_wk> Once you have a JAR, you just need the runtime and some linkage glue for a main that invokes the runtime, right?

[16:03] <timotimo> yeah, because rakudo will look for .moarvm files in the -I

[16:18] *** Hor|zon joined
[16:19] *** dwarring left
[16:21] <avuserow_> yeah, I'm just doing preliminary investigation of distribution methods for a program I'm writing

[16:22] <avuserow_> I'm thinking that requiring java and having the users run `java -jar perl6.jar -jar myprogram.jar` would be okay

[16:23] <avuserow_> if we have good MSIs for p6 on windows, that might work too...

[16:23] <timotimo> java programs always have a shell script type of launcher thing with them anyway

[16:23] <mst> and they're always terrible

[16:23] <avuserow_> yeah, I mean in the sense of what they need preinstalled. I think people would be more likely to have a JVM installed than P6, sadly :P

[16:24] <timotimo> yes, always terrible. no doubt about it

[16:24] *** andrzejku joined
[16:25] <mst> right, ideally, we'd do statically compiled binary packages as well or something

[16:25] <mst> but I've got a different argument to have with the build system first ;)

[16:25] <timotimo> :)

[16:32] *** zacts joined
[16:37] *** zakharyas left
[16:38] *** zakharyas joined
[16:43] *** domidumont joined
[16:49] *** zakharyas left
[16:57] *** araujo left
[17:05] *** kyclark joined
[17:06] <kyclark> How do I printf to $*ERR?

[17:06] <smls> $*ERR.print: sprintf ...

[17:09] <timotimo> or "note sprintf ..."

[17:10] <timotimo> note will give you a \n at the end for free

[17:14] *** brrt joined
[17:17] <unmatched}> New blog post: "The Awesome Errors of Perl 6": http://perl6.party/post/The-Awesome-Errors-of-Perl-6

[17:18] *** mvorg left
[17:21] *** zacts left
[17:23] *** TEttinger left
[17:24] * brrt reads

[17:24] *** firstdayonthejob joined
[17:25] *** TEttinger joined
[17:25] <brrt> well, loads

[17:30] *** prammer left
[17:30] *** Ven joined
[17:31] *** labster joined
[17:32] *** harovali1 joined
[17:34] *** harovali left
[17:35] *** labster left
[17:37] <kyclark> Thanks.

[17:37] *** kyclark left
[17:41] *** prammer joined
[17:43] *** sena_kun joined
[17:48] *** brrt2 joined
[17:48] *** brrt left
[17:49] *** Ven left
[17:50] *** Ven joined
[17:52] *** vendethiel joined
[17:52] *** Ven left
[17:53] *** Ven joined
[17:54] *** Ven left
[17:55] *** Ven joined
[17:56] *** Ven left
[17:58] <unmatched}> m: sub term:<-1> { *-1 }; my @a = ^10; say @a[-1]

[17:58] <camelia> rakudo-moar 8f43bb: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of a negative -1 subscript to index from the end; in Perl 6 please use a function such as *-1␤at <tmp>:1␤------> 3rm:<-1> { *-1 }; my @a = ^10; say @a[-1]7⏏5<EOL>␤»

[17:58] <unmatched}> gah. Well, so much for that :(

[17:59] <unmatched}> m: sub term:<① > { *-1 }; my @a = ^10; say @a[① ]

[17:59] <camelia> rakudo-moar 8f43bb: OUTPUT«9␤»

[17:59] <unmatched}> \o/

[18:01] *** heatsink joined
[18:03] *** mcmillhj left
[18:07] *** Ven joined
[18:09] <jnthn> smls: Sorry, got dug into some $dayjob stuff and didn't get to comment on the files-files thing. It's not entirely clear whether the test handling in that code is correct also. What if the test matches *and* it's a directory?

[18:09] <jnthn> smls: Oh wait, that's the case you handled...

[18:09] <jnthn> Oh, or is it... :)

[18:10] <jnthn> I htink something is a bit odd though in that if you have a directory that matches the test it'll be included and traversed, and if you have a dir that doesn't match the test it'll be traversed, etc. :)

[18:11] <smls> Isn't that what  `find -iname ...`  does?

[18:12] <jnthn> No idea :)

[18:13] *** n1lp7r left
[18:13] *** ptolemarch joined
[18:14] <smls> Basically, traverse the whole tree and return all paths where the basename matches the test

[18:15] *** mcmillhj joined
[18:16] *** labster joined
[18:17] *** Ven left
[18:24] *** smls left
[18:26] *** domidumont left
[18:30] *** TEttinger left
[18:34] *** TEttinger joined
[18:36] *** kyclark joined
[18:37] <kyclark> Is there a framework or suggested path to test the output from Perl 6 scripts?  E.g., do I need to use ‘proc’ to get the output and then the various methods from Test?

[18:37] *** cdg left
[18:37] <lizmat> kyclark: you can assign $*OUT to some class that has a .print in it

[18:40] <avuserow_> kyclark: Test::Output in the ecosystem looks potentially useful. haven't tried it personally but worth a look

[18:40] <lizmat> m: my @log; { my $*OUT = class { method print(*@a) { @log.push(@a) } }.new; say "foo" }; dd @log

[18:40] <camelia> rakudo-moar 8f43bb: OUTPUT«Array @log = [["foo\n"],]␤»

[18:42] <unmatched}> kyclark: there's https://modules.perl6.org/repo/Test::Output and depending on your needs, take a look at roast's is_run/get_out subs. Maybe you can steal them: https://github.com/perl6/roast/blob/master/packages/Test/Util.pm

[18:42] <kyclark> Test::Output looks pretty good!  I’ll try that.  Thanks!

[18:43] *** brrt2 left
[18:47] *** rindolf left
[18:51] *** zacts joined
[18:51] *** TEttinger left
[18:54] *** Ven joined
[18:54] *** TEttinger joined
[18:57] *** Ven left
[18:57] *** domidumont joined
[18:59] *** heatsink left
[19:01] *** djbkd_ left
[19:03] *** labster left
[19:08] *** zacts left
[19:08] <AlexDaniel> unmatched}: since you explain *-42 anyway, perhaps you can also add an example with “@a[-42]”? It has an awesome error message too.

[19:08] *** Girafferson joined
[19:10] <perlpilot> AlexDaniel, unmatched} : For that same example, I was thinking it would be nice to introduce shaped arrays too:  my @a[42]; @a[50] = 7;

[19:11] <perlpilot> unmatched}: and +1 to what AlexDaniel said  :)

[19:13] *** rindolf joined
[19:15] * AlexDaniel is going to submit some LTA tickets after reading a post about awesome error messages…

[19:16] *** andrzejku left
[19:21] *** domidumont left
[19:22] *** Lemy left
[19:23] <dalek> ecosystem: e48a097 | Altai-man++ | META.list:

[19:23] <dalek> ecosystem: Add Texas::To::Uni package

[19:23] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/e48a097ed3

[19:25] <harmil_wk> We should have more modules in that namespace. Texas::To::California would be interesting.

[19:26] *** ridthyself joined
[19:26] <sena_kun> harmil_wk, I'm super-bad with naming. :-( I'll rename it if you can give me a better name.

[19:27] <sena_kun> Perhaps, it should be something like "Text::Operators-Converting" or such. Dunno.

[19:27] *** darutoko left
[19:27] <harmil_wk> I wasn't complaining. It's very clear what it's for...

[19:27] <ridthyself> greetings everyone -- sorry to interrupt -- but are Roles in PERL6 how interfaces are done?

[19:28] <AlexDaniel> sena_kun: wait… what

[19:28] <sena_kun> AlexDaniel, what "what"?

[19:28] <ridthyself> if you were to create a class to use as an interface, would you use a role?

[19:29] <ugexe> yes

[19:29] <AlexDaniel> sena_kun: so it replaces =~= with ≅, pi with π, but at the same time it replaces “” with "" and ｢｣ with Q//. What does it all mean?

[19:29] *** Lemy joined
[19:29] <sena_kun> AlexDaniel, afk for 25 minutes, sorry.

[19:30] <ugexe> m: role Foo { method bar { ... }; }; class Bar1 does Foo { }; class Bar2 { }; sub check-me(Foo $x) { say "OK" }; check-me(Bar1.new); check-me(Bar2.new)

[19:30] <camelia> rakudo-moar 8f43bb: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Method 'bar' must be implemented by Bar1 because it is required by a role␤at <tmp>:1␤»

[19:30] <sena_kun> AlexDaniel, it's a bug, obviously.

[19:30] <AlexDaniel> ah ok

[19:31] <ugexe> m: role Foo { method bar { ... }; }; class Bar1 does Foo { method bar { 1 }; }; class Bar2 { }; sub check-me(Foo $x) { say "OK" }; check-me(Bar1.new); check-me(Bar2.new)

[19:31] <camelia> rakudo-moar 8f43bb: OUTPUT«OK␤Type check failed in binding to $x; expected Foo but got Bar2 (Bar2.new)␤  in sub check-me at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[19:31] <AlexDaniel> sorry for this reaction, but I was like “WTF??? WTF???” ;)

[19:32] <AlexDaniel> hmm, there's no unicode character for triple question mark⁇

[19:32] <ridthyself> okay I understand, thanks ugexe

[19:33] <zengargoyle> avuserow_: glad it worked out into an easy hackaround.

[19:36] *** cpage_ joined
[19:36] <ridthyself> How would I have one class own another class? A Player Class owning a Player-Character class, for example...

[19:37] <ridthyself> it does not seem appropriate to say a Character is-a Player

[19:40] *** zengargoyle left
[19:41] *** zengargoyle joined
[19:43] <ugexe> what do you mean by own

[19:44] <ugexe> Inherit? Compose? Lexically scoped to an outer class?

[19:45] *** kobain joined
[19:45] *** kobain is now known as Guest17874

[19:46] *** Guest17874 is now known as jverce

[19:46] <ridthyself> if i were writing procedurally, i would make a Player struct which has a Character struct

[19:47] <ugexe> I'm not sure what you mean by "has a". class Foo { my class Bar { }; } ?

[19:47] *** jverce left
[19:47] <mst> ridthyself: not sure that's wrong with a character attribute

[19:47] <mst> well, actually, I'd have an array of

[19:48] <mst> since some players control multiple PCs

[19:48] <unmatched}> m: class Player { my class Character { has $!strength; }; has $.character = Character.new }.new.character.^name.say

[19:48] <camelia> rakudo-moar 4d85cd: OUTPUT«Player::Character␤»

[19:48] <ridthyself> oh! that could work

[19:49] <ridthyself> can I declare the Character class seperately, or do i need to declare it within the Player Class declaration?

[19:51] <mst> depends if you're planning to re-use it outside

[19:51] <ridthyself> Although I don't suppose I'll ever need Characters that aren't owned by a player, even NPC would be owned by the "world". 

[19:52] <ridthyself> yeah

[19:55] <ridthyself> thanks everyone! PERL 6 is awesome, I'm having so much fun. Peace!

[19:55] *** ridthyself left
[19:57] <timotimo> but it's just spelled "Perl" ...

[20:00] <sena_kun> AlexDaniel, this module is still 0.1, so we(or I, rather) need good parsing, good replacing mechanism, good tests, good everything... You get the tendencies. (: I converted the table from docs to Hash using emacs macro, so things happen.

[20:01] *** labster joined
[20:01] *** cdg joined
[20:02] *** TEttinger left
[20:03] <kyclark> How can I get around this error:

[20:03] <kyclark> m: my %count = A => 1, G => 5; put join ' ', %count<A C T G>

[20:03] <camelia> rakudo-moar 4d85cd: OUTPUT«Use of uninitialized value <element> of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.  in block <unit> at <tmp> line 1␤Use of uninitialized value <element> of type Any in string c…»

[20:04] <CIAvash> m: my %count = A => 1, G => 5; put join ' ', %count<A C T G>:v

[20:04] <camelia> rakudo-moar 4d85cd: OUTPUT«1 5␤»

[20:04] *** TEttinger joined
[20:05] <kyclark> What does :v do?

[20:05] <kyclark> Also, I would actually like to print 0 when nothing exists.

[20:06] <kyclark> Ah, found it (https://docs.perl6.org/syntax/$COLONv)

[20:07] <avuserow_> m: my %count = A => 1, G => 5; put join ' ', %count<A C T G>:exists

[20:07] <camelia> rakudo-moar 4d85cd: OUTPUT«True False False True␤»

[20:07] <ugexe> m: my %count = A => 1, G => 5; put join " ", map {.defined ?? $_ !!  0 }, %count<A C T G>

[20:07] <camelia> rakudo-moar 4d85cd: OUTPUT«1 0 0 5␤»

[20:07] <avuserow_> m: my %count = A => 1, G => 5; put join ' ', %count<A C T G>:exists>>.Int

[20:07] <camelia> rakudo-moar 4d85cd: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Missing << or >>␤at <tmp>:1␤------> 3 put join ' ', %count<A C T G>:exists>>.7⏏5Int␤»

[20:07] *** prammer left
[20:08] <ugexe> m: my %count = A => 1, G => 5; put join " ", map {$_ //  0}, %count<A C T G>

[20:08] <camelia> rakudo-moar 4d85cd: OUTPUT«1 0 0 5␤»

[20:08] <CIAvash> m: my %count is default(0) = A => 1, G => 5; put join ' ', %count<A C T G>

[20:08] <camelia> rakudo-moar 4d85cd: OUTPUT«1 0 0 5␤»

[20:09] <avuserow_> m: my %count = A => 1, G => 5; put join ' ', (%count<A C T G>:exists)>>.Num; # appears to work if you want 0/1 rather than True and False

[20:09] <camelia> rakudo-moar 4d85cd: OUTPUT«1 0 0 1␤»

[20:10] <kyclark> Thanks!

[20:12] <unmatched}> Just use a Bag

[20:15] <unmatched}> m: my $dna = BagHash.new: <A A G G G>; say $dna<A T C G>'

[20:15] <camelia> rakudo-moar 4d85cd: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3Hash.new: <A A G G G>; say $dna<A T C G>7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤     …»

[20:15] <unmatched}> (2 0 0 3)

[20:15] <unmatched}> stupid phone :(

[20:15] *** prammer joined
[20:15] <ugexe> you typed that on your phone? ouch

[20:16] <unmatched}> :)

[20:17] *** vendethiel left
[20:19] <harmil_wk> m: say ^3 >>*>> 2; say ^3 S[>>*>>] 2

[20:19] <camelia> rakudo-moar 4d85cd: OUTPUT«(0 2 4)␤Too few positionals passed; expected 2 arguments but got 0␤  in block <unit> at <tmp> line 1␤␤»

[20:19] <harmil_wk> Is that second form supposed to work?

[20:23] *** Wiertek joined
[20:33] <tailgate> m: my @a = (1,2,3); @a[1]:delete; say @a;

[20:33] <camelia> rakudo-moar 4d85cd: OUTPUT«[1 (Any) 3]␤»

[20:33] <tailgate> how do I delete without the (

[20:33] <tailgate> how do I delete without the (Any)?

[20:33] <avuserow_> m: my @a = <1 2 3>; splice @a, 1; say @a

[20:33] <camelia> rakudo-moar 4d85cd: OUTPUT«[1]␤»

[20:34] <timotimo> right, splice it

[20:34] <avuserow_> m: my @a = <1 2 3>; splice @a, 1, 1; say @a

[20:34] <camelia> rakudo-moar 4d85cd: OUTPUT«[1 3]␤»

[20:34] *** mvorg joined
[20:34] <tailgate> thanks

[20:37] *** trnh joined
[20:37] *** trnh left
[20:37] *** trnh joined
[20:39] *** sftp joined
[20:45] *** wamba left
[20:50] <tailgate> m: (1,2,3,1,1,2,3) ==> grep { 1 === $_};

[20:50] <camelia> rakudo-moar 4d85cd: ( no output )

[20:50] <tailgate> m: say (1,2,3,1,1,2,3) ==> grep { 1 === $_};

[20:50] <camelia> rakudo-moar 4d85cd: OUTPUT«(1 2 3 1 1 2 3)␤»

[20:50] <tailgate> m: say (1,2,3,1,1,2,3) ==> grep { 1 == $_};

[20:50] <camelia> rakudo-moar 4d85cd: OUTPUT«(1 2 3 1 1 2 3)␤»

[20:52] * unmatched} is amused by the "devs are immature" critique of Perl 6 :)

[20:52] <unmatched}> m: sub foo {}; for foo {}

[20:52] <camelia> rakudo-moar 4d85cd: OUTPUT«5===SORRY!5===␤Function 'foo' needs parens to avoid gobbling block␤at <tmp>:1␤------> 3sub foo {}; for foo {}7⏏5<EOL>␤Missing block (apparently claimed by 'foo')␤at <tmp>:1␤------> 3sub foo {}; for foo {}7⏏5<EOL>␤␤»

[20:52] <avuserow_> tailgate: try an extra set of parens between `say` and `;`. or use grep as a method or sub call.

[20:52] <unmatched}> Look! Look! It says "gobbling"! How terrible :)

[20:53] <tailgate> avuserow_: thanks, I actually couldn't duplicate the problem I was having

[20:53] <unmatched}> Programming must be boring. How dare the compiler make me chuckle :p

[20:53] <tailgate> It's a breath of fresh air after spending 8 hours as a java dev

[20:58] <CIAvash> m: 1,2,3,1,1,2,3 ==> grep(1 == *) ==> say();

[20:58] <camelia> rakudo-moar 4d85cd: OUTPUT«(1 1 1)␤»

[20:58] *** zacts joined
[20:58] <unmatched}> m: m: (1,2,3,1,1,2,3).Bag{1}

[20:58] <camelia> rakudo-moar 4d85cd: ( no output )

[20:59] <unmatched}> m: m: (1,2,3,1,1,2,3).Bag{1}.say

[20:59] <camelia> rakudo-moar 4d85cd: OUTPUT«3␤»

[20:59] *** tx0h joined
[21:00] *** tx0h left
[21:01] <tailgate> So, I have this code: https://gist.github.com/ahalbert/5cd22fafc0c383c70da0fadc0a50d614 It's giving me a single element per item found, when I want all the items. What is wrong with my code?

[21:03] *** Actualeyes left
[21:04] *** skids left
[21:04] <ugexe> (@rest ==> grep { $head eq $key($_)}, $head) # what is this meant to do?

[21:05] <tailgate> take all items in the array eq $key($_) and add head to the end

[21:05] <tailgate> it should be a push

[21:07] *** zacts left
[21:08] <tailgate> I fixed it. Thanks!

[21:13] <CIAvash> tailgate: you can use `classify` to do that

[21:14] *** mempko left
[21:18] *** mcmillhj left
[21:18] *** Actualeyes joined
[21:19] *** kyclark left
[21:20] *** kyclark joined
[21:21] <lizmat> and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2016/08/15/2016-33-where-did-we-go-wrong/

[21:22] *** prammer left
[21:23] <hoelzro> lizmat++

[21:23] *** jeek joined
[21:28] *** mcmillhj joined
[21:29] *** trnh left
[21:31] <CIAvash> lizmat++

[21:32] *** nadim_ left
[21:33] *** trnh joined
[21:35] *** Wiertek left
[21:37] *** kjs_ joined
[21:37] *** zacts joined
[21:41] *** kalkin-_ joined
[21:41] <kalkin-_> hi

[21:41] *** kalkin-_ is now known as kalkin-

[21:42] <lizmat> kalkin-  o/

[21:42] *** kjs_ left
[21:43] *** pmurias left
[21:43] *** rindolf left
[21:43] *** n1lp7r joined
[21:54] *** rkazak joined
[21:56] <zacts> hi perl6 nerds

[21:56] *** mscha joined
[21:56] * ugexe takes zacts lunch money

[21:56] *** mcmillhj left
[21:57] <zacts> ugexe: nice

[21:58] *** telex left
[21:59] <mscha> m: my @sq = (^10).map: *²; say @sq;

[21:59] <camelia> rakudo-moar 4d85cd: OUTPUT«Cannot resolve caller Numeric(Whatever: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[21:59] <mscha> m: my @sq = (^10).map: * ** 2; say @sq;

[21:59] <camelia> rakudo-moar 4d85cd: OUTPUT«[0 1 4 9 16 25 36 49 64 81]␤»

[21:59] *** mcmillhj joined
[22:00] *** telex joined
[22:07] *** CIAvash left
[22:09] *** bjz left
[22:10] <TEttinger> hm. what hashing algorithm does perl6 use? does it differ on JVM and Moar? I seem to recall something about random hashing

[22:11] <TEttinger> there's some interesting properties of the JVM's builtin hashCode functions for arrays, particularly long arrays. as in, new long[]{-1} and new long[]{0} both hash to 31

[22:11] *** mcmillhj left
[22:12] <TEttinger> ... so I kinda hope perl6 doesn't use that

[22:12] <TEttinger> (that uses Arrays.hashCode because the .hashCode method on arrays is just some variant on the memory address)

[22:15] *** zacts left
[22:15] <timotimo> moar has ut_hash in it

[22:16] <timotimo> but also, arrays are mutable, so you can't sensibly use it in a hash as an object key

[22:16] <timotimo> not without supplying the exact same object every time you want to access; which basically means you'll have to keep a list of keys around, or grab the keys off the hash, or something like that

[22:20] *** mcmillhj joined
[22:23] *** rkazak left
[22:24] *** bjz joined
[22:24] *** mcmillhj left
[22:25] *** bjz left
[22:31] *** skids joined
[22:33] *** rkazak joined
[22:34] *** mcmillhj joined
[22:37] *** harovali1 left
[22:37] *** kyclark left
[22:39] *** mcmillhj left
[22:40] *** kyclark joined
[22:40] <TEttinger> I think I only use hashing of arrays by value (preferably with a 64-bit hash) when I want to have a relatively certain statement that two caches are identical

[22:41] <timotimo> don't forget arrays can have anything they want in them

[22:41] <TEttinger> or when I know that an array isn't going to be modified by me and is internally-used only

[22:42] <timotimo> in that case you need to use something else :)

[22:42] <timotimo> like a list

[22:42] <TEttinger> mm, yeah, I mostly wanted to mention that because Java's arrays seem like they have some issues with hashing and I didn't want JVM Perl 6 to hit the same issue

[22:43] <TEttinger> I'll look up ut_hash

[22:43] <timotimo> https://www.reddit.com/r/perl/comments/4xg3hd/interesting_useful_rarely_used_idioms/d6i57le  -  would you call this an idiom? :(

[22:43] <lizmat> timotimo: the reason I mentioned it, is that it refers to Perl 6

[22:43] <timotimo> i wonder why nobody answered with the subst method/sub in perl6

[22:44] <timotimo> because that code is just ... no.

[22:44] <lizmat> timotimo: there's still time, no ?

[22:44] <timotimo> of course

[22:45] *** mcmillhj joined
[22:46] *** RabidGravy left
[22:48] *** bjz joined
[22:48] <TEttinger> huh, searching for ut_hash finds some interesting unrelated stuff https://duckduckgo.com/?q=ut_hash&ia=web

[22:49] *** bjz left
[22:49] <timotimo> oh, it's called uthash actually

[22:50] <timotimo> ..... wat.

[22:50] *** bjz joined
[22:50] *** mcmillhj left
[22:51] *** firstdayonthejob left
[22:55] <grondilu> this page about perl idioms pointed to an example that made me realize something.   In Perl often we do something like "do this\nl   or die "could not do that";".  That is putting a newline before ending the statement with a semi-colon, and add a or die $error-message; below, usually with ident.  We can't always do that in Perl 6.

[22:55] *** bjz left
[22:55] <grondilu> e.g.  do { do-stuff }\n   or die "could not do stuff";  # would fail

[22:55] <timotimo> yeah, curlies.

[22:56] <grondilu> it's very slightly LTA

[22:56] <timotimo> do we already give a good error when we find an infix op like "or" at the beginning of aline when the previous line has a } at its end?

[22:56] <grondilu> nope

[22:56] <grondilu> most likely you'll get an "undeclared routine 'or'"

[22:58] *** mcmillhj joined
[23:00] <El_Che> starting to get syntax error support for vim with syntastic, but vimscript is painful 

[23:02] <timotimo> https://gist.github.com/timo/9036c265cebe28765a8ebda6624eceb3 - what do people think?

[23:02] <El_Che> I saw that azawawi added a perl6 lint support to atom using "perl6 -c". It that the only way for now? (One of the perl5 linters on systastic uses perl -c but it's disabled out of the box because of security issues (running external code)

[23:03] <timotimo> yeah, perl6 also has that exact security issue

[23:03] <El_Che> yeah, that's what I thought

[23:04] *** mcmillhj left
[23:04] <El_Che> I am copying what they did for perl5: add a config option to enable if wanted

[23:07] <dalek> perl6-examples: 639577e | (David Warring)++ | categories/parsers/CSSGrammar.pm:

[23:07] <dalek> perl6-examples: Credit wayland76++ for CSSGGrammar example

[23:07] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/639577e444

[23:14] *** mscha left
[23:15] *** mcmillhj joined
[23:18] *** cdg left
[23:18] *** pi__ joined
[23:19] *** mcmillhj left
[23:27] *** _28_ria left
[23:28] *** _28_ria joined
[23:40] <dataangel> p6: my @f = <3 4>; say @f; my @g = [3, 4]; say @g; # what is the difference?

[23:40] <camelia> rakudo-moar 6cd6ef: OUTPUT«[3 4]␤[3 4]␤»

[23:41] *** rkazak left
[23:44] <timotimo> no difference; the assignment will take whatever values you put in and throw them into an array; that's because of the one-argument-rule, which ensures that the thing on the RHS of the = will get iterated over

[23:45] <timotimo> m: my @f = <3, 4>, <9, 9>; say @f.perl; my @g = [3, 4], [9, 9]; say @g.perl

[23:45] <camelia> rakudo-moar 6cd6ef: OUTPUT«[("3,", IntStr.new(4, "4")), ("9,", IntStr.new(9, "9"))]␤[[3, 4], [9, 9]]␤»

[23:45] <timotimo> ^- now here's a difference

[23:45] <timotimo> oh, haha

[23:45] <timotimo> man, i need to go to bed :)

[23:46] <timotimo> the difference between your two pieces of code is that the @g one won't remember how you spelled the numbers, as they'll be "only" Int objects, whereas what's in < blah > will get the IntStr (and friends) treatment

[23:46] <timotimo> m: my @f = <0x3 4>; say @f.perl

[23:46] <camelia> rakudo-moar 6cd6ef: OUTPUT«[IntStr.new(3, "0x3"), IntStr.new(4, "4")]␤»

[23:46] <timotimo> see how it remembers whether you wrote it in hexadecimal or in decimal?

[23:47] <dataangel> Interesting... Not sure what I would do with it yet but interesting

[23:47] <timotimo> m: say <foo bar baz>.perl; say [1, 2, 3].perl

[23:47] <camelia> rakudo-moar 6cd6ef: OUTPUT«("foo", "bar", "baz")␤[1, 2, 3]␤»

[23:47] <timotimo> ^- see also round parens vs brackets

[23:48] <timotimo> m: say <foo bar baz>.WHAT; say [1, 2, 3].WHAT

[23:48] <camelia> rakudo-moar 6cd6ef: OUTPUT«(List)␤(Array)␤»

[23:48] <timotimo> that's only before you put it into the @f and @g, though

[23:48] <dataangel> Didn't realize there is an array/list distinction... What's the point when you have auto extending arrays?

[23:51] <timotimo> lists are immutable

[23:51] <timotimo> arrays also have every element in a scalar container

[23:52] <dataangel> So is there a syntax for list doesn't remember how things are spelled? I'm assuming the spelling distinction is the main feature of < stuff here >

[23:52] <dataangel> * that doesn't

[23:53] *** wbill joined
[23:53] *** mcmillhj joined
[23:55] *** kurahaupo left
[23:57] <timotimo> yes, < and > does the spelling thing

[23:57] <timotimo> you want round parens to get a regular old list

[23:57] *** mcmillhj left
[23:57] <timotimo> and you can write [<foo bar baz>] to get an array of the things in that inner list

[23:58] <timotimo> (same "one argument rule" applies here. just one "thing" inside the [], so we iterate over it)

