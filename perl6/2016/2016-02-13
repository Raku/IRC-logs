[00:00] *** virtualsue left
[00:00] *** firstdayonthejob left
[00:02] *** apiw left
[00:03] <Hotkeys> AlexDaniel: removing zeroes from the start and end of an array

[00:03] <Hotkeys> m: my @a = [0, 0, 0, 8, 1, 4, 3, 5, 6, 4, 1, 2, 0, 0, 0, 0]; my &f = {@_.[.first(?*,:k).. .grep(?*,:k)[*-1]]}; f(@a).say

[00:03] <camelia> rakudo-moar 691b39: OUTPUT«Use of uninitialized value $i of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block  at /tmp/g1M0Wu4Flz line 1␤Effective index out of range. Is: -1, should be in 0..Inf␤  in block <uni…»

[00:03] <Hotkeys> er

[00:03] <Hotkeys> m: my @a = [0, 0, 0, 8, 1, 4, 3, 5, 6, 4, 1, 2, 0, 0, 0, 0]; my &f = {@_.[.first(?*,:k).. .grep(?*,:k)[@_-1]]}; f(@a).say

[00:03] <camelia> rakudo-moar 691b39: OUTPUT«Use of uninitialized value $i of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block  at /tmp/7EaWWXJZyd line 1␤Use of uninitialized value $e of type Any in string context␤Any of .^name…»

[00:03] <Hotkeys> oh

[00:04] <Hotkeys> i copied the wrong one

[00:04] <Hotkeys> m: my @a = [0, 0, 0, 8, 1, 4, 3, 5, 6, 4, 1, 2, 0, 0, 0, 0]; my &f = {@_[.first(?*,:k)..@_.grep(?*,:k)[*-1]]}; f(@a).say

[00:04] <camelia> rakudo-moar 691b39: OUTPUT«Use of uninitialized value $i of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block  at /tmp/1J3NMgaSHG line 1␤Method 'succ' not found for invocant of class 'Any'␤  in block <unit> at …»

[00:04] <Hotkeys> m: my @a = [0, 0, 0, 8, 1, 4, 3, 5, 6, 4, 1, 2, 0, 0, 0, 0]; my &f = {@_[@_.first(?*,:k)..@_.grep(?*,:k)[*-1]]}; f(@a).say

[00:04] <camelia> rakudo-moar 691b39: OUTPUT«(8 1 4 3 5 6 4 1 2)␤»

[00:04] <Hotkeys> there

[00:05] <Hotkeys> AlexDaniel: 

[00:05] <Hotkeys> Haven't posted it yet

[00:05] <Hotkeys> because I feel like it's too long still

[00:06] <AlexDaniel> it's too long

[00:06] <AlexDaniel> even if it is the best we can get it don't post it. Such a shame :D

[00:06] <AlexDaniel> -it

[00:06] <Hotkeys> pff

[00:06] <Hotkeys> it's 42 bytes

[00:06] <Hotkeys> if anything that's a great number

[00:06] <Hotkeys> :p

[00:09] <AlexDaniel> Hotkeys: ok well I know how to make it shorter

[00:09] <Hotkeys> cool

[00:09] <Hotkeys> there better not be a built-in for this

[00:09] <AlexDaniel> Hotkeys: I haven't found it

[00:10] <AlexDaniel> yet

[00:10] <AlexDaniel> Hotkeys: but just replace @_ with $_

[00:10] <AlexDaniel> Hotkeys: and then instead of doing $_.grep do just .grep

[00:10] <AlexDaniel> Hotkeys: and instead of @_[] you can do .[]

[00:10] <Hotkeys> I tried .[]

[00:10] <Hotkeys> it got angry

[00:10] <Hotkeys> I tried .grep and that got angry

[00:10] <AlexDaniel> m: my @a = [0, 0, 0, 8, 1, 4, 3, 5, 6, 4, 1, 2, 0, 0, 0, 0]; my &f = {.[.first(?*,:k).. .grep(?*,:k)[*-1]]}; f(@a).say

[00:10] <camelia> rakudo-moar 691b39: OUTPUT«(8 1 4 3 5 6 4 1 2)␤»

[00:11] <Hotkeys> well fine

[00:11] <arnsholt> r: my @a[2]; # ?

[00:11] <camelia> rakudo-jvm f99bdb: OUTPUT«5===SORRY!5=== Error while compiling /tmp/tmpfile␤Shaped arrays not yet implemented. Sorry. ␤at /tmp/tmpfile:1␤------> 3my @a[2]7⏏5; # ?␤    expecting any of:␤        constraint␤»

[00:11] <camelia> ..rakudo-moar 691b39: ( no output )

[00:12] <Hotkeys> m: my @a = [0, 0, 0, 8, 1, 4, 3, 5, 6, 4, 1, 2, 0, 0, 0, 0]; my &f = {.[.first(?*,:k).. .grep(?*,:k)[*-1]]}; f(@a).say

[00:12] <camelia> rakudo-moar 691b39: OUTPUT«(8 1 4 3 5 6 4 1 2)␤»

[00:12] <Hotkeys> I TRIED THIS I SWEAR

[00:13] <AlexDaniel> Hotkeys: ok you can save 1 byte by using .first(?*):k

[00:13] <Hotkeys> oh

[00:13] <AlexDaniel> Hotkeys: that is, no comma required

[00:13] <Hotkeys> I didn't know you could put those outside

[00:13] <Hotkeys> I thought there would be something like that

[00:13] <AlexDaniel> yeah perhaps you can also use that trick in other golfing tasks

[00:14] <Hotkeys> m: my &f = {.[.first(?*):k.. .grep(?*):k[*-1]]}; say f([0,0,1,2,0,3,2,1,0,0,0]).say

[00:14] <camelia> rakudo-moar 691b39: OUTPUT«Unexpected named parameter 'k' passed␤  in block <unit> at /tmp/xeNjsDj4VS line 1␤␤»

[00:14] <AlexDaniel> nope that'd be too much

[00:15] <Hotkeys> m: my &f = {.[.first(?*):k.. .grep(?*,:k)[*-1]]}; say f([0,0,1,2,0,3,2,1,0,0,0]).say

[00:15] <camelia> rakudo-moar 691b39: OUTPUT«(1 2 0 3 2 1)␤True␤»

[00:15] *** kamel left
[00:15] <AlexDaniel> Hotkeys: honestly I have no idea how this code works

[00:16] <Hotkeys> it does @a[<first non-zero>..<last non-zero>]

[00:16] *** apiw joined
[00:16] <Hotkeys> by doing .grep(?*) it evaluates things as a boolean

[00:17] <Hotkeys> and only takes the truthy ones

[00:17] <AlexDaniel> oh, okay

[00:17] *** raiph joined
[00:17] <Hotkeys> unfortunately there is no ".last" sister for ".first"

[00:17] <Hotkeys> so I had to use grep for that one

[00:17] <Hotkeys> and get the last element

[00:17] <AlexDaniel> maybe there has to be one

[00:18] <Hotkeys> oh actually

[00:18] *** cdg left
[00:19] <Hotkeys> m: my &f = {.[.first(?*):k.. .first(?*,:k,:end)]}; say f([0,0,1,2,0,3,2,1,0,0,0]).say

[00:19] <camelia> rakudo-moar 691b39: OUTPUT«(1 2 0 3 2 1)␤True␤»

[00:19] <Hotkeys> there's a :end parameter

[00:19] <AlexDaniel> is it shorter?

[00:19] <Hotkeys> but the grep one is shorter

[00:19] <Hotkeys> :(

[00:19] <AlexDaniel> wait

[00:20] <Hotkeys> m: my &f = {.[.first(?*):k.. .first(?*:k:end)]}; say f([0,0,1,2,0,3,2,1,0,0,0]).say

[00:20] <camelia> rakudo-moar 691b39: OUTPUT«5===SORRY!5=== Error while compiling /tmp/QXpciUjDa3␤You can't adverb ␤at /tmp/QXpciUjDa3:1␤------> 3my &f = {.[.first(?*):k.. .first(?*:k7⏏5:end)]}; say f([0,0,1,2,0,3,2,1,0,0,0]).␤    expecting any of:␤        pair value␤»

[00:20] <Hotkeys> m: my &f = {.[.first(?*):k.. .first(?*,:k:end)]}; say f([0,0,1,2,0,3,2,1,0,0,0]).say

[00:20] <camelia> rakudo-moar 691b39: OUTPUT«(1 2 0 3 2 1)␤True␤»

[00:20] <Hotkeys> m: my &f = {.[.first(?*):k.. .first(?*,:k:end)]}; say f([0,0,1,2,0,3,2,1,0,0,0])

[00:20] <camelia> rakudo-moar 691b39: OUTPUT«(1 2 0 3 2 1)␤»

[00:20] <Hotkeys> there's another byte

[00:20] <Hotkeys> now it's as short as the grep one

[00:21] <AlexDaniel> Hotkeys: any idea why we can't do (?*):k:end here?

[00:21] <AlexDaniel> it doesn't work

[00:21] <Hotkeys> m: my &f = {.[.first(?*):k.. .first(?*):k:end]}; say f([0,0,1,2,0,3,2,1,0,0,0])

[00:21] <camelia> rakudo-moar 691b39: OUTPUT«Unexpected named parameter 'k' passed␤  in block <unit> at /tmp/VG3wtnk0G7 line 1␤␤»

[00:22] <Hotkeys> m: my &f = {.[.first(?*):k.. .first(?*):k]}; say f([0,0,1,2,0,3,2,1,0,0,0])

[00:22] <camelia> rakudo-moar 691b39: OUTPUT«Unexpected named parameter 'k' passed␤  in block <unit> at /tmp/HTouTJm3GN line 1␤␤»

[00:22] <Hotkeys> not sure

[00:22] <AlexDaniel> m: my &f = {.[.first(?*):k.. (.first(?*):k:end)]}; say f([0,0,1,2,0,3,2,1,0,0,0])

[00:22] <camelia> rakudo-moar 691b39: OUTPUT«(1 2 0 3 2 1)␤»

[00:22] <Hotkeys> that's longer

[00:22] <AlexDaniel> and so we can remove the space now

[00:22] <Hotkeys> oh

[00:22] <AlexDaniel> same length

[00:24] <Hotkeys> I suppose it does look better without the space

[00:24] <Hotkeys> m: my &f = {.[.first(?*):k.. .first(?*):k]}; say f([0,0,0,0,0,0])

[00:24] <camelia> rakudo-moar 691b39: OUTPUT«Unexpected named parameter 'k' passed␤  in block <unit> at /tmp/YFgOTUTYR9 line 1␤␤»

[00:25] <Hotkeys> er

[00:25] *** kamel joined
[00:25] <Hotkeys> m: my &f = {.[.first(?*):k.. (.first(?*):k:end)]}; say f([0,0,0,0,0,0])

[00:25] <camelia> rakudo-moar 691b39: OUTPUT«Use of uninitialized value $i of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block  at /tmp/d7QF1dEPuF line 1␤Use of uninitialized value $e of type Any in string context␤Any of .^name…»

[00:25] <Hotkeys> m: my &f = {.[.first(?*):k.. (.first(?*):k:end)]}; say f([0,0,0,1,0,0,0])

[00:25] <camelia> rakudo-moar 691b39: OUTPUT«(1)␤»

[00:26] <Hotkeys> m: my &f = {.[.first(?*):k.. (.first(?*):k:end)]or0}; say f([0,0,0,1,0,0,0])

[00:26] <camelia> rakudo-moar 691b39: OUTPUT«5===SORRY!5=== Error while compiling /tmp/TDO9ZrBbcg␤Bogus statement␤at /tmp/TDO9ZrBbcg:1␤------> 3= {.[.first(?*):k.. (.first(?*):k:end)]o7⏏5r0}; say f([0,0,0,1,0,0,0])␤    expecting any of:␤        whitespace␤»

[00:26] <Hotkeys> m: my &f = {.[.first(?*):k.. (.first(?*):k:end)] or0}; say f([0,0,0,1,0,0,0])

[00:26] <camelia> rakudo-moar 691b39: OUTPUT«5===SORRY!5=== Error while compiling /tmp/H6vnntFxyY␤Bogus statement␤at /tmp/H6vnntFxyY:1␤------> 3 {.[.first(?*):k.. (.first(?*):k:end)] o7⏏5r0}; say f([0,0,0,1,0,0,0])␤    expecting any of:␤        whitespace␤»

[00:26] <Hotkeys> m: my &f = {.[.first(?*):k.. (.first(?*):k:end)] or 0}; say f([0,0,0,1,0,0,0])

[00:26] <camelia> rakudo-moar 691b39: OUTPUT«(1)␤»

[00:26] <Hotkeys> m: my &f = {.[.first(?*):k.. (.first(?*):k:end)]or 0}; say f([0,0,0,1,0,0,0])

[00:26] <camelia> rakudo-moar 691b39: OUTPUT«(1)␤»

[00:27] <Hotkeys> m: my &f = {.[.first(?*):k.. (.first(?*):k:end)]or[]}; say f([0,0,0,0,0,0])

[00:27] <camelia> rakudo-moar 691b39: OUTPUT«Use of uninitialized value $i of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block  at /tmp/nQGb3Y6r50 line 1␤Use of uninitialized value $e of type Any in string context␤Any of .^name…»

[00:27] <Hotkeys> m: my &f = {.[.first(?*):k.. (.first(?*):k:end)]or []}; say f([0,0,0,0,0,0])

[00:27] <camelia> rakudo-moar 691b39: OUTPUT«Use of uninitialized value $i of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block  at /tmp/qy3xo_FV68 line 1␤Use of uninitialized value $e of type Any in string context␤Any of .^name…»

[00:27] <Hotkeys> ugh

[00:28] <Hotkeys> m: my &f = {.[.first(?*):k.. (.first(?*):k:end)]//0}; say f([0,0,0,0,0,0])

[00:28] <camelia> rakudo-moar 691b39: OUTPUT«Use of uninitialized value $i of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block  at /tmp/VV8HVpbwBK line 1␤Use of uninitialized value $e of type Any in string context␤Any of .^name…»

[00:28] <AlexDaniel> Hotkeys: spam-spam-spam

[00:28] <b2gills> m: say {.[.grep(?*,:k).minmax]||0}([0,0,0,1,0,0,0])

[00:29] <camelia> rakudo-moar 691b39: OUTPUT«(1)␤»

[00:29] <Hotkeys> true

[00:29] <Hotkeys> b2gills: you're a wizard

[00:29] <AlexDaniel> b2gills: yup. was looking for that :)

[00:29] <AlexDaniel> now that's ok

[00:30] * b2gills .oO( Let me just push this pointy hat over behind this wall so you can't see it )

[00:30] <Hotkeys> why doesn't that one get angry

[00:31] <AlexDaniel> m: say {.[.grep(?*,:k).minmax]//0}([])

[00:31] <camelia> rakudo-moar 691b39: OUTPUT«()␤»

[00:31] <AlexDaniel> I think that this is better

[00:31] <b2gills> m: say {.grep(?*,:k).minmax}([0,0,0,0,0,0])

[00:31] <camelia> rakudo-moar 691b39: OUTPUT«Inf..-Inf␤»

[00:31] <Hotkeys> ah

[00:32] <AlexDaniel> now remove that comma

[00:32] <AlexDaniel> m: say {.[.grep(?*):k.minmax]//0}([0,0,2,5,8,0,0])

[00:32] <camelia> rakudo-moar 691b39: OUTPUT«(2 5 8)␤»

[00:32] <AlexDaniel> kk we're getting somewhere

[00:32] *** apiw left
[00:32] <Hotkeys> m: say {.[.grep(?*):k.minmax]//0}([0,0,0,0])

[00:32] <camelia> rakudo-moar 691b39: OUTPUT«()␤»

[00:33] <b2gills> It returns a defined empty list

[00:33] <Hotkeys> right

[00:33] <Hotkeys> m: say {.[.grep(?*):k.minmax]||0}([0,0,0,0])

[00:33] <camelia> rakudo-moar 691b39: OUTPUT«0␤»

[00:34] <Hotkeys> the test case for all zeroes has it returning nothing

[00:34] <AlexDaniel> what's the link by the way?

[00:34] *** apiw joined
[00:34] <Hotkeys> http://codegolf.stackexchange.com/questions/71877/remove-leading-and-trailing-zeroes

[00:34] <b2gills> One of the things I don't like is the code highlighter that CG uses thinks // is a comment in Perl 6 but not Perl 5

[00:34] <AlexDaniel> m: say {.[.grep(?*):k.minmax]}([]) # that works fine by the way…

[00:35] <camelia> rakudo-moar 691b39: OUTPUT«()␤»

[00:35] <Hotkeys> yeah don't really need ||0

[00:35] <Hotkeys> if it just wants nothing returned

[00:35] <Hotkeys> I assume an empty list is sufficiently nothingy

[00:35] <AlexDaniel> what means “nothing”???

[00:35] <Hotkeys> well a list of 0s with all the 0s removed is an empty list anyway

[00:35] <b2gills> If anything it would be ｢|||()｣

[00:36] <Hotkeys> m: say {.[.grep(?*):k.minmax]|||[]}([0,0,0,0])

[00:36] <camelia> rakudo-moar 691b39: OUTPUT«()␤»

[00:36] <Hotkeys> m: say {.[.grep(?*):k.minmax]|||()}([0,0,0,0])

[00:36] <camelia> rakudo-moar 691b39: OUTPUT«()␤»

[00:36] <b2gills> m: say {.[.grep(?*):k.minmax]|||[]}([0,0,0,0]).perl

[00:36] <camelia> rakudo-moar 691b39: OUTPUT«slip()␤»

[00:37] <Hotkeys> m: say {.[.grep(?*):k.minmax]}([0,0,0,0]).perl

[00:37] <camelia> rakudo-moar 691b39: OUTPUT«()␤»

[00:37] <Hotkeys> why is a slip any better?

[00:37] <AlexDaniel> m: say {.[.grep(?*):k.minmax]||Any}([])

[00:37] <camelia> rakudo-moar 691b39: OUTPUT«(Any)␤»

[00:37] <AlexDaniel> or Nil

[00:37] <Hotkeys> An empty list satisfies "Output the list with trailing and leading zeroes removed."

[00:39] *** kid51 joined
[00:39] <AlexDaniel> “Vim 16 Keystrokes” – haha

[00:39] *** alpha123 left
[00:39] <Hotkeys> "Mathematica has a builtin for determining goats. I don't know how to feel about that." beautiful

[00:40] <Hotkeys> http://codegolf.stackexchange.com/questions/71631/upgoat-or-downgoat

[00:41] <AlexDaniel> m: say {+($_,*/2...^*!%2)}(20)

[00:41] <camelia> rakudo-moar 691b39: OUTPUT«5===SORRY!5=== Error while compiling /tmp/rbWibEog3g␤Cannot negate % because multiplicative operators are not iffy enough␤at /tmp/rbWibEog3g:1␤------> 3say {+($_,*/2...^*!7⏏5%2)}(20)␤    expecting any of:␤        infix␤        infix s…»

[00:41] <AlexDaniel> Hotkeys: ↑ your example does not run

[00:42] <AlexDaniel> Hotkeys: it works without !% I think

[00:42] <Hotkeys> strange

[00:42] <Hotkeys> it worked before

[00:42] <Hotkeys> m: my &f = {+($_,*/2...^*%2)}; f(20)

[00:42] <camelia> rakudo-moar 691b39: ( no output )

[00:42] <Hotkeys> m: my &f = {+($_,*/2...^*%2)}; f(20).say

[00:42] <camelia> rakudo-moar 691b39: OUTPUT«2␤»

[00:42] <Hotkeys> oh

[00:42] <Hotkeys> m: my &f = {+($_,*/2...^*!%2)}; f(20).say

[00:42] <camelia> rakudo-moar 691b39: OUTPUT«5===SORRY!5=== Error while compiling /tmp/OQiZr4HwmZ␤Cannot negate % because multiplicative operators are not iffy enough␤at /tmp/OQiZr4HwmZ:1␤------> 3my &f = {+($_,*/2...^*!7⏏5%2)}; f(20).say␤    expecting any of:␤        infix␤    …»

[00:42] <arnsholt> m: my $_=[0,0,2,5,8,0,0]; .shift while !.[0];.pop while !.[*]; .say # Should do it, I think

[00:42] <camelia> rakudo-moar 691b39: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/lpUjEcIpb7:1␤    ------> 3my $_7⏏5=[0,0,2,5,8,0,0]; .shift while !.[0];.po␤[2 5 8 0 0]␤»

[00:42] <Hotkeys> yeah

[00:43] <Hotkeys> it works without the negation

[00:43] <arnsholt> m: $_=[0,0,2,5,8,0,0]; .shift while !.[0];.pop while !.[*]; .say # Durr.

[00:43] <camelia> rakudo-moar 691b39: OUTPUT«[2 5 8 0 0]␤»

[00:43] <Hotkeys> I edited wrong is all

[00:43] <arnsholt> Oh. It's *-1, I guess

[00:43] <arnsholt> m: $_=[0,0,2,5,8,0,0]; .shift while !.[0];.pop while !.[*-1]; .say 

[00:43] <camelia> rakudo-moar 691b39: OUTPUT«[2 5 8]␤»

[00:43] <AlexDaniel> arnsholt: and we have a winner!

[00:44] <arnsholt> The power of implicit invocants compels you! =)

[00:44] <Hotkeys> {.shift while !.[0];.pop while !.[*-1];}([0,0,2,5,8,0,0,0]).say

[00:45] <Hotkeys> m: {.shift while !.[0];.pop while !.[*-1];}([0,0,2,5,8,0,0,0]).say

[00:45] <camelia> rakudo-moar 691b39: OUTPUT«Nil␤»

[00:45] <arnsholt> Not sure if my code is shorter, but it's pretty straightforward

[00:45] <Hotkeys> or is yours a full program

[00:45] <Hotkeys> m: {.shift while !.[0];.pop while !.[*-1];$_}([0,0,2,5,8,0,0,0]).say

[00:45] <camelia> rakudo-moar 691b39: OUTPUT«[2 5 8]␤»

[00:45] <Hotkeys> ah

[00:45] <Hotkeys> that works

[00:47] <Hotkeys> not shorter than the greppy one though which got down to 23 bytes

[00:47] <AlexDaniel> m: say {chars .base(2)~~/0+$/}(20) # oh well… that's so long

[00:47] <camelia> rakudo-moar 691b39: OUTPUT«2␤»

[00:48] <Hotkeys> fixed my post

[00:50] <Hotkeys> I love beating golf langs

[00:51] <AlexDaniel> are you going to post leading/trailing zeroes thing?

[00:51] <Hotkeys> only if b2gills doesn't want to

[00:51] <Hotkeys> he did nearly half the length

[00:52] <Hotkeys> maybe not quite half but quite a bit

[00:54] *** BenGoldberg_ joined
[00:54] <AlexDaniel> Hotkeys: haven't thought that a solution with … could be so short

[00:55] <AlexDaniel> Hotkeys: it also works with negative numbers but hangs on 0

[00:56] <Hotkeys> the original question specifies non-zero input

[00:57] *** Ben_Goldberg left
[00:57] <AlexDaniel> I don't like that it happens on SE though. Would've been much better if it was just a plain wiki

[00:58] <Hotkeys> hm?

[00:59] <AlexDaniel> Hotkeys: code golf I mean. stackexchange-like posting and voting does not really fit code golf I think

[00:59] <Hotkeys> oh

[00:59] <Hotkeys> Questions often have a script that makes a leaderboard by length

[01:00] <Hotkeys> Actually I haven't seen it much recently

[01:00] <Hotkeys> but they did

[01:01] <Hotkeys> this has it http://codegolf.stackexchange.com/questions/67554/is-my-name-official

[01:03] *** Kitt3n joined
[01:03] <Kitt3n> is there a (sane) way to cross compile perl6?

[01:03] *** bowtie_ left
[01:03] <AlexDaniel> Hotkeys: nope, that's still by vote count

[01:03] *** addison_ left
[01:04] <Hotkeys> The code snippet under "Leaderboard"

[01:04] <AlexDaniel> aaa

[01:04] <AlexDaniel> ok

[01:04] <Hotkeys> show it and then hit run code snippet

[01:04] <Hotkeys> ya

[01:07] *** apiw left
[01:07] <BenGoldberg_> m: {.shift until .[0];.pop until .[*-1];$_}([0,0,2,5,8,0,0,0]).say

[01:07] <camelia> rakudo-moar 691b39: OUTPUT«[2 5 8]␤»

[01:08] <BenGoldberg_> m: {.shift until.[0];.pop until.[*-1];$_}([0,0,2,5,8,0,0,0]).say

[01:08] <camelia> rakudo-moar 691b39: OUTPUT«5===SORRY!5===␤Whitespace required after keyword 'until'␤at /tmp/rObnchegaX:1␤------> 3{.shift until7⏏5.[0];.pop until.[*-1];$_}([0,0,2,5,8,0,0␤Whitespace required after keyword 'until'␤at /tmp/rObnchegaX:1␤------> 3{.shift until7…»

[01:10] <BenGoldberg_> m: {.shift until .[0];.pop until .[-1];$_}([0,0,2,5,8,0,0,0]).say

[01:10] <camelia> rakudo-moar 691b39: OUTPUT«5===SORRY!5=== Error while compiling /tmp/hIrutpBbP1␤Unsupported use of a negative -1 subscript to index from the end; in Perl 6 please use a function such as *-1␤at /tmp/hIrutpBbP1:1␤------> 3{.shift until .[0];.pop until .[-1]7⏏5;$_}([0,0,…»

[01:10] *** Herby_ joined
[01:10] <Herby_> Evening, everyone!

[01:11] *** apiw joined
[01:16] *** BenGoldberg_ is now known as BenGoldberg

[01:26] *** colomon left
[01:26] *** alpha123 joined
[01:27] *** colomon joined
[01:46] *** z8 joined
[01:49] *** addison_ joined
[01:53] *** addison_ left
[02:09] *** apiw left
[02:25] *** molaf_ joined
[02:29] *** molaf left
[02:30] *** raiph left
[02:32] *** kamel left
[02:35] *** Kitt3n is now known as Redfoxmoon

[02:36] *** timrs2998 joined
[02:37] *** wamba joined
[02:42] *** ChoHag joined
[02:52] *** kamel joined
[03:00] <masak> Herby_: good antenoon :)

[03:01] *** sno left
[03:03] *** DoverMo joined
[03:04] <Herby_> \o

[03:05] <DoverMo> no matter what language i use to output hello world, the world never replies to me ;-;

[03:06] <Herby_> m: say "Hello, DoverMo."

[03:06] <camelia> rakudo-moar 691b39: OUTPUT«Hello, DoverMo.␤»

[03:06] <DoverMo> O:

[03:08] <timotimo> i still think we should have camelia put things like the user name that requested the evaluation into an environment variable

[03:08] *** kid511 joined
[03:08] *** raiph joined
[03:08] <DoverMo> m: say "Goodbye cruel world."

[03:08] <camelia> rakudo-moar 691b39: OUTPUT«Goodbye cruel world.␤»

[03:08] *** noganex joined
[03:09] <Herby_> >:(

[03:10] *** kid51 left
[03:12] *** noganex_ left
[03:14] *** BenGoldberg left
[03:17] <sortiz> timotimo, It is a good idea!

[03:17] <sortiz> \o Herby_ 

[03:17] *** BenGoldberg joined
[03:18] <Herby_> o/

[03:20] <masak> timotimo: sounds like a job for a separate bot, if you ask me ;)

[03:24] *** colomon left
[03:25] *** Sgeo joined
[03:25] *** Sgeo_ left
[03:27] *** colomon joined
[03:35] *** DoverMo left
[03:36] *** jack_rabbit joined
[03:38] *** geraud joined
[03:43] *** kamel left
[03:43] *** ryanoz joined
[03:44] *** wamba left
[03:44] *** kid511 left
[03:50] *** Herby_ left
[04:00] *** colomon left
[04:00] *** colomon joined
[04:10] *** Ben_Goldberg joined
[04:13] *** BenGoldberg left
[04:17] *** cdg joined
[04:18] *** Ben_Goldberg left
[04:19] *** Ben_Goldberg joined
[04:25] *** Ben_Goldberg left
[04:26] *** cpage_ left
[04:28] *** BenGoldberg joined
[04:34] *** atweiden left
[04:35] *** cdg left
[04:41] *** BenGoldberg left
[04:42] *** BenGoldberg joined
[04:48] *** azawawi joined
[04:51] *** cpage_ joined
[04:53] <azawawi> hi

[04:54] <azawawi> im using %?RESOURCES and im asking myself what's the point of making installed resources folder flat?

[04:55] <azawawi> since %?RESOURCES can be used to share files with other libraries/external processes (e.g. electron)

[04:56] <azawawi> and hence one needs to reconstruct the folder from its flat structure

[04:57] *** BenGoldberg left
[04:57] *** molaf_ left
[04:58] *** BenGoldberg joined
[04:59] *** BenGoldberg left
[04:59] <sortiz> .seen lizmat

[04:59] <yoleaux> I saw lizmat 12 Feb 2016 08:40Z in #perl6: <lizmat> *caused

[04:59] <ugexe> azawawi: i agree

[05:00] *** BenGoldberg joined
[05:00] <azawawi> ugexe: and good morning or afternoon:)

[05:01] <azawawi> so basically now i have to manually copy resources before handing them to the external processes by traversing %?RESOURCES

[05:01] *** revhippie left
[05:02] *** cpage_ left
[05:03] *** BenGoldberg left
[05:03] <ugexe> its because of the same reason they use sha1 names still. if they solve 1, they solve the other

[05:03] <azawawi> http://pasteboard.co/1w0CRId7.png  # does not compute :)

[05:04] *** BenGoldberg joined
[05:05] <ugexe> and they use sha1 names because your file system might not support the characters the name of the file wants to use

[05:07] <azawawi> so basically they solved problems and created another

[05:07] <azawawi> at the expense of more load/execution time

[05:07] <ugexe> you can also generate the name on the fly i think. the sha1 is just (i think) sha1($path)

[05:07] <ugexe> for resources anyway

[05:09] <azawawi> lately i have seen slowness in the package installers(s) commits

[05:09] <azawawi> nothing to do? or waiting for something?

[05:09] <ugexe> what do you mean

[05:09] <dalek> evalbot: 5eabe3e | (Aleks-Daniel Jakimenko-Aleksejev)++ | evalbot.pl:

[05:09] <dalek> evalbot: Put user name that requested the eval into ENV variable

[05:09] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/5eabe3e547

[05:10] *** cpage_ joined
[05:11] *** camelia left
[05:11] *** camelia joined
[05:12] <azawawi> panda is not seeing any commits lately

[05:13] <AlexDaniel> m: say ‘hi’

[05:13] *** ChanServ sets mode: +v camelia

[05:13] <azawawi> ugexe: but zef is moving nicely :)

[05:13] <camelia> rakudo-moar 691b39: OUTPUT«hi␤»

[05:13] *** BenGoldberg left
[05:13] <AlexDaniel> m: say “I love %*ENV<ME>”

[05:13] <camelia> rakudo-moar 691b39: OUTPUT«I love AlexDaniel␤»

[05:13] <AlexDaniel> timotimo: I don't know why but there you go

[05:14] *** BenGoldberg joined
[05:15] <MadcapJake> AlexDaniel++

[05:16] <azawawi> MadcapJake: hey

[05:18] <dalek> evalbot: e600617 | (Aleks-Daniel Jakimenko-Aleksejev)++ | evalbot.pl:

[05:18] <dalek> evalbot: Set %ENV<ME> variable only when actually required

[05:18] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/e600617e40

[05:18] <AlexDaniel> okay that's slightly better I think

[05:19] <BenGoldberg> m: say %ENV<ME>

[05:19] <camelia> rakudo-moar 691b39: OUTPUT«5===SORRY!5=== Error while compiling /tmp/xinJKGw2nV␤Variable '%ENV' is not declared␤at /tmp/xinJKGw2nV:1␤------> 3say 7⏏5%ENV<ME>␤»

[05:19] <AlexDaniel> it's %*ENV

[05:19] <BenGoldberg> m: say %*ENV<ME>

[05:19] <camelia> rakudo-moar 691b39: OUTPUT«BenGoldberg␤»

[05:19] <BenGoldberg> Whee!

[05:22] <azawawi> ugexe: does this seem to you or is there an alternative syntax? https://github.com/azawawi/perl6-electron/blob/master/META.info#L21

[05:22] <azawawi> ugexe: s/seem to/seem right to/

[05:24] *** camelia left
[05:24] *** camelia joined
[05:24] <AlexDaniel> m: say “I love %*ENV<ME>” # just in case

[05:25] *** khw left
[05:25] *** ChanServ sets mode: +v camelia

[05:25] <camelia> rakudo-moar 691b39: OUTPUT«I love AlexDaniel␤»

[05:25] <AlexDaniel> camelia: ;)

[05:45] *** Cabanossi left
[05:46] *** Cabanossi joined
[05:51] <AlexDaniel> m: my $terminator = DateTime.new(:2029year:10month:26day); my $*TZ = -1420070400; say $terminator.local

[05:51] <camelia> rakudo-moar 691b39: OUTPUT«1984-10-26T00:00:00-394464:00␤»

[05:53] *** azawawi left
[05:59] *** raiph left
[06:00] <sortiz> .tell lizmat I found additional gains for Internals. Can you take a look at https://gist.github.com/salortiz/6555993cc5cbe746dd85 

[06:00] <yoleaux> sortiz: I'll pass your message to lizmat.

[06:01] *** BenGoldberg left
[06:14] <llfourn> .seen nine

[06:14] <yoleaux> I saw nine 11 Feb 2016 06:48Z in #perl6: <nine> AI has been solved? Nice...

[06:15] <llfourn> .tell nine friendly poke https://github.com/rakudo/rakudo/pull/694 :)

[06:15] <yoleaux> llfourn: I'll pass your message to nine.

[06:15] *** raiph joined
[06:22] *** MadcapJake_ joined
[06:22] *** MadcapJake_ left
[06:23] *** MadcapJake_ joined
[06:23] *** MadcapJake_ left
[06:25] *** CIAvash joined
[06:34] *** rurban joined
[06:58] <petercommand> why the unless construct cannot an else clause?

[06:59] <petercommand> that should be reasonable..

[07:02] *** Actualeyes joined
[07:02] <sortiz> petercommand, To avoid the cognitive impedance of the double negation. If you feed that need it, invert the order and use if.

[07:03] <petercommand> okay...

[07:04] <sortiz> s/feed/feel/

[07:23] *** Actualeyes left
[07:25] *** Actualeyes joined
[07:33] *** skids joined
[07:36] *** xinming left
[07:45] *** raiph left
[07:48] *** dolmen joined
[07:52] *** geraud left
[07:52] *** dolmen left
[07:53] *** darutoko joined
[08:14] *** z8_ joined
[08:15] *** CIAvash left
[08:15] *** z8 left
[08:15] *** AlexDaniel left
[08:15] *** abaugher left
[08:15] *** abaugher joined
[08:18] *** CIAvash joined
[08:19] *** spider-mario joined
[08:35] <petercommand> self.bless(:$name,:$age,:$sex,:$nationality);

[08:36] <petercommand> what does the : before the symbol $ do?

[08:37] <petercommand> is it something like name => $name, age => $age (some sort of macro?)?

[08:38] *** xinming joined
[08:38] <petercommand> it is in this tutorial: http://perl6intro.com/#_named_vs_positional_arguments

[08:40] *** firstdayonthejob joined
[08:43] <sortiz> petercommand, yes.

[08:44] <petercommand> sortiz: it is a macro?

[08:45] *** molaf joined
[08:46] <sortiz> petercommand, Not exactly. The compiler implements all those Pair constructors.

[08:46] <petercommand> okay, thanks!

[08:47] <petercommand> also, it seems that perl6 does not have a keyword for overriding method?

[08:47] <petercommand> i just started to look into perl6

[08:48] <petercommand> something like java's @Override

[08:48] <sortiz> After perl6intro, look the documents at http://doc.perl6.org/language.html

[08:49] *** maybekoo5 joined
[08:50] <sortiz> In http://doc.perl6.org/language/objects you can learn about perl6 objects, inheritance, etc.

[08:50] <petercommand> Thanks, sortiz. I'll look into it

[08:51] <sortiz> yw

[08:54] <petercommand> wow, perl6 has type objects..

[08:57] <sortiz> m: say "Hello".WHAT

[08:57] <camelia> rakudo-moar 691b39: OUTPUT«(Str)␤»

[08:58] *** Laurent_R joined
[08:58] <petercommand> m: say "hello".WHAT.WHAT

[08:58] <camelia> rakudo-moar 691b39: OUTPUT«(Str)␤»

[08:58] <petercommand> m: say 1.WHAT

[08:58] <camelia> rakudo-moar 691b39: OUTPUT«(Int)␤»

[08:58] <petercommand> m: say 1.WHAT.WHAT

[08:58] <camelia> rakudo-moar 691b39: OUTPUT«(Int)␤»

[08:58] <petercommand> seems that there are no kinds (type of types)?

[08:59] <sortiz> m: Str.WHAT.say

[08:59] <camelia> rakudo-moar 691b39: OUTPUT«(Str)␤»

[08:59] <skids> Well, there are metaobjects.

[08:59] <skids> m: 1.HOW.WHAT.say

[08:59] <camelia> rakudo-moar 691b39: OUTPUT«(ClassHOW)␤»

[08:59] <petercommand> m: 1.HOW

[08:59] <camelia> rakudo-moar 691b39: ( no output )

[09:00] <petercommand> what is the HOW method?

[09:00] <sortiz> A method to obtain the metaclass

[09:00] <sortiz> m: say 1.HOW.methods

[09:00] <camelia> rakudo-moar 691b39: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in any methods at gen/moar/m-Metamodel.nqp line 490␤  in block <unit> at /tmp/UpUlrPUPHX line 1␤␤»

[09:00] <skids> m: (role A { }).HOW.WHAT.say

[09:00] <camelia> rakudo-moar 691b39: OUTPUT«(ParametricRoleHOW)␤»

[09:01] <skids> m: say 1.HOW.^methods

[09:01] <camelia> rakudo-moar 691b39: OUTPUT«Method 'gist' not found for invocant of class 'NQPRoutine'␤  in block <unit> at /tmp/k6W1caPALH line 1␤␤»

[09:01] <skids> Still some interface consistency issues down that low.

[09:02] <skids> m: say 1.HOW.^methods».name

[09:02] <camelia> rakudo-moar 691b39: OUTPUT«(archetypes new new_type add_fallback compose roles role_typecheck_list concretization is_composed setup_junction_fallback find_method_fallback has_fallbacks submethod_table add_role can does array_type generate_mixin trusts rw method_table type_check publ…»

[09:02] <sortiz> m: say 1.^methods

[09:02] <camelia> rakudo-moar 691b39: OUTPUT«(Int Num Rat FatRat abs Bridge chr sqrt base polymod expmod is-prime floor ceiling round lsb msb narrow Range sign sin tan cotan acosech conj atan2 cosec pred asec acotan cosh acos acosec sech unpolar log10 atanh log exp acosh truncate sinh tanh acotanh Re…»

[09:02] * sortiz fingers frozen!

[09:04] <petercommand> is the metaclass a superclass?

[09:05] <skids> Not of the class.  Itself, it could be a superclass for other metaclasses.

[09:06] <skids> m: 1.HOW.HOW.WHAT.say

[09:06] <camelia> rakudo-moar 691b39: OUTPUT«Method 'say' not found for invocant of class 'NQPClassHOW'␤  in block <unit> at /tmp/bndrFXg8Pg line 1␤␤»

[09:06] <sortiz> No, the metaclass is a class for manipulate classes.

[09:06] <skids> m: 1.HOW.HOW.name.say

[09:06] <camelia> rakudo-moar 691b39: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in any name at gen/moar/stage2/nqpmo.nqp line 1216␤  in block <unit> at /tmp/Fp6Wk6LOI1 line 1␤␤»

[09:06] <skids> m: 1.HOW.HOW.^name.say

[09:06] <camelia> rakudo-moar 691b39: OUTPUT«NQPClassHOW␤»

[09:06] *** dolmen joined
[09:07] <skids> Eventually that should be made to behave itself I guess.

[09:08] *** ocbtec joined
[09:09] <sortiz> m: say 1.HOW.methods(Int)

[09:09] <camelia> rakudo-moar 691b39: OUTPUT«(Int Num Rat FatRat abs Bridge chr sqrt base polymod expmod is-prime floor ceiling round lsb msb narrow Range sign sin tan cotan acosech conj atan2 cosec pred asec acotan cosh acos acosec sech unpolar log10 atanh log exp acosh truncate sinh tanh acotanh Re…»

[09:13] <stmuk> http://video.fosdem.org/2016/STATUS.txt

[09:14] <stmuk> h2214 was perl

[09:15] <sortiz> skids, accustomed to the ^ syntax, I always forgot that ClassHOW's methods needs a Type as argument! :)

[09:15] <skids> m: .WHAT.^name.say for 1.HOW.WHAT.^roles(:!local)

[09:15] <camelia> rakudo-moar 691b39: OUTPUT«Perl6::Metamodel::Naming␤Perl6::Metamodel::Documenting␤Perl6::Metamodel::Versioning␤Perl6::Metamodel::Stashing␤Perl6::Metamodel::AttributeContainer␤Perl6::Metamodel::MethodContainer␤Perl6::Metamodel::PrivateMethodContainer␤Perl6::Metamodel::M…»

[09:19] <petercommand> hmm..so i need to look into how the meta* thing works in perl6

[09:20] <skids> Well, most of us just et it do its thing and don't worry about it too much :-)

[09:24] <masak> that's not satisfactory from a knowledge perspective! :)

[09:24] <masak> I have one tip along the way: prefer the terminology "class metaobject", which is clearer and less confusing than "metaclass"

[09:24] <masak> (because it's actually an *object* responsible for a certain class, not a class)

[09:27] <petercommand> yeah..I need to understand the language design to gain more understanding into how to language works :D

[09:28] <petercommand> masak: so..class themselfs are not objects, right?

[09:28] <petercommand> themselves

[09:28] <sortiz> petercommand, listen to masak, it is one of the designers of this matter and teacher of many around here

[09:28] <petercommand> :)

[09:29] <sortiz> A class is an object.

[09:29] *** dolmen left
[09:30] <petercommand> ok

[09:30] <skids> Each class has an instance of a metaclass behind it.

[09:30] <skids> Thus as masak said, "class metaobject"

[09:31] *** RabidGravy joined
[09:33] <sortiz> petercommand, you can read about the MOP: http://doc.perl6.org/language/mop

[09:33] <petercommand> thx!

[09:41] <[Tux]> test            22.708

[09:41] <[Tux]> test-t          12.191

[09:41] <[Tux]> csv-parser      51.441

[09:41] <sortiz> masak, thanks for the details on the terminology.

[09:52] *** rindolf joined
[09:56] <masak> petercommand: in Perl 6, when we say "class", we can actually be referring to *three* different objects, each capturing some aspect of what it is to be a class.

[09:57] <masak> (a) the type object, like when you do `my $d = Dog;` instead of `my $d = Dog.new;`

[09:58] <masak> (b) the package-like global name, the thing that actually goes in the package namespace when you say `class Dog { ... }`

[09:59] <masak> (c) the class metaobject, Dog.HOW, which governs things like how attributes, methods, inheritance, method lookup etc function for the Dog class

[09:59] <masak> so it's not really "a class is an object", unless you say it three times in different tone of voice ;)

[10:01] <sortiz> masak, Is the type the actual instance of the metaclass?

[10:02] <masak> no, I wouldn't say so. not in the sense that Dog ~~ Dog.HOW

[10:02] <petercommand> masak: ok, I got it :D

[10:02] <masak> m: class say Dog {}; say Dog ~~ Dog.HOW

[10:02] <camelia> rakudo-moar 691b39: OUTPUT«5===SORRY!5=== Error while compiling /tmp/0xVhRj0B6R␤Unable to parse class definition␤at /tmp/0xVhRj0B6R:1␤------> 3class say7⏏5 Dog {}; say Dog ~~ Dog.HOW␤    expecting any of:␤        generic role␤»

[10:02] <masak> m: class Dog {}; say Dog ~~ Dog.HOW

[10:02] <camelia> rakudo-moar 691b39: OUTPUT«False␤»

[10:03] <masak> "meta" here doesn't indicate an instantiation relationship. it indicates that the class metaobject is describing how the class works.

[10:03] <masak> actually, it's ultimately called "meta" because we're using the OO system to specify how the OO system works.

[10:04] <masak> a neat trick.

[10:04] *** domidumont joined
[10:07] <sortiz> Ok, not in that sense, but in the sense that a type is created instantiating a [meta]object of the metaclass ClassHOW, no?

[10:07] *** rurban left
[10:08] <skids> More like you create that instance and then install it in some special places.

[10:08] *** domidumont left
[10:09] *** domidumont joined
[10:09] <sortiz> A really neat trick, indeed.

[10:09] *** maybekoo5 left
[10:09] <petercommand> can I say that the class syntax is a syntatic sugar?

[10:09] <skids> The mere existence of an instance of ClassHOW does't magically make "Foo.new" parse the Foo

[10:10] <masak> sortiz: you seem to be asking whether $class_metaobject.new gives you the class itself. no, it doesn't.

[10:10] <masak> petercommand: yes, syntactic sugar.

[10:10] <masak> in the sense that you can do everything through the MOP.

[10:13] <sortiz> masak, I was thinking in ClassHOW.new_type(...), so I look that as a factory for types.

[10:13] <masak> that's correct.

[10:13] <masak> but the objects .new_type produces are not instances of the class metaobject's type

[10:14] <sortiz> That is clear, that only the type.

[10:17] *** rurban joined
[10:18] *** skids left
[10:20] <sortiz> The semantic is complex, and I need to understand it well so I can be capable of explain with precision in Spanish! :)

[10:22] <masak> we're happy to help :)

[10:23] <masak> maybe it would make sense to find some old advent post by jnthn++ -- he explains it quite well

[10:26] <sortiz> I have been reading many hours a day for the last six weeks, and somehow I still feel lost at times.

[10:28] *** virtualsue joined
[10:28] <petercommand> reading what?

[10:28] <sortiz> But now I can read the Perl6 source and understand it reasonably well.

[10:28] <petercommand> oh perl6..

[10:32] <sortiz> petercommand, every blog I found, the old advents, masak's blog, etc. A lot has been written in recent years.

[10:33] *** [Tux] left
[10:33] *** [Tux] joined
[10:33] <petercommand> is the old advents this website? https://perl6advent.wordpress.com/2014/12/03/day-3-cap-your-junctions/

[10:36] <sortiz> Yep. The old and the new ones. Unfortunately lacks good index.

[10:41] <sortiz> I need some sleep o/

[10:46] *** SCHAAP137 joined
[10:50] *** p6newbee joined
[10:51] <nine> messages?

[10:51] <yoleaux> 06:15Z <llfourn> nine: friendly poke https://github.com/rakudo/rakudo/pull/694 :)

[10:51] *** sortiz left
[10:52] *** hankache joined
[11:01] *** espadrine joined
[11:03] <nine> .tell jnthn funny question: what should we do with commits that make TODO tests in 6.c roast pass? Shouldn't 6.c roast be fudge free?

[11:03] <yoleaux> nine: I'll pass your message to jnthn.

[11:07] <masak> sortiz: there's an index: https://perl6advent.wordpress.com/category/table-of-contents/

[11:08] <masak> (but there's no link to that URL anywhere outside of the admin area, which is a pity)

[11:08] <masak> also, we never seemed to get a table of contents for 2015, unless I'm missing something.

[11:12] *** mattn_jp joined
[11:12] <p6newbee> hi all

[11:14] <p6newbee> m: my @a = 12,12,12; my $p := @a; say @a.WHAT; say $p.WHAT;

[11:14] <camelia> rakudo-moar 691b39: OUTPUT«(Array)␤(Array)␤»

[11:14] <p6newbee> $p is a pointer, right?

[11:14] <p6newbee> m: my @a = 12,12,12; my $p := @a; say @a.WHERE; say $p.WHERE;

[11:14] <camelia> rakudo-moar 691b39: OUTPUT«140034835862328␤140034835862328␤»

[11:15] <p6newbee> Is there a way to figure out what type the $p is?

[11:18] <p6newbee> and when I assign $p to a class variable like MyClass.new(p => $p); Is the class variable a pointer then or is the array copied?

[11:18] *** sno joined
[11:21] <RabidGravy> no, for the most part:

[11:21] <RabidGravy> m: class F { has $.g }; class G {}; my $g = F.new; say $g.WHICH; my $f = F.new(g => $g); say $f.g.WHICH

[11:21] <camelia> rakudo-moar 691b39: OUTPUT«F|68313728␤F|68313728␤»

[11:22] <RabidGravy> er, wait

[11:22] <lizmat> computer, messages

[11:22] <yoleaux> 06:00Z <sortiz> lizmat: I found additional gains for Internals. Can you take a look at https://gist.github.com/salortiz/6555993cc5cbe746dd85

[11:23] <RabidGravy> m: class F { has $.g }; class G {}; my $g = F.new; say $g.WHICH; my $f = F.new(g => $g); say $f.g.WHICH

[11:23] <camelia> rakudo-moar 691b39: OUTPUT«F|56701568␤F|56701568␤»

[11:23] <RabidGravy> is what I meant, not enough coffee

[11:23] <p6newbee> hehe

[11:24] <p6newbee> ok, so there are no pointers?

[11:24] <RabidGravy> pointer would not be the right term no

[11:25] <p6newbee> I can think of all is copied by value not by reference

[11:25] <RabidGravy> all values can be thought of as objects

[11:25] <masak> p6newbee: there are pointers/references in Perl 6, just like in Java or Python.

[11:25] <masak> p6newbee: but you don't often need to think in terms of them.

[11:26] <masak> let me demonstrate.

[11:27] <masak> m: my @a = 1, { foo: 42 }, "OH HAI"; my @b = @a; @a[1]<foo> = 5; say @b.perl

[11:27] <camelia> rakudo-moar 691b39: OUTPUT«Type Block does not support associative indexing.␤  in block <unit> at /tmp/4XqtOvKBdf line 1␤␤Actually thrown at:␤  in block <unit> at /tmp/4XqtOvKBdf line 1␤␤»

[11:27] <masak> m: my @a = 1, { foo => 42 }, "OH HAI"; my @b = @a; @a[1]<foo> = 5; say @b.perl

[11:27] <camelia> rakudo-moar 691b39: OUTPUT«[1, {:foo(5)}, "OH HAI"]␤»

[11:27] <masak> gah, JavaScript interference :)

[11:27] <p6newbee> in perl5 I have a pointer to a hash with. with my $p = { "hello" => "perl6" }. What does my $p := %hash do?

[11:27] <p6newbee> :-)

[11:28] <masak> p6newbee: if it was all copied by value, then @b would still have an object with :foo(42) above. QED, there are pointers.

[11:28] <p6newbee> sorry, I need some time to get this

[11:29] <RabidGravy> for the most part you don't need to care

[11:29] <masak> that's not satisfactory from a knowledge perspective! ;)

[11:30] <p6newbee> so my @b = @a does not copy the array. its creates a reference?

[11:30] <masak> (but it's true)

[11:30] <masak> p6newbee: it copies the array in that case, but the array has references as some of the elements

[11:31] <petercommand> does perl6 provides anything to explicit operate on pointers? (say, for ffi)

[11:32] <masak> petercommand: yes. see NativeCall

[11:33] <p6newbee> masak. aaah. { foo: 12} is a reference, of course. and what if I want to have a pointer to @a? my $p := @a;?

[11:34] <petercommand> masak: i see

[11:34] <masak> p6newbee: I think you are coming at this from a C/C++ perspective, perhaps. in that case, expect surprises in how this works :)

[11:35] <p6newbee> you're right. I still struggle with the conecpt of perl6. However I like it and would like get better

[11:36] <masak> p6newbee: specifically, after you do that binding, $p will not be a "pointer object" or a "reference object", but an reference to the array in @a, identical to @a and just as much "an Array" as @a

[11:36] *** CIAvash left
[11:36] *** kamel joined
[11:36] <p6newbee> Hmm ok

[11:36] <masak> p6newbee: I wrote this long ago, but perhaps it'll shed some light: http://strangelyconsistent.org/blog/plain-old-assignment-and-freaky-binding

[11:37] <p6newbee> cool thx masak!

[11:38] *** CIAvash joined
[11:43] <dalek> rakudo/nom: 78d2c71 | lizmat++ | src/core/Rakudo/Internals.pm:

[11:43] <dalek> rakudo/nom: Remove superfluous line, sortiz++

[11:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/78d2c7148a

[11:46] <lizmat> .tell sortiz: the || suggestion gives a tiny slowdown in my benchmarks, so I didn't apply that

[11:46] <yoleaux> lizmat: What kind of a name is "sortiz:"?!

[11:46] *** rurban left
[11:46] <lizmat> .tell sortiz the || suggestion gives a tiny slowdown in my benchmarks, so I didn't apply that

[11:46] <yoleaux> lizmat: I'll pass your message to sortiz.

[11:47] *** hankache left
[11:52] *** pecastro left
[11:52] *** leont joined
[11:59] *** bowtie joined
[11:59] *** bowtie is now known as Guest79116

[11:59] *** pmurias joined
[12:01] *** pecastro joined
[12:02] *** TEttinger left
[12:03] *** Guest79116 left
[12:04] <RabidGravy> speaking of binding, I doing something with a language where '=' and ':=' have different semantics to that of Perl 6 (actually of most languages and keeps confusing me)

[12:05] *** bowtie_ joined
[12:05] *** domidumont left
[12:09] *** bowtie_ left
[12:09] *** maybekoo5 joined
[12:10] *** pecastro left
[12:10] *** bowtie_ joined
[12:14] <stmuk> pascal? :)

[12:18] *** kid51 joined
[12:19] *** mattn_jp left
[12:21] *** rurban joined
[12:22] <RabidGravy> nah

[12:23] <RabidGravy> http://savonet.sourceforge.net/doc-svn/language.html

[12:27] *** mattn_jp joined
[12:29] <petercommand> m: 1.^methods.perl

[12:29] <camelia> rakudo-moar 78d2c7: ( no output )

[12:31] <petercommand> m: say 1.^methods.perl

[12:31] <camelia> rakudo-moar 78d2c7: OUTPUT«(method Int (Int $: *%_) { #`(Method|47171384) ... }, method Num (Int:D $: *%_) { #`(Method|47171536) ... }, method Rat (Int:D $: $?, *%_) { #`(Method|47171688) ... }, method FatRat (Int:D $: $?, *%_) { #`(Method|47171840) ... }, method abs (Int:D $: *%_) …»

[12:39] *** pecastro joined
[12:39] *** p6newbee left
[12:51] *** wamba joined
[12:53] *** hankache joined
[12:59] *** pecastro left
[13:02] *** hankache left
[13:04] *** virtualsue left
[13:05] *** hankache joined
[13:07] *** pecastro joined
[13:09] *** nebuchadnezzar left
[13:10] *** nebuchadnezzar joined
[13:10] *** firstdayonthejob left
[13:15] *** SCHAAP137 left
[13:18] <stmuk> ah a DSL for streaming

[13:22] <hankache> hello#perl6

[13:23] *** firstdayonthejob joined
[13:24] *** musiKk joined
[13:27] <masak> hellohankache

[13:29] <hankache> hello masak

[13:29] <hankache> :)

[13:33] <hankache> do we have something that reads a module code and generate the classes and their methods/attributes in some textual format?

[13:33] <hankache> or something close that can be reused/augmented?

[13:38] *** virtualsue joined
[13:41] *** raiph joined
[13:52] <moritz> hankache: you mean besides cat?

[13:53] <hankache> moritz cat?

[13:56] <moritz> hankache: cat MyModule.pm6 # prints the class and their methods and attributes

[13:56] <masak> in some textual format!

[13:57] <masak> 'night, #perl6

[14:05] *** shlomif joined
[14:07] *** mr-foobar left
[14:07] *** maybekoo5 left
[14:08] *** pecastro left
[14:10] *** apiw joined
[14:14] *** eyck left
[14:14] <RabidGravy> I've got a little hack somewhere that generates stub pod from a module but I usually end up tailoring it to circumstances of each module

[14:15] *** st_iron joined
[14:16] *** eyck joined
[14:16] <st_iron> hello my friends

[14:19] <nine> .tell llfourn pr 694 regresses several spec tests in the 6.c branch (some of them the S01 integration tests)

[14:19] <yoleaux> nine: I'll pass your message to llfourn.

[14:21] *** shlomif left
[14:39] *** musiKk left
[14:41] *** skids joined
[14:47] *** dolmen joined
[14:49] *** kamel left
[14:52] *** dolmen left
[14:58] *** sftf joined
[15:01] *** eyck left
[15:06] <petercommand> is there a difference between

[15:06] <petercommand> my $sig = :($Int $a, Str);

[15:06] <petercommand> opps, i mean my $sig = :(Int $a, Str);

[15:06] <petercommand> and my $sig = :(Int, Str);

[15:07] <petercommand> they should be the same signature right?

[15:08] <skids> No the name is indeed recorded in the sig.

[15:08] *** kamel joined
[15:08] <skids> m: my $a, $b; :($a, $b) = 1, 2; $a.say; $b.say

[15:08] <camelia> rakudo-moar 78d2c7: OUTPUT«5===SORRY!5=== Error while compiling /tmp/oAM6lKKzHH␤Variable '$b' is not declared␤at /tmp/oAM6lKKzHH:1␤------> 3my $a, 7⏏5$b; :($a, $b) = 1, 2; $a.say; $b.say␤»

[15:08] <skids> m: my $a; my $b; :($a, $b) = 1, 2; $a.say; $b.say

[15:08] <camelia> rakudo-moar 78d2c7: OUTPUT«Cannot modify an immutable Signature␤  in block <unit> at /tmp/BmKyfx7P0T line 1␤␤»

[15:08] *** eyck joined
[15:08] <skids> oh

[15:09] <skids> m: my $a; my $b; :($a, $b) := 1, 2; $a.say; $b.say

[15:09] <camelia> rakudo-moar 78d2c7: OUTPUT«1␤2␤»

[15:09] <petercommand> oh, i see

[15:09] <hankache> Me: Will you be my valentine?

[15:09] <hankache> Girl: No way

[15:09] <hankache> Me: sudo Will you be my valentine?

[15:09] <hankache> Girl: Yes..yes..yes! Let's go!

[15:09] <skids> But for the purpose of multidispatch, it of course does not consider the name

[15:13] *** dolmen joined
[15:15] <petercommand> m: my Int $x where { loop (my $i = 0; $i > -1; $i++) { }; $_ > 3 } = 7;

[15:16] <camelia> rakudo-moar 78d2c7: OUTPUT«(timeout)»

[15:17] <petercommand> turing complete run-time type check..

[15:21] *** squach1 left
[15:21] <petercommand> for something like "my Int $x where { $_ < 3 } = 2", i think this is much easier to write than the agda/idris variant of the Fin type

[15:21] <petercommand> though it might not terminate at all..

[15:23] <skids> We call that case DHWDT

[15:24] <petercommand> what does that mean?

[15:25] <skids> "Doctor it Hurts When I Do This"

[15:25] <skids> ("So Don't do That")

[15:25] <petercommand> lol

[15:29] <stmuk> hmm gitlab allows use of github signin but pushing to it seems slow :/

[15:30] *** raiph left
[15:31] <petercommand> skids: what's the main usage for this kind of type?

[15:32] *** raiph joined
[15:32] <skids> There are two main usages.  Subset types, and dispatch checks for subs/methods.

[15:33] <skids> The latter is more common.

[15:34] *** apiw left
[15:35] <skids> m: multi sub a ($ where 2) { 1.say }; multi sub a ($ where 3) { 2.say }; a(2); a(3);

[15:35] <camelia> rakudo-moar 78d2c7: OUTPUT«1␤2␤»

[15:35] *** jack_rabbit left
[15:36] <skids> m: multi sub a (2) { 1.say }; multi sub a (3) { 2.say }; a(2); a(3); # basically the same thing

[15:36] <camelia> rakudo-moar 78d2c7: OUTPUT«1␤2␤»

[15:36] <petercommand> oh..that's an interesting feature..

[15:37] <RabidGravy> very useful

[15:38] *** ggoebel16 joined
[15:40] <petercommand> skids: does it try the method in the sequence i defined them?

[15:40] <petercommand> a(2) then a(3)

[15:41] <skids> Yes.  (There are a couple places where rakudo messes this up currently, but in general, yes)

[15:41] <skids> After elimination throuh nominal type check, though.

[15:45] <petercommand> skids: what about multi sub from different modules?

[15:45] <skids> Yes you can add to a multi from different modules.  As long as the proto is in a scope that's accessible.  So, that would be, if the module exports them.

[15:45] <skids> m: multi sub a (Int $ where { "a checked".say; $_ == 2 }) { 1.say }; multi sub a (Int $ where { "b checked".say; $_ == 3 }) { 2.say }; multi sub a (Str $ where { "c checked".say; $_ == "2" }) { 3.say }; a(2); a(3); a("2");

[15:45] <camelia> rakudo-moar 78d2c7: OUTPUT«a checked␤a checked␤1␤a checked␤b checked␤b checked␤2␤c checked␤c checked␤3␤»

[15:46] *** yheif joined
[15:46] <skids> (Seems to be an extra ceck in there for now)

[15:46] <petercommand> so what will be the sequence for dispatching multi from different modules?

[15:47] *** AlexDaniel joined
[15:47] <skids> The use statements count as declarations, I would suppose.

[15:47] <skids> Never tested that.

[15:48] <petercommand> hmm..that sounds bad....

[15:48] <skids> howso?

[15:49] <petercommand> that will mean that changing the sequence of the use statements changes the semantic of the program

[15:49] *** kamel left
[15:50] *** ka joined
[15:50] <yheif> does perl6 have an equivalent of R copy-on-modify semantics?

[15:50] *** apiw joined
[15:51] *** hankache left
[15:51] <skids> In general there aren't too horribly many places where declaration order matters.  (Personally, coming from the rough-and-tumble perl 5/C world, I expect the order of "use" statements to matter)

[15:52] *** ryanoz left
[15:54] *** pmurias_ joined
[15:54] <AlexDaniel> .tell hankache Girl: [sudo] password for Girl:

[15:54] <yoleaux> AlexDaniel: I'll pass your message to hankache.

[15:54] *** apiw left
[15:55] <skids> yheif: Not built in, that I've seen.  It should be easy to implement though so I imagine a module might be able to make a trait for that.

[15:56] *** pmurias left
[15:57] *** rurban1 joined
[15:58] *** rurban2 joined
[15:59] <AlexDaniel> m: sub foo($x is copy) { say $x.WHERE; $x = 35; say $x }; my $z = 25; say $z.WHERE; foo($z)

[15:59] <camelia> rakudo-moar 78d2c7: OUTPUT«139712022043168␤139712022043168␤35␤»

[15:59] <yheif> skids: in R I think it is useful when dealing with tables because you end up having multiple instances of the same data with additional columns allocating memory only when you really need

[15:59] *** rurban left
[15:59] <AlexDaniel> haha. Well, that's not it

[16:00] <AlexDaniel> m: sub foo($x is copy) { say $x.WHERE; $x = 35; say $x.WHERE }; my $z = 25; say $z.WHERE; foo($z) # that's what I meant

[16:00] <camelia> rakudo-moar 78d2c7: OUTPUT«139666929756760␤139666929756760␤139666929649664␤»

[16:00] *** Zero_Dogg left
[16:00] *** isBEKaml joined
[16:01] *** Zero_Dogg joined
[16:01] <petercommand> skids: hmm..i come from haskell...where something like this result in compilation error by default, and module import order doesn't matter at all

[16:01] *** pecastro joined
[16:01] <skids> Classic functional vs procedral difference of viewpoint :-)

[16:02] *** apiw joined
[16:02] *** rurban1 left
[16:02] *** kurahaupo joined
[16:02] *** kurahaupo left
[16:03] <petercommand> yeah..but at least there should be a warning or sth for that

[16:03] *** Laurent_R left
[16:04] <petercommand> so the user can know that something might go wrong there

[16:04] <ugexe> to be fair: "or there is a single prior or outer proto in the same file"

[16:05] *** larion joined
[16:05] <skids> It's generally considered to be icky to create a situation like that, culturally (don;t do it or if you do, bears documenting).  I could see a linter or compiler feature to look for things of that sort being useful.

[16:05] <RabidGravy> in reality the order of the multis shouldn't matter as if you have two that tie you get at least a warning

[16:06] <skids> Yeah only with where clauses does it matter.

[16:06] <AlexDaniel> m: class C { has $.f is rw }; sub foo($x is copy) { $x.f = 49 }; my $z = C.new(:25f); say $z; foo($z); say $z

[16:06] <camelia> rakudo-moar 78d2c7: OUTPUT«C.new(f => 25)␤C.new(f => 49)␤»

[16:07] <AlexDaniel> what kind of a copy is that?…

[16:07] <AlexDaniel> :)

[16:07] <AlexDaniel> I'm joking of course

[16:07] <petercommand> RabidGravy: then the thing it checks should be something decidable

[16:08] <petercommand> then can know whether there is a tie

[16:08] <RabidGravy> don't know what 'decidable' means

[16:08] *** apiw left
[16:09] *** apiw joined
[16:10] <yheif> Do you think that in the parse tree that is the result of a complex regular expression (like a grammar) in Perl6, all the string are copy of the parsed text?

[16:10] <petercommand> RabidGravy: it needs to be sure that the check it is performing is always terminating

[16:11] <petercommand> so it won't get stuck..

[16:11] *** ggoebel16 left
[16:11] <RabidGravy> right, 

[16:13] *** khw joined
[16:18] *** ggoebel16 joined
[16:21] <petercommand> wait, in compile time, it is not possible to determine whether the checks can tie in general..even if they all terminate

[16:22] *** st_iron left
[16:24] <petercommand> i think it should just warn for any multi defined in different module

[16:25] <skids> You wouldn't have to warn unless there were where clauses, I don't think.

[16:25] <petercommand> yep, there has to be where clauses

[16:31] <AlexDaniel> yheif: good question :)

[16:32] <AlexDaniel> yheif: as far as I remember Strs were immutable, so I don't think that it would make any sense to do that

[16:33] <AlexDaniel> yheif: however, rakudo is not very optimized right now, so who knows?

[16:35] <yheif> AlexDaniel: yep, there should be a reason why strings are immutable

[16:41] *** ka left
[16:46] *** maybekoo5 joined
[16:46] <RabidGravy> well that was the stupidest refactor I've ever done, I appear to have wound up with *more* code

[16:46] *** yheif left
[16:50] <jnthn> yheif left already, but to answer the question anyway: Match objects store from/to and a reference to the original string

[16:50] <yoleaux> 11:03Z <nine> jnthn: funny question: what should we do with commits that make TODO tests in 6.c roast pass? Shouldn't 6.c roast be fudge free?

[16:51] <jnthn> If you ask for the string preresentation of that matched range, yes, it's a new Str, though on MoarVM it will also just be a reference to the original string and a start offset.

[16:51] <jnthn> So, not copying.

[16:51] <jnthn> .tell nine I don't know that we need to do anything; a pass with some passing TODO'd tests is still a perfectly fine pass.

[16:51] <yoleaux> jnthn: I'll pass your message to nine.

[16:53] <b2gills> The part about it not copying is an implementation detail that should not be noticeable by code which does not peak behind the curtain

[16:54] <jnthn> b2gills: Sure, though people usually ask these things with the performance/memory behavior in mind :)

[16:54] *** lsm-desktop joined
[16:57] *** Begi joined
[16:58] <b2gills> Now that we pretty much have what 6.c means, can @a.permutations be fixed where @a is 0 or 1 elements long (Rakudo PR #686 and Roast PR #98)

[16:59] *** apiw left
[17:00] <jnthn> b2gills: Don't see why those two can't go in.

[17:00] *** larion left
[17:00] *** musiKk joined
[17:01] *** mohae left
[17:01] *** mohae joined
[17:04] <b2gills> The only debate that would affect it (other than waiting on version stuff) was what permutations(0) returned. It should numify to 1 because that is its mathematical definition. (the PR does/tests that)

[17:09] *** ka joined
[17:21] *** maybekoo5 left
[17:25] *** apiw joined
[17:28] *** rurban2 left
[17:32] *** pmurias_ left
[17:35] *** Laurent_R joined
[17:38] <dalek> nqp: a59d662 | hoelzro++ | src/HLL/Compiler.nqp:

[17:38] <dalek> nqp: Move continuation detection into eval

[17:38] <dalek> nqp: 

[17:38] <dalek> nqp: With this change, eval can return the output of running the code, or

[17:38] <dalek> nqp: a sentinel value that indicates that more input is needed to run a chunk

[17:38] <dalek> nqp: of code.  This is so that more advanced forms of detecting when we need

[17:38] <dalek> nqp: more input, such as if the user is entering input for a multi-line

[17:38] <dalek> nqp: statement like a block.

[17:38] <dalek> nqp: 

[17:38] <dalek> nqp: This is just a proof-of-concept change; I don't really like how eval

[17:38] <dalek> nqp: indicates to its caller that it needs more input.  But at least this

[17:38] <dalek> nqp: will get people to try and see if multi-line input could be feasible.

[17:38] <dalek> nqp: 

[17:38] <dalek> nqp: We also add a new method to HLL::Compiler - needs-more-input, which is

[17:38] <dalek> nqp: used in conjunction with the sentinel value returned by eval.

[17:38] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a59d66226b

[17:38] <dalek> nqp: a789a7e | hoelzro++ | src/HLL/Compiler.nqp:

[17:38] <dalek> nqp: Check if we need more input due to trailing backslash

[17:38] <dalek> nqp: 

[17:38] <dalek> nqp: This is a bit of a hack, but it's good enough for this experiment

[17:38] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a789a7e9c4

[17:38] <dalek> nqp: b31afba | hoelzro++ | src/HLL/Compiler.nqp:

[17:38] <dalek> nqp: Merge branch 'multi-line-repl'

[17:38] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b31afba0d1

[17:39] *** rurban joined
[17:40] <dalek> rakudo/nom: 9576596 | hoelzro++ | tools/build/NQP_REVISION:

[17:40] <dalek> rakudo/nom: Require NQP for multi-line REPL

[17:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9576596690

[17:40] <dalek> rakudo/nom: 6015ce7 | hoelzro++ | src/ (2 files):

[17:40] <dalek> rakudo/nom: Add pos attribute to X::Syntax

[17:40] *** dalek left
[17:40] *** dalek joined
[17:40] *** ChanServ sets mode: +v dalek

[17:44] *** skids left
[17:44] *** pmurias joined
[17:45] *** _mg_ joined
[17:45] *** hankache joined
[17:49] *** pmurias left
[17:49] *** pmurias joined
[17:49] *** spider-mario left
[17:54] <hankache> https://github.com/hankache/perl6intro needs your stars :)

[17:54] <yoleaux> 15:54Z <AlexDaniel> hankache: Girl: [sudo] password for Girl:

[17:56] <hankache> .tell AlexDaniel [sudo] password for Girl: input credit card number

[17:56] <yoleaux> hankache: I'll pass your message to AlexDaniel.

[17:56] *** rurban left
[17:56] <AlexDaniel> :)

[17:56] <yoleaux> 17:56Z <hankache> AlexDaniel: [sudo] password for Girl: input credit card number

[17:58] *** atweiden joined
[17:59] *** sftf left
[18:03] *** raiph left
[18:03] <atweiden> any hint as to why this exception handling code would be exiting with "This exception is not resumable"? http://ix.io/omG

[18:03] *** mattn_jp left
[18:05] *** apiw left
[18:06] <jnthn> atweiden: Probably the default. You can't rely on all exceptions being resumable. Generally, you should only rely on exceptions types you throw yourself to be.

[18:07] <jnthn> (Or others that are explicitly documented as being)

[18:09] <atweiden> ty, it was the default {...} block doing it

[18:10] *** agent008 joined
[18:11] *** Psyche^_ joined
[18:12] *** virtualsue left
[18:12] *** nebuchadnezzar left
[18:13] *** Psyche^ left
[18:14] *** apiw joined
[18:16] <dalek> nqp: b9ab65b | (Pawel Murias)++ | / (3 files):

[18:16] <dalek> nqp: [js] Implemente simple conversion/wrapping of some basic things between NQP/native js.

[18:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b9ab65bbc5

[18:16] <dalek> nqp: 45927a6 | (Pawel Murias)++ | src/vm/js/ (4 files):

[18:16] <dalek> nqp: [js] add a --source-map-debug flag to help with getting correcting source maps

[18:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/45927a6cfb

[18:18] *** sjoshi joined
[18:19] *** musiKk left
[18:20] *** ka left
[18:23] *** nebuchadnezzar joined
[18:24] *** rurban joined
[18:25] *** ka joined
[18:27] *** abaugher left
[18:33] *** gorgor joined
[18:37] *** rurban left
[18:37] *** espadrine left
[18:47] *** ka left
[18:49] *** ka joined
[18:50] <dalek> nqp: ac4325c | (Pawel Murias)++ | src/vm/js/Compiler.nqp:

[18:50] <dalek> nqp: [js] Better source maps for ops with side-effects.

[18:50] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ac4325c2ee

[18:51] *** rindolf left
[18:58] *** squach joined
[19:05] *** espadrine joined
[19:05] *** sjoshi left
[19:07] *** dolmen left
[19:10] *** abaugher joined
[19:13] *** rindolf joined
[19:17] *** TEttinger joined
[19:18] *** BenGoldberg joined
[19:18] *** jack_rabbit joined
[19:22] <RabidGravy> I'm struggling to make an interesting and possibly useful example of Audio::Liquidsoap without bringing in a veritable boat load of dependencies

[19:25] *** apiw left
[19:29] *** Herby_ joined
[19:29] <Herby_> Afternoon, everyone!

[19:29] <Begi> is the "&" new with Perl6 or already exists with Perl 5 ?

[19:34] *** bowtie_ left
[19:36] *** bowtie joined
[19:36] *** bowtie is now known as Guest99208

[19:38] <pmurias> Begi: & in what context?

[19:39] <Begi> my &x = &method

[19:39] <RabidGravy> it has a similar thing in Perl 5

[19:39] <atweiden> is there a more p6 idiomatic way to create a subroutine with a signature of `multi sub step($container where {$_ !~~ Positional}, Int $step)`

[19:40] <atweiden> something to filter out all non-positionals

[19:40] <RabidGravy> however it behaves differently, to get the "reference" of a sub in perl5 one would typically do \&foo

[19:40] <Begi> Oh ok, thanks

[19:40] <atweiden> select for non-pos*

[19:42] <RabidGravy> rather than just declare it as a named argument?

[19:44] <RabidGravy> or is that above "one integer and a single named argument"?

[19:44] <geekosaur> in perl6 &foo is a way to refer to a sub by name, as opposed to calling it. but it can't be used as a declarator

[19:44] <geekosaur> er perl5

[19:44] <Hotkeys> m: my @a; my @b = [0,1,0]; @a.push(@b); @a.say; @b = [0,0,1]; @a.say

[19:44] <camelia> rakudo-moar 97eafa: OUTPUT«[[0 1 0]]␤[[0 0 1]]␤»

[19:44] <Hotkeys> how do I push @b as a value?

[19:44] <Hotkeys> instead of as a reference to @b

[19:44] <hankache> push |@b

[19:44] <Hotkeys> m: my @a; my @b = [0,1,0]; @a.push(|@b); @a.say; @b = [0,0,1]; @a.say

[19:44] <RabidGravy> .append

[19:44] <camelia> rakudo-moar 97eafa: OUTPUT«[0 1 0]␤[0 1 0]␤»

[19:45] <Hotkeys> genius

[19:45] <Hotkeys> er

[19:45] <Hotkeys> I want the whole array pushed as an array

[19:45] <Hotkeys> not as individual values

[19:45] <Hotkeys> but I don't want the one in @a to change if @b is modified

[19:46] <RabidGravy> [|@b] then

[19:46] <Hotkeys> m: my @a; my @b = [0,1,0]; @a.push([|@b]); @a.say; @b = [0,0,1]; @a.say

[19:46] <camelia> rakudo-moar 97eafa: OUTPUT«[[0 1 0]]␤[[0 1 0]]␤»

[19:46] <Hotkeys> fancy

[19:46] <Hotkeys> thanks

[19:47] *** squach left
[19:48] *** ggoebel16 left
[19:49] <timotimo> o/

[19:49] <RabidGravy> RARR!

[19:50] <Herby_> \o

[19:51] <BenGoldberg> m: my @a; my @b = (0,1,0); @a.push: item @b; @a.say;

[19:51] <camelia> rakudo-moar 97eafa: OUTPUT«[[0 1 0]]␤»

[19:51] *** squach joined
[19:52] <BenGoldberg> m: my @a; my @b = (0,1,0); @a.push: item @b; @a.say; @b.push: 2; @a.say;

[19:52] <camelia> rakudo-moar 97eafa: OUTPUT«[[0 1 0]]␤[[0 1 0 2]]␤»

[19:55] *** Herby_ left
[19:56] *** ggoebel16 joined
[20:05] *** yqt joined
[20:07] *** Ben_Goldberg joined
[20:08] *** apiw joined
[20:09] *** BenGoldberg left
[20:11] *** p6newbee joined
[20:12] *** _mg_ left
[20:12] <Hotkeys> m: my @a = [[1,0,1],[0,0,0]]; say @b (elem) @a; say ?@a.grep(@b);

[20:12] <camelia> rakudo-moar 97eafa: OUTPUT«5===SORRY!5=== Error while compiling /tmp/uFF5_oCpMT␤Variable '@b' is not declared␤at /tmp/uFF5_oCpMT:1␤------> 3my @a = [[1,0,1],[0,0,0]]; say 7⏏5@b (elem) @a; say ?@a.grep(@b);␤»

[20:13] <Hotkeys> m: my @a = [[1,0,1],[0,0,0]]; my @b = [0,0,0]; say @b (elem) @a; say ?@a.grep(@b);

[20:13] <camelia> rakudo-moar 97eafa: OUTPUT«False␤True␤»

[20:13] <Hotkeys> the (elem) operator is quite confusing

[20:14] <timotimo> how so? it just coerces to Set before acting on stuff

[20:14] <timotimo> that's where the exact semantics come from

[20:14] *** atweiden left
[20:19] *** rindolf left
[20:21] <Hotkeys> but @b is an element of @a isn't it?

[20:21] <Hotkeys> in that example

[20:23] *** virtualsue joined
[20:24] *** darutoko left
[20:24] *** ilbelkyr is now known as u

[20:24] *** ocbtec left
[20:27] <timotimo> oh, heh.

[20:27] <timotimo> m: my @b = [0,0,0]; say @b.perl

[20:27] <camelia> rakudo-moar 97eafa: OUTPUT«[0, 0, 0]␤»

[20:27] <timotimo> m: my @a = [[1,0,1], [0,0,0]]; my $b = [0,0,0]; say $b (elem) @a; say so @a.grep($b)

[20:27] <camelia> rakudo-moar 97eafa: OUTPUT«False␤True␤»

[20:27] *** u is now known as ishanyx

[20:27] <timotimo> m: my @a = [1,0,1], [0,0,0]; say @a.Set.perl

[20:27] <camelia> rakudo-moar 97eafa: OUTPUT«set($[1, 0, 1],$[0, 0, 0])␤»

[20:28] <timotimo> probably is because arrays aren't a value type?

[20:28] *** agent008 left
[20:34] <Hotkeys> hm I guess

[20:34] <Hotkeys> there should be an op similar to python's 'in' IMO

[20:35] <Hotkeys> I know you can do ?@a.grep($thing) 

[20:35] * Hotkeys shrug

[20:37] *** mr-foobar joined
[20:37] *** dolmen joined
[20:38] *** pmurias left
[20:40] <ugexe> @b ~~ any(@a) ?

[20:40] *** ely-se joined
[20:40] <timotimo> yeah, usually we recommend "any"

[20:40] <Hotkeys> 'oh

[20:40] <Hotkeys> right

[20:44] *** rindolf joined
[20:47] *** CIAvash left
[20:48] <hankache> m: say 4 R/ 12;

[20:48] <camelia> rakudo-moar 97eafa: OUTPUT«3␤»

[20:49] <hankache> i wonder what is the use case for the reverse operator?

[20:49] <Hotkeys> I can't think of any off the top of my head

[20:50] <Hotkeys> but sometimes it makes the order of things nicer etc.

[20:50] <Hotkeys> or you can do things like

[20:50] <Hotkeys> m: my @a = ^10; say [R,] @a;

[20:50] <camelia> rakudo-moar 97eafa: OUTPUT«(9 8 7 6 5 4 3 2 1 0)␤»

[20:50] <hankache> oh ok

[20:51] <ugexe>  m: 1 R= my $a; say $a

[20:51] <camelia> rakudo-moar 97eafa: OUTPUT«1␤»

[20:51] <Hotkeys> oo

[20:51] <Hotkeys> that's neat

[20:51] <ugexe> combine with <== for great fun

[20:52] <Hotkeys> <== ?

[20:52] <Hotkeys> is that less-than or equal to assignment

[20:53] <hankache> m: my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9 0 1 2>; @array ==> unique() ==> sort() ==> reverse() ==> my @final-array; say @final-array;

[20:53] <camelia> rakudo-moar 97eafa: OUTPUT«[9 8 7 6 5 4 3 2 1 0]␤»

[20:53] <hankache> is like this ^^ but in reverse

[20:53] *** revhippie joined
[20:54] <hankache> it chains methods

[20:54] *** p6newbee left
[20:55] <hankache> Hotkeys see http://perl6intro.com/#_feed_operator

[20:55] <ugexe> m: my @a <== grep * > 3 <== (^5) R= my @f; say @a

[20:55] <camelia> rakudo-moar 97eafa: OUTPUT«[4]␤»

[20:55] <Hotkeys> oh

[20:56] <Hotkeys> ugexe: wot

[20:56] <Hotkeys> oh

[20:56] <Hotkeys> I see

[20:56] <ugexe> the job security operators/methods

[20:57] <Hotkeys> lol

[20:57] <Hotkeys> it's neat that it can feed into a new variable

[20:57] *** apiw left
[20:57] <Hotkeys> I like that

[20:58] <ugexe> ==>> will let it feed into *two* different arrays (its nyi)

[20:58] *** wamba left
[20:58] <Hotkeys> well that's ridonkulous

[20:59] <ugexe> or maybe the other way around, 2 into 1

[20:59] <ugexe> but all the pipe stuff will be cool when its done

[20:59] *** Begi1 joined
[20:59] <Hotkeys> 2 into 1 should be ====>

[21:00] <Hotkeys> :p

[21:00] *** Begi left
[21:00] *** Begi1 is now known as Begi

[21:02] *** apiw joined
[21:08] *** gorgor left
[21:09] *** jack_rabbit left
[21:11] *** gorgor joined
[21:12] *** SCHAAP137 joined
[21:13] <rudi_s_> Hi. Can I specify that a type should be either an Int or a Str in the type signature?

[21:13] <yoleaux> 1 Dec 2015 21:08Z <FROGGS> rudi_s_: please pull all the things and rebuild rakudo, Pointer is rw works now like shown in this test: https://github.com/rakudo/rakudo/commit/2b5c41e94f

[21:15] <ugexe> use a multi method (one for each type) or use foo($a where Int|Str)

[21:17] *** Murko_ joined
[21:17] <rudi_s_> ugexe: Thanks. Does that also work with optional argments? I get "Constraint type check failed for parameter '$user'" with sub file (:$user where Int|Str) {  } when called as file;

[21:19] <ugexe> hmm. well one way would probably be Int|Str|Nil, or setting a default value of ''

[21:20] *** Murko_ left
[21:21] <timotimo> you could "where any(Int|Str, !*.defined)" perhaps?

[21:21] <timotimo> i wonder if that works

[21:22] <ugexe> m: sub foo(Str(Cool) :$user = "") { say $user.perl; }; foo(user => "str"); foo(user => 1); foo() # if you dont care about turning Int into a Str

[21:22] <camelia> rakudo-moar 97eafa: OUTPUT«"str"␤"1"␤""␤»

[21:24] *** Averna left
[21:26] *** Averna joined
[21:28] *** cpage_ left
[21:30] *** cpage_ joined
[21:38] *** M-Illandan left
[21:41] *** Averna left
[21:46] *** Averna joined
[21:46] <rudi_s_> Yeah, I thought about Cool too, but I'd like to keep the type.

[21:46] <rudi_s_> ugexe: Thanks, will try |Nil.

[21:47] <rudi_s_> Hm. |Nil doesn't work, same error message.

[21:47] <rudi_s_> = '' would work, but that's a bit ugly.

[21:47] *** Averna left
[21:48] <rudi_s_> where any(Int|Str, !*.defined) works too, but that's a bit ugly.

[21:49] <rudi_s_> Is there a shorter way?

[21:49] <timotimo> you're not getting a Nil there

[21:50] <timotimo> if you know what exactly you get, you can put that in the initial |

[21:50] <timotimo> actually, Int | Str | !*.defined should work

[21:50] *** BenGoldberg_ joined
[21:53] *** Ben_Goldberg left
[21:54] <ugexe> m: proto sub foo(|) {*}; multi sub foo(Int :$user!, |c) { samewith(user => ~$user, |c) }; multi sub foo(Str :$user) { say $user.perl; }; foo(user => 1); foo(user => "one"); foo();

[21:54] <camelia> rakudo-moar 97eafa: OUTPUT«"1"␤"one"␤Str␤»

[21:55] *** hankache left
[21:57] <rudi_s_> timotimo: I get the value that Perl uses as default value if no arguments are given. I've no idea what that is. .WHAT says Any, but that isn't useful.

[21:58] <rudi_s_> Yeah, that works. Still a bit long though ..

[21:58] <timotimo> why not?

[21:58] <timotimo> you can Int | Str | Any:U

[21:58] <timotimo> Any is totally a thing

[21:59] <rudi_s_> timotimo: Didn't think of :U - but won't that also allow something like foo(Str)?

[21:59] <timotimo> ah, yes, it would

[21:59] <rudi_s_> Hm. !*.defined also allows Str.

[21:59] <rudi_s_> Hm.

[22:01] <timotimo> true

[22:01] <rudi_s_> It looks like I need :D everywhere. Is it possible to tell Perl to automatically enforce :D? Looks weird that I can have types but they don't have to be values but can be classes as well.

[22:01] <timotimo> you can define a sentinel value for "this argument not passed"

[22:02] <rudi_s_> ugexe: Sadly the function takes many arguments, so multi doesn't help.

[22:02] *** Ben_Goldberg joined
[22:02] <rudi_s_> Yeah, = '' would be good enough in my case, but feels a little ugly. I'd like to easily check for undefined values and still tell Perl to verify the type.

[22:05] *** Ben_Goldberg left
[22:05] *** BenGoldberg_ left
[22:06] *** Ben_Goldberg joined
[22:08] <AlexDaniel> timotimo: what else do you want to have in ENV variables?

[22:08] <AlexDaniel> m: say %*ENV<ME>

[22:08] <camelia> rakudo-moar 97eafa: OUTPUT«AlexDaniel␤»

[22:08] *** lizmat left
[22:08] <timotimo> if we could put arrays into %*ENV, that'd be cool for the whole nicklist

[22:08] <timotimo> how do you feel about last line said?

[22:08] *** lizmat joined
[22:10] <AlexDaniel> timotimo: well, I can make camelia say that she loves me

[22:10] <AlexDaniel> but besides that it's useless

[22:10] <AlexDaniel> and the whole nicklist is even more useless, I guess

[22:10] <timotimo> that's not useless

[22:11] <AlexDaniel> timotimo: what's the use-case then?

[22:11] <timotimo> i have no idea

[22:11] <timotimo> someone will come up with something

[22:11] <Ben_Goldberg> m: say 0 == Numeric.new

[22:11] <camelia> rakudo-moar 97eafa: OUTPUT«Memory allocation failed; could not allocate 58880 bytes␤»

[22:11] *** kaare_ left
[22:12] <timotimo> endless recursion ^

[22:12] <AlexDaniel> and what about the nicklist? Sure you can annoy random people but…

[22:13] <Ben_Goldberg> m: say Numeric.HOW

[22:13] <camelia> rakudo-moar 97eafa: OUTPUT«Perl6::Metamodel::ParametricRoleGroupHOW.new␤»

[22:13] <timotimo> yeah, ok, the nicklist *is* useless

[22:16] <Hotkeys> in what cases can you do things like @a.grep($foo):k instead of @a.grep($foo,:k)

[22:16] *** kurahaupo joined
[22:17] <AlexDaniel> Hotkeys: in all cases?

[22:17] <Hotkeys> I've tried it in many places

[22:17] <AlexDaniel> Hotkeys: except when it creates parsing problems (e.g. it is not clear what you have meant)

[22:17] <Hotkeys> and gotten "unexpected parameter :foo passed"

[22:17] <AlexDaniel> Hotkeys: because you are trying to adverb something else

[22:18] <AlexDaniel> in which case you have to put parens to force it to do what you want

[22:18] <Hotkeys> like "[R-] @h.grep($w,:k)"

[22:18] <Hotkeys> (but with :k outside)

[22:18] *** Begi1 joined
[22:19] <AlexDaniel> m: say [~] %*ENV<ME>.comb.pick: *

[22:19] <camelia> rakudo-moar 97eafa: OUTPUT«leaADlxeni␤»

[22:19] <AlexDaniel> m: say [~] %*ENV<ME>.comb.pick: *

[22:19] <camelia> rakudo-moar 97eafa: OUTPUT«eelnaxlADi␤»

[22:19] <AlexDaniel> m: say [~] %*ENV<ME>.comb.pick: *

[22:19] <camelia> rakudo-moar 97eafa: OUTPUT«inexDlelAa␤»

[22:19] <AlexDaniel> timotimo: ↑ ? :/

[22:19] *** Begi left
[22:19] *** Begi1 is now known as Begi

[22:19] <timotimo> :D

[22:19] <timotimo> eelnaxLadi, totally sounds like something out of a sci-fi show

[22:19] <AlexDaniel> lead lxeni

[22:20] <AlexDaniel> m: say ([~] %*ENV<ME>.comb.pick: *).lc.tc

[22:20] <camelia> rakudo-moar 97eafa: OUTPUT«Nldxeeaali␤»

[22:20] <AlexDaniel> m: say ([~] %*ENV<ME>.comb.pick: *).lc.tc

[22:20] <camelia> rakudo-moar 97eafa: OUTPUT«Aelleniadx␤»

[22:20] <AlexDaniel> m: my $s = ‘heLLo’; say tc lc [~] $s.comb.pick: *

[22:20] <camelia> rakudo-moar 97eafa: OUTPUT«Ohlel␤»

[22:21] <AlexDaniel> m: say tc lc [~] %*ENV<ME>.comb.pick: *

[22:21] <camelia> rakudo-moar 97eafa: OUTPUT«Aaldeenlxi␤»

[22:21] <timotimo> you know about tclc and friends?

[22:21] <timotimo> m: say "LOLWUT".tclc

[22:21] <camelia> rakudo-moar 97eafa: OUTPUT«Lolwut␤»

[22:21] <AlexDaniel> timotimo: I have no idea

[22:21] <AlexDaniel> never had to change the case

[22:21] <timotimo> it's a rare case

[22:22] <timotimo> BBIAB

[22:30] *** Averna joined
[22:30] <timotimo> oh well.

[22:35] *** Averna left
[22:40] <AlexDaniel> Hotkeys: are you saying that you can't use that on method calls?

[22:40] <Hotkeys> m: my @h = 5,1,2,3,4,5; my $w = 5; say [R-] @h.grep($w):k;

[22:40] <camelia> rakudo-moar 97eafa: OUTPUT«Unexpected named parameter 'k' passed␤  in block <unit> at /tmp/8sQcBXwuA6 line 1␤␤»

[22:40] <Hotkeys> AlexDaniel: 

[22:40] *** Averna joined
[22:41] <AlexDaniel> m: my @h = 5,1,2,3,4,5; my $w = 5; say [R-] (@h.grep($w):k);

[22:41] <camelia> rakudo-moar 97eafa: OUTPUT«5===SORRY!5=== Error while compiling /tmp/W_jO0_ZkyH␤Bogus postfix␤at /tmp/W_jO0_ZkyH:1␤------> 3,3,4,5; my $w = 5; say [R-] (@h.grep($w)7⏏5:k);␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤     …»

[22:41] <Hotkeys> m: my @h = 5,1,2,3,4,5; my $w = 5; say [R-] @h.grep($w,:k);

[22:41] <camelia> rakudo-moar 97eafa: OUTPUT«5␤»

[22:41] <AlexDaniel> m: my @h = <1 1 2 1 1>; @h.grep(1):k.say

[22:41] <camelia> rakudo-moar 97eafa: OUTPUT«(0 1 3 4)␤»

[22:42] <AlexDaniel> m: my @h = <1 1 2 1 1>; say @h.grep(1):k

[22:42] <camelia> rakudo-moar 97eafa: OUTPUT«(0 1 3 4)␤»

[22:42] <Hotkeys> why would it try to adverb [R-]

[22:42] <Hotkeys> m: my @h = <1 1 2 1 1>; say [R-] @h.grep(1):k

[22:42] <camelia> rakudo-moar 97eafa: OUTPUT«Unexpected named parameter 'k' passed␤  in block <unit> at /tmp/e_nvUF6eao line 1␤␤»

[22:43] <Hotkeys> this is interesting:

[22:43] <Hotkeys> m: my @h = <1 1 2 1 1>; say @h.grep:k:k: 1

[22:43] <camelia> rakudo-moar 97eafa: OUTPUT«(1 1 1 1)␤»

[22:43] <Hotkeys> bug?

[22:44] <AlexDaniel> m: my @h = <1 1 2 1 1>; say @h.grep:k: 1

[22:44] <camelia> rakudo-moar 97eafa: OUTPUT«(1 1 1 1)␤»

[22:44] <AlexDaniel> m: my @h = <1 1 2 1 1>; say @h.grep:k: 2

[22:44] <camelia> rakudo-moar 97eafa: OUTPUT«(2)␤»

[22:44] <AlexDaniel> Hotkeys: nope, it actually works

[22:44] <Hotkeys> well yes but it doesn't return the keys

[22:44] <AlexDaniel> you can pass the same argument multiple times if you really want to…

[22:44] <AlexDaniel> ah

[22:44] <Hotkeys> it just works normally

[22:44] <AlexDaniel> xD

[22:45] <Hotkeys> m: my @h = <1 1 2 1 1>; say @h.grep:nonsense: 1

[22:45] <camelia> rakudo-moar 97eafa: OUTPUT«(1 1 1 1)␤»

[22:45] <AlexDaniel> Hotkeys: well, it adverbs something!

[22:45] <AlexDaniel> Hotkeys: the question is: what exactly?

[22:46] <AlexDaniel> ok we need design docs…

[22:46] <Hotkeys> hmm

[22:46] <Hotkeys> m: my @h = <1 1 2 1 1>; say @h.grep:nonsense: 1; goto nonsense

[22:46] <camelia> rakudo-moar 97eafa: OUTPUT«5===SORRY!5=== Error while compiling /tmp/RxvvxP37Aw␤Undeclared routine:␤    nonsense used at line 1␤␤»

[22:46] <Hotkeys> aw

[22:46] <Hotkeys> m: my @h = <1 1 2 1 1>; say @h.grep:nonsense: 1; nonsense.^name.say

[22:46] <camelia> rakudo-moar 97eafa: OUTPUT«5===SORRY!5=== Error while compiling /tmp/hY30t2EEwa␤Undeclared routine:␤    nonsense used at line 1␤␤»

[22:47] <Hotkeys> just checking

[22:52] *** TEttinger left
[22:52] <AlexDaniel> m: sub foo(:$x) { say $x }; foo :25x :45x

[22:52] <camelia> rakudo-moar 97eafa: OUTPUT«45␤»

[22:52] *** rindolf left
[22:53] <AlexDaniel> “Perl 6 allows multiple same-named arguments, and records the relative order of arguments with the same name. When there are more than one argument, the @ sigil in the parameter list causes the arguments to be concatenated”

[22:53] <AlexDaniel> m: sub fun (Int :@x) { say @x }; fun( x => 1, x => 2 );

[22:53] <camelia> rakudo-moar 97eafa: OUTPUT«Type check failed in binding @x; expected Positional[Int] but got Int␤  in sub fun at /tmp/qtZ_IgESat line 1␤  in block <unit> at /tmp/qtZ_IgESat line 1␤␤»

[22:53] <jnthn> fwiw, I'd be surprised if that was every implemented.

[22:53] <jnthn> *ever

[22:54] <jnthn> It's likely incompatible with multi-dispatch for now.

[22:54] <jnthn> uh, for one

[22:54] <jnthn> Heh, one typo per line. Go me. 

[22:54] <jnthn> Should probably get tossed from the design docs, anyway.

[22:56] <jnthn> I suspect that .foo:bar: 1 is being parsed as a method name with colonpair parts, but somehow the latter part is getting dropped...

[22:56] <jnthn> m: 42.foo:sym<bar>

[22:56] <camelia> rakudo-moar 97eafa: OUTPUT«Method 'foo' not found for invocant of class 'Int'␤  in block <unit> at /tmp/eTh9RDyze5 line 1␤␤»

[22:56] <jnthn> Same there

[22:57] <jnthn> I suspect given we use such names for action methods, we should do something about canonicalizing the colonpairs into the name before doing the method dispatch

[22:57] <jnthn> Just as in

[22:57] <jnthn> m: say infix:< + >(1, 2)

[22:57] <camelia> rakudo-moar 97eafa: OUTPUT«3␤»

[22:58] <jnthn> So, the method one counts as an NYI. Dunno if it's in RT.

[22:58] *** espadrine left
[22:59] *** atweiden joined
[23:00] <AlexDaniel> jnthn: https://github.com/perl6/doc/issues/394 is it ok?

[23:01] *** neilb joined
[23:01] <jnthn> AlexDaniel: Sure :)

[23:03] <atweiden> m: my $array-index = *-1; say so $array-index ~~ *-1

[23:03] <camelia> rakudo-moar 97eafa: OUTPUT«Cannot call Numeric(WhateverCode: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at /tmp/MhEkRebx87 line 1␤␤»

[23:03] <atweiden> is it possible to smart match WhateverCode values? e.g. can you check for *-0 vs *-1 in a list?

[23:05] <atweiden> m: my @wecodes = [*-0, *-1, *-2, *-3]; say @wecodes.grep({$_ === *-1}).perl

[23:05] <camelia> rakudo-moar 97eafa: OUTPUT«(WhateverCode.new, WhateverCode.new, WhateverCode.new, WhateverCode.new).Seq␤»

[23:06] <jnthn> Smart-matching against a piece of code calls it

[23:06] *** virtualsue left
[23:06] *** ishanyx is now known as ilbelkyr

[23:06] <jnthn> With the thing on the LHS of the smartmatch as an argument

[23:06] <dalek> rakudo-star-daily: 6a58e6a | coke++ | log/ (9 files):

[23:06] <dalek> rakudo-star-daily: today (automated commit)

[23:06] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/6a58e6aa93

[23:07] <jnthn> m: say [*-0, *-1, *-2, *-3].grep({ .(0) == -1 })

[23:07] <camelia> rakudo-moar 97eafa: OUTPUT«(WhateverCode.new)␤»

[23:07] <jnthn> Something like that would work

[23:07] <atweiden> :o thanks

[23:07] <jnthn> (That is, is this a bit of code where, if I give it a 0, it spits out a -1)

[23:08] <jnthn> In general though, code is not comparable...

[23:08] * jnthn hides behind a huge "halting problem" sign :)

[23:10] <atweiden> m: my @z = qw<zero one two three four five six seven>; say @z[[*-0, *-1, *-2, *-3].grep({.(0) == -1})]

[23:10] <camelia> rakudo-moar 97eafa: OUTPUT«(seven)␤»

[23:12] <AlexDaniel> jnthn: I don't really understand the method:foo thing. What kind of a bug report should I submit?

[23:16] *** BenGoldberg_ joined
[23:16] *** apiw left
[23:18] *** Ben_Goldberg left
[23:18] *** BenGoldberg_ is now known as BenGoldberg

[23:19] *** BenGoldberg left
[23:20] *** BenGoldberg joined
[23:30] *** apiw joined
[23:30] *** mohae left
[23:31] *** mohae joined
[23:33] <jnthn> AlexDaniel: Probably a "Method calls with colonpairs in name NYI" or something

[23:33] <AlexDaniel> okay

[23:35] *** BenGoldberg left
[23:36] *** BenGoldberg joined
[23:39] *** mohae left
[23:40] *** mohae joined
[23:42] <jnthn> sleep &

[23:44] *** RabidGravy left
[23:47] *** firstdayonthejob left
[23:53] *** Begi left
[23:54] *** firstdayonthejob joined
