[00:26] *** djbkd left
[00:27] *** Zoffix left
[00:35] *** Zoffix joined
[00:35] *** MasterDuke joined
[00:35] <MasterDuke> .seen AlexDaniel

[00:35] <yoleaux> I saw AlexDaniel 8 Jul 2016 21:38Z in #perl6: <AlexDaniel> gfldex: maybe we can try smaller camelia? What do you think?

[00:36] <AlexDaniel> MasterDuke: ?

[00:36] <Zoffix> gfldex, the Issues seems to be locked on HTTP::Server::Simple. I don't see where to report issues. The tests fail on installation: https://gist.github.com/zoffixznet/45024edb136d5396ffe8815bcd5983d7

[00:36] <MasterDuke> for bisectbot, you've built a version of rakudo at every commit, correct?

[00:37] <AlexDaniel> yes

[00:37] <Zoffix> And HTTP::Server::Tiny is failing too :/ man, why are things like this when I actually try to build something with Perl 6....

[00:38] <MasterDuke> would it be possible to use those to create a version of camelia where you could specify the commit you'd like to use?

[00:39] <AlexDaniel> MasterDuke: sure

[00:39] <Zoffix> HTTP::Easy seems to be working.

[00:39] <MasterDuke> and also, how about a benchmarkbot? give it a list of commits and a block of code and it returns the timing numbers for running that block on those version of rakudo

[00:39] *** Zoffix left
[00:40] <AlexDaniel> MasterDuke: the thing is, the functionality of camelia and bisectbot overlap a lot… When I wrote bisectbot, some people said that it's better to keep them separated

[00:40] <AlexDaniel> MasterDuke: but it looks like it will be much better to merge them

[00:40] <AlexDaniel> bisectable: source

[00:40] <bisectable> AlexDaniel: https://github.com/perl6/bisectbot

[00:40] <AlexDaniel> MasterDuke: the source is there ↑, so feel free to hack on it

[00:41] <MasterDuke> the default could certainly stay the same (latest release), but it seems like it could be useful functionality

[00:41] <AlexDaniel> MasterDuke: I agree

[00:41] <AlexDaniel> MasterDuke: also, I still haven't moved it to hack, so I still host it myself… :)

[00:42] <MasterDuke> ha. how warm do you want your house to get?

[00:42] <AlexDaniel> MasterDuke: it's on a dedicated server, but CPU usage is really low

[00:43] <AlexDaniel> it takes about 7 minutes to create a build and currently it does 7 in parallel

[00:43] <AlexDaniel> so there are only short 7 minute spikes… :)

[00:44] <MasterDuke> if a benchmarkbot does end up getting created, it might be good to put it in its own cgroup or something like that

[00:44] <MasterDuke> so it doesn't kill the rest of the system, and hopefully the numbers are less effected by anything else also

[00:45] <MasterDuke> i.e., only give it 1-2 cores

[00:46] <AlexDaniel> MasterDuke: I thought about a variation of bisect: but to run it on every commit instead. This may solve some of the current issues with bisection :)

[00:47] <AlexDaniel> MasterDuke: then it can give a link to the output or something

[00:47] <MasterDuke> or the ranges of commits and their unique output

[00:47] <AlexDaniel> yea

[00:48] <AlexDaniel> MasterDuke: as for the benchmarking, you can always send me a thing you want to test

[00:48] <AlexDaniel> and I'll run it “manually” )

[00:48] <AlexDaniel> :)*

[00:49] <MasterDuke> cool, thanks

[00:49] <AlexDaniel> or once I move it to hack you'll probably be able to play with it yourself :)

[00:53] <MasterDuke> what's the directory structure that the different builds live under?

[00:55] <MasterDuke> hmm, looks like i can figure it out from process-sha

[00:59] <AlexDaniel> MasterDuke: it's just builds/123abc123abc123abc…/bin/perl6

[01:00] <MasterDuke> ahh, thanks

[01:04] *** sortiz joined
[01:05] *** cdg left
[01:06] *** kalkin- joined
[01:10] *** wamba left
[01:11] *** Actualeyes left
[01:12] *** TEttinger left
[01:12] *** girafe left
[01:15] <AlexDaniel> MasterDuke: I'm crashing to bed soon, feel free to leave me a message

[01:18] <sortiz> m: say 'x'.Numeric ~~ Failure; say 'x'.Int ~~ Failure; # Inconsistency bug?

[01:18] <camelia> rakudo-moar f583f2: OUTPUT«True␤Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5x' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[01:20] <gfldex> .tell Zoffix HTTP::Server::Simple is fixed

[01:20] <yoleaux> gfldex: I'll pass your message to Zoffix.

[01:21] *** AndyBotwin joined
[01:24] *** Actualeyes joined
[01:33] *** AlexDaniel left
[01:35] *** cdg joined
[01:39] *** espadrine joined
[01:42] *** cdg left
[01:43] *** molaf left
[01:45] *** addison left
[01:45] *** Zoffix joined
[01:56] <Zoffix> Hacked together a helper for myself to go through the RT queue. Maybe it's useful for someone too: https://github.com/zoffixznet/perl6-Ticket-Trakr

[01:56] *** molaf joined
[01:56] <yoleaux> 01:20Z <gfldex> Zoffix: HTTP::Server::Simple is fixed

[01:56] <Zoffix> gfldex++

[01:57] <sortiz> m: dd min(Failure.new, Str).WHAT, (Failure.new min Str).WHAT

[01:57] <camelia> rakudo-moar f583f2: OUTPUT«Num␤Failure␤»

[01:57] <Zoffix> :|

[01:58] * sortiz found a mine field

[01:59] <gfldex> m: my @a = [[1,2,3],[[4,5],6]]; dd @a.duckmap({ $_ ~~ Num ?? $_+1 !! Any })

[01:59] <camelia> rakudo-moar f583f2: OUTPUT«Memory allocation failed; could not allocate 6289984 bytes␤»

[02:00] <gfldex> does duckmap actually work?

[02:00] <sortiz> m: dd max(Str, Failure.new).WHAT; # Really!?

[02:00] <camelia> rakudo-moar f583f2: OUTPUT«Num␤»

[02:01] *** AndyBotwin left
[02:01] <sortiz> m: dd (Str max Failure.new).WHAT; # Sane

[02:01] <camelia> rakudo-moar f583f2: OUTPUT«Failure␤»

[02:02] *** killbill left
[02:03] *** AndyBotwin joined
[02:03] <ugexe> m: class Foo is DateTime { has $.a;  }; say Foo.new(:a(1)); # Is DateTime not supposed to be subclassed?

[02:03] <camelia> rakudo-moar f583f2: OUTPUT«Cannot call Foo.new with these named parameters: a␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[02:03] <ugexe> m: class Foo is DateTime {  }; say Foo.new

[02:03] <camelia> rakudo-moar f583f2: OUTPUT«Cannot make a Foo object using .new␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[02:03] <sortiz> Zoffix++ # RT tracker, nice!!

[02:04] <dalek> doc: d3f2534 | (Wenzel P. P. Peppmeyer)++ | doc/Type/Any.pod6:

[02:04] <dalek> doc: doc Any.deepmap

[02:04] <dalek> doc: review: https://github.com/perl6/doc/commit/d3f2534e6e

[02:06] <Zoffix> ugexe, isn't it still using DateTime's method new? It's specially made to take only specific named args

[02:06] *** skids joined
[02:07] <Zoffix> m: class Foo is DateTime { has $.a; method new (:$a) { self.bless: '2016-05-06', :$a  }; my $x = Foo.new(:a(1)); say $x.a; say $x.Str

[02:07] <camelia> rakudo-moar f583f2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3x = Foo.new(:a(1)); say $x.a; say $x.Str7⏏5<EOL>␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        statement…»

[02:08] <Zoffix> eh, well something or other :)

[02:08] <geekosaur> need another } after the first

[02:08] <Zoffix> It's still broken 'cause bless doesn't take positionals :)

[02:08] <sortiz> m: DateTime.new;

[02:08] <camelia> rakudo-moar f583f2: OUTPUT«Cannot make a DateTime object using .new␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[02:08] <ugexe> m: class Foo is DateTime { has $.a;  method new($a) { self.bless(:$a) }; }; say Foo.new(1);

[02:08] <camelia> rakudo-moar f583f2: OUTPUT«Invocant requires an instance of type Int, but a type object was passed.  Did you forget a .new?␤  in block <unit> at <tmp> line 1␤␤»

[02:09] <Zoffix> huh

[02:10] <ugexe> m: class Foo is DateTime { has $.a;  submethod BUILD(:$!a) {}; }; say Foo.new(a => 1)

[02:10] <camelia> rakudo-moar f583f2: OUTPUT«Cannot call Foo.new with these named parameters: a␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[02:10] <Zoffix> ¯\_(ツ)_/¯

[02:11] <tbrowder> lizmat: okay, but in my defense.

[02:12] <Zoffix> "<lizmat> if you set TEST_JOBS=8 on an i7, it takes around 4 minutes nowadays"  really?

[02:12] <Zoffix> Man, I need an upgrade :|

[02:14] <tbrowder> lizmat: (once more) okay, but, in my defense, I think I said in each recent PR review request, that I had done the table tests (thereby implying no full spec test). I will fix the problem, do the full spec test, and resubmit.

[02:19] *** AndyBotwin left
[02:19] <Zoffix> m: say 335/60

[02:19] <camelia> rakudo-moar f583f2: OUTPUT«5.583333␤»

[02:20] <Zoffix> Takes 5.5 mins on my VirtualBox with i5 in host. But it hangs a lots of times and I dunno why :/

[02:20] *** Zoffix left
[02:22] *** ChoHag joined
[02:23] *** travis-ci joined
[02:23] <travis-ci> Doc build passed. Wenzel P. P. Peppmeyer 'doc Any.deepmap'

[02:23] <travis-ci> https://travis-ci.org/perl6/doc/builds/143489568 https://github.com/perl6/doc/compare/b42b05375855...d3f2534e6ed5

[02:23] *** travis-ci left
[02:28] *** aindilis joined
[02:29] *** buharin left
[02:38] <sortiz> m: 

[02:46] *** xtreak joined
[02:50] *** buharin joined
[02:52] *** noganex_ joined
[02:53] *** BrassLantern joined
[02:53] *** BrassLantern left
[02:53] *** BrassLantern joined
[02:55] *** noganex left
[03:00] *** huggable joined
[03:01] *** xtreak left
[03:06] *** TEttinger joined
[03:07] <BenGoldberg> m: say 1⁄4

[03:07] <camelia> rakudo-moar f583f2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Bogus postfix␤at <tmp>:1␤------> 3say 17⏏5⁄4␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier␤        state…»

[03:10] <Xliff_zzz> Does anyone know of a module that can take a hash and turn it into XML?

[03:10] <Xliff_zzz> Or any data struct, really.

[03:12] <Xliff_zzz> Hmmm.... let's try XML::Class

[03:14] <Xliff_zzz> Urgh. No. XML::Class is too heavy

[03:16] <BenGoldberg> What about the XML class?

[03:16] <BenGoldberg> https://github.com/supernovus/exemel

[03:17] <BenGoldberg> or XML::Writer ?

[03:20] *** labster left
[03:23] *** skids left
[03:25] *** Senji joined
[03:29] *** kid51 joined
[03:32] *** sortiz left
[03:38] <Xliff_zzz> XML is too low level. I don't want to have to think about the nodes. I just want to pass a hash or array and have it do the conversion.

[03:39] <Xliff_zzz> No docs for XML::Writer.

[03:41] *** z3ndrag0n joined
[03:48] *** Herby_ left
[03:49] *** kid51 left
[03:56] *** canopus left
[03:57] *** kaare_ joined
[04:05] *** canopus joined
[04:12] *** rgrinberg left
[04:18] *** BrassLantern left
[04:21] *** labster joined
[04:28] <gtodd> how "general"  is  the implementation of "." and ".="  for method calls ... is it an just another perl6 operator (a "function") ?   

[04:32] *** khw left
[04:34] <gtodd> the function and method versions of "lc" for example are same-ishly consistent and return but don't change the string they are pointed at. But with the method you can use ".="  e.g.:    my $word="Horse" ;  lc($word) ;  say $word; $word.lc ;  say $word; $word.=lc; say $word; and do the changes in place ... 

[04:44] <geekosaur> <op>= is a meta-operator; `x <op>= y` is `x  = x <op> y` except x is only referenced once. this works for `.` as it does for e.g. `+`

[04:46] <gtodd> ok thanks ... noticed that say ruby has differently named functions  .downcase and .downcase! (which make it seem like the syntax is in the function name?) ... whereas perl6 seems to leverage operators (and sigils twigils etc.) to great effect.

[04:46] <geekosaur> ruby is channeling smalltalk with the suffix ! meaning mutating

[04:47] *** dupek joined
[04:47] <geekosaur> but they are distinct methods and iirc ruby does not actually check that foo and foo! are the same except that the latter mutates in place

[04:48] <parabolize> pretty sure its just a convention

[04:48] <geekosaur> (I should say #foo and #foo!)

[04:48] *** Cabanossi joined
[04:51] <geekosaur> nor does it automagically create mutating methods for you, if you have #foo then you can't use #foo! and have it figure out to create that (absent some horrid metaprogramming, which would be rather scary for this usage)

[04:54] *** djbkd joined
[04:56] *** dupek left
[05:05] *** dj_goku joined
[05:05] *** andrzejku joined
[05:16] *** andrzejku left
[05:16] *** dupek joined
[05:17] *** dupek left
[05:17] *** andrzejku joined
[05:44] *** domm joined
[05:53] *** TEttinger left
[05:55] *** loren joined
[06:03] *** TEttinger joined
[06:08] *** djbkd left
[06:14] *** molaf left
[06:20] *** CIAvash joined
[06:22] *** samb1 joined
[06:29] *** andrzejku left
[06:36] *** yguo joined
[06:40] *** yguo left
[06:51] *** RabidGravy joined
[06:55] *** espadrine left
[06:59] *** yguo joined
[07:00] *** huggable left
[07:00] *** huggable joined
[07:02] *** espadrine joined
[07:02] *** yguo left
[07:04] *** yguo joined
[07:04] *** kurahaupo joined
[07:06] *** Actualeyes left
[07:12] *** wamba joined
[07:14] *** yguo left
[07:18] *** darutoko joined
[07:19] *** Actualeyes joined
[07:22] *** kurahaupo left
[07:23] *** holyghost joined
[07:25] *** setty1 joined
[07:47] *** wamba left
[07:53] *** holyghost left
[08:09] *** loren left
[08:19] *** firstdayonthejob joined
[08:26] *** pdcawley joined
[08:28] *** holyghost joined
[08:28] *** holyghost left
[08:33] *** labster left
[08:36] *** RabidGravy left
[08:58] *** maybekoo2 joined
[09:03] *** loren joined
[09:05] *** AlexDaniel joined
[09:06] *** BenGoldberg left
[09:14] *** FROGGS joined
[09:24] *** iH2O joined
[09:25] *** grondilu joined
[09:38] *** dalek joined
[09:38] *** ChanServ sets mode: +v dalek

[10:03] *** iH2O left
[10:04] *** pyrimidi_ joined
[10:04] *** jjido joined
[10:05] *** firstdayonthejob left
[10:16] *** hankache joined
[10:16] <hankache> morning #perl6

[10:19] *** loren left
[10:23] *** AlexDaniel left
[10:23] <lizmat> morning hankache!

[10:23] <hankache> hi lizmat

[10:27] <hankache> lizmat++ for all the speed improvements. Each time i see XYZ about X time faster.

[10:29] <lizmat> hankache: sometimes the win is really in fewer allocations, causing fewer GC's

[10:29] <lizmat> but that's very hard to put a finger on

[10:31] <hankache> lizmat how do you measure the speed? I'd like to test different ways of doing the same things and see which one is faster.

[10:31] <lizmat> time perl6 -e

[10:31] <lizmat> and perl6 --profile

[10:32] <hankache> normally i do "now - init now" but it is getting cumbersome

[10:32] <hankache> aha ok

[10:33] <hankache> would you run the same script multiple time and average the time or just once?

[10:34] <lizmat> run it at least 3 times with 10 second intervals, take the lowest

[10:34] <lizmat> also run an empty loop to find out the overhead

[10:35] <hankache> thanks lizmat. or should i say lizmagic :)

[10:35] <lizmat> don't make me blush   :-)

[10:36] <hankache> lizmagic lizmagic lizmagic lizmagic

[10:36] <hankache> :D

[10:37] <lizmat> *blush*   :-)

[10:48] *** rindolf joined
[10:49] *** ely-se joined
[10:49] *** ely-se is now known as rightfold

[10:52] *** TEttinger left
[10:52] <cognominal> In some Perl6 package distros, I see xt/ in addition to t/ . It seems that tests that are not run during the install. This seems to defeat the purpose of tests.  Example of such package : https://github.com/skaji/mi6

[10:53] *** kurahaupo joined
[10:58] <arnsholt> IIRC you have the same convention on CPAN; IIRC they're called author tests

[10:58] <cognominal> thx arnsholt 

[10:58] <arnsholt> Basically tests only intended to be run by the author

[10:59] <hankache> cognominal xt are tests that are run only by the author 

[10:59] <cognominal> hi hankache 

[10:59] <hankache> ex: make sure that META is ok etc.

[10:59] <hankache> salut cognominal

[11:00] *** huggable left
[11:00] *** huggable joined
[11:02] *** wamba joined
[11:07] *** wamba left
[11:07] *** wamba joined
[11:10] *** loren joined
[11:30] *** kurahaupo left
[11:32] *** loren left
[11:42] <MasterDuke> .tell AlexDaniel https://github.com/perl6/bisectbot/pull/1

[11:42] <yoleaux> MasterDuke: I'll pass your message to AlexDaniel.

[11:45] *** Senji left
[11:45] *** Senj joined
[11:46] *** jjido left
[11:47] <wamba> m: class SortedMap { has $.pok = 1; };   my $a = SortedMap.new();say $a.pok

[11:47] <camelia> rakudo-moar 4e4039: OUTPUT«1␤»

[11:48] <wamba> m: class SortedMap is Map  { has $.pok = 1; };   my $a = SortedMap.new();say $a.pok

[11:48] <camelia> rakudo-moar 4e4039: OUTPUT«(Any)␤»

[11:49] *** kid51 joined
[11:53] <timotimo> ah, Map won't delegate to BUILDALL in its "new" constructor

[11:53] <lizmat> wamba: you realize that Map is immutable, so Map.new creates an empty Map that you cannot change

[11:54] <wamba> m: class SortedMap is Hash  { has $.pok = 1; };   my $a = SortedMap.new();say $a.pok

[11:54] <camelia> rakudo-moar 959cd3: OUTPUT«(Any)␤»

[11:54] <lizmat> ok, so you really want to create a SortedHash

[11:57] *** iH2O joined
[11:57] *** jjido joined
[11:57] *** AlexDaniel joined
[11:57] <AlexDaniel> .

[11:57] <yoleaux> 11:42Z <MasterDuke> AlexDaniel: https://github.com/perl6/bisectbot/pull/1

[11:59] <lizmat> wamba: please rakudobug this

[12:00] <AlexDaniel> MasterDuke: nice! There's one weird thing though

[12:01] <AlexDaniel> MasterDuke: ｢if ($exit == 0) {｣ – it looks like we want to print the output anyway

[12:01] <AlexDaniel> MasterDuke: even if the exit code is non-zero

[12:01] *** Senji joined
[12:01] <dalek> bisectbot: 874f092 | (Daniel Green)++ | / (2 files):

[12:01] <dalek> bisectbot: Add a new bot that will run code at the given commit

[12:01] <dalek> bisectbot: review: https://github.com/perl6/bisectbot/commit/874f092fca

[12:01] <dalek> bisectbot: 06ec04d | (Aleks-Daniel Jakimenko-Aleksejev)++ | / (2 files):

[12:01] <dalek> bisectbot: Merge pull request #1 from MasterDuke17/committable

[12:01] <dalek> bisectbot: 

[12:01] <dalek> bisectbot: Add a new bot that will run code at the given commit

[12:01] <dalek> bisectbot: review: https://github.com/perl6/bisectbot/commit/06ec04d21c

[12:02] <AlexDaniel> MasterDuke: also it does not cut the output if it's way too long :)

[12:02] *** jjido left
[12:02] <AlexDaniel> MasterDuke: but it's a good starting point, yeah

[12:03] *** Senj left
[12:04] *** cognominal left
[12:04] <dalek> doc: 128e0c9 | (Wenzel P. P. Peppmeyer)++ | / (2 files):

[12:04] <dalek> doc: Replace the search placeholder with a single unicode sign.

[12:04] <dalek> doc: review: https://github.com/perl6/doc/commit/128e0c914e

[12:05] *** Actualeyes left
[12:06] *** kaare_ left
[12:06] <tbrowder> mornin' #perl6

[12:07] <tbrowder> lizmat: sorry about the last PR

[12:08] <wamba> m: class SortedMap is Hash { my $pok = 1; method pok ( $value? ) { with $value {  $pok = $_ } else { $pok } } }; 

[12:08] <camelia> rakudo-moar 959cd3: ( no output )

[12:08] <wamba>  my $a = SortedMap.new("a" => 2, "b" => 3 );say $a.pok(2),$a.keys,$a.pok

[12:09] <wamba> m: class SortedMap is Hash { my $pok = 1; method pok ( $value? ) { with $value {  $pok = $_ } else { $pok } } };  my $a = SortedMap.new("a" => 2, "b" => 3 );say $a.pok(2),$a.keys,$a.pok

[12:09] <camelia> rakudo-moar 959cd3: OUTPUT«2(a b)2␤»

[12:12] <wamba> I try this make with has $.pok. How is it possible?

[12:12] <timotimo> you can mix a trait into the instance

[12:13] <timotimo> m: role Sorted { has $.pok = 1 }; my %foo = a => 1, b => 2; %foo does Sorted; say %foo.perl; say %foo.pok

[12:13] <camelia> rakudo-moar 959cd3: OUTPUT«{:a(1), :b(2)}␤1␤»

[12:13] <timotimo> m: role Sorted { has $.pok = 1 }; my %foo = a => 1, b => 2; %foo does Sorted; say %foo.perl; say %foo.pok; %foo.pok = 99; say %foo.pok

[12:13] <camelia> rakudo-moar 959cd3: OUTPUT«{:a(1), :b(2)}␤1␤Cannot modify an immutable Int␤  in block <unit> at <tmp> line 1␤␤»

[12:13] <timotimo> m: role Sorted { has $.pok is rw = 1 }; my %foo = a => 1, b => 2; %foo does Sorted; say %foo.perl; say %foo.pok; %foo.pok = 99; say %foo.pok

[12:13] <camelia> rakudo-moar 959cd3: OUTPUT«{:a(1), :b(2)}␤1␤99␤»

[12:15] *** cognominal joined
[12:18] *** hankache left
[12:19] <tbrowder> lizmat: As I tossed and turned last night, I thought about what I had done that might have had coupling outside the modified file (Pod.nqp) and the only thing was a sub rename. I just checked and, sure enough, that is used in Grammar.npq, hence the exception on a test that happened to need it.  Thus showing the need for a full spec test.  Another way I could

[12:19] <tbrowder> have avoided the problem would have been to do a make realclean which should have caught the sub rename and missing sub.  Anyhow, I will fix the reverted PR, do a full spec test, and resubmit.  And I will try to stick with that process in the future.

[12:23] <wamba> timitimo: thank you, with Map works too

[12:23] <wamba> m: role Sorted { has $.pok is rw = 1 }; my $a = Map.new("a" => 1, "b" => 2); $a does Sorted; say $a.perl; say $a.pok; $a.pok = 

[12:23] <wamba> 99; say $a.pok

[12:23] <camelia> rakudo-moar 959cd3: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Missing required term after infix␤at <tmp>:1␤------> 3orted; say $a.perl; say $a.pok; $a.pok =7⏏5<EOL>␤    expecting any of:␤        prefix␤        term␤»

[12:23] <wamba> m: role Sorted { has $.pok is rw = 1 }; my $a = Map.new("a" => 1, "b" => 2); $a does Sorted; say $a.perl; say $a.pok; $a.pok =  99; say $a.pok

[12:23] <camelia> rakudo-moar 959cd3: OUTPUT«Map+{Sorted}.new((:a(1),:b(2)))␤1␤99␤»

[12:24] *** AlexDaniel left
[12:25] *** sena_kun joined
[12:26] <dalek> doc: 38b77c4 | (Wenzel P. P. Peppmeyer)++ | / (2 files):

[12:26] <dalek> doc: Move CSS from sourounging div to input element to allow for resize on

[12:26] <dalek> doc: focus/transitions etc. This is in preparations of the redesign.

[12:26] <dalek> doc: review: https://github.com/perl6/doc/commit/38b77c4b61

[12:26] *** Actualeyes joined
[12:26] <gfldex> ENEEDMORETEA

[12:27] *** rightfold left
[12:28] *** iH2O left
[12:39] *** skids joined
[12:40] <dogbert17> o/ #perl6

[12:40] <dogbert17> m: my $capture = \(2, 3, apples => 2); say $capture.Str; 

[12:40] <camelia> rakudo-moar 959cd3: OUTPUT«2 3 apples   2␤»

[12:41] <dogbert17> so someone has already fixed the Capture.Str problem, impressive

[12:43] <dogbert17> do we still need and RT for this?

[12:43] <dogbert17> s/and/an/

[12:44] <gfldex> no

[12:44] <timotimo> just a test would probably be enough; but that might already exist, to

[12:46] *** yqt joined
[12:47] <dogbert17> gfldex: ok

[12:58] *** kurahaupo joined
[13:08] *** hankache joined
[13:12] *** maybekoo2 left
[13:12] *** espadrine left
[13:12] *** loren joined
[13:16] <dogbert17> strange, the recently documented deepmap method is not present in the search box

[13:17] <dogbert17> ah, I see what the problem is, should I fix it?

[13:23] <arnsholt> Can't see why not =)

[13:24] <dogbert17> ok, will fix

[13:25] *** kurahaupo left
[13:25] *** kurahaupo joined
[13:25] *** kurahaupo left
[13:26] <arnsholt> And if there turns out to be a reason not to, it's straightforward to revert a change. That's what version control is for, after all =)

[13:28] *** espadrine joined
[13:30] <dalek> doc: e268500 | (Jan-Olof Hendig)++ | doc/Type/Any.pod6:

[13:30] <dalek> doc: Make Any.deepmap available in the search box

[13:30] <dalek> doc: review: https://github.com/perl6/doc/commit/e26850016c

[13:36] *** yqt left
[13:36] <arnsholt> dogbert17++

[13:43] <dogbert17> anyone know what this 'is nodal' trait is?

[13:43] <timotimo> it's about hyper operators

[13:43] <timotimo> whether it should descend into structures or not

[13:43] <timotimo> like >>.elems on a nested list wouldn't make sense if it descended

[13:43] <timotimo> because it'd turn [[1, 2, 3], [9, 9, 9, 9]] into [[1, 1, 1], [1, 1, 1, 1]]

[13:44] <dogbert17> timotimo: so if you want something to descend it should have the 'is nodal' ?

[13:46] <psch> m: say &elems.^can('nodal')

[13:46] <camelia> rakudo-moar 959cd3: OUTPUT«(nodal)␤»

[13:47] <dogbert17> hmm, maybe I should read up on this

[13:48] <dogbert17> atm, the docs is a bit lacking: https://docs.perl6.org/routine/is%20nodal

[13:49] <psch> m: say &say.^can('nodal')

[13:49] <camelia> rakudo-moar 959cd3: OUTPUT«()␤»

[13:49] <psch> m: [[1,2],[3,4]]>>.say

[13:49] <camelia> rakudo-moar 959cd3: OUTPUT«1␤2␤3␤4␤»

[13:49] <psch> m: say [[1,2],[3,4]]>>.elems

[13:49] <camelia> rakudo-moar 959cd3: OUTPUT«(2 2)␤»

[13:50] *** mst joined
[13:50] *** mst_ joined
[13:51] <dogbert17> psch: thx for the examples, I have to admit that I haven't looked into hyper operators yet. My loss it would seem..

[13:51] *** loren left
[13:52] <tbrowder> [Coke]: ref yesterday's advive to see RT page <https://rt.perl.org/Prefs/Other.html>, I have seen that page before and used it, but I still don't see the issue I own on the top 10.  I have filed a support request with perlbug-admin.

[13:56] *** kaare_ joined
[13:56] *** mst left
[13:56] *** mst_ left
[13:57] *** mst joined
[13:57] *** brrt joined
[13:59] *** khw joined
[14:00] <dalek> doc: 4f7ece0 | (Wenzel P. P. Peppmeyer)++ | doc/Language/typesystem.pod6:

[14:00] <dalek> doc: doc is nodal

[14:00] <dalek> doc: review: https://github.com/perl6/doc/commit/4f7ece0baf

[14:00] *** jjido joined
[14:05] <dogbert17> gfldex++

[14:07] <dalek> doc: cf6f118 | (Wenzel P. P. Peppmeyer)++ | / (2 files):

[14:07] <dalek> doc: remove more blueness from sidelined ToC

[14:07] <dalek> doc: review: https://github.com/perl6/doc/commit/cf6f11894c

[14:07] *** TakinOver left
[14:11] *** andrzejku joined
[14:21] *** brrt left
[14:26] *** jjido left
[14:26] *** cdg joined
[14:31] *** z3ndrag0n left
[14:31] *** bpmedley joined
[14:32] *** z3ndrag0n joined
[14:34] *** cdg left
[14:35] <hankache> i was trying to provide the method render of Pod::To::HTML with a string containing pod. Unfortunately it is not working. Any ideas what I should do?

[14:35] <hankache> the pod is a separate file

[14:35] <gfldex> hankache: you have to eval it

[14:36] <gfldex> hankache: $pod = (EVAL ($io.slurp ~ "\n\$=pod"));

[14:36] <gfldex> replace the $io.slurpy with your pod string

[14:47] *** brrt joined
[14:53] <dalek> bisectbot: 5cba60d | (Daniel Green)++ | committable.pl:

[14:53] <dalek> bisectbot: Include the error code with the reply if it's non-zero

[14:53] <dalek> bisectbot: review: https://github.com/perl6/bisectbot/commit/5cba60d8f6

[14:53] <dalek> bisectbot: c04e228 | (Aleks-Daniel Jakimenko-Aleksejev)++ | committable.pl:

[14:53] <dalek> bisectbot: Merge pull request #2 from MasterDuke17/committable

[14:53] <dalek> bisectbot: 

[14:53] <dalek> bisectbot: Include the error code with the reply if it's non-zero

[14:53] <dalek> bisectbot: review: https://github.com/perl6/bisectbot/commit/c04e2283fc

[14:55] *** AndyBotwin joined
[14:55] *** kaare_ left
[14:56] *** kaare_ joined
[14:59] <hankache> gfldex not working :(

[15:00] <hankache> the file contains =begin pod and =end pod with multiple lines in it

[15:00] *** huggable left
[15:00] *** huggable joined
[15:00] <gfldex> hankache: can you provide source code?

[15:00] <timotimo> i think we should have a saner way to get at an evaluated code's pod data ... maybe something like CTXSAVE? PODSAVE :)

[15:01] <timotimo> at the end of parsing, it'll just call $*PODSAVE($=pod) from inside the parser

[15:03] <hankache> gfldex https://gist.github.com/hankache/f5319b907564887a60c4a3a6dd26802c

[15:04] <hankache> gfldex basically what i am trying to do is provide my own header & footer. But i can't even render the pod.

[15:05] <hankache> i can do perl6 --doc=HTML test.pod6 > test.html but i was trying to figure out a way to give it my own c

[15:05] <hankache> my own css

[15:06] <hankache> after i looked at the code in Pod::To::HTML i saw that the method pod2html accepts $head and $footer and i can use them to inject my css and js

[15:07] <hankache> this is ultimately what i want to achieve

[15:12] *** andrzejku left
[15:12] *** hankache_ joined
[15:12] *** hankache_ left
[15:15] *** hankache left
[15:19] *** AndyBotwin left
[15:21] *** hankache joined
[15:21] *** girafe joined
[15:22] *** firstdayonthejob joined
[15:22] *** Zoffix joined
[15:22] <Zoffix> What's a simple way to blow up a failure?

[15:23] <timotimo> CALL-ME will immediately throw it

[15:24] *** Senji left
[15:25] *** Khisanth joined
[15:25] *** hankache left
[15:26] <Zoffix> hm

[15:27] <Zoffix> What is happening here? Is it some sort of laziness? https://gist.github.com/zoffixznet/9e6fc8ddfe921198dbce98776c2600c6 ?

[15:28] <Zoffix> I'm trying to make it blow up without `say`. Using `~` with something works, but I can't use it in cases when it doesn't blow up because in those a type object is returned.

[15:29] <gfldex> .tell hankache please update your Pod::To::HTML and follow https://github.com/perl6/Pod-To-HTML/blob/master/examples/01-parse-files.p6

[15:29] <yoleaux> gfldex: I'll pass your message to hankache.

[15:29] <timotimo> i don't think i get it

[15:29] <Zoffix> Oh, calling .gist does the trick

[15:30] *** maybekoo2 joined
[15:30] *** firstdayonthejob left
[15:31] *** RabidGravy joined
[15:34] *** holyghost joined
[15:48] *** firstdayonthejob joined
[15:49] *** domidumont joined
[15:49] *** bpa joined
[15:54] *** domidumont left
[15:55] *** holyghost left
[15:55] *** domidumont joined
[15:57] *** canopus left
[15:57] <bpa> p6: say ().WHAT; say ((1,2),(3,4)).flat;

[15:57] <camelia> rakudo-moar 959cd3: OUTPUT«(List)␤(1 2 3 4)␤»

[15:58] <bpa> p6: say [].WHAT; say [(1,2),(3,4)].flat;

[15:58] <camelia> rakudo-moar 959cd3: OUTPUT«(Array)␤((1 2) (3 4))␤»

[15:58] <bpa> Is this on purpose that List and Array have different behavior for flat?

[15:58] <timotimo> an array is a list of scalar containers

[15:58] *** rgrinberg joined
[15:58] <timotimo> so anything inside a list is scalar'd, and thus protected from flattening

[15:59] <timotimo> m: say ($(1,2),$(3,4)).flat

[15:59] <camelia> rakudo-moar 959cd3: OUTPUT«((1 2) (3 4))␤»

[15:59] <timotimo> ^- basically the same thing. more or less, anyway

[16:00] *** domidumont left
[16:01] <bpa> Is there an easy way to allow Array to use list's behavior, or do you need to create a new List?

[16:01] <timotimo> tbh, i always forget how to do this :)

[16:01] <timotimo> m: say [(1,2),(3,4)]>>.List.flat

[16:01] <camelia> rakudo-moar 959cd3: OUTPUT«(1 2 3 4)␤»

[16:03] <bpa> ok, that's perfect

[16:03] <bpa> p6: my @a = ((1,2),(3,4)); say @a.List.flat;

[16:03] <camelia> rakudo-moar 959cd3: OUTPUT«(1 2 3 4)␤»

[16:03] <Zoffix> .ask tbrowder can this be closed? https://rt.perl.org/Ticket/Display.html?id=128087

[16:03] <yoleaux> Zoffix: I'll pass your message to tbrowder.

[16:04] <bpa> The sad thing is that I tried lower case list and forgot the upper case version

[16:05] <bpa> p6: my @a = ((1,2),(3,4)); say @a.list.flat;

[16:05] <camelia> rakudo-moar 959cd3: OUTPUT«((1 2) (3 4))␤»

[16:05] <bpa> thanks

[16:05] <timotimo> m: my @a = (1, 2), (3, 4); say @a.WHAT; say @a.list.WHAT; say @a.List.WHAT

[16:05] <camelia> rakudo-moar 959cd3: OUTPUT«(Array)␤(Array)␤(List)␤»

[16:06] <timotimo> m: say Array ~~ List

[16:06] <camelia> rakudo-moar 959cd3: OUTPUT«True␤»

[16:06] <timotimo> that's why, i'd guess

[16:07] *** canopus joined
[16:10] *** rindolf left
[16:10] *** domidumont joined
[16:13] *** brrt left
[16:15] *** rindolf joined
[16:19] <tbrowder> Zoffix: I think #128087 should stay open unless we don't want a man page eventually (and in that case all mention of it needs to be eliminated).

[16:19] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128087

[16:19] <yoleaux> 16:03Z <Zoffix> tbrowder: can this be closed? https://rt.perl.org/Ticket/Display.html?id=128087

[16:20] <tbrowder> yoleaux: I think #128087 should stay open unless we don't want a man page eventually (and in that case all mention of it needs to be eliminated).

[16:20] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128087

[16:21] <tbrowder> Zoffix: why the need for msg passing?

[16:21] <Zoffix> tbrowder, but what docs did you mean? The other comment on the ticket is saying the docs included with rakudo are dev wiki and isn't suitable for man pages.

[16:22] <tbrowder> okay, let me look closer...

[16:22] <dalek> doc: f3f3518 | (Wenzel P. P. Peppmeyer)++ | template/search_template.js:

[16:22] <dalek> doc: change default value for #query in the template

[16:22] <dalek> doc: review: https://github.com/perl6/doc/commit/f3f3518dac

[16:22] <dalek> doc: 9bd1d93 | (Wenzel P. P. Peppmeyer)++ | / (2 files):

[16:22] <dalek> doc: add autogeneration warning to search_template.js

[16:22] <dalek> doc: review: https://github.com/perl6/doc/commit/9bd1d931d7

[16:27] <tbrowder> Zoffix: okay, I see the confusion.  Close #128087 and I'll submit another version.

[16:27] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128087

[16:28] <tbrowder> (grumble) RT is sure hard to read sometime...

[16:30] *** sortiz joined
[16:30] *** BenGoldberg joined
[16:33] <Zoffix> Closed. Thanks.

[16:39] *** noganex_ left
[16:42] <pmichaud> good morning, #perl6

[16:42] <pmichaud> I have an RT question.

[16:42] *** cdg joined
[16:42] <pmichaud> actually, let me try something and see if I still have that question.

[16:44] *** noganex joined
[16:46] *** domidumont left
[16:48] <sortiz> \o pmichaud

[16:49] <timotimo> hey pm

[16:49] <timotimo> glad to see you around

[16:51] <pmichaud> m:  say -1 ** -0.1    # RT 128584

[16:51] <camelia> rakudo-moar 959cd3: OUTPUT«-1␤»

[16:51] <pmichaud> m:  say (-1) ** -0.1    # RT 128584

[16:51] <camelia> rakudo-moar 959cd3: OUTPUT«NaN␤»

[16:52] *** Senji joined
[16:53] <pmichaud> and my RT question answered itself, so nevermind.  :)

[16:54] <sortiz> m: say "a".Numeric ~~ Failure

[16:54] <camelia> rakudo-moar 959cd3: OUTPUT«True␤»

[16:55] <BenGoldberg> m: "a".Numeric.WHAT.say

[16:55] <camelia> rakudo-moar 959cd3: OUTPUT«(Failure)␤»

[16:55] <sortiz> m: say "a".Int ~~ Failure

[16:55] <camelia> rakudo-moar 959cd3: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5a' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[16:55] <sortiz> That inconsistency bothers me.

[16:55] <pmichaud> it bothers me also

[16:55] <BenGoldberg> rakudobug it!

[16:56] <pmichaud> testing for Failure should not cause it to be thrown.

[16:56] <BenGoldberg> Of course, you'll have to change the specs and tests, too.

[16:56] <pmichaud> I suspect that one isn't tested.

[16:56] <BenGoldberg> m: "a".Int.WHAT.say

[16:56] <camelia> rakudo-moar 959cd3: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5a' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[16:56] <pmichaud> my understanding of the design is that  "a".Int ~~ Failure  should return true

[16:56] <pmichaud> it looks to me as though "a".Int is being overeager

[16:57] <BenGoldberg> Or it's actually, you know, throwing an exeption instead of failing.

[16:57] <psch> m: try "a".Int; say $!.perl

[16:57] <camelia> rakudo-moar 959cd3: OUTPUT«X::Str::Numeric.new(source => "a", pos => 0, reason => "base-10 number must begin with valid digits or '.'")␤»

[16:58] <pmichaud> according to src/perl6/Str.pm, I don't see anything there that will generate a Failure.

[16:58] <sortiz> Yep, Numeric fails, but Int throws

[17:00] <pmichaud> or it may be throwing simply because  Failure.Int throws

[17:00] *** Zoffix left
[17:00] <pmichaud> Str.Int is implemented as   Str.Numeric.Int

[17:00] <pmichaud> so Str.Numeric produces the Failure, and then .Int throws it.

[17:00] <psch> m: try "a".Numeric.Int; say $!.perl

[17:00] <camelia> rakudo-moar 959cd3: OUTPUT«X::Str::Numeric.new(source => "a", pos => 0, reason => "base-10 number must begin with valid digits or '.'")␤»

[17:01] <dalek> doc: 499b197 | (Wenzel P. P. Peppmeyer)++ | html/js/main.js:

[17:01] <dalek> doc: hitting Esc will give the search input focus

[17:01] <dalek> doc: review: https://github.com/perl6/doc/commit/499b1979ba

[17:04] *** domidumont joined
[17:04] <sortiz> So, in the general case it is better propagate Failures that throw it?

[17:04] <pmichaud> I'm not sure.

[17:05] <pmichaud> Because   Failure.Str   should almost certainly throw

[17:05] <sortiz> Sure.

[17:05] <pmichaud> so what makes .Str different from .Int?

[17:06] <pmichaud> It seems to me the correct answer is that Str.Int has to be a bit smarter about handling Failure, and not just delegating it to .Numeric

[17:07] <arnsholt> I don't think I can think of any methods that should *not* throw when called on Failure, TBH

[17:07] <psch> m: say "a".Numeric.defined

[17:07] <camelia> rakudo-moar 959cd3: OUTPUT«False␤»

[17:07] <pmichaud> feels like it should be  .Int with Str.Numeric   or something like that  (if I understand "with" correctly)

[17:08] <sortiz> See this case:

[17:08] <sortiz> m: for ^3 {  say ([min] Failure.new, |(Str xx $_)).WHAT;  }

[17:08] <camelia> rakudo-moar 959cd3: OUTPUT«(Num)␤(Failure)␤(Num)␤»

[17:09] <pmichaud> m:  say (.Int with "3".Numeric)

[17:09] <camelia> rakudo-moar 959cd3: OUTPUT«3␤»

[17:09] <pmichaud> m:  say (.Int with "3".Numeric).WHAT

[17:09] <camelia> rakudo-moar 959cd3: OUTPUT«(Int)␤»

[17:09] <pmichaud> m:  say (.Int with "a".Numeric).WHAT

[17:09] <camelia> rakudo-moar 959cd3: OUTPUT«(Slip)␤»

[17:10] <pmichaud> okay, not "with" then.

[17:10] <sortiz> m: (Failure.new min Str) ~~ Failure # Propagated

[17:10] <camelia> rakudo-moar 959cd3: ( no output )

[17:11] <sortiz> m: say (Failure.new min Str) ~~ Failure # Propagated

[17:11] <camelia> rakudo-moar 959cd3: OUTPUT«True␤»

[17:11] <pmichaud> yes, but comparison operators are explicitly propagated per S03

[17:11] <sortiz> m: say min(Failure.new.Str) ~~ Failure; # Throwed

[17:11] <camelia> rakudo-moar 959cd3: OUTPUT«Failed␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[17:11] <BenGoldberg> m: if "a".Numeric -> \success { say success.Int.WHAT } else -> \failure { say failure.WHAT };

[17:11] <camelia> rakudo-moar 959cd3: OUTPUT«(Failure)␤»

[17:12] <pmichaud> m:  say ("a".Numeric.?Int).WHAT

[17:12] <camelia> rakudo-moar 959cd3: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5a' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[17:12] <BenGoldberg> Something like that ^ inside of Str.Int, I think.

[17:12] <pmichaud> Oh!

[17:12] <BenGoldberg> Hmm?

[17:13] *** sftp joined
[17:13] <pmichaud> m: say "a".Numeric.defined

[17:13] <camelia> rakudo-moar 959cd3: OUTPUT«False␤»

[17:14] <sortiz> When not propagated, we need a 'try', otherwise we can handle in smart ways.

[17:14] <sortiz> m: without "a".Numeric { dd $_ };

[17:14] <camelia> rakudo-moar 959cd3: OUTPUT«Failure.new(exception => X::Str::Numeric.new(source => "a", pos => 0, reason => "base-10 number must begin with valid digits or '.'"), backtrace => Backtrace.new)␤»

[17:15] <sortiz> m: without "a".Numeric { say $_.handled };

[17:15] <camelia> rakudo-moar 959cd3: OUTPUT«True␤»

[17:15] <pmichaud> I think the correct answer is that Str.Int has to be smarter about returning Failure somehow.

[17:15] <pmichaud> self.Numeric.Int is going to cause an unwanted throw

[17:16] *** AlexDaniel joined
[17:17] *** rgrinberg left
[17:17] <pmichaud> IMBNI to have a method call syntax that propogates a Failure

[17:18] <pmichaud> i.e.,    $foo.?!method()    returns $foo unchanged if $foo is a Failure

[17:19] *** bpa left
[17:19] <BenGoldberg> Ooh, could that be written as ‽

[17:20] <pmichaud> I'd be fine with using the interrobang for that, yes.  

[17:21] * BenGoldberg notes that one can usefully google search for ‽, but searching for ?! does not produce anything useful.

[17:22] <pmichaud> anyway, perhaps bring that suggestion up with TimToady, unless someone already knows of a convenient "propagate Failure" syntax.

[17:25] <pmichaud> and I think it perhaps has to be Failure/Exception specific, a simple definedness check might not be good enough (since testing a Failure for definedness marks it as handled, and we don't want that here.)

[17:25] *** jack_rabbit left
[17:25] <pmichaud> definitely   "a".Int ~~ Failure   is worth a rakudobug or specbug  issue (or both)

[17:26] <pmichaud> gotta go -- bbl

[17:26] <sortiz> Thanks pmichaud 

[17:48] <llfourn> m: my %h = %( foo => "bar"); my (:$foo) := %h; say $foo

[17:48] <camelia> rakudo-moar 959cd3: OUTPUT«bar␤»

[17:48] <llfourn> m: my %h = Hash.new( foo => "bar"); my (:$foo) := %h; say $foo

[17:48] <camelia> rakudo-moar 959cd3: OUTPUT«(Mu)␤»

[17:48] <llfourn> shouldn't those both work?

[17:50] <llfourn> oh right Hash.new needs a list nvm =(

[17:50] <llfourn> m: my %h = Hash.new( "foo","bar"); my (:$foo) := %h; say $foo

[17:50] <camelia> rakudo-moar 959cd3: OUTPUT«bar␤»

[17:55] <pmichaud> m:   say ("3".Numeric andthen .Int)

[17:55] <camelia> rakudo-moar 959cd3: OUTPUT«3␤»

[17:55] <pmichaud> m:   say ("3".Numeric andthen .Int).WHAT

[17:55] <camelia> rakudo-moar 959cd3: OUTPUT«(Int)␤»

[17:55] <pmichaud> m:   say ("a".Numeric andthen .Int).WHAT

[17:55] <camelia> rakudo-moar 959cd3: OUTPUT«(Slip)␤»

[17:56] <pmichaud> m:   say ("a".Numeric).WHAT

[17:56] <camelia> rakudo-moar 959cd3: OUTPUT«(Failure)␤»

[17:56] <pmichaud> m:   say (Int andthen 3).WHAT

[17:56] <camelia> rakudo-moar 959cd3: OUTPUT«(Slip)␤»

[17:56] <pmichaud> that's a rakudobug.

[17:57] <psch> m: say ((Nil andthen 2) orelse "foo") 

[17:57] <camelia> rakudo-moar 959cd3: OUTPUT«-> ;; $_ is raw { #`(Block|80393968) ... }␤»

[17:57] <psch> ...i *might* just be doing something really weird, though 

[17:57] <timotimo> that's ... interesting?

[17:58] *** AlexDaniel left
[17:58] * pmichaud files rakudobug.

[17:58] <psch> i don't have an intuition for andthen and orelse, but it might kinda follow natrually from what pmichaud++ showed

[17:58] <psch> as in, from the bug there

[17:58] <llfourn> where is the bug?

[17:58] <pmichaud> Anyway,  for Str.Int one could write      Str.Numeric andthen .Int     except for the fact that "andthen" likely marks the Failure as being handled.

[17:58] <pmichaud> andthen returns the first undefined argument

[17:59] *** rurban_ joined
[17:59] <llfourn> oh ok

[17:59] * pmichaud files rakudobug.

[18:00] <pmichaud> m:  say (Int andthen 3)

[18:00] <camelia> rakudo-moar 959cd3: OUTPUT«()␤»

[18:00] <pmichaud> m:  say (Int andthen3).WHAT

[18:00] <camelia> rakudo-moar 959cd3: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say (Int7⏏5 andthen3).WHAT␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        stat…»

[18:00] <pmichaud> m:  say (Int andthen 3).WHAT

[18:00] <camelia> rakudo-moar 959cd3: OUTPUT«(Slip)␤»

[18:02] <pmichaud> say Int

[18:02] <pmichaud> m: say Int

[18:02] <camelia> rakudo-moar 959cd3: OUTPUT«(Int)␤»

[18:02] <llfourn> according to design docs: If you wish to have the same semantics in the opposite order, use the with statement modifier.

[18:02] <llfourn> but Slip is the right answer for with

[18:02] <pmichaud> I want this ordering of semantics for this case.

[18:03] <llfourn> so it seems that they designers were somewhat confused on this point

[18:03] <llfourn> m: say ( "foo" with Int ).WHAT

[18:03] <camelia> rakudo-moar 959cd3: OUTPUT«(Slip)␤»

[18:03] <pmichaud> No, I don't think they're confused.

[18:03] <pmichaud> I just think "andthen" has a rakudobug.

[18:04] <llfourn> m:  say (Int andthen 3).WHAT

[18:04] <camelia> rakudo-moar 959cd3: OUTPUT«(Slip)␤»

[18:04] * timotimo remembers mucking around with andthen and orelse because of the feature matrix saying they had something missing

[18:04] *** rurban_ left
[18:04] <llfourn> but you think that is te wrong answer right?

[18:04] <pmichaud> According to S03, that's the wrong answer, yes.

[18:04] <llfourn> it's the right answer if andthen is a backwards with though

[18:05] <pmichaud> Okay, so S03 is self-contradictory on that point.

[18:05] <llfourn> yes :)

[18:05] <psch> m: say (Int andthen 3).perl

[18:05] <camelia> rakudo-moar 959cd3: OUTPUT«slip()␤»

[18:05] <psch> that is all kinds of wrong

[18:05] <pmichaud> The whole point of "andthen" was to have a way to return the first undefined value

[18:05] <psch> m: say (1 andthen 3).perl

[18:05] <camelia> rakudo-moar 959cd3: OUTPUT«3␤»

[18:05] <pmichaud> so you can say    foo() andthen .dothis andthen .dothat andthen .doother

[18:06] <llfourn> no argument here that makes sense

[18:06] <pmichaud> and have it do all of the method calls as long as the results are defined, but short-circuit if anything in the chain returned an undefined result

[18:06] <pmichaud> it's not exactly the same purpose/semantic as "with"

[18:07] * pmichaud files specbug

[18:07] <llfourn> pmichaud++

[18:08] <llfourn> m: say ("foo" andthen .uc) # does it set $_...

[18:08] <camelia> rakudo-moar 959cd3: OUTPUT«FOO␤»

[18:08] <llfourn> hmm that's handy

[18:12] <psch> oh hm

[18:12] <pmichaud> right

[18:13] <psch> doesn't that mean that (Nil andthen ...) *should* return an empty Slip?

[18:13] <psch> or should it return Nil, or Empty..?

[18:13] <pmichaud> I'd think it should return Nil

[18:13] <pmichaud> m:  say Nil.defined

[18:13] <camelia> rakudo-moar 959cd3: OUTPUT«False␤»

[18:13] <pmichaud> andthen returns its first undefined argument.

[18:13] <psch> m: class A { method defined { False } }; say (A andthen "foo")

[18:13] <camelia> rakudo-moar 959cd3: OUTPUT«()␤»

[18:14] <pmichaud> m: class A { method defined { True } };  say (A andthen "foo")

[18:14] <camelia> rakudo-moar 959cd3: OUTPUT«foo␤»

[18:14] *** canopus left
[18:16] *** sena_kun left
[18:16] <pmichaud> also, I'd be really happy / fine if  "andthen" changed its semantics to test for Failure/Exception rather than simple definedness

[18:17] <pmichaud> and have a different operator that does a definedness check-and-return-lhs-if-undef

[18:17] <moritz> !//

[18:17] <pmichaud> I thought about !//, yes  :)

[18:18] <llfourn> is there a Bool version of andthen (like && but sets $_)?

[18:18] <psch> i really liked discovering [R//]= due to damians talk that complained about exactly that missing

[18:18] <moritz> fwiw "andthen" is in light use in the ecosystem

[18:18] <pmichaud> llfourn:    if $val -> { ... }

[18:18] <psch> like, assign iff the rhs is defined

[18:18] <pmichaud> moritz: yes, but I'm finding places where it ought to be heavily used in core

[18:19] <pmichaud> and I suspect the ecosystem should be using it as well if we want robust failure handling.

[18:19] <moritz> in Native::LibC and DBIish for environment variables, where checking for Failuer wouldn't make a difference

[18:19] <moritz> and in Net::HTTP several times

[18:19] <moritz> and once in ArrayHash

[18:20] <pmichaud> I was also thinking we could have funny ternaries:    $val ?//?  "defined"  !! "not defined"

[18:20] <psch> having that easily available probably depends on un-special casing ?? !!

[18:20] <pmichaud> oh, I wasn't thinking it'd be meta

[18:21] <pmichaud> just one or two more special cases

[18:21] *** canopus joined
[18:21] <pmichaud> it could just be  ?//  though.

[18:21] <pmichaud> This way lies madness.

[18:21] <psch> right, i'm just saying that stuffing more special cases in the grammar - especially considering there will be users that want to implement variations themselves - would probably be a bad idea

[18:21] <pmichaud> well, macros may be the answer.

[18:22] <psch> and having ternary as another categorical can only be better than not having them

[18:22] <pmichaud> I'm not sure the parser would cope well with that.

[18:22] <psch> i have been told it's a mid- to long-term goal, but i haven't looked at it at all

[18:23] <pmichaud> interestingly:

[18:24] <pmichaud> perhaps could meta infix ops with a ->  to mean "topicalize"

[18:24] <pmichaud> $val &&-> .foo

[18:24] <pmichaud> returns $val if false, otherwise invokes .foo on $val

[18:25] <pmichaud> er, backwards

[18:25] <pmichaud> no, I had that right

[18:25] <pmichaud> $val ||-> .foo    returns $val if true, otherwise invokes .foo on $val

[18:26] <psch> $x +-> .++ # i think composability has to be limited somewhat there

[18:26] <psch> or it just gets really weird eventually

[18:26] <psch> probably iffy, if i categorize the examples correctly

[18:26] <pmichaud> yeah, perhaps it only works on "iffy" things

[18:28] *** jack_rabbit joined
[18:30] <pmichaud> anyway, I'm afk again.  Need lunch, then meetings.

[18:30] *** eugen joined
[18:30] <llfourn> 5 _+_ .sqrt, $var _&&_ .foo # put _ around an infix to set $_ for the RHS #justathought

[18:30] <psch> i like the pointy more there, fwiw

[18:30] <psch> maybe as prefix-meta rather than as postfix meta though

[18:31] <timotimo> have it be -- -> meta-circumfix

[18:32] <pmichaud> if the number of affected operators is limited, it doesn't need to be meta I guess.

[18:32] <pmichaud> afk for real

[18:33] <pmichaud> er, back again with one last thought

[18:34] <pmichaud> for Failures, could have a "passthen" infix (name can be bikeshed)

[18:34] <timotimo> bikeshod?

[18:34] <pmichaud> so Str.Int can be written with     self.Numeric passthen .Int

[18:34] <pmichaud> which returns the Failure object unchanged if self.Numeric fails, but applies .Int to any non-Failure

[18:35] <pmichaud> or, to be really weird,  use "then" as the generic topicalizer

[18:36] <pmichaud> $foo andthen .Int    # call .Int on $foo if true

[18:36] <pmichaud> $foo orthen .Int   # call .Int on $foo if False

[18:36] <pmichaud> $foo defthen .Int  # call .Int on $foo if defined

[18:36] <timotimo> so defthen is Rwith?

[18:37] <pmichaud> *no*

[18:37] <psch> m: "foo" Rwith .say

[18:37] <camelia> rakudo-moar 959cd3: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3"foo" Rwith 7⏏5.say␤»

[18:37] <pmichaud> because with returns a Slip if false

[18:37] <psch> also, that doesn't even

[18:37] <timotimo> oh

[18:37] <pmichaud> the whole point of these is that they short circuit, not that they return Sips

[18:37] <pmichaud> *Slips

[18:37] <timotimo> OK

[18:37] <timotimo> that makes sense

[18:37] *** PerlJam joined
[18:37] <pmichaud> $a && $b   returns $a if false

[18:38] <pmichaud> whereas    $b if $a   returns Slip if false

[18:39] <pmichaud> the andthen/orthen/defthen  forms would also topicalize (which is why they're huffmanized to be a little larger than their counterparts)

[18:39] <dalek> ecosystem: 77d2991 | ugexe++ | META.list:

[18:39] <dalek> ecosystem: Add CompUnit::Repository::Tar

[18:39] <dalek> ecosystem: 

[18:39] <dalek> ecosystem: https://github.com/ugexe/Perl6-CompUnit--Repository--Tar

[18:39] <dalek> ecosystem: 

[18:39] <dalek> ecosystem: Load modules directly from a .tar.gz archive

[18:39] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/77d2991c3f

[18:40] *** domidumont left
[18:40] <pmichaud> $a andthen $b   returns $a if undef;      $b with $a   returns Slip with undef

[18:41] <sortiz> m: my $h = (with 'a'.Numeric { .Int } else { Failure.new($_.exception) }); .say for $h.WHAT, $h.handled; # This seems to work :)

[18:41] <camelia> rakudo-moar 959cd3: OUTPUT«(Failure)␤False␤»

[18:41] <pmichaud> *Slip if undef

[18:41] <pmichaud> sortiz: yes, but if I have to write that for my failure handling code then I'm not going to bother.

[18:41] <pmichaud> and writing code to handle failures should be easy.

[18:42] <sortiz> Sure, but I want to start fixing some cases...

[18:42] <pmichaud> and it should be fast, if it's going to be done in CORE

[18:42] <pmichaud> shorter might be      given self.Numeric { when Failure { $_ }; .Int }

[18:42] *** CIAvash left
[18:43] <sortiz> Yep.

[18:43] <pmichaud> m: say (given 'a'.Numeric { when Failure { $_ }; .Int).WHAT

[18:43] <camelia> rakudo-moar 959cd3: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3 'a'.Numeric { when Failure { $_ }; .Int7⏏5).WHAT␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loop␤»

[18:43] <llfourn> wouldn't it make more sense if andthen checked for bool like with does?

[18:43] <pmichaud> m: say (given 'a'.Numeric { when Failure { $_ }; .Int}).WHAT

[18:43] <camelia> rakudo-moar 959cd3: OUTPUT«(Failure)␤»

[18:43] <pmichaud> m: say (given 'a'.Numeric { when Failure { $_ }; .Int}).handled

[18:43] <camelia> rakudo-moar 959cd3: OUTPUT«False␤»

[18:43] <pmichaud> yeah, the given version is shorter.

[18:43] <pmichaud> llfourn: "with" doesn't check for bool.

[18:44] <pmichaud> llfourn: "if" checks for bool.

[18:44] *** andrzejku joined
[18:44] <llfourn> pmichaud: err right I meant like "and" does

[18:44] * llfourn wonders about his brain

[18:44] <pmichaud> llfourn: yes, I think that "andthen" would make more sense as a topicalizing form of "and"

[18:44] <pmichaud> and that testing for definedness would be "defthen"

[18:45] <pmichaud> but that boat might've sailed on us already :(

[18:45] <pmichaud> so perhaps something other than "then"

[18:45] <llfourn> I hope the captain forgot something and has to come back quickly

[18:45] <psch> defthen gives me a pythonic vibe

[18:45] <psch> that's not necessarily bad though i suppose vOv

[18:45] <llfourn> I like andthen and defthen etc

[18:46] <pmichaud> llfourn: me too.  See if TimToady++ likes it.  :)

[18:46] <psch> i like the concept of a iffy-applicable postfix meta topicalizer

[18:46] <psch> not sure if that has to be 'then'

[18:47] <pmichaud> psch: I'm fine if it's a prefix or circumfix meta topicalizer... I'm just not sure "meta" is the way to go.

[18:47] <psch> but i think the *then variants are intended as plain infixes

[18:47] <psch> which is probably fine too

[18:47] <pmichaud> yes, it feels infixy to me

[18:47] <pmichaud> the main thing I'm looking for are the  failthen  and   passthen    variants :)

[18:48] <psch> well, if users can't mark ops as iffy my only argument against making them plain infixes is moot anyway

[18:48] <psch> and i'm not sure users can, fwiw

[18:48] <pmichaud> could just shorten to "th", except that probably puns badly with the ":nth" syntax.

[18:48] <psch> i think we do that deep in the grammar, so if anything slangs could

[18:49] <pmichaud> andth   orth   defth   failth   passth   undefth

[18:49] <pmichaud> heh

[18:49] <pmichaud> or "eth"

[18:50] <pmichaud> $foo andeth .bar

[18:50] <pmichaud> self.Numeric   passeth  .Int

[18:50] <pmichaud> ye olde topicalizing syntax

[18:50] <psch> that is strangely poetic

[18:51] <timotimo> stranglingly poetic

[18:53] <pmichaud> okay, I really really need lunch.  later

[18:56] *** mohae joined
[19:00] *** huggable left
[19:03] *** cdg left
[19:06] *** khw left
[19:09] *** canopus left
[19:15] *** canopus joined
[19:17] <gfldex> any ideas for an example to doc Any.duckmap?

[19:21] *** AndyBotwin joined
[19:23] <sortiz> timotimo, in the meantime a new nqp p6 op like nqp::failpass(foo,stmts) can be of help, no? 

[19:24] <timotimo> what do you imagine it to do?

[19:24] <timotimo> like defor?

[19:26] <sortiz> Simply optimized syntactic sugar of "given foo { Failure { $_ } stmts }"

[19:26] <timotimo> er

[19:27] *** andrzejku left
[19:27] *** canopus left
[19:29] <psch> m: say %(:1a, :2b).map: *.Str; say %(:1a, :2b).duckmap: *.Str 

[19:29] <camelia> rakudo-moar 959cd3: OUTPUT«(a   1 b     2)␤{a => 1, b => 2}␤»

[19:32] *** yqt joined
[19:32] <gfldex> m: say %(:1a, :2b).map: *.Str; say %(:1a, :2b).deepmap: *.Str

[19:32] <camelia> rakudo-moar 959cd3: OUTPUT«(a   1 b     2)␤{a => 1, b => 2}␤»

[19:33] <gfldex> an example that shows the difference between deepmap and duckmap would be more helpful

[19:34] *** labster joined
[19:35] *** canopus joined
[19:35] <psch> m: say %(%(:1a, :2b), :3c).deepmap: *.Str; say %($(:1a, :2b), :3c).duckmap: *.Str

[19:35] <camelia> rakudo-moar 959cd3: OUTPUT«{a => 1, b => 2, c => 3}␤{a  1 b     2 => c  3}␤»

[19:35] *** darutoko left
[19:35] <psch> not sure that's really helpful though

[19:35] <psch> but what i take from that is that .map goes all the way down, deepmap makes assumptions all the way through, and duckmap makes one assumption and then goes all the way through

[19:36] <sjn> \o

[19:36] <sortiz> In https://gist.github.com/salortiz/e5434418ff26774eeeb7ebac20da630d a simple fix for the discussed Str.Int issue, spectested. I'll create a PR after dinner.

[19:36] *** yqt left
[19:36] <psch> where "making assumption{,s}" here means "decide whether to treat a Pair as one item or two"

[19:38] *** andrzejku joined
[19:42] *** canopus left
[19:43] <wamba> m: dd [1,[2]].deepmap: {$_}; dd [1,[2]].duckmap: {$_}

[19:43] <camelia> rakudo-moar 959cd3: OUTPUT«[1, [2]]␤(1, $[2])␤»

[19:46] *** canopus joined
[19:51] <wamba> m: say  [1,[2]].deepmap({.Slip}); say [1,[2]].duckmap({.Slip})

[19:51] <camelia> rakudo-moar 959cd3: OUTPUT«[1 [2]]␤((1) (2))␤»

[19:51] *** kaare_ left
[19:51] *** trnh joined
[19:51] *** domidumont joined
[20:00] *** jjido joined
[20:01] *** BenGoldberg left
[20:04] <gfldex> m: my @a = [1,[2,3],4]; @a.duckmap({ $_ ~~ Int ?? $_++ !! Any }); @a[1]++;

[20:04] <camelia> rakudo-moar 959cd3: OUTPUT«Method 'succ' not found for invocant of class 'Array'␤  in block <unit> at <tmp> line 1␤␤»

[20:04] <gfldex> m: my @a = [1,[2,3],4]; dd @a.duckmap({ $_ ~~ Int ?? $_++ !! Any }); @a[1]++;

[20:04] <camelia> rakudo-moar 959cd3: OUTPUT«(1, (2, 3), 4)␤Method 'succ' not found for invocant of class 'Array'␤  in block <unit> at <tmp> line 1␤␤»

[20:05] <gfldex> m: my @a = [1,[2,3],4]; dd @a.duckmap({ $_ ~~ Int ?? $_++ !! Failure.new() }); @a[1]++;

[20:05] <camelia> rakudo-moar 959cd3: OUTPUT«(1, (2, 3), 4)␤Method 'succ' not found for invocant of class 'Array'␤  in block <unit> at <tmp> line 1␤␤»

[20:08] *** espadrine left
[20:27] *** raiph joined
[20:31] *** domidumont left
[20:33] *** FROGGS left
[20:42] *** TEttinger joined
[20:46] *** AlexDaniel joined
[20:47] *** cdg joined
[20:57] *** khw joined
[20:58] <raiph> pmichaud: Maybe:new "then" / "else" infixes that test .DEFINITE (don't handle Failures) and topicalize; "&&->" does same as "andthen", etc. for boolean ops; Promise.then fires when promise kept, .else when broken, and .chain or .ps or somesuch to chain regardless of kept/broken status?

[21:05] *** trnh left
[21:05] <dalek> doc: 590cf0d | (Wenzel P. P. Peppmeyer)++ | doc/Type/Num.pod6:

[21:05] <dalek> doc: doc sub srand

[21:05] <dalek> doc: review: https://github.com/perl6/doc/commit/590cf0db8d

[21:05] <dalek> doc: 64cfe4f | (Wenzel P. P. Peppmeyer)++ | doc/Type/Num.pod6:

[21:05] <dalek> doc: doc Num.rand

[21:05] <dalek> doc: review: https://github.com/perl6/doc/commit/64cfe4f7e1

[21:06] *** jjido left
[21:08] <AlexDaniel> meh, one more time my new account on github was automatically classified as spam or something

[21:09] <AlexDaniel> for those who don't know: in this case you have to use the contact form to tell them that you are actually a human

[21:09] <AlexDaniel> and they will reply to you… several days later

[21:10] *** eugen left
[21:11] <AlexDaniel> for those curious, the message looks like this: https://files.progarm.org/2016-07-10-001100_1035x151_scrot.png

[21:12] <dalek> doc: 62486f3 | (Wenzel P. P. Peppmeyer)++ | doc/Type/Any.pod6:

[21:12] <dalek> doc: doc Any.duckmap

[21:12] <dalek> doc: review: https://github.com/perl6/doc/commit/62486f30db

[21:12] <AlexDaniel> oh wow

[21:12] <AlexDaniel> gfldex++

[21:13] *** mr-fooba_ left
[21:14] <AlexDaniel> gfldex: oops, there's a typo: “inplementing”

[21:15] *** mr-foobar joined
[21:15] <gfldex> strangly `make test` did not spot that

[21:15] <dalek> doc: 64f2330 | (Wenzel P. P. Peppmeyer)++ | doc/Type/Any.pod6:

[21:15] <dalek> doc: fix typo

[21:15] <dalek> doc: review: https://github.com/perl6/doc/commit/64f2330804

[21:15] *** zakharyas joined
[21:16] *** rindolf left
[21:17] <AlexDaniel> gfldex: we have no spell checking yet

[21:20] *** zacts joined
[21:22] *** mohae left
[21:27] <raiph> .tell pmichaud Maybe ".todo" (instead of .chain or .ps from earlier message ^^) to replace current ".then"?

[21:27] <yoleaux> raiph: I'll pass your message to pmichaud.

[21:28] *** mohae joined
[21:39] <ilmari> m: ｢5̧｣ ~~ /^\d+$/

[21:39] <camelia> rakudo-moar a88508: ( no output )

[21:39] <ilmari> m: say ｢5̧｣ ~~ /^\d+$/

[21:39] <camelia> rakudo-moar a88508: OUTPUT«｢5̧｣␤»

[21:39] <ilmari> m: say ｢5̧｣.Int

[21:39] <camelia> rakudo-moar a88508: OUTPUT«0␤»

[21:40] <ilmari> m: say ｢5̧｣.chars

[21:40] <camelia> rakudo-moar a88508: OUTPUT«1␤»

[21:41] *** mra90 joined
[21:41] <ilmari> m: say "⁵" ~~ /^\d+$/; say "⁵".Int

[21:41] <camelia> rakudo-moar a88508: OUTPUT«Nil␤Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5⁵' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[21:42] <mra90> p6: say 3;

[21:42] <camelia> rakudo-moar a88508: OUTPUT«3␤»

[21:44] <awwaiid>  

[21:44] *** mra90 left
[21:45] <gfldex> m: say so Int =:= Int.WHAT;

[21:45] <camelia> rakudo-moar a88508: OUTPUT«True␤»

[21:45] <gfldex> m: say so Int === Int.WHAT;

[21:45] <camelia> rakudo-moar a88508: OUTPUT«True␤»

[21:45] *** TimToady joined
[21:47] <gfldex> m: my Int $i; say so $i === $i.WHAT;

[21:47] <camelia> rakudo-moar a88508: OUTPUT«True␤»

[21:47] <gfldex> m: my Int $i; say so $i =:= $i.WHAT;

[21:47] <camelia> rakudo-moar a88508: OUTPUT«False␤»

[21:48] *** trnh joined
[21:48] *** trnh left
[21:48] *** trnh joined
[21:50] *** rgrinberg joined
[21:55] *** zacts left
[22:02] *** trnh left
[22:05] *** djbkd joined
[22:11] *** hankache joined
[22:12] <hankache> Inbox?

[22:12] <yoleaux> 15:29Z <gfldex> hankache: please update your Pod::To::HTML and follow https://github.com/perl6/Pod-To-HTML/blob/master/examples/01-parse-files.p6

[22:14] <hankache> .tell gfldex thanks mate! Removing the old render candidate caused perl6 --doc=HTML to fail. I sent a PR to correct it in addition to misc. changes

[22:14] <yoleaux> hankache: I'll pass your message to gfldex.

[22:17] *** wamba left
[22:17] *** andrzejku left
[22:23] *** cognominal left
[22:36] *** cognominal joined
[22:37] *** firstdayonthejob left
[22:45] <gfldex> .

[22:45] <yoleaux> 22:14Z <hankache> gfldex: thanks mate! Removing the old render candidate caused perl6 --doc=HTML to fail. I sent a PR to correct it in addition to misc. changes

[22:45] <dalek> doc: 1b96a0d | (Wenzel P. P. Peppmeyer)++ | template/header.html:

[22:45] <dalek> doc: use tooltip to tell how to focus #query

[22:45] <dalek> doc: review: https://github.com/perl6/doc/commit/1b96a0d97d

[22:47] *** zakharyas left
[22:56] <AlexDaniel> Esc works :O

[22:56] *** RabidGravy left
[22:56] <gfldex> shift-alt-f works too, if you use firefox

[22:58] <AlexDaniel> well, I know that, because I added it, but Esc! :O

[23:00] *** huggable joined
[23:03] *** raiph left
[23:15] *** hankache left
[23:16] *** mr-foobar left
[23:18] *** mr-foobar joined
[23:23] *** cdg left
[23:29] *** mr-foobar left
[23:31] *** mr-foobar joined
[23:33] *** setty1 left
[23:40] *** killbill joined
[23:44] <dalek> bisectbot: cf9049a | (Aleks-Daniel Jakimenko-Aleksejev)++ | committable.pl:

[23:44] <dalek> bisectbot: Relax input restriction

[23:44] <dalek> bisectbot: 

[23:44] <dalek> bisectbot: Very often it is useful to use tags like “2015.10”. Previous regex did

[23:44] <dalek> bisectbot: not account for that, even though it is already supported.

[23:44] <dalek> bisectbot: review: https://github.com/perl6/bisectbot/commit/cf9049ae25

[23:44] <dalek> bisectbot: 46f3639 | (Aleks-Daniel Jakimenko-Aleksejev)++ | committable.pl:

[23:44] <dalek> bisectbot: Replace newlines with “␤”

[23:44] <dalek> bisectbot: review: https://github.com/perl6/bisectbot/commit/46f36392d3

[23:47] <dalek> bisectbot: f4ed1c8 | (Aleks-Daniel Jakimenko-Aleksejev)++ | b (2 files):

[23:47] <dalek> bisectbot: Rename bot.pl → bisectable.pl

[23:47] <dalek> bisectbot: 

[23:47] <dalek> bisectbot: Given that we now have several bots in one repository, “bot.pl” is no longer a

[23:47] <dalek> bisectbot: meaningful name.

[23:47] <dalek> bisectbot: review: https://github.com/perl6/bisectbot/commit/f4ed1c822e

[23:48] *** zacts joined
[23:50] *** girafe left
[23:50] <killbill>  my \Ar = '1s²2s²2p⁶3s²3p⁶';  # I need SUM of superscript digits ( electrons ).  Do we have <:superscript> unicode-property?

[23:51] *** grondilu left
[23:53] *** mr-foobar left
[23:54] <AlexDaniel> <[¹²³⁴⁵⁶⁷⁸⁹⁰]> ? :)

[23:55] <AlexDaniel> m: ‘1s²2s²2p⁶3s²3p⁶’.comb(/<[¹²³⁴⁵⁶⁷⁸⁹⁰]>/)».unival.sum.say

[23:55] <camelia> rakudo-moar 405519: OUTPUT«18␤»

[23:58] *** mr-foobar joined
[23:58] <killbill> AlexDaniel: yes, it is not uniproperty but it works :)

