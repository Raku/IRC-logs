[00:00] *** BrassLantern joined
[00:01] *** dainis joined
[00:02] <P6fr> m: say Q§5+9+6+3+5+1+4+7§.split("+")

[00:02] <camelia> rakudo-moar a37cd2: OUTPUT«(5 9 6 3 5 1 4 7)␤»

[00:03] <P6fr> m: say :a[5+9+6+3+5+1+4+7].split("+")

[00:03] <camelia> rakudo-moar a37cd2: OUTPUT«Use of uninitialized value of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in block <unit> at <tmp> line 1␤Cannot resolve caller split(Pair, Str); none of these signatures match:␤  in blo…»

[00:04] <P6fr> ok variable

[00:04] <skids> say (:a[5+9+6+3+5+1+4+7]).perl

[00:04] <skids> m: say (:a[5+9+6+3+5+1+4+7]).perl

[00:04] <camelia> rakudo-moar a37cd2: OUTPUT«:a([40])␤»

[00:05] *** dainis left
[00:06] <P6fr> m: my @a =[5+9+6+3+5+1+4+7];say :a@a.split("+");

[00:06] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3my @a =[5+9+6+3+5+1+4+7];say :a7⏏5@a.split("+");␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤ …»

[00:07] <skids> What are you trying to do?

[00:07] *** BrassLantern left
[00:07] <parabolize> P6fr: split and trans work on strings not arrays or lists

[00:09] *** BrassLantern joined
[00:09] *** BrassLantern left
[00:09] *** BrassLantern joined
[00:18] *** cpage_ joined
[00:19] *** cpage_ left
[00:21] *** cpage_ joined
[00:21] <P6fr> "5+9+6+3+5+1+4+7".trans("+" =>" ")

[00:21] <P6fr> m: "5+9+6+3+5+1+4+7".trans("+" =>" ")

[00:21] <camelia> rakudo-moar a37cd2: ( no output )

[00:21] *** dainis joined
[00:21] <P6fr> m: say "5+9+6+3+5+1+4+7".trans("+" =>" ")

[00:21] <camelia> rakudo-moar a37cd2: OUTPUT«5 9 6 3 5 1 4 7␤»

[00:22] <P6fr> m: say [+] "5+9+6+3+5+1+4+7".trans("+" =>" ")

[00:22] <camelia> rakudo-moar a37cd2: OUTPUT«Cannot convert string to number: trailing characters after number in '035⏏5 9 6 3 5 1 4 7' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[00:22] <P6fr> lol

[00:23] <AlexDaniel> P6fr: so, what are you trying to do?

[00:24] <parabolize> m: say [+] [5, 9, 6, 3, 5, 1, 4, 7]

[00:24] <camelia> rakudo-moar a37cd2: OUTPUT«40␤»

[00:24] <P6fr> i rien de particulier je fais quelque test pour bien comprendre le fonctionnement du langage, regarder quels sont les routines, methods a utilisé.

[00:24] <P6fr> nothing special I do some testing to understand the functioning of language, look at what are the routines, methods used.

[00:24] <P6fr> yes parabolize numeric

[00:25] *** dainis left
[00:36] <P6fr> m: say so 1 S& 2 S& 4;

[00:36] <camelia> rakudo-moar a37cd2: OUTPUT«True␤»

[00:36] <P6fr> m: say so 1 S& 2 S& 3;

[00:36] <camelia> rakudo-moar a37cd2: OUTPUT«True␤»

[00:36] <P6fr> m: say so 1 S& 2 S& 1;

[00:36] <camelia> rakudo-moar a37cd2: OUTPUT«True␤»

[00:46] <P6fr> m: substr('abc': 1).say

[00:46] <camelia> rakudo-moar a37cd2: OUTPUT«bc␤»

[00:52] <P6fr> m:my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet:delete

[00:52] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet:delete

[00:52] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '%alphabet:delete' is not declared␤at <tmp>:1␤------> 3my %alphabet = 'A'..'Z' Z=> 1..26;say 7⏏5%alphabet:delete␤»

[00:52] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet[]:delete

[00:52] <camelia> rakudo-moar a37cd2: OUTPUT«Can not remove elements from a Hash␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[00:53] <skids> m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet{}:delete

[00:53] <camelia> rakudo-moar a37cd2: OUTPUT«(26 22 24 6 2 1 23 11 9 25 21 8 20 19 14 12 7 5 4 17 16 15 13 3 18 10)␤»

[00:53] <P6fr> ha oui c'est vrai

[00:53] <P6fr> thx

[00:54] <P6fr> {} array ok

[00:56] <P6fr> my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet{}:delete;say now - INIT now; 

[00:56] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet{}:delete;say now - INIT now; 

[00:56] <camelia> rakudo-moar a37cd2: OUTPUT«(26 22 24 6 2 1 23 11 9 25 21 8 20 19 14 12 7 5 4 17 16 15 13 3 18 10)␤0.0076812␤»

[00:59] *** leokitten joined
[00:59] <leokitten> Hi to all

[00:59] <skids> o/

[01:00] <gfldex> m: say 'ohai leokitten!'

[01:00] <camelia> rakudo-moar a37cd2: OUTPUT«ohai leokitten!␤»

[01:00] <gfldex> i'm tempted to walk over the whole docs and change any say to a dd that isn't actually meant to do what say does.

[01:01] <leokitten> I mentioned the other night that when you search on Google the term "rakudo" the first search result is from rakudo.org and the result snippet is out of date 

[01:01] <leokitten> It reads "An implementation of the Perl 6 specification that runs on the Parrot virtual machine."

[01:01] <gfldex> leokitten: your first hit may not be my first hit

[01:02] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26; say %alphabet{}.trans("A".."Z" =>"");say now - INIT now; 

[01:02] <camelia> rakudo-moar a37cd2: OUTPUT«     1␤      2␤      3␤      4␤      5␤      6␤      7␤      8␤      9␤      10␤     11␤     12␤     13␤     14␤     15␤     16␤     17␤     18␤     19␤     20␤     21␤     22␤     23␤     24␤     25␤     26␤0.00914672␤»

[01:02] <leokitten> I think they said pmichaud is the site owner 

[01:02] <gfldex> also, we have very little influence about the summary on google.*

[01:03] <leokitten> Oh I thought you can control what the Google result snippet shows with <meta> tags 

[01:03] <leokitten> And other ways 

[01:03] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26; say trans(%alphabet.keys =>"");say now - INIT now; 

[01:03] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    trans used at line 1. Did you mean 'rand', 'tanh', 'srand'?␤␤»

[01:03] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26; say trans(%alphabet{}.keys =>"");say now - INIT now; 

[01:03] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    trans used at line 1. Did you mean 'rand', 'tanh', 'srand'?␤␤»

[01:04] <gfldex> leokitten: you can ask it to re-crawl the site what it may or not may do

[01:05] <leokitten> Well hope it could be update to say more like "An implementation of Perl 6 on MoarVM and JVM..." Parrot is bye bye 

[01:05] <P6fr>  JVM ? bad idea. JVM is better on the langage compilated

[01:05] <P6fr> no script

[01:06] <leokitten> gfldex can you reproduce what I see? Please type "rakudo" into google

[01:06] <skids> leokitten: yes that's what google has cached as a summary

[01:07] *** leokitten left
[01:07] <gfldex> leokitten: i can

[01:07] *** leokitten_ joined
[01:11] <leokitten_> pmichaud++ please if you can update the Google result snippet here is their page on how to change it https://developers.google.com/custom-search/docs/snippets

[01:12] <skids> leokitten: use .tell to leave a message for later

[01:12] <leokitten_> How do i? Like pmichaud.tell ?

[01:12] <AlexDaniel> P6fr: actualy, it works very well

[01:12] <AlexDaniel> l*

[01:12] <skids> ".tell pmichaud"

[01:12] *** dvinciguerra_ joined
[01:13] <leokitten_> .tell pmichaud please if you can update the Google result snippet here is their page on how to change it https://developers.google.com/custom-search/docs/snippets

[01:13] <yoleaux> leokitten_: I'll pass your message to pmichaud.

[01:13] <leokitten_> Yoleaux++

[01:14] <P6fr> he downside of a jvm for scripting languages is that it will take more time to start. Good after in length is time is caught up with all the optimizations they can make

[01:15] <gfldex> P6fr: so does moarvm

[01:15] <leokitten_> Perl 6 is really awesome, gosh all the features I feel like I'm still just scratching the surface 

[01:15] <P6fr> I somewhat exaggerated by saying that it is a bad idea

[01:16] <P6fr> gfldex moarvm is make on perl6 

[01:17] *** leokitten_ left
[01:17] <P6fr> If I am not mistaken

[01:18] <gfldex> m: sub term:<♥>() { say 'I ♥ Perl6;' }; ♥;

[01:18] <camelia> rakudo-moar a37cd2: OUTPUT«I ♥ Perl6;␤»

[01:20] <skids> P6fr: moarvm is written in C mostly.

[01:20] <AlexDaniel> mostly?

[01:20] <P6fr> no perl mostly

[01:20] <AlexDaniel> what parts of moarvm are not in C?

[01:20] <P6fr> ha ?

[01:21] *** dainis joined
[01:21] <gfldex> there are some Perl 5 scripts that generate a bunch of stuff

[01:21] <P6fr> OK I confused with rakudo sorry

[01:21] <skids> I think there's some dsl and scripting to build the instruction tiler IIRC.

[01:21] <P6fr> in the memory

[01:21] <P6fr> my

[01:22] <skids> And maybe some asm.

[01:28] *** adu joined
[01:28] *** molaf joined
[01:31] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet{}

[01:31] <camelia> rakudo-moar a37cd2: OUTPUT«{A => 1, B => 2, C => 3, D => 4, E => 5, F => 6, G => 7, H => 8, I => 9, J => 10, K => 11, L => 12, M => 13, N => 14, O => 15, P => 16, Q => 17, R => 18, S => 19, T => 20, U => 21, V => 22, W => 23, X => 24, Y => 25, Z => 26}␤»

[01:31] *** Xliff joined
[01:31] <Xliff> \o

[01:31] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet{%keys}

[01:31] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '%keys' is not declared. Did you mean '&keys'?␤at <tmp>:1␤------> 3abet = 'A'..'Z' Z=> 1..26;say %alphabet{7⏏5%keys}␤»

[01:31] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet.values

[01:31] <camelia> rakudo-moar a37cd2: OUTPUT«(26 22 24 6 2 1 23 11 9 25 21 8 20 19 14 12 7 5 4 17 16 15 13 3 18 10)␤»

[01:32] <P6fr> hello Xliff 

[01:32] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet.values.sort

[01:32] <camelia> rakudo-moar a37cd2: OUTPUT«(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26)␤»

[01:32] <japhb> .sort.values works as well (.sort on a hash produces an ordered list of pairs)

[01:33] <japhb> I guess .sort>>.value

[01:34] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet.values.sort;say now - INIT now;m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet.sort.values;say now - INIT now;

[01:34] <camelia> rakudo-moar a37cd2: OUTPUT«Potential difficulties:␤    Redeclaration of symbol %alphabet␤    at <tmp>:1␤    ------> 3.sort;say now - INIT now;m: my %alphabet7⏏5 = 'A'..'Z' Z=> 1..26;say %alphabet.sort␤(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 2…»

[01:34] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;say %alphabet.values.sort;say now - INIT now;say %alphabet.sort.values;say now - INIT now;

[01:34] <camelia> rakudo-moar a37cd2: OUTPUT«(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26)␤0.0079270␤(A => 1 B => 2 C => 3 D => 4 E => 5 F => 6 G => 7 H => 8 I => 9 J => 10 K => 11 L => 12 M => 13 N => 14 O => 15 P => 16 Q => 17 R => 18 S => 19 T => 20 U => 21 V => 22 W =…»

[01:35] <P6fr> ok

[01:36] *** jack_rabbit joined
[01:37] *** dainis left
[01:42] <Xliff> m: my $a = Any; say $a.defined

[01:42] <camelia> rakudo-moar a37cd2: OUTPUT«False␤»

[01:43] <Xliff> m: my $a = Any; say $a ~~ Any; say 1 ~~ Any;

[01:43] <camelia> rakudo-moar a37cd2: OUTPUT«True␤True␤»

[01:43] <Xliff> Grrr....

[01:43] <BenGoldberg> Does anyone know if the ff operator could have been implemented as a macro?

[01:43] <Xliff> How can I test if a scalar holds the "Any" type?

[01:43] * BenGoldberg is aware that macros are experimental, but still...

[01:44] <P6fr> m: my $a = Any; say $a.WHAT

[01:44] <camelia> rakudo-moar a37cd2: OUTPUT«(Any)␤»

[01:44] <Xliff> Somehow my C lib is returning a value that gets thrown into a scalar as "Any" but it still passes a .defined check.

[01:44] <P6fr> POUR ONCE THAT IT IS ME WHO HELP ^^

[01:46] *** colomon joined
[01:46] <Xliff> LOL P6fr!

[01:46] <Xliff> Hey, it's a bit more high level than I want, but if it works... ;)

[01:46] <Xliff> Ohe thing though.

[01:47] <BenGoldberg> m: my $a; say so $a.WHAT;

[01:47] <camelia> rakudo-moar a37cd2: OUTPUT«False␤»

[01:47] <Xliff> m: my $a = 1; say $a.WHAT ~~ Any

[01:47] <camelia> rakudo-moar a37cd2: OUTPUT«True␤»

[01:47] <BenGoldberg> Note that $a.WHAT is returning an undefined value...

[01:50] <P6fr> you want which result ?

[01:51] *** adu left
[01:54] <P6fr> m: my $a = Any; say $a.does(Any)

[01:54] <camelia> rakudo-moar a37cd2: OUTPUT«True␤»

[01:54] <P6fr> Xliff  ?

[01:54] <P6fr> :D

[01:54] <skids> m: my Any:D $i = Nil; $i.WHAT.say; $i.DEFINITE.say; $i.defined.say;

[01:54] <camelia> rakudo-moar a37cd2: OUTPUT«(Any:D)␤False␤False␤»

[01:55] <skids> Hrm so it isn't that...

[01:57] <skids> m: my Any:D $a = Any.new; say $a.WHAT; say $a.defined

[01:57] <camelia> rakudo-moar a37cd2: OUTPUT«(Any)␤True␤»

[01:57] <skids> m: Any.new.perl.say

[01:57] <camelia> rakudo-moar a37cd2: OUTPUT«Any.new␤»

[01:57] <skids> :/

[01:57] *** colomon left
[01:57] <P6fr> m: my $var = 1;say $var.does(any)

[01:57] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Function "any" may not be called without arguments (please use () or whitespace to denote arguments, or &any to refer to the function as a noun)␤at <tmp>:1␤------> 3my $var = 1;say $var.does(any7⏏5)…»

[01:57] <P6fr> m: my $var = 1;say $var.does(Any)

[01:57] <camelia> rakudo-moar a37cd2: OUTPUT«True␤»

[01:58] <P6fr> ...

[01:58] <Xliff> OK. That's freaking weird.

[01:58] <skids> I suppose it should be fine to instantiate Any.  I guess... someone with more type calculus foo might chime in.

[01:58] <Xliff> I must be seeing things. I will circle back to the weirdness, tomorrow.

[01:58] * gfldex .oO( Nil statement considered harmful )

[01:58] <P6fr> m: my $var = 1;say $var.WHAT

[01:58] <camelia> rakudo-moar a37cd2: OUTPUT«(Int)␤»

[01:58] <Xliff> skids: I think there is a problem in rakudo

[01:59] <P6fr> int = Any ? 

[01:59] <Xliff> skids: If you have some spare cycles, could you check out my code and verify some behavior for me?

[01:59] <Xliff> If not, it can wait until a more reasonable hour.

[01:59] *** colomon joined
[01:59] <skids> Xliff: where at?

[02:01] <BenGoldberg> m: my $i = Any but Int { 42 }; say $i + 3;

[02:01] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Unexpected block in infix position (missing statement control word before the expression?)␤at <tmp>:1␤------> 3my $i = Any but Int7⏏5 { 42 }; say $i + 3;␤    expecting any of:␤        infix␤ …»

[02:02] <Xliff> skids: https://github.com/Xliff/p6-XML-LibXML.git

[02:02] <skids> m: Any.WHICH.say; Any.WHICH.say; Any.new.WHICH.say; Any.new.WHICH.say # OK, not a singleton.

[02:02] <camelia> rakudo-moar a37cd2: OUTPUT«Any␤Any␤Any|67319616␤Any|67319648␤»

[02:03] <Xliff> Once you clone, switch to the 07dtd branch.

[02:03] <P6fr> m: my $i = Any but Int 42 ; say $i + 3;

[02:03] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3my $i = Any but Int7⏏5 42 ; say $i + 3;␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        st…»

[02:03] <Xliff> skids: Then run "perl6 --stagestats -Ilib t/07dtd.t" -- test should complete.

[02:04] <P6fr> bon  moi je ne peut définitvement pas t’aider lol

[02:04] <P6fr> well me I cannot definitely help lol

[02:04] <P6fr> one day perahps

[02:04] <Xliff> skids: Then go into lib/XML/LibXML/Dtd.pm and look in the parse-string method. Check out the comments. Comment the line that starts with say "P:"

[02:05] <Xliff> Then rerun test and watch it fail one test that passed, earlier.

[02:05] *** bob777 joined
[02:05] <Xliff> Imma go get some water. 

[02:06] <BenGoldberg> m: my $i = Any but role { method Int { 42 } }; say $i + 3;

[02:06] <camelia> rakudo-moar a37cd2: OUTPUT«Use of uninitialized value of type Any+{<anon|56665968>} in numeric context  in block <unit> at <tmp> line 1␤3␤»

[02:06] <BenGoldberg> m: my $i = Any but role { method Int { 42 } }; say $i;

[02:06] <camelia> rakudo-moar a37cd2: OUTPUT«(Any+{<anon|73045840>})␤»

[02:06] <BenGoldberg> m: my $i = Any but role { method Int { 42 } }; $i.= new; say $i;

[02:06] <camelia> rakudo-moar a37cd2: OUTPUT«Any+{<anon|61339584>}.new␤»

[02:06] <BenGoldberg> m: my $i = Any but role { method Int { 42 } }; $i.= new; say $i + 3;

[02:06] <camelia> rakudo-moar a37cd2: OUTPUT«Cannot resolve caller Numeric(Any+{<anon|55289824>}: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[02:07] <BenGoldberg> m: my $i = Any but role Numeric { method Int { 42 } }; $i.= new; say $i + 3;

[02:07] <camelia> rakudo-moar a37cd2: OUTPUT«Cannot resolve caller Numeric(Any+{Numeric}: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[02:09] <skids> Xliff: The tests only run 38/57 in both cases.  I commented out an "R:" line there was no "P:"

[02:09] <Xliff> One sec.

[02:10] <Xliff> skids: Sorry. I gave you the wrong file....

[02:10] <Xliff> skids: Then go into lib/XML/LibXML/Parser.pm and look in the parse-string method. Check out the comments. Comment the line that starts with say "P:"

[02:10] <skids> What kind of monster have you created that takes 26 seconds to compile :-)

[02:10] <Xliff> LOL!

[02:10] <Xliff> I know, right?!?!

[02:11] *** AndyBotwin joined
[02:11] <Xliff> My guess it is all the stuff in CStructs.pm that's giving rakudo hives.

[02:11] <Xliff> Either that or just NativeCall issues in general... but.... donno...

[02:12] <skids> Yeah test 37 fails.

[02:12] <Xliff> skids: After a new rakudo build it takes over 50 seconds.

[02:12] <Xliff> skids: Soo... you see what's driving me O_o ?

[02:13] <skids> Well, the test is that an exception gets thrown so maybe that nativecast is throwing an exception?

[02:13] <Xliff> It should get caught at the fail.

[02:14] <skids> No if it throws it would only get caught by an actual catch.

[02:14] <Xliff> If you uncomment the A: line, you will see that the .defined test is False

[02:14] <Xliff> fail XML::LibXML::Error.get-last(self, :orig($str)) unless $ret.defined;

[02:15] <Xliff> ^^ That should fire.

[02:15] <Xliff> It doesn't.

[02:15] <Xliff> But if you leave the P: line it, it does.

[02:15] <Xliff> No way a "say" should affect the code like that.

[02:18] <skids>     { say "P: {+(nativecast(Pointer, $ret))}";

[02:18] <skids>       CATCH { $_.message.say } }

[02:18] <skids> Invocant requires an instance of type NativeCall::Types::Pointer, but a type object was passed.  Did you forget a .new?

[02:21] *** P6fr left
[02:21] <Xliff> Huh!

[02:22] <Xliff> Well that's embarrassing!

[02:22] *** Guest66 joined
[02:22] <Xliff> So the P: line throws an exception.

[02:22] <Xliff> That causes the test to pass. OK. 

[02:22] *** Guest66 is now known as P6fr

[02:23] *** colomon left
[02:23] <Xliff> But why doesn't the fail get thrown?!?

[02:23] <skids> Also in 07dtd.t, I think the Failure is protected from throwing by assigning to $doc.

[02:23] <Xliff> Seriously?

[02:23] <skids> Failures only throw when sunk.

[02:23] <skids> (Or other things, but basically interacted with)

[02:24] <skids> They are meant not to blow up unless it becomes obvious someone forgot to write error handling code.

[02:24] <Xliff> Should that be replaced with a die()?

[02:25] <Xliff> Or better question.... how can you check for a fail?

[02:25] <skids> It's a matter of taste.  Do you want users to have to use a CATCH if they want to handle the error, or not.

[02:25] <Xliff> What's the perl6 way to go?

[02:26] <skids> Unfortunately, recently Failures have gotten tricky to work with due to the "useless use of" compiler work.

[02:26] <Xliff> I have no problems with try/catch if the user wants error handling.

[02:26] <skids> It used to be if you just did $a = could_fail(); $a; # that would throw.

[02:27] * skids tries to remember what the best trick was.

[02:27] <Xliff> I just need something that will trigger the dies-ok() routine 

[02:28] <Xliff> But not be a complete pain in general use if someone does want to write error handling code for that situation.

[02:28] <Xliff> I need to talk to FROGGS about that.

[02:29] *** dvinciguerra_ left
[02:29] <skids> I'd go with a die or throw for now, Failure really needs work... for example there is no option to prevent an unhandled one from not spewing noise when it gets GCd

[02:31] <Xliff> Yeah. I just used a die and it workedf.

[02:31] <Xliff> So much for being fancy...

[02:31] <Xliff> Thanks, skids++!!

[02:31] <skids> np

[02:33] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;my %voyelle = ('A' => 1,'E' => 5,'I' => 9,'O' => 15,'U' => 21,'Y' => 25 );say "name".trans([%alphabet.keys] => [%alphabet.values]).trans([%alphabet.keys] => [%alphabet.values])'

[02:33] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3([%alphabet.keys] => [%alphabet.values])7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤     …»

[02:33] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;my %voyelle = ('A' => 1,'E' => 5,'I' => 9,'O' => 15,'U' => 21,'Y' => 25 );say "name".trans([%alphabet.keys] => [%alphabet.values])

[02:33] <camelia> rakudo-moar a37cd2: OUTPUT«name␤»

[02:34] <P6fr> hum..

[02:35] <P6fr> m: my %alphabet = 'A'..'Z' Z=> 1..26;my %voyelle = ('A' => 1,'E' => 5,'I' => 9,'O' => 15,'U' => 21,'Y' => 25 );say "NAME".trans([%alphabet.keys] => [%alphabet.values])

[02:35] <camelia> rakudo-moar a37cd2: OUTPUT«141135␤»

[02:35] <P6fr> haaaaaa

[02:36] <P6fr> In other languages, should have been automatically through a loop

[02:37] <P6fr> now, what is the best and fastest. method or loop?

[02:38] *** hwcomcn joined
[02:40] *** bob777 left
[02:41] *** labster left
[02:42] <gfldex> P6fr: at some point (when the optimiser is actually optimising stuff) .trans will be the fastest

[02:42] <P6fr> yeah

[02:43] <skids> m: my %alphabet = "A".."Z" Z=> ("z"..."a"); say %alphabet.perl; say "ABCDEFGHIJ".trans(%alphabet.pairs)

[02:43] <camelia> rakudo-moar a37cd2: OUTPUT«{:A("z"), :B("y"), :C("x"), :D("w"), :E("v"), :F("u"), :G("t"), :H("s"), :I("r"), :J("q"), :K("p"), :L("o"), :M("n"), :N("m"), :O("l"), :P("k"), :Q("j"), :R("i"), :S("h"), :T("g"), :U("f"), :V("e"), :W("d"), :X("c"), :Y("b"), :Z("a")}␤zyxwvutsrq␤»

[02:43] <P6fr> in some language, native functions/methods most commonly used are the most optimized. Perl will do the same thing?

[02:44] <skids> Maybe.  It depends how smart the automatic optimization gets.

[02:44] *** kid51 joined
[02:44] *** noganex joined
[02:44] <P6fr> ok

[02:45] <geekosaur> it tries to; optimization is an ongoing thing currently

[02:46] <P6fr> Yes I have seen ca on the site of moarvm

[02:46] *** hwcomcn left
[02:47] <P6fr> why .perl ??

[02:47] *** hwcomcn joined
[02:47] <P6fr> what is it

[02:47] *** hwcomcn left
[02:47] <skids> It usually produces perl6 code to replicate the object.

[02:48] *** hwcomcn joined
[02:48] <P6fr> hum

[02:48] <skids> Sometmes it also helps you tell the difference between different things that look the same under say/gist

[02:48] <skids> So it reveals more structure.

[02:49] <P6fr> m: my %alphabet = "A".."Z" Z=> ("z"..."a"); say %alphabet; say "ABCDEFGHIJ".trans(%alphabet.pairs)

[02:49] <camelia> rakudo-moar a37cd2: OUTPUT«{A => z, B => y, C => x, D => w, E => v, F => u, G => t, H => s, I => r, J => q, K => p, L => o, M => n, N => m, O => l, P => k, Q => j, R => i, S => h, T => g, U => f, V => e, W => d, X => c, Y => b, Z => a}␤zyxwvutsrq␤»

[02:49] <P6fr> haaaa the dump ?

[02:49] <P6fr> var_dump in php

[02:50] <skids> Mostly... there is also .dd

[02:50] <P6fr> m: my %alphabet = "A".."Z" Z=> ("z"..."a"); say %alphabet.dd; say "ABCDEFGHIJ".trans(%alphabet.pairs)

[02:50] <camelia> rakudo-moar a37cd2: OUTPUT«Method 'dd' not found for invocant of class 'Hash'␤  in block <unit> at <tmp> line 1␤␤»

[02:50] *** bob777 joined
[02:51] <skids> m: my @a := List.new(1); @a.perl.say; @a.say; # .perl tells you how to write a 1-element list literal.

[02:51] <camelia> rakudo-moar a37cd2: OUTPUT«(1,)␤(1)␤»

[02:51] <skids> Hrm I thought we had a dd.

[02:52] <geekosaur> it's a sub, not a method

[02:52] <P6fr> ok thx for the explain

[02:53] <skids> Ah.

[02:53] <geekosaur> m: my $x; dd $x

[02:53] <camelia> rakudo-moar a37cd2: OUTPUT«Any $x = Any␤»

[02:53] <P6fr> m: my %alphabet = "A".."Z" Z=> ("z"..."a"); say dd %alphabet.; say "ABCDEFGHIJ".trans(%alphabet.pairs)

[02:53] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Malformed postfix call␤at <tmp>:1␤------> 3.."Z" Z=> ("z"..."a"); say dd %alphabet.7⏏5; say "ABCDEFGHIJ".trans(%alphabet.pairs␤»

[02:53] <gfldex> m: my %alphabet = "A".."Z" Z=> ("z"..."a"); say %alphabet.&dd;

[02:53] <camelia> rakudo-moar a37cd2: OUTPUT«Hash %alphabet = {:A("z"), :B("y"), :C("x"), :D("w"), :E("v"), :F("u"), :G("t"), :H("s"), :I("r"), :J("q"), :K("p"), :L("o"), :M("n"), :N("m"), :O("l"), :P("k"), :Q("j"), :R("i"), :S("h"), :T("g"), :U("f"), :V("e"), :W("d"), :X("c"), :Y("b"), :Z("a")}␤Ni…»

[02:53] <gfldex> if you really want to you can call it like a method :)

[02:54] <P6fr> fine

[02:55] <P6fr> well, im bored. i 'll sleep

[02:55] <P6fr> It is what time in your home?

[02:58] *** cyphase joined
[03:00] <skids> 11pm here

[03:05] *** skrshn joined
[03:05] <skrshn> newbie question

[03:06] <skrshn> is this possible:

[03:07] <skrshn> while prompt("Enter number: ") -> $h { $h++; say $h; }

[03:07] <skrshn> basically, I want $h to be read/write

[03:08] <skids> m: for 1..2 -> $h is copy { $h++; say $h }

[03:08] <camelia> rakudo-moar a37cd2: OUTPUT«2␤3␤»

[03:08] *** wamba joined
[03:09] <skids> (There is "is rw" as well but in this case you only want it writeable internally)

[03:09] <skrshn> got it. Thanks

[03:09] <skrshn> "is rw" does not seem to work

[03:10] <gfldex> m: my @a = 1,2,3; for @a <-> $h { $h++ }; dd @a

[03:10] <camelia> rakudo-moar a37cd2: OUTPUT«Array @a = [2, 3, 4]␤»

[03:10] <gfldex> <-> is a shortcut for writeable containers

[03:11] <skids> "is rw" expects what you pass in to be a writeable container

[03:11] *** hwcomcn left
[03:11] <skids> m: my $a = 1; my $b = 2; for ($a,$b) -> $h is rw { $h++; say $h }; "$a $b".say

[03:11] <camelia> rakudo-moar a37cd2: OUTPUT«2␤3␤2 3␤»

[03:12] <skrshn> wonderful. thanks for the example with rw

[03:14] <dalek> doc: fc6c2d5 | (Wenzel P. P. Peppmeyer)++ | doc/Type/Block.pod6:

[03:14] <dalek> doc: add <-> to index

[03:14] <dalek> doc: review: https://github.com/perl6/doc/commit/fc6c2d5257

[03:16] *** hwcomcn joined
[03:17] *** canopus joined
[03:18] *** hwcomcn left
[03:19] *** hwcomcn joined
[03:24] *** hwcomcn left
[03:26] <skrshn> follow up question: when we do "is rw", is binding at work here? Is that why we need a container? 

[03:26] *** hwcomcn joined
[03:28] *** kid51 left
[03:28] *** hwcomcn left
[03:29] <skids> It's a form of binding, yes.

[03:29] <skids> IIRC the ::= form.

[03:29] *** hwcomcn joined
[03:29] <skrshn> ok. I need to look that one up. thanks.

[03:30] <skids> Oh I guess ::= is read-only binding.

[03:30] <skids> Which protects the first layer, I think.

[03:30] *** hwcomcn left
[03:31] <skids> So rw would be := binding

[03:31] *** hwcomcn joined
[03:32] <skrshn> thats the only one I am aware of.

[03:38] *** hwcomcn left
[03:39] *** hwcomcn joined
[03:40] *** hwcomcn left
[03:44] *** hwcomcn joined
[03:48] <skrshn> This works

[03:48] <skrshn> my %count; for "ofile.txt".IO.lines -> $line {    %count{$_}++ for $line.split(' '); } say "%count{}";

[03:48] <skrshn> But this does not work

[03:48] <skrshn> my %count; for "ofile.txt".IO.lines -> $line {    $line.split(' ').map(-> $w {%count{$w}++}); } say "%count{}";

[03:49] *** hwcomcn left
[03:50] *** P6fr left
[03:58] <skids> map is probably producing a lazy seq.

[03:59] <skrshn> but this is counter-intuitive (to a newbie)

[03:59] <skids> m: my %count; for $*IN.lines -> $line {    $line.split(' ').map(-> $w {%count{$w}++});  } say "%count{}";

[03:59] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3split(' ').map(-> $w {%count{$w}++});  }7⏏5 say "%count{}";␤»

[03:59] <skids> m: my %count; for $*IN.lines -> $line {    $line.split(' ').map(-> $w {%count{$w}++});  }; say "%count{}";

[03:59] <camelia> rakudo-moar a37cd2: OUTPUT«␤»

[04:00] <skids> m: my %count; for $*IN.lines -> $line {    $line.split(' ').map(-> $w {%count{$w}++}).elems;  }; say "%count{}";

[04:00] <camelia> rakudo-moar a37cd2: OUTPUT«     4␤'S    1␤'s    1␤Ach   1␤Ag    1␤Agus  1␤Atá   1␤B'é   1␤Chontae       1␤Céad  1␤Dhún  3␤Dobhair,      1␤Dobhair.      3␤Domhain       1␤Dún   1␤D’fhág        1␤Eireagal      1␤Gall, 1␤Ghall;        1␤Ghaoth        4␤Ghlas'        1␤Ghleann       1␤Ghleanntáin  

[04:00] <camelia> ..1␤Go    1␤I     1␤Is    1…»

[04:01] <skids> Yeah, general rule is that "for" is procedural paradigm, .map is functional paradigm.  Working in a multi-paradigm environment takes a little getting used to.

[04:01] *** samb1 joined
[04:01] <skids> m: my %count; for $*IN.lines -> $line {  sink $line.split(' ').map(-> $w {%count{$w}++})  }; say "%count{}"; # A little less circumlocuative

[04:01] <camelia> rakudo-moar a37cd2: OUTPUT«     4␤'S    1␤'s    1␤Ach   1␤Ag    1␤Agus  1␤Atá   1␤B'é   1␤Chontae       1␤Céad  1␤Dhún  3␤Dobhair,      1␤Dobhair.      3␤Domhain       1␤Dún   1␤D’fhág        1␤Eireagal      1␤Gall, 1␤Ghall;        1␤Ghaoth        4␤Ghlas'        1␤Ghleann       1␤Ghleanntáin  

[04:01] <camelia> ..1␤Go    1␤I     1␤Is    1…»

[04:02] <skids> When in doubt, introspect.

[04:03] <skids> m: (1,2,3).map(-> $w { $w++ }).WHAT.say

[04:03] <camelia> rakudo-moar a37cd2: OUTPUT«(Seq)␤»

[04:03] *** adu joined
[04:03] <skids> m: (1,2,3).map(-> $w { $w++ }).perl.say

[04:03] <camelia> rakudo-moar a37cd2: OUTPUT«Cannot resolve caller postfix:<++>(Int); none of these signatures match:␤    (Mu:D $a is rw)␤    (Mu:U $a is rw)␤    (Int:D $a is rw)␤    (int $a is rw)␤    (Bool:U $a is rw)␤    (Bool:D $a is rw)␤    (Num:D $a is rw)␤    (Num:U $a is rw)…»

[04:03] *** adu left
[04:04] <skids> m: (1,2,3).map(-> $w is copy { $w++ }).perl.say

[04:04] <camelia> rakudo-moar a37cd2: OUTPUT«(1, 2, 3).Seq␤»

[04:04] <skids> m: (for (1,2,3) { $w++ }).perl.say

[04:04] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '$w' is not declared␤at <tmp>:1␤------> 3(for (1,2,3) { 7⏏5$w++ }).perl.say␤»

[04:04] <skids> m: (for (1,2,3) { $w + 1 }).perl.say

[04:04] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '$w' is not declared␤at <tmp>:1␤------> 3(for (1,2,3) { 7⏏5$w + 1 }).perl.say␤»

[04:04] <skids> I suck tonight

[04:05] <skids> m: (for (1,2,3) -> $w { $w + 1 }).perl.say

[04:05] <camelia> rakudo-moar a37cd2: OUTPUT«(2, 3, 4)␤»

[04:05] <skrshn> thanks skids.. a lot of food for thought for me

[04:05] <skids> m: (for (1,2,3) -> $w { $w + 1 }).WHAT.say

[04:05] <camelia> rakudo-moar a37cd2: OUTPUT«(List)␤»

[04:17] *** pochi_ joined
[04:20] *** dainis joined
[04:28] *** dainis left
[04:29] *** kaare_ joined
[04:33] <skrshn> m: sub func(@arr is copy) { @arr[0] = "First";}; my @arr = ^10; func(@arr); say @arr;

[04:33] <camelia> rakudo-moar a37cd2: OUTPUT«[0 1 2 3 4 5 6 7 8 9]␤»

[04:33] <skrshn> in the argument "@arr is copy", is @arr deep coy?

[04:33] <skrshn> *copy

[04:35] <skrshn> m: sub func(@arr is copy) { @arr[0][0] = "First";}; my @arr = ^10; @arr[0] = ^10; func(@arr); say @arr;

[04:35] <camelia> rakudo-moar a37cd2: OUTPUT«Cannot modify an immutable Int␤  in sub func at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[04:37] <skrshn> m: sub func(@arr is copy) { @arr[0][0] = "First";}; my @arr = ^10; @arr[0] = [0,1,2]; func(@arr); say @arr;

[04:37] <camelia> rakudo-moar a37cd2: OUTPUT«[[First 1 2] 1 2 3 4 5 6 7 8 9]␤»

[04:38] <BenGoldberg> m: my @a; @a[0] = 42; @a[0][0] = 'wut'; say @a;

[04:38] <camelia> rakudo-moar a37cd2: OUTPUT«Cannot modify an immutable Int␤  in block <unit> at <tmp> line 1␤␤»

[04:38] <skrshn> so it is not deep copy

[04:39] <BenGoldberg> To the best of my knowledge, 'is copy' just means that you can assign to the variable name without the original being wiped out.

[04:40] <BenGoldberg> m: sub func(@arr is copy) { @arr = () }; my @a = ^10; func(@a); say @a;

[04:40] <camelia> rakudo-moar a37cd2: OUTPUT«[0 1 2 3 4 5 6 7 8 9]␤»

[04:40] <BenGoldberg> m: sub func(@arr is rw) { @arr = () }; my @a = ^10; func(@a); say @a;

[04:40] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Can only use 'is rw' on a scalar ('$' sigil) parameter␤at <tmp>:1␤»

[04:40] <BenGoldberg> m: sub func(@arr is raw) { @arr = () }; my @a = ^10; func(@a); say @a;

[04:40] <camelia> rakudo-moar a37cd2: OUTPUT«[]␤»

[04:41] <BenGoldberg> m: sub func(@arr is copy) { push @a, 42 }; my @a = ^10; func(@a); say @a;

[04:41] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '@a' is not declared␤at <tmp>:1␤------> 3sub func(@arr is copy) { push 7⏏5@a, 42 }; my @a = ^10; func(@a); say @a;␤»

[04:41] <BenGoldberg> m: sub func(@arr is copy) { push @arr, 42 }; my @a = ^10; func(@a); say @a;

[04:41] <camelia> rakudo-moar a37cd2: OUTPUT«[0 1 2 3 4 5 6 7 8 9]␤»

[04:41] <BenGoldberg> m: sub func(@arr) { push @arr, 42 }; my @a = ^10; func(@a); say @a;

[04:41] <camelia> rakudo-moar a37cd2: OUTPUT«[0 1 2 3 4 5 6 7 8 9 42]␤»

[04:41] * BenGoldberg shrugs

[04:41] *** Xliff left
[04:41] <skrshn> the default for arrays is a binding I think

[04:43] <skrshn> equivalent to @arr := @a

[04:43] <parabolize> m: dd $_ for [ (1..3)».succ, ++«(@ = 1..3), 1 «+« (1..3), 1 »+« 1..3 »+« 1, (for (1..3) -> $a {$a+1}), (*+1 for (1..3)), (1..3).map({$^a + 1}) ]

[04:43] <camelia> rakudo-moar a37cd2: OUTPUT«List <element> = $(2, 3, 4)␤Array <element> = $[2, 3, 4]␤List <element> = $(2, 3, 4)␤Range <element> = 2..4␤List <element> = $(2, 3, 4)␤List <element> = $(2, 3, 4)␤Seq <element> = (2, 3, 4).Seq␤»

[04:44] <skrshn> whoa.. that is way over my head :-)

[04:45] *** AlexDaniel left
[04:54] *** Cabanossi joined
[04:59] *** wamba left
[05:02] <skrshn> Is this the only way to adverb? 

[05:03] <skrshn> m: sub truncate($text, :$limit = 100, :$trailer = '...') {    $text.chars > $limit      ?? "$text.substr(0,$limit)$trailer"     !! $text }; truncate $text,:limit(20)

[05:03] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '$text' is not declared. Did you mean '&next'?␤at <tmp>:1␤------> 3imit)$trailer"     !! $text }; truncate 7⏏5$text,:limit(20)␤»

[05:03] *** dj_goku joined
[05:03] <skrshn> m: sub truncate($text, :$limit = 100, :$trailer = '...') {    $text.chars > $limit      ?? "$text.substr(0,$limit)$trailer"     !! $text }; my $text = (^1000).join(''); truncate $text,:limit(20)

[05:03] <camelia> rakudo-moar a37cd2: ( no output )

[05:04] *** cibs left
[05:04] <skrshn> m: sub truncate($text, :$limit = 100, :$trailer = '...') {    $text.chars > $limit      ?? "$text.substr(0,$limit)$trailer"     !! $text }; my $text = (^1000).join(''); say truncate $text,:limit(20)

[05:04] <camelia> rakudo-moar a37cd2: OUTPUT«01234567891011121314...␤»

[05:04] <parabolize> lots of syntax to play with adverbs let alone named parameters in captures

[05:04] <skrshn> Is this the only way to adverb the function?

[05:05] <skrshn> ok.. I am going through Jnthn's intro. Need to look them up

[05:05] *** Xliff joined
[05:06] *** cibs joined
[05:06] *** dainis joined
[05:08] <parabolize> :( I'm always mixing Signatures and Captures

[05:08] <parabolize> skrshn: https://docs.perl6.org/type/Signature

[05:10] <skrshn> parabolize: thanks

[05:15] <skrshn> this is from the jnthn tutorial. it does not work:

[05:15] <skrshn> m: sub check-array-lengths(*@arrays) {    for @arrays -> @arr {      die "oh no it's too long!" if @arr.elems > 5;   } } my @a = 1..4; my @b = 1..3; check-array-lengths(@a, @b);

[05:15] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3it's too long!" if @arr.elems > 5;   } }7⏏5 my @a = 1..4; my @b = 1..3; check-array␤    expecting any of:␤        infi…»

[05:15] <skrshn> m: sub check-array-lengths(*@arrays) {    for @arrays -> @arr {      die "oh no it's too long!" if @arr.elems > 5;   } }; my @a = 1..4; my @b = 1..3; check-array-lengths(@a, @b);

[05:15] <camelia> rakudo-moar a37cd2: OUTPUT«Type check failed in binding @arr; expected Positional but got Int (1)␤  in sub check-array-lengths at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[05:17] <skrshn> spoke too soon :-)

[05:18] *** holyghost joined
[05:18] <holyghost> gm

[05:20] *** Xliff left
[05:23] *** cyphase left
[05:24] *** BrassLantern left
[05:25] <parabolize> skrshn: change the sig to +@arrays. https://gist.github.com/parabolize/f40df4fad63a13cf9e223928b934a4b3

[05:25] <parabolize> skrshn: do you have a link to the tutorial?

[05:26] <parabolize> skrshn: https://docs.perl6.org/type/Signature#Single_Argument_Rule_Slurpy

[05:28] <skrshn> It is called 2015-spw-perl6-course.pdf and it is part of the rakudo Star page in the Docs directory

[05:28] *** cyphase joined
[05:29] <skrshn> http://www.jnthn.net/papers/2015-spw-perl6-course.pdf

[05:29] <skrshn> In the course, we have **@arrays instead of your +@arrays. Don't know the difference yet

[05:36] <parabolize> there is a snippet here: https://docs.perl6.org/language/functions#Slurpy_Conventions

[05:36] *** cibs left
[05:38] *** cibs joined
[05:43] <skrshn> what is the easiest way to achieve the "in" operator in Python: 

[05:43] <skrshn> m: my @seq = 1..6; say 1 ~~ @seq;

[05:43] <camelia> rakudo-moar a37cd2: OUTPUT«False␤»

[05:44] <skrshn> m: my @seq = 1..6; say 1 in @seq;

[05:44] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3my @seq = 1..6; say 17⏏5 in @seq;␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statemen…»

[05:47] <parabolize> skrshn: (1..6).contains(1)

[05:48] <ShimmerFairy> m: my @a = 1..6; say 1 (in) @a

[05:48] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3my @a = 1..6; say 17⏏5 (in) @a␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement m…»

[05:48] <ShimmerFairy> m: my @a = 1..6; say 1 (elem) @a

[05:48] <camelia> rakudo-moar a37cd2: OUTPUT«True␤»

[05:48] <ShimmerFairy> ^^^ there's also that, but it does involve Sets

[05:48] <skrshn> (elem) is not very intuitive

[05:49] <skrshn> what is (elem) really? is it an operator?

[05:49] <ShimmerFairy> skrshn: it's a texas version of the appropriate set theory operator, which I haven't fixed my compose key to type yet :P

[05:50] <skrshn> got it.. in latex, you would write as \in ? 

[05:51] <ShimmerFairy> Maybe, I wouldn't know off-hand :)

[05:51] <parabolize> 3 ∈ ^6

[05:52] <skrshn> ∈

[05:52] <skrshn> m: say 1 ∈ ^6

[05:52] <camelia> rakudo-moar a37cd2: OUTPUT«True␤»

[05:52] <skrshn> cool

[05:53] <skrshn> is 1 ∈ ^6 a O(n) operation? 

[05:54] <skrshn> or O(log(n)) ? 

[05:54] *** dainis left
[05:55] <ShimmerFairy> skrshn: not sure, but know that set theory operators will implicitly convert things to Set objects as needed, which are implemented as a kind of hash internally.

[05:57] <skrshn> more simply, is it faster to do 1 ∈ ^6 or "my %hash; %hash{$_}++ for ^6; say ?%hash{1};"

[05:58] <BenGoldberg> Converting a list to a hash takes at least O(n) time, regardless of whether you do it manually or use, for example, the .set method on the list.

[05:58] *** wamba joined
[05:59] <skrshn> also, if I am going to do the set operation repeatedly, is the created set object smartly cached?

[05:59] <BenGoldberg> m: my %set := (^6).set; say 1 ∈ %set;

[05:59] <camelia> rakudo-moar a37cd2: OUTPUT«Method 'set' not found for invocant of class 'Range'␤  in block <unit> at <tmp> line 1␤␤»

[05:59] <BenGoldberg> m: my %set := (^6).Set; say 1 ∈ %set;

[05:59] <camelia> rakudo-moar a37cd2: OUTPUT«True␤»

[06:00] <BenGoldberg> I don't think that created sets are automatically cached (yet), but you can do it yourself.

[06:00] <skrshn> BenGoldberg: True. That was an oversight. But my following question is actually the one I am more interested.

[06:01] *** cibs left
[06:01] <skrshn> so doing my %set = (^6).Set is more efficient than "my %hash; %hash{$_}++ for ^6;" ?  or is it the same thing?

[06:02] <skrshn> Probably does not matter. As you said, both are probably O(n) 

[06:02] <skrshn> sorry O(nlog(n))

[06:03] <BenGoldberg> I'd expect the .Set method to be a fraction faster, as it's not storing a bunch of ints that the ++ version does.

[06:03] *** cibs joined
[06:04] <skrshn> BenGoldberg: makes sense

[06:05] <BenGoldberg> Also, if you're going to use assignment = instead of binding := then you should use a $scalar variable, not a %hash variable...

[06:06] <BenGoldberg> my $set = (^6).Set; #(ok), my %set := (^6).Set; #(ok), my %set = (^6).Set; # not ok, will not dwym

[06:08] *** cibs left
[06:08] <skrshn> what is happening here: my %set := (^6).Set; #(ok)

[06:09] *** cibs joined
[06:11] <skrshn> Hash and Set both have % sigil?

[06:12] <BenGoldberg> I'm not really good at explaining... have you ever programmed in say, perl5 or c++?

[06:12] <skrshn> I have programmed in both. pretty decent in perl5

[06:13] <BenGoldberg> In perl5, what's the difference between doing: our %hash = %foo, and doing *hash = \%foo;

[06:14] <skrshn> I have never used the second construct. 

[06:14] <skrshn> Are you hinting at binding? 

[06:14] <BenGoldberg> Assignment in perl6 is like assignment in perl5... but doing binding in perl6 (using the := operator) is like assigning a ref to a glob.

[06:14] <BenGoldberg> yes

[06:14] <skrshn> I understand that part

[06:15] <skrshn> my question is..

[06:15] <skrshn> m: my %hash := (^6).Set; say %hash.WHAT; say %hash.perl;

[06:15] <camelia> rakudo-moar a37cd2: OUTPUT«(Set)␤set(5,4,3,0,1,2)␤»

[06:15] <skrshn> m: my %hash = (^6).Set; say %hash.WHAT; say %hash.perl;

[06:15] <camelia> rakudo-moar a37cd2: OUTPUT«(Hash)␤{"0" => Bool::True, "1" => Bool::True, "2" => Bool::True, "3" => Bool::True, "4" => Bool::True, "5" => Bool::True}␤»

[06:15] <BenGoldberg> :)

[06:16] <skrshn> So I thought Hash and Set are somehow connected.. one is a subclass of the other

[06:16] *** aries_liuxueyang joined
[06:18] <BenGoldberg> m: Hash.^parents.say;

[06:18] <camelia> rakudo-moar a37cd2: OUTPUT«((Map))␤»

[06:18] <BenGoldberg> m: Set.^parents.say;

[06:18] <camelia> rakudo-moar a37cd2: OUTPUT«()␤»

[06:18] <BenGoldberg> m: Map.^parents.say;

[06:18] <camelia> rakudo-moar a37cd2: OUTPUT«()␤»

[06:18] <skrshn> ok

[06:18] <skrshn> m: Set.^parents.say;

[06:18] <camelia> rakudo-moar a37cd2: OUTPUT«()␤»

[06:20] *** adu joined
[06:24] <BenGoldberg> m: say Hash.can('AT-KEY');

[06:24] <camelia> rakudo-moar a37cd2: OUTPUT«(Method+{<anon|53710736>}.new Method+{<anon|53710736>}.new Method+{<anon|53710736>}.new)␤»

[06:24] <BenGoldberg> m: say Set.can('AT-KEY');

[06:24] <camelia> rakudo-moar a37cd2: OUTPUT«(Method+{<anon|53710736>}.new Method+{<anon|53710736>}.new)␤»

[06:24] <BenGoldberg> m: say Array.can('AT-KEY');

[06:24] <camelia> rakudo-moar a37cd2: OUTPUT«(Method+{<anon|53710736>}.new)␤»

[06:24] <BenGoldberg> m: my @foo; @foo{0} = 2;

[06:24] <camelia> rakudo-moar a37cd2: OUTPUT«Type Array does not support associative indexing.␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[06:25] <BenGoldberg> m: my @foo; @foo.AT-KEY(0) = 2;

[06:25] <camelia> rakudo-moar a37cd2: OUTPUT«Type Array does not support associative indexing.␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[06:25] <BenGoldberg> m: Mu{0} = 1;

[06:25] <camelia> rakudo-moar a37cd2: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Autovivifying object closures not yet implemented. Sorry. ␤at <tmp>:1␤------> 3Mu{0}7⏏5 = 1;␤»

[06:25] *** nine left
[06:26] <BenGoldberg> Oops?

[06:27] *** domidumont joined
[06:28] <BenGoldberg> It is getting late (early), so good night.

[06:28] *** BenGoldberg left
[06:31] *** domidumont left
[06:32] *** domidumont joined
[06:33] *** Tonik joined
[06:39] <skrshn> m: class DaySchedule { has $!opening; has $!closing; has %!schedule; submethod BUILD(:$opening!, :$closing!) {  } }

[06:40] <skrshn> How do I initialize the object properly if the names are the same? 

[06:40] *** hwcomcn joined
[06:43] <skrshn> Also, how do I delete a class definition in a running session of perl6 REPL? 

[06:47] <skrshn> figured it out: $!opening = $opening. (obviously)

[06:52] *** hwcomcn left
[06:55] *** wamba left
[06:55] *** RabidGravy joined
[06:56] *** cibs left
[06:57] *** adu left
[06:58] *** cibs joined
[07:02] <skrshn> is it possible to delete a class definition (or change) a class defined in the REPL? I don't want to keep quitting and restarting the perl6 REPL every time I change the class 

[07:02] <psch> skrshn: you can mess with the class via its meta object, but you can redeclare a new class with the same name

[07:03] <skrshn> m: class A {}; class A {}

[07:03] <psch> skrshn: you could probably assign an anonymous class into a sigilless variable instead of using the normal 'class ... { }' syntax and overwrite the content of that variable, but that doesn't change already instantiated objects

[07:04] <skrshn> bad example

[07:04] <psch> something like 'my \Foo = class :: { ... }; ...; Foo := class :: { ... }'

[07:04] <skrshn> This is what I am getting: ===SORRY!=== Error while compiling: Redeclaration of symbol DaySchedule at line 2 ------> class DaySchedule⏏     expecting any of:         generic role

[07:04] <psch> err, you *cant* redeclare with the same name

[07:04] <psch> sorry, just got my first cup of coffee :)

[07:05] <skrshn> So in an ongoing session of the REPL, I have to keep updating the class name for every change? 

[07:05] <psch> or you use one of the two other ways i suggested

[07:06] <skrshn> I don't really understand what you said.. sorry..

[07:06] <skrshn> can you give more details? 

[07:08] *** vendethiel- joined
[07:08] *** vendethiel left
[07:09] <skrshn> How would I use your example if I want to improvise a class definition and examine it in a running REPL session? 

[07:09] <psch> skrshn: https://gist.github.com/peschwa/22815eefdf64efcc181abcddd31d4952

[07:10] <psch> the sigilless one is probably closer to what you want, as you can keep using the same name

[07:10] <psch> you just slightly change how you define the class

[07:10] <psch> note though that in the example $x and $y are *not* the same class

[07:11] <psch> and $x doesn't get the method foo

[07:11] <psch> if you need changes to propagate back to older instances you have to use the MOP

[07:12] *** domidumont left
[07:12] <skrshn> awesome! the sigilless one is what I want. I don't want to propogate anything

[07:16] <skrshn> psch: what does "Foo = $;" do?

[07:16] <skrshn> sorry.. "my \Foo = $;"

[07:16] <psch> skrshn: well, normally sigilless variables don't get a container, so you can reassign

[07:17] <psch> skrshn: the $ is an anonymous state variable, which gets us the wanted container so we can assign things to Foo

[07:17] <psch> skrshn: https://docs.perl6.org/language/containers might be of interest

[07:18] <skrshn> right now, this is beyond me.. thanks for the link. I will read it later.

[07:24] *** jack_rabbit left
[07:26] <skrshn> psch: for "Foo = class :: { }", how would roles work? 

[07:28] <skrshn> how do I specify "does XXX" in the above ? 

[07:28] <psch> skrshn: just after the ::, it's a standin for a name if you don't have one

[07:29] <skrshn> ok

[07:32] *** CIAvash joined
[07:33] *** kurahaupo joined
[07:33] <skrshn> psch: This does not work: https://gist.github.com/skrisna/883d74e784f0af5f3f88679d72d483ec

[07:34] <skrshn> It complains: "No compile-time value for Rolex"

[07:34] <psch> well, yeah

[07:34] <psch> that's because it's true :)

[07:35] <psch> as in, the assignment happens at runtime, but mixins happen at compile time

[07:35] <psch> so Rolex doesn't have a meaningful value when the class that you assign to Classx wants to compose it

[07:35] <psch> if you want to move the mixin to runtime you have to do it via the MOP

[07:36] <psch> as in, 'Classx = ...; Classx.^mixin(Rolex);'

[07:36] <psch> you might have to .^compose after that, not sure

[07:36] <skrshn> let me try..

[07:38] <psch> you could, of course, just do all the editing in a file and run that file directly

[07:38] <psch> which, by now, probably would have saved you a lot of typing :)

[07:38] <psch> and you wouldn't need all those weird workarounds for runtime stuff vOv

[07:38] * psch doesn't really get the appeal of REPLs

[07:39] <skrshn> but I am also learning a lot thanks to you :-)

[07:41] <skrshn> Actually, if I remove "does Rolex" then I get "No such private method 'zero-scores'" .. is there a workaround? 

[07:41] *** domidumont joined
[07:41] *** labster joined
[07:41] <psch> skrshn: well, you can reference a method that doesn't exist

[07:42] <timotimo> but not private methods, as they are already looked up at compile time

[07:42] <skrshn> psch: ??

[07:42] <timotimo> when the closing curly brace of the class definition is first encountered

[07:42] <psch> ...

[07:42] <timotimo> no way to make it work afterwards with MOP and .^compose

[07:42] <psch> that's the second time i' missing a "'t" 

[07:42] <psch> so, "can't reference a method that doesn't exist"

[07:42] <timotimo> you can reference public methods that don't exist, though

[07:43] <psch> well, i'd say the workaround kludge has reached it's limits

[07:43] <psch> but as timotimo says, you could probably make it public and keep going like that

[07:43] <skrshn> timotimo: example? 

[07:43] <psch> ...just replace the ! with a .

[07:44] <psch> in the invocation and declaration both

[07:44] <skrshn> I mean, referencing method that does not exist

[07:44] <skrshn> the public/private part I get

[07:46] <skrshn> psch: I will take your advice for now and not digress to much from what I am learning at the moment. Just source files wo/ using REPL

[07:49] *** girafe joined
[07:49] *** thomas joined
[07:51] *** Tonik left
[07:54] *** darutoko joined
[08:00] *** holyghost left
[08:01] *** spider-mario joined
[08:06] *** darutoko left
[08:10] *** domidumont left
[08:19] <stmuk> hmm I'm used to online forum perl 6 discussion being a bit rubbish but I did find it worrying one of the more interesting posters on the R* reddit the saying " The language is still in beta (official beta circa last December)"

[08:19] <stmuk> s/the/thread

[08:23] *** kurahaupo left
[08:23] *** kurahaupo joined
[08:23] *** firstdayonthejob joined
[08:31] <dalek> perl6.org: d3e1a1d | (Steve Mynott)++ | source/index.html:

[08:31] <dalek> perl6.org: try to explain better perl 6 no long in beta

[08:31] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/d3e1a1d367

[08:31] <dalek> perl6.org: b87f768 | (Steve Mynott)++ | source/downloads/index.html:

[08:31] <dalek> perl6.org: missed space

[08:31] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/b87f768857

[08:39] *** rindolf joined
[08:48] <dalek> Inline-Perl5: de1dfb6 | niner++ | / (2 files):

[08:48] <dalek> Inline-Perl5: Expose Perl 5 global variables as %*PERL5

[08:48] <dalek> Inline-Perl5: 

[08:48] <dalek> Inline-Perl5: Fixes GH #69

[08:48] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/de1dfb6dd9

[08:51] <stmuk> hmmm is there a .tell $zoffix-last-nick ?

[08:53] *** RabidGravy left
[09:12] *** cibs left
[09:14] *** cibs joined
[09:17] *** holyghost joined
[09:20] *** cibs left
[09:21] *** cibs joined
[09:32] *** iH2O joined
[09:36] *** Actualeyes joined
[09:39] *** AndyBotwin left
[09:41] *** skrshn left
[09:44] *** FROGGS joined
[09:44] *** domidumont joined
[09:47] *** ufobat joined
[09:48] <ufobat> hoi :)

[09:48] <timotimo> yo!

[09:50] <hahainternet> o/

[09:52] *** cosimo left
[09:57] <iH2O> grrr

[09:57] <iH2O> oops that nick is already reserved, srry

[10:08] *** holyghost left
[10:31] *** setty1 joined
[10:39] *** colomon joined
[10:42] *** labster left
[10:51] *** esh_ joined
[10:51] *** pierrot_ joined
[10:52] *** darutoko joined
[10:53] *** Bucciarati joined
[10:53] *** colomon left
[10:55] *** kurahaupo left
[10:55] *** colomon joined
[11:05] *** kid51 joined
[11:10] *** colomon left
[11:15] <timotimo> we may need a module that builds a whole bunch of nice emoji operators

[11:15] <timotimo> like "FAX MACHINE" for what C++ uses << for

[11:15] <timotimo> and maybe "TELEPHONE" for what C++ uses >> for

[11:16] *** kid51 left
[11:34] *** sena_kun joined
[11:34] <Roamer`> hmm, is try supposed to not catch everything?

[11:34] <Roamer`> m: sub a() { my @arr = 1; my %hash = @arr; %hash; }; my %res = try a; dd %res;

[11:34] <timotimo> BBL

[11:34] <Roamer`> oh, camelia is not here...

[11:37] *** domidumont left
[11:37] <Roamer`> still, can anybody explain why this dies instead of saying "whee"?

[11:37] <Roamer`> use v6.c; sub a() { my @arr = 1; my %hash = @arr; %hash; }; my %res = try a; say "whee";

[11:38] <lizmat> fwiw, the #perl6 channel on irc.perl.org seems to have "p6eval"

[11:39] <lizmat> which seems up to date

[11:40] <Roamer`> ahh, I got it actually

[11:40] <Roamer`> try does catch the thing

[11:41] <Roamer`> but then returns a Failure object, an X::AdHoc

[11:41] <Roamer`> and I try to assign a single Failure object to a hash

[11:41] <Roamer`> and that's what dies

[11:41] <Roamer`> my $res = try a works

[11:41] <Roamer`> but thanks for the p6eval pointer

[11:41] *** MasterDuke joined
[11:42] <MasterDuke> Roamer`: committable is still here also

[11:43] <MasterDuke> committable: help

[11:43] <committable> MasterDuke: Like this: committable: f583f22,HEAD say 'hello'; say 'world'

[11:43] *** iH2O left
[11:43] <MasterDuke> committable: HEAD use v6.c; sub a() { my @arr = 1; my %hash = @arr; %hash; }; my %res = try a; say "whee";

[11:43] <committable> MasterDuke: |«HEAD»: Odd number of elements found where hash initializer expected:␤Only saw 1 element␤  in block <unit> at /tmp/OGVPURWOcT line 1␤ exit code = 1

[11:46] *** rindolf left
[11:46] <Roamer`> MasterDuke, thanks

[11:49] *** cognominal joined
[12:02] *** Guest66 joined
[12:03] *** pmqs joined
[12:04] *** vendethiel- left
[12:08] *** pmqs left
[12:08] *** darutoko left
[12:15] *** domidumont joined
[12:15] *** domidumont left
[12:16] *** domidumont joined
[12:17] *** rindolf joined
[12:20] *** pmqs joined
[12:26] *** pmqs left
[12:38] *** Xliff joined
[12:39] *** kaare_ left
[12:42] *** pmqs joined
[12:43] *** colomon joined
[12:53] *** perlawhirl joined
[13:06] *** domidumont left
[13:14] *** Tonik joined
[13:14] *** darutoko joined
[13:18] *** colomon left
[13:20] *** darutoko left
[13:20] *** colomon joined
[13:22] *** kaare_ joined
[13:22] *** colomon left
[13:23] *** colomon joined
[13:23] *** vcv joined
[13:26] *** kurahaupo joined
[13:32] *** kaare_ left
[13:35] *** skrhn joined
[13:40] *** kaare_ joined
[13:42] *** geekosaur joined
[13:42] *** geekosaur left
[13:43] *** geekosaur joined
[13:46] *** dainis joined
[13:46] *** skids joined
[13:50] *** darutoko joined
[13:51] *** rindolf left
[13:52] <Guest66> hello

[13:52] <Guest66> How to change a variable str to list

[13:52] <Guest66> ?

[13:52] *** Guest66 is now known as P6fr

[13:53] *** ccube joined
[13:55] <ccube> p6: say [1, <2 3 4>, 5].flat

[13:55] <P6fr> m: say [1, <2 3 4>, 5].flat

[13:55] <P6fr> hum

[13:55] <P6fr> m: say "hello"

[13:56] <gfldex> camelia: you there honey?

[13:56] <vcv> p6eval: say [1, <2 3 4>, 5].flat

[13:56] *** skids left
[13:56] <P6fr> camelia sleep

[13:56] <P6fr> :-)

[13:56] *** colomon left
[13:56] <MasterDuke> committable: help

[13:56] <committable> MasterDuke: Like this: committable: f583f22,HEAD say 'hello'; say 'world'

[13:57] <ccube> in any case turns it into a list but doesn't flatten in my recently downloaded p6

[13:57] <MasterDuke> committable: f583f22,HEAD say 'hello'; say 'world'

[13:57] <committable> MasterDuke: |«f583f22,HEAD»: hello␤world

[13:57] <MasterDuke> committable: HEAD say [1, <2 3 4>, 5].flat

[13:57] <committable> MasterDuke: |«HEAD»: (1 (2 3 4) 5)

[13:58] <P6fr> you want the result (1 2 3 4 5) ?

[13:58] *** wamba joined
[13:59] <ccube> i'm trying to learn p6, p6doc say .flat will interpret invocant as list and flatten - here's an example where it doesn't

[13:59] <ccube> bug or am i confused

[13:59] *** colomon joined
[14:00] *** darutoko left
[14:00] <P6fr> f583f22,HEAD my $nums = [1, <2 3 4>, 5]; say |$nums.flat

[14:00] <psch> commitable: f583f22,HEAD my $nums = [1, <2 3 4>, 5]; say |$nums.flat

[14:00] <gfldex> ccube: it does remove the first level, what is []

[14:00] <psch> +t >_>

[14:01] <P6fr> 	committable:f583f22,HEAD my $nums = [1, <2 3 4>, 5]; say |$nums.flat

[14:01] <psch> committable: f583f22,HEAD my $nums = [1, <2 3 4>, 5]; say ($nums.flat).elems

[14:01] <committable> psch: |«f583f22,HEAD»: 3

[14:01] <psch> committable: f583f22,HEAD my $nums = [1, <2 3 4>, 5]; say ($nums>>.flat).elems

[14:01] <committable> psch: |«f583f22,HEAD»: 3

[14:01] <psch> committable: f583f22,HEAD my $nums = [1, <2 3 4>, 5]; say ($nums.flat).WHAT

[14:01] <committable> psch: |«f583f22,HEAD»: (Seq)

[14:01] <psch> that's somewhat informative

[14:01] <gfldex> ccube: if you want to flatten recursively, use .deepmap

[14:01] <psch> committable: f583f22,HEAD my $nums = [1, <2 3 4>, 5]; say $nums.flat.flat

[14:01] <committable> psch: |«f583f22,HEAD»: (1 (2 3 4) 5)

[14:01] <psch> gfldex++

[14:03] <vcv> commitable: HEAD say flat [1, <2 3 4>, 5].List

[14:03] <ccube> gfldex: example?

[14:03] <vcv> commitable f583f22,HEAD say flat [1, <2 3 4>, 5].List

[14:03] <gfldex> `my @a = [1,2,3]` and `my @a = 1,2,3` are not the very same thing

[14:03] <psch> committable: HEAD say [1, <2 3 4>, 5].deepmap(*.flat)

[14:03] <committable> psch: |«HEAD»: [(1) ((2) (3) (4)) (5)]

[14:03] <psch> heh

[14:03] <vcv> committable: HEAD say flat [1, <2 3 4>, 5].List

[14:03] <committable> vcv: |«HEAD»: (1 2 3 4 5)

[14:03] *** colomon left
[14:04] <ccube> vcv: okay but p6doc say "interprets invocant as List"

[14:05] <ccube> commitable: HEAD say [1, <2 3 4>,5].List.flat

[14:06] <P6fr> committable HEAD my $nums = [1, <2 3 4>, 5]; $nums.isa(Any)

[14:06] <committable> P6fr: |«HEAD»: 

[14:06] <P6fr> committable HEAD my $nums = [1, <2 3 4>, 5]; say $nums.isa(Any)

[14:06] <committable> P6fr: |«HEAD»: True

[14:07] <MasterDuke> committable: HEAD say [1, <2 3 4>,5].List.flat

[14:07] <committable> MasterDuke: |«HEAD»: (1 2 3 4 5)

[14:07] <MasterDuke> ccube: ^^^, you were missing a 't'

[14:08] <P6fr> committable HEAD  say (1, <2 3 4>, 5).flat

[14:08] <committable> P6fr: |«HEAD»: (1 2 3 4 5)

[14:08] <P6fr> committable HEAD  say (1, <2 3 4>, 5).flat.elems

[14:08] <committable> P6fr: |«HEAD»: 5

[14:08] <ccube> committable: HEAD say [1, <2 3 4>,5].List.flat

[14:08] <committable> ccube: |«HEAD»: (1 2 3 4 5)

[14:08] <P6fr> it's ok ?

[14:09] <ccube> ok, but seems flat method does NOT coerce invocant to List

[14:09] <MasterDuke> committable: HEAD say [1, <2 3 4>,5].WHAT;say (1, <2 3 4>,5).WHAT

[14:09] <committable> MasterDuke: |«HEAD»: (Array)␤(List)

[14:09] <vcv> ccube: which doc says that?

[14:09] <ccube> p6doc List

[14:10] <P6fr> Interprets the invocant as a list, flattens it, and returns that list.

[14:10] <vcv> [ ] is an Array, not a List, right?

[14:10] <ccube> committable: HEAD say [1,<2 3 4>,5].flat

[14:10] <committable> ccube: |«HEAD»: (1 (2 3 4) 5)

[14:11] <MasterDuke> committable: HEAD say [1, <2 3 4>,5].list.flat

[14:11] <committable> MasterDuke: |«HEAD»: (1 (2 3 4) 5)

[14:11] <ccube> an array that doesn't get interpreted as a List

[14:11] <MasterDuke> there's a difference between a List and a list

[14:11] <vcv> i have so much to learn

[14:11] <P6fr> HEAD say [1, <2 3 4>,5].List.flat

[14:11] <MasterDuke> so it 'Interprets the invocant as a list, flattens it, and returns that list.' instead of 'Interprets the invocant as a List, flattens it, and returns that List.'

[14:11] <P6fr> committable HEAD say [1, <2 3 4>,5].List.flat

[14:11] <committable> P6fr: |«HEAD»: (1 2 3 4 5)

[14:12] <P6fr> yes

[14:12] <MasterDuke> which i agree is confusing and arguably non-intuitive

[14:12] <ccube> so .flat flattens List but not list

[14:12] <ccube> humm

[14:13] <P6fr> well found

[14:13] <ccube> or maybe vice versa

[14:14] <vcv> committable: HEAD say [1, (2, (3, 4)), 5].flat

[14:14] <P6fr> the method works with low & haigh cass normally

[14:14] <committable> vcv: |«HEAD»: (1 (2 (3 4)) 5)

[14:14] *** Sgeo left
[14:14] *** rindolf joined
[14:14] <vcv> well that wasnt what i expected

[14:14] <P6fr> committable HEAD say list([1, <2 3 4>,5])

[14:14] <committable> P6fr: |«HEAD»: (1 (2 3 4) 5)

[14:14] <P6fr> committable HEAD say List([1, <2 3 4>,5])

[14:14] <committable> P6fr: |«HEAD»: ([1 (2 3 4) 5])

[14:15] <vcv> I thought Array's flat method constructs a new List from the elements in the Array, after calling .flat on each element

[14:16] <vcv> calling .flat on a List like (2, (3, 4)) should flatten it to (2, 3, 4)

[14:16] <psch> committable: HEAD say (2, (3,4)).flat

[14:16] <committable> psch: |«HEAD»: (2 3 4)

[14:16] <psch> vcv: okay

[14:16] <ccube> side issue - I ran p6doc-index, but p6doc -f ... takes an absurdly long time to respond

[14:16] *** Sgeo joined
[14:17] <tbrowder> lizmat: how do you get the fine-grained timings for showing speed-ups for various functions?

[14:17] <yoleaux> 22 Jul 2016 02:47Z <unmatched}> tbrowder: Not sure if it has any relevance to your table Pod work, but just thought I'd mention this old ticket I came across about =paras in tables: https://rt.perl.org/Ticket/Display.html?id=127509#ticket-history

[14:17] *** andrzejku joined
[14:18] <P6fr> tbrowder  say now - INIT now; 

[14:18] <ccube> anybody else seeing very slow p6doc -f ... ?

[14:19] <P6fr> committable HEAD my @a = ("A".."Z" Z=> 1..26).perl;now - INIT now;

[14:19] <committable> P6fr: |«HEAD»: WARNINGS for /tmp/gMUVpwvbaP:␤Useless use of "-" in expression "now - INIT now" in sink context (line 1)

[14:19] <P6fr> committable HEAD my @a = ("A".."Z" Z=> 1..26).perl;say now - INIT now;

[14:19] <committable> P6fr: |«HEAD»: 0.01123732

[14:20] *** kalkin-_ joined
[14:20] <kalkin-_> hi

[14:20] <P6fr> hi

[14:20] *** colomon joined
[14:20] <MasterDuke> btw, it's still pretty rough, but we do have benchable

[14:20] <MasterDuke> benchable: help

[14:20] <benchable> MasterDuke: Like this: benchable: f583f22,110704d my $a = "a" x 2**16;for ^1000 {my $b = $a.chop($_)}

[14:20] <kalkin-_> m: use 🙈;

[14:21] <MasterDuke> benchable: 2016.01,HEAD my @a = ("A".."Z" Z=> 1..26)

[14:21] <benchable> MasterDuke: |«2016.01»:No build for this commit␤|«HEAD»:0.1010

[14:21] <kalkin-_> m: unit class 🙈 {};

[14:22] <kalkin-_> m: unit class 🙈 {}; say "foo";

[14:22] *** kalkin-_ is now known as kalkin-

[14:22] <MasterDuke> kalkin-_: camelia is unavailable right now, but you can use committable

[14:22] <P6fr> committable HEAD unit class 🙈 {}; say "foo";

[14:23] <committable> P6fr: |«HEAD»: ===SORRY!=== Error while compiling /tmp/kCkhzuoEEe␤Unable to parse class definition␤at /tmp/kCkhzuoEEe:1␤------> unit class⏏ 🙈 {}; say "foo";␤    expecting any of:␤        generic role exit code = 1

[14:24] <kalkin-> yeah this is what I'm trying to show. I can't use Unicode(or just the monkey see no evile?) as any unit name

[14:24] <tbrowder>   yoleaux: I'm aware of the problem, and I hope to work on it after I get the basic table working and accepted first. At the moment I don't know if that will require grammar work or not. I don't have the knowledge or experience enough yet to dig into the grammar and actions, but ShimmerFairy does.  I will try an experiment later today which I hope will show

[14:24] <tbrowder> me whether or not it requires grammar work.

[14:24] <kalkin-> (Actually I just wanted for lulz alias MONKEY-SEE-NO-EVAL to 🙈)

[14:25] *** colomon left
[14:25] *** kaare_ left
[14:25] *** ccube left
[14:26] *** AlexDaniel joined
[14:27] <vcv> committable: HEAD my $💩 = 42; say $💩

[14:27] <committable> vcv: https://gist.github.com/33eab609cc8af73d38cb49e3945ca7c3

[14:27] <vcv> committable: my $a💩 = 42; say $a💩

[14:27] <committable> vcv: |«my»: Cannot find this revision

[14:28] <vcv> committable: HEAD my $a💩 = 42; say $a💩

[14:28] <committable> vcv: https://gist.github.com/050661bfee2c4fea7873032e20cd9299

[14:30] <kalkin-> vcv: Ohh TIL, that the name must be an alphabetic character. It's a pity, but makes kind of sense

[14:30] *** vcv left
[14:30] *** vcv joined
[14:31] *** kaare_ joined
[14:32] <AlexDaniel> commit HEAD my \term:<💩> = 42; say 💩

[14:32] <committable> AlexDaniel: |«HEAD»: 42

[14:32] <sena_kun> tbrowder, I'm not sure if I'm right, but I doubt your message will be delivered this way. Yoleaux's message delivery command works like this: ".tell $nickname message".

[14:32] <AlexDaniel> kalkin-: ↑

[14:33] <kalkin-> ok

[14:33] <kalkin-> AlexDaniel: thanks

[14:33] <AlexDaniel> kalkin-: it's not a very good idea because it affects startup time, but it is still possible

[14:34] <gfldex> AlexDaniel: that doesn't work because 'use MONKEY-SEE-NO-EVAL' is a term in itself. If you `use 🙈;` rakudo thinks you call the use sub.

[14:35] <gfldex> and there is no sub called use

[14:37] <gfldex> also, you can't do `my \term:<use 🙈> = 'use MONKEY-SEE-NO-EVAL';` because terms are separated by space

[14:38] <P6fr> committable HEAD my $a = (123).list;say [+] $a;

[14:38] <committable> P6fr: |«HEAD»: 123

[14:38] <P6fr> committable HEAD my $a = (123).list;say [+]$a;

[14:38] <committable> P6fr: https://gist.github.com/71c1da00b1ce173255222ccbfbb2beed

[14:38] *** wamba left
[14:41] <MasterDuke> commit: HEAD my $a = "123".comb;say [+] $a;say $a.sum

[14:41] <committable> MasterDuke: |«HEAD»: 6␤This Seq has already been iterated, and its values consumed␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at /tmp/RDw8UPu82h line 1␤ exit code = 1

[14:41] <MasterDuke> commit: HEAD my $a = "123".comb;say $a.sum

[14:41] <committable> MasterDuke: |«HEAD»: 6

[14:41] <kalkin-> I'm reading the documentation of Cool.EVAL() but I can't find a way to provide a context to the EVAL (i.e. already defined vars and so on...)

[14:42] <kalkin-> the only way I see to encapsulate it in it's own module and let the EVAL executed code assign values inside this dummy module

[14:42] <kalkin-> right?

[14:42] <arnsholt> IIRC it's evaluated in the lexical scope where EVAL is called

[14:43] <P6fr> commit: HEAD my $a = "123".comb.say

[14:43] <committable> P6fr: |«HEAD»: (1 2 3)

[14:43] <P6fr> commit: HEAD my $a = "123".say

[14:43] <committable> P6fr: |«HEAD»: 123

[14:43] <P6fr> commit: HEAD my $a = "123".list.say

[14:43] <committable> P6fr: |«HEAD»: (123)

[14:43] <kalkin-> arnsholt,: docs are saying → Furthermore, the EVAL is evaluated in the current package:

[14:43] <P6fr> hum

[14:43] <arnsholt> Pretty sure there's no way to supply additional bindings like Python's eval (most likely because Python's naming and binding model makes that really easy, unlike the Perl 6 model)

[14:44] *** perlawhirl left
[14:44] <arnsholt> m: my $foo = "foo"; 'say $foo'.EVAL # Let's see

[14:44] <P6fr> which is difference between comb & list MasterDuke  pls ?

[14:44] <arnsholt> Bah, no evalbot!

[14:44] <P6fr> what is*

[14:45] <MasterDuke> P6fr: comb splits a string based on the given delimiter

[14:45] <DrForr> She's on a recently-banned server.

[14:45] <arnsholt> kalkin-: It's in the scope where EVAL is called, as far as I can make out from a quick REPL test

[14:45] <AlexDaniel> why was it banned?

[14:45] <MasterDuke> which defaults to the empty string

[14:45] <DrForr> No idea.

[14:45] <P6fr> as split() ?

[14:45] <moritz> how can one get it to be unbanned?

[14:46] *** dainis left
[14:46] <psch> moritz: nine already mailed freenode support earlier today

[14:46] *** bob777 left
[14:46] <kalkin-> committable: HEAD my $foo; module Bar { say EVAL("say \$foo"); }

[14:46] <committable> kalkin-: |«HEAD»: (Any)␤True

[14:47] <kalkin-> committable: HEAD my $foo; say EVAL("say \$foo"); 

[14:47] <committable> kalkin-: |«HEAD»: (Any)␤True

[14:47] <MasterDuke> i wasn't entirely accurate. split() splits, comb() return matches

[14:47] <kalkin-> committable: HEAD my $foo="fii"; say EVAL("say \$foo"); 

[14:47] <committable> kalkin-: |«HEAD»: fii␤True

[14:47] <kalkin-> committable: HEAD my $foo="fii"; module Bar { say EVAL("say \$foo"); }

[14:47] <committable> kalkin-: |«HEAD»: fii␤True

[14:48] <kalkin-> interesting

[14:48] <P6fr> haaa

[14:48] <MasterDuke> but the default pattern that comb() matches on is essentially /./, i.e., return a list of all characters

[14:48] <moritz> fwiw I'e just stopped the [email@hidden.address] service

[14:49] <P6fr> commit: HEAD my $a = "123".comb.say.WHAT

[14:49] <committable> P6fr: |«HEAD»: (1 2 3)

[14:49] <P6fr> commit: HEAD my $a = "123".comb.WHAT.say

[14:49] <committable> P6fr: |«HEAD»: (Seq)

[14:49] *** bob777 joined
[14:49] <P6fr> commit: HEAD my $a = "123".list.WHAT.say

[14:49] <committable> P6fr: |«HEAD»: (List)

[14:50] <MasterDuke> P6fr: my $a = "123".list just creates a one-element list

[14:51] <P6fr> yes

[14:51] *** dainis joined
[14:51] <MasterDuke> commit: HEAD my $a = "123".comb.list;say $a;say $a.WHAT

[14:51] <committable> MasterDuke: |«HEAD»: (1 2 3)␤(List)

[14:51] <MasterDuke> commit: HEAD my $a = "123".list;say $a;say $a.WHAT

[14:51] <committable> MasterDuke: |«HEAD»: (123)␤(List)

[14:52] <P6fr> thx i understand

[14:53] *** evalable joined
[14:53] <AlexDaniel> m: say ‘hello’

[14:53] <evalable> AlexDaniel: |«HEAD»: hello

[14:54] <AlexDaniel> that's gonna be a bit easier now ;)

[14:54] <P6fr> :D

[14:54] <P6fr> hi AlexDaniel 

[14:54] <AlexDaniel> kick evalable from the channel when camelia comes back

[15:00] *** colomon joined
[15:00] <dalek> bisectbot: e17c571 | (Aleks-Daniel Jakimenko-Aleksejev)++ | Perl6IRCBotable.pm:

[15:00] <dalek> bisectbot: Disable colors in error messages

[15:00] <dalek> bisectbot: 

[15:00] <dalek> bisectbot: We can replace terminal colors with something sensible, but the problem is that

[15:00] <dalek> bisectbot: it is not going to work so well for gists. At the time we execute something,

[15:00] <dalek> bisectbot: there is no way to know if we are going to gist it or not. It seems like

[15:00] <dalek> bisectbot: there's no easy way to have a cake and eat it.

[15:00] <dalek> bisectbot: review: https://github.com/perl6/bisectbot/commit/e17c571336

[15:00] <dalek> doc: b1e3270 | (Wenzel P. P. Peppmeyer)++ | doc/Type/Any.pod6:

[15:00] <dalek> doc: make it clear that flat doesn't recurse and show how to do that

[15:00] <dalek> doc: review: https://github.com/perl6/doc/commit/b1e3270b5c

[15:01] *** RabidGravy joined
[15:01] <P6fr> what is difference between List and Seq ?

[15:03] <sena_kun> P6fr, docs? https://docs.perl6.org/language/list.html - there is a good description.

[15:04] *** colomon left
[15:04] <AlexDaniel> wow, indeed

[15:04] <AlexDaniel> great page

[15:05] *** kaare_ left
[15:11] *** holyghost joined
[15:11] *** kaare_ joined
[15:12] *** canopus left
[15:15] *** espadrine joined
[15:17] *** canopus joined
[15:20] *** mns` joined
[15:21] *** kaare__ joined
[15:21] *** mns` left
[15:23] *** kaare_ left
[15:29] *** pmurias joined
[15:29] <pmurias> hi

[15:30] <holyghost> hello

[15:31] <gfldex> m: my $s = "I \x[2665] Perl 6!";

[15:31] <evalable> gfldex: |«HEAD»: 

[15:31] <gfldex> m: my $s = "I \x[2665] Perl 6!"; dd $s;

[15:31] <evalable> gfldex: |«HEAD»: Str $s = "I ♥ Perl 6!"

[15:31] *** sjoshi joined
[15:32] *** skrhn left
[15:34] <gfldex> m: my $s = "I really \x[2661,2665,2764,1f495] Perl 6!"; dd $s;

[15:34] <evalable> gfldex: |«HEAD»: Str $s = "I really ♡♥❤💕 Perl 6!"

[15:34] *** sjoshi left
[15:35] *** rx joined
[15:35] *** P6fr left
[15:35] <rx> hi guyd

[15:35] <rx> guys*

[15:38] <tbrowder> sena_kun: duh, thanks! is that from the .tell comments i see?

[15:39] <tbrowder> sena_kun: duh, thanks! is that from the .tell comments i see? [Read The Fine Msg!!]

[15:39] * TimToady home again from Rome

[15:39] <yoleaux> 22 Jul 2016 14:48Z <gfldex> TimToady: your judgment on `my Int:D $i = Nil` and `sub f(-->Int:D){Nil}` is required

[15:40] <sena_kun> tbrowder, yes. One of the yoleaux purposes is to deliver messages to people who are not online *right now*, but will be here in the future. http://dpk.io/yoleaux - here is a link to common commands.

[15:41] *** dainis left
[15:42] <gfldex> what is the syntax for having \-interpolation of unicode names?

[15:43] <AlexDaniel> m: say “hello \c[PILE OF POO]”

[15:43] <evalable> AlexDaniel: |«HEAD»: hello 💩

[15:43] <gfldex> thanks

[15:44] <gfldex> m: my $s = "Camelia \u[BROKEN HEART] my \u[HEAVY BLACK HEART]!"; dd $s;

[15:44] <evalable> gfldex: https://gist.github.com/1ba2142a4cf370f37b7f12be165fc897

[15:45] <tbrowder> sena_kun: so any way to tell who to reply to?  or how does one properly answer something from yoleaux when the sender is unknown?

[15:45] <gfldex> m: my $s = "Camelia \c[BROKEN HEART] my \c[HEAVY BLACK HEART]!"; dd $s;

[15:45] <evalable> gfldex: |«HEAD»: Str $s = "Camelia 💔 my ❤!"

[15:45] *** rx left
[15:46] <sena_kun> sena_kun, yoleaux writes sender of message, just like above: time <$nickname-of-sender> $receiver: $message(maybe my formatting is bad, but I hope it's easy to understand). So you can see who is sender and use it in your own query.

[15:47] <dalek> doc: af84958 | (Wenzel P. P. Peppmeyer)++ | doc/Language/quoting.pod6:

[15:47] <dalek> doc: show how to interpolate with unicode

[15:47] <dalek> doc: review: https://github.com/perl6/doc/commit/af84958715

[15:47] <sena_kun> Ah.

[15:48] <sena_kun> tbrowder, my message before last~

[15:50] <tbrowder> okay, it looked like it was "<unmatched>" but it seems to be zoffix up to  his old alias trick to confuse old people <unmatched}>

[15:51] <tbrowder> .tell $unmatched} is that you, Zoffix?

[15:51] <yoleaux> tbrowder: What kind of a name is "$unmatched}"?!

[15:51] <AlexDaniel> without $

[15:51] <tbrowder> .tell unmatched} is that you, Zoffix?

[15:51] <yoleaux> tbrowder: I'll pass your message to unmatched}.

[15:52] <AlexDaniel> yeah, it's pretty hard to .tell him something because of his constant nick changes

[15:52] *** harmil joined
[15:52] <AlexDaniel> 💔 is a very cool symbol by the way

[15:53] <sena_kun> Ah, sorry. I meant "$" symbol just as a sigil to show it's a "variable", for actual command it doesn't needed.

[15:54] *** darutoko joined
[15:55] <harmil> This code segfaults my older star release, would someone mind testing it on a newer one? Prints about 1100 lines then segvs. $ perl6 -e 'for 0..0xffff -> $i { say $i; my $c = try { :16(uniprop($i.chr, "Bidi_Mirroring_Glyph")).chr }; say "{$i.fmt("%04x")}: {$i.chr} ~ $c" if $c.defined}'

[15:55] *** pierrot_ is now known as pierrot

[15:55] <harmil> Didn't want to crash the IRC bot...

[15:56] <harmil> or is a fresh interpreter run for each bot command?

[15:56] *** dainis joined
[15:56] <AlexDaniel> yes

[15:56] <harmil> oh, cool

[15:56] <AlexDaniel> m: for 0..0xffff -> $i { say $i; my $c = try { :16(uniprop($i.chr, "Bidi_Mirroring_Glyph")).chr }; say "{$i.fmt("%04x")}: {$i.chr} ~ $c" if $c.defined}

[15:56] <evalable> AlexDaniel: https://gist.github.com/9f52f2a53e11a4d9519e5cf203e3b714

[15:56] <tbrowder> .tell unmatched} I'm aware of the problem, and I hope to work on it after I get the basic table working and accepted first. At the moment I don't know if that will require grammar work or not. I don't have the knowledge or experience enough yet to dig into the grammar and actions, but ShimmerFairy does.  I will try an experiment later today which I hope will

[15:56] <tbrowder> show me whether or not it requires grammar work.

[15:56] <yoleaux> tbrowder: I'll pass your message to unmatched}.

[15:57] <AlexDaniel> m: for 0..0xffff -> $i { say $i; my $c = try { :16(uniprop($i.chr, "Bidi_Mirroring_Glyph")).chr }; say "{$i.fmt("%04x")}: {$i.chr} ~ $c" if $c.defined}

[15:57] <evalable> AlexDaniel: https://gist.github.com/feaab41c4c66bf8933d364f3f820754f

[15:57] <harmil> m: for 0..0xffff -> $i { my $c = try { :16(uniprop($i.chr, "Bidi_Mirroring_Glyph")).chr }; say "{$i.fmt("%04x")}: {$i.chr} ~ $c" if $c.defined}

[15:57] <evalable> harmil: |«HEAD»: 

[15:57] *** cyphase left
[15:57] <AlexDaniel> ok, so it does segfault

[15:58] <harmil> It's failing in a strange way. I would have expected that say to have output a few matches.

[15:58] <tbrowder> thnx for the yoleaux lessons, sena_kun and AlexDaniel! 

[16:00] *** iH2O joined
[16:00] <harmil> BTW: I have to say I discovered accidentally and absolutely LOVE that "" works inside of {} inside of ""!

[16:01] *** cyphase joined
[16:01] <harmil> I'll bug the above

[16:01] <sena_kun> tbrowder, no problem.

[16:03] *** pmurias left
[16:04] <TimToady> harmil: that's due to our strict one-pass policy; we never look for the closing delim and rescan

[16:05] <gfldex> TimToady++ # for https://www.youtube.com/watch?v=BJIfPFpaMRI

[16:06] *** holyghost left
[16:06] *** cdg joined
[16:06] <harmil> TimToady: When I wote "{$i.fmt("%04x")}" I didn't even think about whether or not it would work, it just did. I think that really speaks to Perl 6's MO.

[16:07] <kalkin-> Hmm i can't figure out how to make use of EVAL so that i keep some kind of context

[16:07] <TimToady> another way to state it is that we always know exactly which language we're parsing at each point

[16:07] *** Gothmog_ joined
[16:08] *** jmiven joined
[16:08] *** dainis left
[16:09] <kalkin-> I looked at the repl implementation in rakudo, but it uses a lot of nqp and it somehow works differently (or I don't understand it fully)

[16:10] <TimToady> afaik, it's still uses nested lexical scopes to emulate progress through a single lexical scope, which is a bit problematic in some ways

[16:10] <kalkin-> I'm not sure if I fully understand what I need to do, but I try to sum up: I need to find a way to merge the lexical scope of an EVAL execution with the outside lexical scope. (Right?)

[16:11] <TimToady> sounds about right

[16:12] <TimToady> if the transactional support was there for it, we could even undo multiple statements

[16:12] <mst> TimToady: if you want to see something really funny, look at my Eval::WithLexicals ;)

[16:12] <AlexDaniel> m: say “\c[SHRUG]”

[16:12] <evalable> AlexDaniel: |«HEAD»: ===SORRY!=== Error while compiling /tmp/_RngWLbH53␤Unrecognized character name SHRUG␤at /tmp/_RngWLbH53:1␤------> say “\c[SHRUG<HERE>]” exit code = 1

[16:13] <TimToady> mst: I'm not sure my jet-lagged brane would survive that

[16:14] <mst> TimToady: oh, it's easy, just a coderef in @INC, a source filter, and B.pm ;)

[16:14] <mst> (what it lacks in sanity it makes up for by providing a persistent lexical env while not requiring non-core XS ;)

[16:14] <kalkin-> How do I get all variables of the current lexical scope?

[16:16] <moritz> kalkin-: MY:: or so

[16:16] <TimToady> m: say MY::.keys

[16:16] <evalable> TimToady: |«HEAD»: ($=pod !UNIT_MARKER EXPORT $_ $! ::?PACKAGE GLOBALish $¢ $=finish $/ $?PACKAGE)

[16:17] <kalkin-> moritz & TimToady: awesome thanks

[16:18] *** AndyBotwin joined
[16:19] *** iH2O left
[16:26] *** Tonik left
[16:28] *** holyghost joined
[16:28] *** holyghost left
[16:30] *** holyghost joined
[16:32] *** holyghost left
[16:33] <timotimo> where are my goddarned kexs!?

[16:33] <timotimo> keys, duh

[16:36] *** Guest66 joined
[16:40] *** bob777 left
[16:41] *** bob777 joined
[16:42] <moritz> timotimo: check your keyboard :-)

[16:48] <harmil> moritz: or under the cat

[16:48] <harmil> Which, in many cases is isomorphic to checking the keyboard.

[16:51] *** kurahaupo left
[16:51] *** kaare_ joined
[16:54] *** adu joined
[16:55] *** kaare__ left
[16:56] *** kid51 joined
[16:56] *** aindilis joined
[16:57] *** kid51 left
[16:58] *** adu left
[17:00] *** domidumont joined
[17:03] *** holyghost joined
[17:07] <kalkin-> I try to read only one character from $*IN, but it always waits for me pressing enter or CTRL+D. I tried `$*IN.getc` and `$*IN.readchars(1)` but both waits for me pressing enter

[17:09] *** sena_kun left
[17:10] *** holyghost left
[17:12] *** holyghost joined
[17:15] <kalkin-> How do I get one char from the STDIN in real time without waiting for user pressing enter

[17:17] <holyghost> while (<STDIN>) last;

[17:17] <holyghost> etc

[17:18] <moritz> m: say $*IN.readchars(1)

[17:18] <evalable> moritz: |«HEAD»: 

[17:19] <moritz> no, still waits for enter

[17:19] *** zacts joined
[17:19] *** adu joined
[17:20] <moritz> even getc waits :(

[17:21] <AlexDaniel> moritz: nothing in stdin on evalable :)

[17:21] <kalkin-> holyghost: I'm not sure what is happening there. 

[17:24] <kalkin-> Also it says i should use $*IN.lines or add whitespace to sppress warning

[17:24] <kalkin-> but where should i add whitespace?

[17:26] <AlexDaniel> kalkin-: what's in your code exactly?

[17:27] <kalkin-> ok i figured this at least doesn't throw errors while (< STDIN>) { last };

[17:28] <kalkin-> i think i figured it out

[17:29] *** wamba joined
[17:31] <kalkin-> ok so I have my while (< STDIN>) loop but $_ is Any instead of being a Str and is called the whole time over and over 

[17:31] <kalkin-> how do i access the characters?

[17:31] <kalkin-> or bytes

[17:31] <kalkin-> something :)

[17:33] <holyghost> <STDIN> can get your file `cat`ted as input,

[17:34] <arnsholt> To read character by character, you need to twiddle the buffering of the filehandle you're reading from

[17:35] <arnsholt> Not sure if (and if so how) that's exposed in Perl 6

[17:35] <arnsholt> By default, stdin is line-buffered

[17:35] <holyghost> just do a string match on $_

[17:35] <holyghost> $_[0] should be right

[17:36] <holyghost> so while (<STDIN>) { print $_[0]; last; }; 1;

[17:36] <holyghost> AFAIK :-)

[17:37] <holyghost> if you want to know, $_ is a metasyntactic variable

[17:37] <holyghost> search on it in google or something

[17:37] *** Guest66 left
[17:37] <kalkin-> holyghost: no this doesn't work. because $_[0] is Any even before i have a change to enter anything

[17:38] <kalkin-> s/change/chance/g

[17:38] <holyghost> try print Str $_[0] ?

[17:39] <holyghost> or $_.Str or something

[17:39] <kalkin-> $_ uninitialized value in string context

[17:39] <kalkin-> I think i can't create a Str from Any

[17:39] *** Guest66 joined
[17:40] <holyghost> WAM

[17:41] <kalkin-> ?

[17:42] <mst> warren abstract machine?

[17:42] <mst> no, this is #perl6, not ##prolog

[17:44] <kalkin-> hmm i figured how i can do this in zsh while read -sk 1 a; do printf %s "$a"; done

[17:44] <holyghost> you can do it in awk also if you like

[17:45] <holyghost> WAM == wait a minute

[17:45] <ugexe> next unless $_.?chars;

[17:45] <holyghost> <STDIN> in unsupported, sorry my mistake it seems

[17:46] <kalkin-> i figured you can just do < STDIN> to supress it :)

[17:46] <holyghost> I am still learning 6 :-)

[17:48] <holyghost> s/6/perl 6/

[17:50] *** GNUYawk joined
[17:51] <GNUYawk> i had they’re making a ruby6 to compete with perl6

[17:51] *** domidumont left
[17:52] <ugexe> that pretty much exists already under the name perl6

[17:53] <geekosaur> I thought it existed under the name smalltalk >.>

[17:53] *** skrhn joined
[17:54] <skrhn> How would I do this? 

[17:54] <skrhn> m: my Int @a := 1..50;

[17:54] <evalable> skrhn: |«HEAD»: Type check failed in binding; expected Positional[Int] but got Range (1..50)␤  in block <unit> at /tmp/I3dyumCPSK line 1␤ exit code = 1

[17:54] <GNUYawk> ugexe: but is it true

[18:00] <skrhn> m: my Int @a = 1..50 # works

[18:00] <evalable> skrhn: |«HEAD»: 

[18:00] *** zacts left
[18:03] *** cosimo joined
[18:06] *** skrhn left
[18:15] *** kid51 joined
[18:15] *** khw joined
[18:15] <cognominal> jnthn++ # gut-blog

[18:15] <yoleaux> 22 Jul 2016 14:11Z <Ven> cognominal: https://medium.com/@octskyward/graal-truffle-134d8f28fb69 thought about you :)

[18:17] *** espadrine left
[18:21] *** Guest66 left
[18:25] <harmil> m: [**] lazy 3,3,3

[18:25] <evalable> harmil: |«HEAD»: Cannot reverse a lazy list␤  in block <unit> at /tmp/sAUhGbog8P line 1␤␤Actually thrown at:␤  in block <unit> at /tmp/sAUhGbog8P line 1␤ exit code = 1

[18:25] <harmil> That seems somewhat hostile...

[18:25] <TimToady> lazy is a proxy for probably infinite

[18:25] <TimToady> m: [**] eager lazy 3,3,3

[18:25] <evalable> TimToady: |«HEAD»: 

[18:25] <TimToady> m: say [**] eager lazy 3,3,3

[18:26] <evalable> TimToady: |«HEAD»: 7625597484987

[18:26] *** colomon joined
[18:27] <TimToady> and arguably, there aren't that many right-associative operators you want to reduce with anyway

[18:28] <TimToady> but maybe we could throw an eager in there somewhere

[18:29] *** girafe left
[18:29] <TimToady> maybe the error message is LTA, though, it could at least suggest eager

[18:31] <harmil> Well, I suppose it's the only operator you're likely to do that with. I'm still questioning the hilarity of [=]...

[18:31] *** adu left
[18:31] *** girafe joined
[18:34] *** colomon left
[18:40] *** awwaiid joined
[18:43] <timotimo> i liked your keynote alot, TimToady

[18:44] <jdv79> is it easy to find?

[18:44] <timotimo> in order to appreciate p6 you sometimes need to look at its features and realize how few languages have 'em

[18:44] *** parabolize joined
[18:45] <timotimo> curry on larry wall in youtube search ought to do it

[18:45] <jdv79> that requires that you know a lot of different langs decently well

[18:45] <jdv79> 53:58?

[18:46] *** adu joined
[18:49] <harmil> Is there a better way to say "\\c[{$i.fmt("%x")}]".EVAL

[18:50] <harmil> I can't find a uni* function for going from the name to the character or codepoint.

[18:51] <harmil> er, I just mixed two very different bits of code, sorry. I meant "\\c[$name]".EVAL

[18:51] <timotimo> i wished for that function before

[18:51] <AlexDaniel> what a good question

[18:51] <timotimo> i exposed the nqp op for the lookup i think

[18:51] <timotimo> but i didnt want to decide on the p6 function name

[18:52] <AlexDaniel> harmil: rakudobug it

[18:53] <harmil> okay

[18:53] <AlexDaniel> m: say “\c[PILE OF POO]”.uniname

[18:53] <evalable> AlexDaniel: |«HEAD»: PILE OF POO

[18:54] *** autarch joined
[18:55] <timotimo> codepointffromname

[18:55] <timotimo> is the name of tge nqp op

[18:55] <timotimo> one less f

[18:57] <harmil> bugged

[18:57] <timotimo> hm?

[18:57] <harmil> I sent it to the bug address

[18:57] <harmil> m: my $name = "COMMA"; say "char: qq\{\\c[$name]}".EVAL

[18:57] <evalable> harmil: |«HEAD»: ,

[18:58] <timotimo> ah

[18:58] <harmil> m: my $name = "COMMA"; say "qq\{\\c[$name]}".EVAL

[18:58] <evalable> harmil: |«HEAD»: ,

[18:58] <timotimo> we usually write "rakudobugged" for that

[18:58] <harmil> Yeah, that's it.

[18:58] <harmil> rakudobugged :)

[18:58] <AlexDaniel> m: use MONKEY-GUTS; say nqp::codepointfromname(“\c[PILE OF POO]”.uniname).chr

[18:58] <evalable> AlexDaniel: |«HEAD»: 💩

[18:58] <timotimo> bugged sounds like its short for "that's bugged"

[18:59] <timotimo> ad, without the \c

[18:59] *** domidumont joined
[19:00] <timotimo> i dont habe a proper keyboard here

[19:00] <timotimo> AlexDaniel: ∆

[19:02] *** lucastheisen joined
[19:03] <lucastheisen> has anyone been able to compile for cygwin since 2.5 when they implemented pthread_barrier?

[19:08] *** GNUYawk left
[19:12] *** GNUYawk joined
[19:19] *** trnh joined
[19:22] *** adu left
[19:22] *** kaare__ joined
[19:25] *** adu joined
[19:25] *** kaare_ left
[19:30] *** holyghost left
[19:34] *** BenGoldberg joined
[19:35] <BenGoldberg> m: my \c = $(42); say c++;

[19:35] <evalable> BenGoldberg: https://gist.github.com/304125b6f17439878144906d2e3e8723

[19:36] <BenGoldberg> m: my \c = $(42); say c;

[19:36] <evalable> BenGoldberg: |«HEAD»: 42

[19:36] <BenGoldberg> m: my \c = $(42); say c = 7;

[19:36] <evalable> BenGoldberg: |«HEAD»: Cannot modify an immutable Int␤  in block <unit> at /tmp/wEHD3cvnNM line 1␤ exit code = 1

[19:37] <BenGoldberg> m: my \c = $ = 42; say c = 7;

[19:37] <evalable> BenGoldberg: |«HEAD»: 7

[19:37] <BenGoldberg> m: my \c = $ = 42; say c++;

[19:37] <evalable> BenGoldberg: |«HEAD»: 42

[19:37] <BenGoldberg> m: my \c = $ = 42; say ++c;

[19:37] *** BenGoldberg left
[19:37] <evalable> BenGoldberg: |«HEAD»: 43

[19:40] *** trnh left
[19:42] *** domidumont left
[19:43] *** pmqs left
[19:43] *** trnh joined
[19:43] <timotimo> wtf?

[19:43] *** labster joined
[19:44] *** kaare__ left
[19:46] *** kaare__ joined
[19:47] <geekosaur> has anyone actually gone to #freenode and asked why sigyn is killing both legitimate bots and legitimate users thereof?

[19:47] <harmil> Freenode doesn

[19:47] <harmil> doesn''t parse Perl6 :)

[19:48] <TimToady> maybe it's a python bot waging war :)

[19:48] <mst> geekosaur: no, nobody bothered telling me, your freenode staff contact, either

[19:48] <mst> fortunately, I just noticed it in backlog

[19:48] <mst> camelia and nine are un-k-lined

[19:49] <harmil> mst++

[19:49] <mst> as now is bengoldberg

[19:51] <mst> and that's the antispam bot out until we can reconfigure it

[19:52] *** Tonik joined
[19:54] *** pmqs joined
[19:56] *** darutoko left
[20:04] *** colomon joined
[20:06] *** Tonik left
[20:08] *** RabidGravy left
[20:09] *** colomon left
[20:12] *** jersni joined
[20:15] *** jersni left
[20:16] *** trnh left
[20:20] *** Sgeo_ joined
[20:21] *** lucastheisen left
[20:23] *** adu left
[20:24] *** Sgeo left
[20:25] *** Sgeo_ left
[20:25] *** Sgeo joined
[20:26] *** camelia joined
[20:27] <moritz> m: say 42

[20:27] <evalable> moritz: |«HEAD»: 42

[20:27] *** ChanServ sets mode: +v camelia

[20:27] <camelia> rakudo-moar 78915a: OUTPUT«42␤»

[20:28] <AlexDaniel> \o/

[20:28] <lizmat> moritz++

[20:28] *** evalable left
[20:28] <moritz> mst++

[20:28] <AlexDaniel> bye-bye evalable

[20:28] <mst> see how much quicker these thing go when you actually bother telling your IRC contact? :)

[20:29] <lizmat> :-)

[20:29] <mst> sorry. this is my "damnit, I hate it when people don't report bugs" sarcasm coming out :P

[20:29] <mst> moritz: thanks for bringing 'er back up

[20:30] <mst> next time, gimme a shout if you have to turn 'er off :)

[20:30] <lizmat> mst: we know how to find you for these things now  :-)

[20:31] <mst> I'm group contact. when I first became group contact, I explained in here at length that that meant I was the person to come to for IRC stuff.

[20:31] <lizmat> mst: fwiw, I must have missed that  :-(

[20:32] <mst> I /msg-ed the various ops of here as well

[20:32] <mst> moritz was notified to report any problems to me on Feb 27, and thanked me for telling him

[20:32] *** trnh joined
[20:32] *** trnh left
[20:32] *** trnh joined
[20:32] <mst> apparently everybody forgot :(

[20:33] <lizmat> mst: it's just one of those things when everything is always running smoothly

[20:33] <TimToady> mst: you're so unmemorable :P

[20:33] <lizmat> you forget what you had to do to fix things

[20:33] *** BenGoldberg joined
[20:33] <lizmat> unused skills disappear

[20:33] <mst> TimToady: maybe I should try growing an insane moustache

[20:34] <AlexDaniel> mst: you sound like something tragic happened :)

[20:34] <lizmat> .oO( would be cool for Movember )

[20:34] <AlexDaniel> camelia was on her little vacation

[20:34] <harmil> Relevant to a reddit discussion, will reduction ops (e.g. [*]) be auto-concurrencied once that's in or just listish hyperops?

[20:34] <AlexDaniel> and evalable did OK job while she was offline

[20:34] <mst> AlexDaniel: which meant nine was K-lined

[20:34] <mst> and then because it wasn't reported, BenGoldberg also got K-lined

[20:35] <AlexDaniel> well…

[20:35] <mst> how many regulars/contributors need to get screwed over before you start caring?

[20:35] <mst> I prefer fixing things at zero :P

[20:35] <harmil> BTW: I sent BenGoldberg some mail letting him know the situation.

[20:35] <AlexDaniel> ok good point

[20:35] * BenGoldberg goes off to check his email ... :)

[20:35] <harmil> Ha!

[20:35] <harmil> BenGoldberg: I missed that you'd come back

[20:36] <BenGoldberg> :)

[20:36] <mst> and it only got fixed now because I spotted somebody saying 'antispam' in #perl6-dev and went "wait, hang on"

[20:36] <mst> I would prefer to not have to rely on my "this is an unreported bug" spidey sense to fix things with minimum collateral damage

[20:37] <AlexDaniel> spidey sense :D

[20:38] <mst> I've been doing this somewhere over ten years. things ... smell wrong ... sometimes

[20:38] <lizmat> .oO( a disturbance in the force )

[20:39] <mst> if I could write down the decision making algorith, I'd've uploaded it to cpan already ;)

[20:39] <AlexDaniel> by the way, jnthn++ for fixing this nasty string bug

[20:40] <AlexDaniel> mst: by the way, is there somebody else we can contact if you are offline?

[20:40] <mst> well, for a k-line, you email [email@hidden.address]
[20:41] <mst> if the weather has turned cloudly with showers of fuckwittery, poke #freenode for an active staffer if there's no chanops around

[20:41] *** zacts joined
[20:42] *** labster left
[20:42] <geekosaur> I had missed the announcement in here as well, but also I'm not a channel operator or etc. (otoh I was also being a bit snarky when I asked if anyone had thought to say something...)

[20:43] *** kaare__ left
[20:44] *** skrhn joined
[20:44] <mst> geekosaur: yeah, well, apparently you were right :P

[20:44] <mst> and as the only person who apparently even thought about it, I'm hereby making you responsible as well

[20:45] *** CIAvash left
[20:45] <mst> also, now you totally are a channel operator

[20:45] <mst> geekosaur++ # well volunteered

[20:45] <zacts> wait, so is much of Perl6 implemented in Perl6?

[20:45] <skrhn> Newbie Channels question: https://gist.github.com/skrisna/8c8dd495952d8beb0642531442898331 hangs

[20:45] <geekosaur> zacts, large chunks of it, yes

[20:45] <zacts> ok cool

[20:46] <zacts> cool

[20:46] <zacts> yeah, this Perl6 seems pretty sweet

[20:47] *** espadrine joined
[20:47] <zacts> I still wonder if I should brush up on my Perl5 skills before teaching myself Perl6

[20:47] <zacts> or if I can just dive in, coming from Ruby

[20:48] <geekosaur> enough is different from perl5 that you'd just have to unlearn a bunch of it :)

[20:48] <skrhn> zacts: suggest you forget perl5 .. it will just confuse you more

[20:48] <zacts> I don't have any professional Perl5 I have to do now, and it's just a hobby currently

[20:48] <gfldex> zacts: you will likely confuse yourself when dealing with Perl 5 and Perl 6 at the same time

[20:48] <zacts> ok

[20:48] <zacts> I think I might just dive-in and see how far I get

[20:49] <skrhn> zacts: I am a perl5 programmer just starting out with perl6. I would suggest http://www.jnthn.net/papers/2015-spw-perl6-course.pdf

[20:50] <zacts> cool thanks skrhn 

[20:50] <skrhn> then perl6intro

[20:50] <zacts> ok

[20:51] <skrhn> but the course does not teach concurrency, etc

[20:52] <zacts> ok

[20:52] <zacts> cool

[20:54] <AlexDaniel> zacts: have you seen this? https://docs.perl6.org/language/rb-nutshell

[20:58] <lizmat> hmmm.... jnthn blogged: https://6guts.wordpress.com/2016/07/23/assorted-fixes/

[21:13] <zacts> AlexDaniel: indeed I have, but I still have yet to fully read it

[21:13] *** labster joined
[21:13] <zacts> it looks cool

[21:15] *** paraboli` joined
[21:15] *** wamba left
[21:15] *** parabolize left
[21:16] *** setty2 joined
[21:16] *** rindolf left
[21:16] *** tinita left
[21:16] *** tinita joined
[21:17] *** dvinciguerra_ joined
[21:17] *** cyphase left
[21:17] *** TimToady left
[21:17] *** TimToady joined
[21:17] *** setty1 left
[21:17] *** setty2 is now known as setty1

[21:19] *** zacts left
[21:20] *** cyphase joined
[21:25] *** rindolf joined
[21:27] *** RabidGravy joined
[21:29] *** solarbunny left
[21:29] *** rindolf left
[21:32] *** GNUYawk left
[21:34] *** trnh left
[21:35] *** solarbunny joined
[21:37] *** ufobat left
[21:41] *** woolfy joined
[21:43] <woolfy> What a nice surprise. :-)  http://www.wendy.org/O'Reilly%20Publishers/Programming%20Perl%206%20for%20the%20Impatient/Programming%20Perl%206%20for%20the%20Impatient.png

[21:46] <lizmat> :-)

[21:48] <woolfy> (yeah, I know, a bit lame)

[21:52] *** skrhn left
[21:54] <gfldex> m: my Int:D @a; @a[0,1] = 1,1; @a[1] = Nil; @a[0]:delete; dd @a;

[21:54] <camelia> rakudo-moar 1724f8: OUTPUT«Array[Int:D] @a = Array[Int:D].new(Int:D, Int:D)␤»

[21:54] <gfldex> i'm not as happy as those Ints

[21:54] <gfldex> m: my Int:D @a; @a[0,1] = 1,1; @a[1] = Nil; @a[0]:delete; dd @a, @a.WHAT;

[21:54] <camelia> rakudo-moar 1724f8: OUTPUT«Array[Int:D] @a = Array[Int:D].new(Int:D, Int:D)␤Cannot look up attributes in a type object␤  in block <unit> at <tmp> line 1␤␤»

[21:56] <lizmat> gfldex: the error is a dd artefact, no ?

[21:56] <gfldex> m: my Int:D @a; dd @a.WHAT;

[21:56] <camelia> rakudo-moar 1724f8: OUTPUT«Cannot look up attributes in a type object␤  in block <unit> at <tmp> line 1␤␤»

[21:56] <gfldex> m: my Int:D @a; dd @a[0].WHAT ~~ Int:D;

[21:56] <camelia> rakudo-moar 1724f8: OUTPUT«Bool::False␤»

[21:57] <gfldex> m: my Int:D @a; dd @a[0] ~~ Int:D;

[21:57] <camelia> rakudo-moar 1724f8: OUTPUT«Bool::False␤»

[21:57] <gfldex> m: my Int:D @a; dd @a[0].WHAT =:= Int:D;

[21:57] <camelia> rakudo-moar 1724f8: OUTPUT«Bool::True␤»

[21:59] *** dvinciguerra_ left
[22:00] *** froobar joined
[22:00] *** TEttinger left
[22:01] *** trnh joined
[22:03] *** kurahaupo joined
[22:03] *** kurahaupo left
[22:04] *** kurahaupo joined
[22:04] *** setty1 left
[22:05] *** TEttinger joined
[22:08] *** s34n joined
[22:08] <s34n> hello

[22:08] *** kurahaupo left
[22:09] <lizmat> hello s34n 

[22:09] <s34n> I'm browsing perl6, trying to learn a little at a time. Today, I was looking at grammars and specifically reading http://stackoverflow.com/questions/18561179/example-of-perl-6-grammar-with-operator-precedence-rules

[22:10] <s34n> I was hoping that somebody would be kind enough to answer very newbie questions about perl6 syntax

[22:10] *** espadrine left
[22:11] *** kurahaupo joined
[22:11] <s34n> for instance, what does <expr=.add> mean?

[22:12] <s34n> ah. <> means a named subrule?

[22:15] *** pmurias joined
[22:16] <s34n> so <expr=add> will match a subrule named 'expr' into a capture called 'add', right?

[22:16] <s34n> so what does the '.' do?

[22:17] <s34n> and where is expr defined?

[22:19] *** spider-mario left
[22:19] *** GNUYawk joined
[22:21] <s34n> oh. I got it backwards. 'expr' is the name of the capture. '.add' is the subrule

[22:22] <pmurias> lizmat: I implemented nqp::readcharfh on the JVM (and JS) as requested by that old nqp ticket (found that while going through the nqp for things to close). I'm not touching Parrot ;)

[22:22] <lizmat> pmurias++

[22:23] <s34n> the '.' just means that the subrule is a 'sibling method' on the same grammar?

[22:25] *** spider-mario joined
[22:25] <s34n> did I read that right?

[22:27] * lizmat draws a blank

[22:27] *** skrshn joined
[22:27] *** pmurias_ joined
[22:27] <s34n> lizmat: from me?

[22:27] *** pmurias left
[22:28] <lizmat> the period means something really simple, but I guess I'm too tired to remember what it was

[22:29] <lizmat> too deep in optimizing perl 6 settings  :-(

[22:31] <geekosaur> iirc it means don't also assign the result of parsing the add subrule to a capture named add

[22:31] <s34n> I'm guessing it means that the rule is defined as a rule in the current 'class'

[22:32] <s34n> geekosaur: oh.hmmm

[22:33] <s34n> <.name> means don't capture, so maybe so. but that seems to contradict renaming the capture...

[22:34] *** pmurias_ is now known as pmurias

[22:34] <s34n> geekosaur: what do you mean by 'also'? also, in addition to what?

[22:34] <geekosaur> it means don't put it in *both* captures, which it would otherwise do

[22:34] <geekosaur> hence the "also"

[22:34] <s34n> ah

[22:35] <s34n> oh. without the plus, the capture is stored under both keys?

[22:35] <s34n> s/plus/'.'/

[22:35] *** GNUYawk left
[22:37] <s34n> next question regards -> token mult-op:sym<times>   { <sym>|'*' }

[22:37] <s34n> what does :sym<times> mean?

[22:38] <geekosaur> that breaks up as token class mult-op, token type sym (symbol), token name "times"

[22:39] <s34n> sym is a type?

[22:40] <geekosaur> um, no, these are grammatical categories, not types as in the type system

[22:42] <s34n> geekosaur: I'm still lost

[22:43] <s34n> <times> looks like the named subrule idea again

[22:43] <geekosaur> insofar as these definitions are concerned, I think it's just a way to group related tokens together. so any token that acts as a mult-op gets the prefix `mult-op:`; `sym` is any token that is a symbol (vs. a term or various other things), and the thing in the brackets is the actual name

[22:43] <geekosaur> (I assume from context that mult-op means a multiplication operator)

[22:44] <geekosaur> http://design.perl6.org/S02.html#Grammatical_Categories is the relevant part of the design documents

[22:48] <s34n> geekosaur: here's a restatement that works in my brain: this declares a regex (token) named 'times' that is of 'type' mult-op.

[22:48] <s34n> is that close?

[22:48] <geekosaur> not really, since the category isn't actually used for anything. it's just a way to structure names that are used in similar ways

[22:49] <s34n> so anywhere we say <mult-op> it will do [<times> | <divided>] ? kinda?

[22:49] <geekosaur> in particular I don't think the grammar stuff is smart enough to automatically define a rule `term` that tries any token named `term:<whatever>`

[22:52] <s34n> geekosaur: I see in the lines above, rule multiply { <digit> +%  [ <mult-op> ] }    where <mult-op> is wrapped in [] for grouping

[22:52] <s34n> why does it need to be grouped?

[22:53] <TimToady> I believe as currently implemented you must define a proto token mult-op to get the ability to call the alternation as <mult-op>

[22:54] <s34n> TimToady: they have a proto token mult-op

[22:55] <TimToady> then it's just an extensible alternation

[22:55] *** andrzejku left
[22:56] <s34n> do mult-op is an alternation, right? that's why it needs [ ] ?

[22:56] <s34n> s/do/so/

[22:56] *** pmqs left
[22:56] <TimToady> you can have normal alternations inside a proto alternation

[22:56] <s34n> is sym a reseved word in perl6?

[22:56] <TimToady> if they're at the top level, it's as if you defined two multis

[22:57] <TimToady> all the LTM is transitive on the prefix, anyway

[22:57] <s34n> TimToady: sorry. I didn't understand 'LTM', 'transitive', or 'prefix'

[22:57] <TimToady> sym is specially recognized, if that's what you mean

[22:58] <TimToady> mostly it defines <sym> inside so you don't have to repeat yourself

[22:58] <s34n> yes. that's what I meant.

[22:58] <TimToady> but also makes the symbol available for operator construction, say

[22:59] <s34n> so sym<times> turns 'times' into a symbol?

[22:59] <TimToady> only if the action does something with it, which infix et all do

[23:00] <TimToady> but sym is automatically available in the AST, so it's pretty handy

[23:00] <s34n> so it's a symbol just within the {} that follows?

[23:00] <dalek> bisectbot: 1182968 | (Daniel Green)++ | / (4 files):

[23:00] <dalek> bisectbot: Add support for timing out the bots

[23:00] <dalek> bisectbot: review: https://github.com/perl6/bisectbot/commit/1182968278

[23:01] <TimToady> if you match it with <sym> it persists in the resulting match object, which the action method may turn into something else

[23:02] <TimToady> though more typically the action method is also differentiated with :sym<foo>

[23:03] <TimToady> grep '\<sym\>' src/Perl6/Actions.nqp to see it all in action (pun intented)

[23:03] *** pmurias left
[23:04] <s34n> could -> token mult-op:sym<times>   { <sym>|'*' }  <- be rewritten -> token mult-op { [times || '*']}        ?

[23:05] <TimToady> not really, in the latter case, the '*' would not participate in LTM

[23:05] <TimToady> you could use | there though instead

[23:06] <s34n> TimToady: what does 'LTM' mean?

[23:06] <TimToady> but also you wouldn't have $<sym> available to the action routine, so you'd have to do another string comparison against the whole match

[23:06] <TimToady> longest token matching

[23:08] <s34n> hmm. so <sym> is just a regular named subrule

[23:08] <s34n> ?

[23:08] <TimToady> transitive means that if a token calls another token it bubbles up into the whole list of tokens that it does LTM over

[23:08] <TimToady> yes, but automatically defined specially within the {}

[23:09] <dalek> doc: caa99e1 | (Wenzel P. P. Peppmeyer)++ | doc/Type/Range.pod6:

[23:09] <dalek> doc: Range and $-sigiled containers are slightly trappy

[23:09] <dalek> doc: review: https://github.com/perl6/doc/commit/caa99e1e8c

[23:09] <s34n> right. defined by the sym<times> thing preceding the {}, right?

[23:09] <TimToady> right

[23:10] <s34n> ok. so I get everything inside the {}

[23:10] <TimToady> it's just a convenience, since we want to use the identity of the operator anyway, might as well use the operator itself as a distinguishing part of the name

[23:10] <TimToady> and then why repeat ourselves to match it?

[23:11] *** pmqs joined
[23:11] <s34n> but how does sym<times> define sym? that's because 'sym' means something in perl? it lexically defines a symbol?

[23:11] <TimToady> basically, the built-in sym rule knows to look up the name of the current routine and pull out the symbol

[23:12] <TimToady> and since it's known at compile time, it could be treated as a literal match

[23:13] <TimToady> certainly it's treated sufficiently as a literal that we can let it participate in the lexer we automatically write for you

[23:15] *** spider-mario left
[23:15] <s34n> ok. I think the concept I'm missing here is prefixes

[23:15] <s34n> mult-op can be used as a prefix

[23:15] *** spider-mario joined
[23:15] <s34n> ?

[23:15] <TimToady> different meaning of prefix here, sorry

[23:15] *** trnh left
[23:16] <TimToady> I mean the set of all the longest tokens that could match at the current point in the puarse

[23:16] <TimToady> *parse

[23:17] <TimToady> every rule that participates in in the overall alternation at this point has a "prefix" that is declarational, and maybe the rest of the rule that does matching by more operational means

[23:17] *** labster left
[23:17] <s34n> I'm reading geekosaur's link and I see things like infix:<cmp>

[23:18] <TimToady> to the first approximation, the "prefix" I'm talking about is the front that can be matched by real regular expressions (in the technical sense)

[23:18] <s34n> so I need to understand something:else syntax

[23:19] <TimToady> you can extend any identifier using the pair notation if it follows without space

[23:19] <TimToady> m: my $foo:bar = 42; say $foo:bar

[23:19] <camelia> rakudo-moar 32c08b: OUTPUT«42␤»

[23:20] *** labster joined
[23:20] <TimToady> m: my $foo:bar<baz> = 42; say $foo:bar<baz>

[23:20] <camelia> rakudo-moar 32c08b: OUTPUT«42␤»

[23:20] <TimToady> but since that's a quoting form, you can sneak non-wordy characters in

[23:20] <TimToady> (as part of the identity of the, er, "identifier")

[23:22] <TimToady> we can use this for various things, depending on the key of the pair

[23:22] <TimToady> so there are things like infix:sym<cmp> that name a rule that will eventually result in an operator named infix:<cmp>

[23:22] <TimToady> but that's just convention

[23:23] <TimToady> other places we use the form: use Foo::Bar:from<Perl5>

[23:23] <gfldex> m: sub foo:bar(){};

[23:23] <camelia> rakudo-moar 32c08b: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Null operator is not allowed␤at <tmp>:1␤------> 3sub foo:bar()7⏏5{};␤»

[23:24] <gfldex> m: my &foo:bar = sub (){}; foo:bar;

[23:24] <camelia> rakudo-moar 32c08b: ( no output )

[23:24] <TimToady> m: sub foo:bar (){};

[23:24] <camelia> rakudo-moar 32c08b: ( no output )

[23:24] <TimToady> the pair will eat the () if it can

[23:25] <gfldex> TimToady: you just made a pretty big hole in docs.perl6.org visible

[23:25] *** spider-mario left
[23:25] <TimToady> yes, I'm not interested in culturally ruling out that space

[23:25] <TimToady> I don't really believe in necessarily making the call syntax look like the definition syntax

[23:26] <TimToady> similar things that are different should look a little different sometimes :)

[23:26] <gfldex> the space is not the hole part. We missed the whole foo:bar ordeal

[23:26] <TimToady> ah, yes, well, that's why we're doing documentation this year, among other things :)

[23:27] <s34n> I'm trying to catch up here. : with no spaces around it creates a 'pair'? 

[23:27] <jdv79> i thought it was the year of perf

[23:27] <TimToady> that too

[23:27] <TimToady> this is just "doc perf"  :)

[23:27] <gfldex> we also making the docs faster :)

[23:28] <TimToady> s34n: not exactly

[23:28] <s34n> ?

[23:29] <TimToady> we reuse colon followed by an identifier plus brackets as a pair notation

[23:29] <geekosaur> s34n, :name{expr} defines a colonpair; it's the same as (name => expr). but the {} can be replaced by various other things to quote the expr, so :name<x y> is :name{'x', 'y'} is (name => ['x', 'y'])

[23:29] <gfldex> m: my $foo:bar = 1; my $foo:bar<2> = 2; dd MY::.keys

[23:29] <camelia> rakudo-moar 32c08b: OUTPUT«("\$=pod", "!UNIT_MARKER", "EXPORT", "\$_", "\$!", "\$foo:bar", "::?PACKAGE", "GLOBALish", "\$¢", "\$=finish", "\$/", "\$foo:bar<2>", "\$?PACKAGE").Seq␤»

[23:29] <TimToady> and you can leave out either the identifier or the brackets for specialized uses

[23:29] <gfldex> m: my $foo:bar<1> = 1; my $foo:bar<2> = 2; dd MY::.keys

[23:29] <camelia> rakudo-moar 32c08b: OUTPUT«("\$=pod", "!UNIT_MARKER", "EXPORT", "\$_", "\$!", "::?PACKAGE", "GLOBALish", "\$¢", "\$=finish", "\$/", "\$foo:bar<1>", "\$foo:bar<2>", "\$?PACKAGE").Seq␤»

[23:29] <TimToady> the fact that in foo:bar there's a foo in front of the :bar is kind of accidental

[23:30] <TimToady> that's just one of the spots that p6 tries to make sense of "adverbial pair" notation

[23:31] <TimToady> you can use :foo(42) anywhere you might use foo => 42 to generate a pair, but you can't always use foo => 42 anywhere you can use :foo(42)

[23:32] <TimToady> so you can use either form for named args to a function, but lots of more specialized syntaxes require the colon form for disambiguation

[23:32] <TimToady> it's just a convenient syntax we can reuse in many different ways

[23:33] <TimToady> even the radix form :16<deadbeef> is a variant of it

[23:33] <TimToady> hmm, I wonder

[23:34] <TimToady> m: my $foo:16<deadbeef> = 42; say $foo:16<deadbeef>

[23:34] <camelia> rakudo-moar 32c08b: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3my $foo:7⏏0516<deadbeef> = 42; say $foo:16<deadbeef>␤    expecting any of:␤        colon pair␤»

[23:34] <TimToady> nah :)

[23:34] *** dvinciguerra_ joined
[23:34] <TimToady> that one has to be alpha

[23:35] <BenGoldberg> .seen huggable

[23:35] <yoleaux> I saw huggable 22 Jul 2016 14:09 EDT in #perl6: <huggable> unmatched}, Added speed is as Some speed stats: http://tux.nl/Talks/CSV6/speed4.html

[23:38] <s34n> I don't get the part about extending any identifier using pair notation

[23:39] <gfldex> s34n: have a look at https://docs.perl6.org/language/typesystem#Versioning_and_Authorship to see what it's good for

[23:40] <s34n> $foo:bar<baz>   <- so :bar<baz> gets turned into a pair? How does a pair be part of an identifier?

[23:40] <gfldex> if we would have proper macros one coud play more cards with this

[23:40] <gfldex> s34n: it's just part of the name but the compiler/a future macro could do fancy stuff with it

[23:41] <TimToady> in a name, we simply canonicalize it to a string, but logically it still has structure that can contain arbitrary data

[23:42] <TimToady> if you work at it, you can see the canonicalization

[23:42] <TimToady> m: my $foo:bar<\<\>> = 42; say MY::.keys

[23:42] <camelia> rakudo-moar 32c08b: OUTPUT«($=pod !UNIT_MARKER EXPORT $_ $! ::?PACKAGE GLOBALish $¢ $foo:bar«<>» $=finish $/ $?PACKAGE)␤»

[23:43] <TimToady> notice that it canonicalized to $foo:bar«<>»

[23:43] <BenGoldberg> m: my $foo:bar<x y>; dd grep /foo/, MY::.keys;

[23:43] <camelia> rakudo-moar 32c08b: OUTPUT«("\$foo:bar<x y>",).Seq␤»

[23:43] <dalek> bisectbot: 4fc97b7 | (Daniel Green)++ | Perl6IRCBotable.pm:

[23:43] <dalek> bisectbot: Change how exit status is handled so if the given code segfaults, the exit status is 11

[23:43] <dalek> bisectbot: review: https://github.com/perl6/bisectbot/commit/4fc97b74e4

[23:43] <BenGoldberg> m: dd Mu;

[23:43] <camelia> rakudo-moar 32c08b: OUTPUT«Mu␤»

[23:43] <BenGoldberg> m: dd Mu<x y>;

[23:43] <camelia> rakudo-moar 32c08b: OUTPUT«Cannot resolve caller postcircumfix:<{ }>(Mu, ("x", "y")); none of these signatures match:␤    (\SELF, \key)␤    (\SELF, \key, Mu \ASSIGN)␤    (\SELF, \key, Mu :$BIND! is raw)␤    (\SELF, \key, :$SINK!, *%other)␤    (\SELF, \key, :$delete!, *%oth…»

[23:45] <gfldex> m: my $i = 42; my $foo:bar«$i»; dd MY::.keys;

[23:45] <camelia> rakudo-moar 32c08b: OUTPUT«===SORRY!===␤QAST::Var with scope '' NYI␤»

[23:45] <gfldex> o.0

[23:45] <gfldex> m: my $i = 42; my $foo:bar«$i»;

[23:45] <camelia> rakudo-moar 32c08b: OUTPUT«===SORRY!===␤QAST::Var with scope '' NYI␤»

[23:46] <gfldex> do I spot a lack of $?LINE ?

[23:46] <s34n> m: my $i = 2; my $foo:bar«$i»;

[23:46] <camelia> rakudo-moar 32c08b: OUTPUT«===SORRY!===␤QAST::Var with scope '' NYI␤»

[23:47] <geekosaur> it's mentioning QAST, it's internal low level stuff that oughn't be leaking through...

[23:48] <s34n> m: my $i = 2; my $foo:bar«2» = 42; say $foo:bar«$i»;

[23:48] <camelia> rakudo-moar 32c08b: OUTPUT«Use of uninitialized value $i of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in code  at <tmp> line 1␤5===SORRY!5=== Error while compiling <tmp>␤Variable '$foo:bar<>' is not declared…»

[23:53] <s34n> I still don't get inserting a pair into an identifier

[23:53] * geekosaur guesses that $i needs to be known at compile time

[23:53] <geekosaur> m: my $i ::= 2; my $foo:bar«2» = 42; say $foo:bar«$i»;

[23:53] <camelia> rakudo-moar 32c08b: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤"::=" not yet implemented. Sorry. ␤at <tmp>:1␤------> 3my $i ::= 27⏏5; my $foo:bar«2» = 42; say $foo:bar«$i»;␤»

[23:53] <geekosaur> beh

[23:56] <gfldex> LTA filed as #128712

[23:56] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=128712

[23:57] *** RabidGravy left
[23:58] <s34n> but back to that grammar, wouldn't mult-op and mult-op:sym<times> be two different identifiers?

[23:59] <TimToady> sure, but when you call mult-op, it knows all its candidates begin with mult-op

[23:59] <TimToady> with all multiple dispatch in P6, you really call the proto, and the proto calls which multi candidates it decides to

[23:59] <TimToady> in the case of rules, LTM is involved in the decision

