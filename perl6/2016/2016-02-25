[00:02] *** vendethiel joined
[00:06] *** guru_ joined
[00:07] <hoelzro> sortiz: I'm having trouble breaking your change, which is good =)

[00:08] <hoelzro> I'm wondering, though, if we shouldn't override FAILGOAL in rakudo to throw a typed exception that we can look for, kind of like X::Syntax::Missing

[00:08] *** matiaslina joined
[00:10] *** john51 left
[00:11] *** john51 joined
[00:11] <sortiz> hoelzro, That was my first approach, but there are tests in roast that expect X::comp::AdHoc :(

[00:13] *** sevvie joined
[00:13] <hoelzro> =/

[00:14] <hoelzro> maybe those tests need to change? I don't know how comfortable that makes me in a post-6.c world, though

[00:14] <hoelzro> dinner &

[00:14] <sortiz> CY

[00:15] <sortiz> Bon Appetite!

[00:15] <sevvie> sortiz: s/te/t/

[00:16] * masak .oO( J grand, a petit )

[00:19] <sevvie> voulez vous coucher avec moi, monsoir?

[00:19] <sortiz> tnks sevvie. :)

[00:21] <sevvie> <3

[00:21] <sevvie> I've been out of the loop a week or so, how grows the butterfly?

[00:22] * masak thought it was "ce soir"

[00:22] <timotimo> are we proposing cuddles?

[00:23] *** vendethiel left
[00:23] <sevvie> masak, it might be. It's been some time since I've heard the song and couldn't remember the words too well; I guessed based on scansion.

[00:24] <sevvie> timotimo: whY would you think that wE are propoSing cuddles?

[00:24] <masak> :P

[00:27] * masak commutes

[00:28] <timotimo> <3

[00:28] <leont> Indeed it's ce soir. It's quite an interesting song to analyze, actually (for various reasons)

[00:29] <sevvie> ... evernoted.

[00:33] <timotimo> i'm going to bed alone now. i'm even leaving the cats behind

[00:35] <timotimo> but i actually have an easier time sleeping when alone

[00:35] <sortiz> What fault have cats?

[00:35] <timotimo> they get super annoying when it's time for them to get fed in the morning :) :)

[00:36] <leont> You mean, they love you intensely and without reservation ;-)

[00:36] <timotimo> yep. they'd love me to my face and chest

[00:37] <timotimo> anyway, i'm heading out :)

[00:39] <sortiz> till tomorrow timotimo, sleep well without cats :)

[00:41] *** SCHAAP137 left
[00:42] *** addison_ joined
[00:45] *** cdg left
[00:46] *** leont left
[00:47] *** addison_ left
[00:47] *** huf_ left
[00:48] *** rburkholder joined
[00:50] *** yurivish left
[00:50] *** huf joined
[00:52] *** Trey_ left
[00:52] *** sufrostico joined
[00:53] *** yqt left
[00:58] <timotimo> i spent some more time letting the cats adore the light spots that my glasses project onto the walls

[00:58] *** matiaslina left
[00:59] *** addison joined
[00:59] <sortiz> .tell hoelzro Overriding FAILGOAL the tests that fail are in S02-literals/char-by-number.t and S02-literals/quoting-unicode.t. In roast there are 37 tests that explicitly check for X::Comp::AdHoc, convert them to typed exceptions is for another project, though

[00:59] <yoleaux> sortiz: I'll pass your message to hoelzro.

[01:02] <timotimo> nothing terrible about throwing an X::Comp::AdHoc enhanced with an extra role

[01:03] *** addison left
[01:04] <sortiz> Can be, but the cleaner approach is turn them to typed exceptions, case by case. Some a inherited from nqp/Grammar and some are from naked 'die's in rakudo.

[01:05] <sortiz> All of them should be X::Syntax::<something>

[01:09] <sortiz> Right now I'm simply regexing the message, and works well.

[01:11] <sortiz> In fact, some tests said '# no exception type yet' :)

[01:14] <skids> m: class X::Syntax::Foo is X::Comp::AdHoc { }; use Test; throws-like { X::Syntax::Foo.new(:message<foo>).throw }, X::Comp::AdHoc

[01:14] <camelia> rakudo-moar a7ec54: OUTPUT«    1..2␤    ok 1 - code dies␤    ok 2 - right exception type (X::Comp::AdHoc)␤ok 1 - did we throws-like X::Comp::AdHoc?␤»

[01:15] <skids> Not that it should remain that way forever.

[01:15] <sortiz> Sure, I known.

[01:16] *** Trey_ joined
[01:16] *** vendethiel joined
[01:19] *** gfldex_ is now known as gfldex

[01:19] <sortiz> Are you up to volunteer? ;)

[01:27] * sortiz Surprised and delighted that native methods works!!

[01:27] <timotimo> how else would we be able to claim c++ support?

[01:29] <sortiz> This is only C, but had not tried. :)

[01:31] <sortiz> For Pg DBDish: class PGconn is export is repr('CPointer') { method PQstatus (PGconn: --> int32) is native(LIB) { * } };

[01:35] *** telex left
[01:39] *** zpmorgan joined
[01:39] *** vendethiel left
[01:41] *** sufrostico left
[01:44] *** adu joined
[01:49] *** labster left
[01:50] *** telex joined
[02:01] *** guru_ left
[02:05] *** rburkholder left
[02:08] *** dfcarpenterak left
[02:20] *** Actualeyes joined
[02:33] *** vendethiel joined
[02:36] *** kaare_ left
[02:44] *** _dolmen_ joined
[02:45] *** abaugher left
[02:46] *** abaugher joined
[02:49] *** adu left
[02:55] *** SevenWolf joined
[02:56] *** vendethiel left
[03:02] *** noganex joined
[03:02] *** Trey_ left
[03:03] *** raiph left
[03:05] *** noganex_ left
[03:06] *** Herby_ joined
[03:06] <Herby_> Evening, everyone!

[03:06] <yoleaux> 24 Feb 2016 05:27Z <MadcapJake> Herby_: i'd suggest trying Crust if you do want to peruse webdev in Perl 6

[03:07] <Herby_> MadcapJake: I'll take a look, thanks

[03:10] *** raiph joined
[03:11] *** araujo left
[03:14] <Herby_> \o

[03:15] <skids> o/

[03:36] *** adu joined
[03:37] *** labster joined
[03:41] *** cdg joined
[03:42] *** cdg left
[03:42] *** cdg joined
[03:43] *** dfcarpenterak joined
[03:44] *** pierrot left
[03:47] *** idiosyncrat_ joined
[03:59] *** noganex_ joined
[04:02] *** noganex left
[04:02] *** avenj left
[04:08] *** raiph left
[04:08] *** SevenWolf left
[04:09] *** kid511 left
[04:16] *** lichtkind left
[04:16] *** Herby_ left
[04:19] *** autogen_ joined
[04:20] *** autogen left
[04:25] *** cbk joined
[04:29] *** Trey_ joined
[04:32] *** idiosyncrat_ left
[04:32] *** raiph joined
[04:43] *** addison joined
[04:47] *** ka joined
[04:48] *** addison left
[05:00] *** raiph left
[05:01] *** Trey_ left
[05:16] *** labster left
[05:17] *** havenwood joined
[05:20] *** labster joined
[05:21] *** laz78 joined
[05:22] *** cdg left
[05:29] *** labster left
[05:39] *** autarch left
[05:40] <skids> m: my ($n, $base) = 120973, 100; ($n ~~ m:ex/^[$<dig>=[(0|<[1..9]>\d*)<?{ +~$0[*-1] < $base }>]]*$/).map( { [+] (((+«$_<dig>).reverse) Z* (1, * * $base ... *)) }).sort».say

[05:40] <camelia> rakudo-moar a7ec54: OUTPUT«1200973␤1209703␤12000973␤12009703␤102000973␤102009703␤120090703␤1200090703␤10200090703␤»

[05:40] <skids> (solution to reddit daily programmer)

[05:40] <skids> A bit slow.

[05:42] <skids> Probably due to the match results not being a lazy uncached iterator.

[05:44] *** skids left
[05:49] *** labster joined
[05:54] *** labster left
[05:57] *** Trey_ joined
[05:58] <dalek> DBIish: 5288b6b | (Salvador Ortiz)++ | lib/DBDish/Pg (4 files):

[05:58] <dalek> DBIish: Pg now uses typed handlers and native methods

[05:58] <dalek> DBIish: 

[05:58] <dalek> DBIish: DBDish::Pg revamped to use 'is native' methods of typed CPointer classes

[05:58] <dalek> DBIish: at the native call interface level.

[05:58] <dalek> DBIish: 

[05:58] <dalek> DBIish: A lot of needless 'return' removed and general cleanup.

[05:58] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/5288b6bc59

[05:58] <dalek> DBIish: f042c03 | (Salvador Ortiz)++ | lib/DBDish/Pg/ (2 files):

[05:58] <dalek> DBIish: Two types made NativeCall unneeded in Pg::SH

[05:58] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/f042c033bb

[05:58] *** Cabanossi left
[05:59] *** khw left
[06:00] *** avenj joined
[06:02] *** Cabanossi joined
[06:02] *** Trey_ left
[06:13] *** dfcarpenterak left
[06:17] *** nemo left
[06:20] *** avenj left
[06:20] *** avenj joined
[06:22] *** cbk2 joined
[06:22] *** vendethiel joined
[06:27] *** skids joined
[06:32] *** adu_ joined
[06:33] *** addison joined
[06:35] *** adu left
[06:35] *** adu_ is now known as adu

[06:36] *** laz__78 joined
[06:37] *** addison left
[06:38] *** laz78 left
[06:38] *** laz__78 is now known as laz78

[06:46] *** vendethiel left
[06:48] *** vendethiel joined
[07:01] *** nwc10 joined
[07:01] <nwc10> lizmat++ # setting compilation seems to be a few percent faster

[07:01] *** CIAvash joined
[07:01] *** nwc10 left
[07:02] *** molaf joined
[07:09] *** jameslenz left
[07:11] *** vendethiel left
[07:23] *** adu left
[07:24] *** molaf left
[07:25] *** FROGGS joined
[07:28] <[Tux]> test            22.043

[07:28] <[Tux]> test-t          11.828

[07:28] <[Tux]> csv-parser      51.126

[07:29] <[Tux]> lizmat, any progress/mews on that new where bug? (just being curious)

[07:31] *** domidumont joined
[07:34] *** nakiro joined
[07:35] *** abraxxa joined
[07:35] *** domidumont left
[07:36] *** nemo joined
[07:36] *** nemo is now known as Guest28835

[07:37] *** domidumont joined
[07:37] *** darutoko joined
[07:42] *** AiHasBeenSolved joined
[07:42] <AiHasBeenSolved> http://www.sourcecodeonline.com/details/ghost_perl_webserver_strong_ai.html

[07:42] * AiHasBeenSolved Ghost AI coder leaves this message FYI -- For Your Information. Bye

[07:42] *** AiHasBeenSolved left
[07:42] *** rindolf joined
[07:43] *** sno left
[07:44] *** firstdayonthejob joined
[07:49] *** _dolmen_ left
[07:52] *** domidumont left
[08:00] *** Trey_ joined
[08:02] *** nine left
[08:03] *** alpha123 left
[08:04] *** alpha123 joined
[08:04] *** jameslenz joined
[08:05] *** Trey_ left
[08:05] *** camelia left
[08:07] *** domidumont joined
[08:08] *** vendethiel joined
[08:08] *** notbenh left
[08:11] *** RabidGravy joined
[08:11] *** virtualsue joined
[08:16] <FROGGS> wow, that's an impressive code style: http://ai.neocities.org/perlmind.txt

[08:17] <FROGGS> sad that (s)he has left

[08:17] <moritz> FSVO "impressive" :-)

[08:18] <FROGGS> I mean, *every* line has its coment

[08:18] <FROGGS> that's probably what REXX hackers are used to

[08:18] <RabidGravy> EUGH

[08:19] *** _dolmen_ joined
[08:19] <FROGGS> I wonder what that actually does

[08:19] *** notbenh joined
[08:19] <gfldex> the comments didn't tell you?

[08:19] *** zakharyas joined
[08:24] <TEttinger> in soviet russia, ai solves you!

[08:25] <Hotkeys> What's going on here

[08:25] <Hotkeys> > f(@z)

[08:25] <Hotkeys> ([141 214 314 495 767] [908 709 314] [1617 314] [1931])

[08:25] <Hotkeys> > f(@z)».join('  ').say

[08:25] <Hotkeys> (141  214  314  495  767 1931 1931 1931)

[08:25] <gfldex> Hotkeys: some stuff is joined (and separated by '  ') and some stuff is stringyfied

[08:26] <Hotkeys> but that should join each list in that superlist

[08:27] <gfldex> Hotkeys: also, you may want to step away from the dangerous say method if you work with lists

[08:27] <Hotkeys> it does the thing even without say

[08:28] <gfldex> Hotkeys: could you golf that a little better so we can play with it?

[08:28] <Hotkeys> do you want f?

[08:28] *** _dolmen_ left
[08:29] <FROGGS> we want an example that fits in a single line here, with e.g. less data

[08:29] <gfldex> the result of f(@z) would do

[08:30] *** d^_^b left
[08:30] <Hotkeys> evaling f(@z) in the repl gives ([141 214 314 495 767] [908 709 314] [1617 314] [1931])

[08:31] *** vendethiel left
[08:31] <gfldex> please .perl.put it

[08:31] <Hotkeys> > f(@z).perl.put

[08:31] <Hotkeys> ([141, 214, 314, 495, 767], [1931], [1931], [1931])

[08:32] <gfldex> m: @a = [141, 214, 314, 495, 767], [1931], [1931], [1931]; @a.perl.put;

[08:32] *** domidumont left
[08:32] <Hotkeys> however > f(@z)[1].perl.put

[08:32] <Hotkeys> [908, 709, 314]

[08:32] <gfldex> camelia: you alright?

[08:34] *** addison joined
[08:35] *** sno joined
[08:36] <FROGGS> ahh

[08:36] <FROGGS> "In the early stages of the construction of the Mind.pl program, you may type in a word such as "boys", then "play" and then "games" to tell the AI that "boys play games." The program will go about storing the words in auditory memory and at the end will show you the contents of the auditory memory, along with associative tags that connect words as concepts instantiated in a mind. "

[08:36] <FROGGS> "In the more mature AI Minds such as MindForth or the JavaScript AiMind.html program, once you tell the AI that "boys play games" and you enter a fact such as "John is a boy", the InFerence module will engage in machine reasoning and ask you, "Does John play games?" The Perl AI is on its way to the same level of reasoning. "

[08:36] <FROGGS> that's what I wanted to know

[08:38] *** addison left
[08:39] *** firstdayonthejob left
[08:39] <gfldex> Hotkeys: the first element (that is a list) of the list is joined as asked by you, then the other 3 elements are then assumed to be lists with one element. Joining a list of one element is kinda hard. The resulting list of strings is then stringyfied (and join by a single space).

[08:40] <Hotkeys> why are they assumed to be one element though

[08:40] <gfldex> because .join demands a list

[08:41] <gfldex> any item that is called with a listy-method is turned into a list on the fly

[08:41] *** laz78 left
[08:42] <lizmat> good *, #perl6!

[08:42] *** zpmorgan left
[08:42] <lizmat> [Tux] sorry, didn't get a round tuit yet

[08:42] <Hotkeys> > (.WHAT for f(@z))

[08:42] <Hotkeys> ((Array) (Array) (Array) (Array))

[08:42] <Hotkeys> they seem to already be listy though

[08:42] <gfldex> Hotkeys: the interface to any object is the set of methods you call at runtime. The "type" of the object doesn't matter (unless you force a type-check).

[08:43] <gfldex> in this case they are arrays with one element

[08:43] <Hotkeys> okay but

[08:43] <Hotkeys> > (.join('  ') for f(@z)).perl

[08:43] <Hotkeys> ("141  214  314  495  767", "908  709  314", "1617  314", "1931")

[08:44] <Hotkeys> Why does this work then

[08:44] <Hotkeys> what's different?

[08:44] <gfldex> ».foo will call foo and take each return value to form a new list

[08:44] <gfldex> that list is then stringyfied

[08:45] <gfldex> in your initial example you either call .join to early or to late, depending on what output you would like to see.

[08:46] <Hotkeys> I was under the impression that @foo».bar would call .bar on each element of @foo

[08:46] <Hotkeys> which is also what the for loop there does essentially

[08:46] <Hotkeys> what am I missing

[08:47] <gfldex> what output would you like to see?

[08:47] <moritz> doesn't >> descend further into sub-structures?

[08:47] * moritz has lost track of current hyper semantics

[08:47] <Hotkeys> I would like to see the output the for loop produced

[08:47] <Hotkeys> ("141  214  314  495  767", "908  709  314", "1617  314", "1931")

[08:47] <Hotkeys> that is

[08:47] <Hotkeys> each element of each sub list joined

[08:47] <moritz> @list.map(~*)

[08:48] <moritz> @list.map(*.join(' '))

[08:48] <Hotkeys> I know

[08:48] <Hotkeys> but 

[08:49] <gfldex> ».join should actually do that

[08:49] <Hotkeys> postfix ». / postfix >>.

[08:49] <Hotkeys> Hyper method call operator. Will call a method on all elements of a List out of order and return the list of return values in order.

[08:49] <gfldex> camelia where are you?

[08:49] <Hotkeys> is a bit misleading if it doesn't actually do that

[08:49] <jast> it does do that

[08:49] <jast> your confusion comes from using .say on its result

[08:49] <jast> try this: f(@z)>>.join('  ').perl.say

[08:49] <Hotkeys> it also fails with .perl.put

[08:50] <Hotkeys> s/fails/does the weird/

[08:50] <Hotkeys> <Hotkeys> > f(@z).perl.put

[08:50] <Hotkeys> <Hotkeys> ([141, 214, 314, 495, 767], [1931], [1931], [1931])

[08:50] <moritz> gfldex: I can't even ping the server anymore that it runs on

[08:50] <jast> there's no >>.join in that

[08:50] <Hotkeys> without the join

[08:50] <Hotkeys> something weird is happening

[08:50] <Hotkeys> and idk what

[08:50] <Hotkeys> even without hyper

[08:50] <gfldex>  /o\ the internet got a flat

[08:51] <moritz> last traceroute point is somewhere in a hetzner DC

[08:51] <Hotkeys> > (.perl for f(@z))

[08:51] <Hotkeys> ([141, 214, 314, 495, 767] [908, 709, 314] [1617, 314] [1931])

[08:51] <gfldex> i prefer dd to loot at things with structure

[08:52] <gfldex> s/look/loot/ (i better take of this pirate hat)

[08:52] <Hotkeys> I'm wondering why f(@z).foobarbaz is turning everything but the first list into a single value

[08:52] <Hotkeys> whether it be join or perl or whatever

[08:52] <jast> I just tried the same thing (@x>>.join.perl) with a constant array and it does the expected thing

[08:53] <Hotkeys> here's f

[08:53] <Hotkeys> my &f = {my@b=@^a.sort;my@c=[@b];@b=flat(@b [email@hidden.address] while +@b>1))}

[08:53] <Hotkeys> it's a messy one liner cause I'm golfing

[08:54] *** tmch joined
[08:56] <jast> I get the same behaviour with that

[08:57] <Hotkeys> it just seems weird

[08:57] *** fireartist joined
[08:57] <Hotkeys> because iterating over it works fine

[08:57] <Hotkeys> but regular methods do the weird collapsing

[08:58] *** virtualsue left
[08:58] *** notbenh left
[09:00] *** vendethiel joined
[09:03] *** nine joined
[09:05] *** camelia joined
[09:05] <jast> I think you're going to have to take this to people who know way more about Perl 6 than I do

[09:05] <jast> might actually be some kind of bug

[09:07] *** ChanServ sets mode: +v camelia

[09:11] *** rindolf left
[09:15] *** virtualsue joined
[09:22] *** vendethiel left
[09:25] *** espadrine joined
[09:30] <nine> m: say "I'm up"

[09:30] <camelia> rakudo-moar a7ec54: OUTPUT«I'm up␤»

[09:30] <nine> excellent

[09:33] *** kjs_ joined
[09:36] *** pierrot joined
[09:38] <lizmat> afk for a few hours&

[09:39] <kjs_> good morning. How would one test whether a hash element is an array

[09:39] <timotimo> having the same value a bunch of times at the end looks a lot like you're accidentally re-using a single array where you'd expect multiple different ones, or multiple arrays that share the same scalar container in their first slot

[09:42] <timotimo> but i'm not messing with that blob of code that has not a single space in it :P

[09:43] *** dakkar joined
[09:43] <timotimo> also, the thing about hypers that you probably don't know and that's potentially undocumented, is the "nodal" semantics

[09:43] <timotimo> when a method that's marked "is nodal" is called on stuff, it won't descend into sublists

[09:43] <timotimo> it will operate on the list itself instead

[09:44] <llfourn> kjs_: %hash<foo> ~~ Array

[09:44] <timotimo> m: say (+<<[[1, 2, 3], [5, 6], [9], [9, 9, 9, 9]]).perl

[09:44] <camelia> rakudo-moar a7ec54: OUTPUT«[[1, 2, 3], [5, 6], [9], [9, 9, 9, 9]]␤»

[09:44] <timotimo> m: say ([[1, 2, 3], [5, 6], [9], [9, 9, 9, 9]]>>.elems).perl

[09:44] <camelia> rakudo-moar a7ec54: OUTPUT«(3, 2, 1, 4)␤»

[09:44] <timotimo> ^- see the difference here

[09:45] <timotimo> without the nodal semantics, the second invocation would have given [[1, 1, 1], [1, 1], [1], [1, 1, 1, 1]]

[09:46] *** donaldh joined
[09:47] *** leont joined
[09:48] <kjs_> llfourn: many thanks - that did the trick.

[09:48] <llfourn> yw :)

[09:49] *** notbenh joined
[09:53] *** araujo joined
[09:53] *** araujo left
[09:53] *** araujo joined
[09:54] *** sitaram joined
[10:00] *** skids left
[10:02] *** Trey_ joined
[10:06] *** Trey_ left
[10:07] *** leont left
[10:19] *** Humbedooh left
[10:22] <lizmat> m: use nqp; my num @a; say nqp::islist(@a)   # how can we differentiate between a num and int here ?

[10:22] <camelia> rakudo-moar a7ec54: OUTPUT«1␤»

[10:22] <lizmat> afk again&

[10:25] <psch> m: my num @a; @a.of.say 

[10:25] <camelia> rakudo-moar a7ec54: OUTPUT«(num)␤»

[10:25] <psch> not sure that captures the intent of the question, though...

[10:28] <jnthn> It's how I'd do it, and you can use nqp::objprimspec on the result

[10:42] *** Actualeyes left
[10:43] *** ab6tract joined
[10:44] *** sitaram left
[10:45] <ab6tract> o/ #perl6

[10:45] <timotimo> hey you

[10:47] <ab6tract> so quick question: how can i test whether a sub was successfully imported into the package scope?

[10:47] <ab6tract> i thought it would look like this:

[10:47] <ab6tract> m: module S { sub s is export { say "hi!" } }; import S; s(); say OUR::{'&s'}:exists

[10:47] <camelia> rakudo-moar a7ec54: OUTPUT«hi!␤False␤»

[10:47] <abraxxa> is the 2016.02 a bugger release? I have only troubles with it

[10:48] <timotimo> "bugger" release?

[10:48] <abraxxa> nothing I touch works

[10:48] <timotimo> :o

[10:48] <timotimo> stop touching things!!!

[10:48] <psch> m: module S { sub s is export { say "hi!" } }; import S; s(); say MY::{'&s'}:exists

[10:48] <camelia> rakudo-moar a7ec54: OUTPUT«hi!␤True␤»

[10:48] <jnthn> abraxxa: Import is lexical.

[10:48] <abraxxa> can't install Net::AMQP on a Debian 8 box whereas it worked on my Ubuntu 15.10 notebook

[10:48] <psch> OUR:: is what is shared from the current scope, isn't it?

[10:48] <jnthn> psch: OUR:: is the current *package*

[10:49] <psch> ahh

[10:49] <jnthn> Orthogonal to current lexical scope

[10:49] <jnthn> So MY:: is the right thing for checking about imports, yes.

[10:50] <ab6tract> jnthn: ok. i guess i would have thought that checking OUR would be as sensible

[10:50] <ab6tract> but yeah, now that i think about it.. a test file is not really a package

[10:51] <jnthn> OUR:: in the mainline is just another way to spell GLOBAL::

[10:51] <ab6tract> i love the scoping in perl 6

[10:51] *** virtualsue left
[10:51] <timotimo> abraxxa: what kind of errors are you getting?

[10:51] <ab6tract> jnthn: gotcha!

[10:51] <jnthn> in module Foo { ... } then OUR:: is short for Foo::

[10:51] <jnthn> etc.

[10:51] <jnthn> Well, not short there, but... :)

[10:51] <ab6tract> that's clear :D

[10:52] <llfourn> m: our $foo = "foo"; say GLOBAL::<$foo>; say OUR::<$foo>

[10:52] <camelia> rakudo-moar a7ec54: OUTPUT«foo␤foo␤»

[10:53] <llfourn> and if you're outside of a declared package your package is GLOBAL

[10:53] <El_Che> hi jnthn, has your grant been voted yet? I saw results for rperl in my rss feed

[10:53] <ab6tract> llfourn: but imported thingies don't show up there anyway

[10:54] <jnthn> El_Che: Not as far as I know.

[10:54] <jnthn> El_Che: I've heard nothing on it yet.

[10:54] <El_Che> ok, no new is good news then :)

[10:54] <jnthn> El_Che: Hopefully soon...I'm about ready to get to work :)

[10:54] *** ka left
[10:54] * ab6tract is trying his hands at a Perl 6 port of Sereal

[10:54] <El_Che> fingers crossed

[11:00] *** Actualeyes joined
[11:04] *** vendethiel joined
[11:05] *** RabidGravy left
[11:06] *** virtualsue joined
[11:07] *** TeamBlast left
[11:12] *** ocbtec joined
[11:12] *** TeamBlast joined
[11:14] *** virtualsue left
[11:16] *** Skarsnik joined
[11:17] *** alpha123 left
[11:17] *** alpha123 joined
[11:21] *** _mg_ joined
[11:28] *** susmus joined
[11:28] <susmus> hello

[11:29] <psch> hi susmus 

[11:29] *** _mg_ left
[11:29] <DrForr> o/

[11:29] *** kurahaupo joined
[11:36] <timotimo> ohai

[11:37] *** rindolf joined
[11:40] *** alpha123 left
[11:42] *** peter joined
[11:42] *** peter is now known as Guest11189

[11:47] *** vendethiel left
[11:47] *** kaare_ joined
[11:50] <psch> hrm, this is odd

[11:50] <psch> something gets confused in the JavaHOW

[11:50] <psch> specifically with the MethodContainer role

[11:50] <psch> as in, a Java class that i successfully load can dispatch to its Java methods

[11:50] <psch> but those don't show up in .^methods

[11:51] <psch> on the other hand, methods added with .^add_method show up in .^methods but can't be dispatched to

[11:51] <lizmat> ab6tract++

[11:51] <moritz> fwiw dispatching uses find_method, not .^methods

[11:51] <moritz> which likely uses method_table

[11:52] <psch> moritz++ 

[11:52] <psch> that's a hint at least

[11:53] <nine> psch: in case you wondered. The "# $jtype.WHO{$_.key} := $_.value for @existing;" line is for when there's already a Foo::Bar::Baz package and you are creating a wrapper class called Foo::Bar

[11:53] <jnthn> Generally, meta-objects can keep whatever internal state they want

[11:53] <psch> nine: it's commented because it NPEs afair.  probably something else going on there that's not quite right...

[11:53] <jnthn> And can transform it into what's needed

[11:54] <jnthn> In the Perl 6 MOP classes we do need both an array and a hash

[11:54] <jnthn> Hash for fast lookup, array because we need to know the order methods were added in

[11:54] <psch> hm, it probably has something to do with 7432d6202ede8569cac13ecbfae78afafc915fa4

[11:55] <psch> no wait

[11:55] <psch> that's impossible cause that's a really old commit

[11:56] <psch> well, 2 years and change, which is older than any jvminterop work i did :)

[11:58] *** vendethiel joined
[12:04] *** Trey_ joined
[12:04] <psch> hm, find_method directly fetches %!methods, which only has methods added with .^add_method, if any

[12:04] <psch> which means dispatch for Java classes is completely weird and i have no idea what i'm doing..? /o\

[12:06] <psch> right, nqp::findmethod finds the original ones

[12:07] <moritz> it just means that it doesn't call methods from parent classes

[12:07] <moritz> so, no inheritance

[12:07] <FROGGS> I thought you .^add_method all methods that exist on java classes?

[12:07] *** CIAvash left
[12:08] <psch> FROGGS: no, https://github.com/rakudo/rakudo/blob/nom/src/vm/jvm/runtime/org/perl6/rakudo/RakudoJavaInterop.java#L896

[12:08] <dalek> rakudo/nom: 817b0b9 | lizmat++ | src/core/Buf.pm:

[12:08] <dalek> rakudo/nom: Streamline Blob creation

[12:08] <dalek> rakudo/nom: 

[12:08] <dalek> rakudo/nom: - when creating from Blob:D or int array, use nqp::splice (1.5x faster)

[12:08] <dalek> rakudo/nom: - pre-size buffer if we can know number of elements to be added beforehand

[12:08] <dalek> rakudo/nom: - add private method for failing with element number info

[12:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/817b0b9bac

[12:09] <FROGGS> ahh

[12:09] *** Trey_ left
[12:09] <psch> the curious bit is why the bind_attribute_boxed calls don't seem to take

[12:09] <psch> a few lines below the linked one

[12:10] <psch> afaict i'm not messing with the HOW anywhere either...

[12:20] *** vendethiel left
[12:23] *** TEttinger left
[12:30] *** kjs_ left
[12:33] *** wamba joined
[12:41] *** kurahaupo_ joined
[12:41] *** kurahaupo left
[12:43] *** kurahaupo_ is now known as kurahaupo

[12:46] *** vendethiel joined
[12:55] *** tmch left
[12:55] *** kid51 joined
[12:56] *** kurahaupo left
[12:58] *** kurahaupo joined
[13:07] *** vendethiel left
[13:07] *** ZoffixW joined
[13:08] <ZoffixW> .tell nemo I'm not deathly sick :) While still not fully well, the reason I'm not around is because I've just moved and (a) I don't have Internet at my new place yet and won't until next week. (b) I'm too busy with unpacking and settling in :)

[13:08] <yoleaux> ZoffixW: I'll pass your message to nemo.

[13:08] * ZoffixW waves and submerges under the shadows

[13:08] *** ZoffixW left
[13:19] *** autarch joined
[13:20] <ab6tract> hmmm.. does anyone know how to map the @EXPORT_OK pattern to p6?

[13:21] <ab6tract> ie, to make an import "rule" for a whole bunch of things dynamically?

[13:23] *** Guest28835 is now known as nemo

[13:23] <El_Che> ab6tract: http://doc.perl6.org/language/modules#EXPORT ?

[13:23] <ab6tract> El_Che: yeah, i've been up and down that doc a few times..

[13:27] <moritz> I guess the weird thing is that EXPORT in that example doesn't take any arguments

[13:27] <FROGGS> ab5tract: just mark the subs you want to export "is export(:MY_TAG)"

[13:27] <moritz> which makes dynamism harder

[13:28] *** kjs_ joined
[13:28] <dalek> doc: 11ebd2b | (Claudio Ramirez)++ | doc/Language/modules-extra.pod:

[13:28] <dalek> doc: META6.info -> META6.json

[13:28] <dalek> doc: review: https://github.com/perl6/doc/commit/11ebd2b26f

[13:29] <FROGGS> moritz: but EXPORT can take params, no?

[13:30] <FROGGS> I mean, the other examples show it

[13:31] <FROGGS> though, that not what I think what the original question was

[13:31] <FROGGS> the idomatic way of exporting stuff on demand is to use custom tags

[13:38] <ab6tract> FROGGS, moritz: https://github.com/Sereal/Sereal/blob/master/Perl/Decoder/lib/Sereal/Decoder/Constants.pm

[13:38] <ab6tract> i think i will just go the "long form" route and do:

[13:39] <ab6tract> constant SRL_HDR_ALIAS is export(SRL_HDR_ALIAS) = 46;

[13:39] <FROGGS> hmmm

[13:39] <hoelzro> o/ #perl6

[13:39] <yoleaux> 00:59Z <sortiz> hoelzro: Overriding FAILGOAL the tests that fail are in S02-literals/char-by-number.t and S02-literals/quoting-unicode.t. In roast there are 37 tests that explicitly check for X::Comp::AdHoc, convert them to typed exceptions is for another project, though

[13:40] <FROGGS> why not export all constant with the tag :constants or so?

[13:40] <ab6tract> FROGGS: sure, but that doesn't match the original behavior

[13:40] <FROGGS> does it have to?

[13:40] <ab6tract> not necessarily :)

[13:40] <FROGGS> see :o)

[13:42] <FROGGS> and I would probably put these constants into five enums

[13:42] <FROGGS> SRL_HDR, SRL_MAGIC, SRL_MASK, SRL_SIZE, SRL_PROTOCOL

[13:42] <FROGGS> then you can use the enum type object as a constraint in signatures

[13:44] <ab6tract> docs.perl6.org => 'enum' not found

[13:44] <FROGGS> like: https://github.com/FROGGS/p6-XML-LibXML/blob/master/lib/XML/LibXML/Enums.pm#L5-L9

[13:44] <FROGGS> is used here: https://github.com/FROGGS/p6-XML-LibXML/blob/a1d3a6cbfeaa7babd22ab8585d508a5366b75cd0/lib/XML/LibXML/C14N.pm#L11

[13:45] *** kurahaupo left
[13:46] <hoelzro> now that 6.c has been released, how flexible can we be in changing AdHoc exceptions to another typed exceptions? sortiz and I wanted to make FAILGOAL raise a X::Comp::FailGoal (or something like that) instead of X::Comp::AdHoc, but that breaks roast

[13:46] <ab6tract> hrrmm

[13:46] <ab6tract> m: enum XS { X1 => 1, X2 => 2 }

[13:46] <camelia> rakudo-moar 817b0b: OUTPUT«5===SORRY!5=== Error while compiling /tmp/JqnzurrrTG␤Undeclared name:␤    XS used at line 1␤Undeclared routine:␤    enum used at line 1␤␤»

[13:47] <moritz> then roast should be fixed to only check for X::Comp (at least in the 6.c-errata branch)

[13:47] <jnthn> hoelzro: AdHoc => typed is fine

[13:47] <FROGGS> ab6tract: dont use curlies

[13:47] <ab6tract> ah :D

[13:47] <jnthn> I went through the test suite and removed all mentions of X::AdHoc, just making them say Exception

[13:47] <jnthn> So, no changes should be needed to 6.c-errata

[13:48] <jnthn> (To be clear, I did that before 6.c)

[13:48] <moritz> jnthn: you seem to have overlook X::Comp::AdHoc

[13:48] <moritz> *overlooked

[13:48] <jnthn> Grr

[13:49] <moritz> jnthn: I dind't think of that easier when we discussed that topic :/

[13:49] <jnthn> OK, then we should s/X::Comp::AdHoc/Exception/ in 6.c-errata

[13:49] <jnthn> But don't put into 6.c-errata exception types that never existed in 6.c

[13:49] <moritz> m: say X::Comp::AdHoc ~~ X::Comp

[13:49] <camelia> rakudo-moar 817b0b: OUTPUT«True␤»

[13:49] <ab6tract> FROGGS: thanks!

[13:49] <moritz> jnthn: or replace it with X::Comp

[13:49] <jnthn> Or that, yes

[13:49] <moritz> which is a little bit more specific

[13:50] *** brian__ joined
[13:51] <hoelzro> jnthn: ah, great! so I should replace X::Comp::AdHoc with X::Comp? on which branch of roast?

[13:53] <sortiz> \o #perl6

[13:53] * sortiz JIT

[13:54] <moritz> hoelzro: on 6.c-errata

[13:54] <hoelzro> *nod*

[13:54] <moritz> hoelzro: though you can do it too on master

[13:54] <hoelzro> master is what's bound for 6.d, I take it?

[13:54] <moritz> yes

[13:56] <hoelzro> what's the policy for propagating changes between 6.c-errata and master? merging, cherry-picking, etc?

[13:57] * moritz doesn't know of the existance of any policy

[13:57] <lizmat> only errors should be merged back ?

[13:57] <lizmat> hence the "errata" name ?

[13:57] <jnthn> hoelzro: Don't do merges between them

[13:57] <hoelzro> I would assume that 6.c-errata would be merged into master on a regular basis, but I don't want to step on toes

[13:59] <jnthn> I'd prefer commits in master, then cherry-pick what's needed into errata

[13:59] <hoelzro> ok

[13:59] *** molaf joined
[14:00] <sortiz> If I understand well, in 6.c-errata only the tests that check X::Comp::AdHoc should be changed for Exception, no?

[14:01] <jnthn> sortiz: Well, X::Comp instead of Exception, it looks like

[14:01] <jnthn> But yeah, that'd give us the flexibility we shoulda had in the first place.

[14:01] <jnthn> I expect there to be less errata with time

[14:02] <hoelzro> one hopes =)

[14:02] <dalek> rakudo/nom: fe0768b | lizmat++ | src/core/Buf.pm:

[14:02] <dalek> rakudo/nom: Introducing Blob.allocate

[14:02] <dalek> rakudo/nom: 

[14:02] <dalek> rakudo/nom: Create your Blob-like objects with a given number of elements,

[14:02] <dalek> rakudo/nom: optionally with values other then 0 to initialize with.

[14:02] <dalek> rakudo/nom: 

[14:02] <dalek> rakudo/nom: $ 6 'dd Blob.allocate(11,1,2,42)'

[14:02] <dalek> rakudo/nom: Blob.new(1, 2, 42, 1, 2, 42, 1, 2, 42, 1, 2)

[14:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fe0768b955

[14:03] <lizmat> jnthn sortiz ^^^

[14:03] *** ka joined
[14:04] <sortiz> lizmat++

[14:04] <gfldex> what reminds me of a question i wanted to ask

[14:04] <gfldex> how is the transition from 6.c -> 6.d planned for docs?

[14:05] <gfldex> or better, are there any plans?

[14:05] *** Trey_ joined
[14:05] <lizmat> gfldex: if anything, I think there are too many plans

[14:05] <gfldex> i shall plan to make a plan then :->

[14:05] <lizmat> :-)

[14:07] <sortiz> hoelzro, I can resurrect the override of FAILGOAL from my branch, what exception should I use?

[14:07] *** RabidGravy joined
[14:08] <hoelzro> sortiz: I made a X::Comp::FailGoal locally; we can just use that if you don't mind

[14:09] <brian__> How do I append one Buf[uint8] to another? (https://gist.github.com/bduggan/e740964547406f1c856d)

[14:09] <hoelzro> right now I'm working on converting X::Comp::AdHoc → X::Comp in roast

[14:09] *** autarch left
[14:09] <jnthn> brian__: ~

[14:10] <sortiz> hoelzro, no problem.

[14:10] <gfldex> joking aside, we will need a way to keep as many different versions of the docs around as we keep versions of the language. At least for reference. Or we might end up with docs littered with: "but in 6.d you do it that say". Or unmarked stuff that simply wont work in 6.c and resulting confusion.

[14:10] *** Trey_ left
[14:11] <brian__> jnthn: thanks!

[14:11] <lizmat> brian__: alternately, you can do $buf.append($buf2) nowadays

[14:12] <jnthn> Only in bleeding edge though. :)

[14:12] <jnthn> But yeah, that'll be in the next lang version :)

[14:12] <brian__> ok, yes that didn't seem to work in 2016.01

[14:12] <jnthn> Well, provided we have tests for it :)

[14:12] <lizmat> jnthn: there are some append tests nowadays

[14:13] *** virtualsue joined
[14:13] <lizmat> jnthn: also, are you happy with the Blob.allocate interface ?

[14:13] * lizmat looks outside to enjoy the snow

[14:14] <jnthn> lizmat: Not quite sure about the initialization-with-sequence part...

[14:14] <lizmat> well, it can be a single value as well

[14:15] <jnthn> lizmat: Will ponder a little on that. May be fine. Something feels a tad off, but I don't quite know what yet. Maybe nothing. :)

[14:15] <lizmat> I was more thinking allowing something like a 0xdeadbeef initialization option

[14:15] <jnthn> My guts are messed up enough at the moment that gut feeling isn't worth much :P

[14:16] <lizmat> jnthn: sorry to hear you're not feeling well  :-(

[14:17] <lizmat> jnthn: related:  I was thinking of allowing Buf:D.allocate as well, for changing the size of the buffer (larger *and* smaller)

[14:17] <lizmat> any thoughts on that ?

[14:17] <jnthn> Think I'd rather it were called something else...

[14:17] <lizmat> reallocate ?

[14:17] <jnthn> Yeah

[14:18] <jnthn> Would match-ish the C-ish naming without the shortening :)

[14:18] <lizmat> but allowing shortening would be ok, right ?

[14:19] <jnthn> I'd rather go with reallocate, if we have allocate

[14:19] <perlpilot> lizmat: fwiw, combining fixed size allocation and initialization seemed weird to me too.

[14:20] <jnthn> perlpilot: calloc does it ;)

[14:20] <jnthn> No, wait :)

[14:20] <jnthn> calloc doesn't it :)

[14:20] <jnthn> You'd typically memset

[14:20] <perlpilot> also ... Perl isn't C  ;)

[14:20] <jnthn> But yeah

[14:20] <lizmat> perlpilot: the thing is, that Blob's are immutable, so you cannot have an .initialize method later

[14:20] <jnthn> I don't think I might an initial value in there

[14:20] <jnthn> *I mind

[14:21] <lizmat> again, Blob's are considered immutable, so initializing later is not really an option, hence the initialization values with the allocate

[14:22] <dalek> rakudo/nom: 9f74027 | coke++ | README.md:

[14:22] <dalek> rakudo/nom: Note current pumpking.

[14:22] <dalek> rakudo/nom: 

[14:22] <dalek> rakudo/nom: pmichaud++

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9f74027bb0

[14:22] <jnthn> lizmat: tbh, I mostly expect people to encounter Blob when they receive one from, say, I/O.

[14:23] <jnthn> Anyway, on naming, I think either we need to have allocate/reallocate, or alloc/realloc, but not allocate/realloc :)

[14:24] <lizmat> ok, I'll implement a reallocate for now

[14:24] <jnthn> Yeah

[14:24] <jnthn> Well, it's all changeable until it's in an actual lang release. :)

[14:24] <lizmat> doesn't feel to me that the name needs to be huffmanized

[14:24] <jnthn> No, I'd rather spell it out. It's what we've tended to do, except when the prevailing culture pushes us the other way.

[14:25] <jnthn> Though, strictly speaking, I think the name "reallocate" *is* huffmanized

[14:25] <jnthn> Huffmanized doesn't mean short, it means matching commonality of use. :)

[14:26] <[Coke]> (docs 6.c vs. 6.d) there's a ticket about being able to track which language versions things were introduced or removed in.

[14:26] <lizmat> well, doesn't need to be huffmanized further then  :-)

[14:26] <jnthn> Aye :)

[14:26] <ab6tract> should i expect "\xF3" to produce the same value between p5 and p6?

[14:26] <ab6tract> because at first glance this is not the case

[14:27] *** Perleone left
[14:27] <lizmat> well, inasofar "" generates a Str in P6, and is untyped in P5 ?

[14:28] <ab6tract> lizmat: true.. that's a definite difference. i meant more in terms of the character... to be honest i'm not at all familiar with these underlying guts (pack/unpack, protobufs, encodings, and the like)

[14:28] <jnthn> m: say "\xF3"

[14:28] <camelia> rakudo-moar fe0768: OUTPUT«ó␤»

[14:28] <ab6tract> jnthn: that's what p6 gives me locally

[14:28] <jnthn> ab6tract: Right, which is correct...

[14:28] <ab6tract> p5 outputs a question sign

[14:28] <jnthn> .u ó

[14:28] <yoleaux> U+00F3 LATIN SMALL LETTER O WITH ACUTE [Ll] (ó)

[14:29] <lizmat> ab6tract: I think P5 has the trouble with displaying it

[14:29] <ab6tract> ok

[14:29] <jnthn> ab6tract: I'm certainly the wrong person to ask about what Perl 5 does. But I'm guessing you may have to opt in to...something...:)

[14:29] *** Upasaka_ joined
[14:29] <lizmat> probably something about STDOUT not being UTF-8 ?

[14:29] <ilmari> -CSAD

[14:29] <jnthn> Anyway, in Perl 6, \xABC refers to a Unicode codepoint number.

[14:29] <lizmat> $ perl -E 'say "\x61"'

[14:29] <lizmat> a

[14:29] <lizmat> LizyPro:rakudo.moar liz$ 6 'say "\x61"'

[14:29] <lizmat> a

[14:29] *** ka left
[14:30] <lizmat> looks the same for me for less troublesome chars

[14:30] <ab6tract> cool

[14:30] <ilmari> $ perl -CS -E 'say "\xf3"'

[14:30] <ilmari> ó

[14:30] <ab6tract> this is all because "In protocol version 3 the magic string has been changed to "=\xF3rl", where \xF3 is "s" with the high bit set. "

[14:30] <ab6tract> nice! thanks liz

[14:31] <jnthn> That sounds like a protocol that wants byte level processing... :)

[14:31] *** Upasaka left
[14:31] <lizmat> ab6tract: ilmari showed how to make STDOUT be utf-8  :-)

[14:31] <ilmari> that probably means it's the byte 0xf3, not the character U+F3

[14:31] <ab6tract> in their Sereal::Decoder::Constants module, they are then using a different escape scheme, doing "\363"

[14:31] <ilmari> that's octal

[14:31] <ab6tract> oops.. sorry for the misattribution ilmari :)

[14:32] <ilmari> m: say 0x363 == 0xf3

[14:32] <camelia> rakudo-moar 9f7402: OUTPUT«False␤»

[14:32] <ilmari> m: say 0o363 == 0xf3

[14:32] <camelia> rakudo-moar 9f7402: OUTPUT«True␤»

[14:33] <abraxxa> timotimo: sorry, busy day...again

[14:33] <ab6tract> ilmari: sorry i'm so dense, but aren't the byte 0xf3 and U+F3 functionally the same, in terms of what the byte looks like?

[14:33] <abraxxa> timotimo: all kinds of, mostly test failures on install, hangs on panda/p6doc start without params

[14:34] <ilmari> ab6tract: can be any number of byte sequences, depending on the encoding U+F3

[14:35] <ab6tract> but for utf8...

[14:35] <ilmari> m: say <latin-1 utf-8 utf-16le utf-32le>.map: "\xf3".encode($_)

[14:35] <camelia> rakudo-moar 9f7402: OUTPUT«Cannot call encode(Str: Any); none of these signatures match:␤    (Str $: Str:D $encoding = { ... }, Bool:D :$replacement, *%_)␤    (Str $: Str:D $encoding = { ... }, Str :$replacement, *%_)␤  in block <unit> at /tmp/TaoE8jtQuw line 1␤␤»

[14:35] <ilmari> m: say <latin-1 utf-8 utf-16le utf-32le>.map: "\xf3".encode(*)

[14:35] <camelia> rakudo-moar 9f7402: OUTPUT«Cannot call encode(Str: Whatever); none of these signatures match:␤    (Str $: Str:D $encoding = { ... }, Bool:D :$replacement, *%_)␤    (Str $: Str:D $encoding = { ... }, Str :$replacement, *%_)␤  in block <unit> at /tmp/vQm2u3juFC line 1␤␤»

[14:35] <ilmari> m: say <latin-1 utf-8 utf-16le utf-32le>.map: { "\xf3".encode($_) }

[14:35] <camelia> rakudo-moar 9f7402: OUTPUT«Unknown string encoding: 'utf-16le'␤  in block <unit> at /tmp/Uf7AQBsri9 line 1␤␤»

[14:35] <ilmari> m: say <latin-1 utf-8 utf-16 utf-32>.map: { "\xf3".encode($_) }

[14:35] <camelia> rakudo-moar 9f7402: OUTPUT«Unknown string encoding: 'utf32'␤  in block <unit> at /tmp/uQR5039n5x line 1␤␤»

[14:35] <ilmari> m: say <latin-1 utf-8>.map: { "\xf3".encode($_) }

[14:35] <camelia> rakudo-moar 9f7402: OUTPUT«(Blob[uint8]:0x<f3> utf8:0x<c3 b3>)␤»

[14:36] <ab6tract> so rather than this: constant SRL_MAGIC_STRING_HIGHBIT is export(:Constants)         = "=\x[F3]rl";

[14:36] <ab6tract> i want: constant SRL_MAGIC_STRING is export(:Constants)                 = Buf.new('='.ord, 0xf3, 's'.ord, 'r'.ord, 'l'.ord);

[14:36] <ab6tract> ?

[14:36] <ilmari> or "=\x[F3]rl".encode('latin-1')

[14:36] <ilmari> since codepoint == byte in latin1

[14:37] <ab6tract> bam

[14:37] <ab6tract> thanks a lot!

[14:39] <ilmari> you probably want Blob, not Buf, since it's constant

[14:39] <ilmari> Buf is mutable, so someone ciould do SRL_MAGIC_STRING[0] = 0xff; # boom

[14:40] <ab6tract> gotcha

[14:40] <ab6tract> looks like thats what encode returns anyway

[14:41] <ab6tract> and 'eq' is still a valid comparison operator between two Blobs?

[14:41] <ab6tract> or is there a more appropriate comparison op?

[14:42] <ilmari> you want eq

[14:43] <ilmari> == is numeric comparison, which compares the length

[14:43] <dalek> roast: 6198907 | hoelzro++ | S (10 files):

[14:43] <dalek> roast: Change X::Comp::AdHoc → X::Comp

[14:43] <dalek> roast: 

[14:43] <dalek> roast: We don't need to be *that* specific when checking compilation error

[14:43] <dalek> roast: types, because otherwise we are restricted in how far we can refine

[14:43] <dalek> roast: those types down the road

[14:43] <dalek> roast: review: https://github.com/perl6/roast/commit/6198907ce4

[14:43] <dalek> roast/6.c-errata: 409ee89 | hoelzro++ | S (10 files):

[14:43] <dalek> roast/6.c-errata: Change X::Comp::AdHoc → X::Comp

[14:43] <dalek> roast/6.c-errata: 

[14:43] <dalek> roast/6.c-errata: We don't need to be *that* specific when checking compilation error

[14:43] <dalek> roast/6.c-errata: types, because otherwise we are restricted in how far we can refine

[14:43] <dalek> roast/6.c-errata: those types down the road

[14:43] <dalek> roast/6.c-errata: review: https://github.com/perl6/roast/commit/409ee89c5a

[14:43] <ilmari> m: say Blob.new(0x42) == Blob.new(0x37)

[14:43] <camelia> rakudo-moar 9f7402: OUTPUT«True␤»

[14:44] <ilmari> m: say Blob.new(0x42) == Blob.new(0x42, 0x37)

[14:44] <camelia> rakudo-moar 9f7402: OUTPUT«False␤»

[14:44] <hoelzro> I've made the change, and rakudo passes, but this concerns me: https://github.com/perl6/roast/blob/6198907ce48e6c9d22e2a6cd691689c76462fbd6/S32-exceptions/misc.t#L317

[14:44] <dalek> DBIish/oracle: 037c377 | (Salvador Ortiz)++ | lib/DB (9 files):

[14:44] <dalek> DBIish/oracle: Rationalize 'use' and 'need' in modules

[14:44] <dalek> DBIish/oracle: 

[14:44] <dalek> DBIish/oracle: With module 'require' fixed, now DBDish.pm loads roles and

[14:44] <dalek> DBIish/oracle: other modules only needs DBDish.

[14:44] *** dalek left
[14:44] <hoelzro> X::Comp on its own doesn't have a payload attribute; that's provided via X::AdHoc

[14:44] <perlpilot> lizmat: on reflection, I think what was bothering me about your original allocate() example was the "flatness" of the args and the auto-repeat of the sequence of values.  My brain wanted some separation between the size of allocation and the initialization and a way to tweak the initialization  (what if I wanted 1,2,42,0,0,0,0,0,0,0,0  ?  how would I do that? )

[14:44] *** brian__ left
[14:44] <hoelzro> so I'll probably go back later and revisit taht

[14:45] <perlpilot> lizmat: anyway, I don't have any specific suggestion or "answer", those are just my thoughts.

[14:45] *** dalek joined
[14:45] *** ChanServ sets mode: +v dalek

[14:45] <perlpilot> lizmat++ for allocate/reallocate btw  :)

[14:45] <lizmat> perlpilot: Blob.new(1,2,42, 0 xx 8)

[14:46] <lizmat> m: dd Blob.new(1,2,42, 0 xx 8)  # just checking

[14:46] <camelia> rakudo-moar 9f7402: OUTPUT«Blob.new(1, 2, 42, 0, 0, 0, 0, 0, 0, 0, 0)␤»

[14:47] <perlpilot> lizmat: then why do we need allocate when I can just say something like that anyway?  

[14:48] <lizmat> because it's relatively slow

[14:48] <lizmat> a repeated list is nqp::spliced into the blob, which is much faster

[14:51] <lizmat> Buf/Blob's slowness, specifically wrt to NC, has been a complaint that I heard a lot on the channel

[14:51] <dalek> rakudo/more_ml_repl: 47bd65f | (Salvador Ortiz)++ | src/Perl6/Compiler.nqp:

[14:51] <dalek> rakudo/more_ml_repl: Multi-line REPL: Detect grammar's failed goals.

[14:51] <dalek> rakudo/more_ml_repl: 

[14:51] <dalek> rakudo/more_ml_repl: That allows the following session:

[14:51] <dalek> rakudo/more_ml_repl: > my $a = <

[14:51] *** dalek left
[14:51] <hoelzro> sortiz: ^ REPL changes, feel free to have a look

[14:51] <perlpilot> aye

[14:51] <hoelzro> now I need to hurry up and get ready for work o_O

[14:52] *** dalek joined
[14:52] *** ChanServ sets mode: +v dalek

[14:52] <sortiz> hoelzro, Thanks!

[14:52] <perlpilot> it's still bothersome in my head.  Either I'll get used to it or I'll think of something "better"  :)

[14:52] <lizmat> m: dd Blob.allocate(10,42)

[14:52] <camelia> rakudo-moar 9f7402: OUTPUT«Blob.new(42, 42, 42, 42, 42, 42, 42, 42, 42, 42)␤»

[14:52] <nine> Is there really no way to prevent dalek from getting kicked?

[14:52] <lizmat> m: my @int @a = ^10; dd Blob.allocate(20,@a)

[14:53] <camelia> rakudo-moar 9f7402: OUTPUT«5===SORRY!5=== Error while compiling /tmp/LF_vOVnurt␤Two terms in a row␤at /tmp/LF_vOVnurt:1␤------> 3my @int7⏏5 @a = ^10; dd Blob.allocate(20,@a)␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤   …»

[14:53] <lizmat> m: my int @a = ^10; dd Blob.allocate(20,@a)

[14:53] <camelia> rakudo-moar 9f7402: OUTPUT«Blob.new(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)␤»

[14:53] <lizmat> m: dd Blob.allocate(20,Blob.new(^10))

[14:53] <camelia> rakudo-moar 9f7402: OUTPUT«Blob.new(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)␤»

[14:54] * moritz would have expected the end to be zero-filled

[14:56] *** zpmorgan joined
[14:57] <perlpilot> could .new be made to do this?   Blob.new( :size(11), init(1,2,42), :repeat )   # something like this

[14:57] <dalek> rakudo/nom: 60a187d | lizmat++ | src/core/Buf.pm:

[14:57] <dalek> rakudo/nom: Introducing Buf:D.reallocate($elems)

[14:57] <dalek> rakudo/nom: 

[14:57] <dalek> rakudo/nom: Simple and straightforward without initialization options, as it's a

[14:57] <dalek> rakudo/nom: Buf and you can do with you want with it.

[14:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/60a187d5fe

[14:57] <perlpilot> er, :init

[14:57] *** virtualsue left
[14:58] * lizmat wonders whether jnthn was aware he's also the pumpking now ?

[14:58] <nine> This sounds like a reasonable strategy: https://github.com/sopel-irc/sopel/issues/952#issuecomment-162449543

[14:59] *** huggable joined
[15:00] <lizmat> perlpilot: the :init would be superfluous, as that's already any positionals that you pass

[15:01] <lizmat> Blob.new(*@init, :size(x), :repeat) # comments anyone?

[15:01] <lizmat> basically add 2 nameds to Blob.new

[15:01] <sortiz> The oracle branch of DBIish is now travis-ci clean and can be merged, objections anyone?

[15:02] <moritz> lizmat: somehow that feels like over-engineering. What's the use case for :repeat?

[15:02] *** buharin joined
[15:02] <buharin> hello :)

[15:02] <buharin> my friends

[15:02] <lizmat> moritz: repeating a non-null pattern for debugging, for instance

[15:02] <lizmat> buharin o/

[15:03] <moritz> lizmat: is that debugging sufficiently performance sensitive that it deserves its own parameter+

[15:03] <moritz> s/\+/?/

[15:03] <moritz> you could use (flat @list xx *)[^$size] or so

[15:04] <lizmat> moritz: indeed you could, and it would be slow

[15:04] <Juerd> I think it's a weird use case

[15:05] <perlpilot> moritz: repeating values is quite useful ...   If Blob.new(1, :size(20), :repeat) == PDL::ones(20)   (ones and zeroes got used all the time when I was doing PDL stuff)

[15:05] <arnsholt> :repeat would be similar to circular lists in Lisp, wouldn't it?

[15:05] *** prammer joined
[15:05] <arnsholt> An infinite list in finite space

[15:05] <moritz> arnsholt: no, just initialization

[15:05] <lizmat> arnsholt: except it would be limited to :size parameter

[15:05] <moritz> perlpilot: that convinces me more

[15:06] <Juerd> The one exceptional time you need something like this, you can also choose between a less performant list of integers or just reusing the buf, I think

[15:06] <lizmat> Juerd: this was mostly about immutable blobs

[15:07] <Juerd> perlpilot: I can see why you'd want to init the buf with a single repeated value, because you may want to match something that exists already (for example, eeproms are often shipped with every byte set to 0xff)

[15:07] <lizmat> m: dd Buf.allocate(100,0xff)

[15:07] <camelia> rakudo-moar 9f7402: OUTPUT«Buf.new(255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255…»

[15:08] *** vendethiel joined
[15:08] <lizmat> m: dd Blob.allocate(10,0xff)

[15:08] <camelia> rakudo-moar 9f7402: OUTPUT«Blob.new(255, 255, 255, 255, 255, 255, 255, 255, 255, 255)␤»

[15:08] <Juerd> So perlpilot's example would be Buf.allocate(20, 1), right?

[15:08] <perlpilot> Juerd: multiple repeating values can be used in convolutions (for example).

[15:08] <Juerd> Or Blob

[15:08] <lizmat> Juerd: yes

[15:08] <lizmat> yes

[15:08] <Juerd> perlpilot: I'm not saying it can't be useful

[15:09] <lizmat> and since the "1" is repeating, 1,2,3 should also be repeating

[15:10] <lizmat> moving this functionality to Blob.new with :size and :repeat optionals, I can live with

[15:10] <lizmat> I'll just hold off from doing anything here until we have consensus

[15:10] <lizmat> and if we don't have that by 6.c,1, I'll just rip it out again

[15:11] <lizmat> .oO( wouldn't be the first time)

[15:11] *** sufrostico joined
[15:13] <dalek> rakudo/nom: c9d4650 | PerlJam++ | CREDITS:

[15:13] <dalek> rakudo/nom: update pumpking in CREDITS

[15:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c9d4650e24

[15:13] <mst> lizmat: got to keep your revert count up to stay ahead of everybody else's :D

[15:17] <moritz> lizmat: fwiw perlpilot convinced me that :repeat probably isn't over-engineering

[15:20] *** kid511 joined
[15:22] *** kid51 left
[15:24] *** [Sno] joined
[15:26] *** gfldex_ joined
[15:26] *** [particle]1 joined
[15:26] *** camelia left
[15:27] *** sno left
[15:27] *** gfldex left
[15:27] *** [particle] left
[15:27] *** camelia joined
[15:29] *** ChanServ sets mode: +v camelia

[15:31] *** vendethiel left
[15:32] *** cdg joined
[15:36] *** buharin left
[15:38] *** virtualsue joined
[15:38] *** buharin joined
[15:39] <ab6tract> maybe it's not worth it (since the language itself guarantees it), but i don't see a decent way to test a compile time error (in this particular case, a sub sig constraint error)

[15:39] *** kjs_ left
[15:40] *** kjs_ joined
[15:41] <jnthn> ab6tract: throws-like takes a string, I think...it the EVAL's it

[15:42] <masak> m: use MONKEY-SEE-NO-EVAL; try EVAL q[sub foo($x, [$y, $z where * < 5]) { say $z }; foo(1, [2, 10])]; say "hi"; say $!

[15:42] <camelia> rakudo-moar c9d465: OUTPUT«hi␤Constraint type check failed for parameter '$z' in sub-signature␤  in sub foo at EVAL_0 line 1␤  in block <unit> at EVAL_0 line 1␤  in block <unit> at /tmp/pEEhJjomKu line 1␤␤»

[15:42] <masak> ab6tract: ^^

[15:43] *** ggoebel16 left
[15:43] <ab6tract> ahh

[15:43] <ab6tract> thanks

[15:43] <masak> wow, we've gone eval-paranoid recently...

[15:43] <masak> all-uppercase *and* a pragma. :)

[15:44] <geekosaur> it

[15:44] <geekosaur> it's eeeeeeeval

[15:44] <masak> but I guess I shouldn't complain

[15:45] <masak> 'cus it seems every time I do, another layer of paranoia is added :P

[15:45] <masak> I know some languages where eval isn't strictly curtailed, but more like a fundamental building block of the whole theory of the language...

[15:46] <masak> along with another thing called `apply`, which we don't have in Perl 6

[15:46] <lizmat> masak: that's 6.c, so around for ~ 2 months now ?

[15:46] <masak> yes, that sounds right

[15:46] *** sufrostico left
[15:51] *** kjs_ left
[15:51] <ab6tract> m: use Test; sub f { fail 'because' }; throws-like f(), Exception, message => 'because';

[15:51] <camelia> rakudo-moar c9d465: OUTPUT«    1..3␤Use of uninitialized value $desc of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in sub proclaim at /home/camelia/rakudo-m-inst-2/share/perl6/sources/C712FE6969F786C9380D643DF17E85…»

[15:52] <ab6tract> any idea why proclaim is complaining here?

[15:52] <lizmat> m: use Test; sub f { fail 'because' }; throws-like &f, Exception, message => 'because';

[15:52] <camelia> rakudo-moar c9d465: OUTPUT«    1..3␤    ok 1 - code dies␤    ok 2 - right exception type (Exception)␤    ok 3 - .message matches because␤ok 1 - did we throws-like Exception?␤»

[15:52] <ab6tract> beyond the obvious ;)

[15:53] <ab6tract> lizmat: thank you :D

[15:53] <lizmat> ab6tract: f() vs &f  :-)

[15:53] <ab6tract> lizmat: hrrmmm...

[15:54] <ab6tract> then how do i test a sub that takes args?

[15:54] <lizmat> m: use Test; sub f { fail 'because' }; throws-like { f() }, Exception, message => 'because';

[15:54] *** cbk2 left
[15:54] <camelia> rakudo-moar c9d465: OUTPUT«    1..3␤    ok 1 - code dies␤    ok 2 - right exception type (Exception)␤    ok 3 - .message matches because␤ok 1 - did we throws-like Exception?␤»

[15:54] <ab6tract> m: use Test; sub f($f) { say $f; fail 'because' }; throws-like &f('foo'), Exception, message => 'because';

[15:54] <camelia> rakudo-moar c9d465: OUTPUT«foo␤    1..3␤Use of uninitialized value $desc of type Any in string context␤Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in sub proclaim at /home/camelia/rakudo-m-inst-2/share/perl6/sources/C712FE6969F786C9380D643D…»

[15:55] <ab6tract> ok :)

[15:55] <lizmat> ab6tract: put it in a block

[15:55] <lizmat> aka Callable

[15:56] *** ggoebel16 joined
[15:56] <lizmat> afk for a bit&

[15:58] <ab6tract> thanks everyone for the help

[15:59] *** tmch joined
[16:02] <hoelzro> is there a notion of anything like "test warnings" for Test.pm6?

[16:02] <hoelzro> I was thinking about that test I mentioned earlier, the throws-like 'X::Comp', ..., payload => '...';

[16:03] *** autarch joined
[16:03] <hoelzro> even though it works because the exception *happens* to have a payload method, I think it might be nice if throws-like checked X::Comp's method list and warned "hey, the exception has a payload method, but X::Comp doesn't. Something feels wrong"

[16:04] *** pmurias joined
[16:07] *** Trey_ joined
[16:12] *** Trey_ left
[16:17] *** nakiro left
[16:20] *** Trey_ joined
[16:21] *** ricardo_ joined
[16:23] *** khw joined
[16:25] *** ggoebel16 left
[16:25] <dalek> DBIish/oracle: fb76c83 | (Salvador Ortiz)++ | t/ (3 files):

[16:25] <dalek> DBIish/oracle: Fix the mysql problem, remove old tests

[16:25] <dalek> DBIish/oracle: review: https://github.com/perl6/DBIish/commit/fb76c83655

[16:25] *** ggoebel16 joined
[16:27] *** Trey_ is now known as TreyHarris

[16:30] <dalek> rakudo-star-daily: 69fe09b | coke++ | log/ (9 files):

[16:30] <dalek> rakudo-star-daily: today (automated commit)

[16:30] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/69fe09b906

[16:32] *** kjs_ joined
[16:34] *** ggoebel16 left
[16:38] <dalek> Heuristic branch merge: pushed 119 commits to DBIish by salortiz

[16:39] *** Guest11189 is now known as alpha123

[16:40] *** fireartist left
[16:41] <MadcapJake> what does it mean when a field in a C struct has a number in brackets?

[16:42] <MadcapJake> e.g., «char 	reserved [32]»

[16:42] <sortiz> It's a char array.

[16:42] <flussence> sortiz++ # those Pg changes look really nice

[16:43] <MadcapJake> oh ok, so 32 char slots?

[16:43] <psch> i'd think about it as one char[32] slot vOv

[16:43] <MadcapJake> o_O

[16:43] <sortiz> MadcapJake, An inline array of 32 chars.

[16:43] <abraxxa> who is salortiz on github?

[16:44] <geekosaur> otherwise known as a string that can hold up to 31 chars (plus a terminating NUL)

[16:44] <MadcapJake> how do i capture that with repr('CStruct')? CArray[int8] ?

[16:44] <sortiz> abraxxa, I'm

[16:44] <abraxxa> sortiz: thanks for the Oracle branch fixes and merging!

[16:45] <abraxxa> sortiz++

[16:45] <nine> jnthn: what do you think about adding "changing a CORE.setting class into a role" to the ok list in the versioning guidelines? I can't find any down sides, but you may have interesting insights there :)

[16:45] <MadcapJake> CStruct doesn't recognize CArray for some reason

[16:46] <MadcapJake> wait nvm

[16:46] <abraxxa> sortiz: does that mean I can delete my fork on github and work directly in the DBIish repo (in a branch) from now on?

[16:46] *** ab6tract left
[16:47] <sortiz> abraxxa, two misplaced $sth.finish in Test/DBDish drove my crazy!

[16:47] <sortiz> abraxxa, Yes, sure.

[16:48] *** virtualsue left
[16:49] <MadcapJake> CStruct is giving me a compilation error about the types I'm using but I only have 4 int64's and one CArray[int8]

[16:49] *** dh7320 joined
[16:49] <abraxxa> sortiz: I guess you can also delete the oracle branch

[16:49] <japhb> (DBIish committers)++  # Lots of DBIish love of late, thank you all!

[16:50] <nine> .oO(20 years from now people are gonna wonder what's so "ish" about DBI)

[16:50] <sortiz> MadcapJake, need to see the case.

[16:51] <sortiz> abraxxa, no yet. :)

[16:52] <MadcapJake> sortiz, http://pastebin.com/QXk6ZmxH

[16:53] *** dh7320 left
[16:53] *** kjs_ left
[16:54] *** dh7320 joined
[16:54] <abraxxa> nine: MY plan is to use DBIish as playground for A DBI (whatever it will be called)

[16:55] *** zakharyas left
[16:55] <perlpilot> MadcapJake: it's those where clauses

[16:56] <MadcapJake> ohh, can't use those on cstruct fields eh?

[16:56] <abraxxa> have to go now, bye!

[16:56] *** dh7320 left
[16:56] *** dh7320 joined
[16:56] *** kjs_ joined
[16:56] *** abraxxa left
[16:57] *** FROGGS left
[16:57] *** skids joined
[16:59] <sortiz> MadcapJake, indeed no. :(

[17:00] *** mkz left
[17:01] <nine> .tell abraxxa Makeshift solutions have the tendency to stick around much longer than people think when they implement them. Imagine people starting to use Perl 6 more and more, DBIish becoming better and better and the "real" DBI taking another 3-4 years to become usable. By then it will have a hard time catching up with a well established DBIish.

[17:01] <yoleaux> nine: I'll pass your message to abraxxa.

[17:01] <lizmat> perlpilot moritz: thinking more on Blob.new( :size, :repeat)

[17:02] <lizmat> :repeat could also be a number, but then what does :size mean ?

[17:02] *** mkz joined
[17:03] *** TimToady left
[17:03] *** telex left
[17:04] *** telex joined
[17:04] * flussence is cleaning up old github permissions I haven't used in years, apologies if it notifyspams anyone

[17:04] <perlpilot> what would :repeat mean as a number (to the Blob)?   repeat N times?

[17:06] <lizmat> :5repeat without :size would just essentially be () xx 5 as initializer (but faster)

[17:07] <lizmat> Blob.new((1,2,3) xx 5) vs Blob.new(1,2,3, :5repeat )

[17:08] <lizmat> it still feels better to me to have the special functionality in a separate allocate method, rather than trying to cram all functionality into .new

[17:08] <sortiz> lizmat, totally agree.

[17:08] *** vendethiel joined
[17:12] <TreyHarris> huh, → isn't a valid synonym for -> ? Was it at one time (I'm sure it was; I mean, "was it for any length of time longer than it took to break something?"), or am I just dreaming?

[17:12] <psch> .u right arrow

[17:12] <yoleaux> U+02C3 MODIFIER LETTER RIGHT ARROWHEAD [Sk] (˃)

[17:12] <yoleaux> U+02F2 MODIFIER LETTER LOW RIGHT ARROWHEAD [Sk] (˲)

[17:12] <yoleaux> U+034D COMBINING LEFT RIGHT ARROW BELOW [Mn] (◌͍)

[17:13] <perlpilot> lizmat: I can live with that I guess.   (it kinda feels like .allocate will be used more than .new though)

[17:13] <skids> → is the one that matches the texas under linux compose character.

[17:13] <TreyHarris> thought I could be clever and use my Haskell texas to unicode bindings for Perl 6 as well

[17:14] <TreyHarris> but every time I type -> I get → and that breaks

[17:14] <psch> yeah, i was just wondering how many there are, but it's apparently too many for yoleaux, in any case

[17:14] <perlpilot> .u →

[17:14] <yoleaux> U+2192 RIGHTWARDS ARROW [Sm] (→)

[17:16] <psch> but no, we only have '->' (and '<->') in token lambda currently

[17:16] <nine> CompUnit::PrecompilationStore @stores = Array[CompUnit::PrecompilationStore].new( $precomp.store ),

[17:16] <nine> I wonder if this ^^^ is really worth the type safety

[17:17] <perlpilot> lizmat: though, would you change .allocate to be like   .allocate(20, :init(1,2,42), :repeat)  ?

[17:20] <lizmat> again, why the :init, if Blob.new doesn't have that ?  

[17:20] <lizmat> also, I feel that :repeat should be the default, don't you think?

[17:21] <TreyHarris> psch: yep, see that. <-> is a synonym for ->, or does it have a different function I can't immediately recall? 

[17:21] <lizmat> and having a named default to true is also a design smell, is it not?

[17:21] <RabidGravy> sortiz++ # nice one on fixing up the DBIish

[17:23] *** ggoebel16 joined
[17:23] *** _mg_ joined
[17:23] <perlpilot> lizmat: all I know is .allocate(11,1,2,42)  feels wrong. What it does is slightly surprising. (i.e. same as Blob.new(1,2,42,1,2,42,1,2,42,1,2) )

[17:24] <RabidGravy> TreyHarris, <-> makes the parameters rw

[17:25] <lizmat> m: dd Blob.allocate(10, (1,2,3))   # perhaps remove the slurpy candidate, so you would have to specify a list ?

[17:25] <camelia> rakudo-moar c9d465: OUTPUT«Blob.new(1, 2, 3, 1, 2, 3, 1, 2, 3, 1)␤»

[17:25] <lizmat> perlpilot: ^^

[17:26] <TreyHarris> RabidGravy: oh, right, S06. forgot about that. so it wouldn't be as simple as just adding → to that token's alternation.

[17:26] <skids> Maybe just stick with .allocate(:size, :ival) and leave the case of a repeating multivalue pattern to be sped up by future optimization?

[17:27] <skids> I see less of a use case for filling with a pattern.

[17:27] <lizmat> "Blob.new(0 xx 10000) vs Blob.new(:initial-elems(10000)) -> 200.2908/s vs 38052.1614/s"  # I think we want it now ?

[17:27] <ugexe> what about :contents(1,2,3)? there is already a Buf.contents method

[17:27] *** ka joined
[17:27] <perlpilot> lizmat: that helps

[17:29] <dalek> rakudo/nom: 846d513 | lizmat++ | src/core/Buf.pm:

[17:29] <dalek> rakudo/nom: Remove the slurpy Blob.allocate candidate

[17:29] <dalek> rakudo/nom: 

[17:29] <dalek> rakudo/nom: If you want to initialize with a multi-byte pattern, you will need

[17:29] <dalek> rakudo/nom: to specify it as a list, so:

[17:29] <dalek> rakudo/nom: 

[17:29] <dalek> rakudo/nom:   Blob.allocate(100, (1,2,3))

[17:29] <dalek> rakudo/nom: 

[17:29] <dalek> rakudo/nom: versus:

[17:29] <dalek> rakudo/nom: 

[17:29] <dalek> rakudo/nom:   Blob.allocate(100, 1,2,3)

[17:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/846d513e18

[17:29] *** vendethiel left
[17:30] <lizmat> ugexe: we need something that can work on immutable blobs

[17:30] <perlpilot> lizmat++

[17:30] <skids> yes lizmat++

[17:31] <TreyHarris> RabidGravy: would it be as simple as splitting it up into two sym tokens with token lambda:sym«->» { '->' | '→' } and token lambda:sym«<->» { '<->' | '↔' }, and then... hrm, I'm not seeing where the distinction between the two lambdas is made in nqp, it isn't in NQP/Actions.nqp where I'd expect it...

[17:31] *** skids left
[17:31] <sortiz> lizmat++ # consensus

[17:31] <TreyHarris> (Sorry, I'm looking for something that will help me get up to speed and this seems like a very small bite to take a stab at.)

[17:32] <RabidGravy> TreyHarris, I'm almost certainly not the right person to be asking about this as I try to avoid that part of the code ;-)

[17:32] <ugexe> m: say Blob.new(0 xx 5).contents; # right, but the value of .contents here seems to match well enough to what you want to pass in to be repeated (.new(5, :contents(0))

[17:32] <camelia> rakudo-moar c9d465: OUTPUT«(0 0 0 0 0)␤»

[17:32] * lizmat likes to reach consensus by removing code  :-)

[17:32] <lizmat> but not too much :-)

[17:34] <TreyHarris> RabidGravy: understood.

[17:35] <TreyHarris> can anyone else give me a pointer? or, if adding a digraph synonym is a lot harder than it looks (my fruitless attempt just now to find where texas pointies are suggests it may be), tell me this is not a good newbie project?

[17:37] <TreyHarris> I haven't made any Perl 6 commits since Pugs days, and then I mostly just wrote tons of tests.

[17:38] *** SCHAAP137 joined
[17:39] *** agentzh left
[17:40] *** agentzh joined
[17:40] *** agentzh left
[17:40] *** agentzh joined
[17:40] *** lostinfog joined
[17:40] <flussence> adding bits to the core of the language is going to be much harder than, say, adding unicode multis for normal infix operators. definitely not an easy project to start off with

[17:41] *** dakkar left
[17:42] <TreyHarris> flussence: okay. it was trivial with Pugs (I need to clean out my ~src/p6 one of these days!), so I didn't know

[17:43] <TreyHarris> i almost always learn by scratching my own itch, so I'll continue with my userland project and see if and when the next itch scratches. er... something like that.

[17:45] *** bazzaar joined
[17:45] <bazzaar> \o good evening all

[17:46] <lizmat> bazzaar o/

[17:47] *** erdic left
[17:48] <bazzaar> perl6 really is a pleasure to utilise :)

[17:48] *** TimToady joined
[17:48] *** Actualeyes left
[17:49] *** erdic joined
[17:51] <bazzaar> spurt ('testfile',@aa) .... is it possible to control the output delimiter? set it to "\n"?

[17:52] <ugexe> @aa.join("\n")

[17:53] <ugexe> if you mean set the newline character you can do that too, but you do that on a string, not an array

[17:53] <psch> bazzaar: you can specify the output delimiter on a Handle with nl-out, see http://doc.perl6.org/routine/put#role_IO

[17:53] <psch> eh

[17:53] <psch> that's not what i wanted to link, the docs for IO::Handle explain it differently...

[17:54] <psch> oh, no, it's method put on IO::Handle 

[17:54] <psch> http://doc.perl6.org/type/IO::Handle here 

[17:54] *** ocbtec left
[17:55] <psch> well.  looks like i got a bit confused there.  the docs for sub put state it uses $handle.nl-out, on the page for IO::Handle

[17:55] *** musiKk joined
[17:55] <psch> ah, that's the same text as for put in class Mu...

[17:56] <dalek> rakudo/nom: 2afe79f | lizmat++ | src/core/Buf.pm:

[17:56] <dalek> rakudo/nom: Remove some superfluous returns

[17:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2afe79fa61

[17:57] *** vendethiel joined
[18:00] <MadcapJake> can you create typedefs with NativeCall?

[18:01] <DrForr> Structs and unions, yes.

[18:01] <timotimo> you can create typedefs even without nativecall

[18:01] <MadcapJake> what about for a callback?

[18:02] <timotimo> you may have to spell it different from inside a routine, but it should work

[18:02] <MadcapJake> how do you mean?

[18:02] <DrForr> Too bad there isn't a project out there that creates a complex struct and returns a linked list of them from a callback.... Oh, wait, there is :) I do that from Inline::Scheme::Guile :)

[18:02] *** firstdayonthejob joined
[18:03] <timotimo> m: sub foobar(&bar:(int32, int32)) { }

[18:03] <camelia> rakudo-moar 846d51: ( no output )

[18:03] <timotimo> m: sub foobar(&bar:(int32, int32)) { }; say &foobar.signature[0].perl

[18:03] <camelia> rakudo-moar 846d51: OUTPUT«:(&bar where { ... })␤»

[18:03] <timotimo> m: sub foobar(&bar:(int32, int32)) { }; say &foobar.signature[0].arguments[0].perl

[18:03] <camelia> rakudo-moar 846d51: OUTPUT«Method 'arguments' not found for invocant of class 'Signature'␤  in block <unit> at /tmp/f2L7dzQkJt line 1␤␤»

[18:03] <timotimo> what's it called

[18:03] <timotimo> m: sub foobar(&bar:(int32, int32)) { }; say &foobar.signature[0].parameters[0].perl

[18:03] <camelia> rakudo-moar 846d51: OUTPUT«Method 'parameters' not found for invocant of class 'Signature'␤  in block <unit> at /tmp/bF65PlfIdF line 1␤␤»

[18:03] <timotimo> m: sub foobar(&bar:(int32, int32)) { }; say &foobar.signature[0].params[0].perl

[18:03] <camelia> rakudo-moar 846d51: OUTPUT«&bar where { ... }␤»

[18:03] <timotimo> huh, it's a where clause? i must have written this wrong, then

[18:04] <bazzaar> ugexe : and psch : thankyou both for helping me. The documentation is really well laid out, I shall have to study it. usgexe your solution using .join is what I need I think.

[18:04] <psch> timotimo: i think it translated that to a constraint on the sig for the &-param

[18:04] <timotimo> could be

[18:04] <timotimo> what's the correct spelling? i haven't done this in ages :)

[18:04] <psch> timotimo: 'cause we don't have subtypes for Signatures with specific parameters

[18:05] <psch> (which i think is perfectly fine... :) )

[18:06] <nine> timotimo: &bar (int32, int32)

[18:06] <nine> The space is important

[18:06] <psch> m: sub f(&b:(Int, Str)) { say "k" }; f( sub (Int $, Str $) {}); f( sub (Str $, Str $) {} )

[18:06] <camelia> rakudo-moar 846d51: OUTPUT«k␤Constraint type check failed for parameter '&b'␤  in sub f at /tmp/1sfL_Dh66g line 1␤  in block <unit> at /tmp/1sfL_Dh66g line 1␤␤»

[18:06] <psch> isn't the space for unpacking?

[18:07] <psch> e.g. @a ($head, @tail)

[18:07] <MadcapJake> so if I take foobar and place it in the signature of a native sub, it will "unbox" to the signature inside foobar?

[18:08] * psch isn't sure how all that interacts with NativeCall though vOv

[18:08] <nine> psch: oh, indeed!

[18:09] <nine> Intriguingly it still worked with NativeCall

[18:10] *** espadrine left
[18:11] <lizmat> m: sub byte() { ... }; byte()  # warning appears inappropriate

[18:11] <camelia> rakudo-moar 846d51: OUTPUT«WARNINGS for /tmp/_bsOqb4TPE:␤Useless use of constant value byte() in sink context (line 1)␤»

[18:11] <lizmat> and it should die because of the yadayadayada?

[18:11] <psch> m: sub Int() {...}; Int()

[18:11] <camelia> rakudo-moar 2afe79: OUTPUT«WARNINGS for /tmp/JR7oQkRElb:␤Useless use of constant value Int() in sink context (line 1)␤»

[18:12] <lizmat> I guess it's a case of DIHWIDT

[18:12] <timotimo> what i was meaning is that you may have to spell it like "constant ThatCallback = Routine[Foo, (Bar, Baz)] or something

[18:12] *** _mg_ left
[18:16] *** xinming left
[18:16] <bazzaar> spurt "testfile", @aa.join("\n") ;   ...... this works a charm, would it be worth adding to the documentation of spurt?

[18:16] *** FROGGS joined
[18:18] <FROGGS> o/

[18:18] <psch> \o

[18:18] *** xinming joined
[18:19] <jnthn> nine: Well, it would work in so far as role punning means .new and inheritance still work. Introspection might look a bit different, though. And, of course, no adding requirements (... methods).

[18:20] <nine> jnthn: introspection always means MOP, doesn't it? And the MOP is implementation specific.

[18:22] *** donaldh left
[18:23] <psch>     public static SixModelObject findmethod(SixModelObject invocant, String name, ThreadContext tc) {

[18:23] <psch>     public static SixModelObject findmethod(ThreadContext tc, SixModelObject invocant, String name) {

[18:23] <nine> Though I wonder how well we could keep up the latter if an alternative Perl 6 implementation came along.

[18:23] <psch> that seems a bit... weird

[18:23] <psch> i mean, i get that two candidates might make sense, but differntiating them by *order* of identical parameters..? :/

[18:25] *** boegel left
[18:28] <jnthn> nine: I suspect the MOP will get increasingly test-covered over time.

[18:29] <lizmat> nine: making Baggy inherit from typed hashes was also considered a nono

[18:29] <lizmat> because of changed introspection

[18:32] <jnthn> nine: Which type are you thinking of changing that way?

[18:32] <nine> Distribution

[18:32] <jnthn> Hm

[18:33] <jnthn> I'd agree the risk of problems on that one is quite low. :) But curious about the rationale?

[18:33] <nine> Not exactly one that's gonna be used in user code all that often :)

[18:34] <nine> ugexe++ suggested having repository specific implementations of Distribution for better code structuring and better composability.

[18:35] <jnthn> I think I can see it... :)

[18:35] *** bazzaar left
[18:35] <nine> So a CompUnit::Repository::Installation::Distribution would know how to find its resources, source files, etc. and we'd no longer have to pass them separatly to $repo.install

[18:37] <nine> Or rather that you could pass a Distribution::Tar/Distribution::GitHub or whatever object to .install while $comp-unit.distribution would return the CompUnit::Repository::Installation::Distribution object

[18:37] <jnthn> *nod*

[18:37] <jnthn> No objections.

[18:37] <nine> \o/

[18:38] <lizmat> fwiw, +1 from me too

[18:39] *** boegel|quassel joined
[18:39] <jnthn> bbl

[18:40] *** boegel|quassel is now known as boegel

[18:40] *** boegel left
[18:42] *** boegel joined
[18:43] *** skids joined
[18:43] <[Coke]> so, I may have jumped the gun putting jnthn down as pumpking - we don't really have a defined role for that in the project, but I was thinking of it as a combo of his role as lead dev and generator of a lot of the release docs that we're now trying to follow. so, if we end up changing that line or putting out a clarification or whatever, there wasn't a coup or anything. :)

[18:43] <[Coke]> jnthn++ pmichaud++

[18:46] <lizmat> [Coke]++    # moving forward on the issue :-)

[18:51] <lizmat> if I look at the role of the P5 pumpking, it is much more a manager's role in the background

[18:52] <lizmat> [Coke]: one, I might add, has been played a lot by you already

[18:52] <El_Che> with the customary "herding cats" experience in the resumé :)

[18:56] <dalek> rakudo/nom: 4f33801 | lizmat++ | src/core/ (3 files):

[18:56] <dalek> rakudo/nom: No longer show module compile errors twice

[18:56] <dalek> rakudo/nom: 

[18:56] <dalek> rakudo/nom: Fixes RT #127176

[18:56] <dalek> rakudo/nom: 

[18:56] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=127176

[18:56] <dalek> rakudo/nom: This is done by adding a VERBATIM-EXCEPTION capability to Exception,

[18:56] <dalek> rakudo/nom: by means of a special Rakudo::Internals.VERBATIM-EXCEPTION semaphore

[18:56] <dalek> rakudo/nom: which is set when precompilation dies and we need to exit

[18:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4f338014ae

[18:59] <nine> lizmat: what do we do with STDERR output when precomp succeeds?

[19:00] <lizmat> nine: hmmm.. like warnings?  hmmm... good point, they get eaten now

[19:01] <lizmat> I guess the easiest solution would be to note() them ?

[19:01] <nine> Think so, yes.

[19:02] <lizmat> testing...

[19:04] <lizmat> yeah, seems to do the trick, spectesting for issues

[19:05] <nine> lizmat++

[19:06] *** cdg left
[19:08] <lizmat> hmmm... note is adding an extra \n  ....  $*ERR.print it is then :-)

[19:12] *** musiKk left
[19:16] <dalek> rakudo/nom: ac88669 | lizmat++ | src/core/CompUnit/PrecompilationRepository.pm:

[19:16] <dalek> rakudo/nom: Make sure we don't eat warnings during precomp

[19:16] <dalek> rakudo/nom: 

[19:16] <dalek> rakudo/nom: Also, we don't need the else, as we're dying in the if before

[19:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ac88669fff

[19:17] *** leont joined
[19:17] *** spider-mario joined
[19:27] *** Cabanossi left
[19:29] *** n0tjack joined
[19:30] *** Cabanossi joined
[19:32] *** kjs_ left
[19:34] <lizmat> hmmm... I wonder if it would make sense to make Blob.list an iterator, rather than copying the whole Blob right away

[19:34] *** Ven joined
[19:35] *** [Sno] left
[19:36] <sortiz> I think it's a good idea.

[19:38] <sortiz> lizmat, Especially by the saving in memory.

[19:41] <timotimo> well, it's also about semantics

[19:41] <timotimo> what happens when you iterate over the buf and change it at the same time

[19:42] <timotimo> do you want to iterate over the new values when you reach them ("lazy" semantics) or do you want the original values to come out of the iterator?

[19:42] *** molaf left
[19:45] <[Coke]> timotimo: didn't we already decide that during the GLR?

[19:46] <timotimo> well, for arrays perhaps

[19:46] <timotimo> potentially not for bufs :)

[19:47] *** KotH left
[19:48] <sortiz> A more interesting question to me is, can I acquire a lock over an object for the current thread?

[19:48] <lizmat> what would that give you ?

[19:49] <lizmat> do you want to bar access from other threads ?

[19:49] <sortiz> Yes, ban other threads for atomic changes, for example.

[19:50] <jnthn> sortiz: OO::Monitor

[19:51] *** kjs_ joined
[19:51] <jnthn> Uh, OO::Monitors :)

[19:51] <jnthn> You can't "ban other threads" with a lock

[19:51] <sortiz> jnthn, I knew there was an answer! Thank you.

[19:51] <jnthn> Locks require everyone to play ball :)

[19:51] <sortiz> Sure, cooperative lock.

[19:51] <jnthn> So, structure your code so that all access to the data goes through some point of control.

[19:52] <jnthn> OO::Monitors is one way to achieve that.

[19:52] <timotimo> well, you can "ban other threads" in general

[19:52] <timotimo> you just have to turn off interrupts on the CPU

[19:52] <jnthn> (You know that only one thread will ever be inside any of the object's methods at a time)

[19:54] * sortiz There is much to study ahead

[19:56] <jnthn> Generally, you can get a fair way with concurrent design by doing OO design really well :)

[19:56] <jnthn> (Following "tell, don't ask" and the like)

[19:57] *** zakharyas joined
[19:57] <jnthn> The other major strategy I tend to turn to being finding a way to look at the information as an event stream, then using supplies.

[19:58] <sortiz> I understand the concepts.

[19:58] *** zpmorgan left
[20:01] <sortiz> Unfortunately the user documentation is incomplete, so I resort to the code.

[20:02] <jnthn> sortiz: For what in particular?

[20:02] <jnthn> If you're not already and have time, please file issues on doc.perl6.org for things you miss

[20:03] *** Rotwang left
[20:03] *** Rotwang joined
[20:03] <skids> https://gist.github.com/skids/fabd0304f40e24db33d0 is my list of Supply questions

[20:03] *** Rotwang left
[20:05] <sortiz> Just an example: Yesterday I *discover* that 'is native' methods are possible.

[20:06] <sortiz> And works like a charm!

[20:07] *** ggoebel16 left
[20:07] <sortiz> jnthn, When I have time, I prefer fill the blanks ;)

[20:07] <sortiz> *to fill

[20:07] <timotimo> sortiz: you seem to think supplies are a method to introduce parallelism

[20:07] <timotimo> they never introduce additional parallelism. that's their design, really

[20:08] <timotimo> so different taps on some supply should not run in parallel

[20:08] <sjn> \o

[20:08] <timotimo> o/ sjn 

[20:09] * sjn tries to search doc.perl.org for docs on ENV

[20:09] <sjn> getting no hits :-\

[20:09] <sjn> is there a way to fix that?

[20:10] <skids> timotimo: were you actually referring to my gist?

[20:10] <moritz> sjn: lots of ways to fix that, all of them involve quite some work :/

[20:11] <sortiz> timotimo, What makes you think that? I haven't mentioned Supplies.

[20:11] <mst> sjn: try goolging with 'site:' ?

[20:12] <sortiz> %*ENV is mentioned in http://doc.perl6.org/language/variables#Dynamic_variables

[20:12] <sjn> mm, found it

[20:12] <sjn> wish it was simpler to find

[20:13] * sjn munches some cheese with his whine

[20:14] <jnthn> skids: Writing you some answers.

[20:15] <lizmat> .oO( wite whine ?)

[20:17] *** darutoko left
[20:20] *** yqt joined
[20:21] <lizmat> m: my $b = Buf.new(1,2,3); for @$b { $_ = 42 }   # so, do we want this to work for Buf?

[20:21] <camelia> rakudo-moar ac8866: OUTPUT«Cannot assign to an immutable value␤  in block <unit> at /tmp/YAdS1J2uCk line 1␤␤»

[20:21] <timotimo> sortiz: sorry, i meant skids

[20:23] <sortiz> While installing OO::Monitors: ==> Testing OO::Monitors

[20:23] <sortiz> t/basic.t ...... ok

[20:23] <sortiz> Weird node visited: QAST::BVal

[20:23] <lizmat> jnthn: my $b = Buf.new(1,2,3); for @$b { $_ = 42 }  # do we want this to work ?

[20:25] <timotimo> lizmat: the default is to have <-> $_, right?s o i'd expect this to work

[20:25] <lizmat> ok, I'll see if I can make that work

[20:25] <lizmat> not so for Blob, right ?

[20:25] <timotimo> sounds like you want atposref_* for this?

[20:25] <timotimo> no, not for blob

[20:25] <skids> timotimo: Personally I'm more interested in managing parallel events than having blocking automatically added to my code -- I realize this is not the common use case.  The serial supply changes left me wondering how to go about preserving the API for non-serial supplies since every api call transforms to serials.  In any case it all needs doccing, so I'll unstash my S17 patch and look at jnthn++'s answers and do what I can.

[20:26] <jnthn> sortiz: I'm aware of the warning; it's harmless, I think

[20:26] <timotimo> skids: OK, i see you're on top of things :)

[20:26] <lizmat> timotimo: looks like it

[20:26] <timotimo> BBIAB

[20:29] *** ggoebel16 joined
[20:29] <sortiz> Building blocks like OO::Monitors deserve to be in core, IMO.

[20:30] <lizmat> sortiz jnthn warnings confirmed

[20:34] <jnthn> sortiz: There are dozens of such things I could make that we'd be able to classify as "building blocks" in the same way, though.

[20:34] *** musiKk joined
[20:35] <sortiz> jnthn, They should at least be mentioned in a prominent place :)

[20:36] <sortiz> Hardly I had found on my own.

[20:36] <jnthn> sortiz: Yeah. When I wrote a .Net concurrency course, I made a few decision trees for folks. 

[20:36] <jnthn> sortiz: Maybe I should try and port them to Perl 6 :)

[20:40] <sortiz> Well, by the time I leave. DBIish robbed me several hours of sleep ;)

[20:40] <sortiz> o/ #perl6

[20:41] <lizmat> sortiz o/

[20:44] <jnthn> o/

[20:45] *** sufrostico joined
[20:48] <jnthn> skids: https://gist.github.com/jnthn/04999dd3af5c9df91a17

[20:48] <jnthn> Probably a worthwhile read for anyone else interested in concurrency stuff too

[20:50] <skids> Thanks jnthn++

[20:50] <Hotkeys> jnthn++

[20:51] *** sufrosti1o joined
[20:53] *** sufrostico left
[20:56] *** kaare_ left
[21:01] <DrForr> I'm having trouble tracing an error through a callback.

[21:01] <perigrin> use thinner onion paper.

[21:04] <DrForr> There's nothing useful being reported after 'Failed'. It does report the line where the function was un, but nothing beyond that. And eliminating the callback is not an option.

[21:06] *** [Sno] joined
[21:10] *** spintronic joined
[21:10] *** ka left
[21:13] *** _dolmen_ joined
[21:14] <timotimo> callbacks are really problematic, yeah

[21:14] <timotimo> you mean NativeCall, right?

[21:14] <DrForr> No, this is Crust.

[21:15] *** gfldex_ is now known as gfldex

[21:15] *** cdg_ joined
[21:18] <timotimo> oh

[21:18] *** _dolmen_ left
[21:21] <DrForr> I'll worry about it tomorrow, I suppose.

[21:22] <dalek> rakudo/nom: f25d41c | lizmat++ | src/core/ (2 files):

[21:22] <dalek> rakudo/nom: Streamline Blob|Buf.list

[21:22] <dalek> rakudo/nom: 

[21:22] <dalek> rakudo/nom: - use iterator, so that we don't need to copy the buffer when iterating

[21:22] <dalek> rakudo/nom:   element by element

[21:22] <dalek> rakudo/nom: - split into Blob/Buf candidates

[21:22] <dalek> rakudo/nom: - Buf candidate passes rw value when iterating ($_++ for @$buf works)

[21:22] <dalek> rakudo/nom: - add BlobbyIterator role, for general usage in other situations

[21:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f25d41c678

[21:24] <FROGGS> lizmat++

[21:27] <lizmat> enough hacking for today, good night #perl6!

[21:28] <FROGGS> gnight lizmat 

[21:31] *** musiKk left
[21:33] *** buharin left
[21:33] *** sufrosti1o left
[21:34] *** _dolmen_ joined
[21:36] *** spintronic left
[21:36] *** spintronic joined
[21:37] *** sufrostico joined
[21:40] *** FROGGS left
[21:40] *** TreyHarris left
[21:41] *** labster joined
[21:42] *** zakharyas left
[21:44] <Hotkeys> I've never really thought to ask: What exactly is 'sink context'

[21:45] <timotimo> it's when something that produces a value doesn't get its value put into anything

[21:45] <timotimo> it's mostly important for lazy lists and stuff that we want to have evaluated for side-effects

[21:47] <Hotkeys> ah

[21:47] <Hotkeys> why is it called sink context?

[21:47] <mst> people often use source/sink to mean producer and consumer of values

[21:47] <moritz> because the returned value just disappears into the kitchen sink

[21:48] <mst> in this case it's a context that basically consumes the value itself

[21:49] <Hotkeys> ah

[21:49] <Hotkeys> okay, thanks

[21:49] *** espadrine joined
[21:50] <mst> reasonably mnemonic once you understand it, I think

[21:50] <mst> (in that I was basically able to reverse engineer it in my head just now :)

[21:50] *** cosarara left
[21:52] *** ely-se joined
[21:55] *** cosarara joined
[21:55] *** TreyHarris joined
[21:58] *** n0tjack left
[22:04] <skids> The etymology probably comes via electrical engineering where sinking circuits provide a return to ground.  Of course, thanks to Ben Franklin, ground is actually the *source* of electrons, so we just have to pretend everything is made out of aluminum or other hole carriers to feel good about it.

[22:06] <skids> (Or build all our circuits upside down with a positive ground)

[22:06] *** spintronic left
[22:06] *** spintronic joined
[22:07] * skids decommute

[22:07] *** skids left
[22:08] *** ely-se left
[22:10] <Skarsnik> sortiz, hm, why did you put Real and Num in Pg? I think the idea was to have all float in Rat x)

[22:15] <MadcapJake> how would I represent a C struct field that holds a function?

[22:16] *** Ven left
[22:16] *** spintronic left
[22:20] *** autarch left
[22:22] <Skarsnik> Pointer

[22:22] <Skarsnik> you can't call it, it's not implemented

[22:22] *** TEttinger joined
[22:28] *** ka joined
[22:32] *** prammer left
[22:34] *** labster left
[22:34] *** john51_ joined
[22:35] *** Skarsnik left
[22:37] *** ka left
[22:38] *** john51 left
[22:41] *** labster joined
[22:47] *** SCHAAP137 left
[22:48] *** prammer joined
[22:49] <RabidGravy> MadcapJake, if you want to call them then you need to make a tiny C wrapper which you pass the pointer and the rest of the arguments to actually execute it

[22:49] *** pmurias left
[22:52] *** prammer left
[22:53] *** prammer joined
[22:55] *** prammer left
[22:58] *** vendethiel left
[23:01] *** lsm-desktop joined
[23:03] *** kjs_ left
[23:07] *** AndyDee joined
[23:12] *** abaugher left
[23:17] *** rburkholder joined
[23:17] *** abaugher joined
[23:26] *** spider-mario left
[23:29] *** adu joined
[23:33] *** lostinfog left
[23:34] *** skids joined
[23:41] *** RabidGravy left
[23:52] *** rindolf left
[23:59] *** sevvie left
