[00:00] *** djbkd joined
[00:01] *** WAAM811 joined
[00:04] *** Matthew[m] left
[00:04] *** ilmari[m] left
[00:04] *** tadzik left
[00:04] *** Matias[m] left
[00:04] *** scott left
[00:04] *** M-Illandan left
[00:13] *** djbkd left
[00:14] *** MasterDukeLaptop joined
[00:15] *** djbkd joined
[00:16] *** itaipu joined
[00:22] *** Juerd_ joined
[00:27] *** djbkd left
[00:27] *** djbkd joined
[00:33] *** Juerd_ is now known as Juerd

[00:33] *** Xliff joined
[00:34] <Xliff> \0 #perl6

[00:34] <Xliff> Oh my word, the Luke Cage show is awesome. Only watched ep 1

[00:34] <Xliff> But it was guuud

[00:35] *** mcmillhj left
[00:37] *** RabidGravy left
[00:41] *** djbkd left
[00:43] *** zakharyas joined
[00:43] *** kent\n left
[00:44] *** mempko left
[00:45] *** djbkd joined
[00:52] *** wamba left
[00:57] *** djbkd left
[00:58] *** djbkd joined
[01:00] *** grondilu left
[01:10] *** djbkd left
[01:15] *** djbkd joined
[01:21] *** Dunearhp left
[01:24] *** eliasr left
[01:28] *** djbkd left
[01:32] *** itaipu left
[01:33] *** djbkd joined
[01:34] *** itaipu joined
[01:42] *** mcmillhj joined
[01:46] *** ilbot3 left
[01:47] *** ilbot3 joined
[01:49] *** djbkd left
[01:51] *** baest left
[01:52] *** djbkd joined
[01:52] *** mcmillhj left
[01:53] *** baest joined
[01:53] *** ilmari[m] joined
[01:57] *** AlexDaniel left
[02:02] *** user9 left
[02:03] *** noganex_ joined
[02:06] *** pierre_ joined
[02:06] <seatek> eeuw. perl6 --doc output is ...  flat

[02:07] *** djbkd left
[02:07] *** noganex left
[02:10] *** djbkd joined
[02:14] *** bstamour joined
[02:14] <dalek> doc: 09662f5 | (Tom Browder)++ | doc/Language/grammars.pod6:

[02:14] <dalek> doc: add missing results for examples

[02:14] <dalek> doc: review: https://github.com/perl6/doc/commit/09662f54f3

[02:17] *** djbkd left
[02:17] *** bstamour left
[02:18] *** bstamour joined
[02:19] *** bstamour left
[02:20] *** bstamour joined
[02:20] *** djbkd joined
[02:23] *** labster left
[02:34] *** djbkd left
[02:40] *** djbkd joined
[02:41] *** sufrostico left
[02:48] *** nadim left
[03:03] *** rgrinberg joined
[03:07] *** BenGoldberg left
[03:08] *** pierre_ left
[03:08] *** MasterDukeLaptop left
[03:09] *** pierre_ joined
[03:13] *** pierre_ left
[03:47] *** djbkd left
[03:53] *** djbkd joined
[04:10] *** djbkd_ joined
[04:10] *** pierre_ joined
[04:11] *** itaipu left
[04:13] *** djbkd left
[04:17] *** pierre_ left
[04:30] *** Zoffix joined
[04:30] *** Zoffix left
[04:41] *** canopus left
[04:46] *** canopus joined
[04:50] *** kaare_ joined
[04:58] *** Cabanossi left
[05:01] *** Cabanossi joined
[05:36] *** wamba joined
[05:49] *** skids left
[06:14] *** pierre_ joined
[06:14] *** canopus left
[06:16] *** domidumont joined
[06:19] *** pierre_ left
[06:20] *** domidumont left
[06:20] *** rgrinberg left
[06:21] *** tadzik joined
[06:21] *** Matias[m] joined
[06:21] *** M-Illandan joined
[06:21] *** scott joined
[06:21] *** Matthew[m] joined
[06:21] *** domidumont joined
[06:22] *** canopus joined
[06:28] *** domidumont left
[06:37] *** djbkd_ left
[06:41] *** TEttinger left
[06:41] *** djbkd joined
[06:44] *** seatek left
[06:49] *** setty1 left
[06:53] *** setty1 joined
[06:55] *** wamba left
[06:59] *** djbkd left
[07:01] *** djbkd joined
[07:02] *** pierre_ joined
[07:04] *** pierre_ left
[07:12] *** darutoko joined
[07:19] *** pierre_ joined
[07:19] *** domidumont joined
[07:22] *** pierre_ left
[07:24] *** pierre_ joined
[07:24] *** pierre_ left
[07:24] *** buggable left
[07:27] *** robertle joined
[07:30] *** pierre_ joined
[07:43] *** pierre_ left
[07:45] *** imcsk8 joined
[07:51] *** FROGGS joined
[07:53] <FROGGS> o/

[07:54] <psch> o/

[08:11] *** domidumont left
[08:12] *** domidumont joined
[08:20] *** labster joined
[08:22] *** rindolf joined
[08:24] *** pmurias joined
[08:51] *** domidumont left
[08:54] *** domidumont joined
[08:57] *** nadim joined
[08:59] *** domidumont left
[09:21] *** Dunearhp joined
[09:21] *** Dunearhp left
[09:42] *** RabidGravy joined
[09:47] *** pierre_ joined
[09:48] *** mniip joined
[09:52] *** kurahaupo left
[09:56] *** FROGGS left
[09:57] *** shadowpaste left
[09:59] *** aindilis left
[10:00] *** aindilis joined
[10:04] <RabidGravy> boom!

[10:09] *** pierre_ left
[10:10] *** domidumont joined
[10:17] *** grondilu joined
[10:21] *** labster left
[10:22] *** pecastro left
[10:22] *** pecastro joined
[10:41] *** mcmillhj joined
[10:46] *** iH2O joined
[10:46] *** mcmillhj left
[10:48] *** iH2O left
[10:48] *** domidumont left
[10:51] *** wamba joined
[10:55] *** zakharyas left
[10:55] *** zakharyas joined
[10:56] *** MARTIMM joined
[10:59] * grondilu wonders why `prove` doesn't accept `plan *`

[10:59] <grondilu> or rather prove -e perl6

[11:00] *** zakharyas left
[11:07] <psch> grondilu: isn't it Test.pm should would have to support it?  also, what is it supposed to mean?  afaik TAP supports either a fixed number of tests or done_testing

[11:07] <psch> s/should/that/

[11:07] <psch> where "done_testing" means a message over the protocol that all tests have been executed

[11:08] <grondilu> psch: yes, it's about Test.pm, my bad.

[11:09] *** pierre_ joined
[11:10] <grondilu> and what I meant is that if I do : $ PERL6LIB=lib prove -e perl6 t/, it will fail with 'no plan' if one of the test files has 'plan *'

[11:10] <psch> m: use Test; say plan *

[11:10] <camelia> rakudo-moar 46e0ed: OUTPUT«1475320238.58462␤»

[11:10] <psch> m: use Test; say (plan *).WHAT

[11:10] <camelia> rakudo-moar 46e0ed: OUTPUT«(Num)␤»

[11:10] <psch> i actually don't know what &plan returns

[11:11] <grondilu> forcing me to manually count the tests I do in the file and put the actual count in the plan.

[11:11] *** pierre_ left
[11:11] <psch> m: use Test; ok 1; ok 1; ok 1; done-testing

[11:11] <camelia> rakudo-moar 46e0ed: OUTPUT«ok 1 - ␤ok 2 - ␤ok 3 - ␤1..3␤»

[11:11] <psch> grondilu: that's what done-testing is for

[11:12] <grondilu> oh, ok.  I did not know that done-testing was a thing.

[11:13] <grondilu> psch++ thanks

[11:14] * grondilu will have to read S24 again one day

[11:15] <grondilu> miniPerl, a Turing-complete subset of Perl compiling to javascript:

[11:15] <grondilu> https://github.com/grondilu/miniPerl

[11:16] *** Khisanth left
[11:17] <psch> grondilu: fwiw, 'plan *' is equivalent to no &plan call and you can use it the same, i.e. with &done-testing

[11:17] <psch> which might be a good idea for explicitness

[11:21] *** itaipu joined
[11:23] *** djbkd left
[11:26] *** djbkd joined
[11:29] *** Khisanth joined
[11:34] *** grondilu left
[11:35] *** andrzejku joined
[11:39] *** djbkd left
[11:39] *** andrzejku left
[11:40] *** andrzejku_ joined
[11:40] *** andrzejku_ left
[11:40] *** andrzejku joined
[11:41] *** andrzejku left
[11:41] *** djbkd joined
[11:45] *** pierre_ joined
[11:47] *** andrzejku joined
[11:48] *** andrzejku left
[11:48] *** pierre_ left
[11:49] *** andrzejku joined
[11:49] *** andrzejku left
[11:50] *** andrzejku joined
[11:50] *** itaipu left
[11:52] *** domidumont joined
[11:52] *** djbkd left
[11:56] *** djbkd joined
[11:56] *** grondilu joined
[11:57] <pmurias> grondilu: you want to grow miniPerl into something bigger or will it stay in it's current lambda calculus form?

[11:58] <grondilu> I want to try anyway

[11:59] <pmurias> grondilu: have you looked at the nanopass compilers?

[11:59] <grondilu> no

[12:00] *** pierre_ joined
[12:02] *** kaare_ left
[12:02] *** domidumont left
[12:03] <pmurias> it's in scheme but they seem to be using the have a bazillion intermediate languages/passes approach you where proposing

[12:04] <grondilu> yeah, I've just read the description and indeed that looks like what I was talking about.

[12:04] <grondilu> I know close to nothing about Scheme, though.

[12:05] * pmurias has only used it for writing gimp extensions

[12:05] <pmurias> (a long time ago)

[12:05] *** shadowpaste joined
[12:05] <grondilu> I can extend grammars in Perl 6, can't I?  So I guess I can stick to perl.

[12:06] <pmurias> having the intermediate expressions in tree/s-expr for seems much more saner then having them textual

[12:07] * grondilu did not think about using s-expr

[12:08] *** djbkd left
[12:10] *** djbkd joined
[12:12] <pmurias> grondilu: is your goal more to explore the multi pass idea or get a perlish language that compiles to javascript?

[12:12] <grondilu> honestly I don't quite understand how they work.  For instance what is the s-expr for sub {}()  ?

[12:12] <grondilu> pmurias: both

[12:12] <grondilu> or rather, a perlish language that compiles to lambda-calculus.

[12:14] *** KotH is now known as Gandalf

[12:15] *** Gandalf is now known as KotH

[12:18] <tbrowder> good morning (US CDT), #perl6, anyone awake?

[12:18] <timotimo> greetings tbrowder 

[12:19] <pmurias> tbrowder: hi

[12:19] * lizmat is awake fsvo

[12:19] <pmurias> grondilu: s-exprs are a notation for writing lists

[12:19] <tbrowder> hi!  I am ready to release a new P6 module and would appreciate anyone who can take the time to check  it: see https://github.com/tbrowder/Net-IP-Lite-Perl6

[12:20] <tbrowder> hi all!

[12:21] <tbrowder> i'll let it percolate a day or two...

[12:22] <grondilu> I thought they could be used to writing programs as well.  I guess they can with if you add a "call" function or something.

[12:22] <grondilu> but that looks like a hassle.

[12:23] *** Ven_ joined
[12:23] *** djbkd left
[12:24] * grondilu thought about generating actual lambda-calculus expression but couldn't quite cope with parenthesis rules.

[12:25] *** djbkd joined
[12:29] <pmurias> grondilu: when you are writing lisp you are basically writing programs as lists

[12:30] *** Ven_ left
[12:34] *** pierre_ left
[12:37] *** djbkd left
[12:39] *** djbkd joined
[12:39] <grondilu> correct me if I'm wrong.  The s-exp for sub {} is (() ()) and the one for sub {}() is (call (() ()))  

[12:41] *** BenGoldberg joined
[12:42] *** itaipu joined
[12:51] *** djbkd left
[12:52] <arnsholt> Depends on the exact Lisp you're programming in

[12:52] <arnsholt> In CL declaration is (defun subroutine (args) ...) and call is (subroutine ...)

[12:52] *** djbkd joined
[12:53] <arnsholt> If you have a varaible containing a function, you need to do (funcall var ...) because CL is a Lisp-2

[13:01] *** noninc joined
[13:03] <noninc> hello! I am pondering on the possibility to make a portable version of perl6+moarvm on windows. It seems the rakudo binaries have a hardcoded prefix.

[13:04] <noninc> Is there a sensible / simple way of making rakudo use relative paths?

[13:05] *** djbkd left
[13:08] *** djbkd joined
[13:08] *** kent\n joined
[13:09] <dalek> perl6-examples: 2bb7126 | (Mathieu Gagnon)++ | categories/interpreters/lisp.pl:

[13:09] <dalek> perl6-examples: Fix lisp interpreter test

[13:09] <dalek> perl6-examples: 

[13:09] <dalek> perl6-examples: Make `perl6 lisp.pl --test` pass again.

[13:09] <dalek> perl6-examples: « is for word quoting with interpolation so changing for q.

[13:09] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/2bb7126d3f

[13:10] <[ptc]> hey cool!  (Mathieu Gagnon)++

[13:11] <grondilu> arnsholt: I only have anonymous subroutines so far.  How do you call an anonymous function in lisp?

[13:11] *** mohae_ joined
[13:11] <arnsholt> grondilu: Depends on the Lisp =)

[13:11] <arnsholt> But if it's a Lisp-1 (single namespace) It's just ((lambda (@sig) $function-body) @args)

[13:12] <arnsholt> Or you can have a call special form

[13:12] <grondilu> meh, I think I'll stick to ES6 

[13:12] <grondilu> where sub {}() is (_ => null)()

[13:13] <grondilu> seems simple enough

[13:13] *** itaipu left
[13:13] *** kent\n left
[13:15] *** mohae left
[13:15] * grondilu checked and realizes (() => null) is better for sub {}

[13:15] *** itaipu joined
[13:19] <dalek> doc: 5252066 | (Jan-Olof Hendig)++ | doc/ (2 files):

[13:19] <dalek> doc: Changed references to deprecated Order::Increase and Order::Decrease to Order::Less and Order::More

[13:19] <dalek> doc: review: https://github.com/perl6/doc/commit/5252066ddf

[13:19] *** djbkd left
[13:22] *** djbkd joined
[13:23] <pmurias> grondilu: how are you going to transform the javascript you produce?

[13:26] <gfldex> for a concurrent File::Find, is $follow-symlink = True a sane default?

[13:27] <grondilu> pmurias: I won't.

[13:27] <grondilu> why would I?

[13:28] *** pierre_ joined
[13:28] <pmurias> grondilu: you seem to want to have a bunch of passes that feed into each other

[13:29] <grondilu> yes

[13:29] <pmurias> so what will the first pass return?

[13:30] <grondilu> but only the last stage will produce javascript.

[13:30] <grondilu> the pass in language miniPerl::<n> returns code in language miniPerl::<n-1>

[13:31] <pmurias> in string form?

[13:31] <grondilu> yes

[13:31] *** pierre_ left
[13:31] *** djbkd_ joined
[13:32] *** djbkd left
[13:33] <dylanwh> gfldex: re File::Find, symlinks can form cycles. Do you detect those cycles?

[13:35] <grondilu> for instance miniPerl::II will accept sequences of operations.  So 'f(); g();' will become 'sub { g() }(f());'

[13:35] *** rgrinberg joined
[13:37] <gfldex> dylanwh: i would like to but we don't got readlink nor stat (readlink is hard on win32 and stat is pointless)

[13:38] <dylanwh> I would ignore symlinks by default then. 

[13:38] <dylanwh> symlink cycles are not uncommon in my experience.

[13:39] <gfldex> they are the default on windows is you start at C:\

[13:40] *** pierre_ joined
[13:43] <noninc> how would I go about building moarvm, nqp and rakudo all with relative prefixes on windows, so i can move it later? is this possible?

[13:46] <pmurias> grondilu: seems doable but really inconvinient and slow as you will have to reparse everything as opposed to just manipulating s-exprs like the use in scheme (or just ASTs)

[13:46] *** AlexDaniel joined
[13:46] *** djbkd joined
[13:47] *** djbkd_ left
[13:49] <grondilu> pmurias: I confess I don't understand how they do it, then.

[13:52] <pmurias> grondilu: have you learned lisp?

[13:53] <grondilu> pmurias: not seriously, and long ago.

[13:55] <pmurias> grondilu: in lisp the program is written as nested lists (with atoms in them)

[13:55] <grondilu> not related:  how do I refer to a grammar inside itself?  Like with ::CLASS but for grammars?

[13:55] <pmurias> with a very thin layer of syntax on top of it

[13:55] <pmurias> isn't a grammar also a class?

[13:55] <grondilu> m: grammar { say ::CLASS }

[13:55] <camelia> rakudo-moar 46e0ed: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤No such symbol 'CLASS'␤at <tmp>:1␤------> 3grammar { say ::CLASS7⏏5 }␤»

[13:55] <grondilu> it's supposed to.

[13:56] <grondilu> m: class { say ::CLASS }

[13:56] <camelia> rakudo-moar 46e0ed: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤No such symbol 'CLASS'␤at <tmp>:1␤------> 3class { say ::CLASS7⏏5 }␤»

[13:56] <grondilu> oh

[13:56] <grondilu> m: class { say ::?CLASS }

[13:56] <camelia> rakudo-moar 46e0ed: OUTPUT«(<anon|60424016>)␤»

[13:56] <grondilu> wrong syntax, sorry

[13:56] <dalek> doc: 4a99a1a | (Jan-Olof Hendig)++ | doc/Type/Str.pod6:

[13:56] <dalek> doc: Attempt to fix #923 by exchanging a few =head3 directives with B<>

[13:56] <dalek> doc: review: https://github.com/perl6/doc/commit/4a99a1a141

[13:57] *** djbkd left
[13:58] <grondilu> pmurias: I get that in lisp the program is written in nested lists, but I don't know how that can help doing what I'm trying to do. 

[13:58] *** dalek left
[13:59] <grondilu> I suppose I should look into how exactly they proceed with nanopass.

[13:59] <pmurias> grondilu: you don't have to reparse it in every stage you just transform lists

[13:59] *** dalek joined
[13:59] *** ChanServ sets mode: +v dalek

[14:00] *** djbkd joined
[14:01] <grondilu> ok

[14:01] <grondilu> but I can't cope with the kind of AST perl6 generates.

[14:04] <pmurias> QAST is not very fun true

[14:11] *** djbkd left
[14:12] *** kaare_ joined
[14:13] *** djbkd joined
[14:14] <dalek> perl6-most-wanted: dae00bf | (Tom Browder)++ | most-wanted/modules.md:

[14:14] <dalek> perl6-most-wanted: add new module to the list (also WIP)

[14:14] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/dae00bfd57

[14:15] <pmurias> rakudo.js compiles 56% of the setting before dying

[14:16] <dalek> perl6-most-wanted: bbbbbdd | (Tom Browder)++ | most-wanted/modules.md:

[14:16] <dalek> perl6-most-wanted: correct typo

[14:16] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/bbbbbdd7c3

[14:17] <dalek> perl6-most-wanted: 22dc004 | (Tom Browder)++ | most-wanted/modules.md:

[14:17] <dalek> perl6-most-wanted: correct entry

[14:17] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/22dc0042cd

[14:20] *** seatek joined
[14:25] *** seatek left
[14:25] *** djbkd left
[14:25] *** djbkd joined
[14:35] *** kent\n joined
[14:39] *** djbkd_ joined
[14:39] *** djbkd left
[14:49] *** djbkd_ left
[14:51] *** kaare_ left
[14:52] *** kaare_ joined
[14:53] *** djbkd joined
[14:53] *** pierre_ left
[14:57] *** MilkmanDan left
[14:59] *** MilkmanDan joined
[14:59] <moritz> nice commit hash, starting with bbbbbdd

[15:02] *** khw joined
[15:03] <gfldex> is Channel.list eager (given no Promise is involved)?

[15:04] <noninc> okay, my problem seems to be in the nqp::backendconfig<prefix>. Can I change that at runtime between invoking moarvm and bootstrapping perl (when trying to run a perl script)?

[15:04] *** rmmm joined
[15:04] <dalek> perl6-most-wanted: 895e6fb | (Tom Browder)++ | most-wanted/modules.md:

[15:04] <dalek> perl6-most-wanted: add note about impending review and release

[15:04] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/895e6fb14a

[15:04] <moritz> gfldex: yes, it blocks until you close the channel

[15:13] *** Alikzus left
[15:15] *** djbkd left
[15:16] *** djbkd joined
[15:21] <Woodi_> hi #perl6 :)

[15:21] <Woodi_> is AST eqivalent of s-expressions ?

[15:22] *** pmurias left
[15:22] <mst> sorrrt of?

[15:23] <mst> I mean, both 'yes' and 'absolutely not' depending on how you look at it

[15:23] <TimToady> s-expressions are syntax, and syntax is not...abstract...

[15:23] <TimToady> unless, of course, it's abstract syntax...

[15:24] <TimToady> but usually, when people say "s-exprs" they mean Lost In Silly Parens

[15:25] *** djbkd left
[15:26] <TimToady> so I think most people would say s-exprs are one way of representing ASTs

[15:27] *** djbkd joined
[15:29] <Woodi_> os they are isomorphic or not ? :)

[15:29] <Woodi_> so*

[15:29] <mst> ah, point. I think I tend to think of S-exprs as the list-of-lists structure, and the ((((((())))))) stuff as just a textual representation

[15:30] <TimToady> to me, if things look different, they are different :)

[15:30] <TimToady> that's probably why I dislike gratuitous abstractions...

[15:31] <Woodi_> I wonder do optimizations done on AST can be done on something more human friendly ;)

[15:31] *** Ven_ joined
[15:32] <Woodi_> btw. can we just *inline EVERYTHING!* into asm and optimize it as postcompilation ? :)

[15:32] <mst> hrm, i think what I mean is that I think of lisp as an infospace (ala there being an XML infospace, of which the textual representation is merely the usual means for humans to poke it)

[15:33] <mst> it's notable that e.g. symbolics (IIRC) didn't store a textual form at all, and when you went to edit something it formatted it according to whatever your editor/tidy config said

[15:33] <TimToady> but yes, they can generally be considered isomorphic, except insofar as an AST often contains abstractions (cross links and such) that the s-exprs are usually thought of as lower-level than

[15:33] <TimToady> or however you say that in English

[15:34] *** RabidGravy left
[15:34] <mst> hmm, I've always regarded the cross links are more being ... pre-caching of lookups from the surrounding environment

[15:35] <mst> then again, your "looks different" comment kinda suggests your brain does concrete visual processing in a way mine simply doesn't/can't

[15:35] <TimToady> at some point you're not actually talking about s-exprs anymore, but lisp :)

[15:35] *** djbkd left
[15:36] *** djbkd joined
[15:36] <mst> the extent to which s-exprs directly represent the conceptual structure makes that kinda blurred for me, much though I don't disagree

[15:37] *** Alikzus joined
[15:37] <TimToady> on a linguistic side, it comes down to making an etic vs emic distinction

[15:37] <TimToady> *the

[15:38] <TimToady> emically, I meant "on the linguistic side", but etically, it came out the other way

[15:38] <dylanwh> it's cons cells all the way down, man.

[15:39] <TimToady> I'm not worried about all the way down, but all the way up. :P

[15:39] <TimToady> at some point I punch you in the nose rather than handing you a cons cell :)

[15:41] *** seatek joined
[15:41] <Woodi_> yes, pairs can be used to construct rest data structures but it would be nice to have other data structures natively in Lisp. why torture yourself all the time ? :) 

[15:42] <noninc> I'm stuck here :( After building nqp retains nqp::backendconfig()<prefix> and afaik uses that to boot up perl. So if I move the C:\rakudo somewhere else, and change the .bat files accordingly, perl still refuses to run (While looking for 'C:\rakudo/share/nqp/lib/Perl6/BOOTSTRAP.moarvm': no such file or directory). Is there some way I can tell it to look other then by the built-in prefix?

[15:43] <noninc> I'd very much appreciate some help!

[15:44] *** Ven_ left
[15:44] <TimToady> rakudo is not yet relocatable like that, afaik

[15:45] *** Ven_ joined
[15:45] <TimToady> symlinks are the usual remedy

[15:45] <MasterDuke> noninc: i think mst did some work on making the build less dependent on specific paths, but i don't think that's been committed yet

[15:47] <noninc> I am quite commited to make that possible somehow, but I have hardly any experience in the moar/nqp/rakudo sources :( Would you want to help me get started?

[15:49] <psch> the biggest issue is that nqp::backendconfig() is compile time afair

[15:49] *** Ven_ left
[15:49] <psch> so either you replace everything that looks there with a check for e.g. an ENV var or $PWD

[15:49] <noninc> yes. That seems to make sense, as it provides info on the specific installation.

[15:49] <psch> or you figure out a way to move parts (i.e. probably only prefix) of the backendconfig to runtime

[15:50] <noninc> Can I overwrite it befor loading perl's bootstrap into moar

[15:50] <psch> m: use nqp; say nqp::backendconfig().HOW.^name

[15:50] <camelia> rakudo-moar 46e0ed: OUTPUT«KnowHOW␤»

[15:50] <psch> m: use nqp; say nqp::backendconfig().WHAT

[15:50] <camelia> rakudo-moar 46e0ed: OUTPUT«{}␤»

[15:51] <psch> ...no idea, honestly

[15:52] <noninc> so best guess would be to rewirte the bootstrap to look somewhere else then just at backendconfig?

[15:52] <noninc> -rewirte +change

[15:53] <noninc> I will try that.

[15:53] *** djbkd left
[15:56] *** djbkd joined
[15:57] <TimToady> at one point (don't know if it's still this way), in Perl 5 we put each absolute location into a fixed-size chunk of memory, with spare bytes at the end, so that a program could relocate the perl interpreter by rewriting those chunks in the binary

[15:59] <noninc> I looked at the .moarvm files with a hex editor and the string was not long enough sadly

[16:00] <MasterDuke> noninc: you could see what mst did for Alien::[Rakudo,NQP,MoarVM]

[16:01] <noninc> let me google that

[16:03] <noninc> please excuse my ignorance, but I can only find irc logs when searching for alien::<perl6-stuff>

[16:03] <mst> noninc: http://trout.me.uk/6dists/

[16:03] <noninc> ty

[16:03] <mst> noninc: I haven't quite got them cleaned up to where I wanted to inflict them on cpantesters etc.

[16:04] <mst> TimToady: pretty sure activestate's installer still relies on that

[16:04] <noninc> give me a moment please to read up on that

[16:05] *** domidumont joined
[16:07] *** djbkd left
[16:08] *** djbkd joined
[16:09] *** TEttinger joined
[16:17] *** djbkd left
[16:18] <noninc> :/ alien::<perl6-stuff> just rebuilds with appropriate prefixes

[16:19] <noninc> -just

[16:20] *** djbkd joined
[16:24] *** setty1 left
[16:25] *** lucasb_ joined
[16:27] *** djbkd left
[16:28] *** MARTIMM left
[16:30] *** djbkd joined
[16:32] *** jstimpfl1 left
[16:36] <noninc> solution symbolic link from C:\perl6prefix\share\nqp\lib to <working directory>\blib

[16:37] *** djbkd left
[16:37] <noninc> because rakudo/src/Perl6/ModuleLoader.nqp line 56 - 59 (https://github.com/rakudo/rakudo/blob/8cbb1efd1d84fd57298e0e0813b64d8dd37140ba/src/Perl6/ModuleLoader.nqp#L56)

[16:37] <noninc> ?? "blib/$file"

[16:37] <noninc> is that  blib thing documented somewhere?

[16:38] <tailgate> is there an operator for type comparisons?

[16:38] <gfldex> ~~

[16:38] <gfldex> or .WHAT === .WHAT

[16:39] <gfldex> sometimes .HOW ~~ Metamodel::*

[16:39] *** djbkd joined
[16:39] <gfldex> tailgate: see introspection sections in https://docs.perl6.org/language/typesystem

[16:41] <noninc> I think I can rely on perl (moar) looking for itself (BOOTSTRAP.moarvm) in <working directory>/blib/..., can't I?

[16:43] <BenGoldberg> m: class Foo { method posfix:<!>() { say "bang!" } }; Foo.new!;

[16:43] <camelia> rakudo-moar 46e0ed: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Negation metaoperator not followed by valid infix␤at <tmp>:1␤------> 3posfix:<!>() { say "bang!" } }; Foo.new!7⏏5;␤    expecting any of:␤        infix␤        infix stopper␤»

[16:44] <BenGoldberg> Is there any chance that perl6 will something C++-ish, and allow an operator to be defined either as a method or as a sub?

[16:45] <BenGoldberg> (In the future, that is)

[16:45] <noninc> Thank you for your help! cya later

[16:45] *** noninc left
[16:46] <TimToady> no, we do not allow other people to change the language in your lexical scope; you must use a sub to delegate to a method in that case

[16:46] <lucasb_> m: class C {}; multi sub postfix:<!>(C) { say "bang!" }; C.new!

[16:46] <camelia> rakudo-moar 46e0ed: OUTPUT«bang!␤»

[16:47] <BenGoldberg> How is it different from them exporting operators into your lexical scope when you 'use' a module?

[16:47] <TimToady> those are subs, not methods

[16:47] <BenGoldberg> What I mean is, there's more than one way to do it, no?

[16:48] <TimToady> always :)

[16:48] <BenGoldberg> Would it be too hard to add to the language?  Or is it for a different reason?

[16:49] <TimToady> all language change is lexically scoped in Perl 6, and method calls are not lexically scoped

[16:50] <TimToady> you cannot add a method in some module and magically change the syntax in a different module

[16:50] *** djbkd_ joined
[16:51] <TimToady> we don't allow magical action at a distance without importing a special name at compile time, in which case it's no longer magical, but desirable

[16:51] *** djbkd left
[16:52] <BenGoldberg> What if it were limited to places where the user has explicitly declared the type of a variable, and the declared type has the specified operator methods?

[16:52] <TimToady> and the whole point of methods is that they're late bound, so you can't predict where the name is to be found

[16:52] <TimToady> BenGoldberg: as I said, you can easily do that with subs that delegate to methods

[16:53] <TimToady> they'll even get inlined in most cases

[16:53] <TimToady> but language changes are always bound to function names, not method names

[16:53] <TimToady> because function names are lexically scoped, and method names are not

[16:54] <TimToady> to do otherwise means you can't actually understand which language you're parsing until you've analyzed the entire program

[16:54] <TimToady> which is a form of accidental genericity we don't want to support ever

[16:55] <TimToady> now, if you say 'use MyTerriblyGenericLanguage;' at the top, of course, you can do whatever you like

[16:55] <TimToady> but stock Perl 6 isn't gonna mix up those namespaces

[16:56] <BenGoldberg> So if I've got: class Foo { method posfix:<!>() { say "bang!" } }, and then I later write: my Foo $x .= new; then when the compiler later sees '$x!', it says, (at compile time!), $x is of type Foo, and Foo has an postfix<!>, therefore I shall translate this into $x."postfix<!>"().  The actual method lookup and binding would be done at runtime (late binding) just like any other method, but the decision whether $x! is a sub, method, 

[16:56] <BenGoldberg> or error is done at compile time.

[16:57] <TimToady> that would be C++, not Perl :)

[16:57] <BenGoldberg> Yes! :)

[16:59] <TimToady> however, does even C++ allow you to add new operators that way?  or just rebind existing ones?

[16:59] <BenGoldberg> But it's also a bit like perl5, where if I wrote: package Foo; use overload '+' => 'add'; and later wrote: $x + 2, it would call $x->add(2), a perfectly ordinary method call.

[17:00] <TimToady> yes, because Perl 5 suffers the same illness as C++ in terms of not allowing new operators

[17:00] <BenGoldberg> Neither perl nor C++ doesn't let you write wholly new operators, because that would require changing the lexer.

[17:00] <BenGoldberg> Well, perl you *could*, but it's messy! :)

[17:01] <TimToady> yes, because lexers are a form of multi-pass parsing, which we don't do in Perl 6

[17:01] <TimToady> having learned bitter lessons about that in Perl 5

[17:02] <TimToady> so lexically scoped syntax change is fundamentally tied to one-pass parsing in Perl 6

[17:03] <TimToady> multi-pass parsing is a form of accidental genericity, because the second pass you're actually parsing a different language

[17:03] <BenGoldberg> The existance or non-existance of a specific operator is something that can be tested for with one pass parsing.

[17:04] <TimToady> we made the mistake very large with source filters, but the same principle works at smaller scales as well as larger

[17:04] <TimToady> sure, but only if something has been declared ahead of time

[17:04] <BenGoldberg> Yes!  I only want it if it's been declared ahead of time.

[17:04] <TimToady> and methods are not in that category, unless you violate late binding as C++ does, to its shame

[17:05] <TimToady> so you must declare not only the name but the delegation to a method in Perl 6

[17:05] *** rgrinberg left
[17:05] <BenGoldberg> If someone uses augment class Foo, and adds an operator method, then they should be unsurprised if code which was previously compiled does not call that operator.

[17:05] <TimToady> well, you could redirect the delegation after the fact, but the name of the new operator must certainly be declared up front

[17:06] <BenGoldberg> Yes.

[17:06] *** rgrinberg joined
[17:06] <TimToady> you can repeat your statement without "augment" there

[17:06] *** djbkd joined
[17:07] <BenGoldberg> Good point.

[17:07] <TimToady> just because other languages confuse things doesn't mean we have to :)

[17:07] <TimToady> we actually believe in virtual methods by default in a way that C++ does not

[17:08] *** djbkd_ left
[17:08] <BenGoldberg> If someone write: class Foo; my Foo $x .= new; $x!; class Foo { method postfix<!>{ say "bang" } }; it's ok by me if it doesn't compile, because the compiler doesn't yet know of the existance of Foo's"!"

[17:09] <TimToady> won't work in the other order either, and that also should not surprise you

[17:09] <BenGoldberg> Well, won't work now, but I think it could be made to work, keeping with one pass parsing.

[17:10] <TimToady> no, because the lexical scope of postfix:<!> is limited to the block in which it's declared, even if we did pay attention to it on method declarations, which I don't believe we do

[17:10] <BenGoldberg> Hmm...

[17:11] *** MARTIMM joined
[17:11] <TimToady> m: class Foo { method postfix:<!>() { say self ~ "!" }; method foo { self! } }; Foo.new.foo

[17:11] <camelia> rakudo-moar b77d2b: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Negation metaoperator not followed by valid infix␤at <tmp>:1␤------> 3) { say self ~ "!" }; method foo { self!7⏏5 } }; Foo.new.foo␤    expecting any of:␤        infix␤        infix stopper␤»

[17:11] <TimToady> yes, we don't

[17:12] <TimToady> m: class Foo { sub postfix:<!>($x) { say $x ~ "!" }; method foo { self! } }; Foo.new.foo

[17:12] <camelia> rakudo-moar b77d2b: OUTPUT«Foo<95784800>!␤»

[17:13] <TimToady> but in any case, the postfix can't leak out of the lexical scope unless explicitly exported and imported

[17:13] *** cyphase left
[17:13] <TimToady> it's simply not allowed in Perl 6 for you to mess with someone else's lexical scope like that

[17:14] <BenGoldberg> What prevents someone from writing a multi sub trait_mod:<is>( Class $c, :$overloaded! ), which looks at the names of methods of $c, and for any whose name starts with postfix, infix, prefix, circumfix, etc, generates an appropriate multi sub, and further declares those generated subs as exported?

[17:14] <TimToady> to paraphrase one of our slogans, "All is fair if and only if you predeclare."

[17:15] *** bstamour left
[17:15] <timotimo> BenGoldberg: that still needs those multis to be imported into the right scopes

[17:15] *** cpage left
[17:15] <TimToady> that's fine, as long as the user says "use ThatCrazyModule;"

[17:15] *** cpage_ joined
[17:16] <TimToady> it's no different than importing new sytactic functions that happen to delegate to methods, which we allow

[17:16] <TimToady> *syn

[17:17] * BenGoldberg grins.

[17:17] *** djbkd_ joined
[17:17] *** djbkd left
[17:17] <BenGoldberg> So the important thing is that the user be able to easily choose whether or not that behavior's imported.

[17:18] <TimToady> Perl 6 doesn't mind if you declare 'use ShootMeNow;', just as long as it's explicit

[17:18] <BenGoldberg> Ok, got it :)

[17:18] *** cyphase joined
[17:18] *** cyphase left
[17:18] <grondilu> .tell pmurias you're right, passing text between stages is not the way to go.

[17:18] <yoleaux> grondilu: I'll pass your message to pmurias.

[17:19] *** cyphase joined
[17:19] *** cdg joined
[17:24] <lucasb_> m: my &c = { * + 10 and * + 20 }; say c()(1)

[17:24] <camelia> rakudo-moar b77d2b: OUTPUT«21␤»

[17:25] <lucasb_> I saw this ticket about multiple whatevercode in closures

[17:25] <lucasb_> I'm wondering if this snippet will fail next time camelia is recompiled

[17:26] <lucasb_> I'll wait :)

[17:26] <BenGoldberg> m: my &c = { * + 10 and * + 20 }; say c()(0, 2)

[17:26] <camelia> rakudo-moar b77d2b: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at <tmp> line 1␤␤»

[17:27] <BenGoldberg> m: my &c = { * + 10 and * + 20 }; say c()(-10)

[17:27] <camelia> rakudo-moar b77d2b: OUTPUT«10␤»

[17:27] *** nadim_ joined
[17:27] *** djbkd_ left
[17:27] <BenGoldberg> m: my &c = { * + 10 and * + 20 }; dd &c;

[17:27] <camelia> rakudo-moar b77d2b: OUTPUT«Block &c = -> ;; $_? is raw { #`(Block|60885600) ... }␤»

[17:27] <lucasb_> I know, the snippet doesn't make sense. I was just testing the presence of the error or not

[17:28] *** nadim left
[17:28] *** TakinOver joined
[17:28] *** djbkd joined
[17:29] <lucasb_> just to clarify: in 'sub foo($a where {* < 5 and * > 9})', the where clause will always evalute to true, right?

[17:29] <lucasb_> it's not the case that the where clause is getting ignored

[17:30] <BenGoldberg> I suppose that the real question is: If there are N *s in one expression, should the resulting block take one parameter or N parameters?

[17:30] <lucasb_> i think the answer always was "N parameters"

[17:30] <lucasb_> each star is a different paramenter... maybe that is the confusion in the ticket

[17:31] <BenGoldberg> m: my &c = { * + 10 and * + 20 }; dd c();

[17:31] <camelia> rakudo-moar c4c071: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *␤at <tmp>:1␤------> 3my &c = { * + 10 and * + 20 }7…»

[17:31] <lucasb_> that's why "* + *" sums two numbers, not just one

[17:32] <BenGoldberg> m: my $c = { * + 10 and * + 20 }; dd $c;

[17:32] <camelia> rakudo-moar c4c071: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *␤at <tmp>:1␤------> 3my $c = { * + 10 and * + 20 }7…»

[17:32] <BenGoldberg> m: my $c = { * + 10 and * + 20 };

[17:32] <camelia> rakudo-moar c4c071: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *␤at <tmp>:1␤------> 3my $c = { * + 10 and * + 20 }7…»

[17:32] <BenGoldberg> m: my $c = * + 10 and * + 20;

[17:32] <camelia> rakudo-moar c4c071: OUTPUT«WARNINGS for <tmp>:␤Useless use of "+" in expression "* + 20" in sink context (line 1)␤»

[17:32] <BenGoldberg> m: my $c = (* + 10 and * + 20); dd $c;

[17:32] <camelia> rakudo-moar c4c071: OUTPUT«WhateverCode $c = { ... }␤»

[17:32] <BenGoldberg> m: my $c = (* + 10 and * + 20); say $c(32);

[17:32] <camelia> rakudo-moar c4c071: OUTPUT«52␤»

[17:33] <lucasb_> so, ok. it's confirmed. with this new revision, my previous snippet fails

[17:33] <BenGoldberg> m: my $c = (* + 10 and * + 20); say $c(-10);

[17:33] <camelia> rakudo-moar c4c071: OUTPUT«10␤»

[17:33] <BenGoldberg> bisectable6: my $c = (* + 10 and * + 20); say $c(-10, 13);

[17:34] * BenGoldberg wonders where's the bot.

[17:35] <grondilu> ls

[17:35] *** mempko joined
[17:35] <grondilu> ^sorry wrong window

[17:36] <BenGoldberg> huggable, bots

[17:36] <huggable> BenGoldberg, nothing found

[17:40] <BenGoldberg> huggable, bots is The #perl6 irc channel normally hosts several helpful bots.  I am a bot, and camelia, SourceBaby, yoleaux, Bisectable, Commitable, Benchable, Evalable are other bots who are usually here.

[17:40] <huggable> BenGoldberg, nothing found

[17:42] <BenGoldberg> huggable, bots :is: The #perl6 irc channel normally hosts several helpful bots.  I am a bot, and camelia, SourceBaby, yoleaux, Bisectable, Commitable, Benchable, Evalable are other bots who are usually here.

[17:42] <huggable> BenGoldberg, Added bots as The #perl6 irc channel normally hosts several helpful bots.  I am a bot, and camelia, SourceBaby, yoleaux, Bisectable, Commitable, Benchable, Evalable are other bots who are usually here.

[17:43] *** mempko left
[17:43] <BenGoldberg> huggable, author

[17:43] <huggable> BenGoldberg, nothing found

[17:44] <BenGoldberg> huggable, author :is: was written by Zoffix++.

[17:44] <huggable> BenGoldberg, Added author as was written by Zoffix++.

[17:44] *** djbkd left
[17:45] *** seatek left
[17:45] *** nadim_ left
[17:47] *** Actualeyes left
[17:47] *** nadim_ joined
[17:47] *** djbkd joined
[17:47] *** seatek joined
[17:48] <TimToady> BenGoldberg: note that 'and' is a short-circuit op and thus is really control flow

[17:49] <TimToady>  m: my $c = (* + 20 if * + 10); say $c(32);

[17:49] <camelia> rakudo-moar c4c071: OUTPUT«52␤»

[17:49] <TimToady> you've essentially said that

[17:49] <BenGoldberg> Sure, I know that.

[17:50] <BenGoldberg> The important thing I'm taking away is that I can't write:

[17:50] <BenGoldberg> m: my $c = (* + *); say $c( 10, 20 );

[17:50] <camelia> rakudo-moar c4c071: OUTPUT«30␤»

[17:50] <BenGoldberg> Err

[17:50] <BenGoldberg> Hmm...

[17:50] <BenGoldberg> Ok, now I'm confused.

[17:51] <BenGoldberg> m: my $c = (* and *); say $c( 10, 20 );

[17:51] <camelia> rakudo-moar c4c071: OUTPUT«No such method 'CALL-ME' for invocant of type 'Whatever'␤  in block <unit> at <tmp> line 1␤␤»

[17:51] <TimToady> we do not try to apply autopriming to control flow, it's only for simple expressions

[17:52] <BenGoldberg> m: my $c = (* ?? * !! *); say $c( True, 10, 20 );

[17:52] <camelia> rakudo-moar c4c071: OUTPUT«No such method 'CALL-ME' for invocant of type 'Whatever'␤  in block <unit> at <tmp> line 1␤␤»

[17:52] <TimToady> same deal

[17:52] <lucasb_> I found this interesting:

[17:52] <lucasb_> my &c = { $_ + * }; say c(2)(3)   # this works

[17:52] <lucasb_> my &c = { $^a + * }; say c(2)(3)  # this doesn't work

[17:52] <BenGoldberg> m: my $c = (* ?? * !! *); dd $c;

[17:52] <camelia> rakudo-moar c4c071: OUTPUT«Whatever $c = *␤»

[17:52] *** nadim_ left
[17:53] *** AlexDaniel left
[17:53] <lucasb_> should the two snippets both fail or both work? :)

[17:54] <lucasb_> or maybe it's ok for $_ to be "more special" than $^a

[17:54] *** nadim_ joined
[17:55] <grondilu> m: dd foo => "bar"

[17:55] <camelia> rakudo-moar c4c071: OUTPUT«block <unit>␤»

[17:55] <grondilu> ^wat

[17:55] <grondilu> m: say foo => "bar"

[17:55] <camelia> rakudo-moar c4c071: OUTPUT«Unexpected named argument 'foo' passed␤  in block <unit> at <tmp> line 1␤␤»

[17:55] <BenGoldberg> In the absence of an EVAL, it should be almost impossible to distinguish betwen a block which uses $_ and one which uses a single positional parameter

[17:56] <TimToady> I think they should both fail, because they almost certainly show confusion on the part of the programmer

[17:56] <BenGoldberg> m: my &c = -> $a { $a + * }; say c(2)(3);

[17:56] <camelia> rakudo-moar c4c071: OUTPUT«5␤»

[17:56] <BenGoldberg> m: my &c = { $^a + * }; say c(2)(3);

[17:56] <camelia> rakudo-moar c4c071: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *␤at <tmp>:1␤------> 3my &c = { $^a + * }7⏏5; say c…»

[17:56] <BenGoldberg> m: my &c = { $_ + * }; say c(2)(3);

[17:56] <camelia> rakudo-moar c4c071: OUTPUT«5␤»

[17:56] <TimToady> though one could argue that use of $_ is "valid parameter syntax"

[17:57] <TimToady> and hence so is $^a

[17:58] <BenGoldberg> I definitely think all three of those ought to behave the same, either all correct or all wrong.

[17:58] <TimToady> I'd be fine with all correct

[17:58] <lucasb_> cool

[17:58] <TimToady> it's things like { * + * } that we really want to catch

[17:59] *** djbkd left
[17:59] <lucasb_> I understand this malformed double closure error has been around for very long, but maybe someone can come with an usecase where it is needed to return a whatevercode from a block

[17:59] <BenGoldberg> m: my &c = -> $a { $a + * + * }; say c(2)(3, 10);

[17:59] <camelia> rakudo-moar c4c071: OUTPUT«15␤»

[17:59] *** nadim_ left
[18:00] <BenGoldberg> m: my &c = -> $a { * ?? $a !! * }; say c("true")(Bool.pick, "false");

[18:00] <camelia> rakudo-moar c4c071: OUTPUT«No such method 'CALL-ME' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»

[18:01] *** nadim_ joined
[18:01] *** djbkd joined
[18:01] <TimToady> * specifically doesn't work on control flow, just as it specifically doesn't work on ..

[18:02] <TimToady> m: say (1..*).WHAT

[18:02] <camelia> rakudo-moar c4c071: OUTPUT«(Range)␤»

[18:02] *** Actualeyes joined
[18:03] <BenGoldberg> m: say (* ~~ Cool)

[18:03] <camelia> rakudo-moar c4c071: OUTPUT«{ ... }␤»

[18:03] *** FROGGS joined
[18:03] *** buggable joined
[18:07] *** nadim_ left
[18:10] *** brrt joined
[18:11] *** djbkd left
[18:13] *** nadim_ joined
[18:15] *** djbkd joined
[18:18] *** AlexDaniel joined
[18:18] *** canopus left
[18:23] *** nadim_ left
[18:24] *** canopus joined
[18:24] *** cdg left
[18:25] *** nadim_ joined
[18:29] *** nadim_ left
[18:30] *** nadim_ joined
[18:39] *** nadim joined
[18:39] *** nadim_ left
[18:43] <AlexDaniel> huggable, bots :is: The #perl6 irc channel normally hosts several helpful bots.  I am a bot, and camelia, benchable, bisectable, buggable, committable, dalek, ilbot, NeuralAnomaly, SourceBaby, synopsebot6, Undercover, yoleaux are other bots who are usually here.

[18:43] <huggable> AlexDaniel, Added bots as The #perl6 irc channel normally hosts several helpful bots.  I am a bot, and camelia, benchable, bisectable, buggable, committable, dalek, ilbot, NeuralAnomaly, SourceBaby, synopsebot6, Undercover, yoleaux are other bots who are usually here.

[18:45] <brrt> what does Undercover do?

[18:46] <AlexDaniel> brrt: https://github.com/perl6/doc/issues/711#issuecomment-235414744

[18:46] <TimToady> figures out which code is under covered

[18:46] <brrt> aha

[18:46] <brrt> that, ehm, makes sense

[18:46] <brrt> :-)

[18:47] <seatek> unicode operators are slowly driving me insane

[18:47] <AlexDaniel> seatek: which ones exactly?

[18:48] <seatek> AlexDaniel: Right now the function combinator -- FINALLY figured out it wanted a "ring operator" symbol

[18:48] <timotimo> ah

[18:48] <AlexDaniel> seatek: you can use “o”

[18:49] <seatek> o!

[18:49] <seatek> ok i'm sane again ;) thanks  :)

[18:49] <AlexDaniel> seatek: see this table: https://docs.perl6.org/language/unicode_texas

[18:50] <seatek> i need to start mapping. couldn't even get the standard "compose" to make that ring operator symbol

[18:50] *** nadim left
[18:50] <grondilu> what best represent "no value"?  Mu or Nil?

[18:51] <gfldex> Nil

[18:51] <timotimo> nil is the absence of a value you expected

[18:51] <timotimo> whereas mu is an undefined value

[18:51] <grondilu> ok

[18:51] <gfldex> however, handling Nil is tricky. Sometimes () or Empty is better.

[18:51] <lucasb_> or maybe the undefined type object of the object you were expecting (Int, Str, etc.)

[18:52] <timotimo> yeah, Empty will disappear when iterating

[18:52] <AlexDaniel> m: sub foo { return Nil }; say foo

[18:52] <camelia> rakudo-moar c4c071: OUTPUT«Nil␤»

[18:52] <AlexDaniel> m: sub foo { return Mu }; say foo

[18:52] <camelia> rakudo-moar c4c071: OUTPUT«(Mu)␤»

[18:52] <AlexDaniel> m: sub foo { return Empty }; say foo

[18:52] <camelia> rakudo-moar c4c071: OUTPUT«()␤»

[18:52] <AlexDaniel> m: sub foo { return }; say foo

[18:52] <camelia> rakudo-moar c4c071: OUTPUT«Nil␤»

[18:53] <lucasb_> I think I don't like Nil for this purpose because it propagates, other types would raise an error

[18:53] <AlexDaniel> these flavors of nothingness drive me insane, but unicode ops are nice :)

[18:53] <seatek> i was just thinking the same thing

[18:53] <brrt> not sure if i mssed it, but can we disable precompilation (and loading-of-precompiled modules) with an environment var

[18:53] *** kaare_ left
[18:54] <brrt> that would help the jit-bisect script i've written

[18:54] *** djbkd left
[18:56] <seatek> Yeah, I can't cope with a letter "o" being an operator now. gotta map the little doohicky instead

[18:56] <AlexDaniel> ｢∘_∘｣

[18:57] *** brrt left
[18:57] *** nadim joined
[18:58] <seatek> showoff ;)

[19:01] *** darutoko left
[19:07] *** andrzejku left
[19:10] <grondilu> first time I get this error:

[19:10] <grondilu> ===SORRY!===

[19:10] <grondilu> Representation must be composed before it can be serialized

[19:10] <grondilu> le shell a retourné 1

[19:17] <lucasb_> m: say <2 10>.sort({~$^a})

[19:17] <camelia> rakudo-moar c4c071: OUTPUT«(2 10)␤»

[19:17] <lucasb_> m: say <2 10>.sort({$^a.Str})

[19:17] <camelia> rakudo-moar c4c071: OUTPUT«(10 2)␤»

[19:18] <lucasb_> so, "~" calls .Stringy, not .Str... this suprised me

[19:18] *** nadim left
[19:18] <lucasb_> ...and IntStr.new(...).Stringy returns an IntStr

[19:19] *** nadim joined
[19:19] <lucasb_> so they are sorted numerically, not alpha

[19:26] *** MARTIMM left
[19:27] <dalek> ecosystem: fb20051 | gfldex++ | META.list:

[19:27] <dalek> ecosystem: add Concurrent::File::Find

[19:27] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/fb20051efc

[19:28] *** domidumont left
[19:30] *** nadim left
[19:38] *** nadim joined
[19:38] *** wamba left
[19:40] *** wamba joined
[19:40] *** seatek left
[19:41] *** Ven_ joined
[19:41] *** rgrinberg left
[19:42] *** rgrinberg joined
[19:43] *** nadim left
[19:48] *** nadim joined
[19:52] *** nadim_ joined
[19:53] *** nadim left
[19:56] *** rindolf left
[19:57] *** nadim_ left
[19:58] *** nadim_ joined
[19:59] *** rindolf joined
[19:59] *** cyphase left
[20:02] *** nadim_ left
[20:03] *** nadim_ joined
[20:04] *** cyphase joined
[20:08] *** aindilis left
[20:09] *** wamba left
[20:10] *** nadim_ left
[20:10] *** nadim_ joined
[20:11] <grondilu> I got a cute idea for my pet project.  Instead of naming my incremental subsets of Perl miniPerl::<some-roman-number>, I'm going to use SI prefixes.

[20:12] <grondilu> so the first itteration is going to be called "yPerl" (pronounce yocto Perl)

[20:12] <grondilu> also, I made a proper AST format

[20:14] <grondilu> it would be fun if I ever arrive to MPerl, the "mega perl" :)

[20:15] *** rindolf left
[20:15] <japhb> What in the heck does the &( ) do in https://github.com/ab5tract/Terminal-Print/blob/master/lib/Terminal/Print/Commands.pm6#L97 ?

[20:15] <AlexDaniel> .oO( and yet another stupid version numbering theme was born )

[20:15] <japhb> It seems to be some odd sort of passthrough

[20:15] *** seatek joined
[20:16] <japhb> m: my \bar := &( "foo" ); dd bar

[20:16] <camelia> rakudo-moar 4abc28: OUTPUT«"foo"␤»

[20:16] <japhb> m: my \bar := &( %( :foo, :bar ) ); dd bar

[20:16] <camelia> rakudo-moar 4abc28: OUTPUT«${:bar, :foo}␤»

[20:16] <japhb> WTH is that operation?

[20:17] *** Actualeyes left
[20:17] <psch> m: say WHAT &( "foo" )

[20:17] <camelia> rakudo-moar 4abc28: OUTPUT«(Str)␤»

[20:17] <psch> probably the same as { ... }()

[20:17] <psch> at least from the looks of it

[20:18] <japhb> psch: maybe ...?  Kindof an odd construction.

[20:19] *** rindolf joined
[20:21] <psch> m: say { &( 1 ) }().WHAT

[20:21] <camelia> rakudo-moar 4abc28: OUTPUT«(Int)␤»

[20:21] <geekosaur> that doesn't make a lot of sense to me, tbh. it looks like a coercion to a Callable, in the same sense that $(...) coerces to item context (mot commonly as $[...] to indicate the list itself is the item instead of there being three items)

[20:22] <psch> geekosaur: well, it doesn't coerce to something invokable.  in fact, it doesn't seem to do anything

[20:22] <psch> m: my \a := &( * ); a.WHAT.say

[20:22] <camelia> rakudo-moar 4abc28: OUTPUT«(Whatever)␤»

[20:22] <psch> m: my $a = &( * ); a.WHAT.say

[20:22] <camelia> rakudo-moar 4abc28: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    a used at line 1␤␤»

[20:22] <psch> m: my $a = &( * ); $a.WHAT.say

[20:22] <camelia> rakudo-moar 4abc28: OUTPUT«(Whatever)␤»

[20:22] <psch> m: my $a = *; $a.WHAT.say

[20:22] <camelia> rakudo-moar 4abc28: OUTPUT«(Whatever)␤»

[20:24] <psch> m: say ({ 1 => 2 }).WHAT; say &({ 1 => 2 }).WHAT

[20:24] <camelia> rakudo-moar 4abc28: OUTPUT«(Hash)␤(Hash)␤»

[20:24] <psch> so, yeah

[20:25] <psch> also, Perl6::Actions.contextualizer:

[20:26] <psch> it basically ignores &() completely

[20:27] <psch> https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L2401

[20:27] <psch> line 2435ff specifically sets the context to 'item' if it's not % or @

[20:27] <psch> so, yeah, &() is currently equivalent to ().item, is equivalent to $()

[20:28] <psch> minus some special casing in the if before

[20:28] <psch> oh, wait, that's only for $()

[20:28] <japhb> m: my \bar := &( 1, 2, 3 ); dd bar

[20:28] <camelia> rakudo-moar 4abc28: OUTPUT«$(1, 2, 3)␤»

[20:28] <japhb> Yup, it itemizes all right.

[20:28] <psch> it is actually completely equivalent

[20:29] * psch wonders if that should instead be equivalent to { }

[20:29] <psch> not sure that's useful, but having it as-is seems like an oversight

[20:29] <japhb> Yeah, I think the current situation is just a bug

[20:29] <lucasb_> psch: do you mean &( 42 ) to be the same as -> { 42 } ?

[20:30] <japhb> lucasb_: It's not clear what the most useful variation of Callable would be there.

[20:30] *** Actualeyes joined
[20:32] <lucasb_> maybe it should just enforce that the expression inside parentheses is actually a callable, and do nothing else.

[20:32] <geekosaur> yeh, possibly it just falls through to itemization by default because nobody was certain what the syntax should do?

[20:33] <lucasb_> for example, intuitively, I was expected that @(...) would create an array, but it creates a list. I have to type 'something.Array' to coerce to array, right?

[20:33] <lucasb_> I know, it coerces to... Positional, not Array

[20:34] <geekosaur> right, and the simplest Positional is the basic read-only one, aka List

[20:34] <psch> m: say @( 1 ).WHAT

[20:34] <camelia> rakudo-moar 4abc28: OUTPUT«(List)␤»

[20:34] <psch> right, but what's the simplest Callable?

[20:34] <psch> i'm not sure it's the Callable that has already been invoked

[20:35] <japhb> psch: I would think that'd be plain old Block: { } -- which is *fewer* characters.

[20:35] <psch> m: say Sub.^mro

[20:35] <camelia> rakudo-moar 4abc28: OUTPUT«((Sub) (Routine) (Block) (Code) (Any) (Mu))␤»

[20:36] <psch> m: say Array.^mro

[20:36] <camelia> rakudo-moar 4abc28: OUTPUT«((Array) (List) (Cool) (Any) (Mu))␤»

[20:36] <psch> japhb: so it should still be something invokable you say?

[20:36] <psch> japhb: and including my evals there (and ignoring Cool) we should get a Code at the least, if not a Block

[20:37] <psch> japhb: i'm not sure "there's a less-characters way to do it" means we can't have semantic consistency

[20:37] <AlexDaniel> m: say ‘abc‘test'test’’ ~~ /^<-[']>+/

[20:37] <psch> japhb: because &-sigil means "something invokable/Callable", just as @-sigil means "something Positional"

[20:37] <camelia> rakudo-moar 4abc28: OUTPUT«｢abc‘test｣␤»

[20:37] <AlexDaniel> m: say ‘abc‘test'test’’ ~~ /^<-["'"]>+/

[20:37] <camelia> rakudo-moar 4abc28: OUTPUT«Potential difficulties:␤    Quotes are not metacharacters in character classes␤    at <tmp>:1␤    ------> 3say ‘abc‘test'test’’ ~~ /^<-7⏏5["'"]>+/␤    Repeated character (") unexpectedly found in character class␤    at <tmp>:1␤   …»

[20:37] <AlexDaniel> m: say ‘abc‘test'test’’ ~~ /^<-[“'”]>+/

[20:37] <camelia> rakudo-moar 4abc28: OUTPUT«｢abc‘test｣␤»

[20:38] <AlexDaniel> m: say ‘abc‘test'test’’ ~~ /^<-[”'”]>+/

[20:38] <camelia> rakudo-moar 4abc28: OUTPUT«Potential difficulties:␤    Repeated character (”) unexpectedly found in character class␤    at <tmp>:1␤    ------> 3say ‘abc‘test'test’’ ~~ /^<-7⏏5[”'”]>+/␤｢abc‘test｣␤»

[20:39] <lucasb_> m: my &c = 42

[20:39] <camelia> rakudo-moar 4abc28: OUTPUT«Type check failed in assignment to &c; expected Callable but got Int (42)␤  in block <unit> at <tmp> line 1␤␤»

[20:39] <psch> m: say "“foo”" ~~ /“foo”/

[20:39] <camelia> rakudo-moar 4abc28: OUTPUT«｢foo｣␤»

[20:39] <psch> m: say "“foo”" ~~ /"“foo”"/

[20:39] <camelia> rakudo-moar 4abc28: OUTPUT«｢“foo”｣␤»

[20:39] <psch> m: my &c = &( c )

[20:39] <lucasb_> ^^ just to be clear, I want that message when the inside of the &(...) is not a callable. can we have that? do you all agree?

[20:39] <camelia> rakudo-moar 4abc28: OUTPUT«Cannot invoke this object (REPR: Uninstantiable; Callable)␤  in block <unit> at <tmp> line 1␤␤»

[20:39] <psch> lucasb_: but that *also* means that mine should work, no?

[20:40] <psch> lucasb_: oh, nevermind, judged only the eval, not the comment afterwards :)

[20:40] <psch> lucasb_: i don't agree with the comment, because &() looks to me like it should do what { $blocky-stuff } does

[20:40] <japhb> psch: Sure, I'm not saying having fewer characters means a WTDI is bad, just that there's no push to have &( ) mean { } on huffmanizing merit.  And certainly I agree &( ) as a "something Callable" contextualizer is fine semantic consistency, yes.

[20:40] <lucasb_> psch: ok, I understand your point

[20:42] *** Ven_ left
[20:44] <lucasb_> IIRC, the design of P6 says that scope is always created by braces... &( my $x = 42 ) would look strange

[20:45] <psch> m: @( 1, 2)

[20:45] <camelia> rakudo-moar 4abc28: ( no output )

[20:45] <lucasb_> I mean... is 'my $x' inside the scope or outside?

[20:45] <psch> i think we want a sink context warning there too

[20:45] <psch> anyway, i'm also not precluding the possibility of being wrong because of some oversight

[20:45] <psch> m: 1,2

[20:45] <camelia> rakudo-moar 4abc28: OUTPUT«WARNINGS for <tmp>:␤Useless use of constant integer 1 in sink context (lines 1, 1)␤Useless use of constant integer 2 in sink context (lines 1, 1)␤»

[20:45] *** cyphase left
[20:45] <psch> m: (1,2)

[20:45] <camelia> rakudo-moar 4abc28: OUTPUT«WARNINGS for <tmp>:␤Useless use of constant integer 1 in sink context (lines 1, 1)␤Useless use of constant integer 2 in sink context (lines 1, 1)␤»

[20:45] <psch> m: @(1,2)

[20:45] <camelia> rakudo-moar 4abc28: ( no output )

[20:45] <psch> m: $(1,2)

[20:45] <camelia> rakudo-moar 4abc28: ( no output )

[20:46] <psch> lucasb_: i'd argue it inside the scope

[20:46] <psch> lucasb_: you're coercing a statement_list to a Callable

[20:46] <psch> lucasb_: there's probably a fine distinction that can be made between that and a Block, but i'm not fit enough anymore today to make it... :)

[20:50] *** cyphase joined
[20:51] *** cdg joined
[20:53] *** chris2 left
[20:56] *** cyphase left
[20:57] *** rindolf left
[21:08] *** Ven_ joined
[21:08] *** chris2 joined
[21:09] *** Ven_ left
[21:18] *** cyphase joined
[21:26] <japhb> psch: Perhaps the fine distinction is exactly that it *isn't* a new scope ...

[21:28] *** Ven_ joined
[21:30] *** cyphase left
[21:34] *** cyphase joined
[21:38] *** Ven_ left
[21:38] *** Ven_ joined
[21:40] *** Ven_ left
[21:42] *** cyphase left
[21:46] <grondilu> m: "foo" ~~ / <alpha> || <digit> /; say $<alpha>

[21:46] <camelia> rakudo-moar 4abc28: OUTPUT«｢f｣␤»

[21:46] <grondilu> m: "foo" ~~ / <+alpha+digit> /; say $<alpha>

[21:46] <camelia> rakudo-moar 4abc28: OUTPUT«Nil␤»

[21:46] <grondilu> can't I make a capture in the second form as well?

[21:47] *** cyphase joined
[21:55] *** MonkWannab joined
[21:55] *** cyphase left
[21:56] <MonkWannab> p6: say 3;

[21:56] <camelia> rakudo-moar 4abc28: OUTPUT«3␤»

[21:56] <lucasb_> grondilu: maybe the leading "+" prevents capturing, so you have to say / <foo=+alpha+digit> / or / $<foo> = <+alpha+digit> /

[21:57] <MonkWannab> rakudo:

[21:58] <MonkWannab> p6: say rakudo

[21:58] <camelia> rakudo-moar 4abc28: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    rakudo used at line 1␤␤»

[21:58] <MonkWannab> p6: rakudo:

[21:58] <camelia> rakudo-moar 4abc28: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3rakudo:7⏏5<EOL>␤    expecting any of:␤        colon pair␤»

[21:59] <MonkWannab> help

[22:00] <MonkWannab> p6: say 'how do I start Perl 6?';

[22:00] <camelia> rakudo-moar 4abc28: OUTPUT«how do I start Perl 6?␤»

[22:00] <grondilu> here you go.

[22:00] <grondilu> m: say "just 'm' is fine too"

[22:00] <camelia> rakudo-moar 4abc28: OUTPUT«just 'm' is fine too␤»

[22:00] *** cyphase joined
[22:01] <grondilu> MonkWannab++ nick of the month

[22:01] <MonkWannab> m: say 'Hello';

[22:01] <camelia> rakudo-moar 4abc28: OUTPUT«Hello␤»

[22:01] *** itaipu left
[22:01] <MonkWannab> m: say 'Thanks grondilu';

[22:01] <camelia> rakudo-moar 4abc28: OUTPUT«Thanks grondilu␤»

[22:03] <grondilu> m: say $*VM; # in case you're curious what you're running

[22:03] <camelia> rakudo-moar 4abc28: OUTPUT«moar (2016.09.13.g.34.c.375.a)␤»

[22:03] <grondilu> p6: say $*VM

[22:03] <camelia> rakudo-moar 4abc28: OUTPUT«moar (2016.09.13.g.34.c.375.a)␤»

[22:03] <MonkWannab> m: say 'Is there a prize for nick of the month?';

[22:03] <camelia> rakudo-moar 4abc28: OUTPUT«Is there a prize for nick of the month?␤»

[22:03] <grondilu> nope, but you got your karma incremented

[22:04] <MonkWannab> m: say 'LOL';

[22:04] <camelia> rakudo-moar 4abc28: OUTPUT«LOL␤»

[22:04] <MonkWannab> m: say $VM;

[22:04] <camelia> rakudo-moar 4abc28: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '$VM' is not declared␤at <tmp>:1␤------> 3say 7⏏5$VM;␤»

[22:06] <MonkWannab> p6: say $*VM;

[22:06] <camelia> rakudo-moar 4abc28: OUTPUT«moar (2016.09.13.g.34.c.375.a)␤»

[22:07] <MonkWannab> m: say 'Thanks...off to tutorial land...';

[22:07] <camelia> rakudo-moar 4abc28: OUTPUT«Thanks...off to tutorial land...␤»

[22:07] *** MonkWannab left
[22:08] *** cyphase left
[22:09] <seatek> I'm sad that .push throws up its hands on infinite arrays

[22:09] <psch> m: "foo" ~~ / $<alpha>=<+alpha+digit> /; say $<alpha>

[22:09] <camelia> rakudo-moar 4abc28: OUTPUT«｢f｣␤»

[22:10] <psch> ah, yeah, that's been mentioned

[22:10] <psch> grondilu: in general, <> in regex only capture if the < isn't followed by something non-alpha

[22:11] <psch> grondilu: at least that's how i remember it

[22:12] <lucasb_> seatek: can you show an example to clarify for me? :)

[22:12] <psch> m: my @a = ^Inf; say "hi"; say @a.push: 0;

[22:12] <camelia> rakudo-moar 4abc28: OUTPUT«hi␤Cannot push to a lazy list␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»

[22:13] <psch> honestly, it seems perfectly reasonable to me vOv

[22:13] <psch> 'cause lazy means "potentially infinite"

[22:13] *** cyphase joined
[22:13] <psch> if you can eager it without a timeout, you can push *after* you eager it

[22:14] <psch> m: my @a = lazy 1..10; say @a.is-lazy; @a .= eager; @a.push: 11; say @a

[22:14] <camelia> rakudo-moar 4abc28: OUTPUT«True␤[1 2 3 4 5 6 7 8 9 10 11]␤»

[22:15] <psch> m: my @a = lazy 1..10; say @a.is-lazy; try @a.push: 11; @a .= eager; @a.push: 11; say @a

[22:15] <camelia> rakudo-moar 4abc28: OUTPUT«True␤[1 2 3 4 5 6 7 8 9 10 11]␤»

[22:15] <psch> m: my @a = lazy 1..10; say @a.is-lazy; try @a.push: 11; say $!; @a .= eager; @a.push: 11; say @a

[22:15] <camelia> rakudo-moar 4abc28: OUTPUT«True␤Cannot push to a lazy list␤  in block <unit> at <tmp> line 1␤␤[1 2 3 4 5 6 7 8 9 10 11]␤»

[22:15] <psch> there

[22:15] <timotimo> we also have (in theory/speculation) a "plan" method that pushes between the reified part and the iterator part of a list ... i think?

[22:15] <psch> timotimo: i thought plan appends to the iterator?

[22:16] <psch> m: say Array.^can('plan')

[22:16] <camelia> rakudo-moar 4abc28: OUTPUT«()␤»

[22:16] <timotimo> could be

[22:16] <psch> m: my @a; @a.can('plan')

[22:16] <camelia> rakudo-moar 4abc28: ( no output )

[22:16] <psch> m: my @a; @a.can('plan').say

[22:16] <camelia> rakudo-moar 4abc28: OUTPUT«()␤»

[22:16] <psch> well, we don't have it yet apparently

[22:16] *** cdg_ joined
[22:18] *** Ven_ joined
[22:18] <seatek> hehe - it's crazy really. abstract mathematically it might make sense to be able to work with inifinities like that. but as for partially reified lists... probably doing it in a more clear way without working with inifinites might make more sense

[22:19] *** cdg left
[22:19] <psch> seatek: well, compilers have to be at least somewhat realistic 

[22:19] <psch> seatek: although the mentioned .plan should work with at least one of the mentioned semantics

[22:19] <timotimo> yes

[22:19] <psch> (because math isn't realistic ha ha)

[22:20] <seatek> yeah i was curious as to what was come up with to deal with it. i was expecting maybe a grand cosmic insight :)

[22:20] <timotimo> the trick is you never reach the infinite part

[22:21] <timotimo> then it all comes down to finite sequences and you're fine

[22:21] <seatek> lazy .push

[22:21] <psch> timotimo++

[22:21] <psch> that makes .plan prepending to the iterator make more sense

[22:22] <psch> cause, like, the iterator might not ever reach the appended bit because it's infinite

[22:22] *** cyphase left
[22:23] <timotimo> right

[22:23] <seatek> i'm trying to think of a pracitcal use and can't

[22:24] <psch> well, a queue seems straight forward as a use case

[22:24] <timotimo> imagine you've got a channel that you're receiving items from via a lazy list, and you want to push some stuff to be worked on after the channel is done

[22:25] <seatek> then it's not inifite -- just *potentially* infinite

[22:25] <seatek> a conditional basically

[22:25] <timotimo> if you append a whole sequence you can "plan" new Channels in a row

[22:25] <seatek> hidden behind the semantics

[22:25] <timotimo> if it's infinite, you won't reach the planned stuff. if it isn't, you will

[22:25] <timotimo> so what?

[22:26] <seatek> well, it's always up to the programmer to create the clarity or not... seems like some interesting potential in that

[22:26] *** cyphase joined
[22:27] <lucasb_> practical use for infinite lists? well, I think you use it for the clarity. for example, the list of all squared numbers, or fibonacci numbers. then you just grab from the front the items you'll need

[22:27] <seatek> i meant, to push something onto an inifite list... what's the practical with that?

[22:28] <lucasb_> ah, ok. I misunderstood

[22:28] <timotimo> that's why i was thinking the plan goes in *front* of the current iterator :)

[22:28] <seatek> it would have to involve conditionals of some kind

[22:29] *** FROGGS left
[22:30] *** jameslenz joined
[22:35] *** cyphase left
[22:39] *** cyphase joined
[22:40] *** cyphase left
[22:41] *** cyphase joined
[22:43] *** girafe joined
[22:43] *** cog_ joined
[22:47] *** cognominal left
[22:50] *** lucasb_ left
[22:52] *** Ven_ left
[22:52] *** cyphase left
[22:56] *** cyphase joined
[22:57] *** cyphase left
[23:05] *** cgfbee left
[23:05] *** dalek left
[23:05] *** perlpilot_ joined
[23:05] *** cdg_ left
[23:05] *** perlpilot left
[23:05] *** sftp left
[23:05] *** dalek joined
[23:05] *** ChanServ sets mode: +v dalek

[23:07] *** cgfbee joined
[23:10] *** nadim_ left
[23:12] *** sftp joined
[23:12] *** rgrinberg left
[23:13] *** cyphase joined
[23:15] <seatek> Wasn't expecting I must explicity specify "$_" when printing to a filehandle: for @data { $fh.print($_) }

[23:15] <seatek> thought i'd be able to $fh.print and have it at that

[23:21] <seatek> it's better than a poke in the eye though

[23:21] *** cyphase left
[23:21] <timotimo> no, perl6 has almost nothing that uses $_ implicitly

[23:22] <timotimo> you can set $*OUT and just .print for @data

[23:23] *** BenGoldberg left
[23:24] <seatek> weirdest things to readjust to

[23:27] *** cyphase joined
[23:27] *** girafe left
[23:32] *** BenGoldberg joined
[23:33] <psch> $_ is not special, it's just a default

[23:33] <psch> iterating over an array means you need a variable that contains the value for each iteration

[23:33] <psch> if you don't supply that you get it in $_

[23:34] <psch> i mean, yeah, i know perl5 was lots different there

[23:34] <psch> but in the end the convenience was less than the effort required to learn it -- or so i think is part of the reason behind the decision for the change :)

[23:35] <seatek> yeah if i wasn't used to it so much in p5, i woudln't have batted an eye

[23:35] <seatek> holy moley! you can use arrays inside regex's and  they're implicitly or'd ??? how wonderful!

[23:35] <seatek> thought i'd try it for for kicks not even expecting

[23:35] <psch> seatek: there's actually a subtle bug there, the semantics don't quite work out

[23:36] <seatek> oh really...

[23:36] <BenGoldberg> m: my @a = 'a'..'c'; say "abcd" ~~ /(@a)/;

[23:36] <camelia> rakudo-moar 4abc28: OUTPUT«｢a｣␤ 0 => ｢a｣␤»

[23:36] <psch> yeah, it's #126713

[23:36] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=126713

[23:37] <psch> well, whether it actually *is* a bug depends on whether arrays do interpolate with | or ||

[23:37] <psch> so, yeah, it's in large parts about what was intended with the synopses, which are by now almost completely out of date :)

[23:38] <seatek> interesting

[23:38] *** cyphase left
[23:38] <psch> where | interpolates as LTM aware or and | interpolates as first-come-first-match or

[23:38] <psch> err, the second is ||, not |

[23:38] <psch> i haven't actually tested whether the || semantics would be identical to what array interpolation currently does though

[23:39] <psch> in any case, it's *probably* a really interesting and fun bug in the regex engine, assuming it is currently behaving wrongly :)

[23:40] <BenGoldberg> m: my @a = 'a'..'c'; say "abcd" ~~ /(@a)*/;

[23:40] <camelia> rakudo-moar 4abc28: OUTPUT«｢abc｣␤ 0 => ｢a｣␤ 0 => ｢b｣␤ 0 => ｢c｣␤»

[23:40] <BenGoldberg> m: my @a = 'a'..'c'; say "abcd" ~~ /([||@a])*/;

[23:40] <camelia> rakudo-moar 4abc28: OUTPUT«｢abc｣␤ 0 => ｢a｣␤ 0 => ｢b｣␤ 0 => ｢c｣␤»

[23:40] <BenGoldberg> m: my @a = 'a'..'c'; say "abcd" ~~ /([|@a])*/;

[23:40] <camelia> rakudo-moar 4abc28: OUTPUT«｢abc｣␤ 0 => ｢a｣␤ 0 => ｢b｣␤ 0 => ｢c｣␤»

[23:41] *** tushar joined
[23:41] <psch> BenGoldberg: well, in the RT backtracking is involved... :)

[23:41] <AlexDaniel> seatek: well, if I recall correctly, you can also have regexes in this array

[23:42] <psch> m: my @a = 'a', rx/b/, 'c'; say "abc" ~~ /@a/

[23:42] <camelia> rakudo-moar 4abc28: OUTPUT«｢a｣␤»

[23:42] <psch> m: my @a = 'a', rx/b/, 'c'; say "abc" ~~ /@a+?/

[23:42] <camelia> rakudo-moar 4abc28: OUTPUT«｢a｣␤»

[23:42] <psch> m: my @a = 'a', rx/b/, 'c'; say "abc" ~~ /@a+/

[23:42] <camelia> rakudo-moar 4abc28: OUTPUT«｢abc｣␤»

[23:42] <psch> m: my @a = 'a', rx/b/, 'bc', 'cd'; say "abc" ~~ /@a*?/

[23:42] <camelia> rakudo-moar 4abc28: OUTPUT«｢｣␤»

[23:42] <psch> m: my @a = 'a', rx/b/, 'bc', 'cd'; say "abc" ~~ /^(@a*?)$/

[23:42] <camelia> rakudo-moar 4abc28: OUTPUT«｢abc｣␤ 0 => ｢abc｣␤»

[23:42] <psch> vOv

[23:42] *** cyphase joined
[23:43] <psch> m: my @a = 'a', rx/b/, 'bc', 'cd'; say "abcd" ~~ /^(@a*?)$/

[23:43] <camelia> rakudo-moar 4abc28: OUTPUT«Nil␤»

[23:43] <psch> but yeah, that's the bug from the ticket still

[23:43] <psch> as i said, it's probably hard

[23:43] <psch> or it's just niche 

[23:43] <psch> i mean, *i* don't want to dig for it so yeah 

[23:44] <tushar> How can i differentiate between "my @a=[1..5];" and "my @a=[[1..5],[6..10]];"? In words, I can say that first one is array and second one is array of arrays. If I use WHAT on both of them, I get "(Array)". 

[23:44] <psch> tushar: either with nominal typing or by examining elements

[23:45] <AlexDaniel> tushar: don't you need a comma there?

[23:45] <AlexDaniel> ah no

[23:45] <AlexDaniel> nvm

[23:45] <psch> m: my Array[Int] @a = [1,2,3],[4,5,6];

[23:45] <camelia> rakudo-moar 4abc28: OUTPUT«Type check failed in assignment to @a; expected Array[Int] but got Array ($[1, 2, 3])␤  in block <unit> at <tmp> line 1␤␤»

[23:45] <psch> m: my Array[Int] @a = (Int @ = [1,2,3]), (Int @ = [4,5,6]);

[23:45] <camelia> rakudo-moar 4abc28: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3my Array[Int] @a = (Int7⏏5 @ = [1,2,3]), (Int @ = [4,5,6]);␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        …»

[23:46] <AlexDaniel> I was thinking about this:

[23:46] <AlexDaniel> m: my @a=[[1..5]]; say @a.perl

[23:46] <camelia> rakudo-moar 4abc28: OUTPUT«[1, 2, 3, 4, 5]␤»

[23:46] <AlexDaniel> m: my @a=[[1..5],]; say @a.perl

[23:46] <camelia> rakudo-moar 4abc28: OUTPUT«[[1, 2, 3, 4, 5],]␤»

[23:46] <psch> AlexDaniel: oh, yeah, that's single arg rule

[23:46] <psch> m: my Array[Int] @a = (my Int @ = [1,2,3]), (my Int @ = [4,5,6]); say @a[0].of

[23:46] <camelia> rakudo-moar 4abc28: OUTPUT«(Int)␤»

[23:46] <psch> anyway, yeah, typing of arrays (of arrays) gets cumbersome eventually

[23:47] <psch> tushar: your best bet is probably something like '... where all(*) ~~ Int'

[23:47] <AlexDaniel> I am so accustomed to seeing trailing commas that code without them seems wrong to me by default :)

[23:47] <psch> tushar: it depends on your exact use case though i suppose

[23:48] <psch> tushar: like, do you know how many Arrays containing Ints are supposed to be in your Array

[23:48] <tushar> psch: it is possible that array doesn't contain Int only. It can hold anything.

[23:48] <psch> tushar: well what do you want to check for then

[23:48] <psch> tushar: whether any of the elements in the array is itself an array?

[23:50] <tushar> psch: yes that what I am trying to detect. whether user provides an array with elements or an array with array of elements. I hope it make sense.

[23:51] *** c74d left
[23:52] <tushar> e.g. my @a = [1..3] --> this is an array with elements. my @b = [[1..3],[4..6]] --> this is an array with array as elements where each array has elements.

[23:53] <psch> m: multi f(@a where any(@a) ~~ Positional) { say "at least one array-ish thingy" }; multi f(@) { say "no array-ish thingy" }; f [[1,2,3], 4]; f [1,2,3]

[23:53] <camelia> rakudo-moar 4abc28: OUTPUT«at least one array-ish thingy␤no array-ish thingy␤»

[23:53] <psch> tushar: that's what i think is the obvious way to differentiate

[23:53] <psch> tushar: of course you can also do that in smart match instead of signatures, but the idea remains the same

[23:53] *** cyphase left
[23:54] <tushar> psch: thanks. That's what I exactly trying to achieve. Thanks a lot.

[23:59] <gfldex> m: my @a = [1..5]; my @b = [[1..5],[6..10]]; say [@a.shape, @b.shape];

[23:59] <camelia> rakudo-moar 4abc28: OUTPUT«[(*) (*)]␤»

