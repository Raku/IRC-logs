[00:00] <timotimo> m: use NativeCall; sub test(size_t $foo) is native(Str) {*}

[00:00] <rudi_s> timotimo: Nice. - Any idea what's wrong?

[00:00] <camelia> rakudo-moar 620f4e: ( no output )

[00:00] *** spider-mario left
[00:00] <timotimo> i'd need to see more code, i think

[00:01] <rudi_s> timotimo: Ah, old version of Perl6. Works fine in 2016.1, broken in 2015.11.

[00:01] <timotimo> ah, yes

[00:01] <timotimo> size_t and friends are new-ish

[00:01] <timotimo> never be on a version before 2015.12, is what i'd say

[00:02] *** vendethiel left
[00:02] <rudi_s> Slow Debian sid ... yeah, good idea.

[00:02] <timotimo> sorry about that :(

[00:03] <timotimo> Juerd: i wonder if [+] @switches would be faster or slower

[00:03] <rudi_s> No worries, building it locally works fine.

[00:03] <Juerd> timotimo: I don't. I wonder more about the bonus challenge, which takes ages even for the first range of switches :)

[00:04] <Juerd> Besides that, I prefer .sum to [+] :P

[00:04] <timotimo> only thing i can think of is maybe packing the light switches into a big integer or a bunch of 64bit ints? then you can do bitwise arithmetic on them

[00:04] <timotimo> just xor the current light state with the range you calculated

[00:05] <timotimo> i'm not sure if that's the right kind of result there

[00:05] <Juerd> Sure, but that code won't be nearly as pretty :)

[00:05] <timotimo> approach* not result

[00:05] <Juerd> I've updated the post to use @switches.sum instead of +@switches.grep: *.so

[00:05] <timotimo> well, was it faster?

[00:05] <Juerd> I fail to care enough to even test that :)

[00:06] <timotimo> :o

[00:06] <Juerd> I participate in these code challenges to showcase that Perl 6 is an elegant language

[00:06] *** vendethiel joined
[00:06] <Juerd> Performance for me is a matter of "is it usable", not a number... :)

[00:07] <timotimo> did you see the haskell example? the way it puts the example input in is ... kind of horrible to look at

[00:07] <Juerd> There is more than one Haskell solution and I can't read Haskell :)

[00:07] <timotimo> oh

[00:08] <timotimo> the first one that shows up on my end ... by the person whose name is only hex digits

[00:08] <Juerd> Oh, I don't like hard coding at all, but if you're going to do that, why bother with a single string.

[00:09] <timotimo> hum?

[00:10] <Juerd> Don't put "foo\nbar\nbaz" in your code and then split on \n. If you're going to skip reading from stdin, then skip parsing too.

[00:11] <timotimo> ah

[00:12] <Juerd> Speaking of performance, having non-typed @switches is a lot faster than having Bools :(

[00:12] <timotimo> right. could see that happen :|

[00:12] <Juerd> Even for the simple challenge input, that shaves .1 s from an original .6

[00:12] *** wamba left
[00:13] <Juerd> An array of int goes to .9

[00:13] <timotimo> the only way a typed array is going to be faster is with native types like int

[00:13] <Juerd> So that's the slowest of the three options

[00:13] <timotimo> yeah. currently we have trouble inlining operators and operations regarding native ints

[00:15] <geekosaur> wow. at the very least I'd have brought in the heredoc package >.>

[00:15] <geekosaur> (found that haskell solution, it's like the 4th one listed here)

[00:15] <timotimo> yeah, i was sure haskell would have something much better than whatever that was

[00:16] <timotimo> https://github.com/timo/SDL2_raw-p6/blob/master/examples/white_noise.p6 - did you check this out yet?

[00:17] *** pierrot joined
[00:19] *** sufrostico joined
[00:20] *** sufrosti1o joined
[00:20] <timotimo> by going to nqp::bindpos_i instead of the $pixdata[...] = ... code, i get to about 50fps

[00:21] *** masak_grrr is now known as masak

[00:24] *** pierrot left
[00:27] <rudi_s> I have a list of lists, e.g. @x = (1,2), (3,4), (5,6) and I'd like to flatten that to @x = 1,2,3,4,5,6; I thought @x.flat would do that, but it returns the list unchanged. What am I doing wrong?

[00:27] *** sufrostico left
[00:28] *** sufrosti1o left
[00:28] <timotimo> when you put a list of lists into an array, it will itemize everything in it, because an array is "a list of scalar containers"

[00:28] <timotimo> m: my @a = (1, 2), (3, 4), (5, 6); say @a.perl

[00:28] <camelia> rakudo-moar 620f4e: OUTPUT«[(1, 2), (3, 4), (5, 6)]␤»

[00:28] <timotimo> it doesn't show that in .perl, though

[00:28] <timotimo> huh.

[00:28] *** vendethiel left
[00:28] <timotimo> m: my @a = flat (1, 2), (3, 4), (5, 6); say @a.perl

[00:28] <camelia> rakudo-moar 620f4e: OUTPUT«[1, 2, 3, 4, 5, 6]␤»

[00:29] <timotimo> when you use flat before assigning into the array, it'll work as expected, because at thta point it hasn't packed the sublists into scalar containers yet

[00:29] <timotimo> m: my @a = (1, 2), (3, 4), (5, 6); say @a>>.flat.perl

[00:29] <camelia> rakudo-moar 620f4e: OUTPUT«[((1,).Seq, (2,).Seq), ((3,).Seq, (4,).Seq), ((5,).Seq, (6,).Seq)]␤»

[00:29] <timotimo> m: my @a = (1, 2), (3, 4), (5, 6); say @(@a>>.flat).perl

[00:29] <camelia> rakudo-moar 620f4e: OUTPUT«[((1,).Seq, (2,).Seq), ((3,).Seq, (4,).Seq), ((5,).Seq, (6,).Seq)]␤»

[00:29] <timotimo> m: my @a = (1, 2), (3, 4), (5, 6); my @b = @a>>.flat; say @b.perl

[00:29] *** SCHAAP137 left
[00:29] <camelia> rakudo-moar 620f4e: OUTPUT«[((1,).Seq, (2,).Seq), ((3,).Seq, (4,).Seq), ((5,).Seq, (6,).Seq)]␤»

[00:29] <timotimo> hmm.

[00:29] <timotimo> m: my @a = (1, 2), (3, 4), (5, 6); my @b = @a>>.flat; say @b.flat.perl

[00:29] <camelia> rakudo-moar 620f4e: OUTPUT«($((1,).Seq, (2,).Seq), $((3,).Seq, (4,).Seq), $((5,).Seq, (6,).Seq)).Seq␤»

[00:29] <timotimo> well, i don't know how to do this well :)

[00:30] <timotimo> m: my @a = (1, 2), (3, 4), (5, 6); my @b = @a>>.Slip; say @b.perl

[00:30] <camelia> rakudo-moar 620f4e: OUTPUT«[slip(1, 2), slip(3, 4), slip(5, 6)]␤»

[00:30] <rudi_s> ;-) - I got really confused when I try >>.flat and saw all those Seqs.

[00:30] <timotimo> yeah, they'd go away when you assign to a @foo, for example

[00:30] <timotimo> but since they are in the sublists still, that doesn't happen there

[00:30] *** cdg left
[00:31] <rudi_s> Yeah. Hm. So no easy way to flatten an array?

[00:31] <timotimo> oh, there is

[00:32] <sortiz> m: my @a = (1, 2), (3, 4), (5, 6); say @a[*;*]; # A trick

[00:32] <camelia> rakudo-moar 620f4e: OUTPUT«(1 2 3 4 5 6)␤»

[00:32] <timotimo> oh, that's cute

[00:32] <rudi_s> How does that work?

[00:33] <timotimo> ah, here we go; this is what i meant, but it didn't work the last time:

[00:33] <timotimo> my @a = (1, 2), (3, 4), (5, 6); my @b = @a.map(*.Slip); say @b.perl

[00:33] *** mr-foobar left
[00:33] <timotimo> m: my @a = (1, 2), (3, 4), (5, 6); my @b = @a.map(*.Slip); say @b.perl

[00:33] <camelia> rakudo-moar 620f4e: OUTPUT«[1, 2, 3, 4, 5, 6]␤»

[00:33] <geekosaur> treats it as a matrix and lists out the contents

[00:33] <geekosaur> ...in a flat way since [*;*] iterates the whole thing

[00:34] <sortiz>  m: my @a = (1, 2), (3, 4), (5, 6); say @a.List.flat;  # Other way

[00:34] <camelia> rakudo-moar 620f4e: OUTPUT«(1 2 3 4 5 6)␤»

[00:34] <rudi_s> Thanks - a little too much for my current perl knowledge.

[00:34] <rudi_s> sortiz: That looks good. Thanks.

[00:34] <timotimo> m: my @a = (1, 2), (3, 4), (5, 6); say @a.List.flat.perl;

[00:34] <camelia> rakudo-moar 620f4e: OUTPUT«(1, 2, 3, 4, 5, 6).Seq␤»

[00:34] <timotimo> oh, that's even easier

[00:34] <rudi_s> Too easy ..

[00:35] <sortiz> The real problem is that Array.flat don't attempt to flat, it should be named Array.Seq ;)

[00:40] *** Herby_ joined
[00:42] <Herby_> Evening, everyone!

[00:43] <sortiz> \o Herby_

[00:43] <Herby_> o/

[00:46] <sortiz> rudi_s, But beware with Array.List, it doesn't work if Array is-lazy.

[00:46] *** kid51 joined
[00:46] <rudi_s> sortiz: Hm. Are can slurpy parameters be non lazy? (I'm using it in a function with a sulpy array parameter).

[00:46] *** vendethiel joined
[00:47] <timotimo> we don't have lazy arrays, sortiz 

[00:48] <rudi_s> *be lazy

[00:49] <sortiz> m: my @a = [1..*];

[00:49] <camelia> rakudo-moar 620f4e: ( no output )

[00:49] <timotimo> hum. am i totally wrong?

[00:49] <sortiz> m: my @a = [1..*]; say @a.List

[00:49] <camelia> rakudo-moar 620f4e: OUTPUT«Cannot List a lazy list␤  in block <unit> at /tmp/LditQUsUOV line 1␤␤»

[00:49] <timotimo> m: my @a = [1..*]; say @a.WHAT

[00:49] <camelia> rakudo-moar 620f4e: OUTPUT«(Array)␤»

[00:49] <timotimo> huh, i *am* totally wrong!

[00:49] <timotimo> that's good :)

[00:50] <ugexe> m: my @a = 1,2,3,4,5; @a[2]:delete; say @a[0..*]

[00:50] <camelia> rakudo-moar 620f4e: OUTPUT«(1 2)␤»

[00:50] <ugexe> m: my @a = 1,2,3,4,5; @a[2]:delete; say @a[lazy 0..4]

[00:50] <camelia> rakudo-moar 620f4e: OUTPUT«(1 2)␤»

[00:51] <ugexe> m: my @a = 1,2,3,4,5; @a[2]:delete; say @a[0..4]

[00:51] <camelia> rakudo-moar 620f4e: OUTPUT«(1 2 (Any) 4 5)␤»

[00:52] <gfldex> m: class Brray is Array {}; my @b is Brray = Brray.new; say @b.WHAT; sub f(*@a){ say @a.WHAT }; f(@b);

[00:52] <camelia> rakudo-moar 620f4e: OUTPUT«(Brray)␤(Array)␤»

[00:52] <sortiz> m: my @a = [1,2,3, 4 ..*, (1..*)];

[00:52] <camelia> rakudo-moar 620f4e: ( no output )

[00:53] <sortiz> m: my @a = [1,2,3, 4 ..*, (1..*)]; dd @a;

[00:53] <camelia> rakudo-moar 620f4e: OUTPUT«Array @a = [1, 2, 3, 4..Inf, 1..Inf]␤»

[00:54] <gfldex> m: class Brray is Array { method here(){ say 'here' }}; my @b is Brray = Brray.new; say @b.WHAT; sub f(*@a){ say @a.WHAT; @a.here }; f(@b);

[00:54] <camelia> rakudo-moar 620f4e: OUTPUT«(Brray)␤(Array)␤Method 'here' not found for invocant of class 'Array'␤  in sub f at /tmp/cAIBBf4p0p line 1␤  in block <unit> at /tmp/cAIBBf4p0p line 1␤␤»

[00:55] <gfldex> do I understand camelia right, that she believes that slurpies should "typecast"?

[00:55] <timotimo> "typecast"?

[00:55] <timotimo> slurpies will cause a single array argument to be un- and re-packed

[00:56] <gfldex> it does coerce Brray to Array but i'm not sure if coerce is what really happens

[00:59] *** zpmorgag joined
[01:02] *** BenGoldberg joined
[01:03] <sortiz> gfldex, A slurpy argument eats as many positional args you pass to one Array:

[01:03] <sortiz> m: sub f(*@a){ dd  @a }; f([1,2,3,4],<a b c d>,[5,6,7]);

[01:03] <camelia> rakudo-moar 620f4e: OUTPUT«[1, 2, 3, 4, "a", "b", "c", "d", 5, 6, 7]␤»

[01:04] <gfldex> m: sub f(**@a){ dd  @a }; f([1,2,3,4],<a b c d>,[5,6,7]);

[01:04] <camelia> rakudo-moar 620f4e: OUTPUT«[[1, 2, 3, 4], ("a", "b", "c", "d"), [5, 6, 7]]␤»

[01:04] *** adu left
[01:04] <gfldex> and it flattens on top of that

[01:04] <gfldex> so it doesnt coerce

[01:05] *** roguelazer left
[01:05] <sortiz> Yes, and use double ** for not flattening.

[01:05] *** roguelazer joined
[01:07] *** snarkyboojum joined
[01:07] <gfldex> m: class Brray is Array { method here(){ say 'here' }}; my @b is Brray = Brray.new; say @b.WHAT; sub f(@a){ say @a.WHAT; @a.here }; f(@b);

[01:07] <camelia> rakudo-moar 620f4e: OUTPUT«(Brray)␤(Brray)␤here␤»

[01:08] *** vendethiel left
[01:08] <timotimo> there's also +@foo for the "single-argument rule" semantics we have in most core methods and subs

[01:09] <gfldex> timotimo: and you are waiting for me to doc that, don't you? :->

[01:09] <sortiz> :-P

[01:10] *** raiph left
[01:10] <timotimo> i'm not deep enough into the proper list semantics, sorry. i've been paying much less attention to stuff in the last ~half-year ;(

[01:16] *** dh7320 left
[01:17] *** dh7320 joined
[01:19] *** raiph joined
[01:20] <timotimo> Use of uninitialized value of type SDL_INIT in string context

[01:20] <timotimo> Any of .^name, .perl, .gist, or .say can stringify undefined things, if needed.  in any optimize_call at gen/moar/m-Perl6-Optimizer.nqp line 1503

[01:20] <timotimo> ^- btw, this is amusing, but probably pretty terrible :)

[01:23] <sortiz> Seems awful, yes.

[01:23] *** zpmorgag left
[01:25] <sortiz> m: sub f(**@a) { dd @a }; f([1..*])

[01:25] <camelia> rakudo-moar 620f4e: OUTPUT«Cannot .elems a lazy list␤  in sub f at /tmp/RzZSHAPoHZ line 1␤  in block <unit> at /tmp/RzZSHAPoHZ line 1␤␤Actually thrown at:␤  in sub f at /tmp/RzZSHAPoHZ line 1␤  in block <unit> at /tmp/RzZSHAPoHZ line 1␤␤»

[01:25] <sortiz> m: sub f(*@a) { dd @a }; f([1..*])

[01:25] <camelia> rakudo-moar 620f4e: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8, 9, 10...Inf)␤»

[01:26] <sortiz> m: sub f(**@a) { @a.gist.say }; f([1..*])

[01:26] <camelia> rakudo-moar 620f4e: OUTPUT«[[...]]␤»

[01:28] <sortiz> rudi_s, Was this your question?  ^^^ Laziness survive both forms of slurpies

[01:30] <sortiz> m: sub f(*@a) { @a.is-lazy.say }; f([1..*]);

[01:30] <camelia> rakudo-moar 620f4e: OUTPUT«True␤»

[01:31] *** dh7320 left
[01:31] <sortiz> m: sub f(**@a) { @a[0].is-lazy.say }; f([1..*]);

[01:31] <camelia> rakudo-moar 620f4e: OUTPUT«True␤»

[01:33] <rudi_s> sortiz: It does, thanks. Then .List is potentially problematic for my function. But it's not a library so I just have to remember not to call it with a lazy list.

[01:34] *** telex left
[01:36] *** risou is now known as risou_awy

[01:36] *** risou_awy is now known as risou

[01:38] *** skids joined
[01:38] *** Guest47022 is now known as nemo

[01:38] *** kaa joined
[01:44] *** Actualeyes joined
[01:50] *** vendethiel joined
[01:54] *** telex joined
[01:57] <sortiz> .seen hoelzro 

[01:57] <yoleaux> I saw hoelzro 22 Feb 2016 19:51Z in #perl6: * hoelzro has memories of family thinking "that Java thing is a virus"

[01:59] *** davido joined
[02:02] <sortiz> .tell hoelzro I Have a working implementation of the idea that I mentioned to you in https://github.com/rakudo/rakudo/pull/718

[02:02] <yoleaux> sortiz: I'll pass your message to hoelzro.

[02:02] *** Ben_Goldberg joined
[02:05] *** BenGoldberg left
[02:09] *** BenGoldberg joined
[02:09] *** Ben_Goldberg left
[02:10] *** BenGoldberg left
[02:11] *** BenGoldberg joined
[02:11] *** vendethiel left
[02:12] *** davido left
[02:18] <llfourn> any way to specify a custom test harness for a module?

[02:18] <llfourn> so that panda etc don't just blindly prove everything in t

[02:18] <timotimo> m: say Any

[02:18] <camelia> rakudo-moar 620f4e: OUTPUT«(Any)␤»

[02:32] *** TreyHarris left
[02:35] *** jameslenz left
[02:36] *** kid51 left
[02:39] *** zpmorgag joined
[02:40] *** labster left
[02:42] *** Ben_Goldberg joined
[02:42] <sortiz> llfourn, panda etc prove everything in t that ends with .t, so I would try with .ct for customized. And start the custom harness in t/mytests.t

[02:43] <llfourn> sortiz: mmm yeah that's what I was thinking

[02:43] *** adu joined
[02:43] <llfourn> thanks

[02:43] <sortiz> yw

[02:44] *** AlexDaniel left
[02:44] *** BenGoldberg left
[02:48] *** BenGoldberg_ joined
[02:49] *** _dolmen_ joined
[02:49] *** kaa left
[02:50] *** Ben_Goldberg left
[02:56] *** raiph left
[02:58] *** ka joined
[03:05] *** raiph joined
[03:06] *** roguelazer left
[03:29] *** ka left
[03:29] *** ka joined
[03:33] *** tharkun left
[03:33] *** tharkun joined
[03:50] *** roguelazer joined
[03:52] *** noganex_ joined
[03:53] *** roguelazer left
[03:54] *** roguelazer joined
[03:56] *** yqt left
[03:56] *** noganex left
[04:03] *** snarkyboojum left
[04:06] *** AlexDaniel joined
[04:06] *** sevvie left
[04:08] *** _dolmen_ left
[04:14] *** vendethiel joined
[04:23] *** adu left
[04:25] *** adu joined
[04:25] *** adu left
[04:26] *** labster joined
[04:28] *** Herby_ left
[04:37] *** ka left
[04:37] *** ka joined
[04:38] *** vendethiel left
[04:38] *** Ben_Goldberg joined
[04:40] *** BenGoldberg_ left
[04:49] *** ka left
[04:52] *** perturbation left
[04:55] *** perturbation joined
[04:58] *** adu joined
[05:06] *** lustlife joined
[05:09] *** lustlife left
[05:10] <AlexDaniel> Juerd: hah, I like your solution :)

[05:11] <AlexDaniel> Juerd: what about ignoring $num ?

[05:13] *** jeek joined
[05:16] <AlexDaniel> Juerd: yea, it works

[05:16] <AlexDaniel> Juerd: get; my Bool @switches; :)

[05:19] *** lustlife joined
[05:34] *** Ben_Goldberg left
[06:02] *** Cabanossi left
[06:02] *** telex left
[06:04] *** Cabanossi joined
[06:04] *** telex joined
[06:08] *** skids left
[06:08] *** autarch left
[06:08] *** vendethiel joined
[06:21] *** raiph left
[06:27] *** hippie1 left
[06:35] <AlexDaniel> m: my @a = <a b c>; @a.splice: 1, 0, 2..5; say @a

[06:35] <camelia> rakudo-moar 620f4e: OUTPUT«[a 2 3 4 5 b c]␤»

[06:35] <AlexDaniel> why?

[06:35] <AlexDaniel> m: my @a = <a b c>; @a.splice: 1, 0, (2..5,); say @a

[06:35] <camelia> rakudo-moar 620f4e: OUTPUT«[a 2..5 b c]␤»

[06:35] *** atweiden left
[06:35] <AlexDaniel> I expected this ↑

[06:36] *** cpage_ joined
[06:51] *** adu left
[06:59] *** molaf joined
[07:03] *** noganex_ left
[07:23] <AlexDaniel> Juerd: I wrote a solution that is significantly faster

[07:23] <AlexDaniel> Juerd: but it is still not enough to parse this 3mb file

[07:23] <AlexDaniel> perhaps if I slap binary search on top of that it will suddenly become much faster… but somehow I doubt it

[07:27] *** sno left
[07:30] *** vendethiel- joined
[07:32] *** vendethiel left
[07:35] <AlexDaniel> m: my @a; say @a.end

[07:35] <camelia> rakudo-moar 620f4e: OUTPUT«-1␤»

[07:35] *** CIAvash joined
[07:37] *** _mg_ joined
[07:41] *** RabidGravy joined
[07:43] *** firstdayonthejob joined
[07:44] <AlexDaniel> why -1 and not Nil or something else?

[07:45] *** domidumont joined
[07:46] *** ka joined
[07:47] *** FROGGS joined
[07:49] *** domidumont left
[07:51] *** domidumont joined
[07:51] *** rindolf joined
[07:51] <[Tux]> test            22.300

[07:51] <[Tux]> test-t          11.934

[07:51] <[Tux]> csv-parser      49.556

[07:52] *** noganex joined
[07:54] *** fireartist joined
[07:56] *** araujo left
[08:01] *** sno joined
[08:01] *** wamba joined
[08:03] *** tmch joined
[08:06] *** zakharyas joined
[08:07] *** darutoko joined
[08:16] *** ka left
[08:16] *** ka joined
[08:17] <dalek> Inline-Perl5/threading_fixes: ebd7261 | (Stefan Seifert)++ | p5helper.c:

[08:17] <dalek> Inline-Perl5/threading_fixes: Make sure we call PERL_SET_CONTEXT before accessing P5 in any way

[08:17] <dalek> Inline-Perl5/threading_fixes: 

[08:17] <dalek> Inline-Perl5/threading_fixes: Important for handling multiple P5 interpreters.

[08:17] <dalek> Inline-Perl5/threading_fixes: review: https://github.com/niner/Inline-Perl5/commit/ebd7261cce

[08:18] *** neilb joined
[08:21] *** araujo joined
[08:24] *** abraxxa joined
[08:29] *** salva joined
[08:33] <RabidGravy> HARR!

[08:36] <lizmat> bless you!

[08:38] *** AlexDaniel left
[08:39] *** firstdayonthejob left
[08:40] *** ely-se joined
[08:52] *** vendethiel- left
[08:58] <renormalist> On http://moarvm.com/features.html it says "On x64, much hot code can also be JIT-compiled into machine code". With x64, does it mean x86_64?

[08:58] *** nakiro joined
[08:58] *** cpage_ left
[09:00] *** ka left
[09:02] <lizmat> renormalist: I would think so

[09:03] <ilmari> yes. x64, x86_64 and amd64 are all names for the same cpu architecture

[09:05] <ely-se> with x86_64, do you mean x86-64?

[09:05] *** azawawi joined
[09:05] <azawawi> https://atom.io/packages/atom-perl6-editor-tools # More animated screencasts

[09:05] <azawawi> and hi #perl6 :)

[09:06] <sortiz> \o #perl6

[09:06] *** st_iron joined
[09:06] *** cpage_ joined
[09:06] <renormalist> ok, thanks

[09:12] *** st_iron left
[09:12] *** vendethiel joined
[09:14] <renormalist> Is the Pugs source code only hosted on google code archive? https://code.google.com/archive/p/pugs/source 

[09:16] *** vytas left
[09:17] *** neilb left
[09:17] <ilmari> https://github.com/audreyt/Pugs.hs

[09:18] * renormalist just pressed the Export button on Pugs page :-)

[09:18] <ilmari> ah, no, https://github.com/perl6/Pugs.hs

[09:18] <ilmari> the link in https://github.com/perl6/mu/blob/master/README should be updated

[09:18] <renormalist> ilmari: ah, I didn't find that

[09:19] <renormalist> thanks

[09:19] *** vytas joined
[09:19] <renormalist> (now I have more than enough Pugs around :-))

[09:20] *** atta left
[09:21] *** neilb joined
[09:21] <renormalist> Maybe someone already knows the answer: was Pugs using Haskell's Parsec parser lib or was it doing its own thing?

[09:24] <peteretep> parsec

[09:24] *** ely-se left
[09:24] <peteretep> https://hackage.haskell.org/package/Pugs

[09:25] * peteretep wonders what Audrey is up to

[09:25] *** atta joined
[09:26] <peteretep> Looks like she's gone all political

[09:28] *** zakharyas left
[09:29] *** TEttinger left
[09:30] *** zakharyas joined
[09:30] *** TEttinger joined
[09:32] * lizmat clickbaits https://p6weekly.wordpress.com/2016/02/22/2016-8-yacr/ before being away for a few hours&

[09:32] *** atta left
[09:33] *** atta joined
[09:33] *** azawawi left
[09:34] *** dakkar joined
[09:35] *** ka joined
[09:36] *** vendethiel left
[09:36] <FROGGS> lizmat++

[09:52] <stmuk_> "you wouldn't believe what happened in perl 6 this week"

[10:00] <nine> m: my %h = a => [1, 2, 3], b => [3, 4], c => [5]; for %h.pairs.sort({$^a.key cmp $^b.key}).map(*.kv) -> ($name, @postings) { say $name; say @postings; }

[10:00] <camelia> rakudo-moar 620f4e: OUTPUT«a␤[1 2 3]␤b␤[3 4]␤c␤[5]␤»

[10:00] <nine> There must be a shorter way than this ^^^

[10:03] <dalek> perl6-most-wanted: 8641ca2 | (Brian Gomes Bascoy)++ | most-wanted/modules.md:

[10:03] <dalek> perl6-most-wanted: Update modules.md

[10:03] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/8641ca27f2

[10:03] <dalek> perl6-most-wanted: a02d30f | azawawi++ | most-wanted/modules.md:

[10:03] <dalek> perl6-most-wanted: Merge pull request #17 from pera/patch-1

[10:03] <dalek> perl6-most-wanted: 

[10:03] <dalek> perl6-most-wanted: Update modules.md

[10:03] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/a02d30f899

[10:07] *** solarbunny joined
[10:08] <sortiz> m: my %h = z => [1, 2, 3], x => [3, 4], y => [5]; say %h{$_}:kv for %h.keys.sort;

[10:08] <camelia> rakudo-moar 620f4e: OUTPUT«(x [3 4])␤(y [5])␤(z [1 2 3])␤»

[10:10] <nine> sortiz: That's close to the original Perl 5 code and exactly what I wanted to replace with something more elegant :)

[10:11] *** vendethiel joined
[10:11] <sortiz> m: my %h = z => [1, 2, 3], x => [3, 4], y => [5]; say |(%h{$_}:kv) for %h.keys.sort; # With a touch of elegance ;)

[10:11] <camelia> rakudo-moar 620f4e: OUTPUT«x[3 4]␤y[5]␤z[1 2 3]␤»

[10:12] <nine> m: my %h = a => [1, 2, 3], b => [3, 4], c => [5]; for %h.pairs.map(*.kv) -> ($name, @postings) { say $name; say @postings; }

[10:12] <camelia> rakudo-moar 620f4e: OUTPUT«a␤[1 2 3]␤c␤[5]␤b␤[3 4]␤»

[10:12] <nine> Works, too, but only because of Pair's stringification

[10:16] <jnthn> nine: %h.pairs.sort({$^a.key cmp $^b.key}) can be %h.sort(*.key)

[10:19] <nine> jnthn: Aaaah...it decides by arity :) Thanks!

[10:21] <jnthn> Yeah, and .sort will iterate the hash, which by default gets you pairs, so no need to do that explicitly either

[10:28] <nine> Invalid GC status observed; aborting

[10:31] <nine> Happens just by wrapping a block in await start { }

[10:32] *** vendethiel left
[10:38] *** cpage_ left
[10:40] *** labster left
[10:43] *** labster joined
[10:43] <DrForr> MadcapJake: Latest Prancer push fixes the issues you noticed with the exception of text/plain, I might get to that tonight.

[10:54] *** labster left
[10:56] *** labster joined
[10:56] *** labster left
[10:59] *** mr-foobar joined
[11:07] *** rindolf left
[11:08] *** ely-se joined
[11:09] *** TEttinger left
[11:12] *** rindolf joined
[11:14] *** cgfbee joined
[11:20] *** sortiz left
[11:21] *** ely-se left
[11:24] *** pmurias joined
[11:24] *** ka left
[11:26] *** ka joined
[11:26] <pmurias> jnthn: re performance grant, based on nqp-js experience working on the profiler seems like a promissing thing, I'm using the chrome's builtin profiler for nqp-js code and it's finding some really suprising things

[11:27] <jnthn> pmurias: Yeah, the current Moar one has turned up plenty also :)

[11:27] <jnthn> Though you need to have got the problem down to something quite small for it to be usable.

[11:28] <pmurias> for example a large time of parsing json was spent doing nqp::callercode ;)

[11:28] <jnthn> o.O

[11:28] <jnthn> Doubt we'd find that on Moar...pretty sure that's a couple of pointer follows :)

[11:29] <jnthn> But sure there's other such things

[11:29] <pmurias> it was something really specific to the v8 jit

[11:29] <jnthn> ah :)

[11:30] <jnthn> But yeah, agree that having better profiling tools will let us turn up more issues.

[11:30] <pmurias> the v8 tools even sometimes show a cute little yellow warning sign that the v8 jit refuses to optimize a given sub ;)

[11:31] <pmurias> s/v8 tools/chrome's profiler/

[11:32] <dalek> nqp: d555ce0 | (Pawel Murias)++ | src/vm/js/ (3 files):

[11:32] <dalek> nqp: [js] Implement nqp::curcode() in a simpler way.

[11:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d555ce0e9e

[11:32] <dalek> nqp: 791d643 | (Pawel Murias)++ | src/vm/js/nqp-runtime/reprs.js:

[11:32] <dalek> nqp: [js] optimize P6opaque.allocate

[11:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/791d643c47

[11:34] *** donaldh joined
[11:39] *** zpmorgag left
[11:42] *** haircode joined
[11:45] *** kaare_ joined
[11:49] *** raiph joined
[11:53] <nine> Threading allows for all sorts of exciting new error messages ;) Internal error: unhandled dyncall argument type

[11:56] *** haircode left
[11:57] <lizmat> nine: while working on PackUnpack, I found that if I run it like "perl6 -Ilib _e 'use PackUnpack'" and there is a compile error, I get the dsame error message twice

[11:57] <lizmat> *-e

[11:57] <FROGGS> nine: is that error reproducable?

[11:57] <lizmat> is that to be expected, or is it odd?

[11:58] *** haircode joined
[12:00] <nine> lizmat: sounds rather odd

[12:00] *** ka left
[12:00] <lizmat> ok, I will look deeper into it then

[12:01] <nine> FROGGS: no :/ I do get a reproducable "Scalars leaked: -1" message at the end of the program. But I don't even know if that's Perl 6 or Perl 5.

[12:01] <jnthn> Perl 5

[12:01] <jnthn> I'd think

[12:01] <jnthn> Seems a very unlikely message from a Perl 6 perspective.

[12:02] <jnthn> nine: https://github.com/Perl/perl5/blob/9d876b687d12d77fcb1012f1b865783476f00c7a/perl.c#L1219

[12:06] <lizmat> nine: that most definitely is a P5 message: I know it well from the early ithreads days  :-)

[12:08] <nine> Then that's work for me I guess :)

[12:09] <nine> FROGGS: I just got the dyncall thing a second time

[12:11] <ilmari> how do you leak -1 scalar?

[12:11] <ilmari> free one you didn't allocate?

[12:11] <nine> ilmari: threading

[12:12] <nine> I thought it would be fun giving the "run separate Perl 5 interpreters in multiple Perl 6 threads" idea a try ;)

[12:13] <ilmari> nine: I meant conceptually...

[12:13] <jnthn> Leaking -1 scalars isn't normal...but it is on threads!

[12:13] <ilmari> freeing the same scalar twice?

[12:14] <lizmat> wouldn't that be a double free ?

[12:14] *** sufrostico joined
[12:15] *** _mg_ left
[12:15] <moritz> maybe the number of scalars overflowed :-)

[12:16] <FROGGS> hmmm

[12:16] <nine> It always seems to be -1

[12:16] <FROGGS> nine: if it persists I could try to look at that... though I'm not an expert when it comes to threading

[12:18] *** ka joined
[12:25] *** ka left
[12:30] *** pmurias left
[12:30] *** pmurias joined
[12:31] *** _mg_ joined
[12:31] *** pmurias left
[12:32] *** ka joined
[12:35] *** pmurias joined
[12:37] *** skids joined
[12:41] *** skids left
[12:43] *** donaldh left
[12:52] *** nowan left
[12:55] *** nowan joined
[13:00] *** rindolf left
[13:01] *** Skarsnik joined
[13:01] *** sufrostico left
[13:02] *** gensym left
[13:05] *** ka left
[13:07] *** ka joined
[13:09] <|Tux|> Do signatures support either/or types? «method foo (IO $handle, Str|Callable $x) { … }»

[13:10] <|Tux|> of course I can make two methods with different signatures

[13:10] *** virtualsue joined
[13:10] <psch> m: sub f ($a where Str|Callable) { say $a.WHAT }; f -> { }; f "foo"; f 42 

[13:10] <camelia> rakudo-moar 620f4e: OUTPUT«(Block)␤(Str)␤Constraint type check failed for parameter '$a'␤  in sub f at /tmp/Lq8IJylcAC line 1␤  in block <unit> at /tmp/Lq8IJylcAC line 1␤␤»

[13:10] <jnthn> No, you'd need to do it in a where

[13:10] <psch> right, technically not a type but a constraint

[13:10] <|Tux|> that'll do

[13:11] <dalek> rakudo/nom: 96a1954 | lizmat++ | src/core/Buf.pm:

[13:11] <dalek> rakudo/nom: int arrays now can Buf.push|append|unshift|prepend

[13:11] <dalek> rakudo/nom: 

[13:11] <dalek> rakudo/nom: They couldn't before:

[13:11] <dalek> rakudo/nom:   This representation (VMArray) does not support attribute storage

[13:11] <dalek> rakudo/nom: 

[13:11] <dalek> rakudo/nom: It's still a bit slower than using Int arrays, but I guess another

[13:11] <dalek> rakudo/nom: round of speshing/optimizing/jitting will take care of that in the

[13:11] <dalek> rakudo/nom: future

[13:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/96a1954024

[13:15] <rudi_s> m: "hi\r\nho\nhu".split("\n").perl

[13:15] <camelia> rakudo-moar 620f4e: ( no output )

[13:15] <rudi_s> m: say "hi\r\nho\nhu".split("\n").perl

[13:15] <camelia> rakudo-moar 620f4e: OUTPUT«("hi\r\nho", "hu")␤»

[13:16] <rudi_s> Is this expected and if so how can I fix it? I want to split on "\n", but "\r\n" is treated as single character.

[13:16] <rudi_s> I want to split on all "\n" no matter what else is before/after it.

[13:16] <timotimo> m: say "hi\r\nho\nhu".lines

[13:16] <camelia> rakudo-moar 620f4e: OUTPUT«(hi ho hu)␤»

[13:16] <timotimo> m: say "hi\r\nho\nhu".lines.perl

[13:16] <camelia> rakudo-moar 620f4e: OUTPUT«("hi", "ho", "hu").Seq␤»

[13:18] <rudi_s> I can understand that it happens for lines (well, not really, but well). But I still want a way to split on the character "\n".

[13:19] <timotimo> m: say ord("\n")

[13:19] <camelia> rakudo-moar 620f4e: OUTPUT«10␤»

[13:19] <timotimo> m: say "hi\r\nho\nhu".split(/ \x0a /).perl

[13:19] <camelia> rakudo-moar 620f4e: OUTPUT«("hi\r\nho", "hu")␤»

[13:20] <timotimo> m: say "hi\r\x0aho\nhu".split(/ \x0a /).perl

[13:20] <camelia> rakudo-moar 620f4e: OUTPUT«("hi\r\nho", "hu")␤»

[13:20] <timotimo> the magic of newlines ...

[13:20] <lizmat> timotimo : \r\n is a synthetic

[13:20] *** n0xff joined
[13:20] <timotimo> we're treating \r\n as one thing, as unicode prescribes it

[13:20] <timotimo> so it's hard to split it open. because we go to extra lengths to prevent splitting things that are one grapheme

[13:20] <timotimo> because that's what makes other programming languages suck at unicode

[13:22] <rudi_s> Well, it makes perl6 suck at handling byte-oriented data. - Any idea how I can fix that? I get output from a program which I must split on just "\n".

[13:22] <psch> rudi_s: if you want to deal with your Str as bytes Buf it

[13:23] <timotimo> yeah

[13:23] <psch> rudi_s: you need to specify an encoding then, and handle it as a byte array too

[13:24] <rudi_s> How do I split on Buf?

[13:24] <lizmat> m: dd "a\r\nb\nc\rd".split(("\n","\r\n","\r"),:k)   # perhaps this can be of use, rudi_s ?

[13:24] <camelia> rakudo-moar 620f4e: OUTPUT«("a", 1, "b", 0, "c", 2, "d")␤»

[13:25] <timotimo> ah, good catch liz

[13:25] <lizmat> it would allow you to differentiate between \r \r\n and \n

[13:25] <rudi_s> Well, then I'd have to manually combine it later.

[13:25] <rudi_s> How do I split a Buf?

[13:26] <lizmat> rudi_s: we don't atm, afaik

[13:26] <psch> m: my $buf = "hi\r\nhu\nho".encode('ascii'); say $buf.grep(* != "\x0a")

[13:26] <camelia> rakudo-moar 620f4e: OUTPUT«(104 105 13 10 104 117 10 104 111)␤»

[13:26] <psch> uh

[13:26] *** donaldh joined
[13:26] <psch> yeah, stupid comparison there :)

[13:26] <psch> m: my $buf = "hi\r\nhu\nho".encode('ascii'); say $buf.grep(* != 10) 

[13:26] <camelia> rakudo-moar 620f4e: OUTPUT«(104 105 13 104 117 104 111)␤»

[13:27] <rudi_s> lizmat: Awesome ...

[13:27] <psch> well, that's not splitting

[13:27] <psch> rudi_s: .split is inherintly a Str operation, and Buf/Blob are byte arrays

[13:27] *** autarch joined
[13:28] <rudi_s> psch: Well, there should still be a way to split a Buf on a byte.

[13:32] <pmurias> isn't a Buf already a byte array?

[13:33] <pmurias> what's the point of spliting it?

[13:33] *** autarch left
[13:33] *** autarch joined
[13:33] *** nightfrog left
[13:34] <RabidGravy> there's a sub in H::UA that searches for a byte sequence in a buf, which is then used for doing a subbuf

[13:35] <RabidGravy> but that's what 'split on a Buf' implies

[13:35] *** Actualeyes left
[13:36] <rudi_s> pmurias: Did you see my example above? That's all I want to do.

[13:36] <psch> well, afaiu this generalizes to "separate a List into multiple List delimited by $x"

[13:36] <rudi_s> Yes.

[13:36] <psch> which i think could be convenient enough as a builtin, but i maybe it's not vOv

[13:36] <renormalist> I'm getting: NativeCall: Consider adding the api version of the library you want to use, sub foo is native(readline, v1) with each perl6 prompt.

[13:36] <psch> s:2nd/ i //

[13:37] <renormalist> Anyone knows how I can avoid that?

[13:37] <psch> in any case, probably needs prototyping :)

[13:37] *** dbrunton joined
[13:37] <renormalist> Probably from Readline - can I uninstall a panda lib?

[13:37] *** ka left
[13:37] <nine> rudi_s: how about $buf.decode('latin-1').split("\n")? latin-1 should give you basically one byte per character

[13:37] <psch> fwiw, i can't think of anything idiomatic off the top of my head

[13:38] <psch> the general case that is, nine's idea seems fitting enough here...

[13:38] <jnthn> nine: Uh...but if you decode it to a Str then NFG applies and \r\n becomes a grapheme :)

[13:38] <jnthn> We probably should have a Buf.split, which takes a Blob to split on

[13:39] <jnthn> And it'd Blob.split too

[13:40] *** colomon left
[13:40] *** ka joined
[13:40] *** jameslenz joined
[13:41] <nine> renormalist: perl6 -e 'my $cu = $*REPO.resolve(CompUnit::DependencySpecification.new(:short-name<Readline>)); $cu.repo.uninstall($cu.distribution);'

[13:41] <DrForr> renormalist: Thanks, I'll fix that in a few.

[13:41] <RabidGravy> https://github.com/sergot/http-useragent/blob/master/lib/HTTP/UserAgent.pm6#L92

[13:43] <renormalist> nine: hm, I get: Method 'resolve' not found for invocant of class 'CompUnit::Repository::Installation'

[13:43] <nine> renormalist: then your rakudo version doesn't support uninstall yet

[13:44] <renormalist> nine: hm, I'm on Rakudo* 2016.01 made with perl5.22.1 - can I do something about it?

[13:44] *** mr-foobar left
[13:44] <renormalist> nine: like rebuild with some option?

[13:44] <nine> renormalist: upgrade to 2016.02

[13:45] <pmurias> nine: would decoding utf8 as latin1 work correctly?

[13:45] * renormalist tries...

[13:45] *** mr-foobar joined
[13:45] <nine> pmurias: well it wouldn't help anyway as jnthn++ pointed out. But pretty much everything can be interpreted as latin-1.

[13:46] <jnthn> pmurias: For some interesting definition of "correctly". Every valid utf-8 sequence will decode as latin-1 for the same reason everything decodes as latin-1 :)

[13:47] <pmurias> just using a loop on the buf seems cleaner than decoding to latin1, spliting on "\n" encoding back to a buf and recoding as utf8

[13:47] <renormalist> nine: can you point me to upgrade instructions, 2016.02 doesn't seem to be official by just tweaking URLs with s/01/02/g

[13:47] <RabidGravy> is the CompUnit::Repository.installed() not implemented yet?

[13:48] <jnthn> pmurias: And that won't help anyway, because \r\n in latin-1 is still 1 grapheme after decoding :)

[13:49] <nine> renormalist: Sorry, I've only ever installed rakudo straight from git.

[13:49] <renormalist> nine: oh, do I mix up rakudo with rakudo star?

[13:49] <nine> renormalist: probably

[13:49] <nine> RabidGravy: installed()?

[13:49] <renormalist> nine: mkay, don't worry, I will play around a bit, thanks so far.

[13:51] <RabidGravy> "Returns the Distribution objects for all installed distributions" says the comment in Compunit::Repository::Installable

[13:51] *** Psyche^ joined
[13:51] <RabidGravy> which would be way handy

[13:52] <nine> RabidGravy: oh...seems like I forgot to implement that

[13:53] <RabidGravy> :)

[13:53] <RabidGravy> I couldn't work out how to get the information otherwise

[13:53] *** Actualeyes joined
[13:55] *** Psyche^_ left
[13:56] *** pierrot joined
[13:59] <rudi_s> Hm. I can't even check if the string contains that char: say "\r\n".contains("\n") ...

[13:59] *** dakkar_ joined
[13:59] <rudi_s> That's really problematic for my use case.

[13:59] <FROGGS> say "\r\n".NFCD

[13:59] <FROGGS> m: say "\r\n".NFCD

[13:59] <camelia> rakudo-moar 96a195: OUTPUT«Method 'NFCD' not found for invocant of class 'Str'␤  in block <unit> at /tmp/AEhyyCoEMV line 1␤␤»

[13:59] <FROGGS> m: say "\r\n".NFC

[13:59] <camelia> rakudo-moar 96a195: OUTPUT«NFC:0x<000d 000a>␤»

[13:59] <FROGGS> m: say "\r\n".NFC.grep: "\n"

[13:59] <camelia> rakudo-moar 96a195: OUTPUT«()␤»

[14:00] <FROGGS> m: say "\r\n".NFKD.grep: "\n"

[14:00] <camelia> rakudo-moar 96a195: OUTPUT«()␤»

[14:00] <FROGGS> m: say "\r\n".NFKD

[14:00] <camelia> rakudo-moar 96a195: OUTPUT«NFKD:0x<000d 000a>␤»

[14:00] <FROGGS> m: say "\r\n".NFKD.grep: "\n".ord

[14:00] <camelia> rakudo-moar 96a195: OUTPUT«(10)␤»

[14:00] <FROGGS> m: say so "\r\n".NFKD.grep: "\n".ord

[14:00] <camelia> rakudo-moar 96a195: OUTPUT«True␤»

[14:00] <jnthn> rudi_s: That's because \r\n is a different character to \n

[14:00] <FROGGS> rudi_s: ^^

[14:01] <psch> m: "\r\n".chars.say

[14:01] <camelia> rakudo-moar 96a195: OUTPUT«1␤»

[14:01] *** dakkar left
[14:02] *** ely-se joined
[14:02] <perlpilot> rudi_s: imho, if you mean to talk about line feed characters and carriage return characters, it's best to stay away from \n and \r and instead use hex or octal or some other representation that doesn't have some extra symbolic meaning attached to it.

[14:03] <rudi_s> jnthn: FROGGS: Well, yes. I understand that.

[14:03] <rudi_s> perlpilot: Doesn't help me if I get input from outside of my program.

[14:03] * psch wonders what didn't work about .lines

[14:04] <psch> oh.  the \r was supposed to stick around, wasn't it

[14:04] <timotimo> yeah, that's what

[14:04] <rudi_s> Yeah.

[14:05] <jnthn> So I'd do it at byte level, which will just be a little inconvenient at the moment due to the lack of a Blob.split method

[14:05] <timotimo> but the split :k thing should help

[14:05] *** skids joined
[14:05] <jnthn> Or what timo said

[14:05] *** virtualsue left
[14:06] <perlpilot> rudi_s: or you could implement Blob.split for the next guy (which is probably you again :)

[14:07] <rudi_s> Are there more Str surprises I should be aware of? Basically I want that input and output stays the same even when it passes through Str.

[14:07] <stmuk_> I'm trying to use a channel to plot SDL based on a number of promises calc'ing a mandelbrot .. and it seems slower than not using concurrency .. is there anything obviously wrong with 

[14:07] <stmuk_> https://github.com/stmuk/contalk/blob/master/mbrot4.p6

[14:08] <moritz> stmuk_: how many calculation do you do per promise?

[14:09] <stmuk_> not sure yet

[14:10] <moritz> you might need to a few thousand or ten thousand to make up for the concurrency overhead

[14:10] <stmuk_> I was getting better results by limiting the number of threads very low

[14:10] <stmuk_> I only have dual core machines as well

[14:13] <stmuk_> actually probably less than 100 calcs :/

[14:13] *** cdg joined
[14:14] <psch> rudi_s: afaiu passing through Str has to slightly change the data because unicode is weird

[14:15] <psch> rudi_s: as in, perl6 does some unicode-y things more sensible (or even correctly?) than many other implementations, which screws with the other implementations expectations... there is probably a blog post by jnthn++ that explains it better and in more detail...

[14:15] <jnthn> Str promises Unicode canonical equivalence, not original bytes equivalence.

[14:15] <stmuk_> actually increasing the size of the image should give me very much calcs/promise

[14:16] <RabidGravy> nine, installed() something like https://gist.github.com/jonathanstowe/be951a63cbf713cff2b5 ?

[14:17] <rudi_s> psch: jnthn: Thanks. Will have to think how can use that properly for my use case.

[14:17] <rudi_s> *how I can

[14:18] <rudi_s> jnthn: "not original bytes equivalence" is problematic for Paths, but last time you convinced me that Perl6 handles that correctly. Was that an incorrect assumption? 

[14:19] <FROGGS> rudi_s: if you need to stick to the "original bytes and their ordering" stick to the bytes level

[14:19] <jnthn> rudi_s: We use a differnet encoding for those, that uses NFG synthetics to represent things so they can round-trip. But it will also frustrate proper string processing.

[14:20] <rudi_s> jnthn: Ah, so it's all in the special encoding/decoding. Good.

[14:21] <jnthn> rudi_s: So, you really only want to use that for interchange with the OS.

[14:21] <rudi_s> Ok.

[14:21] *** dbrunton left
[14:21] <jnthn> You *can* read a file with it, but you'll get really "interesting" effects if you try and do string equality and the two files happen to have been in different Unicode normal forms.

[14:23] *** jameslenz left
[14:23] <rudi_s> Won't try that then.

[14:25] *** jameslenz joined
[14:27] *** colomon joined
[14:34] * [Coke] yawn.

[14:34] <[Coke]> s

[14:34] <nine> RabidGravy: I think it's meant to be per repo, not for the whole repo chain

[14:35] <RabidGravy> well even easier then :)

[14:36] <nine> yeah, something like: method installed() { self.prefix.child('dist').dir.map({ Distribution.new(|from-json $_.slurp) })

[14:40] *** dakkar__ joined
[14:44] <renormalist> sorry if I ask noob questions: does today's perl6 (2016.01) already do autoparallelism/autothreading behind the scenes, like on vector operators, or junctions?

[14:44] *** dakkar_ left
[14:46] <stmuk_> I need moar cores

[14:47] <flussence> map/reduce-like operations are threaded if you ask them to be

[14:47] <perlpilot> renormalist: the short answer is "no"

[14:47] *** virtualsue joined
[14:48] <renormalist> perlpilot: I come from the FAQ which show "abuse" of "autothreading" to print values of a junction, that's why I ask.

[14:48] <renormalist> http://doc.perl6.org/language/faq#How_can_I_extract_the_values_from_a_Junction%3F

[14:48] *** virtualsue left
[14:49] <renormalist> perlpilot: you probably have a longer answer ending with "yes" - point me to it, please. :-)

[14:49] *** virtualsue joined
[14:50] <perlpilot> renormalist: actually, the longer answer probably still ends with "no" depending on what you mean by "threading" and "auto"  :)

[14:50] <perlpilot> renormalist: mostly we have syntactic hints that things are to be parallelized, so there is no "auto" without you telling the compiler

[14:51] <perlpilot> renormalist: and for junctions we have "conceptual threading", but I don't think we actually use separate threads yet.

[14:53] <renormalist> perlpilot: ok, what I mean with "auto~" is that magic "all my cpus are utilized well by the perl6 compiler without me taking care of it in the program".

[14:55] <renormalist> perlpilot: I'm currently just reading and playing around, so a "no" is fine, I'm just curious.

[14:56] *** mr-foobar left
[14:57] *** ely-se left
[14:58] <ugexe> I thought the duplicate compile errors were fairly well known. in any case lots of people have reported this # nine

[14:58] *** cpage_ joined
[14:59] <perlpilot> renormalist: maybe start by looking at http://jnthn.net/papers/2015-spw-concurrency.pdf and other stuff at http://www.jnthn.net/articles.shtml

[15:00] *** mr-foobar joined
[15:00] <renormalist> perlpilot: great, thanks, started reading it...

[15:01] *** TreyHarris joined
[15:02] *** rindolf joined
[15:02] *** autarch left
[15:02] *** cpage_ left
[15:02] *** autarch joined
[15:04] *** autarch left
[15:05] *** autarch joined
[15:06] *** TreyHarris left
[15:07] *** wamba1 joined
[15:07] *** wamba left
[15:08] <skids> https://gist.github.com/skids/aca87c6b6fb065a3c244 close to performant solution to https://www.reddit.com/r/dailyprogrammer/comments/46zm8m/20160222_challenge_255_easy_playing_with_light/

[15:08] *** prammer joined
[15:08] <lizmat> nine: on the compile error issue: it would appear there's two processes doing the compile

[15:08] <lizmat> create a lib/foo.pm with "foo" in it

[15:09] <lizmat> add $*PID to X::Undeclared::Symbols message

[15:09] <lizmat> do perl6 --ll-exception -lib -e 'use foo'

[15:10] <lizmat> the first one seen has the higher process number, but looks like it just compiling (happens in the grammar)

[15:11] <lizmat> nine: could it be that it's precompiling, which fails, then tries to run it as source, and fails again ?

[15:11] <ugexe> i thought what was happening is it tries to use the precompiled version (that was installed), which fails, and then tries to load the source and precompile that

[15:12] <lizmat> adding a "no precompilation" to the foo module, makes it only show the error once

[15:13] *** Guest5741 left
[15:14] *** luiz_lha joined
[15:15] *** luiz_lha is now known as Guest72897

[15:16] <ugexe> https://github.com/rakudo/rakudo/blob/nom/src/core/CompUnit/Repository/Installation.pm#L336-L338

[15:17] <nine> lizmat: oh yes, that sounds like a valid explanation

[15:17] <ugexe> https://rt.perl.org/Ticket/Display.html?id=127176

[15:18] <RabidGravy> so I'd totally forgotten about complex types with simple content, need to look at more schema

[15:19] <nine> I think this https://github.com/rakudo/rakudo/blob/nom/src/core/CompUnit/PrecompilationRepository.pm#L30 swallows the fail from https://github.com/rakudo/rakudo/blob/nom/src/core/CompUnit/PrecompilationRepository.pm#L156

[15:22] <nine> lizmat: Easiest fix should be replacing the fail in https://github.com/rakudo/rakudo/blob/nom/src/core/CompUnit/PrecompilationRepository.pm#L156 by a die

[15:25] *** donaldh left
[15:25] <ugexe> `module XXX { our $FOO is export = BAR(); sub BAR { die; }; }; import XXX;` # -e dies as expected. putting module XXX into its own file and using it dies from NQP

[15:26] *** donaldh joined
[15:27] *** vendethiel joined
[15:34] *** jameslenz left
[15:35] *** jameslenz joined
[15:35] <lizmat> nine: will try

[15:38] *** sufrostico joined
[15:38] *** virtualsue left
[15:40] *** gensym joined
[15:41] *** TreyHarris joined
[15:41] *** fireartist left
[15:45] <lizmat> nine: it looks like @result is always empty on an unsuccessful precompile

[15:48] <nine> lizmat: maybe because such error messages actually go to .err, not .out?

[15:49] <lizmat> yep, think so: so they're already visible, so we don't need to do anything, except exit

[15:49] *** vendethiel left
[15:50] *** ka left
[15:51] <hoelzro> o/ #perl6

[15:51] <yoleaux> 02:02Z <sortiz> hoelzro: I Have a working implementation of the idea that I mentioned to you in https://github.com/rakudo/rakudo/pull/718

[15:51] <hoelzro> .tell sortiz thanks, I'll take a look when I have some time!

[15:51] <yoleaux> hoelzro: I'll pass your message to sortiz.

[15:51] <hoelzro> (hopefully Wednesday night)

[15:52] <nine> lizmat: than it's actually ok the way it is. We just need to make it more fatal.

[15:52] <lizmat> yeah, testing a patch now

[15:55] <lizmat> nine: can we have multiple threads doing precompiling of different (independent) files at the same time ?

[15:57] *** colomon left
[15:58] <nine> lizmat: they would probably fight about the PrecompilationStore lock file

[15:59] <lizmat> ah, well, serialized by it, for sure ?

[15:59] <nine> yes

[16:00] <nine> I hope

[16:01] <lizmat> thing is, visually, the best result is to just "exit $proc.status"

[16:01] <nine> On second thought: I think it would more like end in catastrophe. This code is not thread safe.

[16:01] <nine> But that would make module loading errors non-catchable?

[16:01] <lizmat> ok, so we'll make that a point of interest  :-)   being able to do what *is* possible in parallel, would be nice

[16:02] *** autarch left
[16:02] <lizmat> nine: the error is already on screen by that time

[16:02] *** spintronic joined
[16:02] <nine> Unless STDOUT got redirected.

[16:03] <nine> s/STDOUT/STDERR

[16:04] <rudi_s> :m sub foo(*@x) { say @x.perl }; foo((1,2), (3,4));

[16:04] <rudi_s> m: sub foo(*@x) { say @x.perl }; foo((1,2), (3,4));

[16:04] <camelia> rakudo-moar 96a195: OUTPUT«[1, 2, 3, 4]␤»

[16:05] <rudi_s> I'm confused about the result. Why are the lists flattened?

[16:05] <psch> m: sub foo(**@x) { say @x.perl }; foo((1,2), (3,4));

[16:05] <camelia> rakudo-moar 96a195: OUTPUT«[(1, 2), (3, 4)]␤»

[16:05] *** sena_kun joined
[16:05] <rudi_s> What's the difference between **@x and *@x?

[16:05] <rudi_s> (Doc link is fine.)

[16:05] *** Actualeyes left
[16:05] *** pmqs left
[16:05] <moritz> *@x flattens

[16:05] <moritz> **@x preserves structure

[16:05] <psch> http://doc.perl6.org/type/Signature#Slurpy_(A.K.A._Variadic)_Parameters

[16:05] <psch> oh

[16:06] <psch> there's no docs for **@ or +@ it seems

[16:06] <psch> ah, there is for **@ at least

[16:06] <psch> well, +@ might be under a different heading...

[16:06] *** mr-foobar left
[16:08] *** Actualeyes joined
[16:09] <rudi_s> Thank you.

[16:12] *** sena_kun left
[16:12] <dalek> rakudo-star-daily: 8e1fddf | coke++ | log/ (9 files):

[16:12] <dalek> rakudo-star-daily: today (automated commit)

[16:12] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/8e1fddfa99

[16:12] <dalek> rakudo-star-daily: 71ba402 | coke++ | log/ (9 files):

[16:12] <dalek> rakudo-star-daily: today (automated commit)

[16:12] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/71ba40248c

[16:18] *** _mg_ left
[16:19] *** spintronic left
[16:19] *** spintronic joined
[16:20] *** espadrine_ joined
[16:20] *** espadrine_ is now known as espadrine

[16:20] *** lostinfog joined
[16:21] *** spintronic left
[16:21] <lizmat> dinner&

[16:21] *** spintronic joined
[16:22] *** edenc left
[16:22] *** edenc joined
[16:22] <renormalist> perlpilot: re 2015-spw-concurrency slides from jnthn - is that available perl6 functionality of today?

[16:23] <renormalist> jnthn: ^ you are allowed to answer, too :-)

[16:26] <RabidGravy> you got a link to those slides?

[16:26] *** rurban joined
[16:27] *** zpmorgan joined
[16:29] <RabidGravy> renormalist, yes

[16:30] <renormalist> cool

[16:30] <stmuk_> Liz's YAPC::EU 2016 covers much of the same ground and had a change or two I believe

[16:30] <stmuk_> and I think supplies (?) changed after that

[16:31] <RabidGravy> the supplies piece seems about as it is at the moment

[16:31] <RabidGravy> didn't read in detail so there may be one or two small changes

[16:31] * renormalist is quite excited from the last 2 days reading into perl6 stuff

[16:32] <[Coke]> <burns>excellent</burns>

[16:32] <stmuk_> I meant https://6guts.wordpress.com/2015/12/05/getting-closer-to-christmas/

[16:37] *** rurban1 joined
[16:38] *** virtualsue joined
[16:39] *** rurban left
[16:49] *** spintronic left
[16:49] *** spintronic joined
[16:54] *** ka joined
[16:56] *** abraxxa left
[16:57] *** zakharyas left
[16:58] *** ka left
[16:59] *** colomon joined
[17:00] *** ka joined
[17:02] *** cpage_ joined
[17:03] *** kst`` is now known as kst

[17:03] *** sufrostico left
[17:05] *** neilb left
[17:08] *** _mg_ joined
[17:09] <pmurias> jnthn: would it make sense to add a '#line' equivalent to nqp so that we get better errors for combined files? 

[17:09] *** spintronic left
[17:09] *** FROGGS left
[17:09] *** spintronic joined
[17:10] *** rurban1 left
[17:15] *** neilb joined
[17:19] *** domidumont left
[17:21] *** spintronic_ joined
[17:24] *** donaldh left
[17:25] *** spintronic left
[17:26] *** raiph left
[17:29] *** nakiro left
[17:29] *** spintronic_ left
[17:29] *** vendethiel joined
[17:35] <psch> m: use Test; Test.WHO.perl.say

[17:35] <camelia> rakudo-moar 96a195: OUTPUT«{"\&failure_output" => sub failure_output () { #`(Sub|73884856) ... }, "\&output" => sub output () { #`(Sub|73885312) ... }, "\&todo_output" => sub todo_output () { #`(Sub|73885464) ... }, :EXPORT(EXPORT)}␤»

[17:36] <psch> is that how the WHO has to look before symbols are imported..?

[17:36] *** cpage_ left
[17:36] <psch> 'cause i am definitely missing something here...

[17:36] <psch> loading of java classes seems to work, but the imports don't happen

[17:37] *** virtualsue left
[17:38] <llfourn> m: use Test; say Test::EXPORT::DEFAULT.WHO.perl.say # symbols are "imported" from here (sort of)

[17:38] <camelia> rakudo-moar 96a195: OUTPUT«{"\&MONKEY-SEE-NO-EVAL" => sub MONKEY-SEE-NO-EVAL () { #`(Sub|94177080) ... }, "\&can-ok" => sub can-ok (;; Mu | is raw) { #`(Sub|94176472) ... }, "\&cmp-ok" => sub cmp-ok (;; Mu | is raw) { #`(Sub|94173280) ... }, "\&diag" => sub diag (Mu $message) { #`(S…»

[17:39] <psch> m: say Test::EXPORT.WHAT

[17:39] <camelia> rakudo-moar 96a195: OUTPUT«Could not find symbol '&EXPORT'␤  in block <unit> at /tmp/EpwjQn7W3E line 1␤␤Actually thrown at:␤  in block <unit> at /tmp/EpwjQn7W3E line 1␤␤»

[17:39] <psch> m: say Test::EXPORT::.WHAT

[17:39] <camelia> rakudo-moar 96a195: OUTPUT«Could not find symbol '&EXPORT'␤  in block <unit> at /tmp/fNMR2xy3oW line 1␤␤Actually thrown at:␤  in block <unit> at /tmp/fNMR2xy3oW line 1␤␤»

[17:40] <psch> hm, so the package itself isn't anything useful for WHAT but the WHO has the Stash..?

[17:40] <llfourn> psch: use Test; say Test::EXPORT.WHAT

[17:40] <psch> oh duh

[17:40] <psch> m: use Test; say Test::EXPORT.WHAT

[17:40] <camelia> rakudo-moar 96a195: OUTPUT«(EXPORT)␤»

[17:40] <psch> m: use Test; say Test::EXPORT.HOW.^name

[17:40] <camelia> rakudo-moar 96a195: OUTPUT«Perl6::Metamodel::PackageHOW␤»

[17:41] <psch> well, yeah, i think that's the lines i've been trying to look along

[17:41] <psch> unfortunately i fail to see how i can build that kind in a work-y manner

[17:42] <psch> as in, https://github.com/rakudo/rakudo/blob/nom/src/vm/jvm/Perl6/JavaModuleLoader.nqp#L22 this way gives me either "expected Stash but got Hash" or something related to nqp::ctxlexpad

[17:42] <llfourn> m: say $*REPO.need(CompUnit::DependencySpecification.new(:short-name<Test>)).handle.export-package.WHO.keys

[17:42] <camelia> rakudo-moar 96a195: OUTPUT«()␤»

[17:43] *** dakkar__ left
[17:43] <llfourn> m: say $*REPO.need(CompUnit::DependencySpecification.new(:short-name<Test>)).handle.export-package.keys

[17:43] <camelia> rakudo-moar 96a195: OUTPUT«(DEFAULT ALL)␤»

[17:43] <llfourn> this is how things are actually loaded

[17:43] <llfourn> I'm not at all familar with JVM side of things

[17:44] <llfourn> but each package's .WHO should be a stash

[17:44] <llfourn> m: Stash.new

[17:44] <camelia> rakudo-moar 96a195: ( no output )

[17:44] <psch> right

[17:45] <psch> the bit i'm stuck with is turning the Hash i get from RakudoJavaInterop.computeInterop into a package with a correct WHO

[17:46] <psch> the Hash there contains stuff like $method_name => CodeRef and '/TYPE/' => HOW

[17:46] <llfourn> I see. I'm not sure what kind of envionment your in, but there is an nqp::setwho operation I think

[17:46] <llfourn> which will take keyvalues

[17:47] <llfourn> and may play nicely

[17:47] <psch> hm, that'd play out to pulling the linked bit to Perl 6 level so i can make it a Stash instead of a Hash..?

[17:47] <llfourn> otherwise the best thing to do is to create a PackageHOW.create_type

[17:47] <psch> 'cause i think nqp::hash there gives a P6-level Hash

[17:48] <psch> ...or it hllizes somewhere sneakily

[17:49] <psch> hm, i'll play around with those two approach, thanks llfourn++

[17:49] <llfourn> nw :)

[17:51] <psch> ehh, i had a jumble there.  the computeInterop Hash doesn't actually play into this, it's only the type object from typeForName that comes from load_module...

[17:51] <psch> these bits used to be less complicated and Just Work once /o\

[17:52] <psch> ...not that i'm actually against anything that the CUR* work brought :)

[17:53] *** virtualsue joined
[17:58] *** spintronic_ joined
[18:01] *** raiph joined
[18:02] *** virtualsue left
[18:03] *** colomon left
[18:03] *** zpmorgan left
[18:04] *** spintronic_ left
[18:05] *** firstdayonthejob joined
[18:06] <arnsholt> psch: IIRC nqp::hash (and nqp::list for that matter) creates an object according to a type object set during HLL config

[18:07] <arnsholt> So in Perl 6, it'll give you a Perl 6 hash, yeah, I think

[18:22] *** patrickz joined
[18:23] <nine> psch: what do you tink about turning JavaModuleLoader into a proper CompUnit::Repository?

[18:24] <psch> nine: https://github.com/rakudo/rakudo/blob/jvminterop/src/vm/jvm/CompUnit/Repository/Java.pm is what i'm doing, starting from what NQP does

[18:25] <psch> nine: seeing as the NQP Repository also has the ModuleLoader separate...

[18:27] <psch> also that could just be because NQP needs to have the ModuleLoader separate because NQP itself has it already

[18:27] <psch> or rather, the CU::R::NQP is just piggybacking on what NQP already brings vOv

[18:27] *** sortiz joined
[18:28] <psch> anyway, i could probably drag the JavaModuleLoader code into CU::R::Java, but i'll stick with "make it work" for now ;)

[18:30] <sortiz> \o #perl6

[18:30] <yoleaux> 15:51Z <hoelzro> sortiz: thanks, I'll take a look when I have some time!

[18:31] * [Coke] keeps reading sortiz as soritz like moritz.

[18:32] *** ka left
[18:32] <nine> psch: NQP's module loader code is mostly in NQP because it started out that way and there was not enough incentive to fight the porting problems.

[18:32] *** sufrostico joined
[18:33] <psch> s/also/although/ # belatedly

[18:33] *** raiph left
[18:34] <nine> psch: doing it in Perl 6 may save you some of these NQP vs. HLL problems though :) Maybe https://github.com/rakudo/rakudo/blob/jvminterop/src/core/CompUnit/Repository/Perl5.pm could be an inspiration

[18:35] <psch> i had looked at that a bit too, to figure out this Stash stuff...

[18:35] *** spider-mario joined
[18:35] <psch> but yeah, if nothing else we could lose the JavaModuleLoader 

[18:36] <nine> This is the other half: https://github.com/niner/Inline-Perl5/blob/master/lib/Inline/Perl5.pm6#L832

[18:38] *** CIAvash left
[18:39] <psch> huh, so i also need an &EXPORT..?

[18:40] <nine> I can only tell you that it seems to work. I tinkered around till it did what it should

[18:41] <psch> ah, a development method after my own heart :)

[18:41] *** raiph joined
[18:41] *** musiKk joined
[18:43] <psch> well, as mentioned i'm mostly looking for ideas which direction i should tinker towards

[18:43] <psch> and moving all this to P6-level seems like a good one, 'cause building the Stash/Package structure there is quite a bit easier than in NQP

[18:44] *** AlexDaniel joined
[18:45] *** virtualsue joined
[18:46] <dalek> rakudo/nom: ab4d432 | coke++ | docs/release_guide.pod:

[18:46] <dalek> rakudo/nom: remove unneeded tag instructions

[18:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ab4d4325c7

[18:46] <dalek> rakudo/nom: c86ac20 | coke++ | docs/release_guide.pod:

[18:46] <dalek> rakudo/nom: add -u option, fails for me without

[18:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c86ac20eef

[18:47] *** roguelazer left
[18:47] *** roguelazer joined
[18:49] <TreyHarris> a couple grammar questions... first, years ago, i think it was common to specify "proto token foo {*}; token foo:sym<one> { ... }; token foo:sym<two> { ... }; etc..." in preference to specifying alternations in a single token. But the current docs don't give this as an example and I don't see any examples of that in the core, so do I presume that's fallen out of favor? (it still works)

[18:51] *** Actualeyes left
[18:52] *** AlexDani` joined
[18:54] *** AlexDaniel left
[18:54] *** AlexDani` is now known as AlexDaniel

[18:55] *** musiKk left
[18:55] *** cdg left
[19:00] <MadcapJake> anyone know how i can get a perl.org email? I need one and a login in order to send emails via my issue submitter

[19:03] *** yqt joined
[19:04] <perlpilot> TreyHarris: no, that hasn't fallen out of favor.  That's still one of the best ways to extend a grammar when the tokenization is already right but you want to add more alternatives.

[19:04] <TreyHarris> perlpilot: thanks

[19:05] <TreyHarris> second question: so what's a good concise rule or rules to represent hashy perllike comments and no-op whitespace?

[19:06] <perlpilot> TreyHarris: um ... whatever is in src/Perl6/Grammar.nqp  :)

[19:07] <TreyHarris> my TOP is currently:  "token TOP { [<cmd> \n+]* }", which surprisingly to me does not allow for blank lines between valid <cmd>s

[19:07] <TreyHarris> I'd think the "\n+" would allow that

[19:09] <arnsholt> Why should that match blank lines? \n+ matches a sequence of newlines =)

[19:10] <perlpilot> maybe you want rule instead of token?

[19:10] <perlpilot> maybe you want to match <ws> ?

[19:10] <perlpilot> maybe you want an anchor or two?

[19:10] <arnsholt> Yeah, you probably want something based on <ws> as well to gobble up the blanklines

[19:10] <TreyHarris> arnsholt: if 'a' and 'b' are my only two allowed matches of <cmd>, why does "a\nb\n" match but "a\n\nb\n" not?

[19:11] *** molaf left
[19:11] <perlpilot> TreyHarris: can cmd match zero characters?

[19:11] <arnsholt> That's weirder, yeah

[19:12] <psch> m: grammar G { token TOP { [ [a|b] \n+ ]* } }; G.parse("a\nb\n").say # ?

[19:12] <camelia> rakudo-moar c86ac2: OUTPUT«｢a␤b␤｣␤»

[19:12] <TreyHarris> um, here, i'll gist it, one moment. (is gist the preferred paste here?)

[19:12] <psch> m: grammar G { token TOP { [ [a|b] \n+ ]* } }; G.parse("a\n\nb\n").say # ?

[19:12] <camelia> rakudo-moar c86ac2: OUTPUT«｢a␤␤b␤｣␤»

[19:12] <perlpilot> TreyHarris: gist is fine

[19:17] <TreyHarris> oops, that was in error, turns out my examples with blank lines lacked an ending newline before EOF.

[19:17] <TreyHarris> but: https://gist.github.com/treyharris/9f39736e766bbc0c1a8b

[19:17] <TreyHarris> what would I change to allow newlines before my first a or b?

[19:17] <psch> m: https://gist.github.com/treyharris/9f39736e766bbc0c1a8b

[19:17] <camelia> rakudo-moar c86ac2: OUTPUT«noparse␤»

[19:17] <psch> m: say slurp

[19:17] <camelia> rakudo-moar c86ac2: OUTPUT«Céad slán ag sléibhte maorga Chontae Dhún na nGall␤Agus dhá chéad slán ag an Eireagal ard ina stua os cionn caor is coll;␤Nuair a ghluais mise thart le Loch Dhún Lúich’ go ciúin sa ghleann ina luí␤I mo dhiaidh bhí gleanntáin ghlas’ G…»

[19:18] <psch> right, of course 

[19:19] <perlpilot> TreyHarris: btw, do you know about % in regex?

[19:21] <pmurias> Ian Hague grants are voted on two weeks after the end of the community feedback period?

[19:21] <TreyHarris> perlpilot: yes, but where I was going was to make blank lines a type of comment, so [<my-rule>+ % \n+] seemed wrong

[19:21] *** TEttinger joined
[19:22] *** FROGGS joined
[19:23] <TreyHarris> perlpilot: though I now see that "token TOP { [<my-rule>+ % \n]* }" doesn't work so I guess I don't understand % after all

[19:23] *** prammer left
[19:23] <psch> m: grammar G { token TOP { [ [a|b]+ % \n* ]* } }; G.parse("a\n\nb").say  

[19:23] <camelia> rakudo-moar c86ac2: OUTPUT«｢a␤␤b｣␤»

[19:23] <psch> % doesn't do trailing separators

[19:24] <psch> m: grammar G { token TOP { [ [a|b]+ %% \n ]* } }; G.parse("a\nb\n").say 

[19:24] <camelia> rakudo-moar c86ac2: OUTPUT«｢a␤b␤｣␤»

[19:24] <psch> %% does though

[19:25] <perlpilot> psch++ for the examples while I was distracted :)

[19:26] *** espadrine left
[19:26] <TreyHarris> psch++ thanks

[19:27] <TreyHarris> I see the answer from Grammar.nqp is to define comments as a type of ws

[19:32] <TreyHarris> which may be fine for my purposes, not sure, I'll have to get farther into the real project. The thing I'm doing is to parse a variant of Markdown that will still render correctly in a normal Markdown processor, so I was planning on sticking my extensions in (Markdown) comments. So I was trying to start with a un-flavored Markdown grammar and then extend it, but if comments are waved away as ws from the start,

[19:32] <TreyHarris> it seems it would be difficult to say in a derived grammar "... but this one kind of ws I now want to make not ws" without doing copy-pasting from the parent ws rule. hrm. This is why I'm practicing with a toy grammar, I assume this will become clearer as I practice. :)

[19:32] *** ka joined
[19:34] *** colomon joined
[19:34] *** prammer joined
[19:36] <TreyHarris> i expected to find a perl6 markdown-to-html someone wrote at some point, but i don't see one. there are several exmples of perl6 converting othing things _to_ markdown (including POD, of course)

[19:36] *** sufrostico left
[19:36] *** prammer left
[19:36] <psch> modules.perl6.org points at https://github.com/retupmoca/p6-markdown

[19:37] *** ka left
[19:38] *** sufrostico joined
[19:40] *** [particle] left
[19:40] <AlexDaniel> I've actually used it. It worked OK

[19:40] <psch> m: grammar G { token TOP { a* %% <ws> } }; class A { method TOP($/) { make $<ws>>>.ast }; method ws($/) { make ~$/ eq '  ' ?? "double space!" !! '' } }; G.parse("a\na  a\n a \n", :actions(A.new)).made.say # somewhat hacky way to react to specific kinds of <ws>

[19:40] <camelia> rakudo-moar c86ac2: OUTPUT«[ double space!  ]␤»

[19:41] <TreyHarris> psch: ahh, clever

[19:41] <psch> where "somewhat" means "please wait if anyone has a better idea"... :)

[19:42] <moritz> fwiw you should overwrite ws to only match non-significant whitespace in your problem domain

[19:42] <moritz> so if two line breaks make a paragraph, make sure that <ws> doesn't match that

[19:43] *** [particle] joined
[19:44] <TreyHarris> moritz: right, but if i'm inheriting from a grammar where <ws> matches any amount of line breaks, and I, say, want to intercept four newlines in a row and make them not <ws>, how can I do that without copy-pasting from the parent ws?

[19:44] <psch> usual inheritance practice applies, i'd say

[19:44] *** itaipu joined
[19:44] <psch> as in, either provide a ws rule that does exactly what you want or handle special cases before redispatching to the parent

[19:44] <moritz> right

[19:48] <TreyHarris> hm... what does an initial || in a token do? 

[19:49] *** yqt left
[19:49] <moritz> nothing

[19:50] <moritz> it's just that you're allowed to put the || not just between tokens, but also up front

[19:50] <moritz> for nicer vertical formatting

[19:50] <AlexDaniel> it is  there so that you can line up || nicely

[19:51] <TreyHarris> Ohhh. Okay, so that explains https://github.com/perl6/nqp/blob/master/src/NQP/Grammar.nqp#L54

[19:52] <TreyHarris> how do you "redispatch"? that word doesn't appear anywhere I see except for http://doc.perl6.org/type/X::NoDispatcher#method_redispatcher

[19:52] <moritz> callsame

[19:53] <moritz> or explicit calling with <TheClass::method> or something

[19:54] *** virtualsue left
[19:54] <sortiz> .ask lizmat Seems to me that Buf.push and Buf.append are identical (the same for .unshift/.prepend). It's intended?

[19:54] <yoleaux> sortiz: I'll pass your message to lizmat.

[19:55] <moritz> probably, because Buf doesn't have the flat/non-flat distinctions that Array has

[19:56] <TreyHarris> argh, my google search didn't find http://doc.perl6.org/language/functions#Re-dispatching for some reason....

[19:56] *** prammer joined
[19:56] <TreyHarris> sorry and thanks.

[19:58] *** prammer left
[20:03] <sortiz> moritz, Can be, but then Buf.append should attempt to always flat its arguments, I though.

[20:04] <moritz> the *@values candidate does, no?

[20:04] <moritz> m: my $b = Buf.new; $b.apend((1, 2), (3, 4); say $b

[20:04] <camelia> rakudo-moar c86ac2: OUTPUT«5===SORRY!5=== Error while compiling /tmp/LkbmMf1w_D␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/LkbmMf1w_D:1␤------> 3Buf.new; $b.apend((1, 2), (3, 4); say $b7⏏5<EOL>␤    expecting any of:␤        post…»

[20:04] <moritz> m: my $b = Buf.new; $b.apend((1, 2), (3, 4)); say $b

[20:04] <camelia> rakudo-moar c86ac2: OUTPUT«Method 'apend' not found for invocant of class 'Buf'␤  in block <unit> at /tmp/vet1JmRKun line 1␤␤»

[20:04] <moritz> m: my $b = Buf.new; $b.append((1, 2), (3, 4)); say $b

[20:04] <camelia> rakudo-moar c86ac2: OUTPUT«Buf:0x<01 02 03 04>␤»

[20:04] <moritz> sortiz: seems like it's flattening fine

[20:05] <sortiz> moritz, indeed.

[20:05] *** sufrostico left
[20:05] <moritz> is anybody interested in helping me with a bit of web design for a (non-Perl 6) project?

[20:07] *** sufrostico joined
[20:08] *** darutoko left
[20:09] *** SCHAAP137 joined
[20:11] <sortiz> moritz, In that cases, It would be worthwhile to use simply aliases? (To avoid the code bloating)

[20:11] <moritz> sortiz: if that's fast enough, yes

[20:13] <[Coke]> moritz: sure.

[20:14] *** domidumont joined
[20:14] <[Coke]> I need a break from docker & git.

[20:15] <lizmat> .

[20:15] <yoleaux> 19:54Z <sortiz> lizmat: Seems to me that Buf.push and Buf.append are identical (the same for .unshift/.prepend). It's intended?

[20:16] <sortiz> moritz, lizmat is an expert in benchmarks, I'll wait for her opinion. Thanks. Btw, Buf.shift is missing.

[20:16] <lizmat> sortiz: yes, as you can only push/append ints anyway

[20:16] <sortiz> \o lizmat

[20:16] <lizmat> you could argue that multi-element push on Buf should be disallowed

[20:16] *** musiKk joined
[20:17] <lizmat> sortiz: wrt to shift missing: good point  :-)

[20:20] <sortiz> lizmat, And found another problem: Buf!pend uses a CATCH to report unboxing problems, but the generic Blob.new(@values) don't.

[20:20] <lizmat> yeah, it's on my list of things to go through as well

[20:20] <lizmat> similar issues with native arrays

[20:21] <lizmat> sortiz: I'll take PR's also  :-)

[20:22] <jnthn> Um, don't put CATCHes on paths like that. :(

[20:22] <jnthn> You'll never get it inlined

[20:23] *** colomon left
[20:23] <dalek> nqp: ba2aa73 | (Pawel Murias)++ | src/vm/js/Compiler.nqp:

[20:23] <dalek> nqp: [js] Remove useless code.

[20:23] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ba2aa733e4

[20:23] <dalek> nqp: c7b640d | (Pawel Murias)++ | t/nqp/75-curcode.t:

[20:23] <dalek> nqp: Test nqp::curcode with methods.

[20:23] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c7b640ddea

[20:23] <dalek> nqp: 51983bf | (Pawel Murias)++ | t/nqp/76-capture.t:

[20:23] <dalek> nqp: Test nqp::usecapture with methods.

[20:23] <dalek> nqp: review: https://github.com/perl6/nqp/commit/51983bf842

[20:23] <dalek> nqp: fcecdf1 | (Pawel Murias)++ | src/vm/js/ (5 files):

[20:23] <dalek> nqp: [js] Compile suspected methods in a different manner that passes the invocant using this instead of as the 3 js arguments.

[20:23] <dalek> nqp: 

[20:23] <dalek> nqp: For now it just slows things down a bit, will be used to optimize method calls.

[20:23] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fcecdf18d6

[20:24] <jnthn> The right fix is to provide a hll_config place to let us have the VM throw the appropriate typed exception there

[20:24] <jnthn> Well, or call code to throw...

[20:25] <jnthn> If we already have tests for the type exception, though, guess we leave the CATCH there and fix it later.

[20:26] <jnthn> But it's something to look out for...CATCH + hot path = bad news.

[20:26] <sortiz> jnthn, For the Blob.new case I was thinking in something in the lines of: nqp::push_i($buf, $pulled.DEFINITE ?? +$pulled !! 0) with maybe a warning.

[20:27] <jnthn> I think a straight +$pulled will spit out a warning anyway

[20:27] <jnthn> say +Int

[20:27] <jnthn> m: say +Int

[20:27] <camelia> rakudo-moar c86ac2: OUTPUT«Use of uninitialized value of type Int in numeric context  in block <unit> at /tmp/qXJsL7LRLt line 1␤0␤»

[20:27] *** prammer joined
[20:29] <sortiz> jnthn, like the idea of fallback to 0 in other cases?

[20:31] <dalek> rakudo/nom: c6df201 | lizmat++ | src/core/Buf.pm:

[20:31] <dalek> rakudo/nom: Add Buf.shift, sortiz++ for spotting its absence

[20:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c6df201d7e

[20:32] *** prammer left
[20:32] <lizmat> jnthn: in the !pend case, would you suggest nqp::istype(...,Int) for each value before push/unshifting ?

[20:33] * lizmat benchmarks

[20:34] <jnthn> lizmat: A branch guarded by nqp::istype will be elminated nicely by specialization

[20:34] <lizmat> ok

[20:35] <jnthn> But we can't really easily eliminate CATCH and the associated handler bits; it means proving the impossibility of an exception being thrown

[20:37] <jnthn> Moar actually can inline code with handlers in it too, but the machinery around a CATCH tends to produce enough code that it pushes an otherwise small enough thing over the inline limit.

[20:37] *** yqt joined
[20:37] <jnthn> (The main reason it can is to cope with return handlers in small subs)

[20:37] *** sufrostico left
[20:38] <sortiz> lizmat, btw, for the .push/.append/.prepend/.unshift (Buf:D: int @values) I suspect that nqp::splice can be faster 

[20:39] <lizmat> sortiz: again a good point  :-)

[20:39] <jnthn> Very likely, yes

[20:39] *** sufrostico joined
[20:39] <jnthn> We're not quite smart enough to make that a memcpy yet

[20:39] <jnthn> But can in the future

[20:40] * sortiz I'm doing my homework :)

[20:42] *** _dolmen_ joined
[20:43] <sortiz> jnthn, And for the case of identical methods and avoid code bloat, can be possible to use method aliasing?

[20:44] <sortiz> m: class Foo { method foo { say "Im foo" } }; Foo.HOW.add_method(Foo,'bar', Foo.^method_table<foo>); Foo.new.bar; # Seems to work

[20:44] <camelia> rakudo-moar c86ac2: OUTPUT«Im foo␤»

[20:44] <lizmat> sortiz: in general, you can: but this very early in the setting, and my experiences with tricks like that aren't good  :-(

[20:44] <lizmat> so I try to avoid these tricks in the settings

[20:45] *** prammer joined
[20:46] <lizmat> jnthn: looks like !pend is already above the inline level, as the difference is in noise  :-(

[20:46] * lizmat tries to make methods smaller 

[20:47] *** yqt left
[20:47] <sortiz> lizmat, I'm aware of that, but in this case there are lots of duplicate code.

[20:47] <jnthn> soritz: You'd have to do it in a BEGIN block

[20:48] *** prammer left
[20:50] <sortiz> jnthn, Sure, worth it?

[20:51] <jnthn> sortiz: Well, the trouble is that introspection will show up the method under its original name

[20:51] <jnthn> So .^methods will give bogus output

[20:53] <lizmat> separating !pend into an !push and a !unshift, only make things (marginally) worse

[20:53] *** adhoc joined
[20:54] *** adhoc left
[20:54] *** adhoc joined
[20:54] <sortiz> jnthn, yes, that use the name in the Method and not the one of the method_table.

[20:55] *** adhoc left
[20:55] <jnthn> sortiz: Correct. :)

[20:55] <jnthn> So your'd actually need to .clone and .set_name

[20:55] <jnthn> *you'd

[20:56] <lizmat> I'm not seeing any benefit in this line of thought, so I;m abandoning it for the moment

[20:56] <lizmat> https://gist.github.com/lizmat/0fa96cd2c6782b1bb2b0   # in case anybody is interested in playing around with this some more

[20:57] *** TimToady left
[20:57] *** prammer joined
[20:58] * sortiz Thinking in "method bar is alias(foo);" 

[20:59] *** TimToady joined
[21:04] <pmurias> jnthn: how can I detect if something is compiled as a method in nqp?

[21:05] *** yqt joined
[21:05] *** telex left
[21:05] <pmurias> jnthn: guess more then detect as I don't have to be 100% correct

[21:06] <jnthn> pmurias: I don't really understand the question, sorry

[21:07] <jnthn> pmurias: In Rakudo you'd check ~~ Method I guess but we don't distinguish code object types in NQP

[21:07] <jnthn> What's the use case?

[21:07] <pmurias> I want to compile methods slightly differently for optimalization purposes

[21:08] <sortiz> lunch &

[21:08] <pmurias> if the take the invocant using the javascript this rather then as a positional parameter I can just put them into a prototype and call them directly

[21:08] <pmurias> s/the/they/

[21:08] <jnthn> Remember that you can .^find_method and then call it as a sub

[21:09] <pmurias> that's supported too

[21:10] *** colomon joined
[21:10] <pmurias> it's just that one way of calling them will be faster

[21:10] <jnthn> ok

[21:10] *** domidumont left
[21:11] <jnthn> I'm often wary of opts that go against things that Perl 6 has as "fundemental" in a sense, I guess. :)

[21:11] <jnthn> An easy heuristic may be to see if it has a "self" lexical

[21:11] <jnthn> But we lower away most of those

[21:11] <pmurias> I'm using this heuristic currently, but the lowering gets into the way

[21:12] *** telex joined
[21:13] <pmurias> jnthn: is it ok if I add an annotation that marks if the QAST::Block was declared as a sub or method?

[21:13] <jnthn> No

[21:13] <jnthn> I don't really like annotations have semantic meaning to code-gen.

[21:15] <jnthn> Heh, an absolute cheat is to look at the .node on the block, and see if you see the word "method" at that string offset :P

[21:15] *** autarch joined
[21:19] <dalek> rakudo/nom: bd60603 | lizmat++ | src/core/Buf.pm:

[21:19] <dalek> rakudo/nom: Optimize Buf.push|append|unshift|prepend(int @a)

[21:19] <dalek> rakudo/nom: 

[21:19] <dalek> rakudo/nom: Suggested by sortiz++

[21:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bd60603b84

[21:21] <lizmat> jnthn: hmmm.   I just noticed that the methods in Buf use a mix of .throw and fail  :-(

[21:21] *** itaipu left
[21:22] <lizmat> jnthn: I guess fail would be more consistent, eh?

[21:22] <nine> Meh...I'm gonna have to change how precomp ids are determined. This is becoming more involved than I would have liked.

[21:25] *** sno left
[21:28] *** sufrostico left
[21:30] *** sftp left
[21:32] *** _mg_ left
[21:33] *** cdg_ joined
[21:33] *** cdg_ left
[21:33] <jnthn> lizmat: Yeah...I guess follow what we do for Array since we tend to have thought it out well there, as it's the most used of the classes :)

[21:33] *** cdg_ joined
[21:34] *** sftp joined
[21:39] <dalek> rakudo/nom: 0a35d4c | lizmat++ | src/core/Buf.pm:

[21:39] <dalek> rakudo/nom: Streamline failing in Buf

[21:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0a35d4c5e8

[21:41] *** kaare_ left
[21:50] <[Coke]> yapc-na; hackathon before or after?

[21:52] *** sno joined
[21:55] <nine> Once you start thinking about loading precomp files from multiple stores the current architecture doesn't fit at all anymore

[21:59] *** kid51 joined
[22:01] <lizmat> [Coke]: at this point, I could go either way  :-)

[22:01] <jnthn> nine: Yes, when I started thinking about that, I realized how tangled it becomes...

[22:02] <jnthn> ...which is why the "head of the chain precomps" design came up

[22:02] *** rindolf left
[22:02] <jnthn> What I didn't expect us to do was to end up with such a long chain :)

[22:03] <[Coke]> lizmat: just looking at flights. look like I can book something today for saturday to saturday for not unreasonable amounts of dollars.

[22:03] <[Coke]> i'm sure there will be some hacking available during that window, if I can make that happen.

[22:04] *** skids left
[22:04] <lizmat> yes, then it will *definitely* happen :-)

[22:04] <lizmat> jnthn: did you ever consider an nqp::slice op ?

[22:04] <lizmat> for slicing elements out of nqp lists ?

[22:05] * lizmat is looking at implementing Buf.splice

[22:05] <lizmat> creating the return value of Buf.splice is expensive :-(

[22:05] <jnthn> nine: I still wonder if no modules in this repo = skip and let the next one use its precomp store could work

[22:05] <jnthn> lizmat: Can't you use nqp::splice in some cunning way to do that?

[22:06] *** musiKk left
[22:06] <lizmat> looked at this, but nqp::slice returns the list on which it operates

[22:06] <lizmat> *not* what is being removed

[22:07] <jnthn> Ah

[22:07] <lizmat> (or I must be getting too tired)

[22:08] <nine> jnthn: now that you mention that, I wonder why I haven't tried implementing that. Skipping an empty repo sounds rather trivial and would get us a good part of the benefit.

[22:08] <lizmat> anyways, having an nqp::slice could be generally beneficial for slicing into native arrays, no?

[22:08] <jnthn> lizmat: No, I think you're right

[22:08] <jnthn> lizmat: yes but...

[22:08] <jnthn> lizmat: I've long pondered a more general nqp::memcpy style op

[22:08] <jnthn> I think we might be able to fold it into that

[22:09] <lizmat> ok, in that light, I'll fake it for now, we can plug it in at a later time

[22:09] <jnthn> *nod*

[22:09] <jnthn> It'd be useful for subbuf too

[22:09] <lizmat> yup

[22:09] <jnthn> But also for various NativeCall scenarios I suspect

[22:10] <lizmat> yup

[22:11] <sortiz> jnthn, That would make my NativeHelpers::Buff worthless! ;-)

[22:11] <jnthn> .oO( In one fell op... )

[22:11] <timotimo> don't worry, it's just a little nerf

[22:12] <sortiz> s/Buff/Blob/

[22:15] <sortiz> btw, some decision about my proposed :initial-elems for Blob.new() ?

[22:16] <lizmat> jnthn sortiz : perhaps a 'new-with-size(...) method ?

[22:17] <timotimo> hum, weren't blobs read-only?

[22:17] <lizmat> eh, yeah, sorry, Buf.new I guess

[22:17] <timotimo> right, but isn't it enough to my $b = Buf.new(); $b[1000] = 0; ?

[22:17] <timotimo> m: my $b = Buf.new(); $b[10] = 0; say $b.perl

[22:17] <jnthn> Yeah, but it's ugly :)

[22:17] <camelia> rakudo-moar 0a35d4: OUTPUT«Buf.new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)␤»

[22:18] <timotimo> well, fair enough

[22:18] <jnthn> But yeah, it's pretty much just as good functionally :)

[22:18] <jnthn> Maybe Buf.allocate($items) is nicer

[22:18] <timotimo> that sounds all right

[22:19] <jnthn> Where $items is the number of items

[22:19] <timotimo> could also do something like that for NativeCall's CArray

[22:19] <sortiz> And that don't work for Blob, 'cus inmutable size.

[22:19] <jnthn> I shoulda written $elems :)

[22:19] *** yurivish joined
[22:19] <jnthn> sortiz: Yeah, there's no point putting this method on Blob :)

[22:19] <timotimo> isn't Blob also immutable content?

[22:19] <jnthn> You can't mutate it :)

[22:20] <sortiz> It's for preallocation only, the alternative Blob.new(0 xx 100) is slow... 

[22:20] <jnthn> I dislike Buf.allocate($elems) the least so far, anyways :)

[22:20] <timotimo> what do you do with a Blob that's preallocated?

[22:21] <lizmat> timotimo: an immutable buf with nulls ?

[22:21] <jnthn> lizmat: Yes, so you'd use Buf, not Blob...

[22:21] <lizmat> so .allocate on a Blob doesn't make sense

[22:21] <lizmat> indee

[22:21] <lizmat> d

[22:21] <sortiz> Is inmutable in size, not in content. 

[22:22] <timotimo> really? i'm pretty sure that's a bug, then

[22:22] <lizmat> Blob should be immutable in content as well, no ?

[22:22] <sortiz> Sorry, you right

[22:22] <lizmat> m: my $b = Blob.new(1,2,3); $b[2] = 42   # sortiz, how are you changing the blob ?

[22:22] <camelia> rakudo-moar 0a35d4: OUTPUT«Cannot modify an immutable Int␤  in block <unit> at /tmp/CDMn7Q3npb line 1␤␤»

[22:23] <timotimo> well, you can mutate it using the low-level ops with "use nqp" ;)

[22:24] <sortiz> And pass the reference to NC to fill it.

[22:24] <sortiz> *can*

[22:25] <lizmat> still, I think using a Buf would be more correct

[22:25] *** vendethiel left
[22:25] <lizmat> m: my $b = Buf.new(1,2,3); $b.push(Buf.new(4,5,6))   # hmmm... this should probably also work

[22:25] <camelia> rakudo-moar 0a35d4: OUTPUT«This representation (VMArray) does not support attribute storage␤  in any  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm line 1␤  in block <unit> at /tmp/LVq9TZwWey line 1␤␤»

[22:26] <sortiz> lizmat, In the later case (NC) dunno, precisely because it is inmutable.

[22:27] <lizmat> jnthn: what are your thoughts on a Blob being changed in NC ?

[22:27] <sortiz> lizmat, yeah, that should work.

[22:27] <jnthn> lizmat: DIHWIDT

[22:28] <jnthn> I strongly suggest folks pass a Buf instead

[22:28] <jnthn> m: Blob.new(1..10).say

[22:28] <camelia> rakudo-moar 0a35d4: OUTPUT«Blob:0x<01 02 03 04 05 06 07 08 09 0a>␤»

[22:28] <jnthn> m: Blob.new(1..10).subbuf(2, 5).say

[22:28] <camelia> rakudo-moar 0a35d4: OUTPUT«Blob:0x<03 04 05 06 07>␤»

[22:28] <jnthn> m: Blob.new(1..10).subbuf(2, 5).WHAT.say

[22:28] <camelia> rakudo-moar 0a35d4: OUTPUT«(Blob)␤»

[22:29] <jnthn> So, that I plan to implement later as taking a view into the original

[22:29] <jnthn> And if you go mutating it you'll get action at a distance.

[22:29] <lizmat> but not so for Buf, I would assume ?

[22:29] <lizmat> indeed

[22:29] <jnthn> Right

[22:30] <jnthn> It's quite a notable optimization that we can do for Blob (and we do a similar thing for .substr under the hood in Moar)

[22:30] <lizmat> yeah, for substr that would be brill

[22:30] <timotimo> substr already has that

[22:30] <jnthn> lizmat: It already does it for substr :)

[22:30] <sortiz> Right now passing "Str is rw" to NC has valid user cases.

[22:30] <lizmat> ah?

[22:31] <lizmat> cool!

[22:31] <timotimo> sortiz: right, but NC doesn't get the original underlying string

[22:31] <timotimo> we don't want to leak out synthetic codepoints, ever

[22:31] <jnthn> Also, `is rw` is talking about a Scalar pointing to a Str. The rw thing is the Scalar, not the Str.

[22:31] <lizmat> jnthn: perhaps also for lists ?

[22:31] <jnthn> lizmat: Perhaps, yeah

[22:32] <jnthn> I mean, the functionality would support it

[22:32] <jnthn> How we'd expose/use it API wise, I'm not sure

[22:33] <jnthn> (The VM level functionality, I mean)

[22:33] <lizmat> me neither atm, but I am pretty tired already :-)

[22:33] <jnthn> Yeah, I've had two longer days than I should probably be having :)

[22:34] <jnthn> (Now relaxing with a beer before sleep...and tomorrow should be an easy day :))

[22:34] <sortiz> jnthn, Before I forget, what are the plan about "my $foo is MyContainer"

[22:34] <jnthn> sortiz: Works already, no?

[22:35] <jnthn> Well...hm

[22:35] <jnthn> I guess I only checked it for @/%

[22:35] <jnthn> :)

[22:35] <jnthn> And we case-analyze $ so it's not quite so easy there

[22:35] *** sevvie joined
[22:35] <dalek> rakudo/nom: a02d44b | lizmat++ | src/core/Buf.pm:

[22:35] <dalek> rakudo/nom: Add Buf.splice(int @a) candidate

[22:35] <dalek> rakudo/nom: 

[22:35] <dalek> rakudo/nom: More to come...

[22:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a02d44b93f

[22:36] <jnthn> sortiz: I suspect it'll be a case of writing a STORE/FETCH method anyway

[22:36] <jnthn> May need a little low-level work

[22:36] <jnthn> Also a *lot* of care to not infinitely recurse

[22:37] <jnthn> (As it's quite easy to manage with a Proxy)

[22:39] <jnthn> I think https://github.com/rakudo/rakudo/pull/688 isn't going to fly as a solution for the reason nine++ pointed out

[22:39] <jnthn> But I did ponder another way

[22:39] <jnthn> Which is to use subsignatures

[22:40] <jnthn> sub MAIN(('subcommand', Str $arg, Int :$subcom-option), :$general-option) { ... }

[22:40] <jnthn> Which probably would deal with that case

[22:40] <dalek> rakudo/nom: b801c3a | coke++ | docs/release_guide.pod:

[22:40] <dalek> rakudo/nom: use errata branch for testing, not original tag

[22:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b801c3a4cf

[22:41] <jnthn> Would need some mangling but might be a more promising direction to explore in.

[22:42] <timotimo> i like the sound of that

[22:42] <timotimo> it's also unlikely that someone would already have a signature like that in their MAIN so far

[22:42] <timotimo> so we wouldn't break things

[22:43] <timotimo> at least i think so

[22:43] <timotimo> BBIAB

[22:47] <jnthn> rest time

[22:47] <jnthn> 'night all o/

[22:47] <sortiz> Thank you jnthn, relax

[22:48] <lizmat> good night, jnthn 

[22:48] *** spider-mario left
[22:48] <jnthn> Will do. Looking forward to digging into more Perl 6 things again soon. \o/

[22:48] <jnthn> o/

[22:48] <Skarsnik> gah, I did not work on dbiish today

[22:48] <Skarsnik> anyway, have a good night #perl6

[22:49] <sortiz> lizmat, you also deserve it.

[22:49] <sortiz> o/ Skarsnik.

[22:50] <lizmat> gnight Skarsnik 

[22:50] <Skarsnik> and ++ for the optimision stuff I glimps on dalek msg x)

[22:51] <sortiz> Skarsnik, I plan to work in dbiish tomorrow, btw.

[22:53] *** yurivish left
[22:58] *** haircode left
[22:58] *** avar left
[22:58] *** crux left
[22:58] *** wtw left
[22:58] *** literal left
[22:58] *** jervo left
[22:58] *** sjohnson left
[22:58] *** matt_ left
[22:58] *** kid51 left
[22:58] *** FROGGS left
[22:58] *** AlexDaniel left
[22:58] *** vytas left
[22:58] *** john51 left
[22:58] *** rhr left
[22:58] *** brabo left
[22:58] *** erdic left
[22:58] *** MilkmanDan left
[22:58] *** yqt left
[22:58] *** TEttinger left
[22:58] *** inokenty left
[22:58] *** ribasushi left
[22:58] *** leedo left
[22:58] *** dpk left
[22:58] *** xiaomiao left
[22:58] *** cognominal left
[22:58] *** xnrand left
[22:58] *** Roamer` left
[22:58] *** Woodi left
[22:58] *** ranguard left
[22:58] *** Grauwolf left
[22:58] *** au left
[22:58] *** moritz left
[22:58] *** rjbs left
[22:58] *** mst left
[22:58] *** broquaint left
[22:58] *** [Coke] left
[22:58] *** camelia left
[22:58] *** eiro left
[22:58] *** burnersk left
[22:58] *** sevvie left
[22:58] *** SCHAAP137 left
[22:58] *** roguelazer left
[22:58] *** wamba1 left
[22:58] *** mithaldu_ left
[22:58] *** peteretep left
[22:58] *** jnthn left
[22:58] *** alnewkirk left
[22:58] *** xinming left
[22:58] *** hobbs left
[22:58] *** beatdown left
[22:58] *** mrsolo left
[22:58] *** ilmari left
[22:58] *** polyfloyd left
[22:58] *** andrewalker left
[22:58] *** Praise left
[22:58] *** kent\n left
[22:58] *** petercommand left
[22:58] *** edenc left
[22:58] *** damnlie left
[22:58] *** Khisanth left
[22:58] *** [Tux] left
[22:58] *** mspo left
[22:58] *** dsp- left
[22:58] *** jercos left
[22:58] *** pochi left
[22:58] *** pdcawley left
[22:58] *** d^_^b left
[22:58] *** Hotkeys left
[22:58] *** gabiruh left
[22:58] *** b2gills left
[22:58] *** mohae left
[22:58] *** PotatoGim left
[22:58] *** lnrdo left
[22:58] *** ugexe left
[22:58] *** nebuchadnezzar left
[22:58] *** simcop2387 left
[22:58] *** mkz left
[22:58] *** TeamBlast left
[22:58] *** sftp left
[22:58] *** _dolmen_ left
[22:58] *** [particle] left
[22:58] *** firstdayonthejob left
[22:58] *** Guest72897 left
[22:58] *** pmurias left
[22:58] *** tmch left
[22:58] *** DarthGandalf left
[22:58] *** tharkun left
[22:58] *** decent left
[22:58] *** khw left
[22:58] *** synopsebot6 left
[22:58] *** dalek left
[22:58] *** skarn left
[22:58] *** caasih left
[22:58] *** boegel left
[22:58] *** hoelzro left
[22:58] *** jnap left
[22:58] *** flussence left
[22:58] *** hacst left
[22:58] *** renormalist left
[22:58] *** aindilis left
[22:58] *** cfedde left
[22:59] *** Jarcode left
[22:59] *** jsimonet1 left
[22:59] *** autogen left
[22:59] *** luis left
[22:59] *** Juerd left
[22:59] *** El_Che left
[22:59] *** sivoais left
[22:59] *** TimToady left
[22:59] *** lostinfog left
[22:59] *** TreyHarris left
[22:59] *** araujo left
[22:59] *** jeek left
[22:59] *** dg left
[22:59] *** shadowpaste left
[22:59] *** keix left
[22:59] *** jferrero left
[22:59] *** nemo left
[22:59] *** diakopter left
[22:59] *** Bucciarati left
[22:59] *** konobi left
[22:59] *** sm0x left
[22:59] *** masak left
[22:59] *** dustinm` left
[22:59] *** ilbot3 left
[22:59] *** japhb left
[22:59] *** kst left
[22:59] *** agentzh left
[22:59] *** psch left
[22:59] *** mattp_ left
[22:59] *** lestrrat left
[22:59] *** felher left
[22:59] *** awwaiid left
[22:59] *** LGD left
[22:59] *** Upasaka left
[22:59] *** arnsholt left
[22:59] *** captain-adequate left
[22:59] *** sjn left
[22:59] *** jevin left
[22:59] *** zacts left
[22:59] *** breinbaas left
[22:59] *** Util left
[22:59] *** bpmedley left
[22:59] *** emdashcomma left
[22:59] *** tadzik left
[22:59] *** ingy left
[22:59] *** jdv79 left
[22:59] *** perigrin left
[22:59] *** geraud left
[22:59] *** cibs left
[22:59] *** sno left
[22:59] *** cdg_ left
[22:59] *** prammer left
[22:59] *** Skarsnik left
[22:59] *** nowan left
[22:59] *** cgfbee left
[22:59] *** RabidGravy left
[22:59] *** lustlife left
[22:59] *** lucs left
[22:59] *** bhm left
[22:59] *** Sgeo left
[22:59] *** Gothmog_ left
[22:59] *** sunnavy left
[22:59] *** musca left
[22:59] *** llfourn left
[22:59] *** apejens left
[22:59] *** yeltzooo left
[22:59] *** Amnez777 left
[22:59] *** Grrrr left
[22:59] *** cosimo left
[22:59] *** mathw left
[22:59] *** perlpilot left
[22:59] *** krakan left
[22:59] *** SHODAN left
[22:59] *** tony-o left
[22:59] *** sergot left
[22:59] *** zhmylove left
[22:59] *** cxreg left
[22:59] *** kshannon left
[22:59] *** jast left
[22:59] *** profan left
[22:59] *** raydiak_ left
[22:59] *** autarch left
[22:59] *** patrickz left
[22:59] *** jameslenz left
[22:59] *** atta left
[22:59] *** salva left
[22:59] *** noganex left
[22:59] *** Celelibi left
[22:59] *** huf left
[22:59] *** gregf_ left
[22:59] *** ggoebel16 left
[22:59] *** adrusi left
[22:59] *** n0xff left
[22:59] *** gfldex left
[22:59] *** Vitrifur left
[22:59] *** lizmat left
[22:59] *** cpage left
[22:59] *** ambs left
[22:59] *** rdleon left
[22:59] *** tinita left
[22:59] *** Timbus left
[22:59] *** gypsydave5 left
[22:59] *** BooK left
[22:59] *** KotH left
[22:59] *** jcallen left
[22:59] *** MadcapJake left
[22:59] *** pederindi left
[22:59] *** nine left
[22:59] *** olinkl left
[22:59] *** mre left
[22:59] *** Possum left
[22:59] *** ruoso left
[22:59] *** BuildTheRobots left
[22:59] *** parisba left
[22:59] *** clkao left
[22:59] *** kipd left
[22:59] *** Spot__ left
[22:59] *** ggherdov left
[22:59] *** chansen_ left
[22:59] *** rodarmor left
[22:59] *** dylanwh_ left
[22:59] *** apathor left
[22:59] *** Humbedooh left
[22:59] *** retupmoca left
[22:59] *** Lucas_One_ left
[22:59] *** SmokeMachine____ left
[22:59] *** rudi_s left
[22:59] *** DrForr left
[22:59] *** silug left
[22:59] *** ab5tract left
[22:59] *** maddingue left
[22:59] *** Ulti left
[22:59] *** skaji left
[22:59] *** telex left
[22:59] *** colomon left
[22:59] *** raiph left
[22:59] *** neilb left
[22:59] *** gensym left
[22:59] *** Cabanossi left
[23:00] *** solarbunny left
[23:00] *** ilbelkyr left
[23:00] *** grondilu left
[23:00] *** stmuk_ left
[23:00] *** pnu left
[23:00] *** khagan left
[23:00] *** rvchangue left
[23:00] *** sQuEE left
[23:00] *** zostay left
[23:00] *** nchambers left
[23:00] *** richi235 left
[23:00] *** pRiVi left
[23:00] *** domm_ left
[23:00] *** ponbiki left
[23:00] *** charsbar__ left
[23:00] *** rntz left
[23:00] *** f3ew left
[23:00] *** geekosaur left
[23:00] *** integral left
[23:00] *** mephinet left
[23:00] *** notbenh left
[23:00] *** frew left
[23:00] *** drforr1 left
[23:00] *** frederico left
[23:00] *** lnx left
[23:00] *** Rotwang left
[23:00] *** k-man left
[23:00] *** ashleydev left
[23:00] *** Fleurety left
[23:00] *** garu left
[23:00] *** vike left
[23:00] *** xxpor left
[23:00] *** anshin left
[23:00] *** [ptc] left
[23:00] *** robinsmidsrod left
[23:00] *** Peter_R left
[23:00] *** avalenn left
[23:00] *** jantore left
[23:00] *** Amnez777 joined
[23:03] *** MilkmanDan joined
[23:03] *** brabo joined
[23:03] *** rhr joined
[23:03] *** erdic joined
[23:03] *** vytas joined
[23:03] *** AlexDaniel joined
[23:03] *** FROGGS joined
[23:03] *** kid51 joined
[23:03] *** jervo joined
[23:03] *** wtw joined
[23:03] *** literal joined
[23:03] *** crux joined
[23:03] *** avar joined
[23:03] *** profan joined
[23:03] *** raydiak_ joined
[23:03] *** perigrin joined
[23:03] *** cibs joined
[23:03] *** jast joined
[23:03] *** jdv79 joined
[23:03] *** kshannon joined
[23:03] *** cxreg joined
[23:03] *** ingy joined
[23:03] *** zhmylove joined
[23:03] *** sergot joined
[23:03] *** tadzik joined
[23:03] *** emdashcomma joined
[23:03] *** bpmedley joined
[23:03] *** tony-o joined
[23:03] *** Util joined
[23:03] *** breinbaas joined
[23:03] *** SHODAN joined
[23:03] *** jevin joined
[23:03] *** krakan joined
[23:03] *** sjn joined
[23:03] *** captain-adequate joined
[23:03] *** arnsholt joined
[23:03] *** perlpilot joined
[23:03] *** Upasaka joined
[23:03] *** mathw joined
[23:03] *** Grrrr joined
[23:03] *** cosimo joined
[23:03] *** LGD joined
[23:03] *** yeltzooo joined
[23:03] *** awwaiid joined
[23:03] *** apejens joined
[23:03] *** llfourn joined
[23:03] *** felher joined
[23:03] *** lestrrat joined
[23:03] *** zacts joined
[23:03] *** musca joined
[23:03] *** sunnavy joined
[23:03] *** mattp_ joined
[23:03] *** psch joined
[23:03] *** agentzh joined
[23:03] *** kst joined
[23:03] *** Gothmog_ joined
[23:03] *** geraud joined
[23:03] *** japhb joined
[23:03] *** Sgeo joined
[23:03] *** ilbot3 joined
[23:03] *** dustinm` joined
[23:03] *** bhm joined
[23:03] *** masak joined
[23:03] *** sm0x joined
[23:03] *** diakopter joined
[23:03] *** Bucciarati joined
[23:03] *** konobi joined
[23:03] *** nemo joined
[23:03] *** jferrero joined
[23:03] *** lucs joined
[23:03] *** keix joined
[23:03] *** shadowpaste joined
[23:03] *** dg joined
[23:03] *** jeek joined
[23:03] *** lustlife joined
[23:03] *** RabidGravy joined
[23:03] *** araujo joined
[23:03] *** cgfbee joined
[23:03] *** nowan joined
[23:03] *** Skarsnik joined
[23:03] *** TreyHarris joined
[23:03] *** lostinfog joined
[23:03] *** prammer joined
[23:03] *** TimToady joined
[23:03] *** cdg_ joined
[23:03] *** sno joined
[23:03] *** telex joined
[23:03] *** matt_ joined
[23:03] *** haircode joined
[23:03] *** sivoais joined
[23:03] *** El_Che joined
[23:03] *** Juerd joined
[23:03] *** autogen joined
[23:03] *** luis joined
[23:03] *** jsimonet1 joined
[23:03] *** Jarcode joined
[23:03] *** cfedde joined
[23:03] *** aindilis joined
[23:03] *** renormalist joined
[23:03] *** hacst joined
[23:03] *** flussence joined
[23:03] *** jnap joined
[23:03] *** hoelzro joined
[23:03] *** boegel joined
[23:03] *** caasih joined
[23:03] *** synopsebot6 joined
[23:03] *** khw joined
[23:03] *** tharkun joined
[23:03] *** decent joined
[23:03] *** DarthGandalf joined
[23:03] *** tmch joined
[23:03] *** pmurias joined
[23:03] *** Guest72897 joined
[23:03] *** firstdayonthejob joined
[23:03] *** [particle] joined
[23:03] *** _dolmen_ joined
[23:03] *** dalek joined
[23:03] *** avalenn joined
[23:03] *** robinsmidsrod joined
[23:03] *** [ptc] joined
[23:03] *** Peter_R joined
[23:03] *** daxim joined
[23:03] *** timrs2991 joined
[23:03] *** sjohnsen joined
[23:03] *** BinGOs joined
[23:03] *** timotimo joined
[23:03] *** xxpor joined
[23:03] *** anshin joined
[23:03] *** vike joined
[23:03] *** ashleydev joined
[23:03] *** garu joined
[23:03] *** k-man joined
[23:03] *** Fleurety joined
[23:03] *** frederico joined
[23:03] *** lnx joined
[23:03] *** Rotwang joined
[23:03] *** drforr1 joined
[23:03] *** frew joined
[23:03] *** notbenh joined
[23:03] *** mephinet joined
[23:03] *** integral joined
[23:03] *** geekosaur joined
[23:03] *** burnersk joined
[23:03] *** eiro joined
[23:03] *** camelia joined
[23:03] *** [Coke] joined
[23:03] *** broquaint joined
[23:03] *** moritz joined
[23:03] *** rjbs joined
[23:03] *** mst joined
[23:03] *** au joined
[23:03] *** Grauwolf joined
[23:03] *** ranguard joined
[23:03] *** Woodi joined
[23:03] *** Roamer` joined
[23:03] *** xnrand joined
[23:03] *** cognominal joined
[23:03] *** xiaomiao joined
[23:03] *** leedo joined
[23:03] *** dpk joined
[23:03] *** inokenty joined
[23:03] *** ribasushi joined
[23:03] *** TEttinger joined
[23:03] *** yqt joined
[23:03] *** sjohnson joined
[23:03] *** TeamBlast joined
[23:03] *** mkz joined
[23:03] *** simcop2387 joined
[23:03] *** nebuchadnezzar joined
[23:03] *** ugexe joined
[23:03] *** lnrdo joined
[23:03] *** mohae joined
[23:03] *** b2gills joined
[23:03] *** gabiruh joined
[23:03] *** Hotkeys joined
[23:03] *** d^_^b joined
[23:03] *** pdcawley joined
[23:03] *** dsp- joined
[23:03] *** jercos joined
[23:03] *** pochi joined
[23:03] *** mspo joined
[23:03] *** [Tux] joined
[23:03] *** Khisanth joined
[23:03] *** damnlie joined
[23:03] *** edenc joined
[23:03] *** petercommand joined
[23:03] *** kent\n joined
[23:03] *** Praise joined
[23:03] *** cameron.freenode.net sets mode: +v camelia

[23:03] *** andrewalker joined
[23:03] *** polyfloyd joined
[23:03] *** ilmari joined
[23:03] *** mrsolo joined
[23:03] *** beatdown joined
[23:03] *** hobbs joined
[23:03] *** xinming joined
[23:03] *** jnthn joined
[23:03] *** alnewkirk joined
[23:03] *** peteretep joined
[23:03] *** mithaldu_ joined
[23:03] *** wamba1 joined
[23:03] *** roguelazer joined
[23:03] *** SCHAAP137 joined
[23:03] *** baest joined
[23:03] *** mindos joined
[23:03] *** skaji joined
[23:03] *** Ulti joined
[23:03] *** maddingue joined
[23:03] *** ab5tract joined
[23:03] *** silug joined
[23:03] *** rudi_s joined
[23:03] *** SmokeMachine____ joined
[23:03] *** Lucas_One_ joined
[23:03] *** apathor joined
[23:03] *** Humbedooh joined
[23:03] *** retupmoca joined
[23:03] *** dylanwh_ joined
[23:03] *** rodarmor joined
[23:03] *** chansen_ joined
[23:03] *** Spot__ joined
[23:03] *** kipd joined
[23:03] *** clkao joined
[23:03] *** parisba joined
[23:03] *** DrForr joined
[23:04] *** Amnez777 left
[23:04] *** huf_ joined
[23:04] *** jantore joined
[23:04] *** solarbunny joined
[23:04] *** grondilu joined
[23:04] *** stmuk_ joined
[23:04] *** pnu joined
[23:04] *** rntz joined
[23:04] *** khagan joined
[23:04] *** rvchangue joined
[23:04] *** sQuEE joined
[23:04] *** zostay joined
[23:04] *** richi235 joined
[23:04] *** pRiVi joined
[23:04] *** domm_ joined
[23:04] *** ponbiki joined
[23:04] *** charsbar__ joined
[23:04] *** f3ew joined
[23:04] *** hahainternet joined
[23:04] *** sevvie joined
[23:04] *** john51 joined
[23:04] *** colomon joined
[23:04] *** raiph joined
[23:04] *** neilb joined
[23:04] *** gensym joined
[23:04] *** yoleaux joined
[23:04] *** cameron.freenode.net sets mode: +v yoleaux

[23:05] *** KotH_ joined
[23:05] *** n0xff_ joined
[23:05] *** gypsydav15 joined
[23:05] *** john51 left
[23:05] *** ruoso_ joined
[23:05] *** BooK_ joined
[23:05] *** tinita_ joined
[23:05] *** caasih left
[23:05] *** gfldex_ joined
[23:05] *** jnap left
[23:05] *** Amnez777 joined
[23:05] <dalek> rakudo/nom: 64e1c72 | lizmat++ | src/core/Buf.pm:

[23:05] <dalek> rakudo/nom: Buf:D candidates for Buf.splice|push|unshift etc.

[23:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/64e1c728c8

[23:06] *** salv0 joined
[23:06] *** FROGGS left
[23:06] *** autarch joined
[23:06] *** patrickz joined
[23:06] *** jameslenz joined
[23:06] *** n0xff joined
[23:06] *** atta joined
[23:06] *** salva joined
[23:06] *** noganex joined
[23:06] *** huf joined
[23:06] *** gregf_ joined
[23:06] *** ggoebel16 joined
[23:06] *** adrusi joined
[23:06] *** gfldex joined
[23:06] *** Vitrifur joined
[23:06] *** lizmat joined
[23:06] *** cpage joined
[23:06] *** ambs joined
[23:06] *** rdleon joined
[23:06] *** tinita joined
[23:06] *** Timbus joined
[23:06] *** gypsydave5 joined
[23:06] *** BooK joined
[23:06] *** KotH joined
[23:06] *** jcallen joined
[23:06] *** MadcapJake joined
[23:06] *** pederindi joined
[23:06] *** nine joined
[23:06] *** mre joined
[23:06] *** Possum joined
[23:06] *** ruoso joined
[23:06] *** ChanServ sets mode: +v dalek

[23:06] *** Timbus_ joined
[23:06] *** sftp joined
[23:06] *** nchambers joined
[23:06] *** sjohnson left
[23:06] *** firstdayonthejob left
[23:07] *** jcallen left
[23:07] *** gregf_ left
[23:07] *** huf left
[23:07] *** n0xff left
[23:07] *** tinita left
[23:07] *** gypsydave5 left
[23:07] *** BooK left
[23:07] *** KotH left
[23:07] *** ruoso left
[23:07] *** gfldex left
[23:07] *** mre left
[23:07] *** WAADLHR joined
[23:07] *** salva left
[23:07] *** Timbus left
[23:07] <lizmat> hmmm... dalek is taking a long time to see my push

[23:07] *** lizmat left
[23:07] *** Cabanossi joined
[23:07] *** lizmat_ joined
[23:07] *** ilbelkyr joined
[23:07] *** jcallen joined
[23:07] *** john51 joined
[23:07] *** Celelibi joined
[23:07] *** skarn joined
[23:08] <lizmat_> yup, something amiss in the mean hook delivery time on status.github.com

[23:08] <geekosaur> [23 23:05] <dalek> rakudo/nom: 64e1c72 | lizmat++ | src/core/Buf.pm:

[23:08] *** lizmat_ is now known as lizmat

[23:08] <geekosaur> not that one?

[23:08] <lizmat> ah, *i* did not see that, but I see it in the backlog

[23:08] <geekosaur> weird effects from the rehubbing or whatever

[23:08] <lizmat> guess I was on the wrong end of a netsplit

[23:09] *** mre joined
[23:09] <geekosaur> everyone was for a bit, they rebooted some network device and netsplit *everyone*

[23:09] <lizmat> ah, ok  :-)

[23:09] <lizmat> anyways, enough from me today

[23:09] <lizmat> good night, #perl6!

[23:09] *** vendethiel joined
[23:10] *** Skarsnik left
[23:10] <sortiz> 'night lizmat

[23:11] <sortiz> Thanks for the patience

[23:11] *** sjohnson joined
[23:12] <timotimo> gnite lizmat and jnthn

[23:13] *** sjohnson left
[23:15] *** sjohnson joined
[23:16] *** zpmorgan joined
[23:16] *** ggherdov joined
[23:17] *** BuildTheRobots joined
[23:17] *** KotH_ left
[23:17] *** KotH joined
[23:18] *** ggherdov left
[23:18] *** ggherdov joined
[23:18] *** BuildTheRobots left
[23:18] *** BuildTheRobots joined
[23:22] *** _dolmen_ left
[23:25] *** PotatoGim joined
[23:26] *** jnap joined
[23:28] *** olinkl joined
[23:30] *** vendethiel left
[23:33] *** eiro_ joined
[23:34] *** eiro_ left
[23:37] *** john51_ joined
[23:39] *** skids joined
[23:40] *** caasih joined
[23:41] *** john51 left
[23:42] <stmuk_> "Professors like Lisp because they think they can write code like mathematics, which they can't." --@ErrataRob at #polarvortexconelniño

[23:50] *** lostinfog left
[23:58] *** patrickz left
