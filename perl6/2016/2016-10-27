[00:04] *** user10 joined
[00:05] *** user9 left
[00:05] *** user10 is now known as user9

[00:14] *** _28_ria left
[00:16] *** BenGoldberg joined
[00:17] *** _28_ria joined
[00:24] *** _28_ria left
[00:25] *** _28_ria joined
[00:26] *** cognominal left
[00:35] *** cyphase left
[00:39] *** nightfrog left
[00:40] *** cyphase joined
[00:47] *** pierre_ joined
[00:54] *** eliasr left
[00:56] *** pdcawley joined
[00:59] *** aborazmeh joined
[00:59] *** aborazmeh left
[00:59] *** aborazmeh joined
[01:08] *** vendethiel left
[01:09] *** vendethiel joined
[01:16] *** pierre_ left
[01:16] *** skink left
[01:16] *** pierre_ joined
[01:19] <BenGoldberg> m: say ++$¢;

[01:19] <camelia> rakudo-moar a1fcee: OUTPUT«1␤»

[01:20] * BenGoldberg wonders what $¢'s purpose is.

[01:21] *** pierre_ left
[01:23] <geekosaur> isn't it something like the current capture in a regex?

[01:26] <viki> Current Cursor in grammar

[01:26] <geekosaur> right, it's the current state of what will become $/ after the match completes

[01:27] *** nicq20 joined
[01:32] <labster> viki: Thanks for asking, anyway, about Lingua::Number.  For bonus points, you can fix the bug: https://rt.perl.org/Ticket/Display.html?id=127071

[01:33] <labster> m: my $v = rx/foo/; say("foobar" ~~ $v); say("foobar" ~~ /foo/)

[01:33] <camelia> rakudo-moar a1fcee: OUTPUT«True␤｢foo｣␤»

[01:37] <MasterDuke> bisectable6: my $v = rx/foo/; say("foobar" ~~ $v); say("foobar" ~~ /foo/)

[01:37] <bisectable6> MasterDuke, On both starting points (old=2015.12 new=b7201a8) the exit code is 0 and the output is identical as well

[01:37] <bisectable6> MasterDuke, Output on both points: True␤｢foo｣

[01:38] <MasterDuke> bisectable6: old=2015.07 new=2015.12 my $v = rx/foo/; say("foobar" ~~ $v); say("foobar" ~~ /foo/)

[01:38] <bisectable6> MasterDuke, Bisecting by output (old=2015.07 new=2015.12) because on both starting points the exit code is 0

[01:38] <bisectable6> MasterDuke, bisect log: https://gist.github.com/3ac927ee99178823f595a1ee0810cedb

[01:38] <bisectable6> MasterDuke, (2015-12-10) https://github.com/rakudo/rakudo/commit/f457007181bb6e2dcb6aefe857f36d648ae38401

[01:39] *** nightfrog joined
[01:39] *** Sqirrel left
[01:40] *** FROGGS_ joined
[01:40] <viki> s: /foo/, 'ACCEPTS', \('foobar')

[01:40] <SourceBaby> viki, Sauce is at https://github.com/rakudo/rakudo/blob/a1fceeb/src/core/Regex.pm#L13

[01:40] <viki> s: rx/foo/, 'ACCEPTS', \('foobar')

[01:40] <SourceBaby> viki, Sauce is at https://github.com/rakudo/rakudo/blob/a1fceeb/src/core/Regex.pm#L13

[01:40] <viki> s: my $s = rx/foo/, 'ACCEPTS', \('foobar')

[01:40] <SourceBaby> viki, Sauce is at https://github.com/rakudo/rakudo/blob/a1fceeb/src/core/Regex.pm#L13

[01:41] <viki> m: my $v = rx/meow/; dd "foobar" ~~ $v; 

[01:41] <camelia> rakudo-moar a1fcee: OUTPUT«Bool::False␤»

[01:41] *** FROGGS left
[01:41] <labster> does bisectable work by looking at exit code, or output?

[01:41] <viki> labster: both

[01:42] <MasterDuke> any change, to the exit code or output, should count

[01:43] *** aborazmeh left
[01:43] <labster> Ah, I see how it works.

[01:44] *** pdcawley_ joined
[01:44] *** pdcawley left
[01:45] *** ilbot3 left
[01:46] *** aborazmeh joined
[01:46] *** aborazmeh left
[01:46] *** aborazmeh joined
[01:47] <viki> m: my $v = rx/foo/; say("foobar" ~~ $v); dd $/

[01:47] <camelia> rakudo-moar a1fcee: OUTPUT«True␤Nil $/ = Nil␤»

[01:47] <viki> labster: no idea. You could try asking lizmat. She's might be familiar with this area. I suspect it's something to do with $/

[01:47] *** ilbot3 joined
[01:48] *** Sqirrel joined
[01:49] *** pdcawley_ left
[01:49] <viki> m: my $v = rx/foo/; say("foobar" ~~ /<$v>/);

[01:49] <camelia> rakudo-moar a1fcee: OUTPUT«｢foo｣␤»

[01:49] <viki> labster: ^ workaround

[01:49] *** fredstorm joined
[01:49] <labster> Well, bisectable blames Larry.

[01:50] <labster> That's not great, but I might do it anyway.

[01:51] <viki> labster: where does bisectable blame Larry? Above? That's just the "oldest" (sorta) commit it knows about. It didn't find any difference and this behaved like that since our first stable release.

[01:52] <labster> it doesn't look like that in the log to me?

[01:52] <viki> Or rather, it did today and on 2015-12-10. There's a caveat that the stuff behaved differently in the middle.

[01:52] <viki> Ah.

[01:52] * viki really needs to go to bed :)

[01:55] *** pierre_ joined
[01:55] <viki> labster: I guess it needs a check that the QAST::Var doesn't itself contain a regex.

[01:55] <viki> labster: I'll try to look into it tomorrow, unless someone beats me to it.

[01:56] *** fredstorm left
[01:58] *** aries_liuxueyang left
[02:00] *** pierre_ left
[02:00] *** pierre_ joined
[02:04] *** pierre_ left
[02:05] *** aries_liuxueyang joined
[02:05] *** pierre_ joined
[02:07] *** aborazmeh left
[02:08] *** aborazmeh joined
[02:08] *** aborazmeh left
[02:08] *** aborazmeh joined
[02:09] *** Jesmaybe joined
[02:16] *** aries_liuxueyang left
[02:20] *** aries_liuxueyang joined
[02:36] *** aborazmeh left
[02:42] *** pierre_ left
[02:44] *** pierre_ joined
[02:45] *** pdcawley joined
[02:48] *** aries_liuxueyang left
[02:49] *** noganex_ joined
[02:52] *** wamba joined
[02:53] *** noganex left
[03:05] *** nicq20 left
[03:06] *** pdcawley left
[03:06] *** Jesmaybe left
[03:08] *** Kop joined
[03:12] *** Kop left
[03:24] *** pierre_ left
[03:29] *** pierre_ joined
[03:30] *** Jesmaybe joined
[03:36] *** pierre__ joined
[03:36] *** pierre_ left
[03:49] *** Jesmaybe left
[03:54] *** skids left
[04:01] *** wamba left
[04:01] *** pdcawley joined
[04:05] *** khw left
[04:18] *** pdcawley left
[04:28] *** Cabanossi left
[04:30] *** Cabanossi joined
[04:35] *** pierre__ left
[04:36] *** canopus left
[04:36] *** pierre_ joined
[04:41] *** canopus joined
[04:45] *** xinming joined
[04:47] *** pierre_ left
[04:53] *** BenGoldberg left
[04:55] *** pierre_ joined
[04:57] *** Penguiniator joined
[05:00] *** pierre_ left
[05:00] *** rurban joined
[05:00] *** rurban left
[05:03] *** Penguiniator left
[05:06] *** wamba joined
[05:13] *** pdcawley joined
[05:15] *** skrshn joined
[05:15] <skrshn> Newbie question: In the program (https://gist.github.com/anonymous/1e410ebdae854ba3787dca51afa63d1c), I want to have some arguments as required and others optional

[05:16] <skrshn> Is this possible?

[05:23] *** darutoko joined
[05:23] *** cyphase left
[05:27] <moritz> skrshn: yes, you can make named params mandatory with a !

[05:27] <moritz> m: sub f(:$x!) { }; f()

[05:27] <camelia> rakudo-moar a1fcee: OUTPUT«Required named parameter 'x' not passed␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[05:31] *** pdcawley left
[05:34] <skrshn> I thought I tried it. It now works. Thanks

[05:34] *** cyphase joined
[05:42] *** wamba left
[05:43] *** canopus left
[05:43] *** _28_ria left
[05:44] *** canopus joined
[05:45] *** _28_ria joined
[05:50] *** RabidGravy joined
[05:56] *** pierre_ joined
[05:58] *** rurban joined
[05:59] *** snowman left
[06:01] *** pierre_ left
[06:06] <moritz> you're welcome

[06:08] *** abraxxa joined
[06:09] <RabidGravy> boom

[06:09] <timotimo> boom gravy

[06:13] *** abraxxa left
[06:23] <RabidGravy> right, off to earn some quids

[06:23] <timotimo> good quiddin'

[06:25] *** neuraload joined
[06:25] *** firstdayonthejob joined
[06:27] *** FROGGS_ is now known as FROGGS

[06:27] *** pierre_ joined
[06:28] *** pdcawley joined
[06:28] *** wamba joined
[06:32] *** domidumont joined
[06:32] *** wamba left
[06:36] *** domidumont left
[06:37] *** domidumont joined
[06:37] *** abraxxa joined
[06:40] *** firstdayonthejob left
[06:42] *** domidumont left
[06:43] *** Tonik joined
[06:47] *** wamba joined
[06:55] *** wamba left
[06:56] *** wamba joined
[06:57] *** ufobat joined
[06:59] *** domidumont joined
[06:59] *** _28_ria left
[07:00] *** jonas2 joined
[07:01] *** pdcawley left
[07:03] *** _28_ria joined
[07:04] *** eiro joined
[07:04] <eiro> hello

[07:04] <timotimo> hello

[07:04] <eiro> muuuuuch more people on this channel now :)

[07:04] <eiro> long time no see

[07:05] *** bjz joined
[07:05] <FROGGS> hi eiro 

[07:05] *** Upasaka left
[07:06] <timotimo> helps that a few of our people have been adding bots left, right, and center ;)

[07:07] <eiro> :)

[07:08] <eiro> thnaks to asynchrony, each perl6 bots run dozen of clients then

[07:10] *** Actualeyes left
[07:10] *** pmurias joined
[07:10] *** _28_ria left
[07:11] *** _28_ria joined
[07:12] *** bjz left
[07:13] *** _28_ria left
[07:15] *** CIAvash joined
[07:15] *** CIAvash left
[07:21] *** Actualeyes joined
[07:25] *** mr-foobar left
[07:26] *** labster left
[07:27] *** CIAvash joined
[07:28] *** CIAvash left
[07:29] *** labster joined
[07:34] *** dakkar joined
[07:52] *** salva00 joined
[07:55] *** TheovdH joined
[07:55] *** pdcawley joined
[07:55] *** abraxxa left
[08:00] *** Sqirrel left
[08:00] *** Sqirrel joined
[08:04] *** aborazmeh joined
[08:04] *** aborazmeh left
[08:04] *** aborazmeh joined
[08:07] *** pierre_ left
[08:10] *** pierre_ joined
[08:16] *** rindolf joined
[08:18] *** pdcawley left
[08:19] *** salva00 left
[08:27] *** abraxxa joined
[08:31] *** salva00 joined
[08:34] *** ocbtec joined
[08:38] <lizmat> .tell Zoffix the difference between my $a = rx/foo/; "foo" ~~ $a   and  "foo" ~~ /foo/ is in the codegen: the former goes through multi sub infix:<~~>(Mu \topic, Mu \matcher), which Boolifies the result

[08:38] <yoleaux> lizmat: I'll pass your message to Zoffix.

[08:38] <lizmat> m: my $v = rx/bar/; say("foobar" ~~ $v); say $/; say("foobar" ~~ /foo/); say $/

[08:38] <camelia> rakudo-moar a1fcee: OUTPUT«True␤Nil␤｢foo｣␤｢foo｣␤»

[08:41] *** salva00 left
[08:42] *** wamba left
[08:42] *** salva00 joined
[08:43] *** gregf_ joined
[08:43] <lizmat> Zoffix am testing a fix, but first afk for a few hours

[08:47] *** wamba joined
[08:48] *** salv0 joined
[08:52] *** g4 joined
[08:52] *** g4 left
[08:52] *** g4 joined
[08:54] *** __T joined
[08:54] <__T> hello, I have a quick question

[08:54] <timotimo> greetings

[08:54] <__T> what is the perl6 equivalent of the qw()

[08:55] <timotimo> just angle brackets

[08:55] <timotimo> m: say <hello how are you>.perl

[08:55] <camelia> rakudo-moar a1fcee: OUTPUT«("hello", "how", "are", "you")␤»

[08:55] <__T> oooh

[08:55] <__T> thats elegant 

[08:56] <__T> i love the gather take construction

[08:56] <timotimo> perl6 took the opportunity to make things that are used more often shorter to type

[08:56] <moritz> explicit qw also works, but not with ()

[08:56] *** zakharyas joined
[08:56] <timotimo> yeah, gather/take is really nice

[08:56] <timotimo> that's true, like this:

[08:56] <timotimo> m: say qw"hello how are you".perl

[08:57] <camelia> rakudo-moar a1fcee: OUTPUT«("hello", "how", "are", "you")␤»

[08:57] <timotimo> m: say qw^hello how are you^.perl

[08:57] <camelia> rakudo-moar a1fcee: OUTPUT«("hello", "how", "are", "you")␤»

[08:57] <moritz> or even

[08:57] <timotimo> m: say qw“hello how are you”.perl

[08:57] <camelia> rakudo-moar a1fcee: OUTPUT«("hello", "how", "are", "you")␤»

[08:57] <__T> and implementation of gather take + start keyword for some concurrency

[08:57] <moritz> m: say qw<hello how are you">

[08:57] <camelia> rakudo-moar a1fcee: OUTPUT«(hello how are you")␤»

[08:57] <timotimo> without the .perl you can't easily see where the list puts its separators then

[08:58] <moritz> right

[08:58] <__T> m: say 'hello world'

[08:58] <camelia> rakudo-moar a1fcee: OUTPUT«hello world␤»

[08:59] <timotimo> one of the best things about gather/take is that it works recursively, and even across subs/methods that don't know anything about gather/take

[08:59] <timotimo> with python's yield it's not as nice. not by a long shot.

[09:02] <__T> ok

[09:02] <__T> i'm now trying gather/take with start keyword

[09:02] <__T> so i make a list of promises

[09:02] <__T> i can flatten the array of promises just with: await @promises?

[09:03] <timotimo> that's not what flatten means, but yeah, that should do what you meant

[09:03] <__T> yeah sorry, flatten is not the right term

[09:03] <__T> how is fulfilling a promis named?

[09:03] <moritz> keeping it

[09:04] <timotimo> right, you can keep it or break it

[09:04] <__T> ok, so how i keep promises

[09:04] <__T> now i use .say for @promises

[09:05] <timotimo> oh, keeping promises is something the piece that's responsible for the promise does

[09:05] <timotimo> so, when the start { ... } block is finished and no exception happened or anything, the start block will keep its promise 

[09:06] <timotimo> the value it'll be kept with will be the return value of the start block (but be careful, you can't use return inside of a start block, because it's not a full subroutine)

[09:07] <__T> ok, i have to jump into these promises

[09:08] <moritz> also note that gather/take + start is a somewhat weird mix

[09:08] <moritz> gather/take is for creating a lazy list

[09:08] <moritz> and start / threads is about doing computation so eagerly that you even want it parallelized

[09:08] <timotimo> continuations don't go very well with going between threads

[09:08] <moritz> so, do you want lazy or eager?

[09:09] <__T> eager

[09:09] <moritz> then you don't really need gather/take

[09:09] <moritz> I mean sure, you can use it, but it's likely confusing

[09:09] <__T> i just found a concurrency example that uses gather/take

[09:09] <__T> and build from there

[09:09] <moritz> not all examples out there are idiomatic :-)

[09:10] <__T> so where can i use take start?

[09:10] <__T> or you mean, i dont have to use take to use start

[09:11] <__T> just within normal loops i guess

[09:11] <moritz> right

[09:11] <timotimo> yeah, start just gives you a regular old value. just a promise object

[09:11] <moritz> you  can do stuff like   my @promises = map { start computation($_) }, @inputs

[09:11] <moritz> where computation is your sub that does the actual work

[09:12] <__T> yes

[09:13] <__T> and from that array the promises will be kept or do i have to use @a = await @b?

[09:13] <moritz> or even my @results = @input.hyper.map(&computation)

[09:13] <__T> hyper.map..

[09:13] <timotimo> the promises will be kept on their own accord. if you access the .result of a promise, it'll block for you and give you the result

[09:13] <timotimo> if you want the result of a bunch of promises at once, you best use await with a list of promises

[09:13] <moritz> m: my @promises = map { start $_ + 2 }, 1..10; say await @promises

[09:13] <camelia> rakudo-moar a1fcee: OUTPUT«(3 4 5 6 7 8 9 10 11 12)␤»

[09:14] <moritz> __T: ^^ that's basically the the simplest thing you can do with promises

[09:14] *** pdcawley joined
[09:15] <moritz> m: sub compute($x) { $x + 2 }; say (1..10).hyper.map(&compute)

[09:15] <camelia> rakudo-moar a1fcee: OUTPUT«HyperSeq.new␤»

[09:15] <moritz> m: sub compute($x) { $x + 2 }; say (1..10).hyper.map(&compute).lsit

[09:15] <camelia> rakudo-moar a1fcee: OUTPUT«No such method 'lsit' for invocant of type 'HyperSeq'␤  in block <unit> at <tmp> line 1␤␤»

[09:15] <moritz> m: sub compute($x) { $x + 2 }; say (1..10).hyper.map(&compute).list

[09:15] <camelia> rakudo-moar a1fcee: OUTPUT«(3 4 5 6 7 8 9 10 11 12)␤»

[09:15] <moritz> implicit parallelization with .hyper

[09:15] <moritz> m: sub compute($x) { $x + 2 }; say (1..10).hyper(4).map(&compute).list

[09:15] <camelia> rakudo-moar a1fcee: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at <tmp> line 1␤␤»

[09:15] <moritz> m: sub compute($x) { $x + 2 }; say (1..10).hyper(batch => 4).map(&compute).list

[09:15] <camelia> rakudo-moar a1fcee: OUTPUT«(3 4 5 6 7 8 9 10 11 12)␤»

[09:15] <timotimo> is hyper actually stable at the moment?

[09:15] <moritz> dunno

[09:15] <timotimo> i thought there were still cases where hyper and map and/or grep will lose values

[09:17] <__T> well thanks for the examples, perl 6 looks very promising

[09:17] <__T> I already liked how elegant the Class implementation is

[09:17] <__T> and the type subsets that you can mek

[09:17] <__T> *make

[09:17] <timotimo> yeah, they're nice

[09:18] <__T> and ofcourse 0.1 + 0.2 == 0.3 

[09:18] <DrForr> Chained operators are handy as well.

[09:18] <__T> i didn't read about chained operators yet

[09:18] <timotimo> very yes

[09:19] <timotimo> m: say "yay" if 1 < 2 < 3 < 4

[09:19] <camelia> rakudo-moar a1fcee: OUTPUT«yay␤»

[09:20] <__T> nice

[09:20] <FROGGS> m: sub two { say "evaluated once"; 2 }; say "yay" if 1 < two() < 3 < 4

[09:20] <camelia> rakudo-moar a1fcee: OUTPUT«evaluated once␤yay␤»

[09:20] <__T> and ofcourse, something i really missed where the set operators

[09:20] <__T> (in perl 5)

[09:21] <__T> return is implicit still in perl 6?

[09:21] <__T> so last declared value will be returned?

[09:21] <timotimo> yes

[09:22] <timotimo> you can annotate a function with "returns Nil" or "--> Nil" to make it not return anything

[09:22] <DrForr> __T: How'd you run across Perl 6? Just curious.

[09:22] <__T> ah yes, thats different from python

[09:22] <__T> I started with Perl 5 long time ago

[09:22] <__T> then I needed to use Python, and now i work with python

[09:23] <__T> But I always loved Perl

[09:23] <__T> I try to use perl 5 one liners as much as possible  in my workflow

[09:23] <__T> so I kept following the progress of perl6

[09:24] *** TheovdH left
[09:24] <moritz> so have I :-)

[09:24] <__T> Python is really nice, but it's also boring :D

[09:25] <__T> I like list comprehensions and dict comprehensions in Python

[09:25] <__T> and ofcourse the whole Class system

[09:25] * moritz finds python classes underpowered

[09:25] <__T> yes

[09:25] <__T> its true, but for my relatively simple tasks its enought

[09:25] <arnsholt> List comprehensions are just map and grep =)

[09:26] <__T> i know

[09:26] <__T> but without many keywords, i like it

[09:26] <__T> its just hard to convince my collegues Perl6 is promising

[09:27] <arnsholt> moritz: Having looked at how they work internally, I find them a bit weird TBH =)

[09:28] <__T> how fast is regex now?

[09:28] <__T> i used perl6 regex last year

[09:28] <__T> it was very slow

[09:29] <timotimo> depends on how you use it

[09:29] <timotimo> we've just had a few major speed-ups with functions surrounding regex, but the regex match itself is still not the fastest

[09:29] <__T> perhaps I used it wrongly :D

[09:29] <timotimo> i wouldn't call it "wrong"; you'll just be able to find very fast shortcuts for many things if you really know a lot about performance in perl6

[09:30] <timotimo> we're working on it, of course

[09:30] <__T> I remember it was quite simple regex, just matching IP adresses over a list of lines

[09:30] *** llfourn left
[09:30] <__T> so what is your role timo?

[09:30] <[ptc]> RabidGravy: just ran across Test::META.  Cool stuff!  The docs mention the TEST_AUTHOR env var; shouldn't that be AUTHOR_TESTING to be consistent with roughly standard P5 usage?  E.g. in Dist::Zilla etc?

[09:31] *** jnthn joined
[09:34] *** aborazmeh left
[09:34] *** Actualeyes left
[09:37] *** pdcawley left
[09:40] <timotimo> __T: i'm working on MoarVM and perl6 in general

[09:41] <timotimo> i'm interested in getting perl6 faster and making it use less memory

[09:41] <timotimo> not terribly good at it, though

[09:41] <__T> well, i'm glad someone is doing that job :D

[09:41] *** llfourn joined
[09:41] <timotimo> many more than me are involved :)

[09:42] *** Sqirrel left
[09:43] <__T> btw, will there be a Learning Perl 6 book coming out?

[09:43] <__T> preferably without butterfly cover

[09:43] <__T> or Programming Perl 6

[09:43] <timotimo> multiple books are in the works, i don't know when the first one will be finished

[09:43] <__T> nice

[09:44] <__T> you're proofreader?

[09:44] <DrForr> Yes. I can't quite say when, but there are books in the works.

[09:44] <moritz> __T: I'm creating a mailing list with updates on p6 books

[09:44] <moritz> __T: if you want in, /msg me your email address

[09:45] <timotimo> i've got a review copy of one book, but i've been procrastinating continuing it :(

[09:46] <__T> i would love to receive review copies, but my perl6 knowledges is probably not good enought to be of any use.

[09:46] <__T> so i will be typical bookbuyer

[09:47] *** TheovdH joined
[09:47] <__T> moritz did you receive my message

[09:47] <moritz> __T: yes

[09:55] *** zakharyas left
[09:55] *** zakharyas joined
[09:56] *** labster left
[10:01] *** pdcawley joined
[10:03] *** huf joined
[10:08] *** TEttinger left
[10:09] *** pdcawley left
[10:10] *** Zoffix joined
[10:10] <Zoffix> Ah right, I went straight to ACCEPTS and didn't check the ~~ with sourceable

[10:10] <yoleaux> 08:38Z <lizmat> Zoffix: the difference between my $a = rx/foo/; "foo" ~~ $a   and  "foo" ~~ /foo/ is in the codegen: the former goes through multi sub infix:<~~>(Mu \topic, Mu \matcher), which Boolifies the result

[10:11] <Zoffix> s: &infix:<~~>, \(my $a = rx/foo/, 'foo')

[10:11] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/a1fceeb/src/core/Mu.pm#L809

[10:11] <Zoffix> s: &infix:<~~>, \(/foo/, 'foo')

[10:11] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/a1fceeb/src/core/Mu.pm#L809

[10:11] <Zoffix> :/

[10:11] <Zoffix> s: &infix:<~~>, \('foo', my $a = rx/foo/)

[10:11] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/a1fceeb/src/core/Mu.pm#L809

[10:11] <Zoffix> s: &infix:<~~>, \('foo', /foo/)

[10:11] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/a1fceeb/src/core/Mu.pm#L809

[10:11] <DrForr> Zoffix: Thanks, threw your PRs in.

[10:11] <Zoffix> ¯\_(ツ)_/¯

[10:11] *** zakharyas left
[10:12] <Zoffix> Oh well... lizmat++ for fix

[10:12] *** Zoffix left
[10:12] *** bpmedley joined
[10:16] <[ptc]> Zoffix++: thanks for the PR!  I don't often PRs on projects of my own :-)

[10:18] *** araujo joined
[10:18] *** araujo left
[10:18] *** araujo joined
[10:19] *** araujo left
[10:20] *** araujo joined
[10:24] *** amalia_ left
[10:27] *** amalia_ joined
[10:29] *** arnsholt left
[10:30] <dalek> doc: eb172c0 | paultcochrane++ | doc/Language/modules.pod6:

[10:30] <dalek> doc: Link to full META spec in modules docs

[10:30] <dalek> doc: review: https://github.com/perl6/doc/commit/eb172c0d1f

[10:42] *** bjz joined
[10:44] * lizmat is back

[10:44] <lizmat> investigating some spectest breakage

[10:44] *** eliasr joined
[10:45] <viki> [ptc]: RabidGravy AUTHOR_TESTING is also what our Test::When looks for: https://github.com/zoffixznet/perl6-Test-When#author

[10:46] <dalek> doc: 758bcb8 | paultcochrane++ | doc/Language/modules.pod6:

[10:46] <dalek> doc: Link directly to META6 section

[10:46] <dalek> doc: 

[10:46] <dalek> doc: ... which takes the user more directly to the required information.

[10:46] <dalek> doc: review: https://github.com/perl6/doc/commit/758bcb8db5

[10:47] *** pierre_ left
[10:48] *** smash_ is now known as smash

[10:50] *** arnsholt joined
[10:54] <[ptc]> viki, RabidGravy: yeah, I was thinking about the consistency of that env var, and whether or not a patch to the Test::META docs was in order

[10:54] *** salva00 left
[11:00] *** llfourn left
[11:01] *** kaare__ joined
[11:03] *** k-man left
[11:05] *** salva00 joined
[11:07] *** bjz left
[11:10] *** k-man joined
[11:14] *** k-man left
[11:15] *** k-man joined
[11:16] *** itaipu joined
[11:22] *** rurban left
[11:23] *** vendethiel left
[11:23] *** Actualeyes joined
[11:23] *** bjz joined
[11:30] <skrshn> regex q

[11:30] <skrshn> m:"1234" ~~ /<:N - [12]>+/ && say $/;

[11:31] <skrshn> p6: "1234" ~~ /<:N - [12]>+/ && say $/;

[11:31] <camelia> rakudo-moar 5ac593: OUTPUT«｢34｣␤»

[11:31] <skrshn> p6: "1234" ~~ /<-:N - [12]>+/ && say $/;

[11:31] <camelia> rakudo-moar 5ac593: ( no output )

[11:31] <skrshn> I want to negate the (:N - [12]) set

[11:33] *** __T left
[11:36] *** stux|RC-only joined
[11:40] *** AlexDaniel joined
[11:46] <viki> m: say "1234" ~~ /<+:N - [12]>+/

[11:46] <camelia> rakudo-moar 5ac593: OUTPUT«｢34｣␤»

[11:46] <viki> m: say "1234" ~~ /<-:N + [12]>+/

[11:46] <camelia> rakudo-moar 5ac593: OUTPUT«｢12｣␤»

[11:54] <skrshn> viki: thanks. how do I interpret (-:N + [12])?

[11:55] <skrshn> I earlier thought that <-...> would negate whatever set is in ...

[11:56] <moritz> m: say 'a' ~~ /<-:N>/

[11:56] <camelia> rakudo-moar 5ac593: OUTPUT«｢a｣␤»

[11:56] <moritz> skrshn: seems to be parsed as (-:N) + [12]

[11:56] <viki> skrshn: < > umm... "contains regex things"... -:N regex thing negates :N   +:N regex thing adds it in. So -:N negates all :N and +[12] brings 12 back in

[11:57] <viki> .oO( thingies! )

[11:59] *** jantore joined
[11:59] <skrshn> so the process of building the set matters

[12:00] <moritz> it's just like in

[12:00] <moritz> m: say -5 + 2

[12:00] <camelia> rakudo-moar 5ac593: OUTPUT«-3␤»

[12:00] <skrshn> for instance, <-:N + [12]> is different from <[12] - :N>

[12:00] <skrshn> moritz: i don't think so

[12:00] <skrshn> -5 + 2 == 2 - 5

[12:01] <moritz> skrshn: right

[12:01] *** Irev joined
[12:01] <Irev> Is Perl6 better and more modern than Perl 5?

[12:01] <moritz> skrshn: but it kinda still makes sense; you start from [12], and then subtract all numeric letters

[12:02] <viki> Irev: yes

[12:02] <AlexDaniel> and not like… -5 ** 2… :P

[12:02] <Irev> viki, is it also the future of Perl?

[12:02] <AlexDaniel> Irev: actually, define “better”

[12:02] <AlexDaniel> and also “modern”

[12:02] <viki> Irev: I don't have a chrystal ball. Perl 5 is in active development and does get new features.

[12:03] <Irev> AlexDaniel, you know, generally better and worth learning more than Perl 5

[12:03] <AlexDaniel> Irev: it depends on your needs

[12:03] <AlexDaniel> Irev: for example, right now performance is significantly better in perl 5, generally

[12:03] <Irev> AlexDaniel, I just want to get more skilss

[12:03] <skrshn> moritz: kinda. But the way I think it would be better to start with an empty set and start adding things to it

[12:03] <viki> Irev: so learn both

[12:03] <Irev> *skills not for job, but for fun and doing crazy things

[12:03] <viki> Irev: then Perl 6

[12:04] <skrshn> in doing <-:N>, you are adding everything to the empty set except the nubmers

[12:04] <viki> Irev: Perl 5 is more performant and there are more jobs for it. Perl 6 has saner features IMO. You can still get them in Perl 5, but they feel like hacks over the core language.

[12:04] <skrshn> after that, <-:N + [12]>, you would be adding [12] to that resulting set

[12:05] <viki> Irev: and I'm obviously biased in my opinions. Hence my suggestion to try both and see which one fits your brain better.

[12:05] <Irev> what are the relation perl6.org and rakudo.org ?

[12:05] <viki> Irev: Perl 6 is the language. Rakudo is one of the compilers.

[12:05] <viki> Irev: kinda like the relation between C and gcc

[12:05] <Irev> viki, so Rakudo is a major implementation?

[12:06] <viki> Irev: it's the most complete and to my knowledge the only one currently actively maintained

[12:06] <Irev> viki, is it a compiler or JIT?

[12:06] <Irev> A compiler like GCC?

[12:06] <viki> Irev: it compiles to a VM bytecode

[12:06] <avalenn> what is the better way to use perl6 and panda in Debian (testing) for now ?

[12:07] <AlexDaniel> avalenn: eh, well… I use rakudobrew…

[12:07] <viki> avalenn: Rakudo Star: http://rakudo.org/downloads/star/

[12:07] <moritz> avalenn: docker pull mj41/perl6-star; docker run -v $PWD:/perl6 -w /perl6 -it mj41/perl6-star panda ...

[12:07] <skrshn> +1 for rakudobrew

[12:07] <viki> -1 for rakudobrew

[12:07] <viki> It's not for end users.

[12:07] <[ptc]> avalenn: there are very up-to-date packages for moarvm, nqp and rakudo available in Debian testing

[12:07] <avalenn> Ok. I tried to use packaged rakudo and it's fine but for the lack of panda.

[12:07] <Irev> viki, why so many people say that programs in Perl are non-maintainable and is like write a program and then throw it away?

[12:08] <AlexDaniel> avalenn: generally, the answer would be to get rakudo from repos and install panda somehow on top

[12:08] <[ptc]> I believe 2016.09 is the current, most up to date version

[12:08] <AlexDaniel> avalenn: however, upcoming debian freezes will probably invalidate that option rather quickly

[12:08] <viki> avalenn: well, first, I'd recommend using zef instead of panda. And if you read its docs, it tells you how to install it: http://modules.perl6.org/repo/zef

[12:08] <DrForr> Irev: Because they haven't seen cleanly written Perl code, usually.

[12:08] <viki> [ptc]: nope, 2016.10

[12:08] <AlexDaniel> avalenn: and rakudo is evolving a bit too fast at this moment

[12:08] <moritz> I've thought long about how to give instructions for running rakudo in my book, keeping it minimal

[12:08] <[ptc]> viki: oh, wow, cool!

[12:09] <moritz> and I've decided do recommend docker, because it's so few commands, and works pretty much independent of the host

[12:09] <avalenn> I would be interested on up-to-date rakudo packages in Debian experimental, but I am not ready to do them myself.

[12:09] <AlexDaniel> /o\ docker

[12:09] <Irev> viki, well, I like to give it a try. so which book is suitable for a beginner like me? I know some about computer hardware and software and networks

[12:09] <viki> Irev: it's easy to write really shitty code in Perl 5. You get enough idiots writing crap, then of course, there will be crap. In my experience, people who say those things haven't seen Perl code for decades and a lot have changed since then.

[12:09] <AlexDaniel> avalenn: well, I've been using debian unstable for years

[12:10] <moritz> AlexDaniel: there's no compulsion to use it; it's just a convenient way

[12:10] <viki> Irev: I don't think there are any up-to-date books for Perl 6 yet (we've just released last December). You can start with "For Newcomers" section here: http://perl6.org/resources/

[12:10] <DrForr> Yet.

[12:11] <viki> Yeah, there are a couple in the works.

[12:11] <AlexDaniel> avalenn: now regarding rakudo star, if you're serious about development in perl 6 then there's a high chance that rakudo star will not do it for you… You will face bugs and will need latest bug fixes

[12:11] <moritz> Irev: fwiw I'm starting a mailing list with updates on various Perl 6 book projects. If you want in, /msg me your email address (and optionally first name)

[12:11] <viki> avalenn: oh!

[12:12] <viki> avalenn: wait, El_Che++ has been building packages. 1 sec

[12:12] <AlexDaniel> avalenn: so I'm not sure where all these anti rakudobrew people come from, like, are they real? :) rakudobrew is not meant for anything, yeah, but other solutions just don't cut it.

[12:12] <AlexDaniel> ah, El_Che packages!

[12:12] <moritz> https://github.com/nxadm/rakudo-pkg/releases/tag/2016.10

[12:12] <viki> Yeah https://github.com/nxadm/rakudo-pkg/releases

[12:12] <moritz> debian packages for 2016.10

[12:12] * moritz faster this time

[12:12] <AlexDaniel> yes, that's probably the best solution right now

[12:13] <viki> AlexDaniel: I've seen enough people with rakudobrew installations who don't know wtf they're doing, get issues, and then complain that Perl 6 is broken crap.

[12:13] <viki> rakudobrew is not for regular end users

[12:13] <viki> You have to rehash with binaries, for one.

[12:13] <avalenn> viki: rehash ?

[12:14] <viki> avalenn: rakudobrew has a rehash command.

[12:14] <moritz> is there a nice rakudo + zef docker image somewhere?

[12:14] *** Irev left
[12:14] <skrshn> why is zef better than panda?

[12:14] <viki> skrshn: more actively developed

[12:15] <viki> skrshn: https://github.com/perl6/doc/issues/894#issuecomment-249450054

[12:15] <avalenn> Ok. I will settle for rakudobrew with zef for now.

[12:16] <viki> heh

[12:16] <[ptc]> viki: should we be using zef rather than panda in the travis builds then?

[12:17] <[ptc]> viki: at present Travis uses build-panda and then the user can use panda to install the deps as required

[12:17] <viki> people getting dev work that hasn't been tested and don't know enough to update their installation... another -1 for rakudobrew. I think it was jkramer that came with that issue when a commit broke precomp and they managed to install that version.

[12:18] <skrshn> viki: tx

[12:19] <avalenn> viki: thx for the recommendation, I will keep this in my head if I have problems with rakudobrew

[12:20] <viki> And here's another person poo-pooing Perl 6, and I suspect their messing around with rakudobrew just exacerbated their original issue: https://www.reddit.com/r/perl6/comments/56qy7w/panda_problems/d8n58jf/

[12:21] <viki> avalenn: personally, I have `update-perl6` alias set to this: rm -fr ~/.zef; rm -fr ~/.perl6; rm -fr ~/.rakudobrew/; git clone https://github.com/tadzik/rakudobrew ~/.rakudobrew; rakudobrew build moar; rakudobrew build zef; zef --install A::List Of::The Modules::I::Use;

[12:22] <viki> avalenn: so far, worked like a charm for me to get bleed Perl 6 on my boxes

[12:22] <AlexDaniel> except that you have to maintain the list of packages you use

[12:22] <viki> avalenn: that does use rakudobrew, but it nukes everything on each update

[12:23] <viki> buggable: eco

[12:23] <buggable> viki, Out of 739 Ecosystem dists, 247 have warnings and 0 have errors. See https://modules.perl6.org/update.log for details

[12:23] <tadzik> . o O ( rakudbrew set autonuke )

[12:25] <viki> [ptc]: ¯\_(ツ)_/¯ 

[12:25] *** rurban joined
[12:26] *** mxco86 left
[12:26] *** mxco86 joined
[12:28] <viki> tadzik: you have a bunch of unmerged PRs BTW: https://github.com/issues?utf8=%E2%9C%93&q=is%3Apr+author%3Azoffixznet+user%3Atadzik+is%3Aopen

[12:28] <tadzik> oh wow, indeed

[12:29] <tbrowder>  /msg moritz please add me to yr book list [email@hidden.address] Tom

[12:30] * viki snikers

[12:30] <viki> Good thing it wasn't top secret info :)

[12:30] <viki>  /msg moritz the nukclear code is SDG-D4343-D

[12:31] <DrForr> That's the same conde I use on my luggage!

[12:31] <tadzik>  /msg nickserv identify sexytadzik123

[12:31] <[ptc]> and that's my root password!

[12:33] <moritz> tbrowder: added

[12:33] <moritz> wow, four subscribers before I even put up the signup form

[12:35] <tbrowder> ok, why didn't /msg work? that's what freenode help said

[12:35] <viki> moritz: did samcv give you theirs?

[12:35] <viki> tbrowder: you had a space before the /

[12:36] <tbrowder> ah, thanks, i'll try to remember not to send any secrets that way

[12:37] <AlexDaniel> by the way, if anybody wants somebody to read through their stuff (e.g. book), feel free to ping me

[12:38] <AlexDaniel> I'm not a native speaker, so no help with the language, but you'll get a hundred of other notes :P

[12:38] <viki> tbrowder: you can also use /query to first query a person and then you'd be typing in their window

[12:40] <moritz> AlexDaniel: I'll keep that in mind, thanks

[12:46] <AlexDaniel> yea, /query first

[12:46] *** pierre_ joined
[12:56] <tbrowder> thanks for the hint

[12:58] *** bjz left
[12:58] *** stigo left
[12:59] *** bjz joined
[12:59] *** stigo joined
[13:00] *** wamba left
[13:01] <AlexDaniel> bwahahahah :D

[13:02] <AlexDaniel> “-1  **   2” as an example

[13:02] <viki> ?

[13:02] <viki> It's -1

[13:02] <AlexDaniel> no, but the use of two spaces

[13:02] <AlexDaniel> that's a good joke :)

[13:02] <viki> m: say -1  **   2

[13:02] <camelia> rakudo-moar e4dc8b: OUTPUT«-1␤»

[13:02] * viki doesn't get the joke

[13:03] <AlexDaniel> viki: https://github.com/perl6/doc/issues/971#issuecomment-256633870

[13:03] *** wamba joined
[13:03] * viki is reminded that it was a good idea to unsub from doc Issues

[13:04] <viki> m: say -1²

[13:04] <camelia> rakudo-moar e4dc8b: OUTPUT«-1␤»

[13:05] <lizmat> eh, yuk ?

[13:05] <lizmat> ah, precedence ?

[13:05] <lizmat> m:  say (-1)²

[13:05] <camelia> rakudo-moar e4dc8b: OUTPUT«1␤»

[13:05] <viki> -1 on "Perhaps -x ** y should produce an error telling you to use parens to disambiguate."

[13:06] *** grondilu joined
[13:06] *** domidumont left
[13:07] <viki> It's basic math.  x² - y² is not x² + (-y)²

[13:07] <viki> Perl 6's behaviour makes perfect sense to me.

[13:07] <AlexDaniel> lizmat: ok, if this made you go “eh, yuk ?” then all this holy war is probably justified… :)

[13:07] <AlexDaniel> viki: actually…

[13:07] *** domidumont joined
[13:07] <viki> AlexDaniel: yes?

[13:07] <DrForr> PEMDAS doesn't care about negative values :)

[13:07] <AlexDaniel> viki: aren't you comparing infix - with a prefix one?

[13:09] <viki> AlexDaniel: -1² is 0 - 1², as far as I'm concerned.

[13:10] <viki> Making -1² behave differently than 0 - 1² would be fine sample of insanity

[13:10] <AlexDaniel> m: say &prefix:<->

[13:10] <camelia> rakudo-moar e4dc8b: OUTPUT«sub prefix:<-> ($?) { #`(Sub+{<anon|53968992>}+{Precedence}|52990496) ... }␤»

[13:12] <AlexDaniel> I mean, if your definition of sanity is to imply a zero whenever you see a prefix operator, then fine, I guess…

[13:13] <jnthn> Folks can holy war all they want, but the chances of us changing the precedence of basic operators now is close to zero.

[13:13] <viki> AlexDaniel: my definition of sanity is sane mathematical operations. -1² giving 1 while at the same time 0 - 1² giving -1 is insane.

[13:13] <viki> jnthn++

[13:14] * viki can now do better things :)

[13:14] <DrForr> "You were entitled to make suggestions at the appropriate time."

[13:14] *** skrshn left
[13:14] <AlexDaniel> jnthn: yeah, the old “we are not changing anything” idea, even though factually we do it all the time. But still, what do you think about making it give a warning?

[13:15] <viki> Why? What point is the warning? It will just annoying anyone who spent 2 seconds to learn proper precedence.

[13:15] <moritz> AlexDaniel: we change stuff, but the more fundamental it is, the less likely we are to change it

[13:15] <jnthn> What moritz said

[13:15] <grondilu> -1² should not give one.  The exponent takes precedence over the minus prefix

[13:16] <moritz> but do we parse it as an exponent?

[13:16] <moritz> or as part of the number?

[13:17] <viki> it parses into the ** op

[13:17] <grondilu> wasn't that discussed few days ago already?

[13:17] <moritz> m: say -1²

[13:17] <camelia> rakudo-moar e4dc8b: OUTPUT«-1␤»

[13:17] <AlexDaniel> ok, I get it. So instead of fixing it we will just document another trap in the documentation. That's actually what I proposed initially (by creating a doc issue instead of rakudobugging it), even though I strongly disagree now.

[13:18] *** ocbtec left
[13:18] <viki> AlexDaniel: what's your reasoning for -1² being 1? It contravenes basic rules of mathematics.

[13:18] <viki> AlexDaniel: for expecting it to be 1, I mean.

[13:18] <moritz> AlexDaniel: try entering the same expression in Mathematica, for example

[13:18] <jnthn> AlexDaniel: We do have a warning on things like ^2.map(...) iirc, so there is at least a precedent. But I'm not particularly inclined in this case, because ^2.foo will be a thinko just about all of the time, while in this case it seems the current way it is matches what a lot of people expect.

[13:19] <lizmat> m: say -1**2     # I withdraw my yuk

[13:19] <camelia> rakudo-moar e4dc8b: OUTPUT«-1␤»

[13:19] <jnthn> We'd basically force people to always parenthesize with such a warning

[13:19] <moritz> to me, all seems fine

[13:19] <AlexDaniel> if there's a -, sure?

[13:20] *** cdg joined
[13:20] * viki just now realizes ^2.map is a warning and not an exception....

[13:21] <viki> m: say quietly ^10.map: *+2

[13:21] <camelia> rakudo-moar e4dc8b: OUTPUT«Potential difficulties:␤    Precedence of ^ is looser than method call; please parenthesize␤    at <tmp>:1␤    ------> 3say quietly ^107⏏5.map: *+2␤^1␤»

[13:21] <viki> tsk tsk

[13:21] <AlexDaniel> viki: my reasoning is that people read code. And when they read it, half of them will go “yuk” when they see what actually happens. They will then “spend 2 seconds to learn “proper” precedence”, and it will be fine, but I'd much rather not allow this ambiguity to happen by giving a warning

[13:22] <grondilu> comparison with ^$n.map is a good one.  I've always found slightly annoying to have to add parens in that case.

[13:22] <AlexDaniel> anyway, to all of you who think how this makes sense so much, perhaps you can contribute to the documentation (document this trap) by showing your way of thinking to others

[13:23] <viki> AlexDaniel: and the other half of people who know math are now forced to type parentheses all the time?

[13:23] <viki> AlexDaniel: OK, I can document a trap

[13:23] <AlexDaniel> viki++

[13:23] <[Coke]> (/query) - huh. I had by habit used (/msg moritz .) in the past. 

[13:24] <AlexDaniel> [Coke]: in emacs, moritz would have to reply with . to make it pop up a new window

[13:28] *** skids joined
[13:32] <viki> .u nonbreaking space

[13:32] <yoleaux> No characters found

[13:32] <viki> .u non-breaking space

[13:32] <yoleaux> U+00A0 NO-BREAK SPACE [Zs] ( )

[13:33] <[Coke]> viki: for docs? (I finally broke down and memorized the vim sequence to insert one.)

[13:33] <moritz> Ctrl-k space space

[13:34] <dalek> doc: 5a5b428 | (Zoffix Znet)++ | doc/Language/traps.pod6:

[13:34] <dalek> doc: Document behaviour of -1² in Traps

[13:34] <dalek> doc: 

[13:34] <dalek> doc: Closes #971

[13:34] <dalek> doc: review: https://github.com/perl6/doc/commit/5a5b4284b5

[13:34] * viki used GitHub editor

[13:36] <viki> bah

[13:36] <dalek> doc: e10d6e0 | (Zoffix Znet)++ | doc/Language/traps.pod6:

[13:36] <dalek> doc: Fix output shown for say (-1)²

[13:36] <dalek> doc: review: https://github.com/perl6/doc/commit/e10d6e0f17

[13:40] *** profan joined
[13:41] <AlexDaniel> OK folks, now with that out of our way, how do we fix -Inf ?

[13:42] <AlexDaniel> m: say -∞**2

[13:42] <camelia> rakudo-moar e4dc8b: OUTPUT«-Inf␤»

[13:42] <AlexDaniel> m: say -Inf**2

[13:42] <camelia> rakudo-moar e4dc8b: OUTPUT«Inf␤»

[13:42] <grondilu> well that's surprising

[13:42] <AlexDaniel> We can add -∞ as another exception to this precedence feature

[13:43] <AlexDaniel> m: say -Inf**2

[13:43] <camelia> rakudo-moar e4dc8b: OUTPUT«Inf␤»

[13:43] <AlexDaniel> m: say - Inf**2

[13:43] <camelia> rakudo-moar e4dc8b: OUTPUT«-Inf␤»

[13:43] <AlexDaniel> but will all respect to everyone, this makes zero fucking sense…

[13:43] <viki> Yeah. It's due to -Inf being in grammar: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.nqp#L3386

[13:43] <grondilu> maybe Inf should not be allowed in arithmetic expressions

[13:43] <viki> oh god...

[13:43] <grondilu> the literal Inf I mean

[13:44] <grondilu> after all Inf**2 is *not* defined.

[13:44] <viki> Says who?

[13:44] <AlexDaniel> are you sure about that?

[13:44] <grondilu> I'm pretty sure, yes.

[13:44] * viki opens up a copy of IEEE 754-2008

[13:45] <DrForr> Well, Inf really isn't a number, inasmuch as it's not commutative for starters.

[13:46] <DrForr> Inf+1 == Inf, 1+Inf != Inf.

[13:46] <grondilu> -Inf can be allowed, but basically nothing else.

[13:47] <jnthn> I think -Inf is special-cased in the grammar.

[13:47] <jnthn> It may be more entirley historical reasons

[13:47] <viki> That's not true. IEEE defines a whole ton of operations with Inf

[13:47] <jnthn> *for

[13:47] <jnthn> m: say -Inf

[13:47] <camelia> rakudo-moar e4dc8b: OUTPUT«-Inf␤»

[13:47] <jnthn> m: say -(Inf)

[13:47] <camelia> rakudo-moar e4dc8b: OUTPUT«-Inf␤»

[13:47] <jnthn> Could just try removing the special case

[13:48] *** rudolfochrist joined
[13:48] <DrForr> I'm just speaking to the mathematical point of view - Infinity isn't something that you add or take things away from, it's the size of the natural (and real) numbers.

[13:48] <viki> m: say −Inf

[13:48] <camelia> rakudo-moar e4dc8b: OUTPUT«-Inf␤»

[13:48] <viki> :)

[13:48] <viki> m: say −1²

[13:48] <camelia> rakudo-moar e4dc8b: OUTPUT«-1␤»

[13:49] <grondilu> DrForr: that's what I meant as well.

[13:49] <grondilu> but if IEEE really defines operations on it, then fair enough

[13:52] <viki> Amusingly, it doesn't appear to say what Inf**N is supposed to be. It does list -Inf/+Inf as valid domain, but no indication that overflow exceptions should be given and then deleaniates dozens of cases of Inf/NaN combinations but none for the specific case of Inf**Integer :P

[13:54] <viki> Well, section 6.1, I guess: "The behavior of infinity in floating-point arithmetic is derived from the limiting cases of real arithmetic with

[13:54] <viki> operands of arbitrarily large magnitude, when such a limit exists.

[13:54] <viki> m: say 9e99**20

[13:54] <camelia> rakudo-moar e4dc8b: OUTPUT«Inf␤»

[13:54] * viki &

[13:56] *** kurahaupo joined
[14:00] *** ugjka joined
[14:01] <dalek> doc: 9727473 | coke++ | xt/doc:

[14:01] <dalek> doc: Remove file

[14:01] <dalek> doc: 

[14:01] <dalek> doc: sample file that should not have been checked in

[14:01] <dalek> doc: review: https://github.com/perl6/doc/commit/9727473e90

[14:04] *** jonas2 left
[14:04] *** amalia_ left
[14:05] <[Coke]> m: my Pair $p2 = ('Perl' => (5, 6)); say $p2.invert

[14:05] <camelia> rakudo-moar e4dc8b: OUTPUT«(5 => Perl 6 => Perl)␤»

[14:05] <lizmat> afk&

[14:06] <viki> m: say -Inf²

[14:06] <camelia> rakudo-moar e4dc8b: OUTPUT«Inf␤»

[14:07] <viki> Yeah, removing the special case fixes -Inf², but it breaks literal -Inf in signatures, which is why I suspect it was added originally. I'll take care of it on the weekend, as part of fixing RT#129915

[14:07] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129915

[14:14] <AlexDaniel> viki++

[14:16] <viki> First sign of trouble was actually in a spectest: https://github.com/perl6/roast/commit/697b4605815fd7dacb62e04071ee3601010c841c

[14:16] <viki> Message for -Inf.Int tests for "-Inf" yet message for -∞.Int test for "Inf" :} This Zoffix guy is blind

[14:18] *** sivoais left
[14:19] <eythian> I hope there's different keywords for countable and uncountable infinities.

[14:20] <[Coke]> Nope, just one Inf in Perl 6.

[14:20] <viki> Sure. my $countable = Inf; my $uncountable = Inf but role Uncountable {}

[14:20] <viki> :}

[14:20] <eythian> but then you have to express that $uncountable > $countable

[14:21] *** bjz left
[14:21] *** Actualeyes1 joined
[14:21] <viki> easy

[14:21] *** Actualeyes left
[14:21] <viki> m: role Uncountable {}; multi infix:«>»(Inf, Uncountable) { True }; my $countable = Inf; my $uncountable = Inf but Uncountable; say $countable > $uncountable

[14:21] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[14:22] <viki> well, if you type it right, it'll give the right results :}

[14:22] <eythian> heh

[14:22] *** nicq20 joined
[14:23] <nicq20> Hello o/

[14:23] <viki> \o

[14:23] <DrForr> m: א₀ == \C

[14:23] <camelia> rakudo-moar e4dc8b: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Bogus postfix␤at <tmp>:1␤------> 3א7⏏5₀ == \C␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        statement modifier lo…»

[14:24] *** tokomer joined
[14:25] <eythian> what is \C?

[14:26] *** sivoais joined
[14:26] <DrForr> Doesn't matter, I was just riffing on the Continuum hypothesis that Zoffix was geting at :)

[14:27] <viki> m: my \א₀ = "w00t"; say א₀

[14:27] <camelia> rakudo-moar e4dc8b: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Term definition requires an initializer␤at <tmp>:1␤------> 3my \א7⏏5₀ = "w00t"; say א₀␤»

[14:27] <viki> too bad subscripts don't work

[14:27] <viki> m: my \א = "w00t"; say א

[14:27] <camelia> rakudo-moar e4dc8b: OUTPUT«w00t␤»

[14:27] <viki> m: my \term:<א₀> = "w00t"; say א₀

[14:27] <camelia> rakudo-moar e4dc8b: OUTPUT«w00t␤»

[14:28] <DrForr> . o ( m: @x₀ == 1 )

[14:28] <DrForr> Though subscripts are terribly overloaded in maths.

[14:29] <eythian> m: say ℵ₁==ℶ₁

[14:29] <camelia> rakudo-moar e4dc8b: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Bogus postfix␤at <tmp>:1␤------> 3say ℵ7⏏5₁==ℶ₁␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier␤    …»

[14:30] <eythian> I guess it remains unproven...

[14:31] <viki> m: sub term:<ℵ₁> {1}; sub term:<ℶ₁> {1}; say ℵ₁==ℶ₁

[14:31] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[14:31] <masak> well, that settles that.

[14:33] <eythian> maths: completed

[14:42] *** raiph left
[14:42] *** rudolfochrist left
[14:47] <viki> m: class al { has $.c; method Numeric { $.c } }; sub prefix:<ℵ> { al.new: :$^c }; sub infix:<**> ($, al $a1) {al.new: :c($a1.c-1) }; dd ℵ⁰ == 2**ℵ¹

[14:47] <camelia> rakudo-moar e4dc8b: OUTPUT«Bool::True␤»

[14:48] *** raiph joined
[14:51] <viki> m: class ℵ {}; sub prefix:<ℵ> { +ℵ.new: :$^c }; dd ℵ⁰

[14:51] <camelia> rakudo-moar e4dc8b: OUTPUT«Memory allocation failed; could not allocate 101408 bytes␤»

[14:52] <viki> I wonder why that hangs. Wouldn't the + before ℵ make it expect a term, so it'd know to use the class and not the prefix op?

[14:52] <jnthn> No, otherwise you'd not be able to use multiple prefix ops together

[14:52] <viki> m: say +-2

[14:52] <camelia> rakudo-moar e4dc8b: OUTPUT«-2␤»

[14:53] <viki> oh, didn't realize you could

[14:53] <viki> m: say +-+-+-+-2

[14:53] <camelia> rakudo-moar e4dc8b: OUTPUT«2␤»

[14:53] <viki> haw

[14:53] <jnthn> +~$something (numify the stringification of an object) is perhaps are more useful example

[14:53] <jnthn> Or ?+$foo (boolify the numification)

[14:53] <jnthn> m: say ?'0'

[14:53] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[14:53] <jnthn> m: say ?+'0'

[14:53] <camelia> rakudo-moar e4dc8b: OUTPUT«False␤»

[14:54] *** ggoebel left
[14:56] *** ggoebel joined
[14:56] *** AlexDani` joined
[15:00] *** MorayJ joined
[15:01] *** AlexDaniel left
[15:03] *** wamba left
[15:03] *** wamba joined
[15:04] *** neuraload left
[15:06] *** snowman joined
[15:15] *** wamba left
[15:21] <avalenn> m: Buf.new(65699)

[15:21] <camelia> rakudo-moar e4dc8b: ( no output )

[15:22] <avalenn> m: say Buf.new(65599).perl

[15:22] <camelia> rakudo-moar e4dc8b: OUTPUT«Buf.new(63)␤»

[15:22] <viki> That's by design

[15:22] <viki> m: say Buf.new(256)

[15:22] <camelia> rakudo-moar e4dc8b: OUTPUT«Buf:0x<00>␤»

[15:23] <timotimo> m: say Buf[int64].new(65599).perl

[15:23] <camelia> rakudo-moar e4dc8b: OUTPUT«Buf[int64].new(65599)␤»

[15:23] <viki> :o

[15:23] <avalenn> Ok. Default Buf is 8 bits

[15:24] <avalenn> That's what I looked for. Thanks viki and timotimo

[15:24] <timotimo> YW

[15:25] *** chris2 joined
[15:27] *** AlexDani` is now known as AlexDaniel

[15:29] *** g4 left
[15:29] *** lmfjeh[m] joined
[15:43] <grondilu> how do I specify that a sub returns Nothing for nativecall?

[15:44] <grondilu> I guess I could just not put any returns trait

[15:44] <jnthn> Just don't put a returns statement

[15:44] <jnthn> *trait

[15:44] <jnthn> Right

[15:48] *** pierre_ left
[15:48] *** pierre_ joined
[15:48] *** pierre_ left
[15:48] <[Coke]> riiiiiiight

[15:52] *** tokomer left
[16:00] *** domidumont left
[16:02] <cosimo> win 30

[16:04] *** rurban2 joined
[16:05] *** rurban3 joined
[16:06] *** araujo_ joined
[16:06] * FROGGS .oO( ohh noes! he finally cloned himself! )

[16:06] *** araujo__ joined
[16:07] *** rurban left
[16:09] *** araujo left
[16:09] *** rurban2 left
[16:10] *** araujo_ left
[16:14] *** wamba joined
[16:21] <moritz> is anybody interested in doing art work for a book cover?

[16:21] <moritz> I thought of a butterfly, naturally

[16:22] <moritz> either painted, or extracted from a photograph

[16:24] *** amalia_ joined
[16:31] <gfldex> i would like to put the following into the docs but I can't decide where. Any suggestions? https://www.reddit.com/r/perl6/comments/59bqn8/you_have_to_take_what_you_can_get/

[16:32] *** domidumont joined
[16:33] *** gregf_ left
[16:35] *** canopus left
[16:36] *** Actualeyes1 left
[16:36] <ugexe> fwiw Zef has a file fetcher that can load sets of modules by encapsulating them in classes (not exporing subs)

[16:36] <ugexe> my $fetchers := self.plugins.grep(*.fetch-matcher($uri))

[16:37] *** dakkar left
[16:38] <ugexe> and the plugin/dynamic loading logic: https://github.com/ugexe/zef/blob/master/lib/Zef.pm6#L110

[16:40] <viki> m: cache

[16:40] <camelia> rakudo-moar e4dc8b: ( no output )

[16:40] <viki> TIL

[16:41] <viki> Oh, it's same as .cache :}

[16:41] <[Coke]> gfldex: how slow is the type lookup that using the $ // = makes it worth it?

[16:41] *** Actualeyes joined
[16:44] *** canopus joined
[16:46] *** nicq20 left
[16:46] *** nicq201 joined
[16:46] *** nicq201 left
[16:50] *** ocbtec joined
[16:52] *** __T joined
[16:52] <__T> hello, i have a short question

[16:52] *** wamba left
[16:53] <__T> is there a way to prevent the perl6 shell from printing out an array or lazy list i declare?

[16:53] <viki> You mean the REPL?

[16:53] *** lostinfog joined
[16:53] <viki> It always prints out the last line, unless you're producing some output yourself.

[16:53] <__T> i guess its the repl yes

[16:53] <viki> *the result of last line.

[16:54] <timotimo> you can put a ; 1 at the end of your lines

[16:54] <gfldex> [Coke]: i didn't benchmark it

[16:54] <dalek> doc: f59ad3e | gfldex++ | doc/Language/typesystem.pod6:

[16:54] <dalek> doc: doc dynamic subset

[16:54] <dalek> doc: review: https://github.com/perl6/doc/commit/f59ad3eb40

[16:54] <dalek> doc: 961c5f4 | gfldex++ | doc/Language/modules.pod6:

[16:54] <dalek> doc: link to dynamic lookup/dynamic subset

[16:54] <dalek> doc: review: https://github.com/perl6/doc/commit/961c5f4371

[16:54] <__T> if i make a lazy list

[16:54] <__T> it tries to print it right

[16:54] <viki> Really?

[16:54] <viki> __T: would you rakudobug that please.

[16:54] <viki> huggable: rakudobug

[16:54] <huggable> viki, [email@hidden.address] or use perl6 query on http://rt.perl.org ; see https://github.com/rakudo/rakudo/#reporting-bugs

[16:54] <viki> ummm...

[16:55] <viki> __T: I just tried and it prints it as simply [...]

[16:55] <__T> well not always

[16:55] <__T> very strang

[16:55] <__T> now i make 1..Inf and it doesnt

[16:55] <__T> that should be the behaviour

[16:56] <viki> __T: and what happens? It just hangs?

[16:56] <ugexe> you should show an example that *does* sometimes give incorrect behavior

[16:56] <timotimo> the .. operator gives you a Range object

[16:56] <__T> yes, but i'm just trying to make sure its not just me being silly

[16:57] <__T> triple dot forces lazy right?

[16:58] <ugexe> well if you show us the code we can tell you if its you being silly or not

[16:58] <viki> __T: tripple dot is the sequence operator.

[16:59] <viki> I do spot a different bug in REPL. The auto-print-last-expression's-value consumes Seqs and you can't use them again

[16:59] <timotimo> how is that a bug?

[16:59] <timotimo> that's exactly how Seq works

[17:00] <timotimo> you don't suggest the repl .cache every seq we come across?

[17:00] <viki> m: dd [(1…4).is-lazy, (1…∞).is-lazy]

[17:00] <camelia> rakudo-moar e4dc8b: OUTPUT«[Bool::False, Bool::True]␤»

[17:03] <viki> timotimo: I've not made use of the Seq in my code. The bug is that a diagnostic feature of the REPL is affecting my code. 

[17:03] <viki> I don't need to make any suggestions to claim that to be a bug.

[17:03] <timotimo> OK, i guess that's fair

[17:03] <gfldex> m: my $i = 1; my $start = now; $i ~~ ::('Int') for 1..10000; say now - $start; $start = now; $i ~~ Int for 1..10000; say now - $start;

[17:03] <camelia> rakudo-moar e4dc8b: OUTPUT«0.55654043␤0.00901874␤»

[17:03] <gfldex> [Coke]: ^^^

[17:03] <gfldex> i would say that is a wee bit faster :)

[17:04] <viki> m: my $s = (1…4); my $o = [$s.clone]; .say for |$o;  .say for |$s

[17:04] <camelia> rakudo-moar e4dc8b: OUTPUT«1␤2␤3␤4␤»

[17:04] <viki> s: ().Seq, 'clone', \()

[17:04] <SourceBaby> viki, Sauce is at https://github.com/rakudo/rakudo/blob/e4dc8b6/src/core/Mu.pm#L611

[17:04] <timotimo> neither the static optimizer nor the dynamic optimizer can pull the constant out of the loop there

[17:05] <gfldex> m: subset DInt where $ = ::('Int'); my $i = 1; my $start = now; $i ~~ DInt for 1..10000; say now - $start; $start = now; $i ~~ Int for 1..10000; say now - $start;

[17:05] <camelia> rakudo-moar e4dc8b: OUTPUT«0.65682002␤0.0089549␤»

[17:06] *** Actualeyes left
[17:06] *** mspo joined
[17:06] <[Coke]> gfldex: nifty. thanks.

[17:07] <gfldex> m: subset DInt where ::('Int'); my $i = 1; my $start = now; $i ~~ ($ = ::('Int')) for 1..10000; say now - $start; $start = now; $i ~~ Int for 1..10000; say now - $start;

[17:07] <camelia> rakudo-moar e4dc8b: OUTPUT«0.5601499␤0.0075087␤»

[17:08] *** Actualeyes joined
[17:08] <gfldex> m: my $i = 1; my $type = Int; my $start = now; $i ~~ $type for 1..10000; say now - $start; $start = now; $i ~~ Int for 1..10000; say now - $start;

[17:08] <camelia> rakudo-moar e4dc8b: OUTPUT«0.0112901␤0.00799491␤»

[17:08] <tbrowder> viki: should i change anything for that module with two versions?

[17:08] <dalek> perl6-most-wanted: 4f26bb0 | titsuki++ | most-wanted/bindings.md:

[17:08] <dalek> perl6-most-wanted: Make is WIP

[17:08] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/4f26bb0a7b

[17:09] <__T> so ranges arent lazy by default 

[17:09] <timotimo> ranges aren't lists, actually

[17:09] <__T> unless you assign them to a @?

[17:09] <timotimo> assigning to @ vars will .list things

[17:09] <gfldex> Range is a pair of two values

[17:10] *** kaare__ left
[17:10] <timotimo> m: my $foo = 1..10; say $foo.WHAT; my @bar = 1..10; say @bar.WHAT

[17:10] <camelia> rakudo-moar e4dc8b: OUTPUT«(Range)␤(Array)␤»

[17:11] <viki> m: use nqp; my $s = (1…4); my $o = $s.clone; nqp::bindattr(nqp::decont($o), Seq, Q|$!iter|, nqp::getattr(nqp::decont($s), Seq, Q|$!iter|).clone); .say for |$o; .say for |$s;

[17:11] <camelia> rakudo-moar e4dc8b: OUTPUT«1␤2␤3␤4␤1␤2␤3␤4␤»

[17:13] *** kaare__ joined
[17:13] *** kaare__ left
[17:14] <viki> m: dd [(1..4).is-lazy, (1..∞).is-lazy]

[17:14] <camelia> rakudo-moar e4dc8b: OUTPUT«[Bool::False, Bool::True]␤»

[17:16] *** kaare_ joined
[17:16] <dalek> doc: 9dd9ede | coke++ | doc/Language/ (2 files):

[17:16] <dalek> doc: fix spelling mistakes

[17:16] <dalek> doc: review: https://github.com/perl6/doc/commit/9dd9ede486

[17:16] <dalek> doc: 11552fe | coke++ | xt/code.pws:

[17:16] <dalek> doc: new code word

[17:16] <dalek> doc: review: https://github.com/perl6/doc/commit/11552fea69

[17:16] <[Coke]> BTW, doc folks, you can run the spell checker on individual files.

[17:19] <viki> m: subset DInt where ::("Int"); my $i = 42; $i ~~ DInt for 1..10000; say now - INIT now;

[17:19] <camelia> rakudo-moar e4dc8b: OUTPUT«0.7093227␤»

[17:19] <viki> m: subset DInt where $ = ::("Int"); my $i = 42; $i ~~ DInt for 1..10000; say now - INIT now;

[17:19] <camelia> rakudo-moar e4dc8b: OUTPUT«0.7464075␤»

[17:20] <viki> m: subset DInt where $ //= ::("Int"); my $i = 42; $i ~~ DInt for 1..10000; say now - INIT now;

[17:20] <camelia> rakudo-moar e4dc8b: OUTPUT«0.7201939␤»

[17:20] <viki> m: subset DInt where ::("Int"); my $i = 42; $i ~~ DInt for 1..10000; say now - INIT now;

[17:20] <camelia> rakudo-moar e4dc8b: OUTPUT«0.691085665␤»

[17:20] <viki> Seems the whole caching trickery just makes it slightly slower

[17:21] <lizmat> yeah, caching is a tricky business

[17:22] <__T> m: 'hello world'.say

[17:22] <camelia> rakudo-moar e4dc8b: OUTPUT«hello world␤»

[17:22] <timotimo> also depends on how spesh is able to get a handle on the thing staying the same

[17:22] *** seatek joined
[17:22] <__T> m: my @a = 1..100;?@.grep(99);

[17:22] <camelia> rakudo-moar e4dc8b: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable @.grep used where no 'self' is available␤at <tmp>:1␤------> 3my @a = 1..100;?@.grep(99)7⏏5;␤»

[17:23] <__T> m: my @ = 1..100;?@a.grep(99);

[17:23] <camelia> rakudo-moar e4dc8b: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable '@a' is not declared␤at <tmp>:1␤------> 3my @ = 1..100;?7⏏5@a.grep(99);␤»

[17:23] <__T> wtf

[17:23] <viki> lol

[17:23] <timotimo> haha :D

[17:23] <viki> m: my @a = 1..100; @a.grep(99).say;

[17:23] <camelia> rakudo-moar e4dc8b: OUTPUT«(99)␤»

[17:23] <viki> m: my @a = 1..100; @a.grep(99).so.say;

[17:23] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:23] <gfldex> m: my $type = ::("Int"); my $i = 42; $i ~~ $type for 1..10000; say now - INIT now;

[17:23] <camelia> rakudo-moar e4dc8b: OUTPUT«0.01177583␤»

[17:24] <__T> is grep the fastest wayt to check for presence in a list?

[17:24] <gfldex> there is something wrong with the `$ =` part

[17:24] <timotimo> nah

[17:24] <__T> ?@x.grep

[17:24] <viki> __T: depends on the list. We have .first too

[17:24] <viki> __T: premature optimization is the root of all evil.

[17:24] <timotimo> also, you'll want to check the .defined of the result

[17:24] <viki> m: say 99 ∈ 1..100

[17:24] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:25] <timotimo> because if you are looking for something that boolifies to False, but it's in the list, you'll get the element from .first

[17:25] <viki> m: say 99 ~~ 1..100

[17:25] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:25] <viki> That one is probably the most idiomatic way

[17:25] <timotimo> for ranges, yes

[17:25] <__T> ah the smart match

[17:26] <timotimo> for lists and arrays, no.

[17:26] <viki> Why not?

[17:26] <timotimo> because it won't do membership testing

[17:26] <viki> s: say 99 ~~ [1..100]

[17:26] <SourceBaby> viki, Something's wrong: False␤␤ERR: Cannot resolve caller sourcery(Bool); none of these signatures match:␤    ($thing, Str:D $method, Capture $c)␤    ($thing, Str:D $method)␤    (&code)␤    (&code, Capture $c)␤  in block <unit> at -e line 6␤␤

[17:26] <viki> m: say 99 ~~ [1..100]

[17:26] <camelia> rakudo-moar e4dc8b: OUTPUT«False␤»

[17:26] <viki> :(

[17:27] <timotimo> you'll need element ~~ @foo.any for that

[17:27] <viki> s: [], 'ACCEPTS', \(99)

[17:27] <viki> Robot!

[17:27] <viki> :(

[17:28] <timotimo> :o

[17:28] <viki> s: [], 'ACCEPTS', \(99)

[17:28] <viki> s: say 99 ~~ [1..100]

[17:28] <SourceBaby> viki, Sauce is at https://github.com/rakudo/rakudo/blob/e4dc8b6/src/core/List.pm#L755

[17:28] <SourceBaby> viki, Sauce is at https://github.com/rakudo/rakudo/blob/e4dc8b6/src/core/List.pm#L755

[17:28] <SourceBaby> viki, Something's wrong: False␤␤ERR: Cannot resolve caller sourcery(Bool); none of these signatures match:␤    ($thing, Str:D $method, Capture $c)␤    ($thing, Str:D $method)␤    (&code)␤    (&code, Capture $c)␤  in block <unit> at -e line 6␤␤

[17:28] *** dalek left
[17:29] *** dalek joined
[17:29] *** ChanServ sets mode: +v dalek

[17:29] <viki> I see.

[17:29] <ugexe> m: say [1..100].contains(99)

[17:29] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:30] <viki> heh

[17:30] <viki> m: say [1..100].contains("98 99")

[17:30] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:30] <__T> hmm,

[17:31] <viki> To me that feels like List needs a .contains blocker. Don't python or something or other have .contains to check membership of lists?

[17:34] <__T> m: [0..100].contains("1 2");

[17:34] <camelia> rakudo-moar e4dc8b: ( no output )

[17:35] <viki> m: say ("a"…"z").contains: "nop".comb

[17:35] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:35] <ugexe> you have to do something with it, like "say" it

[17:35] <viki> hahaha :)

[17:35] <__T> [0..100].contains("1 2").say

[17:35] <viki> __T: don't use that. It's basically an artefact of Arrays being Cool. It gets stringified into one string and then the given argument is searched in it

[17:36] <__T> m: [0..100].contains("1 2").say

[17:36] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:36] <timotimo> yeah, cool is a tiny bit wonky sometimes

[17:36] *** hankache joined
[17:36] <__T> well, i find it cool :D

[17:36] <ugexe> m: [0..100].contains(1, 2)

[17:36] <camelia> rakudo-moar e4dc8b: ( no output )

[17:36] <ugexe> m: [0..100].contains(1, 2).say

[17:36] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:36] <__T> well, i still like my grep 

[17:37] * viki likes ∈

[17:37] <viki> even though it's slower and very picky :}

[17:37] <__T> m: [0..100].grep(1).defined

[17:37] <seatek> the prong :)

[17:37] <camelia> rakudo-moar e4dc8b: ( no output )

[17:38] <__T> m: [0..100].grep(1).defined.say

[17:38] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:38] <viki> m: [0..100].grep(423423423423).defined.say

[17:38] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:38] <viki> __T: you want .so

[17:38] <viki> __T: the .defined was for .first, which returns the first element that matches

[17:38] <timotimo> yes, sorry, i should have made that more clear

[17:38] <__T> haha

[17:39] <viki> m: [0..100].first(423423423423).defined.say

[17:39] <camelia> rakudo-moar e4dc8b: OUTPUT«False␤»

[17:39] <timotimo> grep will return a list, if there's nothing you get an empty list, but that's still a defined value

[17:39] <viki> m: [0..100].first(42).defined.say

[17:39] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:39] <__T> m: [0..100].grep(999).defined.say

[17:39] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:40] <__T> m: [0..100].first(999).defined.say;

[17:40] <camelia> rakudo-moar e4dc8b: OUTPUT«False␤»

[17:40] <viki> FWIW, you can also /msg camelia    to run commands

[17:40] * viki &'

[17:40] <seatek> m: [0..100].grep(999).elems.say

[17:40] <camelia> rakudo-moar e4dc8b: OUTPUT«0␤»

[17:42] <seatek> m: [0..100].grep(34..38).elems.say

[17:42] <camelia> rakudo-moar e4dc8b: OUTPUT«5␤»

[17:49] <__T> viki:  arent set operators abit slow

[17:50] <__T> or is it efficient to first convert to set and then check for presence of an element?

[17:50] <__T> like i read in the example in the perl6doc

[17:50] <__T> m: my @a = <foo bar buzz>; say @a.Set<bar buzz>; 

[17:50] <camelia> rakudo-moar e4dc8b: OUTPUT«(True True)␤»

[17:52] <viki> __T: as I've said, premature optimization is the root of all evil. Write your code to work right first. Then find the bottle neck. Then optimize it. "a" ∈ <a b c> is short to type and fast to read. I don't care how long it takes to run when I use it.

[17:53] <viki> __T: the ∈ would convert its arguments to sets first.

[17:53] <viki> s: &infix:<∈>

[17:53] <SourceBaby> viki, Sauce is at https://github.com/rakudo/rakudo/blob/e4dc8b6/src/core/set_operators.pm#L10

[17:53] <__T> m: (0..100).Set<55>

[17:53] <camelia> rakudo-moar e4dc8b: ( no output )

[17:53] <__T> m: (0..100).Set<55>.say

[17:53] <camelia> rakudo-moar e4dc8b: OUTPUT«False␤»

[17:54] <__T> only work for string sets i guess

[17:54] <viki> m: (0..100).Set{55}.say

[17:54] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[17:55] <viki> __T: that's the "pickiness" of ∈ that I mentioned. It descerns between Int, IntStr, and Str, so 2, <2>, and "2" are different elements to it.

[17:55] <viki> and .Set<55> is looking for IntStr 55

[17:56] <__T> hmm ok

[17:57] <viki> Well, Setties, Baggies, and parametarized Maps do.... not a specialty of ∈ per say

[17:58] <viki> m: dd set 2, <2>, "2"

[17:58] <camelia> rakudo-moar e4dc8b: OUTPUT«set(IntStr.new(2, "2"),2,"2")␤»

[17:58] *** perlpilot joined
[17:58] <viki> m: my %hash{Any}; dd %hash{ 2, <2>, "2" }

[17:58] <camelia> rakudo-moar e4dc8b: OUTPUT«(Any, Any, Any)␤»

[17:59] <viki> m: my %hash{Any}; dd %hash{ 2, <2>, "2" } = (1, 2, 3); dd %hash

[17:59] <camelia> rakudo-moar e4dc8b: OUTPUT«(1, 2, 3)␤Hash[Any,Any] %hash = (my Any %{Any} = 2 => 1, IntStr.new(2, "2") => 2, "2" => 3)␤»

[18:06] *** rurban joined
[18:06] <__T> well thanks for all the examples viki :D

[18:07] <__T> i realize that perl is not very forgiving, and i like it

[18:08] *** abraxxa left
[18:10] *** rurban3 left
[18:21] *** wamba joined
[18:23] *** rurban left
[18:24] *** rurban joined
[18:24] *** rurban left
[18:26] <ugexe> its pretty darn forgiving

[18:29] <__T> it depends how you look at it

[18:29] *** MorayJ left
[18:29] *** cdg left
[18:30] <__T> perl6 will easily cheat on you

[18:30] <__T> if you're not fully informed

[18:30] <seatek> it's got a nice balance of forgiving, fascism, methodology and insanity

[18:30] <__T> haha, well said

[18:31] <__T> m: <foo bar buzz 42>.grep: Int

[18:31] <camelia> rakudo-moar e4dc8b: ( no output )

[18:31] <timotimo> m: <foo bar buzz 42>.>>.WHAT.say

[18:31] <camelia> rakudo-moar e4dc8b: OUTPUT«(List)␤»

[18:31] <timotimo> ah, yeah

[18:31] <__T> m: say <foo bar buzz 42>.grep: Int

[18:31] <camelia> rakudo-moar e4dc8b: OUTPUT«(42)␤»

[18:32] <timotimo> m: <foo bar buzz 42>.map({ $_.WHAT }).say

[18:32] <camelia> rakudo-moar e4dc8b: OUTPUT«((Str) (Str) (Str) (IntStr))␤»

[18:32] <viki> And IntStr is Int

[18:33] <__T> and Str

[18:33] <__T> m: say <foo bar buzz 42>.grep: Str

[18:33] <camelia> rakudo-moar e4dc8b: OUTPUT«(foo bar buzz 42)␤»

[18:35] <__T> IntStr is good when creating subsets, but it seems abit quirky to me

[18:35] <__T> but perhaps my fault for not being explicit

[18:36] <__T> m: say ['foo', 'bar', 'buzz', 42].grep: Str 

[18:36] <camelia> rakudo-moar e4dc8b: OUTPUT«(foo bar buzz)␤»

[18:37] *** Actualeyes left
[18:38] *** erdic joined
[18:44] *** erdic left
[18:49] <ugexe> personally i think @x.contains("foo") looks better and is easier to understand than @x.any ~~ "foo"

[18:50] <masak> ugexe: at some point a suggested way to write it was @x ~~ (*, "foo", *), too

[18:52] <__T> m: [0..100].contains("1 2").say

[18:52] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[18:53] <__T> [0..100].contains(999).say

[18:53] <__T> m: [0..100].contains(999).say

[18:53] <camelia> rakudo-moar e4dc8b: OUTPUT«False␤»

[18:54] *** dolmen_ joined
[18:55] <__T> m: [0..100].grep(999).defined.say

[18:55] <camelia> rakudo-moar e4dc8b: OUTPUT«True␤»

[18:57] <__T> m: [0..100].Set{999}.say

[18:57] <camelia> rakudo-moar e4dc8b: OUTPUT«False␤»

[18:57] <__T> TIMTOWDI

[18:57] <__T> :D

[18:58] *** erdic joined
[18:59] *** Actualeyes joined
[18:59] *** ggoebel left
[19:00] *** vendethiel joined
[19:00] *** TEttinger joined
[19:04] *** sufrostico left
[19:11] *** hankache left
[19:13] *** araujo_ joined
[19:14] *** ggoebel joined
[19:14] *** darutoko left
[19:17] *** araujo__ left
[19:19] *** erdic left
[19:22] *** itaipu left
[19:23] *** leont joined
[19:23] <leont> Why are we adding mandatory fields to the meta spec without having a version on the meta spec?

[19:24] <viki> leont: 6.c

[19:24] <leont> You miss my point

[19:24] <viki> Don't think so.

[19:24] <leont> *without having a version on the spec"

[19:25] <viki> The META spec is part of the language.

[19:26] <viki> We didn't add the "perl" field. It existed since 6.c release.

[19:27] <leont> I see

[19:27] <perlpilot> Where are the tests in roast for the META spec?

[19:28] <ugexe> the meta spec has never been finalized

[19:29] <ugexe> there is a field for the spec version, `meta`, which was added somewhat recently. but i'd prefer that to use `meta-spec` since thats what perl 5 uses

[19:29] <viki> There can be (•_•)     ( •_•)    >⌐■-■     (⌐■_■)

[19:29] <ugexe> so CPAN::Meta could parse it all the same

[19:31] <viki> perlpilot: I grepped for `provides` and `depends`. Nothing came up

[19:31] <viki> There's also this doc issue: https://github.com/perl6/doc/issues/764

[19:31] <ugexe> the previous "test" was Distribution.new(:name<xxx>)

[19:32] <ugexe> when Distribution was nothing more than a struct with required attributes

[19:36] *** domidumont left
[19:37] *** leont left
[19:46] <ugexe> m: sub validate(%meta (Str :$name!, :$auth!, :$ver!)) { %meta<provides> //= {}; %meta; }; my %meta = name => "xxx", auth => "fff", ver => 1; say validate(%meta) # this is the pattern I generally use

[19:46] <camelia> rakudo-moar e4dc8b: OUTPUT«{auth => fff, name => xxx, provides => {}, ver => 1}␤»

[19:47] *** nicq201 joined
[19:49] <ugexe> still have to handle auth/author/authority combinations, ver/version, various `depends` fields allowing arrays of alternatives, etc

[19:51] *** bjz joined
[19:55] *** wamba left
[19:56] *** cdg joined
[19:58] *** labster joined
[20:02] *** erdic joined
[20:03] *** imcsk8_P1O is now known as imcsk8_PTO

[20:11] *** mcsnolte joined
[20:19] *** erdic left
[20:19] *** stanley joined
[20:20] *** gensym joined
[20:26] <RabidGravy> boo!

[20:26] *** grondilu left
[20:29] *** itaipu joined
[20:30] *** salv0 left
[20:32] <moritz> http://blog.robertelder.org/switch-statements-statement-expressions/ I'm now afraid of C

[20:32] *** Timtico joined
[20:33] <Timtico> m: say 'Hello World';

[20:33] <camelia> rakudo-moar e4dc8b: OUTPUT«Hello World␤»

[20:36] *** Timtico left
[20:40] <viki> moritz, I think it's possible to concoct a similar thing with our given/when :)

[20:42] <viki> or rather, the first weird switch the article shows.

[20:42] <viki> (tl;dr) for the rest

[20:43] <moritz> viki: the rest is where it gets interesting :-)

[20:44] <viki> :)

[20:50] *** Ven joined
[20:52] *** erdic joined
[21:00] *** labster left
[21:01] *** labster joined
[21:03] <moritz> https://perl6book.com/ # not much there at the moment, just the mailing list signup form

[21:03] *** rurban joined
[21:04] *** __T left
[21:09] *** skids left
[21:09] *** FROGGS left
[21:11] *** FROGGS joined
[21:11] *** bjz left
[21:12] *** erdic left
[21:13] *** nicq201 left
[21:13] *** ufobat left
[21:16] *** Ven left
[21:19] <perlpilot> moritz++

[21:21] *** sftp left
[21:22] *** Actualeyes left
[21:23] *** sftp joined
[21:29] *** firstdayonthejob joined
[21:33] *** perlpilot left
[21:35] *** leont joined
[21:41] *** RabidGravy left
[21:43] *** Actualeyes joined
[21:47] *** rindolf left
[21:47] *** erdic joined
[21:51] *** espadrine joined
[21:56] *** lostinfog left
[22:06] *** espadrine left
[22:10] <stanley> moritz: any idea when it will be out for?

[22:11] *** erdic left
[22:12] <lucs> Christmas ;)

[22:14] *** dalek left
[22:14] *** dalek joined
[22:14] *** ChanServ sets mode: +v dalek

[22:15] *** itaipu left
[22:16] *** pierrot joined
[22:17] *** itaipu joined
[22:22] *** firstdayonthejob left
[22:26] *** erdic joined
[22:26] *** captain-adequate joined
[22:27] *** labster1 joined
[22:29] *** pmurias left
[22:30] *** labster left
[22:30] *** dolmen_ left
[22:32] *** TheovdH left
[22:41] <timotimo> https://twitter.com/darksuji/status/791771672114176000 - well, someone is certainly very unhappy

[22:42] * timotimo goes to bed

[22:42] <FROGGS> does that differ to other languages?

[22:45] *** labster1 is now known as labster

[22:45] *** labster left
[22:45] *** labster joined
[22:47] *** erdic left
[22:48] *** Tonik left
[22:52] *** sufrostico joined
[22:54] *** dolmen_ joined
[22:55] <seatek> say 2²

[22:55] <seatek> m: say 2²

[22:55] <camelia> rakudo-moar 8c3548: OUTPUT«4␤»

[22:55] <seatek> m: say -2²

[22:55] <camelia> rakudo-moar 8c3548: OUTPUT«-4␤»

[22:56] <seatek> m: say -(2²)

[22:56] <camelia> rakudo-moar 8c3548: OUTPUT«-4␤»

[22:56] <seatek> m: say -(2)²

[22:56] <camelia> rakudo-moar 8c3548: OUTPUT«-4␤»

[22:56] <seatek> my $x = -2; say $x²

[22:56] <seatek> m: my $x = -2; say $x²

[22:56] <camelia> rakudo-moar 8c3548: OUTPUT«4␤»

[22:56] <seatek> so the 2 isn't a 2, or the power gets precedence

[22:57] <seatek> i've run across a few weird things like that

[22:57] <seatek> i generall just curse the horrors of objects

[22:58] <awwaiid> greetings seatek. I thought you were sartak and got all excited but I accept you all the same

[22:58] <seatek> awwaiid, no not sartak, i'm pretty sure :)

[22:58] <awwaiid> hehe

[23:04] *** dolmen_ left
[23:08] *** mohae joined
[23:22] *** erdic joined
[23:28] *** kyclark joined
[23:29] <kyclark> docs (https://docs.perl6.org/language/regexes#Zero_or_more:_*) say "*" is still 0-or-more matches, but "'foobar' ~~ /o*/" returns nothing

[23:31] <MasterDuke> m: say "foobar" ~~ /o*/

[23:31] <camelia> rakudo-moar 8c3548: OUTPUT«｢｣␤»

[23:31] <MasterDuke> m: say "foobar" ~~ /o/

[23:31] <camelia> rakudo-moar 8c3548: OUTPUT«｢o｣␤»

[23:31] <MasterDuke> m: say "foobar" ~~ /o+/

[23:31] <camelia> rakudo-moar 8c3548: OUTPUT«｢oo｣␤»

[23:31] <MasterDuke> m: say "foobar" ~~ /o**0..Inf/

[23:31] <camelia> rakudo-moar 8c3548: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Malformed Range. If attempting to use variables for end points, wrap the entire range in curly braces.␤at <tmp>:1␤------> 3say "foobar" ~~ /o**0..7⏏5Inf/␤    expecting any of:␤        term␤»

[23:32] <MasterDuke> m: say "foobar" ~~ /o**0..9/

[23:32] <camelia> rakudo-moar 8c3548: OUTPUT«｢｣␤»

[23:32] <MasterDuke> m: say "foobar" ~~ /o**1..9/

[23:32] <camelia> rakudo-moar 8c3548: OUTPUT«｢oo｣␤»

[23:33] <MasterDuke> bisectable6: say "foobar" ~~ /o*/

[23:33] <bisectable6> MasterDuke, On both starting points (old=2015.12 new=5ac593e) the exit code is 0 and the output is identical as well

[23:33] <bisectable6> MasterDuke, Output on both points: ｢｣

[23:34] *** sftp left
[23:34] *** sftp_ joined
[23:35] *** erdic left
[23:35] *** sftp_ is now known as sftp

[23:36] *** erdic joined
[23:37] <MasterDuke> perl 5 does the same thing

[23:37] <MasterDuke> say $1 if "foobar" =~ /(o*)/

[23:41] *** erdic left
[23:41] <jast> btw I don't see anything wrong with the 2²-related results above. it works exactly the same way in math.

[23:42] <jast> in math, power binds more tightly than the negative sign, and so every language does it that way, too

[23:43] *** jameslenz left
[23:44] *** jameslenz joined
[23:46] <kyclark> Sorry, is this a bug then?  Do I get a cookie or something? :-)

[23:47] *** skids joined
[23:51] *** rurban left
[23:58] *** cdg left
