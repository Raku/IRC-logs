[00:02] *** mr-foobar left
[00:04] <AlexDaniel> â€œI plan to keep using Python 2.* until the sun grows cold or I die (whichever comes first.)â€ â€“ I didn't know that python 2â†’3 problem is still a thing

[00:06] <geekosaur> at this point it is not a technical problem, but a political problem

[00:07] <geekosaur> and. let's just say that the Python community created the political problem itself and seems uninterested in any solution other than increasingly shrill hoots

[00:10] *** ssotka left
[00:10] <rjbs> but it's also a technical problem

[00:12] *** cognominal left
[00:28] *** smls_ joined
[00:28] *** smls_ left
[00:28] *** smls left
[00:30] *** bjz left
[00:32] *** huggable joined
[00:32] *** pierre_ joined
[00:38] *** grassass left
[00:44] *** BenGoldberg joined
[00:50] *** BenGoldberg left
[00:54] <Xliff> geekosaur, I just started learning Python coz... calibre

[00:54] <Xliff> And that political problem sounds very similar. 

[00:54] <geekosaur> exactly

[00:54] <Xliff> Is it as bad as perl 5 â†’ 6?

[00:54] *** itaipu left
[00:55] *** bjz joined
[00:55] <geekosaur> kovid's not the only one, there are a number of others who refuse to move to python3 essentially for political reasons

[00:55] <Xliff> rjbs, how is it a technical problem?

[00:55] *** BenGoldberg joined
[00:57] <geekosaur> it's not terrible; there are even programs that will do the lion's share of it, and many projects that have successfully moved. but there are ideological differences, such as a perception that Python 3 is moving in the direction of prioritizing ease over power (I do not know enough to have a position on it, but I have heard this cited numerous times)

[00:58] *** BenGoldberg left
[01:09] *** BenGoldberg joined
[01:12] <timotimo> Xliff: how is perl5 -> 6 bad?

[01:12] <timotimo> okay, apart from people stomping around yelling "perl6 killed perl5!"

[01:13] <geekosaur> translating programs

[01:13] <geekosaur> perl6 is a significant departure

[01:17] <Xliff> timotimo, I'm talking political, not technical.

[01:18] <Xliff> Even though geekosaur has a point.

[01:18] <geekosaur> and that part I couldn't talk about because I got fed up with the perl 5 community some time back. their reaction to perl 6 is, shall we say, symptomatic

[01:21] <jdv79> m: .say for "\x2488".."\x249b" # cool

[01:21] <camelia> rakudo-moar c59e4d: OUTPUTÂ«â’ˆâ¤â’‰â¤â’Šâ¤â’‹â¤â’Œâ¤â’â¤â’â¤â’â¤â’â¤â’‘â¤â’’â¤â’“â¤â’”â¤â’•â¤â’–â¤â’—â¤â’˜â¤â’™â¤â’šâ¤â’›â¤Â»

[01:21] <jdv79> m: .say for â’ˆ..â’›  # why not the same thing?

[01:21] <camelia> rakudo-moar c59e4d: OUTPUTÂ«1â¤2â¤3â¤4â¤5â¤6â¤7â¤8â¤9â¤10â¤11â¤12â¤13â¤14â¤15â¤16â¤17â¤18â¤19â¤20â¤Â»

[01:23] <jdv79> also why do those exist and why do they stop at 20?

[01:23] <timotimo> because those are actual number literals in the second one and strings in the first one

[01:23] <jdv79> even though they represent the same glyph they are understood differently?

[01:24] <timotimo> um

[01:24] <timotimo> m: say "rand"; say rand

[01:24] <camelia> rakudo-moar c59e4d: OUTPUTÂ«randâ¤0.0296613608515009â¤Â»

[01:24] <geekosaur> if you use it as a syntactic component instead of as a string, you get its numeric value

[01:25] <timotimo> â’› is literally the same thing as 20

[01:25] <jdv79> i suppose

[01:25] <timotimo> .. cannot behave differently because it can't tell the difference

[01:26] <timotimo> whereas "\x249b" is not the same as 20

[01:26] <geekosaur> and not the same thing as "â’›" which is explicitly a string

[01:26] *** jack_rabbit left
[01:26] <jdv79> m: .say for "â’ˆ".."â’›" # ok

[01:26] <camelia> rakudo-moar c59e4d: OUTPUTÂ«â’ˆâ¤â’‰â¤â’Šâ¤â’‹â¤â’Œâ¤â’â¤â’â¤â’â¤â’â¤â’‘â¤â’’â¤â’“â¤â’”â¤â’•â¤â’–â¤â’—â¤â’˜â¤â’™â¤â’šâ¤â’›â¤Â»

[01:27] <jdv79> .say for "1".."20" # wut

[01:27] <jdv79> m: .say for "1".."20" # wut

[01:27] <camelia> rakudo-moar c59e4d: OUTPUTÂ«1â¤2â¤Â»

[01:27] <timotimo> .. with string endpoints that look like numbers seem to WAT everyone

[01:28] <geekosaur> people have been wat-ing over that for the past several days. answer is: string ranges behave in a way that only makes sense in some contexts

[01:28] *** jack_rabbit joined
[01:29] *** wamba left
[01:29] <timotimo> though i must admit the "1".."20" one WATs me, too. i only have the intuition for same-length strings

[01:32] *** kid51 joined
[01:35] <BenGoldberg> m: loop (my $x = "1"; $x le "20"; ++$x) { $x.say }

[01:35] <camelia> rakudo-moar c59e4d: OUTPUTÂ«1â¤2â¤Â»

[01:35] <timotimo> um, wouldn't ++ always be numeric?

[01:35] <BenGoldberg> Nope.

[01:35] <timotimo> OK

[01:36] <timotimo> ah, when you do it with le, that makes much more sense

[01:36] <BenGoldberg> :)

[01:37] <BenGoldberg> m: loop (my $x = "1a"; $x le "2b"; ++$x) { $x.print }

[01:37] <camelia> rakudo-moar c59e4d: OUTPUTÂ«1a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z2a2bÂ»

[01:39] <BenGoldberg> The peculiar way ++ on strings works is basically inherited from perl5.

[01:39] *** BenGoldberg left
[01:39] *** sufrostico left
[01:40] <mst> when writing something like an imap server A001 -> A999 -> B001 etc. is actually really useful

[01:40] <mst> and I'm unsure what else ++ on strings could do that would be useful ever

[01:41] <timotimo> increase the rightmost unicode codepoint by one and when you reach the end of unicode, increase the one one to the left by one and reset to \0

[01:42] *** BenGoldberg joined
[01:43] <geekosaur> the only remotely useful one is str->int,increment,int->str

[01:43] <geekosaur> other than what it does now, that is

[01:43] <sortiz> m: my $x = "file001.gif"; say ++$x; # Modulo some extension

[01:43] <camelia> rakudo-moar c59e4d: OUTPUTÂ«file002.gifâ¤Â»

[01:44] <timotimo> would you prefer file001.gig?

[01:44] <sortiz> Nope

[01:44] *** molaf left
[01:44] <timotimo> :)

[01:44] <sortiz> I like that, but was missing in you description. :)

[01:44] <timotimo> not by my description

[01:44] <sortiz> *your

[01:45] <timotimo> my description was actually insane and wrong and terrible

[01:46] <timotimo> m: .print for "\c[SNOWMAN]..\c[COMET]"

[01:46] <camelia> rakudo-moar c59e4d: OUTPUTÂ«â˜ƒ..â˜„Â»

[01:46] <timotimo> m: .print for @("\c[SNOWMAN]..\c[COMET]")

[01:46] <camelia> rakudo-moar c59e4d: OUTPUTÂ«â˜ƒ..â˜„Â»

[01:46] <timotimo> huh?

[01:46] <timotimo> m: .say for @("\c[SNOWMAN]..\c[COMET]")

[01:46] <camelia> rakudo-moar c59e4d: OUTPUTÂ«â˜ƒ..â˜„â¤Â»

[01:46] <timotimo> oh, hahaha

[01:46] <timotimo> m: .print for @("\c[SNOWMAN]".."\c[COMET]")

[01:46] <camelia> rakudo-moar c59e4d: OUTPUTÂ«â˜ƒâ˜„Â»

[01:46] <timotimo> oh, they are neighbours?

[01:46] <mst> rock beats scissors, comet beats snowman

[01:47] <timotimo> m: .say for "\c[SNOWMAN]", *.succ, ... *

[01:47] <camelia> rakudo-moar c59e4d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/oWt7zY_XPjâ¤Comma found before apparent series operator; please remove comma (or put parensâ¤    around the ... listop, or use 'fail' instead of ...)â¤at /tmp/oWt7zY_XPj:1â¤------> 3.say for "\c[SNOWMAN]",â€¦Â»

[01:47] <timotimo> m: .say for "\c[SNOWMAN]", *.succ ... *

[01:47] <timotimo> i should really go to bed, i can't even ...

[01:47] <camelia> rakudo-moar c59e4d: OUTPUTÂ«(timeout)â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â˜ƒâ¤â€¦Â»

[01:48] <timotimo> ah, that's what it does on .succ when it doesn't has a sensible successor

[01:48] <timotimo> little known fact: before the comet, snowmen actually roamed the earth free and careless

[01:48] <BenGoldberg> .u â¤â˜ƒ

[01:48] <yoleaux> U+2424 SYMBOL FOR NEWLINE [So] (â¤)

[01:48] <yoleaux> U+2603 SNOWMAN [So] (â˜ƒ)

[01:50] <mst> timotimo++

[01:50] <BenGoldberg> m: "file.gif".succ.say;

[01:50] <camelia> rakudo-moar c59e4d: OUTPUTÂ«filf.gifâ¤Â»

[01:50] <timotimo> the cradle of filf?

[01:50] <BenGoldberg> Filfy picture!

[01:51] <geekosaur> m: "file.gif".succ.succ.succ.succ.succ.succ.say

[01:51] <camelia> rakudo-moar c59e4d: OUTPUTÂ«filk.gifâ¤Â»

[01:52] <BenGoldberg> Musical picture!

[01:52] <BenGoldberg> m: ("file.gif"..*)[6].say;

[01:52] <camelia> rakudo-moar c59e4d: OUTPUTÂ«filk.gifâ¤Â»

[01:56] *** tokuhirom joined
[01:56] *** pierre_ left
[01:56] *** molaf joined
[01:58] *** pierre_ joined
[02:00] *** tokuhirom left
[02:04] *** ssotka joined
[02:04] *** pierre_ left
[02:14] *** AlexDaniel left
[02:18] *** pierre_ joined
[02:19] *** pierre_ left
[02:20] *** Xliff_ joined
[02:22] *** pierre_ joined
[02:22] *** Xliff left
[02:26] *** pierre_ left
[02:54] *** astj joined
[02:56] *** noganex_ joined
[02:58] *** kid51 left
[02:58] *** noganex left
[03:01] *** |2701 left
[03:05] <lizmat> hoelzro [Coke] : what is the issue with https://github.com/rakudo/rakudo/commit/949a7c7 exactly ?

[03:18] *** khw left
[03:29] <jdv79> m: .say for "â’ˆ".."â’›"

[03:29] <camelia> rakudo-moar c59e4d: OUTPUTÂ«â’ˆâ¤â’‰â¤â’Šâ¤â’‹â¤â’Œâ¤â’â¤â’â¤â’â¤â’â¤â’‘â¤â’’â¤â’“â¤â’”â¤â’•â¤â’–â¤â’—â¤â’˜â¤â’™â¤â’šâ¤â’›â¤Â»

[03:37] *** pierre_ joined
[03:41] *** pierre_ left
[03:45] *** pierre_ joined
[03:46] *** pierre_ left
[03:51] *** tokuhirom joined
[03:57] *** tokuhirom left
[04:01] *** cpage_ left
[04:03] *** cpage_ joined
[04:10] *** finanalyst joined
[04:23] *** BenGoldberg left
[04:23] <MadcapJake> Where is the lazy sub documented?

[04:26] <MadcapJake> oh it's not really a sub, it calls .lazy on the following value, correct?

[04:26] <Xliff_> jdv79: I do agree, that is cool. However who thought that having single characters from 1 to 20 was a thing?

[04:27] <Xliff_> Why not 1..100?

[04:28] *** BenGoldberg joined
[04:28] <geekosaur> it's unicode. best not to ask >.>

[04:28] <MadcapJake> is `lazy 1,2...*` equivalent to `(1,2...*).lazy`?

[04:31] *** jack_rabbit left
[04:31] *** jack_rabbit joined
[04:32] *** aries_liuxueyang left
[04:32] *** huggable left
[04:32] *** huggable joined
[04:33] *** aries_liuxueyang joined
[04:37] <BenGoldberg> m: (1,2...*).lazy;

[04:37] <BenGoldberg> m: (1,2...*).lazy.sau;

[04:38] <camelia> rakudo-moar c59e4d: OUTPUTÂ«(timeout)Â»

[04:38] <camelia> rakudo-moar c59e4d: OUTPUTÂ«Method 'sau' not found for invocant of class 'Seq'â¤  in block <unit> at /tmp/F0xzlWIKGI line 1â¤â¤Â»

[04:39] <MadcapJake> m: say (lazy 1, 2 ... *)

[04:39] <camelia> rakudo-moar c59e4d: OUTPUTÂ«(...)â¤Â»

[04:39] <MadcapJake> m: say (1, 2 ... *).lazy

[04:39] <camelia> rakudo-moar c59e4d: OUTPUTÂ«(...)â¤Â»

[04:39] <BenGoldberg> m: my $x = (1,2...*) but role { method lazy { 42 } }; say lazy $x

[04:39] <camelia> rakudo-moar c59e4d: OUTPUTÂ«42â¤Â»

[04:39] <BenGoldberg> m: my $x = (1,2...*) but role { method lazy { 42 } }; say $x.lazy

[04:39] <camelia> rakudo-moar c59e4d: OUTPUTÂ«42â¤Â»

[04:39] <BenGoldberg> Tada, question answered.

[04:40] <MadcapJake> huh so they really do just call the method lazy, interesting! thanks BenGoldberg!

[04:43] *** Cabanossi left
[04:44] *** Cabanossi joined
[04:48] *** neuron joined
[04:48] <neuron> Hi

[04:49] <neuron> If I want to file a bug against nativecall, should I file it against perl6 or against the 'zavolaj' modujle?

[04:49] *** rindolf joined
[04:50] <MadcapJake> neuron: https://github.com/rakudo/rakudo#reporting-bugs

[04:50] <MadcapJake> zavolaj has been integrated into rakudo and is no longer maintained as a separate module

[04:51] <neuron> MadcapJake: Thanks, that's what I wanted to hear

[04:53] *** telex left
[04:54] *** kaare_ left
[04:54] *** telex joined
[04:56] *** wgb joined
[04:58] *** pierre_ joined
[05:00] *** pierre_ left
[05:02] *** wgb left
[05:04] <MadcapJake> looking for some feedback on the generator article I've been chipping away at: https://gist.github.com/MadcapJake/2e27822561f72cdf6e93fbff10db858f

[05:04] <MadcapJake> What to add? What to shorten? What to explain more?

[05:08] *** pierre_ joined
[05:08] *** sortiz left
[05:08] *** BenGoldberg left
[05:09] <neuron> I like it

[05:09] *** kaare_ joined
[05:10] <MadcapJake> thanks! :)

[05:10] *** BenGoldberg joined
[05:14] *** kaare_ left
[05:22] <lizmat> MadcapJake: too tired to really look at it in depth, but a quick scan looks good

[05:22] <lizmat> good night, #perl6!

[05:22] <MadcapJake> night!

[05:24] *** tokuhirom joined
[05:28] *** astj left
[05:28] *** tokuhirom left
[05:29] *** kaare_ joined
[05:36] *** CIAvash joined
[05:39] *** pierre_ left
[05:41] *** skids joined
[05:42] *** CIAvash left
[05:48] *** kaare__ joined
[05:48] *** kaare_ left
[05:49] *** CIAvash joined
[05:53] *** dalek joined
[05:53] *** ChanServ sets mode: +v dalek

[05:57] *** aries_liuxueyang left
[05:59] *** edehont joined
[05:59] *** aries_liuxueyang joined
[06:00] *** neuron left
[06:03] *** BenGoldberg left
[06:04] *** mr-foobar joined
[06:05] *** kaare__ left
[06:06] *** BenGoldberg joined
[06:08] *** kaare__ joined
[06:11] *** BenGoldberg left
[06:12] *** pmurias joined
[06:12] <pmurias> hi

[06:14] *** kaare__ left
[06:16] *** kaare__ joined
[06:16] *** kaare__ left
[06:21] *** mr-foobar left
[06:24] *** mr-foobar joined
[06:31] *** matiaslina joined
[06:39] *** pierre_ joined
[06:45] *** labster left
[06:46] *** pierre_ left
[06:48] *** bjz_ joined
[06:48] *** kurahaupo left
[06:49] *** bjz left
[06:52] *** wamba joined
[06:54] *** labster joined
[07:02] *** domidumont joined
[07:06] *** domidumont left
[07:06] *** domidumont joined
[07:07] *** wamba left
[07:09] *** wamba joined
[07:12] *** skids left
[07:13] *** aries_liuxueyang left
[07:14] *** aries_liuxueyang joined
[07:16] *** edehont left
[07:17] *** _dolmen_ joined
[07:26] *** firstdayonthejob joined
[07:27] *** ssotka left
[07:28] *** bjz joined
[07:29] *** bjz_ left
[07:31] *** RabidGravy joined
[07:34] <RabidGravy> morning!

[07:35] *** Xliff_ left
[07:37] *** wamba left
[07:39] <pmurias> RabidGravy: morning

[07:39] *** matiaslina left
[07:41] *** domidumont left
[07:41] *** kaare_ joined
[07:41] <RabidGravy> harr!

[07:45] *** _dolmen_ left
[07:46] *** firstdayonthejob left
[07:54] *** aries_liuxueyang left
[07:55] *** aries_liuxueyang joined
[07:59] *** mr-foobar left
[08:09] <RabidGravy> tum ti tum

[08:13] *** darutoko joined
[08:27] <pmurias> RabidGravy: ?

[08:32] *** huggable left
[08:34] *** pierre_ joined
[08:37] *** pierre_ left
[08:40] <RabidGravy> not really waking up very quickly this morning

[08:53] *** jjido joined
[09:01] *** cognominal joined
[09:06] *** spider-mario joined
[09:21] *** xinming_ joined
[09:22] *** shmibs joined
[09:23] * RabidGravy wonders why the gtk action bar is only 1 pixel high

[09:24] <dalek> doc: 8a694d2 | (Jan-Olof Hendig)++ | doc/Type/Date.pod:

[09:24] <dalek> doc: Fixed typo, added some missing C<> tags and wrote two new examples

[09:24] <dalek> doc: review: https://github.com/perl6/doc/commit/8a694d2fd9

[09:25] *** tokuhirom joined
[09:29] <dalek> gtk-simple: 9bcd1c3 | RabidGravy++ | / (2 files):

[09:29] <dalek> gtk-simple: Add ActionBar

[09:29] <dalek> gtk-simple: 

[09:29] <dalek> gtk-simple: One widget a day :)

[09:29] <dalek> gtk-simple: review: https://github.com/perl6/gtk-simple/commit/9bcd1c3a65

[09:29] *** tokuhirom left
[09:30] *** TEttinger left
[09:34] *** cognominal left
[09:34] *** mr-foobar joined
[09:35] *** pmurias left
[09:36] *** titsuki joined
[09:38] *** jjido left
[09:40] *** pierre_ joined
[09:40] *** ecocode joined
[09:43] <titsuki> Hi. Does anyone know how to see the internal state when debugging the NativeCall bindings ?

[09:44] <titsuki> "perl6-gdb-m"doesn't seem to return useful results.

[09:45] *** pierre_ left
[09:46] <titsuki> example: https://gist.github.com/titsuki/1a501975950c1c1be6c12b433f814fe7

[09:48] *** aries_liuxueyang left
[09:55] *** cognominal joined
[09:56] <titsuki> I want to know the line where the error has occurred.

[10:04] <RabidGravy> you will need to build the library with the debugging symbols

[10:04] <RabidGravy> -g with gcc

[10:05] *** wamba joined
[10:06] <titsuki> RabidGravy: Thanks. Is this correct ? : https://gist.github.com/titsuki/15182a4d3793215e8b0fe434556040b1

[10:06] <RabidGravy> looks alright

[10:07] <titsuki> then I have already set g option

[10:09] *** labster left
[10:10] <RabidGravy> well it's not in effect

[10:10] <RabidGravy> have you deleted all the *.o files and the .so file and rebuilt since adding that?

[10:11] <titsuki> RabidGravy: I did so.

[10:11] <RabidGravy> or you're using another c compiler and the -g doesn't mean the same

[10:12] *** hankache joined
[10:13] *** aries_liuxueyang joined
[10:13] <RabidGravy> does it actually have the -g in the resulting Makefile?

[10:14] <titsuki> RabidGravy: This is the resulting Makefile https://gist.github.com/titsuki/51c9ed6efbe72d7cf3006897d5af402c

[10:14] <titsuki> It contains g option.

[10:17] <hankache> hello #perl6

[10:17] <RabidGravy> erp

[10:18] <titsuki> and I use a common gcc compiler https://gist.github.com/titsuki/83c5e2bd2564d7f19943a2956bb724f3

[10:19] *** jjido joined
[10:22] <dalek> gtk-simple: f8eb045 | azawawi++ | examples/0 (4 files):

[10:22] <dalek> gtk-simple: Add missing `use v6; use lib 'lib'` to examples

[10:22] <dalek> gtk-simple: review: https://github.com/perl6/gtk-simple/commit/f8eb0453fc

[10:26] <RabidGravy> titsuki, dunno then, it should have the debug information - the only remaining possibility is that you are loading a different version of the .so without the debug information

[10:28] *** jjido left
[10:31] <titsuki> RabidGravy: I see. Thanks for the reply !

[10:32] *** jjido_ joined
[10:38] *** kaare_ left
[10:38] *** kid51 joined
[10:39] *** bjz_ joined
[10:41] *** bjz left
[10:43] *** cpage_ left
[10:44] *** ocbtec joined
[10:45] *** cpage_ joined
[10:54] *** pyrimidine joined
[11:03] *** jjido_ left
[11:13] <dalek> ecosystem: 3c935ad | (Francis Whittle)++ | META.list:

[11:13] <dalek> ecosystem: Add Path::Map to the ecosystem

[11:13] <dalek> ecosystem: 

[11:13] <dalek> ecosystem: Port of Path::Map from Perl5 with extended functionality.

[11:13] <dalek> ecosystem: 

[11:13] <dalek> ecosystem: See https://github.com/fjwhittle/p6-Path-Map

[11:13] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/3c935ad84c

[11:13] <dalek> ecosystem: 0f86c0e | titsuki++ | META.list:

[11:13] <dalek> ecosystem: Merge pull request #208 from fjwhittle/fjwhittle-p6-Path-Map

[11:13] <dalek> ecosystem: 

[11:13] <dalek> ecosystem: Add Path::Map to the ecosystem

[11:13] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/0f86c0e3d8

[11:14] *** buharin joined
[11:22] *** jjido joined
[11:26] *** jjido left
[11:38] *** jjido joined
[11:38] *** tbrowder joined
[11:42] <tbrowder> good morning perl 6 people

[11:46] *** jjido left
[11:49] *** jjido joined
[11:49] <tbrowder> question about testing: is there currently a way to declare tests that are (1) expected to fail and (2) unexpectedly pass. the use case I am thinking about is for adding time tests to roast.

[11:50] <psch> tbrowder: look for "todo" in t/spec

[11:51] <psch> tbrowder: specifically e.g. "#?rakudo todo reason here"

[11:51] <psch> well, more specifically - i don't think we have a todo with reason "reason here" :)

[11:52] *** jjido left
[12:00] <masak> isn't "todo" for tests that expectedly fail but *don't* unexpectedly pass?

[12:00] <tbrowder> I  was thinking of something on the order of the XFAIL tests of gcc, but it looks like that could be done by just adding another test series (sub dir) of expected failures where the user could be alerted if one or more passed, correct?

[12:01] <psch> masak: i think you're right, and i misunderstood tbrowder's question

[12:01] <tbrowder> psch: what repo is t/spec in?

[12:01] <psch> like, i seem to have added a 'might' in (2), but on closer inspection that's not really there :)

[12:02] <psch> tbrowder: that's where 'make spectest' puts roast

[12:04] *** aries_liuxueyang left
[12:05] <tbrowder> i don't see t/spec in rakudo or roast

[12:05] *** aries_liuxueyang joined
[12:06] *** jjido joined
[12:06] <psch> tbrowder: when you run 'make spectest' inside the rakudo repository, the makefile downloads perl6/roast into the local folder t/spec

[12:07] <psch> tbrowder: sorry for being confusing... :)

[12:08] <psch> https://github.com/perl6/roast/blob/master/S06-traits/precedence.t#L19 is one example

[12:08] <psch> but i think masak++ is right and that's not quite what you're looking for

[12:09] <psch> fwiw, i don't think defining the Perl 6 specification in terms of "this bit should just not work in whatever way, and if it works something is wrong" seems sensible

[12:09] *** hankache left
[12:09] <psch> but well, i am having trouble thinking of an example, so there :)

[12:12] <tbrowder> psch: thanks, i've only run roast outside rakudo and haven't really looked hard at it. i just thought of the timing thing upon reading of the latest rakudo release and how i am going to run my own timing tests i have used since the Christmas release

[12:12] <psch> tbrowder: did you look at p6bench?  i think we could use someone to involve themselves with that... :)

[12:13] <psch> https://github.com/japhb/perl6-bench

[12:14] <tbrowder> my tests are at github.com/tbrowder/perl6-read-write-tests

[12:18] <tbrowder> i have looked at p6 bench before and intended to run it on one of my servers but haven't yet gotten a round TOIT. my test is very simple and pragmatic for my typical use case. i also have a non-working native call version in the works to see if the rw can be improved

[12:20] <psch> http://doc.perl6.org/language/testing#Skipping_tests is how to use todo outside of roast, fwiw

[12:30] *** Ven joined
[12:32] *** huggable joined
[12:38] *** tbrowder left
[12:42] *** hankache joined
[12:43] <hankache> m: use Test; is-approx 2, 2, 'Two is equal to two';

[12:43] <camelia> rakudo-moar 4f046d: OUTPUTÂ«ok 1 - Two is equal to twoâ¤Â»

[12:43] <hankache> m: use Test; is-approx 2, 2;

[12:43] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Absolute tolerance must be a positive number greater than zeroâ¤  in sub is-approx at /home/camelia/rakudo-m-inst-2/share/perl6/sources/C712FE6969F786C9380D643DF17E85D06868219E (Test) line 251â¤  in block <unit> at /tmp/L8iAhr7H3y line 1â¤â¤Â»

[12:43] <hankache> This is misleading ^^

[12:44] <hankache> The doc https://doc.perl6.org/language/testing states that is-approx signature is either is-approx($value, $expected, $description?) or is-deeply($value, $expected, $description?)

[12:45] *** domidumont joined
[12:45] <hankache> so if you use the first signature and omit a description it doesn't work and expects a tolerance 

[12:46] <hankache> sorry the 2 signatures are: is-approx($value, $expected, $description?) and is-approx($value, $expected, $tol, $description?)

[12:46] <psch> m: use Test; is-approx 2, 2, :1abs_tol

[12:46] <camelia> rakudo-moar 4f046d: OUTPUTÂ«ok 1 - â¤Â»

[12:46] <hankache> who's wrong in this case the doc or the implementation?

[12:47] <psch> hankache: the is-approx candidates are a mess, imo :/

[12:48] <psch> there was a bit of discussion about this a few weeks back, but i can't find it right now

[12:48] <hankache> psch aha

[12:49] <hankache> well i just wanted to flag it. I can live with it as is, just thought maybe it's a bug or wrong doc

[12:50] <psch> i think there's just too many candidates

[12:50] <psch> m: use Test; say +&is-approx.candidates

[12:50] <camelia> rakudo-moar 4f046d: OUTPUTÂ«3â¤Â»

[12:50] <psch> m: use Test; say &is-approx.candidates

[12:50] <camelia> rakudo-moar 4f046d: OUTPUTÂ«(sub is-approx (Numeric $got, Numeric $expected, $desc = "") { #`(Sub|71995304) ... } sub is-approx (Numeric $got, Numeric $expected, Numeric $tol, $desc = "") { #`(Sub|71995456) ... } sub is-approx (Numeric $got, Numeric $expected, Numeric :$rel_tol = 1e-â€¦Â»

[12:50] <psch> the second one there just isn't useful

[12:51] <psch> m: use Test; say &is-approx.candidates[2]

[12:51] <camelia> rakudo-moar 4f046d: OUTPUTÂ«sub is-approx (Numeric $got, Numeric $expected, Numeric :$rel_tol = 1e-06, Numeric :$abs_tol = 0, :$desc = "") { #`(Sub|88281304) ... }â¤Â»

[12:52] <psch> well, maybe not "not useful", but at least breaking dispatch expectations :S

[12:53] <hankache> psch shouldn't the 1st candidate work?

[12:53] <hankache> m:  say &is-approx.candidates[0]

[12:53] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/tKhTorxkNxâ¤Undeclared routine:â¤    is-approx used at line 1â¤â¤Â»

[12:53] <psch> m: multi f($?) { "one opt" }; multi f() { "none" }; f()

[12:53] <camelia> rakudo-moar 4f046d: ( no output )

[12:53] <psch> m: multi f($?) { "one opt" }; multi f() { "none" }; say f()

[12:53] <camelia> rakudo-moar 4f046d: OUTPUTÂ«noneâ¤Â»

[12:53] <hankache> m:  use Test; say &is-approx.candidates[0]

[12:53] <camelia> rakudo-moar 4f046d: OUTPUTÂ«sub is-approx (Numeric $got, Numeric $expected, $desc = "") { #`(Sub|89001128) ... }â¤Â»

[12:53] <psch> m: multi f($,$?) { "one opt" }; multi f($) { "one" }; say f(1)

[12:53] <camelia> rakudo-moar 4f046d: OUTPUTÂ«oneâ¤Â»

[12:53] <hankache> this one ^^

[12:53] <psch> m: multi f($) { "one" }; multi f($,$?) { "one opt" }; say f(1)

[12:53] <camelia> rakudo-moar 4f046d: OUTPUTÂ«oneâ¤Â»

[12:54] <psch> m: multi f($) { "one" }; multi f($,$="") { "one opt" }; say f(1)

[12:54] <camelia> rakudo-moar 4f046d: OUTPUTÂ«oneâ¤Â»

[12:54] <psch> oh duh, got lead astray

[12:55] <psch> dispatch isn't the problem, the problem is bad invocation of something else, isn't it

[12:55] <psch> m: use Test; is-approx 2, 2;

[12:55] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Absolute tolerance must be a positive number greater than zeroâ¤  in sub is-approx at /home/camelia/rakudo-m-inst-2/share/perl6/sources/C712FE6969F786C9380D643DF17E85D06868219E (Test) line 251â¤  in block <unit> at /tmp/MPC2NxQ_m1 line 1â¤â¤Â»

[12:55] <hankache> psch no idea

[12:56] <psch> huh

[12:56] <hankache> see this should use the first candidate but it is not

[12:56] <psch> m: multi f($a, Numeric $b) { say "$b" }; multi f($a) { f($a, 1e-6) }; say f(1)

[12:56] <camelia> rakudo-moar 4f046d: OUTPUTÂ«1e-06â¤Trueâ¤Â»

[12:57] *** jjido left
[12:57] *** pierre joined
[12:57] <psch> m: say 1e-06 > 0

[12:57] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Trueâ¤Â»

[12:58] <psch> https://github.com/rakudo/rakudo/blob/nom/lib/Test.pm6#L232 is where it dies

[12:58] <psch> but it really shouldn't

[12:58] <psch> 'cause that candidate gets invoked with 1e-6

[12:58] <psch> m: say 1e-6 > 0

[12:58] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Trueâ¤Â»

[12:59] <hankache> the dispatcher is getting lost

[12:59] <psch> m: use Test; say &is-approx.candidates[2](2, 2, 1e-6)

[12:59] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Too many positionals passed; expected 2 arguments but got 3â¤  in sub is-approx at /home/camelia/rakudo-m-inst-2/share/perl6/sources/C712FE6969F786C9380D643DF17E85D06868219E (Test) line 246â¤  in block <unit> at /tmp/tF1G1bugIl line 1â¤â¤Â»

[13:00] <psch> m: use Test; say &is-approx.candidates[1](2, 2, 1e-6)

[13:00] <camelia> rakudo-moar 4f046d: OUTPUTÂ«ok 1 - â¤Trueâ¤Â»

[13:00] <psch> m: use Test; say &is-approx.candidates[0](2, 2)

[13:00] <camelia> rakudo-moar 4f046d: OUTPUTÂ«ok 1 - â¤Trueâ¤Â»

[13:00] <hankache> it should use this one https://github.com/rakudo/rakudo/blob/nom/lib/Test.pm6#L226

[13:00] *** AlexDaniel joined
[13:00] <psch> oh, right

[13:00] <psch> missed the "Absolute"

[13:00] *** buharin left
[13:01] <psch> so the actual problem is that the candidate with nameds has a default for one of its nameds that's actually wrong

[13:01] <hankache> m: use Test; is-approx 2.Num, 2.Num;

[13:01] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Absolute tolerance must be a positive number greater than zeroâ¤  in sub is-approx at /home/camelia/rakudo-m-inst-2/share/perl6/sources/C712FE6969F786C9380D643DF17E85D06868219E (Test) line 251â¤  in block <unit> at /tmp/uEjVD1TjIK line 1â¤â¤Â»

[13:01] <psch> i mean, yes, no nameds should be narrower than optional nameds

[13:01] <psch> but that's not the easy way to fix this... :)

[13:01] <psch> and besides, it'd *still* have a bad default 

[13:02] *** pierre left
[13:02] <psch> i don't know what a good default for absolute tolerance would be though vOv

[13:03] <hankache> ah i got an idea

[13:04] <hankache> how can i add a new candidate using monkey-patching?

[13:04] <hankache> maybe if you add a type to $desc (Str) it could work?

[13:06] *** pierre joined
[13:09] <psch> m: multi f(:$ = "foo") { "named with default" }; multi f() { "no params" }; say f

[13:09] <camelia> rakudo-moar 4f046d: OUTPUTÂ«named with defaultâ¤Â»

[13:09] <psch> hankache: types don't matter.  it's just that a named that has a value is narrower than no named

[13:09] <psch> which is actually reasonable, i think :)

[13:09] *** domidumont left
[13:09] <psch> hankache: the fix really is just changing the default for abs_tol

[13:10] <psch> this might even want to be a FAQ

[13:10] <psch> ...do we have a multi dispatch traps FAQ?

[13:11] <hankache> ah well adding a type to $desc doesn't solve it

[13:11] *** silug joined
[13:11] <hankache> psch if we have i'd gladly take a look at it

[13:12] *** Emeric joined
[13:13] <psch> hm, it does seem a bit too in-depth for the FAQ we have :/

[13:13] <dalek> doc: ae0a4bd | (Jan-Olof Hendig)++ | doc/Type/X/Temporal/InvalidFormat.pod:

[13:13] <dalek> doc: Added docs for X::Temporal::InvalidFormat

[13:13] <dalek> doc: review: https://github.com/perl6/doc/commit/ae0a4bd8ef

[13:16] <hankache> what would happen in the case you had these 2 candidates? is-approx(Numeric $got, Numeric $expected, :$desc = '') and is-approx(Numeric $got, Numeric $expected,Numeric :$rel_tol = 1e-6) ?

[13:17] *** CIAvash left
[13:17] *** pierre left
[13:18] <psch> m: multi is-approx(Numeric $got, Numeric $expected, :$desc = '') { "desc" }; multi is-approx(Numeric $got, Numeric $expected,Numeric :$rel_tol = 1e-6) { "rel-tol" }; say is-approx 1, 1

[13:18] <camelia> rakudo-moar 4f046d: OUTPUTÂ«descâ¤Â»

[13:18] *** bjz_ left
[13:18] <psch> m: multi is-approx(Numeric $got, Numeric $expected,Numeric :$rel_tol = 1e-6) { "rel-tol" }; multi is-approx(Numeric $got, Numeric $expected, :$desc = '') { "desc" }; is-approx 1, 1

[13:18] <camelia> rakudo-moar 4f046d: ( no output )

[13:18] <psch> m: multi is-approx(Numeric $got, Numeric $expected,Numeric :$rel_tol = 1e-6) { "rel-tol" }; multi is-approx(Numeric $got, Numeric $expected, :$desc = '') { "desc" }; say is-approx 1, 1

[13:18] <camelia> rakudo-moar 4f046d: OUTPUTÂ«rel-tolâ¤Â»

[13:19] <psch> hankache: falls back to order-of-declaration

[13:19] *** bjz joined
[13:19] <hankache> psch ok

[13:25] <psch> hankache: way i see it there's two solutions.  either abs_tol and rel_tol get their default values removed, or abs_tol gets a useful default

[13:25] <psch> hankache: the first case means we dispatch to the 3-param cand with 2 args, the second means the current behavior stays, but works

[13:26] *** wamba left
[13:27] <hankache> psch which one is more _sane_ ?

[13:28] <psch> well, considering the abs_tol candidate does something different i'd say the first one

[13:28] <psch> i suppose the default for rel_tol probably could stick around

[13:28] <psch> but having abs_tol without default means it's opt-in

[13:29] <psch> which is probably what was intended, and isn't currently work as such

[13:29] <hankache> aha

[13:33] *** |2701 joined
[13:34] *** Ven left
[13:39] <dalek> doc: bbe2538 | (Jan-Olof Hendig)++ | doc/Type/Signature.pod:

[13:39] <dalek> doc: Fixed broken link

[13:39] <dalek> doc: review: https://github.com/perl6/doc/commit/bbe2538618

[13:50] <masak> m: sub infix:<y->($coords, $dy) { $coords ~~ /(.*)\,(.*)/ or die "not coords"; "$0,{$1 - $dy}" }; say "4,5" y- 20

[13:50] <camelia> rakudo-moar 4f046d: OUTPUTÂ«4,-15â¤Â»

[13:50] <masak> quite possibly the weirdest custom op I've created for some real purpose.

[13:51] <psch> that's amazing :D

[13:52] <masak> part of why I needed is because I'm taking temporary shortcuts with my model

[13:52] <masak> but they make sense in the moment :)

[13:53] <MadcapJake> Looking for some input (before I publish) on my generators article: https://gist.github.com/MadcapJake/2e27822561f72cdf6e93fbff10db858f

[13:59] <psch> MadcapJake: the only thing of note is that the remark "As you can see, it is quite a bit more verbose." doesn't really seem to fit to me

[13:59] <psch> as in, i can't see that, because i don't have the same semantics with non-OO code

[14:00] <psch> hm, maybe the actual problem is that there's that long a "real-world" example suddenly at the end

[14:01] <psch> as in, everything else was just minimal and demonstrative, and then there's an example for a different concept that's muddled in a lot of not-really-related code

[14:01] <MadcapJake> yeah I just wanted to show using an Iterator/Iterable roled class.  I could make it shorter.

[14:01] <MadcapJake> Good point, I'll shorten it to something simple then.

[14:01] <masak> MadcapJake: "within these walls, `take` returns a value to be pushed onto an array"

[14:02] <masak> MadcapJake: that makes it sound like `gather` is a lexical construct. but it's dynamic.

[14:02] <masak> m: my @a = gather { foo() }; sub foo() { take 1; take 2; take 3 }; say @a

[14:02] <camelia> rakudo-moar 4f046d: OUTPUTÂ«[1 2 3]â¤Â»

[14:03] <hoelzro> o/ #perl6

[14:04] <MadcapJake> ok, yeah I should definitely explain that

[14:06] <masak> not sure how best to phrase it

[14:06] <masak> but "within these walls" sounds like a lexical-not-dynamic construct to me

[14:10] *** raiph joined
[14:12] <stmuk_> oh I never knew Intel 64 bit is actually 48bit!

[14:16] <MadcapJake> what would you say is the difference between Seq and List?

[14:17] *** Ven joined
[14:17] *** pierre joined
[14:20] <MadcapJake> figured it out

[14:21] <arnsholt> IIRC a Seq can only be traversed once

[14:22] *** pierre left
[14:28] *** khw joined
[14:30] *** wamba joined
[14:38] <Ven> arnsholt: unless you call *cache* on it

[14:39] <Ven> m: sub f($a) { for $a { .say }; for $a { .say }; }; f((1, 2, 3))

[14:39] <camelia> rakudo-moar 4f046d: OUTPUTÂ«(1 2 3)â¤(1 2 3)â¤Â»

[14:39] <Ven> m: sub f($a) { for $a { .say }; for $a { .say }; }; f((1, 2 X+ 3, 4))

[14:39] <camelia> rakudo-moar 4f046d: OUTPUTÂ«(4 5 5 6)â¤(4 5 5 6)â¤Â»

[14:40] *** cpage_ left
[14:40] <Ven> m: say map(-> ($i, $j) { $i + $j }, (-1, 0 X 0, 1));

[14:40] <camelia> rakudo-moar 4f046d: OUTPUTÂ«(-1 0 0 1)â¤Â»

[14:43] <Ven> m: for ^2 { say [+] map(-> ($i, $j) { $i + $j }, (-1, 0 X 0, 1)); }

[14:43] <camelia> rakudo-moar 4f046d: OUTPUTÂ«0â¤This Seq has already been iterated, and its values consumedâ¤(you might solve this by adding .cache on usages of the Seq, orâ¤by assigning the Seq into an array)â¤  in block <unit> at /tmp/gXbGg4BN5R line 1â¤â¤Â»

[14:43] <Ven> There, that was the one I hit last time.

[14:44] *** BenGoldberg joined
[14:47] *** cdg joined
[14:53] *** buharin joined
[15:03] *** CIAvash joined
[15:06] *** Actualeyes left
[15:11] *** buharin left
[15:12] *** buharin joined
[15:15] *** buharin left
[15:20] *** buharin joined
[15:23] <MadcapJake> It's up: http://madcapjake.github.io/2016/perl6-generators/

[15:23] <MadcapJake> psch, masak: thanks for the tips! I've made adjustments accordingly

[15:24] *** tokuhirom joined
[15:29] *** tokuhirom left
[15:31] *** cpage_ joined
[15:34] *** smls joined
[15:34] <masak> MadcapJake++

[15:37] <hankache> MadcapJake++

[15:37] <smls> Could someone (ideally TimToady) take a look at RT #123933, and decide what the expected regex behavior is there?

[15:37] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=123933

[15:44] *** firstdayonthejob joined
[15:57] *** Ven left
[15:59] <TimToady> I'll have to page in my regex brane to think about that one; historically rakudo just slapped ':' on various things, but that wasn't necessarily how it was originally envisioned to work, so I need to reconstruct the arguments

[16:00] <TimToady> (and my branes don't page out/in till I've had more coffee than this...)

[16:01] <smls> :)

[16:03] *** KotH joined
[16:04] <MadcapJake> m: say "abcd" ~~ /:r ["foo" | .+!] "d"/

[16:04] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Nilâ¤Â»

[16:07] *** pierre joined
[16:07] <smls> Yeah, it only matches with || not |

[16:08] <MadcapJake> smls: what about this line in S05: "Note: for portions of patterns subject to longest-token analysis, a : is ignored in any case, since there will be no backtracking necessary."

[16:09] *** pecastro left
[16:10] *** pmurias joined
[16:10] <smls> I think that talks about the : being redundant in  [ <a>: | <b> ]

[16:12] *** pierre left
[16:13] <MadcapJake> m: say "abcd" ~~ /["foo" | .+!]: "d"/; say "abcd" ~~ /["foo" | .+!] "d"/

[16:13] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Nilâ¤ï½¢abcdï½£â¤Â»

[16:17] <hankache> can stdout be redirected to a variable?

[16:18] *** dwarring left
[16:20] <MadcapJake> hankache: yeah, via Proc.new(:out) and $proc.out (an IO::Pipe) http://doc.perl6.org/type/Proc#method_new

[16:21] <ugexe> something like $*OUT = class :: { method print(*@_) { $whatever = @_ }; method flush(|) { } };

[16:21] <hankache> thn

[16:21] <hankache> thanks

[16:22] <tadzik> IO::Capture::Simple does roughly that

[16:22] <tadzik> you may find it useful

[16:25] <hankache> thanks

[16:25] <ugexe> $*OUT.Supply.tap: {.say}; would probably be the cleanest way, but currently it just freezes

[16:26] *** pmurias left
[16:29] <MadcapJake> start { $*OUT.Supply.tap: {.say} }; say 'hello!'

[16:29] <MadcapJake> m: start { $*OUT.Supply.tap: {.say} }; say 'hello!'

[16:29] <camelia> rakudo-moar 4f046d: OUTPUTÂ«hello!â¤Â»

[16:30] <MadcapJake> huh, on my machine it prints Â«hello!â¤TrueÂ»

[16:30] <psch> m: my @*LINES; start { $*OUT.Supply.tap: { @*LINES.push: $_ } }; say 'hello!'; #note @*LINES

[16:30] <camelia> rakudo-moar 4f046d: OUTPUTÂ«hello!â¤Â»

[16:30] <psch> m: my @*LINES; start { $*OUT.Supply.tap: { @*LINES.push: $_ } }; say 'hello!'; note @*LINES

[16:30] <camelia> rakudo-moar 4f046d: OUTPUTÂ«hello!â¤[]â¤Â»

[16:30] <ugexe> m: start { $*OUT.Supply.tap: {say "xxx"} }; say 'hello!'

[16:30] <camelia> rakudo-moar 4f046d: OUTPUTÂ«hello!â¤Â»

[16:31] <psch> m: my @*LINES; start { $*OUT.Supply.tap: { @*LINES.push: $_ } }; $*OUT.say: 'hello!'; note @*LINES

[16:31] <camelia> rakudo-moar 4f046d: OUTPUTÂ«hello!â¤[]â¤Â»

[16:31] <dalek> gtk-simple: d3ac2da | azawawi++ | README.md:

[16:31] <dalek> gtk-simple: Fix spelling typo in README

[16:31] <dalek> gtk-simple: review: https://github.com/perl6/gtk-simple/commit/d3ac2da5c1

[16:32] *** huggable left
[16:32] <BenGoldberg> The way IO::Capture::

[16:33] *** Zoffix joined
[16:33] <BenGoldberg> The way IO::Capture::Simple uses global variables means that if you do capture(&something_which_throws_an_exception), then capturing will remain in effect...

[16:35] <ugexe> i always temp $*OUT but i tend to avoid modules for 1 liners

[16:36] <Zoffix> Hey. When is it best to use roles instead of classes? I've seen people rage about awesomeness of roles, but all I know about them is they behave as if all the methods were part of the class they're composed into and not passed up the food chain with inheritance... Is that all there is to it?

[16:37] <ugexe> parameterization, method resolution, etc

[16:37] <MadcapJake> ensuring that your class matches a specified interface

[16:37] <Ulti> MadcapJake++ I like your generators article, you should check out Icon if you want to see early implementations of the idea :3 where the keyword was "suspend" rather than yield https://en.wikipedia.org/wiki/Icon_(programming_language)#Generators

[16:38] <ugexe> container[My::Type].new(blah => 1) # sometimes i use them to allow me to write initialization like this instead of passing My::Type into new

[16:38] <Zoffix> MadcapJake, oh, that's my current need. So I should use a Role. 

[16:39] <Zoffix> I need to readup on parameterization

[16:40] *** CIAvash left
[16:40] <MadcapJake> Ulti: thanks! That's really neat about Icon. I'm not sure I've ever even heard of the language! :P

[16:40] <psch> m: role R { method foo { "foo" } }; class A does R { }; class B is A { }; say B.foo

[16:40] <camelia> rakudo-moar 4f046d: OUTPUTÂ«fooâ¤Â»

[16:40] <ugexe> also roles with a single member can use `xxx but My::Role($member)`

[16:40] * psch isn't sure whether B is "up the foodchain" from A

[16:41] <Zoffix> m: role R { method foo { "foo" } }; class A does R { }; class B is A {  method foo { 'bar' } }; say B.foo

[16:41] <camelia> rakudo-moar 4f046d: OUTPUTÂ«barâ¤Â»

[16:42] <psch> well, that's just normal shadowing

[16:42] <Ulti> MadcapJake yeah its sort of obscure, its the child of SNOBOL which was an early string processing language in the 60s, Icon is one of those 70s languages that never quite made it because it was ahead of its day

[16:42] <psch> m: class A { method foo { "foo" } }; class B is A { method foo { "bar" } }; B.foo.say

[16:42] <camelia> rakudo-moar 4f046d: OUTPUTÂ«barâ¤Â»

[16:42] <ugexe> m: role R { method foo { "foo" } }; class A does R { }; class B is A {  method foo { 'bar' } }; say B.*foo

[16:42] <camelia> rakudo-moar 4f046d: OUTPUTÂ«(bar foo)â¤Â»

[16:42] <Zoffix> By "up the foodchain" I meant that if it's not found in B, it goes to look in A, while with roles, the method gets composed into the class

[16:42] * geekosaur did a fair bit with icon bitd

[16:43] <Ulti> orly

[16:43] <psch> Zoffix: right, but if  the parent clase composes the role that's the same, isn't it?

[16:43] <psch> *class

[16:43] <Zoffix> Looks like it.

[16:43] <Ulti> my Dad used it for work and since it was so high level I learnt quite a bit of programming in it since graphics and GUIs were really easy to program

[16:43] <Zoffix> psch, I just don't really see the benefit for R to be a role and not a class in that case :/

[16:44] <Zoffix> Or I don't get what the benefit is.

[16:44] <psch> fwiw, i don't have strong opinions on how to do OO.  well, except "inheritance is a mess" maybe :S

[16:44] <MadcapJake> Ulti: neat! It looks really clean and expressive for an old language

[16:45] <psch> well, the difference between roles and classes is that the latter cannot be composed

[16:45] <psch> only inherited

[16:45] <ugexe> you cant mixin a class

[16:46] <psch> right, "composed into something else", which is probably better expressed as mixin, ugexe++

[16:46] <MadcapJake> Zoffix: I think it can often be a matter of choice.  But I would say classes are for instantiation and roles are for enclosing specific "roles" that you want to have multiple classes utilize. By "roles" I mean a set of methods that all work around a specific task

[16:46] <psch> MadcapJake: that's not really an argument against making that same role a parent class, though

[16:46] <psch> MadcapJake: and, well, roles can be punned too

[16:47] <psch> i think it was masak++ who said to usually just use roles, 'cause they do everything classes do and more vOv

[16:47] <psch> ...or maybe the actual argument was "it's the shorter keyword"

[16:47] <psch> i don't remember

[16:50] <MadcapJake> Here's how S14 describes the difference: http://design.perl6.org/S14.html#Roles

[16:50] <ugexe> theres some problems with punning though, although i cant recall them off the top of my head

[16:50] <MadcapJake> Though is it wrong about roles not being able to be instantiated?

[16:51] <ugexe> when you are trying to do more advanced initialization

[16:51] <psch> m: role R { method f(::?CLASS:D: ) { say "i'm definite!" } }; R.new.f

[16:51] <camelia> rakudo-moar 4f046d: OUTPUTÂ«i'm definite!â¤Â»

[16:52] <ugexe> m: role Foo[$a] { has $.b; method new ($b) { self.bless(b => $b * $a); }; }; say Foo[10].new(2).perl # ehh

[16:52] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Foo[Int].new(b => 20)â¤Â»

[16:52] <Zoffix> m: say (1, 2, 3).Seq.is-lazy

[16:52] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Falseâ¤Â»

[16:52] <Zoffix> MadcapJake, what do you mean by Seq is inherently lazy? (RE: your article)

[16:52] <psch> ugexe: what's 'ehh' about that?

[16:52] <MadcapJake> Zoffix: is-lazy is for Array and List to know what to do when they build (whether to do it eagerly or not)

[16:53] <Zoffix> MadcapJake, ahh. Thanks.

[16:53] <MadcapJake> m: say (lazy 1, 2, 3).is-lazy

[16:53] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Trueâ¤Â»

[16:53] <ugexe> because you can't actually initialize foo with that

[16:54] <psch> ugexe: i don't get it?  what's "that"?

[16:54] <ugexe> m: role Foo[$a] { has $.b; method new ($b) { self.bless(b => $b * $a); }; }; say Foo[Int].new(20).perl

[16:54] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Invocant requires an instance of type Int, but a type object was passed.  Did you forget a .new?â¤  in method new at /tmp/Bvk0Rf7wEY line 1â¤  in any  at gen/moar/m-Metamodel.nqp line 1736â¤  in block <unit> at /tmp/Bvk0Rf7wEY line 1â¤â¤Â»

[16:54] <psch> ohh

[16:55] <psch> the .perl is wrong then, yeah

[16:59] <Zoffix> MadcapJake++ # informative article

[17:01] *** finanalyst left
[17:02] <ugexe> m: role Foo { has $.a; }; my $x but Foo(42); say $x.a # maybe needs a better error message (my $x = 1 but Foo(42))

[17:02] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Unexpected named parameter 'value' passedâ¤  in block <unit> at /tmp/iCEiY4dzvb line 1â¤â¤Â»

[17:03] <psch> m: role Foo { has $.a }; Foo(42)

[17:03] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Cannot invoke this object (REPR: Uninstantiable; Foo)â¤  in block <unit> at /tmp/8a6akFTj_v line 1â¤â¤Â»

[17:03] <psch> eh, probably different code path due to the but 

[17:03] <ugexe> thats probably trying to use a class CALL-ME

[17:04] <psch> yeah.  i'm not aware of "but Role($attr-value)" meaning anything, but that doesn't have to mean anything... :)

[17:04] <ugexe> m: role Foo { has $.a; }; my $x = 1 but Foo(42); say $x.a

[17:04] <camelia> rakudo-moar 4f046d: OUTPUTÂ«42â¤Â»

[17:04] <Zoffix> 0.o

[17:04] <ugexe> single attribute role can use that form

[17:05] *** domidumont joined
[17:05] <ugexe> m: role Foo { has $.a; has $.b; }; my $x = 1 but Foo(42); say $x.a

[17:05] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Can only supply an initialization value for a role if it has a single public attribute, but this is not the case for 'Foo'â¤  in any mixin at gen/moar/m-Metamodel.nqp line 1293â¤  in block <unit> at /tmp/Ju0JNlN6OZ line 1â¤â¤Â»

[17:08] <dalek> gtk-simple: f74f422 | finanalyst++ | / (2 files):

[17:08] <dalek> gtk-simple: Added set-active method to preselect an combobox option. Modified example 06 to demonstrate.

[17:08] <dalek> gtk-simple: review: https://github.com/perl6/gtk-simple/commit/f74f42280f

[17:08] <dalek> gtk-simple: 93c8774 | RabidGravy++ | / (2 files):

[17:08] <dalek> gtk-simple: Merge pull request #32 from finanalyst/master

[17:08] <dalek> gtk-simple: 

[17:08] <dalek> gtk-simple: Added set-active method to preselect an combobox option. Modified exaâ€¦

[17:08] <dalek> gtk-simple: review: https://github.com/perl6/gtk-simple/commit/93c87749fb

[17:08] <buharin> hey can I ask emacs question?

[17:08] <Zoffix> You just did! ğŸ˜œ

[17:09] <timotimo> i know emacs has the "therapist mode" where you can ask it questions

[17:09] <timotimo> hm. actually. i think it asks you questions

[17:09] <Zoffix> timotimo++

[17:09] * llfourn checks to see if this is real

[17:09] <Zoffix> Wait... that wasn't a joke? :o

[17:09] <timotimo> not a joke

[17:09] <geekosaur> and never forget M-x psychoanalyze-pinhead

[17:09] <Zoffix> :O

[17:10] <geekosaur> (eliza connected to yow)

[17:10] <timotimo> what is yow?

[17:10] <geekosaur> zippy the pinhead quotes

[17:10] <timotimo> oh?

[17:11] <timotimo> never heard of that comic

[17:11] <geekosaur> https://en.wikipedia.org/wiki/Zippy_the_Pinhead

[17:11] <geekosaur> (it is ... inexplicable)

[17:12] *** firstdayonthejob left
[17:17] <dalek> doc: cc620b5 | titsuki++ | doc/Type/Str.pod:

[17:17] <dalek> doc: Fix printf arguments

[17:17] <dalek> doc: review: https://github.com/perl6/doc/commit/cc620b5d93

[17:17] <dalek> doc: 0cd4571 | (Zoffix Znet)++ | doc/Type/Str.pod:

[17:17] <dalek> doc: Merge pull request #535 from titsuki/fix-printf

[17:17] <dalek> doc: 

[17:17] <dalek> doc: Fix printf arguments

[17:17] <dalek> doc: review: https://github.com/perl6/doc/commit/0cd45715ab

[17:17] <buharin> Zoffix: when I am trying to paste by ctrl+shift+v from clipboard I get additional spaces with every line

[17:17] <buharin> like: original text is some\nsome\n and yanked some\nsome\n\n

[17:17] <Zoffix> buharin, Â¯\_(ãƒ„)_/Â¯ I use Sublime Text 2 and Atom.

[17:17] <buharin> if you know what I mean

[17:18] <buharin> ohh ok

[17:18] <buharin> :(

[17:18] <Zoffix> I'm sure there's #emacs or similar on Freenode

[17:18] <llfourn> buharin: I use ctrl-y which seems to use the clipboard anyways but this is on mac

[17:18] <buharin> wait will check

[17:19] *** Emeric left
[17:20] <geekosaur> if you paste with ctrl+shift+v then autoindent and other settings apply, just as if you typed it. if you use ctrl-y, they don't

[17:20] *** firstdayonthejob joined
[17:20] * TimToady has special vim commands to turn autoindent off and on for that reason

[17:21] <geekosaur> ...but emacs in terminal may not have pasteboard/clipboard access

[17:21] <buharin> on Linux I cann't do this with ctrl-y

[17:21] <geekosaur> (especially on OS X where things are Weird)

[17:21] * TimToady also has firefox bindings that let ctrl+shift+v work :)

[17:21] <geekosaur> right, on  linux you'd need a build with X11 support and emacs -nw

[17:22] <geekosaur> ...and -nw might nevertheless block access to X11 selections

[17:22] <buharin> :(

[17:22] <geekosaur> vim has specific support for running in a terminal but connecting to X11 to read its selections. I don't recall emacs having this

[17:22] <timotimo> there's also "fakeclip" for vim

[17:22] *** Zoffix left
[17:25] *** khw left
[17:26] *** khw joined
[17:28] *** willthechill joined
[17:33] *** Emeric joined
[17:42] *** skingsbu joined
[17:46] *** rindolf left
[17:50] *** buharin_ joined
[18:03] *** cdg left
[18:05] *** kurahaupo joined
[18:05] *** kurahaupo left
[18:06] *** TimToady joined
[18:06] *** hankache_ joined
[18:09] *** hankache left
[18:12] <smls> moritz: Are you fine with closing #123666 ?

[18:12] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=123666

[18:25] *** hankache_ left
[18:25] *** hankache joined
[18:30] <moritz> smls: yes

[18:30] <smls> ok

[18:30] *** cdg joined
[18:38] *** domidumont left
[18:39] *** aries_liuxueyang left
[18:41] *** aries_liuxueyang joined
[18:48] *** BenGoldberg left
[18:49] *** BenGoldberg joined
[18:49] *** BenGoldberg left
[18:51] *** hankache left
[19:12] <TimToady> what a strange caller-id: LLDSGJL JLDFSJL

[19:12] <TimToady> all home-row keys...

[19:18] *** rindolf joined
[19:25] *** tokuhirom joined
[19:26] <masak> TimToady: all we know about them is they probably don't use Dvorak :P

[19:27] <TimToady> yeah, that occurred to me :)

[19:28] <TimToady> (having won the obfuscated C contest once with a Dvorak emulator)

[19:29] *** tokuhirom left
[19:30] *** jjido joined
[19:31] *** |2701 left
[19:31] *** KotH left
[19:33] *** bjz left
[19:33] *** jjido left
[19:37] *** jjido joined
[19:38] *** pecastro joined
[19:38] *** awwaiid joined
[19:51] <AlexDaniel> can't write a comment on RT /o\

[19:52] <AlexDaniel> ah, it logged me out, that's why

[19:57] *** TEttinger joined
[20:00] *** brrt joined
[20:05] *** |2701 joined
[20:07] *** _dolmen_ joined
[20:08] *** darutoko left
[20:12] <psch> AlexDaniel: yeah, the auto logout on RT doesn't make sense to me

[20:12] <dalek> doc: a957eef | raiph++ | doc/Language/objects.pod:

[20:12] <dalek> doc: Show BUILDALL example returning built object

[20:12] <dalek> doc: 

[20:12] <dalek> doc: "It doesn't seem clear from the documentation that returning from BUILDALL would matter."

[20:12] <dalek> doc: 

[20:12] <dalek> doc: See http://www.perlmonks.org/?node_id=1163681

[20:12] <dalek> doc: review: https://github.com/perl6/doc/commit/a957eef2a3

[20:12] <psch> i mean, i never figured out when or why it happens

[20:17] *** brrt left
[20:17] *** pecastro left
[20:24] <dalek> doc: e3555ea | raiph++ | doc/Language/traps.pod:

[20:24] <dalek> doc: Fix mistake in BUILDALL example code

[20:24] <dalek> doc: 

[20:24] <dalek> doc: Immediate `nextsame` makes a method a no op. Switched to `callsame`. This revealed that the BUILDALL example failed to return `self`.

[20:24] <dalek> doc: review: https://github.com/perl6/doc/commit/e3555ea630

[20:32] *** KotH joined
[20:32] *** huggable joined
[20:32] <moritz> m: multi e(@tree) { my \op = &::("infix:<{@tree.shift}>); @tree.map(&e).reduce(op) }; multi (\e) { e }; say e ['+', 5, 7]

[20:32] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/XEpQjJy5DNâ¤Unable to parse expression in double quotes; couldn't find final '"' â¤at /tmp/XEpQjJy5DN:1â¤------> 3) }; multi (\e) { e }; say e ['+', 5, 7]7â5<EOL>â¤    expecting any of:â¤        horiâ€¦Â»

[20:33] <timotimo> why would you return self from a BUILD method?

[20:33] <moritz> m: multi e(@tree) { my \op = &::("infix:<{@tree.shift}>"); @tree.map(&e).reduce(op) }; multi (\e) { e }; say e ['+', 5, 7]

[20:33] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/m31xfDiy2fâ¤An anonymous routine may not take a multi declaratorâ¤at /tmp/m31xfDiy2f:1â¤------> 3t}>"); @tree.map(&e).reduce(op) }; multi7â5 (\e) { e }; say e ['+', 5, 7]â¤Â»

[20:33] *** matiaslina joined
[20:33] <moritz> m: multi e(@tree) { my \op = &::("infix:<{@tree.shift}>"); @tree.map(&e).reduce(op) }; multi e(\x) {  }; say e ['+', 5, 7]

[20:33] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/3FGQmdJfyYâ¤Missing infix inside []â¤at /tmp/3FGQmdJfyY:1â¤------> 3.reduce(op) }; multi e(\x) {  }; say e [7â5'+', 5, 7]â¤    expecting any of:â¤        bracketed infixâ¤        infixâ¤        infâ€¦Â»

[20:33] <TimToady> we should probably force the siggie on those to --> Nil

[20:33] <moritz> timotimo: cargo culting, most likely

[20:34] *** jjido left
[20:34] <timotimo> but why would we encourage that in the docs?

[20:34] <moritz> m: multi e(@tree) { my \op = &::("infix:<{@tree.shift}>"); @tree.map(&e).reduce(op) }; multi e(\x) {  }; say e(['+', 5, 7])

[20:34] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Use of Nil in numeric context  in sub e at /tmp/9zizSaS4Lx line 1â¤Use of Nil in numeric context  in sub e at /tmp/9zizSaS4Lx line 1â¤0â¤Â»

[20:34] <timotimo> oh, returning from BUILDALL

[20:34] *** jjido joined
[20:34] <timotimo> yeah, that's different

[20:34] <moritz> m: multi e(@tree) { my \op = &::("infix:<{@tree.shift}>"); @tree.map(&e).reduce(op) }; multi e(\x) { x }; say e(['+', 5, 7])

[20:34] <camelia> rakudo-moar 4f046d: OUTPUTÂ«12â¤Â»

[20:34] <moritz> finally

[20:35] <moritz> my generic-ish tree evaluator

[20:35] <timotimo> yeah, bless just returns what BUILDALL returns

[20:35] <moritz> timotimo: yes, BUILDALL should return self

[20:35] <TimToady> and we should force buildall to --> self except that doesn't work yet :)

[20:35] <TimToady> unless it does

[20:36] <TimToady> m: my method foo (--> self) { 42; }; foo("bar")

[20:36] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/aPzAytoQhhâ¤Type 'self' is not declaredâ¤at /tmp/aPzAytoQhh:1â¤------> 3my method foo (--> self7â5) { 42; }; foo("bar")â¤Â»

[20:37] <TimToady> nah

[20:37] <TimToady> odd error though

[20:37] <TimToady> I guess self isn't introduced soon enough to be in the siggie

[20:37] <TimToady> arguably a buglet

[20:38] *** jjido left
[20:38] *** jjido joined
[20:40] <moritz> masak: a few days ago, you said that code using map felt more declarative to you than one using explicit loops, with fewer moving parts. How do you feel about code using list comprehensions?

[20:41] <moritz> masak: I ask, because in the python community, list comprehensions seem to be seen as more idiomatic

[20:41] <TimToady> yeah, those are python's new hammer

[20:41] <moritz> (presumably because they are a bit more general, and python's lambdas are... weirdish)

[20:43] <RabidGravy> what are "list comprehensions"?  I understand both the words individually the idiom makes no sense to me

[20:44] <RabidGravy> infact the plural of comprehension makes no sense

[20:45] <TimToady> https://en.wikipedia.org/wiki/List_comprehension

[20:48] <RabidGravy> I'm not convinced that helps me understand, infact the article seems designed as a barrier to, er, comprehension

[20:48] <RabidGravy> ;-)

[20:50] * TimToady blames the mathematicians

[20:50] <RabidGravy> I blame my maths teacher

[20:51] <RabidGravy> I jacked it all in and studied literature when I was 19

[20:51] <moritz> RabidGravy: in python, you might write  new = [x + 1 for  in old] to generate a list of elements where each item is increased by one

[20:51] <moritz> *for x in old

[20:51] <moritz> that's a list comprehension

[20:52] <moritz> and the map variant would be new = map(lambda x: x +1, old)

[20:52] <moritz> in p6, @new = map * + 1, @old

[20:52] <TimToady> the main problem with them linguistically is that they're postdeclarations

[20:53] <TimToady> the other problem is that they put the 'if' outside the loop

[20:53] <moritz> right, that's the really weird part

[20:53] <RabidGravy> never liked it in python

[20:53] <smls> TimToady: It's like the american date format... middle->right->left

[20:53] <smls> ;)

[20:53] <moritz> at_most_five = [x for x in old if x <= 5]

[20:53] <TimToady> we've just tried to get as close as possible by making it fall out of normal statement modifiers

[20:55] <RabidGravy> yeah, either of the object form or statement modifier seem more natural to me

[20:55] <TimToady> $_ if $_ <= 5 for @old

[20:55] <TimToady> -> $x { $x if $x } for @old

[20:55] <awwaiid> in haskell the list is lazy

[20:56] <moritz> grep * <= 5, @old

[20:56] <TimToady> m: say ( -> $x { $x if $x <= 5 } for 1..10 )

[20:56] <camelia> rakudo-moar 4f046d: OUTPUTÂ«(1 2 3 4 5)â¤Â»

[20:57] *** willthechill left
[20:58] *** Emeric left
[20:59] <TimToady> awwaiid: the lists are lazy in p6 too

[20:59] <AlexDaniel> I've always thought that list comprehensions in python are popular only because it lacks a good enough .map

[20:59] <AlexDaniel> am I wrong?

[21:00] <TimToady> it's cargo-culted math, basically

[21:01] <masak> moritz: I think I consider maps and list comprehensions about equally declarative, at least in Python.

[21:02] <masak> moritz: the differences are minute. I could imagine if I had several transformation steps then using `map()` or `filter()` would feel more natural, perhaps.

[21:02] <masak> but most of the time it's a wash.

[21:04] <TimToady> I'd say that .map has to be late-bound, but a built-in can make more assumptions about it

[21:04] <AlexDaniel> m: say ($_ + 1 for <1 2 3>) # by the way, do we call this â† a â€œlist comprehensionâ€ in perlÂ 6?

[21:04] <camelia> rakudo-moar 4f046d: OUTPUTÂ«(2 3 4)â¤Â»

[21:04] <TimToady> yes, we do

[21:04] <moritz> masak: ok, thanks

[21:04] <TimToady> but only when we're trying to show off

[21:05] *** Emeric joined
[21:05] <moritz> I do feel a bit of envy that it's so easy to get a reference to a bound method object in python

[21:06] <moritz> python: obj.foo  Perl 6: -> |c { $obj.foo: |c }

[21:07] <masak> moritz: yes, me too.

[21:08] <masak> moritz: I've been meaning to blog about bound methods in various languages -- haven't got achhhround tuit yet though

[21:10] <awwaiid> I've been reading so much ruby where they use |x| for params in blocks that it took me three readings to see the |c as a super-slurpy param :)

[21:11] <TimToady> .oO( 'foo'.assuming($obj:) )

[21:11] <awwaiid> yeah, partial was coming to my mind also. that work?

[21:11] <masak> TimToady, the language design troll :P

[21:12] <TimToady> to really use partial you'd have to use .can

[21:12] <masak> no, it won't work -- that `:` only works in signatures, not in argument lists

[21:13] <TimToady> sez who?

[21:13] <masak> ...assuming TimToady doesn't change the rules just to prove a point, natch...

[21:13] <RabidGravy> :-^

[21:13] * TimToady looks for his deloran

[21:13] <TimToady> *rean

[21:14] <awwaiid> that'd be another colon for my collection :)

[21:14] <RabidGravy> we saw one in a petrol station in Melksham of all places

[21:15] <TimToady> m: say polymod(42, 3 xx *)

[21:15] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/gExnBfMncGâ¤Undeclared routine:â¤    polymod used at line 1â¤â¤Â»

[21:15] <masak> I think "set the invocant" might be a solution to a problem that was never that general to begin with

[21:15] <TimToady> m: say polymod(42: 3 xx *)

[21:15] <camelia> rakudo-moar 4f046d: OUTPUTÂ«(0 2 1 1)â¤Â»

[21:16] * TimToady returns in his DeLorean

[21:16] <masak> in the overwhelming majority of the cases, one wants to extract a bound method with the invocant set to the object the method was pulled out of

[21:16] <TimToady> that being said, dunno that .assuming will accepting a colon

[21:16] <psch> m: printf("%d": 5)

[21:16] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5Â»

[21:16] <TimToady> in fact, pretty sure it won't

[21:17] <psch> m: Str.^can('printf').say

[21:17] <camelia> rakudo-moar 4f046d: OUTPUTÂ«(printf)â¤Â»

[21:17] <psch> huh, i thought we didn't have that

[21:17] * TimToady is a bit surprised too

[21:17] <TimToady> but pleasantly so

[21:21] *** Emeric left
[21:21] *** labster joined
[21:22] * TimToady wonders if we could have some kind of curry-the-rest-of-these-args notation

[21:23] <TimToady> to be applied on the arguments end, not the . end

[21:26] *** _dolmen_ left
[21:27] *** tokuhirom joined
[21:28] *** TimToady left
[21:28] <RabidGravy> so I've concluded that the mango mint and chilli sauce our lovely neighbour brought round is the great satan, I can't feel my  lips

[21:28] <TEttinger> Satan, devourer of lips

[21:29] <llfourn> maybe your neighbour can brand it "Satan's kiss" and make a mint

[21:29] <llfourn> a mint of money that is :)

[21:29] <timotimo> get tongue-kissed by satan

[21:29] <timotimo> sounds lovely, don't it?

[21:30] *** TimToady joined
[21:30] <jast> that sauce does sound interesting, though

[21:31] <jast> it might even be worth sending your lips to purgatory...

[21:31] *** tokuhirom left
[21:33] <awwaiid> m: class Baz { method greet($name) { say "Greetings, $name!" }; method get-method($m) { self.^methods.grep($m)[0].assuming(self) } }; my $b = Baz.new; $f = $b.get-method('greet'); $f('Pat')

[21:33] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/usrCYL8OBQâ¤Variable '$f' is not declaredâ¤at /tmp/usrCYL8OBQ:1â¤------> 030].assuming(self) } }; my $b = Baz.new; 7â5$f = $b.get-method('greet'); $f('Pat')â¤Â»

[21:33] <awwaiid> m: class Baz { method greet($name) { say "Greetings, $name!" }; method get-method($m) { self.^methods.grep($m)[0].assuming(self) } }; my $b = Baz.new; my $f = $b.get-method('greet'); $f('Pat')

[21:33] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Method object coerced to string (please use .gist or .perl to do that)  in method get-method at /tmp/mEKeXZnho1 line 1â¤Greetings, Pat!â¤Â»

[21:37] *** kaare_ joined
[21:39] <TimToady> maybe something like $obj.foo(1,2,3,,,), with $obj.foo(,,,) as a degenerate case

[21:40] <MasterDuke> i just noticed that the jvm's nqp::nextfiledir returns results with the the path of the dir that was nqp::opendir'ed, but moar's doesn't

[21:41] <MasterDuke> e.g., nqp-j -e 'nqp::say(nqp::nextfiledir(nqp::opendir("nqp")))' # nqp/bin, but nqp-m -e 'nqp::say(nqp::nextfiledir(nqp::opendir("nqp")))' # bin

[21:41] <jjido> TimToady: $obj.foo(*,*,*,*)

[21:41] <MasterDuke> is that expected behavior?

[21:48] <TimToady> jjido: we can't know whether .foo is already expecting to process Whatevers, so that synax is not really available

[21:48] <TimToady> I picked ,,, because it's currently a syntax error

[21:48] <TimToady> m: say 1,,,

[21:48] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/rd0fMI_ZBhâ¤Preceding context expects a term, but found infix , insteadâ¤at /tmp/rd0fMI_ZBh:1â¤------> 3say 1,,7â5,â¤Â»

[21:49] *** rindolf left
[21:49] <TimToady> but maybe we could come up with something better

[21:50] <jjido> don't know

[21:51] *** kaare_ left
[21:54] <masak> TimToady: something tells me it'd be a regret-later kind of mistake to start messing with comma/argument clocking, for pretty much the same reasons we've decided not to do it with terms and ops

[21:55] <TimToady> well, I'd treat ,,, as a single token, but yeah

[21:55] <TimToady> maybe some unicode would be clearer

[21:55] <masak> :P

[21:56] *** ssotka joined
[21:57] <TimToady> $obj.foo(â”…) looks pretty darn impressive :)

[21:58] <TimToady> but what I'm proposing is a general syntax that degrades to what other languages provide :)

[21:58] <psch> i had thought $obj&.foo as shortcut for .^can('foo'), but that'd serve a different purpose i think

[21:58] <psch> also not sure that works sensibly enough as a method op, and in a class scope it's probably weirdish

[22:00] <timotimo> &obj &.foo is already a thing

[22:00] <timotimo> as is &obj & .foo

[22:00] <psch> m: say 5&.abs

[22:00] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Method 'abs' not found for invocant of class 'Any'â¤  in block <unit> at /tmp/s91gCtJgyI line 1â¤â¤Â»

[22:01] <psch> yeah, that goes to infix:<&>

[22:01] <psch> m: $_ = 1; say 5&.abs

[22:01] <camelia> rakudo-moar 4f046d: OUTPUTÂ«all(5, 1)â¤Â»

[22:01] <timotimo> m: say 5 &.abs  # also a thing

[22:01] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Method 'abs' not found for invocant of class 'Any'â¤  in block <unit> at /tmp/ngFm40jwaW line 1â¤â¤Â»

[22:01] <timotimo> oh, apparently not a thing

[22:01] <psch> yeah, the same thing :)

[22:01] <timotimo> i thought that could be like $.foo or @.bar

[22:01] <timotimo> i.e. a call to self

[22:02] <psch> m: class A { has &.foo = -> { say "hi" }; method f { &.foo } }; A.f

[22:02] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Cannot look up attributes in a type objectâ¤  in method f at /tmp/skb6ddkWtJ line 1â¤  in block <unit> at /tmp/skb6ddkWtJ line 1â¤â¤Â»

[22:02] <psch> m: class A { has &.foo = -> { say "hi" }; method f { &.foo } }; A.new.f

[22:02] <camelia> rakudo-moar 4f046d: ( no output )

[22:02] <psch> m: class A { has &.foo = -> { say "hi" }; method f { say &.foo } }; A.new.f

[22:02] <camelia> rakudo-moar 4f046d: OUTPUTÂ«->  { #`(Block|75882256) ... }â¤Â»

[22:02] <timotimo> oh, haha

[22:02] <psch> that's what i mean with "in a class scope weirdish" :)

[22:02] <jnthn> timotimo: It is, when the parser is looking for a term rather than an infix :)

[22:02] <timotimo> would have been TTIAR

[22:02] <timotimo> yeah

[22:02] <timotimo> took me a minute to realize that

[22:02] <jnthn> m: &.foo

[22:02] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/cKMFktWt49â¤Variable &.foo used where no 'self' is availableâ¤at /tmp/cKMFktWt49:1â¤------> 3&.foo7â5<EOL>â¤    expecting any of:â¤        termâ¤Â»

[22:04] *** jack_rabbit left
[22:08] <psch> i like the idea of a shortcut for $obj.can("$meth").assuming($obj: *)

[22:09] <timotimo> you mean **? :P

[22:09] <timotimo> oh, no

[22:10] *** buharin left
[22:13] *** rindolf joined
[22:15] *** bjz joined
[22:24] *** cdg left
[22:30] *** RabidGravy left
[22:35] *** ocbtec left
[22:35] <psch> m: my &printf-wrap = printf(**); printf-wrap("%s", "foo")

[22:35] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/NtSbarxp3Wâ¤Calling printf(HyperWhatever) will never work with declared signature (Cool $format, *@args)â¤at /tmp/NtSbarxp3W:1â¤------> 3my &printf-wrap = 7â5printf(**); printf-wrap("%s", "foo")â¤Â»

[22:36] <psch> m: my &printf-wrap = printf.assuming(**); printf-wrap("%s", "foo")

[22:36] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/akLDGJpV3Tâ¤Calling printf() will never work with declared signature (Cool $format, *@args)â¤at /tmp/akLDGJpV3T:1â¤------> 3my &printf-wrap = 7â5printf.assuming(**); printf-wrap("%s", "â¤Â»

[22:36] <psch> ...okay that is a bit LTA

[22:36] <psch> m: my &printf-wrap = printf.assuming(*,*); printf-wrap("%s", "foo")

[22:36] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/lW2LS6jc25â¤Calling printf() will never work with declared signature (Cool $format, *@args)â¤at /tmp/lW2LS6jc25:1â¤------> 3my &printf-wrap = 7â5printf.assuming(*,*); printf-wrap("%s", â¤Â»

[22:36] <psch> wait, i'm just doing it wrong again, aren't i? :)

[22:36] <psch> m: my &printf-wrap = &printf.assuming(**); printf-wrap("%s", "foo")

[22:36] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Type check failed in binding $format; expected Cool but got HyperWhatever (**)â¤  in sub trybind at EVAL_1 line 1â¤  in block <unit> at EVAL_1 line 1â¤  in block <unit> at /tmp/5oYyvKPpGc line 1â¤â¤Â»

[22:37] <psch> m: my &printf-wrap = &printf.assuming(*,*); printf-wrap("%s", "foo")

[22:37] <camelia> rakudo-moar 4f046d: OUTPUTÂ«fooÂ»

[22:37] <psch> yeah, i was

[22:38] <jjido> psch: ah that works?

[22:39] <psch> jjido: the latest iteration, yeah.. :)

[22:39] *** brabo joined
[22:40] <psch> m: my &printf-wrap = &printf.assuming("%s", *); printf-wrap "foo" # this too, works

[22:40] <camelia> rakudo-moar 4f046d: OUTPUTÂ«fooÂ»

[22:40] <psch> m: my &printf-wrap = &printf.assuming(*, 5); printf-wrap "%08d" # as does this

[22:40] <camelia> rakudo-moar 4f046d: OUTPUTÂ«00000005Â»

[22:40] <psch> i forget who did that work there, but i'm glad it happened

[22:41] <psch> jjido: basically, assuming takes Whatever to mean "these are the parameters i *don't* want to give values for"

[22:41] <smls> psch: What would ** do there?

[22:41] <smls> m: my &printf-wrap = &printf.assuming(); printf-wrap("%s", "foo")

[22:41] <camelia> rakudo-moar 4f046d: OUTPUTÂ«fooÂ»

[22:42] <psch> smls: i don't think that's specified anywhere.  i'd probably interpret it to mean "all positional from here on"

[22:42] <smls> you can just pass less parameters, to achieve that

[22:42] <smls> (to assuming)

[22:42] <psch> yeah, i see that

[22:43] <psch> i'm not sure there's anything left it could mean

[22:43] <psch> mean "make this positional slurpy instead"?

[22:43] <AlexDaniel> m: &printf.wrap: { nextsame }; printf â€œ%08dâ€

[22:43] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Your printf-style directives specify 1 argument, but no argument was suppliedâ¤  in any  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm line 1â¤  in any panic at /home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPHLL.moarvm line 1â€¦Â»

[22:43] <psch> although that's kind of ugh

[22:43] <AlexDaniel> â€œYour printf-style directives specify 1 argument, but no argument was suppliedâ€ â€¦ what's the right way to read this?

[22:44] <AlexDaniel> aah

[22:44] <AlexDaniel> right, I see

[22:45] <psch> m: printf "%d", class :: { }

[22:45] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Directive d not applicable for type <anon|56507504>â¤  in any  at /home/camelia/rakudo-m-inst-2/share/perl6/runtime/CORE.setting.moarvm line 1â¤  in any panic at /home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPHLL.moarvm line 1â¤â¤Â»

[22:45] <AlexDaniel> m: &printf.wrap: { say â€˜hello worldâ€™ }; printf â€œ%08dâ€

[22:45] <camelia> rakudo-moar 4f046d: OUTPUTÂ«hello worldâ¤Â»

[22:45] <AlexDaniel> m: &printf.wrap: { say â€˜hello worldâ€™ }; printf â€œ%08dâ€, 42

[22:45] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Too many positionals passed; expected 0 or 1 arguments but got 2â¤  in block <unit> at /tmp/9xTKYMFF_1 line 1â¤â¤Â»

[22:45] <AlexDaniel> is there any way to make that work?

[22:45] <psch> m: &printf.wrap: { .say }; printf â€œ%08dâ€

[22:45] <camelia> rakudo-moar 4f046d: OUTPUTÂ«%08dâ¤Â»

[22:46] <psch> AlexDaniel: i think you're misusing .wrap there :)

[22:46] <psch> AlexDaniel: or rather, i don't understand what you're trying to achieve

[22:46] <AlexDaniel> psch: doesn't mean that there's no way to make it work :D

[22:47] <psch> m: &printf.wrap: -> $fmt, *@stuff { say "calling printf!"; printf $fmt, @stuff }; printf "%08d", 5

[22:47] <psch> ugh

[22:47] <AlexDaniel> /o\

[22:47] <camelia> rakudo-moar 4f046d: OUTPUTÂ«(timeout)calling printf!â¤calling printf!â¤calling printf!â¤calling printf!â¤calling printf!â¤calling printf!â¤calling printf!â¤calling printf!â¤calling printf!â¤calling printf!â¤calling printf!â¤calling printf!â¤calling printf!â¤calling printâ€¦Â»

[22:47] <psch> ...that should've been "nextwith $fmt, @stuff" instead of "printf ..." :P

[22:47] <geekosaur> whoops

[22:47] <psch> or callwith..?

[22:48] *** TakinOver joined
[22:48] <psch> anyway, yeah

[22:48] <psch> if you want to wrap a sub with a slurpy, you have to wrap it with a callable with a slurpy in its sig

[22:48] <AlexDaniel> m: &printf.wrap: -> $fmt, *@stuff { say "calling printf!"; nextsame }; printf "%08d", 5

[22:48] <camelia> rakudo-moar 4f046d: OUTPUTÂ«calling printf!â¤Attempt to return outside of any Routineâ¤  in block <unit> at /tmp/PW6TNh3oLI line 1â¤â¤Â»

[22:48] <AlexDaniel> m: &printf.wrap: -> $fmt, *@stuff { say "calling printf!"; callsame }; printf "%08d", 5

[22:48] <camelia> rakudo-moar 4f046d: OUTPUTÂ«calling printf!â¤Â»

[22:48] *** firstdayonthejob left
[22:49] <AlexDaniel> m: &printf.wrap: -> $fmt, *@stuff { callwith($fmt, 42) }; printf "%08d", 5

[22:49] <camelia> rakudo-moar 4f046d: ( no output )

[22:49] <psch> i don't really know how .wrap works though :/

[22:49] <psch> might also be buggy from... something... recently

[22:49] <psch> no idea

[22:49] <AlexDaniel> star: &printf.wrap: -> $fmt, *@stuff { callwith($fmt, 42) }; printf "%08d", 5

[22:49] <camelia> star-m 2016.01: ( no output )

[22:50] <AlexDaniel> m: &printf.wrap: -> $fmt, *@stuff { callsame }; printf "%08d", 42

[22:50] <camelia> rakudo-moar 4f046d: ( no output )

[22:51] <AlexDaniel> huggable: dunno

[22:51] <huggable> AlexDaniel, Â¯\_(ãƒ„)_/Â¯

[22:51] <psch> hrm

[22:51] <psch> maybe something weird about slurpies there

[22:52] <psch> i mean, i recently (as in, a few weeks ago) learned that {call,next}{same,with} on redispatch on candidates with the same arity

[22:52] <psch> s/on/only/

[22:52] <psch> which is why this doesn't work:

[22:52] <psch> m: sub f($a) { say "got $a" }; &f.wrap( sub ($a, $b) { say "$b here!"; callwith $a } ); f(1, 2)

[22:52] <camelia> rakudo-moar 4f046d: OUTPUTÂ«5===SORRY!5=== Error while compiling /tmp/cejBqg2Okuâ¤Calling f(Int, Int) will never work with declared signature ($a)â¤at /tmp/cejBqg2Oku:1â¤------> 3 $b) { say "$b here!"; callwith $a } ); 7â5f(1, 2)â¤Â»

[22:52] <psch> well, maybe not quite *why*, but it's related :P

[22:54] <psch> m: multi f($) { nextwith 1, 2 }; multi f($, $) { say "all good" }; f 1

[22:54] <camelia> rakudo-moar 4f046d: ( no output )

[22:54] <psch> ^^^ that's what i mean

[22:54] <AlexDaniel> interesting

[22:55] <AlexDaniel> well, what's even more interesting, is that nothing happens

[22:55] <psch> m: multi f($) { callwith 1, 2 }; multi f($, $) { say "all good" }; f 1

[22:55] <camelia> rakudo-moar 4f046d: ( no output )

[22:56] <AlexDaniel> m: multi f($) { say callwith(1, 2) }; multi f($, $) { say "all good" }; f 1

[22:56] <camelia> rakudo-moar 4f046d: OUTPUTÂ«Nilâ¤Â»

[22:57] <jjido> AlexDaniel: not returning anything in either func

[22:58] <psch> jjido: &say returns True

[22:58] <psch> m: say say 1

[22:58] <camelia> rakudo-moar 4f046d: OUTPUTÂ«1â¤Trueâ¤Â»

[22:59] <jjido> k

[23:11] *** |2701 left
[23:14] *** jack_rabbit joined
[23:16] *** jjido left
[23:17] *** jjido joined
[23:19] *** jack_rabbit left
[23:20] *** spider-mario left
[23:20] *** cdg joined
[23:20] *** jack_rabbit joined
[23:21] *** jjido left
[23:23] *** tokuhirom joined
[23:29] *** tokuhirom left
[23:31] * TimToady vaguely attempts to backlog all the #perl6 that happened during OSCON, with mixed results :)

[23:36] *** rindolf left
[23:42] *** wamba left
[23:56] *** cognominal left
[23:59] *** bjz left
