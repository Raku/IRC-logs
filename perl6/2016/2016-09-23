[00:00] *** aries_liuxueyang left
[00:00] *** aries_liuxueyang joined
[00:05] <SmokeMachine____> hi! whats the difference between [] and $[]?

[00:06] <SmokeMachine____> m: say set([1, 2]) (-) set([1, 2]); say set($[1, 2]) (-) set($[1, 2])

[00:06] <camelia> rakudo-moar 553ced: OUTPUT«set()␤set([1 2])␤»

[00:07] <SmokeMachine____> the same with () and $()

[00:08] *** cdg joined
[00:08] <SmokeMachine____> m: say set((1, 2)) (-) set((1, 2)); say set($(1, 2)) (-) set($(1, 2))

[00:08] <camelia> rakudo-moar 553ced: OUTPUT«set()␤set((1 2))␤»

[00:09] <SmokeMachine____> m: say set((1, 2)) (|) set((1, 2)); say set($(1, 2)) (|) set($(1, 2))

[00:09] <camelia> rakudo-moar 553ced: OUTPUT«set(1, 2)␤set((1 2), (1 2))␤»

[00:09] <SmokeMachine____> thats confusing...

[00:10] <skids> m: say (1, [2,3], $[4,5], 6).flat # The $ itemizes, which protects from flattening.

[00:10] <camelia> rakudo-moar 553ced: OUTPUT«(1 2 3 [4 5] 6)␤»

[00:10] <SmokeMachine____> m: say set([1, 2]) (|) set([1, 2]); say set($[1, 2]) (|) set($[1, 2])

[00:10] <camelia> rakudo-moar 553ced: OUTPUT«set(1, 2)␤set([1 2], [1 2])␤»

[00:11] <skids> But, be careful, it does not stp single-element iteration:

[00:11] <skids> m: say ($[1,2]).flat

[00:11] <camelia> rakudo-moar 553ced: OUTPUT«(1 2)␤»

[00:12] <SmokeMachine____> skids: so, how can I make a set of arrays?

[00:12] <SmokeMachine____> m: say set($[1, 2], $[1, 2])

[00:12] <camelia> rakudo-moar 553ced: OUTPUT«set([1 2], [1 2])␤»

[00:13] <skids> If you need to itemize a bunch of things, take advantage of the fact that inside [], everything gets an invisible $.

[00:13] <SmokeMachine____> m: class Bla {has $.a; has $.b}; say set(Bla.new(:a(1), :b(2)), Bla.new(:a(1), :b(2)))

[00:13] <camelia> rakudo-moar 553ced: OUTPUT«set(Bla.new(a => 1, b => 2), Bla.new(a => 1, b => 2))␤»

[00:13] <skids> m: say set([[1,2],[1,2]])

[00:13] <camelia> rakudo-moar 553ced: OUTPUT«set([1 2], [1 2])␤»

[00:14] <SmokeMachine____> skids: but I am using a set to do not repeat elements...

[00:14] <skids> I see what you mean now.

[00:15] <SmokeMachine____> and...

[00:15] <skids> Containers are not value types, so each [] is a different object, which is why that is not working.

[00:15] <SmokeMachine____> m: my %a := set $[1, 2]; say %a{$[1, 2]}

[00:15] <camelia> rakudo-moar 553ced: OUTPUT«False␤»

[00:15] <skids> m: [1,2].WHICH.say; [1,2].WHICH.say;

[00:15] <camelia> rakudo-moar 553ced: OUTPUT«Array|64433024␤Array|64433088␤»

[00:16] <SmokeMachine____> ok, I understand that...

[00:16] <SmokeMachine____> but:

[00:16] <SmokeMachine____> m: [1, 2] ~~ [1, 2]

[00:16] <camelia> rakudo-moar 553ced: ( no output )

[00:16] <SmokeMachine____> m: say [1, 2] ~~ [1, 2]

[00:16] <camelia> rakudo-moar 553ced: OUTPUT«True␤»

[00:17] <skids> right.  Smartmatch doesn't check identity, just value.

[00:17] <skids> m: say [1,2] === [1,2]

[00:17] <camelia> rakudo-moar 553ced: OUTPUT«False␤»

[00:18] <SmokeMachine____> Shouldn't  the bouth arrays create the same hash to use on the set? (assuming that the set uses a hash function...)

[00:18] <skids> sets use the WHICH.

[00:19] <SmokeMachine____> because, if it uses === and not a hash function, so it probably have to compare item by item... so its insertion, get, etc will not be O(1)

[00:19] <skids> Hash by default uses the stringification.  Object hashes use the WHICH, though.

[00:19] <timotimo> a set of arrays is very problematic

[00:19] <timotimo> yes, for that reason

[00:19] <timotimo> arrays are mutable

[00:19] <timotimo> but skids already said that

[00:20] <skids> mutability really isn't the issue, lists won't work either.

[00:20] *** pierre_ joined
[00:20] <SmokeMachine____> it compares the new value with all the itens on insert?

[00:21] <skids> It looks at the WHICH, and compares it to the other WHICH's

[00:21] <skids> So it doesn't traverse all the elements.

[00:21] <SmokeMachine____> m: my %a{Any}; %a{$[1,2]}++; %a{$[1,2]}++; say %a

[00:21] <camelia> rakudo-moar 553ced: OUTPUT«{[1 2] => 1, [1 2] => 1}␤»

[00:22] <SmokeMachine____> skids: so, the insertion's complexity is O(n), not O(1)?

[00:22] <SmokeMachine____> and looks the the hash is the same, right?

[00:22] <skids> Likely it hashes the WHICH value, I'm not sure.

[00:23] <timotimo> i think that's how, yes

[00:23] <timotimo> er, no, actually

[00:23] <skids> So probably some O(log N)ish 

[00:23] <timotimo> we have an "object id" mechanism for that

[00:23] <timotimo> it moves an object into the second gen so that it never moves again and then uses its location in memory as its ID

[00:24] <timotimo> that is then used for hashing

[00:24] <SmokeMachine____> skids: if it uses a hash function and insert on that position, it would be O(1), or am I wrong?

[00:24] <skids> Hash tables aren't actually O(1).

[00:24] <timotimo> amortized they are, no?

[00:26] <skids> I think that's a stretch/creative accounting.  Suffice to say tey are the fastest thing we have :-).

[00:28] <timotimo> creative accounting is what amortization is

[00:28] <skids> Speaking of that anchoring mechanism, how would I anchor the memory in a Buf so it can't move but still can get GCd later.

[00:31] * skids wonders whether SmokeMachine____'s arrays need to preserve order

[00:31] <skids> m: say set(set(1,2)) (-) set(set(1,2))

[00:31] <camelia> rakudo-moar 553ced: OUTPUT«set()␤»

[00:31] <skids> Looks like sets are value objects.

[00:31] <SmokeMachine____> Is there a way to change the way that the set is "indexed"?

[00:32] <skids> Depends on the precise definition of "indexed"?

[00:32] <timotimo> depends on what your definition of "is" is.

[00:32] <SmokeMachine____> I don't need order, I am trying to create a set of points...

[00:33] <SmokeMachine____> I am trying to do some thing like: set $(1,2), $(2,4), $(1, 4)

[00:33] <skids> m: say set(set(:1x,:2y)) (-) set(set(:1x,:2y))

[00:33] <camelia> rakudo-moar 553ced: OUTPUT«Unexpected named argument 'x' passed␤  in block <unit> at <tmp> line 1␤␤»

[00:34] <skids> m: say set(set($:1x,$:2y)) (-) set(set($:1x,$:2y))

[00:34] <camelia> rakudo-moar 553ced: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤You can't adverb $ANON_VAR__1␤at <tmp>:1␤------> 3say set(set($:1x7⏏5,$:2y)) (-) set(set($:1x,$:2y))␤»

[00:35] <skids> m: :1x.WHICH.say; :1x.WHICH.say

[00:35] <camelia> rakudo-moar 553ced: OUTPUT«Pair|Str|x|Int|1␤Pair|Str|x|Int|1␤»

[00:35] <skids> m: say :1x === :1x

[00:35] <camelia> rakudo-moar 553ced: OUTPUT«True␤»

[00:37] <skids> m: say [:1x,:2y].Set # o.O this I don't get.

[00:37] <camelia> rakudo-moar 553ced: OUTPUT«set(x, y)␤»

[00:37] <SmokeMachine____> m: say {:x(1),:y(2)} === say {:x(1),:y(2)}

[00:37] <camelia> rakudo-moar 553ced: OUTPUT«{x => 1, y => 2}␤False␤»

[00:37] <skids> m: say {:x(1),:y(2)} === {:x(1),:y(2)}

[00:37] <camelia> rakudo-moar 553ced: OUTPUT«False␤»

[00:39] <skids> m: say Set(Pair.new("x",1),Pair.new("y",2))

[00:39] <camelia> rakudo-moar 553ced: OUTPUT«set(x, y)␤»

[00:39] <timotimo> so ... compiz and compiz fusion are kind of dead; what project would supercede those?

[00:44] <skids> m: Set([1.0,2e0]).perl.say # dirty trick

[00:44] <camelia> rakudo-moar 553ced: OUTPUT«set(2e0,1.0)␤»

[00:45] *** rindolf left
[00:48] *** cdg left
[00:52] <tushar> how can I identify "nl-in"? Also, how can I set "nl-out"?

[00:53] *** eliasr left
[00:54] *** MasterDuke joined
[00:56] <MasterDuke> m: my $h = IO::Handle.new; dd $h.nl-in; dd $h.nl-out; $h.nl-out = "\t"; dd $h.nl-out

[00:56] <camelia> rakudo-moar 553ced: OUTPUT«IO::Handle is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting line 1␤  in method new at src/RESTRICTED.setting line 32␤  in block <unit> at <tmp> line 1␤␤»

[00:57] <MasterDuke> tushar: $["\n", "\r\n"]

[00:57] <MasterDuke> Str $!nl-out = "\n"

[00:57] <MasterDuke> Str $!nl-out = "\t"

[00:57] <MasterDuke> that's what i get when i run the above code

[01:01] <tushar> MasterDuke: Thanks. I have one question though, when I try "$FH.nl-in" where $FH = input file handle, I got an array containing \n and \r\n. I created a text file on my MAC using vi editor. I am expecting to get either "\n" or "\r" but not "\r\n". Do you have any idea that why am I getting "\r\n"?

[01:05] *** Cabanossi left
[01:08] *** cyphase left
[01:08] <skids> It would appear the default is "on input, take either \n or \r\n as a newline"

[01:09] <skids> Or in other words, "sorry really old Apple users, the world has moved on" :-)

[01:13] *** cyphase joined
[01:13] <tushar> skids: hahaha.. I am quite young.. 

[01:15] *** Cabanossi joined
[01:15] <tushar> Is there any way of detecting type of file? I meant text or csv file. I know I can check the extension. But many time extensions are not consistent with the content? So is there any way to detect file type from file content?

[01:16] <skids> Well, you don't have to be old to use a really old Apple, but it sure helps :-)

[01:16] <SmokeMachine____> Any way to change the which method and do not have troubles with the gc?

[01:17] *** cbk_ joined
[01:17] <tushar> skids: me and my mac both are quite young.. ;)

[01:18] *** stmuk_ joined
[01:18] <skids> tushar: maybe use one of the Perl5 modules for file type identification using :from<perl5>?

[01:18] <skids> Or use NativeCall with libmagic or somesuch.

[01:18] <kerframil> tushar: Lib::FileMagic. there's a p6 port.

[01:18] <skids> Oh cool.

[01:20] *** stmuk left
[01:21] *** pierre_ left
[01:21] *** cyphase left
[01:23] <tushar> kerframil: Does Lib::FileMagic available on modules.perl6.org? Because I am not available to find it. Could you please provide a link to it?

[01:24] *** cbk_ left
[01:24] <tushar> Thanks.

[01:25] *** cyphase joined
[01:26] <kerframil> tushar: I have no idea, but it's in Dave Rolsky's github repo

[01:26] <kerframil> https://github.com/autarch/perl6-File-LibMagic

[01:26] <tushar> kerframil:thanks a lot

[01:26] <kerframil> you'd need the libmagic library and headers installed to build it

[01:27] *** MasterDuke left
[01:27] *** cbk_ joined
[01:29] *** nadim_ left
[01:29] *** pierre_ joined
[01:30] <tushar> hmmm

[01:33] *** cyphase left
[01:34] *** MasterDuke joined
[01:34] *** pierre_ left
[01:35] *** pierre_ joined
[01:38] *** cyphase joined
[01:40] *** Actualeyes joined
[01:46] *** cyphase left
[01:49] *** tushar left
[01:57] <zengargoyle> heh, looks like ∘ (function composition) and ≅ (approximately equal) are created using the unicode name and then have Texas version just calling the unicode version.

[01:58] <zengargoyle> other ones are defined the Texas way and have a unicode version that just calls the Texas version.  weird.

[01:58] <skids> That module does not look like it needs headers so it should just need the lib itself.

[01:59] *** BenGoldberg joined
[01:59] *** cpage_ left
[02:00] <skids> probably just because those were late adds/author preference.

[02:00] *** zwu joined
[02:05] <BenGoldberg> .tell tushar For a conventient way to install libmagic, consider using the perl5 module Alien::LibMagic.

[02:05] <yoleaux> BenGoldberg: I'll pass your message to tushar.

[02:07] *** cyphase_eviltwin joined
[02:07] <zwu> I just checked the performance of perl6 running https://gist.github.com/anonymous/f31c6b7e0163b41efe0a7cd9a1085894, compared with https://github.com/famzah/langs-performance. The perl6 version is about 13 times slower than python version today, while in May, it was about 17 times slower.  

[02:14] *** noganex_ joined
[02:15] *** cyphase_eviltwin left
[02:16] *** noganex left
[02:19] *** cyphase_eviltwin joined
[02:28] *** cyphase_eviltwin left
[02:33] *** cyphase_eviltwin joined
[02:33] *** poisonby left
[02:35] *** integral left
[02:36] *** cyphase_eviltwin left
[02:36] *** cyphase_eviltwin joined
[02:40] *** poisonby joined
[02:41] <TEttinger> nice zwu

[02:41] <TEttinger> improvement is improving

[02:43] *** integral joined
[02:44] *** jonas4 left
[02:48] *** cpage_ joined
[02:49] *** zwu left
[02:49] *** mcmillhj joined
[02:49] *** cyphase_eviltwin left
[02:53] *** mcmillhj left
[02:54] *** cyphase joined
[02:58] *** zwu joined
[02:58] *** zwu left
[03:01] *** cyphase left
[03:06] *** cyphase joined
[03:14] *** cyphase left
[03:19] *** cyphase joined
[03:33] *** khw left
[03:34] *** cyphase left
[03:38] *** cyphase joined
[03:53] *** pierre_ left
[03:56] *** cyphase left
[03:59] *** dalek left
[03:59] *** dalek joined
[03:59] *** ChanServ sets mode: +v dalek

[03:59] *** pierre_ joined
[04:01] *** cyphase joined
[04:01] *** pierre_ left
[04:02] *** pierre_ joined
[04:09] *** cyphase left
[04:12] *** pierre_ left
[04:13] *** pierre_ joined
[04:14] *** cyphase joined
[04:16] *** zrr joined
[04:19] *** skids left
[04:22] *** woolfy left
[04:22] *** woolfy joined
[04:24] *** cyphase left
[04:27] *** wamba joined
[04:28] *** cyphase joined
[04:31] *** Cabanossi left
[04:34] *** Cabanossi joined
[04:40] *** dayangkun joined
[04:44] *** AndyBotwin left
[04:46] *** AndyBotwin joined
[04:50] *** cyphase left
[04:53] *** dayangkun left
[04:55] *** cyphase joined
[04:55] *** pierre_ left
[04:55] <Xliff_> What's the best way to re-initialize a CArray? This is in the context of reasignment by infix<=>

[04:56] <Xliff_> Particularly, the case when we need to drop the original contents for a new list (or single item)

[05:00] *** rurban joined
[05:00] *** rurban left
[05:04] *** pierre_ joined
[05:08] *** pierre_ left
[05:17] *** cyphase left
[05:18] *** maddingue left
[05:18] *** maddingue joined
[05:20] *** dayangkun joined
[05:21] *** cyphase joined
[05:22] *** brrt2 joined
[05:27] *** BenGoldberg left
[05:31] *** holyghost joined
[05:37] *** cyphase left
[05:41] *** cyphase joined
[05:48] *** AlexDaniel left
[05:49] *** wamba left
[05:49] *** cyphase left
[05:53] *** Ven` joined
[05:54] *** darutoko joined
[05:58] *** Ven` left
[05:58] *** domidumont joined
[06:02] *** domidumont left
[06:03] *** MasterDuke left
[06:04] *** domidumont joined
[06:04] *** pierre_ joined
[06:06] *** kerframil left
[06:09] *** pierre_ left
[06:10] *** cyphase joined
[06:14] *** brrt2 left
[06:18] *** firstdayonthejob joined
[06:18] *** rurban joined
[06:18] *** pierre_ joined
[06:24] *** cyphase left
[06:26] *** holyghost left
[06:27] *** confundus joined
[06:28] *** confundus left
[06:28] *** cyphase joined
[06:34] *** confundus joined
[06:37] *** cyphase left
[06:38] *** wamba joined
[06:39] *** wamba left
[06:41] *** cyphase joined
[06:43] *** dayangkun left
[06:44] *** firstdayonthejob left
[06:45] *** domidumont left
[06:47] *** domidumont joined
[06:52] *** domidumont left
[06:54] *** wamba joined
[06:54] *** domidumont joined
[07:05] *** domidumont left
[07:06] *** domidumont joined
[07:08] *** domidumont left
[07:09] *** domidumont joined
[07:09] *** confundus left
[07:19] *** espadrine joined
[07:20] *** pierre_ left
[07:27] *** pierre_ joined
[07:30] *** _slade_ left
[07:32] *** pierre_ left
[07:36] *** pierre_ joined
[07:39] *** wamba left
[07:39] *** wamba joined
[07:43] *** brrt2 joined
[07:43] *** bjz joined
[07:45] *** rurban left
[07:47] *** wamba left
[07:47] *** wamba joined
[07:52] *** brrt2 left
[07:54] *** bjz left
[07:56] *** bjz joined
[07:57] *** pmurias joined
[07:57] <pmurias> hi

[07:58] *** dalek left
[07:58] *** dalek joined
[07:58] *** ChanServ sets mode: +v dalek

[07:59] *** Guest98158 left
[08:00] <El_Che> hi pmurias 

[08:01] <El_Che> pmurias: you were talking about perl 6 vim integration, but I didn't get what you eactly wanted to do. Semantic autocomplete?

[08:01] *** bjz left
[08:09] *** wamba left
[08:16] *** bjz joined
[08:20] *** dayangkun joined
[08:24] <pmurias> El_Che: semantic movement/text selection

[08:24] *** labster joined
[08:25] <pmurias> El_Che: so just like we have dw do delete a word we could have d<some char that we map to perl6 string literal>

[08:28] *** espadrine left
[08:29] *** wamba joined
[08:30] <El_Che> pmurias: interesting

[08:30] <El_Che> pmurias: can you hook that to an existing plugin framework or it is standalone?

[08:33] *** pierre_ left
[08:40] *** dayangkun left
[08:40] *** Guest54448 joined
[08:40] *** pierre_ joined
[08:42] *** dayangkun joined
[08:46] <pmurias> El_Che: it's still in the thought experiment stage, there seems to be a plugin framework vim-textobj-user that could be hooked in, but I haven't looked into details seriously

[08:50] *** wamba left
[08:52] *** nadim_ joined
[08:53] <El_Che> pmurias: I had a look at the syntastic (wrote a small perl6 plugin for it) for syntax and youcompleteme for semantic support (was not so straight forward)

[08:53] <El_Che> go support is handled by a local web service by example

[08:53] *** labster left
[08:58] *** RabidGravy joined
[09:02] *** bjz left
[09:03] *** bjz joined
[09:03] *** labster joined
[09:07] *** wamba joined
[09:07] *** eliasr joined
[09:08] *** andrzejku joined
[09:09] *** bjz left
[09:10] *** bjz joined
[09:13] *** aries_liuxueyang left
[09:14] *** cyphase left
[09:18] *** sammers left
[09:18] *** cyphase joined
[09:19] *** canopus_ joined
[09:20] *** canopus left
[09:22] *** sammers joined
[09:29] *** andrzejku left
[09:42] *** dayangkun left
[09:48] *** andrzejku joined
[09:48] *** lambd0x left
[09:53] *** confundus joined
[10:07] <dalek> doc: 0bce341 | gfldex++ | doc/Type/WrapHandle.pod6:

[10:07] <dalek> doc: doc class WrapHandle

[10:07] <dalek> doc: review: https://github.com/perl6/doc/commit/0bce34172b

[10:10] *** brrt left
[10:11] *** pierre_ left
[10:11] *** user9 left
[10:11] *** user9 joined
[10:12] <lizmat> gfldex: I wonder whether WrapHandle isn't a rakudo implementation detail

[10:13] <gfldex> lizmat: S06-advanced/wrap.t

[10:13] <gfldex> also .restore is very useful

[10:14] <lizmat> well, yes, but the functionality.  the word WrapHandle doesn't occur in roast

[10:15] <lizmat> and its mention in specs appears to be documenting the state in rakudo, afaics

[10:15] *** MorayJ joined
[10:15] <gfldex> i can't doc a free floating method

[10:16] <lizmat> ah, the restore you mean, ok, fair enough  :-)

[10:17] <gfldex> well, I can if I really have to. And if WrapHandle shall not be named then it may need anonymising in rakudo

[10:17] <lizmat> true

[10:17] <gfldex> not sure if we want that tho as it would create LTA messages

[10:17] *** travis-ci joined
[10:17] <travis-ci> Doc build failed. Wenzel P. P. Peppmeyer 'doc class WrapHandle'

[10:17] <travis-ci> https://travis-ci.org/perl6/doc/builds/162151280 https://github.com/perl6/doc/compare/2061fa71aeba...0bce34172b89

[10:17] *** travis-ci left
[10:18] <lizmat> well, actually, WrapHandle only exists *inside* of wrap

[10:18] <lizmat> m: say WrapHandle

[10:18] <camelia> rakudo-moar e12ebb: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    WrapHandle used at line 1␤␤»

[10:19] <lizmat> so I guess you could argue it *is* anonymous

[10:19] *** confundus left
[10:19] <lizmat> or at least not visible

[10:19] <lizmat> it's just that instances of it *are* externally visible

[10:20] <dalek> doc: 8b3cd79 | gfldex++ | doc/Type/WrapHandle.pod6:

[10:20] <dalek> doc: pod needs to be pod

[10:20] <dalek> doc: review: https://github.com/perl6/doc/commit/8b3cd79139

[10:20] <lizmat> m: dd (sub { }).wrap: sub { }

[10:20] <camelia> rakudo-moar e12ebb: OUTPUT«Routine::WrapHandle.new␤»

[10:21] *** rindolf joined
[10:21] <gfldex> not sure what happends with the search index (and other stuff) if I add Routine:: to the pod

[10:22] <gfldex> we may even want that class inside Routine.pod6

[10:28] *** andrzejku left
[10:28] <lizmat> well, that's where I have doubts

[10:29] *** andrzejku joined
[10:29] <lizmat> I mean, are we documenting how to use, or are we documenting what exists ?

[10:30] <lizmat> because if we're documenting what exists, then there are plenty more classes (e.g. many iterators) that you may run into:

[10:30] <lizmat> many of them don't even have a name

[10:31] <gfldex> we do both atm. We have exists-docs and howto/tutorial docs and we don't mark what is what

[10:31] <gfldex> iterators a covered by roles

[10:36] *** kaare_ joined
[10:42] *** travis-ci joined
[10:42] <travis-ci> Doc build passed. Wenzel P. P. Peppmeyer 'pod needs to be pod'

[10:42] <travis-ci> https://travis-ci.org/perl6/doc/builds/162154116 https://github.com/perl6/doc/compare/0bce34172b89...8b3cd7913901

[10:42] *** travis-ci left
[10:46] *** andrzejku left
[10:49] *** bjz_ joined
[10:49] *** bjz left
[10:51] *** andrzejku joined
[10:52] *** labster left
[10:57] <dalek> doc: 10def9d | (Zoffix Znet)++ | doc/Type/Any.pod6:

[10:57] <dalek> doc: Include purpose of :$label and :$item .map arguments

[10:57] <dalek> doc: 

[10:57] <dalek> doc: psch++ lizmat++ for explaining http://irclog.perlgeek.de/perl6-dev/2016-09-23#i_13262649

[10:57] <dalek> doc: review: https://github.com/perl6/doc/commit/10def9de11

[11:03] <pmurias> El_Che: the problem with writing vim extensions is that vimscript is the worst programming language I have ever seen that's not purposefully designed to be horrible

[11:08] *** pierre_ joined
[11:10] <Woodi> pmurias: right :)  maybe creating vi clone based on Perl6 compiler would be nicer ? :)

[11:10] <Woodi> hi today :)

[11:10] <DrForr> O gawd, don't tempt me :)

[11:11] <Woodi> probably vi don't even use curses and we have Term:: lib ;)

[11:11] <nine> pmurias: I thought one can write vim extensions in other languages, too. Perl being among them.

[11:12] <DrForr> There's :perldo and :perl commands you can use.

[11:13] *** rurban joined
[11:15] <Woodi> todays HN: JITing PHP is better then compiling PHP to C++ :)  or maybe just jitting is better ? somehow my brain *don't want* to accept that :)  https://code.facebook.com/posts/156835038101894/redesigning-the-hhvm-jit-compiler-for-better-performance/

[11:16] <gfldex> Woodi: a JIT can query runtime information, also writing fast C++ is a lot harder then it sounds (and it sounds quite hard)

[11:18] <Woodi> gfldex: I just don't have middle level details on what is usually jitted in runtime... is it concrete string put into asm ? or type information or array size, such things... so hard to even think about that

[11:19] *** andrzejku left
[11:20] <Woodi> btw. there was Perl6 benchmarks showing programs executing in 4-5 seconds and using *milion(s)* function calls... that is shocking...

[11:21] *** pierre_ left
[11:27] *** wamba left
[11:39] *** pierre_ joined
[11:40] *** MasterDuke joined
[11:52] *** andrzejku joined
[11:58] <DrForr> Just in case it doesnt' make it here, https://opensource.com/life/16/9/perl-6-features

[12:02] *** andrzejku left
[12:05] *** andrzejku joined
[12:06] <timotimo> DrForr: the sentence about concurrenly doesn't really say that the "don't do that" thing is only for perl5

[12:07] <timotimo> or maybe that's just because i don't know anything about perl5 users :)

[12:07] <Woodi> (Jeff Goff)++ :)

[12:13] *** wamba joined
[12:15] *** andrzejku left
[12:18] *** andrzejku joined
[12:19] <RabidGravy> Is the interface provided by HTTP::Server::Tiny supported by any other modules (I know it differs from some)?

[12:21] <Woodi> Hard Real World story, somewhere in Africa: "5 reasons for kids absence in schools": 1) "he don't have a sweater..." - winter, less then +10C, and problems with completing school uniform *facedesk*; 2) "hi don't have boots...", .oO(WHAT? Yesterday he have!); 3) parents don't have money for a bus, price: 0.17 euro...; 4) mam is in hospital, she need to take care for younger sister; 5) kids are sick, 

[12:21] <Woodi> sometimes. rarely...

[12:21] <Woodi> I'm selling one of my thinkpads...

[12:26] *** salva left
[12:31] *** gnull joined
[12:32] *** gnull left
[12:33] <Ulti> the file encoding stuff is there a branch around for that or is it in the design thinking stage? I'm writing something that encodes and decodes files to DNA style sequences and it would be kind of cool if I could do that at the IO layer

[12:34] <timotimo> design thinking stage at the moment

[12:34] <Ulti> at the moment I'm working in Python but its all easily ported bitshift stuff

[12:34] <Ulti> timotimo: k k thanks

[12:34] * Ulti will o____O

[12:35] <timotimo> you will what?

[12:36] *** zakharyas joined
[12:36] *** jmark joined
[12:41] <gfldex> m: my enum E1 <A B>; my enum E2 <C D>; sub g(@a) { say @a.all ~~ (E1|E2) }; g([A, C]);

[12:41] <camelia> rakudo-moar e12ebb: OUTPUT«False␤»

[12:41] *** ocbtec joined
[12:41] <gfldex> i did expect True. Am I asking for to much?

[12:44] <timotimo> don't smart match against junctions :)

[12:45] *** cyphase left
[12:47] <gfldex> is there an easy way to get what I want?

[12:47] <timotimo> hmm

[12:48] <timotimo> not so sure

[12:49] <timotimo> gfldex: i know you can build a subset that has "where E1 | E2" and you can smart match against that

[12:50] *** andrzejku left
[12:50] *** wamba left
[12:50] *** cyphase joined
[12:53] <Xliff_> Does anyone know the best way to re-initialize a CArray (I'm using this for STORE)

[12:53] *** Xliff_ is now known as Xliff

[12:53] *** zakharyas left
[12:53] *** whoami__ joined
[12:54] *** whoami__ left
[12:56] *** _slade_ joined
[12:58] <timotimo> i don't know what "re-initialize" means

[12:58] *** confundus joined
[13:00] <Xliff> timotimo: Empty, start over, clear out?

[13:01] <Woodi> Xliff: assign defaults ?

[13:01] <Xliff> Coz if @b is a CArray and you do: @b = Bool.pick(100), you want to make sure that whatever was previously in @b is properly disposed of.

[13:01] *** cyphase left
[13:02] <timotimo> i know you can assign Empty to an Array to empty it out

[13:02] <gfldex> m: my enum E1 <A B>; my enum E2 <C D>; subset E1-or-E2 where * ~~ E1|E2; sub g(@a) { say @a.all ~~ {$_ ~~ E1|E2} }; g([A, C]);

[13:02] <camelia> rakudo-moar e12ebb: OUTPUT«False␤»

[13:02] <Xliff> And I don't see a handy method to do that.

[13:02] <timotimo> don't we expose setelemspos somehow?

[13:02] <timotimo> yeah, nqp::setelems could be what you need

[13:02] <Xliff> That's an Array. CArrays are noticably different, internally.

[13:02] <Xliff> Uh. OK. Thought I looked into that, but will check again. Thanks.

[13:02] <timotimo> VMArray isn't

[13:03] *** mcmillhj joined
[13:03] <Xliff> Yeah. nqp::setelems will work.

[13:04] <gfldex> m: my enum E1 <A B>; my enum E2 <C D>; sub g(@a) { say @a.all ~~ subset :: where * ~~ E1|E2 }; g([A, C]);

[13:04] <camelia> rakudo-moar e12ebb: OUTPUT«True␤»

[13:05] <gfldex> i don't need no stinking names!

[13:05] *** rurban left
[13:06] <gfldex> i better doc that, it's so obscure I will likely forget it within hours :->

[13:06] *** cyphase joined
[13:06] <gfldex> also, $idioms++

[13:07] <Xliff> OK. VERY simple implementation of CArray STORE is about done. I need to test it now. Not sure I will have time to do that before tomorrow.

[13:08] *** cdg joined
[13:11] *** gregf_ left
[13:12] <gfldex> m: my enum E1 <A B>; my enum E2 <C D>; sub g(@a where { .all ~~ subset where * ~~ E1|E2 } ) { say @a }; g([A, C]);

[13:12] <camelia> rakudo-moar e12ebb: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Expected a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use a space like ~ ~)␤at <tmp>:1␤------> 3b g(@a where { .all ~~ subset where * ~~7⏏5 E1|E2 } )…»

[13:12] <gfldex> m: my enum E1 <A B>; my enum E2 <C D>; sub g(@a where { .all ~~ subset :: where * ~~ E1|E2 } ) { say @a }; g([A, C]);

[13:12] <camelia> rakudo-moar e12ebb: OUTPUT«[A C]␤»

[13:13] <dalek> doc: 53f32fd | gfldex++ | doc/Language/typesystem.pod6:

[13:13] <dalek> doc: show anonymous subsets

[13:13] <dalek> doc: review: https://github.com/perl6/doc/commit/53f32fda3d

[13:13] *** brrt joined
[13:14] *** cyphase left
[13:14] *** tushar joined
[13:17] *** sammers left
[13:17] <Woodi> btw. there is new (for me) thing: nullable types - something that automatically allow to have types without NULL :)  do we have something similiar ?

[13:18] <Woodi> except subtypes :)

[13:19] *** cyphase joined
[13:22] <gfldex> m: my Int $i = 42; dd $i; $i = Nil; dd $i;

[13:22] <camelia> rakudo-moar e12ebb: OUTPUT«Int $i = 42␤Int $i = Int␤»

[13:22] <gfldex> Woodi: ^^^ yes, we do

[13:22] <gfldex> m: my int32 $i = 42; dd $i; $i = Nil; dd $i;

[13:22] <camelia> rakudo-moar e12ebb: OUTPUT«42␤Cannot unbox a type object␤  in block <unit> at <tmp> line 1␤␤»

[13:22] <gfldex> with that limitation

[13:27] *** cyphase left
[13:29] *** sammers joined
[13:31] *** MasterDuke left
[13:32] *** cyphase joined
[13:33] *** andrzejku joined
[13:36] *** b2gills joined
[13:39] *** cyphase left
[13:43] <[Coke]> nine: work happened, actually running the stresstest now

[13:44] *** cyphase joined
[13:53] *** cyphase left
[13:58] *** cyphase joined
[14:03] *** pierre_ left
[14:03] <Woodi> gfldex: int32 case is usefull to me. however it's not clear that we thing about that usecase as a positive feature, somewhat oficially :)

[14:04] *** confundus left
[14:04] *** woolfy left
[14:05] *** woolfy joined
[14:09] <RabidGravy> so I started this streaming server thingy before I worked out how to get am existing HTTP server module to do the input streaming partt

[14:09] <RabidGravy> and now I find I got he abstraction horribly wrong

[14:11] <RabidGravy> Ooops

[14:11] <RabidGravy> ==> Testing Pod::To::BigPage

[14:11] <RabidGravy> ===SORRY!===

[14:11] <RabidGravy> Expected MAST::Frame, but didn't get one

[14:11] <RabidGravy> that's unfortunate

[14:11] <arnsholt> Well, that's a hilariously low-level error to get from user code =)

[14:12] <RabidGravy> isn't it just

[14:12] *** skids joined
[14:13] <vcv> m: my Int:D $i = 42; dd $i; $i = Nil; dd $i

[14:13] <camelia> rakudo-moar e12ebb: OUTPUT«Int $i = 42␤Type check failed in assignment to $i; expected type Int:D cannot be itself (perhaps Nil was assigned to a :D which had no default?)␤  in block <unit> at <tmp> line 1␤␤»

[14:13] <vcv> ^- does that count as a non-nullable type?

[14:14] <ilmari> m: my Int:D $i; dd $i

[14:14] <camelia> rakudo-moar e12ebb: OUTPUT«5===SORRY!5=== Error while compiling <tmp>␤Variable definition of type Int:D requires an initializer␤at <tmp>:1␤------> 3my Int:D $i7⏏5; dd $i␤    expecting any of:␤        constraint␤»

[14:14] *** ptolemarch joined
[14:15] <Woodi> vcv: it count as feature I want :)  vcv++  looks nullable types allow to add null to eg. plain int or bool :)

[14:17] *** hlafarge joined
[14:18] *** andrzejku left
[14:23] *** pnull_ joined
[14:23] *** wamba joined
[14:25] *** rurban joined
[14:30] <RabidGravy> So that error from Pod::To::BigPage has been there for two months: https://github.com/gfldex/perl6-pod-to-bigpage/issues/1

[14:31] *** andrzejku joined
[14:31] *** djbkd left
[14:33] <nine> jnthn: how bad is Str.^find_method("Stringy").wrap(sub ($self) { ... }) in terms of "oh please, don't ever do this in production code!"?

[14:34] *** djbkd joined
[14:38] *** maybekoo2 joined
[14:39] *** beatdown joined
[14:40] <Woodi> nine: Lisp and asm are used in production ;)

[14:41] <nine> Woodi: I'm asking about rakudo's implementation specifically

[14:45] <nine> Ok, now that I have this syntax actually work with DBIx::Class, I guess it's time to think about real complicated queries: my $homepages = select $articles where {"name=$name and active=$active"};

[14:45] <mst> oh, cool, you're prototyping the boring bits of that for me

[14:46] <mst> nine: I have plans for modifying SQL::Abstract to accept a less-DWIM-more-explicit syntax

[14:46] <mst> so later we should be able to get to 'SELECT *.articles WHERE *.name eq $name AND $.active eq $active'

[14:46] <mst> we'll see though

[14:47] <mst> (this is why I wanted to know if I could do .* as a postfix op ;)

[14:47] <RabidGravy> nine, I certainly would be think twice before doing that in fairly high level production code

[14:47] <nine> mst: it's from a lightning talk I gave yesterday. Born at yesterday's discussion over lunch: http://niner.name/talks/DBIC%20in%20Perl%206%20revisited/

[14:47] <RabidGravy> but if it was in something that was "infrastructural" then it would be fine

[14:48] <RabidGravy> FWIW, I have something that passes nearly all of SQL::Abstract's tests for the DWIMmey syntax

[14:48] <mst> nine: well worth discussing with #dbix-class

[14:50] <nine> RabidGravy: is it online somewhere?

[14:52] <RabidGravy> nine, https://github.com/jonathanstowe/Squirrel - haven't touched it for a while

[14:52] *** beatdown left
[14:52] *** beatdown joined
[14:54] *** rurban left
[14:54] <RabidGravy> my medium term plan is to actually use a functional syntax primarily and make the SQLA syntax a facade

[14:54] *** confundus joined
[14:55] <nine> Thinking a bit more about this, with enough type-ing we may be able to define all the infix operators without even having to hijack string interpolation. prefix:<select> (ResultSet) is the entry point. All the infixes just have to take an appropriate type for the left hand argument and return the type needed for the next operator

[14:57] *** Khisanth left
[14:57] <mst> nine: this is why I was planning to use uppercase keywords

[14:57] *** girafe joined
[14:57] <mst> also, 'select $rs' makes no sense at all, did you mean 'from' ?

[14:59] <nine> now that you mention that, indeed I did

[15:01] *** sufrostico left
[15:01] *** confundus left
[15:04] *** pierre_ joined
[15:05] <mst> RabidGravy: functional syntax?

[15:05] *** pnull_ left
[15:05] <mst> (I inherited SQLA's syntax a decade ago, I'm always interested in better ways)

[15:06] <RabidGravy> functional? syntax?

[15:06] <mst> < RabidGravy> my medium term plan is to actually use a functional syntax

[15:06] <mst> you're the one who said those words

[15:06] <mst> I can't tell you what you meant

[15:06] <mst> that's why I'm asking

[15:06] <RabidGravy> like "SELECT(<list of stuff>, FROM(<stuff>), WHERE(<etc>))"

[15:07] <mst> right

[15:07] <mst> so more like Data::Query than SQL::Abstract

[15:07] <RabidGravy> yes, but I don't know which part you were having difficulty with ;-)

[15:07] <mst> (I have a version of SQLA that runs on top of DQ)

[15:07] <mst> well, honestly, I was more interested in your thoughts about operators and parameterization

[15:08] <mst> but apparently by 'functional syntax' you just meant the obvious boring part :P

[15:08] <mst> anyway, I'd be interested to see any sketches of that with the <stffu> and <etc> filled out

[15:09] *** pierre_ left
[15:09] <RabidGravy> I basically see it as being a bunch of Term objects under the hood, the actual syntax isn't much fun

[15:10] <RabidGravy> the DWIM thing with SQLA is waaaay over-generous

[15:10] *** Khisanth joined
[15:13] <RabidGravy> so I think for the second cut of this I would start at the bottom and find the types that would be composed into a complete SQL statement and add e.g. the "functional syntax" over that

[15:13] <mst> right, Data::Query provides fairly low level stuff

[15:13] <mst> but is slightly more complicated than it needs to be

[15:13] <mst> my plan is basically to do it again with a more explicit SQLAish syntax

[15:13] <mst> i.e.

[15:13] <mst> [ -op, '=', [ -ident, 'foo' ], [ -value, $bar ] ]

[15:14] <mst> have the current DWIM syntax expand to that and thhen get rendered

[15:14] <mst> and then build a better top level atop that

[15:15] *** acrussell joined
[15:15] <vcv> m: 'abc'.comb.join

[15:15] <camelia> rakudo-moar e12ebb: ( no output )

[15:17] <nine> The idea behind the string interpolation trick is that I'm just sick of trying to fit working SQL statements into my ORM's special snowflake syntax. Everything people really want is not having to type lists of field names and join conditions. So just provide shortcuts for those on top of otherwise standard SQL.

[15:19] <mst> sadly, you can't entirely do cross-platform LIMIT without being able to introspect the WHERE clause

[15:20] <mst> other than that though

[15:20] *** brrt left
[15:20] <mst> the key thing you really need is some way to do alias management

[15:21] <mst> consider e.g. an EAV table where you want to LEFT JOIN attributes a1 ON thing.id = a1.id AND a1.key = 'foo' LEFT JOIN atttributes a2 ON thing.id = a2.id AND a2.key = 'bar' WHERE a2.value = 'baz'

[15:21] <mst> you'll get quite a long way with "just feed it SQL", but not as far as you might hope

[15:22] <mst> (one of the many things I've learned the hard way ;)

[15:25] *** khw joined
[15:25] <mst> basically, you'll get a very nice 80% solution that way, but there's things people do with DBIC that would be ... tricky ... in such a situation

[15:25] <mst> (of course the answer for perl6 there may be 'yeah, and we can parse the SQL and transform it')

[15:26] <[Coke]> (ORM) I don't think I've ever worked on a project with a DB and thought "ORM will make this easier." 

[15:27] *** domidumont left
[15:27] <mst> most ORMs are terrible. DBIx::Class is significant less terrible than average, because most of the developers actually like databases

[15:28] <vcv> ORM can make things easier to start.  once your project using it starts to scale, then it can all fall apart quickly

[15:28] <nine> mst: introspection of the where clause is not an issue when I parse the whole SQL thing into an AST.

[15:29] <nine> Or I just don't understand what the problem is

[15:30] <mst> nine: right, using it as another surface syntax is fine

[15:30] <mst> I'm just saying that you're still going to need an AQT underneath

[15:32] <nine> Absolutely. I have no illusions about the size of such a project. Otherwise I'd have started it long ago :) Even the lightning talk was more an answer to "why would you even want to combine Perl 5 and 6?" than anything else.

[15:34] <mst> heh, yeah

[15:43] <nine> Instead of quoting the SQLValue, it would also be better to just replace it by ? and stash it somewhere so we don't lose the type information. And because of all the other benefits of using placeholders.

[15:44] <mst> anyway, if I get a chance to hack on SQLA I suspect I can give you a much easier set of primitives to use under the hood once you've parsed the SQL

[15:45] <mst> I was going to do this earlier this year but ribasushi was insistent that he had offline work he needed to push, but wouldn't tell us what or when :(

[15:53] <dalek> doc: 39b1226 | coke++ | doc/Type/WrapHandle.pod6:

[15:53] <dalek> doc: fix whitespace

[15:53] <dalek> doc: review: https://github.com/perl6/doc/commit/39b122622c

[15:56] *** _slade_ left
[15:56] *** kaare_ left
[15:56] *** kaare_ joined
[15:57] *** ocbtec left
[16:11] *** _slade_ joined
[16:11] *** mcmillhj left
[16:12] *** hlafarge left
[16:16] *** robertle joined
[16:22] *** _slade_ left
[16:27] *** buggable left
[16:28] *** hackedNODE joined
[16:39] *** andrzejku left
[16:39] <RabidGravy> gfldex, I'm going to make a rakudobug for the https://github.com/gfldex/perl6-pod-to-bigpage/issues/1 as that is just not right at all

[16:42] *** _slade_ joined
[16:43] *** zakharyas joined
[16:45] <RabidGravy> not sure where to start golfing it, however it appears that it is related to the number of multi sub handle

[16:46] *** _slade_ left
[16:46] *** mcmillhj joined
[16:52] *** lichtkind joined
[16:53] *** andrzejku joined
[16:54] <RabidGravy> ah no, talking bullshit here, Pod::To::BigPage *does* use LWP::Simple, commenting out the sub where it does that causes it to load fine

[16:58] *** FROGGS joined
[16:59] <hackedNODE> RabidGravy: there's an Issue for it in LWP::Simple: https://github.com/perl6/perl6-lwp-simple/issues/3

[17:00] <hackedNODE> RabidGravy: and the issue is due to its trying to require in mainline: https://github.com/perl6/perl6-lwp-simple/blob/master/lib/LWP/Simple.pm#L8

[17:00] *** lichtkind_ joined
[17:01] <hackedNODE> I think if it's changed to sub {try require IO::Socket::SSL;}() it might be fixed

[17:01] <RabidGravy> Oh man

[17:01] <hackedNODE> (though the MAST::Frame error is very LTA)

[17:01] <RabidGravy> (I fixed the same problem in HTTP::UserAgent about a year ago _

[17:02] *** sufrostico joined
[17:03] *** domidumont joined
[17:03] *** domidumont left
[17:03] *** domidumont joined
[17:04] *** lichtkind left
[17:05] *** domidumont left
[17:05] *** domidumont joined
[17:05] *** pierre_ joined
[17:07] * RabidGravy goes after that rather than dicking around with the symptoms

[17:09] *** firstdayonthejob joined
[17:10] *** pierre_ left
[17:11] *** confundus joined
[17:12] *** confundus left
[17:12] *** adu joined
[17:12] <stmuk_> I think all module installation on all BSD variants is broken 

[17:12] <stmuk_> post ac1987

[17:13] *** sjoshi joined
[17:17] <nine> stmuk_: odd considering ac1987 is fairly high level

[17:19] <stmuk_> it may be a Moar bug

[17:20] <stmuk_> https://github.com/MoarVM/MoarVM/issues/410

[17:20] *** zakharyas left
[17:23] <RabidGravy> right, fixed the LWP::Simple it would appear

[17:26] <hackedNODE> \o/

[17:26] *** xinming_ joined
[17:26] <hackedNODE> It's worth rakudobugging the issue, fixing the LTA error, and adding a roast test for it.

[17:28] <captain-adequate> Oooooo. I just found perl mogrify.

[17:28] <captain-adequate> https://github.com/drforr/Perl-Mogrify

[17:28] <ugexe> stmuk_: do the modules Test/NativeCall/etc get installed at the end of `make install` rakudo?

[17:29] *** xinming left
[17:30] <hackedNODE> That sounds like a bad idea :) Or rather a recipe for receiving awful code :)

[17:30] <RabidGravy> though there does appear to be a problem with parsing the response from gitthub

[17:31] *** hackedNODE left
[17:34] *** hankache joined
[17:37] *** MorayJ left
[17:38] *** domidumont left
[17:39] <bioduds_> hi guys, acessing sqlite and trying to retrieve info from it also the same problem as loading a custom module

[17:39] <bioduds_> I seem to lack the ability to track the cause of it

[17:39] *** sjoshi left
[17:40] *** wamba left
[17:48] *** andrzejku left
[17:50] <harmil_wk> bioduds_: do you have some context?

[17:50] <bioduds_> oh, sorry, it was a problem I'm having that I reported yesterday

[17:51] <bioduds_> it is a server call I'm doing from Meteor

[17:51] <bioduds_> there is a gist, I just don't know where it is, sorry

[17:52] *** acrussell left
[17:52] *** acrussell joined
[17:53] *** acrussell left
[17:53] <RabidGravy> there

[17:54] *** domidumont joined
[17:54] <RabidGravy> the LWP::Simple and all related problems should be fixed now

[17:56] <gfldex> RabidGravy: thanks

[17:56] *** zakharyas joined
[17:58] *** Actualeyes left
[17:59] <RabidGravy> I can't believe that it was left like that for so long

[18:02] <El_Che> good evening

[18:04] <stmuk_> ugexe: yes those are installed OK .. its more an issue with panda and zef

[18:04] <stmuk_> I've investigated zef less

[18:04] <[Coke]> wasn't the meteor problem meteor?

[18:06] *** Guest54448 left
[18:07] <timotimo> what was wrong with it? everything? :)

[18:07] <[Coke]> didn't like the precompile step, IIRC

[18:08] *** andrzejku joined
[18:12] *** Actualeyes joined
[18:14] <RabidGravy> [Coke], can you check your https://github.com/gfldex/perl6-pod-to-bigpage/issues/1 with the latest LWP::Simple? I think I fixed it

[18:25] *** adu left
[18:26] *** adu joined
[18:28] *** dmaestro joined
[18:33] <dmaestro> rakudo: say "Hello"

[18:33] <camelia> rakudo-moar 76d585: OUTPUT«Hello␤»

[18:35] *** cdg left
[18:35] *** FROGGS left
[18:36] <dmaestro> p6: say "Hello"

[18:36] <camelia> rakudo-moar 76d585: OUTPUT«Hello␤»

[18:42] *** AlexDaniel joined
[18:49] *** zakharyas left
[18:49] *** zakharyas joined
[18:53] *** zakharyas left
[18:55] *** kmwallio joined
[18:57] *** kerframil joined
[19:01] *** khw left
[19:03] *** domidumont left
[19:07] *** pierre_ joined
[19:11] *** maybekoo2 left
[19:13] *** pierre_ left
[19:17] *** dmaestro left
[19:18] *** dmaestro joined
[19:21] *** LegalResale left
[19:23] *** LegalResale joined
[19:23] *** __curiousgeorge_ joined
[19:24] *** _slade_ joined
[19:27] *** __curiousgeorge_ left
[19:31] *** Ulfalizer joined
[19:31] *** Ulfalizer left
[19:33] *** hackedNODE joined
[19:34] <hackedNODE> What exactly is the difference between .categorize-list and .classify-list?

[19:34] <hackedNODE> m: dd BagHash.new.classify-list: { $_ %% 2 ?? 'even' !! 'odd' }, ^10

[19:34] <camelia> rakudo-moar b3c92b: OUTPUT«("even"=>5,"odd"=>5).BagHash␤»

[19:34] <hackedNODE> m: dd BagHash.new.categorize-list: { $_ %% 2 ?? 'even' !! 'odd' }, ^10

[19:34] <camelia> rakudo-moar b3c92b: OUTPUT«("even"=>5,"odd"=>5).BagHash␤»

[19:38] *** tushar left
[19:39] *** cowens joined
[19:41] *** Actualeyes left
[19:41] <cowens> Is it really true that Perl 6 is intentionally designed such that it can't roundtrip Unicode?  perl -CO -E 'say "e\x{301}"' | perl6 -ne '.say' | perl -CI -ne 'printf "U+%04x\n", ord for split //'

[19:42] *** darutoko left
[19:42] <hackedNODE> cowens: that's a bit of a loaded question. It uses graphemes and normal whatever form. You're giving a character and receive normalized form and then say "this is broken; is it true Perl 6 was designed to be broken"

[19:42] <hackedNODE> m: say "e\x[301]".chars

[19:42] <camelia> rakudo-moar b3c92b: OUTPUT«1␤»

[19:43] <ugexe> but why cant it automatically know what i want??

[19:43] <hackedNODE> :)

[19:44] <hackedNODE> m: say "\x[E9]" eq "e\x[301]"

[19:44] <camelia> rakudo-moar b3c92b: OUTPUT«True␤»

[19:44] <harmil_wk> cowens: are you just eavesdropping? :-)

[19:45] <hackedNODE> cowens: ^ see. It normalized them into a single representation, which is what a human would expect when seeing a é character. If you want to preseve the details of combinations and such there are .NFG .NFC .NFK or something like that methods

[19:45] <hackedNODE> We still kinda lack decent user docs for that area

[19:46] <harmil_wk> cowens: You can preserve an ordered list of bytes if that's what you want (Buf does this) but if you wanted a high-level string object, then you cannot assume that it's ordering the bytes the way you assumed.

[19:49] <cowens> Sorry, had to deal with work stuff, reading stuff now

[19:50] <hackedNODE> If you read bytes from $*IN and write them to $*OUT, you'll "roundtrip" Unicode

[19:50] <cowens> So, the only way to preserve a document that is being read in is to use a buf

[19:50] <timotimo> right, it'll do normalization if you treat it as strings

[19:50] <cowens> But all of the high-level string functions won't work?

[19:50] <timotimo> you can also read it as a latin1 string

[19:50] <cowens> or do some of them work on bufs?

[19:51] <timotimo> latin1 strings will act just like a buf8, but it'll let you do string functions

[19:51] <timotimo> but you'll be prone to composing characters being broken apart and stuff like that

[19:51] *** hackedNODE left
[19:51] <cowens> Say I want to replace a person's name, but leave a document in the state it was found otherwise, I would I do that?

[19:52] <ugexe> open with the proper encoding?

[19:52] <cowens> whoops, that should have been "How would I do that?"

[19:52] <timotimo> that could work, but you might want to be careful at the end

[19:52] <cowens> UTF-8

[19:52] <timotimo> ugexe: that'll cause normalization on the way

[19:53] *** cyphase left
[19:54] <AlexDaniel> cowens: it is unrelated to your question, but I'm still curious why. What's the reason to keep unnormalized data?

[19:56] <cowens> Basically, what I want is something like cat file | perl -CIO -pe 's/name/newname/' that doesn't trash the rest of the document WRT what form it is in (ie if it is in NFD, it stays NFD, if it is in NFC, it stays in NFC, if it isn't in a normal form, then it stays in its form)

[19:57] <cowens> I don't want to have to add metadata to the system to tell me which files are in which form and I don't want them changing form

[19:57] <AlexDaniel> cowens: I got that. But why? It's not trashing it, it is fixing it.

[19:57] *** cyphase joined
[19:57] *** diakopter___ joined
[19:57] <cowens> How is changing an NFD file into NFC "fixing" it?

[19:58] *** diakopter___ left
[20:00] <geekosaur> isn't this the usecase for a Buf?

[20:00] <AlexDaniel> well, if your *goal* is to have data in NFD, then yeah, it does not help.

[20:00] <geekosaur> basically, encodings are a nightmare no matter what; if you want to treat it as binary data, use Buf instead of Str

[20:01] <cowens> My *goal* is not to have to worry about what form it was in or mucking it up for whatever is going to read it next

[20:01] <pmurias> cowens: if you don't want to change the orginal encoding you can treat it as binary data

[20:01] <cowens> Can I still do regexes and string operations on Bufs?  I haven't really looked into them.

[20:01] <timotimo> we'll be able to - in the future - keep mixed-normalization-files roundtrippable

[20:02] <timotimo> and still use string operations on them

[20:02] <cowens> Okay, so this is a temporary bug then?

[20:02] <timotimo> it'll take a few months for that

[20:02] <geekosaur> (note, you are not treating your data as UTF-8 because UTF-8 has things to say about normalization --- specifically, it recommends the normalization that perl6 is doinh)

[20:02] <timotimo> i.e. it's not a priority at the moment

[20:02] <AlexDaniel> m: say Buf.new(104, 101, 108, 108, 111) ~~ /hello/

[20:02] <camelia> rakudo-moar b3c92b: OUTPUT«Cannot use a Buf as a string, but you called the Str method on it␤  in block <unit> at <tmp> line 1␤␤»

[20:02] <timotimo> what, utf-8 suggests things about normalization?

[20:02] <timotimo> i didn't know that

[20:03] <geekosaur> they even recommend specific normalization schemes for specific use cases

[20:03] <cowens> Yeah, NFD for doing work and NFC for storing

[20:03] <cowens> But that is a very loose recommendation

[20:03] <pmurias> cowens: it's more a missing feature than a temporary bug

[20:04] <cowens> Eh, I consider it bug that you can't implement cat unless you drop down to the binary level

[20:04] <timotimo> or use latin1 encoding

[20:05] <cowens> I try to pretend like latin1 doesn't exist anymore

[20:07] <cowens> Are there any docs on NFG?

[20:07] <cowens> Like how NFG differs from NFC?

[20:08] *** domidumont joined
[20:12] <timotimo> latin1 is just "use the buf8 as a Str"

[20:12] <timotimo> if you know what you're doing, you can handle simple substitutions, i'd say

[20:13] <ugexe> can always use unpack("A*") if the word "latin1" is a personal trigger

[20:14] *** girafe left
[20:16] <cowens> What I really want is a language that lets me treat "e\x[301]" and "\xe9" as the being string equivalent without them being the codepoints being changed.

[20:21] *** domidumont left
[20:23] *** cdg joined
[20:24] <cowens> Here is a perfect example of why roundtripping is important

[20:24] *** kaare_ left
[20:24] <cowens> Say I have a DB that is broken WRT Unicode

[20:24] <cowens> it has name columns that are stored in UTF-8, but it knows nothing about NFC, NFD, etc.

[20:25] <cowens> there is a DB dump file that needs to be tweaked

[20:25] <cowens> In order to use Perl 6, I would either need to fix the DB and all of the related systems

[20:25] *** Peter_R left
[20:26] <cowens> or use Buf, which appears to be a second class citizen data type

[20:26] <cowens> Or, I could just use Perl 5 and not worry about it.

[20:27] <[Coke]> sure.

[20:27] <[Coke]> we like Perl 5 here. Have fun.

[20:27] <cowens> I want to use Perl 6.

[20:27] <ugexe> you are offering to implement this in perl6 for us then?

[20:27] <cowens> Heh.

[20:27] <[Coke]> cowens: so use Inline::Perl5 (or Inline::Perl6 if you want to go the other way). pick and choose, sure.

[20:28] *** labster joined
[20:28] <[Coke]> My recommendation for your "only change those bits" would be to treat the file as a whole as a Buf, and the bits you care about as strings as Strings. Then you can write them back out in whatever encoding you want, leaving the rest behind.

[20:29] <pmurias> cowens: we agree that being to work on data in a way where the exact way characters is preserved is important

[20:29] <[Coke]> You'll have to treat different things differently, though.

[20:29] <cowens> How do you propose finding those bits if you are using Bufs instead of Str?

[20:29] <pmurias> cowens: it's just that other things are important too so it hasn't been implemented yet

[20:30] <cowens> I am not sure how it can be implemented based on what I am reading in the docs

[20:30] <[Coke]> cowens: i don't know what your proposed bits look like. You're the one who said you wanted to change them, I assumed you could find them. :)

[20:30] *** ptolemarch left
[20:30] <cowens> With a regex, sure, but I can't use a regex.

[20:31] <cowens> Given what I am hearing about Str, it sounds like NFC/NFG is baked into the type.

[20:31] <cowens> Is the right answer a third type?

[20:31] <cowens> something between Buf and Str?

[20:31] <[Coke]> Each of the NF*'s has a type.

[20:32] <cowens> Yeah, but only the normal forms

[20:32] <cowens> there is no unnormalized string format

[20:32] <[Coke]> if it's not normal, it's bytes, no?

[20:32] <[Coke]> right, that's a Buf.

[20:32] <cowens> which is what I guess I am looking for

[20:32] <cowens> No, unnormalized is not bytes

[20:32] <cowens> "e\x[301]\xe9" is not bytes

[20:33] <cowens> it is a perfectly valid string

[20:34] <cowens> Unless my understanding of Unicode is deeply wrong

[20:34] <cowens> Which is a possibility.

[20:34] <[Coke]> well, don't think I know what I'm talking about. :)

[20:35] <pmurias> [Coke]: wouldn't unnormalized be bytes+encoding

[20:35] <[Coke]> I'm sure our unicode/string expert will weigh in in backlog.

[20:35] <AlexDaniel> m: ‘⚧’.uniname.say

[20:35] <camelia> rakudo-moar b3c92b: OUTPUT«MALE WITH STROKE AND MALE AND FEMALE SIGN␤»

[20:35] <[Coke]> pmurias: yah, don't listen to me. workweek is nearly over, I'm checked out. :)

[20:36] <AlexDaniel> male with stroke huh

[20:36] *** adu left
[20:37] *** andrzejku left
[20:37] <cowens> Also, can you use regexes and stuff on the NF* types?  I didn't see anything about that when I was glancing through the docs

[20:39] *** TEttinger left
[20:40] *** TEttinger joined
[20:43] <timotimo> so how would we go about getting a Uni out of a file without any normalization applied at all?

[20:44] *** cpage_ left
[20:44] <cowens> Is Uni the type I am looking for?

[20:45] <cowens> basically just codepoints without normalization?

[20:47] <pmurias> cowens: yes

[20:47] <harmil_wk> cowens: I'm confused by your premise. It seems like you're interpreting normalization of strings as "damage" but you haven't clarified why that is.

[20:48] <timotimo> it exists, but you mostly get Uni objects with the .NORMFORM methods

[20:48] <cowens> Applying normalization when it isn't asked for makes changes.

[20:49] <cowens> The DB example I gave is a good one

[20:49] <harmil_wk> cowens: okay... so does reading a value into an integer.

[20:49] <cowens> Yes, it is broken that the DB doesn't store in NFC, but I don't have time to fix that and every other system touching it

[20:49] <ugexe> m: my $buf = Buf.new(1); say $buf.^find_method("chars"); say $buf.chars; # it'd be nice if method chars wasn't exposed via .^methods if its just there to throw an exception telling you that you cant

[20:49] <camelia> rakudo-moar b3c92b: OUTPUT«chars␤Cannot use a Buf as a string, but you called the chars method on it␤  in block <unit> at <tmp> line 1␤␤»

[20:50] <cowens> In what way does turning the string "123" into the number 123 and then back to the string "123" remove or change information?

[20:51] <cowens> whereas reading in "e\x[301]" from a file and then outputting it changes it into "\xe9" currently

[20:51] <cowens> That is damage

[20:51] <harmil_wk> cowens: I don't think your DB example makes any sense. The DB doesn't care about composition does it? Why would this be an issue? Also, if you're operating on binary data that happens to have string in it, then that's not the same as a unicode string, and you should expect failure.

[20:51] <cowens> Perl 6 wasn't asked to do that

[20:51] <cowens> it cares about it when it goes to compare the strings

[20:51] <harmil_wk> It most certainly was. You asked for a string, not a blob of bits

[20:52] <cowens> because it is broken WRT to Unicode and doesn't know "e\[301]" and "\xe9" should compare as the same

[20:52] <AlexDaniel> m: say ‘２５’.Int.Str # Oops

[20:52] <camelia> rakudo-moar b3c92b: OUTPUT«25␤»

[20:52] <harmil_wk> If you have a blob of bits that you don't want to coerce into a string, then don't coerce them into a string. If there are little bits of that binary blob that you want to treat as if they were strings, do so, but don't expect that interface to be clean and simple, because Unicode isn't clean or simple

[20:53] <harmil_wk> Perl 6 just happens to clean up that interface at a different level of abstraction that some languages.

[20:53] <cowens> Coming from other languages, in particular Perl 5, there is a certain expectation that reading a file into a string doesn't change the bits

[20:53] <harmil_wk> That's not a valid assumption in most modern, high level, Unicode-aware languages. Stop doing that.

[20:54] <AlexDaniel> cowens: I agree with you that there should be a way to do what you want, but this particular expectation is just wrong

[20:54] *** Guest60806 joined
[20:54] <harmil_wk> Bits are bits. Strings are strings. You can't just mash the two into each other and hope.

[20:55] *** ufobat left
[20:55] <cowens> What is the raison d'être of Perl 6?

[20:55] <cowens> I had assumed it was string processing like Perl 5.

[20:56] <ugexe> m: say "e\x[301]">>.ord ~~ "\x[e9]">>.ord

[20:56] <camelia> rakudo-moar b3c92b: OUTPUT«True␤»

[20:56] <harmil_wk> cowens: there is no one answer to that question. it's certainly not limited to string processing.

[20:56] <lizmat> cowens: it's the programming language for the next 100 years  :-)

[20:56] <harmil_wk> Compilation is really the first and most critical target (since it's self-hosting) of course.

[20:56] <harmil_wk> After that, all the things is pretty accurate.

[20:57] *** cdg left
[20:57] <cowens> It isn't limited to string processing, but Perl has historically been the goto language for string processing

[20:57] *** cdg joined
[20:58] <cowens> Should I not look to Perl 6 for string processing?

[20:58] <AlexDaniel> .oO( string processing! Not byte processing, right? )

[20:58] <cowens> Should I not expect to be able to easily roundtrip a file?

[20:58] <harmil_wk> cowens: You're not describing a string processing use case, though. You're describing a binary data use case that you wish to seamlessly treat as a string processing use case under certain circumstances.

[20:58] <pmurias> AlexDaniel: what cowens wants to do is code points processing

[20:59] <cowens> Yeah, pretty much codepoint processing

[20:59] *** cdg left
[20:59] <cowens> I am having a hard time understanding why the codepoints have to change

[20:59] *** ufobat joined
[20:59] <cowens> Why Str is forcing a normalization on me

[21:00] <harmil_wk> cowens: because Unicode is a mess, essentially. And in order to make strings more reasonable, we de-messify it as much as possible.

[21:00] *** cdg joined
[21:00] <harmil_wk> There was a great talk about this at a recent YAPC

[21:00] * harmil_wk looks for the link...

[21:00] <cowens> Yeah, but it is a mess and I can't always normalize for that reason

[21:00] <cowens> and I don't want to have to turn into a second class citizen because I can't normalize

[21:01] <cowens> I understand I can't do it now

[21:01] <AlexDaniel> m: say so ‘hello world’.ords ~~ (**, |‘world’.ords, **)

[21:01] <camelia> rakudo-moar b3c92b: OUTPUT«True␤»

[21:01] <AlexDaniel> m: say so ‘hello world’.ords ~~ (**, |‘foo’.ords, **)

[21:01] <camelia> rakudo-moar b3c92b: OUTPUT«False␤»

[21:01] <cowens> And I here people saying "you will be able to do it in the future" and people saying "why do you want that, you should do byte level stuff"

[21:02] <harmil_wk> cowens:  oh, you can do just about anything. But reading a blob of binary data as if it were a string and doing string-like processing on it, while carefully preserving its binary representation... that's just a bit harder.

[21:02] *** nadim_ left
[21:02] <harmil_wk> You could certainly write your own class that managed data that way, based on buf, implementing Cool and otherwise doing the things you might expect.

[21:02] <cowens> I am not even talking about binary representation

[21:02] <harmil_wk> cowens: yes you are, you just don't think you are.

[21:03] <cowens> I am talking about codepoint level representation

[21:03] <timotimo> cowens: AFAIK, Uni doesn't give you a lot of stringy functions, so it's similar to Buf, too. but i'm not 100% on that

[21:03] <timotimo> in the near future we're going to decouple encoding/decoding and normalization

[21:03] <timotimo> so your use case will become a bit more easily doable then, i expect

[21:03] <cowens> I can re-encode it to UTF-16le or whatever and the same codepoints will be there

[21:03] *** girafe joined
[21:04] <cowens> but the byte level will change

[21:04] <pmurias> cowens: the people asking "why do you want that" seem to be the ones who hate codepoints ;)

[21:04] <cowens> It seems like Perl6 has byte level (Buf) and string level (Str) but no middle layer

[21:05] <pmurias> Uni is the middle layer

[21:05] <pmurias> it's just not implemented yet

[21:05] <cowens> Well, they aren't alone, I would love to live in a perfect world where I didn't have to care about codepoints, but they matter to heck of a lot of broken legacy code

[21:06] <timotimo> pmurias: it is implemented. we just don't have a way to get directly from file to Uni without normalization

[21:06] <timotimo> i think.

[21:06] <cowens> So, if Uni is the right type, how would you read them in?  As a Buf and then convert?

[21:06] <timotimo> you just have to write your own utf8 decoder right now

[21:06] *** cdg left
[21:06] *** mcmillhj left
[21:07] *** cdg joined
[21:07] <timotimo> read the file contents into a 32bit buf, then feed it directly into a Uni

[21:07] *** skids left
[21:07] <pmurias> timotimo: what I meant is that operations on Uni are not implemented yet

[21:07] <timotimo> oh

[21:07] <timotimo> what are we going to get to be used on Uni? everything that Str has?

[21:08] *** ufobat left
[21:09] <pmurias> timotimo: I'm not the language designer

[21:09] *** pierre_ joined
[21:10] <timotimo> right

[21:11] <pmurias> timotimo: I assume we will want equivalents of most of the things that Str has

[21:11] <timotimo> regexes on Uni will be interesting

[21:12] <timotimo> regexes on Cat will be ... amazing

[21:14] *** pierre_ left
[21:17] *** thundergnat joined
[21:18] <thundergnat> \o #perl6

[21:20] <timotimo> yo

[21:21] <timotimo> long time no see, or am i imagining things?

[21:21] <thundergnat> Hi timotimo, I lurk daily but rarely sign on. 

[21:21] <timotimo> ah

[21:22] <thundergnat> My employer doesn't allow IRC but I read the logs.

[21:22] <thundergnat> I'm having an issue with what seems to be "my" variables leaking in a recursing subroutine. It may be that I need to adjust my expectations though.

[21:22] <timotimo> hopefully you're not using the REPL?

[21:23] <thundergnat> Nope. Let me put up a gist real quick.

[21:23] <timotimo> k

[21:23] <thundergnat> m: https://gist.github.com/thundergnat/cfbdee0c0c73daac724aeaf93eca564

[21:23] <camelia> rakudo-moar b3c92b: OUTPUT«gist not found»

[21:23] <thundergnat> err..

[21:23] <thundergnat> m: https://gist.github.com/thundergnat/cfbdee0c0c73daac724aeaf93eca5649

[21:23] <camelia> rakudo-moar b3c92b: OUTPUT«1) 9␤2) 8␤    1) a␤    2) b␤3) 7␤4) 6␤    1) a␤    2) b␤3) 15␤4) 11␤5) 0␤»

[21:24] <thundergnat> hard to tell in here, but I would expect the $count variable of the outer sub not to be incremented by the inner.

[21:24] *** canopus_ left
[21:25] <timotimo> that's what we call a closure

[21:26] <timotimo> the inner subs close over the variable, so they get access to it

[21:26] <thundergnat> even though it recurses and declares its own $count variable?

[21:27] <timotimo> oh, you mean the call to list()

[21:27] <timotimo> right, let me re-read :)

[21:27] <timotimo> indeed, that ought to get its own $count

[21:28] <perlpilot> it would be easier to read if it didn't use subs called "item" and "list"  ;)

[21:28] <AlexDaniel> haha, yes

[21:28] <timotimo> m: say item

[21:28] <camelia> rakudo-moar b3c92b: OUTPUT«()␤»

[21:28] <timotimo> it might be problematic that a sub "item" already exists outside

[21:28] <AlexDaniel> committable6: releases https://gist.githubusercontent.com/thundergnat/cfbdee0c0c73daac724aeaf93eca5649/raw/79f6a504e4d48c4e1f50ff0c761ef26e6c6b97d8/leaky.p6

[21:28] <committable6> AlexDaniel, Successfully fetched the code from the provided URL.

[21:28] <committable6> AlexDaniel, ¦«2015.10»: ===SORRY!=== Error while compiling /tmp/SgrNtWbw4J␤Undeclared routine:␤    put used at line 13␤ «exit code = 1»␤¦«2015.11,2015.12,2016.02,2016.03,2016.04,2016.05,2016.06,2016.07.1,2016.08.1,HEAD»: 1) 9␤2) 8␤    1) a␤    2) b␤3) 7␤4) 6␤    1) a␤    2) b␤3) 15␤4) 11␤5) 0

[21:28] <timotimo> this is a long shot, but what if you declare a proto sub item inside your list sub?

[21:28] *** mcmillhj joined
[21:28] <timotimo> also, having the other sub called list is also ... :)

[21:29] <cowens> regexes on Uni shouldn't be anymore interesting that Perl 5 regexes are currently

[21:29] <thundergnat> sorry, piece of a larger program, the names are actually different, I was trying to make a minimal example and failed at naming :-/

[21:29] <cowens> The interesting thing is will . match a code point or grapheme

[21:30] *** girafe left
[21:30] <timotimo> at some point we had speculated about lexical modifiers for that decision

[21:30] <cowens> Perl 5 is codepoint with \X matching grapheme

[21:30] <AlexDaniel> wow I think I forgot that “put” is so new

[21:30] <AlexDaniel> bisect: old=2015.10 put()

[21:30] <bisectable6> AlexDaniel, Bisecting by exit code (old=2015.10 new=c9b18c6). Old exit code: 1

[21:30] <bisectable6> AlexDaniel, bisect log: https://gist.github.com/cdfdc71974d4c05ba340435bdc5bb527

[21:30] <bisectable6> AlexDaniel, (2016-02-15) https://github.com/rakudo/rakudo/commit/b5c6a49072d3d9c118cf0b625b65a9f21bde4316

[21:31] <AlexDaniel> bisect: old=2015.10 put() # oh come on

[21:31] <bisectable6> AlexDaniel, Bisecting by exit code (old=2015.10 new=c9b18c6). Old exit code: 1

[21:31] <bisectable6> AlexDaniel, bisect log: https://gist.github.com/dc72a55558025f0cd1b23b314109fb84

[21:31] <bisectable6> AlexDaniel, (2015-11-12) https://github.com/rakudo/rakudo/commit/bcebf8e96ff7cd68cdc9f4ef9815c724544082e6

[21:31] <AlexDaniel> ok that seems right ;)

[21:31] <AlexDaniel> println! Nooooooo…

[21:32] *** canopus joined
[21:34] *** mcmillhj left
[21:35] *** hankache left
[21:36] <RabidGravy> Hmm

[21:38] *** jmark left
[21:40] *** Peter_R joined
[21:44] *** dmaestro left
[21:45] <perlpilot> thundergnat, timotimo: did someone rakudobug this or look to see if it was already rakudobugged?

[21:46] <timotimo> sorry, i'm completely out of heads right now

[21:46] <thundergnat> perlpilot: I have not yet. I'm still trying to decide whether the problem is in me or Rakudo...

[21:46] <timotimo> i couldn't even finish thinking about that gist

[21:46] <thundergnat> I'm rather suspecting that the my var is leaking to the outer scope though.

[21:48] *** rgrinberg joined
[21:48] <perlpilot> thundergnat: it doesn't hurt to rakudobug it even if you're unsure where the problem is.

[21:52] <thundergnat> perlpilot: Ok, I'll file a bug report. At worst it is bogus or a repeat.

[21:53] <thundergnat> timotimo:, AlexDaniel, thanks for looking.

[21:53] <timotimo> sorry for not actually looking

[21:53] <timotimo> i have kind of an achey head

[21:55] <perlpilot> thundergnat: fwiw, it looks like a bug to me too.

[22:01] *** mcmillhj joined
[22:02] *** Ven joined
[22:03] *** pmurias left
[22:05] *** rindolf left
[22:06] *** mcmillhj left
[22:06] *** Ven left
[22:07] *** Ven joined
[22:08] *** firstdayonthejob left
[22:10] <thundergnat> Bug report filed : RT#129344

[22:10] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129344

[22:19] *** Ven_ joined
[22:19] *** Ven left
[22:20] *** mcmillhj joined
[22:22] <jnthn> .tell nine About your question about wrap of a core method in backlog, you'd better stick "no precompilation" on your code if you do that, since it's a monkey patch and those don't compose under precomp.

[22:22] <yoleaux> jnthn: I'll pass your message to nine.

[22:25] *** robertle left
[22:25] <tailgate> m: https://gist.github.com/ahalbert/0fe8a2eb0cddd1c049214a27d8559f3c

[22:25] <camelia> rakudo-moar b3c92b: OUTPUT«Cannot resolve caller formatted(List); none of these signatures match:␤    ($node, $ ())␤    ($node, List @codes)␤  in block <unit> at <tmp> line 7␤␤»

[22:25] <tailgate> Why doesn't these method delcrations work?

[22:25] *** mcmillhj left
[22:28] <jnthn> 'cus you're passing them a single argument

[22:29] <jnthn> Maybe you meant: say formatted("END", ('A', 'B', 'C'));

[22:29] <jnthn> Or: say formatted "END", ('A', 'B', 'C');

[22:31] *** cdg left
[22:35] *** mcmillhj joined
[22:36] <AlexDaniel> m: multi sub formatted($node, ()) { $node; }; multi sub formatted($node, @codes where {.elems > 0}) { @codes.head ~ formatted($node, @codes[1..*-1]); }; say formatted "END", <a b c>;

[22:36] <camelia> rakudo-moar b3c92b: OUTPUT«abcEND␤»

[22:36] <tailgate> m: https://gist.github.com/ahalbert/0fe8a2eb0cddd1c049214a27d8559f3c

[22:36] <camelia> rakudo-moar b3c92b: OUTPUT«Cannot resolve caller formatted(Str, List); none of these signatures match:␤    ($node, $ ())␤    ($node, List @codes)␤  in block <unit> at <tmp> line 7␤␤»

[22:36] <tailgate> hmm

[22:37] <AlexDaniel> m: multi sub formatted($node, @codes ()) { $node; }; multi sub formatted($node, @codes) { @codes.head ~ formatted($node, @codes[1..*-1]); }; say formatted "END", <a b c>

[22:37] <camelia> rakudo-moar b3c92b: OUTPUT«abcEND␤»

[22:38] <tailgate> ah. So should I still specify the type in @codes ())?

[22:38] <AlexDaniel> tailgate: I have no idea actually. I just know that it works this way :)

[22:39] *** mcmillhj left
[22:40] *** skids joined
[22:40] *** Peter_R left
[22:41] <jnthn> sleep &

[22:41] *** Peter_R joined
[22:41] <AlexDaniel> disown

[22:42] <geekosaur> &|

[22:42] <geekosaur> :p

[22:46] *** cpage_ joined
[22:50] *** _slade_ left
[22:56] *** grondilu joined
[23:02] *** MasterDuke joined
[23:11] *** pierre_ joined
[23:16] *** pierre_ left
[23:20] *** Ven_ left
[23:23] *** Ven joined
[23:29] *** RabidGravy left
[23:40] *** kerframil left
[23:44] *** thundergnat left
[23:44] <grondilu> m: sub infix:<choose>(UInt $n, UInt $k) { combinations($n, $k).elems }; say 10 choose 2

[23:44] <camelia> rakudo-moar b3c92b: OUTPUT«45␤»

[23:44] <grondilu> m: sub infix:<choose>(UInt $n, UInt $k) { combinations($n, $k).elems }; say 64 choose 6

[23:44] <camelia> rakudo-moar b3c92b: OUTPUT«74974368␤»

[23:48] <stmuk_>   

[23:50] *** Ven left
[23:51] *** Ven joined
[23:51] <bioduds_> hi

[23:52] <bioduds_> is this here possible? sub MAIN( Str :%kv ) {

[23:52] <bioduds_> how would I call it on the command line? 

[23:52] <bioduds_> --kv= ?

[23:54] *** Ven left
[23:57] *** TEttinger left
[23:59] *** kerframil joined
