[00:13] *** bradb joined
[00:26] *** nekokak joined
[00:36] *** mako132_ joined
[01:24] <TreyHarris> @tell audreyt I wanted to change util/run-smoke.pl to save a backup to smoke.last.html first, but i don't know how to do that portably--is there an example of moving/copying somewhere i should refer to?

[01:24] <lambdabot> Consider it noted.

[01:29] *** cjeris left
[01:30] <audreyt> TreyHarris: File::Copy

[01:30] <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.

[01:30] <audreyt> and builtin rename

[01:30] <audreyt> lambdabot: @messages

[01:30] <lambdabot> TreyHarris said 5m 56s ago: I wanted to change util/run-smoke.pl to save a backup to smoke.last.html first, but i don't know how to do that portably--is there an example of moving/copying somewhere

[01:30] <lambdabot> i should refer to?

[01:32] <TreyHarris> audreyt: thanks

[01:33] <TreyHarris> actually, probably rename alone is enough, you probably don't want to copy your smoke, just move it aside.  i guess i didn't think it through :)

[01:34] *** buu joined
[01:36] <audreyt> :)

[01:43] *** pfenwick joined
[01:45] <TreyHarris> is the name smoke.last.(htm(l?)|yml) legal on all the systems we support?

[01:46] *** weinig is now known as weinig|sleep

[01:47] *** cmarcelo joined
[01:49] <cmarcelo> hello. any MOP "specialist" in here?

[01:50] <Khisanth> TreyHarris: wouldn't it be simpler to name it smoke.(modification time).html?

[01:51] <TreyHarris> Khisanth: they are rather large, I don't think people want smokes piling up.  But if you're checking for regression, having your last smoke is handy

[01:59] *** mac93 joined
[02:09] <audreyt> cmarcelo: #moose has them

[02:10] <cmarcelo> freenode's?

[02:11] <audreyt> irc.perl.org's

[02:13] <svnbot6> r13774 | fglock++ | [v6.pm]

[02:13] <svnbot6> r13774 | fglock++ | - autoboxing: $array = (1,2,3); $array = [1,2,3]; $hash = { a => 'b' }; $code = { 1 };

[02:13] <svnbot6> r13774 | fglock++ | - 'Code' class

[02:13] <cmarcelo> i'm going there :)... i'm trying to get around MO::Overview, I took a break to study OpenC++ (paper were simpler than M::Over) so I got an idea about MOP but still lots of  "existential doubts".. :o)

[02:21] <audreyt> ok :)

[02:21] <svnbot6> r13775 | trey++ | [util/run-smoke.pl]

[02:21] <svnbot6> r13775 | trey++ | make smoke will now rename the last smoke as

[02:21] <svnbot6> r13775 | trey++ | smoke.last.html and smoke.last.yml.

[02:25] <svnbot6> r13776 | trey++ | Added indention of message to match other messages.

[02:57] *** mauke_ joined
[03:07] *** mako132_ joined
[03:12] *** mauke_ is now known as mauke

[03:14] *** etzel_ is now known as etzel

[03:41] *** Gothmog_ joined
[04:26] *** mac93 joined
[05:11] *** Aankhen`` joined
[05:31] *** imago joined
[05:44] *** kanru joined
[05:52] <svnbot6> r13777 | lanny++ | [docs/Perl6/Spec/Functions.pod]

[05:52] <svnbot6> r13777 | lanny++ | - reference discussion beginning http://colabti.de/irclogger/irclogger_log/perl6?date=2006-10-01,Sun&sel=64#l107

[05:52] <svnbot6> r13777 | lanny++ | * Changed SortCriterion to Ordering and moved to Type Declarations

[05:52] <svnbot6> r13777 | lanny++ | * Added Any to Function Packages and placed eqv() and cmp() within

[05:52] <svnbot6> r13777 | lanny++ | * Added :repl to pick() and modified docs

[05:52] <svnbot6> r13777 | lanny++ | * Modifed sort() docs

[05:52] <svnbot6> r13777 | lanny++ | * Added min() and max()

[05:52] <lambdabot> Title: #perl6 2006-10-01,Sun, http://tinyurl.com/jjuay

[05:57] *** MacVince joined
[06:05] *** kanru joined
[06:24] * gaal mooses

[07:10] *** iblechbot joined
[07:11] *** elmex joined
[07:11] *** imago joined
[07:17] <lumi> gaal: Moose

[07:20] *** zakharyas joined
[07:20] <svnbot6> r13778 | audreyt++ | * Support for instance default expressions (which are evaluated in

[07:20] <svnbot6> r13778 | audreyt++ |   Class composition time, not in instance creation time):

[07:20] <svnbot6> r13778 | audreyt++ |     class Foo {

[07:20] <svnbot6> r13778 | audreyt++ |         has $.x = 10;

[07:20] <svnbot6> r13778 | audreyt++ |     }

[07:20] <svnbot6> r13778 | audreyt++ | * In diamond inheritance, BUILD/DESTROY from a parent class won't be

[07:20] <svnbot6> r13778 | audreyt++ |   executed more than once.

[07:23] <svnbot6> r13779 | audreyt++ | * More triaging under t/oo/; help needed for unTODO

[07:24] *** kane-xs joined
[07:26] *** marmic joined
[07:32] *** MacVince joined
[07:35] *** jferrero joined
[07:36] <masak> audreyt++ # instance default expressions

[07:36] <masak> audreyt: what kind of help needed for unTODO?

[07:39] *** cognominal joined
[08:09] <masak> um, I'm about to commit marking three tests as :todo<feature> and one as :todo<bug> in t/oo/

[08:09] <masak> but I actually have a very vague idea about the difference between these

[08:09] <masak> or how to tell

[08:10] <masak> help appreciated

[08:19] *** mdiep_ joined
[08:31] *** buetow joined
[08:32] *** Psyche^ joined
[08:35] *** Psyche^ is now known as Patterner

[08:54] *** bradb joined
[09:16] <Juerd> audreyt: feather now listens on 443 for both ssl and ssh

[09:18] <webmind> how does it know the difference ?

[09:21] *** xinming__ is now known as xinming

[09:32] <Juerd> webmind: With SSL, the client initiates communication, with SSH, the server does.

[09:39] *** chris2 joined
[09:43] <Juerd> feather runs 14 irssis :)

[09:48] *** drrho joined
[09:53] *** imago_ joined
[09:53] <audreyt> mauke: a :todo<feature> is something that is missing

[09:54] <audreyt> a :todo<bug> is something that "works" but incorrectly

[09:54] <audreyt> when in doubt, call it a bug :)

[09:55] <webmind> Juerd, so what do you use to select between te two ?

[09:55] <masak> audreyt: oki

[09:56] *** rodi joined
[09:57] <audreyt> dinner, bbiab

[10:00] <svnbot6> r13780 | masak++ | * marked a few failing t/oo/ test cases :todo<bug>

[10:02] <Juerd> webmind: sslh, distributed with Net::Proxy. It was demonstrated at YAPC::Europe

[10:03] <webmind> ah k, cool

[10:06] <audreyt> Juerd: woot, thanks! (re sslh)

[10:13] <audreyt> mauke: unTODO help, as in look at yellow boxes in smoke matrix

[10:13] <audreyt> and remove the :todo on those tests

[10:13] <audreyt> since they are now passing and no longer todo

[10:16] *** imago_ is now known as gunya

[10:51] *** ruoso joined
[10:56] *** kane-xs_ joined
[11:13] *** xinming_ joined
[12:19] * masak can live with everyone calling him mauke :)

[12:20] <masak> though I'm trying to think of a way to highlight those lines too

[12:20] <masak> so I can react sooner when people say something to me

[12:21] *** Limbic_Region joined
[12:25] <Khisanth> masak: can't set that in your client?

[12:26] *** xdg joined
[12:27] <Limbic_Region> salutations all

[12:29] <masak> Khisanth: not that I can see. I'd need some sort of "people sometimes call me" feature (or rather "highlight lines containing:"). I'm running X-Chat.

[12:30] <Khisanth> that is in the preferences window :)

[12:30] * masak looks again

[12:30] <Khisanth> under Chatting>General

[12:30] <Khisanth> second text entry from the bottom

[12:30] <masak> Khisanth: thx. found it

[12:30] <masak> can you please call me mauke once so I can see if it works?

[12:32] <Khisanth> hello mauke

[12:32] <masak> it works! :)

[12:32] <Khisanth> that is actually more difficult to type since tab completion goes to you first :P

[12:32] <masak> really? strange...

[12:33] <Khisanth> yes I have it set to complete based on the last time a person has spoken

[12:33] <Khisanth> and you are the last person with a "m" nick speaking

[12:33] <masak> Khisanth: maybe some clients only take the first person matching "ma", alphabetically

[12:34] <masak> regardless of who spoke last

[12:34] <Khisanth> xchat's default tab completion does that

[12:34] <masak> (but that would make me "Maddingue" instead, so that theory doesn't work)

[12:35] <Khisanth> heh looks like they are completing to masak but have an off by 1 error!

[12:35] <masak> :)

[12:46] <svnbot6> r13781 | masak++ | [t/builtins/lists/reduce.t]

[12:46] <svnbot6> r13781 | masak++ | * removed :todo<unspecced> for an unexpectedly passing test

[12:56] *** iblechbot joined
[12:58] <svnbot6> r13782 | audreyt++ | * The statement-level "does Foo;" and "is Bar;" inside a class

[12:58] <svnbot6> r13782 | audreyt++ |   declaration are now compile-time macros instead of runtime mixins,

[12:58] <svnbot6> r13782 | audreyt++ |   exactly as if they've been declared in the class declaration head:

[12:59] <svnbot6> r13782 | audreyt++ |     class Moose does Foo does Bar {...}

[12:59] <svnbot6> r13782 | audreyt++ |     class Moose { does Foo; does Bar; ... } # same thing

[12:59] <svnbot6> r13783 | audreyt++ | * unTODO.

[13:00] *** eggzeck[laptop] joined
[13:04] * Limbic_Region imagines a pedagog teaching:  class Debbie does Dallas;

[13:04] <svnbot6> r13784 | audreyt++ | * more unTODO.

[13:04] <Limbic_Region> ok - sorry for the inappropriate Monday morning humor - but it is Monday

[13:07] <masak> Limbic_Region: :)

[13:10] <svnbot6> r13785 | masak++ | s/_initializement/_initialization/

[13:13] <svnbot6> r13786 | masak++ | and some further s/ement/ation/ within the test file

[13:13] <svnbot6> r13787 | audreyt++ | * Some more triaging; t/oo/roles/ done.

[13:21] *** DHGE joined
[13:27] *** BooK joined
[13:31] *** vel joined
[13:33] <clkao> audreyt: hey. if $c has an incovant, should foo($c;$c) discard the invocant on the second capture ?

[13:33] * clkao goes to buy some milk

[13:38] *** Odin-LAP joined
[13:50] <Limbic_Region> um, the nmake smoke output looks different - did something change recently?

[13:51] *** rodi joined
[13:56] *** jferrero joined
[13:58] <svnbot6> r13788 | audreyt++ | * Runtime mixin "$x does Foo" simply eval back into $x for now.

[14:17] *** iblechbot joined
[14:22] *** mako132 joined
[14:28] <audreyt> clkao: |$c;|$c you meann?

[14:28] <audreyt> (otherwise it's just two positionals)

[14:28] <audreyt> when there's already an invocant, the invocant became 0th positional

[14:28] <audreyt> in that feed

[14:29] <clkao> yes

[14:29] <audreyt> @tell markstos I've fixed pugs so method/multi.t mostly passes -- the one that didn't (*%h) was because all methods implicitly gets a (*%_)

[14:29] <lambdabot> Consider it noted.

[14:29] <Limbic_Region> circa 95% on my Win32 audreyt

[14:29] <clkao> audreyt: ok... but only the the second |$c ?

[14:29] <audreyt> Limbic_Region: *nod* I have ~67 test files to triage

[14:29] <audreyt> clkao: correct

[14:30] <audreyt> Limbic_Region: was 120 just 4 days ago, so it's getting there

[14:30] <Limbic_Region> audreyt - there is another Win32 smoker that isn't doing as hot though

[14:30] <Limbic_Region> not sure what the differences are

[14:30] <audreyt> *nod*

[14:31] <clkao> audreyt: is it in the spec

[14:31] <Limbic_Region> oh, and the weird not loading Test.pm.yml correctly has apparently been fixed

[14:33] <audreyt> clkao: merely "The invocant does not participate in multi-dimensional argument list"

[14:33] <audreyt> clkao: so i's also acceptable to die onsecond |$c I think. it's documented in TimToady's brain only at this moment...

[14:33] <Limbic_Region> heh - the Java instructor from last week had never heard of multi-method dispatch

[14:33] <clkao> the behaviour about unshifting it into pos args

[14:33] <clkao> hmm. ok.

[14:33] <audreyt> Limbic_Region: it's called method overloading there.

[14:33] <audreyt> exactly same thing

[14:34] <clkao> but ya. i think we need to take the capture bit from P::Runtime::Mtch

[14:34] <clkao> for runtime cptures

[14:34] <audreyt> yup

[14:34] <clkao> pesky keyboard

[14:34] <clkao> wht should it be called? pugs::runtime::capture? data::capture?

[14:35] <audreyt> Data::Capture sounds just fine

[14:35] <audreyt> P::R::Capture will work too

[14:35] <svnbot6> r13789 | rodi++ | Typo (unterminated C<...> at line 1160).

[14:35] <clkao> but sounds less neutral for normal p5 use in conjunction with data::bind

[14:35] <audreyt> so D::C it is

[14:35] <clkao> but d::c should be a role right? and PC::Match does it

[14:36] <audreyt> I think it can be simple inheritance.

[14:36] <audreyt> Match is Capture, that is

[14:36] <clkao> ok will try to spend one hour on it. and $work

[14:37] <audreyt> moose!yay

[14:37] * audreyt just fixed various weird OO bugs in pugs

[14:37] <Limbic_Region> audreyt - yes, I know but this instructor claimed over 20 years experience in programming and listed smalltalk and other OO languages amongst his many known languages

[14:37] <audreyt> markstos++ # t/oo/*

[14:38] <audreyt> Limbic_Region: "MMD" is a very not popular jargon for this concept

[14:38] <audreyt> neither "multi dispatch"

[14:38] <clkao> any particular reason PC::Runtime is trying to use its own version of class::insideout?

[14:38] <audreyt> ask fglock, there's a reason

[14:39] <clkao> @tell fglock any particular reason PC::Runtime is trying to use its own version of class::insideout?

[14:39] <lambdabot> Consider it noted.

[14:41] <svnbot6> r13790 | ajs++ | Unicode normalization as promised on IRC. This is not final, and may not even remain. Some determination should be made about comparioson and smart matching (do thye use normalization / do they compare normalized forms?)

[14:41] <svnbot6> r13791 | ajs++ | Clarified comparisons of normalized strings

[14:42] <audreyt> (for the record I don't like the name MMD when "multi" and "method" are orthogonal and unrelated concepts)

[14:42] <ajs_work> So, there's the Unicode normalization stuff for discussion, should anyone care to review.

[14:42] <ajs_work> Based mostly on http://www.unicode.org/unicode/reports/tr15/

[14:42] <lambdabot> Title: UAX #15: Unicode Normalization

[14:43] *** theorb joined
[14:44] <clkao> audreyt: what was blocking the type-based sub::multi do you remember?

[14:45] * audreyt goes excising all such "multimethod" occurances in S06

[14:45] <audreyt> clkao: Class::MultiMethod calculus in Moose

[14:46] <clkao> ya, but i remembered there was somehitng not working so i stopped

[14:46] <audreyt> that escaped me...

[14:46] <clkao> maybe i should start blogging as secondary brain

[14:47] <clkao> the 'invocant' in match is the whole matched string right?

[14:48] <audreyt> yes

[14:48] *** xinming joined
[14:49] <audreyt> alternately it's uninitialized by default and only calculated on demand

[14:49] <audreyt> when stringied , etc

[14:49] <clkao> *nod*

[14:50] *** Su-Shee joined
[14:50] <Su-Shee> hi.

[14:52] <audreyt> Su-Shee: greetings

[14:52] <ajs_work> The Unicode documentation is so simple and readable. Who wouldn't know what "conjoining jamo of various types" meant? :-/

[14:53] *** zakharyas left
[14:53] <clkao> i noticed the hash overload in PC::Match is returning the arrays as well, like 0 => 'foo', 1 => 'bar', along with the named one. is it the right behaviour?

[14:55] <audreyt> Su-Shee: are you tryshee at gmail? would you like a commit bit? :)

[14:55] <Su-Shee> I am indeed "tryshee" - but how did this end up here?! :)

[14:56] <rodi> audreyt is all-knowing.

[14:56] <PerlJam> Su-Shee: didn't you see the sign when you came in?  It reads "Beware!  There be Smart People inside.  Enter at your own risk!"

[14:57] <rodi> which reminds me: audreyt, is my next baby going to be a boy or a girl (baby is due December 31!)

[14:57] * Su-Shee feels stripped to the bare bones of her existence. ;) 

[14:57] <rodi> We need to figure out what color to paint the nursery.

[14:57] <PerlJam> rodi: it's going to be perl6!  ;-)

[14:57] <svnbot6> r13792 | audreyt++ | * Pugs.Eval.Var: Much improve multi dispatch system;

[14:57] <svnbot6> r13792 | audreyt++ |   now the presence of a slurpy named hash (*%_, which is

[14:57] <svnbot6> r13792 | audreyt++ |   default for all methods) no longer totally disables

[14:57] <svnbot6> r13792 | audreyt++ |   argument-counting compatibility check.

[14:57] <svnbot6> r13792 | audreyt++ |   Also, (Str @x) now constraints the incoming argument

[14:57] <svnbot6> r13792 | audreyt++ |   to Array, not Str, as it should be.

[14:57] <audreyt> rodi: yes, your next baby is going to be a boy or a girl, or both (less likely though).

[14:57] <rodi> LOL

[14:57] <PerlJam> audreyt: it could be neither.

[14:57] <audreyt> that's even less likely, but yeah

[14:58] <Su-Shee> rodi: choose green. ;)

[14:58] <PerlJam> rodi: show me a recent picture of your pregnant wife and I'll be able to make a good guess.

[14:58] <ajs_work> S03 doesn't say it now, but I think eq (and thus smart-match) should (by default) coerce to Unicode normalized form before comparing. That is our Bool multi infix:eq(Str $a,Str $b){$a.uninorm === $b.uninorm}

[14:58] <PerlJam> rodi: um ... a picture that includes her belly  :)

[14:59] <audreyt> Su-Shee: commit bit sent; you can test out commit to svn on http://svn.openfoundry.org/pugs/ by editing the AUTHORS file too add your name and commit it in. welcome aboard :) 

[14:59] <lambdabot> Title: Revision 13792: /

[14:59] <rodi> PerlJam: hehe, no good belly shot on the laptop- I

[14:59] <rodi> I'll try to get one, though.

[14:59] <audreyt> ajs_work: maybe all Str is inherently normalised.

[14:59] <audreyt> I'd prefer that.

[14:59] <ajs_work> audreyt: I was thinking that, but the overhead seems prohibitive.

[15:00] <ajs_work> especially when passing entire programs around

[15:00] <PerlJam> rodi: Haven't you guys done an ultrasound or anything?

[15:00] <ajs_work> Ultrasound is just a bad superhero name ;)

[15:01] <audreyt> ajs_work: but the default unicode level is grapheme

[15:01] <svnbot6> r13793 | audreyt++ | * HTML::Entities: Add a Str constraint to help multi tiebreaking.

[15:02] <audreyt> which already implied that precomposed chars need to work the same as non-

[15:02] <ajs_work> audreyt: thinking about that...

[15:04] <rodi> PerlJam: I'm caught.  We have, and I already know it's a littly boy :-D but I like to hear how different people guess.  For instance, this weekend we went to the renaissance festival, and one fortune teller called out that it was a boy...

[15:04] <rodi> But audreyt's response was the best yet.  "yes"

[15:05] <rodi> And Su-Shee, I think we *are* going to paint the nursery green :)

[15:05] <PerlJam> rodi: heh, I was going to guess boy too sight unseen.  But typically girl babies hang lower in the belly than boy babies (or so all the women around have said through many pregnancies)

[15:05] <ajs_work> So a Str probably contains what you put into it (no surprises), but also probably has a slot for caching its normalized representation. That would speed up lots of work, and you could use a simpler type or turn off the caching (perhaps via a role) if it's a problem in terms of memory.

[15:06] <audreyt> Su-Shee: I think #094 will make a nice nursery painting colour...

[15:06] <ajs_work> I *do not* think compatibility normalization should be performed by default, since ? and fi are different things.

[15:06] <Su-Shee> I'd choose rainbow colours - satisfies any possibilities and looks cool .. colorful. :)

[15:06] <audreyt> ajs_work: yes, actually Str manages multiple buf underneath

[15:06] <audreyt> each maybe weirdly encoded

[15:07] <audreyt> but that (and caching) is likely VM specific

[15:07] <ajs_work> audreyt: Ok, that's cool then. And eq simply operates on the appropriate underlying buf for the current Unicode level?

[15:08] <audreyt> I think so, at least that's the plan I've been nudging #haskell people toward

[15:08] <clkao> audreyt: in the capture faq, \($x) == \($x: )

[15:08] <audreyt> clkao: yes, that's as currently specced, but that may go away.

[15:08] <clkao> does that mean invocant gets in positional anyway?

[15:08] <ajs_work> I will look into how Parrot does

[15:08] <audreyt> \$x === \($x:) # this for sure

[15:08] <clkao> ya

[15:08] <clkao> but the \($x) bit?

[15:09] <Su-Shee> Hm. Matching Unicode. I wanted to give me a treat and buy friedl 3.

[15:09] <audreyt> ajs_work: it doesn't do normalization. I think it hooks ICU, but normalization is only exposed via explicit calls to compose/decompose

[15:10] <ajs_work> audreyt: Ok. That's probably fair, since the semantics are language-level. Parrot does what any language will need to start from.

[15:10] <audreyt> exactly.

[15:11] <PerlJam> Su-Shee: There's an MRE3?

[15:12] * PerlJam checks ora

[15:12] <Su-Shee> PerlJam: Yes, rather fresh of the press.

[15:12] <ajs_work> Well, I'm off to do work-work. Thanks for the feedback.

[15:12] <PerlJam> Su-Shee: I see.  Aug 2006

[15:12] <PerlJam> Full chapter devoted to PHP.

[15:13] <PerlJam> what a waste ;-)

[15:14] <Su-Shee> Hm. Ok, I'm going to check this out in the bookstore first. ;)

[15:16] <PerlJam> The last 4 chapters are devoted to perl, java, .net, and php.  Those are probably the most useful chapters.

[15:17] <clkao> audreyt: it seems to be a bit hateful. as it needs to hold ref to values all the time to do anything sensibly

[15:18] <Su-Shee> I've got the first two Friedls, it's more a question of "I buy them always.." than the need for another regex-book. :) I'm waiting for Friedls "mastering perl6 regex" or something like that.

[15:18] <PerlJam> Heck, jfriedl should do the same as Robert Sedgewick.  Have a whole series of books: MRE in perl, MRE in Java, MRE in python, MRE in C (yikes!), MRE in ruby, MRE in PHP, MRE in .net, etc.

[15:18] <PerlJam> (Sedgewick had a slew of "algorithms in X" books)

[15:19] *** rodi joined
[15:19] <Su-Shee> Yeah, but most draw heavily from perl - I'm really curious if they start to adopt the new things of perl6.

[15:20] <PerlJam> I imagine they will with time (assuming perl6 is ever "released" or that at least the perl6 regex engine is released)

[15:20] <audreyt> clkao: sorry, I'm fading now... tomorrow perhaps :)

[15:20] <audreyt> PerlJam: dmq's been working a lot lately on things that will enable native p6re support on p5re engine

[15:21] <PerlJam> audreyt: what about on a pcre engine?  :)

[15:21] <audreyt> which will make PCR much faster (and since Pugs just uses p5/pcr, that'd be fast as well)

[15:21] <audreyt> PerlJam: that would work as well, but p5re is iterative and reentrant and nice now :)

[15:22] <audreyt> (also part of the work was allow wswapping in of pcre sensibly)

[15:22] <Su-Shee> PerlJam: I _will_ advertise and advocate for perl6. :) a perl6 book will be released in german by the end of the year.

[15:22] <Su-Shee> PerlJam: which hopefully makes people more aware.

[15:22] * audreyt waves and goes to sleep :) &

[15:23] <PerlJam> g'night audrey

[15:23] <Su-Shee> n8! :)

[15:26] <masak> goodnite aud'

[15:43] *** Eimi joined
[15:49] <gaal> hola all moose

[15:52] * [particle] mooses at gaal

[15:53] <gaal> yo [particle]

[16:03] *** Eimi joined
[16:15] *** buetow joined
[16:22] *** jsiracusa joined
[16:22] *** hexmode joined
[16:23] *** foo\ joined
[16:32] *** Psyche^ joined
[16:33] *** shobadobs joined
[16:36] <Su-Shee> hm. does CGI.pm work right now or am I simply too stupid for cut and paste? I have to set the header manually.

[16:38] *** BooK joined
[16:41] *** amnesiac joined
[16:49] *** Psyche^ is now known as Patterner

[16:57] *** holoway joined
[17:00] *** silug joined
[17:15] *** buetow joined
[17:25] *** etzel joined
[17:27] *** cm joined
[17:32] *** Narcisse joined
[17:35] <obra> seen audreyt

[17:35] <jabbot> obra: audreyt was seen 2 hours 13 minutes 51 seconds ago

[17:36] *** hexmode joined
[17:38] <[particle]> * audreyt waves and goes to sleep :) &

[17:40] *** vel joined
[17:57] <ashleyb> Hi, I'm new around here, just getting involved, could some one clarify for me: what are the definitions of "pugs" -- What has me confused is using the word "pugs" for the perl 5 implementation of perl6 (as opposed to the haskell implementation) , so what does "pugs" mean?

[17:58] <gaal> pugs is the implementation written in haskell, primarily running its own runcore

[17:58] <TimToady> it's also the whole project, which includes pugs.

[17:58] <lambdabot> TimToady: You have 1 new message. '/msg lambdabot @messages' to read it.

[17:59] <gaal> but it can also emit code in javascript and some other backends (though those are less featurefull)

[17:59] <wilx> I thought Pugs was audrey's dog's name. Or some such thing.

[17:59] <ashleyb> so the whole perl6 project is called pugs?

[17:59] <gaal> also, the perl-on-perl stuff lives in the same repo

[17:59] <TimToady> nope, just this particular svn part of it

[18:00] <TimToady> but there's a lot of stuff under that svn repostitory that aren't directly part of the Haskell implementation

[18:00] <ashleyb> so pugs refers to what ever is in the svn repo?

[18:00] <TimToady> the whole Perl 6 project is just called "Perl 6".  :)

[18:01] <ashleyb> so is v6.pm part of pugs?

[18:01] <TimToady> that would include the parrot project, which is not part of the pugs repository

[18:01] <ashleyb> ok

[18:01] <TimToady> and all the wikis and such in various spots

[18:01] * Juerd uses that same definition for feather :)

[18:01] <Juerd> "and that includes Parrot, of course"

[18:02] <[particle]> v6 uses the pugs repo for development, releases of v6 are on cpan.

[18:02] <[particle]> (this as also true for some other pugs-related perl5 modules)

[18:02] <TimToady> basically, this whole Perl 6 thing is just a flooding algorithm, and wherever is downhill from here, that's where we go.  :)

[18:02] <gaal> also, the test suite

[18:03] <TimToady> just that different people see different versions of "downhill"

[18:03] * [particle] asks, "why is the world in love again?"

[18:03] <gaal> answer: bicycles

[18:04] <ashleyb> ok so the pugs name got stuck in some of the perl5 modules like "Pugs::Compiler::Rule" - but this is p5 not haskell -- right? so what is the etymology of that package?

[18:04] <TimToady> ashleyb: do you have a commit bit yet?

[18:04] <ashleyb> nope not yet, but let me guess this is your lasso trick coming up?

[18:05] <TimToady> actually, it's audrey's lasso trick...

[18:05] <ashleyb> *smiles*

[18:05] <TimToady> but she has recruited a bunch of meta-lassoers

[18:05] <[particle]> ...but you're getting pretty good at it, TimToady :)

[18:06] * [particle] is a bit-carrying member of that posse

[18:06] <ashleyb> so what's the deal with the name "Pugs::Compiler::Rule" ?

[18:06] * gaal is disappointed not to find a good image of a masthead knot online

[18:06] <ashleyb> if it doesn't require ghc

[18:07] <gaal> (kind of a metalasso)

[18:07] <[particle]> ashleyb: i believe it was to differentiate itself from the Perl6:: modules already on cpan

[18:07] <TimToady> that's using "pugs" as the name of the repo rather than the name of the Haskell impl

[18:07] <integral> .oO( the 'g' in 'Pugs' isn't for GHC )

[18:07] <gaal> it's for golfing, actually :-)

[18:08] <gaal> though -fglasgow-exts also acts as -fgolfing-exts, so I wonder

[18:08] * [particle] yells "six!" and swings his club

[18:08] <TimToady> I believe it was decided at the time that the Perl6:: on CPAN had acquired a rather ACME::ish feeling.

[18:08] <ashleyb> *laughter(

[18:08] <ashleyb> *laughter*

[18:09] <TimToady> (as if Pugs:: isn't ACME:: all over again. :)

[18:09] <SamB> TimToady: so, if you are the koyote you will be in trouble?

[18:09] <TimToady> pugs is dog friendly

[18:10] <ashleyb> ok so this feels like a wiki page coming on "what is pugs?"...

[18:11] *** larsen joined
[18:13] *** cm_ joined
[18:20] *** Qiang joined
[18:23] <ashleyb> http://rakudo.org/perl6/index.cgi?glossary_of_perl_6_terms_and_jargon

[18:23] <lambdabot> http://tinyurl.com/lyeet

[18:23] <ashleyb> does that look right?

[18:23] <ashleyb> for "pugs"

[18:24] *** lanny joined
[18:24] <lanny> I am corrupted.  I'm starting to write @forms[-1] in my perl5 code.  :(

[18:26] <TimToady> looks good to me.  are you perchance the ashleyb at halcyon?

[18:26] *** polettix joined
[18:29] <TimToady> @messages

[18:29] <lambdabot> audreyt said 1d 3h 54m 5s ago: I'm dropping support for [+]<< because << recurses into subarrays and so [+] never got a chance...

[18:29] <ashleyb> nope not the ashleyb at halcyon -- sorry.

[18:30] <TimToady> google finds a lot of ashleys...alas.

[18:31] <TimToady> anyway, if you send an email address one of us can get you an invite

[18:31] <TimToady> private msg is okay or foo at bar dot com form

[18:31] <TimToady> to avoid spam

[18:32] *** cm joined
[18:32] <TimToady> email to [email@hidden.address] works too

[18:32] <TimToady> and I already get gigabytes of spam on that address, so I don't care if you see it.

[18:34] <Su-Shee> Hmpf. In order to get a beginner's guide .. someone has to write one, right?

[18:34] *** weinig|sleep is now known as weinig

[18:35] <TimToady> to write a good beginner's guide usually takes at least two people, one of which is a beginner, and one of which is not.

[18:37] * Su-Shee takes the beginner writing beginner's stuff-part. I simply need it. 

[18:40] *** Qiang_ joined
[18:42] *** b_jonas joined
[18:46] *** cm_ joined
[19:07] *** weinig is now known as weinig|bbl

[19:07] <gaal> An Incremental Approach to Compiler Construction - http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf

[19:07] <lambdabot> http://tinyurl.com/mpaac

[19:08] *** iblechbot_ joined
[19:11] *** putter joined
[19:12] <putter> Slides for Steele's recent talk on Fortress are up http://iic.harvard.edu/documents/steeleLecture2006public.pdf

[19:12] <lambdabot> http://tinyurl.com/j9fco

[19:12] <putter> &

[19:49] *** spoop joined
[20:00] *** vel joined
[20:02] <TimToady> ext/URI/t/escape.t seems to be looping

[20:06] *** Limbic_Region joined
[20:19] *** mdiep joined
[20:22] *** ofer0 joined
[20:24] *** jferrero joined
[20:37] <TimToady> examples/algorithms/quicksort.pl ain't so quick at running infinite loops either.

[20:37] <TreyHarris> TimToady: yep, confirmed

[20:37] <TreyHarris> i didn't look at the smoke i started 3 hours ago until just now

[20:37] <TreyHarris> stuck on ext/URI/t/escape.t

[20:38] <TimToady> I chewed up an hour of CPU on that one--sounds like you chewed up more...

[20:38] <TreyHarris> yeah :)

[20:41] <TreyHarris> TimToady: so, I don't want to draw you into the rat hole that's been going on on p6-l until you're ready, but I am wondering: do you have clearly in mind whether typing of sigs and args in Perl 6 exists just for multis to work correctly and for additional checking when required, or for autocoercion too?  it's a question i often get asked when i talk about Perl 6, and I usually just handwave and talk about the sorts of things that *could* be done...

[20:43] <TreyHarris> oh, the other one I get, immediately after describing autoboxing and captures: "so why does Perl 6 still have @vars and %vars?  just for some extra namespaces?  it looks like you can do everything with $vars now..."  (course, you could do everything with scaler vars in perl 5 too, it was just much more keyboarding.  In Perl 6 it's rarely any more keyboarding at all.)

[20:46] <PerlJam> TreyHarris: @foo and %bar are annotations for humans about default expectation IMHO.

[20:49] <wolverian> could be useful to the type inferencer too, I suppose.

[20:49] <TimToady> TreyHarris: I have clearly in mind that multis are the primary use of sigs/captures, but not the exclusive use.  They're really pattern matching primitives.

[20:50] <TimToady> As for the sigils, Perl will lose its plural markers about the same time English does.

[20:50] <PerlJam> heh

[20:51] <ajs_work> TimToady, so you're saying that foo is a scalar and foos is an array now? Does that make fooz a hash? ;)

[20:51] <TimToady> orz

[20:52] *** SubStack joined
[20:56] <wolverian> foo's 2th = "a";

[20:56] *** yts joined
[20:56] <wolverian> s,th,nd, # oops

[21:00] <TreyHarris> TimToady: ok, makes sense.  the reactions I've generally gotten when I mention the possibility of autocoercion seems to be either a) elation from people who have always wanted it, or b) revulsion from those who have used it in another language (usually C++).  so i think there's a huge opportunity here if we can do it right, but a lot of danger too...

[21:01] *** crem_ joined
[21:01] <TimToady> at the moment we've said that only the basic P5 Str/Num autocoercions happen implicitly.  Others must be explicit, or at least declared implicit.

[21:02] <TimToady> but that's also why we've said that Foo() implies coercion rather than construction, and you have to say Foo.new() to force construction.

[21:02] <TimToady> Use Foo() if you don't care whether it's a new object or not.

[21:02] <TreyHarris> yup.  and it would always be easy enough to add a multi to give the appearance in user code of autocoercion while leaving the actual coercion explicit

[21:03] <TimToady> yes, that's probably how implicit conversions are defined.

[21:05] <TimToady> possibly even with "multi * (Bar --> Foo)" since it's an 'is deeply' kind of thing.

[21:05] <TimToady> so you're binding semantics rather than a particular syntax.

[21:06] <TimToady> so the actual name doesn't matter.

[21:06] <TimToady> prefix:<?> and prefix:<true> are really the same semantic operation.

[21:07] <mugwump> mmm.  have you got any idea about how true aliases like that could work?  eg, equivalent unicode vs ascii operators

[21:08] <mugwump> aiui at the moment you'd have to define both

[21:09] *** araujo joined
[21:11] <TimToady> it's easy enough to alias normal subs with ::=, but things in syntactic categories tend to also need macro capabilities, so that tends to force separate declarations if the macroness differs.  I don't think we've specified what ::= does with "is parsed".

[21:12] <TimToady> but if the default behavior for the syntactic category is desired, then

[21:12] <TimToady> &*prefix:<?> ::= &*prefix:<true> may have sufficient info.

[21:13] <TimToady> except it might poke ? into the wrong precedence level.

[21:29] *** Limbic_Region joined
[21:53] <mugwump> TimToady: do references notionally point to $object.WHICH ?

[21:53] *** Odin- joined
[21:54] <mugwump> ie, say I change one of an object's 'primary' values, does that invalidate pointers to the object?  (or, perhaps even create a new object)

[21:59] <mugwump> I'm starting to wonder if making the return value of a function define its identity is the right approach

[21:59] <mugwump> (the .WHICH function)

[22:00] <mugwump> There was a gut feeling that it was more of a constructor thing some time ago when I first looked at this

[22:03] *** putter joined
[22:06] <mugwump> Here's the code that illustrates;

[22:06] <mugwump> class Dog { has $.dogtag; has $.size; method WHICH { $.dogtag } }; my Dog $spot .= new(:dogtag<spot123>, :size<35>); say $spot.size; say Dog.new(:dogtag<spot123>).size;

[22:06] <mugwump> ?eval class Dog { has $.dogtag; has $.size; method WHICH { $.dogtag } }; my Dog $spot .= new(:dogtag<spot123>, :size<35>); say $spot.size; say Dog.new(:dogtag<spot123>).size;

[22:06] *** evalbot_r13766 is now known as evalbot_r13793

[22:06] <evalbot_r13793> OUTPUT[35  ] Bool::True

[22:08] * mugwump considers timing out this question and referring to the list

[22:10] *** beppu_ joined
[22:12] <mugwump> note that the output of the above program would have been [35 35 ] if .WHICH provided a definition of object identity

[22:14] <putter> does anyone know the current state of literal unicode named characters?

[22:15] <mugwump> your adjectives seem to disagree there

[22:15] <mugwump> how can a character be literal and named?

[22:16] <putter> :)

[22:16] <putter> actually, string escape is what I was aiming for

[22:16] <putter> "\c[LATIN CAPITAL LETTER A]"

[22:17] <mugwump> that's self-referential!  :)

[22:18] <putter> lol

[22:18] <[particle]> mugwump ::= "\c[IRC LITERAL WISE GUY]"

[22:18] <putter> also unspecced apparrently.  and googling the list hasn't yet turned up anything.

[22:20] <mugwump> right, but they're defined as rule tokens.

[22:21] <mugwump> ?eval "\c[NUMBER SIGN]"

[22:21] <evalbot_r13793> "#"

[22:25] <putter> oops, I'm wrong.  S02 defines \c.

[22:30] *** mako132_ joined
[22:40] <lumi> mugwump: Couldn't it be that, when overriding .WHICH, you're asserting its uniqueness? That is, it's your responsibility that .WHICH is good enough for identity

[22:41] <mugwump> That's right.  But if you change the object in such a way that its .WHICH changes, what happens to things that were treating your .WHICH as the point of uniqueness?

[22:43] <lumi> I guess that .WHICH should be unique and consistent throughout object lifetime..

[22:43] <mugwump> that would make life easy, sure

[22:44] <lumi> Yup, although in Perl, rules are always made to be broken

[22:45] <mugwump> And then, how does object construction work?  You create a not-quite object, call .WHICH, check in a hash to see if an object with the same .WHICH already exists, and if so just return that?

[22:46] <mugwump> And does the value returned by .WHICH have to be unique for all types or just all types in the same class hierarchy?

[22:46] <lumi> That would be some sort of memoization

[22:46] <TreyHarris> also consider:

[22:46] <TreyHarris> ?eval class Foo { has $.a is rw; method changeme ($self is rw:) { $self = Foo.new(:a(42)) } }; my Foo $moose .= new(:a(17)); say $moose.a; $moose.changeme; say $moose.a

[22:46] <evalbot_r13793> OUTPUT[17 42 ] Bool::True

[22:46] <TreyHarris> a method is free to change its invocant

[22:47] <lumi> Yes, but "that's your responsibility" means it's your responsibility :P

[22:47] <lumi> I mean, either a programmer respects its contract with the language, or the language puts out a contract on them

[22:47] <lumi> Er, s/its/their/ # or other gender-neutral pronoun

[22:47] *** SubStack joined
[22:48] <svnbot6> r13794 | putter++ | [t/regex/from_perl6_rules/]

[22:48] <svnbot6> r13794 | putter++ | Undelete the 15 tests deleted "quasi-intentionally" by r13604.

[22:48] <lumi> You shouldn't use your mutable attributes to identify yourself

[22:49] <mugwump> Well, there would be one behaviour in this case that could be considered correct

[22:49] <mugwump> That is, changing an object in such a way that .WHICH changes makes a new object

[22:49] <mugwump> And the old object goes away if nothing was referring to it.

[22:50] <lumi> Oh, .become

[22:50] <TreyHarris> yes.  the point is that there's TIMTOWDI currently on object identity.  and I personally don't think this is a place where we want TIMTOWTDI, since there's a good change that we'll have the same issue that inside-out objects had with all the modules that assume that "object" means "blessed hash"..... bad coupling forced by convention, not by the language....

[22:50] <TreyHarris> s/change/chance/

[22:51] <lumi> So you'd rather "object" mean "have this .WHICH"?

[22:51] <lumi> (This is just a query)

[22:52] <mugwump> If you define .WHICH, are you not stating the basis of an object's identity?

[22:52] <lumi> It sounds like you are

[22:52] <TreyHarris> lumi: who are you asking, me?

[22:53] <mugwump> actually it's probably (.WHAT, .WHICH), but I guess that was implied

[22:53] <lumi> However, I don't think it's the object system's job to take care of memoizing for you always, especially since this is a classless society :)

[22:53] <lumi> TreyHarris: Yes, sorry

[22:53] <mugwump> it's not the object system's job, or it seems like a hard problem?

[22:54] <TreyHarris> no, i think "object" is very well-defined in S12.  an object is a value.  i don't think we have the duality of object values versus simple values in Perl 6 like we do in Perl 5, so I think it would be harder to write a module that couldn't deal with any arbitrary objects than one that could.  This is a Good Thing.

[22:54] <lumi> mugwump: It's not a hard problem, but it does sound like a lot of overhead.. but possibly by defining .WHICH you're asking for that?

[22:55] <mugwump> yes, that's the idea.

[22:55] <TreyHarris> (The duality we might see is of modules that do Deep Magic only dealing with :repr<P6opaque> objects.  But that will be much more rare than the multitude of modules on CPAN today that assume blessed-hash reprs....

[22:56] <lumi> So: method WHICH {...} would mean "Please memoize objects for me using this key"

[22:56] <lumi> I'm possibly misusing the word "memoize"

[22:56] <mugwump> It could, but my gut feeling is that the side effects imply it's more of a property of the constructor

[22:57] <TreyHarris> lumi: method WHICH means "if you ever see this thing I return again, you can assume that what returned it is me"

[22:57] *** nothingmuch joined
[22:57] <TreyHarris> $x === $y is defined as $x.WHICH eq $y.WHICH

[22:58] <lumi> TreyHarris: So I guess it's fair to assume that the optimizer, for one, would take your word for it?

[22:58] <TreyHarris> I would think so, if the optimizer operates at that high a semantic level....

[22:58] <mugwump> What === means is currently uninteresting.  I'm more interested in =:=

[22:59] <mugwump> .WHICH just seems too late

[23:01] <mugwump> but maybe it's not.  Maybe it's OK, when constructing objects, for Perl to call .WHICH on the resultant object, and if there was already an object with that ~~ .WHAT and ~~ .WHICH, then change the invocant before returning from .new

[23:01] <TreyHarris> i need to scroll back clearly, as I didn't realize we were talking about the underlying variable, I thought we were talking about objects.  objects don't exist at compile-time.  well, objects the compiler instantiates itself do.... but i'm talking about ordinary code

[23:01] *** Odin- joined
[23:01] <TreyHarris> ohhh... I see

[23:02] <TreyHarris> < mugwump> TimToady: do references notionally point to $object.WHICH ?

[23:02] <TreyHarris> I'd be floored if that were true

[23:02] <TreyHarris> Because it would mean that you couldn't fake it out with class-internal memoization or singletonizing

[23:02] <mugwump> those would be easy to implement, though

[23:02] <TreyHarris> because you could never refer to "that other object with the same .WHICH as me" to do the indirection with....

[23:03] <mugwump> but if "another" object has the same .WHICH, it's the same object, by definition

[23:04] <TreyHarris> I've assumed that autoboxing and "there are no references in Perl 6" means that the only valid question to, "in C<$obj = Foo.new()>, what does $obj contain?"  is "a Foo".  asking a deeper question about $obj's value apart from Foo is specious...

[23:04] <mugwump> well, not if Foo is a singleton class

[23:05] <mugwump> which could be written: class Foo { method WHICH { } }

[23:05] <lumi> Because then it's "the Foo"

[23:05] <putter> looks like svnbot is on vacation again...

[23:06] <TreyHarris> how does that matter?  "$obj1 = Foo.new(); $obj2 = Foo.new();", the answer to what's in $obj1 or $obj2 is still "a Foo", it just happens to be the same Foo....

[23:06] <mugwump> and?

[23:06] <lumi> But then .new is lying

[23:06] <TreyHarris> you said "not if Foo is a singleton class"

[23:07] <lumi> I guess that's irrelevant

[23:07] <mugwump> right, but if Perl spots that the .WHICH has a prototype of (), ie it's always a constant, then it doesn't even have to call .new

[23:07] <TreyHarris> lumi: do the specs say that new must return a nonpreexisting object?

[23:09] <TreyHarris> mugwump: what about "for ^2 { my $obj = Foo.new() }"?  the only Foo goes out of scope

[23:09] <mugwump> that's fine

[23:09] <mugwump> nobody said singletons had to be immortal

[23:09] <mugwump> I think you're getting containers and objects slightly confused.

[23:10] <mugwump> $y = $b = Foo.new() - gives you two containers pointing at the same object

[23:10] <lumi> TreyHarris: No, they don't, only my brain, and $larry not ex camera

[23:11] <TreyHarris> mugwump: i understand that.... and $y := $b = Foo.new() doesn't

[23:12] *** Aankhen`` joined
[23:12] <lumi> I think I just lost you

[23:12] <mugwump> that's right, in that case you've got two lexicals for the same container

[23:12] *** mako132_ joined
[23:14] <TreyHarris> right.  but what does that have to do with my confusing container and object before?  yes, of course "$obj = Foo.someFactory() # better? :)" puts something besides all of the Foo's representation into the container.  but what I'm saying is that the answer to the question of "so what *is* stored in $obj then?" is "you can't ask that question, it's just a Foo."  or "it's implementation-dependent" if you like :)

[23:15] <mugwump> You never care what things are, just how they behave

[23:15] <mugwump> That's why I said "notionally"

[23:17] <lumi> I guess it's an implementation detail, then

[23:19] <mugwump> Right.  I think where we've arrived is that if the value that .WHICH returns ever changes for an object, the result is undefined.

[23:19] <TreyHarris> mugwump: but what about value types?

[23:20] <mugwump> what about them?

[23:20] <lumi> Value types == immutable types? Or not necessarily?

[23:20] <TreyHarris> ?eval my $val = 3; say $val.WHICH; $val += 2; say $val.WHICH

[23:20] *** evalbot_r13793 is now known as evalbot_r13794

[23:20] <evalbot_r13794> OUTPUT[3 5 ] Bool::True

[23:21] <TreyHarris> in effect, it just did the ($self is rw:) game I wrote above.

[23:21] <TreyHarris> created a new object, and installed it into $val.  because it refuses to allow 3's value to change.

[23:22] <TreyHarris> (I know that's not what's going on below the covers, I'm just speaking 'notionally' again.)

[23:22] <TreyHarris> I don't think you can tell the difference between an object that changes its .WHICH and an object that implements a value type.

[23:23] <mugwump> that last comment is exactly what I'm getting at

[23:23] <lumi> Isn't it notionally, "VAR($val) = $val.+(2)" or so?

[23:23] <mugwump> but how can you tell if the value of .WHICH would have changed?

[23:23] <lumi> I mean, = happens at um, container level

[23:24] <TreyHarris> ?eval my $obj = 3; say VAR($obj); $obj += 2; say VAR($obj)

[23:24] <evalbot_r13794> OUTPUT[3 5 ] Bool::True

[23:25] <mugwump> ok, my use of =:= before was incorrect;

[23:25] <mugwump> ?eval my $x = 5; my $y = 5; say "yes" if ($x =:= $y)

[23:25] <evalbot_r13794> undef

[23:25] <TimToady> ?eval my $x = 5; my $y = 5; say "yes" if $x === $y

[23:25] <evalbot_r13794> OUTPUT[yes ] Bool::True

[23:27] <TreyHarris> mugwump: I'll let TimToady answer your original question, but *my* answer would be: if it's a value type, then yes, changing one of its primary keys would cause you to suddenly have a new object.  if it's a mutable type, then no, you can change its primary key but it's up to you to change WHICH as well if that's what you want.

[23:27] <TreyHarris> (maybe not really a "new object", but as far as any code outside the class itself can tell...)

[23:28] <mugwump> well, there are ways in which you could tell

[23:28] <TreyHarris> mugwump: but you shouldn't count on any of them

[23:28] <mugwump> consider the case of a content hashed filesystem.

[23:29] <mugwump> in that, you have a "file" object, for which its .WHICH is defined as sha1_hex(self.contents)

[23:29] <TreyHarris> sorry, back in 10m or so.....

[23:30] *** particle___ joined
[23:30] *** particle___ is now known as ___particle___

[23:30] <mugwump> or, if you prefer, the sha1_hex is computed and placed into an object attribute $object_id

[23:30] <mugwump> which is returned by .WHICH

[23:31] <mugwump> so, if I then create an object with .new(:object_id<...>), am I referring to the same object?

[23:33] <lumi> Probably you are

[23:34] *** dvorak joined
[23:37] <mugwump> see also http://colabti.de/irclogger/irclogger_log/perl6?date=2006-07-16,Sun&sel=70#l130

[23:38] <lambdabot> Title: #perl6 2006-07-16,Sun, http://tinyurl.com/eozda

[23:38] *** drbean joined
[23:40] <mugwump> (note that the difference between now and then are that now I'm interested in what happens if WHICH changes...)

[23:40] *** foo\ joined
[23:49] <mugwump> I'm wondering if WHICH is actually a per-class macro, not a function

[23:55] <TreyHarris> mugwump: i guess i'm wondering when/why you would care, so long as outside of the class, you can safely use .WHICH to semantically identify a object.  what is a case where you need to know the difference?

