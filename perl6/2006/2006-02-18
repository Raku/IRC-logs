[00:11] *** jiing joined
[00:13] *** jiing joined
[00:14] *** feng joined
[00:14] *** feng left
[00:15] *** jiing__ joined
[00:18] *** avar joined
[00:18] <svnbot6> r9048 | putter++ | regexp_engine_demo.pl - exploring backtracking api.

[00:50] *** avar joined
[01:04] *** theorbtwo joined
[01:04] *** pdcawley joined
[01:08] *** lao joined
[01:40] *** orafu joined
[01:51] *** joepurl joined
[01:56] *** Khisanth joined
[02:23] *** Limbic_Region joined
[02:30] *** xern joined
[02:43] <svnbot6> r9049 | Darren_Duncan++ |  r2519@darren-duncans-power-mac-g4:  darrenduncan | 2006-02-17 18:41:13 -0800

[02:43] <svnbot6> r9049 | Darren_Duncan++ |  ext/Locale-KeyedText/ : resynced KeyedText.pm version num with the perl 5 edition

[02:51] *** justatheory joined
[03:02] *** Limbic_Region left
[03:06] *** hcarty joined
[03:10] *** Cryptic_K joined
[03:21] *** gugod joined
[03:23] *** beppu joined
[03:55] *** hcarty left
[04:19] *** Amnesiac joined
[04:54] *** justatheory joined
[05:08] *** putter joined
[05:11] *** justatheory joined
[05:46] *** kanru joined
[05:50] <gaal> azuroth: given ($object) { ... }, I think, does what you want

[06:02] <arcady> what's the difference between { temp $_ = $object; ... } and { my $_ = $object; ... } ?

[06:03] <buu> arcady: One involves the collapse of miniature black holes.

[06:04] *** drbean joined
[06:04] <arcady> oh, well then everything is perfectly clear : )

[06:04] *** Nouk joined
[06:08] *** Gniij is now known as jiing

[06:14] *** feng joined
[07:14] *** beppu joined
[07:25] *** scook0 joined
[08:24] *** iblechbot joined
[09:15] *** ghenry joined
[09:24] *** ghenry left
[10:16] *** Alias_ joined
[10:17] <Alias_> audreyt: ping?

[10:18] *** chris2 joined
[10:45] *** bsb joined
[11:03] *** elmex joined
[11:28] *** larsen joined
[11:42] *** kisu joined
[11:43] *** pdcawley joined
[12:01] *** iblechbot joined
[12:08] *** pdcawley joined
[12:20] *** larsen_ joined
[12:45] *** chris2 joined
[12:51] *** avar joined
[13:01] *** marmic joined
[13:23] *** SamB joined
[13:27] *** avar joined
[13:34] *** rantanplan_ joined
[13:39] *** rantanplan_ joined
[14:36] *** avar joined
[14:41] *** scw joined
[14:58] *** avar joined
[15:15] *** feng123 joined
[15:16] <avar> mm

[15:17] <avar> has there been any discussion on negative imports in Perl 6?

[15:17] <avar> like some shorthand for:

[15:17] <avar> use warnings;

[15:17] <avar> no warnings 'qw';

[15:17] <avar> use warnings '!qw'; or something

[15:17] <Alias_> that works in Perl 5... so I'm sure there's be an equivalent

[15:17] <Alias_> unimport

[15:18] <avar> yeah, I know it works, but I was wondering about whether there had been any discussion on a shorthand syntax

[15:18] <Alias_> ah

[15:18] <Alias_> Well, the import params are module-specific

[15:18] <Alias_> So I imagine it will be very similar

[15:18] <gaal> import syntax isn't finalized, so i don't think unimport shortcuts can be :)

[15:18] <Alias_> and it isn't really unimport anyway

[15:19] <Alias_> There's import, and then there's lexical pragma-like stuff

[15:19] <Alias_> In P5 they are the same, I think the two were being split out or something

[15:25] <gaal> way I see it, there's import and module config requests. there was a good discussion about this here on the channel sometime, and a few attempts on p6l, but no resolution

[15:30] <avar> how is EXPR for EXPR parsed internally?

[15:30] <avar> because it's not turned into for EXPR <BLOCK>EXPR</BLOCK>

[15:31] <avar> since print $i for my $i 0 .. 5; doesn't work

[15:32] <Alias_> gaal: Right

[15:32] <Alias_> gaal: imports suck anyway for most OO code, since they pollute APIs

[15:33] <Alias_> at least in the Perl 6 symbol table style of imports anyway

[15:33] <Alias_> err Perl 5 symbol table style

[16:03] *** putter joined
[16:05] <svnbot6> r9050 | audreyt++ | * Pugs.CodeGen.YAML: "pugs -CParse-YAML" now omits the primitive

[16:05] <svnbot6> r9050 | audreyt++ |   bindings for functions and types, just as "pugs -CPugs" used to do.

[16:08] <putter> gaal: re imports, if you have any dreams of how they would ideally work, and be expressed, I'd be interested.

[16:15] <putter> in case anyone is curious, my current state is:  i think i'm starting to get a handle on the whole regex (and parsing, i think) picture.  (ask me questions, please!:)  and there's _no_ way i'm coding it all by hand.  so i've just started a meta-programming exercise, so i can keep all the info in one place, and autogrovel out p5/p6 ast and engine code for p5/p6 regexs.  commits when things settle down a bit more.

[16:19] <putter> my surprise for yesterday was just how close p5 is to having rules already, with ast macros as subs, in the character class sublanguage (user-defined unicode properties), and string macros in the... need a name for it... top-level regex language (overload and customre).  it kind of looks like the only reason p5 regex couldn't gracefully 

[16:20] <putter> evolve into p6 rules is the p5 engine's intolerance of reentrancy.  but for that, we could have had rules years ago.  sigh.

[16:20] <audreyt> damian found that out in 2003. sigh.

[16:20] * audreyt mumbles something insane: "switch to pcre"

[16:21] <putter> did anyone ever consider swapping out the regexp engine?  or adding a second one (pragma'ed)?

[16:22] *** cognominal joined
[16:22] <gaal> putter: you were part of that discussion and I remember you had some valuable input... I'll bring this up in the 'thon

[16:23] <audreyt> putter: yes, I think mjd and ilyaz had both coded something toward that

[16:23] <putter> re the meta-programming, i'm trying to do a "whole spec" massage.  so my hope is, when it runs (maybe a week out?), it will actually be feature complete, and perhaps even resemble correct.  we'll see.

[16:26] <putter> gaal: that would be great, thanks.

[16:34] <putter> (hmm, so in an alternate universe, where the p5 engine was reentrant early on, "it can parse anything easily" was a property of perl 5.something, rather than p6.  instead of mere Inline, complete compilers.  instead of multi-year p6 discontinuity, years of moduled sourcefilter+rules-based experimentation, and incremental language evolution.  sigh indeed.;)

[16:36] <audreyt> putter: that's the theme of my CUFP article ;)

[16:37] <audreyt> though dconway/allison remarked "perl6-rules on perl5-regex was never the plan, just a spike"

[16:37] <audreyt> but had the p5rx engine be reentrant, the spike will had likely evolved, instead of broken on perl 5.8.3 and never picked up again

[16:39] *** bsb joined
[16:40] <putter> neat.  no comment.  agreed.  putter goes to read docs/talks/cufp2005.txt .  

[16:41] <audreyt> putter: er, see docs/talks/hw2005.tex instead

[16:44] <putter> thanks :)  have read both, but rereading is fun/useful.

[16:45] <putter> re dynamic grammars, turns out "once upon a time" languages with custom grammars were actually common.

[16:46] <putter> died out because they were a maintenance nightmare.  each file/program has it's own syntax.

[16:48] <putter> I think a key characteristic / distinction from p6, is they were not (easily?) customizable enough to do other, standardized languages.  eg, couldn't customize all the way to a fortran or lisp.  so custom == random author whims.  rather than == ability to use well designed and documented other languages.

[16:49] <putter> hmm, also , the lack of a cpan / ability to share ideas, and focus in on good ones, meant "each author has his own language, with only bacterial code sharing".

[16:50] <putter> "bacterial code sharing" == pick up bits of code from those you bump into, and add them to your own set.

[16:51] <putter> p6 flexibility _will_ have challenges, and it will seem strange to folks, and some will remember flexibility's earlier failures, so something to think/talk about.

[16:51] <audreyt> nod.

[16:52] <putter> (all this because putter noticed the sentence in hw2005.tex "Unlike most languages, Perl 5 has a dynamic grammar...":)

[16:53] <Alias_> sigh... pcre...

[16:54] <Alias_> putter: I seem to recall hearing smalltalk discussed like that

[16:54] <Alias_> "It will take me 3 weeks to code up a suitable set of environment $stuff, but after that we'll progress fast"

[16:54] <svnbot6> r9051 | gaal++ | * DrIFT.YAML and DrIFT.RuleYAML: better error handling for unrecognized

[16:54] <svnbot6> r9051 | gaal++ |   nodes in derived instances

[16:54] <svnbot6> r9051 | gaal++ | * Derive instances for the DrIFTless

[16:55] <Alias_> putter: And I believe you bacterial thing has a name. Something like "horozontal evolution"

[16:55] <Alias_> your

[16:55] <putter> Alias_: ooo, interesting.  i wonder if we could get an "if only we had cpan" quote from one of the smalltalk old-timers like Alan Kay...

[16:56] <Alias_> Interestingly, I find JavaScript the same way

[16:56] * putter googles...

[16:56] <Alias_> Not at a grammar level, but at a "first you make your tools"

[16:56] <Alias_> Which might help explain why Prototype is so inscrutable 

[16:56] <Alias_> :)

[16:56] <Alias_> audreyt: A couple of very quick YAML::Syck question

[16:56] <Alias_> ?

[16:57] <Alias_> As it related 

[16:57] <Alias_> Specifically, your Module::Install Makefile.PL for it

[16:57] *** justatheory joined
[16:57] <audreyt> ...yes?

[16:57] <Alias_> I've had 5 people in the last week ask how to do XS in M:I

[16:58] <Alias_> So I figure it needs to be documented properly, and YAML::Syck is the only example I know of

[16:58] <svnbot6> r9052 | gaal++ | * Pugs.Prim - add Pugs::Internals::eval_p6y, a conjectural and

[16:58] <svnbot6> r9052 | gaal++ |   probably bogosous prim to load precompiled Perl 6 files.

[16:58] <Alias_> Can you explain what you are doing in it briefly?

[16:58] <audreyt> inc_paths sets the INC paths

[16:58] <audreyt> c_file sets the C files

[16:58] <Alias_> why the use lib '.'?

[16:58] <audreyt> optimize_flags sets theoptimization flags

[16:59] <Alias_> And why is inc_paths needed 

[16:59] <audreyt> use lib is not needed

[16:59] <putter> Alias_: re horiz ev, yes, thanks.  (as long as one stays away from creationists, which seem to have their own take on this, as on so much else;)

[16:59] <svnbot6> r9053 | gaal++ | * The Prelude is now precompiled into YAML.

[16:59] <audreyt> you can take it off

[16:59] <Alias_> ok

[16:59] <audreyt> inc_paths is needed becaus syck.h is in .

[16:59] <audreyt> gaal++ gaal++ gaal++ # 3-day non-stop hacking 

[16:59] <Alias_> So it refers to the location of the headers? Because the header search is done in the @INC?

[17:00] <gaal> the next one's the nice one :)

[17:00] <audreyt> Alias_: it's not done in the @INC

[17:00] <putter> "bogosous"  *grin*

[17:00] <audreyt> inc_paths refers to C's "INC"

[17:00] <audreyt> not perl's @INC

[17:00] <Alias_> uuum, oh dear

[17:00] <audreyt> I admit it to be ambiguous.

[17:00] <audreyt> c_inc_paths?

[17:00] <audreyt> header_paths?

[17:00] <Alias_> I have some ideas, I'll deal

[17:00] <putter> gaal++  woot

[17:00] <audreyt>  k

[17:00] <Alias_> (and leave the current one for now)

[17:00] <gaal> audreyt++ audreyt++ audreyt++ # nonstop mental-and-I-mean-mental support :)

[17:01] <Alias_> can_cc I've already improved

[17:01] <audreyt> mm I'm feeling mental

[17:01] <audreyt> cool

[17:01] <Alias_> explain c_files

[17:01] <gaal> whoops, "next one" was actually 9053

[17:01] <Alias_> According to someone else, it's a bit weird

[17:01] <Alias_> Because you set c_files( 'foo.c' ) if there's a file 'foo.xs'

[17:01] <Alias_> Or something

[17:02] <gaal> plus profound hackerosity magic and generic^Wall-around wonderosity coolage, etc. :)

[17:02] <putter> lol; audreyt++ ;)

[17:02] <gaal> so, now, just to make it not slow, TWD etc.

[17:03] <audreyt> Alias_: I think c_files should accept .xs and translate them into .c

[17:03] <putter> so this putter around the planet thing seems to work.. ;)

[17:03] *** Maddingue joined
[17:03] * gaal remakes an optimized build.

[17:03] <audreyt> c_files glob("*.c"), glob("*.xs")

[17:03] <putter> err, audreyt-ing around the planet...

[17:03] <audreyt> putter: I'm thinking about relaxing my self-imposed US ban

[17:03] <audreyt> just so I can come to Chicago and Portland.

[17:03] <audreyt> and Seattle.

[17:04] <audreyt> (and where stevan is at, now that he did not secure a TPF grant to .jp)

[17:04] <audreyt> where is stevan located anyway?

[17:04] * putter avoids flying where possible.  security idiocy was the only thing i didn't like about flying _before_ 2001.  now it's just silly.

[17:05] <Alias_> Entering the US sucked

[17:05] <audreyt> it looks like YAPC::NA this year will rock, though.

[17:05] <Alias_> And I'm from a friendly country dammit

[17:05] <Alias_> audreyt: I may not be going :/

[17:05] <putter> stevan is in Conneticut.  ok, no chance of spelling that right without checking.  a couple of hours from boston.

[17:05] <audreyt> yeah, I'm from a minion country too

[17:06] <audreyt> ah, on the other end of the country

[17:06] <gaal> putter: consider donating to alt.pave.the.earth so you can take a train anywhere!

[17:06] <Alias_> audreyt: World Cup is on at the same time as YAPC::NA and AU is going for the first time in 35 years

[17:06] <audreyt> Alias_: that means... what?

[17:06] <audreyt> (and world cup for which sport?)

[17:06] <Alias_> err "the" world cup

[17:06] <Alias_> football

[17:06] <putter> lol

[17:06] <Alias_> That means how could I go somewhere where I can't find room of drunk cheering australians!

[17:07] * putter didn't know the NFL had a world cup... ;)

[17:07] <Alias_> heh

[17:07] <Alias_> If YAPC::NA can organise drunk rooms of cheering australians, I'm there

[17:07] <Alias_> or a football mini-conf :)

[17:08] <Alias_> Anyways... c_files

[17:08] <putter> seems likely :)

[17:08] <Alias_> Is there any reason you could just want it automated :)

[17:08] <Alias_> compile_all_c_files

[17:08] <Alias_> or line it into the inc_paths

[17:08] <putter> back to meta-coding...

[17:08] <Alias_> compile_c_path '.'

[17:09] <audreyt> Alias_: maybe... but it's unusal to put all .c into the same .

[17:09] <Alias_> wouldn't it be recursive?

[17:09] <Alias_> or is that not normal too

[17:09] <Alias_> I'm kind of feeling around for the "as easy to learn as Ruby" approach

[17:09] <Alias_> (which is my new MI slogan)

[17:09] <Alias_> :)

[17:10] <audreyt> recursive may make sense

[17:11] <Alias_> so people would split it up, but #include "foo/bar.h" ?

[17:11] <Alias_> I've never really understood C namespacing/dirs/etc

[17:12] <audreyt> the thing is everyone does it differently

[17:12] <audreyt> see Compress::Zlib for another example

[17:12] <Alias_> got any more?

[17:12] <Alias_> Even finding YAML::Syck was hard

[17:13] <audreyt> the usual case

[17:13] <audreyt> where it's just a .xs file

[17:13] <audreyt> requires no special declaration whatsoever

[17:13] <audreyt> it's only needed if you either include other .h/.c files

[17:13] <Alias_> meaning one and one only .xs file in the root dir, or something like that right?

[17:15] <audreyt> yup

[17:17] <Alias_> Is that a EUMM thing, or can we remove that?

[17:17] <Alias_> It would be nice to keep things declarative an d predictable, rather than magic :)

[17:18] <audreyt> it's a EUMM thing, though I'd argue it should Just Work much like .pm files

[17:18] * Alias_ nods

[17:18] <audreyt> (I may need to run for dinner soonish)

[17:18] <Alias_> cc/stuff

[17:18] <Alias_> or something

[17:18] <Alias_> So, something like cc_autocompile '.'

[17:18] <Alias_> although that reads wrong

[17:19] <Alias_> cc_build '.' ?

[17:19] <Alias_> which would be cc_inc_paths + File::Find and add all .c and .xs

[17:19] <audreyt> that sounds good

[17:20] <Alias_> And I'd like to rename c_files to cc_c_files, but it's not as important as inc_path

[17:20] <Alias_> it also looks wrong :)

[17:27] *** pdcawley joined
[17:27] *** calanya joined
[17:28] *** kisu joined
[17:52] *** justatheory joined
[17:52] <rafl> audreyt: Do you already know if you can come to GPW?

[18:01] <Alias_> hmm, I just realised an amazing feature of Module::Install

[18:01] <Alias_> It allows you to deprecate old features really really quickly :)

[18:01] <Alias_> (in relative terms)

[18:04] *** Amnesiac joined
[18:08] <putter> Alias_: how so?

[18:09] <Alias_> Well, because it doesn't matter what the end user has, and only what the author has, it means a relatively much smaller number of people need to adapt

[18:10] <Alias_> And authors are generally much smarter and easier to control

[18:10] <putter> ah :)

[18:10] <Alias_> So if I replace c_files with a die "Deprecated, use cc_c_file" I can skip the whole "keep it" and "keep it, but warn" stages

[18:15] <putter> got it.  a nice property.

[18:15] <putter> wonder how more things could be made to have it...?

[18:15] <Alias_> heh

[18:15] <Alias_> not many

[18:15] <Alias_> I suspect it's a particular property of installers

[18:15] <Alias_> Bundling redundant extra code with you is a positive in that case

[18:19] <putter> hmm.. though in p6, you can request particular flavors of module... i don't remember if foobar-joe-1.30 and foobar-bob-0.05 modules can coexist at runtime... i think so...

[18:19] <Alias_> yes

[18:19] <Alias_> C/C# style versioning

[18:20] <obra> putter: larry put this in the synopsis.

[18:20] <putter> err, "C style versioning"?  ;)

[18:20] <putter> obra: ah, great.  tnx

[18:26] <putter> hmm.  foobar-1.3.0-joe.  different order, hmm...  I imagine one might end up saying a lot of  use Something-(Any)-joe.  because joe and bob have entirely unconnected concepts of what the name "Something" applies to.  the hierarchy looks like authority-name-version, but it's been shuffled to optimize for the "agreement on name" case.

[18:47] *** orafu joined
[18:49] <putter> It could be nice to have an "annotated" p6 spec.  which not only said what's what, but also described the thinking behind it.  maybe?

[18:50] <Alias_> audreyt: ping?

[18:51] *** nnunley joined
[18:54] *** ilogger2 joined
[19:10] <robkinyon> I'm not sure where to ask this, but what is "self-tying" and why is it so horrible?

[19:11] <robkinyon> I ran into the "self-tying of arrays and hashes is not allowed" error and the only thing i can find on it through google is that it was removed in 5.8.9

[19:11] <robkinyon> errr ... 5.8.0

[19:11] <robkinyon> (I'd ask in #perl, but I've asked questions there before)

[19:55] <putter> robkinyon: re what is, just from the name I imagine it's something like  {package A;sub new {bless $_[1],$_[0]}} my @a; tie @a, A, \@a;  so @a is both the variable tied, and the object it is tied too.  aside from being hard to use (A methods would have to untie/retie if they wished to use its contents), perhaps it required

[19:55] *** qwacky joined
[19:56] <putter> some internals gymnastics.  ie, @a, the object itself (not merely its contents), would have a ref to itself (the tie ref), so the gc would have to understand this possiblity, and untie it if it had only one ref...  so perhaps pain and limited utility.

[20:06] <stevan> audreyt: ping

[20:06] <stevan> hey putter :)

[20:09] <robkinyon> putter: Thanks

[20:10] <robkinyon> i don't think it would be that hard to use

[20:11] <robkinyon> but, i was storing object data in a separate %object_data hash keyed by the stringification of the retval of tie(

[20:11] <audreyt> stevan: yes?

[20:12] <audreyt> stevan: I'm 1.5 chapters into TAOMP

[20:12] <stevan> audreyt: I havent heard back from tpf yet, do you know something I dont ? :)

[20:12] <audreyt> stevan: I happen to, yeah :)

[20:12] <stevan> ah,.. oh well

[20:13] <stevan> how do you like AMOP?

[20:13] <audreyt> so I'll come visit you instead

[20:13] <stevan> audreyt: that works :)

[20:13] <audreyt> AMOP is nice

[20:13] <stevan> however, the sushi is not as good here :)

[20:13] <audreyt> though very elementary so far

[20:13] <audreyt> because you've brainwashed me already

[20:13] <stevan> audreyt: :)

[20:14] <stevan> the more interesting bits come when they break down the ways to extend the MOP

[20:14] <stevan> I am working on that kind of stuff with Class::MOP right now actually 

[20:15] <stevan> I have been thinking that we need to seperate the MOP for p6 from the new/bless/CREATE/BUILDALL/BUILD part

[20:15] <robkinyon> stevan: Will the MOP allow you to specify how WALK and WALKMETH is going to work?

[20:15] <stevan> robkinyon: I think it should yes

[20:16] <robkinyon> That would be very cool.

[20:16] <stevan> in other words,.. I dont want the MOP to be tied to S12 at all

[20:16] <audreyt> <aol/>

[20:16] <audreyt> I think that's the way to go, yeah

[20:17] <robkinyon> does that mean you want to describe S12 in terms of the MOP or are S12 and the MOP in parallel?

[20:17] <stevan> S12 should be implemented in terms of the MOP

[20:17] *** KingDiamond joined
[20:17] <stevan> I am gonna try doing it with Class::MOP first

[20:17] <robkinyon> So, if that's the case, then can I ditch S12 and implement Rob::S12 instead?

[20:18] <stevan> see what happens there

[20:18] <robkinyon> s/can I/should I be able to/

[20:18] <stevan> robkinyon: yes you can :)

[20:18] <robkinyon> LOL

[20:18] <stevan> S12 ties the MOP down in too many places and makes things like repr types and containers a real pain

[20:19] <stevan> they should not be a pain, they should be simple, but they should not be tied to the rest of the object system 

[20:20] *** buu joined
[20:20] <robkinyon> So, you're saying that S12 should make a set of duck-typed requirements upon the thing that I can build with the MOP

[20:20] <robkinyon> then, if I want, I can build Rob::S12 and someone else can build Ruby::S12 and everyone's happy?

[20:21] <stevan> no, I am saying that there should be a MOP deep down which gives you the most generic (class|prototype) based object system we can muster, and what you hack on top of that is your business :)

[20:22] <stevan> S12 will be the default

[20:22] <stevan> to a certain degree the MOP becomes an implementation detail

[20:22] <robkinyon> but, there are going to be P6 subsystems that are going to depend upon a certain implementation of containers

[20:22] <stevan> which allows parts/all of it to be optimized out if you want

[20:22] <stevan> robkinyon: nope, same deal

[20:23] <stevan> implementation detail

[20:23] <robkinyon> uhh ... i don't think so

[20:23] <stevan> everything should depend on the public APIs

[20:23] <stevan> or its an implementation detail IMO

[20:24] <robkinyon> which are built atop of S12

[20:24] <robkinyon> or some S12-implementing item

[20:24] * robkinyon & # dishes ... groceries .... you'd think I was married!

[20:24] <stevan> S12 is a public API

[20:24] <stevan> things must conform to it 

[20:27] *** orafu joined
[20:29] *** sapper joined
[20:33] *** p5evalbot joined
[20:48] <svnbot6> r9054 | audreyt++ | * pugs -CParse-HsYaml backend for yaml-node based serialization.

[20:48] <svnbot6> r9054 | audreyt++ | * slightly improved DrIFT.YAML syntax.

[20:51] <Alias_> What's DrIFT do btw?

[20:52] <Alias_> A YAML implementation in Haskell/P6/PIL?

[20:52] <gaal> no, it's a haskell-intelligent preprocessor. it lets you do metaprogramming in haskell.

[20:53] <Alias_> That sounds scary...

[20:53] <gaal> we use it to add YAML serialization instances to our data structures

[20:53] <Alias_> So now Haskell is even more obfuscated :)

[20:53] <gaal> ("instances" in haskell means something like "role consumer")

[20:54] <Alias_> again in english?

[20:54] <gaal> nah, consider this example.

[20:54] <gaal> you have a run of the mill data structure that you defined

[20:55] <gaal> data Color = Infrared | Red | Orange | Yellow | Violet

[20:55] <gaal> in haskell, you can add a trait to this type, saying that these possible variants are equatable

[20:56] <gaal> so that haskell automatically knows to tell that Orange == Orange but Red /= Orange

[20:56] <gaal> this is spelled simply "derives Eq"

[20:56] <Alias_> is /= is !=?

[20:56] <gaal> the nice thing is that unless you're doing funky stuff, you don't have to suply the code for this yourlsef

[20:56] <Alias_> erm, is /= haskell for != ?

[20:56] <gaal> yes

[20:57] <integral> =^H/

[20:57] <Alias_> ok

[20:57] <Alias_> And so this will let you bulk-import stuff from yaml files?

[20:57] <gaal> you can similarly say that these different possible values have an inherent ordering

[20:57] <Alias_> right

[20:58] <gaal> so you want to ask whether Red < Infrared and get False

[20:58] <gaal> you can do this with "deriving Ord"

[20:58] <gaal> (s/derives/deriving/ above)

[20:58] <gaal> that's a standard "typeclass"

[20:58] <Alias_> deriving being in essense "dwim as long as it's right"

[20:59] <gaal> in Perl 6 Roles fulfil the same, er, role, more or less

[20:59] <Alias_> to the parser...

[20:59] <Alias_> right

[20:59] <gaal> you can say that your data type does (say) Eq, but doesn't inherir the defualt implementation at all

[21:00] <gaal> there are a number of useful standard classes

[21:00] <Alias_> right

[21:00] <gaal> two very cool ones being "Show" and "Read"

[21:00] <gaal> which stringify stuff and back

[21:00] <Alias_> And so when do we turn to what drift does :)

[21:00] <gaal> ?eval {a=>"moose"}.perl

[21:00] <gaal> ok ok :)

[21:01] *** evalbot_9024 is now known as evalbot_9054

[21:01] <evalbot_9054> "\{(\"a\" => \"moose\"),}" 

[21:01] <gaal> now say you invent a new typeclass of your own

[21:01] <gaal> oh, I don't know, YAML :)_

[21:01] <gaal> you don't want to go to your 17000 user-defined types and write code ("methods") for them, right?

[21:02] <gaal> the computer can do that for you

[21:02] <Alias_> do you normally do that though

[21:02] <gaal> but it's not so simple to let something like the c preprocessor do it, because sometimes you need to be very careful

[21:02] <Alias_> Do most Haskell programmers have big chunks of code for types?

[21:02] <gaal> how do you mean?

[21:03] <Alias_> Are types done currently with code

[21:03] <Alias_> Is this filling a need in that way

[21:05] <gaal> oh, well, by type we mean a type of a data structure

[21:05] <Alias_> asin Color

[21:05] <Alias_> as in

[21:05] <gaal> so a node in the AST can be say a function application

[21:05] <Alias_> erk...

[21:06] <gaal> App Exp (Maybe Exp) [Exp]

[21:06] <Alias_> OK! My LambdaCamel shipped without a Camel! 

[21:06] <gaal> don't worry, that simply means...

[21:06] <Alias_> This Camel needs a Camel :)

[21:06] <gaal> say "hi!"

[21:07] <Alias_> don't worry

[21:07] <Alias_> I just spent 4 hours debugging CPAN.pm on the new Win32 Perl, my WPU is nearly spent

[21:07] <gaal> ==> _Apply_ the code _&say_ to (no invocant, this is a function) with the arglist ["hi!"]

[21:08] <gaal> if you enter the interactive pugs shell and do :d say "hi!", you'll get it pretty-printed in one format

[21:09] <gaal> because App is an instance of Show

[21:09] <Alias_> ok

[21:09] <gaal> (well actually, App is just one variant of an AST node, like Orange is just one variant of Color)

[21:09] <gaal> so any Color knows how to Show itself

[21:10] <gaal> as does any Exp

[21:10] * Alias_ runs

[21:10] *** Odin-FOO joined
[21:10] <gaal> if you want to have a Color show itself in YAML, you have to write an "asYAML" method on the type Color

[21:11] *** Odin-FOO is now known as Odin-LAP

[21:11] <gaal> that would emit the part of the YAML representation that is needed

[21:11] <avar> does p6 yaml support anon functions?

[21:11] <gaal> in the case of a color, it's trivial, just a string

[21:12] <gaal> avar: sure

[21:12] <Alias_> gaal: wouldn't that open the door for major security issues?

[21:12] <avar> $ perl -MYAML -e 'print Dump $s = { subptr => sub { "foo" }}'

[21:12] <avar> ---

[21:12] <avar> subptr: !perl/code: '{ "DUMMY" }

[21:12] <avar> p5 doesn't...

[21:12] <avar> gaal: is that compatable across languages?

[21:12] <avar> i.e. can I run my perl 6 anon subs on ruby

[21:12] <Alias_> avar: YAML isn't compatible across languages

[21:13] <gaal> in the case of sometihng more complex, like the syntax for function application, you have to stanradrize on a representation you can make sense of when you want to deserialize

[21:13] <avar> it kind-of-is

[21:13] <Alias_> avar: You need to have a matching serialize/deserializers for each thing in each language

[21:13] <Alias_> avar: Otherwise... erm... something

[21:14] <gaal> avar: grab a recent pugs and do "./pugs -CParse-YAML -e '{ say "I am a closure" }.()'

[21:14] <gaal> how's this a security issue?

[21:14] <Alias_> gaal: The whole point of most exploits is to trick you into running code

[21:14] <Alias_> gaal: When your data structure embeds arbitrary code, that gets a whole lot easier

[21:15] <Alias_> That whole data/code seperation issue

[21:15] <integral> but it's not encoding code, it's encoding data...

[21:15] <gaal> now it turns out that for the majority of data types, there's a standard way of doing things that works

[21:15] <gaal> but sometimes it breaks down, notably in circular references

[21:15] <integral> it's not code code,  but code as an AST, reified,  so it's not actual code when it's in the YAML

[21:15] <Alias_> integral: um... { system 'rm -rf ~' }.()

[21:16] <Alias_> it still does things

[21:16] <integral> Alias_: no, it's not like that at all.  It's like giving you the string "rm -rf",  rather than an executable shell script of the same

[21:16] <gaal> Alias_: it's no different from the risk of eval

[21:16] <Alias_> gaal: Which is why Data::Dumper is completely unsafe as a data serialization language

[21:16] <Alias_> And why we use things like XML

[21:16] <integral> Alias_: umm, my point is that when this YAML is unserialised this stuff isn't run...

[21:17] <Alias_> integral: are you sure?

[21:17] <gaal> NAK. we are serializing code, not business data

[21:17] <Alias_> What if it's a init code to a class hook that runs it

[21:17] <gaal> the whole intention is to run this code

[21:17] <integral> yes, it's the difference in Data::Dumper output between: $VAR1 = { case1 => "sub foo { unlink('.') }", case2 => unlink(".") };

[21:17] <gaal> if the serialized stream is tampered with, sure an attack can be injected

[21:17] <integral> Alias_: we've got the first, because this code *is* data.  Because we're INSIDE a compiler.

[21:17] <gaal> that's like me editing your files on your fisk.

[21:18] <gaal> *disk.

[21:18] <Alias_> integral: Right, and the exploit would be finding some deserialisation class that runs it (though you don't realise it might)

[21:18] <Alias_> or finding some other way to trick you into running it

[21:18] <integral> Alias_: A deserialisation class that just eval'ed any string?

[21:18] <Alias_> integral: See, you hadn't even considered it

[21:19] <integral> I think someone's either being silly, or misunderstanding how to exploid serialised things.

[21:19] <gaal> Alias_: we're talking about things that are all replacements for "eval" in use anyway

[21:19] <integral> *exploit

[21:19] <Alias_> someone goes and uses this shiny new anon code feature, and it only takes one person to use it in some bit somewhere and forget it's completely untrusted

[21:20] <integral> umm, no.

[21:20] <Alias_> And if you have that things installed, all of a sudden I've got arbitrary execution

[21:20] <gaal> whoa whoa :) what shiny new non code feature? :)

[21:20] <integral> Alias_: Let's imagine two readline functions.

[21:20] <Alias_> or perhaps closer, a Storable class

[21:20] <integral> One reads a line from the keyboard and returns it.  The other does that, but if the first char is ! interprets it as code, and returns the result of that code.

[21:20] <integral> Data::Dumper has the second feature,  YAML does NOT.

[21:20] <Alias_> sure it does

[21:21] <Alias_> Because it has equivalents of Storable hooks

[21:21] <integral> no, it doesn't have something which says "instead of serialised data, here's some code instead that will give you the data"

[21:21] <integral> Alias_: but they're not in the data stream itself.

[21:21] <Alias_> right

[21:22] <integral> Someone would have to put a hook in the app that did an eval.   But *all* serialisation schemes can have someone put an eval into the app!

[21:22] <Alias_> not the app

[21:22] <gaal> Alias_: the purpose of YAML in the internals work we've been doing is not user tools (although those could be useful)

[21:22] <Alias_> Any class

[21:22] <Alias_> Any class that acts as a YAML hook

[21:22] <Alias_> Because it will autoload the class

[21:22] <Alias_> or at least, if ingy did something similar to Storable it well

[21:22] <Alias_> will

[21:22] <Alias_> (because I don't know any other way to do it)

[21:22] <integral> ugh, autoloading classes?!

[21:23] <Alias_> How else do you deserialize things

[21:23] <gaal> which things?

[21:23] <Alias_> oh, for example, a singleton

[21:23] <Alias_> or a database handle

[21:23] <integral> bleh,  I like haskell too much where "data" is this nice fixed well defined thing, and it's just typeclasses that vary

[21:23] <gaal> and for which purpose?

[21:23] <Alias_> gaal: To serialize a larger object that contains one

[21:24] <gaal> Alias_: for the compiler, of for the application?

[21:24] <integral> anyway, this particular "feature" of the perl YAML has nothing to do with the haskell YAML luckily.

[21:24] <Alias_> integral: It's not a feature of Perl so much as a feature of any sufficiently advanced serialization mechanism

[21:24] <Alias_> It requires some sort of code-assisted serialize/deserialize

[21:25] <integral> Alias_: and an open world model.

[21:25] <Alias_> And so what happens if you don't have every single class already loaded you encounter in the data stream?

[21:25] <Alias_> it dies?

[21:25] <Alias_> I hope so

[21:25] <gaal> are you talking haskell type or perl class?

[21:25] <Alias_> language-neutral

[21:26] <integral> alias must be talking about perl

[21:26] <Alias_> deserialization handler

[21:26] <gaal> don't confuse the internals of the compiler with user-visible technologies perl provides

[21:27] <Alias_> YAML has class-tagged nodes

[21:27] <gaal> sure

[21:27] <Alias_> they have handlers

[21:27] <Alias_> ?

[21:27] <integral> sure, but in a closed-world application all the handlers are part of the app.

[21:28] <Alias_> ok

[21:28] <Alias_> So you start a YAML stream

[21:28] <integral> and the current YAML for haskell has no idea of how to start using hs-plugins

[21:28] <Alias_> And you're going along, and YAML says node "Foo"

[21:28] <Alias_> And you don't have a class Foo loaded

[21:28] <Alias_> then what? exception?

[21:28] <gaal> who's "you"? a perl program or the perl compiler?

[21:28] <integral> yes.

[21:29] <integral> The thing haskell is loading has a concrete type,  not just an interface that it complies to.

[21:29] <Alias_> ok then

[21:29] <Alias_> So no way to load that class

[21:29] <Alias_> that's all fine

[21:29] *** dduncan joined
[21:29] <integral> We know it's *exactly* a tree made from these types of components,  not the other view where we know it's a "tree" that has all these methods

[21:29] <Alias_> it introduces other problem, but those are functionality thigns

[21:30] <Alias_> uh... a yaml tree?

[21:30] <Alias_> oh, haskell

[21:30] <Alias_> I wasn't talking about any particular language

[21:30] <Alias_> It's not a language issue, it's a serialize/deserialize algorithm problem

[21:30] <integral> *sigh*

[21:31] <gaal> Alias_: I still think you're confused. The current YAML work is, in the bottom line, just one technique for the compiler to store program data.

[21:31] <Alias_> And you gave me the answer I wanted, in Haskell's case it can't handle encountering a class-tagged node that isn't already loaded

[21:31] <gaal> it's program data anyway. if someone could manipulate it they could make the perl it represents do evil things

[21:31] <integral> Alias_: that's not a very good way to be viewing what you've got.

[21:31] <gaal> but I don't see your threat model.

[21:32] <integral> In haskell you've got data, plain old data,  it doesn't have methods.   What you normally seralise in perl are objects and an object is both data *and* the behaviour.

[21:32] <Alias_> integral: That is not the issue

[21:32] <integral> Yes, it is.

[21:32] <Alias_> no, it isn't

[21:32] <integral> Yes, it is.

[21:33] <Alias_> The threat model NEVER has to call an object method

[21:33] <Alias_> So the object's behaviour is NOT a problem

[21:33] <integral> But if you're not loading an object, there is no "class tagged node that isn't already loaded"

[21:33] <Alias_> right

[21:33] <Alias_> well, not entirely, but close enough

[21:34] <integral> That's my point, your final statement was close enough but not entirely.

[21:34] <Alias_> but lets say yes for the sake of argument

[21:34] <gaal> Alias_... we're currently loading nodes in a parse tree. If someone controls these nodes, the program that'll get run will be pwned anyway

[21:35] <Alias_> That's not true... 

[21:35] <Alias_> Otherwise XML would be impossible

[21:35] <Alias_> And you could exploit everything

[21:35] <gaal> well anymoose. I have to sleep now

[21:35] <gaal> good night :)

[21:36] *** calanya joined
[21:36] <integral> Alias_: well you can.   XML that is XHTML containing a <script> tag that is run with full permissions of the browser user.

[21:36] <Alias_> exactly

[21:36] <Alias_> because someone OTHER than you implemented it

[21:36] <gaal> zZ&

[21:36] <integral> So, yes, in this case, the one gaal talks about, it is true.

[21:37] <Alias_> But in that case, you know it's XHTML

[21:37] <Alias_> actually, it applies

[21:37] <Alias_> ideally you'd be using data types with no support for that

[21:37] <Alias_> So you can not have to worry

[21:38] <Alias_> And no support for injecting arbitrary types into the node stream

[21:38] <Alias_> because the format is closed

[21:38] <Alias_> YAML supports arbitrarily tagged nodes

[21:39] <Alias_> Much like I guess you could say any XML document could set a namespace to be XHTML

[21:39] * integral gives up &

[21:39] <Alias_> If the XHTML handler loads on demand, then just by virtue of having an XHTML handler installed, any XML document can execute arbitrary code

[21:39] *** DesreveR joined
[21:40] <Alias_> without ever calling a "method" on the <script> object

[21:42] <Alias_> See, I said I needed a camel

[21:42] <Alias_> ... with my lamda

[21:42] * Alias_ wander off

[21:45] <audreyt> Alias_: YAML has arbitrarily tagged nodes, yes. we ignore everything but the tags we know how to handle.

[21:45] <Alias_> See!

[21:45] <Alias_> One camel and my issue is resolved in a single line

[21:45] <audreyt> it's a fatal error, actually.

[21:45] <Alias_> :)

[21:45] <Alias_> good

[21:45] <Alias_> Then it's not a security problem

[21:46] <audreyt> I'd be very sure it's not, yeah :)

[21:46] <Alias_> Well, unless you preload any handler you don't understand that executes the code block

[21:46] <Alias_> either way, I still think it turns something patently stupid "executing an arbitrary string of code" into something more tempting "executing nice trustworthy code trees"

[21:47] <audreyt> yes.

[21:47] <audreyt> though we were doing that patently stupid thing at the first place

[21:47] <audreyt> in loading Prelude.pm and run it

[21:47] <Alias_> and that approachability is often half the problem

[21:47] <audreyt> and we are just replacing that into the more tempting (and easier to check) code trees.

[21:47] <Alias_> well, it's the handler that's the problem really, not the actual code

[21:48] <audreyt> right. and in this case, we write no handler ourselves

[21:48] <Alias_> that only matter once the handler might potentially execute it

[21:48] <audreyt> the handler is derived from the static structure of the types that we are accepting.

[21:48] <audreyt> there is no human intervention possible in writing handlers.

[21:48] <Alias_> in your case :)

[21:48] <audreyt> yeah. :)

[21:48] <Alias_> For an exploit to happen, generally 5 things go wrong

[21:48] <audreyt> (I agree with your general analysis.)

[21:48] <Alias_> 1 being "YAML supports code"

[21:49] <audreyt> (just that we are not tripping it)

[21:49] <Alias_> right

[21:49] <Alias_> BTW, I'm very close to throwing Module::Install::Compiler away :)

[21:49] <audreyt> excellent

[21:49] <Alias_> I had a read of what the makefile params actually do

[21:49] <Alias_> And I'm amazed you can make anything work with what's in ::Compiler :)

[21:50] <Alias_> well, not true

[21:50] <Alias_> I'm amazed you can make something like YAML::Syck work

[21:50] <audreyt> excellent :)

[21:50] <Alias_> Which would seem at first glance to exceed the notional complexity threshhold

[21:51] <Alias_> I'll probably need some help here and there to work out which commands can be implemented that are useful to real life XS coding

[21:51] <Alias_> I have some ideas

[21:51] <Alias_> but I'm dealing with some support code first

[21:52] <Alias_> I also don't have the time for a job this big :)

[21:52] <Alias_> But so you know, don't release 0.57 without talking to me first

[21:52] <audreyt> I'll leave it for you to release anyway.

[21:52] <Alias_> Because there's some transitional things there and it's not really quite in release state

[21:53] <Alias_> I'd also like some help at some point on testing

[21:53] <Alias_> Create me a sample test case for example...

[21:53] <Alias_> not sure exactly how to make one without risking actually installing things or interacting with the parent install

[21:53] <Alias_> :)

[21:55] <audreyt> *nod*

[21:55] <Alias_> And I'm trying to resist rewriting the whole thing

[21:55] <Alias_> But that's par for the course

[21:56] <Alias_> :)

[21:56] <Alias_> And it's fractally complex, so too many risks

[21:59] *** ayrnieu joined
[22:43] <svnbot6> r9055 | gaal++ | * DrIFT.YAML - add a default, erroring instance for fromYAMLElem,

[22:43] <svnbot6> r9055 | gaal++ |   thus eliminating trillions of pesky warnings.

[22:45] <gaal> you can tell you're under an Audrey field when you commit after you'd gone to sleep

[22:45] <beppu> Alias_, this is the Module::Install ticket you asked me to write last night:  http://rt.cpan.org/Public/Bug/Display.html?id=17731

[22:45] <beppu> It's about being able to customize what happens during installation.

[22:46] <Alias_> ok

[23:32] *** scook0 joined
[23:35] *** drbean joined
[23:51] *** lumi joined
[23:51] <Alias_> beppu: I've replied to your bug btw, on the subject for share, which does exist

[23:51] *** gaal joined
[23:52] <beppu> I'll take a look

[23:52] <Alias_> beppu, and we've got limited etc capability

[23:52] <Alias_> See...

[23:52] <Alias_> File::UserConfig

[23:53] <Alias_> That's a user-specific etc, but it fits into the resource model properly

[23:53] <beppu> I didn't know about these.

[23:53] <Alias_> I only wrote them at Christmas :)

[23:54] <Alias_> The share stuff has existed for ages, but is arcane and few people know about

[23:54] <Alias_> I wrapped some user-friendly shell around it when audreyt told me it existed

[23:54] <Alias_> The File::UserConfig is just a combination of that, plus the new File::HomeDir implementation

[23:55] <Alias_> more an elegant trick than a full on resource though

[23:55] <Alias_> but correct

[23:55] <beppu> I'll consider using these.

[23:55] <Alias_> doing system etc has issues

[23:55] <beppu> It's hard to be portable, right?

[23:55] <Alias_> So I have no answers for that, yet

[23:55] <Alias_> very

[23:55] <Alias_> Perl runs on 100+ platforms

[23:56] <Alias_> which is under the skin, share is a variation on lib

[23:56] <Alias_> which is why ...

[23:56] <Alias_> And homedir is only tested on Win32, basic Unix and OS X

[23:56] <Alias_> So there might be variations

[23:56] <beppu> that covers a lot, though.

[23:57] <Alias_> enough for desktop applications :)

[23:57] <Alias_> Which is what I'm using it for

[23:57] <beppu> It's mostly Win32 that would be problematic, I would think.

[23:57] <Alias_> it's all three

[23:57] <Alias_> for homedir at least

[23:57] <Alias_> Mac OS X is not entirely like Unix

[23:58] <beppu> what about the share stuff.  How does that work using File::ShareDir?

[23:59] <beppu> nvmd.  i rtfm'd.

[23:59] <Alias_> Module::Install::Share provides the stuff to install it to the right place, which is the same technique used by autosplit and other core modules

[23:59] <Alias_> File::ShareDir adds the logic to locate it afterwards

