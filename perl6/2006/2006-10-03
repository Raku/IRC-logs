[00:03] *** spoop joined
[00:08] *** lisppaste3 joined
[00:13] *** vel joined
[00:21] *** nekokak joined
[00:26] *** putter joined
[00:26] <TimToady> is that ねこかき or ねこかく or ねこかっ？

[00:31] <TimToady> nekokak: is that ねこかき or ねこかく or ねこかっ？

[00:31] <TimToady> or is it finnish?

[00:33] <TimToady> or is it mojibake on your terminal?

[00:35] <mugwump> TreyHarris: I'm doing a design for O/R mapping, and trying to figure out how to tell that attributes are parts of the primary key

[00:35] <TreyHarris> i wonder if there's some way to tell colabti.de that #perl6 should be considered to be a utf8 channel, i always have to change the encoding from western-1

[00:36] *** etzel joined
[00:36] <TreyHarris> mugwump: hmm... wouldn't doing it using .WHICH, even if it worked that way, require doing it experimentally?  (i.e., if changing this attribute results in a new object, i must have changed something in the primary key?)

[00:37] <mugwump> that's why I think WHICH is a macro, not a function

[00:37] <TreyHarris> what does the macro do?

[00:38] <mugwump> but that can't work, because you have runtime type hopping.  hmm.

[00:38] <mugwump> ok, here's the application;

[00:38] <mugwump> say I've got a class which I'm expected to be automatically backed by a database;

[00:39] <mugwump> class Dog { has Str $.tag; has Country $.registered_country; has Num $.weight; method WHICH of (Str, Country) { $.tag, $registered_country } }

[00:40] <mugwump> from that, I can tell I need to create a table with two columns, but I have to guess which properties are a part of the key

[00:43] <TreyHarris> you mean, from outside the class you can't tell

[00:44] <TimToady> this sounds like the sort of stuff you should be talking over with dduncan

[00:44] <TreyHarris> but can WHICH return any arbitrary data, including a Seq like that?

[00:45] <TimToady> TreyHarris: yes, or we should just rewrite colabti's Python script in Perl...

[00:45] <TimToady> WHICH is required to return something that is comparable with ===

[00:45] <mugwump> Yeah, I ran a paper past dduncan on this, and he liked it

[00:45] <mugwump> he's been the one to comment on it the most so far

[00:46] <TimToady> we let people override WHICH to make value types, but using the override to make flapping-in-the-wind types would be erroneous

[00:46] <TreyHarris> eh, I thought === was defined in terms of WHICH?

[00:46] <TimToady> they are defined in terms of each other.

[00:46] <mugwump> turtles all the way down and all that :)

[00:46] <TreyHarris> define "flapping-in-the-wind types"?  sorry, haven't heard that term before

[00:47] <mugwump> that's variant WHICH return values

[00:47] <TimToady> objects that change their identity on the fly

[00:47] <TimToady> would drive a sane hash nuts.

[00:47] <TimToady> WHICH is supposed to be immutable

[00:48] <mugwump> ok, in my paper [http://utsl.gen.nz/talks/dbic-tangram.pdf], I'm going to say that the behaviour if changing attributes that affect .WHICH is undefined and implementation-specific

[00:48] <TreyHarris> i think that was the bone of contention earlier.  .WHICH is immutable, or its mutating indicates that you no longer have the same object?

[00:48] <TimToady> I do love the term "erroneous". :)

[00:49] <mugwump> Well, I think to dictate either behaviour would hurt the VM that doesn't work like that.

[00:49] <TreyHarris> mugwump: thinking of it in terms of Tangram does make it clearer what you're asking though :)

[00:50] <lumi> I love the phrase "So don't do that."

[00:50] <mugwump> One other small thing, I'm using 'of' incorrectly.  I need a new preposition

[00:50] <mugwump> Seq of (Int) doesn't mean a sequence of exactly one int as specced

[00:50] <mugwump> Or does it?

[00:51] <mugwump> Seq of Int sure means a sequence of integers of any length, is Seq of (Int) different enough?

[00:51] <TimToady> not necessarily, the Seq role can interpret its parameter however it likes.

[00:52] <TimToady> it doesn't have to distribute the "of" like Array necessarily

[00:52] <TreyHarris> or "of Seq[Int]" versus "of Seq[Int, Int]" versus "of Seq[Int, Int, Str, Int]"

[00:52] <TimToady> so maybe Seq of (Int*) is the distributed form

[00:52] <mugwump> is that a new use of postfix:<*> ?

[00:52] <TimToady> the "slurpy" form.

[00:53] <TimToady> no

[00:53] <mugwump> oh, like a method sig

[00:53] <TimToady> maybe it has to be written Seq of :(Int*)

[00:54] <TimToady> or Seq of :(Int)

[00:54] <TimToady> seems a little inside out

[00:54] <TreyHarris> yeah... if a sig has Type as a parameter, it would be nice if Int as an argument would be interpreted as ::Int, and not as Int()

[00:54] <TimToady> Seq[:of(:(Int))]

[00:54] <mugwump> heh

[00:55] <TreyHarris> then just Seq[Int] could work, no?

[00:55] <TimToady> well, that's what Seq of :(Int) means.

[00:55] <TimToady> depends on how the sig of Seq is declared I imagine

[00:55] <mugwump> I'd write it Seq[ of => :(Int) ] to avoid the very close use of two different meanings of :

[00:56] <TimToady> if role Seq is splatting the Type param already, then Seq of (Int,Int) could work

[00:57] <TimToady> if it's expecting only a single arg which is a sig, then no

[00:58] <TimToady> the latter is probably more consistent

[00:58] <TimToady> variadic types outside of signatures is a bit suspect, notationally.

[00:59] <TimToady> I would expect List of Int to distribute though.

[00:59] <mugwump> yeah, I think I'd rather use a parametric collection type than have variable length parts of a Seq

[00:59] <TimToady> but Seq is more like Scalar, except with more bits in it

[00:59] <TreyHarris> yes.... but TreeNode[::X = Whatever] would be legal, though, if you're never going to take variadic args, yes?

[01:00] <mugwump> hmm, variadic args are more like TreeNode[\$capture]

[01:00] <mugwump> s/args/types/

[01:01] <TimToady> I can well imagine other uses for the variadicness of such an argument list, so maybe it's better to limit types to a single parameter

[01:02] <TimToady> especially since :of is named.

[01:02] <TreyHarris> i forgot, do we write that TreeNode[::X = Whatever] or TreeNode[::X = *] ?

[01:03] <mugwump> Well, in the Seq case we want more than one, for our Seq of :(Int, Str, Int)

[01:03] <TimToady> I think use * as rvalue and Whatever to match against it in a sig.

[01:03] <TimToady> but the default is an rvalue

[01:03] <mugwump> But I could fully forgive a role implementation for not supporting certain classes of Signature

[01:03] <TimToady> sure

[01:04] <TreyHarris> TimToady: ok.  so TreeNode[::X = *] but multi dwim (Whatever $x) { ... }

[01:04] <mugwump> hmm, perhaps the role requires a hook during role or class composition, too

[01:04] <TimToady> In general the $x is not necessary

[01:05] <TimToady> since Whatever is presumably a singleton

[01:05] <TreyHarris> sorry, I was using ... as "fill in here" rather than "yada-yada"

[01:05] <TreyHarris> so I was saying "I'll take an arg of any type and use it as $x below"

[01:05] <TimToady> doesn't matter, you still don't need the $x

[01:05] <TimToady> that's not what Whatever does

[01:06] <TimToady> Whatever is a very specific type

[01:06] <TimToady> it matches '*' and only *

[01:06] <TimToady> if you want any type, use Any

[01:06] <mugwump> unless you also want to match junctions, in which case use Any|Junction :)

[01:06] <TimToady> whatever is for default case selected from the caller's end.

[01:07] <TreyHarris> right, I remember that now.

[01:07] <TimToady> so you'll have a lot of specific multis and then a special Whatever case

[01:07] <TimToady> 1..10 never matches Whatever, but 1..* does

[01:08] <TimToady> the right arg, that is

[01:09] <TreyHarris> mugwump: Any doesn't match a Junction?  and (3|4|5) !~~ Int?

[01:09] <mugwump> ?eval sub foo(Any $x) { say "I got $x" }; foo(1&2)

[01:09] <evalbot_r13794> OUTPUT[I got 1 I got 2 ] (Bool::True)

[01:10] <TimToady> autothreads

[01:10] <mugwump> ?eval sub foo(Any|Junction $x) { say "I got $x" }; foo(1&2)

[01:10] <evalbot_r13794> OUTPUT[all(VStr "I got 1",VStr "I got 2") ] Bool::True

[01:10] <TreyHarris> ?eval (3|4|5) ~~ Int

[01:10] <evalbot_r13794> (Bool::True)

[01:10] *** weinig|bbl is now known as weinig

[01:10] <TreyHarris> ?eval (3|4|"moose") ~~ Int

[01:10] <evalbot_r13794> (Bool::False | Bool::True)

[01:10] <TimToady> we have to be careful because passing an unexpected junction into a sub would make both legs of an if/else run.

[01:10] <TreyHarris> gotcha.

[01:11] <TimToady> (arguably, that's what autothreading does)

[01:11] <TimToady> but the naïve implementation it would do the if and skip the else

[01:11] <TreyHarris> iff the value is both true and false, you mean?

[01:11] <TimToady> despite the fact the the junction is both true and false.

[01:11] <TimToady> yes

[01:12] <TreyHarris> an all-false junction would just run the else, and an all-true would just run the if regardless

[01:12] <TimToady> presumably

[01:12] <mugwump> I'll ask questions about how Junction is defined that gives it this special behaviour some other day, but for now I'm curious as to whether there's a BUILD equivalent for role composition

[01:13] <mugwump> Actually I'll ask Damian that Junction question

[01:13] <TimToady> yes, it's called BUILD.

[01:13] <TreyHarris> mugwump: according to audreyt, BUILD :)

[01:13] <TimToady> all the role BUILDs are magically gathered into the class BUILD at composition time.

[01:13] <TimToady> <insert handwaving character here>

[01:14] <mugwump> but that's an object construction hook, I want a class composition hook

[01:14] <mugwump> eg, to generate some methods in the role based on the type parameters

[01:14] <mugwump> s/roles/class/

[01:14] <mugwump> bah

[01:14] <mugwump> eg, to generate some methods in the class based on the role type parameters

[01:15] <TimToady> that would be in the province of the MRP

[01:15] <mugwump> in a sense, a sub definition that uses a type from the role's type argument does this

[01:15] <mugwump> MRP?

[01:15] <TimToady> just as a class body runs as a MOP object instance, the role body is run by some kind of MRP object instance.

[01:15] *** Qiang joined
[01:15] <TimToady> (I'm making this up on the fly.)

[01:16] <TimToady> anyway, somebody's methods are getting called when that closure runs.

[01:16] <mugwump> sure.  It might be good to have syntax for that sometime so that you don't have to subclass your metaclass to do this, but I think we need parametric roles prototyped first

[01:17] <TimToady> It's possible stevan has already thought this part rather more thoroughly than me.

[01:18] <TreyHarris> mugwump: so "role Antlered { submethod COMPOSE { foo() } }; class Moose does Antlered { #[ ... ] }; class Elk is Moose { #[ ... ] }; my Str $baz = "moose!" but Antlered;

[01:18] <TreyHarris> you'd expect COMPOSE to be called three times at compiletime and once at runtime?

[01:18] <TreyHarris> or four times at compile time?

[01:19] <TreyHarris> er... s/two/; s/four/three/; # can't count

[01:19] <TreyHarris> s/three/two/; # can't write syntactically correct substitutions either

[01:20] <TimToady> and perhaps COMPOSE is a block trait rather than a submethod...

[01:20] <TimToady> or maybe it's a macro

[01:20] <TimToady> hmm.

[01:20] <TimToady> role macros.  yum.

[01:21] <TimToady> installs new declarators, for instance.

[01:22] <TreyHarris> maybe it just gets called once at compile time for Moose; Elk is a Moose and so it defers to Moose its Antleredhood.  so you call just twice.  (maybe it can infer from My Str $baz = "moose!" but Antlered at compile time it needs a Str that does Antlered, but in the general case, you're sometimes not going to know what to compose until runtime)

[01:22] <TimToady> it would be good to avoid keywords that look like they want to be generic when you mean something non-generic.

[01:22] <mugwump> what's an example of a  "declarator"?  I should understand that term, but I don't

[01:22] <TimToady> "my", "has"

[01:23] <TimToady> "requires_method

[01:23] <mugwump> also "method", etc ?

[01:23] <TimToady> "must"

[01:23] <TimToady> yes

[01:23] <TimToady> a role could have special declarators for requirements.

[01:23] <TimToady> if the yadas don't suffice.

[01:23] <TimToady> much like in ruby, but cooler

[01:24] <mugwump> the yadas are runtime anyway, if written method X { ... }

[01:24] <TimToady> as macros you're not limited to one syntax.

[01:24] <TimToady> I think S12 allows the class to assume that all role ... should be resolved at composition time by default.

[01:25] <TimToady> assuming that classes are elaborated in derivation order...

[01:25] <TimToady> so you know whether your parent classes supply the method.

[01:25] *** spoop joined
[01:26] <mugwump> I would have thought that just writing the method signature without a block was enough

[01:26] <TimToady> but I'm just talking through my hat here

[01:26] <mugwump> like a forward declaration of a sub

[01:27] <TimToady> {...} is intended to fail at runtime, but that doesn't mean the compiler can't fail earlier if it can figure it out.

[01:27] <TimToady> it's there for the compiler, not just the human.

[01:27] <mugwump> true, but all those extra characters.  the Portugese will hate it

[01:27] <mugwump> :)

[01:29] <TimToady> {¡*!} might make the Spanish happy

[01:29] <mugwump> What's that, the Siesta operator?

[01:29] <TimToady> dunno, I'll tell you tomorrow.

[01:29] <TimToady> my wife is picking me up in about 1 minute, so gotta dash...

[01:30] <TimToady> biab &

[01:30] <mugwump> seeya!

[01:30] *** mako132_ joined
[01:35] *** buu joined
[01:40] *** buubot joined
[01:42] *** lollan joined
[01:52] <svnbot6> r13795 | mugwump++ | Add test for specifying memoized instances via WHICH

[01:52] <svnbot6> r13795 | mugwump++ | This also allows for singletons.

[01:55] <putter> ?eval my @x = <a b c>; scalar(@a)

[01:55] *** evalbot_r13794 is now known as evalbot_r13795

[01:55] <evalbot_r13795> Error: Undeclared variable: "@a"

[01:56] <putter> ?eval my @x = <a b c>; scalar(@x)

[01:56] <evalbot_r13795> Error: No compatible subroutine found: "&scalar"

[01:56] <putter> didn't there use to be a scalar()?

[02:04] <mugwump> ?eval my @x=^4; +@x

[02:04] <evalbot_r13795> 4

[02:04] * mugwump slaps evalbot_r13795 

[02:05] <mugwump> ?eval my @x=<0 1 2 3 4>; +@x

[02:05] <evalbot_r13795> 5

[02:05] <mugwump> ?eval ^4

[02:05] <evalbot_r13795> (0.0, 1.0, 2.0, 3.0)

[02:06] <mugwump> ?eval my @x=<0 1 2 3 4>; item(@x)

[02:06] <evalbot_r13795> ["0", "1", "2", "3", "4"]

[02:10] <svnbot6> r13796 | putter++ | [t/xx-uncategorized/lexical_variable_in_eval.t]

[02:10] <svnbot6> r13796 | putter++ | Created.  eval_ok isn't seeing lexical variables.

[02:14] *** weinig is now known as weinig|sleep

[02:23] *** chaoslawful joined
[02:23] <mugwump> TimToady: ok, I'm assuming that Seq requires a Capture passed to its :of role parameter to get the per-element typing I use in my paper...

[02:26] <mugwump> ie, Seq of Int works like Array of Int, Seq of :(Int) means a single integer Seq

[02:28] <TreyHarris> like in Haskell, the difference between [Int] and (Int)

[02:29] <putter> ?eval "abc\c[HEBREW POINT HIRIQ]def"

[02:29] *** evalbot_r13795 is now known as evalbot_r13796

[02:29] <evalbot_r13796> "abcÖ´def"

[02:30] <putter> ?eval "abc\c[LINE FEED]def"

[02:30] <evalbot_r13796> Error: Invalid unicode character name: LINE FEED

[02:30] <stevan> putter: !

[02:30] <putter> stevan! :)

[02:30] <mugwump> ?eval "abc\c[LINE FEED (LF)]def"

[02:30] <evalbot_r13796> "abc\ndef"

[02:30] <mugwump> :>

[02:30] <stevan> putter: sorry I missed the Boston.pm thing,.. $work kept me busy until too late in the day

[02:30] * mugwump thinks he might know which file that is using ... :)

[02:31] <putter> ?eval "abc\c[CARRIAGE RETURN]def"

[02:31] <evalbot_r13796> Error: Invalid unicode character name: CARRIAGE RETURN

[02:31] <stevan> mugwump: re: what you were talking about with TimToady eaerlier

[02:31] <putter> stevan: so no problem.  I was going to tell you "sorry I missed the Boston.pm thing,..."

[02:31] <TreyHarris> mugwump: "LINE FEED (LF)" isn't in my unicode name table...

[02:31] <stevan> putter: :)

[02:31] <mugwump> putter: get utsl.gen.nz/scripts/unicode

[02:32] <stevan> mugwump: are you looking to create different sets of methods based on the role generic parameter?

[02:32] <stevan> or specific type based stuff?

[02:32] <stevan> (for Array vs. Str, etc etc)

[02:32] <mugwump> well, this is one possible way to implement any of the parametric role features

[02:33] <putter> mugwump: what is this binary file and why am I getting it?

[02:33] <mugwump> er, it's a script.  sorry, my web server doesn't set mime types for files with no extension

[02:34] <mugwump> then you can go, eg, unicode 'hot springs' to see 'hot springs' chars or unicode '' 20 to see page 20

[02:35] <putter> ah, I see...

[02:35] <putter> ?eval "abc\c[CARRIAGE RETURN (CR)]def"

[02:35] <evalbot_r13796> "abc\rdef"

[02:35] <mugwump> stevan: so, eg, when you write:

[02:35] <mugwump> role Foo[::T] { sub blah(T $x) { ... } }

[02:35] <mugwump> s/sub/method/

[02:36] <mugwump> the "sub" declarator is generating a new signature, composing the role parameter into the class being built

[02:36] <mugwump> s/sub/method/ again

[02:37] <mugwump> anyway, those declarators are methods on the role metaclass

[02:37] <putter> mugwump: thanks!

[02:38] <stevan> mugwump: I always saw Roles as being kind of lazy, but parametric roles as being *really* lazy

[02:38] <putter> so \N{} in p5 tolerates the " (LF)" being missing, but pugs currently doesn't.

[02:39] <mugwump> yeah, they're real louts.

[02:40] <TreyHarris> mugwump: it's generating a new signature?  i would think it's generating the signature :(Foo self: T $x where { self.does(Foo[::T]) }) or something like that.  but my mind may be too polluted with Haskell's type inference....

[02:40] <mugwump> you mean GADTs ?

[02:41] <stevan> TreyHarris: I saw it that way as well

[02:41] <TreyHarris> mugwump: yes, exactly

[02:41] <mugwump> ok, so when you write a parametric role definition like that, you need a concrete type when you use it with "does"

[02:42] <mugwump> then, it composes the method into the class, resolving types that are generic

[02:42] <mugwump> you can't have parametric classes

[02:42] <stevan> mugwump: it might help to look at the role body as being deferred

[02:42] <TreyHarris> my $foo = Foo[Int];  class Blah does Foo[Int]; class Baz[::T] does Foo[T];

[02:42] <mugwump> what's a role body?

[02:42] <TreyHarris> you can't have parametric classes?

[02:43] <mugwump> TreyHarris: no.

[02:43] <TreyHarris> how does Array work then?

[02:43] <TreyHarris> or Seq?

[02:43] <stevan> body == role { # this is the body }

[02:43] <mugwump> they're roles

[02:43] <stevan> mugwump: where as a normal (non parameterized) role's body would execute at compile time

[02:43] <stevan> a parameterized role's body is executed each time you pass in a new parameter

[02:44] <mugwump> hmm.  that makes sense.

[02:45] <stevan> mugwump: in one of the MM prototypes I had parameterized roles as being like this:

[02:45] <mugwump> I think the parametric :) role is also run a first time at compile time

[02:45] <stevan> class 'Foo' => sub { my $T = shift; ... bunch of meta operations ... };

[02:45] <stevan> s/class/role/

[02:46] <mugwump> right, so $T is the composing class?

[02:46] <stevan> the $T was then in the closure and would generate a new package named 'Foo[T]'

[02:46] <mugwump> oh

[02:46] <mugwump> ok

[02:46] <stevan> no,.. $T was the type parameter

[02:46] <stevan> it was a quick hack,.. but it seemed to work quite well

[02:46] <mugwump> then, Foo[T] is composed?

[02:46] <putter> oh, that's cute.  a new way to segfault ghc.  :/

[02:47] <TreyHarris> is there anything a class can do that a role *can't* do then?

[02:47] <stevan> mugwump: let me find the test in svn, it might make more sense to see it

[02:47] <mugwump> ok.

[02:47] <mugwump> TreyHarris: sure.  be instantiated, for instance

[02:47] <TreyHarris> because it's clear that roles have abilities--being abstract, having parameters--that classes do not

[02:47] <stevan> mugwump: see this test - http://svn.openfoundry.org/pugs/perl5/Perl6-MetaModel/t/32_parameterized_classes.t

[02:48] <lambdabot> http://tinyurl.com/jj6ob

[02:48] <stevan> and this one - http://svn.openfoundry.org/pugs/perl5/Perl6-MetaModel/t/34_nested_parameterized_classes.t

[02:48] <lambdabot> http://tinyurl.com/z8edq

[02:50] <mugwump> interesting.  I note that's using classes, not roles

[02:51] <stevan> yes, it should conceptually work for roles as well

[02:51] <stevan> at least in that metamodel

[02:51] <mugwump> sure

[02:51] <stevan> we are getting close to a solid role implementation in Moose, at which point adding parameters will probably be a next step

[02:52] <mugwump> what's still slightly gelatinous?

[02:52] <stevan> the internals

[02:52] <TreyHarris> this very test is what I based my thinking that classes could be parameterized from.  so that's not true, it's only true in Perl6::MetaModel?

[02:52] <svnbot6> r13797 | putter++ | [t/xx-uncategorized/unicode_aliases.t]

[02:52] <svnbot6> r13797 | putter++ | Created.  "\c[LINE FEED (LF)]" works, but not "\c[LINE FEED]" or "\c[LF]".

[02:52] <svnbot6> r13797 | putter++ | And the third test segfaults my pugs.

[02:52] <stevan> they are pretty bad IMO

[02:53] <stevan> TreyHarris: I am not sure why @larry does not want parameterized classes

[02:53] <stevan> mugwump: I am refactoring the composition part using Set::Object actually

[02:54] <mugwump> A nice module, that one.  jll++

[02:54] <stevan> TreyHarris: Perl6::MetaModel bends a number of "rules" on the meta-level,.. which may not be available on the user level

[02:54] *** mako132_ joined
[02:54] *** Qiang_ joined
[02:55] * stevan has to run, his ice cream is melting :) 

[02:56] <TreyHarris> ok.  the only problem i see, and I'll have to consider it some more, is that there are patterns in which you have the following inheritance line: Abstract -> Concrete -> Abstract -> Concrete.  this seems to be unsupported currently, as a class can do a role, but a role cannot inherit from a class.  i don't think you can even fake it out with delegation, since there's no way to say a role is or does a class....

[02:59] <TreyHarris> you'd have to fake it out with a runtime exception if you instantiate the "abstract class"

[03:00] <putter> ?eval sub ok(*@a){} ok(!defined $/[0], "Correctly didn't capture 2");

[03:00] *** evalbot_r13796 is now known as evalbot_r13797

[03:00] <evalbot_r13797> Error: No compatible subroutine found: "&defined"

[03:00] <putter> bug?

[03:01] <TreyHarris> ?eval sub ok(*@a){} ok(!defined($/[0]), "Correctly didn't capture 2");

[03:01] *** mauke_ joined
[03:01] <evalbot_r13797> undef

[03:01] <TreyHarris> or more properly:

[03:01] <TreyHarris> ?eval sub ok(*@a){} ok(! $/[0].defined, "Correctly didn't capture 2");

[03:01] <evalbot_r13797> undef

[03:02] <putter> my impression is defined() is arity 1, suggesting a misparse.

[03:03] <TreyHarris> putter: See S29.  defined is arity 1-or-2

[03:03] <TreyHarris> but arg 2 is a role

[03:03] <TreyHarris> and "Correctly didn't capture 2" isn't

[03:04] <putter> ahh!  my thanks.  TreyHarris++

[03:05] *** SubStack joined
[03:06] <TreyHarris> putter: another case where TimToady's current pet peeve would help.

[03:06] <TreyHarris> "no subroutine compatible with *what*?"

[03:09] <putter> :)

[03:09] * putter goes to see if exists() has similar issues...

[03:09] <TreyHarris> stevan: the classic example of the exclusionary role has been (to make up syntax) "role Pregnancy requires Mammal excludes Platypus"

[03:11] * TreyHarris will bbiab 

[03:12] <putter> exists (@array : Int *@indices ), weeee...

[03:14] <putter> but not quite that bad.  a unary form is said to exist

[03:16] *** mauke_ is now known as mauke

[03:16] <putter> oh, no.  exists(%h,<key>)

[03:16] <obra> 'evening

[03:17] * putter wonders if there is a recursive exists(), so one can ask something like exists(%h<a><b>[3]<c>)

[03:17] <putter> 'evening obra

[03:28] <putter> exists %h<a><b>   looks so much cleaner than exists(%h<a>,<b>) or %h<a>.exists(<b>).  :/

[03:34] <putter> "  a b\tc" ~~ m/%<chars>:=( \s+ \S+ )/; defined($/<chars>{'  a'})

[03:34] <putter> ?eval "  a b\tc" ~~ m/%<chars>:=( \s+ \S+ )/; defined($/<chars>{'  a'})

[03:34] <evalbot_r13797> Error: Can't modify constant item: VUndef

[03:35] <putter> bug?

[03:39] *** spoop joined
[03:40] <mugwump> ?eval my %h=<1,2,3,4>;say "yes: {%h.exists(1)} no: {%h.exists(2)}"

[03:40] <evalbot_r13797> OUTPUT[yes:  no:  ] Bool::True

[03:40] <mugwump> ?eval my %h=(1,2,3,4);say "yes: {%h.exists(1)} no: {%h.exists(2)}"

[03:40] <evalbot_r13797> OUTPUT[yes: 1 no:  ] Bool::True

[03:41] <putter> bah, my mistake

[03:41] <putter> the bug is the regex is failing.

[03:46] <mugwump> gah!  damned readline bug in pugs

[03:48] *** vel joined
[03:49] <mugwump> putter: is reduce :{$^a&&$^a.exists($^b)&&($^a~~Array??$^a[$^b]!!$^a{$^b})} too much to type?

[03:51] <mugwump> ?eval sub _exists(Item $x, *@x){ reduce :{$^a&&$^a.exists($^b)&&($^a~~Array??$^a[$^b]!!$^a{$^b})} $x, @x }; _exists(%h, <a b 3 c>)

[03:51] <evalbot_r13797> Error: Undeclared variable: "%h"

[03:51] <mugwump> grr

[03:51] <mugwump> ?eval my%h=(a=>{b=>[1,2,3,{c=>4}]}); sub _exists(Item $x, *@x){ reduce :{$^a&&$^a.exists($^b)&&($^a~~Array??$^a[$^b]!!$^a{$^b})} $x, @x }; _exists(%h, <a b 3 c>)

[03:51] <evalbot_r13797> 4

[03:51] <mugwump> ?eval my%h=(a=>{b=>[1,2,3,{c=>4}]}); sub _exists(Item $x, *@x){ reduce :{$^a&&$^a.exists($^b)&&($^a~~Array??$^a[$^b]!!$^a{$^b})} $x, @x }; _exists(%h, <a b 3 d>)

[03:51] <evalbot_r13797> Bool::False

[03:51] <mugwump> ?eval my%h=(a=>{b=>[1,2,3,{c=>4}]}); sub _exists(Item $x, *@x){ reduce :{$^a&&$^a.exists($^b)&&($^a~~Array??$^a[$^b]!!$^a{$^b})} $x, @x }; _exists(%h, <a b>)

[03:51] <evalbot_r13797> [1, 2, 3, {("c" => 4),}]

[03:51] <mugwump> ?eval my%h=(a=>{b=>[1,2,3,{c=>4}]}); sub _exists(Item $x, *@x){ reduce :{$^a&&$^a.exists($^b)&&($^a~~Array??$^a[$^b]!!$^a{$^b})} $x, @x }; _exists(%h, <a d>)

[03:51] <evalbot_r13797> Bool::False

[03:52] <mugwump> actually, that's not right, is it?  the last value could be Bool::False

[04:04] *** SubStack joined
[04:13] <putter> :)

[04:13] <buu> Hrmph. I need the lexical pad from an eval

[04:17] <TreyHarris> mugwump: what's the readline bug?

[04:25] <mugwump> if the line is very long, the display doesn't work

[04:26] <TreyHarris> pugs interactive, or a program using readline?

[04:26] <mugwump> pugs

[04:27] <TreyHarris> the lines above are too long for your pugs?

[04:29] <mugwump> the cursor ends up in the wrong place

[04:29] <mugwump> and after hitting enter, the output starts on the wrong line

[04:30] <TreyHarris> oh... what OS are you running under?

[04:31] <mugwump> Ubuntu Dapper Drake

[04:32] <TreyHarris> on os x, both ppc and intel, it works fine... i wonder what the bug is

[04:35] <mugwump> sure, blame the platform

[04:38] <TreyHarris> *grin* no, i'm just making an empirical observation :)

[04:39] <mugwump> ghci seems to be fine

[04:45] *** snowstalker joined
[04:45] <TimToady> looks like both of the infinite loops are dispatches going to the multi with a slurpy when it was expected to go to the other case.

[04:47] <TimToady> though in the URI case the "other" one is a single scalar parameter, while in quicksort it's the null parameter list that isn't getting called.

[04:52] *** baest joined
[04:55] *** nothingmuch joined
[05:11] <putter> bitesized project idea: something which takes test output and produces a compact (ie, uses ranges) force_todo list.  might even be a one-liner.

[05:28] *** xinming joined
[05:28] <masak> TimToday: do you have some thoughts on audrey's "Motivation for /<alpha>+/ set Array not Match?"? http://nntp.perl.org/group/perl.perl6.language/26284

[05:29] <masak> I like it, and I'd feel sorry if it was really a good idea but got warnocked due to other things taking precedence

[05:35] *** DHGE joined
[05:38] *** MacVince joined
[05:38] <MacVince> ?eval "foo" x 2 x 2

[05:38] <evalbot_r13797> "foofoofoofoo"

[05:39] <MacVince> ?eval "foo" x 2 * 2

[05:39] <evalbot_r13797> 0.0

[05:39] <MacVince> ?eval "foo" x (2 * 2)

[05:39] <evalbot_r13797> "foofoofoofoo"

[05:44] <svnbot6> r13798 | putter++ | t/regex/from_perl6_rules/

[05:44] <svnbot6> r13798 | putter++ | Revised the 15 recently undeleted test files.

[05:44] <svnbot6> r13798 | putter++ | They should now all be spec (hopefully), be proper test files, and pass smoke (untested!).

[05:44] <svnbot6> r13798 | putter++ | Added many eval_*'s, and force_todo's.

[05:44] <svnbot6> r13798 | putter++ | The "disable entire file with a comment" kludges are all gone.

[05:44] <svnbot6> r13798 | putter++ | The tests correctly indicate a great many missing features.

[05:44] <svnbot6> r13798 | putter++ | propcharset.t and properties.t take a while - about 10 minutes each on my machine.

[05:44] <svnbot6> r13798 | putter++ | It would be nice for someone to raise the other test files in the directory to the same standard.  capture.t and subrule.t still have "silently eliminate lots of tests with a comment" kludges.

[05:47] * putter ponders that he almost never runs with -Ofun.  Usually -Oneeds-to-be-done instead.  :/

[05:47] <putter> good night all &

[05:51] *** kanru joined
[05:53] <obra> seen audreyt

[05:53] <jabbot> obra: audreyt was seen 14 hours 31 minutes 10 seconds ago

[06:19] *** Eidolos joined
[06:46] *** iblechbot joined
[06:46] *** dduncan joined
[06:48] *** dduncan left
[07:06] *** _vytautas joined
[07:07] *** vytautas joined
[07:18] *** avarab joined
[07:19] *** kane-xs joined
[07:20] *** avarab is now known as avar

[07:24] *** zakharyas joined
[07:25] *** elmex joined
[07:31] *** jferrero joined
[07:40] *** Psyche^ joined
[07:40] *** avarab joined
[07:55] *** Psyche^ is now known as Patterner

[07:57] *** penk joined
[08:01] *** marmic joined
[08:15] *** drrho joined
[08:19] *** mdiep_ joined
[08:23] <nothingmuch> so what did I miss?

[08:39] *** H2S04 joined
[09:11] *** carrumba joined
[09:11] *** carrumba left
[09:34] *** j0sephi joined
[09:40] <svnbot6> r13799 | audreyt++ | * Implement quantified method calls: $obj.*meth, $obj.+meth, $obj.?meth,

[09:40] <svnbot6> r13799 | audreyt++ |   as well as quantified dynamic method calls: $obj.[+*?]$meth.

[09:40] <svnbot6> r13800 | audreyt++ | * User-defined macros now take effect even in prefix unary

[09:40] <svnbot6> r13800 | audreyt++ |   and optional unary. (Previously only listop worked.)

[09:40] <gaal> nothingmuch: a fun ride to tlv :)

[09:41] <svnbot6> r13801 | audreyt++ | * Move typeOfParam into Pugs.AST.

[09:41] <svnbot6> r13801 | audreyt++ |   This is used in the previous commits to implement class-wide

[09:41] <svnbot6> r13801 | audreyt++ |   attributes with accessors, namely "class C { my $.x }".

[09:44] <svnbot6> r13802 | audreyt++ | * Adjust possiblyApplyMacro such that we can support

[09:44] <svnbot6> r13802 | audreyt++ |   non-prefix macros if needed.  (May affect parsing

[09:44] <svnbot6> r13802 | audreyt++ |   speed significantly; still need to benchmark before

[09:44] <svnbot6> r13802 | audreyt++ |   checking that in.)

[09:44] <svnbot6> r13803 | audreyt++ | * Refactor list comprehension tests from t/junction/ into

[09:44] <svnbot6> r13803 | audreyt++ |   t/syntax/list_comprehension.t.

[09:48] <svnbot6> r13804 | audreyt++ | * Fix magickal line numbers in t/magicals/.

[09:48] *** ruoso joined
[09:51] <svnbot6> r13805 | audreyt++ | * Correct multi invocation data set in t/oo/methods/multi.t.

[09:51] <svnbot6> r13806 | audreyt++ | * t/oo/attributes/array.t: minor indent fix; no functional changes.

[09:55] <svnbot6> r13807 | audreyt++ | * t/oo/methods/chaining.t:

[09:55] <svnbot6> r13807 | audreyt++ |     [===] ($foo, $_foo2, $_foo1)

[09:55] <svnbot6> r13807 | audreyt++ |   should be written as:

[09:55] <svnbot6> r13807 | audreyt++ |     [===]($foo, $_foo2, $_foo1)

[09:58] <svnbot6> r13808 | audreyt++ | * Finish triaging of t/oo/methods/.

[10:07] <svnbot6> r13809 | audreyt++ | * Now that ::?CLASS support is checked in (although it's lexical

[10:07] <svnbot6> r13809 | audreyt++ |   as specced, not dyamic as the test implies), triage the text.

[10:07] <svnbot6> r13810 | audreyt++ | * Fix instance.t: compile-time errors can't be caught by try{},

[10:07] <svnbot6> r13810 | audreyt++ |   so use eval'' instead.  Also unTODO the now-passing parts about

[10:07] <svnbot6> r13810 | audreyt++ |   default attribute values.

[10:08] *** chris2 joined
[10:36] <nothingmuch> gaal: you missed a fun walk =)

[10:52] <audreyt> @tell putter uhm, I don't think I've advocated pugs not testing regex and leave all that to parrot; I was consistently advocating a shared set of spec-based tests.

[10:52] <lambdabot> Consider it noted.

[10:52] <nothingmuch> audreyt: wrt MO - i need to catch up with reality,  $work, etc

[10:53] <nothingmuch> you're free-ish now, right?

[10:53] <audreyt> right

[10:53] <nothingmuch> ok... so i'll try to hunt you down when i am too

[10:54] <audreyt> @tell putter deleting the Perl6::Rules tests was more of a local cleanup on disabled tests; I didn't mean to push it through, but when it's pushed I didn't rollback it in time. I'm glad that you reanimated them.

[10:54] <lambdabot> Consider it noted.

[11:00] <audreyt> @tell putter to qualify "locally": I was release engineering, and "3810 failed" really doesn't help me tracking down the number of failing tests; I don't see a way to easily make the 300 failing subtests pass across two regex engines; however, if you can take care of todo/skip triaging those 3000 subtests such that they reflect the default PCR engine correctly, I'd be very happy; until then I'll still delete them locally but not push back.

[11:00] <lambdabot> Consider it noted.

[11:06] <audreyt> @tell putter also on macbook here, I get random segfaults after ~500 invocations to PCR with embedded perl (it used to exhibit the same thing with PGE), but putting "sleep" between them will "fix" it. I'll look into that bug also. I guess pushing the delete through without reverting it in time is inexcusable; I'm very, very sorry that I've done it, and thanks for noticing.

[11:06] <lambdabot> Consider it noted.

[11:13] <audreyt> @tell putter also, eval was seeing lexical vars just fine; it's eval_ok that couldn't see it. we can make eval_ok a macro, but that makes Test.pm's barrier of adoption by v6.pm and parrot/perl6 much, much higher. if you still think lexical_variable_in_eval.t warrants existence, maybe move it into ext/Test/ instead of on the main perl6 test suite?

[11:13] <lambdabot> Consider it noted.

[11:17] *** buetow joined
[11:29] <svnbot6> r13811 | audreyt++ | * Charnames.hs: Allow charnames.pm aliases such as \N[LF].

[11:32] <svnbot6> r13812 | audreyt++ | * Now that t/xx-uncategorized/unicode_aliases.t is passing, we merge them

[11:32] <svnbot6> r13812 | audreyt++ |   back into char_by_name.t.

[11:35] <svnbot6> r13813 | fglock++ | v6.pm - simplified 'operator' ast

[11:38] <svnbot6> r13814 | audreyt++ | * TODO out object_id.t.

[11:47] <svnbot6> r13815 | audreyt++ | * golfex.t: (=<>).reverse is now the same as =<>.reverse, so we

[11:47] <svnbot6> r13815 | audreyt++ |   must qualify it as list(=<>).reverse to get the list context reverse.

[11:57] *** jsiracusa joined
[11:59] *** fglock joined
[12:03] *** weinig joined
[12:06] <svnbot6> r13816 | audreyt++ | * Add List::reverse to handle the [1,2,3].reverse case.

[12:09] <svnbot6> r13817 | audreyt++ | * Pugs.Eval.Var: Slury scalar in param lists should count as

[12:09] <svnbot6> r13817 | audreyt++ |   one required argument level.

[12:12] *** Limbic_Region joined
[12:12] <svnbot6> r13818 | audreyt++ | * Fix expected outut of head-neck-tail in examples/:

[12:12] <svnbot6> r13818 | audreyt++ |   [1,2,3].say should print "1 2 3\n", not "123\n".

[12:13] <Limbic_Region> salutations all

[12:15] *** frankg joined
[12:18] <svnbot6> r13819 | audreyt++ | * catch_type_cast_mismatch.t: %ordered_hash[0] should be a legit use

[12:18] <svnbot6> r13819 | audreyt++ |   to get the first pair from an ordered hash, I think...

[12:18] <svnbot6> r13820 | audreyt++ | * pair.t: TODOize.

[12:21] *** fglock joined
[12:21] *** jsiracusa left
[12:33] <svnbot6> r13821 | audreyt++ | * Triage of t/data_types/ finished...

[12:38] <audreyt> 44 to go...

[12:38] <fglock> clkao: re PC::Runtime own version of insideout - Class::Insideout methods were in the top-ten profiler times; Match performance is very critical for v6.pm

[12:39] *** nothingmuch joined
[12:44] <Limbic_Region> audreyt - would you mind expounding on the 44 to go?  Do you have a specific set of tests you want to get passing before the next release and all other failing tests can be todo'd?

[12:45] <fglock> does ' $a=(1,2,3) ' makes a capture operation? (captures the list to the first positional)

[12:46] <fglock> since $a is supposed to not be a reference

[12:52] <fglock> ok, I think I figured it out

[12:54] *** mj41_ joined
[12:58] *** count_leto joined
[13:03] <svnbot6> r13822 | fglock++ | pX/v6 - moved tests to t/00-compile-time/

[13:09] <audreyt> Limbic_Region: 44 files, not 44 subtests

[13:09] <audreyt> Limbic_Region: that's all the failing ones modullo t/regex/

[13:10] <audreyt> fglock: no, $a is simply a Seq object autovivifed into an Array

[13:10] <audreyt> the thing doing the vivify is the non-listop infix:<=>

[13:12] <fglock> audreyt: what is the S\d\d for Seq?

[13:13] <audreyt> 06, but 02/03/04 too

[13:13] <audreyt> Seq is what was known as Tuple

[13:14] <audreyt> nothingmuch: I'm afraid I need to sleep -- maybe some 20 hours from now, or the day after

[13:14] <fglock> right - thanks!

[13:15] <nothingmuch> it'll take me as long

[13:15] <nothingmuch> maybe more

[13:18] <Limbic_Region> audreyt - got it

[13:19] * Limbic_Region begins a smoke

[13:20] <audreyt> er, please ^C it :)

[13:20] <Limbic_Region> k

[13:20] <Limbic_Region> more test triaging on its way?

[13:21] <audreyt> no, i accidentally checked in a bogus fix

[13:21] <audreyt> r13823 should be good to smoke now

[13:21] <svnbot6> r13823 | audreyt++ | * oops, the slurpy-param count fix accidentally broke named args.

[13:21] <Limbic_Region> oh, ok

[13:22] <Limbic_Region> fwiw, I think triage is being used incorrectly - it means to sort not to fix ;-)

[13:22] <audreyt> it's to sort into todo and tofix :)

[13:22] <Limbic_Region> true enough

[13:23] <Limbic_Region> beginning smoke

[13:24] <Limbic_Region> hrm, I wonder if bin sorting could benefit from triage sorting

[13:29] *** vel joined
[13:30] *** agentzh joined
[13:30] <agentzh> @messages

[13:30] <lambdabot> audreyt said 3d 4h 36m 17s ago: all of operators/quoting.t now passes except for pair inside <<>> -- I don't feel comfortable with that feature, so will discuss more beore impl

[13:30] <lambdabot> lanny said 2d 23h 12m 17s ago: Smoke Syns are acting up again. :/

[13:33] <svnbot6> r13824 | fglock++ | pX/v6 added HACKING.CompileTime (still empty)

[13:35] <fglock> does this makes sense (new plan for v6.pm emitter): The compile-time system builds a Program object. ' Program.print ' emits the compiled code.

[13:35] <svnbot6> r13825 | fglock++ | pX/v6 - updated HACKING.CompileTime

[13:36] <___particle___> why not Program.emit()?

[13:36] <___particle___> by whatever name, building an object and calling a method on it seems sane

[13:36] <PerlJam> fglock: makes sense to me

[13:37] <___particle___> fglock: do you call methods on the intermediate trees to transform them?

[13:37] <fglock> ___particle___: because ' print Program ' would work too; and ' print Program.perl ' would show it's internal data

[13:38] *** ___particle___ is now known as [particle]

[13:38] <fglock> ___particle___: yes, that's the idea

[13:38] <[particle]> ok, wondering if you could do Program.emit('yaml') or something

[13:38] <[particle]> Program.yaml.print?

[13:39] <fglock> particle: example: http://svn.openfoundry.org/pugs/misc/pX/Common/Pugs-Compiler-Perl6/t/00-compile-time/01-bool.t

[13:39] <lambdabot> http://tinyurl.com/eo3jj

[13:39] <fglock> yes, Program.yaml.print

[13:40] *** avar joined
[13:41] <fglock> at this time, Program is backend-dependent

[13:41] <[particle]> i like this syntax.

[13:41] <[particle]> what is $b->_61__61_() ?

[13:42] <fglock> it is the ascii representation of '=='

[13:42] <[particle]> ah, i see. the comment didn't make sense until now

[13:46] *** weinig is now known as weinig|away

[13:46] *** cjeris joined
[13:47] *** BooK joined
[13:50] <fglock> [particle]: in order to emit Parrot, one would write the Compile-Time classes in pir

[13:51] <[particle]> i'd assume a perl5 module

[13:51] *** BooK joined
[13:51] <[particle]> Pugs::Emitter::Perl6::PIR::*

[13:52] <fglock> or a v6-alpha module :)

[13:55] <[particle]> what's the diff between perl5/PCP6 and misc/pX/PCP6 ?

[13:56] <fglock> pX is experimental - if it works, it can be merged back

[13:56] <[particle]> ah, ok. so perl5 is stable, misc is head

[13:57] <fglock> more like: perl5 is unstable, misc/pX is throw-away :)

[13:58] <fglock> cpan is stable

[13:58] <[particle]> ok, you got me there :)

[14:00] *** buetow joined
[14:00] <[particle]> any docs other than source on what methods a PEP6::PIR would have to implement?

[14:02] <fglock> sorry, not yet - HACKING.CompileTime will be it

[14:05] <fglock> [particle]: it would be nice if you could add some files to misc/pX/PCP6/lib/Pugs/Emitter/PIR - I could help you work it out

[14:05] <[particle]> i've just started that

[14:05] <fglock> woot

[14:06] <[particle]> i figure i'll copy 01-bool.t

[14:06] <[particle]> to pir-01-bool.t

[14:07] <fglock> how about a subdir t/01-pir/01-bool.t - so we could mirror the p5 stuff into it

[14:08] <[particle]> sure, great. i wondered how you wanted to do it. t/pir/01-bool.t

[14:09] <fglock> it's nice that it doesn't depend on the AST format, so we can even use PIL as input (not just v6)

[14:09] <[particle]> hrmm, could we eventually use PASM?

[14:09] <[particle]> err PAST

[14:10] <fglock> sure - you just have to write a tree walker to build the output object

[14:11] <Limbic_Region> audreyt - 96.59% on my Win32

[14:12] <fglock> [particle]: then you can have PAST->perl5 too :)

[14:13] <[particle]> precisely!

[14:14] <fglock> what's a good name for the 'objectification' operation? such as int->Int

[14:15] <rgs> boxing ?

[14:15] <fglock> 'enbox'? :)

[14:15] <rgs> "embox" reads better

[14:15] <fglock> rgs: thanks!

[14:21] <[particle]> why not box/unbox

[14:21] *** lanny joined
[14:22] <fglock> [particle]: sure

[14:22] <lanny> @tell TreyHarris role Pregnancy; class Mammal does Pregnancy; class Platypus is Mammal hides Pregnancy;  ... S12 doesn't make clear if you can hide roles though.

[14:22] <lambdabot> Consider it noted.

[14:23] <svnbot6> r13826 | fglock++ | pX/v6 - updated HACKING.CompileTime

[14:23] <fglock> [particle]: i added some of the method names

[14:24] <[particle]> great!

[14:24] <audreyt> Limbic_Region: uploaded the smoke?

[14:25] <svnbot6> r13827 | audreyt++ | * Further tweaks to the slurpy-param model.  The quicksort

[14:25] <svnbot6> r13827 | audreyt++ |   example was broken all along, and this commit removes the

[14:25] <svnbot6> r13827 | audreyt++ |   previous made-it-work kluge:

[14:25] <svnbot6> r13827 | audreyt++ |     multi quicksort () { () }

[14:25] <svnbot6> r13827 | audreyt++ |     multi quicksort (*$x, *@xs) { ... }

[14:25] <svnbot6> r13827 | audreyt++ |     my @x;

[14:25] <svnbot6> r13827 | audreyt++ |     quicksort(@x); # this should not have succeeded!

[14:25] <svnbot6> r13827 | audreyt++ |   It was binding to variant #1, but there's really nothing

[14:25] <svnbot6> r13827 | audreyt++ |   there that would cause it to bind that way.  I think rewriting

[14:25] <svnbot6> r13827 | audreyt++ |   the example to "quicksort(|@x)" is the sanest approach, but

[14:25] <svnbot6> r13827 | audreyt++ |   that'll have to wait till tomorrow as |@x doesn't work at this

[14:25] <svnbot6> r13827 | audreyt++ |   moment...

[14:25] *** ofer1 joined
[14:27] *** penk joined
[14:27] <lanny> quicksort(|@x) isn't going to be very intuitive syntax for sorting some type of @thing.

[14:28] <audreyt> another fix is

[14:28] <lanny> audreyt++

[14:28] <audreyt> multi quicksort (*[]) {...}

[14:28] <audreyt> but I'm not sure at all that syntax works, or is specced

[14:29] <PerlJam> it's easily inferred from the existing spec :)

[14:29] <PerlJam> Though it could be that *[...] could be considered an error (in judgement at least ;-)

[14:29] <audreyt> perhaps, but there's no mention that slurpy arrays are unpackable

[14:30] <audreyt> would make some sense though.

[14:30] <lanny> The workaround is to check $x in the second multi declaration and return if it's unset but I know that's not the point of multi

[14:30] <audreyt> exactly.

[14:30] <audreyt> |@x will work Correctly

[14:30] <gaal> didn't multis-as-guards need a rethink anyway?

[14:31] <audreyt> but as you said it wasn't very intuitive.

[14:31] <svnbot6> r13828 | audreyt++ | * unTODO the now-passing slurpy_param.t and oo/attributes/class.t.

[14:31] <gaal> (hello!)

[14:31] <audreyt> hi!

[14:31] * PerlJam still isn't used to the unary |

[14:31] <PerlJam> the |-as-junction has become quite hardwired

[14:32] <svnbot6> r13829 | audreyt++ | * next.t: fix plan number.

[14:32] <audreyt> PerlJam: & is a precedent though

[14:32] <audreyt> actually, so is ^

[14:32] <audreyt> all junctiona infix has an absolutely unrelated prefix meaning

[14:32] <PerlJam> yes, I don't know why my brain is having trouble with unary |

[14:33] <fglock> lunch &

[14:33] <svnbot6> r13830 | fglock++ | pX/v6 - updated HACKING.CompileTime

[14:33] <audreyt> gaal: how's life/work/tuits these days?

[14:34] <lanny> slurpy empty seems to handle quicksort() as well.  and if you are used to haskell...  :)

[14:35] <audreyt> yeah. but the current OldParam has no way to express it

[14:35] <audreyt> newland SigParam can express it quite elegantly though

[14:36] <gaal> audreyt: new project starting at $job tomorrow, so I don't know exactly

[14:37] <lanny> Anyone have any idea what "applying a Signature to a value would look like and extracting the positional parameters"?  Needed for sort and the signature will be held in a Signature variable.

[14:37] <gaal> audreyt: you're itching for a release I take it...

[14:38] <audreyt> parsefail

[14:39] <PerlJam> lanny: I don't understand "applying a signature to a value"

[14:40] <lanny> PerlJam: Neither do I.  :)  It's in the spec for sort() in S29.  Signature got added to SortCriterion so you can do stuff like: sort :(Num, Str), @values;  and sort will write the KeyExtractor and Comparator for you.

[14:40] <audreyt> gaal: that is so :)

[14:41] <audreyt> see y'all tomorrow :) *waves and goes sleep*

[14:41] <gaal> audreyt: night! next two days are probably not free but hopegully the weekend (unless hiking w/nothingmuch)

[14:41] <PerlJam> lanny: then it sounds like it'll treat each value as a Capture in a way

[14:42] <lanny> Or worse sort :(Num but canonicalized(&abs), Str), @values;

[14:42] <lanny> Agreed.

[14:44] <lanny> I woudl accuse TimToady of having a fevered imagination on this kind of thing but everyone already knows that's true.

[14:47] <Limbic_Region> yes audreyt - smoke uploaded

[14:49] <Limbic_Region> about to run another

[14:56] *** etzel joined
[15:06] *** hexmode joined
[15:19] <lanny> Is .yaml what the AST looks like of a given expression?

[15:19] *** jferrero joined
[15:19] <lanny> er... given statement.

[15:25] <kolibrie> lanny: .yaml and .perl are representations of a data structure in those serialization formats

[15:26] <lanny> Thanks, Kolibrie.  Finally realized what I wanted was interactive pugs to look at the syntax tree

[15:30] <gaal> lanny: another way is Pugs::Internals::emit_yaml, but that's very verbose

[15:31] <clkao> fglock: oh ok. why is it using inside out at all? ;)

[15:31] *** buetow joined
[15:36] <audreyt> clkao: when you overload ${} @{} %{}, what else can you do?

[15:37] <audreyt> I guess you can bless CVs. that feels very slow though

[15:37] *** chris2 joined
[15:37] <lanny> I wonder if audreyt will be the first recognized medical case of "Sleep Developing"

[15:41] <svnbot6> r13831 | lanny++ | * split.t - fixed bug in test wrapper that was causing failing tests

[15:43] <clkao> audreyt: heh

[15:43] <clkao> fglock: so i m tking the bits to mke data::capture. but i will be using refs for the values. do you think it makes sense for PC::Match?

[15:44] <clkao> not having a full copy of matched things might be a good idea - but the thing in ::match are not ref'ing other things i guess...

[15:50] <fglock> clkao: hi

[15:50] <svnbot6> r13832 | lanny++ | * readline_chomped.t -- todo on 'is chomped' working

[15:50] <clkao> fglock: hi

[15:51] <fglock> insideout is being used so that we can overload all of $ % @

[15:51] <clkao> *nod*

[15:52] <fglock> the reason to use ref-ref-thing is so that we can use ref-variables as cheap accessors

[15:52] <clkao> uhm ? are you using ref-ref?

[15:53] <fglock> like in:   $match = { thing => \$thing }; $$thing = 42;  # sets $match->thing

[15:54] <fglock> it's a bit cheaper than method calls

[15:54] <fglock> actually:   $match = { thing => \$thing }; $thing = 42;  # sets $match->thing

[15:55] <clkao> oh y, that's good and consistent with what i am doing anyway

[15:55] <clkao> do you do tht for positional as well ?

[15:55] <clkao> and i noticed your keys also have the array index

[15:56] <fglock> yes:   $match = { array => \@array, hash \%hash };

[15:56] <fglock> yes, that's specced

[15:57] <clkao> no, i mean the values of the array and hash

[15:57] <clkao> { array => [\1, \'foo'], hash => { key => \'value' } }

[15:57] <clkao> need that for data::bind

[15:58] <fglock> sorry? I mean as in S05: "The numbered captures may be treated as named, so $<0 1 2> is equivalent to $/[0,1,2]"

[15:58] <fglock> Captures don't need that

[15:59] <clkao> oh ok.

[15:59] <clkao> only in match.

[16:03] *** Psyche^ joined
[16:05] <fglock> though in some places you turn positional arguments into named arguments, and named into positionals

[16:07] <clkao> ok. but what i cared more is the value of the named. because i need to have them as ref in capture

[16:11] *** Psyche^ is now known as Patterner

[16:18] <clkao> fglock: so what happens if you feed a match object as a capture to a subroutine? do you alsao have the index keys?

[16:22] <fglock> clkao: you mean when used as a hash? yes, it was implemented like this

[16:23] <lanny> ?eval my @ps = 1=>'a',2=>'b'; @ps.fmt("%d->%s", "\n")

[16:23] *** evalbot_r13797 is now known as evalbot_r13832

[16:23] <evalbot_r13832> "1->a\n2->b"

[16:24] *** iblechbot joined
[16:24] <clkao> fglock: uhm, do you mean about the value ref?

[16:25] <fglock>  $($match) is whatever you set it to - it doesn't depend on @($match) or %($match)

[16:25] <lanny> Why does that work?  fmt(List $obj, Str $fmt, Str $comma) { join($comma, map -> $v { sprintf($v, $fmt); }, @$obj; }

[16:26] <lanny> And sprintf doesn't understand :(Pair, Str)

[16:26] *** putter joined
[16:27] <lanny> oops.  Reverse the parameters on sprintf() above.

[16:28] <fglock> lanny: maybe it is handling the pairs in Array context?

[16:29] <lanny> They seem to be Pair objects as far as I can trace them.

[16:29] *** lollan joined
[16:29] <fglock> ?eval @( 1 => 'a' )

[16:29] <evalbot_r13832> (1 => "a")

[16:29] <fglock> ?eval @( 1 => 'a' ,)

[16:29] <evalbot_r13832> [(1 => "a"),]

[16:30] <lanny> What it breaks is this:

[16:30] <lanny> ?eval (1=>'a').fmt("%d->%s","\n")

[16:30] <evalbot_r13832> Error: Insufficient arguments to sprintf

[16:31] <fglock> ?eval (1=>'a').kv.fmt("%d->%s","\n")

[16:31] <evalbot_r13832> Error: Insufficient arguments to sprintf

[16:31] <fglock> ?eval (1=>'a').kv

[16:31] <evalbot_r13832> (1, "a")

[16:32] <lanny> Yeah.  Fix is something like map -> $v { $v~~Pair ?? sprintf($fmt, $v.kv) !! sprintf($fmt, $v)

[16:32] <putter> audreyt: re lexical_variable_in_eval.t, I'll add a warning to Test's pod.  and look at the tests. :/

[16:32] <putter> problem is failing regex tests produce matches on which hash access is deadly.

[16:34] <putter> re eval_ok, I'm certainly never going to advocate Test.pm use even more language features ;)

[16:34] <putter> though basic text macros aren't actually _that_ daunting.  compared to say junctions.

[16:36] <putter> bah, wrong channel again ;)

[16:36] *** araujo joined
[16:36] <putter> fglock: does v6 actually use the "real" Test.pm?

[16:36] <putter> audreyt: if so, it may be the first non-hs impl which did.  pilrun pil2js et al used tailored simplified ones.

[16:37] <putter> though my fuzzy recollection is Test dropped its junctions at parrot's request, so maybe they did too.

[16:37] <fglock> putter: yes - it uses a copy that is in the /t directory - you can use perl -It -Ilib ... in order to include it

[16:39] <fglock> re hash access is deadly - this is fixable

[16:39] *** rindolf joined
[16:39] <rindolf> Hi all.

[16:39] *** avar joined
[16:39] <rindolf> Hi avar

[16:40] <putter> modified copy, or identical to ext/Test/lib/Test.pm?  I've wondered off and on if we should create a simplified Test for bootstrappers.  but each time it is easier to just do another custom one, and "well, no one will be doing another bootstrap any time soon". ;)

[16:40] <rindolf> ingy: here?

[16:40] *** avar joined
[16:40] <fglock> putter: it is a plain copy

[16:41] <putter> re fixable, yes?!? :)  problem is $m = ... ~~ /.../;  $m<foo><bar> goes boom trying to make the $m<foo> exist.

[16:41] <rindolf> Hmmm... avar is bouncing.

[16:41] <rindolf> Hi fglock

[16:42] <putter> re plain copy, neat :).  another infinite todo list item bites the dust.  yay

[16:42] <putter> err, re goes boom, "when the match fails".

[16:42] <fglock> rindolf: hi

[16:43] <svnbot6> r13833 | fglock++ | pX/v6 - HACKING.CompileTime - added more Classes, Methods; special Classes

[16:43] <fglock> putter: would you add a test to PCR?

[16:45] <clkao> fglock: no, i meant values of the array and the hash

[16:45] <putter> @tell audreyt "shared set of spec-based tests"++.  second regex test deletion I've noticed lately, so was wondering if there was a pattern.  none- great.

[16:45] <lanny> aha

[16:45] <fglock> putter: re Test.pm - we should start using Versioning (as in S11)

[16:45] <lanny> ?eval my @p = (1=>'a'); @p

[16:45] <evalbot_r13832> [(1 => "a"),]

[16:46] <lanny> ?eval my @p = (1=>'a'); map -> $v { $v.WHAT }, @p

[16:46] *** evalbot_r13832 is now known as evalbot_r13833

[16:46] <evalbot_r13833> (::Int, ::Str)

[16:46] <lambdabot> Consider it noted.

[16:46] <lanny> A singe Pair gets stripped down to it's .key and .value for some reason.

[16:46] *** avar joined
[16:47] <lanny> ?eval @p = 1=>'a',2=>'b'; map -> $v { $v.WHAT }, @p

[16:47] <evalbot_r13833> Error: Undeclared variable: "@p"

[16:47] <lanny> ?eval my @p = 1=>'a',2=>'b'; map -> $v { $v.WHAT }, @p

[16:47] <evalbot_r13833> (::Pair, ::Pair)

[16:48] <lanny> Time to make a test.

[16:48] <fglock> clkao: it depends on which context the Match will find inside the subroutine - if it gets used as a Hash, it will show positionals as keyed by number

[16:48] <clkao> no, i don't mean the keys

[16:48] <clkao> the values.

[16:48] <clkao> in capture they should be references

[16:49] <ingy> hi clkao

[16:49] <lambdabot> ingy: You have 1 new message. '/msg lambdabot @messages' to read it.

[16:50] <putter> audreyt: (re "advocated"... ah well, searching the irc log without better tools is hopeless.  it was somehing vaguely like "we're debugging pge second hand; create unified tests?; let's just give them all to parrot!".  I countered with "what about my regex stuff in prelude and alternate regex engines?".)

[16:51] <fglock> clkao: would you give an example?

[16:51] <putter> fglock: re versioning, intriguing idea

[16:53] <putter> fglock: re adding tests to PCR, I think it's more of a pugs-side issue.  and quite possibly the correct behavior, regardless of how inconvenient for regex tests ;)

[16:53] <putter> ?eval my $m = "" ~~ /a/; defined($m<foo><b>)

[16:53] <evalbot_r13833> *** Cannot parse regex: a *** Error: Error: 'require' trapped by operation mask at /home/audreyt/pugs/perl5/Pugs-Compiler-Rule/lib/Pugs/Runtime/Match/HsBridge.pm line 23.  Error: Can't modify constant item: VUndef

[16:53] <fglock> ?eval my @p = (1=>'a',); map -> $v { $v.WHAT }, @p

[16:53] <evalbot_r13833> (::Int, ::Str)

[16:54] <putter> ok, so $m has a match failure other than the one intended, but it's the Error: Can't modify constant item: VUndef which bites.

[16:56] <putter> @tell audreyt re lots of failing&toxic tests unhelpful... yeah, no-one has yet done the next-gen test infrastructure wanted long ago.  ...

[16:56] <lambdabot> Consider it noted.

[16:57] <putter> @tell audreyt ...our test failure firewall is the test file.  we directly modify test cases to protect the test file, and encode expectations.  alternate backends, or here component of backend, have different fragilities and expectations.  they basically have to live with doing their own fragility workarounds, working around pugs' to see the tests, and ignoring expectations.

[16:57] <lambdabot> Consider it noted.

[16:57] <putter> the wild and wacky world of alternate backend testing

[16:57] <putter> maybe when we start doing generative testing we can do a "firewall which is not a file" infrastructure.

[16:58] <putter> anyone looking for a project? :)

[17:03] <lanny> fglock: the loss of pairness probably tied up with pairs as named parameters (somehow)

[17:05] <rindolf> Does anyone know when the slides for YAPC::Europe will be available?

[17:05] <rindolf> The Birmingham YAPC::EU that is.

[17:06] <clkao> fglock: 11:57 < clkao> { array => [\1, \'foo'], hash => { key => \'value' } }

[17:09] <putter> re testing problem... silly me... "If you need context, use a normal C<eval> inside a C<ok> or C<is> or C<dies_ok>."

[17:11] *** justatheory joined
[17:11] <svnbot6> r13834 | fglock++ | pX/v6 - added Native Class (int/num/str/bool)

[17:12] <fglock> clkao: yes, in that case, the array values would appear twice, unless we add a Match.capture coercing method that returned a proper formatted Capture

[17:12] <clkao> fglock: i am not talking about array in hash anymore... i am asking about using refs in the array and hash values, as i need to do so in capture

[17:16] *** count_leto joined
[17:16] <fglock> clkao: what's the question again? (sorry)

[17:16] *** hexmode joined
[17:17] <clkao> fglock: are you using refs or just values

[17:17] <clkao> in ::Match

[17:18] <fglock> clkao: one sec - checking

[17:18] *** avarab joined
[17:18] <svnbot6> r13835 | putter++ | [ext/Test/lib/Test.pm]

[17:18] <svnbot6> r13835 | putter++ | Noted in the pod that eval_{ok,is,etc} do not eval() in the context of the caller.  When context is needed, ok(eval()) should be used.

[17:19] <putter> audreyt: re segfault, segfaulting after 3 is easier to debug then after 500.  But I'm running an old 6.4.1, on 64bit.  so the causes may be different.  how much of a priority do you think this?

[17:21] <fglock> clkao: Match array/hashes store either Match (which is blessed ref) or ARRAY (which is ref)

[17:22] <fglock> clkao: never just values

[17:24] <clkao> oh cool.

[17:24] <svnbot6> r13836 | putter++ | [xx-uncategorized/lexical_variable_in_eval.t]

[17:24] <svnbot6> r13836 | putter++ | Deleted.  Test.pm's pod now documents that eval_ok() does not eval() in the context of the caller.

[17:24] <clkao> anyway, i will make my data::capture and we can see if that can be superclass of match

[17:26] <fglock> clkao: it can be cheated to be a superclass, even if the code is not reused

[17:27] <svnbot6> r13837 | lanny++ | [t/xx-uncategorized/pair_in_array.t]

[17:27] <svnbot6> r13837 | lanny++ | * demonstrate bug where (::Pair) becomes (.key, .value)

[17:29] *** kanru joined
[17:30] <rindolf> Hi clkao

[17:33] <svnbot6> r13838 | lanny++ | * fmt.t - todo :depends<list of single pair> on failing test

[17:38] *** Ikarus joined
[17:38] *** vel joined
[17:48] <svnbot6> r13839 | putter++ | [t/regex/from_perl6_rules/]

[17:48] <svnbot6> r13839 | putter++ | Instances of eval_ok('something which depends on caller context',...) changed to ok(eval('...'),...).  Also eval_is().

[17:48] <putter> yipes, there are 200+ plus tests which _may_ be hitting the same eval_ok isn't eval problem...

[17:54] <gaal> putter: iirc using context vars can help with that

[18:00] <fglock> yay! # pX/v6 emitter does ' 1+1 '

[18:00] <svnbot6> r13840 | fglock++ | pX/v6 - passes minimal emitter tests

[18:04] <putter> ok, topic for discussion:

[18:05] <putter> almost all the uses of eval_ok and eval_is in t/ are incorrect.  that is, the vast majority depend upon seeing non-global lexicals, or being in the same package.

[18:07] <putter> oops, that's not quite true,

[18:09] <putter> 1/3 of eval_ uses don't have a [$@%] in the line.  thus likely don't depend on lexicals, but may still depend on package - haven't checked.

[18:10] <putter> of the remaining 2/3, about 4/5 are broken.

[18:11] <fglock> very simple test for the new emitter: http://svn.openfoundry.org/pugs/misc/pX/Common/Pugs-Compiler-Perl6/t/00-compile-time/02-int.t

[18:11] <lambdabot> http://tinyurl.com/h26g6

[18:11] <fglock> coffee &

[18:13] <putter> the ok(eval()) is(eval()) idiom outnumbers the use of eval_ok/eval_is.

[18:17] <putter> strawman proposal: remove eval_ok/eval_is/eval_dies_ok from Test.pm.  it is not what people think it is.  it is pervasively being used incorrectly.  the alternatives are already in widespread use.

[18:17] <putter> comments?  thoughts?

[18:21] <gaal> ?eval my $x is context; eval '$x++'; $x

[18:21] *** evalbot_r13833 is now known as evalbot_r13840

[18:21] <evalbot_r13840> \1

[18:22] <gaal> ?eval my $x; eval '$x++'; $x

[18:22] <evalbot_r13840> \1

[18:22] <gaal> heh

[18:23] <gaal> hm, putter, remoose me, the problem is that the eval takes place deep in Test, right?

[18:23] <putter> yes

[18:23] <putter> lol (re remoose)

[18:23] <TimToady> ?eval my $x is context; eval '$+x++'; $x

[18:23] <evalbot_r13840> \1

[18:24] <gaal> ?eval my $x is context; Moo::evinc('$x++'); say $x; class Moo { sub evinc ($s) { eval $s } }

[18:24] <evalbot_r13840> OUTPUT[1 ] undef

[18:24] <TimToady> still in lexical scope of "my"

[18:24] <gaal> ?eval { my $x is context; Moo::evinc('$x++'); say $x;} class Moo { sub evinc ($s) { eval $s } }

[18:25] <evalbot_r13840> Error:  Unexpected "class" expecting comment, operator, statement modifier, ";" or end of input

[18:25] <gaal> ?eval { my $x is context; Moo::evinc('$x++'); say $x;}; class Moo { sub evinc ($s) { eval $s } }

[18:25] <evalbot_r13840> OUTPUT[ ] undef

[18:25] <putter> a couple of eval_* uses in ext/, 300-ish in t/, 200-ish of which are obviously broken.  roughly.  400-ish instances of {ok,is}(eval()).

[18:25] <gaal> ?eval { my $x is context; Moo::evinc('$+x++'); say $x;}; class Moo { sub evinc ($s) { eval $s } }

[18:25] <evalbot_r13840> OUTPUT[1 ] undef

[18:25] <TimToady> yes

[18:25] <gaal> whew.

[18:25] <gaal> putter: does this look like an approach for a fix?

[18:26] <gaal> I mean, there's obviously many places to apply it - but is this an acceptable solution IYO?

[18:26] <TimToady> removing eval_ok seems simpler

[18:26] <gaal> or making it a macro (is there a way we can wing that?)

[18:26] <TimToady> it's not like ok eval is all that much longer

[18:27] <TimToady> *cough* source filters *cough*

[18:27] <gaal> a var has to be declared contextual, right?

[18:28] <putter> "source filters"++.  but here, eval_ok() is so little improvement over ok(eval()), that it doesnt seem worth any pain.

[18:29] <putter> gaal: I'm not sure I understand your idea.  Use "is context" to pass lexicals, and... how does the "eval() happens in the wrong package" get handled?

[18:30] <putter> and is the idea dealing with the "people get it wrong", or just with "once they realize they have gotten it wrong, they can work around it by doing X".

[18:30] <putter> ?

[18:31] <gaal> the idea is to make it convenient to write tests :)

[18:32] <gaal> if ok eval is good enough, great. I can't believe I started a sentence with four consecutive Perl 6 keywords.

[18:32] *** Yappoo joined
[18:32] <putter> lol

[18:32] <gaal> (I didn't really though)

[18:33] * putter foresees a vast vista of executable poetry in p6...

[18:33] <gaal> perl -pi -e 's/eval_ok/eval ok/g' will probably break things though

[18:33] <gaal> phone, bbl

[18:34] <putter> re -pi -e, yeah, a bit more work ;)

[18:34] *** larsen joined
[18:35] <putter> hmm... instead of the usual arity parser rules, when you use Haiku;...

[18:36] *** count_leto left
[18:36] <fglock> re backends, macros are actually easier to implement than most other tricks

[18:37] <putter> that's my impression as well.

[18:37] <putter> err, wait.

[18:37] <fglock> putter: would you review the pX/v6 emitter idea?

[18:37] <putter> phone bbl

[18:38] *** vel joined
[18:40] <putter> back

[18:42] <putter> re "easier", um, what do backends have to do for macros?  frontends do most all the work, no?

[18:43] <fglock> right - it is easier because it is not backend-specific

[18:45] <putter> so while my only attempt at a frontend briefly had string macros, the whole parser was a kludge, so I can only hypothesize how difficult they would be to integrate with something more sane.

[18:45] <putter> re right...

[18:45] <putter> but v6, doing it's own parsing, would have to deal.

[18:46] <putter> or am I missing something?

[18:47] *** weinig joined
[18:47] <fglock> putter: v6 uses something very close to macros internally: http://svn.openfoundry.org/pugs/perl5/Pugs-Compiler-Perl6/lib/Pugs/Grammar/StatementControl.pm

[18:47] <lambdabot> http://tinyurl.com/kvn9s

[18:48] *** weinig is now known as weinig|away

[18:49] <putter> re emitter idea, 02-int.t ?

[18:49] <fglock> yes, that's an example

[18:53] <putter> re "very close to macros", indeed.  so the question is how much effort it would be to get to the point that Test could safely use macros to implement eval_is.  that I am unsure of.  while thinking about Parser.hs and other attempts, I don't see a problem, but I've also been burned enough around here to have a "beware gotchas contributing orders-of-magnitude of pain" hesitancy.

[18:56] <putter> re 02-int.t, hmm... so emit() is figuring out what kind of node it is holding by checking for the existance of some fields?

[18:56] <fglock> the most likely problem is that we don't have a common AST that could be use inside macros

[18:56] <putter> so not a problem for string macros. :) :)  and that's all which is needed.

[18:56] <putter> s/so/soooo/

[18:57] <fglock> putter: emit() is creating compile-time objects (this ast format is just an example)

[18:58] <fglock> parsing into objects would be possible too, but that's not the point here

[18:59] <putter> the usual compiler ast story is you grovel over the ast accumulating non-local information, mutate the ast, and then emit.  the usual lossage is that your mutation was lossy, and you find pass 13 needs information discarded in pass 3.  "non-lossy ast modification"++.

[19:00] <putter> could you summarize "the point here"?

[19:01] <putter> i guess i am unsure what aspects to comment on

[19:01] <fglock> you have a syntax tree to walk - you walk the tree creating objects that represent the current program; then you stringify the object and you get source code

[19:02] <putter> my first reaction was "why aren't the ast nodes typed, and emit a multimethod (or at least doing type based dispatch)".  but I don't know if that's the kind of thing you are looking for...

[19:03] <fglock> the ast nodes belong to classes that represent the Perl6 types - int, str, Array, ...

[19:03] *** ashleyb joined
[19:03] <ajs_work> ?eval $_=1; say "{$_} {$^a}" for 1..4;

[19:03] <evalbot_r13840> OUTPUT[1 2 3 4 ] undef

[19:04] <ajs_work> Is that intentional, or should the $^a prevent the $_ from sucking/creating a positional parameter?

[19:04] <fglock> ajs_work: you mean $_[0] ?

[19:05] <ajs_work> fglock: I don't think so, no.

[19:05] <fglock> ?eval my $out; $_=1; $out .= "{$_} {$^a}" for 1..4; $out

[19:05] <evalbot_r13840> Error:  Unexpected "\"{$" expecting ".", operator name, qualified identifier, variable name, "...", "++", "--", array subscript, hash subscript or code subscript

[19:06] <fglock> ?eval my $out; $_=1; $out ~= "{$_} {$^a}" for 1..4; $out

[19:06] <evalbot_r13840> \"1 23 4"

[19:06] <ajs_work> You see, it's treating $_ and $^a as if they were $^a $^b

[19:06] <ajs_work> which obscures the old $_

[19:07] <ajs_work> and also implies :by<2> which isn't really what I think I wanted there

[19:08] <fglock> putter: the way it works is not too different from what you said

[19:09] <fglock> ?eval my $out; $_=1; $out ~= " _ {$_} ^ {$^a}" for 1..4; $out

[19:09] <evalbot_r13840> \" _ 1 \^ 2 _ 3 \^ 4"

[19:12] <ajs_work> I was also wondering if AST nodes could be typed for multi dispatch. I really think that would be handy for differentiating certain types of circumstances in user macros.

[19:12] <ajs_work> I gave an example in the macro API doc

[19:13] <ajs_work> Of course, it's compile-time multi-dispatch which has some interesting quirks, but it's not unreasonable, I think

[19:13] <fglock> ajs_work: link?

[19:13] <ajs_work> docs/Perl6/API/macros.pod

[19:14] <ajs_work> search for "multi"

[19:15] <ajs_work> It's not a finished document by any stretch, but was just an attempt to see what docs/notes/p6ast_draft meant for the user API

[19:15] *** bernhard joined
[19:17] <putter> end of "lunch" for me.  need to plan a jobsearch.  really ;)

[19:17] <putter> perhaps bash on eval_ok->ok(eval()) tomorrow, if no-one beats me to it.

[19:17] <putter> feedback on the depreciating/disappearing eval_x continues to be welcome.

[19:17] <putter> fglock: do you have a english rather than code sketch of your plan for feedback?

[19:17] <putter> especially when beginning a new subproject, writing one can be useful.  and helps others think about your core ideas without the challenge/flakeyness of inferring them from code...

[19:17] <fglock> ajs_work: yes, I think it works

[19:18] <fglock> putter: ' HACKING.CompileTime ' in the module root

[19:19] <putter> @tell audreyt Thoughts on the proposal to eliminate eval_ok eval_is eval_dies_ok and convert t/ to use ok(eval()) etc?

[19:19] <lambdabot> Consider it noted.

[19:20] <putter> fglock: awesome.  that's the other thing I'll try to do tomorrow. :)

[19:21] <fglock> putter: in order to add an eval_ok macro to v6.pm, you can do %Pugs::Grammar::Term<eval_ok> = '...rule...'  # low-level access to the parser tables :)

[19:22] <putter> lol

[19:22] *** smash joined
[19:22] <svnbot6> r13841 | putter++ | [t/xx-uncategorized/namespaces.t]

[19:22] <svnbot6> r13841 | putter++ | [t/blocks/pointy.t]

[19:22] <svnbot6> r13841 | putter++ | Incorrect eval_ok()'s converted to ok(eval())'s.  2 files down, lots to go.  Volunteers?

[19:23] <putter> fglock: "I promise to use this power only for good..." :)

[19:23] <putter> those were the two files I converted before noticing the scale of the problem, and bumping it to discussion.

[19:25] <putter> changing the rest really isnt a big deal.  the right pugs/anarchistic/just-go-for-it model would likely be to right now quickly convert the rest of the t/ files.  but I'm out of time for today.  feel free.

[19:26] <putter> have fun &

[19:31] *** justatheory joined
[19:32] <mugwump> fglock: isn't that written as macro eval_ok is parsed /...rule.../ ?

[19:46] <fglock> mugwump: yes - the 'Term' thing is just an example of how it could be implemented

[19:46] *** BooK_ joined
[19:51] *** hexmode joined
[19:52] <holoway>  /window 12

[19:52] <holoway> gack

[19:52] <holoway> silly spaces

[20:01] *** fglock joined
[20:03] <fglock> putter: re "the point here" - the "$ast" and "emit" in 02-int.t are just an example, they are not part of the project.

[20:03] <fglock> putter: the project is about emitting code from an expression like ' 1.int.infix:<+>( 1.int ) '

[20:04] <fglock> s/expression/perl6 program/

[20:11] *** hexmode joined
[20:13] *** hexmode left
[20:18] *** weinig|away is now known as weinig

[20:19] *** mdiep joined
[20:31] *** jferrero joined
[20:35] <fglock> ?eval my $a; my $b=1; 'scalar ' ~ $a.WHAT ~ ' int ' ~ $b.WHAT

[20:35] *** evalbot_r13840 is now known as evalbot_r13841

[20:35] <evalbot_r13841> "scalar Scalar int Int"

[20:38] *** larsen joined
[21:02] *** justatheory joined
[21:03] *** theorbtwo joined
[21:06] <svnbot6> r13842 | fglock++ | pX/v6 - added TODO.CompileTime; several fixes

[21:17] *** fglock left
[21:17] *** avarab is now known as avar

[21:26] *** Limbic_Region joined
[21:45] *** weinig joined
[22:06] *** weinig is now known as weinig|bbl

[22:08] *** cjeris left
[22:11] *** mauke joined
[22:24] *** spoop joined
[22:26] *** pfenwick joined
[22:27] *** mako132_ joined
[22:31] *** spoop joined
[22:33] *** weinig joined
[22:51] *** polettix joined
[22:57] *** frankg joined
[23:14] *** Aankhen`` joined
[23:17] *** avarab joined
[23:24] *** mako132_ joined
[23:36] *** Aankhen`` joined
[23:49] <svnbot6> r13843 | lanny++ | * t/unspecced/sort.t - remove eval_ok

