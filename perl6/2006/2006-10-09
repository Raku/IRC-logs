[00:17] *** mjk joined
[00:18] <aufrank> TimToady or audreyt: any thoughts on an adverbial form for C< a => \($x, $y) > ?

[00:20] <ajs_home> aufrank: :a($x,$y) ?

[00:20] <aufrank> I'd like that if it were the case

[00:20] *** mako132 joined
[00:20] <aufrank> but I think right now :a($x) is a => $x

[00:21] <aufrank> and this change would make it a => \($x)

[00:21] <aufrank> maybe that's OK

[00:21] <ajs_home> ?eval my $x=1;my $y=2; :a($x,$y);

[00:21] *** evalbot_r14076 is now known as evalbot_r14098

[00:21] <evalbot_r14098> ("a" => (\1, \2))

[00:22] <ajs_home> Ah, I missed your \

[00:22] <ajs_home> ?eval my $x=1;my $y=2; :a(\($x,$y))

[00:22] <aufrank> yeah, I want a literal-capture adverbial pair

[00:22] <evalbot_r14098> pugs: don't know how to toVV': VRef <Scalar:0xb6be0a8c>

[00:23] <ajs_home> freaky. That worked in my (few days old) pugs

[00:23] <ajs_home> aufrank: None the less, that should be the syntax

[00:25] <aufrank> ajs_home: yeah, someone showed that earlier.  I agree that's the way to do it given the current adverbial syntax

[00:25] <aufrank> I just wondered if there was room to add another entry to the list of adverbial forms

[00:29] <ajs_home> I can't see that it would save much if we did. (\(...)) would become something with 2-3 fewer characters... for something that's not likely to be used very often, I don't see the advantage.

[00:29] <ajs_home> Typically captures that users interact with will be in variables (like match results) anyway.

[00:31] <ajs_home> OF outage kind of sucks... oh well

[00:33] <ajs_home> v6 seems to choke on captures right now

[00:43] *** Odin- joined
[00:46] *** mako132 joined
[00:52] <wolverian> hm, the docs on spec.pugscode.org don't resize liquidly to under some specified width, which is a tad annoying if you want to read them with less wide lines

[00:52] * wolverian checks the css

[00:53] <wolverian> the width is specified in pixels, which is a big no-no.

[00:53] <wolverian> ...as is the font size

[01:01] *** lollan joined
[01:14] *** nperez joined
[01:46] *** jayrod joined
[01:59] *** frederico joined
[02:01] <ingy> stevan: ping

[02:08] <wolverian> eh.. right, openfoundry is down

[02:24] <ingy> seen audreyt

[02:24] <jabbot> ingy: audreyt was seen 8 hours 33 minutes 8 seconds ago

[02:24] <ingy> how palindramatic of her

[02:40] <aufrank> are you calling her a palin-drama queen?  ;)

[03:00] <audreyt> @tell cmarcelo wow, great work! I've applied the "use monad, not maybe" pattern to it so we can drop-in C3 into Pugs (or any other monad) right away. see http://perlcabal.org/~audreyt/tmp/C3.hs

[03:00] <lambdabot> Consider it noted.

[03:01] *** weinig|bb is now known as weinig|zZz

[03:45] *** Qiang_ joined
[04:01] *** cmarcelo joined
[04:08] <cmarcelo> audreyt++ # better style with pattern guards && "monad, not maybe" pattern tip :)

[04:21] *** jayrod left
[04:23] *** Qiang joined
[04:45] <TimToady> ~.~.

[04:45] <lambdabot> TimToady: You have 1 new message. '/msg lambdabot @messages' to read it.

[04:46] *** drbean joined
[05:04] <gaal> fancy typeset Haskell in papers always bunches up operators, like >> turning into ». But it should also unify guards to one vertical line whenever possible.

[05:08] *** mac93 joined
[05:11] <audreyt> gaal: still $job-bound?

[05:11] <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.

[05:11] <audreyt> @messages

[05:11] <lambdabot> cmarcelo said 7h 2m 11s ago: hi! still not MO for Hs yet but did a little C3 MRO implementation because I didn't found any on the web. comments/ideas/suggestions welcome :) http://feather.perl6.nl/~

[05:11] <lambdabot> cmarcelo/C3.hs

[05:15] *** BooK_ joined
[05:15] <gaal> audreyt: for the day, yes

[05:16] <audreyt> 'k

[05:16] <gaal> am having morning drink + email check + backlog

[05:17] <gaal> no buyers for those shower pics eh. need to coach nothingmuch on marketing...

[05:19] <gaal> so, what's the svk incantation to switch to a mirror repo? I'm using a local mirror.

[05:19] <gaal> won't svk mi --relocate give me a "different uuid" error?

[05:20] *** agentzh joined
[05:21] <clkao> it works if the one you are switching to one is a mirror of the original one

[05:24] <gaal> which neither of the /topical ones are :-(

[05:26] <audreyt> right.

[05:26] <audreyt> we need the new box

[05:26] <audreyt> and run uuidgen on it

[05:27] <TimToady> @messages

[05:27] <lambdabot> audreyt said 21h 41m 2s ago: How does S04:927 work with [undef, undef, 1, 5, undef, 6] ?

[05:28] <audreyt> TimToady: I think a list-context undef is a dangerous idea...

[05:28] <gaal> spinozaUuidGen = const 1 -- different repos are but aspects of the same object

[05:28] <audreyt> unless of could we want to train people to write [*, *, 1, 5, *, 6]

[05:29] <audreyt> but that doesn't quite mean "uninitialized"

[05:29] <TimToady> ordinary undef should be 1 long always.  Not sure about failures

[05:29] <audreyt> A list is of undefined

[05:29] <audreyt> length only if it contains an undefined generator, which, happily, is

[05:29] <audreyt> what is returned by the C<undef> function when used in list context.

[05:29] <audreyt> So any Perl 6 function can say

[05:29] <audreyt> return undef;

[05:29] <audreyt> and not care about whether the function is being called in scalar or list

[05:29] <audreyt> context.

[05:29] <gaal> $commute &

[05:29] <TimToady> that what when I was trying to make "return undef" mean "fail".

[05:29] <audreyt> so perhaps that para needs to be fixed

[05:29] <audreyt> 'k

[05:29] <TimToady> *was when

[05:29] <TimToady> yeah.

[05:30] <agentzh> audreyt: i'm exceedingly happy to see the tests under t/closure_traits/ now all turn green. :)

[05:30] <lambdabot> agentzh: You have 1 new message. '/msg lambdabot @messages' to read it.

[05:30] <agentzh> audreyt++ audreyt++ audreyt++

[05:30] <TimToady> still thinking about s{pattern} expr and variations.

[05:30] <audreyt> agentzh: thanks a lot for those tests

[05:30] <audreyt> agentzh: they are very helpful to ensure I got the implemntation right

[05:30] <audreyt> which took ~4 tries

[05:31] <audreyt> the only thing I adjusted was that NEXT is always run even on the final loop

[05:31] <audreyt> as long as its naturally "next"ing instead of last'ing out

[05:31] <audreyt> I think it's saner for it to behave that way

[05:31] <agentzh> audreyt: those tests costed me a lot of time in the summer. ;)

[05:31] <audreyt> because it has to run before evaluating the condition, and without evaluating the condition we don't know if it's the last run

[05:32] *** agentzh joined
[05:33] <audreyt> 07:31 < audreyt> because it has to run before evaluating the condition, and without evaluating the condition we don't know  if it's the last run

[05:34] <agentzh> audreyt: i've read the irc log. :)

[05:34] <agentzh> but i think an explicit last will bypass NEXT {...}, no?

[05:35] <audreyt> that is correct

[05:35] <audreyt> you tested for it :)

[05:35] <agentzh> yeah. :)

[05:35] <audreyt> and PRE/POST seems to be a handy thing to have

[05:35] <agentzh> indeed!

[05:35] <agentzh> i love those trait blocks very much. :)

[05:35] * TimToady blushes.

[05:36] <agentzh> TimToady: :)

[05:36] <agentzh> TimToady: will return bypass LAST {...}?

[05:36] <agentzh> and leave?

[05:36] <TimToady> I don't think so.

[05:37] <agentzh> okay.

[05:37] <agentzh> i didn't write tests for those cases.

[05:37] <TimToady> FIRST and LAST are really traits on the loop as a whole.

[05:37] <audreyt> currently I have it run LEAVE but not LAST

[05:37] <TimToady> ENTER/LEAVE on the closure it repeatedly runs

[05:37] <audreyt> on the theory that nonloop controls does not trigger loop ones

[05:37] <audreyt> hmm.

[05:38] <audreyt> but FIRST won't get run if the condition starts out false, no?

[05:38] <audreyt> neither will LAST

[05:39] <TimToady> I think it's both or neither

[05:40] <TimToady> FIRST, LAST, and NEVER.  :)

[05:40] <TimToady> actually, doesn't python allow else on a loop? or is that some other language?

[05:40] <audreyt> I think neither makes quite a bit more sense

[05:41] <audreyt> the first element of a null list is undefined

[05:41] <audreyt> neither is the last element

[05:42] <TimToady> yeah, that way they are aimed at control points that are otherwise relative inaccessible.

[05:42] <TimToady> one can always say something before or after the loop to get "both".

[05:42] <audreyt> right.

[05:42] <TimToady> s/or/and/

[05:42] <audreyt> in which case they are not really LEAVE on any particular scope

[05:42] <audreyt> and so "return" not triggering LAST makes some sense, I hope

[05:43] <TimToady> I suppose, in the same sense that a goto into a loop might bypass a FIRST.

[05:43] <audreyt> yup.

[05:44] <TimToady> but it seems righter the other way

[05:44] <TimToady> because people will use them to enforce invariants.

[05:44] <audreyt> hm. then I can arrange so it triggers LAST queue explicitly

[05:44] <audreyt> after LEAVE queue

[05:44] <TimToady> the loop as a whole has to have a dynamic scope anyway

[05:45] <audreyt> yes, but it has no place on the stack

[05:45] <TimToady> or you don't have anything to capture the exceptions

[05:45] <audreyt> it's something like

[05:45] <audreyt> FOO while 1;

[05:45] <audreyt> here there's an invisible yet noncapturable {} around FOO

[05:47] <TimToady> well, sure, but whenever you have a thunk somebody's doing things to it.

[05:47] <audreyt> nodnod. as LAST doesn't mix with LEAVE ordering anyway, either hanging it around the invisible thunk of invoke that explicitly turns out to be the same thing

[05:48] <TimToady> been thinking a lot about thunks with respect to s {pattern} mumble

[05:48] <TimToady> and how we can have a way forward on that without confusing people.

[05:49] <TimToady> the s:g {pattern} syntax is getting stretched out, so I've been looking for a syntactic shim

[05:49] <TimToady> so that we don't have to say {...} "..."

[05:49] <TimToady> which is okay for that case, but confusing to people used to

[05:49] <TimToady> [] and {} for quotes on the second part.

[05:50] <TimToady> best candidates I have so far:

[05:50] <TimToady> s{foo} -> "bar"

[05:50] <TimToady> s{foo} = "bar"

[05:50] <TimToady> s{foo}: "bar"

[05:50] *** agentzh left
[05:50] <TimToady> problem with the first is that

[05:50] <TimToady> s{foo} -> $foo

[05:50] <TimToady> is ambig with pointy subs

[05:50] <TimToady> *blocks

[05:51] <audreyt> the colon seems to be the most overloaded one

[05:51] <TimToady> (not really, but visually)

[05:51] <audreyt> so overload it poses least problem

[05:51] <audreyt> ;)

[05:51] <TimToady> problem with colon is

[05:51] <TimToady> s{foo}:qq/bar/

[05:51] <TimToady> suddenly looks like a pair, but isn't.

[05:52] <audreyt> an extended comma?

[05:52] <TimToady> the only problem with = is that, as a pseudo assignment, it seems to have the wrong precedence in:

[05:52] <audreyt> s{foo} <== "bar"

[05:52] <TimToady> $x ~~ s {foo} = "bar"

[05:52] <audreyt> but that too is low prec

[05:52] <TimToady> yes.

[05:52] <TimToady> nice thing about : is that we could actually make it a list operator

[05:52] <audreyt> yes.

[05:53] <audreyt> I think the :qq/bar/ part is easily disambig

[05:53] <TimToady> s{foo}: 1..*

[05:53] <audreyt> s{foo}: qq/bar/

[05:53] <audreyt> which I expect people to write that anyway

[05:53] <TimToady> oh, another possibility was

[05:53] <TimToady> s{foo}/"bar" using / for old time's sake

[05:54] <TimToady> but I just don't like it as well.

[05:54] <TimToady> other problem with <== is that it's backwards from the transformative point of view

[05:54] <TimToady> the = at least finesses that by not looking backwards.

[05:55] <audreyt> the / has the same problem as ./method

[05:55] <TimToady> also considered s{foo} => "bar"

[05:56] <TimToady> nod

[05:56] <audreyt> I like the listop :, because it's not really twisting the meaning

[05:56] <TimToady> thing I liked about = is that we already have lots of pseudo assigns that happen at weird times.

[05:56] <TimToady> though all to declarators at the moment

[05:57] <TimToady> would be funny if s turned out to be a declarator of substrs...

[05:57] <audreyt> oy...

[05:58] <TimToady> but syntactically s{} is a macro, so it can really take anything it jolly well pleases after it.

[05:59] <audreyt> sure, it's just the visualmetaphor

[05:59] <TimToady> also played around a lot with s{foo}.() and friends, but just couldn't make them "think" right.

[05:59] <TimToady> they don't look at all thunky

[05:59] <TimToady> considered s{foo}\"foo" too

[06:00] <TimToady> and \() of course

[06:03] <TimToady> other advantage of = is that we could think of it as unary (scalar assign) if we only want it to collect one expression.

[06:04] <TimToady> with :, you pretty much are expecting a list, and then you have to

[06:04] <TimToady> put parens around the whole thing

[06:04] <TimToady> (s{foo}: "bar"), more...

[06:05] <TimToady> vs s{foo} = "bar", more

[06:05] <TimToady> which can be visually stopped before the comma

[06:05] <TimToady> and we can always use = [...] for a changing list.

[06:06] <audreyt> s{foo}:{...} will also terminate though, but yeah.

[06:07] <TimToady> not necessarily.

[06:07] <TimToady> in .method:{...} it parses as .method: {...}

[06:08] <audreyt> it is considered the final element of that list unless followed immediately

[06:08] <audreyt> by a comma or comma surrogate.

[06:08] <audreyt> but yeah.

[06:08] <nothingmuch> morning

[06:08] <audreyt> hi nothingmuch

[06:08] <TimToady> right, so your example can stop there too.

[06:09] <TimToady> except that it makes no sense to interpolate a closure.

[06:09] <TimToady> if the right side is already thunked.

[06:10] <TimToady> one thing going for bare s{foo} expr is that we could simply outlaw {expr}

[06:10] <TimToady> to catch all the P5 mistakes.

[06:10] <TimToady> doesn't help with [] or () though.

[06:10] <TimToady> <> will usually work.

[06:11] <TimToady> unless they try to interpolate

[06:11] <TimToady> but I still think it's better to spread it out with : or =

[06:13] <audreyt> s{foo}:(...);

[06:13] <audreyt> hm. still has to listop problem

[06:13] <TimToady> s{foo} = (...) is less problematic that way

[06:13] <audreyt> as we can say it's a item=

[06:14] <audreyt> oh well, I guess = wins on that account then

[06:14] <TimToady> I think it stands out just a hair more too.

[06:14] <TimToady> without being obtrusive.

[06:14] <audreyt> but don't make s{} a declarator :)

[06:14] <audreyt> it's a macro that parses assignment form, 'sall

[06:14] <TimToady> why would I do a silly thing like that.

[06:15] <audreyt> :D

[06:15] <TimToady> and I think it compresses better s{foo}=q/bar/

[06:16] <audreyt> sometime people is goign to want

[06:16] <audreyt> s{foo}.="bar"

[06:16] <audreyt> I know I've wanted that several times.

[06:16] <TimToady> ~= ???

[06:16] <audreyt> except it's now ~=

[06:16] <audreyt> S{foo}.=reverse;

[06:16] <TimToady> s{foo}+=42

[06:17] <audreyt> yeah.

[06:17] <audreyt> s{foo}x=3;

[06:17] <TimToady> s{foo}=($/.=reverse)

[06:17] <audreyt> could be handy.

[06:18] <TimToady> so s{foo} really is a kind of self-hypering lvalue.

[06:19] <TimToady> it definitely has some possibilities, though maybe not for 6.0

[06:19] <audreyt> I think it's good jus tto say it looks that way

[06:19] <audreyt> but saying "$x = s{foo};" is invalid

[06:19] <audreyt> not all things need to be first class...

[06:19] <TimToady> yes, it's really a metaop of some sort.

[06:20] *** marmic joined
[06:20] <TimToady> or a term that metas the following infix.

[06:20] <TimToady> or sump'n

[06:21] <TimToady> not sure how this translates to .subst though, unless second arg {$/.=reverse} and such.

[06:21] <TimToady> or $() more likely.

[06:22] <audreyt> *nod*

[06:22] * audreyt goes back to relenging -- subsets are now parsed

[06:25] <gaal> are nested traits legal? { LEAVE { LEAVE { ... } } }

[06:25] <gaal> newVal allows it

[06:25] <gaal> but I'm not sure it makes sense!

[06:25] <audreyt> it certainly does

[06:25] <gaal> use case?

[06:25] <audreyt> you can leave a leave block

[06:26] <audreyt> LEAVE { UNDO {...} }

[06:26] <audreyt> L/L doesn't make a lot of sense but L/U or L/Keep does

[06:26] <gaal> okies

[06:26] <gaal> only a matter of time till someone writes an interpreter using only closure traits for control

[06:28] <audreyt> sure, that's part of perl6's ferocity

[06:28] * audreyt ponders "a feral language"

[06:29] <gaal> Perl's already a creole of sorts

[06:29] <TimToady> booga booga wooga

[06:30] <TimToady> people *are* going to want to say $obj.=s[foo] = "bar"

[06:32] <TimToady> hmm, I wonder if we can distinguish a .subst() normal method from a .subst[] macro, since () always forcing routineness.

[06:32] <audreyt> we certainly can

[06:32] <TimToady> assuming subst is defined as a macro, of course, or it'd be .subst.[]

[06:32] <audreyt> visually confusing though

[06:33] <audreyt> mixing quotelikes with methodlikes

[06:33] <TimToady> yeh

[06:34] <TimToady> I'll leave the method syntax vanilla for now.

[06:35] <TimToady> maybe we make a general policy that method macros should be ALLCAPS

[06:35] <TimToady> .SUBST[foo] = "bar" definitely stands out...

[06:36] <TimToady> pretty darn ugly though

[06:37] <TimToady> maybe we can come up with something prettier someday

[06:44] <audreyt> oy, [\\] is parsed as \ on infix \

[06:44] <audreyt> if we have a infix \\, how do we explicitly want \\ foled?

[06:44] <audreyt> folded

[06:44] <audreyt> [ \\] ?

[06:45] <audreyt> hm, maybe not

[06:45] * audreyt chalks that up as "don't do that then"

[06:55] <TimToady> < audreyt> oy, [\\] is parsed as \ on infix \

[06:55] <TimToady> that's incorrect.  S03 says it prefers the infix.

[06:55] <TimToady> then [\\\] is the triangular form.

[06:56] <audreyt> okie.

[06:56] <TimToady> That's at S03:1036

[06:57] <audreyt> &infix:<\\> means actually \ right?

[06:57] <audreyt> as <> respects quotes

[06:57] <audreyt> have to write &infix:{qn'\\'} to get \\

[06:57] <audreyt> s/quotes/escapes/

[06:57] <TimToady> yes

[06:59] <TimToady> actually, s[foo] x= 3 just turns into .subst(/foo/, { $() x 3 }) since assignment back to $() is already assumed.

[07:00] *** mac93 joined
[07:02] *** mac93 joined
[07:11] <audreyt> [\\] is fixed

[07:13] *** iblechbot joined
[07:15] *** zakharyas joined
[07:22] <TimToady> audreyt++

[07:23] <TimToady> I've checked in the s[foo] = "bar" spec, but we can just deprecate s[foo][bar] for this release.

[07:23] <TimToady> actually, almost all the occurrences in pugs were s{foo}{bar}

[07:24] <audreyt> so maybe just change them all to say that...

[07:24] <TimToady> to say what?

[07:25] <audreyt> I still wonder if quotelike adverbs should simply only take () for args and never other forms.

[07:25] <audreyt> to say {}{} not [][]

[07:25] <audreyt> what I mean is

[07:25] <audreyt> m:adv(1){...}

[07:25] <audreyt> but never

[07:25] <audreyt> m:adv{1=>2}{...}

[07:25] <audreyt> this is a generalization that can bring back

[07:25] <audreyt> m:g{...}.

[07:26] <TimToady> lemme sleep on it

[07:26] <audreyt> and because m() doesn't match, neither shuld m:g(), and eople will accept that

[07:26] <audreyt> but m:P5{...} is a compellign use case of not generalizing pair syntax with quotes, and only allow ()

[07:26] <audreyt> sure :) sleep well

[07:26] <audreyt> m:!adv will still be sllowed, of course.

[07:26] <audreyt> allowed, even

[07:27] *** polettix joined
[07:43] <gaal> hah! I'm reading a Syn patch and see

[07:43] <gaal> So any Perl 6 function can say

[07:43] <gaal> fail "message"

[07:43] <gaal> and I mentally complete "and not care what monad it's in"

[08:32] *** kane-xs joined
[08:44] *** buetow joined
[08:47] *** smash joined
[08:48] *** smash is now known as smash_

[09:02] *** elmex joined
[09:05] *** miyagawa_ joined
[09:17] *** ruoso joined
[09:25] *** cm_ joined
[09:36] <stevan> ingy: ping

[09:44] *** jferrero joined
[10:24] *** TreyHarris changes topic to: Check your feather email | spec.pugscode.org | paste: http://sial.org/pbot/perl6 | pugs.blogs.com

[10:25] <TreyHarris> openfoundry's back

[10:32] <gaal> yay

[10:34] <audreyt> I implemented full continuations

[10:34] <audreyt> and full coroutines

[10:34] <audreyt> that works across blocks

[10:34] <audreyt> and generally rewrote the Eval monad :)

[10:34] <audreyt> pushing back in a bit

[10:34] <integral> audreyt++ # yet more amazing magic

[10:34] <audreyt> integral: I realized that we need to be ContT ErrorT instead of lumping the two together

[10:35] <audreyt> however, ErrorT is lazy in its arguments (Either), so we also need a strict Either

[10:35] <audreyt> the rest just follows :)

[10:35] <integral> ah, fascinating :-)

[10:35] <audreyt> &?CALLER_CONTINUATION is now a full reentrant one

[10:36] <audreyt> and I'm glad to report that t/unspecced/cont.t all passes

[10:40] <svnbot6> r14099 | audreyt++ |  r14971@T:  audreyt | 2006-10-09 13:14:19 +0800

[10:40] <svnbot6> r14099 | audreyt++ |  * screen-nodestatus.pl: Fix parsefail.

[10:40] <svnbot6> r14100 | audreyt++ |  r14972@T:  audreyt | 2006-10-09 13:48:40 +0800

[10:40] <svnbot6> r14100 | audreyt++ |  * Pugs.Val: Explicitly UNPACK inside the boot file, which seems to be

[10:40] <svnbot6> r14100 | audreyt++ |    the only way to get 6.6 and -HEAD both recognize the unboxedness.

[10:40] <svnbot6> r14101 | audreyt++ |  r14973@T:  audreyt | 2006-10-09 13:58:39 +0800

[10:40] <svnbot6> r14101 | audreyt++ |  * Don't unpack Val for now.

[10:40] <svnbot6> r14102 | audreyt++ |  r14974@T:  audreyt | 2006-10-09 14:37:29 +0800

[10:40] <svnbot6> r14102 | audreyt++ |  * FindBin.pm: Correct a bogus use of BEGIN block.

[10:40] <svnbot6> r14103 | audreyt++ |  r14975@T:  audreyt | 2006-10-09 14:40:20 +0800

[10:40] <svnbot6> r14103 | audreyt++ |  * rename the p5 script in examples/cookbook/ to -p5

[10:40] <svnbot6> r14104 | audreyt++ |  r14976@T:  audreyt | 2006-10-09 14:49:47 +0800

[10:40] <svnbot6> r14104 | audreyt++ |  * 01-02default-variables.pl: Use infix:<??> as the example operator name

[10:40] <svnbot6> r14104 | audreyt++ |    that's aliased to //, for old time's sake.  The problem with infix:<qn{\\}>

[10:40] <svnbot6> r14104 | audreyt++ |    is that [\\] can also be construed as a scan over infix:<\>.

[10:40] <svnbot6> r14105 | audreyt++ |  r14977@T:  audreyt | 2006-10-09 15:19:34 +0800

[10:41] <svnbot6> r14105 | audreyt++ |  * Pugs.Lexer: Stylistic tweak.

[10:41] <svnbot6> r14106 | audreyt++ |  r14978@T:  audreyt | 2006-10-09 15:20:40 +0800

[10:41] <svnbot6> r14106 | audreyt++ |  * Pugs.Parser.Operator: When both infix \ and infix \\ is in scope,

[10:41] <svnbot6> r14106 | audreyt++ |      [\\] should parse as folded \\, not scanned \.

[10:41] <svnbot6> r14107 | audreyt++ |  r14979@T:  audreyt | 2006-10-09 15:21:18 +0800

[10:41] <svnbot6> r14107 | audreyt++ |  * Pugs.Parser: Kluged up parser for subsets; not actually doing anything yet.

[10:41] <svnbot6> r14108 | audreyt++ |  r14980@T:  audreyt | 2006-10-09 15:23:37 +0800

[10:41] <svnbot6> r14108 | audreyt++ |  * ext/Benchmark/t/basic.t: This is not a hash:

[10:41] <svnbot6> r14108 | audreyt++ |          {

[10:41] <svnbot6> r14108 | audreyt++ |              foo => sub {

[10:41] <svnbot6> r14108 | audreyt++ |                  ...

[10:41] <svnbot6> r14108 | audreyt++ |              }

[10:41] <svnbot6> r14108 | audreyt++ |          }

[10:41] <svnbot6> r14108 | audreyt++ |      But this is:

[10:41] <svnbot6> r14108 | audreyt++ |          {

[10:41] <svnbot6> r14108 | audreyt++ |              foo => sub {

[10:41] <svnbot6> r14108 | audreyt++ |                  ...

[10:41] <svnbot6> r14108 | audreyt++ |              },

[10:41] <svnbot6> r14108 | audreyt++ |          }

[10:41] <svnbot6> r14108 | audreyt++ |      Can you spot the difference? :-)

[10:41] <svnbot6> r14108 | audreyt++ |      See L<S04/Statement-ending blocks/"block must be disambiguated by a trailing comma">.

[10:41] <svnbot6> r14109 | audreyt++ |  r14981@T:  audreyt | 2006-10-09 15:29:24 +0800

[10:41] <svnbot6> r14109 | audreyt++ |  * Pugs.Class.C3: Generalized C3 algorithm, courtesy of Caio Marcelo.

[10:41] <svnbot6> r14110 | audreyt++ |  r14982@T:  audreyt | 2006-10-09 15:33:18 +0800

[10:41] <svnbot6> r14110 | audreyt++ |  * Perl::Compiler::CodeGen::NameGen - $.foo()(...) is needed to invoke a Code

[10:41] <svnbot6> r14110 | audreyt++ |    attribute, not $.foo(...).

[10:41] <svnbot6> r14111 | audreyt++ |  r14983@T:  audreyt | 2006-10-09 16:36:29 +0800

[10:41] <svnbot6> r14111 | audreyt++ |  * lib.pm: Tidy up the code and force eager evaluation of @*INC.

[10:41] <svnbot6> r14112 | audreyt++ |  r14984@T:  audreyt | 2006-10-09 16:43:13 +0800

[10:41] <svnbot6> r14112 | audreyt++ |  * Pugs.Prim: Force eager evaluation on list-context readdir.

[10:42] <svnbot6> r14113 | audreyt++ |  r14985@T:  audreyt | 2006-10-09 16:45:12 +0800

[10:42] <svnbot6> r14113 | audreyt++ |  * Use MonadError instead of MonadCont for error handling.

[10:42] <svnbot6> r14113 | audreyt++ |    This will help separate out continuations with exceptions.

[10:42] <svnbot6> r14114 | audreyt++ |  r14986@T:  audreyt | 2006-10-09 17:01:41 +0800

[10:42] <svnbot6> r14114 | audreyt++ |  * Oops, fix a miscommit.

[10:42] <svnbot6> r14115 | audreyt++ |  r14987@T:  audreyt | 2006-10-09 17:02:11 +0800

[10:42] <svnbot6> r14115 | audreyt++ |  * Rewrite the Eval monad so we control our own exception

[10:42] <svnbot6> r14115 | audreyt++ |    results now, and force all actions to be strict.

[10:42] <svnbot6> r14116 | audreyt++ |  r14988@T:  audreyt | 2006-10-09 17:06:05 +0800

[10:42] <svnbot6> r14116 | audreyt++ |  * Fix lib.pm again using uniq().

[10:42] <svnbot6> r14117 | audreyt++ |  r14989@T:  audreyt | 2006-10-09 17:13:29 +0800

[10:42] <svnbot6> r14117 | audreyt++ |  * dir.t: @x.sort is better than [sort(@x)].

[10:42] <svnbot6> r14118 | audreyt++ | * Pugs.AST.Eval: Rewrite the Eval monad again to introduce

[10:42] <svnbot6> r14118 | audreyt++ |   full continuations on top of the control-exception stack.

[10:42] <svnbot6> r14118 | audreyt++ |   This is good because it allows us full continuations that

[10:42] <svnbot6> r14118 | audreyt++ |   does not stop at subroutine boundaries.

[10:42] *** agentzh joined
[10:43] <SamB> so many changes, reminds me of "darcs pull" ;-)

[10:43] <svnbot6> r14119 | audreyt++ | * Pugs.AST.Internals: Introduce a different set of control

[10:43] <svnbot6> r14119 | audreyt++ |   combinators:

[10:43] <svnbot6> r14119 | audreyt++ |     # establish a dynamic scope to handle control exceptions

[10:43] <svnbot6> r14119 | audreyt++ |     tryT $ ...

[10:43] <svnbot6> r14119 | audreyt++ |     # like tryT, except you also get a "throw" for free

[10:43] <svnbot6> r14119 | audreyt++ |     catchT $ \throw -> ...

[10:43] <svnbot6> r14119 | audreyt++ |   The "shiftT" is discontinued as Perl6 doesn't have first-class

[10:43] <svnbot6> r14119 | audreyt++ |   delimited continuations (yet), though some day I'd like to add it.

[10:43] <svnbot6> r14119 | audreyt++ |   Use "retError" and "retContol" instead to fire off exceptions.

[10:43] <svnbot6> r14119 | audreyt++ |   The "callCC" is now used to establish fully reentrant continuations.

[10:43] <svnbot6> r14119 | audreyt++ |   The "resetT" guard is only used in coroutines now to limit the

[10:43] <svnbot6> r14119 | audreyt++ |   scope of its callCC register.

[10:44] <agentzh> audreyt is in hacking mode. yay! releng++

[10:44] <audreyt> SamB: it's actually "svk push" following "svk pull" in my local repo :)

[10:44] <SamB> audreyt: ah ;-)

[10:44] <svnbot6> r14120 | audreyt++ | * Pugs.Prim.Eval: Change resetT to tryT.

[10:44] <SamB> I was just saying the output was reminiscent of that "darcs pull" sometimes has ;-)

[10:44] <agentzh> hmm...i'm wondering why the S29 on the smoke server has craps like "_SMART_LINK_34" :(

[10:45] <SamB> its probably supposed to link to something ;-)

[10:45] <svnbot6> r14121 | audreyt++ | * Pugs.Prim: Restore "yield" and coroutines to their former glory,

[10:45] <svnbot6> r14121 | audreyt++ |   by storing a genuine callCC register inside the subCont.

[10:47] <agentzh> SamB: right. they're actually placeholders introduced by myself. ;)

[10:47] <svnbot6> r14122 | audreyt++ | * Pugs.Monad: Establish a resetT boundary upon entering

[10:47] <svnbot6> r14122 | audreyt++ |   coroutines, so its "yield" will only capture the control

[10:47] <svnbot6> r14122 | audreyt++ |   stack up to that point.  However, the &?CALLER_CONTINUATION

[10:47] <svnbot6> r14122 | audreyt++ |   there is unaffected.

[10:47] <svnbot6> r14123 | audreyt++ | * Pugs.Eval: Finish excising of resetT and shiftT and replace

[10:47] <svnbot6> r14123 | audreyt++ |   them with tryT and retControl.

[10:47] <SamB> agentzh: oh really?

[10:47] <agentzh> SamB: yes.

[10:48] <SamB> note that if I was challanging your statement, I'd hava had a 50% chance of having said "o rly?"

[10:48] <agentzh> i just have no idea why the placeholders were not replaced by some HTML links...

[10:48] <SamB> not sure if that is relevant

[10:48] <svnbot6> r14124 | audreyt++ | * examples/cookbook/01strings/01-02default-variables.pl:

[10:48] <svnbot6> r14124 | audreyt++ |   Now that [\\] means infix \\ instead of infix \ again,

[10:48] <svnbot6> r14124 | audreyt++ |   restore the example to its original state.

[10:48] <svnbot6> r14125 | audreyt++ | * t/examples/all_parse.t: examples/ all parses now!

[10:48] <svnbot6> r14125 | audreyt++ |   Take away the spurious force_todo.

[10:48] <svnbot6> r14126 | audreyt++ | * t/unspecced/coro.t: Remove all TODOs.

[10:48] <svnbot6> r14127 | audreyt++ | * t/unspecced/cont.t: Fix plans, and remove all TODOs.

[10:49] <SamB> agentzh: see, thats what I would have expected to happen too...

[10:49] <agentzh> but the S29 page on feather looks fine.

[10:49] <SamB> it must be some half-hearted or out-of-date processor

[10:49] <agentzh> investigating now...

[10:56] <agentzh> heh, maybe iblech is using an older version of Pod::Simple::HTML on the smoke server...hehe

[10:56] <agentzh> the HTML source is different from the one on feather.

[10:57] <agentzh> smartlinks.pl uses regexes to process HTML...

[10:57] <agentzh> fixing...

[11:05] *** cm_ joined
[11:05] <svnbot6> r14128 | audreyt++ | * Pugs.Eval.Var: In multi-dispatch, bias toward things with

[11:05] <svnbot6> r14128 | audreyt++ |   longer parameter lists, even though the type distance is

[11:05] <svnbot6> r14128 | audreyt++ |   otherwise equivalent:

[11:05] <svnbot6> r14128 | audreyt++ |     multi f (Any *@) {...}

[11:05] <svnbot6> r14128 | audreyt++ |     multi f (Any $)  {...}  # This always wins on 1arg case

[11:05] <svnbot6> r14128 | audreyt++ |   Previously the *@ case will win, which was utterly bogus.

[11:08] <svnbot6> r14129 | audreyt++ | * ext/Set/t/operations.t: TODO the stringification test

[11:08] <svnbot6> r14129 | audreyt++ |   as exported methods isn't there yet.

[11:11] <audreyt> ...but it's there now ;)

[11:12] *** chris2 joined
[11:15] <gaal> audreyt: you're stresstesting openfoundry, eh? :-p

[11:16] <audreyt> yeah :)

[11:16] *** agentzh joined
[11:20] <agentzh> hey, i believe the changelog for this release will be *very* lengthy. ;)

[11:20] <audreyt> blame the test writers...

[11:20] <svnbot6> r14130 | agentz++ | [util/smartlinks.pl]

[11:21] <svnbot6> r14130 | agentz++ | - fixed a bug in the HTML post-processor. this patch

[11:21] <svnbot6> r14130 | agentz++ |   should have fixed the smartlink placeholder

[11:21] <svnbot6> r14130 | agentz++ |   (e.g. "_SMART_LINK_57") problem on the smoke server.

[11:21] <svnbot6> r14130 | agentz++ |   this bug was reported by lanny++

[11:21] <agentzh> lol

[11:21] <svnbot6> r14130 | agentz++ |   hopefully iblech++ will update the smartlinks.pl on

[11:21] <svnbot6> r14130 | agentz++ |   the smoke server.

[11:24] <agentzh> i've just tried out stevan's Moose.pm in my XUL to PPT converter. it gave me the feeling of writing Perl 6 OO code. sweet~~

[11:24] *** xinming_ joined
[11:24] <agentzh> now my perl 5 OO modules will no longer be *that* hateful. :)

[11:25] <audreyt> good :)

[11:25] <agentzh> mooooose~~

[11:26] * agentzh now has to go back to some nasty java swing code...

[11:26] <agentzh> sigh.

[11:27] *** agentzh left
[11:30] <svnbot6> r14131 | audreyt++ | * Pugs.Parser: Methods can now be exported and turned into

[11:30] <svnbot6> r14131 | audreyt++ |   multis in their caller's scope.

[11:30] <svnbot6> r14132 | audreyt++ | * Set/t/overload.t: unTODO the prefix ~$foo test.

[11:32] *** markstos joined
[11:32] <svnbot6> r14133 | audreyt++ | * Set.pm: Massive rewrite using shiny new OO style, instead of

[11:32] <svnbot6> r14133 | audreyt++ |   lots of explicit $self variables.

[11:33] <svnbot6> r14134 | audreyt++ | * Set/t/operations.t: unTODO everything.

[11:38] *** cm_ joined
[11:40] *** elmex joined
[11:40] <svnbot6> r14135 | audreyt++ | * Set::Infinite - Repair *@x syntax.

[11:52] <audreyt> hm, 31 unexpected successes

[11:55] <svnbot6> r14136 | audreyt++ | * set-infinite-recurrence.t: unTODO everything and unskip everything.

[11:59] <svnbot6> r14137 | audreyt++ | * even more unTODOs...

[11:59] *** cm_ joined
[12:20] <svnbot6> r14138 | audreyt++ | * Pugs.AST: Bring (listVal :: Val -> [Val]) helper function

[12:20] <svnbot6> r14138 | audreyt++ |   from newVal into oldVal land.

[12:23] *** iblechbot joined
[12:26] <svnbot6> r14139 | audreyt++ | * Pugs.Prim: "take [1,2,3]" shouldn't flatten into "take 1,2,3"

[12:26] <svnbot6> r14140 | audreyt++ | * Pugs.Prim.List: "join(1, [2, 3])" shouldn't flatten into "join(1, 2, 3)".

[12:35] <svnbot6> r14141 | audreyt++ | * Pugs.Eval.Var: The previous treatment of ($) always beating (*@)

[12:35] <svnbot6> r14141 | audreyt++ |   was too eager.  Instead ($) should win iff it's compatible with

[12:35] <svnbot6> r14141 | audreyt++ |   the argument, i.e. at least (Any).

[12:42] *** weinig joined
[12:45] <svnbot6> r14142 | audreyt++ | * Pugs.AST.Internals: Use a more helpful error message to

[12:45] <svnbot6> r14142 | audreyt++ |   explain cases where a prototype occured when instance is expected,

[12:45] <svnbot6> r14142 | audreyt++ |   and we don't know how to autovivify it

[12:45] <svnbot6> r14143 | audreyt++ | * Set/t/basic.t: Correct a misstringification.

[12:47] *** BooK joined
[12:47] <svnbot6> r14144 | audreyt++ | * array-lazy-overloaded.t: Correct a bogus isa_ok().

[12:49] <masak> wow, things are really happening today :)

[12:50] *** fglock joined
[12:52] *** cm- joined
[12:53] *** cm- is now known as cm

[12:57] *** Limbic_Region joined
[12:59] *** camenix joined
[13:02] <svnbot6> r14145 | audreyt++ | * Cipher.pm: Repair [,] syntax to use |@x, and use array instead

[13:02] <svnbot6> r14145 | audreyt++ |   of hash to hold Caesar cipher keys.

[13:03] <audreyt> only five failing tests left in ext/ space:

[13:03] <audreyt> ext/HTML-Entities/t/entities.t

[13:03] <audreyt> ext/Perl6-Container-Array/t/array-lazy.t

[13:03] <audreyt> ext/Perl6-Container-Array/t/array-operations.t

[13:03] <audreyt> ext/Recurrence/t/recurrence.t

[13:03] <audreyt> ext/libwww-perl/t/live.t

[13:03] <audreyt> I need to go out for a walk now; will be nice if someone can take a look at them :)

[13:04] <fglock> audreyt: I'm considering using ext/Perl6-Container-Array for implementing laziness in v6.pm

[13:04] <audreyt> cool. maybe you can take a look at why it's failing miserably currently then

[13:05] <fglock> looking

[13:06] <fglock> I'll need to install pugs first - too old here

[13:07] *** rodi joined
[13:09] <audreyt> k... bbiab

[13:15] <svnbot6> r14146 | audreyt++ | * Cipher.pm: Don't treat undef as Array.

[13:18] <svnbot6> r14147 | audreyt++ | * ext/: Massive change of [,] into |.

[13:36] <fglock> make test is looking for Test.pm, but blib6/lib only has Test.pm.yml

[13:47] *** iblechbot joined
[13:47] <fglock> copying Test.pm to blib6/lib fixed it - Makefile bug?

[13:54] *** fglock left
[14:00] <svnbot6> r14148 | audreyt++ | * Pugs.AST.Eval: unsafeCoerce# on an unpacked field was a bad idea...

[14:01] <svnbot6> r14149 | audreyt++ | * Pugs.Parser: Removed an unused binding

[14:04] *** lisppaste3 joined
[14:07] <pasteling> "masak" at 130.238.83.176 pasted "I looked at ext/Perl6-Container-Array/t/array-lazy.t but quickly filled up my mystification quota... here's the postmortem" (40 lines, 1.1K) at http://sial.org/pbot/20290

[14:11] *** ludan joined
[14:49] <TimToady> @messages

[14:49] <lambdabot> You don't have any new messages.

[14:49] <audreyt> TimToady: gather/take scopes dynamically right?

[14:49] <audreyt> sub f { take 3 } # this makes sense, correct?

[14:50] <audreyt> gather is unspecced in Syn, hence the question

[14:50] <TimToady> the A might have said

[14:51] <audreyt> A12 says it's lexical

[14:51] <audreyt> I wonder why it's lexical...

[14:51] <audreyt> I mean, its effect, unlike that of given/when, is dynamic

[14:51] <TimToady> ere probably ought to be a dynamically scoped variant.

[14:51] <TimToady> Unless it should be dynamic by default, in which case there probably

[14:51] <TimToady> ought to be a lexically scoped variant...

[14:52] <audreyt> curiously damian's Perl6::Gather on CPAN is dynamically scoped.

[14:52] <audreyt> where is lexical useful, I wonder

[14:52] <TimToady> well, the only purpose of a lexical scope would be to prevent people from doing the dynamic version, I guess.

[14:53] <audreyt> that's like saying we should have a lexical variant of "next"

[14:53] <audreyt> to prevent people using next outside loops...

[14:54] <TimToady> go with dynamic then. can always do some kind of stricture later

[14:54] <audreyt> 'k. I'll make it die if not within a gather dyamic scope

[14:54] <TimToady> after thinking about s:g() overnight, I think I agree.

[14:54] <audreyt> using the same mechanism as next outside loops

[14:55] <audreyt> hurray

[14:56] <TimToady> gather can be viewed as (potentially) spawning another thread, so given the whole purpose of that other thread may be to generate, it makes sense to have it dynamic.

[14:57] <TimToady> must generate some coffee... biab

[15:04] *** fglock joined
[15:05] *** penk joined
[15:08] <fglock> audreyt: re ext/Perl6-Container-Array - I found the same error as masak - maybe @array-as-invocant is not parsed correctly?

[15:11] <audreyt> fglock: maybe; or maybe the local push is shadowing the global one

[15:12] <fglock> hmm - circularity problems

[15:12] <audreyt> can you add some trace to see if it's the case?

[15:13] <fglock> actually, the error is - No compatible subroutine found: "&items" - looks more like a parser problem

[15:14] <audreyt> no, that means "self" is somehow not a object

[15:14] <fglock> the code reads @.items

[15:14] <audreyt> instead it's an Array

[15:14] <fglock> k

[15:14] <audreyt> @.items is just @(self.items)

[15:14] <lambdabot> Unknown command, try @list

[15:15] <masak> audreyt: I tried adding a trace using :E in pugs interactive, but I didn't get very far -- seems :E creates a new instance of pugs

[15:16] <masak> or something

[15:16] <fglock> rewriting to @(self.items) seems to improve it

[15:16] <audreyt> masak: there's ./pugd -d

[15:16] <audreyt> ./pugs -d

[15:16] <audreyt> indeed? hmm

[15:16] <audreyt> weird

[15:19] *** amnesiac joined
[15:19] <svnbot6> r14150 | audreyt++ | * Pugs.Monad, Pugs.AST.Internals: Revamp the dynamic frame

[15:19] <svnbot6> r14150 | audreyt++ |   management system.  Instead of tracking explicit frames,

[15:19] <svnbot6> r14150 | audreyt++ |   we now collect a set of frame markers, such as "FrameRoutine",

[15:19] <svnbot6> r14150 | audreyt++ |   "FrameGather", "FrameGiven", "FrameLoop" etc.

[15:19] <svnbot6> r14151 | audreyt++ | * Regen instances.

[15:20] <fglock> yes, @(self.items) seems to fix each of the errors

[15:20] <svnbot6> r14152 | audreyt++ | * Revamp the "gather" structure, after discussion with TimToady++

[15:20] <svnbot6> r14152 | audreyt++ |   so that "take" is dynamic, although still fails if the callers

[15:20] <svnbot6> r14152 | audreyt++ |   contains no "gather" frames.

[15:20] <svnbot6> r14153 | audreyt++ | * statements/gather.t: Reflect the fact that gather/take

[15:20] <svnbot6> r14153 | audreyt++ |   is now dynamic.

[15:21] <audreyt> fglock: commit the workaround and I'll trace the cause?

[15:21] <fglock> ok

[15:24] <svnbot6> r14154 | putter++ | t/regex/p6regex/p6regex.t - enforce assumptions about input (audreyt++); added standard check for rules support; updated force_todo.

[15:24] <fglock> audreyt: v14155

[15:24] <svnbot6> r14155 | fglock++ | ext/P6::C::Array - workaround @.items => @(self.items)

[15:25] *** putter joined
[15:27] <fglock> audreyt: btw, I got this error in my first make test - pugs looks for Test.pm, but blib6/lib only has Test.pm.yml

[15:28] <audreyt> fglock: yeah, "make" need to happen before make test

[15:29] <putter> strawman proposals: add two new make targets: "precompiled_test" - tweak config.yml; perl Makefile.PL; make.   And "testonly" - only run the test, no make - because make test, which runs make, dumps a great deal of crud at the top of the test log.  thoughts?

[15:30] <audreyt> good idea, please commence :)

[15:31] <putter> hmm, the preceeding few lines of irc suggest  make test does not do  make, but whatever it's doing, it's noisy...

[15:31] <putter> :) k

[15:31] *** thepler joined
[15:33] *** chris2 joined
[15:35] <gaal> moose!

[15:35] <TimToady> m:g[I'm okay] now specced

[15:35] <svnbot6> r14156 | audreyt++ | * Move possiblyFixOperatorName from consumption site (lookupPad)

[15:35] <svnbot6> r14156 | audreyt++ |   into production site (_Var and explicit &::()) on the assumption

[15:35] <svnbot6> r14156 | audreyt++ |   that the former happens far more often than the former.

[15:36] * avar notes that conway did not spec L<info:*> in S26a:/

[15:36] <gaal> the former happens more often than the former? hmm.

[15:36] <audreyt> *more often than the latter.

[15:36] <pasteling> "masak" at 130.238.83.176 pasted "I must be misunderstanding the -d flag. it makes no difference for me" (10 lines, 467B) at http://sial.org/pbot/20293

[15:37] <audreyt> masak: seems "use" turns off -d

[15:37] <audreyt> for some reason. investigating

[15:37] <gaal> audreyt: I gots me some tuits. open antlers == ?

[15:38] *** Limbic_Region joined
[15:39] <audreyt> chglog is by far the most antler

[15:39] <gaal> hmm, why's smoke upload taking so long?

[15:39] <gaal> oi :)

[15:39] <audreyt> oy indeed, as there are very few triage tasks left

[15:40] <Limbic_Region> yay

[15:40] <TimToady> @audreyt »+=« 42

[15:40] <lambdabot> Unknown command, try @list

[15:42] <putter> has anyone ever done timing tests of "Test precompiled, but not in Prelude" vs "Test precompiled in Prelude"?

[15:44] <audreyt> havn't

[15:44] <svnbot6> r14157 | audreyt++ | * operator_overloading.t: Change the example from infix:<X>

[15:44] <svnbot6> r14157 | audreyt++ |   to infix:<Z> in the anticipation of the new X and XX ops.

[15:44] <audreyt> would be surprised if there's a nontrivial delta

[15:47] <svnbot6> r14158 | audreyt++ | * uhm, typo.

[15:47] <svnbot6> r14159 | fglock++ | ext/P6::C::Array - added comments to workaround

[15:47] <svnbot6> r14160 | audreyt++ | * One more s/X/Z/ in operators.t.

[15:47] <putter> looks like  make test  and smoke  precompile Test already.  that plus "trivial delta" suggest editing config.yml doesn't matter, and a "precompiled_test" target is not needed.  anyone have experience that editing config.yml's precompiled_modules  _does_ matter?

[15:48] <audreyt> it predates individual.pm.ml

[15:48] <svnbot6> r14161 | fglock++ | fixed last commit

[15:48] <audreyt> er, .yml. though .ml would be fun

[15:49] <audreyt> but yeah.

[15:49] <TimToady> audreyt: can we sneak the s:g[yay] change in?  seems non impactful, by and large.

[15:50] <svnbot6> r14162 | audreyt++ | * Pugs.Parser.Unsafe: "pugs -d" should trace statements

[15:50] <svnbot6> r14162 | audreyt++ |   inside/after "use" and macros as well.

[15:50] <TimToady> or would that need a bifurcation of the adverb logic?

[15:50] <audreyt> sure. can you moose the dynamic gather in as well?

[15:51] * demerphq idly wonders if p6 will have an efficient 'goto'

[15:52] <TimToady> why should it?  P5's goto was pessimal by design.  :)

[15:52] * [particle] notes that parrot does

[15:52] <demerphq> really?

[15:52] <demerphq> by design i mean.

[15:52] <TimToady> pretty much, though "pessimal" is overstating it.

[15:53] <TimToady> I didn't want people building efficient switch statements from labels.

[15:53] <demerphq> i was just thinking about state machines and how useful goto is for them

[15:53] <TimToady> P5 always scans for the label dynamically, though it does optimize by scanning outward from the current scope.

[15:54] <demerphq> but its probably just a sign of oncoming demetia due to too much C programming. :-)

[15:54] <TimToady> it also optimizes by scanning forward from the current location and then from the top to here.

[15:54] <TimToady> on the assumption that most goto's are forwards.

[15:54] <TimToady> other than that, it doesn't go out of its way to make it efficient.

[15:54] <demerphq> ok.

[15:55] <TimToady> because there was always going to be a switch statement someday...

[15:55] <TimToady> P5 even had the opcodes for cswitch and nswitch, just nothing ever parsed to them.

[15:56] <demerphq> Yes i recall you explaining that one time.

[15:56] <demerphq> other question: ive selected (?&NAME) for a recursive call to a named subpattern. Which is different from what Python/PCRE use (partially because we are using the .NET syntax and not the Python/PCRE syntax)

[15:56] <gaal> TimToady: duff's device *does* provide a speedup in p5, fwiw.

[15:56] <TimToady> P4 actually did have that optimization

[15:56] <demerphq> 5.10 will use those ops wont it?

[15:57] <TimToady> dunno

[15:57] <demerphq> id have to check, but robin put given into perl 5.9.x sometime back.

[15:58] <rgs> nswitch and cswitch aren't used in perl 5.

[15:58] <rgs> the new-style switch in bleadperl is implemented with other ops (given)

[15:58] <TimToady> phone...

[15:58] <demerphq> ah.

[15:59] <demerphq> btw, rgs i was just going to C&P my comment about the sytax for the recursive call to a named subpattern. did you see it?

[15:59] <rgs> no.

[16:00] <demerphq> c&p'd to p5p

[16:01] <TimToady> sort of a pity you can't use (?<NAME>)

[16:01] <TimToady> though maybe (?P6:<NAME>) would work for that.

[16:01] <demerphq> thats what we use to declare the buffer.

[16:02] <rgs> that you be a bit more symmetrical

[16:02] * rgs looks at the % key on his keyboard

[16:02] <demerphq> declare: (?<NAME>PATTERN) backref: \k<NAME> recurse: (?&NAME)

[16:02] <fglock> demerphq: I've got a p6rx-to-p5rx module under way - might be useful for experimenting with p6 requirements

[16:02] <audreyt> fglock: as an aside, are you subscribed to p5p?

[16:02] <demerphq> fglock: are you targetting perl 5.8 or 5.9.x?

[16:03] <fglock> audreyt: not sure, maybe not

[16:03] <fglock> demerphq: 5.8

[16:03] <demerphq> ok.

[16:03] <fglock> demerphq: but it is not production, so no problem in targetting 5.9

[16:04] <demerphq> i can see why, but i think you might find your life is much easier with 5.9 or 5.10

[16:04] <audreyt> fglock: you can find out by sending a mail to [email@hidden.address]
[16:04] *** justatheory joined
[16:04] <fglock> audreyt: will do

[16:05] <demerphq> personally i think it would be cool if you did, as thats where my regex updates go to first.

[16:06] <TimToady> hmm, that smoke was very fast, pity about the 0% successful, will try realclean...

[16:06] <svnbot6> r14163 | audreyt++ | * Pugs.Parser.Operator: Use an very evil Int32# unsafeCoerce#

[16:06] <svnbot6> r14163 | audreyt++ |   as the hash key for (TVar VRef) cache, completely bypassing

[16:06] <svnbot6> r14163 | audreyt++ |   the Enum instance and the two boxing/unboxing involved.

[16:06] <svnbot6> r14163 | audreyt++ |   Weakly typed language has its advantages...

[16:06] <svnbot6> r14162 | audreyt++ | * Pugs.Parser.Unsafe: "pugs -d" should trace statements

[16:06] <svnbot6> r14162 | audreyt++ |   inside/after "use" and macros as well.

[16:07] *** discordja joined
[16:07] <demerphq> timtoady: theres been some debated about whether the perl engine can or should support (?P.... constructs, as apparently you told Guido at one point that he could "have" it for python. (Based on hearsay only)

[16:08] <TimToady> audreyt: btw I have been notably unsuccessful in getting -prof to not coredump within the first 10 or 20 records of my dataset.  Holding out for 6.6, I guess...

[16:08] <audreyt> TimToady: is your perl5 threaded?

[16:09] <TimToady> dunno, it's stock fedora

[16:09] <audreyt> perl -v will show that info

[16:09] <TimToady> yeah, P5 should probably avoid (?P

[16:09] <TimToady> yes, threaded

[16:09] <audreyt> because GHC 6.4 -prof+threaded is notoriously broken, so much so that they've taken out that combination in 6.6...

[16:10] <TimToady> ah

[16:10] <TimToady> yes, I promised Guido he could have (?P

[16:11] <TimToady> course, with P6 all bets are off, since there's no (?...) anymore

[16:12] <fglock> demerphq: the main bottleneck for regexes in v6.pm is the OO overhead; also, backtracking into sub-rx is not possible

[16:12] *** Psyche^ joined
[16:13] <TimToady> well, all we have to do is reimplement the entire P5 engine inside the regex engine, and then we'll have continuations.  :)

[16:13] <ajs_home> TimToady <P{...}>

[16:13] <demerphq> the question we had a little was whether we should support the Python/PCRE syntax for named buffers as well as the .NET one.

[16:13] <ajs_home> I realize the braces are just mean, but there you go ;)

[16:13] <demerphq> fglock: what do you mean backtracking into subpatterns is not possible?

[16:13] <fglock> actually, I was wondering if we could implement p6-to-rx instead

[16:14] <fglock> demerphq: such as /a <ws> \s a/

[16:14] <TimToady> ajs_home: huh?

[16:14] <demerphq> i thought 5.8 supported backtracking into (??{...}) patterns. doesnt it?

[16:14] <fglock> demerphq: <ws> is a method

[16:15] <demerphq> but if ws is a method that resolves to a pattern...

[16:15] <ajs_home> TimToady: Was just thinking out loud about (?P...) in P6.

[16:15] <demerphq> anyway, 5.9.5 does, unequivocally, support backtracking into a subpattern.

[16:15] <ajs_home> <P something> perhaps just <P ...>

[16:16] <ajs_home> demerphq: subpatterns ne sub-rx/rule

[16:16] <demerphq> for instance $ws=qr/\s+/; /a (??{$ws}) \s a/x does.

[16:17] <audreyt> demerphq: is $ws=qr/\s+/ still much slower than $ws='\s+' ?

[16:17] <demerphq> er, i didnt know it ever was.

[16:17] <fglock> demerphq: should I be afraid of the "highly experimental" notice in the docs in 5.8?

[16:18] <demerphq> fglock: not really. ive been meaning to ask on p5p if we could tone those notices down.

[16:18] <demerphq> they wont be removed.

[16:18] <demerphq> their behaviour may change subtly however.

[16:18] <demerphq> most likely for the better. but whatever.

[16:18] <demerphq> :-)

[16:18] <demerphq> ajs: thanks i didnt realize that

[16:22] <TimToady> subpatterns in P6 really are full-fledged subroutine calls.  They're not special-cased into the regex engine.

[16:22] *** cmarcelo joined
[16:23] <TimToady> where one could use a less polite term for "special-cased"  :)

[16:25] <svnbot6> r14164 | audreyt++ | * Recurrence.pm: Fix the bug of $.previous_closure()()

[16:25] <svnbot6> r14164 | audreyt++ |   written as $.previous_closure().

[16:26] <fglock> TimToady: maybe it can be faked into a call - perl -e ' my $ws=sub{qr/z+/}; my $ax = /a (??{$ws->()}) \s a/x; $ws=sub{qr/\s+/}; print ("a x" =~ $ax ? "yes" : "no") '

[16:26] <TimToady> eep, my smoke tests are all getting "user error (syntax error: line 3, column 0)

[16:27] <TimToady> which file, it does not deign to say...

[16:27] <TimToady> fglock: sure, but it still doesn't by you backtracking into it unless main runloop does continuations

[16:28] <TimToady> I was very nearly semi-serious about using the regex runloop instead.

[16:28] *** weinig is now known as weinig|out

[16:28] *** Psyche^ is now known as Patterner

[16:29] <fglock> TimToady: isn't it backtracking in this example?

[16:29] <demerphq> lexicals dont really work with (??{})

[16:29] <demerphq> something you want to keep in mind.

[16:29] <nothingmuch> @seen cmarcelo

[16:29] <lambdabot> cmarcelo is in #perl6. I don't know when cmarcelo last spoke.

[16:33] *** rodi joined
[16:33] <TimToady> fglock: it's a form of backtracking, but doesn't actually let the sub do sub-ish things on the fly, since the sub is just precalculating a regex to hand back.

[16:34] <svnbot6> r14165 | audreyt++ | * Pugs.hs: pugs -c should not imply -d...

[16:34] <putter> the regexp spike, whose syntax was p5 regexps plus <foo>, just converted the <foo args> into (?{dorule( C  ,'foo','args')}), where C was the continuation representing the rest of the regexp.  so backtracking worked properly.

[16:34] <fglock> TimToady: got it

[16:34] <demerphq> and in 5.9.5 it be called on backtracking.

[16:35] <putter> but did depend on the spike engine being reentrant

[16:35] <demerphq> it wont be

[16:35] <putter> demerphq: was "it wont be" -> putter?

[16:36] <demerphq> no.

[16:36] <putter> k :)

[16:36] <demerphq> i was saying that in /(??{ ... })/ the code only gets executed when the constructed is entered from the left, not from the right.

[16:36] <demerphq> in hindsight im not sure if thats a useful observation....

[16:37] <demerphq> :-)

[16:39] * putter punts on  make test-only.  Fighting MakeMaker is just not -Ofun.

[16:39] <cmarcelo> nothingmuch: pong

[16:39] <audreyt> m:P5{...} is now valid again. let's see how many tests it breaks...

[16:40] <svnbot6> r14166 | kudra++ | Jesse gives this uri for planetsix perl

[16:41] <fglock> bbiab &

[16:44] <nothingmuch> hola cmarcelo

[16:46] <TimToady> is "user error (syntax error: line 3, column 0)" a yaml error?

[16:46] <svnbot6> r14167 | audreyt++ | * Pugs.Parser.Types: Introduce a new bracket level,

[16:46] <svnbot6> r14167 | audreyt++ |   "QuoteAdverbBracket", that constraints a pair adverb

[16:46] <svnbot6> r14167 | audreyt++ |   to not consume bracktes other than ():

[16:46] <svnbot6> r14167 | audreyt++ |     q:n{...}    # q:n(True){...}, not q:n({...}).

[16:46] <svnbot6> r14168 | audreyt++ | * Date.pm: Avoid a :P5<i> use where a .lc will suffice.

[16:46] *** weinig|out is now known as weinig

[16:47] <cmarcelo> nothingmuch: ola! did you try some Hs code for MO already?

[16:47] <nothingmuch> nope, did not

[16:47] <nothingmuch> however, the perl 5 version is 100% pure

[16:47] <nothingmuch> so it should almost be a transliteration

[16:47] <svnbot6> r14169 | audreyt++ | * Pugs.Parser: Rename ruleAdverbHash to ruleQuoteAdverbs,

[16:47] <svnbot6> r14169 | audreyt++ |   and let them respect the QuoteAdverbBracket level.

[16:48] <nothingmuch> the bit i'm worried about is translating roles to type classes etc

[16:49] <cmarcelo> that's my idea at first. however i'm not very experienced :o) what do you think can go wrong?

[16:49] <nothingmuch> audreyt: could you give us a quick primer?

[16:49] <nothingmuch> e.g. some points to avoid

[16:49] <nothingmuch> etc?

[16:50] <audreyt> nothingmuch: I wish I can but it's past midnight and my brain doesn't quite work yet :)

[16:50] <nothingmuch> ah

[16:50] *** smash joined
[16:50] <audreyt> will be happy to SEE it out tomorrow

[16:50] <nothingmuch> err

[16:50] <audreyt> but would be happy if you two start first

[16:50] <nothingmuch> aye

[16:50] <nothingmuch> hmm

[16:51] <nothingmuch> we will annoy #haskell with n00b questions =)

[16:51] <cmarcelo> @localtime nothingmuch

[16:51] <lambdabot> Local time for nothingmuch is Mon Oct  9 18:51:41 2006

[16:53] <cmarcelo> nothingmuch: i'll leave work in +/- 4hr, then I'll have a few hours to start something. you told me that AG were not that important, other tests aren't too?

[16:53] <nothingmuch> basic.t, mi.t -- they're fairly good

[16:55] <nothingmuch> i'm going to get a beer

[16:55] <nothingmuch> and then churn out some unit tests

[16:55] <nothingmuch> that clarify what all the sub objects are about

[16:55] <nothingmuch> it should be around 4 hrs worth of work

[16:55] <nothingmuch> fairynuff?

[16:58] <cmarcelo> ok. i'll go for basic.t and mi.t first. (i meant i'll leave $job in 4hrs => i think didn't understand your last msgs)

[16:58] <nothingmuch> si

[16:59] <nothingmuch> i meant i'll have something for you by then  ;-)

[16:59] <nothingmuch> hopefully

[16:59] * nothingmuch never lives up to his code promises

[16:59] *** rodi joined
[17:00] <svnbot6> r14170 | audreyt++ | * examples/obfu/l33t.pl: remove :P5<i> usage and restore

[17:00] <svnbot6> r14170 | audreyt++ |   it to fully working condition.

[17:00] <cmarcelo> nothingmuch: ok :)

[17:03] <svnbot6> r14171 | audreyt++ | * examples/perl5/cpan-upload.pl: Restore use of rx:P5{}

[17:03] <putter> am I correct in believing we still don't have a p5 regexp to p6 regex converter yet?

[17:04] <audreyt> we actually do

[17:04] <audreyt> pretty comprehensive too

[17:04] <audreyt> it's in misc/pX/Common/P5_to_P6_Translation

[17:04] <audreyt> not yet hooked to Pugs proper

[17:04] <audreyt> planned, though.

[17:06] *** bernhard joined
[17:07] <putter> ah ok.  I stumbled upon an old todo item, that someone should take an hour or few and make a converter out of Regexp::Parser, and it didn't seem anyone had done it yet.

[17:10] <putter> yipes!  P5_to_P6_Translation  isn't p5 regexp to p6 regex translation...  P5_to_P6_Translation is p5 to p6 translation!!!

[17:10] <audreyt> yeah. works for quite a few simple cases too

[17:10] <audreyt> it's Sage's SoC

[17:10] <audreyt> although only the regex part is well-covered

[17:11] <audreyt> putter: a transcription from misc/pX/Common/P5_to_P6_Translation/ASTTranslate.hs to some spec based stuff that you can then hook into Regexp::Parser will be cool

[17:11] <audreyt> i.e. only the rx parts of it

[17:12] <audreyt> t/regex/ aside, magic number is down to 2:

[17:12] <audreyt>  ext/HTML-Entities/t/entities.t

[17:12] <audreyt>  ext/libwww-perl/t/live.t

[17:13] <audreyt> alas I can't stay up to finish them :)

[17:13] <audreyt> till tomorrow then... *wave* &

[17:13] <putter> re "t/regex/ aside", t/regex should be all working, but for any supprise sucesses from recent work

[17:13] <audreyt> TimToady++ # gave ready assent to m:P5{...} and q:w{...}

[17:13] <audreyt> oh, excellent. I mask them locally; will give another run tomorrow

[17:13] <audreyt> putter++

[17:13] <putter> good night audreyt *wave*

[17:14] <audreyt> this release is actually looking good :)

[17:14] <putter> indeed. :)

[17:14] * putter realizes he hasn't tested the "use PGE instead" env var stuff.

[17:18] <svnbot6> r14172 | audreyt++ | * t/02-test-pm/: synchronize with ext/Test/.

[17:32] *** discordja_ joined
[17:50] <cmarcelo> bbl &

[17:57] <audreyt> :r

[17:57] <audreyt> oops, wrong window ;)

[18:08] *** buetow joined
[18:12] *** larsen joined
[18:13] *** putter joined
[18:15] <putter> As of r14149, I see 3 t/ failures: t/blocks/multidimensional_arglists.t with a parse error, and segfaults in t/examples/all_parse.t and t/perl5/array.t.

[18:15] * putter considers upgrading to 6.4.2, but notes 6.4.1 is still the official dependency.

[18:15] <putter> bbl &

[18:17] <TimToady> currently smoking r14172, news in .5`hr or so

[18:22] <demerphq> I just realized that we could use (*...) and ({.....}) in the perl5 engine with no back compat problems.

[18:23] <TimToady> except it probably won't recognize {...} as a quantifier unless it matches \d+,?\d*

[18:23] <svnbot6> r14173 | audreyt++ | * Date.pm: Remove bogus "return-in-BUILD" pattern and instead

[18:23] <svnbot6> r14173 | audreyt++ |   just set $!attr.

[18:23] <TimToady> in which case the {...} match literally

[18:24] <demerphq> oh. ok, heh. i had been wondering why (??{}) wasnt spelled ({...}).

[18:24] <TimToady> hysterical raisins

[18:24] <demerphq> but that doesnt apply to (*....) does it?

[18:25] <svnbot6> r14174 | audreyt++ | * multidimensional_arglists.t: unTODO the passing tests.

[18:25] <TimToady> no, if I recall, I had the sense to make that illegal.

[18:25] <TimToady> unlike some of the other greppy things.

[18:25] <demerphq> grep lets you quantify an open bracket? weird.

[18:26] <svnbot6> r14175 | audreyt++ | * Pugs.Parser: Parse and recognize the @@ sigil.

[18:26] <TimToady> no

[18:26] <TimToady> grep assumes you meant \*

[18:26] <TimToady> likewise for a non-sensical $

[18:27] <demerphq> aha. right. good thinking. that does sound unwise.

[18:28] <TimToady> unfortunately, by the time I added {n,m}, Perl had already been out in the while matching {...} literally.

[18:28] <TimToady> s/while/wild/

[18:28] <TimToady> durn fingers...

[18:29] <demerphq> yes i can see the issue. thats why ive pestering everybody about the syntax for my recent changes so much.

[18:29] <TimToady> backward compatibility is the pits in regex land...

[18:30] <TimToady> that's why we've been careful to leave a lot of wiggleroom in P6

[18:31] <pasteling> "gaal" at 192.115.25.249 pasted "some pugsjs failures" (23 lines, 1.5K) at http://sial.org/pbot/20302

[18:31] <svnbot6> r14176 | audreyt++ | * Pugs.Eval.Var: Rewrite the multi-dispatch resolver:

[18:31] <svnbot6> r14176 | audreyt++ |     - Don't bother calculating type distance if it can't be bound.

[18:31] <svnbot6> r14176 | audreyt++ |     - If it's bound, only calculate type distances for the bound non-slurpy parts.

[18:31] <svnbot6> r14176 | audreyt++ |     - Named arguments are no longer rigged to always lose multi-dispatch.

[18:31] <svnbot6> r14176 | audreyt++ |     - Mixed named-vs-positional arguments are now handled correctly.

[18:31] <TimToady> yow! audreyt++

[18:33] <integral> I'm getting "<no location info>: file name does not match module name `Main'" as a build error when I build Pugs atm.  Anyone else found this?

[18:33] <demerphq> yep. that sounds very sensible.

[18:39] *** rodi joined
[18:40] <svnbot6> r14177 | audreyt++ | * Set::Infinite - unTODO and unSKIP every single test now that MMD resolver

[18:40] <svnbot6> r14177 | audreyt++ |   correctly make the module work as designed.

[18:42] *** mac93 joined
[18:42] <gaal> integral: hmmm, sounds familiar, but I can't recall what it was. make clean?

[18:43] *** Aankhen`` joined
[18:43] <integral> I'm trying a realclean at the moment.  I'd already tried clean+rm -r dist

[18:43] *** fglock joined
[18:43] <gaal> fwiw 14175 builds ok here

[18:44] <gaal> integral: nopaste whereabouts this happens?

[18:44] <gaal> or grep the irc log...

[18:44] <integral> gaal: right after running Setup for the main Pugs cabal package it appears

[18:46] *** xerox joined
[18:47] <gaal> integral: ah, I remember what gives this error. do an svk st and make sure you didn't mangle the first character of a .hs file

[18:47] <integral> o_O  `svk diff src` is showing no difference for me, so  I hope that's the case

[18:48] <TreyHarris> TimToady: "is copy" on formal params is currently a noop for non-autoboxed types.  will that always be true (at least for non-value types)?  or will "is copy" eventually clone non-value types?

[18:48] <gaal> integral: may be one of the autogen files?

[18:48] <gaal> oops phoen

[18:48] <gaal> *phone

[18:48] * integral watches the build,  I'll find out in a minute 8-)

[18:50] <integral> ugh, realclean hasn't solved it, so I'll check all the .hs files now :)

[18:52] <integral> ah, my src/DrIFT/XML.hs is missing a module declaration at the top

[18:53] <gaal> hmm, why didn't svk st show that?

[18:53] <integral> hrm, I've svk reverted it and it still doesn't. :-/

[18:53] <gaal> okay, please strace -fF -o /tmp/xx make pugs

[18:53] <gaal> and find the offending file :)

[18:53] <integral> hmm, the one on openfoundry also doesn't have a module statement

[18:54] <gaal> huh, neither does the one here.

[18:54] <integral> I can't strace, I'm on OS X 10.3

[18:55] <gaal> there's another tool... ktrace?

[18:55] *** elmex joined
[18:55] <gaal> or just some file monitor

[18:56] <gaal> 'svk st util' too

[18:56] <fglock> gaal: I'm reading Test.pm.yml - would you help me with a few things?

[18:58] <gaal> I'll try :-)

[18:58] <svnbot6> r14178 | audreyt++ | * DrIFT.XML: Add the missing module statement.

[18:58] <TimToady> TreyHarris: good question.  we could certainly extend it to other types provided the definitions of "clone" and "rw" are clear.

[18:58] <TimToady> as it is, "readonly" is a bit hand-wavey.

[18:59] <TimToady> what does it really mean for a non-value type to be "writable"?

[18:59] <fglock> I see ( Var "&infix:~" ) - does "Var" mean it has to lookup &infix:~ at runtime?

[18:59] <gaal> yes

[19:00] <gaal> it's App Exp (Maybe Exp) [Exp]

[19:01] <TreyHarris> well, the MOP could snapshot the object and throw an exception at runtime if the repr changes.  i suppose then objects would have to have some way of saying an given operation should be considered a read but may change the repr or certain attribs may change without "writing" to the object (e.g., caches)

[19:01] <fglock> about ( Ann ... ) - is it meant to attach a (Pos) node?

[19:01] <gaal> that is, apply to an Exp (with an invocant, maybe) [and an Exp list]

[19:01] <TimToady> yay, r14172 exceeds the purity of Ivory Soap!!!

[19:01] <TimToady> it's all very transactional...

[19:02] <TimToady> and also related to "old" in PRE blocks.

[19:02] <TimToady> *PO

[19:02] <svnbot6> r14179 | audreyt++ | * Pugs.Bind: Reject named arguments that cannot find a matching named

[19:02] <svnbot6> r14179 | audreyt++ |   parameter or slurpy hash.

[19:02] <TimToady> *POST

[19:02] <svnbot6> r14179 | audreyt++ |     sub f () {...}

[19:02] <svnbot6> r14179 | audreyt++ |     f(y => 1); # used to bind silently, but now no more

[19:02] <gaal> fglock: Ann[otation] nodes decorate other Exps with stuff like context, position, and pragma

[19:02] <gaal> fglock: this is no longer how it works in newVal though.

[19:03] <gaal> also, in newVal there are two application nodes:

[19:03] <integral> hmm, it's my Pugs.CodeGen.PIR.Prelude that's doing it; it's an empty file

[19:03] <gaal> ...three, actually..

[19:04] <gaal> data ExpControl = CCall        ID     ExpCapt

[19:04] <TreyHarris> TimToady: yes... you presaged me :)  i have a 90%-finished proposal to normalize C<but>, C<is copy>, DBC "old", and cloning... I'll p6-l in the next couple days.  I just wanted to be sure you didn't already have a clear direction that just hadn't been committed to synopses yet.

[19:04] <gaal>   | CCallDyn     Exp    ExpCapt

[19:04] <gaal>    | CApply       Exp    ExpCapt

[19:04] *** mdiep joined
[19:04] <gaal> (sorry for the messy indent)

[19:04] <gaal> this is commented in src/Pugs/Val/Code.hs

[19:04] <TimToady> I would love some cognitive help.

[19:05] <TimToady> (I need all the cognitive help I can get...)

[19:05] <fglock> gaal: looking

[19:05] <gaal> fglock: the idea being that if you have { some code }.(), there shouldn't be much lookup, just direct invocation

[19:05] <svnbot6> r14180 | audreyt++ | * t/blocks/multi_named_vs_pos.t: unTODO several test, and mark

[19:05] <svnbot6> r14180 | audreyt++ |   the rest :todo<unspecced>.  The unspecced part is:

[19:05] <svnbot6> r14180 | audreyt++ |     multi f ($x)  { 1 }

[19:05] <svnbot6> r14180 | audreyt++ |     multi f (:$x is mandatory) { 2 }

[19:05] <svnbot6> r14180 | audreyt++ |     f('foo');         # binds to 1

[19:05] <svnbot6> r14180 | audreyt++ |     f(x => 'foo');    # binds to 2

[19:05] <svnbot6> r14180 | audreyt++ |   IMHO it's okay to have one shadow the other here, but the

[19:05] <svnbot6> r14180 | audreyt++ |   test says otherwise...

[19:07] <rodi> Good G-d Almighty, audreyt is on a tear.  I'm in awe.  audreyt++

[19:07] <TreyHarris> TimToady: one thing that would help me finish the last 10% is to know how you were thinking that a class would go about defining a value type.  I can see ways reading between the lines (er, ^LINES?), but particularly wondered whether you'd be okay with a declarative ("i can ask that class/object if it's a value") rather than a behavioral ("if this object's .WHAT matches that object's .WHAT, then they're the same object/value") approach.

[19:07] <TreyHarris> erm... that was kind of muddled

[19:07] <fglock> "Maybe Param" means "Param" is optional?

[19:07] <gaal> fglock: yes

[19:08] <gaal> it's like a pointer in c, it's allowed to be NULL.

[19:08] <TimToady> certainly it should at least look declarative

[19:08] <gaal> without the Maybe, Haskell's type system guarantees you can't have NULL there.

[19:08] <TimToady> if only by calling .HOW stuff at compile time

[19:08] *** Aankh|Clone joined
[19:09] <TreyHarris> TimToady: yepyep

[19:09] <gaal> integral: do you have DrIFT set up for pugs?

[19:10] <integral> gaal: hmm,  probably not, or if I did it was ages ago

[19:10] <integral> (and maybe with a previous GHC version even)

[19:10] <gaal> integral: I'm wondering how you ended up with a zero InstESCdd oh, you said Prelude, not Instances

[19:11] <TimToady> now smoking r14180

[19:12] <TimToady> eta 45 min

[19:12] <integral> hmm, what should the "inline_prelude_source" config var be?

[19:13] <gaal> obsoleted :)

[19:13] <integral> ah, that's why it's unmentioned in the template :-)

[19:14] <integral> what's the difference between Pugs/CodeGen/PIR/Prelude.hs and Pugs/Prelude.hs?

[19:14] <gaal> it's from a year ago when we didn't have precompiled prelude, and wanted the pugs binary to embed the Prelude.pm source

[19:14] <gaal> (it=="inline_prelude_source")

[19:14] <integral> (the latter's fine, the former's the problem).   Maybe my parrot's broken?

[19:14] <svnbot6> r14181 | audreyt++ | * currying.t: unTODO the passing test that tests you can't

[19:14] <svnbot6> r14181 | audreyt++ |   curry a nonexisting named param, and remove the one test

[19:15] <svnbot6> r14181 | audreyt++ |   that says .currying takes named arguments only, as the spec

[19:15] <svnbot6> r14181 | audreyt++ |   no longer says that.

[19:15] <integral> ugh, I've just realised that I hadn't setup PUGS_EMBED correctly

[19:16] <gaal> I don't see how that can cause that, actually. Makefile.PL:602

[19:16] <gaal> should Just Work

[19:17] <gaal> it's a simple templating thing, doesn't depend on parrot or embedding

[19:17] <fglock> clkao: ping

[19:17] <integral> hmm, yes

[19:18] <gaal> I'm guessing that you interrupted gen_prelude once before it produced any output

[19:18] <gaal> and then the makefile rule never regenned it

[19:18] <clkao> fglock hi

[19:18] * integral has just removed it again, and seen make regenerate it, but it's still empty!

[19:19] <gaal> right, come to think of it make_clean does rm it

[19:19] <integral> hmm, it's running "src/gen_prelude Pugs.CodeGen.PIR.Prelude < src/perl6/Prelude/PIR.pm > src/Pugs/CodeGen/PIR/Prelude.hs" which isn't producing any errors but it leaving the .hs file empty

[19:19] <fglock> clkao: did you see this problem with Data::Bind and perl5 references? http://sial.org/pbot/20232

[19:19] <lambdabot> Title: Paste #20232 from "fglock" at 200.17.89.80

[19:21] <gaal> integral: rm src/gen_prelude && make src/Pugs/CodeGen/PIR/Prelude.hs

[19:21] <integral> nope, still empty

[19:21] <svnbot6> r14182 | audreyt++ | * ext/DateTime/t/basic.t: unTODO everything.

[19:22] <gaal> echo "elkelkelk" | src/gen_prelude Moo

[19:22] <clkao> fglock: uhm.  don't have an idea out of my head. i will look into it lter

[19:22] <gaal> what does that give on stdout?

[19:22] <integral> nothing!

[19:22] <fglock> clkao: thanks

[19:22] <integral> maybe my GHC is badly broken :-/

[19:23] <gaal> it's a pretty straightforward .hs file!

[19:23] * integral comments out the source until it works

[19:23] <gaal> ghci src/gen_prelude.hs     ?

[19:25] <integral> gah, it's working now :-/

[19:26] <integral> I have absolutely no idea why it wasn't working before, unless clean misses it somehow

[19:26] <gaal> shouldn't.

[19:26] <gaal> lines 103, 107

[19:26] <gaal> of Makefile.PL

[19:26] <integral> *nod* oh well, it's all working now

[19:27] <gaal> vird.

[19:27] *** mdiep joined
[19:50] <buu> Who?

[19:50] <buu> Where?

[19:51] <buu> http://erxz.com/8002/

[19:51] <lambdabot> Title: Interactive Perl Shell

[19:51] <TreyHarris> whoops.  "make smoke" is *not* the same as "make smoke-upload"

[19:52] <integral> buu: it was andara (not here?) who was interested

[19:55] <fglock> what is the Snn for interpolation of Pair and Hash into lists?

[19:57] <fglock> pugs explodes %hash into %hash.kv, but $hash into $hash.pairs

[20:00] *** rindolf joined
[20:00] <rindolf> Hi all.

[20:00] <buu> haha

[20:00] <buu> integral: Someone made it unhappy =[

[20:01] <buu> integral: poco-simple-http has a really hilarious habit of dying when you access non mapped urls.

[20:01] <rindolf> ingy: you can upload IO::All now.

[20:03] <TimToady> fglock: a list interpolated %hash doesn't do .kv in pugs

[20:03] <buu> rindolf: Did you check out my shiny?

[20:03] <TimToady> and $hash should never interpolate into a list as anything other than a single item.

[20:04] <rindolf> buu: your shiny what?

[20:05] <fglock> ?eval my $p= a=>3; my %h = ( 1,2,$p ); %h.perl   # interpolates Pair.kv ?

[20:05] *** evalbot_r14098 is now known as evalbot_r14182

[20:05] <evalbot_r14182> "\{(\"1\" => 2), (\"a\" => 3)}"

[20:05] <integral> buu: surely adding some eval{}'s or catching the DIE signal would solve that?

[20:06] <TimToady> ?eval my %foo = :a(1), :b(2); say join " XXX ", %foo;

[20:06] <evalbot_r14182> OUTPUT[a	1 XXX b	2 ] Bool::True

[20:06] *** wilx joined
[20:07] <TimToady> that shouldn't interpolate $p as other than a hash object.  I don't think the assignment should unpack it either.

[20:07] <fglock> ?eval my %p = { a=>3, b=>4 }; my %h = ( 1,2,%p ); %h.perl  # interpolates %p.kv ?

[20:07] <evalbot_r14182> "\{(\"1\" => 2), (\"a\" => 3), (\"b\" => 4)}"

[20:08] <TimToady> nothing ever interpolate .kv by default

[20:08] <fglock> ?eval my $p = { a=>3, b=>4 }; my %h = ( 1,2,$p ); %h.perl  # different result if $p instead of %p ?

[20:09] <evalbot_r14182> "\{(\"1\" => 2), (\"a\\t3\" => (\"b\" => 4))}"

[20:09] <TimToady> ?eval my %p := { a=>3, b=>4 }; my %h = ( 1,2,%p ); %h.perl

[20:09] <evalbot_r14182> "\{(\"1\" => 2), (\"a\" => 3), (\"b\" => 4)}"

[20:09] <fglock> mine is the one with the tab :)

[20:09] <TimToady> ?eval my %p = ( a=>3, b=>4 ); my %h = ( 1,2,%p ); %h.perl

[20:09] <evalbot_r14182> "\{(\"1\" => 2), (\"a\" => 3), (\"b\" => 4)}"

[20:10] <TimToady> %p = {...} is a single key without a value.

[20:11] <buu> integral: Well, I needed to add a handler that would actually match

[20:11] <buu> Magic number checking on storable string failed at ../../lib/Storable.pm (autosplit into ../../lib/auto/Storable/thaw.al) line 366, at server.pl line 236

[20:11] <buu> How entertaining

[20:11] <fglock> ?eval my $p = { a=>3, b=>4 }; $p.WHAT

[20:11] <evalbot_r14182> ::Hash

[20:14] <rindolf> buu: your shiny what?

[20:15] <fglock> ?eval my %hash = ( a=>3, b=>4 ); my $scalar = { c=>5, d=>6 }; my %h = ( 1,2,%hash, $scalar ); %h.perl ~ %hash.WHAT ~ $scalar.WHAT

[20:15] <evalbot_r14182> "\{(\"1\" => 2), (\"a\" => 3), (\"b\" => 4), (\"c\\t5\" => (\"d\" => 6))}HashHash"

[20:16] <fglock> why does %hash interpolates different from $scalar ?

[20:16] <TimToady> because it has a % sigil

[20:16] <rindolf> TimToady: :-)

[20:16] <TimToady> use %$scalar

[20:17] <fglock> so it's a compile-time thing

[20:17] <TimToady> $ is a request to treat the thing as a single item, not as a complex item, even if it's complex underneath.

[20:18] <TimToady> it always takes something explicit to get at the parse, such as .{} or %

[20:18] <TimToady> *parts

[20:18] <fglock> actually looks ok in v6.pm - I thought it was a bug :)

[20:18] <buu> rindolf: erxz.com/8002/

[20:19] <fglock> TimToady: thanks

[20:19] *** ezraburgh joined
[20:19] <TimToady> {} and [] in list context also assume that they are there to produce a single item, since you could just omit the brackets to get the other behavior

[20:20] <fglock> my %hash = ( a=>3, b=>4 ); my $scalar = { c=>5, d=>6 }; my %h = ( 1,2,$%hash, $scalar ); %h.perl

[20:20] <fglock> ?eval my %hash = ( a=>3, b=>4 ); my $scalar = { c=>5, d=>6 }; my %h = ( 1,2,$%hash, $scalar ); %h.perl

[20:20] <evalbot_r14182> "\{(\"1\" => 2), (\"a\" => 3), (\"b\" => 4), (\"c\\t5\" => (\"d\" => 6))}"

[20:21] <fglock>  $%hash still goes into pairs

[20:21] <TimToady> %$, not $%

[20:21] <fglock> can't use $(..) to mean scalar context?

[20:23] <rindolf> buu: my $s = ""; for(my $u=0;$u<10;$u++){$s .= "$u\n"}$s; - I'm getting 0.

[20:23] <rindolf> buu: but nice.

[20:23] <TimToady> could be a buglet.

[20:24] <buu> rindolf: It's a bit of a bug with how I handle output.

[20:24] <buu> rindolf: The 0 was the first result.

[20:26] <rindolf> buu: I see.

[20:30] <demerphq> heh, i just realized i dont need a (?DEFINE:...)

[20:35] <demerphq> (?(?{0})...) does the same thing

[20:36] *** jferrero joined
[20:36] <svnbot6> r14183 | fglock++ | Pugs-Emitter-Perl6-Perl5 - added comments on Seq->Hash conversion

[20:37] *** mac93 joined
[20:42] *** larsen joined
[20:47] <TimToady> seems like (?:...){0} oughta work too

[20:50] <TimToady> for that matter, seems like (?(0)...) oughta work.

[20:51] <svnbot6> r14184 | fglock++ | Pugs-Emitter-Perl6-Perl5 - more comments on Seq->Hash conversion

[20:56] *** etzel joined
[20:57] <TimToady> ah well, it doesn't like (?(0)...)

[21:09] <rindolf> TimToady: has the smoke time been reduced eventually?

[21:10] <TimToady> it gained back the 20 minutes it lost a couple days ago.

[21:10] <TimToady> so I'm back to 48 or 49 minutes.

[21:15] *** mac93 joined
[21:23] <rindolf> TimToady: by "gained back" do you mean it now executes in *less* time?

[21:25] *** polettix joined
[21:26] *** fglock left
[21:33] <TimToady> it went from 48 to 68 minutes and back to 48.

[21:37] <rindolf> TimToady: I see.

[21:52] *** putter joined
[21:52] *** wilx joined
[21:55] <putter> S05 says "The \p and \P properties become intrinsic grammar rules such as (<alpha> and <!alpha>)."  Wouldn't that be better as "<-alpha>"?  Even if the \P association isn't intended, the sentence layout makes it rather strong.

[22:01] <camenix> quit

[22:01] *** camenix left
[22:06] <TimToady> yeah, <!alpha> is essentially a <!before <alpha>>

[22:11] *** Limbic_Region joined
[22:26] *** mako132 joined
[22:32] *** mac93 joined
[22:38] *** dduncan joined
[22:42] <putter> Can character property classes take an argument?   Eg, <+alpha_variant($only_on_tuesdays)-[q]> or somesuch.

[22:42] <TimToady> @tell audreyt my pugs-prof still segfaults even with a non-threaded perl :(

[22:42] <lambdabot> Consider it noted.

[22:42] <TimToady> in theory they could, but only in theory.

[22:43] * justatheory squirms uncomfortably

[22:43] <TimToady> lol

[22:47] *** cmarcelo joined
[22:54] *** polettix joined
[23:00] *** mako132 joined
[23:14] <clkao> ok, let me take a look at data::bind

[23:15] *** lollan joined
[23:22] <Limbic_Region> wow - 99.18% on latest smoke

[23:23] <clkao> whoot

[23:28] <Limbic_Region> @tell audreyt test 12 of ext/Config-Tiny/t/basic.t is failing though the output is correct.  My guess is difference of \n versus \r\n

[23:28] <lambdabot> Consider it noted.

[23:34] *** weinig joined
[23:39] *** demerphq joined
[23:42] <putter> <+<alpha>> is no longer valid, yes?   So the distinction between external and internal negation is gone, yes?  <-<alpha>> vs <+<-alpha>>

[23:42] <putter> is there any form of external negation?  ie, you have  <foo-bar+hee-qux> , can you negate that in any way other than going through and flipping all the signs?

[23:46] *** shobadobs joined
[23:47] <TimToady> <!foo-bar+hee-qux>

[23:47] <TimToady> but then you have to traverse the . yourself

[23:47] <TimToady> because ! turns it into lookahead

[23:47] <putter> with a trainling dot I assume... righ

[23:47] <putter> <+<alpha>> is gone?

[23:47] <TimToady> yes

[23:48] <putter> ok, will update tests.  thanks :)

[23:48] <TimToady> np

[23:48] <TimToady> biab &

[23:49] <clkao> audreyt: first failed test in perl5/array.t

[23:49] <clkao> is(eval(q{$retarray.elems}), @array.elems, 'retro elems');

[23:49] <clkao> why is $retarray suppose to have .elems ?

[23:50] <clkao> why is $retarray suppose to have .elems ?

[23:50] <clkao> gr, sorry

[23:50] <clkao> oh, nevermind. it's the object coming back again. misread

[23:52] *** bsb joined
