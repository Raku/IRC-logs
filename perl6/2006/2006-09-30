[00:01] *** Psyche^_ joined
[00:03] *** theorbtwo joined
[00:06] *** Psyche^__ joined
[00:09] *** Psyche^__ is now known as Patterner

[00:10] *** rashakil joined
[00:11] *** mjk joined
[00:12] *** Psyche^ joined
[00:17] <mjk> sshshushurshuru􏿽xCA􏿽xE4􏿽xC8􏿽xEBzzhzhozhonzhongzhongwzhongwezhongwen􏿽xD6􏿽xD0􏿽xCE􏿽xC4zzozonzongzongszongshzongshi􏿽xD7􏿽xDC􏿽xCA􏿽xC7zzhzhezheyzheyazheyanzheyang􏿽xD5􏿽xE2􏿽xD1􏿽xF9,

[00:17] <mjk> sshshi􏿽xCA􏿽xC7sshsheshemsheshenshenmʲôyyuyuayuanyuanyyuanyiyuanyinԭ􏿽xD2􏿽xF2 ?

[00:18] *** Psyche^ is now known as Patterner

[00:22] *** mjk joined
[00:26] *** rodi joined
[00:36] *** Aankhen`` joined
[00:48] <pasteling> "TimToady" at 64.0.7.8 pasted "bad dispatch at #XXX from yaml data, doesn't notice missing class defs!!!" (51 lines, 1K) at http://sial.org/pbot/20064

[00:48] <TimToady> audreyt: see previous

[00:49] <TimToady> the Container has a list of kids, but when I call $kid.visit() it ends up calling the parent's visit method, albeit with the kid as invocant.

[00:51] <TimToady> I wonder if eval(:lang<yaml>) is defaulting to the last dispatcher class it saw.  The bogus classes are properly named via .WHAT, but dispatch to Container despite not being derived from Container in any way.

[00:52] <TimToady> anyway, I was tearing my hair out trying to understand how Perl 6 was reading my mind and installing derivations for me.  :)

[00:53] <wolverian> is the syntax for defining coercion for your class specced?

[00:53] *** SubStack joined
[00:56] <TimToady> huh?

[00:58] <wolverian> I meant to ask: how do I declare that my class Foo should coerce to True in boolean context?

[00:59] <audreyt> TimToady: methods were installed as subs and valid as failover

[00:59] <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.

[01:00] <TimToady> even when explicitly smd with extra arg?

[01:00] <audreyt> the sub/method distinct dispatch system will be swapped in

[01:00] <audreyt> the thing is in the sub failover case

[01:01] <audreyt> it shouldn't even see methods in scope

[01:01] <TimToady> but even with MMD failover, it should have tied between Leaf::visit and Container:visit

[01:01] <audreyt> those become totally irrelevant

[01:01] <audreyt> since it should only consider subs at that point

[01:01] <audreyt> let me see if there's a simple fix...

[01:02] <TimToady> but even without the failover it's calling the wrong visit on the first Item.

[01:03] <TimToady> because Item is explicitly derived from Leaf.

[01:07] <TimToady> wolverian: something like method true () is deeply { Bool::True }

[01:08] <wolverian> hm. how about saying it's 5 in numeric context? am I right in thinking they're the same class of behaviour?

[01:10] <TimToady> maybe it's multi Bool (MyType $x) { Bool::True }

[01:11] <TimToady> and multi Num (MyType $x) { 5 }

[01:11] <TimToady> with maybe some "is deeply"s thrown in there

[01:12] <wolverian> multi context (MyType $x --> Num) { 5 } # heh

[01:12] <wolverian> anyway, thanks :)

[01:12] <TimToady> yeah, that's maybe a different approach to "is deeply"

[01:20] <TimToady> my Foo $x = context($y);  # explicitly do some coercion implicitly :)

[01:20] <TimToady> my Foo $x = force($y);

[01:20] <TimToady> my Foo $x = dwim($y)

[01:20] <TimToady> my Foo $x = *($y)

[01:21] <TimToady> multi * (MyType $x --> Num) { 5 }

[01:21] <TimToady> that's almost cool.

[01:24] <TimToady> decommutationalizing &

[01:31] <audreyt> TimToady: the dispatch bug is fixed

[01:31] <clkao> hi audreyt

[01:33] <clkao> audreyt: will be in pdx 21-26

[01:33] <audreyt> greetings

[01:35] <audreyt> cool!

[01:44] *** svnbot6 joined
[01:44] <TimToady> yay

[02:02] <audreyt> and even tested :)

[02:04] <svnbot6> r13739 | audreyt++ | * t/oo/inheritance.t: Add test case for the dispatch bug

[02:04] <svnbot6> r13739 | audreyt++ |   found by TimToady++.

[02:06] *** snowstalker joined
[02:08] <snowstalker> Hi, Can you please tell me how long it takes to build pugs? I had started a build yesterday night (in my time zone) and it's been 7 hours and it's still going on... :/

[02:09] <Patterner> depends on your system...

[02:11] <snowstalker> Patterner, it's a 1.7 GHz machine.

[02:11] *** revision17_ joined
[02:11] <Patterner> i'll time mine and get back to you :)

[02:11] <snowstalker> Patterner, thanks :)

[02:12] <Patterner> 1 minute 35 seconds.

[02:13] <Patterner> (for svn update :)

[02:15] <snowstalker> Patterner, oh, I was referring to the 'make'

[02:15] <Patterner> i was joking :)

[02:15] <Patterner> "make" or "make fast"?

[02:15] <snowstalker> Patterner, hehe

[02:17] <snowstalker> Patterner, 'make'

[02:17] <snowstalker> Patterner, Should I try 'make fast' instead?

[02:17] <Patterner> it depends. personally i would like to know how many hours make would take. Do you need it compiled right now?

[02:18] <Patterner> (even "make fast" takes some time)

[02:20] <snowstalker> Patterner, no, I don't have any time constraints, just wanted to spend some time learning Perl 6 this weekend :)

[02:20] <snowstalker> but if I start 'make', it takes over the whole system and the computer is unusable for me.

[02:22] <Patterner> install more RAM

[02:23] <snowstalker> Patterner, yeah, I guess I'll have to do that some time

[02:24] <Patterner> GHC needs more than 640KB :)

[02:29] <mjk> audreyt:can you move to #perlchina channel, i have a question to learn from you

[02:29] <audreyt> mjk: sure I can but, I need to run for a while

[02:30] <audreyt> please type away

[02:30] <audreyt> bbl

[02:30] <mjk> audreyt:i wait you

[02:41] <audreyt> mjk: mail question to audreyt at audreyt dot net = easier

[02:48] <Patterner> snowstalker: 26 minutes 23 seconds for "make"

[02:48] <Patterner> 7 hours is far too long for 1.7GHz...

[02:48] <mjk> audreyt:thanks, i will email to you

[02:50] *** mauke_ joined
[02:54] *** hikozaemon joined
[02:54] <snowstalker> Patterner, hmm, I don't know what's wrong, perhaps I can try make fast

[03:00] <mjk> audreyt:i have email my question to [email@hidden.address]
[03:01] <mjk> audreyt:thank you very much!

[03:05] *** mauke_ is now known as mauke

[03:08] <Khisanth> now for the torrent of spam :)

[03:10] *** lollan joined
[03:21] *** frederico joined
[03:51] *** Sal joined
[04:11] *** Salzh joined
[04:16] *** Salzh joined
[04:17] <snowstalker> Hello folks, is perlcabal.org down?

[04:18] <snowstalker> (trying to look up http://www.perlcabal.org/syn/S02.html)

[04:18] <lambdabot> Title: S02

[04:37] <Patterner> IT'S ALIVE!

[05:15] *** BooK__ joined
[05:16] *** rashakil_ joined
[05:37] *** shobadobs joined
[05:44] *** norageek joined
[05:55] *** avar joined
[06:09] *** ^^MAg^^ joined
[06:09] *** ^^MAg^^ left
[06:26] *** evil3y3 joined
[06:51] *** norageek joined
[07:04] *** penk joined
[07:06] *** masak joined
[07:47] *** mj41_ joined
[07:55] <audreyt> @seen TimToady

[07:55] <lambdabot> TimToady is in #perl6. I last heard TimToady speak 6h 11m 15s ago.

[07:56] <audreyt> @tell TimToady I implemented << 'foo' "bar" >> by reparsing 'foo' and "bar" as separate literals; I wonder if we should generally allow all undecorated quote forms inside :ww, that is << `foo` <bar> <<baz>> >> should be legal

[07:56] <lambdabot> Consider it noted.

[08:06] *** iblechbot joined
[08:08] *** Psyche^ joined
[08:08] <audreyt> @tell TimToady also, should << foo'$bar'baz >> be one element?

[08:08] <lambdabot> Consider it noted.

[08:13] *** shobadobs_ joined
[08:14] *** Psyche^ is now known as Patterner

[08:18] *** mdiep_ joined
[08:22] *** xerox joined
[08:25] <TimToady> audreyt: I'm more inclined to try to keep the insides of <<...>> as close as possible to shell quoting so that it's easier to write portable "shell" scripts even on Windows and such.

[08:25] <lambdabot> TimToady: You have 2 new messages. '/msg lambdabot @messages' to read them.

[08:27] <TimToady> back to zzz &

[08:34] *** marmic joined
[08:35] *** crem joined
[08:42] *** mjk joined
[08:45] <audreyt> TimToady: hm, but

[08:45] <audreyt> << "@x[]" >>

[08:45] <audreyt> interpolates @x, which is not in shell

[08:46] <audreyt> but ok, I'll admit only "" and '' in q:ww for now

[08:46] <audreyt> (though `` may be useful there... not sure)

[08:46] <audreyt> also, << :!foo >> parsing as a Pair is troubling me

[08:46] <audreyt> I think

[08:46] <audreyt> enum << :Mon(1) Tue Wed >>

[08:47] <audreyt> is better written as

[08:47] <audreyt> enum :Mon(1), << Tue Wed >>

[08:48] *** idiotmax joined
[08:54] <audreyt> @tell agentzh all of operators/quoting.t now passes except for pair inside <<>> -- I don't feel comfortable with that feature, so will discuss more beore impl

[08:54] <lambdabot> Consider it noted.

[08:58] *** weinig_ joined
[09:09] *** buetow joined
[09:21] <svnbot6> r13740 | audreyt++ | * Much improved quoting handling:

[09:21] <svnbot6> r13740 | audreyt++ |   (t/operators/quoting.t all passes except for :p inside <<>>)

[09:21] <svnbot6> r13740 | audreyt++ |   - <<'$foo'>> now never interpolates '$foo'.

[09:21] <svnbot6> r13740 | audreyt++ |   - <<"$bar">> now never splits $bar.

[09:21] <svnbot6> r13740 | audreyt++ |   - <<$baz>> now splits $baz, but respects non-breaking space as non-breaking.

[09:21] <svnbot6> r13740 | audreyt++ |   - q:to/END/ heredocs is now parsed properly.

[09:22] *** lichtkind joined
[09:24] <svnbot6> r13741 | audreyt++ | * Massive cleanup: qw() and q() is no longer quotes but functions,

[09:24] <svnbot6> r13741 | audreyt++ |   and q:to/END/ is now expression-level construct.

[09:24] <svnbot6> r13742 | audreyt++ | * earendil_translations: update version number.

[09:24] <svnbot6> r13743 | audreyt++ | * Pugs.Parser.Program: If the incoming source code did not

[09:24] <svnbot6> r13743 | audreyt++ |   end with "\n", append one for it anyway.

[09:27] <svnbot6> r13744 | audreyt++ | * In m:g/(1)|(2)/, only return the successfully matched subcaptures,

[09:27] <svnbot6> r13744 | audreyt++ |   not the unsuccessful ones.  This is such that "1212" matched against

[09:27] <svnbot6> r13744 | audreyt++ |   the regex will evaluate to ('1', '2', '1', '2'), instead of

[09:27] <svnbot6> r13744 | audreyt++ |   ('1', '', '', '2', '1', '', '', '2').

[09:27] <svnbot6> r13745 | audreyt++ | * Nuke t/pil/.  The PIL swap-in as the new AST will use MO/Moose's

[09:27] <svnbot6> r13745 | audreyt++ |   bootstrap code (which is the nth logical successor to src/PIL/),

[09:27] <svnbot6> r13745 | audreyt++ |   not the 0th prototype.

[09:28] <svnbot6> r13746 | audreyt++ | * Detect hsc2hs a bit more correctly.

[09:43] *** yts joined
[10:08] *** chris2 joined
[10:21] *** penk joined
[10:32] *** count_leto joined
[10:32] <count_leto> hi :)

[10:45] *** jiing joined
[10:48] *** Southen joined
[11:01] *** jferrero joined
[11:05] <masak> audreyt: am I interpreting the change in r13741 correctly as qw() and q() no longer being quoting constructs?

[11:09] <masak> is there a rationale preceding that change? (just curious)

[11:18] *** tretboot joined
[11:23] *** xinming__ joined
[11:35] *** tretboot left
[11:37] *** wilx joined
[11:49] *** chris2 joined
[11:52] *** elmex joined
[12:02] *** iblechbot joined
[12:38] <audreyt> masak: I don't quite feel strongly about that change

[12:38] <audreyt> in fact I find it mildly surprising coming rom p5

[12:38] <audreyt> but it's consistent.

[12:38] <masak> audreyt: I see

[12:38] <audreyt> I don't know of the rationale behind the S02 change

[12:39] <audreyt> running "svn praise S02"...

[12:39] <masak> audreyt: skimming the logs for a rationale, I discovered the probable reason for having been given an admin bit for pugs the other day :)

[12:39] <masak> and I also figured out what I'm supposed to do with it

[12:40] <audreyt> yeah, because you're around a lot :)

[12:40] <audreyt> cool!

[12:40] *** lisppaste3 joined
[12:41] <audreyt> r15371 (orig r9733):  larry | 2006-07-02 04:55:09 +0800

[12:41] <audreyt> Clarification of differences between quote and macro declarations, Markus++.

[12:41] <audreyt> apparently malaire++ is to blame

[12:41] <audreyt> I mean, to praise

[12:41] <masak> :)

[12:41] <audreyt> or to annotate

[12:42] <masak> *lol*

[12:42] <masak> I see. well, qw() is less needed now when we have <>

[12:42] <audreyt> indeed

[12:42] <masak> still, it is surprising to p5ers

[12:42] <audreyt> and a somewhat handy and well-implemented << >>

[12:42] <masak> is << >> to < > as "" is to ''?

[12:42] <audreyt> ?eval << a b 'c d {1+1}' "e f g {1+1}" >>

[12:43] *** evalbot_r13730 is now known as evalbot_r13746

[12:43] <evalbot_r13746> ("a", "b", "c d \{1+1}", "e f g 2")

[12:43] <audreyt> it's even more magickal

[12:43] <masak> oh, in what way?

[12:43] <audreyt> see the treatment of '' and "" above

[12:43] <audreyt> shellish quoting

[12:44] <masak> hm. not sure i grok the implications

[12:44] <audreyt> ?eval my $x = "two words"; << $x '$x' "$x" >>

[12:44] <evalbot_r13746> ("two", "words", "\$x", "two words")

[12:44] <masak> ah!

[12:44] * masak sees now

[12:44] <masak> I think

[12:44] <audreyt> you think correctly :)

[12:44] <audreyt> or rather, you thunk correctly

[12:46] <masak> so, I'd use "$x" within << >> when I don't want to split an interpolated string into several elements...

[12:46] <audreyt> exactly

[12:46] <audreyt> even more magically:

[12:46] <audreyt> ?eval my $x = "two words"; << !$x! !'$x'! !"$x"! >>

[12:46] <evalbot_r13746> ("!two", "words!", "!\$x!", "!two words!")

[12:47] <audreyt> as you can see it's very handy :)

[12:47] <masak> hm :)

[12:47] <masak> I can see how it's a nice feature, it's just that it's several layers of abstraction beyond what I use on a daily basis, so I'm in a bad spot to evaluate its use

[12:48] <masak> it's not like: "I know, a 'switch' is the perfect tool for this problem"

[12:49] <masak> for some reason, I can't see myself going: "hm, I need to interpolate this string within a << >> while still keeping it as one element" :)

[12:50] <audreyt> you don't do a lot of shell programming, do you :)

[12:50] <masak> well, no :)

[12:50] <masak> but that made me understand its use better

[12:50] <masak> I do some command-line hackery sometimes

[12:50] <masak> and quoting comes in there

[12:51] <masak> thanks for careful explanations

[12:51] <audreyt> no prob

[12:52] <masak> btw, somewhat OT-ly, I'm learning chinese this semester!

[12:52] <audreyt> for detailed rationale, ask TimToady++, I'm just this coding moneky... :)

[12:52] <audreyt> cool! @ uni?

[12:52] <masak> yes

[12:52] <audreyt> as a foriegn language course?

[12:53] <masak> @tell larry what is the rationale behind removing qw() as a quoting construct? (just curious)

[12:53] <lambdabot> Consider it noted.

[12:53] <masak> audreyt: yes. I started a few weeks ago

[12:53] <masak> we've been crammed full of grammar and history so far

[12:53] <masak> first chapter this Wednesday, four weeks into the course

[12:53] <audreyt> oy. you don't want to learn grammar-first...

[12:54] <masak> well, opinions diverge there

[12:54] <masak> I kinda like it, being grammar-oriented

[12:54] <audreyt> *nod* it makes sense if you're going to use mostly written chinese

[12:54] <masak> it prepares me for seeing the patterns IRL later

[12:54] <masak> I'm hoping to use both a lot

[12:54] <audreyt> excellent

[12:55] <masak> chinese is the first language that makes good on its promise of being hard

[12:55] <masak> well, that and haskell :)

[12:56] <masak> I'm sort of a little scared after reading this... http://pinyin.info/readings/texts/moser.html

[12:56] <lambdabot> Title: Why Chinese Is So Damn Hard

[12:57] <audreyt> ooh, is this moser who I think he is?

[12:57] <audreyt> ...yes

[12:57] <masak> who is it?

[12:57] <masak> I haven't hear of him

[12:58] <audreyt> Douglas Hofstadter mentioned him a lot in Le Ton Beau De Marot

[12:58] <gaal> drh's pal?

[12:58] <gaal> heh

[12:58] <audreyt> one of my fav books

[12:58] *** ofer0 joined
[12:58] * masak checks the book out

[12:59] <audreyt> also "To Err Is Human: To Study Errors is Cognitive Science" and "This Is the Title of This Story, Which Is Also Found Several Times in the Story Itself"

[12:59] <masak> can't believe there's a hofstadter book I haven't heard about

[12:59] <masak> oh. the latter rings a bell

[12:59] <gaal> i believe he's also mentioned in metamagical themas. which is also pretty good.

[13:00] <masak> yes

[13:00] <xerox> What Hofstadter book?

[13:00] <audreyt> xerox: Le Ton Beau De Marot, aka the Chickadee book

[13:00] *** Salzh joined
[13:01] <pasteling> "masak" at 130.238.83.176 pasted "the best part, and the one that shook me the most, from "Why Chinese Is So Damn Hard"... I always wanted to be able to read the classics :/" (15 lines, 980B) at http://sial.org/pbot/20074

[13:01] *** ludan joined
[13:01] <gaal> "A passage in classical Chinese can be understood only if you

[13:01] <gaal> already know what the passage says in the first place"

[13:01] <gaal> hey, that sounds like unix man pages!

[13:02] <xerox> O_o

[13:02] <audreyt> hrm

[13:02] <audreyt> that's not quite true...

[13:02] * masak exhales

[13:02] <audreyt> it's true that to understand all interpretations of it you need a lot of context

[13:02] <masak> of course

[13:02] <masak> as with all old texts

[13:03] <audreyt> but if you just want to have a gestalt idea, especially if it's literature work, then it just takes liberal imagination

[13:03] <masak> cool! I have that

[13:03] <audreyt> because The Author Is Dead (for centuries), that approach is not only more fruitful, sometimes it's the only sane approach :)

[13:04] <masak> right

[13:04] * masak pushes on with the character studies with new hope

[13:04] <masak> I've memorised maybe 20 so far...

[13:04] <audreyt> 1k will get you very far

[13:04] <masak> they already feel like friends

[13:04] <audreyt> e.g. newspapers, etc

[13:05] <masak> I'd like to get to know the radicals really well, tho'

[13:05] <masak> thinking of making a nice desktop background with all radicals and their meaning

[13:06] <masak> audreyt: I've heard people claiming the opposite lately. Moser, for one

[13:06] <masak> he says that the more uncommon characters are the one's which are often most important in a text

[13:06] <audreyt> all, as in nearly 200?

[13:06] <masak> yes

[13:06] <audreyt> that is correct

[13:06] <masak> should be able to fit that on-screen, I think

[13:06] <audreyt> as with english, less frequent words are keywords

[13:06] <masak> while not making it too cluttered

[13:07] <audreyt> good news is you just need to look a few of them up from a dictionary :)

[13:07] <masak> audreyt: and besides, it's the combinations of characters that is more important

[13:07] <audreyt> and they are the least ambiguous

[13:07] <masak> and there are very many combinations...

[13:07] <audreyt> unlikes common words, which form one-char phrases

[13:07] <audreyt> and can have dozens of context-dependent meanings...

[13:08] <masak> audreyt: true. I'm still quite hopeful, and looking forward to when I can pick up a newspaper in chinese and read some of it

[13:08] <audreyt> multichar phrases almost always have specific meanings that can easily be looked up

[13:08] <masak> another article says there's a real need for a change in chinese wordbook paradigms

[13:08] <masak> sec

[13:08] <gaal> there's no marking that a phrase is multichare though, is there?

[13:09] <gaal> that is, lexing is hard

[13:09] <audreyt> no but you can ues my Lingua::Zh::Toke...

[13:09] <masak> http://www.sino-platonic.org/abstracts/spp001_chinese_dictionaries.html

[13:09] <audreyt> which features overloading of @{} %{} <> etc

[13:09] <audreyt> %{} is histogram iirc ;)

[13:10] * masak just found a treasure trove of modules in the Lingua::Zh namespace

[13:11] <masak> cool

[13:11] <lambdabot> Title: Chinese dictionary review, http://tinyurl.com/api-create.php?url=http://www.sino-platonic.org/abstracts/spp001_chinese_dictionaries.html"></HEAD><BODY>

[13:11] <audreyt> Encode::HanConvert is one of my more popular modules :)

[13:12] <masak> audreyt: I'll have a look :)

[13:14] <masak> audreyt: when you answer "test triaging" in response to "what can be done to help along with the next pugs release?", what does that mean? besides running the tests on the last rev of pugs, I mean

[13:15] <audreyt> it means look at smoke matrix

[13:15] <audreyt> in particular the failures

[13:16] <pasteling> "audreyt" at 220.135.90.73 pasted "triage targets" (82 lines, 4.2K) at http://sial.org/pbot/20075

[13:16] <audreyt> I'm moving from bottom up

[13:16] <audreyt> so pick a point and move down

[13:16] <masak> :)

[13:16] <masak> gladly

[13:17] <audreyt> woot

[13:17] <audreyt> if the error is at the end

[13:17] <audreyt> likely nonregressions

[13:17] <audreyt> then simply :todo<feature> them as needed

[13:17] <masak> right

[13:17] <masak> can do

[13:17] <audreyt> if they are regressions, try to find out if they are not buggy tests

[13:17] <audreyt> and if so fix the tests :)

[13:17] <audreyt> s/not/actually/

[13:18] <masak> oki

[13:22] *** zakharyas joined
[13:30] <audreyt> hm

[13:30] <audreyt> @a[0] := $x

[13:31] <lambdabot> Unknown command, try @list

[13:31] <audreyt> the lhs of := is not valid Signature expression, is it?

[13:31] * audreyt ponders how to reconcile this

[13:32] <audreyt> easiest way: allow that in a signature ;)

[13:32] <audreyt> sub f (@a[0], @a[1]) { ... }

[13:32] <audreyt> maybe insane...

[13:32] <masak> when would one want to use that?

[13:32] <audreyt> when creating views, presumably

[13:33] <masak> fair enough

[13:33] <audreyt> maybe not worth keeping

[13:33] <audreyt> none of the spec text uses this form

[13:33] <audreyt> marking as unspecced.

[13:35] <masak> there should be a tool for mapping test numbers to the corresponding lines in the test file

[13:36] <TimToady> @messages

[13:36] <lambdabot> audreyt said 5h 39m 37s ago: I implemented << 'foo' "bar" >> by reparsing 'foo' and "bar" as separate literals; I wonder if we should generally allow all undecorated quote forms inside :ww, that is <

[13:36] <lambdabot> < `foo` <bar> <<baz>> >> should be legal

[13:36] <lambdabot> audreyt said 5h 27m 49s ago: also, should << foo'$bar'baz >> be one element?

[13:37] <masak> TimToady: ...and I accidentally gave someone whose nick was "larry" the following message, meant for you:

[13:37] <masak> "what is the rationale behind removing qw() as a quoting construct? (just curious)"

[13:39] <TimToady> it's ugly, it doesn't compose like <...>, and we didn't remove it.

[13:39] <masak> :)

[13:39] <TimToady> qw// still works, as does qw ()

[13:40] <masak> but not qw()?

[13:40] <TimToady> but qw() itself looks like a function call, so that's what it is.

[13:40] <masak> I always thought of it as a function call

[13:40] <SamB> so, since ;-) looks like a smiley face, is it one of those too?

[13:40] <masak> only that qw is a special kind of function

[13:40] <TimToady> sure is.  just not in Perl

[13:41] <masak> TimToady: but I'm not really complaining about the change... I think it's good once one gets past the p5 discrepancy of it

[13:41] <TimToady> one could say that about a lot of thins. :)

[13:42] <TimToady> our goal is to surprise p5 programmers on a surface level and delight them on a deeper level.

[13:42] <SamB> but not about Py2k, IMO...

[13:43] * SamB does not like Guido's attitude towards FP

[13:43] <TimToady> well, gotta run, and don't know if I'll have connectivity for the next N hours...

[13:43] <masak> TimToady: as for me, I'm delighted on the deeper level. thx

[13:44] <TimToady> (taking Lewis to a quiz meet at an unfamiliar church, so don't know if they have wireless...)

[13:44] <TimToady> yw!

[13:44] <TimToady> afk &

[13:57] <pasteling> "masak" at 130.238.83.176 pasted "what's the test output supposed to look like? I get the this after putting a "force_todo 7 .. 12" in the beginning of the test file, is that normal?" (17 lines, 913B) at http://sial.org/pbot/20076

[14:00] <audreyt> no... you need to try{} a fatal error

[14:03] <masak> oh, ok

[14:04] <masak> the whole block, or just that line?

[14:05] <ajs_home> One more question about bareword constants like pi... how do they behave inside :adverb<pi> ?

[14:06] <masak> is there a common practice for making sure the planned number of tests are run even if the try exits prematurely?

[14:06] <audreyt> try should't exit...

[14:07] <audreyt> if it's parsefail then use eval

[14:07] <audreyt> ajs_home: constants are just functions

[14:08] <masak> audreyt: it's not a parsefail, it's a runtime error

[14:08] *** mako132_ joined
[14:08] <masak> I'm about to commit putting a try on the line with the assignment, that at least clears things up more than before...

[14:09] *** Limbic_Region joined
[14:09] <ajs_home> audreyt: Right, so it would have to be :adverb<pi()> ?

[14:09] <ajs_home> or :adverb<true()>

[14:11] <svnbot6> r13747 | masak++ | [t/data_types/array_extending.t]

[14:11] <svnbot6> r13747 | masak++ | * put a try block around an assignment which blew the test file out of the water

[14:12] <audreyt> ajs_home: :adverb(pi)

[14:12] <audreyt> <> wouldn't work

[14:12] <ajs_home> Ah right

[14:12] <ajs_home> forgot () worked on adverbs entirely

[14:12] <ajs_home> thanks, I feel better

[14:12] <audreyt> Glad to provide you with potion of healing

[14:13] <audreyt> t/operators/ triaged. bbiab...

[14:14] <ajs_home> Is Bool::True the canonical truth for code examples? If I need to show a Bool adverb being called, should I write ":terror(Bool::True)" or is there some "true" type thing?

[14:14] <svnbot6> r13748 | lanny++ | * Bring t/unspecced/sort.t into line with latest S29

[14:16] <SamB> ?eval 1 < 2

[14:16] <evalbot_r13746> Bool::True

[14:16] <audreyt> ajs_home: :terror is sufficient

[14:16] <audreyt> :terror(True) is okay

[14:16] *** bradb joined
[14:16] <audreyt> but you really just want :terror

[14:16] <audreyt> use :!terror for the False case

[14:16] <ajs_home> Oh nice. Thanks.

[14:17] *** lanny joined
[14:17] *** loumz joined
[14:18] <lanny> @tell agentzh Smoke Syns are acting up again.  :/

[14:18] <lambdabot> Consider it noted.

[14:18] <ajs_home> That will make the Unicode normalization examples much easier, since there are essentially two boolean parameters, though the Unicode documentation insists on calling it four different functions :(

[14:20] <masak> ?eval my @array = <a b c>; my $arglist = try { \(@array) }; my sub foo (@arr) { ~@arr }; try { &foo.call($arglist) }

[14:20] *** evalbot_r13746 is now known as evalbot_r13748

[14:20] <evalbot_r13748> undef

[14:20] <masak> yes, that's what the test becomes, too :(

[14:20] * masak marks it as :todo<feature>

[14:21] <masak> though I have no proof that it's not really a regression

[14:21] <masak> it's subtest 5 out of 18, but many of the others are marked :todo<feature>

[14:23] <lanny> Didn't that one get reworked  with the Capture |  ?  &foo.call(|$arglist);

[14:23] <lanny> Looking it up

[14:23] <audreyt> &foo.call($arglist) is canonical

[14:24] <audreyt> as .call takes the unflattened Capture

[14:24] <audreyt> :todo<feature> is also correct.

[14:25] <masak> ?eval my $ref = { val => 42 }; say $ref[0] # should die trying to access the hash as an array, but doesn't

[14:25] <evalbot_r13748> OUTPUT[val42 ] Bool::True

[14:25] <lanny> aha.  Found the S02 was gonna hit S06 next.  @audreyt is easier.

[14:25] <masak> leaving that test in place, failing, because it's likely a regression

[14:26] *** foo\ joined
[14:26] <audreyt> *nod*

[14:28] <masak> ?eval my $foo = 42; ($foo, "does_not_matter")[0] =:= $foo # should be Bool::True, but isn't

[14:28] <evalbot_r13748> Bool::False

[14:28] <masak> maybe this is the time for me to finally learn enough Haskell to hunt those bugs down...

[14:28] <masak> it sure is tempting

[14:29] <audreyt> I'd be thrilled to help!

[14:29] <audreyt> er, the [0] =:= thing.

[14:29] <audreyt> it's currently not clear that you can := into [0]

[14:29] <audreyt> it's unspecced and of dubious usefulness

[14:30] <audreyt> so all =:= involving subscripts is :todo<unspecced>

[14:30] <masak> gotcha

[14:30] <masak> marking it as such

[14:35] <masak> ?eval my $pair = :when<now>; (%$pair).does(Hash) # should be Bool::True, but pugs says Bool::False (or parsefails on the command line)

[14:35] <evalbot_r13748> Bool::False

[14:35] <lanny> ?eval ((1,2),(3,4))

[14:35] <evalbot_r13748> (1, 2, 3, 4)

[14:35] <lanny> ?eval zip(1,2;3,4)

[14:35] <evalbot_r13748> ((1, 2, 3, 4),)

[14:35] <masak> evalbot_r13748: ah, the parsefail was me -- I forgot to escape the % from within vim

[14:36] <masak> I really shouldn't be talking with bots

[14:36] <Juerd> Good afternoon

[14:36] <masak> hiya

[14:37] <lanny> ?eval my @a = (1,2); my @b = (3,4); zip(@a;@b)

[14:37] <evalbot_r13748> ((1, 3), (2, 4))

[14:37] <Juerd> I went to a party last night. There are always a few software developers. I told someone about Perl 6.

[14:37] <lanny> ?eval zip((1,2);(3,4))

[14:37] <evalbot_r13748> ((1, 3), (2, 4))

[14:37] <Juerd> "Huh, how can you improve a switch statement? It's already perfect."

[14:37] <Juerd> So I showed examples of given/when.

[14:37] <Juerd> "Whoa - that's pretty cool!"

[14:38] <lanny> Is there any way to build a list of lists without having them flatten using literals?

[14:38] <Juerd> It can be amazing how people are used so to living with a lot of limitations that they can't even come up with this (to me, rather logical and obvious) stuff themselves :)

[14:38] <Juerd> lanny: A list of ... lists? Why not arrays?

[14:39] <lanny> Just trying to match the output of zip.

[14:39] <Juerd> Match?

[14:39] <lanny> I guess I could use zip but that would be silly to test  something against it's own call.  lists/zip.t has a buggy test.  Trying to fix it.

[14:39] <svnbot6> r13749 | masak++ | [t/data_types/lists.t]

[14:39] <svnbot6> r13749 | masak++ | * marked to tests as :todo<unspecced>

[14:39] <svnbot6> r13749 | masak++ | [t/data_types/capture.t]

[14:39] <svnbot6> r13749 | masak++ | * marked one test as :todo<feature>

[14:39] <svnbot6> r13749 | masak++ | * now done triaging t/data_types, moving on to t/examples

[14:40] <Juerd> I'm not sure I know what a "list" is, really.

[14:40] <Juerd> I know:

[14:40] <lanny> ?eval zip((1,2);(3,4))

[14:40] <evalbot_r13748> ((1, 3), (2, 4))

[14:40] <Juerd> * lists - whatever is in list context

[14:40] <Juerd> * feeds

[14:40] <Juerd> * arrays

[14:40] <Limbic_Region> Juerd - not so amazing to me.  Humans want familiarity - it makes them feel safe.  In any browser, OS, editor war - the side someone is fighting for has plenty of problems but the person fighting for it has become used to them and no longer notices them.  IOW - best to live with known evils.

[14:41] <lanny> No.  For instance list(1) says 1 is in list context but it's not a list.

[14:41] <Juerd> I don't get how ((1,3),(2,4)) is possible, as that flattens to one list...

[14:41] <lanny> It's the result of a zip()

[14:41] <lanny> I thought it should flatten too but Pugs seems perfectly happy carrying it around as a result.

[14:41] <Juerd> I thought ((1,3),(2,4)) is (1,3,2,4) in list context, and [[1,3],[2,4]] in item context.

[14:41] <lanny> If I assign it to something I'll bet it flattens

[14:42] <Juerd> So I can't really think of what nested parens would mean here.

[14:43] <lanny> ?eval my @a=(0,4); my @b=(2,6); my @c=(1,3,5,7); my @z = zip(zip(@a;@b);@c); @z

[14:43] <evalbot_r13748> [((0, 2), 1), ((4, 6), 3), (undef, 5), (undef, 7)]

[14:43] <lanny> So  not flattening

[14:43] <Juerd> I see that it does that, but I don't know how to read it.

[14:44] <Juerd> Or how it would make universal sense.

[14:44] <lanny> Well lists and arrays are different now.  So this is a situation where  you are able to stuff a list of list in another container before it flattens

[14:44] <lanny> It makes perfect sense since zip returns list-tuples as its result.

[14:45] <Juerd> Lists and arrays were different in Perl 5, but there a list could only be in list context. Something not in list context wouldn't be a list.

[14:45] <Limbic_Region> audreyt ping

[14:45] <Juerd> How do you create a list then? Surely the syntax evalbot outputs can't be it, as that would flatten in list context, and create arrays in item context.

[14:45] <Limbic_Region> I go to Java class for 4 days and Win32 pugs goes to hell in a handbasket

[14:45] <Juerd> Or am I wrong about that?

[14:46] <Juerd> Limbic_Region: That should teach you.

[14:46] <Limbic_Region> . o O ( he says very jokingly )

[14:46] <lanny> So I don't know if it's Perl 6 but Pugs has no problem keeping them (Lists of lists) around

[14:46] <Limbic_Region> it is however not working on Win32

[14:46] <Juerd> lanny: I see that.

[14:46] <Juerd> I think it's not Perl 6.

[14:46] <Juerd> I could be wrong, of course.

[14:47] <lanny> I think it might be but I'm with you on could be wrong.

[14:47] * Juerd still thinks that W operators should NOT return arrays instead of lists in item context, including comma

[14:48] <lanny> Well I think it's an artifact of zip here but I think it's an artifact that's supposed to be here

[14:48] <lanny> ?eval my @a=(0,4); my @b=(2,6); my @c=(1,3,5,7); my @z = zip(zip(@a;@b);@c); @z[0]

[14:49] *** evalbot_r13748 is now known as evalbot_r13749

[14:49] <evalbot_r13749> [(0, 2), 1]

[14:49] <lanny> Reminds me of Lisp.  We should keep it since it followed us home.

[14:50] <lanny> ?eval my @a=(0,4); my @b=(2,6); my @c=(1,3,5,7); my @z = zip(zip(@a;@b);@c); @z[0,1]

[14:50] <evalbot_r13749> [((0, 2), 1), ((4, 6), 3)]

[14:50] <Limbic_Region> @tell audreyt running make smoke on Win32 results in pugs blowing up on almost every single test

[14:50] <lambdabot> Consider it noted.

[14:51] <masak> ?eval map -> $num { map -> $suit { { num => $num, val => $num > 10 ?? 10 !! $num, suit => $suit } }, <H D C S>; }, 1..13; # this parsefails in pugs right now in examples/cribbage_scoring.pl, how should it be written?

[14:51] <evalbot_r13749> pugs: internal error: startTask: Can't create new task     Please report this as a compiler bug.  See:     http://www.haskell.org/ghc/reportabug

[14:51] <lambdabot> Title: 1.2. Reporting bugs in GHC

[14:51] <masak> whoa

[14:51] <masak> sorry, GHC, didn't mean to

[14:51] <Limbic_Region> masak - cribbage_scoring.pl was never parseable

[14:52] <masak> Limbic_Region: whee!

[14:52] <masak> so there's nothing I can do?

[14:52] <Limbic_Region> it was written a long while back

[14:52] <Limbic_Region> masak - there is

[14:52] *** Salzh joined
[14:52] <Limbic_Region> figure out the intent of the code, determine if it is valid syntax

[14:52] <lanny> ?eval [((0, 2), 1), ((4, 6), 3), (undef, 5), (undef, 7)]

[14:52] <evalbot_r13749> [0, 2, 1, 4, 6, 3, undef, 5, undef, 7]

[14:52] <Limbic_Region> if it is - write failing tests

[14:52] <Limbic_Region> if not - rewrite using valid syntax

[14:52] <lanny> Interesting.

[14:53] <masak> Limbic_Region: well, rewriting using valid syntax is my goal -- hence the question above: "how should it [the nested map expression] be written?"

[14:53] <masak> do we still have map { expr }, @array?

[14:54] * Limbic_Region doesn't keep up with the synopses well enough to know what is valid and what isn't without looking it up

[14:54] <masak> or is it written exclusively with colons nowadays?

[14:54] <Limbic_Region> no comma needed in that form

[14:54] <masak> not even in p6? :)

[14:54] <masak> p6 is more regular in that regard

[14:54] <Limbic_Region> ?eval my @foo = map { uc($_) } 'a' .. 'z'; ~@foo;

[14:54] <evalbot_r13749> Error:  Unexpected "'" expecting comment, ",", ":", operator, statement modifier, ";" or end of input

[14:54] <masak> if no comma, then at least a colon or sum'n

[14:55] <Limbic_Region> ?eval my @foo = map { uc($_) }, 'a' .. 'z'; ~@foo;

[14:55] <evalbot_r13749> "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"

[14:55] <Limbic_Region> ok - comma is needed and yes - it still works

[14:55] <masak> ?eval my @foo = map :{ uc($_) } 'a' ... 'z'; ~@foo

[14:55] <evalbot_r13749> Error:  Unexpected "'" expecting operator, ":", ",", comment, statement modifier, ";" or end of input

[14:55] *** bradb left
[14:55] <masak> hm

[14:56] <Limbic_Region> ?eval my @foo = ('a'..'z').map{ uc($_) }; ~@foo;

[14:56] <masak> I know I've seen something with a colon

[14:56] <evalbot_r13749> Error: Cannot cast from VList [] to Pugs.AST.Internals.VCode (VCode)

[14:56] <mauke> ?eval my @foo = map { uc($_) } :'a' ... 'z'; ~@foo

[14:56] <evalbot_r13749> Error:  Unexpected "'" expecting operator, ":", ",", comment, statement modifier, ";" or end of input

[14:56] <Limbic_Region> ?eval my @foo = ('a'..'z'):map{ uc($_) }; ~@foo;

[14:56] <evalbot_r13749> Error:  Unexpected ":" expecting term postfix, comment, operator, ",", statement modifier, ";" or end of input

[14:56] * Limbic_Region wishes mauke good luck

[14:57] <Limbic_Region> err uh masak even

[14:57] <lanny> masak: that double map works for me

[14:57] <masak> lanny: which one?

[14:57] <masak> the parsefailing one?

[14:57] <lanny> The big one you said parsefails

[14:57] <masak> ah

[14:58] <audreyt> ('a'..'z').map:{}

[14:58] <lambdabot> audreyt: You have 2 new messages. '/msg lambdabot @messages' to read them.

[14:58] <masak> which revision pugs are you using?

[14:58] <masak> audreyt: thx

[14:58] <lanny> Version: 6.2.12 (r13749)

[14:58] <Limbic_Region> me too - and it is terribly b0rk on Win32

[14:59] <masak> that's the latest one

[14:59] <masak> ?eval my @foo = ('a'..'z').map:{ uc($_) }; ~@foo'

[14:59] <evalbot_r13749> Error:  Unexpected "'" expecting "::", term postfix, comment, operator, statement modifier, ";" or end of input

[14:59] <masak> this should work, right?

[15:00] <masak> audreyt: is there a non-dot form with a colon, too?

[15:00] <audreyt> prolly not

[15:00] <lanny> ?eval zip((1,3);(2,4))

[15:00] <evalbot_r13749> ((1, 2), (3, 4))

[15:01] <lanny> audreyt: Should that list of lists exist?  Seems like the correct output of zip() but surprising.

[15:01] <masak> audreyt: oh, I seem to remember having seen one. did it really never exist, or only never in the 1984 sense? :)

[15:01] <audreyt> in the 1984 sense

[15:01] <audreyt> lanny: each() is the flatten form

[15:02] <audreyt> masak: that should work except you had a trailing ' after @foo

[15:02] <lanny> Ok.  Good to (be reminded) know.

[15:02] * masak blushes

[15:02] <masak> ?eval my @foo = ('a'..'z').map:{ uc($_) }; ~@foo

[15:02] <evalbot_r13749> "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"

[15:02] <masak> huh

[15:03] <Limbic_Region> audreyt - not sure how to debug why Pugs is blowing up on Win32.  Windows is giving me a popup that pugs has encountered problems and must terminate - no output to stderr or stdout

[15:03] * masak rewrites cribbage_scoring.pl

[15:03] <Limbic_Region> -d is of no help

[15:04] <Limbic_Region> pugs -e "say 'hello, world'" # works fine though

[15:05] <audreyt> hrm. which ghc are you using?

[15:05] <audreyt> ghc -head was broken for a week or so

[15:05] <Limbic_Region> ghc is from about the 9th

[15:05] <Limbic_Region> and had previously been working fine

[15:06] <Limbic_Region> IOW - I haven't changed the ghc, just pugs

[15:06] <audreyt> so it's a pugsbug... hm

[15:06] <lanny> audreyt: is there a way to create that list of lists above using literals?  I ask trying to fix a test in zip.t

[15:06] <audreyt> so say is working fine

[15:06] <audreyt> what's a minimal non-fine case?

[15:06] <Limbic_Region> would you prefer something from t/ or ext/

[15:07] <Limbic_Region> since ext/ comes first in smoke

[15:07] <Limbic_Region> I know more of those tests

[15:07] <Limbic_Region> but could easily find something in t/

[15:07] <svnbot6> r13750 | masak++ | [examples/cribbage_scoring.pl]

[15:07] <svnbot6> r13750 | masak++ | * threw around some syntax to make map calls work :)

[15:07] <svnbot6> r13750 | masak++ | * now it parsefails somewhere else instead :/

[15:07] <audreyt> lanny: test for stringification perhaps?

[15:07] <audreyt> Limbic_Region: I prefer something reduceable to -e

[15:07] <audreyt> I suspect p5embed

[15:07] <masak> afk & # there's an emergency at my local sushi place, they need me to come and pick stuff up

[15:08] <audreyt> perl -e "say /./"

[15:08] <audreyt> does that work?

[15:08] <Limbic_Region> audreyt - testing

[15:08] <lanny> It's doing that now and getting it wrong.  The only way I can see  to test  right now is run the zip(zip(@a;@b); @c) twice  and test against each other.  That's hardly a real test.

[15:08] <Limbic_Region> <Regex>

[15:08] <Limbic_Region> yep - works

[15:08] <xinming__> audreyt: Hello, What will you do on national day? :-P

[15:08] <audreyt> perl -e "say 1 ~~ /./"

[15:09] * audreyt mumbles something about not having loyalty for nations

[15:09] <audreyt> Limbic_Region: try that?

[15:09] <lanny> I'll p6l it.  There really shouldn't be a construct you can create that you can't make as literals as well.

[15:09] <audreyt> there's a canonical way

[15:09] <audreyt> namely Seq(Seq(1,2);Seq(3,4))

[15:09] <Limbic_Region> audreyt - assuming you mean pugs and not perl

[15:10] <Limbic_Region> that doesn't work

[15:10] <audreyt> but that's not yet available

[15:10] <Limbic_Region> but doesn't cause the windows level error

[15:10] <audreyt> Limbic_Region: segfaults?

[15:10] <Limbic_Region> I get output

[15:10] <lanny> Ok.  I'll switch the test  to that and  todo it.  :)

[15:10] <Limbic_Region> *** Cannot parse regex: .'

[15:10] <audreyt> lanny: good :)

[15:10] *** MacVince joined
[15:10] <Limbic_Region> *** Error: Error: Can't locate object method "__RUN__" via package "Pugs::Runtime::Match::HsBridge".

[15:10] <audreyt> Limbic_Region: that's all? no other explanations?

[15:10] <audreyt> ah. there we go

[15:10] <Limbic_Region> those 2 lines

[15:11] <MacVince> Will Perl 6 have an easy way to compare complexe arrays and hashes?

[15:11] <lanny> MacVince: see eqv()

[15:12] <MacVince> lanny: thanks.

[15:12] <audreyt> Limbic_Region: try this line

[15:12] <audreyt> perl -Iperl5/Pugs-Compiler-Rule/lib -MPugs::Runtime::Match::HsBridge -e "warn Pugs::Runtime::Match::HsBridge->__RUN__(1,q[.])"

[15:13] <Limbic_Region> did you mean perl or pugs?

[15:14] <Limbic_Region> perl blows up about not finding some stuff

[15:14] <Limbic_Region> will nopaste

[15:14] <Limbic_Region> perlbot nopaste

[15:14] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[15:15] <audreyt> I mean perl this time :)

[15:15] *** justatheory joined
[15:15] <pasteling> "Limbic_Region" at 24.35.57.240 pasted "perl output" (13 lines, 888B) at http://sial.org/pbot/20078

[15:15] <audreyt> oy, someone is being naughty

[15:16] <audreyt> fglock: this doesn't dwym:     eval { use YAML::Syck };

[15:16] * audreyt changes that to require

[15:16] <Limbic_Region> audreyt - I think just trying to use Test; is causing the windows level blowup

[15:16] <audreyt> Limbic_Region: try again? no recompile needed

[15:17] <svnbot6> r13751 | audreyt++ | * Pugs::Runtime::Match: Load YAML::Syck at runtime only when needed.

[15:17] <audreyt> Limbic_Region: oh? hm.

[15:17] <audreyt> rm blib6/lib/Test.pm.yml ?

[15:17] <Limbic_Region> PGE_Match 0 1 [] [] at -e line 1.

[15:17] <Limbic_Region> so that looks good

[15:18] <audreyt> yup

[15:18] <Limbic_Region> let me test my Test theory

[15:18] <Limbic_Region> and then your potential fix

[15:19] <Limbic_Region> pugs -Iblib6/lib -e "use Test;" # sufficient to cause windows to blow up (testing removal of Test.pm.yml now)

[15:19] <Limbic_Region> and now all is right in the world

[15:19] <Limbic_Region> ;-)

[15:19] * Limbic_Region runs a smoke

[15:20] <svnbot6> r13752 | audreyt++ | * Support for postfix reduction forms:

[15:20] <svnbot6> r13752 | audreyt++ |     [+]<<

[15:20] <svnbot6> r13752 | audreyt++ |     [\+]<<

[15:20] <svnbot6> r13752 | audreyt++ |     [>>+<<]<<

[15:20] <svnbot6> r13752 | audreyt++ |     [>>\+<<]<<

[15:22] <Limbic_Region> running smoke of 13752 - thanks audreyt++

[15:22] <Limbic_Region> now if you have time for a question

[15:22] <svnbot6> r13753 | audreyt++ | * triaging of t/operators/.

[15:24] <Limbic_Region> in p5 - I could create a dispatch table of code refs and inside a while () { ... } block call one of those coderefs

[15:24] <Limbic_Region> and if that code ref had a last

[15:24] <Limbic_Region> the last worked on the while () { ... } block

[15:24] <Limbic_Region> and this worked in pugs too - for some time

[15:24] <Limbic_Region> but I was just testing examples/progessive_powerset.pl

[15:25] <Limbic_Region> and discovered that this doesn't work any longer

[15:25] <Limbic_Region> I can see how to work around it - kludgely

[15:25] <Limbic_Region> is there a more elegant way than

[15:25] <Limbic_Region> checking the return of the code ref

[15:26] <Limbic_Region> and if 'last' than last inside the while () { ... } block itself?

[15:26] <audreyt> hm. the reason last diddn't work was because it's not really throwing a control exception

[15:26] <audreyt> but indtead we bind &last inside the while

[15:26] <audreyt> now you mentioned it that was indeed a very wrong way

[15:26] <audreyt> please write a todo<bug> test

[15:26] <Limbic_Region> audreyt - happy to except I am not sure which is correct behavior

[15:27] <audreyt> p5 is

[15:27] <audreyt> as for workaround - two ways. one is to put the table construction inside the while

[15:27] <Limbic_Region> should the code in examples/progressive_powerset.pl work?

[15:27] <audreyt> that will let it bind the correct &last

[15:27] <audreyt> one is to check for rv and last, as you said

[15:27] <Limbic_Region> I don't really like either of those ways

[15:27] <Limbic_Region> the first defeats the purpose of the dispatch table in the first place

[15:28] <Limbic_Region> the second just isn't pretty - but I can live with it

[15:28] <audreyt> you can use "fail" and try{}

[15:28] <audreyt> but write a test definitely; I wasn't realizing we were doing it wrong

[15:28] <svnbot6> r13754 | lanny++ | [zip.t]

[15:28] <svnbot6> r13754 | lanny++ | * fixed test trying to use array to match zip(zip(@a;@b);@c);

[15:28] <svnbot6> r13754 | lanny++ | * :todo :depends<Seq> same test

[15:28] <svnbot6> r13754 | lanny++ | * modified test text indicating a bug.  text now explains the regression

[15:28] <Limbic_Region> audreyt - so the p5 behavior is correct

[15:29] <audreyt> aye

[15:29] <Limbic_Region> a code ref executed inside a while block that invokes last should work on the while block not the code ref (provided it isn't inside a loop construct in the code ref)?

[15:30] <audreyt> that is correct.

[15:30] <lanny> Limbic_Region: You might be able to leave TAG;  I think I did that in sort.t inside a closure.

[15:30] <audreyt> I don't recall mplementing leave :)

[15:30] <Limbic_Region> hrm - I would think that the p5 behavior was wrong

[15:31] <audreyt> Limbic_Region: think of next/redo/last as throwing exceptions

[15:31] <audreyt> not invoking lexical escape continuations

[15:31] <Limbic_Region> ok - so lets walk through this so I can understand

[15:31] <lanny> Hmm.  I'm 95% sure  I tested it in isolation and it seemed to be doing the right thing.

[15:31] <Limbic_Region> my example (in my mind) is equivalent to

[15:32] <audreyt> sub call_last { last } while 1 { call_last() }

[15:32] <audreyt> sub call_last { last }; while 1 { call_last() }

[15:32] <Limbic_Region> sub foobar { # ... some code; last; # using last to exit a sub is wrong } while ($cond) { # ... foobar(); # uses last # ... more statements }

[15:33] <Limbic_Region> yeah

[15:33] <audreyt> last-to-exit-a-sub is a warning , true

[15:33] <audreyt> or should be one, at any rate

[15:34] <audreyt> but it still works

[15:34] <Limbic_Region> so last throws an exception caught at the sub level - the sub level realizes it needs to re-throw it so it can be handled by the loop construct?

[15:34] <audreyt> (I need to crash into sleepiness very soon)

[15:34] <audreyt> yes.

[15:34] <audreyt> Bit's equiv to

[15:34] <Limbic_Region> will write the test then

[15:34] <Limbic_Region> still feels like I am abusing behavior but am happy to write the test

[15:35] <audreyt> leave Loop;

[15:35] <audreyt> which reminds me, I need to subclass Block into Loop

[15:35] * Limbic_Region is glad he is good for something

[15:35] <Limbic_Region> ;-)

[15:36] <audreyt> you're good for lots of things :)

[15:36] <Limbic_Region> well - I am probably going to be spending more time on Java (and possibly Haskell) then on p6 for a while

[15:36] <lanny> Glad I qualified my having tested in isolation.  :/

[15:37] <audreyt> ...you rolled a 1 in 1d20 :)

[15:37] <Limbic_Region> audreyt - fwiw, I needed to re-delete blib6/lib/Test.pm.yml after svn uping and making

[15:37] <pasteling> "lanny" at 206.109.40.208 pasted "leave LOOP;" (11 lines, 240B) at http://sial.org/pbot/20079

[15:38] <lanny> Is what I was aiming at.

[15:38] <audreyt> Limbic_Region: seems yaml loading is broken on win32 somehow

[15:38] <lanny> Was very useful in my fevered imagination.  :)

[15:38] <audreyt> Limbic_Region: can you upload your pugs.exe somewhere?

[15:38] <audreyt> I can maybe look at it tomorrow

[15:38] <Limbic_Region> audreyt - yep - can put it in my home directory on feather

[15:38] <audreyt> also file a hiveminder.com ticket for that :)

[15:38] <Juerd> sub infix:<d> ($num, $size) { ^$num.map:{ 1 + int rand $size } }

[15:38] <audreyt> Limbic_Region++

[15:39] <audreyt> I need to run now... *wave*

[15:39] <Limbic_Region> going to finish the smoke first

[15:39] <Limbic_Region> sleep well

[15:39] <Juerd> ? eval sub infix:<d> ($num, $size) { ^$num.map:{ 1 + int rand $size } }; 5 d 3

[15:39] <audreyt> Juerd++

[15:39] <Juerd> ?eval sub infix:<d> ($num, $size) { ^$num.map:{ 1 + int rand $size } }; 5 d 3

[15:39] *** evalbot_r13749 is now known as evalbot_r13751

[15:39] <evalbot_r13751> (0.0,)

[15:39] <Juerd> Holy crap, it can parse that?!

[15:39] <audreyt> you want a [+]

[15:39] <lanny> Why not?

[15:39] <Juerd> Oh, right. I need .sum ;)

[15:39] <wolverian> isn't prefix ^ metaclass stuff?

[15:40] <Juerd> ?eval sub infix:<d> ($num, $size) { [+] ^$num.map:{ 1 + int rand $size } }; 5 d 3

[15:40] <evalbot_r13751> 0.0

[15:40] <Juerd> ? eval 1 + int rand $size

[15:40] <Juerd> I'm too used to hitting spacebar after ?.

[15:40] <Juerd> ?eval 1 + int rand $size

[15:40] <evalbot_r13751> Error: Undeclared variable: "$size"

[15:40] <Juerd> D'oh.

[15:40] <Juerd> ?eval 1 + int rand 5

[15:40] <evalbot_r13751> 2

[15:40] <Juerd> ?eval ^3

[15:40] <audreyt> ?eval sub infix:<d> ($num, $size) { [+] map { 1 +  rand($size).int }, ^$num }; 10 d 6

[15:40] <evalbot_r13751> (0.0, 1.0, 2.0)

[15:40] <evalbot_r13751> 37

[15:40] <MacVince> ? eval undef err "Oh noes!"

[15:41] <Juerd> Why does ^$num.map:{ ... } not work? Predecence?

[15:41] <audreyt> 37 is pretty good for a fireball

[15:41] <audreyt> yeah. (^$num).map would work

[15:41] <Juerd> Oh. Is this intended?

[15:41] <lanny> Juerd: What is the ^$num ?

[15:41] <Juerd> lanny: 0..$num.

[15:41] <MacVince> ? eval undef err say "undefined"

[15:41] <Juerd> lanny: I don't really like it, and would prefer that we get XX instead.

[15:41] <lanny> You're kidding!  :)

[15:42] <audreyt> Juerd: intentional. think   (int $foo.moose)

[15:42] <audreyt> .moose gets run first, not int

[15:42] <audreyt> for I think good reasons

[15:42] <Juerd> { 1 + int rand $size } XX 5

[15:42] <Juerd> Eh, $num

[15:42] <lanny> I would think 0..$num would be a lot clearer.

[15:42] <masak> MacVince: you shouldn't use a space after the "?"

[15:42] <MacVince> masak: okay

[15:42] <Juerd> audreyt: Eh, the intended was referring to ^ binding so loosely.

[15:42] <MacVince> ?eval undef err say "undefined"

[15:42] <evalbot_r13751> OUTPUT[undefined ] Bool::True

[15:42] <masak> MacVince: and "say" isn't really needed in ?eval

[15:42] <MacVince> ?eval undef err "undefined"

[15:42] <evalbot_r13751> "undefined"

[15:42] <MacVince> Cool, thanks masak

[15:43] <masak> np

[15:43] <audreyt> Juerd: I was replying to that; no prefix op binds tighter than method

[15:43] <audreyt> except for prefix sigil op on a sigilled var, and that doesn't count because it's parsed as var.

[15:43] <Limbic_Region> audreyt - pugs.exe uploaded and hiveminder reminder set - writing failing last test now

[15:43] <MacVince> ?eval ([1,2,3], [4, 5, [6]]) eqv ([1,2,3], [4,5,[7]])

[15:43] <audreyt> Limbic_Region++

[15:43] <evalbot_r13751> Bool::False

[15:44] <MacVince> ?eval ([1,2,3], [4, 5, [6]]) eqv ([1,2,3], [4,5,[6]])

[15:44] <audreyt> Juerd: $num.'^'.map:{...} will get you that... maybe tomorrow I'll implement it

[15:44] <evalbot_r13751> Bool::False

[15:44] <MacVince> Limbic_Region: are you Jesse Vincent, the guy behind hiveminder?

[15:44] <Juerd> audreyt: Ahh, I see. I think that's a bit unfortunate, but it's understandable.

[15:44] <MacVince> Hmmm....

[15:44] <audreyt> MacVince: recursive comparison is better done by comparing .perl

[15:44] <Juerd> MacVince: No, that's obra

[15:44] <Juerd> audreyt: I still don't like '^' as a syntax. '' reminds me of strings!

[15:44] <audreyt> Juerd: the only way to make ^$num.map work is... make it a sigil!

[15:44] <MacVince> audreyt: .perl is the representation of a data structure, right?

[15:45] <audreyt> MacVince: it is.

[15:45] <Juerd> audreyt: I'm convinced. Let's use parens :)

[15:45] <MacVince> ?eval (1,2,[3,4]).perl

[15:45] *** evalbot_r13751 is now known as evalbot_r13753

[15:45] <evalbot_r13753> "(1, 2, [3, 4])"

[15:45] <Juerd> (re sigil, not re '^')

[15:45] <audreyt> good. now I can rest in pieces

[15:45] <audreyt> :) &

[15:45] <lanny> MacVince: sub infix:<eqp> ($a,$b) { $a.perl eq $b.perl; }

[15:45] <Juerd> Good night, audreyt

[15:46] <MacVince> ?eval (1,2,3).perl eq ~(1,2,3)

[15:46] <evalbot_r13753> Bool::False

[15:46] <masak> 'night, audreyt

[15:46] <MacVince> ?eval (1,2,3).perl

[15:46] <evalbot_r13753> "(1, 2, 3)"

[15:46] <MacVince> ?eval ~(1,2,3)

[15:46] <evalbot_r13753> "1 2 3"

[15:46] <masak> :)

[15:46] <MacVince> Ah!

[15:46] <MacVince> repl++

[15:47] <lanny> Oh good.  ^$num is 0..^$num.  Was gonna be worried about the disconnect there.

[15:47] <Juerd> ^ reads as "up to"

[15:47] <lanny> That's in S02 probably?

[15:48] <Juerd> I don't know

[15:48] <Juerd> I think S03.

[15:48] <lanny> or  maybe 03

[15:49] <lanny> S03/New Operators

[15:49] <wolverian> oh, ^ is meta only on classes.

[15:49] <lanny> ?eval ^(3,3)

[15:49] <evalbot_r13753> (0.0, 1.0)

[15:50] <lanny> ?eval list(^(3,3))

[15:50] <evalbot_r13753> (0.0, 1.0)

[15:50] <lanny> Time to write a test.

[15:50] <masak> lanny: why? that seems fine by me

[15:51] <Juerd> ?eval ^(1, 2, 3, 4)

[15:51] <evalbot_r13753> (0.0, 1.0, 2.0, 3.0)

[15:51] <lanny> Spec says that should be (0,0), (0,1), (0,2), ... (2,2)

[15:51] <Juerd> I think it makes no sense for ^ to accept multiple arguments

[15:51] <masak> lanny: ah

[15:51] <Juerd> We have ^« for that when we really need it.

[15:51] <lanny> The for example  used in the spec is compelling

[15:52] <masak> Juerd: why not p6l that opinion?

[15:52] <lanny> for ^(3,3) { }  # (0,0), (0,1), ... (2,2)

[15:52] <mauke> d num size = liftM sum (replicateM num (randomRIO (1, size)))

[15:52] <lanny> ^<< wouldn't do  the same thing

[15:52] <masak> lanny: I like the example

[15:53] <Juerd> masak: I wonder too much if it would matter. My opinion about ^ has been ignored before. These examples look cute, but IMO we'd be better off without.

[15:53] <Juerd> Well, not ignored. But it wasn't well received either.

[15:54] <masak> Juerd: I must have missed that. anyway, if you have good arguments for leaving multi-arg ^ out of the stew, I sure'd like to hear them

[15:54] <lanny> How else would you easily form a cross product?  for  ( i = 0; i < 3; ++i ) { for (j = 0; j < 3; ++j ) { ... }}

[15:54] <lanny> Would have loved to have had ^(3,3) a few times in the past

[15:55] <Juerd> masak: Because returning nested "lists" can be done in so many different ways, that none of them would still be intuitive as a default.

[15:55] <Juerd> my $list = any(List, Array, Capture, Feed);

[15:55] <masak> Juerd: what about the order that corresponds to increasing numbers in the position system

[15:55] <masak> ...?

[15:55] <Juerd> my $nested_list = $list of $list.

[15:56] <Juerd> That's 16 permutations already.

[15:56] <Juerd> masak: What's a position system?

[15:56] <masak> Juerd: the one that replaced Roman numerals

[15:56] <svnbot6> r13755 | Limbic_Region++ | Added a todo test for last inside sub inside loop per audreyt++

[15:56] <Juerd> masak: If you need 0..^$foo, write it?

[15:56] <Juerd> ^ will be used much with arrays: ^@foo.

[15:56] <lanny> for ^(2,2,2,2)  -> $nibble { }

[15:57] <Juerd> This solves something, and it makes something else go really bad.

[15:57] <Juerd> It solves the common case where you need the indices of an array, but ONLY for arrays that are 0-based.

[15:57] <masak> Juerd: yes

[15:57] <masak> but that's quite common

[15:57] <Juerd> It makes things go really bad when an array doesn't follow that anymore.

[15:58] <Juerd> Arrays can be shaped very differently in Perl 6.

[15:58] <mauke> isn't there something like array.indices?

[15:58] <Juerd> If you want the indices, ask for them: @foo.indices, or @foo.keys for all i care.

[15:58] <Juerd> But don't do ^@foo. We should get RID of assumptions about indices, like we got rid of C-style for loops: lists work so much better!

[15:59] <Limbic_Region> @tell audreyt the t/statements/last.t test for last inside a sub inside a loop is eval_is/todo because it crashes locally fyi

[15:59] <lambdabot> Consider it noted.

[15:59] <masak> Juerd: you're almost getting through to me here

[15:59] <Juerd> We should have something that returns a list of indices for any given array.

[15:59] <Juerd> And avoid having something that's more attractive, but returns a list of indices only for most arrays.

[15:59] <Juerd> ^ is so cute and easy to type, that people will use it instead of a .indices or .keys, even if those methods exist.

[15:59] <Juerd> That will either:

[15:59] <Juerd> 1. hurt later on

[16:00] <Juerd> 2. make oddly shaped Arrays look bad (bad style, frowned upon)

[16:00] <masak> ?eval my @a = <a b c d>; @a.keys

[16:00] *** evalbot_r13753 is now known as evalbot_r13755

[16:00] <evalbot_r13755> (0, 1, 2, 3)

[16:01] <lanny> The vast majority of users are going to be using  one-dim, zero based  arrays

[16:01] <Juerd> And see how I already abused (^$foo).map:{...} to do ... $foo times?

[16:01] <Juerd> I don't need indices there!

[16:01] <Juerd> I'm not using $_ at all. It shouldn't be there. It can only hurt or pollute.

[16:02] <lanny> Why is it abuse?  It says that ^$num generates 0..^$num.  It doesn't specify that this has to be for array indices

[16:02] <masak> hm

[16:02] <Juerd> But - I used ^ because it exists. I'm like all the other programmers: I'll abuse any language feature you give me.

[16:02] <Juerd> lanny: Generating a list and then never using it is abuse of the list.

[16:02] <Juerd> lanny: If you want to do something a number of times, why generate a list for that? Why not just have something that says "do foo, bar times"?

[16:02] <masak> Juerd: but ^ is also a handy shortcut

[16:03] <Juerd> If your code still works when you change a single 0..9 to a 1..10, you're wasting a list.

[16:03] <masak> Juerd: but I agree, I kind of like Ruby's 5.times {}

[16:03] <Juerd> masak: It's a handy shortcut, but TOO handy. And it's only 3 characters shorter than its full form, 0..^

[16:03] <lanny> Ah.  Missed your not  using $_ in the map.  I wouldn't go so far as naming it abuse but I see your point

[16:03] <Juerd> masak: While introducing a lot of obfuscation.

[16:04] <Juerd> .. is immediately recognisable as a range to almost anyone. Even if you have to look up wath that ^ does there.

[16:05] <Juerd> Also, ^ could be used for so many nice things. A lot have been mentioned already. None of which really appeals to me, but we need to reserve some characters for future killer operators.

[16:05] <masak> Juerd: so you propose outlawing ^$foo and writing it 0..^$foo

[16:06] <Juerd> masak: Yes. And when you need a list of array indices, writing it as @foo.keys, not ^@foo.

[16:06] <Juerd> There has been mentioning of ^@array being shorthand for @array.keys, but that feels like a hackery solution to a problem that can be avoided in a much earlier stage.

[16:07] <Juerd> 5.times is nice, but not in line with x and xx, which repeat too (but in a different way). The order of arguments is completely reversed.

[16:08] <masak> Juerd: well, you've more or less convinced me. but I'm not sure I'll do something about it, short of not writing ^$foo in my perl6 code

[16:08] <Juerd> Well, if it's there anyway, I will use it too.

[16:08] <Juerd> But I'm convinced that it's better to not have it.

[16:09] <masak> Juerd: a lot of features exist in Perl that can be abused, but that can also be used for a lot of goodness

[16:09] <Juerd> Yes, but this kind of abuse will be the standard.

[16:09] <Juerd> That's the danger here.

[16:10] <masak> Juerd: sounds like you're saying that ^$foo is too Huffman-y

[16:10] <Juerd> It's huffmanly perfect for our current problems.

[16:10] <Juerd> But our problems will be shaped differently. Pun not intended, but you can interpret it both ways.

[16:11] <masak> Juerd: actually, I don't agree that the zero-basedness is a problem. zero is a very, very common array index base

[16:11] <masak> having a shorthand for that is nice

[16:11] <Juerd> Yes, and that's great. I think we should keep the default to 0, and I think that most arrays would best have 0 as their base.

[16:11] <Juerd> Well, there you go.

[16:11] <Juerd> You first say that 0 is a common array index base, then you say that a shorthand for an array index base is nice.

[16:12] <lanny> 0..^$num does  say that clearer though and does handle 7..^$num

[16:12] <Juerd> But why this shorthand?

[16:12] <Juerd> It's "nice". Yes, it's cute and short syntax.

[16:12] <lanny> For instance being midway down a buffer  and taking slices

[16:12] <Juerd> But it's awful code documentation, because you're not asking for the right thing.

[16:12] <Juerd> Even though you are getting what you wanted.

[16:12] <Juerd> It's like the difference between 5 * 3 and 3 * 5. They both return 15, but they mean something wildly different.

[16:13] <masak> Juerd: I fail to draw the analogy. why are 5 * 3 and 3 * 5 so different?

[16:13] <lanny> Um... * is associative so no they don't.  At least in the field of integers

[16:13] <Juerd> And indeed, the non-shorthand isn't so bad either: 0..^  # on most keyboards, that's only three keys.

[16:14] <Juerd> masak: 5 * 3 is XXX XXX XXX XXX XXX, while 3 * 5 is XXXXX XXXXX XXXXX.

[16:14] <Juerd> Both 15 Xes

[16:14] <masak> Juerd: yes, I get that

[16:14] <mauke> Juerd: or the other way around

[16:14] <Juerd> But arranged differently.

[16:14] <masak> Juerd: yes

[16:14] <Juerd> mauke: In LTR languages, no, not the other way around.

[16:14] <mauke> since 5 x 3 is '555'

[16:14] <Juerd> I'm speaking of * strictly, for the analogy, not about x or xx.

[16:15] <mauke> I'm seriously not sure which way * works

[16:15] <Juerd> I do think that the arguments for x and xx should have been the other way around, but it's much too late to change that now.

[16:15] <Juerd> 3 x "foo" makes much more sense to mee than "foo" x 3.

[16:15] <Juerd> As would 3 XX { ... } make more sense to me than { ... } XX 3

[16:16] <lanny> Nope.  Because "foo" is  what you want copied.  It pays to  introduce the subject at the start of your sentence

[16:16] <masak> Juerd: anyway, from the pragmatic point of view, ^ is not going to go away by itself. someone needs to lobby against it. write a blog entry or something :)

[16:16] <Juerd> masak: I've mentioned it here and on p6l before. If enough, or influential enough people would agree, it would already have been changed.

[16:17] * Limbic_Region likes to start his sentences with conjunctions

[16:17] <masak> Juerd: nothing is set in stone, you know

[16:17] <Juerd> masak: I'm not going to lobby. I hate that.

[16:17] <masak> Limbic_Region: and an example?

[16:17] <Limbic_Region> Because it was rainy and cold outside, he stayed indoors.

[16:17] <Juerd> Larry has made up his mind about this, and other things. He gets to decide.

[16:17] <Juerd> I also still want <->.

[16:18] <Juerd> And "<-> $_" to be the default instead of "-> $_ is rw"

[16:18] <masak> Juerd: with a bit of luck, you'll be able to redefine p6 to your needs :)

[16:18] <masak> afk & # dinner

[16:18] <Limbic_Region> $larry is variable and has been known to unmake up his mind.

[16:18] <Juerd> masak: No, that'd be bad. Deviating from the standard language too much is a stupid idea.

[16:18] * Limbic_Region was very happy to hear that 2 things he bitched about on the list over a year ago have ended up coming to pass anyway

[16:18] <Juerd> Also, <-> wouldn't just be practical, it would also make teaching Perl much simpler.

[16:18] <mauke> what is <->?

[16:19] <Juerd> Glueing it to the language afterwards would only fix half of that.

[16:19] <Limbic_Region> masak - if you hadn't noticed the sentence beginning with a conjunction - it was the one right before you asked for the example

[16:19] <Juerd> mauke: Well, in current terms, "->" implying "is rw" for all parameters.

[16:19] *** vv3 joined
[16:19] <Juerd> mauke: I'd like to explain "->" as a special case of "<->" instead, where it has "is ro" for all of its parameters.

[16:19] <Juerd> for @foo { ... }

[16:19] <Juerd> That's actually shorthand for:

[16:20] <Juerd> for @foo -> $_ is rw { ... }

[16:20] <Juerd> So "$_" isn't the default here. No, it's "$_ is rw".

[16:20] <Juerd> That's weird, because that makes these two things different, while they look like they should be the same:

[16:20] <Juerd> for @foo { ... }

[16:20] <Juerd> for @foo -> $_ { ... }

[16:20] <Juerd> This is solved by making <-> the general case, and -> the more specific case:

[16:20] <Juerd> for @foo { ... }

[16:21] <Juerd> is shorthand for:

[16:21] <Juerd> for @foo <-> $_ { ... }

[16:21] <Juerd> While

[16:21] <Juerd> for @foo -> $_ { ... }

[16:21] <Juerd> is shorthand for:

[16:21] <Juerd> for @foo <-> $_ is ro { ... }

[16:21] <Juerd> (But that'd be BAD style, if we have both -> and <->)

[16:21] <lanny> Yeah. And all my orgs junior programmers  would be using <-> because they don't want to have to think about what vars to make is rw and I'll be tracking down bugs forever.

[16:22] <lanny> Better to make folks think about is rw  when needed than prop open the door.

[16:22] <Juerd> (As <-> looks bidirectional, and -> looks unidirectional. Using -> for bidirectional may make sense for us now, but using <-> for unidirectional would certainly be bad style and only good if you were mixing ro and rw)

[16:22] <Juerd> lanny: Disagreed.

[16:22] <mauke> lanny has a point

[16:23] <lanny> We can agree  to disagree but I face this problem now.

[16:23] <Juerd> lanny: That is -- if that's your argument, and I do see your point, then the default should also be ro, not rw.

[16:23] <Juerd> But if the default is rw, then your argument doesn't really hold for the explicit cases...

[16:24] <Juerd> If the default were ro, though, Perl'd change much in the way it's used.

[16:25] <lanny> The default probably would be ro if Perl 6 were starting from ground zero.  It's standing on the shoudlers of  Perl 5 though

[16:25] <Juerd> (I wouldn't mind that, by the way. I'm quite apathetic re for @array { s/.../.../ and manipulate $_ some more }, because for the simplest case I already get » in return to fix it.)

[16:25] <Juerd> lanny: That's what I mean.

[16:27] *** cognominal joined
[16:27] <lanny> Well Perl is the only language I can think of that scales from one-liners to full production codebases.  Getting rid of the shortcuts  that tend to dirty things as the language  scales up would hurt the one-liners.

[16:27] <lanny> So your gonna get some non scaling items (e.g., ^$num)

[16:28] <Juerd> But changing behaviour much while scaling up is weird too.

[16:28] <Juerd> Small scale defaulting to rw, but any explicit mentioning defaulting to ro... That's unintuitive, hard to explain, and just not very logical.

[16:29] <lanny> Yes.  But in my production code I wouldn't use for  @array { s/// } without a compelling reason.  Heh.  I'm coming to think we are  arguing the same point from different views.

[16:29] <Juerd> It requires explicit learning of behaviour, and you can no longer get by by trial and error, because it'll only confuse you. I expect this to be reported as a design bug by critics.

[16:30] <lanny> But why would you ever for -> $_ {}  ?  It's  there just for  the for {}

[16:30] <Juerd> lanny: It's not $_ that I'm afraid about

[16:30] <Juerd> I will initially have, somewhere in a program:

[16:30] <Juerd> for @foos {

[16:30] <Juerd>     ...

[16:30] <Juerd> }

[16:30] <lanny> Yes, well the critics write  stuff like  python (a language I have a lot of  fun with) so I have to do regexes as \\\\...\\....\\\\\\

[16:30] <Juerd> Then, later, the block grows, and gets more complex. It gets an inner block, so the outer block needs an explicit loop variable:

[16:31] <Juerd> for @foos -> $foo {

[16:31] <Juerd>     ...

[16:31] <Juerd>     ... # but I was mutating $_ somewhere, so now suddenly my code breaks. And all I did (if I were a normal programmer, and not already intimately familiar with Perl 6) was use a name "foo" instead of the default name "_"!

[16:31] <Juerd> }

[16:32] <Juerd> So I will come to IRC, or Perl Monks, or my cow orker, and ask about this.

[16:32] <Juerd> I'll be wasting time over this.

[16:32] <lanny> Hmm.  I always for @foo -> $v {} so don't bump into  that but I do see your point.

[16:33] <Juerd> Not just my time, but also someone else's time. I can really not understand what happened here to make this variable read only, even though I do understand from the error message that something must have done that.

[16:33] <Juerd> If I'm really smart, I'll ask IRC, Perl Monks, or my cow orker, how to make it read-write again. I'll be wasting time, but not a lot.

[16:33] *** chris2_ joined
[16:33] *** shachaf_ joined
[16:34] <Juerd> But most programmers aren't really smart, so I'll just paste the loop, and the error message, and complain that I didn't do anything to change this. Help me, please! This is urgent, not homework, and I can't really continue with my project until is fixed. I'm wasting a lot of my own and someone else's time.

[16:34] *** Psyche^__ joined
[16:34] <integral|ZzZzz> Obviously the solution is to introduce certification, so that programmers are required to know that.

[16:34] <Juerd> The principle of least suprise is ENTIRELY ignored here.

[16:35] <Juerd> integral|ZzZzz: I considerid mentioning that a few minutes ago. But it hurts my brain too much.

[16:35] <Juerd> considered.

[16:35] *** ashleyb joined
[16:35] <integral|ZzZzz> Probably hurt the economy too much to insist on competence :-P

[16:35] <Juerd> integral|ZzZzz: Unfortunately, yes, products that do have such implicit unexpected behavioural changes, typically do come with certification :(

[16:35] <lanny> I wish google was better at finding symbols.  Can't trace down where $_ is  ro on for ->

[16:36] <Juerd> lanny: That's just one of the many reasons you'd have to ask someone else about this.

[16:37] <Juerd> The other reasons are that documentation isn't indexed by problem, but by subject. While it's easy to find information in documentation, it's hard to find solutions in documentation.

[16:37] <lanny> Trivial test shows it though

[16:37] *** chris2_ is now known as chris2

[16:37] <Juerd> If we would document by problem, we'd quickly identify this as a design flaw.

[16:37] <lanny> Yeah.  I thought about indexing it but the rate of change is still really high

[16:37] <lanny> And a programmatic indexer  would have fun with symbols like ->

[16:37] <Juerd> Because in the perldiag of the future, "Try adding 'is rw'" would have to be mentioned.

[16:38] <Juerd> And if we can already determine now that we will need to explain this later, why go on with making the mistake? We can't optimize for TWO things in one construct. Sorry about that.

[16:39] <Juerd> That is, not for two *conflicting* things.

[16:39] <lanny> That will probably be a resolution.  Perl 6 is going to have a lot better idea of basic errors than Perl 5 did.  I wouldn't be surprised with an error that said, "You attempted  to modify $_ in a pointy block without declaring it is rw"

[16:39] <Juerd> Well, I have to compare this to how certain ISPs handle network breakage.

[16:40] <lanny> Well I don't agree with <-> as a solution but I do think $_ should always be is rw.

[16:40] <Juerd> Some actively put the information about the breakage on their website. One Dutch ISP even broadcasts network status on a Text page on a TV channel.

[16:40] <Juerd> Some will wait for you to call and complain, and then they'll tell you what's wrong.

[16:41] <Juerd> It turns out that the ISPs that actively inform you about the status are ALWAYS the ones that have the most solid networks in the first place.

[16:42] *** Psyche^__ is now known as Patterner

[16:42] <Juerd> If we need to find out what's wrong by running code (asking what's wrong), we're in the leage of the bad ISPs: a better language (network) design would probably have prevented the problem from happening in the first place.

[16:44] <Juerd> I agree that "->" looks very uni-directional, so that if it's used, you should have read-onliness as the default. But that just means that we need a read-write version of -> to serve as the default when no -> variant is used at all.

[16:44] <Juerd> The alternative is to make $_ read only by default too.

[16:44] <Juerd> Just like what was done to sub foo { ... } which gets a signature of (*@_) by default, NOT (*@_ is rw)!

[16:45] <Juerd> We can live with that.

[16:45] <Juerd> So we could also live with for @foo { ... } having a readonly $_ by default.

[16:46] <lanny> The alternative alternative is to have $_ alwasy rw in for

[16:46] <Juerd> The common case is not this, but ... for @foo. And such a single action is already better done with a hyper op: @foo »~~ s/foo/bar/, so the impact in idiomatic Perl 6 wouldn't be huge.

[16:46] <Juerd> lanny: That's the current behaviour that I've been calling illogical for the past 30 minutes (months, actually)

[16:47] <lanny> Hypers are going to take some time to trickle  through as  an idiom

[16:47] <lanny> No.  I mean that for @foo -> $v { s///; } still works because $_ remained  rw

[16:47] <Juerd> lanny: To me, that's a bad solution. Actually, it's not a solution but an ugly hack that will bite many people later.

[16:47] <lanny> Yes but the other way is an ugly hack that will bite people later so maybe we just get rid of for.

[16:48] <Juerd> lanny: That'd be very weird and not be a good fix for what I mentioned.

[16:48] <Juerd> Though I'll have to expand my example to illustrate:

[16:48] <Juerd> for @foo {

[16:48] <Juerd>     foo;

[16:48] <Juerd>     bar;

[16:48] <Juerd>     baz;

[16:48] <Juerd> }

[16:49] <Juerd> "bar" happens to modify $_.

[16:49] <Juerd> for @foo -> $foo {

[16:49] <Juerd>     foo;

[16:49] <lanny> Getting rid of for was humor/sarcasm.

[16:49] <Juerd>     for @bar -> $bar {

[16:49] <Juerd>         bar;

[16:49] <Juerd>     }

[16:49] <Juerd>     baz;

[16:49] <Juerd> }

[16:49] <Juerd> Code broke.

[16:49] <lanny> Juerd: I'm with your examples.  I just ran them in a side window.

[16:49] <Juerd> Even though "bar" now mentions $foo explicitly.

[16:50] <Juerd> (foo, bar, and baz, are to be read as "...", but labeled :))

[16:50] <Juerd> (not as function calls or macros)

[16:52] <lanny> What I'm suggesting  is the p5 behavior.  $_ is always rw weather you said for @foo {} or for @foo -> $v {}.

[16:52] <lanny> s/weather/whether/

[16:52] <Juerd> No fix.

[16:52] <Juerd> The inner loop would have a different $_, and mentioning $foo explicitly as in Perl 5 doesn't help, because it's weirdly automatically ro now.

[16:52] <lanny> No no no.  You can't claim that's not a local fix anyway because it causes  your broken examples to now work.  Might not be a scalable fix.

[16:53] <Juerd> local fix?

[16:53] <Juerd> It's simply not a fix.

[16:53] <lanny> Ok.  Sorry.  Your example isn't the one I was  thinking of.

[16:53] <Juerd> It's another hackish workaround, that only serves a specific case.

[16:54] <Juerd> I'm all for hacks in my own code, but such hacks get a bit harder to code if the language I write them in has them too :)

[16:56] <lanny> So  I agree for  @foo { $_ } acts differently than for @foo -> $v { $_ } and that it's surprising.  Your argument that folks will waste time having to learn the fix is a stretch (in my book) because learning a  new language is always time wasting.

[16:58] <lanny> Hmm.  I thought there was way to keep the topic though ($_) while naming it something as well.  i.e., for @foo -> <magic>, $v { $v =:= $_; }

[16:59] <MacVince> ?eval :foo

[16:59] <evalbot_r13755> ("foo" => Bool::True)

[16:59] <MacVince> ?eval :foo.class

[16:59] <evalbot_r13755> Error:  Unexpected ":" expecting "::"

[17:00] <MacVince> ?eval :22

[17:00] <evalbot_r13755> 1

[17:00] <lanny> Aha.

[17:01] *** ashleyb is now known as ashleyb_

[17:01] <lanny> ?eval my @x = 1..6; for @x -> $v is rw { $_ += 1; }  say @x;

[17:01] <evalbot_r13755> OUTPUT[234567 ] Bool::True

[17:02] <MacVince> Does Perl 6 have symbols like Ruby?

[17:02] <lanny> MacVince: What's a symbol like Ruby?

[17:03] <MacVince> lanny: basically an atomic, immutable string

[17:04] <MacVince> lanny: they look like this: :symbol

[17:04] *** ashleyb_ is now known as ashleyb

[17:05] <lanny> Ah.  Immutables that share memory.  An implementation is free to re-use an immutable without making another.  You don't name the explicitly though.

[17:06] <lanny> * them

[17:08] <Juerd> lanny: It's not wasting time learning, for the people who learn taking courses or by reading books that tell you about such things. But a lot of Perl programmers, myself included, learn from reference manuals and trial and error.

[17:09] *** Aankhen`` joined
[17:09] <Juerd> lanny: And for those programmers, the principle of least surprise is extremely important. It cannot be stressed enough.

[17:09] <lanny> Yes.  I took that path too.

[17:09] <Juerd> This isn't just time invested in learning a new language. It's time wasted in frustration.

[17:10] <Juerd> MacVince: There's very little reason to have symbols, except the cute syntax. We have cuter syntax ::)

[17:10] <Juerd> s/::)/:)/

[17:10] <lanny> Admitting that there is a surprise there it's a single-point surprise.  It bites you, you learn to put is rw on your first parameter, and you go on.

[17:10] <Juerd> lanny: Times how many programmers?

[17:10] <Juerd> lanny: For something that's easily avoided now?

[17:11] <MacVince> Juerd: it was a guy on #python who lamented that Python didn't have symbols like Ruby.  Upon further questioning, his reasoning was that he liked the Ruby syntax.  I just got curious as to whether Perl 6 had that feature.

[17:11] <Juerd> lanny: Have you ever been in a Perl IRC help channel? On Perl Monks? These things must be avoided, really... :)

[17:11] <Juerd> MacVince: We don't need the feature, because our language works differently.

[17:11] <lanny> Ok.  I'll toss your main point right back at you.  How much time are you going to lose reprogramming p5 programmers concerning for @bar {} doesn't work because $_ is ro  or you have to now say for @bar <-> $v {}

[17:11] *** loumz joined
[17:12] <lanny> I haven't visited the channels.  I do provide classes at my work and I have mentored any number of perl newbies and know the joy of, "Well yes what  you did is correct but there is this edge condition..."

[17:13] * MacVince should get off his ass

[17:13] <MacVince> turn on my PC

[17:13] <MacVince> fire up Emacs

[17:13] <Juerd> lanny: They will find that out early ("compile time") instead of while doing important work ("runtime"). Besides that, Perl 5 programmers WILL read documents about differences between the languages. There, a simple notice about this suffices. With the current behaviour, a simple notice AND A DETAILED EXPLANATION OF THE REAL THING, are needed.

[17:13] <MacVince> and then get side tracked by Digg.com and not try to port something to perl 6.

[17:13] <MacVince> :-)

[17:13] <Juerd> lanny: The joy I refer to is answering the same questions over and over and over.

[17:14] <Juerd> lanny: Perl's helpful community can get really annoyed by this. Many people eventually get rude when N+1 asks the same question.

[17:14] <Juerd> lanny: There are a lot of such cases that are fixed in Perl 6. I see a problem in adding a new one when we can identify it.

[17:14] <Juerd> If we can't identify it, well, then we can't avoid it. But if we can... by god, please let's.

[17:15] <Juerd> "fixed" in the "repaired" sense of the word.

[17:15] <Juerd> Gotta go

[17:15] <Juerd> afk

[17:15] <lanny> Juerd: I disagree.   The reason the help channels get the same question N+1 times  is that very few new learners actually read  the docs if they can find a helpful person.

[17:16] <Juerd> No, most of such questions are actually about unintuitive syntax, also known as design flaws.

[17:16] <Juerd> Sorry, really have to go. Just found out.

[17:16] <Juerd> afk

[17:16] <lanny> np

[17:21] <Khisanth> you can't design for every possible brain that exists and will ever exists :)

[17:35] <lanny> Well you can but your programming language  wouldn't do much.  :)

[17:56] *** Aankhen`` joined
[18:02] <svnbot6> r13756 | lanny++ | * undef.t -- :todo on ?(@(undef,)) test

[18:03] *** justatheory joined
[18:19] *** weinig_ is now known as weinig\

[18:19] *** weinig\ is now known as weinig

[18:20] *** shachaf_ joined
[18:33] <Juerd> Khisanth: That's true, but I think this kind of brain is very common amongst Perl programmers.

[18:45] *** yts joined
[18:47] *** shobadobs joined
[18:48] *** penk joined
[18:52] *** MacVince_ joined
[19:00] <svnbot6> r13757 | lanny++ | * reduce.t - :todo<unspecced> on n-ary reduce

[19:21] <pasteling> "fglock" at 200.102.175.122 pasted "Possible Module::Compile bug" (20 lines, 241B) at http://sial.org/pbot/20082

[19:27] <svnbot6> r13758 | fglock++ | [Pugs-Compiler-Rule]

[19:27] <svnbot6> r13758 | fglock++ | - added '>>' and '<<' to Rule parser (currently disabled due to possible M::C parsing bug)

[19:27] <svnbot6> r13758 | fglock++ | - fixed :ratchet newline regex

[19:35] *** frederico joined
[19:40] *** lanny joined
[19:53] <pasteling> "lanny" at 128.107.248.220 pasted "min/max with block broken" (32 lines, 524B) at http://sial.org/pbot/20083

[19:53] *** TimToady joined
[19:53] <lanny> Anyone that knows Prim/Lists.hs help me with a debug?  I know how to fix it but I don't know what it's broken.  Example is in the nopaste.

[19:54] <lanny> s/what/why/

[19:55] <lanny> TimToady: if Array::min and Array::max are supposed to be in Perl 6 they aren't specced.  Lots of tests for them though.

[19:57] <lanny> I know Functions.pod is in Pugs space but not sure about just going in and putting whatever builtins I think should be in there.

[19:58] *** MacVince_ is now known as MacVince

[20:03] <lanny> @tell audreyt bug in src/Pugs/Prim/Lists.hs in op1MinMax' (-- or use the one of the user).  I know how to fix it but I don't know why it's broken.  Example of error in http://sial.org/pbot/20083

[20:03] <lambdabot> Consider it noted.

[20:05] <lanny> @tell audreyt Bug is that @a.min: { $^a <=> $^b } returns the max and vice versa for @a.max; {...}.

[20:05] <lambdabot> Consider it noted.

[20:08] <[particle]> lanny: if you don't find something specced in S* try A* or E*

[20:08] <[particle]> (sometimes things haven't made it into S* yet)

[20:09] <lanny> [particle]: ok.  Sort of obvious how min and max should work but I'll do that for questionable stuff.

[20:09] *** lanny joined
[20:10] <[particle]> D:\usr\local\perl6\doc>ack --perl \.min

[20:10] <[particle]> trunk\design\syn\S03.pod

[20:10] <[particle]> 469:be interrogated for their current C<.min> and C<.max> values (which

[20:11] <lanny> Yes.  And the test file has a p.p6.lang article mentioning them.  But that doesn't really say if they should take code blocks, etc.

[20:12] <lanny> (They should if the current implementation is a guide.)

[20:12] *** DaGo joined
[20:13] <lanny> I need to go make a Wiki page concerning things that seem missing from the specs.  Make one or find one if already made.

[20:19] *** mdiep joined
[20:28] <svnbot6> r13759 | lanny++ | * minmax.t - added examples of min/max returning the max/min

[20:34] *** Aankh|Clone joined
[21:00] *** crem_ joined
[21:02] *** Aankh|Clone is now known as Aankhen``

[21:28] <svnbot6> r13760 | fglock++ | [Pugs-Compiler-Rule]

[21:28] <svnbot6> r13760 | fglock++ | - workaround '<<' bug; no workaround yet for '>>'

[21:28] <svnbot6> r13760 | fglock++ | - implemented /<<word/ and /word>>/

[21:44] *** Bugi joined
[22:10] <svnbot6> r13761 | lanny++ | * os/system.t - :todo failing test that :depends<0 but True>

[22:25] *** imago joined
[22:26] *** imago is now known as gunya

[22:50] <Juerd> Is =<> a special case, or does <> always return $*ARGS?

[22:50] *** MacVince joined
[22:50] * Juerd would be surprised if removing foo from <foo> would make <> be something different.

[23:07] *** Limbic_Region joined
[23:08] *** ashleyb joined
[23:13] *** weinig is now known as weinig|food

[23:18] *** kanru joined
[23:31] *** weinig|food is now known as weinig

[23:39] *** gnuvince joined
[23:40] <gnuvince> I want to add tests to make sure that map {...} @array; is invalid and that map {...}, @array; is correct.  Should I put that in the syntax folder?

[23:41] *** kanru joined
